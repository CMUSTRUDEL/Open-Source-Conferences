Title: Functional UIs and Unidirectional Dataflow by Mikael Brevik at JSConf Budapest 2015
Publication date: 2020-09-22
Playlist: JSConf Budapest 2015
Description: 
	Slides: http://www.slideshare.net/mikaelbr/budapest-49024114

http://2015.jsconfbp.com/#mikaelbrevik

Let us bring back the days where we could write declarative representations of how we want our UI components to work. We should be able to read our code from top to bottom and intuitively know what the output will be, just like the good old HTML, but with the power of functional programming. 

In this talk we'll explore bringing functional programming into views. Instead of moving logic to markup through weird DSLs we bring expressive views into the programming language. We'll see how to create a UI where we have composable, pure and referentially transparent components; components with no side-effects and predictable output. We couple this with immutable data and components with single responsibilities, and we can get a fast and smart way to build UIs with a unidirectional flow and a simpler static mental model.
Captions: 
	00:00:12,799 --> 00:00:17,680
so

00:00:14,160 --> 00:00:19,680
you can hear me is it on yeah hi

00:00:17,680 --> 00:00:20,960
as you said my name is michael this is

00:00:19,680 --> 00:00:23,439
my twitter handle

00:00:20,960 --> 00:00:24,160
right there and today we'll be talking

00:00:23,439 --> 00:00:27,279
about

00:00:24,160 --> 00:00:30,400
how to apply basic basic uh

00:00:27,279 --> 00:00:34,239
functional programming to and apply to

00:00:30,400 --> 00:00:34,960
uis we'll talk a bit about a simple form

00:00:34,239 --> 00:00:37,600
of united

00:00:34,960 --> 00:00:38,559
unidirectional data flow and how we

00:00:37,600 --> 00:00:41,680
could

00:00:38,559 --> 00:00:43,680
make our views simpler so

00:00:41,680 --> 00:00:45,200
kind of touching about what andre was

00:00:43,680 --> 00:00:47,760
talking about earlier but

00:00:45,200 --> 00:00:49,360
just focused on the particular

00:00:47,760 --> 00:00:52,480
particular views

00:00:49,360 --> 00:00:53,600
so the goal for this talk is to try to

00:00:52,480 --> 00:00:55,920
make us

00:00:53,600 --> 00:00:57,760
to get us to reflect about how we build

00:00:55,920 --> 00:00:59,039
our front-end systems maybe give some

00:00:57,760 --> 00:00:59,680
inspiration to how we can make it

00:00:59,039 --> 00:01:03,359
simpler

00:00:59,680 --> 00:01:03,760
in terms of complexity so by thinking of

00:01:03,359 --> 00:01:06,560
our

00:01:03,760 --> 00:01:08,479
entire application as a function of

00:01:06,560 --> 00:01:10,000
state and abstracting the input and

00:01:08,479 --> 00:01:12,479
output to the

00:01:10,000 --> 00:01:14,400
far edges of our system we can create a

00:01:12,479 --> 00:01:18,240
predictable and easy to maintain

00:01:14,400 --> 00:01:20,159
application so along the way for this

00:01:18,240 --> 00:01:22,320
we'll examine how we can use the most

00:01:20,159 --> 00:01:24,799
basic building blocks we have functions

00:01:22,320 --> 00:01:25,439
and how we can use composability for

00:01:24,799 --> 00:01:28,720
building

00:01:25,439 --> 00:01:30,640
more functional style views

00:01:28,720 --> 00:01:32,960
and and compose different functions to

00:01:30,640 --> 00:01:36,079
more smarter functions

00:01:32,960 --> 00:01:39,360
so first so

00:01:36,079 --> 00:01:42,079
how did we get to this stage how

00:01:39,360 --> 00:01:44,240
do we really need to think about how we

00:01:42,079 --> 00:01:46,159
make uis how we make

00:01:44,240 --> 00:01:48,399
view programming is it necessary to

00:01:46,159 --> 00:01:50,320
re-evaluate this

00:01:48,399 --> 00:01:52,079
so in the beginning we had the

00:01:50,320 --> 00:01:54,720
traditional server client

00:01:52,079 --> 00:01:55,840
relationship it was an easy request

00:01:54,720 --> 00:01:58,799
response render

00:01:55,840 --> 00:02:00,479
that was it so simple flow what was

00:01:58,799 --> 00:02:01,680
rendered on the client was our system

00:02:00,479 --> 00:02:04,079
output

00:02:01,680 --> 00:02:04,880
if we did an up update even if it's just

00:02:04,079 --> 00:02:07,280
a tiny bit

00:02:04,880 --> 00:02:09,039
of updates on our page we had to do a

00:02:07,280 --> 00:02:12,080
complete refresh

00:02:09,039 --> 00:02:14,959
so it had had its drawbacks obviously

00:02:12,080 --> 00:02:15,599
but we at least we had a complete static

00:02:14,959 --> 00:02:19,200
models

00:02:15,599 --> 00:02:21,200
of our page so moving on the web matured

00:02:19,200 --> 00:02:23,520
we found

00:02:21,200 --> 00:02:25,200
we had a need to do more dynamic updates

00:02:23,520 --> 00:02:28,000
we wouldn't want to have

00:02:25,200 --> 00:02:28,879
just changing a text in in one paragraph

00:02:28,000 --> 00:02:32,319
on our page

00:02:28,879 --> 00:02:34,400
and do an entire new page reload with a

00:02:32,319 --> 00:02:35,360
new http request a new response a new

00:02:34,400 --> 00:02:38,720
render

00:02:35,360 --> 00:02:40,800
so we wanted a more dynamic

00:02:38,720 --> 00:02:41,840
way of doing this so we started moving

00:02:40,800 --> 00:02:44,080
more code

00:02:41,840 --> 00:02:45,200
from the server to the client so instead

00:02:44,080 --> 00:02:48,160
of sending all

00:02:45,200 --> 00:02:50,000
our entire structure in our entire

00:02:48,160 --> 00:02:53,280
content on initial load

00:02:50,000 --> 00:02:55,440
we do now has ajax requests and

00:02:53,280 --> 00:02:57,680
dynamically create our content on the

00:02:55,440 --> 00:03:00,480
client side in many cases

00:02:57,680 --> 00:03:02,480
so what happens actually is we build up

00:03:00,480 --> 00:03:05,920
a massive time dependent state

00:03:02,480 --> 00:03:07,920
and a representation of the dom and we

00:03:05,920 --> 00:03:09,200
no longer have these complete static

00:03:07,920 --> 00:03:13,120
models as we have with

00:03:09,200 --> 00:03:15,440
just plain old html so

00:03:13,120 --> 00:03:16,800
we can think of our pages and

00:03:15,440 --> 00:03:19,440
applications

00:03:16,800 --> 00:03:20,319
like multiple pieces of individual code

00:03:19,440 --> 00:03:22,400
which in some way

00:03:20,319 --> 00:03:23,440
are connected and need to communicate

00:03:22,400 --> 00:03:26,000
with each other

00:03:23,440 --> 00:03:28,080
so the problem is we often have our

00:03:26,000 --> 00:03:30,959
applications and we

00:03:28,080 --> 00:03:32,080
don't have a clear direction of how

00:03:30,959 --> 00:03:36,400
these messages

00:03:32,080 --> 00:03:39,040
go so our pieces of code can send

00:03:36,400 --> 00:03:40,080
messages in multiple directions and

00:03:39,040 --> 00:03:41,840
further

00:03:40,080 --> 00:03:43,840
further our pieces can be tightly

00:03:41,840 --> 00:03:47,920
coupled

00:03:43,840 --> 00:03:49,440
so in many cases it's impossible to just

00:03:47,920 --> 00:03:51,840
look at one piece of code

00:03:49,440 --> 00:03:53,360
and imagine what the output will be what

00:03:51,840 --> 00:03:55,280
if two pieces share some

00:03:53,360 --> 00:03:56,879
sort of data and one of the pieces

00:03:55,280 --> 00:04:00,640
changes that data what happens to the

00:03:56,879 --> 00:04:03,040
other one so

00:04:00,640 --> 00:04:04,480
this is this is a model that needs to be

00:04:03,040 --> 00:04:07,680
simplified we need to

00:04:04,480 --> 00:04:08,640
be able to reason about our system in a

00:04:07,680 --> 00:04:11,439
much clearer way

00:04:08,640 --> 00:04:12,319
so we have solved many of these problems

00:04:11,439 --> 00:04:14,959
already

00:04:12,319 --> 00:04:16,799
just not in a ui context and we can use

00:04:14,959 --> 00:04:18,959
a more functional style approach to our

00:04:16,799 --> 00:04:20,720
systems

00:04:18,959 --> 00:04:22,560
functional programming can allow us to

00:04:20,720 --> 00:04:24,720
think about our code

00:04:22,560 --> 00:04:26,560
in simpler ways just having two

00:04:24,720 --> 00:04:27,120
connection points to our components or

00:04:26,560 --> 00:04:30,720
to our

00:04:27,120 --> 00:04:33,360
pieces of code its input and its output

00:04:30,720 --> 00:04:36,000
so instead of having the

00:04:33,360 --> 00:04:38,479
multi-directional

00:04:36,000 --> 00:04:41,120
different communications bar by our

00:04:38,479 --> 00:04:44,320
pieces this will cause a tree

00:04:41,120 --> 00:04:45,759
so or even if our system gets large

00:04:44,320 --> 00:04:46,880
enough you can see them as multiple

00:04:45,759 --> 00:04:49,199
trees connected

00:04:46,880 --> 00:04:50,720
yet again by trees so you can think

00:04:49,199 --> 00:04:54,000
about a tree

00:04:50,720 --> 00:04:57,440
of trees if you like so

00:04:54,000 --> 00:05:00,880
this looks familiar though to our old

00:04:57,440 --> 00:05:02,960
ways of of thinking about content just

00:05:00,880 --> 00:05:04,160
just like the html pages we had we can

00:05:02,960 --> 00:05:07,199
read this code

00:05:04,160 --> 00:05:09,759
from top to bottom and

00:05:07,199 --> 00:05:11,680
statically in our head mentally reason

00:05:09,759 --> 00:05:14,880
about what the output will be

00:05:11,680 --> 00:05:18,320
so to achieve this kind of things our

00:05:14,880 --> 00:05:20,160
pieces need to show some certain traits

00:05:18,320 --> 00:05:23,199
one trait we'll talk about is

00:05:20,160 --> 00:05:26,160
referential transparency and purity

00:05:23,199 --> 00:05:26,720
so let's just talk about function for a

00:05:26,160 --> 00:05:29,120
moment

00:05:26,720 --> 00:05:29,919
andrei uh touched upon this as well but

00:05:29,120 --> 00:05:32,960
this most

00:05:29,919 --> 00:05:36,000
basic form is just the ability to

00:05:32,960 --> 00:05:38,720
group a set of expressions

00:05:36,000 --> 00:05:40,080
which can be reused in different time

00:05:38,720 --> 00:05:42,800
and place in our system

00:05:40,080 --> 00:05:43,840
in other words a function is a set of

00:05:42,800 --> 00:05:45,919
operations

00:05:43,840 --> 00:05:46,960
which takes some information transform

00:05:45,919 --> 00:05:50,000
it and gives

00:05:46,960 --> 00:05:52,960
an another piece of information's

00:05:50,000 --> 00:05:54,240
information as outputs so referential

00:05:52,960 --> 00:05:56,880
transparent functions

00:05:54,240 --> 00:05:58,720
are a subset of the of functions they

00:05:56,880 --> 00:06:02,800
have a specific trait

00:05:58,720 --> 00:06:05,199
then in simple words

00:06:02,800 --> 00:06:07,039
a function is referentially transparent

00:06:05,199 --> 00:06:09,520
f at invocation level

00:06:07,039 --> 00:06:11,840
we can swap out the function call with

00:06:09,520 --> 00:06:16,160
the result of the invocation

00:06:11,840 --> 00:06:18,840
so let's take a for instance to see that

00:06:16,160 --> 00:06:20,400
this isn't as advanced that i made it to

00:06:18,840 --> 00:06:22,479
sound we can

00:06:20,400 --> 00:06:24,240
have a square function which we should

00:06:22,479 --> 00:06:28,240
if you pass the number two

00:06:24,240 --> 00:06:29,039
it results um the number four so we can

00:06:28,240 --> 00:06:31,199
swap out just

00:06:29,039 --> 00:06:32,479
our invocation with the number four and

00:06:31,199 --> 00:06:36,880
our system would

00:06:32,479 --> 00:06:36,880
still behave in the exact same way

00:06:37,199 --> 00:06:41,759
expressions such as this one can also be

00:06:39,840 --> 00:06:45,199
referential transparent so in javascript

00:06:41,759 --> 00:06:47,039
we have built-in operations like add

00:06:45,199 --> 00:06:48,639
and that is by nature referential

00:06:47,039 --> 00:06:49,759
transparent we're just adding two

00:06:48,639 --> 00:06:53,199
numbers together

00:06:49,759 --> 00:06:54,800
you don't do any other effects on the

00:06:53,199 --> 00:06:55,440
system by just adding those two numbers

00:06:54,800 --> 00:06:59,520
together

00:06:55,440 --> 00:07:02,880
so we can think of a simple

00:06:59,520 --> 00:07:03,680
plus or addition as the result of its

00:07:02,880 --> 00:07:05,680
edition

00:07:03,680 --> 00:07:07,440
because the operation itself is

00:07:05,680 --> 00:07:09,520
referentially transparent

00:07:07,440 --> 00:07:11,759
so replacing our expression with the

00:07:09,520 --> 00:07:14,400
result it wouldn't change and alter the

00:07:11,759 --> 00:07:16,960
behavior of the system at all

00:07:14,400 --> 00:07:17,840
in code this would look um much like

00:07:16,960 --> 00:07:20,479
you're you're

00:07:17,840 --> 00:07:21,039
expected to so we can have a function

00:07:20,479 --> 00:07:22,800
square

00:07:21,039 --> 00:07:24,080
return returning the number multiplied

00:07:22,800 --> 00:07:27,199
by itself

00:07:24,080 --> 00:07:30,479
and we can think of two

00:07:27,199 --> 00:07:32,880
invocations adding together as just

00:07:30,479 --> 00:07:33,680
two times one invocation or we can think

00:07:32,880 --> 00:07:36,880
of it as

00:07:33,680 --> 00:07:40,319
two times the result of one invocation

00:07:36,880 --> 00:07:43,680
or just a resulting object which is

00:07:40,319 --> 00:07:46,240
even though it's just a scholar value

00:07:43,680 --> 00:07:48,479
this causes of course predictability

00:07:46,240 --> 00:07:51,599
because they're deterministic right

00:07:48,479 --> 00:07:53,840
so no matter when or where

00:07:51,599 --> 00:07:56,400
we invoke our functions the output will

00:07:53,840 --> 00:07:59,840
be the exact same thing

00:07:56,400 --> 00:07:59,840
given that the input is the same

00:08:00,479 --> 00:08:04,720
so that's testability as well our

00:08:03,360 --> 00:08:08,080
function and building blocks are

00:08:04,720 --> 00:08:08,080
predictable they are testable

00:08:09,199 --> 00:08:12,639
just as we can replace expressions of

00:08:11,280 --> 00:08:14,960
adding two numbers together

00:08:12,639 --> 00:08:16,720
with at the results we can also simplify

00:08:14,960 --> 00:08:20,560
series of function indications

00:08:16,720 --> 00:08:24,160
or our series of function calls

00:08:20,560 --> 00:08:26,000
if you will so multiple

00:08:24,160 --> 00:08:28,639
function calls can be thought of as one

00:08:26,000 --> 00:08:28,639
function call

00:08:28,720 --> 00:08:32,399
or just the last call in our message

00:08:31,199 --> 00:08:34,640
queue or message

00:08:32,399 --> 00:08:36,320
call stack so we can group a series of

00:08:34,640 --> 00:08:38,560
functions in any way or permutation we

00:08:36,320 --> 00:08:38,560
want

00:08:38,719 --> 00:08:43,120
this helps for for thinking about the

00:08:40,719 --> 00:08:45,839
large tree that we had from before

00:08:43,120 --> 00:08:46,800
so instead of thinking about it as as a

00:08:45,839 --> 00:08:49,440
very grainy

00:08:46,800 --> 00:08:50,320
tree we can mentally skip all the

00:08:49,440 --> 00:08:51,760
details

00:08:50,320 --> 00:08:54,399
and think of our tree as a more much

00:08:51,760 --> 00:08:57,120
more simplified three

00:08:54,399 --> 00:08:58,640
so again this requires our functions to

00:08:57,120 --> 00:09:02,160
follow the same pattern they need

00:08:58,640 --> 00:09:05,680
they need to be referential transparent

00:09:02,160 --> 00:09:06,480
so with referential transparency we also

00:09:05,680 --> 00:09:10,160
can

00:09:06,480 --> 00:09:12,480
have composability so

00:09:10,160 --> 00:09:16,000
we can derive new functions that are

00:09:12,480 --> 00:09:18,160
also referential transparent

00:09:16,000 --> 00:09:19,040
we can take two functions with the same

00:09:18,160 --> 00:09:21,200
argument list

00:09:19,040 --> 00:09:22,320
and the same return type and we can

00:09:21,200 --> 00:09:25,839
compose them

00:09:22,320 --> 00:09:28,480
into a new derived function

00:09:25,839 --> 00:09:30,000
composing can sometimes be denoted as

00:09:28,480 --> 00:09:32,640
dots but in javascript

00:09:30,000 --> 00:09:34,800
of course it's just a function so a

00:09:32,640 --> 00:09:36,640
function taking one or more functions

00:09:34,800 --> 00:09:39,040
and returning a function function yet

00:09:36,640 --> 00:09:41,440
again so this is called a higher order

00:09:39,040 --> 00:09:41,440
function

00:09:41,600 --> 00:09:45,440
composability of functions can allow us

00:09:43,519 --> 00:09:46,399
to build larger systems larger

00:09:45,440 --> 00:09:49,440
applications

00:09:46,399 --> 00:09:51,040
by just by adding multiple small pieces

00:09:49,440 --> 00:09:53,360
together

00:09:51,040 --> 00:09:55,120
and each of those individual pieces are

00:09:53,360 --> 00:09:56,640
easy to understand and simple to

00:09:55,120 --> 00:10:00,160
understand

00:09:56,640 --> 00:10:03,200
so what this buys is the potentiality

00:10:00,160 --> 00:10:04,720
to look at one single piece and without

00:10:03,200 --> 00:10:06,800
even knowing the rest of the system

00:10:04,720 --> 00:10:09,839
just by knowing its input you can see

00:10:06,800 --> 00:10:09,839
what it should output

00:10:10,800 --> 00:10:15,839
another way to use composability is to

00:10:13,600 --> 00:10:17,279
attach a predefined set of arguments to

00:10:15,839 --> 00:10:20,399
a function

00:10:17,279 --> 00:10:22,720
so this is called partial application

00:10:20,399 --> 00:10:23,600
probably heard about this we can derive

00:10:22,720 --> 00:10:25,760
a new function

00:10:23,600 --> 00:10:27,760
which takes any norm any number of

00:10:25,760 --> 00:10:29,519
arguments arbitrary number of arguments

00:10:27,760 --> 00:10:30,959
fewer than the original function

00:10:29,519 --> 00:10:34,320
function

00:10:30,959 --> 00:10:37,120
so we gradually build up our

00:10:34,320 --> 00:10:38,399
application one functional one compose

00:10:37,120 --> 00:10:41,040
composing at a time

00:10:38,399 --> 00:10:42,399
so by having simple building blocks we

00:10:41,040 --> 00:10:45,519
can build our application

00:10:42,399 --> 00:10:48,880
one step at a time one important feature

00:10:45,519 --> 00:10:49,839
functions that are is referential

00:10:48,880 --> 00:10:53,600
transparent

00:10:49,839 --> 00:10:54,160
as purity so we can't have side effects

00:10:53,600 --> 00:10:57,920
between

00:10:54,160 --> 00:11:00,399
functions not one code inside

00:10:57,920 --> 00:11:01,440
one function can alter the behavior of a

00:11:00,399 --> 00:11:03,200
different function

00:11:01,440 --> 00:11:07,040
or a different section in your

00:11:03,200 --> 00:11:08,800
application except for what it outputs

00:11:07,040 --> 00:11:10,560
unless often we can have these kind of

00:11:08,800 --> 00:11:11,920
side effects without even knowing it in

00:11:10,560 --> 00:11:15,279
our applications

00:11:11,920 --> 00:11:17,680
so everyone probably know this

00:11:15,279 --> 00:11:18,720
javascript objects are per default

00:11:17,680 --> 00:11:21,600
mutable

00:11:18,720 --> 00:11:22,560
so this means that two functions f2

00:11:21,600 --> 00:11:26,000
functions get past

00:11:22,560 --> 00:11:27,200
the same object and that object is

00:11:26,000 --> 00:11:29,680
changed in some way

00:11:27,200 --> 00:11:30,880
inside one of the functions the other

00:11:29,680 --> 00:11:33,680
function has to leave

00:11:30,880 --> 00:11:34,160
liv with the consequences of that change

00:11:33,680 --> 00:11:37,519
so

00:11:34,160 --> 00:11:40,560
this is a fairly common side effect and

00:11:37,519 --> 00:11:42,480
often it's fairly common to have this

00:11:40,560 --> 00:11:45,920
sort of bugs in larger systems

00:11:42,480 --> 00:11:48,959
you can pass in object options

00:11:45,920 --> 00:11:49,279
options objects to two sets of plugins

00:11:48,959 --> 00:11:51,600
or

00:11:49,279 --> 00:11:53,600
two sets of code and one of them changes

00:11:51,600 --> 00:11:55,519
the object

00:11:53,600 --> 00:11:57,519
and the other one then has to live with

00:11:55,519 --> 00:12:01,279
their consequences

00:11:57,519 --> 00:12:03,279
so this doesn't all only apply to

00:12:01,279 --> 00:12:06,160
objects in a sense it's all values

00:12:03,279 --> 00:12:08,800
passed by reference

00:12:06,160 --> 00:12:11,839
so this is one way our functions can be

00:12:08,800 --> 00:12:14,320
tightly coupled between them

00:12:11,839 --> 00:12:15,760
there might be a better way to avoid the

00:12:14,320 --> 00:12:18,000
shared mutable states

00:12:15,760 --> 00:12:19,920
of objects leaking through our system

00:12:18,000 --> 00:12:21,519
instead of passing mutable objects to

00:12:19,920 --> 00:12:21,920
our functions to our building blocks we

00:12:21,519 --> 00:12:25,839
can use

00:12:21,920 --> 00:12:25,839
immutable objects

00:12:25,920 --> 00:12:31,920
immutable objects works in a fairly

00:12:29,680 --> 00:12:33,839
fairly same way as other objects but

00:12:31,920 --> 00:12:35,600
instead of altering the existing object

00:12:33,839 --> 00:12:37,120
you would create a new object

00:12:35,600 --> 00:12:40,480
when it's changed and you would have to

00:12:37,120 --> 00:12:43,519
store a reference to a new object

00:12:40,480 --> 00:12:44,959
this means the original object is

00:12:43,519 --> 00:12:46,079
unchanged and we can still have a

00:12:44,959 --> 00:12:49,519
reference to it

00:12:46,079 --> 00:12:50,240
not only will we avoid accidental shared

00:12:49,519 --> 00:12:52,079
state

00:12:50,240 --> 00:12:54,399
but we will also be able to use and

00:12:52,079 --> 00:12:56,720
reuse our old structures in different

00:12:54,399 --> 00:12:56,720
ways

00:12:58,560 --> 00:13:02,800
as we always create new references and

00:13:00,800 --> 00:13:03,680
new objects when we change or swap any

00:13:02,800 --> 00:13:07,760
of the value

00:13:03,680 --> 00:13:09,839
of immutable data structure

00:13:07,760 --> 00:13:11,680
we can easily check if two objects are

00:13:09,839 --> 00:13:13,760
the same

00:13:11,680 --> 00:13:16,320
there's no need to have deep value

00:13:13,760 --> 00:13:18,320
checks or

00:13:16,320 --> 00:13:19,360
the only thing we have to do is check if

00:13:18,320 --> 00:13:22,880
two references

00:13:19,360 --> 00:13:26,000
references point to the same memory slot

00:13:22,880 --> 00:13:29,120
if they are their objects are equal

00:13:26,000 --> 00:13:32,160
so this is a

00:13:29,120 --> 00:13:35,200
very cheap operation reference checks

00:13:32,160 --> 00:13:37,680
aren't costly at all in contrast to

00:13:35,200 --> 00:13:38,639
value deep value checks which can be

00:13:37,680 --> 00:13:40,639
very costly

00:13:38,639 --> 00:13:43,040
especially with large structures and

00:13:40,639 --> 00:13:46,639
large trees

00:13:43,040 --> 00:13:47,440
it might it might sound like immutable

00:13:46,639 --> 00:13:51,839
structures

00:13:47,440 --> 00:13:54,480
are not very memory efficient but that's

00:13:51,839 --> 00:13:55,199
in most cases not not true so we can use

00:13:54,480 --> 00:13:58,240
something called

00:13:55,199 --> 00:14:01,600
persistent data structure in which

00:13:58,240 --> 00:14:04,880
if you change small bits of data

00:14:01,600 --> 00:14:08,240
in our larger structure we only swap out

00:14:04,880 --> 00:14:08,880
the new data in a particular tree and we

00:14:08,240 --> 00:14:12,560
share

00:14:08,880 --> 00:14:12,560
the old data between them

00:14:13,199 --> 00:14:17,120
by having immutable values this way we

00:14:15,600 --> 00:14:19,600
can pass the same object

00:14:17,120 --> 00:14:20,560
to different functions and not to worry

00:14:19,600 --> 00:14:22,800
about

00:14:20,560 --> 00:14:25,440
having accidental shear state not worry

00:14:22,800 --> 00:14:27,040
about if the object has changed or not

00:14:25,440 --> 00:14:28,800
so the only part we're concerned about

00:14:27,040 --> 00:14:31,839
is what the function outputs this is a

00:14:28,800 --> 00:14:31,839
simple simple contract

00:14:32,399 --> 00:14:36,399
everything we're seeing can be applied

00:14:34,320 --> 00:14:39,120
to components as well

00:14:36,399 --> 00:14:40,959
so what is a component most of you have

00:14:39,120 --> 00:14:44,240
probably seen react

00:14:40,959 --> 00:14:46,560
react or any other virtual dom or

00:14:44,240 --> 00:14:48,560
library or framework or what have you

00:14:46,560 --> 00:14:51,600
can allow us to write

00:14:48,560 --> 00:14:52,399
not particularly um you won't write html

00:14:51,600 --> 00:14:54,800
templates

00:14:52,399 --> 00:14:57,120
but you will write html representations

00:14:54,800 --> 00:15:00,079
either using jsx or just plain all

00:14:57,120 --> 00:15:03,760
javascript functions and these libraries

00:15:00,079 --> 00:15:06,000
have smart ways of updating your dom

00:15:03,760 --> 00:15:09,040
they do what they do is they build up an

00:15:06,000 --> 00:15:11,440
internal abstract tree of

00:15:09,040 --> 00:15:13,120
abstract dom tree and only when the

00:15:11,440 --> 00:15:14,800
internal representation has changed the

00:15:13,120 --> 00:15:18,480
appropriate update state

00:15:14,800 --> 00:15:22,720
steps get taken to output the actual daw

00:15:18,480 --> 00:15:27,279
this the html representations are often

00:15:22,720 --> 00:15:30,399
called components

00:15:27,279 --> 00:15:31,199
a component is as a small piece of view

00:15:30,399 --> 00:15:35,199
code

00:15:31,199 --> 00:15:37,440
just like html templates elements sorry

00:15:35,199 --> 00:15:39,360
and contain one or more elements

00:15:37,440 --> 00:15:42,160
themselves but it's in code

00:15:39,360 --> 00:15:43,199
so by having our components as a part of

00:15:42,160 --> 00:15:45,360
our programming

00:15:43,199 --> 00:15:46,639
language we move views into a more

00:15:45,360 --> 00:15:48,639
powerful environment

00:15:46,639 --> 00:15:50,560
instead of moving javascript into a less

00:15:48,639 --> 00:15:53,120
powerful one

00:15:50,560 --> 00:15:54,320
html elements are very restricted by

00:15:53,120 --> 00:15:56,079
nature

00:15:54,320 --> 00:15:57,920
they can only communicate with

00:15:56,079 --> 00:16:01,839
themselves and with each other

00:15:57,920 --> 00:16:03,519
by using text or numbers as attributes

00:16:01,839 --> 00:16:05,759
this is not the case with components

00:16:03,519 --> 00:16:09,279
components are much more powerful and

00:16:05,759 --> 00:16:11,519
can communicate much clearer

00:16:09,279 --> 00:16:13,279
with advanced structures we can pass

00:16:11,519 --> 00:16:15,920
objects

00:16:13,279 --> 00:16:17,600
and as we know the way javascript works

00:16:15,920 --> 00:16:18,480
when you can pass objects you also can

00:16:17,600 --> 00:16:21,519
pass lists

00:16:18,480 --> 00:16:22,880
you can last pass functions and you can

00:16:21,519 --> 00:16:26,480
even pass something like

00:16:22,880 --> 00:16:27,040
observables components can have the same

00:16:26,480 --> 00:16:28,959
traits

00:16:27,040 --> 00:16:30,399
as regular function they can be

00:16:28,959 --> 00:16:33,680
referential transparent

00:16:30,399 --> 00:16:33,680
and they can be composable

00:16:34,000 --> 00:16:38,000
so the same way we can derive a new

00:16:36,079 --> 00:16:40,480
function we can also derive a new

00:16:38,000 --> 00:16:42,720
component

00:16:40,480 --> 00:16:44,560
for instance we can compose two

00:16:42,720 --> 00:16:47,519
components creating a new component

00:16:44,560 --> 00:16:50,639
which is the combination of the two

00:16:47,519 --> 00:16:52,959
we call these we can call them higher

00:16:50,639 --> 00:16:56,959
order components

00:16:52,959 --> 00:16:59,680
so we can also partially apply

00:16:56,959 --> 00:17:01,279
components using higher order components

00:16:59,680 --> 00:17:02,720
by partially applying some bit of

00:17:01,279 --> 00:17:04,640
information to a component

00:17:02,720 --> 00:17:06,400
we can create a component that is much

00:17:04,640 --> 00:17:08,319
more semantically clear

00:17:06,400 --> 00:17:09,679
and is much more focused and what its

00:17:08,319 --> 00:17:11,760
goal is

00:17:09,679 --> 00:17:13,439
components can work exactly like

00:17:11,760 --> 00:17:17,120
functions

00:17:13,439 --> 00:17:20,240
stateless pieces of code which transform

00:17:17,120 --> 00:17:23,919
one information one input and result to

00:17:20,240 --> 00:17:23,919
another information as an output

00:17:25,520 --> 00:17:30,640
of course we can use other functional

00:17:27,520 --> 00:17:33,120
patterns of functional building tools

00:17:30,640 --> 00:17:35,440
for our components as well we can use

00:17:33,120 --> 00:17:38,480
map we can use filter we can use reduce

00:17:35,440 --> 00:17:39,679
or even decorators so by having

00:17:38,480 --> 00:17:41,200
by applying different functional

00:17:39,679 --> 00:17:41,919
patterns we can take very simple

00:17:41,200 --> 00:17:43,919
components

00:17:41,919 --> 00:17:44,960
deriving components with more more

00:17:43,919 --> 00:17:48,720
functionality

00:17:44,960 --> 00:17:48,720
just by adding small pieces together

00:17:49,039 --> 00:17:56,080
so so a huge huge advantage of this

00:17:53,280 --> 00:17:57,120
is that we're still able to use our

00:17:56,080 --> 00:17:58,640
components

00:17:57,120 --> 00:18:00,480
in different ways in different settings

00:17:58,640 --> 00:18:02,400
in different time our

00:18:00,480 --> 00:18:05,360
individual components and the new

00:18:02,400 --> 00:18:05,360
derived functions

00:18:06,640 --> 00:18:11,520
we can output our components to the dom

00:18:09,039 --> 00:18:14,559
by using function that takes a component

00:18:11,520 --> 00:18:16,240
and a mounting point this can

00:18:14,559 --> 00:18:17,919
this can be achieved by using something

00:18:16,240 --> 00:18:19,679
like react virtual dom

00:18:17,919 --> 00:18:21,600
any any virtual dom implementation

00:18:19,679 --> 00:18:23,600
really so

00:18:21,600 --> 00:18:24,720
this would diff the output we had with

00:18:23,600 --> 00:18:26,320
the actual dom just perform the

00:18:24,720 --> 00:18:28,640
observation operations needed with the

00:18:26,320 --> 00:18:31,200
dom right

00:18:28,640 --> 00:18:32,000
but the important part here is we update

00:18:31,200 --> 00:18:35,280
the dom to

00:18:32,000 --> 00:18:36,960
reflect our truth our truth in the code

00:18:35,280 --> 00:18:39,600
not the dom being the source of the

00:18:36,960 --> 00:18:42,960
truth itself

00:18:39,600 --> 00:18:44,320
and of course our system is referential

00:18:42,960 --> 00:18:47,200
transparent is pure

00:18:44,320 --> 00:18:49,440
so we can so we can have unpredictable

00:18:47,200 --> 00:18:51,520
output and testable output

00:18:49,440 --> 00:18:52,559
we can do rendering multiple times with

00:18:51,520 --> 00:18:54,160
the same input

00:18:52,559 --> 00:18:56,080
and the system wouldn't actually do any

00:18:54,160 --> 00:18:57,679
dom operations

00:18:56,080 --> 00:18:59,600
it might seem like we have a problem

00:18:57,679 --> 00:19:01,200
here though it seems like we

00:18:59,600 --> 00:19:03,520
continuously

00:19:01,200 --> 00:19:05,280
communicate with a rather huge side

00:19:03,520 --> 00:19:06,799
effect the dom

00:19:05,280 --> 00:19:09,520
this will break our system being pure

00:19:06,799 --> 00:19:12,559
and referentially transparent

00:19:09,520 --> 00:19:14,320
but even if we have immutability and we

00:19:12,559 --> 00:19:16,080
take care of having all our functions

00:19:14,320 --> 00:19:18,880
pure all our components pure

00:19:16,080 --> 00:19:20,240
and referentially transparent we still

00:19:18,880 --> 00:19:22,000
have to integrate with the dom

00:19:20,240 --> 00:19:23,440
we still have to have some output for

00:19:22,000 --> 00:19:25,280
our system

00:19:23,440 --> 00:19:27,440
the dom is just a massive blob of states

00:19:25,280 --> 00:19:27,919
and a huge mutated side effects allowing

00:19:27,440 --> 00:19:30,799
our

00:19:27,919 --> 00:19:32,000
functions to be tightly coupled so just

00:19:30,799 --> 00:19:34,160
as we saw with actual

00:19:32,000 --> 00:19:36,160
accidental shared state between objects

00:19:34,160 --> 00:19:39,520
we can have accidental shared state

00:19:36,160 --> 00:19:40,960
and tightly coupled through the dom

00:19:39,520 --> 00:19:42,880
if all our building blocks can

00:19:40,960 --> 00:19:44,480
communicate directly with the dom

00:19:42,880 --> 00:19:46,960
directly to the integration point that

00:19:44,480 --> 00:19:49,280
is the dom our functions aren't pure

00:19:46,960 --> 00:19:53,840
they aren't referentially transparent

00:19:49,280 --> 00:19:53,840
even if they may look that way initially

00:19:54,000 --> 00:19:57,840
so there's no avoiding the integration

00:19:56,720 --> 00:20:00,400
points

00:19:57,840 --> 00:20:02,000
but we can do we can move all the

00:20:00,400 --> 00:20:04,000
integration points all the

00:20:02,000 --> 00:20:05,440
stateful communication to the far edges

00:20:04,000 --> 00:20:08,480
of our system

00:20:05,440 --> 00:20:09,600
to the far edges of our data data flow

00:20:08,480 --> 00:20:12,159
graph

00:20:09,600 --> 00:20:14,799
we don't have to worry about the state

00:20:12,159 --> 00:20:16,559
leaking through our applications

00:20:14,799 --> 00:20:18,240
we can have one top global immutable

00:20:16,559 --> 00:20:20,559
structure which which holds

00:20:18,240 --> 00:20:22,480
all of our information we can pass the

00:20:20,559 --> 00:20:24,480
global structure as input to our top

00:20:22,480 --> 00:20:27,520
components and that component

00:20:24,480 --> 00:20:28,159
can distribute its state as input to the

00:20:27,520 --> 00:20:31,360
different

00:20:28,159 --> 00:20:32,559
objects this is also true for

00:20:31,360 --> 00:20:34,080
integrating with a dom

00:20:32,559 --> 00:20:35,679
remember dom is just the integration

00:20:34,080 --> 00:20:39,200
point it's just our

00:20:35,679 --> 00:20:41,440
output by having the data fetching

00:20:39,200 --> 00:20:43,360
integration in the at the beginning

00:20:41,440 --> 00:20:44,799
and let the data flow through our system

00:20:43,360 --> 00:20:48,480
to its end output

00:20:44,799 --> 00:20:50,480
to the dom this can

00:20:48,480 --> 00:20:52,080
uh simplify how we can think about

00:20:50,480 --> 00:20:54,000
system and

00:20:52,080 --> 00:20:55,840
by directing all the communication from

00:20:54,000 --> 00:20:57,120
top to bottom or start to end

00:20:55,840 --> 00:20:58,880
we get what is often called a

00:20:57,120 --> 00:21:02,799
unidirectional

00:20:58,880 --> 00:21:04,720
data flow so remember again

00:21:02,799 --> 00:21:06,480
we have referential transparent

00:21:04,720 --> 00:21:08,960
components we can think of our

00:21:06,480 --> 00:21:11,039
application as a single function call

00:21:08,960 --> 00:21:12,000
mentally we can replace the entire tree

00:21:11,039 --> 00:21:14,400
with just the top

00:21:12,000 --> 00:21:16,720
function call and think of it just as a

00:21:14,400 --> 00:21:20,320
function of states

00:21:16,720 --> 00:21:24,159
so sometimes we have to do updates

00:21:20,320 --> 00:21:26,320
we have to swap out some part of our

00:21:24,159 --> 00:21:28,799
application states

00:21:26,320 --> 00:21:30,159
after all applications that just render

00:21:28,799 --> 00:21:33,280
some outputs

00:21:30,159 --> 00:21:35,120
are rather dull so what we do is we send

00:21:33,280 --> 00:21:38,559
a message back to the

00:21:35,120 --> 00:21:41,440
top state or from any other place

00:21:38,559 --> 00:21:43,760
to the dom to the top global structure

00:21:41,440 --> 00:21:46,320
and when a value of the immutable

00:21:43,760 --> 00:21:48,640
tree has been swapped a new invocation

00:21:46,320 --> 00:21:51,760
of our system occurs

00:21:48,640 --> 00:21:54,320
so this is think about it it's it's

00:21:51,760 --> 00:21:56,240
essentially just the same as doing a

00:21:54,320 --> 00:21:59,679
complete browser reload

00:21:56,240 --> 00:22:01,679
just we we can go back to our simple

00:21:59,679 --> 00:22:02,880
mental model that we have the good old

00:22:01,679 --> 00:22:05,039
html

00:22:02,880 --> 00:22:06,480
we can read the page from top top to

00:22:05,039 --> 00:22:08,799
bottom without having

00:22:06,480 --> 00:22:09,760
a massive blob of mutative mutative

00:22:08,799 --> 00:22:12,400
state buildup

00:22:09,760 --> 00:22:13,600
but by having distinct states over time

00:22:12,400 --> 00:22:16,559
stored at the top

00:22:13,600 --> 00:22:17,919
abstracted to the far edges so none of

00:22:16,559 --> 00:22:21,120
our stateful interaction

00:22:17,919 --> 00:22:21,120
is leaking through our system

00:22:21,360 --> 00:22:24,720
by sending messages to our global state

00:22:23,679 --> 00:22:27,760
we can get

00:22:24,720 --> 00:22:29,600
some sort of revision history between

00:22:27,760 --> 00:22:31,600
our changes

00:22:29,600 --> 00:22:33,520
every time some something in our system

00:22:31,600 --> 00:22:34,799
changes we get a new iteration of the

00:22:33,520 --> 00:22:36,159
top structure

00:22:34,799 --> 00:22:37,840
this means we can step through our

00:22:36,159 --> 00:22:40,799
system and

00:22:37,840 --> 00:22:42,559
react to error if some error is an

00:22:40,799 --> 00:22:44,960
uncaught error occurs

00:22:42,559 --> 00:22:45,919
so then we can pop the last state and go

00:22:44,960 --> 00:22:49,360
back to the working

00:22:45,919 --> 00:22:50,640
version we can even build test tools and

00:22:49,360 --> 00:22:51,600
instead of having to click through our

00:22:50,640 --> 00:22:53,600
applications

00:22:51,600 --> 00:22:55,039
we're using some tedious tools like

00:22:53,600 --> 00:22:57,440
selenium to click through

00:22:55,039 --> 00:22:58,080
and record a session we could just take

00:22:57,440 --> 00:23:00,320
our history

00:22:58,080 --> 00:23:01,120
serialize it and step through it through

00:23:00,320 --> 00:23:03,679
time

00:23:01,120 --> 00:23:04,880
and check our output for each iteration

00:23:03,679 --> 00:23:07,919
this is much simpler

00:23:04,880 --> 00:23:08,640
to to build robust systems so another

00:23:07,919 --> 00:23:10,080
use

00:23:08,640 --> 00:23:11,679
would be to do something like

00:23:10,080 --> 00:23:14,880
serialization of our top

00:23:11,679 --> 00:23:18,240
application state if an error occurs

00:23:14,880 --> 00:23:21,360
so by serializing the

00:23:18,240 --> 00:23:22,960
entire application states we can log it

00:23:21,360 --> 00:23:25,760
to a logging server

00:23:22,960 --> 00:23:27,200
and on our local development machine we

00:23:25,760 --> 00:23:30,320
can take the entire state

00:23:27,200 --> 00:23:33,520
and the same code base the same revision

00:23:30,320 --> 00:23:35,200
and reproduce any error that occurred

00:23:33,520 --> 00:23:37,520
this makes it really easy to fix some

00:23:35,200 --> 00:23:41,360
bugs

00:23:37,520 --> 00:23:44,400
initially this render loop we have by

00:23:41,360 --> 00:23:45,039
sending data down and updating and doing

00:23:44,400 --> 00:23:48,240
a new

00:23:45,039 --> 00:23:50,559
loop or a cycle if you will initially

00:23:48,240 --> 00:23:52,480
this render loop can seem like it would

00:23:50,559 --> 00:23:53,279
be slow but in most cases it actually

00:23:52,480 --> 00:23:56,480
works

00:23:53,279 --> 00:23:58,080
rather well as we follow of course

00:23:56,480 --> 00:24:00,080
the principle of referential

00:23:58,080 --> 00:24:02,320
transparency we know that

00:24:00,080 --> 00:24:04,080
if the input hasn't changed the output

00:24:02,320 --> 00:24:06,000
shouldn't change either

00:24:04,080 --> 00:24:07,520
this means we can omit updating a

00:24:06,000 --> 00:24:09,440
component that's past

00:24:07,520 --> 00:24:12,880
input that's unchanged from the last

00:24:09,440 --> 00:24:15,520
iteration of our application state

00:24:12,880 --> 00:24:17,520
so this will only update a leaf node or

00:24:15,520 --> 00:24:19,200
any of its parents that it has changed

00:24:17,520 --> 00:24:21,440
none of the siblings or rest of the

00:24:19,200 --> 00:24:22,240
trees rest of the components in the

00:24:21,440 --> 00:24:24,960
trees

00:24:22,240 --> 00:24:26,480
should update this works really great

00:24:24,960 --> 00:24:27,120
with using something like react or any

00:24:26,480 --> 00:24:30,559
other

00:24:27,120 --> 00:24:32,960
virtual dom implementation which is

00:24:30,559 --> 00:24:34,720
very the output as well so we have

00:24:32,960 --> 00:24:38,320
double diffs

00:24:34,720 --> 00:24:41,440
this of course no um silver bullet as

00:24:38,320 --> 00:24:42,960
any library or implementation is so

00:24:41,440 --> 00:24:44,640
if you do high frequent updates you

00:24:42,960 --> 00:24:47,600
might stress the garbage collector

00:24:44,640 --> 00:24:49,440
you might do more memory and cpu time

00:24:47,600 --> 00:24:52,880
but for the most cases this works

00:24:49,440 --> 00:24:55,520
pretty good so to summarize

00:24:52,880 --> 00:24:56,159
we see how we can use patterns from

00:24:55,520 --> 00:24:57,840
functional

00:24:56,159 --> 00:25:00,080
functional programming to program our

00:24:57,840 --> 00:25:01,360
views and this is often thought of as a

00:25:00,080 --> 00:25:04,880
poor fit due to the state

00:25:01,360 --> 00:25:08,880
stateful nature of ui programming

00:25:04,880 --> 00:25:11,919
the dom is just a side effect right so

00:25:08,880 --> 00:25:13,200
we can see by thinking our system as a

00:25:11,919 --> 00:25:15,200
function of state

00:25:13,200 --> 00:25:16,559
where we have the global structure at

00:25:15,200 --> 00:25:18,559
the top

00:25:16,559 --> 00:25:20,240
and global immutable structure to avoid

00:25:18,559 --> 00:25:22,320
sharing mutable states

00:25:20,240 --> 00:25:24,000
and using a render loop to achieve a

00:25:22,320 --> 00:25:27,840
static mental model

00:25:24,000 --> 00:25:28,720
much like we had with the good old html

00:25:27,840 --> 00:25:31,440
but this

00:25:28,720 --> 00:25:33,200
instead of having static html we have

00:25:31,440 --> 00:25:34,400
still the power and the flexibility of

00:25:33,200 --> 00:25:38,240
programming

00:25:34,400 --> 00:25:41,440
so it's merging the two worlds

00:25:38,240 --> 00:25:43,039
all of these ideas can be realized using

00:25:41,440 --> 00:25:44,480
react or using any virtual dom

00:25:43,039 --> 00:25:46,559
implementation it's just an idea

00:25:44,480 --> 00:25:49,600
it's just an inspiration it's just a way

00:25:46,559 --> 00:25:51,440
you build your applications by using

00:25:49,600 --> 00:25:53,039
thinking thoroughly through how you

00:25:51,440 --> 00:25:56,080
build your functions

00:25:53,039 --> 00:25:57,919
my hope is and it seems that it might be

00:25:56,080 --> 00:26:00,720
heading that way is for react to get

00:25:57,919 --> 00:26:01,039
built-in support for stateless functions

00:26:00,720 --> 00:26:03,679
uh

00:26:01,039 --> 00:26:04,720
as for now it's not that straightforward

00:26:03,679 --> 00:26:07,360
you have to use

00:26:04,720 --> 00:26:09,600
something called something that looks

00:26:07,360 --> 00:26:11,840
like classes

00:26:09,600 --> 00:26:13,760
this is why we created a very very small

00:26:11,840 --> 00:26:15,360
syntactic sugar on top of react

00:26:13,760 --> 00:26:17,039
and a smart logic to check whether or

00:26:15,360 --> 00:26:19,600
not the components should update

00:26:17,039 --> 00:26:20,880
based on the past input as mutable

00:26:19,600 --> 00:26:23,520
structures

00:26:20,880 --> 00:26:24,640
and this library encourages these kinds

00:26:23,520 --> 00:26:27,520
of patterns we're seeing

00:26:24,640 --> 00:26:28,640
so if this talk is was at all

00:26:27,520 --> 00:26:31,200
interesting to you

00:26:28,640 --> 00:26:33,360
check out the omniscient project and

00:26:31,200 --> 00:26:35,120
help on improving on its ideas

00:26:33,360 --> 00:26:38,000
or just check out the reading material

00:26:35,120 --> 00:26:39,919
or say why you disagree or if you even

00:26:38,000 --> 00:26:41,200
disagree

00:26:39,919 --> 00:26:43,120
if you're interested in learning more

00:26:41,200 --> 00:26:45,039
these are some links you can check out

00:26:43,120 --> 00:26:46,799
i didn't get much into how immutable

00:26:45,039 --> 00:26:48,480
data structure works

00:26:46,799 --> 00:26:49,919
just briefly hand waved over it but you

00:26:48,480 --> 00:26:51,279
could you should check out lee byron's

00:26:49,919 --> 00:26:53,279
talk from react conf

00:26:51,279 --> 00:26:54,880
which goes much more into it and has

00:26:53,279 --> 00:26:57,600
great information you should also check

00:26:54,880 --> 00:26:59,919
out closurescript library arm

00:26:57,600 --> 00:27:03,120
a library which amnesian has built most

00:26:59,919 --> 00:27:03,120
of its core ideas from

00:27:03,919 --> 00:27:07,840
so thank you

00:27:15,360 --> 00:27:17,600
so

00:27:18,640 --> 00:27:23,520
again we're on the sofa time and honest

00:27:22,080 --> 00:27:26,399
questions

00:27:23,520 --> 00:27:27,200
are there any questions there's one

00:27:26,399 --> 00:27:30,240
right here

00:27:27,200 --> 00:27:32,399
and there's one over there all right uh

00:27:30,240 --> 00:27:35,440
very good stuff

00:27:32,399 --> 00:27:37,679
so with the global big state approach uh

00:27:35,440 --> 00:27:38,240
the benefits are obvious like go global

00:27:37,679 --> 00:27:41,279
undo

00:27:38,240 --> 00:27:43,440
and state serialization etc etc and that

00:27:41,279 --> 00:27:44,399
is assuming that all the ui components

00:27:43,440 --> 00:27:46,159
are built with

00:27:44,399 --> 00:27:48,080
this specific framework whether it's

00:27:46,159 --> 00:27:49,840
omniscient or react

00:27:48,080 --> 00:27:52,080
and okay so let's imagine that in the

00:27:49,840 --> 00:27:54,559
next two years web components are the

00:27:52,080 --> 00:27:56,559
next big thing so if we're using

00:27:54,559 --> 00:27:59,360
extensively web components

00:27:56,559 --> 00:28:01,200
they own their own state so then your

00:27:59,360 --> 00:28:02,880
global big state will not have

00:28:01,200 --> 00:28:06,240
everything and you will not get the

00:28:02,880 --> 00:28:09,440
benefits that we mentioned so what to do

00:28:06,240 --> 00:28:13,279
my argument is that the next big thing

00:28:09,440 --> 00:28:16,480
isn't really web components and probably

00:28:13,279 --> 00:28:18,640
it is not going to be but you can have

00:28:16,480 --> 00:28:19,600
like windows to your applications and

00:28:18,640 --> 00:28:22,399
using this arc

00:28:19,600 --> 00:28:23,440
this style of architecture and other

00:28:22,399 --> 00:28:24,880
parts of your system

00:28:23,440 --> 00:28:27,520
doesn't entirely follow that you can

00:28:24,880 --> 00:28:29,840
have some parts of your system using it

00:28:27,520 --> 00:28:30,880
you're not restricted using one type of

00:28:29,840 --> 00:28:32,799
architecture one

00:28:30,880 --> 00:28:34,880
type of paradigm in your system but you

00:28:32,799 --> 00:28:38,399
use the paradigms to fit

00:28:34,880 --> 00:28:42,240
the type of problem you have so i don't

00:28:38,399 --> 00:28:42,240
know if that answer your question

00:28:42,720 --> 00:28:46,720
there was another question second row

00:28:48,399 --> 00:28:52,399
thank you thank you for the talk um i

00:28:50,640 --> 00:28:54,960
was asking myself do you believe that

00:28:52,399 --> 00:28:56,480
the fact that we have the html tags

00:28:54,960 --> 00:28:59,440
inside the javascript like

00:28:56,480 --> 00:29:00,000
with jsx is necessary or can we move to

00:28:59,440 --> 00:29:01,919
something like

00:29:00,000 --> 00:29:03,279
directive.js where the templates are

00:29:01,919 --> 00:29:06,640
externalized

00:29:03,279 --> 00:29:09,679
yeah so your question is

00:29:06,640 --> 00:29:10,240
how i feel about jsx is that pretty much

00:29:09,679 --> 00:29:12,399
it or

00:29:10,240 --> 00:29:14,080
do you feel it's necessary for the for

00:29:12,399 --> 00:29:16,799
this approach no it's not

00:29:14,080 --> 00:29:17,279
jsx isn't necessary and often i don't

00:29:16,799 --> 00:29:20,159
use it

00:29:17,279 --> 00:29:22,159
at all you can just have functions and

00:29:20,159 --> 00:29:24,320
that's what jsx really is it's a small

00:29:22,159 --> 00:29:27,360
transpire layer to a function call

00:29:24,320 --> 00:29:29,600
which is a kind of a hairy syntax but

00:29:27,360 --> 00:29:31,600
you can make the syntax clear just like

00:29:29,600 --> 00:29:35,279
in cycle it's clear or

00:29:31,600 --> 00:29:37,360
it's easier to use but you're

00:29:35,279 --> 00:29:38,559
you need to have an internal

00:29:37,360 --> 00:29:42,159
representation

00:29:38,559 --> 00:29:44,559
of the dom and the ability to to

00:29:42,159 --> 00:29:45,679
do smart logic for updating to to be

00:29:44,559 --> 00:29:48,320
able to have efficient

00:29:45,679 --> 00:29:50,240
render loops so some sort of

00:29:48,320 --> 00:29:53,279
representation of html in code

00:29:50,240 --> 00:29:54,320
is yeah required but i think that's the

00:29:53,279 --> 00:29:57,440
direction that

00:29:54,320 --> 00:30:00,559
you might be headed to

00:29:57,440 --> 00:30:03,760
include the output to the more

00:30:00,559 --> 00:30:06,080
powerful environment that is programming

00:30:03,760 --> 00:30:10,320
instead of moving programming into

00:30:06,080 --> 00:30:10,320
to the views all right thank you

00:30:10,720 --> 00:30:15,200
oh i can see your hand over here and

00:30:12,720 --> 00:30:15,200
over there

00:30:15,520 --> 00:30:20,960
who's going to be first oh wait conflict

00:30:19,279 --> 00:30:22,799
could you please elaborate on the

00:30:20,960 --> 00:30:26,399
concept of preferential

00:30:22,799 --> 00:30:28,799
transparency it's not

00:30:26,399 --> 00:30:30,240
clear to me what referential

00:30:28,799 --> 00:30:34,320
transparency is

00:30:30,240 --> 00:30:35,200
where which sorry the concept of

00:30:34,320 --> 00:30:37,360
referential

00:30:35,200 --> 00:30:39,120
transparency okay so the concept of

00:30:37,360 --> 00:30:40,159
referential transparency is just the

00:30:39,120 --> 00:30:42,640
ability

00:30:40,159 --> 00:30:44,480
to swap out the invocation of a function

00:30:42,640 --> 00:30:47,760
with a result of the invocation

00:30:44,480 --> 00:30:50,000
and that's that wouldn't

00:30:47,760 --> 00:30:50,880
in some way alter the behavior of the

00:30:50,000 --> 00:30:54,080
rest of the system

00:30:50,880 --> 00:30:57,440
so it's just an expression to say that

00:30:54,080 --> 00:31:01,360
there's not one code inside the function

00:30:57,440 --> 00:31:01,360
that alters the behavior

00:31:01,519 --> 00:31:07,120
of your system as a whole if that makes

00:31:03,679 --> 00:31:07,120
sense it makes sense thank you

00:31:07,840 --> 00:31:14,480
okay so i had a question

00:31:11,200 --> 00:31:17,519
when the here yeah

00:31:14,480 --> 00:31:18,080
yes sir obviously when you have this

00:31:17,519 --> 00:31:21,200
state

00:31:18,080 --> 00:31:21,919
like you know one global object uh it

00:31:21,200 --> 00:31:25,360
becomes

00:31:21,919 --> 00:31:28,640
kind of like uh very big and complex

00:31:25,360 --> 00:31:32,080
so what's your solution to structure

00:31:28,640 --> 00:31:36,320
the state do you like structure

00:31:32,080 --> 00:31:38,960
is it somehow as the element three or

00:31:36,320 --> 00:31:41,039
how are you doing that one it won't

00:31:38,960 --> 00:31:43,279
necessarily become complex

00:31:41,039 --> 00:31:44,399
it would be big not necessarily complex

00:31:43,279 --> 00:31:46,960
but you could also

00:31:44,399 --> 00:31:47,840
split up your application to sub modules

00:31:46,960 --> 00:31:49,919
and sub

00:31:47,840 --> 00:31:51,840
parts of your system which have in turn

00:31:49,919 --> 00:31:53,760
their

00:31:51,840 --> 00:31:55,679
global objects if you will so you can

00:31:53,760 --> 00:31:57,679
have a you can have a tree of global

00:31:55,679 --> 00:31:59,039
objects as well if your system is large

00:31:57,679 --> 00:32:01,440
enough

00:31:59,039 --> 00:32:02,399
it depends on how you use it so so you

00:32:01,440 --> 00:32:04,880
can

00:32:02,399 --> 00:32:05,760
split up the different components as

00:32:04,880 --> 00:32:08,720
modules and

00:32:05,760 --> 00:32:09,919
and have some parts of your page one

00:32:08,720 --> 00:32:12,480
global object

00:32:09,919 --> 00:32:13,120
and perhaps a global object on the top

00:32:12,480 --> 00:32:16,640
that

00:32:13,120 --> 00:32:19,519
stores the global objects so yeah

00:32:16,640 --> 00:32:20,000
tree of trees okay thanks okay one more

00:32:19,519 --> 00:32:23,360
question

00:32:20,000 --> 00:32:23,360
to win the first round um

00:32:24,240 --> 00:32:28,720
what are strategies for sharing global

00:32:26,799 --> 00:32:30,559
immutable state between a client and a

00:32:28,720 --> 00:32:33,120
server

00:32:30,559 --> 00:32:34,399
are there strategies for sharing global

00:32:33,120 --> 00:32:36,559
immutable state

00:32:34,399 --> 00:32:38,559
between the client and the server does

00:32:36,559 --> 00:32:42,159
it make sense to do that there are some

00:32:38,559 --> 00:32:46,480
initiatives some call bases that try to

00:32:42,159 --> 00:32:49,039
patch or do like um scuttlebot

00:32:46,480 --> 00:32:49,600
things with the structure on the server

00:32:49,039 --> 00:32:52,080
side and

00:32:49,600 --> 00:32:53,519
on the client side so yeah there uh

00:32:52,080 --> 00:32:56,960
there are a few links on it

00:32:53,519 --> 00:33:00,000
on the github page

00:32:56,960 --> 00:33:01,760
here uh you mentioned omniscient

00:33:00,000 --> 00:33:03,200
which is really modern and fun

00:33:01,760 --> 00:33:06,000
technology to me

00:33:03,200 --> 00:33:07,360
you are maybe aware of presentation from

00:33:06,000 --> 00:33:10,240
martin klotman about

00:33:07,360 --> 00:33:10,640
event streams that in your system you

00:33:10,240 --> 00:33:13,679
have

00:33:10,640 --> 00:33:16,159
lock of immutable facts

00:33:13,679 --> 00:33:16,880
um if you know that presentation have

00:33:16,159 --> 00:33:20,000
you tried

00:33:16,880 --> 00:33:22,720
uh built frontend system like that

00:33:20,000 --> 00:33:23,360
that there is only this event stream

00:33:22,720 --> 00:33:26,080
yeah

00:33:23,360 --> 00:33:27,279
so i've used reactive extensions or

00:33:26,080 --> 00:33:29,600
bacon

00:33:27,279 --> 00:33:30,880
as well but i usually use it to abstract

00:33:29,600 --> 00:33:34,240
like

00:33:30,880 --> 00:33:37,120
time-dependent or data-dependent

00:33:34,240 --> 00:33:38,640
asynchronous achievements so you can use

00:33:37,120 --> 00:33:41,519
still

00:33:38,640 --> 00:33:42,159
reactive extensions and event streams to

00:33:41,519 --> 00:33:45,519
uh

00:33:42,159 --> 00:33:47,279
and it will nicely play with omniscient

00:33:45,519 --> 00:33:49,039
yeah as long as you update as long as

00:33:47,279 --> 00:33:52,240
you update the global state and

00:33:49,039 --> 00:33:54,159
invoke the system and you you can uh

00:33:52,240 --> 00:33:56,799
have any integration point you want

00:33:54,159 --> 00:33:59,360
right okay thanks

00:33:56,799 --> 00:34:01,279
so it seems like uh everyone wants to

00:33:59,360 --> 00:34:04,399
fix your pick your brain

00:34:01,279 --> 00:34:06,000
but we have another talk so thank you

00:34:04,399 --> 00:34:08,000
michael that was amazing thank you

00:34:06,000 --> 00:34:10,750
thanks for all the questions so if you

00:34:08,000 --> 00:34:14,179
want more questions just cut michael

00:34:10,750 --> 00:34:14,179
[Applause]

00:34:18,119 --> 00:34:21,119

YouTube URL: https://www.youtube.com/watch?v=Pbqratnt9Io


