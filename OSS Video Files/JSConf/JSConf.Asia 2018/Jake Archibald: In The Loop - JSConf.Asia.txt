Title: Jake Archibald: In The Loop - JSConf.Asia
Publication date: 2018-02-09
Playlist: JSConf.Asia 2018
Description: 
	Have you ever had a bug where things were happening in the wrong order, or particular style changes were being ignored? Ever fixed that bug by wrapping a section of code in a setTimeout? Ever found that fix to be unreliable, and played around with the timeout number until it kinda almost always worked? 
This talk looks at the browser's event loop, the thing that orchestrates the main thread of the browser, which includes JavaScript, events, and rendering. We'll look at the difference between tasks, microtasks, requestAnimationFrame, requestIdleCallback, and where events land. 
Hopefully you'll never have to use setTimeout hacks again!"

Jake is developer advocate for Google Chrome. He's one of the editors of the service worker spec, so he's into offline-first, push messaging and web performance.


JSConf.Asia - Capitol Theatre, Singapore - 27 January 2018

Source: https://2018.jsconf.asia/

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:13,599 --> 00:00:15,599
Hello everyone

00:00:16,029 --> 00:00:19,019
How's it going didn't get my slide clicker out

00:00:20,859 --> 00:00:23,399
Yeah, this is my first time in Singapore

00:00:24,760 --> 00:00:26,760
It's yeah, it's nice

00:00:27,730 --> 00:00:29,650
oh

00:00:29,650 --> 00:00:33,000
This is already going well if I get an applause for that. That's fantastic

00:00:34,120 --> 00:00:39,540
It's like I haven't really looked around yet like I landed just before the conference so I can't say I've really experienced it yet

00:00:39,540 --> 00:00:42,959
But I'm gonna stay on for a few days afterwards, and you know and have a proper explore

00:00:43,410 --> 00:00:45,410
I brought my partner along with me as well

00:00:45,550 --> 00:00:49,349
And I have to say that was a big mistake a huge mistake

00:00:49,750 --> 00:00:53,879
Because she's been really looking forward to this trip right and especially over the last couple of weeks

00:00:53,879 --> 00:00:58,858
she's been saying things like I don't know two weeks till we go to Singapore one week till we go to Singapore five days to

00:00:58,859 --> 00:01:04,889
Go four days to go, and I could you could you please not do that because what I'm hearing right is

00:01:05,560 --> 00:01:11,100
Five days you only have five days to finish your talk four days three days. You're still not ready

00:01:11,100 --> 00:01:17,009
Are you said the worst project manager ever just like taunting me, and how unprepared I am, but then

00:01:17,530 --> 00:01:21,239
she's brilliant like she knows how to she knows how to put up with me because

00:01:21,640 --> 00:01:28,259
Because I stress right. I stress pretty easily. I stress about things that aren't really problems. I stress about things that are really

00:01:28,960 --> 00:01:30,820
nothing to do with me and

00:01:30,820 --> 00:01:34,079
Someone posted this picture on Twitter last week

00:01:35,770 --> 00:01:38,790
He's holding a MacBook between two fingers

00:01:40,659 --> 00:01:46,019
above concrete! I have not slept since I saw this picture

00:01:48,280 --> 00:01:54,960
I stress about code like this right and firstly because there's no semicolons. Give me a cheer if you use semicolons in JavaScript

00:01:56,229 --> 00:01:59,489
Yes, good to hear the rest of you are monsters

00:02:00,700 --> 00:02:04,900
But that's not the main thing that stresses me out late. It's because it's adding stuff to the DOM and

00:02:05,980 --> 00:02:12,340
Then hiding it like presumably to show it some time later like on click or something and that stresses me out because it's like

00:02:13,220 --> 00:02:19,320
can we be sure that the user's not going to see like a flash of that element before it's hidden and

00:02:20,280 --> 00:02:22,760
And I've never been able to recreate this problem

00:02:22,760 --> 00:02:27,950
I've never seen it happen, but I you never know when it comes to race conditions, so I always just

00:02:28,470 --> 00:02:31,820
Swap those lines around you know just so I can get some sleep

00:02:33,000 --> 00:02:35,690
But really there's no race condition here

00:02:36,360 --> 00:02:38,360
because the timing of running code and

00:02:39,000 --> 00:02:41,570
rendering is always all tightly defined and

00:02:42,600 --> 00:02:44,370
mostly deterministic

00:02:44,370 --> 00:02:49,819
And that is thanks to the event loop, and if I do a half decent job in the next 30 or so minutes

00:02:49,860 --> 00:02:57,170
You'll know why things run in the order they do and I don't know it might even make sense, but there's no promises there

00:02:57,840 --> 00:03:02,520
So web pages have a thing that we tend to call the main thread

00:03:03,780 --> 00:03:05,700
Here's the main thread

00:03:05,700 --> 00:03:13,240
We call it the main thread because loads of stuff happens here is where JavaScript happens. It's where rendering happens. It's where the DOM lives

00:03:13,940 --> 00:03:18,760
And this means that the bulk of your stuff on the web has a deterministic order

00:03:18,770 --> 00:03:23,119
we don't get multiple bits of code running at the same time like trying to edit the same DOM and

00:03:23,790 --> 00:03:26,689
Giving you a world of horrible race conditions

00:03:27,270 --> 00:03:33,350
But it does mean that if something on the main thread takes a long time and by a long time

00:03:33,350 --> 00:03:34,850
I mean like 200 milliseconds

00:03:34,850 --> 00:03:36,850
That's a long time in terms of user interaction

00:03:36,960 --> 00:03:43,279
Then it becomes really noticeable because it's blocked loads of other things like it blocks rendering it blocks interaction

00:03:44,250 --> 00:03:47,960
and I think it's difficult for us to think in this way because as

00:03:48,720 --> 00:03:50,550
humans we are

00:03:50,550 --> 00:03:53,719
Extremely multi-threaded like I can stand here

00:03:53,720 --> 00:03:58,520
I can wave one hand I can stand on one leg I can wave the other leg and all the time

00:03:58,520 --> 00:04:02,270
I'm speaking I'm breathing and processing audio and visual information

00:04:03,120 --> 00:04:08,750
As humans we don't really have a main thread. We don't really have things that block

00:04:09,570 --> 00:04:12,260
unrelated things I mean we have one and

00:04:12,900 --> 00:04:14,900
That is when we sneeze

00:04:16,500 --> 00:04:23,989
Because as you begin to sneeze just stuff shuts down. You know like and the first thing you lose is the ability to talk

00:04:24,720 --> 00:04:26,720
Then you pull a stupid face

00:04:27,230 --> 00:04:31,759
If you're driving at this point. This is where you think huh I hope no one dies

00:04:32,730 --> 00:04:38,329
Least of all me and then the human body becomes entirely single-threaded like you were sneezing

00:04:39,060 --> 00:04:43,339
Nothing else you can't see hear think you can move and make noises

00:04:44,190 --> 00:04:48,499
but only in ways the sneeze wants you to you have no control over this at all and

00:04:48,960 --> 00:04:51,740
Then it's over right you essentially wake up and

00:04:51,840 --> 00:04:57,880
You find out if your car is still on the road if you have the same number of limbs you started with the same number

00:04:57,889 --> 00:05:04,219
Of passengers you started with right needless to say we don't want to write code that is like a sneeze

00:05:05,010 --> 00:05:10,339
So although we have this and this main thread thing we tend to spawn a whole series of threads like for networking stuff

00:05:10,620 --> 00:05:12,030
encoding and decoding

00:05:12,030 --> 00:05:14,030
crypto monitoring input devices

00:05:14,310 --> 00:05:17,419
But once these threads have done something that the page needs to hear about

00:05:17,700 --> 00:05:22,009
they need to sort of come back to the main thread to give it that information and

00:05:22,410 --> 00:05:24,919
It's the event loop that orchestrates all of this they

00:05:25,440 --> 00:05:30,679
Take setTimeout for instance is it badly named? Yes. Are the arguments in the wrong order?

00:05:31,260 --> 00:05:35,089
I'd say so but have you thought about how it actually works?

00:05:36,000 --> 00:05:40,549
Well, let's write a web standard for it because that's what I do these days

00:05:41,370 --> 00:05:48,289
We'll start with the setTimeout method, when invoked, must run the following steps: wait ms milliseconds invoke callback done

00:05:49,680 --> 00:05:51,680
But this isn't quite working

00:05:52,320 --> 00:05:58,549
Because spec text like this this runs on the same thread as whatever invokes it and in this case it's invoked by

00:05:58,650 --> 00:06:02,359
JavaScript, so this is running on the main thread so if we say wait

00:06:03,240 --> 00:06:09,590
5,000 milliseconds we are waiting five thousand milliseconds on the main thread we're blocking lots of other stuff, so

00:06:10,169 --> 00:06:12,139
This spec is very sneezy right now

00:06:12,139 --> 00:06:17,689
So we need to change that and we do this we run the steps in parallel which is magic spec speak for

00:06:18,450 --> 00:06:23,509
Get off the main thread or get off this thread and run this stuff kind of at the same time as other stuff

00:06:24,750 --> 00:06:31,279
but we create a new problem here because now we're invoking a callback from something other than the main thread and I

00:06:32,310 --> 00:06:34,339
Mean, there's no way this can really work

00:06:34,340 --> 00:06:38,209
You would end up with lots of JavaScript running in parallel still editing the same, DOM

00:06:38,210 --> 00:06:40,190
And you'd end up with all of these race conditions

00:06:40,190 --> 00:06:45,559
So what we do is this we queue a task and we queue a task to get back on to the main thread at some point

00:06:45,960 --> 00:06:50,359
And now we're calling JavaScript on the thread where JavaScript lives, so it all works

00:06:50,610 --> 00:06:52,819
And this is a core part of how the browser works

00:06:52,819 --> 00:06:58,878
So if you click the mouse like how does that get from the operating system into your JavaScript? it queues a task

00:06:59,009 --> 00:07:02,209
When you fetch something how did you get the response into your JavaScript well?

00:07:02,460 --> 00:07:08,120
It queues a task and you send a message from a page to a worker once again it queues a task to do that

00:07:08,819 --> 00:07:14,569
So the first part the event loop I want to look at are task queues, and this is the oldest part of the event loop

00:07:16,379 --> 00:07:23,479
Rather than look at the spec I thought it might be easier to try and visualize the event loop so

00:07:24,900 --> 00:07:29,269
Here it is this is it. I hope that clears up any questions you have

00:07:30,180 --> 00:07:34,789
Actually, I really hope it does because I based the whole talk around this one diagram, so I hope it works

00:07:34,919 --> 00:07:39,978
But yeah without anything to do the event loop just spins round and round in a CPU efficient manner now

00:07:40,169 --> 00:07:43,698
This visualization is running at a fraction of a percent of real time

00:07:43,699 --> 00:07:48,079
And it's still kind of too fast to really see what's going on, so let's slow things down a bit

00:07:49,169 --> 00:07:55,008
When we queue a task the event loop takes a detour so this here this detour here. This is where tasks happen

00:07:56,339 --> 00:07:58,999
So at some point the browser says to the event loop hey

00:07:59,400 --> 00:08:02,449
I've got a job for you to do and the event loop is like

00:08:02,759 --> 00:08:07,639
Excellent ok add it to my to-do list and I'll get round to it at some point no problem done

00:08:09,150 --> 00:08:12,349
What if we do this like using set timeout we queue two callbacks

00:08:12,839 --> 00:08:19,279
That we want to run after one second 1,000 milliseconds well according to the spec we wrote these two algorithms

00:08:19,279 --> 00:08:22,549
Go parallel each waits for a thousand milliseconds

00:08:22,550 --> 00:08:26,719
And then they need to come back on to the main thread, and they do that by queuing a task

00:08:27,270 --> 00:08:32,870
So the browser says to the event loop hey, I've got something here that wants to do main thread work in fact

00:08:32,870 --> 00:08:40,279
I have two things and it adds each one as a separate to-do item in the task queue. The event loop's like sure that's

00:08:40,279 --> 00:08:45,439
Fine I'll get round to it so it runs the first callback it goes around the event loop

00:08:45,959 --> 00:08:47,959
And runs the second callback

00:08:48,660 --> 00:08:50,660
And that's tasks

00:08:51,050 --> 00:08:53,560
And it would be pretty simple if that's all it was

00:08:54,410 --> 00:08:59,980
But it gets more complicated when we think about the render steps, and this is what the browser uses to update

00:08:59,980 --> 00:09:01,980
What's actually on the screen

00:09:03,020 --> 00:09:09,360
The render steps are another detour and that involves style calculation. This is looking at all of the CSS

00:09:09,360 --> 00:09:11,880
That's going on and working out what applies to each element

00:09:13,460 --> 00:09:17,740
Layout is in creating a render tree figuring out where everything is on the page

00:09:18,620 --> 00:09:20,620
And where it's positioned

00:09:20,690 --> 00:09:24,549
And then creating actual pixel data. You know doing the actual painting

00:09:25,100 --> 00:09:29,080
So at some point the browser will say to the event loop hey, you know we need to wait to update

00:09:29,100 --> 00:09:34,060
What's on the screen and the event loop's like no problem, I'll get round to that next time I go around the event loop

00:09:35,200 --> 00:09:37,980
now I don't know about you, but I

00:09:38,660 --> 00:09:41,740
Would consider myself an expert at coding badly

00:09:41,740 --> 00:09:46,479
But I can take very simple bits of JavaScript and create infinite loops out of them in places

00:09:46,480 --> 00:09:51,250
I least expect, but let's take a closer look at what happens when I do that

00:09:51,830 --> 00:09:57,069
Here's a page with a gif and some text and a big button that runs an infinite JavaScript loop

00:09:57,680 --> 00:09:59,680
so if I click that button

00:09:59,690 --> 00:10:05,679
Everything stops the gif has stopped. I can no longer select text the whole tab has kind of come to a standstill

00:10:06,470 --> 00:10:10,000
Code for this are simple. This is just button click while true

00:10:12,440 --> 00:10:16,150
So how do we actually visualize this well the user clicks the button so the browser says

00:10:16,250 --> 00:10:20,140
Hey event loop. I've got a task for you event loop's like yep. No problem. I'm on it

00:10:20,810 --> 00:10:24,549
But this task never ends, it's running JavaScript

00:10:25,339 --> 00:10:26,930
forever a

00:10:26,930 --> 00:10:29,620
Couple of milliseconds later at the browser says hey event loop like um

00:10:29,990 --> 00:10:33,640
we need to update that gif that was on the page so if you could just

00:10:34,250 --> 00:10:39,250
Render at your next earliest convenience. That would be fantastic and event loop's like yeah, okay?

00:10:39,250 --> 00:10:45,099
I'll get round to that right after I finish this infinite loop that I'm busy doing right now

00:10:46,160 --> 00:10:49,870
Then the user tries to highlight text and that involves like hit testing

00:10:50,000 --> 00:10:53,650
Involves looking at the DOM to see what the text actually is so the browser says hey

00:10:53,650 --> 00:10:54,700
I've got a couple of more items

00:10:54,700 --> 00:10:55,660
For your to-do list there

00:10:55,660 --> 00:11:01,060
And the event loop's like are you having a laugh like do you know how long it takes to perform an infinite loop?

00:11:02,120 --> 00:11:04,989
It's a long time. You know. There is a clue in the name

00:11:05,689 --> 00:11:11,229
So that is why a while loop blocks rendering and other page interaction, but this is a good thing in practice

00:11:11,230 --> 00:11:16,300
We look again at the code that I started with I used to worry that this would result in a flash of content

00:11:16,300 --> 00:11:16,850
but it can't

00:11:16,850 --> 00:11:19,659
right because this script runs as part of a task and

00:11:19,730 --> 00:11:23,889
That must run to completion before the browser can get back around to the render steps

00:11:24,460 --> 00:11:28,680
The event loop guarantees your task will complete before rendering next happens

00:11:29,420 --> 00:11:32,880
It still stresses me out though. I'll always swap these lines around when I see it in code

00:11:33,860 --> 00:11:36,760
So a while loop blocks rendering, but what about this?

00:11:37,360 --> 00:11:43,680
So this is a loop, but each time we go round the loop we're using setTimeout to queue the next call

00:11:44,320 --> 00:11:48,300
well, let's find out so very similar testing before I click the button and

00:11:49,780 --> 00:11:55,320
Things are still working in fact. It kind of looks like nothing has changed, but in the background, here's what's happening

00:11:56,269 --> 00:11:57,829
We queue a task

00:11:57,829 --> 00:11:59,269
Go around the event loop

00:11:59,269 --> 00:12:05,558
Pick up that task and we queue another task as a result and that just keeps happening and happening until the end of time

00:12:05,959 --> 00:12:07,959
But as we've already seen like

00:12:08,180 --> 00:12:10,599
Only one task can be processed at a time

00:12:10,670 --> 00:12:15,219
So when it's processed a task it's having to go all the way around the event loop to pick up the next task

00:12:16,639 --> 00:12:23,019
So and that means at some point the browser can say huh we should update the display for that gif and it can it can

00:12:23,019 --> 00:12:27,878
Go around and update the display, and that's why a setTimeout loop is not render blocking

00:12:29,389 --> 00:12:33,128
But if you want to run code that has anything to do with rendering

00:12:33,740 --> 00:12:39,399
A task is really the wrong place to do it because a task is on the opposite side of the world to all of the rendering

00:12:39,399 --> 00:12:41,059
Stuff as far as the event loop is concerned

00:12:41,059 --> 00:12:45,939
What we want to do is we want to run code in the render steps. I want to run code here

00:12:46,819 --> 00:12:50,558
And the browser lets us do that and it lets us do that using requestAnimationFrame

00:12:51,410 --> 00:12:55,269
Another another badly named function. I think but it's it's really good for this purpose

00:12:56,809 --> 00:12:58,459
RAF callbacks

00:12:58,459 --> 00:13:03,998
They happen as part of the render steps and to show why this is useful. I'm going to animate a box

00:13:03,999 --> 00:13:05,999
just just a box and

00:13:06,529 --> 00:13:11,888
Using this code, so I'm going to move that box forward one pixel and then use requestAnimationFrame

00:13:13,100 --> 00:13:15,409
to create a loop around this and

00:13:16,829 --> 00:13:22,159
That's it that's all it does so that's requestAnimationFrame, but what if we switched requestAnimationFrame

00:13:24,209 --> 00:13:26,209
For setTimeout?

00:13:27,329 --> 00:13:29,009
It looks like this

00:13:29,009 --> 00:13:31,639
Now this box is moving faster

00:13:31,639 --> 00:13:37,878
It's moving about 3.5 times faster, and that means this callback is being called more often, and that is not a good thing

00:13:37,879 --> 00:13:39,879
That's not a good thing at all

00:13:40,350 --> 00:13:44,240
We saw earlier that the render rendering can happen in between tasks

00:13:44,850 --> 00:13:50,779
Yes, but just because it can happen doesn't mean it must in reality. We can take a task shall we render

00:13:50,779 --> 00:13:54,828
No, it can't be bothered yet. Go around the event loop pick up another task shall we render now

00:13:55,499 --> 00:13:59,149
now doesn't feel like the right time many tasks can happen and

00:13:59,879 --> 00:14:01,490
Before the browser goes yeah

00:14:01,490 --> 00:14:04,849
actually next time we will update the display and

00:14:05,220 --> 00:14:08,660
The browser gets to decide when to do this and it tries to be as efficient as possible

00:14:08,910 --> 00:14:14,059
The render steps only happen if there's something actually worth updating. If nothing's changed. It won't bother

00:14:14,579 --> 00:14:15,689
like

00:14:15,689 --> 00:14:21,079
If the browser tab is in the background if it isn't visible it will never run the render steps because there's there's no point

00:14:21,990 --> 00:14:25,639
But also the majority of screens update at a set frequency in most cases

00:14:25,639 --> 00:14:27,799
That's 60 times a second some screens

00:14:27,800 --> 00:14:29,490
Go faster some screens go slower

00:14:29,490 --> 00:14:34,459
But 60 Hertz is the most common so if we changed page Styles like a thousand times a second

00:14:34,459 --> 00:14:37,068
It's not going to run the render steps a thousand times a second

00:14:37,379 --> 00:14:42,199
It will synchronize itself with the display and only render up to a frequency the display is capable of

00:14:42,689 --> 00:14:49,339
Usually 60 times a second, otherwise it would be a waste of time like there's no point rendering stuff the user will never see

00:14:50,189 --> 00:14:52,189
But that's what setTimeout is doing here

00:14:52,649 --> 00:14:59,058
It's moving faster, because it's updating the position of that box more times than the user can see more times than this display is

00:14:59,639 --> 00:15:01,639
capable of showing us

00:15:02,189 --> 00:15:02,990
also so far

00:15:02,990 --> 00:15:04,990
We've been using setTimeout as this kind of

00:15:05,220 --> 00:15:10,730
Shorthand for "queue a task" and it isn't really because even though we've put zero milliseconds for the callback

00:15:10,730 --> 00:15:12,439
It's more like four point

00:15:12,439 --> 00:15:16,729
Seven is what the browser will use as a default the spec says the browser can pick any number to use

00:15:17,399 --> 00:15:20,178
But in the things I've tested it seems to be about four point seven

00:15:21,029 --> 00:15:23,448
There isn't a single method

00:15:23,459 --> 00:15:29,448
That just queues a task, but we can kind of fake it using message channels, and so I ran a test with that

00:15:30,479 --> 00:15:35,749
And if you're sensitive to flashing images might be best to look away now because that looks like this

00:15:36,569 --> 00:15:42,168
The there's so many tasks happening that it kind of just looks like the box is getting a random position

00:15:42,239 --> 00:15:45,709
We're getting a task every two hundredths of a millisecond

00:15:46,229 --> 00:15:53,629
So rendering can happen between tasks, but you can have many even tens of thousands of tasks between renderings

00:15:54,809 --> 00:15:56,809
Okay, flashing image has gone now

00:15:57,119 --> 00:16:02,839
Let's imagine each of these is a frame that is displayed to the user so our rendering steps

00:16:02,839 --> 00:16:08,808
They happen at the start of each frame and that includes like style calculation layout and paint not necessarily all three every time

00:16:08,969 --> 00:16:12,079
Depends what actually needs updating, but I like this

00:16:12,079 --> 00:16:17,058
I like this is very this is very neat and tidy this is this is a beautiful picture

00:16:18,180 --> 00:16:19,859
tasks on the other hand

00:16:19,860 --> 00:16:26,540
They couldn't give a stuff. They just kind of appear anywhere they fancy. The event loop ensures that tasks appear

00:16:27,060 --> 00:16:29,749
They happen in the right order they happen in the order they were queued

00:16:29,749 --> 00:16:34,788
But in terms of timing within a frame. There is no kind of ordering here at all

00:16:36,329 --> 00:16:38,329
And we saw this with our setTimeout

00:16:38,789 --> 00:16:42,559
We were getting four per frame three or four per frame and that means that

00:16:42,899 --> 00:16:49,069
Three-quarters of those callbacks were wasted effort in terms of rendering old animation libraries used to do something like this

00:16:49,829 --> 00:16:53,868
Where they were trying to use a millisecond value that's going to give them roughly 60 callbacks per

00:16:54,509 --> 00:16:56,219
second

00:16:56,219 --> 00:16:58,159
And they're assuming a lot about the screen

00:16:58,159 --> 00:17:04,008
They're they're assuming a screen 60 Hertz, but that was the common case so it kind of worked it eliminated some of the duplicate effort

00:17:05,429 --> 00:17:08,898
Unfortunately it was a massive hack because setTimeout was not designed for animation

00:17:08,899 --> 00:17:12,138
And it really shows like due to inaccuracies you can end up with drift

00:17:12,149 --> 00:17:16,039
So what's happened here is we've we're doing nothing in one frame, and then in the next frame

00:17:16,039 --> 00:17:21,109
We're doing twice the amount of work, and that is a visual jank to user it doesn't look great

00:17:21,869 --> 00:17:28,039
Also, if one of your tasks runs long you can end up moving the render steps around because it's all running on the same thread

00:17:28,039 --> 00:17:30,919
And you're sort of disturbing there that lovely routine that they have

00:17:31,889 --> 00:17:33,889
if we use requestAnimationFrame

00:17:34,019 --> 00:17:37,368
Rather than setTimeout. It would look a lot more like this

00:17:37,369 --> 00:17:41,869
All neat and tidy all nice and ordered everything is within the timing of the frame even this

00:17:42,570 --> 00:17:44,570
longer task here

00:17:44,700 --> 00:17:50,990
When I see performance traces like this this makes me happy. This is showing a good user experience makes me feel very calm

00:17:52,519 --> 00:17:54,519
You can't avoid tasks completely of course

00:17:54,690 --> 00:18:00,169
Because things like click events they're going to be delivered to you in the task and generally you want to respond to those as soon

00:18:00,169 --> 00:18:04,489
As possible fair enough, but if you have things like timers or you have stuff coming from the network

00:18:04,730 --> 00:18:06,720
I really recommend using requestanimationframe

00:18:06,720 --> 00:18:12,079
To batch that work together especially if you already have animations running because you can save yourself a lot of duplicate work

00:18:12,090 --> 00:18:17,299
I treat tasks like I treat people who drink fizzy water

00:18:17,820 --> 00:18:19,820
Like I acknowledge that they exist

00:18:20,190 --> 00:18:24,830
But I keep our interaction to a minimum because I do not trust them at all

00:18:24,830 --> 00:18:31,669
I mean I would consider myself an empathetic person, but I have limits like I think soda water is

00:18:32,309 --> 00:18:37,819
Totally disgusting, and I cannot think of a way that a human being could drink fizzy water

00:18:38,519 --> 00:18:43,819
Without gagging or being sick or passing out or something so people when I say someone who does drink fizzy water?

00:18:43,820 --> 00:18:47,840
I think there must be something there must be something else going on with them

00:18:48,179 --> 00:18:52,038
I maintain a Twitter list of people who drink fizzy water

00:18:54,720 --> 00:19:00,199
It's not a creepy thing I just I just wanna make sure I know what they're up to and what they're doing

00:19:00,899 --> 00:19:03,859
but when I find the link between these people and

00:19:06,240 --> 00:19:08,839
Brexit and Donald Trump. I am blowing the case wide open

00:19:09,870 --> 00:19:17,359
taking him straight to the FBI and it pains me to tell you this JSConf, but this conspiracy goes straight to the top I

00:19:18,870 --> 00:19:21,979
Saw him in airport drinking fizzy water

00:19:22,649 --> 00:19:26,569
Every now and then someone else a toons like over Jake you drink diet coke

00:19:26,570 --> 00:19:30,980
And I think you'll find the main ingredient is fizzy water ha ha ha ha no that's different

00:19:31,049 --> 00:19:36,619
That's completely different like the main ingredient of air is nitrogen right?

00:19:36,750 --> 00:19:42,679
But you would still die if that's all you breathed, so it's more like that you cannot survive on just fizzy water

00:19:43,980 --> 00:19:46,789
What was I talking about? requestAnimationFrame, right

00:19:47,669 --> 00:19:52,819
There's one more detail I want to get to and this is something that caught catches a lot of developers out it caught me out

00:19:53,550 --> 00:19:58,609
requestAnimationFrame it comes before processing CSS and before painting

00:19:59,550 --> 00:20:06,109
So code like this might seem expensive like we're showing and hiding a box many many times, but this is actually really cheap like

00:20:06,690 --> 00:20:09,619
JavaScript will always run to completion before rendering happens

00:20:09,620 --> 00:20:14,780
So while you're doing this the browser just sits back, and it lets you have your fun changing a value

00:20:14,880 --> 00:20:19,340
And it doesn't really think about it in terms of CSS at all and then at the end

00:20:19,860 --> 00:20:23,090
When it actually comes around to the render steps it goes, right?

00:20:23,520 --> 00:20:27,499
What did you actually change in the end? And the only bit that matters is this final line

00:20:29,310 --> 00:20:32,330
And this explains a gotcha in CSS or at least something that caught me out

00:20:32,330 --> 00:20:37,309
I had a thing right, that I wanted to animate from an X position of

00:20:38,040 --> 00:20:40,040
1000 to

00:20:40,410 --> 00:20:41,850
00:20:41,850 --> 00:20:48,050
And that sounds easy right so I had my listener here. I set the X position to 1000

00:20:48,050 --> 00:20:52,099
I told it to transition and I changed the value to 500

00:20:53,490 --> 00:20:59,060
But that animated from 0 to 500 and that's like come on browser. That's not

00:21:00,420 --> 00:21:02,000
What I asked you to do. It's very clear

00:21:02,000 --> 00:21:08,810
I said 1000 transition to 500 what I was like I figured out that maybe I'm giving it too much information

00:21:09,210 --> 00:21:11,210
All at once

00:21:11,280 --> 00:21:17,570
And it's the same reason we saw before like the browser is not going to think about it. Come just install one block of JavaScript

00:21:18,120 --> 00:21:20,570
So it's going to ignore that first transform value

00:21:21,180 --> 00:21:27,409
So ok fair enough what I'll do then is I'm going to put this second bit I'm gonna put inside a requestAnimationFrame and now

00:21:28,320 --> 00:21:32,840
It still animates from 0 to 500, and I was like. What is what is going on here

00:21:33,510 --> 00:21:37,969
well, I will tell you what's going on because I finally figured it out the user clicks on the button and

00:21:38,520 --> 00:21:45,410
That's a task so we come around to here and this is where we set the initial transform and the transition fine

00:21:45,930 --> 00:21:53,930
We queue an animation frame, and we go around and this is where we set the destination the final transform value

00:21:54,720 --> 00:21:58,970
But the browser doesn't think about CSS until this next step over the purple block there

00:21:58,970 --> 00:22:02,330
This is where it calculates the CSS so again

00:22:02,580 --> 00:22:08,179
It totally misses the first value because it hasn't thought about styles in between those two things being set

00:22:09,300 --> 00:22:10,880
And that's why to make this work

00:22:10,880 --> 00:22:16,640
You need to use not one, but two requests animation frames and now this will animate from 1,000 to 500

00:22:18,330 --> 00:22:23,990
Incidentally, there is a hacky alternative for this you can use something like getComputedStyle and just access one of the properties on it

00:22:23,990 --> 00:22:28,490
And this forces the browser to perform style calculation a lot earlier than it naturally would

00:22:29,280 --> 00:22:33,859
But it makes the browser take note of all of the things you set up until that point so it's like oh, okay

00:22:34,800 --> 00:22:38,029
Transform translate X 1000 that's a thing that this element does

00:22:38,970 --> 00:22:43,790
But you need to be careful with doing this because you can end up forcing the browser to do a lot of extra style work than it

00:22:43,860 --> 00:22:46,670
Really wants to it only really wants to do that once per frame

00:22:47,790 --> 00:22:50,209
In reality the best way to deal with this

00:22:50,400 --> 00:22:55,969
Would be the animation API the web animation API because you can just say I want it to go from here to this other

00:22:55,970 --> 00:23:01,670
Value and it all just works, but that's only in Chrome, so it's not really worth talking about right now

00:23:04,740 --> 00:23:06,740
So

00:23:06,810 --> 00:23:12,229
If the position if requestAnimationFrame within the render steps if that was a surprise to you if that was something you didn't know already

00:23:12,930 --> 00:23:18,229
It's probably not your fault. You might have been misled by particular implementations because Edge and Safari

00:23:18,230 --> 00:23:20,719
They get this very wrong they put RAF around about here

00:23:21,450 --> 00:23:23,450
most notably they put it after paint

00:23:24,210 --> 00:23:29,840
And that's kind of annoying because it means like if the user clicks somewhere or something happens, and you want to batch that work

00:23:29,840 --> 00:23:31,840
You've been using requestAnimationFrame

00:23:32,040 --> 00:23:37,550
Edge and Safari they will render before they get to your callback so the user's going to see something

00:23:38,340 --> 00:23:44,000
and that means that you're not going to see the actual changes you make until the next frame along and that's adding quite a

00:23:44,100 --> 00:23:46,579
significant delay to things appearing on the screen

00:23:47,100 --> 00:23:51,500
And it also makes it really difficult to batch work together. I hope this is something they fix soon

00:23:51,540 --> 00:23:56,869
Is there's been activity on the bugs recently, but the web standards say it should be here, and that's where it is in

00:23:57,390 --> 00:23:59,390
Firefox and Chrome

00:23:59,670 --> 00:24:03,560
Ok that's enough about requestAnimationFrame. I want to take a look at microtasks

00:24:04,230 --> 00:24:07,130
this is probably the least understood part of the event loop I'd say I

00:24:08,280 --> 00:24:10,080
strongly associate

00:24:10,080 --> 00:24:17,960
Microtasks with promises, but this is not where they started back in the 1990s browsers wanted to give developers a way to monitor DOM changes

00:24:18,510 --> 00:24:24,979
And the w3c went okay, I'll sort that out for you, and they gave us mutation events so this is where I could say okay

00:24:24,980 --> 00:24:29,839
I want to know when a node is inserted into the body element and fine excellent

00:24:29,840 --> 00:24:31,840
And you get a series of other events as well

00:24:33,060 --> 00:24:38,749
But in practice this was pretty problematic we take this bit of code here what I'm doing is I'm adding a hundred spans

00:24:39,180 --> 00:24:41,180
into the the body element

00:24:41,340 --> 00:24:48,199
How many events would you expect to receive as a result of this? one event? one event for the whole operation?

00:24:49,140 --> 00:24:50,910
nope

00:24:50,910 --> 00:24:53,599
100 events one for each span yes

00:24:54,120 --> 00:24:56,070
But also another hundred

00:24:56,070 --> 00:24:57,750
for this line here when

00:24:57,750 --> 00:25:04,040
Content is going into the actual span a text node is going into the span and because these events bubble this simple piece of code

00:25:04,040 --> 00:25:06,040
Is going to land you with 200 events

00:25:06,840 --> 00:25:09,829
And because of this like relatively simple DOM modifications

00:25:10,020 --> 00:25:16,009
ended up triggering thousands of events and if you were doing like a tiny bit of work in these listeners that quickly became a

00:25:16,080 --> 00:25:18,560
Big bit of work, and it was a performance disaster

00:25:19,110 --> 00:25:22,490
What we really wanted was a way to sort of hear about a batch of this work

00:25:22,490 --> 00:25:25,819
It's similar to what we saw with styles before we want the browser to kind of sit back

00:25:26,130 --> 00:25:29,810
Let us do some stuff and then at a convenient point say

00:25:30,240 --> 00:25:35,120
Some stuff changed it here is a kind of an event or something to represent all of those changes

00:25:36,240 --> 00:25:42,530
We want to hear about it once not 200 times and the answer became mutation observers, and they created a new queue called microtasks

00:25:43,320 --> 00:25:50,630
a lot of documentation I read about microtasks suggests that it happens like I don't know every turn of the event loop or

00:25:50,910 --> 00:25:55,160
It happens after a task or something like that and that's kind of true

00:25:55,770 --> 00:26:00,770
There is a single place on the event loop where micro tasks happen, but that is not where you'll generally encounter it

00:26:01,440 --> 00:26:06,500
They also happen whenever JavaScript finishes executing yeah

00:26:06,500 --> 00:26:12,319
that means that the JavaScript stack has gone from having stuff in it to having no stuff in it and

00:26:12,690 --> 00:26:14,220
That's where we run micro tasks

00:26:14,220 --> 00:26:16,370
So you can end up with microtasks happening

00:26:16,710 --> 00:26:22,550
halfway through a task you can have happen we can have micro tasks in the render steps as part of request animation frames kind of

00:26:22,550 --> 00:26:24,550
anywhere anywhere JavaScript can run

00:26:25,440 --> 00:26:27,440
So that means this JavaScript will run to completion

00:26:27,900 --> 00:26:33,530
Adding a hundred spans and their contents JavaScript finishes executing and we get our mutation observer callback

00:26:34,770 --> 00:26:40,579
Promise has made use of them as well so here we queue a micro task and then log yo

00:26:41,429 --> 00:26:43,429
JavaScript is finished executing

00:26:43,500 --> 00:26:45,829
So we go for the micro tasks, and we log hey

00:26:46,620 --> 00:26:51,919
And that means when the Promise callback is executing you were guaranteed that no other JavaScript is

00:26:52,140 --> 00:26:57,559
Midway through at the time the Promise callback is right at the bottom of the stack, and that's why promises use micro tasks

00:26:58,710 --> 00:27:02,630
But what happens if we create a loop using micro tasks bit like we did with setTimeout before

00:27:04,260 --> 00:27:06,260
Same demo again

00:27:06,419 --> 00:27:08,340
click the button and

00:27:08,340 --> 00:27:13,819
It blocks rendering it blocks the tab in the same way a plain while loop did very different from setTimeout before

00:27:15,330 --> 00:27:16,799
So

00:27:16,799 --> 00:27:23,509
Promise callbacks are async fine, but what does async actually mean? I mean all it means is that they happen after

00:27:24,330 --> 00:27:28,819
Synchronously executing code, so that's why we get yo before Hey

00:27:29,460 --> 00:27:35,360
But just being async doesn't mean it must yield to rendering doesn't mean it must yield to any particular part of the event loop

00:27:36,690 --> 00:27:40,130
We've looked at three different queues so far we looked at task queues

00:27:40,830 --> 00:27:45,949
animation callback queues which is where requestAnimationFrame callbacks happen and now we're looking at micro tasks and

00:27:46,320 --> 00:27:48,320
Just to make your lives a little bit easier

00:27:48,929 --> 00:27:51,739
They all are processed very subtly differently

00:27:51,960 --> 00:27:57,290
Like we've seen with task queues we take one item and we take one item only and if another item is queued

00:27:57,290 --> 00:27:59,290
It just goes to the end of the queue fine

00:28:00,419 --> 00:28:03,649
animation callbacks they happen until completion

00:28:04,740 --> 00:28:10,309
Except ones that were queued while we were processing animation callbacks. They are deferred to the next frame

00:28:11,130 --> 00:28:13,969
Micro tasks on the other hand they are processed to completion

00:28:14,700 --> 00:28:15,570
including any

00:28:15,570 --> 00:28:22,160
Additionally queued items so if you were adding items to the queue as quickly as you're processing them you are processing micro tasks forever

00:28:22,740 --> 00:28:28,819
The event loop cannot continue until that queue has completely emptied and that is why it blocks rendering

00:28:29,580 --> 00:28:34,220
Sorry, I get I get really excited about this stuff. I hope I hope other people are excited about this as I am

00:28:35,190 --> 00:28:38,030
Thanks. Thank you. Thanks one person excellent

00:28:39,120 --> 00:28:42,530
Do I used to have a real job right like many of you did?

00:28:43,559 --> 00:28:48,629
This stuff like that sort of speaking the standards work the creating slides. This used to be my hobby

00:28:49,330 --> 00:28:53,279
But then my hobby became my job, and now I have no hobbies

00:28:53,680 --> 00:28:59,070
I'm a boring person now, and I think didn't I didn't actually notice when this happened like

00:28:59,620 --> 00:29:05,640
Genuinely doing the first time. I noticed I went for an eye test and the optician just making small talk

00:29:06,160 --> 00:29:07,780
asked and

00:29:07,780 --> 00:29:09,780
And what are your hobbies?

00:29:10,620 --> 00:29:11,960
Oh shit

00:29:12,790 --> 00:29:14,790
When did this happen I don't have any

00:29:15,700 --> 00:29:21,029
Like I said, I stress, so I I got a bit like oh, I can't I can't say nothing who says nothing so I

00:29:21,550 --> 00:29:23,999
totally true I panicked and I said I

00:29:25,080 --> 00:29:27,560
Play the piano I don't play the piano

00:29:29,020 --> 00:29:33,360
And I stressed even more cuz I thought like she was going to say. Oh well. That's great

00:29:33,880 --> 00:29:37,500
We don't need to use the letters chart, then here's some sheet music

00:29:38,500 --> 00:29:41,440
Can you read me the first five bars? What chord is this?

00:29:42,280 --> 00:29:48,810
Thankfully she didn't but yeah my optician now thinks I'm a pianist that was great. I don't go back to the optician's anymore

00:29:48,810 --> 00:29:53,020
I'm terrified of like more piano chat. I don't know how I survive in the real world

00:29:53,800 --> 00:29:56,340
Right I think you're ready for this next one

00:29:57,610 --> 00:30:03,420
Occasionally I run little JavaScript quizzes. Maybe that's my hobby. Nope that's work too never mind. Yes

00:30:03,420 --> 00:30:09,599
I run little JavaScript quizzes, and this is my favorite question, so I've got a button an onclick I resolved a promise and then

00:30:10,150 --> 00:30:12,150
log something

00:30:12,310 --> 00:30:16,889
But I have two event listeners on the same element doing the same thing so

00:30:17,890 --> 00:30:19,890
if the user clicks a button

00:30:20,230 --> 00:30:23,099
What happens? In which order are things logged?

00:30:26,230 --> 00:30:27,340
Well

00:30:27,340 --> 00:30:29,040
our first listener executes great

00:30:29,040 --> 00:30:30,580
So that's on the JavaScript stack

00:30:30,580 --> 00:30:35,369
Queues a micro task and then we get to the next line where we log Listener 1 and that's the first answer

00:30:36,790 --> 00:30:41,670
Most folks agree on that bit but what next and I ran a Twitter poll on this last week

00:30:41,670 --> 00:30:43,670
I've been speaking to a few of you a few of you saw it

00:30:43,870 --> 00:30:50,940
Most people would say the next thing logged is Listener 2 that's 63 percent 5% of people think NaN is just logged and then Infinity

00:30:51,310 --> 00:30:56,399
that is not the answer, but fair enough to that five percent of people, but yes, we've got 63 percent and

00:30:57,550 --> 00:30:59,550
Listener 2 is the wrong answer

00:30:59,620 --> 00:31:06,969
This is a real gotcha with script, but if you thought it was Listener 2 then you're in very good company, so don't worry about it

00:31:07,970 --> 00:31:13,659
Our listener has finished, so we've gone from having something on the JavaScript stack to nothing

00:31:14,299 --> 00:31:16,389
So it is micro task time

00:31:16,520 --> 00:31:21,159
we are going to run that promise and we are going to log Microtask 1 and there we go and

00:31:21,740 --> 00:31:27,400
Then it's time for the second listener and that works the same so the order is Listener 1 Microtask 1 Listener 2 Microtask 2

00:31:28,970 --> 00:31:36,130
But that's if the user clicks the button what if the button is clicked using javascript. Oh, yes, it's different

00:31:37,549 --> 00:31:42,908
For starters our script is on the stack. We call click and that synchronously

00:31:43,669 --> 00:31:46,778
Dispatches the events so we start with listener one great

00:31:47,299 --> 00:31:51,519
We queue a microtask and we log listener one and now it's microtask time no

00:31:51,520 --> 00:31:54,459
No, it is not microtask time. We can't run microtasks

00:31:54,460 --> 00:31:59,500
This is where it's different because our JavaScript stack is not empty button dot click has not returned yet

00:32:00,380 --> 00:32:07,029
So we move on to Listener 2 we queue another microtask and now we log Listener 2 and this is where it diverges

00:32:08,120 --> 00:32:11,049
And now our listener is done in fact all our listeners are done

00:32:11,120 --> 00:32:15,819
Button dot click returns, our JavaScript stack empties and now we can process those microtasks

00:32:15,820 --> 00:32:21,070
And they happen in order and this has real-world implications they so beware if you're using

00:32:21,980 --> 00:32:26,289
like promises in this way, you're using if you're using automated tests as well because

00:32:27,289 --> 00:32:29,349
Automated tests if they're clicking things on the page

00:32:29,350 --> 00:32:33,490
They're likely to be using javascript to do it and that can change the behavior of your code

00:32:34,220 --> 00:32:36,220
This also came up when we were looking at how to add

00:32:36,380 --> 00:32:40,479
Observables to the DOM and how they'd integrate with promises we hit this question

00:32:40,850 --> 00:32:47,319
If we have a promise that represents the the next click of a particular link. It's just this little bit of code here

00:32:47,929 --> 00:32:50,679
Can someone use that promise and still call

00:32:51,230 --> 00:32:53,230
event dot preventDefault?

00:32:53,990 --> 00:32:55,789
promises are async

00:32:55,789 --> 00:33:00,459
So have we missed our chance to prevent the default here? Turns out no, It's fine. It's totally fine this works

00:33:00,460 --> 00:33:02,460
This just works unless again

00:33:02,960 --> 00:33:07,149
The user clicks the link er some code clicks the link using javascript

00:33:07,250 --> 00:33:11,409
And this is the final puzzle of the talk I'm overrunning a little bit to figure this out

00:33:11,409 --> 00:33:13,409
We actually need to take a look at the spec

00:33:13,540 --> 00:33:16,869
So this is a very rough description of how the spec for clicking a link works

00:33:17,360 --> 00:33:24,280
but we start by creating an event object and then for every listener we have we invoke that listener with the event object and

00:33:24,500 --> 00:33:27,910
Then we take a look at has that event object's canceled flag been

00:33:28,910 --> 00:33:31,509
Set if it's been set then we're not going to follow the hyperlink

00:33:31,510 --> 00:33:38,469
But if it's unset we will follow the hyperlink when you call event dot preventDefault it sets this canceled flag on the event object

00:33:39,470 --> 00:33:45,579
So if the user clicks a link that's fine our micro tasks happen here after each callback because that's where the JavaScript stack empties

00:33:45,770 --> 00:33:50,799
But when we call click with JavaScript. It's just going to call out to our process a link click

00:33:51,500 --> 00:33:57,160
Algorithm, and it only returns once that algorithm is complete so the JavaScript stack never empties

00:33:57,860 --> 00:34:00,760
During this algorithm so our micro tasks can't happen

00:34:01,610 --> 00:34:04,479
so it hits this step three where it looks at the event object and

00:34:05,030 --> 00:34:08,769
Even if you've got loads of promises trying to call like preventDefault

00:34:09,409 --> 00:34:16,209
It's too late. It's going to follow the hyperlink and then sometime later those promise callbacks happen, but you've missed the boat

00:34:16,240 --> 00:34:18,909
You've missed a point where you can actually cancel that event so

00:34:20,389 --> 00:34:24,819
Remember that micro tasks they you know they behave quite differently depending on the JavaScript stack

00:34:26,540 --> 00:34:31,479
Ok so that 34 minutes that was a massive brain dump of everything

00:34:31,480 --> 00:34:35,770
I know about the event loop and the various steps and various queues. I have found that knowing this stuff

00:34:36,139 --> 00:34:39,219
Like it prevents that case where you kind of got a bit of code

00:34:39,220 --> 00:34:40,629
That's not doing what you want

00:34:40,629 --> 00:34:43,239
So you just wrap it in a setTimeout and now it kind of works sometimes

00:34:43,550 --> 00:34:49,749
Knowing the stuff kind of helps avoid that it helps me avoid jank by getting stuff running on the correct part of the event loop

00:34:49,750 --> 00:34:54,250
As well, and I hope I managed to explain this stuff in a way that is helpful to you too, like I said

00:34:54,250 --> 00:34:56,409
I'm a stressful person so as a result of this

00:34:56,409 --> 00:35:01,089

YouTube URL: https://www.youtube.com/watch?v=cCOL7MC4Pl0


