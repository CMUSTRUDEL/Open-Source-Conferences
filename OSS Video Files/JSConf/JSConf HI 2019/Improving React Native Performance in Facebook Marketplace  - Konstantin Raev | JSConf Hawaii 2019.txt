Title: Improving React Native Performance in Facebook Marketplace  - Konstantin Raev | JSConf Hawaii 2019
Publication date: 2019-06-24
Playlist: JSConf HI 2019
Description: 
	Konstantin Raev talks about reaching React Native performance goals for Facebook Marketplace--one of Facebook's biggest applications.

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:05,610 --> 00:00:13,920
so my name is Constantine and I'll learn

00:00:09,540 --> 00:00:19,400
how to use this remote just another

00:00:13,920 --> 00:00:19,400
second so there are just three buttons

00:00:23,419 --> 00:00:30,329
I'll use my finger and I just press

00:00:26,640 --> 00:00:33,120
spacebar here so I work for Facebook on

00:00:30,329 --> 00:00:35,220
Marketplace team and I mostly focus on

00:00:33,120 --> 00:00:37,350
performance recently before joining

00:00:35,220 --> 00:00:40,440
marketplace in Seattle I worked in

00:00:37,350 --> 00:00:44,640
Facebook UK and I worked on yarn package

00:00:40,440 --> 00:00:46,500
manager anyone loves packages and before

00:00:44,640 --> 00:00:48,479
that I worked on react native so I'm a

00:00:46,500 --> 00:00:52,399
little bit biased towards what framework

00:00:48,479 --> 00:00:52,399
to choose when you build a mobile app so

00:00:53,180 --> 00:00:58,769
today I'm going to talk what I have been

00:00:56,640 --> 00:01:03,119
working on for the last year actually

00:00:58,769 --> 00:01:04,860
making Marketplace load faster just

00:01:03,119 --> 00:01:08,189
before we start anyone is familiar with

00:01:04,860 --> 00:01:12,960
react nice

00:01:08,189 --> 00:01:16,619
how about react native much less so this

00:01:12,960 --> 00:01:19,680
talk is I made it so that you could

00:01:16,619 --> 00:01:20,909
actually take it home some ideas how to

00:01:19,680 --> 00:01:23,460
make your application faster

00:01:20,909 --> 00:01:25,799
specifically react native but it also

00:01:23,460 --> 00:01:27,659
applies to react and actually if you

00:01:25,799 --> 00:01:32,579
think about it it applies to any other

00:01:27,659 --> 00:01:35,429
application so first of all what is

00:01:32,579 --> 00:01:39,149
marketplace anyone used marketplace

00:01:35,429 --> 00:01:41,369
before so it's a platform it's actually

00:01:39,149 --> 00:01:44,460
a tab inside Facebook application anyone

00:01:41,369 --> 00:01:46,460
knows about Facebook so it's a social

00:01:44,460 --> 00:01:48,590
network

00:01:46,460 --> 00:01:50,960
and there are tabs in it and marketplace

00:01:48,590 --> 00:01:53,360
is one of the tabs it's a place where

00:01:50,960 --> 00:01:58,210
you can buy and sell things to people in

00:01:53,360 --> 00:02:01,580
your community so marketplace started in

00:01:58,210 --> 00:02:03,920
2016 and it took us to build to build

00:02:01,580 --> 00:02:06,290
the first version for iOS just six

00:02:03,920 --> 00:02:09,590
months and actually we tested it in

00:02:06,290 --> 00:02:12,620
Hawaii so it means that this stock sort

00:02:09,590 --> 00:02:14,690
of brings it back home then it took us

00:02:12,620 --> 00:02:16,790
just two months to build the Android

00:02:14,690 --> 00:02:20,450
version and this is actually quite rare

00:02:16,790 --> 00:02:24,860
for applications of this size in company

00:02:20,450 --> 00:02:25,880
of this this size because it's usually

00:02:24,860 --> 00:02:28,459
like six months

00:02:25,880 --> 00:02:30,920
iOS then another six months Android but

00:02:28,459 --> 00:02:33,620
because we reused JavaScript and 90% of

00:02:30,920 --> 00:02:35,380
the code was reused we were able to do

00:02:33,620 --> 00:02:38,390
it just in two months

00:02:35,380 --> 00:02:41,300
so what officially launched in October

00:02:38,390 --> 00:02:44,870
2016 to mainland US and some other

00:02:41,300 --> 00:02:47,360
countries and now it's global and there

00:02:44,870 --> 00:02:51,700
are more than 800 million people using

00:02:47,360 --> 00:02:54,290
this application every month and

00:02:51,700 --> 00:02:56,420
marketplace is more than just buying and

00:02:54,290 --> 00:02:59,120
selling items to people around you it's

00:02:56,420 --> 00:03:04,060
also both buying a car finding a place

00:02:59,120 --> 00:03:06,950
to live some daily deals some business

00:03:04,060 --> 00:03:09,440
opportunities quite a lot the team is

00:03:06,950 --> 00:03:11,540
quite large it's more than 100 engineers

00:03:09,440 --> 00:03:16,670
working on the same react native code

00:03:11,540 --> 00:03:19,780
base so market will plays grew from 0 to

00:03:16,670 --> 00:03:23,810
800 million in just about two years and

00:03:19,780 --> 00:03:26,510
the Tube team grew as well so we need to

00:03:23,810 --> 00:03:29,570
hire more people and we need to make the

00:03:26,510 --> 00:03:31,880
application nice to work with and react

00:03:29,570 --> 00:03:37,730
native played a big role in how to make

00:03:31,880 --> 00:03:41,660
a good developer experience so anyone is

00:03:37,730 --> 00:03:43,459
familiar with hot reloading anyone knows

00:03:41,660 --> 00:03:46,730
the difference between live reloading

00:03:43,459 --> 00:03:49,640
and hot reloading all right not everyone

00:03:46,730 --> 00:03:52,760
so live reloading is when you develop a

00:03:49,640 --> 00:03:55,430
website you change your code type

00:03:52,760 --> 00:03:58,250
something save it and then your browser

00:03:55,430 --> 00:04:00,400
or application refreshes with the latest

00:03:58,250 --> 00:04:03,349
code and you see the changes

00:04:00,400 --> 00:04:07,549
hot reloading is when you make your

00:04:03,349 --> 00:04:09,560
changes on your laptop like here make

00:04:07,549 --> 00:04:13,579
some code some code changes to my react

00:04:09,560 --> 00:04:16,400
component I press save and then it goes

00:04:13,579 --> 00:04:18,919
to the device and only the components

00:04:16,400 --> 00:04:22,250
that actually changed get re-rendered

00:04:18,919 --> 00:04:25,520
as usual react tree renders components

00:04:22,250 --> 00:04:26,990
at at its pleasure and this iteration is

00:04:25,520 --> 00:04:30,550
quite fast because I'm just changing

00:04:26,990 --> 00:04:32,870
code a little bit and here we go and

00:04:30,550 --> 00:04:35,419
another thing that you probably don't

00:04:32,870 --> 00:04:37,910
know at Facebook we don't like building

00:04:35,419 --> 00:04:39,919
the Facebook application will love the

00:04:37,910 --> 00:04:42,020
application but building it is not fun

00:04:39,919 --> 00:04:44,750
because it takes 30 minutes to have a

00:04:42,020 --> 00:04:47,479
new binary on your device because we

00:04:44,750 --> 00:04:50,090
have millions of files something good

00:04:47,479 --> 00:04:52,910
about react native as I mentioned 90% of

00:04:50,090 --> 00:04:55,370
the code or even more is written in

00:04:52,910 --> 00:04:58,460
JavaScript and we don't need to change

00:04:55,370 --> 00:05:00,620
the native code that often so what we

00:04:58,460 --> 00:05:03,349
can do is we can grab the latest binary

00:05:00,620 --> 00:05:06,080
from a build server install it on the

00:05:03,349 --> 00:05:08,259
device and then build the JavaScript

00:05:06,080 --> 00:05:10,880
file from the source code

00:05:08,259 --> 00:05:15,050
as a matter of fact we have integration

00:05:10,880 --> 00:05:16,820
with our IDE that just grabs this binary

00:05:15,050 --> 00:05:22,550
and does everything with just one single

00:05:16,820 --> 00:05:25,550
click another big deal is hiring people

00:05:22,550 --> 00:05:29,360
as I told you marketplace team has grown

00:05:25,550 --> 00:05:32,150
a lot to build a lot of features and at

00:05:29,360 --> 00:05:34,099
Facebook we have a joke that it's really

00:05:32,150 --> 00:05:37,280
hard to find Android developers because

00:05:34,099 --> 00:05:39,469
we already hired every Android developer

00:05:37,280 --> 00:05:44,149
who wanted to work for us

00:05:39,469 --> 00:05:45,709
so we we need a high incidentally there

00:05:44,149 --> 00:05:49,209
are more JavaScript developers around

00:05:45,709 --> 00:05:51,769
still hard to hire them but possible

00:05:49,209 --> 00:05:53,749
less than 5% of people working on

00:05:51,769 --> 00:05:57,259
marketplace are actually specializing in

00:05:53,749 --> 00:05:59,269
native platforms it doesn't mean that we

00:05:57,259 --> 00:06:00,949
don't use their skills we just leverage

00:05:59,269 --> 00:06:03,769
their ability to work on something

00:06:00,949 --> 00:06:06,349
complex platform specific all the other

00:06:03,769 --> 00:06:09,469
people are quite quick to adapt to their

00:06:06,349 --> 00:06:15,169
javascript code base and become quite

00:06:09,469 --> 00:06:19,069
proficient building features Repton

00:06:15,169 --> 00:06:21,459
react native are also very popular if

00:06:19,069 --> 00:06:26,769
you count github stars which I do

00:06:21,459 --> 00:06:31,159
periodically there it probably in top 10

00:06:26,769 --> 00:06:34,639
frameworks on github by star count of

00:06:31,159 --> 00:06:36,979
course it doesn't matter but if you look

00:06:34,639 --> 00:06:38,629
at the number of contributors individual

00:06:36,979 --> 00:06:40,909
people who contribute to the codebase

00:06:38,629 --> 00:06:44,569
react native is one of the top projects

00:06:40,909 --> 00:06:46,969
and also it built a community around it

00:06:44,569 --> 00:06:49,849
what I'm saying is that when we hire

00:06:46,969 --> 00:06:52,309
people from outside to work on

00:06:49,849 --> 00:06:55,159
marketplace those people are very likely

00:06:52,309 --> 00:06:57,800
already familiar with our technology

00:06:55,159 --> 00:07:02,269
technology and it means that they can be

00:06:57,800 --> 00:07:04,699
productive straightaway so I just

00:07:02,269 --> 00:07:06,740
described react native a JavaScript

00:07:04,699 --> 00:07:10,579
framework that allowed us to grow the

00:07:06,740 --> 00:07:13,550
team fast but what about javascript and

00:07:10,579 --> 00:07:16,669
been building an application that works

00:07:13,550 --> 00:07:20,709
fast javascript has a lot of things that

00:07:16,669 --> 00:07:24,309
people people say that it's not good for

00:07:20,709 --> 00:07:28,459
performance it's garbage collected

00:07:24,309 --> 00:07:30,919
anyone else has ideas yes

00:07:28,459 --> 00:07:34,069
dynamic typing I'm just kidding I

00:07:30,919 --> 00:07:36,769
actually have it written here it has

00:07:34,069 --> 00:07:39,139
module system that's not really mature

00:07:36,769 --> 00:07:41,989
enough we have not different module

00:07:39,139 --> 00:07:43,999
system it's single threaded how do you

00:07:41,989 --> 00:07:45,289
build a UI when single threaded but

00:07:43,999 --> 00:07:47,259
thankfully we actually have a

00:07:45,289 --> 00:07:49,879
synchronous code and co-routines

00:07:47,259 --> 00:07:53,030
but anyway a lot of people are biased

00:07:49,879 --> 00:07:56,330
about javascript and there are reasons

00:07:53,030 --> 00:07:58,610
so Facebook occasionally surveys people

00:07:56,330 --> 00:08:00,830
who are using their applications and

00:07:58,610 --> 00:08:03,980
there is a direct correlation between

00:08:00,830 --> 00:08:05,690
how fast the application loads and how

00:08:03,980 --> 00:08:10,370
satisfied are people with the

00:08:05,690 --> 00:08:12,770
application and performance work that we

00:08:10,370 --> 00:08:15,290
did on marketplace in the last year

00:08:12,770 --> 00:08:17,660
shows that people engage more with the

00:08:15,290 --> 00:08:19,550
application if it loads faster for every

00:08:17,660 --> 00:08:21,860
hundred milliseconds there is a certain

00:08:19,550 --> 00:08:24,560
percent of improvement of how people

00:08:21,860 --> 00:08:26,120
engage with marketplace and I'm not

00:08:24,560 --> 00:08:27,890
talking about just looking at the screen

00:08:26,120 --> 00:08:30,200
and I'm going away I'm actually good I'm

00:08:27,890 --> 00:08:33,950
I'm actually meaning that it sticks to

00:08:30,200 --> 00:08:36,830
people if something loads fast so

00:08:33,950 --> 00:08:38,719
Facebook application leadership spend

00:08:36,830 --> 00:08:40,880
some time researching how fast the

00:08:38,719 --> 00:08:44,060
application should be for people to feel

00:08:40,880 --> 00:08:46,040
comfortable with it and in the last 40

00:08:44,060 --> 00:08:50,150
years there have been a lot of

00:08:46,040 --> 00:08:52,760
researches and the consensus is that if

00:08:50,150 --> 00:08:55,100
the application if a computer system

00:08:52,760 --> 00:08:59,990
refreshes a screen within one second

00:08:55,100 --> 00:09:02,480
then people perceive that it's fast so

00:08:59,990 --> 00:09:05,330
that was the goal for all the tabs at

00:09:02,480 --> 00:09:08,750
Facebook how do we make them fast as in

00:09:05,330 --> 00:09:11,260
load within one second and on a slow

00:09:08,750 --> 00:09:14,780
device like this

00:09:11,260 --> 00:09:19,250
Samsung j5 prime which is not a nicest

00:09:14,780 --> 00:09:21,290
device that around but surprisingly it's

00:09:19,250 --> 00:09:24,080
one of the most popular devices in the

00:09:21,290 --> 00:09:29,060
world so we started with three and a

00:09:24,080 --> 00:09:31,760
half seconds for 75% of people load in

00:09:29,060 --> 00:09:33,589
marketplace and when we heard about the

00:09:31,760 --> 00:09:38,810
goal we thought well it's a bit humorous

00:09:33,589 --> 00:09:42,260
70 % improvement are you serious

00:09:38,810 --> 00:09:44,330
a year passed and turns out they

00:09:42,260 --> 00:09:47,060
believed in us and they were serious so

00:09:44,330 --> 00:09:50,300
we are getting closer so what I'm going

00:09:47,060 --> 00:09:53,150
to talk next about is how we achieved

00:09:50,300 --> 00:09:55,610
that and I tried to focus on things that

00:09:53,150 --> 00:09:57,980
you people working on react and react

00:09:55,610 --> 00:10:01,610
native could actually bring it home and

00:09:57,980 --> 00:10:04,100
reuse it and even though many people

00:10:01,610 --> 00:10:07,490
hold JavaScript as a liability of react

00:10:04,100 --> 00:10:10,310
native I think it's on the contrary we

00:10:07,490 --> 00:10:12,830
have many years of experience optimizing

00:10:10,310 --> 00:10:15,080
websites and if you haven't seen this

00:10:12,830 --> 00:10:18,140
talk from ilya grigorik

00:10:15,080 --> 00:10:20,810
from six years ago pretty much

00:10:18,140 --> 00:10:25,520
everything applies to optimizing react

00:10:20,810 --> 00:10:27,890
native so similar to optimizing websites

00:10:25,520 --> 00:10:30,380
or any other application we start with

00:10:27,890 --> 00:10:33,140
measuring all different sub spans how

00:10:30,380 --> 00:10:35,540
things are loading then we find the slow

00:10:33,140 --> 00:10:37,160
things and we make a decision it is

00:10:35,540 --> 00:10:39,380
something that we really need at the

00:10:37,160 --> 00:10:43,100
startup that we call the critical path

00:10:39,380 --> 00:10:45,380
or is it something and if it is not

00:10:43,100 --> 00:10:47,390
let's just do it later and if it is

00:10:45,380 --> 00:10:52,640
let's do it in parallel with something

00:10:47,390 --> 00:10:55,130
else so what's another cool thing about

00:10:52,640 --> 00:10:58,280
JavaScript and ability to debug your

00:10:55,130 --> 00:11:00,830
applications is that JavaScript can run

00:10:58,280 --> 00:11:03,290
on many things and there is a feature

00:11:00,830 --> 00:11:05,390
called debug JavaScript remotely on

00:11:03,290 --> 00:11:07,550
react native and not a lot of people

00:11:05,390 --> 00:11:10,300
realize that it's actually sending the

00:11:07,550 --> 00:11:14,690
JavaScript application of react native

00:11:10,300 --> 00:11:17,300
to the browser it executes their full

00:11:14,690 --> 00:11:19,490
application builds the component tree

00:11:17,300 --> 00:11:22,010
and then sends signal to the device

00:11:19,490 --> 00:11:24,800
telling what needs to be rendered in the

00:11:22,010 --> 00:11:27,350
native code so full JavaScript is for

00:11:24,800 --> 00:11:29,240
real running in the browser and it means

00:11:27,350 --> 00:11:31,070
that we have access to the development

00:11:29,240 --> 00:11:32,390
tools that are coming with the browsers

00:11:31,070 --> 00:11:35,180
for example in Chrome

00:11:32,390 --> 00:11:38,720
I can click performance tab I can click

00:11:35,180 --> 00:11:40,640
record and get some samples and then it

00:11:38,720 --> 00:11:42,560
has a very good integration with react

00:11:40,640 --> 00:11:44,870
and react native is running react.js

00:11:42,560 --> 00:11:47,480
inside it so we actually have a very

00:11:44,870 --> 00:11:49,970
nice flame chart of all the components

00:11:47,480 --> 00:11:52,130
that are loading and we can see which

00:11:49,970 --> 00:11:54,260
components are slow or which component

00:11:52,130 --> 00:11:56,120
are unnecessary and we can make some

00:11:54,260 --> 00:11:57,860
assumptions like let's let's not have

00:11:56,120 --> 00:12:00,860
this component or let's let's optimize

00:11:57,860 --> 00:12:03,380
that first now you have to take this

00:12:00,860 --> 00:12:06,350
with a grain of salt because we're

00:12:03,380 --> 00:12:11,300
running this on a desktop browser on

00:12:06,350 --> 00:12:15,770
your powerful MacBook probably and it's

00:12:11,300 --> 00:12:17,900
a v8 JavaScript engine on a real device

00:12:15,770 --> 00:12:21,530
it will be a JavaScript core that runs

00:12:17,900 --> 00:12:23,840
on Android and iOS and it's completely

00:12:21,530 --> 00:12:25,700
different picture but if you really want

00:12:23,840 --> 00:12:29,450
to have the same flame chart there is a

00:12:25,700 --> 00:12:31,580
tool called systrace that just collects

00:12:29,450 --> 00:12:33,620
the traces and it integrates with react

00:12:31,580 --> 00:12:38,000
native and you can see how your

00:12:33,620 --> 00:12:40,250
components work on a real device so

00:12:38,000 --> 00:12:43,190
measuring performance is actually an art

00:12:40,250 --> 00:12:45,590
we could be talking have a separate talk

00:12:43,190 --> 00:12:47,330
about how to measure performance on a

00:12:45,590 --> 00:12:49,850
group of people on a large group of

00:12:47,330 --> 00:12:51,680
people how about the distributions

00:12:49,850 --> 00:12:55,250
between different people what kind of

00:12:51,680 --> 00:12:57,620
category of devices exists but I think

00:12:55,250 --> 00:13:01,010
the first two tools that I showed you

00:12:57,620 --> 00:13:03,530
could be a good start how to start

00:13:01,010 --> 00:13:07,370
improving your performance so now let's

00:13:03,530 --> 00:13:10,940
actually look at what things helped us

00:13:07,370 --> 00:13:13,400
to improve react native so this one is

00:13:10,940 --> 00:13:15,190
an obvious one I'm pretty sure everyone

00:13:13,400 --> 00:13:19,100
who is running a mobile application

00:13:15,190 --> 00:13:20,810
should be running their network requests

00:13:19,100 --> 00:13:22,730
in parallel when things are loading

00:13:20,810 --> 00:13:24,380
because you're doing stuff on the server

00:13:22,730 --> 00:13:27,500
and stuff on the client they shouldn't

00:13:24,380 --> 00:13:29,810
be interconnected however there is a

00:13:27,500 --> 00:13:32,620
caveat I know some people are using

00:13:29,810 --> 00:13:37,910
graph girl here who likes graph you'll

00:13:32,620 --> 00:13:39,910
yeah so with mobile and graph QL and

00:13:37,910 --> 00:13:43,400
JavaScript there is a caveat because

00:13:39,910 --> 00:13:45,350
usually people using react native they

00:13:43,400 --> 00:13:47,690
use JavaScript implementation of graph

00:13:45,350 --> 00:13:51,290
queue for those who don't know what

00:13:47,690 --> 00:13:55,310
graph QL is it's a it's a concept that

00:13:51,290 --> 00:13:57,500
allows your components to define what

00:13:55,310 --> 00:14:01,220
they need and it means that the query

00:13:57,500 --> 00:14:03,050
for the data is based on the components

00:14:01,220 --> 00:14:04,910
so you need a graphical engine that

00:14:03,050 --> 00:14:05,690
would inspect your components build a

00:14:04,910 --> 00:14:08,330
query

00:14:05,690 --> 00:14:11,240
and then send this query and if it is in

00:14:08,330 --> 00:14:13,580
JavaScript you see the blue line we need

00:14:11,240 --> 00:14:15,560
to start up JavaScript VM we need to

00:14:13,580 --> 00:14:18,130
start up react native we need to start

00:14:15,560 --> 00:14:20,690
the bundle we need to find the graph QL

00:14:18,130 --> 00:14:24,020
JavaScript implementation and then send

00:14:20,690 --> 00:14:27,740
the request what we should be doing is

00:14:24,020 --> 00:14:30,470
running it in parallel so if you are

00:14:27,740 --> 00:14:32,930
using react native or a very similar

00:14:30,470 --> 00:14:34,760
framework and the graph QL you should

00:14:32,930 --> 00:14:37,220
the question how can I make the request

00:14:34,760 --> 00:14:40,010
in parallel at Facebook we have a very

00:14:37,220 --> 00:14:42,910
thin layer implemented in native code

00:14:40,010 --> 00:14:46,250
that is capable of sending the request

00:14:42,910 --> 00:14:49,610
from Java or from Objective C that's how

00:14:46,250 --> 00:14:53,270
we achieve that also I brought you some

00:14:49,610 --> 00:14:56,840
good news if you update to latest react

00:14:53,270 --> 00:15:00,050
native you will know that it has the

00:14:56,840 --> 00:15:01,910
latest JavaScript core engine for those

00:15:00,050 --> 00:15:04,070
who don't know JavaScript core is the

00:15:01,910 --> 00:15:06,830
JavaScript engine that react native is

00:15:04,070 --> 00:15:10,910
using the problem is that it hasn't been

00:15:06,830 --> 00:15:12,920
updated for two years and it has been 32

00:15:10,910 --> 00:15:15,820
bits and now we have the latest one

00:15:12,920 --> 00:15:18,470
that's 64 bits it's not only good for

00:15:15,820 --> 00:15:20,830
library compatibility but also it comes

00:15:18,470 --> 00:15:23,720
with two years of optimizations and

00:15:20,830 --> 00:15:25,370
performance tweaks it's one of the

00:15:23,720 --> 00:15:26,960
easiest things that that you can

00:15:25,370 --> 00:15:31,010
actually do to improve your reg native

00:15:26,960 --> 00:15:33,020
performance oh this one is really cool

00:15:31,010 --> 00:15:35,260
but legal department didn't allow me to

00:15:33,020 --> 00:15:38,540
mention anything about it

00:15:35,260 --> 00:15:43,880
just imagine unicorns exploding with

00:15:38,540 --> 00:15:45,980
jelly beans moving on now let's talk

00:15:43,880 --> 00:15:49,190
about what we can do to the JavaScript

00:15:45,980 --> 00:15:53,390
bundle by default all react native

00:15:49,190 --> 00:15:55,820
surfaces in our application are compiled

00:15:53,390 --> 00:15:58,570
in one JavaScript file this is a very

00:15:55,820 --> 00:16:02,240
common technique anyone using webpack

00:15:58,570 --> 00:16:04,670
pretty much everyone so it compiles all

00:16:02,240 --> 00:16:07,400
the JavaScript in one javascript file it

00:16:04,670 --> 00:16:10,280
gets zipped and sent over the network to

00:16:07,400 --> 00:16:11,780
the device with react native it's a

00:16:10,280 --> 00:16:14,510
little bit different we want to optimize

00:16:11,780 --> 00:16:16,610
it differently the problem is that this

00:16:14,510 --> 00:16:18,800
JavaScript on react native is actually

00:16:16,610 --> 00:16:22,160
part of the application

00:16:18,800 --> 00:16:25,250
and if we want to load any react native

00:16:22,160 --> 00:16:28,010
screen we need to read this file and if

00:16:25,250 --> 00:16:30,740
it's large like sex may six megabytes or

00:16:28,010 --> 00:16:35,600
maybe 20 megabytes it's quite heavy for

00:16:30,740 --> 00:16:37,279
IO it will take time to load so ideally

00:16:35,600 --> 00:16:40,540
we want to split it into two like

00:16:37,279 --> 00:16:43,040
webpack can do you can have a very small

00:16:40,540 --> 00:16:45,260
javascript bundle for the your initial

00:16:43,040 --> 00:16:48,020
screen and then you can load other

00:16:45,260 --> 00:16:51,290
things later for example unclick or

00:16:48,020 --> 00:16:52,790
maybe it's a different surface now the

00:16:51,290 --> 00:16:54,680
trick is that actually for react native

00:16:52,790 --> 00:16:56,839
we don't need to do that there is a

00:16:54,680 --> 00:17:01,700
feature called Ram bundles it's a fancy

00:16:56,839 --> 00:17:03,410
name means random access memory but what

00:17:01,700 --> 00:17:05,990
it actually does it compels every

00:17:03,410 --> 00:17:10,309
JavaScript module is its own file and

00:17:05,990 --> 00:17:12,140
puts it in the application so we when

00:17:10,309 --> 00:17:14,660
you start up your application you only

00:17:12,140 --> 00:17:18,620
read the modules that are required in

00:17:14,660 --> 00:17:20,809
your initial startup path and it means

00:17:18,620 --> 00:17:24,550
that you only pay I owe only for the

00:17:20,809 --> 00:17:29,480
modules that you need now talking about

00:17:24,550 --> 00:17:33,470
requires and imports let's imagine we

00:17:29,480 --> 00:17:37,280
have a very heavy component like I even

00:17:33,470 --> 00:17:38,870
called it very expensive and let's say

00:17:37,280 --> 00:17:41,240
it does something nasty not just this

00:17:38,870 --> 00:17:42,830
console log that indicates that's

00:17:41,240 --> 00:17:46,160
something I still like it it mines a

00:17:42,830 --> 00:17:47,900
Bitcoin for you now you want to use this

00:17:46,160 --> 00:17:49,970
component but you know that it mines a

00:17:47,900 --> 00:17:52,730
bit going so it's very slow so what you

00:17:49,970 --> 00:17:54,260
do when you use it on line 20 you say

00:17:52,730 --> 00:17:57,679
hey don't load this very expensive

00:17:54,260 --> 00:18:00,230
component before I make a click there's

00:17:57,679 --> 00:18:01,940
a conditional for the state but you

00:18:00,230 --> 00:18:04,490
didn't know that import is actually

00:18:01,940 --> 00:18:07,700
eagerly loading and it means when we

00:18:04,490 --> 00:18:09,380
have on line 3 import very expensive

00:18:07,700 --> 00:18:13,730
component you actually get a bit Co in

00:18:09,380 --> 00:18:16,640
mind we don't want global code executed

00:18:13,730 --> 00:18:19,370
during our startup time so what we can

00:18:16,640 --> 00:18:23,300
do is change the import into the old

00:18:19,370 --> 00:18:26,450
common GS require that allows you to

00:18:23,300 --> 00:18:29,390
import files within the functions so we

00:18:26,450 --> 00:18:32,600
define a new variable called lead very

00:18:29,390 --> 00:18:35,810
expensive it's undefined by default

00:18:32,600 --> 00:18:38,480
and then on the key press we say require

00:18:35,810 --> 00:18:41,540
this module and then it becomes

00:18:38,480 --> 00:18:44,090
available as a as something to render

00:18:41,540 --> 00:18:47,600
now obviously you don't want to do it

00:18:44,090 --> 00:18:49,580
for everything in your application so

00:18:47,600 --> 00:18:52,490
thankfully react native packager that's

00:18:49,580 --> 00:18:54,620
called Metro bundler has this setting

00:18:52,490 --> 00:18:57,920
that automatically translates all your

00:18:54,620 --> 00:19:01,070
imports into these require statements so

00:18:57,920 --> 00:19:02,830
you can write idiomatic JavaScript but

00:19:01,070 --> 00:19:05,270
it's smart enough to find that

00:19:02,830 --> 00:19:07,220
components are not used during the

00:19:05,270 --> 00:19:09,680
startup it converts them into require

00:19:07,220 --> 00:19:18,860
statements and you don't pay the extra

00:19:09,680 --> 00:19:21,680
thing so we talked about what things you

00:19:18,860 --> 00:19:24,470
can do with your configurations and then

00:19:21,680 --> 00:19:27,170
other people built parts of your

00:19:24,470 --> 00:19:29,630
application build frameworks for you and

00:19:27,170 --> 00:19:33,140
you can just tweak some knobs and get it

00:19:29,630 --> 00:19:38,300
work faster now let's talk about what

00:19:33,140 --> 00:19:40,340
you can do to your production code so

00:19:38,300 --> 00:19:42,650
you can find a lot of information on the

00:19:40,340 --> 00:19:46,100
web about optimizing react components

00:19:42,650 --> 00:19:48,380
the gist of it is we don't want to call

00:19:46,100 --> 00:19:51,080
render function multiple times for your

00:19:48,380 --> 00:19:52,670
component and react is very generous

00:19:51,080 --> 00:19:56,390
about cold in render because it's

00:19:52,670 --> 00:20:00,070
supposed to be fast however if it's

00:19:56,390 --> 00:20:04,130
critical for you to don't call extra

00:20:00,070 --> 00:20:09,440
extra extra times the component then you

00:20:04,130 --> 00:20:13,090
you can do some tricks so here is a

00:20:09,440 --> 00:20:13,090
common way of how we can avoid it

00:20:13,240 --> 00:20:19,760
this component implemented should

00:20:15,740 --> 00:20:22,370
component update function the idea is if

00:20:19,760 --> 00:20:24,560
it returns true then the render function

00:20:22,370 --> 00:20:26,930
will be called and if it returns false

00:20:24,560 --> 00:20:30,590
react will trust you that this component

00:20:26,930 --> 00:20:32,870
shouldn't be rendered in this case we

00:20:30,590 --> 00:20:35,570
look at the property color and we say

00:20:32,870 --> 00:20:39,980
only update this component only rerender

00:20:35,570 --> 00:20:42,980
this component when color changes this

00:20:39,980 --> 00:20:45,860
this concept is very popular so there is

00:20:42,980 --> 00:20:46,460
a pure component in react what it does

00:20:45,860 --> 00:20:48,200
it

00:20:46,460 --> 00:20:51,260
matically implements should component

00:20:48,200 --> 00:20:57,980
update for you and only calls rerender

00:20:51,260 --> 00:21:01,370
when a prop changes and I'd like to

00:20:57,980 --> 00:21:04,010
finish my talk on a point that focusing

00:21:01,370 --> 00:21:07,300
on perception can give you more results

00:21:04,010 --> 00:21:09,050
than actually grinding the components

00:21:07,300 --> 00:21:13,040
here is what I mean

00:21:09,050 --> 00:21:15,980
by default react built a component tree

00:21:13,040 --> 00:21:18,890
depth first so we have some top

00:21:15,980 --> 00:21:21,200
component and it goes down down down to

00:21:18,890 --> 00:21:24,110
the most inner component in it

00:21:21,200 --> 00:21:26,330
then goes up up up by the stack then

00:21:24,110 --> 00:21:30,980
goes again and it kind of builds the

00:21:26,330 --> 00:21:33,500
whole tree now react fiber is coming to

00:21:30,980 --> 00:21:35,630
react native soon but for now we don't

00:21:33,500 --> 00:21:39,020
have this way to prioritize things how

00:21:35,630 --> 00:21:41,990
to load them so for example in

00:21:39,020 --> 00:21:46,040
marketplace we can decide that hey user

00:21:41,990 --> 00:21:48,800
content is more important than a fancy

00:21:46,040 --> 00:21:50,960
navigation at the top and we could save

00:21:48,800 --> 00:21:54,200
50 milliseconds by just delaying the

00:21:50,960 --> 00:21:56,390
navigation the header and show the

00:21:54,200 --> 00:21:59,780
components the user content that people

00:21:56,390 --> 00:22:02,630
could engage with here is how you can do

00:21:59,780 --> 00:22:02,960
it with react native so you can define

00:22:02,630 --> 00:22:05,090
that

00:22:02,960 --> 00:22:07,370
alright this header is very expensive I

00:22:05,090 --> 00:22:13,100
don't want to have to render it from the

00:22:07,370 --> 00:22:15,500
first go but how do I know that it got

00:22:13,100 --> 00:22:18,020
rendered at all because components are

00:22:15,500 --> 00:22:21,020
built in JavaScript and code is rendered

00:22:18,020 --> 00:22:22,790
in the native that and there is some

00:22:21,020 --> 00:22:24,650
communication between those threads but

00:22:22,790 --> 00:22:27,320
they are completely independent you

00:22:24,650 --> 00:22:29,330
cannot just say wait 400 milliseconds

00:22:27,320 --> 00:22:31,070
and then render the header because a

00:22:29,330 --> 00:22:33,770
hundred milliseconds on a slow device

00:22:31,070 --> 00:22:36,260
may pass and you start rendering the

00:22:33,770 --> 00:22:39,170
header before anything rendered on the

00:22:36,260 --> 00:22:41,480
screen so you slow it down but we have a

00:22:39,170 --> 00:22:45,380
trick for example I created a little

00:22:41,480 --> 00:22:48,020
view component on line 23 and it has an

00:22:45,380 --> 00:22:51,560
own layout callback this view is

00:22:48,020 --> 00:22:54,800
actually invisible but react native

00:22:51,560 --> 00:22:57,080
still renders it when we have this view

00:22:54,800 --> 00:22:59,030
rendered we know that hey something this

00:22:57,080 --> 00:22:59,970
component already was rendered by the

00:22:59,030 --> 00:23:02,460
native code

00:22:59,970 --> 00:23:05,610
so we can do things that we wanted to

00:23:02,460 --> 00:23:08,519
delay so it has the only out callback

00:23:05,610 --> 00:23:10,470
that goes to line seven and that's when

00:23:08,519 --> 00:23:15,360
we change the state of the component and

00:23:10,470 --> 00:23:17,899
say hey I render other things now as a

00:23:15,360 --> 00:23:20,340
matter of fact in marketplace this was

00:23:17,899 --> 00:23:23,279
one of the most common things that we

00:23:20,340 --> 00:23:26,309
have been doing reg native application

00:23:23,279 --> 00:23:28,919
is just one large component that goes

00:23:26,309 --> 00:23:30,809
into more smaller components and in

00:23:28,919 --> 00:23:33,509
marketplace we were saying alright this

00:23:30,809 --> 00:23:36,450
looks like a heavy component let's delay

00:23:33,509 --> 00:23:39,360
it the problem is that we have a large

00:23:36,450 --> 00:23:41,789
team and a lot of features so these

00:23:39,360 --> 00:23:43,379
components started piling up and of

00:23:41,789 --> 00:23:45,840
course we started delaying them but

00:23:43,379 --> 00:23:49,049
there are a lot of layers a lot of

00:23:45,840 --> 00:23:52,470
things that javascript has still to go

00:23:49,049 --> 00:23:54,899
through and when we measure when we

00:23:52,470 --> 00:23:58,559
measure this this just didn't sit with

00:23:54,899 --> 00:24:02,000
me right right we spent 500 milliseconds

00:23:58,559 --> 00:24:04,350
on a slow device to render this screen

00:24:02,000 --> 00:24:06,090
because we have flat list we have many

00:24:04,350 --> 00:24:08,370
things we still delay them but we can

00:24:06,090 --> 00:24:13,080
delay everything because the code will

00:24:08,370 --> 00:24:15,179
be really hard to read but really I can

00:24:13,080 --> 00:24:17,970
implement this thing from scratch and it

00:24:15,179 --> 00:24:21,090
would run under 200 milliseconds because

00:24:17,970 --> 00:24:25,590
it's just four images I can just do a

00:24:21,090 --> 00:24:28,379
view and put images in there so we

00:24:25,590 --> 00:24:31,289
thought about it and we implemented this

00:24:28,379 --> 00:24:36,090
we decided to do a little trick so we

00:24:31,289 --> 00:24:39,809
implement the light one and then destroy

00:24:36,090 --> 00:24:41,940
it and render the full view with all the

00:24:39,809 --> 00:24:43,529
flag stars and craft and of course this

00:24:41,940 --> 00:24:46,230
is not shippable this is a terrible

00:24:43,529 --> 00:24:48,539
experience because it blinks but not

00:24:46,230 --> 00:24:52,200
everyone knows that react native has a

00:24:48,539 --> 00:24:55,350
very good animation library that allows

00:24:52,200 --> 00:24:58,740
you to run an animation when a component

00:24:55,350 --> 00:25:01,409
is destroyed so for a couple of weeks we

00:24:58,740 --> 00:25:04,350
tested a few ideas and this is what we

00:25:01,409 --> 00:25:07,350
settle to it we render the light view

00:25:04,350 --> 00:25:10,110
with the runs within 200 milliseconds in

00:25:07,350 --> 00:25:12,059
the background we build the full view

00:25:10,110 --> 00:25:12,650
with all the crafts that takes 500

00:25:12,059 --> 00:25:15,830
millisecond

00:25:12,650 --> 00:25:18,620
then we destroy the light one and we

00:25:15,830 --> 00:25:20,150
animate in with a fade out into the

00:25:18,620 --> 00:25:24,800
thing that's already in the background

00:25:20,150 --> 00:25:27,200
this way we have quite indistinguishable

00:25:24,800 --> 00:25:29,090
change but at the same time the light

00:25:27,200 --> 00:25:32,170
view is already clickable and people can

00:25:29,090 --> 00:25:35,390
engage with the application much sooner

00:25:32,170 --> 00:25:36,050
so lets me summarize what I talked about

00:25:35,390 --> 00:25:37,880
today

00:25:36,050 --> 00:25:41,420
Market Place is on a great trajectory

00:25:37,880 --> 00:25:44,150
and keeps growing react native is one of

00:25:41,420 --> 00:25:47,480
the tools to satisfy the product growth

00:25:44,150 --> 00:25:49,250
needs and we can use our experience from

00:25:47,480 --> 00:25:51,950
the web from optimizing all those

00:25:49,250 --> 00:25:54,920
websites for many years and apply it to

00:25:51,950 --> 00:25:59,710
react native and in general mobile J's

00:25:54,920 --> 00:25:59,710
on mobile that's all

00:26:04,090 --> 00:26:06,150

YouTube URL: https://www.youtube.com/watch?v=g3jwd0kAIDU


