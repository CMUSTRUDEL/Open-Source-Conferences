Title: New Adventures for WASM - Lin Clark and Till Schneidereit | JSConf Hawaii 2019
Publication date: 2019-06-16
Playlist: JSConf HI 2019
Description: 
	Lin Clark and Till Schneidereit provide an update on the current features and future direction of WebAssembly as it moves past the MVP phase.

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:05,610 --> 00:00:11,879
thank you for that great introduction I

00:00:08,340 --> 00:00:15,000
am Lynn Clark and I make code cartoons

00:00:11,879 --> 00:00:16,139
and I also work at Mozilla on things

00:00:15,000 --> 00:00:18,119
like web assembly which as well I'll be

00:00:16,139 --> 00:00:19,800
talking about today and I'm joined by

00:00:18,119 --> 00:00:21,390
till Schneider right who leads our web

00:00:19,800 --> 00:00:24,060
assembly tooling efforts and he'll be

00:00:21,390 --> 00:00:27,720
filling us in on some of their work so

00:00:24,060 --> 00:00:29,640
first off what is web assembly what

00:00:27,720 --> 00:00:31,439
assembly is a way of running programming

00:00:29,640 --> 00:00:32,010
languages other than JavaScript on the

00:00:31,439 --> 00:00:34,730
web

00:00:32,010 --> 00:00:36,900
up until now to run code on a web page

00:00:34,730 --> 00:00:38,970
the only language you could use was

00:00:36,900 --> 00:00:40,440
JavaScript but now that there's web

00:00:38,970 --> 00:00:44,580
assembly you can use other languages

00:00:40,440 --> 00:00:46,379
like C or C++ or rust I've noticed that

00:00:44,580 --> 00:00:48,629
some people have a misconception about

00:00:46,379 --> 00:00:51,839
web assembly though people think that

00:00:48,629 --> 00:00:54,269
the MVP that landed in browsers and 2017

00:00:51,839 --> 00:00:55,290
is the final version of web assembly and

00:00:54,269 --> 00:00:57,570
I can understand where that

00:00:55,290 --> 00:00:59,430
misconception comes from because the web

00:00:57,570 --> 00:01:01,110
assembly CG is really committed to

00:00:59,430 --> 00:01:02,790
backwards compatibility so the web

00:01:01,110 --> 00:01:05,640
assembly that you write today will

00:01:02,790 --> 00:01:06,990
continue to work far into the future but

00:01:05,640 --> 00:01:08,970
that doesn't mean that its feature

00:01:06,990 --> 00:01:11,520
complete and that's far from the case in

00:01:08,970 --> 00:01:13,200
fact features are coming to web assembly

00:01:11,520 --> 00:01:16,860
which will fundamentally alter what you

00:01:13,200 --> 00:01:18,630
can do with web assembly I think of

00:01:16,860 --> 00:01:21,330
these future features kind of like the

00:01:18,630 --> 00:01:23,490
skill tree in a video game we've fully

00:01:21,330 --> 00:01:25,260
filled in the top few of these skills

00:01:23,490 --> 00:01:27,780
but there's still this whole skill tree

00:01:25,260 --> 00:01:28,950
underneath to unlock so that we can

00:01:27,780 --> 00:01:31,710
unlock all of these different

00:01:28,950 --> 00:01:33,120
applications so let's look at what's

00:01:31,710 --> 00:01:35,900
been filled in already and then we can

00:01:33,120 --> 00:01:35,900
see what's yet to come

00:01:36,830 --> 00:01:41,730
webassembly story starts with unscripted

00:01:39,360 --> 00:01:43,770
which made it possible to bring large C

00:01:41,730 --> 00:01:45,870
and C++ code bases to the web for things

00:01:43,770 --> 00:01:48,090
like desktop applications and games and

00:01:45,870 --> 00:01:51,300
it did this by transpiling that code to

00:01:48,090 --> 00:01:53,370
JavaScript and at first that JavaScript

00:01:51,300 --> 00:01:55,170
would run pretty slow but then the

00:01:53,370 --> 00:01:57,690
Firefox engineer saw how you could add

00:01:55,170 --> 00:02:00,390
optimizations to the j/s engine to make

00:01:57,690 --> 00:02:03,390
it run fast and that gave us has enjoy

00:02:00,390 --> 00:02:05,310
us once the other browser vendors saw

00:02:03,390 --> 00:02:06,930
how fast as andreas was they started

00:02:05,310 --> 00:02:09,810
adding the same optimizations to their

00:02:06,930 --> 00:02:10,979
at engines as well but that wasn't the

00:02:09,810 --> 00:02:11,750
end of the story it was just the

00:02:10,979 --> 00:02:14,060
beginning

00:02:11,750 --> 00:02:16,050
engines could still make this go faster

00:02:14,060 --> 00:02:18,510
but they couldn't do it in JavaScript

00:02:16,050 --> 00:02:19,180
itself instead they needed a new

00:02:18,510 --> 00:02:20,739
language

00:02:19,180 --> 00:02:24,030
one that was designed specifically to be

00:02:20,739 --> 00:02:26,590
compiled - and that was webassembly

00:02:24,030 --> 00:02:28,719
so what word the skills needed for this

00:02:26,590 --> 00:02:31,930
MVP this Minimum Viable Product running

00:02:28,719 --> 00:02:33,280
c and c++ on the web web assemblies

00:02:31,930 --> 00:02:34,569
designers knew that eventually they

00:02:33,280 --> 00:02:36,819
would want to support languages other

00:02:34,569 --> 00:02:38,760
than just C and C++ so they needed a

00:02:36,819 --> 00:02:40,870
language agnostic compile target

00:02:38,760 --> 00:02:42,549
something like the assembly language

00:02:40,870 --> 00:02:45,549
that things like desktop applications

00:02:42,549 --> 00:02:47,379
are compiled to like x86 but this

00:02:45,549 --> 00:02:49,239
assembly language wouldn't be for an

00:02:47,379 --> 00:02:52,269
actual physical machine it would be for

00:02:49,239 --> 00:02:54,129
a conceptual machine that compiler

00:02:52,269 --> 00:02:55,659
target had to run very fast to meet

00:02:54,129 --> 00:02:57,819
users expectations for smooth

00:02:55,659 --> 00:02:59,620
interactions and gameplay and it also

00:02:57,819 --> 00:03:02,040
needed to load fast because the web's

00:02:59,620 --> 00:03:04,209
users are used to pretty fast load times

00:03:02,040 --> 00:03:06,519
but these kinds of applications are very

00:03:04,209 --> 00:03:07,870
large code bases which means that

00:03:06,519 --> 00:03:10,810
there's a lot to download when you first

00:03:07,870 --> 00:03:12,400
visit the URL so we needed our compiler

00:03:10,810 --> 00:03:15,129
target to be compact so it could go over

00:03:12,400 --> 00:03:17,169
the internet quickly these languages

00:03:15,129 --> 00:03:19,180
also needed to manage memory differently

00:03:17,169 --> 00:03:21,310
from JavaScript they need to be able to

00:03:19,180 --> 00:03:23,319
directly manage their memory and this is

00:03:21,310 --> 00:03:24,849
because languages like C and C++ have a

00:03:23,319 --> 00:03:27,129
low-level language feature called

00:03:24,849 --> 00:03:29,560
pointers the in pointers need to be able

00:03:27,129 --> 00:03:31,319
to take a memory address and read and

00:03:29,560 --> 00:03:33,639
write directly from that memory address

00:03:31,319 --> 00:03:35,799
but you can't have a program that you

00:03:33,639 --> 00:03:38,260
downloaded from the web just accessing

00:03:35,799 --> 00:03:39,849
your memory willy-nilly in order to

00:03:38,260 --> 00:03:41,530
provide a way to access memory like a

00:03:39,849 --> 00:03:43,720
native program is used to but to keep

00:03:41,530 --> 00:03:45,159
the browser secure we had to create

00:03:43,720 --> 00:03:47,349
something that could give access to a

00:03:45,159 --> 00:03:50,379
very specific part of memory and nothing

00:03:47,349 --> 00:03:52,930
else to do this web assembly uses a

00:03:50,379 --> 00:03:55,120
linear memory model and that's

00:03:52,930 --> 00:03:57,040
implemented using typed arrays which are

00:03:55,120 --> 00:03:59,379
basically just JavaScript arrays except

00:03:57,040 --> 00:04:01,840
the the items that are in this array are

00:03:59,379 --> 00:04:03,579
bytes bytes of memory so when you're

00:04:01,840 --> 00:04:05,709
accessing it you're just using array

00:04:03,579 --> 00:04:07,239
indexes which you can treat as though

00:04:05,709 --> 00:04:08,409
they were memory addresses and this

00:04:07,239 --> 00:04:12,639
means that you can pretend that this

00:04:08,409 --> 00:04:14,379
array is C++ memory so with all of those

00:04:12,639 --> 00:04:16,030
things in place you could run desktop

00:04:14,379 --> 00:04:18,009
applications and games in your browser

00:04:16,030 --> 00:04:20,799
as if they were running natively on your

00:04:18,009 --> 00:04:22,659
computer and that was pretty much the

00:04:20,799 --> 00:04:26,110
skill set the web assembly had one was

00:04:22,659 --> 00:04:27,690
released as an MVP it truly was an MVP a

00:04:26,110 --> 00:04:29,710
Minimum Viable Product

00:04:27,690 --> 00:04:31,180
this allowed certain kinds of

00:04:29,710 --> 00:04:31,660
applications to work but there was still

00:04:31,180 --> 00:04:33,310
a whole

00:04:31,660 --> 00:04:36,640
host of other applications that needed

00:04:33,310 --> 00:04:38,440
to be unlocked so the next achievement

00:04:36,640 --> 00:04:41,650
to unlock is heavier-weight desktop

00:04:38,440 --> 00:04:43,240
applications can you imagine if

00:04:41,650 --> 00:04:44,830
something like Photoshop was running in

00:04:43,240 --> 00:04:46,420
your browser if you could load it on any

00:04:44,830 --> 00:04:49,060
of your devices and start working with

00:04:46,420 --> 00:04:50,850
your files like you can with Gmail we've

00:04:49,060 --> 00:04:53,590
already started seeing things like this

00:04:50,850 --> 00:04:55,060
for example the AutoCAD team has made

00:04:53,590 --> 00:04:56,950
their CAD software available through the

00:04:55,060 --> 00:04:58,360
browser and adobe has made Lightroom

00:04:56,950 --> 00:05:00,910
available through the browser using web

00:04:58,360 --> 00:05:02,680
assembly but there are still a few

00:05:00,910 --> 00:05:04,120
features that we need to make sure all

00:05:02,680 --> 00:05:06,670
of these applications even the heaviest

00:05:04,120 --> 00:05:09,430
of heavy weight applications work well

00:05:06,670 --> 00:05:12,340
in the browser first as support for

00:05:09,430 --> 00:05:14,050
multi-threading modern-day computers

00:05:12,340 --> 00:05:16,420
have multiple cores that can process

00:05:14,050 --> 00:05:18,010
things in parallel but to make use of

00:05:16,420 --> 00:05:20,980
these cores you need support for

00:05:18,010 --> 00:05:22,480
threading there's another bit of modern

00:05:20,980 --> 00:05:24,910
hardware that processes things in

00:05:22,480 --> 00:05:27,970
parallel and that sim date single

00:05:24,910 --> 00:05:29,560
instruction multiple data what cindy is

00:05:27,970 --> 00:05:31,600
possible to take a chunk of memory and

00:05:29,560 --> 00:05:33,700
split it up across different execution

00:05:31,600 --> 00:05:35,080
units which are basically like cores and

00:05:33,700 --> 00:05:37,090
then you have the same bit of code the

00:05:35,080 --> 00:05:39,100
same instruction run across all of those

00:05:37,090 --> 00:05:40,500
execution units but on different parts

00:05:39,100 --> 00:05:43,210
of the data

00:05:40,500 --> 00:05:45,760
another hardware capability is 64-bit

00:05:43,210 --> 00:05:47,770
addressing memory addresses are just

00:05:45,760 --> 00:05:49,540
numbers so if your memory addresses are

00:05:47,770 --> 00:05:51,370
only 32 bits long you only have so many

00:05:49,540 --> 00:05:54,880
memory of Justis enough for gigabytes

00:05:51,370 --> 00:05:57,250
but most modern hardware supports 64-bit

00:05:54,880 --> 00:06:00,690
addressing which offers 16 exabytes of

00:05:57,250 --> 00:06:03,040
memory addresses that's a big difference

00:06:00,690 --> 00:06:04,960
adding 64-bit support will take the

00:06:03,040 --> 00:06:07,200
artificial limitation on memory address

00:06:04,960 --> 00:06:09,460
space out of webassembly

00:06:07,200 --> 00:06:12,100
but these applications don't just need

00:06:09,460 --> 00:06:15,190
to run fast load times need to be fast

00:06:12,100 --> 00:06:16,780
too one mix-up here is to do something

00:06:15,190 --> 00:06:18,130
called streaming compilation where you

00:06:16,780 --> 00:06:20,710
compile the file as it's being

00:06:18,130 --> 00:06:26,110
downloaded and web assembly was designed

00:06:20,710 --> 00:06:27,940
to enable this tiered compiler also

00:06:26,110 --> 00:06:29,740
helps so in Firefox we have two

00:06:27,940 --> 00:06:32,080
compilers the first one the baseline

00:06:29,740 --> 00:06:35,470
compiler starts when the download starts

00:06:32,080 --> 00:06:37,330
for the first time then another compiler

00:06:35,470 --> 00:06:39,280
the optimizing compiler runs on several

00:06:37,330 --> 00:06:41,440
threads in the background and that one

00:06:39,280 --> 00:06:43,690
takes longer to compile but the code

00:06:41,440 --> 00:06:46,210
that it generates is extremely fast

00:06:43,690 --> 00:06:47,800
we're also working on a new optimizing

00:06:46,210 --> 00:06:49,330
compiler called crane lift and crane

00:06:47,800 --> 00:06:51,670
lift is designed to actually speed up

00:06:49,330 --> 00:06:53,410
that initial compile time so it can

00:06:51,670 --> 00:06:55,540
compile a code in parallel at a function

00:06:53,410 --> 00:06:57,160
by function level but the code it

00:06:55,540 --> 00:06:58,900
generates is still fast and we're

00:06:57,160 --> 00:07:01,270
currently working to see if we can make

00:06:58,900 --> 00:07:02,650
it generate code that's even faster and

00:07:01,270 --> 00:07:05,800
when it's executing then our current

00:07:02,650 --> 00:07:07,150
optimizing compiler but there's an even

00:07:05,800 --> 00:07:09,970
better trick we can use to skip

00:07:07,150 --> 00:07:12,100
compiling most of the time unlike with

00:07:09,970 --> 00:07:13,930
JavaScript if you load the same web

00:07:12,100 --> 00:07:16,420
assembly file twice it compiles to the

00:07:13,930 --> 00:07:19,420
same machine code so we can store that

00:07:16,420 --> 00:07:20,710
compiled code in the HTTP cache and then

00:07:19,420 --> 00:07:22,540
when the page is loading and it goes to

00:07:20,710 --> 00:07:24,310
check the cache instead of pulling out

00:07:22,540 --> 00:07:26,710
that source code it pulls out the

00:07:24,310 --> 00:07:29,710
compiled code so this skips compiling

00:07:26,710 --> 00:07:31,510
completely and there are ways to skip

00:07:29,710 --> 00:07:34,930
even more work so stay tuned to see what

00:07:31,510 --> 00:07:36,490
else happens to improve load times where

00:07:34,930 --> 00:07:39,640
are we with supporting these heavyweight

00:07:36,490 --> 00:07:41,080
applications right now for the threading

00:07:39,640 --> 00:07:42,820
we have a proposal that's pretty much

00:07:41,080 --> 00:07:44,530
done but a key piece of that shared RAID

00:07:42,820 --> 00:07:47,050
buffers had to be turned off in browsers

00:07:44,530 --> 00:07:48,880
earlier this season last year they will

00:07:47,050 --> 00:07:52,210
be turned again turned on again soon

00:07:48,880 --> 00:07:55,150
though cindy is under active development

00:07:52,210 --> 00:07:56,680
at the moment for 164 we have a good

00:07:55,150 --> 00:07:58,720
picture of how this is going to work and

00:07:56,680 --> 00:08:01,680
that's pretty similar to how x86 or arm

00:07:58,720 --> 00:08:04,180
got support for 64-bit addressing and

00:08:01,680 --> 00:08:06,490
Firefox added streaming compilation last

00:08:04,180 --> 00:08:07,900
year in Firefox we actually compile the

00:08:06,490 --> 00:08:09,190
code so fast that's basically done

00:08:07,900 --> 00:08:12,250
compiling by the time you've downloaded

00:08:09,190 --> 00:08:14,830
the file and other browsers are adding

00:08:12,250 --> 00:08:16,240
streaming too and we also added our

00:08:14,830 --> 00:08:17,710
baseline compiler last year and other

00:08:16,240 --> 00:08:21,130
browsers have been adding the same kind

00:08:17,710 --> 00:08:23,200
of architecture in Firefox HTTP caching

00:08:21,130 --> 00:08:25,810
is close and it is in closing Chrome as

00:08:23,200 --> 00:08:28,840
well and other improvements are in

00:08:25,810 --> 00:08:31,030
discussion even though this is all still

00:08:28,840 --> 00:08:33,760
in progress heavyweight applications are

00:08:31,030 --> 00:08:34,990
still coming out today because

00:08:33,760 --> 00:08:36,370
webassembly already gives these

00:08:34,990 --> 00:08:39,520
applications the performance that they

00:08:36,370 --> 00:08:41,260
need but once these features are all in

00:08:39,520 --> 00:08:43,479
place there's going to be another

00:08:41,260 --> 00:08:45,010
achievement unlocked and more of these

00:08:43,479 --> 00:08:47,830
heavyweight applications are going to be

00:08:45,010 --> 00:08:49,180
able to come to the browser but web

00:08:47,830 --> 00:08:51,190
assembly isn't just for desktop

00:08:49,180 --> 00:08:53,170
applications it's also meant for regular

00:08:51,190 --> 00:08:54,490
small modules developed web development

00:08:53,170 --> 00:08:56,570
the kind of web development that you're

00:08:54,490 --> 00:08:58,070
used to

00:08:56,570 --> 00:09:00,080
if you have a module that does a lot of

00:08:58,070 --> 00:09:02,240
heavy computation or processing that's a

00:09:00,080 --> 00:09:03,770
good use case for web assembly and again

00:09:02,240 --> 00:09:06,650
we're already seeing some of this

00:09:03,770 --> 00:09:08,390
so the parser in the source Maps library

00:09:06,650 --> 00:09:10,460
that's used in web pack and Firefox dev

00:09:08,390 --> 00:09:11,840
tools that was rewritten in Russ

00:09:10,460 --> 00:09:14,510
compiled to web assembling there's now

00:09:11,840 --> 00:09:16,550
11 times faster and the Gutenberg parser

00:09:14,510 --> 00:09:19,370
and WordPress is now an average of 86

00:09:16,550 --> 00:09:22,280
times faster with its rewrite and rust

00:09:19,370 --> 00:09:24,620
compiled to web assembly but for this to

00:09:22,280 --> 00:09:28,190
go mainstream we need to have a few more

00:09:24,620 --> 00:09:29,750
things in place first calls between

00:09:28,190 --> 00:09:32,300
javascript and web assembly need to be

00:09:29,750 --> 00:09:34,520
fast when web assembly first came out

00:09:32,300 --> 00:09:37,490
these calls weren't fast because engines

00:09:34,520 --> 00:09:39,530
needed to optimize them we finished our

00:09:37,490 --> 00:09:41,570
working on this in Firefox last summer

00:09:39,530 --> 00:09:43,700
and now some of these calls are actually

00:09:41,570 --> 00:09:46,730
faster than non inline JavaScript to

00:09:43,700 --> 00:09:48,560
JavaScript calls that brings us to

00:09:46,730 --> 00:09:50,450
another thing though you often need to

00:09:48,560 --> 00:09:52,490
pass data between your JavaScript and

00:09:50,450 --> 00:09:54,530
web assembly functions you need to pass

00:09:52,490 --> 00:09:57,410
arguments into your web simulator or

00:09:54,530 --> 00:09:59,090
return values from it at the moment web

00:09:57,410 --> 00:10:01,640
assembly only web assembly only

00:09:59,090 --> 00:10:03,320
understands numbers so this means that

00:10:01,640 --> 00:10:05,570
you can't pass more complex things than

00:10:03,320 --> 00:10:07,430
like objects you need to convert your

00:10:05,570 --> 00:10:08,960
object into numbers put it in a linear

00:10:07,430 --> 00:10:10,760
memory and then pull it back out on the

00:10:08,960 --> 00:10:14,030
web assembly side and figure out what it

00:10:10,760 --> 00:10:15,890
is that's kind of complicated and it

00:10:14,030 --> 00:10:18,350
takes some time to convert the data into

00:10:15,890 --> 00:10:21,770
linear memory so we need this to be

00:10:18,350 --> 00:10:24,080
easier and faster we also need to

00:10:21,770 --> 00:10:26,450
integrate with es modules right now you

00:10:24,080 --> 00:10:28,670
can't use import and export with Wazza

00:10:26,450 --> 00:10:30,650
modules but that means that the web

00:10:28,670 --> 00:10:33,800
assembly module isn't really part of the

00:10:30,650 --> 00:10:35,360
J's module graph just being able to

00:10:33,800 --> 00:10:37,700
import and export doesn't get us all the

00:10:35,360 --> 00:10:39,410
way there though we also needed ways to

00:10:37,700 --> 00:10:42,530
distribute and bundle web assembly

00:10:39,410 --> 00:10:46,700
modules what's the MPM for web assembly

00:10:42,530 --> 00:10:49,670
well what about NPM what's the web pack

00:10:46,700 --> 00:10:52,340
or parcel for web assembly well what

00:10:49,670 --> 00:10:53,720
about web pack and parcel these modules

00:10:52,340 --> 00:10:55,190
shouldn't look any different to the

00:10:53,720 --> 00:10:57,760
people that are using them so why should

00:10:55,190 --> 00:11:00,740
we create a whole other ecosystem and

00:10:57,760 --> 00:11:02,690
there's one more thing support for older

00:11:00,740 --> 00:11:04,370
versions of browsers even those that

00:11:02,690 --> 00:11:07,490
don't know what web assembly is like ie

00:11:04,370 --> 00:11:08,140
11 so where are we on all of these

00:11:07,490 --> 00:11:10,550
things

00:11:08,140 --> 00:11:12,019
well calls between JavaScript and web

00:11:10,550 --> 00:11:15,170
we're fast and Firefox now and other

00:11:12,019 --> 00:11:16,790
browsers are also prioritizing this for

00:11:15,170 --> 00:11:18,080
easy and fast data exchange there are a

00:11:16,790 --> 00:11:20,089
few proposals that will help with this

00:11:18,080 --> 00:11:22,130
such as any rough post bindings and weak

00:11:20,089 --> 00:11:24,470
refs and I unfortunately don't have time

00:11:22,130 --> 00:11:26,089
to go into the detail on that but in the

00:11:24,470 --> 00:11:28,010
meantime the rust ecosystem has created

00:11:26,089 --> 00:11:31,339
tools that automate the handling of this

00:11:28,010 --> 00:11:32,950
stuff for you for es module integration

00:11:31,339 --> 00:11:35,149
the proposal is pretty far along for

00:11:32,950 --> 00:11:37,130
tool chain support tools in the rust

00:11:35,149 --> 00:11:39,140
ecosystem can package your code for NPM

00:11:37,130 --> 00:11:41,600
and the bundlers are also actively

00:11:39,140 --> 00:11:43,519
working on support and finally for

00:11:41,600 --> 00:11:46,130
backwards compatibility there's the wasm

00:11:43,519 --> 00:11:48,260
2j s tool that takes a wizened file and

00:11:46,130 --> 00:11:49,550
spits out the equivalent java script now

00:11:48,260 --> 00:11:51,440
that javascript isn't going to be fast

00:11:49,550 --> 00:11:52,850
but at least it will work in older

00:11:51,440 --> 00:11:56,180
versions of browsers that don't know

00:11:52,850 --> 00:11:57,829
what web assembly is once we unlock this

00:11:56,180 --> 00:12:00,529
achievement we open the path to another

00:11:57,829 --> 00:12:02,839
to rewriting large parts of JavaScript

00:12:00,529 --> 00:12:04,550
frameworks and web assembly and making

00:12:02,839 --> 00:12:06,440
it possible for statically typed compile

00:12:04,550 --> 00:12:08,540
to JavaScript languages to compile to

00:12:06,440 --> 00:12:12,170
web assembly instead languages like

00:12:08,540 --> 00:12:14,029
Scala jeaious or reason or elm for both

00:12:12,170 --> 00:12:16,760
of these use cases weba simply needs to

00:12:14,029 --> 00:12:18,500
support high-level language features so

00:12:16,760 --> 00:12:22,190
first let's look at rewriting parts of

00:12:18,500 --> 00:12:24,470
j/s frameworks for a framework like

00:12:22,190 --> 00:12:26,660
react you could paralyze the virtual Dom

00:12:24,470 --> 00:12:28,490
dipping algorithm with a language that

00:12:26,660 --> 00:12:31,459
has really economic support for

00:12:28,490 --> 00:12:33,230
parallelization like rust and you can

00:12:31,459 --> 00:12:35,140
also speed things up by reducing memory

00:12:33,230 --> 00:12:37,820
usage and allocating memory differently

00:12:35,140 --> 00:12:39,140
but you still need to interact with

00:12:37,820 --> 00:12:40,850
JavaScript objects things like

00:12:39,140 --> 00:12:42,950
components from that code

00:12:40,850 --> 00:12:44,930
you can't just rewrite everything in

00:12:42,950 --> 00:12:47,930
linear memory because that would be

00:12:44,930 --> 00:12:49,310
difficult and inefficient so you need to

00:12:47,930 --> 00:12:52,459
be able to integrate with the browsers

00:12:49,310 --> 00:12:54,350
built-in garbage collector and that will

00:12:52,459 --> 00:12:56,209
also help languages that compile to

00:12:54,350 --> 00:12:59,149
JavaScript like Scala GS reason and elm

00:12:56,209 --> 00:13:00,709
because these languages they already use

00:12:59,149 --> 00:13:02,959
Java scripts garbage collector when they

00:13:00,709 --> 00:13:04,699
compile to j s and that's the same GC

00:13:02,959 --> 00:13:07,010
that web assembly will be Rutt using

00:13:04,699 --> 00:13:10,190
when it's running in the browser so they

00:13:07,010 --> 00:13:11,390
won't need to change their GC we also

00:13:10,190 --> 00:13:13,490
need better support for handling

00:13:11,390 --> 00:13:16,310
exceptions and we need good debugging

00:13:13,490 --> 00:13:18,709
support browsers today make it easy to

00:13:16,310 --> 00:13:20,329
bug your your JavaScript using dev tools

00:13:18,709 --> 00:13:23,089
we need that same kind of support for

00:13:20,329 --> 00:13:23,850
web assembly and finally for many

00:13:23,089 --> 00:13:27,170
functional link

00:13:23,850 --> 00:13:31,740
justyou need a feature called tail calls

00:13:27,170 --> 00:13:33,930
so where are we on all of this for

00:13:31,740 --> 00:13:35,940
garbage collection our team already has

00:13:33,930 --> 00:13:37,199
a prototype of this working but it will

00:13:35,940 --> 00:13:39,060
still take some time for these proposals

00:13:37,199 --> 00:13:41,240
to go through standardization so we're

00:13:39,060 --> 00:13:43,019
probably looking at sometime next year

00:13:41,240 --> 00:13:45,269
exception handling is still in the

00:13:43,019 --> 00:13:46,949
research and development phase for

00:13:45,269 --> 00:13:48,959
debugging there's currently some support

00:13:46,949 --> 00:13:51,420
and browser dev tools but it's still not

00:13:48,959 --> 00:13:52,860
ideal so there's a subgroup of the web

00:13:51,420 --> 00:13:55,680
assembly CG that is working on

00:13:52,860 --> 00:13:59,190
specifying that and the tail calls

00:13:55,680 --> 00:14:00,930
proposal is also underway once those are

00:13:59,190 --> 00:14:02,759
all in place we'll have unlocked J's

00:14:00,930 --> 00:14:05,819
frameworks and many compiled to j/s

00:14:02,759 --> 00:14:07,920
languages so those are all achievements

00:14:05,819 --> 00:14:10,139
that we can can unlock inside of the

00:14:07,920 --> 00:14:13,230
browser but what about outside the

00:14:10,139 --> 00:14:16,050
browser now you may be confused when I

00:14:13,230 --> 00:14:17,790
talk about outside the browser because

00:14:16,050 --> 00:14:20,069
this is the browser what you use to view

00:14:17,790 --> 00:14:22,860
the web and isn't that right in the name

00:14:20,069 --> 00:14:25,079
web assembly but the truth is

00:14:22,860 --> 00:14:26,790
technologies like HTML and CSS and

00:14:25,079 --> 00:14:28,470
JavaScript are only part of what makes

00:14:26,790 --> 00:14:30,329
the web they're the visible part they're

00:14:28,470 --> 00:14:32,310
what she used to make user interfaces so

00:14:30,329 --> 00:14:33,870
they are the most obvious part but

00:14:32,310 --> 00:14:35,160
there's another really important part of

00:14:33,870 --> 00:14:39,529
the web which has properties which

00:14:35,160 --> 00:14:42,509
aren't as visible and this is the link

00:14:39,529 --> 00:14:44,160
the links innovation is that I can link

00:14:42,509 --> 00:14:46,110
to your page without having to put it in

00:14:44,160 --> 00:14:48,660
a central registry or ask you or even

00:14:46,110 --> 00:14:50,430
know who you are it's this ease of

00:14:48,660 --> 00:14:51,990
linking that enabled us to create these

00:14:50,430 --> 00:14:54,870
global communities with people that we

00:14:51,990 --> 00:14:56,279
don't know but there are two problems we

00:14:54,870 --> 00:14:58,829
haven't addressed if we just have this

00:14:56,279 --> 00:15:00,300
link the first one is you go to visit

00:14:58,829 --> 00:15:02,790
the site and it delivers some code to

00:15:00,300 --> 00:15:05,009
you how does it know what kind of code

00:15:02,790 --> 00:15:06,569
it should deliver to you because if

00:15:05,009 --> 00:15:07,709
you're running on a Mac then you need to

00:15:06,569 --> 00:15:10,319
have a different kind of machine code

00:15:07,709 --> 00:15:11,759
than if you're running on Windows does

00:15:10,319 --> 00:15:13,470
the website need to have a different

00:15:11,759 --> 00:15:17,130
version of the code for every possible

00:15:13,470 --> 00:15:19,050
device no instead the site has one

00:15:17,130 --> 00:15:21,120
version of code the source code and

00:15:19,050 --> 00:15:23,399
that's what's delivered to the user and

00:15:21,120 --> 00:15:26,459
that is translated to machine code on

00:15:23,399 --> 00:15:29,730
the user's device the name for this

00:15:26,459 --> 00:15:31,019
concept is portability with it websites

00:15:29,730 --> 00:15:33,300
don't need to know what kind of device

00:15:31,019 --> 00:15:35,639
you're running but that brings us to a

00:15:33,300 --> 00:15:37,680
second problem if you don't know these

00:15:35,639 --> 00:15:39,300
people whose webpages you're visiting

00:15:37,680 --> 00:15:41,459
how do you know what kind of code

00:15:39,300 --> 00:15:44,069
they're going to give to you it could be

00:15:41,459 --> 00:15:46,170
trying to take over your system doesn't

00:15:44,069 --> 00:15:48,059
this vision of the web running code from

00:15:46,170 --> 00:15:49,949
anybody who's a link you follow mean

00:15:48,059 --> 00:15:52,529
that you have to blindly trust anyone

00:15:49,949 --> 00:15:54,720
who's on the web this is where the other

00:15:52,529 --> 00:15:58,709
key concept from the web comes in and

00:15:54,720 --> 00:16:00,300
that's the security model basically the

00:15:58,709 --> 00:16:02,189
browser takes the code and puts it in a

00:16:00,300 --> 00:16:04,889
sandbox and it puts a couple of toys in

00:16:02,189 --> 00:16:06,360
that sandbox that make it possible for

00:16:04,889 --> 00:16:08,850
the code to do some interesting things

00:16:06,360 --> 00:16:10,550
but it leaves the dangerous toys outside

00:16:08,850 --> 00:16:12,990
of the sandbox

00:16:10,550 --> 00:16:14,610
so the utility of the link is based on

00:16:12,990 --> 00:16:16,379
these two things the portability being

00:16:14,610 --> 00:16:17,759
able to deliver the same code to all

00:16:16,379 --> 00:16:20,730
these different devices and have it run

00:16:17,759 --> 00:16:22,139
and the sandbox the security model that

00:16:20,730 --> 00:16:25,649
lets you run the code without putting

00:16:22,139 --> 00:16:27,449
your machine at risk so what difference

00:16:25,649 --> 00:16:30,629
does it make if you think of the web

00:16:27,449 --> 00:16:33,179
this way it changes how you think of web

00:16:30,629 --> 00:16:34,829
assembly you can think about web

00:16:33,179 --> 00:16:37,559
assembly is just another tool in the

00:16:34,829 --> 00:16:40,290
browser's toolbox which it is but it's

00:16:37,559 --> 00:16:41,699
not just that what assembly also gives

00:16:40,290 --> 00:16:44,040
us a way to take these other two

00:16:41,699 --> 00:16:45,569
capabilities of the web the portability

00:16:44,040 --> 00:16:47,519
and the security model and bring them to

00:16:45,569 --> 00:16:50,220
use cases that need them to outside of

00:16:47,519 --> 00:16:53,249
the web we can expand the web past the

00:16:50,220 --> 00:16:54,959
boundaries of the browser now you may be

00:16:53,249 --> 00:16:55,610
thinking that already happened with

00:16:54,959 --> 00:16:58,170
nodejs

00:16:55,610 --> 00:16:59,910
but as it is today note doesn't quite

00:16:58,170 --> 00:17:01,679
get us there it doesn't give us full

00:16:59,910 --> 00:17:03,360
portability and it doesn't give us the

00:17:01,679 --> 00:17:06,230
same security the same ability to run

00:17:03,360 --> 00:17:09,750
untrusted code either

00:17:06,230 --> 00:17:11,610
so James modules is using with node it's

00:17:09,750 --> 00:17:13,620
possible to run JavaScript on servers

00:17:11,610 --> 00:17:15,689
and other devices that don't have a

00:17:13,620 --> 00:17:18,390
browser so that does give us some

00:17:15,689 --> 00:17:21,120
portability but you still need native

00:17:18,390 --> 00:17:23,370
modules in a lot of cases either because

00:17:21,120 --> 00:17:25,110
you need the code to run really fast or

00:17:23,370 --> 00:17:26,880
you already have code written in a

00:17:25,110 --> 00:17:29,850
language like C that you want to then

00:17:26,880 --> 00:17:32,039
use in your app but native modules

00:17:29,850 --> 00:17:33,870
aren't portable they have to be compiled

00:17:32,039 --> 00:17:37,110
ahead of time specifically for the kind

00:17:33,870 --> 00:17:40,200
of device the users using we're also

00:17:37,110 --> 00:17:42,090
still missing security node could have

00:17:40,200 --> 00:17:43,890
taken the sandbox from the browser but

00:17:42,090 --> 00:17:46,380
node made the define decision early on

00:17:43,890 --> 00:17:49,740
that J's modules would have full access

00:17:46,380 --> 00:17:51,390
to certain system api's so J's modules

00:17:49,740 --> 00:17:54,000
can do things like write and read file

00:17:51,390 --> 00:17:56,730
on your machine these capabilities

00:17:54,000 --> 00:17:58,560
things like direct file access to your

00:17:56,730 --> 00:18:01,520
system are the dangerous toys that

00:17:58,560 --> 00:18:04,410
aren't available in the browser sandbox

00:18:01,520 --> 00:18:06,060
even though they're dangerous though for

00:18:04,410 --> 00:18:08,370
the kinds of use cases that node was

00:18:06,060 --> 00:18:09,420
built for these these api's do make a

00:18:08,370 --> 00:18:12,020
certain kind of sense this kind of

00:18:09,420 --> 00:18:15,030
access makes a certain kind of sense the

00:18:12,020 --> 00:18:18,090
thing I want to make clear here is that

00:18:15,030 --> 00:18:20,150
node made a choice really is that node

00:18:18,090 --> 00:18:22,680
had a choice to make

00:18:20,150 --> 00:18:25,380
4j s modules it could have gone with a

00:18:22,680 --> 00:18:27,230
sandbox style approach but for native

00:18:25,380 --> 00:18:29,730
modules node had less of a choice

00:18:27,230 --> 00:18:33,800
because it's really hard to sandbox

00:18:29,730 --> 00:18:35,790
native code so notice made this choice

00:18:33,800 --> 00:18:37,470
basically if you're running a node

00:18:35,790 --> 00:18:39,090
application today on your computer

00:18:37,470 --> 00:18:41,370
you've basically said I trust this code

00:18:39,090 --> 00:18:42,720
although the node developers are

00:18:41,370 --> 00:18:46,320
actually looking at a way that they can

00:18:42,720 --> 00:18:50,280
change this in the future but despite

00:18:46,320 --> 00:18:51,900
this webassembly can still help node it

00:18:50,280 --> 00:18:53,670
could eliminate most of the need for

00:18:51,900 --> 00:18:56,210
native modules ones that are compiled

00:18:53,670 --> 00:18:58,170
ahead of time for the user's device

00:18:56,210 --> 00:19:01,560
these could be written in webassembly

00:18:58,170 --> 00:19:02,730
instead and just compiled once and these

00:19:01,560 --> 00:19:05,960
modules could then run across all

00:19:02,730 --> 00:19:08,340
devices just like JavaScript modules do

00:19:05,960 --> 00:19:10,290
the only problem here is that web

00:19:08,340 --> 00:19:13,020
assembly doesn't have direct access to

00:19:10,290 --> 00:19:15,330
the system's resources we would need to

00:19:13,020 --> 00:19:16,500
pass in functions to the web assembly

00:19:15,330 --> 00:19:19,830
module so they can work with the

00:19:16,500 --> 00:19:20,880
operating system now for note this will

00:19:19,830 --> 00:19:22,560
probably include a lot of the

00:19:20,880 --> 00:19:24,180
functionality of things like the c

00:19:22,560 --> 00:19:26,940
standard library and things that are

00:19:24,180 --> 00:19:28,770
part of POSIX the portable operating

00:19:26,940 --> 00:19:30,300
system interface which is an older

00:19:28,770 --> 00:19:31,860
standard and helps with compatibility

00:19:30,300 --> 00:19:35,760
across different kinds of operating

00:19:31,860 --> 00:19:38,100
systems unix-like operating systems to

00:19:35,760 --> 00:19:39,510
make that happen the node core folks

00:19:38,100 --> 00:19:42,420
would need to figure out what API they

00:19:39,510 --> 00:19:43,530
want to use for these functions but

00:19:42,420 --> 00:19:45,990
wouldn't it be nice if that were

00:19:43,530 --> 00:19:48,060
actually something standard not

00:19:45,990 --> 00:19:49,530
something that was constrained just to

00:19:48,060 --> 00:19:53,010
node but could be used across other

00:19:49,530 --> 00:19:55,140
runtimes and use cases to a POSIX for

00:19:53,010 --> 00:19:58,470
web assembly if you will a POSIX a

00:19:55,140 --> 00:20:00,210
portable web assembly system interface

00:19:58,470 --> 00:20:02,700
and if this were done in the right way

00:20:00,210 --> 00:20:05,730
you could even implement the same API

00:20:02,700 --> 00:20:07,139
but in a different way for the web now

00:20:05,730 --> 00:20:09,240
these functions wouldn't be part of the

00:20:07,139 --> 00:20:10,799
core web assembly spec and there would

00:20:09,240 --> 00:20:12,960
be web assembly hosts that didn't

00:20:10,799 --> 00:20:14,129
include them but for platforms that

00:20:12,960 --> 00:20:16,590
could make use of them

00:20:14,129 --> 00:20:18,090
there would be a unified API for calling

00:20:16,590 --> 00:20:21,299
these functions no matter which platform

00:20:18,090 --> 00:20:22,889
your code was running on and this would

00:20:21,299 --> 00:20:24,960
make universal modules ones that run

00:20:22,889 --> 00:20:27,389
across both the web and node so much

00:20:24,960 --> 00:20:29,240
easier so is this something that could

00:20:27,389 --> 00:20:33,149
actually happen

00:20:29,240 --> 00:20:37,320
well we and others are working on it and

00:20:33,149 --> 00:20:39,870
I think we have a pretty good chance and

00:20:37,320 --> 00:20:42,600
we are also seeing a lot of demand for

00:20:39,870 --> 00:20:45,779
this from a wide range of that with

00:20:42,600 --> 00:20:49,799
different domains one of these domains

00:20:45,779 --> 00:20:53,370
is the domain of CD ends of service and

00:20:49,799 --> 00:20:56,460
off top computing the fastly CDN for

00:20:53,370 --> 00:20:59,580
example serves a significant fraction of

00:20:56,460 --> 00:21:03,029
the entire Internet traffic and they are

00:20:59,580 --> 00:21:05,720
moving from serving just static files as

00:21:03,029 --> 00:21:08,399
Citians have historically done to

00:21:05,720 --> 00:21:11,220
running their customers code on every

00:21:08,399 --> 00:21:13,379
incoming request and they are doing this

00:21:11,220 --> 00:21:16,080
without adding ten times as many

00:21:13,379 --> 00:21:18,360
machines to their network which is

00:21:16,080 --> 00:21:21,360
really what they would have to do if

00:21:18,360 --> 00:21:24,330
they were to use more traditional server

00:21:21,360 --> 00:21:26,929
architectures where you'd use something

00:21:24,330 --> 00:21:31,159
like containers or other heavy wage

00:21:26,929 --> 00:21:33,960
mechanisms to one untrusted code instead

00:21:31,159 --> 00:21:36,899
webassembly gives them the sandboxing

00:21:33,960 --> 00:21:40,500
they need at the speed and at the scale

00:21:36,899 --> 00:21:43,289
that they need people are also working

00:21:40,500 --> 00:21:46,259
on building blockchain platforms with

00:21:43,289 --> 00:21:49,500
web assembly this interest in the IOT

00:21:46,259 --> 00:21:54,629
space and in a world of reading portable

00:21:49,500 --> 00:21:56,820
CLI tools with web simply we've also

00:21:54,629 --> 00:21:59,519
seen interest from companies building

00:21:56,820 --> 00:22:05,269
game engines where web simply can be

00:21:59,519 --> 00:22:08,580
used to run game logic in sandboxes and

00:22:05,269 --> 00:22:11,039
with projects like wasn't written a

00:22:08,580 --> 00:22:12,400
beulah some folks try to make it one

00:22:11,039 --> 00:22:15,370
inside of weddings

00:22:12,400 --> 00:22:17,410
and criminals I don't have time to

00:22:15,370 --> 00:22:20,050
explain all these difficult use cases

00:22:17,410 --> 00:22:24,520
and what exactly makes assembly good for

00:22:20,050 --> 00:22:27,190
them but there are some important

00:22:24,520 --> 00:22:30,040
considerations but for example they all

00:22:27,190 --> 00:22:32,070
have in common that sandboxing and

00:22:30,040 --> 00:22:34,450
portability are important for them and

00:22:32,070 --> 00:22:36,280
there are some other important

00:22:34,450 --> 00:22:40,960
commonalities which I want to talk a bit

00:22:36,280 --> 00:22:43,860
more about for example how do things

00:22:40,960 --> 00:22:48,010
like network access work of file access

00:22:43,860 --> 00:22:51,460
the way these things work should ideally

00:22:48,010 --> 00:22:55,540
be roughly identical across all of these

00:22:51,460 --> 00:22:57,790
use cases or exactly identical if you

00:22:55,540 --> 00:23:01,450
use webassembly together with javascript

00:22:57,790 --> 00:23:03,940
in the browser or a node then javascript

00:23:01,450 --> 00:23:07,690
is used to let webassembly talk to the

00:23:03,940 --> 00:23:11,230
outside world you use fetch to load a

00:23:07,690 --> 00:23:13,180
file from a server in the browser all of

00:23:11,230 --> 00:23:17,500
this is standardized so you can rely on

00:23:13,180 --> 00:23:20,320
it and you use nodes FS thought we'd

00:23:17,500 --> 00:23:22,920
file to read a file and you can also

00:23:20,320 --> 00:23:25,570
rely on this but for a different reason

00:23:22,920 --> 00:23:29,110
there's really only one runtime you

00:23:25,570 --> 00:23:30,250
would use note because node is the de

00:23:29,110 --> 00:23:33,460
facto standard

00:23:30,250 --> 00:23:37,300
you know the api's you can use and can

00:23:33,460 --> 00:23:39,520
rely on ideally we all have a similar

00:23:37,300 --> 00:23:42,520
situation with web assembly where you

00:23:39,520 --> 00:23:45,280
know what api's you can work with but

00:23:42,520 --> 00:23:49,120
not with one runtime being completely

00:23:45,280 --> 00:23:50,710
dominant instead we are working towards

00:23:49,120 --> 00:23:52,870
the standardized runtime environment

00:23:50,710 --> 00:23:55,270
which means there'll be a set of

00:23:52,870 --> 00:23:57,700
functions that you can rely on for

00:23:55,270 --> 00:24:00,880
things like file access or network

00:23:57,700 --> 00:24:02,590
access that means you can compile code

00:24:00,880 --> 00:24:05,380
once and run it in all of these

00:24:02,590 --> 00:24:07,510
different environments and in any one

00:24:05,380 --> 00:24:09,190
time that provides these functions or on

00:24:07,510 --> 00:24:12,610
the browser where these functions can be

00:24:09,190 --> 00:24:17,880
implemented in using javascript using

00:24:12,610 --> 00:24:20,920
existing Dom API and then you can have

00:24:17,880 --> 00:24:24,040
at one time so that really tailored

00:24:20,920 --> 00:24:26,390
towards their exact use case instead of

00:24:24,040 --> 00:24:31,850
having to rely on

00:24:26,390 --> 00:24:35,150
size fits all so for this standard lab

00:24:31,850 --> 00:24:38,320
we we could have said let's just use

00:24:35,150 --> 00:24:38,320
POSIX and be done with it

00:24:38,350 --> 00:24:44,690
unfortunately that eliminates one of

00:24:40,550 --> 00:24:46,880
webassembly big advantages security

00:24:44,690 --> 00:24:48,650
model it's security model and in

00:24:46,880 --> 00:24:51,530
particular the sandbox england talked

00:24:48,650 --> 00:24:53,570
about lin also talked about how node had

00:24:51,530 --> 00:24:58,150
a choice to make at least four

00:24:53,570 --> 00:25:01,280
javascript modules its choice between

00:24:58,150 --> 00:25:03,230
keeping the sandbox that j s runs in in

00:25:01,280 --> 00:25:05,780
the browser or giving it an easy way to

00:25:03,230 --> 00:25:08,420
talk to the outside world and we now

00:25:05,780 --> 00:25:11,180
have the same choice to make do we go

00:25:08,420 --> 00:25:13,160
with this easiest route but give up on

00:25:11,180 --> 00:25:15,410
sandboxing or do we do something

00:25:13,160 --> 00:25:17,750
different something that allows better

00:25:15,410 --> 00:25:20,090
control and leads to better security and

00:25:17,750 --> 00:25:23,600
auditability and that last point is

00:25:20,090 --> 00:25:24,950
really important if you run an

00:25:23,600 --> 00:25:26,780
application or before you run an

00:25:24,950 --> 00:25:29,090
application ideally you should be able

00:25:26,780 --> 00:25:31,610
to tell what it can do to your machine

00:25:29,090 --> 00:25:33,680
sort of in the worst case can it access

00:25:31,610 --> 00:25:36,590
your entire file file system and then

00:25:33,680 --> 00:25:40,280
just send off things to the internet say

00:25:36,590 --> 00:25:42,470
your Bitcoin wallet maybe not run that

00:25:40,280 --> 00:25:45,800
machine maybe that that application but

00:25:42,470 --> 00:25:47,870
if it can only access files in a single

00:25:45,800 --> 00:25:53,870
directory and right back to that effect

00:25:47,870 --> 00:25:58,490
we seems fine now with POSIX that isn't

00:25:53,870 --> 00:26:00,830
quite a be hard and it really only works

00:25:58,490 --> 00:26:03,950
with support from the operating system

00:26:00,830 --> 00:26:06,530
and how this works is different between

00:26:03,950 --> 00:26:10,190
different operating systems so there

00:26:06,530 --> 00:26:14,900
goes a lot of your portability solid

00:26:10,190 --> 00:26:17,630
portable sandboxing is hard equi note

00:26:14,900 --> 00:26:20,230
was created nobody had really figured

00:26:17,630 --> 00:26:23,870
out how to apply it to the real world

00:26:20,230 --> 00:26:26,750
but with things such as Google's fuschia

00:26:23,870 --> 00:26:31,220
operating system this has changed better

00:26:26,750 --> 00:26:32,900
designs exist and for well some time we

00:26:31,220 --> 00:26:35,420
are working on a standard lab between

00:26:32,900 --> 00:26:38,060
that will make it easy to build secure

00:26:35,420 --> 00:26:38,960
auditable and portable modules and

00:26:38,060 --> 00:26:40,520
application

00:26:38,960 --> 00:26:45,550
that'll work for all of these different

00:26:40,520 --> 00:26:49,070
use cases so with the standardized API

00:26:45,550 --> 00:26:50,930
you could get the same flexibility that

00:26:49,070 --> 00:26:53,660
you have with note but still have

00:26:50,930 --> 00:26:55,970
security audit ability and the ability

00:26:53,660 --> 00:27:00,020
to run your code in very different

00:26:55,970 --> 00:27:02,330
runtimes and we are making sure that you

00:27:00,020 --> 00:27:05,360
can use the tools you are used to as

00:27:02,330 --> 00:27:09,290
well the compilers for languages such as

00:27:05,360 --> 00:27:13,610
C C++ and others and the debugger

00:27:09,290 --> 00:27:17,570
such as ll DB and gdb and IDE such as

00:27:13,610 --> 00:27:19,550
Xcode and Visual Studio code so as you

00:27:17,570 --> 00:27:21,950
can see there's a lot of active

00:27:19,550 --> 00:27:24,920
development in this space we are all

00:27:21,950 --> 00:27:27,320
working hard to make it easy for you to

00:27:24,920 --> 00:27:29,720
target these different use cases without

00:27:27,320 --> 00:27:32,660
making you jump through hoops to develop

00:27:29,720 --> 00:27:34,670
and debug your code and with this we

00:27:32,660 --> 00:27:36,290
bring these capabilities of the web that

00:27:34,670 --> 00:27:38,960
Lynn mentioned the Portability and

00:27:36,290 --> 00:27:44,060
security and the audit ability that I

00:27:38,960 --> 00:27:46,400
mentioned to all of these use cases now

00:27:44,060 --> 00:27:51,170
let's zoom back out and look at the

00:27:46,400 --> 00:27:52,160
skill tree I said at the beginning of

00:27:51,170 --> 00:27:54,890
this talk that people have a

00:27:52,160 --> 00:27:56,930
misconception about web assembly this

00:27:54,890 --> 00:27:59,060
idea that the web assembly that landed

00:27:56,930 --> 00:28:00,950
in the MVP was the final version of web

00:27:59,060 --> 00:28:04,400
assembly and I think you can see now why

00:28:00,950 --> 00:28:06,260
this is a misconception yes the MVP

00:28:04,400 --> 00:28:07,970
opened up a lot of opportunities and

00:28:06,260 --> 00:28:10,970
made it possible to bring a lot of

00:28:07,970 --> 00:28:13,820
desktop applications to the web but we

00:28:10,970 --> 00:28:15,590
still have many use cases to unlock from

00:28:13,820 --> 00:28:17,450
heavyweight desktop applications to

00:28:15,590 --> 00:28:18,830
small modules to JavaScript frameworks

00:28:17,450 --> 00:28:21,290
to all of those things outside of the

00:28:18,830 --> 00:28:23,180
browser node and serverless in the

00:28:21,290 --> 00:28:26,120
blockchain and portable CLI tools in the

00:28:23,180 --> 00:28:27,650
internet of things so the web assembly

00:28:26,120 --> 00:28:29,720
that we have today is not the end of the

00:28:27,650 --> 00:28:31,880
story because what assembly still has

00:28:29,720 --> 00:28:34,640
promised to keep and many places to go

00:28:31,880 --> 00:28:36,230
before it sleeps I want to thank my

00:28:34,640 --> 00:28:38,230
collaborators on developing this talk

00:28:36,230 --> 00:28:41,830
luke Wagner until Schneider right and

00:28:38,230 --> 00:28:43,750
thank you all for listening

00:28:41,830 --> 00:28:46,950
you

00:28:43,750 --> 00:28:46,950

YouTube URL: https://www.youtube.com/watch?v=MowRVWn02HM


