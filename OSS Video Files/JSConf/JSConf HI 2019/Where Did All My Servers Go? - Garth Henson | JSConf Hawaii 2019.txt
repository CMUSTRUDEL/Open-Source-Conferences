Title: Where Did All My Servers Go? - Garth Henson | JSConf Hawaii 2019
Publication date: 2019-06-24
Playlist: JSConf HI 2019
Description: 
	Garth Henson demystifies severless computing, explaining when it should be used, when it should be avoided, and what the tradeoffs are for moving from a monolith to serverless.

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:06,840 --> 00:00:11,320
my name is Garth Henson as was mentioned

00:00:09,700 --> 00:00:12,730
I do

00:00:11,320 --> 00:00:15,219
Disney Company I've been with the

00:00:12,730 --> 00:00:18,360
company about five years now thank you

00:00:15,219 --> 00:00:21,160
that that's how I feel still every day I

00:00:18,360 --> 00:00:22,900
worked out of the Seattle office for

00:00:21,160 --> 00:00:23,950
about four years I work with corporate

00:00:22,900 --> 00:00:27,039
technology there

00:00:23,950 --> 00:00:29,439
what we do is basically platform to

00:00:27,039 --> 00:00:31,029
laying anything we need to build to

00:00:29,439 --> 00:00:32,980
enable the different brands to do what

00:00:31,029 --> 00:00:35,350
they need to do so right now I'm working

00:00:32,980 --> 00:00:36,790
with the SPN we work with ABC News we

00:00:35,350 --> 00:00:38,530
work with Parks and Resorts we work with

00:00:36,790 --> 00:00:40,809
all the different brands from an

00:00:38,530 --> 00:00:42,539
infrastructure architecture application

00:00:40,809 --> 00:00:46,000
basically whatever we need to build

00:00:42,539 --> 00:00:48,520
right now it's kind of fun because most

00:00:46,000 --> 00:00:50,320
of what I build is node on the backend

00:00:48,520 --> 00:00:52,629
and we do full stack all the way up then

00:00:50,320 --> 00:00:53,980
we do react on the front end and so most

00:00:52,629 --> 00:00:56,710
of the stuff we're working is JavaScript

00:00:53,980 --> 00:00:59,170
end to end one of the reasons I am

00:00:56,710 --> 00:01:02,289
excited about this talk is this is

00:00:59,170 --> 00:01:03,899
something that is an ongoing project is

00:01:02,289 --> 00:01:06,399
we're trying to figure out which

00:01:03,899 --> 00:01:08,380
applications we should move to not only

00:01:06,399 --> 00:01:10,990
into the cloud but into a service

00:01:08,380 --> 00:01:12,850
architecture the nice thing is that in

00:01:10,990 --> 00:01:15,190
most cases we can keep running

00:01:12,850 --> 00:01:16,689
JavaScript end to end with maybe a

00:01:15,190 --> 00:01:18,159
little bit of bash in there for some of

00:01:16,689 --> 00:01:20,590
our docker containers and entry points

00:01:18,159 --> 00:01:22,830
and that type of thing so that's what

00:01:20,590 --> 00:01:25,810
we're gonna talk about today

00:01:22,830 --> 00:01:27,880
serverless is one of those very

00:01:25,810 --> 00:01:29,470
interesting terms it's been a buzzword

00:01:27,880 --> 00:01:32,759
for a long time and it's one that I

00:01:29,470 --> 00:01:35,770
really don't like honestly serverless

00:01:32,759 --> 00:01:39,369
sounds like we just don't have service

00:01:35,770 --> 00:01:40,689
anymore which of course we know they

00:01:39,369 --> 00:01:42,009
just are going to go away and everything

00:01:40,689 --> 00:01:45,850
runs on magic right that's at least at

00:01:42,009 --> 00:01:48,399
Disney that's how it works but but what

00:01:45,850 --> 00:01:50,649
is serverless server this computing

00:01:48,399 --> 00:01:53,170
based on a Wikipedia definition here

00:01:50,649 --> 00:01:55,270
it's really a cloud computing execution

00:01:53,170 --> 00:01:57,399
model it's a process it's a way of

00:01:55,270 --> 00:01:59,259
thinking in which the cloud provider

00:01:57,399 --> 00:02:01,840
dynamically manages allocation of

00:01:59,259 --> 00:02:03,759
machine resources and then the pricing

00:02:01,840 --> 00:02:06,040
itself is generally based on the actual

00:02:03,759 --> 00:02:08,619
consumption of the processing so

00:02:06,040 --> 00:02:11,380
whatever you use is what you pay for so

00:02:08,619 --> 00:02:14,170
obviously that means I'm not there yes

00:02:11,380 --> 00:02:16,000
arms up and so this this diagram kind of

00:02:14,170 --> 00:02:18,430
breaks down into a couple different

00:02:16,000 --> 00:02:20,590
categories all of the things we would

00:02:18,430 --> 00:02:23,320
talk about as a cloud offering and so

00:02:20,590 --> 00:02:24,609
most of these I hope many people in here

00:02:23,320 --> 00:02:24,970
familiar with some of the different

00:02:24,609 --> 00:02:29,740
burrows

00:02:24,970 --> 00:02:30,790
odd categories is is pretty common

00:02:29,740 --> 00:02:32,350
you're gonna have

00:02:30,790 --> 00:02:34,150
infrastructure-as-a-service whether

00:02:32,350 --> 00:02:36,970
that's an on-prem data center that

00:02:34,150 --> 00:02:39,160
you're having to pull resources from an

00:02:36,970 --> 00:02:41,950
out gate or you're using ec2 instances

00:02:39,160 --> 00:02:43,740
or you're using compute instances from

00:02:41,950 --> 00:02:47,410
whatever provider cloud provider you use

00:02:43,740 --> 00:02:50,170
you basically have to provision what you

00:02:47,410 --> 00:02:51,820
need and you have to assemble all of

00:02:50,170 --> 00:02:53,710
your pieces before you can deploy the

00:02:51,820 --> 00:02:56,050
code to it right that's that we're

00:02:53,710 --> 00:02:57,940
familiar with that and then you've got

00:02:56,050 --> 00:02:59,500
the SAS offerings which I think most of

00:02:57,940 --> 00:03:01,120
us are also familiar with where I just

00:02:59,500 --> 00:03:02,500
don't either want to take the time or

00:03:01,120 --> 00:03:04,240
the money to build it I'd rather put the

00:03:02,500 --> 00:03:06,220
money into paying for the service and

00:03:04,240 --> 00:03:08,350
just use it where it stands and let them

00:03:06,220 --> 00:03:10,030
manage the SaaS let them manage

00:03:08,350 --> 00:03:11,290
everything else and the support layers

00:03:10,030 --> 00:03:13,630
we just don't want to take that on

00:03:11,290 --> 00:03:15,700
ourselves so we're gonna buy the service

00:03:13,630 --> 00:03:18,910
from somebody else use it in place and

00:03:15,700 --> 00:03:20,620
continue processing and then more

00:03:18,910 --> 00:03:22,540
recently we're getting more and more

00:03:20,620 --> 00:03:24,760
capabilities of moving things into the

00:03:22,540 --> 00:03:26,410
cloud on top of your past offering so

00:03:24,760 --> 00:03:28,350
you've got your platform as a service

00:03:26,410 --> 00:03:31,810
that you're going to start leveraging

00:03:28,350 --> 00:03:33,220
and what's really interesting and we'll

00:03:31,810 --> 00:03:36,220
talk a little bit more about this is

00:03:33,220 --> 00:03:37,780
with things like Direct Connect for AWS

00:03:36,220 --> 00:03:39,720
and there's other things with with some

00:03:37,780 --> 00:03:42,160
of the other service offerings as well

00:03:39,720 --> 00:03:44,680
you can actually start running some of

00:03:42,160 --> 00:03:47,560
these platform offerings on your own

00:03:44,680 --> 00:03:50,200
private networks and so even though it's

00:03:47,560 --> 00:03:51,550
still managed completely remotely by

00:03:50,200 --> 00:03:52,900
your service provider you can actually

00:03:51,550 --> 00:03:55,060
run it on your private network as well

00:03:52,900 --> 00:03:57,250
so you starting to get the best of both

00:03:55,060 --> 00:03:59,170
worlds where you can start leveraging

00:03:57,250 --> 00:04:00,549
these other pieces but yet keep your

00:03:59,170 --> 00:04:03,400
connectivity the way it needs to be for

00:04:00,549 --> 00:04:05,019
your broader application and then on

00:04:03,400 --> 00:04:08,230
this diagram as well you'll notice that

00:04:05,019 --> 00:04:11,049
towards the top here we have the

00:04:08,230 --> 00:04:12,959
functions and the database is a service

00:04:11,049 --> 00:04:16,989
some of your things like your no sequels

00:04:12,959 --> 00:04:19,810
firebase or you've got your dynamo DB

00:04:16,989 --> 00:04:21,820
type of thing those are typically what

00:04:19,810 --> 00:04:23,200
we group into what we would really call

00:04:21,820 --> 00:04:24,760
server lists those are the things that

00:04:23,200 --> 00:04:27,100
basically everybody says oh yeah just

00:04:24,760 --> 00:04:31,030
use it it'll it'll scale and you just

00:04:27,100 --> 00:04:32,440
pay for what you use which is true but

00:04:31,030 --> 00:04:35,919
we need to make sure we understand what

00:04:32,440 --> 00:04:37,750
that actually means so this is if we're

00:04:35,919 --> 00:04:38,740
in a smaller room I would pause for

00:04:37,750 --> 00:04:40,900
questions but I

00:04:38,740 --> 00:04:43,030
say now if you have questions please do

00:04:40,900 --> 00:04:44,979
come talk to me afterwards I don't have

00:04:43,030 --> 00:04:46,630
all the answers I'm still learning a lot

00:04:44,979 --> 00:04:50,069
of this but I do want to share what

00:04:46,630 --> 00:04:53,470
we've what we've figured out so far so

00:04:50,069 --> 00:04:55,090
of course once we understand all of

00:04:53,470 --> 00:04:56,889
these this means this brings us to the

00:04:55,090 --> 00:04:58,900
conclusion I've heard so many times

00:04:56,889 --> 00:04:59,949
no more server is yeah everything's

00:04:58,900 --> 00:05:03,340
awesome we'd have to worry about

00:04:59,949 --> 00:05:06,520
anything anymore no actually all it

00:05:03,340 --> 00:05:08,680
means is it's not my servers the the

00:05:06,520 --> 00:05:09,880
problem or the the hiccups that the

00:05:08,680 --> 00:05:12,310
things we have to be aware of don't go

00:05:09,880 --> 00:05:16,659
away they just move to another location

00:05:12,310 --> 00:05:21,759
the concerns we have to be aware of just

00:05:16,659 --> 00:05:25,479
change it they don't go away why do we

00:05:21,759 --> 00:05:27,819
care why does it matter well if we look

00:05:25,479 --> 00:05:29,949
at the benefits of service there's

00:05:27,819 --> 00:05:32,710
several and then there's other things we

00:05:29,949 --> 00:05:33,729
have to be aware of as we move into this

00:05:32,710 --> 00:05:38,500
architecture

00:05:33,729 --> 00:05:42,520
first of all cost cost really is almost

00:05:38,500 --> 00:05:44,159
unanimously cited as the driving reason

00:05:42,520 --> 00:05:46,120
to move to serverless adoption

00:05:44,159 --> 00:05:47,320
everybody's like oh it's just cheaper

00:05:46,120 --> 00:05:51,190
everything should be service

00:05:47,320 --> 00:05:52,930
everything's cheaper which can be on

00:05:51,190 --> 00:05:56,409
demand execution built-in elasticity

00:05:52,930 --> 00:05:58,000
optimizes utilization uptime reliability

00:05:56,409 --> 00:06:00,789
everything's higher this is this is all

00:05:58,000 --> 00:06:02,500
true this is great it's fantastic but I

00:06:00,789 --> 00:06:06,180
want to see there's a there's a specific

00:06:02,500 --> 00:06:09,909
word right there the savings can be

00:06:06,180 --> 00:06:12,240
insane if they're built correctly for

00:06:09,909 --> 00:06:14,199
the appropriate applications they are

00:06:12,240 --> 00:06:18,460
incredibly cheaper to run

00:06:14,199 --> 00:06:20,469
however there's that key word of if we

00:06:18,460 --> 00:06:22,300
build them properly and we use it used

00:06:20,469 --> 00:06:24,340
it for the appropriate application it's

00:06:22,300 --> 00:06:27,940
cheaper so keep that in mind

00:06:24,340 --> 00:06:30,250
scalability by definition we're using

00:06:27,940 --> 00:06:33,490
serverless offerings we're using hosted

00:06:30,250 --> 00:06:36,190
and managed solutions and so scalability

00:06:33,490 --> 00:06:38,800
is built into it reliability it's really

00:06:36,190 --> 00:06:40,539
based off your providers SLA so we have

00:06:38,800 --> 00:06:42,849
all of these great potential benefits

00:06:40,539 --> 00:06:45,270
that we can get out of moving

00:06:42,849 --> 00:06:49,000
applications into a service architecture

00:06:45,270 --> 00:06:51,400
but we need to be aware I love this

00:06:49,000 --> 00:06:52,090
quote the most common currency to pay

00:06:51,400 --> 00:06:54,160
for benefits

00:06:52,090 --> 00:06:57,970
in our application architecture its

00:06:54,160 --> 00:07:00,040
complexity so how do we get I don't know

00:06:57,970 --> 00:07:02,260
if you I don't have the diagram up here

00:07:00,040 --> 00:07:03,820
but you've got different pivots that you

00:07:02,260 --> 00:07:06,280
can actually pull on in any application

00:07:03,820 --> 00:07:08,260
right any architecture management comes

00:07:06,280 --> 00:07:10,540
down says hey this has to run less

00:07:08,260 --> 00:07:12,550
expensively okay great it's gonna be

00:07:10,540 --> 00:07:14,500
slower now or it's going to be there's

00:07:12,550 --> 00:07:18,250
only certain things we can pull on and

00:07:14,500 --> 00:07:20,410
in order to reduce the cost and increase

00:07:18,250 --> 00:07:22,540
the performance and the scalability and

00:07:20,410 --> 00:07:24,160
reliability the easiest way to do that

00:07:22,540 --> 00:07:26,410
is to increase complexity now what does

00:07:24,160 --> 00:07:29,290
that look like though well in this

00:07:26,410 --> 00:07:31,570
diagram we kind of see the stepping

00:07:29,290 --> 00:07:34,570
stones between moving from our old

00:07:31,570 --> 00:07:36,070
monolithic applications into a standard

00:07:34,570 --> 00:07:38,580
what we would call the microservice

00:07:36,070 --> 00:07:41,560
infrastructure or ecosystem and

00:07:38,580 --> 00:07:44,470
basically what happens is is from step

00:07:41,560 --> 00:07:46,479
one to step two all we've done is we've

00:07:44,470 --> 00:07:48,160
broken all of those bits of logic all of

00:07:46,479 --> 00:07:50,440
those sections of the code that we're

00:07:48,160 --> 00:07:51,850
running all in one big application we've

00:07:50,440 --> 00:07:54,430
broken them out into their own smaller

00:07:51,850 --> 00:07:56,650
services which is great but now we have

00:07:54,430 --> 00:07:58,960
all this wiring in between so we've

00:07:56,650 --> 00:08:01,000
introduced some complexity of the wiring

00:07:58,960 --> 00:08:03,090
breaking a model with into into a

00:08:01,000 --> 00:08:05,350
microservices now did we gain

00:08:03,090 --> 00:08:07,450
performance reliability yeah if it's

00:08:05,350 --> 00:08:10,060
done right absolutely but we've added

00:08:07,450 --> 00:08:12,250
some type of complexity so when we're

00:08:10,060 --> 00:08:16,270
moving from microservice infrastructure

00:08:12,250 --> 00:08:19,780
or architecture into a full server love

00:08:16,270 --> 00:08:21,580
stack we're introducing far more wiring

00:08:19,780 --> 00:08:24,130
in between all the pieces so the

00:08:21,580 --> 00:08:27,280
complexity is potentially much greater

00:08:24,130 --> 00:08:29,229
for the overall application even if the

00:08:27,280 --> 00:08:30,910
individual pieces of code that we as

00:08:29,229 --> 00:08:33,370
engineers are managing are much much

00:08:30,910 --> 00:08:35,560
simpler to maintain so the overall

00:08:33,370 --> 00:08:38,260
application architecture we've got to be

00:08:35,560 --> 00:08:39,820
aware of as we go and then all of this

00:08:38,260 --> 00:08:43,779
of course is built on top of some type

00:08:39,820 --> 00:08:48,100
of a platform that we're paying for or

00:08:43,779 --> 00:08:51,550
we've spun up internally so Oh moving on

00:08:48,100 --> 00:08:55,300
here here are some of the things that we

00:08:51,550 --> 00:08:57,820
have to be aware of as the heading up

00:08:55,300 --> 00:09:02,980
here says service is cheaper not

00:08:57,820 --> 00:09:04,660
necessarily simpler anybody played with

00:09:02,980 --> 00:09:05,860
us three much and had any issues with

00:09:04,660 --> 00:09:09,339
eventual consistency

00:09:05,860 --> 00:09:12,490
a couple hands awesome okay so if you're

00:09:09,339 --> 00:09:16,600
not aware of what eventual consisted he

00:09:12,490 --> 00:09:17,620
consistently and and I told miles I was

00:09:16,600 --> 00:09:18,670
going to have to apologize to him I

00:09:17,620 --> 00:09:22,120
don't know if he's in here all of my

00:09:18,670 --> 00:09:24,640
examples are AWS I am intentionally

00:09:22,120 --> 00:09:26,170
doing pretty generic examples because

00:09:24,640 --> 00:09:28,360
these are things you can do on any

00:09:26,170 --> 00:09:30,459
service provider I'm not doing a sales

00:09:28,360 --> 00:09:33,000
pitch for AWS I just just what I know

00:09:30,459 --> 00:09:35,440
the best but eventual consistency

00:09:33,000 --> 00:09:39,130
basically means you can drop an object

00:09:35,440 --> 00:09:40,990
into an s3 bucket for storage and it may

00:09:39,130 --> 00:09:43,269
or may not be available for a read right

00:09:40,990 --> 00:09:44,709
away because it has the replicated

00:09:43,269 --> 00:09:46,510
across different data centers it's got

00:09:44,709 --> 00:09:48,040
to replicate across regions and when

00:09:46,510 --> 00:09:50,860
you're get requests or your pull request

00:09:48,040 --> 00:09:52,720
goes back out if it hasn't replicated

00:09:50,860 --> 00:09:54,310
all the way across you might hit a

00:09:52,720 --> 00:09:56,560
bucket or region where it hasn't

00:09:54,310 --> 00:09:58,390
propagated yet and so even though you

00:09:56,560 --> 00:10:01,240
just wrote it you've got a success it

00:09:58,390 --> 00:10:02,769
may not be available to read yet and so

00:10:01,240 --> 00:10:04,089
we actually had a couple projects we're

00:10:02,769 --> 00:10:05,380
like a server looks awesome we're gonna

00:10:04,089 --> 00:10:06,579
do one lamb to here and it's going to

00:10:05,380 --> 00:10:07,959
drop something into a three and then

00:10:06,579 --> 00:10:09,279
it's gonna fire this thing off over here

00:10:07,959 --> 00:10:11,019
and then the other lamp is gonna pick it

00:10:09,279 --> 00:10:15,100
up and do more processing with it and it

00:10:11,019 --> 00:10:17,320
wasn't there and the entire flow grinds

00:10:15,100 --> 00:10:19,240
to a halt and we realized that oh we

00:10:17,320 --> 00:10:20,860
need to call AWS guys so we can is on

00:10:19,240 --> 00:10:22,600
the phone we're talking with them and

00:10:20,860 --> 00:10:29,230
the question of course what did you read

00:10:22,600 --> 00:10:31,420
the SLA no I didn't and s3 is eventual

00:10:29,230 --> 00:10:33,490
consistency there is a window of time in

00:10:31,420 --> 00:10:35,649
which they are still within their SLA

00:10:33,490 --> 00:10:37,870
and as long as you can read it back out

00:10:35,649 --> 00:10:40,420
within a certain length of time they're

00:10:37,870 --> 00:10:42,670
okay and so these are things like the

00:10:40,420 --> 00:10:44,440
fault tolerance a synchronicity is

00:10:42,670 --> 00:10:46,810
you're doing multiple lambdas they're

00:10:44,440 --> 00:10:49,240
stateless you've got things like this

00:10:46,810 --> 00:10:50,980
that you have to start juggling where

00:10:49,240 --> 00:10:54,190
you do it in an application level in a

00:10:50,980 --> 00:10:56,560
monolith or even a microcircuit maintain

00:10:54,190 --> 00:10:58,810
some type of state you now are

00:10:56,560 --> 00:11:00,790
introducing logical chunks that are

00:10:58,810 --> 00:11:03,130
stateless that have to be aware or be

00:11:00,790 --> 00:11:05,500
able to retrieve or rebuild or saturate

00:11:03,130 --> 00:11:07,630
or do something to be able to continue

00:11:05,500 --> 00:11:09,910
processing and so things that before

00:11:07,630 --> 00:11:11,680
were somewhat intuitive within the

00:11:09,910 --> 00:11:13,240
application architecture are now

00:11:11,680 --> 00:11:15,430
becoming things we have to manually

00:11:13,240 --> 00:11:18,399
think through and deal with or at least

00:11:15,430 --> 00:11:19,550
be aware of latency the only reason I

00:11:18,399 --> 00:11:21,860
bring it up here

00:11:19,550 --> 00:11:24,320
every new Network hop can introduce

00:11:21,860 --> 00:11:25,850
latency so if you have something let's

00:11:24,320 --> 00:11:27,620
say we've got three micro-services and

00:11:25,850 --> 00:11:29,660
they're talking nicely together and

00:11:27,620 --> 00:11:31,670
every new request hits all three of them

00:11:29,660 --> 00:11:33,290
and it's a handoff you've got the

00:11:31,670 --> 00:11:36,830
inbound request and then you've got at

00:11:33,290 --> 00:11:38,450
least two hops so you've got three but

00:11:36,830 --> 00:11:40,670
if we break that out and it turns into

00:11:38,450 --> 00:11:41,960
six different lambdas or whatever you're

00:11:40,670 --> 00:11:43,400
doubling the number of network

00:11:41,960 --> 00:11:45,560
connections the network hops you're

00:11:43,400 --> 00:11:46,880
having to make to process something so

00:11:45,560 --> 00:11:49,490
you've got to be aware of the increased

00:11:46,880 --> 00:11:50,870
latency potentially okay and again these

00:11:49,490 --> 00:11:52,790
are all just be aware of them they're

00:11:50,870 --> 00:11:54,050
not I'm not saying don't do it I'm just

00:11:52,790 --> 00:11:57,110
saying be aware of what the potential

00:11:54,050 --> 00:11:59,270
gotchas are let's see fault tolerance

00:11:57,110 --> 00:12:01,460
what happens if an asynchronous lambda

00:11:59,270 --> 00:12:03,980
spins up and fails and it can't process

00:12:01,460 --> 00:12:06,980
and it's responding to something that it

00:12:03,980 --> 00:12:08,510
pulled off of a queue have you thought

00:12:06,980 --> 00:12:10,040
through what's your dead letter Q look

00:12:08,510 --> 00:12:12,050
like are you going to actually do some

00:12:10,040 --> 00:12:13,970
retry logic what is your fault tolerance

00:12:12,050 --> 00:12:15,860
for it what's your retry all these

00:12:13,970 --> 00:12:21,920
things we have to start thinking through

00:12:15,860 --> 00:12:23,810
on a higher level or broader scale API

00:12:21,920 --> 00:12:25,400
is messaging schemas how are you gonna

00:12:23,810 --> 00:12:26,330
have all of the different pieces talk to

00:12:25,400 --> 00:12:29,030
each other if they're on the same

00:12:26,330 --> 00:12:31,670
process all of these different things

00:12:29,030 --> 00:12:32,930
rolling up grades how do you manage your

00:12:31,670 --> 00:12:35,780
actual upgrades of the individual

00:12:32,930 --> 00:12:38,750
lambdas or whatever whatever piece

00:12:35,780 --> 00:12:40,550
you're upgrading are you changing the

00:12:38,750 --> 00:12:42,320
signature of the payload you're dropping

00:12:40,550 --> 00:12:45,410
what what are all of the different

00:12:42,320 --> 00:12:48,920
pieces like that ah let's see and

00:12:45,410 --> 00:12:51,020
there's more so I've heard from a lot of

00:12:48,920 --> 00:12:52,790
people that hey just do everything

00:12:51,020 --> 00:12:54,980
serverless it's it's a solve all it'll

00:12:52,790 --> 00:12:58,430
cure everything and it's really not if

00:12:54,980 --> 00:12:59,720
you if you approach it as a cure-all if

00:12:58,430 --> 00:13:01,190
you approach it as a silver bullet

00:12:59,720 --> 00:13:02,330
that's gonna fix all of our problems I'm

00:13:01,190 --> 00:13:05,450
afraid people are gonna be very

00:13:02,330 --> 00:13:07,250
disappointed now again I say all of this

00:13:05,450 --> 00:13:10,040
and I'm a very big proponent of using

00:13:07,250 --> 00:13:13,040
serverless so don't get me wrong it is a

00:13:10,040 --> 00:13:14,930
fantastic tool but as with any other

00:13:13,040 --> 00:13:15,560
tool you've got to use the right tool

00:13:14,930 --> 00:13:17,630
for the right job

00:13:15,560 --> 00:13:20,180
and so every application if you're

00:13:17,630 --> 00:13:22,490
considering server lists as a potential

00:13:20,180 --> 00:13:24,590
architecture you need to evaluate your

00:13:22,490 --> 00:13:26,360
actual system what it is you're trying

00:13:24,590 --> 00:13:29,000
to build and what the benefits are what

00:13:26,360 --> 00:13:31,480
is your ROI what's the cost going to be

00:13:29,000 --> 00:13:34,630
how many requests are you gonna have

00:13:31,480 --> 00:13:35,830
and we'll look at a couple examples here

00:13:34,630 --> 00:13:39,820
in a minute where we can actually talk

00:13:35,830 --> 00:13:45,130
through some of those concerns so let's

00:13:39,820 --> 00:13:46,390
build a little bit this slide we're

00:13:45,130 --> 00:13:49,480
going to talk through a couple of the

00:13:46,390 --> 00:13:52,470
options in the AWS toolset that actually

00:13:49,480 --> 00:13:55,410
we use regularly for service

00:13:52,470 --> 00:13:58,450
applications so broader architectures

00:13:55,410 --> 00:14:00,400
some of these are arguable they fall

00:13:58,450 --> 00:14:02,710
into slightly different categories and

00:14:00,400 --> 00:14:05,260
maybe somebody like well that's not pure

00:14:02,710 --> 00:14:07,690
serverless that's the bass or something

00:14:05,260 --> 00:14:09,190
yeah I get that but overall from a

00:14:07,690 --> 00:14:11,740
service architecture standpoint here's a

00:14:09,190 --> 00:14:14,100
few things to be aware of we use route

00:14:11,740 --> 00:14:18,130
53 anytime we can to do dns resolution

00:14:14,100 --> 00:14:19,840
because it ties so seamlessly into some

00:14:18,130 --> 00:14:22,660
of the other pieces like the API gateway

00:14:19,840 --> 00:14:24,610
if you have not looked into the API

00:14:22,660 --> 00:14:26,620
management structures for several of the

00:14:24,610 --> 00:14:30,310
different cloud providers API gateway is

00:14:26,620 --> 00:14:33,130
great they're the the way you can define

00:14:30,310 --> 00:14:35,020
and manage configuration for even

00:14:33,130 --> 00:14:35,770
authentication and header parsing

00:14:35,020 --> 00:14:39,790
different things like that

00:14:35,770 --> 00:14:41,530
it's pretty pretty slick lambdas

00:14:39,790 --> 00:14:43,150
themselves this is this is pretty

00:14:41,530 --> 00:14:46,840
standard this is what every provider has

00:14:43,150 --> 00:14:50,020
as their cloud functions you you provide

00:14:46,840 --> 00:14:52,540
enough logic to run as a single logical

00:14:50,020 --> 00:14:54,280
execution and you want to break it down

00:14:52,540 --> 00:14:55,750
and make sure you don't throw too much

00:14:54,280 --> 00:14:58,020
in there you're going to run within

00:14:55,750 --> 00:15:00,730
restrictions in the different providers

00:14:58,020 --> 00:15:03,220
such as within lambdas if you're running

00:15:00,730 --> 00:15:05,830
more than I believe it's a five Meg

00:15:03,220 --> 00:15:07,930
payload in a post request in or into the

00:15:05,830 --> 00:15:10,300
context into the lambda is your your cap

00:15:07,930 --> 00:15:12,910
it also has a time limit of a five

00:15:10,300 --> 00:15:14,380
minute processing time so anything

00:15:12,910 --> 00:15:16,480
beyond that and it will automatically

00:15:14,380 --> 00:15:18,640
shut it down so there are things like

00:15:16,480 --> 00:15:20,530
that you just have to be aware of which

00:15:18,640 --> 00:15:22,570
will help you discern where in your

00:15:20,530 --> 00:15:24,630
logic to slice up the pieces to make it

00:15:22,570 --> 00:15:29,230
affordable and still be able to process

00:15:24,630 --> 00:15:32,320
so lambdas um you see what's next s3

00:15:29,230 --> 00:15:35,740
this is your object stores this is

00:15:32,320 --> 00:15:38,140
basically I'm mmm AWS makes it very

00:15:35,740 --> 00:15:39,460
distinct that it is not a static asset

00:15:38,140 --> 00:15:40,780
store it is an object store you

00:15:39,460 --> 00:15:43,840
basically could drop anything you want

00:15:40,780 --> 00:15:45,130
in there this is the one that has given

00:15:43,840 --> 00:15:46,750
us trouble with eventual consists

00:15:45,130 --> 00:15:49,300
see you just have to be aware of that

00:15:46,750 --> 00:15:51,310
and then we'll look at dynamodb this is

00:15:49,300 --> 00:15:55,120
our new seek no sequel store highly

00:15:51,310 --> 00:15:58,330
scalable incredibly fast connection

00:15:55,120 --> 00:16:00,490
speeds read speeds write speeds and then

00:15:58,330 --> 00:16:01,390
sqs the and the reason I threw these up

00:16:00,490 --> 00:16:03,550
on here is because these are the ones

00:16:01,390 --> 00:16:05,380
will actually talk through on a couple

00:16:03,550 --> 00:16:08,140
of the architectural diagrams that we'll

00:16:05,380 --> 00:16:09,550
look at in a moment so sqs is just what

00:16:08,140 --> 00:16:10,870
it sounds like it's a queueing service

00:16:09,550 --> 00:16:12,670
it's a hosted and managed queuing

00:16:10,870 --> 00:16:14,880
service you set it up and you start

00:16:12,670 --> 00:16:17,230
dropping items into it and then you can

00:16:14,880 --> 00:16:18,700
reach out to it and check to see if

00:16:17,230 --> 00:16:22,120
there's anything on the queue for you to

00:16:18,700 --> 00:16:24,940
resolve and it supports both standard

00:16:22,120 --> 00:16:26,140
queuing as well as 5o queuing so you can

00:16:24,940 --> 00:16:27,330
you can do a lot of different things

00:16:26,140 --> 00:16:29,920
with it

00:16:27,330 --> 00:16:33,880
so one of the examples I'm going to talk

00:16:29,920 --> 00:16:37,260
through is a problem space I ran into

00:16:33,880 --> 00:16:39,730
where we had a couple api's internally

00:16:37,260 --> 00:16:42,700
these were api's that had been spun up

00:16:39,730 --> 00:16:45,070
and as we all know there's no such thing

00:16:42,700 --> 00:16:47,290
as a proof-of-concept that stays a proof

00:16:45,070 --> 00:16:49,030
of concept any time you show it to

00:16:47,290 --> 00:16:51,250
somebody somebody starts using it and

00:16:49,030 --> 00:16:52,840
now you have to support it and we had

00:16:51,250 --> 00:16:55,320
several api's that had been built

00:16:52,840 --> 00:16:57,760
internally for different teams and a

00:16:55,320 --> 00:16:59,830
security audit came through and realized

00:16:57,760 --> 00:17:02,680
that we had multiple api's that had

00:16:59,830 --> 00:17:05,320
accessed the data that were not fronted

00:17:02,680 --> 00:17:06,970
with any type of authentication now good

00:17:05,320 --> 00:17:08,200
news is they were only on the internal

00:17:06,970 --> 00:17:10,810
network however they still were not

00:17:08,200 --> 00:17:13,270
fronted with authentication so we were

00:17:10,810 --> 00:17:18,670
tasked with figuring out a way to try

00:17:13,270 --> 00:17:20,920
and Front existing api's with basically

00:17:18,670 --> 00:17:23,020
an OAuth style authentication of some

00:17:20,920 --> 00:17:25,390
sort well we could give API keys out to

00:17:23,020 --> 00:17:27,070
only those who need access to it and we

00:17:25,390 --> 00:17:29,890
could do some type of token exchange to

00:17:27,070 --> 00:17:31,030
grant access into those api's so if

00:17:29,890 --> 00:17:32,950
you've ever done something like that

00:17:31,030 --> 00:17:34,600
before where you've had an existing API

00:17:32,950 --> 00:17:36,100
and you've had to try and put something

00:17:34,600 --> 00:17:39,700
in front of it it can be extremely

00:17:36,100 --> 00:17:42,580
challenging in this case we came up with

00:17:39,700 --> 00:17:46,150
something that worked decently well see

00:17:42,580 --> 00:17:48,310
if I can point over here essentially the

00:17:46,150 --> 00:17:49,840
goal is we have an application layer

00:17:48,310 --> 00:17:52,000
down here so this is something that was

00:17:49,840 --> 00:17:55,540
already existing okay the applications

00:17:52,000 --> 00:17:57,730
there the API is being hit but there's

00:17:55,540 --> 00:17:59,030
no security layer in front of it and so

00:17:57,730 --> 00:18:06,190
what we were able to do

00:17:59,030 --> 00:18:10,720
is take a right here the API gateway and

00:18:06,190 --> 00:18:13,460
set up a basically just an authorization

00:18:10,720 --> 00:18:16,190
password exchange so you can take your

00:18:13,460 --> 00:18:18,890
API key and your secret and you can hit

00:18:16,190 --> 00:18:20,840
an endpoint here that will reach out

00:18:18,890 --> 00:18:22,940
into the this is kind of where the

00:18:20,840 --> 00:18:25,550
application layer I guess from the the

00:18:22,940 --> 00:18:27,040
oauth thing that we created and there's

00:18:25,550 --> 00:18:30,710
a lambda here that's your Authenticator

00:18:27,040 --> 00:18:33,320
that really just checks your password if

00:18:30,710 --> 00:18:35,210
you're in the the API keys that have

00:18:33,320 --> 00:18:37,420
been granted it checks to make sure

00:18:35,210 --> 00:18:39,980
you've got the appropriate role it

00:18:37,420 --> 00:18:42,260
creates a new token it drops a token

00:18:39,980 --> 00:18:44,960
into another DB table and another dynamo

00:18:42,260 --> 00:18:47,900
table the reason we chose this

00:18:44,960 --> 00:18:51,350
architecture is DynamoDB tables allow

00:18:47,900 --> 00:18:54,500
you to specify a TTL on every item that

00:18:51,350 --> 00:18:56,480
you drop into the table and at that TTL

00:18:54,500 --> 00:18:58,520
it will auto expire that item and remove

00:18:56,480 --> 00:19:00,770
it from your table so for this solution

00:18:58,520 --> 00:19:03,260
it worked really well because if we had

00:19:00,770 --> 00:19:04,910
you know let's say we had five minutes

00:19:03,260 --> 00:19:06,830
oaken's and we only wanted them good for

00:19:04,910 --> 00:19:09,680
a certain amount of time we could drop

00:19:06,830 --> 00:19:11,000
them into our token table and they would

00:19:09,680 --> 00:19:12,260
auto expire in that amount of time we

00:19:11,000 --> 00:19:14,810
didn't have to do any manual cleanup

00:19:12,260 --> 00:19:17,180
which was fantastic in this case once

00:19:14,810 --> 00:19:19,100
that's done the Authenticator simply

00:19:17,180 --> 00:19:24,110
returns with the token that they just

00:19:19,100 --> 00:19:25,220
generated and the user or application

00:19:24,110 --> 00:19:27,890
whatever it is it's hitting the end

00:19:25,220 --> 00:19:30,560
point then can pick up that token pass

00:19:27,890 --> 00:19:33,380
it off to the API that they were trying

00:19:30,560 --> 00:19:35,240
to reach anyway and provide an

00:19:33,380 --> 00:19:37,970
authorization header with a bearer token

00:19:35,240 --> 00:19:40,250
on it that then fires off a secondary

00:19:37,970 --> 00:19:41,900
lambda that all it knows how to do is

00:19:40,250 --> 00:19:44,510
authorize the only thing this lambda

00:19:41,900 --> 00:19:46,910
does is it takes the header and it looks

00:19:44,510 --> 00:19:48,830
in here to see if it exists and if it

00:19:46,910 --> 00:19:50,530
has the appropriate scopes for you to

00:19:48,830 --> 00:19:55,160
execute what you're trying to execute an

00:19:50,530 --> 00:19:58,450
api gateway right here actually has a

00:19:55,160 --> 00:20:01,700
concept of authorizer and the authorizer

00:19:58,450 --> 00:20:07,010
basically says you can check your token

00:20:01,700 --> 00:20:09,260
you can build up an AWS what's the term

00:20:07,010 --> 00:20:10,700
lost my lost my train of thought but you

00:20:09,260 --> 00:20:12,870
basically build up your policy that's

00:20:10,700 --> 00:20:15,150
what it is that grants our denies

00:20:12,870 --> 00:20:16,950
as to what they're wanting and the API

00:20:15,150 --> 00:20:18,990
gateway will receive that policy and

00:20:16,950 --> 00:20:20,630
actually cache it at that layer so all

00:20:18,990 --> 00:20:22,920
subsequent requests that that endpoint

00:20:20,630 --> 00:20:25,110
will actually use the same policy that's

00:20:22,920 --> 00:20:26,790
been cached so you can actually replay

00:20:25,110 --> 00:20:28,440
tokens without having to overload the

00:20:26,790 --> 00:20:31,410
number of executions of your lambdas

00:20:28,440 --> 00:20:33,450
which ends up saving even more money so

00:20:31,410 --> 00:20:35,760
I get a jump ahead I just got got the

00:20:33,450 --> 00:20:37,650
signal here so application layer you end

00:20:35,760 --> 00:20:41,850
up doing the handoff once everything has

00:20:37,650 --> 00:20:44,120
been granted and you move forward this

00:20:41,850 --> 00:20:47,160
one I think is a little more

00:20:44,120 --> 00:20:48,840
approachable this is a full-on if we

00:20:47,160 --> 00:20:52,800
wanted to do something like a mailing

00:20:48,840 --> 00:20:54,540
list we could actually have the route 53

00:20:52,800 --> 00:20:57,390
layer the DNS resolution had an API

00:20:54,540 --> 00:21:01,260
gateway we can have the Gateway simply

00:20:57,390 --> 00:21:04,230
drop payloads into like a registration

00:21:01,260 --> 00:21:05,490
bucket so lambda can fire off mail great

00:21:04,230 --> 00:21:07,440
yo you wanted to register we're gonna

00:21:05,490 --> 00:21:10,200
drop drop your email address into a

00:21:07,440 --> 00:21:11,760
dynamo DB table and then you might have

00:21:10,200 --> 00:21:13,590
an administrator come in later and want

00:21:11,760 --> 00:21:14,910
to actually send an email and they can

00:21:13,590 --> 00:21:17,280
hit a different endpoint on the API

00:21:14,910 --> 00:21:19,320
gateway and it'll kick you over and

00:21:17,280 --> 00:21:20,610
build up a queue of all the emails that

00:21:19,320 --> 00:21:23,160
need to be sent and then you can process

00:21:20,610 --> 00:21:25,950
them however you like I want to jump

00:21:23,160 --> 00:21:31,170
real quick and see if I can do a quick

00:21:25,950 --> 00:21:34,820
demo or not so give me one moment I've

00:21:31,170 --> 00:21:34,820
got just a couple minutes here and

00:21:38,600 --> 00:21:43,890
alright so this is a whirlwind I will

00:21:41,760 --> 00:21:46,260
tell you now I'm going to probably have

00:21:43,890 --> 00:21:47,880
to cut this very short so if you have

00:21:46,260 --> 00:21:49,730
questions or you want to walk through

00:21:47,880 --> 00:21:51,870
this with me later please find me I'm

00:21:49,730 --> 00:21:53,040
happy to talk through as much of this as

00:21:51,870 --> 00:21:56,220
I can

00:21:53,040 --> 00:21:58,980
API gateway essentially allows you to

00:21:56,220 --> 00:22:01,290
just specify all of your endpoints like

00:21:58,980 --> 00:22:02,820
you would it's almost if you've used

00:22:01,290 --> 00:22:04,860
swagger or anything like that or or you

00:22:02,820 --> 00:22:09,600
use happy Jas or anything that where you

00:22:04,860 --> 00:22:11,610
can do a declarative style ap is or

00:22:09,600 --> 00:22:15,570
routes that's basically what we can do

00:22:11,610 --> 00:22:17,130
here and then you wire it up directly to

00:22:15,570 --> 00:22:19,080
a lambda so you've got up here you see

00:22:17,130 --> 00:22:21,690
the type as a lambda proxy on the

00:22:19,080 --> 00:22:24,060
integration request basically what that

00:22:21,690 --> 00:22:26,070
tells the api gateway to do is to do a

00:22:24,060 --> 00:22:27,570
little bit of pre-processing and

00:22:26,070 --> 00:22:29,760
create a context that's going to hand

00:22:27,570 --> 00:22:31,700
off to your lambda function and so then

00:22:29,760 --> 00:22:47,610
you write a little bit of node in your

00:22:31,700 --> 00:22:49,020
lambdas over here slow there we go if

00:22:47,610 --> 00:22:51,810
that loads that's great but there's some

00:22:49,020 --> 00:22:53,070
node it's just a function that accepts a

00:22:51,810 --> 00:22:54,720
context and some additional parameters

00:22:53,070 --> 00:22:56,070
depending on the type of lambda you want

00:22:54,720 --> 00:22:58,380
there's a lot more complexity I'm

00:22:56,070 --> 00:23:00,270
smoothing a little bit of it over but it

00:22:58,380 --> 00:23:01,860
gets handed of context from that context

00:23:00,270 --> 00:23:02,970
you can basically look at the payload

00:23:01,860 --> 00:23:04,470
that was parsed out you can look at the

00:23:02,970 --> 00:23:06,750
headers you can make all kinds of

00:23:04,470 --> 00:23:09,450
different decisions within your lambda

00:23:06,750 --> 00:23:11,940
of what to do further and so in this

00:23:09,450 --> 00:23:13,410
case I'm trying to load the email

00:23:11,940 --> 00:23:15,900
sending one in this case we would

00:23:13,410 --> 00:23:18,270
actually grab from dynamodb our entire

00:23:15,900 --> 00:23:20,340
list of emails that have been registered

00:23:18,270 --> 00:23:22,050
we would then take the body that was

00:23:20,340 --> 00:23:23,460
sent to us and we just kind of line them

00:23:22,050 --> 00:23:24,960
up together and send off an email to

00:23:23,460 --> 00:23:27,390
each one of the users so it's a really

00:23:24,960 --> 00:23:29,970
really rudimentary email management or

00:23:27,390 --> 00:23:32,910
marketing type thing but that's that's

00:23:29,970 --> 00:23:35,730
essentially all that there is in it is

00:23:32,910 --> 00:23:37,320
the ability to wire up your API directly

00:23:35,730 --> 00:23:39,150
into a lambda that knows how to process

00:23:37,320 --> 00:23:42,030
glean the data that's been dropped in

00:23:39,150 --> 00:23:45,810
from somewhere else so that never did

00:23:42,030 --> 00:23:50,070
load did it nope all right well come to

00:23:45,810 --> 00:23:52,200
be later well we'll run through it so

00:23:50,070 --> 00:23:54,150
again that's all this this diagram is

00:23:52,200 --> 00:23:56,490
showing in this case what I was doing is

00:23:54,150 --> 00:23:58,020
dropping it into a queue and SQS and

00:23:56,490 --> 00:24:00,120
then we'd be able to pull that queue and

00:23:58,020 --> 00:24:01,290
pull off the generated emails to send

00:24:00,120 --> 00:24:02,900
off you could have an iron port or

00:24:01,290 --> 00:24:08,250
something like that to actually process

00:24:02,900 --> 00:24:09,450
major email loads so besides that a

00:24:08,250 --> 00:24:11,550
little bit of homework there are

00:24:09,450 --> 00:24:13,380
multiple multiple multiple things to

00:24:11,550 --> 00:24:16,620
consider we have not talked about this

00:24:13,380 --> 00:24:18,540
is a very high level we have things like

00:24:16,620 --> 00:24:20,340
I am roles you've got security models

00:24:18,540 --> 00:24:22,890
you've got VPC for your private cloud

00:24:20,340 --> 00:24:24,510
you have Direct Connect which I did

00:24:22,890 --> 00:24:27,330
mention which lets you run things on

00:24:24,510 --> 00:24:30,000
your internal or business network so

00:24:27,330 --> 00:24:31,260
that you can actually control your

00:24:30,000 --> 00:24:33,060
security a little bit better or have

00:24:31,260 --> 00:24:36,360
security shared between internal and

00:24:33,060 --> 00:24:38,310
cloud applications if you're using my

00:24:36,360 --> 00:24:39,200
sequel Postgres something like that

00:24:38,310 --> 00:24:40,549
there are

00:24:39,200 --> 00:24:42,139
Frings to let you do that with your

00:24:40,549 --> 00:24:45,080
database and let them scale it or host

00:24:42,139 --> 00:24:46,250
it for you and again by them pretty much

00:24:45,080 --> 00:24:48,529
all the providers have this type of

00:24:46,250 --> 00:24:50,450
thing you've got caching layers you've

00:24:48,529 --> 00:24:52,730
got all kinds of different things you

00:24:50,450 --> 00:24:54,679
can use to to accent or complement the

00:24:52,730 --> 00:24:56,510
serverless offerings we've looked at to

00:24:54,679 --> 00:25:00,200
build out a much broader and more secure

00:24:56,510 --> 00:25:03,140
application so I just did the demo and

00:25:00,200 --> 00:25:09,119
so that's it thank you very much

00:25:03,140 --> 00:25:09,119

YouTube URL: https://www.youtube.com/watch?v=LFUnn-8IAjQ


