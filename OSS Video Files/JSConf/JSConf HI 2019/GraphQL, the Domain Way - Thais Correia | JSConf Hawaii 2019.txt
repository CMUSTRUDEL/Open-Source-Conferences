Title: GraphQL, the Domain Way - Thais Correia | JSConf Hawaii 2019
Publication date: 2019-06-24
Playlist: JSConf HI 2019
Description: 
	Thais Correia talks about how GraphQL allows teams to work with complex data by allowing them to focus on their domains of expertise.

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:05,650 --> 00:00:14,650
so hi folks I'm pleased how's everyone

00:00:10,000 --> 00:00:17,980
doing right now how how am i doing I'm

00:00:14,650 --> 00:00:19,570
doing okay thanks for asking oh no I'm

00:00:17,980 --> 00:00:22,840
actually really really stoked to be here

00:00:19,570 --> 00:00:25,239
because I love Hawaii I love going to

00:00:22,840 --> 00:00:28,090
the beach and surfing and doing things

00:00:25,239 --> 00:00:31,570
in the ocean this is me on a recent

00:00:28,090 --> 00:00:34,000
scuba trip here but a recreational

00:00:31,570 --> 00:00:35,620
diving doesn't really pay the bills so I

00:00:34,000 --> 00:00:38,800
do a little bit of software engineering

00:00:35,620 --> 00:00:42,280
on the side and my first engineering job

00:00:38,800 --> 00:00:45,730
was in 2015 where I worked at an unnamed

00:00:42,280 --> 00:00:47,079
company I'd been coding small things on

00:00:45,730 --> 00:00:49,390
my own like Neopets

00:00:47,079 --> 00:00:51,879
storefronts and myspace fiends since I

00:00:49,390 --> 00:00:53,469
was a teenager but this was my yeah who

00:00:51,879 --> 00:00:56,499
knew pets or once I moved from MySpace

00:00:53,469 --> 00:00:58,809
either way this is my first time working

00:00:56,499 --> 00:01:00,789
on a team and building a capital P

00:00:58,809 --> 00:01:03,339
product and this was also my first

00:01:00,789 --> 00:01:05,530
introduction to graph QL so show of

00:01:03,339 --> 00:01:09,070
hands how many people here have worked

00:01:05,530 --> 00:01:12,190
with graph QL before cool cool cool so

00:01:09,070 --> 00:01:15,520
yeah graph QL is a query language in an

00:01:12,190 --> 00:01:18,010
application it fits in the API layer

00:01:15,520 --> 00:01:21,640
much like rest does how many people here

00:01:18,010 --> 00:01:24,070
have worked with REST API s how many

00:01:21,640 --> 00:01:27,850
people here worked with graph QL before

00:01:24,070 --> 00:01:30,520
they ever worked with a REST API handle

00:01:27,850 --> 00:01:33,040
nice but yeah I still think it's unusual

00:01:30,520 --> 00:01:35,530
to have this experience of learning and

00:01:33,040 --> 00:01:37,720
working with graph QL first and I think

00:01:35,530 --> 00:01:40,120
that that early exposure set the

00:01:37,720 --> 00:01:42,100
foundation for how I view product

00:01:40,120 --> 00:01:45,270
development overall and this is a

00:01:42,100 --> 00:01:45,270
picture of me realizing that

00:01:48,079 --> 00:01:52,380
imagine if your first introduction to

00:01:50,579 --> 00:01:54,119
web development was through something

00:01:52,380 --> 00:01:55,770
like react and I'm sure that for many of

00:01:54,119 --> 00:01:58,500
you you don't even have to imagine that

00:01:55,770 --> 00:02:00,179
but you'd probably understand that that

00:01:58,500 --> 00:02:02,819
kind of introduction left a unique

00:02:00,179 --> 00:02:04,890
impression on you and it molded your way

00:02:02,819 --> 00:02:06,990
of thinking about web app development

00:02:04,890 --> 00:02:08,940
right and I think that that's the case

00:02:06,990 --> 00:02:12,930
with me and Graziella and product

00:02:08,940 --> 00:02:14,879
development as well so in the first

00:02:12,930 --> 00:02:17,160
engineering job I worked on recruiting

00:02:14,879 --> 00:02:20,099
products we built a suite of products

00:02:17,160 --> 00:02:22,200
and tools that our recruiters used to do

00:02:20,099 --> 00:02:23,940
their jobs in my sound kind of

00:02:22,200 --> 00:02:26,150
surprising but for a company of that

00:02:23,940 --> 00:02:29,099
size that recruits on that scale

00:02:26,150 --> 00:02:30,540
greenhouse just doesn't cut it so it's

00:02:29,099 --> 00:02:32,610
actually a cost saver to have an

00:02:30,540 --> 00:02:35,430
internal team building those tools for

00:02:32,610 --> 00:02:38,610
you and for recruiting that statement is

00:02:35,430 --> 00:02:40,500
true partly because of the scale that we

00:02:38,610 --> 00:02:42,480
were dealing with like more than a

00:02:40,500 --> 00:02:44,579
million candidates in our pool thousands

00:02:42,480 --> 00:02:46,410
of interviews every day hundreds of

00:02:44,579 --> 00:02:48,599
thousands of recruiting decisions that

00:02:46,410 --> 00:02:51,540
have to be made every day from resume

00:02:48,599 --> 00:02:54,299
reviews to final offers but that's also

00:02:51,540 --> 00:02:57,450
true because recruiting is an incredibly

00:02:54,299 --> 00:03:00,000
complex problem domain and what do I

00:02:57,450 --> 00:03:02,190
mean by complex problem domain let's

00:03:00,000 --> 00:03:04,950
define domain when I talk about domain

00:03:02,190 --> 00:03:07,500
I'm talking about the subject area for

00:03:04,950 --> 00:03:09,420
which you are building software so on my

00:03:07,500 --> 00:03:12,510
old team our domain was the tech

00:03:09,420 --> 00:03:14,850
recruiting space I had to understand how

00:03:12,510 --> 00:03:16,829
the industry sources candidates how

00:03:14,850 --> 00:03:19,200
often recruiters engage candidates and

00:03:16,829 --> 00:03:22,980
in what ways and how people prepare for

00:03:19,200 --> 00:03:25,530
interviews and a lot more and then what

00:03:22,980 --> 00:03:28,260
do I mean by complex it's important to

00:03:25,530 --> 00:03:31,349
differentiate complicated from complex

00:03:28,260 --> 00:03:33,750
complicated is about many rules and

00:03:31,349 --> 00:03:35,849
steps but predictable ones and getting

00:03:33,750 --> 00:03:38,750
predictable results from the same sets

00:03:35,849 --> 00:03:42,000
of inputs think like taxes software

00:03:38,750 --> 00:03:43,950
American taxes are super complicated but

00:03:42,000 --> 00:03:45,870
it can be simplified by pruning or

00:03:43,950 --> 00:03:48,510
consolidating steps and that's what the

00:03:45,870 --> 00:03:51,150
taxes software does but complex is

00:03:48,510 --> 00:03:53,639
different we can't easily turn a complex

00:03:51,150 --> 00:03:55,100
problem into a set of predictable rules

00:03:53,639 --> 00:03:58,660
to follow

00:03:55,100 --> 00:04:00,910
because complex problems are fuzzy

00:03:58,660 --> 00:04:03,700
relationship-driven and constantly

00:04:00,910 --> 00:04:06,160
evolving so by definition there's no

00:04:03,700 --> 00:04:08,500
solution to a complex problem like

00:04:06,160 --> 00:04:10,930
recruiting and trying to solve it once

00:04:08,500 --> 00:04:13,180
and for all is kind of misguided the

00:04:10,930 --> 00:04:15,310
best we can do is continuously manage it

00:04:13,180 --> 00:04:18,489
how do we manage a complex problem

00:04:15,310 --> 00:04:20,140
domain let's find out I worked on that

00:04:18,489 --> 00:04:22,450
team for a while and I learned a ton

00:04:20,140 --> 00:04:24,340
about the recruiting space a lot about

00:04:22,450 --> 00:04:26,380
graffiti whoa and a lot about product

00:04:24,340 --> 00:04:28,510
development and then I went to work at a

00:04:26,380 --> 00:04:30,730
small start-up whose tech stack was

00:04:28,510 --> 00:04:33,580
really similar to my old team except no

00:04:30,730 --> 00:04:35,320
graph QL and I sat in meetings and I

00:04:33,580 --> 00:04:38,770
read over a technical specs and things

00:04:35,320 --> 00:04:40,660
just felt different not worse because

00:04:38,770 --> 00:04:43,510
God forbid I say anyone technology is

00:04:40,660 --> 00:04:45,640
worse than another just different and

00:04:43,510 --> 00:04:47,440
the things we focused on were different

00:04:45,640 --> 00:04:49,660
the way we discuss problems was

00:04:47,440 --> 00:04:52,600
different and I think that that contrast

00:04:49,660 --> 00:04:55,060
shed a light on my past experience and

00:04:52,600 --> 00:04:57,040
helped me develop opinions on a product

00:04:55,060 --> 00:05:00,070
development within a complex product

00:04:57,040 --> 00:05:02,380
domain should look like I had an aha

00:05:00,070 --> 00:05:04,150
moment or more like a series of aha

00:05:02,380 --> 00:05:07,090
moments when I started to think about

00:05:04,150 --> 00:05:08,140
where this difference came from so I

00:05:07,090 --> 00:05:10,720
wanted to share some of those opinions

00:05:08,140 --> 00:05:14,590
with y'all in this talk called graph QL

00:05:10,720 --> 00:05:16,630
the domain way by the end of this talk I

00:05:14,590 --> 00:05:19,150
hope to convince you of this that graph

00:05:16,630 --> 00:05:20,560
2l gives product teams superpowers by

00:05:19,150 --> 00:05:23,290
letting them focus on their domain

00:05:20,560 --> 00:05:25,090
rather than their data and I also hope

00:05:23,290 --> 00:05:27,220
that you can learn something that will

00:05:25,090 --> 00:05:30,420
be helpful to you as a product developer

00:05:27,220 --> 00:05:33,790
even if you don't use graph QL yet

00:05:30,420 --> 00:05:35,230
let's do a high-level overview really

00:05:33,790 --> 00:05:36,910
grateful that Shawn showed you all some

00:05:35,230 --> 00:05:38,590
cool graphic UL stuff yesterday because

00:05:36,910 --> 00:05:41,890
it takes the pressure off of this part a

00:05:38,590 --> 00:05:44,320
little bit if I said us before graph 2 I

00:05:41,890 --> 00:05:47,500
was a query language it's also a runtime

00:05:44,320 --> 00:05:49,360
for fulfilling those queries so to be

00:05:47,500 --> 00:05:52,210
clear it's not a programming language

00:05:49,360 --> 00:05:54,220
and it's not a graph database in fact

00:05:52,210 --> 00:05:56,610
graph GL was pretty agnostic about both

00:05:54,220 --> 00:05:59,080
of these things there are graph QL

00:05:56,610 --> 00:06:02,550
implementations out there in JavaScript

00:05:59,080 --> 00:06:04,270
obviously but also ruby scala closure

00:06:02,550 --> 00:06:06,700
doesn't care what programming language

00:06:04,270 --> 00:06:08,590
you implement it in and you can use

00:06:06,700 --> 00:06:11,290
whichever and however many different

00:06:08,590 --> 00:06:13,360
data sources you want with it

00:06:11,290 --> 00:06:15,400
this graphic shows where graph QL sits

00:06:13,360 --> 00:06:17,680
as the API layer between all of your

00:06:15,400 --> 00:06:19,930
possible clients and all of your data

00:06:17,680 --> 00:06:22,240
sources it can talk to any kind of

00:06:19,930 --> 00:06:25,390
database micro-service a third party API

00:06:22,240 --> 00:06:27,550
it can act as a layer to a legacy system

00:06:25,390 --> 00:06:31,690
it can talk to another graph QL server

00:06:27,550 --> 00:06:33,400
or to an existing REST API the rest it's

00:06:31,690 --> 00:06:35,650
important to understand that graph QL

00:06:33,400 --> 00:06:37,930
doesn't replace your data layer concerns

00:06:35,650 --> 00:06:39,730
but it does let you decouple those

00:06:37,930 --> 00:06:42,820
concerns from your product domain

00:06:39,730 --> 00:06:45,400
concerns I'm gonna keep showing you some

00:06:42,820 --> 00:06:47,350
snippets of graph QL alongside the rest

00:06:45,400 --> 00:06:50,050
of this talks content but this is all we

00:06:47,350 --> 00:06:52,150
need to know to get started so changing

00:06:50,050 --> 00:06:53,980
teams got me curious about different

00:06:52,150 --> 00:06:56,110
product development philosophies out

00:06:53,980 --> 00:06:56,500
there and eventually I came across one

00:06:56,110 --> 00:06:59,110
called

00:06:56,500 --> 00:07:01,210
domain driven development I think that

00:06:59,110 --> 00:07:03,310
graph QL and domain driven development

00:07:01,210 --> 00:07:05,260
go really well with each other and

00:07:03,310 --> 00:07:07,360
hopefully you think so too by the end of

00:07:05,260 --> 00:07:09,150
this talk but even if you don't use

00:07:07,360 --> 00:07:12,580
graph QL if you're building software

00:07:09,150 --> 00:07:14,890
within a complex domain the principles

00:07:12,580 --> 00:07:17,170
of DDD can really help you collaborate

00:07:14,890 --> 00:07:20,590
better and build a better product for

00:07:17,170 --> 00:07:22,210
your user I want to talk about five

00:07:20,590 --> 00:07:23,890
strategies within domain driven

00:07:22,210 --> 00:07:26,680
development that I feel are most

00:07:23,890 --> 00:07:29,710
relevant to my own product development

00:07:26,680 --> 00:07:31,420
experience and to graph QL we'll go

00:07:29,710 --> 00:07:33,370
through each strategy one by one so

00:07:31,420 --> 00:07:36,190
don't worry if these go fast I just want

00:07:33,370 --> 00:07:38,290
to let you know what's coming the first

00:07:36,190 --> 00:07:40,960
strategy is finding the important parts

00:07:38,290 --> 00:07:44,380
of the problem second strategy

00:07:40,960 --> 00:07:48,100
oops second one is creating a model that

00:07:44,380 --> 00:07:50,650
solves that problem then we collaborate

00:07:48,100 --> 00:07:53,770
to using a shared language to build a

00:07:50,650 --> 00:07:56,050
better model we make sure to separate

00:07:53,770 --> 00:07:58,960
our domain logic from our infrastructure

00:07:56,050 --> 00:08:01,480
logic and we also make sure to clearly

00:07:58,960 --> 00:08:03,790
document all of our changes so let's go

00:08:01,480 --> 00:08:05,320
to the first strategy breaking down the

00:08:03,790 --> 00:08:07,090
problem that you're trying to solve and

00:08:05,320 --> 00:08:10,780
highlighting what the most important

00:08:07,090 --> 00:08:12,700
parts are even outside of DDD or using

00:08:10,780 --> 00:08:15,250
graph QL this is a pretty important part

00:08:12,700 --> 00:08:17,560
of software development right when you

00:08:15,250 --> 00:08:19,600
work within a complex domain there's a

00:08:17,560 --> 00:08:20,180
wealth of information but not all of it

00:08:19,600 --> 00:08:22,850
is rel

00:08:20,180 --> 00:08:24,470
to the problem at hand you can find

00:08:22,850 --> 00:08:26,389
where to put your focus by breaking down

00:08:24,470 --> 00:08:29,570
your problem and asking which parts

00:08:26,389 --> 00:08:31,520
deliver the most value building software

00:08:29,570 --> 00:08:33,649
is really expensive way to solve a

00:08:31,520 --> 00:08:36,020
problem and I think not everything

00:08:33,649 --> 00:08:37,820
merits a problem solution so a product

00:08:36,020 --> 00:08:40,880
solution I mean so it's important to be

00:08:37,820 --> 00:08:42,890
thoughtful about these things let's

00:08:40,880 --> 00:08:45,080
practice finding the important parts of

00:08:42,890 --> 00:08:46,190
a problem with a sample problem and by

00:08:45,080 --> 00:08:48,140
the way this is the problem that I made

00:08:46,190 --> 00:08:50,180
up I never worked on anything like this

00:08:48,140 --> 00:08:54,680
so don't come after me for exposing

00:08:50,180 --> 00:08:56,540
trade secrets or whatever on average 20%

00:08:54,680 --> 00:08:59,120
of our interviewers cancel their

00:08:56,540 --> 00:09:00,310
interview slot less than 24 hours before

00:08:59,120 --> 00:09:03,140
their scheduled interview

00:09:00,310 --> 00:09:05,480
this means that coordinators are rushing

00:09:03,140 --> 00:09:08,720
to fill slots and when they can't it's a

00:09:05,480 --> 00:09:12,230
really bad candidate experience I see

00:09:08,720 --> 00:09:15,410
two sub problems here problem a is that

00:09:12,230 --> 00:09:17,870
20% of interviewers cancel and problem B

00:09:15,410 --> 00:09:21,050
is coordinators have to drop everything

00:09:17,870 --> 00:09:22,790
and rush to find a fill-in which problem

00:09:21,050 --> 00:09:24,830
do you think we should solve with a

00:09:22,790 --> 00:09:28,130
product solution vote now on your phones

00:09:24,830 --> 00:09:29,930
okay now there's no voting but to know

00:09:28,130 --> 00:09:31,820
which is the right problem to solve

00:09:29,930 --> 00:09:33,500
you need to have domain knowledge which

00:09:31,820 --> 00:09:35,870
you can get by talking to domain experts

00:09:33,500 --> 00:09:38,450
so let's think about problem a for a

00:09:35,870 --> 00:09:40,339
little bit why do people cancel maybe

00:09:38,450 --> 00:09:43,160
they had a scheduling conflict

00:09:40,339 --> 00:09:45,350
maybe they got sick how much lower could

00:09:43,160 --> 00:09:47,690
we change this number realistically like

00:09:45,350 --> 00:09:50,089
maybe we can make it go from 20 percent

00:09:47,690 --> 00:09:51,589
to 10 percent so 10 percent of

00:09:50,089 --> 00:09:54,430
candidates would still have a really bad

00:09:51,589 --> 00:09:56,660
experience but what about so problem B

00:09:54,430 --> 00:09:59,420
coordinators have to rush to fill in

00:09:56,660 --> 00:10:01,520
interview slots at the last minute if we

00:09:59,420 --> 00:10:03,950
can make that process really easy or

00:10:01,520 --> 00:10:06,650
non-existent then it's okay for some

00:10:03,950 --> 00:10:08,570
interviewers to cancel so we can go and

00:10:06,650 --> 00:10:10,310
talk to an expert in our domain like an

00:10:08,570 --> 00:10:12,260
interview coordinator and ask what they

00:10:10,310 --> 00:10:14,570
think and they might say something like

00:10:12,260 --> 00:10:16,430
you know a lot of times people cancel

00:10:14,570 --> 00:10:18,770
because they're sick and we can't really

00:10:16,430 --> 00:10:20,540
do anything to change that I would

00:10:18,770 --> 00:10:23,060
rather just have a backup interviewer or

00:10:20,540 --> 00:10:26,000
a tool that makes it super easy to find

00:10:23,060 --> 00:10:30,230
one and now we know where to focus our

00:10:26,000 --> 00:10:31,030
product building acts efforts then the

00:10:30,230 --> 00:10:33,100
next step

00:10:31,030 --> 00:10:35,680
getting to work and designing a model

00:10:33,100 --> 00:10:37,570
that solves the problem it's easy for me

00:10:35,680 --> 00:10:40,090
as an engineer to start chasing a

00:10:37,570 --> 00:10:41,860
perfect abstraction so I have to try

00:10:40,090 --> 00:10:43,540
really hard to keep in mind the actual

00:10:41,860 --> 00:10:46,090
business need that this project

00:10:43,540 --> 00:10:48,580
addresses remember that we're building a

00:10:46,090 --> 00:10:50,080
product within a complex domain it's

00:10:48,580 --> 00:10:52,270
kind of a waste of time to try to build

00:10:50,080 --> 00:10:54,820
a perfect mapping between the real world

00:10:52,270 --> 00:10:57,310
and your API layer because by definition

00:10:54,820 --> 00:10:59,860
the complex domain we're working in is

00:10:57,310 --> 00:11:01,600
fuzzy and ever-changing so I think we

00:10:59,860 --> 00:11:03,760
just have to accept that we're not gonna

00:11:01,600 --> 00:11:06,340
reach domain model harmony and our best

00:11:03,760 --> 00:11:08,130
approach is to build an evolvable model

00:11:06,340 --> 00:11:11,110
that brings us that business value now

00:11:08,130 --> 00:11:13,570
and a good question to ask yourself here

00:11:11,110 --> 00:11:16,180
is what's the smallest possible change I

00:11:13,570 --> 00:11:17,680
can make to deliver this value to answer

00:11:16,180 --> 00:11:20,590
that question we need to know the

00:11:17,680 --> 00:11:22,450
current state of the world and this is

00:11:20,590 --> 00:11:24,490
where I want to introduce you all to a

00:11:22,450 --> 00:11:27,280
core concept in graph two I'll call the

00:11:24,490 --> 00:11:29,140
schema the schema is where you define

00:11:27,280 --> 00:11:31,780
all the data that is available to the

00:11:29,140 --> 00:11:34,570
client the basic building block is the

00:11:31,780 --> 00:11:36,420
type and a type can have fields and also

00:11:34,570 --> 00:11:39,010
relationships to other types the

00:11:36,420 --> 00:11:41,380
graphical schema is where you model your

00:11:39,010 --> 00:11:43,060
business domain so any important entity

00:11:41,380 --> 00:11:45,970
in your domain could be defined as a

00:11:43,060 --> 00:11:47,950
type on the schema here's an example of

00:11:45,970 --> 00:11:50,500
a type of the interview type written in

00:11:47,950 --> 00:11:52,180
schema definition language what's the

00:11:50,500 --> 00:11:55,030
shape of an interview type well it has

00:11:52,180 --> 00:11:57,370
an ID a start in an endtime a room that

00:11:55,030 --> 00:12:00,430
it's held in a status which could be

00:11:57,370 --> 00:12:01,630
like scheduled or completed it has an

00:12:00,430 --> 00:12:04,420
interview type which could be like a

00:12:01,630 --> 00:12:06,610
systems interview or front-end coding it

00:12:04,420 --> 00:12:08,560
also has relationships to other types

00:12:06,610 --> 00:12:11,500
that are defined elsewhere on the schema

00:12:08,560 --> 00:12:13,710
Canada interviewer interview and vie and

00:12:11,500 --> 00:12:16,300
the interview loop but it's a part of

00:12:13,710 --> 00:12:18,430
remember we were talking about how graph

00:12:16,300 --> 00:12:19,780
QL is like an abstraction layer over all

00:12:18,430 --> 00:12:22,630
of the places you want to get your data

00:12:19,780 --> 00:12:24,280
from I see the schema also as an

00:12:22,630 --> 00:12:26,530
abstraction but over your business

00:12:24,280 --> 00:12:28,420
domain and I found a really natural to

00:12:26,530 --> 00:12:30,640
use schema definition language in

00:12:28,420 --> 00:12:33,280
product development because the graph

00:12:30,640 --> 00:12:35,800
based system resembles my natural mental

00:12:33,280 --> 00:12:38,800
model for relationships between real

00:12:35,800 --> 00:12:40,870
world things and maybe someone who are

00:12:38,800 --> 00:12:43,500
looking at this and thinking how is this

00:12:40,870 --> 00:12:45,420
different from a database model the

00:12:43,500 --> 00:12:47,460
sir has to do with what we're focusing

00:12:45,420 --> 00:12:48,990
on when we're designing each when

00:12:47,460 --> 00:12:51,540
designing a database structure we care

00:12:48,990 --> 00:12:53,970
about things like consistency redundancy

00:12:51,540 --> 00:12:55,980
and efficiency on the back end when

00:12:53,970 --> 00:12:57,510
designing a graphic UL schema we care

00:12:55,980 --> 00:13:00,420
about the needs of our front-end client

00:12:57,510 --> 00:13:02,160
specifically when writing the schema

00:13:00,420 --> 00:13:04,590
it's definitely tempting to just

00:13:02,160 --> 00:13:06,810
recreate a 101 in mapping to your

00:13:04,590 --> 00:13:09,180
underlying database setup or to your

00:13:06,810 --> 00:13:11,580
existing REST API but by doing so you're

00:13:09,180 --> 00:13:13,970
introducing unnecessary complexity on

00:13:11,580 --> 00:13:16,290
the client side let's look at an example

00:13:13,970 --> 00:13:18,270
let's say this is the UI we're building

00:13:16,290 --> 00:13:21,150
floor please don't judge my design

00:13:18,270 --> 00:13:22,530
skills too harshly I get mistaken for a

00:13:21,150 --> 00:13:25,380
designer all the time but I definitely

00:13:22,530 --> 00:13:26,910
don't have those skills we want to

00:13:25,380 --> 00:13:28,980
display information about an interview

00:13:26,910 --> 00:13:30,960
loop namely we want to display the

00:13:28,980 --> 00:13:32,970
candidate name the job that they applied

00:13:30,960 --> 00:13:34,980
for and then a list of their interviews

00:13:32,970 --> 00:13:38,520
including their interviewers name and

00:13:34,980 --> 00:13:40,920
their feedback what would that look like

00:13:38,520 --> 00:13:42,930
if our graph UL types were just mappings

00:13:40,920 --> 00:13:45,330
to our database we'll start from the

00:13:42,930 --> 00:13:47,760
interview loop on the left is our domain

00:13:45,330 --> 00:13:49,620
style schema definition and on the right

00:13:47,760 --> 00:13:51,960
is our database style schema definition

00:13:49,620 --> 00:13:53,550
you'll see that the difference is that

00:13:51,960 --> 00:13:55,830
the relationships to other types are

00:13:53,550 --> 00:13:58,710
represented by string IDs instead of by

00:13:55,830 --> 00:14:01,680
the actual type so assuming we're gonna

00:13:58,710 --> 00:14:03,210
use our database style schema how does

00:14:01,680 --> 00:14:06,810
this affect the way that we write our

00:14:03,210 --> 00:14:09,510
client code buckle in this is what a

00:14:06,810 --> 00:14:11,640
query in graph QL looks like in this one

00:14:09,510 --> 00:14:14,790
we're giving some interview loop ID and

00:14:11,640 --> 00:14:16,860
asking for the IDS of the candidate the

00:14:14,790 --> 00:14:19,500
job requisition and all the interviews

00:14:16,860 --> 00:14:22,530
on the loop we stored those IDs and then

00:14:19,500 --> 00:14:24,120
we kick off some other queries we do

00:14:22,530 --> 00:14:27,000
three more queries to get the candidate

00:14:24,120 --> 00:14:28,589
name the job requisition title and then

00:14:27,000 --> 00:14:30,600
all the data that we need for each of

00:14:28,589 --> 00:14:32,280
the interviews and we're still not done

00:14:30,600 --> 00:14:33,570
because for each of those interviews we

00:14:32,280 --> 00:14:36,180
also need to get the interviewers name

00:14:33,570 --> 00:14:38,040
and then there's a bunch of code that we

00:14:36,180 --> 00:14:42,020
still have to write to parse this data

00:14:38,040 --> 00:14:44,910
and map it into the right format

00:14:42,020 --> 00:14:46,740
remember this is more complex than it

00:14:44,910 --> 00:14:48,570
needs to be because of our decision to

00:14:46,740 --> 00:14:51,180
make our graph QL schema map to our

00:14:48,570 --> 00:14:53,459
databases what would this look like if

00:14:51,180 --> 00:14:56,940
we design our schema to match our mental

00:14:53,459 --> 00:14:57,270
model instead if we wrote our schema

00:14:56,940 --> 00:14:59,340
tonight

00:14:57,270 --> 00:15:01,110
our mental model we can get exactly the

00:14:59,340 --> 00:15:04,020
data that we want in the shape that we

00:15:01,110 --> 00:15:06,180
want with just one request being able to

00:15:04,020 --> 00:15:08,190
write queries like this simplifies our

00:15:06,180 --> 00:15:10,170
work on the client by a lot and if we

00:15:08,190 --> 00:15:12,390
ran this query this would be the data

00:15:10,170 --> 00:15:14,580
that we get back we have our candidate

00:15:12,390 --> 00:15:16,140
Barack Obama who applied for a product

00:15:14,580 --> 00:15:18,360
engineer role and was interviewed by

00:15:16,140 --> 00:15:21,990
Michelle Obama which is not a conflict

00:15:18,360 --> 00:15:24,330
of interest at all don't worry after you

00:15:21,990 --> 00:15:25,950
get some initial ideas down it's time to

00:15:24,330 --> 00:15:27,930
work together with your team to make it

00:15:25,950 --> 00:15:30,150
good and for this part to go well

00:15:27,930 --> 00:15:32,640
everyone has to have a shared

00:15:30,150 --> 00:15:34,680
understanding of your domain and even

00:15:32,640 --> 00:15:36,960
more importantly an established shared

00:15:34,680 --> 00:15:40,110
language to talk about it with why is

00:15:36,960 --> 00:15:41,970
this part so important without a shared

00:15:40,110 --> 00:15:44,280
language collaboration between teams

00:15:41,970 --> 00:15:46,800
within a company is really inefficient

00:15:44,280 --> 00:15:48,990
you're gonna mix business jargon with

00:15:46,800 --> 00:15:50,670
technical jargon and everyone is just

00:15:48,990 --> 00:15:53,370
going to be constantly talking past each

00:15:50,670 --> 00:15:55,500
other without even realizing it having a

00:15:53,370 --> 00:15:57,750
shared language removes a large chunk of

00:15:55,500 --> 00:16:00,480
ambiguity and misinterpretation and it

00:15:57,750 --> 00:16:02,550
ultimately saves you time and especially

00:16:00,480 --> 00:16:04,950
when we're building for complex domains

00:16:02,550 --> 00:16:06,390
we need to iterate quickly to keep up

00:16:04,950 --> 00:16:08,160
with the ever-changing nature of our

00:16:06,390 --> 00:16:11,130
domain so we need those tight feedback

00:16:08,160 --> 00:16:13,500
loops so I take my text back and I set

00:16:11,130 --> 00:16:15,060
up a meeting actually I'm gonna call it

00:16:13,500 --> 00:16:17,490
a working session after Anna's talk

00:16:15,060 --> 00:16:19,440
yesterday I really like that I set up a

00:16:17,490 --> 00:16:22,770
working session with maybe one other

00:16:19,440 --> 00:16:25,260
engineer a p.m. a designer and a domain

00:16:22,770 --> 00:16:27,900
expert so my last job our domain experts

00:16:25,260 --> 00:16:30,210
were longtime recruiters and recruiting

00:16:27,900 --> 00:16:32,340
managers these are the people who have

00:16:30,210 --> 00:16:34,620
the most on-the-ground realistic

00:16:32,340 --> 00:16:36,240
knowledge of your domain so you're

00:16:34,620 --> 00:16:37,920
really doing yourself a disservice if

00:16:36,240 --> 00:16:39,930
you don't include them early in your

00:16:37,920 --> 00:16:40,740
development process I'm gonna say it

00:16:39,930 --> 00:16:42,450
again because I think it's really

00:16:40,740 --> 00:16:44,070
important talk to your domain experts

00:16:42,450 --> 00:16:46,080
like think right now who are your domain

00:16:44,070 --> 00:16:47,670
experts for the area that you work in

00:16:46,080 --> 00:16:51,320
and how can you include them in your

00:16:47,670 --> 00:16:53,760
development process more where were we

00:16:51,320 --> 00:16:55,560
okay we're in the working session we're

00:16:53,760 --> 00:16:58,800
collaborating on our proposed changes

00:16:55,560 --> 00:17:00,840
and in the session we talked about a lot

00:16:58,800 --> 00:17:03,360
of things but I wanted to share some

00:17:00,840 --> 00:17:06,000
concrete tips for building and

00:17:03,360 --> 00:17:07,260
maintaining a shared vocabulary or as

00:17:06,000 --> 00:17:08,120
it's called in domain driven development

00:17:07,260 --> 00:17:12,260
you

00:17:08,120 --> 00:17:14,720
kotas language first ensure that you

00:17:12,260 --> 00:17:17,209
only use one word for specific concept

00:17:14,720 --> 00:17:18,800
don't let domain experts and developers

00:17:17,209 --> 00:17:22,610
have two words that address the same

00:17:18,800 --> 00:17:25,309
thing second try to stay away from

00:17:22,610 --> 00:17:28,760
overloaded technical terms like service

00:17:25,309 --> 00:17:31,070
policy manager etc in your API layer

00:17:28,760 --> 00:17:33,460
words in your API layer should

00:17:31,070 --> 00:17:37,010
correspond to concepts in your domain

00:17:33,460 --> 00:17:39,800
third create and maintain a glossary of

00:17:37,010 --> 00:17:41,900
terms with explicit definitions this is

00:17:39,800 --> 00:17:43,700
something that you get basically for

00:17:41,900 --> 00:17:47,840
free with graph key well it's really

00:17:43,700 --> 00:17:49,490
cool and I'll show you how in a bit use

00:17:47,840 --> 00:17:52,429
terms from your shared language

00:17:49,490 --> 00:17:54,950
everywhere namespaces classes filenames

00:17:52,429 --> 00:17:56,660
properties method names you should also

00:17:54,950 --> 00:17:58,730
be able to find the same language that

00:17:56,660 --> 00:18:01,460
you use in your code in your support

00:17:58,730 --> 00:18:03,980
articles in your internal update emails

00:18:01,460 --> 00:18:06,860
in your product specs this is how you

00:18:03,980 --> 00:18:09,980
keep a shared language alive and useful

00:18:06,860 --> 00:18:11,660
by using it and then as you gain a

00:18:09,980 --> 00:18:13,970
deeper understanding of your business

00:18:11,660 --> 00:18:16,400
domain your shared language will evolve

00:18:13,970 --> 00:18:19,190
as well periodically refactor your code

00:18:16,400 --> 00:18:21,440
base to reflect this this is also

00:18:19,190 --> 00:18:23,510
something that's much easier to do in a

00:18:21,440 --> 00:18:26,240
typed and well-documented code base like

00:18:23,510 --> 00:18:28,100
one that uses graph QL and I know that

00:18:26,240 --> 00:18:31,070
this sounds like a lot of work but it's

00:18:28,100 --> 00:18:33,440
necessary work because there is always

00:18:31,070 --> 00:18:35,179
going to be some underlying model and if

00:18:33,440 --> 00:18:37,820
you're not putting conscious effort into

00:18:35,179 --> 00:18:40,280
building a useful and evolvable model

00:18:37,820 --> 00:18:42,980
then you're probably modeling garbage by

00:18:40,280 --> 00:18:44,840
accident this is the kind of upfront

00:18:42,980 --> 00:18:46,460
work that makes sure that you're solving

00:18:44,840 --> 00:18:48,230
the right problem that you have the

00:18:46,460 --> 00:18:49,730
correct assumptions about your domain

00:18:48,230 --> 00:18:51,440
and that you're not making some

00:18:49,730 --> 00:18:53,210
incorrect assumption into your model

00:18:51,440 --> 00:18:57,590
that's going to give you headaches for

00:18:53,210 --> 00:18:59,870
years to come another strategy in DDD is

00:18:57,590 --> 00:19:01,760
separating your business logic from your

00:18:59,870 --> 00:19:03,200
infrastructure logic and if you get

00:19:01,760 --> 00:19:06,210
nothing else from this talk here's a

00:19:03,200 --> 00:19:08,309
life hack for separating egg yolks

00:19:06,210 --> 00:19:10,679
and why is it important to keep these

00:19:08,309 --> 00:19:13,559
things separate not the egg yolks I mean

00:19:10,679 --> 00:19:15,570
the different logic types over time your

00:19:13,559 --> 00:19:17,399
product priorities change or your

00:19:15,570 --> 00:19:19,169
understanding of your product domain

00:19:17,399 --> 00:19:21,629
changes and so your product itself

00:19:19,169 --> 00:19:23,480
changes there's a regular cadence within

00:19:21,629 --> 00:19:26,220
which you add new features and whatnot

00:19:23,480 --> 00:19:28,619
at the same time as your company grows

00:19:26,220 --> 00:19:29,669
and it grows its user base you probably

00:19:28,619 --> 00:19:31,320
also will need to make some

00:19:29,669 --> 00:19:34,019
infrastructure changes to accommodate

00:19:31,320 --> 00:19:36,119
that but those are two separate things

00:19:34,019 --> 00:19:38,759
right you're changing product needs and

00:19:36,119 --> 00:19:41,490
then you're changing scale needs a lot

00:19:38,759 --> 00:19:43,679
of complexity in applications comes from

00:19:41,490 --> 00:19:45,389
these two things being entangled when we

00:19:43,679 --> 00:19:48,470
want them to be isolated so that they

00:19:45,389 --> 00:19:52,139
can grow and change at their own pace

00:19:48,470 --> 00:19:55,049
remember our good old schema graph QL

00:19:52,139 --> 00:19:56,580
has a special type called query this is

00:19:55,049 --> 00:19:59,340
a special type because it defines the

00:19:56,580 --> 00:20:01,110
entry point for all of your data for

00:19:59,340 --> 00:20:03,179
every type in our schema and for every

00:20:01,110 --> 00:20:05,249
field on every type we have to teach

00:20:03,179 --> 00:20:07,590
graph QL where that data actually lives

00:20:05,249 --> 00:20:09,990
and how to get it we do this in the

00:20:07,590 --> 00:20:12,509
resolvers and the resolvers are

00:20:09,990 --> 00:20:14,419
functions that tell graph QL where and

00:20:12,509 --> 00:20:16,559
how to resolve the types you've defined

00:20:14,419 --> 00:20:18,480
this is where you'd write the code that

00:20:16,559 --> 00:20:20,759
accesses your data source whatever it

00:20:18,480 --> 00:20:23,999
may be let's look at this example

00:20:20,759 --> 00:20:26,159
I wrote a MongoDB example but remember

00:20:23,999 --> 00:20:28,950
you can put logic to ask us anything in

00:20:26,159 --> 00:20:31,110
the resolvers in this example we have a

00:20:28,950 --> 00:20:33,749
query called all interviews that returns

00:20:31,110 --> 00:20:36,809
you guessed it all the interviews from a

00:20:33,749 --> 00:20:39,269
MongoDB document we also have a query

00:20:36,809 --> 00:20:41,309
called interviews by candidate that lets

00:20:39,269 --> 00:20:44,279
you filter the interviews using a

00:20:41,309 --> 00:20:46,259
candidate ID oh by the way if you like

00:20:44,279 --> 00:20:49,499
this editor theme amy webelo made it

00:20:46,259 --> 00:20:51,690
it's called fairy floss check it out as

00:20:49,499 --> 00:20:53,549
I said before a few times in domain

00:20:51,690 --> 00:20:55,139
driven development it's really important

00:20:53,549 --> 00:20:57,240
for the whole team to have a shared

00:20:55,139 --> 00:20:59,429
understanding of the business domain and

00:20:57,240 --> 00:21:01,559
a shared language to use when talking

00:20:59,429 --> 00:21:03,779
about it so you need to document

00:21:01,559 --> 00:21:05,249
everything and I know that everyone says

00:21:03,779 --> 00:21:07,710
this in like this really aspirational

00:21:05,249 --> 00:21:09,929
way but graphic you graph to out really

00:21:07,710 --> 00:21:11,639
does make this much easier because of

00:21:09,929 --> 00:21:14,879
the type system your domain is

00:21:11,639 --> 00:21:17,440
practically self documenting there's

00:21:14,879 --> 00:21:21,430
this really cool tool

00:21:17,440 --> 00:21:22,870
video playing yeah no is it yeah there's

00:21:21,430 --> 00:21:25,780
this really cool tool called graphical

00:21:22,870 --> 00:21:28,510
it's a sandbox for your graph QL schema

00:21:25,780 --> 00:21:31,810
and here I have a video of graphical

00:21:28,510 --> 00:21:34,060
over the github graph QL API if you want

00:21:31,810 --> 00:21:36,370
to try out graph QL this is a really

00:21:34,060 --> 00:21:38,560
good place to get started you can write

00:21:36,370 --> 00:21:41,050
and run arbitrary queries and get real

00:21:38,560 --> 00:21:42,880
data back and my favorite part is the

00:21:41,050 --> 00:21:45,310
documentation Explorer on the right

00:21:42,880 --> 00:21:46,720
where you can navigate and search

00:21:45,310 --> 00:21:49,120
through every type that you've defined

00:21:46,720 --> 00:21:52,090
in your schema including descriptions

00:21:49,120 --> 00:21:54,340
for every type a protip is you can make

00:21:52,090 --> 00:21:56,260
descriptions a required field for any

00:21:54,340 --> 00:21:59,620
new type in your schema and you've got

00:21:56,260 --> 00:22:01,660
built in documentation that way let's do

00:21:59,620 --> 00:22:03,790
a recap at the beginning of the talk I

00:22:01,660 --> 00:22:05,800
said that graph QL gives product team

00:22:03,790 --> 00:22:08,050
superpowers by letting them focus on

00:22:05,800 --> 00:22:10,510
their domain rather than their data and

00:22:08,050 --> 00:22:12,460
we've learned that this domain focused

00:22:10,510 --> 00:22:15,250
way of structuring your work is called

00:22:12,460 --> 00:22:17,050
domain driven development how our graph

00:22:15,250 --> 00:22:20,710
QL and domain driven development tied

00:22:17,050 --> 00:22:22,180
together one it's impossible for a

00:22:20,710 --> 00:22:24,340
schema designed to be an afterthought

00:22:22,180 --> 00:22:26,080
because for anything to work in your API

00:22:24,340 --> 00:22:27,970
you have to define it in your schema

00:22:26,080 --> 00:22:29,800
first and this forces you to think

00:22:27,970 --> 00:22:33,370
upfront about your schema and your

00:22:29,800 --> 00:22:35,860
domain graph based modeling feels really

00:22:33,370 --> 00:22:38,340
natural and speeds up development on the

00:22:35,860 --> 00:22:40,870
client side the schema definition

00:22:38,340 --> 00:22:43,330
reduces communication errors between

00:22:40,870 --> 00:22:45,070
teams because everyone is on the same

00:22:43,330 --> 00:22:48,030
page about what terms mean and what

00:22:45,070 --> 00:22:50,830
relationships between types look like

00:22:48,030 --> 00:22:53,440
you get built-in separation of concerns

00:22:50,830 --> 00:22:56,710
between your domain and your infra logic

00:22:53,440 --> 00:22:58,720
because of the resolvers and you get

00:22:56,710 --> 00:23:00,280
really nice documentation with very

00:22:58,720 --> 00:23:02,080
little extra effort because of the type

00:23:00,280 --> 00:23:06,370
system and the awesome tooling that's

00:23:02,080 --> 00:23:08,170
available in the graph QL ecosystem and

00:23:06,370 --> 00:23:10,390
after all of this maybe some of y'all

00:23:08,170 --> 00:23:12,910
are thinking it sounds like a lot of

00:23:10,390 --> 00:23:14,830
work and a lot of meetings and first of

00:23:12,910 --> 00:23:16,420
all yeah if you're not working in a

00:23:14,830 --> 00:23:19,140
complex problem domain this is

00:23:16,420 --> 00:23:21,280
definitely overkill but otherwise

00:23:19,140 --> 00:23:22,840
personally getting to work more

00:23:21,280 --> 00:23:24,730
collaboratively is one of the things

00:23:22,840 --> 00:23:28,300
that I love about working with graphs

00:23:24,730 --> 00:23:30,490
well and following DDD it's exposed me

00:23:28,300 --> 00:23:32,230
to new domains and new opportunities too

00:23:30,490 --> 00:23:34,059
about those domains so I got to

00:23:32,230 --> 00:23:35,890
understand the entire recruiting

00:23:34,059 --> 00:23:37,809
pipeline very in-depth and on my current

00:23:35,890 --> 00:23:40,510
job I've gotten to learn a bunch about

00:23:37,809 --> 00:23:43,120
political organizing how nonprofits run

00:23:40,510 --> 00:23:46,780
and a ton about text messages as a

00:23:43,120 --> 00:23:48,850
platform I also strongly believe that

00:23:46,780 --> 00:23:50,620
the best product engineering teams don't

00:23:48,850 --> 00:23:52,660
just use the most cutting-edge tech or

00:23:50,620 --> 00:23:55,030
focus on building pristine code bases

00:23:52,660 --> 00:23:57,070
they also think and care deeply about

00:23:55,030 --> 00:23:59,920
their products their users and their

00:23:57,070 --> 00:24:02,740
domain if you want to learn more about

00:23:59,920 --> 00:24:05,140
DDD Eric Evans's domain driven design is

00:24:02,740 --> 00:24:06,940
the canonical text and I also use

00:24:05,140 --> 00:24:10,330
patterns principles and practices of

00:24:06,940 --> 00:24:12,790
domain driven design aka the PPP of DDD

00:24:10,330 --> 00:24:14,500
and if you'd like to hear more about

00:24:12,790 --> 00:24:17,350
graph QL and domain driven design

00:24:14,500 --> 00:24:19,870
specifically this talk by mark Andre

00:24:17,350 --> 00:24:21,610
zero from graph QL Summit last year is

00:24:19,870 --> 00:24:23,890
really good and also talks about it and

00:24:21,610 --> 00:24:25,780
finally Emily Griffin made those

00:24:23,890 --> 00:24:27,550
adorable illustrations you can find her

00:24:25,780 --> 00:24:29,350
on Twitter at Emily with curls

00:24:27,550 --> 00:24:31,090
you should totally Commission her to do

00:24:29,350 --> 00:24:32,300
art for your next talk so that's it

00:24:31,090 --> 00:24:35,950
thanks everyone

00:24:32,300 --> 00:24:35,950
[Applause]

00:24:36,120 --> 00:24:38,180

YouTube URL: https://www.youtube.com/watch?v=UM-RhglTyKA


