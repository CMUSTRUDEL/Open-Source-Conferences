Title: Bubble Up Your Node.JS I O - Matteo Collina | JSConf Hawaii 2019
Publication date: 2019-06-16
Playlist: JSConf HI 2019
Description: 
	Mateo Collina talks about how to improve your JavaScript I/O performance and reliability by thinking about async operations as...bubbles?!?

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:05,650 --> 00:00:09,970
so that's my head Twitter and all add

00:00:08,260 --> 00:00:13,380
materially nough please ask me questions

00:00:09,970 --> 00:00:14,769
whatever I replied most of the time so

00:00:13,380 --> 00:00:16,779
I'm going to

00:00:14,769 --> 00:00:18,939
to talk about the no dial you might ask

00:00:16,779 --> 00:00:21,340
why not' well I am part of the nodejs

00:00:18,939 --> 00:00:23,020
technical steering committee so whatever

00:00:21,340 --> 00:00:27,029
a lot of things no J yes if you have

00:00:23,020 --> 00:00:30,730
questions about north core thing me so

00:00:27,029 --> 00:00:31,899
I'm also a principal ocular the near

00:00:30,730 --> 00:00:33,250
forum we are a professional service

00:00:31,899 --> 00:00:35,079
company

00:00:33,250 --> 00:00:37,059
distributed all around the globe but

00:00:35,079 --> 00:00:38,620
business in Ireland whatever if you need

00:00:37,059 --> 00:00:42,700
us we are there check it out check us

00:00:38,620 --> 00:00:44,920
out also another little bit of intro

00:00:42,700 --> 00:00:46,570
there is these lights if you have a

00:00:44,920 --> 00:00:47,860
laptop there are some interactive

00:00:46,570 --> 00:00:50,320
visualizations so if you have a laptop

00:00:47,860 --> 00:00:51,579
out and you want to play with them these

00:00:50,320 --> 00:00:55,780
are these lights you can take a picture

00:00:51,579 --> 00:00:59,649
whatever whatever you want so let's get

00:00:55,780 --> 00:01:01,630
started when everybody starts with note

00:00:59,649 --> 00:01:05,110
they start with a very simple question

00:01:01,630 --> 00:01:06,909
how to debug a synchronous activity you

00:01:05,110 --> 00:01:08,860
know you have a socket coming in on an

00:01:06,909 --> 00:01:13,960
HTTP request coming in and you want to

00:01:08,860 --> 00:01:16,360
react to to those activity and you know

00:01:13,960 --> 00:01:18,100
what everybody does oh well I can use

00:01:16,360 --> 00:01:20,590
the inspector protocol the expector

00:01:18,100 --> 00:01:21,369
chrome inspector and I just laughs yeah

00:01:20,590 --> 00:01:23,889
more or less

00:01:21,369 --> 00:01:28,780
but what if we have 10 concurrent

00:01:23,889 --> 00:01:30,609
requests a hundred how can i debug an

00:01:28,780 --> 00:01:34,029
application running in production where

00:01:30,609 --> 00:01:35,409
i have a lot of concurrency in place in

00:01:34,029 --> 00:01:38,100
other I came from the Java world

00:01:35,409 --> 00:01:40,899
whatever I've done this and I've said it

00:01:38,100 --> 00:01:42,579
you could stop a thread single try than

00:01:40,899 --> 00:01:47,439
just debug that you can't do that in

00:01:42,579 --> 00:01:49,270
node so most of the stuff is because no

00:01:47,439 --> 00:01:50,950
js' is based on a concept called the

00:01:49,270 --> 00:01:54,189
ever loop and you'll probably are

00:01:50,950 --> 00:01:55,420
familiar with the node event loop okay

00:01:54,189 --> 00:01:59,950
how many of you think you are familiar

00:01:55,420 --> 00:02:04,899
with a node event loop okay how many of

00:01:59,950 --> 00:02:07,509
you I've seen this less people this is

00:02:04,899 --> 00:02:10,660
this the secret sauce okay that's the

00:02:07,509 --> 00:02:12,940
most Aiden piece of node lore that you

00:02:10,660 --> 00:02:15,459
can find took six months to write that

00:02:12,940 --> 00:02:17,709
guide please read it if you want to know

00:02:15,459 --> 00:02:20,319
more about our node works and this is on

00:02:17,709 --> 00:02:22,150
that node event loop works probably not

00:02:20,319 --> 00:02:26,920
really easy to understand so let's

00:02:22,150 --> 00:02:28,720
switch to a more easy to understand

00:02:26,920 --> 00:02:31,270
version because Pro

00:02:28,720 --> 00:02:35,350
a little bit more clear to everybody so

00:02:31,270 --> 00:02:37,990
when the JavaScript is execute the only

00:02:35,350 --> 00:02:42,070
thing that a node application does when

00:02:37,990 --> 00:02:44,200
at least two i/o it talked to the kernel

00:02:42,070 --> 00:02:47,080
a single barrier or the thread pool and

00:02:44,200 --> 00:02:49,750
says when this event happens when this

00:02:47,080 --> 00:02:52,060
condition happens please call back call

00:02:49,750 --> 00:02:55,680
a function when these finishes that's

00:02:52,060 --> 00:02:58,570
the only thing that that node does and

00:02:55,680 --> 00:03:01,030
it is specified in passing a JavaScript

00:02:58,570 --> 00:03:03,610
function and you know some event happens

00:03:01,030 --> 00:03:06,790
like you are receiving some data from a

00:03:03,610 --> 00:03:08,680
socket and that it calls back and then

00:03:06,790 --> 00:03:12,850
wants to call that function how does

00:03:08,680 --> 00:03:14,830
that happen that is let's see whoa there

00:03:12,850 --> 00:03:17,680
is an event queue here and the event

00:03:14,830 --> 00:03:22,480
queue means that all the functions are

00:03:17,680 --> 00:03:25,990
processed one at a time so just to

00:03:22,480 --> 00:03:28,180
repeat the dusky primetime specify a

00:03:25,990 --> 00:03:31,180
fare other function as a listener to

00:03:28,180 --> 00:03:34,690
some IO event and then the yo event

00:03:31,180 --> 00:03:37,930
happens and the function is called but

00:03:34,690 --> 00:03:40,000
you know that is one caller ID to all of

00:03:37,930 --> 00:03:41,920
this we have only one function executing

00:03:40,000 --> 00:03:44,470
again a given time and this is one of

00:03:41,920 --> 00:03:47,019
the key tenants of any nodejs

00:03:44,470 --> 00:03:49,150
and in ojs function now you might ask

00:03:47,019 --> 00:03:50,680
why all of this matter when doing a

00:03:49,150 --> 00:03:54,250
synchronous activity would it make these

00:03:50,680 --> 00:03:56,620
things simpler yes and now it makes

00:03:54,250 --> 00:03:59,760
things simpler to code however there is

00:03:56,620 --> 00:04:03,100
one key piece that is a little bit

00:03:59,760 --> 00:04:07,540
obscure which knowing which code is

00:04:03,100 --> 00:04:10,810
running relative to one another also

00:04:07,540 --> 00:04:13,510
what about next ik promises and set

00:04:10,810 --> 00:04:15,700
immediate now which one will run first

00:04:13,510 --> 00:04:18,790
if you schedule a promise if you run a

00:04:15,700 --> 00:04:21,310
promise if you do next ik or if you do

00:04:18,790 --> 00:04:23,169
set immediate you know I'm not throwing

00:04:21,310 --> 00:04:27,430
set timeout zero in there because that's

00:04:23,169 --> 00:04:29,440
even trickier so next it are always

00:04:27,430 --> 00:04:33,310
executed before

00:04:29,440 --> 00:04:36,669
promises are resolved and before any

00:04:33,310 --> 00:04:38,380
other are your events promises are if

00:04:36,669 --> 00:04:40,990
you do new promise the function is

00:04:38,380 --> 00:04:42,249
executed synchronously but then resolve

00:04:40,990 --> 00:04:47,169
are synchronously

00:04:42,249 --> 00:04:49,659
and before any other are your events set

00:04:47,169 --> 00:04:52,959
immediate instead exercise the full

00:04:49,659 --> 00:04:55,419
event loop that we told you that we've

00:04:52,959 --> 00:04:56,859
told you you know and I've not thrown in

00:04:55,419 --> 00:04:59,129
setting itself time Abdera because

00:04:56,859 --> 00:05:01,929
that's another level of complication so

00:04:59,129 --> 00:05:05,169
again the artist piece of information

00:05:01,929 --> 00:05:07,869
that the thing that when a newbie starts

00:05:05,169 --> 00:05:10,029
working with node is to know when a

00:05:07,869 --> 00:05:14,229
chunk of code is executed relative to

00:05:10,029 --> 00:05:17,319
one another so going back to the

00:05:14,229 --> 00:05:19,119
question how to debug multiple

00:05:17,319 --> 00:05:20,679
asynchronous activity how do we do this

00:05:19,119 --> 00:05:22,839
because you know we have multiple things

00:05:20,679 --> 00:05:25,239
happening how do we we have a bad bug

00:05:22,839 --> 00:05:26,799
and that is happening only when I'm

00:05:25,239 --> 00:05:29,589
calling three different routes at the

00:05:26,799 --> 00:05:31,419
same time and the moon is aligning and

00:05:29,589 --> 00:05:34,809
Mars is over there I don't know

00:05:31,419 --> 00:05:36,729
it really gets complicated and I don't

00:05:34,809 --> 00:05:40,299
understand what what is happening it

00:05:36,729 --> 00:05:42,369
here it's very hard so it goes back to

00:05:40,299 --> 00:05:43,839
to a problem and something that we're

00:05:42,369 --> 00:05:47,159
missing in JavaScript which is the

00:05:43,839 --> 00:05:50,799
concept of the synchronous context so

00:05:47,159 --> 00:05:53,289
let's look at a bad very basic HTTP

00:05:50,799 --> 00:05:55,899
server written in ojs and you can see

00:05:53,289 --> 00:05:58,419
that we do our HTTP create server and we

00:05:55,899 --> 00:06:01,029
pass in a function this function in fact

00:05:58,419 --> 00:06:03,849
when we receive an HTTP request from a

00:06:01,029 --> 00:06:05,110
browser you have a new logical a

00:06:03,849 --> 00:06:07,029
synchronous context that is being

00:06:05,110 --> 00:06:08,769
created which means you know this is

00:06:07,029 --> 00:06:11,289
your transaction this is your HTTP

00:06:08,769 --> 00:06:14,289
request and response this is a logical

00:06:11,289 --> 00:06:16,179
concept that is living in there okay all

00:06:14,289 --> 00:06:19,360
the things that the Sun from this one

00:06:16,179 --> 00:06:22,719
will be you know linked one with another

00:06:19,360 --> 00:06:24,759
mainly because they are part of the same

00:06:22,719 --> 00:06:26,829
closure you see it's a closure created

00:06:24,759 --> 00:06:28,629
here so they are part of the same

00:06:26,829 --> 00:06:32,669
closure and then when I create another

00:06:28,629 --> 00:06:35,589
closure you know it's in here okay and

00:06:32,669 --> 00:06:39,610
and the context is being the response is

00:06:35,589 --> 00:06:43,269
being propagated just by using that so

00:06:39,610 --> 00:06:45,039
it's really powerful right however there

00:06:43,269 --> 00:06:47,259
is no concept of a synchronous context

00:06:45,039 --> 00:06:49,569
in the JavaScript language so you know

00:06:47,259 --> 00:06:51,550
it's something that is built in into our

00:06:49,569 --> 00:06:54,789
browser works and how the event loop

00:06:51,550 --> 00:06:56,340
works but there is no way to control in

00:06:54,789 --> 00:06:58,420
any

00:06:56,340 --> 00:07:00,940
reflection oriented way this type of

00:06:58,420 --> 00:07:02,920
things so it's completely illogical

00:07:00,940 --> 00:07:04,960
contest construct but is not a language

00:07:02,920 --> 00:07:07,090
not a language feature there is some

00:07:04,960 --> 00:07:08,950
work in making this a reality where

00:07:07,090 --> 00:07:10,690
there is actually a concept in the

00:07:08,950 --> 00:07:12,010
language pack and some of the wall you

00:07:10,690 --> 00:07:14,550
can find some of the work done by the

00:07:12,010 --> 00:07:17,200
Diagnostics working group in no js'

00:07:14,550 --> 00:07:19,210
check it out and this goes a little bit

00:07:17,200 --> 00:07:23,800
into the deep depth of this and it's

00:07:19,210 --> 00:07:27,220
really really interesting to read then

00:07:23,800 --> 00:07:31,600
well if there is no concept of seamless

00:07:27,220 --> 00:07:33,490
context how can we track IO events so

00:07:31,600 --> 00:07:36,370
how can we know when things happen you

00:07:33,490 --> 00:07:38,230
know this is a thing called a Singh

00:07:36,370 --> 00:07:41,110
cooks you're probably heard about a

00:07:38,230 --> 00:07:44,500
Singh cooks in the past and it's one of

00:07:41,110 --> 00:07:47,130
those you know new features of not Jas

00:07:44,500 --> 00:07:49,390
that do that can do great things also

00:07:47,130 --> 00:07:51,850
you know there are somewhat hard to use

00:07:49,390 --> 00:07:54,460
this is an example of using them this

00:07:51,850 --> 00:07:55,260
actually real real code can you

00:07:54,460 --> 00:08:00,580
understand what it does

00:07:55,260 --> 00:08:02,320
well it's complex and it also generates

00:08:00,580 --> 00:08:04,660
a lot of data and I'm not going to

00:08:02,320 --> 00:08:08,350
explain it because it's a really big

00:08:04,660 --> 00:08:09,880
that conversation so myself and my team

00:08:08,350 --> 00:08:12,160
we have work force each month trying to

00:08:09,880 --> 00:08:15,340
make sense about all the stuff and how

00:08:12,160 --> 00:08:16,870
to provide a way to reason about the

00:08:15,340 --> 00:08:19,060
synchronous context and their

00:08:16,870 --> 00:08:21,160
synchronous activity in node J yes so

00:08:19,060 --> 00:08:23,500
you know and when you have this type of

00:08:21,160 --> 00:08:25,120
question the best way to attack these

00:08:23,500 --> 00:08:25,990
problems you know I am a software

00:08:25,120 --> 00:08:29,979
engineer okay

00:08:25,990 --> 00:08:33,339
by trade whatever so you know you go oh

00:08:29,979 --> 00:08:35,620
well you ask a designer sorry we can't

00:08:33,339 --> 00:08:37,960
do this so I ask we ask I ask a designer

00:08:35,620 --> 00:08:39,310
hey can you please sit down with a

00:08:37,960 --> 00:08:42,000
little bit of a design workshop whatever

00:08:39,310 --> 00:08:44,650
to figure this out turns out that they

00:08:42,000 --> 00:08:47,190
they answer to the question on how to

00:08:44,650 --> 00:08:53,140
visualize the synchronous activity is

00:08:47,190 --> 00:08:56,410
bubbles so bubbles yeah that's it so

00:08:53,140 --> 00:08:59,770
let's make an example we have we have a

00:08:56,410 --> 00:09:01,839
nice very tiny piece of ass off code

00:08:59,770 --> 00:09:05,230
here okay it's the same server that we

00:09:01,839 --> 00:09:08,899
were talking about before you so we go

00:09:05,230 --> 00:09:12,470
to all our lights so hey so we go to our

00:09:08,899 --> 00:09:14,389
so we are here and we have that code now

00:09:12,470 --> 00:09:17,180
we can use this tool called bubble probe

00:09:14,389 --> 00:09:18,529
and this part of a sweet code clinic you

00:09:17,180 --> 00:09:20,869
might check it out late this is critter

00:09:18,529 --> 00:09:22,369
linked and autocannon is a tool to

00:09:20,869 --> 00:09:24,079
generate some load so we are putting in

00:09:22,369 --> 00:09:27,050
a thousand requests just to spice things

00:09:24,079 --> 00:09:28,999
up to know where things behave in

00:09:27,050 --> 00:09:33,439
production and basically you run on your

00:09:28,999 --> 00:09:34,970
code not probably I've typed yeah you we

00:09:33,439 --> 00:09:36,740
run our code now you can see that

00:09:34,970 --> 00:09:38,509
autocannon is pinning things up a little

00:09:36,740 --> 00:09:42,740
bit and running a little bit of those

00:09:38,509 --> 00:09:44,600
requests and it's basically now

00:09:42,740 --> 00:09:46,819
generating our visualization take some

00:09:44,600 --> 00:09:50,720
time you know this machine is not

00:09:46,819 --> 00:09:54,019
powerful at all and this is a bubble

00:09:50,720 --> 00:09:56,269
prof diagram now I'm zooming in and so

00:09:54,019 --> 00:09:58,189
what we can see on on the right side is

00:09:56,269 --> 00:10:01,639
the number of a synchronous operation

00:09:58,189 --> 00:10:03,129
being done of by this system and you can

00:10:01,639 --> 00:10:06,079
see that it's doing you know we have

00:10:03,129 --> 00:10:09,999
twelve thousand a synchronous resource

00:10:06,079 --> 00:10:13,399
being created by running a thousand

00:10:09,999 --> 00:10:16,100
requests in no Jaya's does this app help

00:10:13,399 --> 00:10:17,720
anybody maybe yes maybe no the key

00:10:16,100 --> 00:10:20,120
important part are blue a further down

00:10:17,720 --> 00:10:22,519
we can start from the root so when the

00:10:20,120 --> 00:10:23,809
root this is the root node and represent

00:10:22,519 --> 00:10:27,019
the starting point of your application

00:10:23,809 --> 00:10:29,720
yeah then we can go deep and you know

00:10:27,019 --> 00:10:32,179
see the first part and the first part in

00:10:29,720 --> 00:10:34,579
fact it's on line 20 of our application

00:10:32,179 --> 00:10:38,149
basic dodge is whatever it is and it's

00:10:34,579 --> 00:10:41,870
alcohol to server dot listen our server

00:10:38,149 --> 00:10:43,819
is starting to listen on stuff still

00:10:41,870 --> 00:10:45,670
this is not helping me and again knowing

00:10:43,819 --> 00:10:49,399
what is happening in my node application

00:10:45,670 --> 00:10:51,259
so the next part it's this big block

00:10:49,399 --> 00:10:53,480
here which is a bunch of and network

00:10:51,259 --> 00:10:55,670
activity which is you can see it in in

00:10:53,480 --> 00:10:57,679
green and this bunch of network activity

00:10:55,670 --> 00:11:01,399
it's there's some bunch of antifreeze

00:10:57,679 --> 00:11:03,079
these are not core stuff but then we

00:11:01,399 --> 00:11:05,209
have a bunch of another node core stuff

00:11:03,079 --> 00:11:08,179
which come from how we receive a TCP

00:11:05,209 --> 00:11:09,559
connection in node.js itself so you know

00:11:08,179 --> 00:11:11,779
that you are receiving a TCP connection

00:11:09,559 --> 00:11:13,670
on J yes when you receive an HTTP

00:11:11,779 --> 00:11:18,679
request you got an HD a TCP connection

00:11:13,670 --> 00:11:20,259
being open after this you after this you

00:11:18,679 --> 00:11:22,920
actually the key part of our application

00:11:20,259 --> 00:11:27,180
which is our

00:11:22,920 --> 00:11:28,950
set time out now you know you see that

00:11:27,180 --> 00:11:31,860
is a set time out happening here and you

00:11:28,950 --> 00:11:33,390
see a fork and you can ask wise is there

00:11:31,860 --> 00:11:35,040
a fork now you can see two things first

00:11:33,390 --> 00:11:36,930
of all the execution continued on the

00:11:35,040 --> 00:11:38,339
left because there's a big Harrow that

00:11:36,930 --> 00:11:40,560
will give you a hint that the execution

00:11:38,339 --> 00:11:43,560
continued on the left but our execution

00:11:40,560 --> 00:11:46,200
force white force well on the right you

00:11:43,560 --> 00:11:51,209
can see that you know it start a set

00:11:46,200 --> 00:11:57,209
timeout okay on the right but then on on

00:11:51,209 --> 00:12:01,860
the left its when it's our promise dot

00:11:57,209 --> 00:12:06,360
then okay which the resolution of the

00:12:01,860 --> 00:12:08,100
promise itself so it it is and there is

00:12:06,360 --> 00:12:10,529
a tiny bit of thing in the middle of

00:12:08,100 --> 00:12:14,160
North core bits and bobs where things

00:12:10,529 --> 00:12:16,980
are you know executed so so you know

00:12:14,160 --> 00:12:18,720
these things is clear enough and we have

00:12:16,980 --> 00:12:21,420
a bunch of stuff that not core does when

00:12:18,720 --> 00:12:23,750
it finishes and you know it's for

00:12:21,420 --> 00:12:26,579
example in here we are calling a

00:12:23,750 --> 00:12:29,100
responsible end which is where we send

00:12:26,579 --> 00:12:31,140
our response back to the user so we were

00:12:29,100 --> 00:12:32,880
talking this okay no these I understand

00:12:31,140 --> 00:12:33,870
is this is matching which matches my

00:12:32,880 --> 00:12:36,079
understanding

00:12:33,870 --> 00:12:39,300
now let's pile things up a little bit

00:12:36,079 --> 00:12:41,940
now let's do a little quick refactoring

00:12:39,300 --> 00:12:43,260
on this system and well if you are

00:12:41,940 --> 00:12:45,089
following there is the full name of this

00:12:43,260 --> 00:12:47,459
thing the generator one let's switch to

00:12:45,089 --> 00:12:50,550
the sink oh wait when I think about

00:12:47,459 --> 00:12:52,649
version this is function is that

00:12:50,550 --> 00:12:54,600
function J functionally equivalent to

00:12:52,649 --> 00:12:57,630
the previous one note that we are using

00:12:54,600 --> 00:12:58,529
dot catch always put a dot catch when

00:12:57,630 --> 00:13:01,320
you're doing these type of things

00:12:58,529 --> 00:13:03,450
because otherwise you will leak file

00:13:01,320 --> 00:13:06,839
descriptor and you know make popcorn of

00:13:03,450 --> 00:13:08,730
your servers so I don't do that

00:13:06,839 --> 00:13:13,529
put a catch here and when you're calling

00:13:08,730 --> 00:13:16,050
promises so you need you know we are

00:13:13,529 --> 00:13:18,740
doing this so let's try let's see if

00:13:16,050 --> 00:13:22,680
it's the same as before

00:13:18,740 --> 00:13:25,740
how many people think is the same how

00:13:22,680 --> 00:13:27,730
many people 60s there different somebody

00:13:25,740 --> 00:13:36,709
knows

00:13:27,730 --> 00:13:39,350
somebody knows so this is this is that's

00:13:36,709 --> 00:13:40,790
my zoom in okay so you can see that this

00:13:39,350 --> 00:13:44,810
is actually different from the previous

00:13:40,790 --> 00:13:46,910
one you generate a different diagram why

00:13:44,810 --> 00:13:48,200
well first of all we can note that we

00:13:46,910 --> 00:13:49,010
are actually using more synchronous

00:13:48,200 --> 00:13:51,140
resources

00:13:49,010 --> 00:13:52,930
note that promises are a synchronous

00:13:51,140 --> 00:13:54,769
resources because they are scheduled in

00:13:52,930 --> 00:13:57,680
they're going to be a synchronous

00:13:54,769 --> 00:13:59,630
activity happening in the future so you

00:13:57,680 --> 00:14:02,180
see that we are scheduling 2000 more

00:13:59,630 --> 00:14:02,690
promises more or less than before why is

00:14:02,180 --> 00:14:04,970
that

00:14:02,690 --> 00:14:07,459
and the reason comes in the way the a

00:14:04,970 --> 00:14:09,620
sink await I think a way to specified

00:14:07,459 --> 00:14:11,300
and you know for every way that you do

00:14:09,620 --> 00:14:13,610
you are locate a bunch of promises that

00:14:11,300 --> 00:14:15,410
are not necessarily needed and they're

00:14:13,610 --> 00:14:17,600
going to be removed and you know fixed

00:14:15,410 --> 00:14:19,579
in later version of the spec I can send

00:14:17,600 --> 00:14:21,440
you some links if you are interested so

00:14:19,579 --> 00:14:23,300
the Reedy and you can see the difference

00:14:21,440 --> 00:14:25,100
here that you know we have our handle

00:14:23,300 --> 00:14:26,839
function and then we our a sink await

00:14:25,100 --> 00:14:29,390
function and it gets split in two and

00:14:26,839 --> 00:14:31,399
there is a bunch of tiny thing in here

00:14:29,390 --> 00:14:32,870
which says one frame with no file and

00:14:31,399 --> 00:14:35,120
this is you know there are some

00:14:32,870 --> 00:14:38,120
throwaway called throwaway promises in

00:14:35,120 --> 00:14:40,370
its gets you see some artifacts due to

00:14:38,120 --> 00:14:41,959
our promises work and you know and this

00:14:40,370 --> 00:14:43,579
is a completing of the hallway promise

00:14:41,959 --> 00:14:45,800
that goes nowhere this promise is

00:14:43,579 --> 00:14:49,959
completely like generated to just

00:14:45,800 --> 00:14:53,329
fulfill some spec need whatever anyway

00:14:49,959 --> 00:14:56,680
this is with the sink await and you know

00:14:53,329 --> 00:14:59,779
then another step interesting it's just

00:14:56,680 --> 00:15:01,490
just use callbacks you know why we are

00:14:59,779 --> 00:15:03,980
using this type of thing why can't we

00:15:01,490 --> 00:15:06,980
just use callbacks and let's do another

00:15:03,980 --> 00:15:09,709
example that's calling FS read file one

00:15:06,980 --> 00:15:12,770
of the parameters of nodejs so we go

00:15:09,709 --> 00:15:16,820
back here and we are running our files

00:15:12,770 --> 00:15:19,070
example and I think loosing tab but it's

00:15:16,820 --> 00:15:21,440
not a really good idea so a lot of files

00:15:19,070 --> 00:15:24,170
in there so we are running it and

00:15:21,440 --> 00:15:27,040
generating some bunch of things and here

00:15:24,170 --> 00:15:32,570
we go

00:15:27,040 --> 00:15:33,079
some magic sprinkling I don't know here

00:15:32,570 --> 00:15:34,880
we go

00:15:33,079 --> 00:15:36,560
now you can see that is another a

00:15:34,880 --> 00:15:38,810
slightly different one this is fully

00:15:36,560 --> 00:15:40,430
linear let me zoom in okay you can see

00:15:38,810 --> 00:15:42,020
in this blah blah

00:15:40,430 --> 00:15:44,180
there's a lot of brown activity which is

00:15:42,020 --> 00:15:45,740
a reading of files a bunch of scheduling

00:15:44,180 --> 00:15:48,050
activity which is the purple and then

00:15:45,740 --> 00:15:50,000
some green one which is data so we have

00:15:48,050 --> 00:15:52,190
these blocks of brown activity in here

00:15:50,000 --> 00:15:53,360
that you can see and you know the third

00:15:52,190 --> 00:15:56,570
let's click on the first one and the

00:15:53,360 --> 00:15:58,460
first one is our f1 function and you can

00:15:56,570 --> 00:16:00,200
see oh maybe as we are reading a file so

00:15:58,460 --> 00:16:02,870
this is scheduling our rid of the file

00:16:00,200 --> 00:16:05,270
then we have this next block afterwards

00:16:02,870 --> 00:16:06,740
which is in fact a combination of three

00:16:05,270 --> 00:16:08,990
different a synchronous activities

00:16:06,740 --> 00:16:11,030
because no J yes in order to read that

00:16:08,990 --> 00:16:13,160
file is actually accessing the file

00:16:11,030 --> 00:16:14,540
system three times and is completely in

00:16:13,160 --> 00:16:17,120
it for you you just call a fast read

00:16:14,540 --> 00:16:20,060
file but it's segmented and it makes

00:16:17,120 --> 00:16:21,680
things interleaved so that it you can

00:16:20,060 --> 00:16:24,080
use multiple signals activity at the

00:16:21,680 --> 00:16:25,430
same time and he's doing treat and is

00:16:24,080 --> 00:16:27,350
doing three things and it's calling this

00:16:25,430 --> 00:16:29,330
function read file after open which is

00:16:27,350 --> 00:16:30,950
totally an old call thing and we are not

00:16:29,330 --> 00:16:31,430
should not really worry too much about

00:16:30,950 --> 00:16:33,350
it

00:16:31,430 --> 00:16:35,630
and now we have the first we have the

00:16:33,350 --> 00:16:38,050
first file and then the second file and

00:16:35,630 --> 00:16:44,120
then the third file okay this seems I

00:16:38,050 --> 00:16:46,880
can understand this so let's switch to a

00:16:44,120 --> 00:16:48,710
sink await okay now you should have

00:16:46,880 --> 00:16:51,110
learned we should have seen that it

00:16:48,710 --> 00:16:56,330
changes significantly the structure of

00:16:51,110 --> 00:16:59,120
my application and it's it's actually

00:16:56,330 --> 00:17:00,440
very it's actually very useful because

00:16:59,120 --> 00:17:02,120
it moved from something that is very

00:17:00,440 --> 00:17:04,550
hard to read and very hard to maintain

00:17:02,120 --> 00:17:07,459
or something this is way better to read

00:17:04,550 --> 00:17:12,740
and maintain so yeah I like it right

00:17:07,459 --> 00:17:15,740
I'm a fan by the way and so what is

00:17:12,740 --> 00:17:18,950
happening it's now you can see that the

00:17:15,740 --> 00:17:22,130
the actual bubble prof art as we call it

00:17:18,950 --> 00:17:24,940
it is slightly different than them

00:17:22,130 --> 00:17:27,530
before because you can see that there is

00:17:24,940 --> 00:17:29,870
way more scheduling activity happening

00:17:27,530 --> 00:17:31,220
and you can see where the throw away

00:17:29,870 --> 00:17:32,990
promises are so there is at Rahway

00:17:31,220 --> 00:17:34,910
promise here via KHOU we are actually

00:17:32,990 --> 00:17:36,830
calling a sink await three times as I

00:17:34,910 --> 00:17:38,930
wait three times so we have three throw

00:17:36,830 --> 00:17:44,270
away promises and we have one here one

00:17:38,930 --> 00:17:45,770
here and one here now there is and we

00:17:44,270 --> 00:17:47,210
can now understand how things are

00:17:45,770 --> 00:17:49,940
getting interleaved between each other

00:17:47,210 --> 00:17:53,470
and how we can use this information to

00:17:49,940 --> 00:17:56,920
write better code and maybe fix problems

00:17:53,470 --> 00:18:00,850
one more thing it's we have written our

00:17:56,920 --> 00:18:04,360
code in this way now we can also very

00:18:00,850 --> 00:18:08,770
quickly write our code to be Impa in

00:18:04,360 --> 00:18:11,410
parallel note that changing a bunch of

00:18:08,770 --> 00:18:13,840
code back he'll functions to be parallel

00:18:11,410 --> 00:18:15,070
it's hard doing it with the sink away it

00:18:13,840 --> 00:18:18,190
is a matter of changing three lines of

00:18:15,070 --> 00:18:23,880
code so benefit there note that I'm not

00:18:18,190 --> 00:18:23,880
using a weight and let's see how it goes

00:18:28,770 --> 00:18:41,170
take some time here we go I'm zoom in

00:18:38,470 --> 00:18:43,060
and now now you can see that in fact the

00:18:41,170 --> 00:18:45,100
truth we throw away promises that we

00:18:43,060 --> 00:18:48,040
were talking before I have gone I have

00:18:45,100 --> 00:18:50,260
disappeared and we now have our only

00:18:48,040 --> 00:18:52,180
three blocks of reading our files and we

00:18:50,260 --> 00:18:54,070
can unpack this web and you can see that

00:18:52,180 --> 00:18:56,650
you know there is all the the things

00:18:54,070 --> 00:18:58,300
will get generated properly and stuff

00:18:56,650 --> 00:19:00,700
like that and there is a lot of

00:18:58,300 --> 00:19:02,350
information that you can that you can

00:19:00,700 --> 00:19:04,600
gather from this tool and to visualize

00:19:02,350 --> 00:19:07,180
your synchronous activity and understand

00:19:04,600 --> 00:19:09,730
how human your node process work in fact

00:19:07,180 --> 00:19:15,280
we've done some analysis on some some

00:19:09,730 --> 00:19:18,100
open source modules this is from a

00:19:15,280 --> 00:19:19,630
library called ipfs and it's a

00:19:18,100 --> 00:19:23,550
distributed web platform and we have

00:19:19,630 --> 00:19:27,700
done some optimizations in there and

00:19:23,550 --> 00:19:29,170
there was some some there was things

00:19:27,700 --> 00:19:31,180
that could be improved and you can see

00:19:29,170 --> 00:19:32,560
there is a lot of activity in here a lot

00:19:31,180 --> 00:19:35,440
of things that are you know chained

00:19:32,560 --> 00:19:38,050
together and so on and so forth and you

00:19:35,440 --> 00:19:41,470
can read all of this in this issue if

00:19:38,050 --> 00:19:44,050
you are interested it's long it's a long

00:19:41,470 --> 00:19:44,920
long long paper of explanation on what

00:19:44,050 --> 00:19:47,200
was the problem

00:19:44,920 --> 00:19:49,330
how we fix it in the end we fix it we

00:19:47,200 --> 00:19:50,380
got a 30% performance improvements so

00:19:49,330 --> 00:19:54,210
yeah

00:19:50,380 --> 00:19:56,170
what's nice what was a nice one okay so

00:19:54,210 --> 00:19:57,880
let's go a little bit into some

00:19:56,170 --> 00:20:00,010
performance consideration on how you

00:19:57,880 --> 00:20:04,390
write your node application and how to

00:20:00,010 --> 00:20:05,920
improve them so you know we've talked a

00:20:04,390 --> 00:20:07,299
little bit about the event loop and now

00:20:05,920 --> 00:20:10,239
the fact that your i/o

00:20:07,299 --> 00:20:12,159
runs one at a time right and we schedule

00:20:10,239 --> 00:20:17,860
functions so when we receive a request

00:20:12,159 --> 00:20:19,809
and it really is we schedule some

00:20:17,860 --> 00:20:22,419
activity to happen in the future

00:20:19,809 --> 00:20:25,600
we set a function into our event loop

00:20:22,419 --> 00:20:28,179
machinery right and they will call me

00:20:25,600 --> 00:20:31,179
back when it's finished so when this is

00:20:28,179 --> 00:20:35,590
low are your operation that function

00:20:31,179 --> 00:20:38,259
will stay alive longer okay which means

00:20:35,590 --> 00:20:39,549
that they can accept more stuff from I

00:20:38,259 --> 00:20:41,830
can accept more requests before

00:20:39,549 --> 00:20:44,080
returning right that's what everybody

00:20:41,830 --> 00:20:47,019
would do well I have capacity I'm not

00:20:44,080 --> 00:20:48,999
doing anything I'm haidle so I will get

00:20:47,019 --> 00:20:54,070
more data from you know I let's add more

00:20:48,999 --> 00:20:55,929
HTTP requests so yeah it's increased the

00:20:54,070 --> 00:20:57,820
amount of concurrent tasks because I

00:20:55,929 --> 00:20:59,109
have more CPU bandwidth now I'm waiting

00:20:57,820 --> 00:21:03,999
for stuff to happen so I can execute

00:20:59,109 --> 00:21:07,749
stuff good however the more increased

00:21:03,999 --> 00:21:11,799
the concurrency the more you increase

00:21:07,749 --> 00:21:13,690
the memory consumption why well we have

00:21:11,799 --> 00:21:17,619
a for each one that we received we are

00:21:13,690 --> 00:21:19,779
allocating new closures so new closures

00:21:17,619 --> 00:21:24,129
gets allocated new objects and all of

00:21:19,779 --> 00:21:30,549
these occupy memory which is you know

00:21:24,129 --> 00:21:33,999
precious in most systems the moment you

00:21:30,549 --> 00:21:36,609
increase memory consumption you increase

00:21:33,999 --> 00:21:41,289
you make the word of the nice garbage

00:21:36,609 --> 00:21:44,950
collector harder why well because you

00:21:41,289 --> 00:21:47,950
have es more stuff to clean up and you

00:21:44,950 --> 00:21:49,210
will is worth even the performance of

00:21:47,950 --> 00:21:50,379
the garbage collector is getting better

00:21:49,210 --> 00:21:53,889
and better and better and better better

00:21:50,379 --> 00:21:55,299
better and better every year we are

00:21:53,889 --> 00:21:58,539
scheduling more stuff every year to

00:21:55,299 --> 00:22:00,220
every moment to do more arise so it

00:21:58,539 --> 00:22:05,799
increased the pressure on the garbage

00:22:00,220 --> 00:22:07,419
collector to to do work and these the

00:22:05,799 --> 00:22:09,609
garbage collector where does it run is

00:22:07,419 --> 00:22:12,340
it magic no it's not magic it runs on a

00:22:09,609 --> 00:22:14,019
CPU and you know when you are working on

00:22:12,340 --> 00:22:18,190
a container system or are deploying

00:22:14,019 --> 00:22:20,169
nodejs in production you are doing you

00:22:18,190 --> 00:22:22,330
probably have one or two or three

00:22:20,169 --> 00:22:24,639
maybe course I don't know Italy most of

00:22:22,330 --> 00:22:26,889
the time once one Corps

00:22:24,639 --> 00:22:29,259
so if regard watch collectors running

00:22:26,889 --> 00:22:30,580
maybe my note process cannot run so we

00:22:29,259 --> 00:22:35,320
have a problem there okay there is

00:22:30,580 --> 00:22:36,730
contention so in the end and so this

00:22:35,320 --> 00:22:40,989
means that the garbage collector will

00:22:36,730 --> 00:22:45,059
steal my CPU cycles perfect and will

00:22:40,989 --> 00:22:50,350
steal my CPU cycle from the JavaScript

00:22:45,059 --> 00:22:57,159
critical path which is which is a little

00:22:50,350 --> 00:23:00,070
bit a tricky thing II so the net result

00:22:57,159 --> 00:23:03,340
is that late in a node.js application

00:23:00,070 --> 00:23:06,249
latency and throughput are tightly

00:23:03,340 --> 00:23:09,009
connected so the moment you see an

00:23:06,249 --> 00:23:11,049
increase in latency you will see also

00:23:09,009 --> 00:23:13,090
likely a decrease in in throughput

00:23:11,049 --> 00:23:17,440
mainly because they are linked together

00:23:13,090 --> 00:23:19,749
by the way the node works and the fact

00:23:17,440 --> 00:23:22,749
that typically it can take a huge amount

00:23:19,749 --> 00:23:25,629
of high concurrency compared to other

00:23:22,749 --> 00:23:28,149
platforms and and this is one of the

00:23:25,629 --> 00:23:31,840
things that you know having doing it as

00:23:28,149 --> 00:23:34,239
a job to go through and putting node.js

00:23:31,840 --> 00:23:36,129
application in production it's one of

00:23:34,239 --> 00:23:39,340
the most misunderstood concepts about

00:23:36,129 --> 00:23:41,710
about no GS and think thinking that this

00:23:39,340 --> 00:23:43,989
true concept latency and throughput are

00:23:41,710 --> 00:23:47,409
not connected to each other and you

00:23:43,989 --> 00:23:49,600
should always remember this so that this

00:23:47,409 --> 00:23:51,309
tool is part of the clinic J's suite you

00:23:49,600 --> 00:23:55,299
can find it there it there is also a

00:23:51,309 --> 00:23:56,529
video of me speaking whatever so if you

00:23:55,299 --> 00:23:58,600
need some help in improving the

00:23:56,529 --> 00:24:01,749
performance of your node.js application

00:23:58,600 --> 00:24:04,629
reach out eh say hi and yeah that's it

00:24:01,749 --> 00:24:05,980
and again these lights you probably want

00:24:04,629 --> 00:24:08,230
to check them out I don't know hopefully

00:24:05,980 --> 00:24:09,909
hopefully yes hopefully now I will tweet

00:24:08,230 --> 00:24:11,529
about them sooner rather than later

00:24:09,909 --> 00:24:14,999
somebody taking a pictures thank you I

00:24:11,529 --> 00:24:14,999
put it right they put it there for you

00:24:15,480 --> 00:24:21,239
so yes and thank you

00:24:24,630 --> 00:24:26,690

YouTube URL: https://www.youtube.com/watch?v=rYqh5LYfw0Y


