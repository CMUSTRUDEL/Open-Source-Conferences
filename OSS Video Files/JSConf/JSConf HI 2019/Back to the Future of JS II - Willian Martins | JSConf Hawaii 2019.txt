Title: Back to the Future of JS II - Willian Martins | JSConf Hawaii 2019
Publication date: 2019-06-16
Playlist: JSConf HI 2019
Description: 
	Willian Martins takes a sneak peak into the future of JavaScript by discussing the Pattern Matching, Pipeline Operator, and Binary AST proposals that are currently in Stage 1 of the TC 39 process.

Check out the proposals
Pattern Matching: https://github.com/tc39/proposal-pattern-matching
Pipeline Operator: https://github.com/tc39/proposal-pipeline-operator
Binary AST: https://github.com/tc39/proposal-binary-ast


JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:06,070 --> 00:00:11,620
okay now before I start my

00:00:09,280 --> 00:00:14,290
presentation I just want to go as most

00:00:11,620 --> 00:00:18,100
disclaimer all the proposed

00:00:14,290 --> 00:00:20,050
our own stage 1 in tc39 process which

00:00:18,100 --> 00:00:22,869
means that the community decided that

00:00:20,050 --> 00:00:26,590
the use case of this proposed that this

00:00:22,869 --> 00:00:28,090
proposed tries to solve are valid and it

00:00:26,590 --> 00:00:30,460
worth more investigation investigation

00:00:28,090 --> 00:00:34,780
nothing else okay

00:00:30,460 --> 00:00:38,340
the main purpose here is you still have

00:00:34,780 --> 00:00:41,800
a nice nick peak about of the future

00:00:38,340 --> 00:00:45,370
javascript and understand the use case

00:00:41,800 --> 00:00:49,150
broad pros and cons of this or each one

00:00:45,370 --> 00:00:51,160
of these features and create some words

00:00:49,150 --> 00:00:52,960
about the amazing and work that this

00:00:51,160 --> 00:00:59,850
attorney committee is doing in order to

00:00:52,960 --> 00:01:02,710
make our language better so if you have

00:00:59,850 --> 00:01:07,299
more a thing if I have any any concerns

00:01:02,710 --> 00:01:09,729
or if wanna show your excitement about

00:01:07,299 --> 00:01:12,670
some of the features or even though

00:01:09,729 --> 00:01:16,390
feature that I'm not mentioning here go

00:01:12,670 --> 00:01:18,550
to this link is their github repository

00:01:16,390 --> 00:01:23,470
all the proposed there they work on is

00:01:18,550 --> 00:01:25,630
there so the agenda for today is I will

00:01:23,470 --> 00:01:29,530
talk about pattern matching pipeline

00:01:25,630 --> 00:01:32,409
operator binaries T ast and a dangerous

00:01:29,530 --> 00:01:35,590
thing I will throw some opinions on that

00:01:32,409 --> 00:01:39,010
so if you will if you see this red

00:01:35,590 --> 00:01:40,390
border it means it's my opinion so if

00:01:39,010 --> 00:01:42,790
you disagree like let's talk to me

00:01:40,390 --> 00:01:47,850
afterwards and otherwise just ignore it

00:01:42,790 --> 00:01:50,850
because it's just my opinion with that

00:01:47,850 --> 00:01:50,850
sound

00:01:52,200 --> 00:01:55,430
[Music]

00:02:01,869 --> 00:02:12,800
okay to give a your background

00:02:10,670 --> 00:02:15,800
motivation about the first proposal I

00:02:12,800 --> 00:02:17,630
want to first talk about conditionals in

00:02:15,800 --> 00:02:20,959
JavaScript in JavaScript nowadays we

00:02:17,630 --> 00:02:23,390
have three ways to do conditionals if

00:02:20,959 --> 00:02:25,870
you're if knows the statement switch

00:02:23,390 --> 00:02:28,180
statement in ternary eternal expression

00:02:25,870 --> 00:02:30,170
to help you to get the picture an

00:02:28,180 --> 00:02:33,140
expression is something that they value

00:02:30,170 --> 00:02:35,959
a it's dot Val value and a statement is

00:02:33,140 --> 00:02:38,510
just something that does something I

00:02:35,959 --> 00:02:42,590
will show quickly how each one of these

00:02:38,510 --> 00:02:44,569
words so an if-else statement requires a

00:02:42,590 --> 00:02:50,120
condition which is thrown by this

00:02:44,569 --> 00:02:52,580
parenthesis and which can evaluate to

00:02:50,120 --> 00:02:56,170
true fee or false value if the condition

00:02:52,580 --> 00:02:59,630
is true it is equids the first block

00:02:56,170 --> 00:03:04,310
which is the curly brackets there and if

00:02:59,630 --> 00:03:09,500
not if it's false goes to the to the

00:03:04,310 --> 00:03:13,510
else block if there is one okay just to

00:03:09,500 --> 00:03:16,220
help you to get Peter I I create this

00:03:13,510 --> 00:03:21,680
snippet which is just a function that

00:03:16,220 --> 00:03:27,680
outputs a moyes that mostly reflects the

00:03:21,680 --> 00:03:30,850
the the the the temperature this is so I

00:03:27,680 --> 00:03:35,000
forgot to firstly it is to Freud sorry

00:03:30,850 --> 00:03:37,430
okay so as you can see here like you

00:03:35,000 --> 00:03:39,260
have a an ephah statement and then if

00:03:37,430 --> 00:03:42,230
this is true it returns like all the

00:03:39,260 --> 00:03:44,930
fire otherwise it falls to the LC

00:03:42,230 --> 00:03:48,410
statement which is another heavy

00:03:44,930 --> 00:03:50,930
statement so with this you can Cheney if

00:03:48,410 --> 00:03:52,970
an Elsa statement and this can go wild

00:03:50,930 --> 00:03:59,930
like I'm not even talk about that nasty

00:03:52,970 --> 00:04:02,480
if so if if I have like oh and this kind

00:03:59,930 --> 00:04:05,420
of sequential checks with just a small

00:04:02,480 --> 00:04:06,440
code to react to this I think switch

00:04:05,420 --> 00:04:08,570
statement could fit

00:04:06,440 --> 00:04:13,130
better so let's check how a switch

00:04:08,570 --> 00:04:14,600
statement works so as I told you that if

00:04:13,130 --> 00:04:18,620
statements very handy when you want to

00:04:14,600 --> 00:04:21,680
just react to a cup of choice and you

00:04:18,620 --> 00:04:24,380
know or we have a big chunk of code to

00:04:21,680 --> 00:04:26,930
run but when I will have like a

00:04:24,380 --> 00:04:30,740
multiple-choice with just a small code

00:04:26,930 --> 00:04:32,150
to react to this I think maybe a switch

00:04:30,740 --> 00:04:35,360
statement could be a good choice

00:04:32,150 --> 00:04:38,900
so how switch statement works so have

00:04:35,360 --> 00:04:42,110
like under between disbalances an

00:04:38,900 --> 00:04:44,870
expression and it evaluates this

00:04:42,110 --> 00:04:48,250
expression try to match with one of

00:04:44,870 --> 00:04:50,630
these cases statements and owns the

00:04:48,250 --> 00:04:52,520
expression matched to the expression

00:04:50,630 --> 00:04:54,050
inside the case statement this is the

00:04:52,520 --> 00:04:59,450
entry point of the the switch statement

00:04:54,050 --> 00:05:03,860
so the the the this is a key to enter in

00:04:59,450 --> 00:05:05,990
this point it get it gets going until

00:05:03,860 --> 00:05:08,660
the end so that's why we have this break

00:05:05,990 --> 00:05:12,470
statement to jump out of the the switch

00:05:08,660 --> 00:05:16,330
statement so going back to our initial

00:05:12,470 --> 00:05:19,640
example this is the way I just make the

00:05:16,330 --> 00:05:21,620
we will wrote the the previous example

00:05:19,640 --> 00:05:24,169
using switch statement as you can see

00:05:21,620 --> 00:05:25,790
here you oftentimes we just use the

00:05:24,169 --> 00:05:28,460
constant in the case statement but here

00:05:25,790 --> 00:05:30,820
see someone to trust us the truth value

00:05:28,460 --> 00:05:33,410
so I put that constant in the the switch

00:05:30,820 --> 00:05:38,960
expression and the comparison inside the

00:05:33,410 --> 00:05:42,500
case expression the third one like is

00:05:38,960 --> 00:05:45,590
the ternary expression so the ternary

00:05:42,500 --> 00:05:48,590
operator became popular recently most by

00:05:45,590 --> 00:05:50,390
the fictional programmers and who tries

00:05:48,590 --> 00:05:53,660
to write the code which am as much

00:05:50,390 --> 00:05:55,640
expression as possible it's it basically

00:05:53,660 --> 00:05:57,800
works as the following give it a

00:05:55,640 --> 00:06:00,380
condition if it's true it executes that

00:05:57,800 --> 00:06:02,390
block after the question mark it's false

00:06:00,380 --> 00:06:06,530
or if it's false

00:06:02,390 --> 00:06:08,960
after there the column so sister Mary is

00:06:06,530 --> 00:06:11,750
an expression you can use error function

00:06:08,960 --> 00:06:15,380
and to make the that previous example

00:06:11,750 --> 00:06:18,540
more concise and but it is readable I

00:06:15,380 --> 00:06:20,160
don't know I'm not heated dirt

00:06:18,540 --> 00:06:24,480
there are people that really like this

00:06:20,160 --> 00:06:27,480
approach as you can see there are a lot

00:06:24,480 --> 00:06:27,900
of ways to do conditional in JavaScript

00:06:27,480 --> 00:06:30,740
today

00:06:27,900 --> 00:06:34,410
what's the matter of the fourth one

00:06:30,740 --> 00:06:36,840
could you imagine what could happen if

00:06:34,410 --> 00:06:39,360
you mix if statement with switch

00:06:36,840 --> 00:06:46,130
statement plus the power for the power

00:06:39,360 --> 00:06:51,840
of distracting parameter very matching

00:06:46,130 --> 00:06:54,480
so transcend it better how I create this

00:06:51,840 --> 00:06:58,770
for example which I have we have like a

00:06:54,480 --> 00:07:01,770
list of shapes with size color type and

00:06:58,770 --> 00:07:06,210
I want I want to log all these circles

00:07:01,770 --> 00:07:09,090
red squares and big ball triangles just

00:07:06,210 --> 00:07:14,100
to context wise this will be our sample

00:07:09,090 --> 00:07:17,280
entry and this is how this is one of

00:07:14,100 --> 00:07:19,620
partition solution for the problem but

00:07:17,280 --> 00:07:21,810
it's tricky that it becomes tricky

00:07:19,620 --> 00:07:24,540
because it can easily become hard to

00:07:21,810 --> 00:07:26,670
reason about because the more checks we

00:07:24,540 --> 00:07:29,910
have then the bigger is the if statement

00:07:26,670 --> 00:07:34,770
and this is the way we can achieve this

00:07:29,910 --> 00:07:37,440
with with pattern matching so because of

00:07:34,770 --> 00:07:39,540
the time I want to explain the concepts

00:07:37,440 --> 00:07:41,520
of the pattern matching if you are

00:07:39,540 --> 00:07:45,630
interested in interest in this we can

00:07:41,520 --> 00:07:48,450
talk more about this later so this is

00:07:45,630 --> 00:07:52,110
the first first part part of it which is

00:07:48,450 --> 00:07:55,800
the case statement it defines the start

00:07:52,110 --> 00:07:59,340
of the pattern matching statement so it

00:07:55,800 --> 00:08:01,110
receives just one value as input which

00:07:59,340 --> 00:08:04,260
is inside this parenthesis which is the

00:08:01,110 --> 00:08:08,130
case expression so then we have

00:08:04,260 --> 00:08:11,070
afterwards the wain clause so the

00:08:08,130 --> 00:08:13,920
windows is divided in two parts the

00:08:11,070 --> 00:08:17,700
match pattern which is this first pair

00:08:13,920 --> 00:08:18,150
of curly brackets and the Wayne Clause

00:08:17,700 --> 00:08:22,320
body

00:08:18,150 --> 00:08:24,750
so whenever the shape of the parent the

00:08:22,320 --> 00:08:29,670
the pattern and makes the shape of the

00:08:24,750 --> 00:08:32,900
expression it gets into this it executes

00:08:29,670 --> 00:08:36,090
the this body

00:08:32,900 --> 00:08:38,729
so as you can see to achieve the second

00:08:36,090 --> 00:08:43,280
condition I just need to create another

00:08:38,729 --> 00:08:46,020
query let's say not another pattern and

00:08:43,280 --> 00:08:48,630
so in here you have something different

00:08:46,020 --> 00:08:51,450
you can check that we have like we are

00:08:48,630 --> 00:08:55,590
matching the size and then afterwards we

00:08:51,450 --> 00:08:58,200
have this if statement which not a an if

00:08:55,590 --> 00:09:02,150
statement it's just it's called magic

00:08:58,200 --> 00:09:05,280
word so whenever the first part match

00:09:02,150 --> 00:09:07,770
even though the like if the the match

00:09:05,280 --> 00:09:11,250
guard returns false we don't execute

00:09:07,770 --> 00:09:14,400
that that body we just skip the last

00:09:11,250 --> 00:09:20,310
part is when I will put a variable and

00:09:14,400 --> 00:09:23,670
stay alone on this match better it's

00:09:20,310 --> 00:09:25,680
just it just matched everything so it's

00:09:23,670 --> 00:09:32,280
kind of the default statement for force

00:09:25,680 --> 00:09:34,140
which case okay now even though man

00:09:32,280 --> 00:09:35,700
parent may is powerful we should not

00:09:34,140 --> 00:09:39,930
forget to use the right tool to do the

00:09:35,700 --> 00:09:42,900
right job remember or whether example

00:09:39,930 --> 00:09:45,780
using part and a pattern matching we

00:09:42,900 --> 00:09:50,870
could do like this so keep in mind that

00:09:45,780 --> 00:09:55,170
not everything they need to use a hammer

00:09:50,870 --> 00:09:58,620
okay dangerous part this brings me some

00:09:55,170 --> 00:10:00,420
some wishes like since we have three

00:09:58,620 --> 00:10:05,010
ways to do conditionals in JavaScript

00:10:00,420 --> 00:10:06,450
and to our arrays a statement so I would

00:10:05,010 --> 00:10:09,540
like to see parent matching linking

00:10:06,450 --> 00:10:13,380
JavaScript as as expression so we could

00:10:09,540 --> 00:10:16,890
have because now as its proposed its

00:10:13,380 --> 00:10:18,900
proposed as a statement and I think and

00:10:16,890 --> 00:10:20,820
having this I know there are there are a

00:10:18,900 --> 00:10:23,820
lot of chronic case that needs to be

00:10:20,820 --> 00:10:25,860
covered to make this as as an expression

00:10:23,820 --> 00:10:29,820
but I would like to wait more to have

00:10:25,860 --> 00:10:34,230
this and have this as expression but if

00:10:29,820 --> 00:10:35,910
this lens as a as a statement and if we

00:10:34,230 --> 00:10:37,770
have a do expression aligned in

00:10:35,910 --> 00:10:40,620
JavaScript we can write prior image we

00:10:37,770 --> 00:10:42,030
do expression so let's go to the next

00:10:40,620 --> 00:10:44,550
one

00:10:42,030 --> 00:10:45,920
before introduce the next proposal let's

00:10:44,550 --> 00:10:48,290
check

00:10:45,920 --> 00:10:50,480
what is functional composition in how we

00:10:48,290 --> 00:10:52,510
can do this even in JavaScript so

00:10:50,480 --> 00:10:55,940
function composition is a mathematical

00:10:52,510 --> 00:10:58,160
mathematical concept that allows you to

00:10:55,940 --> 00:11:01,940
combine two or more functions to create

00:10:58,160 --> 00:11:02,810
a new function okay so to help you to

00:11:01,940 --> 00:11:05,660
get the picture

00:11:02,810 --> 00:11:07,640
let's could cook a bento I came up with

00:11:05,660 --> 00:11:09,890
this example just because it's I think

00:11:07,640 --> 00:11:15,170
it's easier to reason about food and

00:11:09,890 --> 00:11:18,730
because I like to use a mooch so when I

00:11:15,170 --> 00:11:21,440
was like whenever have a function that

00:11:18,730 --> 00:11:24,620
you the output of the previous function

00:11:21,440 --> 00:11:27,200
use as input to the next function you

00:11:24,620 --> 00:11:30,380
like you think that you need to compose

00:11:27,200 --> 00:11:32,029
those but like to do this nowadays one

00:11:30,380 --> 00:11:35,600
of the possible ways is to do this

00:11:32,029 --> 00:11:38,000
within this intermediary variables but

00:11:35,600 --> 00:11:39,800
it becomes verbose just just because you

00:11:38,000 --> 00:11:41,930
need to create this variable just to

00:11:39,800 --> 00:11:43,870
hold this function to this value until

00:11:41,930 --> 00:11:47,570
use this as input to the next function

00:11:43,870 --> 00:11:51,470
so I don't want I don't want to use this

00:11:47,570 --> 00:11:55,130
intermediate variables okay like how can

00:11:51,470 --> 00:11:59,540
we do this better right I can do like

00:11:55,130 --> 00:12:01,370
this but it's a trick treasonable

00:11:59,540 --> 00:12:03,020
because the way the data flow is

00:12:01,370 --> 00:12:04,970
different that the way we read the code

00:12:03,020 --> 00:12:06,320
because the the data flows from the

00:12:04,970 --> 00:12:08,540
inner function to the our reference

00:12:06,320 --> 00:12:11,570
outer function but the way we read this

00:12:08,540 --> 00:12:13,460
like top down left right and there is a

00:12:11,570 --> 00:12:15,110
1x or problem that the more we change

00:12:13,460 --> 00:12:16,880
these functions the more an asset that

00:12:15,110 --> 00:12:20,420
we have this call so it's not so

00:12:16,880 --> 00:12:23,870
readable okay we can use low - flow for

00:12:20,420 --> 00:12:27,710
of for pipe in this function and a more

00:12:23,870 --> 00:12:32,480
readable way let's say or ramp down a

00:12:27,710 --> 00:12:34,959
pipe or even vanilla J's right so

00:12:32,480 --> 00:12:37,400
wouldn't be nice to have this capability

00:12:34,959 --> 00:12:39,290
somehow incorporate into JavaScript

00:12:37,400 --> 00:12:43,580
without having to rely to external

00:12:39,290 --> 00:12:45,380
library or some homemade functions so

00:12:43,580 --> 00:12:47,770
let's bring the the second proposal of

00:12:45,380 --> 00:12:47,770
this talk

00:12:48,810 --> 00:12:57,000
pipeline operator so pipeline operator

00:12:52,540 --> 00:12:59,350
is a syntactic sugar for this use case

00:12:57,000 --> 00:13:01,330
it creates a streamline

00:12:59,350 --> 00:13:04,390
chain of functions you know readable in

00:13:01,330 --> 00:13:08,920
functional manner and in its backhoe

00:13:04,390 --> 00:13:14,590
backwards compatible so that initial

00:13:08,920 --> 00:13:17,680
example of great Beto could be used to I

00:13:14,590 --> 00:13:24,820
only have five minutes sir really I just

00:13:17,680 --> 00:13:27,400
started oh I need to hurry up okay so

00:13:24,820 --> 00:13:29,950
use the pipeline operator I can do like

00:13:27,400 --> 00:13:31,330
this so it becomes clear that the way

00:13:29,950 --> 00:13:34,120
there are flow is the way I read the

00:13:31,330 --> 00:13:36,370
code and this will be the sugar to this

00:13:34,120 --> 00:13:39,510
one it's nice right

00:13:36,370 --> 00:13:42,670
so what if my chain function like

00:13:39,510 --> 00:13:45,190
receives more one more parameter let's

00:13:42,670 --> 00:13:47,980
suppose that we have this add fish to

00:13:45,190 --> 00:13:50,920
create an agree and we need to define

00:13:47,980 --> 00:13:54,970
which kind of fish we need to add to the

00:13:50,920 --> 00:13:57,070
to the rice once we have it so we could

00:13:54,970 --> 00:14:00,610
wrap this function with an arrow

00:13:57,070 --> 00:14:02,260
function so but in a minimum proposal

00:14:00,610 --> 00:14:03,400
you need to wrap the arrow function with

00:14:02,260 --> 00:14:09,610
parentheses otherwise you'll have a

00:14:03,400 --> 00:14:12,700
syntax error and okay I just figure out

00:14:09,610 --> 00:14:15,820
that I don't know how to a simpler bento

00:14:12,700 --> 00:14:19,480
so I need to delegate this task to an

00:14:15,820 --> 00:14:21,490
iron I a sync third-party function how

00:14:19,480 --> 00:14:25,180
to treat this async function using

00:14:21,490 --> 00:14:29,170
pipeline operator so I could await this

00:14:25,180 --> 00:14:31,360
function but the problem is this line by

00:14:29,170 --> 00:14:34,060
line aphorism Vigo's because I don't

00:14:31,360 --> 00:14:35,650
know for example if my implementation of

00:14:34,060 --> 00:14:38,260
the add to bento is just a

00:14:35,650 --> 00:14:40,660
straightforward async implementation I

00:14:38,260 --> 00:14:43,660
want to have this function to be the

00:14:40,660 --> 00:14:46,360
sugar to this line six but if for some

00:14:43,660 --> 00:14:48,010
reason I have uncommon implementation

00:14:46,360 --> 00:14:50,140
which I return another function that I

00:14:48,010 --> 00:14:52,600
want to call with the the the rice to

00:14:50,140 --> 00:14:56,140
create an agree or to create the the

00:14:52,600 --> 00:14:58,450
bento I want to I want this line to be

00:14:56,140 --> 00:15:00,570
the alone among this function to be the

00:14:58,450 --> 00:15:03,210
sugar to the line 6 the

00:15:00,570 --> 00:15:06,930
problem is that the MIMO proposal there

00:15:03,210 --> 00:15:09,540
is no guarantee that I I can that our

00:15:06,930 --> 00:15:13,560
wait step could be the sugar to the one

00:15:09,540 --> 00:15:15,360
on an order yes as you can see the the

00:15:13,560 --> 00:15:18,600
minimal poser has two caveats that needs

00:15:15,360 --> 00:15:20,010
to be others in order to have in order

00:15:18,600 --> 00:15:24,480
to proceed in and the sitter nine

00:15:20,010 --> 00:15:27,810
proposal there are two comparing

00:15:24,480 --> 00:15:30,900
proposals to that try to address these

00:15:27,810 --> 00:15:32,580
two issues in different ways I will

00:15:30,900 --> 00:15:35,970
first explain the smart pipeline

00:15:32,580 --> 00:15:38,760
proposal so this mark pipeline proposal

00:15:35,970 --> 00:15:40,740
creates our token so this token is like

00:15:38,760 --> 00:15:43,830
the placeholder for the results of the

00:15:40,740 --> 00:15:47,790
previous step so whenever whenever we

00:15:43,830 --> 00:15:50,640
want to you have like a to a weight a

00:15:47,790 --> 00:15:53,970
function or you have to pass one extra

00:15:50,640 --> 00:15:57,210
premier like as as I showed you you can

00:15:53,970 --> 00:15:58,740
you can use the top style or whenever

00:15:57,210 --> 00:16:03,050
you have like this is straight for a

00:15:58,740 --> 00:16:05,930
call you just use the very bear style so

00:16:03,050 --> 00:16:09,090
just couple of rules for SmartPak nine

00:16:05,930 --> 00:16:13,140
when I will have parentheses are called

00:16:09,090 --> 00:16:15,330
by square brackets you need to use topic

00:16:13,140 --> 00:16:18,330
style otherwise issue do you can use

00:16:15,330 --> 00:16:20,310
various time which brings to a small

00:16:18,330 --> 00:16:23,220
corner case which is how to handle

00:16:20,310 --> 00:16:30,450
co-occurring so when you have current

00:16:23,220 --> 00:16:31,530
you have to use you have - I have more

00:16:30,450 --> 00:16:36,110
50 more minutes

00:16:31,530 --> 00:16:41,310
okay okay

00:16:36,110 --> 00:16:42,960
backtrack okay when you have curry since

00:16:41,310 --> 00:16:45,570
you have the the parentheses if you

00:16:42,960 --> 00:16:49,200
don't if though if you try to use the

00:16:45,570 --> 00:16:52,290
Barry style you have a syntax error so

00:16:49,200 --> 00:16:56,820
that's why you need to create a an extra

00:16:52,290 --> 00:16:58,830
call I can with the token okay this

00:16:56,820 --> 00:17:01,160
proposal has an extensive documentation

00:16:58,830 --> 00:17:03,060
for further enhancements after this

00:17:01,160 --> 00:17:06,400
[Music]

00:17:03,060 --> 00:17:08,380
baseline baseline proposal you should

00:17:06,400 --> 00:17:09,760
check that out that is there there are

00:17:08,380 --> 00:17:13,420
some links on the end of this

00:17:09,760 --> 00:17:16,510
presentation so as a counterpart we have

00:17:13,420 --> 00:17:19,440
the F sharp proposal which only tries to

00:17:16,510 --> 00:17:22,900
other is the ambiguity of a weight step

00:17:19,440 --> 00:17:27,250
of a weight by using an unweighted step

00:17:22,900 --> 00:17:29,500
so it seems to be simpler than than

00:17:27,250 --> 00:17:31,600
smart pipelines proposed but still we

00:17:29,500 --> 00:17:34,290
have to override the the arrow function

00:17:31,600 --> 00:17:36,760
with parentheses because the F sharp

00:17:34,290 --> 00:17:40,240
pipeline proposal doesn't try to address

00:17:36,760 --> 00:17:44,400
this one maybe because we still like

00:17:40,240 --> 00:17:46,450
maybe if we have the partial application

00:17:44,400 --> 00:17:48,280
lending JavaScript the partial

00:17:46,450 --> 00:17:53,860
application can replace this this line

00:17:48,280 --> 00:17:56,170
with of their error function so just to

00:17:53,860 --> 00:17:58,810
summarize the everything about pipeline

00:17:56,170 --> 00:18:01,260
operator so it's a nice addition for

00:17:58,810 --> 00:18:04,450
create a functional composition in a

00:18:01,260 --> 00:18:08,230
streamlined way the minimal purpose has

00:18:04,450 --> 00:18:10,300
two caveats the smart pipeline tries to

00:18:08,230 --> 00:18:15,070
solve this by ID and talkin and the F

00:18:10,300 --> 00:18:17,650
sharp adds just the weight step okay my

00:18:15,070 --> 00:18:20,410
point is I really really really like

00:18:17,650 --> 00:18:22,900
pipeline operator and I really want to

00:18:20,410 --> 00:18:26,350
have this shift as soon as possible so I

00:18:22,900 --> 00:18:28,330
would advocate for have the the I think

00:18:26,350 --> 00:18:31,300
that the F sharp proposed is just great

00:18:28,330 --> 00:18:33,850
like it's just writes off like a small

00:18:31,300 --> 00:18:36,790
problem and then we can we could put

00:18:33,850 --> 00:18:39,430
possible possibly having this ship to

00:18:36,790 --> 00:18:41,190
JavaScript and then afterwards the the

00:18:39,430 --> 00:18:46,600
committee could decide that whether

00:18:41,190 --> 00:18:48,970
introduce a token as one way of so these

00:18:46,600 --> 00:18:52,990
issues are these caveats as the the

00:18:48,970 --> 00:18:56,400
smart pipeline tries to to others or I

00:18:52,990 --> 00:18:59,200
don't know keep a series nevertheless

00:18:56,400 --> 00:19:01,960
bubble seven and adultery has shipped

00:18:59,200 --> 00:19:04,810
this my it smart pipeline proposal so I

00:19:01,960 --> 00:19:06,820
invite you to try that out not important

00:19:04,810 --> 00:19:10,720
so far like because this is this is not

00:19:06,820 --> 00:19:13,850
the syntax is not final but please and

00:19:10,720 --> 00:19:16,220
try that out okay

00:19:13,850 --> 00:19:18,409
before going to the last proposal of

00:19:16,220 --> 00:19:21,169
this presentation one to me I want to

00:19:18,409 --> 00:19:24,739
make sure some performance tips have you

00:19:21,169 --> 00:19:28,190
ever heard about any of these JavaScript

00:19:24,739 --> 00:19:29,869
performance tips do you ever wonder why

00:19:28,190 --> 00:19:33,580
this is important for the performance of

00:19:29,869 --> 00:19:37,279
your application to understand this in

00:19:33,580 --> 00:19:39,019
this practice and how they are important

00:19:37,279 --> 00:19:42,529
the next propose and how the next

00:19:39,019 --> 00:19:45,409
proposal tries to help to mitigate that

00:19:42,529 --> 00:19:52,059
we need to check first how the GS engine

00:19:45,409 --> 00:19:54,919
is generally generally works so so

00:19:52,059 --> 00:19:58,070
hopefully explain how the GS engines

00:19:54,919 --> 00:20:02,210
worked I will show this illustration

00:19:58,070 --> 00:20:04,519
that I borrowed from excellent article

00:20:02,210 --> 00:20:08,599
from address money about startup

00:20:04,519 --> 00:20:11,590
reference in JavaScript so whenever the

00:20:08,599 --> 00:20:16,070
browser finds a script tag they download

00:20:11,590 --> 00:20:18,529
the text content of it and then after it

00:20:16,070 --> 00:20:20,659
parses the JavaScript and then generally

00:20:18,529 --> 00:20:24,409
the result of this JavaScript is

00:20:20,659 --> 00:20:27,139
something called abstract syntax tree or

00:20:24,409 --> 00:20:28,249
ast which is a tree representation of

00:20:27,139 --> 00:20:31,700
your code

00:20:28,249 --> 00:20:35,690
so then afterwards the browser used is

00:20:31,700 --> 00:20:38,149
to generate the vertical to do the first

00:20:35,690 --> 00:20:40,460
virtual version of the other brainy

00:20:38,149 --> 00:20:43,909
JavaScript so this last parts more

00:20:40,460 --> 00:20:46,220
regarding the the runtime optimizations

00:20:43,909 --> 00:20:48,649
that happens in JavaScript when Dan and

00:20:46,220 --> 00:20:50,450
makes the JavaScript executes faster but

00:20:48,649 --> 00:20:54,669
this is not targeted for presentation

00:20:50,450 --> 00:20:56,899
just to summarize putting short

00:20:54,669 --> 00:20:59,809
JavaScript likes I could be described as

00:20:56,899 --> 00:21:01,970
generally as startup phase or loading

00:20:59,809 --> 00:21:05,149
phase that's the the dull old Parson

00:21:01,970 --> 00:21:08,479
compilation runtime phase which is the

00:21:05,149 --> 00:21:10,159
the proper execution of the optimization

00:21:08,479 --> 00:21:11,629
the optimization bailing out and the

00:21:10,159 --> 00:21:16,820
teardown phase which is the garbage

00:21:11,629 --> 00:21:20,869
collection but here I want to focus more

00:21:16,820 --> 00:21:23,119
on the parsing phase why think about the

00:21:20,869 --> 00:21:25,849
code and startup phase in JavaScript we

00:21:23,119 --> 00:21:27,500
can see that it's crucial crucial for

00:21:25,849 --> 00:21:31,520
the perceived profession or perform

00:21:27,500 --> 00:21:33,800
of an application so to make an

00:21:31,520 --> 00:21:35,540
application I start faster we end up

00:21:33,800 --> 00:21:37,070
doing those kinds of things that we just

00:21:35,540 --> 00:21:40,310
spoke in the beginning of this section

00:21:37,070 --> 00:21:44,180
but one thing doesn't change the parts

00:21:40,310 --> 00:21:45,860
in time parson parson in the initial

00:21:44,180 --> 00:21:49,100
compilation of JavaScript could take up

00:21:45,860 --> 00:21:52,520
to 30% of the the main tried time and 1

00:21:49,100 --> 00:21:54,590
megabyte of uncompressed JavaScript can

00:21:52,520 --> 00:21:58,450
easily take a whole second to be parsad

00:21:54,590 --> 00:22:01,850
in an average mobile phone normal depth

00:21:58,450 --> 00:22:05,690
the browser needs to parse the whole

00:22:01,850 --> 00:22:07,340
file before compiling and these are the

00:22:05,690 --> 00:22:15,110
motivation for the last propose of this

00:22:07,340 --> 00:22:18,440
talk binary is T so the parent in a

00:22:15,110 --> 00:22:22,550
binary SC proposal proposes a new over

00:22:18,440 --> 00:22:25,820
the wire format for JavaScript which is

00:22:22,550 --> 00:22:30,020
based on the binary representation of a

00:22:25,820 --> 00:22:32,330
simplified custom ast so this could

00:22:30,020 --> 00:22:35,240
potentially decrease the the start of

00:22:32,330 --> 00:22:37,310
large J application and the browser that

00:22:35,240 --> 00:22:41,570
doesn't support it just can load the

00:22:37,310 --> 00:22:45,140
Nommo javascript file so this is how

00:22:41,570 --> 00:22:47,090
this may work first we we need to write

00:22:45,140 --> 00:22:50,780
or or beautiful delightful piece of

00:22:47,090 --> 00:22:55,880
JavaScript so then you can compile it

00:22:50,780 --> 00:23:00,320
using your favorite favorite flavor of a

00:22:55,880 --> 00:23:04,850
bundle or transpire which provides such

00:23:00,320 --> 00:23:07,940
feature and then the processor will give

00:23:04,850 --> 00:23:11,630
not only the min J's file but a bean JS

00:23:07,940 --> 00:23:15,770
file and and this bin J's file it's a

00:23:11,630 --> 00:23:19,580
pre first ast representation of your

00:23:15,770 --> 00:23:24,470
javascript file so the browser that

00:23:19,580 --> 00:23:27,860
supports it can can have the the parsing

00:23:24,470 --> 00:23:29,780
phase the duskily decrease in time since

00:23:27,860 --> 00:23:33,710
the majority of this test is doing in a

00:23:29,780 --> 00:23:36,890
butte I'm right so the champions of this

00:23:33,710 --> 00:23:39,320
proposal create a PLC over spider I spot

00:23:36,890 --> 00:23:39,990
a marquee and user government buys on

00:23:39,320 --> 00:23:43,760
the it

00:23:39,990 --> 00:23:46,500
internal ast and try to compile some

00:23:43,760 --> 00:23:50,160
javascript in binary ST and measured

00:23:46,500 --> 00:23:52,500
their performance and using the the

00:23:50,160 --> 00:23:56,179
Facebook static newsfeed as a benchmark

00:23:52,500 --> 00:23:59,010
the POC had the following outcomes

00:23:56,179 --> 00:24:01,320
the result of this beauty of the POC was

00:23:59,010 --> 00:24:03,660
the following the the size of the binary

00:24:01,320 --> 00:24:08,090
st was slightly smaller than the

00:24:03,660 --> 00:24:10,920
javascript file and the parsing of

00:24:08,090 --> 00:24:14,250
creating the that job is clearly was

00:24:10,920 --> 00:24:16,950
between work between 500 800

00:24:14,250 --> 00:24:22,920
milliseconds but the time for create ast

00:24:16,950 --> 00:24:25,140
was twice as fast as before so this POC

00:24:22,920 --> 00:24:28,530
showed the show showed some evidence

00:24:25,140 --> 00:24:32,090
that cheap plain binary AST was a good

00:24:28,530 --> 00:24:35,340
performance wing that creates some a

00:24:32,090 --> 00:24:39,870
second level of X extra notations on the

00:24:35,340 --> 00:24:42,510
binary ST file could has enable some

00:24:39,870 --> 00:24:45,570
that that code elimination without

00:24:42,510 --> 00:24:50,730
relying in the butt and the bundle

00:24:45,570 --> 00:24:54,000
bundle plugins like tree shaking and it

00:24:50,730 --> 00:24:55,410
it can improve to the point that it this

00:24:54,000 --> 00:24:58,080
this annotation improved to the point

00:24:55,410 --> 00:25:01,110
that we can enable a streaming

00:24:58,080 --> 00:25:05,610
compilation if the performance of this

00:25:01,110 --> 00:25:08,730
hypothetical stream compilation has was

00:25:05,610 --> 00:25:11,460
closer to the current webassembly stream

00:25:08,730 --> 00:25:15,059
completion we can reach to the point

00:25:11,460 --> 00:25:18,300
that the compilation time for for the

00:25:15,059 --> 00:25:20,970
enhancement EST by name EST could be

00:25:18,300 --> 00:25:26,700
faster than a long time amazing right

00:25:20,970 --> 00:25:32,640
so to finalize these are links for

00:25:26,700 --> 00:25:38,059
further reading and these are my contact

00:25:32,640 --> 00:25:38,059
if want to get in touch and Mahalo

00:25:38,330 --> 00:25:40,390

YouTube URL: https://www.youtube.com/watch?v=yWMlLhx3foI


