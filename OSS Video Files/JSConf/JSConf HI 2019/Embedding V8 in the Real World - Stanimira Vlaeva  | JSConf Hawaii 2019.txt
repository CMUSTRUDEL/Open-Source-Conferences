Title: Embedding V8 in the Real World - Stanimira Vlaeva  | JSConf Hawaii 2019
Publication date: 2019-06-16
Playlist: JSConf HI 2019
Description: 
	Stanimira Vlaeva discusses the inner workings of NativeScript, an open source framework to use frameworks like Angular and Vue.js or even vanilla JavaScript for mobile front end development.

JSConf Hawaii is returning in 2020. Learn more at https://www.jsconfhi.com/
Captions: 
	00:00:05,680 --> 00:00:09,600
thank you for staying so long and I'm

00:00:08,960 --> 00:00:12,630
gonna be

00:00:09,600 --> 00:00:15,240
about how we are embedding v8d

00:00:12,630 --> 00:00:18,600
javascript engine v8 in the native

00:00:15,240 --> 00:00:21,140
script project how's the muder it's

00:00:18,600 --> 00:00:21,140
required

00:00:23,060 --> 00:00:28,320
[Applause]

00:00:26,090 --> 00:00:30,360
so before we start just to make sure

00:00:28,320 --> 00:00:34,350
that we're on the same page we'll

00:00:30,360 --> 00:00:37,140
explain a few basic terms first what is

00:00:34,350 --> 00:00:39,600
the JavaScript engine so JavaScript

00:00:37,140 --> 00:00:41,309
engine is a computer program that

00:00:39,600 --> 00:00:45,510
executes J's code

00:00:41,309 --> 00:00:48,180
thanks Wikipedia and also most modern

00:00:45,510 --> 00:00:51,870
JavaScript engines utilize just-in-time

00:00:48,180 --> 00:00:55,589
compilation and when I first read that a

00:00:51,870 --> 00:00:59,550
few years back I was like wait you just

00:00:55,589 --> 00:01:01,710
say compilation I taught it I was

00:00:59,550 --> 00:01:05,159
writing in a language that's kind of

00:01:01,710 --> 00:01:07,290
interpreted and not compiled and I was I

00:01:05,159 --> 00:01:08,970
was reading through different blog post

00:01:07,290 --> 00:01:11,490
doing some research trying to figure out

00:01:08,970 --> 00:01:15,360
what is going on it's my whole life a

00:01:11,490 --> 00:01:18,930
lie was a was a reading yeah so it turns

00:01:15,360 --> 00:01:21,560
out that yeah javascript is interpreted

00:01:18,930 --> 00:01:24,119
but it's not just that the first

00:01:21,560 --> 00:01:26,609
JavaScript engine that was created was

00:01:24,119 --> 00:01:28,859
just the interpreter but it turns out

00:01:26,609 --> 00:01:31,409
that we started choosing jealously for a

00:01:28,859 --> 00:01:34,710
lot of more things that it was initially

00:01:31,409 --> 00:01:37,649
thought is gonna be used for so there

00:01:34,710 --> 00:01:40,100
had to be some performance improvements

00:01:37,649 --> 00:01:45,810
to the way the JavaScript engine works

00:01:40,100 --> 00:01:50,280
so this is what actually the modern

00:01:45,810 --> 00:01:52,590
JavaScript engine engines do and the

00:01:50,280 --> 00:01:55,020
blog post that I got it from is the jasc

00:01:52,590 --> 00:01:57,719
if starboard startup performance by eros

00:01:55,020 --> 00:01:59,640
money you can find the link later but

00:01:57,719 --> 00:02:02,340
the blog post says that this is actually

00:01:59,640 --> 00:02:05,630
a simplification of what javascript

00:02:02,340 --> 00:02:10,020
engine that's under the hood I was like

00:02:05,630 --> 00:02:13,740
ok cool so why do we actually need that

00:02:10,020 --> 00:02:16,100
and as I mentioned before well

00:02:13,740 --> 00:02:20,640
performance that's it

00:02:16,100 --> 00:02:22,490
so the first just-in-time compiler and

00:02:20,640 --> 00:02:25,930
very Tina

00:02:22,490 --> 00:02:28,630
script engine was trace monkey which is

00:02:25,930 --> 00:02:31,100
actually part of the spider monkey

00:02:28,630 --> 00:02:35,390
JavaScript engine which was owned by a

00:02:31,100 --> 00:02:37,370
Mozilla and it was back in 2007 or

00:02:35,390 --> 00:02:40,310
something like that a little bit after

00:02:37,370 --> 00:02:42,640
that v8 was released and that was the

00:02:40,310 --> 00:02:45,290
same time when chrome was released and

00:02:42,640 --> 00:02:48,050
this really boosted the performance of

00:02:45,290 --> 00:02:48,650
JavaScript in the browser and everywhere

00:02:48,050 --> 00:02:53,360
else

00:02:48,650 --> 00:02:56,810
and that kind of explains how the whole

00:02:53,360 --> 00:03:01,010
JavaScript engine development happened

00:02:56,810 --> 00:03:03,860
and why is it I mean we started from

00:03:01,010 --> 00:03:07,550
just some interpreters and this is what

00:03:03,860 --> 00:03:09,890
we've got now so if you want to read the

00:03:07,550 --> 00:03:12,200
proper explanation of what JIT compiler

00:03:09,890 --> 00:03:14,630
is I really recommend this blog post by

00:03:12,200 --> 00:03:17,870
link work was here today just two hours

00:03:14,630 --> 00:03:22,520
before and yeah really excited to be on

00:03:17,870 --> 00:03:25,760
the same stage anyway and another great

00:03:22,520 --> 00:03:28,490
great resource is the talk life of a

00:03:25,760 --> 00:03:32,210
script which is really recent and it's

00:03:28,490 --> 00:03:35,030
by Satya and Yaqoob from the VA team and

00:03:32,210 --> 00:03:37,850
they're explaining all the optimizations

00:03:35,030 --> 00:03:43,130
that the v8 engine does under the hood

00:03:37,850 --> 00:03:43,640
in order to make JavaScript faster let's

00:03:43,130 --> 00:03:45,500
move on

00:03:43,640 --> 00:03:47,510
I'm already mentioned that I'm going to

00:03:45,500 --> 00:03:50,060
be talking about v8 it is a JavaScript

00:03:47,510 --> 00:03:56,300
engine it is built at Google for Chrome

00:03:50,060 --> 00:03:58,430
and it was open sourced in 2008 and here

00:03:56,300 --> 00:04:01,880
I have this really cool video that you

00:03:58,430 --> 00:04:04,220
can check out later is by Wars back who

00:04:01,880 --> 00:04:06,950
was the first tech lead for the v8

00:04:04,220 --> 00:04:11,240
project and what he said in that video

00:04:06,950 --> 00:04:14,090
is that v8 is not just something that

00:04:11,240 --> 00:04:17,290
chrome uses underneath you can actually

00:04:14,090 --> 00:04:22,070
take v8 as a standalone project and

00:04:17,290 --> 00:04:24,650
embed it at different place and this

00:04:22,070 --> 00:04:27,710
kind of worked out well because node.js

00:04:24,650 --> 00:04:30,440
embedded v8 and this is how we get

00:04:27,710 --> 00:04:32,300
JavaScript on the server and what we're

00:04:30,440 --> 00:04:34,580
trying to do in projects like native

00:04:32,300 --> 00:04:37,540
script is actually bring JavaScript the

00:04:34,580 --> 00:04:37,540
mobile world as well

00:04:37,840 --> 00:04:43,270
so native script a few words about me I

00:04:41,630 --> 00:04:46,460
am developer it's progress

00:04:43,270 --> 00:04:48,770
part of the native script team and so

00:04:46,460 --> 00:04:51,230
recently I became a GD for angular and

00:04:48,770 --> 00:04:52,880
12 technologies are important thing

00:04:51,230 --> 00:04:54,890
about me is that I love web pack I do

00:04:52,880 --> 00:04:57,530
quite a lot of web pack things in native

00:04:54,890 --> 00:04:59,480
script and this is I'm sure this is a

00:04:57,530 --> 00:05:03,050
wipeout carrier but as you can see I'm

00:04:59,480 --> 00:05:12,220
smiling because you have to accept these

00:05:03,050 --> 00:05:15,050
things all right back on native script I

00:05:12,220 --> 00:05:18,080
want a real story I read a short story

00:05:15,050 --> 00:05:21,130
and I know I mean it's kind of weird but

00:05:18,080 --> 00:05:25,700
I kind of had a long flight and then I

00:05:21,130 --> 00:05:28,550
actually wrote that story and then I

00:05:25,700 --> 00:05:31,130
could it's like 8% of it because it gets

00:05:28,550 --> 00:05:33,590
even more weird so that's just an

00:05:31,130 --> 00:05:34,610
explanation why why why it's like that

00:05:33,590 --> 00:05:36,890
anyway

00:05:34,610 --> 00:05:39,710
so we have the JavaScript world and we

00:05:36,890 --> 00:05:42,919
have these great magical creatures

00:05:39,710 --> 00:05:45,260
living in the JavaScript world not

00:05:42,919 --> 00:05:47,510
really technology technologically

00:05:45,260 --> 00:05:51,380
advanced but they know a lot of spells

00:05:47,510 --> 00:05:53,419
and they're kind of like elves but not

00:05:51,380 --> 00:05:55,760
like the Santa Claus

00:05:53,419 --> 00:05:57,860
kind of type but more like deals from

00:05:55,760 --> 00:06:01,310
worth of the Rings like magical handsome

00:05:57,860 --> 00:06:02,870
awesome creatures and so I don't think

00:06:01,310 --> 00:06:07,580
about the elves is that they're pretty

00:06:02,870 --> 00:06:10,310
expansive as a nation or tribe and they

00:06:07,580 --> 00:06:13,070
kinda expanded the browser world but

00:06:10,310 --> 00:06:17,210
here's the zero difference we shouldn't

00:06:13,070 --> 00:06:18,700
mix the terms browser and JavaScript

00:06:17,210 --> 00:06:21,260
because they are not interchangeable

00:06:18,700 --> 00:06:22,690
they're chinks in the browser which are

00:06:21,260 --> 00:06:25,910
not part of the JavaScript language

00:06:22,690 --> 00:06:30,320
obviously the most obvious difference is

00:06:25,910 --> 00:06:36,939
the DOM and HTML

00:06:30,320 --> 00:06:40,479
of course the someone say CSS

00:06:36,939 --> 00:06:43,909
we're gonna come back back to CSS later

00:06:40,479 --> 00:06:46,189
anyway another important world in our

00:06:43,909 --> 00:06:48,579
story is the Android world and the

00:06:46,189 --> 00:06:52,659
androids world obviously is populated by

00:06:48,579 --> 00:06:55,219
robots which have really great

00:06:52,659 --> 00:06:59,179
technological knowledge and they have a

00:06:55,219 --> 00:07:00,679
lot of native resources and native

00:06:59,179 --> 00:07:04,849
resource what is it

00:07:00,679 --> 00:07:08,149
so satellites geolocation Bluetooth

00:07:04,849 --> 00:07:09,619
camera augmented reality kids she

00:07:08,149 --> 00:07:12,919
warning kids basically everything you

00:07:09,619 --> 00:07:15,349
have on your phone today the Android

00:07:12,919 --> 00:07:20,359
people take it for granted and they have

00:07:15,349 --> 00:07:22,849
access to it so I'm doing a really but

00:07:20,359 --> 00:07:28,639
metaphor generate world use your mobile

00:07:22,849 --> 00:07:30,769
phone anyway so what is the deal the

00:07:28,639 --> 00:07:33,109
folks from the JavaScript world the

00:07:30,769 --> 00:07:34,819
elves are pretty expansive and they want

00:07:33,109 --> 00:07:37,899
to use the native resources from the

00:07:34,819 --> 00:07:41,360
Android world but they're not great

00:07:37,899 --> 00:07:46,159
diplomats I mean it's probably the whole

00:07:41,360 --> 00:07:50,029
Java JavaScript think anyway there is

00:07:46,159 --> 00:07:53,269
not a really easy way to use native

00:07:50,029 --> 00:07:56,629
resources from the Android world from

00:07:53,269 --> 00:07:58,549
JavaScript and this is the problem that

00:07:56,629 --> 00:08:02,509
we're trying to solve in native script

00:07:58,549 --> 00:08:04,969
and if I say we it's kind of weird

00:08:02,509 --> 00:08:08,269
because yet neither script has been part

00:08:04,969 --> 00:08:12,259
of my life for three years and a if I

00:08:08,269 --> 00:08:13,789
say we I mean the name script team and I

00:08:12,259 --> 00:08:16,999
know this is the same slide what I was

00:08:13,789 --> 00:08:19,339
too lazy to change it okay so shortly

00:08:16,999 --> 00:08:21,889
native script is a framework that allows

00:08:19,339 --> 00:08:24,549
you to build native mobile apps for

00:08:21,889 --> 00:08:27,139
Android and iOS with JavaScript or

00:08:24,549 --> 00:08:34,550
something a bit more sophisticated like

00:08:27,139 --> 00:08:36,649
your angular really short overview of

00:08:34,550 --> 00:08:38,809
the architecture obviously we have

00:08:36,649 --> 00:08:41,719
Android and iOS on the bottom we have

00:08:38,809 --> 00:08:44,839
may skip runtimes which allow us to have

00:08:41,719 --> 00:08:47,689
access to the native resources from

00:08:44,839 --> 00:08:50,480
JavaScript don't top that we have a

00:08:47,689 --> 00:08:54,110
common layer which unifies the end

00:08:50,480 --> 00:08:57,200
in the i/os api's so for example you've

00:08:54,110 --> 00:08:59,960
ever had to build user interface on

00:08:57,200 --> 00:09:02,330
android and user interface on iOS you

00:08:59,960 --> 00:09:05,870
would have realized that they're quite

00:09:02,330 --> 00:09:09,560
different so we provide a common

00:09:05,870 --> 00:09:12,140
layouting structure or system that

00:09:09,560 --> 00:09:14,660
allows you to write the same code and it

00:09:12,140 --> 00:09:18,830
should kind of work the same way on both

00:09:14,660 --> 00:09:21,410
Android and iOS on top of that we have a

00:09:18,830 --> 00:09:24,020
really really small layer for the

00:09:21,410 --> 00:09:27,590
application flavor framework which gives

00:09:24,020 --> 00:09:31,100
you data bindings and navigation and we

00:09:27,590 --> 00:09:33,890
also support angular and view and the

00:09:31,100 --> 00:09:37,100
last important bit is that if there is

00:09:33,890 --> 00:09:41,780
some library out there in the Android

00:09:37,100 --> 00:09:44,840
world you can just wrap that as a notes

00:09:41,780 --> 00:09:48,050
package ship it to NPM and anyone can

00:09:44,840 --> 00:09:51,920
npm install your package and use it in

00:09:48,050 --> 00:09:54,380
your native script app but today we're

00:09:51,920 --> 00:09:54,950
going to be focusing on the name Swift

00:09:54,380 --> 00:09:57,890
runtimes

00:09:54,950 --> 00:10:00,170
and how we access the native resources

00:09:57,890 --> 00:10:02,840
and more specifically we're going to

00:10:00,170 --> 00:10:06,410
focus on the Android runtime because

00:10:02,840 --> 00:10:08,800
this is where we embed v8 for iOS we

00:10:06,410 --> 00:10:13,930
actually embed another JavaScript engine

00:10:08,800 --> 00:10:13,930
JavaScript core which is used in Safari

00:10:13,960 --> 00:10:23,890
so native API access important thing

00:10:20,240 --> 00:10:26,480
about the elves they're not just like

00:10:23,890 --> 00:10:28,340
not advanced in technology they also

00:10:26,480 --> 00:10:31,400
don't have great scientific knowledge

00:10:28,340 --> 00:10:33,290
but that's fine so even if they had

00:10:31,400 --> 00:10:36,080
access to the native resources they

00:10:33,290 --> 00:10:39,530
wouldn't really know how to use them so

00:10:36,080 --> 00:10:41,810
what they do in that case is that they

00:10:39,530 --> 00:10:45,440
send out some spice in the Android world

00:10:41,810 --> 00:10:48,290
and these PI's gather information about

00:10:45,440 --> 00:10:49,700
the native resources so they go back to

00:10:48,290 --> 00:10:53,360
the JavaScript world with that

00:10:49,700 --> 00:10:57,800
information and now the elves know how

00:10:53,360 --> 00:10:59,840
to use the native resources but they

00:10:57,800 --> 00:11:01,910
have to get there so we're still not

00:10:59,840 --> 00:11:03,860
quite there but they know how to use the

00:11:01,910 --> 00:11:08,459
resources

00:11:03,860 --> 00:11:11,430
how does that look like in more boring

00:11:08,459 --> 00:11:14,970
way so we have a native library for

00:11:11,430 --> 00:11:20,399
example Android SDK or some animation

00:11:14,970 --> 00:11:23,449
library in Android we parse through the

00:11:20,399 --> 00:11:26,670
whole library to generate metadata

00:11:23,449 --> 00:11:29,370
basically we get every package every API

00:11:26,670 --> 00:11:31,829
did that's available and gathering

00:11:29,370 --> 00:11:34,860
information how we can use it so if

00:11:31,829 --> 00:11:37,860
there is some method we should know what

00:11:34,860 --> 00:11:40,680
how many arguments the method accepts

00:11:37,860 --> 00:11:43,019
what are their types what is the return

00:11:40,680 --> 00:11:48,300
type so we gather all that information

00:11:43,019 --> 00:11:54,300
and package that inside the application

00:11:48,300 --> 00:11:57,569
itself in some binary format and the

00:11:54,300 --> 00:11:59,970
application package itself is not very

00:11:57,569 --> 00:12:04,740
different from a regular Android

00:11:59,970 --> 00:12:06,990
application so we have just the Android

00:12:04,740 --> 00:12:11,370
application inside it we have the

00:12:06,990 --> 00:12:13,920
JavaScript code as some assets and 20q

00:12:11,370 --> 00:12:15,630
the JavaScript code we also have a

00:12:13,920 --> 00:12:18,329
library which contains the native

00:12:15,630 --> 00:12:23,610
scripts runtime and v8 which is the

00:12:18,329 --> 00:12:26,329
engine that can execute JavaScript we

00:12:23,610 --> 00:12:30,569
run the application the Weibull restarts

00:12:26,329 --> 00:12:31,920
we initialize v8 then we set up some

00:12:30,569 --> 00:12:36,420
callbacks that we're going to take a

00:12:31,920 --> 00:12:42,149
look at right the next slide and then we

00:12:36,420 --> 00:12:45,329
launch the regular Android activity and

00:12:42,149 --> 00:12:45,899
we have a normal Android up running so

00:12:45,329 --> 00:12:48,240
Kovaks

00:12:45,899 --> 00:12:51,680
very important if you are ever gonna

00:12:48,240 --> 00:12:54,779
embed v8 callbacks or everywhere

00:12:51,680 --> 00:12:57,720
first we have a field get a callback so

00:12:54,779 --> 00:13:00,149
con stop jack Tico's java.lang object is

00:12:57,720 --> 00:13:05,220
actually a valid JavaScript code in

00:13:00,149 --> 00:13:08,130
native script Java comes from something

00:13:05,220 --> 00:13:10,980
that we set on the v8 instance as a

00:13:08,130 --> 00:13:14,389
global object because it was inside the

00:13:10,980 --> 00:13:15,920
metadata so we know that we can access

00:13:14,389 --> 00:13:19,670
the Java

00:13:15,920 --> 00:13:26,509
or Java because it's available in the

00:13:19,670 --> 00:13:28,699
Android world java.lang is actually

00:13:26,509 --> 00:13:31,850
where the field Gator Quebec is attached

00:13:28,699 --> 00:13:34,309
so whenever someone calls java.lang from

00:13:31,850 --> 00:13:37,069
the JavaScript world we trigger that

00:13:34,309 --> 00:13:40,429
field get her callback and the Quebec

00:13:37,069 --> 00:13:43,639
finds the metadata inside the java.lang

00:13:40,429 --> 00:13:46,850
package and returns what is exactly

00:13:43,639 --> 00:13:48,129
there in that package what we can what

00:13:46,850 --> 00:13:51,769
we can use

00:13:48,129 --> 00:13:54,529
and finally Java rank object just

00:13:51,769 --> 00:14:02,299
returns the object class from the

00:13:54,529 --> 00:14:05,179
java.lang metadata kind of constructor

00:14:02,299 --> 00:14:07,299
Quebec okay whenever we try to create

00:14:05,179 --> 00:14:10,910
the new instance of something in the

00:14:07,299 --> 00:14:13,160
Android world we trigger a constructor

00:14:10,910 --> 00:14:16,100
callback which was placed there by the

00:14:13,160 --> 00:14:18,109
name super on time so the constructor

00:14:16,100 --> 00:14:21,679
Quebec creates the objects in generate

00:14:18,109 --> 00:14:24,350
world and it also creates a proxy object

00:14:21,679 --> 00:14:28,160
in the JavaScript world and then returns

00:14:24,350 --> 00:14:30,499
the proxy object the method Quebec

00:14:28,160 --> 00:14:33,110
okay so what is special about the proxy

00:14:30,499 --> 00:14:35,779
javascript object for example if we have

00:14:33,110 --> 00:14:37,639
two methods in the Java object and we're

00:14:35,779 --> 00:14:41,389
going to have exactly the same methods

00:14:37,639 --> 00:14:45,169
in the JavaScript object and in these

00:14:41,389 --> 00:14:47,629
methods we attach a method call back so

00:14:45,169 --> 00:14:49,699
whenever someone calls that method on

00:14:47,629 --> 00:14:52,220
the JavaScript object it's going to

00:14:49,699 --> 00:14:54,019
trigger that Quebec in the Quebec is

00:14:52,220 --> 00:14:58,489
actually gonna called the original Java

00:14:54,019 --> 00:15:02,029
method and after it's caught we're going

00:14:58,489 --> 00:15:04,779
to get some results and we're gonna pass

00:15:02,029 --> 00:15:07,429
it back and this is a more of an

00:15:04,779 --> 00:15:09,499
implementation detail but we can't

00:15:07,429 --> 00:15:13,339
actually just pass back the return

00:15:09,499 --> 00:15:16,850
result to the JavaScript function but we

00:15:13,339 --> 00:15:20,720
have to set the result as a return

00:15:16,850 --> 00:15:26,419
argument of that proxy function or

00:15:20,720 --> 00:15:29,870
method okay so so far we know that we

00:15:26,419 --> 00:15:32,330
have metadata but it is exactly

00:15:29,870 --> 00:15:35,990
it's actually not enough to have

00:15:32,330 --> 00:15:39,410
metadata in order to call stuff on the

00:15:35,990 --> 00:15:42,050
native Android world so we're using

00:15:39,410 --> 00:15:46,160
something called j'ni or Java native

00:15:42,050 --> 00:15:48,560
interface and because currently we

00:15:46,160 --> 00:15:50,540
started v8 this one virtual machine we

00:15:48,560 --> 00:15:55,220
also have the dalvik virtual machine

00:15:50,540 --> 00:15:58,910
running on the Android device J&I is the

00:15:55,220 --> 00:16:01,010
thing that passes all calls from the

00:15:58,910 --> 00:16:04,160
JavaScript virtual machine down to the

00:16:01,010 --> 00:16:08,450
Java Virtual Machine and the same way

00:16:04,160 --> 00:16:12,830
back this is the actual bridge if you

00:16:08,450 --> 00:16:16,340
ever heard of a bridge inside of native

00:16:12,830 --> 00:16:18,800
script okay but there's a little

00:16:16,340 --> 00:16:21,920
complication here what happens if the

00:16:18,800 --> 00:16:23,320
Java object the Java method returns a

00:16:21,920 --> 00:16:27,050
string

00:16:23,320 --> 00:16:30,680
well the shrink is gonna be of type Java

00:16:27,050 --> 00:16:35,090
long string which is definitely not the

00:16:30,680 --> 00:16:36,980
same as a JavaScript string or a string

00:16:35,090 --> 00:16:39,500
object or even a string a string

00:16:36,980 --> 00:16:43,250
primitive they're just two different

00:16:39,500 --> 00:16:46,190
data formats that's why we need some

00:16:43,250 --> 00:16:49,340
kind of marshaling service that can

00:16:46,190 --> 00:16:53,920
convert data from the Java world to the

00:16:49,340 --> 00:16:57,140
JavaScript world and vice versa and

00:16:53,920 --> 00:16:59,750
maybe you'd ask if you think more about

00:16:57,140 --> 00:17:03,050
it what about objects I mean wouldn't it

00:16:59,750 --> 00:17:06,079
be terribly slow if we start converting

00:17:03,050 --> 00:17:08,720
objects from the Java world back to

00:17:06,079 --> 00:17:11,540
JavaScript well I should this is why we

00:17:08,720 --> 00:17:16,130
create proxies this and of course

00:17:11,540 --> 00:17:22,030
attaching method call backs so we use

00:17:16,130 --> 00:17:24,880
smush ring for primitives and arrays and

00:17:22,030 --> 00:17:29,210
obviously the marshaling service and

00:17:24,880 --> 00:17:31,490
j'ni are c-3po in our already weird

00:17:29,210 --> 00:17:33,620
story because c-3po is a protocol droid

00:17:31,490 --> 00:17:39,460
so it translates messages back and forth

00:17:33,620 --> 00:17:39,460
and yeah really proud of that comparison

00:17:39,580 --> 00:17:45,990
so let's see very quickly how that works

00:17:43,320 --> 00:17:48,980
we're trying to instantiate a new native

00:17:45,990 --> 00:17:51,509
object we call the constructor callback

00:17:48,980 --> 00:17:55,799
this requests an instance of the class

00:17:51,509 --> 00:17:59,009
from the Android virtual machine we get

00:17:55,799 --> 00:18:00,809
back the instance of the class we return

00:17:59,009 --> 00:18:04,769
which way the JavaScript proxy object

00:18:00,809 --> 00:18:08,639
and return it back then we try to call

00:18:04,769 --> 00:18:11,480
some method we come Kody method callback

00:18:08,639 --> 00:18:15,059
that was attached on the proxy object

00:18:11,480 --> 00:18:18,419
then through the method callback we call

00:18:15,059 --> 00:18:21,120
the actual native method we get back the

00:18:18,419 --> 00:18:25,289
result from the Java world and then

00:18:21,120 --> 00:18:29,580
convert it to a JavaScript data format

00:18:25,289 --> 00:18:33,360
and assign it to the variable so far so

00:18:29,580 --> 00:18:36,750
good okay we're ready for I have no idea

00:18:33,360 --> 00:18:37,529
how much time I have it's just getting

00:18:36,750 --> 00:18:42,720
interesting

00:18:37,529 --> 00:18:49,440
cool let's talk about multi-threading in

00:18:42,720 --> 00:18:54,059
JavaScript weird cool I will try to

00:18:49,440 --> 00:18:58,679
explain the term junk or there are a lot

00:18:54,059 --> 00:19:00,779
of ways to code that behavior but here's

00:18:58,679 --> 00:19:05,190
the thing most of the devices that we're

00:19:00,779 --> 00:19:08,159
using nowadays have to draw something 60

00:19:05,190 --> 00:19:12,720
times per second on the screen so this

00:19:08,159 --> 00:19:15,450
is what we call a frame rate the frame

00:19:12,720 --> 00:19:18,299
rate of a usual device nowadays is 60

00:19:15,450 --> 00:19:21,480
frames per second and that means that we

00:19:18,299 --> 00:19:25,009
basically have 16 milliseconds to draw a

00:19:21,480 --> 00:19:27,539
single frame on the device and that

00:19:25,009 --> 00:19:30,000
means that whatever computations we are

00:19:27,539 --> 00:19:31,649
doing right now we have to finish in 16

00:19:30,000 --> 00:19:32,639
milliseconds and be ready to draw

00:19:31,649 --> 00:19:35,129
something on the screen

00:19:32,639 --> 00:19:37,549
and of course 60 milliseconds is the

00:19:35,129 --> 00:19:40,919
upper bound because there may be other

00:19:37,549 --> 00:19:44,220
computations happening and this may be

00:19:40,919 --> 00:19:47,340
actually down to 10 milliseconds in the

00:19:44,220 --> 00:19:51,120
browser which is not a lot of time and

00:19:47,340 --> 00:19:56,010
so what happens if we fail to meet that

00:19:51,120 --> 00:19:57,320
10 milliseconds well we drop a frame or

00:19:56,010 --> 00:20:03,900
we skip a frame

00:19:57,320 --> 00:20:06,360
and when we start skipping frames where

00:20:03,900 --> 00:20:09,900
things start to happen and this is the

00:20:06,360 --> 00:20:15,630
term junk I'm gonna put that on a really

00:20:09,900 --> 00:20:21,600
slow motion so that we can see the

00:20:15,630 --> 00:20:24,210
actual animation cool awesome so here we

00:20:21,600 --> 00:20:28,790
have a really smooth animation running

00:20:24,210 --> 00:20:31,410
in 60 frames per second focus on D I

00:20:28,790 --> 00:20:39,059
just realized this is a beard

00:20:31,410 --> 00:20:42,450
I told it's a scarf anyway yeah so focus

00:20:39,059 --> 00:20:46,080
on the beards 60 frames per seconds

00:20:42,450 --> 00:20:49,740
looks pretty cool here it kind of keeps

00:20:46,080 --> 00:20:52,260
a few frames right 15 frames per second

00:20:49,740 --> 00:20:54,480
you can definitely see the difference

00:20:52,260 --> 00:20:57,240
between this animation and this

00:20:54,480 --> 00:20:59,520
animation so this is called junk and

00:20:57,240 --> 00:21:05,700
it's very obvious when you start

00:20:59,520 --> 00:21:11,610
scrolling and the list just steps or

00:21:05,700 --> 00:21:14,220
lags cool why is that important well we

00:21:11,610 --> 00:21:17,070
run the JavaScript in native script on a

00:21:14,220 --> 00:21:20,970
single thread and that is obviously the

00:21:17,070 --> 00:21:24,270
user interface thread so that might

00:21:20,970 --> 00:21:24,750
cause junk in some cases it won't cause

00:21:24,270 --> 00:21:28,650
jank

00:21:24,750 --> 00:21:32,490
if you're using native script the right

00:21:28,650 --> 00:21:34,350
way no if you're building user interface

00:21:32,490 --> 00:21:36,840
you won't have any problem because

00:21:34,350 --> 00:21:39,620
native script is using native components

00:21:36,840 --> 00:21:41,730
underneath if you're building animations

00:21:39,620 --> 00:21:43,830
that won't be a problem because

00:21:41,730 --> 00:21:47,130
underneath we're using native animations

00:21:43,830 --> 00:21:49,710
and so on and so on but it will cause

00:21:47,130 --> 00:21:51,990
gen if you're executing CPU intensive

00:21:49,710 --> 00:21:54,809
operations for example if you're trying

00:21:51,990 --> 00:21:57,690
to calculate Fibonacci numbers in a very

00:21:54,809 --> 00:21:59,390
an optimized way which is something we

00:21:57,690 --> 00:22:03,240
do in our everyday lives

00:21:59,390 --> 00:22:05,220
perfect example so this would cause Jan

00:22:03,240 --> 00:22:09,660
because it will stress the main trait

00:22:05,220 --> 00:22:10,770
and the matron won't be able to to put

00:22:09,660 --> 00:22:14,370
out

00:22:10,770 --> 00:22:17,130
you know 60 frames per second so how do

00:22:14,370 --> 00:22:22,170
we solve that problem in JavaScript

00:22:17,130 --> 00:22:23,490
well the browser has web workers and in

00:22:22,170 --> 00:22:25,790
native script we call them worker

00:22:23,490 --> 00:22:28,830
threads but basically they're just

00:22:25,790 --> 00:22:31,680
background threads or separate threads

00:22:28,830 --> 00:22:38,070
than the user interface thread in the

00:22:31,680 --> 00:22:40,020
JavaScript world okay the deal with the

00:22:38,070 --> 00:22:42,270
worker threads is that you can create

00:22:40,020 --> 00:22:44,910
them they can do some computations in

00:22:42,270 --> 00:22:47,730
the background and then they can return

00:22:44,910 --> 00:22:52,050
some result that's the whole the whole

00:22:47,730 --> 00:22:54,300
thing the downsides in a new script is

00:22:52,050 --> 00:22:56,940
that you can't share JavaScript memory

00:22:54,300 --> 00:23:00,090
you can actually share native objects

00:22:56,940 --> 00:23:02,460
and also the communication is limited so

00:23:00,090 --> 00:23:06,810
you it's not a great idea to return

00:23:02,460 --> 00:23:11,400
really large objects or recursive

00:23:06,810 --> 00:23:14,690
objects also can't be returned okay some

00:23:11,400 --> 00:23:18,300
VA time the really interesting thing

00:23:14,690 --> 00:23:20,910
what is the nice relate to v8 well this

00:23:18,300 --> 00:23:23,850
is a running instance of the engine and

00:23:20,910 --> 00:23:26,120
is actually a v8 way to allocate memory

00:23:23,850 --> 00:23:29,460
for some script that's running and

00:23:26,120 --> 00:23:33,990
isolate that memory so it can't be

00:23:29,460 --> 00:23:36,870
accessed from other processes and also

00:23:33,990 --> 00:23:42,650
you can have many isolates and they can

00:23:36,870 --> 00:23:45,690
run in parallel another similar term or

00:23:42,650 --> 00:23:48,770
related term is a context one isolate

00:23:45,690 --> 00:23:52,050
can have multiple contexts the context

00:23:48,770 --> 00:23:54,270
can run in parallel so basically when

00:23:52,050 --> 00:23:56,910
when you're running a script in an

00:23:54,270 --> 00:23:59,280
isolate you should explicitly specify

00:23:56,910 --> 00:24:03,890
the the context what is the constant

00:23:59,280 --> 00:24:06,720
context right now so how do you think we

00:24:03,890 --> 00:24:14,520
implemented worker threads with isolates

00:24:06,720 --> 00:24:16,760
or with context isolates contexts we

00:24:14,520 --> 00:24:20,630
didn't implement

00:24:16,760 --> 00:24:24,460
okay well the answer is isolate and

00:24:20,630 --> 00:24:33,500
everyone raised their hint was no one

00:24:24,460 --> 00:24:35,690
guessed right cool so worker traits are

00:24:33,500 --> 00:24:39,710
isolates basically you create a new

00:24:35,690 --> 00:24:42,650
instance of v8 you attach some callbacks

00:24:39,710 --> 00:24:44,600
or that G to isolate can communicate and

00:24:42,650 --> 00:24:47,120
that's how we have worker threads and

00:24:44,600 --> 00:24:49,130
the way they work in browsers is pretty

00:24:47,120 --> 00:24:53,960
similar okay

00:24:49,130 --> 00:24:56,929
lasting snapshots let's talk about time

00:24:53,960 --> 00:25:01,910
and I don't mean that I'm running out of

00:24:56,929 --> 00:25:05,120
time although that's true but what takes

00:25:01,910 --> 00:25:08,390
time in a mobile applications and more

00:25:05,120 --> 00:25:12,559
specifically what takes time on startup

00:25:08,390 --> 00:25:15,280
well obviously on the mobile device we

00:25:12,559 --> 00:25:18,830
don't have Network requests all the

00:25:15,280 --> 00:25:20,750
scripts that we're running when we're

00:25:18,830 --> 00:25:23,030
starting the applications are already on

00:25:20,750 --> 00:25:25,160
the device but we have to get them from

00:25:23,030 --> 00:25:29,480
the file system so that takes time if

00:25:25,160 --> 00:25:33,370
there are many files also parsing and

00:25:29,480 --> 00:25:38,809
compiling JavaScript takes time because

00:25:33,370 --> 00:25:41,000
JavaScript engines and how do we solve

00:25:38,809 --> 00:25:42,860
the problem they actually these two

00:25:41,000 --> 00:25:45,740
things can take quite a lot of time and

00:25:42,860 --> 00:25:49,280
this is a screenshot from two years ago

00:25:45,740 --> 00:25:52,429
and at the time that was how much it

00:25:49,280 --> 00:25:55,120
took to start an a script application in

00:25:52,429 --> 00:25:58,850
a very an optimized way of course and

00:25:55,120 --> 00:26:03,679
two seconds just to load the JavaScript

00:25:58,850 --> 00:26:06,679
up the app it's kind of weird so how do

00:26:03,679 --> 00:26:09,770
we solve that problem first we can

00:26:06,679 --> 00:26:12,500
borrow our app so we can use a tool like

00:26:09,770 --> 00:26:16,370
web pack to get all of our millions of

00:26:12,500 --> 00:26:20,600
files in our application and output a

00:26:16,370 --> 00:26:22,700
few files for example - so that way we

00:26:20,600 --> 00:26:24,919
won't be making millions of file

00:26:22,700 --> 00:26:27,940
requests on startup we were making just

00:26:24,919 --> 00:26:27,940
two file requests

00:26:28,780 --> 00:26:33,100
person compiled obviously we can skip

00:26:31,120 --> 00:26:35,740
that part we just have to isolate our

00:26:33,100 --> 00:26:38,080
JavaScript code somehow but there is

00:26:35,740 --> 00:26:40,150
this trick which is called custom

00:26:38,080 --> 00:26:42,040
startup snapshots which is a really

00:26:40,150 --> 00:26:45,790
great feature provided by the v8 engine

00:26:42,040 --> 00:26:48,750
and I'm not sure if it's the only one

00:26:45,790 --> 00:26:52,680
but it's definitely not provided by JSC

00:26:48,750 --> 00:26:55,750
that's why we have it only on Android so

00:26:52,680 --> 00:26:57,580
the way it works is that you take a

00:26:55,750 --> 00:27:01,120
JavaScript file you run it through some

00:26:57,580 --> 00:27:03,940
generation tool that outputs that

00:27:01,120 --> 00:27:06,430
executes the code and then you take

00:27:03,940 --> 00:27:09,340
basically a snapshot of the heap at the

00:27:06,430 --> 00:27:12,940
current time and output that in some

00:27:09,340 --> 00:27:14,650
binary file and the binary file gets in

00:27:12,940 --> 00:27:18,190
your file pack in your application

00:27:14,650 --> 00:27:21,250
package and when you start the app you

00:27:18,190 --> 00:27:24,670
load the snapshot binary you set some

00:27:21,250 --> 00:27:27,010
parameters for the isolates passing

00:27:24,670 --> 00:27:28,840
these snapshots binary and then when you

00:27:27,010 --> 00:27:31,390
create the new isolate you can basically

00:27:28,840 --> 00:27:34,270
instruct it to create the new context

00:27:31,390 --> 00:27:36,610
from the already loaded heap so it

00:27:34,270 --> 00:27:37,360
doesn't have to load the JavaScript from

00:27:36,610 --> 00:27:40,300
the filesystem

00:27:37,360 --> 00:27:43,660
compile it parse it whatever it does

00:27:40,300 --> 00:27:48,520
underneath and it basically takes these

00:27:43,660 --> 00:27:51,100
two seconds to zero and this is a little

00:27:48,520 --> 00:27:53,950
bit of code and if you're interested and

00:27:51,100 --> 00:27:56,080
not it's not going to read it obviously

00:27:53,950 --> 00:27:57,760
because I don't have time but you can

00:27:56,080 --> 00:28:01,660
find it in the slides later I'm going to

00:27:57,760 --> 00:28:03,970
share them and this section is C++ code

00:28:01,660 --> 00:28:06,070
but the idea of the that code here was

00:28:03,970 --> 00:28:10,650
that it's not that hard to get a grasp

00:28:06,070 --> 00:28:17,320
of how you can embed v8 it's it's free

00:28:10,650 --> 00:28:20,340
actually understandable API okay what

00:28:17,320 --> 00:28:23,020
are the limitations of the snapshots

00:28:20,340 --> 00:28:25,660
basically we are executing the code at

00:28:23,020 --> 00:28:28,420
Build time so we don't have any access

00:28:25,660 --> 00:28:32,740
to the native funds rate or whatever API

00:28:28,420 --> 00:28:36,690
is also we don't have require and I

00:28:32,740 --> 00:28:36,690
don't have time to explain that but

00:28:37,200 --> 00:28:41,580
finally later I can talk to you about

00:28:39,790 --> 00:28:45,840
require where does it

00:28:41,580 --> 00:28:49,230
from and why it's not a JavaScript

00:28:45,840 --> 00:28:52,350
Tinky actually anyway also third-party

00:28:49,230 --> 00:28:54,360
codes can break the snapshots because

00:28:52,350 --> 00:28:56,880
we're not sure if the third-party code

00:28:54,360 --> 00:29:00,450
is now trying to access something which

00:28:56,880 --> 00:29:02,820
is not available at Build time so how

00:29:00,450 --> 00:29:06,330
can we solve that first we can wrap

00:29:02,820 --> 00:29:09,600
native API access here obviously we're

00:29:06,330 --> 00:29:12,330
trying to access new Android text format

00:29:09,600 --> 00:29:15,240
time and if we execute that in a better

00:29:12,330 --> 00:29:17,460
context without metadata without j'ni we

00:29:15,240 --> 00:29:19,590
don't have hundred so this is going to

00:29:17,460 --> 00:29:22,230
throw an error the way to fix that is

00:29:19,590 --> 00:29:26,490
just to wrap that in a getter function

00:29:22,230 --> 00:29:28,710
and you get the time lazily inside the

00:29:26,490 --> 00:29:34,830
other function that does some

00:29:28,710 --> 00:29:37,170
complicated things does the audio and if

00:29:34,830 --> 00:29:39,150
you're really lazy I don't have time to

00:29:37,170 --> 00:29:42,570
explain that code but you can create

00:29:39,150 --> 00:29:44,790
getters like that I'm gonna give you

00:29:42,570 --> 00:29:47,550
just a few seconds to wrap your hand

00:29:44,790 --> 00:29:52,560
around the first thing it's a very

00:29:47,550 --> 00:29:58,230
interesting function yeah I still don't

00:29:52,560 --> 00:30:00,690
get it anyway so it is that you have to

00:29:58,230 --> 00:30:05,390
be lazy when trying to access in 85

00:30:00,690 --> 00:30:09,990
years and just really quick reference

00:30:05,390 --> 00:30:12,000
the editor item is using snapshots to

00:30:09,990 --> 00:30:14,250
optimize their startup time as well and

00:30:12,000 --> 00:30:20,360
they have a great blog post on how they

00:30:14,250 --> 00:30:22,770
used keep snapshots to to do that and

00:30:20,360 --> 00:30:24,210
garbage collection and obviously if I

00:30:22,770 --> 00:30:27,210
start talking about garbage collection

00:30:24,210 --> 00:30:30,180
right now we can just flow into the next

00:30:27,210 --> 00:30:32,610
day and if you're interesting in how

00:30:30,180 --> 00:30:37,320
we're trying to synchronize to garbage

00:30:32,610 --> 00:30:39,420
collectors the v8s one and Avex one you

00:30:37,320 --> 00:30:43,470
can check out this blog post it's a very

00:30:39,420 --> 00:30:45,400
interesting problem and that was it

00:30:43,470 --> 00:30:47,460
thank you

00:30:45,400 --> 00:30:47,460

YouTube URL: https://www.youtube.com/watch?v=yde3oKsWltw


