Title: Decoupling Applications from Architectures - Jeff Hoffer - JSConf US 2019
Publication date: 2019-09-12
Playlist: JSConf US 2019
Description: 
	Software is the most malleable building material we've ever created, and yet Technical Debt continues to plague the choices we make when building applications.

When we talk about starting new projects, there's always a debate over getting something out the door knowing we're taking on Technical Debt in order to "move faster" versus taking our time to build it properly and risk over-engineering and possibly overfitting our application to an unknown problem. Can we avoid this Kobayashi Maru?

Like what Docker did to decouple the Infrastructure Layer from the Application Layer, we can decouple the Business Application from its Technical Architecture.

From 20 years of experience building software applications for different domains, I'll use many code samples and example applications to show how we can change the technical architectural choices of without affecting the business logic, and prove it's possible to decouple the application from the architecture so we can be fast and build it right.
Captions: 
	00:00:00,110 --> 00:00:03,679
Decoupling Applications from Architectures - Jeff Hoffer

00:00:03,679 --> 00:00:05,480
Hello, all right.

00:00:05,480 --> 00:00:06,910
Thank you everybody for coming.

00:00:06,910 --> 00:00:15,780
My name is Jeff Hoffer, and my talk is decoupling applications from architecture.

00:00:15,780 --> 00:00:24,040
I gave a talk on this side last year and there was literally 10% of the people in the room

00:00:24,040 --> 00:00:26,950
that there is now, so thank you all for showing up.

00:00:26,950 --> 00:00:28,710
I really appreciate it.

00:00:28,710 --> 00:00:35,870
The lights are really bright so I can't see anybody's face, which is probably a good thing.

00:00:35,870 --> 00:00:40,370
All right.

00:00:40,370 --> 00:00:42,560
So a little bit more about me.

00:00:42,560 --> 00:00:49,290
I've been professionally developing software for 20 years, and I recently joined a company

00:00:49,290 --> 00:00:52,649
called bluebeam.

00:00:52,649 --> 00:01:06,440
It's for the design bid and build phases of projects.

00:01:06,440 --> 00:01:15,030
You can find me on GitHub at @eudaimos, it's a word I made up, kind of.

00:01:15,030 --> 00:01:24,540
It was inspired by Aristotle's eudaiminea.

00:01:24,540 --> 00:01:34,670
The inspiration is my son Eric who's here with my wife this week, if you see us around,

00:01:34,670 --> 00:01:42,590
he's nine now, please say hi.

00:01:42,590 --> 00:01:48,979
So it's appropriate that I work in a software company for construction.

00:01:48,979 --> 00:01:55,479
I notice that as human beings, we've been in the practice of building things for a long

00:01:55,479 --> 00:01:57,909
time.

00:01:57,909 --> 00:02:02,979
We built some amazing things that have stood the test of time, beyond which most of us

00:02:02,979 --> 00:02:09,050
can even conceptualize the length of that time.

00:02:09,050 --> 00:02:15,340
And with software we've come up with a single-most malleable thing which we've ever had to build

00:02:15,340 --> 00:02:21,500
anything, and it's been pretty great.

00:02:21,500 --> 00:02:25,090
But still there's something not quite right.

00:02:25,090 --> 00:02:34,510
When I worked in Santa Monica, there was a lot of construction nearby all the time, and

00:02:34,510 --> 00:02:39,840
as we were walking our VP of Engineering, my boss used to point out how quickly they

00:02:39,840 --> 00:02:46,120
could build these buildings versus how long it took us to deliver software.

00:02:46,120 --> 00:02:53,360
[laughter] So how do we keep ending up here?

00:02:53,360 --> 00:02:59,519
[laughter] We either build it too slow, we build it wrong,

00:02:59,519 --> 00:03:03,350
or both.

00:03:03,350 --> 00:03:07,670
And how does that happen?

00:03:07,670 --> 00:03:13,940
We get asks from people who don't really know the difference between building application

00:03:13,940 --> 00:03:17,989
and building it well.

00:03:17,989 --> 00:03:23,710
But they want to make sure that we don't build it well, sometimes.

00:03:23,710 --> 00:03:31,330
That' d be great.

00:03:31,330 --> 00:03:39,440
So we end up in this Kobayashi Maru scenario and for the younger folks out there who haven't

00:03:39,440 --> 00:03:42,849
seen Star Trek II.

00:03:42,849 --> 00:03:49,100
It's designed to be a no-win scenario.

00:03:49,100 --> 00:03:56,560
It's there to determine how we will respond, and unfortunately most of our responses are

00:03:56,560 --> 00:04:01,989
this.

00:04:01,989 --> 00:04:09,290
[laughter] Where the needs of the many outweigh the needs

00:04:09,290 --> 00:04:14,260
of the few, right?

00:04:14,260 --> 00:04:27,119
And then we get back to our brittle code.

00:04:27,119 --> 00:04:31,279
So what do I mean exactly by application versus architecture?

00:04:31,279 --> 00:04:34,340
So we should probably define this.

00:04:34,340 --> 00:04:43,240
And we can take a step and define it based on who defines each for our software.

00:04:43,240 --> 00:04:49,300
Product team will define what the application does, engineers will build it, QA validate.

00:04:49,300 --> 00:04:52,809
Engineers work with software architects to define the needs.

00:04:52,809 --> 00:05:01,729
They build the architecture, QA validates nonfunctional constraints.

00:05:01,729 --> 00:05:07,210
So I'd like to take this and define these as layers.

00:05:07,210 --> 00:05:12,340
So we have an application we call that the development layer and architecture is the

00:05:12,340 --> 00:05:14,069
architecture layer.

00:05:14,069 --> 00:05:20,669
And if we can organize these into layers, then we can separate them like what Docker

00:05:20,669 --> 00:05:26,279
was able to do for apps in DevOps.

00:05:26,279 --> 00:05:29,809
There's also four aspects of software.

00:05:29,809 --> 00:05:37,399
Taking another view here, what an application represents to a user, how it does its job,

00:05:37,399 --> 00:05:45,029
where it executes, and when it does what it's designed to do.

00:05:45,029 --> 00:05:51,990
Unfortunately, when working between the development and architecture layers, we commingle these

00:05:51,990 --> 00:05:58,099
four aspects into a kind of a mess.

00:05:58,099 --> 00:06:02,849
So let's go back to our layer definition and define them using these four aspects.

00:06:02,849 --> 00:06:11,399
If we say the development layer is the what and the when, and the architecture layer is

00:06:11,399 --> 00:06:16,710
how and where.

00:06:16,710 --> 00:06:23,499
We can organize them this way and if we can organize them this way, along these layers,

00:06:23,499 --> 00:06:31,520
and make them orthogonal to each other, then we have the decoupling we're looking for.

00:06:31,520 --> 00:06:36,309
So if we take these aspects and graft them on to our layers, the development layer has

00:06:36,309 --> 00:06:44,400
what the context of the application is for a user, when does a user go from one context

00:06:44,400 --> 00:06:47,399
to another.

00:06:47,399 --> 00:06:53,249
architecturally how will the app move from context to context and where will the code

00:06:53,249 --> 00:06:58,270
reacting to this actually execute?

00:06:58,270 --> 00:07:03,619
So if we get into the details of that so that it actually matters to us who have to build

00:07:03,619 --> 00:07:11,059
this stuff, we can borrow some concepts from computer science where we say the what these

00:07:11,059 --> 00:07:19,270
contexts are signals, when is triggering and the reaction to these signals.

00:07:19,270 --> 00:07:26,159
And the how is -- and the where is a signal network and the implementation of where that

00:07:26,159 --> 00:07:34,499
signal network will run.

00:07:34,499 --> 00:07:38,860
So I want to introduce a few things for the demo first.

00:07:38,860 --> 00:07:40,020
There's RealWorld.

00:07:40,020 --> 00:07:52,619
If you haven't gone to realworld.io, it's beyond a standard to do app.

00:07:52,619 --> 00:07:58,439
It involves conduit which is a Medium-like blog platform and there's lots of concepts

00:07:58,439 --> 00:08:04,211
which are integrating different front ends and different back ends all doing basically

00:08:04,211 --> 00:08:08,059
the same functionality as this Conduit app.

00:08:08,059 --> 00:08:12,330
I also wanted to introduce TAO.js.

00:08:12,330 --> 00:08:20,439
There's a project that I've been working on as a solution for this.

00:08:20,439 --> 00:08:29,589
It has a meta language for defining signals that end up in the code, using trigrams.

00:08:29,589 --> 00:08:41,909
It provides interaction primitives to determine when to interact with these signals 

00:08:41,909 --> 00:08:48,550
and it implements signal networks.

00:08:48,550 --> 00:08:59,279
So a trigram, the library TAO actually comes from term action orient, so we want to describe

00:08:59,279 --> 00:09:03,279
these contexts with these three dimensions.

00:09:03,279 --> 00:09:09,290
So term is something, action is an action taking place, and orientation -- orient is

00:09:09,290 --> 00:09:12,540
a perspective.

00:09:12,540 --> 00:09:19,160
Three ways to interact and respond to signals is inline, do them in order.

00:09:19,160 --> 00:09:24,310
Async, do it in parallel as a side effect.

00:09:24,310 --> 00:09:32,350
And intercept is do it first and optionally you can interrupt the flow.

00:09:32,350 --> 00:09:39,891
And implementing signal networks, it abstracts that away from the application code, and it

00:09:39,891 --> 00:09:52,410
also has the implements a signal chaining, so that if you are reacting to a signal from

00:09:52,410 --> 00:09:59,170
the network, you can provide it with another signal that will chain itself, so this gives

00:09:59,170 --> 00:10:05,910
us very small bits of code that we can implement now as it -- using the signal network as the

00:10:05,910 --> 00:10:12,550
medium for the interaction.

00:10:12,550 --> 00:10:21,500
So taking this back to our notion of aspects to layers and now to TAO.js, what we're able

00:10:21,500 --> 00:10:28,439
to do with the development layer using TAO.js is the powers that engineers use to define

00:10:28,439 --> 00:10:39,540
these trigrams and define the desired behaviors when these are signaled in the signal network.

00:10:39,540 --> 00:10:45,240
The engineers implement these behaviors in the code using these interaction primitives

00:10:45,240 --> 00:10:46,889
on the signal network.

00:10:46,889 --> 00:10:55,980
And the architectural layer, we allow the architect or whoever's implementing the architecture

00:10:55,980 --> 00:11:01,649
to choose the signal network, and implement using that, and decide where that signal network

00:11:01,649 --> 00:11:08,370
will run, so we've now abstracted away where the code has to run in order to interact and

00:11:08,370 --> 00:11:12,720
provide the development layer with what it needs.

00:11:12,720 --> 00:11:21,579
A quick note about trigrams versus an application context, so think of a trigram, it's a 3-dimensional

00:11:21,579 --> 00:11:26,330
signal, also an event.

00:11:26,330 --> 00:11:31,980
You can subscribe to trigrams on the signal network and it's like a class in an OOP where

00:11:31,980 --> 00:11:40,029
ar application context would be an object in OOP, and so it's a specific context and

00:11:40,029 --> 00:11:47,540
so it combines this trigram with the actual data associated with the event that's happening

00:11:47,540 --> 00:11:52,190
the signal.

00:11:52,190 --> 00:11:59,279
So when going through the real world conduit application, what we'll do first is define

00:11:59,279 --> 00:12:00,279
the terms.

00:12:00,279 --> 00:12:05,769
We have an app, user, article, comment.

00:12:05,769 --> 00:12:15,660
We'll define some actions, init, load, find, exit.

00:12:15,660 --> 00:12:21,220
We'll define the orientation so we have a portal and an anonymous orientation, so portal

00:12:21,220 --> 00:12:22,379
is when you're logged in.

00:12:22,379 --> 00:12:27,600
Anonymous is when you're not.

00:12:27,600 --> 00:12:31,339
And then we'll define some paths.

00:12:31,339 --> 00:12:37,350
This allows us to understand how to react to signals on the network, and then throwback

00:12:37,350 --> 00:12:41,970
new signals in order to keep this chain going.

00:12:41,970 --> 00:12:50,560
And this is why we also develop or define very granular actions, so that we can have

00:12:50,560 --> 00:12:58,579
more granular chains and we can hook into these at any time.

00:12:58,579 --> 00:13:02,319
So I'm going to go into the demo portion.

00:13:02,319 --> 00:13:04,189
OK.

00:13:04,189 --> 00:13:10,720
So we're going to start with our Conduit app.

00:13:10,720 --> 00:13:19,269
And -- of course! [laughter]

00:13:19,269 --> 00:13:22,120
OK.

00:13:22,120 --> 00:13:33,529
Oh, I understand why.

00:13:33,529 --> 00:13:39,230
All right.

00:13:39,230 --> 00:13:48,899
Um, so this is working with their -- with the default API, which is using a service

00:13:48,899 --> 00:13:51,600
somewhere.

00:13:51,600 --> 00:14:00,089
And we're going to -- oops, wrong one.

00:14:00,089 --> 00:14:01,509
Sorry.

00:14:01,509 --> 00:14:19,480
Of course this all worked in the room.

00:14:19,480 --> 00:15:07,560
(Whispers) now completely broken.

00:15:07,560 --> 00:15:46,490
So I'm going to skip showing it as a ... because it doesn't seem to want to behave with Redux.

00:15:46,490 --> 00:15:50,139
So it was a Redux React based application.

00:15:50,139 --> 00:16:32,199
That still doesn't want to play nice.

00:16:32,199 --> 00:16:34,249
Very sorry for this.

00:16:34,249 --> 00:16:37,470
AUDIENCE: You got it!

00:16:37,470 --> 00:16:39,079
>> Thank you.

00:16:39,079 --> 00:16:41,459
I can't see who you are.

00:16:41,459 --> 00:16:43,870
But thank you.

00:16:43,870 --> 00:16:57,959
All right, let's just turn all of it on.

00:16:57,959 --> 00:17:12,110
Anybody know which screen I'm on?

00:17:12,110 --> 00:17:23,899
I can't imagine what changed.

00:17:23,899 --> 00:17:38,049
Oh, I, yeah, now I know.

00:17:38,049 --> 00:17:52,720
This is the best!

00:17:52,720 --> 00:18:02,460
OK.

00:18:02,460 --> 00:18:12,200
[applause]

00:18:12,200 --> 00:18:17,350
Getting the applause for code you didn't write, it's, thank you!

00:18:17,350 --> 00:18:19,450
[laughter] So this is Conduit.

00:18:19,450 --> 00:18:25,919
This is the basic React Redux example I think probably the first one they did.

00:18:25,919 --> 00:18:29,790
So we're going to modify this, time willing.

00:18:29,790 --> 00:18:33,440
To use TAO.js.

00:18:33,440 --> 00:18:44,190
So this is actually hitting the API for that, we can sign in, go to home page, so you see

00:18:44,190 --> 00:18:49,169
there's all this functionality.

00:18:49,169 --> 00:19:19,760
There's lots of ...

00:19:19,760 --> 00:19:30,559
so this application has a bunch of reducers that we're used to, all the Redux boilerplating,

00:19:30,559 --> 00:19:43,500
the components are React, they have a lot of baked-in Redux, so we've sort of embedded

00:19:43,500 --> 00:19:57,919
all of this together, what these -- how we call the API, what to do on various -- within

00:19:57,919 --> 00:19:59,990
various components.

00:19:59,990 --> 00:20:07,130
So if we go ahead and -- I'm going to turn off Redux logging.

00:20:07,130 --> 00:20:25,399
We're going to switch to using some alternative components and not all of

00:20:25,399 --> 00:20:29,880
them are necessary.

00:20:29,880 --> 00:20:35,419
So we notice, still looks the same.

00:20:35,419 --> 00:20:36,919
Still works.

00:20:36,919 --> 00:20:41,720
I didn't get that tab thing working yet.

00:20:41,720 --> 00:20:43,900
We see the results change.

00:20:43,900 --> 00:21:04,240
And the way this is implemented is -- so for the home, the original home is here.

00:21:04,240 --> 00:21:12,920
It's home page loaded, home page unloaded, applying the tag filter, we now take and add

00:21:12,920 --> 00:21:15,980
a handler.

00:21:15,980 --> 00:21:24,750
We import a TAO signal network that is the default signal network, and in order to chain

00:21:24,750 --> 00:21:34,240
a signal into the network from a handler, we use this app context constructor to return

00:21:34,240 --> 00:21:45,309
that as a new signal to follow, and so when we receive the signal to enter home, we want

00:21:45,309 --> 00:21:51,940
to tell the application to view home.

00:21:51,940 --> 00:22:04,510
Alternatively, we use a data handler from the React library to capture data from a signal,

00:22:04,510 --> 00:22:16,210
and store it where we can utilize it again in our render handler, and this -- you provide

00:22:16,210 --> 00:22:22,769
it with a context to say any data handlers above, they create this context for me, I

00:22:22,769 --> 00:22:28,910
will now have these available to me in my handler that I use.

00:22:28,910 --> 00:22:32,200
It's a function as a child component.

00:22:32,200 --> 00:22:41,950
And so when it -- this will react when we reach the trigram -- in the application context

00:22:41,950 --> 00:22:47,309
that reaches the trigram of home and view and we actually don't care about the orientation.

00:22:47,309 --> 00:22:54,700
So it allows for wild-carding, so if you don't provide a term, it's a wild card on that term

00:22:54,700 --> 00:23:01,380
-- on that attribute of the trigram.

00:23:01,380 --> 00:23:08,020
And so when we render the home, we actually want to use our home component.

00:23:08,020 --> 00:23:10,700
This one's new.

00:23:10,700 --> 00:23:18,480
We pass down the token, the app name, we get from the app data, which tabs are active,

00:23:18,480 --> 00:23:25,490
a tag, and then what to do if they click "All" or click on the feed.

00:23:25,490 --> 00:23:28,830
So this is a -- just a standard React component.

00:23:28,830 --> 00:23:36,990
There's no logic or anything in here to interact with the signal layer, signal network and

00:23:36,990 --> 00:23:42,730
we can treat our components completely on their own, makes them easier to test, easier

00:23:42,730 --> 00:23:54,590
to design using storybook, and this works for many things, so this uses a main view.

00:23:54,590 --> 00:24:05,880
Vue, and you notice that the interactions are -- there you go.

00:24:05,880 --> 00:24:24,669
We pass down this "Click all" which will then -- 

00:24:24,669 --> 00:24:26,720
this will create a signal into the network.

00:24:26,720 --> 00:24:37,500
Actually, this is not implemented right.

00:24:37,500 --> 00:24:54,360
So going in here and signing in, I come back here and see the signed-in view and we did

00:24:54,360 --> 00:25:00,299
that with using a different header.

00:25:00,299 --> 00:25:07,120
Nope, wrong window again.

00:25:07,120 --> 00:25:16,669
So we have our login component, which is saying if I'm trying to view -- if I'm trying to

00:25:16,669 --> 00:25:23,289
enter a user anonymously, I want to view that user anonymously, so that's going to render

00:25:23,289 --> 00:25:33,299
-- use a render handler, user view, anonymous, and that will give us our login control.

00:25:33,299 --> 00:25:42,200
When we submit, it's going to generate a user find action anonymously.

00:25:42,200 --> 00:25:53,710
Because this is just working with what's already here, we have these handlers all defined around

00:25:53,710 --> 00:25:55,940
users.

00:25:55,940 --> 00:26:06,000
So we find a user anonymously, we have a handler for that, which will grab the email and password

00:26:06,000 --> 00:26:12,030
out of the data -- out of the user portion of the data passed in the application context

00:26:12,030 --> 00:26:21,840
to our handler, we will leverage the agent and do a login, and then based on how that

00:26:21,840 --> 00:26:27,690
responds, we'll either get a user or it will catch an error.

00:26:27,690 --> 00:26:33,620
If we get a user, then we want to enter that user in the portal orientation, and provide

00:26:33,620 --> 00:26:39,020
the token so that that can be used.

00:26:39,020 --> 00:26:47,720
So what's nice about the ability to have these wild card handlers, when we pass the token

00:26:47,720 --> 00:27:02,720
and we're in the portal orientation for any of our signals, we make sure to set the token

00:27:02,720 --> 00:27:07,210
on the agent every time based on that.

00:27:07,210 --> 00:27:11,559
So we don't have to call this anywhere else, but it will always be accurate.

00:27:11,559 --> 00:27:19,600
If we are going anonymous, we change -- we set the token to empty.

00:27:19,600 --> 00:27:30,580
We also can react to initializing the -- so our initial application context will be appinit

00:27:30,580 --> 00:27:41,140
anon, we can grab the token from local storage.

00:27:41,140 --> 00:27:45,559
If there is a token, we'll switch to the portal view.

00:27:45,559 --> 00:27:53,720
If there's not, intercept sends nothing back, it will chain to the next appinit anon.

00:27:53,720 --> 00:27:56,940
That's when it will call load.

00:27:56,940 --> 00:28:08,330
So using this, we now can refactor all of the application logic into these handlers

00:28:08,330 --> 00:28:16,159
that are small and bite-size and easy to change, and we don't have to worry about how we're

00:28:16,159 --> 00:28:26,870
making calls necessarily to move the user around the application.

00:28:26,870 --> 00:28:33,430
On the -- not sure how much time I have left.

00:28:33,430 --> 00:28:54,080
So going into the API side -- so if I switch this to using the local API -- let me sign

00:28:54,080 --> 00:28:57,360
out first.

00:28:57,360 --> 00:29:02,289
Clears the token.

00:29:02,289 --> 00:29:12,200
And we also see, through logging these, that these chain to each other, -- now, let's ...

00:29:12,200 --> 00:29:19,320
We'll use the local API.

00:29:19,320 --> 00:29:38,740
Now for this, with the same user, we set up -- we convert these routes from the API where

00:29:38,740 --> 00:29:47,299
instead of doing what it was -- what it had here, gets the user find by, it's going directly

00:29:47,299 --> 00:29:58,411
against mongo, we can instead create a transponder on our signal network and what a transponder

00:29:58,411 --> 00:30:04,659
does is just provide us with a promise when we set the context that we can await.

00:30:04,659 --> 00:30:13,350
And we add some handlers to the transponder, so that these will only be handled by the

00:30:13,350 --> 00:30:21,679
transponder and do -- perform this action in other handlers we've added to the signal

00:30:21,679 --> 00:30:23,580
network.

00:30:23,580 --> 00:30:33,180
They'll all be called except for other transponders will not see the signal that I put into the

00:30:33,180 --> 00:30:37,549
network.

00:30:37,549 --> 00:30:46,300
So when we come in here, we want to get the user, and so this is a -- this is when the

00:30:46,300 --> 00:30:53,669
user is coming back to the portal or -- when the user is coming back to the portal, we

00:30:53,669 --> 00:30:58,720
want to be able to retrieve that user from the portal, so we will send the signal off

00:30:58,720 --> 00:31:04,680
to find the user in the portal and we pass what that user ID came in and what the token

00:31:04,680 --> 00:31:08,120
was.

00:31:08,120 --> 00:31:22,789
And now in here we have a user find portal, and here's where we implement going to the

00:31:22,789 --> 00:31:24,500
database.

00:31:24,500 --> 00:31:29,610
And if they're not found, we say it's a fail.

00:31:29,610 --> 00:31:33,570
And that the auth failed.

00:31:33,570 --> 00:31:41,700
If it's -- if we did find the user, we grab that user and we send it back and saying we

00:31:41,700 --> 00:31:44,639
retrieved the user from the portal.

00:31:44,639 --> 00:31:52,049
So now on a retrieve, we can send that back in the JSON.

00:31:52,049 --> 00:32:02,260
I won't have time to get to it, but what this allows us to do is because we've put the -- we've

00:32:02,260 --> 00:32:12,409
put the actual interaction with Mongo here, we can add other handlers and one, put an

00:32:12,409 --> 00:32:16,320
intercept handler to handle caching.

00:32:16,320 --> 00:32:22,580
If we have a token and we already know the user, we can just get that user from cache,

00:32:22,580 --> 00:32:27,399
so return the correct thing and not even go to Mongo.

00:32:27,399 --> 00:32:35,890
Or if we want to change our database from Mongo to Postgres or mySQL or a relational

00:32:35,890 --> 00:32:43,279
store, we can just implement new handlers and refactor that on the fly without having

00:32:43,279 --> 00:32:52,600
to worry about all -- changing the the code of the actual API that the code is relying

00:32:52,600 --> 00:32:56,720
upon.

00:32:56,720 --> 00:33:06,990
Now, what I've shown is an example of how to do this directly inside of an app or an

00:33:06,990 --> 00:33:12,770
API, and then they're still using a REST API as an interface to talk to each other, but

00:33:12,770 --> 00:33:25,740
once I have these signals set up on both sides, then I can use the socket io package 

00:33:25,740 --> 00:33:32,019
without having to go through this REST medium.

00:33:32,019 --> 00:33:33,019
I think I'm almost out of time.

00:33:33,019 --> 00:33:35,240
Scoot back to -- -- I really want to thank a few people.

00:33:35,240 --> 00:33:40,720
I want to thank the people at Thinkster.io for creating the real world app.

00:33:40,720 --> 00:33:48,190
I will be developing this further and supplying it to anybody who wants to see -- oh, is my

00:33:48,190 --> 00:33:49,190
display thing?

00:33:49,190 --> 00:33:50,190
That's nasty!

00:33:50,190 --> 00:33:51,190
Let's go ahead and close out of there.

00:33:51,190 --> 00:33:52,250
JSConf for being able to have these talks.

00:33:52,250 --> 00:33:59,769
I really appreciate to come up here and share my work with everyone, and JS.org for hosting

00:33:59,769 --> 00:34:02,909
DNS for so many great projects.

00:34:02,909 --> 00:34:06,440
A few resources.

00:34:06,440 --> 00:34:12,800
The website for the project is tao.js.org.

00:34:12,800 --> 00:34:15,390
The GitHub repo.

00:34:15,390 --> 00:34:21,620
There are six cores published.

00:34:21,620 --> 00:34:27,220
The transponder came out of the utils package.

00:34:27,220 --> 00:34:30,930
You don't need it in the core package.

00:34:30,930 --> 00:34:34,150
And so the for build extensions on signal networks.

00:34:34,150 --> 00:34:48,190
And the -- and then coming soon, I'll get the 100% test coverage back on the packages.

00:34:48,190 --> 00:34:53,910
I did a lot of building for a little while, and updated documentation, especially with

00:34:53,910 --> 00:35:02,030
this decoupled architecture focus, so thank you very much for coming, and I really appreciate

00:35:02,030 --> 00:35:03,030
it.

00:35:03,030 --> 00:35:03,031

YouTube URL: https://www.youtube.com/watch?v=qKtHo3WOkW8


