Title: Composing music with composed functions - Adam Giese - JSConf US 2019
Publication date: 2019-09-10
Playlist: JSConf US 2019
Description: 
	Functional programming can be difficult to learn. Although there are many practical lessons, they are often hidden through academic lingo and dry examples. What if these basics could be livened up and taught through the lens of music? Together, we will go over some of the basics of functional programming including functional array manipulation, closure, and function composition. As I go through these, I will show how they can be applied to the creation of music and musical instruments using the Web Audio API.

https://2019.jsconf.us/speakers/adam-giese
Captions: 
	00:00:04,879 --> 00:00:18,750
welcome everybody my name is Adam DC I'm

00:00:15,420 --> 00:00:21,539
Adam DC dev on Twitter and before I was

00:00:18,750 --> 00:00:23,939
a software engineer I attended school

00:00:21,539 --> 00:00:26,820
for music specifically music composition

00:00:23,939 --> 00:00:29,160
and I was always drawn to the analytical

00:00:26,820 --> 00:00:31,109
thinking aspect of music theory and

00:00:29,160 --> 00:00:32,880
years later when I started to learn

00:00:31,109 --> 00:00:34,620
functional programming I found that that

00:00:32,880 --> 00:00:37,890
kind of the same itch was scratched

00:00:34,620 --> 00:00:40,350
so when I started a musical project with

00:00:37,890 --> 00:00:42,059
web development I decided to use

00:00:40,350 --> 00:00:43,710
functional programming so here's my

00:00:42,059 --> 00:00:48,000
introduction to functional programming

00:00:43,710 --> 00:00:50,039
from a musical perspective so first we

00:00:48,000 --> 00:00:53,120
have to ask the question what is

00:00:50,039 --> 00:00:53,120
functional programming

00:00:53,780 --> 00:00:59,550
well it's programming with functions I

00:00:56,270 --> 00:01:01,170
just like object-oriented is based

00:00:59,550 --> 00:01:03,420
around objects functions are the

00:01:01,170 --> 00:01:07,290
building blocks so that leads the next

00:01:03,420 --> 00:01:08,909
question what is a function well a non

00:01:07,290 --> 00:01:11,850
functional definition might be something

00:01:08,909 --> 00:01:14,250
like a sequence of commands attracted

00:01:11,850 --> 00:01:15,720
into a reusable unit but a functional

00:01:14,250 --> 00:01:17,880
definition is more something like a

00:01:15,720 --> 00:01:20,090
relationship between a set of inputs and

00:01:17,880 --> 00:01:24,330
outputs this is the mathematical

00:01:20,090 --> 00:01:26,100
definition of of a function and is

00:01:24,330 --> 00:01:30,119
sometimes referred to in programming as

00:01:26,100 --> 00:01:33,750
a pure function so what makes a function

00:01:30,119 --> 00:01:35,970
pure first means given the same

00:01:33,750 --> 00:01:39,780
arguments in it will return the same

00:01:35,970 --> 00:01:41,520
value this this means that it shouldn't

00:01:39,780 --> 00:01:43,560
rely on anything from the outside such

00:01:41,520 --> 00:01:47,159
as a random number generator the current

00:01:43,560 --> 00:01:48,450
time or a read from the database it also

00:01:47,159 --> 00:01:50,189
means no side-effects

00:01:48,450 --> 00:01:52,649
this means it shouldn't affect anything

00:01:50,189 --> 00:01:54,720
outside of itself it shouldn't many play

00:01:52,649 --> 00:01:57,420
the Dom or write to the database or play

00:01:54,720 --> 00:02:00,000
music and sometimes this is referred to

00:01:57,420 --> 00:02:01,979
as being referentially transparent and

00:02:00,000 --> 00:02:04,140
referentially transparent means that the

00:02:01,979 --> 00:02:08,280
function and its arguments can be

00:02:04,140 --> 00:02:10,860
replaced by its return value so for an

00:02:08,280 --> 00:02:12,180
example we are here defining a note it

00:02:10,860 --> 00:02:16,049
has a name

00:02:12,180 --> 00:02:18,150
and an octave for here we have a pure

00:02:16,049 --> 00:02:21,090
function increment octave it accepts a

00:02:18,150 --> 00:02:24,180
note and returns a new note with octave

00:02:21,090 --> 00:02:27,810
incremented by one pi see here is the

00:02:24,180 --> 00:02:29,790
result of that pure function play here

00:02:27,810 --> 00:02:30,810
is an impure function because it has a

00:02:29,790 --> 00:02:33,269
side-effect

00:02:30,810 --> 00:02:36,120
it plays music and here you can note

00:02:33,269 --> 00:02:38,220
that you can pass in either high C or

00:02:36,120 --> 00:02:39,450
increment octave middle C and have the

00:02:38,220 --> 00:02:44,069
same effect this is where the

00:02:39,450 --> 00:02:45,950
referential transparency comes in so you

00:02:44,069 --> 00:02:49,319
learn functional programming and you

00:02:45,950 --> 00:02:52,739
move all side effects and now your

00:02:49,319 --> 00:02:54,900
program is useless it's important to

00:02:52,739 --> 00:02:57,090
note that side effects are not bad they

00:02:54,900 --> 00:02:59,220
include making an HTTP request

00:02:57,090 --> 00:03:01,290
manipulating the Dom putting the console

00:02:59,220 --> 00:03:03,180
or playing music side effects are not

00:03:01,290 --> 00:03:04,859
bad but they are unpredictable and they

00:03:03,180 --> 00:03:06,989
are harder to test so you should use

00:03:04,859 --> 00:03:12,239
your impure functions carefully and

00:03:06,989 --> 00:03:14,389
predictably alright now that we have a

00:03:12,239 --> 00:03:16,590
definition of functional programming

00:03:14,389 --> 00:03:19,919
here are some of the tools that are

00:03:16,590 --> 00:03:23,010
important immutability immutability is

00:03:19,919 --> 00:03:24,810
the idea that variable state cannot be

00:03:23,010 --> 00:03:27,949
modified after its creation

00:03:24,810 --> 00:03:30,389
you might be thinking something like why

00:03:27,949 --> 00:03:32,940
why would you like to why would you

00:03:30,389 --> 00:03:34,980
limit yourself by tying one hand behind

00:03:32,940 --> 00:03:37,590
your back but there is a reason for for

00:03:34,980 --> 00:03:40,560
this one of the advantages is that is

00:03:37,590 --> 00:03:42,659
less for your brain to track humans have

00:03:40,560 --> 00:03:44,729
a working memory it's kind of like the

00:03:42,659 --> 00:03:46,530
biological equivalent to RAM you can

00:03:44,729 --> 00:03:49,590
only keep track of so many things at a

00:03:46,530 --> 00:03:51,299
time so by making sure not to change

00:03:49,590 --> 00:03:53,449
your variables let's Lester a brain to

00:03:51,299 --> 00:03:56,639
track it also prevents unintentional

00:03:53,449 --> 00:03:58,349
side-effects trust me I know from

00:03:56,639 --> 00:04:00,030
experience that accidentally changing a

00:03:58,349 --> 00:04:03,329
variable and function could be a really

00:04:00,030 --> 00:04:05,790
hard bug to track down immutability also

00:04:03,329 --> 00:04:07,260
preserves state think about like a bank

00:04:05,790 --> 00:04:08,819
account it doesn't just show your

00:04:07,260 --> 00:04:10,500
balance it shows your starting balance

00:04:08,819 --> 00:04:15,329
and then all of your withdrawals and

00:04:10,500 --> 00:04:18,419
deposits I higher-order functions are

00:04:15,329 --> 00:04:20,279
functions that either accept a function

00:04:18,419 --> 00:04:22,139
as an argument or return a new function

00:04:20,279 --> 00:04:25,740
so you might be thinking something like

00:04:22,139 --> 00:04:29,220
this here's a

00:04:25,740 --> 00:04:30,720
here's an example so we've got tone J s

00:04:29,220 --> 00:04:33,180
is a framework on top of the Web Audio

00:04:30,720 --> 00:04:36,930
API the Web Audio API itself is very low

00:04:33,180 --> 00:04:39,120
level and and maybe a little more than

00:04:36,930 --> 00:04:41,400
what you need so the the the Web Audio

00:04:39,120 --> 00:04:44,520
API helps abstract it become a little

00:04:41,400 --> 00:04:48,419
easier play note here is a higher order

00:04:44,520 --> 00:04:51,930
function it accepts a note and it

00:04:48,419 --> 00:04:53,880
returns a new function play middle C

00:04:51,930 --> 00:04:57,120
here is the result of play note and it

00:04:53,880 --> 00:04:59,330
is the new function add event listener

00:04:57,120 --> 00:05:01,949
here accepts a function as an argument

00:04:59,330 --> 00:05:04,590
so add event listener and played-out are

00:05:01,949 --> 00:05:06,150
both higher-order play note because it

00:05:04,590 --> 00:05:07,199
returns a function and add event

00:05:06,150 --> 00:05:10,409
listener him because it accepts a

00:05:07,199 --> 00:05:16,020
function so here's our first beautiful

00:05:10,409 --> 00:05:19,530
musical example I promise they get a

00:05:16,020 --> 00:05:22,020
little better from here on out I dealing

00:05:19,530 --> 00:05:24,240
with arrays manipulating arrays are an

00:05:22,020 --> 00:05:26,250
important part of all paradigms and

00:05:24,240 --> 00:05:27,870
JavaScript comes with some array methods

00:05:26,250 --> 00:05:30,690
that work really well with functional

00:05:27,870 --> 00:05:32,219
programming and there are two concepts

00:05:30,690 --> 00:05:33,180
that we covered that that are important

00:05:32,219 --> 00:05:34,830
to dealing with arrays there's

00:05:33,180 --> 00:05:36,300
higher-order functions each of these

00:05:34,830 --> 00:05:38,460
methods except a function and

00:05:36,300 --> 00:05:40,590
immutability because each of the ment

00:05:38,460 --> 00:05:43,800
mentioned methods here will return a new

00:05:40,590 --> 00:05:45,449
array so array dot filter right up

00:05:43,800 --> 00:05:47,490
filter accepts a function that's run

00:05:45,449 --> 00:05:49,590
against every element it receives an

00:05:47,490 --> 00:05:52,560
element index and array and it returns a

00:05:49,590 --> 00:05:56,250
subset of the original array so here

00:05:52,560 --> 00:05:59,099
we're defining the melody is high here

00:05:56,250 --> 00:06:02,729
compares and the nose frequency in Hertz

00:05:59,099 --> 00:06:04,590
to middle C and if the provider note is

00:06:02,729 --> 00:06:06,539
C for or above it will return true

00:06:04,590 --> 00:06:09,270
otherwise it will return false so we

00:06:06,539 --> 00:06:13,440
passed the is high function into the

00:06:09,270 --> 00:06:16,409
melody filter and we get the only the

00:06:13,440 --> 00:06:17,680
values that remain so here we have an

00:06:16,409 --> 00:06:22,400
unfiltered melody

00:06:17,680 --> 00:06:24,680
[Music]

00:06:22,400 --> 00:06:30,910
and when we remove all the notes that

00:06:24,680 --> 00:06:34,039
are that are that don't pass the is hi

00:06:30,910 --> 00:06:34,039
[Music]

00:06:34,449 --> 00:06:40,220
we have the new melody a write up map is

00:06:38,630 --> 00:06:42,169
similar it accepts a function that's run

00:06:40,220 --> 00:06:45,070
against every element and receives the

00:06:42,169 --> 00:06:48,650
element index and array but rather than

00:06:45,070 --> 00:06:50,990
checking if a value is truthy or faulty

00:06:48,650 --> 00:06:54,229
it returns an array of the same length

00:06:50,990 --> 00:06:58,699
as the original but with new values so

00:06:54,229 --> 00:07:00,350
here we have a melody and we have our

00:06:58,699 --> 00:07:02,150
increment octave function from before it

00:07:00,350 --> 00:07:06,440
takes a note and it returns a new note

00:07:02,150 --> 00:07:08,419
and we can map the notes with this

00:07:06,440 --> 00:07:10,430
increment octave function then we have

00:07:08,419 --> 00:07:12,010
the same melody but each notes octave

00:07:10,430 --> 00:07:20,099
has been incremented

00:07:12,010 --> 00:07:22,990
[Music]

00:07:20,099 --> 00:07:24,729
now we have a radar produced a radar

00:07:22,990 --> 00:07:26,319
reduce is a little bit more complicated

00:07:24,729 --> 00:07:29,050
it accepts a function that's run against

00:07:26,319 --> 00:07:30,789
every every element but in addition to

00:07:29,050 --> 00:07:32,979
the element index and array it also

00:07:30,789 --> 00:07:35,499
receives an accumulator and returns an

00:07:32,979 --> 00:07:38,289
accumulated value this is also known as

00:07:35,499 --> 00:07:40,959
fold or accumulate in some languages and

00:07:38,289 --> 00:07:43,959
it is a more generic tool than filter or

00:07:40,959 --> 00:07:45,909
map I sometimes hear that radar reduced

00:07:43,959 --> 00:07:49,029
takes an array and it returns a single

00:07:45,909 --> 00:07:51,249
value this is true but I don't find it

00:07:49,029 --> 00:07:53,439
to be a particularly useful distinction

00:07:51,249 --> 00:07:56,349
because all functions in JavaScript will

00:07:53,439 --> 00:07:58,449
return a single value so I like to think

00:07:56,349 --> 00:08:00,309
of array dot reduced as a value that

00:07:58,449 --> 00:08:03,550
takes an array and it can return any

00:08:00,309 --> 00:08:06,369
type filter for example will take an

00:08:03,550 --> 00:08:08,529
array and it will return a new array

00:08:06,369 --> 00:08:11,259
that is of smaller size array that map

00:08:08,529 --> 00:08:13,119
will take an array and it will return a

00:08:11,259 --> 00:08:17,519
new array of the same length both with

00:08:13,119 --> 00:08:19,779
different values a rate not reduce can

00:08:17,519 --> 00:08:23,169
return anything whether it be a number

00:08:19,779 --> 00:08:26,499
or a string or an array filter and map

00:08:23,169 --> 00:08:28,240
for example can be written in reduce so

00:08:26,499 --> 00:08:30,490
here's here's an example we have a

00:08:28,240 --> 00:08:33,669
little bit longer melody we define the

00:08:30,490 --> 00:08:34,719
notes and the length here we have a two

00:08:33,669 --> 00:08:37,599
length function that's going to be

00:08:34,719 --> 00:08:40,449
passed to reduce total here is the

00:08:37,599 --> 00:08:43,419
accumulator and note here is the array

00:08:40,449 --> 00:08:46,120
element the method here accepts the

00:08:43,419 --> 00:08:49,060
function two length and an initial value

00:08:46,120 --> 00:08:51,430
and it will return the end accumulation

00:08:49,060 --> 00:08:54,910
so we start with the initial value of

00:08:51,430 --> 00:08:57,670
zero and then we add it to each to each

00:08:54,910 --> 00:09:00,720
note length so zero plus point one two

00:08:57,670 --> 00:09:03,220
five plus point one two five is 0.25

00:09:00,720 --> 00:09:06,699
point three seven five and so on until

00:09:03,220 --> 00:09:13,470
we get to the overall melodies length so

00:09:06,699 --> 00:09:18,160
here didn't update the timer supposed to

00:09:13,470 --> 00:09:20,459
go up on my screen says one point six

00:09:18,160 --> 00:09:20,459
two five

00:09:22,060 --> 00:09:27,850
partial application personal application

00:09:24,970 --> 00:09:29,860
is an incredibly useful tool for writing

00:09:27,850 --> 00:09:32,440
reusable and generic functions and

00:09:29,860 --> 00:09:33,970
partial application works by pre setting

00:09:32,440 --> 00:09:38,020
or fixing some of the arguments to a

00:09:33,970 --> 00:09:41,320
function so here we've got the transpose

00:09:38,020 --> 00:09:43,600
function it takes a direction an

00:09:41,320 --> 00:09:46,210
interval and a note and it returns a new

00:09:43,600 --> 00:09:51,640
note so here up nature third is a

00:09:46,210 --> 00:09:55,600
partially apply transpose it accepts a

00:09:51,640 --> 00:09:59,350
note and it calls transpose with up and

00:09:55,600 --> 00:10:05,340
a major third preset so here we can

00:09:59,350 --> 00:10:07,390
convert c4 to e4 or b-flat - to d3 and

00:10:05,340 --> 00:10:10,240
partial application is currently in

00:10:07,390 --> 00:10:11,470
stage one of the tc39 proposal and if

00:10:10,240 --> 00:10:13,750
that goes through then you'll be able to

00:10:11,470 --> 00:10:15,940
use the question mark to partially apply

00:10:13,750 --> 00:10:20,040
function so here are down minor seventh

00:10:15,940 --> 00:10:23,530
is a partially apply transpose as well

00:10:20,040 --> 00:10:27,010
so you don't have to manually apply it

00:10:23,530 --> 00:10:29,770
hard code each of the functions so here

00:10:27,010 --> 00:10:31,300
we can map using array to map these

00:10:29,770 --> 00:10:31,900
partial applied functions to an array of

00:10:31,300 --> 00:10:35,029
notes

00:10:31,900 --> 00:10:35,029
[Music]

00:10:35,239 --> 00:10:44,429
which I could take credit for that

00:10:37,199 --> 00:10:54,179
melody here's it Maps it down a minor

00:10:44,429 --> 00:10:56,610
70s alright composition composition I

00:10:54,179 --> 00:10:59,160
find to really be the bread and butter a

00:10:56,610 --> 00:11:00,749
functional programming and composition

00:10:59,160 --> 00:11:03,989
is a technique to combine multiple

00:11:00,749 --> 00:11:05,249
functions into a new function so here

00:11:03,989 --> 00:11:06,629
we're going to take a note name and

00:11:05,249 --> 00:11:09,480
we'll return a slightly detuned

00:11:06,629 --> 00:11:10,799
frequency first we have a function

00:11:09,480 --> 00:11:15,600
converting a note name to a frequency

00:11:10,799 --> 00:11:17,279
for example an input of a4 would which

00:11:15,600 --> 00:11:20,399
is a note name of a and an octave a4

00:11:17,279 --> 00:11:23,519
will return 440 that's the the Hertz of

00:11:20,399 --> 00:11:25,439
that note and here we're defining

00:11:23,519 --> 00:11:26,939
function to multiply by small percentage

00:11:25,439 --> 00:11:31,259
so once we have that frequency we can

00:11:26,939 --> 00:11:35,699
detune it so in input a 440 would return

00:11:31,259 --> 00:11:37,199
444 0.4 so compose takes two new

00:11:35,699 --> 00:11:41,179
functions and calls them from right to

00:11:37,199 --> 00:11:44,329
left the right to left is because

00:11:41,179 --> 00:11:46,889
compose is a mathematical concept and

00:11:44,329 --> 00:11:49,619
compose reads them from right to left if

00:11:46,889 --> 00:11:52,019
you are you can use pike which is a

00:11:49,619 --> 00:11:53,369
similar idea but from left to right and

00:11:52,019 --> 00:11:56,850
we'll be looking at that a little bit

00:11:53,369 --> 00:11:59,249
later so here get deep get d2 dn't

00:11:56,850 --> 00:12:01,799
frequency is a new composition that

00:11:59,249 --> 00:12:05,999
takes an input and it passes it first to

00:12:01,799 --> 00:12:10,290
frequency and then to detune up so an

00:12:05,999 --> 00:12:15,179
input of a four will return 444 0.4 so

00:12:10,290 --> 00:12:18,419
passing through the 440 value and the

00:12:15,179 --> 00:12:21,179
pipeline operator is also in the stage 1

00:12:18,419 --> 00:12:23,579
of tc39 and it would also allow for easy

00:12:21,179 --> 00:12:26,879
function composition allow you the pipe

00:12:23,579 --> 00:12:34,079
of value through multiple functions here

00:12:26,879 --> 00:12:36,329
we got our a for our detuned a form all

00:12:34,079 --> 00:12:38,160
right putting it all together I promised

00:12:36,329 --> 00:12:40,319
we'd be composing music with composed

00:12:38,160 --> 00:12:42,059
functions well here we're gonna be

00:12:40,319 --> 00:12:44,999
writing a function that converts a

00:12:42,059 --> 00:12:48,209
human-readable shorthand into a computer

00:12:44,999 --> 00:12:52,110
readable array alright so can everybody

00:12:48,209 --> 00:12:54,649
read this alright so don't don't worry I

00:12:52,110 --> 00:12:56,879
will zoom in on the important parts

00:12:54,649 --> 00:12:59,430
first we're gonna be importing some

00:12:56,879 --> 00:13:03,180
dependencies from Ram de and tan Jaya

00:12:59,430 --> 00:13:06,060
Ram de is a utility library similar to

00:13:03,180 --> 00:13:09,960
lodash or underscores but with a more

00:13:06,060 --> 00:13:11,550
functional approach and you might note

00:13:09,960 --> 00:13:13,290
that there are a lot of functions I'm

00:13:11,550 --> 00:13:14,670
importing one of the cool things about

00:13:13,290 --> 00:13:16,590
functional programming is that you take

00:13:14,670 --> 00:13:20,580
lots of small functions and combine them

00:13:16,590 --> 00:13:23,070
together with composition so for example

00:13:20,580 --> 00:13:25,530
parse name here is a function it takes a

00:13:23,070 --> 00:13:30,360
shorthand note and it returns the name

00:13:25,530 --> 00:13:32,220
so c4 at a 10 would be a string where

00:13:30,360 --> 00:13:36,060
the C is the note name the fours are

00:13:32,220 --> 00:13:38,640
octave in the 8 n is the duration so

00:13:36,060 --> 00:13:40,320
pipes through first to this regex

00:13:38,640 --> 00:13:44,100
and that will return an array of

00:13:40,320 --> 00:13:47,040
matching strings so any valid note name

00:13:44,100 --> 00:13:49,740
and then it takes a head to return just

00:13:47,040 --> 00:13:52,170
the full string so when passing in c4 at

00:13:49,740 --> 00:13:55,050
a 10 the match function will return an

00:13:52,170 --> 00:13:58,830
array of C and then head function will

00:13:55,050 --> 00:14:01,680
take that and return just C so C for a

00:13:58,830 --> 00:14:04,530
day 10 becomes array of the string c2

00:14:01,680 --> 00:14:08,400
just the string seed parse octave is

00:14:04,530 --> 00:14:10,980
similar imagines it to digits and then

00:14:08,400 --> 00:14:13,530
we convert it to a number and parse

00:14:10,980 --> 00:14:16,470
duration similarly will split at the at

00:14:13,530 --> 00:14:19,260
symbol and it will take the last so c4

00:14:16,470 --> 00:14:23,040
at a 10 will bring an array of c4 comma

00:14:19,260 --> 00:14:25,080
a 10 and then just a 10 first time here

00:14:23,040 --> 00:14:28,830
is a little bit more complicated it

00:14:25,080 --> 00:14:32,370
takes a note and its context and it

00:14:28,830 --> 00:14:35,190
returns a scheduled time so here we have

00:14:32,370 --> 00:14:39,270
the array of notes we're slicing it to

00:14:35,190 --> 00:14:42,570
only those preceding in and then we map

00:14:39,270 --> 00:14:45,000
each of those to their length and we

00:14:42,570 --> 00:14:47,910
reduce those to a single value and

00:14:45,000 --> 00:14:50,100
overall this lets the Web Audio API know

00:14:47,910 --> 00:14:52,650
when to play each note you're taking the

00:14:50,100 --> 00:14:55,860
duration of all the notes before an

00:14:52,650 --> 00:14:57,270
individual note and you're taking the

00:14:55,860 --> 00:14:58,800
direction of them all and adding them

00:14:57,270 --> 00:14:59,720
together and that lets you know when to

00:14:58,800 --> 00:15:03,120
play the new note

00:14:59,720 --> 00:15:06,150
so here parse shorthand is a composition

00:15:03,120 --> 00:15:07,770
of compositions where it accepts a

00:15:06,150 --> 00:15:11,130
string and it will return an array of

00:15:07,770 --> 00:15:12,899
note objects so first it splits at all

00:15:11,130 --> 00:15:15,779
whitespace converting a string

00:15:12,899 --> 00:15:18,449
to an array of strings and an array map

00:15:15,779 --> 00:15:20,009
here works like the array da map but as

00:15:18,449 --> 00:15:22,949
a function so that allows us to pipe

00:15:20,009 --> 00:15:25,589
into it and apply spec here takes an

00:15:22,949 --> 00:15:28,230
object shape with functions each string

00:15:25,589 --> 00:15:30,059
in the in the array that we just split

00:15:28,230 --> 00:15:32,879
will be passed into each of these

00:15:30,059 --> 00:15:35,369
functions and it will be mapped to an

00:15:32,879 --> 00:15:37,499
object of the same shape so the string

00:15:35,369 --> 00:15:39,600
will be passed a parse name and that'll

00:15:37,499 --> 00:15:41,519
be the value for the key name the string

00:15:39,600 --> 00:15:46,170
we passed a part octave they'll be the

00:15:41,519 --> 00:15:48,089
value for the key octave and so on so

00:15:46,170 --> 00:15:50,660
overall with our purse shorthand

00:15:48,089 --> 00:15:55,949
function which takes an array of strings

00:15:50,660 --> 00:15:58,050
this input string will be split at

00:15:55,949 --> 00:16:00,689
whitespace become this array of strings

00:15:58,050 --> 00:16:04,139
which will become this array of note

00:16:00,689 --> 00:16:23,850
objects as that allows us to convert

00:16:04,139 --> 00:16:27,379
this into this or we can convert this

00:16:23,850 --> 00:16:27,379
into this

00:16:27,430 --> 00:16:39,349
[Music]

00:16:40,310 --> 00:16:45,399
[Applause]

00:16:43,350 --> 00:16:49,209
again I wish I could take credit for

00:16:45,399 --> 00:16:50,920
those melodies but so why do you want to

00:16:49,209 --> 00:16:53,800
use functional programming I've heard

00:16:50,920 --> 00:16:56,560
that it allows for easier easier reason

00:16:53,800 --> 00:16:59,410
ability easier debugging easier testing

00:16:56,560 --> 00:17:02,050
for me I find that functional

00:16:59,410 --> 00:17:04,030
programming is really nice because it

00:17:02,050 --> 00:17:07,209
forces you to break down problems into

00:17:04,030 --> 00:17:11,140
their smallest parts and by taking those

00:17:07,209 --> 00:17:15,309
small parts you can combine the tiny

00:17:11,140 --> 00:17:17,169
solutions into larger solutions so if

00:17:15,309 --> 00:17:19,929
you found this interesting and would

00:17:17,169 --> 00:17:21,880
like to go further a few great resources

00:17:19,929 --> 00:17:23,589
I would highly suggest professor

00:17:21,880 --> 00:17:26,829
frisbees mostly adequate guide to

00:17:23,589 --> 00:17:30,429
functional programming it's it's a great

00:17:26,829 --> 00:17:31,809
book available online for free it goes

00:17:30,429 --> 00:17:34,570
very in-depth into functional

00:17:31,809 --> 00:17:36,010
programming also I would suggest is

00:17:34,570 --> 00:17:38,530
looking into functional utility

00:17:36,010 --> 00:17:40,900
libraries looking into their functions

00:17:38,530 --> 00:17:43,929
Ramba is the one that I used here lo -

00:17:40,900 --> 00:17:47,830
FB is a similar uses similar functional

00:17:43,929 --> 00:17:50,980
techniques but with but is based on low

00:17:47,830 --> 00:17:53,140
- so if you're familiar with low - that

00:17:50,980 --> 00:17:54,669
that might be a better fit and just

00:17:53,140 --> 00:17:57,760
looking at these and asking yourself

00:17:54,669 --> 00:18:00,160
when might you use this function I found

00:17:57,760 --> 00:18:02,910
really is a great way to level up and

00:18:00,160 --> 00:18:06,330
also lambda cast is a great podcast for

00:18:02,910 --> 00:18:08,950
for all things functional programming

00:18:06,330 --> 00:18:09,700
thank you so much if you have any

00:18:08,950 --> 00:18:12,010
questions

00:18:09,700 --> 00:18:14,559
catch me afterwards or message me at

00:18:12,010 --> 00:18:16,299
Adam GC dev and the slides are available

00:18:14,559 --> 00:18:19,010
at compos'd

00:18:16,299 --> 00:18:21,910
Adam GC calm thank you

00:18:19,010 --> 00:18:35,219
[Applause]

00:18:21,910 --> 00:18:35,219

YouTube URL: https://www.youtube.com/watch?v=PTbbqsR9twA


