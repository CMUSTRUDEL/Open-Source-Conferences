Title: CSS Algorithms - Lara Schenck - JSConf US 2019
Publication date: 2019-09-13
Playlist: JSConf US 2019
Description: 
	Wait... CSS algorithms? Can one really write algorithms in CSS? According to Lara, absolutely!

This talk is all about CSS algorithms: what they are, how to write them, and the potential impacts of a word like "algorithm" when it comes to positioning CSS expertise in the larger context of web development.
Captions: 
	00:00:00,160 --> 00:00:01,160
CSS Algorithms

00:00:01,160 --> 00:00:05,379
Lara Schenck KATIE: Hello. Hi. Oh, all right. How is everybody

00:00:05,379 --> 00:00:07,319
doing? Yeah? Whoo! I know we're all hungry. But this is our last talk before lunch. And

00:00:07,319 --> 00:00:08,420
I think it's gonna be an amazing one. We have Lara Schenck here to talk to us about CSS

00:00:08,420 --> 00:00:09,440
algorithms. And so, Lara's fun fact that she gave me is that she grew up on a llama farm

00:00:09,440 --> 00:00:10,440
in rural Pennsylvania, very small town. And I asked her, well, can you tell me some cool

00:00:10,440 --> 00:00:11,440
things about llamas that people wouldn't necessarily know about in their everyday life that's llama

00:00:11,440 --> 00:00:12,440
free. At 4H competitions, there's a bunch of llama categories that you can enter. So,

00:00:12,440 --> 00:00:13,530
llamas can do agility runs. Kind of like, you know, you've seen the dogs that jump over

00:00:13,530 --> 00:00:14,530
hurdles and they go in between poles. That was not her specialty, though. Her specialty

00:00:14,530 --> 00:00:15,530
was the llama costume category. Where you dress up yourself and you dress up your llama.

00:00:15,530 --> 00:00:16,530
And she won a blue ribbon for her rendition of she was the tinman and the llama was the

00:00:16,530 --> 00:00:17,530
cowardly lion. And she said there's probably a picture of this somewhere so I'm going to

00:00:17,530 --> 00:00:18,530
really encourage her to have her parents take a picture and send it to us so we can go and

00:00:18,530 --> 00:00:19,530
find it later and see a picture of her prize winning llama costume. All right. So, let's

00:00:19,530 --> 00:00:20,530
give it up for Lara Schenck. Take care. [ Applause ]

00:00:20,530 --> 00:00:21,530
LARA: Hey, everybody. Wouldn't it be great if I want in a tinman costume? Yeah, I don't

00:00:21,530 --> 00:00:22,530
know how I'm gonna follow that story with my talk. I wasn't really prepared. Yeah. Welcome

00:00:22,530 --> 00:00:23,530
to my talk. CSS algorithms. I'm really excited to be giving this to a room full of people

00:00:23,530 --> 00:00:27,270
at a JavaScript conference. And the best thing is I have met so many great people that, oh,

00:00:27,270 --> 00:00:36,440
I'm giving a talk to my new friends. Isn't that nice? Nasty, friends, before we get started

00:00:36,440 --> 00:00:43,410
talking about CSS algorithms, we have to answer a very important question. Is CSS a programming

00:00:43,410 --> 00:00:46,350
language? Fire emoji. [ Laughter ]

00:00:46,350 --> 00:00:54,610
How many of you have seen this question where there's related drama about this topic on

00:00:54,610 --> 00:01:01,100
Twitter over the last year or so? Yeah? Okay. Depends how many people use Twitter, I guess.

00:01:01,100 --> 00:01:06,211
I do have a question. Like, does this drama come up in real life also, or is it mostly

00:01:06,211 --> 00:01:10,800
contained to Twitter? Anyways, we have to answer this question before we talk about

00:01:10,800 --> 00:01:18,120
algorithms. So, I asked this question on Twitter. First in March of 2018 before I gave version

00:01:18,120 --> 00:01:24,330
1 of this talk. This is on 3.5.1 now I believe. Is CSS a programming language? What did Twitter

00:01:24,330 --> 00:01:34,460
think in 2018? Any guesses? No. So  but it's pretty split. 42% yes, 50% no, 8% I'm not

00:01:34,460 --> 00:01:42,520
sure. Not a huge dataset, 129 votes. But the answers to kind of the responses in the comments

00:01:42,520 --> 00:01:46,650
are very varied. So, it was either like, yes, absolutely. Or, of course it's a programming

00:01:46,650 --> 00:01:52,360
language. Or, I don't really consider CSS programming. Or you can't call styling a web

00:01:52,360 --> 00:01:57,090
page programming. It's not really a programming language. And things like that. So, after

00:01:57,090 --> 00:02:03,360
I gave this talk a little bit, before I started giving it again this year, May of 2019 I asked

00:02:03,360 --> 00:02:07,170
this question again. And I was like, nobody is going to answer. Okay, Lara, we see what

00:02:07,170 --> 00:02:12,410
you're doing. We saw your talk. Okay. No. This time 

00:02:12,410 --> 00:02:18,610
[ Laughter ] This time the poll had 5324 votes, which is

00:02:18,610 --> 00:02:23,520
definitely the most activity I've had on a Tweet before. And the noes increased. I was

00:02:23,520 --> 00:02:28,280
like, what's happening? What's going on? And not only were the same kind of varied responses

00:02:28,280 --> 00:02:32,690
in the comments, but there were also people that kind of specialize in HTML and CSS that

00:02:32,690 --> 00:02:37,840
were saying that I never call myself a programmer. And things like, why are we concerned about

00:02:37,840 --> 00:02:42,360
what CSS is? We should be concerned about what it's doing, et cetera. And things like

00:02:42,360 --> 00:02:51,720
stop asking this question. Don't wake the beast. So, stop. Like, everybody, stop. We

00:02:51,720 --> 00:02:54,860
have to answer a different question before we talk about is CSS a programming language.

00:02:54,860 --> 00:02:58,720
What is a programming language? Before we decide whether or not CSS is one of these

00:02:58,720 --> 00:03:04,510
things so, not surprisingly, there are many fields of research and people have dedicated

00:03:04,510 --> 00:03:10,680
their entire careers to answering this question. And we can't be really specific about what

00:03:10,680 --> 00:03:15,350
a programming language is because there are so many types of programming languages. So,

00:03:15,350 --> 00:03:18,670
the definition kind of boils down to there are lots of different ones. But could boil

00:03:18,670 --> 00:03:24,380
down to a formal language for instructing computer to perform tasks. This is Wikipedia

00:03:24,380 --> 00:03:28,310
and several others. Some good articles out there. The important part here is language.

00:03:28,310 --> 00:03:33,810
It's a language. And there are different types of programming languages. And these kind of

00:03:33,810 --> 00:03:38,840
fall under the categories of programming paradigms. And we use programming paradigms to both describe

00:03:38,840 --> 00:03:45,020
languages themselves as well as the style of code that we write. So, the two main paradigms

00:03:45,020 --> 00:03:51,220
are imperative which is code that describes  code that tells a computer how to accomplish

00:03:51,220 --> 00:03:57,599
a task. And declarative. Where you tell a computer what to do. So, the language  the

00:03:57,599 --> 00:04:02,100
expressions in the language are saying what, not how. And the main difference is the presence

00:04:02,100 --> 00:04:06,520
and absence of control flow. And so, control flow is the ability to manipulate the order

00:04:06,520 --> 00:04:10,740
of executions of statements in a program. So, control structures like if statements,

00:04:10,740 --> 00:04:16,601
for loops, imperative languages have these, declarative do not. Any logic is baked into

00:04:16,601 --> 00:04:23,200
the statement itself. What are some examples of these programming languages? Hmm m... imperative

00:04:23,200 --> 00:04:29,150
languages. JavaScript, of course. Ruby, C + +, Python. These are what we usually think

00:04:29,150 --> 00:04:33,630
of when we think of programming languages. Often times general purpose languages. Declarative

00:04:33,630 --> 00:04:40,470
languages are often, not always, domain specific. They are built to function within a certain

00:04:40,470 --> 00:04:52,520
context. What are some domain specific declarative programming languages? SQL. It is a declarative

00:04:52,520 --> 00:04:57,050
for data bastes. HTML, adding meaning around content on a web page, CSS for styling the

00:04:57,050 --> 00:05:04,030
content on that web page. Loud and clear. CSS is a domain specific declarative programming

00:05:04,030 --> 00:05:14,780
language. 100%. CSS developers program the layout of web pages. boxes. Let's be honest.

00:05:14,780 --> 00:05:24,669
Everything is a box. CSS programmers are box programmers. Also 100%. Okay. So, cool. Like,

00:05:24,669 --> 00:05:32,639
great. Like, maybe I can win a Twitter argument at some point. Good job. Why do we care about

00:05:32,639 --> 00:05:37,070
this? Why do we care if CSS is a programming language or not? So, I want to talk about

00:05:37,070 --> 00:05:48,910
something called Turd driven development. Of course this is a rift on test driven development,

00:05:48,910 --> 00:05:57,600
one simple in both is all code is crap the first time you write if. It is not possible

00:05:57,600 --> 00:06:02,790
for a human being to write perfect code the first time you write it. So, in test driven

00:06:02,790 --> 00:06:08,490
development, you kind of counter this by starting, instead of writing in production code, write

00:06:08,490 --> 00:06:15,020
a failing test first. In CSS, we don't really have this kind of testing. You can kind of

00:06:15,020 --> 00:06:21,080
say the test is the design. It's like, okay. This is why am I failing tests? Yes, I see

00:06:21,080 --> 00:06:25,880
it. It doesn't exist yet. So, yes, the test is failing. Run the test with our eyes. What

00:06:25,880 --> 00:06:32,460
do we do? We write code to make the test pass. So, all code is crap at first. We write some

00:06:32,460 --> 00:06:40,410
crap CSS. And then what happens? We stop. Okay? The CSS, it's done. I don't have to

00:06:40,410 --> 00:06:46,889
write anymore. Oh, wait, the test is failing. There was a change to the UI. Some new feature.

00:06:46,889 --> 00:06:52,759
The test is failing now. What do we do? We write more CSS. The test is passing. Oh, wait,

00:06:52,759 --> 00:06:58,030
maybe there was a regression. So, now our test is failing again. So, we write more CSS.

00:06:58,030 --> 00:07:07,950
Okay, whew, don't touch it, erg is working. And then we wait. And, oh, wait, new feature.

00:07:07,950 --> 00:07:16,140
More CSS. Test is passing, oh, no, another regression. More CSS. And so on. Wait  here

00:07:16,140 --> 00:07:23,710
we go. Oh, wow, what's happening. Our tests no longer completely passes. And this is what

00:07:23,710 --> 00:07:28,100
happens. But the problem is this is the web. This is the frontend of our web applications.

00:07:28,100 --> 00:07:32,601
This is what People use. And this doesn't just apply to CSS as a language. But also

00:07:32,601 --> 00:07:38,200
HTML and also JavaScript. It's kind of this culture of how we program. So, what do we

00:07:38,200 --> 00:07:48,020
do? Ah! Oooo! This is so bad! It's so bad! All this crap everywhere. What do we do? Stop

00:07:48,020 --> 00:07:56,760
writing CSS. Start programming. Okay. So, the thing is, programming does not equal logic,

00:07:56,760 --> 00:08:01,520
math, science, engineering. These things can be part of programming. But programming in

00:08:01,520 --> 00:08:07,670
its essence as an art, as a craft, is writing instructions for computers that other developers

00:08:07,670 --> 00:08:13,550
are able to read and maintain. And I think if anything shows that CSS is a programming

00:08:13,550 --> 00:08:18,770
language, it's that naming is really hard and extremely important. Naming is one of

00:08:18,770 --> 00:08:24,259
the hardest problems in computer science CSS is part of that story. Unless you're writing

00:08:24,259 --> 00:08:32,740
CSS in JavaScript. Okay. Okay. So, cool, we got if. We've covered a lot of ground so far.

00:08:32,740 --> 00:08:37,120
Now let's talk about algorithms. Now that CSS is a programming language, how do we write

00:08:37,120 --> 00:08:44,800
algorithms in this programming language? Hm. Algorithms 1013 let's have another definition.

00:08:44,800 --> 00:08:48,889
An algorithm, a well Defined computational procedure that takes

00:08:48,889 --> 00:08:55,769
input and produces output. This is from Thomas Cormen who wrote the book, the introduction

00:08:55,769 --> 00:09:00,459
to algorithms that is assigned in many the computer science course. I read the introduction.

00:09:00,459 --> 00:09:06,850
[ Laughter ] Might revisit. Okay. So, a well defined computational

00:09:06,850 --> 00:09:13,019
procedure. Input and output. Let's use this little board to help us visualize. Common

00:09:13,019 --> 00:09:20,779
use for an algorithm, sorting. We have a list of unsorted numbers. Our algorithm, the output,

00:09:20,779 --> 00:09:26,779
our algorithm should transform that input into sorted output. Hm. What are some sorting

00:09:26,779 --> 00:09:33,380
algorithms? I know this crowd probably knows some sorting algorithms. Bubble sort. Selection

00:09:33,380 --> 00:09:45,050
sort. MergeSort, quickSort. And could go on, but we'll keep it at that. Okay. What does

00:09:45,050 --> 00:09:53,940
an implementation of a sorting algorithm look like? Name that sorting algorithm. Bubblesort.

00:09:53,940 --> 00:10:01,790
This is imperative JavaScript. Cool. That's fine. If this was declarative code, it would

00:10:01,790 --> 00:10:06,839
be secured behind the source. We're telling not, not telling the computer how to do it.

00:10:06,839 --> 00:10:17,279
What about another kind of algorithm? So, how could this possibly apply to boxes? Okay.

00:10:17,279 --> 00:10:23,689
So, our input is a stack of unsorted, unstyled boxes. And our output, we want this to be

00:10:23,689 --> 00:10:31,240
a row of boxes. What kind of algorithm happens in between? Well, display: Flex, absolutely.

00:10:31,240 --> 00:10:34,360
float: Left. Gasp! [ Laughter ]

00:10:34,360 --> 00:10:46,420
How dare we? Yes. Floats still have their place in this day and age. Okay. What is an

00:10:46,420 --> 00:10:52,040
implementation of these algorithms look like? Well, this is what we see. This is declarative

00:10:52,040 --> 00:10:59,720
CSS. There's a big huge algorithm under the surface, but display: Flex is all we have

00:10:59,720 --> 00:11:09,439
to write. If we expand on this, this is what declarative logic looks like, what, not how.

00:11:09,439 --> 00:11:15,670
And under the surface, this is what's happening. This is a little snippet of Rust code from

00:11:15,670 --> 00:11:25,050
the experimental rendering engine called servo being pulled into gecko in Firefox. And this

00:11:25,050 --> 00:11:32,850
is where the wrap is happening. There's an imperative backbone to any code in CSS. Let's

00:11:32,850 --> 00:11:39,999
have a iceberg metaphor. Love a good iceberg metaphor. We have CSS on the top and imperative

00:11:39,999 --> 00:11:45,259
code on the bottom. Oh, my god, so many browsers in here. They are complicated.

00:11:45,259 --> 00:11:58,949
can we call the CSS algorithms? Hm? Algorithm? Why not? So, let's go on the premise of all

00:11:58,949 --> 00:12:04,980
the work I have been doing. What happens when we call that an algorithm? How far can we

00:12:04,980 --> 00:12:13,060
take this? Let's update algorithms 101 to CSS algorithms 101. Domain specific, declarative.

00:12:13,060 --> 00:12:21,910
These are magic words for CSS. And in term little of a word like algorithm or any kind

00:12:21,910 --> 00:12:28,111
of analogy to general programming, it's by definition going to be different in CSS, domain

00:12:28,111 --> 00:12:35,070
specific, declarative, you have to understand the domain to use these. A definition, a CSS

00:12:35,070 --> 00:12:39,459
algorithm is a well defined declaration or set of declarations that produces a specific

00:12:39,459 --> 00:12:50,529
styling output. Me. So, key points here. Well defined and specific. An algorithm is not

00:12:50,529 --> 00:12:58,300
a block of however long a set of declarations can get. But you're solving a specific problem.

00:12:58,300 --> 00:13:04,449
And I also think an algorithm is when CSS goes from being this mundane styling language

00:13:04,449 --> 00:13:11,389
like font size, color, whatever, to something where you're like, whoa! CSS! Like, what's

00:13:11,389 --> 00:13:16,149
happening? This is so cool. And you kind of appreciate the fact that you don't need to

00:13:16,149 --> 00:13:21,139
write so much code because the language is doing it. We can understand the language and

00:13:21,139 --> 00:13:26,259
understand how to communicate with the browser. So, you know what this notion is. This well

00:13:26,259 --> 00:13:30,300
defined set of declarations. So, as I was thinking, I was like, okay. I'm going to pick

00:13:30,300 --> 00:13:34,519
out some common algorithms that people would recognize. And the first one I thought of

00:13:34,519 --> 00:13:44,309
was this. Clearfix. So, oh, god, sad face. Like, that's a hack. Clearfix is not a fun

00:13:44,309 --> 00:13:55,230
algorithm. Could be an algorithm. Okay. What about this?

00:13:55,230 --> 00:14:00,769
[ Laughter ] So, this is a very long class name and not

00:14:00,769 --> 00:14:05,670
actually the name of the class. But you get the idea. And this is very amazing and elegant

00:14:05,670 --> 00:14:10,689
that you can do this. Let's say you have an element way out here. Positioned relatively.

00:14:10,689 --> 00:14:16,239
You can  no matter how far it's nested in  nested into that, that child you can kind

00:14:16,239 --> 00:14:21,660
of pop out of that whole DOM structure and stick it to the top right, bottom right, whatever.

00:14:21,660 --> 00:14:26,170
That's cool. Positioning. It's cool. Spaced content. Has anybody used this before? It's

00:14:26,170 --> 00:14:32,410
kind of a selector pattern. Lobotomized owl. Someone named Heydon Pickering came up with

00:14:32,410 --> 00:14:41,889
this. This is a way of spacing content with another content without adding to the top

00:14:41,889 --> 00:14:48,480
and bottom. This one I like. It's kind of a fluid typography. So, we use a viewport

00:14:48,480 --> 00:14:55,009
unit to make the size of the text element more fluid. And this is a linear interpolation.

00:14:55,009 --> 00:15:03,670
Math. Cool. So, yes, that's grid. Oh, my god. These two lines of code, we can make so many

00:15:03,670 --> 00:15:07,559
grids. Add a couple of spans in there and this is the most robust grid framework you'll

00:15:07,559 --> 00:15:15,889
ever need. It's not a framework. It's just code. Oh, my god, so great. So, CSS algorithm,

00:15:15,889 --> 00:15:24,279
a well defined declaration or set of declarations. Specific styling pattern. I haven't updated

00:15:24,279 --> 00:15:33,160
it. A CSS algorithm is a utility pattern that lets the browser algorithms do the work. And

00:15:33,160 --> 00:15:39,089
I think a CSS algorithm also follows some programming best practices. So, a single responsibility

00:15:39,089 --> 00:15:45,190
principle. Let's say we have a set of kitchen tools. So, the wooden spoon is so good at

00:15:45,190 --> 00:15:50,609
being a spoon. The whisk is great at being a whisk. Spatula is great at being a spatula,

00:15:50,609 --> 00:15:57,949
knife, knife, et cetera. What happens when a tool tries to do too much?

00:15:57,949 --> 00:16:01,759
[ Laughter ] Sad. This is a spork. A spork. I'm sorry,

00:16:01,759 --> 00:16:07,029
spork, but you're just trying to do too much. It's not that useful. People aren't that excited

00:16:07,029 --> 00:16:13,529
about sporks. Although there is a restaurant in Pittsburgh named Spork. Why did you do

00:16:13,529 --> 00:16:19,920
that? Anyways. Small, well named functions. This was a good programming practice. How

00:16:19,920 --> 00:16:27,699
small should your function be? Small. And then smaller than that. So, these are the

00:16:27,699 --> 00:16:34,009
words of Robert C. Martin in a book called Clean Code. He's kind of one of the inventors

00:16:34,009 --> 00:16:38,929
of a lot of agile software development practices. Okay. This is all well and good. What about

00:16:38,929 --> 00:16:45,559
in the real world? You're probably not writing the next Clearfix. So, I work as a design

00:16:45,559 --> 00:16:50,279
engineer at a company called Penske Media Corporation, PMC. We're a big publisher with

00:16:50,279 --> 00:16:57,959
24, I think, different very large brands all on WordPress sites which is exciting. This

00:16:57,959 --> 00:17:03,769
enterprise WordPress environment. Sometimes I call myself a design Ops engineer. I love

00:17:03,769 --> 00:17:12,579
my job. So, give it some hearts. These words also equate to UI engineer. Also, the design

00:17:12,579 --> 00:17:22,040
systems at PMC. Also, the first and only frontend developer in team of many backend developers.

00:17:22,040 --> 00:17:27,850
However, not anymore. We hired another frontend developer recently and I see that as a major

00:17:27,850 --> 00:17:32,460
sign of success. Yes, a company that went so long without frontend developers now has

00:17:32,460 --> 00:17:38,920
two. This is cool. This is like, yes. PMC cares about frontend. So, my work has revolved

00:17:38,920 --> 00:17:47,970
around the development of a design system called Larva. Yes, it is called  our design

00:17:47,970 --> 00:17:54,010
system is called Larva. And it is an embryonic design system. It's a good name for it. It's

00:17:54,010 --> 00:17:59,850
a little baby. It's not this beautiful UI library of components. But it's tools and

00:17:59,850 --> 00:18:05,960
best practices to build modules and comments. Embryonic. This is a laboratory to try out

00:18:05,960 --> 00:18:12,130
all these ideas, what is an algorithm? How does this work? So, Larva was built inside

00:18:12,130 --> 00:18:20,830
of a project from a site called deadline. And this is a WordPress theme. Kind of the

00:18:20,830 --> 00:18:29,860
base file structure here. And then drilling into a source directory. This is an IT CSS

00:18:29,860 --> 00:18:35,260
architecture. Triangle CSS. I added at the beginning of the project a directory for algorithms.

00:18:35,260 --> 00:18:42,411
I was like, will this be useful? Would this  will we actually add anything to this? And

00:18:42,411 --> 00:18:46,690
yes, there were like 20 something algorithms in here afterwards. So, kind of proved to

00:18:46,690 --> 00:18:51,700
be this useful naming convention and useful way to think about styles. And since this

00:18:51,700 --> 00:18:57,510
project completed, the process has been like moving all of this code into a shared repo.

00:18:57,510 --> 00:19:02,410
So, project structure that might be familiar to some is the monorepo structures. This is

00:19:02,410 --> 00:19:11,111
like Laravel 1.0 and these are npm packages. We have kind of the CSS npm package. Inside

00:19:11,111 --> 00:19:15,481
one of these algorithms, a glue, which is a pretty weird name for a style. There's a

00:19:15,481 --> 00:19:23,160
SaaS file, or a CSS file. And an HTML file to give an example of what the markup is.

00:19:23,160 --> 00:19:30,570
And a glue is this algorithm. But we've kind of turned it like design systemed it to be

00:19:30,570 --> 00:19:34,610
more reusable and a little more robust. So, it has different namespacing and we use the

00:19:34,610 --> 00:19:42,000
term glue because it's a nice mental model for what it does. Glue a UI element within

00:19:42,000 --> 00:19:50,320
another UI element. And this was used like 15 times in the deadline project. Not only

00:19:50,320 --> 00:19:55,720
by me. Mostly not by me, in fact. So, there was another contractor who was like a little

00:19:55,720 --> 00:20:01,010
more junior and they understand what this did. Whoa, this is a cool way to communicate

00:20:01,010 --> 00:20:06,710
the CSS concepts that might be a little hard to understand at first. Another algorithm,

00:20:06,710 --> 00:20:16,370
space children. Whoo  space children. So, this is the lobotomized owl. And design systemed,

00:20:16,370 --> 00:20:21,610
this looks like this. So, I could have some progressive enhancement inside this algorithm.

00:20:21,610 --> 00:20:26,430
It's kind of pulling this functionality into its own little node. Into its own little section.

00:20:26,430 --> 00:20:31,270
We can do really interesting things. So, column gap is a new property in some browsers and

00:20:31,270 --> 00:20:38,360
we can add this feature query inside the algorithm. In markup, this is what it look like. So,

00:20:38,360 --> 00:20:44,410
pretty heavy use of utility classes. And the algorithms are kind of layered in among the

00:20:44,410 --> 00:20:53,950
other class names. Like an onion. But algorithms can also be useful for stuff like this. So,

00:20:53,950 --> 00:21:00,970
if you've ever got an design and you're like, god damn it. This is a really pretty border.

00:21:00,970 --> 00:21:07,470
But this is a very annoying thing. Why do I have to develop this? So, you can be like,

00:21:07,470 --> 00:21:11,851
I'm gonna pull this out and I'm just gonna write this border. This border code. And if

00:21:11,851 --> 00:21:21,960
it shows up in one design, it's probably going to show up in another one. So, an algorithm

00:21:21,960 --> 00:21:28,470
can be a nice way of handling that. Okay. How to write a CSS algorithm or realize you

00:21:28,470 --> 00:21:34,520
don't need to. How to write algorithms? How you write an algorithm in an algorithm interview?

00:21:34,520 --> 00:21:42,140
Has anybody done a whiteboarding interview or an algorithms interview? A few? Yeah. No

00:21:42,140 --> 00:21:44,110
more comments. [ Laughter ]

00:21:44,110 --> 00:21:48,630
Okay. So, the steps. These are kind of taken straight out of cracking the coding interview.

00:21:48,630 --> 00:21:54,090
Plan your algorithm. Then you run a brute force solution. A not optimized version that

00:21:54,090 --> 00:21:59,750
steps through piece by piece. Slow, but maybe it works. And then you do a walkthrough in

00:21:59,750 --> 00:22:05,280
the interview to make sure the algorithm is functioning and then optimize it. Layer different

00:22:05,280 --> 00:22:10,500
optimization techniques. What about writing CSS algorithms? Well, you start by planning.

00:22:10,500 --> 00:22:17,610
Planning out the algorithm. Then you write brute force solution that's not quite optimized

00:22:17,610 --> 00:22:23,390
and walkthrough. Same thing. Except there's some pre work when you're writing a CSS algorithm

00:22:23,390 --> 00:22:32,700
which is doing a turd check. So, you'd stop before you write any CSS and say to yourself,

00:22:32,700 --> 00:22:37,010
should I actually be writing new CSS? Like, what is going on? Have I solved this problem

00:22:37,010 --> 00:22:42,650
before somewhere in this codebase and why can I not use that again? So, just a quick

00:22:42,650 --> 00:22:47,460
moment to be like, wait, is this really the problem I should be solve something and then

00:22:47,460 --> 00:22:54,310
you plan. Pseudo code and boxes. Pseudo coding CSS and defining your problem. What is this

00:22:54,310 --> 00:22:59,470
thing you're having a hard time with that you need to solve? On paper, I love drawing

00:22:59,470 --> 00:23:06,001
boxes on paper. I love to do other things too. But sometimes this is really fun. Also

00:23:06,001 --> 00:23:10,960
because writing things on paper and like whiteboarding, there's research that shows we have better 

00:23:10,960 --> 00:23:15,220
human beings have better retention when you're doing things in physical space like that versus

00:23:15,220 --> 00:23:20,220
drawing boxes in Illustrator, et cetera. Also, printing out the design and marking it up

00:23:20,220 --> 00:23:23,820
in that way could be really useful. Figure out what  if you're working with an existing

00:23:23,820 --> 00:23:28,630
system, what patterns are already provided. What do you need to write new? And a brute

00:23:28,630 --> 00:23:35,300
force solution. Spaghetti, write gross code, that's fine. And remember the assumption,

00:23:35,300 --> 00:23:40,680
all code is crap at first. Don't write it in the actual stylesheet. Write it somewhere

00:23:40,680 --> 00:23:49,300
else. Instead of inside the main application, you could have a separate file. This recent

00:23:49,300 --> 00:23:55,940
project I was having a file called scratch pat.scss that was added to a test environment,

00:23:55,940 --> 00:24:01,460
not to an actual application. It was a safe space to try out the CSS. This is what it

00:24:01,460 --> 00:24:07,460
ends up looking like. Working with boxes. CodePen is like a product for this specific

00:24:07,460 --> 00:24:14,070
use case. For writing frontend code outside of a regular environment. And this is a 

00:24:14,070 --> 00:24:20,840
the little border arc. Our story border arc from before. So, do a walkthrough. We love

00:24:20,840 --> 00:24:26,310
resizing our browsers. Web developers are like, yes. Not going to test it in a different

00:24:26,310 --> 00:24:32,690
browser, but I'm gonna resize it a lot in this one. So, that's a walkthrough. But test

00:24:32,690 --> 00:24:36,120
it in other browsers. And it's a lot easier to do that when it's a small piece. So, it's

00:24:36,120 --> 00:24:43,240
easier to do it now. Ask yourself, is every declaration essential? Are there any dependencies?

00:24:43,240 --> 00:24:48,430
Does this algorithm need to be applied with another class and why? And this you can have

00:24:48,430 --> 00:24:54,940
a Robert C. Martin in the back of your head that's like smaller, smaller codes. And then

00:24:54,940 --> 00:25:00,610
you can optimize and refactor and document. This is when the magic happens. When our poopy

00:25:00,610 --> 00:25:09,900
code becomes a flower. Of course. This is how programming works, right? And this is

00:25:09,900 --> 00:25:15,850
when you're moving that crap code, the fact that you need to move it into the actual codebase,

00:25:15,850 --> 00:25:20,750
that refactoring will happen naturally. So, moving from this set of boxes to an actual

00:25:20,750 --> 00:25:28,300
layout will improve your code. Document. So, inside our deadline program library we had

00:25:28,300 --> 00:25:35,010
documents, a paragraph about what it's doing, how to use it. And then boxes. Show what it's

00:25:35,010 --> 00:25:40,880
doing. So, I feel like this  with this process  turd driven development can kind of become

00:25:40,880 --> 00:25:46,870
more like test driven development. With CSS? What? So, what if we had thought about it

00:25:46,870 --> 00:25:52,080
like, oh, our test, instead of being the entire design, is a smaller piece of the design or

00:25:52,080 --> 00:25:58,190
a specific piece. We run the test with our eyes still and write our crap code. But the

00:25:58,190 --> 00:26:07,650
refactoring, putting it in the code, can give us that additional step of refactoring. Again,

00:26:07,650 --> 00:26:18,880
a beautiful flower. Refactor the missing piece. Let's be real. But less looking poop is greater

00:26:18,880 --> 00:26:25,950
than regular poop. But what if, so, this is a little experiment that's coming up here.

00:26:25,950 --> 00:26:30,110
What if  so, test driven development. I have been writing tests for other parts of our

00:26:30,110 --> 00:26:35,230
design system in JavaScript and I'm like, I love writing tests. There's some magic,

00:26:35,230 --> 00:26:39,891
like straight up magic when you write good tests. And I want to do this with CSS. How

00:26:39,891 --> 00:26:47,600
can we write unit tests for CSS? Domain specific declarative tests? I had an idea and wrote

00:26:47,600 --> 00:26:56,540
enthusiastic blog posts about it. Testing algorithms. So, warning, this is a big code

00:26:56,540 --> 00:27:01,010
slide and kind of a prototype of something I'm trying out with a little bit of client

00:27:01,010 --> 00:27:16,020
side JavaScript. For one of the CSS unit tests, what it could look like. So, this is essentially

00:27:16,020 --> 00:27:22,130
a couple of test methods that log to the console. And the crux is you're testing boxes against

00:27:22,130 --> 00:27:27,660
boxes. So, you're figure out relative values of certain positions and boxes and comparing

00:27:27,660 --> 00:27:33,480
them. And what this looks like in practice. The unit test might be with the minimum amount

00:27:33,480 --> 00:27:40,300
of HTML. And we're logging into the console. But this could also be an integration test

00:27:40,300 --> 00:27:46,320
on an actual application. I ordered this to the deadline staging environment and actually

00:27:46,320 --> 00:27:51,230
found a problem with this. So, this showed me that there should not be space below the

00:27:51,230 --> 00:27:55,120
last item. But there was a different set of styles that was adding that space, which is

00:27:55,120 --> 00:27:59,380
incorrect. That will cause problems later because if someone adds another widget to

00:27:59,380 --> 00:28:04,950
the side bar, it's gonna be too spaced out. And that's what cause this is like turd driven

00:28:04,950 --> 00:28:09,070
development. Especially with CSS, oh, you override it instead of going back to change

00:28:09,070 --> 00:28:16,710
the actual issue. Ah! This could be cool. So, my inner critic is like, overengineering

00:28:16,710 --> 00:28:23,380
much, Lara? Like, why are you  it's just CSS, jeez. My god. But then I'm like, no.

00:28:23,380 --> 00:28:29,760
That's the kind of thinking that causes turd driven development. Say no to that. It's okay

00:28:29,760 --> 00:28:34,480
to think about CSS like this. And in fact like the rest of software has come up with

00:28:34,480 --> 00:28:40,120
many an antidote to turds. So, general software on this end is kind of like, whoa, look at

00:28:40,120 --> 00:28:45,500
all these things we do to control our code. To create better environments and develop

00:28:45,500 --> 00:28:50,760
better programming practices. And then on the other side we have frontend and UI that

00:28:50,760 --> 00:28:56,480
has a lot of these things as well. So, design systems, atomic design, progressive enhancement.

00:28:56,480 --> 00:29:02,750
Many a CSS architecture and naming convention. And maybe these things are not that different.

00:29:02,750 --> 00:29:10,800
So, there's a lot of the same concepts that bridge these  these two kind of areas that

00:29:10,800 --> 00:29:20,740
could seem separate. But testing. I think we could do more of this. Okay. Conclusion.

00:29:20,740 --> 00:29:30,660
I'll tell a small story time. Okay. How the math hater became a programmer. This is me.

00:29:30,660 --> 00:29:40,430
14 year old Lara in 2003. I hate math. Okay? I was a staunch math hater throughout my childhood.

00:29:40,430 --> 00:29:46,390
I loved art class and horses and llamas. But at the age of 14 I was starting to become

00:29:46,390 --> 00:29:51,770
a little bit anti llama and just kind of embarrassed about that. But I loved art class and horses

00:29:51,770 --> 00:30:00,090
and Green Day. Which I didn't put up there. 2009. A little bit larger Lara. I had some

00:30:00,090 --> 00:30:05,520
blond in my hair and glasses. I was in college. 20 years old? Art school and I had a weird

00:30:05,520 --> 00:30:10,270
idea for a video game and learned how to code. I had a lot of freedom in school and very

00:30:10,270 --> 00:30:18,180
supportive parents. And then fast forward to 2015. I had been working as a freelance

00:30:18,180 --> 00:30:23,480
developer for a while and I wrote this article for CSS Tricks. Tales of a non unicorn: A

00:30:23,480 --> 00:30:29,700
story about the trouble with job titles and descriptions. This was about a role, the UI

00:30:29,700 --> 00:30:37,520
engineer/interaction designer. And I was like, yes, this is totally my thing. CSS, maybe

00:30:37,520 --> 00:30:42,620
some design, some like UI oriented JavaScript. And in the interview they asked me FizzBuzz.

00:30:42,620 --> 00:30:49,910
And FizzBuzz, for anybody unfamiliar, is sort of this beginner's algorithms question. And

00:30:49,910 --> 00:30:55,510
in the interview I was like, what? Why would anybody do this? I had been so far removed

00:30:55,510 --> 00:31:02,559
from what this algorithm in computer as someone self taught from an art background. And after

00:31:02,559 --> 00:31:09,621
I wrote this article, which became a little bit viral, there was a post on Reddit. Designer

00:31:09,621 --> 00:31:17,309
applies for JS job, fails at FizzBuzz, then proceeds to write 5 page rant about job descriptions.

00:31:17,309 --> 00:31:23,750
I was like, whoa. This was on the front page. There were all these horrible comments coming

00:31:23,750 --> 00:31:30,800
into the article. Like, awful stuff. And sob, after this experience from like 2015 to 2017,

00:31:30,800 --> 00:31:36,360
I was like, oh, hell no. Like, I am not a programmer. Computer science is not what I

00:31:36,360 --> 00:31:41,410
do. I do HTML and CSS. Computer science, not for me. Programming, not what I do. Who are

00:31:41,410 --> 00:31:48,540
these people? No thanks. I had like these two years of rebellion against that kind of

00:31:48,540 --> 00:31:54,170
identity. And late 2017 I ended up getting an interview for a job I was super excited

00:31:54,170 --> 00:32:00,550
about that was going to be an algorithms interview. No question about it. Okay. I have to learn

00:32:00,550 --> 00:32:04,460
this. Swallow my pride, FizzBuzz, let's do it. I wrote all these blog posts and put myself

00:32:04,460 --> 00:32:10,721
through computer science boot camp. And I was like, wait a second, this is for me. This

00:32:10,721 --> 00:32:18,910
is cool. I love this stuff. And it's not so different than the concepts in HTML and CSS.

00:32:18,910 --> 00:32:28,050
And in 2018 I proposed this original talk of algorithms of CSS for CSS ConfEU to bridge

00:32:28,050 --> 00:32:33,810
the gap between CSS and computer science. And throughout that talk, CSS  something

00:32:33,810 --> 00:32:39,220
I knew well before  kind of went from like CSS to like, wow. I understand what CSS is

00:32:39,220 --> 00:32:45,960
doing. Like, this is freaking amazing. I love CSS. And I realized that this is kind of the

00:32:45,960 --> 00:32:51,910
wrong metaphor. It's not like this. It's like this. So, computer science is like the big

00:32:51,910 --> 00:32:56,510
like, you know, mom giving everyone a hug. All these nice things in here. So, CSS, they're

00:32:56,510 --> 00:33:05,010
all together. So, to put a button on this. Here is FizzBuzz in CSS.

00:33:05,010 --> 00:33:16,230
[ Applause ] Okay. Okay. 2019. Is blank a blank? Is CSS

00:33:16,230 --> 00:33:23,309
a programming language? This is like a fucked up question structure. Because you can sub

00:33:23,309 --> 00:33:31,090
out the terms and have like is depression a treatable illness? Is non binary a gender?

00:33:31,090 --> 00:33:37,400
When you ask a question like this, it's opening up the option for people to say no, when as

00:33:37,400 --> 00:33:42,080
soon as you start excluding something from something else, that's a sign of much darker

00:33:42,080 --> 00:33:49,010
stuff. So, this is a smelly question. This is a culture smell. The answer is, of course.

00:33:49,010 --> 00:33:57,190
So, I'm like, what is going on? Why is this happen something why are there designers designing

00:33:57,190 --> 00:34:01,860
systems at companies, but they can't have anybody from the engineering team implement

00:34:01,860 --> 00:34:09,190
them because HTML and CSS are not considered part of engineering? Or why are there developers

00:34:09,190 --> 00:34:14,230
coming from full stack bootcamps or presenting themselves as full stack developers who don't

00:34:14,230 --> 00:34:19,700
understand fundamental characteristics of CSS? Is CSS not part of the stack anymore?

00:34:19,700 --> 00:34:25,720
What's going on? I was describing this to someone at my coworking space, kind of an

00:34:25,720 --> 00:34:34,190
old school computer science guide. His name is Dick. And why are there so many people

00:34:34,190 --> 00:34:38,859
that don't think CSS is a programming language? What's going on? He said, well, Lara, when

00:34:38,859 --> 00:34:43,839
it comes to computer science, and in computer science, there's an 800 pound gorilla in the

00:34:43,839 --> 00:34:53,190
room and it's called a testosterone. And I was like, okay. Wow. Okay. So, maybe this

00:34:53,190 --> 00:34:59,150
is the truth. Is this what  like, okay. But I don't think the answer is to not talk about

00:34:59,150 --> 00:35:04,099
it. So, when I see responses to this question, it's like, stop asking this question. Don't

00:35:04,099 --> 00:35:07,859
talk about it. Questions like that can be good because it brings out what we need to

00:35:07,859 --> 00:35:15,710
address. So, what if instead of, you know, people who know other types of programming

00:35:15,710 --> 00:35:19,789
not learning HTML and CSS because they're not programming. I know programming. I don't

00:35:19,789 --> 00:35:23,910
want to learn that, it's not my thing. And web applications suffering because of that.

00:35:23,910 --> 00:35:28,619
That's on one side. And we have people like me and I'm sure some people in this room who

00:35:28,619 --> 00:35:34,519
were focused in HTML and CSS and told you're not a real programmer. And therefore you develop

00:35:34,519 --> 00:35:42,859
this kind of oppositional identity, I'm not learning that. That was me. What if we do

00:35:42,859 --> 00:35:51,440
this, CSS and HTML are this little golden springboard. You have little people like me,

00:35:51,440 --> 00:35:57,630
little baby Lara, or people with non traditional backgrounds who don't necessarily have the

00:35:57,630 --> 00:36:02,039
ability to go into computer science programs, et cetera. HTML and CSS can be this kind of

00:36:02,039 --> 00:36:07,859
springboard into technology. And not just people that look like me. Of course, like

00:36:07,859 --> 00:36:14,829
anybody can do this. And it's also kind of a metaphor for creativity. Because I'm not

00:36:14,829 --> 00:36:19,539
that good at drawing people. I put a monster in it. It has to represent something. Creativity.

00:36:19,539 --> 00:36:26,530
Let's have more creativity and honor technology teams. HTML and CSS, this golden springboard.

00:36:26,530 --> 00:36:31,591
My question is, why aren't we valuing these skills more and embracing this technology?

00:36:31,591 --> 00:36:32,591
Instead of this is not for you, saying, yes, you are a programmer. Come, learn more. Thank

00:36:32,591 --> 00:36:33,591
you. [ Applause ]

00:36:33,591 --> 00:36:34,591
KATIE: Wow. Okay. Yes, yes. Yes, yes. Yes. You're awesome. Yes. I am so excited that

00:36:34,591 --> 00:36:35,591
we are going to lunch right now because I would feel really bad for anyone who had to

00:36:35,591 --> 00:36:36,591
follow that up. Thank you, Lara. That was amazing. Yeah. Thank you.

00:36:36,591 --> 00:36:37,591
[ Applause ] All right. So, it is lunchtime. Before you

00:36:37,591 --> 00:36:38,591
go, I have two things that I need to do. The first thing is that I need to tell you back

00:36:38,591 --> 00:36:41,869
in this room at 12:30 because folks have been so interested in learning more about how the

00:36:41,869 --> 00:36:42,869
closed captioning works, that Mux has sponsored a special presentation where the folks from

00:36:42,869 --> 00:36:43,869
White Coat are going to show us how their closed captioning works and how they transcribe

00:36:43,869 --> 00:36:44,869
things so quickly. And the second thing that I need to do, because my 8 year old daughter

00:36:44,869 --> 00:36:45,869
and my 6 year old son are in the back of the room is I need to tell you all a joke that

00:36:45,869 --> 00:36:46,869
my daughter told me. All right. So, why is a seagull called a seagull?

00:36:46,869 --> 00:36:47,869
Cause if it flew over a bay, it would be called a beagle.

00:36:47,869 --> 00:36:48,869
[ Applause ] All right. So, everyone go and enjoy your

00:36:48,869 --> 00:36:49,869
lunch and we'll see you back here or in the scythe HPE room when lunch is done.

00:36:49,869 --> 00:36:50,869
test this is test.


YouTube URL: https://www.youtube.com/watch?v=panKf9hzUfQ


