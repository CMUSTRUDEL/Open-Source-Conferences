Title: We Started Using Webpack and It Took A While - Salem Hilal - JSConf US 2019
Publication date: 2019-09-16
Playlist: JSConf US 2019
Description: 
	There are so many benefits to using a modern JavaScript build system, but getting one to play nicely with a very old, very large codebase is not always easy. I'll go over some of the more interesting problems we ran into at Etsy when migrating to Webpack from a system written in-house. We'll talk about working in a large codebase without running out of memory, localizing our JavaScript into 15 languages without building it 15 times, and why 4 milliseconds kept us from launching the new system for 3 months.
Captions: 
	00:00:00,160 --> 00:00:05,569
We Started Using Webpack and it Took a While - Salem Hilal

00:00:05,569 --> 00:00:06,569
>> Hello?

00:00:06,569 --> 00:00:07,569
Hello, hi!, oh, my God, oh, my God, oh, my God, I'm so excited!

00:00:07,569 --> 00:00:08,569
My coworker, Salem, is about to come up on stage and tell you about the migration process

00:00:08,569 --> 00:00:09,860
of moving to Webpack and what a kind of disaster that was.

00:00:09,860 --> 00:00:10,920
But it's a really interesting disaster, I promise.

00:00:10,920 --> 00:00:12,530
So Salem gave me some fun facts but I'm going to go totally on my own and tell you my fun

00:00:12,530 --> 00:00:13,530
facts and favorite things about Salem.

00:00:13,530 --> 00:00:14,530
The first thing that you need to know about Salem is he gives the world's best hugs, literally,

00:00:14,530 --> 00:00:15,530
so all of you need to be good-enough friends with him by the end of the conference so that

00:00:15,530 --> 00:00:16,530
he could give you a hug and trust me, you will, like, love it for the rest of your life.

00:00:16,530 --> 00:00:17,530
The other thing that you need to know about Salem is that we have regular Etsy-wide smash

00:00:17,530 --> 00:00:18,530
tournaments, we had one the other night.

00:00:18,530 --> 00:00:19,530
I was not there, but my husband went, and apparently do not let him play at duck hunt

00:00:19,530 --> 00:00:20,530
because he will hide in the corner and throw beans at everybody.

00:00:20,530 --> 00:00:21,530
All right, so everyone, gave it up for Salem Hilal.

00:00:21,530 --> 00:00:22,530
[applause]

00:00:22,530 --> 00:00:23,530
Oh, my gosh, that was the nicest thing that anyone has ever said about me.

00:00:23,530 --> 00:00:24,530
It's also very bright up here, everyone's right, everybody said that already.

00:00:24,530 --> 00:00:25,530
Thank you, Katie, I'll say thank you so much to everybody who has organized JSConf, it

00:00:25,530 --> 00:00:26,530
is unreal to be up on stage.

00:00:26,530 --> 00:00:27,530
I can hear my voice echo.

00:00:27,530 --> 00:00:28,530
That makes it sound like I'm in a stadium, that's so cool.

00:00:28,530 --> 00:00:29,530
My name is Salem, if you know about the cat, and my pronouns are he/him, and I work at

00:00:29,530 --> 00:00:30,530
Etsy and we're hiring.

00:00:30,530 --> 00:00:31,530
This is my very first conference talk, as well, so if you have any feedback for me,

00:00:31,530 --> 00:00:32,530
please do not withhold it.

00:00:32,530 --> 00:00:33,530
I would love to hear about it.

00:00:33,530 --> 00:00:34,530
So.

00:00:34,530 --> 00:00:41,370
OK, cool I wanted to talk about how we migrated from an in-house system to Webpack and specifically

00:00:41,370 --> 00:00:47,630
I want to talk about why it took us so long to do that.

00:00:47,630 --> 00:00:52,399
I work at a team at Etsy called the web platform team.

00:00:52,399 --> 00:00:55,540
If you've ever worked at a place that has a front-end infrastructure team it's probably

00:00:55,540 --> 00:01:02,769
very similar.

00:01:02,769 --> 00:01:09,860
This talk is essentially about how we moved from one build system another, but this doesn't

00:01:09,860 --> 00:01:18,861
mean I'm going to talk about -- my goal here is to talk about the weird problems that we

00:01:18,861 --> 00:01:21,610
unearthed and how we fixed them and where all my hair went.

00:01:21,610 --> 00:01:22,610
[laughter]

00:01:22,610 --> 00:01:26,570
So this talk is like about five parts.

00:01:26,570 --> 00:01:29,630
I'm going to first tell you about a little bit about Etsy and our old build system that

00:01:29,630 --> 00:01:41,480
we called Builda, and then this really weird rolling it out.

00:01:41,480 --> 00:01:49,170
So that's going to be a fun one, so if the beginning parts are boring, at least stay

00:01:49,170 --> 00:01:50,310
till the end.

00:01:50,310 --> 00:01:55,390
So before I get into it, there are two caveats that are worth mentioning, number one, the

00:01:55,390 --> 00:02:00,750
decisions that we made were true at the time we made them.

00:02:00,750 --> 00:02:10,100
JavaScript as you all probably know changes very quickly, which is the whole reason that

00:02:10,100 --> 00:02:14,370
we wanted a really flexible build system in the first place and No. 2, all of the things

00:02:14,370 --> 00:02:16,930
that I'm going to talk about today are big team efforts.

00:02:16,930 --> 00:02:27,280
I know a whole lot about how Etsy's front end infrastructure on behalf of my whole team

00:02:27,280 --> 00:02:30,600
that kind of collectively built and researched all the things that I'm going to talk about

00:02:30,600 --> 00:02:31,600
today.

00:02:31,600 --> 00:02:34,000
They kick ass, and I really love working with them.

00:02:34,000 --> 00:02:39,440
I think Joe is right up there somewhere in the front.

00:02:39,440 --> 00:02:41,080
That's my teammate Joe.

00:02:41,080 --> 00:02:53,260
There's also John and Natalia who are not here but they're great to work with.

00:02:53,260 --> 00:02:57,070
It's hard to tell you about a migration process without giving you a little bit of context.

00:02:57,070 --> 00:03:04,120
So here it is, this is Etsy's codebase, it's like anyone's codebase at a medium sized company.

00:03:04,120 --> 00:03:06,270
Some.

00:03:06,270 --> 00:03:18,310
That is to say, the code that makes Etsy show up in your web browser from the API all the

00:03:18,310 --> 00:03:21,450
way down to the CSS lives in one.

00:03:21,450 --> 00:03:28,050
We call our mono repoetsy web, it's worked surprisingly well for us, it has helped us

00:03:28,050 --> 00:03:33,800
facilitate.

00:03:33,800 --> 00:03:42,410
One thing that did not scale very well when we moved was the JavaScript part of our codebase.

00:03:42,410 --> 00:03:45,600
And.

00:03:45,600 --> 00:04:00,250
So this system is something that we named Builda.

00:04:00,250 --> 00:04:05,940
For those of you who may not be familiar with JavaScript build systems, a build system is

00:04:05,940 --> 00:04:11,520
something that takes our files, resolves their dependencies, bundles them together, makes

00:04:11,520 --> 00:04:19,380
them as small and efficient as possible, and (audio is breaking out).

00:04:19,380 --> 00:04:30,410
we got to hit play on this part.

00:04:30,410 --> 00:04:42,550
It's going to be like a carnival game where I have to aim on the screen.

00:04:42,550 --> 00:04:43,550
Boop?

00:04:43,550 --> 00:04:44,550
One more time.

00:04:44,550 --> 00:04:48,560
Yay, there it goes, so when BBuilda was first written, it wasn't this sleek interactive

00:04:48,560 --> 00:04:54,910
home page that you see here, complete with cool animations and a responsive navigation

00:04:54,910 --> 00:04:57,600
bar and a really cool branding.

00:04:57,600 --> 00:05:04,090
It looked more like that.

00:05:04,090 --> 00:05:07,780
Having one file depend on another was pretty infrequent and when that did happen it was

00:05:07,780 --> 00:05:14,400
usually for large globally scoped libraries, like JQuery ...

00:05:14,400 --> 00:05:21,560
Production builds took very little time.

00:05:21,560 --> 00:05:23,060
At Etsy, this is pretty important.

00:05:23,060 --> 00:05:27,310
We deploy code dozens of times in a single day and slowing down deployment is something

00:05:27,310 --> 00:05:31,380
we'd try to avoid at all costs.

00:05:31,380 --> 00:05:34,490
So developing JavaScript was similarly pretty simple.

00:05:34,490 --> 00:05:36,840
That's supposed to be me.

00:05:36,840 --> 00:05:41,000
If we load a page in development that requests some JavaScript, that JavaScript file would

00:05:41,000 --> 00:05:45,010
be built from our source and sent back inside of one request.

00:05:45,010 --> 00:05:49,480
To keep track of all the possible files that we might need to request, we kept a list of

00:05:49,480 --> 00:05:52,180
all of them which we brilliantly called the build list.

00:05:52,180 --> 00:05:55,650
When we served a file we'd make sure it was in that list somewhere.

00:05:55,650 --> 00:05:59,460
The build list was used in production then later to determine the entirety of what we

00:05:59,460 --> 00:06:05,669
needed to build when we deployed [inaudible] in development if a requested file was not

00:06:05,669 --> 00:06:11,830
the build list we'd respond with some JavaScript that threw us an exception.

00:06:11,830 --> 00:06:16,110
This ensured that we could essentially build any file we wanted on demand.

00:06:16,110 --> 00:06:24,810
We used require.js to manage our delinquencies.

00:06:24,810 --> 00:06:28,670
Maybe you haven't even heard of this because it's a relatively old library but we still

00:06:28,670 --> 00:06:37,530
used it and it was pretty simple up until we moved to Webpack, that is.

00:06:37,530 --> 00:06:40,130
We'd follow it down with some of our own code.

00:06:40,130 --> 00:06:44,639
Require.js then allows our own code to use any style module definitions as you can see

00:06:44,639 --> 00:06:45,639
here.

00:06:45,639 --> 00:06:48,920
For some of you this might sound out of the stone age but for us it was pretty cutting

00:06:48,920 --> 00:06:55,900
edge when we did this.

00:06:55,900 --> 00:06:59,680
Async ... We defined an array of imports which require

00:06:59,680 --> 00:07:04,320
then resolve for us.

00:07:04,320 --> 00:07:07,890
All of our code goes to the body of one of these callbacks where it has access to all

00:07:07,890 --> 00:07:09,830
of the imports.

00:07:09,830 --> 00:07:14,620
Builda's job was to make sure that all of the necessary modules were bundled into one

00:07:14,620 --> 00:07:19,870
JavaScript file so that require.js has access to everything it needed in the browser.

00:07:19,870 --> 00:07:22,910
At some point, React came along.

00:07:22,910 --> 00:07:28,110
React is just a library that makes writing large, client-side applications a lot easier.

00:07:28,110 --> 00:07:33,810
Sometime around 2016, we decided it would be a really good fit for some of our seller

00:07:33,810 --> 00:07:35,740
tools.

00:07:35,740 --> 00:07:36,740
Everyone was excited.

00:07:36,740 --> 00:07:42,900
React, however, strongly relies on a syntax that looks like HTML controversially aligned

00:07:42,900 --> 00:07:43,900
into JavaScript.

00:07:43,900 --> 00:07:47,462
If you want to be able to use this syntax, we need to make a build system that it can

00:07:47,462 --> 00:07:54,280
do more than just build files together.

00:07:54,280 --> 00:07:56,740
So we used an old version of.

00:07:56,740 --> 00:08:04,520
(Audio breaking out) So it's a stapler.

00:08:04,520 --> 00:08:16,480
I added the staples last night.

00:08:16,480 --> 00:08:21,751
There was one problem with this setup, however, because we built every file only when it was

00:08:21,751 --> 00:08:26,090
requested rather than when some part of it was edited we had no way of knowing if it

00:08:26,090 --> 00:08:29,229
had changed or not since the last time it was requested.

00:08:29,229 --> 00:08:33,719
So we had to rebuild every asset every time we wanted to use it.

00:08:33,719 --> 00:08:40,969
Transpiling JSX into JavaScript -- so React heavily ended up taking a good bit longer

00:08:40,969 --> 00:08:43,740
in order to be served.

00:08:43,740 --> 00:08:50,629
But JSX was new, so few few people felt the pain of long rebuild times in development.

00:08:50,629 --> 00:08:54,449
Besides, it's just JavaScript, right?

00:08:54,449 --> 00:08:58,139
We know it didn't last very long.

00:08:58,139 --> 00:09:02,580
All of these quirks together meant that loading something large, like a single-page app implied

00:09:02,580 --> 00:09:07,149
rebuilding the entire thing from scratch every time the page reloaded, plus our codebase

00:09:07,149 --> 00:09:16,529
was only getting bigger, we had over 1,000 separate JavaScript assets to output.

00:09:16,529 --> 00:09:20,379
React code was use in a lot more places and it started to take the better part of a minute

00:09:20,379 --> 00:09:24,899
to show up on the page in development which made iterating very, very tedious, on top

00:09:24,899 --> 00:09:28,329
of this, developers were starting to ask for the ability to use ES6.

00:09:28,329 --> 00:09:34,889
It felt like a nonstarter for us, React support was difficult to implement and when it worked,

00:09:34,889 --> 00:09:37,470
it certainly wasn't sustainable.

00:09:37,470 --> 00:09:41,910
We knew we needed to do something.

00:09:41,910 --> 00:09:45,839
This is where I've told myself that I'm going to drink water and you all are going to take

00:09:45,839 --> 00:09:49,980
15 seconds to introduce yourself to the people next to you so that you don't hear me gulping

00:09:49,980 --> 00:09:51,290
over the microphone.

00:09:51,290 --> 00:09:52,290
All right, time's up.

00:09:52,290 --> 00:09:53,290
I'm going to test all of you later so I hope you all paid attention.

00:09:53,290 --> 00:09:54,290
OK, I gotta hurry up because I'm already running behind my schedule.

00:09:54,290 --> 00:09:55,290
(mic is cutting in and out.)

00:09:55,290 --> 00:09:56,290
Can you hear me OK?

00:09:56,290 --> 00:09:57,290
>> Can you still hear me OK?

00:09:57,290 --> 00:09:58,290
All right, awesome.

00:09:58,290 --> 00:09:59,290
OK, cool.

00:09:59,290 --> 00:10:00,290
So I drank my water and it is now time for me to talk about the solution to every one

00:10:00,290 --> 00:10:01,290
of our problems.

00:10:01,290 --> 00:10:03,440
People started talking around this time about this brand new open source build system, it

00:10:03,440 --> 00:10:05,180
was called Webpack.

00:10:05,180 --> 00:10:06,529
You might have heard of it.

00:10:06,529 --> 00:10:13,389
These are all the GIFs for my entire presentation, they are just right here.

00:10:13,389 --> 00:10:16,509
All right, any new developer that we hired, asked if we could use Webpack and the internet

00:10:16,509 --> 00:10:26,970
made it sound like every tech company that used JavaScript also used Webpack.

00:10:26,970 --> 00:10:31,839
It sounded a lot like Builda in that it built stuff, but it also sounded very different

00:10:31,839 --> 00:10:37,050
in that it had a robust development experience, it was highly extensible and it had a bunch

00:10:37,050 --> 00:10:40,790
of built-in performance optimizations for our code.

00:10:40,790 --> 00:10:45,790
Most of all it was supposed to be very fast, especially for development.

00:10:45,790 --> 00:10:46,790
So we did a little research.

00:10:46,790 --> 00:10:51,720
I wanted to point out, this is a fast chicken.

00:10:51,720 --> 00:10:54,290
[laughter]

00:10:54,290 --> 00:10:57,249
It's a recurring motif, so keep it in mind.

00:10:57,249 --> 00:11:01,339
So we did a little bit of research, we evaluated a bunch of alternatives and we decided that

00:11:01,339 --> 00:11:05,119
going down the path of building our JavaScript with Webpack instead of Builda was the right

00:11:05,119 --> 00:11:09,899
path.

00:11:09,899 --> 00:11:13,360
We had two requirements for any new system that we wanted to adopt.

00:11:13,360 --> 00:11:17,860
Number one, it would have to take care of development builds without too much interacts

00:11:17,860 --> 00:11:23,280
from developers, one of the nicest things about Builda, you could navigate the entire

00:11:23,280 --> 00:11:32,910
site without having to worry about how the Builda requirement looked.

00:11:32,910 --> 00:11:36,040
Etsy deploys code to production dozens of times in a day.

00:11:36,040 --> 00:11:41,129
If our builds took longer than five minutes, Etsy's deployments would slow down, which

00:11:41,129 --> 00:11:43,209
is not a good thing for us.

00:11:43,209 --> 00:11:49,410
So Webpack, what was cool about Webpack for us, well, it's highly configurable.

00:11:49,410 --> 00:11:59,259
Instead of a build list, Webpack uses a configuration file usually called Webpack.config.

00:11:59,259 --> 00:12:03,379
From how you'd like to support templates, if any, to what sort of performance optimizations

00:12:03,379 --> 00:12:04,379
you'd like to make.

00:12:04,379 --> 00:12:09,040
This oftentimes means really large really scary config files, which isn't always the

00:12:09,040 --> 00:12:11,889
right idea for small projects.

00:12:11,889 --> 00:12:18,059
But having something that could adapt and fit to our code was very invaluable.

00:12:18,059 --> 00:12:25,910
We spent a while writing out a really nice Webpack.config file and also different features

00:12:25,910 --> 00:12:29,870
that Builda currently supported which at the time included everything from transpiling

00:12:29,870 --> 00:12:33,290
templates.

00:12:33,290 --> 00:12:37,799
After spending hours, setting things up just right, we finally got Webpack to build our

00:12:37,799 --> 00:12:41,809
whole codebase, but it wasn't quite what we expected.

00:12:41,809 --> 00:12:44,160
It took about a half hour to do.

00:12:44,160 --> 00:12:50,760
It ate up 20 gigs of our servers' memory and maxed out every single one of its cores.

00:12:50,760 --> 00:12:52,959
This is a real screenshot.

00:12:52,959 --> 00:13:01,940
And it had the unclear progress indicator that everyone has come to know and love.

00:13:01,940 --> 00:13:05,029
[laughter]

00:13:05,029 --> 00:13:09,040
This made it exceptionally hard to figure out why it was so slow.

00:13:09,040 --> 00:13:12,139
So we definitely had a lot to learn about improving Webpack's performance but at the

00:13:12,139 --> 00:13:17,489
end of the day we needed to change a lot about how our codebase worked and how Webpack worked

00:13:17,489 --> 00:13:20,639
with it if we wanted to use it with Etsy.

00:13:20,639 --> 00:13:28,679
All right, I'm drinking water again, so tell the person next to you what your text editor

00:13:28,679 --> 00:13:31,930
of choice is without trying to convince them that yours is the right one.

00:13:31,930 --> 00:13:32,930
[laughter]

00:13:32,930 --> 00:13:33,930
OK, how we doing?

00:13:33,930 --> 00:13:34,930
Good?

00:13:34,930 --> 00:13:35,930
All right.

00:13:35,930 --> 00:13:36,930
I gotta hurry up.

00:13:36,930 --> 00:13:37,930
I am, like I said, not on schedule.

00:13:37,930 --> 00:13:38,930
I hope the answer was vim, but that's OK if it wasn't.

00:13:38,930 --> 00:13:39,930
[applause]

00:13:39,930 --> 00:13:45,009
OK, our first order of business was to get a development workflow that was good.

00:13:45,009 --> 00:13:48,109
If engineers could develop with Webpack and validate that their code still worked with

00:13:48,109 --> 00:13:59,079
Builda in production we wouldn't be able to offer new features like ES6 yet since Builda

00:13:59,079 --> 00:14:01,439
didn't know anything about ES6 transformation.

00:14:01,439 --> 00:14:05,899
But maybe we could let the engineers have a good time doing it.

00:14:05,899 --> 00:14:12,050
And so why does Webpack take so long to build.

00:14:12,050 --> 00:14:16,059
When Webpack first starts it does a complete build of all of your code first.

00:14:16,059 --> 00:14:20,579
Then it enters watch mode.

00:14:20,579 --> 00:14:23,360
It kicks off a portion rebuild every time it sees one.

00:14:23,360 --> 00:14:27,489
This pattern developed to be extremely fast.

00:14:27,489 --> 00:14:33,879
We figured that the longer builds would probably be much better but if that initial build took

00:14:33,879 --> 00:14:39,259
a half hour and ate up all of our memory, it wouldn't be all that good.

00:14:39,259 --> 00:14:41,809
So our codebase was really big and was getting even bigger.

00:14:41,809 --> 00:14:46,660
So it would have to scale.

00:14:46,660 --> 00:14:53,300
Well, Webpack makes inferences about your code in the context of your whole project.

00:14:53,300 --> 00:14:58,059
For example, it is smart enough to group commonly requested modules together so that they can

00:14:58,059 --> 00:15:00,339
be cast efficiently between pages.

00:15:00,339 --> 00:15:04,000
It can only make these optimizations if it understands your entire project, not just

00:15:04,000 --> 00:15:05,499
your individual files.

00:15:05,499 --> 00:15:14,639
This is good if your project is nicely scoped but it makes a lot less sense in a mono repo.

00:15:14,639 --> 00:15:19,259
So we started by trying to make Webpack faster and less resource intensive in general, something

00:15:19,259 --> 00:15:21,339
that's really hard to do both of at the same time.

00:15:21,339 --> 00:15:27,999
We got a lot of mileage from caching plugins like cache-loader and hard source and allowing

00:15:27,999 --> 00:15:34,699
modules in parallel but at the end of the day we still had a prohibitively heavy first

00:15:34,699 --> 00:15:35,769
build time.

00:15:35,769 --> 00:15:37,929
I can't believe I found this image.

00:15:37,929 --> 00:15:39,279
It's amazing.

00:15:39,279 --> 00:15:41,179
We also looked at Webpack's development server.

00:15:41,179 --> 00:15:47,999
The development server chooses to keep everything in memory.

00:15:47,999 --> 00:15:52,290
For us this meant that our whole codebase, plus all the transformation information about

00:15:52,290 --> 00:15:58,369
the whole codebase, plus all of the build files for the whole codebase had to fit in

00:15:58,369 --> 00:15:59,779
memory.

00:15:59,779 --> 00:16:06,179
There isn't a way to turn this off without modifying the development servers source code

00:16:06,179 --> 00:16:10,449
which is actually a really nicely written repository and if you're interested in how

00:16:10,449 --> 00:16:14,419
these things work, I would totally recommend reading through the source.

00:16:14,419 --> 00:16:18,579
Even if there was a way to turn this off, it wasn't clear that it would save ourselves

00:16:18,579 --> 00:16:27,970
from the size of our mono repo over time.

00:16:27,970 --> 00:16:31,429
One really easy solution was just to make a bunch of different config files for different

00:16:31,429 --> 00:16:35,439
areas of the codebase and only build the one that was being used at the time.

00:16:35,439 --> 00:16:39,069
We can make each region be small enough so that memory is reasonable and initial build

00:16:39,069 --> 00:16:42,110
times are closer to one minute rather than 11.

00:16:42,110 --> 00:16:56,410
For us this meant splitting our codebase into 11 regions was 

00:16:56,410 --> 00:16:58,809
the right number.

00:16:58,809 --> 00:17:03,089
Juggling a bunch of configurations just to browser on Etsy on your work machine was not

00:17:03,089 --> 00:17:04,089
ideal.

00:17:04,089 --> 00:17:06,910
This meant that we probably needed to write something of our own.

00:17:06,910 --> 00:17:11,380
So we wrote a thing called Kevin.

00:17:11,380 --> 00:17:15,959
Kevin is a plugin for the express web server framework.

00:17:15,959 --> 00:17:18,620
And its only job is to manage a bunch of Webpack instances.

00:17:18,620 --> 00:17:21,040
Why did we name it Kevin?

00:17:21,040 --> 00:17:22,640
Look how funny he is.

00:17:22,640 --> 00:17:28,449
When a request for any file comes in, Kevin determines when Webpack config is responsible

00:17:28,449 --> 00:17:33,700
for building that file, if any, and then it starts a Webpack instance for that config.

00:17:33,700 --> 00:17:38,330
Once the compiler is finished, it starts running that code in watch mode rebuilding files as

00:17:38,330 --> 00:17:41,510
they're edited.

00:17:41,510 --> 00:17:46,360
If Kevin gets a request for another file in a different config, it does the same thing.

00:17:46,360 --> 00:17:52,810
If there are too many compilers running, Kevin will shut down that compiler based on a frequency

00:17:52,810 --> 00:17:54,510
and recency model.

00:17:54,510 --> 00:17:58,490
This keeps us from building the whole codebase and it has an added benefit of making sure

00:17:58,490 --> 00:18:05,310
that the codebase has regions of it that are all related to each other.

00:18:05,310 --> 00:18:09,570
The only extra thing to consider is that really long first build.

00:18:09,570 --> 00:18:15,010
If a request for a JavaScript file times out after 30 seconds, and starting up the Webpack

00:18:15,010 --> 00:18:18,560
server takes closer to a minute we're going to end up timing in development for what seems

00:18:18,560 --> 00:18:20,260
like no reason.

00:18:20,260 --> 00:18:22,530
Kid in time out.

00:18:22,530 --> 00:18:29,990
That's a joke.

00:18:29,990 --> 00:18:33,430
It is modeled after the Domino's Pizza tracker.

00:18:33,430 --> 00:18:37,620
We also exposed some data about the status of every active compiler so that the overlay

00:18:37,620 --> 00:18:44,130
is able to monitor the status of its build.

00:18:44,130 --> 00:18:48,420
Keeps memory usage low and keeps engineers informed about the state of all of their builds

00:18:48,420 --> 00:18:51,110
without requiring them to manage a build system.

00:18:51,110 --> 00:18:54,790
With any luck, Kevin will be available as open source software very soon.

00:18:54,790 --> 00:18:56,790
All right, another water break.

00:18:56,790 --> 00:19:00,640
In 15 seconds or less, tell a neighbor what you did for adventure day.

00:19:00,640 --> 00:19:01,640
Go!

00:19:01,640 --> 00:19:02,640
All right, that is the 15-second warning.

00:19:02,640 --> 00:19:05,500
Let me really quickly talk about productionizing your code and then that GC bug that I've been

00:19:05,500 --> 00:19:10,880
waiting for.

00:19:10,880 --> 00:19:15,430
I want to talk about localization, since there's a lot of other less interesting things that

00:19:15,430 --> 00:19:18,050
went into getting our code production ready.

00:19:18,050 --> 00:19:21,300
So at this point development was working.

00:19:21,300 --> 00:19:25,391
We even started to onboard a handful of developers so they could start giving us feedback, most

00:19:25,391 --> 00:19:26,610
of which was pretty good.

00:19:26,610 --> 00:19:34,970
Because we weren't building production code with Builda packet.

00:19:34,970 --> 00:19:39,280
The benefits of Webpack brought to the development speed were wins in and of themselves.

00:19:39,280 --> 00:19:42,790
Our next order of business was to get production to have that same speed.

00:19:42,790 --> 00:19:47,031
There is that chicken again, reminding us that we need to get five-minute production

00:19:47,031 --> 00:19:48,220
goals.

00:19:48,220 --> 00:19:52,670
A working development environment meant that we were at least able to successfully build

00:19:52,670 --> 00:19:55,330
our code.

00:19:55,330 --> 00:19:59,570
This involved minifying it but more critically it meant localizing all of our assets into

00:19:59,570 --> 00:20:02,030
11 different languages.

00:20:02,030 --> 00:20:05,860
Localization is a little tricky with Webpack.

00:20:05,860 --> 00:20:09,510
You need to kick off a separate Webpack build.

00:20:09,510 --> 00:20:13,720
Webpack's localization plugin uses a file that provides localized strings that you provide

00:20:13,720 --> 00:20:16,340
and.

00:20:16,340 --> 00:20:18,410
It seems simple enough.

00:20:18,410 --> 00:20:22,360
Using this method, constant strings can be defined in one file and swapped out between

00:20:22,360 --> 00:20:25,040
builds without your JavaScript changing.

00:20:25,040 --> 00:20:27,580
There is an implication here that is a little tricky.

00:20:27,580 --> 00:20:32,370
Webpack ends up with a different configuration because the plugin needs to be configured

00:20:32,370 --> 00:20:34,140
differently will for each language.

00:20:34,140 --> 00:20:39,040
This means that in order to run 11 different languages, you need to run 11 Webpack builds.

00:20:39,040 --> 00:20:46,710
Again, 34 course, 62 gigs of ram?

00:20:46,710 --> 00:20:50,350
It's really big.

00:20:50,350 --> 00:20:54,410
We could maybe run two in parallel and have the resources and get like 8 or 9 minutes

00:20:54,410 --> 00:20:55,410
for those two builds.

00:20:55,410 --> 00:21:00,580
But that would still mean that all of our builds would take like an hour.

00:21:00,580 --> 00:21:09,670
We couldn't just ask for new hardware, let alone

00:21:09,670 --> 00:21:12,790
a dozen or so of the most powerful computers that we used to have.

00:21:12,790 --> 00:21:18,450
If we were trying to keep pace with Builda, we were going to have to cheat a little bit.

00:21:18,450 --> 00:21:22,920
Luckily for us, cheating is OK, because Builda cheats, too.

00:21:22,920 --> 00:21:27,830
Let me explain what I mean here.

00:21:27,830 --> 00:21:33,320
Builda doesn't build that code 11 different times.

00:21:33,320 --> 00:21:40,090
Later, when that Builda's mostly done and it looks like word salad, it goes back through

00:21:40,090 --> 00:21:46,200
each file, finds those placeholders and swaps them out for actual localized strings in every

00:21:46,200 --> 00:21:47,390
language.

00:21:47,390 --> 00:21:53,180
If you speak French, you will know that this is an accurate translation.

00:21:53,180 --> 00:21:57,160
Compared with Webpack's apparently deprecated international plugin, this seemed like a much

00:21:57,160 --> 00:21:58,500
faster approach.

00:21:58,500 --> 00:22:03,670
I actually didn't know this was deprecated at the time I wrote this talk, so like I said,

00:22:03,670 --> 00:22:05,440
JavaScript changes very quickly.

00:22:05,440 --> 00:22:13,870
Anyways, we tweaked our plugins and had them insert placeholders, instead.

00:22:13,870 --> 00:22:24,380
From there, we would do a find and replace.

00:22:24,380 --> 00:22:26,860
This is actually a lot easier than it sounds.

00:22:26,860 --> 00:22:30,040
This whole screenshot is essentially all of the code but here are the juicy bits.

00:22:30,040 --> 00:22:37,770
We're able to take our source code and call dot split on it with our placeholder.

00:22:37,770 --> 00:22:43,780
Would iterate through the odd indexes and translate them.

00:22:43,780 --> 00:22:52,050
In case you're curious we get our translations from a separate service that we maintain.

00:22:52,050 --> 00:22:57,140
This message was actually so fast that we were able to provide localization in development.

00:22:57,140 --> 00:23:00,930
That's why Kevin has Italian on his forehead.

00:23:00,930 --> 00:23:05,080
We could do this quick enough by translating things as they were requested, rather than

00:23:05,080 --> 00:23:07,810
build every file into every language possible.

00:23:07,810 --> 00:23:10,740
Thanks to this method we were able to get our production builds ready in well under

00:23:10,740 --> 00:23:11,840
5 minutes.

00:23:11,840 --> 00:23:18,060
OK, in 15 seconds or less, tell your neighbor if you can speak more than one language.

00:23:18,060 --> 00:23:19,060
OK, that is about 15 seconds.

00:23:19,060 --> 00:23:20,060
Give or take.

00:23:20,060 --> 00:23:21,060
I heard more than yes or no, so I don't know what you were talking about.

00:23:21,060 --> 00:23:22,240
For the last part of this talk, let me tell you about that 4 milliseconds that kept us

00:23:22,240 --> 00:23:25,900
from building this whole thing 3 months earlier than we actually did.

00:23:25,900 --> 00:23:30,670
So we felt we were ready to try Webpack on code production traffic.

00:23:30,670 --> 00:23:34,830
We were very excited.

00:23:34,830 --> 00:23:37,880
A bunch of our end to end tests showed that things were the same.

00:23:37,880 --> 00:23:41,290
However, build systems are very hard to replace.

00:23:41,290 --> 00:23:46,150
A new build system has to work in every language in every page in the site like we talked about,

00:23:46,150 --> 00:23:53,480
but it also has to work on every browser, no mart how old or cutting edge it may be.

00:23:53,480 --> 00:23:57,330
So what do we want to do?

00:23:57,330 --> 00:24:00,960
We run an A/B test.

00:24:00,960 --> 00:24:03,640
A stock photo of an A/B test.

00:24:03,640 --> 00:24:07,560
We actually ran five separate ones, and they all look pretty good.

00:24:07,560 --> 00:24:10,680
You can see the important metrics that we checked.

00:24:10,680 --> 00:24:17,450
And yet, in spite of all this, we had some pretty alarming changes in every one of our

00:24:17,450 --> 00:24:19,540
browser performance metrics.

00:24:19,540 --> 00:24:22,540
Every page was running way slower than we expected.

00:24:22,540 --> 00:24:26,970
Some of our pages are up to 14% slower which is unheard of.

00:24:26,970 --> 00:24:33,140
In the general view if your site's performance gets worse, so does your site's money.

00:24:33,140 --> 00:24:38,140
We had to figure out what was going on before we could launch Webpack.

00:24:38,140 --> 00:24:41,390
Before I go on, let me talk about our client-side metrics very quickly.

00:24:41,390 --> 00:24:44,450
Many of you probably know this sort of thing, but some of you may not and I hope this is

00:24:44,450 --> 00:24:45,450
a good refresher.

00:24:45,450 --> 00:24:50,580
At Etsy we track a lot of things, but two in particular.

00:24:50,580 --> 00:24:54,080
One is DOMContentLoaded and one is page load.

00:24:54,080 --> 00:24:59,460
So when the browser parses our HTML it goes through line by line and evals everything

00:24:59,460 --> 00:25:03,130
one line at a time.

00:25:03,130 --> 00:25:06,940
It downloads and executes the whole thing before continuing to parse the page.

00:25:06,940 --> 00:25:15,000
Some things like this image tag will -- here is our JavaScript at the very bottom.

00:25:15,000 --> 00:25:19,880
Like CSS, JavaScript is downloaded and executed before the browser can continue.

00:25:19,880 --> 00:25:24,210
Some JavaScript code, like a network request or timeout calls do not block the browser

00:25:24,210 --> 00:25:28,500
and are added to a list of tasks that the browser can take care of at a later time.

00:25:28,500 --> 00:25:33,040
Finally it fires the DOM-content loaded event.

00:25:33,040 --> 00:25:38,830
There it is!

00:25:38,830 --> 00:25:45,490
Once all of our subresources load -- that is a thing that you can buy on Etsy.com

00:25:45,490 --> 00:25:49,000
Once all of our subresources load like that image and when the browser has run enough

00:25:49,000 --> 00:26:01,490
tasks to really take care of it says that the fires the page.

00:26:01,490 --> 00:26:06,670
Both of these were slower for us, this raised two questions: What is so small, yet so different

00:26:06,670 --> 00:26:08,130
that we've miss it had?

00:26:08,130 --> 00:26:12,990
And two, if something is so different, why do people still buy things on Etsy.com so

00:26:12,990 --> 00:26:17,270
we started investigating or performance monitoring code and we double-checked that we weren't

00:26:17,270 --> 00:26:21,520
shipping extra code to our clients but both of these things turned up nothing so we decided

00:26:21,520 --> 00:26:25,310
to investigate how our code was running in the browser.

00:26:25,310 --> 00:26:31,430
This is a flame graph for the listing page that shows the item for sale on Etsy.

00:26:31,430 --> 00:26:34,320
The graph shows our code built with Builda.

00:26:34,320 --> 00:26:42,280
Horizontal axis represents time the every rectangle represents a function call, and

00:26:42,280 --> 00:26:46,560
everything below that is a subtask related to it.

00:26:46,560 --> 00:26:52,870
This shows what the browser does when it parses the main JavaScript file on the page.

00:26:52,870 --> 00:26:55,370
Now, what does Webpack's look like?

00:26:55,370 --> 00:26:57,000
A lot worse.

00:26:57,000 --> 00:27:01,310
This is the same file as the previous graph, but it's taking 4 times as long.

00:27:01,310 --> 00:27:03,690
For kicks, here they are side by side.

00:27:03,690 --> 00:27:05,770
Clearly Builda is doing a lot less.

00:27:05,770 --> 00:27:09,950
So this is kind of concerning.

00:27:09,950 --> 00:27:11,520
So why is this happening?

00:27:11,520 --> 00:27:14,600
Even if our conversion numbers look good, this big difference may mean that we're missing

00:27:14,600 --> 00:27:16,210
a performance win.

00:27:16,210 --> 00:27:19,230
Let's take another look at the whole graph built with Builda.

00:27:19,230 --> 00:27:21,960
This is roughly the area that we were looking at before.

00:27:21,960 --> 00:27:26,890
This is where DOMContentLoading fires, this is page load and this is where our JavaScript

00:27:26,890 --> 00:27:28,740
file was actually getting executed.

00:27:28,740 --> 00:27:35,650
So zooming in a little bit, that rectangle there is the main body of our JavaScript file.

00:27:35,650 --> 00:27:46,230
In other words, our performance metrics were not accounting for the time it took to actually

00:27:46,230 --> 00:27:51,940
run our JavaScript, but rather when that JavaScript was built with Builda.

00:27:51,940 --> 00:27:54,360
Code built with Webpack did not have this problem.

00:27:54,360 --> 00:27:57,880
So we no why people were still buying stuff, the same things have happened, but our measurements

00:27:57,880 --> 00:28:01,000
have moved.

00:28:01,000 --> 00:28:05,820
So let's look back at our two metrics, specifically at load, and very specifically let's look

00:28:05,820 --> 00:28:09,760
at the part that say there are no outstanding scripts waiting to be executed.

00:28:09,760 --> 00:28:15,210
What if the browser was being tricked into ready.

00:28:15,210 --> 00:28:20,270
Very quick because I know I'm way over time.

00:28:20,270 --> 00:28:22,970
As ooh reminder, requires a library that Builda was built around.

00:28:22,970 --> 00:28:29,390
We sent a copy of it to our browsers, where it's responsible for starting up our code.

00:28:29,390 --> 00:28:35,160
Here's where require.js kicks off our execution and it's wrapped in this next tick function.

00:28:35,160 --> 00:28:45,820
It looks like it's just a 4ms set time outscore.

00:28:45,820 --> 00:28:49,559
This isn't a hard and fast time and the browser is totally allowed to push things back a little

00:28:49,559 --> 00:28:51,010
bit later if it needs.

00:28:51,010 --> 00:28:56,070
In other words, require.js tells the browser that none of our code needs to run right away.

00:28:56,070 --> 00:28:59,960
Require.js may do this because it gives the browser a second to finish loading the page

00:28:59,960 --> 00:29:02,030
before starting any JavaScript.

00:29:02,030 --> 00:29:05,590
It also might do this because set timeout was a great way to make your performance numbers

00:29:05,590 --> 00:29:07,550
look good in 2010.

00:29:07,550 --> 00:29:15,260
So knowing that this was a bug, what did we do?

00:29:15,260 --> 00:29:17,470
We did not wrap all of our code in set timeout calls.

00:29:17,470 --> 00:29:20,610
That would make our numbers look better but it wouldn't tell us anything that we needed

00:29:20,610 --> 00:29:25,860
to D but we did add some new metrics.

00:29:25,860 --> 00:29:28,780
We added a timer to every one of our top five pages.

00:29:28,780 --> 00:29:31,330
Here yellow is Webpack and lower is better.

00:29:31,330 --> 00:29:34,760
Those timers were supposed to measure how long it took for all of our JavaScript to

00:29:34,760 --> 00:29:36,420
run on those pages.

00:29:36,420 --> 00:29:38,320
We were very happy with this graph.

00:29:38,320 --> 00:29:40,680
OK, I'm about done.

00:29:40,680 --> 00:29:44,000
In conclusion it took us almost a year and a half to move to Webpack.

00:29:44,000 --> 00:29:50,610
That is a very long time and it's a lot of hair-pulling.

00:29:50,610 --> 00:29:54,800
At the end of the day, we had a lot to learn about build systems, performance and our own

00:29:54,800 --> 00:29:55,800
codebase.

00:29:55,800 --> 00:30:00,760
I felt like there should be a three-point slide thing, but there were so many winnings

00:30:00,760 --> 00:30:02,720
that we had that it's kind of hard to pick 3.

00:30:02,720 --> 00:30:04,900
But I tried anyways.

00:30:04,900 --> 00:30:07,850
Number one, your codebase gets bigger, not smaller.

00:30:07,850 --> 00:30:15,160
If you're trying to find small performance win, it probably won't last very long.

00:30:15,160 --> 00:30:22,370
Number 2: Always question what other companies, websites, articles and blogs claim to be best

00:30:22,370 --> 00:30:23,370
practices.

00:30:23,370 --> 00:30:26,350
What works well for one person may not always work well everywhere.

00:30:26,350 --> 00:30:30,650
If we accepted that Webpack's internationalisation plugin was the only option we'd still be waiting

00:30:30,650 --> 00:30:32,460
for our JavaScript to build.

00:30:32,460 --> 00:30:41,070
And finally if you can take a risk on a big build project, you absolutely should.

00:30:41,070 --> 00:30:46,520
We really hated that that metrics bug cost us months of time but we ended up learning

00:30:46,520 --> 00:30:51,140
so much more about performance, the browser and our code and at the end of the day after

00:30:51,140 --> 00:30:55,170
almost a year and a half of wild problems and pulling my hair out, Webpack is pretty

00:30:55,170 --> 00:30:56,710
great software.

00:30:56,710 --> 00:30:58,120
So that is my talk.

00:30:58,120 --> 00:31:01,100
If you have any questions, please hit me up on Slack or Twitter.

00:31:01,100 --> 00:31:12,220
If you like this stuff, my team is hiring and of course, thank you all so very much.

00:31:12,220 --> 00:31:15,970

YouTube URL: https://www.youtube.com/watch?v=nDAvXOePowM


