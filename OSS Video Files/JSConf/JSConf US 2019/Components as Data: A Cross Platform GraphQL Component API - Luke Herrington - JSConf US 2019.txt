Title: Components as Data: A Cross Platform GraphQL Component API - Luke Herrington - JSConf US 2019
Publication date: 2019-09-23
Playlist: JSConf US 2019
Description: 
	Discussions about "when to use decoupled architecture are plentiful and important, but it often assumes or ignores another tricky decision: "Where" to decouple. This talk will discuss the "Decouple Line" and how moving it around provides some amazing features to your API.

When designing a content API, the assumption is often that decoupling must take the form of an API that matches your data model, where tables in your data store are mapped to resources in your API (think, /author and /posts). This is often helpful and necessary for exposing the raw data that our UIs need, however, in a cross platform scenario where teams are all building similar features, this can lead to a lot of duplicated efforts and discrepancies between the apps. All of these platforms will be writing similar queries, denormalization logic, business logic, and A/B tests, and then finally render the UI with their respective component libraries. This can lead to platform specific bugs, inefficient queries, and design inconsistency across platforms.

Components as Data moves the "decouple line" further toward the frontend to absorb queries, denormalization, business logic, and A/B testing into the backend. In practice, the API serves JSON structured in terms of the tree of UI components that will be used to render the respective data. In doing so, it becomes a quasi frontend in its own right, but it renders JSON instead of HTML or native views. This enables some amazing features:

1. Simpler, presentational frontends

2. Centralized business logic

3. Centralized A/B Testing and Feature Flagging

4. Design consistency via a "Design Schema"

5. Query optimization

Finally, this pattern opens the door for writing a cross platform UI library that implements the "design schema" and can be used as the rendering engine for each platform.
Captions: 
	00:00:00,380 --> 00:00:01,790
Well, our next talk is by Luke Herrington on components as data, so a round of applause,

00:00:01,790 --> 00:00:02,790
please.

00:00:02,790 --> 00:00:03,790
[applause]

00:00:03,790 --> 00:00:05,070
All right, let's get started.

00:00:05,070 --> 00:00:09,400
Hey, everyone, my name is Luke Herrington, I'm a senior JavaScript engineer at Four Kitchens,

00:00:09,400 --> 00:00:15,240
we're a digital agency and we make big websites.

00:00:15,240 --> 00:00:22,460
Actually my work on NBC.com and the apps that inspired this talk, the API work.

00:00:22,460 --> 00:00:25,589
And the talk is components as data.

00:00:25,589 --> 00:00:31,789
Across-platform GraphQL powered component API and if that's not a mouthful, we're going

00:00:31,789 --> 00:00:32,980
to unpack it, don't worry.

00:00:32,980 --> 00:00:39,280
I just threw a bunch of buzzwords in there to get you all to come, all right?

00:00:39,280 --> 00:00:41,370
So let's start with components.

00:00:41,370 --> 00:00:46,920
Components are these things that show up in our front ends and everyone across our industry

00:00:46,920 --> 00:00:49,030
is using them to build UIs.

00:00:49,030 --> 00:00:53,030
They're the fundamental building blocks of a UI.

00:00:53,030 --> 00:00:59,470
Doesn't matter what framework, what platform you're building on, you're using components

00:00:59,470 --> 00:01:02,310
to build it most likely.

00:01:02,310 --> 00:01:03,830
So I think components win.

00:01:03,830 --> 00:01:08,819
We found a really good abstraction for building UI.

00:01:08,819 --> 00:01:12,120
But what is a component?

00:01:12,120 --> 00:01:14,070
So I like to define components this way.

00:01:14,070 --> 00:01:17,280
This is kind of like pseudomath here.

00:01:17,280 --> 00:01:21,520
A component is a function of rendering props and state.

00:01:21,520 --> 00:01:28,409
And those words might sound familiar to you if you've built a React app.

00:01:28,409 --> 00:01:32,159
Let's dig into those words a little bit more.

00:01:32,159 --> 00:01:37,079
So props, I think of, as read-only external data.

00:01:37,079 --> 00:01:41,579
They're basically the parameters to your render function.

00:01:41,579 --> 00:01:45,310
State is going to be local data that changes over time.

00:01:45,310 --> 00:01:52,600
And your render is a declarative representation of the UI based upon the current props and

00:01:52,600 --> 00:01:56,460
state.

00:01:56,460 --> 00:02:01,759
So let's start with just this simple example of a component, and then we'll get on to the

00:02:01,759 --> 00:02:04,159
API stuff.

00:02:04,159 --> 00:02:06,079
So here we have a switch component.

00:02:06,079 --> 00:02:15,080
A switch component has a label, it has some state, whether or not it's on or off, and

00:02:15,080 --> 00:02:17,220
it has some presentation to it.

00:02:17,220 --> 00:02:22,730
You know, when it's on, it's green, when it's off it's white.

00:02:22,730 --> 00:02:29,080
So the thing about components is that they're also composable, so we could take this switch

00:02:29,080 --> 00:02:34,940
component, and we could add it to a row, for example.

00:02:34,940 --> 00:02:40,780
And say we take that row component, and we add it to our settings screen and suddenly

00:02:40,780 --> 00:02:50,150
we have basically a screen in our application.

00:02:50,150 --> 00:02:52,450
So I love components.

00:02:52,450 --> 00:02:57,870
As a '90s kid, who grew up building LEGOs, I can't help but love them, they feel like

00:02:57,870 --> 00:03:02,590
LEGOs, and they're genuinely fun to work with and we see this happening in our industry,

00:03:02,590 --> 00:03:08,590
it doesn't matter if you're building with something like SWIFT UI, or React, ReactNative,

00:03:08,590 --> 00:03:19,130
VUe, you're using this general abstraction and I think it's because it's a good one.

00:03:19,130 --> 00:03:23,320
So I'm going to stop gushing about components now because this is an API talk and you're

00:03:23,320 --> 00:03:26,390
thinking, OK, where do we get to this whole GraphQL thing?

00:03:26,390 --> 00:03:33,530
So, but I just love components so much so I'm going to leave this slide up for a second.

00:03:33,530 --> 00:03:34,530
No.

00:03:34,530 --> 00:03:35,980
Let's move on.

00:03:35,980 --> 00:03:45,350
So when you get into building an application, there's these pieces to your app, to your

00:03:45,350 --> 00:03:53,470
architecture, and I'm going to use this throughout the talk to kind of describe this API approach.

00:03:53,470 --> 00:03:57,250
So generally you're going to have some sort of database or data store.

00:03:57,250 --> 00:04:02,340
You're going to have business logic, which describes the rules that your business wants

00:04:02,340 --> 00:04:05,960
to accomplish and help the user.

00:04:05,960 --> 00:04:10,680
You're going to have some data fetching with some third-party or external APIs, and you're

00:04:10,680 --> 00:04:15,820
going to be denormallizing your data from your database with maybe some third party

00:04:15,820 --> 00:04:18,239
or other API data.

00:04:18,239 --> 00:04:24,420
And you're probably going solve some sort of feature flags, A/B testing and then of

00:04:24,420 --> 00:04:28,350
course you're going to have some sort of component library.

00:04:28,350 --> 00:04:33,690
And you're going to kind of stitch that all together in a composable way into the pieces

00:04:33,690 --> 00:04:39,900
and the pages or screens for your application.

00:04:39,900 --> 00:04:46,750
So you can combine these things in countless ways and it's basically our job to figure

00:04:46,750 --> 00:04:52,290
out how do we, you know, how do we put these together?

00:04:52,290 --> 00:04:56,270
And as you're building these things, usually there comes a point in the conversation where

00:04:56,270 --> 00:05:01,250
you're architecting an application of OK, are we going to, you know, take more of a

00:05:01,250 --> 00:05:05,880
monolithic approach or are we going to decouple and build an API?

00:05:05,880 --> 00:05:11,350
So when you're decoupling, we've had these kind of conversations before.

00:05:11,350 --> 00:05:14,780
Who should use like a decoupled architecture?

00:05:14,780 --> 00:05:15,930
What is decoupling?

00:05:15,930 --> 00:05:17,600
Let's define the terms.

00:05:17,600 --> 00:05:20,750
When should you do that in a project life cycle?

00:05:20,750 --> 00:05:21,750
Why?

00:05:21,750 --> 00:05:22,750
Why is it a good idea?

00:05:22,750 --> 00:05:25,340
Why is it a bad idea sometimes.

00:05:25,340 --> 00:05:26,460
And how?

00:05:26,460 --> 00:05:27,910
The how-to.

00:05:27,910 --> 00:05:32,120
But one thing that we generally neglect and I don't think it's on purpose but I think

00:05:32,120 --> 00:05:35,680
it's assumed is where.

00:05:35,680 --> 00:05:41,300
Where do we decouple our applications?

00:05:41,300 --> 00:05:46,760
So in this talk, we're going to use our friend, the decouple line, to kind of describe and

00:05:46,760 --> 00:05:52,580
explore this question of where do you decouple your application.

00:05:52,580 --> 00:05:58,210
So as the decouple line moves around your architecture, some really interesting features

00:05:58,210 --> 00:06:01,630
of your API are exposed.

00:06:01,630 --> 00:06:09,389
Some -- the format of your API is exposed and the content of your API is different.

00:06:09,389 --> 00:06:14,340
So let's start by describing a typical decoupled architecture.

00:06:14,340 --> 00:06:22,669
This is one that I think is basically assumed in general when we build APIs for our apps.

00:06:22,669 --> 00:06:28,610
And that is, that you basically decouple right before business logic, but right after the

00:06:28,610 --> 00:06:35,389
data store, and essentially you're building an API that exposes the raw data of your data

00:06:35,389 --> 00:06:38,280
store, your database.

00:06:38,280 --> 00:06:45,400
And this API is going to have listing functionality, it's going to have filtering functionality,

00:06:45,400 --> 00:06:50,270
sorting, including, or joining of some sort.

00:06:50,270 --> 00:06:51,770
It's pretty typical.

00:06:51,770 --> 00:07:00,050
And a good example of this approach is the JSON API spec, which is an API format specification.

00:07:00,050 --> 00:07:06,639
In this format you're going to roughly map CRUD operations to HTTP verbs and the queries

00:07:06,639 --> 00:07:14,810
are going to look pretty atomic and low-level and almost like a SQL query.

00:07:14,810 --> 00:07:20,400
Where you're basically saying, give me the authors and you better know there's an authors

00:07:20,400 --> 00:07:23,540
table somewhere in your database.

00:07:23,540 --> 00:07:27,699
And I want to get the posts for those authors and there's probably a post, too, and you

00:07:27,699 --> 00:07:34,180
can see what I mean by kind of it being pretty closely mapping to your data model.

00:07:34,180 --> 00:07:41,810
So I think this is what people usually mean when they say that their API is RESTful, and

00:07:41,810 --> 00:07:49,900
let's be real: No one really knows what that means except for our fearless leader Roy Fielding.

00:07:49,900 --> 00:07:50,900
But let's look back here.

00:07:50,900 --> 00:07:56,009
This leaves, if you look kind of on the other side of the decouple line, this leaves a lot

00:07:56,009 --> 00:07:58,419
for API consumers to implement.

00:07:58,419 --> 00:08:00,580
This leaves them with business logic.

00:08:00,580 --> 00:08:08,350
Further API fetching and denormalization, A/B testing, and the whole gamut.

00:08:08,350 --> 00:08:14,590
So let's move this line over a bit to here.

00:08:14,590 --> 00:08:22,330
So in this approach, you're exposing business logic in your API, and this is a really common

00:08:22,330 --> 00:08:25,320
approach for product companies.

00:08:25,320 --> 00:08:31,330
You're still exposing the resources of your data store, but you're also exposing operations

00:08:31,330 --> 00:08:37,490
upon that date Y This is -- it's more than just resources or

00:08:37,490 --> 00:08:40,080
entities that you're exposing.

00:08:40,080 --> 00:08:44,120
A great example of something like this is Stripe's API.

00:08:44,120 --> 00:08:50,380
Stripe is a payment as a service company and they expose a really, really powerful API

00:08:50,380 --> 00:08:58,080
for working with things like charges and customers and subscriptions, right?

00:08:58,080 --> 00:09:04,430
But you're not just simply going and getting a subscriber and then deleting a subscriber.

00:09:04,430 --> 00:09:09,580
Stripe also exposes parts of their business logic in the API.

00:09:09,580 --> 00:09:13,870
So you could dispute a charge.

00:09:13,870 --> 00:09:16,640
What HTTP verb does that map to?

00:09:16,640 --> 00:09:17,640
Not really any.

00:09:17,640 --> 00:09:23,870
Any of these kind of APIs can get really powerful.

00:09:23,870 --> 00:09:29,930
They're essentially exposing their business logic to you and most of their customers are

00:09:29,930 --> 00:09:34,880
going to be developers that need to -- need someone else to deal with the hard bits of

00:09:34,880 --> 00:09:39,390
payments, for example.

00:09:39,390 --> 00:09:47,490
So this format, and the prior, get really powerful when you introduce something like

00:09:47,490 --> 00:09:52,880
HATEOAS, stands for hypermedia as the engine of application state.

00:09:52,880 --> 00:09:57,550
So a big mouthful there.

00:09:57,550 --> 00:10:03,880
So let me give you an example of what HATEOAS looks like in action and this is a very basic

00:10:03,880 --> 00:10:06,990
example in my opinion.

00:10:06,990 --> 00:10:14,970
I think pagination of resources in your API is an example of HATEOAS.

00:10:14,970 --> 00:10:23,860
So imagine that we have this listing API where we're going to get a list of things, and below

00:10:23,860 --> 00:10:29,620
our data, we're going to return this kind of like metadata attribute in our response,

00:10:29,620 --> 00:10:31,250
called links.

00:10:31,250 --> 00:10:39,880
And the links are going to include these things like self, next, previous, last, first.

00:10:39,880 --> 00:10:46,250
So if these links exist, the UI can know that there's more to see or that there's something

00:10:46,250 --> 00:10:50,890
else before this page of the list.

00:10:50,890 --> 00:10:56,190
So what they can do is wire up their UI, to based upon the existence of one of these properties,

00:10:56,190 --> 00:11:02,140
create a next button or a previous button, and in that way the server is powering the

00:11:02,140 --> 00:11:03,330
state.

00:11:03,330 --> 00:11:11,100
We could do things like calculating the last page, by dividing the total count of the number

00:11:11,100 --> 00:11:17,330
of items in this list, by the page size.

00:11:17,330 --> 00:11:24,750
If some links don't exist, then you simply don't create the UI for that.

00:11:24,750 --> 00:11:29,290
And the other really powerful thing about HATEOAS in hypermedia is that you can swap

00:11:29,290 --> 00:11:33,440
out the implementation without friends even knowing.

00:11:33,440 --> 00:11:36,399
So in this example I've switched to an offset-based pager.

00:11:36,399 --> 00:11:39,790
You can do the same for a cursor-based pager.

00:11:39,790 --> 00:11:48,070
And because they are running a git request for it, they know no different.

00:11:48,070 --> 00:11:49,130
Super powerful.

00:11:49,130 --> 00:11:57,810
Imagine doing that for your users, if you're working on a SaaS and expose an API.

00:11:57,810 --> 00:12:07,180
You're exposing all of these actions and operations that they could basically generate and machine-read

00:12:07,180 --> 00:12:10,470
and work with.

00:12:10,470 --> 00:12:17,640
So there's kind of the explanation for this architecture.

00:12:17,640 --> 00:12:22,880
So let's move the line all the way over to this other side.

00:12:22,880 --> 00:12:26,580
And this one's a bit of a stretch, I'll admit it.

00:12:26,580 --> 00:12:28,360
It's not really an API anymore.

00:12:28,360 --> 00:12:33,019
You're basically building a monolith where you're sending HTML, CSS, JavaScript, down

00:12:33,019 --> 00:12:34,420
the wire.

00:12:34,420 --> 00:12:39,640
But it's a decision to make, nonetheless, when you're choosing your application.

00:12:39,640 --> 00:12:44,430
And I want to kind of address the element in the room here, that the room monolith has

00:12:44,430 --> 00:12:50,920
become this low-grade insult in our industry and I think that's a shame.

00:12:50,920 --> 00:12:56,580
I think it's a case of guilt by association.

00:12:56,580 --> 00:13:01,060
There's folks in our industry that have been in the industry for a long time and worked

00:13:01,060 --> 00:13:07,070
on these large codebases or joined a team as a new member and had this legacy quote-unquote

00:13:07,070 --> 00:13:11,150
application that was really difficult to work with and maybe it was poorly designed and

00:13:11,150 --> 00:13:14,990
it also happened to be a monolith, because that's how everything was built for a very

00:13:14,990 --> 00:13:18,529
long time.

00:13:18,529 --> 00:13:24,980
But just because the different pieces of the application don't communicate over the network

00:13:24,980 --> 00:13:27,040
doesn't mean that the app is poorly written.

00:13:27,040 --> 00:13:30,260
In fact, I would argue the opposite.

00:13:30,260 --> 00:13:36,399
You could take a poorly written monolith and break it up into microservices, and now you

00:13:36,399 --> 00:13:37,830
have two problems.

00:13:37,830 --> 00:13:41,360
You have a poorly designed application that communicates over the network and you have

00:13:41,360 --> 00:13:45,800
CAP theorem to deal with now and concurrency and consistency issues.

00:13:45,800 --> 00:13:50,140
So don't go so hard on the monolith.

00:13:50,140 --> 00:13:55,930
I think it's a pretty good pattern.

00:13:55,930 --> 00:13:59,210
Monolith does not mean spaghetti code.

00:13:59,210 --> 00:14:01,230
OK.

00:14:01,230 --> 00:14:11,030
So let's move on to the next ... this one's interesting.

00:14:11,030 --> 00:14:18,150
What is an application that -- whose database lives in the client?

00:14:18,150 --> 00:14:23,380
Well, it's an offline-first application or it's a local-first application.

00:14:23,380 --> 00:14:30,140
And I'm really excited about this kind of pattern right here, these days.

00:14:30,140 --> 00:14:37,350
In a world where people and their data, their private data, has become a product, this pattern,

00:14:37,350 --> 00:14:40,709
I think, could be really helpful.

00:14:40,709 --> 00:14:47,700
OK, I'll get off my soapbox.

00:14:47,700 --> 00:14:52,339
There's some really interesting research happening in distributed, local-first, offline-first

00:14:52,339 --> 00:14:53,350
applications.

00:14:53,350 --> 00:14:58,690
It's a hard problem, so you have an app that has been offline for two weeks and connects

00:14:58,690 --> 00:15:03,260
to the network and needs to sync with other nodes in the network?

00:15:03,260 --> 00:15:06,050
How do you solve that problem?

00:15:06,050 --> 00:15:08,690
It's a hard problem to solve.

00:15:08,690 --> 00:15:11,330
But it's a real problem.

00:15:11,330 --> 00:15:19,209
If you have a customer who's going to be out in the field for two weeks or in low-latency

00:15:19,209 --> 00:15:25,181
and no internet connection, this might be an API that you consider building, and it

00:15:25,181 --> 00:15:28,670
kind of takes the form of syncing.

00:15:28,670 --> 00:15:34,730
There's some really interesting research happening in this spot with CRDTs, which stand for commutative

00:15:34,730 --> 00:15:36,120
replicated data types.

00:15:36,120 --> 00:15:44,529
Wherein you seepsly model the operations on your data as commutative, so you can basically

00:15:44,529 --> 00:15:50,280
not worry about the order in which operations happen, when you reconnect to the network.

00:15:50,280 --> 00:15:52,200
* Really excited about this pattern and I think

00:15:52,200 --> 00:15:56,260
more apps should be built with data privacy in mind.

00:15:56,260 --> 00:15:59,079
Data ownership.

00:15:59,079 --> 00:16:01,829
OK.

00:16:01,829 --> 00:16:07,870
So finally, let's move to components as data.

00:16:07,870 --> 00:16:15,320
In components as data, the back end has essentially absorbed a lot more work, but leaves something

00:16:15,320 --> 00:16:16,860
for the frontends to do.

00:16:16,860 --> 00:16:26,829
And at this point, the backend kind of becomes a frontend in its own right so what this looks

00:16:26,829 --> 00:16:33,769
like is an API that serves JSON, structured in terms of a UI tree.

00:16:33,769 --> 00:16:39,880
And if that sounds confusing, we're going to unpack it and get some examples here.

00:16:39,880 --> 00:16:47,690
So your components can be described as data.

00:16:47,690 --> 00:16:49,600
Hence the name components as data.

00:16:49,600 --> 00:16:51,730
So let's get to an example.

00:16:51,730 --> 00:16:53,670
Here's the most basic example I could think of.

00:16:53,670 --> 00:16:55,450
A hero component.

00:16:55,450 --> 00:17:03,040
So here we have a JSON blob with a field called component.

00:17:03,040 --> 00:17:12,040
That component field is going to map directly to a component in your component library.

00:17:12,040 --> 00:17:13,900
And then you have the data.

00:17:13,900 --> 00:17:20,919
And the data is essentially going to represent the props that are needed to render that component.

00:17:20,919 --> 00:17:28,950
Any state that the component might have is going to be locally handled.

00:17:28,950 --> 00:17:30,850
So I wanted to address another thing.

00:17:30,850 --> 00:17:37,250
When React was first released, there was this big conversation that happened about separation

00:17:37,250 --> 00:17:39,010
of concerns.

00:17:39,010 --> 00:17:46,040
In the creators of React's mind, I think there was this ability to question best practices

00:17:46,040 --> 00:17:49,610
and I'm glad they did it.

00:17:49,610 --> 00:17:57,590
But then also, with the introduction of hooks, which is a way of abstracting logic out of

00:17:57,590 --> 00:18:03,790
components, and suspense, which is going to solve for data fetching and a couple other

00:18:03,790 --> 00:18:12,720
problems, I think we've seen that the component as an abstraction isn't necessarily the best

00:18:12,720 --> 00:18:19,230
abstraction for expressing business logic, or data fetching.

00:18:19,230 --> 00:18:26,049
So I think that this pattern kind of works with that a little bit.

00:18:26,049 --> 00:18:29,840
So this is a scary part in the talk where I need to load an iFrame.

00:18:29,840 --> 00:18:31,679
Oh, my gosh!

00:18:31,679 --> 00:18:32,900
It worked!

00:18:32,900 --> 00:18:33,900
OK.

00:18:33,900 --> 00:18:34,900
Whew!

00:18:34,900 --> 00:18:43,910
So we used this pattern to build out NBC.com and all of its apps, Android, iOS, Roku, and

00:18:43,910 --> 00:18:47,290
the TV app Samsung video.

00:18:47,290 --> 00:18:57,580
So we used this component data to basically render the slideshow here, some shelves, with

00:18:57,580 --> 00:19:02,670
your favorite shows, this is us, any it this is Us fans out there?

00:19:02,670 --> 00:19:04,070
OK.

00:19:04,070 --> 00:19:07,130
How about Will and Grace?

00:19:07,130 --> 00:19:16,820
It's the '90s, OK!

00:19:16,820 --> 00:19:20,950
So we used this pattern at NBC.

00:19:20,950 --> 00:19:32,530
We started out kind of around here with a very data-centric metric API.

00:19:32,530 --> 00:19:36,540
Including and joining kinds of logic.

00:19:36,540 --> 00:19:40,669
This left a lot fort frontends to do and they were all reimplementing basically the same

00:19:40,669 --> 00:19:47,260
queries with basically the same business logic and having to deal with all sorts of denormalization

00:19:47,260 --> 00:19:48,330
on sides.

00:19:48,330 --> 00:19:56,040
They were all doing similar AB tests, and it didn't seem dry when ultimately we wanted

00:19:56,040 --> 00:19:58,880
a consistent experience across platforms.

00:19:58,880 --> 00:20:06,169
So we built this proxy of sorts where we're including and denormallizing data from multiple

00:20:06,169 --> 00:20:14,910
sources, multiple APIs and giving the clients much more to work with and much less responsibility.

00:20:14,910 --> 00:20:21,620
But then has we built this out, we found that what the business wanted was a very powerful

00:20:21,620 --> 00:20:29,760
suite of A/B testing and very quick process-platform A/B testing and feature flagging and reimplementing

00:20:29,760 --> 00:20:35,500
that across platforms was more work than it needed to be.

00:20:35,500 --> 00:20:39,160
So what we did was moved toward components as data where we absorbed that work and we

00:20:39,160 --> 00:20:45,360
absorbed the component library into the back end.

00:20:45,360 --> 00:20:50,830
So some basic components that live in the NBC data model would be, you know, a slideshow

00:20:50,830 --> 00:20:52,490
that contains slides.

00:20:52,490 --> 00:20:56,480
A shelf that might contain a series tile, or a video tile.

00:20:56,480 --> 00:20:59,840
So those are what we're going to be working with our examples here.

00:20:59,840 --> 00:21:05,270
It's a very basic example.

00:21:05,270 --> 00:21:09,630
So we chose GraphQL to implement this pattern, and I think the reason we ultimately did it

00:21:09,630 --> 00:21:13,590
was because of the types and the queries.

00:21:13,590 --> 00:21:21,559
The coupling you of the queries and the types in GraphQL is a perfect match, in my opinion.

00:21:21,559 --> 00:21:29,669
The way that these types need to be shared, especially in the component library as data,

00:21:29,669 --> 00:21:34,420
it was just really powerful to be able to describe those with GraphQL schema.

00:21:34,420 --> 00:21:38,350
And we'll show some benefits of doing that.

00:21:38,350 --> 00:21:43,530
So let's just do a quick overview of what the GraphQL schema looks like for an application

00:21:43,530 --> 00:21:47,049
like this, and this is again a simplified example.

00:21:47,049 --> 00:21:51,330
So we're going to have an interface called component with a component field like we talked

00:21:51,330 --> 00:21:57,330
about earlier, and a treatment field and this treatment field was essentially our quasi--like

00:21:57,330 --> 00:22:04,360
class name field, that works cross-platform, so if we wanted a component to be, you know,

00:22:04,360 --> 00:22:10,500
the primary or the featured type of component, we didn't have to create a whole new component

00:22:10,500 --> 00:22:11,500
for that.

00:22:11,500 --> 00:22:14,970
We could just augment it with this treatment field, like a class.

00:22:14,970 --> 00:22:21,280
Then we have our video tile and the video tile also has a component and treatment field

00:22:21,280 --> 00:22:25,130
and it's going to have a data field like we talked about, and that data field will contain

00:22:25,130 --> 00:22:29,650
like an image, title, secondary title, and percent viewed.

00:22:29,650 --> 00:22:35,580
We decoupled the data from the component for use if another data type might need video

00:22:35,580 --> 00:22:39,200
data.

00:22:39,200 --> 00:22:43,010
So then we have our shelf and a shelf is going to contain tiles.

00:22:43,010 --> 00:22:50,090
So we define a series tile in a similar manner and we union the video and series tile together

00:22:50,090 --> 00:22:56,350
into this tile union and the shelf data, the data for the shelf is going to contain this

00:22:56,350 --> 00:23:02,440
items field, which is basically a slot for tiles to live.

00:23:02,440 --> 00:23:09,040
It's kind of like children, but it's more specifically kind of tied to like a slot of

00:23:09,040 --> 00:23:13,830
components.

00:23:13,830 --> 00:23:18,100
So we're going to introduce this new interface called section, right?

00:23:18,100 --> 00:23:26,380
And you'll see why in a bit, but this section interface is going to kind of delineate a

00:23:26,380 --> 00:23:30,410
shelf component from other types of components.

00:23:30,410 --> 00:23:34,799
It's a component, but it's also a section.

00:23:34,799 --> 00:23:38,690
Same goes for featured: Slideshow is a different type of component.

00:23:38,690 --> 00:23:40,620
It's like a featured component, right?

00:23:40,620 --> 00:23:44,360
And these things might have different properties, different analytics, information, and metadata

00:23:44,360 --> 00:23:50,830
information, and so introducing a new interface makes sense.

00:23:50,830 --> 00:23:52,559
So a slideshow contains slides.

00:23:52,559 --> 00:23:56,180
I think we get the picture there.

00:23:56,180 --> 00:23:59,480
And then finally we're going to have our page type.

00:23:59,480 --> 00:24:03,380
The page type stitches this all together, it takes a featured field, which is going

00:24:03,380 --> 00:24:08,230
to be, you know, like that slideshow up on the top at the home page, for example and

00:24:08,230 --> 00:24:12,900
then the sections field which is essentially going to represent all of the shelves in the

00:24:12,900 --> 00:24:21,340
UI and the query will obviously take the name, user ID for personalization, and a platform.

00:24:21,340 --> 00:24:25,840
So that we can vary the same platform.

00:24:25,840 --> 00:24:27,900
So let's give another example.

00:24:27,900 --> 00:24:32,799
This is what it's going to look like in Apollo Playground.

00:24:32,799 --> 00:24:35,059
So here we have our home page.

00:24:35,059 --> 00:24:38,230
We're using our page field.

00:24:38,230 --> 00:24:44,150
We're querying the home page for user ID loop on platform web and you can see here that

00:24:44,150 --> 00:24:50,159
we're spreading our slideshow fragment into featured, shelf into sections, and as we build

00:24:50,159 --> 00:24:55,289
out more and more components that are of the section's interface, we would add more like

00:24:55,289 --> 00:25:00,039
a group or other types.

00:25:00,039 --> 00:25:06,900
So here we have our fragments that are going to look as you would expect.

00:25:06,900 --> 00:25:11,980
And this is what it looks like to send back a UI tree as JSON.

00:25:11,980 --> 00:25:17,580
We have our page, with our featured section and our sections array.

00:25:17,580 --> 00:25:23,200
And we have our component, called slideshow with items of slides.

00:25:23,200 --> 00:25:28,820
And sections are going to contain our shelf and in this case we have a top picks for you

00:25:28,820 --> 00:25:36,360
shelf, personalized just for you.

00:25:36,360 --> 00:25:39,460
Let's show another example: You don't have to just build out pages this way.

00:25:39,460 --> 00:25:44,860
There's nothing that is forcing you to build out an entire page response.

00:25:44,860 --> 00:25:46,610
You can build out certain features.

00:25:46,610 --> 00:25:49,900
So when I talked about absorbing the business logic, this is kind of what I meant.

00:25:49,900 --> 00:25:55,240
One of the features of NBC.com or really any media-streaming kind of platform is some kind

00:25:55,240 --> 00:25:59,840
of continue watching feature where you can pick up where you've left off the videos you've

00:25:59,840 --> 00:26:01,980
been watching.

00:26:01,980 --> 00:26:07,760
So here we've exposed a continue watching field that just returns the continue watching

00:26:07,760 --> 00:26:14,570
shelf, a bunch of video tiles with some percent viewed, some images, and the UI is going to

00:26:14,570 --> 00:26:28,220
map over this field and generically render its contents.

00:26:28,220 --> 00:26:32,230
So let's talk about this -- I think that what we're describing here is some sort of design

00:26:32,230 --> 00:26:38,970
schema, where your component libraries is described in terms of GraphQL, in terms of

00:26:38,970 --> 00:26:40,100
a schema.

00:26:40,100 --> 00:26:46,780
And this is, I think, what we are trying to accomplish often when we build a design system,

00:26:46,780 --> 00:26:53,300
is we want rules, we want structure, and this type system ensures that.

00:26:53,300 --> 00:26:58,799
A great example of this is when you throw in the schema and do an open source tool like

00:26:58,799 --> 00:27:06,210
GraphQL Voyager, and you can see kind of this component library described as a graph.

00:27:06,210 --> 00:27:12,010
So let's look at page, which is going to contain featured, and sections.

00:27:12,010 --> 00:27:23,840
So go to sections, where there's a shelf, data, there's our tile union, and then a tile

00:27:23,840 --> 00:27:28,080
could be a video tile or a series tile.

00:27:28,080 --> 00:27:37,230
With their respective data.

00:27:37,230 --> 00:27:41,380
So what does it look like to actually implement this on the front end?

00:27:41,380 --> 00:27:46,240
We showed kind of the back-end implementation and we're going to use React to implement

00:27:46,240 --> 00:27:47,840
this.

00:27:47,840 --> 00:27:49,429
So we'll start with our component library.

00:27:49,429 --> 00:27:53,460
That's how most front-end projects begin and we'll build out a slideshow.

00:27:53,460 --> 00:27:58,340
A slideshow is going to have some state, as to which slide it's currently on.

00:27:58,340 --> 00:27:59,679
A slide number.

00:27:59,679 --> 00:28:05,150
And it's going to receive props and remember that the props here is the data that comes

00:28:05,150 --> 00:28:06,919
from the API.

00:28:06,919 --> 00:28:11,320
So it's going to include this items field.

00:28:11,320 --> 00:28:16,970
So we could map over the items field, and get slides.

00:28:16,970 --> 00:28:23,309
And we're going to generically render the children using this dictionary.

00:28:23,309 --> 00:28:26,750
Passing the data through and the current state of the slide member.

00:28:26,750 --> 00:28:31,240
Here is a boring slide component.

00:28:31,240 --> 00:28:37,430
These are just example snippets here.

00:28:37,430 --> 00:28:42,120
So these dictionaries are where kind of the magic happens here.

00:28:42,120 --> 00:28:46,340
These dictionaries map to the interfaces ins in our schema.

00:28:46,340 --> 00:28:51,970
So you remember our features interface and our sections interface, so we add the respective

00:28:51,970 --> 00:28:58,600
components from the components library into these dictionaries.

00:28:58,600 --> 00:29:05,029
Then when we want to go render a component, we use the respective dictionary, we grab

00:29:05,029 --> 00:29:11,070
the component field, look up the component in the dictionary, and generically render

00:29:11,070 --> 00:29:14,080
it with its data.

00:29:14,080 --> 00:29:19,970
Finally, here's an example of how we could stitch together that full-page query that

00:29:19,970 --> 00:29:26,570
I showed you, where we're using the featured section with the featured dictionary.

00:29:26,570 --> 00:29:33,470
Grabbing out the featured property, and then rendering our sections array, and mapping

00:29:33,470 --> 00:29:39,150
over the sections and rendering whatever component we have.

00:29:39,150 --> 00:29:48,110
So this is, I think, a pretty interesting solution to a hard problem that NBC had.

00:29:48,110 --> 00:29:49,820
And maybe you have it too.

00:29:49,820 --> 00:29:57,220
Here are some of the hard parts: When business logic gets fragmented and you're centralizing

00:29:57,220 --> 00:30:02,700
the business logic, you have to deal with it in a centralized way, and that it can mean

00:30:02,700 --> 00:30:03,929
bloat.

00:30:03,929 --> 00:30:05,510
And something you tried to dry out.

00:30:05,510 --> 00:30:11,919
If you've ever tried to dry code with don't repeat yourself and then it turned out that

00:30:11,919 --> 00:30:16,700
oh, actually, I kind of wanted to repeat myself.

00:30:16,700 --> 00:30:19,520
The same goes with variance across platforms.

00:30:19,520 --> 00:30:32,030
If Android wants that slight tweak or another platform wants another tweak.

00:30:32,030 --> 00:30:39,539
So we solved those by creating this abstraction

00:30:39,539 --> 00:30:44,100
that we called the conditional resolver and you saw maybe if you're here in the last talk

00:30:44,100 --> 00:30:49,230
what a resolver looks like and a conditional resolver allows you to essentially compose

00:30:49,230 --> 00:30:54,730
an array of resolvers together with some basic conditions that are going to be looking at

00:30:54,730 --> 00:31:02,299
the args off your query, a the variables off your query and the context, as well, and choosing

00:31:02,299 --> 00:31:06,330
the time to run.

00:31:06,330 --> 00:31:08,250
Another thing was pagination.

00:31:08,250 --> 00:31:17,750
So we solved this by creating a lazy shelf that tells the front end, hey, when you render

00:31:17,750 --> 00:31:23,520
this thing, there's not very much to do, but we were able to tell them, hey, implement

00:31:23,520 --> 00:31:28,450
it like this, when you get a lazy shelf, use this query that we're going to give you the

00:31:28,450 --> 00:31:34,059
query name in the lazy shelf data and then use these variables that we're passing to

00:31:34,059 --> 00:31:39,100
you, and when you render, make this call and when you get the callback and the response,

00:31:39,100 --> 00:31:41,760
you'll get a component and you'll swap it out.

00:31:41,760 --> 00:31:47,480
So if you get a lazy shelf, you render it, it fires off a request and returns a shelf

00:31:47,480 --> 00:31:49,690
and then you just swap in the shelf.

00:31:49,690 --> 00:31:55,029
There are some good parts, too.

00:31:55,029 --> 00:31:58,030
This led to vastly simpler front ends.

00:31:58,030 --> 00:32:00,960
it's a different problem set for them to solve.

00:32:00,960 --> 00:32:02,770
It's not easy, don't get me wrong.

00:32:02,770 --> 00:32:04,490
But it's simpler.

00:32:04,490 --> 00:32:11,720
We're also able to centralize business logic which has a lot of pros, lets fragmentation

00:32:11,720 --> 00:32:14,280
and differences across platforms.

00:32:14,280 --> 00:32:28,250
Also, centralizing A/B testing and feature flagging has been a huge boon. same goes for

00:32:28,250 --> 00:32:34,880
feature flagging and releases, we also get this design consistency with a design schema.

00:32:34,880 --> 00:32:39,890
The documentation for a component library for a front end is described in schema, and

00:32:39,890 --> 00:32:46,070
you can use all of these really interesting GraphQL tools out there to document it and

00:32:46,070 --> 00:32:50,250
finally on the server side we're able to do some query optimization and caching that you

00:32:50,250 --> 00:32:55,630
simply wouldn't have been able to do on the front end.

00:32:55,630 --> 00:33:00,669
So here's what I'll leave you with: I'm not saying that everyone should use this pattern.

00:33:00,669 --> 00:33:09,809
In fact, I would caution you against it if you have a very transactional-heavy app or

00:33:09,809 --> 00:33:17,760
if you have a UI that is very form-based, or I think you get what I'm saying.

00:33:17,760 --> 00:33:25,039
If you're serving content or media, and you need to be very swift in *AB tests and you're

00:33:25,039 --> 00:33:28,309
doing that across platforms, this might be a good fit for you.

00:33:28,309 --> 00:33:31,230
It's not for everyone, though.

00:33:31,230 --> 00:33:35,360
And I guess what I'm leaving you with, if you're going to design an API, think outside

00:33:35,360 --> 00:33:36,360
the box.

00:33:36,360 --> 00:33:42,779
You never know what you might come up with and you can have some fun doing it, as well.

00:33:42,779 --> 00:33:43,899
Thanks everyone for having me.

00:33:43,899 --> 00:33:45,110
It's been an honor speaking here.

00:33:45,110 --> 00:33:48,750
Thank you to the conference organizers and come talk to me afterwards.

00:33:48,750 --> 00:33:48,920

YouTube URL: https://www.youtube.com/watch?v=4cEJ-1rXqMg


