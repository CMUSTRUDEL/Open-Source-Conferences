Title: Vienna.js, Writing better test assertions, April 2019
Publication date: 2019-04-30
Playlist: viennaJS
Description: 
	Talk by Thomas Mayrhofer:

TDD is part of my day to day workflow. Quite often my tests cause some maintenance overhead as additional requirements make previous tests break, even though functionality was only added and existing behaviour didn't change. Doing some research made me realise that the way the test assertions were written caused this overhead. In this talk I'll present a way test assertions can be written without the need to fix them on requirement changes.
Captions: 
	00:00:00,539 --> 00:00:09,330
who of you is actually writing tests on

00:00:03,300 --> 00:00:11,730
a day-to-day basis a couple of hands who

00:00:09,330 --> 00:00:16,619
a few is actually pushing it hard and

00:00:11,730 --> 00:00:20,630
doing test-driven development okay and

00:00:16,619 --> 00:00:20,630
who of you knows a test you'd like that

00:00:21,170 --> 00:00:25,890
so basically we have quite a lot of

00:00:23,369 --> 00:00:30,689
failing tests just because we changed

00:00:25,890 --> 00:00:33,090
something in somewhere and I basically

00:00:30,689 --> 00:00:35,880
got a little bit upset with the fact

00:00:33,090 --> 00:00:39,540
that sometimes I have tests which failed

00:00:35,880 --> 00:00:41,579
because of changing requirements and I

00:00:39,540 --> 00:00:45,899
basically thought to myself what the

00:00:41,579 --> 00:00:48,390
 am I doing wrong and then I started

00:00:45,899 --> 00:00:50,789
questioning test-driven development and

00:00:48,390 --> 00:00:53,820
then I took a little bit deeper and

00:00:50,789 --> 00:00:55,350
thought about hey how are other people

00:00:53,820 --> 00:00:57,480
doing it or how are other people really

00:00:55,350 --> 00:00:59,370
writing their tests or the way how to

00:00:57,480 --> 00:01:02,489
write the tests that not on every

00:00:59,370 --> 00:01:08,369
requirement change the previous tests

00:01:02,489 --> 00:01:11,070
are breaking and basically I came up

00:01:08,369 --> 00:01:13,470
with the thing that the way how I wrote

00:01:11,070 --> 00:01:16,670
the test assertions had been problematic

00:01:13,470 --> 00:01:20,070
and then I look a little bit deeper and

00:01:16,670 --> 00:01:22,650
saw what is a test assertion at its core

00:01:20,070 --> 00:01:27,110
and the test assertion is nothing more

00:01:22,650 --> 00:01:29,850
than a function which takes a value and

00:01:27,110 --> 00:01:32,520
tests if this value is true fee or not

00:01:29,850 --> 00:01:36,750
and if it's faulty then it throws an

00:01:32,520 --> 00:01:39,270
error with a message and that's

00:01:36,750 --> 00:01:41,430
basically almost everything from the

00:01:39,270 --> 00:01:43,439
slides itself because I'm going to do a

00:01:41,430 --> 00:01:45,750
live coding session then to show you

00:01:43,439 --> 00:01:49,409
what I mean with writing other or better

00:01:45,750 --> 00:01:52,560
test assertions and I basically came up

00:01:49,409 --> 00:01:54,240
with a scenario where I'm writing an

00:01:52,560 --> 00:01:57,540
employee management system for local

00:01:54,240 --> 00:01:59,280
grocery store and the owner decided he

00:01:57,540 --> 00:02:01,799
wants to open up the store on Sunday and

00:01:59,280 --> 00:02:04,290
for this he wants to have a report of

00:02:01,799 --> 00:02:09,330
the employees because not all employees

00:02:04,290 --> 00:02:12,740
are allowed to work on Sundays and so

00:02:09,330 --> 00:02:15,650
this this shop owner calls me

00:02:12,740 --> 00:02:17,480
says hey I want to have an application I

00:02:15,650 --> 00:02:21,470
want to have a report of my employees

00:02:17,480 --> 00:02:24,140
and recompile this user story out of it

00:02:21,470 --> 00:02:25,700
so a shop owner I want to view a list of

00:02:24,140 --> 00:02:27,890
all employees which are all that I'm 18

00:02:25,700 --> 00:02:31,670
years old so that I know who is allowed

00:02:27,890 --> 00:02:33,760
to work on Sundays and that's basically

00:02:31,670 --> 00:02:38,050
the kickoff for this live coding session

00:02:33,760 --> 00:02:41,750
I have here

00:02:38,050 --> 00:02:44,750
testitude which is green right now and I

00:02:41,750 --> 00:02:47,480
want to and I already have the employees

00:02:44,750 --> 00:02:52,220
marked here and I'm going to write an

00:02:47,480 --> 00:02:53,720
employee report function which is then

00:02:52,220 --> 00:02:56,360
returning me all employees which are

00:02:53,720 --> 00:03:00,500
older than 18 years old and looking at

00:02:56,360 --> 00:03:03,980
the first requirement a shop owner just

00:03:00,500 --> 00:03:05,210
copy that one here a shop one I want a

00:03:03,980 --> 00:03:07,670
few lists of all employers which already

00:03:05,210 --> 00:03:10,640
eight years old so would write a test

00:03:07,670 --> 00:03:16,910
assertion a test description employee

00:03:10,640 --> 00:03:25,970
report returns employees which are older

00:03:16,910 --> 00:03:28,340
than 18 years so here we go okay first

00:03:25,970 --> 00:03:30,320
I'm using a assertion library called ham

00:03:28,340 --> 00:03:37,000
chest while I'm using it I come to that

00:03:30,320 --> 00:03:42,710
later I would write assert that employee

00:03:37,000 --> 00:03:46,850
employee report from the employees equal

00:03:42,710 --> 00:03:50,240
to and then I'm having a look the first

00:03:46,850 --> 00:03:54,670
employee is which is over 18 is SEP so

00:03:50,240 --> 00:03:58,040
I'm saying employees number one and

00:03:54,670 --> 00:04:00,140
employees number three because Mike is

00:03:58,040 --> 00:04:01,910
also older than that so the first thing

00:04:00,140 --> 00:04:04,430
is employee report is obviously not

00:04:01,910 --> 00:04:12,890
defined so I'm starting here constant

00:04:04,430 --> 00:04:15,560
Chloe report gets employees Louise and I

00:04:12,890 --> 00:04:22,630
would start with a simple filter so

00:04:15,560 --> 00:04:22,630
returned employees filter Chloe

00:04:22,650 --> 00:04:31,750
and that employee got H greater than or

00:04:28,090 --> 00:04:33,960
equal to 18 so let's look at our test

00:04:31,750 --> 00:04:37,750
test the screen everything works well so

00:04:33,960 --> 00:04:42,100
we call it a day and the next morning

00:04:37,750 --> 00:04:44,199
the customer calls again and asks me hey

00:04:42,100 --> 00:04:47,440
it would be so nice if this newly

00:04:44,199 --> 00:04:49,990
created employee function would swatch

00:04:47,440 --> 00:04:52,120
them or would be sorted so we compile

00:04:49,990 --> 00:04:53,740
the next user story and say a shop owner

00:04:52,120 --> 00:04:55,599
I want the list of employees to be

00:04:53,740 --> 00:04:59,560
sorted by the names so I can find

00:04:55,599 --> 00:05:01,960
employees more easily so forgetting

00:04:59,560 --> 00:05:07,090
about what I did yesterday I start off

00:05:01,960 --> 00:05:11,910
with a new with a new test so just put

00:05:07,090 --> 00:05:20,830
the test use a story upfront here and

00:05:11,910 --> 00:05:25,389
say returns employees which are sort by

00:05:20,830 --> 00:05:29,550
their name okay start off with the next

00:05:25,389 --> 00:05:37,510
test assertion that's not that generate

00:05:29,550 --> 00:05:41,620
employee report from the employees until

00:05:37,510 --> 00:05:45,580
should equal 2 we look at the employees

00:05:41,620 --> 00:05:50,349
so Mike is obviously before cept so we

00:05:45,580 --> 00:05:52,840
return employees number 3 and employees

00:05:50,349 --> 00:05:57,130
number two number one or three

00:05:52,840 --> 00:05:58,780
so obviously this one test is now

00:05:57,130 --> 00:06:03,340
failing returns employees which is

00:05:58,780 --> 00:06:07,990
sorted by the name so we go to our

00:06:03,340 --> 00:06:10,470
implementation again and sort our

00:06:07,990 --> 00:06:10,470
employees

00:06:10,800 --> 00:06:20,849
they make it a be a dot named Dutch

00:06:14,699 --> 00:06:25,310
local compare B dot name so we run the

00:06:20,849 --> 00:06:29,520
tests and our tests are failing but now

00:06:25,310 --> 00:06:32,460
funny sorry the real thing is that our

00:06:29,520 --> 00:06:34,680
newly create the test is obviously green

00:06:32,460 --> 00:06:37,830
but the previous test is failing for

00:06:34,680 --> 00:06:40,319
whatever reason so let's have a look on

00:06:37,830 --> 00:06:43,080
what the previous test is saying to us

00:06:40,319 --> 00:06:45,720
and looking at those things it's pretty

00:06:43,080 --> 00:06:48,389
obvious that this can't work because

00:06:45,720 --> 00:06:51,300
here we're depending on the order of the

00:06:48,389 --> 00:06:54,930
employees which are returned and here we

00:06:51,300 --> 00:06:56,940
are explicitly sorting them and so what

00:06:54,930 --> 00:06:59,220
we can do with ham chest is that we can

00:06:56,940 --> 00:07:02,849
use a different metric they are called

00:06:59,220 --> 00:07:07,400
to write our assertions so I can now

00:07:02,849 --> 00:07:07,400
write here contains in any order and

00:07:09,889 --> 00:07:16,440
let's look at the tests and both of them

00:07:13,919 --> 00:07:19,770
are green again so the only thing what

00:07:16,440 --> 00:07:22,979
we did now is that this test is checking

00:07:19,770 --> 00:07:24,360
for everybody who is above 18 years old

00:07:22,979 --> 00:07:27,319
and we don't care about the order and

00:07:24,360 --> 00:07:30,090
below there we care about the order

00:07:27,319 --> 00:07:32,550
we're going to see that this is also not

00:07:30,090 --> 00:07:37,020
the perfect way to do it but that's in

00:07:32,550 --> 00:07:39,750
the next requirement most probably so we

00:07:37,020 --> 00:07:41,759
deployed this to production customers

00:07:39,750 --> 00:07:42,210
happy a couple of weeks later he calls

00:07:41,759 --> 00:07:46,919
me again

00:07:42,210 --> 00:07:49,199
and asks hey I print this out and

00:07:46,919 --> 00:07:51,509
because I have such a bad sight I want

00:07:49,199 --> 00:07:54,060
the names to be capitalized so I can

00:07:51,509 --> 00:07:59,310
read it better so we say hey absolutely

00:07:54,060 --> 00:08:03,639
no problem we call we write another test

00:07:59,310 --> 00:08:06,930
for that so we see it

00:08:03,639 --> 00:08:08,470
just put a user story up front here

00:08:06,930 --> 00:08:13,620
sorry right

00:08:08,470 --> 00:08:20,039
returns employees which names are

00:08:13,620 --> 00:08:25,840
capitalized capitalized like that okay

00:08:20,039 --> 00:08:30,009
issue and we write another assertion

00:08:25,840 --> 00:08:38,019
like assert that employee report from

00:08:30,009 --> 00:08:40,419
our employees equal to and then we're

00:08:38,019 --> 00:08:44,610
writing the first employee we want to

00:08:40,419 --> 00:08:44,610
get back is obviously Mike so we say

00:08:45,300 --> 00:08:55,839
employees free name is Mike then

00:08:52,350 --> 00:08:59,320
capitalized and we also have the same

00:08:55,839 --> 00:09:02,740
thing for the one which is zip in our

00:08:59,320 --> 00:09:04,120
case so we run our tests test is

00:09:02,740 --> 00:09:08,050
obviously broken because we didn't

00:09:04,120 --> 00:09:13,829
implement something and we go back up

00:09:08,050 --> 00:09:13,829
here and say employees dot map employee

00:09:15,510 --> 00:09:22,800
then we do something like that Chloe and

00:09:18,910 --> 00:09:31,990
then the name we just say employee name

00:09:22,800 --> 00:09:33,339
to uppercase so let's have a look so two

00:09:31,990 --> 00:09:36,490
tests are failing out so we basically

00:09:33,339 --> 00:09:39,370
implemented the solution for our test we

00:09:36,490 --> 00:09:43,750
wanted to do but the other two are now

00:09:39,370 --> 00:09:48,220
failing and looking at the first test

00:09:43,750 --> 00:09:50,680
also quite obvious why this is failing

00:09:48,220 --> 00:09:53,620
because we are matching for the age and

00:09:50,680 --> 00:09:58,269
the name and not only taking care about

00:09:53,620 --> 00:09:59,980
the age so what can we do about that in

00:09:58,269 --> 00:10:03,579
ham chest there is this one measure

00:09:59,980 --> 00:10:06,910
which is called every item so we can do

00:10:03,579 --> 00:10:09,610
something like that every item then we

00:10:06,910 --> 00:10:14,190
can compose another match out of it with

00:10:09,610 --> 00:10:14,190
the name has property age

00:10:14,380 --> 00:10:22,980
greater than but equal to 18 so move

00:10:20,950 --> 00:10:22,980
that

00:10:25,170 --> 00:10:37,620
so one parenthesizes here we go

00:10:30,610 --> 00:10:42,520
so look what Thanks

00:10:37,620 --> 00:10:44,980
three item so here we go okay looking at

00:10:42,520 --> 00:10:47,589
this one test this is now green again

00:10:44,980 --> 00:10:51,339
and what I really like about this way to

00:10:47,589 --> 00:10:54,640
compose the test assertions is that this

00:10:51,339 --> 00:10:56,890
now reads almost exactly like the thing

00:10:54,640 --> 00:11:00,460
I have here so I say assert that

00:10:56,890 --> 00:11:02,650
employee employee report every item has

00:11:00,460 --> 00:11:04,990
property age greater than or equal to 18

00:11:02,650 --> 00:11:06,460
and looking at the test description

00:11:04,990 --> 00:11:09,550
that's basically what the test

00:11:06,460 --> 00:11:12,880
description is telling us so we have an

00:11:09,550 --> 00:11:16,300
exact match of our assertion with the

00:11:12,880 --> 00:11:20,170
way how we write how the test

00:11:16,300 --> 00:11:23,440
description is called having a look on

00:11:20,170 --> 00:11:27,130
the the other test there is obviously

00:11:23,440 --> 00:11:33,250
another match for it so we can say the

00:11:27,130 --> 00:11:35,950
employee report is sorted by ordered by

00:11:33,250 --> 00:11:44,200
I always get confused by that nature and

00:11:35,950 --> 00:11:53,790
then I can say a B and a dot name must

00:11:44,200 --> 00:11:53,790
be smaller than B top name so let's see

00:11:54,050 --> 00:11:59,420
and I'll test the Queen again so we're

00:11:58,939 --> 00:12:15,069
good to go

00:11:59,420 --> 00:12:15,069
yeah not at all

00:12:20,170 --> 00:12:25,549
that's one of the things I'm going to

00:12:22,879 --> 00:12:29,949
discuss afterwards because in that

00:12:25,549 --> 00:12:34,970
particular case one test is missing but

00:12:29,949 --> 00:12:40,189
yeah so the next thing is this

00:12:34,970 --> 00:12:42,529
capitalized thing oh now all our tests

00:12:40,189 --> 00:12:46,910
are green so we are basically kind of

00:12:42,529 --> 00:12:50,239
good to go and then basically the last

00:12:46,910 --> 00:12:51,019
requirement comes in and that says a

00:12:50,239 --> 00:12:52,759
shop owner

00:12:51,019 --> 00:12:54,259
I want the employees to be sorted by the

00:12:52,759 --> 00:12:59,480
name descending instead of ascending

00:12:54,259 --> 00:13:03,699
because for whatever reason and that's

00:12:59,480 --> 00:13:07,519
basically for us now a pretty simple fix

00:13:03,699 --> 00:13:12,319
that we say hey we just turned around

00:13:07,519 --> 00:13:18,649
and here in our implementation we can do

00:13:12,319 --> 00:13:22,189
beat up name a dog name and here

00:13:18,649 --> 00:13:25,399
basically our last test kind of fails

00:13:22,189 --> 00:13:30,230
again and there is also one thing where

00:13:25,399 --> 00:13:36,290
we can't do every item and we can say

00:13:30,230 --> 00:13:38,600
has property name and this is one thing

00:13:36,290 --> 00:13:40,669
which is not the most pretty one but I

00:13:38,600 --> 00:13:44,629
can show you how we can do that a little

00:13:40,669 --> 00:13:47,600
bit prettier afterwards so and here we

00:13:44,629 --> 00:13:49,939
can say matches pattern and we're going

00:13:47,600 --> 00:13:54,709
to use some kind of records which I

00:13:49,939 --> 00:14:00,570
never learned by heart before so it's I

00:13:54,709 --> 00:14:02,580
think like that a to set and like that

00:14:00,570 --> 00:14:15,390
and we will see how we can make it a

00:14:02,580 --> 00:14:16,650
little bit prettier afterwards yeah but

00:14:15,390 --> 00:14:19,230
it's for the test right now

00:14:16,650 --> 00:14:24,210
yeah basically it's for our test data we

00:14:19,230 --> 00:14:25,080
have at the top here but I think it's

00:14:24,210 --> 00:14:30,830
the other way around

00:14:25,080 --> 00:14:35,820
Oh true Thanks

00:14:30,830 --> 00:14:37,860
so basically this now doesn't read it

00:14:35,820 --> 00:14:39,900
too well and one nice thing about this

00:14:37,860 --> 00:14:43,790
approach is that we can extract this

00:14:39,900 --> 00:14:57,140
into something else oh come on is

00:14:43,790 --> 00:14:57,140
capitalized and cap cap utilized

00:14:58,190 --> 00:15:04,110
so something like that and then we can

00:15:00,990 --> 00:15:10,230
read it again good we just put it here

00:15:04,110 --> 00:15:12,450
and we're basically good to go so as you

00:15:10,230 --> 00:15:16,530
already mentioned one of the issues is

00:15:12,450 --> 00:15:19,680
that right now missing one test because

00:15:16,530 --> 00:15:23,760
if I'm just returning an empty array all

00:15:19,680 --> 00:15:27,710
my tests are green so everything's fine

00:15:23,760 --> 00:15:31,830
still and in this one particular case

00:15:27,710 --> 00:15:36,710
one can write the first test which says

00:15:31,830 --> 00:15:43,860
returns any employee returns at least

00:15:36,710 --> 00:15:53,690
one employee and then just do something

00:15:43,860 --> 00:15:53,690
like that and say has property length

00:15:53,870 --> 00:16:00,830
greater than or equal to one

00:15:57,500 --> 00:16:03,970
okay and we're good to go and now one of

00:16:00,830 --> 00:16:07,340
the nice things about this test suit is

00:16:03,970 --> 00:16:09,200
regarding what is failing so for example

00:16:07,340 --> 00:16:12,800
I up the sorting for whatever

00:16:09,200 --> 00:16:15,230
reason exactly one test okay because

00:16:12,800 --> 00:16:17,240
that was a because it's already sorted

00:16:15,230 --> 00:16:19,580
but for example I up the filtering

00:16:17,240 --> 00:16:22,240
or the mapping it's gonna see the

00:16:19,580 --> 00:16:25,010
mapping then exactly one test is failing

00:16:22,240 --> 00:16:27,110
so I say it turns employees which names

00:16:25,010 --> 00:16:31,070
are capitalized and I exactly see what's

00:16:27,110 --> 00:16:32,780
wrong with my test suit and the same

00:16:31,070 --> 00:16:34,910
goes for sorting right now the sorting

00:16:32,780 --> 00:16:41,540
is it's already in the right order but

00:16:34,910 --> 00:16:42,920
yeah so that's basically almost

00:16:41,540 --> 00:16:45,380
everything I have

00:16:42,920 --> 00:16:48,260
I wrote the blog post about this thing

00:16:45,380 --> 00:16:52,190
how to compose test assertions out of it

00:16:48,260 --> 00:16:55,100
the library I'm using and I have the

00:16:52,190 --> 00:16:57,860
source code here so if you have any

00:16:55,100 --> 00:17:01,100
questions feel free

00:16:57,860 --> 00:17:01,100

YouTube URL: https://www.youtube.com/watch?v=pXBZ0G1cp3Q


