Title: Vienna.JS, Composing better predicates with PDSL, September 2019
Publication date: 2019-10-02
Playlist: viennaJS
Description: 
	Talk By Rudi Yardley

We often have to balance clarity, precision and brevity when dealing with predicate expressions in JavaScript. In this short talk Rudi will quickly present an easier way to think about and manage predicates using PDSL. https://github.com/ryardley/pdsl
Captions: 
	00:00:00,000 --> 00:00:03,659
my name is Rudy Yardley firstly we want

00:00:02,220 --> 00:00:06,919
to say thank you to Vienna yes for

00:00:03,659 --> 00:00:09,210
letting me chat to you guys tonight

00:00:06,919 --> 00:00:12,150
had some really interesting talks

00:00:09,210 --> 00:00:13,889
tonight I thought Roland's last little

00:00:12,150 --> 00:00:15,719
talk was actually quite an acoustic and

00:00:13,889 --> 00:00:18,810
quite exciting actually I really like

00:00:15,719 --> 00:00:20,220
that and and Julian's take on editors is

00:00:18,810 --> 00:00:24,060
really different to what I've seen

00:00:20,220 --> 00:00:28,320
before so that was really cool yeah I'm

00:00:24,060 --> 00:00:30,390
from Melbourne Australia I'm kind of on

00:00:28,320 --> 00:00:31,439
a working sabbatical at the moment just

00:00:30,390 --> 00:00:34,200
trying to play around with some

00:00:31,439 --> 00:00:35,940
open-source ideas and just sort of have

00:00:34,200 --> 00:00:36,899
fun in code instead of just kind of

00:00:35,940 --> 00:00:39,210
working for the man

00:00:36,899 --> 00:00:43,260
all the time so that's what I'm doing

00:00:39,210 --> 00:00:48,690
here and um yeah and today I want to

00:00:43,260 --> 00:00:51,329
talk about this so does anyone like

00:00:48,690 --> 00:00:55,079
doing this can you go see all that so

00:00:51,329 --> 00:00:58,079
we've got X does not equal no and X does

00:00:55,079 --> 00:01:00,899
not equal undefined anyone like doing

00:00:58,079 --> 00:01:03,470
having to do that all the time you're

00:01:00,899 --> 00:01:10,049
like I've got one guy here who likes it

00:01:03,470 --> 00:01:11,220
anyone refuse to do this right exactly

00:01:10,049 --> 00:01:17,939
I'm gonna get to that in a minute yep

00:01:11,220 --> 00:01:21,390
yep there is - yeah that's true so but

00:01:17,939 --> 00:01:23,400
what is this this thing we've got here X

00:01:21,390 --> 00:01:26,659
doesn't equal no X does make one phone

00:01:23,400 --> 00:01:26,659
anyone know a name for it

00:01:28,520 --> 00:01:34,950
no check whoa what

00:01:32,729 --> 00:01:36,479
it's an equality it's it's it's a

00:01:34,950 --> 00:01:41,850
language construct what sort of language

00:01:36,479 --> 00:01:45,799
contract is it alright it it's an

00:01:41,850 --> 00:01:48,299
expression right so it's an expression

00:01:45,799 --> 00:01:52,079
most specifically it's

00:01:48,299 --> 00:01:54,420
it's a predicate expression and so an

00:01:52,079 --> 00:01:55,950
expression is basically an expression is

00:01:54,420 --> 00:02:01,289
anything that resolves to true or false

00:01:55,950 --> 00:02:04,140
and a predicate expression is States

00:02:01,289 --> 00:02:06,689
affirms or assert something about a

00:02:04,140 --> 00:02:12,420
subject and in this case our subject is

00:02:06,689 --> 00:02:14,220
X we'd use it like this so in an if

00:02:12,420 --> 00:02:18,590
statement you could put the predicate

00:02:14,220 --> 00:02:21,239
expression my if is completely invisible

00:02:18,590 --> 00:02:24,390
because of the contrast here I'm sorry

00:02:21,239 --> 00:02:27,030
but that says if X doesn't equal no and

00:02:24,390 --> 00:02:28,950
then do something and so the idea here

00:02:27,030 --> 00:02:34,110
is that basically we're checking to see

00:02:28,950 --> 00:02:37,049
if we can compute with X but I'm pretty

00:02:34,110 --> 00:02:40,440
lazy as a lot of developers are and I

00:02:37,049 --> 00:02:46,230
tend to do this all the time so I'm just

00:02:40,440 --> 00:02:47,640
like if X do something with that X but

00:02:46,230 --> 00:02:50,489
what if X is zero

00:02:47,640 --> 00:02:53,130
what if it's false what if it's an empty

00:02:50,489 --> 00:02:58,470
string well then it's not really going

00:02:53,130 --> 00:02:59,220
to work and so it's not really correct

00:02:58,470 --> 00:03:00,959
anymore

00:02:59,220 --> 00:03:02,430
so we've got this correct the thing

00:03:00,959 --> 00:03:04,380
where we're checking against like a nil

00:03:02,430 --> 00:03:06,480
check right we're checking against if we

00:03:04,380 --> 00:03:08,489
can compute with X this is just checking

00:03:06,480 --> 00:03:11,819
if it's truth e right which is a little

00:03:08,489 --> 00:03:15,750
a JavaScript trick you know where it

00:03:11,819 --> 00:03:18,290
just checks to see chicks if it's you

00:03:15,750 --> 00:03:20,880
know if it coalesces to true or false

00:03:18,290 --> 00:03:24,810
so but why don't why don't we do this

00:03:20,880 --> 00:03:26,730
what why do we decide to just check X

00:03:24,810 --> 00:03:28,260
and not do the proper thing well I would

00:03:26,730 --> 00:03:31,200
say that there's a good reason for this

00:03:28,260 --> 00:03:34,620
is it basically predicates in JavaScript

00:03:31,200 --> 00:03:37,889
are just not concise enough so when I go

00:03:34,620 --> 00:03:41,280
if X it's a lot less effort on the

00:03:37,889 --> 00:03:43,230
keyboard in my head than going if X

00:03:41,280 --> 00:03:49,139
doesn't equal null and X doesn't equal

00:03:43,230 --> 00:03:53,220
undefined so being concise is it's

00:03:49,139 --> 00:03:56,099
important because it it makes things

00:03:53,220 --> 00:03:58,739
more correct now over here that that

00:03:56,099 --> 00:04:00,859
invisible word there's this type of by

00:03:58,739 --> 00:04:00,859
the way

00:04:01,650 --> 00:04:08,310
yeah so this is another example of a

00:04:04,739 --> 00:04:12,120
predicate expression here we got we're

00:04:08,310 --> 00:04:14,340
checking our input sync that's its user

00:04:12,120 --> 00:04:20,570
names of string and checking out a whole

00:04:14,340 --> 00:04:20,570
lot of stuff about it is this concise

00:04:21,259 --> 00:04:26,280
and don't know I don't know about that

00:04:23,750 --> 00:04:27,990
but there are solutions right so one of

00:04:26,280 --> 00:04:30,750
the solutions thing that we could use

00:04:27,990 --> 00:04:33,960
would be to turn it into a predicate

00:04:30,750 --> 00:04:36,060
function like this gentleman over here

00:04:33,960 --> 00:04:38,820
suggested before which would mean that

00:04:36,060 --> 00:04:41,039
basically we get to tokenize that's use

00:04:38,820 --> 00:04:45,030
one predicate into something that makes

00:04:41,039 --> 00:04:47,190
more sense to us so here we're taking it

00:04:45,030 --> 00:04:48,990
this is a function that takes so there's

00:04:47,190 --> 00:04:50,850
a type by the way before that this is

00:04:48,990 --> 00:04:54,720
typescript type predicate function

00:04:50,850 --> 00:04:57,810
equals x and it returns a book X which

00:04:54,720 --> 00:04:59,130
is any and it returns a boolean all

00:04:57,810 --> 00:04:59,910
right and so this is how we'd use it

00:04:59,130 --> 00:05:03,419
we'd go

00:04:59,910 --> 00:05:07,860
okay we've got Const is not nil equals

00:05:03,419 --> 00:05:10,590
then X returns X like basic returns the

00:05:07,860 --> 00:05:12,090
predicate and so that means that

00:05:10,590 --> 00:05:15,300
anywhere in our code we can then use is

00:05:12,090 --> 00:05:18,720
not nil as a function to to check that

00:05:15,300 --> 00:05:22,650
that's that's the thing that we expect

00:05:18,720 --> 00:05:24,090
out of X is the thing we want and so

00:05:22,650 --> 00:05:27,260
then we have like here's a complex

00:05:24,090 --> 00:05:29,580
predicate function again excuse for the

00:05:27,260 --> 00:05:33,690
read but basically we've got Const is

00:05:29,580 --> 00:05:36,330
user it's function takes input and then

00:05:33,690 --> 00:05:37,650
we're returning input and type of

00:05:36,330 --> 00:05:41,070
employees username blah blah blah blah

00:05:37,650 --> 00:05:43,500
blah so that's complex predicate

00:05:41,070 --> 00:05:45,030
function but I would say that like if we

00:05:43,500 --> 00:05:47,370
look at this there's some issues here

00:05:45,030 --> 00:05:49,470
right and I'd say that complex put a

00:05:47,370 --> 00:05:50,760
predicate function is hard to understand

00:05:49,470 --> 00:05:52,199
the intent when you look at it like

00:05:50,760 --> 00:05:55,169
there's so much stuff going on there

00:05:52,199 --> 00:05:56,940
it's quite complicated you can't

00:05:55,169 --> 00:06:00,630
understand it immediately which is a

00:05:56,940 --> 00:06:02,539
problem and it's it's mainly not concise

00:06:00,630 --> 00:06:05,490
due to the way that JavaScript works and

00:06:02,539 --> 00:06:06,840
as a result it it needs to be well

00:06:05,490 --> 00:06:09,760
tested so when you have these things

00:06:06,840 --> 00:06:12,220
that are checking you know checking

00:06:09,760 --> 00:06:14,500
if the user is valid or you know if an

00:06:12,220 --> 00:06:17,890
object has the correct sort of structure

00:06:14,500 --> 00:06:22,000
that you need you need to usually put

00:06:17,890 --> 00:06:25,390
those in a test so I was asking myself

00:06:22,000 --> 00:06:27,220
well can we do better and I was thinking

00:06:25,390 --> 00:06:29,110
well let's just boil this down a little

00:06:27,220 --> 00:06:32,260
bit right so what's the essential

00:06:29,110 --> 00:06:35,160
information here we've got so here

00:06:32,260 --> 00:06:39,490
here's a predicate function without the

00:06:35,160 --> 00:06:41,110
without the name there so it's just X it

00:06:39,490 --> 00:06:44,530
takes in an X and it checks if it's no

00:06:41,110 --> 00:06:47,410
it's not null or not undefined well we

00:06:44,530 --> 00:06:49,330
can get rid of X so because we're

00:06:47,410 --> 00:06:50,530
dealing with predicates we know that

00:06:49,330 --> 00:06:54,160
there's going to be a subject there and

00:06:50,530 --> 00:06:56,560
as a result we can just say well we know

00:06:54,160 --> 00:06:58,090
it's a subject that we're looking at so

00:06:56,560 --> 00:07:00,880
we can get rid of that we can also get

00:06:58,090 --> 00:07:03,630
rid of the the equality component of it

00:07:00,880 --> 00:07:06,160
because we're checking X against a thing

00:07:03,630 --> 00:07:09,160
so then we have not null and not

00:07:06,160 --> 00:07:11,320
undefined and if we do get a boolean

00:07:09,160 --> 00:07:15,190
algebra we can pull out the not and then

00:07:11,320 --> 00:07:17,350
make it not null or undefined and then

00:07:15,190 --> 00:07:18,880
because we're in la-la-land and we're

00:07:17,350 --> 00:07:20,500
using our imagination and everything we

00:07:18,880 --> 00:07:24,780
can actually just use a single pipe

00:07:20,500 --> 00:07:31,480
instead of instead of a valid JavaScript

00:07:24,780 --> 00:07:33,790
not or and wouldn't it be nice and here

00:07:31,480 --> 00:07:37,900
this says Const again so wouldn't it be

00:07:33,790 --> 00:07:41,950
nice if if we could just go okay well

00:07:37,900 --> 00:07:44,290
here's that little like main information

00:07:41,950 --> 00:07:47,800
about this predicate and give me a

00:07:44,290 --> 00:07:50,680
function that's going to test that and

00:07:47,800 --> 00:07:52,870
it turns out that there is well there is

00:07:50,680 --> 00:07:54,940
now there's a little library that I've

00:07:52,870 --> 00:07:58,690
been working on so P DSL is an open

00:07:54,940 --> 00:08:01,600
source project that I'm working on at

00:07:58,690 --> 00:08:04,390
the moment and basically P DSL allows

00:08:01,600 --> 00:08:08,050
you to do exactly that so you this is

00:08:04,390 --> 00:08:11,290
import P from P DSL Const not nil equals

00:08:08,050 --> 00:08:14,200
P and then part passing into P we pass a

00:08:11,290 --> 00:08:17,710
template string and I call that template

00:08:14,200 --> 00:08:19,570
string of P expression and what what

00:08:17,710 --> 00:08:20,980
that's going to do it's going to provide

00:08:19,570 --> 00:08:22,230
kind of the minimum amount of

00:08:20,980 --> 00:08:25,980
information you need in

00:08:22,230 --> 00:08:28,590
to define what the predicate is that you

00:08:25,980 --> 00:08:32,790
want and then down bottom that's just

00:08:28,590 --> 00:08:35,220
calling that function so here's another

00:08:32,790 --> 00:08:38,550
example so what we're doing here is

00:08:35,220 --> 00:08:40,260
we're checking to see if our object it's

00:08:38,550 --> 00:08:42,510
got a name property on it so you can see

00:08:40,260 --> 00:08:43,770
that the template strings the main thing

00:08:42,510 --> 00:08:45,690
to look for here so you can see that

00:08:43,770 --> 00:08:50,220
that's just basically it looks like an

00:08:45,690 --> 00:08:52,200
object with name in there and here's a

00:08:50,220 --> 00:08:55,410
slightly more complex example where

00:08:52,200 --> 00:08:57,720
we've got what we've got were checking

00:08:55,410 --> 00:08:59,400
for a name checking that the age is

00:08:57,720 --> 00:09:01,020
greater than 16 and we're checking the

00:08:59,400 --> 00:09:06,390
occupation can be either engineer

00:09:01,020 --> 00:09:10,410
designer or project manager so and that

00:09:06,390 --> 00:09:12,470
really big gastly predicate expression

00:09:10,410 --> 00:09:17,040
before that sort of boils down to this

00:09:12,470 --> 00:09:18,660
so here we can you know you've got full

00:09:17,040 --> 00:09:22,110
white space because you can muck around

00:09:18,660 --> 00:09:23,810
with it so we can sort of separate

00:09:22,110 --> 00:09:26,910
things out so that make a bit more sense

00:09:23,810 --> 00:09:31,400
and so that I think to me that's a lot

00:09:26,910 --> 00:09:33,360
more readable than what we had before

00:09:31,400 --> 00:09:35,310
one other thing I think it's quite a

00:09:33,360 --> 00:09:37,680
killer feature of Peter cell is that

00:09:35,310 --> 00:09:38,270
it's composable so you can create small

00:09:37,680 --> 00:09:40,860
peered

00:09:38,270 --> 00:09:44,730
small predicate and then incorporate

00:09:40,860 --> 00:09:47,070
them into larger predicates so there

00:09:44,730 --> 00:09:49,350
we've got here we've got a valid user

00:09:47,070 --> 00:09:51,510
name predicate valid password predicate

00:09:49,350 --> 00:09:53,040
and then is valid user uses both of

00:09:51,510 --> 00:09:56,880
those in order to just check the types

00:09:53,040 --> 00:09:59,970
of the properties that it that it has as

00:09:56,880 --> 00:10:04,880
well as that where typescript compatible

00:09:59,970 --> 00:10:07,140
so take typescript types pass them into

00:10:04,880 --> 00:10:10,410
this is all within typescript person

00:10:07,140 --> 00:10:12,900
into where we call our P function and

00:10:10,410 --> 00:10:16,470
then that turns the resulting predicate

00:10:12,900 --> 00:10:18,600
into a guard statement so also a guard

00:10:16,470 --> 00:10:20,820
function so you can use that guide

00:10:18,600 --> 00:10:23,220
function and then types are just going

00:10:20,820 --> 00:10:24,720
to know that once you've used that that

00:10:23,220 --> 00:10:27,960
you have the particular type you've

00:10:24,720 --> 00:10:29,730
specified we've got primitive matching

00:10:27,960 --> 00:10:33,150
so here we're checking against number

00:10:29,730 --> 00:10:35,340
boolean strings symbol and array and you

00:10:33,150 --> 00:10:35,920
can pass in stuff into that so you can

00:10:35,340 --> 00:10:38,260
pass in

00:10:35,920 --> 00:10:40,089
sort of JavaScript primitive you want so

00:10:38,260 --> 00:10:43,209
you could pass in the actual JavaScript

00:10:40,089 --> 00:10:45,610
primitive inside the template literal

00:10:43,209 --> 00:10:48,880
and do that there

00:10:45,610 --> 00:10:51,880
we've got range comparison so here is

00:10:48,880 --> 00:10:54,310
teenager is just checking to see if the

00:10:51,880 --> 00:10:57,029
numbers between and including thirteen

00:10:54,310 --> 00:10:57,029
to nineteen

00:10:57,370 --> 00:11:03,459
we've got boolean operators so this will

00:11:01,540 --> 00:11:08,170
return true if the input object is

00:11:03,459 --> 00:11:12,220
either has a success message string in

00:11:08,170 --> 00:11:15,839
it or it has an error code which is a

00:11:12,220 --> 00:11:20,440
number and a message which is a string

00:11:15,839 --> 00:11:23,860
reference equality we can check the

00:11:20,440 --> 00:11:28,029
empty stuff so you can use arrays of

00:11:23,860 --> 00:11:30,360
objects or undefined null we can check

00:11:28,029 --> 00:11:35,620
to see if an array contains a value so

00:11:30,360 --> 00:11:38,500
that so here we've got we're checking to

00:11:35,620 --> 00:11:43,360
see if this array contains seven and the

00:11:38,500 --> 00:11:45,060
string foo and so basically if we look

00:11:43,360 --> 00:11:48,279
when we boil it down the way that

00:11:45,060 --> 00:11:50,490
pedicel works is it it uses a bunch of

00:11:48,279 --> 00:11:53,440
helper functions and peter cell actually

00:11:50,490 --> 00:11:55,810
provides those helper functions to the

00:11:53,440 --> 00:11:57,699
developer to use to compose your own if

00:11:55,810 --> 00:11:58,870
you needed or if you needed to just if

00:11:57,699 --> 00:12:01,589
you just wanted to use the functions by

00:11:58,870 --> 00:12:04,089
themselves are there so you can use them

00:12:01,589 --> 00:12:05,560
that's a more detailed list of the ones

00:12:04,089 --> 00:12:09,610
that have been able to put together so

00:12:05,560 --> 00:12:11,920
far and i've also written a babel plugin

00:12:09,610 --> 00:12:14,529
for it so that makes peter so quite fast

00:12:11,920 --> 00:12:18,910
because you can add that to your table

00:12:14,529 --> 00:12:20,800
config and it's gonna mean that all of

00:12:18,910 --> 00:12:23,740
your p expressions will then be compiled

00:12:20,800 --> 00:12:24,940
into just function calls so that they're

00:12:23,740 --> 00:12:26,529
actually quite fast they're not going to

00:12:24,940 --> 00:12:28,779
be a performance penalty of having to go

00:12:26,529 --> 00:12:30,640
through pass the string work out what's

00:12:28,779 --> 00:12:31,870
a you know what the shape of the object

00:12:30,640 --> 00:12:33,370
is that you're looking for them whatever

00:12:31,870 --> 00:12:34,810
so it's just going to be a bunch of

00:12:33,370 --> 00:12:38,769
function calls in your in your final

00:12:34,810 --> 00:12:40,870
build so it is a little bit experimental

00:12:38,769 --> 00:12:42,610
still there I'm sure there are a couple

00:12:40,870 --> 00:12:43,990
of bugs in that that only should have

00:12:42,610 --> 00:12:46,120
popped the other day and haven't had a

00:12:43,990 --> 00:12:48,519
lot of time to work on it lately so but

00:12:46,120 --> 00:12:49,920
I plan to go back and fix a couple other

00:12:48,519 --> 00:12:53,379
bugs

00:12:49,920 --> 00:12:56,319
so the syntax it's influenced by

00:12:53,379 --> 00:12:58,149
JavaScript typescript flow star

00:12:56,319 --> 00:13:02,470
components as you can see with the

00:12:58,149 --> 00:13:05,199
template literals and Ruby and also by

00:13:02,470 --> 00:13:07,600
you so I'm hoping that by come coming

00:13:05,199 --> 00:13:09,249
and talking about this maybe you'd be

00:13:07,600 --> 00:13:11,110
interested in coming to check out the

00:13:09,249 --> 00:13:12,550
repository and provide some feedback and

00:13:11,110 --> 00:13:13,869
let me know what you don't like about it

00:13:12,550 --> 00:13:15,279
what you like about it that'd be really

00:13:13,869 --> 00:13:19,059
cool

00:13:15,279 --> 00:13:21,339
yeah I loved your input so beauty still

00:13:19,059 --> 00:13:25,449
is young I just started it a couple of

00:13:21,339 --> 00:13:27,910
months ago I was hacking on it can't do

00:13:25,449 --> 00:13:31,569
a J's camp in Barcelona the other day

00:13:27,910 --> 00:13:33,160
and so I still need to do syntax

00:13:31,569 --> 00:13:35,110
highlighting unfortunately I haven't got

00:13:33,160 --> 00:13:37,600
that happening yet so within the PD

00:13:35,110 --> 00:13:39,999
within the P expression it's still just

00:13:37,600 --> 00:13:42,009
a template string but actually if

00:13:39,999 --> 00:13:43,569
someone knows how to do that I'd love to

00:13:42,009 --> 00:13:45,100
hear from you if anyone's done any

00:13:43,569 --> 00:13:46,809
syntax highlighting it like PS code

00:13:45,100 --> 00:13:48,550
syntax highlighting I'd really like to

00:13:46,809 --> 00:13:51,220
talk to you about that not all the

00:13:48,550 --> 00:13:55,179
syntax is defined there are still open

00:13:51,220 --> 00:13:57,879
areas that we're looking at a big one is

00:13:55,179 --> 00:14:00,910
that I've been working on this with

00:13:57,879 --> 00:14:03,399
another guy and he's what we've been

00:14:00,910 --> 00:14:05,049
talking about moving to exact matching

00:14:03,399 --> 00:14:06,759
by default at the moment it's not it's

00:14:05,049 --> 00:14:08,019
it's loose matching at the moment but

00:14:06,759 --> 00:14:09,699
exact matching is actually going to make

00:14:08,019 --> 00:14:11,949
it a lot better because you're going to

00:14:09,699 --> 00:14:15,220
be able to be much more precise with DP

00:14:11,949 --> 00:14:18,040
expressions and it adds a bunch of other

00:14:15,220 --> 00:14:19,839
good features to it too

00:14:18,040 --> 00:14:21,910
and lastly I've been looking at

00:14:19,839 --> 00:14:26,079
validation errors so that we can create

00:14:21,910 --> 00:14:28,360
a different type of a different type of

00:14:26,079 --> 00:14:29,769
process that will instead of spitting

00:14:28,360 --> 00:14:32,499
out true or false it's going to give you

00:14:29,769 --> 00:14:34,929
an array of errors so you can specify

00:14:32,499 --> 00:14:36,939
the errors within within the P

00:14:34,929 --> 00:14:39,449
expression and then you'll be able to

00:14:36,939 --> 00:14:43,119
use it to do things like validate form

00:14:39,449 --> 00:14:44,860
objects and that sort of stuff so this

00:14:43,119 --> 00:14:47,709
is a little sneak preview so that's the

00:14:44,860 --> 00:14:51,759
exact matching so it's a little bit

00:14:47,709 --> 00:14:53,350
small but but yeah and a validation of

00:14:51,759 --> 00:14:55,480
errors is going to look like that at the

00:14:53,350 --> 00:14:59,259
moment that could change so we're not

00:14:55,480 --> 00:15:01,929
sure yet so I'd appreciate it if you can

00:14:59,259 --> 00:15:03,289
follow P DSL on github if you feel so

00:15:01,929 --> 00:15:07,049
inclined

00:15:03,289 --> 00:15:09,179
any input any issues any PRS any stars

00:15:07,049 --> 00:15:12,720
all things that I'm gonna make me love

00:15:09,179 --> 00:15:15,509
you so thank you and if you have any

00:15:12,720 --> 00:15:20,009
questions I must show how much more time

00:15:15,509 --> 00:15:22,019
I've got her from yep so yeah if if

00:15:20,009 --> 00:15:28,249
anyone has any questions I'll be happy

00:15:22,019 --> 00:15:28,249

YouTube URL: https://www.youtube.com/watch?v=_B-Zw7VPb7g


