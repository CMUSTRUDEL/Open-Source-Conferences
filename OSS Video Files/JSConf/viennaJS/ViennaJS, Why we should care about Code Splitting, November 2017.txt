Title: ViennaJS, Why we should care about Code Splitting, November 2017
Publication date: 2018-02-12
Playlist: viennaJS
Description: 
	Shipping apps is easy, but shipping GREAT apps takes quite some effort. Our mission now is to build faster web apps and deliver as less code as needed. But how? Dynamic imports have arrived! With the new import() proposal we have got a convenient capability to load React components whenever rendered. In this talk by Glenn Reyes, we will leverage code-splitting with minimal effort and discuss common approaches.

More about Glenn: https://twitter.com/glnnrys

More about ViennaJS: https://www.meetup.com/viennajs/
Captions: 
	00:00:00,240 --> 00:00:04,380
hey everybody so welcome to my talk

00:00:02,520 --> 00:00:07,740
about why I should care about code

00:00:04,380 --> 00:00:09,929
splitting I gave the talk like half a

00:00:07,740 --> 00:00:13,110
year ago at Vienna J's but it was kind

00:00:09,929 --> 00:00:15,480
of like a prototype of it so hands up

00:00:13,110 --> 00:00:19,770
who has heard about who was here like

00:00:15,480 --> 00:00:24,689
half a year ago I see one end to okay so

00:00:19,770 --> 00:00:28,740
not too many so it's good yeah Dan would

00:00:24,689 --> 00:00:33,239
stop and go outgo so yeah my name is

00:00:28,740 --> 00:00:37,350
Glenn Reyes and the one behind this is

00:00:33,239 --> 00:00:39,149
my face because if you see it and this

00:00:37,350 --> 00:00:41,690
is also my twitter handle which is my

00:00:39,149 --> 00:00:43,950
name actually but without the ease and

00:00:41,690 --> 00:00:46,170
I'm a freelance front-end engineer

00:00:43,950 --> 00:00:51,360
currently working with react and

00:00:46,170 --> 00:00:53,100
currently working with graph GL and I'm

00:00:51,360 --> 00:00:56,070
also married to play the guitar and be

00:00:53,100 --> 00:00:58,500
like to be around the globe so I'm also

00:00:56,070 --> 00:01:02,280
part of the array Agana meetup group

00:00:58,500 --> 00:01:04,860
which is I helped them up to organise

00:01:02,280 --> 00:01:07,260
meetups and the next one is on December

00:01:04,860 --> 00:01:08,790
13 so you may want to check this out if

00:01:07,260 --> 00:01:11,840
you're interesting if you're interested

00:01:08,790 --> 00:01:14,430
in react or react to related stuff and

00:01:11,840 --> 00:01:15,990
yeah let's talk about a little bit code

00:01:14,430 --> 00:01:19,740
splitting so hands up in the air who

00:01:15,990 --> 00:01:23,369
knows what code splitting is awesome

00:01:19,740 --> 00:01:25,229
who who knows who who has played with it

00:01:23,369 --> 00:01:28,979
but haven't had the chance to ship

00:01:25,229 --> 00:01:31,610
something something who has sheep

00:01:28,979 --> 00:01:36,030
production died with it

00:01:31,610 --> 00:01:38,909
not too many oh it's so what is code

00:01:36,030 --> 00:01:41,100
splitting actually code splitting is

00:01:38,909 --> 00:01:44,759
nothing but a feature that allows you to

00:01:41,100 --> 00:01:47,250
split code into that can be loaded on

00:01:44,759 --> 00:01:49,350
demand or in parallel so what does this

00:01:47,250 --> 00:01:52,860
mean in our component architecture like

00:01:49,350 --> 00:01:55,049
like and react so let's say we have this

00:01:52,860 --> 00:01:57,810
component three and top-level one

00:01:55,049 --> 00:01:59,820
represents like the entry points imagine

00:01:57,810 --> 00:02:04,200
of webpack the empty point of a module

00:01:59,820 --> 00:02:07,920
and that imports react components and

00:02:04,200 --> 00:02:11,160
and so on and so forth so most apps

00:02:07,920 --> 00:02:14,100
likely have ever out separate the views

00:02:11,160 --> 00:02:17,280
right so let's say this

00:02:14,100 --> 00:02:21,510
part in blue is is our components that

00:02:17,280 --> 00:02:24,930
is used for a homer out and the the one

00:02:21,510 --> 00:02:27,600
on the right is are the parts for that

00:02:24,930 --> 00:02:30,330
are used for a profiler out right so

00:02:27,600 --> 00:02:33,900
this example just uses two routes in

00:02:30,330 --> 00:02:37,500
total and most simple configuration of a

00:02:33,900 --> 00:02:40,430
bundler like web pack for example they

00:02:37,500 --> 00:02:43,830
they generate like one giant bundle and

00:02:40,430 --> 00:02:46,080
it contains like NPM packages and all

00:02:43,830 --> 00:02:47,760
the react components they all are

00:02:46,080 --> 00:02:49,890
squeezed into one giant monolithic

00:02:47,760 --> 00:02:52,650
Bangla the camera really be dependent on

00:02:49,890 --> 00:02:54,960
your application and the problem if the

00:02:52,650 --> 00:02:56,610
problem is if you would only visit the

00:02:54,960 --> 00:03:00,720
if you would only visit the home page

00:02:56,610 --> 00:03:02,520
for example all the parts that that you

00:03:00,720 --> 00:03:07,110
use for the profile page would be loaded

00:03:02,520 --> 00:03:09,390
as well over the network and so we need

00:03:07,110 --> 00:03:12,330
to split the bundle into smaller pieces

00:03:09,390 --> 00:03:15,140
and to do so we first want to define

00:03:12,330 --> 00:03:19,860
speeding points exactly there and

00:03:15,140 --> 00:03:22,290
separate pieces of code so you want to

00:03:19,860 --> 00:03:25,440
basically set boundaries that are

00:03:22,290 --> 00:03:28,140
specific to the views and our share code

00:03:25,440 --> 00:03:30,180
that is that is used across across all

00:03:28,140 --> 00:03:34,050
pages which is which is in this case

00:03:30,180 --> 00:03:37,350
only the entry point and as a result we

00:03:34,050 --> 00:03:40,110
expect to to to have our application

00:03:37,350 --> 00:03:42,750
divided into separate smaller pieces of

00:03:40,110 --> 00:03:44,640
chunks and it's in this case we have the

00:03:42,750 --> 00:03:47,430
bound on the GS and the parts for the

00:03:44,640 --> 00:03:50,250
home that GS and the parts for profile

00:03:47,430 --> 00:03:52,770
of GS these two parts are like the route

00:03:50,250 --> 00:03:56,330
specific chunks that you would use only

00:03:52,770 --> 00:03:59,160
if you visit this route right and

00:03:56,330 --> 00:04:01,320
imagining visiting our app if you visit

00:03:59,160 --> 00:04:03,270
the home route these are the parts that

00:04:01,320 --> 00:04:06,090
you want to do one a load over the

00:04:03,270 --> 00:04:09,120
network right and all the pink parts

00:04:06,090 --> 00:04:13,200
shouldn't be loaded as you visit only

00:04:09,120 --> 00:04:15,180
the home page and yeah again these are

00:04:13,200 --> 00:04:16,920
the two bundles that you would that you

00:04:15,180 --> 00:04:19,010
want that you want to load that should

00:04:16,920 --> 00:04:21,930
be present when you visit the home page

00:04:19,010 --> 00:04:23,760
so we want to skip the profile code

00:04:21,930 --> 00:04:26,310
because it's not needed at the moment

00:04:23,760 --> 00:04:27,810
and because of this we will potentially

00:04:26,310 --> 00:04:29,550
improve

00:04:27,810 --> 00:04:32,460
performance introduced PageSpeed load

00:04:29,550 --> 00:04:33,120
read and actually why should we why

00:04:32,460 --> 00:04:35,760
should we care

00:04:33,120 --> 00:04:38,610
do we really need it and when I started

00:04:35,760 --> 00:04:40,710
to dig deeper into this I was like hell

00:04:38,610 --> 00:04:43,200
of Hell of God I I don't I don't I don't

00:04:40,710 --> 00:04:45,240
want it it's just much probably too much

00:04:43,200 --> 00:04:48,090
overhead it's my app is too small enough

00:04:45,240 --> 00:04:49,620
I don't need it right and of course if

00:04:48,090 --> 00:04:51,510
it was just me I wouldn't need it

00:04:49,620 --> 00:04:52,740
because I'm really support held in that

00:04:51,510 --> 00:04:53,790
most of the time when I'm when I'm

00:04:52,740 --> 00:04:56,639
surfing or the Internet

00:04:53,790 --> 00:05:01,620
it's it's on 100 megabytes per second

00:04:56,639 --> 00:05:03,780
and all of us here we all we know it we

00:05:01,620 --> 00:05:06,720
are all engineers and we know how to

00:05:03,780 --> 00:05:08,669
handle networks and to get to get like

00:05:06,720 --> 00:05:10,410
fast internet connection and we know

00:05:08,669 --> 00:05:11,970
that we are privileged so and most of

00:05:10,410 --> 00:05:14,460
the time we know how to troubleshoot

00:05:11,970 --> 00:05:16,860
tech right and we should really

00:05:14,460 --> 00:05:20,310
appreciate it so mostly we don't have to

00:05:16,860 --> 00:05:23,940
worry about properly accessing our Web

00:05:20,310 --> 00:05:27,570
Apps and it's basically everything is

00:05:23,940 --> 00:05:29,610
cool until we see this this guy right so

00:05:27,570 --> 00:05:31,890
everybody everybody hates this like

00:05:29,610 --> 00:05:34,260
especially if you want if you need

00:05:31,890 --> 00:05:36,120
something really but you need you need

00:05:34,260 --> 00:05:38,970
to wait like forever and it's really

00:05:36,120 --> 00:05:41,820
frustrating when especially in

00:05:38,970 --> 00:05:43,680
situations where your needs connectivity

00:05:41,820 --> 00:05:46,650
right now imagine you're in the middle

00:05:43,680 --> 00:05:48,780
of nowhere right and then and then your

00:05:46,650 --> 00:05:50,789
your your only survivor is now internet

00:05:48,780 --> 00:05:53,750
connection and then suddenly yeah

00:05:50,789 --> 00:06:02,400
suddenly a CD let me see this guy right

00:05:53,750 --> 00:06:06,120
so so the thing is we are used to expect

00:06:02,400 --> 00:06:09,150
the internet users work and in fact the

00:06:06,120 --> 00:06:11,400
vast majority of people surfing on the

00:06:09,150 --> 00:06:13,979
internet right now is not on on on our

00:06:11,400 --> 00:06:17,340
elegant super high fast computers it's

00:06:13,979 --> 00:06:20,100
it's it's it's like this where's the

00:06:17,340 --> 00:06:21,900
more and more people like are using the

00:06:20,100 --> 00:06:26,850
internet over the smart phones and very

00:06:21,900 --> 00:06:29,940
little phones that are very that are not

00:06:26,850 --> 00:06:31,680
that that it does not have the same

00:06:29,940 --> 00:06:34,080
capability is like like your computers

00:06:31,680 --> 00:06:35,760
right so again back to question why

00:06:34,080 --> 00:06:38,340
should we care

00:06:35,760 --> 00:06:40,919
code speeding can help out can help out

00:06:38,340 --> 00:06:41,670
to reduce or idle time and despite this

00:06:40,919 --> 00:06:43,940
why

00:06:41,670 --> 00:06:45,900
Coates but is because it's so simple

00:06:43,940 --> 00:06:48,780
correlating is nothing else but

00:06:45,900 --> 00:06:51,690
replacing one line code of code with

00:06:48,780 --> 00:06:52,680
with four lines of code it doesn't it

00:06:51,690 --> 00:06:54,420
doesn't mean you want you need to

00:06:52,680 --> 00:06:55,890
reflect or like like your whole

00:06:54,420 --> 00:06:58,080
application or a half code of the

00:06:55,890 --> 00:07:00,890
application is basically one it's

00:06:58,080 --> 00:07:04,200
basically three more lines of extra code

00:07:00,890 --> 00:07:05,940
now how does code trading mean for

00:07:04,200 --> 00:07:08,490
performance what's how does it increase

00:07:05,940 --> 00:07:13,740
performance so one reason why I wanna a

00:07:08,490 --> 00:07:17,220
cosplayer is to separate the bundles is

00:07:13,740 --> 00:07:19,320
long-term caching and long-term caching

00:07:17,220 --> 00:07:21,600
means you split your vendor codes like

00:07:19,320 --> 00:07:24,360
packages in node modules that almost

00:07:21,600 --> 00:07:26,490
never changes with app code that you

00:07:24,360 --> 00:07:29,100
frequently updates and add over that

00:07:26,490 --> 00:07:31,560
features over the time so and after this

00:07:29,100 --> 00:07:34,770
you basically get the benefit of not

00:07:31,560 --> 00:07:37,050
read downloading NPM packages it hasn't

00:07:34,770 --> 00:07:43,200
changed deployed after you have deployed

00:07:37,050 --> 00:07:44,850
your your your app right and also split

00:07:43,200 --> 00:07:47,850
up codes are being loaded asynchronously

00:07:44,850 --> 00:07:49,770
by using the power of promises and this

00:07:47,850 --> 00:07:52,050
means you don't have to worry about

00:07:49,770 --> 00:07:56,310
render blocking while you were you're

00:07:52,050 --> 00:07:59,370
loading the page and this this allows

00:07:56,310 --> 00:08:01,560
you to easily customize components like

00:07:59,370 --> 00:08:05,160
like Laura loading opponents and and

00:08:01,560 --> 00:08:08,370
render them as you as you want and they

00:08:05,160 --> 00:08:09,990
are they're already there as you stay as

00:08:08,370 --> 00:08:13,170
you wanted you want them to be rendered

00:08:09,990 --> 00:08:15,930
right so with code splitting or all

00:08:13,170 --> 00:08:18,180
necessary code are loaded on demand and

00:08:15,930 --> 00:08:21,510
the bundler would take care of injecting

00:08:18,180 --> 00:08:23,790
code automatically to the Dom and that

00:08:21,510 --> 00:08:26,760
is needed in the page I'll explain it a

00:08:23,790 --> 00:08:28,860
little bit later so we as developer we

00:08:26,760 --> 00:08:31,920
shouldn't have to worry about what

00:08:28,860 --> 00:08:35,040
happens what happens and at a low level

00:08:31,920 --> 00:08:38,640
is on level right so what we aim for is

00:08:35,040 --> 00:08:41,580
not to waste any kilobytes that's being

00:08:38,640 --> 00:08:43,560
downloaded through your network and

00:08:41,580 --> 00:08:46,710
what we aim for is to load code as

00:08:43,560 --> 00:08:48,450
needed so yeah let's you might be

00:08:46,710 --> 00:08:51,960
curious about how this how this works

00:08:48,450 --> 00:08:55,010
and let's take a sec that the app

00:08:51,960 --> 00:08:57,680
example earlier where we have there's

00:08:55,010 --> 00:09:01,550
our home home route right with the blue

00:08:57,680 --> 00:09:04,459
background and if we take a closer look

00:09:01,550 --> 00:09:07,730
to the h2 element 3 we see that we have

00:09:04,459 --> 00:09:10,209
here underneath the bounded GS which is

00:09:07,730 --> 00:09:13,790
which is our shared application code and

00:09:10,209 --> 00:09:19,639
here in the head the home that jankoji s

00:09:13,790 --> 00:09:22,430
that is loaded as our app recognized

00:09:19,639 --> 00:09:26,630
oh we here the home page and so let's

00:09:22,430 --> 00:09:28,880
load this dynamically and after after

00:09:26,630 --> 00:09:30,500
both after both scripts are there you

00:09:28,880 --> 00:09:32,779
will see your your app in the end

00:09:30,500 --> 00:09:36,230
rendered on the browser or any or any

00:09:32,779 --> 00:09:37,639
environment so if as we click on the

00:09:36,230 --> 00:09:40,790
profile page while being on the home

00:09:37,639 --> 00:09:42,800
page and looking at dependents looking

00:09:40,790 --> 00:09:44,750
at the HTML element tree again we know

00:09:42,800 --> 00:09:46,459
they stirrers now another script tag

00:09:44,750 --> 00:09:48,529
which is the proper that chunk of GS and

00:09:46,459 --> 00:09:51,110
the profit chunk the GS is the part that

00:09:48,529 --> 00:09:55,089
we have that is that is used for the for

00:09:51,110 --> 00:09:57,500
the other forty of other other route and

00:09:55,089 --> 00:09:59,269
we notice we have now home that jankoji

00:09:57,500 --> 00:10:02,390
has probably challenges and bondage GS

00:09:59,269 --> 00:10:05,029
and the thing is we moved from the home

00:10:02,390 --> 00:10:07,790
page to a profile page and as we moved

00:10:05,029 --> 00:10:10,910
to the home to the profile page we we

00:10:07,790 --> 00:10:13,339
dynamically loaded another chunk and and

00:10:10,910 --> 00:10:16,730
the code that we have in the profile

00:10:13,339 --> 00:10:20,329
page is a nano key been added to the to

00:10:16,730 --> 00:10:22,070
to our to our browser right so

00:10:20,329 --> 00:10:24,769
everything is there and nothing will be

00:10:22,070 --> 00:10:30,079
loaded anymore to the wire well we have

00:10:24,769 --> 00:10:33,980
this and if you're also if you're using

00:10:30,079 --> 00:10:37,160
CSS mgs all styles are being the not

00:10:33,980 --> 00:10:39,290
only are being downloaded dynamically

00:10:37,160 --> 00:10:43,399
for free by using this code splitting

00:10:39,290 --> 00:10:45,199
because CSS and J's relies on your

00:10:43,399 --> 00:10:47,060
modules and relies on your components

00:10:45,199 --> 00:10:49,390
that you're using they are all tightly

00:10:47,060 --> 00:10:52,220
coupled on door and the environment

00:10:49,390 --> 00:10:54,319
because of this styles are loaded on the

00:10:52,220 --> 00:10:57,670
mound as well which is which is really

00:10:54,319 --> 00:11:01,010
powerful actually and despite despite

00:10:57,670 --> 00:11:02,810
despite this all we can all load code

00:11:01,010 --> 00:11:06,620
that is dynamically based on its

00:11:02,810 --> 00:11:08,199
interactions and yeah it's really cool

00:11:06,620 --> 00:11:10,449
isn't it so

00:11:08,199 --> 00:11:14,569
yeah let's take a little bit a look at

00:11:10,449 --> 00:11:16,600
syntax so right now there are a number

00:11:14,569 --> 00:11:18,739
of ways on how you want to import

00:11:16,600 --> 00:11:21,259
modules or components into your

00:11:18,739 --> 00:11:22,999
interview into some modules right so

00:11:21,259 --> 00:11:25,699
there is for example a system that I've

00:11:22,999 --> 00:11:28,339
really bad to read but the system that

00:11:25,699 --> 00:11:31,129
j/s systems is not import for example or

00:11:28,339 --> 00:11:33,439
system that import which is I think web

00:11:31,129 --> 00:11:36,679
pick to you or so and there's also

00:11:33,439 --> 00:11:40,489
common GS requires and require that

00:11:36,679 --> 00:11:46,970
ensure and even people implement their

00:11:40,489 --> 00:11:49,220
own way of importing modules and there's

00:11:46,970 --> 00:11:53,329
thankfully something better than than

00:11:49,220 --> 00:11:55,579
this and it's called dynamic import so

00:11:53,329 --> 00:11:58,040
it looks like this and its really

00:11:55,579 --> 00:12:01,429
awesome very familiar for us JavaScript

00:11:58,040 --> 00:12:03,910
developers so what is it and how how do

00:12:01,429 --> 00:12:03,910
I use it

00:12:04,929 --> 00:12:10,239
syntactically it looks like like a

00:12:07,669 --> 00:12:15,199
function and use the reserved word

00:12:10,239 --> 00:12:16,789
import as a name of a function but yeah

00:12:15,199 --> 00:12:19,160
it except it accepts the path to your

00:12:16,789 --> 00:12:21,169
module and it doesn't actually behave

00:12:19,160 --> 00:12:24,470
like like a function it behaves more

00:12:21,169 --> 00:12:27,829
like like like the super in your

00:12:24,470 --> 00:12:33,429
constructor for example it doesn't what

00:12:27,829 --> 00:12:36,799
it also does is it returns a promise and

00:12:33,429 --> 00:12:39,769
behaves like like this so very a lot of

00:12:36,799 --> 00:12:41,569
open source libraries are adapting this

00:12:39,769 --> 00:12:44,749
feature because the syntax makes a lot

00:12:41,569 --> 00:12:46,549
of sense and there is an open tc39

00:12:44,749 --> 00:12:48,799
proposal which you can check out at

00:12:46,549 --> 00:12:49,939
github and if you're interested into the

00:12:48,799 --> 00:12:52,220
into the steps

00:12:49,939 --> 00:12:53,839
I think it's currently in stage 3 right

00:12:52,220 --> 00:12:56,439
now but if you're interested into the

00:12:53,839 --> 00:13:01,789
progress so definitely check this out

00:12:56,439 --> 00:13:03,739
but even if it's a proposal it's it's we

00:13:01,789 --> 00:13:06,709
don't have to wait for for this to land

00:13:03,739 --> 00:13:09,049
to the spec right because with babel we

00:13:06,709 --> 00:13:13,129
are able to allow we're able to use

00:13:09,049 --> 00:13:16,189
these the syntax today and with syntax

00:13:13,129 --> 00:13:19,100
dynamic plugin and with this baby we'll

00:13:16,189 --> 00:13:21,139
be able to parse the new syntax the new

00:13:19,100 --> 00:13:23,720
import syntax into code 3

00:13:21,139 --> 00:13:26,629
is actually readable in your browser or

00:13:23,720 --> 00:13:29,239
any other - in target environment and

00:13:26,629 --> 00:13:31,879
actually I want to add to this is chrome

00:13:29,239 --> 00:13:35,119
better and and Firefox better I guess

00:13:31,879 --> 00:13:38,929
they they have it already on in the

00:13:35,119 --> 00:13:43,850
browser natively so they implemented it

00:13:38,929 --> 00:13:45,709
already into the browser but yeah if you

00:13:43,850 --> 00:13:48,259
if you're still using other browsers

00:13:45,709 --> 00:13:50,059
than the better so the magic will happen

00:13:48,259 --> 00:13:54,199
all in this in the bundler which is in

00:13:50,059 --> 00:13:55,970
this case web pack and you find here are

00:13:54,199 --> 00:13:58,399
fantastic guides on how to set up code

00:13:55,970 --> 00:14:00,379
splitting what it does and all the

00:13:58,399 --> 00:14:03,470
informations you need for setting up and

00:14:00,379 --> 00:14:05,799
configuring this thing and also there is

00:14:03,470 --> 00:14:08,239
a nice step-by-step guide from duo of

00:14:05,799 --> 00:14:09,859
survived J's calm so definitely check

00:14:08,239 --> 00:14:13,579
this out it's it's a really great thing

00:14:09,859 --> 00:14:21,739
I also tweet my my slides so you so you

00:14:13,579 --> 00:14:24,259
don't need to catch pictures or so now

00:14:21,739 --> 00:14:29,149
let's talk a little bit about more about

00:14:24,259 --> 00:14:33,529
how how the Namek imports are different

00:14:29,149 --> 00:14:38,059
to synchronous imports basically u6

00:14:33,529 --> 00:14:40,429
imports loads module synchronously by

00:14:38,059 --> 00:14:42,799
just importing for import charge from

00:14:40,429 --> 00:14:45,709
chart and so on and and then you have

00:14:42,799 --> 00:14:49,009
access on the module so it's nothing you

00:14:45,709 --> 00:14:51,290
write and we have asynchronous imports

00:14:49,009 --> 00:14:53,899
using dynamic imports you basically call

00:14:51,290 --> 00:14:56,119
the import by passing passing the patent

00:14:53,899 --> 00:14:58,220
module and then use it just as you would

00:14:56,119 --> 00:15:00,649
deal with promises like in this case

00:14:58,220 --> 00:15:04,519
with the debt dam module and then you

00:15:00,649 --> 00:15:08,079
have access to your module and the cool

00:15:04,519 --> 00:15:11,449
thing is you can use a second and wait

00:15:08,079 --> 00:15:13,759
with import as well with the name

00:15:11,449 --> 00:15:17,539
keepers as well you just basically wrap

00:15:13,759 --> 00:15:18,980
an async at the wrapping function or add

00:15:17,539 --> 00:15:22,129
an async to the wrapping function and

00:15:18,980 --> 00:15:24,799
then you can access to the module with

00:15:22,129 --> 00:15:28,039
pretending awaits before your dynamic

00:15:24,799 --> 00:15:30,919
import and everything looks more like

00:15:28,039 --> 00:15:35,010
imperative Lee and more like sync code

00:15:30,919 --> 00:15:36,810
even if it stays in code right and

00:15:35,010 --> 00:15:39,480
let's talk a little bit about more how

00:15:36,810 --> 00:15:43,590
you wanted how you would use a dynamic

00:15:39,480 --> 00:15:46,470
import with react and note that react

00:15:43,590 --> 00:15:48,510
isn't just the only way on how you can

00:15:46,470 --> 00:15:51,180
apply the name imports there's a lot of

00:15:48,510 --> 00:15:55,500
frameworks like angular view or ember

00:15:51,180 --> 00:15:57,720
that probably will are will adapt is

00:15:55,500 --> 00:15:59,280
feature to write so watch but in this

00:15:57,720 --> 00:16:05,220
but for now I'll show you an example in

00:15:59,280 --> 00:16:08,910
react so in our app components we

00:16:05,220 --> 00:16:11,220
basically want to render a component

00:16:08,910 --> 00:16:13,500
that is being loaded asynchronously or

00:16:11,220 --> 00:16:16,350
we basically want to load an

00:16:13,500 --> 00:16:20,930
asynchronous components by importing

00:16:16,350 --> 00:16:24,330
some something and once that we mounted

00:16:20,930 --> 00:16:27,200
so what what is once you set initial

00:16:24,330 --> 00:16:30,120
initial state in our react state and

00:16:27,200 --> 00:16:33,870
render first or return first with a

00:16:30,120 --> 00:16:35,340
function simple react element by to just

00:16:33,870 --> 00:16:39,270
show that nothing is loaded so this is

00:16:35,340 --> 00:16:44,600
our synchronous nothing nothing has been

00:16:39,270 --> 00:16:47,610
loaded indicator right so and react

00:16:44,600 --> 00:16:49,440
react components has have this has this

00:16:47,610 --> 00:16:51,960
pattern that is called lifecycle hooks

00:16:49,440 --> 00:16:55,650
like component did mountain in this case

00:16:51,960 --> 00:16:58,830
and it fires when the component has been

00:16:55,650 --> 00:17:01,080
mounted and in component did mount we

00:16:58,830 --> 00:17:03,720
want to call the dynamic import and pass

00:17:01,080 --> 00:17:07,020
the path for the async component as an

00:17:03,720 --> 00:17:10,650
argument and then we simply assign the

00:17:07,020 --> 00:17:14,400
result to our to our constant Asian

00:17:10,650 --> 00:17:17,490
component and then we simply set the

00:17:14,400 --> 00:17:20,339
state to to update or to perform a

00:17:17,490 --> 00:17:24,540
rerender of our component and with

00:17:20,339 --> 00:17:26,400
setting the state we basically replace

00:17:24,540 --> 00:17:28,800
that we have in this nothing loading

00:17:26,400 --> 00:17:32,490
indicator with our async loaded

00:17:28,800 --> 00:17:35,130
component ret so and the run function

00:17:32,490 --> 00:17:39,600
will we will first see the nothing has

00:17:35,130 --> 00:17:42,270
loaded indicator and after the a sync

00:17:39,600 --> 00:17:45,360
component has been loaded it will be

00:17:42,270 --> 00:17:47,220
loaded afterwards like like after after

00:17:45,360 --> 00:17:48,220
the set state has been has been called

00:17:47,220 --> 00:17:51,100
and after

00:17:48,220 --> 00:17:54,780
after I did the app component has been

00:17:51,100 --> 00:17:57,840
rear-ended right so but what about

00:17:54,780 --> 00:18:00,430
loading multiple component at once and

00:17:57,840 --> 00:18:03,520
for this we have we can take advantage

00:18:00,430 --> 00:18:05,350
of promised at all and it's basically

00:18:03,520 --> 00:18:07,720
just the same thing like you would do

00:18:05,350 --> 00:18:09,880
with simple promises and in component

00:18:07,720 --> 00:18:11,890
didn't are we basically would call the

00:18:09,880 --> 00:18:15,250
promise promise at all and then pass an

00:18:11,890 --> 00:18:17,770
array of dynamic imports and then we set

00:18:15,250 --> 00:18:20,140
the state of components which is here an

00:18:17,770 --> 00:18:22,630
array and initially an empty array and

00:18:20,140 --> 00:18:26,770
after we have set it it's an array of

00:18:22,630 --> 00:18:30,310
the of promises and and then in render

00:18:26,770 --> 00:18:36,130
we simply map through the array and then

00:18:30,310 --> 00:18:37,900
and then render them right and you

00:18:36,130 --> 00:18:40,810
probably might be like are you kidding

00:18:37,900 --> 00:18:42,910
me this is not this is not three lines

00:18:40,810 --> 00:18:46,060
of extra code it is actually this is

00:18:42,910 --> 00:18:48,280
actually your your your you you screwed

00:18:46,060 --> 00:18:51,940
my component so it's going on here right

00:18:48,280 --> 00:18:54,340
and for this we have react loadable

00:18:51,940 --> 00:18:57,910
which will be able to cut these lines

00:18:54,340 --> 00:19:00,520
down into just a few lines and it's it's

00:18:57,910 --> 00:19:03,310
a higher-order component offered by the

00:19:00,520 --> 00:19:04,900
james kyle and it's it's basically

00:19:03,310 --> 00:19:08,710
taking all the complexities i just show

00:19:04,900 --> 00:19:10,600
it before and makes dynamic imports you

00:19:08,710 --> 00:19:13,750
mix using that making imports even

00:19:10,600 --> 00:19:17,650
easier so including a server-side render

00:19:13,750 --> 00:19:22,560
support here's a tiny comparison of a

00:19:17,650 --> 00:19:26,200
synchronous we're out and here we we

00:19:22,560 --> 00:19:28,360
simply passed a component with the

00:19:26,200 --> 00:19:32,820
component per up and if you want to it

00:19:28,360 --> 00:19:35,320
asynchronously we basically call our

00:19:32,820 --> 00:19:37,750
called loadable composer

00:19:35,320 --> 00:19:39,460
higher-order component and pass passed a

00:19:37,750 --> 00:19:39,970
bunch of options like here in this case

00:19:39,460 --> 00:19:42,430
loader

00:19:39,970 --> 00:19:45,400
with a function that returns the dynamic

00:19:42,430 --> 00:19:47,890
import and yeah i'm here loading

00:19:45,400 --> 00:19:49,870
indicator which is also again react and

00:19:47,890 --> 00:19:53,680
simply react element and what would what

00:19:49,870 --> 00:19:55,930
this would do is the example that i've

00:19:53,680 --> 00:19:57,049
shown before but only in three lines

00:19:55,930 --> 00:20:01,369
right

00:19:57,049 --> 00:20:04,960
and with this we will be able to replace

00:20:01,369 --> 00:20:08,029
in this with this we will be able to

00:20:04,960 --> 00:20:11,809
make our app up five times faster before

00:20:08,029 --> 00:20:15,559
than before and create reactive is a

00:20:11,809 --> 00:20:19,249
great way to start using using dynamic

00:20:15,559 --> 00:20:22,460
imports it supports this and also you'll

00:20:19,249 --> 00:20:25,369
be able to do this with react loadable

00:20:22,460 --> 00:20:28,940
it's it's it's 100% compatible with this

00:20:25,369 --> 00:20:31,759
and especially if you're new to react

00:20:28,940 --> 00:20:33,889
it's a great way to start actually so

00:20:31,759 --> 00:20:37,489
definitely worth consider using it if

00:20:33,889 --> 00:20:39,379
you start new projects or some of you

00:20:37,489 --> 00:20:41,299
might be like crate reactive is not an

00:20:39,379 --> 00:20:43,279
option and we need server-side rendering

00:20:41,299 --> 00:20:46,549
for app right and of course there must

00:20:43,279 --> 00:20:50,480
be something and I there's this

00:20:46,549 --> 00:20:53,539
resolution parts of crate react app but

00:20:50,480 --> 00:20:56,330
also does the parts on the server too so

00:20:53,539 --> 00:20:58,850
it has liked to webpack instances and I

00:20:56,330 --> 00:21:00,679
played with react loadable and made

00:20:58,850 --> 00:21:03,289
experiments with this so check this out

00:21:00,679 --> 00:21:04,759
this is basically razzle with react

00:21:03,289 --> 00:21:06,559
Louisville and has server-side rendering

00:21:04,759 --> 00:21:09,980
support with it and just work like

00:21:06,559 --> 00:21:12,649
create react app and also there is next

00:21:09,980 --> 00:21:15,259
GS which has code splitting and dynamic

00:21:12,649 --> 00:21:17,359
imports out of the box it has a very

00:21:15,259 --> 00:21:18,679
minimalistic API and renders your app

00:21:17,359 --> 00:21:23,059
complete on a server too and I guess

00:21:18,679 --> 00:21:23,779
agent that SH uses it right so yeah

00:21:23,059 --> 00:21:26,980
check this out

00:21:23,779 --> 00:21:30,350
game Ralph author out next to GS

00:21:26,980 --> 00:21:33,320
mentioned that sighted Co is built of it

00:21:30,350 --> 00:21:35,749
and uses hundreds of code splitting

00:21:33,320 --> 00:21:37,580
entry points and with this they have

00:21:35,749 --> 00:21:39,730
really speed up time from thousand

00:21:37,580 --> 00:21:46,700
milliseconds to down to 200 milliseconds

00:21:39,730 --> 00:21:48,859
which is pretty pretty awesome so when I

00:21:46,700 --> 00:21:51,919
started to dig deeper into this topic I

00:21:48,859 --> 00:21:54,799
saw so many guides on how to do and what

00:21:51,919 --> 00:21:57,739
it does but in reality what it where I

00:21:54,799 --> 00:21:59,299
was more interested in was how do I

00:21:57,739 --> 00:22:01,039
actually make it right how does the big

00:21:59,299 --> 00:22:03,499
player do it what are the common

00:22:01,039 --> 00:22:07,159
practices and how do I actually make my

00:22:03,499 --> 00:22:10,129
app even faster and I'd love to share an

00:22:07,159 --> 00:22:10,970
approach that works for me applying

00:22:10,129 --> 00:22:14,210
common practices

00:22:10,970 --> 00:22:17,870
and to strategically code split the

00:22:14,210 --> 00:22:19,880
entire application and the first besides

00:22:17,870 --> 00:22:21,770
dynamic imports may want to split your

00:22:19,880 --> 00:22:23,720
code your app code and been decoded that

00:22:21,770 --> 00:22:25,850
that I've explained you before to get

00:22:23,720 --> 00:22:29,809
the benefit of long-term caching as I've

00:22:25,850 --> 00:22:32,299
as I mentioned before to create one

00:22:29,809 --> 00:22:34,640
bundle for the vendors and another

00:22:32,299 --> 00:22:38,210
bundle for our frequently updating or

00:22:34,640 --> 00:22:39,710
for frequently updating app and if you

00:22:38,210 --> 00:22:42,470
want to read more about this here is a

00:22:39,710 --> 00:22:45,380
nice medium blog post by Tim Sebastian

00:22:42,470 --> 00:22:48,100
and he basically treats the problem with

00:22:45,380 --> 00:22:51,340
named chunks and named chunks IDs so

00:22:48,100 --> 00:22:51,340
check this out

00:22:51,590 --> 00:22:56,710
yeah the second is considered code

00:22:54,140 --> 00:22:59,179
splitting your code at the router level

00:22:56,710 --> 00:23:02,320
using dynamic imports this is basically

00:22:59,179 --> 00:23:06,159
what I've showed you the last 15 minutes

00:23:02,320 --> 00:23:09,110
everything every single line of code you

00:23:06,159 --> 00:23:13,220
of a page that you visit that typically

00:23:09,110 --> 00:23:15,679
belongs to to a page right so in general

00:23:13,220 --> 00:23:18,320
it's common practice to to split your

00:23:15,679 --> 00:23:20,360
code at the route entry points and even

00:23:18,320 --> 00:23:24,230
there might be code that can be shared

00:23:20,360 --> 00:23:26,299
so if you have if you have the case that

00:23:24,230 --> 00:23:29,360
you have like shared code between routes

00:23:26,299 --> 00:23:32,990
even even for this web peg has an

00:23:29,360 --> 00:23:35,870
awesome feature which is called epic

00:23:32,990 --> 00:23:38,320
chunk names and it's basically doing

00:23:35,870 --> 00:23:42,460
this import thing and then adding this

00:23:38,320 --> 00:23:45,409
weird comment in between and with this

00:23:42,460 --> 00:23:47,809
you'll be able to allow to organize and

00:23:45,409 --> 00:23:50,809
group multiple chunks of modules

00:23:47,809 --> 00:23:52,789
together and assign it with the same

00:23:50,809 --> 00:23:56,330
name and it's pretty neat if you

00:23:52,789 --> 00:23:58,730
especially if you want to to use shared

00:23:56,330 --> 00:24:02,090
code just for parts of the app all right

00:23:58,730 --> 00:24:05,179
and the third thing is after splitting

00:24:02,090 --> 00:24:07,520
vendor code with your app code and then

00:24:05,179 --> 00:24:10,340
further down speeding your your code at

00:24:07,520 --> 00:24:13,130
the router level consider splitting your

00:24:10,340 --> 00:24:16,880
your code further down that component

00:24:13,130 --> 00:24:19,309
level so what does this mean imagine you

00:24:16,880 --> 00:24:21,350
have this huge chart but imagine it's

00:24:19,309 --> 00:24:23,240
still not in this huge imagine it is

00:24:21,350 --> 00:24:23,920
somewhere not in the view not in the

00:24:23,240 --> 00:24:26,830
viewport

00:24:23,920 --> 00:24:29,440
and what you want is you want to load

00:24:26,830 --> 00:24:33,250
this chart as you scroll in so you you

00:24:29,440 --> 00:24:36,310
might want to lazy load this chart into

00:24:33,250 --> 00:24:38,920
the view and it's really really

00:24:36,310 --> 00:24:42,220
important it to do this especially for

00:24:38,920 --> 00:24:44,830
for bigger for bigger components for

00:24:42,220 --> 00:24:48,510
example like like chars that have that

00:24:44,830 --> 00:24:52,120
have but so so you don't wastefully

00:24:48,510 --> 00:24:55,090
loads something to the browser or you

00:24:52,120 --> 00:24:59,380
you you get you will be able to render

00:24:55,090 --> 00:25:01,030
things faster to the viewport by yeah by

00:24:59,380 --> 00:25:06,520
splitting by splitting them up component

00:25:01,030 --> 00:25:08,350
level so also we we should we should we

00:25:06,520 --> 00:25:10,420
shouldn't overuse dynamic splitting

00:25:08,350 --> 00:25:12,670
points since this can also have a

00:25:10,420 --> 00:25:16,120
negative effects so don't split

00:25:12,670 --> 00:25:20,050
everything but don't split definitely

00:25:16,120 --> 00:25:24,090
like big things that that are like where

00:25:20,050 --> 00:25:27,040
you feel you want to split them right so

00:25:24,090 --> 00:25:29,290
also try to predict what they use

00:25:27,040 --> 00:25:32,410
intends to do in your app and prefetch

00:25:29,290 --> 00:25:34,600
based on your user interaction so

00:25:32,410 --> 00:25:36,310
sometimes their use cases where most

00:25:34,600 --> 00:25:38,440
where people where users most most

00:25:36,310 --> 00:25:42,310
likely will click on certain things and

00:25:38,440 --> 00:25:45,370
therefore you can prefetch the chunks so

00:25:42,310 --> 00:25:47,590
that the coded is already there and

00:25:45,370 --> 00:25:52,030
prepared for for the user to be

00:25:47,590 --> 00:25:53,950
displayed and react pyramid is actually

00:25:52,030 --> 00:25:55,630
a great tool for this that can be used

00:25:53,950 --> 00:25:58,330
for prefetching data based on mouse

00:25:55,630 --> 00:26:00,100
behavior and with this you can define

00:25:58,330 --> 00:26:04,180
for example like imagine you have a

00:26:00,100 --> 00:26:07,420
component and then you add then you have

00:26:04,180 --> 00:26:10,000
like a parameter like like an area where

00:26:07,420 --> 00:26:13,090
where your mouse reach in and then and

00:26:10,000 --> 00:26:15,070
then you load everything for the next

00:26:13,090 --> 00:26:19,060
route for example by calling a function

00:26:15,070 --> 00:26:21,220
so it looks like this imagine your your

00:26:19,060 --> 00:26:23,920
your mouse is here and then as you move

00:26:21,220 --> 00:26:26,170
here you know now the chunks that that

00:26:23,920 --> 00:26:28,480
you are about to to visit to the next

00:26:26,170 --> 00:26:30,670
route for example and then it's loaded

00:26:28,480 --> 00:26:34,090
and then in it's loaded before you click

00:26:30,670 --> 00:26:35,770
or the button right and this is how the

00:26:34,090 --> 00:26:37,570
syntax would look like and it's very

00:26:35,770 --> 00:26:39,670
simple

00:26:37,570 --> 00:26:43,150
you have here a parameter parameter

00:26:39,670 --> 00:26:45,340
element and here the button as a child

00:26:43,150 --> 00:26:50,080
and here in the arm bridge to basically

00:26:45,340 --> 00:26:51,880
define your your own sense and when you

00:26:50,080 --> 00:26:54,010
when you click or when you when you

00:26:51,880 --> 00:26:55,060
breach the gray area that I've shown you

00:26:54,010 --> 00:26:57,490
before and this is actually their

00:26:55,060 --> 00:27:00,130
padding that can be set with react

00:26:57,490 --> 00:27:03,220
parameter so it's great thing to yeah to

00:27:00,130 --> 00:27:05,590
do prefetching as well so to sum up

00:27:03,220 --> 00:27:08,170
where code split split up and vendor

00:27:05,590 --> 00:27:10,480
code for long time caching split at

00:27:08,170 --> 00:27:12,490
route level as synchronously to load

00:27:10,480 --> 00:27:15,490
only the code that is needed for the

00:27:12,490 --> 00:27:18,580
page and also split a component level to

00:27:15,490 --> 00:27:22,530
lazily load parts of the page as the

00:27:18,580 --> 00:27:25,840
user Scrolls in or as the user interacts

00:27:22,530 --> 00:27:27,720
these are the nice good reads if you're

00:27:25,840 --> 00:27:30,970
interested in cultivating benchmarks and

00:27:27,720 --> 00:27:35,080
loading loading performance definitely

00:27:30,970 --> 00:27:35,770
check them out and the recap dynamic

00:27:35,080 --> 00:27:39,220
imports

00:27:35,770 --> 00:27:42,970
it's a tc39 proposal with babel you can

00:27:39,220 --> 00:27:44,140
use it now don't load useless code by

00:27:42,970 --> 00:27:46,630
splitting your codes with dynamic

00:27:44,140 --> 00:27:50,710
imports depending on the project size we

00:27:46,630 --> 00:27:53,890
will be able to reduce the page load up

00:27:50,710 --> 00:27:56,590
to five times first splits app and

00:27:53,890 --> 00:27:59,470
vendor codes and then at route level and

00:27:56,590 --> 00:28:01,840
a component level create react app and

00:27:59,470 --> 00:28:03,100
next is I'll clue is to start also check

00:28:01,840 --> 00:28:06,820
out this rattle experiment I've shown

00:28:03,100 --> 00:28:08,500
you before and also note that the idea

00:28:06,820 --> 00:28:11,320
can be applied to any frame it's not

00:28:08,500 --> 00:28:12,970
just react so yeah that's basically it

00:28:11,320 --> 00:28:15,430
if you're interested to talk more about

00:28:12,970 --> 00:28:18,040
code splitting that's definitely talk to

00:28:15,430 --> 00:28:20,650
talk to me and yeah also you can ping me

00:28:18,040 --> 00:28:22,080
on Twitter if you if you want so thanks

00:28:20,650 --> 00:28:26,140
very much

00:28:22,080 --> 00:28:26,140

YouTube URL: https://www.youtube.com/watch?v=iSit-m6kjFI


