Title: ViennaJS, Functional Javascript with Monads, February 2018
Publication date: 2018-03-02
Playlist: viennaJS
Description: 
	Speaker: Oleksandr tryshchenko
Captions: 
	00:00:00,030 --> 00:00:05,879
heroin guys I hope you are ready my name

00:00:03,540 --> 00:00:08,160
is Alex I'm originally from Ukraine I

00:00:05,879 --> 00:00:10,320
moved to bones half a year ago it's very

00:00:08,160 --> 00:00:14,630
long story how I got here speaking here

00:00:10,320 --> 00:00:16,859
and I'm working in data art it's a big

00:00:14,630 --> 00:00:18,960
outsourcing company we have more than 20

00:00:16,859 --> 00:00:23,760
offices and eight countries I believe

00:00:18,960 --> 00:00:26,699
and you can find me on using my website

00:00:23,760 --> 00:00:28,980
and also because product names and

00:00:26,699 --> 00:00:31,230
surnames are complicated take awaited a

00:00:28,980 --> 00:00:36,540
mirror just with links to my social

00:00:31,230 --> 00:00:40,500
networks so first of all I will say some

00:00:36,540 --> 00:00:42,840
sad things just to make sure we are on

00:00:40,500 --> 00:00:46,680
the same page that functional

00:00:42,840 --> 00:00:49,550
programming isn't something new it it is

00:00:46,680 --> 00:00:52,530
older than many of us here actually and

00:00:49,550 --> 00:00:56,340
moreover your students use it just

00:00:52,530 --> 00:00:58,770
because it's trendy so I will try to

00:00:56,340 --> 00:01:02,579
give some skeptical talk about benefits

00:00:58,770 --> 00:01:05,070
and ministers of Technology and I will

00:01:02,579 --> 00:01:08,549
share my experience after half a year of

00:01:05,070 --> 00:01:11,880
using monads intensively on on a project

00:01:08,549 --> 00:01:14,909
so yes probably you can disagree with

00:01:11,880 --> 00:01:18,840
those two points but I hope is not a

00:01:14,909 --> 00:01:23,159
problem so I will talk about Mona's

00:01:18,840 --> 00:01:25,259
monarchs are actually instruments which

00:01:23,159 --> 00:01:30,150
are not something specific for

00:01:25,259 --> 00:01:33,869
JavaScript monarchs like its Universal

00:01:30,150 --> 00:01:38,579
approach and there is a stereotype

00:01:33,869 --> 00:01:42,479
that's monads how to say aren't debts

00:01:38,579 --> 00:01:47,869
very useful you know and it can be

00:01:42,479 --> 00:01:51,000
iterated with this picture and yes okay

00:01:47,869 --> 00:01:53,369
why can we need and why do we need

00:01:51,000 --> 00:01:55,950
Mona's actually we need them for

00:01:53,369 --> 00:01:58,799
functional programming we can use them

00:01:55,950 --> 00:02:00,149
for reactive programming you might say

00:01:58,799 --> 00:02:05,670
that it's reactive program in its

00:02:00,149 --> 00:02:10,050
functional program and no and okay today

00:02:05,670 --> 00:02:12,769
I'll talk about numbers how to add two

00:02:10,050 --> 00:02:15,659
numbers with JavaScript obviously

00:02:12,769 --> 00:02:18,900
okay but you know it's very old-school

00:02:15,659 --> 00:02:21,000
brush everyone can do so and I want to

00:02:18,900 --> 00:02:23,359
provide some really cool contemporary

00:02:21,000 --> 00:02:27,959
code so I can do it like this with

00:02:23,359 --> 00:02:31,019
current functions with aramta but well

00:02:27,959 --> 00:02:34,349
it's better but it's it's still not that

00:02:31,019 --> 00:02:36,599
perfect as I expected it to be these

00:02:34,349 --> 00:02:39,150
models we can do something like this we

00:02:36,599 --> 00:02:42,650
can split it in several sprints between

00:02:39,150 --> 00:02:45,569
several developers and arrange our KU

00:02:42,650 --> 00:02:47,370
enterprise process so I guess it is

00:02:45,569 --> 00:02:51,659
perfection

00:02:47,370 --> 00:02:55,169
actually I do this right is to give the

00:02:51,659 --> 00:03:00,090
idea that using some technologies

00:02:55,169 --> 00:03:04,829
everywhere regardless are they useful or

00:03:00,090 --> 00:03:08,900
not it's not the best idea and yes guys

00:03:04,829 --> 00:03:14,040
please don't over complicate things so I

00:03:08,900 --> 00:03:16,919
guess we already originally in object

00:03:14,040 --> 00:03:20,459
oriented approach we have a pretty basic

00:03:16,919 --> 00:03:23,669
example how does the organization of

00:03:20,459 --> 00:03:26,280
code works like we have some objects we

00:03:23,669 --> 00:03:29,489
can call some methods on it they mutate

00:03:26,280 --> 00:03:31,829
something inside the subject and in the

00:03:29,489 --> 00:03:35,819
end and then we can do something with

00:03:31,829 --> 00:03:37,889
all this data we managed inside and it

00:03:35,819 --> 00:03:41,400
is pretty much good for a functional

00:03:37,889 --> 00:03:42,720
approach it works well in functional

00:03:41,400 --> 00:03:45,629
programming it works a little bit

00:03:42,720 --> 00:03:49,340
differently so functional programming is

00:03:45,629 --> 00:03:52,769
about functions function composition and

00:03:49,340 --> 00:03:54,840
the idea of minutes to try to make

00:03:52,769 --> 00:03:59,069
something like this and here we have

00:03:54,840 --> 00:04:01,049
just three levels of functions but we

00:03:59,069 --> 00:04:06,299
can have much much more and idea to make

00:04:01,049 --> 00:04:09,810
something like this and of course I

00:04:06,299 --> 00:04:12,930
wanted to notice that a B and C are pure

00:04:09,810 --> 00:04:15,569
functions so just shortly they don't

00:04:12,930 --> 00:04:22,370
access outer scope don't read don't

00:04:15,569 --> 00:04:25,860
write and they don't mutate arguments so

00:04:22,370 --> 00:04:27,330
using functional approach that example

00:04:25,860 --> 00:04:31,560
from functional programming will work

00:04:27,330 --> 00:04:34,439
like this one which isn't dead booth in

00:04:31,560 --> 00:04:37,500
my opinion however is much better then

00:04:34,439 --> 00:04:43,050
we call all those matters one inside

00:04:37,500 --> 00:04:45,750
each other so monitor they are about

00:04:43,050 --> 00:04:48,870
function composition and when it comes

00:04:45,750 --> 00:04:52,680
to JavaScript it's the main problem they

00:04:48,870 --> 00:04:55,650
so we don't have problems with strict

00:04:52,680 --> 00:04:58,520
typing and for us it's just about

00:04:55,650 --> 00:05:04,379
function composition I'm sorry in two

00:04:58,520 --> 00:05:07,590
ways course or somewhere so known as

00:05:04,379 --> 00:05:10,650
pattern it's pretty much simple thing

00:05:07,590 --> 00:05:14,699
you can read its definition from

00:05:10,650 --> 00:05:16,889
Wikipedia and but I hope that you know

00:05:14,699 --> 00:05:20,610
when I first seen that I haven't

00:05:16,889 --> 00:05:22,770
understood what what is it about when

00:05:20,610 --> 00:05:25,590
someone talks about some features

00:05:22,770 --> 00:05:29,099
usually you have some exception

00:05:25,590 --> 00:05:30,870
like for example hi we got a sink of

00:05:29,099 --> 00:05:33,419
eight Wow it's freaking amazing

00:05:30,870 --> 00:05:36,029
I don't know we go through octave fix

00:05:33,419 --> 00:05:38,550
it's cool we can use it and when you are

00:05:36,029 --> 00:05:41,449
talking about technologies usually some

00:05:38,550 --> 00:05:44,750
cool features have pretty simple

00:05:41,449 --> 00:05:47,909
definition what they do but not this and

00:05:44,750 --> 00:05:49,379
I decided to go deeper and find some

00:05:47,909 --> 00:05:55,529
short definition that looks like this

00:05:49,379 --> 00:05:59,219
and he'll not still he'll noticed it's

00:05:55,529 --> 00:06:02,069
still not clear and event of our May

00:05:59,219 --> 00:06:06,360
talks in YouTube and some of them are

00:06:02,069 --> 00:06:09,779
pretty good however they go in too deep

00:06:06,360 --> 00:06:13,789
in my opinion and idea if I'm staying

00:06:09,779 --> 00:06:16,650
here is to give this idea as simple as

00:06:13,789 --> 00:06:19,349
possible at least I'll try to and

00:06:16,650 --> 00:06:25,009
already like this movie and everybody's

00:06:19,349 --> 00:06:29,129
code so zero month ago my wife

00:06:25,009 --> 00:06:32,099
demonstrated made this video like here

00:06:29,129 --> 00:06:37,319
is good guy and he can recognize various

00:06:32,099 --> 00:06:39,220
bow inside and I got holy I can use

00:06:37,319 --> 00:06:42,520
it to explain monads

00:06:39,220 --> 00:06:45,040
and I went to our workers took a camera

00:06:42,520 --> 00:06:48,760
and made several photos so ever

00:06:45,040 --> 00:06:52,990
demonstrated in pictures so we have a

00:06:48,760 --> 00:06:58,450
value is just a variable and it is to

00:06:52,990 --> 00:07:02,380
nothing more they have something box and

00:06:58,450 --> 00:07:06,070
we place this variable inside the box it

00:07:02,380 --> 00:07:11,860
has move in our example it is a ma not

00:07:06,070 --> 00:07:13,090
now and process when we placed a value

00:07:11,860 --> 00:07:16,570
inside the box

00:07:13,090 --> 00:07:19,060
it's called from its unit function which

00:07:16,570 --> 00:07:22,480
takes a value and places it inside the

00:07:19,060 --> 00:07:25,150
monitor let's make it a little bit more

00:07:22,480 --> 00:07:30,040
complicated we have several values like

00:07:25,150 --> 00:07:32,919
this number and this candy and okay

00:07:30,040 --> 00:07:36,370
candy don't have a number it's cast only

00:07:32,919 --> 00:07:40,380
called color and here we have also color

00:07:36,370 --> 00:07:44,620
and value and the idea is to handle

00:07:40,380 --> 00:07:47,950
those two objects regardless what they

00:07:44,620 --> 00:07:52,140
have inside and regardless was what type

00:07:47,950 --> 00:07:56,590
of it so let's place those two values

00:07:52,140 --> 00:07:58,990
inside the boxes and to make it even

00:07:56,590 --> 00:08:01,300
more complicated we'll assume that we

00:07:58,990 --> 00:08:06,610
have three values but one is empty it is

00:08:01,300 --> 00:08:09,729
undefined so we have to Ramona's and the

00:08:06,610 --> 00:08:12,550
idea is that we can apply any function

00:08:09,729 --> 00:08:16,990
to them and make sure that it will work

00:08:12,550 --> 00:08:19,000
safely it won't break it won't straw any

00:08:16,990 --> 00:08:20,979
exception because we have some

00:08:19,000 --> 00:08:24,160
unexpected datatype or something like

00:08:20,979 --> 00:08:27,729
that and yes we have three Mona's and

00:08:24,160 --> 00:08:31,720
okay let's first apply a function which

00:08:27,729 --> 00:08:37,780
Mike will make all of them green okay we

00:08:31,720 --> 00:08:41,800
applied its coats map mapping and we can

00:08:37,780 --> 00:08:44,200
map any moment as an array however it

00:08:41,800 --> 00:08:45,900
will apply like for the whole value

00:08:44,200 --> 00:08:48,580
inside the monitor

00:08:45,900 --> 00:08:51,010
okay we are added we still don't know

00:08:48,580 --> 00:08:53,040
what is inside and we shouldn't care

00:08:51,010 --> 00:08:56,339
about it so they can take an hour

00:08:53,040 --> 00:09:00,630
method and apply it again and as you can

00:08:56,339 --> 00:09:03,630
remind we don't have value number value

00:09:00,630 --> 00:09:05,399
inside the candy but it doesn't matter

00:09:03,630 --> 00:09:08,519
it will work anyway

00:09:05,399 --> 00:09:11,130
it won't draw any exception so we are

00:09:08,519 --> 00:09:15,839
quiet those two methods to all m units

00:09:11,130 --> 00:09:19,110
and okay we can uncover them so we got

00:09:15,839 --> 00:09:23,250
four and green sticker instead of pink

00:09:19,110 --> 00:09:26,810
one this process is called flatten the

00:09:23,250 --> 00:09:30,509
process when we uncover some Monat and

00:09:26,810 --> 00:09:32,819
get some value you can merge the process

00:09:30,509 --> 00:09:34,709
of mapping this flattening

00:09:32,819 --> 00:09:38,009
it's called front map we'll go a little

00:09:34,709 --> 00:09:41,850
bit further about flat maps however a

00:09:38,009 --> 00:09:44,519
hope idea is quite simple so let's

00:09:41,850 --> 00:09:47,009
uncover the second value it is a candy

00:09:44,519 --> 00:09:51,329
it became green but we don't have any

00:09:47,009 --> 00:09:53,370
color here so mana just executed the

00:09:51,329 --> 00:09:56,880
first methods and validated that we

00:09:53,370 --> 00:09:58,709
don't have a number here and well we

00:09:56,880 --> 00:10:04,170
don't have any errors but we have

00:09:58,709 --> 00:10:08,730
modified candy so what we got outside so

00:10:04,170 --> 00:10:11,519
we got cover we got some value and for

00:10:08,730 --> 00:10:14,430
empty box we still have nothing we don't

00:10:11,519 --> 00:10:17,240
got we haven't got any errors swag oh

00:10:14,430 --> 00:10:20,720
man you're trying to access some

00:10:17,240 --> 00:10:24,540
property of undefined you can do it no

00:10:20,720 --> 00:10:27,660
any problems so it's type agnostic and

00:10:24,540 --> 00:10:31,370
it's safe however it relies on you to

00:10:27,660 --> 00:10:34,019
write save metals we should use as maps

00:10:31,370 --> 00:10:36,510
so let's go a little bit further by

00:10:34,019 --> 00:10:38,850
definition monad can be described with

00:10:36,510 --> 00:10:42,959
this interface so it has some value

00:10:38,850 --> 00:10:46,050
inside candy or sticker it has some

00:10:42,959 --> 00:10:49,470
value which will place our value into

00:10:46,050 --> 00:10:52,470
the cup it has some flat map which will

00:10:49,470 --> 00:10:55,290
apply some function and return well go

00:10:52,470 --> 00:10:57,569
forward value or you can create a new

00:10:55,290 --> 00:11:00,930
Monat inside that method you can map any

00:10:57,569 --> 00:11:03,449
function you have and you can just

00:11:00,930 --> 00:11:06,570
extract the value outside using water

00:11:03,449 --> 00:11:10,950
method so again

00:11:06,570 --> 00:11:13,620
we are placing value into the box pretty

00:11:10,950 --> 00:11:20,460
much simple map we are doing something

00:11:13,620 --> 00:11:25,830
without taking value outside the box so

00:11:20,460 --> 00:11:29,040
we have what it does it gives us a point

00:11:25,830 --> 00:11:32,400
one plane a value we return a pole and

00:11:29,040 --> 00:11:36,990
value but our mana takes it's a pneumo

00:11:32,400 --> 00:11:38,630
not again instead of failure and it's

00:11:36,990 --> 00:11:40,830
called differently in different

00:11:38,630 --> 00:11:42,990
implementations actually bought by and

00:11:40,830 --> 00:11:47,370
chained wet map it's actually the same

00:11:42,990 --> 00:11:50,070
and okay it means that we got some value

00:11:47,370 --> 00:11:52,080
and modified it and afterwards we decide

00:11:50,070 --> 00:11:55,680
we will return a point value and we will

00:11:52,080 --> 00:11:56,640
return a new monitor instead so it looks

00:11:55,680 --> 00:11:58,500
like something exists

00:11:56,640 --> 00:12:02,190
sorry for capita waste waste waters here

00:11:58,500 --> 00:12:10,290
and waton it's just extraction of value

00:12:02,190 --> 00:12:12,600
outside the box so about flat map it's

00:12:10,290 --> 00:12:15,540
not only about extraction the values

00:12:12,600 --> 00:12:17,940
outside the box and making some changes

00:12:15,540 --> 00:12:21,960
with them it's also about structure a

00:12:17,940 --> 00:12:24,870
little bit for example we have something

00:12:21,960 --> 00:12:28,920
like this let's just array with three

00:12:24,870 --> 00:12:31,740
numbers inside and we will map a

00:12:28,920 --> 00:12:34,760
function it's not like any mo not map

00:12:31,740 --> 00:12:37,320
it's just rig or map on or a very boy

00:12:34,760 --> 00:12:40,530
some function which will return a new

00:12:37,320 --> 00:12:44,790
array for each of those values and if

00:12:40,530 --> 00:12:48,660
you return number source number x 2 and

00:12:44,790 --> 00:12:52,860
x 10 so they got something like this

00:12:48,660 --> 00:12:57,080
here and this flat map we can actually

00:12:52,860 --> 00:13:03,090
make this structure wet so obviously wet

00:12:57,080 --> 00:13:06,840
and it also helpful when it comes to

00:13:03,090 --> 00:13:08,850
real usage of Mona's also several words

00:13:06,840 --> 00:13:12,810
a bit earlier about each a little bit

00:13:08,850 --> 00:13:15,300
later and yes it's all about

00:13:12,810 --> 00:13:18,780
infrastructure around because you know

00:13:15,300 --> 00:13:19,590
it looks cool however it doesn't make

00:13:18,780 --> 00:13:21,420
sense for

00:13:19,590 --> 00:13:24,930
to numbers it still doesn't make any

00:13:21,420 --> 00:13:27,810
sense parade in two numbers so it's too

00:13:24,930 --> 00:13:30,000
useful because of infrastructure which

00:13:27,810 --> 00:13:33,090
different why Burris provides us

00:13:30,000 --> 00:13:36,980
I'm personally using several ones first

00:13:33,090 --> 00:13:43,410
one is Monat it's a point why brief for

00:13:36,980 --> 00:13:46,110
just Mona's it allows you to it has some

00:13:43,410 --> 00:13:48,630
unique functions here unit does not

00:13:46,110 --> 00:13:52,800
validate anything you draw inside here

00:13:48,630 --> 00:13:56,010
you can do some great Mona's from some

00:13:52,800 --> 00:13:58,890
specific data types like some it will do

00:13:56,010 --> 00:14:01,200
something like we did on the pictures it

00:13:58,890 --> 00:14:03,510
will create a mana from empty values or

00:14:01,200 --> 00:14:06,660
any different values regard to as the

00:14:03,510 --> 00:14:09,029
type we have we can create none from no

00:14:06,660 --> 00:14:11,610
it's useful when we are using flat Maps

00:14:09,029 --> 00:14:14,940
if we want to return any you mana

00:14:11,610 --> 00:14:16,560
instead of old one we can use either if

00:14:14,940 --> 00:14:23,460
we're working with several Mona's or

00:14:16,560 --> 00:14:27,690
least I guess either at least familiar

00:14:23,460 --> 00:14:29,730
for some of you and also they'll get

00:14:27,690 --> 00:14:31,770
there a little bit waiter for example we

00:14:29,730 --> 00:14:34,500
can map a new value here is just the

00:14:31,770 --> 00:14:37,110
syntax of the Webber amusing so we

00:14:34,500 --> 00:14:40,050
created a memo not out of number five we

00:14:37,110 --> 00:14:42,210
can map any function to its and extract

00:14:40,050 --> 00:14:43,800
the value outside it's just for

00:14:42,210 --> 00:14:45,690
demonstration actually into a wife a

00:14:43,800 --> 00:14:49,620
doesn't make any real sense however we

00:14:45,690 --> 00:14:53,430
added one to five using Mona's it looks

00:14:49,620 --> 00:14:55,790
like this one there are actually many

00:14:53,430 --> 00:14:58,320
things which monitor provides you and

00:14:55,790 --> 00:15:02,310
for example you can do some filtering

00:14:58,320 --> 00:15:06,600
like you're doing on arrays however it

00:15:02,310 --> 00:15:08,850
won't filter anything inside the monit

00:15:06,600 --> 00:15:13,470
it will validate the value it's like

00:15:08,850 --> 00:15:16,260
some conditional validation like instead

00:15:13,470 --> 00:15:19,589
of writing Eve etc etc you can use

00:15:16,260 --> 00:15:21,240
filter and it suits functional style a

00:15:19,589 --> 00:15:24,180
little bit more so we can do something

00:15:21,240 --> 00:15:26,580
like this and we have the same six we

00:15:24,180 --> 00:15:29,520
had before on the previous white and I

00:15:26,580 --> 00:15:31,990
filter ease and function validates is

00:15:29,520 --> 00:15:34,330
the number began the bigger than ten

00:15:31,990 --> 00:15:36,370
and returns what we have inside

00:15:34,330 --> 00:15:40,330
regardless the type and we have now

00:15:36,370 --> 00:15:44,230
instead of 6 because 6 has not validated

00:15:40,330 --> 00:15:46,510
through the head here or for example we

00:15:44,230 --> 00:15:49,480
can specify the default value it is the

00:15:46,510 --> 00:15:53,080
same example we had here so here we had

00:15:49,480 --> 00:15:56,290
now well here we can specify that if our

00:15:53,080 --> 00:15:58,930
value does not suit the condition we can

00:15:56,290 --> 00:16:01,450
return some default value ends here it

00:15:58,930 --> 00:16:06,610
starts making some sense but not always

00:16:01,450 --> 00:16:08,290
and here is some some example what we

00:16:06,610 --> 00:16:13,089
can do inside wait we have some function

00:16:08,290 --> 00:16:16,600
each what validates the number it's

00:16:13,089 --> 00:16:19,750
bigger than 0 and if it is it returns as

00:16:16,600 --> 00:16:22,690
a new-mown 'it is the same value or we

00:16:19,750 --> 00:16:25,149
can return Amanat which is empty is just

00:16:22,690 --> 00:16:27,130
a demonstration what is happening under

00:16:25,149 --> 00:16:30,040
the hood or filters so you can write it

00:16:27,130 --> 00:16:34,660
on your own to some flat map and see

00:16:30,040 --> 00:16:37,390
you'll get the same result and one truly

00:16:34,660 --> 00:16:39,100
makes sense it's in situations but when

00:16:37,390 --> 00:16:41,410
you're working with unpredictable data

00:16:39,100 --> 00:16:43,470
sources for example it might be some

00:16:41,410 --> 00:16:46,230
third party API if you are working with

00:16:43,470 --> 00:16:50,440
backends it might be API of your server

00:16:46,230 --> 00:16:53,350
if it's not predictable or it might be

00:16:50,440 --> 00:16:56,410
some user input in such cases it really

00:16:53,350 --> 00:17:00,520
cool for for validation it it's really

00:16:56,410 --> 00:17:03,430
reasonable it saves amount of code you

00:17:00,520 --> 00:17:05,709
write in and here you can see just a

00:17:03,430 --> 00:17:08,319
crate am honored out with some

00:17:05,709 --> 00:17:10,780
properties like address name there might

00:17:08,319 --> 00:17:15,130
be many many fields and I just specified

00:17:10,780 --> 00:17:18,760
the set of rules how I can handle every

00:17:15,130 --> 00:17:22,900
parameter I have there so for those

00:17:18,760 --> 00:17:25,839
tasks it's really useful and there is

00:17:22,900 --> 00:17:28,179
one example I have taken it for the ends

00:17:25,839 --> 00:17:30,840
please raise your hands guys who used

00:17:28,179 --> 00:17:30,840
rigs Jess

00:17:31,260 --> 00:17:37,840
congratuations used moments because

00:17:33,690 --> 00:17:40,450
erect jess is actually kinetic data

00:17:37,840 --> 00:17:42,640
structure you can do map with me upon

00:17:40,450 --> 00:17:44,140
them and they provide you a lot of

00:17:42,640 --> 00:17:48,970
different

00:17:44,140 --> 00:17:51,190
stop wish you can do this observables

00:17:48,970 --> 00:17:56,170
I mean observables are monadic totally

00:17:51,190 --> 00:17:58,210
melodic in rxjs however from the big

00:17:56,170 --> 00:18:01,620
specification you have there like more

00:17:58,210 --> 00:18:05,860
than 100 methods by oboe in there exist

00:18:01,620 --> 00:18:08,040
most of them are about such patterns

00:18:05,860 --> 00:18:10,780
called appliqué defunct or it's about

00:18:08,040 --> 00:18:12,820
interacting between several monads in

00:18:10,780 --> 00:18:15,520
the very beginning and I present that

00:18:12,820 --> 00:18:17,890
you example how to add numbers and it

00:18:15,520 --> 00:18:20,380
used the same patterns so it's more

00:18:17,890 --> 00:18:22,480
about how you interact between your

00:18:20,380 --> 00:18:24,640
observables you got several syllables

00:18:22,480 --> 00:18:27,400
you want to unite them or you wanna wake

00:18:24,640 --> 00:18:31,120
Hilter the way test results it's about

00:18:27,400 --> 00:18:34,090
that pattern and actually it's pretty

00:18:31,120 --> 00:18:37,000
much eat it alike to us answer any

00:18:34,090 --> 00:18:40,140
questions you have and why I'm answering

00:18:37,000 --> 00:18:40,140
feel free to reach me anywhere

00:18:41,090 --> 00:18:45,740

YouTube URL: https://www.youtube.com/watch?v=K_Uw4-Sv-lc


