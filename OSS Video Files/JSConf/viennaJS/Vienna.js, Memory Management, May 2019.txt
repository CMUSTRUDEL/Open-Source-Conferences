Title: Vienna.js, Memory Management, May 2019
Publication date: 2019-06-13
Playlist: viennaJS
Description: 
	Talk By Rainer Hahnekamp:

As JavaScript developers we don't have to care how our application "gets" memory and releases it. We are in the luxurious position that the engine does that automatically and shields us from all challenges that can occur. For a professional developer, this is not an excuse to ignore this important topic. In my talk, I will cover the very basics of memory management. We will start with the theory in general, watch JavaScript's memory management in action and learn about patterns that can cause the feared memory leaks. We will finish with an overview of the most important component: Garbage Collectors.
Captions: 
	00:00:00,089 --> 00:00:05,400
my software engineer and I want to spend

00:00:02,610 --> 00:00:08,429
the next 20 minutes to talk about memory

00:00:05,400 --> 00:00:11,130
management so my talk consists of four

00:00:08,429 --> 00:00:13,650
parts I will start with the general

00:00:11,130 --> 00:00:16,230
theory that does not only apply to

00:00:13,650 --> 00:00:20,250
JavaScript but also to other languages

00:00:16,230 --> 00:00:21,869
like Java Python or even see at least a

00:00:20,250 --> 00:00:24,840
little bit

00:00:21,869 --> 00:00:27,599
the next part in the next part we will

00:00:24,840 --> 00:00:30,810
see how we can use the Google dev tools

00:00:27,599 --> 00:00:33,780
to see how the memory management works

00:00:30,810 --> 00:00:36,420
in action and then we will learn about

00:00:33,780 --> 00:00:39,270
some patterns that can cause problems

00:00:36,420 --> 00:00:41,280
with memory management and here I will

00:00:39,270 --> 00:00:44,610
speak especially about the memory leaks

00:00:41,280 --> 00:00:49,890
and in the end I will explain a little

00:00:44,610 --> 00:00:54,360
bit how the garbage collector works good

00:00:49,890 --> 00:00:57,539
so as you can see I have your JavaScript

00:00:54,360 --> 00:01:00,870
object that stores two properties and if

00:00:57,539 --> 00:01:03,090
I want to access this property some time

00:01:00,870 --> 00:01:06,240
later I need to store it somewhere and

00:01:03,090 --> 00:01:09,360
that somewhere is usually the main

00:01:06,240 --> 00:01:12,030
memory but this is just a very

00:01:09,360 --> 00:01:16,170
simplified image a more realistic

00:01:12,030 --> 00:01:18,720
version might look like this as we know

00:01:16,170 --> 00:01:21,540
in JavaScript we don't have any commands

00:01:18,720 --> 00:01:23,400
to store the data into the memory but

00:01:21,540 --> 00:01:26,759
this does not mean that it is not

00:01:23,400 --> 00:01:29,700
required and the thing that is

00:01:26,759 --> 00:01:32,400
responsible for for the storing is the

00:01:29,700 --> 00:01:35,790
engine because as we know the our

00:01:32,400 --> 00:01:37,829
JavaScript code is run by an engine but

00:01:35,790 --> 00:01:40,530
the engine it does not have direct

00:01:37,829 --> 00:01:43,079
access to the hardware itself only the

00:01:40,530 --> 00:01:45,149
operating system does this and what the

00:01:43,079 --> 00:01:48,329
operating system now provides to a

00:01:45,149 --> 00:01:50,310
process or also to the engine it

00:01:48,329 --> 00:01:54,540
provides something that we call virtual

00:01:50,310 --> 00:01:57,750
memory and the applications can put

00:01:54,540 --> 00:02:00,390
their data inside or into the virtual

00:01:57,750 --> 00:02:03,030
memory and the operating system will map

00:02:00,390 --> 00:02:07,229
the data from the virtual memory to the

00:02:03,030 --> 00:02:09,300
actual Hardware now in order to

00:02:07,229 --> 00:02:11,459
structure the data that is inside of

00:02:09,300 --> 00:02:12,730
this virtual memory we have to use data

00:02:11,459 --> 00:02:15,190
structures

00:02:12,730 --> 00:02:19,390
and there are two major data structures

00:02:15,190 --> 00:02:22,239
the first one is the stack and the stack

00:02:19,390 --> 00:02:24,849
is also called the static static memory

00:02:22,239 --> 00:02:27,370
allocation and the stack comes with a

00:02:24,849 --> 00:02:30,099
constraint because with a when we want

00:02:27,370 --> 00:02:32,530
to use stack as data structure we have

00:02:30,099 --> 00:02:34,870
to know in advance how much memory a

00:02:32,530 --> 00:02:36,730
function will require and this also

00:02:34,870 --> 00:02:39,489
includes all the variables that it will

00:02:36,730 --> 00:02:43,209
create and what the stack does that it

00:02:39,489 --> 00:02:45,190
will allocate memory space when the

00:02:43,209 --> 00:02:47,500
function starts to run and when the

00:02:45,190 --> 00:02:50,709
function exits it will remove all that

00:02:47,500 --> 00:02:53,079
memory now this is a kind of a problem

00:02:50,709 --> 00:02:55,569
for JavaScript because in JavaScript we

00:02:53,079 --> 00:02:58,390
don't know in advance how much memory

00:02:55,569 --> 00:03:00,430
our function will require and of course

00:02:58,390 --> 00:03:02,829
we also don't want that everything is

00:03:00,430 --> 00:03:05,049
removed once the function exits because

00:03:02,829 --> 00:03:07,150
we can have some objects that we want to

00:03:05,049 --> 00:03:09,280
have returned and that we want to

00:03:07,150 --> 00:03:12,310
continue to work even when the function

00:03:09,280 --> 00:03:16,060
has already exited and that's why in

00:03:12,310 --> 00:03:18,849
JavaScript me more or less everything

00:03:16,060 --> 00:03:21,280
not really but the major things are

00:03:18,849 --> 00:03:24,519
stored in the second data structure that

00:03:21,280 --> 00:03:27,579
is also known as heap now the problem

00:03:24,519 --> 00:03:29,889
with the heap is that the heap does not

00:03:27,579 --> 00:03:32,470
automatically remove the memory this is

00:03:29,889 --> 00:03:34,060
something that we have to do and since

00:03:32,470 --> 00:03:36,459
again we don't have any commands in

00:03:34,060 --> 00:03:38,919
JavaScript to remove memory it falls

00:03:36,459 --> 00:03:41,500
again into the responsibility of the

00:03:38,919 --> 00:03:44,079
engine and the part of the engine that

00:03:41,500 --> 00:03:46,510
is responsible for the removing of the

00:03:44,079 --> 00:03:49,299
memory is called the garbage collector

00:03:46,510 --> 00:03:53,139
so the garbage collector is able to

00:03:49,299 --> 00:03:55,629
detect objects that are not being used

00:03:53,139 --> 00:03:59,049
anymore and also removes it

00:03:55,629 --> 00:04:01,720
automatically for us so from now on when

00:03:59,049 --> 00:04:05,310
I'm when I speak of memory I will mainly

00:04:01,720 --> 00:04:05,310
mean the heap

00:04:08,290 --> 00:04:13,209
so the question is of course not how

00:04:10,090 --> 00:04:16,260
large is such a heap when it is too much

00:04:13,209 --> 00:04:19,750
when it is interview when it is optimal

00:04:16,260 --> 00:04:23,229
the answer is of course it depends and I

00:04:19,750 --> 00:04:25,539
have here a list of most of very popular

00:04:23,229 --> 00:04:29,280
websites and as we can see the Google

00:04:25,539 --> 00:04:31,960
search requires only seven megabytes and

00:04:29,280 --> 00:04:35,500
on the other hand we find Google Maps

00:04:31,960 --> 00:04:39,280
with 3d enable feature which occupies or

00:04:35,500 --> 00:04:41,260
allocates about 150 megabyte so your

00:04:39,280 --> 00:04:43,690
applications should find its place

00:04:41,260 --> 00:04:45,280
somewhere in between now the next

00:04:43,690 --> 00:04:47,740
question is of course how can I measure

00:04:45,280 --> 00:04:51,130
how much memory my application actually

00:04:47,740 --> 00:04:55,780
requires and this can be done very easy

00:04:51,130 --> 00:05:00,010
so I have here an empty HTML page that

00:04:55,780 --> 00:05:02,680
doesn't do anything and I have here a

00:05:00,010 --> 00:05:05,979
chromium so what I have to do is that I

00:05:02,680 --> 00:05:08,699
just have to open the dev tools and then

00:05:05,979 --> 00:05:11,650
I have here this step called memory and

00:05:08,699 --> 00:05:14,289
if I scroll down I can see here two very

00:05:11,650 --> 00:05:17,349
important numbers the number to the

00:05:14,289 --> 00:05:20,020
right is the amount that the engine has

00:05:17,349 --> 00:05:21,940
allocated for the complete heap and the

00:05:20,020 --> 00:05:25,090
number to the right Nimmi do you want or

00:05:21,940 --> 00:05:27,550
three megabyte is the memory disk that

00:05:25,090 --> 00:05:29,970
is actually already used so we have here

00:05:27,550 --> 00:05:34,180
an empty web page that is already using

00:05:29,970 --> 00:05:37,180
about between 2 1 & 2 megabytes and this

00:05:34,180 --> 00:05:39,760
is because JavaScript comes with with

00:05:37,180 --> 00:05:42,580
some static object with some with some

00:05:39,760 --> 00:05:44,410
static methods and so on and you can see

00:05:42,580 --> 00:05:48,690
it says this as the minimal memory

00:05:44,410 --> 00:05:48,690
footprint of JavaScript in chrome

00:05:49,349 --> 00:05:54,340
question of course is now okay now this

00:05:52,120 --> 00:05:57,330
is an empty web page can I somehow

00:05:54,340 --> 00:06:03,090
measure for example if I have an object

00:05:57,330 --> 00:06:03,090
so I'm adding a script tag

00:06:07,220 --> 00:06:16,380
like yes then I have here an object that

00:06:14,490 --> 00:06:18,750
is called person 1 and this person 1

00:06:16,380 --> 00:06:20,700
contains multiple properties with

00:06:18,750 --> 00:06:23,220
different data types so we have here two

00:06:20,700 --> 00:06:25,350
times a string we have one date we have

00:06:23,220 --> 00:06:28,669
from boolean but we also have a function

00:06:25,350 --> 00:06:31,700
and I want to see now or I want to know

00:06:28,669 --> 00:06:34,290
how much memory these object requires

00:06:31,700 --> 00:06:36,990
what I have to do I have to go back to

00:06:34,290 --> 00:06:39,300
chromium reload the page and then I have

00:06:36,990 --> 00:06:41,610
here to the left I have the button take

00:06:39,300 --> 00:06:45,450
heap snapshot and if I click on this

00:06:41,610 --> 00:06:47,669
button then what's happening is that it

00:06:45,450 --> 00:06:50,100
goes through all the objects that are

00:06:47,669 --> 00:06:53,580
inside of the heap it groups their

00:06:50,100 --> 00:06:55,889
objects and gives me a list and since

00:06:53,580 --> 00:06:59,070
the person one object is directly

00:06:55,889 --> 00:07:01,889
attached to the window I can open this

00:06:59,070 --> 00:07:04,080
one expanded and then I have here all my

00:07:01,889 --> 00:07:07,260
objects that can be reached by the

00:07:04,080 --> 00:07:11,580
window and if I scroll down I see here

00:07:07,260 --> 00:07:13,770
already the person one object now this

00:07:11,580 --> 00:07:16,020
screen comes with three different

00:07:13,770 --> 00:07:19,229
columns first one is distance and

00:07:16,020 --> 00:07:23,400
distance means that is the distance from

00:07:19,229 --> 00:07:25,410
so how many steps do I are required to

00:07:23,400 --> 00:07:27,780
get from the window object to this

00:07:25,410 --> 00:07:29,700
person one object so window object

00:07:27,780 --> 00:07:32,190
counts for one and then we have your

00:07:29,700 --> 00:07:35,880
person too and that's why we have two

00:07:32,190 --> 00:07:38,220
and all the properties inside of the

00:07:35,880 --> 00:07:40,250
person one count for Indiana ditional

00:07:38,220 --> 00:07:43,440
step and that's why we have your three

00:07:40,250 --> 00:07:46,380
the other column is the shallow size and

00:07:43,440 --> 00:07:49,530
the shallow size is just the memory that

00:07:46,380 --> 00:07:51,870
the the object the shell itself requires

00:07:49,530 --> 00:07:54,060
but of course what we are interested in

00:07:51,870 --> 00:07:56,550
is the retained size and the retained

00:07:54,060 --> 00:08:00,060
size is the object including all its

00:07:56,550 --> 00:08:03,050
properties and we can see here that the

00:08:00,060 --> 00:08:07,190
memory size for the person one is about

00:08:03,050 --> 00:08:07,190
1600 byte

00:08:10,780 --> 00:08:16,900
so we have seen now how we can get

00:08:14,560 --> 00:08:19,150
information how large an object is but

00:08:16,900 --> 00:08:21,250
of course we are also interested how the

00:08:19,150 --> 00:08:27,730
memory consumption of our application

00:08:21,250 --> 00:08:29,350
changes over time so what I have what I

00:08:27,730 --> 00:08:31,960
want to do is that I want to create a

00:08:29,350 --> 00:08:34,000
button if I click on the button I want

00:08:31,960 --> 00:08:36,849
to execute a function and then I want to

00:08:34,000 --> 00:08:44,350
watch what how many memory this function

00:08:36,849 --> 00:08:47,140
will does require so this is my button

00:08:44,350 --> 00:08:50,940
then some CSS so that it looks nice

00:08:47,140 --> 00:08:54,970
and then I have prepared a function that

00:08:50,940 --> 00:08:58,600
runs another function five times when

00:08:54,970 --> 00:09:01,240
the user clicks on it just removing this

00:08:58,600 --> 00:09:04,960
and what I am what I do is that I now

00:09:01,240 --> 00:09:08,530
create an array that I call large array

00:09:04,960 --> 00:09:11,770
which is empty and then I say I want to

00:09:08,530 --> 00:09:14,650
run following function five times where

00:09:11,770 --> 00:09:18,640
I'm adding a new array to this large

00:09:14,650 --> 00:09:21,130
array or pushing it and let me see some

00:09:18,640 --> 00:09:28,860
memory consumption I'm creating a memory

00:09:21,130 --> 00:09:28,860
that contains 100,000 elements okay

00:09:28,950 --> 00:09:37,240
so if I go back I can reload my website

00:09:34,300 --> 00:09:39,100
then I have here my button and then I

00:09:37,240 --> 00:09:42,880
have to switch the tap and I go to

00:09:39,100 --> 00:09:45,250
performance in in performance I have

00:09:42,880 --> 00:09:48,339
again a recording button and if I click

00:09:45,250 --> 00:09:49,589
on this I are the the memory consumption

00:09:48,339 --> 00:09:54,460
is being watched

00:09:49,589 --> 00:09:58,839
click and I say click me and it runs

00:09:54,460 --> 00:10:01,110
five times I can say stop and then I see

00:09:58,839 --> 00:10:04,510
here very nicely how the memory

00:10:01,110 --> 00:10:06,550
consumption increased over time you need

00:10:04,510 --> 00:10:08,950
a five times so we started from about

00:10:06,550 --> 00:10:11,380
two megabyte and then we went up to six

00:10:08,950 --> 00:10:14,020
megabyte the only question is this

00:10:11,380 --> 00:10:16,990
memory stays at six megabyte why because

00:10:14,020 --> 00:10:19,930
the large memory is in the window object

00:10:16,990 --> 00:10:22,150
so it is smallest globally everybody can

00:10:19,930 --> 00:10:23,950
access it and that's the reason why the

00:10:22,150 --> 00:10:26,230
garbage collector does nothing

00:10:23,950 --> 00:10:28,690
so if we want to see the garbage

00:10:26,230 --> 00:10:30,910
collector in action I just have to

00:10:28,690 --> 00:10:34,120
remove the large array and I'm creating

00:10:30,910 --> 00:10:35,860
these arrays just out in the blue so I'm

00:10:34,120 --> 00:10:42,660
just creating them but they can't be

00:10:35,860 --> 00:10:42,660
used relearning website removing this

00:10:43,139 --> 00:10:53,529
and then I again I say record click me

00:10:48,570 --> 00:10:57,100
again it runs now five times I think you

00:10:53,529 --> 00:10:59,680
have to wait a little bit then I stop it

00:10:57,100 --> 00:11:01,540
and then we can see here again the

00:10:59,680 --> 00:11:03,940
increase of the memory consumption and

00:11:01,540 --> 00:11:05,740
then it went down and this is the time

00:11:03,940 --> 00:11:07,899
where the garbage collector kicked it

00:11:05,740 --> 00:11:09,910
kicked in the garbage collector saw that

00:11:07,899 --> 00:11:12,100
we had allocated quite a lot of erase

00:11:09,910 --> 00:11:14,139
that aren't used anymore that can't be

00:11:12,100 --> 00:11:22,240
used anymore and that's why they got

00:11:14,139 --> 00:11:24,639
removed good so to the memory issues so

00:11:22,240 --> 00:11:26,649
we have seen now how we can watch how

00:11:24,639 --> 00:11:30,190
the memory works all the also the

00:11:26,649 --> 00:11:32,019
analysis tools and the major problem

00:11:30,190 --> 00:11:34,570
that comes with memory management are

00:11:32,019 --> 00:11:37,120
the so called memory leaks memory leaks

00:11:34,570 --> 00:11:40,420
means that we have some objects lying

00:11:37,120 --> 00:11:42,130
around that aren't not used anymore but

00:11:40,420 --> 00:11:44,829
the garbage collector can't remove it

00:11:42,130 --> 00:11:48,519
for some reasons so one of the reasons

00:11:44,829 --> 00:11:50,620
is that an object is defined in the

00:11:48,519 --> 00:11:53,050
global scope as we have just seen with

00:11:50,620 --> 00:11:54,790
the large array this means that the

00:11:53,050 --> 00:11:57,399
garbage collector will simply not remove

00:11:54,790 --> 00:12:00,250
it please be aware that there are some

00:11:57,399 --> 00:12:02,860
pitfalls where you can accidentally

00:12:00,250 --> 00:12:05,350
assign an object to the global scope if

00:12:02,860 --> 00:12:08,079
you forget to remove all that constant

00:12:05,350 --> 00:12:10,480
constant something like this or if you

00:12:08,079 --> 00:12:12,640
are doing some strange things with the

00:12:10,480 --> 00:12:15,550
context it can also happen that the

00:12:12,640 --> 00:12:18,339
context changes to window so please be

00:12:15,550 --> 00:12:20,769
aware of this then we have also another

00:12:18,339 --> 00:12:23,019
problem which comes with detached Dom

00:12:20,769 --> 00:12:25,420
nodes and this means that we have to

00:12:23,019 --> 00:12:28,779
know that the rendering engine itself

00:12:25,420 --> 00:12:30,519
also has a separate garbage collector

00:12:28,779 --> 00:12:32,560
and the garbage collector for the

00:12:30,519 --> 00:12:34,930
rendering engine works like this that it

00:12:32,560 --> 00:12:36,200
removes all the nodes that are not part

00:12:34,930 --> 00:12:38,660
of the Dom anymore

00:12:36,200 --> 00:12:40,519
but what can happen now is that in

00:12:38,660 --> 00:12:42,649
JavaScript we have a reference to one of

00:12:40,519 --> 00:12:44,510
these Dom nodes and then the garbage

00:12:42,649 --> 00:12:45,920
collector of the rendering engine knows

00:12:44,510 --> 00:12:49,250
that there is a reference from

00:12:45,920 --> 00:12:53,360
JavaScript and can't remove it and this

00:12:49,250 --> 00:12:57,620
is a very hard to find bug or issue and

00:12:53,360 --> 00:12:59,870
that's why in the heap dump there is a

00:12:57,620 --> 00:13:03,440
special functionality to find these

00:12:59,870 --> 00:13:06,500
detached nodes so if we create or make a

00:13:03,440 --> 00:13:09,649
heap dump as we have seen before we only

00:13:06,500 --> 00:13:12,740
have to type into this input field here

00:13:09,649 --> 00:13:15,560
detached and then chrome lists us all

00:13:12,740 --> 00:13:18,649
the downloads that are detached from the

00:13:15,560 --> 00:13:20,660
DOM and then we can check if we can

00:13:18,649 --> 00:13:23,870
really remove them or if they are there

00:13:20,660 --> 00:13:29,839
for a reason so these are more or less

00:13:23,870 --> 00:13:32,889
very easy to debug memory leaks it gets

00:13:29,839 --> 00:13:36,019
harder when we come to the closures and

00:13:32,889 --> 00:13:37,910
this comes again with a code example so

00:13:36,019 --> 00:13:39,800
what I want to do or let's consider we

00:13:37,910 --> 00:13:42,470
have an application where we are

00:13:39,800 --> 00:13:45,140
requesting data of the current user from

00:13:42,470 --> 00:13:47,360
an endpoint and then we have again our

00:13:45,140 --> 00:13:49,160
button and if we click on the button the

00:13:47,360 --> 00:13:56,810
button should just print out the name of

00:13:49,160 --> 00:13:59,300
the user so I'm simulating here my where

00:13:56,810 --> 00:14:02,209
I'm loading the endpoint as we can see

00:13:59,300 --> 00:14:04,820
it returns a promise that contains an

00:14:02,209 --> 00:14:06,589
array only the first element of the

00:14:04,820 --> 00:14:09,430
array is the actual name of the user and

00:14:06,589 --> 00:14:14,180
the rest is something else we don't care

00:14:09,430 --> 00:14:15,709
and then we have a get current user

00:14:14,180 --> 00:14:18,709
function and this function should return

00:14:15,709 --> 00:14:20,720
either a print named function that will

00:14:18,709 --> 00:14:23,810
will be that we will use as event

00:14:20,720 --> 00:14:27,170
listener and what I'm doing here is that

00:14:23,810 --> 00:14:30,620
I say okay name I have here this nested

00:14:27,170 --> 00:14:33,319
function kept name I'm just calling it

00:14:30,620 --> 00:14:35,959
this get name will just return me here

00:14:33,319 --> 00:14:38,720
the first element of the list which

00:14:35,959 --> 00:14:43,660
which will be the name and then I return

00:14:38,720 --> 00:14:46,370
a function print name

00:14:43,660 --> 00:14:54,980
and what this function does is that it

00:14:46,370 --> 00:14:56,960
just says console.log hello mean and of

00:14:54,980 --> 00:14:58,820
course I also have it have to add it to

00:14:56,960 --> 00:15:03,350
the event listener or I have to create

00:14:58,820 --> 00:15:05,630
an event listener looks like this so I'm

00:15:03,350 --> 00:15:07,940
so I'm creating my okay use a function

00:15:05,630 --> 00:15:10,220
by calling it and when I have my

00:15:07,940 --> 00:15:16,430
function I'm adding the event listener

00:15:10,220 --> 00:15:20,900
and let's see how this works so I'm

00:15:16,430 --> 00:15:24,530
reloading it I'm seeing record then I

00:15:20,900 --> 00:15:26,450
say click me I can already say stop and

00:15:24,530 --> 00:15:28,490
as we can see here it prints out the

00:15:26,450 --> 00:15:31,280
name so the function already worked and

00:15:28,490 --> 00:15:33,170
if we go back to the performance then we

00:15:31,280 --> 00:15:34,820
see that nothing really changed there

00:15:33,170 --> 00:15:36,950
was my no increase in the memory

00:15:34,820 --> 00:15:39,740
consumption but there is something very

00:15:36,950 --> 00:15:44,000
very strange because the heap size is

00:15:39,740 --> 00:15:46,010
already a 12 megabyte and yeah I mean

00:15:44,000 --> 00:15:48,290
obviously it is it has it must have do

00:15:46,010 --> 00:15:50,210
something with this big data object but

00:15:48,290 --> 00:15:50,810
the question is of course why did this

00:15:50,210 --> 00:15:53,960
happen

00:15:50,810 --> 00:15:56,660
so what we can do is that we can go to

00:15:53,960 --> 00:15:59,300
the debugger my set here a breakpoint

00:15:56,660 --> 00:16:04,370
and then I'm clicking again on this

00:15:59,300 --> 00:16:07,070
button works looks everything looks nice

00:16:04,370 --> 00:16:10,220
so far but now the thing is that inside

00:16:07,070 --> 00:16:13,190
of this closure we have this data object

00:16:10,220 --> 00:16:16,270
and this is what that causes the garbage

00:16:13,190 --> 00:16:21,710
collector not to remove the data object

00:16:16,270 --> 00:16:23,510
the question is why so as we can see we

00:16:21,710 --> 00:16:25,340
have a diskette current user function

00:16:23,510 --> 00:16:27,380
and this gate current user function

00:16:25,340 --> 00:16:29,860
contains two further nested functions

00:16:27,380 --> 00:16:33,500
maybe they get name and the print name

00:16:29,860 --> 00:16:35,360
when the function exits we would suppose

00:16:33,500 --> 00:16:36,920
that the get name function can be

00:16:35,360 --> 00:16:40,000
removed because it is not required

00:16:36,920 --> 00:16:43,070
anymore and since only they get named

00:16:40,000 --> 00:16:45,410
accesses the data we would also guess

00:16:43,070 --> 00:16:48,590
that the data object will be removed as

00:16:45,410 --> 00:16:50,810
well but this is not how it works

00:16:48,590 --> 00:16:53,690
because what we have is that we have

00:16:50,810 --> 00:16:55,580
here the scope and the rule is that all

00:16:53,690 --> 00:16:56,900
nested function they share the same

00:16:55,580 --> 00:16:59,180
scope

00:16:56,900 --> 00:17:01,880
and as we can see since the getname

00:16:59,180 --> 00:17:04,459
needs access to data the data gets into

00:17:01,880 --> 00:17:06,680
the scope and then the print name

00:17:04,459 --> 00:17:08,949
accesses the name which also gets into

00:17:06,680 --> 00:17:11,930
the scope but the print name function

00:17:08,949 --> 00:17:13,880
has now also this data object inside of

00:17:11,930 --> 00:17:16,970
the scope and this causes all the

00:17:13,880 --> 00:17:19,130
travels so the question is now how can

00:17:16,970 --> 00:17:21,589
we get rid of this and the answer is

00:17:19,130 --> 00:17:24,860
very very simple we only have two

00:17:21,589 --> 00:17:27,949
defined or a way where no nested

00:17:24,860 --> 00:17:30,860
function contains the data object so

00:17:27,949 --> 00:17:34,730
that it looks something like this now if

00:17:30,860 --> 00:17:36,410
I go back to my code I'm removing this

00:17:34,730 --> 00:17:38,660
return and then I'm simple and then I'm

00:17:36,410 --> 00:17:41,270
simply doing the thing that this nested

00:17:38,660 --> 00:17:46,420
function would have done I'm just saying

00:17:41,270 --> 00:17:50,590
at the first element just running it

00:17:46,420 --> 00:17:53,600
reloading it then I say again click me

00:17:50,590 --> 00:17:55,880
and then we can see that in this closure

00:17:53,600 --> 00:17:59,090
the data is not there anymore

00:17:55,880 --> 00:18:02,240
and again it's the problem is not that

00:17:59,090 --> 00:18:04,670
we have such a big data the problem was

00:18:02,240 --> 00:18:07,640
that the data was used inside of another

00:18:04,670 --> 00:18:09,679
nested function and this cost that the

00:18:07,640 --> 00:18:16,429
data find its way into the scope that is

00:18:09,679 --> 00:18:20,059
shared by all nested functions just

00:18:16,429 --> 00:18:21,950
you're in the game this is a rule to an

00:18:20,059 --> 00:18:24,830
exception to the rule because if we are

00:18:21,950 --> 00:18:26,570
using an evil in a nested function and

00:18:24,830 --> 00:18:28,820
this will cause the engine to put

00:18:26,570 --> 00:18:32,600
everything inside into the scope because

00:18:28,820 --> 00:18:35,360
then maybe this evil will try to access

00:18:32,600 --> 00:18:40,210
the data for some reason and you'll

00:18:35,360 --> 00:18:43,010
still remember it just don't use it and

00:18:40,210 --> 00:18:46,460
to take away is here that closures they

00:18:43,010 --> 00:18:48,650
are a very very elegant way to solve

00:18:46,460 --> 00:18:50,179
certain problems but they are also very

00:18:48,650 --> 00:18:52,760
dangerous when it comes to memory

00:18:50,179 --> 00:18:54,980
management and it somehow looks like it

00:18:52,760 --> 00:18:57,530
pact with the devil so you really have

00:18:54,980 --> 00:19:00,500
to know what you are doing when you have

00:18:57,530 --> 00:19:03,500
very many closures inside of your

00:19:00,500 --> 00:19:05,460
application so I think we are already

00:19:03,500 --> 00:19:09,250
over time

00:19:05,460 --> 00:19:14,680
okay because I have one last chapter and

00:19:09,250 --> 00:19:16,930
this is the garbage collector so we have

00:19:14,680 --> 00:19:19,090
here again another example where we have

00:19:16,930 --> 00:19:20,950
some shopping case and as we can see we

00:19:19,090 --> 00:19:24,309
are defining here a basket that contains

00:19:20,950 --> 00:19:26,380
basket items we create a total object

00:19:24,309 --> 00:19:28,360
that wants to calculate the total number

00:19:26,380 --> 00:19:31,059
of the total amount of money that we

00:19:28,360 --> 00:19:34,210
have to pay for the basket and then I'm

00:19:31,059 --> 00:19:36,850
iterating over each basket item and in

00:19:34,210 --> 00:19:39,340
each iteration as you can see here I am

00:19:36,850 --> 00:19:41,710
fetching the product from some end point

00:19:39,340 --> 00:19:44,140
and then I use the price of this product

00:19:41,710 --> 00:19:49,059
multiplied with the amount to come to

00:19:44,140 --> 00:19:52,870
the total amount so it works like this

00:19:49,059 --> 00:19:54,730
we start with assigning with waiting the

00:19:52,870 --> 00:19:56,590
basket as you can see to the right side

00:19:54,730 --> 00:19:59,050
we have here this the heap which started

00:19:56,590 --> 00:20:01,750
out to be empty now we have two basket

00:19:59,050 --> 00:20:06,010
inside of it let me create the doto and

00:20:01,750 --> 00:20:09,160
then the loop starts so that we create a

00:20:06,010 --> 00:20:11,170
new product object then the next

00:20:09,160 --> 00:20:13,809
iteration we create the second product

00:20:11,170 --> 00:20:16,960
object then we have the third iteration

00:20:13,809 --> 00:20:19,120
and what can happen now since these

00:20:16,960 --> 00:20:21,520
await commands took quite a long time

00:20:19,120 --> 00:20:24,040
that the garbage collector kicks in

00:20:21,520 --> 00:20:25,330
kicks in and what's happening now is

00:20:24,040 --> 00:20:27,420
that the garbage collector says okay

00:20:25,330 --> 00:20:30,190
execution stops immediately

00:20:27,420 --> 00:20:33,400
nobody will is allowed to do anything

00:20:30,190 --> 00:20:36,490
and the garbage collection our garbage

00:20:33,400 --> 00:20:38,800
collector follows know something that we

00:20:36,490 --> 00:20:41,530
are that is known for marking sweep as

00:20:38,800 --> 00:20:43,540
marking sweep and the garbage collector

00:20:41,530 --> 00:20:46,990
of course knows which objects are in the

00:20:43,540 --> 00:20:50,650
heap and the garbage collector now tries

00:20:46,990 --> 00:20:53,890
from predefined routes if these objects

00:20:50,650 --> 00:20:57,100
are reachable and one route is the

00:20:53,890 --> 00:20:59,679
window object the basket actually no no

00:20:57,100 --> 00:21:01,900
one no no object of this list can be

00:20:59,679 --> 00:21:04,929
reached by the window object but what

00:21:01,900 --> 00:21:07,450
also counts is the current stack and

00:21:04,929 --> 00:21:10,210
from the current stack we can access the

00:21:07,450 --> 00:21:11,890
basket we can also access the total but

00:21:10,210 --> 00:21:16,480
not the two products that have been

00:21:11,890 --> 00:21:18,460
created in the iterations before now the

00:21:16,480 --> 00:21:21,700
the first ones are marked that they

00:21:18,460 --> 00:21:25,870
should stay there now the obvious thing

00:21:21,700 --> 00:21:27,940
which we think might think is that we

00:21:25,870 --> 00:21:30,490
just have to remove here the product the

00:21:27,940 --> 00:21:34,810
first and the second product object but

00:21:30,490 --> 00:21:38,860
this is not how it works in reality we

00:21:34,810 --> 00:21:42,220
have a second keep space memory in the

00:21:38,860 --> 00:21:45,630
hips in the hip and what the garbage

00:21:42,220 --> 00:21:47,890
collection of us is that it takes the

00:21:45,630 --> 00:21:49,270
objects that will survive this garbage

00:21:47,890 --> 00:21:52,090
collection namely the basket and the

00:21:49,270 --> 00:21:54,640
total it moves them to into the second

00:21:52,090 --> 00:21:56,980
memory space the second memory space

00:21:54,640 --> 00:22:01,360
which is also called to space becomes

00:21:56,980 --> 00:22:03,280
now the active heap space and what

00:22:01,360 --> 00:22:06,220
happens to the first we just remove

00:22:03,280 --> 00:22:07,750
everything so you can think of this like

00:22:06,220 --> 00:22:09,310
if you have a house you want to clean

00:22:07,750 --> 00:22:11,410
your house you just take all your

00:22:09,310 --> 00:22:14,170
belongings put it to a second house and

00:22:11,410 --> 00:22:17,410
burn down the first house this is a

00:22:14,170 --> 00:22:20,260
little bit crazy but it is done with the

00:22:17,410 --> 00:22:23,710
garbage collector and the reason why we

00:22:20,260 --> 00:22:27,010
this it works like this is an effect we

00:22:23,710 --> 00:22:29,110
call infant mortality and this means

00:22:27,010 --> 00:22:31,030
that we know that the most objects that

00:22:29,110 --> 00:22:31,630
we are using they don't live for a very

00:22:31,030 --> 00:22:34,420
long time

00:22:31,630 --> 00:22:36,430
so it is very very inefficient if we

00:22:34,420 --> 00:22:39,760
just go through the heap and pick each

00:22:36,430 --> 00:22:42,070
of these objects and therefore we just

00:22:39,760 --> 00:22:44,650
take the few objects that we know will

00:22:42,070 --> 00:22:46,960
survive put it to to another memory

00:22:44,650 --> 00:22:50,650
space and just remove the rest so this

00:22:46,960 --> 00:22:52,570
is how it is usually done so I'm just

00:22:50,650 --> 00:22:55,600
skipping it and then there is one more

00:22:52,570 --> 00:22:58,270
thing with the garbage collector let's

00:22:55,600 --> 00:23:01,630
suppose there are no more up more

00:22:58,270 --> 00:23:04,360
purchase purchases in the basket so it

00:23:01,630 --> 00:23:08,950
can happen that inside of this for loop

00:23:04,360 --> 00:23:11,680
we have multiple garbage collections so

00:23:08,950 --> 00:23:14,380
it just behaves as we just have seen so

00:23:11,680 --> 00:23:17,800
the the survivors are moved into their

00:23:14,380 --> 00:23:20,080
other heap space but what happens now is

00:23:17,800 --> 00:23:22,690
that the garbage collector knows which

00:23:20,080 --> 00:23:24,850
one of these objects objects have

00:23:22,690 --> 00:23:28,450
already survived one garbage collection

00:23:24,850 --> 00:23:29,920
and they are put into a so-called second

00:23:28,450 --> 00:23:31,930
generation which is called

00:23:29,920 --> 00:23:34,390
immediate and the ones that have just

00:23:31,930 --> 00:23:38,380
been created are put into the nursery

00:23:34,390 --> 00:23:40,450
generation and if the objects from the

00:23:38,380 --> 00:23:42,820
intermediate generation survived the

00:23:40,450 --> 00:23:45,070
next garbage collection then they will

00:23:42,820 --> 00:23:48,130
not put in again into the other heap

00:23:45,070 --> 00:23:50,680
heap space but there is another one a

00:23:48,130 --> 00:23:53,470
far larger one and they will be moved

00:23:50,680 --> 00:23:55,150
there and the larger one is called the

00:23:53,470 --> 00:23:57,580
old generation and the first two ones

00:23:55,150 --> 00:24:00,250
are called the new generation and why

00:23:57,580 --> 00:24:02,560
are we doing this because the old

00:24:00,250 --> 00:24:04,900
generation contains these objects where

00:24:02,560 --> 00:24:06,880
we think they will survive for a very

00:24:04,900 --> 00:24:09,910
long long time they have their own

00:24:06,880 --> 00:24:13,330
garbage collection cycle and we just try

00:24:09,910 --> 00:24:16,060
that inside of these two smaller memory

00:24:13,330 --> 00:24:16,930
spaces we have only the ones that will

00:24:16,060 --> 00:24:18,970
not survive

00:24:16,930 --> 00:24:20,560
that often so that the garbage

00:24:18,970 --> 00:24:23,200
collection cycle itself is very

00:24:20,560 --> 00:24:25,560
efficient and can be executed very very

00:24:23,200 --> 00:24:25,560
fast

00:24:25,890 --> 00:24:33,820
okay this was just really good that just

00:24:32,050 --> 00:24:34,810
scratch the surface how it's working in

00:24:33,820 --> 00:24:37,060
reality it's a little bit more

00:24:34,810 --> 00:24:39,220
complicated there is far far more but

00:24:37,060 --> 00:24:42,700
then but the principle it stays the same

00:24:39,220 --> 00:24:44,740
and what the browser's are not drying

00:24:42,700 --> 00:24:47,020
the browser windows what they are trying

00:24:44,740 --> 00:24:48,550
is that they want to reduce the time

00:24:47,020 --> 00:24:52,180
that the garbage collector

00:24:48,550 --> 00:24:53,890
takes to more or less an effect cut stop

00:24:52,180 --> 00:24:57,450
the world when nothing can happen and

00:24:53,890 --> 00:25:00,520
what they are trying that they try to to

00:24:57,450 --> 00:25:02,680
put some of the work that has to be done

00:25:00,520 --> 00:25:04,720
before the garbage collection actually

00:25:02,680 --> 00:25:06,730
really starts so that it just takes a

00:25:04,720 --> 00:25:08,980
very very short amount of time which

00:25:06,730 --> 00:25:11,110
means we have some garbage collection

00:25:08,980 --> 00:25:14,410
tasks that run concurrently or imperial

00:25:11,110 --> 00:25:17,170
and so on and especially in the browser

00:25:14,410 --> 00:25:18,820
the garbage collection also works

00:25:17,170 --> 00:25:20,860
together with the rendering engine and

00:25:18,820 --> 00:25:23,350
rendering anything in the rendering

00:25:20,860 --> 00:25:25,840
engine kintel the garbage collector that

00:25:23,350 --> 00:25:27,940
we are now between a rendering frame for

00:25:25,840 --> 00:25:31,120
example and the garbage collection can

00:25:27,940 --> 00:25:33,310
now do something which goes unnoticed by

00:25:31,120 --> 00:25:36,180
the actual end user because there is no

00:25:33,310 --> 00:25:36,180
flickering or something

00:25:37,060 --> 00:25:42,100
so this was everything from my side and

00:25:41,200 --> 00:25:44,770
thank you very much

00:25:42,100 --> 00:25:46,960
and if you have questions or if you

00:25:44,770 --> 00:25:49,390
think that something is wrong just

00:25:46,960 --> 00:25:53,109
please tell me

00:25:49,390 --> 00:25:53,109

YouTube URL: https://www.youtube.com/watch?v=uhQ0sagRqqY


