Title: ViennaJS, Javascript Engine Essentials for Developers, January 2018
Publication date: 2018-02-01
Playlist: viennaJS
Description: 
	Talk by Rainer Hahnekamp:
Google's V8 raised the execution speed of JavaScript to a level almost comparable to C++. But how do the internals affect us as developers in our daily life? Doesn't "normal written code" just run faster automatically?
In this talk (with live-coding) we will cover the basics and learn about potential pitfalls.

More about Rainer: https://twitter.com/rainerhahnekamp

More about ViennaJS: https://www.meetup.com/viennajs/
Captions: 
	00:00:00,030 --> 00:00:05,310
so hello I hope everybody can hear me my

00:00:03,179 --> 00:00:08,189
name is Reina Hanukkah I'm in

00:00:05,310 --> 00:00:10,559
independent software engineer and this

00:00:08,189 --> 00:00:13,530
is already my second talk at this meetup

00:00:10,559 --> 00:00:15,509
my first one was last June where I

00:00:13,530 --> 00:00:18,630
talked about type safety in JavaScript

00:00:15,509 --> 00:00:21,270
applications and this time I want to go

00:00:18,630 --> 00:00:23,880
some levels simple namely to the engine

00:00:21,270 --> 00:00:28,320
so the engine is actually the thing that

00:00:23,880 --> 00:00:29,939
executes our JavaScript code and I don't

00:00:28,320 --> 00:00:32,930
want to talk too much about the

00:00:29,939 --> 00:00:36,660
internals although it might be it is

00:00:32,930 --> 00:00:38,750
interesting and fascinating but this

00:00:36,660 --> 00:00:41,309
talk is more from the perspective of a

00:00:38,750 --> 00:00:43,219
application developer so somebody that

00:00:41,309 --> 00:00:47,280
is using javascript to write

00:00:43,219 --> 00:00:50,190
applications and there i think the

00:00:47,280 --> 00:00:53,610
question is more how much do i as a

00:00:50,190 --> 00:00:56,820
patient developer need to know in order

00:00:53,610 --> 00:01:00,300
that the engine runs my code properly

00:00:56,820 --> 00:01:05,670
and fine and i want to start with a

00:01:00,300 --> 00:01:10,799
little code example so it's more or less

00:01:05,670 --> 00:01:15,090
chrome the font size is large enough i

00:01:10,799 --> 00:01:19,380
hope and as you can see i have here four

00:01:15,090 --> 00:01:22,259
objects that represent characters from

00:01:19,380 --> 00:01:25,650
Star Wars movie with the first and the

00:01:22,259 --> 00:01:33,409
last name and I'm putting them into an

00:01:25,650 --> 00:01:38,280
array which contains eight elements okay

00:01:33,409 --> 00:01:41,070
just and I further have a function

00:01:38,280 --> 00:01:43,409
called get name and I'm not particularly

00:01:41,070 --> 00:01:46,619
interested in how this function behaves

00:01:43,409 --> 00:01:49,530
and what I'm doing now is the time

00:01:46,619 --> 00:01:51,990
calling this function 1 billion times so

00:01:49,530 --> 00:01:54,659
that they get the decent number and I'm

00:01:51,990 --> 00:01:58,350
for measuring the execution speed or

00:01:54,659 --> 00:02:01,560
executed the time I'm using the the time

00:01:58,350 --> 00:02:05,070
commands from the console object so I'm

00:02:01,560 --> 00:02:09,310
running this script now and it tells me

00:02:05,070 --> 00:02:13,940
that it executed in 1.3 seconds

00:02:09,310 --> 00:02:17,330
which doesn't mean so far but if we

00:02:13,940 --> 00:02:20,330
consider now that this script here is a

00:02:17,330 --> 00:02:23,300
part of a larger application and the

00:02:20,330 --> 00:02:26,090
objects are coming from a database for

00:02:23,300 --> 00:02:28,580
example a schema less database then it

00:02:26,090 --> 00:02:31,280
might be quite possible that somebody

00:02:28,580 --> 00:02:34,610
adds a new property into one of these

00:02:31,280 --> 00:02:39,220
objects so for example with this object

00:02:34,610 --> 00:02:49,100
on we can add a property space a

00:02:39,220 --> 00:02:59,090
spaceship and call it Falcone it's hard

00:02:49,100 --> 00:03:03,830
to type with one hand so okay I'm

00:02:59,090 --> 00:03:06,260
executing this code again and as I can

00:03:03,830 --> 00:03:08,420
see we are now up to two seconds so this

00:03:06,260 --> 00:03:12,110
is a actually a huge performance drop

00:03:08,420 --> 00:03:15,709
about 50% and the question is why is

00:03:12,110 --> 00:03:18,260
that the case one might argue that I

00:03:15,709 --> 00:03:21,290
have added a third property to an object

00:03:18,260 --> 00:03:25,959
that hold that two properties which is

00:03:21,290 --> 00:03:28,459
50% more and it could be for some reason

00:03:25,959 --> 00:03:31,430
the reason for this performance drop I

00:03:28,459 --> 00:03:33,590
mean if I want to verify my theory then

00:03:31,430 --> 00:03:35,959
it would be quite easy I only need to

00:03:33,590 --> 00:03:39,109
add these special properties to all the

00:03:35,959 --> 00:03:44,319
other objects and the performance would

00:03:39,109 --> 00:03:44,319
drop even more so if I'm doing this now

00:03:54,480 --> 00:03:59,260
and now execute the kill it again and

00:03:57,250 --> 00:04:00,790
for some reason I am actually at the

00:03:59,260 --> 00:04:09,069
performance where it was the first run

00:04:00,790 --> 00:04:11,409
so this wasn't a reason in real life

00:04:09,069 --> 00:04:13,870
the question is now do you really want

00:04:11,409 --> 00:04:16,810
to investigate into this problem or do

00:04:13,870 --> 00:04:17,530
we say okay if it runs to seconds not a

00:04:16,810 --> 00:04:21,340
big problem

00:04:17,530 --> 00:04:24,789
we we skip it and work on some other

00:04:21,340 --> 00:04:27,449
tasks given that we do that the

00:04:24,789 --> 00:04:29,590
application is still used further and

00:04:27,449 --> 00:04:32,380
it's quite possible that other

00:04:29,590 --> 00:04:34,599
properties are added so somebody could

00:04:32,380 --> 00:04:43,389
start saying that Luke needs a job

00:04:34,599 --> 00:04:46,090
property because he's a Jedi for Leia we

00:04:43,389 --> 00:04:53,620
could add a gender property everything a

00:04:46,090 --> 00:04:55,990
female and for obi-wan we could actually

00:04:53,620 --> 00:04:58,840
add a retired property because it

00:04:55,990 --> 00:05:03,659
doesn't do anything anymore let me say

00:04:58,840 --> 00:05:06,280
it's true now if we run that code again

00:05:03,659 --> 00:05:10,349
the performance even increases now we

00:05:06,280 --> 00:05:14,169
are actually at 200% of our initial run

00:05:10,349 --> 00:05:16,120
now the questions a starts again should

00:05:14,169 --> 00:05:19,030
we deal with this or should we skip it

00:05:16,120 --> 00:05:21,880
you to ignore it and let's say they are

00:05:19,030 --> 00:05:26,949
users don't really complain so we decide

00:05:21,880 --> 00:05:30,190
that we ignore this problem but what now

00:05:26,949 --> 00:05:32,860
could happen is that somebody says well

00:05:30,190 --> 00:05:39,340
actually a very important character is

00:05:32,860 --> 00:05:41,110
missing here and we add Yoda and for

00:05:39,340 --> 00:05:42,370
some reason we don't know the first name

00:05:41,110 --> 00:05:46,650
of you although we only know the last

00:05:42,370 --> 00:05:46,650
name so I'm saying okay

00:05:48,680 --> 00:05:51,839
[Music]

00:05:52,180 --> 00:06:02,390
they also have to add a new object in my

00:05:56,020 --> 00:06:05,260
array now I'm executing it now takes a

00:06:02,390 --> 00:06:09,740
little buying time my laptop gets louder

00:06:05,260 --> 00:06:11,900
so there is quite some work and for some

00:06:09,740 --> 00:06:14,210
reason we are unfortunately up to nine

00:06:11,900 --> 00:06:17,660
seconds so now I would say it's really

00:06:14,210 --> 00:06:23,330
time that we investigate what went wrong

00:06:17,660 --> 00:06:25,340
here and because we simply cannot ignore

00:06:23,330 --> 00:06:26,930
this issue anymore

00:06:25,340 --> 00:06:28,940
so I think it's time that we learn a

00:06:26,930 --> 00:06:33,050
little bit more about actually the

00:06:28,940 --> 00:06:35,660
engine itself and first of all the

00:06:33,050 --> 00:06:37,910
question is what is an engine so as I

00:06:35,660 --> 00:06:39,860
already said in the beginning the engine

00:06:37,910 --> 00:06:42,110
is the part that executes your

00:06:39,860 --> 00:06:45,500
JavaScript code true takes the source

00:06:42,110 --> 00:06:47,270
code and execute it especially it

00:06:45,500 --> 00:06:49,790
usually comes bundled with your

00:06:47,270 --> 00:06:52,880
browser's and each profetas has their

00:06:49,790 --> 00:06:55,780
own engine and so with google chrome we

00:06:52,880 --> 00:06:58,580
have v8 Safari has a Java Script Akua

00:06:55,780 --> 00:07:01,580
Microsoft browsers currently to have

00:06:58,580 --> 00:07:05,180
chakra or chakra which is the open

00:07:01,580 --> 00:07:10,010
source project and Mozilla has spider

00:07:05,180 --> 00:07:12,320
monkey and you should not mistake and

00:07:10,010 --> 00:07:14,270
the JavaScript engine is de-rating

00:07:12,320 --> 00:07:16,390
right with the rendering engine this is

00:07:14,270 --> 00:07:19,840
something completely different and

00:07:16,390 --> 00:07:22,850
what's also very important you know I

00:07:19,840 --> 00:07:26,150
mean usually Java Script is interpreted

00:07:22,850 --> 00:07:30,950
and until the release of Google's Chrome

00:07:26,150 --> 00:07:34,490
or v8 engine the engines only simple

00:07:30,950 --> 00:07:38,300
interpreters so why saying that what has

00:07:34,490 --> 00:07:41,120
changed with v8 well usually these days

00:07:38,300 --> 00:07:45,140
all modern engines are equipped with

00:07:41,120 --> 00:07:48,140
compiler and an interpreter so the

00:07:45,140 --> 00:07:52,640
interpreter takes the source code during

00:07:48,140 --> 00:07:55,490
the runtime it starts let starts to

00:07:52,640 --> 00:07:57,680
execute it immediately and what is

00:07:55,490 --> 00:08:00,560
special here is that it executes your

00:07:57,680 --> 00:08:01,790
source code on the fly and with the

00:08:00,560 --> 00:08:04,760
compiler we have the so-called

00:08:01,790 --> 00:08:08,240
compilation phase weather

00:08:04,760 --> 00:08:10,720
Bosco's is first in JavaScript it is

00:08:08,240 --> 00:08:15,020
first compiled into machine code and

00:08:10,720 --> 00:08:17,210
with a machine code that advantage of

00:08:15,020 --> 00:08:18,860
the machine code is that you can execute

00:08:17,210 --> 00:08:21,880
it directly so you don't need any

00:08:18,860 --> 00:08:25,640
interpreter or the compiler anymore and

00:08:21,880 --> 00:08:27,260
additionally the compiler can also make

00:08:25,640 --> 00:08:29,240
some optimizations during the

00:08:27,260 --> 00:08:31,790
compilation phase this is also very

00:08:29,240 --> 00:08:34,520
important so the big advantage of the

00:08:31,790 --> 00:08:37,970
compiler over the interpreter is that

00:08:34,520 --> 00:08:40,340
the code execution is faster the

00:08:37,970 --> 00:08:42,020
disadvantage is that it takes some time

00:08:40,340 --> 00:08:44,930
because we have the compilation phase

00:08:42,020 --> 00:08:48,170
and with interpreter it's the opposite

00:08:44,930 --> 00:08:50,750
so the interpreter can really very fast

00:08:48,170 --> 00:08:54,500
start up your application but the

00:08:50,750 --> 00:08:57,110
execution itself is slower and the basic

00:08:54,500 --> 00:09:00,710
idea with the modern engines is that we

00:08:57,110 --> 00:09:03,230
want to combine both of the best of both

00:09:00,710 --> 00:09:06,140
worlds so we want from the interpreter

00:09:03,230 --> 00:09:08,270
the faster application startup but we

00:09:06,140 --> 00:09:11,510
also want the fast execution that the

00:09:08,270 --> 00:09:17,810
compiler can give us and how can this

00:09:11,510 --> 00:09:19,490
work well considering in real real life

00:09:17,810 --> 00:09:21,910
examples so let's say we have a web

00:09:19,490 --> 00:09:25,820
application the browser is requesting or

00:09:21,910 --> 00:09:27,620
JavaScript source code it doesn't matter

00:09:25,820 --> 00:09:30,800
if the source code is minified or

00:09:27,620 --> 00:09:33,050
whatever it simply is JavaScript and the

00:09:30,800 --> 00:09:35,150
engine usually starts off with the

00:09:33,050 --> 00:09:37,760
interpreter because we want that the

00:09:35,150 --> 00:09:40,040
application starts immediately now

00:09:37,760 --> 00:09:43,310
additionally the engine itself

00:09:40,040 --> 00:09:46,220
now monitors what the interpreter

00:09:43,310 --> 00:09:49,250
actually does and what code parts are

00:09:46,220 --> 00:09:51,290
executed very often and the code parts

00:09:49,250 --> 00:09:54,230
that I executed very often are also

00:09:51,290 --> 00:09:58,430
called the hot path and usually this hot

00:09:54,230 --> 00:10:01,700
part of the code parts became candidates

00:09:58,430 --> 00:10:03,830
for the compilation so after after some

00:10:01,700 --> 00:10:06,170
time with when the engine says ok I have

00:10:03,830 --> 00:10:10,400
enough information we can now start with

00:10:06,170 --> 00:10:14,780
the compilation it triggers the compiler

00:10:10,400 --> 00:10:17,420
and since the compiler is only started

00:10:14,780 --> 00:10:18,690
after some time and executes and exit

00:10:17,420 --> 00:10:22,890
and compiles the

00:10:18,690 --> 00:10:25,410
but the code parts that are used very

00:10:22,890 --> 00:10:28,620
often you also cause the just-in-time

00:10:25,410 --> 00:10:30,660
compilation what's important

00:10:28,620 --> 00:10:32,730
interpreter still continues so while the

00:10:30,660 --> 00:10:34,290
compilation is going on the interpreter

00:10:32,730 --> 00:10:37,770
still runs so your application is still

00:10:34,290 --> 00:10:41,640
executed but once the compiler is

00:10:37,770 --> 00:10:45,090
finished the engine takes the machine

00:10:41,640 --> 00:10:47,760
code and uses or executes the machine

00:10:45,090 --> 00:10:52,500
code directly and skips for the compiled

00:10:47,760 --> 00:10:54,510
code part the interpreter and as I'm

00:10:52,500 --> 00:10:57,630
showing in this charge there are

00:10:54,510 --> 00:11:00,120
multiple optimization steps and there is

00:10:57,630 --> 00:11:05,610
one particular optimization pattern that

00:11:00,120 --> 00:11:07,950
is very powerful and I think that we

00:11:05,610 --> 00:11:10,110
should all know about and this

00:11:07,950 --> 00:11:13,890
optimization step is called inline

00:11:10,110 --> 00:11:16,260
caching and if I would have to describe

00:11:13,890 --> 00:11:19,200
inline caching in one sentence then I

00:11:16,260 --> 00:11:21,090
would say it's actually the trying to

00:11:19,200 --> 00:11:23,970
create static types during the runtime

00:11:21,090 --> 00:11:25,860
which is quite a tough task as you can

00:11:23,970 --> 00:11:29,820
imagine and of course it's not very safe

00:11:25,860 --> 00:11:32,580
and I also want to show how inline

00:11:29,820 --> 00:11:35,160
caching is working by using our example

00:11:32,580 --> 00:11:40,710
of the Star Wars character movies we had

00:11:35,160 --> 00:11:42,690
before so if we are now looking at the

00:11:40,710 --> 00:11:45,360
situation of an area it is when

00:11:42,690 --> 00:11:48,630
interpreter is running we have all four

00:11:45,360 --> 00:11:51,810
objects we have our functions our

00:11:48,630 --> 00:11:53,550
function and these objects are equipped

00:11:51,810 --> 00:11:56,130
with the property first and last name

00:11:53,550 --> 00:11:58,590
and they are passed as arguments to this

00:11:56,130 --> 00:12:02,940
function so what the interpreter now has

00:11:58,590 --> 00:12:07,310
to do is since JavaScript is not static

00:12:02,940 --> 00:12:10,800
typed you can pass actually each kind of

00:12:07,310 --> 00:12:14,520
type object you want and the interpreter

00:12:10,800 --> 00:12:18,120
Noah is the hard task to search for this

00:12:14,520 --> 00:12:20,520
property and and if we think that in

00:12:18,120 --> 00:12:21,740
JavaScript we have this prototype chain

00:12:20,520 --> 00:12:24,020
and the proper

00:12:21,740 --> 00:12:26,090
it can be somewhere we also have getter

00:12:24,020 --> 00:12:29,780
methods we have praxis and other things

00:12:26,090 --> 00:12:32,240
so this property lookup is really quite

00:12:29,780 --> 00:12:34,580
an expensive task and therefore no

00:12:32,240 --> 00:12:38,770
wonder that this that the execution is

00:12:34,580 --> 00:12:43,310
very slow now with the release of create

00:12:38,770 --> 00:12:47,300
something new was introduced namely the

00:12:43,310 --> 00:12:49,880
concept of a hidden class and what the

00:12:47,300 --> 00:12:52,040
engine or thus it tries to assign a

00:12:49,880 --> 00:12:56,120
so-called hidden class to each object

00:12:52,040 --> 00:12:58,820
and the criteria if objects share the

00:12:56,120 --> 00:13:01,220
same hidden class is that they must have

00:12:58,820 --> 00:13:05,090
the same properties but the properties

00:13:01,220 --> 00:13:07,430
must also be in the same order and since

00:13:05,090 --> 00:13:09,440
this is the case so all of our objects

00:13:07,430 --> 00:13:11,330
have property first name last name first

00:13:09,440 --> 00:13:13,370
image in the first place last name is in

00:13:11,330 --> 00:13:15,830
the second place they all share this

00:13:13,370 --> 00:13:18,670
hidden class the same in the class and

00:13:15,830 --> 00:13:22,040
additionally on the function called

00:13:18,670 --> 00:13:24,140
position side the engine now is

00:13:22,040 --> 00:13:26,960
recording the parameters that are passed

00:13:24,140 --> 00:13:29,240
to this function and records actually

00:13:26,960 --> 00:13:32,690
the hidden classes that are executed

00:13:29,240 --> 00:13:37,100
that are passed still as we are in the

00:13:32,690 --> 00:13:39,020
interpretation phase the code is slow so

00:13:37,100 --> 00:13:43,580
if the engine now decides that it is

00:13:39,020 --> 00:13:45,440
time to compile this function get named

00:13:43,580 --> 00:13:49,430
because it is called very often in our

00:13:45,440 --> 00:13:52,040
case 1 billion times it passes the

00:13:49,430 --> 00:13:54,940
function as well as the profiling

00:13:52,040 --> 00:13:58,880
information it has onto the compiler

00:13:54,940 --> 00:14:01,850
usually or in v8 it does not pass the

00:13:58,880 --> 00:14:04,990
actual JavaScript source code but the

00:14:01,850 --> 00:14:08,900
some bytecode it already got from the

00:14:04,990 --> 00:14:10,640
interpreter still the compiler now has

00:14:08,900 --> 00:14:12,700
first of all the function it has to

00:14:10,640 --> 00:14:16,550
compile and it also has the information

00:14:12,700 --> 00:14:19,630
how this function is used and what does

00:14:16,550 --> 00:14:24,290
know it says ok I see that you are only

00:14:19,630 --> 00:14:26,270
passing me this hidden class p1 so in

00:14:24,290 --> 00:14:26,910
that case I actually don't need to

00:14:26,270 --> 00:14:28,770
search

00:14:26,910 --> 00:14:31,260
anymore for the property because I know

00:14:28,770 --> 00:14:34,440
it's just there and I only returned it

00:14:31,260 --> 00:14:36,630
because the engine or the compiler knows

00:14:34,440 --> 00:14:39,810
already where the properties are in

00:14:36,630 --> 00:14:42,200
these classes so the situation now looks

00:14:39,810 --> 00:14:45,900
like following we have an optimized

00:14:42,200 --> 00:14:47,940
function that also works works with the

00:14:45,900 --> 00:14:50,160
hidden class and it doesn't need to look

00:14:47,940 --> 00:14:53,130
up to look to look up the property

00:14:50,160 --> 00:14:55,770
anymore this is how inline caching works

00:14:53,130 --> 00:14:59,250
and this one's called monomorphic in

00:14:55,770 --> 00:15:02,550
like ash because the function is called

00:14:59,250 --> 00:15:05,400
with a single hidden class only so there

00:15:02,550 --> 00:15:10,020
might be a situation and that's what we

00:15:05,400 --> 00:15:12,210
experienced before that there are other

00:15:10,020 --> 00:15:14,250
that there are more hidden classes so in

00:15:12,210 --> 00:15:17,520
our case I have edited this property

00:15:14,250 --> 00:15:20,640
spaceship to the object on now our

00:15:17,520 --> 00:15:24,900
engine and said ok this is a new

00:15:20,640 --> 00:15:27,240
property so it cannot be p1 anymore and

00:15:24,900 --> 00:15:34,350
it has to create a new hidden class in

00:15:27,240 --> 00:15:39,660
this case I call it v2 and and compiled

00:15:34,350 --> 00:15:41,700
code or the optimized code now has to it

00:15:39,660 --> 00:15:44,550
has to make some additional steps it

00:15:41,700 --> 00:15:47,520
first has to check if the past object is

00:15:44,550 --> 00:15:49,440
of type t1 then it returns the property

00:15:47,520 --> 00:15:53,340
or it knows from view on already if it

00:15:49,440 --> 00:15:55,170
is from p2 and this results in a slight

00:15:53,340 --> 00:15:59,570
performance drop as we have seen in the

00:15:55,170 --> 00:15:59,570
beginning about 50% in our example

00:15:59,870 --> 00:16:05,760
saying this again and there is this

00:16:03,750 --> 00:16:08,190
monomorphic type where only a single

00:16:05,760 --> 00:16:11,040
headman classes passed I have here some

00:16:08,190 --> 00:16:14,430
kind of duration we have two polymorphic

00:16:11,040 --> 00:16:17,520
inline caching type and there it only

00:16:14,430 --> 00:16:21,450
applies if the class amount is two or

00:16:17,520 --> 00:16:26,070
four and execution time here is a little

00:16:21,450 --> 00:16:28,350
bit slower but starting from fifth class

00:16:26,070 --> 00:16:31,110
so if your function is getting more than

00:16:28,350 --> 00:16:33,660
four hidden classes passed then the

00:16:31,110 --> 00:16:36,020
England Nealon caches which is over to

00:16:33,660 --> 00:16:41,270
the so-called mega morphic in

00:16:36,020 --> 00:16:43,640
and and what what's done here is that it

00:16:41,270 --> 00:16:45,950
actually really remembers the first four

00:16:43,640 --> 00:16:48,380
hidden classes that are passed but for

00:16:45,950 --> 00:16:51,560
all the other ones it has to look up the

00:16:48,380 --> 00:16:53,959
properties in a more global map so it

00:16:51,560 --> 00:16:56,810
still does not need to search for the

00:16:53,959 --> 00:16:59,600
property every time there is a map that

00:16:56,810 --> 00:17:01,910
this is all stored but still this lock

00:16:59,600 --> 00:17:04,130
up my thought is quite expensive and as

00:17:01,910 --> 00:17:10,100
we have seen this is where we went up

00:17:04,130 --> 00:17:14,290
from 2.4 seconds to 80 so as we now know

00:17:10,100 --> 00:17:19,459
what the problem is how can we solve it

00:17:14,290 --> 00:17:21,740
just to verify again we have here are

00:17:19,459 --> 00:17:24,589
five objects and then find as I've said

00:17:21,740 --> 00:17:26,059
before starting with five objects you

00:17:24,589 --> 00:17:30,580
are in a mega morph aching language

00:17:26,059 --> 00:17:32,990
which is a drastic performance hit and

00:17:30,580 --> 00:17:35,570
what I have to do now is that I am

00:17:32,990 --> 00:17:37,370
actually or I have to drop the this

00:17:35,570 --> 00:17:39,830
schema-less feature that I have from the

00:17:37,370 --> 00:17:41,840
database what I have to do mean is that

00:17:39,830 --> 00:17:44,570
there are many options but this is the

00:17:41,840 --> 00:17:47,900
option I would prefer is that we create

00:17:44,570 --> 00:17:50,720
a class person and we add in the

00:17:47,900 --> 00:17:54,140
constructor of this class all properties

00:17:50,720 --> 00:17:55,420
that are actually possible this right

00:17:54,140 --> 00:17:58,839
now

00:17:55,420 --> 00:17:58,839
[Music]

00:18:25,129 --> 00:18:36,929
spaceship so as I said I'm not adding

00:18:32,939 --> 00:18:40,109
all Possible's possible properties with

00:18:36,929 --> 00:18:43,679
this constructor and I'm assigning them

00:18:40,109 --> 00:18:47,159
so I'm saying this first name this first

00:18:43,679 --> 00:18:50,689
name and so on and since I think we are

00:18:47,159 --> 00:18:54,659
already out of time I'm just calling the

00:18:50,689 --> 00:18:57,779
existing solution so this is as it looks

00:18:54,659 --> 00:19:00,839
if I would have more time to write it so

00:18:57,779 --> 00:19:02,639
we have here or a constructor and we are

00:19:00,839 --> 00:19:04,979
calling here or we instantiate in here

00:19:02,639 --> 00:19:07,559
these classes and as you can see it does

00:19:04,979 --> 00:19:09,779
not really matter if we are calling if

00:19:07,559 --> 00:19:12,029
we are setting at the property to now

00:19:09,779 --> 00:19:13,529
what's important is that the properties

00:19:12,029 --> 00:19:16,919
exist and that they are in the same

00:19:13,529 --> 00:19:20,729
order and if I'm executing this

00:19:16,919 --> 00:19:23,999
counterpart then we see that we are

00:19:20,729 --> 00:19:28,889
again at this speed phone of 112 three

00:19:23,999 --> 00:19:35,519
seconds it's clear so far

00:19:28,889 --> 00:19:37,769
and we come the final last slide as only

00:19:35,519 --> 00:19:40,559
final twice as I have shown now is if

00:19:37,769 --> 00:19:42,059
you can use classes instead of object

00:19:40,559 --> 00:19:44,729
literals if you can't there are other

00:19:42,059 --> 00:19:46,289
ways you can use object design but with

00:19:44,729 --> 00:19:48,389
object design you have to be a little

00:19:46,289 --> 00:19:52,079
bit careful since object design internal

00:19:48,389 --> 00:19:54,329
it's the property sequentially so it can

00:19:52,079 --> 00:19:55,949
be the case that that you have the same

00:19:54,329 --> 00:19:58,819
properties but they are not in the same

00:19:55,949 --> 00:20:01,679
order then you see another problem

00:19:58,819 --> 00:20:04,559
furthermore user transpiler that allows

00:20:01,679 --> 00:20:06,509
you to program the transpires javascript

00:20:04,559 --> 00:20:08,639
but allows you to develop with static

00:20:06,509 --> 00:20:13,499
types typescript might be a good option

00:20:08,639 --> 00:20:16,049
for that and last but not least if you

00:20:13,499 --> 00:20:17,489
interested in the engines it's quite

00:20:16,049 --> 00:20:18,150
good to know what they are doing but

00:20:17,489 --> 00:20:20,220
please

00:20:18,150 --> 00:20:22,560
never try to outsmart the engine or

00:20:20,220 --> 00:20:25,860
trick it in some ways it's always a bad

00:20:22,560 --> 00:20:27,220
idea and by that they say think you own

00:20:25,860 --> 00:20:31,180
targets

00:20:27,220 --> 00:20:31,180

YouTube URL: https://www.youtube.com/watch?v=SyIO2RzXs-Q


