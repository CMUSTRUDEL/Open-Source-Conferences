Title: ViennaJS, JavaScript at Blazing Speed, March 2018
Publication date: 2018-04-05
Playlist: viennaJS
Description: 
	Talk by Michael Starzinger:
This talk takes you on a deep dive into the inner workings of V8, the high-performance JavaScript engine powering Chrome and Node.js, focusing especially on the compilation aspects.
Captions: 
	00:00:00,020 --> 00:00:05,009
I'm Michel shots new from I work as a

00:00:03,149 --> 00:00:08,429
software engineer at Google I work on

00:00:05,009 --> 00:00:09,750
the v8 team v8 is Tim for those who

00:00:08,429 --> 00:00:12,440
don't know is the JavaScript engine

00:00:09,750 --> 00:00:14,570
that's powering Chrome and no chance

00:00:12,440 --> 00:00:18,060
I've been working for Google for

00:00:14,570 --> 00:00:19,949
seven years now and fun fact before that

00:00:18,060 --> 00:00:22,410
I actually lived in Vienna for I think

00:00:19,949 --> 00:00:23,640
eight years so being able to talk here

00:00:22,410 --> 00:00:25,439
and then being invited here actually

00:00:23,640 --> 00:00:26,849
brings back fond memories so that's

00:00:25,439 --> 00:00:29,400
great

00:00:26,849 --> 00:00:32,250
before v8 I worked on an open source

00:00:29,400 --> 00:00:34,620
java vm so anything to do with compilers

00:00:32,250 --> 00:00:38,489
or virtual machines is super interesting

00:00:34,620 --> 00:00:40,700
for me so I love it all right but enough

00:00:38,489 --> 00:00:42,989
about me let's talk about v8 actually

00:00:40,700 --> 00:00:48,809
the things I want to talk about today

00:00:42,989 --> 00:00:54,239
are our new compilation yes does it work

00:00:48,809 --> 00:00:57,840
our new compilation pipeline our

00:00:54,239 --> 00:01:01,170
compilation pipeline is basically a tale

00:00:57,840 --> 00:01:03,149
of two compilation tears and compilation

00:01:01,170 --> 00:01:06,240
tears are basically basically levels of

00:01:03,149 --> 00:01:13,100
optimization that we can apply to to

00:01:06,240 --> 00:01:13,100
your JavaScript application yeah

00:01:13,850 --> 00:01:20,759
also the optimizing compiler that we use

00:01:17,390 --> 00:01:23,220
uses speculative optimizations so I want

00:01:20,759 --> 00:01:25,049
to talk about that a little bit and how

00:01:23,220 --> 00:01:27,090
it's based on feedback because that

00:01:25,049 --> 00:01:29,009
might be interesting for for application

00:01:27,090 --> 00:01:32,579
developers how we actually optimize the

00:01:29,009 --> 00:01:34,560
JavaScript code and one particular

00:01:32,579 --> 00:01:36,869
optimization I want to go through is

00:01:34,560 --> 00:01:39,000
inlining because it's it's the mother of

00:01:36,869 --> 00:01:41,130
all optimizations so to say it enables a

00:01:39,000 --> 00:01:43,409
lot of other optimizations and then in

00:01:41,130 --> 00:01:46,049
the second half we'll look at two

00:01:43,409 --> 00:01:47,579
examples first one is a higher or it's

00:01:46,049 --> 00:01:50,070
the inlining of higher order built

00:01:47,579 --> 00:01:53,310
instead we do and the second one is

00:01:50,070 --> 00:01:55,939
JavaScript generators so then we'll keep

00:01:53,310 --> 00:02:00,180
us busy for a while

00:01:55,939 --> 00:02:02,840
yep all right let's serve if the

00:02:00,180 --> 00:02:06,299
compilation pipeline as I said it's a

00:02:02,840 --> 00:02:08,940
tale of two compilation tiers the two

00:02:06,299 --> 00:02:11,030
tiers are made up of two big components

00:02:08,940 --> 00:02:13,830
two main components one is called

00:02:11,030 --> 00:02:15,420
ignition it's a bytecode interpreter

00:02:13,830 --> 00:02:19,230
and the second one is called turbofan

00:02:15,420 --> 00:02:22,350
it's the optimizing compiler so bytecode

00:02:19,230 --> 00:02:24,390
interpreter actually means we transform

00:02:22,350 --> 00:02:27,650
JavaScript into bytecode and then

00:02:24,390 --> 00:02:29,700
interpret it so it's not initially

00:02:27,650 --> 00:02:31,740
transformed into machine code but

00:02:29,700 --> 00:02:34,490
bytecode and we run an interpreter on

00:02:31,740 --> 00:02:36,360
that and that whole process

00:02:34,490 --> 00:02:38,810
transformation into bytecode and

00:02:36,360 --> 00:02:41,430
interpretation is called ignition and

00:02:38,810 --> 00:02:43,170
then we have the second tier turbofan

00:02:41,430 --> 00:02:44,880
which is an optimizing compiler so that

00:02:43,170 --> 00:02:50,820
one actually generates native machine

00:02:44,880 --> 00:02:53,310
code so why do we have these two big

00:02:50,820 --> 00:02:55,040
things why do we need two compilation

00:02:53,310 --> 00:02:58,050
tiers

00:02:55,040 --> 00:03:01,590
we don't just add those because we like

00:02:58,050 --> 00:03:03,600
complexity so much but there is a

00:03:01,590 --> 00:03:06,780
certain trade-off between those two

00:03:03,600 --> 00:03:09,780
things ignition on the one hand provides

00:03:06,780 --> 00:03:12,780
us with a fast startup it has a low

00:03:09,780 --> 00:03:14,550
memory footprint and so we we get to

00:03:12,780 --> 00:03:17,040
execute the application of JavaScript

00:03:14,550 --> 00:03:19,170
application quickly we don't use much

00:03:17,040 --> 00:03:23,100
memory and we kind of can observe it for

00:03:19,170 --> 00:03:26,580
a while and also ignition handles all

00:03:23,100 --> 00:03:28,530
cases so that means whatever crazy thing

00:03:26,580 --> 00:03:29,940
the application throws at us we can

00:03:28,530 --> 00:03:32,040
handle it

00:03:29,940 --> 00:03:34,709
turbofan on the other hand requires a

00:03:32,040 --> 00:03:36,720
certain time of warm-up so it requires

00:03:34,709 --> 00:03:39,510
the application to run for a while for

00:03:36,720 --> 00:03:41,550
us to observe it and to then optimize it

00:03:39,510 --> 00:03:44,190
and that means we take longer to

00:03:41,550 --> 00:03:46,140
actually compile the application and we

00:03:44,190 --> 00:03:47,550
only want to do that on a certain subset

00:03:46,140 --> 00:03:49,260
of your application we don't want to

00:03:47,550 --> 00:03:52,820
optimize everything because that would

00:03:49,260 --> 00:03:55,050
just take away too many resources and

00:03:52,820 --> 00:03:57,989
turbofan is the thing provides peak

00:03:55,050 --> 00:03:59,970
performance we take the pieces of your

00:03:57,989 --> 00:04:02,880
application that are really hot really

00:03:59,970 --> 00:04:07,080
important and spend time on optimizing

00:04:02,880 --> 00:04:12,150
those so JavaScript initially is fed

00:04:07,080 --> 00:04:14,730
into ignition the unit of compilation

00:04:12,150 --> 00:04:17,580
for for ignition is a function so we

00:04:14,730 --> 00:04:19,620
compile one function at a time we parse

00:04:17,580 --> 00:04:21,419
the entire script but we look at one

00:04:19,620 --> 00:04:24,000
function at a time compile that to

00:04:21,419 --> 00:04:25,620
bytecode and then start running it we do

00:04:24,000 --> 00:04:26,520
that lazily that means we don't do it

00:04:25,620 --> 00:04:28,979
for the entire script

00:04:26,520 --> 00:04:30,180
once but we do it for the function that

00:04:28,979 --> 00:04:32,669
is called first

00:04:30,180 --> 00:04:34,410
and whenever lab function calls another

00:04:32,669 --> 00:04:38,180
one we look at that one so it's

00:04:34,410 --> 00:04:40,349
basically the cost of compilation is

00:04:38,180 --> 00:04:42,270
distributed a little bit because we only

00:04:40,349 --> 00:04:43,680
need to look at one function at a time

00:04:42,270 --> 00:04:48,060
and don't stall the system for the

00:04:43,680 --> 00:04:50,789
entire script what ignition produces is

00:04:48,060 --> 00:04:55,520
as I said bytecode this bytecode is then

00:04:50,789 --> 00:04:58,560
interpreted and ignition also does

00:04:55,520 --> 00:05:01,050
there's additional work that it would

00:04:58,560 --> 00:05:03,210
not need to do if turbofan was not

00:05:01,050 --> 00:05:06,419
around so you see this this nice gift

00:05:03,210 --> 00:05:09,000
package at the bottom feedback ignition

00:05:06,419 --> 00:05:11,069
collects feedback so we observe the

00:05:09,000 --> 00:05:12,630
application and we look how it behaves

00:05:11,069 --> 00:05:16,229
how certain pieces of the application

00:05:12,630 --> 00:05:17,520
behave and just for ignition sake we

00:05:16,229 --> 00:05:21,889
wouldn't need that but we need it to

00:05:17,520 --> 00:05:24,629
later on optimize the code with turbofan

00:05:21,889 --> 00:05:27,030
so what true fan Lang consumes is this

00:05:24,629 --> 00:05:29,370
feedback but also the bytecode so

00:05:27,030 --> 00:05:31,530
turbofan actually no longer looks at the

00:05:29,370 --> 00:05:33,509
source code at the JavaScript source

00:05:31,530 --> 00:05:36,300
code it Just's based on this

00:05:33,509 --> 00:05:38,729
intermediate bytecode that we that we

00:05:36,300 --> 00:05:44,449
compiled that has several advantages one

00:05:38,729 --> 00:05:46,919
is if we decide to do sugar certain

00:05:44,449 --> 00:05:48,810
language features on the bytecode level

00:05:46,919 --> 00:05:50,279
turbofan no long has to worry about them

00:05:48,810 --> 00:05:52,440
so we can basically reduce the

00:05:50,279 --> 00:05:54,870
complexity of the JavaScript application

00:05:52,440 --> 00:05:56,520
a little bit make simple a bytecode out

00:05:54,870 --> 00:06:00,449
of it and turbofan only has to worry

00:05:56,520 --> 00:06:02,130
about this simple bytecode and what

00:06:00,449 --> 00:06:05,819
turbofan generates is actual machine

00:06:02,130 --> 00:06:09,090
code so it's actually natively running

00:06:05,819 --> 00:06:11,610
on the processor and hopefully gets

00:06:09,090 --> 00:06:14,909
almost close to native speed so that's

00:06:11,610 --> 00:06:17,009
basically the holy grail of the of the

00:06:14,909 --> 00:06:22,349
compilation pipeline to approach native

00:06:17,009 --> 00:06:24,419
speed all right let's take a look at one

00:06:22,349 --> 00:06:27,500
example so this is super trivial example

00:06:24,419 --> 00:06:29,909
but stick with me it gets it gets tricky

00:06:27,500 --> 00:06:32,550
the addition function that you see is

00:06:29,909 --> 00:06:35,099
basically just containing 1/1 arithmetic

00:06:32,550 --> 00:06:36,960
operation 1 addition of two arguments

00:06:35,099 --> 00:06:38,399
that come in and it's called from

00:06:36,960 --> 00:06:40,270
another function so let's first look

00:06:38,399 --> 00:06:44,500
just at the first function

00:06:40,270 --> 00:06:46,930
just edition function what does an

00:06:44,500 --> 00:06:49,540
edition do as long as we all know it's

00:06:46,930 --> 00:06:52,510
overloaded so it can do string addition

00:06:49,540 --> 00:06:55,780
it could be an arithmetic addition but

00:06:52,510 --> 00:06:58,210
it can also convert objects into

00:06:55,780 --> 00:06:59,260
primitive values and what we see on the

00:06:58,210 --> 00:07:01,930
right-hand side is actually the

00:06:59,260 --> 00:07:04,600
specification so that's what Aquino

00:07:01,930 --> 00:07:06,430
script standard dictates that a Java

00:07:04,600 --> 00:07:08,950
Script a faithful ACMA script

00:07:06,430 --> 00:07:14,740
implementation should do add an addition

00:07:08,950 --> 00:07:18,220
and the actual the actual addition is

00:07:14,740 --> 00:07:20,740
step 10 so all of the steps before our

00:07:18,220 --> 00:07:23,080
preparations to actually perform the the

00:07:20,740 --> 00:07:25,150
arithmetic operation and you can see

00:07:23,080 --> 00:07:27,520
that there are certain things that are

00:07:25,150 --> 00:07:29,920
specific to strings but also these two

00:07:27,520 --> 00:07:32,980
primitive calls that are always kind of

00:07:29,920 --> 00:07:35,830
expected to be done by us so okay if we

00:07:32,980 --> 00:07:37,870
want to compile it we have to somehow

00:07:35,830 --> 00:07:42,580
implement that so let's look at what two

00:07:37,870 --> 00:07:45,220
primitive actually does two primitive in

00:07:42,580 --> 00:07:48,280
the end actually gets a method on the

00:07:45,220 --> 00:07:51,310
potential object that you pass in to be

00:07:48,280 --> 00:07:53,410
able to call and a user-provided method

00:07:51,310 --> 00:07:56,890
to convert something to a primitive okay

00:07:53,410 --> 00:07:58,720
so we get a method how do we get a

00:07:56,890 --> 00:08:00,040
method get' method actually means we

00:07:58,720 --> 00:08:02,590
need to do a property look or

00:08:00,040 --> 00:08:05,410
potentially on the object right so okay

00:08:02,590 --> 00:08:08,440
what does property look at me well okay

00:08:05,410 --> 00:08:11,140
property lookup we need to potentially

00:08:08,440 --> 00:08:12,910
go up the prototype chain actually do

00:08:11,140 --> 00:08:14,620
multiple gets here that's the yellow

00:08:12,910 --> 00:08:16,840
part that you can barely see there again

00:08:14,620 --> 00:08:19,210
and okay all of this is way too crazy

00:08:16,840 --> 00:08:22,690
already for for it to be to be efficient

00:08:19,210 --> 00:08:24,210
and fast so if we want to optimize we

00:08:22,690 --> 00:08:26,470
actually don't want to do any of this

00:08:24,210 --> 00:08:28,570
what do we want to do is don't care

00:08:26,470 --> 00:08:30,970
about this we only want to do the

00:08:28,570 --> 00:08:33,310
addition and to some degree that's

00:08:30,970 --> 00:08:35,590
actually what happens what we do is we

00:08:33,310 --> 00:08:38,590
make some speculative assumptions about

00:08:35,590 --> 00:08:43,510
the input about the left value X and the

00:08:38,590 --> 00:08:45,520
right value Y and that's where this

00:08:43,510 --> 00:08:48,700
combination of these two tiers helps us

00:08:45,520 --> 00:08:50,650
so as I said ignition gathers feedback

00:08:48,700 --> 00:08:52,270
so it kind of knew okay I only saw

00:08:50,650 --> 00:08:56,320
numbers at least the

00:08:52,270 --> 00:08:58,180
at this edition site and it tells the

00:08:56,320 --> 00:08:59,500
optimizing compiler hey you only have to

00:08:58,180 --> 00:09:02,440
worry about numbers because I saw

00:08:59,500 --> 00:09:05,170
numbers 500 times so there will not be a

00:09:02,440 --> 00:09:07,060
string around to roofin it like yes can

00:09:05,170 --> 00:09:09,540
do that and K and turbofan generates

00:09:07,060 --> 00:09:11,950
highly optimized code for exactly depth

00:09:09,540 --> 00:09:13,779
that kind of situation because their

00:09:11,950 --> 00:09:16,720
port was the situation it was observed

00:09:13,779 --> 00:09:18,339
before but then on the five hundred and

00:09:16,720 --> 00:09:19,990
first iteration it might be that you

00:09:18,339 --> 00:09:22,240
suddenly pass in a string or an object

00:09:19,990 --> 00:09:24,190
and that's where it gets a little bit

00:09:22,240 --> 00:09:26,890
hairy because then turbofan is out of

00:09:24,190 --> 00:09:29,529
luck turbofan is like I I don't know how

00:09:26,890 --> 00:09:33,910
to handle strings so it needs to be

00:09:29,529 --> 00:09:35,470
optimized back to ignition and you

00:09:33,910 --> 00:09:38,380
already see that there is a cycle

00:09:35,470 --> 00:09:41,290
forming here so if we are not careful we

00:09:38,380 --> 00:09:44,170
basically could run in cycles for a long

00:09:41,290 --> 00:09:46,270
time and we need to prevent it because

00:09:44,170 --> 00:09:50,529
every time we optimize we need to spend

00:09:46,270 --> 00:09:52,120
a lot of time to to to perform smart

00:09:50,529 --> 00:09:54,430
optimizations in the compiler and that

00:09:52,120 --> 00:09:56,920
takes memory on a phone that takes

00:09:54,430 --> 00:09:59,350
battery power so we need to be really

00:09:56,920 --> 00:10:01,480
careful that every time we go around

00:09:59,350 --> 00:10:03,670
this circle we actually learn something

00:10:01,480 --> 00:10:05,709
new so the next time we go around the

00:10:03,670 --> 00:10:07,390
circle ignitions needs to tell turbofan

00:10:05,709 --> 00:10:11,020
hey you need to worry about numbers and

00:10:07,390 --> 00:10:12,880
strings because I've seen both and we

00:10:11,020 --> 00:10:15,270
had the optimization loops that's what

00:10:12,880 --> 00:10:17,800
we call them a lot in the past so that

00:10:15,270 --> 00:10:19,600
that that's the situation when you don't

00:10:17,800 --> 00:10:20,880
learn and when you just run around in

00:10:19,600 --> 00:10:26,500
circles and spend all of your time

00:10:20,880 --> 00:10:30,520
optimizing and optimizing alright so

00:10:26,500 --> 00:10:34,899
back to this example so far we only have

00:10:30,520 --> 00:10:36,640
looked at the ad function but if we look

00:10:34,899 --> 00:10:38,290
a little bit broader if we look at the

00:10:36,640 --> 00:10:41,200
entire script or at least the two

00:10:38,290 --> 00:10:43,779
functions we can actually see that we

00:10:41,200 --> 00:10:46,720
can be way smarter because not only do

00:10:43,779 --> 00:10:50,200
we know that we pass numbers in we pass

00:10:46,720 --> 00:10:52,089
actual constants in and so let's where

00:10:50,200 --> 00:10:55,029
in lining comes into place so if we were

00:10:52,089 --> 00:10:57,640
to inline the addition function into the

00:10:55,029 --> 00:11:01,390
F function we could actually look at two

00:10:57,640 --> 00:11:03,190
functions at once so initially I said we

00:11:01,390 --> 00:11:05,170
look at one function at a time but

00:11:03,190 --> 00:11:06,120
turbofan actually can perform inlining

00:11:05,170 --> 00:11:07,620
so there we can look

00:11:06,120 --> 00:11:10,680
two functions at a time or multiple

00:11:07,620 --> 00:11:13,140
functions at a time all right so so far

00:11:10,680 --> 00:11:16,350
all we saved is one function call so

00:11:13,140 --> 00:11:17,730
that's not that big of a deal so why is

00:11:16,350 --> 00:11:19,830
inlining called the mother of all

00:11:17,730 --> 00:11:22,529
optimizations if it's if it's just

00:11:19,830 --> 00:11:25,529
saving as function calls the reason is

00:11:22,529 --> 00:11:27,600
that inlining enables us to have a

00:11:25,529 --> 00:11:30,029
broader scope it brought a view of the

00:11:27,600 --> 00:11:33,240
of the application and thereby enables

00:11:30,029 --> 00:11:35,700
other further optimizations to apply so

00:11:33,240 --> 00:11:39,630
inlining runs pretty early in the in the

00:11:35,700 --> 00:11:41,810
compilation phase and then enables a lot

00:11:39,630 --> 00:11:45,180
of the powerful optimizations come later

00:11:41,810 --> 00:11:48,750
to have more impact to basically apply

00:11:45,180 --> 00:11:50,339
to a broader range and in this case one

00:11:48,750 --> 00:11:52,290
search optimization would be constant

00:11:50,339 --> 00:11:54,380
folding so we could just see now Oh in

00:11:52,290 --> 00:11:57,000
this one combined function that we have

00:11:54,380 --> 00:11:58,770
we see two constants they're being added

00:11:57,000 --> 00:12:00,870
we don't need to worry about string or

00:11:58,770 --> 00:12:02,700
too primitive conversion because we know

00:12:00,870 --> 00:12:07,080
there are primitive numbers so we can

00:12:02,700 --> 00:12:09,060
just constant fold them and that's

00:12:07,080 --> 00:12:14,100
basically in a nutshell what turbofan

00:12:09,060 --> 00:12:18,000
does kind of okay I took a lot of slides

00:12:14,100 --> 00:12:20,670
to to to just to just explain that one

00:12:18,000 --> 00:12:22,589
of my colleagues addy Osmani actually

00:12:20,670 --> 00:12:27,450
can do that in one slide so that's the

00:12:22,589 --> 00:12:30,120
recap we take your JavaScript we parse

00:12:27,450 --> 00:12:31,709
it then one function at a time we build

00:12:30,120 --> 00:12:34,050
abstract syntax tree and generate

00:12:31,709 --> 00:12:37,290
bytecode out of it we run it for a while

00:12:34,050 --> 00:12:39,720
to gather feedback once we got feedback

00:12:37,290 --> 00:12:43,260
for these speculative optimizations we

00:12:39,720 --> 00:12:45,870
if it pays off if we deem the function

00:12:43,260 --> 00:12:47,970
to be hot we run it through turbofan

00:12:45,870 --> 00:12:50,190
optimize it and compile it to actual

00:12:47,970 --> 00:12:52,230
machine code so thing that comes out is

00:12:50,190 --> 00:12:55,860
then specific to the underlying hardware

00:12:52,230 --> 00:12:58,550
that you're running on and the eight

00:12:55,860 --> 00:13:01,140
currently supports eight architectures

00:12:58,550 --> 00:13:05,940
I'll leave it as an exercise for the

00:13:01,140 --> 00:13:07,740
listener to figure out which one's all

00:13:05,940 --> 00:13:12,390
right so that's the compilation pipeline

00:13:07,740 --> 00:13:14,970
so far which we overhauled the

00:13:12,390 --> 00:13:17,850
compilation pipeline over the last

00:13:14,970 --> 00:13:19,160
year's so turbofan is a fairly new

00:13:17,850 --> 00:13:21,139
compiler again

00:13:19,160 --> 00:13:23,540
is a fairly new bytecode interpreter

00:13:21,139 --> 00:13:29,480
what I mean by that is they're shipping

00:13:23,540 --> 00:13:32,000
for at most a year now both of them my

00:13:29,480 --> 00:13:33,920
personal definition for success that I

00:13:32,000 --> 00:13:36,079
always looked forward to in the in the

00:13:33,920 --> 00:13:37,610
years I've worked on turbofan was once

00:13:36,079 --> 00:13:41,089
we can inline higher order air a

00:13:37,610 --> 00:13:45,439
built-ins I can declare success and we

00:13:41,089 --> 00:13:49,519
can do this now so yeah alright let's

00:13:45,439 --> 00:13:52,310
look at higher or built-ins another

00:13:49,519 --> 00:13:57,829
example let's look at the reduced

00:13:52,310 --> 00:14:00,009
building of an array reduces is we've

00:13:57,829 --> 00:14:02,269
reduced you can for example Express

00:14:00,009 --> 00:14:04,759
summation function so you have an array

00:14:02,269 --> 00:14:07,129
of full of numbers and you want to just

00:14:04,759 --> 00:14:08,899
calculate the sum of it what you would

00:14:07,129 --> 00:14:13,790
write is potentially something like this

00:14:08,899 --> 00:14:15,829
you provide a function to this higher or

00:14:13,790 --> 00:14:19,579
in a built-in namely the arrow function

00:14:15,829 --> 00:14:21,319
that just takes an accumulator and some

00:14:19,579 --> 00:14:23,329
value and adds those two together and

00:14:21,319 --> 00:14:25,339
you provide a starting value then you

00:14:23,329 --> 00:14:28,790
start with zero and just add on top of

00:14:25,339 --> 00:14:33,680
zero for example the array 1 to 3 would

00:14:28,790 --> 00:14:40,069
yield a sum of 6 all right so how do we

00:14:33,680 --> 00:14:48,889
how does turbofan optimize this now

00:14:40,069 --> 00:14:50,630
let's go fishing if you would to met if

00:14:48,889 --> 00:14:52,100
you were to manually optimize this

00:14:50,630 --> 00:14:55,100
function you would write something like

00:14:52,100 --> 00:14:58,189
this and you'll for loop with an index

00:14:55,100 --> 00:15:00,230
you would iterate over it and you would

00:14:58,189 --> 00:15:04,550
also have some accumulator called sum in

00:15:00,230 --> 00:15:05,930
this in this case and yeah so that

00:15:04,550 --> 00:15:08,689
that's basically if you were to hand

00:15:05,930 --> 00:15:11,569
manually optimize it now the question is

00:15:08,689 --> 00:15:13,939
can turbofan actually reduce the left

00:15:11,569 --> 00:15:15,740
hand side down to this and the next few

00:15:13,939 --> 00:15:19,189
slides are to convince you that it

00:15:15,740 --> 00:15:24,079
actually can I think so let's look at

00:15:19,189 --> 00:15:26,230
the spec of reduce again crazy stuff

00:15:24,079 --> 00:15:28,880
going on there a lot of additional

00:15:26,230 --> 00:15:30,860
additional things that we didn't see in

00:15:28,880 --> 00:15:32,600
the hand conversion and the reason for

00:15:30,860 --> 00:15:35,480
this is that the spec in

00:15:32,600 --> 00:15:38,149
annalee wants to be generic so you can

00:15:35,480 --> 00:15:42,350
take the the second order the higher

00:15:38,149 --> 00:15:45,470
order built-ins of array and use it on

00:15:42,350 --> 00:15:47,600
other objects you can come up with your

00:15:45,470 --> 00:15:50,240
own array implementation and just use

00:15:47,600 --> 00:15:51,949
the generic array functions and the spec

00:15:50,240 --> 00:15:54,110
actually mentions this in a note so

00:15:51,949 --> 00:15:56,449
there is this one note which says oh

00:15:54,110 --> 00:15:58,819
reduce function is intentionally generic

00:15:56,449 --> 00:16:02,120
it does not require that this value is

00:15:58,819 --> 00:16:04,220
an actual array object so all of the

00:16:02,120 --> 00:16:06,170
craziness that we saw in the in this

00:16:04,220 --> 00:16:08,600
that we see in the specification where

00:16:06,170 --> 00:16:11,509
we have to worry about - string

00:16:08,600 --> 00:16:13,819
conversion the has property is callable

00:16:11,509 --> 00:16:16,759
check all of that is intentionally there

00:16:13,819 --> 00:16:18,410
and people are using these functions in

00:16:16,759 --> 00:16:22,819
a generic way so we need to be faithful

00:16:18,410 --> 00:16:26,170
to respect if we are faithful to the

00:16:22,819 --> 00:16:29,269
spec we end up with something like this

00:16:26,170 --> 00:16:33,259
the function that we passed in is still

00:16:29,269 --> 00:16:36,649
being allocated at the beginning of foo

00:16:33,259 --> 00:16:38,870
we have this addition function then we

00:16:36,649 --> 00:16:40,639
extract the length out of it then we

00:16:38,870 --> 00:16:43,160
actually have to check is the function a

00:16:40,639 --> 00:16:45,920
callable is it callable can we call it

00:16:43,160 --> 00:16:48,850
otherwise we throw a type error and then

00:16:45,920 --> 00:16:52,579
inside the loop you actually see that we

00:16:48,850 --> 00:16:55,069
have to do and check whether the

00:16:52,579 --> 00:16:57,470
property is on the area itself or up the

00:16:55,069 --> 00:17:00,380
prototype chain again that's dictated by

00:16:57,470 --> 00:17:01,880
respects so we have to do that and we

00:17:00,380 --> 00:17:03,920
see that we have a function call in the

00:17:01,880 --> 00:17:05,179
loop so especially the things in the

00:17:03,920 --> 00:17:07,459
loop are worrisome because they

00:17:05,179 --> 00:17:10,970
potentially get executed many many times

00:17:07,459 --> 00:17:13,100
so if we want to really optimize that we

00:17:10,970 --> 00:17:17,089
should get the loop body as empty as

00:17:13,100 --> 00:17:20,179
possible so the first step we see here

00:17:17,089 --> 00:17:22,939
is basically that we in line T did err a

00:17:20,179 --> 00:17:24,770
reduce function itself to roof and at

00:17:22,939 --> 00:17:26,089
that and on the right hand side we now

00:17:24,770 --> 00:17:28,880
see the steps that are applied

00:17:26,089 --> 00:17:31,159
afterwards by turbofan to actually get

00:17:28,880 --> 00:17:35,419
rid of all the overhead that we see in

00:17:31,159 --> 00:17:38,690
there so one such step is for example

00:17:35,419 --> 00:17:42,380
okay the call ability check is now kind

00:17:38,690 --> 00:17:44,299
of redundant because we see that thing

00:17:42,380 --> 00:17:46,010
we're calling is a function so we don't

00:17:44,299 --> 00:17:46,580
need to check this this is basically

00:17:46,010 --> 00:17:52,370
that

00:17:46,580 --> 00:17:55,970
so turbofan can remove it then we

00:17:52,370 --> 00:17:59,600
actually can inline the second call we

00:17:55,970 --> 00:18:01,850
had inside the loop so we can we no

00:17:59,600 --> 00:18:03,680
longer need to actually call a function

00:18:01,850 --> 00:18:05,600
we can take the function body and inline

00:18:03,680 --> 00:18:10,250
it so basically now we are with inline

00:18:05,600 --> 00:18:13,940
twice already so far this only got rid

00:18:10,250 --> 00:18:16,400
of the of the of the call but in a next

00:18:13,940 --> 00:18:21,220
step we can and this requires some

00:18:16,400 --> 00:18:23,320
explanation so we can assume certain

00:18:21,220 --> 00:18:25,820
certain

00:18:23,320 --> 00:18:28,850
certain invariants of the area to hold

00:18:25,820 --> 00:18:31,160
so array internally for us can have

00:18:28,850 --> 00:18:33,770
multiple shapes it can it can contain

00:18:31,160 --> 00:18:36,320
objects it can contain double numbers

00:18:33,770 --> 00:18:39,410
floating-point numbers it can contain

00:18:36,320 --> 00:18:42,110
integers and another aspect it could

00:18:39,410 --> 00:18:43,970
have hold or it can be packed and packed

00:18:42,110 --> 00:18:45,680
means you don't have any holes it's a

00:18:43,970 --> 00:18:50,750
contiguous area it's really something

00:18:45,680 --> 00:18:53,660
that you normally call an array and this

00:18:50,750 --> 00:18:56,210
is pects Maya basically means it's an

00:18:53,660 --> 00:18:58,940
array that is packed that doesn't have

00:18:56,210 --> 00:19:00,860
holes and that contains into integral

00:18:58,940 --> 00:19:03,980
numbers integer numbers so no doubles

00:19:00,860 --> 00:19:05,450
and that holds for the area we saw in

00:19:03,980 --> 00:19:07,970
the example before right because it

00:19:05,450 --> 00:19:10,360
contained one two three nothing else

00:19:07,970 --> 00:19:16,370
so no holes and integer numbers and

00:19:10,360 --> 00:19:18,140
since ignition observed this turbofan

00:19:16,370 --> 00:19:19,910
then relies on it and that that's the

00:19:18,140 --> 00:19:23,360
point where it relies on it it puts in

00:19:19,910 --> 00:19:26,240
checks and if this check fails it D

00:19:23,360 --> 00:19:28,880
optimizes it actually says ok I now need

00:19:26,240 --> 00:19:32,690
to jump back to ignition now initially

00:19:28,880 --> 00:19:35,060
this looks kind of useless because we

00:19:32,690 --> 00:19:37,430
don't gain anything from that itself but

00:19:35,060 --> 00:19:39,620
it's again an enabler for optimizations

00:19:37,430 --> 00:19:42,170
that we apply then so in the next step

00:19:39,620 --> 00:19:42,890
for example we can now see that since it

00:19:42,170 --> 00:19:46,100
is packed

00:19:42,890 --> 00:19:47,900
there cannot be any holes so this check

00:19:46,100 --> 00:19:50,630
whether the property actually is on the

00:19:47,900 --> 00:19:53,060
array or not is now redundant and since

00:19:50,630 --> 00:19:54,500
this check is in the loop this is super

00:19:53,060 --> 00:19:57,320
beneficial because that means on every

00:19:54,500 --> 00:19:59,630
iteration we can assume the element is

00:19:57,320 --> 00:20:00,020
still is in the array we don't need to

00:19:59,630 --> 00:20:02,690
walk

00:20:00,020 --> 00:20:08,120
the prototype chain and everything just

00:20:02,690 --> 00:20:11,120
becomes way simpler and also on top of

00:20:08,120 --> 00:20:12,890
that we can now see that since it

00:20:11,120 --> 00:20:15,610
contains since the area contains

00:20:12,890 --> 00:20:17,809
integral numbers we can actually also do

00:20:15,610 --> 00:20:19,370
addition of numbers so the addition

00:20:17,809 --> 00:20:23,960
again is specialized as we saw in the

00:20:19,370 --> 00:20:26,270
previous in the first example and so by

00:20:23,960 --> 00:20:29,960
now the loop body actually already gets

00:20:26,270 --> 00:20:32,120
smaller and smaller and with the last

00:20:29,960 --> 00:20:34,910
step we can also remove the shape check

00:20:32,120 --> 00:20:36,860
because in the loop body we see that the

00:20:34,910 --> 00:20:38,630
shape of the area cannot change there is

00:20:36,860 --> 00:20:41,030
nothing that writes to the area that

00:20:38,630 --> 00:20:43,610
deletes elements from the array or that

00:20:41,030 --> 00:20:47,570
that somehow changes its shape like for

00:20:43,610 --> 00:20:49,220
example if you were to freeze this array

00:20:47,570 --> 00:20:53,030
this would be a major shape shape change

00:20:49,220 --> 00:20:55,130
for example and so now we can again

00:20:53,030 --> 00:20:59,020
remove a check inside the loop and the

00:20:55,130 --> 00:21:01,790
loop body now is really it's really

00:20:59,020 --> 00:21:03,200
optimal and actually resembles the

00:21:01,790 --> 00:21:10,100
handwritten version that we had before

00:21:03,200 --> 00:21:11,570
and so this is almost the same as we had

00:21:10,100 --> 00:21:18,050
in the handwritten version before and

00:21:11,570 --> 00:21:20,420
actually this Det edition inside if you

00:21:18,050 --> 00:21:22,070
would not inline the area we'd use the

00:21:20,420 --> 00:21:26,000
addition inside would in the handwritten

00:21:22,070 --> 00:21:29,059
example also also be lower to a number

00:21:26,000 --> 00:21:32,830
addition so the loop body is exactly the

00:21:29,059 --> 00:21:32,830
same as we had in a handwritten example

00:21:34,030 --> 00:21:42,290
all right so I threw this at a I wrote a

00:21:40,309 --> 00:21:45,200
simple micro benchmark just for this and

00:21:42,290 --> 00:21:48,500
and measured the difference of the

00:21:45,200 --> 00:21:51,020
handwritten version and the the one that

00:21:48,500 --> 00:21:53,960
is cool called from manual the dark blue

00:21:51,020 --> 00:21:58,340
one and the light blue one is the one

00:21:53,960 --> 00:22:00,380
with with the area reduce and I compared

00:21:58,340 --> 00:22:03,530
an old version of me eight that didn't

00:22:00,380 --> 00:22:06,110
have T the area on the higher-order

00:22:03,530 --> 00:22:08,059
built in in lining and there you see a

00:22:06,110 --> 00:22:11,210
major difference so using the higher or

00:22:08,059 --> 00:22:13,250
the array built-ins cost a major slow

00:22:11,210 --> 00:22:13,670
down there but we have a recent version

00:22:13,250 --> 00:22:17,000
so six

00:22:13,670 --> 00:22:19,670
26s was released I think a week ago or

00:22:17,000 --> 00:22:23,480
two weeks ago you see that there is

00:22:19,670 --> 00:22:25,430
almost no difference differences of this

00:22:23,480 --> 00:22:27,650
tiny scale in micro benchmarks they can

00:22:25,430 --> 00:22:29,690
just be order of instructions in the

00:22:27,650 --> 00:22:31,160
machine code so that they are completely

00:22:29,690 --> 00:22:31,880
negligible it could also be the other

00:22:31,160 --> 00:22:34,400
way around

00:22:31,880 --> 00:22:36,370
so for all intents and purposes the

00:22:34,400 --> 00:22:39,470
speed is same as the handwritten

00:22:36,370 --> 00:22:42,910
JavaScript version so I hope I convinced

00:22:39,470 --> 00:22:44,240
you that true fan actually can turn the

00:22:42,910 --> 00:22:47,630
nicely

00:22:44,240 --> 00:22:50,840
idiomatic JavaScript second order era

00:22:47,630 --> 00:22:55,550
built-in into something that is as fast

00:22:50,840 --> 00:22:59,090
as the handwritten version yeah it took

00:22:55,550 --> 00:23:02,060
us I was so tough and it took us I think

00:22:59,090 --> 00:23:07,400
four years to get there so - finally we

00:23:02,060 --> 00:23:09,860
started writing from we we started to

00:23:07,400 --> 00:23:11,990
write turbofan from scratch basically

00:23:09,860 --> 00:23:16,850
the only thing we reused from our old

00:23:11,990 --> 00:23:19,460
compiler was the assembler so that thing

00:23:16,850 --> 00:23:21,140
that assembles machine code that outputs

00:23:19,460 --> 00:23:22,820
the machine code I mentioned we have

00:23:21,140 --> 00:23:24,770
eight architectures so we don't want to

00:23:22,820 --> 00:23:27,830
write eight new assemblers but other

00:23:24,770 --> 00:23:33,320
than that everything in turbofan is is

00:23:27,830 --> 00:23:36,230
brand new and shiny alright let's do a

00:23:33,320 --> 00:23:38,780
recap so I just showed one example with

00:23:36,230 --> 00:23:40,850
the array reduce but the same principle

00:23:38,780 --> 00:23:42,770
applies to basically all da-rae built in

00:23:40,850 --> 00:23:46,220
so you can think of the higher order

00:23:42,770 --> 00:23:50,630
ones so like map filter every some

00:23:46,220 --> 00:23:52,910
reduce there are also other built-ins

00:23:50,630 --> 00:23:54,380
that do similar things that also have

00:23:52,910 --> 00:23:56,660
loops in them for example where

00:23:54,380 --> 00:23:59,450
basically you have exactly the same

00:23:56,660 --> 00:24:03,470
example slightly different that is for

00:23:59,450 --> 00:24:05,120
function apply or function call so all

00:24:03,470 --> 00:24:09,440
of those get optimized in the same way

00:24:05,120 --> 00:24:11,660
and again our optimizations are based on

00:24:09,440 --> 00:24:15,650
feedback that we got during during

00:24:11,660 --> 00:24:18,140
ignition run we in line known call

00:24:15,650 --> 00:24:20,960
targets so that means if you if you add

00:24:18,140 --> 00:24:22,550
a certain use site of the second order

00:24:20,960 --> 00:24:24,170
built and always use the same function

00:24:22,550 --> 00:24:26,420
we can inline it so that has a major

00:24:24,170 --> 00:24:27,140
advantage if you if you don't put

00:24:26,420 --> 00:24:29,960
different

00:24:27,140 --> 00:24:34,190
functions into into one place in an

00:24:29,960 --> 00:24:36,110
array every for example also it assumes

00:24:34,190 --> 00:24:37,910
the shape is unchanged of the area so

00:24:36,110 --> 00:24:39,970
basically if in your function you start

00:24:37,910 --> 00:24:42,710
deleting elements from the array that

00:24:39,970 --> 00:24:47,300
would defeat such optimizations or if

00:24:42,710 --> 00:24:50,210
you if you change if you for example

00:24:47,300 --> 00:24:53,030
start putting double elements into this

00:24:50,210 --> 00:24:54,470
array within the function all of that

00:24:53,030 --> 00:24:57,890
would mean that we couldn't remove these

00:24:54,470 --> 00:25:01,610
checks that are inside this hot loop so

00:24:57,890 --> 00:25:05,000
avoiding this shape change is if it's

00:25:01,610 --> 00:25:08,180
good for performance and also we

00:25:05,000 --> 00:25:09,890
specialize the arithmetic so if most of

00:25:08,180 --> 00:25:12,730
the time you perform integer arithmetic

00:25:09,890 --> 00:25:16,760
we learn from that and CEO we can

00:25:12,730 --> 00:25:19,340
produce better machine instructions if

00:25:16,760 --> 00:25:21,830
then once in a while you throw an N in

00:25:19,340 --> 00:25:23,360
there or a double number just to spice

00:25:21,830 --> 00:25:26,000
things up and we need to do PM eyes

00:25:23,360 --> 00:25:28,190
again and learn from that

00:25:26,000 --> 00:25:29,750
that doesn't mean you cannot mix doubles

00:25:28,190 --> 00:25:32,990
and numbers you can totally do that it's

00:25:29,750 --> 00:25:36,680
just about the consistency of doing it

00:25:32,990 --> 00:25:38,810
if you do it once in in in once in

00:25:36,680 --> 00:25:40,430
thousand occurrences probably we

00:25:38,810 --> 00:25:42,470
optimize before if you do it every other

00:25:40,430 --> 00:25:45,920
time okay we learn about it

00:25:42,470 --> 00:25:48,740
so having consistent arithmetic in

00:25:45,920 --> 00:25:51,380
inside you're inside the functions you

00:25:48,740 --> 00:25:58,490
pass through these built-ins also helps

00:25:51,380 --> 00:26:02,030
us to optimize better alright so that

00:25:58,490 --> 00:26:05,390
brings me to the final part of my talk

00:26:02,030 --> 00:26:08,210
and that is JavaScript generators so

00:26:05,390 --> 00:26:10,400
just by show by a show of hands who here

00:26:08,210 --> 00:26:13,340
has used JavaScript generators directly

00:26:10,400 --> 00:26:15,860
already okay half of the room I would

00:26:13,340 --> 00:26:19,840
say who here has used async functions

00:26:15,860 --> 00:26:21,980
for example little bit more ok so

00:26:19,840 --> 00:26:24,790
JavaScript generators they're building

00:26:21,980 --> 00:26:28,960
building blocks for async functions so I

00:26:24,790 --> 00:26:30,070
will mostly talk about generators and

00:26:28,960 --> 00:26:32,960
[Music]

00:26:30,070 --> 00:26:34,730
all of what I say basically applies to

00:26:32,960 --> 00:26:38,350
async functions as well because they're

00:26:34,730 --> 00:26:38,350
based on generators

00:26:38,990 --> 00:26:44,090
so before we talk about generators we

00:26:41,539 --> 00:26:46,130
need to talk about JavaScript and the

00:26:44,090 --> 00:26:48,440
heap and when I say the heap

00:26:46,130 --> 00:26:51,140
I mean basically our garbage collected

00:26:48,440 --> 00:26:52,940
heap so before I worked on turbofan I

00:26:51,140 --> 00:26:55,370
actually worked for you for years on the

00:26:52,940 --> 00:26:58,279
garbage collectors and also whenever I

00:26:55,370 --> 00:27:00,070
can throw some slides about objects and

00:26:58,279 --> 00:27:06,020
the object heap in there I will do that

00:27:00,070 --> 00:27:09,350
and so this slide basically shows that

00:27:06,020 --> 00:27:11,570
while we're running JavaScript we

00:27:09,350 --> 00:27:14,750
populate this this grab bag of things

00:27:11,570 --> 00:27:17,630
that we call the object heap and inside

00:27:14,750 --> 00:27:20,179
there you might have arbitrary objects

00:27:17,630 --> 00:27:22,520
that the application allocates like an

00:27:20,179 --> 00:27:24,830
object literal or if you say new array

00:27:22,520 --> 00:27:28,820
all of this is a JavaScript visible

00:27:24,830 --> 00:27:30,980
object we call this J s object and let's

00:27:28,820 --> 00:27:32,960
draw drew it yellow on the slide

00:27:30,980 --> 00:27:35,210
it basically means okay the application

00:27:32,960 --> 00:27:36,919
can actually look at this object touch

00:27:35,210 --> 00:27:39,620
it it's visible to the application it's

00:27:36,919 --> 00:27:41,330
useful to the application same for

00:27:39,620 --> 00:27:44,690
functions they are also just objects

00:27:41,330 --> 00:27:46,789
floating around in this heap and then on

00:27:44,690 --> 00:27:48,950
the C if we also have internal objects

00:27:46,789 --> 00:27:51,409
that only the VM is allowed to touch and

00:27:48,950 --> 00:27:53,090
look at but they're also part of this

00:27:51,409 --> 00:27:55,190
whole garbage collection scheme so that

00:27:53,090 --> 00:27:58,039
has the advantage that we don't need to

00:27:55,190 --> 00:28:01,010
do explicit memory management for for

00:27:58,039 --> 00:28:03,110
our internal metadata metadata we can

00:28:01,010 --> 00:28:06,559
rely on the garbage collector to handle

00:28:03,110 --> 00:28:09,289
both application provided objects as

00:28:06,559 --> 00:28:11,059
well as daemon metadata and the

00:28:09,289 --> 00:28:13,460
interesting part is even the code that

00:28:11,059 --> 00:28:14,870
we generate the machine code is inside

00:28:13,460 --> 00:28:16,730
this heap so that means the garbage

00:28:14,870 --> 00:28:18,679
collector can also throw a machine code

00:28:16,730 --> 00:28:20,840
if it's no longer used so if you have

00:28:18,679 --> 00:28:22,399
functions that get optimized and then

00:28:20,840 --> 00:28:24,440
all of a sudden you no longer use them

00:28:22,399 --> 00:28:27,350
the code gets also collected and

00:28:24,440 --> 00:28:32,870
actually if the function itself dies

00:28:27,350 --> 00:28:38,539
that holds on to it let's look at an

00:28:32,870 --> 00:28:42,020
example and this example is is basically

00:28:38,539 --> 00:28:45,200
trying to explain where variables can

00:28:42,020 --> 00:28:47,419
can live so sometimes they can local

00:28:45,200 --> 00:28:49,039
variables can be on the zone on the

00:28:47,419 --> 00:28:50,750
machine stack they can be local to a

00:28:49,039 --> 00:28:52,480
function and sometimes they actually

00:28:50,750 --> 00:28:54,100
live on the heap so they

00:28:52,480 --> 00:28:58,270
take part in this garbage collection

00:28:54,100 --> 00:29:01,120
scheme in this example we have a create

00:28:58,270 --> 00:29:04,809
function with a local variable X that is

00:29:01,120 --> 00:29:07,470
passed in as an argument but the X is

00:29:04,809 --> 00:29:12,280
also used inside another function right

00:29:07,470 --> 00:29:15,669
inside closure and what that means is

00:29:12,280 --> 00:29:17,290
that when create returns the value of

00:29:15,669 --> 00:29:19,750
the variable is still hold on

00:29:17,290 --> 00:29:22,240
held onto by by F so that means it

00:29:19,750 --> 00:29:24,309
actually needs to live somewhere that is

00:29:22,240 --> 00:29:29,770
longer than the lifetime of the create

00:29:24,309 --> 00:29:31,270
function and what this means is

00:29:29,770 --> 00:29:33,280
basically the first time you call this

00:29:31,270 --> 00:29:37,450
create function with for example a value

00:29:33,280 --> 00:29:40,710
of 23 for X we remember this value 23 in

00:29:37,450 --> 00:29:43,210
a canonical location in the heap and

00:29:40,710 --> 00:29:45,900
this canonical location where we store

00:29:43,210 --> 00:29:50,770
these variables is called context and

00:29:45,900 --> 00:29:53,260
the function binds this context and if

00:29:50,770 --> 00:29:53,679
you look at the bigger PD entry for for

00:29:53,260 --> 00:29:56,169
closure

00:29:53,679 --> 00:29:57,990
it actually kind of defines closures

00:29:56,169 --> 00:30:00,520
like this it says closure is a

00:29:57,990 --> 00:30:07,150
combination of a function and its

00:30:00,520 --> 00:30:09,040
execution environment so the function

00:30:07,150 --> 00:30:12,160
itself the behavior is encoded in the

00:30:09,040 --> 00:30:14,230
code object and the execution

00:30:12,160 --> 00:30:16,660
environment the variable surrounding it

00:30:14,230 --> 00:30:19,330
is encoded in the context and also we

00:30:16,660 --> 00:30:21,220
put the feed back there so we have

00:30:19,330 --> 00:30:23,020
another object where we gather all of

00:30:21,220 --> 00:30:26,230
this feedback about how the function

00:30:23,020 --> 00:30:28,510
behaves if you call create again you get

00:30:26,230 --> 00:30:31,630
a second closure but the code actually

00:30:28,510 --> 00:30:35,350
can be shared so that means when we

00:30:31,630 --> 00:30:37,720
optimize the function f later on we only

00:30:35,350 --> 00:30:39,250
need to optimize it once and we can we

00:30:37,720 --> 00:30:41,590
can share the underlying optimized

00:30:39,250 --> 00:30:45,070
implementation even if the values are

00:30:41,590 --> 00:30:47,380
different for the context and also the

00:30:45,070 --> 00:30:51,610
feedback is shared so that means if you

00:30:47,380 --> 00:30:54,660
have multiple closures and you you you

00:30:51,610 --> 00:30:59,679
use the arithmetic in them consistently

00:30:54,660 --> 00:31:01,570
optimization again benefits so why am i

00:30:59,679 --> 00:31:03,580
talking so much about closures when we

00:31:01,570 --> 00:31:05,260
actually want to go to generators reason

00:31:03,580 --> 00:31:09,250
for that is that

00:31:05,260 --> 00:31:12,600
this scheme where we store variables on

00:31:09,250 --> 00:31:15,520
the heap is actually pretty pretty

00:31:12,600 --> 00:31:17,500
useful when we talk about generators

00:31:15,520 --> 00:31:20,590
because generators are functions that

00:31:17,500 --> 00:31:22,960
can be suspended mid execution if you

00:31:20,590 --> 00:31:25,360
yield inside a generator it kind of

00:31:22,960 --> 00:31:29,140
returns but remember it's its execution

00:31:25,360 --> 00:31:31,570
state and the execution state is kind of

00:31:29,140 --> 00:31:35,320
the same as this context that the

00:31:31,570 --> 00:31:36,640
closure binds so let's look at it and

00:31:35,320 --> 00:31:40,630
finally look at an example with a

00:31:36,640 --> 00:31:42,580
generator so in this case we've

00:31:40,630 --> 00:31:44,500
generated with to yield points and one

00:31:42,580 --> 00:31:46,960
return so that basically means it can

00:31:44,500 --> 00:31:53,010
produce three values and after that it

00:31:46,960 --> 00:31:57,190
will just say I'm done the first time we

00:31:53,010 --> 00:32:05,860
instantiate the generator a J's function

00:31:57,190 --> 00:32:08,140
for it is created and the generator

00:32:05,860 --> 00:32:11,650
object that is returned actually points

00:32:08,140 --> 00:32:13,690
to that function so every time that

00:32:11,650 --> 00:32:15,880
generator is then invoked again and

00:32:13,690 --> 00:32:18,730
resumed again we know which function to

00:32:15,880 --> 00:32:20,860
execute and the context is also stored

00:32:18,730 --> 00:32:24,040
by the bettor generator object so that

00:32:20,860 --> 00:32:26,230
means we can resume the function with a

00:32:24,040 --> 00:32:27,910
certain execution environment now all

00:32:26,230 --> 00:32:29,530
that's missing is basically to tell the

00:32:27,910 --> 00:32:31,480
function where it should resume right

00:32:29,530 --> 00:32:32,980
because if we if we resume it from the

00:32:31,480 --> 00:32:36,100
top it would have a different behavior

00:32:32,980 --> 00:32:38,620
so we also store this continuation point

00:32:36,100 --> 00:32:40,630
and the way we store it is actually we

00:32:38,620 --> 00:32:43,030
just number them we number all of the

00:32:40,630 --> 00:32:46,900
yield points we give them numbers from

00:32:43,030 --> 00:32:49,870
zero to whatever and that allows us if

00:32:46,900 --> 00:32:52,870
you then call next on this generator for

00:32:49,870 --> 00:32:53,470
the first time we basically call into

00:32:52,870 --> 00:32:56,470
this function

00:32:53,470 --> 00:32:59,320
it knows oh my resume point was zero it

00:32:56,470 --> 00:33:01,750
runs until the next yield point returns

00:32:59,320 --> 00:33:03,550
a value and updates this continuation so

00:33:01,750 --> 00:33:07,360
the next time we call it we know where

00:33:03,550 --> 00:33:09,970
to continue inside the generator also

00:33:07,360 --> 00:33:11,770
all of the variables inside the

00:33:09,970 --> 00:33:13,260
generator our context are located so

00:33:11,770 --> 00:33:15,640
that means we don't need to worry about

00:33:13,260 --> 00:33:17,800
restoring them because they're already

00:33:15,640 --> 00:33:19,060
put on the heap they're already put in

00:33:17,800 --> 00:33:25,600
the place where we can

00:33:19,060 --> 00:33:29,320
per system and that just continues on as

00:33:25,600 --> 00:33:31,390
long as you resume the generator it

00:33:29,320 --> 00:33:36,580
always suspends itself at the next yield

00:33:31,390 --> 00:33:38,530
point so that's for the object model now

00:33:36,580 --> 00:33:42,550
how do we actually model the generator

00:33:38,530 --> 00:33:47,410
function itself so again I'll try to

00:33:42,550 --> 00:33:49,150
explain with with pseudo JavaScript this

00:33:47,410 --> 00:33:51,700
time this translation is not done by

00:33:49,150 --> 00:33:53,470
turbofan but the ignition so it's it's

00:33:51,700 --> 00:33:56,380
done the very first time you compile a

00:33:53,470 --> 00:33:59,170
generator we do some translation to it

00:33:56,380 --> 00:34:00,970
to actually generate bytecode that more

00:33:59,170 --> 00:34:02,710
resembles as if you would have written

00:34:00,970 --> 00:34:05,140
this switch case on the right hand side

00:34:02,710 --> 00:34:07,180
this switch case contains some some

00:34:05,140 --> 00:34:09,280
magic that you wouldn't be able to write

00:34:07,180 --> 00:34:12,159
a normal JavaScript like accessing this

00:34:09,280 --> 00:34:17,590
continue this continuation point this

00:34:12,159 --> 00:34:19,870
special number and it also there are

00:34:17,590 --> 00:34:21,310
some scoping issues with it so we

00:34:19,870 --> 00:34:24,460
basically need to create the scope

00:34:21,310 --> 00:34:25,810
around the entire function but the

00:34:24,460 --> 00:34:28,510
bytecode for all intents and purposes

00:34:25,810 --> 00:34:30,399
has a switch inside so every time we

00:34:28,510 --> 00:34:32,440
call this function we read out the

00:34:30,399 --> 00:34:34,600
continuation point dispatch to the

00:34:32,440 --> 00:34:36,970
correct point and can continue running

00:34:34,600 --> 00:34:39,190
there now the advantage of letting

00:34:36,970 --> 00:34:41,409
ignition do that is as I mentioned

00:34:39,190 --> 00:34:44,620
before we can actually optimize this

00:34:41,409 --> 00:34:46,540
function we don't need to teach turbofan

00:34:44,620 --> 00:34:48,429
anything about generators because it

00:34:46,540 --> 00:34:50,679
just looks at the function that has a

00:34:48,429 --> 00:34:54,730
switch inside with this magic load of

00:34:50,679 --> 00:34:56,770
the continuation point and that is super

00:34:54,730 --> 00:34:59,250
useful for us v8 engineers because we

00:34:56,770 --> 00:35:01,600
don't we we we don't need to worry about

00:34:59,250 --> 00:35:02,980
generators and turbofan at all because

00:35:01,600 --> 00:35:05,890
to refine is complex enough without

00:35:02,980 --> 00:35:08,020
throwing generators in it the very first

00:35:05,890 --> 00:35:11,020
implementation of generators used a

00:35:08,020 --> 00:35:13,720
different model and basically we were

00:35:11,020 --> 00:35:19,240
never able to optimize the generator

00:35:13,720 --> 00:35:22,750
functions now with this we can all right

00:35:19,240 --> 00:35:24,400
so to recap for generators all the

00:35:22,750 --> 00:35:26,410
variables are stored on the heap so that

00:35:24,400 --> 00:35:28,600
means there are no longer local to the

00:35:26,410 --> 00:35:32,490
stack of the function accesses two

00:35:28,600 --> 00:35:32,490
variables are a little bit slower

00:35:32,580 --> 00:35:36,190
generators are the main building blocks

00:35:34,690 --> 00:35:38,730
for async functions so all of this

00:35:36,190 --> 00:35:41,430
applies to async functions as well

00:35:38,730 --> 00:35:44,470
internally we translate to the switch

00:35:41,430 --> 00:35:46,360
but other than that all optimizations

00:35:44,470 --> 00:35:48,280
apply so basically the only drawback you

00:35:46,360 --> 00:35:52,120
get from generators is this slightly

00:35:48,280 --> 00:35:53,830
slower variable axis but the slower

00:35:52,120 --> 00:35:55,540
variable axis you might have experienced

00:35:53,830 --> 00:35:57,310
with functions already because as I

00:35:55,540 --> 00:35:59,500
showed in a previous examples this

00:35:57,310 --> 00:36:01,350
context binding is not context

00:35:59,500 --> 00:36:05,350
allocating of variables is nothing new

00:36:01,350 --> 00:36:07,750
so in essence the upside of that is we

00:36:05,350 --> 00:36:09,940
can optimize generators pretty good so

00:36:07,750 --> 00:36:12,430
or not you shouldn't be afraid of using

00:36:09,940 --> 00:36:16,960
them they should only get faster in the

00:36:12,430 --> 00:36:18,580
future all right and then we have to

00:36:16,960 --> 00:36:22,720
generate objects with the additional

00:36:18,580 --> 00:36:25,060
values so there is a tiny overhead of of

00:36:22,720 --> 00:36:27,280
additional memory to that we need to

00:36:25,060 --> 00:36:30,580
hold on to but also that is negligible

00:36:27,280 --> 00:36:32,530
and you buy into the same machinery that

00:36:30,580 --> 00:36:36,160
was already there for context allocation

00:36:32,530 --> 00:36:40,150
of variables again so there shouldn't be

00:36:36,160 --> 00:36:44,230
any any major surprises in memory usage

00:36:40,150 --> 00:36:46,020
with generators and with that we're

00:36:44,230 --> 00:36:50,500
almost done

00:36:46,020 --> 00:36:52,270
already out of a voice but I just wanted

00:36:50,500 --> 00:36:54,370
to remind you that you can actually

00:36:52,270 --> 00:36:57,700
follow us on Twitter now so over the

00:36:54,370 --> 00:37:01,500
past let's say one year one and a half

00:36:57,700 --> 00:37:03,910
year two years we try to improve our our

00:37:01,500 --> 00:37:06,550
developer outreach we try to reach more

00:37:03,910 --> 00:37:08,530
people we try to not be this this closed

00:37:06,550 --> 00:37:10,750
of hidden be a team that only looks at

00:37:08,530 --> 00:37:15,040
their at their micro benchmarks we try

00:37:10,750 --> 00:37:18,850
to look at real world websites I hope we

00:37:15,040 --> 00:37:20,460
improved over the past years we have a

00:37:18,850 --> 00:37:23,320
Twitter channel now and we have

00:37:20,460 --> 00:37:27,460
developer we have a deferral person now

00:37:23,320 --> 00:37:30,070
and so please follow us tell us what are

00:37:27,460 --> 00:37:32,500
your problems let us know we really want

00:37:30,070 --> 00:37:34,540
to optimize for the real web we still

00:37:32,500 --> 00:37:35,920
have benchmarks that we optimize we

00:37:34,540 --> 00:37:38,280
still care about benchmarks because

00:37:35,920 --> 00:37:41,290
that's that's our way of reasoning about

00:37:38,280 --> 00:37:44,470
about performance but we really want to

00:37:41,290 --> 00:37:46,240
hear your experience about for example

00:37:44,470 --> 00:37:50,800
generation so second order built

00:37:46,240 --> 00:37:55,440
and by the way it's this v8 v8 yes it's

00:37:50,800 --> 00:37:55,440
not that don't follow them

00:37:55,800 --> 00:37:59,190
alright with that I'm finally done

00:37:57,850 --> 00:38:02,749
thanks for listening

00:37:59,190 --> 00:38:02,749

YouTube URL: https://www.youtube.com/watch?v=YmCcvxlnnqM


