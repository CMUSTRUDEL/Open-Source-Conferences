Title: The State of SPA Frameworks in 2020, Vienna.JS, August 2020
Publication date: 2020-09-21
Playlist: viennaJS
Description: 
	Talk by By David Leitner

Over the years we brought the field of front-end development to an elusive new level and Single-Page-Applications (SPAs) became the de facto standard for crafting modern, reactive, and customer-friendly applications. 

When it comes to the selection of SPA frameworks we have a wide range of options. Full fletched enterprise-ready frameworks like Angular, something in the middle like React or Vue, or tiny newcomers like Svelte. But maybe also the options of just using pure Web Components. Most of these options have their merit, and the maturity to have limited risk by using them in production. 

Although all those frameworks seem to follow very different concepts and approaches, more and more ideas seem to swap over from one to the other. And there is a strong tendency that this trend will even increase in the future. After we have uncovered the current status-quo of commonalities and differentiators we will focus on the driving factors that will make SPA frameworks evolve even more in the same direction in the future.


_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,719 --> 00:00:06,240
i'm i'm really happy to be here um not

00:00:03,439 --> 00:00:08,559
not just to be here because i i i can

00:00:06,240 --> 00:00:12,000
speak to you and i can meet you all um

00:00:08,559 --> 00:00:13,679
mainly to be here back on a live meetup

00:00:12,000 --> 00:00:16,160
yeah it's been a while

00:00:13,679 --> 00:00:17,680
um since this was possible and i i think

00:00:16,160 --> 00:00:19,439
it's really really cool

00:00:17,680 --> 00:00:21,600
that we see live meetups popping up

00:00:19,439 --> 00:00:24,960
again um and again

00:00:21,600 --> 00:00:27,760
um and it's getting more and more and

00:00:24,960 --> 00:00:30,480
i would really like to have a say a

00:00:27,760 --> 00:00:32,559
special thank you to the organizers

00:00:30,480 --> 00:00:33,520
of the energy s for making this possible

00:00:32,559 --> 00:00:37,520
it's really cool

00:00:33,520 --> 00:00:40,399
so a handful plows i think is more than

00:00:37,520 --> 00:00:40,399
more than deserved

00:00:43,040 --> 00:00:46,879
um also for me it's the first time to do

00:00:45,440 --> 00:00:49,440
such unplugged things

00:00:46,879 --> 00:00:51,680
i usually um present with macbook and

00:00:49,440 --> 00:00:53,680
slides

00:00:51,680 --> 00:00:55,840
so please bear with me if not everything

00:00:53,680 --> 00:00:57,920
is working out perfectly

00:00:55,840 --> 00:01:00,000
when mirror asked me if i if i want to

00:00:57,920 --> 00:01:02,399
do this if i want to talk about

00:01:00,000 --> 00:01:03,359
about something at vienna gs at the auto

00:01:02,399 --> 00:01:06,479
meetup

00:01:03,359 --> 00:01:08,560
um he was he was mainly thinking about

00:01:06,479 --> 00:01:10,320
the talk i did a few times already ago i

00:01:08,560 --> 00:01:10,799
bought microfondants which i also talked

00:01:10,320 --> 00:01:13,760
at

00:01:10,799 --> 00:01:15,680
at h and conf in january but i said it's

00:01:13,760 --> 00:01:16,720
it's quite hard to talk about such a

00:01:15,680 --> 00:01:18,799
technical topic

00:01:16,720 --> 00:01:20,640
without having kind of code snippets

00:01:18,799 --> 00:01:22,960
without having slides

00:01:20,640 --> 00:01:24,960
um so that's why we decided to to phrase

00:01:22,960 --> 00:01:26,880
the talk like it is called now

00:01:24,960 --> 00:01:29,680
the state of single page applications in

00:01:26,880 --> 00:01:29,680
00:01:29,759 --> 00:01:33,920
the talk is the title is is really

00:01:31,840 --> 00:01:34,880
genius because you can talk actually

00:01:33,920 --> 00:01:37,920
about everything

00:01:34,880 --> 00:01:40,000
yeah behind this title and

00:01:37,920 --> 00:01:42,079
that's what we mainly will do today we

00:01:40,000 --> 00:01:45,600
will not compare frameworks

00:01:42,079 --> 00:01:47,439
on a metric level on a github star level

00:01:45,600 --> 00:01:49,759
we will go into concepts to make you

00:01:47,439 --> 00:01:52,479
understand what are the differences

00:01:49,759 --> 00:01:53,280
and why you should maybe care so first

00:01:52,479 --> 00:01:56,560
things first

00:01:53,280 --> 00:01:57,759
my name is david leitner um usually you

00:01:56,560 --> 00:01:59,600
see a slide with a

00:01:57,759 --> 00:02:01,280
face on it um it's not so important

00:01:59,600 --> 00:02:02,799
because you can see me anyway

00:02:01,280 --> 00:02:04,640
i work for a company which is called

00:02:02,799 --> 00:02:06,159
square solutions we're a rather small

00:02:04,640 --> 00:02:08,080
company in vienna

00:02:06,159 --> 00:02:10,080
and if you need anything just feel free

00:02:08,080 --> 00:02:10,959
to reach out for me via email or wire

00:02:10,080 --> 00:02:13,280
twitter

00:02:10,959 --> 00:02:15,200
um my twitter handle is stuff light most

00:02:13,280 --> 00:02:18,480
of you i guess i guess no

00:02:15,200 --> 00:02:20,879
it was a funny joke back then um

00:02:18,480 --> 00:02:24,640
because of the b and so on but it yeah

00:02:20,879 --> 00:02:24,640
it stayed like this yeah

00:02:24,879 --> 00:02:30,080
i have here this this one slide um i

00:02:28,000 --> 00:02:32,000
will i will build my whole presentation

00:02:30,080 --> 00:02:34,800
around this one slide

00:02:32,000 --> 00:02:36,080
and you see here two axis and i want to

00:02:34,800 --> 00:02:39,040
first understand

00:02:36,080 --> 00:02:40,959
um from the audience here how familiar

00:02:39,040 --> 00:02:42,319
with single page applications so

00:02:40,959 --> 00:02:44,000
first of all i mean that's the easy

00:02:42,319 --> 00:02:46,560
question who could

00:02:44,000 --> 00:02:48,480
build a production ready application

00:02:46,560 --> 00:02:50,080
with a single page application framework

00:02:48,480 --> 00:02:51,440
with just one it doesn't matter which

00:02:50,080 --> 00:02:52,640
one doesn't matter if it's react angle a

00:02:51,440 --> 00:02:55,840
few chairs

00:02:52,640 --> 00:02:59,280
who could do this okay

00:02:55,840 --> 00:02:59,680
so i would say eighty percent who could

00:02:59,280 --> 00:03:01,360
to

00:02:59,680 --> 00:03:02,879
who could do it with two different

00:03:01,360 --> 00:03:04,000
single page application frameworks

00:03:02,879 --> 00:03:07,040
product ready

00:03:04,000 --> 00:03:08,400
application ah it's about i would say

00:03:07,040 --> 00:03:11,760
fifty percent

00:03:08,400 --> 00:03:15,120
who could do it with three or more

00:03:11,760 --> 00:03:16,840
okay it's it's ten to fifty percent i

00:03:15,120 --> 00:03:19,920
would say okay

00:03:16,840 --> 00:03:22,000
so those who can do it with just one

00:03:19,920 --> 00:03:23,519
single page application framework so

00:03:22,000 --> 00:03:24,720
those who can just do it with angular

00:03:23,519 --> 00:03:26,720
reactor whatever you have

00:03:24,720 --> 00:03:28,319
done it doesn't really matter to me do

00:03:26,720 --> 00:03:32,080
you think that this is the best

00:03:28,319 --> 00:03:33,840
the best framework of choice um for for

00:03:32,080 --> 00:03:36,000
your given problem

00:03:33,840 --> 00:03:38,000
so those who who had the head the hand

00:03:36,000 --> 00:03:41,760
up when they said they are able to build

00:03:38,000 --> 00:03:41,760
this one is one framework

00:03:43,360 --> 00:03:48,640
who is able to build this one framework

00:03:46,319 --> 00:03:50,959
so that the first part

00:03:48,640 --> 00:03:53,519
just with one okay you and you do you

00:03:50,959 --> 00:03:57,040
think it's the best choice

00:03:53,519 --> 00:03:58,959
cool it's not an exercise you cannot be

00:03:57,040 --> 00:04:00,959
wrong i just want to understand it okay

00:03:58,959 --> 00:04:02,319
and those those who are building who

00:04:00,959 --> 00:04:03,680
could build it with two different

00:04:02,319 --> 00:04:06,319
frameworks

00:04:03,680 --> 00:04:13,920
um who of those things that one of those

00:04:06,319 --> 00:04:14,319
twos is much better than the other one

00:04:13,920 --> 00:04:15,920
yeah

00:04:14,319 --> 00:04:17,600
that's of course true but do you think

00:04:15,920 --> 00:04:20,639
one of them is usually better in ninety

00:04:17,600 --> 00:04:20,639
percent of the cases

00:04:22,800 --> 00:04:28,560
okay maybe sixty percent okay

00:04:26,960 --> 00:04:31,199
now what i what i actually want to

00:04:28,560 --> 00:04:34,160
because i do this exercise usually

00:04:31,199 --> 00:04:34,800
at clients a lot and i ask exactly those

00:04:34,160 --> 00:04:38,479
questions

00:04:34,800 --> 00:04:41,120
um and and it turns out um i just need a

00:04:38,479 --> 00:04:41,120
few stickers

00:04:41,680 --> 00:04:45,440
it turns out that the curve is usually

00:04:43,440 --> 00:04:48,240
like this right so this is the

00:04:45,440 --> 00:04:48,720
the number of frameworks people know and

00:04:48,240 --> 00:04:50,960
if you

00:04:48,720 --> 00:04:52,560
if you do it like this right so somebody

00:04:50,960 --> 00:04:54,880
knows one framework

00:04:52,560 --> 00:04:56,800
somebody knows two frameworks somebody

00:04:54,880 --> 00:04:58,800
know three frameworks somebody knows

00:04:56,800 --> 00:04:59,759
four frameworks and so on and so forth

00:04:58,800 --> 00:05:02,400
right

00:04:59,759 --> 00:05:03,199
and if you ask those people who know one

00:05:02,400 --> 00:05:05,039
framework

00:05:03,199 --> 00:05:07,120
and if you ask them do you think that's

00:05:05,039 --> 00:05:08,880
the best choice out there

00:05:07,120 --> 00:05:10,720
i would say eighty percent of them say

00:05:08,880 --> 00:05:12,400
yes right

00:05:10,720 --> 00:05:14,160
if those people know at least two

00:05:12,400 --> 00:05:16,400
frameworks and you ask them again is

00:05:14,160 --> 00:05:18,639
do you think one of those is is much

00:05:16,400 --> 00:05:20,720
fundamentally better than the other one

00:05:18,639 --> 00:05:22,560
i would say 50 percent just say yeah one

00:05:20,720 --> 00:05:24,720
of them is much better right

00:05:22,560 --> 00:05:26,720
and if people know more than two or

00:05:24,720 --> 00:05:28,560
three or four frameworks usually the

00:05:26,720 --> 00:05:29,199
number is very low where they can say

00:05:28,560 --> 00:05:31,120
hey

00:05:29,199 --> 00:05:32,800
um one of them is much better and then

00:05:31,120 --> 00:05:34,639
they usually start to

00:05:32,800 --> 00:05:36,639
to start with the with the famous

00:05:34,639 --> 00:05:38,960
sentence it depends yeah

00:05:36,639 --> 00:05:41,120
and when we talk about frameworks this

00:05:38,960 --> 00:05:42,880
is not a framework specific problem i

00:05:41,120 --> 00:05:44,560
think this is generalizing

00:05:42,880 --> 00:05:46,160
in software engineering right there is

00:05:44,560 --> 00:05:48,560
this age-old saying

00:05:46,160 --> 00:05:50,880
that if you meet somebody who is

00:05:48,560 --> 00:05:52,720
strongly believing that his programming

00:05:50,880 --> 00:05:54,639
language is the best one for whatever

00:05:52,720 --> 00:05:56,560
problem and his programming language

00:05:54,639 --> 00:05:58,800
is better than any other programming

00:05:56,560 --> 00:06:00,639
language then the chance is usually very

00:05:58,800 --> 00:06:02,319
high that he only knows this one

00:06:00,639 --> 00:06:04,479
programming language

00:06:02,319 --> 00:06:06,400
and this is the same for frameworks and

00:06:04,479 --> 00:06:08,080
this is what i wanted to bring as an

00:06:06,400 --> 00:06:09,600
example to set a little bit the stage

00:06:08,080 --> 00:06:10,479
i'm not here to tell you which framework

00:06:09,600 --> 00:06:13,520
is better

00:06:10,479 --> 00:06:14,720
i i wouldn't even know it honestly i'm

00:06:13,520 --> 00:06:17,120
here to compare them

00:06:14,720 --> 00:06:18,000
um based on concepts and the few

00:06:17,120 --> 00:06:19,919
concepts which

00:06:18,000 --> 00:06:21,520
should be the past of the frameworks

00:06:19,919 --> 00:06:24,080
which should be the current status quo

00:06:21,520 --> 00:06:27,759
and which should be the future

00:06:24,080 --> 00:06:34,479
make sense cool

00:06:27,759 --> 00:06:37,759
then i need to remove them again

00:06:34,479 --> 00:06:39,759
and i i would like to start with

00:06:37,759 --> 00:06:41,840
with the topic um when it comes to

00:06:39,759 --> 00:06:45,360
single page applications

00:06:41,840 --> 00:06:46,400
which is reactivity who knows the term

00:06:45,360 --> 00:06:48,400
reactivity

00:06:46,400 --> 00:06:50,960
who knows what is meant by it in the

00:06:48,400 --> 00:06:53,199
context of single page applications okay

00:06:50,960 --> 00:06:54,960
when we talk about reactivity we need to

00:06:53,199 --> 00:06:58,080
i think understand mainly three things

00:06:54,960 --> 00:06:58,080
the first one is streams

00:07:00,880 --> 00:07:07,039
the second one is reactive programming

00:07:05,759 --> 00:07:09,680
and the third one is reactive

00:07:07,039 --> 00:07:12,160
architectures i will i will go quickly

00:07:09,680 --> 00:07:13,919
into detail about all of them

00:07:12,160 --> 00:07:16,080
so first first things first who knows

00:07:13,919 --> 00:07:18,960
what is a stream

00:07:16,080 --> 00:07:21,759
who could explain to his parents on the

00:07:18,960 --> 00:07:21,759
phone or the stream

00:07:23,280 --> 00:07:27,280
okay i i have a i have a i think a good

00:07:26,639 --> 00:07:30,400
example

00:07:27,280 --> 00:07:33,280
when it comes to to streams um

00:07:30,400 --> 00:07:35,280
reactivity was actually phrased by by by

00:07:33,280 --> 00:07:37,520
physics right so albert einstein

00:07:35,280 --> 00:07:38,960
worked on reactivity and it's all about

00:07:37,520 --> 00:07:42,560
time and space actually

00:07:38,960 --> 00:07:44,000
yeah and when you think about time and

00:07:42,560 --> 00:07:46,319
space in programming

00:07:44,000 --> 00:07:48,160
if you think at the lowest level of time

00:07:46,319 --> 00:07:50,400
in the lowest level space

00:07:48,160 --> 00:07:52,240
you have something like a value right

00:07:50,400 --> 00:07:54,160
with the geta interceptor

00:07:52,240 --> 00:07:55,680
you can write value you can write a

00:07:54,160 --> 00:07:58,800
value and you can get a value

00:07:55,680 --> 00:08:00,000
right if you go further on the right

00:07:58,800 --> 00:08:02,160
hand side

00:08:00,000 --> 00:08:04,319
into space you have something like a

00:08:02,160 --> 00:08:05,599
list or array or whatever you call it or

00:08:04,319 --> 00:08:07,280
a collection right

00:08:05,599 --> 00:08:08,800
with the generator and with iterator

00:08:07,280 --> 00:08:12,720
usually right

00:08:08,800 --> 00:08:15,919
okay if you now go up in time

00:08:12,720 --> 00:08:18,800
but stay in singular space give

00:08:15,919 --> 00:08:20,639
something like a promise usually right

00:08:18,800 --> 00:08:23,440
something which has one value but you

00:08:20,639 --> 00:08:27,840
will maybe get it in the future right

00:08:23,440 --> 00:08:30,160
and what do you think is here

00:08:27,840 --> 00:08:31,759
exactly that's what his dream is yeah

00:08:30,160 --> 00:08:33,599
and i think with this comparison should

00:08:31,759 --> 00:08:37,039
be it should be quite straightforward to

00:08:33,599 --> 00:08:37,039
understand those streams all right

00:08:37,289 --> 00:08:42,640
[Laughter]

00:08:39,039 --> 00:08:44,880
i never tried it but fair point yeah

00:08:42,640 --> 00:08:46,160
yeah so this is about streams okay this

00:08:44,880 --> 00:08:47,839
is the first building block to

00:08:46,160 --> 00:08:49,680
understand reactivity

00:08:47,839 --> 00:08:51,040
the second one is reactive programming

00:08:49,680 --> 00:08:53,519
right

00:08:51,040 --> 00:08:55,680
so again what is reactive programming

00:08:53,519 --> 00:08:57,519
very simplified to active programming i

00:08:55,680 --> 00:09:00,320
will i will collect this afterwards

00:08:57,519 --> 00:09:02,720
um reactive programming can be can be

00:09:00,320 --> 00:09:06,560
shown in a very simple example right

00:09:02,720 --> 00:09:06,560
so let's assume you have a variable a

00:09:06,640 --> 00:09:11,600
like this right i know nobody uses

00:09:09,040 --> 00:09:12,800
variables these days but i i try to make

00:09:11,600 --> 00:09:15,600
it a little bit

00:09:12,800 --> 00:09:18,720
language agnostic so variable a which

00:09:15,600 --> 00:09:18,720
has the value of one

00:09:20,839 --> 00:09:23,839
okay

00:09:24,000 --> 00:09:28,480
i never programmed it that fast honestly

00:09:26,560 --> 00:09:32,640
variable v

00:09:28,480 --> 00:09:32,640
um which has the value of

00:09:33,440 --> 00:09:41,040
two surprise

00:09:37,519 --> 00:09:41,760
okay what has this to do with reactivity

00:09:41,040 --> 00:09:44,640
right

00:09:41,760 --> 00:09:46,000
um well it starts with variable this

00:09:44,640 --> 00:09:49,200
variable

00:09:46,000 --> 00:09:51,839
c and variable c

00:09:49,200 --> 00:09:51,839
is suddenly

00:09:52,320 --> 00:09:56,480
suddenly a little bit different because

00:09:55,360 --> 00:09:59,040
variable c

00:09:56,480 --> 00:09:59,040
is a

00:10:00,320 --> 00:10:06,880
plus i should have

00:10:04,240 --> 00:10:07,440
should have not separated this so much a

00:10:06,880 --> 00:10:11,519
plus b

00:10:07,440 --> 00:10:15,839
right okay

00:10:11,519 --> 00:10:17,440
so what is c it should be simple

00:10:15,839 --> 00:10:20,640
this is not a this is not a tricky

00:10:17,440 --> 00:10:20,640
question it's really that simple

00:10:21,600 --> 00:10:26,720
it's three right c is three but what

00:10:24,959 --> 00:10:29,519
happens now

00:10:26,720 --> 00:10:30,880
if we would go here and would for

00:10:29,519 --> 00:10:33,839
example change this

00:10:30,880 --> 00:10:33,839
to four

00:10:34,880 --> 00:10:39,279
nothing would happen right that's a

00:10:36,399 --> 00:10:40,800
problem i mean this could be the problem

00:10:39,279 --> 00:10:44,640
and their programming languages are

00:10:40,800 --> 00:10:44,640
their frameworks for example swelter

00:10:44,800 --> 00:10:48,720
which allow us exactly to to build this

00:10:47,519 --> 00:10:50,800
reactivity right

00:10:48,720 --> 00:10:52,640
which allow us to for example add here a

00:10:50,800 --> 00:10:55,120
dollar sign in front of it

00:10:52,640 --> 00:10:57,120
and make this reactive which would mean

00:10:55,120 --> 00:11:00,560
if you would change this variable b

00:10:57,120 --> 00:11:01,120
to 4 this variable c would be ultimately

00:11:00,560 --> 00:11:03,680
five

00:11:01,120 --> 00:11:05,600
yeah and that's reactive programming and

00:11:03,680 --> 00:11:07,360
if you think about it now

00:11:05,600 --> 00:11:09,600
then this is a stream and this is a

00:11:07,360 --> 00:11:12,079
stream this is a stream of values and

00:11:09,600 --> 00:11:14,160
those values can change over time right

00:11:12,079 --> 00:11:16,880
and this is a string transformation for

00:11:14,160 --> 00:11:19,839
the angular developers this would be a

00:11:16,880 --> 00:11:20,880
pipe map a plus b right that every time

00:11:19,839 --> 00:11:23,279
a changes and b

00:11:20,880 --> 00:11:24,000
changes c changes right and this is

00:11:23,279 --> 00:11:25,519
reactive

00:11:24,000 --> 00:11:28,240
programming and it's hard right it's

00:11:25,519 --> 00:11:30,160
just staying in sync and staying

00:11:28,240 --> 00:11:31,760
reactive right that the term is actually

00:11:30,160 --> 00:11:35,279
quite self-explaining

00:11:31,760 --> 00:11:37,519
okay so we nearly got it

00:11:35,279 --> 00:11:40,320
the last building block for reactivity

00:11:37,519 --> 00:11:42,000
is reactive architectures

00:11:40,320 --> 00:11:43,920
so i think it's very important

00:11:42,000 --> 00:11:45,920
especially in this context

00:11:43,920 --> 00:11:47,600
um to understand that reactivity is not

00:11:45,920 --> 00:11:48,880
something which is usually just to any

00:11:47,600 --> 00:11:51,040
programming level

00:11:48,880 --> 00:11:53,120
but reactivity can bring a lot of more

00:11:51,040 --> 00:11:57,839
benefits yeah

00:11:53,120 --> 00:11:57,839
so let me just collect my stickies

00:12:00,320 --> 00:12:04,399
so if you think about modern

00:12:02,639 --> 00:12:06,000
architectures these days or they don't

00:12:04,399 --> 00:12:07,519
even have to be modern let's just think

00:12:06,000 --> 00:12:08,880
of architectures

00:12:07,519 --> 00:12:10,720
then you usually have something like

00:12:08,880 --> 00:12:13,200
this you have microservice

00:12:10,720 --> 00:12:14,720
you have a second microservice you have

00:12:13,200 --> 00:12:17,200
a third microservice

00:12:14,720 --> 00:12:18,160
you have a lot of microservices the more

00:12:17,200 --> 00:12:20,800
the better

00:12:18,160 --> 00:12:22,720
right just joking and those

00:12:20,800 --> 00:12:23,600
microservices usually have databases

00:12:22,720 --> 00:12:25,360
right

00:12:23,600 --> 00:12:27,839
so this microservice has its database on

00:12:25,360 --> 00:12:28,639
its own this microservice has a database

00:12:27,839 --> 00:12:30,399
on its own

00:12:28,639 --> 00:12:32,079
and this microservice has a database on

00:12:30,399 --> 00:12:32,480
its own that's that's the fundamental

00:12:32,079 --> 00:12:35,760
idea

00:12:32,480 --> 00:12:37,600
of of database of microservices um

00:12:35,760 --> 00:12:38,880
that every every service is autonomous

00:12:37,600 --> 00:12:41,760
and has its own

00:12:38,880 --> 00:12:42,880
own database and persistence right so

00:12:41,760 --> 00:12:45,360
the question is now

00:12:42,880 --> 00:12:48,000
how does the the usual the usual

00:12:45,360 --> 00:12:48,000
architecture

00:12:48,480 --> 00:12:56,720
look like beyond those services

00:12:53,120 --> 00:12:56,720
usually have some kind of gateway

00:12:58,880 --> 00:13:02,560
okay and then you have some kind of

00:13:00,880 --> 00:13:03,839
application right

00:13:02,560 --> 00:13:06,639
so you have for example react

00:13:03,839 --> 00:13:08,959
applications who who uses reacts i guess

00:13:06,639 --> 00:13:10,720
people who use react right it's

00:13:08,959 --> 00:13:12,480
interesting to to also

00:13:10,720 --> 00:13:14,320
get to know the audience again who uses

00:13:12,480 --> 00:13:19,040
angular

00:13:14,320 --> 00:13:19,040
okay who uses few

00:13:19,120 --> 00:13:26,240
you use everything i have to feel it

00:13:23,200 --> 00:13:29,279
who uses stencil

00:13:26,240 --> 00:13:33,600
stencil yeah okay

00:13:29,279 --> 00:13:35,200
who uses amber no amber uses anymore sad

00:13:33,600 --> 00:13:36,240
ember is a great framework but i will

00:13:35,200 --> 00:13:39,360
put it on the side

00:13:36,240 --> 00:13:42,720
who uses elm elm

00:13:39,360 --> 00:13:46,320
elm no elmers

00:13:42,720 --> 00:13:46,320
who uses felt yes

00:13:47,279 --> 00:13:51,760
and who uses hyper app still hyper

00:13:49,600 --> 00:13:55,360
abuses here huh

00:13:51,760 --> 00:13:55,360
you used it or you still use it

00:13:55,680 --> 00:14:02,240
okay okay fair enough good

00:13:59,120 --> 00:14:03,600
um so yeah that's that's usually the

00:14:02,240 --> 00:14:05,519
blueprint architecture right you have

00:14:03,600 --> 00:14:07,279
some kind of client application whatever

00:14:05,519 --> 00:14:08,639
it is i just use this now to get a

00:14:07,279 --> 00:14:10,320
little bit of a picture of what

00:14:08,639 --> 00:14:11,920
people are using here you have some kind

00:14:10,320 --> 00:14:12,720
of cadence you have this microservices

00:14:11,920 --> 00:14:14,160
right

00:14:12,720 --> 00:14:15,680
and let's assume the hyper app or

00:14:14,160 --> 00:14:17,519
whatever you have to angular application

00:14:15,680 --> 00:14:18,560
wants to fetch the latest profile from a

00:14:17,519 --> 00:14:20,000
person

00:14:18,560 --> 00:14:21,920
then it goes to the gateway says hey

00:14:20,000 --> 00:14:23,279
give me the profile the gateway goes to

00:14:21,920 --> 00:14:25,040
the microservice

00:14:23,279 --> 00:14:26,720
fetches the profile data the

00:14:25,040 --> 00:14:28,000
microservice usually needs to go to

00:14:26,720 --> 00:14:30,240
other microservices

00:14:28,000 --> 00:14:31,279
to fulfill the whole profile right so

00:14:30,240 --> 00:14:33,440
it's a very s

00:14:31,279 --> 00:14:34,959
it's a very synchronous process so http

00:14:33,440 --> 00:14:35,839
itself is of course synchronous so you

00:14:34,959 --> 00:14:37,839
make a

00:14:35,839 --> 00:14:39,440
response you make here response this

00:14:37,839 --> 00:14:41,440
makes your response and ultimately you

00:14:39,440 --> 00:14:43,120
get better response right

00:14:41,440 --> 00:14:45,680
and it doesn't really matter if you

00:14:43,120 --> 00:14:48,160
build your angular application with

00:14:45,680 --> 00:14:49,279
with http client which returns you an

00:14:48,160 --> 00:14:50,639
observable right

00:14:49,279 --> 00:14:52,320
then you have here this kind of

00:14:50,639 --> 00:14:54,079
artificial reactivity

00:14:52,320 --> 00:14:55,760
but in the end your whole architecture

00:14:54,079 --> 00:14:57,519
is not reactive your whole architecture

00:14:55,760 --> 00:14:59,199
is very synchronous right

00:14:57,519 --> 00:15:01,279
and this comes with a lot of downsides

00:14:59,199 --> 00:15:01,920
first of all the downside of resilience

00:15:01,279 --> 00:15:04,959
right

00:15:01,920 --> 00:15:08,800
if one of those micro services

00:15:04,959 --> 00:15:10,320
falls apart so it starts to burn this is

00:15:08,800 --> 00:15:11,680
what it should show well let's let's

00:15:10,320 --> 00:15:14,320
just remove it right

00:15:11,680 --> 00:15:15,760
one of those microservices is lost right

00:15:14,320 --> 00:15:17,440
then you have this this problem of

00:15:15,760 --> 00:15:19,680
resilience usually yeah

00:15:17,440 --> 00:15:21,199
so you cannot get some data which you

00:15:19,680 --> 00:15:22,320
need for the profile if you have a

00:15:21,199 --> 00:15:24,240
really good team

00:15:22,320 --> 00:15:26,560
they will build the glide in a way that

00:15:24,240 --> 00:15:27,040
it still keeps up running and that it

00:15:26,560 --> 00:15:28,720
just

00:15:27,040 --> 00:15:30,240
doesn't show those fields which we got

00:15:28,720 --> 00:15:32,240
from this microservices

00:15:30,240 --> 00:15:33,759
but honestly you really need a you

00:15:32,240 --> 00:15:36,720
really need a mature team i

00:15:33,759 --> 00:15:38,839
i rarely see microservice architectures

00:15:36,720 --> 00:15:41,759
which are built in such a resilient way

00:15:38,839 --> 00:15:42,800
unfortunately but but that's that's the

00:15:41,759 --> 00:15:44,880
that's the

00:15:42,800 --> 00:15:46,720
that's what i observe at least at least

00:15:44,880 --> 00:15:48,240
at clients yeah

00:15:46,720 --> 00:15:51,040
and that's one of the issues of course

00:15:48,240 --> 00:15:53,279
because we need to go here all the time

00:15:51,040 --> 00:15:54,399
and those those angular applications

00:15:53,279 --> 00:15:56,560
need to fetch those

00:15:54,399 --> 00:15:58,160
things synchronously right and the

00:15:56,560 --> 00:15:59,199
second town that is if we don't have a

00:15:58,160 --> 00:16:03,440
second channel

00:15:59,199 --> 00:16:05,199
let's assume you have a mobile channel

00:16:03,440 --> 00:16:07,600
so this is a mobile phone for those who

00:16:05,199 --> 00:16:09,519
don't know it anymore

00:16:07,600 --> 00:16:10,800
it's easier to to paint than a

00:16:09,519 --> 00:16:13,120
smartphone

00:16:10,800 --> 00:16:14,800
then this this phone has the problem if

00:16:13,120 --> 00:16:15,759
you for example changing the profile

00:16:14,800 --> 00:16:17,279
data right

00:16:15,759 --> 00:16:19,440
if you go here and say hey change the

00:16:17,279 --> 00:16:22,000
first name or whatever you do right

00:16:19,440 --> 00:16:23,680
then they don't get notified about this

00:16:22,000 --> 00:16:24,800
they need to fetch it again or they need

00:16:23,680 --> 00:16:26,639
to press f5

00:16:24,800 --> 00:16:28,320
or you do some polling or whatever you

00:16:26,639 --> 00:16:29,920
do right and it doesn't really

00:16:28,320 --> 00:16:31,360
it doesn't really make too much sense so

00:16:29,920 --> 00:16:33,519
from a ux perspective

00:16:31,360 --> 00:16:36,560
and also from a resilience perspective

00:16:33,519 --> 00:16:38,320
this architecture could be improved yeah

00:16:36,560 --> 00:16:40,160
and this is what where reactive

00:16:38,320 --> 00:16:41,920
architectures come into play

00:16:40,160 --> 00:16:44,560
because reactive architectures don't

00:16:41,920 --> 00:16:46,399
believe in this kind of databases here

00:16:44,560 --> 00:16:47,839
for each microservice they believe in

00:16:46,399 --> 00:16:50,639
microservice of course everybody

00:16:47,839 --> 00:16:52,240
believes in microservices

00:16:50,639 --> 00:16:54,560
so we still have those three micro

00:16:52,240 --> 00:16:56,800
services and on top of this

00:16:54,560 --> 00:16:58,560
we have a new concept which is which is

00:16:56,800 --> 00:16:58,959
usually called a stream yeah as we

00:16:58,560 --> 00:17:01,600
learned

00:16:58,959 --> 00:17:03,360
what a stream is so you could also call

00:17:01,600 --> 00:17:05,199
it a data pipe or it could

00:17:03,360 --> 00:17:07,199
just be called kafka or pulsar or

00:17:05,199 --> 00:17:09,039
rabbitmq whatever it is right

00:17:07,199 --> 00:17:10,559
but the idea is that those microservices

00:17:09,039 --> 00:17:12,400
are talking with the stream they not

00:17:10,559 --> 00:17:14,079
talk directly to each other they publish

00:17:12,400 --> 00:17:14,959
events so for example if a new customer

00:17:14,079 --> 00:17:17,039
is created

00:17:14,959 --> 00:17:18,240
then you publish an event to this kind

00:17:17,039 --> 00:17:20,799
of event queue

00:17:18,240 --> 00:17:22,480
and once once this event is published

00:17:20,799 --> 00:17:23,360
this guy here can subscribe to this

00:17:22,480 --> 00:17:25,760
event queue

00:17:23,360 --> 00:17:27,360
and can say hey if a new sub if a new if

00:17:25,760 --> 00:17:29,200
a new customer is created then let's

00:17:27,360 --> 00:17:30,400
make a risk check how risky this

00:17:29,200 --> 00:17:32,240
customer is right

00:17:30,400 --> 00:17:33,760
and then you get a risk profile event

00:17:32,240 --> 00:17:35,039
and somebody who is interested in your

00:17:33,760 --> 00:17:37,280
risk profile event

00:17:35,039 --> 00:17:38,480
could listen to this right so we have

00:17:37,280 --> 00:17:40,000
this kind of

00:17:38,480 --> 00:17:41,520
asynchronous communication and

00:17:40,000 --> 00:17:43,360
decoupling on the backhand side which we

00:17:41,520 --> 00:17:43,760
don't focus too much on now because it's

00:17:43,360 --> 00:17:46,640
not

00:17:43,760 --> 00:17:46,960
it's not part of the of of this session

00:17:46,640 --> 00:17:48,880
but

00:17:46,960 --> 00:17:50,480
what we also then usually have here we

00:17:48,880 --> 00:17:51,280
don't have this classical gateway

00:17:50,480 --> 00:17:53,039
anymore

00:17:51,280 --> 00:17:54,799
we have something which we usually call

00:17:53,039 --> 00:17:57,200
a hydration

00:17:54,799 --> 00:17:58,320
um you can also call it simple front-end

00:17:57,200 --> 00:18:01,280
cache or that

00:17:58,320 --> 00:18:03,039
multiple terms for it i like the term

00:18:01,280 --> 00:18:05,200
hydration most

00:18:03,039 --> 00:18:07,200
so it's hydrating the current state of

00:18:05,200 --> 00:18:08,400
the system for the ui

00:18:07,200 --> 00:18:10,559
and the interesting thing after

00:18:08,400 --> 00:18:12,320
hydration is here that for example if

00:18:10,559 --> 00:18:14,880
there is a new risk profile

00:18:12,320 --> 00:18:16,720
the hydration will get modified and will

00:18:14,880 --> 00:18:17,760
fetch the data and will store it there

00:18:16,720 --> 00:18:19,679
right

00:18:17,760 --> 00:18:21,440
and this hydration then provides the

00:18:19,679 --> 00:18:23,360
data to the front end

00:18:21,440 --> 00:18:25,760
and you could replace this hydration by

00:18:23,360 --> 00:18:27,679
graphql for example because graphql is

00:18:25,760 --> 00:18:29,919
mainly used in situations so you can

00:18:27,679 --> 00:18:32,000
love graphql for multiple things

00:18:29,919 --> 00:18:33,360
you can love it for it's for its schema

00:18:32,000 --> 00:18:35,200
you can love it for

00:18:33,360 --> 00:18:37,440
for the for the for them for the

00:18:35,200 --> 00:18:39,039
querying mechanism it supports

00:18:37,440 --> 00:18:40,559
but you can also love it for being a

00:18:39,039 --> 00:18:42,559
perfect hydration

00:18:40,559 --> 00:18:44,320
and if you think about this now if the

00:18:42,559 --> 00:18:46,400
ui has this hydration

00:18:44,320 --> 00:18:48,160
where the data is stored in a way how

00:18:46,400 --> 00:18:49,760
the ui needs it yeah

00:18:48,160 --> 00:18:52,000
then you can fully decouple those

00:18:49,760 --> 00:18:53,760
systems because every time you get here

00:18:52,000 --> 00:18:56,880
an event which is interesting

00:18:53,760 --> 00:18:58,480
for this kind of ui application the data

00:18:56,880 --> 00:18:59,280
is stored in a hydration this is a

00:18:58,480 --> 00:19:03,120
dynamodb

00:18:59,280 --> 00:19:04,400
this is a graphql instance whatever it

00:19:03,120 --> 00:19:06,960
is right usually it's called

00:19:04,400 --> 00:19:08,720
quality states and the interesting thing

00:19:06,960 --> 00:19:09,440
is you get a lot of resilience here

00:19:08,720 --> 00:19:11,679
because

00:19:09,440 --> 00:19:13,280
those services could be down for 25

00:19:11,679 --> 00:19:14,799
minutes and you could still read all the

00:19:13,280 --> 00:19:16,320
relevant data which you need for a

00:19:14,799 --> 00:19:18,400
customer and if somebody

00:19:16,320 --> 00:19:20,080
makes some kind of mutation here right

00:19:18,400 --> 00:19:22,160
then you just store it here until the

00:19:20,080 --> 00:19:24,080
services are available again

00:19:22,160 --> 00:19:25,919
and this has this huge advantage and

00:19:24,080 --> 00:19:28,400
that's why by people

00:19:25,919 --> 00:19:30,400
that's why why you usually live use um

00:19:28,400 --> 00:19:31,039
craft quail for this because craft quail

00:19:30,400 --> 00:19:33,039
has

00:19:31,039 --> 00:19:35,039
this direct subscription support right

00:19:33,039 --> 00:19:37,200
you can really stream data

00:19:35,039 --> 00:19:38,080
from the back end to the front end and

00:19:37,200 --> 00:19:40,400
you really move

00:19:38,080 --> 00:19:42,080
from a classical pool architecture to a

00:19:40,400 --> 00:19:44,000
fully push architecture

00:19:42,080 --> 00:19:45,760
and that's actually amazing yeah so

00:19:44,000 --> 00:19:47,919
these are reactive architectures right

00:19:45,760 --> 00:19:50,400
so graphql always works best

00:19:47,919 --> 00:19:52,080
with mutations and subscriptions yeah

00:19:50,400 --> 00:19:55,200
keep this in mind if you ever work with

00:19:52,080 --> 00:19:57,280
it and from this perspective we got

00:19:55,200 --> 00:19:59,200
this kind of resilience because we can

00:19:57,280 --> 00:20:00,480
actually close this and this application

00:19:59,200 --> 00:20:02,559
would still work

00:20:00,480 --> 00:20:04,240
we have this kind of huge massive

00:20:02,559 --> 00:20:05,760
scalability where we say

00:20:04,240 --> 00:20:07,360
if we would have a mobile client this

00:20:05,760 --> 00:20:09,200
mobile client would also have its own

00:20:07,360 --> 00:20:11,280
hydration and we would store data in a

00:20:09,200 --> 00:20:13,440
way how we would need it here right

00:20:11,280 --> 00:20:15,760
and from this perspective we have this

00:20:13,440 --> 00:20:17,840
decoupling of the of the

00:20:15,760 --> 00:20:19,679
of the different channels and we also

00:20:17,840 --> 00:20:21,280
have this kind of scalability and

00:20:19,679 --> 00:20:25,120
resilience advantages

00:20:21,280 --> 00:20:27,760
yeah but if the microservice

00:20:25,120 --> 00:20:35,520
is down it will not work sure it would

00:20:27,760 --> 00:20:38,080
work because the data is stored here

00:20:35,520 --> 00:20:39,039
sure i mean that's what i meant you can

00:20:38,080 --> 00:20:41,520
you can always

00:20:39,039 --> 00:20:43,360
you can you can always read from it yeah

00:20:41,520 --> 00:20:43,760
but of course mutations would be hold

00:20:43,360 --> 00:20:49,840
back

00:20:43,760 --> 00:20:49,840
until the system is available again

00:20:53,840 --> 00:20:57,360
you can update the hydration for example

00:20:55,760 --> 00:20:59,600
right you usually do this in an

00:20:57,360 --> 00:21:01,120
event driven approach where you would

00:20:59,600 --> 00:21:02,720
use

00:21:01,120 --> 00:21:05,120
sorry where you would collect the

00:21:02,720 --> 00:21:07,440
updates yeah and then you would publish

00:21:05,120 --> 00:21:09,360
them back to the to the core systems

00:21:07,440 --> 00:21:11,120
but you could of course up the hydration

00:21:09,360 --> 00:21:11,919
you could also update the hydration say

00:21:11,120 --> 00:21:14,320
hey

00:21:11,919 --> 00:21:16,880
it's it's not persisted yet but this is

00:21:14,320 --> 00:21:19,919
your current state yeah

00:21:16,880 --> 00:21:21,919
okay so in eighty percent of the

00:21:19,919 --> 00:21:23,919
use cases it's more important that

00:21:21,919 --> 00:21:24,640
people can read and they can always

00:21:23,919 --> 00:21:26,159
write right

00:21:24,640 --> 00:21:27,679
if you have the choice it's better that

00:21:26,159 --> 00:21:30,240
you at least can read

00:21:27,679 --> 00:21:31,360
um but in this architecture you always

00:21:30,240 --> 00:21:32,960
can read yeah

00:21:31,360 --> 00:21:34,720
but it's a it's a very valid question of

00:21:32,960 --> 00:21:36,640
course it doesn't it doesn't make a

00:21:34,720 --> 00:21:38,240
system fully resilient

00:21:36,640 --> 00:21:40,000
if something is dying then something is

00:21:38,240 --> 00:21:41,840
dying right you cannot you cannot you

00:21:40,000 --> 00:21:45,600
can do like nothing happened

00:21:41,840 --> 00:21:47,840
but this kind of of streaming um comes

00:21:45,600 --> 00:21:49,520
with a lot of examples with a lot of

00:21:47,840 --> 00:21:50,400
advantages one of them is of course

00:21:49,520 --> 00:21:52,559
resilience

00:21:50,400 --> 00:21:54,320
and scalability but another one is what

00:21:52,559 --> 00:21:56,000
i what i discussed before

00:21:54,320 --> 00:21:57,760
if this mobile client now makes a

00:21:56,000 --> 00:21:58,880
mutation right if he changes the

00:21:57,760 --> 00:22:01,520
customer name

00:21:58,880 --> 00:22:03,039
then this goes to this kind of event

00:22:01,520 --> 00:22:04,240
queue where he say hey i want to update

00:22:03,039 --> 00:22:06,240
the customer name

00:22:04,240 --> 00:22:07,840
then the customer microservice updates

00:22:06,240 --> 00:22:09,600
the customer name red spec hey the

00:22:07,840 --> 00:22:12,000
customer name was updated

00:22:09,600 --> 00:22:13,600
and both hydrations which are maybe

00:22:12,000 --> 00:22:15,039
listening to this event because it's

00:22:13,600 --> 00:22:16,880
interesting to them right

00:22:15,039 --> 00:22:19,039
can update their data in their hydration

00:22:16,880 --> 00:22:20,559
yeah and with graphql you directly

00:22:19,039 --> 00:22:22,480
stream this out because

00:22:20,559 --> 00:22:24,000
people are usually subscribing and every

00:22:22,480 --> 00:22:26,080
time the customer changes

00:22:24,000 --> 00:22:27,280
you get this directly reflected here it

00:22:26,080 --> 00:22:29,360
would be cool

00:22:27,280 --> 00:22:31,919
um if i could show you this direct link

00:22:29,360 --> 00:22:34,080
oh yeah unfortunately that's working

00:22:31,919 --> 00:22:35,760
um but but this is this is what it is

00:22:34,080 --> 00:22:37,520
about reactive architecture and i don't

00:22:35,760 --> 00:22:38,320
want to go too much into detail because

00:22:37,520 --> 00:22:40,320
it would

00:22:38,320 --> 00:22:41,360
it would it would not make sense in this

00:22:40,320 --> 00:22:43,360
limited time

00:22:41,360 --> 00:22:44,880
but i just want to make this point to

00:22:43,360 --> 00:22:46,320
make you understand that reactive

00:22:44,880 --> 00:22:48,240
programming is not just using

00:22:46,320 --> 00:22:49,919
observables and reactive programming is

00:22:48,240 --> 00:22:52,400
not just you know

00:22:49,919 --> 00:22:54,240
putting putting dollar signs in in front

00:22:52,400 --> 00:22:56,799
of of your spell decode it's much

00:22:54,240 --> 00:22:57,840
more and i think it's a very very future

00:22:56,799 --> 00:23:00,320
movement

00:22:57,840 --> 00:23:02,799
because i see more and more people going

00:23:00,320 --> 00:23:04,799
in this reactive architectures

00:23:02,799 --> 00:23:06,320
and i would expect more and more people

00:23:04,799 --> 00:23:07,679
going there if they would know these

00:23:06,320 --> 00:23:09,600
concepts

00:23:07,679 --> 00:23:11,200
so i think lots of people are still

00:23:09,600 --> 00:23:12,880
building synchronous microservices or

00:23:11,200 --> 00:23:15,440
synchronous architectures because

00:23:12,880 --> 00:23:17,440
they do not know better yeah so i think

00:23:15,440 --> 00:23:20,240
this is a this is a huge strength which

00:23:17,440 --> 00:23:21,760
is coming up in the next few years

00:23:20,240 --> 00:23:23,600
and the advantage is that we have

00:23:21,760 --> 00:23:24,880
started it more or less from a front-end

00:23:23,600 --> 00:23:28,159
perspective

00:23:24,880 --> 00:23:31,440
because i i would i would just

00:23:28,159 --> 00:23:35,039
just continue here exactly like this um

00:23:31,440 --> 00:23:38,080
because if you now think about the

00:23:35,039 --> 00:23:39,679
the reactiveness right

00:23:38,080 --> 00:23:42,080
which i tried to explain here with these

00:23:39,679 --> 00:23:43,120
three examples then we can again make

00:23:42,080 --> 00:23:45,840
this comparison

00:23:43,120 --> 00:23:47,520
when it comes to reactiveness in single

00:23:45,840 --> 00:23:51,840
page applications right

00:23:47,520 --> 00:23:51,840
and i will for example select here

00:23:52,400 --> 00:23:57,440
angular because i guess very very many

00:23:55,840 --> 00:23:59,679
of you are familiar with angular and the

00:23:57,440 --> 00:24:02,400
second big player is of course react

00:23:59,679 --> 00:24:03,440
and i like to use those not because i

00:24:02,400 --> 00:24:06,080
think they are

00:24:03,440 --> 00:24:07,039
the best ones but they are super easy to

00:24:06,080 --> 00:24:19,840
compare

00:24:07,039 --> 00:24:19,840
um i will just remove this here again

00:24:20,000 --> 00:24:23,440
so i'm gonna interact okay and if we

00:24:21,520 --> 00:24:26,320
talk about reactiveness um

00:24:23,440 --> 00:24:33,840
in those two particular frameworks just

00:24:26,320 --> 00:24:33,840
need to add some less

00:24:41,279 --> 00:24:46,480
then we have usually two kind of things

00:24:45,039 --> 00:24:49,760
right

00:24:46,480 --> 00:24:51,360
we have what is a prize we have we have

00:24:49,760 --> 00:24:53,600
component driven development that's what

00:24:51,360 --> 00:24:56,720
we have in all single page applications

00:24:53,600 --> 00:24:56,720
and we have html

00:24:57,600 --> 00:25:06,320
and in addition we have again html

00:25:03,039 --> 00:25:06,320
actually it's the other way around

00:25:08,559 --> 00:25:16,960
we have html and we have no no no no

00:25:12,720 --> 00:25:20,559
it's a very very own

00:25:16,960 --> 00:25:22,799
a lot of things um we have javascript so

00:25:20,559 --> 00:25:22,799
yeah

00:25:23,520 --> 00:25:27,919
we have javascript two terms right um

00:25:26,159 --> 00:25:29,520
and their water here is very important

00:25:27,919 --> 00:25:32,320
then i will explain you what this has to

00:25:29,520 --> 00:25:36,480
do with reactiveness yeah

00:25:32,320 --> 00:25:37,279
um for those who who know me already i

00:25:36,480 --> 00:25:39,279
guess notice

00:25:37,279 --> 00:25:41,440
this saying but the fundamental

00:25:39,279 --> 00:25:45,120
difference between react and angular

00:25:41,440 --> 00:25:45,600
is actually the flow of of of data or

00:25:45,120 --> 00:25:47,120
the

00:25:45,600 --> 00:25:49,440
the eccentricness of the of the

00:25:47,120 --> 00:25:50,559
framework that's the main difference of

00:25:49,440 --> 00:25:54,720
the concept

00:25:50,559 --> 00:25:56,559
so in indirect you you create html out

00:25:54,720 --> 00:25:58,400
of your javascript right so react is a

00:25:56,559 --> 00:25:59,600
javascript centric framework where you

00:25:58,400 --> 00:26:01,120
start with the javascript

00:25:59,600 --> 00:26:03,919
out of the javascript you render the

00:26:01,120 --> 00:26:05,440
html right in angular it was always the

00:26:03,919 --> 00:26:08,400
other way around right even

00:26:05,440 --> 00:26:10,720
if it's a little bit fluffy now but yeah

00:26:08,400 --> 00:26:12,880
the idea was always to start with html

00:26:10,720 --> 00:26:14,880
and by to the javascript right

00:26:12,880 --> 00:26:15,919
so in red you create html out of

00:26:14,880 --> 00:26:18,159
javascript

00:26:15,919 --> 00:26:19,520
in angular you bind javascript to html

00:26:18,159 --> 00:26:21,360
that's the fundamental difference

00:26:19,520 --> 00:26:23,120
between those two frameworks if you

00:26:21,360 --> 00:26:24,559
if you think of it on a very abstract

00:26:23,120 --> 00:26:26,640
level this has of course a lot of

00:26:24,559 --> 00:26:29,520
impact on all the other design decisions

00:26:26,640 --> 00:26:38,400
but this is the main difference yeah

00:26:29,520 --> 00:26:41,440
and and step sorry

00:26:38,400 --> 00:26:43,520
and that the the the coming back to

00:26:41,440 --> 00:26:46,000
reactivity now is here

00:26:43,520 --> 00:26:47,200
um that in react that's why it's called

00:26:46,000 --> 00:26:49,360
maybe react yeah

00:26:47,200 --> 00:26:51,120
you can grade this html just directly

00:26:49,360 --> 00:26:53,360
out of javascript

00:26:51,120 --> 00:26:54,960
and reactivity in react is implemented

00:26:53,360 --> 00:26:57,760
in a very simple way

00:26:54,960 --> 00:26:58,240
because if you think back about this

00:26:57,760 --> 00:27:00,799
const

00:26:58,240 --> 00:27:02,799
or this variable abc example where say

00:27:00,799 --> 00:27:05,360
it whenever something on variable b

00:27:02,799 --> 00:27:06,080
changes um this should also be reflected

00:27:05,360 --> 00:27:08,159
in variable

00:27:06,080 --> 00:27:09,200
c right and whenever something in this

00:27:08,159 --> 00:27:11,440
javascript

00:27:09,200 --> 00:27:13,520
um or something triggers this javascript

00:27:11,440 --> 00:27:14,400
this is a direct impact to the html

00:27:13,520 --> 00:27:17,760
right

00:27:14,400 --> 00:27:18,720
and reactive programming javascript is

00:27:17,760 --> 00:27:21,360
done without

00:27:18,720 --> 00:27:22,080
observables and without args most of the

00:27:21,360 --> 00:27:24,880
time

00:27:22,080 --> 00:27:26,960
because you could directly subscribe

00:27:24,880 --> 00:27:30,240
this javascript to something which is

00:27:26,960 --> 00:27:31,520
of interest for you like like a graphql

00:27:30,240 --> 00:27:32,840
subscription and then this would

00:27:31,520 --> 00:27:35,840
automatically

00:27:32,840 --> 00:27:37,440
reactively render this html and if you

00:27:35,840 --> 00:27:39,039
think about the react and if you think

00:27:37,440 --> 00:27:40,799
about what i showed you here that you

00:27:39,039 --> 00:27:43,279
have this kind of subscription to the

00:27:40,799 --> 00:27:45,919
hydration from your react application

00:27:43,279 --> 00:27:47,120
and this mutation to your hydration and

00:27:45,919 --> 00:27:49,120
this kind

00:27:47,120 --> 00:27:51,120
triggers some some kind of action which

00:27:49,120 --> 00:27:53,039
again gives you some kind of state and

00:27:51,120 --> 00:27:53,360
it's actually redux right and that's why

00:27:53,039 --> 00:27:55,200
it

00:27:53,360 --> 00:27:57,840
plays so well together with reactive

00:27:55,200 --> 00:28:00,320
system in itself because redux itself

00:27:57,840 --> 00:28:02,240
is a reactive system right on the

00:28:00,320 --> 00:28:04,080
angular side it was a little bit harder

00:28:02,240 --> 00:28:05,440
always because you had html and you had

00:28:04,080 --> 00:28:07,919
javascript so you had this

00:28:05,440 --> 00:28:09,840
html centric view and that's why we

00:28:07,919 --> 00:28:11,039
helped ourselves here with observables

00:28:09,840 --> 00:28:13,440
and things like this

00:28:11,039 --> 00:28:14,159
which makes the binding kind of reactive

00:28:13,440 --> 00:28:16,320
yeah

00:28:14,159 --> 00:28:17,760
but of course the natural reactiveness

00:28:16,320 --> 00:28:20,240
is given in reactant

00:28:17,760 --> 00:28:22,799
and and and usually not um so much in

00:28:20,240 --> 00:28:23,760
angular based on this fundamental core

00:28:22,799 --> 00:28:26,320
decision

00:28:23,760 --> 00:28:28,159
um back then but this was a different

00:28:26,320 --> 00:28:30,640
target group right here was

00:28:28,159 --> 00:28:31,679
react targeted javascript engineers we

00:28:30,640 --> 00:28:34,640
should have

00:28:31,679 --> 00:28:35,760
been able to build school ui's angular

00:28:34,640 --> 00:28:37,520
targeted

00:28:35,760 --> 00:28:39,039
web engineers which should have been

00:28:37,520 --> 00:28:44,399
able to touch

00:28:39,039 --> 00:28:48,320
detach the html with javascript

00:28:44,399 --> 00:28:51,440
so far so clear okay i i just need to

00:28:48,320 --> 00:28:55,200
order my my notes

00:28:51,440 --> 00:28:57,520
so how is it yeah okay um

00:28:55,200 --> 00:28:58,799
that's that's what i actually want to to

00:28:57,520 --> 00:28:59,840
to tell you a little bit about

00:28:58,799 --> 00:29:02,399
reactiveness

00:28:59,840 --> 00:29:04,320
i just want to give you those insights

00:29:02,399 --> 00:29:06,159
that i think reactiveness is not just on

00:29:04,320 --> 00:29:08,799
a programming level i think reactiveness

00:29:06,159 --> 00:29:10,960
is the movement in an architecture

00:29:08,799 --> 00:29:12,880
space itself and i think it will have an

00:29:10,960 --> 00:29:16,000
impact on on the way how we

00:29:12,880 --> 00:29:18,799
program things but in general

00:29:16,000 --> 00:29:19,520
um it is it is just three things right

00:29:18,799 --> 00:29:22,559
it is this

00:29:19,520 --> 00:29:25,039
kind of being super easy to to

00:29:22,559 --> 00:29:26,720
to synchronize between channels it

00:29:25,039 --> 00:29:29,520
supports us with resilience

00:29:26,720 --> 00:29:30,399
and it supports its scalability based on

00:29:29,520 --> 00:29:32,640
this ideas

00:29:30,399 --> 00:29:35,120
of not being a pull for the bush

00:29:32,640 --> 00:29:37,360
architecture

00:29:35,120 --> 00:29:38,799
okay the second thing um when i ask

00:29:37,360 --> 00:29:40,799
people hey what do you want to

00:29:38,799 --> 00:29:42,640
what do you what are you interested in

00:29:40,799 --> 00:29:43,600
actually when it comes to single page

00:29:42,640 --> 00:29:45,520
applications and

00:29:43,600 --> 00:29:47,200
i i expected the space to be a little

00:29:45,520 --> 00:29:50,000
bit much

00:29:47,200 --> 00:29:52,720
bigger but i will still make it and then

00:29:50,000 --> 00:29:54,240
they usually talk about virtual tone

00:29:52,720 --> 00:29:56,080
and they wanted to understand what is

00:29:54,240 --> 00:29:57,840
the virtual dome and what is what is

00:29:56,080 --> 00:29:59,760
actually angular using and what are

00:29:57,840 --> 00:30:01,679
the frameworks other frameworks using if

00:29:59,760 --> 00:30:05,200
they don't use the virtual dom

00:30:01,679 --> 00:30:05,200
um so who knows the virtual dom

00:30:05,279 --> 00:30:11,120
really everybody that's cool so

00:30:09,120 --> 00:30:12,720
there's a virtual door and the second

00:30:11,120 --> 00:30:14,559
thing is some of the incremental dom

00:30:12,720 --> 00:30:16,240
right

00:30:14,559 --> 00:30:19,520
i will i will start with the vertical

00:30:16,240 --> 00:30:19,520
tom so

00:30:20,480 --> 00:30:24,000
the virtual dom usually looks like this

00:30:22,240 --> 00:30:26,159
right

00:30:24,000 --> 00:30:27,679
it's a ui representation yeah the other

00:30:26,159 --> 00:30:30,080
way around more or less but it doesn't

00:30:27,679 --> 00:30:32,799
really matter to your representation

00:30:30,080 --> 00:30:34,399
um of of what you what you usually have

00:30:32,799 --> 00:30:35,520
in your application right

00:30:34,399 --> 00:30:38,240
and then you have something like a

00:30:35,520 --> 00:30:38,240
native tone

00:30:38,480 --> 00:30:41,919
and every time you change something

00:30:40,720 --> 00:30:44,640
between this kind of

00:30:41,919 --> 00:30:46,640
um on this on this kind of application

00:30:44,640 --> 00:30:48,240
where you for example click a button

00:30:46,640 --> 00:30:49,679
um this would would update the dom

00:30:48,240 --> 00:30:54,159
usually yeah

00:30:49,679 --> 00:30:55,679
and updating the dom usually reflects

00:30:54,159 --> 00:30:57,200
when you when you click a button this

00:30:55,679 --> 00:31:00,000
updates the dom and this usually needs

00:30:57,200 --> 00:31:02,960
to be reflected on the browser dom right

00:31:00,000 --> 00:31:04,080
and react for example uses this kind of

00:31:02,960 --> 00:31:07,360
virtual dom

00:31:04,080 --> 00:31:09,120
where they say um we store the current

00:31:07,360 --> 00:31:11,200
representation of the native dom and

00:31:09,120 --> 00:31:13,120
when somebody clicks on a button

00:31:11,200 --> 00:31:15,679
we just create a second vertical term

00:31:13,120 --> 00:31:16,840
right and we kind of just compare those

00:31:15,679 --> 00:31:19,760
vertical doms

00:31:16,840 --> 00:31:20,799
right and the diff between those virtual

00:31:19,760 --> 00:31:23,039
terms is then

00:31:20,799 --> 00:31:25,519
really reflected in the native dom and

00:31:23,039 --> 00:31:28,320
this is the advantage that native doms

00:31:25,519 --> 00:31:29,679
um that native dom manipulation and

00:31:28,320 --> 00:31:31,760
reading the native term and

00:31:29,679 --> 00:31:33,760
understanding if something has changed

00:31:31,760 --> 00:31:35,440
it's usually quite like quite cost

00:31:33,760 --> 00:31:38,320
intensive so that's why they

00:31:35,440 --> 00:31:39,360
dissolved it with this representation of

00:31:38,320 --> 00:31:42,000
the native tom

00:31:39,360 --> 00:31:42,480
in a virtual dom right and whenever they

00:31:42,000 --> 00:31:43,760
change

00:31:42,480 --> 00:31:45,679
whenever you change something or

00:31:43,760 --> 00:31:47,519
whenever the user changes something

00:31:45,679 --> 00:31:48,960
they create a second virtual dom to the

00:31:47,519 --> 00:31:51,519
diffing and then

00:31:48,960 --> 00:31:52,159
reflect it on the native dom and this

00:31:51,519 --> 00:31:54,799
was

00:31:52,159 --> 00:31:55,919
was somehow invented by react and lots

00:31:54,799 --> 00:31:57,760
of people said wow

00:31:55,919 --> 00:31:59,440
virtual dom that's the best thing ever

00:31:57,760 --> 00:32:00,480
and it was really cool and it is still

00:31:59,440 --> 00:32:02,720
really cool

00:32:00,480 --> 00:32:04,399
but it's interesting that more and more

00:32:02,720 --> 00:32:07,120
people are adopting

00:32:04,399 --> 00:32:08,159
to some kind of different um to some

00:32:07,120 --> 00:32:10,559
kind of

00:32:08,159 --> 00:32:12,799
different term yeah and that's the

00:32:10,559 --> 00:32:14,480
second topic of the reactive program

00:32:12,799 --> 00:32:16,880
which i want to touch a little bit

00:32:14,480 --> 00:32:19,120
a little bit more in detail um is

00:32:16,880 --> 00:32:21,200
virtual first is incremental dominion

00:32:19,120 --> 00:32:23,840
who knows who knows the concept of

00:32:21,200 --> 00:32:26,159
incremental doms

00:32:23,840 --> 00:32:27,440
is there somebody who who is who is

00:32:26,159 --> 00:32:30,320
experienced with few

00:32:27,440 --> 00:32:30,320
future s3

00:32:30,640 --> 00:32:35,840
okay a little bit okay

00:32:33,919 --> 00:32:39,519
because there's a there's definitely a

00:32:35,840 --> 00:32:42,480
rise of incremental doms yeah

00:32:39,519 --> 00:32:43,760
i mean also react itself is not a pure

00:32:42,480 --> 00:32:45,840
vertical tom anymore but

00:32:43,760 --> 00:32:47,200
it doesn't doesn't really matter but

00:32:45,840 --> 00:32:49,360
incremental doms

00:32:47,200 --> 00:32:50,399
have have a different have a different

00:32:49,360 --> 00:32:52,399
behavior

00:32:50,399 --> 00:32:54,080
usually you have as as i said before

00:32:52,399 --> 00:32:55,120
these kind of components here right and

00:32:54,080 --> 00:32:58,320
just make this as a

00:32:55,120 --> 00:32:59,919
this is yeah just fell apart

00:32:58,320 --> 00:33:01,360
so you have these components right they

00:32:59,919 --> 00:33:04,399
look like this

00:33:01,360 --> 00:33:05,120
small small squares nice small squares

00:33:04,399 --> 00:33:06,960
yeah

00:33:05,120 --> 00:33:09,200
and you have multiple components right

00:33:06,960 --> 00:33:11,440
as you have here in one virtual tom

00:33:09,200 --> 00:33:14,399
you have them totally separated and you

00:33:11,440 --> 00:33:19,360
have them autonomous right

00:33:14,399 --> 00:33:21,919
and if you think about incremental dom

00:33:19,360 --> 00:33:23,760
then then angular after the iv compiler

00:33:21,919 --> 00:33:24,080
is a very good example because what they

00:33:23,760 --> 00:33:27,200
do

00:33:24,080 --> 00:33:30,240
is they compile each component to a

00:33:27,200 --> 00:33:32,799
fully separate autonomous

00:33:30,240 --> 00:33:34,559
dom representation actually function

00:33:32,799 --> 00:33:37,600
which can manipulate the dom

00:33:34,559 --> 00:33:40,720
yeah and which even knows

00:33:37,600 --> 00:33:43,360
when and how to update the dom

00:33:40,720 --> 00:33:45,039
and if we come back to the virtual dom

00:33:43,360 --> 00:33:47,039
that the main disadvantage

00:33:45,039 --> 00:33:48,240
which people have is the virtual dom is

00:33:47,039 --> 00:33:50,480
this example this

00:33:48,240 --> 00:33:52,640
honestly stupid example of having a list

00:33:50,480 --> 00:33:54,080
of 10 000 items right

00:33:52,640 --> 00:33:56,159
where you see how long does it take

00:33:54,080 --> 00:33:58,640
react to reorder those 10 000

00:33:56,159 --> 00:34:00,480
items right and usually that's a that's

00:33:58,640 --> 00:34:02,399
a that's a problem with the virtual dom

00:34:00,480 --> 00:34:04,320
because you have you know this thing and

00:34:02,399 --> 00:34:05,840
giving is also not for free even if you

00:34:04,320 --> 00:34:08,720
do it on a virtual dom

00:34:05,840 --> 00:34:09,440
basis and and it you always need to give

00:34:08,720 --> 00:34:11,280
the whole doll

00:34:09,440 --> 00:34:12,960
for each interaction that's that's that

00:34:11,280 --> 00:34:14,079
the performance downside of react

00:34:12,960 --> 00:34:15,760
actually

00:34:14,079 --> 00:34:17,839
and with angular and also this future

00:34:15,760 --> 00:34:18,800
s3d they changed this approach towards

00:34:17,839 --> 00:34:21,200
the later stage

00:34:18,800 --> 00:34:22,560
now we don't want to have this big

00:34:21,200 --> 00:34:24,720
virtual dom

00:34:22,560 --> 00:34:26,879
which we compare to each other we want

00:34:24,720 --> 00:34:28,800
to have fully autonomous independent

00:34:26,879 --> 00:34:30,720
components which are compiled down to

00:34:28,800 --> 00:34:33,919
javascript functions actually

00:34:30,720 --> 00:34:35,760
and every time something changes we tell

00:34:33,919 --> 00:34:36,879
this javascript function hey one of your

00:34:35,760 --> 00:34:39,679
property has changed

00:34:36,879 --> 00:34:40,800
do whatever you want to do with it but

00:34:39,679 --> 00:34:43,839
we don't do

00:34:40,800 --> 00:34:45,839
a general dom diffing and this comes

00:34:43,839 --> 00:34:47,599
with two advantages this in the in the

00:34:45,839 --> 00:34:48,800
case of the very long list this counts

00:34:47,599 --> 00:34:50,639
as the advantage

00:34:48,800 --> 00:34:52,159
that if this is the list component it

00:34:50,639 --> 00:34:53,839
could already say okay this was just a

00:34:52,159 --> 00:34:55,520
reordering of the list

00:34:53,839 --> 00:34:57,280
i don't need to tell the list item that

00:34:55,520 --> 00:34:59,839
it should do anything right

00:34:57,280 --> 00:35:02,720
and the second thing is and this brings

00:34:59,839 --> 00:35:06,960
me nearly to the end

00:35:02,720 --> 00:35:06,960
is that you don't need

00:35:07,920 --> 00:35:11,200
this kind of rendering engine here right

00:35:10,720 --> 00:35:13,119
because

00:35:11,200 --> 00:35:14,320
if you have two virtual doms you need

00:35:13,119 --> 00:35:15,920
some logic

00:35:14,320 --> 00:35:17,760
which makes the diffing of those two

00:35:15,920 --> 00:35:20,560
virtual doms right

00:35:17,760 --> 00:35:22,880
and this comes with the with the

00:35:20,560 --> 00:35:23,200
downsides that you always have this kind

00:35:22,880 --> 00:35:25,599
of

00:35:23,200 --> 00:35:27,200
um runtime dependency and that you

00:35:25,599 --> 00:35:30,000
always have this kind of

00:35:27,200 --> 00:35:32,160
um at least yeah that you always need

00:35:30,000 --> 00:35:36,720
this runtime dependency

00:35:32,160 --> 00:35:40,000
and this kind of incremental dom

00:35:36,720 --> 00:35:42,480
brings us the advantage of having

00:35:40,000 --> 00:35:44,640
compiler first frameworks or compilers

00:35:42,480 --> 00:35:47,119
other new frameworks because you move

00:35:44,640 --> 00:35:48,400
all your runtime dependencies to the

00:35:47,119 --> 00:35:50,560
build time yeah

00:35:48,400 --> 00:35:52,480
and this is the this is the main idea

00:35:50,560 --> 00:35:54,160
behind future s3 why they went to

00:35:52,480 --> 00:35:56,320
incremental terms and this is the main

00:35:54,160 --> 00:35:57,200
idea also behind angola because they can

00:35:56,320 --> 00:35:59,839
say

00:35:57,200 --> 00:36:02,240
we can now start the tree shake the

00:35:59,839 --> 00:36:04,640
runtime dependencies or the dependencies

00:36:02,240 --> 00:36:06,960
we need because if these components

00:36:04,640 --> 00:36:09,599
for rendering don't need anything of

00:36:06,960 --> 00:36:11,920
this rendering engine like i don't know

00:36:09,599 --> 00:36:13,200
some special functionality we can easily

00:36:11,920 --> 00:36:14,800
reshake it here

00:36:13,200 --> 00:36:16,640
here the rendering engine will always

00:36:14,800 --> 00:36:17,119
stay as fat as it is right and you

00:36:16,640 --> 00:36:20,000
cannot

00:36:17,119 --> 00:36:21,839
cannot get rid of this and this brings

00:36:20,000 --> 00:36:23,839
me already to the

00:36:21,839 --> 00:36:25,280
to the to the last part which i want to

00:36:23,839 --> 00:36:26,720
go into detail

00:36:25,280 --> 00:36:28,720
which is compilers are the new

00:36:26,720 --> 00:36:29,839
frameworks and i think this is a very

00:36:28,720 --> 00:36:31,359
interesting movement

00:36:29,839 --> 00:36:33,680
in the in the world of single-page

00:36:31,359 --> 00:36:34,800
applications um where we see more and

00:36:33,680 --> 00:36:37,920
more frameworks

00:36:34,800 --> 00:36:39,440
um i need to put all of them swelter for

00:36:37,920 --> 00:36:42,720
example is kind of an

00:36:39,440 --> 00:36:44,400
example a better example is even stencil

00:36:42,720 --> 00:36:47,119
what they actually do is they are not a

00:36:44,400 --> 00:36:49,760
framework anymore like we know it

00:36:47,119 --> 00:36:51,440
um they are kind of a of a compiler

00:36:49,760 --> 00:36:54,480
which which just generates

00:36:51,440 --> 00:36:56,240
um some kind of of high high performing

00:36:54,480 --> 00:36:57,920
showers could without any run-time

00:36:56,240 --> 00:37:00,640
dependency

00:36:57,920 --> 00:37:01,680
and this is of course the advantage um

00:37:00,640 --> 00:37:03,520
that we can

00:37:01,680 --> 00:37:04,720
that we can decrease the size um

00:37:03,520 --> 00:37:06,560
intensively

00:37:04,720 --> 00:37:08,480
and for stencil for example this has

00:37:06,560 --> 00:37:09,839
even the advantage that it compiles down

00:37:08,480 --> 00:37:12,400
to web components

00:37:09,839 --> 00:37:14,880
and to pure web elements right so you

00:37:12,400 --> 00:37:16,880
don't have any third party dependency

00:37:14,880 --> 00:37:18,240
um in the best case you really um

00:37:16,880 --> 00:37:21,680
compile it down

00:37:18,240 --> 00:37:24,720
um to web standards yeah

00:37:21,680 --> 00:37:27,280
so i i know that everybody wants b

00:37:24,720 --> 00:37:29,359
so i will really make it short um i i

00:37:27,280 --> 00:37:31,599
would have two more points but i will

00:37:29,359 --> 00:37:34,000
not add them

00:37:31,599 --> 00:37:34,880
too too prominent i even don't find them

00:37:34,000 --> 00:37:36,880
right now

00:37:34,880 --> 00:37:40,480
the two more points would have been css

00:37:36,880 --> 00:37:40,480
in javascript and typescript

00:37:40,640 --> 00:37:43,680
i i i already knew that i will not make

00:37:43,440 --> 00:37:47,200
it

00:37:43,680 --> 00:37:48,400
to talk about them um so it's not so

00:37:47,200 --> 00:37:50,720
important because

00:37:48,400 --> 00:37:54,560
the advice for both of those topics is

00:37:50,720 --> 00:37:56,880
is similar just use them yeah

00:37:54,560 --> 00:37:58,079
we can talk it we can talk about it

00:37:56,880 --> 00:38:00,560
later at the ba

00:37:58,079 --> 00:38:01,920
if you if you're more interested yeah i

00:38:00,560 --> 00:38:04,480
hope that you understood

00:38:01,920 --> 00:38:05,359
um the the main ideas which i wanted to

00:38:04,480 --> 00:38:07,520
give here yeah

00:38:05,359 --> 00:38:08,960
this idea of reactive programming how an

00:38:07,520 --> 00:38:11,040
important role it will play in the

00:38:08,960 --> 00:38:13,599
future of single page applications

00:38:11,040 --> 00:38:15,760
and in architecture itself this move

00:38:13,599 --> 00:38:18,079
went from virtual toms to incremental

00:38:15,760 --> 00:38:20,160
terms back again yeah we had this in the

00:38:18,079 --> 00:38:21,119
backend world also where we said we need

00:38:20,160 --> 00:38:23,040
runtime

00:38:21,119 --> 00:38:24,880
we need we need runtimes because at

00:38:23,040 --> 00:38:26,800
runtime we can make systems more

00:38:24,880 --> 00:38:27,359
performant because we can learn from the

00:38:26,800 --> 00:38:30,720
system

00:38:27,359 --> 00:38:33,839
during its runtime and move now back um

00:38:30,720 --> 00:38:35,119
to ahead of ahead of time compilation

00:38:33,839 --> 00:38:36,720
and that's actually also what's

00:38:35,119 --> 00:38:38,320
happening in the in the single-page

00:38:36,720 --> 00:38:40,880
application space

00:38:38,320 --> 00:38:42,720
and this idea of of micro frameworks

00:38:40,880 --> 00:38:43,119
where you really just have a compiler

00:38:42,720 --> 00:38:45,599
and

00:38:43,119 --> 00:38:47,280
not a whole framework anymore and of

00:38:45,599 --> 00:38:51,200
course yeah just use css and

00:38:47,280 --> 00:38:53,839
cheers and and typescript that's it

00:38:51,200 --> 00:38:55,280
that's all um thanks thanks for taking

00:38:53,839 --> 00:38:58,240
your time i hope it was

00:38:55,280 --> 00:38:59,839
was useful just just the last sentence

00:38:58,240 --> 00:39:02,320
from my side

00:38:59,839 --> 00:39:03,280
a few a few people from vienna including

00:39:02,320 --> 00:39:06,320
me are

00:39:03,280 --> 00:39:09,440
organizing a conference this march it's

00:39:06,320 --> 00:39:09,440
called code grafts

00:39:11,520 --> 00:39:14,960
so if you're interested in these topics

00:39:14,320 --> 00:39:17,839
we will have

00:39:14,960 --> 00:39:19,040
also speakers like max driver there the

00:39:17,839 --> 00:39:21,200
one of the one of the

00:39:19,040 --> 00:39:22,400
thought leaders in the css in javascript

00:39:21,200 --> 00:39:25,040
space

00:39:22,400 --> 00:39:26,960
but also many more we will also have

00:39:25,040 --> 00:39:28,720
workshops exactly on the topics like

00:39:26,960 --> 00:39:29,680
reactive architectures and reactive

00:39:28,720 --> 00:39:32,560
programming

00:39:29,680 --> 00:39:33,040
so if you're interested um feels feel

00:39:32,560 --> 00:39:36,240
free

00:39:33,040 --> 00:39:39,760
um to visit us there and to join um

00:39:36,240 --> 00:39:42,390
codecrafting in march 2021

00:39:39,760 --> 00:39:46,750
thanks a lot for having me

00:39:42,390 --> 00:39:46,750

YouTube URL: https://www.youtube.com/watch?v=IKqNTqXBCcY


