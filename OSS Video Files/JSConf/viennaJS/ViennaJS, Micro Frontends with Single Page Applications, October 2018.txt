Title: ViennaJS, Micro Frontends with Single Page Applications, October 2018
Publication date: 2018-11-05
Playlist: viennaJS
Description: 
	Talk by Elias Dräxler

A micro frontend approach can make your life easier. We will look at different kind of micro frontend architectures and their benefits and drawbacks. I will explain and demonstrate how to use these techniques to achieve a modular frontend architecture using SPAs.
Captions: 
	00:00:00,030 --> 00:00:05,759
hello everyone my name is Elias Trexler

00:00:02,820 --> 00:00:07,770
I'm a developer at 12'o metrics as

00:00:05,759 --> 00:00:10,860
already mentioned and today I'm going to

00:00:07,770 --> 00:00:15,330
talk about micro front ins using single

00:00:10,860 --> 00:00:19,560
page applications so who heard about the

00:00:15,330 --> 00:00:24,080
term micro front end one two three who

00:00:19,560 --> 00:00:24,080
uses micro front ends okay

00:00:24,590 --> 00:00:31,410
so just a quick overview on what I'm

00:00:27,510 --> 00:00:36,149
going to present today at first we'll

00:00:31,410 --> 00:00:39,120
talk about what micro front ins are then

00:00:36,149 --> 00:00:41,809
I will present a few advantages and why

00:00:39,120 --> 00:00:46,379
you should use micro front ends I will

00:00:41,809 --> 00:00:48,420
explain a few different types of micro

00:00:46,379 --> 00:00:50,670
front and architectures will show an

00:00:48,420 --> 00:00:54,360
example using the single spar framework

00:00:50,670 --> 00:00:56,070
and at the end I want to talk about a

00:00:54,360 --> 00:00:59,359
few things that should be considered if

00:00:56,070 --> 00:01:04,170
you want to work with micro front ends

00:00:59,359 --> 00:01:09,659
so moment sorry my presentation does not

00:01:04,170 --> 00:01:12,030
work okay sorry now it's working

00:01:09,659 --> 00:01:14,490
so micro front end means that you break

00:01:12,030 --> 00:01:17,340
down your front and architecture your

00:01:14,490 --> 00:01:20,700
front end monolith into its features you

00:01:17,340 --> 00:01:23,040
could use one micro fronted for one

00:01:20,700 --> 00:01:25,409
bounded context from a business point of

00:01:23,040 --> 00:01:28,619
view and there are multiple different

00:01:25,409 --> 00:01:30,150
approaches and I'm going to explain two

00:01:28,619 --> 00:01:33,150
or three of them

00:01:30,150 --> 00:01:34,950
but there are of course more approaches

00:01:33,150 --> 00:01:37,710
so currently I'm working on a project

00:01:34,950 --> 00:01:42,290
and we use some kind of a micro

00:01:37,710 --> 00:01:45,270
front-end architecture and I started

00:01:42,290 --> 00:01:47,670
with this topic earlier last year when I

00:01:45,270 --> 00:01:49,290
started writing my bachelor thesis and I

00:01:47,670 --> 00:01:52,380
wanted to know what different options

00:01:49,290 --> 00:01:56,759
there are for single page application

00:01:52,380 --> 00:01:59,880
architecture so when I started writing

00:01:56,759 --> 00:02:03,390
my thesis I found the forward for twerks

00:01:59,880 --> 00:02:06,210
technology radar for those of you who

00:02:03,390 --> 00:02:10,020
don't know this they assess technologies

00:02:06,210 --> 00:02:12,770
and rate them and when I started I found

00:02:10,020 --> 00:02:17,690
the micro services in the

00:02:12,770 --> 00:02:20,330
ss part of the graph and this means that

00:02:17,690 --> 00:02:24,410
it's a pretty new thing and you should

00:02:20,330 --> 00:02:28,100
be pretty careful if you want to use it

00:02:24,410 --> 00:02:31,400
for a project nowadays since March 2017

00:02:28,100 --> 00:02:33,740
it's already in the trial part and it's

00:02:31,400 --> 00:02:40,240
a pretty good way to build your

00:02:33,740 --> 00:02:43,310
applications and I will show you why so

00:02:40,240 --> 00:02:45,260
if you use micro front-ends you have you

00:02:43,310 --> 00:02:47,840
could be you can be framework

00:02:45,260 --> 00:02:49,820
independent if you think about a chart

00:02:47,840 --> 00:02:52,070
there are many JavaScript frameworks and

00:02:49,820 --> 00:02:53,750
they are not easily interchangeable so

00:02:52,070 --> 00:02:56,270
if you build an application react and

00:02:53,750 --> 00:02:58,910
want to migrate it to angular that's not

00:02:56,270 --> 00:03:00,590
very easy to do so if you have a large

00:02:58,910 --> 00:03:03,050
project and you use only one framework

00:03:00,590 --> 00:03:04,610
you are very inflexible in the choices

00:03:03,050 --> 00:03:06,560
you can make

00:03:04,610 --> 00:03:09,740
and if you realize after year that you

00:03:06,560 --> 00:03:11,870
want to build a feature in another

00:03:09,740 --> 00:03:14,260
language for excel in another framework

00:03:11,870 --> 00:03:17,030
for example in react because it is

00:03:14,260 --> 00:03:23,120
easier to build this feature in react

00:03:17,030 --> 00:03:25,310
you cannot do it the next point is that

00:03:23,120 --> 00:03:28,400
each micro front-end can hold its own

00:03:25,310 --> 00:03:30,110
State and this means that each app only

00:03:28,400 --> 00:03:31,910
knows about its own state and it can

00:03:30,110 --> 00:03:35,330
decide what it publishes to the other

00:03:31,910 --> 00:03:38,510
applications there is no tight coupling

00:03:35,330 --> 00:03:40,460
between the components between the micro

00:03:38,510 --> 00:03:42,260
front-ends and they are easily

00:03:40,460 --> 00:03:45,140
interchangeable so you're way more

00:03:42,260 --> 00:03:47,570
flexible if you use one monolithic

00:03:45,140 --> 00:03:49,190
application you can do independent

00:03:47,570 --> 00:03:51,290
deployments for each micro front-end

00:03:49,190 --> 00:03:52,520
meaning that each team can decide when

00:03:51,290 --> 00:03:54,980
they want to release when they want to

00:03:52,520 --> 00:03:59,360
deploy without any dependencies on the

00:03:54,980 --> 00:04:02,620
other teams and there is no shared code

00:03:59,360 --> 00:04:06,740
base with other features for example and

00:04:02,620 --> 00:04:09,500
there are less conflicts and leading

00:04:06,740 --> 00:04:13,580
with all these points leading to a

00:04:09,500 --> 00:04:16,970
faster time to market and in the end

00:04:13,580 --> 00:04:18,200
what you could utilize and you should

00:04:16,970 --> 00:04:20,770
utilize if you want to build

00:04:18,200 --> 00:04:23,450
applications using micro front ends

00:04:20,770 --> 00:04:25,720
across functional teams just a short

00:04:23,450 --> 00:04:25,720
explanation

00:04:25,740 --> 00:04:32,160
you it means that the teams are have

00:04:30,090 --> 00:04:34,740
full control over the features they are

00:04:32,160 --> 00:04:38,610
building they can decide what frameworks

00:04:34,740 --> 00:04:42,150
they want to use for which is the best

00:04:38,610 --> 00:04:44,520
for their needs and you could you should

00:04:42,150 --> 00:04:49,190
use something like vertical sliced teams

00:04:44,520 --> 00:04:52,860
here's just a small picture how our

00:04:49,190 --> 00:04:55,650
company splitted the teams I'm currently

00:04:52,860 --> 00:04:57,389
in team Patil combat and we have we all

00:04:55,650 --> 00:05:00,690
do front-end and back-end development

00:04:57,389 --> 00:05:03,990
and at the top you see a fin the thing

00:05:00,690 --> 00:05:06,180
global application layer which leads me

00:05:03,990 --> 00:05:09,509
to the micro front and architecture

00:05:06,180 --> 00:05:11,280
approaches because all front all

00:05:09,509 --> 00:05:13,259
microphone and architecture approaches

00:05:11,280 --> 00:05:16,080
have this thing global application layer

00:05:13,259 --> 00:05:18,360
at the top that consolidates the micro

00:05:16,080 --> 00:05:20,870
front ends it provides a possibility for

00:05:18,360 --> 00:05:24,330
each for each child appliquéd

00:05:20,870 --> 00:05:30,570
applications to communicate with each

00:05:24,330 --> 00:05:31,889
other and it yeah and there are or as I

00:05:30,570 --> 00:05:33,840
already mentioned there are a few

00:05:31,889 --> 00:05:38,099
approaches single framework or multi

00:05:33,840 --> 00:05:40,400
framework approaches I will talk about

00:05:38,099 --> 00:05:43,860
the iframe approach and the single spa

00:05:40,400 --> 00:05:46,169
framework you could of course use web

00:05:43,860 --> 00:05:48,990
components for example or angular

00:05:46,169 --> 00:05:53,880
elements to implement these micro

00:05:48,990 --> 00:05:56,819
front-ends but I won't cover these so if

00:05:53,880 --> 00:05:58,229
you want a single framework approach it

00:05:56,819 --> 00:05:59,909
could mean that the teams create

00:05:58,229 --> 00:06:04,139
libraries and integrate them into one

00:05:59,909 --> 00:06:08,190
main application but if you think about

00:06:04,139 --> 00:06:10,830
it there is this would not grant you all

00:06:08,190 --> 00:06:15,449
the advantages that you could gain if

00:06:10,830 --> 00:06:17,849
you use multiple frameworks because if

00:06:15,449 --> 00:06:21,469
you use multiple frameworks the most

00:06:17,849 --> 00:06:25,289
important thing is that you have one

00:06:21,469 --> 00:06:28,289
common component library that all micro

00:06:25,289 --> 00:06:30,479
front-ends use because there's nothing

00:06:28,289 --> 00:06:33,360
more frustrating for a user to have a

00:06:30,479 --> 00:06:35,909
page and each part of the page looks

00:06:33,360 --> 00:06:37,320
different so for a single framework

00:06:35,909 --> 00:06:39,089
approach it's pretty easy you could use

00:06:37,320 --> 00:06:39,510
something if you use angular you could

00:06:39,089 --> 00:06:42,600
use

00:06:39,510 --> 00:06:44,670
material for multiple frameworks there

00:06:42,600 --> 00:06:46,470
has to be a different approach you could

00:06:44,670 --> 00:06:50,040
use a component library written as web

00:06:46,470 --> 00:06:51,920
components also if you want to use

00:06:50,040 --> 00:06:56,190
multiple frameworks then you have to

00:06:51,920 --> 00:06:57,660
utilize the Dom as the API so that micro

00:06:56,190 --> 00:07:01,440
front-ends can communicate with each

00:06:57,660 --> 00:07:03,390
other and the biggest point is that the

00:07:01,440 --> 00:07:06,810
teams can decide which framework they

00:07:03,390 --> 00:07:10,320
want to use and which grants them a lot

00:07:06,810 --> 00:07:12,480
of flexibility so - the first approach

00:07:10,320 --> 00:07:16,020
and I think it's the simplest approach

00:07:12,480 --> 00:07:18,030
you could you could just use iframes to

00:07:16,020 --> 00:07:21,840
integrate the applications into your

00:07:18,030 --> 00:07:23,880
main parent application at the project

00:07:21,840 --> 00:07:26,070
I'm working the project that i'm working

00:07:23,880 --> 00:07:29,060
at currently uses this approach and

00:07:26,070 --> 00:07:33,180
integrates one application into another

00:07:29,060 --> 00:07:36,570
but we use it only for one application

00:07:33,180 --> 00:07:38,460
if you think about a website and you

00:07:36,570 --> 00:07:42,960
want to use ten different micro

00:07:38,460 --> 00:07:44,880
front-ends and I will cover that in a

00:07:42,960 --> 00:07:48,120
minute when attack talk about the single

00:07:44,880 --> 00:07:52,530
spot framework you could think about it

00:07:48,120 --> 00:07:54,000
if you want to load ten applications in

00:07:52,530 --> 00:07:57,390
Internet Explorer in iframes

00:07:54,000 --> 00:08:01,170
I don't know I don't want to know how

00:07:57,390 --> 00:08:04,020
this would look like for the single spot

00:08:01,170 --> 00:08:07,890
approach it is a framework developed by

00:08:04,020 --> 00:08:09,540
the company canopy text and they develop

00:08:07,890 --> 00:08:13,140
this framework because they wanted to

00:08:09,540 --> 00:08:16,770
migrate their angularjs applications

00:08:13,140 --> 00:08:20,220
into angular 2 but they could not do it

00:08:16,770 --> 00:08:22,080
at once so he created this framework it

00:08:20,220 --> 00:08:24,270
has support from any single page

00:08:22,080 --> 00:08:27,780
application frameworks react angular

00:08:24,270 --> 00:08:31,110
beauteous view angularjs pre-act ember

00:08:27,780 --> 00:08:34,260
and delicious very long and what single

00:08:31,110 --> 00:08:37,080
spa does is it functions as a top-level

00:08:34,260 --> 00:08:41,240
router that mounts and unmount the child

00:08:37,080 --> 00:08:43,680
applications also you could load

00:08:41,240 --> 00:08:46,620
different applications for different

00:08:43,680 --> 00:08:47,430
URLs and it always lazy loads these

00:08:46,620 --> 00:08:50,520
applications

00:08:47,430 --> 00:08:53,060
so the initial loading time does not

00:08:50,520 --> 00:08:53,060
increase

00:08:53,100 --> 00:08:56,960
if you are interested in tools in

00:08:54,780 --> 00:09:00,270
server-side rendered micro front-ends

00:08:56,960 --> 00:09:03,330
for large-scale websites i won't cover

00:09:00,270 --> 00:09:06,000
these here but you should take a look at

00:09:03,330 --> 00:09:07,590
the project mosaic from solando it's a

00:09:06,000 --> 00:09:12,180
very interesting project and they have a

00:09:07,590 --> 00:09:15,000
very good approach so now I will show a

00:09:12,180 --> 00:09:18,210
small example using the single spot

00:09:15,000 --> 00:09:21,390
framework how to integrate for different

00:09:18,210 --> 00:09:22,950
applications into one page one

00:09:21,390 --> 00:09:25,170
application is written in react one in

00:09:22,950 --> 00:09:32,550
angular one in view and last one in

00:09:25,170 --> 00:09:34,710
angular one game so to my example if you

00:09:32,550 --> 00:09:40,200
look at it you have four different apps

00:09:34,710 --> 00:09:43,170
and one portal app and I the portal app

00:09:40,200 --> 00:09:44,850
is the main single spa application that

00:09:43,170 --> 00:09:52,920
is the parent application for all other

00:09:44,850 --> 00:09:55,830
applications and this is the main part

00:09:52,920 --> 00:09:59,480
of the framework I could say so you

00:09:55,830 --> 00:10:02,640
define what application should be loaded

00:09:59,480 --> 00:10:07,350
in this case we want to load for

00:10:02,640 --> 00:10:10,380
applications and here you can see the

00:10:07,350 --> 00:10:12,270
name of each application and where the

00:10:10,380 --> 00:10:17,340
main entry file for this for the

00:10:12,270 --> 00:10:22,410
framework should be loaded the URL the

00:10:17,340 --> 00:10:25,250
URL for the store the radix store in my

00:10:22,410 --> 00:10:28,380
case I use the radix sort to let these

00:10:25,250 --> 00:10:33,810
single micro front-ends communicate with

00:10:28,380 --> 00:10:39,510
each other and if we look at the load

00:10:33,810 --> 00:10:42,710
app all it does is it integrates the

00:10:39,510 --> 00:10:45,960
store into the into the main app so that

00:10:42,710 --> 00:10:47,670
the main app knows the instances of the

00:10:45,960 --> 00:10:51,180
stores from the child application so it

00:10:47,670 --> 00:10:53,640
can send actions and the most

00:10:51,180 --> 00:10:56,760
interesting part is the line at the

00:10:53,640 --> 00:10:58,080
bottom here you could see where we use

00:10:56,760 --> 00:11:01,050
the framework to register one

00:10:58,080 --> 00:11:06,950
application with a given name here we

00:11:01,050 --> 00:11:06,950
import the main application entry file

00:11:07,970 --> 00:11:14,310
this parameter should be a function that

00:11:10,829 --> 00:11:18,180
defines when these micro fronton should

00:11:14,310 --> 00:11:20,579
display in my case I wanted to display

00:11:18,180 --> 00:11:25,439
all these different microbes on the same

00:11:20,579 --> 00:11:29,540
page so I just simply defaulted to true

00:11:25,439 --> 00:11:32,759
so they all display every or regarding

00:11:29,540 --> 00:11:36,240
regardless of the URL but you could also

00:11:32,759 --> 00:11:40,019
do it that some applications display

00:11:36,240 --> 00:11:44,490
only for a specific part of the website

00:11:40,019 --> 00:11:49,230
and then at the end you can pass custom

00:11:44,490 --> 00:11:52,110
properties to the application for in

00:11:49,230 --> 00:11:56,910
this case it is used to pass in the

00:11:52,110 --> 00:11:59,339
global event distributor that is

00:11:56,910 --> 00:12:06,870
utilized to send the actions to the

00:11:59,339 --> 00:12:09,269
other components if we now look at the

00:12:06,870 --> 00:12:15,319
main entry file for off for example the

00:12:09,269 --> 00:12:15,319
angular application where is it

00:12:23,540 --> 00:12:31,200
there are different helper libraries for

00:12:26,610 --> 00:12:33,360
most of the frameworks but each library

00:12:31,200 --> 00:12:35,700
only does one thing it provides

00:12:33,360 --> 00:12:38,250
lifecycle hooks for the angular for the

00:12:35,700 --> 00:12:40,530
single spot framework to interact with

00:12:38,250 --> 00:12:43,140
your application you have to provide

00:12:40,530 --> 00:12:48,360
free lifecycle hooks the first one is

00:12:43,140 --> 00:12:50,580
the bootstrap this lifecycle function is

00:12:48,360 --> 00:12:51,960
called only once the first time before

00:12:50,580 --> 00:12:54,780
the framework bootstraps your

00:12:51,960 --> 00:12:59,490
application the next one is the mount

00:12:54,780 --> 00:13:01,560
life cycle that is called every time the

00:12:59,490 --> 00:13:05,010
application is mounted in the Dom from

00:13:01,560 --> 00:13:07,620
the single spot framework and at the and

00:13:05,010 --> 00:13:10,860
the last one is unmount that is called

00:13:07,620 --> 00:13:13,200
at the end when your applicant for

00:13:10,860 --> 00:13:15,270
example you want to show your

00:13:13,200 --> 00:13:18,150
application on a specific URL and the

00:13:15,270 --> 00:13:21,810
user changes the side then it the

00:13:18,150 --> 00:13:28,320
application will be unmounted okay so

00:13:21,810 --> 00:13:32,030
and example if we look at this page we

00:13:28,320 --> 00:13:35,190
can see four different applications and

00:13:32,030 --> 00:13:36,780
this whole page consists of the single

00:13:35,190 --> 00:13:39,300
spur framework at the best apparent

00:13:36,780 --> 00:13:43,200
application and at the top you see a

00:13:39,300 --> 00:13:45,360
beauteous application the left one is

00:13:43,200 --> 00:13:48,870
written in react the list of items is

00:13:45,360 --> 00:13:50,790
written in angular and the last

00:13:48,870 --> 00:13:55,200
component at the bottom is written in

00:13:50,790 --> 00:13:58,110
angular 1 these could also be written by

00:13:55,200 --> 00:14:02,550
different teams they are lazy loaded and

00:13:58,110 --> 00:14:06,420
could be deployed independently and just

00:14:02,550 --> 00:14:10,640
to show how these apps interact with

00:14:06,420 --> 00:14:15,000
each other they use a global store and

00:14:10,640 --> 00:14:16,980
so all applications can access this

00:14:15,000 --> 00:14:20,430
global State but they can also hold

00:14:16,980 --> 00:14:26,330
their own private application state that

00:14:20,430 --> 00:14:32,930
no other applications can see or change

00:14:26,330 --> 00:14:36,260
and in this case we can add a few items

00:14:32,930 --> 00:14:38,350
in this case it's a redox tour yes there

00:14:36,260 --> 00:14:42,100
are a few possibilities how you could

00:14:38,350 --> 00:14:45,350
you utilize messaging in this framework

00:14:42,100 --> 00:14:48,170
I decided to use an example from the

00:14:45,350 --> 00:14:51,710
website it's um it can be found in

00:14:48,170 --> 00:14:53,540
github and changed it a little bit but

00:14:51,710 --> 00:14:57,310
in the end it's a redox tour and all

00:14:53,540 --> 00:14:58,580
applications can send their actions and

00:14:57,310 --> 00:15:00,890
yeah

00:14:58,580 --> 00:15:03,260
what what's also really cool you can

00:15:00,890 --> 00:15:06,850
utilize you can still utilize all the

00:15:03,260 --> 00:15:10,430
routing in for example angular or react

00:15:06,850 --> 00:15:15,230
also the supports are also working so

00:15:10,430 --> 00:15:16,730
and after they they had the problem they

00:15:15,230 --> 00:15:18,230
wanted to migrate but they couldn't

00:15:16,730 --> 00:15:21,530
because they have this one big

00:15:18,230 --> 00:15:23,930
monolithic front-end and a few minutes

00:15:21,530 --> 00:15:26,180
like a few months later I saw a

00:15:23,930 --> 00:15:30,800
screenshot of their application and to

00:15:26,180 --> 00:15:35,090
use 10 to 15 single page application on

00:15:30,800 --> 00:15:40,100
one page and have this completely

00:15:35,090 --> 00:15:48,860
dynamic user experience so back to the

00:15:40,100 --> 00:15:50,510
slides so at the end just a few things

00:15:48,860 --> 00:15:52,880
that should be considered if you want to

00:15:50,510 --> 00:15:55,520
work with micro front-end if you have

00:15:52,880 --> 00:15:59,660
that many applications on one page there

00:15:55,520 --> 00:16:05,360
is always overhead because we already

00:15:59,660 --> 00:16:08,330
heard about possibilities to get better

00:16:05,360 --> 00:16:10,630
rendering time and of course you should

00:16:08,330 --> 00:16:13,760
you should utilize all them I couldn't

00:16:10,630 --> 00:16:17,990
explain them as good as the speaker

00:16:13,760 --> 00:16:19,610
before me but you should use them to

00:16:17,990 --> 00:16:22,730
battle the performance impacts that come

00:16:19,610 --> 00:16:25,040
with micro front ends it makes sense for

00:16:22,730 --> 00:16:27,770
big projects with many developers to

00:16:25,040 --> 00:16:30,140
split in these vertical slice teams but

00:16:27,770 --> 00:16:32,690
for small projects other approaches

00:16:30,140 --> 00:16:35,930
could be easier because the overhead of

00:16:32,690 --> 00:16:38,570
maintaining and creating such a

00:16:35,930 --> 00:16:40,370
microphone in architecture is maybe not

00:16:38,570 --> 00:16:43,130
worthwhile if the project is very small

00:16:40,370 --> 00:16:45,890
and you should also have a build

00:16:43,130 --> 00:16:46,610
pipeline you should have continuous

00:16:45,890 --> 00:16:49,160
integration

00:16:46,610 --> 00:16:52,550
structure because there are four some

00:16:49,160 --> 00:16:54,589
approaches very difficult complex builds

00:16:52,550 --> 00:16:57,769
and to integration is not always that

00:16:54,589 --> 00:16:59,060
easy and in the end it's just to say

00:16:57,769 --> 00:17:00,640
that microphones are not the solution

00:16:59,060 --> 00:17:04,400
for every problem

00:17:00,640 --> 00:17:06,199
to recap splitting micro fronting means

00:17:04,400 --> 00:17:08,809
that you split your monolithic

00:17:06,199 --> 00:17:12,500
application into smaller maintainable

00:17:08,809 --> 00:17:15,230
flexible microbes and there are a few

00:17:12,500 --> 00:17:17,929
different approaches and I it's I

00:17:15,230 --> 00:17:22,040
couldn't cover them all in this small

00:17:17,929 --> 00:17:23,540
talk but just to cut to say you could

00:17:22,040 --> 00:17:25,250
use iframes you could use the single

00:17:23,540 --> 00:17:27,490
spur framework you could use web

00:17:25,250 --> 00:17:30,260
components to encapsulate your

00:17:27,490 --> 00:17:32,419
applications but in the end it does not

00:17:30,260 --> 00:17:34,340
matter which approach you want to use

00:17:32,419 --> 00:17:36,020
the most important thing is that you

00:17:34,340 --> 00:17:37,630
know what goal you want to achieve when

00:17:36,020 --> 00:17:39,930
you want when you use micro front-ends

00:17:37,630 --> 00:17:43,339
thank you

00:17:39,930 --> 00:17:43,339

YouTube URL: https://www.youtube.com/watch?v=TRebTLB1F2g


