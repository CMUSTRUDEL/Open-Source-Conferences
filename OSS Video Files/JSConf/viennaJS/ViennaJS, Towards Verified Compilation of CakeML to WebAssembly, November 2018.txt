Title: ViennaJS, Towards Verified Compilation of CakeML to WebAssembly, November 2018
Publication date: 2018-11-29
Playlist: viennaJS
Description: 
	Talk By Lorenz Leutgeb:

WebAssembly should already be on your radar. I will approach it from formal methods and compilers, sharing my progress and challenges towards verified compilation of CakeML to WebAseembly. You'll not see much Javascript, but plain WebAssembly, some Higher Order Logic, and maybe CakeML.
Captions: 
	00:00:00,030 --> 00:00:04,319
I'll be talking about my work towards

00:00:02,040 --> 00:00:07,410
verified compilation of KML into

00:00:04,319 --> 00:00:10,710
webassembly so who of you raised hands

00:00:07,410 --> 00:00:15,269
has heard of webassembly before okay

00:00:10,710 --> 00:00:17,310
that's very good so this is basically

00:00:15,269 --> 00:00:18,390
the only connection that I will have to

00:00:17,310 --> 00:00:21,630
JavaScript

00:00:18,390 --> 00:00:25,619
so please please bear with me

00:00:21,630 --> 00:00:27,869
so web assembly is currently mostly

00:00:25,619 --> 00:00:28,820
being hosted in in browsers in browser

00:00:27,869 --> 00:00:31,410
runtimes

00:00:28,820 --> 00:00:33,780
inside of JavaScript so that's the

00:00:31,410 --> 00:00:35,910
connection that I have aside from that

00:00:33,780 --> 00:00:37,440
we will be talking about KML which is a

00:00:35,910 --> 00:00:41,719
functional programming language that I

00:00:37,440 --> 00:00:45,239
will introduce and it will be about

00:00:41,719 --> 00:00:47,430
software verification but first let me

00:00:45,239 --> 00:00:48,719
tell you how this all happened it was

00:00:47,430 --> 00:00:52,320
already introduced as a more academic

00:00:48,719 --> 00:00:54,930
talk and it kind of is so I'm currently

00:00:52,320 --> 00:00:57,390
studying computational logic which is

00:00:54,930 --> 00:01:00,300
the theoretical and dry part of computer

00:00:57,390 --> 00:01:03,449
science and a lot of mathematics but I

00:01:00,300 --> 00:01:06,390
really like it and this is a program

00:01:03,449 --> 00:01:09,450
being held at till traced in Rio

00:01:06,390 --> 00:01:10,710
University at Porton and taurine and in

00:01:09,450 --> 00:01:13,409
the summer I got the chance to go to

00:01:10,710 --> 00:01:15,240
Australia where I've been working on KML

00:01:13,409 --> 00:01:19,259
and this was an awesome experience and

00:01:15,240 --> 00:01:22,799
now I'm here to talk about it so first

00:01:19,259 --> 00:01:25,710
of all I will have a sort of prelude to

00:01:22,799 --> 00:01:27,479
what I'm going to be talking I will have

00:01:25,710 --> 00:01:29,280
to introduce software verification a bit

00:01:27,479 --> 00:01:31,350
because this is not what we commonly use

00:01:29,280 --> 00:01:33,360
in the workplace and then I will

00:01:31,350 --> 00:01:35,490
introduce briefly webassembly KML and

00:01:33,360 --> 00:01:37,439
then what it means to translate taken

00:01:35,490 --> 00:01:39,479
out to webassembly some words about

00:01:37,439 --> 00:01:41,490
verification and then where my work

00:01:39,479 --> 00:01:45,930
actually is currently and how it will

00:01:41,490 --> 00:01:47,850
continue so the motivation for software

00:01:45,930 --> 00:01:49,860
verification I guess you all know that

00:01:47,850 --> 00:01:53,490
software has bugs and in some cases

00:01:49,860 --> 00:01:54,780
parks mean injury and death to people

00:01:53,490 --> 00:01:56,759
and this is something that's really

00:01:54,780 --> 00:01:58,680
critical we're talking about critical

00:01:56,759 --> 00:02:01,200
infrastructure maybe this is not the

00:01:58,680 --> 00:02:04,140
case for your particular project but

00:02:01,200 --> 00:02:06,840
just look at the development of

00:02:04,140 --> 00:02:08,520
integrating integrating software systems

00:02:06,840 --> 00:02:10,709
into critical infrastructure and

00:02:08,520 --> 00:02:13,540
digitization so this is this is the

00:02:10,709 --> 00:02:15,490
topic that I'm picking up here

00:02:13,540 --> 00:02:17,050
critical infrastructure might not be

00:02:15,490 --> 00:02:19,510
what you think about it like power

00:02:17,050 --> 00:02:21,520
plants but some people even consider TLS

00:02:19,510 --> 00:02:23,770
implementations or operating systems as

00:02:21,520 --> 00:02:26,680
critical infrastructure because just

00:02:23,770 --> 00:02:29,500
think about I don't know weapon systems

00:02:26,680 --> 00:02:30,700
or airplanes they also run operating

00:02:29,500 --> 00:02:32,560
systems and they have to communicate

00:02:30,700 --> 00:02:34,510
securely and if something goes wrong

00:02:32,560 --> 00:02:37,480
there then it can go really wrong as I

00:02:34,510 --> 00:02:38,860
said before so that's the the frame

00:02:37,480 --> 00:02:42,430
we're operating in and there are many

00:02:38,860 --> 00:02:44,920
possible ways to achieve that the

00:02:42,430 --> 00:02:46,870
underlying question that you probably

00:02:44,920 --> 00:02:49,120
are also asking yourself even if you're

00:02:46,870 --> 00:02:52,000
not interest of the revocation is does

00:02:49,120 --> 00:02:55,150
my code do what it should and that of

00:02:52,000 --> 00:02:57,100
course varies project-by-project so it

00:02:55,150 --> 00:02:58,440
could be that your that your code has to

00:02:57,100 --> 00:03:01,840
be free of security vulnerabilities

00:02:58,440 --> 00:03:04,480
maybe it is a concurrent program and it

00:03:01,840 --> 00:03:06,190
should be deadlock free maybe it has to

00:03:04,480 --> 00:03:10,180
fulfill a certain specification maybe

00:03:06,190 --> 00:03:11,950
from a customer and then also the

00:03:10,180 --> 00:03:13,810
question of whether all resources that

00:03:11,950 --> 00:03:16,420
need to be accessed can actually be at

00:03:13,810 --> 00:03:20,020
some point accessed so no no particular

00:03:16,420 --> 00:03:21,880
worker in your system starves these are

00:03:20,020 --> 00:03:24,700
all properties that are quite tricky to

00:03:21,880 --> 00:03:26,320
actually have in a program and there are

00:03:24,700 --> 00:03:29,140
many ways to get to this point and

00:03:26,320 --> 00:03:32,650
verifying those you probably know about

00:03:29,140 --> 00:03:35,560
unit testing so commonly you would test

00:03:32,650 --> 00:03:37,240
your code and verify that certain runs

00:03:35,560 --> 00:03:40,360
through your code are actually doing

00:03:37,240 --> 00:03:42,850
what they should do so you have one so

00:03:40,360 --> 00:03:46,180
let's say for one unit test you have one

00:03:42,850 --> 00:03:47,890
run through your code usually and you

00:03:46,180 --> 00:03:49,540
can then test whether the result is

00:03:47,890 --> 00:03:52,990
actually correct but there's a slight

00:03:49,540 --> 00:03:54,550
problem because if you just look at the

00:03:52,990 --> 00:03:56,230
domain of strings for example there are

00:03:54,550 --> 00:03:59,470
infinitely many strings so you will just

00:03:56,230 --> 00:04:01,930
never be able to get to a certainty that

00:03:59,470 --> 00:04:05,500
your code is actually correct given the

00:04:01,930 --> 00:04:08,170
input being infinite so there are other

00:04:05,500 --> 00:04:10,570
approaches other testing approaches that

00:04:08,170 --> 00:04:12,250
have similar flaws so even if you do

00:04:10,570 --> 00:04:14,470
bigger tests you will run into more

00:04:12,250 --> 00:04:16,600
complicated scenarios but they kind of

00:04:14,470 --> 00:04:21,010
fall in a very very similar category and

00:04:16,600 --> 00:04:22,330
then if you want to do formal proof

00:04:21,010 --> 00:04:25,060
which is what I'm going to talk about

00:04:22,330 --> 00:04:26,370
this is also like unit tests to ensure

00:04:25,060 --> 00:04:30,030
that some

00:04:26,370 --> 00:04:31,949
program satisfies a property but in this

00:04:30,030 --> 00:04:34,800
case it's about a formal proof so you

00:04:31,949 --> 00:04:37,530
don't just get like a green icon in your

00:04:34,800 --> 00:04:39,780
IDE because some specific execution

00:04:37,530 --> 00:04:41,550
through your program worked but you

00:04:39,780 --> 00:04:43,919
actually in the end have a formal proof

00:04:41,550 --> 00:04:46,160
that any execution of your program

00:04:43,919 --> 00:04:48,720
behaves as specified which is a

00:04:46,160 --> 00:04:51,210
fundamentally different thing and it

00:04:48,720 --> 00:04:52,949
allows you to ask new questions about

00:04:51,210 --> 00:04:55,080
your program you can for example two

00:04:52,949 --> 00:04:57,240
equivalents between programs and so on

00:04:55,080 --> 00:04:59,789
and so forth which you cannot easily do

00:04:57,240 --> 00:05:02,699
by unit testing or in most cases you

00:04:59,789 --> 00:05:07,740
cannot even do that so is that a

00:05:02,699 --> 00:05:09,630
business yes it is but it's not as as I

00:05:07,740 --> 00:05:11,550
don't know another's mainstream as you

00:05:09,630 --> 00:05:14,130
would think so there are companies that

00:05:11,550 --> 00:05:16,620
do mostly static analysis and of course

00:05:14,130 --> 00:05:18,930
the big players have have dedicated

00:05:16,620 --> 00:05:22,530
teams working on that they develop

00:05:18,930 --> 00:05:24,930
static analyzers and compilers and the

00:05:22,530 --> 00:05:27,060
way this field started is actually

00:05:24,930 --> 00:05:29,789
through chip manufacturers because you

00:05:27,060 --> 00:05:32,389
can see a CPU or a chip also as

00:05:29,789 --> 00:05:34,889
something that executes a specification

00:05:32,389 --> 00:05:36,810
but in the case of chip development it's

00:05:34,889 --> 00:05:40,229
actually really hard to have this

00:05:36,810 --> 00:05:41,400
iterative debugging process going so if

00:05:40,229 --> 00:05:43,050
you have your IDE and you have a

00:05:41,400 --> 00:05:44,610
debugger and you step through and

00:05:43,050 --> 00:05:45,720
something goes wrong that's not

00:05:44,610 --> 00:05:49,440
something you can do when you're

00:05:45,720 --> 00:05:51,660
designing a CPU so you you have to

00:05:49,440 --> 00:05:53,250
you're more forced into this area of

00:05:51,660 --> 00:05:54,780
formal verification where you have to

00:05:53,250 --> 00:05:56,550
actually make sure that it works and

00:05:54,780 --> 00:05:58,620
then you can produce your chip and then

00:05:56,550 --> 00:06:02,240
you can run it but you cannot iterate as

00:05:58,620 --> 00:06:05,039
quickly as with just pure software and

00:06:02,240 --> 00:06:06,360
what I'll be talking is verified what

00:06:05,039 --> 00:06:09,120
I'll be talking about is a verified

00:06:06,360 --> 00:06:11,550
compiler and they are slowly getting

00:06:09,120 --> 00:06:12,990
more and more advanced but and I will

00:06:11,550 --> 00:06:16,289
mention by verified compilers are

00:06:12,990 --> 00:06:19,770
actually important and this is can be

00:06:16,289 --> 00:06:21,840
described here sort of so this is the

00:06:19,770 --> 00:06:24,090
actual system a KML that I will be

00:06:21,840 --> 00:06:26,400
talking about so to the left you have

00:06:24,090 --> 00:06:28,260
and this is called a front-end so this

00:06:26,400 --> 00:06:31,139
is not a web front-end but it's a

00:06:28,260 --> 00:06:33,599
compiler front-end so on the left you

00:06:31,139 --> 00:06:35,219
have a kml program which in the end has

00:06:33,599 --> 00:06:37,740
to be translated into a web assembly

00:06:35,219 --> 00:06:39,450
module and this is a compiler

00:06:37,740 --> 00:06:43,400
implemented in higher order

00:06:39,450 --> 00:06:45,990
this is the system the KML compiler and

00:06:43,400 --> 00:06:47,640
so it really doesn't matter which

00:06:45,990 --> 00:06:50,910
language is here or which language is

00:06:47,640 --> 00:06:52,800
here if you have a formal language on

00:06:50,910 --> 00:06:55,790
the left side like your input language

00:06:52,800 --> 00:06:58,830
and you prove some very nice properties

00:06:55,790 --> 00:07:00,750
about your program for example that it

00:06:58,830 --> 00:07:03,660
fulfills a certain specification and

00:07:00,750 --> 00:07:05,340
you're like yeah happy everything works

00:07:03,660 --> 00:07:08,490
I have a formal proof that everything is

00:07:05,340 --> 00:07:10,230
correct but then somehow you have to run

00:07:08,490 --> 00:07:11,940
it and usually when you want to run a

00:07:10,230 --> 00:07:15,540
program oftentimes you have to compile

00:07:11,940 --> 00:07:17,820
it yes what about your proofs that you

00:07:15,540 --> 00:07:19,410
just did I mean this is not the same

00:07:17,820 --> 00:07:21,810
program right you're you're putting it

00:07:19,410 --> 00:07:24,600
through this compiler so what actually

00:07:21,810 --> 00:07:26,280
happens I mean if the compiler itself

00:07:24,600 --> 00:07:28,920
which does this translation is not

00:07:26,280 --> 00:07:31,290
verified then what are your proofs worth

00:07:28,920 --> 00:07:33,270
they are worth nothing so you actually

00:07:31,290 --> 00:07:35,040
have to look into verified compilers too

00:07:33,270 --> 00:07:37,350
and they are a crucial part of

00:07:35,040 --> 00:07:39,660
bootstrapping this whole ecosystem so if

00:07:37,350 --> 00:07:43,410
you don't have a verified compiler you

00:07:39,660 --> 00:07:45,150
cannot ever really be serious about

00:07:43,410 --> 00:07:49,890
running your program that you have

00:07:45,150 --> 00:07:51,420
verified properties about are there any

00:07:49,890 --> 00:07:55,230
questions about this graph you should

00:07:51,420 --> 00:07:57,210
you should you should get this before we

00:07:55,230 --> 00:07:59,460
go on so we haven't we have a compiler

00:07:57,210 --> 00:08:01,920
that's set up like this and it runs in

00:07:59,460 --> 00:08:05,400
SML and through a theorem prover called

00:08:01,920 --> 00:08:07,890
hole okay so I assume that that's fine

00:08:05,400 --> 00:08:11,610
and we'll just now introduce webassembly

00:08:07,890 --> 00:08:14,070
briefly for most of you my guess is that

00:08:11,610 --> 00:08:16,380
you have heard about web assembly by

00:08:14,070 --> 00:08:18,840
compiling to it so you were just using

00:08:16,380 --> 00:08:20,940
another language like rust or C++ M

00:08:18,840 --> 00:08:22,530
script and you name it compile the web

00:08:20,940 --> 00:08:24,840
assembly but you didn't really think

00:08:22,530 --> 00:08:27,030
about the details of web assembly or the

00:08:24,840 --> 00:08:29,100
syntax of web assembly for example but I

00:08:27,030 --> 00:08:30,840
actually had to do that so I want to

00:08:29,100 --> 00:08:32,160
share the knowledge about what happens

00:08:30,840 --> 00:08:34,710
when you read the web assembly course

00:08:32,160 --> 00:08:37,740
back and think about it but let's start

00:08:34,710 --> 00:08:39,960
easy this is what you should be familiar

00:08:37,740 --> 00:08:43,350
with so the yellow part is your

00:08:39,960 --> 00:08:46,260
JavaScript and the violet part in there

00:08:43,350 --> 00:08:47,970
is your embedded web assembly and what

00:08:46,260 --> 00:08:50,310
web assembly is commonly used for is

00:08:47,970 --> 00:08:52,200
that okay you have some modules in there

00:08:50,310 --> 00:08:54,150
you have host functions that can

00:08:52,200 --> 00:08:57,180
indicate to the outside world this is

00:08:54,150 --> 00:08:59,220
JavaScript and then you can through this

00:08:57,180 --> 00:09:01,650
there are some host bindings or some

00:08:59,220 --> 00:09:04,080
some certain bindings to pass data back

00:09:01,650 --> 00:09:07,230
and forth but in the end you have this

00:09:04,080 --> 00:09:09,750
nice sandbox inside your JavaScript that

00:09:07,230 --> 00:09:12,840
can talk to the outside world by design

00:09:09,750 --> 00:09:15,270
this outside box cannot just be

00:09:12,840 --> 00:09:17,100
JavaScript it can basically be any any

00:09:15,270 --> 00:09:18,900
runtime and there are multiple other

00:09:17,100 --> 00:09:21,120
runtimes out there but of course

00:09:18,900 --> 00:09:26,460
browsers and JavaScript are by far the

00:09:21,120 --> 00:09:29,480
most common ones yeah if you have any

00:09:26,460 --> 00:09:32,520
questions feel very free to interrupt me

00:09:29,480 --> 00:09:34,560
otherwise I'll just continue so web

00:09:32,520 --> 00:09:39,600
assembly is a portable code format first

00:09:34,560 --> 00:09:40,470
of all so it's not just binaries or some

00:09:39,600 --> 00:09:42,510
eisah

00:09:40,470 --> 00:09:44,460
I mean it's an ice ax - but it aims to

00:09:42,510 --> 00:09:47,040
be this kind of portable code format

00:09:44,460 --> 00:09:50,460
like we have seen this for Java bytecode

00:09:47,040 --> 00:09:53,310
for example or LLVM intermediate code

00:09:50,460 --> 00:09:56,610
and so on sandbox by design as I said

00:09:53,310 --> 00:09:58,920
it's openly developed and that's an

00:09:56,610 --> 00:10:01,110
effort it is actually supported by major

00:09:58,920 --> 00:10:03,270
browser vendors in order to be supported

00:10:01,110 --> 00:10:05,850
by major browser vendors people had to

00:10:03,270 --> 00:10:08,670
actually you know get rid of pinnacle

00:10:05,850 --> 00:10:10,890
and s MJS but it all worked out and now

00:10:08,670 --> 00:10:13,470
we have web assembly and it's quite fast

00:10:10,890 --> 00:10:15,930
now that's because web assembly is quite

00:10:13,470 --> 00:10:19,800
low level and cheating it to actual

00:10:15,930 --> 00:10:21,720
machine code is really easy and one goal

00:10:19,800 --> 00:10:24,300
is to open up the browser for other

00:10:21,720 --> 00:10:28,730
languages those of you who have compiled

00:10:24,300 --> 00:10:31,440
from C++ or rust already know that so

00:10:28,730 --> 00:10:34,530
taking this from the from a presentation

00:10:31,440 --> 00:10:38,010
of the actual spec author you can see

00:10:34,530 --> 00:10:39,540
that it's not so there are some there

00:10:38,010 --> 00:10:41,070
are some differences to other code it

00:10:39,540 --> 00:10:44,190
runs in the browser so we can compare

00:10:41,070 --> 00:10:46,260
this to JavaScript for example one thing

00:10:44,190 --> 00:10:49,080
that I like to highlight is that it's

00:10:46,260 --> 00:10:51,210
streamable what does that mean

00:10:49,080 --> 00:10:53,310
it's streamable in the sense that you

00:10:51,210 --> 00:10:55,380
can actually start kind of parsing and

00:10:53,310 --> 00:10:57,540
verifying the web assembly module as you

00:10:55,380 --> 00:11:00,150
read it in through the network so you

00:10:57,540 --> 00:11:02,190
don't have to with as with JavaScript

00:11:00,150 --> 00:11:04,030
you have to read a complete file parse

00:11:02,190 --> 00:11:06,250
the file and

00:11:04,030 --> 00:11:08,740
then so only if you have the complete

00:11:06,250 --> 00:11:11,560
file you can parse it and that actually

00:11:08,740 --> 00:11:13,360
kind of takes some time when you load a

00:11:11,560 --> 00:11:15,040
website that's something you don't have

00:11:13,360 --> 00:11:17,110
with webassembly it was designed to be

00:11:15,040 --> 00:11:19,480
kind of streamed into breh into the

00:11:17,110 --> 00:11:22,120
browser while verifying it and as soon

00:11:19,480 --> 00:11:24,760
as it's there and verified you can you

00:11:22,120 --> 00:11:29,080
can just run it so it's faster to to

00:11:24,760 --> 00:11:31,690
load and then for me as a kind of theory

00:11:29,080 --> 00:11:33,070
person it's very cool that the semantics

00:11:31,690 --> 00:11:35,590
of webassembly aim to be very

00:11:33,070 --> 00:11:37,780
deterministic so in in the actual

00:11:35,590 --> 00:11:40,480
specification there are no cases where

00:11:37,780 --> 00:11:42,220
where it's like ah this might happen or

00:11:40,480 --> 00:11:43,840
that might happen or maybe something

00:11:42,220 --> 00:11:45,700
else might happen so the the spec is

00:11:43,840 --> 00:11:47,920
very deterministic and that that is a

00:11:45,700 --> 00:11:49,870
nice property for proving stuff about it

00:11:47,920 --> 00:11:52,630
because you don't have so many different

00:11:49,870 --> 00:11:53,680
cases in your proofs and it should be

00:11:52,630 --> 00:11:55,650
easy to reason about

00:11:53,680 --> 00:11:58,420
yeah the type system is quite simple and

00:11:55,650 --> 00:12:00,370
I guess hardware independence is quite

00:11:58,420 --> 00:12:04,300
obvious but yeah that's that's the

00:12:00,370 --> 00:12:07,150
picture so how does it look on the Left

00:12:04,300 --> 00:12:10,180
you have a program in an S expression

00:12:07,150 --> 00:12:12,460
syntax if you have ever seen Lisp this

00:12:10,180 --> 00:12:14,230
is kind of like Lisp if you have never

00:12:12,460 --> 00:12:18,550
seen Lisp please look at this

00:12:14,230 --> 00:12:21,280
and so so this is really kind of just

00:12:18,550 --> 00:12:23,260
this the abstract syntax as a tree and

00:12:21,280 --> 00:12:26,080
you can just read this in as a tree and

00:12:23,260 --> 00:12:27,700
on on the bottom you have the same

00:12:26,080 --> 00:12:30,100
program in a different syntax so

00:12:27,700 --> 00:12:32,020
webassembly actually defines an abstract

00:12:30,100 --> 00:12:34,960
syntax and then it defines multiple

00:12:32,020 --> 00:12:37,420
concrete syntaxes that directly map one

00:12:34,960 --> 00:12:38,830
to one to the abstract syntax so you

00:12:37,420 --> 00:12:41,760
have the same program in two different

00:12:38,830 --> 00:12:45,130
syntaxes they are on the abstract syntax

00:12:41,760 --> 00:12:46,840
indistinguishable yeah and then of

00:12:45,130 --> 00:12:51,580
course you can also use the postfix

00:12:46,840 --> 00:12:54,400
notation which is just that the postfix

00:12:51,580 --> 00:12:55,840
traversal of so these are two different

00:12:54,400 --> 00:12:57,850
programs right so the left one is

00:12:55,840 --> 00:12:59,710
something that computes addition of two

00:12:57,850 --> 00:13:01,840
numbers and the right one is something

00:12:59,710 --> 00:13:04,090
that confused computes the factorial of

00:13:01,840 --> 00:13:08,560
two numbers or the factorial of one

00:13:04,090 --> 00:13:10,510
number sorry and the the right one is

00:13:08,560 --> 00:13:12,640
just the the postfix notation which

00:13:10,510 --> 00:13:14,200
gives you this streaming property so if

00:13:12,640 --> 00:13:17,230
you look at the left one you actually

00:13:14,200 --> 00:13:19,690
have to somehow reshuffle in or

00:13:17,230 --> 00:13:21,730
to get a streamed a streamable program

00:13:19,690 --> 00:13:25,690
the right one is streamed or it

00:13:21,730 --> 00:13:27,490
streamable and they are both this valid

00:13:25,690 --> 00:13:31,290
in in the same way so this is their

00:13:27,490 --> 00:13:33,700
probe valid webassembly programs okay so

00:13:31,290 --> 00:13:37,540
the abstract syntax what do we have we

00:13:33,700 --> 00:13:41,530
have numerix so basic constants numbers

00:13:37,540 --> 00:13:43,420
unary binary operations then you have

00:13:41,530 --> 00:13:45,640
variables so you have a local scope in

00:13:43,420 --> 00:13:48,220
the global scope the local scope is

00:13:45,640 --> 00:13:49,450
local to the function being executed in

00:13:48,220 --> 00:13:51,610
the global scope is of course global

00:13:49,450 --> 00:13:53,440
then you have some memory access and you

00:13:51,610 --> 00:13:57,340
have local control flow so you can have

00:13:53,440 --> 00:13:59,200
an if loop blocks and you can well call

00:13:57,340 --> 00:14:02,530
is not local but the others are local

00:13:59,200 --> 00:14:05,230
and a few others and yeah you can

00:14:02,530 --> 00:14:07,960
declare function tables to do indirect

00:14:05,230 --> 00:14:10,210
dispatching of functions and you can

00:14:07,960 --> 00:14:13,120
export and import stuff it's fairly

00:14:10,210 --> 00:14:15,700
basic I'm more interested in the

00:14:13,120 --> 00:14:17,860
semantics because I have to prove stuff

00:14:15,700 --> 00:14:22,000
about these programs so there's a type

00:14:17,860 --> 00:14:24,160
system which is very simple and the

00:14:22,000 --> 00:14:27,130
cement the semantics of web assembly is

00:14:24,160 --> 00:14:28,810
actually given as a relational small

00:14:27,130 --> 00:14:32,410
step reduction what does that mean I

00:14:28,810 --> 00:14:34,060
will show you in a second and we can we

00:14:32,410 --> 00:14:35,980
can actually prove nice properties about

00:14:34,060 --> 00:14:37,690
these programs which is not the case

00:14:35,980 --> 00:14:39,760
with many other programming languages

00:14:37,690 --> 00:14:43,420
that are specified in natural language

00:14:39,760 --> 00:14:47,920
or yeah even even not really specified

00:14:43,420 --> 00:14:49,720
at all so you don't have to read this

00:14:47,920 --> 00:14:52,140
this is just to show you the the

00:14:49,720 --> 00:14:54,790
abstract syntax and this is this

00:14:52,140 --> 00:14:56,650
reduction rule so you don't have to look

00:14:54,790 --> 00:14:58,690
at the concrete thing what happens here

00:14:56,650 --> 00:15:01,120
but this is the semantics of the

00:14:58,690 --> 00:15:02,980
language and it's really simple it just

00:15:01,120 --> 00:15:04,840
tells you if you have an expression that

00:15:02,980 --> 00:15:07,000
looks like this thing on the left so

00:15:04,840 --> 00:15:09,220
it's kind of like pattern match you can

00:15:07,000 --> 00:15:12,250
just look at it and yeah it looks like

00:15:09,220 --> 00:15:14,080
that then you can actually there's a

00:15:12,250 --> 00:15:16,120
little arrow here it just tells you okay

00:15:14,080 --> 00:15:20,020
what comes out is the thing on the right

00:15:16,120 --> 00:15:21,880
and if you just apply these these arrow

00:15:20,020 --> 00:15:23,950
of this arrow relation which is called

00:15:21,880 --> 00:15:25,720
the small step semantics if you just

00:15:23,950 --> 00:15:28,000
apply that over and over and over again

00:15:25,720 --> 00:15:29,980
again then you just get the result of

00:15:28,000 --> 00:15:31,010
the program and this is really what's

00:15:29,980 --> 00:15:33,139
happening inside you

00:15:31,010 --> 00:15:34,880
had if you're thinking about okay this I

00:15:33,139 --> 00:15:37,250
don't know why you have an if here and

00:15:34,880 --> 00:15:39,320
then you have some two sub expressions

00:15:37,250 --> 00:15:41,360
and then you kind of evaluate if in your

00:15:39,320 --> 00:15:44,990
head then you will make the very same

00:15:41,360 --> 00:15:46,670
substitution in your own head but the

00:15:44,990 --> 00:15:48,800
difference is that this is formalized

00:15:46,670 --> 00:15:50,269
right so this is mathematical notation

00:15:48,800 --> 00:15:53,329
and it's clearly defined what it means

00:15:50,269 --> 00:15:57,019
so it's not in someone's head or in some

00:15:53,329 --> 00:15:58,279
spec editors words or something it's in

00:15:57,019 --> 00:16:02,149
formal language and that's very

00:15:58,279 --> 00:16:06,949
important then you have a type system on

00:16:02,149 --> 00:16:08,870
top which just tell you if something has

00:16:06,949 --> 00:16:11,420
it if some expression has a specific

00:16:08,870 --> 00:16:13,190
type and then you look at a sub

00:16:11,420 --> 00:16:16,579
expression then the sub expression must

00:16:13,190 --> 00:16:20,660
have another type and and by doing that

00:16:16,579 --> 00:16:22,370
you can actually yeah in a very similar

00:16:20,660 --> 00:16:24,260
way you can assemble the typing

00:16:22,370 --> 00:16:26,810
structure of your whole program these

00:16:24,260 --> 00:16:29,110
are more or less all the rules so you

00:16:26,810 --> 00:16:31,579
haven't you haven't seen them in detail

00:16:29,110 --> 00:16:33,560
but you have seen all of them and if you

00:16:31,579 --> 00:16:35,149
just look at them in detail then you

00:16:33,560 --> 00:16:37,010
will see okay it's actually not so

00:16:35,149 --> 00:16:40,029
complicated there's like I don't know 50

00:16:37,010 --> 00:16:42,740
of them and they are understandable and

00:16:40,029 --> 00:16:44,779
if you have understood them you've

00:16:42,740 --> 00:16:46,339
basically understood formal semantics of

00:16:44,779 --> 00:16:50,420
a programming language which is pretty

00:16:46,339 --> 00:16:51,889
awesome what this gives you is that you

00:16:50,420 --> 00:16:52,579
can now prove properties about

00:16:51,889 --> 00:16:55,639
webassembly

00:16:52,579 --> 00:17:01,069
so you can say for example that if some

00:16:55,639 --> 00:17:03,589
configurations or SMT so so this this

00:17:01,069 --> 00:17:05,870
turnstile here means that some

00:17:03,589 --> 00:17:09,650
configuration has a valid type key and

00:17:05,870 --> 00:17:11,660
then this arrow here is you know what

00:17:09,650 --> 00:17:14,720
happens when you execute it so you have

00:17:11,660 --> 00:17:16,520
something to the left gets executed and

00:17:14,720 --> 00:17:18,730
whatever comes out is the thing on the

00:17:16,520 --> 00:17:22,730
right okay so if you execute something

00:17:18,730 --> 00:17:24,020
then the result of the execution so s

00:17:22,730 --> 00:17:26,839
prime T prime this is the new

00:17:24,020 --> 00:17:29,030
configuration still has the same type

00:17:26,839 --> 00:17:31,010
that's I mean that's totally trivial if

00:17:29,030 --> 00:17:33,200
you have I don't know some expression

00:17:31,010 --> 00:17:34,940
you add two integers you expect that

00:17:33,200 --> 00:17:36,950
what comes out should be an integer

00:17:34,940 --> 00:17:39,799
right so this is more or less what we

00:17:36,950 --> 00:17:43,429
are saying here and there's another side

00:17:39,799 --> 00:17:44,230
condition on s s contains all the state

00:17:43,429 --> 00:17:46,029
of the program

00:17:44,230 --> 00:17:52,080
so it contains the memory it contains

00:17:46,029 --> 00:17:54,580
variables and so on and this this this

00:17:52,080 --> 00:17:56,889
partial order there just tells you okay

00:17:54,580 --> 00:18:00,340
everything is just behaving in a good

00:17:56,889 --> 00:18:03,159
way and if you look at the second

00:18:00,340 --> 00:18:06,070
theorem this is the progress theorem

00:18:03,159 --> 00:18:07,870
then this just means that either some

00:18:06,070 --> 00:18:10,809
configuration has reached end of the

00:18:07,870 --> 00:18:13,059
execution what does that mean and if

00:18:10,809 --> 00:18:15,010
execution means it's a value you cannot

00:18:13,059 --> 00:18:17,019
if you have a value like a number or a

00:18:15,010 --> 00:18:19,330
string there's nothing to execute

00:18:17,019 --> 00:18:21,070
anymore if you have an addition sure

00:18:19,330 --> 00:18:23,080
then you have to you have to do

00:18:21,070 --> 00:18:24,549
something you can execute but if you

00:18:23,080 --> 00:18:26,200
have reached a value then you're kind of

00:18:24,549 --> 00:18:28,539
at the end so this is what's called

00:18:26,200 --> 00:18:31,000
terminal of course there are cases like

00:18:28,539 --> 00:18:35,320
exceptions and traps but they are kind

00:18:31,000 --> 00:18:37,929
of straightforward to extend to and so

00:18:35,320 --> 00:18:41,049
this means that either it's terminal or

00:18:37,929 --> 00:18:42,940
you will actually find in this crazy

00:18:41,049 --> 00:18:44,649
table here you will actually find an

00:18:42,940 --> 00:18:47,080
arrow that you can apply so it tells you

00:18:44,649 --> 00:18:49,990
either you have stopped or there is an

00:18:47,080 --> 00:18:51,820
arrow that and an arrow that matches so

00:18:49,990 --> 00:18:54,070
that's nice because that means that a

00:18:51,820 --> 00:18:56,590
program is either done executing or it

00:18:54,070 --> 00:19:02,649
can execute further that's actually not

00:18:56,590 --> 00:19:04,059
trivial to prove and then took it no

00:19:02,649 --> 00:19:06,789
that doesn't mean there are no infinite

00:19:04,059 --> 00:19:09,010
loops because if you continually apply

00:19:06,789 --> 00:19:13,059
the reduction rule you might still be in

00:19:09,010 --> 00:19:15,130
an infinite loop and together we have

00:19:13,059 --> 00:19:18,220
soundness theorem so what it actually

00:19:15,130 --> 00:19:21,610
means is that there are only nice memory

00:19:18,220 --> 00:19:26,529
accesses and the program does what it's

00:19:21,610 --> 00:19:28,149
supposed to do and yeah so this is

00:19:26,529 --> 00:19:31,360
something that you cannot prove about

00:19:28,149 --> 00:19:34,090
many other programming languages so if

00:19:31,360 --> 00:19:36,720
you would just try to attempt to do this

00:19:34,090 --> 00:19:39,720
for typescript you would have no chance

00:19:36,720 --> 00:19:39,720
yes

00:19:43,840 --> 00:19:49,340
yeah but the other case is it diverges

00:19:46,429 --> 00:19:54,950
and diverges means the same as running

00:19:49,340 --> 00:19:56,419
infinitely yeah and yeah so this is

00:19:54,950 --> 00:20:00,049
something that you cannot do with every

00:19:56,419 --> 00:20:01,729
language so webassembly was my idea to

00:20:00,049 --> 00:20:03,499
compile to web assembly and to actually

00:20:01,729 --> 00:20:05,389
verify compilation to AB assembly is

00:20:03,499 --> 00:20:07,759
that it's so cool that it has a formal

00:20:05,389 --> 00:20:09,350
semantics because you don't just find so

00:20:07,759 --> 00:20:11,119
many programming languages that actually

00:20:09,350 --> 00:20:13,249
have a formal meaning to them they just

00:20:11,119 --> 00:20:14,929
well they kind of work and someone has

00:20:13,249 --> 00:20:17,330
written a compiler or an interpreter

00:20:14,929 --> 00:20:19,759
which works but there's no formal

00:20:17,330 --> 00:20:23,989
specification for many for many

00:20:19,759 --> 00:20:27,409
languages okay I will skip the part of

00:20:23,989 --> 00:20:29,299
maturity and adoption I kind of think

00:20:27,409 --> 00:20:31,190
that most of you know where web assembly

00:20:29,299 --> 00:20:33,559
is right now and what people are working

00:20:31,190 --> 00:20:37,070
on or using it for if you have any

00:20:33,559 --> 00:20:38,629
questions about that please ask but I

00:20:37,070 --> 00:20:40,999
would like to say what might be the

00:20:38,629 --> 00:20:43,549
future of web assembly so web assembly I

00:20:40,999 --> 00:20:45,320
was released as an MVP so it when it was

00:20:43,549 --> 00:20:48,049
released that the first version is very

00:20:45,320 --> 00:20:49,820
small and it just it can compute

00:20:48,049 --> 00:20:51,470
basically it has this type system that I

00:20:49,820 --> 00:20:54,139
showed and the reduction that I showed

00:20:51,470 --> 00:20:55,779
and the very clear semantics but there's

00:20:54,139 --> 00:20:58,279
other stuff that people want for example

00:20:55,779 --> 00:21:01,340
garbage collection would be nice because

00:20:58,279 --> 00:21:03,019
if you want to pass references to the

00:21:01,340 --> 00:21:04,729
JavaScript space then what about

00:21:03,019 --> 00:21:06,619
references I mean what's the lifetime of

00:21:04,729 --> 00:21:08,989
a reference that is that was passed to

00:21:06,619 --> 00:21:11,749
JavaScript who knows so you need a

00:21:08,989 --> 00:21:14,539
concept of of garbage collection there

00:21:11,749 --> 00:21:17,210
if you want to do that concurrency would

00:21:14,539 --> 00:21:19,190
be cool exception handling is also

00:21:17,210 --> 00:21:21,590
something that many people want and

00:21:19,190 --> 00:21:23,239
something that would be very dear to my

00:21:21,590 --> 00:21:26,509
heart is actually implementing tail

00:21:23,239 --> 00:21:28,729
calls because I'm the compiler I've

00:21:26,509 --> 00:21:30,739
written compiles from functional

00:21:28,729 --> 00:21:33,200
programming language and tail calls are

00:21:30,739 --> 00:21:36,739
actually necessary to not blow up the

00:21:33,200 --> 00:21:39,799
call stack and just yeah just region

00:21:36,739 --> 00:21:46,549
stacks Auto stack space exception more

00:21:39,799 --> 00:21:48,139
this mmm yeah and these will as a

00:21:46,549 --> 00:21:50,479
JavaScript developer this might not

00:21:48,139 --> 00:21:52,489
affect you directly but this will

00:21:50,479 --> 00:21:54,650
definitely affect the compilers that

00:21:52,489 --> 00:21:56,960
compile to web assembly

00:21:54,650 --> 00:21:59,090
and maybe it will make interfacing with

00:21:56,960 --> 00:22:01,640
members and be much nicer especially

00:21:59,090 --> 00:22:03,760
once garbage collection is in there it

00:22:01,640 --> 00:22:06,640
will get much cooler to interface with

00:22:03,760 --> 00:22:09,110
JavaScript because this is the the basic

00:22:06,640 --> 00:22:10,490
requirement for actually talking to the

00:22:09,110 --> 00:22:12,640
Dom or something like that out of

00:22:10,490 --> 00:22:16,730
webassembly

00:22:12,640 --> 00:22:19,910
okay first part so now I'm going to

00:22:16,730 --> 00:22:22,640
briefly introduce KML which comes from

00:22:19,910 --> 00:22:26,560
like a completely different angle but

00:22:22,640 --> 00:22:30,440
I'll try to make them fit together so

00:22:26,560 --> 00:22:33,890
KML is a functional programming language

00:22:30,440 --> 00:22:36,500
and it's it's part of a bigger project

00:22:33,890 --> 00:22:38,660
so it's about rigorous engineering of

00:22:36,500 --> 00:22:40,970
mainstream systems that's what our EMS

00:22:38,660 --> 00:22:43,460
stands for and you can see that this is

00:22:40,970 --> 00:22:46,010
structured in somehow in layers and

00:22:43,460 --> 00:22:48,710
people are thinking of okay how can we

00:22:46,010 --> 00:22:51,530
actually do very software verification

00:22:48,710 --> 00:22:53,930
in a like holistic perspective how can

00:22:51,530 --> 00:22:55,730
we take all the all the science that's

00:22:53,930 --> 00:22:57,590
going on and all the prototypes that

00:22:55,730 --> 00:23:00,650
have been done how can we integrate them

00:22:57,590 --> 00:23:06,140
to reach from verified hardware up to

00:23:00,650 --> 00:23:08,060
verified applications and KML is

00:23:06,140 --> 00:23:09,500
somewhere in the middle because in order

00:23:08,060 --> 00:23:13,340
to do that you need a programming

00:23:09,500 --> 00:23:15,620
language that is not assembler so you

00:23:13,340 --> 00:23:17,780
need a compiler in between and you need

00:23:15,620 --> 00:23:20,720
a you need a nice programming language

00:23:17,780 --> 00:23:24,830
to to work in so if any of you know

00:23:20,720 --> 00:23:27,680
standard ml or Oh camel or maybe Haskell

00:23:24,830 --> 00:23:29,540
this is this is the kind of area that

00:23:27,680 --> 00:23:34,070
we're moving in with cake ml it's a

00:23:29,540 --> 00:23:35,330
subset of standard ml and well this is

00:23:34,070 --> 00:23:38,480
something that could be used to

00:23:35,330 --> 00:23:40,070
implement in the end applications so

00:23:38,480 --> 00:23:42,170
there are actually some applications

00:23:40,070 --> 00:23:46,280
very very small ones but there are some

00:23:42,170 --> 00:23:48,620
application implementations in in KML

00:23:46,280 --> 00:23:50,990
but this is this is all being worked on

00:23:48,620 --> 00:23:53,090
and our EMS is not just some fancy

00:23:50,990 --> 00:23:57,500
startup it's a research project so this

00:23:53,090 --> 00:24:01,160
will take some time okay so what is it

00:23:57,500 --> 00:24:03,380
actually it's the first to my knowledge

00:24:01,160 --> 00:24:05,360
and to the knowledge of the program of

00:24:03,380 --> 00:24:06,890
the project team compiled a verified

00:24:05,360 --> 00:24:07,520
compiler of a functional programming

00:24:06,890 --> 00:24:10,040
language

00:24:07,520 --> 00:24:13,790
and it was kind of released you could

00:24:10,040 --> 00:24:15,679
say by publishing it in 2014 and it's

00:24:13,790 --> 00:24:20,000
quite a big team so there are 16 core

00:24:15,679 --> 00:24:23,000
contributors and 25 let's say related

00:24:20,000 --> 00:24:25,760
contributors the it's often said that

00:24:23,000 --> 00:24:29,630
the CA in cake comes from Cambridge and

00:24:25,760 --> 00:24:32,390
the ke comes from Kent but since then

00:24:29,630 --> 00:24:34,700
there's other people working on it so a

00:24:32,390 --> 00:24:37,280
University of farmers down there on the

00:24:34,700 --> 00:24:39,679
left and then data 61 which is where I

00:24:37,280 --> 00:24:42,440
have worked so this is a very global

00:24:39,679 --> 00:24:45,500
effort so on that slide we have the UK

00:24:42,440 --> 00:24:47,870
we have Sweden Australia and I guess if

00:24:45,500 --> 00:24:49,490
you want to join then it's no problem so

00:24:47,870 --> 00:24:51,740
it's it's kind of a globally distributed

00:24:49,490 --> 00:24:55,280
project and a very very fun to work with

00:24:51,740 --> 00:24:56,960
all these people mmm it's a substantial

00:24:55,280 --> 00:24:59,480
subset of standard ml that means it's

00:24:56,960 --> 00:25:01,309
basically standard ml reduced but you

00:24:59,480 --> 00:25:03,410
can still do interesting stuff with it

00:25:01,309 --> 00:25:06,770
so what's missing is modules and

00:25:03,410 --> 00:25:08,000
functors between modules but this is

00:25:06,770 --> 00:25:10,429
like the biggest restriction there are

00:25:08,000 --> 00:25:12,260
some other small restrictions but it has

00:25:10,429 --> 00:25:14,170
everything that you want that you would

00:25:12,260 --> 00:25:16,970
expect from a programming language and

00:25:14,170 --> 00:25:20,000
there are two front ends again compiler

00:25:16,970 --> 00:25:21,770
front ends so the first so this is the

00:25:20,000 --> 00:25:23,540
front end is concerned with the parser

00:25:21,770 --> 00:25:26,690
and how you get cold into the compiler

00:25:23,540 --> 00:25:29,030
right so the first way is that you

00:25:26,690 --> 00:25:32,330
actually translate from Hall which is a

00:25:29,030 --> 00:25:35,540
logic high order logic so this is just

00:25:32,330 --> 00:25:38,330
formulas and formal statements and you

00:25:35,540 --> 00:25:41,900
translate them into kml abstract syntax

00:25:38,330 --> 00:25:43,990
this translation is also verified and

00:25:41,900 --> 00:25:48,230
then you feed this into the compiler

00:25:43,990 --> 00:25:50,090
this is actually the way that kml can

00:25:48,230 --> 00:25:53,600
compile itself but that's a different

00:25:50,090 --> 00:25:56,210
story i guess and if you want to parse

00:25:53,600 --> 00:25:57,800
kml concrete syntax so just a file then

00:25:56,210 --> 00:25:59,750
this also works so these are the two

00:25:57,800 --> 00:26:02,510
front ends and then they're optimizing

00:25:59,750 --> 00:26:05,630
backends you can target x86 arm risk

00:26:02,510 --> 00:26:08,210
mips and the work I'm doing is to extend

00:26:05,630 --> 00:26:10,460
this optimizing pact and 4k for web

00:26:08,210 --> 00:26:13,850
assembly so this is how how they would

00:26:10,460 --> 00:26:15,380
fit and yeah it can bootstrap itself by

00:26:13,850 --> 00:26:17,870
front end one I already mentioned that

00:26:15,380 --> 00:26:20,750
and what's cool is it allows it has a

00:26:17,870 --> 00:26:22,280
header has an FF I so you can

00:26:20,750 --> 00:26:24,830
kind of say there are other functions

00:26:22,280 --> 00:26:28,730
outside of webassembly and that really

00:26:24,830 --> 00:26:31,520
nicely Maps to host functions so outside

00:26:28,730 --> 00:26:34,850
of cake FL and this really maps nicely

00:26:31,520 --> 00:26:38,390
to host functions in web assembly so

00:26:34,850 --> 00:26:41,590
that's it as a picture so this is the

00:26:38,390 --> 00:26:45,500
the standard way from an ASCII file to

00:26:41,590 --> 00:26:47,600
actually should be a utf-8 file you can

00:26:45,500 --> 00:26:49,760
you can somehow hook this up the full

00:26:47,600 --> 00:26:51,679
the full-blown chain here down to

00:26:49,760 --> 00:26:53,780
machine code or you can do the proof

00:26:51,679 --> 00:26:57,429
producing synthesis using whole

00:26:53,780 --> 00:26:59,690
functions to machine code or

00:26:57,429 --> 00:27:03,200
characteristic formulas but they are

00:26:59,690 --> 00:27:06,350
complicated and another another topic so

00:27:03,200 --> 00:27:08,900
how does the compiler look well it has

00:27:06,350 --> 00:27:11,030
some input and it has to generate some

00:27:08,900 --> 00:27:15,110
output and in between there's just many

00:27:11,030 --> 00:27:17,110
many many many layers the actual the

00:27:15,110 --> 00:27:19,309
actual boxes here are different

00:27:17,110 --> 00:27:20,960
intermediate languages so the first

00:27:19,309 --> 00:27:23,510
intermediate language is the source

00:27:20,960 --> 00:27:26,990
syntax it's KML and the last ones down

00:27:23,510 --> 00:27:30,020
here this is arm assembler x86 assembler

00:27:26,990 --> 00:27:31,309
and so on and in between you can just

00:27:30,020 --> 00:27:32,780
imagine that this is a very abstract

00:27:31,309 --> 00:27:35,780
language this like functional

00:27:32,780 --> 00:27:37,700
programming right so nothing near an

00:27:35,780 --> 00:27:39,950
assembler and down there you have to be

00:27:37,700 --> 00:27:41,539
at an assembler for it to make sense so

00:27:39,950 --> 00:27:44,720
what you're doing at every one of these

00:27:41,539 --> 00:27:47,299
arrows is you ever so slightly remove

00:27:44,720 --> 00:27:49,370
the you remove the abstractions so

00:27:47,299 --> 00:27:51,470
you're just craving through your program

00:27:49,370 --> 00:27:54,650
removing abstractions until you're

00:27:51,470 --> 00:27:57,710
actually down to machine code and a big

00:27:54,650 --> 00:28:00,380
part of my of my work was actually

00:27:57,710 --> 00:28:02,270
figuring this out like imagine you're

00:28:00,380 --> 00:28:04,370
joining a project like this and someone

00:28:02,270 --> 00:28:07,490
says yeah compile the web assembly

00:28:04,370 --> 00:28:09,289
please it's kind of crazy so you have to

00:28:07,490 --> 00:28:11,030
find you have to find the right part in

00:28:09,289 --> 00:28:14,120
the compiler where is actually the best

00:28:11,030 --> 00:28:17,320
the best spot to say ah and now let's go

00:28:14,120 --> 00:28:19,549
for web assembly so how did that work

00:28:17,320 --> 00:28:21,919
you look at the whole thing again and

00:28:19,549 --> 00:28:23,870
you look for an intermediate language

00:28:21,919 --> 00:28:27,049
inside the compiler that matches web

00:28:23,870 --> 00:28:28,820
assembly as closely as possible so web

00:28:27,049 --> 00:28:30,770
assembly operates on words which and

00:28:28,820 --> 00:28:32,680
immediately directs your attention to

00:28:30,770 --> 00:28:37,420
this part of the compiler

00:28:32,680 --> 00:28:40,060
because above you have so in the in the

00:28:37,420 --> 00:28:42,910
above let's say third in the first third

00:28:40,060 --> 00:28:45,220
you have abstract values and really no

00:28:42,910 --> 00:28:48,490
concept of a pointer or something and

00:28:45,220 --> 00:28:50,680
then on the on the middle on the middle

00:28:48,490 --> 00:28:53,260
third you have something like pointers

00:28:50,680 --> 00:28:55,330
and values and on the lower third there

00:28:53,260 --> 00:28:57,190
is no distinction anymore between a

00:28:55,330 --> 00:29:01,090
pointer and value so that's where we

00:28:57,190 --> 00:29:02,620
want to be so we focus in on that then

00:29:01,090 --> 00:29:04,720
you actually have to manage memory

00:29:02,620 --> 00:29:06,490
because we said garbage collection is

00:29:04,720 --> 00:29:07,870
this feature that they want to do in the

00:29:06,490 --> 00:29:11,260
future but it's not there yet

00:29:07,870 --> 00:29:13,660
so you have to do it yourself that's

00:29:11,260 --> 00:29:15,790
nice because we have here one phase that

00:29:13,660 --> 00:29:18,070
actually says implement GC primitives so

00:29:15,790 --> 00:29:21,940
before that there's a GC so something

00:29:18,070 --> 00:29:25,240
that relies on just tracking tracking

00:29:21,940 --> 00:29:29,380
references free memory allocating memory

00:29:25,240 --> 00:29:31,210
and so on and so in the compiler there

00:29:29,380 --> 00:29:33,640
is actually a GC implementation that

00:29:31,210 --> 00:29:37,300
somehow gets placed into the program so

00:29:33,640 --> 00:29:40,090
we want to be after that then there's

00:29:37,300 --> 00:29:42,460
local control flow so we want to be

00:29:40,090 --> 00:29:45,790
before the code gets flattened flattened

00:29:42,460 --> 00:29:47,980
means that all the local control flow

00:29:45,790 --> 00:29:50,770
like an if for a while or something that

00:29:47,980 --> 00:29:53,220
groups stuff together is more or less

00:29:50,770 --> 00:29:58,030
replaced with something like jumps and

00:29:53,220 --> 00:30:00,910
comparisons and jumps and so on and then

00:29:58,030 --> 00:30:02,590
in webassembly there are no so this is

00:30:00,910 --> 00:30:04,770
quite specific to the compiler there's

00:30:02,590 --> 00:30:08,260
one stage that actually ensures the

00:30:04,770 --> 00:30:09,630
register naming that the register naming

00:30:08,260 --> 00:30:12,160
corresponds to the actual architecture

00:30:09,630 --> 00:30:14,980
there is no such thing in webassembly so

00:30:12,160 --> 00:30:16,690
you can just skip it and the web

00:30:14,980 --> 00:30:18,960
assembly stack is implicit you cannot

00:30:16,690 --> 00:30:21,190
refer to something else in the stack

00:30:18,960 --> 00:30:23,230
maybe I should mention web assembly is

00:30:21,190 --> 00:30:25,390
formalized as a stack machine so there's

00:30:23,230 --> 00:30:27,460
the concept of a stack where you can add

00:30:25,390 --> 00:30:28,990
values and then you operate on the top

00:30:27,460 --> 00:30:32,110
of the stack and something something

00:30:28,990 --> 00:30:34,000
happens on top of the stack but you

00:30:32,110 --> 00:30:35,440
cannot address lower parts of the stack

00:30:34,000 --> 00:30:38,110
you cannot have an instruction on the

00:30:35,440 --> 00:30:40,540
top that says how what what is hundred

00:30:38,110 --> 00:30:44,040
100 slots down the stack you cannot do

00:30:40,540 --> 00:30:47,490
that so you have to be below this

00:30:44,040 --> 00:30:47,490
translation of the stack

00:30:47,910 --> 00:30:54,730
okay the challenges in there are

00:30:51,010 --> 00:30:57,070
actually the mismatches between this

00:30:54,730 --> 00:31:01,240
this language the chose here to left its

00:30:57,070 --> 00:31:03,309
stack lank and web assembly itself so

00:31:01,240 --> 00:31:05,350
there's no exception handling in web

00:31:03,309 --> 00:31:07,270
assembly and no tail recursive calls in

00:31:05,350 --> 00:31:10,360
web assembly and this make this stuff

00:31:07,270 --> 00:31:12,340
really hard because now you have two

00:31:10,360 --> 00:31:15,490
languages that actually don't really

00:31:12,340 --> 00:31:17,500
match up with each other and in order to

00:31:15,490 --> 00:31:19,240
prove anything significant about web

00:31:17,500 --> 00:31:22,150
assembly you also need a semantics that

00:31:19,240 --> 00:31:23,620
matches up with the semantics of stack

00:31:22,150 --> 00:31:25,690
length which is this intermediate

00:31:23,620 --> 00:31:30,280
language inside KML so I had to do that

00:31:25,690 --> 00:31:32,230
as well so how it looks like is the the

00:31:30,280 --> 00:31:33,730
top part is everything that's concerned

00:31:32,230 --> 00:31:35,200
with web assembly and the lower part is

00:31:33,730 --> 00:31:37,659
everything that's concerned with stack

00:31:35,200 --> 00:31:41,200
lank and in the end you have a program

00:31:37,659 --> 00:31:42,640
going in through your translation stack

00:31:41,200 --> 00:31:45,460
towards them and the program going out

00:31:42,640 --> 00:31:47,710
and in between you have so this is the

00:31:45,460 --> 00:31:49,750
implementation of the compiler and then

00:31:47,710 --> 00:31:52,179
you have a proof of correctness for your

00:31:49,750 --> 00:31:54,640
compiler which has to talk about the

00:31:52,179 --> 00:32:01,860
semantics of kml in the semantics of web

00:31:54,640 --> 00:32:07,480
assembly yeah so how do you verify this

00:32:01,860 --> 00:32:10,740
it's like a simulation proof so again

00:32:07,480 --> 00:32:13,059
what's orange is like corresponds to the

00:32:10,740 --> 00:32:15,870
front end of the compiler so this is

00:32:13,059 --> 00:32:18,730
stack length and what's blue compile

00:32:15,870 --> 00:32:22,179
corresponds to web assembly so what you

00:32:18,730 --> 00:32:24,280
have is this this magic kind of

00:32:22,179 --> 00:32:26,679
commuting diagram not really a commuting

00:32:24,280 --> 00:32:28,840
diagram I know but something similar and

00:32:26,679 --> 00:32:30,940
you basically have to show that if you

00:32:28,840 --> 00:32:33,789
have a program one which you compiled to

00:32:30,940 --> 00:32:36,450
program two and you execute or evaluate

00:32:33,789 --> 00:32:40,120
those two programs so you evaluate them

00:32:36,450 --> 00:32:44,380
then still there is some kind of

00:32:40,120 --> 00:32:49,690
similarity between the result so R means

00:32:44,380 --> 00:32:52,929
result s means state and this similarity

00:32:49,690 --> 00:32:55,059
is preserved so if it if s 1 and s 2 the

00:32:52,929 --> 00:32:57,580
initial states are similar and then you

00:32:55,059 --> 00:32:59,080
execute your programs then the resulting

00:32:57,580 --> 00:33:01,510
states are also similar if you

00:32:59,080 --> 00:33:03,549
achieve that then you have what you

00:33:01,510 --> 00:33:06,250
would call a correctness proof for the

00:33:03,549 --> 00:33:10,590
translation and the schematic of the

00:33:06,250 --> 00:33:12,700
proof is like this so you have like your

00:33:10,590 --> 00:33:14,950
Universal quantification so you can

00:33:12,700 --> 00:33:18,039
prove this for every program and for

00:33:14,950 --> 00:33:19,630
every state so it's an inductive proof

00:33:18,039 --> 00:33:21,880
over the structure of the program and

00:33:19,630 --> 00:33:24,429
what you can actually then derive is

00:33:21,880 --> 00:33:28,630
that you will always find this lower

00:33:24,429 --> 00:33:30,399
part of the of this construction do you

00:33:28,630 --> 00:33:32,620
have any questions about that should I

00:33:30,399 --> 00:33:34,809
explain it in more detail I'm running

00:33:32,620 --> 00:33:42,820
out of time so if there's any question

00:33:34,809 --> 00:33:44,950
about that okay so the progress is that

00:33:42,820 --> 00:33:46,779
the static and dynamic semantics of

00:33:44,950 --> 00:33:49,480
webassembly have been mechanized so this

00:33:46,779 --> 00:33:51,820
means I sat down and I wrote a formal

00:33:49,480 --> 00:33:53,860
version of the web assembly spec in high

00:33:51,820 --> 00:33:57,639
order logic that's not something you get

00:33:53,860 --> 00:34:00,159
for free and the initialization

00:33:57,639 --> 00:34:02,200
semantics of web assembly are mostly

00:34:00,159 --> 00:34:05,320
formalized so this is what happens when

00:34:02,200 --> 00:34:08,820
you actually instantiate a module and I

00:34:05,320 --> 00:34:12,669
also have this alternative version of

00:34:08,820 --> 00:34:14,589
semantics in a big step style because

00:34:12,669 --> 00:34:17,830
the semantics given in the spec are

00:34:14,589 --> 00:34:21,040
small step and the translation is

00:34:17,830 --> 00:34:22,810
prototyped and it was actually also

00:34:21,040 --> 00:34:26,440
quite tricky to integrate all of this in

00:34:22,810 --> 00:34:28,629
the existing compiler and yeah the proof

00:34:26,440 --> 00:34:30,790
is not actually done yet there are many

00:34:28,629 --> 00:34:33,220
many lemmas that I proved but like this

00:34:30,790 --> 00:34:35,740
full picture here is just a conjecture

00:34:33,220 --> 00:34:37,659
right now and it will of course work out

00:34:35,740 --> 00:34:42,820
but it's actually tough to prove this

00:34:37,659 --> 00:34:45,010
even if it might look simple and yeah so

00:34:42,820 --> 00:34:47,020
what is to be done

00:34:45,010 --> 00:34:49,919
proving compiler correctness which is

00:34:47,020 --> 00:34:52,149
just this picture that I showed and

00:34:49,919 --> 00:34:54,790
actually also proving that everything

00:34:52,149 --> 00:34:57,310
that the compiler produces will be valid

00:34:54,790 --> 00:34:59,920
web assembly which is yeah right now

00:34:57,310 --> 00:35:04,530
it's like an assumption but probably I

00:34:59,920 --> 00:35:07,030
can discharge that okay so quick recap

00:35:04,530 --> 00:35:09,700
if you have any questions please ask

00:35:07,030 --> 00:35:12,280
you're also very welcome to mail to me

00:35:09,700 --> 00:35:12,960
if you need any information about this

00:35:12,280 --> 00:35:14,880
project

00:35:12,960 --> 00:35:17,080
how to contribute or anything I'm very

00:35:14,880 --> 00:35:20,900
happy to help you thanks

00:35:17,080 --> 00:35:20,900

YouTube URL: https://www.youtube.com/watch?v=qRkxbWRJQyc


