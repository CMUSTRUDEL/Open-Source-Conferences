Title: ViennaJS, Async await in JS, November 2018
Publication date: 2018-11-29
Playlist: viennaJS
Description: 
	Talk by Ondrej Zara:

Selected by community request â€“ This talk will explain how ES2017 async/await works with respect to older approaches and non-blocking code. We will see how this integrates into legacy codebases, what problems need to be dealt with and how to transpile the stuff for older browsers.
Captions: 
	00:00:00,030 --> 00:00:05,339
my name is Dante and I came here all the

00:00:03,120 --> 00:00:08,700
way from the Czech Republic it's not

00:00:05,339 --> 00:00:11,550
that for I were there for a company

00:00:08,700 --> 00:00:12,929
called says Nam we look pretty much

00:00:11,550 --> 00:00:15,089
everything online

00:00:12,929 --> 00:00:17,880
we're like a local smaller copy of

00:00:15,089 --> 00:00:20,400
Google we do we do sort of search maps

00:00:17,880 --> 00:00:23,130
emails domains news and so and so on

00:00:20,400 --> 00:00:27,000
I work as a front-end developer there

00:00:23,130 --> 00:00:29,250
and I also regularly give lectures on

00:00:27,000 --> 00:00:32,640
web development topics on the Czech

00:00:29,250 --> 00:00:36,390
Technical University in in track so

00:00:32,640 --> 00:00:39,270
that's my trade and let's have a brief

00:00:36,390 --> 00:00:41,219
look at what I'll be talking about of

00:00:39,270 --> 00:00:45,059
course the main topic is async/await in

00:00:41,219 --> 00:00:47,190
JavaScript but first we'll have to have

00:00:45,059 --> 00:00:50,489
a look at the JavaScript history to gain

00:00:47,190 --> 00:00:53,219
some to gain some context so that will

00:00:50,489 --> 00:00:56,719
hopefully answer the question why we

00:00:53,219 --> 00:01:00,000
need or want such feature in JavaScript

00:00:56,719 --> 00:01:02,760
then I will explain how the async/await

00:01:00,000 --> 00:01:05,400
stuff really works and that will

00:01:02,760 --> 00:01:06,240
hopefully answer the question what is

00:01:05,400 --> 00:01:08,850
async/await

00:01:06,240 --> 00:01:12,270
and finally I will briefly talk about

00:01:08,850 --> 00:01:14,280
translation the complex process of

00:01:12,270 --> 00:01:16,619
providing the functionality to older

00:01:14,280 --> 00:01:19,229
implementations so that will hopefully

00:01:16,619 --> 00:01:22,860
answer the question how can we deliver

00:01:19,229 --> 00:01:26,250
this this feature even to to your

00:01:22,860 --> 00:01:29,280
grandparents PC which uses Microsoft

00:01:26,250 --> 00:01:34,200
Windows XP with the Internet Explorer 7

00:01:29,280 --> 00:01:39,600
or or so my main goal here was to start

00:01:34,200 --> 00:01:43,360
with with a joke but turns out that the

00:01:39,600 --> 00:01:45,920
async/await tech is not really funny

00:01:43,360 --> 00:01:48,320
fortunately I managed to find a

00:01:45,920 --> 00:01:53,330
hilarious joke online which I'm

00:01:48,320 --> 00:01:56,150
presenting now without comments but I

00:01:53,330 --> 00:01:59,330
will explain that just a little bit yeah

00:01:56,150 --> 00:02:02,180
it's a sink and a weight yeah it's not

00:01:59,330 --> 00:02:05,119
the best joke but probably the only one

00:02:02,180 --> 00:02:08,000
that that really works so let's just

00:02:05,119 --> 00:02:10,009
jump into the history section where we

00:02:08,000 --> 00:02:12,650
learn about JavaScript how all the

00:02:10,009 --> 00:02:15,459
language is and how it evolved with

00:02:12,650 --> 00:02:17,270
respect to asynchronous processing

00:02:15,459 --> 00:02:20,290
because we will really need to

00:02:17,270 --> 00:02:25,630
understand that before we do a single

00:02:20,290 --> 00:02:29,420
8.now javascript was created in 1995 and

00:02:25,630 --> 00:02:31,940
for the first like thirteen or ten

00:02:29,420 --> 00:02:35,750
twelve years the language was not

00:02:31,940 --> 00:02:38,540
developed almost at all if you wanted to

00:02:35,750 --> 00:02:42,830
do something something some operation

00:02:38,540 --> 00:02:45,590
that would be blocking you had to use a

00:02:42,830 --> 00:02:47,630
non-blocking api and the reason for that

00:02:45,590 --> 00:02:50,330
is because javascript was designed to

00:02:47,630 --> 00:02:53,390
run in the very same thread that the

00:02:50,330 --> 00:02:55,700
browser uses to render stuff so if you

00:02:53,390 --> 00:02:58,030
were to to really block the execution

00:02:55,700 --> 00:03:00,140
you will block the rendering as well

00:02:58,030 --> 00:03:03,610
effectively making the page

00:03:00,140 --> 00:03:07,880
unresponsive so that was the decision

00:03:03,610 --> 00:03:09,709
that was the reason for those calls that

00:03:07,880 --> 00:03:12,760
would take some time some non-trivial

00:03:09,709 --> 00:03:15,709
amount of time to make them run blocking

00:03:12,760 --> 00:03:17,840
fortunately when javascript was young

00:03:15,709 --> 00:03:20,420
there were not many asynchronous calls

00:03:17,840 --> 00:03:23,810
we had like said timeout it's at

00:03:20,420 --> 00:03:26,260
interval xhr and that's it that's

00:03:23,810 --> 00:03:32,690
everything that was doable in JavaScript

00:03:26,260 --> 00:03:36,380
until 2008 what happened in 2008 were

00:03:32,690 --> 00:03:39,709
2009 nodejs came out so the whole

00:03:36,380 --> 00:03:41,780
community like brainstormed and run to

00:03:39,709 --> 00:03:44,540
no js' so they can create something new

00:03:41,780 --> 00:03:47,690
because no J's was completely new there

00:03:44,540 --> 00:03:50,840
was no standard library and everyone

00:03:47,690 --> 00:03:53,450
wanted to contribute so they wanted to

00:03:50,840 --> 00:03:55,730
port their favorite API to port their

00:03:53,450 --> 00:03:56,870
favorite library but nobody really knew

00:03:55,730 --> 00:03:58,849
how to do the

00:03:56,870 --> 00:04:00,890
because asynchronous JavaScript on the

00:03:58,849 --> 00:04:04,550
server that was something pretty pretty

00:04:00,890 --> 00:04:07,489
raw pretty new so the easiest way to

00:04:04,550 --> 00:04:09,470
handle this was just like mirror what we

00:04:07,489 --> 00:04:12,349
already have in JavaScript on the client

00:04:09,470 --> 00:04:15,200
side we have this is a timeout function

00:04:12,349 --> 00:04:18,019
that takes a callback so okay we can do

00:04:15,200 --> 00:04:21,290
that as well and this is how most of the

00:04:18,019 --> 00:04:24,800
nodejs api is were created like the FS

00:04:21,290 --> 00:04:27,639
module the net HTTP and the holds also

00:04:24,800 --> 00:04:30,380
for client-side API geolocation

00:04:27,639 --> 00:04:32,120
navigator just get user media and so on

00:04:30,380 --> 00:04:35,479
and so on these are API that are

00:04:32,120 --> 00:04:41,330
strictly modeled after the the old

00:04:35,479 --> 00:04:45,160
callback based asynchronous flow what

00:04:41,330 --> 00:04:48,950
happened is what we what we typically

00:04:45,160 --> 00:04:50,539
label as the callback hell because when

00:04:48,950 --> 00:04:53,419
you compose a lot of asynchronous

00:04:50,539 --> 00:04:55,639
function together you will have to

00:04:53,419 --> 00:04:58,580
juggle their callbacks and also their

00:04:55,639 --> 00:05:01,100
air bags which are callbacks reserved

00:04:58,580 --> 00:05:03,860
for error handling and this might get

00:05:01,100 --> 00:05:06,289
messy real fast and we probably know

00:05:03,860 --> 00:05:15,919
that very well so I'm not going to dig

00:05:06,289 --> 00:05:18,320
into this deeply so people writing a lot

00:05:15,919 --> 00:05:20,300
of JavaScript code said that they need

00:05:18,320 --> 00:05:22,130
something else to handle the

00:05:20,300 --> 00:05:28,030
asynchronicity because callbacks aren't

00:05:22,130 --> 00:05:31,190
no longer maintainable in 2015 the es

00:05:28,030 --> 00:05:34,099
es6 version of the ACMA script standard

00:05:31,190 --> 00:05:37,160
came out and it introduced the concept

00:05:34,099 --> 00:05:39,620
of promises to cure this

00:05:37,160 --> 00:05:42,440
and these promises are a way to

00:05:39,620 --> 00:05:45,470
formalize how callbacks are supposed to

00:05:42,440 --> 00:05:48,260
work there's nothing new in years 2015

00:05:45,470 --> 00:05:49,970
and now the interesting fact about

00:05:48,260 --> 00:05:52,280
premises is that there are completely

00:05:49,970 --> 00:05:54,440
poly failable which means that there are

00:05:52,280 --> 00:05:58,010
not something new in the language itself

00:05:54,440 --> 00:06:01,250
there are just the design pattern they

00:05:58,010 --> 00:06:04,099
allow us to reason about callbacks in a

00:06:01,250 --> 00:06:07,729
way that's more comprehensible more

00:06:04,099 --> 00:06:09,870
composable they formalize how callbacks

00:06:07,729 --> 00:06:12,780
work how their signatures are

00:06:09,870 --> 00:06:15,050
find and they allow us to separate the

00:06:12,780 --> 00:06:20,580
the implementation of a function

00:06:15,050 --> 00:06:23,220
separated from the flow of the code of

00:06:20,580 --> 00:06:27,270
the returned values and also propagation

00:06:23,220 --> 00:06:31,230
of possible exceptions or rejections so

00:06:27,270 --> 00:06:33,210
there is this like recommendation that

00:06:31,230 --> 00:06:35,010
when you turn your code from a

00:06:33,210 --> 00:06:37,170
synchronous version to promise based

00:06:35,010 --> 00:06:39,510
version instead of returning a value R

00:06:37,170 --> 00:06:42,450
if you resolve a promise and instead of

00:06:39,510 --> 00:06:44,700
throwing an exception you rigid the

00:06:42,450 --> 00:06:47,400
promise

00:06:44,700 --> 00:06:50,340
this promises these promises were pretty

00:06:47,400 --> 00:06:54,030
popular back then so we see quite a lot

00:06:50,340 --> 00:06:57,840
of this new I mean like new promise beta

00:06:54,030 --> 00:07:01,920
ap ice fetch web crypto service workers

00:06:57,840 --> 00:07:05,520
and also in no js' the the object FS

00:07:01,920 --> 00:07:10,320
that promises which is available from

00:07:05,520 --> 00:07:11,880
from the January 2018 so this one is new

00:07:10,320 --> 00:07:16,410
fetch is not that new

00:07:11,880 --> 00:07:20,010
I suppose that everyone in this in this

00:07:16,410 --> 00:07:23,430
room is familiar with promises I mean

00:07:20,010 --> 00:07:26,640
creating premises is is a complex art

00:07:23,430 --> 00:07:28,530
and we're going to discuss that we are

00:07:26,640 --> 00:07:31,260
going to discuss how to consume a

00:07:28,530 --> 00:07:33,570
promise how to deal with the promise

00:07:31,260 --> 00:07:37,610
that was returned by some call so in

00:07:33,570 --> 00:07:40,920
this example this is readable or not

00:07:37,610 --> 00:07:43,020
yeah I can really I cannot do anything

00:07:40,920 --> 00:07:45,840
with that so it's not really about sorry

00:07:43,020 --> 00:07:47,520
I have a function called get data and I

00:07:45,840 --> 00:07:48,900
have no nipple implemented that function

00:07:47,520 --> 00:07:51,540
it's a library call or something

00:07:48,900 --> 00:07:54,210
it returns a promise so in order to

00:07:51,540 --> 00:07:56,670
process the value I have to use to use

00:07:54,210 --> 00:07:58,650
the den method the signature method of a

00:07:56,670 --> 00:08:00,830
promise and unfortunately all my

00:07:58,650 --> 00:08:03,690
callbacks the process data rendering

00:08:00,830 --> 00:08:05,700
functions are asynchronous as well so

00:08:03,690 --> 00:08:07,770
they also return promises fortunately

00:08:05,700 --> 00:08:09,600
the whole concept of promises is based

00:08:07,770 --> 00:08:11,460
on the idea that we'll be chaining

00:08:09,600 --> 00:08:13,590
multiple calls which are returning

00:08:11,460 --> 00:08:16,230
promises together so this works and it's

00:08:13,590 --> 00:08:19,820
readable and if you see the call the

00:08:16,230 --> 00:08:23,810
code you probably easy easy easily under

00:08:19,820 --> 00:08:25,730
and what it does the problem is that not

00:08:23,810 --> 00:08:28,190
everyone uses the functional style

00:08:25,730 --> 00:08:30,410
perhaps you opted to using the

00:08:28,190 --> 00:08:33,200
object-oriented programming using the

00:08:30,410 --> 00:08:34,790
disk keyword in JavaScript or you want

00:08:33,200 --> 00:08:37,640
to pass additional arguments to your

00:08:34,790 --> 00:08:40,850
functions and training premises in this

00:08:37,640 --> 00:08:42,830
fashion is not that readable I even had

00:08:40,850 --> 00:08:47,120
to use these error functions to make

00:08:42,830 --> 00:08:48,830
this stuff more more nice but if I was

00:08:47,120 --> 00:08:51,800
not to use error functions I would have

00:08:48,830 --> 00:08:54,710
to use the explicit bind call to

00:08:51,800 --> 00:08:58,400
maintain the context this this gets

00:08:54,710 --> 00:09:02,570
hairy we are not looking at a combat

00:08:58,400 --> 00:09:05,300
hell but long chains of promises are not

00:09:02,570 --> 00:09:09,490
that readable as well so this is the

00:09:05,300 --> 00:09:13,190
reason why a sink to weight came to es

00:09:09,490 --> 00:09:16,220
2017 and they are here as a third

00:09:13,190 --> 00:09:17,420
approach to to non blocking stuff and

00:09:16,220 --> 00:09:18,530
we're not talking something

00:09:17,420 --> 00:09:21,530
revolutionary

00:09:18,530 --> 00:09:24,020
it's it's mostly just an evolution the

00:09:21,530 --> 00:09:26,900
next step first we had call back then we

00:09:24,020 --> 00:09:29,150
had promises and then we build a top of

00:09:26,900 --> 00:09:31,790
these promises the stuff with a single

00:09:29,150 --> 00:09:34,850
weight and turns out that these keywords

00:09:31,790 --> 00:09:38,540
are just a simple syntax sugar for

00:09:34,850 --> 00:09:40,640
promise consummation so you still need

00:09:38,540 --> 00:09:45,020
to use and you still need to understand

00:09:40,640 --> 00:09:47,540
promises to do async await but when you

00:09:45,020 --> 00:09:49,010
decide to use async await the code will

00:09:47,540 --> 00:09:52,310
be more readable and with it will

00:09:49,010 --> 00:09:54,590
resemble the synchronous flow I have a

00:09:52,310 --> 00:09:57,110
list of browser and server

00:09:54,590 --> 00:10:00,650
implementations that support a single

00:09:57,110 --> 00:10:02,840
weight out of the box will obviously

00:10:00,650 --> 00:10:05,750
also talk about transpiration for older

00:10:02,840 --> 00:10:12,020
versions so we start with the keyword

00:10:05,750 --> 00:10:14,750
async I have an example here with my

00:10:12,020 --> 00:10:16,430
function good data perhaps the

00:10:14,750 --> 00:10:18,650
implementation is pretty simple it just

00:10:16,430 --> 00:10:22,190
fetches the data from network using the

00:10:18,650 --> 00:10:25,130
fetch function and caches the data so I

00:10:22,190 --> 00:10:28,700
might ask for a data that was retrieved

00:10:25,130 --> 00:10:31,340
before and then I will just return the

00:10:28,700 --> 00:10:32,990
cached version which makes my function a

00:10:31,340 --> 00:10:35,990
conditionally asynchronous

00:10:32,990 --> 00:10:42,589
function which sucks because the return

00:10:35,990 --> 00:10:45,680
value return value is now based on the

00:10:42,589 --> 00:10:47,930
implementation so as a consumer of this

00:10:45,680 --> 00:10:51,170
function I can either receive a promise

00:10:47,930 --> 00:10:54,080
or not and the keyword acing helps here

00:10:51,170 --> 00:10:56,779
because it guarantees that the function

00:10:54,080 --> 00:10:59,660
will always return a promise even if the

00:10:56,779 --> 00:11:03,800
return call returns a regular value so

00:10:59,660 --> 00:11:06,410
the row number 3 in my code will return

00:11:03,800 --> 00:11:10,430
a promise that's already fulfilled with

00:11:06,410 --> 00:11:12,290
the value of the cash index by type so

00:11:10,430 --> 00:11:14,300
we have a guarantee the function

00:11:12,290 --> 00:11:16,730
prefixed by async will always return a

00:11:14,300 --> 00:11:19,430
promise which is nice but it's still

00:11:16,730 --> 00:11:22,640
like half of the work and the second

00:11:19,430 --> 00:11:25,010
half is the keyword weight and we put a

00:11:22,640 --> 00:11:29,570
weight keyword before calling a function

00:11:25,010 --> 00:11:32,029
that returns a promise and this

00:11:29,570 --> 00:11:35,240
synthetic element will interrupt the

00:11:32,029 --> 00:11:38,089
execution of the function until the

00:11:35,240 --> 00:11:39,920
promise which is returning which is

00:11:38,089 --> 00:11:43,520
being returned right next to a white

00:11:39,920 --> 00:11:46,820
gets resolved and we are not talking

00:11:43,520 --> 00:11:48,920
about pausing or blocking the execution

00:11:46,820 --> 00:11:51,950
we're still having an asynchronous

00:11:48,920 --> 00:11:54,620
function so my function do it will

00:11:51,950 --> 00:11:57,200
happily finish before the data is

00:11:54,620 --> 00:11:59,570
fetched but it will return a promise and

00:11:57,200 --> 00:12:03,740
the promise will slowly get fulfilled as

00:11:59,570 --> 00:12:07,310
the fetch will fulfill itself so some

00:12:03,740 --> 00:12:10,790
basic observations about this first the

00:12:07,310 --> 00:12:13,730
rule number one you can use the await

00:12:10,790 --> 00:12:16,750
keywords only inside a function that is

00:12:13,730 --> 00:12:21,890
a sink itself which makes perfect sense

00:12:16,750 --> 00:12:23,600
because by using the white keyword you

00:12:21,890 --> 00:12:26,990
state that this function will be

00:12:23,600 --> 00:12:30,079
asynchronous so the async prefix makes

00:12:26,990 --> 00:12:32,329
this publicly available information the

00:12:30,079 --> 00:12:34,190
weight keyword will throw an exception a

00:12:32,329 --> 00:12:38,480
regular exception that might be catched

00:12:34,190 --> 00:12:42,680
by a trackage block should the promise

00:12:38,480 --> 00:12:44,120
write to a white be rejected the

00:12:42,680 --> 00:12:45,890
expression after a way it might be

00:12:44,120 --> 00:12:46,610
synchronous so there is no need to

00:12:45,890 --> 00:12:50,300
return

00:12:46,610 --> 00:12:52,160
when you do await and these two key

00:12:50,300 --> 00:12:54,529
words a single wait don't help with

00:12:52,160 --> 00:12:56,630
creating promises so if you have to

00:12:54,529 --> 00:12:58,640
create a promise yourself there is no

00:12:56,630 --> 00:13:01,760
help for you you will have to use the

00:12:58,640 --> 00:13:06,110
the magic which which is defined when

00:13:01,760 --> 00:13:10,070
using the new promise constructor so

00:13:06,110 --> 00:13:13,100
we're now invent inverting the guidance

00:13:10,070 --> 00:13:16,459
about resolving returning rejecting and

00:13:13,100 --> 00:13:19,310
catching so this function now looks

00:13:16,459 --> 00:13:22,040
pretty synchronous even though it's

00:13:19,310 --> 00:13:24,470
realized on an amazing API the core

00:13:22,040 --> 00:13:27,470
inside function the gate data call is

00:13:24,470 --> 00:13:29,959
asynchronous it returns a promise but

00:13:27,470 --> 00:13:35,450
fortunately I can prefix it with the

00:13:29,959 --> 00:13:38,329
white and also I can wrap the whole call

00:13:35,450 --> 00:13:40,550
inside the try catch block so it still

00:13:38,329 --> 00:13:43,279
looks pretty synchronous also the

00:13:40,550 --> 00:13:46,100
process data which is a Singh works like

00:13:43,279 --> 00:13:49,070
this renderer digger also because this

00:13:46,100 --> 00:13:51,529
function do it is a sink itself so I'm

00:13:49,070 --> 00:13:54,170
free to return a promise and whatever

00:13:51,529 --> 00:13:57,820
whoever calls this my function do it

00:13:54,170 --> 00:14:02,269
will receive a promise from me from me

00:13:57,820 --> 00:14:06,050
turns out that you're able to turn a

00:14:02,269 --> 00:14:08,360
callback based function into a promise

00:14:06,050 --> 00:14:11,839
based function which can then be used

00:14:08,360 --> 00:14:14,149
with a wait keyword the process is

00:14:11,839 --> 00:14:15,949
called promise if occasion and I don't

00:14:14,149 --> 00:14:20,660
think that's a real word in English

00:14:15,949 --> 00:14:23,000
vocabulary but it's used widely how does

00:14:20,660 --> 00:14:25,430
the promise if occasionally clike so

00:14:23,000 --> 00:14:27,320
this is a theoretical implementation of

00:14:25,430 --> 00:14:29,149
a promise if occassion function that

00:14:27,320 --> 00:14:31,760
returns a function that returns a new

00:14:29,149 --> 00:14:34,790
promise and I'm not going to talk about

00:14:31,760 --> 00:14:38,120
this in much detail but you can check

00:14:34,790 --> 00:14:42,199
the code yourself in fact this approach

00:14:38,120 --> 00:14:45,890
is quite a bit popular because it made

00:14:42,199 --> 00:14:48,170
it into node.js version 8 there is a

00:14:45,890 --> 00:14:51,290
building module called require util dot

00:14:48,170 --> 00:14:53,000
promise if I and the implementation of

00:14:51,290 --> 00:14:56,060
the promise if I function is basically

00:14:53,000 --> 00:14:57,920
this one on the previous slide with some

00:14:56,060 --> 00:14:59,840
more bells and whistles like caching and

00:14:57,920 --> 00:15:03,290
so on but the core remains the same

00:14:59,840 --> 00:15:06,850
so you can take your regular all-world

00:15:03,290 --> 00:15:09,500
callback based API such as FS dot unlink

00:15:06,850 --> 00:15:13,670
which is used to remove files from your

00:15:09,500 --> 00:15:16,160
hard drive and wrap it so that it

00:15:13,670 --> 00:15:18,800
returns a promise and then you can use

00:15:16,160 --> 00:15:21,560
the premise as you would using then but

00:15:18,800 --> 00:15:25,370
of course you can use the promise using

00:15:21,560 --> 00:15:27,529
await so if you are using callbacks you

00:15:25,370 --> 00:15:29,630
are not that far from using async await

00:15:27,529 --> 00:15:31,430
but you first need to convert your

00:15:29,630 --> 00:15:34,900
callback based API since the promise

00:15:31,430 --> 00:15:38,810
based API there are some there are some

00:15:34,900 --> 00:15:41,930
caveat some issues you might run into

00:15:38,810 --> 00:15:44,779
them if you don't do this carefully so

00:15:41,930 --> 00:15:48,589
the first the first caveat is

00:15:44,779 --> 00:15:50,960
performance related say we want to say

00:15:48,589 --> 00:15:53,300
we want to use the fetch API and if you

00:15:50,960 --> 00:15:55,700
ever used fetch you know that it works

00:15:53,300 --> 00:15:58,250
in two phases first you fetch data and

00:15:55,700 --> 00:16:00,290
it gives you just the few bytes of the

00:15:58,250 --> 00:16:02,900
response and then you have to fetch the

00:16:00,290 --> 00:16:05,390
response so we have we have a chain of

00:16:02,900 --> 00:16:08,630
two promises here the first one returned

00:16:05,390 --> 00:16:12,080
by fetch and the second one returned by

00:16:08,630 --> 00:16:16,220
the by the JSON method and we can either

00:16:12,080 --> 00:16:19,600
await the JSON and written the resulting

00:16:16,220 --> 00:16:22,700
data that would be line number four or

00:16:19,600 --> 00:16:25,339
we can remove one promise from this

00:16:22,700 --> 00:16:28,430
chain by returning the promise returned

00:16:25,339 --> 00:16:30,500
by responder Jason that's row number

00:16:28,430 --> 00:16:33,290
three in the second example and the

00:16:30,500 --> 00:16:35,690
second example is faster because every

00:16:33,290 --> 00:16:38,650
single promise you use makes the

00:16:35,690 --> 00:16:41,780
execution a little bit slower why

00:16:38,650 --> 00:16:44,870
because the callbacks passed to them

00:16:41,780 --> 00:16:47,810
when using a promise are executed on the

00:16:44,870 --> 00:16:50,240
next iteration of the event loop so

00:16:47,810 --> 00:16:53,780
every promise you use delays the

00:16:50,240 --> 00:16:57,500
execution of your code for by like one

00:16:53,780 --> 00:16:59,150
or two or four milliseconds so we just

00:16:57,500 --> 00:17:01,760
want to reduce the number of promises

00:16:59,150 --> 00:17:05,060
that are being chained caveat number two

00:17:01,760 --> 00:17:07,910
parallel execution say you want to fetch

00:17:05,060 --> 00:17:09,679
three data sources you have three URLs

00:17:07,910 --> 00:17:12,020
you have three calls that you have to

00:17:09,679 --> 00:17:13,630
make to get all the data that you want

00:17:12,020 --> 00:17:15,940
to render

00:17:13,630 --> 00:17:18,220
you might be tempted to fetch the first

00:17:15,940 --> 00:17:19,990
one and fetch the second one and fetch

00:17:18,220 --> 00:17:22,480
the third one and you have a white a

00:17:19,990 --> 00:17:25,180
white await so you have all of your data

00:17:22,480 --> 00:17:28,300
together and now this works but it

00:17:25,180 --> 00:17:31,510
effectively makes all these three HTTP

00:17:28,300 --> 00:17:33,700
requests serial you will be able to do

00:17:31,510 --> 00:17:37,570
the second one only after the first one

00:17:33,700 --> 00:17:39,030
is done often you want to combine them

00:17:37,570 --> 00:17:41,850
and make them in parallel and

00:17:39,030 --> 00:17:44,710
async/await is not going to help you the

00:17:41,850 --> 00:17:47,220
only way to make these calls in parallel

00:17:44,710 --> 00:17:50,080
is to combine them using promises at all

00:17:47,220 --> 00:17:52,990
that's also the reason why you need to

00:17:50,080 --> 00:17:58,510
understand and use promises even when

00:17:52,990 --> 00:18:00,540
you opt to async and white the final

00:17:58,510 --> 00:18:04,480
program I talked about transpiling this

00:18:00,540 --> 00:18:07,330
so this is a theoretical translation we

00:18:04,480 --> 00:18:11,080
have an async function with a trackage

00:18:07,330 --> 00:18:13,720
block and and a white key word and we're

00:18:11,080 --> 00:18:16,060
imagining how the code might be

00:18:13,720 --> 00:18:18,040
transpiled to older JavaScript

00:18:16,060 --> 00:18:21,280
implementations that do not understand

00:18:18,040 --> 00:18:24,760
these key words so probably we want to

00:18:21,280 --> 00:18:29,500
wrap the code that follows after a

00:18:24,760 --> 00:18:32,530
weight into a promise so we can so we

00:18:29,500 --> 00:18:36,580
can just wait with the execution unless

00:18:32,530 --> 00:18:38,950
unless the fetch returns so the

00:18:36,580 --> 00:18:41,350
translation process shall be a rather

00:18:38,950 --> 00:18:43,450
straightforward we can easily take the

00:18:41,350 --> 00:18:46,930
async await code and wrap it into a

00:18:43,450 --> 00:18:48,460
regular set of promises and you might

00:18:46,930 --> 00:18:50,080
think that you will just use babel for

00:18:48,460 --> 00:18:53,080
that you will download the appropriate

00:18:50,080 --> 00:18:56,110
plugin or use the configuration and so

00:18:53,080 --> 00:18:58,450
on and so on many people are happy doing

00:18:56,110 --> 00:19:00,460
that they just download babel they apply

00:18:58,450 --> 00:19:04,060
the Bible to their code they test that

00:19:00,460 --> 00:19:07,420
it works in IE and they release this

00:19:04,060 --> 00:19:08,470
stuff and go home have you ever looked

00:19:07,420 --> 00:19:13,990
at the cloud

00:19:08,470 --> 00:19:17,560
produced by babel yeah that's sometimes

00:19:13,990 --> 00:19:19,870
a good idea because I think oh wait is

00:19:17,560 --> 00:19:23,250
promised in a really crappy promised

00:19:19,870 --> 00:19:25,870
it's transpired in a really crappy way I

00:19:23,250 --> 00:19:28,800
would like to say that the

00:19:25,870 --> 00:19:32,170
a sink away translation Babel just sucks

00:19:28,800 --> 00:19:34,320
because this is Inco it calls our

00:19:32,170 --> 00:19:39,280
transpiled two generators which are

00:19:34,320 --> 00:19:41,530
function with asterisks and because not

00:19:39,280 --> 00:19:43,540
every JavaScript implementation supports

00:19:41,530 --> 00:19:46,900
generators the Bible has to transpire

00:19:43,540 --> 00:19:49,570
the generators as well so there are

00:19:46,900 --> 00:19:52,360
further transpose to a complex state

00:19:49,570 --> 00:19:54,550
machine for a regenerator which is a

00:19:52,360 --> 00:19:57,040
really large implementation of the

00:19:54,550 --> 00:19:58,929
generators in JavaScript and this is all

00:19:57,040 --> 00:20:02,650
unreasonably complicated and unreadable

00:19:58,929 --> 00:20:05,500
so I cannot recommend using Babel itself

00:20:02,650 --> 00:20:07,890
for translation of async/await instead

00:20:05,500 --> 00:20:11,020
there is this little plugin

00:20:07,890 --> 00:20:14,650
unfortunately I'm not its author I found

00:20:11,020 --> 00:20:16,720
it online it's called fast async this is

00:20:14,650 --> 00:20:20,350
this is a link so you can easily find it

00:20:16,720 --> 00:20:21,910
online it's a plug-in for Babel that

00:20:20,350 --> 00:20:23,800
converts async a way to promise you

00:20:21,910 --> 00:20:27,100
directly without using generators or

00:20:23,800 --> 00:20:28,660
regenerator you just have to supply the

00:20:27,100 --> 00:20:31,360
promise implementation which can be

00:20:28,660 --> 00:20:34,179
polyfilled by default this plug-in cost

00:20:31,360 --> 00:20:37,150
fast async code fast async uses its own

00:20:34,179 --> 00:20:38,980
promise polyfill implementation which is

00:20:37,150 --> 00:20:44,350
called Zeus oh no and I have really no

00:20:38,980 --> 00:20:47,050
idea why but you can specify your own

00:20:44,350 --> 00:20:50,110
polyfill or perhaps your target browsers

00:20:47,050 --> 00:20:53,290
that are able to do promises natively so

00:20:50,110 --> 00:20:55,929
in your babel configuration file which

00:20:53,290 --> 00:20:58,480
is called the Babel or see when you

00:20:55,929 --> 00:21:00,340
define your plugins you add that fast

00:20:58,480 --> 00:21:02,980
async plug-in that's recommended to you

00:21:00,340 --> 00:21:06,340
by me and you also configure the plug-in

00:21:02,980 --> 00:21:09,730
itself by passing it this compiler

00:21:06,340 --> 00:21:12,490
dictionary with the runtime option

00:21:09,730 --> 00:21:15,010
turned on and that will remove the

00:21:12,490 --> 00:21:17,740
built-ins Oh sound promise polyfill and

00:21:15,010 --> 00:21:20,320
you're free to either at your own

00:21:17,740 --> 00:21:22,900
profile or at no powerful if you do not

00:21:20,320 --> 00:21:24,880
mean that and this makes the

00:21:22,900 --> 00:21:29,850
transporation really painful painless

00:21:24,880 --> 00:21:33,850
and fast and readable yeah that's it so

00:21:29,850 --> 00:21:35,480
if you have any questions after now or

00:21:33,850 --> 00:21:39,349
no

00:21:35,480 --> 00:21:39,349

YouTube URL: https://www.youtube.com/watch?v=vkUP8YzBAS8


