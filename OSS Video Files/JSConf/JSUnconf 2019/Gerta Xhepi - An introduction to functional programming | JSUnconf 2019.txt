Title: Gerta Xhepi - An introduction to functional programming | JSUnconf 2019
Publication date: 2019-05-23
Playlist: JSUnconf 2019
Description: 
	
Captions: 
	00:00:06,770 --> 00:00:13,139
hi my name is Geeta and I work as a

00:00:10,830 --> 00:00:16,410
software engineer for the design system

00:00:13,139 --> 00:00:19,680
team at sync for the one who don't know

00:00:16,410 --> 00:00:23,460
think it's a platform for professional

00:00:19,680 --> 00:00:27,359
networking and today I will be talking

00:00:23,460 --> 00:00:29,279
about functional programming so first of

00:00:27,359 --> 00:00:31,949
all I would like to share with you why I

00:00:29,279 --> 00:00:34,320
decided to learn functional programming

00:00:31,949 --> 00:00:37,410
I have studied computer science where I

00:00:34,320 --> 00:00:39,210
learned Java and a little bit JavaScript

00:00:37,410 --> 00:00:42,059
and objective oriented programming

00:00:39,210 --> 00:00:44,100
paradigm and it was fine back then but

00:00:42,059 --> 00:00:47,340
when I started to work in real

00:00:44,100 --> 00:00:50,700
application that solve business problems

00:00:47,340 --> 00:00:53,789
I barely see the same techniques I

00:00:50,700 --> 00:00:56,610
learned back at university also I don't

00:00:53,789 --> 00:01:01,100
know for you guys but for me debugging

00:00:56,610 --> 00:01:04,949
code in JavaScript it's very hard so

00:01:01,100 --> 00:01:07,049
today we live in a world where if you

00:01:04,949 --> 00:01:10,229
want to learn new skills it's very easy

00:01:07,049 --> 00:01:12,689
you don't need to wait for universities

00:01:10,229 --> 00:01:13,619
and all those long processes you just

00:01:12,689 --> 00:01:15,900
start right away

00:01:13,619 --> 00:01:18,770
pick your computer and then start

00:01:15,900 --> 00:01:21,540
reading about what you want to learn and

00:01:18,770 --> 00:01:24,750
here I would like to point out something

00:01:21,540 --> 00:01:27,299
that this way of learning it is cool but

00:01:24,750 --> 00:01:29,610
has a side effect in it sometimes I

00:01:27,299 --> 00:01:33,090
believe developers are very creative

00:01:29,610 --> 00:01:35,670
human being but sometimes they create

00:01:33,090 --> 00:01:39,590
some stereotypes like half PHP it's a

00:01:35,670 --> 00:01:43,110
lazy language and JavaScript has heart

00:01:39,590 --> 00:01:45,570
magic and those stereotypes are fine for

00:01:43,110 --> 00:01:49,320
people who are very experienced but for

00:01:45,570 --> 00:01:51,659
me as a junior who just started to code

00:01:49,320 --> 00:01:55,350
it is very hard to understand what do

00:01:51,659 --> 00:01:59,159
they mean and all those why I can find

00:01:55,350 --> 00:02:00,810
an answer so that's was the reason that

00:01:59,159 --> 00:02:03,780
I started to learn functional

00:02:00,810 --> 00:02:07,619
programming because I thought it is cool

00:02:03,780 --> 00:02:10,040
and first I started with to answer the

00:02:07,619 --> 00:02:14,050
question what is functional program

00:02:10,040 --> 00:02:16,610
actually I find it very hard to give a

00:02:14,050 --> 00:02:18,680
definition like what is functional

00:02:16,610 --> 00:02:21,830
programming the one I read on the

00:02:18,680 --> 00:02:25,160
internet it's kind of boring and hard to

00:02:21,830 --> 00:02:28,190
memorize so I decided to tell you first

00:02:25,160 --> 00:02:31,190
the characteristics and let's see if I

00:02:28,190 --> 00:02:33,520
will manage to give you a summarize what

00:02:31,190 --> 00:02:37,550
I understand functional programming is

00:02:33,520 --> 00:02:40,490
so functional programming it is a

00:02:37,550 --> 00:02:42,380
programming paradigm let me explain to

00:02:40,490 --> 00:02:45,500
you what I understand and I think of a

00:02:42,380 --> 00:02:48,110
paradigm for me a paradigm it is kind of

00:02:45,500 --> 00:02:50,780
a world view a way how we look at the

00:02:48,110 --> 00:02:53,810
world in terms of how the world is

00:02:50,780 --> 00:02:55,580
composed to like what elements and how

00:02:53,810 --> 00:02:57,680
does elements interact with each other

00:02:55,580 --> 00:02:59,210
so if we say what is functional

00:02:57,680 --> 00:03:02,120
programming I would say it's a code

00:02:59,210 --> 00:03:04,760
style like we look how those what

00:03:02,120 --> 00:03:06,920
elements it contains and Hamas and and

00:03:04,760 --> 00:03:10,760
them interact with each other so to

00:03:06,920 --> 00:03:13,420
explain this I will try to talk about

00:03:10,760 --> 00:03:16,550
other programming paradigms like

00:03:13,420 --> 00:03:18,980
imperative codes so an imperative code

00:03:16,550 --> 00:03:20,780
we write codes out of commands like

00:03:18,980 --> 00:03:23,300
because we instruct the code line by

00:03:20,780 --> 00:03:25,430
line like now do this and then do that

00:03:23,300 --> 00:03:29,690
and after that do that and after do that

00:03:25,430 --> 00:03:31,760
and as we see time here is an important

00:03:29,690 --> 00:03:34,340
concept in imperative programming and

00:03:31,760 --> 00:03:37,459
with that comes an idea of values

00:03:34,340 --> 00:03:41,270
changing over the time which is called

00:03:37,459 --> 00:03:45,020
state another characteristic of function

00:03:41,270 --> 00:03:47,209
of imperative programming it is that for

00:03:45,020 --> 00:03:50,330
the same input we don't always get the

00:03:47,209 --> 00:03:52,310
same output from the other side that

00:03:50,330 --> 00:03:54,500
this object oriented programming which

00:03:52,310 --> 00:03:57,290
says that imperative programming it's

00:03:54,500 --> 00:04:02,720
cool but what if our programs get

00:03:57,290 --> 00:04:04,700
complicated and the valve manage that

00:04:02,720 --> 00:04:07,760
state in those days are changing over

00:04:04,700 --> 00:04:10,910
the time it is very hard so what if we

00:04:07,760 --> 00:04:13,370
pack those data in some little units

00:04:10,910 --> 00:04:15,140
call them object and the way how they

00:04:13,370 --> 00:04:17,139
talk and interact or each other each

00:04:15,140 --> 00:04:19,629
byte is it is by standing mesh

00:04:17,139 --> 00:04:22,120
back and forth which is essentially what

00:04:19,629 --> 00:04:24,819
we do when we call the methods and

00:04:22,120 --> 00:04:27,819
objects one object method called the

00:04:24,819 --> 00:04:29,979
method of another object the opposite of

00:04:27,819 --> 00:04:32,469
imperative programming it is declarative

00:04:29,979 --> 00:04:35,080
programming if imperative programming

00:04:32,469 --> 00:04:37,389
was the program growth out of comments

00:04:35,080 --> 00:04:39,699
inverting declarative programming it is

00:04:37,389 --> 00:04:42,250
built out of expression so it's like

00:04:39,699 --> 00:04:45,330
that's what I want I don't care how you

00:04:42,250 --> 00:04:48,849
deliver it to me but that's what I want

00:04:45,330 --> 00:04:50,949
so what fight what is functional

00:04:48,849 --> 00:04:53,710
programming then so a functional

00:04:50,949 --> 00:04:55,840
programming it is a paradigm where we

00:04:53,710 --> 00:04:58,090
express everything with functions and

00:04:55,840 --> 00:05:00,599
the way how they lament interact with

00:04:58,090 --> 00:05:06,099
each other is by giving input and

00:05:00,599 --> 00:05:09,009
transferring them into an output and how

00:05:06,099 --> 00:05:11,919
we do that it is by using pure functions

00:05:09,009 --> 00:05:14,620
what is a pure function a pure function

00:05:11,919 --> 00:05:18,009
it is a function that for the same input

00:05:14,620 --> 00:05:21,870
gets always the same output without side

00:05:18,009 --> 00:05:24,219
effects let me explain this also

00:05:21,870 --> 00:05:26,830
functional programming I would say it's

00:05:24,219 --> 00:05:29,349
kind of a sub paradigm of declarative

00:05:26,830 --> 00:05:30,339
programming so I would explain this with

00:05:29,349 --> 00:05:33,279
an example

00:05:30,339 --> 00:05:35,710
let's say we have a function which takes

00:05:33,279 --> 00:05:38,139
as argument an array and you return a

00:05:35,710 --> 00:05:40,479
new function with the double values of

00:05:38,139 --> 00:05:42,490
the old array the code like looks like

00:05:40,479 --> 00:05:44,710
this in declarative style which is

00:05:42,490 --> 00:05:47,500
basically functional programming if we

00:05:44,710 --> 00:05:50,800
want to do the to solve the same problem

00:05:47,500 --> 00:05:53,199
in imperative code we have to do we have

00:05:50,800 --> 00:05:55,150
to declare function which is called Dabu

00:05:53,199 --> 00:05:57,430
age and then takes an array we have to

00:05:55,150 --> 00:05:59,919
initialize a new array and then with the

00:05:57,430 --> 00:06:02,919
help of a for loop we push the other

00:05:59,919 --> 00:06:06,669
values and as you see the code this line

00:06:02,919 --> 00:06:10,120
by line and also we use those old

00:06:06,669 --> 00:06:13,419
methods or methyls I you I learned in

00:06:10,120 --> 00:06:15,039
the data structure subject like four and

00:06:13,419 --> 00:06:17,139
four and this is the good thing about

00:06:15,039 --> 00:06:19,870
functional programming we will never

00:06:17,139 --> 00:06:24,300
have to write a for loop or a push I

00:06:19,870 --> 00:06:24,300
have never seen this at least and my job

00:06:24,810 --> 00:06:30,050
actually when I think of an application

00:06:28,160 --> 00:06:32,810
usually I have in mind like without

00:06:30,050 --> 00:06:35,090
considering the UI part I have in mind a

00:06:32,810 --> 00:06:37,760
list of data that we have to render in

00:06:35,090 --> 00:06:40,790
the screen and those data can be mutable

00:06:37,760 --> 00:06:42,800
and immutable immutable data can change

00:06:40,790 --> 00:06:45,350
after the creation and immutable data

00:06:42,800 --> 00:06:49,310
cannot change after the creation let me

00:06:45,350 --> 00:06:53,300
explain this let's say we have an object

00:06:49,310 --> 00:06:56,150
called a and it has a property fo and

00:06:53,300 --> 00:06:59,360
which has a value bar and then we assign

00:06:56,150 --> 00:07:02,890
the we have a new variable a which we

00:06:59,360 --> 00:07:06,320
assign it to B and then once we want to

00:07:02,890 --> 00:07:10,460
portion your value to the V and if we

00:07:06,320 --> 00:07:12,710
console.log V we will see that a and V

00:07:10,460 --> 00:07:14,990
are equal because we are not doing

00:07:12,710 --> 00:07:20,300
anything else we assign those objects to

00:07:14,990 --> 00:07:26,240
H they assigned to the same place so how

00:07:20,300 --> 00:07:29,030
can we avoid those kind of mutations and

00:07:26,240 --> 00:07:32,870
the way how I know how to do this is by

00:07:29,030 --> 00:07:35,300
object freezing a frozen object is an

00:07:32,870 --> 00:07:37,910
object that can no longer be changed

00:07:35,300 --> 00:07:40,520
after creation which means we cannot

00:07:37,910 --> 00:07:44,180
longer add new values to it but we can

00:07:40,520 --> 00:07:48,080
no longer extract values from it also we

00:07:44,180 --> 00:07:50,900
can do this with programmer discipline

00:07:48,080 --> 00:07:54,050
so we use functions like the map

00:07:50,900 --> 00:07:56,060
function or like a sine function like we

00:07:54,050 --> 00:07:57,890
find the object to a new one and then we

00:07:56,060 --> 00:08:01,340
added the new one but not the old one

00:07:57,890 --> 00:08:03,770
and also there is Concord and filter but

00:08:01,340 --> 00:08:05,240
we never have to use those old methods

00:08:03,770 --> 00:08:09,710
we learned in the data structure like

00:08:05,240 --> 00:08:11,480
Porsche and top and other things one of

00:08:09,710 --> 00:08:13,700
the nice features that I love about

00:08:11,480 --> 00:08:16,760
functional programming is high order

00:08:13,700 --> 00:08:19,430
function a high order function it is the

00:08:16,760 --> 00:08:23,770
function that accepts a function as an

00:08:19,430 --> 00:08:28,310
argument or returns a new function I

00:08:23,770 --> 00:08:30,560
think high order function at first seems

00:08:28,310 --> 00:08:32,780
a bit scary but it's not I think it's

00:08:30,560 --> 00:08:35,630
very helpful when our application it

00:08:32,780 --> 00:08:37,790
gets really complicated so and we repeat

00:08:35,630 --> 00:08:39,560
ourselves again and again

00:08:37,790 --> 00:08:41,870
so I think it could make sense to have

00:08:39,560 --> 00:08:44,090
something as a provider which fits the

00:08:41,870 --> 00:08:46,610
need of the components under the tree

00:08:44,090 --> 00:08:48,850
which are mostly the consumers let me

00:08:46,610 --> 00:08:52,160
show you this with an example

00:08:48,850 --> 00:08:55,130
let's say we have to build a counter for

00:08:52,160 --> 00:08:58,100
making some mathematical calculations

00:08:55,130 --> 00:08:59,780
and I have an high order function which

00:08:58,100 --> 00:09:04,070
takes argument

00:08:59,780 --> 00:09:06,920
another function we store a very odd

00:09:04,070 --> 00:09:07,970
variable calm and then with the help of

00:09:06,920 --> 00:09:13,400
the rest

00:09:07,970 --> 00:09:15,860
operator we create a new function which

00:09:13,400 --> 00:09:19,040
will return the result with the help of

00:09:15,860 --> 00:09:21,140
the spread operator and if we want to

00:09:19,040 --> 00:09:23,180
use now or if we want to make different

00:09:21,140 --> 00:09:24,830
calculation with this we just have to

00:09:23,180 --> 00:09:27,530
use this function by passing another

00:09:24,830 --> 00:09:29,840
function to it which in this case we

00:09:27,530 --> 00:09:33,590
have a function ad which has two

00:09:29,840 --> 00:09:37,810
arguments X and epsilon and then to add

00:09:33,590 --> 00:09:37,810
this function to the higher order wines

00:09:38,380 --> 00:09:45,440
one of the topics that I still don't

00:09:42,410 --> 00:09:49,480
feel comfortable talking with but I will

00:09:45,440 --> 00:09:52,880
try to it is caring and compositions

00:09:49,480 --> 00:09:55,400
sharing a caret function is the function

00:09:52,880 --> 00:09:58,670
that takes multiple arguments at one

00:09:55,400 --> 00:10:01,520
time as we have in this case we have a

00:09:58,670 --> 00:10:06,140
function called substrate or sub which

00:10:01,520 --> 00:10:09,140
first take a and create a new function

00:10:06,140 --> 00:10:12,830
out of it which takes B and then return

00:10:09,140 --> 00:10:15,200
a new function which substrat a minus B

00:10:12,830 --> 00:10:17,690
and to use this we just pass values to

00:10:15,200 --> 00:10:23,450
it so why is that helpful

00:10:17,690 --> 00:10:25,910
I think one of the topics known as the

00:10:23,450 --> 00:10:33,200
soul and the hearth of functional

00:10:25,910 --> 00:10:36,380
programming is compositions let's say we

00:10:33,200 --> 00:10:40,220
have two function like f which takes an

00:10:36,380 --> 00:10:42,170
argument and must've add 2 to it and

00:10:40,220 --> 00:10:45,080
then we have another function with this

00:10:42,170 --> 00:10:49,310
G which takes an argument and added a

00:10:45,080 --> 00:10:50,499
number 3 to compose those elements we

00:10:49,310 --> 00:10:54,819
just nest those

00:10:50,499 --> 00:10:59,619
together like we do it here we have the

00:10:54,819 --> 00:11:02,439
Campos funk function and then we pass to

00:10:59,619 --> 00:11:04,959
function to it and then we just mask the

00:11:02,439 --> 00:11:10,149
F to the G in this way how we see it

00:11:04,959 --> 00:11:12,969
here so why this carried a great so for

00:11:10,149 --> 00:11:16,269
me carat is the great functions for

00:11:12,969 --> 00:11:18,189
composing because they allow us to

00:11:16,269 --> 00:11:20,979
easily convert functions with multiple

00:11:18,189 --> 00:11:30,819
arguments in the stands of a single

00:11:20,979 --> 00:11:33,039
function so I wish to give you a summary

00:11:30,819 --> 00:11:37,929
why I think that functional programming

00:11:33,039 --> 00:11:40,329
for me it is very great one week because

00:11:37,929 --> 00:11:43,029
we can combine a lot of pure function

00:11:40,329 --> 00:11:46,629
with each other and all this work with

00:11:43,029 --> 00:11:48,969
function given in forget transforming

00:11:46,629 --> 00:11:53,649
them into an output it is very helpful

00:11:48,969 --> 00:11:56,199
for me also add avoiding shared state

00:11:53,649 --> 00:12:00,359
immutable data and all the side effects

00:11:56,199 --> 00:12:00,359
which help at least me a lot and

00:12:00,569 --> 00:12:06,419
declarative approach that rather than

00:12:02,919 --> 00:12:09,549
imperative approach I'm not a big fan of

00:12:06,419 --> 00:12:15,329
declarative very difficult so for me it

00:12:09,549 --> 00:12:15,329
is fine to use that one thank you

00:12:18,280 --> 00:12:22,460

YouTube URL: https://www.youtube.com/watch?v=1WISlEtW9LA


