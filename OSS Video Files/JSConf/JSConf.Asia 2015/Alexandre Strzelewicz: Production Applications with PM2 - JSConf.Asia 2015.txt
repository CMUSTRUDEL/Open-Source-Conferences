Title: Alexandre Strzelewicz: Production Applications with PM2 - JSConf.Asia 2015
Publication date: 2015-12-18
Playlist: JSConf.Asia 2015
Description: 
	Once your application is developed, switching it to live production is a painful experience. From process management, deployment, monitoring, bug tracking, orchestration... a lot of techniques and methodologies must be taken into account to provide a quality application. This is where PM2 comes into the game, providing a framework to harden your Node.js application and super charge your production workflow.

Alexandre is a full stack JavaScript developer, technologist and the author of PM2, a well known process manager for production Node.js applications. He is also CEO & co-founder of the startup keymetrics.io, a supervizion solution built on top of PM2.

JSConf.Asia - Red Dot Design Museum, Singapore - 19 November 2015.

Source: http://2015.jsconf.asia
Slides: https://speakerdeck.com/unitech/pm2-presentation-at-jsconf-dot-asia

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:01,080 --> 00:00:11,759
[Music]

00:00:08,030 --> 00:00:14,849
so yes and we speak about p.m. - I'm the

00:00:11,759 --> 00:00:18,359
first auto-off p.m. - so I will begin by

00:00:14,849 --> 00:00:20,220
a presentation about me so I'm a CEO and

00:00:18,359 --> 00:00:23,160
funder at key metrics the monitoring

00:00:20,220 --> 00:00:25,170
solution built on top of TM - I'm the

00:00:23,160 --> 00:00:27,330
first author of PM - that couldn't be

00:00:25,170 --> 00:00:29,369
like so big without all the contributors

00:00:27,330 --> 00:00:31,289
that made this project better and

00:00:29,369 --> 00:00:35,430
full-stack JavaScript developer and I'm

00:00:31,289 --> 00:00:37,559
technologists so my app is ready I

00:00:35,430 --> 00:00:40,290
develop my application now I need to

00:00:37,559 --> 00:00:41,910
purchase in production but deploying to

00:00:40,290 --> 00:00:45,719
production is complex there are a lot of

00:00:41,910 --> 00:00:49,410
parameters to take into account like on

00:00:45,719 --> 00:00:52,890
my application only used like of 10% of

00:00:49,410 --> 00:00:55,710
my resources on my on my servers my app

00:00:52,890 --> 00:00:57,840
is leaking memory why why the server

00:00:55,710 --> 00:00:59,760
went out of memory a lot of question

00:00:57,840 --> 00:01:02,820
come to comes to mind when you need to

00:00:59,760 --> 00:01:05,580
deploy your application so this is a

00:01:02,820 --> 00:01:10,470
this is exactly why I built p.m. - three

00:01:05,580 --> 00:01:12,390
years ago so what is p.m. 2 p.m. - is a

00:01:10,470 --> 00:01:14,700
production application manager for

00:01:12,390 --> 00:01:16,860
Nadia's is dedicated from the GS but you

00:01:14,700 --> 00:01:19,650
can manage other software's with p.m. -

00:01:16,860 --> 00:01:21,630
it comes with a built in load balancer

00:01:19,650 --> 00:01:26,159
guarantees a time and help you manage

00:01:21,630 --> 00:01:28,530
your processes so how are your

00:01:26,159 --> 00:01:30,780
application before using p.m. - so it's

00:01:28,530 --> 00:01:32,759
a bit messy you will use like a lot of

00:01:30,780 --> 00:01:35,369
different software you may use like some

00:01:32,759 --> 00:01:37,259
UNIX built-in process manager that are

00:01:35,369 --> 00:01:40,680
not very well fitted for node.js

00:01:37,259 --> 00:01:43,040
applications and so on and also use PM -

00:01:40,680 --> 00:01:45,270
you will have like a structured way of

00:01:43,040 --> 00:01:47,399
deploying your application you will have

00:01:45,270 --> 00:01:49,350
like a global overview you will be able

00:01:47,399 --> 00:01:52,369
to use all the resources on the same

00:01:49,350 --> 00:01:57,390
server and do a lot of things with it

00:01:52,369 --> 00:02:00,090
so p.m. - so it helps you manage and

00:01:57,390 --> 00:02:03,600
optimize all the resources are used by

00:02:00,090 --> 00:02:07,140
your applications it will also help you

00:02:03,600 --> 00:02:09,060
to manage your software from the

00:02:07,140 --> 00:02:12,390
usability side

00:02:09,060 --> 00:02:12,990
log management deployment and also comes

00:02:12,390 --> 00:02:15,630
with the

00:02:12,990 --> 00:02:21,030
module feature that allows you to extend

00:02:15,630 --> 00:02:23,760
the capabilities of PMT so just some

00:02:21,030 --> 00:02:26,130
figures about about the software we have

00:02:23,760 --> 00:02:29,400
more than 10,000 stars and github more

00:02:26,130 --> 00:02:31,920
than 2 million downloads the project is

00:02:29,400 --> 00:02:34,110
like the eighty sixth most popular

00:02:31,920 --> 00:02:37,410
JavaScript project on github there are

00:02:34,110 --> 00:02:41,570
more than 2,500 commits more than 120

00:02:37,410 --> 00:02:44,430
contributors and more than 750 tests so

00:02:41,570 --> 00:02:48,330
tests are very important for pm2 because

00:02:44,430 --> 00:02:50,990
like PM 2 is entirely built on nodejs on

00:02:48,330 --> 00:02:53,370
javascript and we wanted really to

00:02:50,990 --> 00:02:56,160
provide a quality software for

00:02:53,370 --> 00:02:58,350
production application this is why we we

00:02:56,160 --> 00:03:01,410
built a lot of tests we do like almost a

00:02:58,350 --> 00:03:03,930
test drive and development across like

00:03:01,410 --> 00:03:11,430
five different node.js version from not

00:03:03,930 --> 00:03:14,040
GS 0.10 to to the 5.0 so this is like

00:03:11,430 --> 00:03:16,350
this is like the evolution of the

00:03:14,040 --> 00:03:19,020
projects in the beginning we can see

00:03:16,350 --> 00:03:21,630
that an open source project like get a

00:03:19,020 --> 00:03:24,690
lot of contributors and like that

00:03:21,630 --> 00:03:29,010
contributors that participate to all

00:03:24,690 --> 00:03:31,470
part of this software so yes this slide

00:03:29,010 --> 00:03:33,330
is mainly to to say thank you to all the

00:03:31,470 --> 00:03:36,360
contributors that made the software

00:03:33,330 --> 00:03:39,960
better that helped us to solve issues

00:03:36,360 --> 00:03:45,120
that build like features and and and

00:03:39,960 --> 00:03:49,050
everything so you can see there are a

00:03:45,120 --> 00:03:51,830
lot these like is a map of downloads of

00:03:49,050 --> 00:03:55,170
p.m. to in real time so it shows you

00:03:51,830 --> 00:03:57,540
where p.m. to has been deluded in a real

00:03:55,170 --> 00:03:59,430
time in the student this global every

00:03:57,540 --> 00:04:01,980
time someone installed p.m. to it does

00:03:59,430 --> 00:04:05,010
like a ping on our server we we

00:04:01,980 --> 00:04:06,900
translate this this IP address into GPS

00:04:05,010 --> 00:04:09,450
coordinates and we put this on this map

00:04:06,900 --> 00:04:14,280
this map is inspired from the trunk v

00:04:09,450 --> 00:04:16,140
and quite nice we have also large

00:04:14,280 --> 00:04:19,320
company already using our software

00:04:16,140 --> 00:04:21,330
paypal into eBay Bloomberg sauce West on

00:04:19,320 --> 00:04:23,060
the edge P Morgan and so on maybe the

00:04:21,330 --> 00:04:26,000
party also

00:04:23,060 --> 00:04:28,160
and we are very proud that this company

00:04:26,000 --> 00:04:34,280
is a use of software in production in a

00:04:28,160 --> 00:04:38,150
lot of servers so now we let let's just

00:04:34,280 --> 00:04:40,160
use about p.m. - I will cover all the

00:04:38,150 --> 00:04:43,250
aspects from the installation to process

00:04:40,160 --> 00:04:45,889
management to monitoring and so on so

00:04:43,250 --> 00:04:47,960
first installation of PM 2 is very easy

00:04:45,889 --> 00:04:50,000
PM 2 is still on the table the source

00:04:47,960 --> 00:04:52,639
code is hosted on github and you can

00:04:50,000 --> 00:04:56,270
install it from NPM so you just need to

00:04:52,639 --> 00:04:59,260
do NPM install PM 2 - G and you will be

00:04:56,270 --> 00:05:04,790
you will have this this software

00:04:59,260 --> 00:05:06,380
available from the command line so now

00:05:04,790 --> 00:05:08,300
setup is required once you've installed

00:05:06,380 --> 00:05:10,520
p.m. - once you launch it it will

00:05:08,300 --> 00:05:12,950
directly pop all the files we configure

00:05:10,520 --> 00:05:15,169
it heals itself and so on but you can

00:05:12,950 --> 00:05:17,330
add some other features like if you want

00:05:15,169 --> 00:05:19,430
to have like a cleaner setup of p.m. -

00:05:17,330 --> 00:05:21,740
you can do p.m. to completion install

00:05:19,430 --> 00:05:23,690
that will help you when you have to

00:05:21,740 --> 00:05:25,400
manage a lot of processes when you might

00:05:23,690 --> 00:05:28,400
actually to processes that has different

00:05:25,400 --> 00:05:30,890
names and and it helps you it will to

00:05:28,400 --> 00:05:32,990
complete all these commands and you ever

00:05:30,890 --> 00:05:35,450
saw I came to startup that allows you to

00:05:32,990 --> 00:05:37,520
generate the startup script so if your

00:05:35,450 --> 00:05:40,880
server crash and you get restarted it

00:05:37,520 --> 00:05:44,360
will like respond all the processes that

00:05:40,880 --> 00:05:50,080
was already launched before the crash

00:05:44,360 --> 00:05:50,080
open so Lansing up

00:05:53,770 --> 00:06:02,080
sorry jet lag so launching apps so

00:06:00,220 --> 00:06:05,199
launching a node.js application is very

00:06:02,080 --> 00:06:07,569
easy like all the commands of PM 2 are

00:06:05,199 --> 00:06:09,849
very easy to use you can go like very in

00:06:07,569 --> 00:06:11,740
a very advanced you can use PM to in a

00:06:09,849 --> 00:06:14,069
very advanced way but all the comments

00:06:11,740 --> 00:06:17,410
are very simply simplistic to use them

00:06:14,069 --> 00:06:19,210
so p.m. to start my node.js application

00:06:17,410 --> 00:06:21,430
and we put your application in

00:06:19,210 --> 00:06:23,680
background will under the logs will

00:06:21,430 --> 00:06:25,660
monitor it and it will auto restart the

00:06:23,680 --> 00:06:30,280
application in case of crash or bad

00:06:25,660 --> 00:06:34,090
behavior from the application PM 2 is

00:06:30,280 --> 00:06:36,490
like dedicated phone RGS but but behind

00:06:34,090 --> 00:06:39,940
the scene it's only like oh phone

00:06:36,490 --> 00:06:41,949
kind of simple simple so you can

00:06:39,940 --> 00:06:44,620
start and kind of script if you need

00:06:41,949 --> 00:06:46,750
like to start with a bash script for

00:06:44,620 --> 00:06:49,150
example you do p.m. to start script that

00:06:46,750 --> 00:06:52,000
Sh there is like a kind of ash table

00:06:49,150 --> 00:06:54,130
that do like mapping like yo this is

00:06:52,000 --> 00:06:56,710
like the SH extension so it's like a

00:06:54,130 --> 00:06:58,860
bash creep and it will start it but if

00:06:56,710 --> 00:07:01,830
you need to declare or your interpreter

00:06:58,860 --> 00:07:05,229
you do like p.m. to start my application

00:07:01,830 --> 00:07:07,780
Python - - interpreter and you can put

00:07:05,229 --> 00:07:10,800
the interpreter so you can set the right

00:07:07,780 --> 00:07:13,870
interpreter to start the application and

00:07:10,800 --> 00:07:15,820
after you can act on your processes so

00:07:13,870 --> 00:07:18,370
as it's a process manager there are like

00:07:15,820 --> 00:07:20,590
some basic commands like to restart the

00:07:18,370 --> 00:07:23,110
application to delete the application to

00:07:20,590 --> 00:07:24,819
stop it and so on so if you develop I

00:07:23,110 --> 00:07:26,620
came across service application and

00:07:24,819 --> 00:07:28,750
let's say that you have like one service

00:07:26,620 --> 00:07:30,610
that is sending emails and that is right

00:07:28,750 --> 00:07:33,849
now spamming a lot of your user you just

00:07:30,610 --> 00:07:35,530
do like p.m. to stop my my my service

00:07:33,849 --> 00:07:42,310
that send emails and after it will be

00:07:35,530 --> 00:07:45,669
stopped so now the cluster mode so as

00:07:42,310 --> 00:07:48,610
you know JavaScript is like mono sweetie

00:07:45,669 --> 00:07:50,650
language so basically you will have all

00:07:48,610 --> 00:07:53,610
your CPUs that will not do anything and

00:07:50,650 --> 00:07:57,849
only one CPU will do all the job so

00:07:53,610 --> 00:08:01,779
that's not the best thing because after

00:07:57,849 --> 00:08:04,050
your application gets overloaded and can

00:08:01,779 --> 00:08:04,050
crash

00:08:06,090 --> 00:08:11,740
so this is not the best thing

00:08:09,030 --> 00:08:13,330
so while using the cluster mode so as

00:08:11,740 --> 00:08:15,250
you know JavaScript is Monas with the

00:08:13,330 --> 00:08:17,650
language so it will only use one thread

00:08:15,250 --> 00:08:21,340
of our one thread one car on your

00:08:17,650 --> 00:08:23,200
computer and by using p.m. 2 p.m. 2 we

00:08:21,340 --> 00:08:26,919
duplicate your application to use all

00:08:23,200 --> 00:08:29,740
the resources on your computer so once

00:08:26,919 --> 00:08:33,510
so all the CPUs will be will be loaded

00:08:29,740 --> 00:08:35,320
we dropped and you will be able to

00:08:33,510 --> 00:08:38,020
enhance the performance of your

00:08:35,320 --> 00:08:39,580
application and so the application needs

00:08:38,020 --> 00:08:41,849
to be stateless if you want to use the

00:08:39,580 --> 00:08:45,100
cluster mode so it means that doesn't

00:08:41,849 --> 00:08:47,350
stop any like a local variable in the

00:08:45,100 --> 00:08:49,779
same process like all the variables need

00:08:47,350 --> 00:08:51,430
to be like shared for example like

00:08:49,779 --> 00:08:54,790
sessions and stuff like that so you need

00:08:51,430 --> 00:08:57,130
to use like radius or any other kind of

00:08:54,790 --> 00:09:01,180
database to share the states between

00:08:57,130 --> 00:09:02,860
your processes so otherwise it's very

00:09:01,180 --> 00:09:04,990
simple to start an application in

00:09:02,860 --> 00:09:08,080
cluster model you just do p.m. to start

00:09:04,990 --> 00:09:10,870
my node.js application - II and the

00:09:08,080 --> 00:09:13,270
number of instances if you put 0 it will

00:09:10,870 --> 00:09:15,790
auto-detect the number of CPUs and we

00:09:13,270 --> 00:09:18,040
duplicate the number of application

00:09:15,790 --> 00:09:20,770
depending on the number of CPUs but you

00:09:18,040 --> 00:09:24,160
can also declare your own number for

00:09:20,770 --> 00:09:27,430
example if you have like a processor CPU

00:09:24,160 --> 00:09:30,160
with 8 cores you can say I only want

00:09:27,430 --> 00:09:31,660
like 7 CPUs to be used and one CPU that

00:09:30,160 --> 00:09:37,000
do like something else like for the

00:09:31,660 --> 00:09:39,640
system Oh so after you as the PM 2 is

00:09:37,000 --> 00:09:42,280
writing a node.js we are tightly linked

00:09:39,640 --> 00:09:44,140
to no GS so we can offer like more

00:09:42,280 --> 00:09:46,690
advanced feature so for example the

00:09:44,140 --> 00:09:48,870
cluster or future and also like for

00:09:46,690 --> 00:09:51,670
managing your application we we offer

00:09:48,870 --> 00:09:53,280
reload without downtime so you do p.m.

00:09:51,670 --> 00:09:57,040
to reload the name of your application

00:09:53,280 --> 00:09:58,450
this will for example if you were if you

00:09:57,040 --> 00:10:00,700
already starts it for application in

00:09:58,450 --> 00:10:03,880
cluster mode and you do reload it will

00:10:00,700 --> 00:10:06,070
pop up for new processes we wait that

00:10:03,880 --> 00:10:09,250
the for all processes finish - to

00:10:06,070 --> 00:10:11,260
process their work and the new one will

00:10:09,250 --> 00:10:13,450
replace the old one so you will not lose

00:10:11,260 --> 00:10:15,400
any queries so it's like seamless for

00:10:13,450 --> 00:10:17,410
your users and you can update your code

00:10:15,400 --> 00:10:19,569
very easily without any don't

00:10:17,410 --> 00:10:21,879
after there is the graceful reload

00:10:19,569 --> 00:10:23,889
feature that will send the Steindl to

00:10:21,879 --> 00:10:26,560
your processor to say okay you are going

00:10:23,889 --> 00:10:29,379
to be killed so finish all your your

00:10:26,560 --> 00:10:31,690
work or close all the database

00:10:29,379 --> 00:10:33,339
connections and so on and after you do

00:10:31,690 --> 00:10:35,470
like you process that exit and it will

00:10:33,339 --> 00:10:37,779
exit the application and the new one

00:10:35,470 --> 00:10:39,490
will replace the old one and after you

00:10:37,779 --> 00:10:42,069
have two scalar well this is like a

00:10:39,490 --> 00:10:43,810
nifty feature that just like to scale up

00:10:42,069 --> 00:10:46,870
or scale it down the number of processes

00:10:43,810 --> 00:10:49,779
so if you do like p.m. to scale my up my

00:10:46,870 --> 00:10:52,000
API 8 it will like to whip up eight

00:10:49,779 --> 00:10:58,470
processes if you do too it will scale

00:10:52,000 --> 00:11:01,449
down all your processes and so now

00:10:58,470 --> 00:11:04,779
inspecting applications so once you

00:11:01,449 --> 00:11:06,189
start your applications it's very useful

00:11:04,779 --> 00:11:08,740
to have some information about the

00:11:06,189 --> 00:11:11,769
listing of your processes the CPU usage

00:11:08,740 --> 00:11:14,290
memory usage and so on so there are some

00:11:11,769 --> 00:11:17,379
comments that updating on p.m. 2 p.m. to

00:11:14,290 --> 00:11:19,810
list that will simply list all the

00:11:17,379 --> 00:11:21,040
processes that are launched so you can

00:11:19,810 --> 00:11:24,970
see like the name of your application

00:11:21,040 --> 00:11:27,850
the process ID the mode that the script

00:11:24,970 --> 00:11:29,860
has been launched on the PID the status

00:11:27,850 --> 00:11:33,310
the number of restart app time memory

00:11:29,860 --> 00:11:36,189
and all this or key key metrics here

00:11:33,310 --> 00:11:37,720
information know so for example you can

00:11:36,189 --> 00:11:40,420
see on this list that there is like the

00:11:37,720 --> 00:11:43,600
first script is like it's a bash script

00:11:40,420 --> 00:11:45,100
and you can see that the mode is fork so

00:11:43,600 --> 00:11:47,500
because it's like a bash script it's a

00:11:45,100 --> 00:11:50,110
simple but the other application

00:11:47,500 --> 00:11:55,149
are like no GS application so they are

00:11:50,110 --> 00:11:58,149
all launched on cluster mode after you

00:11:55,149 --> 00:12:00,939
can monitor on the CPU and memory usage

00:11:58,149 --> 00:12:04,059
you just need to do PM to monitor and in

00:12:00,939 --> 00:12:07,569
your terminal it will like pop like

00:12:04,059 --> 00:12:09,670
interface built on town caps to see you

00:12:07,569 --> 00:12:11,860
in a real-time all your processes are

00:12:09,670 --> 00:12:13,360
behaving so you can track this blue

00:12:11,860 --> 00:12:15,959
memory usage or feature of your

00:12:13,360 --> 00:12:15,959
applications

00:12:17,980 --> 00:12:23,230
and you can also get more information

00:12:20,380 --> 00:12:25,570
about your processes you just do p.m. to

00:12:23,230 --> 00:12:27,250
show the name the name of my application

00:12:25,570 --> 00:12:29,110
or JIT and you can get different

00:12:27,250 --> 00:12:31,360
transformations so for example on the

00:12:29,110 --> 00:12:34,209
top of the screenshot you can see like

00:12:31,360 --> 00:12:35,500
the statues name ID the logs it goes

00:12:34,209 --> 00:12:39,100
like the logs when you start an

00:12:35,500 --> 00:12:42,430
application with p.m. - we split the

00:12:39,100 --> 00:12:44,860
logs in two files like a files - to get

00:12:42,430 --> 00:12:48,790
like all the error output and one order

00:12:44,860 --> 00:12:51,130
to get only the standard output you can

00:12:48,790 --> 00:12:52,990
see the PID path the mode that the mode

00:12:51,130 --> 00:12:55,000
on which your application has been

00:12:52,990 --> 00:12:56,440
started on if there is like the watch

00:12:55,000 --> 00:12:58,570
and a reload feature because there is

00:12:56,440 --> 00:13:00,040
like this feature on a p.m. - that

00:12:58,570 --> 00:13:03,010
allows you to when you start an

00:13:00,040 --> 00:13:04,540
application - we start offer to reload

00:13:03,010 --> 00:13:07,360
your application when there is a fight

00:13:04,540 --> 00:13:09,660
that is changed so it's it can be useful

00:13:07,360 --> 00:13:12,579
for staging or development environment

00:13:09,660 --> 00:13:15,310
so you have all this metadata on the on

00:13:12,579 --> 00:13:17,350
the first on the top of this screenshot

00:13:15,310 --> 00:13:21,519
after you can have like some information

00:13:17,350 --> 00:13:23,410
about the revision control metadata so

00:13:21,519 --> 00:13:28,089
you can see which revision control has

00:13:23,410 --> 00:13:30,100
been used whereas this is where the

00:13:28,089 --> 00:13:32,380
repository of your application you get

00:13:30,100 --> 00:13:34,930
your route data and and the probes value

00:13:32,380 --> 00:13:37,180
so the last part on the screen you can

00:13:34,930 --> 00:13:40,570
see that there are like some matrix so

00:13:37,180 --> 00:13:45,130
basically you can use the PMX library

00:13:40,570 --> 00:13:47,709
that allows you to track variable of all

00:13:45,130 --> 00:13:50,079
the time in real time from your code so

00:13:47,709 --> 00:13:52,510
for example you can track the number of

00:13:50,079 --> 00:13:54,399
users can exceed the number of WebSocket

00:13:52,510 --> 00:13:56,769
connections you just need to do like

00:13:54,399 --> 00:13:58,870
it's very simple to use you just need to

00:13:56,769 --> 00:14:01,120
do this to use this library to expose

00:13:58,870 --> 00:14:04,209
some variables so you can track their

00:14:01,120 --> 00:14:08,920
values without link to do we are

00:14:04,209 --> 00:14:11,980
continue after we help developers and

00:14:08,920 --> 00:14:14,949
developed by on managing logs so to

00:14:11,980 --> 00:14:16,870
display logs in real time just to PM to

00:14:14,949 --> 00:14:18,670
logs and you will see like all the logs

00:14:16,870 --> 00:14:21,490
in real time you can declare the name of

00:14:18,670 --> 00:14:23,230
the application we also offer the PM to

00:14:21,490 --> 00:14:25,839
flourish command that will alike just

00:14:23,230 --> 00:14:27,850
empty all your logs it can be useful if

00:14:25,839 --> 00:14:30,279
your applications through a lot of logs

00:14:27,850 --> 00:14:31,000
every seconds and so on and you can

00:14:30,279 --> 00:14:34,209
reload the

00:14:31,000 --> 00:14:36,430
so if you use like log rotates you can

00:14:34,209 --> 00:14:41,500
use PM to really lock so it will like

00:14:36,430 --> 00:14:47,079
refresh all the logs the log files so

00:14:41,500 --> 00:14:48,579
now organizing applications so if you

00:14:47,079 --> 00:14:51,009
build your application in the micro

00:14:48,579 --> 00:14:53,560
service where you split your monolithic

00:14:51,009 --> 00:14:55,990
application into small services it can

00:14:53,560 --> 00:14:59,829
be quite painful to start all the

00:14:55,990 --> 00:15:02,259
application with all their options on oh

00:14:59,829 --> 00:15:04,089
it should be a so the environment

00:15:02,259 --> 00:15:07,269
variable the name of your application

00:15:04,089 --> 00:15:09,759
the number of instances you want the the

00:15:07,269 --> 00:15:12,370
watch if the application will be

00:15:09,759 --> 00:15:14,860
restarted on like owners on a certain

00:15:12,370 --> 00:15:17,079
result of memory the argument and some

00:15:14,860 --> 00:15:19,990
if you if you have a lot of application

00:15:17,079 --> 00:15:24,790
can be quite ugly to manage it over the

00:15:19,990 --> 00:15:27,339
time so this is why we have this feature

00:15:24,790 --> 00:15:29,199
it's like the JSON declaration so

00:15:27,339 --> 00:15:31,240
basically you will have like your JSON

00:15:29,199 --> 00:15:33,459
file it can be like in your package the

00:15:31,240 --> 00:15:36,579
JSON or it can be like an independent

00:15:33,459 --> 00:15:39,100
file where you can declare DBA if you

00:15:36,579 --> 00:15:40,839
are and the option of each of your

00:15:39,100 --> 00:15:45,160
application of your core service

00:15:40,839 --> 00:15:47,620
software so like let's say this one like

00:15:45,160 --> 00:15:50,740
this is like I call it ecosystem dot

00:15:47,620 --> 00:15:52,420
JSON so we have three applications and

00:15:50,740 --> 00:15:56,529
you can see that each application has

00:15:52,420 --> 00:15:58,209
different parameters so it's very useful

00:15:56,529 --> 00:16:00,009
when you need to a manage an application

00:15:58,209 --> 00:16:04,480
with lot of services communicating each

00:16:00,009 --> 00:16:07,000
other on the same server and after it's

00:16:04,480 --> 00:16:09,459
seamless to use like JSON declaration so

00:16:07,000 --> 00:16:11,949
this is like I call it ecosystems ojisan

00:16:09,459 --> 00:16:13,839
so after if you want to start all this

00:16:11,949 --> 00:16:16,089
application you just do p.m. to start

00:16:13,839 --> 00:16:19,660
ecosystem that JSON and it will pop up

00:16:16,089 --> 00:16:22,480
all your process ISM and it will be you

00:16:19,660 --> 00:16:24,519
will be able to list them and and do all

00:16:22,480 --> 00:16:26,920
the comments that are useful for other

00:16:24,519 --> 00:16:29,259
OGS application after you can do we stop

00:16:26,920 --> 00:16:33,540
p.m. to restart ecosystem the JSON and

00:16:29,259 --> 00:16:33,540
you can stop it otherwise

00:16:35,480 --> 00:16:43,470
so deployment system so I use it a lot

00:16:40,680 --> 00:16:46,920
it's like a picture so basically we

00:16:43,470 --> 00:16:49,560
embedded a simple bash script from TG

00:16:46,920 --> 00:16:52,520
it's like a very simple way to deploy

00:16:49,560 --> 00:16:56,070
application so basically I think that

00:16:52,520 --> 00:16:58,050
that developers should be able to manage

00:16:56,070 --> 00:17:00,450
themselves the lifecycle of their

00:16:58,050 --> 00:17:02,970
application they should not ask to like

00:17:00,450 --> 00:17:05,220
the sysadmin our son to deploy the new

00:17:02,970 --> 00:17:07,410
the new application because like the

00:17:05,220 --> 00:17:09,990
developer need to be able to deploy a

00:17:07,410 --> 00:17:11,940
specific version on on one server to see

00:17:09,990 --> 00:17:13,860
how it behaves on production and so on

00:17:11,940 --> 00:17:16,260
so that's why we published

00:17:13,860 --> 00:17:19,230
we built this deployment system in 2

00:17:16,260 --> 00:17:21,209
p.m. - so you just take the previous

00:17:19,230 --> 00:17:22,980
file that was declaring each of your

00:17:21,209 --> 00:17:26,070
application into the echo standard JSON

00:17:22,980 --> 00:17:27,450
and you will add the deploy part on the

00:17:26,070 --> 00:17:30,450
deploy part you will have all your

00:17:27,450 --> 00:17:32,070
environments so for example in this in

00:17:30,450 --> 00:17:34,500
this screenshot you can see the

00:17:32,070 --> 00:17:38,640
production environment that that that

00:17:34,500 --> 00:17:41,160
must be that that has like multiple

00:17:38,640 --> 00:17:42,750
earths so you can see that this the

00:17:41,160 --> 00:17:45,000
production environment would deploy the

00:17:42,750 --> 00:17:47,490
code in this free host and after there

00:17:45,000 --> 00:17:50,310
is the staging of arraignment so in

00:17:47,490 --> 00:17:53,370
these two to two parts you can declare

00:17:50,310 --> 00:17:56,120
out front option which which what is the

00:17:53,370 --> 00:17:58,680
git repository that must deploy the pass

00:17:56,120 --> 00:18:00,990
deposit deploy comment so for example if

00:17:58,680 --> 00:18:03,930
I type in my code here it will run an

00:18:00,990 --> 00:18:06,060
NPM install to install all the modules

00:18:03,930 --> 00:18:07,890
that if I have if I have added some

00:18:06,060 --> 00:18:09,900
modules on my package or JSON

00:18:07,890 --> 00:18:11,850
it will start or restart all the

00:18:09,900 --> 00:18:14,340
processes that are cloud into the same

00:18:11,850 --> 00:18:16,470
phylum with the environment you want and

00:18:14,340 --> 00:18:18,420
so on and you can also declare the

00:18:16,470 --> 00:18:20,730
environment variable that must be

00:18:18,420 --> 00:18:22,860
injected into your application as you

00:18:20,730 --> 00:18:24,960
can see in the staging part where there

00:18:22,860 --> 00:18:29,750
is like the environment and there is not

00:18:24,960 --> 00:18:32,910
there should be staging ok

00:18:29,750 --> 00:18:35,250
after the commands are very easy so once

00:18:32,910 --> 00:18:37,500
you have this file and you have all the

00:18:35,250 --> 00:18:39,480
authorization you have to make sure that

00:18:37,500 --> 00:18:42,930
your target servers as like the

00:18:39,480 --> 00:18:45,600
authorization to like the clones and and

00:18:42,930 --> 00:18:47,120
all these commands you can do p.m. to

00:18:45,600 --> 00:18:49,820
deploy my

00:18:47,120 --> 00:18:52,760
my configuration file on the environment

00:18:49,820 --> 00:18:54,860
and setup so basically it we go to your

00:18:52,760 --> 00:18:57,680
server to your remote server we quit all

00:18:54,860 --> 00:18:59,780
the the files that are needed we treat

00:18:57,680 --> 00:19:01,790
like a deployment file so we'll be able

00:18:59,780 --> 00:19:06,020
to track your deployment of all the time

00:19:01,790 --> 00:19:07,580
and after unsuited that you you can

00:19:06,020 --> 00:19:09,860
update your remote application for

00:19:07,580 --> 00:19:12,530
easily so you just do p.m. to deploy

00:19:09,860 --> 00:19:14,390
ecosystem design production and we look

00:19:12,530 --> 00:19:18,110
at the production part on your ecosystem

00:19:14,390 --> 00:19:20,150
file and with a choke codon and if you

00:19:18,110 --> 00:19:22,490
deployed like a wrong version or

00:19:20,150 --> 00:19:26,240
something like that you can revert to

00:19:22,490 --> 00:19:29,390
the end - deployment so p.m. to deploy

00:19:26,240 --> 00:19:31,520
ecosystem prediction revert and all many

00:19:29,390 --> 00:19:33,700
deployments you want to go back to

00:19:31,520 --> 00:19:33,700
rollback

00:19:34,960 --> 00:19:42,950
so modules so modules is like a new

00:19:39,500 --> 00:19:45,590
feature on human on p.m. - so as you see

00:19:42,950 --> 00:19:47,210
there are already some the more

00:19:45,590 --> 00:19:49,970
important features that are embedded in

00:19:47,210 --> 00:19:52,730
p.m. - from the deployment the

00:19:49,970 --> 00:19:55,730
application declaration from the

00:19:52,730 --> 00:19:59,840
monitoring feature and so on and now we

00:19:55,730 --> 00:20:02,960
do not want to make your p.m. to Blues

00:19:59,840 --> 00:20:04,910
either so we don't want to put too many

00:20:02,960 --> 00:20:07,880
features on the software so that's why

00:20:04,910 --> 00:20:10,610
now we built a module system so it's

00:20:07,880 --> 00:20:12,800
like an obvious application that can do

00:20:10,610 --> 00:20:14,450
many things that can extend the PM 2

00:20:12,800 --> 00:20:17,240
features how it can be a standalone

00:20:14,450 --> 00:20:21,590
software or it can be like a monitoring

00:20:17,240 --> 00:20:23,240
module so what is the module so it's an

00:20:21,590 --> 00:20:24,950
application that extend the PM 2

00:20:23,240 --> 00:20:27,500
capabilities because there are like

00:20:24,950 --> 00:20:29,510
there is the API on p.m. - so you can

00:20:27,500 --> 00:20:32,660
interact with p.m. - programmatically

00:20:29,510 --> 00:20:35,740
you just need to put it on your package

00:20:32,660 --> 00:20:39,200
- Jason after you can call p.m. two

00:20:35,740 --> 00:20:41,900
points tart the name of my file you can

00:20:39,200 --> 00:20:44,960
pass the option you want like the JSON

00:20:41,900 --> 00:20:47,570
I'll show you before as a parameter it

00:20:44,960 --> 00:20:49,790
can be a worker process providing an API

00:20:47,570 --> 00:20:52,040
so in the future it would be interesting

00:20:49,790 --> 00:20:55,640
like because micro services like a real

00:20:52,040 --> 00:20:58,400
trend so in the future it's not I see

00:20:55,640 --> 00:20:59,559
that that it would not be like only

00:20:58,400 --> 00:21:01,840
library that you

00:20:59,559 --> 00:21:03,940
in Seoul from NPM library that you can

00:21:01,840 --> 00:21:06,519
interact in your on your with your coder

00:21:03,940 --> 00:21:08,320
but it could be like also processes so

00:21:06,519 --> 00:21:11,730
you could be able to install like

00:21:08,320 --> 00:21:13,899
services that that do like all

00:21:11,730 --> 00:21:16,659
authorization and that expose an API

00:21:13,899 --> 00:21:18,580
that you can use in another processor so

00:21:16,659 --> 00:21:21,490
you could like install different modules

00:21:18,580 --> 00:21:24,279
that can do like different jobs for your

00:21:21,490 --> 00:21:26,499
application I can be a totally

00:21:24,279 --> 00:21:28,600
independent software for example you can

00:21:26,499 --> 00:21:30,879
do like p.m. to install cinavia

00:21:28,600 --> 00:21:36,249
and you will have like a private and PM

00:21:30,879 --> 00:21:39,039
repository or PM to install PM to SMTP

00:21:36,249 --> 00:21:43,869
and you will have like SMTP server in

00:21:39,039 --> 00:21:46,659
the developed in Nadya's a lot of other

00:21:43,869 --> 00:21:49,840
things so basically the command is

00:21:46,659 --> 00:21:51,970
simple PM to install my module name the

00:21:49,840 --> 00:21:54,309
module name is like the name it's a name

00:21:51,970 --> 00:21:56,679
of a module on the NPM repository so you

00:21:54,309 --> 00:21:58,990
cannot install any library you cannot do

00:21:56,679 --> 00:21:59,769
well like PM to install Express doesn't

00:21:58,990 --> 00:22:01,690
makes any sense

00:21:59,769 --> 00:22:04,179
it should be like an application that is

00:22:01,690 --> 00:22:07,570
configured in a way that can be run in

00:22:04,179 --> 00:22:10,690
standalone way so when you do this

00:22:07,570 --> 00:22:13,119
PM to install my mojo it gets the module

00:22:10,690 --> 00:22:18,909
from NPM it will start it and it will

00:22:13,119 --> 00:22:21,879
keep it alive forever after managing

00:22:18,909 --> 00:22:24,159
module is like simple PM to install my

00:22:21,879 --> 00:22:26,559
module if you want to win install it PM

00:22:24,159 --> 00:22:28,679
2 and install and you can configure your

00:22:26,559 --> 00:22:30,580
modules so you can put like different

00:22:28,679 --> 00:22:33,610
configuration variable that can be

00:22:30,580 --> 00:22:35,440
operated by p.m. - so you do PM to set

00:22:33,610 --> 00:22:37,360
the name of my module and the name of my

00:22:35,440 --> 00:22:40,090
attribute and the new value that you

00:22:37,360 --> 00:22:43,389
want to be used in your on your new

00:22:40,090 --> 00:22:47,259
software so I will just show you some

00:22:43,389 --> 00:22:49,899
modules that we already developed so for

00:22:47,259 --> 00:22:52,119
example tulip rotates all the logs of

00:22:49,899 --> 00:22:54,279
your file you just do p.m. to install

00:22:52,119 --> 00:22:56,440
p.m. to block rotate and this software

00:22:54,279 --> 00:22:59,320
we connect to p.m. - we list all the

00:22:56,440 --> 00:23:01,360
processes will look at which files are

00:22:59,320 --> 00:23:04,269
opened and which file are like being

00:23:01,360 --> 00:23:07,659
writing on and it will check if it not

00:23:04,269 --> 00:23:11,289
exceed like a certain amount of disk

00:23:07,659 --> 00:23:13,180
space or if it doesn't like it sit like

00:23:11,289 --> 00:23:15,790
one week and so on and it will

00:23:13,180 --> 00:23:19,180
Metiria will log rotate all your final

00:23:15,790 --> 00:23:21,010
so built-in you just do came to install

00:23:19,180 --> 00:23:23,490
PM to lock rotate and your your audio

00:23:21,010 --> 00:23:26,260
file or your log files will be rotated

00:23:23,490 --> 00:23:28,720
after there is like this PM to web shell

00:23:26,260 --> 00:23:33,040
so PM to web shell doesn't walk on the

00:23:28,720 --> 00:23:34,990
no GS 4 & 5 because like behind the

00:23:33,040 --> 00:23:38,560
scene behind PM to web shell there is

00:23:34,990 --> 00:23:42,070
like TT yjs that is a way to expose the

00:23:38,560 --> 00:23:43,930
web shell from your browser so I just

00:23:42,070 --> 00:23:46,360
made this proof of concept so if you do

00:23:43,930 --> 00:23:49,330
PM to install PM to web channel you will

00:23:46,360 --> 00:23:50,890
have a fully capable terminal in your

00:23:49,330 --> 00:23:53,500
browser so it means that you can use

00:23:50,890 --> 00:23:56,410
Emacs you can use vim you can use H top

00:23:53,500 --> 00:23:59,980
you can use anything you want like like

00:23:56,410 --> 00:24:02,950
on windows and so on it looks like this

00:23:59,980 --> 00:24:04,450
so you just install this module and

00:24:02,950 --> 00:24:09,250
after you will be able to connect in

00:24:04,450 --> 00:24:11,470
localhost or from remote into a PM to

00:24:09,250 --> 00:24:14,020
web shell and you love this terminal for

00:24:11,470 --> 00:24:16,360
your capable after you can configure

00:24:14,020 --> 00:24:18,880
some things as I showed you before there

00:24:16,360 --> 00:24:21,430
is like the configuration system so far

00:24:18,880 --> 00:24:26,170
going for example I can do p.m. to set

00:24:21,430 --> 00:24:28,720
p.m. to web shell as GPS through true

00:24:26,170 --> 00:24:33,670
and it will expose this web shala

00:24:28,720 --> 00:24:37,030
in a HTTP HTTP protocol so I do I do not

00:24:33,670 --> 00:24:39,130
advise you to use this this module in

00:24:37,030 --> 00:24:42,610
production servers on because I can be a

00:24:39,130 --> 00:24:46,930
bit risky but it's a nice pull of

00:24:42,610 --> 00:24:50,200
concept so to write your own module it's

00:24:46,930 --> 00:24:53,950
very simple you just do if you installed

00:24:50,200 --> 00:25:00,490
the last test PM 2 version you have

00:24:53,950 --> 00:25:02,530
moderns do 0.15 version of p.m. - you

00:25:00,490 --> 00:25:05,260
have the comment came to module generate

00:25:02,530 --> 00:25:07,600
that will create a sample module that

00:25:05,260 --> 00:25:09,640
you can directly publish so after you go

00:25:07,600 --> 00:25:12,040
to this folder you do PM to module

00:25:09,640 --> 00:25:14,710
publish it we do like npm publish and it

00:25:12,040 --> 00:25:18,010
will do a git bash and after you will be

00:25:14,710 --> 00:25:20,470
able to say 21 ok install this module so

00:25:18,010 --> 00:25:22,360
for example could be like a chat so you

00:25:20,470 --> 00:25:24,250
could do like p.m. to install p.m. to

00:25:22,360 --> 00:25:25,560
chat for example and you will have like

00:25:24,250 --> 00:25:29,690
your chat

00:25:25,560 --> 00:25:32,580
could be like SMTP server Daniel's

00:25:29,690 --> 00:25:35,280
anything anything you want and the

00:25:32,580 --> 00:25:37,650
official motor repositories is p.m. to

00:25:35,280 --> 00:25:39,870
either so there are already more than 20

00:25:37,650 --> 00:25:42,150
modules so there are only three module

00:25:39,870 --> 00:25:44,610
like acting as a standalone processes

00:25:42,150 --> 00:25:46,560
and the other modules are like module

00:25:44,610 --> 00:25:48,480
that can interact with a different part

00:25:46,560 --> 00:25:51,990
of your infrastructure so for example

00:25:48,480 --> 00:25:54,570
there are modules that that connect to

00:25:51,990 --> 00:25:56,790
your radius database that connect to

00:25:54,570 --> 00:25:59,010
your MongoDB database to your values to

00:25:56,790 --> 00:26:00,750
your coach DB or anything else and after

00:25:59,010 --> 00:26:04,860
you can get the matrix and you can also

00:26:00,750 --> 00:26:07,680
act on them so yes monitoring with key

00:26:04,860 --> 00:26:09,480
metrics so basically we built our key

00:26:07,680 --> 00:26:12,030
metrics the solution key metrics on top

00:26:09,480 --> 00:26:13,770
of p.m. to so if you already use p.m. to

00:26:12,030 --> 00:26:15,900
its stimulus to integrate two key

00:26:13,770 --> 00:26:18,810
metrics and you can do like the basic

00:26:15,900 --> 00:26:20,700
monitoring features and you can you can

00:26:18,810 --> 00:26:23,160
like track a lot of things with key

00:26:20,700 --> 00:26:25,080
metrics so it looked like this so you

00:26:23,160 --> 00:26:27,960
have like a listing of all the processes

00:26:25,080 --> 00:26:29,730
are on your server and give you a global

00:26:27,960 --> 00:26:34,770
overview of all your application in real

00:26:29,730 --> 00:26:37,020
time it's like a unique product and we

00:26:34,770 --> 00:26:40,230
saw some computer trials coming the more

00:26:37,020 --> 00:26:48,210
and more so that's good so thank you

00:26:40,230 --> 00:26:54,570
thank you thank you and the slides are

00:26:48,210 --> 00:27:00,090
available on you wanna have some

00:26:54,570 --> 00:27:03,750
questions for Alexander and PM to thank

00:27:00,090 --> 00:27:08,340
you for creating p.m. to using PMT in

00:27:03,750 --> 00:27:11,790
production server now but there's one

00:27:08,340 --> 00:27:16,440
thing that I'm still thinking about

00:27:11,790 --> 00:27:21,120
whether fully using PM 2 is do you have

00:27:16,440 --> 00:27:24,660
any docker support by default yes now

00:27:21,120 --> 00:27:27,870
I'm using docker but then I'm because of

00:27:24,660 --> 00:27:30,360
the foreground mode and stuff some

00:27:27,870 --> 00:27:31,220
problem with p.m. to switch back to use

00:27:30,360 --> 00:27:34,860
NPM

00:27:31,220 --> 00:27:40,440
what's your view and on a support on

00:27:34,860 --> 00:27:44,160
docker so we we have some

00:27:40,440 --> 00:27:47,130
docker containers that are like able to

00:27:44,160 --> 00:27:49,200
run TM 2 so PM 2 is always useful when

00:27:47,130 --> 00:27:50,610
you use docker because it can it embed

00:27:49,200 --> 00:27:53,550
like the cluster or module

00:27:50,610 --> 00:27:58,380
cluster mode and so it it it allows you

00:27:53,550 --> 00:28:01,770
to do like all this optimization about

00:27:58,380 --> 00:28:03,990
the resources usage and sure I should do

00:28:01,770 --> 00:28:06,120
like medomak documentation about docker

00:28:03,990 --> 00:28:09,120
but we have really like some docker fire

00:28:06,120 --> 00:28:11,280
and I will make like a page on our

00:28:09,120 --> 00:28:13,970
official documentation to explain how to

00:28:11,280 --> 00:28:18,180
use p.m. to in the best way with dr.

00:28:13,970 --> 00:28:20,670
right sorry this is not a good question

00:28:18,180 --> 00:28:22,340
except what's the visualization what how

00:28:20,670 --> 00:28:26,180
did you do the visualization the slides

00:28:22,340 --> 00:28:29,880
it's really cool the globe the globe

00:28:26,180 --> 00:28:31,380
it's open source project I I hacked I

00:28:29,880 --> 00:28:34,470
don't remember exactly which

00:28:31,380 --> 00:28:37,680
repositories but it's someone that that

00:28:34,470 --> 00:28:40,140
that built like that we produced like

00:28:37,680 --> 00:28:42,660
the same dashboard than in the movie

00:28:40,140 --> 00:28:44,490
Tron so there is like this entire

00:28:42,660 --> 00:28:47,220
dashboard you can see on the Tron movie

00:28:44,490 --> 00:28:49,710
that you did like in JavaScript and I

00:28:47,220 --> 00:28:54,950
just took like the map and I acted so

00:28:49,710 --> 00:28:54,950
totally the web like a different result

00:28:58,310 --> 00:29:04,650
except the monitor the memory memory

00:29:01,080 --> 00:29:08,040
usage is there any other additional

00:29:04,650 --> 00:29:10,950
memory feature such like hip Tom or

00:29:08,040 --> 00:29:13,260
snapshot so yes basically you have like

00:29:10,950 --> 00:29:15,480
also the max memory we load maximum

00:29:13,260 --> 00:29:18,060
which top commander that allows you if

00:29:15,480 --> 00:29:20,730
you use like for example all the socket

00:29:18,060 --> 00:29:24,090
IO version that was leaking before and

00:29:20,730 --> 00:29:26,720
you cannot upgrade this library you can

00:29:24,090 --> 00:29:29,670
use this max memory we stopped that will

00:29:26,720 --> 00:29:32,450
monitor the memory usage and that will

00:29:29,670 --> 00:29:35,640
reload your application in case of this

00:29:32,450 --> 00:29:38,370
result being like reached so you can set

00:29:35,640 --> 00:29:40,140
like limits on the memory usage after

00:29:38,370 --> 00:29:44,400
for the if dump and

00:29:40,140 --> 00:29:46,650
it dump and then CPU dump and so on you

00:29:44,400 --> 00:29:49,200
need to use to need to use the key

00:29:46,650 --> 00:29:53,940
matrix or a commercial solution to get

00:29:49,200 --> 00:29:57,090
these features so you mean we can also

00:29:53,940 --> 00:30:00,050
add extra event when the leaking events

00:29:57,090 --> 00:30:00,050
happened right yes

00:30:00,200 --> 00:30:07,200
max memory restarts yes it's a bit like

00:30:05,190 --> 00:30:10,440
Missy but you can see like on the first

00:30:07,200 --> 00:30:14,640
line max memory restart and I can put

00:30:10,440 --> 00:30:17,430
the memory the memory limit of my

00:30:14,640 --> 00:30:20,250
application and it will not do restart

00:30:17,430 --> 00:30:22,860
it not doesn't do like a restart it does

00:30:20,250 --> 00:30:26,940
like a reload if it's an RGS application

00:30:22,860 --> 00:30:28,680
so it will be like seamless to be

00:30:26,940 --> 00:30:31,320
reloaded like if your application which

00:30:28,680 --> 00:30:35,220
is memory limit it will be seamless like

00:30:31,320 --> 00:30:37,200
so it's not like very clean way to under

00:30:35,220 --> 00:30:40,350
the memory leaks but sometimes you

00:30:37,200 --> 00:30:46,200
cannot do like in the other ways thank

00:30:40,350 --> 00:30:48,780
you as far as I know like no J's the

00:30:46,200 --> 00:30:51,660
cluster module allows you to secure like

00:30:48,780 --> 00:30:54,300
never connections bypassing the UDS

00:30:51,660 --> 00:30:59,070
socket to another process so does p.m.

00:30:54,300 --> 00:31:00,810
who does it differently so you mean like

00:30:59,070 --> 00:31:03,870
you could like use just the cluster

00:31:00,810 --> 00:31:05,790
module to do so basically yes you can do

00:31:03,870 --> 00:31:09,210
you can just use the cluster module if

00:31:05,790 --> 00:31:11,370
you want to use all these views so first

00:31:09,210 --> 00:31:13,860
thing is that I think that's not the

00:31:11,370 --> 00:31:16,910
developer job to do all these things and

00:31:13,860 --> 00:31:19,500
the PM to does much more than just like

00:31:16,910 --> 00:31:21,750
clustering your application it adds some

00:31:19,500 --> 00:31:23,520
features like the reload like the

00:31:21,750 --> 00:31:25,890
graceful willow that are like critical

00:31:23,520 --> 00:31:27,780
features of production applications so

00:31:25,890 --> 00:31:29,370
sure you can use the cluster mode

00:31:27,780 --> 00:31:31,320
crystal module by yourself

00:31:29,370 --> 00:31:34,800
but if you use PM 2 it will be much more

00:31:31,320 --> 00:31:37,020
cleaner we work like spheres on on the

00:31:34,800 --> 00:31:39,720
integration of the crystal mode in

00:31:37,020 --> 00:31:44,010
Panaji application so basically yeah

00:31:39,720 --> 00:31:47,210
it's battle Alton all right Thank You

00:31:44,010 --> 00:32:07,079
Alexander thank you

00:31:47,210 --> 00:32:07,079
[Music]

00:32:10,190 --> 00:32:14,630

YouTube URL: https://www.youtube.com/watch?v=69E5xmF8j-o


