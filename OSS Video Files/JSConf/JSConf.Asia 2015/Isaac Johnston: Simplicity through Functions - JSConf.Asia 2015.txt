Title: Isaac Johnston: Simplicity through Functions - JSConf.Asia 2015
Publication date: 2015-12-15
Playlist: JSConf.Asia 2015
Description: 
	Can functional programming concepts be applied in JavaScript to simplify building software? Using things you already know, we will explore a new style of writing JavaScript in ES2015+.

Isaac is continually exploring different ways to write JavaScript. Works tirelessly defending his home of middle earth's and other far off land's communications at SMX, a global cloud security and carrier-grade email provider. Passionate about functional programming, he is currently prototyping SMX's next generation front-end stack in ClojureScript and React. Tinkers in his spare time on home automation and autonomous space robot projects.

JSConf.Asia - Red Dot Design Museum, Singapore - 19 November 2015.

Source: http://2015.jsconf.asia

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:08,330 --> 00:00:15,780
thank you hello jazz conf Asia I'm Isaac

00:00:13,139 --> 00:00:23,430
you can find me on twitter and github at

00:00:15,780 --> 00:00:25,019
superstructure I live around here you

00:00:23,430 --> 00:00:28,140
might recognize this as a scene from

00:00:25,019 --> 00:00:29,880
Middle Earth and a lot of the Rings more

00:00:28,140 --> 00:00:31,920
realistically known as in New Zealand

00:00:29,880 --> 00:00:33,840
it's a beautiful country so if you have

00:00:31,920 --> 00:00:40,770
the opportunity i highly recommend a

00:00:33,840 --> 00:00:42,899
visit most of my recent commercial work

00:00:40,770 --> 00:00:46,649
has been on a cloud security platform

00:00:42,899 --> 00:00:48,450
called SMX the main product is cloud

00:00:46,649 --> 00:00:50,670
email security used by the New Zealand

00:00:48,450 --> 00:00:53,250
government the Defence Force in most

00:00:50,670 --> 00:00:55,289
businesses so we have JavaScript engines

00:00:53,250 --> 00:00:57,000
running inside our mail servers that

00:00:55,289 --> 00:00:59,820
handle the majority of mail flow in the

00:00:57,000 --> 00:01:02,280
whole country that's always so used by

00:00:59,820 --> 00:01:10,170
other countries such as Australia Japan

00:01:02,280 --> 00:01:15,390
India the average juggler can juggle

00:01:10,170 --> 00:01:19,110
about three things at a time like in

00:01:15,390 --> 00:01:21,950
this example but then he still manages

00:01:19,110 --> 00:01:21,950
to set himself on fire

00:01:29,890 --> 00:01:35,480
the most amazing juggler in the world as

00:01:32,750 --> 00:01:37,460
a world record can joke about 13 things

00:01:35,480 --> 00:01:39,710
at a time so it's not really a lot more

00:01:37,460 --> 00:01:42,070
in the context of things if you think

00:01:39,710 --> 00:01:44,980
about fifty or one hundred or a thousand

00:01:42,070 --> 00:01:47,600
so if we think about this as an analogy

00:01:44,980 --> 00:01:49,880
before our mental capability as

00:01:47,600 --> 00:01:51,860
JavaScript programmers how many things

00:01:49,880 --> 00:01:55,160
about your program can you think about

00:01:51,860 --> 00:01:58,640
at any one time how many parts of your

00:01:55,160 --> 00:02:00,200
program can you juggle most people can

00:01:58,640 --> 00:02:02,330
think about around seven things at a

00:02:00,200 --> 00:02:05,900
time or if you're a complete genius

00:02:02,330 --> 00:02:13,430
maybe 14 but no one can think about 50

00:02:05,900 --> 00:02:15,740
or 100 so the basic premise of this talk

00:02:13,430 --> 00:02:18,860
is that compared to the programs we

00:02:15,740 --> 00:02:21,050
create we're all extremely limited and

00:02:18,860 --> 00:02:23,600
our ability to understand and reason

00:02:21,050 --> 00:02:25,880
about the software how can we get to the

00:02:23,600 --> 00:02:32,420
next level of software creation without

00:02:25,880 --> 00:02:34,690
exceeding our mental capacities and this

00:02:32,420 --> 00:02:38,090
talk will look at what reliability

00:02:34,690 --> 00:02:39,500
simplicity and easiness means how these

00:02:38,090 --> 00:02:43,209
things are related to solving the

00:02:39,500 --> 00:02:45,500
problems on limits our mental capacity

00:02:43,209 --> 00:02:47,720
then go through some code examples in

00:02:45,500 --> 00:02:50,900
JavaScript to help mitigate these

00:02:47,720 --> 00:02:53,000
problems in practice this is a technical

00:02:50,900 --> 00:02:55,780
talk if your JavaScript programmer that

00:02:53,000 --> 00:02:58,700
is based on concepts you already know

00:02:55,780 --> 00:03:00,830
unfortunately there's no music robots or

00:02:58,700 --> 00:03:04,010
live demonstrations it's a practical

00:03:00,830 --> 00:03:05,390
talk on everyday JavaScript I'm not

00:03:04,010 --> 00:03:07,160
going to assume you know any of this

00:03:05,390 --> 00:03:08,750
already so if you do functional

00:03:07,160 --> 00:03:11,000
programming which is going to be

00:03:08,750 --> 00:03:13,489
discussed and haskell or closure or

00:03:11,000 --> 00:03:16,640
something similar this will be quite

00:03:13,489 --> 00:03:19,070
slow we might have time for questions at

00:03:16,640 --> 00:03:21,440
the end but we'll see how it goes let's

00:03:19,070 --> 00:03:23,660
talk is not original work that's

00:03:21,440 --> 00:03:26,840
borrowing a lot from other languages and

00:03:23,660 --> 00:03:29,180
it's based on a 75 year history of work

00:03:26,840 --> 00:03:31,910
by other people just reapplying it in

00:03:29,180 --> 00:03:33,830
the context of JavaScript especially

00:03:31,910 --> 00:03:35,840
want to create rich Hickey they created

00:03:33,830 --> 00:03:37,850
the closure programming language for as

00:03:35,840 --> 00:03:39,650
explanation of simplicity versus

00:03:37,850 --> 00:03:42,250
easiness which I'll summarize in this

00:03:39,650 --> 00:03:44,530
talk as I assume some people might not

00:03:42,250 --> 00:03:47,560
those definitions that he's talked about

00:03:44,530 --> 00:03:48,910
I recommend you look up all of Ricky's

00:03:47,560 --> 00:03:50,830
talks on YouTube even though they're not

00:03:48,910 --> 00:03:55,480
about JavaScript they will help you

00:03:50,830 --> 00:03:57,280
become a better programmer so first

00:03:55,480 --> 00:04:01,510
let's establish some common terminology

00:03:57,280 --> 00:04:02,950
of some important terms words mean

00:04:01,510 --> 00:04:04,450
different things to different people and

00:04:02,950 --> 00:04:10,209
there are a few words you'll need to

00:04:04,450 --> 00:04:12,610
understand so I do email email happens

00:04:10,209 --> 00:04:15,390
to be something users just expect to

00:04:12,610 --> 00:04:18,100
work so the project I'm working on

00:04:15,390 --> 00:04:20,470
reliability means that email is actually

00:04:18,100 --> 00:04:23,020
delivered that is delivered quickly and

00:04:20,470 --> 00:04:26,350
is accurate so for me it's primarily

00:04:23,020 --> 00:04:28,150
about quality and correctness for you

00:04:26,350 --> 00:04:30,550
reliability may have different meanings

00:04:28,150 --> 00:04:35,110
such as software being delivered on time

00:04:30,550 --> 00:04:37,240
or controlling the cost of building and

00:04:35,110 --> 00:04:38,800
maintaining the software or being able

00:04:37,240 --> 00:04:41,950
to confidently change the software and

00:04:38,800 --> 00:04:43,030
the sense almost all of us here probably

00:04:41,950 --> 00:04:45,940
care in one way or another about

00:04:43,030 --> 00:04:48,040
reliability and that our software can be

00:04:45,940 --> 00:04:53,860
trusted in one way or another if you

00:04:48,040 --> 00:04:55,810
don't why not can you imagine a better

00:04:53,860 --> 00:05:00,580
word start the sentence then simplicity

00:04:55,810 --> 00:05:05,740
I can't we need to build simple systems

00:05:00,580 --> 00:05:08,740
if we want to build reliable systems so

00:05:05,740 --> 00:05:11,460
what does simple actually mean the root

00:05:08,740 --> 00:05:14,850
of the word simple are some and flex

00:05:11,460 --> 00:05:19,240
that means one fold or braids or twists

00:05:14,850 --> 00:05:21,840
or untwisted what does one braid look

00:05:19,240 --> 00:05:24,970
like it looks like no braids the

00:05:21,840 --> 00:05:27,910
opposite word is complex that means

00:05:24,970 --> 00:05:30,760
braided together or folded like twisted

00:05:27,910 --> 00:05:32,440
together so we need to be able to think

00:05:30,760 --> 00:05:35,710
about our software in terms of whether

00:05:32,440 --> 00:05:37,690
it is folded together or not simple

00:05:35,710 --> 00:05:40,900
things might have one dimension one

00:05:37,690 --> 00:05:42,520
focus or one objective the important

00:05:40,900 --> 00:05:45,640
word here is the braiding and the

00:05:42,520 --> 00:05:47,560
interleaving not the word one simple is

00:05:45,640 --> 00:05:50,050
not about only having one operation or

00:05:47,560 --> 00:05:52,990
one instance of something simple is

00:05:50,050 --> 00:05:55,280
about that there's no interleaving so

00:05:52,990 --> 00:05:57,410
you can think about things in isolation

00:05:55,280 --> 00:05:59,270
you can see on the left and right there

00:05:57,410 --> 00:06:02,150
are the same number of strands it's four

00:05:59,270 --> 00:06:03,980
strands on the left it is not braided

00:06:02,150 --> 00:06:06,280
and the right it is so simply has

00:06:03,980 --> 00:06:08,840
nothing to do with cardinality

00:06:06,280 --> 00:06:11,090
simplicity is kind of objective you can

00:06:08,840 --> 00:06:14,590
actually look at something and see if

00:06:11,090 --> 00:06:14,590
it's connected to something else or not

00:06:19,780 --> 00:06:24,320
so the bad thing about complexity is

00:06:22,250 --> 00:06:26,150
though if you want to think about a

00:06:24,320 --> 00:06:28,550
piece of your software and it's braided

00:06:26,150 --> 00:06:29,960
together with something else then you

00:06:28,550 --> 00:06:31,610
also have to think about that other part

00:06:29,960 --> 00:06:32,870
and if it's braided to give this with

00:06:31,610 --> 00:06:34,610
something else you start pulling all

00:06:32,870 --> 00:06:37,460
these parts of your software in just to

00:06:34,610 --> 00:06:39,410
solve a single problem you can't think

00:06:37,460 --> 00:06:45,260
about just one concept or dimension and

00:06:39,410 --> 00:06:48,560
isolation another word we frequently

00:06:45,260 --> 00:06:50,180
confused with simple is easy which in

00:06:48,560 --> 00:06:53,240
this derivation is from the leading word

00:06:50,180 --> 00:06:56,060
adjacent which means to line Nia and be

00:06:53,240 --> 00:06:58,550
nearby so there are several meanings

00:06:56,060 --> 00:07:00,710
that you can take from this there's the

00:06:58,550 --> 00:07:02,840
physical meaning of being near like it's

00:07:00,710 --> 00:07:05,479
something right here by right beside me

00:07:02,840 --> 00:07:08,570
is it in my toolkit or is it installed

00:07:05,479 --> 00:07:10,310
on my computer there's also is it near

00:07:08,570 --> 00:07:12,860
to our understanding or is it in our

00:07:10,310 --> 00:07:15,340
current skill set the word in this case

00:07:12,860 --> 00:07:17,900
is about being a familiar concept as

00:07:15,340 --> 00:07:19,450
programmers we're so tremendously self

00:07:17,900 --> 00:07:21,770
involved in these two meanings of easy

00:07:19,450 --> 00:07:23,450
and we think about this far more than we

00:07:21,770 --> 00:07:25,880
should and instead of thinking about

00:07:23,450 --> 00:07:28,039
what is simple simplicity is not the

00:07:25,880 --> 00:07:29,419
same as easy simplicity is not about

00:07:28,039 --> 00:07:30,800
your personal abilities that's not about

00:07:29,419 --> 00:07:36,410
your convenience and it's not about your

00:07:30,800 --> 00:07:38,350
tastes so the first meaning of easy is

00:07:36,410 --> 00:07:41,479
this notion of being physically nearby

00:07:38,350 --> 00:07:43,070
we care so much about we can npm install

00:07:41,479 --> 00:07:45,320
something and get it working in a few

00:07:43,070 --> 00:07:47,120
seconds often we don't think about if

00:07:45,320 --> 00:07:49,280
the thing we installing is a giant ball

00:07:47,120 --> 00:07:52,220
of complexity just that we can get it

00:07:49,280 --> 00:07:53,660
right now this is really easy but is it

00:07:52,220 --> 00:07:57,620
good for the reliability of your

00:07:53,660 --> 00:08:01,970
software conversely if something is

00:07:57,620 --> 00:08:04,070
simple but it is not easy then because

00:08:01,970 --> 00:08:06,710
it is not nearby then it is within your

00:08:04,070 --> 00:08:08,480
control to bring it nearby by making it

00:08:06,710 --> 00:08:14,270
part of your talk or installing it

00:08:08,480 --> 00:08:17,210
I can't read this because i can't read

00:08:14,270 --> 00:08:19,340
chinese we don't learn Chinese and New

00:08:17,210 --> 00:08:22,640
Zealand school unfortunately does that

00:08:19,340 --> 00:08:25,790
make Chinese unreadable there's Chinese

00:08:22,640 --> 00:08:28,820
unreadable no I just don't know Chinese

00:08:25,790 --> 00:08:30,590
so as programmers we're too fixated on

00:08:28,820 --> 00:08:35,150
this notion of easy related to

00:08:30,590 --> 00:08:36,830
familiarity like I can't read that for

00:08:35,150 --> 00:08:39,500
this meaning I don't mean in regards to

00:08:36,830 --> 00:08:40,880
our limits or mental capacity as I was

00:08:39,500 --> 00:08:43,330
talking about earlier I just literally

00:08:40,880 --> 00:08:45,770
mean is it near something I already know

00:08:43,330 --> 00:08:47,800
if you want everything to be easy and

00:08:45,770 --> 00:08:50,090
familiar you'll never learn anything new

00:08:47,800 --> 00:08:52,400
because it cannot be significantly

00:08:50,090 --> 00:08:54,080
different from what you already know we

00:08:52,400 --> 00:08:56,180
also confuse this notion of easy with

00:08:54,080 --> 00:08:57,920
simple all the time by saying that I

00:08:56,180 --> 00:09:00,230
like to use some piece of technology in

00:08:57,920 --> 00:09:03,110
my stack because it is simple when I

00:09:00,230 --> 00:09:10,040
actually mean it it is easy excuse me

00:09:03,110 --> 00:09:12,830
I'll just quit that and when I mean it

00:09:10,040 --> 00:09:16,130
is easy I mean it is similar to

00:09:12,830 --> 00:09:17,900
something I already know conversely to

00:09:16,130 --> 00:09:19,700
make something you don't know which is

00:09:17,900 --> 00:09:21,590
simple familiar all you need to do is

00:09:19,700 --> 00:09:27,200
learn it that's totally within your

00:09:21,590 --> 00:09:28,910
control to make it easy then there's the

00:09:27,200 --> 00:09:31,010
third notion of being easy which is the

00:09:28,910 --> 00:09:32,810
most interesting which is being near to

00:09:31,010 --> 00:09:34,610
our mental capacity to understand

00:09:32,810 --> 00:09:37,700
something because then this were all

00:09:34,610 --> 00:09:40,580
very similar how many conceptual balls

00:09:37,700 --> 00:09:43,130
can you juggle this makes developers

00:09:40,580 --> 00:09:47,450
uncomfortable because we're in the field

00:09:43,130 --> 00:09:48,890
of working and conceptual work so if we

00:09:47,450 --> 00:09:52,370
talk about something being outside a

00:09:48,890 --> 00:09:54,500
mental capacity it hurts our egos we all

00:09:52,370 --> 00:09:56,120
have very similar limitations relative

00:09:54,500 --> 00:09:59,300
to the complexity of the software we can

00:09:56,120 --> 00:10:02,600
create so it's not so embarrassing after

00:09:59,300 --> 00:10:05,390
all we all can't juggle like a hundred

00:10:02,600 --> 00:10:07,250
balls this is the notion of easy you can

00:10:05,390 --> 00:10:09,110
actually control to great benefit in

00:10:07,250 --> 00:10:11,090
your software if you're willing to learn

00:10:09,110 --> 00:10:13,550
some onion familiar ways to write

00:10:11,090 --> 00:10:15,590
JavaScript you can drastically simplify

00:10:13,550 --> 00:10:19,360
your software making it easier to

00:10:15,590 --> 00:10:19,360
understand and ultimately more reliable

00:10:20,310 --> 00:10:24,850
we're in the business of producing

00:10:22,240 --> 00:10:28,060
artifacts for users but we think so much

00:10:24,850 --> 00:10:29,589
about the constructs does a user look at

00:10:28,060 --> 00:10:32,260
our source code and say oh that's so

00:10:29,589 --> 00:10:36,970
nice that javascript is just so amazing

00:10:32,260 --> 00:10:40,019
Wow no users don't care about that that

00:10:36,970 --> 00:10:42,790
users care about usability correctness

00:10:40,019 --> 00:10:45,820
performance and the ability to change

00:10:42,790 --> 00:10:48,420
the software these are all attributes of

00:10:45,820 --> 00:10:51,190
the artifact not the construct

00:10:48,420 --> 00:10:53,230
complexity is endemic and software

00:10:51,190 --> 00:10:55,149
because as developers were too often

00:10:53,230 --> 00:10:58,120
thinking I like this because it's good

00:10:55,149 --> 00:10:58,930
for me personally right now so we need

00:10:58,120 --> 00:11:00,370
to start thinking about building

00:10:58,930 --> 00:11:02,860
software in terms of the complexity of

00:11:00,370 --> 00:11:05,230
the artifact we produce and give to

00:11:02,860 --> 00:11:10,029
users not in terms of the easiness of

00:11:05,230 --> 00:11:11,560
the construct so Ricky revived this

00:11:10,029 --> 00:11:14,230
archaic word to describe creating

00:11:11,560 --> 00:11:16,930
complexity and it means to enter leave

00:11:14,230 --> 00:11:19,300
or into wine or two braids so when I say

00:11:16,930 --> 00:11:20,980
something is conflicting or as complex I

00:11:19,300 --> 00:11:23,730
mean it as breeding things together

00:11:20,980 --> 00:11:26,050
whereas the act of creating complexity

00:11:23,730 --> 00:11:32,199
complexity is bad so obviously

00:11:26,050 --> 00:11:34,180
completing is bad just don't do it I'm

00:11:32,199 --> 00:11:36,430
proposing that some concepts from

00:11:34,180 --> 00:11:39,029
functional programming drastically

00:11:36,430 --> 00:11:41,110
simplify the artifacts we produce

00:11:39,029 --> 00:11:43,690
functional programming covers a wide

00:11:41,110 --> 00:11:45,970
spectrum of languages there is no clear

00:11:43,690 --> 00:11:48,070
widely accepted definition of functional

00:11:45,970 --> 00:11:50,440
programming it's a collection of related

00:11:48,070 --> 00:11:53,529
features that which work together to

00:11:50,440 --> 00:11:55,899
form a very useful style using some

00:11:53,529 --> 00:11:58,089
features from functional programming can

00:11:55,899 --> 00:11:59,740
reduce braiding or complexity thus

00:11:58,089 --> 00:12:02,260
making a program easier to understand

00:11:59,740 --> 00:12:04,000
and increasing reliability some features

00:12:02,260 --> 00:12:06,579
are already widely used in JavaScript

00:12:04,000 --> 00:12:09,220
others require libraries and some are

00:12:06,579 --> 00:12:14,709
just not possible due to language

00:12:09,220 --> 00:12:16,300
constraints so different model

00:12:14,709 --> 00:12:18,699
programming is object orientated

00:12:16,300 --> 00:12:20,740
programming and this emphasizes the

00:12:18,699 --> 00:12:23,550
encapsulation of learning moving parts

00:12:20,740 --> 00:12:26,410
within classes and object instances and

00:12:23,550 --> 00:12:28,660
oh you bundle up data with methods that

00:12:26,410 --> 00:12:31,149
operate on the data whereas in

00:12:28,660 --> 00:12:32,800
functional programming emphasizes the

00:12:31,149 --> 00:12:33,329
use of functions to minimize the number

00:12:32,800 --> 00:12:35,660
of movie

00:12:33,329 --> 00:12:37,889
parts instead of encapsulating them and

00:12:35,660 --> 00:12:39,749
functional programming you have

00:12:37,889 --> 00:12:41,459
behaviorist functions that operate on

00:12:39,749 --> 00:12:43,980
the data as arguments and return values

00:12:41,459 --> 00:12:46,559
so on oh the central activity is around

00:12:43,980 --> 00:12:47,879
classes objects methods whereas in

00:12:46,559 --> 00:12:52,499
functional programming the central

00:12:47,879 --> 00:12:56,999
activity is all around functions so it's

00:12:52,499 --> 00:13:00,290
finally getting to some code this is

00:12:56,999 --> 00:13:03,600
valid JavaScript code albeit not useful

00:13:00,290 --> 00:13:06,720
both 42 and the string hello our values

00:13:03,600 --> 00:13:10,589
I think everyone can see that values

00:13:06,720 --> 00:13:13,379
don't change 42 is always 42 hello as

00:13:10,589 --> 00:13:15,899
always hello values are also not braided

00:13:13,379 --> 00:13:21,629
together with anything so they are

00:13:15,899 --> 00:13:23,339
simple and JavaScript for the primitive

00:13:21,629 --> 00:13:25,860
types such as if you add two numbers

00:13:23,339 --> 00:13:28,139
together or concatenate strings you

00:13:25,860 --> 00:13:30,959
always get a new value it does not

00:13:28,139 --> 00:13:33,899
modify the original number 40 so 40 plus

00:13:30,959 --> 00:13:36,929
2 creates 42 in addition to 40 and too

00:13:33,899 --> 00:13:42,689
or at the original string hello so this

00:13:36,929 --> 00:13:45,290
is all so simple if we bind the result

00:13:42,689 --> 00:13:47,850
of an expression like 40 plus 22 I

00:13:45,290 --> 00:13:50,759
identifier we get an identity

00:13:47,850 --> 00:13:55,230
referencing a value so meaning of life

00:13:50,759 --> 00:13:59,689
is an identity for the value 42 this is

00:13:55,230 --> 00:13:59,689
all so simple there's no braiding here

00:13:59,899 --> 00:14:05,759
now we have a problem the meaning of

00:14:02,639 --> 00:14:07,949
life has changed because of the

00:14:05,759 --> 00:14:10,649
different values of the time the program

00:14:07,949 --> 00:14:12,749
has been executed the state of the

00:14:10,649 --> 00:14:14,459
identifier referencing the value has

00:14:12,749 --> 00:14:17,369
changed or mutated into something else

00:14:14,459 --> 00:14:20,730
so we say the identify now is state and

00:14:17,369 --> 00:14:22,410
that the program is stateful how would

00:14:20,730 --> 00:14:24,239
you test this unless you step through it

00:14:22,410 --> 00:14:25,679
in a debugger you cannot inspect the

00:14:24,239 --> 00:14:27,689
runtime state or the identifier before

00:14:25,679 --> 00:14:31,199
has changed you can only test the most

00:14:27,689 --> 00:14:33,419
recent state state complex values with

00:14:31,199 --> 00:14:36,089
time you don't have the ability to get a

00:14:33,419 --> 00:14:38,429
value independent of time but this is so

00:14:36,089 --> 00:14:39,989
easy and familiar and so many of our

00:14:38,429 --> 00:14:43,350
programming languages and used by

00:14:39,989 --> 00:14:45,149
default in JavaScript a lot of people

00:14:43,350 --> 00:14:45,779
say state is bad because when threading

00:14:45,149 --> 00:14:47,759
and multi-core

00:14:45,779 --> 00:14:50,009
chips concurrency means you need to use

00:14:47,759 --> 00:14:52,259
locks but in this case it has nothing to

00:14:50,009 --> 00:14:54,029
do with concurrency state is complex

00:14:52,259 --> 00:14:56,189
because it is completing the software at

00:14:54,029 --> 00:14:59,600
a fundamental level the data is what

00:14:56,189 --> 00:14:59,600
you're operating on to produce a result

00:15:03,170 --> 00:15:07,829
Const creates a read-only reference to a

00:15:06,149 --> 00:15:09,420
value it does not mean the value of

00:15:07,829 --> 00:15:11,100
holds cannot change just that the

00:15:09,420 --> 00:15:13,319
identifier referencing value cannot be

00:15:11,100 --> 00:15:15,329
reassigned to a different value so this

00:15:13,319 --> 00:15:17,999
is better for primitive types like

00:15:15,329 --> 00:15:19,980
numbers and strings this effectively

00:15:17,999 --> 00:15:23,220
does provide immutability because you

00:15:19,980 --> 00:15:24,899
cannot modify those types anyway this is

00:15:23,220 --> 00:15:27,649
simple because we're not conflicting

00:15:24,899 --> 00:15:27,649
values in time

00:15:36,710 --> 00:15:42,110
to represent some information using

00:15:40,100 --> 00:15:44,810
objects as maps for key value records

00:15:42,110 --> 00:15:47,420
for values as simple because data is

00:15:44,810 --> 00:15:54,560
just data this is not braided together

00:15:47,420 --> 00:15:56,030
with anything but despite using const

00:15:54,560 --> 00:15:58,730
for a read-only reference to this map

00:15:56,030 --> 00:16:00,980
object objects as values are mutable and

00:15:58,730 --> 00:16:03,380
JavaScript this introduces a change of

00:16:00,980 --> 00:16:05,900
state by setting a new field so again

00:16:03,380 --> 00:16:12,860
this is conflicting time with values and

00:16:05,900 --> 00:16:15,380
it is complex a way to give around us in

00:16:12,860 --> 00:16:16,880
javascript is by using a library you can

00:16:15,380 --> 00:16:22,550
get immutable data structures and

00:16:16,880 --> 00:16:24,920
JavaScript this way with an immutable

00:16:22,550 --> 00:16:28,220
collection modifying the collection in

00:16:24,920 --> 00:16:30,800
any way returns a new value so after the

00:16:28,220 --> 00:16:33,110
last line here of confidence it both

00:16:30,800 --> 00:16:37,610
values persist as separate and isolated

00:16:33,110 --> 00:16:39,370
values the set call does not modify the

00:16:37,610 --> 00:16:41,660
value assigned to the comp reference

00:16:39,370 --> 00:16:43,220
immutable collections are simple because

00:16:41,660 --> 00:16:46,430
there are no conflicting of values in

00:16:43,220 --> 00:16:47,840
time immutable collections can also be

00:16:46,430 --> 00:16:49,880
used to do interesting things like time

00:16:47,840 --> 00:16:50,990
traveling debuggers which can show the

00:16:49,880 --> 00:16:52,460
state of values over the entire

00:16:50,990 --> 00:16:56,510
execution of the program because you

00:16:52,460 --> 00:16:58,190
never lose any changes this example is

00:16:56,510 --> 00:17:00,770
using a library called immutable from

00:16:58,190 --> 00:17:02,360
Facebook there is also a library called

00:17:00,770 --> 00:17:04,880
Morey from the closure community which

00:17:02,360 --> 00:17:06,890
is faster but immutable was used here as

00:17:04,880 --> 00:17:15,589
it has more support within JavaScript

00:17:06,890 --> 00:17:16,700
ecosystem so why immutability what do

00:17:15,589 --> 00:17:21,640
you have to do if you want to reproduce

00:17:16,700 --> 00:17:23,630
a bug in production or write a new test

00:17:21,640 --> 00:17:26,959
recreate the state of the program at

00:17:23,630 --> 00:17:28,580
that point in time because our software

00:17:26,959 --> 00:17:31,160
is operating a data there's a huge

00:17:28,580 --> 00:17:33,340
amount of state in our programs state is

00:17:31,160 --> 00:17:35,870
the source of the majority of complexity

00:17:33,340 --> 00:17:38,060
so using a mutable references and

00:17:35,870 --> 00:17:39,590
immutable collections can resolve a

00:17:38,060 --> 00:17:41,810
massive amount of the complexity in your

00:17:39,590 --> 00:17:44,030
software not only does it make your

00:17:41,810 --> 00:17:45,590
software easier to understand for some

00:17:44,030 --> 00:17:47,540
optimizations that are possible with

00:17:45,590 --> 00:17:49,370
frameworks like react it can be

00:17:47,540 --> 00:17:49,640
something like 50 times faster because

00:17:49,370 --> 00:17:54,550
of

00:17:49,640 --> 00:17:54,550
cheap chicks 24 changes to the data

00:18:01,620 --> 00:18:06,830
but what about memory usage if we keep

00:18:03,630 --> 00:18:09,630
all these versions of the data around

00:18:06,830 --> 00:18:11,640
modern mutable immutable collections

00:18:09,630 --> 00:18:14,760
like the immutable library is the

00:18:11,640 --> 00:18:16,230
feature called structural sharing for

00:18:14,760 --> 00:18:18,840
example this means that when you add an

00:18:16,230 --> 00:18:21,090
item to a collection the original is has

00:18:18,840 --> 00:18:23,430
not been changed but a new value is

00:18:21,090 --> 00:18:25,830
created with a reference to the original

00:18:23,430 --> 00:18:28,770
value and only the new item that has

00:18:25,830 --> 00:18:31,290
been added as stored in memory behind

00:18:28,770 --> 00:18:33,809
the scenes the data structures share

00:18:31,290 --> 00:18:35,130
common data between multiple values so

00:18:33,809 --> 00:18:36,929
you don't need to worry that this is

00:18:35,130 --> 00:18:38,730
costing a lot of memory or a lot of

00:18:36,929 --> 00:18:44,250
inefficiency in copying copying data

00:18:38,730 --> 00:18:48,809
around and memory does anyone know what

00:18:44,250 --> 00:18:52,980
this is no it's magnetic core memory

00:18:48,809 --> 00:18:55,320
that was used from 1955 until 1975 if

00:18:52,980 --> 00:18:57,630
you ever wondered with the term core

00:18:55,320 --> 00:18:59,700
dump for writing memory to a file came

00:18:57,630 --> 00:19:02,520
from it was originally used with core

00:18:59,700 --> 00:19:04,559
memory every ring you see is one bit of

00:19:02,520 --> 00:19:06,890
memory made from iron that had to be

00:19:04,559 --> 00:19:10,470
placed in that network of wires by hand

00:19:06,890 --> 00:19:13,530
but by bet it was woven on a loom each

00:19:10,470 --> 00:19:15,270
vet costs as much one as one dollar so

00:19:13,530 --> 00:19:18,450
by that measure my iphone has eight

00:19:15,270 --> 00:19:20,970
billion dollars of memory functional

00:19:18,450 --> 00:19:23,160
programming was invented in 1956 when

00:19:20,970 --> 00:19:25,800
this memory was on use so that time it

00:19:23,160 --> 00:19:27,210
was just too expensive the only reason

00:19:25,800 --> 00:19:28,380
we change locations in memory with

00:19:27,210 --> 00:19:30,660
mutable references and mutable

00:19:28,380 --> 00:19:32,670
collections is that we literally had to

00:19:30,660 --> 00:19:34,290
think about where and memory we would

00:19:32,670 --> 00:19:36,150
put something and then replace it when

00:19:34,290 --> 00:19:37,890
we didn't need it anymore because we

00:19:36,150 --> 00:19:41,400
didn't have enough available memory to

00:19:37,890 --> 00:19:43,160
use a new place and memory we don't have

00:19:41,400 --> 00:19:46,290
anything like these limitations anymore

00:19:43,160 --> 00:19:47,970
memory is plentiful cheap and fast so

00:19:46,290 --> 00:19:53,580
why we're using language decisions made

00:19:47,970 --> 00:19:55,380
for obsolete hardware let's look at an

00:19:53,580 --> 00:19:57,540
example that's a bit less trivial than

00:19:55,380 --> 00:19:59,610
storing simple values this is a

00:19:57,540 --> 00:20:01,380
sunflower a sub flowerheads follow the

00:19:59,610 --> 00:20:05,000
foot Bonacci sequence of numbers which

00:20:01,380 --> 00:20:05,000
is closely related to the golden ratio

00:20:06,140 --> 00:20:11,610
to get a Fibonacci number we start with

00:20:09,330 --> 00:20:13,860
two numbers one and one then each

00:20:11,610 --> 00:20:15,049
subsequent number as the previous two

00:20:13,860 --> 00:20:17,210
numbers added together

00:20:15,049 --> 00:20:19,669
so the first number is one the second

00:20:17,210 --> 00:20:21,320
number is 1 then 1 plus 1 is 2 for the

00:20:19,669 --> 00:20:26,749
third number and one plus two is three

00:20:21,320 --> 00:20:28,070
for the fourth number and so on this is

00:20:26,749 --> 00:20:30,710
a function that will get the info

00:20:28,070 --> 00:20:32,509
Bonacci number so if we want the fifth

00:20:30,710 --> 00:20:35,269
number would pacify them as the in

00:20:32,509 --> 00:20:37,610
argument not only is the state full as

00:20:35,269 --> 00:20:40,190
variables a changing state but loops

00:20:37,610 --> 00:20:43,070
also complex what you're doing with how

00:20:40,190 --> 00:20:44,809
to do it and the four definition it's

00:20:43,070 --> 00:20:47,149
checking if I is listening in on each

00:20:44,809 --> 00:20:49,759
step and incrementing I which is the

00:20:47,149 --> 00:20:51,679
iteration part and then inside the for

00:20:49,759 --> 00:20:55,190
loop the step part is calculating the

00:20:51,679 --> 00:20:56,629
value so loop represents conflicting

00:20:55,190 --> 00:20:58,909
different concerns and as a source of

00:20:56,629 --> 00:21:06,830
complexity could this be written so that

00:20:58,909 --> 00:21:09,489
is stateless and not using a loop it can

00:21:06,830 --> 00:21:12,590
be written this way it's not very useful

00:21:09,489 --> 00:21:15,159
to write it like this but no variables

00:21:12,590 --> 00:21:17,809
changing state and there is no looping

00:21:15,159 --> 00:21:19,820
also despite having no state branching

00:21:17,809 --> 00:21:21,980
complex with structure and organization

00:21:19,820 --> 00:21:26,350
in the program so branching is not

00:21:21,980 --> 00:21:26,350
actually simple there is a better way

00:21:28,090 --> 00:21:33,919
this is a recursive algorithm where thug

00:21:31,580 --> 00:21:37,100
calls itself until in as less than or

00:21:33,919 --> 00:21:39,919
equal to 2 then it will return one and

00:21:37,100 --> 00:21:42,259
stop calling itself no references change

00:21:39,919 --> 00:21:44,570
state new references are introduced with

00:21:42,259 --> 00:21:46,669
const but these are recreated every time

00:21:44,570 --> 00:21:49,369
functions called so if you call this

00:21:46,669 --> 00:21:50,600
function with 5 as the in value the

00:21:49,369 --> 00:21:52,039
lines at the bottom are the calls it

00:21:50,600 --> 00:21:54,889
will go through until is just adding

00:21:52,039 --> 00:21:56,869
ones together you can test the state of

00:21:54,889 --> 00:21:58,970
this function at any point simply by

00:21:56,869 --> 00:22:04,039
calling it with the right value for the

00:21:58,970 --> 00:22:06,859
in argument unfortunately until recently

00:22:04,039 --> 00:22:08,720
JavaScript recursion does not perform as

00:22:06,859 --> 00:22:11,629
well as there is overhead of creating

00:22:08,720 --> 00:22:16,789
stacks new stack context for erie

00:22:11,629 --> 00:22:18,669
function call in es2015 it is tail call

00:22:16,789 --> 00:22:21,529
optimization which will make this fast a

00:22:18,669 --> 00:22:24,679
tail call is when the very last thing

00:22:21,529 --> 00:22:27,350
the function does before returning as a

00:22:24,679 --> 00:22:27,879
recursive call to itself so this verb

00:22:27,350 --> 00:22:30,190
function

00:22:27,879 --> 00:22:32,949
is not optimized herbal because after

00:22:30,190 --> 00:22:34,659
calling itself it calls itself again so

00:22:32,949 --> 00:22:36,039
it's doing something else after it calls

00:22:34,659 --> 00:22:42,069
itself the first time in the return

00:22:36,039 --> 00:22:44,469
statement so let's rewrite the recursive

00:22:42,069 --> 00:22:47,199
function slightly so that there is just

00:22:44,469 --> 00:22:51,789
one recursive call and the return

00:22:47,199 --> 00:22:54,609
statement this is now a tail call the

00:22:51,789 --> 00:22:56,669
very last thing in the function is doing

00:22:54,609 --> 00:22:58,929
before returning is calling itself at

00:22:56,669 --> 00:23:01,539
this point why do we need to allocate

00:22:58,929 --> 00:23:04,389
more stack space the current invocation

00:23:01,539 --> 00:23:06,819
of the function will never need the spec

00:23:04,389 --> 00:23:08,829
space again as soon as it receives a

00:23:06,819 --> 00:23:11,559
value from the recursive call it will

00:23:08,829 --> 00:23:13,809
return to the caller so instead of

00:23:11,559 --> 00:23:15,759
allocating stack space we could simply

00:23:13,809 --> 00:23:17,919
reuse the stake space used by the

00:23:15,759 --> 00:23:20,139
current function invocation and inherit

00:23:17,919 --> 00:23:22,299
the return address which will return the

00:23:20,139 --> 00:23:24,719
Fibonacci number in the latest

00:23:22,299 --> 00:23:27,759
JavaScript engines putting ears 2015

00:23:24,719 --> 00:23:30,419
telco optimizations will make this fast

00:23:27,759 --> 00:23:30,419
and efficient

00:23:35,120 --> 00:23:39,840
so functions have a concept of purity

00:23:38,070 --> 00:23:42,540
and functional programming we say a

00:23:39,840 --> 00:23:45,090
function is impure if it causes state to

00:23:42,540 --> 00:23:47,460
change outside of the scope of itself

00:23:45,090 --> 00:23:49,650
this is also referred to as side effects

00:23:47,460 --> 00:23:52,110
because there is an effect outside of

00:23:49,650 --> 00:23:54,030
the scope of the function and pure

00:23:52,110 --> 00:23:56,460
functions are complex because yet again

00:23:54,030 --> 00:23:59,100
there's conflicting values in time over

00:23:56,460 --> 00:24:00,720
your program but you see the style of

00:23:59,100 --> 00:24:03,590
mutating outer scope variables all the

00:24:00,720 --> 00:24:03,590
time in JavaScript

00:24:09,210 --> 00:24:15,929
conversely a pure function only takes

00:24:12,450 --> 00:24:18,480
arguments and returns values it does not

00:24:15,929 --> 00:24:20,340
modify any other script state pure

00:24:18,480 --> 00:24:22,230
functions are easy to test in isolation

00:24:20,340 --> 00:24:24,299
because you only need to provide

00:24:22,230 --> 00:24:26,669
arguments to test the result there's not

00:24:24,299 --> 00:24:29,580
some otoscope state to set up and check

00:24:26,669 --> 00:24:33,649
and obviously pure functions don't

00:24:29,580 --> 00:24:33,649
complete time with values so simple so

00:24:36,230 --> 00:24:41,070
without loops and modifying values how

00:24:39,510 --> 00:24:43,980
do you convert one collection of values

00:24:41,070 --> 00:24:45,510
into another collection of values one of

00:24:43,980 --> 00:24:48,240
the most fundamental functions and

00:24:45,510 --> 00:24:50,190
functional programming is map which is

00:24:48,240 --> 00:24:52,260
used to convert one collection and to a

00:24:50,190 --> 00:24:54,860
related one by running the same function

00:24:52,260 --> 00:24:57,510
against each member of the collection

00:24:54,860 --> 00:24:59,669
any function that takes a function as an

00:24:57,510 --> 00:25:01,860
argument or returns a function as a

00:24:59,669 --> 00:25:05,390
return value as known as a higher-order

00:25:01,860 --> 00:25:07,799
function in general so in this example

00:25:05,390 --> 00:25:09,330
double is a function that is passed to

00:25:07,799 --> 00:25:12,570
the map function to run against each

00:25:09,330 --> 00:25:15,419
number this is simpler than loops

00:25:12,570 --> 00:25:19,919
because it does not conflict what you

00:25:15,419 --> 00:25:21,899
are doing with how to do it I put

00:25:19,919 --> 00:25:25,350
simpler with an R here because it's not

00:25:21,899 --> 00:25:27,029
as simple as it could be first I could

00:25:25,350 --> 00:25:29,210
be using immutable collections instead

00:25:27,029 --> 00:25:32,070
of the JavaScript mutable arrays in maps

00:25:29,210 --> 00:25:34,679
second I'll talk later about how common

00:25:32,070 --> 00:25:36,210
collection functions like map complete

00:25:34,679 --> 00:25:38,429
to the inputs and the outputs of the

00:25:36,210 --> 00:25:44,610
data with the steps or transformations

00:25:38,429 --> 00:25:46,500
you're performing on the data produce is

00:25:44,610 --> 00:25:48,870
a more general higher-order function for

00:25:46,500 --> 00:25:51,830
collections then map allows you to

00:25:48,870 --> 00:25:54,450
produce any new value from a collection

00:25:51,830 --> 00:25:58,110
so each invocation of the add function

00:25:54,450 --> 00:26:00,059
receives the value so far and returns

00:25:58,110 --> 00:26:02,130
the new value that would be passed into

00:26:00,059 --> 00:26:04,649
the next invocation of the add function

00:26:02,130 --> 00:26:08,360
in this way a value is built up over

00:26:04,649 --> 00:26:08,360
each member of the collection

00:26:12,760 --> 00:26:16,670
filter is another example of a common

00:26:15,320 --> 00:26:18,830
higher-order function for collections

00:26:16,670 --> 00:26:20,990
they will produce a new collection with

00:26:18,830 --> 00:26:23,930
any items that do not pass a truth test

00:26:20,990 --> 00:26:25,400
removed that as even function will be

00:26:23,930 --> 00:26:28,220
invoked for each member of the

00:26:25,400 --> 00:26:29,390
collection and if it returns false the

00:26:28,220 --> 00:26:31,070
member will be removed from the

00:26:29,390 --> 00:26:33,460
collection returned by the filter

00:26:31,070 --> 00:26:33,460
function

00:26:41,530 --> 00:26:46,180
I want to make special mention of for

00:26:43,720 --> 00:26:49,090
each here which is technically a higher

00:26:46,180 --> 00:26:50,920
order function for collections because

00:26:49,090 --> 00:26:53,650
it takes a step function as an argument

00:26:50,920 --> 00:26:55,450
for each is basically a loop with a step

00:26:53,650 --> 00:26:58,300
defined as a function because there's no

00:26:55,450 --> 00:27:00,700
output value because there's no output

00:26:58,300 --> 00:27:02,830
value the only user can have as an

00:27:00,700 --> 00:27:05,980
impure step function that changes state

00:27:02,830 --> 00:27:07,540
or has side effects so the only possible

00:27:05,980 --> 00:27:09,580
valid use of this is pressed with

00:27:07,540 --> 00:27:11,830
debugging or intentional side effects if

00:27:09,580 --> 00:27:13,780
you can't do it another way and it's

00:27:11,830 --> 00:27:16,090
definitely simpler to use reduce fill to

00:27:13,780 --> 00:27:20,230
a map or some of the functions for

00:27:16,090 --> 00:27:27,820
working with transforming collections so

00:27:20,230 --> 00:27:30,730
this is complex methods actually like

00:27:27,820 --> 00:27:33,760
stateful functions most of the time but

00:27:30,730 --> 00:27:35,610
even if methods on classes and instances

00:27:33,760 --> 00:27:38,050
do not mutate any state object

00:27:35,610 --> 00:27:41,650
orientation complex a lot of things a

00:27:38,050 --> 00:27:43,780
complex state identity values methods

00:27:41,650 --> 00:27:46,180
complete functions state and namespaces

00:27:43,780 --> 00:27:47,800
this is claimed to be required to

00:27:46,180 --> 00:27:50,050
encapsulate the data with its

00:27:47,800 --> 00:27:52,060
implementation but latitude and

00:27:50,050 --> 00:27:54,070
longitude here in this example are just

00:27:52,060 --> 00:27:56,740
data what implementation do they

00:27:54,070 --> 00:27:58,240
actually have and reality this is

00:27:56,740 --> 00:28:01,600
braiding together the operations on the

00:27:58,240 --> 00:28:03,850
data with the data itself object

00:28:01,600 --> 00:28:06,640
orientation in general is very complex I

00:28:03,850 --> 00:28:08,560
agree with GK leave earlier who said

00:28:06,640 --> 00:28:11,500
their classes are not necessarily always

00:28:08,560 --> 00:28:13,090
bad that's how you use them it's just

00:28:11,500 --> 00:28:15,340
the most common use of classes for

00:28:13,090 --> 00:28:17,590
encapsulating data has promoted as good

00:28:15,340 --> 00:28:19,780
practice as part of object orientated

00:28:17,590 --> 00:28:22,770
programming but I think this is obsolete

00:28:19,780 --> 00:28:22,770
and complex

00:28:27,450 --> 00:28:32,789
why not just use data as values and

00:28:30,169 --> 00:28:34,559
namespaces of pure functions this is

00:28:32,789 --> 00:28:36,690
easier to test and easier to reason

00:28:34,559 --> 00:28:38,730
about this is simple because there's no

00:28:36,690 --> 00:28:42,440
conflicting of state identity values and

00:28:38,730 --> 00:28:42,440
namespaces lock with object orientation

00:28:54,470 --> 00:28:59,640
there's also feature and functional

00:28:56,909 --> 00:29:02,130
programming called Korean unfortunately

00:28:59,640 --> 00:29:05,789
it's not as yummy as curry in real life

00:29:02,130 --> 00:29:08,220
but it was very useful it's named after

00:29:05,789 --> 00:29:10,289
the person who created it from a

00:29:08,220 --> 00:29:11,789
different programming language so the

00:29:10,289 --> 00:29:18,179
naming has no relation whatsoever to

00:29:11,789 --> 00:29:20,340
what it actually does carrying is the

00:29:18,179 --> 00:29:22,710
process of converting functions that

00:29:20,340 --> 00:29:24,570
take more than one argument and two ones

00:29:22,710 --> 00:29:26,820
that when supplied with fewer the

00:29:24,570 --> 00:29:29,159
arguments then they require will return

00:29:26,820 --> 00:29:32,399
new functions that accept the remaining

00:29:29,159 --> 00:29:37,710
arguments so in this example if is a

00:29:32,399 --> 00:29:42,120
function that is already has a set a to

00:29:37,710 --> 00:29:45,179
1 so that when we call F with 2 we get

00:29:42,120 --> 00:29:47,159
the result of 1 plus 2 carrying is

00:29:45,179 --> 00:29:49,860
simple because it enables us to untwist

00:29:47,159 --> 00:29:51,510
or unbraid applying arguments from

00:29:49,860 --> 00:29:53,580
function and vacation so you can do

00:29:51,510 --> 00:29:55,169
these two things separately whereas with

00:29:53,580 --> 00:29:57,200
normal function invocation you have to

00:29:55,169 --> 00:29:59,220
provide all the arguments that cool time

00:29:57,200 --> 00:30:01,200
different versions of currying work

00:29:59,220 --> 00:30:02,760
slightly differently but in the ram

00:30:01,200 --> 00:30:04,590
dealer library implementation you can

00:30:02,760 --> 00:30:07,710
pass any number of arguments at any time

00:30:04,590 --> 00:30:09,149
to the curried function when the total

00:30:07,710 --> 00:30:10,529
arguments past have not reached the

00:30:09,149 --> 00:30:12,899
required number you'll get back a new

00:30:10,529 --> 00:30:14,399
function if you reach or exceed the

00:30:12,899 --> 00:30:18,179
number of arguments you'll get back the

00:30:14,399 --> 00:30:19,889
final result users of more advanced

00:30:18,179 --> 00:30:21,570
functional languages will insist this is

00:30:19,889 --> 00:30:23,730
not carrying but something called

00:30:21,570 --> 00:30:25,559
partial application that is partially

00:30:23,730 --> 00:30:27,840
applying function arguments to the

00:30:25,559 --> 00:30:31,039
function but for us i think that serves

00:30:27,840 --> 00:30:31,039
the role of carrying just fine

00:30:36,179 --> 00:30:41,129
compose as a function that can join

00:30:39,549 --> 00:30:43,960
functions together into a new function

00:30:41,129 --> 00:30:46,419
so in this example calling if is the

00:30:43,960 --> 00:30:50,230
same as calling power then the gate and

00:30:46,419 --> 00:30:52,779
then increment on the values composed as

00:30:50,230 --> 00:30:54,340
simple because enable us enables us to

00:30:52,779 --> 00:30:56,710
remove braiding between using the

00:30:54,340 --> 00:30:58,869
behavior of multiple functions together

00:30:56,710 --> 00:31:01,960
as a named reference from the actual

00:30:58,869 --> 00:31:03,159
function invocation so we can join these

00:31:01,960 --> 00:31:06,330
functions together and give it a

00:31:03,159 --> 00:31:06,330
reference and then call it later

00:31:14,760 --> 00:31:20,140
this is commonly done in web browsers in

00:31:17,770 --> 00:31:24,850
JavaScript it past callbacks to event

00:31:20,140 --> 00:31:26,980
handlers to do something in relation to

00:31:24,850 --> 00:31:29,649
the mouse moving or someone clicking a

00:31:26,980 --> 00:31:31,929
button passing callbacks event handlers

00:31:29,649 --> 00:31:34,270
as completing the producer and the

00:31:31,929 --> 00:31:38,440
consumer of events as the producer is

00:31:34,270 --> 00:31:42,450
the document that's firing the mouse

00:31:38,440 --> 00:31:45,070
move in and the consumer is the callback

00:31:42,450 --> 00:31:47,230
so there's this massive web of direct

00:31:45,070 --> 00:31:49,779
relationships between the things that

00:31:47,230 --> 00:31:51,429
produce events and the listeners it

00:31:49,779 --> 00:31:53,289
creates fragmented logic there's

00:31:51,429 --> 00:31:55,570
difficult to reason about or control the

00:31:53,289 --> 00:31:57,429
flow of it's also conflicting the

00:31:55,570 --> 00:31:59,770
asynchronous or synchronous nature of

00:31:57,429 --> 00:32:02,559
the event source with the consumer logic

00:31:59,770 --> 00:32:07,450
the consumer logic is directly bound to

00:32:02,559 --> 00:32:09,960
the asynchronous asing recently so this

00:32:07,450 --> 00:32:09,960
is complex

00:32:14,620 --> 00:32:20,150
communicating sequential processes or

00:32:17,630 --> 00:32:23,049
CSP for short as a model that D braids

00:32:20,150 --> 00:32:25,760
event producers from event consumers and

00:32:23,049 --> 00:32:28,340
allows intermediary transformations as

00:32:25,760 --> 00:32:30,289
functions it was originally introduced

00:32:28,340 --> 00:32:32,240
in the go language then put it to

00:32:30,289 --> 00:32:34,760
closure and then put it to JavaScript

00:32:32,240 --> 00:32:36,650
this allows you not to be concerned

00:32:34,760 --> 00:32:39,530
about the source of data or for as

00:32:36,650 --> 00:32:41,450
asynchronous or synchronous these are

00:32:39,530 --> 00:32:43,850
basically multi reader multi writer

00:32:41,450 --> 00:32:47,809
message queues so you can pass the

00:32:43,850 --> 00:32:51,650
endpoints around as values put events on

00:32:47,809 --> 00:32:53,600
to the endpoints the inputs do some

00:32:51,650 --> 00:32:58,549
logical transformations in between and

00:32:53,600 --> 00:33:00,980
take events out I'm not going to go

00:32:58,549 --> 00:33:02,600
through CSP and detail as that would be

00:33:00,980 --> 00:33:08,480
a whole talk in itself but I will

00:33:02,600 --> 00:33:11,720
provide a short example this function

00:33:08,480 --> 00:33:14,900
given a Dom element a name of an event

00:33:11,720 --> 00:33:18,860
type and a CSP channel will put the Dom

00:33:14,900 --> 00:33:21,669
events on to the CSP channel so this is

00:33:18,860 --> 00:33:21,669
an event producer

00:33:29,170 --> 00:33:34,150
so for this example I'm going to use

00:33:31,270 --> 00:33:36,730
mouse events so we can filter to only

00:33:34,150 --> 00:33:39,280
consume Mouse events that are on even

00:33:36,730 --> 00:33:41,620
pixels on the page and I don't want to

00:33:39,280 --> 00:33:43,540
deal with this complex event object are

00:33:41,620 --> 00:33:45,460
just like a simple vector of the x and y

00:33:43,540 --> 00:33:47,410
coordinates so we can use a mapping

00:33:45,460 --> 00:33:49,650
function to transform each event and to

00:33:47,410 --> 00:33:49,650
array

00:34:03,500 --> 00:34:09,440
finally I can use a recursive loop to

00:34:06,590 --> 00:34:11,990
take events from the cs p-channel so

00:34:09,440 --> 00:34:14,990
this is an event consumer and print them

00:34:11,990 --> 00:34:16,639
to the JavaScript console so you can see

00:34:14,990 --> 00:34:18,950
that as a mouse would be moving around

00:34:16,639 --> 00:34:20,450
on the screen each filtered and

00:34:18,950 --> 00:34:23,360
transformed event would be printed to

00:34:20,450 --> 00:34:25,639
the console this is probably more lines

00:34:23,360 --> 00:34:27,370
of code than the event Kovac example but

00:34:25,639 --> 00:34:29,780
it's about the lack of interleaving

00:34:27,370 --> 00:34:31,520
being able to understand and test these

00:34:29,780 --> 00:34:33,909
things in isolation not the number of

00:34:31,520 --> 00:34:33,909
lines of code

00:34:40,700 --> 00:34:44,800
in real life if we want to take some

00:34:42,919 --> 00:34:46,940
luggage there's going on or off a plane

00:34:44,800 --> 00:34:49,220
remove the bags that contain bombs

00:34:46,940 --> 00:34:51,679
because bombs are not cool then label

00:34:49,220 --> 00:34:54,500
the bags with a barcode removing bombs

00:34:51,679 --> 00:34:56,960
is like a filter function and applying

00:34:54,500 --> 00:34:58,670
labels as like the mapping function it

00:34:56,960 --> 00:35:01,339
transforming the bag by putting a label

00:34:58,670 --> 00:35:05,060
on it in real life the instructions for

00:35:01,339 --> 00:35:07,490
removing bombs contain or bomb

00:35:05,060 --> 00:35:09,890
containing bags and labeling bags with

00:35:07,490 --> 00:35:13,099
barcodes don't care about if the bags

00:35:09,890 --> 00:35:15,079
come from a conveyor belt or trailer the

00:35:13,099 --> 00:35:16,700
bomb dog doesn't say oh man that bag

00:35:15,079 --> 00:35:18,260
came from a trailer and I'm only used to

00:35:16,700 --> 00:35:21,260
conveyor belts I just don't want to do

00:35:18,260 --> 00:35:23,930
with that the collection functions like

00:35:21,260 --> 00:35:25,369
Map Reduce and filter that I showed

00:35:23,930 --> 00:35:27,230
earlier actually have some remaining

00:35:25,369 --> 00:35:29,119
complexity and that they're tightly

00:35:27,230 --> 00:35:32,210
interleaved with the type of input and

00:35:29,119 --> 00:35:34,339
outputs for example I might expect to

00:35:32,210 --> 00:35:38,960
get data synchronously from an array and

00:35:34,339 --> 00:35:40,180
provide results as an array you know but

00:35:38,960 --> 00:35:43,190
what if i want to get data

00:35:40,180 --> 00:35:46,579
asynchronously from a CSP channel and

00:35:43,190 --> 00:35:47,930
provide results as an array you know i

00:35:46,579 --> 00:35:50,630
have to rewrite all my code again

00:35:47,930 --> 00:35:52,460
because the input has changed and then

00:35:50,630 --> 00:35:56,180
again for every possible combination of

00:35:52,460 --> 00:35:57,920
inputs and outputs so there are these

00:35:56,180 --> 00:35:59,720
things invented by rich ricci enclosure

00:35:57,920 --> 00:36:02,829
that were subsequently ported to

00:35:59,720 --> 00:36:05,420
javascript called transducers a

00:36:02,829 --> 00:36:08,500
transducer is a function that can

00:36:05,420 --> 00:36:10,700
operate on data collections or streams

00:36:08,500 --> 00:36:14,780
independent of the types of the sources

00:36:10,700 --> 00:36:16,760
and outputs they specify only the

00:36:14,780 --> 00:36:19,280
transformation in terms of a single

00:36:16,760 --> 00:36:22,069
element they don't care where it comes

00:36:19,280 --> 00:36:24,319
from or where it goes I'll show some

00:36:22,069 --> 00:36:25,640
examples but again I can't go into them

00:36:24,319 --> 00:36:30,890
in detail as that would be an entire

00:36:25,640 --> 00:36:32,510
talk so you can use transducers with

00:36:30,890 --> 00:36:35,900
immutable collections from the immutable

00:36:32,510 --> 00:36:38,060
library that I showed earlier and much

00:36:35,900 --> 00:36:40,339
like their original higher-order

00:36:38,060 --> 00:36:43,250
functions I showed earlier apply some

00:36:40,339 --> 00:36:44,900
map and filter transformations so in

00:36:43,250 --> 00:36:47,930
this example map and filter are

00:36:44,900 --> 00:36:49,430
transducers that are composable with the

00:36:47,930 --> 00:36:51,770
function composition

00:36:49,430 --> 00:36:53,540
that I also showed earlier and the

00:36:51,770 --> 00:36:56,440
resulting function can be used with any

00:36:53,540 --> 00:36:58,970
type of inputs and any type of outputs

00:36:56,440 --> 00:37:00,980
so you can even reference the exact same

00:36:58,970 --> 00:37:04,160
code you don't need to copy and paste or

00:37:00,980 --> 00:37:06,920
rewrite it in any way a relevant of

00:37:04,160 --> 00:37:08,510
where we are using it this is quite a

00:37:06,920 --> 00:37:10,490
high level of abstraction so it can be

00:37:08,510 --> 00:37:12,890
difficult to understand at first but it

00:37:10,490 --> 00:37:14,660
is extremely simple we've got into the

00:37:12,890 --> 00:37:19,720
essence of map and filter which is to

00:37:14,660 --> 00:37:19,720
apply a step to transform an item

00:37:27,579 --> 00:37:32,019
so yeah the interesting part is you can

00:37:29,859 --> 00:37:34,029
use those exact functions that were just

00:37:32,019 --> 00:37:35,739
used with immutable collection even

00:37:34,029 --> 00:37:37,779
direct references to the same code to

00:37:35,739 --> 00:37:40,900
transform an asynchronous CSP channel as

00:37:37,779 --> 00:37:42,430
well it doesn't matter that it's a

00:37:40,900 --> 00:37:45,599
synchronous it doesn't matter with

00:37:42,430 --> 00:37:45,599
different data source

00:37:51,460 --> 00:37:55,660
so I certainly didn't cover everything

00:37:53,440 --> 00:37:58,150
all the possible techniques or concepts

00:37:55,660 --> 00:37:59,920
within the subject I hope it has been

00:37:58,150 --> 00:38:02,380
demonstrated that if you look at

00:37:59,920 --> 00:38:04,960
javascript code objectively there are

00:38:02,380 --> 00:38:07,210
simple ways to write things that are not

00:38:04,960 --> 00:38:08,620
interleaved and there are complex ways

00:38:07,210 --> 00:38:11,830
to write things that are braided

00:38:08,620 --> 00:38:14,590
together functional programming features

00:38:11,830 --> 00:38:16,510
can achieve code more closely tied to

00:38:14,590 --> 00:38:18,280
the actual problem domain with

00:38:16,510 --> 00:38:21,550
straightforward unit testing and easier

00:38:18,280 --> 00:38:24,070
debugging do you want to build a lego

00:38:21,550 --> 00:38:26,860
castle as on the left or a knitted

00:38:24,070 --> 00:38:28,900
castle like on the right ask yourself

00:38:26,860 --> 00:38:30,240
which way is going to help you impact

00:38:28,900 --> 00:38:41,080
the most positive change in the world

00:38:30,240 --> 00:38:44,260
Thank you Thank You Rosie thank you I

00:38:41,080 --> 00:38:48,880
just want to ask Allah someone has been

00:38:44,260 --> 00:38:52,000
asked about I stairs or CSP which one is

00:38:48,880 --> 00:38:56,110
better since they are all tagged to

00:38:52,000 --> 00:38:58,390
manually to the event stream so i have a

00:38:56,110 --> 00:39:02,080
herd of a surgical chair also my

00:38:58,390 --> 00:39:04,060
question too so that's a really good

00:39:02,080 --> 00:39:05,980
question the question is what's the

00:39:04,060 --> 00:39:08,680
difference between eric's jayus like

00:39:05,980 --> 00:39:13,000
assume bacon juice in the libraries and

00:39:08,680 --> 00:39:16,660
CSP a tough question answer in a short

00:39:13,000 --> 00:39:20,830
time but there are known cases where r x

00:39:16,660 --> 00:39:23,650
JS doesn't cover things well that you

00:39:20,830 --> 00:39:25,450
can do in CSP i'll have to show some

00:39:23,650 --> 00:39:30,270
code examples to be more clear but i'm

00:39:25,450 --> 00:39:32,330
happy to put those up with my slides

00:39:30,270 --> 00:39:32,330

YouTube URL: https://www.youtube.com/watch?v=lejV59XtPAE


