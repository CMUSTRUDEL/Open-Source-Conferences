Title: Ryan J Salva: JS performance in mobile web and hybrid apps… because science! - JSConf.Asia 2015
Publication date: 2015-12-10
Playlist: JSConf.Asia 2015
Description: 
	In the last few years, PhoneGap and Apache Cordova have gained a lot of traction among mobile app developers. Using a shared codebase, JavaScript developers can build apps for iOS, Android and Windows using the same frameworks they use for the web. But mobile apps carry a different set of user expectations. Users expect ""native performance"" – i.e. slick animations, fluid page transitions, snappy load times and instant visual feedback for user interactions. I've talked with developers building some of the most popular control frameworks (e.g. Ionic, Famo.us) to learn how they think about building performance into hybrid apps. In this session, we'll learn from their experience and chase this elusive rabbit with all the tools at our disposal. We'll answer: 

1. By the numbers, what really constitutes "native performance"? 
2. What pitfalls lead to poor JS performance in hybrid apps?
3. How can you avoid the most common performance pitfalls? 
4. How can you use diagnostic tools to identify problems in your apps? 
5. What design tricks can you use to get that authentic "native look-and-feel?

JavaScript developer, Apache Cordova committer, Visual Studio product manager, CrossFitter, sci-fi connoisseur and whiskey enthusiast. With over a decade of experience in software development, you could exhaust two Scrabble™ bags accounting for all the acronyms and technologies Ryan has influenced, but the important thing to know is this: Ryan is a passionate storyteller with deep insight into market forces, technology, user experience and design. Today, he owns tooling for cross-platform app development at Microsoft. Tomorrow, the world.

JSConf.Asia - Red Dot Design Museum, Singapore - 19 November 2015.

Source: http://2015.jsconf.asia
Slides: http://www.slideshare.net/RyanJSalva/the-real-story-behind-javascript-performance-on-mobile-because-science

License: For reuse of this video under a more permissive license please get in touch with us. The speakers retain the copyright for their performances.
Captions: 
	00:00:01,080 --> 00:00:11,490
[Music]

00:00:08,429 --> 00:00:14,309
so hi my name is Ryan J Salva I am a

00:00:11,490 --> 00:00:17,160
product manager on the visual studio

00:00:14,309 --> 00:00:20,640
team I'm also a JavaScript developer of

00:00:17,160 --> 00:00:23,310
about 15 years and a committer to the

00:00:20,640 --> 00:00:25,859
Apache Cordova project today I'm gonna

00:00:23,310 --> 00:00:27,720
take the next 30 minutes or so to talk

00:00:25,859 --> 00:00:30,119
to you a little bit about performance

00:00:27,720 --> 00:00:32,579
and a lot of the lessons that I talk

00:00:30,119 --> 00:00:34,800
about today will apply to Cordova but

00:00:32,579 --> 00:00:37,530
they apply equally well to the mobile

00:00:34,800 --> 00:00:40,500
web and so really this is just gonna be

00:00:37,530 --> 00:00:42,239
a a tour of a bunch of science that

00:00:40,500 --> 00:00:43,980
we've conducted and I mean that like

00:00:42,239 --> 00:00:46,350
science with a capital S really

00:00:43,980 --> 00:00:49,860
important science to better understand

00:00:46,350 --> 00:00:51,300
how exactly per Forks for mobile

00:00:49,860 --> 00:00:54,149
applications when they're using web

00:00:51,300 --> 00:00:56,160
technologies sound like a good time yeah

00:00:54,149 --> 00:00:59,399
sounds like a good time awesome all

00:00:56,160 --> 00:01:00,870
right sweet so hey if along this you

00:00:59,399 --> 00:01:03,180
learn anything that you didn't know

00:01:00,870 --> 00:01:05,220
before use the hash tag perf matters on

00:01:03,180 --> 00:01:09,000
Twitter and share it with your friends

00:01:05,220 --> 00:01:12,210
because science is everyone's awesome

00:01:09,000 --> 00:01:13,920
thing to learn all right so like I said

00:01:12,210 --> 00:01:15,869
before the lessons we learned today are

00:01:13,920 --> 00:01:18,869
gonna apply equally well between hybrid

00:01:15,869 --> 00:01:20,310
applications in mobile web and just a

00:01:18,869 --> 00:01:21,780
kind of level set I want to make sure

00:01:20,310 --> 00:01:23,880
that everyone understands when I talk

00:01:21,780 --> 00:01:27,030
about hybrid applications what I'm

00:01:23,880 --> 00:01:29,729
really talking about here so this is the

00:01:27,030 --> 00:01:31,320
primary technology is Cordova most

00:01:29,729 --> 00:01:36,150
people know what Cordova is or PhoneGap

00:01:31,320 --> 00:01:39,630
yeah yeah yar okay good excellent so the

00:01:36,150 --> 00:01:42,030
basic idea behind it is that Cordova its

00:01:39,630 --> 00:01:44,009
core is a web application that sits

00:01:42,030 --> 00:01:47,159
inside of a webview inside of a native

00:01:44,009 --> 00:01:48,990
application and as a web application all

00:01:47,159 --> 00:01:53,009
of the HTML the CSS and the JavaScript

00:01:48,990 --> 00:01:55,950
are packaged locally but they kind of

00:01:53,009 --> 00:01:58,290
talk back to native api's whether it be

00:01:55,950 --> 00:02:00,240
the camera API or the address book or

00:01:58,290 --> 00:02:02,219
the accelerometer through these

00:02:00,240 --> 00:02:04,890
asynchronous calls that bridge the

00:02:02,219 --> 00:02:06,659
webview and talk back to native code the

00:02:04,890 --> 00:02:08,520
brilliant thing about this is that it

00:02:06,659 --> 00:02:10,140
kind of gives you like a browser on

00:02:08,520 --> 00:02:11,640
steroids you get access to all these

00:02:10,140 --> 00:02:13,390
native api's that you wouldn't have

00:02:11,640 --> 00:02:15,070
access to otherwise

00:02:13,390 --> 00:02:16,960
and you get support for offline by

00:02:15,070 --> 00:02:18,850
virtue of the fact that all of that HTML

00:02:16,960 --> 00:02:21,160
CSS and JavaScript have been packaged

00:02:18,850 --> 00:02:24,940
locally so that's the basic architecture

00:02:21,160 --> 00:02:27,520
and we're gonna kind of use that to

00:02:24,940 --> 00:02:29,800
explore like there's this perception

00:02:27,520 --> 00:02:32,950
there's this general kind of ickiness

00:02:29,800 --> 00:02:34,810
this feeling that web applications and

00:02:32,950 --> 00:02:37,840
hybrid applications when compared to

00:02:34,810 --> 00:02:40,120
native applications don't quite stand up

00:02:37,840 --> 00:02:42,730
they don't really cut the butter as it

00:02:40,120 --> 00:02:44,490
were and so in the next 30 minutes we're

00:02:42,730 --> 00:02:50,560
gonna try and dispel some of those myths

00:02:44,490 --> 00:02:52,239
using science all right to understand

00:02:50,560 --> 00:02:54,400
performance you first need to understand

00:02:52,239 --> 00:02:56,320
what it actually means to be fast and

00:02:54,400 --> 00:02:57,640
responsive so here's what I want you

00:02:56,320 --> 00:02:59,140
guys to do here's how I want you to

00:02:57,640 --> 00:03:00,940
think about it I got a nice little graph

00:02:59,140 --> 00:03:02,800
here and there's lots of different

00:03:00,940 --> 00:03:04,420
flavors and versions of this graph that

00:03:02,800 --> 00:03:06,310
you might have seen online I think I

00:03:04,420 --> 00:03:08,500
stole this one from the Nielsen Norman

00:03:06,310 --> 00:03:11,140
group and they probably created this

00:03:08,500 --> 00:03:13,540
back in 1995 or something like that

00:03:11,140 --> 00:03:15,640
but I've actually expanded it to put

00:03:13,540 --> 00:03:17,950
some real millisecond measurements on

00:03:15,640 --> 00:03:20,049
this so in the far left hand side that's

00:03:17,950 --> 00:03:23,140
17 milliseconds everything that's under

00:03:20,049 --> 00:03:25,000
fluid that's really not about user

00:03:23,140 --> 00:03:26,980
interaction with your app but that's

00:03:25,000 --> 00:03:29,380
about the way that your app moves

00:03:26,980 --> 00:03:32,590
that's about animations being fluid

00:03:29,380 --> 00:03:35,200
transitions kind of silky smooth flowing

00:03:32,590 --> 00:03:38,140
through right and if you do the math

00:03:35,200 --> 00:03:40,750
that 17 milliseconds actually calculates

00:03:38,140 --> 00:03:42,580
out to be 60 frames per second that's

00:03:40,750 --> 00:03:44,980
what that's about getting that magical

00:03:42,580 --> 00:03:47,620
60 frames per second just to the right

00:03:44,980 --> 00:03:49,510
of that instantaneous okay this is when

00:03:47,620 --> 00:03:51,489
you're actually got your finger on the

00:03:49,510 --> 00:03:54,040
mobile device you're dragging it around

00:03:51,489 --> 00:03:55,690
and the object actually sticks to your

00:03:54,040 --> 00:03:57,549
finger so this is really important to

00:03:55,690 --> 00:03:59,080
make sure that like you actually feel

00:03:57,549 --> 00:04:02,019
like you're in control of the

00:03:59,080 --> 00:04:05,170
application beyond that actions which

00:04:02,019 --> 00:04:08,320
are fast these are maybe like navigation

00:04:05,170 --> 00:04:10,930
events going from one particular page to

00:04:08,320 --> 00:04:13,959
the next loading a new view beyond that

00:04:10,930 --> 00:04:15,549
everything to the right buddy if if

00:04:13,959 --> 00:04:17,380
you've got something that takes that

00:04:15,549 --> 00:04:19,630
long to react you better be throwing up

00:04:17,380 --> 00:04:22,030
a spinner or something like that to let

00:04:19,630 --> 00:04:25,360
people know that work is being done in

00:04:22,030 --> 00:04:27,130
the background for this talk for the

00:04:25,360 --> 00:04:28,990
next 20 30 minutes or so what

00:04:27,130 --> 00:04:31,480
we care about is everything on that

00:04:28,990 --> 00:04:33,250
right-hand side that far right-hand side

00:04:31,480 --> 00:04:35,640
what we care about actually for you guys

00:04:33,250 --> 00:04:38,440
wait that's left that's your left okay

00:04:35,640 --> 00:04:40,630
our left-hand side from your left hand

00:04:38,440 --> 00:04:43,450
side we care about fluid and

00:04:40,630 --> 00:04:45,700
instantaneous because frankly everything

00:04:43,450 --> 00:04:50,980
on the right hand side of that there's

00:04:45,700 --> 00:04:52,630
no question that JavaScript CSS HTML are

00:04:50,980 --> 00:04:57,370
capable of delivering that kind of

00:04:52,630 --> 00:05:00,610
performance right so what is the

00:04:57,370 --> 00:05:03,550
methodology behind our science so we

00:05:00,610 --> 00:05:06,100
took a look at a bunch of different

00:05:03,550 --> 00:05:07,960
applications and we and we kind of

00:05:06,100 --> 00:05:09,970
looked at different approaches that

00:05:07,960 --> 00:05:12,820
developers took to building out those

00:05:09,970 --> 00:05:15,370
applications and we also took a look at

00:05:12,820 --> 00:05:18,160
some of the major makers of the popular

00:05:15,370 --> 00:05:20,470
UX frameworks that are out there so I'm

00:05:18,160 --> 00:05:23,020
thinking of people here like ionic or

00:05:20,470 --> 00:05:24,790
onsen or kendo and not the MV star

00:05:23,020 --> 00:05:26,200
frameworks not the angular's of the

00:05:24,790 --> 00:05:28,030
world of a reacts of the worlds but the

00:05:26,200 --> 00:05:30,610
people that are making UX controls

00:05:28,030 --> 00:05:33,010
because those are the things that end up

00:05:30,610 --> 00:05:34,510
driving user interaction and we said you

00:05:33,010 --> 00:05:36,580
know what is there any difference

00:05:34,510 --> 00:05:38,380
between the way that average Joe

00:05:36,580 --> 00:05:40,870
developer is building things today

00:05:38,380 --> 00:05:43,180
versus the way that these people who are

00:05:40,870 --> 00:05:44,470
creating the best-of-breed UX frameworks

00:05:43,180 --> 00:05:46,990
are actually thinking about performance

00:05:44,470 --> 00:05:49,180
and where there are differences between

00:05:46,990 --> 00:05:51,910
the two what are the differences that

00:05:49,180 --> 00:05:53,470
are contributing to poor performance

00:05:51,910 --> 00:05:57,970
does that make sense

00:05:53,470 --> 00:06:01,630
yeah and so from that we identified six

00:05:57,970 --> 00:06:03,130
issues by the way the all of the tests

00:06:01,630 --> 00:06:05,800
that we performed here because you need

00:06:03,130 --> 00:06:09,580
to control four devices here we used

00:06:05,800 --> 00:06:12,070
three kind of you know recent but not

00:06:09,580 --> 00:06:14,110
too recent devices because we wanted to

00:06:12,070 --> 00:06:17,080
find devices that were out there being

00:06:14,110 --> 00:06:18,790
used by our mothers and our fathers and

00:06:17,080 --> 00:06:20,650
our sisters and people that are not just

00:06:18,790 --> 00:06:22,720
spending all of their time in the tech

00:06:20,650 --> 00:06:25,030
world investing in the next greatest

00:06:22,720 --> 00:06:26,730
thing right so they're slightly older

00:06:25,030 --> 00:06:31,660
devices

00:06:26,730 --> 00:06:33,580
so here the six different areas where we

00:06:31,660 --> 00:06:35,380
found that there were discrepancies

00:06:33,580 --> 00:06:37,180
between the way that the common

00:06:35,380 --> 00:06:40,240
developer might go about building an

00:06:37,180 --> 00:06:40,689
application and the kind of the best of

00:06:40,240 --> 00:06:44,949
the back

00:06:40,689 --> 00:06:47,379
so UX developers so webview tax document

00:06:44,949 --> 00:06:49,509
object model images animation garbage

00:06:47,379 --> 00:06:51,209
collection and UI controls these are the

00:06:49,509 --> 00:06:56,319
areas where we found differences now

00:06:51,209 --> 00:06:57,789
because I'm a sneaky guy I'm only going

00:06:56,319 --> 00:07:01,419
to tell you about four of those today

00:06:57,789 --> 00:07:03,039
really that's my way of tempting all of

00:07:01,419 --> 00:07:05,169
you to come up and talk to me afterwards

00:07:03,039 --> 00:07:07,389
so that you can find out the hidden

00:07:05,169 --> 00:07:09,699
secrets behind animation and UI controls

00:07:07,389 --> 00:07:14,619
we'll start by talking about these four

00:07:09,699 --> 00:07:17,739
though sound good all right so the web

00:07:14,619 --> 00:07:19,899
view tax now this first part this is

00:07:17,739 --> 00:07:22,599
really specific to Cordova this is the

00:07:19,899 --> 00:07:25,329
one piece of the talk that is only going

00:07:22,599 --> 00:07:28,329
to apply to hybrid applications now as I

00:07:25,329 --> 00:07:30,669
said before Cordova application has the

00:07:28,329 --> 00:07:32,769
web application running inside of a

00:07:30,669 --> 00:07:36,219
webview that's hosted inside of a native

00:07:32,769 --> 00:07:38,319
control and because it kind of operates

00:07:36,219 --> 00:07:41,709
inside of that webview there's a tax

00:07:38,319 --> 00:07:44,619
that you got to pay and so here's what

00:07:41,709 --> 00:07:47,289
we did first we said you know what let's

00:07:44,619 --> 00:07:49,539
take a baseline let's measure the memory

00:07:47,289 --> 00:07:52,629
footprint of a native application and

00:07:49,539 --> 00:07:55,659
the native Java for Android objective-c

00:07:52,629 --> 00:07:57,909
for iOS c-sharp for Windows and

00:07:55,659 --> 00:08:00,159
Silverlight for Windows Phone right we

00:07:57,909 --> 00:08:02,679
said okay if you were just to create a

00:08:00,159 --> 00:08:04,449
hello world using the native language

00:08:02,679 --> 00:08:08,769
what would the memory footprint being

00:08:04,449 --> 00:08:11,349
and we said you know what I bet that

00:08:08,769 --> 00:08:14,529
since a webview is essentially just a

00:08:11,349 --> 00:08:16,899
browser that the memory footprint of a

00:08:14,529 --> 00:08:19,209
Cordova app would probably be the native

00:08:16,899 --> 00:08:21,339
application plus the memory footprint of

00:08:19,209 --> 00:08:23,050
the browser and that would probably give

00:08:21,339 --> 00:08:24,249
you the memory footprint of a Cordova

00:08:23,050 --> 00:08:25,919
app and that could kind of give us an

00:08:24,249 --> 00:08:28,869
idea of what the taxes that we pay there

00:08:25,919 --> 00:08:31,059
so we did a measurement of a browser on

00:08:28,869 --> 00:08:33,250
each of the devices so that's the memory

00:08:31,059 --> 00:08:35,740
footprint of about blank in a web

00:08:33,250 --> 00:08:38,889
browser on an Android phone and iOS

00:08:35,740 --> 00:08:41,430
phone and Windows Device then we

00:08:38,889 --> 00:08:43,779
measured the Cordova application now

00:08:41,430 --> 00:08:47,740
there's some interesting things going on

00:08:43,779 --> 00:08:49,839
here clearly androids got something

00:08:47,740 --> 00:08:52,180
going on here there's like a World Trade

00:08:49,839 --> 00:08:54,700
Center tower going up there

00:08:52,180 --> 00:08:57,670
says the Cordova application has got

00:08:54,700 --> 00:08:58,810
giant memory consumption problems on the

00:08:57,670 --> 00:09:01,450
iOS side

00:08:58,810 --> 00:09:03,610
well a plus B does not equal C they're

00:09:01,450 --> 00:09:06,670
actually the memory footprint is about

00:09:03,610 --> 00:09:08,830
the same as the browser Windows Store

00:09:06,670 --> 00:09:11,950
glory be I don't even know how this is

00:09:08,830 --> 00:09:14,410
possible but the memory footprint is

00:09:11,950 --> 00:09:16,750
lower than the native app and lower than

00:09:14,410 --> 00:09:19,750
the browser and then Windows Phone okay

00:09:16,750 --> 00:09:22,480
it's kind of about the same now all

00:09:19,750 --> 00:09:25,480
right so I want you all to remember that

00:09:22,480 --> 00:09:27,010
giant Tower that's there next to Android

00:09:25,480 --> 00:09:29,620
that's gonna come up later in some

00:09:27,010 --> 00:09:33,370
interesting ways but just remember big

00:09:29,620 --> 00:09:35,260
memory footprint on Android so here's

00:09:33,370 --> 00:09:36,370
the thing it's lovely to talk about

00:09:35,260 --> 00:09:39,220
memory but we're here to talk about

00:09:36,370 --> 00:09:42,070
performance today and memory is not

00:09:39,220 --> 00:09:44,320
something you can see where you can see

00:09:42,070 --> 00:09:47,770
it has an effect is on startup time so

00:09:44,320 --> 00:09:49,690
here's what we did took a slow motion

00:09:47,770 --> 00:09:51,790
camera in this case I actually just used

00:09:49,690 --> 00:09:55,209
my iPhone 6 it has a nice little slow

00:09:51,790 --> 00:09:58,270
motion camera in it and filmed actually

00:09:55,209 --> 00:09:59,709
starting up an application so hopefully

00:09:58,270 --> 00:10:02,110
you can see this on the left-hand side

00:09:59,709 --> 00:10:04,240
you can see us using a nice little touch

00:10:02,110 --> 00:10:06,640
pin to click on the hello world app on

00:10:04,240 --> 00:10:08,440
the right-hand side you can start to see

00:10:06,640 --> 00:10:10,630
a little bit of ghosting where the

00:10:08,440 --> 00:10:12,459
applications starting to launch we

00:10:10,630 --> 00:10:15,400
measured the number of frames in between

00:10:12,459 --> 00:10:18,520
the touch moment and the launch moment

00:10:15,400 --> 00:10:20,170
because it was filmed at 240 frames per

00:10:18,520 --> 00:10:22,209
second that meant that each frame

00:10:20,170 --> 00:10:23,830
accounted for 4 milliseconds and we

00:10:22,209 --> 00:10:29,640
could figure out how long it took to

00:10:23,830 --> 00:10:31,300
actually launch the application ah now

00:10:29,640 --> 00:10:33,790
remember how I asked you to remember

00:10:31,300 --> 00:10:34,870
that giant kind of increase on the

00:10:33,790 --> 00:10:39,430
Android side of things

00:10:34,870 --> 00:10:41,980
look how tall or how long it took for

00:10:39,430 --> 00:10:45,100
those Android Cordova apps to start up

00:10:41,980 --> 00:10:48,339
so the memory and the startup time have

00:10:45,100 --> 00:10:53,110
a strong correlation here on the iOS

00:10:48,339 --> 00:10:56,110
side ok this tall pillar right here

00:10:53,110 --> 00:10:57,490
that's the native app starting up I want

00:10:56,110 --> 00:10:59,200
to put a little caveat next to that

00:10:57,490 --> 00:11:01,029
that's why I put a little asterisk up at

00:10:59,200 --> 00:11:03,310
the top we actually just used the

00:11:01,029 --> 00:11:05,840
default hello world iOS app that came

00:11:03,310 --> 00:11:07,880
out of Xcode the way that that app is

00:11:05,840 --> 00:11:10,790
figured out of the box it has a 500

00:11:07,880 --> 00:11:13,040
millisecond delay that is configurable

00:11:10,790 --> 00:11:14,390
and so I believe that that number there

00:11:13,040 --> 00:11:16,970
is actually a bit of a false

00:11:14,390 --> 00:11:19,910
representation of what the actual native

00:11:16,970 --> 00:11:22,010
implementation would would kind of cause

00:11:19,910 --> 00:11:25,880
if we had adjusted that configuration

00:11:22,010 --> 00:11:27,650
setting iOS is iOS warm is pretty good

00:11:25,880 --> 00:11:29,600
when does phone cold is pretty good in

00:11:27,650 --> 00:11:32,690
Windows Phone warm is pretty good these

00:11:29,600 --> 00:11:33,680
cold versus warm so let me kind of give

00:11:32,690 --> 00:11:37,340
a little bit of insight into the

00:11:33,680 --> 00:11:39,740
methodology there cold means that we

00:11:37,340 --> 00:11:41,630
shut the phone completely down then

00:11:39,740 --> 00:11:45,500
started it up and then immediately

00:11:41,630 --> 00:11:48,530
started the application warm means that

00:11:45,500 --> 00:11:51,230
we shut the phone down turn it back on

00:11:48,530 --> 00:11:53,930
started the application shut the

00:11:51,230 --> 00:11:56,120
application down and then open the

00:11:53,930 --> 00:11:59,180
application up again because each of the

00:11:56,120 --> 00:12:01,640
devices makes some some sort of memory

00:11:59,180 --> 00:12:04,010
optimizations for the cold horses warm

00:12:01,640 --> 00:12:05,690
scenario we wanted to make sure that we

00:12:04,010 --> 00:12:10,610
controlled for that depending upon the

00:12:05,690 --> 00:12:13,970
actual usage so big takeaway here memory

00:12:10,610 --> 00:12:16,220
consumption high correlation with slower

00:12:13,970 --> 00:12:18,380
performance we're gonna see that theme

00:12:16,220 --> 00:12:22,430
repeat again and again over the course

00:12:18,380 --> 00:12:24,710
of the next 20 minutes so takeaway

00:12:22,430 --> 00:12:27,140
Android tends to be slower and it tends

00:12:24,710 --> 00:12:30,830
to be slower because we think because of

00:12:27,140 --> 00:12:33,290
memory consumption all right there's one

00:12:30,830 --> 00:12:36,020
more place that in a Cordova application

00:12:33,290 --> 00:12:39,080
you're actually paying a tax and that's

00:12:36,020 --> 00:12:40,820
in that xhr request that a synchronous

00:12:39,080 --> 00:12:44,060
call that needs to go from the webview

00:12:40,820 --> 00:12:46,960
to the native code and back again so

00:12:44,060 --> 00:12:51,410
imagine for a moment that you are

00:12:46,960 --> 00:12:54,830
sending a request for geolocation data

00:12:51,410 --> 00:12:57,290
or for accelerometer data your web your

00:12:54,830 --> 00:12:59,510
JavaScript needs to make the request at

00:12:57,290 --> 00:13:02,090
asynchronous a synchronously crosses the

00:12:59,510 --> 00:13:03,590
webview talks to the native code then

00:13:02,090 --> 00:13:05,390
the native code needs to send that

00:13:03,590 --> 00:13:08,920
response back with an XY and z

00:13:05,390 --> 00:13:13,310
coordinate right so here's what we did

00:13:08,920 --> 00:13:17,060
we created a cordova plugin whose only

00:13:13,310 --> 00:13:18,810
job in this big wide world was just to

00:13:17,060 --> 00:13:20,880
receive data and to

00:13:18,810 --> 00:13:23,190
that data back it didn't perform any

00:13:20,880 --> 00:13:27,180
processing on the data whatsoever it

00:13:23,190 --> 00:13:29,880
just was there to measure the impact on

00:13:27,180 --> 00:13:33,180
data size as it crossed over that web

00:13:29,880 --> 00:13:35,670
view bridge and what we see here is a

00:13:33,180 --> 00:13:38,730
nice linear line look at this

00:13:35,670 --> 00:13:42,060
so for iOS Android and Windows Phone

00:13:38,730 --> 00:13:45,510
using C sharp as the data increases

00:13:42,060 --> 00:13:47,690
along the x-axis the time also increases

00:13:45,510 --> 00:13:51,510
along the y-axis in a linear fashion

00:13:47,690 --> 00:13:53,190
note however crossing the very bottom of

00:13:51,510 --> 00:13:55,650
that line there's a kind of a yellow

00:13:53,190 --> 00:13:58,050
line there that's windows phone using

00:13:55,650 --> 00:14:01,500
javascript because windows devices are

00:13:58,050 --> 00:14:03,680
able to run JavaScript as a native

00:14:01,500 --> 00:14:05,520
language like you don't there's no

00:14:03,680 --> 00:14:08,790
compilation that happens there

00:14:05,520 --> 00:14:11,130
there's no webview to cross and so the

00:14:08,790 --> 00:14:14,339
time to kind of interact with the

00:14:11,130 --> 00:14:16,920
plug-in is zero no matter how large the

00:14:14,339 --> 00:14:19,760
data set gets what I want to call your

00:14:16,920 --> 00:14:23,760
attention to here though is that this

00:14:19,760 --> 00:14:27,860
500k actually this is more than 500 K

00:14:23,760 --> 00:14:30,960
this is 5,000 K in order for you to

00:14:27,860 --> 00:14:32,730
transfer that over the webview is a

00:14:30,960 --> 00:14:34,980
period of less than was that 300

00:14:32,730 --> 00:14:37,530
milliseconds or so it's a very very

00:14:34,980 --> 00:14:39,360
small amount of time and so even if you

00:14:37,530 --> 00:14:42,680
were transferring a large amount of data

00:14:39,360 --> 00:14:46,080
for example an image taken from a camera

00:14:42,680 --> 00:14:48,510
it's going to happen in a practically

00:14:46,080 --> 00:14:51,150
non noticeable period of time if you're

00:14:48,510 --> 00:14:53,400
transferring smaller bits of data for

00:14:51,150 --> 00:14:57,000
example accelerometer or geolocation

00:14:53,400 --> 00:15:00,360
data it's going to be 2 3 4 milliseconds

00:14:57,000 --> 00:15:02,670
very very tiny so what that tells us

00:15:00,360 --> 00:15:05,280
that is that javascript in terms of

00:15:02,670 --> 00:15:08,310
being able to deliver high performance

00:15:05,280 --> 00:15:10,940
is able to really deliver right you

00:15:08,310 --> 00:15:14,310
don't there's no waiting around for it

00:15:10,940 --> 00:15:16,620
ok that's it for the Cordova specific

00:15:14,310 --> 00:15:18,209
stuff now let's actually get into the

00:15:16,620 --> 00:15:21,870
kind of the stuff that's applicable to

00:15:18,209 --> 00:15:23,279
both Cordova and to mobile web so I

00:15:21,870 --> 00:15:26,220
don't need to tell you guys too much

00:15:23,279 --> 00:15:29,060
about what the DOM is you all know let's

00:15:26,220 --> 00:15:31,500
see a dumb or rather an example here and

00:15:29,060 --> 00:15:33,360
a bit about how this is going to

00:15:31,500 --> 00:15:35,400
just to make sure that we had enough

00:15:33,360 --> 00:15:37,620
time to show all the experiments what I

00:15:35,400 --> 00:15:39,930
did is I did a screen recording of me

00:15:37,620 --> 00:15:41,910
conducting these experiments when I

00:15:39,930 --> 00:15:44,280
actually conduct them in the lab I'm

00:15:41,910 --> 00:15:46,950
performing these experiments thousands

00:15:44,280 --> 00:15:49,290
and thousands and thousands of times to

00:15:46,950 --> 00:15:51,450
make sure that we get a good median and

00:15:49,290 --> 00:15:53,580
a good baseline for each of them each

00:15:51,450 --> 00:15:59,430
one of these is exemplary of those

00:15:53,580 --> 00:16:01,830
thousands of runs ok so in this one I'm

00:15:59,430 --> 00:16:05,010
going to conduct an experiment where I'm

00:16:01,830 --> 00:16:08,010
performing Dom manipulation first using

00:16:05,010 --> 00:16:11,130
a simple DOM and then using a complex

00:16:08,010 --> 00:16:15,060
tone and what I mean by that a simple

00:16:11,130 --> 00:16:18,330
Dom has fewer elements and no nesting

00:16:15,060 --> 00:16:21,000
the complex Dom has very deep nesting

00:16:18,330 --> 00:16:23,940
hundreds of nodes deep and multiple

00:16:21,000 --> 00:16:26,730
elements for this I'm actually running

00:16:23,940 --> 00:16:28,200
them on a nexus 9 that Nexus 9 this is

00:16:26,730 --> 00:16:31,140
the case with all the experiments that

00:16:28,200 --> 00:16:34,260
Nexus 9 is just being screencast to my

00:16:31,140 --> 00:16:37,410
to my desktop via a fun little

00:16:34,260 --> 00:16:39,060
application called mobizen all of the

00:16:37,410 --> 00:16:42,180
experiments I'm going to show using

00:16:39,060 --> 00:16:51,330
Android but the results tend to be

00:16:42,180 --> 00:16:53,610
similar for iOS and Windows okay all

00:16:51,330 --> 00:16:55,650
right for this I'm just gonna bring up

00:16:53,610 --> 00:16:56,430
the chrome dev tools and the first one

00:16:55,650 --> 00:16:58,230
that I'm gonna do is I'm going to

00:16:56,430 --> 00:17:00,240
trigger manipulations of the simple Dom

00:16:58,230 --> 00:17:01,800
and you can see here I'm just outputting

00:17:00,240 --> 00:17:03,660
to the console the amount of time

00:17:01,800 --> 00:17:05,459
required to perform each one of the

00:17:03,660 --> 00:17:08,640
manipulations I've moved on to the

00:17:05,459 --> 00:17:11,220
complex Dom using app in child then

00:17:08,640 --> 00:17:14,670
complex Dom modifications using inner

00:17:11,220 --> 00:17:17,189
HTML and then finally complex Dom

00:17:14,670 --> 00:17:18,839
modifications using document fragment

00:17:17,189 --> 00:17:21,930
right so everyone pretty much knows

00:17:18,839 --> 00:17:23,910
those methods appendchild enter HTML

00:17:21,930 --> 00:17:26,130
what I want to call your attention to is

00:17:23,910 --> 00:17:28,740
the amount of time that it required to

00:17:26,130 --> 00:17:31,260
perform a simple Dom manipulation versus

00:17:28,740 --> 00:17:33,960
a complex Dom manipulation that's point

00:17:31,260 --> 00:17:37,380
zero two six milliseconds compared to

00:17:33,960 --> 00:17:40,020
point zero five four milliseconds now I

00:17:37,380 --> 00:17:42,480
know I know I know

00:17:40,020 --> 00:17:43,830
point zero two six milliseconds is just

00:17:42,480 --> 00:17:48,110
not that much time

00:17:43,830 --> 00:17:51,720
right it's it's nanoseconds right but

00:17:48,110 --> 00:17:53,460
those will add up over time as your Dom

00:17:51,720 --> 00:17:55,260
gets more and more complex and we're

00:17:53,460 --> 00:17:59,909
actually gonna see that happen here in

00:17:55,260 --> 00:18:01,529
just a minute so now we know surprise I

00:17:59,909 --> 00:18:03,990
mean like this is almost common sense

00:18:01,529 --> 00:18:06,960
simple Dom manipulations require less

00:18:03,990 --> 00:18:10,350
time time than complex ones but that can

00:18:06,960 --> 00:18:15,090
lead to some interesting choices about

00:18:10,350 --> 00:18:22,590
how you write your code now like this is

00:18:15,090 --> 00:18:24,539
all most unintelligent them whatever but

00:18:22,590 --> 00:18:27,059
you're gonna make some different

00:18:24,539 --> 00:18:30,029
decisions when you optimize for

00:18:27,059 --> 00:18:32,580
performance versus optimizing for code

00:18:30,029 --> 00:18:35,460
maintainability or code legibility in

00:18:32,580 --> 00:18:39,600
this particular case I've reduced the

00:18:35,460 --> 00:18:41,460
number of elements by 30% and by

00:18:39,600 --> 00:18:44,279
reducing the number of elements as that

00:18:41,460 --> 00:18:46,950
multiplies out over the broad scope of

00:18:44,279 --> 00:18:48,570
an application that conservation of

00:18:46,950 --> 00:18:50,519
elements is going to help me

00:18:48,570 --> 00:18:54,230
tremendously so in this case it is

00:18:50,519 --> 00:18:59,610
functionally equivalent but 30% fewer

00:18:54,230 --> 00:19:03,929
actual Dom elements takeaway reduce your

00:18:59,610 --> 00:19:06,659
element count all right so let's talk

00:19:03,929 --> 00:19:08,669
about another little idiosyncrasy of Dom

00:19:06,659 --> 00:19:10,799
manipulation and many of you may be

00:19:08,669 --> 00:19:12,690
familiar with this kind of technique

00:19:10,799 --> 00:19:17,250
before layout thrashing is basically

00:19:12,690 --> 00:19:19,200
when you set a CSS property at the same

00:19:17,250 --> 00:19:22,559
time as on the opposite side you're

00:19:19,200 --> 00:19:25,500
reading the CSS property so let's see

00:19:22,559 --> 00:19:28,169
how this actually works here right so I

00:19:25,500 --> 00:19:30,120
got another video and in this particular

00:19:28,169 --> 00:19:33,510
one you'll see that on the left hand

00:19:30,120 --> 00:19:35,220
side I am setting my style to on the

00:19:33,510 --> 00:19:37,620
right-hand side of the equal sign and

00:19:35,220 --> 00:19:39,059
read a command so I'm just looping

00:19:37,620 --> 00:19:42,539
through again and again and again

00:19:39,059 --> 00:19:45,570
setting to a read in the second case and

00:19:42,539 --> 00:19:47,610
this one I'm looping through I'm reading

00:19:45,570 --> 00:19:50,940
all of the values first and then I have

00:19:47,610 --> 00:19:52,860
a separate loop to set right now that

00:19:50,940 --> 00:19:54,510
seems like a relatively small change and

00:19:52,860 --> 00:19:56,519
again from a legibility or code

00:19:54,510 --> 00:19:58,859
maintainability perspective it all

00:19:56,519 --> 00:20:01,559
seems like the first is better so what

00:19:58,859 --> 00:20:03,779
i'm doing here is first i'm going to

00:20:01,559 --> 00:20:06,989
perform an action where it lets you know

00:20:03,779 --> 00:20:10,529
that one i am using the thrashing so i'm

00:20:06,989 --> 00:20:12,629
actually the very first one I read to my

00:20:10,529 --> 00:20:15,330
set and in the second one I do the two

00:20:12,629 --> 00:20:18,629
four loops now look at the comparison

00:20:15,330 --> 00:20:21,690
here with thrashing that took nearly

00:20:18,629 --> 00:20:24,809
four seconds without thrashing it took

00:20:21,690 --> 00:20:27,659
only 56 milliseconds right that's a

00:20:24,809 --> 00:20:30,539
eight fold improvement something like

00:20:27,659 --> 00:20:37,589
that just by changing the order by which

00:20:30,539 --> 00:20:41,009
we set and read so real quick here just

00:20:37,589 --> 00:20:46,079
to reinforce it bad don't read it and

00:20:41,009 --> 00:20:51,659
set it in the same line good read it

00:20:46,079 --> 00:20:55,409
first set it later batch your layout

00:20:51,659 --> 00:20:59,729
operations all the read at once all the

00:20:55,409 --> 00:21:02,219
set at once okay let's talk about fast

00:20:59,729 --> 00:21:04,649
list scrolling so this is essentially

00:21:02,219 --> 00:21:06,989
when you've got thousands of elements on

00:21:04,649 --> 00:21:08,489
a page and you need to be able to scroll

00:21:06,989 --> 00:21:11,489
through them quickly in an infinite

00:21:08,489 --> 00:21:13,349
scroll think here of something like I

00:21:11,489 --> 00:21:14,820
don't know Facebook right where you're

00:21:13,349 --> 00:21:16,440
just kind of scrolling forever and ever

00:21:14,820 --> 00:21:19,799
and ever or Twitter or whatever your

00:21:16,440 --> 00:21:23,489
favorite social media network is so in

00:21:19,799 --> 00:21:25,649
this particular one in the first one I

00:21:23,489 --> 00:21:27,359
am going to use just those I think it's

00:21:25,649 --> 00:21:29,159
I think actually is a thousand elements

00:21:27,359 --> 00:21:31,049
and I'm just gonna scroll through them

00:21:29,159 --> 00:21:33,389
without any kind of optimizations

00:21:31,049 --> 00:21:36,659
whatsoever it's just Dom elements on the

00:21:33,389 --> 00:21:38,839
page iterating down in the second case

00:21:36,659 --> 00:21:40,799
I'm going to use virtualization

00:21:38,839 --> 00:21:43,739
virtualization is a technique where we

00:21:40,799 --> 00:21:47,070
essentially simplify the Dom by removing

00:21:43,739 --> 00:21:49,529
elements that are before and after the

00:21:47,070 --> 00:21:51,839
visible screen so that there are less

00:21:49,529 --> 00:21:54,389
elements on the page and remember back

00:21:51,839 --> 00:21:55,889
before we had our lesson about when

00:21:54,389 --> 00:21:58,739
there were fewer elements on the page

00:21:55,889 --> 00:22:00,749
when we have a simple Dom it's the the

00:21:58,739 --> 00:22:02,940
the actual browser is faster when we

00:22:00,749 --> 00:22:05,690
have a complex Dom the browser tends to

00:22:02,940 --> 00:22:07,829
be slower this is that same lesson

00:22:05,690 --> 00:22:09,659
multiplied out in a way that you can

00:22:07,829 --> 00:22:10,260
actually see it in a way that the user

00:22:09,659 --> 00:22:12,929
would

00:22:10,260 --> 00:22:16,230
so here we are we're actually launching

00:22:12,929 --> 00:22:18,179
it up the in this particular case I just

00:22:16,230 --> 00:22:20,370
got a little image of some fruit and

00:22:18,179 --> 00:22:21,990
you'll see I'm kinda through here it

00:22:20,370 --> 00:22:23,780
almost looks like the screen is

00:22:21,990 --> 00:22:26,880
disappearing it's just going blank

00:22:23,780 --> 00:22:29,340
that's not like a quirk of the video

00:22:26,880 --> 00:22:31,380
that's because the elements the the

00:22:29,340 --> 00:22:33,299
browser itself isn't able to keep up

00:22:31,380 --> 00:22:35,549
with the paint and so they just

00:22:33,299 --> 00:22:37,470
disappear as I quickly quickly quickly

00:22:35,549 --> 00:22:39,690
move back and forth in it right and

00:22:37,470 --> 00:22:42,720
sometimes they disappear for seconds at

00:22:39,690 --> 00:22:44,549
a time so in this next one I'm actually

00:22:42,720 --> 00:22:47,100
gonna launch it again and this time I'm

00:22:44,549 --> 00:22:50,340
gonna use a virtualization so I'm only

00:22:47,100 --> 00:22:53,370
keeping in memory elements that are one

00:22:50,340 --> 00:22:56,730
or two maybe three screens before or

00:22:53,370 --> 00:22:59,130
after the visible screen right in this

00:22:56,730 --> 00:23:01,169
particular case I'm think what I was

00:22:59,130 --> 00:23:03,360
using here was when Jay s is my

00:23:01,169 --> 00:23:04,980
virtualization engine when Jay s happens

00:23:03,360 --> 00:23:06,299
to have really good list scrolling but

00:23:04,980 --> 00:23:09,900
there are lots of other frameworks that

00:23:06,299 --> 00:23:13,980
provide virtualization for it alright

00:23:09,900 --> 00:23:15,299
let's get it up here one of the other

00:23:13,980 --> 00:23:16,500
things that I want you to know is here

00:23:15,299 --> 00:23:20,280
is one of the other tricks of

00:23:16,500 --> 00:23:22,049
virtualization is that as the as the

00:23:20,280 --> 00:23:24,000
browser gets to a place where it no

00:23:22,049 --> 00:23:25,470
longer has those elements in memory what

00:23:24,000 --> 00:23:28,410
it will start to do you see those gray

00:23:25,470 --> 00:23:31,169
gray boxes essentially what it's doing

00:23:28,410 --> 00:23:33,960
is putting in dummy elements so that you

00:23:31,169 --> 00:23:35,669
feel like the the application is able to

00:23:33,960 --> 00:23:37,710
keep up with it think here I'll use

00:23:35,669 --> 00:23:39,570
Facebook again as an example when you

00:23:37,710 --> 00:23:42,179
first load facebook on your mobile phone

00:23:39,570 --> 00:23:44,880
it's got a couple of placeholder kind of

00:23:42,179 --> 00:23:46,890
posts in there same idea this is really

00:23:44,880 --> 00:23:51,780
all about of improving the perception of

00:23:46,890 --> 00:23:53,940
performance and when we measure this out

00:23:51,780 --> 00:23:55,919
we actually measured the memory of these

00:23:53,940 --> 00:23:58,669
guys the virtualized list

00:23:55,919 --> 00:24:01,080
less than a hundred megabytes of memory

00:23:58,669 --> 00:24:03,870
for that particular application at

00:24:01,080 --> 00:24:06,210
runtime the non-virtualized list over

00:24:03,870 --> 00:24:09,840
was that nearly three hundred and fifty

00:24:06,210 --> 00:24:12,120
megabytes and again we see a strong

00:24:09,840 --> 00:24:14,160
correlation between the memory

00:24:12,120 --> 00:24:17,130
consumption and the actual performance

00:24:14,160 --> 00:24:18,299
itself and so any time that you find

00:24:17,130 --> 00:24:21,090
yourself in a position where you're

00:24:18,299 --> 00:24:22,429
trying to measure for performance and

00:24:21,090 --> 00:24:25,009
trying to optimize for

00:24:22,429 --> 00:24:27,860
formants measuring frames per second

00:24:25,009 --> 00:24:29,779
great you should do that but as a proxy

00:24:27,860 --> 00:24:33,320
it can sometimes be helpful to also look

00:24:29,779 --> 00:24:35,749
at your memory consumption as well all

00:24:33,320 --> 00:24:36,320
right take away use virtualization when

00:24:35,749 --> 00:24:38,450
you can

00:24:36,320 --> 00:24:39,860
lots of frameworks do it my advice don't

00:24:38,450 --> 00:24:41,960
try to do this yourself writing

00:24:39,860 --> 00:24:50,450
virtualization is hard it's super hard

00:24:41,960 --> 00:24:52,759
just use another framework ok images so

00:24:50,450 --> 00:24:54,950
here's a funny one this is like

00:24:52,759 --> 00:24:56,929
completely this this blows my mind when

00:24:54,950 --> 00:24:59,659
I see this one it's it's totally weird

00:24:56,929 --> 00:25:01,460
so I didn't know how long have CSS

00:24:59,659 --> 00:25:05,149
Graydon's gradients been around this is

00:25:01,460 --> 00:25:07,070
like can anyone remember 2008 I don't

00:25:05,149 --> 00:25:09,499
know something like that CSS gradients

00:25:07,070 --> 00:25:10,820
are super super helpful they allow us to

00:25:09,499 --> 00:25:13,070
be a little bit more responsive in our

00:25:10,820 --> 00:25:14,240
design it we don't have to cut like a

00:25:13,070 --> 00:25:16,999
one by one

00:25:14,240 --> 00:25:20,990
you know pixel tile to kind of grayed

00:25:16,999 --> 00:25:22,639
across but just like before when we were

00:25:20,990 --> 00:25:24,259
looking at how we might reduce our

00:25:22,639 --> 00:25:26,149
overall element count there are

00:25:24,259 --> 00:25:28,100
different decisions that you might make

00:25:26,149 --> 00:25:30,470
when you're optimizing for performance

00:25:28,100 --> 00:25:31,369
versus when you're maintaining for or

00:25:30,470 --> 00:25:33,980
when you're writing for code

00:25:31,369 --> 00:25:36,649
maintainability so in this particular

00:25:33,980 --> 00:25:39,320
case I've got two objects the first

00:25:36,649 --> 00:25:42,799
object just uses a regular old CSS

00:25:39,320 --> 00:25:45,919
gradient the second object uses a PNG

00:25:42,799 --> 00:25:47,210
file to create my gradient alright what

00:25:45,919 --> 00:25:49,909
I'm gonna do is I'm gonna animate these

00:25:47,210 --> 00:25:51,619
guys and when I animate these guys I'm

00:25:49,909 --> 00:25:55,009
gonna use the chrome dev tools to

00:25:51,619 --> 00:25:56,779
measure frames per second and I hope

00:25:55,009 --> 00:25:58,580
that many of you are familiar with the

00:25:56,779 --> 00:26:01,970
chrome dev tools performance

00:25:58,580 --> 00:26:06,200
optimization tools if you're not the

00:26:01,970 --> 00:26:10,039
quick rule here is that tall bars up

00:26:06,200 --> 00:26:12,139
there or bad low bars are good right so

00:26:10,039 --> 00:26:15,019
in the first case where you see all

00:26:12,139 --> 00:26:17,389
those giant green skyscrapers that's

00:26:15,019 --> 00:26:19,820
what I'm animating the CSS gradient on

00:26:17,389 --> 00:26:22,820
the right hand side when I'm animating

00:26:19,820 --> 00:26:26,559
the image all those low bars that's when

00:26:22,820 --> 00:26:29,210
I'm animating the bitmapped ping like

00:26:26,559 --> 00:26:31,600
what what's up with that

00:26:29,210 --> 00:26:33,769
like seriously what's up with that so

00:26:31,600 --> 00:26:35,929
here's what I think is actually

00:26:33,769 --> 00:26:37,309
happening right and I like here

00:26:35,929 --> 00:26:39,019
actually you no need to call my friends

00:26:37,309 --> 00:26:41,419
over at Google and verify this but

00:26:39,019 --> 00:26:44,330
here's what I think is happening when

00:26:41,419 --> 00:26:46,700
you animate that CSS gradient every time

00:26:44,330 --> 00:26:49,429
it moves a frame over it needs to redraw

00:26:46,700 --> 00:26:52,220
the gradient each time when it's

00:26:49,429 --> 00:26:54,799
animating the bitmap or the ping in this

00:26:52,220 --> 00:26:56,929
particular case that already exists it

00:26:54,799 --> 00:26:59,360
doesn't need to redraw it every time and

00:26:56,929 --> 00:27:02,110
so you get better animation when you're

00:26:59,360 --> 00:27:05,240
moving the already in memory image

00:27:02,110 --> 00:27:07,789
compared to what's essentially creating

00:27:05,240 --> 00:27:12,409
an image for each for each frame of the

00:27:07,789 --> 00:27:14,779
CSS and so if there's a kind of a a bad

00:27:12,409 --> 00:27:17,240
version of this again like can't believe

00:27:14,779 --> 00:27:19,129
I'm putting this up there bad CSS

00:27:17,240 --> 00:27:22,029
gradients but somehow that is the case

00:27:19,129 --> 00:27:26,059
when you're optimizing for performance

00:27:22,029 --> 00:27:28,100
versus blow your mind good why in the

00:27:26,059 --> 00:27:29,990
world is this but it once again when

00:27:28,100 --> 00:27:31,850
you're optimizing for performance you're

00:27:29,990 --> 00:27:33,909
going to make different decisions than

00:27:31,850 --> 00:27:38,840
you would otherwise

00:27:33,909 --> 00:27:41,659
all right so use images Oh garbage

00:27:38,840 --> 00:27:43,249
collection everybody loves the garbage

00:27:41,659 --> 00:27:46,999
collector he takes all of our dirty

00:27:43,249 --> 00:27:49,639
memory away so garbage collectors have

00:27:46,999 --> 00:27:51,499
been around for you know since browsers

00:27:49,639 --> 00:27:53,990
were around and and generally they're

00:27:51,499 --> 00:27:56,090
pretty efficient but when you're dealing

00:27:53,990 --> 00:27:58,009
with a mobile application and I would

00:27:56,090 --> 00:28:01,700
say that this is particularly poignant

00:27:58,009 --> 00:28:03,559
for hybrid applications where the app

00:28:01,700 --> 00:28:06,230
itself is going to be a single page

00:28:03,559 --> 00:28:08,720
application that rarely shuts down

00:28:06,230 --> 00:28:12,230
memory management becomes really really

00:28:08,720 --> 00:28:13,730
important and that garbage collector it

00:28:12,230 --> 00:28:16,820
does run automatically but you can get

00:28:13,730 --> 00:28:20,539
yourself into a bad spot where it's um

00:28:16,820 --> 00:28:21,830
it's it's unable to do its job so here's

00:28:20,539 --> 00:28:23,269
what we're gonna do I want to kind of

00:28:21,830 --> 00:28:27,590
show this in action and in this

00:28:23,269 --> 00:28:28,909
particular one hit play here what I'm

00:28:27,590 --> 00:28:31,129
going to do is I'm going to create a

00:28:28,909 --> 00:28:33,289
bunch of elements and I'm going to

00:28:31,129 --> 00:28:34,909
attach event handlers to those elements

00:28:33,289 --> 00:28:37,249
just in the loops you see there add

00:28:34,909 --> 00:28:38,990
event listener and then I'm just going

00:28:37,249 --> 00:28:41,659
to destroy them by saying enter HTML

00:28:38,990 --> 00:28:45,470
equals to blank what that means is that

00:28:41,659 --> 00:28:48,139
as I destroy those my event handler is

00:28:45,470 --> 00:28:49,560
still sticking around in memory and the

00:28:48,139 --> 00:28:51,930
garbage collector has a

00:28:49,560 --> 00:28:52,950
really tough time getting back to it so

00:28:51,930 --> 00:28:55,260
what I'm gonna do here is I'm gonna

00:28:52,950 --> 00:28:56,940
start running this guy and once again in

00:28:55,260 --> 00:28:58,410
our friend chrome dev tools I want you

00:28:56,940 --> 00:29:01,500
to notice once I start running it

00:28:58,410 --> 00:29:04,770
there's gonna be a ramp that blue ramp

00:29:01,500 --> 00:29:13,020
that starts to get bigger and bigger and

00:29:04,770 --> 00:29:15,150
bigger bigger again that is death that

00:29:13,020 --> 00:29:18,780
is death for your application over time

00:29:15,150 --> 00:29:21,840
as memory just balloons out of scale now

00:29:18,780 --> 00:29:24,710
granted here I am creating thousands and

00:29:21,840 --> 00:29:27,570
thousands and thousands over again right

00:29:24,710 --> 00:29:28,950
and you might think to yourself well and

00:29:27,570 --> 00:29:30,450
my web application

00:29:28,950 --> 00:29:31,950
I'm never gonna be creating these

00:29:30,450 --> 00:29:35,250
thousands of elements again and again

00:29:31,950 --> 00:29:36,930
and again but but you actually you are

00:29:35,250 --> 00:29:39,540
especially if you've got a single page

00:29:36,930 --> 00:29:41,460
application that guy could stay open for

00:29:39,540 --> 00:29:44,910
a long time you may never shut it down

00:29:41,460 --> 00:29:46,770
for months and as the memory grows and

00:29:44,910 --> 00:29:50,460
those event handlers stick around behind

00:29:46,770 --> 00:29:59,000
you're basically just signing up for a

00:29:50,460 --> 00:29:59,000
browser crash at some point so bad here

00:29:59,690 --> 00:30:02,970
eventlistener

00:30:00,960 --> 00:30:07,260
still hanging around even after we

00:30:02,970 --> 00:30:09,570
destroyed our element good be

00:30:07,260 --> 00:30:12,630
responsible boys and girls destroy your

00:30:09,570 --> 00:30:15,360
event handlers right remove event hit

00:30:12,630 --> 00:30:20,180
event listener right there then

00:30:15,360 --> 00:30:22,950
responsibly remove your child all right

00:30:20,180 --> 00:30:25,110
now while we're on the subject of event

00:30:22,950 --> 00:30:27,480
listeners let's talk about how we can

00:30:25,110 --> 00:30:29,520
actually not just irresponsible create

00:30:27,480 --> 00:30:32,580
and destroy them but also how we can

00:30:29,520 --> 00:30:36,210
minimize the total number of them now I

00:30:32,580 --> 00:30:39,570
don't know about you guys but um I often

00:30:36,210 --> 00:30:41,640
like I go out I do a query selector all

00:30:39,570 --> 00:30:43,080
or a dollar sign dollar sign I go get a

00:30:41,640 --> 00:30:44,850
big collection of elements that loop

00:30:43,080 --> 00:30:47,010
through them and as I loop through them

00:30:44,850 --> 00:30:49,650
I just add in an event handler teach one

00:30:47,010 --> 00:30:52,740
on click event handler on click event

00:30:49,650 --> 00:30:54,590
handler and what that ends up doing is

00:30:52,740 --> 00:30:57,540
that ends up creating a rubber-stamp

00:30:54,590 --> 00:31:00,530
duplicate of every function again and

00:30:57,540 --> 00:31:03,030
again and again and again and that

00:31:00,530 --> 00:31:03,299
multiplicity that that giant collection

00:31:03,030 --> 00:31:05,940
of

00:31:03,299 --> 00:31:09,600
handlers are once again just consuming

00:31:05,940 --> 00:31:11,519
more memory and so what I want you to to

00:31:09,600 --> 00:31:13,769
encourage you to do here is rather than

00:31:11,519 --> 00:31:17,279
create an event listener or event

00:31:13,769 --> 00:31:20,190
handler for each element instead think

00:31:17,279 --> 00:31:22,289
about using a single event handler for

00:31:20,190 --> 00:31:23,730
all of your objects within a node tree

00:31:22,289 --> 00:31:26,159
let me let me kind of explain what I

00:31:23,730 --> 00:31:28,590
mean here a little bit so one two three

00:31:26,159 --> 00:31:30,779
four and five those little elements down

00:31:28,590 --> 00:31:34,889
at the bottom they've all got a common

00:31:30,779 --> 00:31:37,320
ancestor in this case the dude right so

00:31:34,889 --> 00:31:40,230
that dude through the magic of event

00:31:37,320 --> 00:31:42,679
bubbling receives all the same events

00:31:40,230 --> 00:31:44,909
that one two three four and five receive

00:31:42,679 --> 00:31:47,399
so what I want to encourage you to do is

00:31:44,909 --> 00:31:49,259
think about how you can use event

00:31:47,399 --> 00:31:52,799
handlers or event listeners on the dude

00:31:49,259 --> 00:31:56,399
to respond to events that occur on its

00:31:52,799 --> 00:32:02,279
children so here's what we're gonna do

00:31:56,399 --> 00:32:04,220
we're actually show this in action so

00:32:02,279 --> 00:32:08,070
I'm gonna have a couple of different

00:32:04,220 --> 00:32:11,279
scenarios here in scenario one I'm going

00:32:08,070 --> 00:32:15,960
to have one event handler for each

00:32:11,279 --> 00:32:19,129
element in scenario two I'm going to use

00:32:15,960 --> 00:32:22,889
event bubbling and then attach a

00:32:19,129 --> 00:32:25,259
essentially a switch case to my event

00:32:22,889 --> 00:32:27,539
handler to say what did you click on

00:32:25,259 --> 00:32:31,470
oh you clicked on ancestor or rather

00:32:27,539 --> 00:32:34,320
child a then do this and then in case

00:32:31,470 --> 00:32:37,529
three I'm going to have that same kind

00:32:34,320 --> 00:32:40,289
of one-to-one relationship between event

00:32:37,529 --> 00:32:42,330
listeners and objects but this time I'm

00:32:40,289 --> 00:32:45,149
going to use a common function for all

00:32:42,330 --> 00:32:46,350
of them so here's what I've done I've

00:32:45,149 --> 00:32:48,869
just executed the first of those

00:32:46,350 --> 00:32:51,720
scenarios that is one event handler per

00:32:48,869 --> 00:32:55,820
element and I've taken a little snapshot

00:32:51,720 --> 00:32:58,379
of memory now I'm executing scenario two

00:32:55,820 --> 00:33:01,679
this is the one with event bubbling

00:32:58,379 --> 00:33:05,119
where we use a switch case on the top

00:33:01,679 --> 00:33:07,109
level element to identify the actual

00:33:05,119 --> 00:33:09,720
element that it was clicked upon and

00:33:07,109 --> 00:33:12,509
then okay we're taking that snap shot

00:33:09,720 --> 00:33:15,509
now and now snap shot three where we

00:33:12,509 --> 00:33:16,590
actually have an event listener for

00:33:15,509 --> 00:33:19,890
every element

00:33:16,590 --> 00:33:22,110
but it all points to the same common

00:33:19,890 --> 00:33:25,110
eventhandler the same common function

00:33:22,110 --> 00:33:27,000
what I want to point to in this we're

00:33:25,110 --> 00:33:29,640
gonna kind of drag it around here I want

00:33:27,000 --> 00:33:32,309
you to take a look at the retained size

00:33:29,640 --> 00:33:35,520
that's that far column right there so

00:33:32,309 --> 00:33:38,840
look at that 257 K or 8% of the total

00:33:35,520 --> 00:33:41,940
memory is dedicated to the Dom okay

00:33:38,840 --> 00:33:46,200
snapshot - this is the one where we use

00:33:41,940 --> 00:33:50,610
the one-to-one relationship oh man that

00:33:46,200 --> 00:33:53,460
was 468 K and then snapshot one this is

00:33:50,610 --> 00:33:55,380
the one oh that's that that's the bad

00:33:53,460 --> 00:33:58,679
one right that's one two one one event

00:33:55,380 --> 00:34:00,539
handler per object and here we can see

00:33:58,679 --> 00:34:02,610
I'm actually gonna open it up and you'll

00:34:00,539 --> 00:34:08,310
be able to see one event handler per

00:34:02,610 --> 00:34:10,710
object there there it is that native

00:34:08,310 --> 00:34:13,290
function right there that's one per

00:34:10,710 --> 00:34:15,179
object and then in snapshots one and

00:34:13,290 --> 00:34:18,839
three those are the ones where I've got

00:34:15,179 --> 00:34:23,760
a common event handler for each element

00:34:18,839 --> 00:34:27,290
right through that I realize what's here

00:34:23,760 --> 00:34:31,800
I'll rewind it a bit so you can see it

00:34:27,290 --> 00:34:34,470
mmm there we are the 257 there right it

00:34:31,800 --> 00:34:37,589
is about half of the retained memory

00:34:34,470 --> 00:34:40,409
size when I use either a common event

00:34:37,589 --> 00:34:44,099
handler for each event listener or I do

00:34:40,409 --> 00:34:46,220
the handler on the parent element when

00:34:44,099 --> 00:34:49,139
this this it's helpful if you see a

00:34:46,220 --> 00:34:51,210
quick little code example here right so

00:34:49,139 --> 00:34:53,429
for this one bad

00:34:51,210 --> 00:34:56,849
I'm just doing a loop I'm attaching a

00:34:53,429 --> 00:34:59,190
single an event handler to each object

00:34:56,849 --> 00:35:01,580
and each of those event handlers is

00:34:59,190 --> 00:35:05,369
essentially a clone of the one before it

00:35:01,580 --> 00:35:08,369
whereas good I'm attaching an event

00:35:05,369 --> 00:35:11,190
listener to the parent and in this case

00:35:08,369 --> 00:35:12,960
I just use an if statement I could be a

00:35:11,190 --> 00:35:14,550
little bit more sophisticated use a

00:35:12,960 --> 00:35:17,670
switch statement to figure out which

00:35:14,550 --> 00:35:19,830
child I clicked on again that resulted

00:35:17,670 --> 00:35:22,380
in about half of the retained memory

00:35:19,830 --> 00:35:26,640
size a win not only for memory but also

00:35:22,380 --> 00:35:29,690
for your performance so take advantage

00:35:26,640 --> 00:35:29,690
of event bubbling

00:35:29,720 --> 00:35:36,720
pay attention to memory leaks

00:35:32,810 --> 00:35:38,910
okay memory leaks so this is kind of a

00:35:36,720 --> 00:35:41,280
variation of what we saw earlier with

00:35:38,910 --> 00:35:42,840
the event that we left kind of hanging

00:35:41,280 --> 00:35:44,460
on right where we created a lot of

00:35:42,840 --> 00:35:48,480
elements destroy them and left an event

00:35:44,460 --> 00:35:51,600
handler sticking around so in this

00:35:48,480 --> 00:35:53,730
particular one what I'm going to do what

00:35:51,600 --> 00:35:55,530
I'm going to do is I'm going to cycle

00:35:53,730 --> 00:35:57,540
through and create a bunch of elements

00:35:55,530 --> 00:36:00,930
and then for those elements I'm going to

00:35:57,540 --> 00:36:05,310
keep each one of the elements scoped to

00:36:00,930 --> 00:36:07,110
the private function right and this

00:36:05,310 --> 00:36:10,170
first time around because it's scoped to

00:36:07,110 --> 00:36:12,930
the private function those functions and

00:36:10,170 --> 00:36:14,970
those objects will will will be

00:36:12,930 --> 00:36:17,400
destroyed when the function itself is

00:36:14,970 --> 00:36:23,780
destroyed and so here we're gonna launch

00:36:17,400 --> 00:36:23,780
it up there we go here it comes

00:36:28,420 --> 00:36:33,610
little heap snapshot there alright and

00:36:31,330 --> 00:36:35,350
so as I'm navigating from page to page

00:36:33,610 --> 00:36:37,690
what it's essentially doing is creating

00:36:35,350 --> 00:36:40,030
those objects destroying those objects

00:36:37,690 --> 00:36:43,210
creating those objects destroying those

00:36:40,030 --> 00:36:45,010
objects right and as it does so because

00:36:43,210 --> 00:36:47,410
the objects are created as part of the

00:36:45,010 --> 00:36:49,210
private function the objects are

00:36:47,410 --> 00:36:54,160
destroyed with a lifetime of the

00:36:49,210 --> 00:36:56,620
function itself and so here what I want

00:36:54,160 --> 00:36:59,560
you to see look it's a nice clean Dom

00:36:56,620 --> 00:37:02,080
here there are no unparent 'add div

00:36:59,560 --> 00:37:07,000
elements those are all white white is

00:37:02,080 --> 00:37:09,190
good you like white all right now what

00:37:07,000 --> 00:37:11,800
I'm gonna do is I'm gonna switch it up a

00:37:09,190 --> 00:37:14,080
little bit this time just by removing

00:37:11,800 --> 00:37:16,570
the VAR declaration from within the

00:37:14,080 --> 00:37:18,220
function scope I'm immediately putting

00:37:16,570 --> 00:37:20,350
each one of the div elements into the

00:37:18,220 --> 00:37:23,740
global scope because they are in the

00:37:20,350 --> 00:37:26,380
global scope they are not destroyed when

00:37:23,740 --> 00:37:29,580
you destroy the function as well and so

00:37:26,380 --> 00:37:32,500
those will end up hanging around as

00:37:29,580 --> 00:37:34,030
unparent ated Dom fragments sticking

00:37:32,500 --> 00:37:40,960
around in my application so here we go

00:37:34,030 --> 00:37:42,550
we're gonna do the navigation again I'm

00:37:40,960 --> 00:37:45,780
gonna fast forward just a little bit

00:37:42,550 --> 00:37:45,780
there we go

00:37:48,930 --> 00:37:53,410
navigate back and forth once again

00:37:51,010 --> 00:37:55,900
creating destroying each of the

00:37:53,410 --> 00:37:57,280
functions but this time because all of

00:37:55,900 --> 00:37:59,380
my elements are being created in the

00:37:57,280 --> 00:38:01,480
global scope when I create an destroy my

00:37:59,380 --> 00:38:03,160
functions my objects are still sticking

00:38:01,480 --> 00:38:08,170
around my Dom objects are still sticking

00:38:03,160 --> 00:38:12,430
around all right let the snapshot do its

00:38:08,170 --> 00:38:15,730
computational powers and when we expose

00:38:12,430 --> 00:38:17,980
this look at all of that read each one

00:38:15,730 --> 00:38:20,500
of those objects that's marked as kind

00:38:17,980 --> 00:38:22,570
of with a pinkish red background these

00:38:20,500 --> 00:38:25,260
are objects that are just polluting your

00:38:22,570 --> 00:38:30,370
Dom taking up space taking up memory and

00:38:25,260 --> 00:38:32,740
dragging you down right so a good kind

00:38:30,370 --> 00:38:34,660
of check for yourself is run your

00:38:32,740 --> 00:38:37,120
application for a little while go back

00:38:34,660 --> 00:38:39,570
into chrome dev tools see if you can

00:38:37,120 --> 00:38:42,230
find into these objects that are red and

00:38:39,570 --> 00:38:44,930
try and find out where those get created

00:38:42,230 --> 00:38:46,550
how you can destroy them because over

00:38:44,930 --> 00:38:48,800
time they're just going to increase your

00:38:46,550 --> 00:38:52,630
overall memory footprint and ultimately

00:38:48,800 --> 00:38:56,810
drag down your performance as well so

00:38:52,630 --> 00:39:00,190
bad in this particular case we've got

00:38:56,810 --> 00:39:04,010
the element created in the global scope

00:39:00,190 --> 00:39:05,720
outside of the function good we're

00:39:04,010 --> 00:39:07,910
actually creating the element within the

00:39:05,720 --> 00:39:12,440
scope of the function and so it gets

00:39:07,910 --> 00:39:18,320
destroyed with the function destroy all

00:39:12,440 --> 00:39:19,040
your unused objects so we're getting to

00:39:18,320 --> 00:39:22,700
the end of it

00:39:19,040 --> 00:39:27,500
I beg beg of you if you remember

00:39:22,700 --> 00:39:32,119
anything about this talk anyone can

00:39:27,500 --> 00:39:35,780
build slow apps you can you can that guy

00:39:32,119 --> 00:39:36,350
has I know he has back there you can do

00:39:35,780 --> 00:39:38,900
it too

00:39:36,350 --> 00:39:42,200
anyone can build slow apps but you don't

00:39:38,900 --> 00:39:44,660
have to like go into it thinking about

00:39:42,200 --> 00:39:48,140
performance first before it drags you

00:39:44,660 --> 00:39:50,119
down in the end thank you so much once

00:39:48,140 --> 00:39:51,200
again Ryan J Salva come talk to me

00:39:50,119 --> 00:39:53,090
afterwards I'd love to talk to you about

00:39:51,200 --> 00:39:54,440
animation and UI controls and all the

00:39:53,090 --> 00:39:58,609
experiments that I didn't get to share

00:39:54,440 --> 00:40:00,730
with you today thank you so much thank

00:39:58,609 --> 00:40:00,730
you

00:40:01,359 --> 00:40:20,840
you

00:40:02,420 --> 00:40:20,840
[Music]

00:40:23,950 --> 00:40:28,389

YouTube URL: https://www.youtube.com/watch?v=53EJcv2chLo


