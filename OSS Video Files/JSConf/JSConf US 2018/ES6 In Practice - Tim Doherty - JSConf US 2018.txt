Title: ES6 In Practice - Tim Doherty - JSConf US 2018
Publication date: 2018-11-06
Playlist: JSConf US 2018
Description: 
	
Captions: 
	00:00:00,320 --> 00:00:03,840
[Music]

00:00:02,070 --> 00:00:05,660
[Applause]

00:00:03,840 --> 00:00:07,410
[Music]

00:00:05,660 --> 00:00:09,280
[Applause]

00:00:07,410 --> 00:00:11,020
[Music]

00:00:09,280 --> 00:00:12,780
[Applause]

00:00:11,020 --> 00:00:15,920
[Music]

00:00:12,780 --> 00:00:15,920
[Applause]

00:00:16,870 --> 00:00:24,050
[Music]

00:00:25,110 --> 00:00:36,010
hi guys all right I'm gonna take a cue

00:00:33,190 --> 00:00:39,149
from from Laurie stalk and get a selfie

00:00:36,010 --> 00:00:41,890
because pics if it didn't happen

00:00:39,149 --> 00:00:47,440
cool all right so let's talk to you a

00:00:41,890 --> 00:00:48,930
little bit about es6 in practice but

00:00:47,440 --> 00:00:51,850
first a little bit about me

00:00:48,930 --> 00:00:53,560
so I am first and foremost a father a

00:00:51,850 --> 00:00:56,560
stepfather and a husband

00:00:53,560 --> 00:00:59,860
I run Santa Barbara JavaScript which is

00:00:56,560 --> 00:01:01,930
our local meetup up in Santa Barbara as

00:00:59,860 --> 00:01:04,689
Sonia mentioned I'm an avid scuba diver

00:01:01,930 --> 00:01:07,750
and underwater photographer and I'm

00:01:04,689 --> 00:01:09,070
president of paradise dive Club I've

00:01:07,750 --> 00:01:11,229
been building and shipping software

00:01:09,070 --> 00:01:13,180
professionally for a little over two

00:01:11,229 --> 00:01:15,040
decades now and I'm currently staff

00:01:13,180 --> 00:01:16,810
engineer at pro core technologies

00:01:15,040 --> 00:01:19,299
building a software that builds the

00:01:16,810 --> 00:01:20,890
world it is I can say hands-down the

00:01:19,299 --> 00:01:22,479
best job I've ever had we're always

00:01:20,890 --> 00:01:23,920
looking for good people so see me in the

00:01:22,479 --> 00:01:26,680
hallway if you're interested we'll talk

00:01:23,920 --> 00:01:28,060
more all right so enough about me before

00:01:26,680 --> 00:01:29,409
we dig into es6

00:01:28,060 --> 00:01:31,390
before we find out what this is all

00:01:29,409 --> 00:01:33,640
about let's take a moment for a brief

00:01:31,390 --> 00:01:37,330
history of the language so in the

00:01:33,640 --> 00:01:39,930
beginning there was mocha and it was

00:01:37,330 --> 00:01:42,100
released and they called it live script

00:01:39,930 --> 00:01:45,400
but the marketing gods had to be

00:01:42,100 --> 00:01:46,150
appeased and recruiters weren't confused

00:01:45,400 --> 00:01:50,290
enough already

00:01:46,150 --> 00:01:51,869
so they renamed it javascript and they

00:01:50,290 --> 00:01:55,450
saw that it was good

00:01:51,869 --> 00:01:57,759
so they standardized it but javascript

00:01:55,450 --> 00:02:00,900
was a registered trademark of netscape

00:01:57,759 --> 00:02:03,790
corporation so how about web script or

00:02:00,900 --> 00:02:05,259
maybe browser script or Brendan Eich

00:02:03,790 --> 00:02:07,810
site scheme as one of the major

00:02:05,259 --> 00:02:09,549
influences on the language well maybe

00:02:07,810 --> 00:02:10,060
instead let's call it something really

00:02:09,549 --> 00:02:12,970
nasty

00:02:10,060 --> 00:02:16,360
sounds like eczema what we ended up with

00:02:12,970 --> 00:02:17,739
was ACMA script magma for those who

00:02:16,360 --> 00:02:19,270
don't know is the european computer

00:02:17,739 --> 00:02:21,540
manufacturers association they're the

00:02:19,270 --> 00:02:24,280
standardizing body manages ekam script

00:02:21,540 --> 00:02:26,770
so we got actor script one

00:02:24,280 --> 00:02:28,960
and then we got version two and then we

00:02:26,770 --> 00:02:32,560
got version three and then we got

00:02:28,960 --> 00:02:35,620
version four well actually version four

00:02:32,560 --> 00:02:38,170
didn't happen the eat the committee the

00:02:35,620 --> 00:02:39,520
tc39 committee split into warring

00:02:38,170 --> 00:02:41,800
factions and couldn't agree on what

00:02:39,520 --> 00:02:44,800
should be in yes four but they

00:02:41,800 --> 00:02:46,480
eventually extended an olive branch and

00:02:44,800 --> 00:02:48,910
came up with a compromise that ended up

00:02:46,480 --> 00:02:53,950
being version five and then we got

00:02:48,910 --> 00:02:56,980
version 2015 wait what the actual name

00:02:53,950 --> 00:02:58,930
of the language is act math two six two

00:02:56,980 --> 00:03:00,670
fifth edition six edition sorry echo

00:02:58,930 --> 00:03:03,040
script 2015 it rolls right off the

00:03:00,670 --> 00:03:06,130
tongue regardless of what it's called

00:03:03,040 --> 00:03:09,370
it made a big splash and people were

00:03:06,130 --> 00:03:13,090
really excited about this new spec but

00:03:09,370 --> 00:03:14,560
why did I care well I've been using Java

00:03:13,090 --> 00:03:17,410
scripts into the first game Allen in

00:03:14,560 --> 00:03:19,840
1995 and I've been following the spec

00:03:17,410 --> 00:03:22,180
for a while and was really interested in

00:03:19,840 --> 00:03:25,209
getting in on this new hotness so I

00:03:22,180 --> 00:03:27,910
figured like most things the best way to

00:03:25,209 --> 00:03:29,080
learn it was to teach so I went back to

00:03:27,910 --> 00:03:31,330
my JavaScript meet up and gave a

00:03:29,080 --> 00:03:33,459
three-part series of in-depth talks and

00:03:31,330 --> 00:03:35,890
hands-on coding exercises to learn es6

00:03:33,459 --> 00:03:38,650
and then with a head full of knowledge I

00:03:35,890 --> 00:03:41,560
got the bright idea to introduce the s6

00:03:38,650 --> 00:03:43,870
to the enterprise nope not that

00:03:41,560 --> 00:03:45,790
enterprise this kind of enterprise and

00:03:43,870 --> 00:03:47,530
those of you who have worked in an

00:03:45,790 --> 00:03:50,140
enterprise software company know that we

00:03:47,530 --> 00:03:51,250
often do things by committee into the

00:03:50,140 --> 00:03:52,630
case of my last employer

00:03:51,250 --> 00:03:55,060
this meant the enterprise software

00:03:52,630 --> 00:03:56,890
architecture committee comprised mostly

00:03:55,060 --> 00:04:00,160
of former and current back-end

00:03:56,890 --> 00:04:03,100
developers whose default stances Java

00:04:00,160 --> 00:04:05,079
Script sucks so needless to say they

00:04:03,100 --> 00:04:06,430
were dubious and they asked me lots of

00:04:05,079 --> 00:04:09,070
questions like can't we just wait until

00:04:06,430 --> 00:04:12,519
the specs fully implemented then I was

00:04:09,070 --> 00:04:14,829
like well we could but this is not like

00:04:12,519 --> 00:04:17,140
the rollout of es5 for one thing

00:04:14,829 --> 00:04:18,669
browsers are evergreen now and we have

00:04:17,140 --> 00:04:20,709
amazing tools like Babel that will let

00:04:18,669 --> 00:04:22,930
us use the features of tomorrow today

00:04:20,709 --> 00:04:27,850
but there was still a lot of fear

00:04:22,930 --> 00:04:31,090
uncertainty doubt so I waited and I

00:04:27,850 --> 00:04:32,470
evangelized every moment I could and I

00:04:31,090 --> 00:04:34,000
waited some more until finally one day

00:04:32,470 --> 00:04:35,200
in one of these meetings of the

00:04:34,000 --> 00:04:37,650
enterprise software architecture

00:04:35,200 --> 00:04:40,360
committee es6 was approved

00:04:37,650 --> 00:04:42,070
well at that point I was really

00:04:40,360 --> 00:04:43,870
interested in having teams opt in

00:04:42,070 --> 00:04:46,750
without worrying about the plumbing and

00:04:43,870 --> 00:04:48,430
we were using grunt at the time with

00:04:46,750 --> 00:04:50,170
lots of duplicated configs across

00:04:48,430 --> 00:04:51,910
applications there was already an effort

00:04:50,170 --> 00:04:53,860
underway to consolidate those config so

00:04:51,910 --> 00:04:55,750
I piggybacked on that we published an

00:04:53,860 --> 00:05:01,150
NPM package the teams could install and

00:04:55,750 --> 00:05:03,790
get es6 features for free oh all good

00:05:01,150 --> 00:05:05,770
right well that time we were also

00:05:03,790 --> 00:05:07,870
weaning ourselves off Bower which was

00:05:05,770 --> 00:05:09,760
the dominant package manager for the

00:05:07,870 --> 00:05:12,910
client at the time and we decided to

00:05:09,760 --> 00:05:14,740
move to JSP m which is a noble that

00:05:12,910 --> 00:05:16,600
failed experiment and poly filling

00:05:14,740 --> 00:05:18,970
module loading in the browser

00:05:16,600 --> 00:05:20,650
the problem with JSP m is that not only

00:05:18,970 --> 00:05:22,210
does it want to load modules in the

00:05:20,650 --> 00:05:23,560
browser I wants to transpile them there

00:05:22,210 --> 00:05:27,790
as well which you might imagine is

00:05:23,560 --> 00:05:30,520
really slow but at Build time it uses

00:05:27,790 --> 00:05:32,230
node uses babel and it's fast so I just

00:05:30,520 --> 00:05:33,880
offset the transpiling

00:05:32,230 --> 00:05:36,310
to grunt and I have grunt and Babel for

00:05:33,880 --> 00:05:38,080
development and JSP and babble at Build

00:05:36,310 --> 00:05:39,760
time so now my developers are pumped

00:05:38,080 --> 00:05:42,010
everyone stoked we're ready to conquer

00:05:39,760 --> 00:05:45,130
the world but there's still one problem

00:05:42,010 --> 00:05:47,170
and that is most of them haven't been

00:05:45,130 --> 00:05:48,700
following the spec like I have and some

00:05:47,170 --> 00:05:50,620
of them don't even know that es6 is a

00:05:48,700 --> 00:05:54,100
thing so I put my teaching hat back on

00:05:50,620 --> 00:05:56,590
and I gave a condensed version of es6 in

00:05:54,100 --> 00:05:58,300
depth for the enterprise then I used

00:05:56,590 --> 00:06:01,000
code reviews as an opportunity to

00:05:58,300 --> 00:06:02,280
suggest es6 syntax and features to solve

00:06:01,000 --> 00:06:05,140
problems that were already on the table

00:06:02,280 --> 00:06:07,240
slowly but surely it started to sink in

00:06:05,140 --> 00:06:10,930
until a couple of months later our first

00:06:07,240 --> 00:06:12,780
es6 code was deployed to production so

00:06:10,930 --> 00:06:15,660
what's the big deal who cares

00:06:12,780 --> 00:06:17,940
well we're talking about javascript

00:06:15,660 --> 00:06:20,320
javascript is arguably the most

00:06:17,940 --> 00:06:23,620
misunderstood language in widespread use

00:06:20,320 --> 00:06:25,780
it's also arguably the most important by

00:06:23,620 --> 00:06:28,600
virtue of its magnitude of deployment

00:06:25,780 --> 00:06:30,400
alone it's not just in browsers anymore

00:06:28,600 --> 00:06:32,350
it's been for a while now viable on the

00:06:30,400 --> 00:06:34,630
server it's a first-class citizen in

00:06:32,350 --> 00:06:36,310
databases automation tools and even

00:06:34,630 --> 00:06:39,250
operating systems at this point and it's

00:06:36,310 --> 00:06:41,340
the undisputed king of the web and it

00:06:39,250 --> 00:06:43,930
continues to eat the rest of the world

00:06:41,340 --> 00:06:46,060
so let's talk about what's new what's in

00:06:43,930 --> 00:06:47,860
es6 so this was the first major update

00:06:46,060 --> 00:06:50,170
in the languages history really since

00:06:47,860 --> 00:06:51,430
1995 and you can break down the updates

00:06:50,170 --> 00:06:54,400
into three broad categories

00:06:51,430 --> 00:06:56,410
the first is syntax so this is new ways

00:06:54,400 --> 00:06:58,449
of expressing existing behavior that the

00:06:56,410 --> 00:07:02,080
language already has we get things like

00:06:58,449 --> 00:07:05,710
rest spread D structuring block scoping

00:07:02,080 --> 00:07:07,300
arrow functions and modules the second

00:07:05,710 --> 00:07:09,490
broad category of updates are

00:07:07,300 --> 00:07:11,080
enhancements so these are ants mints -

00:07:09,490 --> 00:07:12,520
built-ins or the standard library in

00:07:11,080 --> 00:07:15,460
JavaScript so we get some updates to

00:07:12,520 --> 00:07:17,770
strings and arrays and objects amongst

00:07:15,460 --> 00:07:19,750
others and then the last broad category

00:07:17,770 --> 00:07:21,250
of updates are entirely new features and

00:07:19,750 --> 00:07:22,960
I'm going to argue later that this is

00:07:21,250 --> 00:07:25,199
where the real meat and potatoes of es6

00:07:22,960 --> 00:07:29,320
live these are things like symbols

00:07:25,199 --> 00:07:31,449
generators proxies and promises it's big

00:07:29,320 --> 00:07:33,370
it's a really large update again this

00:07:31,449 --> 00:07:35,320
was the first major update in 20 years

00:07:33,370 --> 00:07:36,880
of the language can't possibly cover all

00:07:35,320 --> 00:07:38,289
of it today so I'm gonna talk about the

00:07:36,880 --> 00:07:38,860
things that I think are kind of

00:07:38,289 --> 00:07:43,330
important

00:07:38,860 --> 00:07:44,949
starting with syntax so we get a you

00:07:43,330 --> 00:07:46,960
know a step forward and what we got in

00:07:44,949 --> 00:07:48,460
the s5 with the object literal syntax we

00:07:46,960 --> 00:07:50,020
get method and property shorthands

00:07:48,460 --> 00:07:52,050
computed properties these are a

00:07:50,020 --> 00:07:54,639
no-brainer most teams have adopted these

00:07:52,050 --> 00:07:56,470
we get default arguments that let you

00:07:54,639 --> 00:07:58,690
provide a default for function arguments

00:07:56,470 --> 00:07:59,979
there with me I know most modern

00:07:58,690 --> 00:08:03,340
programming languages have default

00:07:59,979 --> 00:08:04,690
arguments already but javis could we get

00:08:03,340 --> 00:08:07,000
this nice little dot dot dot operator

00:08:04,690 --> 00:08:09,909
and this guy has a split personality

00:08:07,000 --> 00:08:12,250
its first personality is rest which

00:08:09,909 --> 00:08:14,560
means it gathers the rest of a functions

00:08:12,250 --> 00:08:16,930
arguments together into a true array and

00:08:14,560 --> 00:08:18,550
lets you do real array options or

00:08:16,930 --> 00:08:20,800
operations on this without borrowing

00:08:18,550 --> 00:08:22,720
from a radar prototype so let you do

00:08:20,800 --> 00:08:24,909
things like manipulate an array and then

00:08:22,720 --> 00:08:26,260
call a base function right went the

00:08:24,909 --> 00:08:29,919
opposite of the default value for

00:08:26,260 --> 00:08:31,630
example now it's second personality is

00:08:29,919 --> 00:08:34,779
spread which does the opposite it

00:08:31,630 --> 00:08:36,880
spreads out elements in a collection if

00:08:34,779 --> 00:08:38,169
you will here's an array with the spread

00:08:36,880 --> 00:08:40,060
operator being used I haven't actually

00:08:38,169 --> 00:08:42,159
seen this a lot in production last three

00:08:40,060 --> 00:08:43,810
years now but it can also be used to

00:08:42,159 --> 00:08:47,050
spread out the arguments to a function

00:08:43,810 --> 00:08:49,690
so we see that same example before if

00:08:47,050 --> 00:08:51,250
you don't need to provide the value of

00:08:49,690 --> 00:08:54,310
this it's an alternative to apply

00:08:51,250 --> 00:08:57,190
function dot apply okay let's talk about

00:08:54,310 --> 00:08:58,750
the structuring or more concisely D

00:08:57,190 --> 00:09:00,640
structuring assignment this feature was

00:08:58,750 --> 00:09:02,170
by kind of widely criticised where all

00:09:00,640 --> 00:09:03,750
the spec was being worked on mostly due

00:09:02,170 --> 00:09:05,550
to examples like this

00:09:03,750 --> 00:09:07,529
don't really give any value and just

00:09:05,550 --> 00:09:09,269
make the code even more opaque and hard

00:09:07,529 --> 00:09:10,949
to read but I think most people would

00:09:09,269 --> 00:09:13,199
agree that this is a really readable

00:09:10,949 --> 00:09:15,389
syntax this is widespread D structuring

00:09:13,199 --> 00:09:17,790
of the named exports of a module it's

00:09:15,389 --> 00:09:20,790
also a common pattern and react to D

00:09:17,790 --> 00:09:22,350
structure props and you can actually

00:09:20,790 --> 00:09:25,110
combine this with default function

00:09:22,350 --> 00:09:29,730
arguments for a really concise and

00:09:25,110 --> 00:09:32,160
expressive way to provide sort of you

00:09:29,730 --> 00:09:33,420
know a consistent API for functions if

00:09:32,160 --> 00:09:35,699
you will Doug Crockford is really big

00:09:33,420 --> 00:09:39,240
onto this pattern let's talk about block

00:09:35,699 --> 00:09:41,670
scoping so up until 2015 we had exactly

00:09:39,240 --> 00:09:44,160
two scopes in JavaScript global scope

00:09:41,670 --> 00:09:46,410
and the lexical of function scope so

00:09:44,160 --> 00:09:48,629
even though curly brackets like this is

00:09:46,410 --> 00:09:50,370
a perfectly valid block in es5 this

00:09:48,629 --> 00:09:51,990
doesn't do anything the variable name is

00:09:50,370 --> 00:09:55,439
hoisted and just gets reassigned

00:09:51,990 --> 00:09:57,180
but in es6 with the let operator we

00:09:55,439 --> 00:09:58,410
actually get block scoping it doesn't

00:09:57,180 --> 00:10:00,329
look like this would be useful but it

00:09:58,410 --> 00:10:01,889
this can actually replace the if e or

00:10:00,329 --> 00:10:03,240
immediately vote function expression if

00:10:01,889 --> 00:10:07,309
you need to do setup without polluting

00:10:03,240 --> 00:10:10,709
the global scope the other block scope

00:10:07,309 --> 00:10:12,149
right before we move on to that the

00:10:10,709 --> 00:10:14,550
other thing this can solve although I

00:10:12,149 --> 00:10:16,410
still don't recommend doing this is the

00:10:14,550 --> 00:10:18,029
problem you get with creating functions

00:10:16,410 --> 00:10:20,309
in a loop this is the classic closure

00:10:18,029 --> 00:10:21,750
problem and this is a question that I've

00:10:20,309 --> 00:10:23,129
given in interviews in the past quite a

00:10:21,750 --> 00:10:24,959
bit and people have given me about

00:10:23,129 --> 00:10:26,160
it because it's a contrived example I'm

00:10:24,959 --> 00:10:28,790
never going to see code like this in

00:10:26,160 --> 00:10:30,809
production but I got vindicated when a

00:10:28,790 --> 00:10:32,550
problem just like this came up in

00:10:30,809 --> 00:10:34,170
production and the dev who found it and

00:10:32,550 --> 00:10:35,399
the only reason I recognized it so fast

00:10:34,170 --> 00:10:36,990
because it's because it looked like

00:10:35,399 --> 00:10:38,490
Tim's interview question but those who

00:10:36,990 --> 00:10:40,500
don't know this is basically going to

00:10:38,490 --> 00:10:42,839
close over the variable I and every

00:10:40,500 --> 00:10:44,459
function that gets executed in that

00:10:42,839 --> 00:10:47,639
array will be the value of five at the

00:10:44,459 --> 00:10:50,550
end which is five the value of I so in

00:10:47,639 --> 00:10:52,559
es5 or below the only way to solve this

00:10:50,550 --> 00:10:54,779
is to force a valuation of that variable

00:10:52,559 --> 00:10:58,410
during the iteration either with an e or

00:10:54,779 --> 00:11:00,000
a separate function in es6 block scoping

00:10:58,410 --> 00:11:02,069
will create a new instance of that

00:11:00,000 --> 00:11:03,930
variable every time again I don't

00:11:02,069 --> 00:11:05,129
recommend that you do this but this can

00:11:03,930 --> 00:11:07,110
solve the problems worried if you find

00:11:05,129 --> 00:11:08,939
yourself in that position the other

00:11:07,110 --> 00:11:11,069
block scoped operator would get as Const

00:11:08,939 --> 00:11:14,009
which presumably is short for constant

00:11:11,069 --> 00:11:16,350
and we would be I think reasonable and

00:11:14,009 --> 00:11:19,380
assuming that a constant

00:11:16,350 --> 00:11:21,210
mutated but we'd be wrong because const

00:11:19,380 --> 00:11:23,160
is not immutable accounts is only a

00:11:21,210 --> 00:11:25,050
mutable assignment not a mutable value

00:11:23,160 --> 00:11:27,000
right so any of the properties of an

00:11:25,050 --> 00:11:29,220
object that are not primitive can be

00:11:27,000 --> 00:11:32,850
mutated it's more of a signal of intent

00:11:29,220 --> 00:11:34,380
than actual immutability arrow functions

00:11:32,850 --> 00:11:36,090
are important not just because they

00:11:34,380 --> 00:11:37,680
provide a nice concise syntax there's an

00:11:36,090 --> 00:11:38,910
actual use cases for them Brendan Eich

00:11:37,680 --> 00:11:40,230
has said that if he could change one

00:11:38,910 --> 00:11:41,220
thing about JavaScript when it first

00:11:40,230 --> 00:11:43,470
came out it would be the function

00:11:41,220 --> 00:11:45,510
keyword because it's servos we've got

00:11:43,470 --> 00:11:47,220
various different flavors of them and in

00:11:45,510 --> 00:11:49,560
my opinion they're useful in three

00:11:47,220 --> 00:11:51,360
different use cases the first is they're

00:11:49,560 --> 00:11:52,680
really good for terse callbacks so when

00:11:51,360 --> 00:11:54,090
you're doing a rein manipulation or

00:11:52,680 --> 00:11:55,320
promise chaining things like that they

00:11:54,090 --> 00:11:58,650
really shine make the code a lot more

00:11:55,320 --> 00:12:00,090
readable the second is they retain the

00:11:58,650 --> 00:12:01,830
value of this from their enclosing

00:12:00,090 --> 00:12:03,660
lexical scope so you don't need to do

00:12:01,830 --> 00:12:05,370
crazy things like bar that equals this

00:12:03,660 --> 00:12:07,140
or function that binds are still valid

00:12:05,370 --> 00:12:09,860
use cases for function dot bind and the

00:12:07,140 --> 00:12:12,180
third is that it really shines for

00:12:09,860 --> 00:12:13,650
currying or partial application this

00:12:12,180 --> 00:12:16,350
gives you a really terse and readable

00:12:13,650 --> 00:12:17,910
syntax but as tempting as it is to use

00:12:16,350 --> 00:12:19,350
error functions everywhere you can use

00:12:17,910 --> 00:12:21,210
function declaration there's a reason

00:12:19,350 --> 00:12:22,800
why function function declarations are

00:12:21,210 --> 00:12:23,660
still around they are not a golden

00:12:22,800 --> 00:12:26,280
hammer

00:12:23,660 --> 00:12:28,350
first off they can't be hoisted now this

00:12:26,280 --> 00:12:30,030
is not as much of an issue now that we

00:12:28,350 --> 00:12:31,530
have actual block scoping but if you're

00:12:30,030 --> 00:12:33,240
introducing us into a legacy code base

00:12:31,530 --> 00:12:35,040
it's it's a foot gun to look out for and

00:12:33,240 --> 00:12:38,220
the other thing is they can't be back

00:12:35,040 --> 00:12:40,170
bound I mentioned function bind these

00:12:38,220 --> 00:12:41,730
are functions they inherit from function

00:12:40,170 --> 00:12:43,590
prototype this is a perfectly legal

00:12:41,730 --> 00:12:44,880
operation just won't do anything it

00:12:43,590 --> 00:12:46,350
won't actually change the value of this

00:12:44,880 --> 00:12:49,140
there will always be the value of this

00:12:46,350 --> 00:12:50,670
from the closing lexical scope okay

00:12:49,140 --> 00:12:52,170
template literals give us a really nice

00:12:50,670 --> 00:12:53,790
concise syntax for variable

00:12:52,170 --> 00:12:55,470
interpolation we used to do lots of

00:12:53,790 --> 00:12:57,540
tricks like this in the s52 tokenize a

00:12:55,470 --> 00:12:59,850
string just by borrowing join from array

00:12:57,540 --> 00:13:00,960
and passing your token as the argument

00:12:59,850 --> 00:13:02,610
to it now we get something that actually

00:13:00,960 --> 00:13:03,420
signifies the intent and is a little

00:13:02,610 --> 00:13:06,360
easier to read

00:13:03,420 --> 00:13:07,830
they also potentially can replace even

00:13:06,360 --> 00:13:09,390
the simplest of templating libraries a

00:13:07,830 --> 00:13:11,670
lot of people don't even realize that

00:13:09,390 --> 00:13:13,350
lodash and its predecessor underscore

00:13:11,670 --> 00:13:15,180
actually have a micro templating engine

00:13:13,350 --> 00:13:16,530
included it's the one you use when you

00:13:15,180 --> 00:13:18,660
don't want to reach for handlebars to

00:13:16,530 --> 00:13:20,820
mustache or something heavier weight but

00:13:18,660 --> 00:13:22,950
with es6 we can almost entirely drop

00:13:20,820 --> 00:13:24,870
this and when you bring in multi-line

00:13:22,950 --> 00:13:25,950
string support and tagged template

00:13:24,870 --> 00:13:27,480
functions which i'm not going to cover

00:13:25,950 --> 00:13:29,280
here but basically it allows you gives

00:13:27,480 --> 00:13:30,150
you a way of parsing the strings and

00:13:29,280 --> 00:13:32,250
tokens that are passed

00:13:30,150 --> 00:13:34,980
into a template you can write your own

00:13:32,250 --> 00:13:36,240
templating engine natively and the last

00:13:34,980 --> 00:13:38,460
thing that they can do is potentially

00:13:36,240 --> 00:13:40,200
solve this double versus single quotes

00:13:38,460 --> 00:13:41,430
thing once and for all if you just put

00:13:40,200 --> 00:13:43,020
back takes everywhere in your codebase

00:13:41,430 --> 00:13:44,820
you get rid of that you also get

00:13:43,020 --> 00:13:47,910
character escaping multi-line strings

00:13:44,820 --> 00:13:49,200
and all that great stuff for free and

00:13:47,910 --> 00:13:53,490
last syntax thing I want to talk about

00:13:49,200 --> 00:13:55,590
is modules so JavaScript up until 2015

00:13:53,490 --> 00:13:57,150
was basically the only widespread modern

00:13:55,590 --> 00:13:59,730
programming language with no concept of

00:13:57,150 --> 00:14:01,050
a module system now your modules are a

00:13:59,730 --> 00:14:02,870
great best practice they help us

00:14:01,050 --> 00:14:06,720
structure our code and have a proper

00:14:02,870 --> 00:14:07,980
dependency tree but javascript has had

00:14:06,720 --> 00:14:09,390
new modules and its twenty-year history

00:14:07,980 --> 00:14:11,220
to this point so the community has been

00:14:09,390 --> 00:14:12,870
really creative in stepping in to fill

00:14:11,220 --> 00:14:14,970
this gap with things like object name

00:14:12,870 --> 00:14:16,800
spacing the immediately invoked function

00:14:14,970 --> 00:14:18,360
expression or a variant of that which is

00:14:16,800 --> 00:14:20,640
the JavaScript module pattern on the

00:14:18,360 --> 00:14:22,620
server we got common Jas and its brother

00:14:20,640 --> 00:14:24,930
on the client the asynchronous module

00:14:22,620 --> 00:14:26,670
definition as embodied by required Jas

00:14:24,930 --> 00:14:29,370
but my personal favorite is script tag

00:14:26,670 --> 00:14:31,410
vomit es6

00:14:29,370 --> 00:14:34,140
gives us native modules with all of

00:14:31,410 --> 00:14:35,670
their glory right and it's awesome right

00:14:34,140 --> 00:14:37,860
there's just one problem and that is

00:14:35,670 --> 00:14:40,440
that while the syntax made the cut for

00:14:37,860 --> 00:14:42,690
the es expect a loader did not so we

00:14:40,440 --> 00:14:44,490
have no way until now and I'll touch on

00:14:42,690 --> 00:14:46,890
that later to load modules in the

00:14:44,490 --> 00:14:47,880
browser so again the community stepped

00:14:46,890 --> 00:14:50,130
up to the plate and gave us some

00:14:47,880 --> 00:14:52,110
incredible tools to do this right to

00:14:50,130 --> 00:14:53,670
parse the dependency tree and turn these

00:14:52,110 --> 00:14:56,430
into something that's consumable by a

00:14:53,670 --> 00:14:59,010
browser and some of these do additional

00:14:56,430 --> 00:15:04,080
things like static analysis and tree

00:14:59,010 --> 00:15:06,180
shaking now module loading natively has

00:15:04,080 --> 00:15:08,250
just dropped in most major browsers you

00:15:06,180 --> 00:15:11,700
can actually load modules without a

00:15:08,250 --> 00:15:13,590
polyfill or bundler but traversing a

00:15:11,700 --> 00:15:15,150
dependency tree have a large JavaScript

00:15:13,590 --> 00:15:17,010
application and actually fetching all

00:15:15,150 --> 00:15:18,720
those over HTTP it's prohibitively

00:15:17,010 --> 00:15:21,930
expensive so I think you know for the

00:15:18,720 --> 00:15:23,640
time being until HTTP 2 and aggressive

00:15:21,930 --> 00:15:25,320
module caching or rolled out widely

00:15:23,640 --> 00:15:27,900
across the web bundling is probably

00:15:25,320 --> 00:15:29,130
still the future ok we've talked about

00:15:27,900 --> 00:15:31,620
syntax let's talk about some

00:15:29,130 --> 00:15:33,090
enhancements so we got you know a good

00:15:31,620 --> 00:15:34,620
set of enhancements to the standard

00:15:33,090 --> 00:15:36,960
library of JavaScript what we like to

00:15:34,620 --> 00:15:38,940
refer as built-in objects starting with

00:15:36,960 --> 00:15:42,090
strings string got a handful most of

00:15:38,940 --> 00:15:43,950
these are more about the semantics and

00:15:42,090 --> 00:15:46,020
what the expression of intent

00:15:43,950 --> 00:15:48,380
any kind of real syntax saving although

00:15:46,020 --> 00:15:51,140
stringing out ends red gives you both

00:15:48,380 --> 00:15:53,340
array gives us a few additional

00:15:51,140 --> 00:15:55,560
enhancements I think the most important

00:15:53,340 --> 00:15:57,210
of which are find and find index they

00:15:55,560 --> 00:15:59,280
let us kind of reduce our dependency on

00:15:57,210 --> 00:16:00,140
libraries like low - an underscore to do

00:15:59,280 --> 00:16:02,550
that for us

00:16:00,140 --> 00:16:05,070
number got some enhancements and most of

00:16:02,550 --> 00:16:06,780
these actually are just moving the local

00:16:05,070 --> 00:16:10,110
functions off the window object into a

00:16:06,780 --> 00:16:11,490
named module number math got some

00:16:10,110 --> 00:16:13,920
significant enhancements and I'm gonna

00:16:11,490 --> 00:16:15,090
just put a disclaimer that well some of

00:16:13,920 --> 00:16:17,970
you in the room may use these on a

00:16:15,090 --> 00:16:19,470
regular basis I don't and impostor

00:16:17,970 --> 00:16:20,520
syndrome be damned I'm not afraid to

00:16:19,470 --> 00:16:23,010
admit that they're pretty much just

00:16:20,520 --> 00:16:24,780
Greek to me all right object got one

00:16:23,010 --> 00:16:26,340
functional enhancement but it's an

00:16:24,780 --> 00:16:28,110
important one and that's object out of

00:16:26,340 --> 00:16:31,290
sign it lets us do mix-ins

00:16:28,110 --> 00:16:33,210
natively super cool super easy to

00:16:31,290 --> 00:16:35,400
understand there are some caveats though

00:16:33,210 --> 00:16:38,460
you want to be careful first off its not

00:16:35,400 --> 00:16:40,740
immutable so anything in that target

00:16:38,460 --> 00:16:42,180
object any sorry in the source object

00:16:40,740 --> 00:16:44,490
that is not a primitive type will be

00:16:42,180 --> 00:16:46,890
copying by reference so just be careful

00:16:44,490 --> 00:16:48,540
the other is you won't copy properties

00:16:46,890 --> 00:16:49,800
that aren't its own so it won't traverse

00:16:48,540 --> 00:16:51,690
the dependency tree up the prototype

00:16:49,800 --> 00:16:55,200
train if you need that you need a little

00:16:51,690 --> 00:16:56,760
extra work on your own alright so we've

00:16:55,200 --> 00:16:58,020
talked about syntax we've talked about

00:16:56,760 --> 00:17:00,000
enhancements all that stuff's great

00:16:58,020 --> 00:17:02,150
there's some really good syntax sugar

00:17:00,000 --> 00:17:05,010
there's a nice shortcuts tercer code etc

00:17:02,150 --> 00:17:07,230
but ultimately in my opinion the really

00:17:05,010 --> 00:17:08,640
important category of updates are the

00:17:07,230 --> 00:17:10,650
brand-new features this is what I call

00:17:08,640 --> 00:17:12,990
the good stuff in es6 starting with

00:17:10,650 --> 00:17:15,420
symbols symbols are a new primitive type

00:17:12,990 --> 00:17:17,730
and their primary purpose is to provide

00:17:15,420 --> 00:17:19,770
unique and mutable identifiers for

00:17:17,730 --> 00:17:21,570
well-known methods and the primary

00:17:19,770 --> 00:17:24,240
target audience of browser vendors that

00:17:21,570 --> 00:17:27,000
are implementing built-ins so in the

00:17:24,240 --> 00:17:29,130
absence of static typing in interfaces

00:17:27,000 --> 00:17:31,530
and access modifiers in JavaScript these

00:17:29,130 --> 00:17:34,650
provide us a way of predictably defining

00:17:31,530 --> 00:17:35,400
expected behaviors on objects semantics

00:17:34,650 --> 00:17:36,960
are pretty simple

00:17:35,400 --> 00:17:38,580
we call this symbol function it's

00:17:36,960 --> 00:17:40,950
actually not a constructor despite the

00:17:38,580 --> 00:17:43,740
capital S we get back this immutable

00:17:40,950 --> 00:17:45,780
unique symbol here we're using computed

00:17:43,740 --> 00:17:47,550
syntax on an object computed property

00:17:45,780 --> 00:17:48,960
syntax to reference it and then we get a

00:17:47,550 --> 00:17:50,850
nice accompanying little reflection

00:17:48,960 --> 00:17:53,340
method to inspect the symbols on an

00:17:50,850 --> 00:17:55,260
object one of the side effects of this

00:17:53,340 --> 00:17:56,730
are one of the interesting side cases

00:17:55,260 --> 00:17:57,290
aside from its main one is you can

00:17:56,730 --> 00:17:59,240
actually at

00:17:57,290 --> 00:18:01,640
true privacy so here we've got a closure

00:17:59,240 --> 00:18:03,560
that returns a constructor and in that

00:18:01,640 --> 00:18:05,600
closure we create a new symbol and then

00:18:03,560 --> 00:18:06,980
every constructor every instance created

00:18:05,600 --> 00:18:09,940
from that constructor gets a truly

00:18:06,980 --> 00:18:14,420
private property keyed by that symbol

00:18:09,940 --> 00:18:17,480
all right next up is irritable or maybe

00:18:14,420 --> 00:18:19,400
iterables iterables is a new interface

00:18:17,480 --> 00:18:21,440
in JavaScript we don't have interfaces

00:18:19,400 --> 00:18:23,600
in JavaScript but it's a contract and

00:18:21,440 --> 00:18:25,610
all of the built-in collections array

00:18:23,600 --> 00:18:27,860
strings which are just collections of

00:18:25,610 --> 00:18:30,290
characters and the new datatypes map and

00:18:27,860 --> 00:18:33,070
set they all implement this so here for

00:18:30,290 --> 00:18:35,200
example is the iterator or irritable

00:18:33,070 --> 00:18:37,340
irritable the iterable interface

00:18:35,200 --> 00:18:39,140
implemented on an array and you

00:18:37,340 --> 00:18:40,010
basically just get an iterator back by

00:18:39,140 --> 00:18:41,780
calling a method

00:18:40,010 --> 00:18:43,820
he'd by the well-known symbol symbol

00:18:41,780 --> 00:18:47,090
iterator and then you call next on it

00:18:43,820 --> 00:18:48,530
until it's done kind of verbose there's

00:18:47,090 --> 00:18:50,210
easier ways to consume it and we

00:18:48,530 --> 00:18:52,160
actually got a couple of new syntaxes in

00:18:50,210 --> 00:18:54,560
es6 to consume this one of which is four

00:18:52,160 --> 00:18:56,210
of four of is like four in on objects

00:18:54,560 --> 00:18:58,880
only instead of going over keys it

00:18:56,210 --> 00:19:00,860
returns the values and then the spread

00:18:58,880 --> 00:19:03,530
operator that we've already seen also

00:19:00,860 --> 00:19:04,910
will consume any interval so here we're

00:19:03,530 --> 00:19:07,130
going to call the symbol iterator method

00:19:04,910 --> 00:19:08,810
on a string get that consider ATAR and

00:19:07,130 --> 00:19:10,100
consume it with the spread operator it's

00:19:08,810 --> 00:19:15,430
like string dot split with a lot more

00:19:10,100 --> 00:19:19,400
characters so you can implement

00:19:15,430 --> 00:19:21,380
iterables yourself on any object just by

00:19:19,400 --> 00:19:23,410
implementing a method keyed by symbol

00:19:21,380 --> 00:19:27,380
iterator and following that interface

00:19:23,410 --> 00:19:29,200
you can do it yourself but it turns out

00:19:27,380 --> 00:19:32,780
there's a better way and that is

00:19:29,200 --> 00:19:35,450
generators so generators are just

00:19:32,780 --> 00:19:37,610
functions that can be paused and then

00:19:35,450 --> 00:19:41,080
later resumed and they have three main

00:19:37,610 --> 00:19:44,710
roles the first role is as producer

00:19:41,080 --> 00:19:48,020
producer of what producer of iterables

00:19:44,710 --> 00:19:50,360
we can with a generator function return

00:19:48,020 --> 00:19:53,270
an iterable from a function and since

00:19:50,360 --> 00:19:55,070
functions can be composed and iterables

00:19:53,270 --> 00:19:57,980
give us values one of the time when we

00:19:55,070 --> 00:19:59,210
ask for them they let us be lazy and

00:19:57,980 --> 00:20:01,640
what I mean by that is that we can

00:19:59,210 --> 00:20:04,220
compose generator functions too lazily

00:20:01,640 --> 00:20:06,440
evaluate collections one at a time and

00:20:04,220 --> 00:20:08,020
gate those such that we never go more

00:20:06,440 --> 00:20:11,010
than what we're looking for

00:20:08,020 --> 00:20:12,870
the second role of generators is as

00:20:11,010 --> 00:20:14,640
Zoomers so in addition to yielding

00:20:12,870 --> 00:20:16,950
values out generators can actually take

00:20:14,640 --> 00:20:19,320
values in so we can do things like

00:20:16,950 --> 00:20:21,720
here's a generic consumer that takes an

00:20:19,320 --> 00:20:23,400
iterable and some consumer it starts off

00:20:21,720 --> 00:20:24,510
the generator and then passes it

00:20:23,400 --> 00:20:26,250
everything in that interval to the

00:20:24,510 --> 00:20:27,900
consumer this is a contrived example but

00:20:26,250 --> 00:20:29,670
there's probably some practical

00:20:27,900 --> 00:20:30,060
applications that I just haven't gone to

00:20:29,670 --> 00:20:32,550
yet

00:20:30,060 --> 00:20:34,200
and the last and most important role of

00:20:32,550 --> 00:20:36,600
generators is as co-routines

00:20:34,200 --> 00:20:38,580
so these are functions that both take in

00:20:36,600 --> 00:20:40,440
and yield values and probably the most

00:20:38,580 --> 00:20:42,420
popular implementation of this out in

00:20:40,440 --> 00:20:44,430
the open source community is redux saga

00:20:42,420 --> 00:20:46,290
for those who aren't familiar with this

00:20:44,430 --> 00:20:48,780
it's a side effect library used to

00:20:46,290 --> 00:20:51,840
handle asynchronous actions in redux and

00:20:48,780 --> 00:20:54,150
basically it's middleware that sits in

00:20:51,840 --> 00:20:58,080
between a dispatch and the Redux store

00:20:54,150 --> 00:21:01,140
and these directives that redux give you

00:20:58,080 --> 00:21:03,210
the call put etc those just handle

00:21:01,140 --> 00:21:04,920
resolving promises and feeding the

00:21:03,210 --> 00:21:08,550
generator with next when the result of

00:21:04,920 --> 00:21:10,350
the promise ok proxies the metaphor from

00:21:08,550 --> 00:21:12,330
the web holds up pretty well most people

00:21:10,350 --> 00:21:14,130
are familiar with proxy from a web proxy

00:21:12,330 --> 00:21:15,600
that sits between you and a web server

00:21:14,130 --> 00:21:17,520
and it's actually a pretty good metaphor

00:21:15,600 --> 00:21:18,960
it holds up pretty well and when we talk

00:21:17,520 --> 00:21:21,810
about proxies in JavaScript what we're

00:21:18,960 --> 00:21:24,110
talking about is reflection or more

00:21:21,810 --> 00:21:26,670
specifically reflective meta programming

00:21:24,110 --> 00:21:27,300
in reflective meta programming comes in

00:21:26,670 --> 00:21:30,240
three flavors

00:21:27,300 --> 00:21:32,310
the first is introspection so

00:21:30,240 --> 00:21:34,860
introspection is the ability to inspect

00:21:32,310 --> 00:21:37,170
the structure of a running program and

00:21:34,860 --> 00:21:38,970
we've had this since at least es5 with

00:21:37,170 --> 00:21:41,340
object keys and going back even further

00:21:38,970 --> 00:21:44,670
to es 3 where the object of has own

00:21:41,340 --> 00:21:47,130
property the second type of reflective

00:21:44,670 --> 00:21:49,800
meta programming is self modification

00:21:47,130 --> 00:21:52,580
and we've had this since at least es5

00:21:49,800 --> 00:21:54,660
with things like object defined property

00:21:52,580 --> 00:21:58,890
and then the last type of reflective

00:21:54,660 --> 00:22:00,710
metaprogramming is Inception we all know

00:21:58,890 --> 00:22:03,170
that's impossible it's actually

00:22:00,710 --> 00:22:05,580
intercession which is the ability to

00:22:03,170 --> 00:22:07,260
redefine the semantics of some

00:22:05,580 --> 00:22:08,490
operations in a running program this is

00:22:07,260 --> 00:22:10,710
where it gets really interesting but

00:22:08,490 --> 00:22:12,660
what does that mean in JavaScript well

00:22:10,710 --> 00:22:14,640
one of those would be to protential e

00:22:12,660 --> 00:22:16,950
intercept a getter and a setter on an

00:22:14,640 --> 00:22:18,450
object right and then redefine how that

00:22:16,950 --> 00:22:20,970
works and we've been able to do this in

00:22:18,450 --> 00:22:22,950
cs5 with object dot defined property

00:22:20,970 --> 00:22:24,509
here we go through each of the keys on

00:22:22,950 --> 00:22:26,219
the source object and went and then we

00:22:24,509 --> 00:22:29,249
find a new object that intercepts that

00:22:26,219 --> 00:22:31,349
and we can redefine those semantics so

00:22:29,249 --> 00:22:33,119
proxies in es6 give us a slightly terse

00:22:31,349 --> 00:22:35,699
or syntax for the same thing they're

00:22:33,119 --> 00:22:38,789
traps sort of analogous to traps in an

00:22:35,699 --> 00:22:41,039
operating system and in this case it's

00:22:38,789 --> 00:22:42,959
one-size-fits-all you do a set and you

00:22:41,039 --> 00:22:45,869
get in the target whatever the prop name

00:22:42,959 --> 00:22:47,219
is and potentially a value and we can do

00:22:45,869 --> 00:22:51,869
interesting things with this like

00:22:47,219 --> 00:22:53,879
validation in this example since you

00:22:51,869 --> 00:22:56,009
know since we can basically obfuscate

00:22:53,879 --> 00:22:57,209
the internals of the object we can do

00:22:56,009 --> 00:22:59,129
some interesting things we can embody

00:22:57,209 --> 00:23:00,539
common patterns like the facade pattern

00:22:59,129 --> 00:23:02,039
so here for example we've got a POJO

00:23:00,539 --> 00:23:04,679
plain old JavaScript object that's

00:23:02,039 --> 00:23:06,209
wrapping local storage and you use it

00:23:04,679 --> 00:23:08,639
just by setting and getting properties

00:23:06,209 --> 00:23:10,109
excuse me and the object the

00:23:08,639 --> 00:23:11,459
applications here are boundless there's

00:23:10,109 --> 00:23:14,399
all sorts of great things that you could

00:23:11,459 --> 00:23:16,079
obvious kate behind a simple pojo since

00:23:14,399 --> 00:23:18,659
functions are also objects we can

00:23:16,079 --> 00:23:20,309
actually intercept function calls so we

00:23:18,659 --> 00:23:21,869
can use the the corresponding reflect

00:23:20,309 --> 00:23:23,309
API I'm not going to talk about a whole

00:23:21,869 --> 00:23:25,440
lot but it maps one to one with the

00:23:23,309 --> 00:23:26,849
traps available to a proxy and so here

00:23:25,440 --> 00:23:28,889
we can redefine the semantics of a

00:23:26,849 --> 00:23:30,209
function this is a an alternate and very

00:23:28,889 --> 00:23:33,659
verbose way of doing partial application

00:23:30,209 --> 00:23:35,609
of a function so here's the all that all

00:23:33,659 --> 00:23:36,809
the traps that you get like the one

00:23:35,609 --> 00:23:38,639
that's really interesting here in my

00:23:36,809 --> 00:23:40,739
mind is constructed let's you redefine a

00:23:38,639 --> 00:23:42,389
constructor so you can do conditional

00:23:40,739 --> 00:23:43,979
instantiation of objects you can do

00:23:42,389 --> 00:23:45,839
selective data hiding you can do all

00:23:43,979 --> 00:23:48,179
sorts of really things including being

00:23:45,839 --> 00:23:50,549
paranoid because proxies also come in a

00:23:48,179 --> 00:23:52,289
revocable variant so you can issue a

00:23:50,549 --> 00:23:54,749
proxy and then at some later point you

00:23:52,289 --> 00:23:56,369
can revoke access to it so here we're

00:23:54,749 --> 00:23:58,469
going to revoke access whenever anyone

00:23:56,369 --> 00:24:00,629
tries to write to a private property

00:23:58,469 --> 00:24:02,759
keyed with an underscore and not only is

00:24:00,629 --> 00:24:05,909
it paranoid it's rude because we don't

00:24:02,759 --> 00:24:09,059
even give an error we just revoke all

00:24:05,909 --> 00:24:12,539
right last up is promises es6 brings us

00:24:09,059 --> 00:24:15,059
native promises finally or I'll actually

00:24:12,539 --> 00:24:18,929
finally didn't make the cut it did drop

00:24:15,059 --> 00:24:22,139
in ES 2018 just last month a month

00:24:18,929 --> 00:24:24,239
before but we do get native promises

00:24:22,139 --> 00:24:25,889
they come in a constructor form we also

00:24:24,239 --> 00:24:28,409
get some static methods to return a

00:24:25,889 --> 00:24:30,539
promise immediately or handle concurrent

00:24:28,409 --> 00:24:32,909
promises we didn't get the ability

00:24:30,539 --> 00:24:34,829
either to cancel a promise that's

00:24:32,909 --> 00:24:36,479
already underway but on the bright side

00:24:34,829 --> 00:24:38,470
you won't ever have any broken promises

00:24:36,479 --> 00:24:39,760
but these shortcomings

00:24:38,470 --> 00:24:41,440
have led to some criticism in the

00:24:39,760 --> 00:24:44,170
community and a lot of people still

00:24:41,440 --> 00:24:45,280
prefer libraries like Q or Bluebird for

00:24:44,170 --> 00:24:48,070
their promised needs but I would argue

00:24:45,280 --> 00:24:49,960
that just like this solved the 80% use

00:24:48,070 --> 00:24:52,120
case for querying the Dom without

00:24:49,960 --> 00:24:54,130
needing jQuery I think this is also

00:24:52,120 --> 00:24:57,340
probably gonna solve the 80% use case

00:24:54,130 --> 00:24:58,150
for basic promise usage so all this is

00:24:57,340 --> 00:25:00,460
amazing right

00:24:58,150 --> 00:25:02,740
but the es expect didn't come without

00:25:00,460 --> 00:25:05,260
some controversy there's always people

00:25:02,740 --> 00:25:07,540
out there that legitimately or not want

00:25:05,260 --> 00:25:09,820
to complain about new things the first

00:25:07,540 --> 00:25:11,320
set of controversy came around syntax so

00:25:09,820 --> 00:25:13,720
there's a big part of the surface area

00:25:11,320 --> 00:25:15,190
in es6 that's just syntactic sugar it's

00:25:13,720 --> 00:25:17,200
just new ways of expressing things we

00:25:15,190 --> 00:25:19,240
could already do and we had some people

00:25:17,200 --> 00:25:20,830
that were in the camp I've I've already

00:25:19,240 --> 00:25:22,570
learned the s5 why do I need to learn

00:25:20,830 --> 00:25:24,790
all this new syntax it's not giving me

00:25:22,570 --> 00:25:26,950
anything new then the other camp was

00:25:24,790 --> 00:25:28,720
that effort could have better be spent

00:25:26,950 --> 00:25:31,720
on entirely new features versus just

00:25:28,720 --> 00:25:34,180
syntax sugar but never underestimate

00:25:31,720 --> 00:25:36,010
developer happiness a lot of developers

00:25:34,180 --> 00:25:38,200
are coming at JavaScript first through

00:25:36,010 --> 00:25:39,640
es6 they like these features and there's

00:25:38,200 --> 00:25:43,150
some like me that think they're a great

00:25:39,640 --> 00:25:44,830
tourist expression and a time-saver so

00:25:43,150 --> 00:25:46,750
if you're developers are happy they're

00:25:44,830 --> 00:25:48,280
likely to be more engaged and you should

00:25:46,750 --> 00:25:49,990
be happy too and then there's also

00:25:48,280 --> 00:25:52,420
statistics there's been quite a few

00:25:49,990 --> 00:25:54,010
studies showing a relevant correlation

00:25:52,420 --> 00:25:55,690
between the overall lines of code and

00:25:54,010 --> 00:25:57,580
the code base and the incidence of

00:25:55,690 --> 00:25:59,950
defect so if you can reduce the lines of

00:25:57,580 --> 00:26:01,690
code by any means you should see an

00:25:59,950 --> 00:26:04,780
accompanying decrease in defect

00:26:01,690 --> 00:26:07,600
incidence all right how many people use

00:26:04,780 --> 00:26:09,190
source maps anyone used source maps okay

00:26:07,600 --> 00:26:10,930
we know we no longer live in a world

00:26:09,190 --> 00:26:13,420
where we run the code we write right

00:26:10,930 --> 00:26:15,130
we're going through multiple stages of

00:26:13,420 --> 00:26:17,350
transformation and along the way source

00:26:15,130 --> 00:26:18,910
Maps map the symbols that are produced

00:26:17,350 --> 00:26:21,790
all the way back to your original source

00:26:18,910 --> 00:26:24,910
letting you debug the code you wrote as

00:26:21,790 --> 00:26:25,480
you're troubleshooting but it's not

00:26:24,910 --> 00:26:27,310
perfect

00:26:25,480 --> 00:26:29,200
this is a game of catch the breakpoint

00:26:27,310 --> 00:26:31,300
from some production code I wrote a few

00:26:29,200 --> 00:26:34,090
years ago the experience is vastly

00:26:31,300 --> 00:26:37,510
superior to console dot log but it's not

00:26:34,090 --> 00:26:39,610
perfect yet but by far the single most

00:26:37,510 --> 00:26:41,950
controversial single feature in es6 is

00:26:39,610 --> 00:26:44,080
classes and I'm here to tell you

00:26:41,950 --> 00:26:45,790
definitively three years later that

00:26:44,080 --> 00:26:49,030
JavaScript still doesn't have classes I

00:26:45,790 --> 00:26:50,120
know if it walks like a duck talks like

00:26:49,030 --> 00:26:53,210
a duck

00:26:50,120 --> 00:26:54,890
it's not a duck it's just syntax sugar

00:26:53,210 --> 00:26:59,090
on top of constructors in the prototype

00:26:54,890 --> 00:27:03,080
chain this D sugars into this and this

00:26:59,090 --> 00:27:04,790
just disha goes into this so you know

00:27:03,080 --> 00:27:06,680
there's really polar opposites on this

00:27:04,790 --> 00:27:08,660
topic some people love them some people

00:27:06,680 --> 00:27:10,730
hate them there's not a lot of people in

00:27:08,660 --> 00:27:12,350
the middle like me they're just sort of

00:27:10,730 --> 00:27:14,420
pragmatist and accept them for what they

00:27:12,350 --> 00:27:16,790
are on the pro side

00:27:14,420 --> 00:27:18,530
it's a tercer syntax I actually admire

00:27:16,790 --> 00:27:19,550
the terse syntax I just wish they could

00:27:18,530 --> 00:27:21,320
have figured out how to call it

00:27:19,550 --> 00:27:23,240
something other than classes and bring

00:27:21,320 --> 00:27:25,760
in that kind of the metaphor from class

00:27:23,240 --> 00:27:27,650
based oh oh there's a lot of other

00:27:25,760 --> 00:27:29,690
benefits but I think the main reason

00:27:27,650 --> 00:27:31,460
this was done was to make JavaScript

00:27:29,690 --> 00:27:33,560
more approachable to people coming from

00:27:31,460 --> 00:27:35,750
class-based or languages like Java and

00:27:33,560 --> 00:27:40,640
c-sharp but there's some serious

00:27:35,750 --> 00:27:42,500
non-trivial cons as well and I think the

00:27:40,640 --> 00:27:44,180
biggest one is that the syntax this new

00:27:42,500 --> 00:27:46,250
syntax is so different from the

00:27:44,180 --> 00:27:48,560
underlying semantics of prototype chains

00:27:46,250 --> 00:27:51,260
that it just confuses those same Oh devs

00:27:48,560 --> 00:27:52,820
that came from Java and c-sharp and this

00:27:51,260 --> 00:27:54,740
was beautifully illustrated when I gave

00:27:52,820 --> 00:27:56,210
my in-depth series during the coding

00:27:54,740 --> 00:27:58,070
portion one of the guys was a Java dev

00:27:56,210 --> 00:28:01,780
and he just stopped and looked at me it

00:27:58,070 --> 00:28:04,430
was like that's not how this works but

00:28:01,780 --> 00:28:06,230
they're here to stay I think you know

00:28:04,430 --> 00:28:09,290
with major libraries and frameworks like

00:28:06,230 --> 00:28:11,110
angular and react disseminating class

00:28:09,290 --> 00:28:14,030
syntax everywhere we're stuck with them

00:28:11,110 --> 00:28:16,010
so wrapping up why do I think any of

00:28:14,030 --> 00:28:17,630
this is important well the main reason I

00:28:16,010 --> 00:28:19,910
think that this set of updates

00:28:17,630 --> 00:28:22,310
particularly the updates to the built-in

00:28:19,910 --> 00:28:23,510
library built in standard library are

00:28:22,310 --> 00:28:25,880
important is because they let us go

00:28:23,510 --> 00:28:27,620
native further than we could before and

00:28:25,880 --> 00:28:29,840
by going native I mean that all things

00:28:27,620 --> 00:28:32,150
considered all things being equal I'm a

00:28:29,840 --> 00:28:33,980
huge proponent of using a native feature

00:28:32,150 --> 00:28:35,720
of a language over it's equivalent in a

00:28:33,980 --> 00:28:38,000
library or framework it makes your code

00:28:35,720 --> 00:28:40,340
more future-proof it makes it easier for

00:28:38,000 --> 00:28:42,350
new debts to understand and it also

00:28:40,340 --> 00:28:43,460
reduces potentially a bundle size and so

00:28:42,350 --> 00:28:45,680
some of these things that we get with

00:28:43,460 --> 00:28:47,060
es6 let us reduce the dependencies we're

00:28:45,680 --> 00:28:48,890
going to pull into our bundles deliver

00:28:47,060 --> 00:28:54,230
less JavaScript and allow our code to be

00:28:48,890 --> 00:28:56,030
future proofed so how much of es6 is

00:28:54,230 --> 00:28:58,520
legit and how much of it is just hype I

00:28:56,030 --> 00:29:01,550
don't think a lot of it is hype and we

00:28:58,520 --> 00:29:02,780
have to remember that es6 is decided by

00:29:01,550 --> 00:29:05,180
a committee

00:29:02,780 --> 00:29:06,920
and quite a few of these features were

00:29:05,180 --> 00:29:09,350
actually originally considered for es4

00:29:06,920 --> 00:29:11,510
work on which began right after the es 3

00:29:09,350 --> 00:29:15,380
spec was finalized in 1999 so I think we

00:29:11,510 --> 00:29:15,950
can safely say that ESX is legit what's

00:29:15,380 --> 00:29:17,630
next

00:29:15,950 --> 00:29:20,630
well most teams have barely scratched

00:29:17,630 --> 00:29:22,370
the surface of what you can do and I'm

00:29:20,630 --> 00:29:24,740
just as guilty I think most people

00:29:22,370 --> 00:29:26,510
haven't gone beyond syntactic sugar very

00:29:24,740 --> 00:29:27,980
few teams have implemented proxies

00:29:26,510 --> 00:29:29,990
there's some technical limitations there

00:29:27,980 --> 00:29:33,080
as well generators also haven't been

00:29:29,990 --> 00:29:35,780
widely used outside of Redux sagas but

00:29:33,080 --> 00:29:36,980
I'm a pragmatist so I don't just glom on

00:29:35,780 --> 00:29:39,800
to something because it's shiny there's

00:29:36,980 --> 00:29:41,330
got to be a tangible reason to use it so

00:29:39,800 --> 00:29:43,330
what's next for the language should we

00:29:41,330 --> 00:29:46,730
expect some more earth-shattering

00:29:43,330 --> 00:29:50,030
life-changing updates like es6 well

00:29:46,730 --> 00:29:52,130
probably not because es6 was the last

00:29:50,030 --> 00:29:53,780
major update the first and last major

00:29:52,130 --> 00:29:55,910
update the language will ever get the

00:29:53,780 --> 00:29:58,160
committee decided to move to yearly

00:29:55,910 --> 00:30:00,920
incremental releases hence the name yes

00:29:58,160 --> 00:30:06,050
2015 and it seems to be working because

00:30:00,920 --> 00:30:07,790
yes 2016 had exactly two features the

00:30:06,050 --> 00:30:10,010
exponentiation operator and a rate up

00:30:07,790 --> 00:30:11,810
for design that includes which left me

00:30:10,010 --> 00:30:15,170
feeling gypped because couldn't really

00:30:11,810 --> 00:30:17,720
give an in-depth talk on es 2016 yes

00:30:15,170 --> 00:30:20,060
2017 was a bit more ambitious it has

00:30:17,720 --> 00:30:22,130
features like async and a weight and a

00:30:20,060 --> 00:30:24,770
handful of other important features

00:30:22,130 --> 00:30:27,500
yes 2018 just dropped in June it

00:30:24,770 --> 00:30:30,290
includes promise dot finally finally it

00:30:27,500 --> 00:30:32,030
includes object rest spread properties a

00:30:30,290 --> 00:30:34,640
synchronous generators some other

00:30:32,030 --> 00:30:36,680
important stuff the other versions are

00:30:34,640 --> 00:30:38,270
coming yearly we'll start seeing this

00:30:36,680 --> 00:30:39,620
thing gradually evolve and then the real

00:30:38,270 --> 00:30:42,110
game-changer for all of us is

00:30:39,620 --> 00:30:44,540
webassembly webassembly is a bytecode

00:30:42,110 --> 00:30:46,340
format for the browser that lets other

00:30:44,540 --> 00:30:48,590
languages transpile directly to the

00:30:46,340 --> 00:30:50,210
browser and it lets me say something

00:30:48,590 --> 00:30:52,010
that I never thought I would say in my

00:30:50,210 --> 00:30:53,810
23 years of software development and

00:30:52,010 --> 00:30:54,320
that is if you want to do cool things on

00:30:53,810 --> 00:30:58,480
the web

00:30:54,320 --> 00:31:01,210
learn C and lastly I give you ice cream

00:30:58,480 --> 00:31:03,560
what does ice cream have to do with es6

00:31:01,210 --> 00:31:04,970
absolutely nothing but my ten-year-old

00:31:03,560 --> 00:31:06,710
daughter asked me to include a slide on

00:31:04,970 --> 00:31:09,590
ice cream and you don't say no to that

00:31:06,710 --> 00:31:11,650
 that's all I got

00:31:09,590 --> 00:31:11,650

YouTube URL: https://www.youtube.com/watch?v=Fh0VYI-_uPg


