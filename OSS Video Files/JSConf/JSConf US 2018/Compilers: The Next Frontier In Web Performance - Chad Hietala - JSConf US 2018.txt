Title: Compilers: The Next Frontier In Web Performance - Chad Hietala - JSConf US 2018
Publication date: 2018-11-14
Playlist: JSConf US 2018
Description: 
	
Captions: 
	00:00:00,320 --> 00:00:03,840
[Music]

00:00:02,070 --> 00:00:05,660
[Applause]

00:00:03,840 --> 00:00:07,410
[Music]

00:00:05,660 --> 00:00:09,280
[Applause]

00:00:07,410 --> 00:00:11,020
[Music]

00:00:09,280 --> 00:00:12,780
[Applause]

00:00:11,020 --> 00:00:15,920
[Music]

00:00:12,780 --> 00:00:15,920
[Applause]

00:00:16,870 --> 00:00:24,050
[Music]

00:00:24,689 --> 00:00:30,849
how's everybody doing today alright okay

00:00:29,529 --> 00:00:33,040
so today I'm talking a little bit about

00:00:30,849 --> 00:00:35,440
compilers and why I think they're at the

00:00:33,040 --> 00:00:38,950
core of the next evolution of web

00:00:35,440 --> 00:00:40,930
performance as I mentioned my name is

00:00:38,950 --> 00:00:42,789
Chad I tell I'm a senior staff software

00:00:40,930 --> 00:00:43,920
engineer at LinkedIn where I get to work

00:00:42,789 --> 00:00:46,240
on a bunch of open-source JavaScript

00:00:43,920 --> 00:00:48,730
infrastructure that help power

00:00:46,240 --> 00:00:50,650
LinkedIn's applications I'm also part of

00:00:48,730 --> 00:00:53,829
the Emer j/s core team where I help

00:00:50,650 --> 00:00:55,390
maintain and work on different libraries

00:00:53,829 --> 00:00:57,399
and frameworks within the Ember

00:00:55,390 --> 00:01:00,670
ecosystem you have any questions about

00:00:57,399 --> 00:01:03,340
LinkedIn or ember come find me after my

00:01:00,670 --> 00:01:04,930
talk but Before we jump into my talk we

00:01:03,340 --> 00:01:07,060
first have to have a baseline

00:01:04,930 --> 00:01:09,790
understanding of what actually is a

00:01:07,060 --> 00:01:11,380
compiler and I think this topic can be

00:01:09,790 --> 00:01:12,729
rather intimidating for a lot of people

00:01:11,380 --> 00:01:14,890
because as associated with things like

00:01:12,729 --> 00:01:16,360
computer science and theory and not

00:01:14,890 --> 00:01:18,790
everybody has a background in those

00:01:16,360 --> 00:01:21,370
things so when I think about a compiler

00:01:18,790 --> 00:01:23,650
and what it is at a high level what it

00:01:21,370 --> 00:01:25,000
really is is that it's really just a

00:01:23,650 --> 00:01:27,520
code translator

00:01:25,000 --> 00:01:29,409
it's gonna take some source code in the

00:01:27,520 --> 00:01:31,000
compilers in a transformer in various

00:01:29,409 --> 00:01:34,020
different ways and what you're gonna get

00:01:31,000 --> 00:01:37,270
as output is another executable program

00:01:34,020 --> 00:01:38,979
so for instance and the browser you can

00:01:37,270 --> 00:01:41,110
write something like this a super simple

00:01:38,979 --> 00:01:43,360
add one function and what the browser

00:01:41,110 --> 00:01:46,960
has to do before it can actually execute

00:01:43,360 --> 00:01:48,250
this function is parse and compile it

00:01:46,960 --> 00:01:50,140
into something that's much more

00:01:48,250 --> 00:01:52,600
low-level something that can actually

00:01:50,140 --> 00:01:54,250
run on top of a CPU and it's the

00:01:52,600 --> 00:01:56,770
browser's ability to do this just

00:01:54,250 --> 00:01:58,390
just-in-time compilation that has made

00:01:56,770 --> 00:02:02,920
the web a viable platform for building

00:01:58,390 --> 00:02:04,360
very sophisticated applications but I'm

00:02:02,920 --> 00:02:06,640
not actually here today to talk about

00:02:04,360 --> 00:02:08,920
these compilers I'm here to talk about

00:02:06,640 --> 00:02:11,799
the compilers that we use every single

00:02:08,920 --> 00:02:14,260
day inside of our tool chains and we've

00:02:11,799 --> 00:02:16,599
actually been using compilers for quite

00:02:14,260 --> 00:02:16,780
a long period of time about 15 years or

00:02:16,599 --> 00:02:19,030
so

00:02:16,780 --> 00:02:20,560
maybe a little bit more and so we're

00:02:19,030 --> 00:02:22,330
going to quickly look through kind of

00:02:20,560 --> 00:02:23,860
the history of compilers in the front

00:02:22,330 --> 00:02:24,819
and tooling space and what they've

00:02:23,860 --> 00:02:27,370
afforded us and

00:02:24,819 --> 00:02:29,769
terms of like performance or developer

00:02:27,370 --> 00:02:32,439
ergonomics so we first have to go back

00:02:29,769 --> 00:02:36,819
to 2003 when Douglas Crockford writes

00:02:32,439 --> 00:02:38,650
Jasmine and Jasmine is a one file cc

00:02:36,819 --> 00:02:40,900
library that just removed all the

00:02:38,650 --> 00:02:42,760
meaningless white space from your

00:02:40,900 --> 00:02:44,859
JavaScript code and things like comments

00:02:42,760 --> 00:02:48,010
and stuff like that and this drastically

00:02:44,859 --> 00:02:51,879
shrunk the size of the applications that

00:02:48,010 --> 00:02:53,560
we were shipping to the browser right

00:02:51,879 --> 00:02:55,269
along the same period of time Yui

00:02:53,560 --> 00:02:57,760
compressor comes out and right Yui

00:02:55,269 --> 00:02:59,950
compressor has this very similar type of

00:02:57,760 --> 00:03:01,599
goals it wants to reduce the size of the

00:02:59,950 --> 00:03:03,400
JavaScript that's being sent over the

00:03:01,599 --> 00:03:05,290
wire and it does things like removing

00:03:03,400 --> 00:03:08,730
this meaningless whitespace and removing

00:03:05,290 --> 00:03:12,129
comments but it introduces the notion of

00:03:08,730 --> 00:03:14,139
mangling or symbol mangling and it goes

00:03:12,129 --> 00:03:16,590
something like this so this is a unique

00:03:14,139 --> 00:03:16,590
and functional

00:03:17,639 --> 00:03:23,469
2003 this is like ballad es 3 code and

00:03:21,280 --> 00:03:25,510
so what the compiler is gonna do is that

00:03:23,469 --> 00:03:28,389
it's gonna pull out all of the user

00:03:25,510 --> 00:03:31,720
identify or user specified identifiers

00:03:28,389 --> 00:03:34,269
so this is unique our red-eye item and

00:03:31,720 --> 00:03:36,609
what the compiler does is it Maps them

00:03:34,269 --> 00:03:38,979
onto a set of new identifiers in this

00:03:36,609 --> 00:03:41,229
case a b c d and e and it can do this

00:03:38,979 --> 00:03:43,479
because the compiler has all the lexical

00:03:41,229 --> 00:03:45,909
and semantic information inside of it so

00:03:43,479 --> 00:03:48,040
it knows that it safely can remap this

00:03:45,909 --> 00:03:51,909
thing that you wrote into something that

00:03:48,040 --> 00:03:54,930
is much smaller and so while in 2018

00:03:51,909 --> 00:03:57,069
this is not like a new novel idea

00:03:54,930 --> 00:03:59,139
anybody that's building JavaScript

00:03:57,069 --> 00:04:01,060
applications is going through a

00:03:59,139 --> 00:04:04,870
minification step but at the time this

00:04:01,060 --> 00:04:08,620
was rather novel and it sped up

00:04:04,870 --> 00:04:13,299
applications quite a bit next comes this

00:04:08,620 --> 00:04:15,849
period from 2003 to 2008 and not a whole

00:04:13,299 --> 00:04:17,469
lot happens during this time in terms of

00:04:15,849 --> 00:04:19,840
like developer tool chains and

00:04:17,469 --> 00:04:22,930
everything like that and that's because

00:04:19,840 --> 00:04:24,820
this is the life and death of es 4 and

00:04:22,930 --> 00:04:27,729
so for those who are familiar with what

00:04:24,820 --> 00:04:29,590
es 4 is or was it was an actual

00:04:27,729 --> 00:04:32,770
specification of JavaScript that never

00:04:29,590 --> 00:04:35,380
actually shipped but looking back at es

00:04:32,770 --> 00:04:37,479
4 today we would actually say that es 4

00:04:35,380 --> 00:04:38,740
has shipped because it specified things

00:04:37,479 --> 00:04:41,170
like cloud

00:04:38,740 --> 00:04:43,240
module system generators iterators

00:04:41,170 --> 00:04:46,270
destructuring assignment all the things

00:04:43,240 --> 00:04:49,500
that we're using today inside of our

00:04:46,270 --> 00:04:51,880
applications but mind you this is

00:04:49,500 --> 00:04:53,880
developers wanted these types of

00:04:51,880 --> 00:04:56,970
features from the language back then and

00:04:53,880 --> 00:04:59,860
this is also when Google comes out with

00:04:56,970 --> 00:05:01,300
Google Maps and kind of shows the types

00:04:59,860 --> 00:05:02,470
of things that we can build it build for

00:05:01,300 --> 00:05:05,260
the web and we can be a little bit more

00:05:02,470 --> 00:05:07,900
ambitious in terms of the applications

00:05:05,260 --> 00:05:11,170
that we want to build there so next

00:05:07,900 --> 00:05:13,090
comes this period from 2008 to 2010 and

00:05:11,170 --> 00:05:15,340
what do we see during this period of

00:05:13,090 --> 00:05:18,730
time well we actually see like an

00:05:15,340 --> 00:05:21,250
explosion of compilers enter the tooling

00:05:18,730 --> 00:05:23,290
space and actually like to call this

00:05:21,250 --> 00:05:25,630
period of time the Enlightenment it's

00:05:23,290 --> 00:05:28,440
kind of like the origin story of where

00:05:25,630 --> 00:05:31,810
we are today from a tooling perspective

00:05:28,440 --> 00:05:33,790
so we have projects like cappuccino GWT

00:05:31,810 --> 00:05:35,200
and CoffeeScript that are all kind of

00:05:33,790 --> 00:05:36,880
birthed out of the sentiment that they

00:05:35,200 --> 00:05:39,190
no longer run be beholden to the

00:05:36,880 --> 00:05:41,440
standardization process so in case of

00:05:39,190 --> 00:05:45,030
cappuccino they create objective J which

00:05:41,440 --> 00:05:47,920
is a dialect of Objective C GWT bothers

00:05:45,030 --> 00:05:50,050
borrows Java and CoffeeScript and takes

00:05:47,920 --> 00:05:52,090
the best parts of Python and Ruby to

00:05:50,050 --> 00:05:53,530
create a new language and what all these

00:05:52,090 --> 00:05:56,050
projects kind of have in common is that

00:05:53,530 --> 00:05:58,960
they are their own language and they

00:05:56,050 --> 00:06:01,660
build sophisticated compilers in between

00:05:58,960 --> 00:06:04,030
there to turn that language into

00:06:01,660 --> 00:06:07,090
JavaScript code that could run in the

00:06:04,030 --> 00:06:08,980
browser of the time and so this allowed

00:06:07,090 --> 00:06:10,570
them to do things like shed away runtime

00:06:08,980 --> 00:06:13,150
libraries for doing things like class

00:06:10,570 --> 00:06:15,400
systems but the big idea here is that

00:06:13,150 --> 00:06:17,290
javascript is effectively a bytecode

00:06:15,400 --> 00:06:18,760
format you don't actually have to write

00:06:17,290 --> 00:06:20,140
in the programming language of the web

00:06:18,760 --> 00:06:21,970
as long as you can build the

00:06:20,140 --> 00:06:23,440
sophisticated enough compiler that map's

00:06:21,970 --> 00:06:26,230
the what the language that you wrote in

00:06:23,440 --> 00:06:29,350
on to the semantics of the JavaScript

00:06:26,230 --> 00:06:30,610
language the other thing that comes out

00:06:29,350 --> 00:06:33,250
during this period of time is more

00:06:30,610 --> 00:06:35,710
advanced minifiers so this is closure

00:06:33,250 --> 00:06:38,290
compiler and closure compiler is pretty

00:06:35,710 --> 00:06:40,600
unique so let's say you have some

00:06:38,290 --> 00:06:42,400
JavaScript code in your application like

00:06:40,600 --> 00:06:45,010
this this is very silly code but in a

00:06:42,400 --> 00:06:47,260
large-enough application you will end up

00:06:45,010 --> 00:06:49,480
having code like this even if you try

00:06:47,260 --> 00:06:51,580
really hard so we can see that like

00:06:49,480 --> 00:06:52,240
predicate is never actually getting

00:06:51,580 --> 00:06:53,919
reassigned

00:06:52,240 --> 00:06:55,930
so the first conditional is always going

00:06:53,919 --> 00:06:57,310
to execute the second conditional is

00:06:55,930 --> 00:07:00,580
never going to execute and then we have

00:06:57,310 --> 00:07:01,810
this do stuff function declaration here

00:07:00,580 --> 00:07:03,789
where we're just something left and

00:07:01,810 --> 00:07:05,650
right and we've left off callback and

00:07:03,789 --> 00:07:08,470
then last time we're doing some type of

00:07:05,650 --> 00:07:11,410
string interpolation it's drink

00:07:08,470 --> 00:07:13,389
interpolation or concatenation type of

00:07:11,410 --> 00:07:15,580
thing so if you give this code to a

00:07:13,389 --> 00:07:17,830
closure compiler what you get out of it

00:07:15,580 --> 00:07:20,410
is something like this so not only has

00:07:17,830 --> 00:07:23,229
it minified the code it has done a whole

00:07:20,410 --> 00:07:25,150
lot more so the closure compiler can

00:07:23,229 --> 00:07:26,860
figure out that this first branch is

00:07:25,150 --> 00:07:29,319
always going to execute so just in line

00:07:26,860 --> 00:07:30,669
the body of the conditional the second

00:07:29,319 --> 00:07:33,009
conditional was never going to execute

00:07:30,669 --> 00:07:34,960
so just throw it away and then the

00:07:33,009 --> 00:07:37,270
interesting part here is that do stuff

00:07:34,960 --> 00:07:39,340
just doesn't exist so closure compiler

00:07:37,270 --> 00:07:41,349
has this technique in it known as

00:07:39,340 --> 00:07:43,479
concept folding where it can see if

00:07:41,349 --> 00:07:45,970
calls to the function are going to be

00:07:43,479 --> 00:07:48,370
side-effect free it can just do that

00:07:45,970 --> 00:07:50,289
work in ahead of time and just inline

00:07:48,370 --> 00:07:52,500
the result it's also done the same thing

00:07:50,289 --> 00:07:54,370
with a and B here where it is just

00:07:52,500 --> 00:07:55,389
concatenated them into the string

00:07:54,370 --> 00:07:58,840
because there is no observable

00:07:55,389 --> 00:08:00,130
side-effects and so because closure

00:07:58,840 --> 00:08:01,900
compiler takes in your entire

00:08:00,130 --> 00:08:03,669
application and produces this more

00:08:01,900 --> 00:08:06,130
optimal subset of the code what we

00:08:03,669 --> 00:08:08,680
actually call closure compiler is an

00:08:06,130 --> 00:08:10,509
optimizing compiler it's a really cool

00:08:08,680 --> 00:08:14,860
piece of technology and it's still used

00:08:10,509 --> 00:08:17,500
today on a lot of web properties and so

00:08:14,860 --> 00:08:19,539
that brings us to today and I think

00:08:17,500 --> 00:08:21,159
today we have like really great tools we

00:08:19,539 --> 00:08:22,599
have web pack we have roll-up

00:08:21,159 --> 00:08:25,210
we had tracer for some period of time

00:08:22,599 --> 00:08:28,840
but like babel is kind of superseded in

00:08:25,210 --> 00:08:31,479
turn in translation space and so what

00:08:28,840 --> 00:08:33,099
are those tools doing well they're

00:08:31,479 --> 00:08:35,349
actually building off the backs that

00:08:33,099 --> 00:08:38,260
things of the things that came before it

00:08:35,349 --> 00:08:39,880
so in the case they allow you to use it

00:08:38,260 --> 00:08:42,250
like new language features which kind of

00:08:39,880 --> 00:08:45,130
harkens back to the sentiment of like

00:08:42,250 --> 00:08:47,350
the objective J's and the coffee scripts

00:08:45,130 --> 00:08:49,390
of the world they can do more optimized

00:08:47,350 --> 00:08:51,430
code bundles they can do different forms

00:08:49,390 --> 00:08:53,890
of dead code elimination so this is like

00:08:51,430 --> 00:08:57,790
scope poising and tree shaking and so

00:08:53,890 --> 00:09:01,029
you'd think in 2018 we're kind of like

00:08:57,790 --> 00:09:03,430
pinnacle of performance here we've had

00:09:01,029 --> 00:09:05,740
15 years of really sophisticated tool

00:09:03,430 --> 00:09:06,170
chains being developed so everything is

00:09:05,740 --> 00:09:10,250
great

00:09:06,170 --> 00:09:13,220
right well I actually say that there are

00:09:10,250 --> 00:09:16,160
quite a few problems in what we do today

00:09:13,220 --> 00:09:18,230
I think that's because we've kind of

00:09:16,160 --> 00:09:21,440
fundamentally changed on how we approach

00:09:18,230 --> 00:09:24,620
to building applications for the web and

00:09:21,440 --> 00:09:26,180
so this is a tweet by Alex Russell who

00:09:24,620 --> 00:09:27,620
is a developer on the chrome team he

00:09:26,180 --> 00:09:30,589
also might be some of you guys

00:09:27,620 --> 00:09:32,240
colleagues and what he says is the web

00:09:30,589 --> 00:09:34,699
is getting slower because no matter how

00:09:32,240 --> 00:09:36,529
much faster we make Chrome developers

00:09:34,699 --> 00:09:38,089
abuse users with ever larger piles of

00:09:36,529 --> 00:09:41,000
JavaScript and JavaScript is the most

00:09:38,089 --> 00:09:43,579
expensive thing so let me unpack this a

00:09:41,000 --> 00:09:47,120
little bit so I think about five years

00:09:43,579 --> 00:09:48,649
ago we kind of shifted quite drastically

00:09:47,120 --> 00:09:51,440
and how we approach to building web

00:09:48,649 --> 00:09:54,139
applications we used to start with HTML

00:09:51,440 --> 00:09:55,790
and then you style it with CSS and then

00:09:54,139 --> 00:09:57,680
you would layer on the JavaScript to get

00:09:55,790 --> 00:10:00,380
a little bit of interactivity and we've

00:09:57,680 --> 00:10:02,089
basically inverted this world we start

00:10:00,380 --> 00:10:06,170
with JavaScript a lot of the times and

00:10:02,089 --> 00:10:08,269
we add CSS to it and hTML is this out of

00:10:06,170 --> 00:10:11,959
the picture for a lot of applications

00:10:08,269 --> 00:10:14,000
nowadays and so because we are pushing

00:10:11,959 --> 00:10:15,949
more and more responsibility onto

00:10:14,000 --> 00:10:19,190
JavaScript there tends to be a lot more

00:10:15,949 --> 00:10:21,170
of it and we have to ship that down to

00:10:19,190 --> 00:10:23,149
our users and what he's talking about

00:10:21,170 --> 00:10:26,570
in this last part about JavaScript being

00:10:23,149 --> 00:10:29,209
the most expensive thing is this it is

00:10:26,570 --> 00:10:32,180
the parse and compile step of JavaScript

00:10:29,209 --> 00:10:33,800
that is very very expensive so if you

00:10:32,180 --> 00:10:35,050
think about it you're writing JavaScript

00:10:33,800 --> 00:10:37,610
code it's the textual representation

00:10:35,050 --> 00:10:40,459
that code needs to go to the browser and

00:10:37,610 --> 00:10:42,740
needs to turn into an executable like

00:10:40,459 --> 00:10:45,890
thing like it just doesn't run the text

00:10:42,740 --> 00:10:48,230
that you wrote and so in 2017 addy

00:10:45,890 --> 00:10:49,970
osmani wrote a really great blog article

00:10:48,230 --> 00:10:51,980
called JavaScript startup time and he

00:10:49,970 --> 00:10:54,800
had this really great graphic in it and

00:10:51,980 --> 00:10:56,990
what it's saying is that the bytes of

00:10:54,800 --> 00:10:59,750
JavaScript are not the same bytes as a

00:10:56,990 --> 00:11:01,670
jpg and so this is on a constrained

00:10:59,750 --> 00:11:04,370
network and a constraint is a device so

00:11:01,670 --> 00:11:06,470
if you have 170 KB of anything it takes

00:11:04,370 --> 00:11:07,699
roughly the same amount of time to pull

00:11:06,470 --> 00:11:09,139
it over the wire so in this case it

00:11:07,699 --> 00:11:12,230
takes three and a half seconds to

00:11:09,139 --> 00:11:13,699
transmit both of these asset types but

00:11:12,230 --> 00:11:16,790
once they get on to the device it's a

00:11:13,699 --> 00:11:20,000
whole nother ballgame so in the case of

00:11:16,790 --> 00:11:21,590
a JPEG it is binary data so it just

00:11:20,000 --> 00:11:23,960
goes through a decoder like pretty

00:11:21,590 --> 00:11:25,850
quickly and it takes about 70

00:11:23,960 --> 00:11:28,100
milliseconds to do that whereas the

00:11:25,850 --> 00:11:30,860
JavaScript takes an additional two

00:11:28,100 --> 00:11:32,960
seconds for it just the process on the

00:11:30,860 --> 00:11:35,120
device and I think this is some of the

00:11:32,960 --> 00:11:38,990
stuff that both Chris and Malte we're

00:11:35,120 --> 00:11:40,550
talking about two days ago and then from

00:11:38,990 --> 00:11:44,600
there the JavaScript then executes for

00:11:40,550 --> 00:11:46,310
another 1/2 seconds whereas the JPEG

00:11:44,600 --> 00:11:50,390
just needs to paint of the screen takes

00:11:46,310 --> 00:11:53,150
point 0 to 8 mills are 2.8 milliseconds

00:11:50,390 --> 00:11:56,300
AG are seconds to do that so very

00:11:53,150 --> 00:12:01,040
different types of resources that we're

00:11:56,300 --> 00:12:02,900
talking about here and so as I mentioned

00:12:01,040 --> 00:12:04,370
I'm on the ember.js core team and over

00:12:02,900 --> 00:12:06,680
the past couple years I've been working

00:12:04,370 --> 00:12:09,800
on this project known as the glimmer VM

00:12:06,680 --> 00:12:12,170
and we think about the glimmer being at

00:12:09,800 --> 00:12:14,120
VM as an example of the types of tools

00:12:12,170 --> 00:12:16,280
that I think that we have to start

00:12:14,120 --> 00:12:17,960
thinking about building or building to

00:12:16,280 --> 00:12:22,400
help mitigate some of these inherent

00:12:17,960 --> 00:12:24,140
problems with JavaScript and so for

00:12:22,400 --> 00:12:26,270
those who are familiar with what the

00:12:24,140 --> 00:12:29,270
glimmer VM is it is the rendering engine

00:12:26,270 --> 00:12:31,760
inside of ember and this is the San

00:12:29,270 --> 00:12:35,210
Diego ember meetups mascot it's pretty

00:12:31,760 --> 00:12:37,280
cool so for those who are familiar with

00:12:35,210 --> 00:12:38,270
what it means to build an ember

00:12:37,280 --> 00:12:40,490
application I'm going to go through a

00:12:38,270 --> 00:12:43,550
really quick example so this is your

00:12:40,490 --> 00:12:45,200
quintessential to do MVC type of app so

00:12:43,550 --> 00:12:46,940
you would have a - duze component you

00:12:45,200 --> 00:12:49,160
would each over each one of the two dues

00:12:46,940 --> 00:12:50,900
every iteration of the loop

00:12:49,160 --> 00:12:52,940
you're gonna invoke an item component

00:12:50,900 --> 00:12:56,360
and you're past the to do at that index

00:12:52,940 --> 00:12:58,070
into the item component item component

00:12:56,360 --> 00:12:59,540
is what we call a template only

00:12:58,070 --> 00:13:01,670
component if you're familiar with

00:12:59,540 --> 00:13:04,040
reactor solutions like it we would call

00:13:01,670 --> 00:13:06,440
it a pure component it just draws from

00:13:04,040 --> 00:13:08,390
its inputs and then the backing class

00:13:06,440 --> 00:13:09,650
for the - dues component would look

00:13:08,390 --> 00:13:13,280
something like this we have a couple

00:13:09,650 --> 00:13:14,780
different decorators here tract is just

00:13:13,280 --> 00:13:17,530
our mechanism for doing change detection

00:13:14,780 --> 00:13:21,560
in the system and action is this binding

00:13:17,530 --> 00:13:23,600
the instance - basically doing the bind

00:13:21,560 --> 00:13:25,220
so that when we put it into the template

00:13:23,600 --> 00:13:28,459
layer you can just freely pass it around

00:13:25,220 --> 00:13:31,760
so this isn't all that important but the

00:13:28,459 --> 00:13:33,500
important part is that ember uses

00:13:31,760 --> 00:13:36,260
templates and it's one of the large

00:13:33,500 --> 00:13:37,640
just reasons why it broke away from this

00:13:36,260 --> 00:13:39,590
other framework which was known as

00:13:37,640 --> 00:13:42,380
sprout core which is used to build like

00:13:39,590 --> 00:13:44,120
things like mobile me at Apple it was to

00:13:42,380 --> 00:13:48,680
bring this declarative templating

00:13:44,120 --> 00:13:51,560
language to a framework and we're not

00:13:48,680 --> 00:13:53,810
actually alone in this philosophy of

00:13:51,560 --> 00:13:56,390
having a domain-specific language to

00:13:53,810 --> 00:13:58,160
declaratively declaratively describe our

00:13:56,390 --> 00:14:00,170
views and something that actually isn't

00:13:58,160 --> 00:14:02,780
in JavaScript both of you and angular

00:14:00,170 --> 00:14:04,400
have I think a very similar philosophy

00:14:02,780 --> 00:14:06,860
and angular actually wrote pretty

00:14:04,400 --> 00:14:09,290
extensively about why angular uses

00:14:06,860 --> 00:14:12,200
templates in 2016 it's a really great

00:14:09,290 --> 00:14:14,240
blog article but at the end of the day

00:14:12,200 --> 00:14:18,110
even though that view and angular are

00:14:14,240 --> 00:14:20,240
owning complete languages with our own

00:14:18,110 --> 00:14:22,370
semantics and their own compiler stacks

00:14:20,240 --> 00:14:24,710
at the end of the day both view and

00:14:22,370 --> 00:14:27,020
angular still compile the templates to

00:14:24,710 --> 00:14:29,450
JavaScript and so it's not really

00:14:27,020 --> 00:14:31,130
working towards solving this parse and

00:14:29,450 --> 00:14:34,850
compile problem or problem or just

00:14:31,130 --> 00:14:38,210
property of JavaScript so how does

00:14:34,850 --> 00:14:40,310
glimmr VM approach this problem well

00:14:38,210 --> 00:14:43,280
instead of compiling the templates to

00:14:40,310 --> 00:14:45,980
JavaScript we actually compile them to a

00:14:43,280 --> 00:14:47,750
binary executable anytime that you're

00:14:45,980 --> 00:14:51,589
talking about binary like we have to

00:14:47,750 --> 00:14:53,990
have the matrix background so what does

00:14:51,589 --> 00:14:56,240
that actually mean that means if you

00:14:53,990 --> 00:14:57,950
write a template like this at Build time

00:14:56,240 --> 00:15:01,070
so this is ahead of time compilation

00:14:57,950 --> 00:15:04,400
step we compile that template into a

00:15:01,070 --> 00:15:06,500
binary blob that encodes all of the

00:15:04,400 --> 00:15:09,860
instructions to recreate that template

00:15:06,500 --> 00:15:12,380
at runtime and so you may be saying to

00:15:09,860 --> 00:15:14,870
yourself ah this is like quite novel but

00:15:12,380 --> 00:15:16,430
how does it actually help mitigate this

00:15:14,870 --> 00:15:20,600
parse and compile problem

00:15:16,430 --> 00:15:22,850
well binary data in the browser is can

00:15:20,600 --> 00:15:25,460
be represented by an API known as a

00:15:22,850 --> 00:15:26,930
typed array if you go find the

00:15:25,460 --> 00:15:28,339
documentation for a typed array you'll

00:15:26,930 --> 00:15:30,290
come across this great definition that

00:15:28,339 --> 00:15:32,120
says a typed array is a slab of memory

00:15:30,290 --> 00:15:34,220
with a type view into it much like how

00:15:32,120 --> 00:15:35,720
arrays work and see because of typed

00:15:34,220 --> 00:15:37,370
array is backed by raw memory the

00:15:35,720 --> 00:15:38,810
JavaScript engine can pass that memory

00:15:37,370 --> 00:15:40,820
directly to native libraries without

00:15:38,810 --> 00:15:43,070
having to painstakingly convert the data

00:15:40,820 --> 00:15:44,780
into a native representation so what

00:15:43,070 --> 00:15:46,680
it's talking about and that last part is

00:15:44,780 --> 00:15:48,960
parsing a pile

00:15:46,680 --> 00:15:50,580
with typed arrays and the data inside of

00:15:48,960 --> 00:15:53,790
them they never actually see the parse

00:15:50,580 --> 00:15:57,779
and compile pipeline of JavaScript so

00:15:53,790 --> 00:16:00,690
that's a pretty cool property of them so

00:15:57,779 --> 00:16:02,220
if we look at open source java open

00:16:00,690 --> 00:16:04,020
source ember applications and even

00:16:02,220 --> 00:16:05,910
internal applications what we tend to

00:16:04,020 --> 00:16:08,730
find is anywhere from 25 to 40 percent

00:16:05,910 --> 00:16:11,160
of these applications are built up of

00:16:08,730 --> 00:16:12,930
this templating layer and so if we can

00:16:11,160 --> 00:16:15,000
take those templates and compile them

00:16:12,930 --> 00:16:16,620
into something that isn't JavaScript

00:16:15,000 --> 00:16:20,610
that doesn't have these inherent parse

00:16:16,620 --> 00:16:22,709
and compile not issues but it's just the

00:16:20,610 --> 00:16:26,540
reality of the world then what we can do

00:16:22,709 --> 00:16:29,760
is we can actually speed up applications

00:16:26,540 --> 00:16:31,380
so how do we actually do this we're

00:16:29,760 --> 00:16:33,330
gonna kind of walk through kind of a

00:16:31,380 --> 00:16:36,480
quick example of how both the

00:16:33,330 --> 00:16:40,160
compilation part works and then how we

00:16:36,480 --> 00:16:43,680
actually execute that code at runtime so

00:16:40,160 --> 00:16:46,020
valid HTML in handlebars templates is

00:16:43,680 --> 00:16:48,570
valid a valid template so we're going to

00:16:46,020 --> 00:16:50,730
use this super simple hello world

00:16:48,570 --> 00:16:53,490
esque example to kind of walk through

00:16:50,730 --> 00:16:54,810
the process so the first thing that

00:16:53,490 --> 00:16:57,060
we're actually going to do is we're

00:16:54,810 --> 00:16:59,250
gonna take that template and we're going

00:16:57,060 --> 00:17:01,380
to tokenize it into an abstract syntax

00:16:59,250 --> 00:17:03,510
tree and then it's gonna get passed

00:17:01,380 --> 00:17:06,300
through a couple different compilers

00:17:03,510 --> 00:17:08,010
stages and at the end of the day what

00:17:06,300 --> 00:17:10,530
you're gonna get out of this phase is

00:17:08,010 --> 00:17:12,150
something that looks like this so we

00:17:10,530 --> 00:17:15,480
started with this declarative templating

00:17:12,150 --> 00:17:19,140
layer and now what we get is like this

00:17:15,480 --> 00:17:22,020
JSON that is very declarative it title

00:17:19,140 --> 00:17:27,600
looks like the message format that the

00:17:22,020 --> 00:17:29,550
worker Dom uses and so this is JSON this

00:17:27,600 --> 00:17:32,160
isn't actually binary so we actually

00:17:29,550 --> 00:17:35,070
have to further compile this format down

00:17:32,160 --> 00:17:38,400
and that's where the OP code compiler

00:17:35,070 --> 00:17:40,290
comes in before we actually jump into

00:17:38,400 --> 00:17:43,500
what the role of the OpCo compiler is

00:17:40,290 --> 00:17:47,910
let me unpack some terminology so an

00:17:43,500 --> 00:17:50,100
opcode is just a number a number that is

00:17:47,910 --> 00:17:53,220
significant to a virtual machine that is

00:17:50,100 --> 00:17:55,559
tied to some level or a small bit of

00:17:53,220 --> 00:17:58,050
functionality so you can think of it as

00:17:55,559 --> 00:17:59,290
just a function that is going to do a

00:17:58,050 --> 00:18:03,040
little bit of work

00:17:59,290 --> 00:18:05,140
and an opcode takes operands and you can

00:18:03,040 --> 00:18:07,060
think of operands is just arguments to

00:18:05,140 --> 00:18:09,490
that function and together you would

00:18:07,060 --> 00:18:12,490
call this an instruction a bytecode set

00:18:09,490 --> 00:18:14,290
is just many instructions that is

00:18:12,490 --> 00:18:17,860
encoding where these instructions begin

00:18:14,290 --> 00:18:19,810
and end so it's just a bunch of numbers

00:18:17,860 --> 00:18:22,990
but those numbers are encoded in a very

00:18:19,810 --> 00:18:24,790
specific way so going back to our JSON

00:18:22,990 --> 00:18:29,620
example we're going to start compiling

00:18:24,790 --> 00:18:30,910
this into that binary format so the

00:18:29,620 --> 00:18:34,680
first thing that we do is that we're

00:18:30,910 --> 00:18:36,940
going to pop each item off of this list

00:18:34,680 --> 00:18:38,860
so in this case we're going to compile

00:18:36,940 --> 00:18:41,380
open out the open element statement

00:18:38,860 --> 00:18:43,780
we're gonna map that the first element

00:18:41,380 --> 00:18:45,880
of that array into a method of the same

00:18:43,780 --> 00:18:47,980
name so open element maps into an open

00:18:45,880 --> 00:18:50,320
Ellyn element method and then it's going

00:18:47,980 --> 00:18:52,000
to take some arguments here for open

00:18:50,320 --> 00:18:54,370
element it's gonna take the tag name and

00:18:52,000 --> 00:18:56,500
the first thing that we actually do here

00:18:54,370 --> 00:18:59,440
is that we push the tag name into a

00:18:56,500 --> 00:19:00,910
strings constants pool the constants

00:18:59,440 --> 00:19:04,530
pool is this gonna hold on to our

00:19:00,910 --> 00:19:07,180
user-defined literals in the system and

00:19:04,530 --> 00:19:08,440
from that we're gonna get a number in

00:19:07,180 --> 00:19:11,110
this case that's the first thing that

00:19:08,440 --> 00:19:14,020
we're pushing in so we'll get 0 out of

00:19:11,110 --> 00:19:16,090
the the constants pool and so tag is 0

00:19:14,020 --> 00:19:19,120
at this point and then we pass that into

00:19:16,090 --> 00:19:22,900
the stop builder open element so because

00:19:19,120 --> 00:19:24,400
the VM is working on these op codes and

00:19:22,900 --> 00:19:26,260
they're just numbers we create an

00:19:24,400 --> 00:19:28,780
abstraction around those numbers so

00:19:26,260 --> 00:19:30,820
almost like a DSL type of type of thing

00:19:28,780 --> 00:19:32,380
that's holding on to you know the

00:19:30,820 --> 00:19:34,240
significant numbers in the VM this way

00:19:32,380 --> 00:19:37,150
so you're not like hard coding you know

00:19:34,240 --> 00:19:39,370
45 36 all over the place we have like an

00:19:37,150 --> 00:19:41,950
abstraction on that and the purpose of

00:19:39,370 --> 00:19:46,180
that abstraction is just to create this

00:19:41,950 --> 00:19:48,010
linear list of numbers and so at the end

00:19:46,180 --> 00:19:50,770
of this compilation what what do we get

00:19:48,010 --> 00:19:54,370
we get a linear list of numbers and then

00:19:50,770 --> 00:19:56,200
we get this JSON map thing that is just

00:19:54,370 --> 00:19:59,800
the user-defined literals in the system

00:19:56,200 --> 00:20:03,790
and that's it that's the basically the

00:19:59,800 --> 00:20:05,710
entire process of compiling this from

00:20:03,790 --> 00:20:10,090
this a declarative template language all

00:20:05,710 --> 00:20:13,860
the way to a binary format so next comes

00:20:10,090 --> 00:20:16,750
actually executing this thing

00:20:13,860 --> 00:20:19,270
before we get into executing I probably

00:20:16,750 --> 00:20:24,070
should unpack what a virtual machine is

00:20:19,270 --> 00:20:26,740
a virtual machine is a CPU written in in

00:20:24,070 --> 00:20:28,419
software but at the end of the day what

00:20:26,740 --> 00:20:29,770
you can really think of it as is just a

00:20:28,419 --> 00:20:32,740
while loop with a switch statement

00:20:29,770 --> 00:20:34,809
inside of it and every time you iterate

00:20:32,740 --> 00:20:37,090
that loop you're pointing at an

00:20:34,809 --> 00:20:40,600
instruction that you need to execute and

00:20:37,090 --> 00:20:42,010
then that that opcode is goes into the

00:20:40,600 --> 00:20:46,240
switch and then the switch disc

00:20:42,010 --> 00:20:48,280
dispatches the instruction so that's

00:20:46,240 --> 00:20:52,330
probably the easiest way of explaining a

00:20:48,280 --> 00:20:55,390
virtual machine so because we're dealing

00:20:52,330 --> 00:20:58,630
with binary data we actually use the

00:20:55,390 --> 00:21:00,280
fetch API in the browser and so we asked

00:20:58,630 --> 00:21:02,020
for the templates to come back as an

00:21:00,280 --> 00:21:04,990
array buffer and then we just take that

00:21:02,020 --> 00:21:07,570
array buffer and we pass it into a UN 16

00:21:04,990 --> 00:21:09,280
array which is a typed array and that's

00:21:07,570 --> 00:21:13,600
it that's that's how we get the

00:21:09,280 --> 00:21:16,000
executable into the virtual machine so

00:21:13,600 --> 00:21:18,490
this is kind of my visualization of what

00:21:16,000 --> 00:21:21,669
is actually going on inside the inside

00:21:18,490 --> 00:21:23,409
of the VM the VM works on like an

00:21:21,669 --> 00:21:25,720
iterator type of pattern so you drive

00:21:23,409 --> 00:21:27,850
the state forward you're iterating the

00:21:25,720 --> 00:21:30,730
internal loop by just calling next from

00:21:27,850 --> 00:21:32,320
the outside and then on the right we

00:21:30,730 --> 00:21:34,390
kind of have a bunch of different state

00:21:32,320 --> 00:21:36,280
here so the top is the executable that

00:21:34,390 --> 00:21:38,169
we compiled and below that is our

00:21:36,280 --> 00:21:40,390
constants pool and then we have some

00:21:38,169 --> 00:21:44,080
registers here and you can think of

00:21:40,390 --> 00:21:45,280
registers as just basically you could

00:21:44,080 --> 00:21:47,049
think of them as like an object that's

00:21:45,280 --> 00:21:49,960
holding on to state that we're going to

00:21:47,049 --> 00:21:51,850
consult as the VM is running so we have

00:21:49,960 --> 00:21:55,360
a constructing register and that

00:21:51,850 --> 00:21:59,309
register is going to hold on to HTML

00:21:55,360 --> 00:22:01,840
elements as we are building them PC is

00:21:59,309 --> 00:22:03,610
program counter or in other virtual

00:22:01,840 --> 00:22:06,429
machines you call an instruction pointer

00:22:03,610 --> 00:22:07,720
and it's always this pointing at the

00:22:06,429 --> 00:22:11,230
instruction that's currently being

00:22:07,720 --> 00:22:13,630
executed and then we have our a which is

00:22:11,230 --> 00:22:16,210
a return address for this presentation

00:22:13,630 --> 00:22:18,720
it's gonna stain negative 1 but because

00:22:16,210 --> 00:22:21,730
of the VM has components in it

00:22:18,720 --> 00:22:24,549
components are modeled like function

00:22:21,730 --> 00:22:26,200
calls so after you call into a function

00:22:24,549 --> 00:22:26,770
you need to come you need to know where

00:22:26,200 --> 00:22:28,060
you're going

00:22:26,770 --> 00:22:29,920
once you've done executing it that's

00:22:28,060 --> 00:22:31,840
what that registers for typically used

00:22:29,920 --> 00:22:34,420
for and then we have a couple different

00:22:31,840 --> 00:22:35,680
stacks there's an execution stack which

00:22:34,420 --> 00:22:36,940
isn't shown here because you don't need

00:22:35,680 --> 00:22:38,860
it for this example

00:22:36,940 --> 00:22:40,890
and then there's an element stack which

00:22:38,860 --> 00:22:44,380
is just going to hold on to our HTML

00:22:40,890 --> 00:22:47,350
elements once they've been constructed

00:22:44,380 --> 00:22:51,160
so we're gonna walk through this example

00:22:47,350 --> 00:22:54,880
step by step to show how we actually

00:22:51,160 --> 00:22:57,430
execute this binary format the other

00:22:54,880 --> 00:22:58,930
thing I'll also note is that we have the

00:22:57,430 --> 00:23:00,790
code the actual code that is being

00:22:58,930 --> 00:23:02,560
executed when we were doing this and

00:23:00,790 --> 00:23:04,690
what you'll find is the code is not all

00:23:02,560 --> 00:23:07,180
that much so the first thing that we are

00:23:04,690 --> 00:23:10,120
going to execute is open element open

00:23:07,180 --> 00:23:13,990
element is 31 and it takes one operand

00:23:10,120 --> 00:23:16,810
and that operand is 0 in this case 0 is

00:23:13,990 --> 00:23:19,660
used to be the index into the constants

00:23:16,810 --> 00:23:23,290
pool and so what it does is it pulls out

00:23:19,660 --> 00:23:25,450
the string h1 it creates a HTML heading

00:23:23,290 --> 00:23:29,020
element and places it on to the

00:23:25,450 --> 00:23:31,330
constructing register the next step is

00:23:29,020 --> 00:23:34,180
flush element now if there is actual

00:23:31,330 --> 00:23:35,620
attributes on this HTML element there

00:23:34,180 --> 00:23:37,750
would have been more instructions

00:23:35,620 --> 00:23:39,850
between open element and flushing the

00:23:37,750 --> 00:23:42,010
element but since there were none

00:23:39,850 --> 00:23:44,080
we immediately flushed the element from

00:23:42,010 --> 00:23:48,700
the constructing register and we just

00:23:44,080 --> 00:23:52,330
put it on to the element stack next is

00:23:48,700 --> 00:23:54,640
text text is pretty simple it's going to

00:23:52,330 --> 00:23:56,770
pop the element at the head of the

00:23:54,640 --> 00:23:59,350
element stack off create a text node

00:23:56,770 --> 00:24:03,370
append it and then push it back on to

00:23:59,350 --> 00:24:05,770
the stack and I guess yeah it's 26 + 1

00:24:03,370 --> 00:24:07,300
is this pointing at the first item

00:24:05,770 --> 00:24:12,040
inside of the constants pool so it knows

00:24:07,300 --> 00:24:14,260
how to pick up hello Chad next is close

00:24:12,040 --> 00:24:16,000
element what close element does is it

00:24:14,260 --> 00:24:17,860
just takes the element that's at the

00:24:16,000 --> 00:24:23,110
head of the stack and appends it to the

00:24:17,860 --> 00:24:25,630
dom and then finally we return and what

00:24:23,110 --> 00:24:27,430
return does is it just sets the the

00:24:25,630 --> 00:24:30,100
return address to the program counter

00:24:27,430 --> 00:24:32,640
which sets it to negative 1 negative 1

00:24:30,100 --> 00:24:35,050
is our way in the system to say

00:24:32,640 --> 00:24:37,360
basically halt there is no more

00:24:35,050 --> 00:24:40,400
instructions to actually execute and

00:24:37,360 --> 00:24:42,890
that's that's pretty much it that's how

00:24:40,400 --> 00:24:48,140
we take this binary format and actually

00:24:42,890 --> 00:24:49,970
turn it into a working UI so we really

00:24:48,140 --> 00:24:52,070
think about the glimmer VM as a

00:24:49,970 --> 00:24:54,320
declarative programming language for

00:24:52,070 --> 00:24:56,150
creating you eyes and the glimmer VM is

00:24:54,320 --> 00:25:00,080
a virtual machine in byte code format

00:24:56,150 --> 00:25:02,450
for constructing those you eyes so you

00:25:00,080 --> 00:25:04,760
may have also heard of this thing called

00:25:02,450 --> 00:25:07,460
web assembly and it is quote/unquote a

00:25:04,760 --> 00:25:09,620
bytecode for the web so what how does

00:25:07,460 --> 00:25:10,190
this like relate to the thing that

00:25:09,620 --> 00:25:13,520
you're building

00:25:10,190 --> 00:25:16,280
well web assembly is more of like a

00:25:13,520 --> 00:25:18,440
portable binary format than it is

00:25:16,280 --> 00:25:20,240
anything really to do with the web right

00:25:18,440 --> 00:25:22,610
now so for example you cannot call

00:25:20,240 --> 00:25:24,679
web-based api's inside of web assembly

00:25:22,610 --> 00:25:26,780
it's really good for number crunching

00:25:24,679 --> 00:25:28,970
and doing these types of really awesome

00:25:26,780 --> 00:25:34,130
demos like porting the unity gaming

00:25:28,970 --> 00:25:36,110
engine to to the web but it's still

00:25:34,130 --> 00:25:38,720
pretty interesting it has a lot of cool

00:25:36,110 --> 00:25:41,870
properties associated with it so some of

00:25:38,720 --> 00:25:44,090
those properties are how it did how its

00:25:41,870 --> 00:25:45,860
actually process on the client so on the

00:25:44,090 --> 00:25:47,090
top here we have JavaScript and

00:25:45,860 --> 00:25:48,470
JavaScript goes through parse and

00:25:47,090 --> 00:25:51,590
compile stuff and then goes through an

00:25:48,470 --> 00:25:54,679
optimization step if the code because

00:25:51,590 --> 00:25:56,450
JavaScript is a dynamic language you can

00:25:54,679 --> 00:25:58,460
deopt as you're running it so then you

00:25:56,450 --> 00:26:00,890
have to reoptimize it and throwing away

00:25:58,460 --> 00:26:02,780
any optimized code that you you have it

00:26:00,890 --> 00:26:05,170
has to execute and then you have you

00:26:02,780 --> 00:26:08,510
have to GC at certain points of time

00:26:05,170 --> 00:26:10,820
whereas web assembly it parses and

00:26:08,510 --> 00:26:14,360
compiles directly to optimized code it

00:26:10,820 --> 00:26:16,190
has no optimizing the when you actually

00:26:14,360 --> 00:26:18,620
compile it it compiles into the most

00:26:16,190 --> 00:26:21,920
optimized code and it cannot deopt

00:26:18,620 --> 00:26:24,320
and that's because you it is a compile

00:26:21,920 --> 00:26:25,940
target and you're taking languages that

00:26:24,320 --> 00:26:28,280
have static type information you're

00:26:25,940 --> 00:26:31,070
compiling it into something that is

00:26:28,280 --> 00:26:33,740
strong guarantees around it the other

00:26:31,070 --> 00:26:36,860
thing that that's really great about web

00:26:33,740 --> 00:26:40,190
assembly here is that you get it has the

00:26:36,860 --> 00:26:42,920
ability to compile faster than it is to

00:26:40,190 --> 00:26:45,170
download so it has a streaming compiler

00:26:42,920 --> 00:26:49,010
a streaming parser and compiler and

00:26:45,170 --> 00:26:50,840
javascript has this also but like like

00:26:49,010 --> 00:26:53,180
almost like the JPEG format it's already

00:26:50,840 --> 00:26:56,180
closer to the binary format so

00:26:53,180 --> 00:26:58,160
it can happen much quicker the other

00:26:56,180 --> 00:27:00,380
thing is about webassembly is that it

00:26:58,160 --> 00:27:03,020
has predictable performance and this

00:27:00,380 --> 00:27:06,140
kind of goes back to the Diop tree

00:27:03,020 --> 00:27:08,810
optimization step I'm not sure how many

00:27:06,140 --> 00:27:12,200
people saw this blog article where

00:27:08,810 --> 00:27:14,810
Mozilla took the source map library and

00:27:12,200 --> 00:27:16,490
converted parts of it to rust and then

00:27:14,810 --> 00:27:18,920
compiled the web assembly and got some

00:27:16,490 --> 00:27:20,900
like ridiculous performance benefits out

00:27:18,920 --> 00:27:25,400
of it because of the code being like

00:27:20,900 --> 00:27:27,860
highly could be highly polymorphic now

00:27:25,400 --> 00:27:30,020
you can write highly tuned JavaScript

00:27:27,860 --> 00:27:32,540
code to get to that same level of

00:27:30,020 --> 00:27:34,820
performance but not everybody is a

00:27:32,540 --> 00:27:37,520
browser engineer and knows all the fast

00:27:34,820 --> 00:27:40,670
paths inside of the actual JavaScript

00:27:37,520 --> 00:27:44,020
engine so webassembly kind of alleviates

00:27:40,670 --> 00:27:47,240
having to know all of those details but

00:27:44,020 --> 00:27:49,700
one of the issues with web assembly is

00:27:47,240 --> 00:27:52,880
that you typically have to write in a

00:27:49,700 --> 00:27:57,470
systems like language so C C++ rust and

00:27:52,880 --> 00:28:00,080
then compile them to web assembly and I

00:27:57,470 --> 00:28:02,240
don't know about you guys but this is

00:28:00,080 --> 00:28:04,820
not what I do in my day to day job I'm

00:28:02,240 --> 00:28:08,960
not writing C C simple C++ or rust

00:28:04,820 --> 00:28:13,100
applications so we we kind of it's kind

00:28:08,960 --> 00:28:15,050
of a high bar to a new entrance I think

00:28:13,100 --> 00:28:19,580
right now but I don't think it actually

00:28:15,050 --> 00:28:23,390
has to be or we we can use the fact that

00:28:19,580 --> 00:28:25,700
we have things inside the JavaScript

00:28:23,390 --> 00:28:27,650
ecosystem where we can get the benefit

00:28:25,700 --> 00:28:31,880
without actually having to directly

00:28:27,650 --> 00:28:34,940
write rust or C++ or any of those other

00:28:31,880 --> 00:28:36,860
languages and that's because in within

00:28:34,940 --> 00:28:39,590
the web community we actually have quite

00:28:36,860 --> 00:28:42,470
a few domain-specific languages already

00:28:39,590 --> 00:28:44,510
and those domain-specific languages and

00:28:42,470 --> 00:28:47,450
the runtimes for them are already

00:28:44,510 --> 00:28:50,900
written in JavaScript and so if we can

00:28:47,450 --> 00:28:54,260
pour the the runtimes of these languages

00:28:50,900 --> 00:28:55,640
to web assembly then we as people that

00:28:54,260 --> 00:28:57,560
work with JavaScript there and building

00:28:55,640 --> 00:28:59,120
things for the web can immediately get

00:28:57,560 --> 00:29:02,240
the benefit of them without actually

00:28:59,120 --> 00:29:06,260
having to learn how that stuff actually

00:29:02,240 --> 00:29:06,840
works so earlier this year we worked

00:29:06,260 --> 00:29:10,230
with

00:29:06,840 --> 00:29:12,240
folks at Mozilla and a couple people

00:29:10,230 --> 00:29:15,990
from there Russ core team to figure out

00:29:12,240 --> 00:29:18,390
how we can utilize web assembly inside

00:29:15,990 --> 00:29:21,390
of the glimmer VM so these are kind of

00:29:18,390 --> 00:29:23,880
all the high-level components of the

00:29:21,390 --> 00:29:25,170
goomar VM and what we notice is that all

00:29:23,880 --> 00:29:27,090
this stuff on the bottom

00:29:25,170 --> 00:29:29,910
the registers the opcodes the stack the

00:29:27,090 --> 00:29:32,820
heap the constants the execution are all

00:29:29,910 --> 00:29:35,400
things that if we were writing the VM

00:29:32,820 --> 00:29:38,640
and for any other platform you would

00:29:35,400 --> 00:29:42,000
probably pick a C C++ rust type of

00:29:38,640 --> 00:29:44,520
language and so what we did was that we

00:29:42,000 --> 00:29:46,680
took those implementations that were

00:29:44,520 --> 00:29:49,410
written in JavaScript and we wrote them

00:29:46,680 --> 00:29:54,540
and rust and compiled them to web

00:29:49,410 --> 00:29:56,490
assembly and everything just worked so

00:29:54,540 --> 00:29:58,530
we were able to drop that into an

00:29:56,490 --> 00:30:01,200
existing ember we were able to like take

00:29:58,530 --> 00:30:03,000
this branch build it and then drop this

00:30:01,200 --> 00:30:05,220
version in the glimmer VM directly into

00:30:03,000 --> 00:30:08,550
an existing ember application and that

00:30:05,220 --> 00:30:10,530
ember application can run the web

00:30:08,550 --> 00:30:13,680
assembly under the hood the end consumer

00:30:10,530 --> 00:30:15,420
as you are like the developer the person

00:30:13,680 --> 00:30:18,090
that wrote the application has no idea

00:30:15,420 --> 00:30:20,190
that this actually occurred and you can

00:30:18,090 --> 00:30:22,560
get the benefits that are I think now

00:30:20,190 --> 00:30:27,150
starting to really land inside of web

00:30:22,560 --> 00:30:30,360
assembly so these are all the ways I

00:30:27,150 --> 00:30:34,290
think we're actually thinking about the

00:30:30,360 --> 00:30:36,510
startup performance of applications it's

00:30:34,290 --> 00:30:38,910
a pretty tricky problem because you

00:30:36,510 --> 00:30:40,230
don't actually notice like parse and

00:30:38,910 --> 00:30:42,150
compile problems when you're first

00:30:40,230 --> 00:30:44,370
building your application and your first

00:30:42,150 --> 00:30:46,530
couple features or even when you first

00:30:44,370 --> 00:30:50,180
launch your application it's a problem

00:30:46,530 --> 00:30:52,890
that sneaks up on you over time and like

00:30:50,180 --> 00:30:55,770
we we don't do a very good job at

00:30:52,890 --> 00:30:57,360
testing the whole Rea of devices for

00:30:55,770 --> 00:31:01,500
making sure that our JavaScript startup

00:30:57,360 --> 00:31:02,820
performance is always top notch so

00:31:01,500 --> 00:31:05,040
hopefully today I showed that we

00:31:02,820 --> 00:31:07,080
actually have the technology to help

00:31:05,040 --> 00:31:08,730
mitigate a lot of these problems we just

00:31:07,080 --> 00:31:10,670
have to think I think a little bit

00:31:08,730 --> 00:31:14,400
different about how we're approaching

00:31:10,670 --> 00:31:18,150
our problems and just in development in

00:31:14,400 --> 00:31:24,809
general so that's it Thanks

00:31:18,150 --> 00:31:24,809

YouTube URL: https://www.youtube.com/watch?v=x8GoI01eVuk


