Title: Aligning Paradigms Across Client and Server(less) - Jeffrey Hoffer - JSConf US 2018
Publication date: 2018-11-10
Playlist: JSConf US 2018
Description: 
	
Captions: 
	00:00:00,320 --> 00:00:03,840
[Music]

00:00:02,070 --> 00:00:05,660
[Applause]

00:00:03,840 --> 00:00:07,410
[Music]

00:00:05,660 --> 00:00:09,280
[Applause]

00:00:07,410 --> 00:00:11,020
[Music]

00:00:09,280 --> 00:00:12,780
[Applause]

00:00:11,020 --> 00:00:15,920
[Music]

00:00:12,780 --> 00:00:15,920
[Applause]

00:00:16,870 --> 00:00:26,619
[Music]

00:00:22,230 --> 00:00:28,480
hey everybody welcome to track B again

00:00:26,619 --> 00:00:31,180
I'm Sonia and I'm really excited we have

00:00:28,480 --> 00:00:33,399
Jeff Hoffer here today give our our next

00:00:31,180 --> 00:00:35,559
talk I'm really excited about it when I

00:00:33,399 --> 00:00:37,540
was chatting well we asked you know Jeff

00:00:35,559 --> 00:00:39,160
to share with us some something that you

00:00:37,540 --> 00:00:42,219
know people might not know about him and

00:00:39,160 --> 00:00:45,490
he he mentioned that he is a really loud

00:00:42,219 --> 00:00:48,640
clapper so when I heard this I was like

00:00:45,490 --> 00:00:50,620
I also am a really loud clapper so

00:00:48,640 --> 00:00:52,239
obviously we have to have a clap off

00:00:50,620 --> 00:00:53,860
right all right are you ready

00:00:52,239 --> 00:00:57,670
we both practiced a little bit yesterday

00:00:53,860 --> 00:00:58,540
so so you ready you want to go first why

00:00:57,670 --> 00:00:59,890
do I have to go first

00:00:58,540 --> 00:01:01,600
I mean I was gonna just gonna give you

00:00:59,890 --> 00:01:01,989
the honor you're our guest here ladies

00:01:01,600 --> 00:01:03,970
first

00:01:01,989 --> 00:01:05,890
all right all right all right okay all

00:01:03,970 --> 00:01:08,320
right it's about Palm death and moisture

00:01:05,890 --> 00:01:09,969
okay so there's there she's thought

00:01:08,320 --> 00:01:17,950
about this a lot more than I I really

00:01:09,969 --> 00:01:20,049
have so it's pretty loud all right all

00:01:17,950 --> 00:01:27,100
right maybe I should have gone first I'm

00:01:20,049 --> 00:01:33,140
stressing now mine's more like an

00:01:27,100 --> 00:01:36,549
audience applause clap thank you for you

00:01:33,140 --> 00:01:36,549
[Applause]

00:01:39,000 --> 00:01:43,450
exceptional claps I think we have some

00:01:41,080 --> 00:01:45,250
competition I know definitely some good

00:01:43,450 --> 00:01:48,000
loud clappers out there well thank you

00:01:45,250 --> 00:01:50,310
all and without further ado Jeff hopper

00:01:48,000 --> 00:01:53,590
thank you thanks everybody for joining

00:01:50,310 --> 00:01:55,330
the lights are really bright so if I'm

00:01:53,590 --> 00:01:59,680
looking down the whole time that's

00:01:55,330 --> 00:02:02,530
pretty much why also this is the first

00:01:59,680 --> 00:02:04,690
time giving this talk so I hope that

00:02:02,530 --> 00:02:07,090
there aren't moments that I just pause

00:02:04,690 --> 00:02:11,290
completely and lose lose my train of

00:02:07,090 --> 00:02:13,630
thought so bear with me so the talk is

00:02:11,290 --> 00:02:15,520
we're the same you and me a new way to

00:02:13,630 --> 00:02:24,370
align programming paradigms across

00:02:15,520 --> 00:02:26,800
client and server less so the the the

00:02:24,370 --> 00:02:29,650
this talk and the the concepts and ideas

00:02:26,800 --> 00:02:31,750
in it are born out of years of

00:02:29,650 --> 00:02:34,270
experience working in startups and

00:02:31,750 --> 00:02:38,020
working on legacy systems and too often

00:02:34,270 --> 00:02:42,660
working in a start-up on a legacy system

00:02:38,020 --> 00:02:44,770
that is legacy way too quickly so I

00:02:42,660 --> 00:02:46,840
imagine some of you can relate to that

00:02:44,770 --> 00:02:51,580
and I hope there's some inspiration

00:02:46,840 --> 00:02:54,820
there for all of us when when I talk

00:02:51,580 --> 00:02:57,640
about a new way of programming to align

00:02:54,820 --> 00:03:00,880
these paradigms and more generally

00:02:57,640 --> 00:03:03,480
execution environments I am referring to

00:03:00,880 --> 00:03:08,470
something I call the towel model or

00:03:03,480 --> 00:03:11,350
towel programming paradigm and it has

00:03:08,470 --> 00:03:14,890
three specific parts it provides a

00:03:11,350 --> 00:03:17,709
message format three various ways to

00:03:14,890 --> 00:03:23,620
handle messages and a signal network

00:03:17,709 --> 00:03:27,190
it's the audio okay the towel model

00:03:23,620 --> 00:03:29,410
derives its name from an acronym for the

00:03:27,190 --> 00:03:32,470
message format to make it easy to

00:03:29,410 --> 00:03:37,000
remember especially the ordering of the

00:03:32,470 --> 00:03:39,489
parts and every message we're used to

00:03:37,000 --> 00:03:47,470
messaging that specifies the action or

00:03:39,489 --> 00:03:50,739
operation but the towel message differs

00:03:47,470 --> 00:03:52,780
from traditional messaging in a few ways

00:03:50,739 --> 00:03:56,530
specifically provides three degrees of

00:03:52,780 --> 00:03:59,709
freedom which will make a lot more sense

00:03:56,530 --> 00:04:03,970
when you see it using in wildcard

00:03:59,709 --> 00:04:06,160
handlers also we embed the subject of

00:04:03,970 --> 00:04:08,709
the message within the message itself

00:04:06,160 --> 00:04:11,620
whereas most messaging systems or most

00:04:08,709 --> 00:04:13,780
messaging we're used to this subject is

00:04:11,620 --> 00:04:16,510
either the source or the destination of

00:04:13,780 --> 00:04:19,959
the message and the inclusion of a third

00:04:16,510 --> 00:04:21,970
dimension the orientation allowing us to

00:04:19,959 --> 00:04:24,220
view the description and context of our

00:04:21,970 --> 00:04:31,390
application from all angles not just a

00:04:24,220 --> 00:04:34,060
two-dimensional view so the towel model

00:04:31,390 --> 00:04:35,710
also provides three distinct ways in

00:04:34,060 --> 00:04:38,380
which we can attach handlers to our

00:04:35,710 --> 00:04:40,690
signal network in line handlers are

00:04:38,380 --> 00:04:43,300
those that were most used to invented

00:04:40,690 --> 00:04:45,730
systems they happen in an ordered

00:04:43,300 --> 00:04:49,000
sequence and these are our order desired

00:04:45,730 --> 00:04:52,360
effects but it also provides two other

00:04:49,000 --> 00:04:55,900
mechanisms one is an async attachment so

00:04:52,360 --> 00:04:57,100
that we can explicitly create

00:04:55,900 --> 00:05:00,100
out-of-band

00:04:57,100 --> 00:05:02,410
side-effects as well as an intercept

00:05:00,100 --> 00:05:10,139
handler that allows us to halt operation

00:05:02,410 --> 00:05:13,420
and add guards to our execution flow in

00:05:10,139 --> 00:05:21,670
the towel model our trigrams describe

00:05:13,420 --> 00:05:23,139
discrete application oh sorry in the

00:05:21,670 --> 00:05:26,560
towel model our trigrams to describe

00:05:23,139 --> 00:05:28,720
discrete application contexts we use a

00:05:26,560 --> 00:05:30,490
signal network that connects those parts

00:05:28,720 --> 00:05:33,330
that are generating these application

00:05:30,490 --> 00:05:36,070
context to our handler code which is

00:05:33,330 --> 00:05:40,750
observing and reacting to these

00:05:36,070 --> 00:05:44,639
application contexts our signal network

00:05:40,750 --> 00:05:49,450
also provides the ability to chain these

00:05:44,639 --> 00:05:52,990
messages in a way simply by returning a

00:05:49,450 --> 00:05:56,740
new application context to the signal

00:05:52,990 --> 00:05:58,180
network from your handler in this way

00:05:56,740 --> 00:06:00,400
our signal network is

00:05:58,180 --> 00:06:01,960
implemented the same and has the same

00:06:00,400 --> 00:06:03,580
interface no matter whether you're

00:06:01,960 --> 00:06:09,280
executing it on the client or a server

00:06:03,580 --> 00:06:10,979
or a server loose this the towel model

00:06:09,280 --> 00:06:15,009
is currently implemented in JavaScript

00:06:10,979 --> 00:06:18,850
under the name of Tao das there are

00:06:15,009 --> 00:06:20,860
three packages on NPM published the core

00:06:18,850 --> 00:06:25,960
implements the towel model itself and

00:06:20,860 --> 00:06:27,820
provides the public API you can include

00:06:25,960 --> 00:06:30,160
it in any package you want and start

00:06:27,820 --> 00:06:33,820
using it right away

00:06:30,160 --> 00:06:37,169
react package provides an adapter to

00:06:33,820 --> 00:06:40,509
turn components into towel handlers as

00:06:37,169 --> 00:06:45,099
well as a reactor component that will

00:06:40,509 --> 00:06:46,750
react to the signal network and render

00:06:45,099 --> 00:06:49,960
the correct the component that you'd

00:06:46,750 --> 00:06:53,770
like the socket IO package implements

00:06:49,960 --> 00:06:58,389
the signal network so that it spans

00:06:53,770 --> 00:07:04,389
client and server so let's take a look

00:06:58,389 --> 00:07:07,139
at some code y'all can see that okay

00:07:04,389 --> 00:07:07,139
should I um

00:07:15,130 --> 00:07:37,020
let me move all of these hides ease

00:07:32,260 --> 00:07:42,420
how's that a little more a little more

00:07:37,020 --> 00:07:46,420
better one bitter to bear one better to

00:07:42,420 --> 00:07:50,140
I can't see an optometrist and not crack

00:07:46,420 --> 00:07:54,370
up when I'm going through that so simply

00:07:50,140 --> 00:07:56,650
tell Jo score we go ahead and import the

00:07:54,370 --> 00:07:59,530
tau which is our signal network

00:07:56,650 --> 00:08:02,590
implementation here and then there's

00:07:59,530 --> 00:08:06,570
another piece that we can import is it

00:08:02,590 --> 00:08:08,950
app CT X so that allows us to generate

00:08:06,570 --> 00:08:12,550
application context that we can return

00:08:08,950 --> 00:08:16,840
from a handler until the signal network

00:08:12,550 --> 00:08:26,140
to chain down to this next message or

00:08:16,840 --> 00:08:31,800
event or application context in addition

00:08:26,140 --> 00:08:36,460
we for up for our server we are

00:08:31,800 --> 00:08:42,039
importing our wire tau J s to suck at

00:08:36,460 --> 00:08:43,840
i/o and that's all we need from there so

00:08:42,039 --> 00:08:50,590
once our server is set up so this is a

00:08:43,840 --> 00:09:02,080
KOA server attaching a socket IO for

00:08:50,590 --> 00:09:05,290
each each socket that comes in we will

00:09:02,080 --> 00:09:12,040
wire it up and use our unconnect method

00:09:05,290 --> 00:09:14,280
in it client towel so on the server side

00:09:12,040 --> 00:09:17,380
we need we actually end up with two

00:09:14,280 --> 00:09:21,940
signal networks one that we can use to

00:09:17,380 --> 00:09:25,870
handle all application contexts and ones

00:09:21,940 --> 00:09:28,420
that are specific to our client so

00:09:25,870 --> 00:09:29,119
whenever a connection occurs this one is

00:09:28,420 --> 00:09:32,299
called back

00:09:29,119 --> 00:09:39,289
and then we attach our handlers to it on

00:09:32,299 --> 00:09:42,519
the client side specifically so our NIC

00:09:39,289 --> 00:09:47,659
client ow we get the we get the new

00:09:42,519 --> 00:09:51,529
client ow and it has an ID I'll ignore

00:09:47,659 --> 00:09:53,899
that for now so we set up some inline

00:09:51,529 --> 00:10:00,739
handlers that we need to occur on our

00:09:53,899 --> 00:10:02,869
server our example application it's

00:10:00,739 --> 00:10:05,929
super bare-bones just to be an example

00:10:02,869 --> 00:10:08,299
so that you get the gist of what's

00:10:05,929 --> 00:10:12,739
happening and I'm not dazzling you with

00:10:08,299 --> 00:10:15,669
my terrible CSS so the concept of behind

00:10:12,739 --> 00:10:18,469
it is it's a it's an application for

00:10:15,669 --> 00:10:22,579
creating your own spaces of your own

00:10:18,469 --> 00:10:28,219
vocabulary words and so it's going to

00:10:22,579 --> 00:10:31,009
have spaces and phrases within those

00:10:28,219 --> 00:10:33,739
spaces so for for now we're just using

00:10:31,009 --> 00:10:38,179
the space as an example so on this we

00:10:33,739 --> 00:10:41,359
have a term space an action of find and

00:10:38,179 --> 00:10:45,019
our orientation is the portal that most

00:10:41,359 --> 00:10:48,349
users will see so we have an async

00:10:45,019 --> 00:10:51,939
operation where we're going to take what

00:10:48,349 --> 00:10:54,789
we're being asked to find find can be

00:10:51,939 --> 00:10:57,409
undefined or it could have a specific ID

00:10:54,789 --> 00:11:01,219
which tells our handler to react in

00:10:57,409 --> 00:11:02,839
different ways it will use our spaces to

00:11:01,219 --> 00:11:05,389
go find the spaces if there's no

00:11:02,839 --> 00:11:08,539
specific ID so it'll go get all of the

00:11:05,389 --> 00:11:12,109
spaces or it'll return it'll find one

00:11:08,539 --> 00:11:14,899
and return it directly if we encounter

00:11:12,109 --> 00:11:18,489
any errors we set up in action we we

00:11:14,899 --> 00:11:21,829
chain on towards a space of a fail and

00:11:18,489 --> 00:11:25,189
we send that message on so that the

00:11:21,829 --> 00:11:35,959
client can react so this is very basic

00:11:25,189 --> 00:11:40,599
stuff go ahead and lose all that inside

00:11:35,959 --> 00:11:40,599
of our web application

00:11:50,580 --> 00:12:00,670
so up in here when the client loads

00:11:55,860 --> 00:12:02,280
we're going to import this cow in it

00:12:00,670 --> 00:12:05,530
which will give us an initial

00:12:02,280 --> 00:12:08,080
application context to set to set the

00:12:05,530 --> 00:12:10,840
wheels in motion within our signal

00:12:08,080 --> 00:12:17,950
network that somebody has entered

00:12:10,840 --> 00:12:21,030
entered the application that file looks

00:12:17,950 --> 00:12:30,400
like this so this sets up our socket IO

00:12:21,030 --> 00:12:35,860
connection and and and then sets up a

00:12:30,400 --> 00:12:40,600
series of handlers that will occur as

00:12:35,860 --> 00:12:43,300
where as the application is going so we

00:12:40,600 --> 00:12:46,300
have an app enter portal app view the

00:12:43,300 --> 00:12:51,520
portal session fine portal session

00:12:46,300 --> 00:12:56,280
create portal so we add an inline

00:12:51,520 --> 00:13:02,440
handler for when somebody enters the app

00:12:56,280 --> 00:13:04,360
and we return a view application context

00:13:02,440 --> 00:13:07,810
that we want to happen when the app view

00:13:04,360 --> 00:13:11,440
portal happens we want to go find spaces

00:13:07,810 --> 00:13:13,540
and we don't we don't specify any one

00:13:11,440 --> 00:13:19,920
space by giving it an ID so it returns

00:13:13,540 --> 00:13:19,920
everything these are old

00:13:26,130 --> 00:13:39,920
so as we react to the find oh this is so

00:13:35,670 --> 00:13:45,209
once that's how our find method our fine

00:13:39,920 --> 00:13:47,910
kicks off what happens on the server so

00:13:45,209 --> 00:13:51,240
this is going to respond with a list so

00:13:47,910 --> 00:13:56,209
let me start fire these up and pray that

00:13:51,240 --> 00:13:56,209
it works should it's pretty simple

00:14:04,310 --> 00:14:11,829
it's my fault for commenting out things

00:14:08,810 --> 00:14:11,829
I thought I didn't need

00:14:24,280 --> 00:14:37,480
okay Cole you're back in actually I'm

00:14:35,560 --> 00:14:39,760
just gonna put all this rest stuff back

00:14:37,480 --> 00:14:45,640
in so when I first built that I was

00:14:39,760 --> 00:14:50,350
testing it out with not using socket IO

00:14:45,640 --> 00:14:59,100
but interacting with a REST API which

00:14:50,350 --> 00:14:59,100
works just fine there we go now let's

00:15:11,250 --> 00:15:14,180
welcome

00:15:35,180 --> 00:15:53,060
something I didn't what's that yeah

00:15:47,010 --> 00:15:53,060
that's probably probably the best idea

00:15:55,660 --> 00:16:03,430
get reset head force force push

00:16:21,890 --> 00:16:24,670
see

00:16:30,889 --> 00:16:41,550
there we go thank you so what we see

00:16:37,920 --> 00:16:48,750
here is and I will just clear the

00:16:41,550 --> 00:16:51,180
console refresh a series of series of

00:16:48,750 --> 00:16:54,480
events occur as we go through this

00:16:51,180 --> 00:16:59,220
process of bootstrapping and rendering

00:16:54,480 --> 00:17:02,839
our app good we initially we initially

00:16:59,220 --> 00:17:07,319
set off the app enter portal which then

00:17:02,839 --> 00:17:13,740
kicks off of trying to find a session

00:17:07,319 --> 00:17:16,549
that exists and this is done we have an

00:17:13,740 --> 00:17:22,020
async handler for that so we don't block

00:17:16,549 --> 00:17:24,329
the app view from happening and we enter

00:17:22,020 --> 00:17:27,150
the session when this is found we go

00:17:24,329 --> 00:17:30,290
find spaces so that we can list them and

00:17:27,150 --> 00:17:30,290
show the ListView

00:17:34,280 --> 00:17:44,240
so showing how it integrates with react

00:17:40,750 --> 00:17:47,360
in our app we see we simply are grabbing

00:17:44,240 --> 00:17:52,060
space from our components and then

00:17:47,360 --> 00:17:55,580
rendering it here so in our index here

00:17:52,060 --> 00:17:58,010
what we're doing is creating a space

00:17:55,580 --> 00:18:00,980
container and we have two different

00:17:58,010 --> 00:18:06,710
reactor components that are exported

00:18:00,980 --> 00:18:10,430
from our tower dot J's react package

00:18:06,710 --> 00:18:17,300
along with the adapter the adapter we

00:18:10,430 --> 00:18:21,490
use as a way of adapting we wrap our Tau

00:18:17,300 --> 00:18:25,280
signal Network and then set a default

00:18:21,490 --> 00:18:28,990
context so that all the all the

00:18:25,280 --> 00:18:31,640
component handlers we set I'll use

00:18:28,990 --> 00:18:33,190
determine Orient for space and portal so

00:18:31,640 --> 00:18:36,410
we don't have to keep repeating those

00:18:33,190 --> 00:18:38,690
and then if the action comes in as list

00:18:36,410 --> 00:18:41,030
we want to show the list view the list

00:18:38,690 --> 00:18:43,280
component if it's a view we want to have

00:18:41,030 --> 00:18:46,010
the view component and if it's a new or

00:18:43,280 --> 00:18:51,820
edit action we want to show the form

00:18:46,010 --> 00:18:56,570
component now if you if you look here

00:18:51,820 --> 00:18:59,990
each of these the view components are

00:18:56,570 --> 00:19:02,360
just basic react components the space

00:18:59,990 --> 00:19:04,810
view is a functional component it has

00:19:02,360 --> 00:19:07,820
nothing to do with the Tau except for

00:19:04,810 --> 00:19:11,620
using the signal Network to actually set

00:19:07,820 --> 00:19:11,620
the context if somebody clicks a button

00:19:12,400 --> 00:19:20,720
same with the list it's you know nested

00:19:17,600 --> 00:19:24,440
components and then our form component

00:19:20,720 --> 00:19:27,080
is you know extends component has an

00:19:24,440 --> 00:19:29,450
editable state within it but it's it's

00:19:27,080 --> 00:19:33,470
not doing anything with the tau other

00:19:29,450 --> 00:19:37,130
than being a handler for an application

00:19:33,470 --> 00:19:39,730
context and pretty prettier is

00:19:37,130 --> 00:19:39,730
complaining

00:19:42,489 --> 00:20:08,109
so if I knew save it we now have that

00:20:00,979 --> 00:20:08,109
space and go back to the list can edit

00:20:11,649 --> 00:20:24,409
it's there so all of the code is built

00:20:22,700 --> 00:20:27,339
using the same paradigm for the

00:20:24,409 --> 00:20:35,149
client-side as well as the server-side

00:20:27,339 --> 00:20:36,440
and jump back to our presentation so all

00:20:35,149 --> 00:20:40,539
of my friends and colleagues that have

00:20:36,440 --> 00:20:40,539
shown this to say hey that's really cool

00:20:40,899 --> 00:20:46,239
but they always ask me the same question

00:20:46,299 --> 00:20:54,919
why do we want this as a as a plucky

00:20:51,979 --> 00:20:58,219
recent college grad with my first

00:20:54,919 --> 00:21:01,059
corporate job my first corporate boss I

00:20:58,219 --> 00:21:03,440
was armed with design patterns as a

00:21:01,059 --> 00:21:06,709
solution to all the coding and

00:21:03,440 --> 00:21:08,869
architectural problems so when I noticed

00:21:06,709 --> 00:21:11,929
that the team wasn't talking about

00:21:08,869 --> 00:21:13,459
design patterns in any way and largely

00:21:11,929 --> 00:21:17,629
nobody seemed to have heard of them I

00:21:13,459 --> 00:21:19,099
went to my boss and I said hey I'd like

00:21:17,629 --> 00:21:20,389
to give a presentation on design

00:21:19,099 --> 00:21:21,979
patterns I think he would really help

00:21:20,389 --> 00:21:24,709
the team I think it would really help us

00:21:21,979 --> 00:21:29,089
the applications were building and he

00:21:24,709 --> 00:21:31,009
responded with all software approaches a

00:21:29,089 --> 00:21:38,679
state of entropy over time so I don't

00:21:31,009 --> 00:21:38,679
see any point in design patterns thanks

00:21:38,779 --> 00:21:46,869
true story I'm pretty sure he was

00:21:44,149 --> 00:21:48,919
talking about the second definition here

00:21:46,869 --> 00:21:53,299
since we were talking about how to build

00:21:48,919 --> 00:21:56,629
project management software and customer

00:21:53,299 --> 00:22:00,440
service software and as much as I didn't

00:21:56,629 --> 00:22:02,539
like it he was right all software

00:22:00,440 --> 00:22:08,509
systems do end up heading towards

00:22:02,539 --> 00:22:10,399
entropy and states of disorder so we

00:22:08,509 --> 00:22:13,159
have three major causes of entropy in

00:22:10,399 --> 00:22:16,220
our applications most of which are born

00:22:13,159 --> 00:22:19,940
out of this need to build and prove our

00:22:16,220 --> 00:22:22,279
application and what we want to create

00:22:19,940 --> 00:22:25,429
without incurring the overhead of

00:22:22,279 --> 00:22:27,200
building it right even in cases where we

00:22:25,429 --> 00:22:30,139
set off to build it right because we

00:22:27,200 --> 00:22:32,779
have budget and time managing these

00:22:30,139 --> 00:22:34,549
three factors through traditional

00:22:32,779 --> 00:22:38,259
architectural and design patterns

00:22:34,549 --> 00:22:38,259
attempt to control the entropy

00:22:39,970 --> 00:22:44,179
microservices is another evolution in

00:22:42,590 --> 00:22:47,299
this direction of controlling entropy

00:22:44,179 --> 00:22:49,519
and systems but they come with

00:22:47,299 --> 00:22:52,059
additional overhead requiring additional

00:22:49,519 --> 00:22:59,119
tooling and support and infrastructure

00:22:52,059 --> 00:23:04,239
in order to embrace them so what if we

00:22:59,119 --> 00:23:06,499
embrace the entropy we know it's coming

00:23:04,239 --> 00:23:08,749
what would what would it look like if we

00:23:06,499 --> 00:23:11,599
could just embrace the entropy that's

00:23:08,749 --> 00:23:15,289
coming in our system we would have to

00:23:11,599 --> 00:23:18,200
plan to manage these three aspects of

00:23:15,289 --> 00:23:20,090
entropy the tight coupling scaling

00:23:18,200 --> 00:23:23,739
across processes and extending our

00:23:20,090 --> 00:23:23,739
application beyond its original concept

00:23:23,889 --> 00:23:30,049
so in the seminal work that started the

00:23:26,330 --> 00:23:34,039
design patterns movement the Gang of

00:23:30,049 --> 00:23:36,190
Four put a quote in there that was

00:23:34,039 --> 00:23:38,809
designed to make us better developers

00:23:36,190 --> 00:23:44,840
it's programmed to an interface and not

00:23:38,809 --> 00:23:47,659
an implementation interesting in that in

00:23:44,840 --> 00:23:49,840
an interview in 2005 Erich gamma one of

00:23:47,659 --> 00:23:56,619
the art of

00:23:49,840 --> 00:23:59,480
design patterns book spoke about

00:23:56,619 --> 00:24:03,379
interfaces defining the vocabulary of

00:23:59,480 --> 00:24:07,279
the collaboration of a system and how

00:24:03,379 --> 00:24:08,779
understanding these interfaces you could

00:24:07,279 --> 00:24:13,789
get an understanding of the underlying

00:24:08,779 --> 00:24:18,470
problem of a system so if we want to

00:24:13,789 --> 00:24:21,080
embrace him entropy by avoiding the

00:24:18,470 --> 00:24:22,549
tight coupling and elaborating on Eric's

00:24:21,080 --> 00:24:26,629
words we need a mechanism for

00:24:22,549 --> 00:24:29,029
comprehensive interfaces comprehensive

00:24:26,629 --> 00:24:31,700
has two definitions and we want to use

00:24:29,029 --> 00:24:33,379
both of them we want our interfaces to

00:24:31,700 --> 00:24:36,909
completely define our system while we

00:24:33,379 --> 00:24:36,909
also want them to be easily understood

00:24:37,179 --> 00:24:41,960
we end up spending time and effort

00:24:39,830 --> 00:24:45,799
abstracting the fact that we are using a

00:24:41,960 --> 00:24:50,149
REST API as a back-end from our client

00:24:45,799 --> 00:24:53,149
app creating overhead and abstraction

00:24:50,149 --> 00:24:55,539
for what we never end up swapping out

00:24:53,149 --> 00:25:01,249
the REST API for something different

00:24:55,539 --> 00:25:02,989
that takes too much time most often

00:25:01,249 --> 00:25:04,730
these abstractions and interfaces we

00:25:02,989 --> 00:25:07,009
create deal with the Hal of our system

00:25:04,730 --> 00:25:10,369
through the point I've seen applications

00:25:07,009 --> 00:25:13,279
that have a react client app with three

00:25:10,369 --> 00:25:16,340
different mapping layers from Redux to

00:25:13,279 --> 00:25:18,919
our component and this ends up just

00:25:16,340 --> 00:25:20,419
creating a lot of overhead for the next

00:25:18,919 --> 00:25:23,899
developer coming along that has to add

00:25:20,419 --> 00:25:25,850
something to it this is where

00:25:23,899 --> 00:25:28,549
domain-driven design can help us to find

00:25:25,850 --> 00:25:31,850
the what of our system and focus our

00:25:28,549 --> 00:25:34,190
interface attention where changes

00:25:31,850 --> 00:25:36,669
towards disorder occur most and that is

00:25:34,190 --> 00:25:41,269
in the what

00:25:36,669 --> 00:25:44,330
so our towel message is the interface we

00:25:41,269 --> 00:25:48,230
can use these trigrams of term action

00:25:44,330 --> 00:25:50,299
and orient to create an interface

00:25:48,230 --> 00:25:52,909
description that anyone else can easily

00:25:50,299 --> 00:25:54,129
comprehend as well as create a handler

00:25:52,909 --> 00:25:56,389
for it

00:25:54,129 --> 00:25:58,730
and we generally think of terms as

00:25:56,389 --> 00:26:00,259
entities in our domain from the main

00:25:58,730 --> 00:26:02,790
drive in design but it can also

00:26:00,259 --> 00:26:05,520
represent a relationship or other

00:26:02,790 --> 00:26:09,150
term non domain term that is useful for

00:26:05,520 --> 00:26:12,390
our applications by being distinct three

00:26:09,150 --> 00:26:14,760
mesthri strings to represent a possible

00:26:12,390 --> 00:26:16,400
application context the Tao trigrams are

00:26:14,760 --> 00:26:21,420
not bounded to anything other than

00:26:16,400 --> 00:26:23,370
representing what your app is doing now

00:26:21,420 --> 00:26:25,200
when we're generating an event in our

00:26:23,370 --> 00:26:27,450
system all it needs to do is provide

00:26:25,200 --> 00:26:29,790
these specific application context of

00:26:27,450 --> 00:26:34,500
the event this includes the Tao trigram

00:26:29,790 --> 00:26:37,890
and the complete attached data that goes

00:26:34,500 --> 00:26:39,600
along with it and our handlers are

00:26:37,890 --> 00:26:41,220
called when the trigram matches what

00:26:39,600 --> 00:26:46,020
they've subscribed to so they just wait

00:26:41,220 --> 00:26:48,030
for the outcome and react to it we know

00:26:46,020 --> 00:26:49,860
we have now resolved our tight coupling

00:26:48,030 --> 00:26:51,750
problem with a simple mechanism for

00:26:49,860 --> 00:26:54,180
defining interfaces that abstract of

00:26:51,750 --> 00:26:55,620
what of our application and we didn't

00:26:54,180 --> 00:26:57,960
choose a message driven paradigm by

00:26:55,620 --> 00:26:59,940
accident the next problem to tackle

00:26:57,960 --> 00:27:05,820
entropy in our system is to deal with

00:26:59,940 --> 00:27:10,290
the scale problem this problem usually

00:27:05,820 --> 00:27:13,620
has shows up in algorithms that are

00:27:10,290 --> 00:27:17,220
written that aren't made to deal with

00:27:13,620 --> 00:27:20,130
scale and they're deeply embedded and

00:27:17,220 --> 00:27:23,070
they calcify to the point where once

00:27:20,130 --> 00:27:25,590
it's time to scale we have to pull back

00:27:23,070 --> 00:27:30,540
and find and rip these things out deep

00:27:25,590 --> 00:27:33,600
within our application architecture so

00:27:30,540 --> 00:27:37,680
to embrace the intro this entropic cause

00:27:33,600 --> 00:27:39,630
we need to decouple scalability from our

00:27:37,680 --> 00:27:42,510
system that we used to build the

00:27:39,630 --> 00:27:44,570
application itself and we do this by

00:27:42,510 --> 00:27:48,480
using an evented message oriented

00:27:44,570 --> 00:27:53,790
architecture baked into the baked into

00:27:48,480 --> 00:27:56,430
the towel through the signal network so

00:27:53,790 --> 00:27:58,620
this is a quote from Wikipedia I

00:27:56,430 --> 00:28:01,860
remember it slightly differently from my

00:27:58,620 --> 00:28:06,000
object-oriented class in the reading in

00:28:01,860 --> 00:28:09,840
in in college and I was struck by this

00:28:06,000 --> 00:28:12,360
concept that when an object calls a

00:28:09,840 --> 00:28:16,340
method on another object it is passing a

00:28:12,360 --> 00:28:16,340
message to that object and

00:28:16,659 --> 00:28:21,950
this original definition came from small

00:28:19,580 --> 00:28:26,200
talk where it literally was passing a

00:28:21,950 --> 00:28:29,090
message in the implementation but the

00:28:26,200 --> 00:28:33,619
the metaphor and the abstraction is the

00:28:29,090 --> 00:28:35,749
same so in essence we're already

00:28:33,619 --> 00:28:38,269
building message oriented applications

00:28:35,749 --> 00:28:40,009
we just don't seem to agree on the

00:28:38,269 --> 00:28:45,679
message format and the messaging

00:28:40,009 --> 00:28:48,139
paradigm itself so this is not a new

00:28:45,679 --> 00:28:50,330
pattern but one which we have separated

00:28:48,139 --> 00:28:53,330
client for back-end when we build our

00:28:50,330 --> 00:28:55,159
event and message based systems event

00:28:53,330 --> 00:28:59,899
that implementations written dated from

00:28:55,159 --> 00:29:03,019
user interface designs long ago with the

00:28:59,899 --> 00:29:06,769
observer pattern which that's our signal

00:29:03,019 --> 00:29:09,979
Network uses to its advantage message

00:29:06,769 --> 00:29:13,879
bus systems are prevalent in high skill

00:29:09,979 --> 00:29:17,679
high scale backends and using message

00:29:13,879 --> 00:29:21,519
buses and the the problem with that

00:29:17,679 --> 00:29:24,259
generally that I've come across is that

00:29:21,519 --> 00:29:25,879
whenever you decide to go with a message

00:29:24,259 --> 00:29:27,649
oriented back-end you then have to

00:29:25,879 --> 00:29:31,759
decide what is the format for our

00:29:27,649 --> 00:29:34,970
messages every time by leveraging the

00:29:31,759 --> 00:29:37,099
Tao trigram message we got the format

00:29:34,970 --> 00:29:40,879
figured out it's dynamic enough that we

00:29:37,099 --> 00:29:45,080
can allow it to work for any context in

00:29:40,879 --> 00:29:47,269
any situation now the flux architecture

00:29:45,080 --> 00:29:50,690
introduced a lot of people to the

00:29:47,269 --> 00:29:53,059
concept of unidirectional data flow and

00:29:50,690 --> 00:29:56,359
it's something that existed in backend

00:29:53,059 --> 00:29:58,039
data processing for some time and it's

00:29:56,359 --> 00:30:00,429
now a welcome addition and client side

00:29:58,039 --> 00:30:03,799
development the DAO embraces

00:30:00,429 --> 00:30:07,279
unidirectional data flow in that

00:30:03,799 --> 00:30:09,889
handlers when you set the context on the

00:30:07,279 --> 00:30:12,320
single network there is no return coming

00:30:09,889 --> 00:30:15,289
back to the caller so there's nothing to

00:30:12,320 --> 00:30:17,299
sit there and wait for so you're setting

00:30:15,289 --> 00:30:21,859
a context and letting it propagate

00:30:17,299 --> 00:30:24,440
through your system this allows us to

00:30:21,859 --> 00:30:27,549
have a single paradigm across all the

00:30:24,440 --> 00:30:27,549
execution environments

00:30:27,809 --> 00:30:31,649
so now that we found a wave to decouple

00:30:30,269 --> 00:30:33,869
scalability from our application

00:30:31,649 --> 00:30:39,090
building system across all environments

00:30:33,869 --> 00:30:41,549
to resolve the scale problem we can

00:30:39,090 --> 00:30:43,710
embrace the entropy to come we need to

00:30:41,549 --> 00:30:47,580
have a way to evolve our application

00:30:43,710 --> 00:30:49,349
beyond its original intent again micro

00:30:47,580 --> 00:30:51,090
services have come to our aid in this

00:30:49,349 --> 00:30:54,359
department but once again on the side of

00:30:51,090 --> 00:30:56,580
controlling entropy micro services as an

00:30:54,359 --> 00:30:59,340
architectural choice move us back in the

00:30:56,580 --> 00:31:02,909
direction towards korba and decom of

00:30:59,340 --> 00:31:04,409
distributed components but in this case

00:31:02,909 --> 00:31:06,479
we're running them in their own

00:31:04,409 --> 00:31:08,909
processes they have ownership of their

00:31:06,479 --> 00:31:11,580
own data and they leverage web standards

00:31:08,909 --> 00:31:15,719
for their network and interface

00:31:11,580 --> 00:31:17,190
definitions but what we're really

00:31:15,719 --> 00:31:21,210
looking for is not just the

00:31:17,190 --> 00:31:25,349
componentized development but a method

00:31:21,210 --> 00:31:27,409
for adding or injecting extensions to

00:31:25,349 --> 00:31:31,769
our application and our in our system

00:31:27,409 --> 00:31:38,389
that we didn't think of while we were

00:31:31,769 --> 00:31:38,389
building it this is to embrace entropy

00:31:41,899 --> 00:31:48,960
many frameworks actually provide

00:31:44,489 --> 00:31:51,089
extension points within them but all of

00:31:48,960 --> 00:31:52,320
these extension points are tied to the

00:31:51,089 --> 00:31:54,559
given framework and there's no

00:31:52,320 --> 00:31:57,119
standardization across frameworks

00:31:54,559 --> 00:32:04,589
there's no standardization of extension

00:31:57,119 --> 00:32:06,899
mechanisms from client and server so

00:32:04,589 --> 00:32:10,489
there are you guessed it three ways the

00:32:06,899 --> 00:32:12,929
Tao implements dynamic extension points

00:32:10,489 --> 00:32:17,759
if anybody's counting the number of

00:32:12,929 --> 00:32:20,489
times I say three the first is the three

00:32:17,759 --> 00:32:23,460
different types of message handlers the

00:32:20,489 --> 00:32:25,649
intercept async and inline if you notice

00:32:23,460 --> 00:32:26,999
I flipped the order from when I

00:32:25,649 --> 00:32:31,049
introduced them at the beginning and

00:32:26,999 --> 00:32:34,190
that is because this is in this is in

00:32:31,049 --> 00:32:38,639
the priority order in which they are

00:32:34,190 --> 00:32:42,690
executed by the signal network and this

00:32:38,639 --> 00:32:46,480
gives us a way to deterministically

00:32:42,690 --> 00:32:48,790
configure the order in which our

00:32:46,480 --> 00:32:52,590
handlers will be called even though

00:32:48,790 --> 00:32:52,590
they're added to the system dynamically

00:32:53,490 --> 00:32:59,080
the second way is through while the

00:32:56,710 --> 00:33:01,750
second way for dynamic extension is

00:32:59,080 --> 00:33:05,620
through wildcard handlers so we can add

00:33:01,750 --> 00:33:08,110
handlers that can handle in this case

00:33:05,620 --> 00:33:11,710
anything anytime anything is added on

00:33:08,110 --> 00:33:15,880
the admin or we could have a wildcard

00:33:11,710 --> 00:33:19,410
for any of them any any application

00:33:15,880 --> 00:33:23,890
context that comes through any message

00:33:19,410 --> 00:33:27,100
and the third way is through this

00:33:23,890 --> 00:33:28,840
chaining mechanism as we build our

00:33:27,100 --> 00:33:31,240
application we're not going to think of

00:33:28,840 --> 00:33:31,800
everything ahead of time and that's by

00:33:31,240 --> 00:33:35,230
design

00:33:31,800 --> 00:33:37,030
entropy occurs when our product managers

00:33:35,230 --> 00:33:41,410
come to us and say well I need it to do

00:33:37,030 --> 00:33:44,110
this now so we can now inject a new

00:33:41,410 --> 00:33:46,690
event in our chain a new message in our

00:33:44,110 --> 00:33:49,030
chain and then subscribe to that and add

00:33:46,690 --> 00:33:54,400
a new handler and then thus not touching

00:33:49,030 --> 00:33:56,890
anything between so aspect oriented

00:33:54,400 --> 00:33:59,260
programming is a paradigm that allows a

00:33:56,890 --> 00:34:01,570
separation of application logic from

00:33:59,260 --> 00:34:07,120
what's called application wide or

00:34:01,570 --> 00:34:11,860
cross-cutting concerns like security and

00:34:07,120 --> 00:34:14,830
logging most AOP implementations provide

00:34:11,860 --> 00:34:18,100
point cut systems that perform cross

00:34:14,830 --> 00:34:23,070
compilation to inject code but they're

00:34:18,100 --> 00:34:27,970
generally focused on binaries and single

00:34:23,070 --> 00:34:29,740
single execution single executables by

00:34:27,970 --> 00:34:32,200
broadcasting our town' messages on the

00:34:29,740 --> 00:34:34,000
signal network we can have our AOP

00:34:32,200 --> 00:34:39,850
cross-cutting concerns handled

00:34:34,000 --> 00:34:41,590
system-wide and we get this for free so

00:34:39,850 --> 00:34:43,720
now that we've resolved to embrace the

00:34:41,590 --> 00:34:45,910
entropy to come of our application by

00:34:43,720 --> 00:34:48,550
considering all three major causes of

00:34:45,910 --> 00:34:50,800
entropy let's see some examples of

00:34:48,550 --> 00:34:53,430
leveraging couches to add our add to our

00:34:50,800 --> 00:34:53,430
example app

00:34:54,400 --> 00:35:08,470
so now that we've gone through the

00:34:59,600 --> 00:35:19,010
process of we want to be able to now add

00:35:08,470 --> 00:35:20,540
caching to our server so we're not going

00:35:19,010 --> 00:35:24,520
to change anything on the client side

00:35:20,540 --> 00:35:24,520
it's still responding to these events

00:35:26,200 --> 00:35:37,180
there she's so what I now want to do is

00:35:44,590 --> 00:35:53,150
so we had our inline handler for space

00:35:47,750 --> 00:35:56,450
find what I'm going to do is add an

00:35:53,150 --> 00:35:59,480
intercept handler for space find that's

00:35:56,450 --> 00:36:03,980
going to test to see if we're looking

00:35:59,480 --> 00:36:06,680
for a specific space and if not we

00:36:03,980 --> 00:36:11,930
return and then the in inline handler is

00:36:06,680 --> 00:36:14,960
going to be called its then I'm gonna if

00:36:11,930 --> 00:36:18,260
if we make it past there I'm gonna go to

00:36:14,960 --> 00:36:20,600
Redis and try to get that item if I

00:36:18,260 --> 00:36:24,440
didn't find it we missed on the cache

00:36:20,600 --> 00:36:27,800
log it and return it'll call the inline

00:36:24,440 --> 00:36:30,380
handler if we did we're gonna reset the

00:36:27,800 --> 00:36:34,550
contacts to enter Portal and that will

00:36:30,380 --> 00:36:38,710
prevent any downstream any downstream

00:36:34,550 --> 00:36:38,710
application context from occurring

00:36:43,360 --> 00:36:52,540
so that is a cash check now how do we

00:36:47,110 --> 00:36:58,810
implement how do we implement storing so

00:36:52,540 --> 00:37:02,410
because we're already in our save space

00:36:58,810 --> 00:37:04,960
handler we were we were returning the

00:37:02,410 --> 00:37:07,260
application context as space stored

00:37:04,960 --> 00:37:12,390
we're also broadcasting that on the

00:37:07,260 --> 00:37:20,460
server wide signal Network

00:37:12,390 --> 00:37:20,460
we'll simply add it at an async handler

00:37:20,520 --> 00:37:27,850
globally to anything that's stored and

00:37:23,740 --> 00:37:30,460
grab it and stick it in the cache now

00:37:27,850 --> 00:37:34,980
this was already working because I undid

00:37:30,460 --> 00:37:38,880
all the commenting but I'll go ahead and

00:37:34,980 --> 00:37:38,880
show you how that's working

00:37:45,559 --> 00:38:05,910
so if we have in Redis we've got our je

00:37:54,930 --> 00:38:11,069
s conf we go ahead and hit that and then

00:38:05,910 --> 00:38:17,819
we see in our logging cache hit that's

00:38:11,069 --> 00:38:24,260
what got returned back to the list this

00:38:17,819 --> 00:38:24,260
one due it'll be is not in our cache

00:38:29,420 --> 00:38:34,220
will go into that will see cache miss

00:38:36,500 --> 00:38:44,730
and by the way all the logging is simply

00:38:40,549 --> 00:38:47,369
adding a wild-card handler as an

00:38:44,730 --> 00:38:49,200
intercept that never returns anything so

00:38:47,369 --> 00:38:52,349
we never intercept we never block we

00:38:49,200 --> 00:39:02,520
just see it coming through and that

00:38:52,349 --> 00:39:04,890
happens here as well as in our client so

00:39:02,520 --> 00:39:13,109
this one was a cache miss but if we go

00:39:04,890 --> 00:39:16,039
ahead and edit it will now see that gets

00:39:13,109 --> 00:39:16,039
stored in our cache

00:39:20,790 --> 00:39:28,160
and the next time we go back to the list

00:39:24,710 --> 00:39:28,160
we'll have a cache hit

00:39:37,200 --> 00:39:45,210
they come close to at a time ah

00:39:46,780 --> 00:39:51,700
so with all this we get a lot of

00:39:49,540 --> 00:39:55,090
additional benefits we're building on an

00:39:51,700 --> 00:39:57,100
architecture designed to evolve by

00:39:55,090 --> 00:40:00,670
embracing the entropy inherent in our

00:39:57,100 --> 00:40:04,300
systems it's completely composable and

00:40:00,670 --> 00:40:06,340
decoupled from day zero you have the

00:40:04,300 --> 00:40:08,590
ability to use the best tool for the job

00:40:06,340 --> 00:40:13,600
so because everything is just a handler

00:40:08,590 --> 00:40:15,520
you can use whatever you want we get to

00:40:13,600 --> 00:40:18,130
build reactive applications that come

00:40:15,520 --> 00:40:21,670
with the common semantics across all of

00:40:18,130 --> 00:40:23,770
the execution stacks we get like I said

00:40:21,670 --> 00:40:26,560
aspect-oriented programming system-wide

00:40:23,770 --> 00:40:28,480
for free we're getting a stream of

00:40:26,560 --> 00:40:31,680
events with rich metadata that we can

00:40:28,480 --> 00:40:35,080
then use for reporting and tracking and

00:40:31,680 --> 00:40:39,190
by using this cow message concept these

00:40:35,080 --> 00:40:41,410
trigrams it provides a ubiquitous

00:40:39,190 --> 00:40:44,560
language like we talked about from

00:40:41,410 --> 00:40:47,770
domain-driven design that we get to use

00:40:44,560 --> 00:40:50,260
with our non-technical and our product

00:40:47,770 --> 00:40:52,690
members of our team and then this same

00:40:50,260 --> 00:40:57,370
language ends up translating directly

00:40:52,690 --> 00:41:01,000
into the into the code more things to

00:40:57,370 --> 00:41:03,810
come tools meta description files

00:41:01,000 --> 00:41:06,520
decorators testing and debugging tools

00:41:03,810 --> 00:41:08,860
at the moment it's a little verbose but

00:41:06,520 --> 00:41:12,360
by creating meta description files we

00:41:08,860 --> 00:41:15,340
can wire this stuff up on the side

00:41:12,360 --> 00:41:20,290
router for manipulating and reacting to

00:41:15,340 --> 00:41:23,140
URL paths middleware and adapters for

00:41:20,290 --> 00:41:27,040
different front-end components wrappers

00:41:23,140 --> 00:41:30,930
for the different fast providers and a

00:41:27,040 --> 00:41:33,580
towel mesh that would be able to conjoin

00:41:30,930 --> 00:41:35,590
signal networks to make that aspect

00:41:33,580 --> 00:41:37,440
seamless as well as implementations

00:41:35,590 --> 00:41:41,380
beyond JavaScript so you can have

00:41:37,440 --> 00:41:43,750
handlers implemented in any language

00:41:41,380 --> 00:41:48,600
that basically can support this simple

00:41:43,750 --> 00:41:52,950
paradigm what do I need from

00:41:48,600 --> 00:41:56,160
y'all please try it out this is brand

00:41:52,950 --> 00:41:58,620
new this is from a lot of years of me

00:41:56,160 --> 00:42:01,440
thinking about this problem and

00:41:58,620 --> 00:42:02,220
especially I want you to tell me what's

00:42:01,440 --> 00:42:04,680
wrong with it

00:42:02,220 --> 00:42:06,960
I do believe in this paradigm as a

00:42:04,680 --> 00:42:10,070
simplified way of building applications

00:42:06,960 --> 00:42:12,570
and using the strengths of our tools

00:42:10,070 --> 00:42:16,100
rather than fighting against them as

00:42:12,570 --> 00:42:19,590
we're dealing with various entropy

00:42:16,100 --> 00:42:21,240
there is no sponsor it's just me so if

00:42:19,590 --> 00:42:26,070
anybody wants to contribute it's all

00:42:21,240 --> 00:42:29,490
open source feel free to to share your

00:42:26,070 --> 00:42:32,160
feedback and and please come talk to be

00:42:29,490 --> 00:42:36,480
more if you're interested in working on

00:42:32,160 --> 00:42:39,420
a project that makes that makes it

00:42:36,480 --> 00:42:41,310
easier to build applications quickly

00:42:39,420 --> 00:42:43,920
where you're not having to worry about

00:42:41,310 --> 00:42:47,250
the underlying architecture which can

00:42:43,920 --> 00:42:49,110
evolve with you thank you very much I

00:42:47,250 --> 00:42:51,500
want to thank everybody at Jay's comp

00:42:49,110 --> 00:42:54,890
the hospitality here has been amazing

00:42:51,500 --> 00:43:01,730
and thank you all for attending

00:42:54,890 --> 00:43:01,730

YouTube URL: https://www.youtube.com/watch?v=XWHcKl1jEeE


