Title: Pattern Matching in JS - Juan Caicedo - JSConf US 2018
Publication date: 2018-11-11
Playlist: JSConf US 2018
Description: 
	
Captions: 
	00:00:00,320 --> 00:00:03,840
[Music]

00:00:02,070 --> 00:00:05,660
[Applause]

00:00:03,840 --> 00:00:07,410
[Music]

00:00:05,660 --> 00:00:09,280
[Applause]

00:00:07,410 --> 00:00:11,020
[Music]

00:00:09,280 --> 00:00:12,780
[Applause]

00:00:11,020 --> 00:00:15,920
[Music]

00:00:12,780 --> 00:00:15,920
[Applause]

00:00:16,870 --> 00:00:25,570
[Music]

00:00:23,439 --> 00:00:34,510
so without further ado I present to you

00:00:25,570 --> 00:00:36,910
one Chi Saito thank you I had to ask you

00:00:34,510 --> 00:00:40,809
yeah you told us about something really

00:00:36,910 --> 00:00:42,340
special about your your socks yeah so

00:00:40,809 --> 00:00:44,170
I'm actually wearing brand new ones I

00:00:42,340 --> 00:00:47,170
got those ones from the lorry yesterday

00:00:44,170 --> 00:00:48,640
these are new and PM socks I had an old

00:00:47,170 --> 00:00:54,540
pair of NPM socks and they're like

00:00:48,640 --> 00:00:57,489
getting a little old so thank you for

00:00:54,540 --> 00:00:59,530
another like quick clarifying thing I

00:00:57,489 --> 00:01:02,110
actually I'm mostly like deaf punks

00:00:59,530 --> 00:01:03,700
newest album but when I say that I like

00:01:02,110 --> 00:01:05,229
it I mean like I listened to it two

00:01:03,700 --> 00:01:08,799
times yesterday while I was working on

00:01:05,229 --> 00:01:10,930
my slides so I really really like it and

00:01:08,799 --> 00:01:14,799
thank you all for coming today

00:01:10,930 --> 00:01:17,740
and I it means a lot for me that you're

00:01:14,799 --> 00:01:22,659
here because my fellow web developers I

00:01:17,740 --> 00:01:25,180
am angry and I am angry because for

00:01:22,659 --> 00:01:28,869
years us JavaScript errs have been told

00:01:25,180 --> 00:01:32,140
to never ever ever ever use switch

00:01:28,869 --> 00:01:34,240
statements and you know I mean there's

00:01:32,140 --> 00:01:35,979
there's reasons all over for it and

00:01:34,240 --> 00:01:38,530
today I'd like to talk about some of

00:01:35,979 --> 00:01:41,680
those particularly I'd like to to recap

00:01:38,530 --> 00:01:44,650
a bit of that that awful tragedy tragedy

00:01:41,680 --> 00:01:46,750
and then talk about the the brave web

00:01:44,650 --> 00:01:49,299
developers who've come before us and the

00:01:46,750 --> 00:01:51,460
ways that they've come up with skirting

00:01:49,299 --> 00:01:54,340
around switch statements and then I'd

00:01:51,460 --> 00:01:57,159
like to introduce you to a tc39 proposal

00:01:54,340 --> 00:01:58,780
for a new incarnation of switch

00:01:57,159 --> 00:02:01,119
statements that would leverage pattern

00:01:58,780 --> 00:02:03,100
matching inside of JavaScript so with

00:02:01,119 --> 00:02:05,290
all that being said my name is Juan

00:02:03,100 --> 00:02:08,860
cocido I am a Canadian

00:02:05,290 --> 00:02:10,869
colombian-american developer and I am

00:02:08,860 --> 00:02:13,239
working for a company called testable

00:02:10,869 --> 00:02:15,069
which is a consulting company where we

00:02:13,239 --> 00:02:16,810
go to other people's teams and we help

00:02:15,069 --> 00:02:18,760
them write nice code and we try to be

00:02:16,810 --> 00:02:19,930
nice about writing code we try to help

00:02:18,760 --> 00:02:22,690
people be nice to each other about

00:02:19,930 --> 00:02:24,910
writing code I really like playing

00:02:22,690 --> 00:02:26,860
guitar and speaking foreign languages

00:02:24,910 --> 00:02:28,600
and traveling so if those are all things

00:02:26,860 --> 00:02:32,020
that urine to come chat with me about it

00:02:28,600 --> 00:02:34,780
sometime here is a picture of me then

00:02:32,020 --> 00:02:36,130
here's a picture of me as a child here's

00:02:34,780 --> 00:02:39,310
a picture of me with bleached blonde

00:02:36,130 --> 00:02:41,290
hair and here is a picture of me that my

00:02:39,310 --> 00:02:43,030
co-workers drew at our company retreat

00:02:41,290 --> 00:02:45,370
last week I'm not sure why so I'm

00:02:43,030 --> 00:02:48,880
wearing at Columbia soccer jersey I also

00:02:45,370 --> 00:02:52,030
have my guitar but I'm Abraham Lincoln

00:02:48,880 --> 00:02:52,900
which which makes sense right we're both

00:02:52,030 --> 00:02:55,560
seven feet tall

00:02:52,900 --> 00:02:58,240
we're very similar people all in all and

00:02:55,560 --> 00:03:01,420
so let's get back to switch statements

00:02:58,240 --> 00:03:04,780
so what is wrong with switch statements

00:03:01,420 --> 00:03:08,410
why shouldn't we use them well if you

00:03:04,780 --> 00:03:10,150
believe Google there's approximately 903

00:03:08,410 --> 00:03:12,880
million reasons why we shouldn't reuse

00:03:10,150 --> 00:03:16,840
them my personal favorite of them is

00:03:12,880 --> 00:03:19,150
that switch statements are evil so I'd

00:03:16,840 --> 00:03:21,340
honestly I'd heard this when I started

00:03:19,150 --> 00:03:23,110
programming that we should avoid switch

00:03:21,340 --> 00:03:25,210
statements in JavaScript and I didn't

00:03:23,110 --> 00:03:27,550
have a lot of reasons why until I

00:03:25,210 --> 00:03:29,370
started researching for this talk and

00:03:27,550 --> 00:03:33,160
really putting this together and

00:03:29,370 --> 00:03:36,910
morality of switch statements aside the

00:03:33,160 --> 00:03:39,160
main reasons I could find were two the

00:03:36,910 --> 00:03:41,200
first revolve so here's just a basic

00:03:39,160 --> 00:03:43,510
switch statement it's a function that

00:03:41,200 --> 00:03:45,880
takes in a number and then it switches

00:03:43,510 --> 00:03:48,640
over that number and just has three

00:03:45,880 --> 00:03:52,450
cases for the possible values of it each

00:03:48,640 --> 00:03:54,370
one logs out the word of that number

00:03:52,450 --> 00:03:56,620
you've passed in if none of them match

00:03:54,370 --> 00:03:59,350
we hit a default statement so the main

00:03:56,620 --> 00:04:00,790
reason domain of two reasons I could

00:03:59,350 --> 00:04:03,160
find for where people say not to use

00:04:00,790 --> 00:04:07,120
switch statements one is about their

00:04:03,160 --> 00:04:10,780
syntax so in JavaScript almost all types

00:04:07,120 --> 00:04:13,180
of control flow we do has braces curly

00:04:10,780 --> 00:04:14,650
braces for matching them case is one of

00:04:13,180 --> 00:04:16,660
the very few things that users colons

00:04:14,650 --> 00:04:19,390
and because of that people get really

00:04:16,660 --> 00:04:22,060
upset so not good in case you're ever

00:04:19,390 --> 00:04:24,910
designing a language avoid colons the

00:04:22,060 --> 00:04:26,860
other one that I could find is one that

00:04:24,910 --> 00:04:28,750
I find a lot more of an actual complaint

00:04:26,860 --> 00:04:31,750
which is that case statements have kind

00:04:28,750 --> 00:04:34,600
of tricky semantics so in the side of a

00:04:31,750 --> 00:04:36,190
case after you've matched you have to be

00:04:34,600 --> 00:04:38,889
sure to explicitly

00:04:36,190 --> 00:04:41,639
break out of that case

00:04:38,889 --> 00:04:44,050
so for example in this example if you

00:04:41,639 --> 00:04:46,300
say you have the number 1 we're gonna

00:04:44,050 --> 00:04:47,830
hit the console dot log for 1 and then

00:04:46,300 --> 00:04:51,159
we're gonna break out of it so that's

00:04:47,830 --> 00:04:54,999
good however if we don't do that and we

00:04:51,159 --> 00:04:57,550
do the 2 or the 3 so what's gonna happen

00:04:54,999 --> 00:04:59,589
here is that when we enter the case

00:04:57,550 --> 00:05:02,949
statement for the two we're gonna log

00:04:59,589 --> 00:05:05,319
out 2 however then executions gonna

00:05:02,949 --> 00:05:07,989
continue and it's also gonna log out the

00:05:05,319 --> 00:05:10,289
value for 3 and the value for default

00:05:07,989 --> 00:05:12,610
because since none of those have told

00:05:10,289 --> 00:05:14,289
JavaScript exit out of the switch

00:05:12,610 --> 00:05:18,509
statement it's is gonna match all those

00:05:14,289 --> 00:05:21,129
cases even though the number isn't 3 and

00:05:18,509 --> 00:05:22,809
it's already been matched so this is

00:05:21,129 --> 00:05:24,610
something that I think definitely could

00:05:22,809 --> 00:05:26,889
lead to some unexpected bugs and is is

00:05:24,610 --> 00:05:32,379
worth avoiding switch at least to avoid

00:05:26,889 --> 00:05:34,329
these type of headaches so how do people

00:05:32,379 --> 00:05:36,939
manage to avoid switch statements what

00:05:34,329 --> 00:05:39,629
else do we use so I found two main

00:05:36,939 --> 00:05:42,669
techniques the first is to use nested

00:05:39,629 --> 00:05:44,889
ternary statements so ternary statements

00:05:42,669 --> 00:05:47,259
are if-else there this question mark

00:05:44,889 --> 00:05:49,269
colon operator so what that does is that

00:05:47,259 --> 00:05:50,829
at first evaluates the condition on the

00:05:49,269 --> 00:05:54,159
left so we would evaluate whether the

00:05:50,829 --> 00:05:56,800
number is equal to one and then if that

00:05:54,159 --> 00:05:59,529
evaluates to true we execute the second

00:05:56,800 --> 00:06:01,929
statement however if it evaluates to

00:05:59,529 --> 00:06:05,259
false then we would evaluate the

00:06:01,929 --> 00:06:07,269
statement after the colon so what this

00:06:05,259 --> 00:06:08,889
technique does is it just does a chain

00:06:07,269 --> 00:06:10,449
of them so that if the first condition

00:06:08,889 --> 00:06:12,339
doesn't match then you evaluate the

00:06:10,449 --> 00:06:14,229
second dition if that doesn't match you

00:06:12,339 --> 00:06:18,399
evaluate the third condition and it

00:06:14,229 --> 00:06:20,649
works and my main issue with it is that

00:06:18,399 --> 00:06:23,289
I think that it looks ok when you put it

00:06:20,649 --> 00:06:25,149
like this but it's relying on some code

00:06:23,289 --> 00:06:27,309
style that isn't very normal in

00:06:25,149 --> 00:06:28,989
JavaScript and JavaScript this just

00:06:27,309 --> 00:06:30,699
isn't how we would indent things so I

00:06:28,989 --> 00:06:32,919
took this function and I ran it through

00:06:30,699 --> 00:06:34,539
prettier which I think for most of us is

00:06:32,919 --> 00:06:36,639
kind of like the industry standard on

00:06:34,539 --> 00:06:39,849
how to format code nowadays and it comes

00:06:36,639 --> 00:06:41,860
out of something more like this and here

00:06:39,849 --> 00:06:43,269
you can really see that like it's not as

00:06:41,860 --> 00:06:45,909
straightforward of a statement as we

00:06:43,269 --> 00:06:48,039
were looking at it before this also to

00:06:45,909 --> 00:06:50,619
me highlights one other thing that I'm

00:06:48,039 --> 00:06:51,760
no performance expert but I have the

00:06:50,619 --> 00:06:55,420
feeling that this is

00:06:51,760 --> 00:06:57,580
very performant code because to hit the

00:06:55,420 --> 00:06:59,290
default statement you would actually end

00:06:57,580 --> 00:07:01,390
up going through and have one by one

00:06:59,290 --> 00:07:04,480
evaluating all of the statements above

00:07:01,390 --> 00:07:07,600
it so this type of deep nesting is not

00:07:04,480 --> 00:07:09,520
something that won me over so the next

00:07:07,600 --> 00:07:12,490
approach that I found is one that I'm

00:07:09,520 --> 00:07:14,920
more of a fan of so this is to use an

00:07:12,490 --> 00:07:17,950
object literal which is very common in

00:07:14,920 --> 00:07:20,650
JavaScript and idiomatic and use that to

00:07:17,950 --> 00:07:22,630
control all of our cases so we would

00:07:20,650 --> 00:07:24,760
have an object here I called it the

00:07:22,630 --> 00:07:27,190
values object and you would have a key

00:07:24,760 --> 00:07:30,460
on that for all over the different cases

00:07:27,190 --> 00:07:31,900
that we could match and then the value

00:07:30,460 --> 00:07:33,820
from that is what we would want to

00:07:31,900 --> 00:07:35,470
return so then at the bottom what we

00:07:33,820 --> 00:07:37,870
would do is just take the type that

00:07:35,470 --> 00:07:40,450
we've passed in and then we would pull

00:07:37,870 --> 00:07:42,220
out a value from this object that we've

00:07:40,450 --> 00:07:45,490
defined before and then we'll return

00:07:42,220 --> 00:07:47,200
that if we've passed in a type that

00:07:45,490 --> 00:07:49,450
isn't one of the cases that were set up

00:07:47,200 --> 00:07:51,550
to handle then we're gonna get an

00:07:49,450 --> 00:07:54,460
undefined value back from that object

00:07:51,550 --> 00:07:58,210
which is false II so then what we can do

00:07:54,460 --> 00:08:01,030
is go ahead and get the default value

00:07:58,210 --> 00:08:03,520
and return that instead so this works I

00:08:01,030 --> 00:08:05,770
have a little bit of a gripe with the

00:08:03,520 --> 00:08:08,350
fact that we have to explicitly call a

00:08:05,770 --> 00:08:09,820
default statement to me it seems a

00:08:08,350 --> 00:08:12,550
little weird but maybe I'm just

00:08:09,820 --> 00:08:14,890
nitpicking here I think a concern that

00:08:12,550 --> 00:08:19,000
is much more valid is that any of the

00:08:14,890 --> 00:08:21,550
cases have a false e value so false null

00:08:19,000 --> 00:08:23,770
undefined then when you pull them out of

00:08:21,550 --> 00:08:26,290
the object and Brun them through this or

00:08:23,770 --> 00:08:28,180
check for the default value they would

00:08:26,290 --> 00:08:30,760
evaluate to false so then we would

00:08:28,180 --> 00:08:32,320
return the default and you're all

00:08:30,760 --> 00:08:35,500
probably smarter than me but I would hit

00:08:32,320 --> 00:08:39,250
a bug here for sure so I'm not not a

00:08:35,500 --> 00:08:42,729
hundred percent on this approach ya

00:08:39,250 --> 00:08:44,830
value false e not good so then we would

00:08:42,729 --> 00:08:47,020
hit this default statement so then let's

00:08:44,830 --> 00:08:49,270
look at another example so this is where

00:08:47,020 --> 00:08:52,120
I think switch statements are most used

00:08:49,270 --> 00:08:55,450
in JavaScript today which is inside of

00:08:52,120 --> 00:08:58,810
Redux reducers so inside of this simple

00:08:55,450 --> 00:09:01,750
example sorry to back up if any of you

00:08:58,810 --> 00:09:03,970
haven't used redux in redux a common

00:09:01,750 --> 00:09:05,649
pattern like how Redux reducers work is

00:09:03,970 --> 00:09:08,319
that it's a function that take

00:09:05,649 --> 00:09:10,660
State and it takes some instructions

00:09:08,319 --> 00:09:13,899
about how to update that state and then

00:09:10,660 --> 00:09:15,730
the function is in charge of calculating

00:09:13,899 --> 00:09:17,680
all of the pauses like the updates to

00:09:15,730 --> 00:09:20,800
that state and returning back a new

00:09:17,680 --> 00:09:22,329
state so here we have a counter you know

00:09:20,800 --> 00:09:24,519
the counter would be a number and then

00:09:22,329 --> 00:09:27,160
we can either increment that decrement

00:09:24,519 --> 00:09:29,889
that or reset it so what we would do is

00:09:27,160 --> 00:09:32,439
that in redux you have an action and an

00:09:29,889 --> 00:09:35,050
action has a type which tells you how to

00:09:32,439 --> 00:09:36,850
go through this update statement so if

00:09:35,050 --> 00:09:38,769
that type is increment we would push up

00:09:36,850 --> 00:09:41,110
our state if it's d comment will push it

00:09:38,769 --> 00:09:43,360
down if it's reset we would return 0 and

00:09:41,110 --> 00:09:44,949
then if for some reason it's not any of

00:09:43,360 --> 00:09:47,769
those predetermined ones we want to just

00:09:44,949 --> 00:09:53,709
keep the state the way it is so there's

00:09:47,769 --> 00:09:55,059
a there's a tricky thing here which well

00:09:53,709 --> 00:09:56,230
so let's take the switch statement and

00:09:55,059 --> 00:09:57,579
first let's switch it over to this

00:09:56,230 --> 00:10:00,040
object approach that we were discussing

00:09:57,579 --> 00:10:01,179
before so if we were to do that what we

00:10:00,040 --> 00:10:03,129
would do is cut out that switch

00:10:01,179 --> 00:10:06,069
statement have an object that's all of

00:10:03,129 --> 00:10:07,720
the different cases so it has a key for

00:10:06,069 --> 00:10:09,459
all of the different types of actions

00:10:07,720 --> 00:10:12,220
and then on the right hand it has the

00:10:09,459 --> 00:10:13,420
how we want to update the state then at

00:10:12,220 --> 00:10:14,800
the bottom we would go ahead and pull

00:10:13,420 --> 00:10:19,240
out that case or we would return the

00:10:14,800 --> 00:10:22,720
default so here we run into concern

00:10:19,240 --> 00:10:25,389
which is to illustrate it a little more

00:10:22,720 --> 00:10:28,389
let's think about what if we could

00:10:25,389 --> 00:10:30,610
change instead of always updating or

00:10:28,389 --> 00:10:33,519
decrementing by one what if we can make

00:10:30,610 --> 00:10:35,050
that an arbitrary amount so now the

00:10:33,519 --> 00:10:37,149
amount that we're gonna increment or

00:10:35,050 --> 00:10:40,809
decrement by is also going to flow in

00:10:37,149 --> 00:10:43,300
with this action so here at the very top

00:10:40,809 --> 00:10:44,649
we have just a little bit of

00:10:43,300 --> 00:10:46,179
destructuring if it's not something

00:10:44,649 --> 00:10:48,189
you're familiar with we'll talk about it

00:10:46,179 --> 00:10:49,779
a little later so we're gonna reach into

00:10:48,189 --> 00:10:51,699
that action and we're gonna pull out the

00:10:49,779 --> 00:10:53,589
type of the action we're also going to

00:10:51,699 --> 00:10:55,470
pull out the data of the action and as

00:10:53,589 --> 00:10:58,179
we do that we'll rename it to the amount

00:10:55,470 --> 00:11:00,220
then inside of our case is what we want

00:10:58,179 --> 00:11:03,369
to do is increment state by the amount

00:11:00,220 --> 00:11:06,369
and decrement state by amount so here we

00:11:03,369 --> 00:11:10,029
run into a bug and the bug is that if

00:11:06,369 --> 00:11:11,920
we're in the case of reset all we want

00:11:10,029 --> 00:11:13,119
to do is reset the state to zero so

00:11:11,920 --> 00:11:16,029
we're not incrementing or decrementing

00:11:13,119 --> 00:11:19,360
by any amount so it would make perfect

00:11:16,029 --> 00:11:22,779
sense for amount to be undefined how

00:11:19,360 --> 00:11:24,250
as soon as we hit this skate statement

00:11:22,779 --> 00:11:26,800
definition as soon as we call this

00:11:24,250 --> 00:11:30,310
function we're eagerly gonna evaluate

00:11:26,800 --> 00:11:31,660
what state plus amount means and that

00:11:30,310 --> 00:11:34,209
means that we're either gonna get state

00:11:31,660 --> 00:11:36,790
plus undefined state plus null state -

00:11:34,209 --> 00:11:38,050
no this is bad i I didn't run this to be

00:11:36,790 --> 00:11:40,890
sure but I'm pretty sure this would

00:11:38,050 --> 00:11:44,589
result in your program just blowing up

00:11:40,890 --> 00:11:47,350
so the way to avoid this is that instead

00:11:44,589 --> 00:11:50,410
of just having cases the return of value

00:11:47,350 --> 00:11:53,110
we would instead make the cases return a

00:11:50,410 --> 00:11:55,899
function so that when you evaluate the

00:11:53,110 --> 00:11:57,519
function at that point we do that math

00:11:55,899 --> 00:12:00,279
and this would make sure that when you

00:11:57,519 --> 00:12:02,740
hit the reset case it hasn't evaluated

00:12:00,279 --> 00:12:06,100
the other two cases and it would avoid

00:12:02,740 --> 00:12:08,170
this bug so this means that you know at

00:12:06,100 --> 00:12:11,350
the bottom now we're gonna be having to

00:12:08,170 --> 00:12:13,180
call will pull out our case from the

00:12:11,350 --> 00:12:15,010
object and then we'll have to evaluate

00:12:13,180 --> 00:12:18,370
it and we'll do that again for the

00:12:15,010 --> 00:12:20,620
default case and this isn't I mean it's

00:12:18,370 --> 00:12:22,810
not terrible it just seems to me like a

00:12:20,620 --> 00:12:25,600
lot of ceremony for something that a

00:12:22,810 --> 00:12:28,540
language could and should be able to

00:12:25,600 --> 00:12:30,610
handle for you and a lot of languages do

00:12:28,540 --> 00:12:32,470
so let's backtrack now and talk about a

00:12:30,610 --> 00:12:35,199
couple other ones so here's for example

00:12:32,470 --> 00:12:37,510
elm Elm is a language that embraces

00:12:35,199 --> 00:12:39,519
switch statements a lot in fact so much

00:12:37,510 --> 00:12:42,250
so that in Elm it's considered a code

00:12:39,519 --> 00:12:45,220
smell to use an if statement or any

00:12:42,250 --> 00:12:49,779
other type of evaluation if a case would

00:12:45,220 --> 00:12:53,620
do so here in Elm and an action is a

00:12:49,779 --> 00:12:55,990
data type and the data type would be one

00:12:53,620 --> 00:12:59,199
of a bunch of different cases then when

00:12:55,990 --> 00:13:01,690
a case could involve with it some data

00:12:59,199 --> 00:13:03,820
attached to it so here when we're in the

00:13:01,690 --> 00:13:05,980
increment case will automatically get

00:13:03,820 --> 00:13:08,010
another bit of data with it which is the

00:13:05,980 --> 00:13:10,600
amount and when we hit the reset case

00:13:08,010 --> 00:13:13,709
reset has no amount so it just wouldn't

00:13:10,600 --> 00:13:16,899
be a part of that data type at all in

00:13:13,709 --> 00:13:19,060
rust there's something very similar so

00:13:16,899 --> 00:13:21,610
we would have an action which is a

00:13:19,060 --> 00:13:23,320
struct which has two different type in

00:13:21,610 --> 00:13:25,149
an amount to find on it and then we

00:13:23,320 --> 00:13:27,220
would have a function that matches over

00:13:25,149 --> 00:13:29,649
that type and then lets you do different

00:13:27,220 --> 00:13:31,480
stuff based on it if you actually know

00:13:29,649 --> 00:13:33,250
any rust don't look at this too closely

00:13:31,480 --> 00:13:36,460
because I don't and I have a

00:13:33,250 --> 00:13:37,660
this actually doesn't compile and then

00:13:36,460 --> 00:13:40,030
the one that we're gonna focus on the

00:13:37,660 --> 00:13:42,280
most is elixir the reason why we're

00:13:40,030 --> 00:13:44,380
gonna do that is because elixir has the

00:13:42,280 --> 00:13:47,140
closest semantics out of these languages

00:13:44,380 --> 00:13:49,270
to JavaScript so in elixir we would

00:13:47,140 --> 00:13:51,370
define a function the function would

00:13:49,270 --> 00:13:54,270
take a state and in action we would case

00:13:51,370 --> 00:13:56,830
over that action and then if it matched

00:13:54,270 --> 00:14:00,550
whether we wanted to increment decrement

00:13:56,830 --> 00:14:02,230
or reset we would do we would take the

00:14:00,550 --> 00:14:06,850
amount calculate a new state based off

00:14:02,230 --> 00:14:09,040
of it and this leaves us with a question

00:14:06,850 --> 00:14:12,790
of if all these other languages have a

00:14:09,040 --> 00:14:14,830
way of doing robust handling of cases

00:14:12,790 --> 00:14:18,670
why can't we have something like that in

00:14:14,830 --> 00:14:20,140
JavaScript so at this point actually

00:14:18,670 --> 00:14:21,940
want to take a quick intermission to

00:14:20,140 --> 00:14:24,640
show off my water bottle for all of you

00:14:21,940 --> 00:14:26,020
cuz I'm super proud of my water bottle

00:14:24,640 --> 00:14:28,090
we were talking about it backstage

00:14:26,020 --> 00:14:29,290
actually I have all of these stickers

00:14:28,090 --> 00:14:31,930
from different conferences that I've

00:14:29,290 --> 00:14:33,880
gone to and some of them like this one

00:14:31,930 --> 00:14:36,850
for example is the the most famous

00:14:33,880 --> 00:14:39,100
soccer player in Colombian history but

00:14:36,850 --> 00:14:41,860
it's actually the MPM wombat dressed up

00:14:39,100 --> 00:14:43,510
as him so this is fantastic and if I

00:14:41,860 --> 00:14:45,430
were to lose this water bottle I'm

00:14:43,510 --> 00:14:48,100
really confident that I'd never be able

00:14:45,430 --> 00:14:49,270
to get this sticker again so if you have

00:14:48,100 --> 00:14:50,650
a lot of stickers and don't know what to

00:14:49,270 --> 00:14:52,510
do with them I really encourage you to

00:14:50,650 --> 00:14:54,130
find other things that aren't your

00:14:52,510 --> 00:14:55,780
laptop to put them on because I'm a

00:14:54,130 --> 00:14:57,700
little too anxious to put them on my

00:14:55,780 --> 00:15:00,790
laptop but my water bottle is now my

00:14:57,700 --> 00:15:02,260
favourite object so with that little

00:15:00,790 --> 00:15:03,520
intermission to kind of give you all a

00:15:02,260 --> 00:15:05,530
breath of fresh air let's talk about

00:15:03,520 --> 00:15:08,980
JavaScript so why can't we have this in

00:15:05,530 --> 00:15:10,720
JavaScript because we can actually so

00:15:08,980 --> 00:15:13,120
there's right now a proposal in front of

00:15:10,720 --> 00:15:15,370
tc39 that's reached stage 1 for

00:15:13,120 --> 00:15:18,190
introducing pattern matching into

00:15:15,370 --> 00:15:19,740
JavaScript so what pattern matching

00:15:18,190 --> 00:15:23,050
would be doing is it would be taking

00:15:19,740 --> 00:15:25,180
semantic close to what we have for for

00:15:23,050 --> 00:15:27,010
switch statements now but then it would

00:15:25,180 --> 00:15:29,050
be taking all of the semantics of

00:15:27,010 --> 00:15:32,860
destructuring and it would be filling

00:15:29,050 --> 00:15:34,839
them into that language feature so let's

00:15:32,860 --> 00:15:36,040
take a step back and let's talk about

00:15:34,839 --> 00:15:38,920
what I just mentioned about

00:15:36,040 --> 00:15:40,210
destructuring so destructuring is a

00:15:38,920 --> 00:15:42,430
feature you can use whenever you're

00:15:40,210 --> 00:15:44,770
defining variables with like const or

00:15:42,430 --> 00:15:47,139
virus and what it allows you to do is

00:15:44,770 --> 00:15:49,600
that it allows you to not just define

00:15:47,139 --> 00:15:51,339
a simple variable by variable on the

00:15:49,600 --> 00:15:53,889
left value on the right but to actually

00:15:51,339 --> 00:15:56,259
do some logic as you do that so in this

00:15:53,889 --> 00:15:58,449
simple case on the right hand side we

00:15:56,259 --> 00:16:01,749
have an object and the object has an X

00:15:58,449 --> 00:16:04,209
property and a Y property then when we

00:16:01,749 --> 00:16:06,160
create a variable we can use the curly

00:16:04,209 --> 00:16:08,889
brace object syntax on the left hand

00:16:06,160 --> 00:16:11,079
side and what we can tell it is go ahead

00:16:08,889 --> 00:16:13,419
and make two new variables for me x and

00:16:11,079 --> 00:16:16,389
y and make the value of each of them

00:16:13,419 --> 00:16:18,999
equal to the value of that property and

00:16:16,389 --> 00:16:21,819
the object on the right this is really

00:16:18,999 --> 00:16:24,459
cool because it's so if we were to do

00:16:21,819 --> 00:16:26,169
this we would get like we would just

00:16:24,459 --> 00:16:27,999
have like a easier way to pull things

00:16:26,169 --> 00:16:29,439
out of objects we can also do other

00:16:27,999 --> 00:16:31,480
things on top of it like we can do

00:16:29,439 --> 00:16:33,869
default values so here what we're doing

00:16:31,480 --> 00:16:36,549
is that when we define these variables

00:16:33,869 --> 00:16:39,009
we can give them default values so we

00:16:36,549 --> 00:16:40,359
can say that the default value for X if

00:16:39,009 --> 00:16:42,910
we don't find it on the right-hand side

00:16:40,359 --> 00:16:45,730
will be the poop emoji and the value for

00:16:42,910 --> 00:16:47,649
Y will be the ghost emoji so the the

00:16:45,730 --> 00:16:50,199
results of this is interesting so the

00:16:47,649 --> 00:16:52,989
object on the right does have both of

00:16:50,199 --> 00:16:57,279
these properties but for the first one

00:16:52,989 --> 00:16:59,169
the value of x is undefined so to back

00:16:57,279 --> 00:17:00,970
up if we were to ask for a variable that

00:16:59,169 --> 00:17:04,209
isn't in that object at all let's say if

00:17:00,970 --> 00:17:06,159
we were asked for a Z then Z pulled out

00:17:04,209 --> 00:17:08,559
of that object would be undefined so we

00:17:06,159 --> 00:17:10,480
would get it's a default value with X

00:17:08,559 --> 00:17:12,039
even though the X property does exist

00:17:10,480 --> 00:17:14,769
because its values undefined

00:17:12,039 --> 00:17:17,559
we'll also get the default value however

00:17:14,769 --> 00:17:20,230
this isn't the case for Y because Y has

00:17:17,559 --> 00:17:23,230
a value of null we will actually get

00:17:20,230 --> 00:17:24,789
that value out of the destructuring but

00:17:23,230 --> 00:17:27,840
I'm gonna convince you that this is

00:17:24,789 --> 00:17:30,100
actually a good thing it's not a problem

00:17:27,840 --> 00:17:31,809
other things that you can do with the

00:17:30,100 --> 00:17:33,880
structuring it's not just for objects

00:17:31,809 --> 00:17:36,519
you can do it with arrays so what we can

00:17:33,880 --> 00:17:39,340
do is we can go ahead and define x and y

00:17:36,519 --> 00:17:41,470
to the first and second values of an

00:17:39,340 --> 00:17:43,929
array just by applying the same array

00:17:41,470 --> 00:17:46,690
syntax on the left this is really cool

00:17:43,929 --> 00:17:49,510
it allows you a way of doing much easier

00:17:46,690 --> 00:17:52,360
variable assignment it also allows you

00:17:49,510 --> 00:17:54,309
to ignore parts of an array as you're

00:17:52,360 --> 00:17:56,260
pulling stuff out so let's say that we

00:17:54,309 --> 00:17:58,450
only care about the second value we

00:17:56,260 --> 00:18:00,549
don't care about the first all we can do

00:17:58,450 --> 00:18:00,850
is leave in the assignment will leave

00:18:00,549 --> 00:18:03,010
the

00:18:00,850 --> 00:18:05,530
first slot open and then have the second

00:18:03,010 --> 00:18:07,720
slot then we're never gonna pull

00:18:05,530 --> 00:18:09,190
anything out for that GS comp string

00:18:07,720 --> 00:18:12,820
instead we're only gonna pull out the

00:18:09,190 --> 00:18:14,890
second value into the Y this also allows

00:18:12,820 --> 00:18:18,310
you to do really cool things like to

00:18:14,890 --> 00:18:20,110
leverage rest argument or sprit sorry I

00:18:18,310 --> 00:18:22,120
get confused of this so spread is when

00:18:20,110 --> 00:18:23,860
your you have an arranger spreading it

00:18:22,120 --> 00:18:26,050
apart here what we're doing is rest

00:18:23,860 --> 00:18:28,510
arguments so let's say that we have an

00:18:26,050 --> 00:18:30,250
array with four things in it we're gonna

00:18:28,510 --> 00:18:32,830
take the first out of it and put it into

00:18:30,250 --> 00:18:34,840
a variable X but then this triple dot

00:18:32,830 --> 00:18:36,970
syntax what it's gonna do is it's gonna

00:18:34,840 --> 00:18:38,710
take all the rest of the contents of

00:18:36,970 --> 00:18:41,020
that array and it's gonna put them

00:18:38,710 --> 00:18:43,570
together into the variable rest so now

00:18:41,020 --> 00:18:45,340
we have one variable of the first and

00:18:43,570 --> 00:18:49,180
another variable which is the entire

00:18:45,340 --> 00:18:51,790
tail this is really cool and so having

00:18:49,180 --> 00:18:53,650
covered all of that 4d structuring let's

00:18:51,790 --> 00:18:58,590
talk about how this would fit into the

00:18:53,650 --> 00:19:01,750
pattern matching proposal so here is the

00:18:58,590 --> 00:19:03,850
update state or the update counter that

00:19:01,750 --> 00:19:06,130
we discussed earlier with Redux handlers

00:19:03,850 --> 00:19:08,800
and how we would do this if we had

00:19:06,130 --> 00:19:11,080
pattern matching available so we will do

00:19:08,800 --> 00:19:13,930
a case statement and the case statement

00:19:11,080 --> 00:19:16,630
will switch over the type of the action

00:19:13,930 --> 00:19:21,220
then the proposed semantics right now

00:19:16,630 --> 00:19:23,500
have this new keyword when and with when

00:19:21,220 --> 00:19:25,900
you would put the value that you want to

00:19:23,500 --> 00:19:28,210
match against next to it and then an

00:19:25,900 --> 00:19:30,220
arrow and afterwards whatever you want

00:19:28,210 --> 00:19:33,220
to do so here would be saying that if

00:19:30,220 --> 00:19:35,470
the type of action directly matches the

00:19:33,220 --> 00:19:38,740
string increment then we can go ahead

00:19:35,470 --> 00:19:41,650
and evaluate the state with +1 so this

00:19:38,740 --> 00:19:44,290
is this is cool however that's not where

00:19:41,650 --> 00:19:46,570
we stopped so because we can use all of

00:19:44,290 --> 00:19:48,520
this destructuring semantics we can go

00:19:46,570 --> 00:19:51,700
ahead and just case over the entire

00:19:48,520 --> 00:19:55,030
action when we case over the action we

00:19:51,700 --> 00:19:57,460
can on the right hand of then do a D

00:19:55,030 --> 00:20:01,570
structuring so we can say that if the

00:19:57,460 --> 00:20:03,670
action has a type property and that type

00:20:01,570 --> 00:20:06,790
property matches the string increment

00:20:03,670 --> 00:20:09,880
then what we want to do is pull out the

00:20:06,790 --> 00:20:12,490
property data but rename that to amount

00:20:09,880 --> 00:20:14,740
and now the variables that we've decided

00:20:12,490 --> 00:20:18,070
to find inside of that destructor

00:20:14,740 --> 00:20:19,720
are available to the other side of that

00:20:18,070 --> 00:20:21,880
arrow so we can just go ahead and say

00:20:19,720 --> 00:20:24,159
state plus amount which we've received

00:20:21,880 --> 00:20:25,899
from that destructuring this is really

00:20:24,159 --> 00:20:28,000
cool and we can do it with a raise as

00:20:25,899 --> 00:20:30,610
well so another way to do this would be

00:20:28,000 --> 00:20:33,490
that we could do a case statement over a

00:20:30,610 --> 00:20:35,500
new array and the array could have the

00:20:33,490 --> 00:20:38,049
type of the action and the data of the

00:20:35,500 --> 00:20:40,809
action and then all we would do is we

00:20:38,049 --> 00:20:43,240
would match against the first value

00:20:40,809 --> 00:20:44,919
being increment and then we would just

00:20:43,240 --> 00:20:47,049
put the second value into a variable

00:20:44,919 --> 00:20:49,870
amount we could do that the same with

00:20:47,049 --> 00:20:52,330
decrement and this is okay another one

00:20:49,870 --> 00:20:54,460
that I skipped over before but when we

00:20:52,330 --> 00:20:56,620
get to the bottom we're doing variable

00:20:54,460 --> 00:20:59,980
assignment so any variable that we put

00:20:56,620 --> 00:21:02,320
here will get assigned into there so the

00:20:59,980 --> 00:21:05,289
effect of this of this when underscore

00:21:02,320 --> 00:21:07,450
is the same effect as a default case so

00:21:05,289 --> 00:21:08,890
what we'll do is we'll say if we get to

00:21:07,450 --> 00:21:10,360
this point in the function and we

00:21:08,890 --> 00:21:13,570
haven't matched any previous case

00:21:10,360 --> 00:21:15,010
whatever we've put in the case we'll

00:21:13,570 --> 00:21:17,200
just instead be a sign into this

00:21:15,010 --> 00:21:19,299
variable and we'll match this instead so

00:21:17,200 --> 00:21:22,000
this is a really cool really easy way to

00:21:19,299 --> 00:21:25,149
do default arguments or to do default

00:21:22,000 --> 00:21:27,309
cases other places where this could

00:21:25,149 --> 00:21:30,039
apply could be in nodejs

00:21:27,309 --> 00:21:33,669
so in node a really common thing is to

00:21:30,039 --> 00:21:36,909
have air backs or error first call backs

00:21:33,669 --> 00:21:38,679
so here we could be reading a file we

00:21:36,909 --> 00:21:40,450
passed the first argument is the name of

00:21:38,679 --> 00:21:42,669
the file the second is the encoding we

00:21:40,450 --> 00:21:44,559
want to read out of and then inside of

00:21:42,669 --> 00:21:46,690
our callback we could do a case

00:21:44,559 --> 00:21:50,049
statement over the error that we could

00:21:46,690 --> 00:21:52,390
possibly get back and the contents so

00:21:50,049 --> 00:21:55,179
here the first step that we would do is

00:21:52,390 --> 00:21:57,820
we could say if the error is explicitly

00:21:55,179 --> 00:22:00,250
null which is idiomatically where you'll

00:21:57,820 --> 00:22:02,110
always get back a node then we can go

00:22:00,250 --> 00:22:03,429
ahead and match this case because we

00:22:02,110 --> 00:22:05,080
know that the error is null and

00:22:03,429 --> 00:22:08,140
therefore we have some data we can do

00:22:05,080 --> 00:22:09,520
stuff with it then in the next statement

00:22:08,140 --> 00:22:12,130
we could do is alright if the error

00:22:09,520 --> 00:22:13,659
isn't null and we have an error let's go

00:22:12,130 --> 00:22:15,100
ahead and pull that out and then we'll

00:22:13,659 --> 00:22:16,899
do some error handling something went

00:22:15,100 --> 00:22:19,000
wrong and then we could have another

00:22:16,899 --> 00:22:21,730
statement after that saying for some

00:22:19,000 --> 00:22:24,580
reason the error isn't no but it's also

00:22:21,730 --> 00:22:26,320
not true T value so something went wrong

00:22:24,580 --> 00:22:28,540
here I think that case would actually be

00:22:26,320 --> 00:22:31,330
impossible and node unless someone it

00:22:28,540 --> 00:22:34,170
explicitly returned false to you I guess

00:22:31,330 --> 00:22:36,340
is the only way that it would happen but

00:22:34,170 --> 00:22:39,100
yeah it's cool that basically we could

00:22:36,340 --> 00:22:41,290
take apart which is very idiomatic and

00:22:39,100 --> 00:22:45,520
node and done everywhere but handle it

00:22:41,290 --> 00:22:47,350
in in a really nice concise new way this

00:22:45,520 --> 00:22:49,240
could also be used in JSX was actually

00:22:47,350 --> 00:22:50,470
one of the motivating examples I don't

00:22:49,240 --> 00:22:53,560
know how many of you have tried to in

00:22:50,470 --> 00:22:55,720
JSX do any type of conditionals but you

00:22:53,560 --> 00:22:59,500
have to do you have to return something

00:22:55,720 --> 00:23:02,140
and usually you do a condition and and

00:22:59,500 --> 00:23:03,790
the value that you want to return and if

00:23:02,140 --> 00:23:06,400
you want to do turn Aries then you have

00:23:03,790 --> 00:23:08,470
to do the condition question mark and do

00:23:06,400 --> 00:23:10,180
a few of them if you have multiple cases

00:23:08,470 --> 00:23:12,490
there's no nice way to do that you have

00:23:10,180 --> 00:23:13,780
to do the nested turn Aries so here what

00:23:12,490 --> 00:23:15,760
it would look like is that we could have

00:23:13,780 --> 00:23:18,010
a component and let's say that the

00:23:15,760 --> 00:23:20,320
component inside of its props could

00:23:18,010 --> 00:23:23,050
either be in a loading state or it could

00:23:20,320 --> 00:23:24,490
have some errors or it could have none

00:23:23,050 --> 00:23:26,320
of those and then it just gives you the

00:23:24,490 --> 00:23:27,760
data back so instead what we would do is

00:23:26,320 --> 00:23:30,040
we would just do a case over the props

00:23:27,760 --> 00:23:31,720
and we would tell it how to handle each

00:23:30,040 --> 00:23:34,030
of those and what to return in each of

00:23:31,720 --> 00:23:35,380
those cases I encourage you to write the

00:23:34,030 --> 00:23:36,700
same example in JSX

00:23:35,380 --> 00:23:38,290
and then see what you think about this

00:23:36,700 --> 00:23:42,820
proposal afterwards cuz this this is

00:23:38,290 --> 00:23:44,410
super nice so having talked about all of

00:23:42,820 --> 00:23:46,000
that let's talk about where pattern

00:23:44,410 --> 00:23:49,330
matching is because like I mentioned

00:23:46,000 --> 00:23:53,620
it's not reality right now so right now

00:23:49,330 --> 00:23:55,990
it's a proposal in stage one of tc39 so

00:23:53,620 --> 00:23:57,550
stage one is that it's been evaluated

00:23:55,990 --> 00:23:59,830
it's been talked about and it's

00:23:57,550 --> 00:24:03,100
interesting enough that tc39 is

00:23:59,830 --> 00:24:04,360
interested in pursuing pursuing it more

00:24:03,100 --> 00:24:06,550
and figuring out what it would take to

00:24:04,360 --> 00:24:08,260
make this a part of the language so this

00:24:06,550 --> 00:24:10,060
means that the semantics are being

00:24:08,260 --> 00:24:11,860
discussed a lot more all of the edge

00:24:10,060 --> 00:24:13,870
cases are trying to be identified so

00:24:11,860 --> 00:24:17,100
that we can define how would this fit

00:24:13,870 --> 00:24:19,390
into the language what's really cool I

00:24:17,100 --> 00:24:22,750
didn't know a lot about this until

00:24:19,390 --> 00:24:25,810
researching this talk tc39 is a github

00:24:22,750 --> 00:24:27,970
organization and basically all of the

00:24:25,810 --> 00:24:31,120
documents that go into the language that

00:24:27,970 --> 00:24:34,540
all of us use are just documents on

00:24:31,120 --> 00:24:37,210
github so the the repository for pattern

00:24:34,540 --> 00:24:39,250
matching is right now just some readme

00:24:37,210 --> 00:24:41,440
files that you can go through you can in

00:24:39,250 --> 00:24:42,279
your head kind of say oh what what would

00:24:41,440 --> 00:24:43,509
it mean in this case

00:24:42,279 --> 00:24:45,849
what would it mean in this other case

00:24:43,509 --> 00:24:47,289
you can open up issues saying I'm not

00:24:45,849 --> 00:24:49,960
sure it would work the way that I would

00:24:47,289 --> 00:24:51,759
expect it in here what does that mean so

00:24:49,960 --> 00:24:53,649
this means that right now contributing

00:24:51,759 --> 00:24:56,200
to the proposal is really easy it's all

00:24:53,649 --> 00:24:58,059
just thought experiments the next step

00:24:56,200 --> 00:24:59,590
after this would be to figure out how to

00:24:58,059 --> 00:25:01,809
actually play around with it and how to

00:24:59,590 --> 00:25:04,090
get it in the wild so right now let's

00:25:01,809 --> 00:25:07,570
skip to the bottom there's this library

00:25:04,090 --> 00:25:09,669
called sweet j/s which enables you to do

00:25:07,570 --> 00:25:12,179
macros so basically to extend the

00:25:09,669 --> 00:25:14,139
JavaScript language however you want I

00:25:12,179 --> 00:25:16,570
generally don't think the macros are a

00:25:14,139 --> 00:25:17,950
good idea but they're fun and they

00:25:16,570 --> 00:25:19,749
enable you to play out with things like

00:25:17,950 --> 00:25:22,479
that before with this before they're

00:25:19,749 --> 00:25:24,009
ready so sweet J's right now has a macro

00:25:22,479 --> 00:25:25,599
that enables you to do this style of

00:25:24,009 --> 00:25:27,129
pattern matching it's actually where a

00:25:25,599 --> 00:25:29,799
lot of the inspiration for this proposal

00:25:27,129 --> 00:25:32,559
comes from there's also in the works a

00:25:29,799 --> 00:25:35,649
babel plugin that is going to enable you

00:25:32,559 --> 00:25:38,169
to use this syntax and try it out so if

00:25:35,649 --> 00:25:39,549
this all sounds interesting there's a

00:25:38,169 --> 00:25:42,399
couple different things you can do one

00:25:39,549 --> 00:25:44,139
is you could go to TC 39 and follow the

00:25:42,399 --> 00:25:45,219
pattern matching repo then whenever

00:25:44,139 --> 00:25:48,460
anything happens there you'll be

00:25:45,219 --> 00:25:50,649
notified of it too is that you can find

00:25:48,460 --> 00:25:53,139
the pull request for the babel plugin

00:25:50,649 --> 00:25:54,519
and then follow that I can tweet out a

00:25:53,139 --> 00:25:55,809
link to that so that if that's what

00:25:54,519 --> 00:25:57,279
you're interested in you can just follow

00:25:55,809 --> 00:25:59,440
that pull request and see what's

00:25:57,279 --> 00:26:01,509
happening there and the last option

00:25:59,440 --> 00:26:04,149
would be I'm doing another talk about

00:26:01,509 --> 00:26:05,950
this in Argentina in October so if you

00:26:04,149 --> 00:26:07,989
just follow me this is my Twitter handle

00:26:05,950 --> 00:26:09,460
I'll be tweeting out a lot more about it

00:26:07,989 --> 00:26:10,989
and I can be sure that you get all the

00:26:09,460 --> 00:26:13,509
information about pattern matching that

00:26:10,989 --> 00:26:16,899
you could want so if that sounds

00:26:13,509 --> 00:26:18,969
interesting I have my blog that I put

00:26:16,899 --> 00:26:20,919
some stuff up on the company that I work

00:26:18,969 --> 00:26:23,139
for testable also has a ton of great

00:26:20,919 --> 00:26:25,179
articles on our blog I encourage you to

00:26:23,139 --> 00:26:27,399
go look at both of them here's a picture

00:26:25,179 --> 00:26:28,869
of me and my sister during the World Cup

00:26:27,399 --> 00:26:32,019
wearing our Colombia jerseys because

00:26:28,869 --> 00:26:33,609
we're very patriotic and like I

00:26:32,019 --> 00:26:36,309
mentioned earlier I work for a

00:26:33,609 --> 00:26:39,099
consulting company called testable what

00:26:36,309 --> 00:26:40,960
we do is we go into other companies that

00:26:39,099 --> 00:26:43,269
already have their established

00:26:40,960 --> 00:26:45,039
development teams and we're all

00:26:43,269 --> 00:26:46,929
experienced engineers that can fit into

00:26:45,039 --> 00:26:48,279
the team and help you work on whatever

00:26:46,929 --> 00:26:51,099
it is you're trying to work on at the

00:26:48,279 --> 00:26:52,570
time our goal from doing that is to of

00:26:51,099 --> 00:26:54,669
course help you deliver whatever it is

00:26:52,570 --> 00:26:55,990
you're trying to deliver but also to do

00:26:54,669 --> 00:26:57,970
some coaching on how

00:26:55,990 --> 00:26:59,860
do remote work we're a fully remote

00:26:57,970 --> 00:27:01,390
company so we help companies that are

00:26:59,860 --> 00:27:04,090
trying to make a transition over to

00:27:01,390 --> 00:27:06,160
doing that we help companies with agile

00:27:04,090 --> 00:27:07,900
practices and with testing practices to

00:27:06,160 --> 00:27:10,540
help them better deliver code in the

00:27:07,900 --> 00:27:11,860
future and like I said we try to just be

00:27:10,540 --> 00:27:13,960
really nice with everyone we interact

00:27:11,860 --> 00:27:15,610
with so if that sounds like people you'd

00:27:13,960 --> 00:27:18,220
like to work with you can go ahead and

00:27:15,610 --> 00:27:19,630
go to test double slash contact to ask

00:27:18,220 --> 00:27:21,490
us what that would look like for your

00:27:19,630 --> 00:27:23,590
company or if that sounds like some

00:27:21,490 --> 00:27:24,940
place you'd like to work at I'd love to

00:27:23,590 --> 00:27:28,000
have you as my coworker so you can go to

00:27:24,940 --> 00:27:29,290
test double comm /join thank you all

00:27:28,000 --> 00:27:30,640
very much for joining I hope you have a

00:27:29,290 --> 00:27:32,770
great time at the rest of this

00:27:30,640 --> 00:27:34,310
conference and come say hi to me if you

00:27:32,770 --> 00:27:40,890
see me around Thanks

00:27:34,310 --> 00:27:40,890

YouTube URL: https://www.youtube.com/watch?v=Gfm6kepLop0


