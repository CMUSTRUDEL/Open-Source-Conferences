Title: JavaScript Concurrency and the DOM - Kristofer Baxter and Malte Ubl - JSConf US 2018
Publication date: 2018-11-01
Playlist: JSConf US 2018
Description: 
	Worker DOM GitHub project: https://github.com/ampproject/worker-dom
Blog post: https://www.ampproject.org/latest/blog/workerdom/
Slides: https://speakerdeck.com/cramforce/workerdom-javascript-concurrency-and-the-dom
Captions: 
	00:00:00,320 --> 00:00:03,840
[Music]

00:00:02,070 --> 00:00:05,660
[Applause]

00:00:03,840 --> 00:00:07,410
[Music]

00:00:05,660 --> 00:00:09,280
[Applause]

00:00:07,410 --> 00:00:11,020
[Music]

00:00:09,280 --> 00:00:12,780
[Applause]

00:00:11,020 --> 00:00:15,920
[Music]

00:00:12,780 --> 00:00:15,920
[Applause]

00:00:16,870 --> 00:00:25,770
[Music]

00:00:23,080 --> 00:00:27,160
[Applause]

00:00:25,770 --> 00:00:29,079
well great

00:00:27,160 --> 00:00:31,270
hello everyone I'm Christopher Baxter

00:00:29,079 --> 00:00:33,280
and I'm multiple we're going to talk

00:00:31,270 --> 00:00:35,649
about concurrency in JavaScript with a

00:00:33,280 --> 00:00:37,420
particular focus on the Dom now

00:00:35,649 --> 00:00:39,460
concurrency is a big topic it's maybe a

00:00:37,420 --> 00:00:43,000
complicated topic so let's look at some

00:00:39,460 --> 00:00:44,650
of the basics behind it currency is

00:00:43,000 --> 00:00:46,090
really it's just a technical word for

00:00:44,650 --> 00:00:49,780
multiple parts of a computer program

00:00:46,090 --> 00:00:52,720
running at the same time now if your

00:00:49,780 --> 00:00:55,030
computer or phone has more than one core

00:00:52,720 --> 00:00:57,399
which it does or you have more than one

00:00:55,030 --> 00:00:59,910
computer which the cloud does then this

00:00:57,399 --> 00:01:02,380
can make things get done much faster

00:00:59,910 --> 00:01:04,439
however it generally also makes things

00:01:02,380 --> 00:01:07,149
way more complicated

00:01:04,439 --> 00:01:08,259
speaking of concurrency you always kind

00:01:07,149 --> 00:01:09,790
of have to talk about like the

00:01:08,259 --> 00:01:12,189
difference between parallelism and

00:01:09,790 --> 00:01:14,500
concurrency they're just the same thing

00:01:12,189 --> 00:01:16,470
but someone in the 80s took away the

00:01:14,500 --> 00:01:18,460
awesome word which is parallelism and

00:01:16,470 --> 00:01:20,409
made it means something very specific

00:01:18,460 --> 00:01:21,370
but that doesn't matter are we gonna say

00:01:20,409 --> 00:01:24,520
parallelism and concurrency

00:01:21,370 --> 00:01:27,729
interchangeable who cares so another

00:01:24,520 --> 00:01:30,000
important concept are threats they're

00:01:27,729 --> 00:01:33,070
just programs that run on a computer and

00:01:30,000 --> 00:01:34,750
there can be more than one threat active

00:01:33,070 --> 00:01:38,560
at any given time

00:01:34,750 --> 00:01:41,500
now concurrency doesn't require multiple

00:01:38,560 --> 00:01:44,409
threats for example network requests can

00:01:41,500 --> 00:01:47,530
happen while your main thread is running

00:01:44,409 --> 00:01:50,110
and so that's still a concurrent program

00:01:47,530 --> 00:01:52,689
but if you have only one thread and your

00:01:50,110 --> 00:01:55,420
program can only do one thing at a time

00:01:52,689 --> 00:01:55,930
on a given device so we saw call such a

00:01:55,420 --> 00:01:57,549
program

00:01:55,930 --> 00:01:59,619
single threaded and that's an important

00:01:57,549 --> 00:02:01,270
term because web browsers which we're

00:01:59,619 --> 00:02:03,430
talking about today are traditionally

00:02:01,270 --> 00:02:05,590
single threaded now today they're like

00:02:03,430 --> 00:02:07,600
these complicated beasts and they do

00:02:05,590 --> 00:02:09,759
many things at the same time but they

00:02:07,600 --> 00:02:11,769
very much still behave as if there were

00:02:09,759 --> 00:02:14,290
a single threaded so it's a good model

00:02:11,769 --> 00:02:16,420
to have in your head the single thread

00:02:14,290 --> 00:02:17,829
we call the main thread and very

00:02:16,420 --> 00:02:20,380
important is this Jess confit your

00:02:17,829 --> 00:02:22,720
JavaScript runs on the main threat by

00:02:20,380 --> 00:02:24,580
default so if you write some JavaScript

00:02:22,720 --> 00:02:26,590
and it's still running

00:02:24,580 --> 00:02:29,530
your browser cannot do anything at the

00:02:26,590 --> 00:02:32,260
same time which might be bad because oh

00:02:29,530 --> 00:02:34,930
my god we have to achieve 60 frames per

00:02:32,260 --> 00:02:35,680
second all the time where does his

00:02:34,930 --> 00:02:37,360
number come from

00:02:35,680 --> 00:02:40,570
that's basically the fundamental

00:02:37,360 --> 00:02:44,470
constant of runtime performance

00:02:40,570 --> 00:02:46,660
it's how often on a normal device your

00:02:44,470 --> 00:02:50,920
graphics card would like to push pixels

00:02:46,660 --> 00:02:52,870
to the screen now humans don't you know

00:02:50,920 --> 00:02:55,270
bias to this particular framework frame

00:02:52,870 --> 00:02:56,680
rate for example movies traditionally

00:02:55,270 --> 00:02:58,960
run in the 24 frames per second

00:02:56,680 --> 00:03:01,060
important is that they always run 24

00:02:58,960 --> 00:03:04,150
frames per second humans are really good

00:03:01,060 --> 00:03:06,370
at recognizing changes in frame rate if

00:03:04,150 --> 00:03:09,670
frame rate isn't stable we call that

00:03:06,370 --> 00:03:15,220
Jack and jank is really bad because it

00:03:09,670 --> 00:03:16,870
makes our you know brains go wild now 60

00:03:15,220 --> 00:03:18,790
frames per second leads to another magic

00:03:16,870 --> 00:03:21,250
number which is 60 milliseconds that's

00:03:18,790 --> 00:03:24,280
just 1,000 milliseconds in a second

00:03:21,250 --> 00:03:26,700
divided by 60 which is what do you have

00:03:24,280 --> 00:03:28,690
to update the screen right well

00:03:26,700 --> 00:03:31,510
unfortunately it's more complicated so

00:03:28,690 --> 00:03:32,920
there's you and then there is stuff the

00:03:31,510 --> 00:03:34,630
browser does which is a layout style

00:03:32,920 --> 00:03:37,510
calculation painting compositing

00:03:34,630 --> 00:03:40,780
actually physically flipping the pixels

00:03:37,510 --> 00:03:43,090
on the screen and everything in that 60

00:03:40,780 --> 00:03:46,330
milliseconds has to fit into that kind

00:03:43,090 --> 00:03:48,340
of budget great so let's break that down

00:03:46,330 --> 00:03:50,680
a little bit because it's pretty darn

00:03:48,340 --> 00:03:52,420
complicated you've got 16 milliseconds a

00:03:50,680 --> 00:03:53,680
lot of code to execute and you're trying

00:03:52,420 --> 00:03:55,510
to get it all done within this time

00:03:53,680 --> 00:03:58,030
frame the important thing to remember

00:03:55,510 --> 00:03:59,410
though is that's not just your code your

00:03:58,030 --> 00:04:01,090
code runs for a certain amount of time

00:03:59,410 --> 00:04:03,370
and the browser needs to respond to the

00:04:01,090 --> 00:04:06,130
changes that you asked it to do as well

00:04:03,370 --> 00:04:07,780
in that time frame and sometimes we

00:04:06,130 --> 00:04:10,300
think about this as breaking it into two

00:04:07,780 --> 00:04:12,370
eight millisecond segments the reason is

00:04:10,300 --> 00:04:14,140
that the time that the browser needs is

00:04:12,370 --> 00:04:16,269
kind of arbitrary we don't know that in

00:04:14,140 --> 00:04:19,419
advance and so we shoot for pretty much

00:04:16,269 --> 00:04:21,940
the worst case so what happens in this

00:04:19,419 --> 00:04:24,130
eight milliseconds we have a lot of

00:04:21,940 --> 00:04:26,440
stuff to do and let's hope it's not too

00:04:24,130 --> 00:04:29,080
expensive we get a click event that

00:04:26,440 --> 00:04:30,720
lands in our UI and after we get that

00:04:29,080 --> 00:04:33,280
click event we need to process the event

00:04:30,720 --> 00:04:35,410
now many traditional water and

00:04:33,280 --> 00:04:38,110
frameworks will then do a state change

00:04:35,410 --> 00:04:40,420
at this point so we need to determine

00:04:38,110 --> 00:04:43,180
what that new state is going to be that

00:04:40,420 --> 00:04:45,250
takes some time after we've created a

00:04:43,180 --> 00:04:48,130
new state you need to respond to that

00:04:45,250 --> 00:04:50,800
state so this response may be a virtual

00:04:48,130 --> 00:04:53,400
Dom diff in some libraries or it may be

00:04:50,800 --> 00:04:56,710
a direct mutation of elements and others

00:04:53,400 --> 00:04:59,770
later we have to issue the direct Dom

00:04:56,710 --> 00:05:01,870
updates it's a lot of work to fit in 8

00:04:59,770 --> 00:05:04,840
milliseconds and we don't always make it

00:05:01,870 --> 00:05:07,600
so what happens when we don't well we

00:05:04,840 --> 00:05:09,160
push everything out so now instead of

00:05:07,600 --> 00:05:10,870
being 8 milliseconds we're at 10

00:05:09,160 --> 00:05:12,940
milliseconds in this example because my

00:05:10,870 --> 00:05:15,730
state change process took two

00:05:12,940 --> 00:05:17,440
milliseconds longer what does this mean

00:05:15,730 --> 00:05:20,440
for the end user it's not that big of a

00:05:17,440 --> 00:05:22,570
deal right what means that we went past

00:05:20,440 --> 00:05:24,730
our frame budget because we took 10

00:05:22,570 --> 00:05:28,360
milliseconds the browser really needs 8

00:05:24,730 --> 00:05:30,400
we're now at 18 congratulations we've

00:05:28,360 --> 00:05:34,210
unintentionally and produced a little

00:05:30,400 --> 00:05:36,250
bit jank now don't feel bad we all do

00:05:34,210 --> 00:05:38,020
this it's common it happens to all of

00:05:36,250 --> 00:05:41,140
our applications just don't let it

00:05:38,020 --> 00:05:43,300
happen too much right however it's hard

00:05:41,140 --> 00:05:45,730
to keep this going and hard to make this

00:05:43,300 --> 00:05:47,620
work well across all devices because you

00:05:45,730 --> 00:05:48,970
can target the devices that you know but

00:05:47,620 --> 00:05:53,350
you don't know the performance of your

00:05:48,970 --> 00:05:55,480
application on unknown devices why well

00:05:53,350 --> 00:05:56,350
because not all mobile devices are

00:05:55,480 --> 00:05:58,360
created equal

00:05:56,350 --> 00:06:00,400
we've got a plethora of devices that are

00:05:58,360 --> 00:06:03,700
out in the world things from low-end

00:06:00,400 --> 00:06:06,850
devices that are sold for $80 brand-new

00:06:03,700 --> 00:06:09,550
to high-end devices at $1,000 per unit

00:06:06,850 --> 00:06:11,170
and sometimes people hold on devices for

00:06:09,550 --> 00:06:14,110
way longer than you would expect a

00:06:11,170 --> 00:06:15,550
person buying a phone in 2016 is

00:06:14,110 --> 00:06:17,350
probably still holding on to that phone

00:06:15,550 --> 00:06:19,650
and the performance of that device has

00:06:17,350 --> 00:06:22,000
not improved in fact it's gotten worse

00:06:19,650 --> 00:06:23,440
so it's important to remember that the

00:06:22,000 --> 00:06:25,630
things that you see are not everything

00:06:23,440 --> 00:06:29,680
is not everything that a person using

00:06:25,630 --> 00:06:32,560
your application sees so let's go into

00:06:29,680 --> 00:06:34,660
this a little bit more in depth pretend

00:06:32,560 --> 00:06:36,220
we're walking into a brand new big store

00:06:34,660 --> 00:06:39,310
like a Best Buy and we're gonna buy a

00:06:36,220 --> 00:06:41,050
new device today it's helpful to think

00:06:39,310 --> 00:06:43,120
about a device that you're purchasing as

00:06:41,050 --> 00:06:45,580
breaking down into one of three segments

00:06:43,120 --> 00:06:48,730
the first segment the first the 15th

00:06:45,580 --> 00:06:50,170
percentile is roughly around $80 so if

00:06:48,730 --> 00:06:51,150
you were walking in today and you wanted

00:06:50,170 --> 00:06:52,740
to spend around 80

00:06:51,150 --> 00:06:55,890
you could afford a device in this

00:06:52,740 --> 00:06:58,110
specific segment of the market the

00:06:55,890 --> 00:06:59,610
second segment is around 75th percentile

00:06:58,110 --> 00:07:02,520
where you're looking at spending close

00:06:59,610 --> 00:07:05,760
to $600 that's a really large increase

00:07:02,520 --> 00:07:08,730
and the third segment is the special

00:07:05,760 --> 00:07:10,470
segment I would say because you're able

00:07:08,730 --> 00:07:12,720
to spend a thousand dollars on this

00:07:10,470 --> 00:07:15,360
device one device a thousand dollars

00:07:12,720 --> 00:07:17,070
now this gamut of price is not normally

00:07:15,360 --> 00:07:19,590
reflected in our metrics we tend to look

00:07:17,070 --> 00:07:21,270
at things as a whole however if you

00:07:19,590 --> 00:07:25,230
break things down into these segments

00:07:21,270 --> 00:07:26,840
patterns start to emerge so let's look

00:07:25,230 --> 00:07:29,250
at single core performance over time

00:07:26,840 --> 00:07:31,950
this is a chart of all single core

00:07:29,250 --> 00:07:33,000
performance of modern devices from 2011

00:07:31,950 --> 00:07:35,760
to 2018

00:07:33,000 --> 00:07:38,820
now the segment's are again highlighted

00:07:35,760 --> 00:07:40,590
here so blue is the 15th percentile you

00:07:38,820 --> 00:07:42,990
might notice that this trend line is not

00:07:40,590 --> 00:07:45,510
going up and there's a reason for that

00:07:42,990 --> 00:07:47,310
these devices are not becoming faster

00:07:45,510 --> 00:07:49,830
they're becoming cheaper and more

00:07:47,310 --> 00:07:53,040
accessible and more prolific across the

00:07:49,830 --> 00:07:54,450
world these devices are not improving at

00:07:53,040 --> 00:07:59,070
the rate that you would expect with

00:07:54,450 --> 00:08:01,410
Moore's law the second category is that

00:07:59,070 --> 00:08:03,120
75th percentile and this is a pretty

00:08:01,410 --> 00:08:05,340
close approximation to what you would

00:08:03,120 --> 00:08:07,320
expect from Moore's Law we're seeing an

00:08:05,340 --> 00:08:09,660
improvement in performance over time and

00:08:07,320 --> 00:08:11,940
these devices can even have specialized

00:08:09,660 --> 00:08:13,500
hardware like a pixel does that allows

00:08:11,940 --> 00:08:17,520
you to do say machine learning on the

00:08:13,500 --> 00:08:19,620
device our third category is worth

00:08:17,520 --> 00:08:21,600
talking about as well credit where

00:08:19,620 --> 00:08:25,110
credit is due the a-series processors

00:08:21,600 --> 00:08:28,110
are fantastic these things outperform

00:08:25,110 --> 00:08:30,360
Moore's law by a dramatic amount but it

00:08:28,110 --> 00:08:32,760
creates a very large problem for our

00:08:30,360 --> 00:08:34,530
industry as a whole the problem is that

00:08:32,760 --> 00:08:37,050
we take out the devices that we have in

00:08:34,530 --> 00:08:39,780
our pockets and we test the things that

00:08:37,050 --> 00:08:41,760
we build on these devices these devices

00:08:39,780 --> 00:08:43,170
are not representation are not an

00:08:41,760 --> 00:08:45,270
accurate representation of what's

00:08:43,170 --> 00:08:48,840
available in the world or what many

00:08:45,270 --> 00:08:51,450
people have so this particular gap hurts

00:08:48,840 --> 00:08:53,610
end-users significantly and it's

00:08:51,450 --> 00:08:56,150
important to remember this very large

00:08:53,610 --> 00:08:59,360
performance gap this gap is increasing

00:08:56,150 --> 00:08:59,360
not decreasing

00:09:00,150 --> 00:09:04,440
there's to be some good news right we

00:09:02,940 --> 00:09:06,960
wouldn't be talking about concurrency if

00:09:04,440 --> 00:09:08,850
there wasn't some very small light at

00:09:06,960 --> 00:09:09,270
the tunnel maybe at the end of the

00:09:08,850 --> 00:09:11,070
tunnel

00:09:09,270 --> 00:09:13,020
so what's multi-core performance look

00:09:11,070 --> 00:09:15,090
like let's look at those same devices in

00:09:13,020 --> 00:09:17,190
this first category the 15th percentile

00:09:15,090 --> 00:09:19,680
you can see that the green trend line is

00:09:17,190 --> 00:09:22,290
slightly improving compared to single

00:09:19,680 --> 00:09:24,120
core performance there is one noticeable

00:09:22,290 --> 00:09:26,550
exception at the very end of this line

00:09:24,120 --> 00:09:28,170
the nokia - it's worth calling out

00:09:26,550 --> 00:09:30,840
because there's a very popular phone

00:09:28,170 --> 00:09:34,740
that you can buy for $80 in the United

00:09:30,840 --> 00:09:39,360
States and it is selling like crazy but

00:09:34,740 --> 00:09:41,490
it can't be that bad right I want you to

00:09:39,360 --> 00:09:46,230
bear with me we're about to watch a very

00:09:41,490 --> 00:09:48,990
long video but it's worth the time here

00:09:46,230 --> 00:09:51,720
I have two devices an iPhone on the left

00:09:48,990 --> 00:09:56,010
and an unnamed device on the right you

00:09:51,720 --> 00:09:58,920
name it it's a Nokia - this test the

00:09:56,010 --> 00:10:00,840
Ares 6 test tests modern JavaScript

00:09:58,920 --> 00:10:02,730
features for instance one of the things

00:10:00,840 --> 00:10:06,180
that it runs is a Babel transpilation on

00:10:02,730 --> 00:10:07,710
the device you might criticize that test

00:10:06,180 --> 00:10:09,120
by saying no one will run Babel on a

00:10:07,710 --> 00:10:11,580
mobile phone and you're right for

00:10:09,120 --> 00:10:13,740
criticizing it however it is a good

00:10:11,580 --> 00:10:15,780
representation of what runtime

00:10:13,740 --> 00:10:18,000
performance is like there's no load

00:10:15,780 --> 00:10:20,610
involved there's no network involved

00:10:18,000 --> 00:10:23,730
it's pure capabilities of the local

00:10:20,610 --> 00:10:27,060
device and it's entirely single core

00:10:23,730 --> 00:10:28,620
focused so we've got the iPhone here on

00:10:27,060 --> 00:10:31,230
the Left it's gonna finish this test

00:10:28,620 --> 00:10:33,530
pretty soon all six passes of the test

00:10:31,230 --> 00:10:36,120
are gonna finish at roughly 48 seconds

00:10:33,530 --> 00:10:38,730
now I'm going to speed it up a little

00:10:36,120 --> 00:10:40,770
bit because it's a bit painful the nokia

00:10:38,730 --> 00:10:43,020
2 is gonna be running this test for a

00:10:40,770 --> 00:10:50,550
while longer and we're just gonna wait a

00:10:43,020 --> 00:10:56,250
couple minutes okay now sped it up eight

00:10:50,550 --> 00:11:00,080
times we still haven't finished one pass

00:10:56,250 --> 00:11:00,080
of six or six classes

00:11:01,900 --> 00:11:16,510
it hasn't crashed I promise a-alright

00:11:12,790 --> 00:11:20,770
five minutes and 19 seconds for one of

00:11:16,510 --> 00:11:22,330
six passes that's pretty bad

00:11:20,770 --> 00:11:23,980
but that's what a lot of people's

00:11:22,330 --> 00:11:26,020
devices are like and that's all what a

00:11:23,980 --> 00:11:29,830
lot of people are entering the internet

00:11:26,020 --> 00:11:32,140
using for the first time all right so

00:11:29,830 --> 00:11:35,380
what I kind of took out of these graphs

00:11:32,140 --> 00:11:37,870
is performance is not evenly distributed

00:11:35,380 --> 00:11:39,670
but there is a chance to get a little

00:11:37,870 --> 00:11:42,310
bit more of the devices but taking

00:11:39,670 --> 00:11:45,130
advantage of their multiple cores so how

00:11:42,310 --> 00:11:47,050
do we do that in JavaScript well super

00:11:45,130 --> 00:11:49,780
excited to announce super amazing new

00:11:47,050 --> 00:11:54,610
API on it called the web worker which

00:11:49,780 --> 00:11:57,810
has actually been around since 2009 do

00:11:54,610 --> 00:11:57,810
folks remember Ajax Ian

00:12:00,600 --> 00:12:04,690
if the Ajax iam wrote about something

00:12:03,400 --> 00:12:06,250
you have to check whether it's still

00:12:04,690 --> 00:12:08,980
supported not where the browser supports

00:12:06,250 --> 00:12:10,030
it this is this API is in every browser

00:12:08,980 --> 00:12:12,100
it's in ie8

00:12:10,030 --> 00:12:14,020
it's not a 96 all right so it's not in

00:12:12,100 --> 00:12:15,880
every browser but it is in every browser

00:12:14,020 --> 00:12:18,100
you care about we can really take

00:12:15,880 --> 00:12:20,680
advantage of it so what are they they

00:12:18,100 --> 00:12:23,050
are a way to write multivariate

00:12:20,680 --> 00:12:24,340
JavaScript in web browsers now you've

00:12:23,050 --> 00:12:26,680
probably heard that multi-threading can

00:12:24,340 --> 00:12:28,690
be like dangerous and memory unsafe so

00:12:26,680 --> 00:12:32,080
this is not the case here workers share

00:12:28,690 --> 00:12:36,370
no state at all with each other or the

00:12:32,080 --> 00:12:38,950
main threat they have only access to

00:12:36,370 --> 00:12:40,570
very limited set of API so they can't do

00:12:38,950 --> 00:12:43,060
everything you can do on the main thread

00:12:40,570 --> 00:12:45,460
and and it's very important for this

00:12:43,060 --> 00:12:47,260
presentation they do not have access to

00:12:45,460 --> 00:12:51,100
the Dom and we're talking about

00:12:47,260 --> 00:12:53,140
concurrency in the Dom so sad face let's

00:12:51,100 --> 00:12:55,120
take a look at how that API looks like

00:12:53,140 --> 00:12:56,740
the worker you know you just make a

00:12:55,120 --> 00:12:59,140
worker or you give it a Java file and

00:12:56,740 --> 00:13:02,050
then it runs and you can send it

00:12:59,140 --> 00:13:03,310
messages this post message this kind of

00:13:02,050 --> 00:13:04,960
usually looks like this you know you get

00:13:03,310 --> 00:13:06,820
some event you send a message to the

00:13:04,960 --> 00:13:09,280
worker the worker receives a message

00:13:06,820 --> 00:13:11,410
does some computation sense us back we

00:13:09,280 --> 00:13:14,770
receive it back we have to compute it I

00:13:11,410 --> 00:13:15,630
think one of the main things here is we

00:13:14,770 --> 00:13:18,090
have to

00:13:15,630 --> 00:13:20,190
be very conscience the right coat like

00:13:18,090 --> 00:13:24,090
this we have to measure that we have to

00:13:20,190 --> 00:13:25,950
we have to you know do the work ten

00:13:24,090 --> 00:13:27,660
years of adoption have shown that this

00:13:25,950 --> 00:13:28,800
is not something we do very often right

00:13:27,660 --> 00:13:32,310
so there's a problem with this

00:13:28,800 --> 00:13:34,470
programming model so the primitives to

00:13:32,310 --> 00:13:37,230
low level is there something a bit more

00:13:34,470 --> 00:13:39,210
abstracted perhaps usable in comparison

00:13:37,230 --> 00:13:41,180
I'd like to go over a few things that

00:13:39,210 --> 00:13:43,740
are showing some progress in this space

00:13:41,180 --> 00:13:46,800
first ones called Cluny it's made by the

00:13:43,740 --> 00:13:48,540
chrome team the way that it works is the

00:13:46,800 --> 00:13:50,670
JavaScript you want to run in a separate

00:13:48,540 --> 00:13:53,220
thread is actually loaded with your main

00:13:50,670 --> 00:13:55,020
thread JavaScript so in this case we

00:13:53,220 --> 00:13:57,150
have a class that exists within the main

00:13:55,020 --> 00:13:59,910
thread but using Cluny were able to

00:13:57,150 --> 00:14:02,670
spawn an instance of that that class

00:13:59,910 --> 00:14:04,320
that runs entirely in the worker so what

00:14:02,670 --> 00:14:06,960
happens is Cluny underneath the hood

00:14:04,320 --> 00:14:08,460
creates a web worker for you sends over

00:14:06,960 --> 00:14:09,870
the JavaScript that it needs to be able

00:14:08,460 --> 00:14:14,310
to execute in the worker and you can

00:14:09,870 --> 00:14:16,230
just await its response but it would be

00:14:14,310 --> 00:14:18,480
great if this was actually in the

00:14:16,230 --> 00:14:19,620
browser itself right this is something

00:14:18,480 --> 00:14:22,020
that feels like it should be an echo

00:14:19,620 --> 00:14:23,550
echo script level spec so there's a few

00:14:22,020 --> 00:14:26,100
specification outs that are that are

00:14:23,550 --> 00:14:27,570
trying to bring this to Ahmed script the

00:14:26,100 --> 00:14:30,330
one that I think is the most interesting

00:14:27,570 --> 00:14:32,280
is called Jas blocks but it has an M lot

00:14:30,330 --> 00:14:37,830
above the O so I don't know how to guess

00:14:32,280 --> 00:14:39,630
blex ducts whatever he said so the way

00:14:37,830 --> 00:14:41,880
that this one works is very similar to

00:14:39,630 --> 00:14:43,800
the last example in the sense that the

00:14:41,880 --> 00:14:46,370
block that we're defining here that has

00:14:43,800 --> 00:14:48,870
this additional straight lines is

00:14:46,370 --> 00:14:51,780
indicates that this piece specific piece

00:14:48,870 --> 00:14:53,190
of code can run in any thread it may run

00:14:51,780 --> 00:14:54,570
in the main thread and may run in a

00:14:53,190 --> 00:14:56,520
different thread it's up to the browser

00:14:54,570 --> 00:14:58,950
runtime or the JavaScript runtime in

00:14:56,520 --> 00:15:01,650
this case to determine based on system

00:14:58,950 --> 00:15:03,120
resources where this should run but this

00:15:01,650 --> 00:15:05,310
presents a pretty big problem in

00:15:03,120 --> 00:15:07,830
JavaScript because this thing wouldn't

00:15:05,310 --> 00:15:09,870
have access to lexical scope it only

00:15:07,830 --> 00:15:11,370
knows about the scope of its current

00:15:09,870 --> 00:15:13,080
block it can't know about anything

00:15:11,370 --> 00:15:15,630
outside of it because it may not run in

00:15:13,080 --> 00:15:17,640
the same thread well the proposal

00:15:15,630 --> 00:15:19,350
provides some syntax to allow you to

00:15:17,640 --> 00:15:21,330
specify the things that you would like

00:15:19,350 --> 00:15:23,370
to ensure are available in that within

00:15:21,330 --> 00:15:24,930
that specific block in this case

00:15:23,370 --> 00:15:28,390
something that looks a little bit like

00:15:24,930 --> 00:15:30,130
typescript is included so you can say

00:15:28,390 --> 00:15:32,170
for this specific worker instance I'd

00:15:30,130 --> 00:15:36,519
like to make sure the end point dogs are

00:15:32,170 --> 00:15:38,620
best is passed along let's look at

00:15:36,519 --> 00:15:40,540
something a little bit more easy to use

00:15:38,620 --> 00:15:43,120
straightforward applies to many of our

00:15:40,540 --> 00:15:45,010
applications today many of us use redux

00:15:43,120 --> 00:15:47,050
in this room and many of us across the

00:15:45,010 --> 00:15:51,370
globe use it from really great earlier

00:15:47,050 --> 00:15:53,800
talk today so redux is pretty powerful

00:15:51,370 --> 00:15:55,480
but it runs in the main thread so what

00:15:53,800 --> 00:15:57,370
happens in that earlier model is we

00:15:55,480 --> 00:15:59,709
would need to run our entire Redux store

00:15:57,370 --> 00:16:02,019
and reducers for all of those actions in

00:15:59,709 --> 00:16:04,120
the main thread stockroom from Jason

00:16:02,019 --> 00:16:06,790
Miller is very similar to redux except

00:16:04,120 --> 00:16:09,250
that it runs in a worker so your main

00:16:06,790 --> 00:16:11,230
thread code subscribes to updates that

00:16:09,250 --> 00:16:14,769
come from your Redux store but your

00:16:11,230 --> 00:16:16,839
networking requests and your redux kind

00:16:14,769 --> 00:16:19,240
of massaging of data happens entirely

00:16:16,839 --> 00:16:20,860
off the main thread this can free up a

00:16:19,240 --> 00:16:25,029
significant amount of your time and a

00:16:20,860 --> 00:16:27,190
web app that uses redux heavily but I

00:16:25,029 --> 00:16:29,350
thought this talk was about the Dom you

00:16:27,190 --> 00:16:33,430
are absolutely right

00:16:29,350 --> 00:16:35,850
so Malta yeah so as I said earlier the

00:16:33,430 --> 00:16:38,050
workers cannot have access to the Dom

00:16:35,850 --> 00:16:39,459
which is said and so I'm super excited

00:16:38,050 --> 00:16:42,820
to announce that we're releasing a

00:16:39,459 --> 00:16:44,829
library called worker Dom which exposed

00:16:42,820 --> 00:16:47,490
the same Dom API that you know love to

00:16:44,829 --> 00:16:49,899
you and the frameworks in a web worker

00:16:47,490 --> 00:16:53,170
let's take a look at the original

00:16:49,899 --> 00:16:54,820
requirements when we went about kind of

00:16:53,170 --> 00:16:56,949
building this library I was like hey

00:16:54,820 --> 00:16:58,810
Chris can you make it said react works

00:16:56,949 --> 00:17:04,209
in the web worker and that was really

00:16:58,810 --> 00:17:06,790
all I wanted but I think grace was yeah

00:17:04,209 --> 00:17:08,199
you know first the fun of that let's do

00:17:06,790 --> 00:17:09,910
something more abstract let's do

00:17:08,199 --> 00:17:12,549
something that supports the whole

00:17:09,910 --> 00:17:16,110
variety of web programming so what is

00:17:12,549 --> 00:17:19,209
worker DOM and makes the full Dom API

00:17:16,110 --> 00:17:20,709
available to what worker effectively

00:17:19,209 --> 00:17:23,049
this means that you can use your

00:17:20,709 --> 00:17:26,470
existing web app and run in the web

00:17:23,049 --> 00:17:28,990
worker and it just works with some terms

00:17:26,470 --> 00:17:31,970
and conditions obviously

00:17:28,990 --> 00:17:33,350
but you know we'll go in there let's

00:17:31,970 --> 00:17:36,400
look at the use cases you can use this

00:17:33,350 --> 00:17:39,200
to speed up your existing yep app yay

00:17:36,400 --> 00:17:40,940
framework authors can use it to speed up

00:17:39,200 --> 00:17:44,090
their existing framework with making

00:17:40,940 --> 00:17:46,010
minor changes and one particular use

00:17:44,090 --> 00:17:47,600
case done I'm very excited about you've

00:17:46,010 --> 00:17:49,880
probably heard that third-party

00:17:47,600 --> 00:17:52,460
JavaScript other people JavaScript like

00:17:49,880 --> 00:17:53,960
your analytics framework that's you know

00:17:52,460 --> 00:17:55,520
they're a problem for your site because

00:17:53,960 --> 00:17:57,530
you can control them and they might do

00:17:55,520 --> 00:17:59,420
bad things wouldn't be nice if you just

00:17:57,530 --> 00:18:01,070
ran them on a worker and they kind of

00:17:59,420 --> 00:18:03,200
did their own thing but they couldn't

00:18:01,070 --> 00:18:05,120
touch your code I think this is an

00:18:03,200 --> 00:18:07,610
amazing use case where this library

00:18:05,120 --> 00:18:09,970
could be super powerful all right let's

00:18:07,610 --> 00:18:12,860
take a look what it does to your program

00:18:09,970 --> 00:18:15,650
coming back to this example that Chris

00:18:12,860 --> 00:18:17,180
introduced earlier so you know we have

00:18:15,650 --> 00:18:18,770
this main thread and we're doing event

00:18:17,180 --> 00:18:20,990
processing state determination

00:18:18,770 --> 00:18:23,780
processing dumb issues the browser

00:18:20,990 --> 00:18:26,630
doesn't work and those things they added

00:18:23,780 --> 00:18:28,130
up to 18 milliseconds there's a second

00:18:26,630 --> 00:18:30,530
number there it was just the latency

00:18:28,130 --> 00:18:32,510
which is 80 milliseconds took 18

00:18:30,530 --> 00:18:34,850
milliseconds to react to a user action

00:18:32,510 --> 00:18:36,560
that's yellow because that is actually

00:18:34,850 --> 00:18:38,300
okay if you're familiar with the rails

00:18:36,560 --> 00:18:40,490
model for example actually gives us 50

00:18:38,300 --> 00:18:43,670
milliseconds to react to the user so

00:18:40,490 --> 00:18:47,390
that's kind of cool right so but we're

00:18:43,670 --> 00:18:48,650
janky so let's introduce worker Dom the

00:18:47,390 --> 00:18:50,690
first three steps a free application

00:18:48,650 --> 00:18:53,000
without changing them go into a

00:18:50,690 --> 00:18:55,250
background thread now the whole thing

00:18:53,000 --> 00:18:58,520
still takes 18 milliseconds no change

00:18:55,250 --> 00:19:00,860
there but the stuff that actually is on

00:18:58,520 --> 00:19:02,990
the main thread is now massively reduced

00:19:00,860 --> 00:19:05,810
we're now at 10 milliseconds which is

00:19:02,990 --> 00:19:08,570
silky smooth and I think the important

00:19:05,810 --> 00:19:12,200
part here is that we're now far away

00:19:08,570 --> 00:19:14,420
from breaking through the barrier of 60

00:19:12,200 --> 00:19:16,250
milliseconds right so now we can run on

00:19:14,420 --> 00:19:18,500
a slower device and we still have a lot

00:19:16,250 --> 00:19:20,090
of budget to go to make it there right

00:19:18,500 --> 00:19:22,280
if we're if we're just about like

00:19:20,090 --> 00:19:25,820
scraping against that 16 m/s on an

00:19:22,280 --> 00:19:27,440
iPhone X it's not gonna go well and then

00:19:25,820 --> 00:19:29,810
in the wild so I think this is really

00:19:27,440 --> 00:19:31,190
like a very promising way of building up

00:19:29,810 --> 00:19:35,090
vacation I'm excited to see how that's

00:19:31,190 --> 00:19:38,450
going to go out let's look at those

00:19:35,090 --> 00:19:40,040
terms and conditions really quick now

00:19:38,450 --> 00:19:42,440
the library isn't like hundreds and done

00:19:40,040 --> 00:19:44,570
so some Dom API design implement

00:19:42,440 --> 00:19:47,960
that's cool because you know we can just

00:19:44,570 --> 00:19:50,330
do it there are a small number of dumb

00:19:47,960 --> 00:19:51,800
API is that cannot be implemented but

00:19:50,330 --> 00:19:54,530
there are there are alternatives

00:19:51,800 --> 00:19:56,090
provided and then there's a smaller

00:19:54,530 --> 00:19:58,730
number of Dom API which can't be

00:19:56,090 --> 00:20:01,010
implemented and worker Dom can't really

00:19:58,730 --> 00:20:02,650
work with them at all so let's take a

00:20:01,010 --> 00:20:05,990
quick look at those last two categories

00:20:02,650 --> 00:20:07,730
first of all there unimplemented but

00:20:05,990 --> 00:20:09,980
there is an alternative these are

00:20:07,730 --> 00:20:11,930
primarily dumb api's that provide

00:20:09,980 --> 00:20:13,940
synchronous access to stuff like

00:20:11,930 --> 00:20:16,460
completed layout of a page so for

00:20:13,940 --> 00:20:19,010
example API many of you will be familiar

00:20:16,460 --> 00:20:21,260
with it compounding client rekt so like

00:20:19,010 --> 00:20:24,320
hey browser how big is this diff right

00:20:21,260 --> 00:20:25,940
when you call that function in the main

00:20:24,320 --> 00:20:28,430
thread what the browser will do is will

00:20:25,940 --> 00:20:30,980
go run its entire layout pipeline if

00:20:28,430 --> 00:20:32,180
that's necessary and it's good like full

00:20:30,980 --> 00:20:35,390
in the browser go all the way back and

00:20:32,180 --> 00:20:36,830
that's all synchronous that's not

00:20:35,390 --> 00:20:39,770
implementable in a worker because

00:20:36,830 --> 00:20:41,780
there's no sink access to the Dom so

00:20:39,770 --> 00:20:43,490
what we do instead we provide

00:20:41,780 --> 00:20:45,770
alternatives they all have a async

00:20:43,490 --> 00:20:48,380
suffix so like get burning client direct

00:20:45,770 --> 00:20:49,580
async and the returns a promise now you

00:20:48,380 --> 00:20:52,010
don't have to change your program much

00:20:49,580 --> 00:20:54,500
you just at the async suffix add an

00:20:52,010 --> 00:20:57,050
evade before you're using a single way

00:20:54,500 --> 00:20:58,910
you should and your program works again

00:20:57,050 --> 00:21:01,820
all right so it's a minor change and

00:20:58,910 --> 00:21:04,040
there's an important side benefit if you

00:21:01,820 --> 00:21:05,330
go and optimize the application one of

00:21:04,040 --> 00:21:07,880
the things you're looking out for is

00:21:05,330 --> 00:21:10,310
that you don't make these sync layout

00:21:07,880 --> 00:21:12,950
calls more than once in a given frame

00:21:10,310 --> 00:21:14,030
see if you've make that call it changed

00:21:12,950 --> 00:21:16,730
something make a call again you pay a

00:21:14,030 --> 00:21:19,550
choice if you order syncs the right way

00:21:16,730 --> 00:21:21,590
you only pay it once so by switching to

00:21:19,550 --> 00:21:23,000
this async model the framework can

00:21:21,590 --> 00:21:24,740
actually schedule stuff at the right

00:21:23,000 --> 00:21:26,540
time without you having to worry about

00:21:24,740 --> 00:21:27,530
it which is a much more scalable problem

00:21:26,540 --> 00:21:30,590
so I think this is the right direction

00:21:27,530 --> 00:21:32,780
for the Dom to go anyway these old

00:21:30,590 --> 00:21:35,360
synchronous API is from in 1990 it's

00:21:32,780 --> 00:21:35,570
just not the right way to do it all

00:21:35,360 --> 00:21:38,110
right

00:21:35,570 --> 00:21:40,730
I'm implementable without an alternative

00:21:38,110 --> 00:21:42,680
these are primarily synchronous methods

00:21:40,730 --> 00:21:45,380
on the event like prevent default and

00:21:42,680 --> 00:21:47,090
stop propagation now the browser's event

00:21:45,380 --> 00:21:49,820
processing model is inherently

00:21:47,090 --> 00:21:51,310
synchronous and that means by the time

00:21:49,820 --> 00:21:53,730
the worker learns about the click event

00:21:51,310 --> 00:21:56,039
entire browser eventually

00:21:53,730 --> 00:21:57,779
and that means that you you know you

00:21:56,039 --> 00:21:59,279
might call stop propagation but that

00:21:57,779 --> 00:22:00,899
doesn't do anything because you know

00:21:59,279 --> 00:22:03,210
event processing already rents mean

00:22:00,899 --> 00:22:04,110
nothing you can do there's actually

00:22:03,210 --> 00:22:05,880
light at the end of the tunnel

00:22:04,110 --> 00:22:07,950
transferable events are a thing that

00:22:05,880 --> 00:22:09,929
might come to browser soon and that

00:22:07,950 --> 00:22:11,730
would kind of fix this situation but for

00:22:09,929 --> 00:22:13,769
now basically what it means if you need

00:22:11,730 --> 00:22:15,419
these api's and think you know about

00:22:13,769 --> 00:22:16,529
your last application how often you

00:22:15,419 --> 00:22:18,360
actually call them it's not that much

00:22:16,529 --> 00:22:20,850
you have to run that a little bit of a

00:22:18,360 --> 00:22:24,029
code on the main thread to make sure

00:22:20,850 --> 00:22:26,610
it's the work speaking of working how

00:22:24,029 --> 00:22:27,960
does this library actually work so we

00:22:26,610 --> 00:22:29,370
don't need to understand all of the guts

00:22:27,960 --> 00:22:30,659
of this thing but I thought it'd be

00:22:29,370 --> 00:22:32,130
helpful to go over the kind of the

00:22:30,659 --> 00:22:33,570
high-level as well as some of the

00:22:32,130 --> 00:22:36,149
details that I thought were particularly

00:22:33,570 --> 00:22:38,490
interesting during the implementation so

00:22:36,149 --> 00:22:39,720
let's start with a high-level we start

00:22:38,490 --> 00:22:41,460
off with a main thread in a worker

00:22:39,720 --> 00:22:43,289
thread on the main thread we have a

00:22:41,460 --> 00:22:45,809
runtime roughly one kilobyte of

00:22:43,289 --> 00:22:47,850
JavaScript and this runtime is able to

00:22:45,809 --> 00:22:50,070
look at what the DOM is on the current

00:22:47,850 --> 00:22:51,389
page in this case we have an element an

00:22:50,070 --> 00:22:53,549
HTML element that we would like to

00:22:51,389 --> 00:22:55,559
upgrade to run in within the worker

00:22:53,549 --> 00:22:58,289
context and inside of that just a single

00:22:55,559 --> 00:23:00,330
dip just to make things simple so the

00:22:58,289 --> 00:23:03,450
first thing that happens is the runtime

00:23:00,330 --> 00:23:06,570
will create a worker for you and load

00:23:03,450 --> 00:23:08,669
your JavaScript within that worker now

00:23:06,570 --> 00:23:10,529
worker Dom exists within the worker

00:23:08,669 --> 00:23:13,830
thread and is able to start processing

00:23:10,529 --> 00:23:15,480
your code at this point your code will

00:23:13,830 --> 00:23:17,700
create the Dom structure that it would

00:23:15,480 --> 00:23:20,190
like to have in the document so we have

00:23:17,700 --> 00:23:22,740
a document with our HTML div element and

00:23:20,190 --> 00:23:25,380
then there's a lull your code is

00:23:22,740 --> 00:23:28,350
finished performing an update to the Dom

00:23:25,380 --> 00:23:29,820
in this case we consider hydration so we

00:23:28,350 --> 00:23:31,590
might we make sure that that message is

00:23:29,820 --> 00:23:34,110
passed along over and applied to the

00:23:31,590 --> 00:23:36,090
main thread later as you have input

00:23:34,110 --> 00:23:38,909
events or things that need to you take

00:23:36,090 --> 00:23:41,820
the Dom like click handlers you will

00:23:38,909 --> 00:23:43,649
allow mutations to occur this is very

00:23:41,820 --> 00:23:45,440
simple high level and kind of explains

00:23:43,649 --> 00:23:47,669
what worker Dom does and how it operates

00:23:45,440 --> 00:23:50,760
but let's dive in a little bit more on

00:23:47,669 --> 00:23:53,730
hydration so what is hydration hydration

00:23:50,760 --> 00:23:55,830
is the conversion of string markup into

00:23:53,730 --> 00:23:57,240
usable Dom nodes a helpful way to

00:23:55,830 --> 00:23:59,159
understand this is to look at how the

00:23:57,240 --> 00:24:00,950
browser actually does this with its

00:23:59,159 --> 00:24:03,240
tokenizer

00:24:00,950 --> 00:24:05,010
pretend that we have a section element

00:24:03,240 --> 00:24:07,650
and in this case because we're using

00:24:05,010 --> 00:24:09,450
worker Dom it has an attribute source

00:24:07,650 --> 00:24:12,330
that points to the javascript file of

00:24:09,450 --> 00:24:13,920
your JavaScript that is actually

00:24:12,330 --> 00:24:17,100
represented in the Dom as an HTML

00:24:13,920 --> 00:24:19,260
section element inside that we have a

00:24:17,100 --> 00:24:21,930
HTML div element because I'm pretty bad

00:24:19,260 --> 00:24:24,060
at semantic markup and inside of here

00:24:21,930 --> 00:24:27,300
we'll have three child nodes a text node

00:24:24,060 --> 00:24:29,610
that says hello world followed by a span

00:24:27,300 --> 00:24:33,110
HTML span element with some text inside

00:24:29,610 --> 00:24:37,020
of it that says spanner and lastly an

00:24:33,110 --> 00:24:38,880
HTML input element so this is how the

00:24:37,020 --> 00:24:41,250
browser would tokenize these specific

00:24:38,880 --> 00:24:44,460
elements into Dom structures worker Dom

00:24:41,250 --> 00:24:45,690
does roughly the same thing however we

00:24:44,460 --> 00:24:47,820
need to be able to transmit these

00:24:45,690 --> 00:24:50,070
objects between threads so we need a

00:24:47,820 --> 00:24:52,260
single interface that makes it easy to

00:24:50,070 --> 00:24:53,370
transmit this information that we so we

00:24:52,260 --> 00:24:55,740
don't have to have all of these

00:24:53,370 --> 00:24:58,020
different class types to understand

00:24:55,740 --> 00:25:00,000
between threads so in this case our div

00:24:58,020 --> 00:25:02,280
can be represented as a hydrate Abul

00:25:00,000 --> 00:25:05,340
node it's got an element type of note

00:25:02,280 --> 00:25:07,830
the node type is an element node the tag

00:25:05,340 --> 00:25:09,600
name is div we need a unique identifier

00:25:07,830 --> 00:25:11,490
so we can reference that node on both

00:25:09,600 --> 00:25:12,780
sides of the bridge and whether or not

00:25:11,490 --> 00:25:14,880
it's been transferred is actually

00:25:12,780 --> 00:25:17,040
incredibly important because once it's

00:25:14,880 --> 00:25:19,170
been transferred the format doesn't need

00:25:17,040 --> 00:25:20,730
to be as verbose we only need to send a

00:25:19,170 --> 00:25:25,650
very small amount of information once

00:25:20,730 --> 00:25:27,240
we've transferred it once so we are able

00:25:25,650 --> 00:25:29,010
to convert that div element over to a

00:25:27,240 --> 00:25:30,630
hydrate able node and you can see how we

00:25:29,010 --> 00:25:33,090
could take the same pattern and apply it

00:25:30,630 --> 00:25:34,740
to the rest of this Dom structure so now

00:25:33,090 --> 00:25:37,440
we're looking at a tree of entirely

00:25:34,740 --> 00:25:39,480
hydrate Abul nodes this structure is

00:25:37,440 --> 00:25:41,070
transferable between threads and allows

00:25:39,480 --> 00:25:45,660
us to send the information in an

00:25:41,070 --> 00:25:47,940
efficient way so let's look at an actual

00:25:45,660 --> 00:25:50,280
example here's a JSON representation of

00:25:47,940 --> 00:25:52,650
that interface I've got the node type

00:25:50,280 --> 00:25:54,590
here the node name child nodes that

00:25:52,650 --> 00:25:57,480
there's only a single child in this case

00:25:54,590 --> 00:25:59,910
and that unique identifier our index and

00:25:57,480 --> 00:26:01,950
transferred false so something we've

00:25:59,910 --> 00:26:03,990
learned about web workers in this is

00:26:01,950 --> 00:26:07,020
that given the same complexity of your

00:26:03,990 --> 00:26:09,150
messages a smaller size transmits faster

00:26:07,020 --> 00:26:11,580
and is more responsive to end user input

00:26:09,150 --> 00:26:13,290
so we need to do some work too this

00:26:11,580 --> 00:26:15,270
means this format to ensure that it

00:26:13,290 --> 00:26:18,090
remains small independent of the number

00:26:15,270 --> 00:26:20,220
of nodes that you give it so we apply a

00:26:18,090 --> 00:26:20,980
substitution cipher which is just a

00:26:20,220 --> 00:26:24,340
fancy term for

00:26:20,980 --> 00:26:26,919
replacement to no name node the node

00:26:24,340 --> 00:26:28,990
type child nodes index and transferred

00:26:26,919 --> 00:26:31,720
these are all static keys that we

00:26:28,990 --> 00:26:34,059
restore and allow us to trim to convert

00:26:31,720 --> 00:26:38,980
over our object structure into keys

00:26:34,059 --> 00:26:40,630
based on the index of those strings next

00:26:38,980 --> 00:26:43,030
we have some false and throughs as

00:26:40,630 --> 00:26:45,220
values well those can be represented as

00:26:43,030 --> 00:26:49,210
zeros and ones so let's go ahead and do

00:26:45,220 --> 00:26:51,160
that and lastly we have now something we

00:26:49,210 --> 00:26:52,840
can't do at build time so all those

00:26:51,160 --> 00:26:54,820
other transformations could be done at

00:26:52,840 --> 00:26:58,450
build time because we know both sides of

00:26:54,820 --> 00:27:00,760
the equation at all times but your

00:26:58,450 --> 00:27:02,410
markup has different text in it your

00:27:00,760 --> 00:27:04,210
markup has different Dom nodes in it

00:27:02,410 --> 00:27:06,010
we can't bake in all of the possible

00:27:04,210 --> 00:27:08,500
string permutations that your code use

00:27:06,010 --> 00:27:09,910
so we create a string pool that will

00:27:08,500 --> 00:27:11,950
contain all of the strings that are

00:27:09,910 --> 00:27:13,780
needed for your application as you use

00:27:11,950 --> 00:27:15,760
them and we only transmit the parts of

00:27:13,780 --> 00:27:17,620
the pool that have not yet been received

00:27:15,760 --> 00:27:22,030
on both sides of the thread both sides

00:27:17,620 --> 00:27:24,040
of the threads so now we're able to

00:27:22,030 --> 00:27:26,559
represent this format in a fairly

00:27:24,040 --> 00:27:28,390
succinct way and you can see that we're

00:27:26,559 --> 00:27:30,549
getting closer and closer and closer to

00:27:28,390 --> 00:27:32,950
a pure integer representation of this

00:27:30,549 --> 00:27:35,110
structure in the future we'll be able to

00:27:32,950 --> 00:27:37,630
move this entirely to a typed array and

00:27:35,110 --> 00:27:39,700
that's where we will end up but for now

00:27:37,630 --> 00:27:45,070
we've got a fairly efficient format that

00:27:39,700 --> 00:27:46,090
has been very little overhead so now

00:27:45,070 --> 00:27:48,220
that we've got this format for

00:27:46,090 --> 00:27:49,929
individual hydrator we'll nodes we need

00:27:48,220 --> 00:27:53,020
to be able to look at what the interface

00:27:49,929 --> 00:27:54,520
for hydration itself looks like a little

00:27:53,020 --> 00:27:59,040
bit more complex and that we have to

00:27:54,520 --> 00:28:01,450
pass that string pull over next mutation

00:27:59,040 --> 00:28:03,940
static document would be extremely

00:28:01,450 --> 00:28:05,110
boring if that was all we could do we

00:28:03,940 --> 00:28:10,840
need to be able to respond to those

00:28:05,110 --> 00:28:12,700
input events here we have a span that we

00:28:10,840 --> 00:28:13,570
created and a click event listener

00:28:12,700 --> 00:28:15,640
that's attached to it

00:28:13,570 --> 00:28:17,919
when that happens we were able to then

00:28:15,640 --> 00:28:21,669
use the classlist Dom token list method

00:28:17,919 --> 00:28:23,679
to toggle a class name as well as change

00:28:21,669 --> 00:28:26,650
the style of a different div that is not

00:28:23,679 --> 00:28:29,220
defined in this example how does this

00:28:26,650 --> 00:28:31,659
work well we use a mutation observer and

00:28:29,220 --> 00:28:33,190
because we built the Dom implementation

00:28:31,659 --> 00:28:34,670
we could build our own mutation observer

00:28:33,190 --> 00:28:36,500
which has super powers

00:28:34,670 --> 00:28:39,140
so instead of just being able to modify

00:28:36,500 --> 00:28:40,730
things like attribute changes or changes

00:28:39,140 --> 00:28:44,480
to the tree structure we can also

00:28:40,730 --> 00:28:45,950
observe things like value changes so we

00:28:44,480 --> 00:28:50,300
know property changes not just

00:28:45,950 --> 00:28:52,040
attributes there was a lot of

00:28:50,300 --> 00:28:57,710
information so we had to steal Laurie's

00:28:52,040 --> 00:28:59,840
joke we're not actually gonna do it

00:28:57,710 --> 00:29:03,490
because Laurie did it I just wanted to

00:28:59,840 --> 00:29:05,480
emphasize I just want to emphasize that

00:29:03,490 --> 00:29:07,880
we talked about how it works because

00:29:05,480 --> 00:29:09,260
it's interesting but one of the magical

00:29:07,880 --> 00:29:10,490
things about work Radames I was like

00:29:09,260 --> 00:29:13,250
looking at the readme and like where's

00:29:10,490 --> 00:29:17,000
the usage statement and it doesn't have

00:29:13,250 --> 00:29:18,110
one right like the you just make a

00:29:17,000 --> 00:29:19,820
worker and then you say like

00:29:18,110 --> 00:29:21,680
document.getelementbyid e or you make

00:29:19,820 --> 00:29:23,300
your react component right like it's it

00:29:21,680 --> 00:29:25,310
doesn't have an API because it's just

00:29:23,300 --> 00:29:26,980
the Dom API and the web worker so I

00:29:25,310 --> 00:29:29,600
think that's actually kind of cool

00:29:26,980 --> 00:29:37,310
speaking of which do we want to like

00:29:29,600 --> 00:29:40,780
show a demo so we're kind of short on

00:29:37,310 --> 00:29:43,910
time and so what I'm gonna do is

00:29:40,780 --> 00:29:46,040
something akin to this meme I love this

00:29:43,910 --> 00:29:49,910
one we're gonna start with the left and

00:29:46,040 --> 00:29:51,620
we're gonna move to the owl quickly all

00:29:49,910 --> 00:29:53,540
right I've got some demos here so the

00:29:51,620 --> 00:29:56,060
first one that we'll go into is a

00:29:53,540 --> 00:29:57,290
vanilla Dom implementation so this is

00:29:56,060 --> 00:29:59,390
actually the example we talked about

00:29:57,290 --> 00:30:01,400
during the slides so we've got hello

00:29:59,390 --> 00:30:02,690
world as a text node a span with some

00:30:01,400 --> 00:30:05,300
text inside of it and an input element

00:30:02,690 --> 00:30:06,860
as I click here you can see changes

00:30:05,300 --> 00:30:09,410
occurring this is the least glamorous

00:30:06,860 --> 00:30:12,350
demo ever however believe me all of this

00:30:09,410 --> 00:30:14,690
is happening in a worker now if I come

00:30:12,350 --> 00:30:19,520
here I can type remove and we'll remove

00:30:14,690 --> 00:30:22,640
a node next demo that wasn't very

00:30:19,520 --> 00:30:24,530
impressive this can't possibly be fast

00:30:22,640 --> 00:30:26,210
right we're having to serialize up a

00:30:24,530 --> 00:30:26,780
bunch of information transfer between

00:30:26,210 --> 00:30:28,850
threads

00:30:26,780 --> 00:30:30,500
I thought we'd show something that kind

00:30:28,850 --> 00:30:32,630
of pushes the boundaries of what right

00:30:30,500 --> 00:30:35,030
performance of the web would be like so

00:30:32,630 --> 00:30:37,130
we built a DB Mon implementation if

00:30:35,030 --> 00:30:39,500
you're familiar with like which'll Dom

00:30:37,130 --> 00:30:40,930
frameworks they all implement DB Mon to

00:30:39,500 --> 00:30:43,610
like show how awesome and fast they are

00:30:40,930 --> 00:30:45,590
I don't know if this is fast or not

00:30:43,610 --> 00:30:47,180
compared to some other frameworks but it

00:30:45,590 --> 00:30:48,000
certainly seems to work well on low-end

00:30:47,180 --> 00:30:50,280
devices

00:30:48,000 --> 00:30:53,300
and just to show that this is not

00:30:50,280 --> 00:30:56,070
cheating we'll do a little record and

00:30:53,300 --> 00:30:58,290
let's sneak in at the actual snapshot at

00:30:56,070 --> 00:31:00,120
work you can see we're fairly close to

00:30:58,290 --> 00:31:02,820
60 frames per second across the board

00:31:00,120 --> 00:31:05,190
and the code is split directly across

00:31:02,820 --> 00:31:06,660
the main thread here and the worker

00:31:05,190 --> 00:31:08,520
thread the worker thread is running the

00:31:06,660 --> 00:31:10,260
entirety of our JavaScript framework in

00:31:08,520 --> 00:31:13,140
this case and that's highlighted by

00:31:10,260 --> 00:31:15,300
these kind of light pink categorizations

00:31:13,140 --> 00:31:16,470
and the browser is doing its work in the

00:31:15,300 --> 00:31:22,160
main thread and you can see that by

00:31:16,470 --> 00:31:22,160
these large purple and green streaks

00:31:22,340 --> 00:31:26,790
fantastic so we wanted to ensure that

00:31:25,620 --> 00:31:28,140
this framework earned that this

00:31:26,790 --> 00:31:29,760
technology would work with many

00:31:28,140 --> 00:31:31,950
different frameworks not just one or the

00:31:29,760 --> 00:31:33,930
other so we implemented the exact same

00:31:31,950 --> 00:31:37,860
application and both pre act and react

00:31:33,930 --> 00:31:39,720
this is a fake mapping diagram from some

00:31:37,860 --> 00:31:43,950
data that I found on the internet a very

00:31:39,720 --> 00:31:46,740
abstract map and this is an SVG so as we

00:31:43,950 --> 00:31:50,070
modify this we're able to make mutations

00:31:46,740 --> 00:31:51,810
to the to the SVG graphic across the

00:31:50,070 --> 00:31:52,380
bridge and that example is running

00:31:51,810 --> 00:31:54,750
pre-act

00:31:52,380 --> 00:31:57,750
let's do the same example but in react

00:31:54,750 --> 00:31:58,560
and everything seems to still work by

00:31:57,750 --> 00:32:01,980
the way this is running the latest

00:31:58,560 --> 00:32:03,270
version of react I'm certain there's

00:32:01,980 --> 00:32:06,390
some new things there that I were

00:32:03,270 --> 00:32:08,430
supposed to be pretty cool lastly I

00:32:06,390 --> 00:32:09,870
thought I'd do an example of to do MVC

00:32:08,430 --> 00:32:11,520
since that seems to be the canonical

00:32:09,870 --> 00:32:14,040
thing people show when they are

00:32:11,520 --> 00:32:16,680
demonstrating a new technology this to

00:32:14,040 --> 00:32:21,900
do MVC implementation works pretty well

00:32:16,680 --> 00:32:24,570
if I can actually type and this is like

00:32:21,900 --> 00:32:27,660
not to video to do MVC written for

00:32:24,570 --> 00:32:30,090
worker Dom is just to do MVC running

00:32:27,660 --> 00:32:32,400
inside a worker Dom and I can go ahead

00:32:30,090 --> 00:32:34,620
and remove an item and you very barely

00:32:32,400 --> 00:32:37,790
see that there is the item count is

00:32:34,620 --> 00:32:44,760
updating and Dom nodes are being removed

00:32:37,790 --> 00:32:45,320
okay great all right so can can you try

00:32:44,760 --> 00:32:48,900
this

00:32:45,320 --> 00:32:52,970
yes worker Dom we just became available

00:32:48,900 --> 00:32:52,970
on github and NPM a few minutes ago

00:32:58,430 --> 00:33:06,660
it is still very alpha s software he

00:33:03,630 --> 00:33:09,600
goes I think our main goal is not so

00:33:06,660 --> 00:33:11,210
like all of you go run and use this in

00:33:09,600 --> 00:33:15,060
your production application please don't

00:33:11,210 --> 00:33:16,350
eventually do especially and I know lots

00:33:15,060 --> 00:33:17,850
of you are here if you maintain a

00:33:16,350 --> 00:33:19,980
framework of build tool we really want

00:33:17,850 --> 00:33:21,480
to make sure that they work together

00:33:19,980 --> 00:33:23,160
with worker Dom that there's no missing

00:33:21,480 --> 00:33:26,460
features and but you know some of the

00:33:23,160 --> 00:33:27,720
problems might be might be solved I also

00:33:26,460 --> 00:33:30,120
want to talk about the quick I still

00:33:27,720 --> 00:33:34,260
like why we like personally building

00:33:30,120 --> 00:33:37,350
this so we are working on project or

00:33:34,260 --> 00:33:39,930
vocal amp and our goal with worker Dom

00:33:37,350 --> 00:33:42,150
is to allow authors of M documents to

00:33:39,930 --> 00:33:43,890
run their own JavaScript in amp

00:33:42,150 --> 00:33:46,380
documents which he currently can't and

00:33:43,890 --> 00:33:49,230
that's terrible it's not like JavaScript

00:33:46,380 --> 00:33:50,850
and so we all use worker down to do this

00:33:49,230 --> 00:33:52,620
and I think this is important for an

00:33:50,850 --> 00:33:54,930
open source project so because it's

00:33:52,620 --> 00:33:58,020
alpha today but we will make it rock

00:33:54,930 --> 00:34:00,270
solid for this use case and so it's

00:33:58,020 --> 00:34:02,910
usable for everyone else's and there are

00:34:00,270 --> 00:34:04,170
non amp webpages as well yeah and that's

00:34:02,910 --> 00:34:06,690
really all we had thank you very much

00:34:04,170 --> 00:34:08,360
here's the link to github the slides a

00:34:06,690 --> 00:34:18,840
blog post the Christopher

00:34:08,360 --> 00:34:18,840

YouTube URL: https://www.youtube.com/watch?v=XyVQfqmx2CI


