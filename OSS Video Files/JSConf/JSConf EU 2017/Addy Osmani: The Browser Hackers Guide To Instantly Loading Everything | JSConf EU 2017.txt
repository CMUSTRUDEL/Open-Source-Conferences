Title: Addy Osmani: The Browser Hackers Guide To Instantly Loading Everything | JSConf EU 2017
Publication date: 2017-05-25
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/addy-osmani-the-browser-hackers-guide-to-instantly-loading-everything.html

Venture deep into the belly of the browser to uncover the secret incantations to instantly load anything. Weâ€™ll even back it up with rock-hard data. Will we use preload, prefetch and preconnect? What about HTTP/2 Server Push? or Service Worker? and how the heck do we ship JavaScript bundles that donâ€™t break the bank on mobile? Discover this and more tips to delight your users in the Browser Hackerâ€™s guide to instantly loading EVERYTHING.
Captions: 
	00:00:00,110 --> 00:00:27,559
[Music]

00:00:38,530 --> 00:00:44,420
I'm sorry this conferences loves video

00:00:41,060 --> 00:00:47,739
effects I've gotta got to do it alright

00:00:44,420 --> 00:00:53,570
so today we're going to talk about

00:00:47,739 --> 00:00:57,290
loading on the web loading is a user

00:00:53,570 --> 00:00:59,660
journey with very disparate expectations

00:00:57,290 --> 00:01:01,070
you're basically sending thousands and

00:00:59,660 --> 00:01:03,320
thousands of bytes down the wire and

00:01:01,070 --> 00:01:05,150
hoping that whatever comes out from the

00:01:03,320 --> 00:01:07,250
very end of that is something that's

00:01:05,150 --> 00:01:08,659
actually useful to your users and helps

00:01:07,250 --> 00:01:10,880
them interact with your applications

00:01:08,659 --> 00:01:12,409
relatively quickly so I thought that

00:01:10,880 --> 00:01:15,920
today we'd have a conversation about

00:01:12,409 --> 00:01:17,240
loading now we can really have a

00:01:15,920 --> 00:01:18,770
conversation about loading without

00:01:17,240 --> 00:01:21,500
talking about where we're at right now

00:01:18,770 --> 00:01:23,990
so this is what the average web page on

00:01:21,500 --> 00:01:25,700
mobile looks like in 2017

00:01:23,990 --> 00:01:27,920
whether it's built with sort of a

00:01:25,700 --> 00:01:31,040
JavaScript framework or just a static

00:01:27,920 --> 00:01:33,560
site in many cases it takes 16 seconds

00:01:31,040 --> 00:01:37,009
to get interactive on a real mobile

00:01:33,560 --> 00:01:39,740
device on 3G usually takes 19 seconds to

00:01:37,009 --> 00:01:41,479
be fully loaded and people mostly send

00:01:39,740 --> 00:01:43,430
you know somewhere in the region of 420

00:01:41,479 --> 00:01:46,100
450 kilobytes of JavaScript down the

00:01:43,430 --> 00:01:48,500
wire and why does any of this actually

00:01:46,100 --> 00:01:50,270
matter well if we take a look at a high

00:01:48,500 --> 00:01:52,909
level and how the browser actually

00:01:50,270 --> 00:01:54,500
manages to get anything render to the

00:01:52,909 --> 00:01:56,630
screen from the network it's a

00:01:54,500 --> 00:01:59,630
relatively simple process we send a

00:01:56,630 --> 00:02:01,909
request out server returns an HTML we go

00:01:59,630 --> 00:02:03,109
and we parse the CSS and JavaScript and

00:02:01,909 --> 00:02:04,729
images and anything else that comes back

00:02:03,109 --> 00:02:06,829
and then we actually have to parse

00:02:04,729 --> 00:02:08,720
compile and render that code in order to

00:02:06,829 --> 00:02:11,900
render and turn onto pixels on the

00:02:08,720 --> 00:02:16,220
screen right but it's never quite that

00:02:11,900 --> 00:02:18,890
simple we're usually developing on

00:02:16,220 --> 00:02:21,530
relatively powerful high-end desktop

00:02:18,890 --> 00:02:23,210
machines and the expectations that we

00:02:21,530 --> 00:02:25,400
have when we're profiling there are

00:02:23,210 --> 00:02:26,330
quite different to mobile particularly

00:02:25,400 --> 00:02:28,550
when it comes to things like JavaScript

00:02:26,330 --> 00:02:29,840
startup performance where on a real

00:02:28,550 --> 00:02:31,730
world mobile device you can end up

00:02:29,840 --> 00:02:35,240
seeing anywhere between 4 and 5 times

00:02:31,730 --> 00:02:37,280
with a slowdown so the first thing I

00:02:35,240 --> 00:02:39,740
think that we as a community need to

00:02:37,280 --> 00:02:42,450
shift worth doing is actually testing on

00:02:39,740 --> 00:02:43,680
real phones and real networks

00:02:42,450 --> 00:02:44,970
I know there are a bunch of people so

00:02:43,680 --> 00:02:47,790
how many people here actually used like

00:02:44,970 --> 00:02:49,860
the dev tools network emulation or CPU

00:02:47,790 --> 00:02:51,390
throttling or device node so a lot of

00:02:49,860 --> 00:02:53,190
people here that's great that's a great

00:02:51,390 --> 00:02:55,319
first step we need to do better than

00:02:53,190 --> 00:02:57,240
that though because mobile devices have

00:02:55,319 --> 00:02:58,770
got different GPUs different CPUs

00:02:57,240 --> 00:03:00,720
different memory different battery

00:02:58,770 --> 00:03:02,819
characteristics so there's a lot that we

00:03:00,720 --> 00:03:04,440
can do there for people that want to

00:03:02,819 --> 00:03:06,800
start doing that today we recently

00:03:04,440 --> 00:03:09,870
shipped the new part of webpagetest.org

00:03:06,800 --> 00:03:12,330
called slash easy so webpagetest.org

00:03:09,870 --> 00:03:13,770
slash easy has got a whole farm of

00:03:12,330 --> 00:03:15,870
average mobile devices on there right

00:03:13,770 --> 00:03:18,450
now with easy profiles for going and

00:03:15,870 --> 00:03:20,130
checking out your performance now a lot

00:03:18,450 --> 00:03:21,630
of the time we talk about mobile

00:03:20,130 --> 00:03:24,269
performance these days we reference this

00:03:21,630 --> 00:03:26,280
idea of time to interactive and the idea

00:03:24,269 --> 00:03:27,660
there is that you're just able to make

00:03:26,280 --> 00:03:29,069
sure that the user can actually tap

00:03:27,660 --> 00:03:32,160
around your interface and how something

00:03:29,069 --> 00:03:33,569
useful actually happen in this case I

00:03:32,160 --> 00:03:34,980
think that someone is going through like

00:03:33,569 --> 00:03:36,690
a withdrawal symptom because there isn't

00:03:34,980 --> 00:03:40,800
actually anything on their phone looks a

00:03:36,690 --> 00:03:42,239
little bit dead so there are a few rules

00:03:40,800 --> 00:03:43,890
that I like to follow and I'm building

00:03:42,239 --> 00:03:46,019
modern web apps that try to load

00:03:43,890 --> 00:03:48,299
efficiently the first is only load what

00:03:46,019 --> 00:03:49,860
you need so trying to make sure that if

00:03:48,299 --> 00:03:51,239
you're shipping script and CSS and

00:03:49,860 --> 00:03:52,290
everything else down the wire that it's

00:03:51,239 --> 00:03:54,360
only the things that are going to

00:03:52,290 --> 00:03:56,880
actually be useful to the users initial

00:03:54,360 --> 00:03:59,700
experience that you're using idle time

00:03:56,880 --> 00:04:01,410
to load in anything else so your comment

00:03:59,700 --> 00:04:02,549
threads any additional pages that might

00:04:01,410 --> 00:04:04,320
be needed for the rest of the user

00:04:02,549 --> 00:04:06,360
experience now there are a lot of things

00:04:04,320 --> 00:04:09,180
that we can do to actually help load

00:04:06,360 --> 00:04:10,829
less code one of the first things is

00:04:09,180 --> 00:04:12,180
code splitting so code splitting

00:04:10,829 --> 00:04:14,459
something that a lot of you probably are

00:04:12,180 --> 00:04:16,440
familiar with as a concept relatively

00:04:14,459 --> 00:04:18,359
straightforward get set up using webpack

00:04:16,440 --> 00:04:20,310
were split able or closure compiler or

00:04:18,359 --> 00:04:22,950
browserify the basic idea is that

00:04:20,310 --> 00:04:24,660
instead of like making your user eat an

00:04:22,950 --> 00:04:26,190
entire pizza and get really bloated you

00:04:24,660 --> 00:04:28,470
just give them a single piece at a time

00:04:26,190 --> 00:04:29,760
and that way hopefully they feel you

00:04:28,470 --> 00:04:31,250
know a little bit better about the

00:04:29,760 --> 00:04:33,780
experience that you're shipping down

00:04:31,250 --> 00:04:35,669
tree-shaking so removing unused exports

00:04:33,780 --> 00:04:38,400
using things like roll-up also worth

00:04:35,669 --> 00:04:41,160
spending time on something we don't talk

00:04:38,400 --> 00:04:42,810
about enough is the fact that the

00:04:41,160 --> 00:04:45,080
baselines we're using when we're trying

00:04:42,810 --> 00:04:47,640
to ship powerful experiences on mobile

00:04:45,080 --> 00:04:50,460
don't always set us up for success today

00:04:47,640 --> 00:04:52,680
so if a framework for example and I love

00:04:50,460 --> 00:04:54,419
I love frameworks I created two MVC ela

00:04:52,680 --> 00:04:54,620
frameworks I use like reactant view and

00:04:54,419 --> 00:04:56,660
free

00:04:54,620 --> 00:04:59,540
all the time but the frameworks that we

00:04:56,660 --> 00:05:01,790
use today are often built with desktop

00:04:59,540 --> 00:05:03,410
machines in mind and when it comes to

00:05:01,790 --> 00:05:04,580
actually trying them out on mobile if

00:05:03,410 --> 00:05:06,380
we're saying you've got to be

00:05:04,580 --> 00:05:08,330
interactive in like five seconds and

00:05:06,380 --> 00:05:09,919
your framework is beating up like four

00:05:08,330 --> 00:05:11,600
seconds of that and it's do it at time

00:05:09,919 --> 00:05:13,370
that's not setting you up for success so

00:05:11,600 --> 00:05:15,020
there's probably room that we've got to

00:05:13,370 --> 00:05:17,090
improve there there are lots of

00:05:15,020 --> 00:05:19,340
lightweight options today pre-act view

00:05:17,090 --> 00:05:20,690
svelte polymer there are lots of others

00:05:19,340 --> 00:05:23,930
they generally have a relatively though

00:05:20,690 --> 00:05:25,190
parsing startup time over on the dev

00:05:23,930 --> 00:05:27,320
tools side one of the things that we

00:05:25,190 --> 00:05:29,210
recently shipped to help you with this

00:05:27,320 --> 00:05:31,789
idea of shipping less code is a feature

00:05:29,210 --> 00:05:34,580
called code coverage the idea here is

00:05:31,789 --> 00:05:36,440
that you just load up you're out you hit

00:05:34,580 --> 00:05:38,630
record in this new item in the drawer

00:05:36,440 --> 00:05:40,220
and then we tell you what blocks of code

00:05:38,630 --> 00:05:42,560
actually got executed and which ones

00:05:40,220 --> 00:05:44,300
didn't so here we've got sort of an

00:05:42,560 --> 00:05:46,400
indication that maybe you know I'm not

00:05:44,300 --> 00:05:48,139
really using 50% of the code in the

00:05:46,400 --> 00:05:49,550
bundle that I'm shipping down and as we

00:05:48,139 --> 00:05:51,410
click on that and scroll through the

00:05:49,550 --> 00:05:53,000
sources panel you can see that we

00:05:51,410 --> 00:05:55,370
highlight in green code that got

00:05:53,000 --> 00:05:56,840
executed and red code that didn't in

00:05:55,370 --> 00:05:58,669
this case because this is a camera app

00:05:56,840 --> 00:06:00,950
I've got a lot of code for actually

00:05:58,669 --> 00:06:02,900
doing cross browser saving a file to an

00:06:00,950 --> 00:06:05,570
export so I can probably be lazily

00:06:02,900 --> 00:06:07,099
loading in other things we can do like

00:06:05,570 --> 00:06:09,440
most of us here probably using a

00:06:07,099 --> 00:06:11,000
transpiler of some sort to use all the

00:06:09,440 --> 00:06:13,070
juicy new features javascript has got

00:06:11,000 --> 00:06:15,380
but the reality is that you know cross

00:06:13,070 --> 00:06:17,000
browser es2015 support is in a

00:06:15,380 --> 00:06:18,620
relatively good place right now we don't

00:06:17,000 --> 00:06:21,229
always need to be you know sending

00:06:18,620 --> 00:06:23,270
people down es5 so if you're shipping an

00:06:21,229 --> 00:06:25,610
experience using babel today i strongly

00:06:23,270 --> 00:06:27,740
encourage you to try out babel preset

00:06:25,610 --> 00:06:30,169
ends this will basically only transpile

00:06:27,740 --> 00:06:31,880
code for the browsers that need it and

00:06:30,169 --> 00:06:34,639
just keep everything else in es2015

00:06:31,880 --> 00:06:37,310
let's check that out if you happen to be

00:06:34,639 --> 00:06:39,470
using low - check out babel plugin low -

00:06:37,310 --> 00:06:41,360
this is sort of a neat transform that

00:06:39,470 --> 00:06:42,770
will rewrite your low - code so it only

00:06:41,360 --> 00:06:44,300
uses the modules that you're actually

00:06:42,770 --> 00:06:48,229
using in your source rather than the

00:06:44,300 --> 00:06:50,180
entire package so check that out - this

00:06:48,229 --> 00:06:50,750
week we also announced after a very long

00:06:50,180 --> 00:06:54,580
wait

00:06:50,750 --> 00:06:57,620
support for es2015 modules in chrome

00:06:54,580 --> 00:06:59,539
thank you this is something that will

00:06:57,620 --> 00:07:01,610
hopefully encourage again a little bit

00:06:59,539 --> 00:07:02,570
less transformation and is something

00:07:01,610 --> 00:07:03,919
that will open up a few more

00:07:02,570 --> 00:07:06,200
opportunities for interesting loading

00:07:03,919 --> 00:07:07,190
experiences across the board the next

00:07:06,200 --> 00:07:10,460
thing I like to do

00:07:07,190 --> 00:07:12,230
is order loading thoughtfully you know

00:07:10,460 --> 00:07:13,430
more than anybody else in the stack you

00:07:12,230 --> 00:07:15,650
know what is important to your user

00:07:13,430 --> 00:07:17,960
journey and what needs to be sent down

00:07:15,650 --> 00:07:19,970
earlier on than anything else something

00:07:17,960 --> 00:07:21,530
that we recently also shipped in dev

00:07:19,970 --> 00:07:24,050
tools to help with this is a feature

00:07:21,530 --> 00:07:26,240
called network request blocking that's

00:07:24,050 --> 00:07:28,520
in canary right now the idea here is

00:07:26,240 --> 00:07:30,890
that in the network waterfall for any

00:07:28,520 --> 00:07:32,900
site you can right-click on a network

00:07:30,890 --> 00:07:34,670
request and you can block it or you can

00:07:32,900 --> 00:07:36,890
block the domain and take a look at what

00:07:34,670 --> 00:07:38,630
impact that has on the overall critical

00:07:36,890 --> 00:07:39,800
path of your site I'm particularly

00:07:38,630 --> 00:07:42,310
useful if you've got a lot of

00:07:39,800 --> 00:07:44,660
third-party code that's slowing you down

00:07:42,310 --> 00:07:47,150
and finally cache aggressively and

00:07:44,660 --> 00:07:49,430
granularly cache as much as you can

00:07:47,150 --> 00:07:51,650
locally that's both with HTTP cache but

00:07:49,430 --> 00:07:54,260
also using serviceworker caching at

00:07:51,650 --> 00:07:55,790
Google we've been trying to ramp up our

00:07:54,260 --> 00:07:58,640
investment in serviceworker for a lot of

00:07:55,790 --> 00:08:01,190
our flagship apps inbox has been using

00:07:58,640 --> 00:08:03,680
serviceworker quite a lot and recently

00:08:01,190 --> 00:08:05,120
saw a 10% improvement in time to

00:08:03,680 --> 00:08:06,830
interactive just by making sure that

00:08:05,120 --> 00:08:11,450
they're using it for things like static

00:08:06,830 --> 00:08:15,260
resource caching now about three years

00:08:11,450 --> 00:08:16,760
ago I was speaking at CSS comp and we

00:08:15,260 --> 00:08:19,130
spent the whole talk sort of optimizing

00:08:16,760 --> 00:08:20,570
jazz comp that you and I thought you

00:08:19,130 --> 00:08:22,720
know given that I'm back here it'd be

00:08:20,570 --> 00:08:27,140
kind of fun to do that again at a much

00:08:22,720 --> 00:08:30,020
shorter rate but also a little bit may

00:08:27,140 --> 00:08:33,110
be unorthodox plea so what we're going

00:08:30,020 --> 00:08:35,000
to do is we're going to hack chrome to

00:08:33,110 --> 00:08:35,570
make j/s confi you load a little bit

00:08:35,000 --> 00:08:37,430
faster

00:08:35,570 --> 00:08:39,680
this guy's not in fact a hacker he's

00:08:37,430 --> 00:08:43,000
just like scrolling through his web pack

00:08:39,680 --> 00:08:47,750
on fake or something

00:08:43,000 --> 00:08:49,400
so you dive into C++ in chrome and you

00:08:47,750 --> 00:08:50,750
find this file called resource fetcher

00:08:49,400 --> 00:08:52,250
and resource fetcher is one of these

00:08:50,750 --> 00:08:54,080
files I know nobody can see this so

00:08:52,250 --> 00:08:56,420
let's just zoom in here this is one of

00:08:54,080 --> 00:08:58,100
these files that define how chrome

00:08:56,420 --> 00:09:00,650
actually handles the prioritization for

00:08:58,100 --> 00:09:03,470
different types of resources so your CSS

00:09:00,650 --> 00:09:05,030
your JavaScript your images I don't

00:09:03,470 --> 00:09:06,850
expect anybody to read this so here's

00:09:05,030 --> 00:09:10,190
the table of how we actually handle this

00:09:06,850 --> 00:09:12,650
layout blocking resources like CSS and

00:09:10,190 --> 00:09:14,600
fonts get the highest priority load in

00:09:12,650 --> 00:09:17,510
layout blocking phase resources like

00:09:14,600 --> 00:09:20,330
scripts or images that happens being the

00:09:17,510 --> 00:09:21,080
viewport get a medium priority and then

00:09:20,330 --> 00:09:23,330
everything from your

00:09:21,080 --> 00:09:25,520
basing scripts to images that are

00:09:23,330 --> 00:09:27,410
outside of the viewport mismatch CSS

00:09:25,520 --> 00:09:29,300
they get a much much lower priority

00:09:27,410 --> 00:09:31,790
what's interesting about this table

00:09:29,300 --> 00:09:33,890
actually is that images in your viewport

00:09:31,790 --> 00:09:35,210
get a medium priority and stuff that's

00:09:33,890 --> 00:09:37,010
outside of they get a lower one so we

00:09:35,210 --> 00:09:40,880
kind of do automatic lazy loading of

00:09:37,010 --> 00:09:42,530
images to some extent by default that's

00:09:40,880 --> 00:09:44,060
great but as a developer you probably

00:09:42,530 --> 00:09:46,100
care more about where this is exposed

00:09:44,060 --> 00:09:47,750
for you so in the network panel there's

00:09:46,100 --> 00:09:49,340
a column called priority that will tell

00:09:47,750 --> 00:09:51,440
you exactly what we're already was used

00:09:49,340 --> 00:09:54,920
for any of the resources that you wanted

00:09:51,440 --> 00:09:55,880
to load so we're back here and the part

00:09:54,920 --> 00:09:56,600
of chrome that we're going to hack is

00:09:55,880 --> 00:09:59,060
we're actually going to change

00:09:56,600 --> 00:10:01,430
absolutely every single type of resource

00:09:59,060 --> 00:10:03,800
to load with an extremely high priority

00:10:01,430 --> 00:10:07,130
it sounds like a great idea right so

00:10:03,800 --> 00:10:10,340
let's let's do that and that's going to

00:10:07,130 --> 00:10:13,310
fix all of our problems and I can just

00:10:10,340 --> 00:10:15,860
end the talk there right we could ship a

00:10:13,310 --> 00:10:17,390
new browser we could call it so I

00:10:15,860 --> 00:10:19,730
discovered Germany it's got this

00:10:17,390 --> 00:10:23,750
wonderful world called vers lemon

00:10:19,730 --> 00:10:26,180
discern which that's a terrible

00:10:23,750 --> 00:10:27,890
pronunciation but it means when you try

00:10:26,180 --> 00:10:32,900
to fix something but you actually made

00:10:27,890 --> 00:10:34,790
it a whole lot worse and I did so this

00:10:32,900 --> 00:10:36,080
is the original filmstrip for a jazz

00:10:34,790 --> 00:10:37,700
talk to you and this is what it looks

00:10:36,080 --> 00:10:39,170
like when everything is considered high

00:10:37,700 --> 00:10:41,270
priority we've actually completely

00:10:39,170 --> 00:10:45,020
shifted first meaningful paint way back

00:10:41,270 --> 00:10:46,280
performance is worse lesson there when

00:10:45,020 --> 00:10:50,270
everything is high priority

00:10:46,280 --> 00:10:51,470
nothing is and I ended up fixing this by

00:10:50,270 --> 00:10:52,730
going through the different types of

00:10:51,470 --> 00:10:54,050
resources that are used in this

00:10:52,730 --> 00:10:56,090
particular page and trying to figure out

00:10:54,050 --> 00:10:58,130
okay well are the image of the most

00:10:56,090 --> 00:11:01,190
important things the CSS and as it turns

00:10:58,130 --> 00:11:03,500
out it was the CSS and fonts so let's do

00:11:01,190 --> 00:11:05,150
this right by the browser we talked

00:11:03,500 --> 00:11:07,760
already about sort of at the high level

00:11:05,150 --> 00:11:09,560
how never for process work but there's a

00:11:07,760 --> 00:11:11,720
piece of this puzzle that I didn't quite

00:11:09,560 --> 00:11:14,630
dive into and that's the browser preload

00:11:11,720 --> 00:11:17,060
scanner now browsers like Chrome have

00:11:14,630 --> 00:11:18,470
got a document parser and as we go

00:11:17,060 --> 00:11:19,700
through the tokenization phase of

00:11:18,470 --> 00:11:21,520
actually reading through all the

00:11:19,700 --> 00:11:24,290
different tokens that compose your HTML

00:11:21,520 --> 00:11:26,060
we will go and try to fetch those

00:11:24,290 --> 00:11:28,310
resources and start processing them if

00:11:26,060 --> 00:11:30,590
we run into like a blocking script

00:11:28,310 --> 00:11:32,630
that's going to stop the document parser

00:11:30,590 --> 00:11:34,300
in its tracks which is why we have the

00:11:32,630 --> 00:11:36,280
sort of fallback thing that

00:11:34,300 --> 00:11:39,250
load scanner which is able to look ahead

00:11:36,280 --> 00:11:42,010
even when the you know dr. MacArthur is

00:11:39,250 --> 00:11:44,980
blocked and find other resources that we

00:11:42,010 --> 00:11:46,240
can continue to fetch and process when

00:11:44,980 --> 00:11:47,440
this change was first introduced in

00:11:46,240 --> 00:11:49,660
chrome I believe it introduced like a

00:11:47,440 --> 00:11:51,850
20% improvement over all the time so the

00:11:49,660 --> 00:11:53,440
preload scanner is pretty cool but we

00:11:51,850 --> 00:11:58,690
run into this other interesting

00:11:53,440 --> 00:12:01,510
challenge which is discovery no browser

00:11:58,690 --> 00:12:02,800
knows exactly what sequence of things to

00:12:01,510 --> 00:12:04,900
load to make sure that your page is

00:12:02,800 --> 00:12:06,790
going to be fast you more than anybody

00:12:04,900 --> 00:12:09,040
else again know what's important in your

00:12:06,790 --> 00:12:10,510
page whether it's your web pack bundles

00:12:09,040 --> 00:12:14,700
that need to be loaded early on or

00:12:10,510 --> 00:12:17,170
something else and so to address

00:12:14,700 --> 00:12:18,550
discoverability and the ability for you

00:12:17,170 --> 00:12:20,650
as an author to be able to say what you

00:12:18,550 --> 00:12:22,540
consider to be high priority you can use

00:12:20,650 --> 00:12:24,040
things like link rel preload which works

00:12:22,540 --> 00:12:26,080
with scripts and stylesheets and other

00:12:24,040 --> 00:12:27,790
types of resources and it's basically a

00:12:26,080 --> 00:12:29,800
declarative fetch that tells the browser

00:12:27,790 --> 00:12:33,280
that you consider something to be high

00:12:29,800 --> 00:12:35,500
priority now this is what the impact of

00:12:33,280 --> 00:12:37,510
using it on you know a site that happens

00:12:35,500 --> 00:12:39,220
to be using webpack looked like you

00:12:37,510 --> 00:12:42,130
you kind of shift all of the yellow

00:12:39,220 --> 00:12:44,740
that's on the right right all the way to

00:12:42,130 --> 00:12:46,780
the left at parse time I seeing this

00:12:44,740 --> 00:12:48,520
pattern being used increasingly in

00:12:46,780 --> 00:12:50,350
progressive web apps where it's having a

00:12:48,520 --> 00:12:52,720
positive impact on time to interactive

00:12:50,350 --> 00:12:54,700
for a lot of folks so I check that out

00:12:52,720 --> 00:12:56,230
if you're interested in actually hooking

00:12:54,700 --> 00:12:58,570
this up to your build process today I

00:12:56,230 --> 00:13:01,420
wrote a web pack plug-in called preload

00:12:58,570 --> 00:13:02,770
web pack plug-in they can do this for a

00:13:01,420 --> 00:13:04,450
synchronous chunks as well as like

00:13:02,770 --> 00:13:08,980
normal chunks so check it out if you

00:13:04,450 --> 00:13:11,350
find it interesting over on chrome the

00:13:08,980 --> 00:13:13,960
polymer team worked on an app a while

00:13:11,350 --> 00:13:15,700
ago called shop and the idea behind shop

00:13:13,960 --> 00:13:17,200
was trying to see you know if we if we

00:13:15,700 --> 00:13:18,640
use the web platform and the web

00:13:17,200 --> 00:13:21,040
platform features that are available to

00:13:18,640 --> 00:13:22,600
us today just how fast we make a modern

00:13:21,040 --> 00:13:25,360
web experience that was sort of

00:13:22,600 --> 00:13:28,240
non-trivial and shop kind of checked

00:13:25,360 --> 00:13:30,340
that off it was able to reach sort of

00:13:28,240 --> 00:13:31,900
granular loading you're able to tap on

00:13:30,340 --> 00:13:34,000
things and everything is just really

00:13:31,900 --> 00:13:36,160
nice and buttery smooth on mobile but

00:13:34,000 --> 00:13:37,660
how did they accomplish this so they

00:13:36,160 --> 00:13:40,390
used a pattern we came up with about

00:13:37,660 --> 00:13:42,970
last year called purple and the idea

00:13:40,390 --> 00:13:45,070
with purple is that you try to make sure

00:13:42,970 --> 00:13:46,990
that you're sending down the most

00:13:45,070 --> 00:13:48,579
important things for the user as early

00:13:46,990 --> 00:13:50,499
on as possible

00:13:48,579 --> 00:13:53,619
you push the minimal code needed for a

00:13:50,499 --> 00:13:56,800
route you render that route for next

00:13:53,619 --> 00:13:58,809
routes you're able to precache anything

00:13:56,800 --> 00:14:00,550
using service workers so that not only

00:13:58,809 --> 00:14:01,689
is that stuff already available locally

00:14:00,550 --> 00:14:03,550
in the disk cache when they try

00:14:01,689 --> 00:14:06,160
navigating to it but it's constantly

00:14:03,550 --> 00:14:08,889
available on repeat visits in addition

00:14:06,160 --> 00:14:12,759
for JavaScript using serviceworker we'll

00:14:08,889 --> 00:14:14,949
actually early on opt you into v8 code

00:14:12,759 --> 00:14:16,089
cache which will save you a little bit

00:14:14,949 --> 00:14:18,040
of time on things like parsing

00:14:16,089 --> 00:14:20,410
compilation and then the pattern

00:14:18,040 --> 00:14:22,499
suggests lazy loading code that you need

00:14:20,410 --> 00:14:24,189
for other parts of your user experience

00:14:22,499 --> 00:14:26,079
so let's take a look at what that

00:14:24,189 --> 00:14:28,269
actually looks like so this is um this

00:14:26,079 --> 00:14:32,139
is shop before any optimizations were

00:14:28,269 --> 00:14:36,220
applied you see sort of this this step

00:14:32,139 --> 00:14:39,549
pattern in the timeline this is a CB 2

00:14:36,220 --> 00:14:40,929
with 3G and remember that little block

00:14:39,549 --> 00:14:43,119
at the very start we're not actually

00:14:40,929 --> 00:14:46,059
seeing any any activity we're going to

00:14:43,119 --> 00:14:47,649
go back to that limit later with preload

00:14:46,059 --> 00:14:48,970
we actually changed the shape of that

00:14:47,649 --> 00:14:50,860
completely so we've gone from this to

00:14:48,970 --> 00:14:52,839
something looks like this basically

00:14:50,860 --> 00:14:55,209
we've shifted our time a little bit

00:14:52,839 --> 00:14:57,999
everything is now going to be attempting

00:14:55,209 --> 00:14:59,529
to load in parallel to some extent and

00:14:57,999 --> 00:15:00,819
that's start that starts shaving off

00:14:59,529 --> 00:15:03,579
some time over the overall user

00:15:00,819 --> 00:15:06,970
experience but it still comes with the

00:15:03,579 --> 00:15:09,309
cost of multiple round trips and this is

00:15:06,970 --> 00:15:10,480
where things like hb2 server push can

00:15:09,309 --> 00:15:13,360
actually come in useful

00:15:10,480 --> 00:15:15,610
now what push allows us to do is as an

00:15:13,360 --> 00:15:16,869
author specify using a manifest the

00:15:15,610 --> 00:15:20,350
files that we know are going to be

00:15:16,869 --> 00:15:22,119
critical to the user journey instead of

00:15:20,350 --> 00:15:24,519
just you know pushing down the request

00:15:22,119 --> 00:15:26,499
you know sending the browser some HTML

00:15:24,519 --> 00:15:28,480
with spending to be parsed when we send

00:15:26,499 --> 00:15:30,459
back that an is real HTML we can also

00:15:28,480 --> 00:15:32,410
start sending down a list of files that

00:15:30,459 --> 00:15:34,660
are super important to start fetching

00:15:32,410 --> 00:15:37,389
for the experience effectively we're

00:15:34,660 --> 00:15:38,889
filling up server think time we're today

00:15:37,389 --> 00:15:42,339
in a lot of cases we're not actually

00:15:38,889 --> 00:15:44,139
doing that so hey speed to server push

00:15:42,339 --> 00:15:46,179
is great for that and the impact that it

00:15:44,139 --> 00:15:47,860
had on this particular app was quite

00:15:46,179 --> 00:15:50,679
stark again we've shaved thousands of

00:15:47,860 --> 00:15:52,600
milliseconds off of the overall time for

00:15:50,679 --> 00:15:55,980
this app to get interactive and to load

00:15:52,600 --> 00:15:58,689
in general using this technique

00:15:55,980 --> 00:16:01,079
unfortunately hb2 server pushes not a

00:15:58,689 --> 00:16:03,959
silver bullet by any means

00:16:01,079 --> 00:16:05,490
it's not particularly Kasia we're in a

00:16:03,959 --> 00:16:07,680
perfect world we have the ability to

00:16:05,490 --> 00:16:09,959
have a cache digest or something that

00:16:07,680 --> 00:16:12,660
lets you know what exactly is in your

00:16:09,959 --> 00:16:14,519
user cache and so it's very easy to run

00:16:12,660 --> 00:16:16,440
into cases where you know every single

00:16:14,519 --> 00:16:18,300
time someone comes to your site you're

00:16:16,440 --> 00:16:20,160
just force pushing them you know the

00:16:18,300 --> 00:16:24,110
same set of files even if it's inside

00:16:20,160 --> 00:16:28,230
their cache which is not exactly ideal

00:16:24,110 --> 00:16:30,959
so push versus preload you know push can

00:16:28,230 --> 00:16:32,579
cut out a whole RCT it's not cache weird

00:16:30,959 --> 00:16:34,320
there's no real prioritization in place

00:16:32,579 --> 00:16:36,540
preload is particularly useful because

00:16:34,320 --> 00:16:38,459
in addition to what push can do it also

00:16:36,540 --> 00:16:40,320
you know sports cross-origin requests

00:16:38,459 --> 00:16:43,529
got load narrower events got content

00:16:40,320 --> 00:16:45,390
negotiation but how do we address this

00:16:43,529 --> 00:16:47,370
issue of h2 push not particularly

00:16:45,390 --> 00:16:49,079
knowing what's in the cache what we can

00:16:47,370 --> 00:16:51,089
use serviceworker if we have a

00:16:49,079 --> 00:16:52,860
serviceworker registered in such a way

00:16:51,089 --> 00:16:54,870
that instead of going to the network

00:16:52,860 --> 00:16:56,940
every single time that we need you know

00:16:54,870 --> 00:16:58,769
more resources to be fetched we're just

00:16:56,940 --> 00:17:01,200
trying to get them locally based on what

00:16:58,769 --> 00:17:03,720
is already cached we avoid this issue of

00:17:01,200 --> 00:17:09,270
needing cache digests and it makes this

00:17:03,720 --> 00:17:10,559
entire setup relatively sane for shop in

00:17:09,270 --> 00:17:12,480
particular this meant that on repeat

00:17:10,559 --> 00:17:14,130
visits once you tie absolutely

00:17:12,480 --> 00:17:15,780
everything in purple together you're

00:17:14,130 --> 00:17:17,370
actually able to boot up and get

00:17:15,780 --> 00:17:18,959
interactive in just a few hundred

00:17:17,370 --> 00:17:21,900
milliseconds it's quite a powerful

00:17:18,959 --> 00:17:23,280
pattern so preload is good for moving

00:17:21,900 --> 00:17:24,990
the start download time of an asset

00:17:23,280 --> 00:17:26,850
closer to the initial request and push

00:17:24,990 --> 00:17:28,230
is good for cutting out a full RTT if

00:17:26,850 --> 00:17:29,880
you have a serviceworker

00:17:28,230 --> 00:17:32,520
thanks to Sam Saucony for a bunch of the

00:17:29,880 --> 00:17:34,260
research that he did in this area the

00:17:32,520 --> 00:17:36,000
next thing I want to talk about is how a

00:17:34,260 --> 00:17:38,190
lot of this stuff can apply to the apps

00:17:36,000 --> 00:17:39,270
that you're probably building today out

00:17:38,190 --> 00:17:41,490
of interest how many people here are

00:17:39,270 --> 00:17:45,360
using react as a part of their default

00:17:41,490 --> 00:17:47,940
stack almost everybody or good good size

00:17:45,360 --> 00:17:49,890
the audience so I had the privilege of

00:17:47,940 --> 00:17:51,450
being able to work with Twitter on their

00:17:49,890 --> 00:17:53,370
new progressive web app Twitter light I

00:17:51,450 --> 00:17:55,740
wanted to talk a little bit about the

00:17:53,370 --> 00:17:57,630
learnings that we had there so Twitter

00:17:55,740 --> 00:17:59,520
started off with this which was their

00:17:57,630 --> 00:18:00,990
old mobile web experience and sort of

00:17:59,520 --> 00:18:03,630
the server-side render thing it was

00:18:00,990 --> 00:18:06,600
really really slow and it wasn't

00:18:03,630 --> 00:18:09,059
particularly happy didn't particularly

00:18:06,600 --> 00:18:10,950
encourage users to get engaging with the

00:18:09,059 --> 00:18:14,160
app this is the new progressive web app

00:18:10,950 --> 00:18:17,070
the Twitter shipped very very recently

00:18:14,160 --> 00:18:18,990
Twitter light and one of the

00:18:17,070 --> 00:18:20,250
accomplishments that they had by taking

00:18:18,990 --> 00:18:21,720
advantage of some of the primitives that

00:18:20,250 --> 00:18:23,280
we just talked about is that they're

00:18:21,720 --> 00:18:26,280
able to get interactive in under five

00:18:23,280 --> 00:18:28,530
seconds on 3G which is quite a nice feet

00:18:26,280 --> 00:18:30,780
now this didn't come without an amount

00:18:28,530 --> 00:18:32,820
of pain you know so you can use you know

00:18:30,780 --> 00:18:34,260
modern frameworks like react to shift

00:18:32,820 --> 00:18:36,300
aggressive web apps but you're going to

00:18:34,260 --> 00:18:37,800
have to put the work in to cut down on

00:18:36,300 --> 00:18:39,840
how much you know application code

00:18:37,800 --> 00:18:40,950
you've got going on there you're going

00:18:39,840 --> 00:18:42,090
to have to take advantage of code

00:18:40,950 --> 00:18:44,160
splitting you're going to have to make

00:18:42,090 --> 00:18:47,420
sure that you're just granularly loading

00:18:44,160 --> 00:18:50,280
and serving things in as well as you can

00:18:47,420 --> 00:18:52,710
so when Twitter first started working on

00:18:50,280 --> 00:18:54,150
this app early on they they had a

00:18:52,710 --> 00:18:56,160
relatively poor time to interactive

00:18:54,150 --> 00:18:58,140
score so they were looking at about 15

00:18:56,160 --> 00:18:59,400
16 milliseconds before anyone could

00:18:58,140 --> 00:19:01,830
actually start tapping around the

00:18:59,400 --> 00:19:05,610
interface so not too far away from where

00:19:01,830 --> 00:19:08,040
a lot of us probably are today most of

00:19:05,610 --> 00:19:10,560
their critical path was dominated by

00:19:08,040 --> 00:19:12,360
time spent in script just booting up and

00:19:10,560 --> 00:19:14,400
so they started taking a look at

00:19:12,360 --> 00:19:16,200
patterns like purple and and how they

00:19:14,400 --> 00:19:17,760
could take advantage of them the first

00:19:16,200 --> 00:19:20,010
thing they introduced was support for

00:19:17,760 --> 00:19:22,440
DNS prefetch so the ability to you know

00:19:20,010 --> 00:19:23,580
just specify declaratively what servers

00:19:22,440 --> 00:19:26,340
you want to start warming your DNS

00:19:23,580 --> 00:19:28,230
connections up to that led to an 18%

00:19:26,340 --> 00:19:30,000
perform performance improvement on what

00:19:28,230 --> 00:19:33,000
they initially had just for at least

00:19:30,000 --> 00:19:35,040
hitting things like FMP next they

00:19:33,000 --> 00:19:38,040
investigated using preload for their

00:19:35,040 --> 00:19:39,660
critical scripts I can't tell you how

00:19:38,040 --> 00:19:41,520
easy this stuff is to set up like this

00:19:39,660 --> 00:19:42,990
will take you you know if you're using a

00:19:41,520 --> 00:19:44,730
static site it's probably less than ten

00:19:42,990 --> 00:19:46,620
minutes if you're using something full

00:19:44,730 --> 00:19:48,660
stack it will probably take you an hour

00:19:46,620 --> 00:19:49,980
but it's we're trying out just to see if

00:19:48,660 --> 00:19:52,260
it actually has a perceivable

00:19:49,980 --> 00:19:53,820
improvement on your site so they ended

00:19:52,260 --> 00:19:55,290
up reloading their critical script so

00:19:53,820 --> 00:19:57,510
this is like their vendor bundle their

00:19:55,290 --> 00:19:59,550
synchronous chip scripts as well as

00:19:57,510 --> 00:20:03,750
their their main scripts that lets with

00:19:59,550 --> 00:20:06,680
36% improvement on their overall time to

00:20:03,750 --> 00:20:08,580
interactive next they put work into

00:20:06,680 --> 00:20:11,880
actually putting pixels on the screen

00:20:08,580 --> 00:20:13,980
much faster now Twitter is one of those

00:20:11,880 --> 00:20:16,200
experiences that are very you know

00:20:13,980 --> 00:20:19,170
meteor rich there's a lot of images in

00:20:16,200 --> 00:20:20,670
there and so it's unsurprising the media

00:20:19,170 --> 00:20:24,570
and images one of the things that were

00:20:20,670 --> 00:20:25,980
slowing them down render wise now one of

00:20:24,570 --> 00:20:27,750
the things they did was they used

00:20:25,980 --> 00:20:30,210
request I'll call back

00:20:27,750 --> 00:20:32,190
we defer loading of some of the images

00:20:30,210 --> 00:20:33,900
in their timeline and that led to a four

00:20:32,190 --> 00:20:36,210
times improvement on the render

00:20:33,900 --> 00:20:39,810
performance ric is kind of awesome

00:20:36,210 --> 00:20:41,700
definitely worth exploring another thing

00:20:39,810 --> 00:20:43,830
that they noticed was and this was kind

00:20:41,700 --> 00:20:46,050
of it's it's so silly but images are

00:20:43,830 --> 00:20:48,600
still such a big part of what slows us

00:20:46,050 --> 00:20:50,040
down these days they noticed that they

00:20:48,600 --> 00:20:52,230
were still sending down relatively large

00:20:50,040 --> 00:20:54,690
images that were not the right height or

00:20:52,230 --> 00:20:56,670
width that were still encoded you know

00:20:54,690 --> 00:20:58,350
sub-optimally and we're taking a long

00:20:56,670 --> 00:21:02,430
time to decode as soon as they hit

00:20:58,350 --> 00:21:04,260
chrome they went through the process of

00:21:02,430 --> 00:21:06,300
actually optimizing that and that shaved

00:21:04,260 --> 00:21:08,220
off a whole lot of time on their image

00:21:06,300 --> 00:21:10,200
decodes helped them to make sure that as

00:21:08,220 --> 00:21:11,430
you scroll through the timeline images

00:21:10,200 --> 00:21:12,660
are at least not one of those things

00:21:11,430 --> 00:21:14,970
that are causing you a bottleneck

00:21:12,660 --> 00:21:17,580
another thing that they introduced was

00:21:14,970 --> 00:21:19,920
data saver mode this is this idea that

00:21:17,580 --> 00:21:22,800
you as a user can say well I've got a

00:21:19,920 --> 00:21:24,990
limited data plan I just want you to not

00:21:22,800 --> 00:21:27,210
show any images or videos unless I

00:21:24,990 --> 00:21:30,030
actually tap on them and this led to a

00:21:27,210 --> 00:21:31,410
70 percent improvement in many cases on

00:21:30,030 --> 00:21:33,450
the amount of data consumed by the

00:21:31,410 --> 00:21:35,130
application if you're looking at a web

00:21:33,450 --> 00:21:38,280
platform level at what we're doing to

00:21:35,130 --> 00:21:40,470
try these types of experiences we've got

00:21:38,280 --> 00:21:42,150
the save data client int that you can

00:21:40,470 --> 00:21:44,580
use and Twitter going to investigate

00:21:42,150 --> 00:21:45,090
using that next then you've got free

00:21:44,580 --> 00:21:46,980
cash

00:21:45,090 --> 00:21:49,020
so initially Twitter Lite didn't have

00:21:46,980 --> 00:21:52,410
support for anything offline or

00:21:49,020 --> 00:21:54,240
serviceworker caching and what they did

00:21:52,410 --> 00:21:57,090
was they incremental II took an approach

00:21:54,240 --> 00:21:59,880
to adopting serviceworker they started

00:21:57,090 --> 00:22:02,670
off by first of all statically sort of

00:21:59,880 --> 00:22:04,440
caching their scripts the emoji they're

00:22:02,670 --> 00:22:07,800
used whenever you try DMing someone or

00:22:04,440 --> 00:22:09,720
applying to tweets as well as CSS and

00:22:07,800 --> 00:22:11,400
then they ramp that up over time to

00:22:09,720 --> 00:22:15,390
include things like application shell

00:22:11,400 --> 00:22:17,790
caching so UI caching now what that did

00:22:15,390 --> 00:22:22,560
on repeat visits was it took load time

00:22:17,790 --> 00:22:24,810
down from six point ten seconds down to

00:22:22,560 --> 00:22:26,550
one point four nine seconds so when you

00:22:24,810 --> 00:22:28,830
after the first time that you visit

00:22:26,550 --> 00:22:30,270
Twitter light it feels instant coming

00:22:28,830 --> 00:22:35,820
back and trying to navigate across

00:22:30,270 --> 00:22:40,200
different views it's pretty powerful now

00:22:35,820 --> 00:22:41,610
I was cheeky and asked twitter to like

00:22:40,200 --> 00:22:43,170
host 20 different versions

00:22:41,610 --> 00:22:44,429
their site so I could go and profile

00:22:43,170 --> 00:22:47,160
them and they were kind enough to do

00:22:44,429 --> 00:22:48,299
that now on second load without a

00:22:47,160 --> 00:22:50,250
serviceworker after some of these

00:22:48,299 --> 00:22:52,740
changes they saw that they were 47%

00:22:50,250 --> 00:22:54,720
faster on second load so repeat visits

00:22:52,740 --> 00:22:59,520
with a surface worker they're 65 percent

00:22:54,720 --> 00:23:01,170
faster and you've got lazy load so

00:22:59,520 --> 00:23:02,549
remember when we were looking so this is

00:23:01,170 --> 00:23:03,390
a lighthouse report if I didn't mention

00:23:02,549 --> 00:23:04,890
it before

00:23:03,390 --> 00:23:06,390
remember when we were saying earlier

00:23:04,890 --> 00:23:08,700
that their time to interactive scores

00:23:06,390 --> 00:23:11,100
kind of sucked and needed a little bit

00:23:08,700 --> 00:23:12,540
of work well breaking that work up was

00:23:11,100 --> 00:23:15,299
one of the first things they needed to

00:23:12,540 --> 00:23:17,640
do so they have to do these large blocks

00:23:15,299 --> 00:23:19,350
of like monolithic JavaScript bundles

00:23:17,640 --> 00:23:21,090
that I know people are like you know

00:23:19,350 --> 00:23:23,010
some people just don't look at me I'm

00:23:21,090 --> 00:23:24,990
not doing that but a lot of people

00:23:23,010 --> 00:23:27,299
actually still do this and that's

00:23:24,990 --> 00:23:29,309
relatively slow to load on mobile if you

00:23:27,299 --> 00:23:30,570
have a relatively large bundle even if

00:23:29,309 --> 00:23:32,309
you think that like you know a few

00:23:30,570 --> 00:23:33,929
hundred kilobytes isn't a lot that's

00:23:32,309 --> 00:23:36,090
still extra work the browser has to do

00:23:33,929 --> 00:23:38,370
to parse and compile that code before it

00:23:36,090 --> 00:23:40,860
can even you know start to boot it up so

00:23:38,370 --> 00:23:42,210
initially their bundles were taking five

00:23:40,860 --> 00:23:45,990
and a half seconds five and a half

00:23:42,210 --> 00:23:48,510
second dish to get ready before code

00:23:45,990 --> 00:23:49,770
splitting and then they had this great

00:23:48,510 --> 00:23:51,270
moment where they're trying to figure

00:23:49,770 --> 00:23:53,910
out how you're supposed to configure web

00:23:51,270 --> 00:23:54,929
pack and are still having the best of

00:23:53,910 --> 00:23:57,830
times with it

00:23:54,929 --> 00:24:01,380
I hear it's gone better with web pack -

00:23:57,830 --> 00:24:03,210
we'll see and one of the things that

00:24:01,380 --> 00:24:04,799
they ended up doing was this is this is

00:24:03,210 --> 00:24:06,360
a lot of what their code splitting

00:24:04,799 --> 00:24:08,340
looks like beyond just just using

00:24:06,360 --> 00:24:09,600
require done ensure they're just making

00:24:08,340 --> 00:24:11,370
sure that they're correctly using sort

00:24:09,600 --> 00:24:13,500
of vendor splitting for all of their

00:24:11,370 --> 00:24:15,809
bundles across different views Twitter

00:24:13,500 --> 00:24:18,390
ended up creating something like 40

00:24:15,809 --> 00:24:20,820
different a synchronous chunks that are

00:24:18,390 --> 00:24:25,500
granularly loaded as you navigate from

00:24:20,820 --> 00:24:26,850
one view to the other and the impact

00:24:25,500 --> 00:24:28,320
that that had on their experience was

00:24:26,850 --> 00:24:30,780
that that actual bundle ended up only

00:24:28,320 --> 00:24:33,000
taking about three seconds to fully

00:24:30,780 --> 00:24:35,730
process and it improved their overall

00:24:33,000 --> 00:24:37,080
times interactive by the end of it

00:24:35,730 --> 00:24:39,299
they're actually doing much better than

00:24:37,080 --> 00:24:41,610
this now but by the end of it they were

00:24:39,299 --> 00:24:43,590
getting interactive in about 5.7 seconds

00:24:41,610 --> 00:24:45,660
which is still impressive as an

00:24:43,590 --> 00:24:48,330
investment in just code splitting and

00:24:45,660 --> 00:24:52,960
some relatively low friction ideas

00:24:48,330 --> 00:24:55,100
around efficient loading so

00:24:52,960 --> 00:24:57,860
one other thing that they ended up

00:24:55,100 --> 00:24:59,540
finding was incredibly invaluable and

00:24:57,860 --> 00:25:01,340
have been coming back to it pretty

00:24:59,540 --> 00:25:02,960
regularly is just making sure that

00:25:01,340 --> 00:25:05,240
they're using bundle analyzers like

00:25:02,960 --> 00:25:07,010
webpack bundle analyzer to find out what

00:25:05,240 --> 00:25:09,770
low-hanging fruit they have in their

00:25:07,010 --> 00:25:11,810
bundles I keep running into people they

00:25:09,770 --> 00:25:13,700
don't realize that moment J s or other

00:25:11,810 --> 00:25:14,990
libraries are actually a big part of

00:25:13,700 --> 00:25:17,240
their bundles and can probably be

00:25:14,990 --> 00:25:19,010
trimmed down so if you're not using

00:25:17,240 --> 00:25:21,560
things like web pack bundle analyzer or

00:25:19,010 --> 00:25:23,960
source map Explorer do check them out

00:25:21,560 --> 00:25:25,520
they do generally lead to at least

00:25:23,960 --> 00:25:28,210
understanding a little bit more about

00:25:25,520 --> 00:25:31,430
what it is you're sending down the wire

00:25:28,210 --> 00:25:32,930
and in Twitter's case they were making

00:25:31,430 --> 00:25:35,000
sure that they were using the bundle

00:25:32,930 --> 00:25:36,080
analyzer plugin so that every single

00:25:35,000 --> 00:25:37,610
time someone was actually working

00:25:36,080 --> 00:25:39,980
directly on the application they could

00:25:37,610 --> 00:25:42,560
see what impact that ended up having on

00:25:39,980 --> 00:25:47,390
their bundle site on their actual bundle

00:25:42,560 --> 00:25:50,210
shape so performance is sort of this

00:25:47,390 --> 00:25:52,520
continuous game of measuring for areas

00:25:50,210 --> 00:25:54,620
to improve there isn't a single thing

00:25:52,520 --> 00:25:56,390
that you can do and then just leave it

00:25:54,620 --> 00:25:58,850
where your site is going to you know

00:25:56,390 --> 00:26:00,700
always be fast regardless of the devices

00:25:58,850 --> 00:26:03,620
that your users end up trying it out on

00:26:00,700 --> 00:26:06,800
for anyone that is interested in sort of

00:26:03,620 --> 00:26:08,450
getting involved with more continuous

00:26:06,800 --> 00:26:09,950
performance profiling you know where

00:26:08,450 --> 00:26:11,680
your team are staying on top of it and

00:26:09,950 --> 00:26:14,180
you're building up a performance culture

00:26:11,680 --> 00:26:16,280
I'm happy to encourage you trying out

00:26:14,180 --> 00:26:19,910
lighthouse it's one of the projects that

00:26:16,280 --> 00:26:21,680
we work on lighthouse sort of is a is an

00:26:19,910 --> 00:26:23,390
auditing tool for both performance

00:26:21,680 --> 00:26:25,300
metrics but also progressive web app

00:26:23,390 --> 00:26:28,970
features and general web performance of

00:26:25,300 --> 00:26:32,450
web platform best practices and I'm also

00:26:28,970 --> 00:26:35,210
happy to suggest trying out calibre by

00:26:32,450 --> 00:26:37,430
Ben Schwartz calibre is sort of great in

00:26:35,210 --> 00:26:39,530
that it allows you over time to track

00:26:37,430 --> 00:26:41,210
everything from your bundle size through

00:26:39,530 --> 00:26:42,620
to different performance metrics and see

00:26:41,210 --> 00:26:45,320
you know what impact your different

00:26:42,620 --> 00:26:47,990
employees had over time so check that

00:26:45,320 --> 00:26:50,990
out and I'd also encourage people to

00:26:47,990 --> 00:26:53,780
check out web page test integration with

00:26:50,990 --> 00:26:55,250
your git hooks housing comm is a

00:26:53,780 --> 00:26:56,690
progressive web app that did this and

00:26:55,250 --> 00:26:59,360
basically they have this really awesome

00:26:56,690 --> 00:27:02,240
setup where any time someone tries to

00:26:59,360 --> 00:27:04,070
submit a new PR for a feature it runs it

00:27:02,240 --> 00:27:04,610
through web page test and will include a

00:27:04,070 --> 00:27:06,070
filmstrip

00:27:04,610 --> 00:27:07,960
at the very bottom of your Pia

00:27:06,070 --> 00:27:13,990
are to show exactly what impact that had

00:27:07,960 --> 00:27:16,000
on user experience so with that I hope

00:27:13,990 --> 00:27:17,800
you found this little journey into

00:27:16,000 --> 00:27:19,720
loading useful I hope you found the

00:27:17,800 --> 00:27:25,480
story about some of the experiences we

00:27:19,720 --> 00:27:27,430
had with Twitter useful I know that you

00:27:25,480 --> 00:27:29,680
know Twitter of Twitter is great it also

00:27:27,430 --> 00:27:32,410
sometimes feels like group therapy where

00:27:29,680 --> 00:27:36,010
no one ever it gets any better that it's

00:27:32,410 --> 00:27:36,940
it's great so yeah if if you're

00:27:36,010 --> 00:27:40,330
interested in learning a little bit more

00:27:36,940 --> 00:27:42,610
about loading we started a new blog over

00:27:40,330 --> 00:27:44,710
on a crime scene called reloading on

00:27:42,610 --> 00:27:46,960
medium so medium.com slash reloading and

00:27:44,710 --> 00:27:48,190
we intend on publishing more material

00:27:46,960 --> 00:27:50,950
there over the next coming months about

00:27:48,190 --> 00:27:53,350
everything from h to server push through

00:27:50,950 --> 00:27:54,310
to broadly Gretz lee and a lot of the

00:27:53,350 --> 00:27:56,950
other work that we're doing in the

00:27:54,310 --> 00:27:57,690
loading space and that's it for me thank

00:27:56,950 --> 00:28:01,509
you

00:27:57,690 --> 00:28:01,509
[Applause]

00:28:04,250 --> 00:28:06,310

YouTube URL: https://www.youtube.com/watch?v=7vUs5yOuv-o


