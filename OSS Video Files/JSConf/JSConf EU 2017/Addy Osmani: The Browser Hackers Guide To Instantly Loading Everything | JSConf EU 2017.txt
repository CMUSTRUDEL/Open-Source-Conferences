Title: Addy Osmani: The Browser Hackers Guide To Instantly Loading Everything | JSConf EU 2017
Publication date: 2017-05-25
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/addy-osmani-the-browser-hackers-guide-to-instantly-loading-everything.html

Venture deep into the belly of the browser to uncover the secret incantations to instantly load anything. We’ll even back it up with rock-hard data. Will we use preload, prefetch and preconnect? What about HTTP/2 Server Push? or Service Worker? and how the heck do we ship JavaScript bundles that don’t break the bank on mobile? Discover this and more tips to delight your users in the Browser Hacker’s guide to instantly loading EVERYTHING.
Captions: 
	00:00:00,110 --> 00:00:27,559
[Music]

00:00:38,530 --> 00:00:44,420
I'm sorry this conferences loves video

00:00:41,060 --> 00:00:47,739
effects I've gotta got to do it alright

00:00:44,420 --> 00:00:53,570
so today we're going to talk about

00:00:47,739 --> 00:00:57,290
loading on the web loading is a user

00:00:53,570 --> 00:00:59,660
journey with very disparate expectations

00:00:57,290 --> 00:01:01,070
you're basically sending thousands and

00:00:59,660 --> 00:01:03,320
thousands of bytes down the wire and

00:01:01,070 --> 00:01:05,150
hoping that whatever comes out from the

00:01:03,320 --> 00:01:07,250
very end of that is something that's

00:01:05,150 --> 00:01:08,659
actually useful to your users and helps

00:01:07,250 --> 00:01:10,880
them interact with your applications

00:01:08,659 --> 00:01:12,409
relatively quickly so I thought that

00:01:10,880 --> 00:01:15,920
today we'd have a conversation about

00:01:12,409 --> 00:01:17,240
loading now we can really have a

00:01:15,920 --> 00:01:18,770
conversation about loading without

00:01:17,240 --> 00:01:21,500
talking about where we're at right now

00:01:18,770 --> 00:01:23,990
so this is what the average web page on

00:01:21,500 --> 00:01:25,700
mobile looks like in 2017

00:01:23,990 --> 00:01:27,920
whether it's built with sort of a

00:01:25,700 --> 00:01:31,040
JavaScript framework or just a static

00:01:27,920 --> 00:01:33,560
site in many cases it takes 16 seconds

00:01:31,040 --> 00:01:37,009
to get interactive on a real mobile

00:01:33,560 --> 00:01:39,740
device on 3G usually takes 19 seconds to

00:01:37,009 --> 00:01:41,479
be fully loaded and people mostly send

00:01:39,740 --> 00:01:43,430
you know somewhere in the region of 420

00:01:41,479 --> 00:01:46,100
450 kilobytes of JavaScript down the

00:01:43,430 --> 00:01:48,500
wire and why does any of this actually

00:01:46,100 --> 00:01:50,270
matter well if we take a look at a high

00:01:48,500 --> 00:01:52,909
level and how the browser actually

00:01:50,270 --> 00:01:54,500
manages to get anything render to the

00:01:52,909 --> 00:01:56,630
screen from the network it's a

00:01:54,500 --> 00:01:59,630
relatively simple process we send a

00:01:56,630 --> 00:02:01,909
request out server returns an HTML we go

00:01:59,630 --> 00:02:03,109
and we parse the CSS and JavaScript and

00:02:01,909 --> 00:02:04,729
images and anything else that comes back

00:02:03,109 --> 00:02:06,829
and then we actually have to parse

00:02:04,729 --> 00:02:08,720
compile and render that code in order to

00:02:06,829 --> 00:02:11,900
render and turn onto pixels on the

00:02:08,720 --> 00:02:16,220
screen right but it's never quite that

00:02:11,900 --> 00:02:18,890
simple we're usually developing on

00:02:16,220 --> 00:02:21,530
relatively powerful high-end desktop

00:02:18,890 --> 00:02:23,210
machines and the expectations that we

00:02:21,530 --> 00:02:25,400
have when we're profiling there are

00:02:23,210 --> 00:02:26,330
quite different to mobile particularly

00:02:25,400 --> 00:02:28,550
when it comes to things like JavaScript

00:02:26,330 --> 00:02:29,840
startup performance where on a real

00:02:28,550 --> 00:02:31,730
world mobile device you can end up

00:02:29,840 --> 00:02:35,240
seeing anywhere between 4 and 5 times

00:02:31,730 --> 00:02:37,280
with a slowdown so the first thing I

00:02:35,240 --> 00:02:39,740
think that we as a community need to

00:02:37,280 --> 00:02:42,450
shift worth doing is actually testing on

00:02:39,740 --> 00:02:43,680
real phones and real networks

00:02:42,450 --> 00:02:44,970
I know there are a bunch of people so

00:02:43,680 --> 00:02:47,790
how many people here actually used like

00:02:44,970 --> 00:02:49,860
the dev tools network emulation or CPU

00:02:47,790 --> 00:02:51,390
throttling or device node so a lot of

00:02:49,860 --> 00:02:53,190
people here that's great that's a great

00:02:51,390 --> 00:02:55,319
first step we need to do better than

00:02:53,190 --> 00:02:57,240
that though because mobile devices have

00:02:55,319 --> 00:02:58,770
got different GPUs different CPUs

00:02:57,240 --> 00:03:00,720
different memory different battery

00:02:58,770 --> 00:03:02,819
characteristics so there's a lot that we

00:03:00,720 --> 00:03:04,440
can do there for people that want to

00:03:02,819 --> 00:03:06,800
start doing that today we recently

00:03:04,440 --> 00:03:09,870
shipped the new part of webpagetest.org

00:03:06,800 --> 00:03:12,330
called slash easy so webpagetest.org

00:03:09,870 --> 00:03:13,770
slash easy has got a whole farm of

00:03:12,330 --> 00:03:15,870
average mobile devices on there right

00:03:13,770 --> 00:03:18,450
now with easy profiles for going and

00:03:15,870 --> 00:03:20,130
checking out your performance now a lot

00:03:18,450 --> 00:03:21,630
of the time we talk about mobile

00:03:20,130 --> 00:03:24,269
performance these days we reference this

00:03:21,630 --> 00:03:26,280
idea of time to interactive and the idea

00:03:24,269 --> 00:03:27,660
there is that you're just able to make

00:03:26,280 --> 00:03:29,069
sure that the user can actually tap

00:03:27,660 --> 00:03:32,160
around your interface and how something

00:03:29,069 --> 00:03:33,569
useful actually happen in this case I

00:03:32,160 --> 00:03:34,980
think that someone is going through like

00:03:33,569 --> 00:03:36,690
a withdrawal symptom because there isn't

00:03:34,980 --> 00:03:40,800
actually anything on their phone looks a

00:03:36,690 --> 00:03:42,239
little bit dead so there are a few rules

00:03:40,800 --> 00:03:43,890
that I like to follow and I'm building

00:03:42,239 --> 00:03:46,019
modern web apps that try to load

00:03:43,890 --> 00:03:48,299
efficiently the first is only load what

00:03:46,019 --> 00:03:49,860
you need so trying to make sure that if

00:03:48,299 --> 00:03:51,239
you're shipping script and CSS and

00:03:49,860 --> 00:03:52,290
everything else down the wire that it's

00:03:51,239 --> 00:03:54,360
only the things that are going to

00:03:52,290 --> 00:03:56,880
actually be useful to the users initial

00:03:54,360 --> 00:03:59,700
experience that you're using idle time

00:03:56,880 --> 00:04:01,410
to load in anything else so your comment

00:03:59,700 --> 00:04:02,549
threads any additional pages that might

00:04:01,410 --> 00:04:04,320
be needed for the rest of the user

00:04:02,549 --> 00:04:06,360
experience now there are a lot of things

00:04:04,320 --> 00:04:09,180
that we can do to actually help load

00:04:06,360 --> 00:04:10,829
less code one of the first things is

00:04:09,180 --> 00:04:12,180
code splitting so code splitting

00:04:10,829 --> 00:04:14,459
something that a lot of you probably are

00:04:12,180 --> 00:04:16,440
familiar with as a concept relatively

00:04:14,459 --> 00:04:18,359
straightforward get set up using webpack

00:04:16,440 --> 00:04:20,310
were split able or closure compiler or

00:04:18,359 --> 00:04:22,950
browserify the basic idea is that

00:04:20,310 --> 00:04:24,660
instead of like making your user eat an

00:04:22,950 --> 00:04:26,190
entire pizza and get really bloated you

00:04:24,660 --> 00:04:28,470
just give them a single piece at a time

00:04:26,190 --> 00:04:29,760
and that way hopefully they feel you

00:04:28,470 --> 00:04:31,250
know a little bit better about the

00:04:29,760 --> 00:04:33,780
experience that you're shipping down

00:04:31,250 --> 00:04:35,669
tree-shaking so removing unused exports

00:04:33,780 --> 00:04:38,400
using things like roll-up also worth

00:04:35,669 --> 00:04:41,160
spending time on something we don't talk

00:04:38,400 --> 00:04:42,810
about enough is the fact that the

00:04:41,160 --> 00:04:45,080
baselines we're using when we're trying

00:04:42,810 --> 00:04:47,640
to ship powerful experiences on mobile

00:04:45,080 --> 00:04:50,460
don't always set us up for success today

00:04:47,640 --> 00:04:52,680
so if a framework for example and I love

00:04:50,460 --> 00:04:54,419
I love frameworks I created two MVC ela

00:04:52,680 --> 00:04:54,620
frameworks I use like reactant view and

00:04:54,419 --> 00:04:56,660
free

00:04:54,620 --> 00:04:59,540
all the time but the frameworks that we

00:04:56,660 --> 00:05:01,790
use today are often built with desktop

00:04:59,540 --> 00:05:03,410
machines in mind and when it comes to

00:05:01,790 --> 00:05:04,580
actually trying them out on mobile if

00:05:03,410 --> 00:05:06,380
we're saying you've got to be

00:05:04,580 --> 00:05:08,330
interactive in like five seconds and

00:05:06,380 --> 00:05:09,919
your framework is beating up like four

00:05:08,330 --> 00:05:11,600
seconds of that and it's do it at time

00:05:09,919 --> 00:05:13,370
that's not setting you up for success so

00:05:11,600 --> 00:05:15,020
there's probably room that we've got to

00:05:13,370 --> 00:05:17,090
improve there there are lots of

00:05:15,020 --> 00:05:19,340
lightweight options today pre-act view

00:05:17,090 --> 00:05:20,690
svelte polymer there are lots of others

00:05:19,340 --> 00:05:23,930
they generally have a relatively though

00:05:20,690 --> 00:05:25,190
parsing startup time over on the dev

00:05:23,930 --> 00:05:27,320
tools side one of the things that we

00:05:25,190 --> 00:05:29,210
recently shipped to help you with this

00:05:27,320 --> 00:05:31,789
idea of shipping less code is a feature

00:05:29,210 --> 00:05:34,580
called code coverage the idea here is

00:05:31,789 --> 00:05:36,440
that you just load up you're out you hit

00:05:34,580 --> 00:05:38,630
record in this new item in the drawer

00:05:36,440 --> 00:05:40,220
and then we tell you what blocks of code

00:05:38,630 --> 00:05:42,560
actually got executed and which ones

00:05:40,220 --> 00:05:44,300
didn't so here we've got sort of an

00:05:42,560 --> 00:05:46,400
indication that maybe you know I'm not

00:05:44,300 --> 00:05:48,139
really using 50% of the code in the

00:05:46,400 --> 00:05:49,550
bundle that I'm shipping down and as we

00:05:48,139 --> 00:05:51,410
click on that and scroll through the

00:05:49,550 --> 00:05:53,000
sources panel you can see that we

00:05:51,410 --> 00:05:55,370
highlight in green code that got

00:05:53,000 --> 00:05:56,840
executed and red code that didn't in

00:05:55,370 --> 00:05:58,669
this case because this is a camera app

00:05:56,840 --> 00:06:00,950
I've got a lot of code for actually

00:05:58,669 --> 00:06:02,900
doing cross browser saving a file to an

00:06:00,950 --> 00:06:05,570
export so I can probably be lazily

00:06:02,900 --> 00:06:07,099
loading in other things we can do like

00:06:05,570 --> 00:06:09,440
most of us here probably using a

00:06:07,099 --> 00:06:11,000
transpiler of some sort to use all the

00:06:09,440 --> 00:06:13,070
juicy new features javascript has got

00:06:11,000 --> 00:06:15,380
but the reality is that you know cross

00:06:13,070 --> 00:06:17,000
browser es2015 support is in a

00:06:15,380 --> 00:06:18,620
relatively good place right now we don't

00:06:17,000 --> 00:06:21,229
always need to be you know sending

00:06:18,620 --> 00:06:23,270
people down es5 so if you're shipping an

00:06:21,229 --> 00:06:25,610
experience using babel today i strongly

00:06:23,270 --> 00:06:27,740
encourage you to try out babel preset

00:06:25,610 --> 00:06:30,169
ends this will basically only transpile

00:06:27,740 --> 00:06:31,880
code for the browsers that need it and

00:06:30,169 --> 00:06:34,639
just keep everything else in es2015

00:06:31,880 --> 00:06:37,310
let's check that out if you happen to be

00:06:34,639 --> 00:06:39,470
using low - check out babel plugin low -

00:06:37,310 --> 00:06:41,360
this is sort of a neat transform that

00:06:39,470 --> 00:06:42,770
will rewrite your low - code so it only

00:06:41,360 --> 00:06:44,300
uses the modules that you're actually

00:06:42,770 --> 00:06:48,229
using in your source rather than the

00:06:44,300 --> 00:06:50,180
entire package so check that out - this

00:06:48,229 --> 00:06:50,750
week we also announced after a very long

00:06:50,180 --> 00:06:54,580
wait

00:06:50,750 --> 00:06:57,620
support for es2015 modules in chrome

00:06:54,580 --> 00:06:59,539
thank you this is something that will

00:06:57,620 --> 00:07:01,610
hopefully encourage again a little bit

00:06:59,539 --> 00:07:02,570
less transformation and is something

00:07:01,610 --> 00:07:03,919
that will open up a few more

00:07:02,570 --> 00:07:06,200
opportunities for interesting loading

00:07:03,919 --> 00:07:07,190
experiences across the board the next

00:07:06,200 --> 00:07:10,460
thing I like to do

00:07:07,190 --> 00:07:12,230
is order loading thoughtfully you know

00:07:10,460 --> 00:07:13,430
more than anybody else in the stack you

00:07:12,230 --> 00:07:15,650
know what is important to your user

00:07:13,430 --> 00:07:17,960
journey and what needs to be sent down

00:07:15,650 --> 00:07:19,970
earlier on than anything else something

00:07:17,960 --> 00:07:21,530
that we recently also shipped in dev

00:07:19,970 --> 00:07:24,050
tools to help with this is a feature

00:07:21,530 --> 00:07:26,240
called network request blocking that's

00:07:24,050 --> 00:07:28,520
in canary right now the idea here is

00:07:26,240 --> 00:07:30,890
that in the network waterfall for any

00:07:28,520 --> 00:07:32,900
site you can right-click on a network

00:07:30,890 --> 00:07:34,670
request and you can block it or you can

00:07:32,900 --> 00:07:36,890
block the domain and take a look at what

00:07:34,670 --> 00:07:38,630
impact that has on the overall critical

00:07:36,890 --> 00:07:39,800
path of your site I'm particularly

00:07:38,630 --> 00:07:42,310
useful if you've got a lot of

00:07:39,800 --> 00:07:44,660
third-party code that's slowing you down

00:07:42,310 --> 00:07:47,150
and finally cache aggressively and

00:07:44,660 --> 00:07:49,430
granularly cache as much as you can

00:07:47,150 --> 00:07:51,650
locally that's both with HTTP cache but

00:07:49,430 --> 00:07:54,260
also using serviceworker caching at

00:07:51,650 --> 00:07:55,790
Google we've been trying to ramp up our

00:07:54,260 --> 00:07:58,640
investment in serviceworker for a lot of

00:07:55,790 --> 00:08:01,190
our flagship apps inbox has been using

00:07:58,640 --> 00:08:03,680
serviceworker quite a lot and recently

00:08:01,190 --> 00:08:05,120
saw a 10% improvement in time to

00:08:03,680 --> 00:08:06,830
interactive just by making sure that

00:08:05,120 --> 00:08:11,450
they're using it for things like static

00:08:06,830 --> 00:08:15,260
resource caching now about three years

00:08:11,450 --> 00:08:16,760
ago I was speaking at CSS comp and we

00:08:15,260 --> 00:08:19,130
spent the whole talk sort of optimizing

00:08:16,760 --> 00:08:20,570
jazz comp that you and I thought you

00:08:19,130 --> 00:08:22,720
know given that I'm back here it'd be

00:08:20,570 --> 00:08:27,140
kind of fun to do that again at a much

00:08:22,720 --> 00:08:30,020
shorter rate but also a little bit may

00:08:27,140 --> 00:08:33,110
be unorthodox plea so what we're going

00:08:30,020 --> 00:08:35,000
to do is we're going to hack chrome to

00:08:33,110 --> 00:08:35,570
make j/s confi you load a little bit

00:08:35,000 --> 00:08:37,430
faster

00:08:35,570 --> 00:08:39,680
this guy's not in fact a hacker he's

00:08:37,430 --> 00:08:43,000
just like scrolling through his web pack

00:08:39,680 --> 00:08:47,750
on fake or something

00:08:43,000 --> 00:08:49,400
so you dive into C++ in chrome and you

00:08:47,750 --> 00:08:50,750
find this file called resource fetcher

00:08:49,400 --> 00:08:52,250
and resource fetcher is one of these

00:08:50,750 --> 00:08:54,080
files I know nobody can see this so

00:08:52,250 --> 00:08:56,420
let's just zoom in here this is one of

00:08:54,080 --> 00:08:58,100
these files that define how chrome

00:08:56,420 --> 00:09:00,650
actually handles the prioritization for

00:08:58,100 --> 00:09:03,470
different types of resources so your CSS

00:09:00,650 --> 00:09:05,030
your JavaScript your images I don't

00:09:03,470 --> 00:09:06,850
expect anybody to read this so here's

00:09:05,030 --> 00:09:10,190
the table of how we actually handle this

00:09:06,850 --> 00:09:12,650
layout blocking resources like CSS and

00:09:10,190 --> 00:09:14,600
fonts get the highest priority load in

00:09:12,650 --> 00:09:17,510
layout blocking phase resources like

00:09:14,600 --> 00:09:20,330
scripts or images that happens being the

00:09:17,510 --> 00:09:21,080
viewport get a medium priority and then

00:09:20,330 --> 00:09:23,330
everything from your

00:09:21,080 --> 00:09:25,520
basing scripts to images that are

00:09:23,330 --> 00:09:27,410
outside of the viewport mismatch CSS

00:09:25,520 --> 00:09:29,300
they get a much much lower priority

00:09:27,410 --> 00:09:31,790
what's interesting about this table

00:09:29,300 --> 00:09:33,890
actually is that images in your viewport

00:09:31,790 --> 00:09:35,210
get a medium priority and stuff that's

00:09:33,890 --> 00:09:37,010
outside of they get a lower one so we

00:09:35,210 --> 00:09:40,880
kind of do automatic lazy loading of

00:09:37,010 --> 00:09:42,530
images to some extent by default that's

00:09:40,880 --> 00:09:44,060
great but as a developer you probably

00:09:42,530 --> 00:09:46,100
care more about where this is exposed

00:09:44,060 --> 00:09:47,750
for you so in the network panel there's

00:09:46,100 --> 00:09:49,340
a column called priority that will tell

00:09:47,750 --> 00:09:51,440
you exactly what we're already was used

00:09:49,340 --> 00:09:54,920
for any of the resources that you wanted

00:09:51,440 --> 00:09:55,880
to load so we're back here and the part

00:09:54,920 --> 00:09:56,600
of chrome that we're going to hack is

00:09:55,880 --> 00:09:59,060
we're actually going to change

00:09:56,600 --> 00:10:01,430
absolutely every single type of resource

00:09:59,060 --> 00:10:03,800
to load with an extremely high priority

00:10:01,430 --> 00:10:07,130
it sounds like a great idea right so

00:10:03,800 --> 00:10:10,340
let's let's do that and that's going to

00:10:07,130 --> 00:10:13,310
fix all of our problems and I can just

00:10:10,340 --> 00:10:15,860
end the talk there right we could ship a

00:10:13,310 --> 00:10:17,390
new browser we could call it so I

00:10:15,860 --> 00:10:19,730
discovered Germany it's got this

00:10:17,390 --> 00:10:23,750
wonderful world called vers lemon

00:10:19,730 --> 00:10:26,180
discern which that's a terrible

00:10:23,750 --> 00:10:27,890
pronunciation but it means when you try

00:10:26,180 --> 00:10:32,900
to fix something but you actually made

00:10:27,890 --> 00:10:34,790
it a whole lot worse and I did so this

00:10:32,900 --> 00:10:36,080
is the original filmstrip for a jazz

00:10:34,790 --> 00:10:37,700
talk to you and this is what it looks

00:10:36,080 --> 00:10:39,170
like when everything is considered high

00:10:37,700 --> 00:10:41,270
priority we've actually completely

00:10:39,170 --> 00:10:45,020
shifted first meaningful paint way back

00:10:41,270 --> 00:10:46,280
performance is worse lesson there when

00:10:45,020 --> 00:10:50,270
everything is high priority

00:10:46,280 --> 00:10:51,470
nothing is and I ended up fixing this by

00:10:50,270 --> 00:10:52,730
going through the different types of

00:10:51,470 --> 00:10:54,050
resources that are used in this

00:10:52,730 --> 00:10:56,090
particular page and trying to figure out

00:10:54,050 --> 00:10:58,130
okay well are the image of the most

00:10:56,090 --> 00:11:01,190
important things the CSS and as it turns

00:10:58,130 --> 00:11:03,500
out it was the CSS and fonts so let's do

00:11:01,190 --> 00:11:05,150
this right by the browser we talked

00:11:03,500 --> 00:11:07,760
already about sort of at the high level

00:11:05,150 --> 00:11:09,560
how never for process work but there's a

00:11:07,760 --> 00:11:11,720
piece of this puzzle that I didn't quite

00:11:09,560 --> 00:11:14,630
dive into and that's the browser preload

00:11:11,720 --> 00:11:17,060
scanner now browsers like Chrome have

00:11:14,630 --> 00:11:18,470
got a document parser and as we go

00:11:17,060 --> 00:11:19,700
through the tokenization phase of

00:11:18,470 --> 00:11:21,520
actually reading through all the

00:11:19,700 --> 00:11:24,290
different tokens that compose your HTML

00:11:21,520 --> 00:11:26,060
we will go and try to fetch those

00:11:24,290 --> 00:11:28,310
resources and start processing them if

00:11:26,060 --> 00:11:30,590
we run into like a blocking script

00:11:28,310 --> 00:11:32,630
that's going to stop the document parser

00:11:30,590 --> 00:11:34,300
in its tracks which is why we have the

00:11:32,630 --> 00:11:36,280
sort of fallback thing that

00:11:34,300 --> 00:11:39,250
load scanner which is able to look ahead

00:11:36,280 --> 00:11:42,010
even when the you know dr. MacArthur is

00:11:39,250 --> 00:11:44,980
blocked and find other resources that we

00:11:42,010 --> 00:11:46,240
can continue to fetch and process when

00:11:44,980 --> 00:11:47,440
this change was first introduced in

00:11:46,240 --> 00:11:49,660
chrome I believe it introduced like a

00:11:47,440 --> 00:11:51,850
20% improvement over all the time so the

00:11:49,660 --> 00:11:53,440
preload scanner is pretty cool but we

00:11:51,850 --> 00:11:58,690
run into this other interesting

00:11:53,440 --> 00:12:01,510
challenge which is discovery no browser

00:11:58,690 --> 00:12:02,800
knows exactly what sequence of things to

00:12:01,510 --> 00:12:04,900
load to make sure that your page is

00:12:02,800 --> 00:12:06,790
going to be fast you more than anybody

00:12:04,900 --> 00:12:09,040
else again know what's important in your

00:12:06,790 --> 00:12:10,510
page whether it's your web pack bundles

00:12:09,040 --> 00:12:14,700
that need to be loaded early on or

00:12:10,510 --> 00:12:17,170
something else and so to address

00:12:14,700 --> 00:12:18,550
discoverability and the ability for you

00:12:17,170 --> 00:12:20,650
as an author to be able to say what you

00:12:18,550 --> 00:12:22,540
consider to be high priority you can use

00:12:20,650 --> 00:12:24,040
things like link rel preload which works

00:12:22,540 --> 00:12:26,080
with scripts and stylesheets and other

00:12:24,040 --> 00:12:27,790
types of resources and it's basically a

00:12:26,080 --> 00:12:29,800
declarative fetch that tells the browser

00:12:27,790 --> 00:12:33,280
that you consider something to be high

00:12:29,800 --> 00:12:35,500
priority now this is what the impact of

00:12:33,280 --> 00:12:37,510
using it on you know a site that happens

00:12:35,500 --> 00:12:39,220
to be using webpack looked like you

00:12:37,510 --> 00:12:42,130
you kind of shift all of the yellow

00:12:39,220 --> 00:12:44,740
that's on the right right all the way to

00:12:42,130 --> 00:12:46,780
the left at parse time I seeing this

00:12:44,740 --> 00:12:48,520
pattern being used increasingly in

00:12:46,780 --> 00:12:50,350
progressive web apps where it's having a

00:12:48,520 --> 00:12:52,720
positive impact on time to interactive

00:12:50,350 --> 00:12:54,700
for a lot of folks so I check that out

00:12:52,720 --> 00:12:56,230
if you're interested in actually hooking

00:12:54,700 --> 00:12:58,570
this up to your build process today I

00:12:56,230 --> 00:13:01,420
wrote a web pack plug-in called preload

00:12:58,570 --> 00:13:02,770
web pack plug-in they can do this for a

00:13:01,420 --> 00:13:04,450
synchronous chunks as well as like

00:13:02,770 --> 00:13:08,980
normal chunks so check it out if you

00:13:04,450 --> 00:13:11,350
find it interesting over on chrome the

00:13:08,980 --> 00:13:13,960
polymer team worked on an app a while

00:13:11,350 --> 00:13:15,700
ago called shop and the idea behind shop

00:13:13,960 --> 00:13:17,200
was trying to see you know if we if we

00:13:15,700 --> 00:13:18,640
use the web platform and the web

00:13:17,200 --> 00:13:21,040
platform features that are available to

00:13:18,640 --> 00:13:22,600
us today just how fast we make a modern

00:13:21,040 --> 00:13:25,360
web experience that was sort of

00:13:22,600 --> 00:13:28,240
non-trivial and shop kind of checked

00:13:25,360 --> 00:13:30,340
that off it was able to reach sort of

00:13:28,240 --> 00:13:31,900
granular loading you're able to tap on

00:13:30,340 --> 00:13:34,000
things and everything is just really

00:13:31,900 --> 00:13:36,160
nice and buttery smooth on mobile but

00:13:34,000 --> 00:13:37,660
how did they accomplish this so they

00:13:36,160 --> 00:13:40,390
used a pattern we came up with about

00:13:37,660 --> 00:13:42,970
last year called purple and the idea

00:13:40,390 --> 00:13:45,070
with purple is that you try to make sure

00:13:42,970 --> 00:13:46,990
that you're sending down the most

00:13:45,070 --> 00:13:48,579
important things for the user as early

00:13:46,990 --> 00:13:50,499
on as possible

00:13:48,579 --> 00:13:53,619
you push the minimal code needed for a

00:13:50,499 --> 00:13:56,800
route you render that route for next

00:13:53,619 --> 00:13:58,809
routes you're able to precache anything

00:13:56,800 --> 00:14:00,550
using service workers so that not only

00:13:58,809 --> 00:14:01,689
is that stuff already available locally

00:14:00,550 --> 00:14:03,550
in the disk cache when they try

00:14:01,689 --> 00:14:06,160
navigating to it but it's constantly

00:14:03,550 --> 00:14:08,889
available on repeat visits in addition

00:14:06,160 --> 00:14:12,759
for JavaScript using serviceworker we'll

00:14:08,889 --> 00:14:14,949
actually early on opt you into v8 code

00:14:12,759 --> 00:14:16,089
cache which will save you a little bit

00:14:14,949 --> 00:14:18,040
of time on things like parsing

00:14:16,089 --> 00:14:20,410
compilation and then the pattern

00:14:18,040 --> 00:14:22,499
suggests lazy loading code that you need

00:14:20,410 --> 00:14:24,189
for other parts of your user experience

00:14:22,499 --> 00:14:26,079
so let's take a look at what that

00:14:24,189 --> 00:14:28,269
actually looks like so this is um this

00:14:26,079 --> 00:14:32,139
is shop before any optimizations were

00:14:28,269 --> 00:14:36,220
applied you see sort of this this step

00:14:32,139 --> 00:14:39,549
pattern in the timeline this is a CB 2

00:14:36,220 --> 00:14:40,929
with 3G and remember that little block

00:14:39,549 --> 00:14:43,119
at the very start we're not actually

00:14:40,929 --> 00:14:46,059
seeing any any activity we're going to

00:14:43,119 --> 00:14:47,649
go back to that limit later with preload

00:14:46,059 --> 00:14:48,970
we actually changed the shape of that

00:14:47,649 --> 00:14:50,860
completely so we've gone from this to

00:14:48,970 --> 00:14:52,839
something looks like this basically

00:14:50,860 --> 00:14:55,209
we've shifted our time a little bit

00:14:52,839 --> 00:14:57,999
everything is now going to be attempting

00:14:55,209 --> 00:14:59,529
to load in parallel to some extent and

00:14:57,999 --> 00:15:00,819
that's start that starts shaving off

00:14:59,529 --> 00:15:03,579
some time over the overall user

00:15:00,819 --> 00:15:06,970
experience but it still comes with the

00:15:03,579 --> 00:15:09,309
cost of multiple round trips and this is

00:15:06,970 --> 00:15:10,480
where things like hb2 server push can

00:15:09,309 --> 00:15:13,360
actually come in useful

00:15:10,480 --> 00:15:15,610
now what push allows us to do is as an

00:15:13,360 --> 00:15:16,869
author specify using a manifest the

00:15:15,610 --> 00:15:20,350
files that we know are going to be

00:15:16,869 --> 00:15:22,119
critical to the user journey instead of

00:15:20,350 --> 00:15:24,519
just you know pushing down the request

00:15:22,119 --> 00:15:26,499
you know sending the browser some HTML

00:15:24,519 --> 00:15:28,480
with spending to be parsed when we send

00:15:26,499 --> 00:15:30,459
back that an is real HTML we can also

00:15:28,480 --> 00:15:32,410
start sending down a list of files that

00:15:30,459 --> 00:15:34,660
are super important to start fetching

00:15:32,410 --> 00:15:37,389
for the experience effectively we're

00:15:34,660 --> 00:15:38,889
filling up server think time we're today

00:15:37,389 --> 00:15:42,339
in a lot of cases we're not actually

00:15:38,889 --> 00:15:44,139
doing that so hey speed to server push

00:15:42,339 --> 00:15:46,179
is great for that and the impact that it

00:15:44,139 --> 00:15:47,860
had on this particular app was quite

00:15:46,179 --> 00:15:50,679
stark again we've shaved thousands of

00:15:47,860 --> 00:15:52,600
milliseconds off of the overall time for

00:15:50,679 --> 00:15:55,980
this app to get interactive and to load

00:15:52,600 --> 00:15:58,689
in general using this technique

00:15:55,980 --> 00:16:01,079
unfortunately hb2 server pushes not a

00:15:58,689 --> 00:16:03,959
silver bullet by any means

00:16:01,079 --> 00:16:05,490
it's not particularly Kasia we're in a

00:16:03,959 --> 00:16:07,680
perfect world we have the ability to

00:16:05,490 --> 00:16:09,959
have a cache digest or something that

00:16:07,680 --> 00:16:12,660
lets you know what exactly is in your

00:16:09,959 --> 00:16:14,519
user cache and so it's very easy to run

00:16:12,660 --> 00:16:16,440
into cases where you know every single

00:16:14,519 --> 00:16:18,300
time someone comes to your site you're

00:16:16,440 --> 00:16:20,160
just force pushing them you know the

00:16:18,300 --> 00:16:24,110
same set of files even if it's inside

00:16:20,160 --> 00:16:28,230
their cache which is not exactly ideal

00:16:24,110 --> 00:16:30,959
so push versus preload you know push can

00:16:28,230 --> 00:16:32,579
cut out a whole RCT it's not cache weird

00:16:30,959 --> 00:16:34,320
there's no real prioritization in place

00:16:32,579 --> 00:16:36,540
preload is particularly useful because

00:16:34,320 --> 00:16:38,459
in addition to what push can do it also

00:16:36,540 --> 00:16:40,320
you know sports cross-origin requests

00:16:38,459 --> 00:16:43,529
got load narrower events got content

00:16:40,320 --> 00:16:45,390
negotiation but how do we address this

00:16:43,529 --> 00:16:47,370
issue of h2 push not particularly

00:16:45,390 --> 00:16:49,079
knowing what's in the cache what we can

00:16:47,370 --> 00:16:51,089
use serviceworker if we have a

00:16:49,079 --> 00:16:52,860
serviceworker registered in such a way

00:16:51,089 --> 00:16:54,870
that instead of going to the network

00:16:52,860 --> 00:16:56,940
every single time that we need you know

00:16:54,870 --> 00:16:58,769
more resources to be fetched we're just

00:16:56,940 --> 00:17:01,200
trying to get them locally based on what

00:16:58,769 --> 00:17:03,720
is already cached we avoid this issue of

00:17:01,200 --> 00:17:09,270
needing cache digests and it makes this

00:17:03,720 --> 00:17:10,559
entire setup relatively sane for shop in

00:17:09,270 --> 00:17:12,480
particular this meant that on repeat

00:17:10,559 --> 00:17:14,130
visits once you tie absolutely

00:17:12,480 --> 00:17:15,780
everything in purple together you're

00:17:14,130 --> 00:17:17,370
actually able to boot up and get

00:17:15,780 --> 00:17:18,959
interactive in just a few hundred

00:17:17,370 --> 00:17:21,900
milliseconds it's quite a powerful

00:17:18,959 --> 00:17:23,280
pattern so preload is good for moving

00:17:21,900 --> 00:17:24,990
the start download time of an asset

00:17:23,280 --> 00:17:26,850
closer to the initial request and push

00:17:24,990 --> 00:17:28,230
is good for cutting out a full RTT if

00:17:26,850 --> 00:17:29,880
you have a serviceworker

00:17:28,230 --> 00:17:32,520
thanks to Sam Saucony for a bunch of the

00:17:29,880 --> 00:17:34,260
research that he did in this area the

00:17:32,520 --> 00:17:36,000
next thing I want to talk about is how a

00:17:34,260 --> 00:17:38,190
lot of this stuff can apply to the apps

00:17:36,000 --> 00:17:39,270
that you're probably building today out

00:17:38,190 --> 00:17:41,490
of interest how many people here are

00:17:39,270 --> 00:17:45,360
using react as a part of their default

00:17:41,490 --> 00:17:47,940
stack almost everybody or good good size

00:17:45,360 --> 00:17:49,890
the audience so I had the privilege of

00:17:47,940 --> 00:17:51,450
being able to work with Twitter on their

00:17:49,890 --> 00:17:53,370
new progressive web app Twitter light I

00:17:51,450 --> 00:17:55,740
wanted to talk a little bit about the

00:17:53,370 --> 00:17:57,630
learnings that we had there so Twitter

00:17:55,740 --> 00:17:59,520
started off with this which was their

00:17:57,630 --> 00:18:00,990
old mobile web experience and sort of

00:17:59,520 --> 00:18:03,630
the server-side render thing it was

00:18:00,990 --> 00:18:06,600
really really slow and it wasn't

00:18:03,630 --> 00:18:09,059
particularly happy didn't particularly

00:18:06,600 --> 00:18:10,950
encourage users to get engaging with the

00:18:09,059 --> 00:18:14,160
app this is the new progressive web app

00:18:10,950 --> 00:18:17,070
the Twitter shipped very very recently

00:18:14,160 --> 00:18:18,990
Twitter light and one of the

00:18:17,070 --> 00:18:20,250
accomplishments that they had by taking

00:18:18,990 --> 00:18:21,720
advantage of some of the primitives that

00:18:20,250 --> 00:18:23,280
we just talked about is that they're

00:18:21,720 --> 00:18:26,280
able to get interactive in under five

00:18:23,280 --> 00:18:28,530
seconds on 3G which is quite a nice feet

00:18:26,280 --> 00:18:30,780
now this didn't come without an amount

00:18:28,530 --> 00:18:32,820
of pain you know so you can use you know

00:18:30,780 --> 00:18:34,260
modern frameworks like react to shift

00:18:32,820 --> 00:18:36,300
aggressive web apps but you're going to

00:18:34,260 --> 00:18:37,800
have to put the work in to cut down on

00:18:36,300 --> 00:18:39,840
how much you know application code

00:18:37,800 --> 00:18:40,950
you've got going on there you're going

00:18:39,840 --> 00:18:42,090
to have to take advantage of code

00:18:40,950 --> 00:18:44,160
splitting you're going to have to make

00:18:42,090 --> 00:18:47,420
sure that you're just granularly loading

00:18:44,160 --> 00:18:50,280
and serving things in as well as you can

00:18:47,420 --> 00:18:52,710
so when Twitter first started working on

00:18:50,280 --> 00:18:54,150
this app early on they they had a

00:18:52,710 --> 00:18:56,160
relatively poor time to interactive

00:18:54,150 --> 00:18:58,140
score so they were looking at about 15

00:18:56,160 --> 00:18:59,400
16 milliseconds before anyone could

00:18:58,140 --> 00:19:01,830
actually start tapping around the

00:18:59,400 --> 00:19:05,610
interface so not too far away from where

00:19:01,830 --> 00:19:08,040
a lot of us probably are today most of

00:19:05,610 --> 00:19:10,560
their critical path was dominated by

00:19:08,040 --> 00:19:12,360
time spent in script just booting up and

00:19:10,560 --> 00:19:14,400
so they started taking a look at

00:19:12,360 --> 00:19:16,200
patterns like purple and and how they

00:19:14,400 --> 00:19:17,760
could take advantage of them the first

00:19:16,200 --> 00:19:20,010
thing they introduced was support for

00:19:17,760 --> 00:19:22,440
DNS prefetch so the ability to you know

00:19:20,010 --> 00:19:23,580
just specify declaratively what servers

00:19:22,440 --> 00:19:26,340
you want to start warming your DNS

00:19:23,580 --> 00:19:28,230
connections up to that led to an 18%

00:19:26,340 --> 00:19:30,000
perform performance improvement on what

00:19:28,230 --> 00:19:33,000
they initially had just for at least

00:19:30,000 --> 00:19:35,040
hitting things like FMP next they

00:19:33,000 --> 00:19:38,040
investigated using preload for their

00:19:35,040 --> 00:19:39,660
critical scripts I can't tell you how

00:19:38,040 --> 00:19:41,520
easy this stuff is to set up like this

00:19:39,660 --> 00:19:42,990
will take you you know if you're using a

00:19:41,520 --> 00:19:44,730
static site it's probably less than ten

00:19:42,990 --> 00:19:46,620
minutes if you're using something full

00:19:44,730 --> 00:19:48,660
stack it will probably take you an hour

00:19:46,620 --> 00:19:49,980
but it's we're trying out just to see if

00:19:48,660 --> 00:19:52,260
it actually has a perceivable

00:19:49,980 --> 00:19:53,820
improvement on your site so they ended

00:19:52,260 --> 00:19:55,290
up reloading their critical script so

00:19:53,820 --> 00:19:57,510
this is like their vendor bundle their

00:19:55,290 --> 00:19:59,550
synchronous chip scripts as well as

00:19:57,510 --> 00:20:03,750
their their main scripts that lets with

00:19:59,550 --> 00:20:06,680
36% improvement on their overall time to

00:20:03,750 --> 00:20:08,580
interactive next they put work into

00:20:06,680 --> 00:20:11,880
actually putting pixels on the screen

00:20:08,580 --> 00:20:13,980
much faster now Twitter is one of those

00:20:11,880 --> 00:20:16,200
experiences that are very you know

00:20:13,980 --> 00:20:19,170
meteor rich there's a lot of images in

00:20:16,200 --> 00:20:20,670
there and so it's unsurprising the media

00:20:19,170 --> 00:20:24,570
and images one of the things that were

00:20:20,670 --> 00:20:25,980
slowing them down render wise now one of

00:20:24,570 --> 00:20:27,750
the things they did was they used

00:20:25,980 --> 00:20:30,210
request I'll call back

00:20:27,750 --> 00:20:32,190
we defer loading of some of the images

00:20:30,210 --> 00:20:33,900
in their timeline and that led to a four

00:20:32,190 --> 00:20:36,210
times improvement on the render

00:20:33,900 --> 00:20:39,810
performance ric is kind of awesome

00:20:36,210 --> 00:20:41,700
definitely worth exploring another thing

00:20:39,810 --> 00:20:43,830
that they noticed was and this was kind

00:20:41,700 --> 00:20:46,050
of it's it's so silly but images are

00:20:43,830 --> 00:20:48,600
still such a big part of what slows us

00:20:46,050 --> 00:20:50,040
down these days they noticed that they

00:20:48,600 --> 00:20:52,230
were still sending down relatively large

00:20:50,040 --> 00:20:54,690
images that were not the right height or

00:20:52,230 --> 00:20:56,670
width that were still encoded you know

00:20:54,690 --> 00:20:58,350
sub-optimally and we're taking a long

00:20:56,670 --> 00:21:02,430
time to decode as soon as they hit

00:20:58,350 --> 00:21:04,260
chrome they went through the process of

00:21:02,430 --> 00:21:06,300
actually optimizing that and that shaved

00:21:04,260 --> 00:21:08,220
off a whole lot of time on their image

00:21:06,300 --> 00:21:10,200
decodes helped them to make sure that as

00:21:08,220 --> 00:21:11,430
you scroll through the timeline images

00:21:10,200 --> 00:21:12,660
are at least not one of those things

00:21:11,430 --> 00:21:14,970
that are causing you a bottleneck

00:21:12,660 --> 00:21:17,580
another thing that they introduced was

00:21:14,970 --> 00:21:19,920
data saver mode this is this idea that

00:21:17,580 --> 00:21:22,800
you as a user can say well I've got a

00:21:19,920 --> 00:21:24,990
limited data plan I just want you to not

00:21:22,800 --> 00:21:27,210
show any images or videos unless I

00:21:24,990 --> 00:21:30,030
actually tap on them and this led to a

00:21:27,210 --> 00:21:31,410
70 percent improvement in many cases on

00:21:30,030 --> 00:21:33,450
the amount of data consumed by the

00:21:31,410 --> 00:21:35,130
application if you're looking at a web

00:21:33,450 --> 00:21:38,280
platform level at what we're doing to

00:21:35,130 --> 00:21:40,470
try these types of experiences we've got

00:21:38,280 --> 00:21:42,150
the save data client int that you can

00:21:40,470 --> 00:21:44,580
use and Twitter going to investigate

00:21:42,150 --> 00:21:45,090
using that next then you've got free

00:21:44,580 --> 00:21:46,980
cash

00:21:45,090 --> 00:21:49,020
so initially Twitter Lite didn't have

00:21:46,980 --> 00:21:52,410
support for anything offline or

00:21:49,020 --> 00:21:54,240
serviceworker caching and what they did

00:21:52,410 --> 00:21:57,090
was they incremental II took an approach

00:21:54,240 --> 00:21:59,880
to adopting serviceworker they started

00:21:57,090 --> 00:22:02,670
off by first of all statically sort of

00:21:59,880 --> 00:22:04,440
caching their scripts the emoji they're

00:22:02,670 --> 00:22:07,800
used whenever you try DMing someone or

00:22:04,440 --> 00:22:09,720
applying to tweets as well as CSS and

00:22:07,800 --> 00:22:11,400
then they ramp that up over time to

00:22:09,720 --> 00:22:15,390
include things like application shell

00:22:11,400 --> 00:22:17,790
caching so UI caching now what that did

00:22:15,390 --> 00:22:22,560
on repeat visits was it took load time

00:22:17,790 --> 00:22:24,810
down from six point ten seconds down to

00:22:22,560 --> 00:22:26,550
one point four nine seconds so when you

00:22:24,810 --> 00:22:28,830
after the first time that you visit

00:22:26,550 --> 00:22:30,270
Twitter light it feels instant coming

00:22:28,830 --> 00:22:35,820
back and trying to navigate across

00:22:30,270 --> 00:22:40,200
different views it's pretty powerful now

00:22:35,820 --> 00:22:41,610
I was cheeky and asked twitter to like

00:22:40,200 --> 00:22:43,170
host 20 different versions

00:22:41,610 --> 00:22:44,429
their site so I could go and profile

00:22:43,170 --> 00:22:47,160
them and they were kind enough to do

00:22:44,429 --> 00:22:48,299
that now on second load without a

00:22:47,160 --> 00:22:50,250
serviceworker after some of these

00:22:48,299 --> 00:22:52,740
changes they saw that they were 47%

00:22:50,250 --> 00:22:54,720
faster on second load so repeat visits

00:22:52,740 --> 00:22:59,520
with a surface worker they're 65 percent

00:22:54,720 --> 00:23:01,170
faster and you've got lazy load so

00:22:59,520 --> 00:23:02,549
remember when we were looking so this is

00:23:01,170 --> 00:23:03,390
a lighthouse report if I didn't mention

00:23:02,549 --> 00:23:04,890
it before

00:23:03,390 --> 00:23:06,390
remember when we were saying earlier

00:23:04,890 --> 00:23:08,700
that their time to interactive scores

00:23:06,390 --> 00:23:11,100
kind of sucked and needed a little bit

00:23:08,700 --> 00:23:12,540
of work well breaking that work up was

00:23:11,100 --> 00:23:15,299
one of the first things they needed to

00:23:12,540 --> 00:23:17,640
do so they have to do these large blocks

00:23:15,299 --> 00:23:19,350
of like monolithic JavaScript bundles

00:23:17,640 --> 00:23:21,090
that I know people are like you know

00:23:19,350 --> 00:23:23,010
some people just don't look at me I'm

00:23:21,090 --> 00:23:24,990
not doing that but a lot of people

00:23:23,010 --> 00:23:27,299
actually still do this and that's

00:23:24,990 --> 00:23:29,309
relatively slow to load on mobile if you

00:23:27,299 --> 00:23:30,570
have a relatively large bundle even if

00:23:29,309 --> 00:23:32,309
you think that like you know a few

00:23:30,570 --> 00:23:33,929
hundred kilobytes isn't a lot that's

00:23:32,309 --> 00:23:36,090
still extra work the browser has to do

00:23:33,929 --> 00:23:38,370
to parse and compile that code before it

00:23:36,090 --> 00:23:40,860
can even you know start to boot it up so

00:23:38,370 --> 00:23:42,210
initially their bundles were taking five

00:23:40,860 --> 00:23:45,990
and a half seconds five and a half

00:23:42,210 --> 00:23:48,510
second dish to get ready before code

00:23:45,990 --> 00:23:49,770
splitting and then they had this great

00:23:48,510 --> 00:23:51,270
moment where they're trying to figure

00:23:49,770 --> 00:23:53,910
out how you're supposed to configure web

00:23:51,270 --> 00:23:54,929
pack and are still having the best of

00:23:53,910 --> 00:23:57,830
times with it

00:23:54,929 --> 00:24:01,380
I hear it's gone better with web pack -

00:23:57,830 --> 00:24:03,210
we'll see and one of the things that

00:24:01,380 --> 00:24:04,799
they ended up doing was this is this is

00:24:03,210 --> 00:24:06,360
a lot of what their code splitting

00:24:04,799 --> 00:24:08,340
looks like beyond just just using

00:24:06,360 --> 00:24:09,600
require done ensure they're just making

00:24:08,340 --> 00:24:11,370
sure that they're correctly using sort

00:24:09,600 --> 00:24:13,500
of vendor splitting for all of their

00:24:11,370 --> 00:24:15,809
bundles across different views Twitter

00:24:13,500 --> 00:24:18,390
ended up creating something like 40

00:24:15,809 --> 00:24:20,820
different a synchronous chunks that are

00:24:18,390 --> 00:24:25,500
granularly loaded as you navigate from

00:24:20,820 --> 00:24:26,850
one view to the other and the impact

00:24:25,500 --> 00:24:28,320
that that had on their experience was

00:24:26,850 --> 00:24:30,780
that that actual bundle ended up only

00:24:28,320 --> 00:24:33,000
taking about three seconds to fully

00:24:30,780 --> 00:24:35,730
process and it improved their overall

00:24:33,000 --> 00:24:37,080
times interactive by the end of it

00:24:35,730 --> 00:24:39,299
they're actually doing much better than

00:24:37,080 --> 00:24:41,610
this now but by the end of it they were

00:24:39,299 --> 00:24:43,590
getting interactive in about 5.7 seconds

00:24:41,610 --> 00:24:45,660
which is still impressive as an

00:24:43,590 --> 00:24:48,330
investment in just code splitting and

00:24:45,660 --> 00:24:52,960
some relatively low friction ideas

00:24:48,330 --> 00:24:55,100
around efficient loading so

00:24:52,960 --> 00:24:57,860
one other thing that they ended up

00:24:55,100 --> 00:24:59,540
finding was incredibly invaluable and

00:24:57,860 --> 00:25:01,340
have been coming back to it pretty

00:24:59,540 --> 00:25:02,960
regularly is just making sure that

00:25:01,340 --> 00:25:05,240
they're using bundle analyzers like

00:25:02,960 --> 00:25:07,010
webpack bundle analyzer to find out what

00:25:05,240 --> 00:25:09,770
low-hanging fruit they have in their

00:25:07,010 --> 00:25:11,810
bundles I keep running into people they

00:25:09,770 --> 00:25:13,700
don't realize that moment J s or other

00:25:11,810 --> 00:25:14,990
libraries are actually a big part of

00:25:13,700 --> 00:25:17,240
their bundles and can probably be

00:25:14,990 --> 00:25:19,010
trimmed down so if you're not using

00:25:17,240 --> 00:25:21,560
things like web pack bundle analyzer or

00:25:19,010 --> 00:25:23,960
source map Explorer do check them out

00:25:21,560 --> 00:25:25,520
they do generally lead to at least

00:25:23,960 --> 00:25:28,210
understanding a little bit more about

00:25:25,520 --> 00:25:31,430
what it is you're sending down the wire

00:25:28,210 --> 00:25:32,930
and in Twitter's case they were making

00:25:31,430 --> 00:25:35,000
sure that they were using the bundle

00:25:32,930 --> 00:25:36,080
analyzer plugin so that every single

00:25:35,000 --> 00:25:37,610
time someone was actually working

00:25:36,080 --> 00:25:39,980
directly on the application they could

00:25:37,610 --> 00:25:42,560
see what impact that ended up having on

00:25:39,980 --> 00:25:47,390
their bundle site on their actual bundle

00:25:42,560 --> 00:25:50,210
shape so performance is sort of this

00:25:47,390 --> 00:25:52,520
continuous game of measuring for areas

00:25:50,210 --> 00:25:54,620
to improve there isn't a single thing

00:25:52,520 --> 00:25:56,390
that you can do and then just leave it

00:25:54,620 --> 00:25:58,850
where your site is going to you know

00:25:56,390 --> 00:26:00,700
always be fast regardless of the devices

00:25:58,850 --> 00:26:03,620
that your users end up trying it out on

00:26:00,700 --> 00:26:06,800
for anyone that is interested in sort of

00:26:03,620 --> 00:26:08,450
getting involved with more continuous

00:26:06,800 --> 00:26:09,950
performance profiling you know where

00:26:08,450 --> 00:26:11,680
your team are staying on top of it and

00:26:09,950 --> 00:26:14,180
you're building up a performance culture

00:26:11,680 --> 00:26:16,280
I'm happy to encourage you trying out

00:26:14,180 --> 00:26:19,910
lighthouse it's one of the projects that

00:26:16,280 --> 00:26:21,680
we work on lighthouse sort of is a is an

00:26:19,910 --> 00:26:23,390
auditing tool for both performance

00:26:21,680 --> 00:26:25,300
metrics but also progressive web app

00:26:23,390 --> 00:26:28,970
features and general web performance of

00:26:25,300 --> 00:26:32,450
web platform best practices and I'm also

00:26:28,970 --> 00:26:35,210
happy to suggest trying out calibre by

00:26:32,450 --> 00:26:37,430
Ben Schwartz calibre is sort of great in

00:26:35,210 --> 00:26:39,530
that it allows you over time to track

00:26:37,430 --> 00:26:41,210
everything from your bundle size through

00:26:39,530 --> 00:26:42,620
to different performance metrics and see

00:26:41,210 --> 00:26:45,320
you know what impact your different

00:26:42,620 --> 00:26:47,990
employees had over time so check that

00:26:45,320 --> 00:26:50,990
out and I'd also encourage people to

00:26:47,990 --> 00:26:53,780
check out web page test integration with

00:26:50,990 --> 00:26:55,250
your git hooks housing comm is a

00:26:53,780 --> 00:26:56,690
progressive web app that did this and

00:26:55,250 --> 00:26:59,360
basically they have this really awesome

00:26:56,690 --> 00:27:02,240
setup where any time someone tries to

00:26:59,360 --> 00:27:04,070
submit a new PR for a feature it runs it

00:27:02,240 --> 00:27:04,610
through web page test and will include a

00:27:04,070 --> 00:27:06,070
filmstrip

00:27:04,610 --> 00:27:07,960
at the very bottom of your Pia

00:27:06,070 --> 00:27:13,990
are to show exactly what impact that had

00:27:07,960 --> 00:27:16,000
on user experience so with that I hope

00:27:13,990 --> 00:27:17,800
you found this little journey into

00:27:16,000 --> 00:27:19,720
loading useful I hope you found the

00:27:17,800 --> 00:27:25,480
story about some of the experiences we

00:27:19,720 --> 00:27:27,430
had with Twitter useful I know that you

00:27:25,480 --> 00:27:29,680
know Twitter of Twitter is great it also

00:27:27,430 --> 00:27:32,410
sometimes feels like group therapy where

00:27:29,680 --> 00:27:36,010
no one ever it gets any better that it's

00:27:32,410 --> 00:27:36,940
it's great so yeah if if you're

00:27:36,010 --> 00:27:40,330
interested in learning a little bit more

00:27:36,940 --> 00:27:42,610
about loading we started a new blog over

00:27:40,330 --> 00:27:44,710
on a crime scene called reloading on

00:27:42,610 --> 00:27:46,960
medium so medium.com slash reloading and

00:27:44,710 --> 00:27:48,190
we intend on publishing more material

00:27:46,960 --> 00:27:50,950
there over the next coming months about

00:27:48,190 --> 00:27:53,350
everything from h to server push through

00:27:50,950 --> 00:27:54,310
to broadly Gretz lee and a lot of the

00:27:53,350 --> 00:27:56,950
other work that we're doing in the

00:27:54,310 --> 00:27:57,690
loading space and that's it for me thank

00:27:56,950 --> 00:28:01,509
you

00:27:57,690 --> 00:28:01,509
[Applause]

00:28:04,250 --> 00:28:06,310

YouTube URL: https://www.youtube.com/watch?v=7vUs5yOuv-o


