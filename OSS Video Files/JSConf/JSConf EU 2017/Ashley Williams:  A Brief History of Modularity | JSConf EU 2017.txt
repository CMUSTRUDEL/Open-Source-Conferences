Title: Ashley Williams:  A Brief History of Modularity | JSConf EU 2017
Publication date: 2017-05-20
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/ashley-williams-a-brief-history-of-modularity.html
Slides: https://ashleygwilliams.github.io/jsconfeu-2017/#1

“MAKE IT MODULAR,” they said. “IT WILL BE BETTER,” they said. Modularity is a term so common in today’s software industry, that it’s easy to uncritically accept it as a fundamental software development principle. but what does “modularity” actually mean? Where does this idea come from? Where is it going? This talk will walk us through the technical etymology of “modularity”, stepping through the intellectual breakthroughs alongside the fast spread misconceptions. We’ll conclude by exploring the implications of modularity’s ill-examined history on both its current use today, and where it’s heading in the future.
Captions: 
	00:00:03,100 --> 00:00:05,859
"A Brief History of Modularity" Ashley Williams

00:00:05,859 --> 00:00:06,859
>> Hi, everyone!

00:00:06,859 --> 00:00:07,859
Okay.

00:00:07,859 --> 00:00:09,020
I'm feeling the excitement here.

00:00:09,020 --> 00:00:11,000
We're in the last track.

00:00:11,000 --> 00:00:15,340
We have three more talks to go before we start partying.

00:00:15,340 --> 00:00:17,710
So our next speaker is Ashley.

00:00:17,710 --> 00:00:20,080
She is from New York City.

00:00:20,080 --> 00:00:22,850
This is the New York City track.

00:00:22,850 --> 00:00:25,610
We have four speakers from New York.

00:00:25,610 --> 00:00:29,170
So she works at npm, AKA Wombat Development Union.

00:00:29,170 --> 00:00:31,610
You'll have to ask her about that later.

00:00:31,610 --> 00:00:32,610
She loves explaining it.

00:00:32,610 --> 00:00:33,610
So she was heavily featured in the introduction video, actually, so that was a little bit

00:00:33,610 --> 00:00:34,610
of a preview.

00:00:34,610 --> 00:00:35,610
We're going to see the full Monty now.

00:00:35,610 --> 00:00:36,610
So here's actually with a brief history of modularity.

00:00:36,610 --> 00:00:37,610
Give her a round of applause.

00:00:37,610 --> 00:00:38,610
ASHLEY: All right.

00:00:38,610 --> 00:00:39,610
Here everybody.

00:00:39,610 --> 00:00:40,610
This is good.

00:00:40,610 --> 00:00:41,610
As you filter in, I'm going to start my talk a little strange and read to you from the

00:00:41,610 --> 00:00:43,909
namesake of this talk, which is Stephen Hawking's A Brief History of Time.

00:00:43,909 --> 00:00:52,809
So this is from chapter one, a picture of the universe, a well known scientist, once

00:00:52,809 --> 00:00:59,180
known -- he described how the Earth orbits around the sun and how the sun, in turn, orbits

00:00:59,180 --> 00:01:04,530
around the center of a vast collection of star called a galaxy typical at the end of

00:01:04,530 --> 00:01:10,750
the lecture a little old lady got up in the back of the room and said, what you have told

00:01:10,750 --> 00:01:12,920
us is rubbish.

00:01:12,920 --> 00:01:18,740
The world is a giant plate supported on the back of a tortoise.

00:01:18,740 --> 00:01:27,509
And the scientist gave a reply saying: Well, what is the tortoise standing on, said the

00:01:27,509 --> 00:01:29,729
scientist.

00:01:29,729 --> 00:01:37,619
You're very clever, young man, very clever, old lady, but it's turtles all the way down.

00:01:37,619 --> 00:01:44,060
Now you might be wondering that our universe is some sort of plate and there are turtles

00:01:44,060 --> 00:01:45,060
floating in space.

00:01:45,060 --> 00:01:51,369
You might think that that's an odd idea but this talk is going to be the kind of talk

00:01:51,369 --> 00:01:56,040
that's going to ask you to look at some of the concepts that you take for granted and

00:01:56,040 --> 00:01:58,409
ask you you think they're true.

00:01:58,409 --> 00:02:05,049
Now why on earth would something like that, with turtles in space have to do with JavaScript.

00:02:05,049 --> 00:02:08,930
And, hopefully, by the end of this talk, you'll have figured it out.

00:02:08,930 --> 00:02:09,930
All right.

00:02:09,930 --> 00:02:13,790
So, hi, my name is Ashley Williams, as was introduced.

00:02:13,790 --> 00:02:19,680
You may know me from Twitter as @agdubs, and if you do, I'm very sorry, don't follow.

00:02:19,680 --> 00:02:20,840
I'm terrible.

00:02:20,840 --> 00:02:24,190
I work at this company that you would npm.

00:02:24,190 --> 00:02:27,110
Anybody heard of npm?

00:02:27,110 --> 00:02:31,670
And that's where I work as a services engineer.

00:02:31,670 --> 00:02:35,250
Shout out to the fact that we've released npm 5.

00:02:35,250 --> 00:02:36,270
Download it.

00:02:36,270 --> 00:02:37,670
It's cool.

00:02:37,670 --> 00:02:39,280
This talk is not about that.

00:02:39,280 --> 00:02:42,920
But if you want to talk about that, find me.

00:02:42,920 --> 00:02:46,860
If you're the type of person that watches slides, and sees a typo, and can't handle

00:02:46,860 --> 00:02:50,290
themselves, please submit a PR.

00:02:50,290 --> 00:02:53,170
I'm always very happy for them.

00:02:53,170 --> 00:02:59,560
So I always like to start my talks saying I like to think about thinking, particularly

00:02:59,560 --> 00:03:04,870
the kind of thinking that happens when people write code and the point of this talk today

00:03:04,870 --> 00:03:11,830
is to maybe get you to also think, at least about the type of thinking that you do when

00:03:11,830 --> 00:03:13,040
you write code.

00:03:13,040 --> 00:03:16,330
So to get that thinking started, I'm going to pose you with this.

00:03:16,330 --> 00:03:21,970
I'm not going to give you my answer quite yet but this is a PR that came into a repo

00:03:21,970 --> 00:03:27,660
for a documentation project for a programming language, and they interested remove the jQuery

00:03:27,660 --> 00:03:33,590
dependency by adding 400, and removing 200.

00:03:33,590 --> 00:03:40,230
So this comes into play with dependency, and modularity.

00:03:40,230 --> 00:03:45,260
How many people think that this is a really obvious thing to choose, accepted or not?

00:03:45,260 --> 00:03:47,120
All right, good.

00:03:47,120 --> 00:03:48,780
This talk's for you!

00:03:48,780 --> 00:03:50,910
All right.

00:03:50,910 --> 00:03:55,610
So I'm one of these people who has, for a very long time been a teacher as well as an

00:03:55,610 --> 00:04:01,230
engineer and I'd like to say that teaching is nature's way of letting you know how sloppy

00:04:01,230 --> 00:04:02,720
your thinking is.

00:04:02,720 --> 00:04:08,870
And over a long period of time of teaching people Node across the world, some people

00:04:08,870 --> 00:04:14,670
in the audience are in these photos, we've run into some fascinating questions from beginners.

00:04:14,670 --> 00:04:19,410
Now, here's one of the more fascinating ones and this is actually one of student of Steve

00:04:19,410 --> 00:04:25,420
Kinney's asked him, how did you get permission to publish a module on npm.

00:04:25,420 --> 00:04:26,840
True question.

00:04:26,840 --> 00:04:31,820
Many beginners think that you have to get permission, that there's an exceptionalism

00:04:31,820 --> 00:04:34,210
of being able to publish a package.

00:04:34,210 --> 00:04:40,120
But I hope you know that is not the case, literally anyone can publish a package on

00:04:40,120 --> 00:04:41,120
npm.

00:04:41,120 --> 00:04:47,940
Now once you get the idea of who can publish, the next one is how do you decide what goes

00:04:47,940 --> 00:04:50,340
inside a module?

00:04:50,340 --> 00:04:55,250
So like a proper scientist and wanting to get the correct answer, I went to Twitter

00:04:55,250 --> 00:05:00,540
as I always do, because I was like, hey, what's your primary motivation for writing, or using

00:05:00,540 --> 00:05:01,620
modular code?

00:05:01,620 --> 00:05:04,570
Now, I got a huge number of responses.

00:05:04,570 --> 00:05:06,870
This is a topic that a lot of people like.

00:05:06,870 --> 00:05:10,080
But it was interesting because the responses were very diverse.

00:05:10,080 --> 00:05:14,150
So one of the first sets of responses I got was that people believed that being able to

00:05:14,150 --> 00:05:19,410
write modular code made them more disciplined, made debugging the code easier, made it easier

00:05:19,410 --> 00:05:21,750
to test or document.

00:05:21,750 --> 00:05:27,330
Alternatively, some people wrote that they made their code modular for reuse so that

00:05:27,330 --> 00:05:30,450
they could do something in the future in case their code changed.

00:05:30,450 --> 00:05:36,060
I put Bradley on his own slide in a talk about modularity, you gotta give Bradley a shout-out

00:05:36,060 --> 00:05:43,130
for all the work that he's done for ES6 modules, so if you like ES6 modules, particularly in

00:05:43,130 --> 00:05:44,870
Node, you should thank him.

00:05:44,870 --> 00:05:49,110
So, of course, it was Twitter, so there were some shit posts, and they might have been

00:05:49,110 --> 00:05:55,480
from some of the conference organizers that you know, we'll let those be.

00:05:55,480 --> 00:06:00,960
But the biggest thing that we got was this idea of being able to reuse things, and in

00:06:00,960 --> 00:06:03,360
particular, reuse things by separating concerns.

00:06:03,360 --> 00:06:07,530
Now, lots of people love this term separation of concerns, to the point that a lot of people

00:06:07,530 --> 00:06:13,260
said it exactly in their responses but I thought it was awful vague that it was so specific

00:06:13,260 --> 00:06:18,060
what people were saying, so I tried to push the question a bit further and I said, okay,

00:06:18,060 --> 00:06:22,980
separation of concerns, how do you decide what the concerns are?

00:06:22,980 --> 00:06:24,980
And this really stumped people.

00:06:24,980 --> 00:06:30,919
People went from having ones of verbose answers to going... uh, intuition mostly?

00:06:30,919 --> 00:06:32,980
Said this person.

00:06:32,980 --> 00:06:39,850
This person suggested throwing darts, which is about as scientific you can get, I guess.

00:06:39,850 --> 00:06:46,530
Now even one of my JavaScript heroes, Ryan Haberbeek, who is here as an expert, who wrote

00:06:46,530 --> 00:06:52,440
the book I learned JavaScript from, even he had an answer that, you know what, there are

00:06:52,440 --> 00:06:58,220
a lot of practical, and ethical, and even aesthetic considerations to this question

00:06:58,220 --> 00:07:04,810
of how you separate out your code and here's the punchline, the absolute best answer of

00:07:04,810 --> 00:07:11,770
how do you split up your code is people got mad when I put it all in one file.

00:07:11,770 --> 00:07:16,919
So you remember this from the intro that I was not here for but saw on Twitter, I guess

00:07:16,919 --> 00:07:19,720
a lot of people got mad.

00:07:19,720 --> 00:07:25,160
But believe it or not, people do get mad in programming quite a bit and I could see how

00:07:25,160 --> 00:07:29,080
if someone put their application all in one file, there would be a bunch of people grumping

00:07:29,080 --> 00:07:31,950
about it.

00:07:31,950 --> 00:07:36,380
But looking at the summary of these things it was it was really interesting because people

00:07:36,380 --> 00:07:44,040
didn't have an idea or how or why it was a module.

00:07:44,040 --> 00:07:49,090
However, overwhelmingly everyone thought that it was good.

00:07:49,090 --> 00:07:52,460
No one respond with: Don't modularize your code.

00:07:52,460 --> 00:07:56,870
So we're in this interesting positions where there's a lot of people who feel very interested

00:07:56,870 --> 00:08:01,310
in something but don't have a solid grasp of why.

00:08:01,310 --> 00:08:07,260
So this made me think, okay, we have this huge batch of stuff, and maybe individually

00:08:07,260 --> 00:08:13,220
they all make sense but we don't have a coherent picture of the world, a bit like this store,

00:08:13,220 --> 00:08:17,540
which is a real store outside of Madison Square Garden in New York City.

00:08:17,540 --> 00:08:23,160
I don't know if it capitalizes on all it promises but I would assume it does.

00:08:23,160 --> 00:08:28,580
So this made me think, and I did this classic Ashley think that other people who might not

00:08:28,580 --> 00:08:31,010
know me, might not think a normal person would do.

00:08:31,010 --> 00:08:35,880
They would say, oh, the way that people think about modularity is the way people think about

00:08:35,880 --> 00:08:37,699
time.

00:08:37,699 --> 00:08:43,370
You know, people have this really intuitionistic idea that time passes but no one has any friggin'

00:08:43,370 --> 00:08:46,189
idea of how time works.

00:08:46,189 --> 00:08:50,430
If you do think you have an idea, you should find me at the party because I'm really interested.

00:08:50,430 --> 00:08:56,740
But yeah, this made me think, I love this book, A Brief History of Time, and it goes

00:08:56,740 --> 00:09:02,850
through and chronicles the history of how we've been thinking about the universe.

00:09:02,850 --> 00:09:07,069
So my goal today is not necessarily to give you any answers but I do want to talk about

00:09:07,069 --> 00:09:12,070
the ways that we think about modularity, and particularly give us some pointers to get

00:09:12,070 --> 00:09:16,430
us in the right direction when we talk about splitting our code because, fundamentally,

00:09:16,430 --> 00:09:21,410
splitting our code is so important and so critical to our daily lives that it's pretty

00:09:21,410 --> 00:09:27,300
unsettling that we haven't really examined it as closely as I think we should.

00:09:27,300 --> 00:09:31,720
So I feel like I'm in a pretty good space to talk about this because the package ecosystem,

00:09:31,720 --> 00:09:36,600
I personally think is JavaScript's picture of the universe, and working at npm, I'm pretty

00:09:36,600 --> 00:09:38,720
close to that ecosystem.

00:09:38,720 --> 00:09:42,190
So npm, I've checked this probably a week ago.

00:09:42,190 --> 00:09:51,110
We have 472,000 packages, which puts us about -- by an -- three times as much as the next

00:09:51,110 --> 00:09:52,579
package ecosystem.

00:09:52,579 --> 00:09:59,209
So packages and modularity mean a lot to JavaScript because npm is the largest module repository

00:09:59,209 --> 00:10:00,870
in the world.

00:10:00,870 --> 00:10:02,990
Potentially, the universe.

00:10:02,990 --> 00:10:05,130
I don't know if aliens have package managers.

00:10:05,130 --> 00:10:08,029
But I feel like we'd be in the running, all right?

00:10:08,029 --> 00:10:10,579
But what I want to do is ask: Okay.

00:10:10,579 --> 00:10:12,499
Why is this the case, right?

00:10:12,499 --> 00:10:15,759
Why are we, like, modularize all the things!

00:10:15,759 --> 00:10:17,860
Cut my code into pieces.

00:10:17,860 --> 00:10:19,589
This is my JavaScript!

00:10:19,589 --> 00:10:20,589
[ Laughter ]

00:10:20,589 --> 00:10:21,879
Sorry, I had to do a pizza joke.

00:10:21,879 --> 00:10:22,879
I had to.

00:10:22,879 --> 00:10:23,879
It's late.

00:10:23,879 --> 00:10:25,450
Gotta get you guys going!

00:10:25,450 --> 00:10:26,450
Anyways.

00:10:26,450 --> 00:10:27,600
Now lets get really serious.

00:10:27,600 --> 00:10:30,200
This is a proper computer science talk.

00:10:30,200 --> 00:10:37,399
So let's, Dijkstra, right, so Dijkstra is in a unique position that they have to think

00:10:37,399 --> 00:10:48,060
in computational hierarchies, the automatic computer, lol, the automatic computer, haha,

00:10:48,060 --> 00:10:53,119
the automatic computer confronts us with a radical new intellectual challenge that has

00:10:53,119 --> 00:10:55,290
no precedent in our history.

00:10:55,290 --> 00:11:01,200
So I'm not, like, the biggest fan of computer science exceptionalism but I definitely think

00:11:01,200 --> 00:11:04,350
that he's definitely onto something here.

00:11:04,350 --> 00:11:08,740
Modularity is the way, we as programmers, address this challenge that we need to be

00:11:08,740 --> 00:11:12,240
thinking in very, very deep conceptual hierarchies.

00:11:12,240 --> 00:11:13,540
All right.

00:11:13,540 --> 00:11:18,189
So we know kind of the problem that modularity is solving but what is modularity?

00:11:18,189 --> 00:11:23,120
So, again, to the good sources, let's do a little Wikipedia.

00:11:23,120 --> 00:11:28,339
Modular programming is a software-design technique that emphasizes separating the functionality

00:11:28,339 --> 00:11:34,480
of a program into independent, interchangeable modules, such that each contains everything

00:11:34,480 --> 00:11:40,410
necessary to execute only one aspect of the desired functionality.

00:11:40,410 --> 00:11:44,809
So you may or may not be getting the idea but I'm a little worried about this one aspect

00:11:44,809 --> 00:11:49,670
part of it and that seems to be the clincher of that definition, all right?

00:11:49,670 --> 00:11:53,660
So in JavaScript we have this idea called the small-modules philosophy.

00:11:53,660 --> 00:11:55,949
How many people here have heard of that?

00:11:55,949 --> 00:11:57,300
How many people like it?

00:11:57,300 --> 00:11:58,300
Interesting.

00:11:58,300 --> 00:11:59,489
All right.

00:11:59,489 --> 00:12:03,319
So what are the fiercest fighters for the small-modules philosophy?

00:12:03,319 --> 00:12:08,060
And he does it with his actions because he's probably one of the most prolific publishers

00:12:08,060 --> 00:12:13,279
on npm is cindersaurus, and he says, it's all about containing complexity.

00:12:13,279 --> 00:12:19,690
By making small, focused modules, you can build large, complex systems without having

00:12:19,690 --> 00:12:24,399
to know every single detail of how everything works.

00:12:24,399 --> 00:12:27,500
Our short-term memory is finite.

00:12:27,500 --> 00:12:31,760
So this doesn't get us terribly closer to where we should separate things; but it is

00:12:31,760 --> 00:12:37,089
certainly suggesting that we have a biological constraint that's gonna require us to make

00:12:37,089 --> 00:12:42,779
small packages so that we're able to actually understand the thing that we're working on,

00:12:42,779 --> 00:12:43,930
all right?

00:12:43,930 --> 00:12:48,519
So that's obviously begs the question: How small is too small?

00:12:48,519 --> 00:12:51,769
Now this is a classic critique of packages on npm.

00:12:51,769 --> 00:12:53,949
People love getting upset about this.

00:12:53,949 --> 00:12:56,579
The one-line Node modules program.

00:12:56,579 --> 00:13:03,089
People don't like these, however, they are installed constantly, continue to be published

00:13:03,089 --> 00:13:07,089
and are some of the absolute most popular packages on npm.

00:13:07,089 --> 00:13:12,730
So you have to ask yourself for all this critique, why is it that we continue to use them?

00:13:12,730 --> 00:13:18,699
Now I can't talk about these one-line Node modules without talking about, dun-dun-dun

00:13:18,699 --> 00:13:19,829
Left Pad.

00:13:19,829 --> 00:13:23,779
Warning, if you make jokes about Left Pad to me, I'll get really upset, okay?

00:13:23,779 --> 00:13:30,319
But that being said, I think Left Pad is really interesting to talk about because it brings

00:13:30,319 --> 00:13:37,329
up this idea that at which point are we leveraging modularity too much.

00:13:37,329 --> 00:13:47,010
Because at one time, someone did this package and it's only 11 lines of code here.

00:13:47,010 --> 00:13:52,299
Is it worth it to have a way of abstracting this code out?

00:13:52,299 --> 00:13:54,560
Is this doing us any good?

00:13:54,560 --> 00:13:59,699
So I think actually that Left Pad was most fascinating for me was that people started

00:13:59,699 --> 00:14:06,559
getting really aggressive and they suggested that even the existence of a Left Pad module

00:14:06,559 --> 00:14:11,509
meant that we had somehow forgotten how to program, that using this at all meant that

00:14:11,509 --> 00:14:16,670
we were terrible programmers and so I kind of need a minute here, all right?

00:14:16,670 --> 00:14:20,449
This makes me think of this talk, which if you've seen it, or seen me online, you know

00:14:20,449 --> 00:14:21,699
I'm not a fan of.

00:14:21,699 --> 00:14:26,250
Which is this idea that there's this real programmer out there, and if you use any sort

00:14:26,250 --> 00:14:32,920
of tools, be it a build process, or a packager, or anything that contains 11 lines of code,

00:14:32,920 --> 00:14:37,519
you're not a web developer and I just have to say, that's not cool.

00:14:37,519 --> 00:14:43,100
Building small, reusable abstractions is the foundation of literally all computer science.

00:14:43,100 --> 00:14:49,249
So did we forget to program when we stopped writing C, stopped writing assembly, stopped

00:14:49,249 --> 00:14:54,179
doing electrical engineering, which I can only say vaguely because I have no idea what

00:14:54,179 --> 00:14:55,179
that would be called.

00:14:55,179 --> 00:14:57,999
I assume it has to do with soldering, I don't know.

00:14:57,999 --> 00:15:03,089
But this idea there's no true programmer because you use tools.

00:15:03,089 --> 00:15:06,839
It's the Node true Scotsman fallacy, but I won't go through with that.

00:15:06,839 --> 00:15:15,779
So if you think you're not a programmer because you use tools, I'll have none of that.

00:15:15,779 --> 00:15:21,670
What I will say is that making time for modules is a great idea because this is what I envision

00:15:21,670 --> 00:15:24,149
as the best type of application.

00:15:24,149 --> 00:15:31,329
So substack who's also a prolific author on npm describes this applications this way:

00:15:31,329 --> 00:15:40,279
When applications are done well, they're really the application-specific brackish res do you

00:15:40,279 --> 00:15:42,480
that cannot be abstracted away.

00:15:42,480 --> 00:15:49,589
All the reusable components s sublimate on npm where people can use it of the commons.

00:15:49,589 --> 00:16:02,199
And if you know me, I'm a big fan of the commons, but commons are hard and [Inaudible] and it

00:16:02,199 --> 00:16:06,350
proves that we can do the commons right.

00:16:06,350 --> 00:16:09,699
This is the graph of our weekly downloads.

00:16:09,699 --> 00:16:16,290
At this point, npm is averaging 2 billion downloads a week, which means something about

00:16:16,290 --> 00:16:21,089
breaking things into tiny packages is working well, all right?

00:16:21,089 --> 00:16:24,790
So this doesn't necessarily mean that it's without problems.

00:16:24,790 --> 00:16:29,879
So this is an Alex Norris comment and so you can just read there: I want things to be different.

00:16:29,879 --> 00:16:31,989
I want things to be modular!

00:16:31,989 --> 00:16:33,819
Oh, no.

00:16:33,819 --> 00:16:35,670
All right?

00:16:35,670 --> 00:16:39,790
So this is what it comes to, this fantastic book called John Gald which is about system

00:16:39,790 --> 00:16:44,559
semantics which is about how systems work, but especially about how they fail.

00:16:44,559 --> 00:16:48,470
And so he says a complex system that works is invariably found to have evolved from a

00:16:48,470 --> 00:16:53,749
simpler system that worked, a complex system designed from scratch never works and can

00:16:53,749 --> 00:16:55,720
never be patched up to make it work.

00:16:55,720 --> 00:16:58,299
You have to start over with a simple system.

00:16:58,299 --> 00:17:04,480
And, right now, in the JavaScript ecosystem, we have a complex system, and this complex

00:17:04,480 --> 00:17:06,890
system has been causing us problems.

00:17:06,890 --> 00:17:11,169
And so from now on I'm going to talk a little bit about the problems in modularity.

00:17:11,169 --> 00:17:16,220
So Nolan Lawson wrote: The more I modularized my code, the bigger it gets.

00:17:16,220 --> 00:17:21,230
Over 400 milliseconds is being spent walking my browserified tree.

00:17:21,230 --> 00:17:25,929
And so he wrote this really interesting article called the cost of small modules, and the

00:17:25,929 --> 00:17:32,519
subtitle is why one horse-sized JavaScript duck is faster than a hundred duck-sized JavaScript

00:17:32,519 --> 00:17:34,620
horses.

00:17:34,620 --> 00:17:40,850
And I said, come on, this is perfect but the interesting thing he goes into this is a typical

00:17:40,850 --> 00:17:45,580
web application has ton of little modules and the reason it has a ton of little modules

00:17:45,580 --> 00:17:49,960
is because this really improves developer experience, all right?

00:17:49,960 --> 00:17:56,820
There's lots of these tools that we take for prepare for when we push our code into production.

00:17:56,820 --> 00:18:03,549
Now, these tools are extremely important because modularizing code helps us as developers but

00:18:03,549 --> 00:18:07,539
it doesn't come without a cost, all right?

00:18:07,539 --> 00:18:11,130
So one of the things that he notes in his article is the fact that even just splitting

00:18:11,130 --> 00:18:17,240
our code up into closures, into different functions is actually costing us a lot of

00:18:17,240 --> 00:18:18,690
time at runtime.

00:18:18,690 --> 00:18:25,179
So looking at stuff like webpack and Browserify, and something like roll-up closure which moves

00:18:25,179 --> 00:18:30,450
you everything up into a single closure, actually if you look at these graphs, has a significant

00:18:30,450 --> 00:18:32,450
amount of runtime improvement.

00:18:32,450 --> 00:18:37,059
There's very little of that orange runtime when you're maintaining the modularity in

00:18:37,059 --> 00:18:42,340
your runtime code versus when you're going to use something that takes that modularity

00:18:42,340 --> 00:18:44,340
and collapses it.

00:18:44,340 --> 00:18:49,559
And also, by the way, there's tons of new ones.

00:18:49,559 --> 00:18:52,110
There's a new one that just came out just a few days ago.

00:18:52,110 --> 00:18:54,420
It's pretty neat and it's doing the same thing.

00:18:54,420 --> 00:18:58,269
It's collapsing this ability to be able to modularize our code and be able to collapse

00:18:58,269 --> 00:19:05,360
it into one thing because preserving that modularity actually hurts our users because

00:19:05,360 --> 00:19:09,789
I told them that they have to stop publishing new tools because I'll never finish this talk

00:19:09,789 --> 00:19:16,340
and I'll also never finish on time but the goal here is to say that the use of modularity

00:19:16,340 --> 00:19:22,370
has grown to such a scale that web developers are being confronted with ideas that we've

00:19:22,370 --> 00:19:24,670
never anticipated.

00:19:24,670 --> 00:19:28,590
Oftentimes when you think about performance in web development, we think about network

00:19:28,590 --> 00:19:29,590
latency.

00:19:29,590 --> 00:19:33,179
Obviously, we're like, how long is it going to take over the network but actually it turns

00:19:33,179 --> 00:19:39,309
out that with the number of modules that we are using across all of the devices that we

00:19:39,309 --> 00:19:45,279
have, particularly, low-power devices, low-level programming concepts are now more relevant

00:19:45,279 --> 00:19:51,690
to web developers than ever and we're a little bit not prepared to understand this.

00:19:51,690 --> 00:19:57,809
And so I'd like to say, I for one, welcome our new compiler transpiler overlords because

00:19:57,809 --> 00:20:03,990
we need a way to mitigate the stuff that we do to improve our developer experience and

00:20:03,990 --> 00:20:07,769
not have that cost end up on our end users.

00:20:07,769 --> 00:20:10,220
So Rich Harris, I think, says this really great.

00:20:10,220 --> 00:20:16,750
He says: Yes, smaller modules are easier to write, easier to test, and easier to adhere

00:20:16,750 --> 00:20:17,750
to sember.

00:20:17,750 --> 00:20:23,590
These are all things that make your life, as a library author easier.

00:20:23,590 --> 00:20:28,200
As we've seen, they come at a cost for others.

00:20:28,200 --> 00:20:34,740
So the small-modules philosophy totally benefits the library writers but it disadvantages application

00:20:34,740 --> 00:20:38,380
writers because they have to deal with all of those tiny pieces when they're putting

00:20:38,380 --> 00:20:42,929
something together, and, fundamentally, because that's extremely difficult, it turns out that

00:20:42,929 --> 00:20:47,820
that modularity actually harms end users by costing them time.

00:20:47,820 --> 00:20:49,549
So how did we end up here?

00:20:49,549 --> 00:20:50,549
All right?

00:20:50,549 --> 00:20:56,769
And I love to quote Thomas Kuhn here who says, science through models through subsequent

00:20:56,769 --> 00:21:01,510
exposure to literature without knowing, or needing to know the characteristics that have

00:21:01,510 --> 00:21:04,429
given these models the status of community paradigms.

00:21:04,429 --> 00:21:10,820
What I'm saying is that it's been a little inconvenient for us to interrogator why we

00:21:10,820 --> 00:21:12,740
love modularity so much.

00:21:12,740 --> 00:21:17,470
We see it happening, and the tools keep happening and this is how we use it.

00:21:17,470 --> 00:21:25,930
This is the page of the npm SeigeBot and she's saying here, your monolith is complex, your

00:21:25,930 --> 00:21:32,600
application is complex, but to split it up to modularize it actually makes it more complex.

00:21:32,600 --> 00:21:34,049
So we're kind of complex.

00:21:34,049 --> 00:21:39,309
So we're kind of in a pixel here because I'm saying that modularity makes it easier but

00:21:39,309 --> 00:21:41,690
it's also making it harder.

00:21:41,690 --> 00:21:48,340
This is some graffiti that I saw in San Francisco, my solution is probably worse than the problem

00:21:48,340 --> 00:21:51,590
so we're now in another oh-no situation.

00:21:51,590 --> 00:21:56,970
So this is one of my favorite computer scientists, Rich Hickey, and I says most of the problems

00:21:56,970 --> 00:22:02,700
of computer software are problems of conception so I want us to be focused on the problems

00:22:02,700 --> 00:22:05,280
of day to day work.

00:22:05,280 --> 00:22:09,840
So what I'd like to say is that when we think about programming, software development is

00:22:09,840 --> 00:22:10,950
change management.

00:22:10,950 --> 00:22:16,139
That's why we have version control, that's why we have Sember, the hardest fact about

00:22:16,139 --> 00:22:20,549
programming is that it changes and this is actually really interesting because this really

00:22:20,549 --> 00:22:27,049
is featured briefly in A Brief History of Time by Stephen Hawking because he says: It's

00:22:27,049 --> 00:22:34,740
an interesting reflection on the characteristic of thought that no one had suggested that

00:22:34,740 --> 00:22:37,760
the universe was expanding or contracting.

00:22:37,760 --> 00:22:41,830
Which is to say when we tried to paint a picture of the universe, they never thought that the

00:22:41,830 --> 00:22:45,250
universe would have changed, they just assumed that it was exactly the way it was.

00:22:45,250 --> 00:22:49,919
And I think oftentimes when we think about breaking up our code, we evaluate it in that

00:22:49,919 --> 00:22:52,539
same, static way.

00:22:52,539 --> 00:22:57,110
So it turns out that I was, like, I did ask Twitter how do you modularize.

00:22:57,110 --> 00:23:04,210
And I did go to Google Scholar and looked on how to module and there's an amazing paper

00:23:04,210 --> 00:23:10,400
by an author named David Parnus and the paper is called On the Criteria to be Used on Decomposing

00:23:10,400 --> 00:23:15,380
Systems into Modules and it turns out that he has an answer that nobody provided when

00:23:15,380 --> 00:23:17,539
I asked on Twitter.

00:23:17,539 --> 00:23:22,250
This is what he said, he said: Start with a list of difficult design decisions or design

00:23:22,250 --> 00:23:24,610
decisions that are likely to change.

00:23:24,610 --> 00:23:31,940
Each module is then designed to hide such a decision from the others.

00:23:31,940 --> 00:23:33,080
So here's the trick.

00:23:33,080 --> 00:23:34,190
The goal of modularity.

00:23:34,190 --> 00:23:39,990
We can always talk about it as making our lives easier but the truth of the matter we

00:23:39,990 --> 00:23:46,240
should be using modularity to solve things that are hard.

00:23:46,240 --> 00:23:52,170
So all of a sudden you might be like, I had a conception about modularity that aren't

00:23:52,170 --> 00:23:54,549
correct, how do I go about computerring.

00:23:54,549 --> 00:24:03,549
Richard says, no one is born knowing how to write software.

00:24:03,549 --> 00:24:05,309
I don't even know how to do it right now.

00:24:05,309 --> 00:24:08,070
I'm still trying to figure it out.

00:24:08,070 --> 00:24:11,649
So you might be in despair.

00:24:11,649 --> 00:24:19,770
So this is a have famous existential philosopher, Jean Paul-Sartre, and he quotes this book,

00:24:19,770 --> 00:24:26,269
In Programming in C: Every line of code is written without reason, maintained out of

00:24:26,269 --> 00:24:29,250
weakness, and deleted by chance.

00:24:29,250 --> 00:24:31,769
I need some water.

00:24:31,769 --> 00:24:39,529
Anyways but based on this level of despair, what he suggests that we do is we suggest

00:24:39,529 --> 00:24:46,269
not only do we write code to help our programs change, but we should be not focusing on code

00:24:46,269 --> 00:24:51,040
that's easy to extend, but, rather, code that is easy to delete.

00:24:51,040 --> 00:24:56,740
He says write code that is easy to delete, not easy to extend.

00:24:56,740 --> 00:25:01,540
Instead of building reusable software, we should try to build disposable software.

00:25:01,540 --> 00:25:09,590
I can't tell you that deleting code is more fun than writing code.

00:25:09,590 --> 00:25:15,379
So we come back to this question of do we delete this jQuery dependency.

00:25:15,379 --> 00:25:21,600
So what I thought was very interesting about this was there's a lot of questions to ask

00:25:21,600 --> 00:25:22,700
about this.

00:25:22,700 --> 00:25:30,950
But in the end, using the PR, and accepting the jQuery dependency is what people thought.

00:25:30,950 --> 00:25:37,299
And more than what people saying their feelings about jQuery, what I do think it indicated

00:25:37,299 --> 00:25:42,559
so that we're kind of seeing a return to conservativism in the way that we are thinking about using

00:25:42,559 --> 00:25:45,679
modules and packages in our programming.

00:25:45,679 --> 00:25:48,580
For a long time, we were using modules totally uncritically.

00:25:48,580 --> 00:25:52,809
We were doing a lot of work, including lots of them and we're seeing a lot of people go

00:25:52,809 --> 00:25:56,769
the opposite direction now and there's a lot more of this not invented here.

00:25:56,769 --> 00:25:58,540
I'm going to bundle in my code.

00:25:58,540 --> 00:26:01,559
And not use a package, all right?

00:26:01,559 --> 00:26:06,100
But what I want to say is I think there's a really amazing challenge here and that instead

00:26:06,100 --> 00:26:11,879
of just rejecting the idea of using tons of modularity, we should be looking for new solutions.

00:26:11,879 --> 00:26:16,240
Modularity is an old problem that we're dealing with but at a brand-new scale that I think

00:26:16,240 --> 00:26:17,840
is really exciting.

00:26:17,840 --> 00:26:23,470
So I had asked recently a couple of -- a few months after the first time, why do you choose

00:26:23,470 --> 00:26:29,009
to split your code and so one of my coworkers, Chris Dickinson actually had a really awesome

00:26:29,009 --> 00:26:30,009
answer.

00:26:30,009 --> 00:26:36,140
He said I have two answers, the first one is kind of like what I would say, like, academically,

00:26:36,140 --> 00:26:40,429
but the other one is actually how I think I really feel and what he says is: Programming

00:26:40,429 --> 00:26:44,549
is like a maze that humans lack the language to describe completely.

00:26:44,549 --> 00:26:47,679
With practice you start to internalize the maze.

00:26:47,679 --> 00:26:52,429
And so that can seem pretty bad and what I want to say is internalizing and utilizing

00:26:52,429 --> 00:26:54,090
intuition isn't super terrible.

00:26:54,090 --> 00:26:56,929
It turns out dogs know calculus which is pretty neat.

00:26:56,929 --> 00:27:00,950
You can read about this guy and his corgis to pick up a ball.

00:27:00,950 --> 00:27:06,740
They're actually able to calculate the most efficient route, they're made of star stuff.

00:27:06,740 --> 00:27:12,330
So we can always use intuition to figure out how to use modularity.

00:27:12,330 --> 00:27:16,789
So we can all be a bunch of corgis.

00:27:16,789 --> 00:27:22,399
So in summary, modularize your code to make your life easier for sure but the way that

00:27:22,399 --> 00:27:28,090
you modularize, the way that you separate it out is by isolating things that are hard.

00:27:28,090 --> 00:27:30,019
That's how you're going to make your life easier.

00:27:30,019 --> 00:27:33,120
And in fact, modularizing is not free.

00:27:33,120 --> 00:27:38,700
It's actually pretty expensive and the consequences could be for you for other developers and

00:27:38,700 --> 00:27:40,410
also as you are end users.

00:27:40,410 --> 00:27:48,150
So this helps you -- too many people are are all like, I don't know what all that fancy

00:27:48,150 --> 00:27:50,009
stuff is, I don't need that.

00:27:50,009 --> 00:27:54,519
No, they're solving problems that you already have, so you should be looking into these

00:27:54,519 --> 00:27:56,130
tools and using them.

00:27:56,130 --> 00:28:00,549
And, finally, this is a fast-moving space right now, and there's not a lot of definitive

00:28:00,549 --> 00:28:04,559
answers and I can't help but know that on Twitter recently, there's been a lot of really

00:28:04,559 --> 00:28:11,919
nasty conversations about this, so I want to say, quit being jerks on Twitter, all right?

00:28:11,919 --> 00:28:16,179
So I think this problem is far from being solved and I think getting more meet me into

00:28:16,179 --> 00:28:21,570
this conversations and critically interrogating what we think about modularity is super important.

00:28:21,570 --> 00:28:22,679
So I'll end with this.

00:28:22,679 --> 00:28:29,049
This is from Julia Evans who everyone got mad at when she put it in one file.

00:28:29,049 --> 00:28:35,919
She says: The more programming I do, the more things I run into, I don't know, Google doesn't

00:28:35,919 --> 00:28:42,909
know, my colleagues don't know, but we gotta do it anyway and when this happens, she says,

00:28:42,909 --> 00:28:48,009
right, this is why they pay a human with a brain who can investigate and learn, and these

00:28:48,009 --> 00:28:50,940
should be the problems we're most excited to solve.

00:28:50,940 --> 00:28:51,940
Thank you so much.

00:28:51,940 --> 00:28:54,269
This is all of the sources from the talk.

00:28:54,269 --> 00:28:55,269
Install npm 5!

00:28:55,269 --> 00:28:56,269
[ Applause ]

00:28:56,269 --> 00:28:57,269
>> Thank you so much, Ashley.

00:28:57,269 --> 00:28:58,269
That was really amazing.

00:28:58,269 --> 00:28:59,269
And before you go, I took a photo of this.

00:28:59,269 --> 00:29:00,269
So this store, in New York, that sells karate hip hop action/drama headphones and luxury.

00:29:00,269 --> 00:29:01,269
Have you ever been in this store?

00:29:01,269 --> 00:29:02,269
ASHLEY: No, I just stood outside.

00:29:02,269 --> 00:29:02,276

YouTube URL: https://www.youtube.com/watch?v=vypCsVm5z28


