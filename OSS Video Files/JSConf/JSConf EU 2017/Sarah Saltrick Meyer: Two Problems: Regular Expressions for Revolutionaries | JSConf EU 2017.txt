Title: Sarah Saltrick Meyer: Two Problems: Regular Expressions for Revolutionaries | JSConf EU 2017
Publication date: 2017-05-20
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/sarah-saltrick-meyer-two-problems-regular-expressions-for-revolutionaries.html

There’s an old software joke that goes: “Some people, when confronted with a problem, reach for regular expressions. Now they have two problems.” Regular expressions are a web developer’s best friend and worst nightmare. Sure, you’re glad someone posted the regex pattern for a phone number on Stack Overflow, but when the intern asked you to explain what a “capture group” was, you broke into a cold sweat. So is a “regex” the same thing as a regular expression? How are regular expressions implemented in JavaScript? And just what do Alan Turing and Noam Chomsky have to do with all of this?
Captions: 
	00:00:00,170 --> 00:00:01,170
Two Problems: Regular Expressions for Revolutionaries Sarah Saltrick Meyer

00:00:24,140 --> 00:00:30,740
[Applause] SARAH: Hi guys, thank you so much for the

00:00:30,740 --> 00:00:32,210
warm welcome.

00:00:32,210 --> 00:00:39,410
JSConf really is a conference among conferences and it's really a pleasure to be here.

00:00:39,410 --> 00:00:42,579
So the name of this talk is: Two Problems.

00:00:42,579 --> 00:00:48,960
It is in fact to talk about regular expressions, if regular expressions are something that

00:00:48,960 --> 00:00:52,649
scare you please take a seat and sit down, this talk is for you.

00:00:52,649 --> 00:00:56,100
If regular expressions are something you love and feel very comfortable with, also this

00:00:56,100 --> 00:00:59,019
talk is for you.

00:00:59,019 --> 00:01:00,719
So who am I?

00:01:00,719 --> 00:01:05,379
My name is Sarah Saltrick Meyer and I'm a web developer based out of New York and I

00:01:05,379 --> 00:01:11,009
work for a company called Buzz feed again doing web dev.

00:01:11,009 --> 00:01:19,880
So there's a real classic and wonderful joke about web expressions.

00:01:19,880 --> 00:01:25,299
Some people when confronted with a problem think: I know, I will use regular expressions.

00:01:25,299 --> 00:01:28,610
Now they have two problems.

00:01:28,610 --> 00:01:32,899
You may have heard this joke from the person sitting next to you at your first job, that's

00:01:32,899 --> 00:01:40,109
certainly when I first heard it, but the actual source of the quote is a guy named Jamie Zawinski

00:01:40,109 --> 00:01:49,560
on a group in 1997 and Jamie was an Emacs devotee, approaching the status of a religion

00:01:49,560 --> 00:01:55,600
for him apparently, and he hated Perl with a passion.

00:01:55,600 --> 00:02:01,650
One of his other really meaty quotes is: Perl combines the power of C with the readability

00:02:01,650 --> 00:02:03,539
of PostScript.

00:02:03,539 --> 00:02:07,560
So clearly a man of strong opinions and pithy statements.

00:02:07,560 --> 00:02:10,239
Why would he say this?

00:02:10,239 --> 00:02:14,050
Regular expressions are a great tool, aren't they?

00:02:14,050 --> 00:02:22,120
You can use them in a HTML input box to validate the form of input.

00:02:22,120 --> 00:02:26,260
Obviously you use them all the time when you are trying to match an pattern in text.

00:02:26,260 --> 00:02:38,070
I've seen websites ... but why would regular expressions be a problem?

00:02:38,070 --> 00:02:41,810
I rather think it's because of things like this.

00:02:41,810 --> 00:02:44,319
Can you all actually read this here?

00:02:44,319 --> 00:02:47,349
Use your hand if you can read it.

00:02:47,349 --> 00:02:54,250
Okay, okay, so does anyone recognise this nasty scrum of characters and numbers?

00:02:54,250 --> 00:02:59,400
US phone number, thank you!

00:02:59,400 --> 00:03:01,440
And wow, it's just gross, isn't it?

00:03:01,440 --> 00:03:07,409
It's just nasty, looks like something you would pick off the bottom of your shoe programming-wise,

00:03:07,409 --> 00:03:14,720
and so the reason I think that people - regular expressions are a problem even as they solve

00:03:14,720 --> 00:03:18,720
problems for us is this lack of comprehensibility.

00:03:18,720 --> 00:03:29,280
When I need a regular expression at work, I Google it, so I would just Google regular

00:03:29,280 --> 00:03:33,939
expression for a phone number and take that top Stack Overflow answer and probably most

00:03:33,939 --> 00:03:42,390
people would do the same, but regular expressions are something more than just something that

00:03:42,390 --> 00:03:46,310
we, you know, can take somebody else's advice for.

00:03:46,310 --> 00:03:52,061
They are more than something where you find the experienced senior dev in the room, or

00:03:52,061 --> 00:03:59,189
maybe the one person who you know is a regex whizz and you go ask them for it.

00:03:59,189 --> 00:04:02,189
They can also be something like this.

00:04:02,189 --> 00:04:10,989
So I totally stole this beautiful graph from JavaScript [inaudible], a classic, and this

00:04:10,989 --> 00:04:17,910
is a description of the various ways that white space can be evaluated that code can

00:04:17,910 --> 00:04:25,060
sort of not be evaluated within JavaScript, and let's run through them [sound problem]

00:04:25,060 --> 00:04:26,060
... here.

00:04:26,060 --> 00:04:28,440
Obviously a space will just be a space.

00:04:28,440 --> 00:04:34,860
A tab will just be evaluated as a tab, and a line end similarly, nothing will happen.

00:04:34,860 --> 00:04:43,540
But then we get down into here, so if the parser is running and hits a forward slash,

00:04:43,540 --> 00:04:48,560
well then, if it sees another forward slash and then it sees any character except for

00:04:48,560 --> 00:04:55,950
a line end, and it can seen any numbers, so what is that?

00:04:55,950 --> 00:04:59,140
Of course, it's a comment, yes.

00:04:59,140 --> 00:05:06,040
Then it gets a little bit more complicated, of course, for our beautiful multiline comment.

00:05:06,040 --> 00:05:12,140
We have the forward slash, we have an asterisk, ooh, and then I can optionally - you see it's

00:05:12,140 --> 00:05:16,850
not on the path here - I can optionally have another forward slash but then I have to have

00:05:16,850 --> 00:05:21,810
any character except the slash and the asterisk, and I can have as many of those as I want.

00:05:21,810 --> 00:05:30,060
But I have to finish off with another asterisk before my final forward slash, and the real

00:05:30,060 --> 00:05:36,730
meaning of this diagram here is that you cannot - you can have slashes and asterisks within

00:05:36,730 --> 00:05:42,040
your comment but if you have a slash and then an asterisk, you've closed the comment.

00:05:42,040 --> 00:05:43,900
And you are done.

00:05:43,900 --> 00:05:47,300
So, gosh, well what does this have to do with regular expressions?

00:05:47,300 --> 00:05:51,530
This is a regular expression I wrote for you guys very specially.

00:05:51,530 --> 00:05:57,210
It really broke my brain, it felt like a test in school because I did actually used to do

00:05:57,210 --> 00:06:03,540
this at school, I would have a regular diagram like that and have to turn it into a regular

00:06:03,540 --> 00:06:07,710
expression, not with Perl syntax though, this is Perl syntax which of course is also used

00:06:07,710 --> 00:06:10,050
in JavaScript.

00:06:10,050 --> 00:06:16,760
Without going into it too much, we have the simple cases, we have a space here, a tab,

00:06:16,760 --> 00:06:19,580
ooh and then it starts to get clicked.

00:06:19,580 --> 00:06:27,180
We have these escaped slashes and then line ends, and then this incredibly nasty thing

00:06:27,180 --> 00:06:33,170
is the - you can have asterisks and slashes but they can't be next to each other unless

00:06:33,170 --> 00:06:35,350
you are closing out.

00:06:35,350 --> 00:06:40,310
So, what exactly is a regular expression, my gosh?

00:06:40,310 --> 00:06:44,670
They were defined in the 1950s before there was such a thing as an automatic computer

00:06:44,670 --> 00:06:46,760
really.

00:06:46,760 --> 00:06:52,410
So they pre-date the actual machines that we could our work on and they were defined

00:06:52,410 --> 00:06:57,490
by a wonderful guy named Stephen Culchrane who you love even if you don't know who he

00:06:57,490 --> 00:07:05,220
is because he is responsible for this little star, the clean star, which you probably use

00:07:05,220 --> 00:07:10,250
all the time.

00:07:10,250 --> 00:07:16,340
The clean star is not part of regular expressions per se; it's rather, I would say, a notation

00:07:16,340 --> 00:07:21,960
that we very frequently use in regular expressions and probably the most commonly used of all

00:07:21,960 --> 00:07:26,450
pattern matchers is: tick everything, star.

00:07:26,450 --> 00:07:28,440
Yes, I love this very much.

00:07:28,440 --> 00:07:31,940
I think it's very pretty and also useful.

00:07:31,940 --> 00:07:34,690
So what exactly makes a regular expression?

00:07:34,690 --> 00:07:40,840
It's a set of characters that describe other characters with origins in the attempt to

00:07:40,840 --> 00:07:45,490
describe natural language in a computable way.

00:07:45,490 --> 00:07:51,000
So we have that pipe.

00:07:51,000 --> 00:07:57,770
We have the concept of grouping, the notion that if I have ABCD, or AXYD then that is

00:07:57,770 --> 00:08:05,190
equivalent to ABC or XYD; and then lastly, quantification.

00:08:05,190 --> 00:08:14,970
This syntax may be familiar to you, the question mark is I believe 01, the star is of course

00:08:14,970 --> 00:08:20,950
0 pipe, and the plus is 11 or more.

00:08:20,950 --> 00:08:22,330
So we've got all that.

00:08:22,330 --> 00:08:27,480
We kind of know what we are talking about here, but let's try to place regular expressions

00:08:27,480 --> 00:08:35,250
in sort of a wider world of concepts, a wider world of attempts to describe language, and

00:08:35,250 --> 00:08:41,430
actually we think of ourselves as web developers, we do code, but code is language and it is

00:08:41,430 --> 00:08:46,690
specifically an attempt to translate human language into language that computers can

00:08:46,690 --> 00:08:52,320
understand, and regular expressions are just one in a whole set of toolboxes for doing

00:08:52,320 --> 00:08:57,949
this, and they were described by this gentleman, who may be familiar to you, this is Noam Chomsky,

00:08:57,949 --> 00:09:05,370
who in addition to his wonderful political opinions also is responsible for the Chomsky

00:09:05,370 --> 00:09:10,710
Hierarchy of Grammars so as you can see regular expressions are down here, the most limited

00:09:10,710 --> 00:09:15,920
subset of the Noam Chomsky hierarchy and then we work air way up through the context free

00:09:15,920 --> 00:09:22,040
and others, so what are these?

00:09:22,040 --> 00:09:26,769
Actually the type zero unrestricted grammar is something that you are also all familiar

00:09:26,769 --> 00:09:32,880
with and I say I am familiar with these machines in the same way as regular expressions - I'm

00:09:32,880 --> 00:09:38,610
certainly not an expert, I just know they help me do the things I need to do.

00:09:38,610 --> 00:09:40,170
What exactly is a Turing machine?

00:09:40,170 --> 00:09:44,709
This is a Turing machine that somebody built with Lego.

00:09:44,709 --> 00:09:48,660
It has wheels and goes back and forth.

00:09:48,660 --> 00:09:57,860
We have a beautiful quote which I am going to read out: a Turing machine is an unlimited

00:09:57,860 --> 00:10:02,839
memory capacity obtained in the form of an infinite tape marked out onto squares on each

00:10:02,839 --> 00:10:04,589
of which a symbol could be printed.

00:10:04,589 --> 00:10:09,250
At any moment there is one symbol in the machine, it is called the scan symbol.

00:10:09,250 --> 00:10:13,540
The machine can alter the scan symbol and its behaviour is in part determined by that

00:10:13,540 --> 00:10:18,279
symbol but the symbols on the tape elsewhere do not affect the behaviour of the machine.

00:10:18,279 --> 00:10:24,319
However, the tape can be moved back and forth, this being one of the elementary operations

00:10:24,319 --> 00:10:25,569
of the machine.

00:10:25,569 --> 00:10:28,540
Any symbol on the tape may therefore eventually have an innings.

00:10:28,540 --> 00:10:33,149
That is a quote from Alan Turing, I think in addition to being a brilliant computer

00:10:33,149 --> 00:10:38,879
scientist and truly the father of the industry that we work in now, he was a lovely writer

00:10:38,879 --> 00:10:39,879
as well.

00:10:39,879 --> 00:10:45,399
So Alan Turing, of course, committed suicide after he began to be persecuted by the British

00:10:45,399 --> 00:10:49,970
Government for being gay, and I think there's a lot of irony in the fact that a man who

00:10:49,970 --> 00:10:57,220
contributed so much to our understanding of patterns and communication literally died

00:10:57,220 --> 00:11:02,620
for not fitting a pattern that was prescribed by the society that he lived in.

00:11:02,620 --> 00:11:07,649
Well, moving right along, type 1 grammars, they are boring.

00:11:07,649 --> 00:11:10,310
I don't really understand what the use case is for them.

00:11:10,310 --> 00:11:12,660
It seems to be mostly theoretical.

00:11:12,660 --> 00:11:19,339
But they are called context-sensitive because they come with a little bit of context.

00:11:19,339 --> 00:11:23,249
So I don't know them, I don't know her.

00:11:23,249 --> 00:11:28,370
The type 2 grammars on the other hand, I'm not going to read out all this math, it comes

00:11:28,370 --> 00:11:33,980
from Wikipedia, I do encourage you to look this up, but most programming languages are

00:11:33,980 --> 00:11:39,870
interpreted by computers as type 2 languages so as we are moving up this hierarchy here.

00:11:39,870 --> 00:11:44,589
And type 2 has something extremely important, type 2 languages have a stack.

00:11:44,589 --> 00:11:48,560
So you will note that in a regular - of course, in a regular expression there's no concept

00:11:48,560 --> 00:11:50,490
of memory.

00:11:50,490 --> 00:11:56,160
You are only - you don't know, as you are matching that pattern, the things that you've

00:11:56,160 --> 00:12:01,160
seen before but once you have the introduction of a stack you can keep track of the past

00:12:01,160 --> 00:12:06,850
and use it to help you evaluate the current input.

00:12:06,850 --> 00:12:13,069
Then type 3 grammars are irregular expressions and they are equivalent to finite-state automata

00:12:13,069 --> 00:12:18,899
which is something else you may have used, perhaps a finite-state machine library for

00:12:18,899 --> 00:12:25,350
some context at work so regular expressions are mathematically equivalent, they can always

00:12:25,350 --> 00:12:32,160
be translated in between each other, and this is a picture from my native city.

00:12:32,160 --> 00:12:39,610
These are some turnstiles at a subway stop in Harlem and subway turnstiles are actually

00:12:39,610 --> 00:12:45,560
one of the classic examples of a finite-state machine, and I will show you how.

00:12:45,560 --> 00:12:49,850
So the way that a turnstile used to work, now pretend that the coin is a Metro card

00:12:49,850 --> 00:12:57,770
swipe, these coins are obsolete unfortunately, if the machine is locked then no matter how

00:12:57,770 --> 00:12:59,870
much you push, nothing will happen.

00:12:59,870 --> 00:13:01,579
You return to the locked state.

00:13:01,579 --> 00:13:06,439
But if you put in a coin, then you are in the unlocked state and no matter how many

00:13:06,439 --> 00:13:09,980
coins you put in, it will still be unlocked, you have done nothing to it.

00:13:09,980 --> 00:13:14,459
I have actually done this, swiped my Metro card accidentally multiple times, spending

00:13:14,459 --> 00:13:22,070
$275 each time, very frustrating, but then if you push through the turnstile, you return

00:13:22,070 --> 00:13:27,509
to that locked state and you can only get out of it again by putting in a coin.

00:13:27,509 --> 00:13:37,769
So you could actually write a regular expression for this where you represent where the coin

00:13:37,769 --> 00:13:47,149
and push would be your letters, your characters in it, and the locked and unlocked states

00:13:47,149 --> 00:13:51,829
would be the potential states that you could get to.

00:13:51,829 --> 00:13:57,439
So one thing that you may have heard, it's another thing that I heard sort of second

00:13:57,439 --> 00:14:03,249
hand at my first job, is that you can't parse HTML with a regular expression and the reason

00:14:03,249 --> 00:14:10,779
for that is the same thing that I said about the context free grammars, they have a stack,

00:14:10,779 --> 00:14:11,779
right?

00:14:11,779 --> 00:14:14,850
So to parse HTML we need that stack.

00:14:14,850 --> 00:14:20,399
We need to put down the HTML tag and then we need to put down the body tag and then

00:14:20,399 --> 00:14:26,209
we need to put down our headers and build up that stack and as we unparse or get to

00:14:26,209 --> 00:14:32,639
the end of the execution, we start popping those elements, author stack as we see their

00:14:32,639 --> 00:14:39,149
closing tags, and that's how we get proper HTML parsing, so that again because regular

00:14:39,149 --> 00:14:45,459
expressions do not have a stack, do not have a sense of memory, cannot be done with a true

00:14:45,459 --> 00:14:47,449
regular expression.

00:14:47,449 --> 00:14:52,709
But the regular expressions that you use in programming languages like JavaScript which

00:14:52,709 --> 00:15:00,569
takes its implementation from Perl, and Perl I think has been the most significant influence

00:15:00,569 --> 00:15:06,769
on the development of regular expressions in sort of day-to-day programming - you know,

00:15:06,769 --> 00:15:10,139
I personally, one of the very first things I ever had to do that somebody paid me to

00:15:10,139 --> 00:15:15,540
write code for was to write Perl scripts to parse some documents and put them into a different

00:15:15,540 --> 00:15:16,600
directory structure.

00:15:16,600 --> 00:15:18,800
It's a good task for an intern actually.

00:15:18,800 --> 00:15:20,980
You learn a lot.

00:15:20,980 --> 00:15:32,809
So Perl expressions have features, those negative look-aheads that make them no longer pure

00:15:32,809 --> 00:15:40,269
regular expressions but capable of a wider variety of tasks than true regular expressions

00:15:40,269 --> 00:15:42,339
are.

00:15:42,339 --> 00:15:48,779
So from that I have a quote from Larry Wall who did create Perl so probably the worst

00:15:48,779 --> 00:15:54,089
enemy of that Jamie guy I quoted earlier.

00:15:54,089 --> 00:16:00,050
"The term has grown with the capabilities of our pattern-matching engines, so I am not

00:16:00,050 --> 00:16:02,160
going to fight linguistic necessity here."

00:16:02,160 --> 00:16:03,250
A wise man.

00:16:03,250 --> 00:16:15,819
"I will, however, call them regexes ..." so what's the difference really?

00:16:15,819 --> 00:16:23,179
Those regular expressions meet the criteria, the deterministic criteria in particular it's

00:16:23,179 --> 00:16:27,910
important to remember, that each of its transitions is uniquely determined by its source state

00:16:27,910 --> 00:16:34,819
and input symbol and reading an input symbol is important for each transition; with the

00:16:34,819 --> 00:16:48,290
power of modern regexes, has actually become quite divorced from the underpinning of the

00:16:48,290 --> 00:16:51,610
regular concept, lovely as those are.

00:16:51,610 --> 00:16:59,929
So again a regex has only its state and a Turing machine has memory, and regexes therefore

00:16:59,929 --> 00:17:05,490
are appropriate for a sort of service level parsing of information.

00:17:05,490 --> 00:17:08,790
They are very useful and they help us a lot.

00:17:08,790 --> 00:17:17,950
They still are only one tool for us and as with many things, as with many things in programming,

00:17:17,950 --> 00:17:20,590
right, a limit is not necessarily bad.

00:17:20,590 --> 00:17:26,110
If you were using a limited set of tools, you may see better performance because there

00:17:26,110 --> 00:17:36,140
is less that it has to do, whereas so regexes exist then in a very limited world that is

00:17:36,140 --> 00:17:43,640
connected to a much broader world of computation and of the attempt to let computers understand

00:17:43,640 --> 00:17:50,650
humans, so there's a sort of a sad ending to a lot of the attempts to describe human

00:17:50,650 --> 00:17:57,550
language that many like Turing and Chomsky were working on, and this was sort of the

00:17:57,550 --> 00:18:06,110
post-war attempt to turn human language into a set of rules that machines could understand

00:18:06,110 --> 00:18:13,860
easily and the notion that we would be able to find a theoretical description of all human

00:18:13,860 --> 00:18:15,200
language.

00:18:15,200 --> 00:18:19,110
I think as programmers you all know better than anyone else that we are never going to

00:18:19,110 --> 00:18:20,390
achieve that, right?

00:18:20,390 --> 00:18:28,250
We are probably never going to write a programme that deterministically understands human input.

00:18:28,250 --> 00:18:34,510
This is actually, the rise of machine learning and non-deterministic algorithms to parse

00:18:34,510 --> 00:18:42,510
language is a recognition of the notion that we don't have - we will never find a true

00:18:42,510 --> 00:18:48,240
answer, a correct answer; we can only throw a bunch of guesses at the wall and determine

00:18:48,240 --> 00:18:53,810
which one is closest to our understanding as humans.

00:18:53,810 --> 00:19:00,730
So I will leave you with - there wasn't that much JavaScript in this talk, right?

00:19:00,730 --> 00:19:02,960
So it's right here.

00:19:02,960 --> 00:19:07,710
This is about the implementation of other expressions than JavaScript.

00:19:07,710 --> 00:19:12,670
Of course you may declare a regular expression in one of two ways, either with those lovely

00:19:12,670 --> 00:19:23,640
backslashes or with the regex constructure so the previous one is for a value that will

00:19:23,640 --> 00:19:28,740
never change whereas if you want to construct a regex dynamically and have it evaluated,

00:19:28,740 --> 00:19:33,960
please use the constructor and enjoy writing regular expressions in JavaScript.

00:19:33,960 --> 00:19:35,990
I certainly do.

00:19:35,990 --> 00:19:42,000
So here I have been thinking a lot about regular expressions since making this talk.

00:19:42,000 --> 00:19:54,510
I sort of have a vision of applications as being modelled like that turnstile, of designers

00:19:54,510 --> 00:20:03,370
making automata ... and then somehow turning that into regular expression.

00:20:03,370 --> 00:20:07,340
I don't know how that would look but it's really cool.

00:20:07,340 --> 00:20:12,770
They are also really good with games, so write that with a regular expression.

00:20:12,770 --> 00:20:19,840
I think you could also make some cool web art [sound problem] ... obviously writing

00:20:19,840 --> 00:20:28,560
a chatbot that's too obvious for words, but a lot of us, because we are web developers

00:20:28,560 --> 00:20:35,990
and eager to take any tool that works, we - if we don't know about the theoretical underpinnings

00:20:35,990 --> 00:20:40,000
of this they can remain very opaque and difficult to understand.

00:20:40,000 --> 00:20:43,890
I have a math background and still look at the Wikipedia definition of these things and,

00:20:43,890 --> 00:20:52,740
oh, it breaks my brain, but knowledge and education is a treasure and knowing how things

00:20:52,740 --> 00:20:58,130
work, even if it's not going to help you in your day-to-day is, I think, something that

00:20:58,130 --> 00:21:02,400
is very beautiful and very useful, and it will enrich your understanding of what you

00:21:02,400 --> 00:21:04,450
do on a day-to-day basis.

00:21:04,450 --> 00:21:12,360
So seek out theory, and also don't blame other people for not having knowledge of theory.

00:21:12,360 --> 00:21:16,880
Get as much as you can and give as much to other people, and I think that's the way to

00:21:16,880 --> 00:21:18,680
be a truly effective programmer.

00:21:18,680 --> 00:21:21,590
Thank you very much.

00:21:21,590 --> 00:21:22,320

YouTube URL: https://www.youtube.com/watch?v=4dv53Ft4s9c


