Title: Jan Krutisch: Æsthetics of code | JSConf EU 2017
Publication date: 2017-05-26
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/jan-krutisch-aesthetics-of-code.html

Of course you know what beautiful code looks like. Too bad nobody actually agrees with you. So, what exactly makes beautiful code? Is it readability? Elegance? Simplicity? How much of it depends on the programming language, on your coding style and on the actual code you’re writing? The presentation will contain nothing but code and thus the talk will be largely non-technical.
Captions: 
	00:00:00,170 --> 00:00:01,170
AEsthetics of code Jan Krutisch

00:00:26,630 --> 00:00:30,760
[Applause] JAN: Thank you very much.

00:00:30,760 --> 00:00:34,879
It's always an honour to speak at this conference, and for me it's the second time, that kind

00:00:34,879 --> 00:00:36,589
of amazes me.

00:00:36,589 --> 00:00:45,309
Anyway, so how many of you have actually read the description of the talk?

00:00:45,309 --> 00:00:51,569
Okay, so there's this thing in there where I say my presentation will contain nothing

00:00:51,569 --> 00:01:00,399
but code, and as you can clearly see I'm already tricking you because this is actually code.

00:01:00,399 --> 00:01:07,670
You can take this, you can execute it in your browser console and it's thanks to works of

00:01:07,670 --> 00:01:16,340
a friend of mine, Martin Kleppe, who presented this at JSConf 2013, and it basically turns

00:01:16,340 --> 00:01:21,210
arbitrary JavaScript code into this weird thing that only has six different characters,

00:01:21,210 --> 00:01:27,409
I think, and it's completely oblivious to white space, so I was able to turn it down

00:01:27,409 --> 00:01:34,479
into these things that actually resemble title slides.

00:01:34,479 --> 00:01:41,689
And I was speaking yesterday to someone who mentioned that in the title on the schedule

00:01:41,689 --> 00:01:53,549
page, there's actually - I was using AE, like the Danish use all the time, and it's not

00:01:53,549 --> 00:01:58,479
in here because I didn't have it in my talk title, the organisers came up with it and

00:01:58,479 --> 00:02:04,649
I thought I need to fix this but the problem is that encoding that takes up a lot more

00:02:04,649 --> 00:02:09,599
space so it doesn't really fit the title screen.

00:02:09,599 --> 00:02:14,560
Speaking of Martin's work I just want to quickly point out what I don't really want to talk

00:02:14,560 --> 00:02:15,560
about.

00:02:15,560 --> 00:02:16,930
First of all, this.

00:02:16,930 --> 00:02:19,900
You can look it up.

00:02:19,900 --> 00:02:25,060
It's maybe aesthetic in its own way but it's not very practical probably, and also this

00:02:25,060 --> 00:02:26,060
is not practical.

00:02:26,060 --> 00:02:27,330
I love this.

00:02:27,330 --> 00:02:38,090
It has also been presented as JSConf 2013 and it is very beautiful, it has its ownaesthetic

00:02:38,090 --> 00:02:42,280
but again is not very practical.

00:02:42,280 --> 00:02:48,830
You can learn a lot by analysing what Martin does here but it's not very helpful for day-to-day

00:02:48,830 --> 00:02:55,330
stuff so I'm going to talk about other things and the first thing I want to talk about is

00:02:55,330 --> 00:03:00,879
programming languages versus natural languages, and if you have been here on the talk before

00:03:00,879 --> 00:03:09,500
mine, there was this idea of turning natural language into something that computers can

00:03:09,500 --> 00:03:15,190
understand, and I find this approach very cool.

00:03:15,190 --> 00:03:23,599
I think it makes sense to always keep in mind that programming languages ... [sound problem]

00:03:23,599 --> 00:03:28,680
... can turn natural language into something that computers understand.

00:03:28,680 --> 00:03:37,590
[Sound problem] ... pretty controversial example.

00:03:37,590 --> 00:03:42,130
So how many of you know what this is, where this is from?

00:03:42,130 --> 00:03:49,099
So this is the official npm coding style guide, a talk of it, which talks about the comma

00:03:49,099 --> 00:03:50,769
first syntax.

00:03:50,769 --> 00:03:52,270
Don't yell at me yet.

00:03:52,270 --> 00:03:56,260
So I find this interesting.

00:03:56,260 --> 00:04:03,689
I find - so I personally completely, you know, I would never write this this way.

00:04:03,689 --> 00:04:13,439
But for me it's just a different set of - yes, I don't know, conventions that have different

00:04:13,439 --> 00:04:18,190
drawbacks and different benefits from what I would normally write, so I don't have a

00:04:18,190 --> 00:04:29,220
huge issue with this, but in defence of this I read a blog post that some of you may have

00:04:29,220 --> 00:04:38,850
read at the time, it's pretty old, where he says - I'm paraphrasing - don't compare JavaScript

00:04:38,850 --> 00:04:40,350
to the English language.

00:04:40,350 --> 00:04:42,100
JavaScript is not English.

00:04:42,100 --> 00:04:47,670
So the argument that punctuation should be at the end is silly.

00:04:47,670 --> 00:04:53,770
I read that and had a pretty strong reaction because I think this is a weird way of thinking

00:04:53,770 --> 00:04:56,510
of this.

00:04:56,510 --> 00:05:02,350
We as humans are used to reading natural language every day, of course as programmers we are

00:05:02,350 --> 00:05:11,530
used to reading programming language every day but I think most of the programming languages

00:05:11,530 --> 00:05:16,860
are modelled after things we have in natural languages as well, and that makes a ton of

00:05:16,860 --> 00:05:25,390
sense so to me that argument was kind of: no.

00:05:25,390 --> 00:05:31,110
The irony in the story, of course, is that I wanted to - because this is just an example

00:05:31,110 --> 00:05:38,490
from the style guide and then I wanted to look up actual [sound problem] ... and I was

00:05:38,490 --> 00:05:54,940
in for a surprise because I don't follow that very closely, and obviously since 2015 ... interesting,

00:05:54,940 --> 00:06:00,350
but the coding style is still out there so if anyone from npm is here that might be something

00:06:00,350 --> 00:06:08,720
you want to look at, more maybe I should - I don't know.

00:06:08,720 --> 00:06:13,160
So speaking of closeness to natural languages, here is an example.

00:06:13,160 --> 00:06:18,520
I'm a Ruby programmer - I'm sorry, don't shoot me.

00:06:18,520 --> 00:06:19,940
I also write Ruby.

00:06:19,940 --> 00:06:26,090
And to me this is a perfect example of how a language can look like that tries to mimic

00:06:26,090 --> 00:06:28,860
natural language in some opponents.

00:06:28,860 --> 00:06:30,660
Please ignore the puts.

00:06:30,660 --> 00:06:38,830
Puts is a terrible choice for something - you know, what does that even mean?

00:06:38,830 --> 00:06:45,310
But ten times do, and then do something, that's something I can show to - I almost said my

00:06:45,310 --> 00:06:46,310
Mum, which is terrible.

00:06:46,310 --> 00:06:47,470
Don't do that.

00:06:47,470 --> 00:06:53,360
So you can show that to anyone who is not familiar with programming and it will make

00:06:53,360 --> 00:06:59,720
sense to them, and so I think this is a very elegant example, a very aesthetic example

00:06:59,720 --> 00:07:06,301
of how code can actually look, and just an exercise for you to do in your head: turn

00:07:06,301 --> 00:07:08,430
this into JavaScript.

00:07:08,430 --> 00:07:14,070
You would probably use a 4 loop which is one of the constructs in JavaScript that probably

00:07:14,070 --> 00:07:20,620
resemble natural language the least, I would say.

00:07:20,620 --> 00:07:23,120
Another example.

00:07:23,120 --> 00:07:24,660
This is Python.

00:07:24,660 --> 00:07:34,170
I could have chosen CoffeeScript but I didn't want it upset everyone in the audience, so

00:07:34,170 --> 00:07:41,821
Python is one of those significant white space languages and interestingly I looked it up

00:07:41,821 --> 00:07:46,150
on Wikipedia, and it is termed offside languages.

00:07:46,150 --> 00:07:49,160
Who has heard that before?

00:07:49,160 --> 00:07:52,650
A few people.

00:07:52,650 --> 00:08:01,250
Explain that to an American who calls this thing soccer; interesting choice of words.

00:08:01,250 --> 00:08:04,610
Anyway, I just found that funny.

00:08:04,610 --> 00:08:12,150
So the thing I want to point out here is in slightly modern typesetting, so since we are

00:08:12,150 --> 00:08:20,250
doing typesetting, we use indentation for grouping and categorising things, for building

00:08:20,250 --> 00:08:26,900
a hierarchy of things, and the one thing that we never do in typesetting is actually writing

00:08:26,900 --> 00:08:30,120
something at the end that kind of closes down that block.

00:08:30,120 --> 00:08:31,460
You never do that.

00:08:31,460 --> 00:08:37,209
So I think Python made an interesting choice and it works for Python because it turns this

00:08:37,209 --> 00:08:42,769
thing into something that is still pretty good to read and it follows a convention that

00:08:42,769 --> 00:08:49,690
has been set a few hundred years ago of how to do hierarchies.

00:08:49,690 --> 00:08:58,620
So there's two problems I see with these kind of languages and the first one is actually

00:08:58,620 --> 00:09:04,959
probably not a problem, so at some point I don't know if he has coined that, but DHH,

00:09:04,959 --> 00:09:14,050
the creator of Rails, used the term syntactic vinegar and I like that term, so if you imagine

00:09:14,050 --> 00:09:21,360
you have code that longer than your screen in a language like this and you scroll down

00:09:21,360 --> 00:09:25,959
and suddenly it's like: where am I?

00:09:25,959 --> 00:09:26,959
Where does this close?

00:09:26,959 --> 00:09:28,070
I have no idea.

00:09:28,070 --> 00:09:36,930
I'm completely lost in indentation and so the language or the syntax punishes you for

00:09:36,930 --> 00:09:40,950
actually doing a thing that you shouldn't do in the first place which is writing long

00:09:40,950 --> 00:09:43,509
functions, and I found that kind of interesting.

00:09:43,509 --> 00:09:50,010
The other issue I have with it is that, to me, it always looks a little bit like this.

00:09:50,010 --> 00:09:53,100
So it's kind of off balance in a way.

00:09:53,100 --> 00:09:54,610
It never returns.

00:09:54,610 --> 00:09:56,620
This is weird.

00:09:56,620 --> 00:10:01,779
So yes, that's significant white space.

00:10:01,779 --> 00:10:11,689
This is interesting, so just a quick show of hands, who likes the first thing better?

00:10:11,689 --> 00:10:13,870
Who likes the other thing better?

00:10:13,870 --> 00:10:20,740
Okay, everyone else doesn't have any reaction to that, which is fine.

00:10:20,740 --> 00:10:30,079
So to me at first this was - that's the JavaScript way and the other is the Ruby way.

00:10:30,079 --> 00:10:40,250
There's a complete family of languages like Ruby, Python and others that join things together

00:10:40,250 --> 00:10:46,370
with an underscore and there's a whole family of languages that uses the camel case kind

00:10:46,370 --> 00:10:48,279
of thing.

00:10:48,279 --> 00:10:50,079
What's the difference?

00:10:50,079 --> 00:10:56,069
Turns out there's a study - I only found this one, but interesting enough - that kind of

00:10:56,069 --> 00:11:04,089
tried to find out which works better in the context of how precise can you - how is the

00:11:04,089 --> 00:11:08,660
precision of detecting things and how quickly can you actually read this?

00:11:08,660 --> 00:11:16,290
And it turns out that snake case is same precision but significantly faster and to me after thinking

00:11:16,290 --> 00:11:24,620
about it for a minute that totally makes sense, so if you know how the brain and the eye together

00:11:24,620 --> 00:11:30,800
parses words and sentences, you are not reading character by character, you are basically

00:11:30,800 --> 00:11:37,330
reading shapes of words, and so making out the shapes of the words in a functioning like

00:11:37,330 --> 00:11:42,769
that is significantly harder if you just jam them together and put some large characters

00:11:42,769 --> 00:11:45,829
in there.

00:11:45,829 --> 00:11:51,170
The underscore actually looks pretty familiar to the human eye because it's almost like

00:11:51,170 --> 00:11:56,569
a space, and there's almost - the underscore almost takes up no room so there's no shape

00:11:56,569 --> 00:11:58,199
to detect in a way.

00:11:58,199 --> 00:12:03,860
That's my own almost unscientific explanation for it anyway.

00:12:03,860 --> 00:12:07,670
So why did languages choose one or the other?

00:12:07,670 --> 00:12:09,560
That's an interesting question.

00:12:09,560 --> 00:12:15,259
I have no answer for that, of course.

00:12:15,259 --> 00:12:22,029
To close this down, here is something, you know, that's from an example from a blog post

00:12:22,029 --> 00:12:28,279
that I read during preparing for this talk by Joseph Wynne who talks about readability

00:12:28,279 --> 00:12:35,730
in code and this is another thing where actually, you know, thinking about how we write natural

00:12:35,730 --> 00:12:39,819
languages can help a lot because this for some reason is completely more readable.

00:12:39,819 --> 00:12:42,800
You have all the blocks in there and you just use paragraphs.

00:12:42,800 --> 00:12:52,259
You know, it's a very simple thing and it might sound really mundane and trivial but

00:12:52,259 --> 00:13:00,230
I have seen code bases where this rule wasn't applied and I don't mean Martin Kleppe's stuff

00:13:00,230 --> 00:13:04,769
with that, or minified code.

00:13:04,769 --> 00:13:11,010
The second thing I want to talk about really quickly is the principle of least surprise,

00:13:11,010 --> 00:13:16,779
which is something that influences language design up to a point, and I have a very terrible

00:13:16,779 --> 00:13:22,889
example for you that you will all know, like who in here knows what's going wrong with

00:13:22,889 --> 00:13:27,709
these lines of code?

00:13:27,709 --> 00:13:33,220
Come on, show your hands, please!

00:13:33,220 --> 00:13:34,649
OMG.

00:13:34,649 --> 00:13:39,569
So all of these things are complete garbage.

00:13:39,569 --> 00:13:44,240
They parse into things you don't want them to be parsed into and they will all balk out

00:13:44,240 --> 00:13:45,720
with terrible errors.

00:13:45,720 --> 00:13:47,829
Why is that?

00:13:47,829 --> 00:13:54,399
Because - I mean, it's JavaScript, so JavaScript wants to have semicolons at the end of every

00:13:54,399 --> 00:13:56,809
instruction.

00:13:56,809 --> 00:13:58,529
Do you see any semicolons in here?

00:13:58,529 --> 00:13:59,759
Well, I don't.

00:13:59,759 --> 00:14:04,699
It's, of course, okay to write it because we have this awesome feature called automatic

00:14:04,699 --> 00:14:07,930
semicolon insertion, or ASI.

00:14:07,930 --> 00:14:14,209
The problem is there are a few cases where the ASI stuff simply doesn't know what to

00:14:14,209 --> 00:14:20,839
do, and in this case I mean the worst example is like the one in the middle where it turns

00:14:20,839 --> 00:14:27,589
it into a division because, you know, there's a variable and then there's a slash, so there

00:14:27,589 --> 00:14:32,310
must be a division, and then everything goes wrong, of course.

00:14:32,310 --> 00:14:39,730
To me, this is like JavaScript's Achilles heel in a way because to me, from an aesthetics

00:14:39,730 --> 00:14:42,910
standpoint, all of this looks totally fine.

00:14:42,910 --> 00:14:52,570
I've seen in your reaction that you think too this should be valid code, but other languages

00:14:52,570 --> 00:14:57,119
simply have different syntax rules that make sure that something like this doesn't happen,

00:14:57,119 --> 00:15:01,939
and JavaScript at some point decided that it's okay to say: okay, we need semicolons

00:15:01,939 --> 00:15:08,740
but then we don't but then there are weird cases and that makes it really hard to look

00:15:08,740 --> 00:15:14,450
at this piece of code and say, "This is wrong", or, "This is right", and if you are an experienced

00:15:14,450 --> 00:15:22,040
JavaScript programmer or if you are exlint for example, you can say it and say this is

00:15:22,040 --> 00:15:25,950
wrong, and you can balk out and say: please change this.

00:15:25,950 --> 00:15:29,839
One way is to prefix all the second lines with semicolons.

00:15:29,839 --> 00:15:32,980
Looks really beautiful.

00:15:32,980 --> 00:15:41,529
So another trivial thing, so I like to close down the blogs with trivial things obviously,

00:15:41,529 --> 00:15:47,839
if you can see it, what's wrong with this?

00:15:47,839 --> 00:15:49,670
Does this really calculate a sum?

00:15:49,670 --> 00:15:51,339
No, it doesn't.

00:15:51,339 --> 00:15:56,601
That's like the most trivial example for validating the principle of least surprise that you can

00:15:56,601 --> 00:15:58,259
probably come up with.

00:15:58,259 --> 00:16:00,600
It's like: nobody would do that, right?

00:16:00,600 --> 00:16:06,309
But then you just think about it, how it happens, and code bases, and you have this method or

00:16:06,309 --> 00:16:12,180
a function that does a certain thing and you use it in 30 places all over your code and

00:16:12,180 --> 00:16:17,350
then a new business requirement comes in and you kind of slightly change the function,

00:16:17,350 --> 00:16:21,629
that it does things a little bit different like not changing from a sum to a difference,

00:16:21,629 --> 00:16:27,800
but something more subtle, but the name only half matches what's going on now.

00:16:27,800 --> 00:16:30,749
Do you really want to go into 30 places and change the name?

00:16:30,749 --> 00:16:33,209
Do you have automatic tools for that?

00:16:33,209 --> 00:16:37,360
And so that's just - don't do that.

00:16:37,360 --> 00:16:39,769
Don't leave it in like that.

00:16:39,769 --> 00:16:41,920
Change it to something that's correct.

00:16:41,920 --> 00:16:44,689
That's what I'm going to tell you.

00:16:44,689 --> 00:16:54,189
So who knows what - just out of curiosity, who knows what language this is?

00:16:54,189 --> 00:17:02,589
It's Louvre [?] so you know, function and then this weird looking syntax.

00:17:02,589 --> 00:17:07,200
Number three, expressiveness.

00:17:07,200 --> 00:17:09,700
This is one of my favourite subjects.

00:17:09,700 --> 00:17:13,830
I like expressive languages so that's why I'm starting with this.

00:17:13,830 --> 00:17:16,750
Who knows what this is?

00:17:16,750 --> 00:17:22,780
Hands up, shout it at me?

00:17:22,780 --> 00:17:29,270
Exactly, it is the syntax definition for Lisp.

00:17:29,270 --> 00:17:31,720
It's pretty small, isn't it?

00:17:31,720 --> 00:17:32,960
That's amazing.

00:17:32,960 --> 00:17:38,050
So there's this other thing I want to show you.

00:17:38,050 --> 00:17:40,450
Don't bother to read it.

00:17:40,450 --> 00:17:46,240
This is a parser definition for the Ruby syntax.

00:17:46,240 --> 00:17:56,300
It's not like the parser definition., it's just a library that parses Ruby

00:17:56,300 --> 00:18:03,990
into abstract syntax trees, and I already sped that up two times.

00:18:03,990 --> 00:18:08,110
It's like 2500 lines or so.

00:18:08,110 --> 00:18:11,480
It's quite different to Lisp, isn't it?

00:18:11,480 --> 00:18:13,820
So now we are done.

00:18:13,820 --> 00:18:16,590
Now let's look at some code examples.

00:18:16,590 --> 00:18:24,520
This is like the prototypical Fibonacci sequence definition for Lisp for recursive Fibonacci

00:18:24,520 --> 00:18:27,040
calculation.

00:18:27,040 --> 00:18:35,890
And I'm not used to Lisp so I look at this and go: hmm, I don't think I like this very

00:18:35,890 --> 00:18:40,630
much, and to me it's like, you know, if all you have - lists - everything looks like a

00:18:40,630 --> 00:18:42,540
hammer.

00:18:42,540 --> 00:18:51,800
So yes, it's very uniform and if it wouldn't be correctly indented it would make no sense

00:18:51,800 --> 00:18:55,210
to me.

00:18:55,210 --> 00:19:00,670
Interesting thing though about the indenting, because Lisp syntax is so simple, it's really

00:19:00,670 --> 00:19:09,050
trivial to build a tool that will autoform a Lisp code for you which is almost impossible

00:19:09,050 --> 00:19:12,560
for Ruby code, for example.

00:19:12,560 --> 00:19:18,070
So here is the Ruby example, and to me as a Ruby programmer, and probably also to you

00:19:18,070 --> 00:19:23,710
as a JavaScript programmer, this makes a ton more sense so there's syntax to define the

00:19:23,710 --> 00:19:26,050
end and the beginning of a function.

00:19:26,050 --> 00:19:33,190
There's syntax to return something, there's an if thing which is kind of weird for JavaScript

00:19:33,190 --> 00:19:39,070
programmers, but it's like inherited from Perl and I don't particularly like it but

00:19:39,070 --> 00:19:40,630
it works.

00:19:40,630 --> 00:19:50,870
Yes, there's just so much syntax in there in contrast to the thing before that I think

00:19:50,870 --> 00:19:58,270
it just goes to show that while Lisp people always say that having syntax actually makes

00:19:58,270 --> 00:20:03,210
things more complex, it also makes things more readable, I think, for the most part

00:20:03,210 --> 00:20:06,040
at least.

00:20:06,040 --> 00:20:07,280
So here is another example.

00:20:07,280 --> 00:20:13,260
This is an incomplete example before you yell at me for something that could happen, in

00:20:13,260 --> 00:20:24,210
Ruby on res, for example, and it's a definition for a user table or a user object that has

00:20:24,210 --> 00:20:29,540
a relationship to photos, so users have many photos, and this looks - to me, this looks

00:20:29,540 --> 00:20:33,780
quite elegant and it looks like a declaration.

00:20:33,780 --> 00:20:41,560
There's a reason for that because there are - the method call that is in there technically

00:20:41,560 --> 00:20:44,750
doesn't have the parentheses around it and that's a Ruby thing.

00:20:44,750 --> 00:20:46,590
You can just leave out the parentheses.

00:20:46,590 --> 00:20:52,230
You shouldn't do that all the time but for something like this it makes a ton of sense

00:20:52,230 --> 00:20:59,370
because it is a declaration more or less, but technically internally it isn't.

00:20:59,370 --> 00:21:08,100
That's just an example to show you how flexible syntax rules can really improve the readability

00:21:08,100 --> 00:21:12,090
and the expressiveness of something.

00:21:12,090 --> 00:21:15,190
The next thing I want to talk about is punctuation.

00:21:15,190 --> 00:21:17,580
Who recognises the language in here?

00:21:17,580 --> 00:21:19,280
Yes, exactly.

00:21:19,280 --> 00:21:22,180
So this is Pascal.

00:21:22,180 --> 00:21:26,350
I'm sorry, it's - the most important thing is at the bottom.

00:21:26,350 --> 00:21:29,390
I should have changed that slide.

00:21:29,390 --> 00:21:32,640
So there are two things in here that I find interesting.

00:21:32,640 --> 00:21:35,210
The first one is the assignment operator of Pascal.

00:21:35,210 --> 00:21:38,490
Who loves the assignment operator in Pascal?

00:21:38,490 --> 00:21:39,490
Right.

00:21:39,490 --> 00:21:47,680
Because it is a mathematically somewhat adequate description of an assignment whereas if you

00:21:47,680 --> 00:21:53,240
compare two values in Pascal you are using the equals sign, which means that something

00:21:53,240 --> 00:21:59,860
is equal, and for some reason in almost every other language we do this weird thing where

00:21:59,860 --> 00:22:09,130
we use two equals sign for comparison, or even three, and that's kind of - yeah, I like

00:22:09,130 --> 00:22:10,740
that.

00:22:10,740 --> 00:22:15,420
The other thing is right at the bottom, and I'm sorry if you can't see that, but there's

00:22:15,420 --> 00:22:19,170
a full stop at the end of the programme.

00:22:19,170 --> 00:22:21,430
I just admire that simplicity.

00:22:21,430 --> 00:22:24,040
It's like: end, full stop.

00:22:24,040 --> 00:22:26,090
That's it.

00:22:26,090 --> 00:22:28,000
Punctuation.

00:22:28,000 --> 00:22:32,620
There are a few languages that use punctuation - I'm sorry for another Ruby example.

00:22:32,620 --> 00:22:40,470
You have one which basically adds an exclamation mark to the method and most of the time it's

00:22:40,470 --> 00:22:45,700
a version on a method that does something more dangerous than another method, in this

00:22:45,700 --> 00:22:53,240
case it's the self-modifying method in contrast to a method that would return a copy, and

00:22:53,240 --> 00:22:59,630
then we have the question mark methods which denotes that it will return and that's nice

00:22:59,630 --> 00:23:07,070
because it allows you to return things like "is empty" or "does not have contents", and

00:23:07,070 --> 00:23:12,330
all jammed together with camel case so that's pretty cool.

00:23:12,330 --> 00:23:18,080
You can, of course, put this completely over the top and then you would end up with something

00:23:18,080 --> 00:23:22,900
like this, so who knows what this is?

00:23:22,900 --> 00:23:24,690
It's the programming language.

00:23:24,690 --> 00:23:30,230
Actually, it's "a" programming language, it's APL.

00:23:30,230 --> 00:23:36,600
And it's a very old language and it uses all kinds of mathematical characters to express

00:23:36,600 --> 00:23:44,310
things and just think about how weird it would be to input this language, and so back in

00:23:44,310 --> 00:23:48,240
the days, that was before computer screens were really a thing so they had to come up

00:23:48,240 --> 00:23:52,440
with a printer head that would be able to print these things and of course also you

00:23:52,440 --> 00:23:58,740
needed a special keyboard to be able to put this in and, yes, that's probably overdoing

00:23:58,740 --> 00:24:04,190
it a bit with the symbols there.

00:24:04,190 --> 00:24:09,200
Another thing that improves expressiveness is operating overloading and I don't even

00:24:09,200 --> 00:24:17,030
have an idea if this is really operator overloading technically, but in Ruby you can just overwrite

00:24:17,030 --> 00:24:22,710
the array accessor and that's pretty nice because you can do various things with it.

00:24:22,710 --> 00:24:26,640
There are other languages that do operator overloading.

00:24:26,640 --> 00:24:31,500
If you haven't heard of - like, who knows what this is?

00:24:31,500 --> 00:24:35,570
It's a language that has been talked a lot about a few years back and I haven't heard

00:24:35,570 --> 00:24:36,790
a lot since.

00:24:36,790 --> 00:24:41,340
It's Dart, and Dart has operator overloading.

00:24:41,340 --> 00:24:47,030
That's how it looks and it's pretty nice because you can just take two objects, add them together

00:24:47,030 --> 00:24:51,140
and something meaningful comes out of that, and that just makes for more beautiful code,

00:24:51,140 --> 00:24:52,140
I think.

00:24:52,140 --> 00:24:58,470
This is Ruby examples again, like having - being able to do a substring on something just by

00:24:58,470 --> 00:25:00,850
adding square brackets to it.

00:25:00,850 --> 00:25:06,210
I think this really makes a difference in how expressive a language is.

00:25:06,210 --> 00:25:08,810
Number 4: shared aesthetics.

00:25:08,810 --> 00:25:11,400
I am going to close out with this.

00:25:11,400 --> 00:25:17,860
So there's lots of stuff I have talked about and I have also talked a lot about - I've

00:25:17,860 --> 00:25:26,410
written in my description that this thing - Remy was talking about, like, nobody agrees

00:25:26,410 --> 00:25:29,740
with you in terms of aesthetics.

00:25:29,740 --> 00:25:33,070
I have something that we probably all agree on.

00:25:33,070 --> 00:25:35,880
And that's that this is probably not a good idea.

00:25:35,880 --> 00:25:38,080
I stole this from a tweet.

00:25:38,080 --> 00:25:42,960
I kind of like the attitude behind this.

00:25:42,960 --> 00:25:50,440
Like, you can actually write Java code without curly braces and semicolons, except that you

00:25:50,440 --> 00:25:53,100
can't.

00:25:53,100 --> 00:25:55,770
Yeah.

00:25:55,770 --> 00:26:00,250
I see from your reaction you are agreeing with this.

00:26:00,250 --> 00:26:04,830
What I find interesting about the JavaScript community though is that there doesn't seem

00:26:04,830 --> 00:26:09,520
to be a strong shared understanding of how JavaScript should look like.

00:26:09,520 --> 00:26:11,840
Other languages do it a little bit differently.

00:26:11,840 --> 00:26:18,880
For example, we have Python which has in PEP8 - PEP is like their proposal system for new

00:26:18,880 --> 00:26:24,870
language features and PEP8 is obviously one of the first texts written by the man himself,

00:26:24,870 --> 00:26:32,040
Guido, and it writes meticulously how you should write in Python, how you should index

00:26:32,040 --> 00:26:38,780
things, all that stuff, and if you are a newcomer to Python you just read that thing and internalise

00:26:38,780 --> 00:26:39,830
it and you are done.

00:26:39,830 --> 00:26:42,490
That's pretty cool.

00:26:42,490 --> 00:26:46,660
You might not agree with everything in there but that's how things are done here so maybe

00:26:46,660 --> 00:26:48,860
that's not so bad.

00:26:48,860 --> 00:26:50,510
We have a similar thing in Ruby.

00:26:50,510 --> 00:26:52,000
It's the community style guide.

00:26:52,000 --> 00:26:56,680
It's not really official but people start to adhere to it due to the fact that the guy

00:26:56,680 --> 00:27:00,600
who wrote the first thing here also wrote a pretty good linter.

00:27:00,600 --> 00:27:04,090
That's a nice trick.

00:27:04,090 --> 00:27:11,150
So in JavaScript we have something like this, which is the Crockford style guide, also relatively

00:27:11,150 --> 00:27:18,280
detailed, how you should write your JavaScript, and I guess like 90% of the community nowadays

00:27:18,280 --> 00:27:21,760
disagrees with it, which is fine.

00:27:21,760 --> 00:27:23,900
Then we have this, Standard.

00:27:23,900 --> 00:27:26,510
Who loves Standard?

00:27:26,510 --> 00:27:28,510
Ah, just a few hands.

00:27:28,510 --> 00:27:29,510
Interesting.

00:27:29,510 --> 00:27:36,490
So Standard.js is pretty cool because it just defines a more modern set of how JavaScript

00:27:36,490 --> 00:27:42,220
should look like, but I can't get over this, I'm sorry.

00:27:42,220 --> 00:27:44,880
Yes, I've no idea.

00:27:44,880 --> 00:27:47,260
I would love to know why this is.

00:27:47,260 --> 00:27:53,330
Probably someone can explain it to me later on, but what I wanted to point out is that

00:27:53,330 --> 00:28:00,940
there are a set of languages and I think Go were not the first but they kind of have the

00:28:00,940 --> 00:28:05,680
strongest stance on this, like if you are writing Go and you are not using the official

00:28:05,680 --> 00:28:08,700
Go formatter, you are just doing it wrong.

00:28:08,700 --> 00:28:15,140
Everyone else is using that, and so the Go community also doesn't have problems with

00:28:15,140 --> 00:28:18,200
figuring out how you should actually write Go code.

00:28:18,200 --> 00:28:22,750
And there are a ton of other things and the last thing I want to point out is Elm.

00:28:22,750 --> 00:28:25,210
Who loves Elm?

00:28:25,210 --> 00:28:26,440
A few hands.

00:28:26,440 --> 00:28:27,440
I like Elm.

00:28:27,440 --> 00:28:32,540
I've never built anything spectacular in it, but I kind of like the approach and I also

00:28:32,540 --> 00:28:38,710
like the approach that it doesn't come with this huge baggage of I have to know what monads

00:28:38,710 --> 00:28:44,580
and endofunctors are before I can actually start writing functional code.

00:28:44,580 --> 00:28:51,680
I like that approach, in the communication first of all, and elm-format does this weird

00:28:51,680 --> 00:29:01,160
thing, and with this I kind of would like you to marvel at the irony of an aesthetics

00:29:01,160 --> 00:29:09,740
presentation that begins and ends with comma first code, and I want to close with the reason

00:29:09,740 --> 00:29:16,080
that I wear this T-shirt is that I'm currently trying to build a greenkeeper that works for

00:29:16,080 --> 00:29:22,501
Ruby so if you are also writing Ruby code and not only writing JavaScript code, please

00:29:22,501 --> 00:29:25,260
come talk to me afterwards, and with that, thank you.

00:29:25,260 --> 00:29:25,760

YouTube URL: https://www.youtube.com/watch?v=tfn3dsIQUzY


