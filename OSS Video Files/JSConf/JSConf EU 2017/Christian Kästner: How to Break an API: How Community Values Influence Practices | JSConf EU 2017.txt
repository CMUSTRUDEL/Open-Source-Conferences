Title: Christian Kästner: How to Break an API: How Community Values Influence Practices | JSConf EU 2017
Publication date: 2017-06-01
Playlist: JSConf EU 2017
Description: 
	https://2017.jsconf.eu/speakers/christian-kaestner-how-to-break-an-api-how-community-values-influence-practices.html

Breaking the API of a package can create severe disruptions downstream, but package maintainers have flexibility in whether and how to perform a change. Through interviews and a survey, we found that developers within a community or platform often share cohesive practices (e.g., semver, backporting, synchronized releases), but that those practices differ from community to community, and that most developers are not aware of alternative strategies and practices, their tradeoffs, and why other communities adopt them. Most interestingly, it seems that often practices and community consensus seems to be driven by implicit values in each community, such as stability, rapid access, or ease to contribute. Understanding and discussing values openly can help to understand and resolve conflicts, such as discussions between demands for more stability and a pursuit of frequent and disruptive innovations.
Captions: 
	00:00:02,500 --> 00:00:06,450
Values Influence Practices By

00:00:30,900 --> 00:00:31,900
[ Applause ] >> All right.

00:00:31,900 --> 00:00:32,900
Thanks for coming.

00:00:32,900 --> 00:00:38,190
I continue this theme of speaking about community, but I look at it from a different perspective.

00:00:38,190 --> 00:00:43,600
We look at the culture of communities in terms of norms and values that are established in

00:00:43,600 --> 00:00:51,399
communities and how in different communities have usually fairly cohesive values and practices,

00:00:51,399 --> 00:00:55,080
but among different communities you see huge differences.

00:00:55,080 --> 00:00:59,900
And I want to talk about some of those effects and what you can learn from looking into other

00:00:59,900 --> 00:01:00,960
communities.

00:01:00,960 --> 00:01:04,699
This is joint with Chris, Anna, James and Ferdian.

00:01:04,699 --> 00:01:09,350
I'm at Carnegie Mellon University.

00:01:09,350 --> 00:01:12,630
This is not with experience.

00:01:12,630 --> 00:01:16,000
I don't have much experience with JavaScript to be honest.

00:01:16,000 --> 00:01:18,670
This is from an outsider's perspective.

00:01:18,670 --> 00:01:29,450
We study ecosystems as an outsider, and we hope we have an idea of comparing ecosystems

00:01:29,450 --> 00:01:31,310
learning about this from the outside.

00:01:31,310 --> 00:01:37,221
And we have been looking into this as a research project which we called breaking APIs for

00:01:37,221 --> 00:01:41,860
the last couple of years and we have a Twitter account and web page based on this that I'm

00:01:41,860 --> 00:01:45,680
going to advertise a little bit later.

00:01:45,680 --> 00:01:48,390
So we looked broadly at ecosystems.

00:01:48,390 --> 00:01:59,470
And they form around platforms and products where you have a network structure of dependencies.

00:01:59,470 --> 00:02:04,170
You can depend on a package, and that package can depend on other packages.

00:02:04,170 --> 00:02:10,020
And you have many of those communities around in different languages and different products.

00:02:10,020 --> 00:02:16,060
The main point of this talk is that the culture of the ecosystem matters.

00:02:16,060 --> 00:02:21,260
There are lots of different values, different ecosystems adopt different values.

00:02:21,260 --> 00:02:23,890
Different things are more important than other things.

00:02:23,890 --> 00:02:26,680
And leads to different tradeoffs.

00:02:26,680 --> 00:02:29,730
You can't achieve everything perfectly.

00:02:29,730 --> 00:02:33,420
Some communities favor some things over others.

00:02:33,420 --> 00:02:38,190
And following this, different cost allocations, some people have an easier time.

00:02:38,190 --> 00:02:44,680
People are new to an ecosystem or people establish or put into an ecosystem.

00:02:44,680 --> 00:02:49,489
And you often see consequences in terms of what we call ecosystem health.

00:02:49,489 --> 00:02:54,590
So are there specific problems that you see in ecosystems, like it's hard to retain developers

00:02:54,590 --> 00:02:55,709
in this ecosystem?

00:02:55,709 --> 00:03:00,460
Or a lot of packages are generally considered low quality, things like that.

00:03:00,460 --> 00:03:03,870
And why would you want to learn about this?

00:03:03,870 --> 00:03:07,500
There are lots of different issues where this might be interesting.

00:03:07,500 --> 00:03:11,540
Let's say you want to change a policy or introduce a new policy.

00:03:11,540 --> 00:03:17,250
Say you want to change the versioning rules in your ecosystem or the way� how you upload

00:03:17,250 --> 00:03:18,250
packages.

00:03:18,250 --> 00:03:20,530
Packages need to be reviewed first in some way.

00:03:20,530 --> 00:03:21,830
How you make this decision?

00:03:21,830 --> 00:03:23,750
How do you think about those tradeoffs?

00:03:23,750 --> 00:03:26,560
How do you decide whether this is a good idea?

00:03:26,560 --> 00:03:28,580
What are the consequences based on this?

00:03:28,580 --> 00:03:32,510
So understanding the space, understanding tradeoffs can be a help.

00:03:32,510 --> 00:03:35,540
Or you want to fight a health issue.

00:03:35,540 --> 00:03:38,810
You have problems retaining and recruiting new developers.

00:03:38,810 --> 00:03:44,489
What design decision in your ecosystem might be contributing to this?

00:03:44,489 --> 00:03:48,690
How can you debug your community to figure out what to change?

00:03:48,690 --> 00:03:50,870
Or design a new community.

00:03:50,870 --> 00:03:56,351
I don't think any of us will design the next npm, but there might be a chance where we

00:03:56,351 --> 00:04:02,659
are focusing on sub communities, say Hoodie or some number of packages where you want

00:04:02,659 --> 00:04:04,349
to push specific values.

00:04:04,349 --> 00:04:08,410
What can you do to foster goals in one community?

00:04:08,410 --> 00:04:13,070
And, again, for this, culture really matters.

00:04:13,070 --> 00:04:17,180
It's important to understand the values that� it's important to understand the tradeoffs.

00:04:17,180 --> 00:04:22,370
And we have been doing research on this for a while.

00:04:22,370 --> 00:04:26,520
What I'm going to talk about is mostly based on interviews and surveys that we have conducted

00:04:26,520 --> 00:04:28,620
throughout the last couple of years.

00:04:28,620 --> 00:04:32,130
And we looked at this through one specific lens.

00:04:32,130 --> 00:04:34,780
And that's breaking changes.

00:04:34,780 --> 00:04:40,310
The idea here is that if you use a package, there are lots of dependencies often mind

00:04:40,310 --> 00:04:43,250
that package and you depend on a number of packages.

00:04:43,250 --> 00:04:47,250
And all of those packages have maintainers, and they could make just changes to their

00:04:47,250 --> 00:04:48,250
packages.

00:04:48,250 --> 00:04:49,990
And some of those changes are modular.

00:04:49,990 --> 00:04:54,430
So you just update and have the great new version and everything works fine.

00:04:54,430 --> 00:04:57,080
But some of those changes are breaking changes.

00:04:57,080 --> 00:04:59,880
So they may change some of their APIs.

00:04:59,880 --> 00:05:02,780
So when you update, your code isn't working anymore.

00:05:02,780 --> 00:05:05,710
You have to invest some time, get interrupted.

00:05:05,710 --> 00:05:10,830
You need to invest in new code when you want to migrate.

00:05:10,830 --> 00:05:12,340
This can rip through the ecosystem.

00:05:12,340 --> 00:05:13,980
It can have consequences.

00:05:13,980 --> 00:05:19,990
A single change can affect hundreds of developers and their packages.

00:05:19,990 --> 00:05:22,889
So you can start thinking about costs.

00:05:22,889 --> 00:05:25,690
What's the cost of a breaking change in this sense?

00:05:25,690 --> 00:05:30,820
And we think about this as kind of a balance of who takes cost� it's somewhat an abstract

00:05:30,820 --> 00:05:31,910
concept.

00:05:31,910 --> 00:05:37,560
But in the extreme case, it's really easy to make a change and impact hundreds of thousands

00:05:37,560 --> 00:05:44,130
of developers out there who all get interrupted and who all need to invest in doing some rework.

00:05:44,130 --> 00:05:49,160
So it makes it really easy for maintainers to break something and puts the cost on the

00:05:49,160 --> 00:05:50,160
users.

00:05:50,160 --> 00:05:51,750
That's one extreme.

00:05:51,750 --> 00:05:56,770
The opposite extreme would be you refrain from making a change even though it's really

00:05:56,770 --> 00:05:58,740
important to you.

00:05:58,740 --> 00:06:00,610
There are lots of reasons for making changes.

00:06:00,610 --> 00:06:07,000
Nothing is really ever stable, but if you are not allowed to make breaking changes,

00:06:07,000 --> 00:06:12,680
if you really refrain from this, you're taking on costs, mostly technical debt, opportunity

00:06:12,680 --> 00:06:16,760
costs, maybe have some performance problems that you could fix with an API change, but

00:06:16,760 --> 00:06:18,490
you can't really do that.

00:06:18,490 --> 00:06:19,490
Right?

00:06:19,490 --> 00:06:24,440
So it be really costly for you and maybe in the longterm also for your users not to break

00:06:24,440 --> 00:06:25,600
anything.

00:06:25,600 --> 00:06:31,009
And then there's a lot of passes in the middle where you kind of, as a maintainer, you break

00:06:31,009 --> 00:06:36,530
something, but you try to reduce the cost for your users by mitigating some of those

00:06:36,530 --> 00:06:37,530
changes.

00:06:37,530 --> 00:06:43,250
A typical example is you invest some effort in writing a migration grade to make it easier

00:06:43,250 --> 00:06:45,250
for your users to update.

00:06:45,250 --> 00:06:49,380
You might synchronize releases with other packages or on a schedule to make it easier

00:06:49,380 --> 00:06:51,520
to make changes and not get interrupted.

00:06:51,520 --> 00:07:00,520
And processes like backporting and deprecation, how you can delay the impact of changes.

00:07:00,520 --> 00:07:01,650
So it's not as immediate.

00:07:01,650 --> 00:07:05,270
And there are hundreds of those practices.

00:07:05,270 --> 00:07:11,370
And, again, what I want to show is that different communities have different cost allocations,

00:07:11,370 --> 00:07:15,860
use different practices, and kind of really negotiate differently in this space.

00:07:15,860 --> 00:07:20,139
So in this talk I'm primarily going to talk about three ecosystems.

00:07:20,139 --> 00:07:22,340
There are many more.

00:07:22,340 --> 00:07:27,169
Our web page contains survey data on 18 ecosystems in total.

00:07:27,169 --> 00:07:31,380
But I want to dive in a little bit deeper on three of those.

00:07:31,380 --> 00:07:36,320
And I'm going to start with Eclipse and them assuming you know less about them than NodeJS.

00:07:36,320 --> 00:07:43,730
When I'm talking about those ecosystems, think about your community and what practices you

00:07:43,730 --> 00:07:47,900
do and how this is different from what you see in those ecosystems.

00:07:47,900 --> 00:07:50,080
And think about why.

00:07:50,080 --> 00:07:51,629
Is this a good idea?

00:07:51,629 --> 00:07:52,629
Should this be different?

00:07:52,629 --> 00:07:59,520
Should we copy things that I'm going to show you Eclipse?

00:07:59,520 --> 00:08:04,160
Let's start with Eclipse.

00:08:04,160 --> 00:08:06,910
You have probably heard of it.

00:08:06,910 --> 00:08:09,270
Originally for Java programming.

00:08:09,270 --> 00:08:11,389
Has hundreds of plugins.

00:08:11,389 --> 00:08:13,020
These plugins can depend on other plugins.

00:08:13,020 --> 00:08:16,160
So you have this ecosystem structure.

00:08:16,160 --> 00:08:22,020
And if you look into this community, if you talk to people, or even if you just look at

00:08:22,020 --> 00:08:28,669
their web page, you realize what values are important in this community.

00:08:28,669 --> 00:08:34,060
So one important value is backward compatibility.

00:08:34,060 --> 00:08:40,159
They say on their web page extremely explicitly, as the API prime director, when involving

00:08:40,159 --> 00:08:46,560
the component API from release to release, do not break existing clients, right?

00:08:46,560 --> 00:08:48,670
They really focus on stability.

00:08:48,670 --> 00:08:50,540
And that's not something that they just say.

00:08:50,540 --> 00:08:52,920
This is a culture that they live.

00:08:52,920 --> 00:08:55,670
And here I can show you some data from our survey.

00:08:55,670 --> 00:08:58,320
And I'm going to show you more plots like this.

00:08:58,320 --> 00:09:04,920
But how to read this is mostly� so we ask, how important is stability to your community?

00:09:04,920 --> 00:09:08,550
And the higher up they are, the more important it is.

00:09:08,550 --> 00:09:10,250
These are all positive values.

00:09:10,250 --> 00:09:14,290
So we ask pretty from a little bit important to very important.

00:09:14,290 --> 00:09:17,240
And most people say, yes, stability is important.

00:09:17,240 --> 00:09:22,270
But what you still see are differences among ecosystems, and we have sorted this by average

00:09:22,270 --> 00:09:23,410
rank.

00:09:23,410 --> 00:09:28,500
And what you see is that Eclipse is really on the far end here.

00:09:28,500 --> 00:09:35,810
Eclipse is the ecosystem on which developers rate stability as the most important practice.

00:09:35,810 --> 00:09:38,050
Way more than other ecosystems.

00:09:38,050 --> 00:09:41,270
And this is consistent� largely consistent within this community.

00:09:41,270 --> 00:09:48,120
So this value that's communicated is actually accepted by the community and you see consequences.

00:09:48,120 --> 00:09:53,529
So when we ask them, for example, about how often are you making breaking changes?

00:09:53,529 --> 00:09:56,910
Or how often are you faced by breaking changes?

00:09:56,910 --> 00:10:02,790
You see answers that Eclipse� changes in other ecosystems.

00:10:02,790 --> 00:10:07,010
So this is actually a best practice.

00:10:07,010 --> 00:10:10,450
In terms of cost distribution, what I have shown you in the beginning, this is pretty

00:10:10,450 --> 00:10:18,110
much on the extreme side whereas a developer, you are not allowed to make breaking changes.

00:10:18,110 --> 00:10:24,940
Use a lot of work arounds, a lot of creative hacking and getting around limitations.

00:10:24,940 --> 00:10:30,060
And there's the reduction of the impact of releases.

00:10:30,060 --> 00:10:33,250
A fixed schedule, once a year there's a big release.

00:10:33,250 --> 00:10:41,860
And large parts of the community synchronize and go through a month-long process of checking

00:10:41,860 --> 00:10:44,660
things and so on.

00:10:44,660 --> 00:10:45,890
So severing a tradeoff.

00:10:45,890 --> 00:10:49,120
What can they achieve and what are the problems here?

00:10:49,120 --> 00:10:51,630
So Eclipse is extremely stable.

00:10:51,630 --> 00:10:53,399
It's convenient to use.

00:10:53,399 --> 00:11:00,600
You can put packets written 13 years ago in a new version of Eclipse, and they work.

00:11:00,600 --> 00:11:05,450
Try doing this with JavaScript packages.

00:11:05,450 --> 00:11:08,300
Yearly updates are sufficient for many in the community.

00:11:08,300 --> 00:11:12,920
You don't need to update from week to week to see the next update.

00:11:12,920 --> 00:11:14,950
But this has consequences.

00:11:14,950 --> 00:11:21,800
Eclipse is seen by many we spoke to as is stagnant and staid platform.

00:11:21,800 --> 00:11:27,650
They have it without the generics, they couldn't update those.

00:11:27,650 --> 00:11:34,110
And if I take my students as references, I would say they are not using Eclipse anymore

00:11:34,110 --> 00:11:35,110
these days.

00:11:35,110 --> 00:11:37,680
So at least in Java, people have switched to IntelliJ.

00:11:37,680 --> 00:11:49,290
Not sure it's a good example, but by that example Twitter is pretty much dead.

00:11:49,290 --> 00:11:52,760
I'm not sure with the students these days.

00:11:52,760 --> 00:11:58,840
Eclipse reports that they have difficulty recruiting and retaining developers�and

00:11:58,840 --> 00:12:03,500
that also these coordinated releases are kind of a pain point for them� for the community.

00:12:03,500 --> 00:12:07,790
So they invest a lot of evident, but it's also painful.

00:12:07,790 --> 00:12:10,050
When we ask the question about health.

00:12:10,050 --> 00:12:13,760
How much do you face the difficulty of recruiting new developers?

00:12:13,760 --> 00:12:15,870
It's on the far end.

00:12:15,870 --> 00:12:21,810
If we ask about how much do you feel limited in innovating in your ecosystem, it's on the

00:12:21,810 --> 00:12:31,940
far end, but on the other side if you ask� What I have shown you here is one end.

00:12:31,940 --> 00:12:36,790
Eclipse has made specific decisions which I guess you see as very different from your

00:12:36,790 --> 00:12:42,709
community and they have accepted certain tradeoffs and have certain goals with this.

00:12:42,709 --> 00:12:49,209
I want to talk about the second ecosystem, R, kind of the npm for R.

00:12:49,209 --> 00:12:53,320
R is a language for statistically computation.

00:12:53,320 --> 00:12:59,340
And there are a couple of thousand packages on CRAN that are usually cutting edge research

00:12:59,340 --> 00:13:00,400
and statistics.

00:13:00,400 --> 00:13:07,180
So when you interview people in this community you often speak to physicists or soil analysis,

00:13:07,180 --> 00:13:13,709
researchers, retired professors who maintain some packages in this community.

00:13:13,709 --> 00:13:18,209
And they do something pretty interesting about dependencies and about versioning.

00:13:18,209 --> 00:13:20,269
We call it the snapshot consistency.

00:13:20,269 --> 00:13:27,220
The goal is the most recent version of all packages on the ecosystem should be compatible.

00:13:27,220 --> 00:13:31,931
So it doesn't matter that the newest version of package A is compatible with an older version

00:13:31,931 --> 00:13:37,829
of package B, it just has to be compatible with the newest version of package B at this

00:13:37,829 --> 00:13:38,829
time.

00:13:38,829 --> 00:13:44,710
So at any point you should be able to install any packages in that ecosystem, update all

00:13:44,710 --> 00:13:48,180
at once, and it should be compatible.

00:13:48,180 --> 00:13:51,449
So to achieve this, this requires coordination.

00:13:51,449 --> 00:13:56,279
So what typically happens here is you are allowed to break things, but when you break

00:13:56,279 --> 00:14:00,959
something, you reach out to people in that community that are affected.

00:14:00,959 --> 00:14:02,140
You coordinate.

00:14:02,140 --> 00:14:06,080
And then you typically more or less publish both packages.

00:14:06,080 --> 00:14:08,889
Your package and the affected package at the same time.

00:14:08,889 --> 00:14:10,930
So there's kind of a sliding window.

00:14:10,930 --> 00:14:14,550
Typically three or four weeks until you have to do this.

00:14:14,550 --> 00:14:17,220
But as a maintainer you have to react.

00:14:17,220 --> 00:14:20,620
There's a threat you can get thrown out.

00:14:20,620 --> 00:14:25,600
Your package can be taken over or get thrown out if you don't react and somebody depends

00:14:25,600 --> 00:14:30,620
on you makes a breaking change and you can't coordinate with them.

00:14:30,620 --> 00:14:36,920
To make this work, there's a strong culture of gatekeeping and enforcement of this.

00:14:36,920 --> 00:14:39,720
Some volunteers review changes.

00:14:39,720 --> 00:14:42,770
So you don't just upload things as an npm.

00:14:42,770 --> 00:14:45,000
But you actually submit your changes.

00:14:45,000 --> 00:14:49,320
Somebody review this is, run tests on the entire ecosystem to see whether something

00:14:49,320 --> 00:14:52,220
breaks.

00:14:52,220 --> 00:14:55,170
In terms of costs, we have a different picture.

00:14:55,170 --> 00:15:00,420
So you can make breaking changes, but you have to reach out and some volunteers take

00:15:00,420 --> 00:15:01,880
on some of the additional costs.

00:15:01,880 --> 00:15:06,459
And you cannot have the constant synchronization here.

00:15:06,459 --> 00:15:10,149
In terms of values, it's not quite that obvious as in Eclipse.

00:15:10,149 --> 00:15:13,709
It's not strongly communicated on their web page.

00:15:13,709 --> 00:15:19,060
When we talk to people that are kind of core members of this community, they say they want

00:15:19,060 --> 00:15:23,980
to make it easy for end users to install and update packages.

00:15:23,980 --> 00:15:29,980
And one of our interviews said CRAN primarily has the academic user in mind who want timely

00:15:29,980 --> 00:15:31,860
access to current research.

00:15:31,860 --> 00:15:38,360
And this timely access reflects the contrast, let's say to Eclipse, where you have releases

00:15:38,360 --> 00:15:39,820
once a year.

00:15:39,820 --> 00:15:44,320
These people are doing research and want to publish things and get them out there.

00:15:44,320 --> 00:15:49,410
It's a review process, but much faster than yearly rearrests.

00:15:49,410 --> 00:15:53,779
interestingly, and I don't have much time to talk about this, this is a value that's

00:15:53,779 --> 00:15:56,870
not communicated on their Website.

00:15:56,870 --> 00:15:57,870
It's not transparent.

00:15:57,870 --> 00:16:03,230
And if you ask people, rapid access or quick release is actually not showing up as one

00:16:03,230 --> 00:16:06,709
of the key values that the community as a whole shares.

00:16:06,709 --> 00:16:11,660
It's somewhere between Eclipse and bioconducter that both have yearly releases.

00:16:11,660 --> 00:16:20,160
I think that to the developers of the community, the idea is we want to be faster than the

00:16:20,160 --> 00:16:22,610
turnaround than those yearly releases.

00:16:22,610 --> 00:16:29,029
But to package maintainers, it's slower than npm where you can upload things.

00:16:29,029 --> 00:16:31,089
You have to go through a review process.

00:16:31,089 --> 00:16:36,449
There are certain values where we speculate they are not communicated well, so people

00:16:36,449 --> 00:16:40,320
don't see why the ecosystem is designed this way.

00:16:40,320 --> 00:16:46,160
So, again, there are tradeoffs and costs and benefits.

00:16:46,160 --> 00:16:49,590
So they have relatively short release cycles.

00:16:49,590 --> 00:16:50,709
They achieve compatibility.

00:16:50,709 --> 00:16:53,649
It's actually pretty good usually at that.

00:16:53,649 --> 00:16:59,830
But at the same time, you have this urgency in� this burden to react to updates.

00:16:59,830 --> 00:17:04,159
So, at any time there could be a breaking change that if you depend on that package

00:17:04,159 --> 00:17:10,339
you may need to coordinate, you may get interrupted.

00:17:10,339 --> 00:17:16,650
And this leads to other consequences where people aggressively reduce the number of dependencies

00:17:16,650 --> 00:17:20,919
that they want to depend� they would rather copy and paste code from another package than

00:17:20,919 --> 00:17:25,530
being exposed to this change is something we heard repeatedly.

00:17:25,530 --> 00:17:31,140
And this gatekeeping causes additional effort and causes friction in this community.

00:17:31,140 --> 00:17:34,410
So, this is always a contested point.

00:17:34,410 --> 00:17:39,789
So, again, I have shown you another example that's probably very different from what you

00:17:39,789 --> 00:17:41,200
know.

00:17:41,200 --> 00:17:45,290
And I think I can make this shorter on Node because, I guess, you know the community much

00:17:45,290 --> 00:17:48,480
better there than me.

00:17:48,480 --> 00:17:53,220
But my first contact with node was something like this.

00:17:53,220 --> 00:17:54,220
Right?

00:17:54,220 --> 00:17:56,370
Last week's tutorial is out of date today.

00:17:56,370 --> 00:17:59,280
This is a couple of years ago that I heard this.

00:17:59,280 --> 00:18:02,919
I forgot who the source was.

00:18:02,919 --> 00:18:08,330
But then you also saw things like this which I think is insane, or unique.

00:18:08,330 --> 00:18:14,820
That people actually started documenting the APIs, at least of the Node APIs, with stability

00:18:14,820 --> 00:18:15,820
indicators.

00:18:15,820 --> 00:18:21,270
They have� it's simpler these days� but this entire infrastructure about things we

00:18:21,270 --> 00:18:22,670
are experimenting with this API.

00:18:22,670 --> 00:18:26,820
You can use it, it might change, and at some point we mark it stable.

00:18:26,820 --> 00:18:34,220
So implicitly you can see values of people open to rapid change and they are open to

00:18:34,220 --> 00:18:37,330
experiment with APIs to get things right.

00:18:37,330 --> 00:18:40,539
It's a more of innovative community, in a sense.

00:18:40,539 --> 00:18:46,570
I thought design decisions are really trying to lower the barrier to entry.

00:18:46,570 --> 00:18:49,610
It's really easy to publish your first package on npm.

00:18:49,610 --> 00:18:51,740
A really low bar.

00:18:51,740 --> 00:18:56,179
Also, you hear this in interviews with Isaac.

00:18:56,179 --> 00:19:03,990
And the goal is to make it easy and fast for developers and publish and use packages.

00:19:03,990 --> 00:19:08,799
If you look at stability, Node is not in the top space.

00:19:08,799 --> 00:19:12,900
This is not the value that is most important in this community.

00:19:12,900 --> 00:19:17,370
But if you look at innovation, this is where Node is at the far end.

00:19:17,370 --> 00:19:23,340
Where the community thinks innovation is a key or is a very important value for us, among

00:19:23,340 --> 00:19:25,770
other ones as well.

00:19:25,770 --> 00:19:31,530
In terms of costs, though, it's pretty much on the extreme where it's really easy to just

00:19:31,530 --> 00:19:34,740
break something and let other people deal with it.

00:19:34,740 --> 00:19:39,289
The main saving grace is you're not forced to update, right?

00:19:39,289 --> 00:19:44,320
So you can stick to an old version when you can't really do in CRAN that much.

00:19:44,320 --> 00:19:46,150
And Eclipse in way.

00:19:46,150 --> 00:19:50,510
You can't really stay behind or partially stay behind on some packages.

00:19:50,510 --> 00:19:51,640
Which is easy here.

00:19:51,640 --> 00:19:53,600
So there's some technology behind it.

00:19:53,600 --> 00:19:56,510
And there's a bunch of practices around this.

00:19:56,510 --> 00:20:02,020
So the semantic versioning is broadly adopted as signaling what's breaking and what's not

00:20:02,020 --> 00:20:03,140
breaking.

00:20:03,140 --> 00:20:07,620
This is something that doesn't make sense to people in CRAN and R. To them version numbers

00:20:07,620 --> 00:20:09,720
are just increasing.

00:20:09,720 --> 00:20:11,990
You don't try to communicate what's breaking or not.

00:20:11,990 --> 00:20:13,100
It doesn't matter.

00:20:13,100 --> 00:20:16,830
The newest version of our packages should be compatible.

00:20:16,830 --> 00:20:22,820
Node or npm has this technology infrastructure to allow you to use multiple versions of the

00:20:22,820 --> 00:20:27,330
same package, which helps you to solve the diamond dependency problem, which is pretty

00:20:27,330 --> 00:20:32,870
unique and very hard to translate to other languages, which is a key feature here.

00:20:32,870 --> 00:20:37,840
And then there's a lot of grassroots tool building from the community that tries to

00:20:37,840 --> 00:20:41,500
build tooling to kind of cope with large amounts of changes.

00:20:41,500 --> 00:20:47,809
Things like Greenkeeper and a bunch of these security projects that try to fit changes

00:20:47,809 --> 00:20:51,890
for you which are important and which are not.

00:20:51,890 --> 00:20:54,720
So in terms of tradeoffs, again, there are costs and benefits.

00:20:54,720 --> 00:20:57,600
It's certainly a much more open community.

00:20:57,600 --> 00:20:58,600
It's easier to get in.

00:20:58,600 --> 00:21:03,490
It's attractive to new developers, at least compared to others.

00:21:03,490 --> 00:21:09,390
But it's perceived somewhat as unstable and having little quality control, right?

00:21:09,390 --> 00:21:12,900
There's a lot of junk on npm.

00:21:12,900 --> 00:21:17,720
And the rapid changes out there require constant maintenance, right?

00:21:17,720 --> 00:21:22,880
So at least if you decide to keep up, and that's usually a good idea, I guess, if you

00:21:22,880 --> 00:21:26,200
decide to keep up, you have a lot of changes to deal with dependencies.

00:21:26,200 --> 00:21:30,110
There are often a large number of dependencies.

00:21:30,110 --> 00:21:35,809
And then the community helps with tooling and community efforts.

00:21:35,809 --> 00:21:42,480
So from an outsider's perspective, I have the impression that the amount of change in

00:21:42,480 --> 00:21:46,200
Node and in this ecosystem is slowing down a little bit.

00:21:46,200 --> 00:21:50,840
Potentially because there are more commercial users who want more stability.

00:21:50,840 --> 00:21:52,070
More users in general.

00:21:52,070 --> 00:21:54,140
Maybe a larger community.

00:21:54,140 --> 00:22:00,590
So is Node actually getting more stable and, more importantly, should it get more stable?

00:22:00,590 --> 00:22:05,570
And think this is an interesting question for the community to ask because stability

00:22:05,570 --> 00:22:09,340
can be a nice value, but it also has its cost.

00:22:09,340 --> 00:22:13,690
And we have seen the extreme in Eclipse.

00:22:13,690 --> 00:22:16,720
And this might be worse to think about.

00:22:16,720 --> 00:22:21,150
So what I tried to show here is that culture really matters for an ecosystem.

00:22:21,150 --> 00:22:22,150
Right?

00:22:22,150 --> 00:22:23,150
There are tradeoffs.

00:22:23,150 --> 00:22:28,170
I have shown you three very different examples with different cost allocations, different

00:22:28,170 --> 00:22:31,120
people who are favored in this ecosystem.

00:22:31,120 --> 00:22:34,390
We can speculate about the reasons if you're interested.

00:22:34,390 --> 00:22:38,140
And in the survey, you see a number of other things that might stand out in one or the

00:22:38,140 --> 00:22:39,860
other direction.

00:22:39,860 --> 00:22:44,590
Rust really values community, that's communicates.

00:22:44,590 --> 00:22:52,600
Ruby are fun, a pretty unique versioning strategy.

00:22:52,600 --> 00:23:00,440
People are really aware about the difference [audio cut out]� out of the same thing over

00:23:00,440 --> 00:23:04,030
a conflict on how to deal with compatibility.

00:23:04,030 --> 00:23:12,140
And Maven is interesting, most people perceive it as a tool for replicability.

00:23:12,140 --> 00:23:16,230
And you can explore the page to see the others.

00:23:16,230 --> 00:23:22,510
So, again, community, culture, of an ecosystem really matters.

00:23:22,510 --> 00:23:25,510
The values, the practices matter.

00:23:25,510 --> 00:23:28,900
Everything is a tradeoff and it helps to know the design space.

00:23:28,900 --> 00:23:34,179
It helps to know what other possibilities we can reduce the amount of changes.

00:23:34,179 --> 00:23:38,860
What are the different mechanisms of how we can make it easier for users to update.

00:23:38,860 --> 00:23:39,860
Things like this.

00:23:39,860 --> 00:23:41,900
And understand the tradeoffs behind them.

00:23:41,900 --> 00:23:47,570
And our hope is in the longterm, when we understand those things, we're just in the beginning,

00:23:47,570 --> 00:23:48,570
unfortunately.

00:23:48,570 --> 00:23:53,470
When we understand those things, we can deliberately design communities this we can think about

00:23:53,470 --> 00:23:55,370
we can achieve this goal.

00:23:55,370 --> 00:23:56,549
What other practices?

00:23:56,549 --> 00:23:58,780
How can we encourage people to do this.

00:23:58,780 --> 00:24:01,720
And we can debug communities.

00:24:01,720 --> 00:24:03,679
If we see certain health issues.

00:24:03,679 --> 00:24:06,460
Like people are running away.

00:24:06,460 --> 00:24:08,710
People find this all low quality.

00:24:08,710 --> 00:24:09,710
What can we do?

00:24:09,710 --> 00:24:14,470
What might be effective things to change that have worked in other communities?

00:24:14,470 --> 00:24:16,750
Most people don't know that many communities.

00:24:16,750 --> 00:24:18,750
One, two, three, maybe.

00:24:18,750 --> 00:24:21,810
And don't often think about the explicit differences.

00:24:21,810 --> 00:24:26,950
So we think it really helps to understand the space and to understand.

00:24:26,950 --> 00:24:30,890
As I mentioned a couple of times, there's much more data behind this.

00:24:30,890 --> 00:24:36,289
There's also academic papers behind this and we have created a web page, breaking API's.org,

00:24:36,289 --> 00:24:40,000
we just released all the results of the survey.

00:24:40,000 --> 00:24:46,270
A large number of plots where you can compare different ecosystems, and personal values

00:24:46,270 --> 00:24:47,920
against community values.

00:24:47,920 --> 00:24:49,250
Things like this.

00:24:49,250 --> 00:24:52,010
So feel free to have a look at this, explore this.

00:24:52,010 --> 00:24:53,180
Explore the data.

00:24:53,180 --> 00:24:55,240
And we are always looking for feedback.

00:24:55,240 --> 00:24:58,490
Always looking to discuss things.

00:24:58,490 --> 00:25:01,610
If you have a specific insight, share this.

00:25:01,610 --> 00:25:03,910
We would be happy to interview people.

00:25:03,910 --> 00:25:06,950
Also learn more about those things.

00:25:06,950 --> 00:25:10,190
And with this I get to my last slide.

00:25:10,190 --> 00:25:12,799
Because in the title of the talk I asked how to break an API.

00:25:12,799 --> 00:25:18,419
Now I can at least answer this for three ecosystems I discussed.

00:25:18,419 --> 00:25:21,610
In Eclipse, you just don't.

00:25:21,610 --> 00:25:25,450
[ Laughter ] In CRAN, You reach out to affected developers

00:25:25,450 --> 00:25:30,100
and release simultaneously.

00:25:30,100 --> 00:25:34,370
And in Node, you increase the major version number and you move on.

00:25:34,370 --> 00:25:35,370
That's it.

00:25:35,370 --> 00:25:36,370
Thanks.

00:25:36,370 --> 00:25:37,370
[ Applause ] >> Okay.

00:25:37,370 --> 00:25:38,370
So we've got a break now.

00:25:38,370 --> 00:25:39,370
Both tracks start at 5:45.

00:25:39,370 --> 00:25:40,370
But during the break also there is a what is live JS?

00:25:40,370 --> 00:25:41,370
Which is a lightning talk over by where we have been doing the live music in the back

00:25:41,370 --> 00:25:42,370
like near registration.

00:25:42,370 --> 00:25:43,370
See you in a bit.

00:25:43,370 --> 00:25:43,870

YouTube URL: https://www.youtube.com/watch?v=xJHeHCZtmAU


