Title: Emil Bay:  Keeping passwords safe in 2017 | JSConf EU 2017
Publication date: 2017-05-30
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/emil-bay-keeping-passwords-safe-in-2017.html

Every other week there seems to be a new dump of cracked passwords, hurting innocent and unbeknownst users. It seems as if keeping users passwords safe is an herculean task, even beyond the most resourceful organisations. However it doesn’t have to be.

Password hashing is a important discipline in cryptography. Securing passwords has become so integral to our society that in 2013 a Password Hashing Competition was announced, for the academic community to band together and develop a common recommendation for future use. In this talk I’ll showcase how to handle passwords correctly and safely and clear out misinformation that is still abound in tutorials and blog posts. All with heaps of demos to motivate, make the material concrete and so everyone can follow along!
Captions: 
	00:00:00,179 --> 00:01:01,800
Keeping Passwsords Safe in 2017 By

00:01:01,800 --> 00:01:22,270
Emil Bay

00:01:22,270 --> 00:01:45,229
[no audio] >> I have worked at an advertisement agency

00:01:45,229 --> 00:01:48,220
and I worked at a high performance computing lab.

00:01:48,220 --> 00:01:53,369
And most recently I've worked at a newspaper as a data journalist.

00:01:53,369 --> 00:01:59,830
But today we're talking about passwords.

00:01:59,830 --> 00:02:03,460
Just to get everyone on the same page, I'm sure you know what passwords are.

00:02:03,460 --> 00:02:10,649
But technically if you know a password, it's something to identify yourself.

00:02:10,649 --> 00:02:16,689
If you know a password, it's pretty much equivalent to your identity online.

00:02:16,689 --> 00:02:20,079
When you do on a Website, it's not like you're showing your passport or anything like that.

00:02:20,079 --> 00:02:22,109
You have a password.

00:02:22,109 --> 00:02:28,139
And the state of the world, everyone has passwords.

00:02:28,139 --> 00:02:34,659
My grandmother has a password as well.�if you can steal someone's password, it has a

00:02:34,659 --> 00:02:37,189
lot of implications.

00:02:37,189 --> 00:02:42,560
And as a matter of fact, most people only have one password.

00:02:42,560 --> 00:02:45,419
So your password is your identity.

00:02:45,419 --> 00:02:47,700
If someone steals it, they have your whole identity.

00:02:47,700 --> 00:02:52,269
They can log in as you everyone on the Internet kind of thing.

00:02:52,269 --> 00:02:55,419
So what can we do about this?

00:02:55,419 --> 00:02:57,499
As I see it, three things we can do.

00:02:57,499 --> 00:03:02,799
Eradicate all security holes which is a pretty noble task.

00:03:02,799 --> 00:03:05,129
I think that's what the world strives to do, right?

00:03:05,129 --> 00:03:07,439
But it's probably not going to work out in the shortterm.

00:03:07,439 --> 00:03:19,589
Another thing and another thing we can do is have unique passwords everywhere.

00:03:19,589 --> 00:03:24,069
I don't know about you, but I keep a password safe with a unique password for every Website.

00:03:24,069 --> 00:03:28,760
You can't trust Websites, I'm going to show you.

00:03:28,760 --> 00:03:36,079
But as software provider, you can use safer password storage.

00:03:36,079 --> 00:03:39,159
That's what we're going to talk about today.

00:03:39,159 --> 00:03:40,879
So here's a question for you.

00:03:40,879 --> 00:03:43,249
What do all these companies have in common?

00:03:43,249 --> 00:03:47,159
They were visited by this guy.

00:03:47,159 --> 00:03:50,279
Now, in the Lego world, every Lego man looks alike.

00:03:50,279 --> 00:03:51,340
This is not me.

00:03:51,340 --> 00:03:56,359
This is some other Lego guy, right?

00:03:56,359 --> 00:04:01,670
So in this talk the way we're going to go about things is we're going to build safe

00:04:01,670 --> 00:04:04,819
password storage from the ground up.

00:04:04,819 --> 00:04:09,180
The first and easiest way to store passwords is plain text.

00:04:09,180 --> 00:04:16,739
And I'm sure plain text to a lot of you guys it already has ate alarm bells ringing, right?

00:04:16,739 --> 00:04:18,379
So let's look at some code here.

00:04:18,379 --> 00:04:23,710
Look at the examples after the talk, this is the model I've used throughout all the

00:04:23,710 --> 00:04:24,710
examples.

00:04:24,710 --> 00:04:27,600
So we have a database of some kind.

00:04:27,600 --> 00:04:31,930
In this case, it's just a map that sits over in another file.

00:04:31,930 --> 00:04:35,220
Then we have a register function and a login function.

00:04:35,220 --> 00:04:39,110
Often these two functions are not symmetrical.

00:04:39,110 --> 00:04:45,270
You store the function, and on the other you have to verify that the password was the same

00:04:45,270 --> 00:04:47,710
as was provided when you signed up.

00:04:47,710 --> 00:04:54,680
And we return true or false depending on whether the password is valid.

00:04:54,680 --> 00:04:58,680
And you can see down here at the bottom I have a register function where I register

00:04:58,680 --> 00:05:04,900
my user name and then because we are in Germany, I have chosen the password to be handschuh,

00:05:04,900 --> 00:05:06,300
which is glove.

00:05:06,300 --> 00:05:08,990
But literally translated means "Hand shoe."

00:05:08,990 --> 00:05:10,900
I don't know.

00:05:10,900 --> 00:05:14,650
And we should attempt to log in and see true on the console.

00:05:14,650 --> 00:05:23,471
And afterwards I'm going to use the wrong password which means funny� but it can mean

00:05:23,471 --> 00:05:25,270
funny guy kind of thing.

00:05:25,270 --> 00:05:28,800
Let's see that the model for the talk works.

00:05:28,800 --> 00:05:31,539
We get a true and a false, which we're supposed to.

00:05:31,539 --> 00:05:32,599
Great.

00:05:32,599 --> 00:05:37,800
Now, as I said before, plain text doesn't really work out.

00:05:37,800 --> 00:05:42,659
But that doesn't stop these guys from actually implementing plain text storage for passwords.

00:05:42,659 --> 00:05:48,690
I don't know if you have heard about this famous Sony hack in 2011 where they stole

00:05:48,690 --> 00:05:53,729
all of the PlayStation network� they were stored in plain text.

00:05:53,729 --> 00:06:00,690
Bell, a Canadian television provider stored all the passwords in plain text.

00:06:00,690 --> 00:06:02,860
Comcast.

00:06:02,860 --> 00:06:05,030
Yeah.

00:06:05,030 --> 00:06:06,729
So the problem, plain text.

00:06:06,729 --> 00:06:08,879
Just a problem enough itself.

00:06:08,879 --> 00:06:10,280
What can we do about it?

00:06:10,280 --> 00:06:12,440
We can try to obscure the passwords.

00:06:12,440 --> 00:06:14,550
We're not going to encrypt the passwords.

00:06:14,550 --> 00:06:16,129
That's not what we're going.

00:06:16,129 --> 00:06:21,879
We're going to look at another vendor later that did encrypt their passwords but had no

00:06:21,879 --> 00:06:25,509
idea what they were doing.

00:06:25,509 --> 00:06:29,280
What are we going to use?

00:06:29,280 --> 00:06:31,850
It's something called a hash function.

00:06:31,850 --> 00:06:37,659
You probably know what a hash function is or heard the word hash function.

00:06:37,659 --> 00:06:43,270
And hash functions powers the small, random numbers you get from your Git commits.

00:06:43,270 --> 00:06:48,759
But they have other properties that are variable.

00:06:48,759 --> 00:06:49,910
One is deterministic.

00:06:49,910 --> 00:06:54,220
So deterministic means that the output is solely dependent on the input.

00:06:54,220 --> 00:07:00,590
There is nothing in there, what's the alignment of the planets, what's the random number,

00:07:00,590 --> 00:07:03,520
take a rabbit out of a hat.

00:07:03,520 --> 00:07:05,219
So deterministic, very important.

00:07:05,219 --> 00:07:09,120
Number two, it's preimage resistant.

00:07:09,120 --> 00:07:12,960
That's a nice way of saying that it's one way.

00:07:12,960 --> 00:07:17,370
It means that you can't take the output and figure out what the input was.

00:07:17,370 --> 00:07:19,590
You can only take the input and get the output.

00:07:19,590 --> 00:07:20,819
Never the other way around kind of thing.

00:07:20,819 --> 00:07:27,509
And it has another property that sounds kind of similar, the preimage assistant.

00:07:27,509 --> 00:07:33,590
And that means if you have a hash function, or you have the hash, you know what the input

00:07:33,590 --> 00:07:37,599
to the hash function was, you can find another input that gives the same hash.

00:07:37,599 --> 00:07:45,150
So that means you can find another password that gives the same hash.

00:07:45,150 --> 00:07:49,419
Meaning that you would be able to find like a completely different password and try to

00:07:49,419 --> 00:07:51,740
crack the hashing function.

00:07:51,740 --> 00:07:54,159
And last thing is collision resistance.

00:07:54,159 --> 00:07:56,470
And that's kind of an involuntary collision.

00:07:56,470 --> 00:08:02,960
Meaning by some accident two passwords map to the same hash, which is this as well.

00:08:02,960 --> 00:08:05,919
So these are the properties the hash function has to obey.

00:08:05,919 --> 00:08:07,520
And we're not going to build a hash function.

00:08:07,520 --> 00:08:10,219
There are hash functions out there.

00:08:10,219 --> 00:08:16,380
I spent like three years being able to write this notation here.

00:08:16,380 --> 00:08:17,919
So� yeah.

00:08:17,919 --> 00:08:18,919
Waste of time.

00:08:18,919 --> 00:08:19,919
So I will save you.

00:08:19,919 --> 00:08:22,069
But this looks fancy, right?

00:08:22,069 --> 00:08:26,360
So another nice thing about hash functions� hash functions have heaps and heaps of applications.

00:08:26,360 --> 00:08:28,159
We are going to use them for passwords.

00:08:28,159 --> 00:08:35,020
But the most amazing property about hash functions means that you can take an extremely long

00:08:35,020 --> 00:08:40,500
stream of bits and you can hash it down to something that's finite.

00:08:40,500 --> 00:08:42,570
So it has like the bits in there.

00:08:42,570 --> 00:08:44,120
It's amazing.

00:08:44,120 --> 00:08:48,959
If you study hash functions, it will boggle your mind.

00:08:48,959 --> 00:08:51,740
So was there the demo?

00:08:51,740 --> 00:08:52,980
No, that's at the end.

00:08:52,980 --> 00:08:53,980
Here's hash functions.

00:08:53,980 --> 00:08:54,980
You have heard of some of them.

00:08:54,980 --> 00:09:05,370
MD5 was the first hash functions I learned about when I was building a system in PHP.

00:09:05,370 --> 00:09:08,310
I was born in 1993, MD5 was breaking in 1996.

00:09:08,310 --> 00:09:11,380
I was still wearing a diaper when it was broken.

00:09:11,380 --> 00:09:16,140
You probably heard about the recent shatter attack.

00:09:16,140 --> 00:09:18,490
This is broken too.

00:09:18,490 --> 00:09:22,870
It had a nice run, but, yeah, it's gone now.

00:09:22,870 --> 00:09:24,510
Then we have a couple of other hash functions.

00:09:24,510 --> 00:09:25,730
These are in green.

00:09:25,730 --> 00:09:31,250
These are cryptographically secure hash functions, but they are fast, and that's something we

00:09:31,250 --> 00:09:32,250
don't want.

00:09:32,250 --> 00:09:33,250
I'll show in a minute.

00:09:33,250 --> 00:09:37,690
And you might have a hard time seeing this.

00:09:37,690 --> 00:09:45,810
But I'll read, B script, S script, they are hash functions that you can use to store passwords.

00:09:45,810 --> 00:09:48,399
Not what I recommend, but you can do that.

00:09:48,399 --> 00:09:50,100
And then I have nothing is say about this one later.

00:09:50,100 --> 00:09:54,279
I have a little demo.

00:09:54,279 --> 00:09:59,500
Just open it up here.

00:09:59,500 --> 00:10:05,490
So because everyone knows MD5, and to make it clear that this is not the way you should

00:10:05,490 --> 00:10:08,360
do it, I used it as a hash function up here.

00:10:08,360 --> 00:10:14,640
If you run this, you can see that it� note.

00:10:14,640 --> 00:10:17,459
It gives the same output as before.

00:10:17,459 --> 00:10:24,730
Pretty simple now instead of doing a strict equality to the string, we have to hash the

00:10:24,730 --> 00:10:30,600
password again and compare the two hashes.

00:10:30,600 --> 00:10:34,540
And you can see here, I also tried to use some German words.

00:10:34,540 --> 00:10:38,430
Schildkrote, turtle and belina.

00:10:38,430 --> 00:10:40,020
Yeah.

00:10:40,020 --> 00:10:43,019
We get what we expect.

00:10:43,019 --> 00:10:51,779
This is the boiled down version of how you would do a hash in note with core script.

00:10:51,779 --> 00:10:57,269
The output of a hash function is often called a digest because you're like digesting something

00:10:57,269 --> 00:11:00,980
big into something small.

00:11:00,980 --> 00:11:02,260
These are the offenders.

00:11:02,260 --> 00:11:04,649
I don't know if you know these guys.

00:11:04,649 --> 00:11:10,160
But in 2015� and I said this was broken when I was wearing a diaper.

00:11:10,160 --> 00:11:15,220
In 2015, these guys were hacked and passwords leaked.

00:11:15,220 --> 00:11:21,589
And it turned out that they had used MD5 as the hash function for their passwords.

00:11:21,589 --> 00:11:28,600
[ Laughter ] So why is this a bad idea?

00:11:28,600 --> 00:11:34,509
It's because there's a very famous attack called a dictionary attack that you can perform

00:11:34,509 --> 00:11:39,670
on a password that is hashed this way.

00:11:39,670 --> 00:11:44,870
What you do is you have a dictionary, a large table of words or common passwords or some

00:11:44,870 --> 00:11:48,050
way of generating candidate passwords.

00:11:48,050 --> 00:11:53,709
Then you take all the passwords, or the words that your candidate has, and run them through

00:11:53,709 --> 00:11:54,709
the hash function.

00:11:54,709 --> 00:11:55,709
That's very fast.

00:11:55,709 --> 00:12:00,779
And afterward look up in the table whether you could find� whether you have a hash

00:12:00,779 --> 00:12:02,730
that matches the password you're trying to match.

00:12:02,730 --> 00:12:04,930
And then you have the plain text.

00:12:04,930 --> 00:12:09,450
This might seem farfetched, but it's actually very fast to run.

00:12:09,450 --> 00:12:12,540
So here I have been taking the� oh, wait.

00:12:12,540 --> 00:12:14,180
Is this going to work?

00:12:14,180 --> 00:12:15,180
Yeah, it's going to work.

00:12:15,180 --> 00:12:19,920
I have been taking the builtin diction that's pretty much on all index machines.

00:12:19,920 --> 00:12:25,430
And I run the code that was on the last slide and we are going to try and crack my password.

00:12:25,430 --> 00:12:31,290
And this is a shitty Mac book pro that runs on 1.2 gigahertz.

00:12:31,290 --> 00:12:36,529
It was state of the art hardwarewise eight years ago.

00:12:36,529 --> 00:12:40,769
And cracked my password in 1.3 seconds.

00:12:40,769 --> 00:12:48,750
So rainbow tables are very powerful if people don't know what they're doing kind of thing.

00:12:48,750 --> 00:12:50,110
So problem.

00:12:50,110 --> 00:12:51,170
Rainbow tables.

00:12:51,170 --> 00:12:55,040
What can we do about it?

00:12:55,040 --> 00:12:58,870
If a lot of people in the same database have the same passwords, they're going to have

00:12:58,870 --> 00:13:01,080
the same hash.

00:13:01,080 --> 00:13:05,330
And research shows that a lot of people choose very common passwords.

00:13:05,330 --> 00:13:11,009
So we are going to try and obscure that people have the same passwords, or make it very hard

00:13:11,009 --> 00:13:13,620
to generate these rainbow tables.

00:13:13,620 --> 00:13:18,459
So we want the identical passwords to yield unique hashes.

00:13:18,459 --> 00:13:19,740
So how do we do that?

00:13:19,740 --> 00:13:22,040
We use solid hashes.

00:13:22,040 --> 00:13:27,970
So solid hashes make� so the way you do a dictionary attack is that you generate these

00:13:27,970 --> 00:13:34,660
huge rainbow tables because storage is cheap and you can go and buy premade rainbow tables.

00:13:34,660 --> 00:13:39,639
So we want to make it impractical to generate these rainbow tables.

00:13:39,639 --> 00:13:45,540
And the way we do that is that we solve the passwords.

00:13:45,540 --> 00:13:53,040
So in this case� I can actually use� I generate a crypt graphically secure number

00:13:53,040 --> 00:13:58,779
of bytes and I go to the password and then the separator and then the password.

00:13:58,779 --> 00:14:08,010
And when we store in the database, we need to� this doesn't have to be private, it's

00:14:08,010 --> 00:14:09,600
just a random value.

00:14:09,600 --> 00:14:10,600
It's not random.

00:14:10,600 --> 00:14:14,110
It's stored in the database.

00:14:14,110 --> 00:14:20,709
Because the point is that if an adversary breaks your database and dumps the passwords,

00:14:20,709 --> 00:14:24,180
then you would have to generate a unique rainbow table for the users.

00:14:24,180 --> 00:14:29,810
Because they have a random piece of data in the password.

00:14:29,810 --> 00:14:32,959
And we can run this if we want to.

00:14:32,959 --> 00:14:35,519
It's not too interesting.

00:14:35,519 --> 00:14:36,800
Oh, wait.

00:14:36,800 --> 00:14:38,880
That's because I just� so� yeah.

00:14:38,880 --> 00:14:40,370
Just goes like that.

00:14:40,370 --> 00:14:42,220
Very fast and efficient.

00:14:42,220 --> 00:14:47,310
And it's since we implement, here's the details.

00:14:47,310 --> 00:14:54,129
I just chose 64 random bytes because all hash functions have something called block size.

00:14:54,129 --> 00:14:58,300
MD5 has a block size of I think 512 bits.

00:14:58,300 --> 00:14:59,880
64 times 8.

00:14:59,880 --> 00:15:00,880
That's 512.

00:15:00,880 --> 00:15:02,920
I don't know.

00:15:02,920 --> 00:15:03,920
Maybe.

00:15:03,920 --> 00:15:06,029
Something like that.

00:15:06,029 --> 00:15:08,320
So� yeah.

00:15:08,320 --> 00:15:09,320
These are the offenders.

00:15:09,320 --> 00:15:14,779
It's still very easy to break these solid hashes.

00:15:14,779 --> 00:15:18,220
It was state of the art like eight years ago.

00:15:18,220 --> 00:15:24,610
And I guess that's why it is still like common knowledge that it's okay to just install passwords,

00:15:24,610 --> 00:15:25,990
install them in the database.

00:15:25,990 --> 00:15:32,660
But what these guys did is they used a fast and efficient hash function.

00:15:32,660 --> 00:15:37,149
Some of them used MD5, still broken, still don't do that.

00:15:37,149 --> 00:15:40,949
And some of them used the one that's now broken.

00:15:40,949 --> 00:15:41,959
Don't do that either.

00:15:41,959 --> 00:15:45,310
That can be forgiven in a way.

00:15:45,310 --> 00:15:49,220
They still had eight years to migrate.

00:15:49,220 --> 00:15:51,720
I don't know if that's forgiven.

00:15:51,720 --> 00:15:53,490
Problem.

00:15:53,490 --> 00:15:54,490
It's way too efficient.

00:15:54,490 --> 00:15:56,720
It takes too little time to crack the passwords.

00:15:56,720 --> 00:16:06,250
You can go to Amazon and rent out one of their big servers and crack up the password hashing.

00:16:06,250 --> 00:16:12,250
I saw benchmark for saltedsh1 with the tool called hash cap.

00:16:12,250 --> 00:16:19,570
And it could do 2 million a second on the big server.

00:16:19,570 --> 00:16:22,050
There's the sound again.

00:16:22,050 --> 00:16:26,300
The big Amazon server only cost something like $8 an hour.

00:16:26,300 --> 00:16:31,269
So when you think about cracking passwords, you have to think about not how much time

00:16:31,269 --> 00:16:34,519
does it take, you have to think about how many dollars does it cost?

00:16:34,519 --> 00:16:39,930
The other day I read about a mathematician at a U.S. University working with the special

00:16:39,930 --> 00:16:40,930
curves.

00:16:40,930 --> 00:16:45,779
And to study the curves you had to generate heaps and heaps of them.

00:16:45,779 --> 00:16:50,420
To generate all the curves, he was trying to study took 60CPU years.

00:16:50,420 --> 00:16:52,569
It sounds like a long time.

00:16:52,569 --> 00:17:00,170
It took him just an afternoon to run 60 years of computation.

00:17:00,170 --> 00:17:07,900
That's where the intuition we have about time doesn't map to cracking passwords.

00:17:07,900 --> 00:17:09,230
So what can we do about this?

00:17:09,230 --> 00:17:11,560
Depends on money.

00:17:11,560 --> 00:17:15,370
So we can try and make it less efficient to crack our passwords.

00:17:15,370 --> 00:17:17,340
How do we do that?

00:17:17,340 --> 00:17:19,910
We use is rated hashing.

00:17:19,910 --> 00:17:26,810
It's one of the techniques you can use if what you're doing needs to be compliant, you

00:17:26,810 --> 00:17:34,200
can use a builtin function in Node crypt called PB� passwordbased key iteration function

00:17:34,200 --> 00:17:35,750
2.

00:17:35,750 --> 00:17:38,540
That's what we're going to do now.

00:17:38,540 --> 00:17:47,890
The thinking with the hash functions, you give a password, but also a work factor.

00:17:47,890 --> 00:17:52,580
How many times does it need to take the output to one hash iteration and use it for the next

00:17:52,580 --> 00:17:55,730
hash iteration and so on and so forth.

00:17:55,730 --> 00:18:02,070
And here we are going to use at� I want to use number five instead.

00:18:02,070 --> 00:18:03,120
Oh.

00:18:03,120 --> 00:18:09,330
So you can see now it takes a bit of time.

00:18:09,330 --> 00:18:11,040
There was the true, there was the false.

00:18:11,040 --> 00:18:16,020
So now we are doing something like, I don't know, 200 milliseconds for every time you

00:18:16,020 --> 00:18:18,230
need to authenticate a user.

00:18:18,230 --> 00:18:25,220
Now, an attack, instead of one millisecond per password or per hash, has to spend 200

00:18:25,220 --> 00:18:26,220
milliseconds per hash.

00:18:26,220 --> 00:18:35,100
And now those 60CPU years turn into a thousand CPU years or similar.

00:18:35,100 --> 00:18:38,500
This is what you need to do to use the PBKDF2.

00:18:38,500 --> 00:18:41,420
You can see there's a lot of parameters you have to save in the database.

00:18:41,420 --> 00:18:44,060
And a lot of things can go wrong.

00:18:44,060 --> 00:18:47,600
What about the future when this hash function is broken.

00:18:47,600 --> 00:18:48,990
All that stuff.

00:18:48,990 --> 00:18:54,390
You need to choose an iteration count, how many times to run for risk.

00:18:54,390 --> 00:18:58,950
How long a hash you want and what hash algorithm you want to use.

00:18:58,950 --> 00:19:04,430
And pass that in, runs asynchronous in another worker thread and doesn't block the event

00:19:04,430 --> 00:19:05,460
loop.

00:19:05,460 --> 00:19:11,940
And back you get an�error on the hash.

00:19:11,940 --> 00:19:13,580
I don't recommend you do this.

00:19:13,580 --> 00:19:15,440
Dropbox did this.

00:19:15,440 --> 00:19:17,300
It's not bad.

00:19:17,300 --> 00:19:20,240
I don't want to call them out.

00:19:20,240 --> 00:19:26,220
They used Bcrypt.

00:19:26,220 --> 00:19:29,340
It's based on a block cyber called Blowfish.

00:19:29,340 --> 00:19:39,990
And the only issue with Bcrypt, kind of a nonissue, it limits the password to 72 characters.

00:19:39,990 --> 00:19:44,070
I don't know anyone who would be able to remember a 72character password.

00:19:44,070 --> 00:19:51,450
It's more of a problem with pass phrase instead of a password.

00:19:51,450 --> 00:19:56,720
So the problem here is still that it's very easy to just run all these hash functions

00:19:56,720 --> 00:19:57,720
in parallel.

00:19:57,720 --> 00:20:01,580
And that's the whole deal with the GPU is that instead of having one call with a lot

00:20:01,580 --> 00:20:06,380
of memory, you have like thousands of calls each with very little memory.

00:20:06,380 --> 00:20:08,580
And I'm saying memory and memory all the time.

00:20:08,580 --> 00:20:12,910
I'm kind of hinting at what we can do next for even more money?

00:20:12,910 --> 00:20:15,180
Spend all the money on hashing.

00:20:15,180 --> 00:20:18,370
And now we are getting to what is kind of state of the art today.

00:20:18,370 --> 00:20:21,430
And that is key iteration functions.

00:20:21,430 --> 00:20:27,690
But a special kind of key iteration function that is purposefully slow because it both

00:20:27,690 --> 00:20:32,430
uses a lot of memory and a lot of computation.

00:20:32,430 --> 00:20:33,660
And here we have it.

00:20:33,660 --> 00:20:34,660
Argon2.

00:20:34,660 --> 00:20:40,530
In 2013, the academic community kind of had enough.

00:20:40,530 --> 00:20:44,020
Way too many breaches, way too easy to crack passwords.

00:20:44,020 --> 00:20:51,100
And there was no one place you could point to just say just use this and forget about

00:20:51,100 --> 00:20:52,100
the details.

00:20:52,100 --> 00:20:53,510
They made a competition.

00:20:53,510 --> 00:21:00,920
They had a lot of entries, and argon�2 was their recommendation at the end of the competition.

00:21:00,920 --> 00:21:06,180
So let's fire it up.

00:21:06,180 --> 00:21:11,460
So let's see� that's the number seven.

00:21:11,460 --> 00:21:12,680
And you can see.

00:21:12,680 --> 00:21:14,130
It's computing.

00:21:14,130 --> 00:21:15,570
Take a long time.

00:21:15,570 --> 00:21:19,700
Maybe it's taking too long a time.

00:21:19,700 --> 00:21:21,240
So that's what I was saying about this.

00:21:21,240 --> 00:21:22,930
There we go.

00:21:22,930 --> 00:21:27,080
So that was the first verification, and now it's trying to verify the next one.

00:21:27,080 --> 00:21:29,420
And you can see that it comes out there.

00:21:29,420 --> 00:21:39,550
Now, one issue is that� and I'll show that by showing you the code.

00:21:39,550 --> 00:21:42,550
So the issue is that this is blocking.

00:21:42,550 --> 00:21:49,020
I was trying to, when the hash function was spun up to authenticate, I was trying to log

00:21:49,020 --> 00:21:50,160
out.

00:21:50,160 --> 00:21:56,830
I was trying to log out console with the hash to show you that the event loop wasn't blocked,

00:21:56,830 --> 00:21:57,830
but it was.

00:21:57,830 --> 00:21:58,830
So that's kind of an issue.

00:21:58,830 --> 00:22:05,130
If you have a server running with thousands of people trying to authenticate, then you

00:22:05,130 --> 00:22:07,500
only have one guy at a time authenticating.

00:22:07,500 --> 00:22:10,600
And that's going to get your users very mad at you.

00:22:10,600 --> 00:22:17,560
So the good thing about this is I want to show you just the performance profile of the

00:22:17,560 --> 00:22:18,930
two functions.

00:22:18,930 --> 00:22:28,540
So here I have the PBKDF2 in a file where I ramped up the iteration count to something

00:22:28,540 --> 00:22:31,890
very high so we have a chance to stop it.

00:22:31,890 --> 00:22:40,740
It's a UNIX command to show how much memory and CPU a given process is using.

00:22:40,740 --> 00:22:43,170
So I'm going spin up here.

00:22:43,170 --> 00:22:47,000
You can see that the Node processer is pinking the CPU at 100%.

00:22:47,000 --> 00:22:55,270
But it's using 9 megabytes of memory, which isn't very much.

00:22:55,270 --> 00:23:03,950
I mean, the top of the line GPU server at Amazon has something like 24 kilo bytes of

00:23:03,950 --> 00:23:06,020
memory.

00:23:06,020 --> 00:23:11,270
I don't know how much it is� but it's a lot.

00:23:11,270 --> 00:23:12,670
Heaps and heaps.

00:23:12,670 --> 00:23:13,910
So just kill this.

00:23:13,910 --> 00:23:19,400
And instead let's go and look what the performance profile of Argon2 is.

00:23:19,400 --> 00:23:24,150
So, again, I spun up the work factor.

00:23:24,150 --> 00:23:25,150
Like heaps.

00:23:25,150 --> 00:23:26,740
And let's try and run it.

00:23:26,740 --> 00:23:32,370
And you can see now that it's, again, pegging the CPU, but it's also taking up 500 megabytes

00:23:32,370 --> 00:23:34,040
of memory.

00:23:34,040 --> 00:23:36,530
So it's very easy to do the math.

00:23:36,530 --> 00:23:39,580
24 gigabytes divided by 500, that's like 48.

00:23:39,580 --> 00:23:48,510
You can do 48 of these cracking attempts in parallel, which isn't very much.

00:23:48,510 --> 00:23:50,420
So� nice.

00:23:50,420 --> 00:23:54,000
But the problem is, there was blocking.

00:23:54,000 --> 00:23:58,530
This is the� if you want to do the blocking stuff, this is how I do it.

00:23:58,530 --> 00:24:04,030
I have a small library with one of my friends called Matias McIntosh online.

00:24:04,030 --> 00:24:08,270
It exposes it as the PB hash function.

00:24:08,270 --> 00:24:12,900
You can use it, but as you can see, it's a bit complicated.

00:24:12,900 --> 00:24:15,110
So� yeah.

00:24:15,110 --> 00:24:16,110
I was blocking.

00:24:16,110 --> 00:24:17,110
What can we do?

00:24:17,110 --> 00:24:18,400
We can make it asynchronous.

00:24:18,400 --> 00:24:19,400
That's what you have done for you.

00:24:19,400 --> 00:24:21,130
I have made it asynchronous.

00:24:21,130 --> 00:24:25,740
All you have to do is run npm install and secure password and I'll make the password

00:24:25,740 --> 00:24:27,580
secure for you.

00:24:27,580 --> 00:24:33,200
That's why I have the� [ Applause ]

00:24:33,200 --> 00:24:35,670
So you can use this today.

00:24:35,670 --> 00:24:40,990
It came out like two weeks ago and I'm still adding in a bunch of other features.

00:24:40,990 --> 00:24:46,110
One feature I'm still missing is because it's using so much memory it's actually a very

00:24:46,110 --> 00:24:50,510
real scenario that your box might run out of memory and the process will crash.

00:24:50,510 --> 00:24:52,550
The system will kill it for you.

00:24:52,550 --> 00:24:59,660
So I'm using� I'm still working on putting like a queue mechanism and you can check the

00:24:59,660 --> 00:25:05,480
queue and choose whether to bounce of the hashing tool, another machine or something

00:25:05,480 --> 00:25:06,850
like that.

00:25:06,850 --> 00:25:08,820
It's very easy to use.

00:25:08,820 --> 00:25:10,220
Here all there is to it.

00:25:10,220 --> 00:25:16,840
Don't need to think about salting or the work parameters or the algorithms or anything like

00:25:16,840 --> 00:25:17,840
that.

00:25:17,840 --> 00:25:19,430
Think about forward compatibility.

00:25:19,430 --> 00:25:21,250
It's very important when we do hash functions.

00:25:21,250 --> 00:25:26,040
Because if there's a paper coming out tomorrow saying there's a reduction attack on Argon2,

00:25:26,040 --> 00:25:28,580
we want to switch to something else, maybe.

00:25:28,580 --> 00:25:32,300
We can do that with this library too.

00:25:32,300 --> 00:25:34,490
Doesn't get much easier than this.

00:25:34,490 --> 00:25:36,280
I can just show you.

00:25:36,280 --> 00:25:41,720
So the parameters we ran it with before in blocking mode were high.

00:25:41,720 --> 00:25:45,890
So the secure password, the default settings should be good for now.

00:25:45,890 --> 00:25:51,220
They are set to what the backing library calls interactive settings.

00:25:51,220 --> 00:25:54,960
So settings suitable for passwords on the web.

00:25:54,960 --> 00:25:57,090
And if we run it, it's pretty fast.

00:25:57,090 --> 00:26:04,080
You don't have to wait for several seconds to compute the hash and authenticate them.

00:26:04,080 --> 00:26:06,700
Now, we are running out of time.

00:26:06,700 --> 00:26:10,650
So you can take this home with you.

00:26:10,650 --> 00:26:11,900
It has a couple of options.

00:26:11,900 --> 00:26:14,720
You can see in the readme what you can configure.

00:26:14,720 --> 00:26:20,720
It's very easy to use and it has an equally easy verify function for you to use.

00:26:20,720 --> 00:26:26,410
There's also a sync version in there if you want to use that, for command line stuff or

00:26:26,410 --> 00:26:27,410
whatever.

00:26:27,410 --> 00:26:28,410
So� yeah.

00:26:28,410 --> 00:26:29,410
Wait.

00:26:29,410 --> 00:26:30,410
There we go.

00:26:30,410 --> 00:26:31,410
Thank you.

00:26:31,410 --> 00:26:31,670

YouTube URL: https://www.youtube.com/watch?v=EAaweXzUVh4


