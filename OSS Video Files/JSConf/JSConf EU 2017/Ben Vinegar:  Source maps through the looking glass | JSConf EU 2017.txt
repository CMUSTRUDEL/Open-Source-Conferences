Title: Ben Vinegar:  Source maps through the looking glass | JSConf EU 2017
Publication date: 2017-05-23
Playlist: JSConf EU 2017
Description: 
	http://2017.jsconf.eu/speakers/ben-vinegar-source-maps-through-the-looking-glass.html

You’re probably familiar with source maps – they let you debug your original, unminified and untranspiled code in the browser. But ever wonder how they actually work? In this talk, we deep dive into the source map format to see what’s under the hood. We’ll cover source map generation tools and parsers, and learn how to manipulate source maps directly for fun and profit.
Captions: 
	00:00:01,870 --> 00:00:03,720
Source maps through the looking glass Ben Vinegar

00:00:03,720 --> 00:00:04,720
>> Hi everybody, hi.

00:00:04,720 --> 00:00:05,762
Hope you are enjoying yourselves.

00:00:05,762 --> 00:00:06,762
Get your bums inside, come on, let's get going with this.

00:00:06,762 --> 00:00:07,762
Cool.

00:00:07,762 --> 00:00:08,762
I hope everyone is loving it.

00:00:08,762 --> 00:00:09,762
Is everybody pleased?

00:00:09,762 --> 00:00:12,450
Come on, let's get up a gentle whoop if you are enjoying this.

00:00:12,450 --> 00:00:13,450
Come on.

00:00:13,450 --> 00:00:14,450
See!

00:00:14,450 --> 00:00:15,450
There we go, very gentle.

00:00:15,450 --> 00:00:16,450
Very gentle, hungover people.

00:00:16,450 --> 00:00:17,450
It's okay.

00:00:17,450 --> 00:00:18,450
Everything will be fine.

00:00:18,450 --> 00:00:20,220
Take some aspirin, everything will be okay.

00:00:20,220 --> 00:00:25,190
Our next speaker is joining us all the way from San Francisco because we haven't had

00:00:25,190 --> 00:00:26,750
enough Americans speaking here today.

00:00:26,750 --> 00:00:28,610
They are here and taking over!

00:00:28,610 --> 00:00:30,540
He works at a company called Sentry, he is a published author, wrote a book called Third

00:00:30,540 --> 00:00:31,540
Party JavaScript.

00:00:31,540 --> 00:00:32,540
Hands up if you have read this one.

00:00:32,540 --> 00:00:33,540
Wow, nobody has read it apparently.

00:00:33,540 --> 00:00:34,540
We have an illiterate crowd here.

00:00:34,540 --> 00:00:35,540
I hunted about Ben before and was going through his Twitter feed and was just looking at everything,

00:00:35,540 --> 00:00:36,540
and when you see heart, heart, favourite, retweet, retweet, you know you've found somebody

00:00:36,540 --> 00:00:37,540
very special, so without further ado, let's give a big hand for our next speaker, Ben

00:00:37,540 --> 00:00:38,540
Vinegar.

00:00:38,540 --> 00:00:39,540
[Applause] BEN: Hello, everybody.

00:00:39,540 --> 00:00:40,540
So welcome to this talk.

00:00:40,540 --> 00:00:41,540
It's called Source Maps Through the Looking Glass and I realise now that a looking glass

00:00:41,540 --> 00:00:42,540
is not actually a magnifying glass, it's a mirror, but humour me.

00:00:42,540 --> 00:00:47,829
The idea of this talk is to do a deep dive into source maps, maybe use them today but

00:00:47,829 --> 00:00:51,010
they are kind of a black box technology so we are going to go deeper and uncover what's

00:00:51,010 --> 00:00:53,190
there.

00:00:53,190 --> 00:00:55,870
My name is unfortunately Ben Vinegar, it's a real name.

00:00:55,870 --> 00:01:07,220
I work at a company called Sentry, an open source company that informs you of errors

00:01:07,220 --> 00:01:12,550
in your applications, be they single page JavaScript applications or server side code

00:01:12,550 --> 00:01:17,400
or mobile apps and I will touch on that a little bit later in this talk.

00:01:17,400 --> 00:01:23,260
So to kick things off, just want to talk a little bit about how JavaScript is used today

00:01:23,260 --> 00:01:27,220
in 2017.

00:01:27,220 --> 00:01:35,800
How many people here use like a modern dialect of JavaScript, ES6, 2015, 2017, 2030, 2045?

00:01:35,800 --> 00:01:42,950
Okay, so most people, then you are familiar with this slide which is a really simple function

00:01:42,950 --> 00:01:50,330
using ES6 modules and using like rest operator and it also has arrow functions.

00:01:50,330 --> 00:01:56,950
I love these features, they make running JavaScript more fun but I work on a software product

00:01:56,950 --> 00:02:04,430
that still targets browsers like IE11 and I run it through a tool called Babel and it

00:02:04,430 --> 00:02:11,610
generates code like this and this will run IE11 just fine.

00:02:11,610 --> 00:02:17,129
I want to keep going because for some contrived reason I must also wrap this in webpack, so

00:02:17,129 --> 00:02:24,069
I run that through this tool and it generates a lot more content, but of course I don't

00:02:24,069 --> 00:02:28,600
actually want to ship all of these characters to end users so I run this through one more

00:02:28,600 --> 00:02:33,969
time and I'm left with something like this, this probably seems pretty familiar for most

00:02:33,969 --> 00:02:35,889
people.

00:02:35,889 --> 00:02:43,069
So somebody famous once said, like JavaScript has become the assembly language of the web,

00:02:43,069 --> 00:02:46,269
and I had heard this many times over the years and I always thought this was something that

00:02:46,269 --> 00:02:54,410
Brendan said, maybe it was when he announced Web Assembly, it seems like the type of thing

00:02:54,410 --> 00:03:00,340
that he would talk about but it was actually coined all the way back in 2011 by Scott Hanselman,

00:03:00,340 --> 00:03:08,150
an author and blogger, and he was just observing that when he browsed around his favourite

00:03:08,150 --> 00:03:13,029
websites, be they Google or Facebook, that the code that was being served to him, nobody

00:03:13,029 --> 00:03:17,069
wrote this; this was being generated by tools.

00:03:17,069 --> 00:03:24,709
This was before Babel, webpack etc and the comparison to assembly is pretty apt.

00:03:24,709 --> 00:03:29,370
It's not just a compilation target but assembly is really hard to read.

00:03:29,370 --> 00:03:34,219
I do not know how many of you have worked with compiled languages or even written assembly

00:03:34,219 --> 00:03:40,569
but it looks like this, the actual machine instructions that your computer uses to do

00:03:40,569 --> 00:03:42,310
stuff.

00:03:42,310 --> 00:03:47,470
Some of these commands are stuff like: move a value from one memory location to a register;

00:03:47,470 --> 00:03:53,719
do an additional operation on that register; jump to another location in your program,

00:03:53,719 --> 00:03:55,430
etc.

00:03:55,430 --> 00:04:02,099
I have experimented with trying to debug compiled applications using just assembly and I have

00:04:02,099 --> 00:04:03,549
found this very difficult.

00:04:03,549 --> 00:04:08,049
I have no idea what my program is doing whatsoever and maybe if you are a programming God you

00:04:08,049 --> 00:04:12,400
might be able to do this but I'm incapable.

00:04:12,400 --> 00:04:18,350
Of course, you know, if you are debugging in the browser it doesn't look too dissimilar.

00:04:18,350 --> 00:04:19,350
My code looks like this.

00:04:19,350 --> 00:04:26,059
I have single letter variables, all my functions have been reduced to nonsense, stepping around

00:04:26,059 --> 00:04:31,169
- you can kind of maybe understand what your programme is doing but it's really difficult.

00:04:31,169 --> 00:04:33,389
Similarly, this isn't just debugging in Chrome.

00:04:33,389 --> 00:04:39,490
This is a screen shot from Sentry, and what we do is take crash reports from client side

00:04:39,490 --> 00:04:43,680
JavaScript and suck those up into our web server and give you a sack trace to help you

00:04:43,680 --> 00:04:53,960
reproduce the bug but it's not very experienced for minified code, if you are looking at column

00:04:53,960 --> 00:05:06,960
... that's not very helpful.

00:05:06,960 --> 00:05:16,659
If I compile a complication and add this like dash-dash debug symbol on Mac OS I get this

00:05:16,659 --> 00:05:22,470
decent folder on Mac OS if I'm building with LOVM - I don't want to get too deep into that

00:05:22,470 --> 00:05:28,300
- but if I fire up my debugger again with my compiled program and those symbol files

00:05:28,300 --> 00:05:34,310
are available, the experience of debugging is a lot easier.

00:05:34,310 --> 00:05:39,919
Now I can actually step through the code that I wrote, I can actually inspect variables

00:05:39,919 --> 00:05:45,880
using their logical names and not using like memory addresses or register locations, and

00:05:45,880 --> 00:05:49,039
it's plausible to do things this way.

00:05:49,039 --> 00:05:55,000
So debug symbols map machine instructions, just source locations and symbols, etc, so

00:05:55,000 --> 00:06:01,370
why don't we have this - if we've had this forever in compiled languages, why don't we

00:06:01,370 --> 00:06:03,850
have them in JavaScript or in other languages?

00:06:03,850 --> 00:06:10,720
Well, JavaScript is different because we are not compiling into some intermediate form,

00:06:10,720 --> 00:06:15,750
be it by code or machine code; we are really just taking text and transforming it to some

00:06:15,750 --> 00:06:22,100
other piece of text, right, so the existing sort of debug symbol formats or whatever don't

00:06:22,100 --> 00:06:24,919
really work in this world.

00:06:24,919 --> 00:06:36,210
Furthermore, when you have debug symbols and you are doing this, you are not sending it

00:06:36,210 --> 00:06:42,370
over the Internet back and forth, so many format symbols are not really designed for

00:06:42,370 --> 00:06:44,030
consumption over the web.

00:06:44,030 --> 00:06:48,870
This is a bit of a long preamble to where we all know where this is going, which is

00:06:48,870 --> 00:06:53,360
source maps and what the topic of this talk is.

00:06:53,360 --> 00:06:59,870
So if you didn't know source maps are pretty much a JSON file and it has a format whose

00:06:59,870 --> 00:07:07,810
content let you map file names, lines, columns that appear in sort of an output file back

00:07:07,810 --> 00:07:12,419
into - up to N input source files.

00:07:12,419 --> 00:07:15,910
The source files can be any kind of text, there's nothing about the source map format

00:07:15,910 --> 00:07:20,360
specifically that's designed extremely for JavaScript.

00:07:20,360 --> 00:07:28,350
It can be used for things like CSS ... or other transformations and it's also planned

00:07:28,350 --> 00:07:33,389
for over HTTP and we will see what that means in a bit.

00:07:33,389 --> 00:07:40,192
So the very first version of this source map spec, I'm not sure exactly sure but I think

00:07:40,192 --> 00:07:44,830
it was dated around 2009 and was built for a tool called Closure Inspector.

00:07:44,830 --> 00:07:48,580
Does anyone here use Closure Compiler?

00:07:48,580 --> 00:07:51,630
Okay, maybe five hands.

00:07:51,630 --> 00:07:54,569
I'm actually surprised, I thought there would be more than that but Closure Compiler is

00:07:54,569 --> 00:08:00,110
an optimiser and a minifier, kind of like prepack if you've looked at that a little

00:08:00,110 --> 00:08:05,370
bit, but it has been around for a long time and one of the Closure Compiler developers

00:08:05,370 --> 00:08:15,509
wanted to map what they were seeing back to the original code so he built a Firebug plugin

00:08:15,509 --> 00:08:19,810
and that used effectively the very first version of source maps.

00:08:19,810 --> 00:08:24,210
It went through a couple of revisions and the latest version is actually revision 3

00:08:24,210 --> 00:08:26,380
which was written in 2011.

00:08:26,380 --> 00:08:29,250
Six years ago is a long time in our world.

00:08:29,250 --> 00:08:32,469
It has been updated a few times.

00:08:32,469 --> 00:08:35,839
But something to know is that this is just a proposal.

00:08:35,839 --> 00:08:41,640
You can't go to MDN and find some really fleshed out specification that says what a source

00:08:41,640 --> 00:08:42,640
map is.

00:08:42,640 --> 00:08:49,130
It's just like Google Doc that's on the Internet and you can see at any moment who is reading

00:08:49,130 --> 00:08:52,670
it at the same time, usually about a dozen people, and you can attempt to chat to them

00:08:52,670 --> 00:08:56,990
but they are usually not listening.

00:08:56,990 --> 00:09:01,780
So despite the fact that this is kind of like this specification that doesn't have the standards

00:09:01,780 --> 00:09:06,170
value behind it, it doesn't really matter because everything kind of uses it which is

00:09:06,170 --> 00:09:07,279
really cool.

00:09:07,279 --> 00:09:20,310
Compilers, you know, be it Battle or even C2 JavaScript compiler, module bundlers, every

00:09:20,310 --> 00:09:27,029
browser, tools like Sentry, so we unminify stack traces, Node stack support is interesting

00:09:27,029 --> 00:09:36,670
that will magically convert conceptions into their original format if you are maybe using

00:09:36,670 --> 00:09:39,650
typescript on the server or something like that.

00:09:39,650 --> 00:09:43,120
So we are going to go through like an end to end example to understand how source maps

00:09:43,120 --> 00:09:44,120
work.

00:09:44,120 --> 00:09:47,529
I am going to bring us all the way back to this function that I showed you at the beginning,

00:09:47,529 --> 00:09:52,090
add JS, just an add function etc.

00:09:52,090 --> 00:10:04,040
I am going to run this through Babel, just to keep this simple, so from Babel I can just

00:10:04,040 --> 00:10:12,940
say: hey, take add.JS, take this file, I'm using this ES2015 pre-set to target a particular

00:10:12,940 --> 00:10:19,640
set of browsers, and then also specify this source maps configuration.

00:10:19,640 --> 00:10:22,860
If I run that command a couple of things are going to happen.

00:10:22,860 --> 00:10:33,270
My file is going to be modified a little bit, and also I get a source map file but before

00:10:33,270 --> 00:10:38,579
I jump to that source map file let's take a look at the output file and at dys.js.

00:10:38,579 --> 00:10:46,779
It's pretty much the same except with one key addition which is it adds this line to

00:10:46,779 --> 00:10:50,490
the end of the file which is this source mapping URL directive.

00:10:50,490 --> 00:10:54,870
This is the thing that tells browsers and other tools where to find the source map file

00:10:54,870 --> 00:10:59,790
that is associated with this JavaScript file.

00:10:59,790 --> 00:11:05,520
So browser downloads your JavaScript file, goes to the very end, looks for the last comment

00:11:05,520 --> 00:11:14,490
and goes, "Aha, I need to add JS.map", and that is relative.

00:11:14,490 --> 00:11:18,649
It doesn't have to be relative, you can specify a full path and that's where the browser will

00:11:18,649 --> 00:11:20,589
download it from.

00:11:20,589 --> 00:11:24,339
A lot of people talk to me that they want to use source maps but don't want to expose

00:11:24,339 --> 00:11:31,769
[audio problem] ... can have your source mapping URL point to a location that's maybe only

00:11:31,769 --> 00:11:37,360
accessible on a private network so you can download it and other interlopers can't.

00:11:37,360 --> 00:11:45,300
You could even host those files locally on your own little web server, so you can point

00:11:45,300 --> 00:11:49,870
back at local host and you will be able to download that file.

00:11:49,870 --> 00:11:52,730
Another thing that not everybody is aware of is you don't have to use this source mapping

00:11:52,730 --> 00:11:53,730
URL directive.

00:11:53,730 --> 00:12:00,170
There's a header called source map that you can send down with your file that is a clue

00:12:00,170 --> 00:12:05,910
to your browser where to find these source maps, but not everybody has the power to just

00:12:05,910 --> 00:12:08,459
arbitrarily change headers.

00:12:08,459 --> 00:12:11,420
Again, I mentioned CSS earlier.

00:12:11,420 --> 00:12:19,360
It doesn't strictly have to be this // comment; you can also use this CSS comment at the end

00:12:19,360 --> 00:12:23,709
of your file too.

00:12:23,709 --> 00:12:27,430
If you want to get started with source maps and just want to use them, this is pretty

00:12:27,430 --> 00:12:28,899
much all you need to do.

00:12:28,899 --> 00:12:33,740
You use tools, generate a source map file, put them on your web server, the browser will

00:12:33,740 --> 00:12:38,600
download them and now when you start debugging you get to step 3.

00:12:38,600 --> 00:12:42,800
That's pretty cool, that's it.

00:12:42,800 --> 00:12:45,640
So I would recommend doing that.

00:12:45,640 --> 00:12:50,389
Similarly, Sentry, we kind of act like a browser.

00:12:50,389 --> 00:12:56,680
We actually when we see stack traces that have JavaScript files in them, will actually

00:12:56,680 --> 00:13:00,829
try to fetch those JavaScript files and if we see that there's a source map header or

00:13:00,829 --> 00:13:04,339
a source mapping URL directive we will download that source map and will apply it to your

00:13:04,339 --> 00:13:09,579
stack trace and try to show you the original file, the line and the column, and we even

00:13:09,579 --> 00:13:13,250
pull surrounding source code too, which is kind of cool, so in this case this is actually

00:13:13,250 --> 00:13:20,401
an example from our live application with some JSX and that's kind of neat.

00:13:20,401 --> 00:13:23,381
But we are going to go a little bit deeper because I think it's interesting just to understand

00:13:23,381 --> 00:13:25,120
how does a source map even work.

00:13:25,120 --> 00:13:32,110
How many people here have like tried to open a production source map in their text editor?

00:13:32,110 --> 00:13:35,550
Okay, was that a good experience?

00:13:35,550 --> 00:13:36,830
No, okay.

00:13:36,830 --> 00:13:42,160
Typically this is what happens to me which is like my editor pretty much crashes, and

00:13:42,160 --> 00:13:44,649
they say because source maps can get really big.

00:13:44,649 --> 00:13:47,910
It's totally normal for them to be megabytes in size.

00:13:47,910 --> 00:13:52,029
We've seen source maps as large as 30 megabytes which is pretty absurd.

00:13:52,029 --> 00:13:56,480
The reason we started this with a contrived simple example is that this entire source

00:13:56,480 --> 00:14:01,889
map can fit in one slide so this is what a source map looks like.

00:14:01,889 --> 00:14:06,959
I've pushed around the white space a bit so you can read it easier and we will go through

00:14:06,959 --> 00:14:09,560
all the pieces of this really quickly.

00:14:09,560 --> 00:14:14,160
So the very first piece is just a version spring, a clue to the browser what version

00:14:14,160 --> 00:14:16,230
am I dealing with.

00:14:16,230 --> 00:14:19,580
As we learned early version 3 is pretty much the latest.

00:14:19,580 --> 00:14:24,050
So pretty much everything says version 3.

00:14:24,050 --> 00:14:27,050
What file is associated with this, what is this source map for?

00:14:27,050 --> 00:14:28,050
In this case it's add.js.

00:14:28,050 --> 00:14:33,370
It's associated with one file.

00:14:33,370 --> 00:14:38,190
Sources are a list of input files that went into this output file.

00:14:38,190 --> 00:14:44,720
In our case it's a single file, but if this had many components, modules, you can imagine

00:14:44,720 --> 00:14:49,470
this could be dozens, maybe even hundreds or a thousand files.

00:14:49,470 --> 00:14:53,360
Sources content, this is like an optional feature of source maps.

00:14:53,360 --> 00:14:59,860
Babel inlines all our code into the source map for convenience, and you don't have to

00:14:59,860 --> 00:15:05,459
do this but this is also what contributes to source as being so large but it's convenient

00:15:05,459 --> 00:15:06,660
because it works out of the box.

00:15:06,660 --> 00:15:10,220
You don't have to deal with other problems like where do you find all of these other

00:15:10,220 --> 00:15:11,950
source files.

00:15:11,950 --> 00:15:17,170
Lastly, this is the biggest part of what makes a source map a source map, which is this big

00:15:17,170 --> 00:15:18,450
mappings blob.

00:15:18,450 --> 00:15:25,990
It kind of looks like a bunch of nonsense but it isn't and we are going to walk through

00:15:25,990 --> 00:15:31,560
actually translating something by hand, just so you understand what is taking place.

00:15:31,560 --> 00:15:37,300
So one thing to know is that when you are doing source map parsers, they work through

00:15:37,300 --> 00:15:39,680
a source map or this mappings property linearly.

00:15:39,680 --> 00:15:44,690
They start at the very beginning and the very beginning represents line 0.

00:15:44,690 --> 00:15:48,340
It's not like random access, you can't go to the middle of this blob, you have to process

00:15:48,340 --> 00:15:51,360
the whole thing in order.

00:15:51,360 --> 00:15:58,379
So each semicolon denotes a new line so we start at line zero and you will notice that

00:15:58,379 --> 00:16:03,900
this source map actually begins with five semicolons and that may seem kind of weird.

00:16:03,900 --> 00:16:10,110
The reason for that is that Babel outputs some sort of preamble to the output file for

00:16:10,110 --> 00:16:15,350
which there's actually like no matching code or input file and the source map basically

00:16:15,350 --> 00:16:16,350
recognises that.

00:16:16,350 --> 00:16:23,100
It's like: hey, just skip over this because there's nothing for us to even point to here.

00:16:23,100 --> 00:16:28,250
So if we continue, we go past those first opening lines, and we get to what's called

00:16:28,250 --> 00:16:29,779
a segment.

00:16:29,779 --> 00:16:34,650
Segments are comma separated and these are the things that actually make the translation

00:16:34,650 --> 00:16:39,390
from your output source to your input source.

00:16:39,390 --> 00:16:42,819
Segments are made of variable length quantities.

00:16:42,819 --> 00:16:49,680
Now, what is QA - maybe that's an L or an I, I'm not sure - GB.

00:16:49,680 --> 00:16:53,300
So it's a variable length quantity called VOQ.

00:16:53,300 --> 00:17:00,360
This is sort of a format that's designed for efficiently encoding arbitrarily large integers.

00:17:00,360 --> 00:17:09,780
It's a little different and was designed for midi files which is interesting.

00:17:09,780 --> 00:17:18,579
So for single characters this is fine, but as you get larger, 123 is only three characters,

00:17:18,579 --> 00:17:27,490
123456789, five characters, or six, so if it's plain text and we've got to download

00:17:27,490 --> 00:17:31,690
it we want to represent that in as small a format as possible.

00:17:31,690 --> 00:17:39,740
What is actually neat about VOQ is arbitrary lengths can also be included efficiently.

00:17:39,740 --> 00:17:44,200
That's the last digit at the bottom.

00:17:44,200 --> 00:17:50,910
It's represented by these five characters so we get to avoid commas and the negative

00:17:50,910 --> 00:17:55,210
prefix which is pretty cool.

00:17:55,210 --> 00:17:58,610
The specifics of how to actually convert these, I don't really know.

00:17:58,610 --> 00:18:03,151
I just let this library called VOQ which you can install to decode them and that's how

00:18:03,151 --> 00:18:07,500
I work through a lot of these problems.

00:18:07,500 --> 00:18:10,130
So let's go back to this QAIGB.

00:18:10,130 --> 00:18:19,830
If I decode this I get 80416 so what does that mean?

00:18:19,830 --> 00:18:21,110
Once you break it down it's pretty simple.

00:18:21,110 --> 00:18:23,789
This is where now the source map starts to make sense.

00:18:23,789 --> 00:18:30,770
The very first value is the column in our output file, add.js, and remember because

00:18:30,770 --> 00:18:36,950
we are working linearly we already know what the line number is, which is like line 5.

00:18:36,950 --> 00:18:39,020
The second value is indexing [sound problem] array.

00:18:39,020 --> 00:18:42,890
We only have a single array so it's 0.

00:18:42,890 --> 00:18:49,390
Then the final are the input and the input source file, so if I convert this, this is

00:18:49,390 --> 00:18:53,929
basically what this segment is trying to tell us.

00:18:53,929 --> 00:18:58,490
We are currently on column 5 line 9 of add.js.

00:18:58,490 --> 00:19:05,560
For this one it's column 5, line 17 and if I break this down and go back to my input

00:19:05,560 --> 00:19:13,539
and output file, it's saying in the output file add is over here and in my input file

00:19:13,539 --> 00:19:16,540
add is over there.

00:19:16,540 --> 00:19:25,539
That's pretty much how this works.

00:19:25,539 --> 00:19:30,220
Source maps really just - they could be character by character, there's nothing that would stop

00:19:30,220 --> 00:19:34,950
you from doing this but we only need to source map the start locations of identifiers.

00:19:34,950 --> 00:19:39,929
That's efficient because if we mapped every single character this mappings property would

00:19:39,929 --> 00:19:45,890
be gigantic but if we only have to do identifiers, it's much smaller so I am only going to convert

00:19:45,890 --> 00:19:50,450
one more value just to kind of bring this idea home.

00:19:50,450 --> 00:19:53,640
The very next value, the very next segment if you can see it is actually just a capital

00:19:53,640 --> 00:19:59,190
G which is a little confusing because it's like: wait a minute, didn't I need four values

00:19:59,190 --> 00:20:00,200
to translate something?

00:20:00,200 --> 00:20:04,760
What am I going to do with this single value which is actually a 8?

00:20:04,760 --> 00:20:06,870
Oh, actually I think it's a 3.

00:20:06,870 --> 00:20:09,700
I may have messed this up.

00:20:09,700 --> 00:20:12,930
So segment values are relative.

00:20:12,930 --> 00:20:16,429
This is sort of like a space-saving kind of idea, right, like I don't need to have the

00:20:16,429 --> 00:20:19,330
absolute value for every single segment.

00:20:19,330 --> 00:20:24,130
I can just work off what I was doing in the last segment so if we just add this value

00:20:24,130 --> 00:20:32,520
to the previous segment and we get a new location which is 11 instead of character 8 - bear

00:20:32,520 --> 00:20:38,970
with me, this is a little confusing - but the idea is there was another identifier add.

00:20:38,970 --> 00:20:40,100
Add appears twice, right?

00:20:40,100 --> 00:20:44,919
So this is actually linking back to the same location.

00:20:44,919 --> 00:20:54,850
Remember, the very first value is the location in the output file, right, so line 5, line

00:20:54,850 --> 00:20:57,210
17, like that didn't change.

00:20:57,210 --> 00:21:02,870
So what's really happening here is that the source map is telling us that this add function

00:21:02,870 --> 00:21:06,750
appears twice in the file, which is kind of interesting.

00:21:06,750 --> 00:21:11,679
So hopefully you have a basic understanding of how this is going.

00:21:11,679 --> 00:21:17,309
I would just keep working through these values, keep translating them, keep getting new translations,

00:21:17,309 --> 00:21:21,960
but the idea here is that I finish in a place where I basically take all these values and

00:21:21,960 --> 00:21:26,529
I dump them into some data structure like a table so that going forward I don't actually

00:21:26,529 --> 00:21:32,240
look at the source map; I just kind of like query this table for the data.

00:21:32,240 --> 00:21:36,480
This is how Web Inspector works, other tools, Sentry etc, work.

00:21:36,480 --> 00:21:41,720
They just munch through a source map, generate this big lookup table and then the rest is

00:21:41,720 --> 00:21:45,370
- just kind of works by itself.

00:21:45,370 --> 00:21:49,080
It seems like a lot to take in but the good news is you don't ever really need to know

00:21:49,080 --> 00:21:50,279
the particulars of how this works.

00:21:50,279 --> 00:21:53,840
I just wanted to explain what is happening because it's kind of neat.

00:21:53,840 --> 00:22:04,159
There is a tool called source-map, it's on npm, it's from Mozilla, and it does what we

00:22:04,159 --> 00:22:09,799
just did, breaks down the source map and provides an API where you can look up the location

00:22:09,799 --> 00:22:11,760
for yourself.

00:22:11,760 --> 00:22:15,640
The API is a little complex because it does a lot but it looks like this.

00:22:15,640 --> 00:22:20,530
I import this library, I read my source map file from the file system, I then create what's

00:22:20,530 --> 00:22:25,480
called a source map consumer, and then I can look up, you know, original position for line

00:22:25,480 --> 00:22:29,950
6, column 0, whatever I want to look up and it will tell me which file, what line, what

00:22:29,950 --> 00:22:35,440
column, so if you are working with source maps and you've ever struggled with - it seems

00:22:35,440 --> 00:22:38,700
like the lines and columns don't match up exactly the way that you wanted, I recommend

00:22:38,700 --> 00:22:41,880
using this library to look up the values yourself to see if they make sense.

00:22:41,880 --> 00:22:46,490
That can spare a lot of time with debugging.

00:22:46,490 --> 00:22:49,409
So this kind of takes me to the end.

00:22:49,409 --> 00:22:50,409
What do we learn?

00:22:50,409 --> 00:22:51,409
It's a bit of a wrap-up.

00:22:51,409 --> 00:22:54,390
So source maps are kind of debug symbols for the web.

00:22:54,390 --> 00:22:55,390
That's close enough.

00:22:55,390 --> 00:22:57,070
They are just files, lines and columns.

00:22:57,070 --> 00:23:04,970
They are designed for efficient transmission over HTTP, that's why there's these relative

00:23:04,970 --> 00:23:10,520
segments, etc, and the cool thing is that almost everything supports them today so if

00:23:10,520 --> 00:23:14,490
you are not using them, you should be using them.

00:23:14,490 --> 00:23:19,419
So again, my name is Ben Vinegar, I hope that you've found this talk vaguely illuminating.

00:23:19,419 --> 00:23:21,039
If you want to find me, this is me on the Internet.

00:23:21,039 --> 00:23:22,850
This is a link to pretty much everything we talked to today.

00:23:22,850 --> 00:23:26,130
Please check out Sentry, it's really helpful and it's open source and you can run it on

00:23:26,130 --> 00:23:27,130
your own server.

00:23:27,130 --> 00:23:28,130
Thank you.

00:23:28,130 --> 00:23:28,140

YouTube URL: https://www.youtube.com/watch?v=NkVes0UMe9Y


