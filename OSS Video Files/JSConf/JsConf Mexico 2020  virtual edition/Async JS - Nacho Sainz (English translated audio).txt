Title: Async JS - Nacho Sainz (English translated audio)
Publication date: 2021-02-02
Playlist: JsConf Mexico 2020  virtual edition
Description: 
	In this talk, Nacho Sainz -front end engineer at Nextiva- will talk about what asynchronous code means, the different tools that can be used (such as the "callback" functions for handling the browser APIs, the "promises" and the "async / await" methodology) explaining with the Javascript engine (according to the specs) mentioning the "event loop" and its corresponding queues.
Captions: 
	00:00:04,080 --> 00:00:07,279
welcome

00:00:05,200 --> 00:00:08,400
to this talk we are going to try to

00:00:07,279 --> 00:00:11,840
teach you what

00:00:08,400 --> 00:00:15,679
are the backbone uh behind

00:00:11,840 --> 00:00:18,080
the async js these are concepts

00:00:15,679 --> 00:00:19,680
that help us understand how are we

00:00:18,080 --> 00:00:21,600
programming and how everything is

00:00:19,680 --> 00:00:24,800
working

00:00:21,600 --> 00:00:26,800
behind everything so it's it's good to

00:00:24,800 --> 00:00:27,760
learn the things that are not included

00:00:26,800 --> 00:00:30,640
in the framework

00:00:27,760 --> 00:00:32,559
so what i want you to understand is

00:00:30,640 --> 00:00:35,040
understanding something very

00:00:32,559 --> 00:00:36,640
very basic such as data structure but

00:00:35,040 --> 00:00:40,000
you also have to understand how the

00:00:36,640 --> 00:00:42,000
ecosystem of the language works

00:00:40,000 --> 00:00:43,520
so this is why we're going to see

00:00:42,000 --> 00:00:46,960
different topics

00:00:43,520 --> 00:00:49,680
first is callbacks and how we handle

00:00:46,960 --> 00:00:52,320
things with all the browser apis

00:00:49,680 --> 00:00:52,879
the promises that it is a new thing of

00:00:52,320 --> 00:00:55,120
tracking

00:00:52,879 --> 00:00:56,559
everything that's going on iterators

00:00:55,120 --> 00:01:00,000
that it is a new way

00:00:56,559 --> 00:01:03,280
to of having the usual loops

00:01:00,000 --> 00:01:07,439
that we used to do them strictly like

00:01:03,280 --> 00:01:09,360
how step by step the machine had to go

00:01:07,439 --> 00:01:10,640
for it to be able to grab that data

00:01:09,360 --> 00:01:12,640
structure

00:01:10,640 --> 00:01:14,560
then generators that's a new part of

00:01:12,640 --> 00:01:17,280
javascript that tells you that you can

00:01:14,560 --> 00:01:19,680
have functions that can be paused

00:01:17,280 --> 00:01:20,720
and the async await method that gives us

00:01:19,680 --> 00:01:23,600
a little bit of

00:01:20,720 --> 00:01:23,920
legibility about how we are doing all

00:01:23,600 --> 00:01:26,799
this

00:01:23,920 --> 00:01:28,960
synchronicity in our programming and

00:01:26,799 --> 00:01:31,439
finally we'll reach conclusions about

00:01:28,960 --> 00:01:34,320
when we should use each one so to be

00:01:31,439 --> 00:01:34,320
able to start

00:01:34,560 --> 00:01:40,799
so our approach is going to be callbacks

00:01:37,680 --> 00:01:42,640
from an asynchronous point of view to be

00:01:40,799 --> 00:01:44,960
able to understand this we are going to

00:01:42,640 --> 00:01:46,079
see how the ecosystem of javascript

00:01:44,960 --> 00:01:49,360
works

00:01:46,079 --> 00:01:50,640
javascript is single threaded speaking

00:01:49,360 --> 00:01:53,040
strictly about

00:01:50,640 --> 00:01:55,200
running because maybe they have a

00:01:53,040 --> 00:01:57,920
service worker with another thread

00:01:55,200 --> 00:02:00,560
but this is purely the running of our

00:01:57,920 --> 00:02:02,640
code in our browser

00:02:00,560 --> 00:02:04,159
and this is going to be running

00:02:02,640 --> 00:02:06,880
asynchronously

00:02:04,159 --> 00:02:08,800
so we're going to go line by line seeing

00:02:06,880 --> 00:02:11,440
what we can run

00:02:08,800 --> 00:02:13,280
ignoring comments and other notes and

00:02:11,440 --> 00:02:15,680
that part is going to have to

00:02:13,280 --> 00:02:18,800
end the the entire function would have

00:02:15,680 --> 00:02:20,959
to end to continue to the next line

00:02:18,800 --> 00:02:22,000
so what we have to understand here is

00:02:20,959 --> 00:02:24,080
that it has a

00:02:22,000 --> 00:02:25,840
run to completion behavior which means

00:02:24,080 --> 00:02:28,480
that i am not going to

00:02:25,840 --> 00:02:30,239
to go on to another part of the code

00:02:28,480 --> 00:02:31,200
until i don't complete this part that

00:02:30,239 --> 00:02:33,760
i'm currently

00:02:31,200 --> 00:02:34,560
running someone who hasn't used

00:02:33,760 --> 00:02:36,480
javascript

00:02:34,560 --> 00:02:37,760
would say well if i have to complete

00:02:36,480 --> 00:02:40,080
everything then

00:02:37,760 --> 00:02:42,160
i am going to complete the screen and

00:02:40,080 --> 00:02:43,120
the user will not be able to interact

00:02:42,160 --> 00:02:45,040
with it when

00:02:43,120 --> 00:02:47,680
entering their credentials and it's not

00:02:45,040 --> 00:02:50,800
going to be a good user experience

00:02:47,680 --> 00:02:51,680
so what is going on if you really have

00:02:50,800 --> 00:02:55,040
to complete

00:02:51,680 --> 00:02:57,200
everything in only one place

00:02:55,040 --> 00:02:59,680
because as we said we will always have

00:02:57,200 --> 00:03:02,080
to wait something from a server

00:02:59,680 --> 00:03:03,120
because we are on the browser side so we

00:03:02,080 --> 00:03:06,560
need to

00:03:03,120 --> 00:03:08,720
grab all this information

00:03:06,560 --> 00:03:10,239
so we have something that it is called

00:03:08,720 --> 00:03:13,840
the callbacks act

00:03:10,239 --> 00:03:14,480
the call stack the memory variable

00:03:13,840 --> 00:03:16,319
environment

00:03:14,480 --> 00:03:18,000
and the thread of execution this is

00:03:16,319 --> 00:03:19,360
going to be reading all the lines of

00:03:18,000 --> 00:03:21,440
code that we have

00:03:19,360 --> 00:03:22,560
and the memory variable environment is

00:03:21,440 --> 00:03:24,640
how it's going to be

00:03:22,560 --> 00:03:26,400
replicated different scopes that we're

00:03:24,640 --> 00:03:29,519
going to put in our programs

00:03:26,400 --> 00:03:31,680
and the call stack is all the functions

00:03:29,519 --> 00:03:33,440
that are going to be accumulating to be

00:03:31,680 --> 00:03:36,480
able to run them

00:03:33,440 --> 00:03:38,480
besides this that is just javascript

00:03:36,480 --> 00:03:41,040
we have something else that it is the

00:03:38,480 --> 00:03:44,239
browser apis

00:03:41,040 --> 00:03:45,280
these gives us access to their timers to

00:03:44,239 --> 00:03:48,720
the document

00:03:45,280 --> 00:03:51,519
and a lot of events that we can use

00:03:48,720 --> 00:03:52,239
but they are not really javascript they

00:03:51,519 --> 00:03:55,280
are

00:03:52,239 --> 00:03:58,239
vacate sort of of a browser extension

00:03:55,280 --> 00:03:58,959
so that we can use it as if it was a

00:03:58,239 --> 00:04:02,959
native

00:03:58,959 --> 00:04:05,280
js language besides that we have the

00:04:02,959 --> 00:04:08,560
event loop

00:04:05,280 --> 00:04:11,920
so if you haven't heard what this means

00:04:08,560 --> 00:04:14,080
this is a program that is executing and

00:04:11,920 --> 00:04:16,400
it's looking at what kind of

00:04:14,080 --> 00:04:17,440
asynchronous functions are still to be

00:04:16,400 --> 00:04:20,479
executed if

00:04:17,440 --> 00:04:21,040
and only if no synchronous code has

00:04:20,479 --> 00:04:23,759
finished

00:04:21,040 --> 00:04:23,759
executing

00:04:24,880 --> 00:04:31,759
so in that way

00:04:28,000 --> 00:04:34,080
we can have a way of how

00:04:31,759 --> 00:04:35,440
to look at the code here is a small

00:04:34,080 --> 00:04:36,880
example of code

00:04:35,440 --> 00:04:39,840
in which we're going to create a

00:04:36,880 --> 00:04:42,320
function called print hello

00:04:39,840 --> 00:04:42,880
and we are going to send it to a set

00:04:42,320 --> 00:04:46,000
timer

00:04:42,880 --> 00:04:48,000
this is a facade of what

00:04:46,000 --> 00:04:49,919
i have said about the apis in the

00:04:48,000 --> 00:04:51,840
browser this is not only available in

00:04:49,919 --> 00:04:55,120
the javascript

00:04:51,840 --> 00:04:58,720
native javascript and what this api does

00:04:55,120 --> 00:05:01,919
is sending this function to a queue

00:04:58,720 --> 00:05:05,440
and this is going to run when

00:05:01,919 --> 00:05:06,320
the condition of a thousand milliseconds

00:05:05,440 --> 00:05:10,400
having elapsed

00:05:06,320 --> 00:05:13,919
is fulfilled so it's going to

00:05:10,400 --> 00:05:15,440
it's not going to be cold after

00:05:13,919 --> 00:05:17,840
a thousand milliseconds but it's going

00:05:15,440 --> 00:05:19,680
to be sent to the queue after those

00:05:17,840 --> 00:05:21,440
milliseconds so if there is no

00:05:19,680 --> 00:05:22,960
synchronous code running

00:05:21,440 --> 00:05:24,960
then it's going to be sent to the call

00:05:22,960 --> 00:05:28,080
stack to be able to run

00:05:24,960 --> 00:05:30,000
so if we read from the line 1 to line 8

00:05:28,080 --> 00:05:32,320
we can see that the only synchronous

00:05:30,000 --> 00:05:35,039
code that is not using the callback

00:05:32,320 --> 00:05:35,600
is the console log so that is going to

00:05:35,039 --> 00:05:38,639
be sent

00:05:35,600 --> 00:05:39,840
directly to the call stack and print the

00:05:38,639 --> 00:05:42,560
final hello

00:05:39,840 --> 00:05:46,560
and then after that is going to be to

00:05:42,560 --> 00:05:46,560
print the line six and line five

00:05:47,280 --> 00:05:50,400
and just to clear out what's going on

00:05:49,600 --> 00:05:54,800
this is

00:05:50,400 --> 00:05:56,639
for all dom events so when we click

00:05:54,800 --> 00:05:57,919
this synchronous event is going to be

00:05:56,639 --> 00:06:00,880
happening

00:05:57,919 --> 00:06:02,160
so every time the synchronous code is

00:06:00,880 --> 00:06:03,360
going to be happening this is going to

00:06:02,160 --> 00:06:06,319
be checked not before

00:06:03,360 --> 00:06:08,160
and not after so every timer that is not

00:06:06,319 --> 00:06:09,680
resolved immediately are going to have

00:06:08,160 --> 00:06:13,199
to wait

00:06:09,680 --> 00:06:13,199
to synchronous code to run

00:06:15,840 --> 00:06:18,880
oh i miss you a bit

00:06:18,960 --> 00:06:25,039
can you still see me yes okay

00:06:22,479 --> 00:06:26,240
and in this way this way that i'm

00:06:25,039 --> 00:06:29,680
showing you here is

00:06:26,240 --> 00:06:32,080
how exactly the scope is going to be

00:06:29,680 --> 00:06:32,960
catch so that is going to be the memory

00:06:32,080 --> 00:06:35,840
heap

00:06:32,960 --> 00:06:36,479
the hoisting which is something else you

00:06:35,840 --> 00:06:38,319
can see

00:06:36,479 --> 00:06:40,000
what the different scopes are and how

00:06:38,319 --> 00:06:42,639
the memory is going to be allocated to

00:06:40,000 --> 00:06:45,600
your program

00:06:42,639 --> 00:06:47,680
with this we're going to see the

00:06:45,600 --> 00:06:48,880
functionality of callbacks now that we

00:06:47,680 --> 00:06:51,759
have understand

00:06:48,880 --> 00:06:53,599
of the understood this the negative part

00:06:51,759 --> 00:06:56,080
is that we do not have a tracking of

00:06:53,599 --> 00:06:57,120
what is the status of that function that

00:06:56,080 --> 00:07:00,479
we sent

00:06:57,120 --> 00:07:03,039
so it's going to be this running is

00:07:00,479 --> 00:07:04,960
going to be completely from the api that

00:07:03,039 --> 00:07:08,080
we are using to run it not from

00:07:04,960 --> 00:07:09,440
our site so that gives us a problem of

00:07:08,080 --> 00:07:11,599
inversion of control

00:07:09,440 --> 00:07:13,199
so this is why we have these new things

00:07:11,599 --> 00:07:16,080
called promises

00:07:13,199 --> 00:07:16,479
i call them new but there have been here

00:07:16,080 --> 00:07:19,840
for

00:07:16,479 --> 00:07:22,880
a long time but this is the next

00:07:19,840 --> 00:07:25,199
thing after callbacks and now promises

00:07:22,880 --> 00:07:27,360
gives us from the javascript side

00:07:25,199 --> 00:07:29,360
a way to follow up the status of the

00:07:27,360 --> 00:07:32,160
function that we send

00:07:29,360 --> 00:07:33,520
either pending resolved or maybe an

00:07:32,160 --> 00:07:36,240
error

00:07:33,520 --> 00:07:39,120
and in that way we can counter attack

00:07:36,240 --> 00:07:39,120
what's going on

00:07:40,479 --> 00:07:44,000
and we are going to send the kind of

00:07:42,400 --> 00:07:47,199
callbacks but we have a cleaner

00:07:44,000 --> 00:07:49,680
way to do this because we have a conch

00:07:47,199 --> 00:07:51,840
function now that is called then and we

00:07:49,680 --> 00:07:54,080
can send an array of functions

00:07:51,840 --> 00:07:55,759
that tell us what are the possible

00:07:54,080 --> 00:07:59,039
solution of what's going to happen

00:07:55,759 --> 00:08:02,319
after that function is solved

00:07:59,039 --> 00:08:05,759
and a catch property that can

00:08:02,319 --> 00:08:08,400
let us add all the errors so this is

00:08:05,759 --> 00:08:09,199
about adding stuff is this it is not

00:08:08,400 --> 00:08:12,000
about

00:08:09,199 --> 00:08:13,759
it being run and then being sent to the

00:08:12,000 --> 00:08:14,560
to the then function but it is a

00:08:13,759 --> 00:08:17,120
reference of

00:08:14,560 --> 00:08:19,919
of what functions can we run when this

00:08:17,120 --> 00:08:22,160
had happened

00:08:19,919 --> 00:08:24,800
so to be able to understand what's going

00:08:22,160 --> 00:08:27,360
on we are going to use it with fetch

00:08:24,800 --> 00:08:29,039
this is a promise that it it's already

00:08:27,360 --> 00:08:33,919
included in the browsers

00:08:29,039 --> 00:08:36,560
and what it does is to grab an xhr

00:08:33,919 --> 00:08:37,519
to anywhere and grab the information

00:08:36,560 --> 00:08:40,320
back

00:08:37,519 --> 00:08:42,320
so this way what we do is give me this

00:08:40,320 --> 00:08:44,640
information

00:08:42,320 --> 00:08:46,880
and i will tell you what you're going to

00:08:44,640 --> 00:08:48,240
do when you are complete with a callback

00:08:46,880 --> 00:08:50,640
function

00:08:48,240 --> 00:08:55,839
either in a state of correct or in a

00:08:50,640 --> 00:08:55,839
state of error

00:08:58,080 --> 00:09:01,920
i'm just going to load the following

00:08:59,600 --> 00:09:01,920
page

00:09:04,399 --> 00:09:08,959
when we are calling a promise we are

00:09:07,279 --> 00:09:11,360
going to have the value which is going

00:09:08,959 --> 00:09:14,320
to be returned when it's fulfilled

00:09:11,360 --> 00:09:16,800
and the unfulfilled which is the array

00:09:14,320 --> 00:09:19,839
of callbacks that we

00:09:16,800 --> 00:09:22,000
we send with dot then with that promise

00:09:19,839 --> 00:09:23,120
and every time the value changes from

00:09:22,000 --> 00:09:26,000
undefined to

00:09:23,120 --> 00:09:27,200
something that array that unfulfilled

00:09:26,000 --> 00:09:30,240
array is going to be

00:09:27,200 --> 00:09:32,080
calling each one so since we only have

00:09:30,240 --> 00:09:33,519
one dot then it's going to be calling

00:09:32,080 --> 00:09:35,360
only one function

00:09:33,519 --> 00:09:36,640
so this way of handling errors is a

00:09:35,360 --> 00:09:39,200
little bit cleaner

00:09:36,640 --> 00:09:40,880
because we only have to add functions to

00:09:39,200 --> 00:09:43,920
dot catch

00:09:40,880 --> 00:09:48,000
and we don't have to do something ugly

00:09:43,920 --> 00:09:52,480
like we don't have to send the

00:09:48,000 --> 00:09:55,519
array the tree of callback hell

00:09:52,480 --> 00:09:57,519
that is just nesting the

00:09:55,519 --> 00:10:01,760
function until until there's a pyramid

00:09:57,519 --> 00:10:04,000
so we have some legibility for this part

00:10:01,760 --> 00:10:05,680
so we're going to analyze how is the

00:10:04,000 --> 00:10:07,360
execution of this part

00:10:05,680 --> 00:10:09,360
combining it with what we saw about

00:10:07,360 --> 00:10:11,600
callbacks

00:10:09,360 --> 00:10:14,959
so if we see from line one and line two

00:10:11,600 --> 00:10:14,959
we are creating a function

00:10:15,040 --> 00:10:18,079
which is going to print whatever we put

00:10:16,880 --> 00:10:20,959
there and the second

00:10:18,079 --> 00:10:22,240
is that it's always going to print hello

00:10:20,959 --> 00:10:26,480
the third line

00:10:22,240 --> 00:10:28,160
we will add a call to the timer api

00:10:26,480 --> 00:10:29,600
which is going to create that print

00:10:28,160 --> 00:10:31,600
hello directly

00:10:29,600 --> 00:10:34,160
as we know it is an asynchronous

00:10:31,600 --> 00:10:36,399
function so it's going to be sent to the

00:10:34,160 --> 00:10:39,440
queue of asynchronous things

00:10:36,399 --> 00:10:41,120
since it is indirectly fulfilled it will

00:10:39,440 --> 00:10:44,399
it will go in the queue so when there's

00:10:41,120 --> 00:10:46,160
no synchronous code it's going to run

00:10:44,399 --> 00:10:48,399
then we'll go to a function that is

00:10:46,160 --> 00:10:50,480
going to completely block the thread

00:10:48,399 --> 00:10:52,320
so it's going to be very complex it's

00:10:50,480 --> 00:10:54,399
going to make a lot of calculations

00:10:52,320 --> 00:10:55,760
it's not just synchronous it's going to

00:10:54,399 --> 00:10:59,279
be an infinite loop

00:10:55,760 --> 00:11:00,560
of maybe 8 000 recursions and it's going

00:10:59,279 --> 00:11:03,760
to block it by

00:11:00,560 --> 00:11:06,640
by five milliseconds then

00:11:03,760 --> 00:11:09,120
we are going to assign a promise to the

00:11:06,640 --> 00:11:11,600
value of feature data

00:11:09,120 --> 00:11:13,600
and as we remember we need to add a

00:11:11,600 --> 00:11:14,240
callback to this promise so that when we

00:11:13,600 --> 00:11:16,800
receive

00:11:14,240 --> 00:11:18,000
the return value it can act with that

00:11:16,800 --> 00:11:20,800
value

00:11:18,000 --> 00:11:22,640
so this is why we add this dot then

00:11:20,800 --> 00:11:25,279
print

00:11:22,640 --> 00:11:27,279
so that we when we receive that data we

00:11:25,279 --> 00:11:29,279
can print it in the console

00:11:27,279 --> 00:11:31,120
since it is an asynchronous function

00:11:29,279 --> 00:11:32,399
until it is resolved we can add it to

00:11:31,120 --> 00:11:35,839
the queue

00:11:32,399 --> 00:11:38,160
let's say that it is a stable server

00:11:35,839 --> 00:11:39,440
that is where we're going to take like a

00:11:38,160 --> 00:11:43,200
second to receive that

00:11:39,440 --> 00:11:45,760
that response after that

00:11:43,200 --> 00:11:47,839
just as we saw directly the timer with

00:11:45,760 --> 00:11:49,120
the zero we're going to be able to solve

00:11:47,839 --> 00:11:52,160
a promise with

00:11:49,120 --> 00:11:53,120
dot resolve directly and then add the

00:11:52,160 --> 00:11:56,079
handler

00:11:53,120 --> 00:11:56,560
that is going to have when it's solved

00:11:56,079 --> 00:11:58,320
we

00:11:56,560 --> 00:12:00,079
placed here that result and then the

00:11:58,320 --> 00:12:02,160
data that we're going to resolve

00:12:00,079 --> 00:12:03,839
that test value is going to be printed

00:12:02,160 --> 00:12:06,240
in our function print

00:12:03,839 --> 00:12:08,079
and since it is a synchronous is not

00:12:06,240 --> 00:12:10,240
going to go directly to the call stack

00:12:08,079 --> 00:12:12,720
but to the queue

00:12:10,240 --> 00:12:13,360
so we're going to block again the thread

00:12:12,720 --> 00:12:17,440
by

00:12:13,360 --> 00:12:20,720
five five thousand milliseconds

00:12:17,440 --> 00:12:22,320
so we are going to block that function

00:12:20,720 --> 00:12:24,160
and that function that we're going to

00:12:22,320 --> 00:12:25,440
take was going to take one second is

00:12:24,160 --> 00:12:26,880
going to be fulfilled

00:12:25,440 --> 00:12:28,399
and it's going to be sent to the queue

00:12:26,880 --> 00:12:29,839
because the condition to be added

00:12:28,399 --> 00:12:32,000
already happened

00:12:29,839 --> 00:12:34,639
and finally we had something synchronous

00:12:32,000 --> 00:12:36,240
that can be executed directly

00:12:34,639 --> 00:12:38,079
which is going to go directly to the

00:12:36,240 --> 00:12:40,240
call stack and we're going to see

00:12:38,079 --> 00:12:42,320
our console our first message which is

00:12:40,240 --> 00:12:44,800
going to be final

00:12:42,320 --> 00:12:45,519
and we're going to see this little box

00:12:44,800 --> 00:12:47,680
here

00:12:45,519 --> 00:12:50,160
which is going to be our console to see

00:12:47,680 --> 00:12:54,240
how things are going to happen

00:12:50,160 --> 00:12:55,120
and seeing things with print hello we

00:12:54,240 --> 00:12:57,680
see that

00:12:55,120 --> 00:12:59,519
print hello is printed until the end but

00:12:57,680 --> 00:13:00,800
it was the first that was added to the

00:12:59,519 --> 00:13:03,200
queue

00:13:00,800 --> 00:13:05,279
so this is a very strange behavior

00:13:03,200 --> 00:13:06,880
because we specifically told us

00:13:05,279 --> 00:13:08,320
that it was the first thing that worked

00:13:06,880 --> 00:13:10,959
on was going to be resolved

00:13:08,320 --> 00:13:12,000
but it was resolved until the end why

00:13:10,959 --> 00:13:16,240
does this happen

00:13:12,000 --> 00:13:18,320
because there are two types of cues

00:13:16,240 --> 00:13:19,279
the first queue is directly for all the

00:13:18,320 --> 00:13:21,839
promises

00:13:19,279 --> 00:13:22,399
and the second is for callbacks this let

00:13:21,839 --> 00:13:24,639
us say

00:13:22,399 --> 00:13:26,000
that all promises that we're going to

00:13:24,639 --> 00:13:27,920
solve are going to have a higher

00:13:26,000 --> 00:13:30,079
priority to all the callbacks that i'm

00:13:27,920 --> 00:13:33,519
going to have

00:13:30,079 --> 00:13:35,600
so if you remember we did the first

00:13:33,519 --> 00:13:37,279
which went through the normal queue and

00:13:35,600 --> 00:13:38,240
all the promises went to the higher

00:13:37,279 --> 00:13:42,399
priority

00:13:38,240 --> 00:13:44,160
so this is why they were printed earlier

00:13:42,399 --> 00:13:45,839
so what is going to be the development

00:13:44,160 --> 00:13:48,959
of the event loop

00:13:45,839 --> 00:13:50,800
in our javascript applications so i'm

00:13:48,959 --> 00:13:52,160
always going to try to run the main

00:13:50,800 --> 00:13:54,000
thread which is all

00:13:52,160 --> 00:13:55,600
which is always the synchronous code and

00:13:54,000 --> 00:13:57,920
the asynchronous code

00:13:55,600 --> 00:13:58,800
i'm going to send it until there is a

00:13:57,920 --> 00:14:01,360
condition that

00:13:58,800 --> 00:14:02,000
can add it to the queues and if i ended

00:14:01,360 --> 00:14:04,160
up reading

00:14:02,000 --> 00:14:05,199
all the synchronous code i'm going to

00:14:04,160 --> 00:14:07,680
check what

00:14:05,199 --> 00:14:09,839
is what is going on in the microtask

00:14:07,680 --> 00:14:11,360
queue which is the one from the promises

00:14:09,839 --> 00:14:12,480
and see if there's something that can be

00:14:11,360 --> 00:14:14,800
added

00:14:12,480 --> 00:14:15,760
if there is nothing to be added i will i

00:14:14,800 --> 00:14:18,000
will check the

00:14:15,760 --> 00:14:19,680
callback queue and if there's something

00:14:18,000 --> 00:14:20,800
there that we can add to the call stack

00:14:19,680 --> 00:14:22,800
we put it there

00:14:20,800 --> 00:14:24,240
and if those queues are empty well the

00:14:22,800 --> 00:14:27,040
program will finish

00:14:24,240 --> 00:14:30,800
that is the behavior that normally all

00:14:27,040 --> 00:14:35,199
javascript uppercase applications have

00:14:30,800 --> 00:14:38,079
with that we complete what is going on

00:14:35,199 --> 00:14:38,639
and then we will analyze how the async

00:14:38,079 --> 00:14:41,279
await

00:14:38,639 --> 00:14:42,839
was created to have better legibility

00:14:41,279 --> 00:14:45,120
between

00:14:42,839 --> 00:14:47,600
developers first we have to see

00:14:45,120 --> 00:14:50,079
what our iterators and generators for

00:14:47,600 --> 00:14:52,720
those who do not know an iterator

00:14:50,079 --> 00:14:54,560
is a new way to receive information from

00:14:52,720 --> 00:14:58,320
a data structure

00:14:54,560 --> 00:14:59,199
and instead of we going with an index

00:14:58,320 --> 00:15:02,240
and a counter

00:14:59,199 --> 00:15:04,079
going element by element grabbing all

00:15:02,240 --> 00:15:06,800
the information i will tell it

00:15:04,079 --> 00:15:08,560
give me information when i need it this

00:15:06,800 --> 00:15:10,079
give me information is going to be

00:15:08,560 --> 00:15:11,760
through a protocol that's already

00:15:10,079 --> 00:15:15,120
established

00:15:11,760 --> 00:15:18,480
this is called next and this method

00:15:15,120 --> 00:15:21,199
is going to return a value with

00:15:18,480 --> 00:15:21,920
and a completed if the completed has

00:15:21,199 --> 00:15:23,839
something

00:15:21,920 --> 00:15:25,920
then you won't be able to call anything

00:15:23,839 --> 00:15:27,920
from next and the values go always going

00:15:25,920 --> 00:15:29,839
to return what what it has

00:15:27,920 --> 00:15:33,360
and until the value is undefined

00:15:29,839 --> 00:15:33,360
completed is going to be true

00:15:35,360 --> 00:15:38,959
so this is the way in which we are going

00:15:37,839 --> 00:15:42,320
to create

00:15:38,959 --> 00:15:44,800
this iterator from scratch

00:15:42,320 --> 00:15:46,240
this is using something that is called

00:15:44,800 --> 00:15:49,040
closure

00:15:46,240 --> 00:15:50,800
if you do not know what it is this is

00:15:49,040 --> 00:15:53,839
all the functions that return

00:15:50,800 --> 00:15:55,360
other function that persist in a state

00:15:53,839 --> 00:15:57,600
that we have

00:15:55,360 --> 00:15:58,480
this is the easier way that i have found

00:15:57,600 --> 00:16:00,480
but since it

00:15:58,480 --> 00:16:02,959
is a little bit complex everyone is

00:16:00,480 --> 00:16:06,800
going to have its own definition

00:16:02,959 --> 00:16:08,959
so it can be developed further but just

00:16:06,800 --> 00:16:10,639
plainly speaking this is what i can tell

00:16:08,959 --> 00:16:13,360
you

00:16:10,639 --> 00:16:14,160
so what we are going to to persist here

00:16:13,360 --> 00:16:16,800
is the e

00:16:14,160 --> 00:16:17,920
variable which is going to increase that

00:16:16,800 --> 00:16:21,519
index that we have in our

00:16:17,920 --> 00:16:24,800
array and every time we say return

00:16:21,519 --> 00:16:25,839
x element that is what we're going to

00:16:24,800 --> 00:16:28,720
have as the next

00:16:25,839 --> 00:16:29,920
element and the next element so we're

00:16:28,720 --> 00:16:31,519
not telling it

00:16:29,920 --> 00:16:33,519
give me all those elements and apply

00:16:31,519 --> 00:16:35,199
that function it's just every time i

00:16:33,519 --> 00:16:36,079
want you will give me a piece of that

00:16:35,199 --> 00:16:38,720
data structure

00:16:36,079 --> 00:16:40,480
and then another and another and that is

00:16:38,720 --> 00:16:42,720
how we're going to try to implement

00:16:40,480 --> 00:16:45,360
these iterators

00:16:42,720 --> 00:16:46,000
normally these are built in the language

00:16:45,360 --> 00:16:48,399
like in

00:16:46,000 --> 00:16:50,079
common structures such as objects and

00:16:48,399 --> 00:16:53,839
arrays but this is how it

00:16:50,079 --> 00:16:57,040
works and generators are

00:16:53,839 --> 00:17:00,160
something else that help us to create

00:16:57,040 --> 00:17:03,040
functions that can be paused

00:17:00,160 --> 00:17:04,079
so the only thing that you can create

00:17:03,040 --> 00:17:07,439
this function is

00:17:04,079 --> 00:17:10,880
to add this asterisk

00:17:07,439 --> 00:17:14,240
and use the yield that is a

00:17:10,880 --> 00:17:17,199
word reserved for telling

00:17:14,240 --> 00:17:18,959
that you need to pause that function and

00:17:17,199 --> 00:17:21,280
return to what you are delivering and

00:17:18,959 --> 00:17:23,039
the next time you call us with next

00:17:21,280 --> 00:17:24,799
then we're going to keep on the context

00:17:23,039 --> 00:17:27,760
of execution so we're going to

00:17:24,799 --> 00:17:29,440
analyze what is going to happen when we

00:17:27,760 --> 00:17:31,919
read all this code

00:17:29,440 --> 00:17:32,720
since we have a function declaration all

00:17:31,919 --> 00:17:37,440
this code

00:17:32,720 --> 00:17:39,760
is captured to a function

00:17:37,440 --> 00:17:41,760
called createflow and to be able to call

00:17:39,760 --> 00:17:44,080
it we'll have to call that function so

00:17:41,760 --> 00:17:45,440
when we call it we'll have the iterator

00:17:44,080 --> 00:17:49,600
protocol

00:17:45,440 --> 00:17:51,600
so every time we run next

00:17:49,600 --> 00:17:53,120
we will look for the next thing that we

00:17:51,600 --> 00:17:55,600
can pause and we

00:17:53,120 --> 00:17:56,559
get out of that context of execution so

00:17:55,600 --> 00:17:59,440
when we declare

00:17:56,559 --> 00:18:00,080
return next element and we create the

00:17:59,440 --> 00:18:03,679
generator

00:18:00,080 --> 00:18:06,240
function the first way in which

00:18:03,679 --> 00:18:08,080
we can access the code of the function

00:18:06,240 --> 00:18:10,880
is calling next

00:18:08,080 --> 00:18:13,039
the following line dot next we're going

00:18:10,880 --> 00:18:15,200
to enter the context of execution of

00:18:13,039 --> 00:18:15,840
create flow and we can see that a

00:18:15,200 --> 00:18:18,640
variable

00:18:15,840 --> 00:18:19,840
called num is created called with a

00:18:18,640 --> 00:18:23,760
value 10

00:18:19,840 --> 00:18:26,080
and then a new variable new num and that

00:18:23,760 --> 00:18:27,840
there we get out of the context of

00:18:26,080 --> 00:18:30,720
execution

00:18:27,840 --> 00:18:33,039
but we deliver the num variable to the

00:18:30,720 --> 00:18:36,720
one that was using it for example

00:18:33,039 --> 00:18:39,679
the element 1 which we declared in the

00:18:36,720 --> 00:18:41,760
next to last line of the code that's

00:18:39,679 --> 00:18:43,200
going to receive the 10 that we declared

00:18:41,760 --> 00:18:45,600
in the generator

00:18:43,200 --> 00:18:47,280
so in line number three nothing is

00:18:45,600 --> 00:18:50,000
assigned because it is out of the

00:18:47,280 --> 00:18:53,200
context of execution

00:18:50,000 --> 00:18:54,400
so when we call it in the last line the

00:18:53,200 --> 00:18:58,080
dot next with an

00:18:54,400 --> 00:18:58,720
element 2 with a value 2 the new num is

00:18:58,080 --> 00:19:01,360
going to be

00:18:58,720 --> 00:19:03,760
added with a value of 2 because now it

00:19:01,360 --> 00:19:06,320
has a context of execution and now

00:19:03,760 --> 00:19:08,000
something and now the value can be added

00:19:06,320 --> 00:19:10,799
from right to left

00:19:08,000 --> 00:19:11,360
so the next time that we get out here

00:19:10,799 --> 00:19:13,679
the

00:19:11,360 --> 00:19:14,640
this yield value is going to be five

00:19:13,679 --> 00:19:16,559
plus one

00:19:14,640 --> 00:19:17,679
and it's going to be assigned to element

00:19:16,559 --> 00:19:19,679
number two this is

00:19:17,679 --> 00:19:21,120
a little bit complex if you don't

00:19:19,679 --> 00:19:23,919
understand how

00:19:21,120 --> 00:19:25,840
these kinds of functions work but it is

00:19:23,919 --> 00:19:27,760
worth that you understand

00:19:25,840 --> 00:19:29,679
when do you get out of the context of

00:19:27,760 --> 00:19:31,600
execution and when do you return to the

00:19:29,679 --> 00:19:34,160
context of execution

00:19:31,600 --> 00:19:38,480
to be able to have this new way to have

00:19:34,160 --> 00:19:41,520
possible functions

00:19:38,480 --> 00:19:44,000
so what what is this good for in a sink

00:19:41,520 --> 00:19:44,000
await

00:19:46,000 --> 00:19:49,200
this is where we can say what would

00:19:48,480 --> 00:19:52,640
happen

00:19:49,200 --> 00:19:54,320
if maybe wait until i have a response

00:19:52,640 --> 00:19:56,799
from our server

00:19:54,320 --> 00:19:58,000
and then we can continue with your

00:19:56,799 --> 00:20:01,760
function

00:19:58,000 --> 00:20:04,240
this is the concept behind async await

00:20:01,760 --> 00:20:05,200
if you look at this here we will have a

00:20:04,240 --> 00:20:08,080
function that is

00:20:05,200 --> 00:20:08,799
return next value in which we're going

00:20:08,080 --> 00:20:11,520
to call it

00:20:08,799 --> 00:20:13,520
next when we receive the information

00:20:11,520 --> 00:20:15,919
from our back end

00:20:13,520 --> 00:20:17,200
so in our generation in our generator

00:20:15,919 --> 00:20:18,960
the create flow

00:20:17,200 --> 00:20:21,360
we're going to get out of the context of

00:20:18,960 --> 00:20:22,960
execution returning the promise of the

00:20:21,360 --> 00:20:25,600
api users

00:20:22,960 --> 00:20:27,280
so to understand this a bit better we're

00:20:25,600 --> 00:20:28,159
going to go to the first declaration of

00:20:27,280 --> 00:20:31,360
the constant

00:20:28,159 --> 00:20:34,799
which is return next value in which

00:20:31,360 --> 00:20:37,600
we're going to run our generator

00:20:34,799 --> 00:20:38,960
since we're only just executing it we

00:20:37,600 --> 00:20:41,919
need

00:20:38,960 --> 00:20:44,640
it to use the function next to be able

00:20:41,919 --> 00:20:46,840
to understand

00:20:44,640 --> 00:20:48,640
the context of execution of that

00:20:46,840 --> 00:20:52,799
function

00:20:48,640 --> 00:20:52,799
and wait until it is completed

00:20:52,960 --> 00:20:56,640
so now in that second line when we

00:20:55,919 --> 00:20:59,120
create

00:20:56,640 --> 00:21:00,799
the const we're going to have the future

00:20:59,120 --> 00:21:03,760
data

00:21:00,799 --> 00:21:06,000
now we're going to call dot next that we

00:21:03,760 --> 00:21:07,679
already gives us access to the context

00:21:06,000 --> 00:21:10,799
of execution

00:21:07,679 --> 00:21:12,960
and the api users since we have

00:21:10,799 --> 00:21:14,559
an api users and we're going to return

00:21:12,960 --> 00:21:16,320
it to future data

00:21:14,559 --> 00:21:18,400
and the value of the promise is assigned

00:21:16,320 --> 00:21:20,640
to future data to be able to be

00:21:18,400 --> 00:21:22,000
to assign a callback as we saw in the

00:21:20,640 --> 00:21:24,000
promises

00:21:22,000 --> 00:21:25,440
the last line is a little bit complex

00:21:24,000 --> 00:21:26,880
because you have to understand how the

00:21:25,440 --> 00:21:30,799
generator work

00:21:26,880 --> 00:21:33,919
it has an iterator pattern in which

00:21:30,799 --> 00:21:36,000
you can return a value and the completed

00:21:33,919 --> 00:21:37,280
since we want to add a callback to that

00:21:36,000 --> 00:21:39,520
promise

00:21:37,280 --> 00:21:41,200
we will need to access through that

00:21:39,520 --> 00:21:44,080
iterator protocol

00:21:41,200 --> 00:21:45,280
by means of the adult value so what

00:21:44,080 --> 00:21:47,159
we're saying is

00:21:45,280 --> 00:21:48,799
future value for the

00:21:47,159 --> 00:21:51,280
futuredata.value.then

00:21:48,799 --> 00:21:52,720
grab the data that we have and when you

00:21:51,280 --> 00:21:54,880
receive it

00:21:52,720 --> 00:21:55,760
please continue with the function that

00:21:54,880 --> 00:21:59,360
we have and

00:21:55,760 --> 00:22:02,320
print the console.log of her generator

00:21:59,360 --> 00:22:04,559
that is the entire concept behind async

00:22:02,320 --> 00:22:06,159
await and how it works

00:22:04,559 --> 00:22:07,919
and if you look at this these eight

00:22:06,159 --> 00:22:10,320
lines that look

00:22:07,919 --> 00:22:11,200
very complex if you want to use this

00:22:10,320 --> 00:22:14,240
behavior

00:22:11,200 --> 00:22:14,799
just use a prefix to your function and

00:22:14,240 --> 00:22:18,320
just

00:22:14,799 --> 00:22:19,280
a sync and in another part of your code

00:22:18,320 --> 00:22:21,919
like it was

00:22:19,280 --> 00:22:23,120
a synchronous code you can place an

00:22:21,919 --> 00:22:25,679
await

00:22:23,120 --> 00:22:26,880
but you have to really understand that

00:22:25,679 --> 00:22:28,799
it's not going to happen

00:22:26,880 --> 00:22:30,720
as if it's going to be synchronous code

00:22:28,799 --> 00:22:33,760
it's just happening behind

00:22:30,720 --> 00:22:37,280
but we have a synchronous legibility but

00:22:33,760 --> 00:22:40,000
an asynchronous execution so

00:22:37,280 --> 00:22:41,360
here we are going to finish our little

00:22:40,000 --> 00:22:49,280
talk about how

00:22:41,360 --> 00:22:49,280

YouTube URL: https://www.youtube.com/watch?v=Mfhva_v7wtw


