Title: Deployed math - Brenda Berenice Ramos HernÃ¡ndez [English translated audio]
Publication date: 2021-02-09
Playlist: JsConf Mexico 2020  virtual edition
Description: 
	Have you ever wondered what foundation recursive functions have? This talk will explain the fundamentals to make recursion possible, based on very simple, interesting and exciting mathematical examples.
Captions: 
	00:00:04,400 --> 00:00:08,000
math

00:00:05,040 --> 00:00:08,720
in web development well basically this

00:00:08,000 --> 00:00:11,679
is the topic

00:00:08,720 --> 00:00:13,040
i'm going to touch on today and we're

00:00:11,679 --> 00:00:16,320
going to see that math

00:00:13,040 --> 00:00:18,720
is methods are everywhere particularly

00:00:16,320 --> 00:00:21,199
because we're working in a programming

00:00:18,720 --> 00:00:21,199
language

00:00:21,359 --> 00:00:25,199
but also because the most direct

00:00:23,359 --> 00:00:31,439
application is going to be

00:00:25,199 --> 00:00:34,079
here in this concept called recursion

00:00:31,439 --> 00:00:34,960
so the first thing we have to see we

00:00:34,079 --> 00:00:38,239
have to do is

00:00:34,960 --> 00:00:38,640
ask ourselves what is recursion most of

00:00:38,239 --> 00:00:40,719
us

00:00:38,640 --> 00:00:43,520
already know the concept but i'm still

00:00:40,719 --> 00:00:46,160
going to mention it

00:00:43,520 --> 00:00:46,960
and we can see this definition this

00:00:46,160 --> 00:00:50,000
definition

00:00:46,960 --> 00:00:53,520
it can be a little bit fun

00:00:50,000 --> 00:00:55,760
but it's incorrect actually later i am

00:00:53,520 --> 00:00:59,600
going to explain to you why

00:00:55,760 --> 00:01:02,879
but it is basically that recursivity

00:00:59,600 --> 00:01:07,119
cannot be infinite it has to end

00:01:02,879 --> 00:01:09,760
at some point and in this case

00:01:07,119 --> 00:01:13,360
well this doesn't happen because it

00:01:09,760 --> 00:01:16,400
repeats infinitely

00:01:13,360 --> 00:01:20,479
so what we can call recursion is

00:01:16,400 --> 00:01:20,479
functions that call themselves

00:01:21,600 --> 00:01:27,680
but how does recursion work what are the

00:01:24,720 --> 00:01:29,040
fundamentals of recursion the basis of

00:01:27,680 --> 00:01:32,320
recursion

00:01:29,040 --> 00:01:34,880
we're going to see that recursion is

00:01:32,320 --> 00:01:35,920
is a direct application of mathematical

00:01:34,880 --> 00:01:40,159
induction

00:01:35,920 --> 00:01:43,680
so why is mathematical induction it

00:01:40,159 --> 00:01:47,119
is a method a mathematical method

00:01:43,680 --> 00:01:50,640
that is used to

00:01:47,119 --> 00:01:51,200
prove whether a property is true or

00:01:50,640 --> 00:01:55,520
false

00:01:51,200 --> 00:01:58,640
for integers integer is what we know

00:01:55,520 --> 00:01:59,439
for example zero and one and move

00:01:58,640 --> 00:02:02,399
forward two

00:01:59,439 --> 00:02:02,399
three four five

00:02:04,640 --> 00:02:12,080
so to to do this

00:02:08,800 --> 00:02:16,000
mathematical induction we have two steps

00:02:12,080 --> 00:02:17,280
first the base case and in the problems

00:02:16,000 --> 00:02:20,840
we're going to find that

00:02:17,280 --> 00:02:23,280
it is an equivalence for example one or

00:02:20,840 --> 00:02:26,400
zero

00:02:23,280 --> 00:02:28,480
and the inductive step which is

00:02:26,400 --> 00:02:29,440
where we're going to prove something or

00:02:28,480 --> 00:02:33,840
we're going to

00:02:29,440 --> 00:02:33,840
do something with all other

00:02:35,519 --> 00:02:39,280
for example what was what's going on

00:02:37,599 --> 00:02:41,840
that is happening

00:02:39,280 --> 00:02:42,800
what's different from one or zero or

00:02:41,840 --> 00:02:45,760
what we're using

00:02:42,800 --> 00:02:45,760
as a base case

00:02:45,840 --> 00:02:50,120
so we're going to see an application of

00:02:48,800 --> 00:02:53,200
mathematical

00:02:50,120 --> 00:02:56,640
induction in the hello world

00:02:53,200 --> 00:02:57,519
of in of recursion so we have this hello

00:02:56,640 --> 00:03:00,720
world

00:02:57,519 --> 00:03:04,720
which is a function that solves

00:03:00,720 --> 00:03:08,200
the factorial of a number

00:03:04,720 --> 00:03:09,519
so what is a factorial it is the

00:03:08,200 --> 00:03:12,720
multiplication

00:03:09,519 --> 00:03:14,080
between one given number and all its

00:03:12,720 --> 00:03:17,519
previous numbers

00:03:14,080 --> 00:03:18,000
up until one so to apply this induction

00:03:17,519 --> 00:03:21,840
we have

00:03:18,000 --> 00:03:25,120
the base case which is n equals one

00:03:21,840 --> 00:03:27,920
and in that case when n equals one

00:03:25,120 --> 00:03:29,040
it's going to return one but in all

00:03:27,920 --> 00:03:32,159
other cases

00:03:29,040 --> 00:03:35,040
as long as the number is not one

00:03:32,159 --> 00:03:35,599
the function is going to multiply that

00:03:35,040 --> 00:03:37,599
number

00:03:35,599 --> 00:03:40,080
with the previous number so for example

00:03:37,599 --> 00:03:42,319
if n equals 5

00:03:40,080 --> 00:03:45,040
that is going to check that is different

00:03:42,319 --> 00:03:48,159
from 1 and then is going to multiply

00:03:45,040 --> 00:03:49,440
5 by 4 and at that time it's going to

00:03:48,159 --> 00:03:52,239
call the function

00:03:49,440 --> 00:03:54,080
again and that four number that we have

00:03:52,239 --> 00:03:57,040
is going to go through the function

00:03:54,080 --> 00:03:59,200
again and successively that is going to

00:03:57,040 --> 00:04:01,840
end up in the base case that is number

00:03:59,200 --> 00:04:01,840
one

00:04:02,000 --> 00:04:07,200
so here is another example

00:04:05,680 --> 00:04:10,319
it's going to be a little bit more

00:04:07,200 --> 00:04:13,439
complex where we have a string

00:04:10,319 --> 00:04:16,880
and with that string we're going to find

00:04:13,439 --> 00:04:18,639
the combinations that we can make with

00:04:16,880 --> 00:04:21,680
its character

00:04:18,639 --> 00:04:24,720
so as we can see we have an if

00:04:21,680 --> 00:04:26,320
that if that string equals an empty

00:04:24,720 --> 00:04:29,199
string

00:04:26,320 --> 00:04:30,320
that is for example the first step the

00:04:29,199 --> 00:04:34,080
first induction

00:04:30,320 --> 00:04:38,240
step in which we have a base case

00:04:34,080 --> 00:04:40,800
and if it's not empty then it's going to

00:04:38,240 --> 00:04:41,840
continue applying and it's going to

00:04:40,800 --> 00:04:46,320
continue calling

00:04:41,840 --> 00:04:47,440
itself and following these parameters

00:04:46,320 --> 00:04:50,720
that we are

00:04:47,440 --> 00:04:54,000
giving to the function so here we

00:04:50,720 --> 00:04:57,199
are giving the first case

00:04:54,000 --> 00:05:00,080
for example an empty string or just

00:04:57,199 --> 00:05:01,360
an empty space and then a string with

00:05:00,080 --> 00:05:02,960
characters

00:05:01,360 --> 00:05:05,600
so we're going to see that we are going

00:05:02,960 --> 00:05:09,600
to obtain all these characters

00:05:05,600 --> 00:05:13,600
that are here in here below in a comment

00:05:09,600 --> 00:05:16,479
when we apply this inductive definition

00:05:13,600 --> 00:05:18,320
so how we can see here that we have

00:05:16,479 --> 00:05:22,400
plenty of methods

00:05:18,320 --> 00:05:25,520
for example substring and charat

00:05:22,400 --> 00:05:30,080
the one who uses ordered pairs

00:05:25,520 --> 00:05:34,000
and the other uses like subsets

00:05:30,080 --> 00:05:34,000
so these are all mathematical concepts

00:05:34,160 --> 00:05:40,160
and just this little review of recursion

00:05:37,759 --> 00:05:41,280
it is usually mentioned in this type of

00:05:40,160 --> 00:05:44,400
topics

00:05:41,280 --> 00:05:49,039
that the advantages

00:05:44,400 --> 00:05:53,840
that it has using recursion

00:05:49,039 --> 00:05:53,840
so we can see that mainly it is about

00:05:54,479 --> 00:06:02,080
recursion uses a lot of resources

00:05:58,240 --> 00:06:05,520
such as time execution and memory spaces

00:06:02,080 --> 00:06:08,800
so those are the first disadvantages but

00:06:05,520 --> 00:06:12,400
recursions also has one advantage

00:06:08,800 --> 00:06:13,600
that is for example that is a pure

00:06:12,400 --> 00:06:16,880
function

00:06:13,600 --> 00:06:17,360
in the sense that it does not alter any

00:06:16,880 --> 00:06:21,280
other

00:06:17,360 --> 00:06:24,080
part of the program but we can

00:06:21,280 --> 00:06:25,360
just say that it is a relationship

00:06:24,080 --> 00:06:28,240
between the parameters

00:06:25,360 --> 00:06:29,039
and the return values so this is very

00:06:28,240 --> 00:06:33,280
convenient

00:06:29,039 --> 00:06:33,280
when we're working the paradigm

00:06:33,440 --> 00:06:37,840
of functional programming because that

00:06:36,240 --> 00:06:42,000
is exactly what we need that

00:06:37,840 --> 00:06:46,319
our values are not mutable

00:06:42,000 --> 00:06:46,319
and this does happen in iteration

00:06:47,360 --> 00:06:52,639
and as part of this review i would like

00:06:50,160 --> 00:06:56,240
to mention as well in which cases

00:06:52,639 --> 00:06:58,880
recursion is more convenient to use

00:06:56,240 --> 00:07:01,199
and it is mainly in problems that are

00:06:58,880 --> 00:07:06,000
naturally recursive

00:07:01,199 --> 00:07:06,000
we can see that we have here an array

00:07:07,680 --> 00:07:13,599
this array has nested arrays so we see

00:07:10,880 --> 00:07:16,639
that recursion is present

00:07:13,599 --> 00:07:19,199
because we have to well what we want to

00:07:16,639 --> 00:07:19,919
do and what we want to obtain here is an

00:07:19,199 --> 00:07:22,400
a flat

00:07:19,919 --> 00:07:22,400
array

00:07:23,120 --> 00:07:29,520
so this nested arrays can be flattened

00:07:27,759 --> 00:07:32,240
and this would be an example of

00:07:29,520 --> 00:07:32,240
recursion

00:07:32,560 --> 00:07:36,880
another case in which we can use

00:07:34,560 --> 00:07:40,080
recursion is when the data

00:07:36,880 --> 00:07:43,360
is naturally recursive

00:07:40,080 --> 00:07:45,599
in this case we have paths

00:07:43,360 --> 00:07:47,120
we can see that when we have a folder

00:07:45,599 --> 00:07:50,000
within a folder

00:07:47,120 --> 00:07:52,639
in that case recursion is very very

00:07:50,000 --> 00:07:52,639
efficient

00:07:53,840 --> 00:07:59,840
after this review what we can see

00:07:57,199 --> 00:08:00,879
is that programming languages such as

00:07:59,840 --> 00:08:05,039
javascript

00:08:00,879 --> 00:08:05,039
are based in logic and mathematics

00:08:06,879 --> 00:08:12,160
and the question really that we need to

00:08:09,919 --> 00:08:16,000
ask ourselves is

00:08:12,160 --> 00:08:19,199
do we need to know math to program

00:08:16,000 --> 00:08:20,319
and the answer is obvious for some for

00:08:19,199 --> 00:08:23,520
many that work

00:08:20,319 --> 00:08:25,199
in web development and that is well not

00:08:23,520 --> 00:08:28,800
necessarily

00:08:25,199 --> 00:08:31,840
but knowing the fundamentals of how

00:08:28,800 --> 00:08:34,880
these methods work or what we use

00:08:31,840 --> 00:08:37,279
works day-to-day as programmers

00:08:34,880 --> 00:08:39,680
can lead us to solve problems that look

00:08:37,279 --> 00:08:42,800
difficult

00:08:39,680 --> 00:08:45,360
and solve them in a very simple way

00:08:42,800 --> 00:08:47,680
we can see this for example when we have

00:08:45,360 --> 00:08:49,839
problems

00:08:47,680 --> 00:08:50,880
that maybe we just get them out of the

00:08:49,839 --> 00:08:55,839
internet or

00:08:50,880 --> 00:08:55,839
we just develop them ourselves

00:08:56,640 --> 00:09:00,320
and they lead us to a long

00:08:58,710 --> 00:09:03,680
[Music]

00:09:00,320 --> 00:09:06,560
code to just get to the solution

00:09:03,680 --> 00:09:07,519
but sometimes these solutions just lead

00:09:06,560 --> 00:09:11,279
us to

00:09:07,519 --> 00:09:11,279
errors or problems

00:09:11,440 --> 00:09:15,760
that we can solve in any other way

00:09:17,040 --> 00:09:22,399
so the problem that i that i showed

00:09:20,240 --> 00:09:23,839
previously in which we wanted to flatten

00:09:22,399 --> 00:09:27,040
an array

00:09:23,839 --> 00:09:29,680
can be solved with a flat method but

00:09:27,040 --> 00:09:33,040
many times we do not know we really do

00:09:29,680 --> 00:09:36,320
not have in our memory all our methods

00:09:33,040 --> 00:09:39,760
so it is not enough with googling and

00:09:36,320 --> 00:09:40,399
finding a solution but what we really

00:09:39,760 --> 00:09:42,560
need to do

00:09:40,399 --> 00:09:44,320
is knowing what we're doing or what are

00:09:42,560 --> 00:09:46,720
we trying to achieve and

00:09:44,320 --> 00:09:48,080
how are we going to do it to get to a

00:09:46,720 --> 00:09:51,519
solution

00:09:48,080 --> 00:09:54,560
and with that i'm not saying that study

00:09:51,519 --> 00:09:59,040
a career in maths or engineering

00:09:54,560 --> 00:10:02,000
just simply if you want

00:09:59,040 --> 00:10:02,959
to go deep in these subjects you will be

00:10:02,000 --> 00:10:05,600
able to

00:10:02,959 --> 00:10:07,120
achieve better solutions and they're

00:10:05,600 --> 00:10:10,880
going to be useful to you

00:10:07,120 --> 00:10:14,480
in all aspects of web development

00:10:10,880 --> 00:10:16,560
so thank you very much for all who are

00:10:14,480 --> 00:10:17,120
curious and who want to know more about

00:10:16,560 --> 00:10:20,160
this and

00:10:17,120 --> 00:10:22,160
want to solve functions solve problems

00:10:20,160 --> 00:10:23,200
and want to understand this topic about

00:10:22,160 --> 00:10:26,079
recursion

00:10:23,200 --> 00:10:26,880
i would leave you some links here and i

00:10:26,079 --> 00:10:30,640
will leave you

00:10:26,880 --> 00:10:33,680
some a series of videos which is about

00:10:30,640 --> 00:10:36,720
maths for programmers which

00:10:33,680 --> 00:10:40,079
uses ordered pairs to solve problems

00:10:36,720 --> 00:10:43,279
and other concepts such as sets

00:10:40,079 --> 00:10:44,320
that can be very useful so i hope you

00:10:43,279 --> 00:10:47,839
have liked this

00:10:44,320 --> 00:10:47,839

YouTube URL: https://www.youtube.com/watch?v=YSzLi5vllx0


