Title: How Node.js Bootstraps Itself: 2019 Edition - Joyee Cheung, Igalia
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	How Node.js Bootstraps Itself: 2019 Edition - Joyee Cheung, Igalia
Speakers: Joyee Cheung
In this talk we are going to take a deep dive into the Node.js bootstrap process. We will cover the recent effort of bootstrap refactoring and V8 snapshot integration in Node.js core that have significantly improved the startup performance, and will also look into new approaches of Node.js application distribution that can be enabled by this effort.
Captions: 
	00:00:00,030 --> 00:00:06,839
excuse me sir I'm joy thank you for

00:00:03,600 --> 00:00:10,050
coming in this talk we are going to take

00:00:06,839 --> 00:00:12,000
a look at something that I've been doing

00:00:10,050 --> 00:00:17,340
a lot of great factorial which is the

00:00:12,000 --> 00:00:18,270
bootstrap oh no Gordon so allow me to

00:00:17,340 --> 00:00:21,029
introduce myself

00:00:18,270 --> 00:00:23,970
I'm Joey I work on the competitors team

00:00:21,029 --> 00:00:26,789
agalya I in on denote technicals during

00:00:23,970 --> 00:00:28,680
the midday and I'm via committee so in

00:00:26,789 --> 00:00:31,170
the past year I've been working on the

00:00:28,680 --> 00:00:34,079
startup performance initiative note

00:00:31,170 --> 00:00:36,809
which involves a lot of work related to

00:00:34,079 --> 00:00:40,800
the bootstrap or milk or you can find me

00:00:36,809 --> 00:00:43,219
on Twitter by the Hindu Deutsch um so

00:00:40,800 --> 00:00:48,600
enough about me let's talk about them

00:00:43,219 --> 00:00:51,480
okay so this is the process model of

00:00:48,600 --> 00:00:54,510
node and also the goal of the bootstrap

00:00:51,480 --> 00:00:57,960
process so in a new process you usually

00:00:54,510 --> 00:01:00,899
have one main node instance running on

00:00:57,960 --> 00:01:04,229
the main thread which includes an

00:01:00,899 --> 00:01:07,710
inspector agent I'll be a context a be a

00:01:04,229 --> 00:01:10,110
isolate le pavillon dope and a node

00:01:07,710 --> 00:01:12,420
environment so don't worry about all

00:01:10,110 --> 00:01:15,240
those lingos if you're not familiar with

00:01:12,420 --> 00:01:17,939
them well get them later there is also a

00:01:15,240 --> 00:01:20,310
sick user one watchdog thread for

00:01:17,939 --> 00:01:22,799
handling the signal that you're saying

00:01:20,310 --> 00:01:26,070
to know to make the inspector start

00:01:22,799 --> 00:01:29,189
listening on the port there also one

00:01:26,070 --> 00:01:33,240
prep pole for v8 and is test schedule

00:01:29,189 --> 00:01:37,799
fed and one purple for Livi to serve a

00:01:33,240 --> 00:01:40,140
synchronous file system operations so

00:01:37,799 --> 00:01:42,540
starting from the temp you can spawn

00:01:40,140 --> 00:01:46,619
worker instances in addition to the

00:01:42,540 --> 00:01:50,009
minions in one node process and this is

00:01:46,619 --> 00:01:53,189
what spawning worker looks like we

00:01:50,009 --> 00:01:56,280
basically just create a new thread when

00:01:53,189 --> 00:02:01,200
the worker instance inside and share all

00:01:56,280 --> 00:02:04,320
of the threads in process so compared to

00:02:01,200 --> 00:02:07,380
that spawning a child process is more

00:02:04,320 --> 00:02:09,680
extensive because we need to set up more

00:02:07,380 --> 00:02:09,680
stuff

00:02:09,880 --> 00:02:16,360
so here is an overview of the new

00:02:13,330 --> 00:02:20,620
bootstrap bootstrap process we'll talk

00:02:16,360 --> 00:02:23,260
about these steps one by one so first we

00:02:20,620 --> 00:02:26,830
need to do a few setups that should only

00:02:23,260 --> 00:02:29,530
be done once per process this includes

00:02:26,830 --> 00:02:31,390
setting up the signal handlers parsing

00:02:29,530 --> 00:02:35,530
the command line arguments from strings

00:02:31,390 --> 00:02:37,990
to most structures and initializing the

00:02:35,530 --> 00:02:40,180
dependencies such as ICU for

00:02:37,990 --> 00:02:43,900
internationalization support and open

00:02:40,180 --> 00:02:46,780
SSL for Krypton then we'll need to

00:02:43,900 --> 00:02:49,750
initialize the v8 platform which

00:02:46,780 --> 00:02:52,240
includes at a scheduled and thread pool

00:02:49,750 --> 00:02:57,430
that we can use to compile JavaScript or

00:02:52,240 --> 00:03:01,060
run garbage fraction and when

00:02:57,430 --> 00:03:03,640
initializing the main instance first we

00:03:01,060 --> 00:03:06,130
initialize the live event loop on the

00:03:03,640 --> 00:03:07,690
main thread but we only add handles to

00:03:06,130 --> 00:03:10,210
it later when we initialize the

00:03:07,690 --> 00:03:12,490
environment so the main instance simply

00:03:10,210 --> 00:03:18,400
use the default libuv

00:03:12,490 --> 00:03:20,700
event loop and after the process and one

00:03:18,400 --> 00:03:23,530
default event loop has been initialized

00:03:20,700 --> 00:03:25,540
next we'll move on to setup the VA

00:03:23,530 --> 00:03:29,500
isolate for the main instance

00:03:25,540 --> 00:03:30,370
so the isolates are instances of the v8

00:03:29,500 --> 00:03:33,760
JavaScript engine

00:03:30,370 --> 00:03:36,780
it encapsulates for example and Jasmine

00:03:33,760 --> 00:03:42,370
heap a micro task queue for the promises

00:03:36,780 --> 00:03:45,220
and pending exceptions and so on so to

00:03:42,370 --> 00:03:47,320
set up the way isolate we will first

00:03:45,220 --> 00:03:49,930
configure the resource constraints

00:03:47,320 --> 00:03:52,840
including how much memory this way

00:03:49,930 --> 00:03:57,010
engine instance can use we'll also

00:03:52,840 --> 00:03:59,650
create an array buffer a locator that is

00:03:57,010 --> 00:04:01,890
in charge of allocating external memory

00:03:59,650 --> 00:04:05,410
for preference and other typed arrays

00:04:01,890 --> 00:04:07,390
mva will deserialized isolate from a

00:04:05,410 --> 00:04:10,540
nice little snapshot will cover

00:04:07,390 --> 00:04:12,790
snapshots later then we'll set up

00:04:10,540 --> 00:04:15,250
several price like compacts in C purpose

00:04:12,790 --> 00:04:17,200
but most of them are not ready to be

00:04:15,250 --> 00:04:19,540
called at this point because they will

00:04:17,200 --> 00:04:22,540
have to work with JavaScript callbacks

00:04:19,540 --> 00:04:24,550
initialize nature so this

00:04:22,540 --> 00:04:28,450
dude the garbage collection callbacks

00:04:24,550 --> 00:04:33,550
uncaught exception the listeners promise

00:04:28,450 --> 00:04:37,480
rejection callbacks etc and after the

00:04:33,550 --> 00:04:41,440
vai slit is initialized no Dan starts to

00:04:37,480 --> 00:04:44,740
initialize the via context so a VN

00:04:41,440 --> 00:04:46,830
context is a sandbox execution context

00:04:44,740 --> 00:04:50,730
that encapsulate starts with buildings

00:04:46,830 --> 00:04:55,300
aka Prime models including gobo des

00:04:50,730 --> 00:04:59,290
array object and others so when you call

00:04:55,300 --> 00:05:03,940
VA VM that tray context from the year's

00:04:59,290 --> 00:05:06,250
low end later after the node has been

00:05:03,940 --> 00:05:09,190
promised trapped this is what the return

00:05:06,250 --> 00:05:12,370
result includes its new contacts with a

00:05:09,190 --> 00:05:15,850
different set of buildings so when user

00:05:12,370 --> 00:05:18,580
creates the end contacts some from

00:05:15,850 --> 00:05:20,980
nature after the bootstrap we only add

00:05:18,580 --> 00:05:26,500
one more context to the instance without

00:05:20,980 --> 00:05:29,830
doing any further setups so what does no

00:05:26,500 --> 00:05:32,950
dude initialize this context it creates

00:05:29,830 --> 00:05:37,180
an immutable copy for the my primordius

00:05:32,950 --> 00:05:39,670
so that internals can use them and won't

00:05:37,180 --> 00:05:41,130
be affected when your students monkey

00:05:39,670 --> 00:05:44,890
patch these buildings

00:05:41,130 --> 00:05:48,520
he also initializes the Jung exception

00:05:44,890 --> 00:05:51,490
for web guys to use its some of funny

00:05:48,520 --> 00:05:54,940
that note has done exceptions when there

00:05:51,490 --> 00:06:01,930
is no done but this is done to be expect

00:05:54,940 --> 00:06:05,830
Wyant so each node instance has a main

00:06:01,930 --> 00:06:08,680
context where most of the JavaScript is

00:06:05,830 --> 00:06:12,550
executed in but it can also contain

00:06:08,680 --> 00:06:14,940
contacts created with via module the

00:06:12,550 --> 00:06:18,850
main contest contains a pointer to is

00:06:14,940 --> 00:06:20,920
associated node environment this will be

00:06:18,850 --> 00:06:24,700
assigned later when the environment is

00:06:20,920 --> 00:06:27,250
created in context on the other hand do

00:06:24,700 --> 00:06:30,180
not have this pointer and they are not

00:06:27,250 --> 00:06:33,669
abstract further beyond this point

00:06:30,180 --> 00:06:34,650
so contacts can be this realized from

00:06:33,669 --> 00:06:38,230
the

00:06:34,650 --> 00:06:40,180
startups nashit know that this is

00:06:38,230 --> 00:06:43,300
different from the heap snapshots that

00:06:40,180 --> 00:06:46,300
you use for a memory debugging before we

00:06:43,300 --> 00:06:49,960
integrated the startups nasha into node

00:06:46,300 --> 00:06:51,700
we had to run a few contacts per

00:06:49,960 --> 00:06:54,460
contacts scripts in order to initialize

00:06:51,700 --> 00:06:59,230
these Prem Mario's and the darling

00:06:54,460 --> 00:07:02,320
exception and now we run the scripts a

00:06:59,230 --> 00:07:07,620
real time and serialize the context

00:07:02,320 --> 00:07:10,210
after initializing has been done and we

00:07:07,620 --> 00:07:12,310
sterilize the contact is into a blob

00:07:10,210 --> 00:07:16,360
that gets embedded into the node

00:07:12,310 --> 00:07:19,540
executable then at one time instead of

00:07:16,360 --> 00:07:21,730
educating these scripts we directly dis

00:07:19,540 --> 00:07:25,690
realize the result of the previous

00:07:21,730 --> 00:07:30,280
execution into one context which spins

00:07:25,690 --> 00:07:33,340
up bootstrap after the no-contact is

00:07:30,280 --> 00:07:37,210
initialized we'll move on to initialize

00:07:33,340 --> 00:07:40,330
the entire node environment so in no

00:07:37,210 --> 00:07:44,050
environment encapsulate a known instance

00:07:40,330 --> 00:07:48,340
it is associated with one VA inspector

00:07:44,050 --> 00:07:52,390
agent one mainly a context one VI slit

00:07:48,340 --> 00:07:55,750
and one Liberty envelop to initialize

00:07:52,390 --> 00:07:57,610
the environment we first initialize the

00:07:55,750 --> 00:08:02,050
components that are independent of

00:07:57,610 --> 00:08:04,480
runtime States so this includes the

00:08:02,050 --> 00:08:07,690
internal Java module and sigmaz minding

00:08:04,480 --> 00:08:11,440
loaders the process object and other

00:08:07,690 --> 00:08:14,410
gobos and Java callbacks that super of

00:08:11,440 --> 00:08:17,560
us hooks invoke which will be in charge

00:08:14,410 --> 00:08:20,800
of invoking user-provided compacts later

00:08:17,560 --> 00:08:23,860
so these objects and functions when used

00:08:20,800 --> 00:08:26,830
by the users may depend on other states

00:08:23,860 --> 00:08:29,350
but the creation of them is runtime

00:08:26,830 --> 00:08:34,240
independent and that's why we're doing

00:08:29,350 --> 00:08:36,910
this at this point so to bootstrap

00:08:34,240 --> 00:08:39,610
itself with JavaScript no needs to

00:08:36,910 --> 00:08:41,650
create an internal loader system to load

00:08:39,610 --> 00:08:45,070
throws bindings and internal trotsky

00:08:41,650 --> 00:08:45,970
modules the windings are looked up for

00:08:45,070 --> 00:08:49,240
an old link

00:08:45,970 --> 00:08:51,730
with linear search while the native

00:08:49,240 --> 00:08:54,850
JavaScript modules provided through the

00:08:51,730 --> 00:09:00,370
internal version of require are looked

00:08:54,850 --> 00:09:04,509
up from the map so no recently

00:09:00,370 --> 00:09:07,360
integrated vehicle cache to speed up the

00:09:04,509 --> 00:09:09,490
compilation of internal Java modules so

00:09:07,360 --> 00:09:12,430
before the integration we needed to

00:09:09,490 --> 00:09:15,160
parse and compile the source code of

00:09:12,430 --> 00:09:17,490
these modules at runtime before

00:09:15,160 --> 00:09:20,769
executing them to create native modules

00:09:17,490 --> 00:09:23,829
now we compile them at Build time and

00:09:20,769 --> 00:09:26,709
this realize the compilation data which

00:09:23,829 --> 00:09:28,990
is embedded into the insecure table at

00:09:26,709 --> 00:09:32,709
runtime we can directly deserialize the

00:09:28,990 --> 00:09:34,779
population data and execute the just

00:09:32,709 --> 00:09:38,889
code to create these internal modules

00:09:34,779 --> 00:09:42,790
this speeds up the book strap about 40

00:09:38,889 --> 00:09:44,560
to 60% since parsing and combination

00:09:42,790 --> 00:09:49,480
used to take up a lot of time during

00:09:44,560 --> 00:09:52,230
bootstrap after we have an internal

00:09:49,480 --> 00:09:54,939
loader system setup note can start

00:09:52,230 --> 00:09:57,250
initializing the bubbles which are

00:09:54,939 --> 00:10:00,180
implemented in internal jaskate with

00:09:57,250 --> 00:10:03,459
access to internal suppose findings

00:10:00,180 --> 00:10:07,050
discovers doubles are then attached to

00:10:03,459 --> 00:10:10,750
the global object or the process object

00:10:07,050 --> 00:10:13,509
node the global object is now legacy

00:10:10,750 --> 00:10:20,079
alias to the echo script stage for

00:10:13,509 --> 00:10:22,899
global this project object so this is a

00:10:20,079 --> 00:10:26,230
very simplified version of the code

00:10:22,899 --> 00:10:28,899
executed to set up the Global's we

00:10:26,230 --> 00:10:32,589
usually used internal require to load

00:10:28,899 --> 00:10:36,399
and the information of something

00:10:32,589 --> 00:10:39,130
internal run some setups to get a

00:10:36,399 --> 00:10:42,519
JavaScript function or object and assign

00:10:39,130 --> 00:10:46,839
them to either the process object or the

00:10:42,519 --> 00:10:48,819
global object already in the Bobo's we

00:10:46,839 --> 00:10:51,399
also need to initialize several hooks

00:10:48,819 --> 00:10:54,579
when setting up the environment this

00:10:51,399 --> 00:10:57,970
includes for example process next stick

00:10:54,579 --> 00:10:58,600
which need to invoke queued callbacks

00:10:57,970 --> 00:11:02,350
where

00:10:58,600 --> 00:11:04,470
a sink operations are done so during

00:11:02,350 --> 00:11:07,930
bootstrap we need to create the tick you

00:11:04,470 --> 00:11:10,030
and the tick callback and store the

00:11:07,930 --> 00:11:12,910
tickle back in the environment so that

00:11:10,030 --> 00:11:15,640
it can be caught later we initializing

00:11:12,910 --> 00:11:19,000
the run time independent states no ticks

00:11:15,640 --> 00:11:21,190
should be added to the Takeo we are just

00:11:19,000 --> 00:11:25,810
initializing the machinery to process

00:11:21,190 --> 00:11:28,810
the TQ and after the run time

00:11:25,810 --> 00:11:32,820
independent components are initialized

00:11:28,810 --> 00:11:36,250
we didn't want to setup the event loop

00:11:32,820 --> 00:11:39,010
at this point we need to initialize a

00:11:36,250 --> 00:11:41,650
few handles some are activated

00:11:39,010 --> 00:11:44,380
immediately some are activated on the

00:11:41,650 --> 00:11:47,350
man later and we only initialize a fixed

00:11:44,380 --> 00:11:49,960
number of handles durable strap more

00:11:47,350 --> 00:11:55,180
hair dos specifically the ones for i/o

00:11:49,960 --> 00:11:58,000
are added on demand on demand later so

00:11:55,180 --> 00:12:00,850
the live event event loop has many

00:11:58,000 --> 00:12:05,760
different phases in each iteration and

00:12:00,850 --> 00:12:09,400
this is what roughly what it looks like

00:12:05,760 --> 00:12:12,960
so a bootstrap will initialize one timer

00:12:09,400 --> 00:12:17,380
handle for second while and set interval

00:12:12,960 --> 00:12:20,410
one idle handle for immediate one

00:12:17,380 --> 00:12:25,360
prepare handle for idle for idle

00:12:20,410 --> 00:12:27,040
notification for - - prop and one check

00:12:25,360 --> 00:12:29,920
handle for touch the probe and another

00:12:27,040 --> 00:12:34,170
for us emitter to pair with other

00:12:29,920 --> 00:12:37,570
handles to work so after the van loop is

00:12:34,170 --> 00:12:40,930
fully initialized we then initialize the

00:12:37,570 --> 00:12:43,720
VA inspector which is used for

00:12:40,930 --> 00:12:47,590
JavaScript debugging this includes

00:12:43,720 --> 00:12:49,900
initializing the inspector agent which

00:12:47,590 --> 00:12:56,110
is done even when the inspector is not

00:12:49,900 --> 00:12:59,020
active ok and will spawn a secure one

00:12:56,110 --> 00:13:02,050
watchdog thread that wakes up and asked

00:12:59,020 --> 00:13:05,110
Ming thread to start listening on expect

00:13:02,050 --> 00:13:07,870
report when user sends us accuse someone

00:13:05,110 --> 00:13:08,740
to the process this is only done for the

00:13:07,870 --> 00:13:13,390
main node

00:13:08,740 --> 00:13:17,430
instances and not down for workers so if

00:13:13,390 --> 00:13:22,000
the user passes for example - inspect

00:13:17,430 --> 00:13:23,890
break - to be proof or - - improv when

00:13:22,000 --> 00:13:26,110
launching the instance will also

00:13:23,890 --> 00:13:28,840
immediately create more threats for

00:13:26,110 --> 00:13:33,580
either listening on the inspect port or

00:13:28,840 --> 00:13:35,530
for profiling after the inspector is

00:13:33,580 --> 00:13:37,690
initialized we then continue

00:13:35,530 --> 00:13:42,640
initializing components that depends on

00:13:37,690 --> 00:13:46,090
runtime States at this point we'll need

00:13:42,640 --> 00:13:48,210
to handle various runtime configurations

00:13:46,090 --> 00:13:51,910
including command line flags and

00:13:48,210 --> 00:13:54,850
environment variables this phase is also

00:13:51,910 --> 00:13:58,450
called pre execution for example this is

00:13:54,850 --> 00:14:01,450
what the initialization of - there's no

00:13:58,450 --> 00:14:05,980
warnings look like if the user asked no

00:14:01,450 --> 00:14:07,990
not to write warnings - STD error we

00:14:05,980 --> 00:14:09,910
don't invest all the warning listener

00:14:07,990 --> 00:14:12,970
that does this if the user does not

00:14:09,910 --> 00:14:16,800
configure no to stop doing this

00:14:12,970 --> 00:14:19,860
will install the Meixner other than

00:14:16,800 --> 00:14:22,630
initializations other english license

00:14:19,860 --> 00:14:26,710
initialization is done during the pre

00:14:22,630 --> 00:14:29,200
execution phase include setting up IPC

00:14:26,710 --> 00:14:32,110
channels for clusters and child

00:14:29,200 --> 00:14:35,140
processes initializing the userland

00:14:32,110 --> 00:14:38,890
module loaders including both the CJS

00:14:35,140 --> 00:14:41,920
modular and ESM orders so only after

00:14:38,890 --> 00:14:45,940
this point any useful and module can be

00:14:41,920 --> 00:14:48,550
executed and will right after that will

00:14:45,940 --> 00:14:54,970
also load any preloaded module specified

00:14:48,550 --> 00:14:57,880
with test - required after the pre

00:14:54,970 --> 00:15:01,530
execution is done the node environment

00:14:57,880 --> 00:15:05,140
is ready and we can start the execution

00:15:01,530 --> 00:15:07,630
so at this point we'll choose a main

00:15:05,140 --> 00:15:11,310
script according to the command line

00:15:07,630 --> 00:15:14,880
flags and run it to start the execution

00:15:11,310 --> 00:15:17,710
these scripts are all located under lib

00:15:14,880 --> 00:15:21,910
internal main in the node path tree and

00:15:17,710 --> 00:15:25,240
compiled into the binary at Build time

00:15:21,910 --> 00:15:27,760
so for example if the user passes a foul

00:15:25,240 --> 00:15:31,570
name to note from the command line s

00:15:27,760 --> 00:15:34,720
entry point will load a Ming script that

00:15:31,570 --> 00:15:40,890
detects the type of entry point and load

00:15:34,720 --> 00:15:43,630
it with either the CJ s or ESM order if

00:15:40,890 --> 00:15:46,210
the instant launched is a worker

00:15:43,630 --> 00:15:48,760
instance will load a different Ming

00:15:46,210 --> 00:15:51,820
script that set up various listeners on

00:15:48,760 --> 00:15:54,430
the message port and start listening so

00:15:51,820 --> 00:15:57,010
when the worker thread receives the

00:15:54,430 --> 00:16:01,450
scripts from the port it will compile it

00:15:57,010 --> 00:16:04,060
and start execution from there and after

00:16:01,450 --> 00:16:06,310
the main script is run will kick off the

00:16:04,060 --> 00:16:09,250
event loop and run it until nothing

00:16:06,310 --> 00:16:11,800
keeps it open the lip UV thread pool

00:16:09,250 --> 00:16:16,630
will be created if any asynchronous

00:16:11,800 --> 00:16:19,390
first assistant operation is used so a

00:16:16,630 --> 00:16:22,630
quick summary of what we covered in this

00:16:19,390 --> 00:16:26,650
talk to initialize a know process from

00:16:22,630 --> 00:16:29,950
scratch we first run per process setups

00:16:26,650 --> 00:16:32,800
and then setup a VI slit via contacts

00:16:29,950 --> 00:16:34,990
and the new environment the majority of

00:16:32,800 --> 00:16:37,510
the work is done in the environment

00:16:34,990 --> 00:16:40,690
setup which includes initializing the

00:16:37,510 --> 00:16:44,110
runtime independent States develop the

00:16:40,690 --> 00:16:47,410
in v8 inspector and handling runtime

00:16:44,110 --> 00:16:49,780
dependant configurations then select and

00:16:47,410 --> 00:16:54,310
a secure the main script and start in

00:16:49,780 --> 00:16:58,270
the loop ok so as mentioned earlier

00:16:54,310 --> 00:17:01,180
we're now have integrated the V a start

00:16:58,270 --> 00:17:03,490
up snapshot into node but at the moment

00:17:01,180 --> 00:17:05,230
the snapshot we have only includes the

00:17:03,490 --> 00:17:06,520
contact setups we're currently working

00:17:05,230 --> 00:17:09,699
on including

00:17:06,520 --> 00:17:11,620
the run time independent part of the

00:17:09,699 --> 00:17:13,990
environment bootstrap into the step a

00:17:11,620 --> 00:17:17,380
start up snapshot to speed up the

00:17:13,990 --> 00:17:19,600
bootstrap further so this is currently

00:17:17,380 --> 00:17:22,329
the focus of the startup performance

00:17:19,600 --> 00:17:25,470
initiative you can check out the link if

00:17:22,329 --> 00:17:28,950
you want to know more thank you

00:17:25,470 --> 00:17:28,950

YouTube URL: https://www.youtube.com/watch?v=8_DKruxE_08


