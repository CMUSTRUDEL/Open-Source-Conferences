Title: Introduction to libuv: What's a Unicorn Velociraptor? - Colin Ihrig, Joyent
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	Introduction to libuv: What's a Unicorn Velociraptor? - Colin Ihrig, Joyent
Speakers: Colin Ihrig
libuv is what gives Node.js its event loop and cross-platform asynchronous I/O capabilities. This talk explains what libuv is all about, and how it's used by Node.js. This talk also looks at recent development efforts in the libuv project.
Captions: 
	00:00:00,030 --> 00:00:05,670
all right so it's 9:00 a.m. I'll go

00:00:03,449 --> 00:00:07,550
ahead and get started good morning

00:00:05,670 --> 00:00:10,080
everyone thank you for coming to my talk

00:00:07,550 --> 00:00:11,880
I just want to let you know ahead of

00:00:10,080 --> 00:00:13,590
time that the projector is having some

00:00:11,880 --> 00:00:17,520
issues yesterday and today so if it cuts

00:00:13,590 --> 00:00:20,699
out it's not my fault so the title of my

00:00:17,520 --> 00:00:24,000
talk is Libby V what's a unicorn

00:00:20,699 --> 00:00:26,640
Velociraptor so if you were to enter

00:00:24,000 --> 00:00:30,869
that into Google you would see some

00:00:26,640 --> 00:00:33,480
results similar to this so the the

00:00:30,869 --> 00:00:37,559
picture in the top left is the actual

00:00:33,480 --> 00:00:39,120
libuv logo and then things just kind of

00:00:37,559 --> 00:00:42,510
go off the rails from there a little bit

00:00:39,120 --> 00:00:44,700
we have a dinosaur riding a unicorn for

00:00:42,510 --> 00:00:46,950
some reason the Chicago Bears football

00:00:44,700 --> 00:00:50,719
player is on a dinosaur

00:00:46,950 --> 00:00:53,699
um but yeah so what I'm talking about is

00:00:50,719 --> 00:00:57,719
libuv the platform of abstraction

00:00:53,699 --> 00:01:01,289
library that nodejs sits on top of libuv

00:00:57,719 --> 00:01:04,979
is written in C it's not C++ it's

00:01:01,289 --> 00:01:09,270
actually I believe C 89 so it runs you

00:01:04,979 --> 00:01:12,570
know in most places the the point of the

00:01:09,270 --> 00:01:14,880
library is to do asynchronous i/o so

00:01:12,570 --> 00:01:17,520
it's gonna be what gives libuv or I'm

00:01:14,880 --> 00:01:19,979
sorry gives node it's you know

00:01:17,520 --> 00:01:24,770
asynchronous i/o operations event loop

00:01:19,979 --> 00:01:35,119
and things of that nature up here we go

00:01:24,770 --> 00:01:35,119
my fault that's right

00:01:43,910 --> 00:02:00,150
I'm glad I warned you guys ahead of time

00:01:46,560 --> 00:02:03,300
about that all right so Libby V is used

00:02:00,150 --> 00:02:05,550
by node obviously but it actually has a

00:02:03,300 --> 00:02:09,540
number of other really big consumers so

00:02:05,550 --> 00:02:12,810
a language called Julia knee ovum see

00:02:09,540 --> 00:02:14,970
make a bunch of others at the bottom of

00:02:12,810 --> 00:02:17,820
the screen here you will see cartoon

00:02:14,970 --> 00:02:20,250
head that is foul he is another one of

00:02:17,820 --> 00:02:24,630
the Libby V collaborators that's his his

00:02:20,250 --> 00:02:26,160
github icon and he he'd said this really

00:02:24,630 --> 00:02:28,080
nice quote to me one time and I wanted

00:02:26,160 --> 00:02:30,210
to you know attribute it correctly not

00:02:28,080 --> 00:02:32,430
not take credit for the quote myself but

00:02:30,210 --> 00:02:35,130
it basically is we write the if def so

00:02:32,430 --> 00:02:38,400
you don't have to so if you look inside

00:02:35,130 --> 00:02:40,890
the nodejs C++ code base there there is

00:02:38,400 --> 00:02:43,080
some branching some if deaths based on

00:02:40,890 --> 00:02:44,700
what platform you're executing on but

00:02:43,080 --> 00:02:47,250
it's really not that bad

00:02:44,700 --> 00:02:48,480
if you then dive down into the Libby V

00:02:47,250 --> 00:02:51,260
source code it's a whole nother story

00:02:48,480 --> 00:02:53,459
there are if deaths all over the place

00:02:51,260 --> 00:02:55,350
there are actually two different source

00:02:53,459 --> 00:02:56,940
trees one for Windows and then one for

00:02:55,350 --> 00:02:58,680
everything else so there's there's a lot

00:02:56,940 --> 00:03:01,950
of branching logic there that that kind

00:02:58,680 --> 00:03:05,820
of gives a nice consistent API to people

00:03:01,950 --> 00:03:08,940
who want to build on top of Libby V and

00:03:05,820 --> 00:03:11,820
as I said it is a cross-platform C

00:03:08,940 --> 00:03:14,250
library so we we support a large number

00:03:11,820 --> 00:03:17,120
of operating systems some more than

00:03:14,250 --> 00:03:21,180
others so we have a three tiered support

00:03:17,120 --> 00:03:25,080
system so Tier one is kind of you know

00:03:21,180 --> 00:03:26,910
we we test this in the CI anything that

00:03:25,080 --> 00:03:28,680
you know might cause a regression on any

00:03:26,910 --> 00:03:31,620
of those platforms is gonna block

00:03:28,680 --> 00:03:34,080
something from landing and then tier two

00:03:31,620 --> 00:03:36,060
is it's it's considered officially

00:03:34,080 --> 00:03:38,820
supported it might not necessarily be

00:03:36,060 --> 00:03:40,800
tested in the CI and we'll we'll try to

00:03:38,820 --> 00:03:44,160
the best of our abilities to you know

00:03:40,800 --> 00:03:46,260
make sure that it never breaks I'm not

00:03:44,160 --> 00:03:48,120
really sure why we have the distinction

00:03:46,260 --> 00:03:50,190
between Tier one and tier two because I

00:03:48,120 --> 00:03:53,190
do believe that all the things in tier

00:03:50,190 --> 00:03:54,780
two are currently tested in the CI and

00:03:53,190 --> 00:03:57,000
then tier three is going to be community

00:03:54,780 --> 00:03:59,790
maintained platforms so that's going to

00:03:57,000 --> 00:04:01,170
be Android IBM I although I think

00:03:59,790 --> 00:04:03,359
they're currently in the process of

00:04:01,170 --> 00:04:05,940
trying to add some you know a higher

00:04:03,359 --> 00:04:06,900
tier support right now and then just

00:04:05,940 --> 00:04:10,319
some other you know

00:04:06,900 --> 00:04:12,150
different random platforms a lot of

00:04:10,319 --> 00:04:13,769
times people will show up with platforms

00:04:12,150 --> 00:04:15,330
that I've never even heard of and you

00:04:13,769 --> 00:04:17,340
know they'll start trying to add if

00:04:15,330 --> 00:04:17,669
deaths into the code and see how it

00:04:17,340 --> 00:04:19,739
works

00:04:17,669 --> 00:04:21,989
so you know as long as it's not too

00:04:19,739 --> 00:04:23,669
intrusive into the codebase we're

00:04:21,989 --> 00:04:25,229
usually ok with that

00:04:23,669 --> 00:04:26,430
but we can't really make any promises

00:04:25,229 --> 00:04:28,740
that it won't break because we're not

00:04:26,430 --> 00:04:31,020
testing it anywhere so if you you know

00:04:28,740 --> 00:04:32,490
if there's a platform you care about and

00:04:31,020 --> 00:04:33,840
you want to see it in there you are kind

00:04:32,490 --> 00:04:38,400
of on the hook to make sure things don't

00:04:33,840 --> 00:04:41,370
break so some of the features that come

00:04:38,400 --> 00:04:45,240
from libuv the event loop obviously is a

00:04:41,370 --> 00:04:47,010
really big one in node TCP sockets so in

00:04:45,240 --> 00:04:51,510
node that basically translates to the

00:04:47,010 --> 00:04:53,760
net module we have DNS resolution so in

00:04:51,510 --> 00:04:55,860
the DNS module a lot of some of the

00:04:53,760 --> 00:04:57,690
system calls are from a library called

00:04:55,860 --> 00:05:00,389
si Aires that I'll talk about on the

00:04:57,690 --> 00:05:03,270
neck and a couple slides but libuv also

00:05:00,389 --> 00:05:04,979
implements some stuff there UDP sockets

00:05:03,270 --> 00:05:07,889
is going to be basically nodes D Gramm

00:05:04,979 --> 00:05:10,020
module file watching and file system

00:05:07,889 --> 00:05:11,490
operations so just about everything in

00:05:10,020 --> 00:05:15,510
the FS module is going to go through

00:05:11,490 --> 00:05:17,039
libuv child processes and threads you

00:05:15,510 --> 00:05:19,050
know obviously that translates to the

00:05:17,039 --> 00:05:20,520
child process module and worker threads

00:05:19,050 --> 00:05:23,130
and then we have other things like

00:05:20,520 --> 00:05:25,349
synchronization primitives mutexes and

00:05:23,130 --> 00:05:27,870
things like that and then we offer a

00:05:25,349 --> 00:05:30,120
high resolution clock so if you know

00:05:27,870 --> 00:05:32,340
date.now is just not accurate enough for

00:05:30,120 --> 00:05:34,410
you you can use inside of node process

00:05:32,340 --> 00:05:39,780
HR time to get a little more high

00:05:34,410 --> 00:05:41,849
resolution timing and I want to talk a

00:05:39,780 --> 00:05:43,260
little bit about the high-level

00:05:41,849 --> 00:05:45,720
architecture of Libby Vee

00:05:43,260 --> 00:05:48,330
so I like to think of this as broken up

00:05:45,720 --> 00:05:50,280
into two rows so basically the top row

00:05:48,330 --> 00:05:52,530
which has the network i/o all the way

00:05:50,280 --> 00:05:55,949
across to like file i/o DNS and user

00:05:52,530 --> 00:05:58,919
code that's more of the public facing

00:05:55,949 --> 00:06:01,500
API what users of libuv are going to

00:05:58,919 --> 00:06:03,599
consume and then the bottom row with

00:06:01,500 --> 00:06:06,180
like the iocp and thread pool and things

00:06:03,599 --> 00:06:08,070
like that that's more of the guts of

00:06:06,180 --> 00:06:10,139
Libby Vee you can actually get pretty

00:06:08,070 --> 00:06:14,460
far using Libby v without having to

00:06:10,139 --> 00:06:15,870
interact with any of that stuff one of

00:06:14,460 --> 00:06:19,289
the things that's interesting on the

00:06:15,870 --> 00:06:20,639
bottom row is you know IRC p is that is

00:06:19,289 --> 00:06:23,969
basically how

00:06:20,639 --> 00:06:26,969
we do Iowa polling on Windows but we

00:06:23,969 --> 00:06:30,180
also have things like Ipoh KQ event

00:06:26,969 --> 00:06:33,090
ports so Libby V will basically pick the

00:06:30,180 --> 00:06:34,680
best I guess primitives for what

00:06:33,090 --> 00:06:37,979
operating system you're running on

00:06:34,680 --> 00:06:40,620
so KQ will be used on bsds and the Mac a

00:06:37,979 --> 00:06:46,860
poll is used on Linux and then event

00:06:40,620 --> 00:06:49,349
ports are solaris so in order to really

00:06:46,860 --> 00:06:50,909
use libuv effectively there's a couple

00:06:49,349 --> 00:06:52,259
of things you have to understand a few

00:06:50,909 --> 00:06:55,110
like concepts

00:06:52,259 --> 00:06:57,090
the first one is handles so these are an

00:06:55,110 --> 00:06:59,340
abstraction for what's typically a

00:06:57,090 --> 00:07:02,039
long-lived resource so this might be

00:06:59,340 --> 00:07:05,400
something like a socket or a child

00:07:02,039 --> 00:07:07,529
process TTY is if you're dealing with

00:07:05,400 --> 00:07:10,680
your terminal timers and things like

00:07:07,529 --> 00:07:12,150
that we also have a couple of different

00:07:10,680 --> 00:07:14,129
types of handles that are used for

00:07:12,150 --> 00:07:17,099
interacting with the event loop so

00:07:14,129 --> 00:07:19,710
something called an idle handle which is

00:07:17,099 --> 00:07:21,360
actually poorly named because it runs on

00:07:19,710 --> 00:07:22,770
every iteration of the event loop so

00:07:21,360 --> 00:07:25,560
there's not really anything that's idle

00:07:22,770 --> 00:07:28,229
about it and then prepare and check

00:07:25,560 --> 00:07:31,069
handles which run before and after you

00:07:28,229 --> 00:07:34,050
do before Lybia UV does its IO polling

00:07:31,069 --> 00:07:36,120
and then async handles which can you

00:07:34,050 --> 00:07:37,919
know do things like be used to wake up

00:07:36,120 --> 00:07:41,339
the event loop if it's sleeping and

00:07:37,919 --> 00:07:44,339
things like that and then handles have a

00:07:41,339 --> 00:07:45,899
concept of being active so if a handle

00:07:44,339 --> 00:07:49,110
is active it'll actually keep the event

00:07:45,899 --> 00:07:50,819
loop alive so for example in node

00:07:49,110 --> 00:07:52,529
whenever you start a server if you just

00:07:50,819 --> 00:07:53,069
you know you call server dot start and

00:07:52,529 --> 00:07:55,169
nothing else

00:07:53,069 --> 00:07:56,759
you'll notice that node doesn't exit

00:07:55,169 --> 00:07:59,039
that's because the event loop sees that

00:07:56,759 --> 00:08:01,740
there's at least one active handle alive

00:07:59,039 --> 00:08:04,620
and remaining and keep the event loop

00:08:01,740 --> 00:08:07,770
open and then there's also an operation

00:08:04,620 --> 00:08:10,529
called unwrapping and then the inverse

00:08:07,770 --> 00:08:12,659
of that is reffering so when a handle is

00:08:10,529 --> 00:08:15,149
created it's in a state of being

00:08:12,659 --> 00:08:16,770
referenced and that is what will help

00:08:15,149 --> 00:08:20,219
you keep the event loop alive but if you

00:08:16,770 --> 00:08:21,750
unwrap that then the the event loop no

00:08:20,219 --> 00:08:24,509
longer considers that as something that

00:08:21,750 --> 00:08:26,310
will keep your application open so these

00:08:24,509 --> 00:08:27,689
are actually exposed inside of nodes so

00:08:26,310 --> 00:08:29,039
if you've done a lot of node programming

00:08:27,689 --> 00:08:30,910
you there's a chance you've seen dot

00:08:29,039 --> 00:08:32,290
unrest

00:08:30,910 --> 00:08:37,270
and that's basically what it translates

00:08:32,290 --> 00:08:38,830
to you down in Libby V so in addition to

00:08:37,270 --> 00:08:42,580
handles we also have something called

00:08:38,830 --> 00:08:45,910
requests I like to think of handles as

00:08:42,580 --> 00:08:48,670
more of an object whereas a request is

00:08:45,910 --> 00:08:50,350
more of a function or a method I say

00:08:48,670 --> 00:08:52,240
function or method because sometimes

00:08:50,350 --> 00:08:53,320
they are involved with a handle and

00:08:52,240 --> 00:08:55,960
sometimes they're kind of their own

00:08:53,320 --> 00:08:59,290
standalone thing these are typically

00:08:55,960 --> 00:09:01,690
shorter-lived operations so things that

00:08:59,290 --> 00:09:04,450
happen when you're doing file i/o if

00:09:01,690 --> 00:09:06,340
you're doing dns lookups or if the user

00:09:04,450 --> 00:09:07,630
passes in their own custom work that

00:09:06,340 --> 00:09:09,850
they want to execute in the thread pool

00:09:07,630 --> 00:09:11,500
then that's going to be more of a

00:09:09,850 --> 00:09:15,070
request type of operation instead of a

00:09:11,500 --> 00:09:18,520
handle but like handles they can also

00:09:15,070 --> 00:09:20,530
keep the event loop alive so for example

00:09:18,520 --> 00:09:24,790
if you you know start a node and you do

00:09:20,530 --> 00:09:26,800
FS dot read file its nodes not going to

00:09:24,790 --> 00:09:28,120
terminate until that read operation is

00:09:26,800 --> 00:09:31,390
complete if that's the only thing that's

00:09:28,120 --> 00:09:32,650
happening if if the if the request

00:09:31,390 --> 00:09:34,780
wasn't something that could keep the

00:09:32,650 --> 00:09:36,250
event loop open you would call FS read

00:09:34,780 --> 00:09:38,920
file and then the program would just

00:09:36,250 --> 00:09:41,410
exit immediately so if you're ever

00:09:38,920 --> 00:09:43,090
curious why it is that node doesn't exit

00:09:41,410 --> 00:09:47,100
in some cases it's usually because

00:09:43,090 --> 00:09:47,100
there's a request or a handle somewhere

00:09:47,550 --> 00:09:51,730
and then one of the more I guess famous

00:09:50,140 --> 00:09:54,610
things that we get out of Libby v is the

00:09:51,730 --> 00:09:56,320
thread pool so the whole point there is

00:09:54,610 --> 00:09:59,620
to move computations off of the main

00:09:56,320 --> 00:10:01,210
thread javascript as a language with the

00:09:59,620 --> 00:10:04,870
exception of workers which are

00:10:01,210 --> 00:10:06,610
relatively new is single threaded so you

00:10:04,870 --> 00:10:08,350
know in a server application you

00:10:06,610 --> 00:10:09,730
probably are gonna have a lot of things

00:10:08,350 --> 00:10:11,170
going on at the same time you could have

00:10:09,730 --> 00:10:13,710
you know hundreds or thousands of

00:10:11,170 --> 00:10:16,900
requests being processed simultaneously

00:10:13,710 --> 00:10:18,370
and if everything ran on just the one

00:10:16,900 --> 00:10:21,160
main thread things would slow down

00:10:18,370 --> 00:10:23,530
pretty quickly so we use the thread pool

00:10:21,160 --> 00:10:26,350
to offset some work on to you know

00:10:23,530 --> 00:10:28,480
worker threads one common misconception

00:10:26,350 --> 00:10:32,620
is that everything runs in the thread

00:10:28,480 --> 00:10:35,520
pool that's wrong only file i/o DNS

00:10:32,620 --> 00:10:38,370
lookups so get address info and get an

00:10:35,520 --> 00:10:40,590
info and then custom work that a user

00:10:38,370 --> 00:10:42,390
might actually off put into the thread

00:10:40,590 --> 00:10:45,900
pool those are the only things that

00:10:42,390 --> 00:10:48,390
actually run on a thread pool and by

00:10:45,900 --> 00:10:49,980
default there are four worker threads in

00:10:48,390 --> 00:10:51,390
the thread pool but you can actually

00:10:49,980 --> 00:10:53,670
control that with an environment

00:10:51,390 --> 00:10:56,670
variable called UV underscore thread

00:10:53,670 --> 00:10:58,440
pool size so if you pass that to that's

00:10:56,670 --> 00:11:00,390
propagated up through node two so if you

00:10:58,440 --> 00:11:03,840
start node with UV thread pool size

00:11:00,390 --> 00:11:07,530
equals you know 124 that's how many

00:11:03,840 --> 00:11:08,880
threads you'll spawn unless you actually

00:11:07,530 --> 00:11:11,490
need to do this you should probably be

00:11:08,880 --> 00:11:13,080
careful because more threads are not

00:11:11,490 --> 00:11:14,550
always better if you don't have enough

00:11:13,080 --> 00:11:15,810
hardware to keep up with all the threads

00:11:14,550 --> 00:11:17,580
they can actually compete with one

00:11:15,810 --> 00:11:19,290
another and all the context switching in

00:11:17,580 --> 00:11:24,870
between them can actually slow your

00:11:19,290 --> 00:11:26,880
application down so this this picture is

00:11:24,870 --> 00:11:29,400
taken directly from the Lib Eevee

00:11:26,880 --> 00:11:32,970
documentation it basically explains how

00:11:29,400 --> 00:11:35,190
the event loop works so every tick

00:11:32,970 --> 00:11:37,050
through the event loop we calculate the

00:11:35,190 --> 00:11:39,810
loop times so we have some reference for

00:11:37,050 --> 00:11:41,520
what time it is and this is kind of an

00:11:39,810 --> 00:11:43,440
expensive operation so we cache it at

00:11:41,520 --> 00:11:45,720
the beginning and then we're gonna check

00:11:43,440 --> 00:11:47,160
is the loop alive or not and by is the

00:11:45,720 --> 00:11:49,530
loop alive I mean are there active

00:11:47,160 --> 00:11:51,690
handles and requests that are

00:11:49,530 --> 00:11:53,970
outstanding if there are none then the

00:11:51,690 --> 00:11:55,320
event loop can exit and then you know in

00:11:53,970 --> 00:11:58,710
a node that will propagate to the

00:11:55,320 --> 00:12:00,000
process exiting but if there is still

00:11:58,710 --> 00:12:02,160
work to be done there's a number of

00:12:00,000 --> 00:12:03,780
steps that Libby V goes through so first

00:12:02,160 --> 00:12:06,000
it'll look and see if there are any

00:12:03,780 --> 00:12:07,830
timers that are due so you know if

00:12:06,000 --> 00:12:11,280
you've called set timeout or any of

00:12:07,830 --> 00:12:13,410
those like ready to to be processed from

00:12:11,280 --> 00:12:14,880
there it goes on to pending callbacks so

00:12:13,410 --> 00:12:18,360
these are gonna be your you know in

00:12:14,880 --> 00:12:20,040
nodejs callbacks it pretty much we

00:12:18,360 --> 00:12:22,110
passed the functions down to libel UV as

00:12:20,040 --> 00:12:25,200
well so are there any callbacks that are

00:12:22,110 --> 00:12:27,120
ready to run next it'll look for it'll

00:12:25,200 --> 00:12:28,620
process idle handles these are the

00:12:27,120 --> 00:12:31,020
things that I said before had kind of a

00:12:28,620 --> 00:12:33,420
bad name because they get processed

00:12:31,020 --> 00:12:34,830
every time through the event loop and

00:12:33,420 --> 00:12:38,130
then we do something called prepare

00:12:34,830 --> 00:12:40,890
handles so this is basically we're about

00:12:38,130 --> 00:12:42,750
to go into a polling for i/o prepare

00:12:40,890 --> 00:12:43,890
handles and give you kind of a hook into

00:12:42,750 --> 00:12:44,440
the event loop if you want to do

00:12:43,890 --> 00:12:47,380
anything

00:12:44,440 --> 00:12:49,960
for polling for i/o so then we move into

00:12:47,380 --> 00:12:51,490
the actual IO polling and then when we

00:12:49,960 --> 00:12:53,290
come out of that we have check handles

00:12:51,490 --> 00:12:56,140
so that's kind of the inverse of the

00:12:53,290 --> 00:12:57,280
prepare handle so these that it gives

00:12:56,140 --> 00:13:01,180
you a good way to hook into your event

00:12:57,280 --> 00:13:03,340
loop then finally any close callbacks

00:13:01,180 --> 00:13:04,920
that are outstanding we execute and then

00:13:03,340 --> 00:13:07,300
we loop all the way back up to the top

00:13:04,920 --> 00:13:09,700
compute the time again and basically

00:13:07,300 --> 00:13:12,180
start from scratch and that is that's

00:13:09,700 --> 00:13:14,260
basically one tick of the event loop

00:13:12,180 --> 00:13:16,120
this is all that I'm really going to

00:13:14,260 --> 00:13:17,980
cover on the event loop but if you're

00:13:16,120 --> 00:13:20,860
interested in more about it I would

00:13:17,980 --> 00:13:24,250
recommend Bert belters talk from 2016

00:13:20,860 --> 00:13:26,020
Note interactive it is you know a few

00:13:24,250 --> 00:13:27,370
years old now but the the structure of

00:13:26,020 --> 00:13:33,490
the event loop hasn't changed - the

00:13:27,370 --> 00:13:35,290
information there is still relevant so

00:13:33,490 --> 00:13:37,180
next I want to talk a little bit about

00:13:35,290 --> 00:13:40,930
how libuv works now I want to talk about

00:13:37,180 --> 00:13:42,970
how it fits into - no js' so at the very

00:13:40,930 --> 00:13:44,740
top of this diagram in yellow I have

00:13:42,970 --> 00:13:47,290
that's gonna be your applications

00:13:44,740 --> 00:13:50,020
JavaScript code and then it's gonna call

00:13:47,290 --> 00:13:53,380
down into nodes standard libraries so

00:13:50,020 --> 00:13:56,350
you know the FS module DNS child process

00:13:53,380 --> 00:13:58,750
all those and that's gonna be the the

00:13:56,350 --> 00:14:00,910
second layer of yellow there from there

00:13:58,750 --> 00:14:03,820
it's gonna call down into the purple

00:14:00,910 --> 00:14:05,860
layer C++ that's the binding layer it's

00:14:03,820 --> 00:14:08,320
really ugly code to kind of interface

00:14:05,860 --> 00:14:09,960
between you know JavaScript and v8 and

00:14:08,320 --> 00:14:13,150
libuv

00:14:09,960 --> 00:14:15,190
and then the binding layer I kind of

00:14:13,150 --> 00:14:17,740
listed some of the major libraries that

00:14:15,190 --> 00:14:20,200
are part of node here I put libuv on the

00:14:17,740 --> 00:14:21,790
left by itself because it is you know

00:14:20,200 --> 00:14:23,680
what we're talking about here but in

00:14:21,790 --> 00:14:27,670
reality I would say v8 is the biggest

00:14:23,680 --> 00:14:28,630
dependency and then probably libuv but

00:14:27,670 --> 00:14:34,240
you can see some of the other

00:14:28,630 --> 00:14:37,420
dependencies here so see Aries is a DNS

00:14:34,240 --> 00:14:39,900
resolver so you can actually the node

00:14:37,420 --> 00:14:42,160
has two different ways to do DNS lookups

00:14:39,900 --> 00:14:43,810
there is the way that goes through see

00:14:42,160 --> 00:14:47,220
aries which is always going to make a

00:14:43,810 --> 00:14:49,080
network request and then there is the

00:14:47,220 --> 00:14:52,680
the one that Libby ewv implements which

00:14:49,080 --> 00:14:54,540
is going to be DNS lookup and node that

00:14:52,680 --> 00:14:56,010
actually uses the system resolver so

00:14:54,540 --> 00:14:58,590
it's going to use the same lookup

00:14:56,010 --> 00:14:59,880
mechanism as like ping and any other you

00:14:58,590 --> 00:15:03,630
know applications you might be running

00:14:59,880 --> 00:15:07,200
on your computer one thing to note about

00:15:03,630 --> 00:15:09,300
that is until I don't know about a year

00:15:07,200 --> 00:15:11,550
ago it was actually possible that if you

00:15:09,300 --> 00:15:14,460
issued a bunch of DNS lookup requests

00:15:11,550 --> 00:15:15,660
that it would you know go down into the

00:15:14,460 --> 00:15:18,390
thread pool and so if you're doing like

00:15:15,660 --> 00:15:20,130
five six seven eight DNS lookups it

00:15:18,390 --> 00:15:21,360
could actually block other things in

00:15:20,130 --> 00:15:23,670
your application that we're using the

00:15:21,360 --> 00:15:25,410
thread pool from running so people would

00:15:23,670 --> 00:15:27,810
issue a bunch of DNS requests and then

00:15:25,410 --> 00:15:29,610
start doing file i/o and they wouldn't

00:15:27,810 --> 00:15:30,540
understand why their file i/o wasn't

00:15:29,610 --> 00:15:31,950
working

00:15:30,540 --> 00:15:34,860
it's because the threads were tied up

00:15:31,950 --> 00:15:36,780
with DNS lookups so that's where it'd be

00:15:34,860 --> 00:15:38,910
a good use case to use Ciara's because

00:15:36,780 --> 00:15:41,160
see Ares doesn't go through the thread

00:15:38,910 --> 00:15:41,400
pool but either way that's no longer the

00:15:41,160 --> 00:15:44,670
case

00:15:41,400 --> 00:15:45,960
so we've now inside of Libya V started

00:15:44,670 --> 00:15:48,120
to distinguish between different types

00:15:45,960 --> 00:15:49,320
of thread pool operations to make sure

00:15:48,120 --> 00:15:52,650
that they don't step on each other's

00:15:49,320 --> 00:15:54,300
feed too much and then finally at the

00:15:52,650 --> 00:15:56,700
bottom is just the operating system

00:15:54,300 --> 00:15:58,350
Libbie v calls out to that but you know

00:15:56,700 --> 00:16:03,690
for the purposes of this talk it's not

00:15:58,350 --> 00:16:06,240
really important to think about so on

00:16:03,690 --> 00:16:08,790
this slide Sowell is back to talk about

00:16:06,240 --> 00:16:10,950
the onion architecture where basically

00:16:08,790 --> 00:16:14,750
the more layers that you peel away the

00:16:10,950 --> 00:16:16,890
more you cry and the reason for this is

00:16:14,750 --> 00:16:19,080
inside of node you might have used

00:16:16,890 --> 00:16:21,000
something like net socket which has a

00:16:19,080 --> 00:16:24,230
nice JavaScript API it's built with

00:16:21,000 --> 00:16:27,420
streams and is just fairly easy to use

00:16:24,230 --> 00:16:29,160
but if you look in if you look closer at

00:16:27,420 --> 00:16:31,890
the source code it references something

00:16:29,160 --> 00:16:33,780
called a tcp wrap which is in purple so

00:16:31,890 --> 00:16:37,860
it's one of those nasty binding layer

00:16:33,780 --> 00:16:40,710
objects so this is written in C++ it's a

00:16:37,860 --> 00:16:43,050
lot less nice to work with and then that

00:16:40,710 --> 00:16:47,760
actually wraps something called a UV TCP

00:16:43,050 --> 00:16:50,520
T which is a libuv type written in C for

00:16:47,760 --> 00:16:52,200
interacting with sockets and then inside

00:16:50,520 --> 00:16:55,110
of libel UV we actually wrapped that

00:16:52,200 --> 00:16:57,420
inside of an OS specific Handler or a

00:16:55,110 --> 00:16:59,820
specific handle so you know windows

00:16:57,420 --> 00:17:01,880
socket or UNIX socket things of that

00:16:59,820 --> 00:17:01,880
nature

00:17:03,720 --> 00:17:08,550
I want to talk a little bit about how we

00:17:05,220 --> 00:17:11,490
test this thing so we had issues in the

00:17:08,550 --> 00:17:15,540
past where you know we would run we

00:17:11,490 --> 00:17:17,069
would create a release of libuv and you

00:17:15,540 --> 00:17:18,630
know all the test suite would pass and

00:17:17,069 --> 00:17:20,429
then we would go to update node and then

00:17:18,630 --> 00:17:24,660
all of a sudden you know things would

00:17:20,429 --> 00:17:27,870
break inside of node libuv has close to

00:17:24,660 --> 00:17:30,720
400 tests but they're written in C C is

00:17:27,870 --> 00:17:32,250
kind of a pain to to deal with I mean I

00:17:30,720 --> 00:17:35,960
think we're mostly JavaScript developers

00:17:32,250 --> 00:17:38,309
in this room so it's it's tedious and

00:17:35,960 --> 00:17:41,820
like I said we had issues where for

00:17:38,309 --> 00:17:42,420
example Libby v1 19 came out everything

00:17:41,820 --> 00:17:45,360
was fine

00:17:42,420 --> 00:17:47,700
went to upgrade node and the CI you know

00:17:45,360 --> 00:17:49,860
came back red so we didn't actually land

00:17:47,700 --> 00:17:51,720
that but unfortunately there are people

00:17:49,860 --> 00:17:54,720
in the community who as soon as a new

00:17:51,720 --> 00:17:56,400
libuv release comes out they build with

00:17:54,720 --> 00:17:57,660
that version the you know they compile

00:17:56,400 --> 00:18:00,300
node with that version of libuv

00:17:57,660 --> 00:18:02,460
themselves so even though we hadn't

00:18:00,300 --> 00:18:04,740
strictly broken node we did break some

00:18:02,460 --> 00:18:09,059
users who were you know a little more

00:18:04,740 --> 00:18:11,820
brave and so we very quickly reverted

00:18:09,059 --> 00:18:13,440
and got a new version released and you

00:18:11,820 --> 00:18:15,000
know life was good again but it was it

00:18:13,440 --> 00:18:17,100
was an issue that happened more than

00:18:15,000 --> 00:18:21,660
once and it was kind of frustrating to

00:18:17,100 --> 00:18:23,190
deal with so we kind of thought about it

00:18:21,660 --> 00:18:25,530
for a little bit and we're trying to

00:18:23,190 --> 00:18:27,330
figure out a good way to to make sure

00:18:25,530 --> 00:18:31,410
you know that node was gonna be fine

00:18:27,330 --> 00:18:33,929
before we actually made a live even so

00:18:31,410 --> 00:18:36,020
the the build node.js build working

00:18:33,929 --> 00:18:39,390
group stepped up big time for us there

00:18:36,020 --> 00:18:41,820
they actually created a new CI job where

00:18:39,390 --> 00:18:44,100
before we create a live UV release we

00:18:41,820 --> 00:18:46,820
actually take whatever is the latest in

00:18:44,100 --> 00:18:49,200
node and whatever is the latest in libuv

00:18:46,820 --> 00:18:51,750
compile them together and then run nodes

00:18:49,200 --> 00:18:55,470
test suite and see what happens

00:18:51,750 --> 00:18:57,809
so node has you know over 2,800 tests

00:18:55,470 --> 00:19:01,200
there it's easy to write tests in node

00:18:57,809 --> 00:19:03,000
because they're JavaScript and ever

00:19:01,200 --> 00:19:05,580
since we kind of took this approach we

00:19:03,000 --> 00:19:07,350
haven't had any issues where you know

00:19:05,580 --> 00:19:08,940
there there have been bugs but we

00:19:07,350 --> 00:19:11,190
haven't had any of those known

00:19:08,940 --> 00:19:12,940
regressions that caused us to do cycles

00:19:11,190 --> 00:19:16,800
of multiple releases so

00:19:12,940 --> 00:19:16,800
that's been a nice process improvement

00:19:17,790 --> 00:19:23,350
so now I want to actually trace through

00:19:21,190 --> 00:19:25,570
thread pool operations so all the way

00:19:23,350 --> 00:19:28,330
from user land JavaScript code all the

00:19:25,570 --> 00:19:30,130
way down to the thread pool so in this

00:19:28,330 --> 00:19:33,190
case we're just gonna do a copy file

00:19:30,130 --> 00:19:35,590
operation so we're gonna use FS copy

00:19:33,190 --> 00:19:37,420
file there's three different variations

00:19:35,590 --> 00:19:40,240
of that so there's the synchronous

00:19:37,420 --> 00:19:43,090
version the promises based version and

00:19:40,240 --> 00:19:45,190
then a callback based version and so the

00:19:43,090 --> 00:19:47,920
the first one shown here is the

00:19:45,190 --> 00:19:49,720
synchronous version second is promises

00:19:47,920 --> 00:19:55,150
and then the one at the bottom is the

00:19:49,720 --> 00:19:57,430
old-school callback based approach so

00:19:55,150 --> 00:19:58,570
from the code that we just saw the first

00:19:57,430 --> 00:20:01,450
thing that would happen is we would call

00:19:58,570 --> 00:20:03,070
into nodes FS module in this case I'm

00:20:01,450 --> 00:20:04,810
showing the code for the promises based

00:20:03,070 --> 00:20:08,140
version because it's just it fits nicely

00:20:04,810 --> 00:20:10,000
on a slide a little better but you know

00:20:08,140 --> 00:20:11,590
if you look inside node there's similar

00:20:10,000 --> 00:20:15,190
code for synchronous and callback

00:20:11,590 --> 00:20:17,620
versions but so all we're doing here is

00:20:15,190 --> 00:20:19,180
we're passing in source the destination

00:20:17,620 --> 00:20:21,810
so you know where we're gonna copy the

00:20:19,180 --> 00:20:24,910
file to and then certain flags that that

00:20:21,810 --> 00:20:27,010
the operation takes so for an example

00:20:24,910 --> 00:20:28,780
flag would be you know if the file

00:20:27,010 --> 00:20:31,420
exists already do we want to overwrite

00:20:28,780 --> 00:20:33,310
it or not things like that we're gonna

00:20:31,420 --> 00:20:36,820
validate both the source and destination

00:20:33,310 --> 00:20:38,620
paths inside of node the flags we're

00:20:36,820 --> 00:20:40,780
gonna make sure that the flag is an

00:20:38,620 --> 00:20:43,680
integer so that's what the or 0 is

00:20:40,780 --> 00:20:46,210
that's kind of a JavaScript trick

00:20:43,680 --> 00:20:48,280
javascript doesn't really have different

00:20:46,210 --> 00:20:51,190
types of numbers but under the hood the

00:20:48,280 --> 00:20:54,010
j/s engine does so the or 0 will

00:20:51,190 --> 00:20:56,740
actually convert it to a signed 32-bit

00:20:54,010 --> 00:20:59,020
integer under the hood and then we're

00:20:56,740 --> 00:21:02,710
gonna call binding copy file and pass in

00:20:59,020 --> 00:21:04,930
the the you know normalized paths the

00:21:02,710 --> 00:21:07,540
flags and then a special symbol here

00:21:04,930 --> 00:21:09,790
called K use promises this is just a

00:21:07,540 --> 00:21:10,990
symbol that under the hood will tell the

00:21:09,790 --> 00:21:12,970
binding layer that we're doing a

00:21:10,990 --> 00:21:18,040
promises operation as opposed to

00:21:12,970 --> 00:21:19,390
synchronous or callbacks and so if you

00:21:18,040 --> 00:21:21,280
look through the node code base these

00:21:19,390 --> 00:21:23,800
are the three different ways that we

00:21:21,280 --> 00:21:25,420
would call binding copy file you'll

00:21:23,800 --> 00:21:26,110
notice that the first three parameters

00:21:25,420 --> 00:21:28,210
and every cake

00:21:26,110 --> 00:21:29,740
face are the source destination and

00:21:28,210 --> 00:21:33,010
flags because that's gonna be the data

00:21:29,740 --> 00:21:35,080
that we're operating on but then the you

00:21:33,010 --> 00:21:37,450
know the remaining arguments differ

00:21:35,080 --> 00:21:40,000
between the implementations so I already

00:21:37,450 --> 00:21:41,679
mentioned ku's promises is a symbol that

00:21:40,000 --> 00:21:45,520
tells you to use the promises

00:21:41,679 --> 00:21:47,559
implementation the the synchronous

00:21:45,520 --> 00:21:49,900
version passes undefined followed by a

00:21:47,559 --> 00:21:51,730
context the context is what will be

00:21:49,900 --> 00:21:53,020
populated with any results and errors

00:21:51,730 --> 00:21:55,809
that might come back from the binding

00:21:53,020 --> 00:21:57,520
layer and then the callback based

00:21:55,809 --> 00:22:01,450
version just passes something called req

00:21:57,520 --> 00:22:04,510
which is a C++ object that's used for in

00:22:01,450 --> 00:22:06,100
the callback code so from here we're

00:22:04,510 --> 00:22:08,650
gonna be leaving JavaScript we're gonna

00:22:06,100 --> 00:22:12,370
be entering the the really ugly C++ code

00:22:08,650 --> 00:22:15,280
that I talked about a little bit can

00:22:12,370 --> 00:22:18,850
everybody in the back read that not that

00:22:15,280 --> 00:22:21,610
it's nice code but so this is actually

00:22:18,850 --> 00:22:24,549
the C++ code that gets executed any time

00:22:21,610 --> 00:22:26,890
you run copy file the first you know

00:22:24,549 --> 00:22:29,169
collection of statements you'll see a

00:22:26,890 --> 00:22:32,440
bunch of check GE check not in all

00:22:29,169 --> 00:22:35,520
things like that these are basically a

00:22:32,440 --> 00:22:38,260
last-ditch effort to validate user input

00:22:35,520 --> 00:22:40,840
if any of these checks fail node will

00:22:38,260 --> 00:22:43,419
hard crash and we're okay with that for

00:22:40,840 --> 00:22:44,740
a couple reasons first off you're really

00:22:43,419 --> 00:22:46,929
not supposed to be using the bonding

00:22:44,740 --> 00:22:49,030
layer directly so if if in your code

00:22:46,929 --> 00:22:51,490
you're calling this directly then you

00:22:49,030 --> 00:22:53,169
know you're kind of on your own the

00:22:51,490 --> 00:22:54,640
other reason is we have already done

00:22:53,169 --> 00:22:56,260
we've already validated all these same

00:22:54,640 --> 00:22:58,000
things in JavaScript so we're just

00:22:56,260 --> 00:22:59,290
trying to make sure that you know people

00:22:58,000 --> 00:23:02,860
aren't going to be passing and garbage

00:22:59,290 --> 00:23:04,809
data to us from there we're actually

00:23:02,860 --> 00:23:07,419
gonna then call something called get

00:23:04,809 --> 00:23:09,760
wreck wrap and that is how what we're

00:23:07,419 --> 00:23:11,380
going to be able to use to determine at

00:23:09,760 --> 00:23:13,840
what type of operation it's going to be

00:23:11,380 --> 00:23:15,549
so synchronous asynchronous and then if

00:23:13,840 --> 00:23:18,490
it is asynchronous is that callbacks or

00:23:15,549 --> 00:23:19,809
promises and I'm not gonna go too much

00:23:18,490 --> 00:23:21,309
into what all these different arguments

00:23:19,809 --> 00:23:23,470
are because you can see there's there's

00:23:21,309 --> 00:23:25,330
you know a lot of them but you'll see

00:23:23,470 --> 00:23:27,090
that copy file is there you'll see the

00:23:25,330 --> 00:23:29,770
source and the destination and the flags

00:23:27,090 --> 00:23:32,080
and then most importantly you'll see UV

00:23:29,770 --> 00:23:34,179
underscore FS underscore copy file

00:23:32,080 --> 00:23:36,510
that's the function inside of live UV

00:23:34,179 --> 00:23:37,650
that this operation is going to execute

00:23:36,510 --> 00:23:38,940
so

00:23:37,650 --> 00:23:40,650
from here we're actually going to be

00:23:38,940 --> 00:23:44,220
leaving node completely and going into

00:23:40,650 --> 00:23:46,380
Libya V and this is that same function

00:23:44,220 --> 00:23:49,050
that I just mentioned this is what the

00:23:46,380 --> 00:23:50,660
signature looks like so the first

00:23:49,050 --> 00:23:52,860
parameter is going to be the event loop

00:23:50,660 --> 00:23:55,560
for synchronous operations that can

00:23:52,860 --> 00:23:58,470
actually be no but it'll be there in all

00:23:55,560 --> 00:24:01,320
the calls the the rack the second

00:23:58,470 --> 00:24:03,780
parameter is it's gonna be basically a

00:24:01,320 --> 00:24:05,310
file system operation request so you

00:24:03,780 --> 00:24:08,690
know earlier I talked about handles and

00:24:05,310 --> 00:24:11,640
requests this is one of those requests

00:24:08,690 --> 00:24:13,170
so nodes not really responsible for

00:24:11,640 --> 00:24:15,510
attaching all of the information to the

00:24:13,170 --> 00:24:17,340
request there are some macros down later

00:24:15,510 --> 00:24:20,010
in this code that I'll go over that kind

00:24:17,340 --> 00:24:21,840
of populate that some more but then the

00:24:20,010 --> 00:24:24,690
source and destinations are passed as

00:24:21,840 --> 00:24:26,520
path and new path the same Flags that we

00:24:24,690 --> 00:24:30,090
gave in JavaScript or past as the flags

00:24:26,520 --> 00:24:32,340
and then the UV FS callback that's gonna

00:24:30,090 --> 00:24:35,280
be either a callback function or an all

00:24:32,340 --> 00:24:38,280
if it's synchronous from there we're

00:24:35,280 --> 00:24:39,900
gonna call init so in it is a macro it's

00:24:38,280 --> 00:24:41,310
gonna populate that request that I

00:24:39,900 --> 00:24:43,350
talked about with it's gonna basically

00:24:41,310 --> 00:24:45,600
tell the request that this is a copy

00:24:43,350 --> 00:24:47,430
file operation so everybody who calls

00:24:45,600 --> 00:24:49,860
into libuv doesn't have to specify what

00:24:47,430 --> 00:24:51,690
operation they're running it'll just you

00:24:49,860 --> 00:24:55,680
know automatically know by the function

00:24:51,690 --> 00:24:57,570
that you call then we do some some flag

00:24:55,680 --> 00:24:59,130
validations so we want to make sure that

00:24:57,570 --> 00:25:02,550
you know people are passing in garbage

00:24:59,130 --> 00:25:04,410
values in the CLA or - so if anyone

00:25:02,550 --> 00:25:06,770
passes in a flag that we don't recognize

00:25:04,410 --> 00:25:10,530
will return am Val

00:25:06,770 --> 00:25:12,690
next we do cap FS capture path the point

00:25:10,530 --> 00:25:14,070
of this function is to basically take

00:25:12,690 --> 00:25:16,470
the path that was passed in and make a

00:25:14,070 --> 00:25:18,360
copy of it because if we're doing an

00:25:16,470 --> 00:25:20,280
asynchronous operation there's a chance

00:25:18,360 --> 00:25:22,830
that that that memory could be freed by

00:25:20,280 --> 00:25:23,820
the time the operation completes if that

00:25:22,830 --> 00:25:28,410
happens you're probably going to run

00:25:23,820 --> 00:25:29,910
into a hard crash and then finally we we

00:25:28,410 --> 00:25:33,210
add the flags to the request and then we

00:25:29,910 --> 00:25:35,580
call post so post is another macro that

00:25:33,210 --> 00:25:38,280
is gonna send your work off to the

00:25:35,580 --> 00:25:40,620
thread pool it's worth pointing out this

00:25:38,280 --> 00:25:44,090
is the actual full implementation on

00:25:40,620 --> 00:25:48,260
Windows there are similar ones on

00:25:44,090 --> 00:25:50,299
in Linux but because the windows code is

00:25:48,260 --> 00:25:54,289
a little smaller and cleaner I'm going

00:25:50,299 --> 00:25:57,559
with that so this is what the post macro

00:25:54,289 --> 00:25:59,120
looks like basically it checks the call

00:25:57,559 --> 00:26:01,159
back if it's null or not so it knows if

00:25:59,120 --> 00:26:03,500
it's synchronous or asynchronous and

00:26:01,159 --> 00:26:05,539
then if it's asynchronous it's gonna

00:26:03,500 --> 00:26:08,059
register the request with the event loop

00:26:05,539 --> 00:26:11,419
so once it does that it it'll keep your

00:26:08,059 --> 00:26:13,279
operate your process alive if the while

00:26:11,419 --> 00:26:15,140
the work is still happening and then

00:26:13,279 --> 00:26:17,480
it'll call work submit which basically

00:26:15,140 --> 00:26:20,120
takes you know your request and sends it

00:26:17,480 --> 00:26:23,149
off to the thread pool you'll see you've

00:26:20,120 --> 00:26:25,279
EFS work as one of the parameters that's

00:26:23,149 --> 00:26:26,720
basically a giant switch case where it

00:26:25,279 --> 00:26:28,789
looks at what type of operation you're

00:26:26,720 --> 00:26:30,500
trying to run and then you know cause

00:26:28,789 --> 00:26:33,350
whatever the code that you need to call

00:26:30,500 --> 00:26:34,880
for that and then you've EFS done is

00:26:33,350 --> 00:26:36,500
what's going to be called once the work

00:26:34,880 --> 00:26:37,820
is completing the thread pool that'll

00:26:36,500 --> 00:26:39,200
basically propagate you back to the

00:26:37,820 --> 00:26:42,529
binding layer and then back up to

00:26:39,200 --> 00:26:44,390
JavaScript if you're using a synchronous

00:26:42,529 --> 00:26:46,909
operation we just call you VFS work

00:26:44,390 --> 00:26:48,049
directly so it'll do the copy and then

00:26:46,909 --> 00:26:49,669
it'll just return the results directly

00:26:48,049 --> 00:26:50,720
because there's we don't really need to

00:26:49,669 --> 00:26:56,360
involve the thread pool if we're

00:26:50,720 --> 00:27:00,230
blocking so this is the windows internal

00:26:56,360 --> 00:27:01,970
copy file implementation we're again

00:27:00,230 --> 00:27:05,090
gonna do some flag validation this is

00:27:01,970 --> 00:27:07,850
gonna be operating system specific flag

00:27:05,090 --> 00:27:09,710
validation because certain things are

00:27:07,850 --> 00:27:12,200
supported on UNIX and Mac that aren't

00:27:09,710 --> 00:27:14,690
supported on Windows and then you'll see

00:27:12,200 --> 00:27:16,880
the copy file W called that's actually a

00:27:14,690 --> 00:27:19,490
Windows API call that will handle the

00:27:16,880 --> 00:27:22,549
copy for you and then the rest of the

00:27:19,490 --> 00:27:24,350
code at the bottom is because of a

00:27:22,549 --> 00:27:27,020
little bug on Windows where it'll return

00:27:24,350 --> 00:27:29,510
e busy if you're trying to copy the same

00:27:27,020 --> 00:27:31,909
source and destination so we try to do

00:27:29,510 --> 00:27:34,549
the the copy operation if it fails with

00:27:31,909 --> 00:27:36,500
a busy then we stat both of the both of

00:27:34,549 --> 00:27:38,240
the files and if it's the same then we

00:27:36,500 --> 00:27:41,510
know the operation actually succeeded

00:27:38,240 --> 00:27:41,990
and it's not a genuine error but from

00:27:41,510 --> 00:27:43,940
there

00:27:41,990 --> 00:27:45,380
we're basically you know gonna go back

00:27:43,940 --> 00:27:48,049
up the stack so we'll go back to the

00:27:45,380 --> 00:27:49,460
will exit the event loop go back up to

00:27:48,049 --> 00:27:54,559
the binding layer back up into

00:27:49,460 --> 00:27:56,929
JavaScript next I want to talk a little

00:27:54,559 --> 00:27:57,710
bit about the possibility of a libya V

00:27:56,929 --> 00:28:00,679
2.0

00:27:57,710 --> 00:28:02,059
so this has kind of been an ongoing

00:28:00,679 --> 00:28:05,480
thing for a while

00:28:02,059 --> 00:28:08,000
Libby v1 was released in 2014 so it's

00:28:05,480 --> 00:28:10,220
now about five years old

00:28:08,000 --> 00:28:12,970
the project has it been an API and a

00:28:10,220 --> 00:28:17,799
bi-stable since then with a few you know

00:28:12,970 --> 00:28:20,090
basically a few oops is on our side but

00:28:17,799 --> 00:28:21,799
in order to do some cleanup that we'd

00:28:20,090 --> 00:28:23,600
like to do and add some new features

00:28:21,799 --> 00:28:27,260
that are breaking changes we would have

00:28:23,600 --> 00:28:29,539
to bump up to 2.0 the problem with that

00:28:27,260 --> 00:28:34,549
is at this point that would be a rather

00:28:29,539 --> 00:28:36,049
large like Delta but also we have a

00:28:34,549 --> 00:28:38,770
small team so there are you know

00:28:36,049 --> 00:28:40,760
hundreds of people collaborating on node

00:28:38,770 --> 00:28:41,990
I'd say there's less than 10

00:28:40,760 --> 00:28:44,330
collaborating on libuv

00:28:41,990 --> 00:28:45,799
so it's a pretty big support job for the

00:28:44,330 --> 00:28:49,490
people who are working on Libby v2

00:28:45,799 --> 00:28:51,020
support a 1x and a - Oh even though some

00:28:49,490 --> 00:28:54,320
projects out there are already actually

00:28:51,020 --> 00:28:56,570
using the the fake - oh so we have V 1 X

00:28:54,320 --> 00:28:58,970
which is what node and most people are

00:28:56,570 --> 00:29:01,640
using and then the master branch in

00:28:58,970 --> 00:29:03,620
github is what would be the - oh I think

00:29:01,640 --> 00:29:07,309
Giulio Lange at least is already using

00:29:03,620 --> 00:29:09,409
that but you know we've we've been going

00:29:07,309 --> 00:29:11,330
back and forth on this for over a year

00:29:09,409 --> 00:29:13,039
now and we're starting I think we're

00:29:11,330 --> 00:29:15,350
starting to come around to the idea of

00:29:13,039 --> 00:29:16,669
just staying on v1 forever there's you

00:29:15,350 --> 00:29:19,700
know something to be said for stability

00:29:16,669 --> 00:29:22,460
and things like that it would avoid

00:29:19,700 --> 00:29:25,429
extra work on node side of having to

00:29:22,460 --> 00:29:27,470
create you know api's and n api so that

00:29:25,429 --> 00:29:30,260
so that libuv changes wouldn't break

00:29:27,470 --> 00:29:32,240
node add ons and things like that so I

00:29:30,260 --> 00:29:35,659
think now we're leaning more towards you

00:29:32,240 --> 00:29:37,789
know one dot X forever but we are still

00:29:35,659 --> 00:29:39,919
adding a bunch of new features so this

00:29:37,789 --> 00:29:43,370
is just some of them that have landed in

00:29:39,919 --> 00:29:45,380
the past year one of the one of the ones

00:29:43,370 --> 00:29:48,140
that I guess depending on your use case

00:29:45,380 --> 00:29:50,450
could be a big feature is the maximum

00:29:48,140 --> 00:29:52,370
thread pool size has been increased so

00:29:50,450 --> 00:29:54,559
you know by default it's still going to

00:29:52,370 --> 00:29:56,090
be four threads but if you really need

00:29:54,559 --> 00:29:58,880
it you can bump it up to a thousand

00:29:56,090 --> 00:30:01,330
twenty four threads prior to that change

00:29:58,880 --> 00:30:03,679
the maximum that you could do is 128

00:30:01,330 --> 00:30:05,600
people have made the case that you know

00:30:03,679 --> 00:30:08,480
as computers continue to get better we

00:30:05,600 --> 00:30:10,580
can run more threads we've added

00:30:08,480 --> 00:30:12,860
something called UV random

00:30:10,580 --> 00:30:16,450
so this is gonna be Libya visa answer to

00:30:12,860 --> 00:30:19,929
generating cross-platform random numbers

00:30:16,450 --> 00:30:22,460
UDP connected sockets are a new thing so

00:30:19,929 --> 00:30:24,470
you know UDP sockets you generally think

00:30:22,460 --> 00:30:26,210
of you just kind of broadcast your

00:30:24,470 --> 00:30:28,039
messages out and maybe it'll be received

00:30:26,210 --> 00:30:31,700
maybe it won't but it's actually

00:30:28,039 --> 00:30:33,950
possible to connect a UDP socket so that

00:30:31,700 --> 00:30:37,370
anytime you do to send it'll always send

00:30:33,950 --> 00:30:39,830
to the same destination we've added you

00:30:37,370 --> 00:30:41,809
v.o.s you name so if you're interested

00:30:39,830 --> 00:30:43,279
in getting more information about what

00:30:41,809 --> 00:30:45,799
platform you're running on that's gonna

00:30:43,279 --> 00:30:47,750
that's gonna be useful there and then

00:30:45,799 --> 00:30:51,500
we've actually taken that and nodes OS

00:30:47,750 --> 00:30:54,760
module is now built on top of that UV

00:30:51,500 --> 00:30:58,450
get constrained memory is interesting so

00:30:54,760 --> 00:31:02,720
one of the problems that people have is

00:30:58,450 --> 00:31:04,789
you know especially v8 would set its its

00:31:02,720 --> 00:31:06,529
memory limit to like you know a certain

00:31:04,789 --> 00:31:08,929
amount of memory like whatever is

00:31:06,529 --> 00:31:10,970
available in the computer but some

00:31:08,929 --> 00:31:13,010
operating systems like Linux have things

00:31:10,970 --> 00:31:15,049
called C groups and then there can be

00:31:13,010 --> 00:31:16,309
other you know right now we only look at

00:31:15,049 --> 00:31:18,260
C groups but in the future can be

00:31:16,309 --> 00:31:20,240
expanded to other things where you can

00:31:18,260 --> 00:31:22,789
actually impose artificial memory

00:31:20,240 --> 00:31:25,399
constraints on your application and so

00:31:22,789 --> 00:31:26,809
if something like v8 would try to use of

00:31:25,399 --> 00:31:29,720
the system memory it's not going to be

00:31:26,809 --> 00:31:31,190
able to do that anyway so you V get

00:31:29,720 --> 00:31:33,500
constrained memory lets you actually

00:31:31,190 --> 00:31:35,299
query the operating system to see how

00:31:33,500 --> 00:31:39,200
much memory you're allowed to use so

00:31:35,299 --> 00:31:41,389
that's a useful one threads can now

00:31:39,200 --> 00:31:43,760
actually set what they want their stack

00:31:41,389 --> 00:31:45,470
size to be so that's just a little tweak

00:31:43,760 --> 00:31:47,559
for you know if you know how much memory

00:31:45,470 --> 00:31:50,960
you're gonna need you can configure that

00:31:47,559 --> 00:31:55,360
a really big one was streaming reader so

00:31:50,960 --> 00:31:59,630
this request goes back like five years

00:31:55,360 --> 00:32:02,240
node has FS dot reader but under the

00:31:59,630 --> 00:32:04,460
hood that actually costs kinder and that

00:32:02,240 --> 00:32:06,049
buffers of the requests at once so you

00:32:04,460 --> 00:32:07,940
could see if you're trying to read a

00:32:06,049 --> 00:32:10,940
very large directory how you could run

00:32:07,940 --> 00:32:12,590
into memory issues so people have wanted

00:32:10,940 --> 00:32:14,840
streaming reader we had a pull request

00:32:12,590 --> 00:32:18,110
that changed hands like three or four

00:32:14,840 --> 00:32:20,720
times and then it was also targeted the

00:32:18,110 --> 00:32:22,279
master branch so within the past year we

00:32:20,720 --> 00:32:24,380
actually you know got that under control

00:32:22,279 --> 00:32:25,970
got it targeting the V

00:32:24,380 --> 00:32:27,980
one X branch and we're able to get it

00:32:25,970 --> 00:32:30,370
landed and you know as of a couple

00:32:27,980 --> 00:32:33,410
months ago it's now shipping and node

00:32:30,370 --> 00:32:36,410
and then just you Viet get time-of-day

00:32:33,410 --> 00:32:40,570
this is the you know basically the the

00:32:36,410 --> 00:32:44,630
sea equivalent of date now and you VFS

00:32:40,570 --> 00:32:49,310
MKS temp so it's a call to make a temp

00:32:44,630 --> 00:32:51,830
file for your application and then I

00:32:49,310 --> 00:32:53,480
wanted to finish up with just one thing

00:32:51,830 --> 00:32:56,540
that's I guess tangentially related to

00:32:53,480 --> 00:32:58,240
libuv but it's my talk my rules so I

00:32:56,540 --> 00:33:02,330
want to talk about it

00:32:58,240 --> 00:33:05,030
it's called UV huazi so Y Z is the web

00:33:02,330 --> 00:33:07,280
assembly system interface it's

00:33:05,030 --> 00:33:10,040
relatively new it came out within the

00:33:07,280 --> 00:33:12,710
past year and it basically gives

00:33:10,040 --> 00:33:15,710
webassembly applications a way to access

00:33:12,710 --> 00:33:17,900
the underlying operating system because

00:33:15,710 --> 00:33:21,650
by default web assembly code is

00:33:17,900 --> 00:33:23,000
sandboxed so I you know as a limb UV

00:33:21,650 --> 00:33:24,980
maintainer I'm when I first heard about

00:33:23,000 --> 00:33:27,260
huazi I was like oh that sounds like

00:33:24,980 --> 00:33:29,450
libuv for for web assembly I was like

00:33:27,260 --> 00:33:31,760
let me try to build that so I did I

00:33:29,450 --> 00:33:35,260
built it on top of libuv for you know

00:33:31,760 --> 00:33:37,850
maximum portability and then as of node

00:33:35,260 --> 00:33:38,660
13.3 which I don't know came out in the

00:33:37,850 --> 00:33:41,750
past month or so

00:33:38,660 --> 00:33:44,300
it's shipping and nodes so there's

00:33:41,750 --> 00:33:46,090
documentation you can do require Y Z and

00:33:44,300 --> 00:33:48,260
and play around with that if you want

00:33:46,090 --> 00:33:51,860
hoping to do more work on that in the

00:33:48,260 --> 00:33:53,420
future the the github repository is

00:33:51,860 --> 00:33:56,900
shown on the slide

00:33:53,420 --> 00:33:59,180
wozy dev is the kind of homepage for Y Z

00:33:56,900 --> 00:33:59,870
so if you're interested in web assembly

00:33:59,180 --> 00:34:01,490
or anything like that

00:33:59,870 --> 00:34:04,730
I encourage you to go play around with

00:34:01,490 --> 00:34:05,050
that and that is all that I have thank

00:34:04,730 --> 00:34:09,559
you

00:34:05,050 --> 00:34:09,559

YouTube URL: https://www.youtube.com/watch?v=wBiqtkFKJug


