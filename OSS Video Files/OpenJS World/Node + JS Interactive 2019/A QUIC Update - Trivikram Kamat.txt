Title: A QUIC Update - Trivikram Kamat
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	A QUIC Update - Trivikram Kamat
Speakers: Trivikram Kamat
The QUIC and HTTP/3 protocols are currently being developed by the IETF. While they are busy working, we've been busy working on an implementation within Node.js core. This presentation will introduce the protocol and the implementation and update on where things are at!
Captions: 
	00:00:00,030 --> 00:00:07,560
welcome to node.js interactive this is a

00:00:02,970 --> 00:00:10,920
talk on STP three quick update remember

00:00:07,560 --> 00:00:14,549
that this is experimental so do not try

00:00:10,920 --> 00:00:16,789
it in production if you try it in

00:00:14,549 --> 00:00:19,590
production do not blame me

00:00:16,789 --> 00:00:21,840
my name is Sriram Kamath I'm so Fidelma

00:00:19,590 --> 00:00:26,369
engineer my twitter handle is three week

00:00:21,840 --> 00:00:28,410
RAM and data handle is three week AR if

00:00:26,369 --> 00:00:31,289
you see I did not get three week ram

00:00:28,410 --> 00:00:33,540
handle on github that is because

00:00:31,289 --> 00:00:36,570
somebody I joined a tablet in 2015 and

00:00:33,540 --> 00:00:39,870
somebody else has taken it already so if

00:00:36,570 --> 00:00:43,020
you become parents recently get get up

00:00:39,870 --> 00:00:47,700
handle for your kids because that's more

00:00:43,020 --> 00:00:51,030
important than other social media so the

00:00:47,700 --> 00:00:52,710
respect for node.js in directive is hash

00:00:51,030 --> 00:00:54,960
technologies interactive if you're

00:00:52,710 --> 00:00:58,829
active on social media you can also use

00:00:54,960 --> 00:01:02,190
HTTP 3 or quick if you like this talk if

00:00:58,829 --> 00:01:04,710
you did like this talk then use my name

00:01:02,190 --> 00:01:08,100
and what's my name again most of you

00:01:04,710 --> 00:01:11,909
will have forgotten so I'll give like

00:01:08,100 --> 00:01:13,890
clue ok so we are in Canada and it is

00:01:11,909 --> 00:01:17,250
very cold and you will be knowing this

00:01:13,890 --> 00:01:24,659
drink it's called rum it gives a lot of

00:01:17,250 --> 00:01:30,119
warmth so imagine a weak rum not a

00:01:24,659 --> 00:01:33,299
strong rum a weak rum and add 3 in front

00:01:30,119 --> 00:01:34,829
of it that's my name so what's my

00:01:33,299 --> 00:01:36,630
history with not just I've been using

00:01:34,829 --> 00:01:39,210
node.js for 4 years now I started

00:01:36,630 --> 00:01:42,630
contributing to node.js code in October

00:01:39,210 --> 00:01:45,240
2017 helped make a trip to stable write

00:01:42,630 --> 00:01:46,560
wrote unit test and fix some bugs you

00:01:45,240 --> 00:01:49,140
can do the same with step3

00:01:46,560 --> 00:01:52,259
we'll cover that I became node.js code

00:01:49,140 --> 00:01:54,920
collaborator in March 2018 and I

00:01:52,259 --> 00:01:57,590
organized a mentor for code n LAN events

00:01:54,920 --> 00:02:00,719
what are we going to cover in this talk

00:01:57,590 --> 00:02:05,850
we are going to cover what is STB 1.1

00:02:00,719 --> 00:02:10,590
and y acp to was required then we will

00:02:05,850 --> 00:02:12,979
cover what is HCP to and wiht p3 was

00:02:10,590 --> 00:02:12,979
required

00:02:13,140 --> 00:02:21,150
then you will cover what is HDPE 3 and

00:02:17,450 --> 00:02:22,560
when is it coming it's still draft it's

00:02:21,150 --> 00:02:25,910
still accelerator when is it coming and

00:02:22,560 --> 00:02:29,400
we will see some sample code on the way

00:02:25,910 --> 00:02:33,570
so I would like to thank James Snell who

00:02:29,400 --> 00:02:35,700
is here he's an odious technical sharing

00:02:33,570 --> 00:02:37,410
company member and heading the work on

00:02:35,700 --> 00:02:40,050
implementing quick thanks James

00:02:37,410 --> 00:02:41,700
and I look also like to thank the

00:02:40,050 --> 00:02:44,790
sponsors for his work

00:02:41,700 --> 00:02:47,780
it is protocol labs and near forum I'll

00:02:44,790 --> 00:02:51,390
also like to thank enna Henningsen as

00:02:47,780 --> 00:02:56,670
James says she fixes the books which he

00:02:51,390 --> 00:02:58,530
introduces and I also thank Daniel 1o

00:02:56,670 --> 00:03:01,770
yang and many others who have

00:02:58,530 --> 00:03:04,920
contributed too quick already I also

00:03:01,770 --> 00:03:07,560
like to think that's you know that's

00:03:04,920 --> 00:03:11,550
where your son for his awesome work in

00:03:07,560 --> 00:03:14,010
NGTC we do like we are using ng TCP to

00:03:11,550 --> 00:03:16,560
in for implementing quick and he has

00:03:14,010 --> 00:03:20,750
done some amazing work so let's start

00:03:16,560 --> 00:03:23,130
with STP 0.9 which was published in 1991

00:03:20,750 --> 00:03:26,340
and it was very simple it was just one

00:03:23,130 --> 00:03:29,190
line protocol okay you get my page or

00:03:26,340 --> 00:03:32,430
HTML you send get my page what estimate

00:03:29,190 --> 00:03:34,440
and you get my beta rest Raymond awesome

00:03:32,430 --> 00:03:36,930
right like life was so simple back in

00:03:34,440 --> 00:03:39,900
1991 but things had to get complicated

00:03:36,930 --> 00:03:44,250
so I step II wondered Oh dot introduced

00:03:39,900 --> 00:03:46,170
in May 1996 and it will extensibility

00:03:44,250 --> 00:03:47,519
let us see what it did okay this have

00:03:46,170 --> 00:03:49,620
you send request this is what the

00:03:47,519 --> 00:03:51,420
response you get so now you can send

00:03:49,620 --> 00:03:53,700
version information because now there is

00:03:51,420 --> 00:03:55,350
more than one HTTP protocol you also

00:03:53,700 --> 00:03:58,200
send browser information because there

00:03:55,350 --> 00:04:01,170
are multiple browsers and then you send

00:03:58,200 --> 00:04:03,750
status code because not all requests are

00:04:01,170 --> 00:04:05,700
successful sometimes the redirect backs

00:04:03,750 --> 00:04:07,560
sometimes client error sometimes your

00:04:05,700 --> 00:04:09,120
server error then there are headers who

00:04:07,560 --> 00:04:11,489
did information what kind of server is

00:04:09,120 --> 00:04:13,200
there okay what kind of content type so

00:04:11,489 --> 00:04:16,500
instead of sending content text you can

00:04:13,200 --> 00:04:18,600
even send JSON and other types and then

00:04:16,500 --> 00:04:20,700
we could we could include multiple

00:04:18,600 --> 00:04:23,990
resources in the HTML file so in this

00:04:20,700 --> 00:04:26,940
HTML file that is an image being used

00:04:23,990 --> 00:04:30,480
so then STP 1.1 the standardized but

00:04:26,940 --> 00:04:31,680
came in June 1999 and I will not go

00:04:30,480 --> 00:04:34,530
through the headers because there are

00:04:31,680 --> 00:04:37,410
too many headers we will just see what

00:04:34,530 --> 00:04:38,790
were the improvements in HTTP 1.1 so

00:04:37,410 --> 00:04:40,800
first improvement was precision

00:04:38,790 --> 00:04:43,200
persistent connection in which you can

00:04:40,800 --> 00:04:45,090
use single TCP connection to send and

00:04:43,200 --> 00:04:47,670
receive multiple requests and responses

00:04:45,090 --> 00:04:50,460
which are serial not the concurrent ones

00:04:47,670 --> 00:04:53,460
which are serial and there was

00:04:50,460 --> 00:04:55,740
pipelining in which second request can

00:04:53,460 --> 00:04:57,750
be sent before the first one is fully

00:04:55,740 --> 00:04:59,340
transmitted and there was chum transfer

00:04:57,750 --> 00:05:01,080
encoding and there was additional cache

00:04:59,340 --> 00:05:03,570
control mechanism there is content

00:05:01,080 --> 00:05:07,950
negotiation we will see what were the

00:05:03,570 --> 00:05:09,270
issues with HTTP 1.1 so first issue is

00:05:07,950 --> 00:05:12,360
three round-trips

00:05:09,270 --> 00:05:14,550
per request so this client in a server

00:05:12,360 --> 00:05:16,740
and this is from blog post from cloud

00:05:14,550 --> 00:05:19,920
fair they written a very good

00:05:16,740 --> 00:05:24,240
description so client sends a TCP syn

00:05:19,920 --> 00:05:26,640
packet then server sends TCP syn plus a

00:05:24,240 --> 00:05:29,790
psychic line sends TCP ack then client

00:05:26,640 --> 00:05:37,800
says th TLS client hello service ace TLS

00:05:29,790 --> 00:05:41,460
server is not send okay then HTP request

00:05:37,800 --> 00:05:44,460
is sent and ship e response comes who

00:05:41,460 --> 00:05:48,300
has time for this okay three round-trips

00:05:44,460 --> 00:05:51,180
per a TCP connection let's revisit this

00:05:48,300 --> 00:05:53,970
header issue number two was multiple PCP

00:05:51,180 --> 00:05:57,150
plus TLS connections Ark were created

00:05:53,970 --> 00:05:59,400
for concurrent requests so how does

00:05:57,150 --> 00:06:01,440
happen like you write applications right

00:05:59,400 --> 00:06:04,140
in in those applications you will be

00:06:01,440 --> 00:06:06,390
importing images will be importing CSS

00:06:04,140 --> 00:06:08,430
you will be importing GS and these

00:06:06,390 --> 00:06:11,130
things have to be imported concurrently

00:06:08,430 --> 00:06:13,530
and when that happens multiple TCP

00:06:11,130 --> 00:06:15,450
connections are created and for each TCP

00:06:13,530 --> 00:06:19,350
connection there are three round-trips

00:06:15,450 --> 00:06:21,390
as we saw so it takes a lot of time so

00:06:19,350 --> 00:06:24,900
let us understand this by going through

00:06:21,390 --> 00:06:27,980
the code because talking is boring so

00:06:24,900 --> 00:06:30,030
let us see the code if you attended

00:06:27,980 --> 00:06:33,590
matias talk on streams

00:06:30,030 --> 00:06:36,000
you mentioned today that do not use pipe

00:06:33,590 --> 00:06:37,789
because it uses memory leaks

00:06:36,000 --> 00:06:40,610
anyway

00:06:37,789 --> 00:06:42,499
you use some framework yeah but here we

00:06:40,610 --> 00:06:45,889
are just writing normal create a

00:06:42,499 --> 00:06:48,680
strictly typical eight server so if a

00:06:45,889 --> 00:06:51,289
request URL is has just written index if

00:06:48,680 --> 00:06:52,189
it is style dot CSS hit return that okay

00:06:51,289 --> 00:06:54,379
that's it

00:06:52,189 --> 00:06:57,259
so I'll just made it simpler so if

00:06:54,379 --> 00:07:00,620
request URL is the home page written

00:06:57,259 --> 00:07:02,120
index or HTML and otherwise just a

00:07:00,620 --> 00:07:04,339
regular expression which reads what's

00:07:02,120 --> 00:07:07,069
the file name is and return that file

00:07:04,339 --> 00:07:08,210
name from the files folder okay let us

00:07:07,069 --> 00:07:09,740
go through the code because it is

00:07:08,210 --> 00:07:12,740
important we will see how it works in

00:07:09,740 --> 00:07:17,870
STP one and two and three so index.html

00:07:12,740 --> 00:07:21,379
you input style at the top okay then you

00:07:17,870 --> 00:07:23,180
import an image in the body then you say

00:07:21,379 --> 00:07:26,479
hello one because in the first program

00:07:23,180 --> 00:07:29,180
you have to say hello world and then we

00:07:26,479 --> 00:07:31,819
import a script and so go one by one

00:07:29,180 --> 00:07:35,870
what each files to the side or CSS is

00:07:31,819 --> 00:07:38,509
just CSS like just body displays Flex

00:07:35,870 --> 00:07:42,259
forever here just say six what script is

00:07:38,509 --> 00:07:44,330
is that it finds the name and change it

00:07:42,259 --> 00:07:46,339
it changes it to know just interactive

00:07:44,330 --> 00:07:48,949
because we had no just interactive so

00:07:46,339 --> 00:07:51,050
it's a hello note yes interactive and it

00:07:48,949 --> 00:07:55,490
will change the image and upload a page

00:07:51,050 --> 00:07:58,370
to notice inductive image cool that's

00:07:55,490 --> 00:08:00,349
after a second yeah after one cycle wait

00:07:58,370 --> 00:08:12,469
for second and this is just a globe

00:08:00,349 --> 00:08:14,599
image so let's see how it looks and so

00:08:12,469 --> 00:08:18,199
here you can see that we are requesting

00:08:14,599 --> 00:08:20,599
localhost first and then three

00:08:18,199 --> 00:08:23,599
concurrent requests are sent for CSS J's

00:08:20,599 --> 00:08:26,659
and image and then the JavaScript is

00:08:23,599 --> 00:08:29,419
executed after second the set timeout

00:08:26,659 --> 00:08:35,269
and then the image is sent and node.js

00:08:29,419 --> 00:08:39,459
interactive image is shown let us see

00:08:35,269 --> 00:08:39,459
how many tcp ports are created is very

00:08:43,440 --> 00:08:50,380
so below I have a command telnet command

00:08:47,650 --> 00:08:53,320
which looks for how many TCP connections

00:08:50,380 --> 00:08:55,180
are created when you say that request is

00:08:53,320 --> 00:08:56,620
sent for localhost only one TCP

00:08:55,180 --> 00:08:58,900
connections are created it shows three

00:08:56,620 --> 00:09:00,670
records but only one is created but then

00:08:58,900 --> 00:09:02,470
when it has to make three concurrent

00:09:00,670 --> 00:09:04,540
requests you can see multiple TCP

00:09:02,470 --> 00:09:14,170
connections I created that is the issue

00:09:04,540 --> 00:09:16,900
with STP 1.1 so what are the issues a

00:09:14,170 --> 00:09:17,590
step 201 one was three round-trips first

00:09:16,900 --> 00:09:20,290
request

00:09:17,590 --> 00:09:22,060
let me saw and second one was multiple

00:09:20,290 --> 00:09:23,080
TCP potala TLS connections for

00:09:22,060 --> 00:09:26,470
concurrent requests

00:09:23,080 --> 00:09:32,620
now what did STP to do it was published

00:09:26,470 --> 00:09:36,130
in May 2015 and you saw that three

00:09:32,620 --> 00:09:39,550
requests a send for three resources and

00:09:36,130 --> 00:09:41,260
steppy 1.1 in STP to only one PCP

00:09:39,550 --> 00:09:46,060
connection is created although all three

00:09:41,260 --> 00:09:48,010
surfaced so let us see how it works so

00:09:46,060 --> 00:09:50,890
we write by step into server so you

00:09:48,010 --> 00:09:52,690
create a server and then if it is slash

00:09:50,890 --> 00:09:55,150
you would get an index for xtml and

00:09:52,690 --> 00:10:06,100
otherwise you get the regular extra flex

00:09:55,150 --> 00:10:08,680
question at file and so if you examine

00:10:06,100 --> 00:10:12,640
using the network tab it will be same as

00:10:08,680 --> 00:10:14,890
HTTP 1.1 only in the protocol column you

00:10:12,640 --> 00:10:16,660
will see that H 2 is used okay so you

00:10:14,890 --> 00:10:23,290
don't see that how many TCP connections

00:10:16,660 --> 00:10:26,170
are used so I go to the next slide and I

00:10:23,290 --> 00:10:28,780
watch for TCP connections using next

00:10:26,170 --> 00:10:31,360
read command and you will see that only

00:10:28,780 --> 00:10:34,710
one TCP connections are created although

00:10:31,360 --> 00:10:39,640
three requests are sent simultaneously

00:10:34,710 --> 00:10:40,720
so let us see the benefits of HTTP - we

00:10:39,640 --> 00:10:42,520
saw the one in benefit which is

00:10:40,720 --> 00:10:44,470
multiplexing and concurrency so

00:10:42,520 --> 00:10:46,840
different HTP requests are sent on to

00:10:44,470 --> 00:10:48,670
the same TCP connection but there are

00:10:46,840 --> 00:10:50,680
some other benefits also like stream

00:10:48,670 --> 00:10:52,320
dependencies splines can indicate to

00:10:50,680 --> 00:10:55,300
server which dependents are important

00:10:52,320 --> 00:10:56,920
there is H pack header compression where

00:10:55,300 --> 00:10:58,360
it reduces the length

00:10:56,920 --> 00:10:59,680
of the header field and codings by

00:10:58,360 --> 00:11:01,630
exploiting the redundancy because

00:10:59,680 --> 00:11:04,300
headers have lot of redundant code so it

00:11:01,630 --> 00:11:06,220
can be encoded and there is server push

00:11:04,300 --> 00:11:08,019
a server can send resources with clients

00:11:06,220 --> 00:11:10,000
have not requested yet but you will not

00:11:08,019 --> 00:11:12,730
go through that in detail we will just

00:11:10,000 --> 00:11:14,139
see the issues it actually p2 because if

00:11:12,730 --> 00:11:16,480
there are no issues we ship into a ship

00:11:14,139 --> 00:11:20,920
III will not exist so let's say the

00:11:16,480 --> 00:11:22,449
first issue each pack is stateful so the

00:11:20,920 --> 00:11:25,120
encoding and decoding tables how do we

00:11:22,449 --> 00:11:27,070
maintain at the end point so because of

00:11:25,120 --> 00:11:29,050
which so what happens on each packet is

00:11:27,070 --> 00:11:32,740
sent first time it encodes something and

00:11:29,050 --> 00:11:34,779
when second packet is sent it will use

00:11:32,740 --> 00:11:36,360
the encoded content it will send a new

00:11:34,779 --> 00:11:40,899
content only if there are some changes

00:11:36,360 --> 00:11:43,630
so that is one issue Delta encoding is

00:11:40,899 --> 00:11:45,310
used in header compression so this

00:11:43,630 --> 00:11:47,199
causes high resource consumption in

00:11:45,310 --> 00:11:49,810
Braille tired then it's not easily

00:11:47,199 --> 00:11:51,070
routable along the network and the main

00:11:49,810 --> 00:11:54,970
issue which we'll discuss in today's

00:11:51,070 --> 00:11:56,790
talk is disappeared of line blocking so

00:11:54,970 --> 00:11:59,649
what is the CP head of line blocking

00:11:56,790 --> 00:12:02,199
when a single TCP packet is lost or

00:11:59,649 --> 00:12:04,570
corrupted all subsequent packets are

00:12:02,199 --> 00:12:08,019
blocked until the last one can be

00:12:04,570 --> 00:12:10,029
successfully transmitted in HTTP 1.1 if

00:12:08,019 --> 00:12:13,290
this happens you are blocking only one

00:12:10,029 --> 00:12:15,699
request because there is only one

00:12:13,290 --> 00:12:18,490
requests HTTP request sent or a TCP

00:12:15,699 --> 00:12:20,620
connection but in STP too since multiple

00:12:18,490 --> 00:12:23,230
requests and responses has carried over

00:12:20,620 --> 00:12:26,589
a single TCP connection all those

00:12:23,230 --> 00:12:28,300
request responses will be blocked so let

00:12:26,589 --> 00:12:29,230
us understand understand this using

00:12:28,300 --> 00:12:32,560
uh-oh

00:12:29,230 --> 00:12:35,500
so yeah so before that we will see where

00:12:32,560 --> 00:12:37,630
this effect is most very severe is more

00:12:35,500 --> 00:12:40,300
significant it is more significant on

00:12:37,630 --> 00:12:43,569
high latency networks which are long

00:12:40,300 --> 00:12:45,490
distance so if it is high latency

00:12:43,569 --> 00:12:48,730
probability of packet getting lost is

00:12:45,490 --> 00:12:50,500
more or on mobile connections where

00:12:48,730 --> 00:12:52,930
probability of getting packet loss is

00:12:50,500 --> 00:12:57,300
more so we will understand this using a

00:12:52,930 --> 00:12:59,829
chain metaphor so these are chain

00:12:57,300 --> 00:13:03,819
imagine these a TCP connection between

00:12:59,829 --> 00:13:06,310
two computers and what I am done is I

00:13:03,819 --> 00:13:08,470
put green colors and red colors wear

00:13:06,310 --> 00:13:09,610
green color considered that serious

00:13:08,470 --> 00:13:12,520
pocket and

00:13:09,610 --> 00:13:14,110
gallery jsj expected wear CSS and JS

00:13:12,520 --> 00:13:17,590
files are requested over the same

00:13:14,110 --> 00:13:21,220
pacific connection if a J's packet is

00:13:17,590 --> 00:13:24,430
lost or corrupted then the entire chain

00:13:21,220 --> 00:13:26,290
is broken so the entire chain posts that

00:13:24,430 --> 00:13:29,440
J expected which includes a circuits

00:13:26,290 --> 00:13:31,330
have to be sent again this is explained

00:13:29,440 --> 00:13:34,150
very well in HTTP 3 explained if you

00:13:31,330 --> 00:13:37,990
want more details so what does HTTP 3

00:13:34,150 --> 00:13:40,510
over quick does so this is a draft 24 as

00:13:37,990 --> 00:13:43,120
of December 2019 so what it does is that

00:13:40,510 --> 00:13:45,820
when it is setting up multiple streams

00:13:43,120 --> 00:13:48,160
over quick connection they are deterred

00:13:45,820 --> 00:13:49,990
independently so that if any packet goes

00:13:48,160 --> 00:13:52,030
missing in one of the streams only that

00:13:49,990 --> 00:13:54,340
stream has to pause and wait for the

00:13:52,030 --> 00:13:56,170
missing packet to get transmitted so to

00:13:54,340 --> 00:14:00,490
understand this let us see the chain

00:13:56,170 --> 00:14:03,940
analogy in which this CSS stream this

00:14:00,490 --> 00:14:07,840
J's stream if the J stream packet is

00:14:03,940 --> 00:14:10,450
lost the CSS stream is not affected now

00:14:07,840 --> 00:14:12,520
we'll say isn't this what HDPE one was

00:14:10,450 --> 00:14:17,700
doing are we going back

00:14:12,520 --> 00:14:20,590
no because STP 3 is built on top of UDP

00:14:17,700 --> 00:14:23,140
so on the left side you can see ICP 2

00:14:20,590 --> 00:14:25,780
which is built on top of TCP next EP 3

00:14:23,140 --> 00:14:31,240
is built on top of UDP and quick comes

00:14:25,780 --> 00:14:38,050
there in between speaking of UDP I can

00:14:31,240 --> 00:14:44,290
tell you a joke but most of you won't

00:14:38,050 --> 00:14:44,800
get it got it got it got it you didn't

00:14:44,290 --> 00:14:49,660
get it

00:14:44,800 --> 00:14:59,740
let me still give it a try UDP packet

00:14:49,660 --> 00:15:03,340
bar box in - did you get it now so click

00:14:59,740 --> 00:15:05,350
adds the volume to UDP ok it adds error

00:15:03,340 --> 00:15:09,550
handling it adds acknowledgment it adds

00:15:05,350 --> 00:15:12,180
flow control it adds packet sequencing

00:15:09,550 --> 00:15:14,770
built in and encryption tailless 1.3 and

00:15:12,180 --> 00:15:18,280
bi-directionally directional streams so

00:15:14,770 --> 00:15:23,459
whatever benefits you have on TCP those

00:15:18,280 --> 00:15:25,290
goodies will come to quick amazing right

00:15:23,459 --> 00:15:28,350
and quick also reduces round-trips

00:15:25,290 --> 00:15:31,199
remember we saw that three round-trips

00:15:28,350 --> 00:15:34,199
per request who has time for that so in

00:15:31,199 --> 00:15:36,209
UDP it will take on if each round trip

00:15:34,199 --> 00:15:37,800
takes hundred millisecond in quick it

00:15:36,209 --> 00:15:39,929
will take just hundred millisecond for

00:15:37,800 --> 00:15:41,429
the first request or if blind knows the

00:15:39,929 --> 00:15:45,480
server already it will take zero

00:15:41,429 --> 00:15:50,459
millisecond so before we write -

00:15:45,480 --> 00:15:53,850
typically server remember this quick is

00:15:50,459 --> 00:15:56,309
not equal to HT p3 okay this terms will

00:15:53,850 --> 00:15:59,100
be used interchangeably but they are not

00:15:56,309 --> 00:16:01,800
the same so HTTP 3 is the application

00:15:59,100 --> 00:16:05,339
protocol which uses quick as a transport

00:16:01,800 --> 00:16:09,149
protocol so you have STP 3 on top of

00:16:05,339 --> 00:16:11,279
quick then on top of UDP and then IP the

00:16:09,149 --> 00:16:13,589
node.js implementation will let you

00:16:11,279 --> 00:16:16,679
create your own alternative protocols on

00:16:13,589 --> 00:16:19,259
top of quick one place where we are

00:16:16,679 --> 00:16:22,499
considering using quick is for inspector

00:16:19,259 --> 00:16:24,540
protocol we currently use WebSockets but

00:16:22,499 --> 00:16:26,399
we may switch to quick or in Diagnostics

00:16:24,540 --> 00:16:29,089
similarly you can create your own

00:16:26,399 --> 00:16:33,209
application protocol over quick like DNS

00:16:29,089 --> 00:16:37,769
DNS might also use squid so let us say

00:16:33,209 --> 00:16:40,589
that CP 3 server of course when you

00:16:37,769 --> 00:16:42,449
request slash could index otherwise you

00:16:40,589 --> 00:16:46,439
request the file name and you load the

00:16:42,449 --> 00:16:47,220
web page and you and you get this side

00:16:46,439 --> 00:16:51,480
can't be reached

00:16:47,220 --> 00:16:52,740
why because it is experimental ok you

00:16:51,480 --> 00:16:54,959
cannot use it in production it is

00:16:52,740 --> 00:16:57,029
experimental but we have done sort of

00:16:54,959 --> 00:16:59,549
progress so it is an early stage of

00:16:57,029 --> 00:17:01,709
development but you can help build it

00:16:59,549 --> 00:17:03,600
you can help build it you can help build

00:17:01,709 --> 00:17:06,600
it how go to node.js

00:17:03,600 --> 00:17:09,360
with so these are progress we currently

00:17:06,600 --> 00:17:11,339
have around 70% done and this is the

00:17:09,360 --> 00:17:13,980
project board and this slightly outdated

00:17:11,339 --> 00:17:15,360
but you will be wondering oh like I want

00:17:13,980 --> 00:17:16,919
to contribute I can see all the

00:17:15,360 --> 00:17:18,539
excitement in each one of your eyes that

00:17:16,919 --> 00:17:20,069
you want to contribute to quick but you

00:17:18,539 --> 00:17:22,020
will be wondering oh like I don't know

00:17:20,069 --> 00:17:26,250
anything how do I contribute so very

00:17:22,020 --> 00:17:27,839
easy right test start with writing unit

00:17:26,250 --> 00:17:29,490
tests it's amazing when you write unit

00:17:27,839 --> 00:17:31,440
tests you'll find books and you'll fix

00:17:29,490 --> 00:17:34,950
those books and then you can also become

00:17:31,440 --> 00:17:37,140
a collaborator like me so how can I

00:17:34,950 --> 00:17:40,110
write you read text I am glad

00:17:37,140 --> 00:17:43,080
that you asked so you've got to know

00:17:40,110 --> 00:17:46,110
just quick you fork it and then you

00:17:43,080 --> 00:17:48,570
clone it then you say experimental quick

00:17:46,110 --> 00:17:50,880
because it is experimental get the

00:17:48,570 --> 00:17:53,840
coverage and these are the results so I

00:17:50,880 --> 00:17:56,040
take or old but this is what we have for

00:17:53,840 --> 00:17:57,630
JavaScript so if you are into JavaScript

00:17:56,040 --> 00:18:00,390
you can help writing unit tests in

00:17:57,630 --> 00:18:02,130
JavaScript and we need more help in

00:18:00,390 --> 00:18:05,790
writing C++ tests because there is lot

00:18:02,130 --> 00:18:07,890
of code in C++ so remain so now this is

00:18:05,790 --> 00:18:11,270
how to contribute to quick in s 2 P 3

00:18:07,890 --> 00:18:14,309
but if you want to go more deep and

00:18:11,270 --> 00:18:18,059
contribute to the protocol itself then s

00:18:14,309 --> 00:18:20,280
TPT protocol is a ITA IDF draft 24 right

00:18:18,059 --> 00:18:23,309
now so you can join the meetings and

00:18:20,280 --> 00:18:25,500
suggest so we'll just we'll still see an

00:18:23,309 --> 00:18:27,809
example webpage on quick that is squid

00:18:25,500 --> 00:18:31,080
dot rock so this is how it looks so when

00:18:27,809 --> 00:18:35,130
you examine in it you will see that the

00:18:31,080 --> 00:18:38,850
protocol is HTTP 2 plus quick so let's

00:18:35,130 --> 00:18:42,150
go through demo the node.js did not

00:18:38,850 --> 00:18:49,400
build on my machine quick so I'll show

00:18:42,150 --> 00:18:49,400
the demo which James showed so in view

00:18:53,750 --> 00:18:58,410
so this is one of our test that we're

00:18:56,549 --> 00:18:59,520
using and I have debug tracing enabled

00:18:58,410 --> 00:19:00,900
basically you just gonna see a bunch of

00:18:59,520 --> 00:19:04,169
text plan across the screen but it's the

00:19:00,900 --> 00:19:06,270
client talking to the server sending a

00:19:04,169 --> 00:19:08,880
copy of the test file itself back and

00:19:06,270 --> 00:19:10,049
forth all right but I want to once it's

00:19:08,880 --> 00:19:13,020
through I want to point out a few things

00:19:10,049 --> 00:19:15,090
that it and we see in the results so

00:19:13,020 --> 00:19:16,110
this is you know sending all the UDP

00:19:15,090 --> 00:19:19,190
packets this is all the trace

00:19:16,110 --> 00:19:21,929
information just take just a second here

00:19:19,190 --> 00:19:23,340
what it actually works which I'm super

00:19:21,929 --> 00:19:27,210
happy about cuz last week this was seg

00:19:23,340 --> 00:19:29,280
faulting like crazy alright so we see

00:19:27,210 --> 00:19:30,660
here at the end when these in these

00:19:29,280 --> 00:19:33,330
objects and all this information is

00:19:30,660 --> 00:19:34,830
available to the JavaScript layer but we

00:19:33,330 --> 00:19:36,919
have here you know you can see the bytes

00:19:34,830 --> 00:19:39,720
sent right you can see the number of

00:19:36,919 --> 00:19:41,880
streams that were created if you scroll

00:19:39,720 --> 00:19:43,470
up here a little bit further we'll see

00:19:41,880 --> 00:19:45,419
that you know how many bytes were

00:19:43,470 --> 00:19:47,270
received on a particular session when it

00:19:45,419 --> 00:19:49,590
when the hansik hard to win it

00:19:47,270 --> 00:19:50,970
when it completed this is all

00:19:49,590 --> 00:19:53,630
information it's gonna be available at

00:19:50,970 --> 00:19:56,250
the JavaScript API layer just built in

00:19:53,630 --> 00:19:57,210
here so this that right now this is

00:19:56,250 --> 00:19:58,740
information that you would have to

00:19:57,210 --> 00:20:01,170
install additional modules to get in

00:19:58,740 --> 00:20:02,640
other things with a node this is all

00:20:01,170 --> 00:20:09,300
going to be built into the API and

00:20:02,640 --> 00:20:13,560
available so let's save a summary of

00:20:09,300 --> 00:20:15,120
what we learn in STP 1.1 multiple TCP +

00:20:13,560 --> 00:20:18,270
TLS connections were required for

00:20:15,120 --> 00:20:20,850
concurrent requests in ICP 2 added

00:20:18,270 --> 00:20:22,590
multiplexing in which multiple HTTP

00:20:20,850 --> 00:20:25,410
requests were sent on the same TCP

00:20:22,590 --> 00:20:27,990
connection or TCP head of line blocking

00:20:25,410 --> 00:20:30,090
in which is the one in which the entire

00:20:27,990 --> 00:20:32,840
TCP connection is brought to an halt if

00:20:30,090 --> 00:20:35,880
a single TCP packet packet is lost and

00:20:32,840 --> 00:20:38,760
STP 3 over quick treats each stream

00:20:35,880 --> 00:20:40,950
independently so that if any packet goes

00:20:38,760 --> 00:20:43,740
missing in a stream only that stream is

00:20:40,950 --> 00:20:44,070
affected that's it thank you for

00:20:43,740 --> 00:20:46,260
listening

00:20:44,070 --> 00:20:48,270
my name is Sriram common all the code

00:20:46,260 --> 00:20:51,010
which I showed is present on github and

00:20:48,270 --> 00:20:55,660
the slides available there Thanks

00:20:51,010 --> 00:20:55,660

YouTube URL: https://www.youtube.com/watch?v=5cDr5aemGws


