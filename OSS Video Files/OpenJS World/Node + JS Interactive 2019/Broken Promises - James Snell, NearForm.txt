Title: Broken Promises - James Snell, NearForm
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	Broken Promises - James Snell, NearForm
Speakers: James Snell
When a customer comes to us with a complaint that their code is running slowly, our first question has become, "Are you using Promises?". When they predictably tell us yes, our response has become, "You're likely using them wrong".

In this talk, we'll discuss the various ways Promises are abused. We'll talk about why that ends up needlessly slowing Node.js applications down. And we'll talk about how to use Promises correctly, the way they were intended to be used.

Expect code, opinions, and colorful charts.
Captions: 
	00:00:00,469 --> 00:00:04,520
all right justice everyone hear me all

00:00:02,730 --> 00:00:07,890
right how's everyone doing this morning

00:00:04,520 --> 00:00:11,580
no good all right I'm gonna go to get

00:00:07,890 --> 00:00:14,880
started I am James Snell I am head of

00:00:11,580 --> 00:00:17,850
research at near forum also a node core

00:00:14,880 --> 00:00:21,119
contributor working on quite a bit of

00:00:17,850 --> 00:00:22,410
things that didn't know right now the

00:00:21,119 --> 00:00:24,330
thing I'm working on is the quick

00:00:22,410 --> 00:00:27,359
implementation that for beacon was

00:00:24,330 --> 00:00:28,890
talking about yesterday but in your form

00:00:27,359 --> 00:00:30,900
one of the things that we do is you know

00:00:28,890 --> 00:00:32,520
we have a lot of customers that come to

00:00:30,900 --> 00:00:33,600
us and ask us so but you know saying hey

00:00:32,520 --> 00:00:35,969
our stuff is slow

00:00:33,600 --> 00:00:38,850
come help us figure out why our wire

00:00:35,969 --> 00:00:42,120
code is slow and over the past couple of

00:00:38,850 --> 00:00:44,340
years we've we've come to ask one very

00:00:42,120 --> 00:00:46,469
specific question when a customer comes

00:00:44,340 --> 00:00:48,500
to us and says hey our stuff is slow the

00:00:46,469 --> 00:00:51,059
first question is are you using promises

00:00:48,500 --> 00:00:53,370
all right and if they'd say yes all

00:00:51,059 --> 00:00:55,680
right our response right away is you're

00:00:53,370 --> 00:00:56,640
using them wrong well you know you

00:00:55,680 --> 00:00:58,680
haven't even looked at our code get

00:00:56,640 --> 00:01:01,140
there enough to you're using them wrong

00:00:58,680 --> 00:01:03,300
all right so what we have found in the

00:01:01,140 --> 00:01:06,119
overwhelming majority of cases when

00:01:03,300 --> 00:01:08,369
anybody is using promises they are it's

00:01:06,119 --> 00:01:10,920
some way it's some level using them

00:01:08,369 --> 00:01:12,750
incorrectly so that it's the inspiration

00:01:10,920 --> 00:01:15,270
of this talk is basically all the ways

00:01:12,750 --> 00:01:17,610
that we have seen customers using

00:01:15,270 --> 00:01:20,310
promises incorrectly and kind of

00:01:17,610 --> 00:01:22,350
breaking down why why it's incorrect

00:01:20,310 --> 00:01:26,759
kind of you know how to how to avoid

00:01:22,350 --> 00:01:27,869
those issues now one example they got

00:01:26,759 --> 00:01:30,119
caught up with a customer they are

00:01:27,869 --> 00:01:34,170
having some really poor response times

00:01:30,119 --> 00:01:36,210
on their API I decided to do a 30 second

00:01:34,170 --> 00:01:38,369
benchmark on one path of their code

00:01:36,210 --> 00:01:40,200
right so we're basically just sending

00:01:38,369 --> 00:01:43,140
the same request over and over and over

00:01:40,200 --> 00:01:45,990
again against their server executing a

00:01:43,140 --> 00:01:48,320
single branch a single path within that

00:01:45,990 --> 00:01:54,329
30 second benchmark they were allocating

00:01:48,320 --> 00:01:56,549
30,000 promises okay I'll explain why in

00:01:54,329 --> 00:01:57,930
just a little bit but there are a few

00:01:56,549 --> 00:01:59,600
other examples like that that I will

00:01:57,930 --> 00:02:03,119
share with you all right

00:01:59,600 --> 00:02:05,159
so promises are powerful yes they're

00:02:03,119 --> 00:02:08,069
there in a language you really have to

00:02:05,159 --> 00:02:10,649
understand how how they function and

00:02:08,069 --> 00:02:13,410
what their what their purpose is right

00:02:10,649 --> 00:02:13,890
when to use them and especially when not

00:02:13,410 --> 00:02:15,960
to use

00:02:13,890 --> 00:02:18,060
all right everything that I'm going to

00:02:15,960 --> 00:02:21,120
show you is based on what we have seen

00:02:18,060 --> 00:02:23,550
actual customers do in production code

00:02:21,120 --> 00:02:25,350
alright so you know some of the examples

00:02:23,550 --> 00:02:26,910
you know I've I've simplified the

00:02:25,350 --> 00:02:28,560
examples I'm not going to say what you

00:02:26,910 --> 00:02:30,180
know who's you know what customers and

00:02:28,560 --> 00:02:32,070
what companies are doing what right so I

00:02:30,180 --> 00:02:34,140
completely anonymous it some of the

00:02:32,070 --> 00:02:35,610
examples may look a bit contrived but

00:02:34,140 --> 00:02:39,600
they are based on stuff we've actually

00:02:35,610 --> 00:02:42,150
seen in the out of the real world but

00:02:39,600 --> 00:02:45,420
first I want to do a puzzle I've notice

00:02:42,150 --> 00:02:47,310
a few times this code prints a message

00:02:45,420 --> 00:02:48,870
it's a secret message right without

00:02:47,310 --> 00:02:51,330
writing the code try to figure out what

00:02:48,870 --> 00:02:53,700
the message is you could you know

00:02:51,330 --> 00:02:55,170
without trying to copy down here you can

00:02:53,700 --> 00:02:58,080
scan the the QR code

00:02:55,170 --> 00:03:01,830
I'll also post this on on my Twitter

00:02:58,080 --> 00:03:03,330
feed after this but you know the task is

00:03:01,830 --> 00:03:06,540
try to figure out what the messages

00:03:03,330 --> 00:03:08,430
without running all right what this code

00:03:06,540 --> 00:03:10,380
is doing is using all the various ways

00:03:08,430 --> 00:03:13,560
you can schedule a synchronous activity

00:03:10,380 --> 00:03:16,350
and note so we have next ticks we have

00:03:13,560 --> 00:03:20,040
immediate we have some promises in there

00:03:16,350 --> 00:03:22,530
key micro tasks right so this will print

00:03:20,040 --> 00:03:24,600
a message out if you figure it out

00:03:22,530 --> 00:03:28,140
again without running the code let me

00:03:24,600 --> 00:03:32,959
know alright so I'll give you a moment

00:03:28,140 --> 00:03:35,700
to folks scan the QR code there okay

00:03:32,959 --> 00:03:37,200
alright so the reason I like to start

00:03:35,700 --> 00:03:39,420
with this particular example is it

00:03:37,200 --> 00:03:43,140
because it emphasizes the fact that you

00:03:39,420 --> 00:03:45,720
really need to understand when code is

00:03:43,140 --> 00:03:49,200
being executed within within a note or

00:03:45,720 --> 00:03:51,690
then javascript in general alright so we

00:03:49,200 --> 00:03:54,840
all know node is a JavaScript platform

00:03:51,690 --> 00:04:00,570
right is JavaScript running all of the

00:03:54,840 --> 00:04:02,000
time in note all right no all right so

00:04:00,570 --> 00:04:05,640
let me show you a quick example of this

00:04:02,000 --> 00:04:08,459
so if I do a set interval right I'm

00:04:05,640 --> 00:04:10,380
going to set it for you know about a

00:04:08,459 --> 00:04:12,209
second actually let me let me change

00:04:10,380 --> 00:04:14,910
this a little bit we're gonna set it to

00:04:12,209 --> 00:04:16,950
run every 500 milliseconds we're gonna

00:04:14,910 --> 00:04:20,280
have this thing do a for loop and then

00:04:16,950 --> 00:04:23,430
do a console.log very very simple

00:04:20,280 --> 00:04:26,290
application so I'm gonna run this I'm

00:04:23,430 --> 00:04:30,500
gonna turn on trace events

00:04:26,290 --> 00:04:32,360
and we're gonna turn v8 a nation cooks

00:04:30,500 --> 00:04:33,680
this is basically give us some insight

00:04:32,360 --> 00:04:37,419
into what is happening under the covers

00:04:33,680 --> 00:04:37,419
on this and they're going to run this

00:04:37,480 --> 00:04:42,590
okay so it's just gonna iterate through

00:04:40,130 --> 00:04:45,200
five times that's going to end up

00:04:42,590 --> 00:04:50,450
creating this file this node Trace got

00:04:45,200 --> 00:04:53,180
one file let's pop back over chrome

00:04:50,450 --> 00:04:55,100
tracing is it's a utility built into a

00:04:53,180 --> 00:04:57,290
Chrome browser allows you to be a trace

00:04:55,100 --> 00:04:58,460
event log data generated by node or by

00:04:57,290 --> 00:05:00,410
the browser so let's load this thing up

00:04:58,460 --> 00:05:03,979
this file that we just created this node

00:05:00,410 --> 00:05:05,919
underscore trace might be a little bit

00:05:03,979 --> 00:05:08,389
hard to read there from the back but

00:05:05,919 --> 00:05:11,000
these pink boxes right here are the

00:05:08,389 --> 00:05:13,520
plate other times when node and v8 or

00:05:11,000 --> 00:05:15,830
actually executing JavaScript the blank

00:05:13,520 --> 00:05:18,290
spaces between or times when no

00:05:15,830 --> 00:05:20,419
JavaScript is being run that is times

00:05:18,290 --> 00:05:22,970
when the node event loop is doing other

00:05:20,419 --> 00:05:25,340
things in this case it's waiting for

00:05:22,970 --> 00:05:27,290
that event for that timer to fire right

00:05:25,340 --> 00:05:29,030
so within that time the event loop is

00:05:27,290 --> 00:05:31,130
actually spinning right

00:05:29,030 --> 00:05:34,010
but while the pink boxes are executing

00:05:31,130 --> 00:05:38,270
the event loop is not spinning the event

00:05:34,010 --> 00:05:40,690
loop is completely blocked okay now when

00:05:38,270 --> 00:05:43,729
we say schedule a synchronous activity

00:05:40,690 --> 00:05:46,240
what we're talking about is in one of

00:05:43,729 --> 00:05:48,380
the pink boxes triggering some action

00:05:46,240 --> 00:05:53,090
that is not going to complete until

00:05:48,380 --> 00:05:55,250
another pink box starts okay you know on

00:05:53,090 --> 00:05:58,160
this so basically like we want to do a

00:05:55,250 --> 00:06:01,880
file read right file reads a node happen

00:05:58,160 --> 00:06:03,889
in a in a thread pool so we trigger the

00:06:01,880 --> 00:06:05,690
file read it's gonna go off and read the

00:06:03,889 --> 00:06:08,539
file in a separate thread when that file

00:06:05,690 --> 00:06:11,300
man data is available after the event

00:06:08,539 --> 00:06:13,100
loop turns right it'll see okay that

00:06:11,300 --> 00:06:15,580
data is available now then it'll start

00:06:13,100 --> 00:06:19,490
executing JavaScript again all right

00:06:15,580 --> 00:06:22,039
with a promise you never ever want to

00:06:19,490 --> 00:06:25,460
create a promise that resolves within

00:06:22,039 --> 00:06:28,250
the same execution block that it was

00:06:25,460 --> 00:06:29,720
created if you can avoid it all right

00:06:28,250 --> 00:06:31,580
and I say you can wait if you're using

00:06:29,720 --> 00:06:34,630
like promise not resolve right that is

00:06:31,580 --> 00:06:37,159
explicitly a synchronous promise right

00:06:34,630 --> 00:06:39,110
with promises that you you know don't

00:06:37,159 --> 00:06:39,830
ever use them where they resolve in the

00:06:39,110 --> 00:06:42,290
same

00:06:39,830 --> 00:06:43,580
you want to use it to you know when you

00:06:42,290 --> 00:06:45,560
create it you're scheduling some

00:06:43,580 --> 00:06:47,990
asynchronous activity it's happening

00:06:45,560 --> 00:06:50,180
optimator vent loop and then it's going

00:06:47,990 --> 00:06:52,910
to come back and execute later on right

00:06:50,180 --> 00:06:54,440
that's key that's that's that's number

00:06:52,910 --> 00:07:00,050
one and I'll get into a little bit about

00:06:54,440 --> 00:07:01,790
why that is a little bit later okay so

00:07:00,050 --> 00:07:04,940
people do weird things with async

00:07:01,790 --> 00:07:08,420
functions and promises they pass them to

00:07:04,940 --> 00:07:10,340
functions that don't expect them so

00:07:08,420 --> 00:07:13,100
creating an immediate timer with an

00:07:10,340 --> 00:07:15,770
async function or setting a recurring

00:07:13,100 --> 00:07:27,320
timer than async function what happens

00:07:15,770 --> 00:07:32,180
in this case if this throws right what

00:07:27,320 --> 00:07:33,410
happened to that I dare yes yeah getting

00:07:32,180 --> 00:07:36,920
a support email that's it's basically

00:07:33,410 --> 00:07:39,530
what you do what ends up happening in

00:07:36,920 --> 00:07:48,200
this case is is this error catchable in

00:07:39,530 --> 00:07:50,000
any way no I mean you can do a try-catch

00:07:48,200 --> 00:07:52,100
inside this thing but then you know your

00:07:50,000 --> 00:07:53,300
error happening is limited in inside

00:07:52,100 --> 00:07:54,260
that you can't bubble it out anywhere

00:07:53,300 --> 00:07:56,150
right

00:07:54,260 --> 00:07:58,250
so with this case what you end up with

00:07:56,150 --> 00:08:00,410
is an unhandled rejection you can't

00:07:58,250 --> 00:08:03,140
actually catch any errors thrown within

00:08:00,410 --> 00:08:06,919
that async function outside of that of

00:08:03,140 --> 00:08:08,840
that function right we see this in all

00:08:06,919 --> 00:08:11,990
kinds of places so if we take a look at

00:08:08,840 --> 00:08:14,000
event you meter people love passing

00:08:11,990 --> 00:08:17,510
async functions to you know to handle

00:08:14,000 --> 00:08:18,980
events now just recently within node

00:08:17,510 --> 00:08:21,380
coral I'll show an example of this later

00:08:18,980 --> 00:08:23,210
we just had a new feature landed called

00:08:21,380 --> 00:08:28,070
capture rejections that makes event

00:08:23,210 --> 00:08:30,320
emitter aware of promises but most cases

00:08:28,070 --> 00:08:33,229
if you're talking about event emitter if

00:08:30,320 --> 00:08:36,020
you're talking about callback functions

00:08:33,229 --> 00:08:38,000
these things are not expecting promises

00:08:36,020 --> 00:08:40,310
they are not expecting async functions

00:08:38,000 --> 00:08:42,500
and they do not know how to handle them

00:08:40,310 --> 00:08:44,990
correctly and what you're going to end

00:08:42,500 --> 00:08:47,210
up with our cases where you are either

00:08:44,990 --> 00:08:49,010
you know you know at the best case you

00:08:47,210 --> 00:08:51,170
have an unhandled rejection at the worst

00:08:49,010 --> 00:08:52,230
case you have memory leaks resource

00:08:51,170 --> 00:08:54,360
leaks and

00:08:52,230 --> 00:08:56,010
this case we would be leaking a file

00:08:54,360 --> 00:08:57,090
descriptor all right that would never

00:08:56,010 --> 00:09:00,380
end up getting closed if there's an

00:08:57,090 --> 00:09:03,300
error somewhere in here you end up with

00:09:00,380 --> 00:09:04,470
asynchronous context it's not propagated

00:09:03,300 --> 00:09:06,690
properly down through all of your

00:09:04,470 --> 00:09:08,400
callbacks or all your promises all right

00:09:06,690 --> 00:09:09,780
you can end up with orphans promise

00:09:08,400 --> 00:09:11,970
chains they have you have no way of

00:09:09,780 --> 00:09:16,350
handling all right and all kinds of

00:09:11,970 --> 00:09:17,400
other kind of nastiness you know and we

00:09:16,350 --> 00:09:19,230
actually get into base with this you

00:09:17,400 --> 00:09:20,730
know you know you know Matteo Colinas

00:09:19,230 --> 00:09:23,040
gotten on Twitter and said don't mix

00:09:20,730 --> 00:09:24,510
callbacks and promises together and then

00:09:23,040 --> 00:09:26,880
we actually end up with debates on this

00:09:24,510 --> 00:09:31,250
honest ups like no it's no problem we

00:09:26,880 --> 00:09:35,430
can show specific examples here of them

00:09:31,250 --> 00:09:37,730
of memory leaks happening right me I

00:09:35,430 --> 00:09:42,060
have one in here I mean look at this

00:09:37,730 --> 00:09:44,640
okay so right here we open a file and

00:09:42,060 --> 00:09:46,530
it's just kind of the local file we read

00:09:44,640 --> 00:09:48,090
it we open two file descriptor we you

00:09:46,530 --> 00:09:50,280
know we have some error handling in

00:09:48,090 --> 00:09:51,720
there right then let's call you know a

00:09:50,280 --> 00:09:54,420
function you know you know happen to be

00:09:51,720 --> 00:09:57,750
something that you know the reference is

00:09:54,420 --> 00:09:59,460
not resolved right in this case that

00:09:57,750 --> 00:10:01,710
async function is going to throw that

00:09:59,460 --> 00:10:04,080
unhandled rejection and that FS close is

00:10:01,710 --> 00:10:06,300
never going to fire now a lot of times

00:10:04,080 --> 00:10:08,490
we'll have a you know promise or a

00:10:06,300 --> 00:10:11,160
process on unhandled rejection to do

00:10:08,490 --> 00:10:12,330
some logging all right so maybe you're

00:10:11,160 --> 00:10:15,210
you're you know you'll see a nun held

00:10:12,330 --> 00:10:17,220
rejection or an error in your logs but

00:10:15,210 --> 00:10:20,850
the actual file descriptor itself never

00:10:17,220 --> 00:10:23,160
actually gets closed we see this all of

00:10:20,850 --> 00:10:24,990
the time now it's possible to get around

00:10:23,160 --> 00:10:28,200
this you use you know a try-catch in

00:10:24,990 --> 00:10:30,480
this function use the finally in here to

00:10:28,200 --> 00:10:34,470
close it but most of the time developers

00:10:30,480 --> 00:10:36,540
completely forget to do that right this

00:10:34,470 --> 00:10:40,410
is one of the most common issues that we

00:10:36,540 --> 00:10:41,640
see all right so this is you know and

00:10:40,410 --> 00:10:44,490
these are things that are that are that

00:10:41,640 --> 00:10:47,490
are easily checked the simple rule on

00:10:44,490 --> 00:10:50,190
this don't pass an async function or

00:10:47,490 --> 00:10:53,940
promise to a callback that does not

00:10:50,190 --> 00:10:56,550
expect it period just don't do it all

00:10:53,940 --> 00:10:57,390
right now another weird one that we've

00:10:56,550 --> 00:11:01,200
been seeing lately

00:10:57,390 --> 00:11:03,500
that's just bizarre are people mixing

00:11:01,200 --> 00:11:07,040
new promise in async functions

00:11:03,500 --> 00:11:09,110
right the the the oddest one of this

00:11:07,040 --> 00:11:11,060
that I've seen recently was a wait new

00:11:09,110 --> 00:11:14,150
promise there was past an async function

00:11:11,060 --> 00:11:19,490
and then the resolved it was resolved

00:11:14,150 --> 00:11:20,660
away from me right I still don't quite

00:11:19,490 --> 00:11:24,590
know what they were trying to accomplish

00:11:20,660 --> 00:11:27,470
right it was not what they expected all

00:11:24,590 --> 00:11:30,220
right let me ask you this if I have a

00:11:27,470 --> 00:11:35,960
regular function like this a new promise

00:11:30,220 --> 00:11:38,630
and I throw in here right what's gonna

00:11:35,960 --> 00:11:42,530
happen is that going to get caught or is

00:11:38,630 --> 00:11:44,030
gonna be a thrown immediately it's

00:11:42,530 --> 00:11:45,500
immediately thrown a lot of folks say

00:11:44,030 --> 00:11:46,610
anything that's any error that somewhat

00:11:45,500 --> 00:11:49,370
thinner promise is going to get caught

00:11:46,610 --> 00:11:51,260
by the catch handler it is not right

00:11:49,370 --> 00:11:53,270
it's only caught if it happens in a you

00:11:51,260 --> 00:11:55,610
know dot then or a dot catch right you

00:11:53,270 --> 00:11:57,650
know in one of the in the chain the

00:11:55,610 --> 00:12:00,260
function that is passed to the promise

00:11:57,650 --> 00:12:03,560
itself that will throw immediately when

00:12:00,260 --> 00:12:06,460
is this function executed immediately

00:12:03,560 --> 00:12:08,480
right there is a common misconception

00:12:06,460 --> 00:12:10,370
particularly among developers that are

00:12:08,480 --> 00:12:12,620
coming from Java and.net environments

00:12:10,370 --> 00:12:16,310
that new promise is equivalent to new

00:12:12,620 --> 00:12:19,220
threat right there's you know it's it's

00:12:16,310 --> 00:12:20,750
a very common misconception I I I had to

00:12:19,220 --> 00:12:23,120
sit down and prove it for I think it was

00:12:20,750 --> 00:12:24,500
about 45 minutes go through a proof for

00:12:23,120 --> 00:12:26,420
a customer that we were at but with a

00:12:24,500 --> 00:12:29,800
developer team they were absolutely

00:12:26,420 --> 00:12:32,960
convinced that new promise was was

00:12:29,800 --> 00:12:35,390
running in parallel right just kind of

00:12:32,960 --> 00:12:37,880
magical new threats there's a huge

00:12:35,390 --> 00:12:41,270
amount of misconception out there about

00:12:37,880 --> 00:12:43,820
how this works right so this error it's

00:12:41,270 --> 00:12:47,180
going to get thrown immediately what

00:12:43,820 --> 00:12:50,920
happens if I do this okay pass the async

00:12:47,180 --> 00:12:50,920
function that and we throw that error

00:12:51,490 --> 00:12:57,160
all right again where we're going to end

00:12:54,860 --> 00:12:57,160
up with

00:13:05,750 --> 00:13:10,560
as an unhandled rejection all right now

00:13:09,389 --> 00:13:16,680
do you think the catch handler is going

00:13:10,560 --> 00:13:19,019
to catch it let's just say let's just

00:13:16,680 --> 00:13:25,139
console.log it right once a lug the

00:13:19,019 --> 00:13:28,769
message right you think that's gonna

00:13:25,139 --> 00:13:30,389
handle it there's a they're coming

00:13:28,769 --> 00:13:32,610
you know believe that yeah if you pass

00:13:30,389 --> 00:13:34,680
an eight a promise to this thing you're

00:13:32,610 --> 00:13:36,720
worth it and promises it will not catch

00:13:34,680 --> 00:13:39,209
it you got a nun that'll projection the

00:13:36,720 --> 00:13:41,160
cash handler cannot see this in any way

00:13:39,209 --> 00:13:42,480
but we are seeing this more and more and

00:13:41,160 --> 00:13:44,399
more I think we've seen this and I think

00:13:42,480 --> 00:13:46,949
three or four customer projects just

00:13:44,399 --> 00:13:49,139
over the past couple of months all right

00:13:46,949 --> 00:13:51,509
and this is based on a belief that hey

00:13:49,139 --> 00:13:56,220
async functions are great let's use them

00:13:51,509 --> 00:14:00,449
everywhere no like just just no at all

00:13:56,220 --> 00:14:02,339
all right so we have that one very

00:14:00,449 --> 00:14:04,259
important just you know you have to be

00:14:02,339 --> 00:14:07,139
very careful about where promises are

00:14:04,259 --> 00:14:09,750
actually being used you they are a very

00:14:07,139 --> 00:14:12,240
specific tool that are used only for

00:14:09,750 --> 00:14:14,240
scheduling a synchronous activity and

00:14:12,240 --> 00:14:17,430
waiting for the result of that activity

00:14:14,240 --> 00:14:18,959
right but as we'll see as we go along

00:14:17,430 --> 00:14:23,540
there's lots of other ways that people

00:14:18,959 --> 00:14:30,870
are abusing these things all right so

00:14:23,540 --> 00:14:33,300
let's move forward here all right so if

00:14:30,870 --> 00:14:38,189
we're not going to be passing an async

00:14:33,300 --> 00:14:40,500
function to a callback if we are not

00:14:38,189 --> 00:14:42,569
supposed to be mixing these things how

00:14:40,500 --> 00:14:44,130
do we actually get by it right the

00:14:42,569 --> 00:14:46,860
answer is if you're going to be using

00:14:44,130 --> 00:14:48,300
promises go all in on promises if you're

00:14:46,860 --> 00:14:50,610
going to be using callbacks just do

00:14:48,300 --> 00:14:52,620
everything callbacks right if you're

00:14:50,610 --> 00:14:53,970
going to be mixing them it's it actually

00:14:52,620 --> 00:14:55,470
gets very complicated I'll show you an

00:14:53,970 --> 00:14:56,540
example of kind of doing it right and

00:14:55,470 --> 00:14:59,880
I'll show you how complicated it gets

00:14:56,540 --> 00:15:01,199
this in this case we're fully we're

00:14:59,880 --> 00:15:02,970
using promises throughout the entire

00:15:01,199 --> 00:15:06,000
player so we're using the promise flight

00:15:02,970 --> 00:15:07,709
version of the FS module right so we

00:15:06,000 --> 00:15:11,100
have a promise I'd version of open that

00:15:07,709 --> 00:15:13,649
we can await what this what this version

00:15:11,100 --> 00:15:17,610
of open gives you is a file handle

00:15:13,649 --> 00:15:19,769
object that will automatically close if

00:15:17,610 --> 00:15:22,470
you forget to do it now it'll give you a

00:15:19,769 --> 00:15:24,930
warning but it will it will go ahead and

00:15:22,470 --> 00:15:27,720
clean up after itself if you forget to

00:15:24,930 --> 00:15:29,100
do it try to avoid that memory leak but

00:15:27,720 --> 00:15:30,929
it'll get you know it'll be noisy when

00:15:29,100 --> 00:15:32,639
it doesn't it'll say hey you should be

00:15:30,929 --> 00:15:32,999
explicitly closing this thing do that

00:15:32,639 --> 00:15:35,730
next time

00:15:32,999 --> 00:15:38,100
all right so this is a much safer way of

00:15:35,730 --> 00:15:41,569
doing this error handling is consistent

00:15:38,100 --> 00:15:44,279
throughout and we're properly

00:15:41,569 --> 00:15:47,879
propagating errors in context here

00:15:44,279 --> 00:15:51,449
alright so just as a general rule do not

00:15:47,879 --> 00:15:52,069
mix callbacks promises do one or the

00:15:51,449 --> 00:15:56,519
other

00:15:52,069 --> 00:15:59,309
all right now it is possible I guess it

00:15:56,519 --> 00:16:01,619
took inviting them becomes much more

00:15:59,309 --> 00:16:03,660
complicated alright so in this

00:16:01,619 --> 00:16:05,399
particular case I'm creating the promise

00:16:03,660 --> 00:16:07,860
I have the resolve reject I have two

00:16:05,399 --> 00:16:10,619
callbacks two nested callbacks that are

00:16:07,860 --> 00:16:12,569
happening right I'm having to propagate

00:16:10,619 --> 00:16:14,369
the reject through those different

00:16:12,569 --> 00:16:16,379
levels so this is you know if you've

00:16:14,369 --> 00:16:18,029
heard a callback he'll this is you know

00:16:16,379 --> 00:16:20,550
callback and promise he'll and it just

00:16:18,029 --> 00:16:22,620
gets even nastier right and the problem

00:16:20,550 --> 00:16:24,449
the reason this is nasty is that

00:16:22,620 --> 00:16:27,959
promises and callbacks operate on two

00:16:24,449 --> 00:16:31,949
completely different abstraction models

00:16:27,959 --> 00:16:35,160
right yes both involves scheduling async

00:16:31,949 --> 00:16:36,990
activity but how they are resolved how

00:16:35,160 --> 00:16:39,449
they you know in the execution model or

00:16:36,990 --> 00:16:41,819
are entirely different and incompatible

00:16:39,449 --> 00:16:43,170
to one another so you have to kind of

00:16:41,819 --> 00:16:45,720
bunch them together in order to get them

00:16:43,170 --> 00:16:47,610
to work now utilities like util dot

00:16:45,720 --> 00:16:50,399
promise if I which will take a callback

00:16:47,610 --> 00:16:52,439
function and wrap it it does quite a bit

00:16:50,399 --> 00:16:54,509
of work under this under the covers to

00:16:52,439 --> 00:16:56,970
make sure this is done correctly alright

00:16:54,509 --> 00:17:01,529
so make use of util promise file I have

00:16:56,970 --> 00:17:03,749
a few examples of that in here this like

00:17:01,529 --> 00:17:07,520
you can do you want a promise wide

00:17:03,749 --> 00:17:13,230
version of set timeout and you can do

00:17:07,520 --> 00:17:16,860
let's say sleep equals util promise if I

00:17:13,230 --> 00:17:19,289
set timeout right and then from there

00:17:16,860 --> 00:17:21,409
and like you know sleep actually becomes

00:17:19,289 --> 00:17:24,780
promise fine

00:17:21,409 --> 00:17:27,550
right you can do whatever right

00:17:24,780 --> 00:17:29,800
okay and that actually you know it won't

00:17:27,550 --> 00:17:31,750
block the event loop it's just a timer

00:17:29,800 --> 00:17:34,360
that's happening under the covers but

00:17:31,750 --> 00:17:38,920
it's been wrapped in a way that it does

00:17:34,360 --> 00:17:41,200
proper propagation of errors all right

00:17:38,920 --> 00:17:43,480
event emitter this was mentioned in

00:17:41,200 --> 00:17:44,380
giuseppe's talk earlier if you want to

00:17:43,480 --> 00:17:46,750
create an event you mater that

00:17:44,380 --> 00:17:49,390
understands proper error handling with

00:17:46,750 --> 00:17:57,340
with async functions you can do let's

00:17:49,390 --> 00:17:58,240
say if you pass in the capture

00:17:57,340 --> 00:18:01,030
rejections

00:17:58,240 --> 00:18:03,400
now this isn't in a in a node release

00:18:01,030 --> 00:18:04,540
yet so it's not gonna work with the

00:18:03,400 --> 00:18:07,990
version of node I'm using here because

00:18:04,540 --> 00:18:09,220
I'm using a release version but this

00:18:07,990 --> 00:18:12,100
error fight you know it won't work

00:18:09,220 --> 00:18:14,290
properly if I run example but what this

00:18:12,100 --> 00:18:17,740
will do is if you pass the basic

00:18:14,290 --> 00:18:20,710
function in if it errors it will cause a

00:18:17,740 --> 00:18:22,780
error event to be emitted properly right

00:18:20,710 --> 00:18:25,780
it won't be hidden by the the promise

00:18:22,780 --> 00:18:28,630
chain okay so there are ways to do this

00:18:25,780 --> 00:18:31,630
correctly it's just complicated and

00:18:28,630 --> 00:18:32,860
difficult and you know Matteo clean and

00:18:31,630 --> 00:18:35,350
his talk yesterday made the point that

00:18:32,860 --> 00:18:37,630
you might spend a ton of time in your

00:18:35,350 --> 00:18:38,980
code doing it correctly but I can

00:18:37,630 --> 00:18:41,830
guarantee you there's somebody on your

00:18:38,980 --> 00:18:45,730
team or another team the arrogant that

00:18:41,830 --> 00:18:47,890
will just do it wrong right so it's very

00:18:45,730 --> 00:18:49,600
difficult to do this consistently and we

00:18:47,890 --> 00:18:52,450
have seen this time and time and time

00:18:49,600 --> 00:18:54,760
again where especially with people not

00:18:52,450 --> 00:18:59,260
handling errors correctly that it just

00:18:54,760 --> 00:19:05,530
falls down okay so alright so let's move

00:18:59,260 --> 00:19:06,970
on let's see here's the venue Mitter all

00:19:05,530 --> 00:19:07,800
right so in order to do it correctly

00:19:06,970 --> 00:19:10,060
without

00:19:07,800 --> 00:19:11,650
mateos fixed by the way if you're on a

00:19:10,060 --> 00:19:13,810
version of node that's not it doesn't

00:19:11,650 --> 00:19:16,510
have to capture rejections yet you can

00:19:13,810 --> 00:19:19,540
do it but what you have to do is within

00:19:16,510 --> 00:19:22,540
a try caption your icing function you

00:19:19,540 --> 00:19:24,640
catch catch the error and then you have

00:19:22,540 --> 00:19:28,060
to make sure you omit that in a process

00:19:24,640 --> 00:19:30,090
next tick all right the reason we have

00:19:28,060 --> 00:19:34,260
to do that in a process next tick is

00:19:30,090 --> 00:19:36,940
because emit is asynchronous function

00:19:34,260 --> 00:19:37,420
when it is operating when you call it in

00:19:36,940 --> 00:19:39,010
this

00:19:37,420 --> 00:19:41,230
context from anathan an async function

00:19:39,010 --> 00:19:41,800
if error handling is bound to that

00:19:41,230 --> 00:19:44,650
promise

00:19:41,800 --> 00:19:49,060
right so if you throw it's just gonna be

00:19:44,650 --> 00:19:51,010
same part of the same cop throat right

00:19:49,060 --> 00:19:53,830
and you'll end up with a an unhandled

00:19:51,010 --> 00:19:56,320
rejection so next chick allows you to

00:19:53,830 --> 00:19:59,110
escape that all right it allows you to

00:19:56,320 --> 00:20:00,490
escape the promise right so if you want

00:19:59,110 --> 00:20:02,620
to you know if you're within that you

00:20:00,490 --> 00:20:04,600
actually absolutely want to get out of

00:20:02,620 --> 00:20:07,060
their promised error handling you can

00:20:04,600 --> 00:20:12,600
always use next stick to do so it's ugly

00:20:07,060 --> 00:20:17,100
it's nasty but it works all right okay

00:20:12,600 --> 00:20:17,100
let's move on a little bit more here

00:20:17,820 --> 00:20:24,310
okay so the other this one's fun how

00:20:22,960 --> 00:20:28,120
many of you have seen long then chains

00:20:24,310 --> 00:20:30,820
in your code right denne denne denne dot

00:20:28,120 --> 00:20:32,950
then the worst one of these that I've

00:20:30,820 --> 00:20:35,890
seen was about fifteen or sixteen of

00:20:32,950 --> 00:20:37,090
these chained you know it's in a module

00:20:35,890 --> 00:20:39,220
that's you know actually pretty

00:20:37,090 --> 00:20:42,570
popularly used we recommend now if we

00:20:39,220 --> 00:20:44,980
see it just don't just don't so use it

00:20:42,570 --> 00:20:46,810
and what we typically find when people

00:20:44,980 --> 00:20:50,110
have these long dot n chains is that

00:20:46,810 --> 00:20:54,040
they're being used or basically make the

00:20:50,110 --> 00:20:56,770
code readable okay and they're typically

00:20:54,040 --> 00:20:58,930
end up being used for flow control of

00:20:56,770 --> 00:21:01,030
synchronous code so in this particular

00:20:58,930 --> 00:21:03,070
case we see notices this one's pretty

00:21:01,030 --> 00:21:03,730
contrived but it you know again see this

00:21:03,070 --> 00:21:06,250
all the time

00:21:03,730 --> 00:21:07,720
yeah we have two upper to lower reverse

00:21:06,250 --> 00:21:09,400
we're basically just isolating

00:21:07,720 --> 00:21:10,560
functionality into individual functions

00:21:09,400 --> 00:21:14,800
and then we're gonna chain them together

00:21:10,560 --> 00:21:18,610
you know with with dense this is

00:21:14,800 --> 00:21:22,210
absolutely pointless all of this code is

00:21:18,610 --> 00:21:24,430
resolved synchronously right it's all

00:21:22,210 --> 00:21:26,050
going to be executed synchronously it's

00:21:24,430 --> 00:21:29,620
all going to be blocking the event loop

00:21:26,050 --> 00:21:31,420
in one turn right these promises are

00:21:29,620 --> 00:21:33,970
going to get resolved in the the microbe

00:21:31,420 --> 00:21:36,100
task queue that's the best part of all

00:21:33,970 --> 00:21:37,900
this that excuse to the den and catch

00:21:36,100 --> 00:21:41,020
handlers will actually be executed

00:21:37,900 --> 00:21:41,470
synchronously immediately following the

00:21:41,020 --> 00:21:42,370
execution

00:21:41,470 --> 00:21:44,500
you know the wrote resolution these

00:21:42,370 --> 00:21:47,440
promises there is no asynchronous

00:21:44,500 --> 00:21:48,820
activity happening here at all all

00:21:47,440 --> 00:21:50,230
you're doing is taking a block of code

00:21:48,820 --> 00:21:50,980
that executes right now in the event

00:21:50,230 --> 00:21:52,870
loop

00:21:50,980 --> 00:21:54,190
and weaving it okay right here in the

00:21:52,870 --> 00:21:55,720
vent loop but with a whole bunch of

00:21:54,190 --> 00:21:58,830
allocate promise allocations on top of

00:21:55,720 --> 00:22:01,929
it right do not do this

00:21:58,830 --> 00:22:04,450
don't ever wrap use a promise to wrap

00:22:01,929 --> 00:22:06,460
purely synchronous code this is probably

00:22:04,450 --> 00:22:09,820
cardinal sin number one with with

00:22:06,460 --> 00:22:13,450
promises all right but we see this all

00:22:09,820 --> 00:22:16,090
of the time and every single time it's

00:22:13,450 --> 00:22:18,070
because it makes it more readable right

00:22:16,090 --> 00:22:19,450
you might make it more readable but it's

00:22:18,070 --> 00:22:23,919
going to absolutely kill your

00:22:19,450 --> 00:22:26,530
performance we've seen this code like

00:22:23,919 --> 00:22:29,440
this we've seen it take coat down maybe

00:22:26,530 --> 00:22:30,900
60 70 percent performance toys just

00:22:29,440 --> 00:22:36,429
because they're doing this kind of stuff

00:22:30,900 --> 00:22:40,270
all right to make it even worse people

00:22:36,429 --> 00:22:45,910
will do things like make these async

00:22:40,270 --> 00:22:48,640
functions right which just causes even

00:22:45,910 --> 00:22:50,620
more out promise allocations when you

00:22:48,640 --> 00:22:54,040
await an async function do you know how

00:22:50,620 --> 00:22:56,350
many promises are created just by cut

00:22:54,040 --> 00:22:58,059
you know if you just a empty async

00:22:56,350 --> 00:23:00,640
function that does nothing else if you

00:22:58,059 --> 00:23:03,850
await that function it creates three

00:23:00,640 --> 00:23:06,370
promises every time no matter what else

00:23:03,850 --> 00:23:08,740
it's do it right every time you await an

00:23:06,370 --> 00:23:10,179
async function all right so you need to

00:23:08,740 --> 00:23:12,940
be aware of what you're actually

00:23:10,179 --> 00:23:14,370
allocating here and and for what purpose

00:23:12,940 --> 00:23:20,740
you're actually allocating those four

00:23:14,370 --> 00:23:22,240
all right so for this you know it's it's

00:23:20,740 --> 00:23:24,790
simple if you if you absolutely need

00:23:22,240 --> 00:23:26,700
that getdata to return a promise right

00:23:24,790 --> 00:23:30,700
go ahead and resolve the promise

00:23:26,700 --> 00:23:32,290
synchronously right and use promise that

00:23:30,700 --> 00:23:34,510
resolved that's what it's there for

00:23:32,290 --> 00:23:36,549
that's the intent run your code

00:23:34,510 --> 00:23:38,080
synchronously and save yourself the

00:23:36,549 --> 00:23:41,230
trouble of all those additional promise

00:23:38,080 --> 00:23:42,820
allocations all right there is no other

00:23:41,230 --> 00:23:45,549
there's no other correct way of doing

00:23:42,820 --> 00:23:47,980
this right do not wrap sync purely

00:23:45,549 --> 00:23:51,070
synchronous code and a promise in a

00:23:47,980 --> 00:23:52,570
promise chain of dense the only place

00:23:51,070 --> 00:23:56,080
you should have purely synchronous code

00:23:52,570 --> 00:24:00,990
is in the final then handler that is the

00:23:56,080 --> 00:24:03,120
only place all right all right

00:24:00,990 --> 00:24:07,559
let's keep going

00:24:03,120 --> 00:24:09,990
loop's oh these are fun passing an async

00:24:07,559 --> 00:24:13,680
function to a functional loop like for

00:24:09,990 --> 00:24:14,640
each or map or filter all right the

00:24:13,680 --> 00:24:16,410
example I told you at the beginning

00:24:14,640 --> 00:24:18,510
where the people were creating 30,000

00:24:16,410 --> 00:24:22,490
promises this is how they were doing it

00:24:18,510 --> 00:24:25,110
they were parsing a 1 Meg JSON file

00:24:22,490 --> 00:24:27,990
iterating synchronously over every field

00:24:25,110 --> 00:24:30,420
in that file creating a promise for

00:24:27,990 --> 00:24:32,840
every field not just a promise a promise

00:24:30,420 --> 00:24:35,160
change for every field right and

00:24:32,840 --> 00:24:39,690
majority of those promise chains for we

00:24:35,160 --> 00:24:41,370
resolved synchronously so json.parse is

00:24:39,690 --> 00:24:42,990
synchronous code iterating through the

00:24:41,370 --> 00:24:46,830
synchronous loop allocating thousands of

00:24:42,990 --> 00:24:49,700
promises in a you know synchronously and

00:24:46,830 --> 00:24:52,260
then resolving them all synchronously

00:24:49,700 --> 00:24:55,470
now let's see if you know why this is a

00:24:52,260 --> 00:24:58,350
bad thing let me show you so we're gonna

00:24:55,470 --> 00:25:07,890
go ahead and run no to get your run note

00:24:58,350 --> 00:25:10,790
again with our trace events and then

00:25:07,890 --> 00:25:10,790
this one is

00:25:15,019 --> 00:25:18,570
all right so we're gonna let this run

00:25:17,100 --> 00:25:20,970
for a bit and all this code is doing

00:25:18,570 --> 00:25:22,289
taking you know setting a series of

00:25:20,970 --> 00:25:24,239
numbers and then inverting the values

00:25:22,289 --> 00:25:26,519
right we've got about a thousand of them

00:25:24,239 --> 00:25:30,360
in there all right so it's going to

00:25:26,519 --> 00:25:31,590
create that trace event file again so

00:25:30,360 --> 00:25:35,119
how many promises do you think were

00:25:31,590 --> 00:25:40,350
created during that bring that operation

00:25:35,119 --> 00:25:46,109
let's see no let's see why didn't that

00:25:40,350 --> 00:25:54,029
go all right hold on a second yeah make

00:25:46,109 --> 00:25:57,690
sure my okay all right so how many are

00:25:54,029 --> 00:25:59,669
created during that during that loop why

00:25:57,690 --> 00:26:00,149
is it this not coming up with all the

00:25:59,669 --> 00:26:01,769
information

00:26:00,149 --> 00:26:07,369
I think I'm specifying something wrong

00:26:01,769 --> 00:26:07,369
here oh no nobody some folks

00:26:10,190 --> 00:26:14,389
so that how many promises do we think

00:26:12,679 --> 00:26:18,950
you said like you know five actually

00:26:14,389 --> 00:26:20,330
there's about eight thousand and we can

00:26:18,950 --> 00:26:26,179
see that here every single one of these

00:26:20,330 --> 00:26:27,740
lines is a promise several promises so

00:26:26,179 --> 00:26:30,200
these are all being created in a

00:26:27,740 --> 00:26:32,120
synchronous loop right we really the the

00:26:30,200 --> 00:26:34,669
the iteration was a thousand iterations

00:26:32,120 --> 00:26:36,200
right so we have about eight thousand

00:26:34,669 --> 00:26:37,639
promises that were created over that

00:26:36,200 --> 00:26:40,519
synchronous iteration now how do we know

00:26:37,639 --> 00:26:42,259
it was all synchronous let's go all the

00:26:40,519 --> 00:26:44,840
way down here at the bottom and we see

00:26:42,259 --> 00:26:47,240
this v8 execute block right so this is a

00:26:44,840 --> 00:26:49,279
synchronous code if we go back to the

00:26:47,240 --> 00:26:50,539
trace event log every single one of

00:26:49,279 --> 00:26:52,580
those promises was allocated

00:26:50,539 --> 00:26:56,539
synchronously within the exact same

00:26:52,580 --> 00:26:59,629
block right now in these particular

00:26:56,539 --> 00:27:01,220
promises we do have a timer right so it

00:26:59,629 --> 00:27:03,289
is they are scheduling a synchronous

00:27:01,220 --> 00:27:06,230
activity but we're still allocating all

00:27:03,289 --> 00:27:08,570
those promises all at once and there's

00:27:06,230 --> 00:27:10,399
code running in those sync let's go

00:27:08,570 --> 00:27:13,129
running in each of those that is causing

00:27:10,399 --> 00:27:14,690
this massive event loop block so during

00:27:13,129 --> 00:27:18,230
this time that event loop can't do

00:27:14,690 --> 00:27:21,889
anything else right we have one example

00:27:18,230 --> 00:27:23,570
of a customer they were received was

00:27:21,889 --> 00:27:26,960
receiving a whopping four requests per

00:27:23,570 --> 00:27:30,409
second all right what was it doing

00:27:26,960 --> 00:27:32,629
they were parsing very complex graph QL

00:27:30,409 --> 00:27:35,929
queries that on the back end were

00:27:32,629 --> 00:27:39,470
talking about ten or fifteen back-end

00:27:35,929 --> 00:27:41,179
services right the way the graph QL

00:27:39,470 --> 00:27:43,580
implementation in Apollo works it's very

00:27:41,179 --> 00:27:45,169
promise heavy uses these long promise

00:27:43,580 --> 00:27:47,299
chains it goes off and parses the query

00:27:45,169 --> 00:27:48,559
locks the query figure you know figures

00:27:47,299 --> 00:27:50,659
out an execution plan for the query

00:27:48,559 --> 00:27:53,539
right and then it kind of goes through

00:27:50,659 --> 00:27:56,269
and and executes the backend queries and

00:27:53,539 --> 00:27:57,710
then reassembles the data right well

00:27:56,269 --> 00:28:00,769
they were receiving a large number of

00:27:57,710 --> 00:28:01,549
timeout errors as they were there is

00:28:00,769 --> 00:28:03,019
they're winning this thing and that's

00:28:01,549 --> 00:28:05,210
actually why then what was killing their

00:28:03,019 --> 00:28:06,620
their their throughput what was

00:28:05,210 --> 00:28:08,750
happening is the backend services

00:28:06,620 --> 00:28:12,889
services were receiving their queries

00:28:08,750 --> 00:28:15,080
and they were returning data back right

00:28:12,889 --> 00:28:18,230
now the way that the event event loop

00:28:15,080 --> 00:28:21,080
works when there's data that's been

00:28:18,230 --> 00:28:22,060
returned it sits in a queue until the

00:28:21,080 --> 00:28:24,370
event loop turn

00:28:22,060 --> 00:28:25,660
and it can say hey there's data

00:28:24,370 --> 00:28:27,100
available I'm gonna go ahead and fire

00:28:25,660 --> 00:28:34,000
off the callbacks associated with those

00:28:27,100 --> 00:28:36,100
right but timeout timers fire first so

00:28:34,000 --> 00:28:37,360
okay so the event loop was being blocked

00:28:36,100 --> 00:28:39,370
long enough it was sending the request

00:28:37,360 --> 00:28:41,890
the backend servers were returning the

00:28:39,370 --> 00:28:44,770
data but by the time the event loop

00:28:41,890 --> 00:28:48,190
turned over its a took too long so even

00:28:44,770 --> 00:28:50,110
though the data is sitting there the the

00:28:48,190 --> 00:28:52,270
system would crash and they were only

00:28:50,110 --> 00:28:54,730
getting four requests per second through

00:28:52,270 --> 00:28:58,630
and their solution to that was to throw

00:28:54,730 --> 00:29:04,240
a thousand more servers in it I mean

00:28:58,630 --> 00:29:05,500
okay that works I guess but whenever

00:29:04,240 --> 00:29:08,500
you're creating promises in a

00:29:05,500 --> 00:29:11,200
synchronous loop just don't or keep your

00:29:08,500 --> 00:29:12,610
iterations very very small right there's

00:29:11,200 --> 00:29:14,470
an old rule you know don't create a

00:29:12,610 --> 00:29:16,870
closure all right limit the number of

00:29:14,470 --> 00:29:18,460
allocations are doing in a loop the same

00:29:16,870 --> 00:29:20,260
thing here every time you create a

00:29:18,460 --> 00:29:22,480
promise right you're allocating

00:29:20,260 --> 00:29:24,690
something on the heap all right so we

00:29:22,480 --> 00:29:27,280
just created 8,000 objects on the heat

00:29:24,690 --> 00:29:28,570
right and a synchronous if it's just not

00:29:27,280 --> 00:29:29,560
something you want to do you have to be

00:29:28,570 --> 00:29:33,010
aware of what's happening when you're

00:29:29,560 --> 00:29:35,410
creating these promises all right so

00:29:33,010 --> 00:29:38,020
another interesting this this one just

00:29:35,410 --> 00:29:40,090
qualifies under I I don't have any idea

00:29:38,020 --> 00:29:44,020
what they're doing or why right return

00:29:40,090 --> 00:29:46,930
await new promise async resolve pretty

00:29:44,020 --> 00:29:48,340
soft first awake this is this was based

00:29:46,930 --> 00:29:50,410
on a real customer example we got like

00:29:48,340 --> 00:29:52,990
two weeks ago right now what they're

00:29:50,410 --> 00:29:57,190
doing here is assembling an object over

00:29:52,990 --> 00:29:58,270
time right and these leave a wait are

00:29:57,190 --> 00:30:01,540
actually going off in doing database

00:29:58,270 --> 00:30:04,300
queries right and what they want to do

00:30:01,540 --> 00:30:05,860
is if one of them dies they don't want

00:30:04,300 --> 00:30:06,730
to continue right so they're not they

00:30:05,860 --> 00:30:07,990
don't want to go off and execute all

00:30:06,730 --> 00:30:08,650
these things in parallel they do want to

00:30:07,990 --> 00:30:10,870
do them one at a time

00:30:08,650 --> 00:30:13,330
so they figured let's spread it out this

00:30:10,870 --> 00:30:15,010
way where they came up with this return

00:30:13,330 --> 00:30:17,830
await new promise they saying I have no

00:30:15,010 --> 00:30:19,150
idea there should be a lint rule against

00:30:17,830 --> 00:30:21,810
this and it should just reach out and

00:30:19,150 --> 00:30:23,950
slap you every time you do it all right

00:30:21,810 --> 00:30:27,400
so what's the correct way of doing this

00:30:23,950 --> 00:30:31,680
on this there's a couple of ways let's

00:30:27,400 --> 00:30:31,680
take a look at wand

00:30:32,500 --> 00:30:44,660
like uh uh well that's that's um we're

00:30:35,510 --> 00:30:46,220
doing it in parallel all right no okay

00:30:44,660 --> 00:30:47,720
so if we really wanted to wait on it

00:30:46,220 --> 00:30:50,180
right and do these things you know the

00:30:47,720 --> 00:30:53,870
way that they said we just you know get

00:30:50,180 --> 00:30:55,700
this right it's much more readable it

00:30:53,870 --> 00:30:57,980
actually makes sense you're not using

00:30:55,700 --> 00:31:01,120
strange you know syntax that you know

00:30:57,980 --> 00:31:03,200
should get you slapped and it just works

00:31:01,120 --> 00:31:04,910
now in this case you're still waiting to

00:31:03,200 --> 00:31:06,890
600 milliseconds for everything to

00:31:04,910 --> 00:31:08,840
complete right you're still waiting for

00:31:06,890 --> 00:31:11,960
a one to finish first and if it fails

00:31:08,840 --> 00:31:14,270
then you'll stop right if you wanted to

00:31:11,960 --> 00:31:16,430
do it if you really did want to do it in

00:31:14,270 --> 00:31:18,620
parallel then you could use promise all

00:31:16,430 --> 00:31:23,840
and goes off and execute these things

00:31:18,620 --> 00:31:25,540
all right quick comment on pro song that

00:31:23,840 --> 00:31:28,040
I'm coming up to you know you know

00:31:25,540 --> 00:31:29,990
running out of time here

00:31:28,040 --> 00:31:34,100
promise all wait through you know

00:31:29,990 --> 00:31:36,280
everything to to finish right behind uh

00:31:34,100 --> 00:31:39,650
it'll short circuit at the first

00:31:36,280 --> 00:31:42,340
rejection right what happens to the

00:31:39,650 --> 00:31:46,190
other promises if one of those rejects

00:31:42,340 --> 00:31:48,920
what happens to the other promises they

00:31:46,190 --> 00:31:50,900
continue a lot of folks don't know that

00:31:48,920 --> 00:31:52,700
all right

00:31:50,900 --> 00:31:55,910
especially bad when they use when you

00:31:52,700 --> 00:31:58,550
use promise race all right promise race

00:31:55,910 --> 00:32:00,470
is the first one you know the one that

00:31:58,550 --> 00:32:01,640
finishes first is the winner what

00:32:00,470 --> 00:32:04,700
happens if the other one is taking a

00:32:01,640 --> 00:32:07,400
very long time to finish it still goes

00:32:04,700 --> 00:32:09,560
and still blocks your event loop right

00:32:07,400 --> 00:32:12,320
so you're using promise race actually

00:32:09,560 --> 00:32:13,880
doesn't actually buy you very much there

00:32:12,320 --> 00:32:16,990
are use cases for it in the browser a

00:32:13,880 --> 00:32:22,900
node is just gonna kill your performance

00:32:16,990 --> 00:32:25,700
all right so let me see yeah that's

00:32:22,900 --> 00:32:28,160
essentially it I can go back here to the

00:32:25,700 --> 00:32:30,530
slides we have some basic rules to

00:32:28,160 --> 00:32:35,180
follow know when your code is being

00:32:30,530 --> 00:32:38,300
executed right use trace events if you

00:32:35,180 --> 00:32:41,000
use the - trace event categories you

00:32:38,300 --> 00:32:42,950
know and turn on the v8 category you

00:32:41,000 --> 00:32:46,280
will see exactly when javascript is

00:32:42,950 --> 00:32:48,320
running right you will know when when it

00:32:46,280 --> 00:32:50,750
you'll know when it's not running all

00:32:48,320 --> 00:32:52,730
right you want to make sure that you if

00:32:50,750 --> 00:32:56,060
you are you making use of promises that

00:32:52,730 --> 00:32:57,320
you are spanning those barriers your you

00:32:56,060 --> 00:32:59,840
know your promises should not be

00:32:57,320 --> 00:33:04,430
resolving within the same event you know

00:32:59,840 --> 00:33:06,140
this the the same v8 execution right if

00:33:04,430 --> 00:33:08,510
they are go back and figure out what's

00:33:06,140 --> 00:33:09,620
wrong or don't use a promise they're all

00:33:08,510 --> 00:33:12,320
right

00:33:09,620 --> 00:33:14,660
don't use unexpected promises just don't

00:33:12,320 --> 00:33:17,330
right if a function does not if you do

00:33:14,660 --> 00:33:19,880
not know that it is designed to take an

00:33:17,330 --> 00:33:24,170
async function do not pass an async

00:33:19,880 --> 00:33:26,030
function you know again avoid mixing

00:33:24,170 --> 00:33:30,170
promises and callbacks use one or the

00:33:26,030 --> 00:33:33,260
other all right don't create promises

00:33:30,170 --> 00:33:35,480
and loops again synchronous promises are

00:33:33,260 --> 00:33:38,420
just useless and do not use long been

00:33:35,480 --> 00:33:41,750
chains just avoid it as much as you

00:33:38,420 --> 00:33:42,850
possibly can all right so that's it

00:33:41,750 --> 00:33:50,660
thank

00:33:42,850 --> 00:33:50,660

YouTube URL: https://www.youtube.com/watch?v=DwEYBegpj_Q


