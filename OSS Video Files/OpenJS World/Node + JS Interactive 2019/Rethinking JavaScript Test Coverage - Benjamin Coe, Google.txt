Title: Rethinking JavaScript Test Coverage - Benjamin Coe, Google
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	Rethinking JavaScript Test Coverage - Benjamin Coe, Google
Speakers: Benjamin Coe
In 2017 the V8 engine introduced built-in code coverage; the ability, during runtime, to track the executed lines, branches, functions, etc., of a program. This information is useful for: analyzing bottlenecks, finding unused code, and finding parts of a codebase that need more tests.

Realizing how valuable native coverage could be to the community, Ben made it a mission to expose this functionality in Node.js.

In JavaScript coverage had traditionally been facilitated by a clever hack; tools, like Istanbul, parse the code inserting no-op counters... While this parsing-based approach works, it has shortcomings: as the language evolves, parsers play catch up; counters decrease performance; counters sometimes break applications.

Implementing native coverage in Node.js, was an amazing opportunity for V8, Node.js, and the npm community to work together, and is an exciting success story.
Captions: 
	00:00:00,030 --> 00:00:04,110
so thanks for joining today I know it's

00:00:02,460 --> 00:00:07,010
day two so I'm sure a lot of folks wrote

00:00:04,110 --> 00:00:09,660
having dinner late last night like us

00:00:07,010 --> 00:00:11,190
I'm gonna be talking today about code

00:00:09,660 --> 00:00:13,049
coverage which is a topic I'm really

00:00:11,190 --> 00:00:14,910
passionate about and specifically I'm

00:00:13,049 --> 00:00:16,740
going to be talking about code coverage

00:00:14,910 --> 00:00:19,590
as it relates to the node.js project

00:00:16,740 --> 00:00:22,260
itself which is something I've worked on

00:00:19,590 --> 00:00:25,230
quite a bit on the project my name is

00:00:22,260 --> 00:00:26,760
Benjamin Co I'm a dpe at Google which is

00:00:25,230 --> 00:00:28,619
stands for a developer programs engineer

00:00:26,760 --> 00:00:30,990
this is basically what you get if you

00:00:28,619 --> 00:00:33,690
smash together a developer evangelist

00:00:30,990 --> 00:00:35,370
with a an engineer you get to do some

00:00:33,690 --> 00:00:36,540
talking like this which is really fun

00:00:35,370 --> 00:00:39,120
but you also spend a lot of time

00:00:36,540 --> 00:00:42,390
engineering which I enjoy so good for

00:00:39,120 --> 00:00:45,480
folks who enjoy both things a little bit

00:00:42,390 --> 00:00:47,670
more detail about me I was the third

00:00:45,480 --> 00:00:49,860
employee at NPM incorporated so I've

00:00:47,670 --> 00:00:52,530
been involved in the node.js and NPM

00:00:49,860 --> 00:00:55,020
community for quite a few years I

00:00:52,530 --> 00:00:56,550
currently work on node.js client

00:00:55,020 --> 00:00:58,649
libraries at Google's so this is a

00:00:56,550 --> 00:01:01,199
really neat role where basically my team

00:00:58,649 --> 00:01:04,140
works with teams within Google mostly on

00:01:01,199 --> 00:01:06,869
Google cloud to help them make node.js

00:01:04,140 --> 00:01:08,520
client libraries that are idiomatic to

00:01:06,869 --> 00:01:10,229
the community feel like a normal NPM

00:01:08,520 --> 00:01:11,670
package even though not all the teams at

00:01:10,229 --> 00:01:14,130
Google necessarily are part of the

00:01:11,670 --> 00:01:16,799
node.js community I in the world of

00:01:14,130 --> 00:01:17,790
open-source I contribute yukti yards

00:01:16,799 --> 00:01:20,610
which I've been working on for quite a

00:01:17,790 --> 00:01:21,930
few years I wrote the tool NYC which

00:01:20,610 --> 00:01:23,070
I'll be talking about in this

00:01:21,930 --> 00:01:25,470
presentation which is a tool for

00:01:23,070 --> 00:01:27,210
collecting code coverage and I

00:01:25,470 --> 00:01:28,740
contribute to node.js

00:01:27,210 --> 00:01:30,270
actually I've done a lot of work on

00:01:28,740 --> 00:01:32,369
coverage and node.js so that's why I'm

00:01:30,270 --> 00:01:34,229
talking about it today another thing I

00:01:32,369 --> 00:01:36,390
really like is I edit this specification

00:01:34,229 --> 00:01:39,450
called conventional commits org which is

00:01:36,390 --> 00:01:41,280
a way to add conventional kind of

00:01:39,450 --> 00:01:42,899
structure to your commit messages so

00:01:41,280 --> 00:01:45,810
that you can parse them and automate

00:01:42,899 --> 00:01:46,530
them I'm Canadian naturally but I live

00:01:45,810 --> 00:01:50,460
in California

00:01:46,530 --> 00:01:51,570
no one's perfect and today so to give

00:01:50,460 --> 00:01:52,979
you a bit more detail about what I'm

00:01:51,570 --> 00:01:55,170
gonna be talking about today I'm going

00:01:52,979 --> 00:01:56,430
to talk about what exactly code coverage

00:01:55,170 --> 00:01:57,869
is and give you a little bit of a

00:01:56,430 --> 00:01:59,399
history of code coverage which is I

00:01:57,869 --> 00:02:00,899
started researching this talk it was

00:01:59,399 --> 00:02:03,030
surprisingly interesting the history of

00:02:00,899 --> 00:02:04,350
code coverage I'm gonna talk about what

00:02:03,030 --> 00:02:05,670
it's useful for so why you should want

00:02:04,350 --> 00:02:07,380
to use it on your projects and how we

00:02:05,670 --> 00:02:10,530
use it on the node.js project ourselves

00:02:07,380 --> 00:02:11,970
and how it benefits the project I'm

00:02:10,530 --> 00:02:13,319
gonna for folks who are curious like me

00:02:11,970 --> 00:02:13,740
I'm going to go into details about how

00:02:13,319 --> 00:02:15,060
it actually

00:02:13,740 --> 00:02:17,640
works behind the scenes like what's

00:02:15,060 --> 00:02:18,750
actually happening and I'm going to talk

00:02:17,640 --> 00:02:20,220
about how you can both use it on your

00:02:18,750 --> 00:02:21,930
own projects if you don't currently use

00:02:20,220 --> 00:02:24,090
code coverage is one of the tools for

00:02:21,930 --> 00:02:26,220
for your open source projects I'm going

00:02:24,090 --> 00:02:27,720
to talk about how you can use node.js as

00:02:26,220 --> 00:02:29,280
own coverage as a way to start

00:02:27,720 --> 00:02:30,840
contributing to the node.js project I'm

00:02:29,280 --> 00:02:35,190
going to show you what our coverage

00:02:30,840 --> 00:02:37,290
looks like so what is code coverage I

00:02:35,190 --> 00:02:39,330
mean the simplest explanation PRIZE to

00:02:37,290 --> 00:02:41,190
say it's a way of tracking the execution

00:02:39,330 --> 00:02:44,490
of branches in your programs so if you

00:02:41,190 --> 00:02:45,870
have an if an an else statement you can

00:02:44,490 --> 00:02:48,300
run your program of coverage and it will

00:02:45,870 --> 00:02:50,160
keep track of whether the if was run say

00:02:48,300 --> 00:02:52,350
three times and the else was run four

00:02:50,160 --> 00:02:55,590
times so it gives you nice analytics

00:02:52,350 --> 00:02:57,870
about how how your program executed

00:02:55,590 --> 00:03:00,450
during its run time as you probably

00:02:57,870 --> 00:03:02,100
guessed code coverage was invented in a

00:03:00,450 --> 00:03:04,230
top-secret Army Biological Laboratory

00:03:02,100 --> 00:03:05,640
this is a joke

00:03:04,230 --> 00:03:08,820
you probably didn't guess that but

00:03:05,640 --> 00:03:10,800
that's true it was proposed in a paper

00:03:08,820 --> 00:03:13,650
called a method for systematic error

00:03:10,800 --> 00:03:17,280
analysis of digital computer programs by

00:03:13,650 --> 00:03:19,980
Jones C Miller in 1962 Declassified in

00:03:17,280 --> 00:03:22,160
1971 and what's kind of interesting

00:03:19,980 --> 00:03:25,050
about this is I was reading the paper

00:03:22,160 --> 00:03:26,370
she's actually proposing an approach to

00:03:25,050 --> 00:03:27,720
using coverage that's really similar to

00:03:26,370 --> 00:03:29,370
what a lot of people think of when they

00:03:27,720 --> 00:03:31,110
think of coverage today which is using

00:03:29,370 --> 00:03:32,670
it to better expand the test suite that

00:03:31,110 --> 00:03:36,120
they were using inside that lab which i

00:03:32,670 --> 00:03:37,620
think is really neat what the paper

00:03:36,120 --> 00:03:40,380
suggests basically is that you take a

00:03:37,620 --> 00:03:42,120
program you create a graph of the

00:03:40,380 --> 00:03:43,980
different paths through that program and

00:03:42,120 --> 00:03:47,250
you enumerate the exit conditions of

00:03:43,980 --> 00:03:49,890
that program and then you use this chart

00:03:47,250 --> 00:03:51,030
you've made to create some more tests to

00:03:49,890 --> 00:03:53,010
help make sure you've covered that

00:03:51,030 --> 00:03:55,500
entire programs exit conditions and

00:03:53,010 --> 00:03:56,610
branches through that program kind of

00:03:55,500 --> 00:03:58,050
interesting that I thought that this

00:03:56,610 --> 00:03:59,370
paper doesn't talk about automating it

00:03:58,050 --> 00:04:01,170
and mostly talks about how one would

00:03:59,370 --> 00:04:03,720
kind of draw this out yourself and I was

00:04:01,170 --> 00:04:05,040
thinking if you think about 1962 there's

00:04:03,720 --> 00:04:06,750
a good chance maybe even the program was

00:04:05,040 --> 00:04:07,920
punch cards so like that you can't use a

00:04:06,750 --> 00:04:09,480
lot of the methodologies I'm going to

00:04:07,920 --> 00:04:10,620
talk about in this talk on punch cards

00:04:09,480 --> 00:04:12,780
actually I think would be harder to do

00:04:10,620 --> 00:04:15,690
so and kind of see why someone took the

00:04:12,780 --> 00:04:19,609
approach of doing it externally on piece

00:04:15,690 --> 00:04:21,660
of paper so what's happened since 1962

00:04:19,609 --> 00:04:23,460
well I was kind of doing a little bit

00:04:21,660 --> 00:04:25,700
more of a literature review it turns out

00:04:23,460 --> 00:04:27,650
iBM has a patent from 1918

00:04:25,700 --> 00:04:29,390
which is called a system for determining

00:04:27,650 --> 00:04:31,310
the code coverage of tested programs

00:04:29,390 --> 00:04:34,160
based upon static and dynamic analysis

00:04:31,310 --> 00:04:36,230
of recordings this is the first kind of

00:04:34,160 --> 00:04:37,850
reference I saw to taking that 1962

00:04:36,230 --> 00:04:43,490
paper and starting to automate the

00:04:37,850 --> 00:04:46,190
process interestingly then by 1996 this

00:04:43,490 --> 00:04:50,720
tool Jakob came out which is part of the

00:04:46,190 --> 00:04:53,570
GCC C suite and it allows you to collect

00:04:50,720 --> 00:04:55,460
coverage in your C code and it has a lot

00:04:53,570 --> 00:04:57,110
of the features were used to today so it

00:04:55,460 --> 00:04:58,280
has branch coverage line coverage it

00:04:57,110 --> 00:05:00,410
gives you pretty reports out the other

00:04:58,280 --> 00:05:01,880
end and luckily they weren't sued by IBM

00:05:00,410 --> 00:05:05,180
because I had no clue IBM held this

00:05:01,880 --> 00:05:06,620
patent which luckily ran out in 2006 so

00:05:05,180 --> 00:05:10,060
the tools I've worked on I don't think

00:05:06,620 --> 00:05:15,080
are infringing on this patent right now

00:05:10,060 --> 00:05:17,420
the same year 1996 Java 1.1 also was

00:05:15,080 --> 00:05:19,070
released with coverage so this has been

00:05:17,420 --> 00:05:22,040
a tool in the Java and the C communities

00:05:19,070 --> 00:05:24,140
for quite a few years jumping to the

00:05:22,040 --> 00:05:26,720
node.js community we were actually a

00:05:24,140 --> 00:05:28,910
little late to the game I was talking to

00:05:26,720 --> 00:05:30,200
so so our first kind of real popular

00:05:28,910 --> 00:05:32,060
tool for collecting coverage was called

00:05:30,200 --> 00:05:35,930
Yui coverage and was part of the Yui

00:05:32,060 --> 00:05:37,490
tool suite this apparently did not come

00:05:35,930 --> 00:05:39,800
out until a Suprema came out so if this

00:05:37,490 --> 00:05:40,670
prima is a parser for JavaScript that

00:05:39,800 --> 00:05:42,830
allows you to kind of do your own

00:05:40,670 --> 00:05:44,930
parsing and this is actually what

00:05:42,830 --> 00:05:47,510
enabled a lot of these JavaScript based

00:05:44,930 --> 00:05:49,400
coverage the collectors part of this

00:05:47,510 --> 00:05:51,230
people would actually transpile down to

00:05:49,400 --> 00:05:53,200
Java and then use something like Jacob

00:05:51,230 --> 00:05:55,220
to collect coverage for JavaScript

00:05:53,200 --> 00:05:57,170
what's interesting about why you covered

00:05:55,220 --> 00:05:59,090
Yui coverage is it actually kind of as a

00:05:57,170 --> 00:06:00,860
direct lineage to Istanbul which is a

00:05:59,090 --> 00:06:02,900
popular coverage tool used in the node

00:06:00,860 --> 00:06:05,630
community which in turn is what's used

00:06:02,900 --> 00:06:07,760
by Jess so this Yui coverage too will

00:06:05,630 --> 00:06:10,640
actually inspired a lot of the tools for

00:06:07,760 --> 00:06:12,140
coverage that exists today including NYC

00:06:10,640 --> 00:06:13,940
which is something I wrote while I was

00:06:12,140 --> 00:06:15,650
working at MPM with actually Ryan who's

00:06:13,940 --> 00:06:18,410
in the audience here and we brought this

00:06:15,650 --> 00:06:21,380
at NPM to collect coverage specifically

00:06:18,410 --> 00:06:23,030
for the NPM client which spawned lots of

00:06:21,380 --> 00:06:24,460
sub processes which a lot of tools

00:06:23,030 --> 00:06:27,140
didn't exist for doing that at the time

00:06:24,460 --> 00:06:28,940
NYC also uses Istanbul so most of these

00:06:27,140 --> 00:06:32,830
coverage tools actually kind of follow

00:06:28,940 --> 00:06:36,230
from the same set of tools until 2017

00:06:32,830 --> 00:06:38,330
when v8 actually introduced coverage

00:06:36,230 --> 00:06:39,700
into the v8 JavaScript engine itself

00:06:38,330 --> 00:06:42,520
which is the JavaScript engine

00:06:39,700 --> 00:06:43,780
used by nodejs I'm gonna talk about this

00:06:42,520 --> 00:06:44,800
in detail in this talk so I'm not gonna

00:06:43,780 --> 00:06:47,020
dive into it here

00:06:44,800 --> 00:06:48,580
around the same time twenty seven twenty

00:06:47,020 --> 00:06:50,830
eighteen I began working with some folks

00:06:48,580 --> 00:06:52,390
on the node.js team to expose this

00:06:50,830 --> 00:06:54,760
functionality and nodejs so that we

00:06:52,390 --> 00:06:56,140
could in the node.js project itself also

00:06:54,760 --> 00:06:59,710
take advantage of the fact that we had

00:06:56,140 --> 00:07:02,500
coverage built into the v8 engine so

00:06:59,710 --> 00:07:04,480
unlike that manually drawn chart I

00:07:02,500 --> 00:07:06,100
showed earlier in the talk this is

00:07:04,480 --> 00:07:08,050
closer to what you might think of as a

00:07:06,100 --> 00:07:09,670
coverage report today it's a nice kind

00:07:08,050 --> 00:07:12,700
of human readable shows you the code

00:07:09,670 --> 00:07:14,230
that ran and just to explain it we

00:07:12,700 --> 00:07:16,180
basically see the code that wasn't run

00:07:14,230 --> 00:07:19,210
by my test suite or by some run of my

00:07:16,180 --> 00:07:21,970
processes in read the code that is in

00:07:19,210 --> 00:07:24,130
yellow is a branch that wasn't executed

00:07:21,970 --> 00:07:25,480
so this line might have run but the but

00:07:24,130 --> 00:07:28,000
one of the branches on the line did it

00:07:25,480 --> 00:07:29,260
execute what's interesting about this is

00:07:28,000 --> 00:07:30,330
it shows that problem in the node

00:07:29,260 --> 00:07:32,350
codebase which I'll talk about later

00:07:30,330 --> 00:07:34,450
which is that we historically collected

00:07:32,350 --> 00:07:36,250
coverage for Linux but not for Windows

00:07:34,450 --> 00:07:38,680
so a lot of the time we'd have these

00:07:36,250 --> 00:07:40,870
false negatives which were related to

00:07:38,680 --> 00:07:42,670
our Windows coverage the other

00:07:40,870 --> 00:07:43,860
interesting thing about this report it's

00:07:42,670 --> 00:07:45,550
not just showing you what lines

00:07:43,860 --> 00:07:47,590
recovered it's showing you how many

00:07:45,550 --> 00:07:48,640
times they were executed and so this is

00:07:47,590 --> 00:07:49,630
kind of interesting you can actually

00:07:48,640 --> 00:07:53,530
start to think about it as a way of

00:07:49,630 --> 00:07:55,900
tracking performance analysis so this is

00:07:53,530 --> 00:07:58,050
great this is kind of a little bit of a

00:07:55,900 --> 00:08:01,450
history of coverage what exactly it is

00:07:58,050 --> 00:08:03,760
but what is it actually useful for I'm

00:08:01,450 --> 00:08:05,710
gonna start by showing a little video

00:08:03,760 --> 00:08:07,000
here that kind of shows what a lot of

00:08:05,710 --> 00:08:08,680
people think of when they think of test

00:08:07,000 --> 00:08:10,480
coverage and what's kind of interesting

00:08:08,680 --> 00:08:12,820
about this too is it's also really close

00:08:10,480 --> 00:08:15,700
to the approach that was being proposed

00:08:12,820 --> 00:08:18,280
by that 1962 paper I showed at the start

00:08:15,700 --> 00:08:20,140
of the talk and this is using coverage

00:08:18,280 --> 00:08:23,980
as a way to better expand your test

00:08:20,140 --> 00:08:25,990
suite so imagine you have a program you

00:08:23,980 --> 00:08:28,540
can add NYC to your program to actually

00:08:25,990 --> 00:08:31,630
run your test suite with the coverage

00:08:28,540 --> 00:08:33,010
being collected so then when we run our

00:08:31,630 --> 00:08:36,729
tests we actually see that we've only

00:08:33,010 --> 00:08:38,530
hit 50% of the lines of code here we can

00:08:36,729 --> 00:08:41,650
then go back add an additional test

00:08:38,530 --> 00:08:43,990
suite go back and run our program and

00:08:41,650 --> 00:08:45,370
see if we've actually exercised the

00:08:43,990 --> 00:08:48,280
lines of code we are trying to exercise

00:08:45,370 --> 00:08:49,870
and sure enough we've hit 100% test

00:08:48,280 --> 00:08:51,730
coverage now so it so gives us this nice

00:08:49,870 --> 00:08:52,529
feedback loop as we're trying to expand

00:08:51,730 --> 00:08:54,060
our program

00:08:52,529 --> 00:08:55,680
and make sure that we've hit all the

00:08:54,060 --> 00:08:57,810
lines of code that we that we want to

00:08:55,680 --> 00:09:01,680
hit with our testing this is just one

00:08:57,810 --> 00:09:03,480
use case another use case I really like

00:09:01,680 --> 00:09:06,959
is that if you have a long lived open

00:09:03,480 --> 00:09:08,490
source project like yards or nodejs if

00:09:06,959 --> 00:09:11,370
you can get your codebase close to 100%

00:09:08,490 --> 00:09:12,839
coverage it's easier to identify whether

00:09:11,370 --> 00:09:15,930
a contribution to the project has been

00:09:12,839 --> 00:09:17,370
appropriately tested so imagine that I'm

00:09:15,930 --> 00:09:18,689
working on an open source project and I

00:09:17,370 --> 00:09:20,999
get a pull request that looks something

00:09:18,689 --> 00:09:25,439
like this one of the first things that

00:09:20,999 --> 00:09:29,249
jumps out at me is that there's no no

00:09:25,439 --> 00:09:30,300
new tests added in this PR so even

00:09:29,249 --> 00:09:31,649
though they'd look to be maybe some

00:09:30,300 --> 00:09:33,149
problems with this meaning of life

00:09:31,649 --> 00:09:34,649
method like it looks like it might throw

00:09:33,149 --> 00:09:37,379
an exception because it's calling a

00:09:34,649 --> 00:09:39,149
method on a number that doesn't exist my

00:09:37,379 --> 00:09:41,189
existing test suite is actually going to

00:09:39,149 --> 00:09:42,870
pass this is because it's completely new

00:09:41,189 --> 00:09:44,550
functionality it has no tests written

00:09:42,870 --> 00:09:46,170
for it there is no way for tests to

00:09:44,550 --> 00:09:48,569
really fail and tell me that that code

00:09:46,170 --> 00:09:50,610
had some issues with it but if we start

00:09:48,569 --> 00:09:52,800
to actually enforce a certain coverage

00:09:50,610 --> 00:09:54,959
threshold on our code base we do see a

00:09:52,800 --> 00:09:56,339
big red X that says that this new code

00:09:54,959 --> 00:09:58,709
has dropped our coverage threshold

00:09:56,339 --> 00:10:00,480
threshold a little bit and we can use it

00:09:58,709 --> 00:10:02,519
as a way of kind of keeping a certain

00:10:00,480 --> 00:10:04,500
level of coverage inside of an open

00:10:02,519 --> 00:10:06,720
source project and in an automated

00:10:04,500 --> 00:10:11,339
manner help encourage folks to write

00:10:06,720 --> 00:10:12,839
more tests as they submit PRS another

00:10:11,339 --> 00:10:13,980
interesting thing that coverage is good

00:10:12,839 --> 00:10:15,540
for in a project though and I've seen

00:10:13,980 --> 00:10:18,509
this used in the node.js project quite a

00:10:15,540 --> 00:10:19,829
bit is it can give you an entry it can

00:10:18,509 --> 00:10:22,410
give someone an idea of where they can

00:10:19,829 --> 00:10:25,139
contribute to the project so on nodejs

00:10:22,410 --> 00:10:26,879
for the node.js project we actually

00:10:25,139 --> 00:10:30,660
published nightly coverage reports to

00:10:26,879 --> 00:10:33,089
node.js org and these reports which look

00:10:30,660 --> 00:10:34,680
something like this can actually be a

00:10:33,089 --> 00:10:37,649
really good place for someone to start

00:10:34,680 --> 00:10:39,269
contributing to the project so this is

00:10:37,649 --> 00:10:41,879
an actual snapshot of a night of

00:10:39,269 --> 00:10:43,949
coverage and what you can actually see

00:10:41,879 --> 00:10:45,149
here is you can see that you know our

00:10:43,949 --> 00:10:47,279
coverage is pretty good tool across a

00:10:45,149 --> 00:10:48,899
lot of the codebase but what will happen

00:10:47,279 --> 00:10:51,959
a lot of the time is when a new features

00:10:48,899 --> 00:10:53,639
added so in this case we can see rim raf

00:10:51,959 --> 00:10:55,949
actually has quite a bit lower coverage

00:10:53,639 --> 00:10:57,899
than other parts of the codebase so if

00:10:55,949 --> 00:11:00,209
someone looking to come in contribute to

00:10:57,899 --> 00:11:02,220
the node.js project I would read happily

00:11:00,209 --> 00:11:04,439
accept patches for more coverage on rim

00:11:02,220 --> 00:11:05,740
Raph I don't know if a lot of people

00:11:04,439 --> 00:11:08,130
even knew we have Reimer alpha node

00:11:05,740 --> 00:11:11,050
so kind of a call-out to that feature -

00:11:08,130 --> 00:11:14,230
this is a way to rim wrap is a way to

00:11:11,050 --> 00:11:16,210
delete a directory recursively instead

00:11:14,230 --> 00:11:18,370
of just a single file and directory but

00:11:16,210 --> 00:11:20,110
great place to start contributing to the

00:11:18,370 --> 00:11:20,650
project looking at these coverage

00:11:20,110 --> 00:11:22,690
reports

00:11:20,650 --> 00:11:24,100
I found a natural example from earlier

00:11:22,690 --> 00:11:26,710
in the week and I thought this was a

00:11:24,100 --> 00:11:28,750
really good kind of canonical one this

00:11:26,710 --> 00:11:31,120
is an individual coming in they've

00:11:28,750 --> 00:11:32,740
written a few tests for our DNS

00:11:31,120 --> 00:11:35,230
functionality inside the node.js code

00:11:32,740 --> 00:11:36,760
base and they actually referenced those

00:11:35,230 --> 00:11:38,560
nightly coverage reports as a way of

00:11:36,760 --> 00:11:40,810
saying look I've written these tests and

00:11:38,560 --> 00:11:43,690
I'm specifically trying to target these

00:11:40,810 --> 00:11:44,740
these lines in the coverage report and

00:11:43,690 --> 00:11:46,360
we were very excited to get this pull

00:11:44,740 --> 00:11:48,490
request and it got three approvals

00:11:46,360 --> 00:11:52,090
really quickly so great way to start

00:11:48,490 --> 00:11:53,650
contributing to the project but I would

00:11:52,090 --> 00:11:55,480
like to point out too that code coverage

00:11:53,650 --> 00:11:56,830
is not just about testing there's other

00:11:55,480 --> 00:11:59,740
interesting approaches you can use it

00:11:56,830 --> 00:12:01,150
for one such approach is that you can

00:11:59,740 --> 00:12:03,190
use it to say what parts of my program

00:12:01,150 --> 00:12:05,470
should I think about optimizing more so

00:12:03,190 --> 00:12:08,500
this is again from the full test suite

00:12:05,470 --> 00:12:10,050
run of the node.js project we can see

00:12:08,500 --> 00:12:13,390
that a few of the lines of code are hit

00:12:10,050 --> 00:12:15,850
22,000 times during that test run a few

00:12:13,390 --> 00:12:17,170
of the lines of code or hit twice if I

00:12:15,850 --> 00:12:19,000
was coming in and saying I need to

00:12:17,170 --> 00:12:21,070
optimize this method and make it run a

00:12:19,000 --> 00:12:22,900
little faster I'd probably want to put

00:12:21,070 --> 00:12:24,510
more work in optimising read package

00:12:22,900 --> 00:12:27,970
scope which gets executed

00:12:24,510 --> 00:12:30,550
22300 times then I'd want to put into

00:12:27,970 --> 00:12:32,350
optimizing err require ESM which only

00:12:30,550 --> 00:12:34,990
gets called two times in kind of an

00:12:32,350 --> 00:12:37,420
exceptional case so not perfect this is

00:12:34,990 --> 00:12:39,130
only telling you what the execution

00:12:37,420 --> 00:12:41,890
count is of stuff you actually exercise

00:12:39,130 --> 00:12:43,000
and test but kind of a neat indicator of

00:12:41,890 --> 00:12:44,530
some of the really hot points in your

00:12:43,000 --> 00:12:45,310
programs so it can be a good place to

00:12:44,530 --> 00:12:49,330
start when you're thinking about

00:12:45,310 --> 00:12:52,510
optimization so we have a little bit of

00:12:49,330 --> 00:12:53,590
the history of code coverage we've

00:12:52,510 --> 00:12:55,720
talked a little bit about some of the

00:12:53,590 --> 00:12:57,100
things I think it's useful for I now for

00:12:55,720 --> 00:12:58,090
the kind of folks who are curious like

00:12:57,100 --> 00:13:00,220
me and like to know how things actually

00:12:58,090 --> 00:13:02,740
work I want to talk a bit about how

00:13:00,220 --> 00:13:05,230
coverage actually does work there's two

00:13:02,740 --> 00:13:06,640
main approaches that I can think of for

00:13:05,230 --> 00:13:09,280
collecting coverage in the JavaScript

00:13:06,640 --> 00:13:12,160
world there's the compiled based

00:13:09,280 --> 00:13:14,200
approach where you take a program you

00:13:12,160 --> 00:13:16,420
transpile it with something like babel

00:13:14,200 --> 00:13:17,920
or ASP Rima and you add a bunch of

00:13:16,420 --> 00:13:19,150
counters in that hopefully don't change

00:13:17,920 --> 00:13:21,370
the behavior of the program

00:13:19,150 --> 00:13:23,860
the other interesting approach is

00:13:21,370 --> 00:13:25,810
there's the VM level where you're not

00:13:23,860 --> 00:13:28,240
actually changing the initial JavaScript

00:13:25,810 --> 00:13:29,740
itself the virtual machine that's

00:13:28,240 --> 00:13:30,820
running your JavaScript at the end of

00:13:29,740 --> 00:13:34,089
the days adding some additional

00:13:30,820 --> 00:13:35,529
instruction codes that collect counters

00:13:34,089 --> 00:13:38,470
as your program runs so I'm going to

00:13:35,529 --> 00:13:40,720
talk about both of those approaches so

00:13:38,470 --> 00:13:41,350
let's take this really simple program

00:13:40,720 --> 00:13:43,540
here

00:13:41,350 --> 00:13:45,430
it's an if statement with an else

00:13:43,540 --> 00:13:46,779
statement in it and it doesn't look like

00:13:45,430 --> 00:13:49,390
that outstation it's probably going to

00:13:46,779 --> 00:13:52,210
run but all this programs going to do is

00:13:49,390 --> 00:13:54,279
it's going to run hello world in that if

00:13:52,210 --> 00:13:56,320
block so imagine that we wanted to

00:13:54,279 --> 00:13:59,170
instrument this for coverage how might

00:13:56,320 --> 00:14:01,000
we do that well what we basically do and

00:13:59,170 --> 00:14:02,430
this is what's happening today just trim

00:14:01,000 --> 00:14:06,310
down a little bit

00:14:02,430 --> 00:14:09,400
something like Istanbul or NYC takes

00:14:06,310 --> 00:14:10,930
your program it rewrites it and it adds

00:14:09,400 --> 00:14:13,570
all these counters in throughout your

00:14:10,930 --> 00:14:16,150
entire program so it if we take a look

00:14:13,570 --> 00:14:18,640
at the true block here if true we see

00:14:16,150 --> 00:14:20,440
that we're incrementing branch to 0 and

00:14:18,640 --> 00:14:22,450
statement 0 if we happen to go through

00:14:20,440 --> 00:14:25,000
there we're then doing the same console

00:14:22,450 --> 00:14:27,160
out info we did before if we were to go

00:14:25,000 --> 00:14:28,750
into that else block somehow we then

00:14:27,160 --> 00:14:31,360
increment the branch and that else block

00:14:28,750 --> 00:14:33,250
and if we went into the ternary operator

00:14:31,360 --> 00:14:35,560
we'd also be incrementing branches and

00:14:33,250 --> 00:14:37,839
and statements inside of that ternary

00:14:35,560 --> 00:14:39,700
operator at the end of the program's

00:14:37,839 --> 00:14:40,959
execution we can then dump that report

00:14:39,700 --> 00:14:43,209
we've been collecting the entire time

00:14:40,959 --> 00:14:45,810
and that's how coverage is traditionally

00:14:43,209 --> 00:14:47,410
worked in the JavaScript world I

00:14:45,810 --> 00:14:49,630
obviously you don't want to do this

00:14:47,410 --> 00:14:51,670
manually so there are tools available

00:14:49,630 --> 00:14:54,040
that do this for you one I like is

00:14:51,670 --> 00:14:58,000
called NYC you can just type NPM

00:14:54,040 --> 00:14:59,920
I NYC save def and then run your program

00:14:58,000 --> 00:15:01,750
the same way you'd run it with the node

00:14:59,920 --> 00:15:03,670
bin usually you just put NYC in front of

00:15:01,750 --> 00:15:05,380
it and what it's actually doing behind

00:15:03,670 --> 00:15:06,970
the scenes is it's capturing your

00:15:05,380 --> 00:15:08,920
programs runtime looking at when you

00:15:06,970 --> 00:15:11,740
require files doing a bunch of other

00:15:08,920 --> 00:15:13,150
interesting things but ultimately it's

00:15:11,740 --> 00:15:14,650
just taking your program rewriting your

00:15:13,150 --> 00:15:16,570
thousands of lines of code and putting

00:15:14,650 --> 00:15:18,580
these counters in all over the place and

00:15:16,570 --> 00:15:21,910
hopefully not breaking your program

00:15:18,580 --> 00:15:23,230
while it does that so now I see is a

00:15:21,910 --> 00:15:26,290
tool that automatically does this for

00:15:23,230 --> 00:15:28,570
you the other approach one can take is

00:15:26,290 --> 00:15:31,630
they can use the virtual machine to

00:15:28,570 --> 00:15:32,980
collect coverage for them I'm not going

00:15:31,630 --> 00:15:34,660
to go into a ton of D

00:15:32,980 --> 00:15:37,420
tale about how v8 spiked code works

00:15:34,660 --> 00:15:40,269
frankly I'm not an expert on it but I do

00:15:37,420 --> 00:15:41,260
link to two blog posts that I think are

00:15:40,269 --> 00:15:43,089
worth reading on what's actually

00:15:41,260 --> 00:15:45,940
technically working behind the scenes

00:15:43,089 --> 00:15:49,050
these are understanding v8 spike code by

00:15:45,940 --> 00:15:51,639
my colleague Francisca Hinkleman and

00:15:49,050 --> 00:15:53,949
JavaScript code coverage by Jakob Gruber

00:15:51,639 --> 00:15:55,449
I did put my slides up just before this

00:15:53,949 --> 00:15:56,829
talk so you can think they should

00:15:55,449 --> 00:15:58,899
actually be links you can click to if

00:15:56,829 --> 00:16:00,850
you do want to read these papers but

00:15:58,899 --> 00:16:03,040
basically what's happening is when

00:16:00,850 --> 00:16:06,250
you're running JavaScript your

00:16:03,040 --> 00:16:08,350
JavaScript code gets turned into a tree

00:16:06,250 --> 00:16:10,240
that tree gets turned into bytecode

00:16:08,350 --> 00:16:12,660
which runs through a virtual machine

00:16:10,240 --> 00:16:15,459
much like when you're running java code

00:16:12,660 --> 00:16:17,709
these counters are actually added in at

00:16:15,459 --> 00:16:19,300
that virtual machine kind of bytecode

00:16:17,709 --> 00:16:21,430
level rather than at that source code

00:16:19,300 --> 00:16:23,639
level when you're using the v8 based

00:16:21,430 --> 00:16:25,930
approach there's some advantages to this

00:16:23,639 --> 00:16:28,240
there are there's no instrumentation

00:16:25,930 --> 00:16:31,690
step necessary so in the case of the

00:16:28,240 --> 00:16:34,839
node.js project actually my my colleague

00:16:31,690 --> 00:16:36,370
Anna set this up originally what we used

00:16:34,839 --> 00:16:39,000
to have to do was we would take all the

00:16:36,370 --> 00:16:42,010
JavaScript inside the node.js project

00:16:39,000 --> 00:16:44,110
transpile it with these counters compile

00:16:42,010 --> 00:16:45,910
it into the node executable then you

00:16:44,110 --> 00:16:47,769
could do one to one run of test coverage

00:16:45,910 --> 00:16:49,000
to see what your coverage was like if

00:16:47,769 --> 00:16:50,139
you hadn't actually written the test

00:16:49,000 --> 00:16:53,100
that hit the line of code you were

00:16:50,139 --> 00:16:56,410
hoping you hit you had to untransformed

00:16:53,100 --> 00:16:58,029
just your code ree transpile it rebuild

00:16:56,410 --> 00:16:59,319
the node executable and then maybe

00:16:58,029 --> 00:17:02,199
you've hit a few more lines of coverage

00:16:59,319 --> 00:17:03,760
and this created a feedback loop that

00:17:02,199 --> 00:17:06,970
was really slow on the node project for

00:17:03,760 --> 00:17:08,140
our coverage so it's nice to be able to

00:17:06,970 --> 00:17:10,120
what's nice now is we don't do this

00:17:08,140 --> 00:17:11,559
translation step we can just run the

00:17:10,120 --> 00:17:13,689
node project like we would normally with

00:17:11,559 --> 00:17:16,540
coverage enabled and use this for our

00:17:13,689 --> 00:17:18,130
coverage collection furthermore it was

00:17:16,540 --> 00:17:19,870
significantly faster for the node.js

00:17:18,130 --> 00:17:22,240
project it ran I'd say three or four

00:17:19,870 --> 00:17:23,829
times as fast using it in the v8 based

00:17:22,240 --> 00:17:26,439
approach rather than transpiling all the

00:17:23,829 --> 00:17:28,569
code I put a little asterisks here

00:17:26,439 --> 00:17:30,250
because NYC is pretty fast because it

00:17:28,569 --> 00:17:32,679
aggressively caches it's a really mature

00:17:30,250 --> 00:17:34,960
project so you know it's not always

00:17:32,679 --> 00:17:37,360
gonna be the case that using the v8

00:17:34,960 --> 00:17:38,950
based approach is faster for you I do

00:17:37,360 --> 00:17:41,200
feel however it's less error-prone

00:17:38,950 --> 00:17:44,530
so as I said the way that coverage has

00:17:41,200 --> 00:17:46,330
worked with Istanbul or NYC or a lot of

00:17:44,530 --> 00:17:46,820
these tools is it takes your big

00:17:46,330 --> 00:17:48,799
computer

00:17:46,820 --> 00:17:50,659
program tries to make a new computer

00:17:48,799 --> 00:17:52,730
program that just has thousands of

00:17:50,659 --> 00:17:54,289
counters thrown into it there's been a

00:17:52,730 --> 00:17:55,519
variety of bugs throughout the years of

00:17:54,289 --> 00:17:56,720
working on Istanbul that we just put a

00:17:55,519 --> 00:17:59,929
counter in the wrong place and now your

00:17:56,720 --> 00:18:00,980
program behaves differently it's hard to

00:17:59,929 --> 00:18:02,990
get it perfect all the time we're

00:18:00,980 --> 00:18:05,480
shockingly we get few bug reports but

00:18:02,990 --> 00:18:07,100
it's from years of debugging weird edge

00:18:05,480 --> 00:18:08,659
cases around adding these counters into

00:18:07,100 --> 00:18:10,840
your programs and it's harder than one

00:18:08,659 --> 00:18:10,840
might think

00:18:11,350 --> 00:18:14,929
enabling this coverage in the VM it's

00:18:13,399 --> 00:18:17,539
really easy we have actually built it

00:18:14,929 --> 00:18:19,669
into node.js itself so if you take the

00:18:17,539 --> 00:18:21,950
latest version of node node 14 off

00:18:19,669 --> 00:18:24,080
github or node 13 and you set this

00:18:21,950 --> 00:18:26,029
environment variable node underscore v8

00:18:24,080 --> 00:18:27,830
underscore coverage and you give it an

00:18:26,029 --> 00:18:29,419
output folder and then you run your

00:18:27,830 --> 00:18:31,759
program as you would usually run your

00:18:29,419 --> 00:18:34,070
program you will actually end up getting

00:18:31,759 --> 00:18:35,779
a bunch of inspector coverage

00:18:34,070 --> 00:18:37,820
information out to that output folder so

00:18:35,779 --> 00:18:39,740
it's built in you'll just end these just

00:18:37,820 --> 00:18:43,039
raw JSON files get output that tell you

00:18:39,740 --> 00:18:44,539
what's been executed these JSON files

00:18:43,039 --> 00:18:47,570
are hard to consume they don't give you

00:18:44,539 --> 00:18:51,529
a pretty visual report I've written a

00:18:47,570 --> 00:18:54,679
tool linked here called c8 it literally

00:18:51,529 --> 00:18:58,250
just turns on this variable at the top

00:18:54,679 --> 00:18:59,629
here and having turned that variable on

00:18:58,250 --> 00:19:03,320
gives you pretty reports at the other

00:18:59,629 --> 00:19:05,980
side and lets you you know see something

00:19:03,320 --> 00:19:08,750
more human readable from those reports

00:19:05,980 --> 00:19:10,700
so we've kind of given you a bit of a

00:19:08,750 --> 00:19:13,970
history we've talked about how coverage

00:19:10,700 --> 00:19:15,799
works to a certain degree so why do I

00:19:13,970 --> 00:19:17,029
like coverage or like why do I like

00:19:15,799 --> 00:19:18,980
using it so much why is it something

00:19:17,029 --> 00:19:21,529
I've taken the time to contribute to the

00:19:18,980 --> 00:19:23,330
node.js project well for one it helps me

00:19:21,529 --> 00:19:24,830
find parts of my code bases that could

00:19:23,330 --> 00:19:26,179
be could use more testing and I mean

00:19:24,830 --> 00:19:28,700
even you can be the best engineer in the

00:19:26,179 --> 00:19:30,320
world you're not perfect and I

00:19:28,700 --> 00:19:31,820
definitely find the parts of my codebase

00:19:30,320 --> 00:19:33,769
that I haven't read and test for are

00:19:31,820 --> 00:19:35,299
always broken in every imaginable way I

00:19:33,769 --> 00:19:37,159
think I'm working with numbers they're

00:19:35,299 --> 00:19:40,970
actually strings just everything's wrong

00:19:37,159 --> 00:19:42,500
with it I find that using coverage to

00:19:40,970 --> 00:19:44,000
find those untested parts my program

00:19:42,500 --> 00:19:47,360
just helps me write more stable

00:19:44,000 --> 00:19:48,860
applications it also helps me have more

00:19:47,360 --> 00:19:50,840
trusting contributions being made to my

00:19:48,860 --> 00:19:52,279
projects though so so for a project like

00:19:50,840 --> 00:19:53,450
yards I've actually taken the time to

00:19:52,279 --> 00:19:55,970
gradually get it up to a hundred percent

00:19:53,450 --> 00:19:57,529
coverage over the years helps me know

00:19:55,970 --> 00:19:59,120
that those new features coming in are

00:19:57,529 --> 00:20:00,620
keeping that same baseline level of

00:19:59,120 --> 00:20:04,460
we've at least demonstrated every

00:20:00,620 --> 00:20:06,050
new feature added runs as as claimed it

00:20:04,460 --> 00:20:07,130
doesn't make your program perfect 100%

00:20:06,050 --> 00:20:09,260
test coverage is not a hundred percent

00:20:07,130 --> 00:20:11,059
bug-free code but it's a better

00:20:09,260 --> 00:20:13,550
indicator than just you know throwing

00:20:11,059 --> 00:20:15,050
code out in the wild with no testing um

00:20:13,550 --> 00:20:16,910
the other really cool thing though

00:20:15,050 --> 00:20:18,680
and I love this for the node.js project

00:20:16,910 --> 00:20:21,950
is it helps folks find ways to

00:20:18,680 --> 00:20:22,970
contribute to the project and I'm going

00:20:21,950 --> 00:20:25,580
to link to it again at the end of this

00:20:22,970 --> 00:20:26,870
talk but this coverage node.js org site

00:20:25,580 --> 00:20:30,260
really cool way to find places to

00:20:26,870 --> 00:20:31,640
contribute so hopefully I've also

00:20:30,260 --> 00:20:34,820
started to get you a little bit excited

00:20:31,640 --> 00:20:36,260
about coverage and nodejs so you're

00:20:34,820 --> 00:20:38,600
probably asking how can I actually set

00:20:36,260 --> 00:20:40,010
sail on this coverage train well there's

00:20:38,600 --> 00:20:41,330
a couple tools available that I've

00:20:40,010 --> 00:20:42,920
already referenced a few times in this

00:20:41,330 --> 00:20:44,830
talk but if you haven't taken a picture

00:20:42,920 --> 00:20:48,440
or written them down yet do so now

00:20:44,830 --> 00:20:51,710
there's this tool called NYC it can be

00:20:48,440 --> 00:20:53,059
found at Istanbul Jay s slash NYC and it

00:20:51,710 --> 00:20:54,679
does that approach that I was talking

00:20:53,059 --> 00:20:56,090
about where it takes your code rewrites

00:20:54,679 --> 00:20:59,330
it with counters automatically

00:20:56,090 --> 00:21:02,809
completely invisible to you and can then

00:20:59,330 --> 00:21:03,800
use that to collect coverage what's kind

00:21:02,809 --> 00:21:05,690
of neat about this instrumentation

00:21:03,800 --> 00:21:07,040
approach is once you've rewritten your

00:21:05,690 --> 00:21:08,179
code with those counters you can run it

00:21:07,040 --> 00:21:09,440
anywhere you can read it in a web

00:21:08,179 --> 00:21:11,210
browser you can run it on your server

00:21:09,440 --> 00:21:14,300
you can run it in a light bulb if you're

00:21:11,210 --> 00:21:17,510
doing Internet of Things stuff so it's

00:21:14,300 --> 00:21:19,340
neat it's very portable once you've done

00:21:17,510 --> 00:21:20,600
so though you can just run your program

00:21:19,340 --> 00:21:22,490
like you would usually run your program

00:21:20,600 --> 00:21:23,840
with this NYC bin in front of it and it

00:21:22,490 --> 00:21:26,540
just magically gives you this coverage

00:21:23,840 --> 00:21:28,490
information the other tool that I don't

00:21:26,540 --> 00:21:30,860
think too many folks know about yet we

00:21:28,490 --> 00:21:32,270
use this on the node project itself and

00:21:30,860 --> 00:21:35,390
I use it for a lot of my open source

00:21:32,270 --> 00:21:37,429
right now is this tool called Beco slash

00:21:35,390 --> 00:21:40,520
c8 I'll probably move it into the

00:21:37,429 --> 00:21:42,740
Istanbul org eventually yeah and all it

00:21:40,520 --> 00:21:44,780
does literally is turn on v8 s-- it

00:21:42,740 --> 00:21:47,420
turns on no GS is coverage collection

00:21:44,780 --> 00:21:49,190
environment variable gives you the exact

00:21:47,420 --> 00:21:51,290
same pretty reports as NYC it literally

00:21:49,190 --> 00:21:53,690
uses the same part of NYC use code base

00:21:51,290 --> 00:21:56,000
that does the reporting and instead of

00:21:53,690 --> 00:21:58,550
typing NYC my program you actually get

00:21:56,000 --> 00:21:59,690
to save a character and just type c8 my

00:21:58,550 --> 00:22:03,650
program so it's actually even more

00:21:59,690 --> 00:22:04,580
efficient in that regard if you really

00:22:03,650 --> 00:22:05,960
wanted if you want to write your own

00:22:04,580 --> 00:22:07,550
reports or you're curious about what's

00:22:05,960 --> 00:22:09,620
actually happening behind the scenes you

00:22:07,550 --> 00:22:10,880
can just set the environment variable

00:22:09,620 --> 00:22:13,220
like I said earlier give it an output

00:22:10,880 --> 00:22:14,419
folder and then run your program and

00:22:13,220 --> 00:22:16,399
this will just work with

00:22:14,419 --> 00:22:18,529
versions of Note today and this is

00:22:16,399 --> 00:22:20,570
actually what we do we just run with

00:22:18,529 --> 00:22:22,369
this environment variable and then you

00:22:20,570 --> 00:22:23,840
see 8 to make reports at the other end

00:22:22,369 --> 00:22:26,749
so see it can just take that raw output

00:22:23,840 --> 00:22:31,190
give you reports so we use the bottom

00:22:26,749 --> 00:22:32,600
approach for node um so now kind of

00:22:31,190 --> 00:22:36,529
getting back to that topic of using

00:22:32,600 --> 00:22:40,460
coverage to contribute to node J s this

00:22:36,529 --> 00:22:41,690
is a snapshot of coverage node.js org an

00:22:40,460 --> 00:22:43,489
exciting thing I've been working on

00:22:41,690 --> 00:22:44,840
recently with rich who I see sitting in

00:22:43,489 --> 00:22:48,019
the corner there I'm gonna call him out

00:22:44,840 --> 00:22:49,999
is we now have this nightly code cover

00:22:48,019 --> 00:22:52,850
apart we put up and what's neat about

00:22:49,999 --> 00:22:55,009
this is this actually takes the combined

00:22:52,850 --> 00:22:57,139
coverage of our windows and our Linux

00:22:55,009 --> 00:22:59,509
test builds so that if you go to this

00:22:57,139 --> 00:23:01,580
top report you're less likely to get

00:22:59,509 --> 00:23:02,629
these false negatives where it looks

00:23:01,580 --> 00:23:04,460
like we haven't covered any of the

00:23:02,629 --> 00:23:05,929
windows code but actually we did cover

00:23:04,460 --> 00:23:07,879
that in Windows tests just not in our

00:23:05,929 --> 00:23:10,249
Linux tests so if you're thinking about

00:23:07,879 --> 00:23:11,989
contributing to the project I would

00:23:10,249 --> 00:23:15,080
start by looking at the coverage reports

00:23:11,989 --> 00:23:17,269
in this combined report what we also

00:23:15,080 --> 00:23:19,730
have is a nightly Linux branch coverage

00:23:17,269 --> 00:23:22,669
report this is just more detailed report

00:23:19,730 --> 00:23:24,970
that gives you a lot more specifics

00:23:22,669 --> 00:23:27,739
about the branches that have executed

00:23:24,970 --> 00:23:29,749
execution counts you see the left in the

00:23:27,739 --> 00:23:32,869
rate of a ternary operator so a little

00:23:29,749 --> 00:23:34,789
bit more detailed we also have our c++

00:23:32,869 --> 00:23:36,980
coverage reports which are linked to

00:23:34,789 --> 00:23:38,869
here kind of a throwback to the history

00:23:36,980 --> 00:23:40,779
of coverage these actually do use G

00:23:38,869 --> 00:23:44,149
curve so it hasn't changed much since

00:23:40,779 --> 00:23:47,840
1996 except we use a tool called G cover

00:23:44,149 --> 00:23:49,009
which I believe gives a nicer nicer

00:23:47,840 --> 00:23:50,539
record out the other end and makes it

00:23:49,009 --> 00:23:56,690
easier to instrument your code base with

00:23:50,539 --> 00:23:58,639
it so there's that so if you do want to

00:23:56,690 --> 00:24:00,289
contribute to the node.js project and

00:23:58,639 --> 00:24:02,330
you do want to like look at these

00:24:00,289 --> 00:24:04,309
coverage reports and maybe increase rim

00:24:02,330 --> 00:24:04,999
rafts coverage the heads very much

00:24:04,309 --> 00:24:08,389
appreciate that

00:24:04,999 --> 00:24:12,489
feel free to flag me on github you can

00:24:08,389 --> 00:24:15,470
find me at github comm slash Beco and

00:24:12,489 --> 00:24:17,330
also I'm always open to talking to folks

00:24:15,470 --> 00:24:19,309
on Twitter so you can go to twitter.com

00:24:17,330 --> 00:24:21,259
slash Benjamin Coe always happy to

00:24:19,309 --> 00:24:23,239
answer questions just talk with people

00:24:21,259 --> 00:24:25,970
I'll also be here for the rest of the

00:24:23,239 --> 00:24:27,559
day so if you prefer in real life I will

00:24:25,970 --> 00:24:29,990
be on the stage for the next few

00:24:27,559 --> 00:24:31,879
it's I don't know no I don't think I've

00:24:29,990 --> 00:24:35,840
was too too fast so I'll be here for

00:24:31,879 --> 00:24:37,639
five minutes and so feel free to come

00:24:35,840 --> 00:24:39,799
talk to me thank you very much I hope

00:24:37,639 --> 00:24:40,430
this gave people a good background and

00:24:39,799 --> 00:24:48,659
what coverage is

00:24:40,430 --> 00:24:48,659

YouTube URL: https://www.youtube.com/watch?v=g7q9cM2UZuo


