Title: Stream into the Future - Matteo Collina, NearForm
Publication date: 2020-05-11
Playlist: Node + JS Interactive 2019
Description: 
	Stream into the Future - Matteo Collina, NearForm
Speakers: Matteo Collina
There was a time when Node.js streams were all the rage but over time the Node.js Core Streams codebase became extremely complex and hard to understand. Worse still, WHATWG introduced an API for browser Streams. The two Streams APIâ€™s are incompatible with each other and both are complex and leaky abstractions. In this talk, a Node.js Core Streams maintainer presents a stream-less future by demonstrating how to use pure JavaScript: Async Iterators and Generators can give us everything Streams can while being completely cross-platform and highly performant.
Captions: 
	00:00:00,000 --> 00:00:06,420
I am at the Kalina admeto Kalina on

00:00:03,270 --> 00:00:08,730
Twitter so please follow me just so that

00:00:06,420 --> 00:00:10,110
you know and I'm trying to eat 10,000

00:00:08,730 --> 00:00:12,809
followers by the end of the year so

00:00:10,110 --> 00:00:16,470
please help me into that to that release

00:00:12,809 --> 00:00:17,400
that my son so I'm here today to talk

00:00:16,470 --> 00:00:20,369
about nodejs

00:00:17,400 --> 00:00:22,830
streams and the future of Nod streams

00:00:20,369 --> 00:00:26,640
and you know how you can help or maybe

00:00:22,830 --> 00:00:30,060
what you can provide feedback on so a

00:00:26,640 --> 00:00:32,520
couple of things first I work for a

00:00:30,060 --> 00:00:35,700
company called near form we have a nice

00:00:32,520 --> 00:00:38,190
booth in the booth CRO we are also doing

00:00:35,700 --> 00:00:41,550
some raffle thing with some smart

00:00:38,190 --> 00:00:44,190
watches and airport so come by all the

00:00:41,550 --> 00:00:47,370
you know we donate some money out of the

00:00:44,190 --> 00:00:50,190
Ottawa charity out after the booth after

00:00:47,370 --> 00:00:54,570
after that so please come by swing by it

00:00:50,190 --> 00:00:56,309
would be interesting so we are new to

00:00:54,570 --> 00:00:58,590
yes we are a professional services

00:00:56,309 --> 00:01:00,270
company that do all things javascript so

00:00:58,590 --> 00:01:01,739
you know if you're if you have some

00:01:00,270 --> 00:01:03,510
problems with your JavaScript and you

00:01:01,739 --> 00:01:05,339
need some help and your team need some

00:01:03,510 --> 00:01:09,090
out lights please pass by we have a lot

00:01:05,339 --> 00:01:13,740
of things to talk about so conversation

00:01:09,090 --> 00:01:17,280
so let's go into into streams okay how

00:01:13,740 --> 00:01:20,430
many of you use node streams I mean if

00:01:17,280 --> 00:01:22,920
you have liked node streams okay

00:01:20,430 --> 00:01:27,390
a few maybe I mean if you understand

00:01:22,920 --> 00:01:27,660
those streams okay I'm not sure I trust

00:01:27,390 --> 00:01:30,000
you

00:01:27,660 --> 00:01:34,770
[Laughter]

00:01:30,000 --> 00:01:38,100
so a stream is like an array but over

00:01:34,770 --> 00:01:41,189
time essentially instead of having a big

00:01:38,100 --> 00:01:43,439
chunk of data enough of memory we choose

00:01:41,189 --> 00:01:45,540
rating upon your receiving data along

00:01:43,439 --> 00:01:47,790
the way and you're processing them over

00:01:45,540 --> 00:01:50,430
time this is fantastic because it

00:01:47,790 --> 00:01:54,540
enabled us to crunch an insanely high

00:01:50,430 --> 00:01:57,090
amount of data with a limited amount of

00:01:54,540 --> 00:01:59,040
memory which is fantastic right that's

00:01:57,090 --> 00:02:00,990
that's what why there we are using them

00:01:59,040 --> 00:02:03,540
we are using them for file processing

00:02:00,990 --> 00:02:09,179
and a lot of other things so there are

00:02:03,540 --> 00:02:12,090
key part the problem is that node

00:02:09,179 --> 00:02:13,470
streams are really complicated and most

00:02:12,090 --> 00:02:16,350
people don't really understand all

00:02:13,470 --> 00:02:18,330
dreams at all by even some cork not core

00:02:16,350 --> 00:02:20,400
contributor struggles a little bit into

00:02:18,330 --> 00:02:25,740
when it comes to those two reviewing

00:02:20,400 --> 00:02:27,630
those Chris PPR so it's really you know

00:02:25,740 --> 00:02:32,430
it's a really complicated code base that

00:02:27,630 --> 00:02:34,740
evolved a lot over time and you know in

00:02:32,430 --> 00:02:36,780
fact it emits up a number of events so

00:02:34,740 --> 00:02:39,000
not streams are based on a venturi meter

00:02:36,780 --> 00:02:40,740
and they emit a lot of events you know

00:02:39,000 --> 00:02:42,690
you can have the data event you probably

00:02:40,740 --> 00:02:44,940
have used you have you that it's a

00:02:42,690 --> 00:02:46,290
readable event which probably you

00:02:44,940 --> 00:02:50,430
haven't used much because that's not

00:02:46,290 --> 00:02:52,680
very popular that is close this is a

00:02:50,430 --> 00:02:54,840
meaning this end that has some other

00:02:52,680 --> 00:02:58,320
meaning different from close by the way

00:02:54,840 --> 00:03:01,500
you know there is finish which you know

00:02:58,320 --> 00:03:02,910
close at the finish you know they kind

00:03:01,500 --> 00:03:05,190
of mean the same thing right know that

00:03:02,910 --> 00:03:08,970
really complete different three

00:03:05,190 --> 00:03:10,440
completely different meaning and then

00:03:08,970 --> 00:03:12,660
that is destroyed to tell the full thing

00:03:10,440 --> 00:03:14,190
the full thing down and I have not

00:03:12,660 --> 00:03:15,959
mentioned error because you probably

00:03:14,190 --> 00:03:19,200
have known that a meeting every node is

00:03:15,959 --> 00:03:20,459
a really big thing so there is also that

00:03:19,200 --> 00:03:24,660
to take into consideration

00:03:20,459 --> 00:03:27,060
just to recap data and readable are for

00:03:24,660 --> 00:03:29,550
reading data and that close and finish

00:03:27,060 --> 00:03:32,370
are emitted when when streams are ending

00:03:29,550 --> 00:03:34,620
to some extent the meaning of end it's

00:03:32,370 --> 00:03:36,989
on the readable side the meaning on

00:03:34,620 --> 00:03:38,610
finish on the writable side so when a

00:03:36,989 --> 00:03:40,739
reader of stream is done or the writable

00:03:38,610 --> 00:03:43,440
stream is done successfully successfully

00:03:40,739 --> 00:03:45,510
only so if there's an error or an abrupt

00:03:43,440 --> 00:03:48,299
operations are not emitted close is

00:03:45,510 --> 00:03:50,790
emitted when the underlining resource is

00:03:48,299 --> 00:03:57,000
brought down and it will be emitted also

00:03:50,790 --> 00:03:58,739
in the case of fibers so so once upon a

00:03:57,000 --> 00:04:01,140
time the only way to interact with the

00:03:58,739 --> 00:04:03,030
stream was by using the data on data

00:04:01,140 --> 00:04:04,860
event you will find a lot of these

00:04:03,030 --> 00:04:08,150
examples everywhere

00:04:04,860 --> 00:04:11,070
okay these I call this the wild horse

00:04:08,150 --> 00:04:12,930
example because essentially you are

00:04:11,070 --> 00:04:15,930
receiving as much data as fast as the

00:04:12,930 --> 00:04:18,239
source can provide you which turns out

00:04:15,930 --> 00:04:19,979
to be a very bad idea because you cannot

00:04:18,239 --> 00:04:22,620
really you know it's really hard to

00:04:19,979 --> 00:04:23,520
pause the source to some extent until

00:04:22,620 --> 00:04:25,080
the a please slow down

00:04:23,520 --> 00:04:28,610
because this is too much data I don't

00:04:25,080 --> 00:04:30,990
know what to do it with that here

00:04:28,610 --> 00:04:33,000
also take into account that Jesus posted

00:04:30,990 --> 00:04:35,700
the source of one of the wars back ever

00:04:33,000 --> 00:04:38,970
so if you put with where is it okay if

00:04:35,700 --> 00:04:40,980
you put a sink here you are creating

00:04:38,970 --> 00:04:42,990
making a lot of pop card so don't put a

00:04:40,980 --> 00:04:45,240
sink there James has a talk tomorrow

00:04:42,990 --> 00:04:47,730
about broken promises go to his broken

00:04:45,240 --> 00:04:51,030
promises talk because it's a really good

00:04:47,730 --> 00:04:53,100
talk to be to go and liquid pressure

00:04:51,030 --> 00:04:54,450
with that on data model is really hard

00:04:53,100 --> 00:04:56,970
because I'll do you stop there's a pose

00:04:54,450 --> 00:05:03,060
method on strings but pose is only

00:04:56,970 --> 00:05:05,040
advisory so what so at some point it was

00:05:03,060 --> 00:05:09,120
introduced a new in another API called

00:05:05,040 --> 00:05:11,580
the readable event to actually you know

00:05:09,120 --> 00:05:13,770
provide a pool based model so instead of

00:05:11,580 --> 00:05:16,620
having these fire rows of data okay let

00:05:13,770 --> 00:05:17,850
me just call you and get me notify me

00:05:16,620 --> 00:05:19,440
when there is data available and then

00:05:17,850 --> 00:05:21,390
let me read that data from you so

00:05:19,440 --> 00:05:24,720
instead of you know a fire hose of

00:05:21,390 --> 00:05:26,880
information is more a pool model okay so

00:05:24,720 --> 00:05:29,070
streams can have a push model and the

00:05:26,880 --> 00:05:32,370
pool model I'm implementing in the same

00:05:29,070 --> 00:05:37,080
code base how does that sound that's its

00:05:32,370 --> 00:05:38,610
are able to maintain okay but these is

00:05:37,080 --> 00:05:41,310
actually the probably the best way to

00:05:38,610 --> 00:05:44,220
interact with the string because you

00:05:41,310 --> 00:05:46,620
actually can you pull data from it so

00:05:44,220 --> 00:05:50,010
you use the internal buffer in the most

00:05:46,620 --> 00:05:54,060
optimal way still again not really this

00:05:50,010 --> 00:05:57,450
is not really readable to be honest it's

00:05:54,060 --> 00:05:59,910
also more performant because in this way

00:05:57,450 --> 00:06:02,340
you only read the data that you need so

00:05:59,910 --> 00:06:04,290
it's a little bit more it's a much more

00:06:02,340 --> 00:06:07,320
gentle in the buffering off of the

00:06:04,290 --> 00:06:10,380
streams error handling is still super

00:06:07,320 --> 00:06:12,000
complex though streams and this probably

00:06:10,380 --> 00:06:15,300
the one of the source number one of

00:06:12,000 --> 00:06:17,850
memory leaks and file descriptor leaks

00:06:15,300 --> 00:06:22,740
file descriptor release or refund to to

00:06:17,850 --> 00:06:28,650
diagnose so this is now this is how to

00:06:22,740 --> 00:06:33,350
not stream a file over HTTP don't do

00:06:28,650 --> 00:06:38,340
this okay how many of you have done this

00:06:33,350 --> 00:06:41,419
few people don't do this at all this is

00:06:38,340 --> 00:06:43,919
community this will create a memory leak

00:06:41,419 --> 00:06:46,080
immediately y-you can you see who I can

00:06:43,919 --> 00:06:48,930
this create a memory you know can't you

00:06:46,080 --> 00:06:50,820
see the super it's obvious right it's a

00:06:48,930 --> 00:06:52,979
fast that's a simple API out what can I

00:06:50,820 --> 00:06:54,990
write bad you anyway

00:06:52,979 --> 00:06:59,820
so if you if you look at this you see

00:06:54,990 --> 00:07:04,500
this pie press so if the response errors

00:06:59,820 --> 00:07:11,550
or quit or the and the other side close

00:07:04,500 --> 00:07:15,720
the connection the read stream is not

00:07:11,550 --> 00:07:17,220
closed or tear down or destroyed so it

00:07:15,720 --> 00:07:19,410
stays alive and stays a light forever

00:07:17,220 --> 00:07:22,680
because then there is nobody to consume

00:07:19,410 --> 00:07:25,620
that stream and that's that's a big

00:07:22,680 --> 00:07:28,830
problem so essentially if in your code

00:07:25,620 --> 00:07:31,050
are using pipe without having some

00:07:28,830 --> 00:07:32,250
special error handling magic you're

00:07:31,050 --> 00:07:36,139
probably have a memory leak somewhere

00:07:32,250 --> 00:07:39,570
your application so don't use dot pipe

00:07:36,139 --> 00:07:41,250
what you need to use is pipeline which

00:07:39,570 --> 00:07:43,770
is a new operator that we have added in

00:07:41,250 --> 00:07:48,690
North core I think 10 or something or 8

00:07:43,770 --> 00:07:50,400
maybe 10 10 anyway it's available on as

00:07:48,690 --> 00:07:52,410
an open source model under the name pump

00:07:50,400 --> 00:07:54,419
and these Souls released inside the

00:07:52,410 --> 00:07:56,490
readable stream model module anyway

00:07:54,419 --> 00:07:58,110
there is pipeline and pipeline is

00:07:56,490 --> 00:08:00,599
actually really cool because it actually

00:07:58,110 --> 00:08:04,010
teared tear down the streams so if one

00:08:00,599 --> 00:08:07,139
of those errors it closed all the others

00:08:04,010 --> 00:08:09,780
so basically it makes sure that there's

00:08:07,139 --> 00:08:11,849
no memory leaks and no leaks of any sort

00:08:09,780 --> 00:08:15,720
so please use pipeline ok

00:08:11,849 --> 00:08:17,699
don't use pipe you might want to ask why

00:08:15,720 --> 00:08:19,919
can't you change the behavior of pipe to

00:08:17,699 --> 00:08:22,260
actually do the right thing well

00:08:19,919 --> 00:08:24,660
backward compatibility we cannot break

00:08:22,260 --> 00:08:26,130
everybody okay there's a lot of code

00:08:24,660 --> 00:08:28,440
that the light of that behavior out

00:08:26,130 --> 00:08:31,949
there so you can we can't really change

00:08:28,440 --> 00:08:34,409
that that's bad you can also use a

00:08:31,949 --> 00:08:36,570
framework by the way to serve files

00:08:34,409 --> 00:08:38,490
probably the best option is actually to

00:08:36,570 --> 00:08:39,630
use a framework because there are a

00:08:38,490 --> 00:08:41,039
bunch of things to be done so don't

00:08:39,630 --> 00:08:42,570
survive manually you just use a

00:08:41,039 --> 00:08:45,060
framework we will do it for you it will

00:08:42,570 --> 00:08:47,029
do the right thing that you so use a

00:08:45,060 --> 00:08:49,200
finger

00:08:47,029 --> 00:08:51,959
note that all the best feature from no

00:08:49,200 --> 00:08:54,269
TAS are based on streams so as good as

00:08:51,959 --> 00:08:55,850
bad as it sounds it's an aging codebase

00:08:54,269 --> 00:08:59,519
that there's a lot of history and

00:08:55,850 --> 00:09:03,060
although jes repents of this I fast

00:08:59,519 --> 00:09:05,970
depends on this HTTP depends of this HT

00:09:03,060 --> 00:09:08,880
Picchu of course and a bunch of other

00:09:05,970 --> 00:09:11,310
stuff so standard input a standard

00:09:08,880 --> 00:09:13,410
output dependence is things so it's

00:09:11,310 --> 00:09:15,870
really important to understand and

00:09:13,410 --> 00:09:17,459
evolve this code base in them in the

00:09:15,870 --> 00:09:19,260
best way without breaking everybody

00:09:17,459 --> 00:09:21,060
because the biggest problem with

00:09:19,260 --> 00:09:22,860
developing note stream in node core and

00:09:21,060 --> 00:09:25,380
somebody field an Oracle operator you

00:09:22,860 --> 00:09:27,120
can program program will tell you like

00:09:25,380 --> 00:09:33,000
if you touch those you can really break

00:09:27,120 --> 00:09:35,899
everybody so don't break everybody there

00:09:33,000 --> 00:09:38,670
is a one by big problem though you know

00:09:35,899 --> 00:09:40,829
because the JavaScript community use a

00:09:38,670 --> 00:09:45,240
sink await everywhere now I mean if you

00:09:40,829 --> 00:09:47,550
use async await good everybody is there

00:09:45,240 --> 00:09:52,019
somebody that do not use any async await

00:09:47,550 --> 00:09:57,660
at all we can probably have a beer

00:09:52,019 --> 00:10:00,240
afterwards right anyway so everybody has

00:09:57,660 --> 00:10:01,980
moved to a sink await the biggest

00:10:00,240 --> 00:10:03,690
problem with streams and the sink away

00:10:01,980 --> 00:10:06,480
it is that the two things do not really

00:10:03,690 --> 00:10:08,820
mix well together and if you try to do

00:10:06,480 --> 00:10:11,880
that we are probably have seen some new

00:10:08,820 --> 00:10:13,589
promise and then doing some Shanahan's

00:10:11,880 --> 00:10:15,779
to get actually the thing to do what it

00:10:13,589 --> 00:10:17,699
what you want to do I don't know you

00:10:15,779 --> 00:10:22,620
probably somebody as soon is nothing I

00:10:17,699 --> 00:10:25,620
hope I hope it I'm meeting some nerves

00:10:22,620 --> 00:10:28,790
here but the outer do it is not clear is

00:10:25,620 --> 00:10:31,529
not easy and is not straightforward so

00:10:28,790 --> 00:10:33,660
essentially you have we're not doing a

00:10:31,529 --> 00:10:35,880
good way of serving you folks that's not

00:10:33,660 --> 00:10:37,380
core contributors into this by the way

00:10:35,880 --> 00:10:45,329
I'm part of the team that maintains the

00:10:37,380 --> 00:10:46,949
node streams so anyway so we cannot

00:10:45,329 --> 00:10:48,589
really change the things that are

00:10:46,949 --> 00:10:50,579
already there without breaking everybody

00:10:48,589 --> 00:10:53,490
because everybody depends on these

00:10:50,579 --> 00:10:56,940
things so for example we cannot really

00:10:53,490 --> 00:10:59,130
change all the streams work because then

00:10:56,940 --> 00:11:00,420
it will break whatever web framework

00:10:59,130 --> 00:11:04,260
that you are using

00:11:00,420 --> 00:11:05,730
those used streams or you can change

00:11:04,260 --> 00:11:08,940
them if we break some of the file

00:11:05,730 --> 00:11:12,089
processing that you do so we can do some

00:11:08,940 --> 00:11:18,089
surgical changes but we can't really do

00:11:12,089 --> 00:11:19,459
much so so then the question comes how

00:11:18,089 --> 00:11:22,290
can you improve the usability of this

00:11:19,459 --> 00:11:25,560
user ability of streams considering the

00:11:22,290 --> 00:11:28,860
fact that you know people love us in

00:11:25,560 --> 00:11:30,839
Kuwait so the first one was the number

00:11:28,860 --> 00:11:36,000
one mistake that people do with streams

00:11:30,839 --> 00:11:37,740
is on data sync don't do that okay right

00:11:36,000 --> 00:11:39,779
now I'm working on a field go to this

00:11:37,740 --> 00:11:43,079
totally but I'm going working on a fix I

00:11:39,779 --> 00:11:44,699
did a PR to help with that but to

00:11:43,079 --> 00:11:46,019
actually provide some safety net but the

00:11:44,699 --> 00:11:49,500
net result would be you will have a

00:11:46,019 --> 00:11:51,209
memory leak if you try to do that and so

00:11:49,500 --> 00:11:53,430
the thing that I've been working on for

00:11:51,209 --> 00:11:58,170
the last few years has been to provide a

00:11:53,430 --> 00:11:59,399
sync iterator support on on streams how

00:11:58,170 --> 00:12:04,649
many of you knows about the sync

00:11:59,399 --> 00:12:07,019
iterators hey fantastic guys the best

00:12:04,649 --> 00:12:08,850
feature that has been put putting inside

00:12:07,019 --> 00:12:11,279
one of the recent we should have note

00:12:08,850 --> 00:12:14,160
they came into node it said note 10 so

00:12:11,279 --> 00:12:17,360
that basically after December by the way

00:12:14,160 --> 00:12:20,820
no date goes out of maintenance in the

00:12:17,360 --> 00:12:23,790
31st of December this year so stop using

00:12:20,820 --> 00:12:25,620
no date so since January 1st all

00:12:23,790 --> 00:12:27,300
supported version of nodes yes will have

00:12:25,620 --> 00:12:29,730
a sink iterator sin which is fantastic

00:12:27,300 --> 00:12:31,050
so we can use them everywhere depending

00:12:29,730 --> 00:12:34,560
on whichever node version we are using

00:12:31,050 --> 00:12:36,750
how does this look like well you have a

00:12:34,560 --> 00:12:40,260
bunch of things to say so first one up

00:12:36,750 --> 00:12:42,060
is you can have on a sync generator of a

00:12:40,260 --> 00:12:43,709
nursing generator this is actually a

00:12:42,060 --> 00:12:46,980
very specific way to write a function

00:12:43,709 --> 00:12:50,040
that you know can spit out things you

00:12:46,980 --> 00:12:53,600
know that you can iterate on like this

00:12:50,040 --> 00:12:57,029
with for await and you pass an iterator

00:12:53,600 --> 00:12:59,459
now what you probably don't know is that

00:12:57,029 --> 00:13:01,860
of it there is a full protocol under

00:12:59,459 --> 00:13:03,510
that thing you know to power that so you

00:13:01,860 --> 00:13:06,180
can write your own asynch iterators

00:13:03,510 --> 00:13:09,329
without using the the function syntax

00:13:06,180 --> 00:13:10,860
for example more or less like you can

00:13:09,329 --> 00:13:13,920
write your own iterator normally to

00:13:10,860 --> 00:13:16,560
resource for other objects so you can

00:13:13,920 --> 00:13:18,750
if you want to use for off into on an

00:13:16,560 --> 00:13:20,970
object on any object you can actually

00:13:18,750 --> 00:13:23,850
provide that type of capability because

00:13:20,970 --> 00:13:25,529
there's a protocol so there is your your

00:13:23,850 --> 00:13:29,970
object need to implement certain methods

00:13:25,529 --> 00:13:32,820
to do things so this is pretty

00:13:29,970 --> 00:13:37,410
interesting can we use this with streams

00:13:32,820 --> 00:13:39,899
well maybe we when this was being

00:13:37,410 --> 00:13:42,029
standardized we were working with tc39

00:13:39,899 --> 00:13:43,800
to actually validate that we could

00:13:42,029 --> 00:13:49,550
actually use them with streams and we

00:13:43,800 --> 00:13:52,079
could so so things are compatible and

00:13:49,550 --> 00:13:54,300
compatible right now so you can use this

00:13:52,079 --> 00:13:56,550
code right now so you don't need to

00:13:54,300 --> 00:14:00,180
write any turn on any flag and so on

00:13:56,550 --> 00:14:02,250
this code is so you can create your

00:14:00,180 --> 00:14:04,589
stream and then you can for await and

00:14:02,250 --> 00:14:08,790
iterate over that stream pretty cool

00:14:04,589 --> 00:14:10,800
right and you can just process those

00:14:08,790 --> 00:14:15,209
chunks and that's it and when the for

00:14:10,800 --> 00:14:17,399
loop ends it ends hey I don't need to

00:14:15,209 --> 00:14:18,810
use any crazy events I don't need to do

00:14:17,399 --> 00:14:19,680
any shine against I don't need to do

00:14:18,810 --> 00:14:22,260
anything crazy

00:14:19,680 --> 00:14:25,949
I just can just do my thing and don't be

00:14:22,260 --> 00:14:28,829
done with it and note that if I break I

00:14:25,949 --> 00:14:30,690
use break from my for loop it just tear

00:14:28,829 --> 00:14:33,209
down the streams automatically again I

00:14:30,690 --> 00:14:35,760
don't have to do anything about it so it

00:14:33,209 --> 00:14:38,220
just do they just handle the very 80%

00:14:35,760 --> 00:14:40,560
basic use cases that you need and use

00:14:38,220 --> 00:14:46,649
the down the other API is as low-level

00:14:40,560 --> 00:14:48,180
components also in node 12 but also not

00:14:46,649 --> 00:14:51,959
ten now these are shipped on node 10 as

00:14:48,180 --> 00:14:54,089
well so I need to lay these lights in

00:14:51,959 --> 00:14:56,550
node ten in all version of node but it

00:14:54,089 --> 00:14:59,089
was just recent recently ported to node

00:14:56,550 --> 00:15:03,420
12 so like the last release of no time

00:14:59,089 --> 00:15:05,730
we have added readable dot from which

00:15:03,420 --> 00:15:08,850
essentially you can pass you can pass a

00:15:05,730 --> 00:15:11,579
an iterator or an a sync a traitor to

00:15:08,850 --> 00:15:13,949
readable dot from and it will

00:15:11,579 --> 00:15:17,279
automatically convert you in to a stream

00:15:13,949 --> 00:15:20,760
which is pretty fantastic so you don't

00:15:17,279 --> 00:15:24,520
have to do anything now okay I can just

00:15:20,760 --> 00:15:27,100
use I can just use these to convert

00:15:24,520 --> 00:15:30,340
to convert us to a function or an object

00:15:27,100 --> 00:15:33,190
or an array to a stream so it simplifies

00:15:30,340 --> 00:15:34,870
a lot of testing for example because you

00:15:33,190 --> 00:15:37,030
need to test your streams right I hope

00:15:34,870 --> 00:15:38,620
all of you write unit tests if you don't

00:15:37,030 --> 00:15:43,480
write you in task of start writing any

00:15:38,620 --> 00:15:52,840
test so you can and then use pipeline

00:15:43,480 --> 00:15:56,070
always use pipeline so with now you can

00:15:52,840 --> 00:15:59,950
also go and write some crazy you know

00:15:56,070 --> 00:16:02,290
concept of Inception so you can start

00:15:59,950 --> 00:16:04,630
with an a sink a sink generate on

00:16:02,290 --> 00:16:07,030
function convert into a stream and then

00:16:04,630 --> 00:16:10,780
iterate over the stream now these are

00:16:07,030 --> 00:16:12,700
some little side effects okay stream one

00:16:10,780 --> 00:16:14,740
of the key concept of streams is data

00:16:12,700 --> 00:16:16,480
buffering in order to a stream in order

00:16:14,740 --> 00:16:19,750
to be performin is to will buffer data

00:16:16,480 --> 00:16:23,380
and so you're a sync generator will get

00:16:19,750 --> 00:16:26,500
called a little bit more up to fill the

00:16:23,380 --> 00:16:28,870
streams buffer so it has a slightly

00:16:26,500 --> 00:16:30,220
different behavior then these will be

00:16:28,870 --> 00:16:33,940
have a slightly different behavior that

00:16:30,220 --> 00:16:36,460
are normal if you just iterate over the

00:16:33,940 --> 00:16:37,750
sync generator still is doable and you

00:16:36,460 --> 00:16:40,540
know you can use these things to

00:16:37,750 --> 00:16:42,970
actually level the field up it's pretty

00:16:40,540 --> 00:16:45,370
fitting nice because then you can just

00:16:42,970 --> 00:16:47,770
accept a parameter if it's a sink I

00:16:45,370 --> 00:16:49,480
terrible and just a sink iterate over

00:16:47,770 --> 00:16:51,370
that and you can use an assassin

00:16:49,480 --> 00:16:53,380
assassin generator or any other object

00:16:51,370 --> 00:16:55,630
that implement that protocol and your

00:16:53,380 --> 00:16:57,150
code will actually be the same so it's

00:16:55,630 --> 00:16:59,650
pretty powerful it's pretty powerful

00:16:57,150 --> 00:17:01,930
okay so it's demo time

00:16:59,650 --> 00:17:05,530
so hopefully the demo gods will be with

00:17:01,930 --> 00:17:07,120
me you know because that's that's an

00:17:05,530 --> 00:17:08,530
important piece so I have a seven

00:17:07,120 --> 00:17:11,290
examples I'm not sure if I can go

00:17:08,530 --> 00:17:14,730
through all of them we'll see so this is

00:17:11,290 --> 00:17:18,490
the first example so this is old-school

00:17:14,730 --> 00:17:20,470
streams so you implement the red with a

00:17:18,490 --> 00:17:22,660
the youth pass you implement the read

00:17:20,470 --> 00:17:25,060
method and with read you just you know

00:17:22,660 --> 00:17:27,900
iterate over a big array and just push

00:17:25,060 --> 00:17:30,190
all those values in and then push now

00:17:27,900 --> 00:17:36,040
this is how you would do implement these

00:17:30,190 --> 00:17:38,650
things a long time ago so you run this

00:17:36,040 --> 00:17:41,020
and you just spit out all the code

00:17:38,650 --> 00:17:43,270
now this was how you would do this thing

00:17:41,020 --> 00:17:44,860
note that in node we change I changes

00:17:43,270 --> 00:17:48,850
this and you know these will not run on

00:17:44,860 --> 00:17:49,240
node six it not six this won't work by

00:17:48,850 --> 00:17:52,540
the way

00:17:49,240 --> 00:17:53,470
okay we have fixed some stuff I'm not

00:17:52,540 --> 00:17:56,170
sick this won't work

00:17:53,470 --> 00:17:58,570
whatever don't try that or not six of

00:17:56,170 --> 00:17:59,800
course that is long gone so we don't

00:17:58,570 --> 00:18:02,410
have to worry about it anymore

00:17:59,800 --> 00:18:06,400
so now let's go and look at another

00:18:02,410 --> 00:18:10,150
version of the same code so this is just

00:18:06,400 --> 00:18:13,060
using readable from know that we see use

00:18:10,150 --> 00:18:15,190
on data to put to process that to

00:18:13,060 --> 00:18:17,020
process the data however in this case we

00:18:15,190 --> 00:18:18,700
just pass the array through and we just

00:18:17,020 --> 00:18:20,700
get a stream back this is really

00:18:18,700 --> 00:18:22,870
powerful for for testing for example

00:18:20,700 --> 00:18:25,000
because in this way we can be compatible

00:18:22,870 --> 00:18:28,060
and so on without you know breaking a

00:18:25,000 --> 00:18:29,860
sweat so we can run this code and you

00:18:28,060 --> 00:18:33,460
will still see you can still work the

00:18:29,860 --> 00:18:35,260
exact same now what you can do is you

00:18:33,460 --> 00:18:37,630
can also go into the full inception mode

00:18:35,260 --> 00:18:40,930
to some extent and you can pass in a

00:18:37,630 --> 00:18:42,970
generator generator function note that

00:18:40,930 --> 00:18:45,340
this is all synchronous okay a generator

00:18:42,970 --> 00:18:45,790
is synchronous a sync it a sync

00:18:45,340 --> 00:18:50,230
generator

00:18:45,790 --> 00:18:53,290
it's a synchronous okay anyway you can

00:18:50,230 --> 00:18:55,690
do this and you can still run it and you

00:18:53,290 --> 00:18:57,430
still get the same output as before but

00:18:55,690 --> 00:19:02,080
now you're generating it from a function

00:18:57,430 --> 00:19:06,280
instead this is pretty useful again we

00:19:02,080 --> 00:19:08,290
can of course use those with we can use

00:19:06,280 --> 00:19:10,930
we can go from an iterator to Anna sync

00:19:08,290 --> 00:19:13,720
iterator using this API so we can pass

00:19:10,930 --> 00:19:15,640
we have do we have at the our generator

00:19:13,720 --> 00:19:18,520
here we pass it to readable from and

00:19:15,640 --> 00:19:21,670
then we a sync iterate over it why

00:19:18,520 --> 00:19:23,680
because it's all pretty much generic so

00:19:21,670 --> 00:19:26,040
we can still run the code in still

00:19:23,680 --> 00:19:32,460
spitting out of thousand and twenty four

00:19:26,040 --> 00:19:35,110
numbers I'm I've a lot of fantasy so as

00:19:32,460 --> 00:19:38,530
I said we can also go full inception

00:19:35,110 --> 00:19:40,390
mode and do the sync iterator to a sync

00:19:38,530 --> 00:19:43,360
at a little thing okay

00:19:40,390 --> 00:19:45,160
note that if I do like let's let's let's

00:19:43,360 --> 00:19:48,600
show this so this still runs

00:19:45,160 --> 00:19:48,600
note that if I do

00:19:52,520 --> 00:20:00,270
instead it will still do exact same

00:19:56,940 --> 00:20:02,730
thing okay we still work the exact same

00:20:00,270 --> 00:20:04,500
so there is as I said there is a little

00:20:02,730 --> 00:20:06,300
bit of difference related to how much

00:20:04,500 --> 00:20:08,340
data is fetched from the sink a traitor

00:20:06,300 --> 00:20:11,930
function so there is that thing to take

00:20:08,340 --> 00:20:16,890
into consideration but that's that's it

00:20:11,930 --> 00:20:18,330
so now you can also given that so

00:20:16,890 --> 00:20:20,910
daughter streams though so you can also

00:20:18,330 --> 00:20:22,170
call all the full api's so for example

00:20:20,910 --> 00:20:23,460
if you have a if you have a five you

00:20:22,170 --> 00:20:26,820
want to read from a file and we want to

00:20:23,460 --> 00:20:28,590
read as a as as text as shrinks you need

00:20:26,820 --> 00:20:31,679
to set the encoding and you set the

00:20:28,590 --> 00:20:36,360
according to a utf-8 and it will still

00:20:31,679 --> 00:20:40,170
work now let's run six it spits out the

00:20:36,360 --> 00:20:45,390
same file yeah a lot of hard magic here

00:20:40,170 --> 00:20:46,950
and note that when you do this then you

00:20:45,390 --> 00:20:54,900
can do whatever processing you want in

00:20:46,950 --> 00:20:57,809
here so for example if you do by the way

00:20:54,900 --> 00:21:01,110
always use promise if I if you want to

00:20:57,809 --> 00:21:02,940
get promised version of anything don't

00:21:01,110 --> 00:21:05,160
do it manually the chances if it did

00:21:02,940 --> 00:21:06,450
make a mistakes doing manually or some

00:21:05,160 --> 00:21:08,670
of your colleague will make a mistake

00:21:06,450 --> 00:21:12,510
after you have done it correctly six

00:21:08,670 --> 00:21:13,980
months later it's very high so don't use

00:21:12,510 --> 00:21:17,429
promise advice that is there for a

00:21:13,980 --> 00:21:19,230
reason and it's also really fast so we

00:21:17,429 --> 00:21:21,720
go with generators live function with

00:21:19,230 --> 00:21:23,400
set timeout there are a pretty a lot of

00:21:21,720 --> 00:21:25,440
nasty things that you can just for me if

00:21:23,400 --> 00:21:27,210
you just forget a return in your new

00:21:25,440 --> 00:21:29,940
promise thing you will just create a lot

00:21:27,210 --> 00:21:33,679
of poppers and memory leaks and very bad

00:21:29,940 --> 00:21:37,110
things so avoid again broken promises

00:21:33,679 --> 00:21:44,400
and you know we can do an a quick await

00:21:37,110 --> 00:21:52,050
here for of this so you see now it's

00:21:44,400 --> 00:21:55,010
taking some time and note that this is

00:21:52,050 --> 00:21:55,010
interesting okay

00:21:57,720 --> 00:22:07,180
do you know why it's a single chunk yes

00:22:05,260 --> 00:22:12,910
because it's read as a full Sun from the

00:22:07,180 --> 00:22:21,820
disk interesting right so if we do the

00:22:12,910 --> 00:22:25,470
same thing in in here okay if you do

00:22:21,820 --> 00:22:25,470
this the same thing in here

00:22:30,370 --> 00:22:32,400
ah

00:22:33,580 --> 00:22:38,520
you will see that now it does what God

00:22:36,100 --> 00:22:48,250
says on the tin okay

00:22:38,520 --> 00:22:51,040
note that if you do it in in the stew

00:22:48,250 --> 00:22:59,400
okay I want it this one to one correct

00:22:51,040 --> 00:23:03,850
one note that yes I'm going forward so

00:22:59,400 --> 00:23:06,540
anyway last thing is that they want to

00:23:03,850 --> 00:23:07,720
show you it's an example on the server

00:23:06,540 --> 00:23:11,020
okay

00:23:07,720 --> 00:23:13,540
note that when you using a sink await on

00:23:11,020 --> 00:23:16,510
the server you also always need to put a

00:23:13,540 --> 00:23:18,550
catch handler in there make sure make

00:23:16,510 --> 00:23:21,040
sure that if you don't put a catch and

00:23:18,550 --> 00:23:22,600
ER you're going to create a memory leak

00:23:21,040 --> 00:23:26,020
everything about you called make

00:23:22,600 --> 00:23:29,320
promises safe the name implies the name

00:23:26,020 --> 00:23:31,210
is exactly what it implies or you crash

00:23:29,320 --> 00:23:32,770
on and handle rejection this is a big

00:23:31,210 --> 00:23:37,840
conversation and not the focus of this

00:23:32,770 --> 00:23:39,340
talk but if you run your code with no an

00:23:37,840 --> 00:23:41,400
Android section ender and you don't

00:23:39,340 --> 00:23:43,270
crash on and handle rejection you

00:23:41,400 --> 00:23:47,590
probably have some memory leaks in your

00:23:43,270 --> 00:23:49,360
code very likely anyway just always put

00:23:47,590 --> 00:23:51,310
a catch ender when you are moving from a

00:23:49,360 --> 00:23:55,410
known as sync function to a promise

00:23:51,310 --> 00:23:58,660
based function or a sync function so

00:23:55,410 --> 00:24:02,590
what we do here we just count the chunks

00:23:58,660 --> 00:24:05,230
and count the length and and then we

00:24:02,590 --> 00:24:10,150
just here we just use the request module

00:24:05,230 --> 00:24:12,940
to to do two pipe things so I'm just

00:24:10,150 --> 00:24:14,470
running this up and you see this is all

00:24:12,940 --> 00:24:14,980
working fine and it's actually really

00:24:14,470 --> 00:24:20,200
fast

00:24:14,980 --> 00:24:22,480
not that using a sink a traitor's is

00:24:20,200 --> 00:24:24,850
actually really fast as prolly faster

00:24:22,480 --> 00:24:26,830
than using other things you know living

00:24:24,850 --> 00:24:28,860
on is as fast as any other way of

00:24:26,830 --> 00:24:32,140
processing streams in node so use that

00:24:28,860 --> 00:24:35,290
that is doesn't have a big performance

00:24:32,140 --> 00:24:37,720
overhead i we have optimized the sink

00:24:35,290 --> 00:24:40,110
iterators like to the bone problem so

00:24:37,720 --> 00:24:43,780
it's the include the code is really

00:24:40,110 --> 00:24:47,560
nasty from in there just I brought the

00:24:43,780 --> 00:24:52,660
things so let's go talk a little

00:24:47,560 --> 00:24:54,850
on what is missing so the first one that

00:24:52,660 --> 00:25:00,100
is missing is how to write a transcript

00:24:54,850 --> 00:25:02,110
stream using a sync iterators so there

00:25:00,100 --> 00:25:04,030
is for example something that you could

00:25:02,110 --> 00:25:06,190
use to actually process the data along

00:25:04,030 --> 00:25:08,290
the way this is actually a very nice

00:25:06,190 --> 00:25:11,910
idea because we can have transferred by

00:25:08,290 --> 00:25:15,250
and you just pass in an a sync iterator

00:25:11,910 --> 00:25:18,010
a sync generator function that except on

00:25:15,250 --> 00:25:20,410
a sync iterator as an input so it has

00:25:18,010 --> 00:25:22,870
this or it's a morphic input and output

00:25:20,410 --> 00:25:26,440
and then you can just for await the

00:25:22,870 --> 00:25:28,120
thing and just yield the results so it's

00:25:26,440 --> 00:25:31,870
a pretty nice pattern to write a

00:25:28,120 --> 00:25:37,780
transform a way to transform data pretty

00:25:31,870 --> 00:25:39,580
cool right I love this so and then if

00:25:37,780 --> 00:25:41,170
you convert this each to a transverse

00:25:39,580 --> 00:25:42,490
frame then you can use it with pipeline

00:25:41,170 --> 00:25:43,860
and interact all the stream secure

00:25:42,490 --> 00:25:46,090
system models

00:25:43,860 --> 00:25:46,510
note that this is currently being worked

00:25:46,090 --> 00:25:49,300
on

00:25:46,510 --> 00:25:50,620
so hopefully this PR will land again has

00:25:49,300 --> 00:25:53,830
been it got stuck at the beginning

00:25:50,620 --> 00:25:55,810
October so I'm hoping to unstuck it this

00:25:53,830 --> 00:25:59,050
weekend we have the collaborator summit

00:25:55,810 --> 00:26:02,310
then in two days hopefully I can get

00:25:59,050 --> 00:26:04,450
that unstuck and you can get that landed

00:26:02,310 --> 00:26:06,100
eventually I would love to be able to

00:26:04,450 --> 00:26:08,410
create a to avoid creating a transform

00:26:06,100 --> 00:26:12,760
completely so you can just pass in a

00:26:08,410 --> 00:26:15,510
single sink a sync function I think I

00:26:12,760 --> 00:26:17,710
think I think generator function that

00:26:15,510 --> 00:26:18,010
essentially implement that pattern for

00:26:17,710 --> 00:26:20,440
you

00:26:18,010 --> 00:26:21,880
so in this way you know you can do a

00:26:20,440 --> 00:26:23,410
void creating another stream you can

00:26:21,880 --> 00:26:26,290
just compose function as much as you

00:26:23,410 --> 00:26:28,540
like it's pretty it's pretty interesting

00:26:26,290 --> 00:26:31,210
this is not implemented yet this is

00:26:28,540 --> 00:26:33,520
fantastic code I'm living in Wonderland

00:26:31,210 --> 00:26:37,510
now hopefully this will eat your screen

00:26:33,520 --> 00:26:40,660
maybe on node 14 hopefully will back

00:26:37,510 --> 00:26:43,450
port it so now I've talked about

00:26:40,660 --> 00:26:46,740
readable I talked about transfer now I'm

00:26:43,450 --> 00:26:48,910
talking about writable you know I

00:26:46,740 --> 00:26:50,010
haven't talked about writable at all at

00:26:48,910 --> 00:26:52,930
this point

00:26:50,010 --> 00:26:56,020
writable well I don't know what to do

00:26:52,930 --> 00:27:01,230
with writable that's the end story and

00:26:56,020 --> 00:27:04,060
you know if you want to write something

00:27:01,230 --> 00:27:06,280
to write something you need to consume

00:27:04,060 --> 00:27:09,100
as an a sink a generator right however

00:27:06,280 --> 00:27:10,660
you want to have an operation that

00:27:09,100 --> 00:27:13,240
actually you know returns are freakin

00:27:10,660 --> 00:27:14,650
promised the problem the fact that you

00:27:13,240 --> 00:27:17,080
know our current right thing does not

00:27:14,650 --> 00:27:18,870
return the promise and it's very hard to

00:27:17,080 --> 00:27:21,790
create the behavior to return a promise

00:27:18,870 --> 00:27:23,740
why well in this code I would like to be

00:27:21,790 --> 00:27:25,480
able to write this code okay look at

00:27:23,740 --> 00:27:26,920
this this is we have right or a bill

00:27:25,480 --> 00:27:33,550
right and then we do a way to write

00:27:26,920 --> 00:27:36,160
chunk now this code is correct however

00:27:33,550 --> 00:27:38,050
all the magic is in bill right the

00:27:36,160 --> 00:27:42,220
problem is in the error ending model of

00:27:38,050 --> 00:27:45,060
promises virtual streams streams emit an

00:27:42,220 --> 00:27:51,910
error event as soon as it happens

00:27:45,060 --> 00:27:55,830
promise is like quantum physics so they

00:27:51,910 --> 00:27:55,830
will error only when you look at it

00:27:57,090 --> 00:28:02,740
that's a net that called parts of the

00:27:59,920 --> 00:28:05,350
problem so managing and this is why

00:28:02,740 --> 00:28:07,390
using promises with streams is really

00:28:05,350 --> 00:28:09,430
hard because one thing it errors

00:28:07,390 --> 00:28:11,740
straight away the other thing around

00:28:09,430 --> 00:28:13,750
only when it when you look at it so

00:28:11,740 --> 00:28:16,420
those two things are really really hard

00:28:13,750 --> 00:28:18,280
to mix and match and you can see this

00:28:16,420 --> 00:28:20,770
this code that does this kind of shiny

00:28:18,280 --> 00:28:23,530
guns to make this happen so essentially

00:28:20,770 --> 00:28:27,730
we are we are registering an error event

00:28:23,530 --> 00:28:30,490
and cashing the error you know I'm

00:28:27,730 --> 00:28:32,470
cashing the error so that whenever you

00:28:30,490 --> 00:28:35,470
and we return with this right function

00:28:32,470 --> 00:28:40,000
will return a promise that you know when

00:28:35,470 --> 00:28:43,060
you look at it will error okay it's

00:28:40,000 --> 00:28:44,710
really bad it's really bad code so I

00:28:43,060 --> 00:28:46,510
don't have anything better than this so

00:28:44,710 --> 00:28:48,730
if you have any ideas any promises

00:28:46,510 --> 00:28:51,760
expert that wants to give it a shot I am

00:28:48,730 --> 00:28:56,770
really welcome to to brainstorm things

00:28:51,760 --> 00:28:57,040
this is still open so how does it all

00:28:56,770 --> 00:28:58,720
work

00:28:57,040 --> 00:29:00,250
well almost is implemented in JavaScript

00:28:58,720 --> 00:29:02,470
so you can use all of this stuff in your

00:29:00,250 --> 00:29:06,010
code learn the pattern and use it for

00:29:02,470 --> 00:29:08,680
other things so I think iterator as I

00:29:06,010 --> 00:29:09,850
said I'm running a little bit out of

00:29:08,680 --> 00:29:13,149
time so

00:29:09,850 --> 00:29:15,549
hope you don't kick me out so or not

00:29:13,149 --> 00:29:17,139
this is an extract from North core so

00:29:15,549 --> 00:29:19,659
essentially we are implemented the

00:29:17,139 --> 00:29:22,059
symbol ADATA sync iterator primitive

00:29:19,659 --> 00:29:24,039
that returns a function and essentially

00:29:22,059 --> 00:29:25,989
we just create call that call our

00:29:24,039 --> 00:29:27,159
generator for that or our builder for

00:29:25,989 --> 00:29:31,149
that and we get a turn on a sing

00:29:27,159 --> 00:29:32,679
Katarina so essentially it's in order to

00:29:31,149 --> 00:29:36,309
prove to build something you just need

00:29:32,679 --> 00:29:37,899
to provide that note that if you want to

00:29:36,309 --> 00:29:39,999
build and I think iterate or you can you

00:29:37,899 --> 00:29:42,129
should use this type of pattern if you

00:29:39,999 --> 00:29:44,919
don't want to use on a sync generator

00:29:42,129 --> 00:29:46,989
function that is nice and really cool to

00:29:44,919 --> 00:29:48,909
use but if you want to do some of the

00:29:46,989 --> 00:29:50,169
hard stuff that we're doing or providing

00:29:48,909 --> 00:29:52,330
the mapping that we do in North core

00:29:50,169 --> 00:29:54,879
what you need to do is that you need to

00:29:52,330 --> 00:29:59,950
create an object which as the prototype

00:29:54,879 --> 00:30:02,859
of the a sink a generator and and

00:29:59,950 --> 00:30:05,379
implement some method like next and

00:30:02,859 --> 00:30:07,989
return next when it's called when X is

00:30:05,379 --> 00:30:10,690
called to get the next element when the

00:30:07,989 --> 00:30:12,129
return is called when you exit that's it

00:30:10,690 --> 00:30:16,919
there are some other few but they are

00:30:12,129 --> 00:30:20,919
less important these are the key to ones

00:30:16,919 --> 00:30:22,899
so internally not core we wrap the

00:30:20,919 --> 00:30:24,970
readable event these are some

00:30:22,899 --> 00:30:27,100
consequences and one of those thing is

00:30:24,970 --> 00:30:30,039
that is there it's really performant so

00:30:27,100 --> 00:30:32,470
that's the good side also it handles it

00:30:30,039 --> 00:30:35,619
blenders well buffering and and all the

00:30:32,470 --> 00:30:38,950
things this is a long link sorry

00:30:35,619 --> 00:30:41,350
somewhere small is the source of the

00:30:38,950 --> 00:30:49,450
implementation now I'm going to open it

00:30:41,350 --> 00:30:54,909
up for you okay and I'm going to open it

00:30:49,450 --> 00:30:58,179
up and just do a quick scroll he choose

00:30:54,909 --> 00:31:00,249
200 lines of code okay not that bad not

00:30:58,179 --> 00:31:02,249
that much but really lot of very ugly

00:31:00,249 --> 00:31:10,840
stuff in here sorry

00:31:02,249 --> 00:31:12,850
lot of edge cases and okay so there is

00:31:10,840 --> 00:31:14,139
no performance penalty in using a single

00:31:12,850 --> 00:31:16,029
traitor's over the other method so

00:31:14,139 --> 00:31:18,730
that's the key part which if you talk

00:31:16,029 --> 00:31:21,039
about promise based API saying there is

00:31:18,730 --> 00:31:23,020
no performance penalty this is pretty

00:31:21,039 --> 00:31:25,210
big and I'm not

00:31:23,020 --> 00:31:26,770
underselling Elizabeth typically

00:31:25,210 --> 00:31:29,800
promised by staff are slower than combat

00:31:26,770 --> 00:31:31,660
by staff this thing is on par just so

00:31:29,800 --> 00:31:34,840
that you know one last thing before I

00:31:31,660 --> 00:31:36,130
finish there is what woody streams now

00:31:34,840 --> 00:31:38,620
what would you stream says what you're

00:31:36,130 --> 00:31:40,210
using in node fetch okay no sorry

00:31:38,620 --> 00:31:42,490
naughty not file using in fetch in the

00:31:40,210 --> 00:31:44,710
browser not in not fat not not does not

00:31:42,490 --> 00:31:46,120
have what with these troops now this

00:31:44,710 --> 00:31:49,510
case have a bit of abyss compatibility

00:31:46,120 --> 00:31:51,430
between the two things this is what

00:31:49,510 --> 00:31:54,940
woody streams were which is this pipe to

00:31:51,430 --> 00:31:56,740
method three complex again okay all the

00:31:54,940 --> 00:32:00,040
key part there is streaming is real

00:31:56,740 --> 00:32:01,270
streams based API are really complex you

00:32:00,040 --> 00:32:03,100
know and you know if you want to

00:32:01,270 --> 00:32:06,280
implement those you need to implement

00:32:03,100 --> 00:32:08,470
this thing which has a number controller

00:32:06,280 --> 00:32:15,120
and a lot of other stuff which is really

00:32:08,470 --> 00:32:18,640
complicated again so not really easy and

00:32:15,120 --> 00:32:19,810
I just want to skip through this but we

00:32:18,640 --> 00:32:22,180
would like to have those in node core

00:32:19,810 --> 00:32:24,010
and to make it more consistent you

00:32:22,180 --> 00:32:26,250
probably seen my stock so this makes us

00:32:24,010 --> 00:32:28,750
some sense to have this in North core

00:32:26,250 --> 00:32:30,280
however we want to be compatible with

00:32:28,750 --> 00:32:33,460
the node ecosystem we saw we use node

00:32:30,280 --> 00:32:38,130
streams at what time I use here the next

00:32:33,460 --> 00:32:40,300
one okay a tree okay so I think sorry

00:32:38,130 --> 00:32:43,180
however what we do streams are going to

00:32:40,300 --> 00:32:46,870
be a sink high interval so that's cool

00:32:43,180 --> 00:32:50,830
to implement the same pattern so I hope

00:32:46,870 --> 00:32:53,320
one day to be able to do this type of

00:32:50,830 --> 00:32:56,080
thing which make you start from a what

00:32:53,320 --> 00:33:00,070
was irritable and then consume is just

00:32:56,080 --> 00:33:01,990
using an a sync generator function pass

00:33:00,070 --> 00:33:06,370
to a node writable and it will all work

00:33:01,990 --> 00:33:08,380
fine so we're all the introduction is

00:33:06,370 --> 00:33:10,240
being managed by via their sink I

00:33:08,380 --> 00:33:12,880
traitor protocol which would be pretty

00:33:10,240 --> 00:33:14,950
fantastic do you want to get involved

00:33:12,880 --> 00:33:17,440
please reach out I will be at the booth

00:33:14,950 --> 00:33:18,700
so reach out to me the next few days if

00:33:17,440 --> 00:33:20,800
you're interested in you know stuff you

00:33:18,700 --> 00:33:23,950
know those questions again we are near

00:33:20,800 --> 00:33:26,560
forum again this is a raffle the blah

00:33:23,950 --> 00:33:33,589
blah blah okay and thank you

00:33:26,560 --> 00:33:33,589

YouTube URL: https://www.youtube.com/watch?v=dOCw2sFCdzE


