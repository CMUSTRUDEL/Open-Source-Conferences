Title: Keynote: Production Loading Performance 10 Years Later-Nicole Sullivan and Shubhie Panicker,  Google
Publication date: 2020-06-22
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:02,620 --> 00:00:08,350
I met Ruby years ago when she came to

00:00:05,649 --> 00:00:12,990
speak at a conference that I founded

00:00:08,350 --> 00:00:16,050
called CSS conf and we bonded over

00:00:12,990 --> 00:00:18,970
production quality loading performance

00:00:16,050 --> 00:00:22,480
then because we both deeply cared about

00:00:18,970 --> 00:00:23,259
it and it turns out we both still care

00:00:22,480 --> 00:00:25,839
about it now

00:00:23,259 --> 00:00:29,249
so we thought that we would do this talk

00:00:25,839 --> 00:00:32,349
about we're loading performance has been

00:00:29,249 --> 00:00:36,460
and what we see in it 10 years later and

00:00:32,349 --> 00:00:37,260
hopefully a little bit wiser thanks

00:00:36,460 --> 00:00:40,210
Nicole

00:00:37,260 --> 00:00:42,970
so yeah Nicole and I are once again

00:00:40,210 --> 00:00:45,010
finding ourselves working on learning

00:00:42,970 --> 00:00:47,790
performance and this time its

00:00:45,010 --> 00:00:51,910
performance of open source powered

00:00:47,790 --> 00:00:53,560
ecosystem apps six or seven years ago I

00:00:51,910 --> 00:00:54,190
was working on solving these same

00:00:53,560 --> 00:00:57,940
problems

00:00:54,190 --> 00:01:00,550
for google internal frameworks and since

00:00:57,940 --> 00:01:03,460
then there have been big strides and

00:01:00,550 --> 00:01:06,299
technology advancements for instance for

00:01:03,460 --> 00:01:08,979
instance we have HTTP 2 and now HTTP 3

00:01:06,299 --> 00:01:12,009
we have great primitives like payload

00:01:08,979 --> 00:01:15,969
preconnect we've had a lot of amazing

00:01:12,009 --> 00:01:20,950
browser optimizations and formats like

00:01:15,969 --> 00:01:22,749
web P but what I found is that we still

00:01:20,950 --> 00:01:25,390
have basically the same problems today

00:01:22,749 --> 00:01:30,159
and it's been humbling that this is

00:01:25,390 --> 00:01:31,990
still such a hard problem we're still

00:01:30,159 --> 00:01:32,409
juggling with the relative priority of

00:01:31,990 --> 00:01:36,460
font

00:01:32,409 --> 00:01:38,560
CSS images JavaScript how to effectively

00:01:36,460 --> 00:01:40,210
deliver these things at the right time

00:01:38,560 --> 00:01:45,009
by utilizing the network and the

00:01:40,210 --> 00:01:47,289
bandwidth loading more than 10 20

00:01:45,009 --> 00:01:50,049
resources in parallel still has a

00:01:47,289 --> 00:01:52,179
performance cost and efficiently

00:01:50,049 --> 00:01:54,609
incrementally loading javascript is

00:01:52,179 --> 00:02:00,329
still largely unsolved in the larger

00:01:54,609 --> 00:02:03,310
ecosystem and as an org chrome and

00:02:00,329 --> 00:02:07,600
Google and browsers in general have done

00:02:03,310 --> 00:02:10,300
a lot of good work we've had great

00:02:07,600 --> 00:02:14,430
advances in browser engines in standards

00:02:10,300 --> 00:02:14,430
in dev tools and documentation

00:02:16,060 --> 00:02:22,270
um still a lot of the web is not meeting

00:02:19,319 --> 00:02:24,280
loading performance metrics boom

00:02:22,270 --> 00:02:26,920
recently announced the web viral metrics

00:02:24,280 --> 00:02:28,900
it's this set of three metrics that we

00:02:26,920 --> 00:02:32,020
have high conference impacts user

00:02:28,900 --> 00:02:33,880
experience during page loads we want a

00:02:32,020 --> 00:02:38,890
lot more of the web meeting these

00:02:33,880 --> 00:02:40,690
metrics brick buyers my manager on the

00:02:38,890 --> 00:02:43,900
back platform tweeted this interesting

00:02:40,690 --> 00:02:47,590
bit of data Chrome's usage is about

00:02:43,900 --> 00:02:50,470
evenly divided between sites that are in

00:02:47,590 --> 00:02:54,070
the head in the torso and in the tail

00:02:50,470 --> 00:02:56,440
and this essentially breaks down into

00:02:54,070 --> 00:02:59,050
these numbers we have a small number of

00:02:56,440 --> 00:03:01,900
head size about a hundred sites a medium

00:02:59,050 --> 00:03:05,140
number of tarsus I lost ten thousand and

00:03:01,900 --> 00:03:08,739
then the web has a very long tail three

00:03:05,140 --> 00:03:11,019
million-plus sites so this might give us

00:03:08,739 --> 00:03:12,430
a clue into the UX problems are we

00:03:11,019 --> 00:03:14,340
reaching each of these different

00:03:12,430 --> 00:03:17,380
audiences with our work

00:03:14,340 --> 00:03:20,200
first the best practices tend to make it

00:03:17,380 --> 00:03:21,489
into well resourced head sites they

00:03:20,200 --> 00:03:24,340
might even have teams of dedicated

00:03:21,489 --> 00:03:26,470
performance engineers but we aren't

00:03:24,340 --> 00:03:31,290
missing out on reaching the torso and

00:03:26,470 --> 00:03:31,290
tail sites and that is a bulk of the web

00:03:31,920 --> 00:03:36,280
so to reach more of the web we've

00:03:34,360 --> 00:03:39,730
realized that we should be looking and

00:03:36,280 --> 00:03:42,280
developers to link and these sites are

00:03:39,730 --> 00:03:46,780
often built using client-side frameworks

00:03:42,280 --> 00:03:49,930
or static generators CMS's or website

00:03:46,780 --> 00:03:52,090
builders and looking further down the

00:03:49,930 --> 00:03:54,700
stack we see that a lot of the web is

00:03:52,090 --> 00:03:59,820
powered by these open source ecosystem

00:03:54,700 --> 00:04:02,590
tools like web pack babel npm typescript

00:03:59,820 --> 00:04:04,690
so now we have this new surface a full

00:04:02,590 --> 00:04:08,170
stack you consider when thinking about

00:04:04,690 --> 00:04:10,650
UX then loading performance but how and

00:04:08,170 --> 00:04:13,329
what's the problem with loading anyway

00:04:10,650 --> 00:04:14,880
do you answer this my team has spent a

00:04:13,329 --> 00:04:17,109
lot of time over the last six months

00:04:14,880 --> 00:04:19,299
looking at performance of real

00:04:17,109 --> 00:04:20,979
Production apps and all of those four

00:04:19,299 --> 00:04:24,370
apps were powered that open source

00:04:20,979 --> 00:04:29,919
ecosystem feels like backpack Babel NPM

00:04:24,370 --> 00:04:32,259
and react and at a high level

00:04:29,919 --> 00:04:34,360
we have the same problem that I saw six

00:04:32,259 --> 00:04:38,349
or seven years ago it's still not easy

00:04:34,360 --> 00:04:42,090
and it's a scheduling problem of proper

00:04:38,349 --> 00:04:44,379
ordering prioritization pipelining

00:04:42,090 --> 00:04:49,060
optimizing for metrics in the correct

00:04:44,379 --> 00:04:50,590
order first FCP then LCP then F ID the

00:04:49,060 --> 00:04:52,030
assets Huckabee's Jagger's so it's ready

00:04:50,590 --> 00:04:54,939
by the time the metric should trigger

00:04:52,030 --> 00:04:57,490
based on who's our expectation this

00:04:54,939 --> 00:04:59,770
means figuring out which assets are most

00:04:57,490 --> 00:05:02,500
relevant to which metrics are in them

00:04:59,770 --> 00:05:06,729
appropriately first get the fonts and

00:05:02,500 --> 00:05:09,069
CSS in time for FTP then get the hero

00:05:06,729 --> 00:05:13,509
image ready for largest content full

00:05:09,069 --> 00:05:17,169
paint and I also see that time where the

00:05:13,509 --> 00:05:19,870
CPU on the CPU while reading on the

00:05:17,169 --> 00:05:22,330
network and vice versa so pipelining is

00:05:19,870 --> 00:05:26,169
important it keep the network and CPU

00:05:22,330 --> 00:05:29,110
fully utilized there's also specific

00:05:26,169 --> 00:05:30,610
problems for every metric so here's a

00:05:29,110 --> 00:05:32,740
couple examples and other and I'm too

00:05:30,610 --> 00:05:36,190
much into this for largest content full

00:05:32,740 --> 00:05:38,919
paint fonts and CSS critical and often

00:05:36,190 --> 00:05:40,960
problematic they might be loaded from a

00:05:38,919 --> 00:05:43,719
different domain or not be self hosted

00:05:40,960 --> 00:05:46,629
they might not have pre connect pods

00:05:43,719 --> 00:05:49,659
might be late discovered when CSS is

00:05:46,629 --> 00:05:53,800
parsing and CSS can be too large or have

00:05:49,659 --> 00:05:56,589
too many files and sync scripts often

00:05:53,800 --> 00:06:01,449
third-party synchronous scripts block

00:05:56,589 --> 00:06:03,789
FCP by holding of CSS and fonts another

00:06:01,449 --> 00:06:06,219
metric example is first interaction

00:06:03,789 --> 00:06:09,339
delay the most common culprit here is

00:06:06,219 --> 00:06:11,800
large JavaScript or non-critical

00:06:09,339 --> 00:06:16,089
third-party JavaScript that's sneaking

00:06:11,800 --> 00:06:17,800
up ahead of the primary JavaScript so

00:06:16,089 --> 00:06:20,430
getting ahead on the network or getting

00:06:17,800 --> 00:06:26,020
ahead on the main thread and causing

00:06:20,430 --> 00:06:27,639
additional style and layout work so I

00:06:26,020 --> 00:06:32,710
definitely learned a lot of lessons

00:06:27,639 --> 00:06:34,719
along the way and the key theme here is

00:06:32,710 --> 00:06:38,649
rounding with real-world apps and

00:06:34,719 --> 00:06:41,620
proving things out in production so the

00:06:38,649 --> 00:06:43,750
first lesson is using production apps to

00:06:41,620 --> 00:06:47,620
find problems and opportunities

00:06:43,750 --> 00:06:50,890
and getting to the ground truth early on

00:06:47,620 --> 00:06:54,850
in the project we didn't spend enough

00:06:50,890 --> 00:06:56,530
time looking at production apps we would

00:06:54,850 --> 00:06:58,920
ask developers what their problems were

00:06:56,530 --> 00:07:01,030
instead of looking at their apps and

00:06:58,920 --> 00:07:03,280
understanding and fighting the problems

00:07:01,030 --> 00:07:05,080
themselves and we've definitely been

00:07:03,280 --> 00:07:11,740
guilty of looking at simplistic apps

00:07:05,080 --> 00:07:13,570
versus full-featured Production apps the

00:07:11,740 --> 00:07:17,500
second lesson was validating designs and

00:07:13,570 --> 00:07:19,240
solutions early like lab metrics and a

00:07:17,500 --> 00:07:23,350
lab methodology are really important

00:07:19,240 --> 00:07:25,210
here and also we need to track movement

00:07:23,350 --> 00:07:28,420
in real world metrics as features

00:07:25,210 --> 00:07:31,060
learned so some early features we had

00:07:28,420 --> 00:07:34,210
some trouble with early validation when

00:07:31,060 --> 00:07:36,640
we implemented you know serving a modern

00:07:34,210 --> 00:07:40,090
JavaScript to modern browsers using

00:07:36,640 --> 00:07:42,850
modular module we didn't see expected

00:07:40,090 --> 00:07:45,040
size equivalents in real apps it was too

00:07:42,850 --> 00:07:47,650
complicated there were too many there

00:07:45,040 --> 00:07:49,419
was too much third-party NPM packages

00:07:47,650 --> 00:07:50,200
there was four were compilation issues

00:07:49,419 --> 00:07:52,270
with Babel

00:07:50,200 --> 00:07:55,530
sometimes the coal-based didn't have a

00:07:52,270 --> 00:07:58,150
ton of water and JavaScript to leverage

00:07:55,530 --> 00:08:01,750
another feature granular chunks and we

00:07:58,150 --> 00:08:04,540
reduced hours for it bundles by 30% but

00:08:01,750 --> 00:08:06,520
it didn't move the web idle metrics we

00:08:04,540 --> 00:08:08,950
didn't have a good set up for real world

00:08:06,520 --> 00:08:12,610
measurement or daily testing and perhaps

00:08:08,950 --> 00:08:14,590
javascript size was on the best proxy so

00:08:12,610 --> 00:08:19,240
the lesson overall is early validation

00:08:14,590 --> 00:08:22,840
with real websites is really critical so

00:08:19,240 --> 00:08:24,700
now over to Nicole you could solve all

00:08:22,840 --> 00:08:26,919
of these problems yourself but I think

00:08:24,700 --> 00:08:29,770
like us you'd find that it was two steps

00:08:26,919 --> 00:08:31,479
forward and one step back what we've

00:08:29,770 --> 00:08:36,099
realized is that the web has a lot of

00:08:31,479 --> 00:08:39,099
really great raw materials but there's

00:08:36,099 --> 00:08:39,849
some assembly required and if we're

00:08:39,099 --> 00:08:41,890
being honest

00:08:39,849 --> 00:08:45,220
its massive amounts of assembly required

00:08:41,890 --> 00:08:47,560
and at its worst it's massive amounts of

00:08:45,220 --> 00:08:48,160
assembly required by every dev on every

00:08:47,560 --> 00:08:51,160
project

00:08:48,160 --> 00:08:53,280
some devs absolutely love infrastructure

00:08:51,160 --> 00:08:56,270
I'm not one of them

00:08:53,280 --> 00:08:58,040
others love building features

00:08:56,270 --> 00:09:02,450
so what if we shared the infrastructure

00:08:58,040 --> 00:09:04,370
and the tools new devs find this

00:09:02,450 --> 00:09:09,830
horrifying and I think that we could

00:09:04,370 --> 00:09:11,690
make this much better for them we think

00:09:09,830 --> 00:09:13,880
we can get to a place where much less

00:09:11,690 --> 00:09:15,529
assembly is required and the web just

00:09:13,880 --> 00:09:17,900
works for all different kinds of

00:09:15,529 --> 00:09:21,790
developers and supports the sort of user

00:09:17,900 --> 00:09:24,950
outcomes that we want to have as well

00:09:21,790 --> 00:09:28,820
SDKs are absolutely key to making this

00:09:24,950 --> 00:09:30,020
happen next next and Gatsby wrap their

00:09:28,820 --> 00:09:32,210
respective frameworks

00:09:30,020 --> 00:09:33,830
and provide a lot of things out of the

00:09:32,210 --> 00:09:36,440
box that the framework doesn't

00:09:33,830 --> 00:09:38,930
necessarily come with they provide

00:09:36,440 --> 00:09:41,529
client server integration absolutely

00:09:38,930 --> 00:09:44,960
essential for good perf outcomes and

00:09:41,529 --> 00:09:46,220
many already improved performance over

00:09:44,960 --> 00:09:48,529
using a framework alone

00:09:46,220 --> 00:09:53,660
what's better there's room to make them

00:09:48,529 --> 00:09:56,089
even stronger performance wise so what

00:09:53,660 --> 00:09:57,860
our sdk is in the end we think of them

00:09:56,089 --> 00:10:00,980
as a commons where we can collaborate

00:09:57,860 --> 00:10:05,690
together as an entire developer

00:10:00,980 --> 00:10:08,660
community to get better outcomes what

00:10:05,690 --> 00:10:11,420
sorts of things goes into a web sdk it

00:10:08,660 --> 00:10:13,520
might be back-end server logic unit

00:10:11,420 --> 00:10:15,920
integration testing translations

00:10:13,520 --> 00:10:19,220
encapsulation security image handling

00:10:15,920 --> 00:10:20,600
and the list goes on and on essentially

00:10:19,220 --> 00:10:22,420
we're trying to help a dev to be as

00:10:20,600 --> 00:10:25,160
productive as they possibly can be

00:10:22,420 --> 00:10:27,140
they're building a production app it has

00:10:25,160 --> 00:10:28,850
so many moving parts and it can be

00:10:27,140 --> 00:10:30,920
really difficult to reason about how to

00:10:28,850 --> 00:10:33,140
string those together and how all the

00:10:30,920 --> 00:10:36,200
tiny decisions you make lead up to

00:10:33,140 --> 00:10:38,720
performance outcomes so if you're

00:10:36,200 --> 00:10:40,880
thinking this would bog me down I want

00:10:38,720 --> 00:10:43,130
minimum opinions and maximum flexibility

00:10:40,880 --> 00:10:46,540
I'd love for you to turn that around and

00:10:43,130 --> 00:10:49,280
imagine your entire team with minimum

00:10:46,540 --> 00:10:52,880
opinions and maximum flexibility and

00:10:49,280 --> 00:10:55,400
think how that would turn out often the

00:10:52,880 --> 00:10:57,800
sort of guardrails that keep people from

00:10:55,400 --> 00:11:01,220
making mistakes and the helping teams

00:10:57,800 --> 00:11:03,320
work better together - we believe that

00:11:01,220 --> 00:11:07,160
most developers want to you and should

00:11:03,320 --> 00:11:09,740
focus on building features so that's why

00:11:07,160 --> 00:11:13,130
Google and chrome are investing in

00:11:09,740 --> 00:11:15,290
jeaious and react I want to be super

00:11:13,130 --> 00:11:19,700
clear we want all of the frameworks and

00:11:15,290 --> 00:11:22,030
all of the SDKs to be successful but we

00:11:19,700 --> 00:11:25,490
did realize that we're a small team and

00:11:22,030 --> 00:11:28,580
we needed to invest in one set of stack

00:11:25,490 --> 00:11:32,840
tools in order to have the biggest

00:11:28,580 --> 00:11:35,470
impact that we could that said we're

00:11:32,840 --> 00:11:39,170
very careful to look at the whole stack

00:11:35,470 --> 00:11:41,270
and to realize that each piece that we

00:11:39,170 --> 00:11:44,180
can put lower down in the stack means

00:11:41,270 --> 00:11:47,270
that those those changes that we've made

00:11:44,180 --> 00:11:50,240
will be easier to pick up for other

00:11:47,270 --> 00:11:52,880
stacks if we make a change in webpack

00:11:50,240 --> 00:11:55,390
then everybody that uses webpack can

00:11:52,880 --> 00:12:01,670
leverage that as opposed to simply

00:11:55,390 --> 00:12:05,540
building it into next itself so we work

00:12:01,670 --> 00:12:07,880
with our partners to develop opinions to

00:12:05,540 --> 00:12:10,880
test those opinions in production -

00:12:07,880 --> 00:12:14,710
bacon good defaults the SDKs and then to

00:12:10,880 --> 00:12:14,710
lock in those defaults with guardrails

00:12:15,910 --> 00:12:21,200
we've had some initial perf winds that

00:12:18,800 --> 00:12:24,740
were pretty happy about improved

00:12:21,200 --> 00:12:29,330
chunking reduced bundles by 25 to 75

00:12:24,740 --> 00:12:32,120
percent improving caching and faster

00:12:29,330 --> 00:12:35,750
navigations particularly happy to see

00:12:32,120 --> 00:12:39,320
that ship in in Gatsby - that's the sort

00:12:35,750 --> 00:12:41,090
of ecosystem benefit where when we will

00:12:39,320 --> 00:12:42,980
all work together in the Commons we see

00:12:41,090 --> 00:12:45,470
greater outcomes than any of us could

00:12:42,980 --> 00:12:49,970
get alone we also shipped a polyfill

00:12:45,470 --> 00:12:53,060
chunk in version 9.3 it reduced about 16

00:12:49,970 --> 00:12:56,840
K from the baseline of an XJS hello

00:12:53,060 --> 00:13:00,290
world app and we ship chat CSS

00:12:56,840 --> 00:13:03,320
prioritized over javascript in 9.2 that

00:13:00,290 --> 00:13:05,210
reduced FCP by up to 40% in our partner

00:13:03,320 --> 00:13:08,570
apps we're really excited to see that

00:13:05,210 --> 00:13:11,090
filter out to the rest of the next j/s

00:13:08,570 --> 00:13:15,100
ecosystem so that we can find out if it

00:13:11,090 --> 00:13:17,570
has similar effects on other web sites

00:13:15,100 --> 00:13:19,220
we also added out-of-the-box perf

00:13:17,570 --> 00:13:21,860
metrics should be talked to you a lot

00:13:19,220 --> 00:13:23,570
about the web vital metrics that have

00:13:21,860 --> 00:13:25,820
been recently released

00:13:23,570 --> 00:13:29,270
we added them to next jeaious out of the

00:13:25,820 --> 00:13:31,100
box so an application that wants to

00:13:29,270 --> 00:13:34,010
measure their performance doesn't have

00:13:31,100 --> 00:13:35,660
to actually do it individually they have

00:13:34,010 --> 00:13:37,220
it baked in and they just need to turn

00:13:35,660 --> 00:13:40,190
it on and point those metrics where

00:13:37,220 --> 00:13:42,350
they'd like to get them the other piece

00:13:40,190 --> 00:13:45,470
of that is that we added a couple new

00:13:42,350 --> 00:13:47,800
metrics time to hydration which measures

00:13:45,470 --> 00:13:50,360
something like interaction readiness and

00:13:47,800 --> 00:13:54,260
time to route render which is sort of

00:13:50,360 --> 00:13:56,600
like an SP a navigation metric those are

00:13:54,260 --> 00:13:58,790
two areas where we hope that what vitals

00:13:56,600 --> 00:14:00,860
metrics can grow in the future and so

00:13:58,790 --> 00:14:05,630
we're testing them out ahead of time in

00:14:00,860 --> 00:14:08,570
next j/s apps we also tested reax

00:14:05,630 --> 00:14:11,510
concurrent mode with a partner app for

00:14:08,570 --> 00:14:13,280
SEL and we found a fifty to seventy-five

00:14:11,510 --> 00:14:15,500
percent improvement in interaction

00:14:13,280 --> 00:14:18,650
readiness for the first interaction and

00:14:15,500 --> 00:14:23,960
we found similar improvements in total

00:14:18,650 --> 00:14:27,110
blocking time and also saw improvements

00:14:23,960 --> 00:14:29,330
in lighthouse score and metrics but we

00:14:27,110 --> 00:14:32,390
realized as well that the upgrade path

00:14:29,330 --> 00:14:35,120
is non-trivial for apps our hope is that

00:14:32,390 --> 00:14:40,550
we can make the upgrade smoother by

00:14:35,120 --> 00:14:42,740
baking in some defaults into the SDKs so

00:14:40,550 --> 00:14:47,710
that other developers benefit from our

00:14:42,740 --> 00:14:50,600
experience upgrading to concurrent

00:14:47,710 --> 00:14:52,490
there's a trade-off between developer

00:14:50,600 --> 00:14:55,400
experience and user experience in a lot

00:14:52,490 --> 00:14:56,990
of cases it's hard to fix loading

00:14:55,400 --> 00:14:58,730
performance wholesale without a

00:14:56,990 --> 00:15:01,190
significant change to developer

00:14:58,730 --> 00:15:04,610
experience when should be made these

00:15:01,190 --> 00:15:06,470
changes at Google they were able to make

00:15:04,610 --> 00:15:09,050
the head completely declarative and

00:15:06,470 --> 00:15:10,730
configuration driven that means that any

00:15:09,050 --> 00:15:13,250
change to the head was explicitly

00:15:10,730 --> 00:15:16,640
declared in a manifest file and the

00:15:13,250 --> 00:15:19,280
configuration had defaults for example

00:15:16,640 --> 00:15:20,900
for fonts and CSS it also had an

00:15:19,280 --> 00:15:23,660
ordering and loading strategy that was

00:15:20,900 --> 00:15:25,610
controlled by the framework developers

00:15:23,660 --> 00:15:28,670
like writing code and they really don't

00:15:25,610 --> 00:15:30,200
like updating config files so this was a

00:15:28,670 --> 00:15:32,450
trade-off that could be made at Google

00:15:30,200 --> 00:15:34,340
but might not stand up in the ecosystem

00:15:32,450 --> 00:15:36,200
work idiomatic developer experiment

00:15:34,340 --> 00:15:38,210
experiences paramount for developer

00:15:36,200 --> 00:15:40,670
mindshare

00:15:38,210 --> 00:15:42,230
the lesson we take from that is that

00:15:40,670 --> 00:15:43,940
it's important to maintain that

00:15:42,230 --> 00:15:46,940
developer experience and at the same

00:15:43,940 --> 00:15:49,940
time improve user experience developer

00:15:46,940 --> 00:15:51,680
experience is gold for the web it means

00:15:49,940 --> 00:15:52,940
that developers will choose to and want

00:15:51,680 --> 00:15:54,680
to work on the web we'll continue

00:15:52,940 --> 00:15:58,610
working on the web once they've gotten

00:15:54,680 --> 00:16:00,050
started and it gets new dos up and

00:15:58,610 --> 00:16:03,140
running and building great features

00:16:00,050 --> 00:16:06,710
faster it's also important for content

00:16:03,140 --> 00:16:08,420
diversity so clearly compromising

00:16:06,710 --> 00:16:10,310
developer experience is a risk to the

00:16:08,420 --> 00:16:12,680
web as a platform and it has to be very

00:16:10,310 --> 00:16:15,050
thoughtfully considered for one we need

00:16:12,680 --> 00:16:19,100
to absolutely stop asking developers to

00:16:15,050 --> 00:16:22,100
abandon their tools and frameworks so

00:16:19,100 --> 00:16:24,880
what's next in 2020 for our project

00:16:22,100 --> 00:16:27,740
we're gonna look at critical inlining of

00:16:24,880 --> 00:16:29,630
CSS we're going to look at font

00:16:27,740 --> 00:16:31,820
optimizations and third-party script

00:16:29,630 --> 00:16:34,790
scheduling we're also looking at

00:16:31,820 --> 00:16:36,680
screaming streaming and more developer

00:16:34,790 --> 00:16:38,990
time guardrails that are built into web

00:16:36,680 --> 00:16:41,690
pack es lint and probably into other

00:16:38,990 --> 00:16:44,150
bits of the stack as well we're looking

00:16:41,690 --> 00:16:46,640
at images around sizing and scaling and

00:16:44,150 --> 00:16:49,850
image placeholders also polyfill

00:16:46,640 --> 00:16:51,470
delivery data fetching and reax

00:16:49,850 --> 00:16:54,020
concurrent mode we'll be digging into

00:16:51,470 --> 00:16:56,240
that further will all of that work

00:16:54,020 --> 00:16:58,790
almost certainly not but we're excited

00:16:56,240 --> 00:17:00,530
to see some of it turnout performance

00:16:58,790 --> 00:17:04,970
improvements through the end of the year

00:17:00,530 --> 00:17:06,500
so when I go back to this we really

00:17:04,970 --> 00:17:08,810
think that we can get to a place where

00:17:06,500 --> 00:17:11,810
much less assembly is required for a

00:17:08,810 --> 00:17:13,940
developer on the web and all different

00:17:11,810 --> 00:17:18,230
kinds of developers can produce great

00:17:13,940 --> 00:17:19,640
user experience thanks so much for

00:17:18,230 --> 00:17:21,560
having us here today these are our

00:17:19,640 --> 00:17:23,830
twitter handles and we'd love to talk to

00:17:21,560 --> 00:17:23,830

YouTube URL: https://www.youtube.com/watch?v=9Joy4w5mS-k


