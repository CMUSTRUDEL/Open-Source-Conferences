Title: What the AST? - Dominik Kundel, Twilio
Publication date: 2020-06-17
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:04,430 --> 00:00:12,150
hi there and thank you for joining my

00:00:07,229 --> 00:00:14,700
talk what the ast I like starting my

00:00:12,150 --> 00:00:18,230
talks off with a question um and I know

00:00:14,700 --> 00:00:22,410
raising raising your hand in this

00:00:18,230 --> 00:00:23,940
virtual talk is really difficult but I

00:00:22,410 --> 00:00:26,430
still want you to either participate in

00:00:23,940 --> 00:00:28,200
the chat or at least you know think

00:00:26,430 --> 00:00:31,500
about this question have you ever used

00:00:28,200 --> 00:00:35,010
one of these tools angular webpack is

00:00:31,500 --> 00:00:38,129
land prettier parcel view typescript

00:00:35,010 --> 00:00:40,559
Babel because in the next 30 minutes I

00:00:38,129 --> 00:00:42,089
want to talk to you about what these

00:00:40,559 --> 00:00:44,820
tools have in common what they're using

00:00:42,089 --> 00:00:47,399
under the hood why these concepts are

00:00:44,820 --> 00:00:49,530
useful for you to know even if you're

00:00:47,399 --> 00:00:52,969
not trying to build the next

00:00:49,530 --> 00:00:55,800
yes Lynde web pack or similar tool and

00:00:52,969 --> 00:00:58,170
also why it's just generally useful to

00:00:55,800 --> 00:00:59,489
have this in your tool belt before we

00:00:58,170 --> 00:01:02,010
started I want to briefly introduce

00:00:59,489 --> 00:01:03,719
myself my name is Dominic I work as a

00:01:02,010 --> 00:01:05,759
developer evangelist at a company called

00:01:03,719 --> 00:01:07,619
Twilio if you haven't heard of Twilio

00:01:05,759 --> 00:01:11,250
we're cloud communications platform

00:01:07,619 --> 00:01:12,630
meaning we have api's and SDKs to allow

00:01:11,250 --> 00:01:15,570
you to integrate different means of

00:01:12,630 --> 00:01:17,969
communication such as voice video SMS

00:01:15,570 --> 00:01:20,820
email two-factor authentication or

00:01:17,969 --> 00:01:22,890
similar into your applications my

00:01:20,820 --> 00:01:24,450
pronouns are he and him and you can find

00:01:22,890 --> 00:01:26,759
me anywhere on the internet under D

00:01:24,450 --> 00:01:31,950
kondal so feel free to send me an email

00:01:26,759 --> 00:01:35,399
or DM on Twitter so I want you to think

00:01:31,950 --> 00:01:38,280
about how do we modify and find code on

00:01:35,399 --> 00:01:40,350
a regular basis typically the way at

00:01:38,280 --> 00:01:41,729
least it works for me if I'm trying to

00:01:40,350 --> 00:01:44,369
find something in my project and I'm

00:01:41,729 --> 00:01:46,140
trying to batch fix it is the first

00:01:44,369 --> 00:01:49,049
thing I'm gonna try is command or

00:01:46,140 --> 00:01:51,179
control F that works pretty well if

00:01:49,049 --> 00:01:53,130
you're trying to find like want a

00:01:51,179 --> 00:01:54,899
variable once the moment you're trying

00:01:53,130 --> 00:01:57,000
to use it more often and you're trying

00:01:54,899 --> 00:01:58,740
to replace it in a bunch of files it

00:01:57,000 --> 00:02:01,109
gets it gets more tricky and you're

00:01:58,740 --> 00:02:02,670
starting to try to fiddle around with

00:02:01,109 --> 00:02:04,829
settings and hoping that you're not

00:02:02,670 --> 00:02:06,600
modifying too much or too little and

00:02:04,829 --> 00:02:09,300
that your test hopefully will catch any

00:02:06,600 --> 00:02:12,330
things you might be breaking and so that

00:02:09,300 --> 00:02:14,620
can be incredibly frustrating especially

00:02:12,330 --> 00:02:20,049
if you have to do the same thing

00:02:14,620 --> 00:02:22,090
all times and so the way you might

00:02:20,049 --> 00:02:25,299
resort to solving that at least

00:02:22,090 --> 00:02:27,580
personally is to go the route of writing

00:02:25,299 --> 00:02:29,560
a bash script or something similar that

00:02:27,580 --> 00:02:32,200
uses tools like grab we're sad to fix

00:02:29,560 --> 00:02:34,000
things on a regular basis but that means

00:02:32,200 --> 00:02:36,819
you need to use regular expressions and

00:02:34,000 --> 00:02:38,829
similar things to kind of duct-tape

00:02:36,819 --> 00:02:40,480
things together and at least I don't

00:02:38,829 --> 00:02:42,250
feel that confident with regular

00:02:40,480 --> 00:02:44,980
expressions as much as I use them in the

00:02:42,250 --> 00:02:47,739
past there's always things where it was

00:02:44,980 --> 00:02:49,690
either too flexible or too strict and I

00:02:47,739 --> 00:02:51,359
kept fiddling around with it and it

00:02:49,690 --> 00:02:54,040
wasn't catching the right things and

00:02:51,359 --> 00:02:57,010
that means we're building tools of the

00:02:54,040 --> 00:02:58,599
unreliable and hard to maintain to deal

00:02:57,010 --> 00:03:00,540
with our code bases and that's not a

00:02:58,599 --> 00:03:03,010
great feeling at least for me personally

00:03:00,540 --> 00:03:05,170
but that also gets me back to the tools

00:03:03,010 --> 00:03:06,459
that we use on a regular basis because

00:03:05,170 --> 00:03:09,700
all of these have something in common

00:03:06,459 --> 00:03:12,879
with find and replace and that is they

00:03:09,700 --> 00:03:16,120
take some code run some magic on it and

00:03:12,879 --> 00:03:18,730
produce some output and I want to talk

00:03:16,120 --> 00:03:20,620
to you about exactly that said magic and

00:03:18,730 --> 00:03:22,930
in order to talk to you about that magic

00:03:20,620 --> 00:03:25,450
we first need to talk about how the

00:03:22,930 --> 00:03:27,700
compiler works because effectively all

00:03:25,450 --> 00:03:29,889
of these tools use the same concept

00:03:27,700 --> 00:03:31,840
under the hood if you've never worked

00:03:29,889 --> 00:03:33,970
with a compact or never looked at how a

00:03:31,840 --> 00:03:35,829
compiler works under the hood that's

00:03:33,970 --> 00:03:39,819
okay we'll still cover it step-by-step

00:03:35,829 --> 00:03:41,919
so you should be able to keep up the

00:03:39,819 --> 00:03:45,190
first thing here is we have some input

00:03:41,919 --> 00:03:48,160
in this case for example new symbol 1

00:03:45,190 --> 00:03:50,440
and the compiler will perform what is

00:03:48,160 --> 00:03:53,769
called a lexical analysis on that that

00:03:50,440 --> 00:03:55,349
means it will turn that text into a set

00:03:53,769 --> 00:03:57,579
of tokens so a list of tokens

00:03:55,349 --> 00:03:59,590
representing the different parts of the

00:03:57,579 --> 00:04:01,870
code that we have you can imagine this

00:03:59,590 --> 00:04:03,790
being the equivalent of taking a text

00:04:01,870 --> 00:04:06,180
written in English and then turning it

00:04:03,790 --> 00:04:09,040
into a list of words and punctuation and

00:04:06,180 --> 00:04:10,930
then the next step is to perform syntax

00:04:09,040 --> 00:04:12,699
analysis on this so that means we're

00:04:10,930 --> 00:04:15,190
taking the tokens that we already have

00:04:12,699 --> 00:04:17,500
and creating some structure around them

00:04:15,190 --> 00:04:20,440
in the shape of an ast so an abstract

00:04:17,500 --> 00:04:23,080
syntax tree that represents how the

00:04:20,440 --> 00:04:26,289
program is actually structured so

00:04:23,080 --> 00:04:27,810
imagine this as if you're turning words

00:04:26,289 --> 00:04:30,660
and punctuation

00:04:27,810 --> 00:04:33,330
two sentences representing as part of

00:04:30,660 --> 00:04:36,389
paragraphs and those sentences contain

00:04:33,330 --> 00:04:38,880
information of what what part is the

00:04:36,389 --> 00:04:40,710
subject what part is a verb you know in

00:04:38,880 --> 00:04:42,990
giving all of that detailed information

00:04:40,710 --> 00:04:43,710
rather than just having a list of words

00:04:42,990 --> 00:04:46,169
and punctuation

00:04:43,710 --> 00:04:48,780
and then you can perform actions on

00:04:46,169 --> 00:04:50,820
those ast s but then the last step is

00:04:48,780 --> 00:04:53,460
cogeneration so that means we're taking

00:04:50,820 --> 00:04:55,830
the ast and we're turning that into some

00:04:53,460 --> 00:04:58,800
output so this can be machine code this

00:04:55,830 --> 00:05:00,300
can be another programming language but

00:04:58,800 --> 00:05:03,450
generally we're turning it into some

00:05:00,300 --> 00:05:06,630
sort of output so now when we talked

00:05:03,450 --> 00:05:08,700
about how those general steps work in in

00:05:06,630 --> 00:05:10,350
the grander scheme of things let's dive

00:05:08,700 --> 00:05:12,630
into each of these steps have been more

00:05:10,350 --> 00:05:14,729
into detail so first step is lexical

00:05:12,630 --> 00:05:17,040
analysis you might also hear about it as

00:05:14,729 --> 00:05:19,020
tokenization so that means we're taking

00:05:17,040 --> 00:05:21,120
some example code and I don't want to

00:05:19,020 --> 00:05:23,400
use the classic hello world here since

00:05:21,120 --> 00:05:26,760
then I'm gonna use a function called yes

00:05:23,400 --> 00:05:28,979
panda because I love pandas and it

00:05:26,760 --> 00:05:31,800
receives one argument in this case a

00:05:28,979 --> 00:05:33,720
string with a panda emoji in it and we

00:05:31,800 --> 00:05:35,490
want to turn this into tokens so you

00:05:33,720 --> 00:05:36,870
could build your own tokenizer but

00:05:35,490 --> 00:05:38,610
there's plenty of tokenizer is

00:05:36,870 --> 00:05:40,530
especially for javascript that you can

00:05:38,610 --> 00:05:41,220
use in my case I'm going to use this

00:05:40,530 --> 00:05:43,140
Prima

00:05:41,220 --> 00:05:45,510
and I'm gonna call tokenize on that and

00:05:43,140 --> 00:05:47,039
that will give us a list of tokens so

00:05:45,510 --> 00:05:48,180
that will look roughly like this I

00:05:47,039 --> 00:05:50,010
dropped a couple of pieces of

00:05:48,180 --> 00:05:52,860
information here to fit it on the slide

00:05:50,010 --> 00:05:55,229
like what are the line numbers and and

00:05:52,860 --> 00:05:58,080
things like that but roughly this is

00:05:55,229 --> 00:06:01,200
what you would get for tokens one is an

00:05:58,080 --> 00:06:03,750
identifier is panda to punctuate errs

00:06:01,200 --> 00:06:06,450
and opening and closing parentheses and

00:06:03,750 --> 00:06:09,570
in between it is a string that has the

00:06:06,450 --> 00:06:12,530
string value of a panda now this

00:06:09,570 --> 00:06:15,810
information if you've ever written a

00:06:12,530 --> 00:06:18,539
code editor theme or generally like a

00:06:15,810 --> 00:06:20,430
syntax highlighting theme you might be

00:06:18,539 --> 00:06:22,169
familiar with these words of identifiers

00:06:20,430 --> 00:06:24,690
punctuate or string because that's

00:06:22,169 --> 00:06:27,240
typically what is being used in real

00:06:24,690 --> 00:06:30,510
real practical examples such as syntax

00:06:27,240 --> 00:06:33,030
highlighting so most code editors use

00:06:30,510 --> 00:06:35,100
tokenization at some point to do some

00:06:33,030 --> 00:06:37,680
syntax highlighting some do additional

00:06:35,100 --> 00:06:39,870
work on top of that for more advanced

00:06:37,680 --> 00:06:41,340
highlighting but under the hood at least

00:06:39,870 --> 00:06:44,070
the basic syntax highlighting

00:06:41,340 --> 00:06:45,870
often done by tokenization the token

00:06:44,070 --> 00:06:49,760
formats might differ though so for

00:06:45,870 --> 00:06:54,270
example vias code did some extra work to

00:06:49,760 --> 00:06:57,810
do very to do employment and performance

00:06:54,270 --> 00:06:59,639
improvements on these syntax

00:06:57,810 --> 00:07:00,750
highlighting and tokenization part of

00:06:59,639 --> 00:07:03,350
things and if you want to read about

00:07:00,750 --> 00:07:05,760
that you can check out this blog post

00:07:03,350 --> 00:07:07,590
but once we have those tokens the next

00:07:05,760 --> 00:07:09,810
step would be to turn these tokens into

00:07:07,590 --> 00:07:12,330
an abstract syntax tree so that is the

00:07:09,810 --> 00:07:15,150
syntax parsing side of things so we take

00:07:12,330 --> 00:07:17,430
this list of tokens or list of objects

00:07:15,150 --> 00:07:19,820
and we turn them into a nested object

00:07:17,430 --> 00:07:22,470
that represents or of a tree of how our

00:07:19,820 --> 00:07:24,990
program is structured so at the top we

00:07:22,470 --> 00:07:26,910
have a program and then that has a body

00:07:24,990 --> 00:07:29,250
which in this case only as one

00:07:26,910 --> 00:07:32,070
expression statement which has a call

00:07:29,250 --> 00:07:34,320
expression in it that consists out of a

00:07:32,070 --> 00:07:36,330
collie which is what is being called and

00:07:34,320 --> 00:07:39,090
a set of arguments in this case only one

00:07:36,330 --> 00:07:42,810
argument which is a literal of append

00:07:39,090 --> 00:07:45,870
emoji the format that you've seen there

00:07:42,810 --> 00:07:48,780
is called es tree it's a spec that was

00:07:45,870 --> 00:07:51,060
derived of the ast format that Mozilla

00:07:48,780 --> 00:07:54,539
uses internally in their SpiderMonkey

00:07:51,060 --> 00:07:56,849
engine but it has been altered and

00:07:54,539 --> 00:08:00,139
extended from there so if you're using

00:07:56,849 --> 00:08:03,570
tools like esprima or babel they use

00:08:00,139 --> 00:08:05,430
derivatives offset spec but with some

00:08:03,570 --> 00:08:08,639
additions that help them with their

00:08:05,430 --> 00:08:10,560
functionality and goals and also

00:08:08,639 --> 00:08:13,229
Facebook and others have extended this

00:08:10,560 --> 00:08:15,960
to add functionality like JSX and others

00:08:13,229 --> 00:08:18,810
into the language to give you some

00:08:15,960 --> 00:08:21,180
practical examples of why you would want

00:08:18,810 --> 00:08:24,090
to have an ast in the first place is to

00:08:21,180 --> 00:08:27,510
visit the different nodes to do things

00:08:24,090 --> 00:08:29,669
such as linting so if you if you build a

00:08:27,510 --> 00:08:34,229
linter or use a linter such as es lin

00:08:29,669 --> 00:08:37,080
tears land or jazz hint you would want

00:08:34,229 --> 00:08:39,539
to do analysis often not just purely on

00:08:37,080 --> 00:08:41,909
the format of your code but you want

00:08:39,539 --> 00:08:44,130
more detailed rules that could for

00:08:41,909 --> 00:08:45,959
example be around how you name your

00:08:44,130 --> 00:08:48,150
classes and rather than having to look

00:08:45,959 --> 00:08:50,850
through an entire array to try to find

00:08:48,150 --> 00:08:52,950
the class keyword somewhere and then see

00:08:50,850 --> 00:08:55,020
what's following instead you could

00:08:52,950 --> 00:08:58,890
navigate a tree and look

00:08:55,020 --> 00:09:02,070
or class decorators class declarations

00:08:58,890 --> 00:09:04,280
and then see how they fit into the

00:09:02,070 --> 00:09:08,790
grander scheme so you can do much more

00:09:04,280 --> 00:09:10,890
advanced linting another example that

00:09:08,790 --> 00:09:14,240
sort of fits into that sound same realm

00:09:10,890 --> 00:09:16,680
is code analysis so for example angular

00:09:14,240 --> 00:09:18,960
uses this to build a language service

00:09:16,680 --> 00:09:21,030
that you can use in your code editor to

00:09:18,960 --> 00:09:23,160
get better autocomplete the way they're

00:09:21,030 --> 00:09:27,090
doing that is by returning their HTML

00:09:23,160 --> 00:09:29,160
templates into a STS and then being able

00:09:27,090 --> 00:09:31,890
to tell you based on where your cursor

00:09:29,160 --> 00:09:35,250
is and how your template is connected to

00:09:31,890 --> 00:09:37,500
your to your component what things are

00:09:35,250 --> 00:09:40,530
available and improve your autocomplete

00:09:37,500 --> 00:09:42,930
there another example is bundling so if

00:09:40,530 --> 00:09:45,150
you've used a bundler like web pack or

00:09:42,930 --> 00:09:47,160
partial before those are using STS under

00:09:45,150 --> 00:09:49,620
the hood because while bundling in the

00:09:47,160 --> 00:09:52,680
past might have been just concatenating

00:09:49,620 --> 00:09:55,890
javascript files these days in the world

00:09:52,680 --> 00:09:58,830
of components and modules and things

00:09:55,890 --> 00:10:01,320
like that you need to understand how how

00:09:58,830 --> 00:10:03,660
things fit together and you can do one

00:10:01,320 --> 00:10:06,630
on the one hand optimizations on this

00:10:03,660 --> 00:10:10,050
but you can also better you know fit

00:10:06,630 --> 00:10:12,150
things together without adding them in

00:10:10,050 --> 00:10:14,400
the wrong order and things like that and

00:10:12,150 --> 00:10:17,460
so that is exactly where as T's come

00:10:14,400 --> 00:10:19,170
into place the nice thing though about a

00:10:17,460 --> 00:10:21,210
estie's is that they are not only

00:10:19,170 --> 00:10:23,250
helpful when you're traversing the code

00:10:21,210 --> 00:10:25,680
but they're also incredibly helpful for

00:10:23,250 --> 00:10:30,600
modifying themselves because if you've

00:10:25,680 --> 00:10:33,090
ever had to modify a text or a list

00:10:30,600 --> 00:10:35,190
versus modifying an object you might

00:10:33,090 --> 00:10:37,920
know that it's easier to modify the

00:10:35,190 --> 00:10:39,990
object especially if you have to take

00:10:37,920 --> 00:10:42,120
things out in the middle of a program in

00:10:39,990 --> 00:10:43,890
the middle of an object versus taking

00:10:42,120 --> 00:10:47,220
things out of the middle of an array or

00:10:43,890 --> 00:10:49,560
the middle of a text so let's look at

00:10:47,220 --> 00:10:51,420
our ast again and in this case we can

00:10:49,560 --> 00:10:53,970
actually do an optimization here that

00:10:51,420 --> 00:10:56,640
would be a good use for modifying an ast

00:10:53,970 --> 00:10:59,550
um so if we look at the expression

00:10:56,640 --> 00:11:03,900
statement we have one expression in it

00:10:59,550 --> 00:11:06,990
it's a call expression and really we can

00:11:03,900 --> 00:11:08,410
see that if you call is Panda and you

00:11:06,990 --> 00:11:10,480
give it the value of a pen

00:11:08,410 --> 00:11:12,790
gyah will always be true so we can

00:11:10,480 --> 00:11:14,949
actually do an improvement here and take

00:11:12,790 --> 00:11:17,410
out that expression and replace it with

00:11:14,949 --> 00:11:20,350
just a literal that has the value true

00:11:17,410 --> 00:11:22,600
in it and therefore significantly

00:11:20,350 --> 00:11:24,490
shrinking our code and if you would do

00:11:22,600 --> 00:11:27,040
that same execution across your entire

00:11:24,490 --> 00:11:30,550
code base you know you would eliminate a

00:11:27,040 --> 00:11:32,529
bunch of code um so there's a bunch of

00:11:30,550 --> 00:11:35,079
practical examples but the one that

00:11:32,529 --> 00:11:36,819
might be most most familiar to you if

00:11:35,079 --> 00:11:39,220
you're writing JavaScript these days is

00:11:36,819 --> 00:11:43,149
Babel so they will actually use that

00:11:39,220 --> 00:11:45,550
concept in all of their transformations

00:11:43,149 --> 00:11:48,189
whether you're down transpiling or

00:11:45,550 --> 00:11:50,199
you're using some of the additional

00:11:48,189 --> 00:11:52,209
plugins that people have built if you're

00:11:50,199 --> 00:11:55,180
not familiar with Babel it's a down

00:11:52,209 --> 00:11:59,379
transpiler that allows you to take code

00:11:55,180 --> 00:12:01,750
that you might have used in a written in

00:11:59,379 --> 00:12:04,889
more modern JavaScript and transpile it

00:12:01,750 --> 00:12:07,870
to es5 or years three compatible

00:12:04,889 --> 00:12:11,379
javascript or compatible to exactly the

00:12:07,870 --> 00:12:13,149
browsers that you're targeting but you

00:12:11,379 --> 00:12:15,490
can also do things like extending a

00:12:13,149 --> 00:12:20,920
language so as I said jazz X does this

00:12:15,490 --> 00:12:23,649
we're really we're just having a ast

00:12:20,920 --> 00:12:26,680
that has these JS x tags in it and then

00:12:23,649 --> 00:12:28,750
we modify it to turn those jazz x tags

00:12:26,680 --> 00:12:31,720
into function calls because that's

00:12:28,750 --> 00:12:33,339
really how jazz X is implemented is all

00:12:31,720 --> 00:12:35,560
of these tags are being turned into

00:12:33,339 --> 00:12:40,410
function calls to things like react

00:12:35,560 --> 00:12:45,610
upgrade element or pre x-h function and

00:12:40,410 --> 00:12:48,579
then the third example is language

00:12:45,610 --> 00:12:52,509
transpiling so that means we're taking a

00:12:48,579 --> 00:12:54,670
language such as typescript and we're

00:12:52,509 --> 00:12:56,800
removing all of the typescript specific

00:12:54,670 --> 00:12:59,470
syntax so we can turn it into some

00:12:56,800 --> 00:13:01,750
JavaScript code that we can then execute

00:12:59,470 --> 00:13:04,360
now obviously typescript does a bunch of

00:13:01,750 --> 00:13:05,980
other things as well but that's for

00:13:04,360 --> 00:13:09,370
example how the babel transform for

00:13:05,980 --> 00:13:10,990
typescript works the one that I thought

00:13:09,370 --> 00:13:12,839
was really cool is code coverage if

00:13:10,990 --> 00:13:15,759
you've used code coverage in the past

00:13:12,839 --> 00:13:18,370
such as Istanbul for example you might

00:13:15,759 --> 00:13:20,199
have wondered how it actually works

00:13:18,370 --> 00:13:22,240
under the hood how it plugs into things

00:13:20,199 --> 00:13:24,130
and the

00:13:22,240 --> 00:13:27,250
wait does it we can actually look under

00:13:24,130 --> 00:13:31,029
the hood and that we can do that using

00:13:27,250 --> 00:13:33,760
the NYC CLI from histone bull by calling

00:13:31,029 --> 00:13:35,950
NYC instrument giving it of giving it a

00:13:33,760 --> 00:13:38,589
file and then giving it an output

00:13:35,950 --> 00:13:40,060
directory and looking at the output so

00:13:38,589 --> 00:13:41,680
let's say we have a some jazz file that

00:13:40,060 --> 00:13:44,980
we want a unit test we want to see how

00:13:41,680 --> 00:13:47,890
good our test coverage is we have this

00:13:44,980 --> 00:13:49,540
function in it called some that takes

00:13:47,890 --> 00:13:52,240
two parameters and adds it up and then

00:13:49,540 --> 00:13:55,120
we export that function now if we run

00:13:52,240 --> 00:13:56,740
and watch the instrument on this this is

00:13:55,120 --> 00:13:58,360
the code that we get out of it we have a

00:13:56,740 --> 00:14:00,610
variable declaration at the top that

00:13:58,360 --> 00:14:04,120
we'll look at in a second and then we

00:14:00,610 --> 00:14:08,170
have three edit counter incrementer x'

00:14:04,120 --> 00:14:11,589
added to it so we have two that end with

00:14:08,170 --> 00:14:14,040
s 0 and s 1 and 1 with F 0 and those are

00:14:11,589 --> 00:14:16,209
function and statement counters and

00:14:14,040 --> 00:14:18,149
basically that means if we're running

00:14:16,209 --> 00:14:22,839
our unit tests against this file instead

00:14:18,149 --> 00:14:24,459
we're able to actually tell how often

00:14:22,839 --> 00:14:25,720
functions have been called how often

00:14:24,459 --> 00:14:28,540
statements have been called because we

00:14:25,720 --> 00:14:30,550
can then look into that object that is

00:14:28,540 --> 00:14:33,310
at the top and there's a coverage data

00:14:30,550 --> 00:14:35,529
object as part of this that contains all

00:14:33,310 --> 00:14:37,630
of these counters for each of those

00:14:35,529 --> 00:14:40,870
segments for each of these statements

00:14:37,630 --> 00:14:43,149
functions and branches and also it

00:14:40,870 --> 00:14:46,029
contains a statement map a function map

00:14:43,149 --> 00:14:47,500
in the branch map so that later we can

00:14:46,029 --> 00:14:48,970
look at what are the statements

00:14:47,500 --> 00:14:52,779
functions and branches that have zero

00:14:48,970 --> 00:14:55,300
counters and then inform the user

00:14:52,779 --> 00:14:59,110
exactly which ones haven't been called

00:14:55,300 --> 00:15:00,430
and where they are now if you want to

00:14:59,110 --> 00:15:02,770
learn more about the code coverage

00:15:00,430 --> 00:15:04,600
aspect there's a great blog post that I

00:15:02,770 --> 00:15:06,190
recommend recommend you to read that

00:15:04,600 --> 00:15:09,370
dies a bit more into that ast

00:15:06,190 --> 00:15:12,040
transformation another example is

00:15:09,370 --> 00:15:14,880
running other languages and browsers so

00:15:12,040 --> 00:15:18,700
I'm not talking about web assembly here

00:15:14,880 --> 00:15:21,220
but instead I'm talking about a pretty

00:15:18,700 --> 00:15:23,649
concrete example of code combat so I

00:15:21,220 --> 00:15:28,060
worked on code combat a couple of years

00:15:23,649 --> 00:15:29,860
ago as Google Summer of Code and one

00:15:28,060 --> 00:15:31,390
thing they do is they aim at teaching

00:15:29,860 --> 00:15:34,410
kids how to code using different

00:15:31,390 --> 00:15:36,010
programming languages such as Python or

00:15:34,410 --> 00:15:39,190
JavaScript or coffee

00:15:36,010 --> 00:15:41,530
script or Lua and they don't they

00:15:39,190 --> 00:15:43,330
execute all of the code inside the

00:15:41,530 --> 00:15:46,900
browser but they're doing that without

00:15:43,330 --> 00:15:52,080
shipping a an entire Python runtime or

00:15:46,900 --> 00:15:54,460
an entire CoffeeScript runtime instead

00:15:52,080 --> 00:15:56,890
they use a tool called Esper that they

00:15:54,460 --> 00:15:58,990
built that takes some Python code for

00:15:56,890 --> 00:16:00,880
example on the left and converts that

00:15:58,990 --> 00:16:05,980
into an ast that looks similar to the

00:16:00,880 --> 00:16:09,490
JavaScript one and then modify that that

00:16:05,980 --> 00:16:12,520
ast to fix function calls that might be

00:16:09,490 --> 00:16:15,550
different in JavaScript so for example

00:16:12,520 --> 00:16:17,380
we have a print function call here which

00:16:15,550 --> 00:16:19,120
the equivalent will be constant locks on

00:16:17,380 --> 00:16:20,770
the right side in the ast you can

00:16:19,120 --> 00:16:26,680
actually see there's a call expression

00:16:20,770 --> 00:16:28,480
to console.log and it also gives you

00:16:26,680 --> 00:16:31,980
some additional information so that they

00:16:28,480 --> 00:16:34,960
can do frame execution and kind of like

00:16:31,980 --> 00:16:37,900
step through things without having to

00:16:34,960 --> 00:16:39,880
teach kids how a debugger works but all

00:16:37,900 --> 00:16:42,070
of that is powered by AST isn't that

00:16:39,880 --> 00:16:43,870
super powerful it's not performant

00:16:42,070 --> 00:16:46,060
necessarily you're not you wouldn't want

00:16:43,870 --> 00:16:48,310
to do this to execute production code in

00:16:46,060 --> 00:16:50,890
the browser but I still think it's a

00:16:48,310 --> 00:16:53,320
very cool application once you've

00:16:50,890 --> 00:16:56,500
modified your ast the last step is

00:16:53,320 --> 00:16:59,080
rendering your ast so that means we're

00:16:56,500 --> 00:17:01,810
turning it into output so we have for

00:16:59,080 --> 00:17:04,089
example our optimized ast here now and

00:17:01,810 --> 00:17:06,850
we want to turn that into some code so

00:17:04,089 --> 00:17:09,480
we'll use a library such as yes coach

00:17:06,850 --> 00:17:13,750
and that knows how to turn an ast into

00:17:09,480 --> 00:17:15,430
some code and then we just get the

00:17:13,750 --> 00:17:18,520
statement true because that's how we

00:17:15,430 --> 00:17:20,230
optimized it there's some really

00:17:18,520 --> 00:17:22,660
practical examples that I personally

00:17:20,230 --> 00:17:25,000
love using one of them is called

00:17:22,660 --> 00:17:27,130
prettier if you haven't use prettier

00:17:25,000 --> 00:17:29,530
it's a code formatting tool if you've

00:17:27,130 --> 00:17:31,900
used prettier you might have been as

00:17:29,530 --> 00:17:34,390
excited about as I am and the reason why

00:17:31,900 --> 00:17:37,060
it works so well is because it takes

00:17:34,390 --> 00:17:39,370
your code converts it into an ast and

00:17:37,060 --> 00:17:41,710
then reprints it based on its own

00:17:39,370 --> 00:17:43,810
instructions which means that it doesn't

00:17:41,710 --> 00:17:46,690
really care in which way you wrote your

00:17:43,810 --> 00:17:48,920
initial code or it doesn't screw up your

00:17:46,690 --> 00:17:52,730
code by writing it in the wrong

00:17:48,920 --> 00:17:54,800
whay doesn't just randomly insert new

00:17:52,730 --> 00:17:57,410
lines instead it fully understands your

00:17:54,800 --> 00:17:59,750
code and just prints it based on the

00:17:57,410 --> 00:18:02,330
rules you gave it and so that's really

00:17:59,750 --> 00:18:05,450
cool and minification works in a very

00:18:02,330 --> 00:18:07,220
similar way like it's just taking an ast

00:18:05,450 --> 00:18:09,860
and they might do some modifications on

00:18:07,220 --> 00:18:12,530
the aste to change variable names or

00:18:09,860 --> 00:18:15,950
similar things but then it just prints

00:18:12,530 --> 00:18:18,350
it out into a minified way rather than

00:18:15,950 --> 00:18:22,540
just removing white spaces because that

00:18:18,350 --> 00:18:22,540
could cause trouble in some situations

00:18:22,780 --> 00:18:28,460
but let's say you're not planning to

00:18:25,640 --> 00:18:31,690
build a next web pack or bat babel or

00:18:28,460 --> 00:18:35,180
similar why would you care about this

00:18:31,690 --> 00:18:36,920
one of the good examples that I think we

00:18:35,180 --> 00:18:38,660
can know we might all be able to

00:18:36,920 --> 00:18:40,610
leverage our babel transform plug-ins

00:18:38,660 --> 00:18:43,100
you don't necessarily have to build one

00:18:40,610 --> 00:18:45,740
for a new cutting-edge feature those can

00:18:43,100 --> 00:18:49,240
be useful for just improving your own

00:18:45,740 --> 00:18:51,950
day to day to day developer experience

00:18:49,240 --> 00:18:53,090
without having to use grab or said and

00:18:51,950 --> 00:18:55,430
without having to use regular

00:18:53,090 --> 00:18:58,430
expressions while at least less regular

00:18:55,430 --> 00:19:01,010
expressions a good similar example is

00:18:58,430 --> 00:19:02,900
what reactive react as a project called

00:19:01,010 --> 00:19:04,610
react code mod that is powered by

00:19:02,900 --> 00:19:06,910
another tool that Facebook built called

00:19:04,610 --> 00:19:08,900
J's code shift which works similar to

00:19:06,910 --> 00:19:12,740
Babel in terms of like building

00:19:08,900 --> 00:19:14,750
transform plugins but they have an

00:19:12,740 --> 00:19:18,710
entire library of different scripts that

00:19:14,750 --> 00:19:21,740
you can run to update your code based

00:19:18,710 --> 00:19:24,410
for the latest react api's and similar

00:19:21,740 --> 00:19:26,570
things and so that is super useful

00:19:24,410 --> 00:19:28,430
because if you feel like you're doing

00:19:26,570 --> 00:19:30,830
something on a regular basis or you want

00:19:28,430 --> 00:19:33,230
to have certain macros as part of your

00:19:30,830 --> 00:19:35,510
code base you know as your code base is

00:19:33,230 --> 00:19:39,590
growing these tools can be hugely useful

00:19:35,510 --> 00:19:42,350
for you and so I figured rather than

00:19:39,590 --> 00:19:45,350
talking more about this we would

00:19:42,350 --> 00:19:48,200
actually build a plug-in together so

00:19:45,350 --> 00:19:51,650
this is a website called ast Explorer

00:19:48,200 --> 00:19:53,750
that I personally love using to

00:19:51,650 --> 00:19:56,330
understand highest ease work and play

00:19:53,750 --> 00:20:02,300
around with them so let's clean up some

00:19:56,330 --> 00:20:04,160
things here the top left corner is a

00:20:02,300 --> 00:20:06,200
where we put our input code the bottom

00:20:04,160 --> 00:20:10,700
right corner is where our output code is

00:20:06,200 --> 00:20:13,250
the top right is where we see the ast

00:20:10,700 --> 00:20:16,400
and then on the bottom left we can

00:20:13,250 --> 00:20:21,130
change a bill to our transform plugin we

00:20:16,400 --> 00:20:23,600
chose here already the baby lawn 7

00:20:21,130 --> 00:20:28,190
parser that's the one that babel uses

00:20:23,600 --> 00:20:30,440
and we have babel v7 here as the

00:20:28,190 --> 00:20:35,510
transform you can go for example choose

00:20:30,440 --> 00:20:37,730
JS code shift here and so if you're a

00:20:35,510 --> 00:20:41,510
JavaScript developer like me chances are

00:20:37,730 --> 00:20:44,600
high you use console.log - you know

00:20:41,510 --> 00:20:46,970
debug your things but I was thinking the

00:20:44,600 --> 00:20:50,000
other day of like console.log is sort of

00:20:46,970 --> 00:20:51,500
like the general debugging way then I

00:20:50,000 --> 00:20:56,660
would say breakpoints is probably

00:20:51,500 --> 00:21:01,550
alerting so let's use this alert

00:20:56,660 --> 00:21:02,930
statement here sorry for that and what

00:21:01,550 --> 00:21:05,900
we want to do is we want to make sure

00:21:02,930 --> 00:21:08,120
we're not actually shipping any alert

00:21:05,900 --> 00:21:09,770
statements to our customers because why

00:21:08,120 --> 00:21:11,600
they might be useful for us during

00:21:09,770 --> 00:21:12,890
development we definitely don't want

00:21:11,600 --> 00:21:14,960
them to break the experience for

00:21:12,890 --> 00:21:17,510
customers so we're gonna build a babel

00:21:14,960 --> 00:21:20,240
plugin that will remove or change all

00:21:17,510 --> 00:21:21,650
alert statements to console errors so we

00:21:20,240 --> 00:21:24,920
don't have to worry about them and they

00:21:21,650 --> 00:21:28,400
just pop up in the logs the way we do

00:21:24,920 --> 00:21:31,400
this is by defining a visitor here so

00:21:28,400 --> 00:21:34,400
visitors are different functions based

00:21:31,400 --> 00:21:36,470
on different types of notes that babel

00:21:34,400 --> 00:21:38,990
might encounter so that we can tell it

00:21:36,470 --> 00:21:40,610
what to do during those so if we

00:21:38,990 --> 00:21:42,740
actually click on the alert here we can

00:21:40,610 --> 00:21:44,900
see it's an identifier but it's wrapped

00:21:42,740 --> 00:21:46,010
in a call expression and this call

00:21:44,900 --> 00:21:48,800
expression is really what we're

00:21:46,010 --> 00:21:51,860
interested in and so we're gonna create

00:21:48,800 --> 00:21:54,740
a visitor here called call expression

00:21:51,860 --> 00:21:56,570
and it's a function that receives a path

00:21:54,740 --> 00:21:59,600
every time it was encountered that's

00:21:56,570 --> 00:22:02,650
what we get and so the first thing we

00:21:59,600 --> 00:22:05,870
want to do here is let's just rename

00:22:02,650 --> 00:22:08,570
name this so path that node and then if

00:22:05,870 --> 00:22:11,050
we go here the collie is what we want to

00:22:08,570 --> 00:22:14,120
change so we're gonna create a new

00:22:11,050 --> 00:22:15,380
identifier here I'm just gonna call this

00:22:14,120 --> 00:22:18,410
console to err

00:22:15,380 --> 00:22:22,310
and now we can see on the right here

00:22:18,410 --> 00:22:25,100
that we have consul air apply to both of

00:22:22,310 --> 00:22:27,290
these not just cut not just to alert and

00:22:25,100 --> 00:22:29,210
that means we need to first filter what

00:22:27,290 --> 00:22:32,720
we're actually doing so I'm gonna

00:22:29,210 --> 00:22:35,630
actually filter for I'm gonna do serve

00:22:32,720 --> 00:22:40,730
like what is called an early exit so I'm

00:22:35,630 --> 00:22:44,360
gonna check if we have an identifier as

00:22:40,730 --> 00:22:49,610
part of the collie and has a name of

00:22:44,360 --> 00:22:52,040
alert and because I said we're gonna do

00:22:49,610 --> 00:22:55,820
an early accent actually want to return

00:22:52,040 --> 00:22:57,320
if this is not the case so if we don't

00:22:55,820 --> 00:23:00,200
have an identifier with the alert

00:22:57,320 --> 00:23:02,930
statement I forgot a closing parenthesis

00:23:00,200 --> 00:23:04,250
here then we want to change it to

00:23:02,930 --> 00:23:06,380
console errors so now you can see

00:23:04,250 --> 00:23:09,950
console log state but console error

00:23:06,380 --> 00:23:13,250
didn't learn didn't so change it to your

00:23:09,950 --> 00:23:15,590
console error and this works even if we

00:23:13,250 --> 00:23:20,690
have this inside of function for example

00:23:15,590 --> 00:23:23,330
so if we do alert here we can see it's

00:23:20,690 --> 00:23:25,850
still adjusting that so that's great but

00:23:23,330 --> 00:23:28,640
and similarly you know if we would break

00:23:25,850 --> 00:23:30,170
this up over multiple lines this is

00:23:28,640 --> 00:23:32,900
still working we didn't have to work

00:23:30,170 --> 00:23:34,280
around you know any formatting things

00:23:32,900 --> 00:23:37,490
like you would have to when you write a

00:23:34,280 --> 00:23:40,760
regular expression for example now the

00:23:37,490 --> 00:23:44,840
problem though comes when we do things

00:23:40,760 --> 00:23:49,550
such as for example redefining a local

00:23:44,840 --> 00:23:53,660
function here that just throws an error

00:23:49,550 --> 00:23:55,430
for example or let's do return alert so

00:23:53,660 --> 00:23:57,710
this this is just a local function that

00:23:55,430 --> 00:24:00,710
we defined meaning that this alert here

00:23:57,710 --> 00:24:03,530
is actually externally actually right we

00:24:00,710 --> 00:24:06,140
want to keep this and not replace this

00:24:03,530 --> 00:24:08,420
with console error so the cool thing

00:24:06,140 --> 00:24:10,790
with tools like babel and others of our

00:24:08,420 --> 00:24:13,160
AST part is we have much wonder standing

00:24:10,790 --> 00:24:15,860
of the code this will be really hard to

00:24:13,160 --> 00:24:19,910
do with just regular expressions and

00:24:15,860 --> 00:24:22,430
token tokenization for example but in

00:24:19,910 --> 00:24:23,720
the case of babel we have access to the

00:24:22,430 --> 00:24:27,500
scope and that means we can check for

00:24:23,720 --> 00:24:28,909
bindings which means is there a binding

00:24:27,500 --> 00:24:32,299
for the word

00:24:28,909 --> 00:24:35,809
here and if there is we just want to

00:24:32,299 --> 00:24:37,610
return so that means the alert inside

00:24:35,809 --> 00:24:39,440
this run function is never actually

00:24:37,610 --> 00:24:42,799
changed while the global one is still

00:24:39,440 --> 00:24:45,409
being changed we can take this one step

00:24:42,799 --> 00:24:46,879
further I don't like the fact that you

00:24:45,409 --> 00:24:49,549
know we still have an alert here and

00:24:46,879 --> 00:24:51,350
that could cause some confusion in the

00:24:49,549 --> 00:24:55,450
output so what we're going to do is we

00:24:51,350 --> 00:24:59,419
actually gonna rename inside the scope

00:24:55,450 --> 00:25:00,559
we're going to rename alert and what

00:24:59,419 --> 00:25:01,460
this is going to do is it's going to

00:25:00,559 --> 00:25:04,789
change

00:25:01,460 --> 00:25:06,830
alert to a unique name in this case that

00:25:04,789 --> 00:25:08,600
still is as close to alert as possible

00:25:06,830 --> 00:25:11,389
so it starts by putting an underscore

00:25:08,600 --> 00:25:15,759
there but if we would for example define

00:25:11,389 --> 00:25:20,179
a variable here now called alert

00:25:15,759 --> 00:25:23,360
underscore alert it would change it to

00:25:20,179 --> 00:25:25,309
alert two and then similarly if we would

00:25:23,360 --> 00:25:28,610
have another one here

00:25:25,309 --> 00:25:31,039
alert two it would change it to alert

00:25:28,610 --> 00:25:33,169
three and similar it will always try to

00:25:31,039 --> 00:25:35,509
avoid a clash in the in the respective

00:25:33,169 --> 00:25:38,240
scope in which we rename this so that's

00:25:35,509 --> 00:25:40,340
super useful because we don't have to

00:25:38,240 --> 00:25:43,629
worry about creating clashing variable

00:25:40,340 --> 00:25:45,860
names as we're changing our code here

00:25:43,629 --> 00:25:48,830
similarly you know we can for example

00:25:45,860 --> 00:25:50,869
modify the code entirely if we see the

00:25:48,830 --> 00:25:52,850
global ones and we just remove the node

00:25:50,869 --> 00:25:54,919
there's a lot of different things you

00:25:52,850 --> 00:25:58,279
can do you can insert other things you

00:25:54,919 --> 00:25:59,990
can modify things based on various

00:25:58,279 --> 00:26:01,519
different rules if you want to learn all

00:25:59,990 --> 00:26:01,820
of the different things you can do with

00:26:01,519 --> 00:26:03,470
it

00:26:01,820 --> 00:26:06,289
I would recommend you to check out the

00:26:03,470 --> 00:26:07,610
babel plugin handbook because as much as

00:26:06,289 --> 00:26:08,960
it hasn't been edited for a while

00:26:07,610 --> 00:26:11,600
there's a lot of really useful

00:26:08,960 --> 00:26:14,360
information in there in terms of what

00:26:11,600 --> 00:26:17,529
you can do how you can replace you know

00:26:14,360 --> 00:26:19,759
one node with multiple nodes how you can

00:26:17,529 --> 00:26:22,759
replace it with a source string if you

00:26:19,759 --> 00:26:26,720
don't want to build an entire entire

00:26:22,759 --> 00:26:28,639
tree just by using additional notes and

00:26:26,720 --> 00:26:30,230
generating those so there's a lot of

00:26:28,639 --> 00:26:31,639
things you can do and I recommend you to

00:26:30,230 --> 00:26:34,309
check out that handbook if you're

00:26:31,639 --> 00:26:35,890
interested in exploring more things you

00:26:34,309 --> 00:26:38,559
can do with it

00:26:35,890 --> 00:26:40,850
all right let's get back into the slides

00:26:38,559 --> 00:26:43,340
to wrap things up

00:26:40,850 --> 00:26:45,260
so in summary there's a few things I

00:26:43,340 --> 00:26:48,350
want you to take away one you already

00:26:45,260 --> 00:26:50,929
use tokens and a sts daily they're in

00:26:48,350 --> 00:26:52,669
all of the tools basically then make

00:26:50,929 --> 00:26:55,250
your life easier

00:26:52,669 --> 00:26:57,280
tokens represent format you know they're

00:26:55,250 --> 00:26:59,570
representing how your code is written an

00:26:57,280 --> 00:27:01,730
ast is represent the structure they

00:26:59,570 --> 00:27:04,010
don't care if you used curly braces

00:27:01,730 --> 00:27:07,789
around your hip statement or if you used

00:27:04,010 --> 00:27:09,590
wrote it in one line that also makes se

00:27:07,789 --> 00:27:12,140
is easier to manipulate because you do

00:27:09,590 --> 00:27:15,650
not have to worry about what parts are

00:27:12,140 --> 00:27:18,020
code syntax and what parts are actual

00:27:15,650 --> 00:27:19,850
statements and it makes it safer for

00:27:18,020 --> 00:27:22,789
Colt alterations because you can just

00:27:19,850 --> 00:27:24,559
take out a node and put a new node in

00:27:22,789 --> 00:27:27,169
rather than having to see if you're

00:27:24,559 --> 00:27:30,140
removing the right amount of elements

00:27:27,169 --> 00:27:32,840
from an array or removing the right part

00:27:30,140 --> 00:27:35,030
of a string yes tree is there for

00:27:32,840 --> 00:27:36,919
interoperability so a lot of different

00:27:35,030 --> 00:27:39,860
tools use yes tree as the foundation of

00:27:36,919 --> 00:27:41,659
their AST and that means you don't have

00:27:39,860 --> 00:27:44,900
to reinvent the wheel there's a lot of

00:27:41,659 --> 00:27:47,720
tools to create s geez a lot of tools to

00:27:44,900 --> 00:27:50,059
walk a STS and a lot of tools to render

00:27:47,720 --> 00:27:52,510
a STS and you can use all of these

00:27:50,059 --> 00:27:54,890
different tools to build either your own

00:27:52,510 --> 00:27:57,380
tools that you might share with the

00:27:54,890 --> 00:27:59,659
community were just internal things that

00:27:57,380 --> 00:28:02,210
are gonna be useful for you as you're

00:27:59,659 --> 00:28:04,010
building your apps because that means

00:28:02,210 --> 00:28:06,830
you can replace things like rapper said

00:28:04,010 --> 00:28:08,630
when you're modifying your code if you

00:28:06,830 --> 00:28:10,130
want to learn more about AST I would

00:28:08,630 --> 00:28:11,720
recommend you to check out the ast

00:28:10,130 --> 00:28:14,000
Explorer and just play around with it

00:28:11,720 --> 00:28:16,460
you know put some code in try to figure

00:28:14,000 --> 00:28:18,140
out what you're trying to change click

00:28:16,460 --> 00:28:20,659
on things because it will highlight the

00:28:18,140 --> 00:28:22,100
different parts of the ast on play

00:28:20,659 --> 00:28:23,630
around with different parsers and see

00:28:22,100 --> 00:28:26,600
what kind of information they give you

00:28:23,630 --> 00:28:28,100
there's a lot of fun things to do and

00:28:26,600 --> 00:28:29,600
then read the Babel plug-in handbook

00:28:28,100 --> 00:28:32,179
even if you're not planning to build

00:28:29,600 --> 00:28:33,980
your own Babel plugin if you want to

00:28:32,179 --> 00:28:36,590
learn more about a STS it's a it's a

00:28:33,980 --> 00:28:38,090
great thing to to read the nice thing is

00:28:36,590 --> 00:28:40,370
also all of the things I showed you our

00:28:38,090 --> 00:28:42,260
open source which means that now that

00:28:40,370 --> 00:28:43,610
you know what ast is are you can look

00:28:42,260 --> 00:28:45,830
for them in the different tools that

00:28:43,610 --> 00:28:47,270
you're using or different code bases to

00:28:45,830 --> 00:28:47,570
see what's actually happening on the

00:28:47,270 --> 00:28:50,480
other

00:28:47,570 --> 00:28:52,730
I also wrote a blog post about this

00:28:50,480 --> 00:28:56,540
topic if you want to rather read up on

00:28:52,730 --> 00:28:58,100
this in in the shape of a blog post it

00:28:56,540 --> 00:29:00,980
covers a lot of the same things that I

00:28:58,100 --> 00:29:04,280
covered in this talk but if you prefer

00:29:00,980 --> 00:29:05,870
reading it that's a good format and with

00:29:04,280 --> 00:29:08,480
that if you want to check out the slides

00:29:05,870 --> 00:29:11,150
I uploaded them on the on this URL at

00:29:08,480 --> 00:29:13,070
the left and I'll also tweet about them

00:29:11,150 --> 00:29:14,630
later if you have any questions feel

00:29:13,070 --> 00:29:16,460
free to reach out to me as I said you

00:29:14,630 --> 00:29:18,290
can reach me anywhere on the internet at

00:29:16,460 --> 00:29:21,140
Deakin also feel free to send me an

00:29:18,290 --> 00:29:22,880
email or send me a DM on Twitter

00:29:21,140 --> 00:29:26,680
with that I would like to thank you all

00:29:22,880 --> 00:29:26,680
for your attention and have a great day

00:29:33,059 --> 00:29:35,120

YouTube URL: https://www.youtube.com/watch?v=BtD2OrlLBhI


