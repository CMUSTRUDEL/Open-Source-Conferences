Title: Optimized Hydration via Compile Time Static Analysis - Michael Rawlings   & Dylan Piercey, eBay
Publication date: 2020-06-17
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:07,640 --> 00:00:14,370
hello everyone my name is Dylan and my

00:00:11,639 --> 00:00:16,410
name is Michael we're software engineers

00:00:14,370 --> 00:00:19,500
on eBay's web platform team and

00:00:16,410 --> 00:00:21,210
maintainer zuv marco a UI library that

00:00:19,500 --> 00:00:23,670
is a project under the open Jas

00:00:21,210 --> 00:00:28,199
foundation and also heavily used by eBay

00:00:23,670 --> 00:00:29,640
for our e-commerce platform thanks

00:00:28,199 --> 00:00:31,440
everyone for taking the time to join us

00:00:29,640 --> 00:00:33,330
today we're going to be talking about

00:00:31,440 --> 00:00:35,790
something Michael and I have spent a lot

00:00:33,330 --> 00:00:37,350
of time thinking about we hope that with

00:00:35,790 --> 00:00:39,600
this talk we can get the conversation

00:00:37,350 --> 00:00:44,010
moving around some optimizations we

00:00:39,600 --> 00:00:46,350
believe have been left on the table the

00:00:44,010 --> 00:00:47,850
optimizations were about to dig into do

00:00:46,350 --> 00:00:50,880
not necessarily apply to all

00:00:47,850 --> 00:00:53,280
applications our primary focus for these

00:00:50,880 --> 00:00:55,290
optimizations is multi-page applications

00:00:53,280 --> 00:00:57,410
but that's not to say that there aren't

00:00:55,290 --> 00:00:59,340
learnings to be had either way

00:00:57,410 --> 00:01:01,530
specifically we're going to talk a lot

00:00:59,340 --> 00:01:03,480
about hydration if you haven't heard the

00:01:01,530 --> 00:01:06,090
term before or just need a quick

00:01:03,480 --> 00:01:08,610
refresher hydration is a term for the

00:01:06,090 --> 00:01:10,560
process by which modern frameworks allow

00:01:08,610 --> 00:01:12,600
you to mount your application on a top

00:01:10,560 --> 00:01:13,229
of a page that was initially rendered on

00:01:12,600 --> 00:01:15,300
the server

00:01:13,229 --> 00:01:17,310
this means the framework will handle

00:01:15,300 --> 00:01:19,380
rendering a complete HTML page from the

00:01:17,310 --> 00:01:19,830
server and pick up seamlessly in the

00:01:19,380 --> 00:01:21,810
browser

00:01:19,830 --> 00:01:26,099
initializing application state and

00:01:21,810 --> 00:01:27,270
registering event handlers so hydration

00:01:26,099 --> 00:01:29,250
has been around for quite a while now

00:01:27,270 --> 00:01:31,349
and it's been popularized by modern

00:01:29,250 --> 00:01:32,849
frameworks such as react exists

00:01:31,349 --> 00:01:34,709
primarily because we've shifted from

00:01:32,849 --> 00:01:36,810
building websites with a sprinkling of

00:01:34,709 --> 00:01:39,000
JavaScript on top of a mostly server

00:01:36,810 --> 00:01:40,619
rendered application to our modern

00:01:39,000 --> 00:01:42,690
frameworks which allow us to specify the

00:01:40,619 --> 00:01:44,910
view as a function of our application

00:01:42,690 --> 00:01:46,530
state we've grown accustomed to the

00:01:44,910 --> 00:01:48,060
declarative and expressive templates and

00:01:46,530 --> 00:01:50,729
it also means we get to shift the work

00:01:48,060 --> 00:01:54,270
of attaching to and updating the Dom to

00:01:50,729 --> 00:01:55,739
our favor good choice the promise is

00:01:54,270 --> 00:01:57,720
that the framework will handle these

00:01:55,739 --> 00:01:59,459
things so that we can focus on managing

00:01:57,720 --> 00:02:02,399
the state and business logic of our

00:01:59,459 --> 00:02:04,170
applications and for the most part our

00:02:02,399 --> 00:02:05,550
modern frameworks deliver client-side

00:02:04,170 --> 00:02:09,259
performance which is perfectly

00:02:05,550 --> 00:02:11,849
acceptable for many common use cases

00:02:09,259 --> 00:02:15,599
however when it comes to the initial

00:02:11,849 --> 00:02:18,000
load performance fall short when it

00:02:15,599 --> 00:02:19,620
comes to performance ultimately what

00:02:18,000 --> 00:02:21,569
matters is how it affects our user's

00:02:19,620 --> 00:02:23,040
experience Google

00:02:21,569 --> 00:02:25,379
recently announced a set of metrics

00:02:23,040 --> 00:02:26,969
called web vitals which focus on three

00:02:25,379 --> 00:02:27,659
aspects of delivering a great user

00:02:26,969 --> 00:02:30,209
experience

00:02:27,659 --> 00:02:32,760
loading interactivity and visual

00:02:30,209 --> 00:02:35,249
stability visual stability is largely

00:02:32,760 --> 00:02:37,769
determined by the application logic but

00:02:35,249 --> 00:02:39,870
loading and interactivity are heavily

00:02:37,769 --> 00:02:41,189
impacted by your framework of choice so

00:02:39,870 --> 00:02:45,989
these are the metrics we'll focus on

00:02:41,189 --> 00:02:47,760
today the primary metric associated with

00:02:45,989 --> 00:02:51,269
loading its largest content full paint

00:02:47,760 --> 00:02:53,099
or LCP LCP measures the render time of

00:02:51,269 --> 00:02:55,019
the largest content element visible

00:02:53,099 --> 00:02:56,609
within the viewport this is notably

00:02:55,019 --> 00:02:58,169
different than similar methods like

00:02:56,609 --> 00:02:59,639
first content full paint which just

00:02:58,169 --> 00:03:00,840
measure the first time anything is

00:02:59,639 --> 00:03:03,689
visible on the screen

00:03:00,840 --> 00:03:05,669
the goal of LCP is to identify when the

00:03:03,689 --> 00:03:08,790
main content of a page is visible to the

00:03:05,669 --> 00:03:11,159
user the primary metric for

00:03:08,790 --> 00:03:13,709
interactivity is first input delay or F

00:03:11,159 --> 00:03:15,810
ID f ID measures the time from when a

00:03:13,709 --> 00:03:17,069
user first interacts with a page to the

00:03:15,810 --> 00:03:19,680
time when the browser is actually able

00:03:17,069 --> 00:03:21,060
to respond to that interaction we care a

00:03:19,680 --> 00:03:23,430
lot about the first input from the user

00:03:21,060 --> 00:03:25,079
because the biggest interactivity issues

00:03:23,430 --> 00:03:26,879
we see on the web today occur during

00:03:25,079 --> 00:03:31,139
page load largely due to modern

00:03:26,879 --> 00:03:33,239
hydration F idea is what's known as a

00:03:31,139 --> 00:03:35,040
field metric measures real user

00:03:33,239 --> 00:03:37,199
interactions as this is what ultimately

00:03:35,040 --> 00:03:39,180
matters but when comparing approaches

00:03:37,199 --> 00:03:41,759
from a framework perspective synthetic

00:03:39,180 --> 00:03:43,500
metrics are typically more helpful we'll

00:03:41,759 --> 00:03:45,120
take a look at total blocking time and

00:03:43,500 --> 00:03:49,769
total time to interactive which

00:03:45,120 --> 00:03:51,870
correlate closely with F ID looking

00:03:49,769 --> 00:03:54,239
first at LCP and how quickly we can get

00:03:51,870 --> 00:03:56,069
content visible to the user HTML is the

00:03:54,239 --> 00:03:58,290
absolute fastest way to do this on the

00:03:56,069 --> 00:03:59,699
web HTML is able to be parsed and

00:03:58,290 --> 00:04:01,949
rendered as the browser receives it

00:03:59,699 --> 00:04:03,449
however one common problem with modern

00:04:01,949 --> 00:04:05,159
frameworks is they have a subpar

00:04:03,449 --> 00:04:07,560
solution when it comes to rendering on

00:04:05,159 --> 00:04:09,509
the server in many cases this

00:04:07,560 --> 00:04:11,639
unoptimized rendering means that a

00:04:09,509 --> 00:04:13,409
server can easily get overloaded causing

00:04:11,639 --> 00:04:15,419
a significant amount of time between the

00:04:13,409 --> 00:04:18,449
requests coming into the server and the

00:04:15,419 --> 00:04:20,340
server responding with any HTML this can

00:04:18,449 --> 00:04:22,229
end up negating all performance benefits

00:04:20,340 --> 00:04:24,419
making it actually faster to just serve

00:04:22,229 --> 00:04:27,229
an empty page and let the browser do the

00:04:24,419 --> 00:04:30,360
rendering which was really unfortunate

00:04:27,229 --> 00:04:32,070
other two metrics TB T and TT I don't

00:04:30,360 --> 00:04:34,320
fear much better in the current web dev

00:04:32,070 --> 00:04:34,980
world modern hydration approaches

00:04:34,320 --> 00:04:36,210
requiring

00:04:34,980 --> 00:04:37,980
same amount of JavaScript and

00:04:36,210 --> 00:04:40,290
unfortunately Java scripts not cheap

00:04:37,980 --> 00:04:42,420
besides downloading the Jas we also have

00:04:40,290 --> 00:04:44,520
to parse it and execute it and unlike

00:04:42,420 --> 00:04:46,380
HTML execution can't happen as it's

00:04:44,520 --> 00:04:48,270
being downloaded this is especially

00:04:46,380 --> 00:04:49,770
troublesome for lower end devices but

00:04:48,270 --> 00:04:51,300
it's actually not that uncommon to find

00:04:49,770 --> 00:04:54,200
sites that are taxing even our most

00:04:51,300 --> 00:04:56,220
maxed out developer machines

00:04:54,200 --> 00:04:58,140
the main issue from the users

00:04:56,220 --> 00:05:00,450
perspective is that even if we can

00:04:58,140 --> 00:05:02,820
address LCP and get content quickly to

00:05:00,450 --> 00:05:04,410
display while ojs downloads parses and

00:05:02,820 --> 00:05:06,000
finally execute the user is unable to

00:05:04,410 --> 00:05:08,130
interact with what is visible and

00:05:06,000 --> 00:05:09,990
probably angrily tapping on their screen

00:05:08,130 --> 00:05:13,950
waiting for hydration to finally kick in

00:05:09,990 --> 00:05:16,170
I believe this poor first load

00:05:13,950 --> 00:05:18,750
experience is what is called single page

00:05:16,170 --> 00:05:22,020
applications or spas to become so

00:05:18,750 --> 00:05:23,760
popular the idea is even if the first

00:05:22,020 --> 00:05:25,800
load is terrible at least subsequent

00:05:23,760 --> 00:05:27,540
loads will be fast because the code has

00:05:25,800 --> 00:05:29,340
already been loaded and can be displayed

00:05:27,540 --> 00:05:31,980
without another round-trip to the server

00:05:29,340 --> 00:05:33,690
spas do have some benefits but they

00:05:31,980 --> 00:05:35,790
actually further increase the amount of

00:05:33,690 --> 00:05:37,710
j/s needed in the browser and come with

00:05:35,790 --> 00:05:40,680
a new set of challenges which are

00:05:37,710 --> 00:05:43,740
outside the scope of this talk so this

00:05:40,680 --> 00:05:46,200
sounds bad and it is modern frameworks

00:05:43,740 --> 00:05:48,060
create modern problems but there are

00:05:46,200 --> 00:05:49,830
actually fast sites out there that use

00:05:48,060 --> 00:05:52,800
modern frameworks it's just that it's

00:05:49,830 --> 00:05:54,690
currently a very manual process some

00:05:52,800 --> 00:05:56,250
meta frameworks out there such as next

00:05:54,690 --> 00:05:58,380
J's are beginning to put in some of this

00:05:56,250 --> 00:05:59,790
work for you but they still inherit a

00:05:58,380 --> 00:06:01,920
lot of the problems of the underlying

00:05:59,790 --> 00:06:03,360
framework because of this there's a

00:06:01,920 --> 00:06:06,420
large number of sites out there that

00:06:03,360 --> 00:06:07,920
don't perform well at all optimization

00:06:06,420 --> 00:06:09,480
through static analysis is really

00:06:07,920 --> 00:06:10,920
appealing because it's something that

00:06:09,480 --> 00:06:13,140
can happen automatically from the

00:06:10,920 --> 00:06:14,700
application developers perspective using

00:06:13,140 --> 00:06:16,770
information that's already present

00:06:14,700 --> 00:06:18,630
within the code that the writings the

00:06:16,770 --> 00:06:20,430
compiler can put in the extra work at

00:06:18,630 --> 00:06:23,820
Build time to make things faster and

00:06:20,430 --> 00:06:25,920
even eliminate code altogether template

00:06:23,820 --> 00:06:27,960
based frameworks like Marcos felt and

00:06:25,920 --> 00:06:29,820
view are a bit better poised to take

00:06:27,960 --> 00:06:32,340
advantage of these types of compile time

00:06:29,820 --> 00:06:33,900
optimizations but other frameworks may

00:06:32,340 --> 00:06:36,960
be able to leverage some of these ideas

00:06:33,900 --> 00:06:38,850
as well it's also worth pointing out

00:06:36,960 --> 00:06:40,200
that we're going to primarily be looking

00:06:38,850 --> 00:06:42,210
at these optimizations from the

00:06:40,200 --> 00:06:43,970
perspective of a multi-page app or what

00:06:42,210 --> 00:06:47,190
you might call a traditional website

00:06:43,970 --> 00:06:48,870
that said many of these ideas can help

00:06:47,190 --> 00:06:51,990
improve the first load experience of

00:06:48,870 --> 00:06:53,490
any website when it comes to LCP the

00:06:51,990 --> 00:06:55,620
question is how can we optimize server

00:06:53,490 --> 00:06:57,780
rendering so we can consistently deliver

00:06:55,620 --> 00:07:00,660
content Flay HTML to the user's browser

00:06:57,780 --> 00:07:02,280
in a timely manner some frameworks out

00:07:00,660 --> 00:07:04,200
there recommend using a headless browser

00:07:02,280 --> 00:07:06,300
on the server this is obviously

00:07:04,200 --> 00:07:08,010
expensive but even frameworks that

00:07:06,300 --> 00:07:10,530
create video on the server aren't ideal

00:07:08,010 --> 00:07:12,270
on the server the end goal is always

00:07:10,530 --> 00:07:14,220
going to be building an HTML strings

00:07:12,270 --> 00:07:15,990
these additional abstractions don't help

00:07:14,220 --> 00:07:18,570
us here at all and just end up consuming

00:07:15,990 --> 00:07:19,740
additional memory and CPU cycles the

00:07:18,570 --> 00:07:21,420
templates associated with their

00:07:19,740 --> 00:07:23,670
frameworks already closely mirror that

00:07:21,420 --> 00:07:25,410
HTML we need to generate we shouldn't

00:07:23,670 --> 00:07:27,300
need to spin up a browser or create a

00:07:25,410 --> 00:07:30,360
bunch of objects representing the Dom

00:07:27,300 --> 00:07:32,130
just to generate some HTML instead we

00:07:30,360 --> 00:07:34,050
can compile to basic string

00:07:32,130 --> 00:07:36,890
concatenation which will always be the

00:07:34,050 --> 00:07:39,210
fastest implementation on the server

00:07:36,890 --> 00:07:40,950
there are actually a few frameworks out

00:07:39,210 --> 00:07:42,620
there that are already compiling server

00:07:40,950 --> 00:07:45,630
optimized versions of their templates

00:07:42,620 --> 00:07:47,640
including Mark Owens felt and in

00:07:45,630 --> 00:07:50,910
Martha's case we even compile these to

00:07:47,640 --> 00:07:53,340
writing to a stream this allows us to

00:07:50,910 --> 00:07:55,500
flush out partial HTML while the certain

00:07:53,340 --> 00:07:58,470
parts of the page may be waiting on data

00:07:55,500 --> 00:08:00,030
from an async service compiling the

00:07:58,470 --> 00:08:02,010
strings has the benefit that certain

00:08:00,030 --> 00:08:05,040
work like escaping content happens at

00:08:02,010 --> 00:08:06,870
compile time for static values when HTML

00:08:05,040 --> 00:08:08,850
generation happens at runtime from an

00:08:06,870 --> 00:08:10,980
object tree there's typically no

00:08:08,850 --> 00:08:13,290
differentiator between static values and

00:08:10,980 --> 00:08:15,090
potentially unsafe dynamic values so

00:08:13,290 --> 00:08:18,750
everything needs to be escaped which can

00:08:15,090 --> 00:08:20,400
end up getting quite expensive to see

00:08:18,750 --> 00:08:21,990
how Marco does this let's take a quick

00:08:20,400 --> 00:08:24,690
look at an example template and compile

00:08:21,990 --> 00:08:26,760
it it's pretty simple defining a value

00:08:24,690 --> 00:08:29,790
called name and interpolating that into

00:08:26,760 --> 00:08:31,560
some paragraph content when we compile

00:08:29,790 --> 00:08:33,690
for the server we can see that we've got

00:08:31,560 --> 00:08:35,520
string concatenation and some utilities

00:08:33,690 --> 00:08:38,850
are pulled in to handle escaping dynamic

00:08:35,520 --> 00:08:40,740
content in the browser compilation looks

00:08:38,850 --> 00:08:42,330
a little different Marco creates a feed

00:08:40,740 --> 00:08:44,280
on in the browser similar to other

00:08:42,330 --> 00:08:46,290
frameworks to do lightweight comparisons

00:08:44,280 --> 00:08:47,880
across renders that's not to say that

00:08:46,290 --> 00:08:50,310
Marco is outputting the absolute best

00:08:47,880 --> 00:08:53,880
performance in either environment but it

00:08:50,310 --> 00:08:55,710
is pretty close on the server but Marco

00:08:53,880 --> 00:08:58,350
is not artificially bottlenecking in

00:08:55,710 --> 00:09:00,360
either environment either the nice thing

00:08:58,350 --> 00:09:02,070
here is that Markel is able to compile

00:09:00,360 --> 00:09:02,690
your template to JavaScript which is

00:09:02,070 --> 00:09:04,160
optimized

00:09:02,690 --> 00:09:08,510
to perform some pretty radically

00:09:04,160 --> 00:09:10,390
different tasks this has a huge impact

00:09:08,510 --> 00:09:13,180
on ben-gurion performance on the server

00:09:10,390 --> 00:09:15,350
still there's room for improvement for

00:09:13,180 --> 00:09:17,270
most components written in modern

00:09:15,350 --> 00:09:19,070
frameworks there is this exist code

00:09:17,270 --> 00:09:20,930
that's only ever going to run in a

00:09:19,070 --> 00:09:24,440
single environment here are some

00:09:20,930 --> 00:09:26,360
examples events never need to be called

00:09:24,440 --> 00:09:28,670
on the server creating the functions

00:09:26,360 --> 00:09:30,560
there is wasteful there usually exists

00:09:28,670 --> 00:09:32,480
lifecycle events as well that only ever

00:09:30,560 --> 00:09:34,670
happened in the browser or effects if

00:09:32,480 --> 00:09:38,360
you're using hooks these also should be

00:09:34,670 --> 00:09:40,580
stripped from the server-side code it's

00:09:38,360 --> 00:09:42,470
worth noting that serving a static site

00:09:40,580 --> 00:09:46,640
is an option for sites like blogs where

00:09:42,470 --> 00:09:48,350
the content changes infrequently now

00:09:46,640 --> 00:09:50,180
that we've addressed how we can get the

00:09:48,350 --> 00:09:52,280
content to display quickly for our users

00:09:50,180 --> 00:09:53,750
let's turn to hydration to see what we

00:09:52,280 --> 00:09:56,030
can do to allow our users to more

00:09:53,750 --> 00:09:57,890
quickly interact with the page the

00:09:56,030 --> 00:09:58,970
primary issue with hydration is that

00:09:57,890 --> 00:10:02,120
there's an incredible amount of

00:09:58,970 --> 00:10:03,920
duplication the exact process for

00:10:02,120 --> 00:10:05,390
hydration varies from framework to

00:10:03,920 --> 00:10:07,760
framework but at a high level

00:10:05,390 --> 00:10:11,180
all modern frameworks require three main

00:10:07,760 --> 00:10:12,920
elements - hydration the HTML markup

00:10:11,180 --> 00:10:15,800
which is rendered from the server or

00:10:12,920 --> 00:10:17,120
served statically the JavaScript

00:10:15,800 --> 00:10:19,490
necessary to build the initial

00:10:17,120 --> 00:10:22,490
application state and to mount on top of

00:10:19,490 --> 00:10:24,140
this HTML finally any data that's needed

00:10:22,490 --> 00:10:28,970
to create the initial application state

00:10:24,140 --> 00:10:30,770
this is often serialized as JSON looking

00:10:28,970 --> 00:10:32,000
at some code will probably help here and

00:10:30,770 --> 00:10:34,910
make it more obvious where the

00:10:32,000 --> 00:10:36,770
duplication exists in our example you

00:10:34,910 --> 00:10:39,230
can see that a lot of static contents

00:10:36,770 --> 00:10:41,420
could exist in at least two of them

00:10:39,230 --> 00:10:44,030
elements of hydration we're just talking

00:10:41,420 --> 00:10:47,000
about for the most part static content

00:10:44,030 --> 00:10:49,040
such as such as the Dom structure is

00:10:47,000 --> 00:10:51,860
represented in both the HTML and the

00:10:49,040 --> 00:10:54,020
JavaScript also the dynamic content

00:10:51,860 --> 00:10:56,300
typically the initial input to the view

00:10:54,020 --> 00:10:59,839
is represented in both the HTML and the

00:10:56,300 --> 00:11:02,390
data maybe in our example world may only

00:10:59,839 --> 00:11:04,100
ever render on the server in fact for

00:11:02,390 --> 00:11:06,530
many apps a large chunk this rendering

00:11:04,100 --> 00:11:08,990
only needs to happen once and it's not

00:11:06,530 --> 00:11:11,000
ever updated with the remainder of the

00:11:08,990 --> 00:11:12,860
talk we use the term immutable to refer

00:11:11,000 --> 00:11:15,890
to this content that was once rendered

00:11:12,860 --> 00:11:16,670
can never be updated so how can we start

00:11:15,890 --> 00:11:21,260
to optimize

00:11:16,670 --> 00:11:22,910
process for real applications let's

00:11:21,260 --> 00:11:25,970
quickly take a look at a very simple

00:11:22,910 --> 00:11:27,470
hypothetical template in it we can see

00:11:25,970 --> 00:11:29,660
that there is some stateful value

00:11:27,470 --> 00:11:32,510
denoted by the dollar sign which is used

00:11:29,660 --> 00:11:34,130
to update some text below first we'll

00:11:32,510 --> 00:11:36,440
look at how much static content exists

00:11:34,130 --> 00:11:37,910
here you can see that all of the Dom

00:11:36,440 --> 00:11:40,040
structure for the page is actually

00:11:37,910 --> 00:11:42,470
static as well as some text content and

00:11:40,040 --> 00:11:43,970
attributes taking this a step further

00:11:42,470 --> 00:11:45,530
though we can see that the footer

00:11:43,970 --> 00:11:47,600
element contains some text which

00:11:45,530 --> 00:11:50,000
although dynamic is not tied to any

00:11:47,600 --> 00:11:52,220
state that content also cannot be

00:11:50,000 --> 00:11:55,190
updated by the browser and we consider

00:11:52,220 --> 00:11:57,080
it immutable most multi-page

00:11:55,190 --> 00:11:58,850
applications have a bunch of content on

00:11:57,080 --> 00:11:59,630
the page that once initially rendered is

00:11:58,850 --> 00:12:01,550
immutable

00:11:59,630 --> 00:12:03,730
for this content it should be possible

00:12:01,550 --> 00:12:06,590
to completely skip the hydration process

00:12:03,730 --> 00:12:08,540
meaning that rendering logic data etc is

00:12:06,590 --> 00:12:10,910
not duplicated one of the best ways to

00:12:08,540 --> 00:12:15,050
improve time to interactive is to skip

00:12:10,910 --> 00:12:16,820
hydrating unnecessarily okay so we can

00:12:15,050 --> 00:12:18,830
skip hydrating the immutable parts of

00:12:16,820 --> 00:12:20,840
their page but how can we optimize the

00:12:18,830 --> 00:12:22,550
dynamic parts looking at the simplest

00:12:20,840 --> 00:12:24,170
case you might have some dynamic text

00:12:22,550 --> 00:12:26,270
and attribute grievant just an event

00:12:24,170 --> 00:12:27,650
handler that needs to be attached there

00:12:26,270 --> 00:12:29,510
would be nothing too fancy about if

00:12:27,650 --> 00:12:31,400
you're hooking up the code yourself you

00:12:29,510 --> 00:12:33,710
probably write a solution that you would

00:12:31,400 --> 00:12:35,980
use order of magnitudes less JavaScript

00:12:33,710 --> 00:12:38,390
than any modern hydrated framework would

00:12:35,980 --> 00:12:39,800
for this simple case the key is that the

00:12:38,390 --> 00:12:41,810
layout of the template is still a

00:12:39,800 --> 00:12:44,270
mutable once rendered from the server

00:12:41,810 --> 00:12:46,520
meaning no new elements are added moved

00:12:44,270 --> 00:12:48,320
or removed since the layout is immutable

00:12:46,520 --> 00:12:50,240
we should be able to avoid send in any

00:12:48,320 --> 00:12:52,670
layout to the browser the server has

00:12:50,240 --> 00:12:55,460
already done that work text content

00:12:52,670 --> 00:12:56,780
attributes etc may still be updated but

00:12:55,460 --> 00:12:58,580
to do that you do not need to

00:12:56,780 --> 00:13:00,260
necessarily render a full section of

00:12:58,580 --> 00:13:02,120
layout in the browser just to hydrated

00:13:00,260 --> 00:13:02,810
you might be thinking well what about

00:13:02,120 --> 00:13:04,880
events

00:13:02,810 --> 00:13:06,470
well hydration as it stands is far from

00:13:04,880 --> 00:13:08,570
the simplest approach to attaching

00:13:06,470 --> 00:13:10,760
events to the Dom a much simpler

00:13:08,570 --> 00:13:13,190
approach for both of these would be to

00:13:10,760 --> 00:13:15,470
simply mark our elements with some kind

00:13:13,190 --> 00:13:17,660
of identifier then we can easily grab a

00:13:15,470 --> 00:13:19,310
reference data element adding under the

00:13:17,660 --> 00:13:23,480
event handlers and also updated its

00:13:19,310 --> 00:13:25,070
attributes in text content we can

00:13:23,480 --> 00:13:27,110
actually represent the required

00:13:25,070 --> 00:13:28,880
JavaScript for the example template on

00:13:27,110 --> 00:13:29,450
screen pretty easily in just a few lines

00:13:28,880 --> 00:13:31,850
of code

00:13:29,450 --> 00:13:34,670
we got a reference to the Dom notes that

00:13:31,850 --> 00:13:37,610
we need first the search input then the

00:13:34,670 --> 00:13:39,110
dynamic search text finally we add an

00:13:37,610 --> 00:13:43,180
event listener and update the text

00:13:39,110 --> 00:13:46,220
content as the input value changes

00:13:43,180 --> 00:13:47,780
another way we can reduce the impact of

00:13:46,220 --> 00:13:49,700
hydration especially during the page

00:13:47,780 --> 00:13:51,980
load is by deferring as much of the

00:13:49,700 --> 00:13:53,840
hydration work as possible ideally

00:13:51,980 --> 00:13:55,730
elements would be hydrated in batches

00:13:53,840 --> 00:13:57,380
reducing their total blocking time and

00:13:55,730 --> 00:13:59,750
allowing for the user to interact with

00:13:57,380 --> 00:14:01,480
the page during the hydration process a

00:13:59,750 --> 00:14:04,340
few frameworks are already doing this

00:14:01,480 --> 00:14:06,350
also content could be hydrated and even

00:14:04,340 --> 00:14:08,270
download lazily families can take on

00:14:06,350 --> 00:14:10,460
part of this work for us automatically

00:14:08,270 --> 00:14:13,100
although in many cases it will be a

00:14:10,460 --> 00:14:14,840
manual process either way it's important

00:14:13,100 --> 00:14:17,090
for you to keep in mind you can also a

00:14:14,840 --> 00:14:19,250
lazily hydrate content based off various

00:14:17,090 --> 00:14:20,540
user interactions or even just by simply

00:14:19,250 --> 00:14:23,330
detecting if the elements in the

00:14:20,540 --> 00:14:25,520
viewport everything we've mentioned so

00:14:23,330 --> 00:14:26,840
far can be manually optimized but it

00:14:25,520 --> 00:14:28,910
probably already sounds like a lot of

00:14:26,840 --> 00:14:30,320
work ideally our frameworks need to

00:14:28,910 --> 00:14:33,110
start picking up the slack here

00:14:30,320 --> 00:14:34,760
so whatever frameworks doing today one

00:14:33,110 --> 00:14:37,220
project that has taken a stab at this

00:14:34,760 --> 00:14:39,200
issue is next super performance this

00:14:37,220 --> 00:14:41,570
module is a community plugin for next

00:14:39,200 --> 00:14:43,970
yes which uses pre-act and exposes some

00:14:41,570 --> 00:14:46,310
api's that optimize the hybrid hydration

00:14:43,970 --> 00:14:48,080
process pre-act itself offers

00:14:46,310 --> 00:14:50,090
respectable performance on the server

00:14:48,080 --> 00:14:53,000
side and the client side while having a

00:14:50,090 --> 00:14:55,040
significantly smaller bundle size this

00:14:53,000 --> 00:14:57,080
plugin uses an approach they call

00:14:55,040 --> 00:14:59,420
partial hydration in essence it allows

00:14:57,080 --> 00:15:01,820
developers to explicitly mark a subset

00:14:59,420 --> 00:15:03,440
of components as hydrate able it then

00:15:01,820 --> 00:15:05,450
takes care of serializing the initial

00:15:03,440 --> 00:15:07,430
data for these components and allows the

00:15:05,450 --> 00:15:10,340
mutable top-level components to be only

00:15:07,430 --> 00:15:12,380
rendered right on the server another

00:15:10,340 --> 00:15:15,110
interesting project in this space comes

00:15:12,380 --> 00:15:17,690
from the view community it is called you

00:15:15,110 --> 00:15:19,790
lazy hydration and as you probably can

00:15:17,690 --> 00:15:22,010
guess just based off the name it

00:15:19,790 --> 00:15:24,020
provides a nice component based api to

00:15:22,010 --> 00:15:27,200
explicitly configure what a component

00:15:24,020 --> 00:15:30,020
should be hydrated it also lets you skip

00:15:27,200 --> 00:15:31,640
hydration for a section of code but more

00:15:30,020 --> 00:15:33,860
interestingly it allows you to

00:15:31,640 --> 00:15:36,500
explicitly define when that code should

00:15:33,860 --> 00:15:38,450
hydrate you can opt into hydrating when

00:15:36,500 --> 00:15:41,200
a component is interacted with when it's

00:15:38,450 --> 00:15:43,220
visible or even when the browser is idle

00:15:41,200 --> 00:15:45,079
in Marco

00:15:43,220 --> 00:15:47,509
work we maintain we've put a lot of

00:15:45,079 --> 00:15:49,579
thought into the hydration process eBay

00:15:47,509 --> 00:15:51,439
itself is a multi-page application and

00:15:49,579 --> 00:15:53,829
the performance of our pages while not

00:15:51,439 --> 00:15:55,910
perfect is extremely important to us

00:15:53,829 --> 00:15:57,319
Marco is the only framework that

00:15:55,910 --> 00:16:00,290
implements some of these hydration

00:15:57,319 --> 00:16:02,240
specific optimizations out-of-the-box it

00:16:00,290 --> 00:16:03,949
ships with support for partial hydration

00:16:02,240 --> 00:16:06,680
but it goes one step further and

00:16:03,949 --> 00:16:08,810
automates the process Marco components

00:16:06,680 --> 00:16:10,370
actually take the entire pages component

00:16:08,810 --> 00:16:12,980
rate into account when bundling and

00:16:10,370 --> 00:16:14,930
rendering it uses this information to

00:16:12,980 --> 00:16:17,629
determine where the top-level components

00:16:14,930 --> 00:16:19,430
which are stateful exist if a component

00:16:17,629 --> 00:16:21,800
does not contain stable walking the

00:16:19,430 --> 00:16:23,750
components on the page it can safely be

00:16:21,800 --> 00:16:26,959
omitted since it will always render an

00:16:23,750 --> 00:16:28,699
immutable HTML structure because this is

00:16:26,959 --> 00:16:30,860
all handled by the framework it has some

00:16:28,699 --> 00:16:33,529
unique advantages over other solutions

00:16:30,860 --> 00:16:36,290
if two hydrated components share

00:16:33,529 --> 00:16:38,089
serialized data it dee doop Marko's

00:16:36,290 --> 00:16:39,920
api's are designed to avoid creating

00:16:38,089 --> 00:16:41,930
input which is not serializable

00:16:39,920 --> 00:16:43,639
for example passing a function as input

00:16:41,930 --> 00:16:46,189
which is typically used for event

00:16:43,639 --> 00:16:49,040
handlers would not be properly

00:16:46,189 --> 00:16:51,079
serialized by their solutions marco also

00:16:49,040 --> 00:16:52,759
takes care of tracking what all the

00:16:51,079 --> 00:16:55,129
browser dependencies are for an entire

00:16:52,759 --> 00:16:57,230
page it will analyze the component tree

00:16:55,129 --> 00:16:58,610
and ensure that only hydrated components

00:16:57,230 --> 00:17:02,389
and their children end up in the browser

00:16:58,610 --> 00:17:03,949
bundle marco currently automates a fair

00:17:02,389 --> 00:17:05,510
amount of what is being done by add-ons

00:17:03,949 --> 00:17:07,579
and other communities thanks in part to

00:17:05,510 --> 00:17:09,890
its compiler we believe without this

00:17:07,579 --> 00:17:11,419
automation maintaining which components

00:17:09,890 --> 00:17:13,520
need to be hydrated becomes a headache

00:17:11,419 --> 00:17:15,079
since developers typically like to avoid

00:17:13,520 --> 00:17:15,740
headaches it typically means that

00:17:15,079 --> 00:17:18,049
they're avoiding

00:17:15,740 --> 00:17:21,589
doing these manual optimizations in the

00:17:18,049 --> 00:17:23,510
first place now let's take a step back

00:17:21,589 --> 00:17:25,909
from the solutions in the wild and think

00:17:23,510 --> 00:17:30,470
more about what room we have to continue

00:17:25,909 --> 00:17:31,940
improvement for hydration one issue is

00:17:30,470 --> 00:17:33,440
that all of these solutions treat

00:17:31,940 --> 00:17:35,539
components as the source of truth for

00:17:33,440 --> 00:17:37,159
hydration although in some cases that's

00:17:35,539 --> 00:17:39,110
going to get you quite far for most

00:17:37,159 --> 00:17:40,760
applications the top-level immutable

00:17:39,110 --> 00:17:45,080
content doesn't stop at component

00:17:40,760 --> 00:17:47,000
boundaries let's think more about where

00:17:45,080 --> 00:17:48,820
the truly immutable content is for a

00:17:47,000 --> 00:17:51,830
page ignoring component boundaries

00:17:48,820 --> 00:17:53,480
ultimately it boils down to this can

00:17:51,830 --> 00:17:55,669
this section of the template be rendered

00:17:53,480 --> 00:17:57,049
in the client-side ignoring hydration

00:17:55,669 --> 00:17:58,519
the only way

00:17:57,049 --> 00:18:00,230
10th will need to be rendered from

00:17:58,519 --> 00:18:02,210
scratch in the browser as if it's

00:18:00,230 --> 00:18:04,460
conditionally displayed in practice this

00:18:02,210 --> 00:18:05,929
happens in one of two ways is the

00:18:04,460 --> 00:18:07,820
content under an if statement of some

00:18:05,929 --> 00:18:10,039
kind or some kind of conditional that

00:18:07,820 --> 00:18:11,509
can be toggled in the browser or is the

00:18:10,039 --> 00:18:15,049
content within a loop that can be

00:18:11,509 --> 00:18:17,480
appended to in the browser ultimately if

00:18:15,049 --> 00:18:19,879
the content is out full outside stateful

00:18:17,480 --> 00:18:21,830
control flow then it can't be rendered

00:18:19,879 --> 00:18:24,470
from scratch in a hydrated application

00:18:21,830 --> 00:18:26,720
that is a much more granular boundary

00:18:24,470 --> 00:18:28,730
then relying on components since with

00:18:26,720 --> 00:18:30,799
components even if a single piece of the

00:18:28,730 --> 00:18:33,919
template is dynamic the whole thing

00:18:30,799 --> 00:18:35,899
becomes dynamic so now that we know

00:18:33,919 --> 00:18:37,220
where the hard stop is for things that

00:18:35,899 --> 00:18:39,379
need to be able to render on the

00:18:37,220 --> 00:18:41,600
client-side how can we determine it

00:18:39,379 --> 00:18:44,899
exactly where a stateful control flow

00:18:41,600 --> 00:18:46,820
exists static analysis this is easier

00:18:44,899 --> 00:18:48,710
done in some templating languages and

00:18:46,820 --> 00:18:50,149
others essentially it means tracking

00:18:48,710 --> 00:18:52,789
where the stateful data within the

00:18:50,149 --> 00:18:55,190
template is used and ultimately if it

00:18:52,789 --> 00:18:57,259
ends up either directly or indirectly as

00:18:55,190 --> 00:19:00,830
a part of some computed data used by a

00:18:57,259 --> 00:19:02,690
control flow in practice when analyzing

00:19:00,830 --> 00:19:04,580
a template you can tell which parts of

00:19:02,690 --> 00:19:06,950
the template will be updated as they'll

00:19:04,580 --> 00:19:08,690
be tied to some state by tracking if a

00:19:06,950 --> 00:19:10,279
state is used to update X content or an

00:19:08,690 --> 00:19:12,559
attribute we can have our framework

00:19:10,279 --> 00:19:14,210
inline code to perform targeted updates

00:19:12,559 --> 00:19:16,879
just for that value much like you'd

00:19:14,210 --> 00:19:18,379
write yourself by also tracking state

00:19:16,879 --> 00:19:20,779
that makes its way to the control flows

00:19:18,379 --> 00:19:23,359
that is the if statements or the for

00:19:20,779 --> 00:19:26,450
loops we can use this as our new full

00:19:23,359 --> 00:19:27,830
hydration boundary no framework is

00:19:26,450 --> 00:19:30,169
currently doing this level of

00:19:27,830 --> 00:19:31,639
granularity for hydration but we do have

00:19:30,169 --> 00:19:34,220
plans to incorporate it into future

00:19:31,639 --> 00:19:36,139
versions of Marco with proper tracking

00:19:34,220 --> 00:19:38,059
of state flowing down the page and

00:19:36,139 --> 00:19:40,340
component tree we should be able to

00:19:38,059 --> 00:19:42,230
statically determine significantly more

00:19:40,340 --> 00:19:46,129
dead code to allow for skipping even

00:19:42,230 --> 00:19:48,590
more of the hydration process another

00:19:46,129 --> 00:19:50,720
technique yet to be explored would be to

00:19:48,590 --> 00:19:52,759
use static analysis potentially across

00:19:50,720 --> 00:19:54,769
templates determining which included

00:19:52,759 --> 00:19:56,450
props can actually be used essentially

00:19:54,769 --> 00:19:58,210
running dead code removal in the data

00:19:56,450 --> 00:20:01,070
that is serialized for each component

00:19:58,210 --> 00:20:02,869
the most frameworks client-side logic is

00:20:01,070 --> 00:20:04,639
clearly separate from server-side logic

00:20:02,869 --> 00:20:06,529
and it's possible to determine which

00:20:04,639 --> 00:20:08,539
part of the templates can be updated and

00:20:06,529 --> 00:20:10,759
which input data is needed for the

00:20:08,539 --> 00:20:14,029
client that is used by

00:20:10,759 --> 00:20:16,070
events for lifecycle events previously

00:20:14,029 --> 00:20:17,929
we mentioned that we can use this to

00:20:16,070 --> 00:20:19,459
advantage simply to remove code that

00:20:17,929 --> 00:20:22,009
will never run in our target environment

00:20:19,459 --> 00:20:24,320
and object optimized hydration for

00:20:22,009 --> 00:20:26,029
immutable content however we can also

00:20:24,320 --> 00:20:27,739
use this to track which input is

00:20:26,029 --> 00:20:30,199
actually needed to be serialized for

00:20:27,739 --> 00:20:31,789
hydrated components for all immutable

00:20:30,199 --> 00:20:34,249
components it's possible to check which

00:20:31,789 --> 00:20:37,099
inputs are used in events or life cycles

00:20:34,249 --> 00:20:39,289
or effects every other input is actually

00:20:37,099 --> 00:20:41,359
not needed on the client-side which I've

00:20:39,289 --> 00:20:45,109
tracked correctly it allows to prune the

00:20:41,359 --> 00:20:46,459
serialized data even further hopefully

00:20:45,109 --> 00:20:48,409
all of this has helped show just how

00:20:46,459 --> 00:20:49,849
much dead code and extra work their

00:20:48,409 --> 00:20:52,099
modern framers currently do when it

00:20:49,849 --> 00:20:53,839
comes to hydrating these optimizations

00:20:52,099 --> 00:20:55,279
are just a sample one of the best

00:20:53,839 --> 00:20:57,440
features of the web platform is its

00:20:55,279 --> 00:20:59,269
ability to provide an instant experience

00:20:57,440 --> 00:21:00,949
to our users and we think that is time

00:20:59,269 --> 00:21:02,749
our modern frameworks once again start

00:21:00,949 --> 00:21:05,059
competing on this fundamental feature of

00:21:02,749 --> 00:21:07,159
the web it's time to ask our frameworks

00:21:05,059 --> 00:21:08,959
to produce optimized applications across

00:21:07,159 --> 00:21:12,849
the stack and this time we finally

00:21:08,959 --> 00:21:15,139
outperform that old WordPress blog

00:21:12,849 --> 00:21:16,819
thanks everyone for taking the time to

00:21:15,139 --> 00:21:18,469
hear us out we hope we've left you with

00:21:16,819 --> 00:21:20,690
some ideas on how to optimize your own

00:21:18,469 --> 00:21:24,459
app and we look forward to continuing

00:21:20,690 --> 00:21:24,459
this discussion with all of you

00:21:29,730 --> 00:21:31,790

YouTube URL: https://www.youtube.com/watch?v=tasGnX8OUJ0


