Title: From Streaming to Studio--The Evolution of Node.js at Netflix - Guilherme Hermeto, Netflix
Publication date: 2020-06-22
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:03,920 --> 00:00:13,080
hi there thanks for joining me

00:00:09,440 --> 00:00:15,690
Netflix runs a surplice nodejs platform

00:00:13,080 --> 00:00:19,829
that powers all the devices user

00:00:15,690 --> 00:00:22,109
interfaces as the business evolves the

00:00:19,829 --> 00:00:25,439
platform's growing to serve other use

00:00:22,109 --> 00:00:29,519
cases as the web applications that

00:00:25,439 --> 00:00:32,250
support of content production my name is

00:00:29,519 --> 00:00:34,440
Gillian Yamato and I'm a senior platform

00:00:32,250 --> 00:00:38,430
engineer and Netflix with the nodejs

00:00:34,440 --> 00:00:41,760
runtime team I will explain how we're

00:00:38,430 --> 00:00:45,929
evolving a platform while maximizing the

00:00:41,760 --> 00:00:46,469
code reusability to tell you where we

00:00:45,929 --> 00:00:49,129
are going

00:00:46,469 --> 00:00:52,710
I better start from the beginning

00:00:49,129 --> 00:00:57,329
Netflix is started using nodejs at the

00:00:52,710 --> 00:00:59,760
end of 2013 and the first node AS

00:00:57,329 --> 00:01:02,390
application received production traffic

00:00:59,760 --> 00:01:05,159
in the year of 2014

00:01:02,390 --> 00:01:08,880
that early work evolved to be your

00:01:05,159 --> 00:01:16,170
current service nodejs platform called

00:01:08,880 --> 00:01:18,660
old cork a node cork service lives in a

00:01:16,170 --> 00:01:21,120
container which is deployed into our

00:01:18,660 --> 00:01:26,330
container management platform named

00:01:21,120 --> 00:01:31,500
Titus and sits behind or level seven

00:01:26,330 --> 00:01:33,470
application gateway named zu which is

00:01:31,500 --> 00:01:36,900
responsible for authenticating

00:01:33,470 --> 00:01:39,600
validating in routing requests from the

00:01:36,900 --> 00:01:43,470
diverse clients to the corresponding

00:01:39,600 --> 00:01:46,590
node cork service upon receiving a

00:01:43,470 --> 00:01:49,800
request the node cork service who make

00:01:46,590 --> 00:01:53,010
one or more requests to the mid-tier API

00:01:49,800 --> 00:01:55,040
and format their responses to send back

00:01:53,010 --> 00:01:58,650
to the client

00:01:55,040 --> 00:01:59,610
both zu and titles are Netflix open

00:01:58,650 --> 00:02:03,860
source projects

00:01:59,610 --> 00:02:07,290
I suggest you check them out on github

00:02:03,860 --> 00:02:10,860
the node cork platform main goal was to

00:02:07,290 --> 00:02:13,730
provide a managed experience where

00:02:10,860 --> 00:02:15,100
clients teams could create custom API

00:02:13,730 --> 00:02:19,210
experiences

00:02:15,100 --> 00:02:22,450
tailored to their specific devices for

00:02:19,210 --> 00:02:25,300
example the Android team could create an

00:02:22,450 --> 00:02:29,740
API that would better suit the client

00:02:25,300 --> 00:02:33,580
design same goes for iOS tvy and other

00:02:29,740 --> 00:02:37,930
client teams in other words BFF's

00:02:33,580 --> 00:02:40,990
or back-end for frontier using the

00:02:37,930 --> 00:02:43,660
platform the client team can focus on

00:02:40,990 --> 00:02:46,480
their business goals while we abstract

00:02:43,660 --> 00:02:52,330
the complex infrastructure of platform

00:02:46,480 --> 00:02:55,740
offerings and Netflix so this is what

00:02:52,330 --> 00:03:00,400
you need for a load quark service

00:02:55,740 --> 00:03:03,520
it's a node called JSON file and the

00:03:00,400 --> 00:03:07,050
route handler that's it that's all you

00:03:03,520 --> 00:03:10,180
need to have a production rep service

00:03:07,050 --> 00:03:14,620
the Rope handler file may return an

00:03:10,180 --> 00:03:16,240
array of functions and you can also

00:03:14,620 --> 00:03:21,460
specify middlewares

00:03:16,240 --> 00:03:24,870
or not cork dot Jason the platform will

00:03:21,460 --> 00:03:28,960
be responsible for three main areas

00:03:24,870 --> 00:03:32,170
observability with metrics distributed

00:03:28,960 --> 00:03:37,330
tracing help dashboard and centralized

00:03:32,170 --> 00:03:41,110
logging the boug ability with exception

00:03:37,330 --> 00:03:43,510
management and diagnostic tools examples

00:03:41,110 --> 00:03:49,260
of diagnostic tools are flame graphs and

00:03:43,510 --> 00:03:53,460
simply heap profiler and lastly

00:03:49,260 --> 00:03:57,720
availability with configuration alerts

00:03:53,460 --> 00:04:00,820
service registration and cover ability

00:03:57,720 --> 00:04:05,830
basically everything will expect from

00:04:00,820 --> 00:04:08,470
production ready service at the core of

00:04:05,830 --> 00:04:12,270
the platform we have a restful

00:04:08,470 --> 00:04:15,370
application with its in ground module

00:04:12,270 --> 00:04:18,930
put rest file and in route module are

00:04:15,370 --> 00:04:22,870
open source check them out on github

00:04:18,930 --> 00:04:24,790
the enroute module is responsible to

00:04:22,870 --> 00:04:27,820
read the mudguard

00:04:24,790 --> 00:04:32,050
JSON file from the customer application

00:04:27,820 --> 00:04:34,680
and use it to locate all the route

00:04:32,050 --> 00:04:34,680
handlers

00:04:37,770 --> 00:04:44,229
when we release a platform version we're

00:04:40,809 --> 00:04:47,979
actually publishing a docker image with

00:04:44,229 --> 00:04:50,259
a node called platform runtime and when

00:04:47,979 --> 00:04:54,360
a customer publishes a new version of

00:04:50,259 --> 00:04:57,520
the services we layer those images

00:04:54,360 --> 00:05:01,959
copying their application code into the

00:04:57,520 --> 00:05:04,839
platform image we as a platform are

00:05:01,959 --> 00:05:08,529
responsible for monitoring a mitigating

00:05:04,839 --> 00:05:11,259
issues with the running process when the

00:05:08,529 --> 00:05:13,929
application image is deployed the

00:05:11,259 --> 00:05:18,159
service is ready to receive production

00:05:13,929 --> 00:05:21,069
traffic this module allows the client

00:05:18,159 --> 00:05:25,029
teams to build applications that receive

00:05:21,069 --> 00:05:27,759
huge amounts of traffic in support of a

00:05:25,029 --> 00:05:31,929
hundred and eighty to plus million

00:05:27,759 --> 00:05:37,059
subscribers node quark is highly

00:05:31,929 --> 00:05:39,639
optimized for that use case as the

00:05:37,059 --> 00:05:42,669
business box we're starting to power a

00:05:39,639 --> 00:05:44,319
different type of application like the

00:05:42,669 --> 00:05:48,490
ones that support of content production

00:05:44,319 --> 00:05:51,610
efforts and those applications have very

00:05:48,490 --> 00:05:54,219
different characteristics while

00:05:51,610 --> 00:05:56,979
streaming have a few dozen applications

00:05:54,219 --> 00:05:59,579
with huge footprint and sometimes

00:05:56,979 --> 00:06:02,969
require thousands of containers each

00:05:59,579 --> 00:06:05,979
inserting dozens of millions of users

00:06:02,969 --> 00:06:08,499
content production have a large number

00:06:05,979 --> 00:06:11,259
of applications with very small

00:06:08,499 --> 00:06:16,800
footprint and much more limited user

00:06:11,259 --> 00:06:19,659
base security is also different while a

00:06:16,800 --> 00:06:23,249
streaming user has access to their own

00:06:19,659 --> 00:06:26,559
account and all the content library

00:06:23,249 --> 00:06:28,869
content production applications have a

00:06:26,559 --> 00:06:32,879
way more nuanced authentication and

00:06:28,869 --> 00:06:36,579
authorization we have to authenticate

00:06:32,879 --> 00:06:39,039
employees partners and then decide the

00:06:36,579 --> 00:06:44,979
level of access that each individual

00:06:39,039 --> 00:06:47,700
user has and even though both of those

00:06:44,979 --> 00:06:50,030
types of services requiring this

00:06:47,700 --> 00:06:53,930
the tracing in centralized logging

00:06:50,030 --> 00:06:58,110
simply and retention are not the same

00:06:53,930 --> 00:07:01,700
for example on streaming applications

00:06:58,110 --> 00:07:04,920
with simple 0.1 percent of requests

00:07:01,700 --> 00:07:10,740
while on content production applications

00:07:04,920 --> 00:07:13,800
it makes sense to sample 100% and why we

00:07:10,740 --> 00:07:16,860
it's only cost effective to keep

00:07:13,800 --> 00:07:18,260
streaming logs readily available for the

00:07:16,860 --> 00:07:21,360
last 24 hours

00:07:18,260 --> 00:07:23,400
we probably won't increase the law

00:07:21,360 --> 00:07:29,870
presentation for the other applications

00:07:23,400 --> 00:07:33,120
to let's say a week these applications

00:07:29,870 --> 00:07:37,080
they are different but they also share a

00:07:33,120 --> 00:07:40,890
lot of concerns around observability

00:07:37,080 --> 00:07:43,140
which metrics really matter the book

00:07:40,890 --> 00:07:45,720
ability how do I quickly find out what's

00:07:43,140 --> 00:07:48,240
wrong with my service in configuration

00:07:45,720 --> 00:07:50,790
how do I configure the best

00:07:48,240 --> 00:07:53,960
configuration for running a service in

00:07:50,790 --> 00:07:56,910
production that's important too

00:07:53,960 --> 00:08:00,420
unfortunately the original architecture

00:07:56,910 --> 00:08:02,300
had its limitations the original design

00:08:00,420 --> 00:08:06,300
made a lot of assumptions about

00:08:02,300 --> 00:08:08,670
infrastructure and code paths other use

00:08:06,300 --> 00:08:12,740
cases were just not top of mind at that

00:08:08,670 --> 00:08:18,180
point and stability was a major concern

00:08:12,740 --> 00:08:21,270
let me expand on that so our team tries

00:08:18,180 --> 00:08:26,420
really hard not to break netflix on new

00:08:21,270 --> 00:08:26,420
platform releases it's a slow process

00:08:26,510 --> 00:08:32,310
every platform releases requires that we

00:08:29,700 --> 00:08:35,240
can narrate the changes into multiple

00:08:32,310 --> 00:08:38,820
services take 1% of the traffic and

00:08:35,240 --> 00:08:40,770
comparing it with a baseline if there

00:08:38,820 --> 00:08:43,730
are any issues or performance

00:08:40,770 --> 00:08:47,910
degradation we search for the root cause

00:08:43,730 --> 00:08:53,240
we fix it then we rinse and repeat until

00:08:47,910 --> 00:08:53,240
we get performance that as the

00:08:53,730 --> 00:08:58,690
this model just won't fit well for the

00:08:56,830 --> 00:09:02,170
fast pace in new applications that we

00:08:58,690 --> 00:09:08,710
only support it creates risk on one side

00:09:02,170 --> 00:09:12,700
and reduces velocity on the other and

00:09:08,710 --> 00:09:15,130
one added piece of complexity so when we

00:09:12,700 --> 00:09:18,640
took a step back and look at the whole

00:09:15,130 --> 00:09:20,560
customer base we saw that we have more

00:09:18,640 --> 00:09:23,380
difference than just content production

00:09:20,560 --> 00:09:24,880
and streaming applications some of those

00:09:23,380 --> 00:09:27,460
applications would like a fork or

00:09:24,880 --> 00:09:34,330
someone rest and most of the new world

00:09:27,460 --> 00:09:34,990
graph QL when I analyze all the puzzle

00:09:34,330 --> 00:09:37,270
pieces

00:09:34,990 --> 00:09:40,480
I got the conclusion that the best

00:09:37,270 --> 00:09:43,570
approach moving forward was to extract

00:09:40,480 --> 00:09:47,490
all those components from the platform

00:09:43,570 --> 00:09:49,780
into self-contained modules or plugins

00:09:47,490 --> 00:09:55,030
yeah I went there

00:09:49,780 --> 00:09:59,680
plugins and what plugins solve a problem

00:09:55,030 --> 00:10:01,870
how do they solve a problem well plugins

00:09:59,680 --> 00:10:05,170
allow us to remove the fast-evolving

00:10:01,870 --> 00:10:07,570
pieces of the platform source code

00:10:05,170 --> 00:10:11,410
creating much needed stability for the

00:10:07,570 --> 00:10:13,750
string applications and most of them can

00:10:11,410 --> 00:10:16,210
be reusing all or almost all

00:10:13,750 --> 00:10:18,460
applications with maximize called

00:10:16,210 --> 00:10:22,750
reusability and minimize the support

00:10:18,460 --> 00:10:25,270
burden so we're going even further

00:10:22,750 --> 00:10:28,120
further than that we are making

00:10:25,270 --> 00:10:30,400
everything plugins like everything well

00:10:28,120 --> 00:10:32,550
except that tiny little piece of

00:10:30,400 --> 00:10:34,830
platform code that load plugins

00:10:32,550 --> 00:10:38,380
everything else is a plugin

00:10:34,830 --> 00:10:43,210
even the sir and that gives us a lot of

00:10:38,380 --> 00:10:47,020
flexibility right now or code is very

00:10:43,210 --> 00:10:49,000
intertwined with rest file but if the

00:10:47,020 --> 00:10:51,730
server is a plugin with a stable

00:10:49,000 --> 00:10:55,390
interface it enables us to experiment

00:10:51,730 --> 00:10:57,870
with other application frameworks like

00:10:55,390 --> 00:10:57,870
first file

00:10:58,949 --> 00:11:06,279
when we were designing the plugins we

00:11:02,230 --> 00:11:08,410
research a lot of other plugins we

00:11:06,279 --> 00:11:11,920
search different plugins implementations

00:11:08,410 --> 00:11:15,819
including how happy and fast I implement

00:11:11,920 --> 00:11:20,949
plugins and we decided that we need a

00:11:15,819 --> 00:11:23,800
little bit more structure so well happy

00:11:20,949 --> 00:11:25,930
and fast fight plugins you pass

00:11:23,800 --> 00:11:28,860
application server back to the plugin

00:11:25,930 --> 00:11:31,930
and let the plugin would fight a server

00:11:28,860 --> 00:11:34,750
we chose a format where the plug-in

00:11:31,930 --> 00:11:36,879
actually provides hooks and the platform

00:11:34,750 --> 00:11:41,560
control how and when those hooks are

00:11:36,879 --> 00:11:48,300
called for comparison this is the pacify

00:11:41,560 --> 00:11:53,160
plugin this is how you decorate fat file

00:11:48,300 --> 00:11:59,439
this is how you add apprehend ler hug

00:11:53,160 --> 00:12:07,509
and this is how you add a route from a

00:11:59,439 --> 00:12:12,339
plug-in pretty simple and this is how a

00:12:07,509 --> 00:12:14,019
node called plug-in looks like this is

00:12:12,339 --> 00:12:17,920
how you initialize a plug-in and

00:12:14,019 --> 00:12:21,519
decorate the node cork platform the

00:12:17,920 --> 00:12:24,759
option of the pine ski can be used for

00:12:21,519 --> 00:12:29,500
runtime type checking of the decorated

00:12:24,759 --> 00:12:32,829
object this is how you define a pre

00:12:29,500 --> 00:12:37,889
routing hook which is similar to the pre

00:12:32,829 --> 00:12:42,930
handler hook of fest file and finally

00:12:37,889 --> 00:12:42,930
this is how the plug-in defines a route

00:12:43,589 --> 00:12:54,699
so it's pretty simple too this is the

00:12:48,660 --> 00:12:56,110
interface that I'm working with let's go

00:12:54,699 --> 00:12:58,170
check that out

00:12:56,110 --> 00:12:58,170
you

00:13:00,450 --> 00:13:06,160
in addition to the startup and shutdown

00:13:03,070 --> 00:13:09,030
books the plugins also provide the

00:13:06,160 --> 00:13:13,530
following lifecycle hooks before request

00:13:09,030 --> 00:13:18,910
pre parsing pre routing after request

00:13:13,530 --> 00:13:20,950
Anya this hooks are caught during the

00:13:18,910 --> 00:13:25,480
different stages of the request

00:13:20,950 --> 00:13:27,490
lifecycle we chose this structure to

00:13:25,480 --> 00:13:30,880
give us control now and provide

00:13:27,490 --> 00:13:33,990
flexibility for the future for instance

00:13:30,880 --> 00:13:36,370
in the future we might have a plug-in

00:13:33,990 --> 00:13:39,130
which has different dependencies as

00:13:36,370 --> 00:13:43,600
startup and during the request lifecycle

00:13:39,130 --> 00:13:46,240
a plugins are also responsible to

00:13:43,600 --> 00:13:49,900
provide a debug interface and a maki

00:13:46,240 --> 00:13:52,960
interface then the bug interface is used

00:13:49,900 --> 00:13:55,590
by the platform debug server which runs

00:13:52,960 --> 00:13:59,260
in parallel the custom service and

00:13:55,590 --> 00:14:04,180
provide real-time health information for

00:13:59,260 --> 00:14:06,790
that instance the mock interface allows

00:14:04,180 --> 00:14:12,070
our customers to mock a plugin during

00:14:06,790 --> 00:14:14,790
unit or integration tests in Leslie the

00:14:12,070 --> 00:14:18,520
routes Keys allow us to register

00:14:14,790 --> 00:14:21,970
platform the final routes for instance a

00:14:18,520 --> 00:14:25,690
graph QL or a koala plug-in put the

00:14:21,970 --> 00:14:28,290
final slash rough crowd saving the user

00:14:25,690 --> 00:14:28,290
the trouble

00:14:30,830 --> 00:14:37,380
this pluggable architecture enabled us

00:14:34,440 --> 00:14:41,430
to create another abstraction which we

00:14:37,380 --> 00:14:44,220
call application profiles application

00:14:41,430 --> 00:14:48,000
profiles are type of applications with

00:14:44,220 --> 00:14:51,180
similar characteristics meaning they use

00:14:48,000 --> 00:14:54,000
the same plugins so an application

00:14:51,180 --> 00:14:57,420
profile can be seen as a list of plugins

00:14:54,000 --> 00:14:59,490
to load for a given application we

00:14:57,420 --> 00:15:01,800
actually design it as a module that

00:14:59,490 --> 00:15:07,770
imports the plugins and export in an

00:15:01,800 --> 00:15:12,540
array of loaded plugins in the future

00:15:07,770 --> 00:15:15,830
that will allow us to use the profiles

00:15:12,540 --> 00:15:18,960
to require different versions of plugins

00:15:15,830 --> 00:15:24,870
we're not there yet who hope to be there

00:15:18,960 --> 00:15:29,130
soon so since profiles only load

00:15:24,870 --> 00:15:31,440
specific plugins it reduces the risk of

00:15:29,130 --> 00:15:33,960
a plug-in built for content production

00:15:31,440 --> 00:15:39,290
to break an application on the streaming

00:15:33,960 --> 00:15:43,890
pad for example if I just load the

00:15:39,290 --> 00:15:48,030
security for content production and I

00:15:43,890 --> 00:15:51,720
change that plug-in very after as the

00:15:48,030 --> 00:15:55,140
profiles for streaming applications

00:15:51,720 --> 00:15:59,880
don't load that particular plug-in it's

00:15:55,140 --> 00:16:03,270
fine that that plugin evolves fast and

00:15:59,880 --> 00:16:05,010
not even limited plugins so the concept

00:16:03,270 --> 00:16:07,950
of application profiles can now be

00:16:05,010 --> 00:16:10,350
leveraged to the platform we can use it

00:16:07,950 --> 00:16:12,720
to load different dashboards register

00:16:10,350 --> 00:16:17,540
different alerts and even load different

00:16:12,720 --> 00:16:17,540
sidecars or demons for each profile

00:16:17,550 --> 00:16:22,860
as we remove all the moving pieces from

00:16:20,610 --> 00:16:25,800
the core platform its source code

00:16:22,860 --> 00:16:29,399
becomes very very stable and rarely

00:16:25,800 --> 00:16:31,440
needs to change this allows us in the

00:16:29,399 --> 00:16:36,750
future to shift the focus from platform

00:16:31,440 --> 00:16:39,800
releases to profile releases currently

00:16:36,750 --> 00:16:43,200
our tooling relies on platform versions

00:16:39,800 --> 00:16:46,230
but as we break the platform into

00:16:43,200 --> 00:16:51,089
smaller pieces it becomes less important

00:16:46,230 --> 00:16:54,029
in relation with profile versions what

00:16:51,089 --> 00:16:57,000
we go from here well for us the next

00:16:54,029 --> 00:16:59,010
step is to allow our pioneers teams to

00:16:57,000 --> 00:17:01,440
create application profiles and give to

00:16:59,010 --> 00:17:04,410
their customers enabling them to

00:17:01,440 --> 00:17:09,569
virtually build platforms on top of a

00:17:04,410 --> 00:17:12,209
platform the interface that I show you

00:17:09,569 --> 00:17:14,850
it's private to our team at this moment

00:17:12,209 --> 00:17:17,400
but we plan to release that to our

00:17:14,850 --> 00:17:20,040
partner teams in the coming months right

00:17:17,400 --> 00:17:22,620
now we're trying to test validate it and

00:17:20,040 --> 00:17:27,120
solidify it before we make it a public

00:17:22,620 --> 00:17:30,240
interface to them and it's all very

00:17:27,120 --> 00:17:32,750
open-ended but very excited so we're

00:17:30,240 --> 00:17:36,770
very excited to see where this is going

00:17:32,750 --> 00:17:39,720
and even beyond BFFs

00:17:36,770 --> 00:17:43,140
we are now looking into serving

00:17:39,720 --> 00:17:46,200
federated graphs and server-side render

00:17:43,140 --> 00:17:49,250
applications so possibilities

00:17:46,200 --> 00:17:49,250
possibilities possibilities

00:17:49,550 --> 00:17:57,169
today attach some subjects like strip

00:17:52,980 --> 00:17:59,700
the tracing centralized login and matrix

00:17:57,169 --> 00:18:01,919
some of what we use a Netflix is

00:17:59,700 --> 00:18:05,640
internal so I can't really recommend

00:18:01,919 --> 00:18:06,570
everything you use but if you just need

00:18:05,640 --> 00:18:09,059
a place to start

00:18:06,570 --> 00:18:13,710
I have options that I personally like to

00:18:09,059 --> 00:18:15,090
recommend and which are open source for

00:18:13,710 --> 00:18:17,990
metrics and alerting

00:18:15,090 --> 00:18:22,919
there's Atlas which use a Netflix and

00:18:17,990 --> 00:18:25,050
primitives which is very well known for

00:18:22,919 --> 00:18:28,980
centralized logging I always liked

00:18:25,050 --> 00:18:31,140
fluently and some of the elastic product

00:18:28,980 --> 00:18:34,350
especially 5 bits

00:18:31,140 --> 00:18:37,260
to send their locks to elasticsearch for

00:18:34,350 --> 00:18:40,760
distributed request tracing zip King is

00:18:37,260 --> 00:18:43,020
definitely the way to go

00:18:40,760 --> 00:18:45,750
for Diagnostics

00:18:43,020 --> 00:18:49,410
there's flame scope which you use Linux

00:18:45,750 --> 00:18:53,549
birth so you can use the Linux perf

00:18:49,410 --> 00:18:57,630
package available on NPM we use the same

00:18:53,549 --> 00:19:00,240
package unload quark and Leslie for

00:18:57,630 --> 00:19:03,690
exception management center is very well

00:19:00,240 --> 00:19:09,030
known and easy to use and I also always

00:19:03,690 --> 00:19:11,790
liked air brake thank you very much for

00:19:09,030 --> 00:19:15,419
being here with me today and to let me

00:19:11,790 --> 00:19:17,809
share our work with you I see you on the

00:19:15,419 --> 00:19:17,809

YouTube URL: https://www.youtube.com/watch?v=mOjfdFALAec


