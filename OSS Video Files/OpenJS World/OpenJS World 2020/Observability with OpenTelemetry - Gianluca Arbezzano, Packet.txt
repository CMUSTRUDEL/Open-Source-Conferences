Title: Observability with OpenTelemetry - Gianluca Arbezzano, Packet
Publication date: 2020-06-17
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:00,640 --> 00:00:03,439
hello everyone thank you for having me

00:00:02,720 --> 00:00:06,399
here

00:00:03,439 --> 00:00:07,520
uh i'm jean luca and i work as a

00:00:06,399 --> 00:00:09,760
developer

00:00:07,520 --> 00:00:11,360
in the past i work as a sre as a

00:00:09,760 --> 00:00:13,519
reliability engineer

00:00:11,360 --> 00:00:14,400
and i'm a lot involved with cloud

00:00:13,519 --> 00:00:17,119
computing

00:00:14,400 --> 00:00:18,240
kubernetes and stuff like that today i'm

00:00:17,119 --> 00:00:21,359
here to speak

00:00:18,240 --> 00:00:23,279
with you about observability and

00:00:21,359 --> 00:00:24,560
with a project in mind that is called

00:00:23,279 --> 00:00:26,960
open telemetry

00:00:24,560 --> 00:00:28,560
so this is what we're gonna look at

00:00:26,960 --> 00:00:30,880
today

00:00:28,560 --> 00:00:31,920
so let's start from something more

00:00:30,880 --> 00:00:35,440
general about

00:00:31,920 --> 00:00:38,719
pros and cons about cloud computing

00:00:35,440 --> 00:00:41,600
kubernetes and microservices so

00:00:38,719 --> 00:00:42,719
what those have in common and what's

00:00:41,600 --> 00:00:45,920
good and what's

00:00:42,719 --> 00:00:47,600
bad about those there are both of them

00:00:45,920 --> 00:00:50,160
they have a lot of good stuff

00:00:47,600 --> 00:00:51,680
they bring a lot of good stuff to us and

00:00:50,160 --> 00:00:53,840
that's why they are so popular

00:00:51,680 --> 00:00:55,280
so cloud computing and kubernetes gives

00:00:53,840 --> 00:00:57,440
you an api

00:00:55,280 --> 00:00:59,280
that you can use programmatically to

00:00:57,440 --> 00:01:00,480
build automation and to deploy your

00:00:59,280 --> 00:01:02,800
application

00:01:00,480 --> 00:01:05,119
not only that but you can control the

00:01:02,800 --> 00:01:08,479
lifecycle of your application

00:01:05,119 --> 00:01:10,000
as you prefer so this is very important

00:01:08,479 --> 00:01:13,040
because

00:01:10,000 --> 00:01:13,760
applications are critical we have to

00:01:13,040 --> 00:01:15,360
look at them

00:01:13,760 --> 00:01:18,000
we have to take care of what they are

00:01:15,360 --> 00:01:20,320
doing and they have to be distributed

00:01:18,000 --> 00:01:22,720
across

00:01:20,320 --> 00:01:23,920
clusters and cloud provider for

00:01:22,720 --> 00:01:27,600
reliability

00:01:23,920 --> 00:01:29,520
the problem accounts is the distribution

00:01:27,600 --> 00:01:32,400
itself because distribution

00:01:29,520 --> 00:01:33,600
is crucial for a success but it's also

00:01:32,400 --> 00:01:36,720
very complicated

00:01:33,600 --> 00:01:39,280
like if you think about how easy it is

00:01:36,720 --> 00:01:42,159
to monitor a single process on a single

00:01:39,280 --> 00:01:43,759
laptop or in a single server

00:01:42,159 --> 00:01:45,360
that's way different when you have to

00:01:43,759 --> 00:01:47,680
replicate that across

00:01:45,360 --> 00:01:48,479
like cloud providers or across like

00:01:47,680 --> 00:01:51,680
regions

00:01:48,479 --> 00:01:54,000
or continents so this this distribution

00:01:51,680 --> 00:01:55,680
makes stuff way harder and more

00:01:54,000 --> 00:01:57,520
distributed you are

00:01:55,680 --> 00:01:59,280
more complicated it is and cloud

00:01:57,520 --> 00:02:02,479
computing and kubernetes

00:01:59,280 --> 00:02:04,640
makes the distribution way simpler

00:02:02,479 --> 00:02:06,159
way more affordable and that increased

00:02:04,640 --> 00:02:08,399
complexity

00:02:06,159 --> 00:02:10,560
microservices is a way you write

00:02:08,399 --> 00:02:13,280
application to make them to scale

00:02:10,560 --> 00:02:14,160
not only the application itself but also

00:02:13,280 --> 00:02:16,319
the teams

00:02:14,160 --> 00:02:18,000
that work on your product because you

00:02:16,319 --> 00:02:20,000
can have smaller team

00:02:18,000 --> 00:02:22,480
that works on a segmented piece of your

00:02:20,000 --> 00:02:24,560
application or your business

00:02:22,480 --> 00:02:26,000
and they can work by themselves and you

00:02:24,560 --> 00:02:28,800
can scale them up and down

00:02:26,000 --> 00:02:29,840
as you wish them so it gives you way

00:02:28,800 --> 00:02:32,000
more control

00:02:29,840 --> 00:02:34,080
and scalability but it also means that

00:02:32,000 --> 00:02:35,440
you have a lot more to manage at what

00:02:34,080 --> 00:02:37,840
you are usually

00:02:35,440 --> 00:02:38,800
um you know you usually have to take

00:02:37,840 --> 00:02:41,680
care when you have

00:02:38,800 --> 00:02:42,640
one gigantic application so i think we

00:02:41,680 --> 00:02:45,840
can summarize

00:02:42,640 --> 00:02:48,959
pros and cons here has um you know

00:02:45,840 --> 00:02:52,319
you get better scalability you get

00:02:48,959 --> 00:02:53,519
more um like distribution across the

00:02:52,319 --> 00:02:56,000
network but

00:02:53,519 --> 00:02:58,159
that has a price and the price is all

00:02:56,000 --> 00:02:59,680
about how do you manage and how do you

00:02:58,159 --> 00:03:00,720
understand what's going on in your

00:02:59,680 --> 00:03:04,159
system

00:03:00,720 --> 00:03:06,400
so has consequences for example of

00:03:04,159 --> 00:03:07,599
you know deploying an application across

00:03:06,400 --> 00:03:10,080
cloud provider

00:03:07,599 --> 00:03:11,360
is that you get a resiliency budget

00:03:10,080 --> 00:03:14,879
because your application

00:03:11,360 --> 00:03:16,319
runs better and if one region goes down

00:03:14,879 --> 00:03:19,760
you have the other one

00:03:16,319 --> 00:03:22,879
but this means that you don't get like

00:03:19,760 --> 00:03:24,560
a single way to say oh this is broken or

00:03:22,879 --> 00:03:26,560
this application doesn't work because it

00:03:24,560 --> 00:03:27,200
will may work in a region but it will

00:03:26,560 --> 00:03:30,319
may

00:03:27,200 --> 00:03:31,200
be down in another one so you have to

00:03:30,319 --> 00:03:33,440
figure out

00:03:31,200 --> 00:03:35,360
where it's broken how it's broken and if

00:03:33,440 --> 00:03:38,480
it's broken for how many people

00:03:35,360 --> 00:03:39,920
so those questions are not i know you

00:03:38,480 --> 00:03:40,480
don't have this question when you have a

00:03:39,920 --> 00:03:43,599
single

00:03:40,480 --> 00:03:44,959
like um replicas or when you have a

00:03:43,599 --> 00:03:47,040
single data center

00:03:44,959 --> 00:03:48,159
and so when the distribution is lower

00:03:47,040 --> 00:03:51,040
because yeah

00:03:48,159 --> 00:03:51,840
if it goes down go down that's a problem

00:03:51,040 --> 00:03:53,920
because

00:03:51,840 --> 00:03:55,920
uh it's easy to maintain like it's a con

00:03:53,920 --> 00:03:58,480
because usually you want to keep

00:03:55,920 --> 00:03:59,040
everything up and running all the time

00:03:58,480 --> 00:04:01,280
so

00:03:59,040 --> 00:04:02,480
this is kind of the friction that you

00:04:01,280 --> 00:04:05,439
have when you think about

00:04:02,480 --> 00:04:06,480
onboarding kubernetes cloud computing

00:04:05,439 --> 00:04:11,200
it's all good

00:04:06,480 --> 00:04:14,640
but it's complicated i also never heard

00:04:11,200 --> 00:04:17,199
like a customer complaining about

00:04:14,640 --> 00:04:17,840
my application using too many cpus like

00:04:17,199 --> 00:04:20,320
when i get

00:04:17,840 --> 00:04:21,919
ticket supports for e-commerce that says

00:04:20,320 --> 00:04:24,560
that they can pay

00:04:21,919 --> 00:04:25,280
or that the page doesn't load fast

00:04:24,560 --> 00:04:27,919
enough

00:04:25,280 --> 00:04:28,880
but nobody ever complained about cpus

00:04:27,919 --> 00:04:31,520
but from mine

00:04:28,880 --> 00:04:33,759
from my experience everybody cares about

00:04:31,520 --> 00:04:36,880
cpu i mean when i go

00:04:33,759 --> 00:04:37,440
in a company i see graphs and dashboards

00:04:36,880 --> 00:04:41,120
all about

00:04:37,440 --> 00:04:43,120
cpu packet lost and all those stuff that

00:04:41,120 --> 00:04:44,800
like customers really don't care about

00:04:43,120 --> 00:04:46,000
because they come from a different

00:04:44,800 --> 00:04:48,400
perspective

00:04:46,000 --> 00:04:49,360
and this is part of the story that i

00:04:48,400 --> 00:04:52,720
want to tell

00:04:49,360 --> 00:04:56,400
like those metrics cpu memory

00:04:52,720 --> 00:04:59,680
are important but the business requires

00:04:56,400 --> 00:05:00,240
other metrics and as a developer we are

00:04:59,680 --> 00:05:03,520
there

00:05:00,240 --> 00:05:07,199
to meet their expectation

00:05:03,520 --> 00:05:09,840
so we have to figure out a way to

00:05:07,199 --> 00:05:11,600
make this to work so customers doesn't

00:05:09,840 --> 00:05:12,080
complain about the quality of my code

00:05:11,600 --> 00:05:14,639
either

00:05:12,080 --> 00:05:15,680
i can wrote the words code that works as

00:05:14,639 --> 00:05:17,919
like very good

00:05:15,680 --> 00:05:19,440
and they are happy or i can write the

00:05:17,919 --> 00:05:21,360
perfect code that doesn't

00:05:19,440 --> 00:05:24,320
meet their criteria and they are not

00:05:21,360 --> 00:05:27,199
able to use the outcome of my

00:05:24,320 --> 00:05:28,880
workflow so this this is important they

00:05:27,199 --> 00:05:31,440
don't care about cpu they don't care

00:05:28,880 --> 00:05:33,280
about code quality they care about

00:05:31,440 --> 00:05:35,680
the product to be up and running

00:05:33,280 --> 00:05:38,800
reliable and useful for them

00:05:35,680 --> 00:05:39,520
but i care about those stuff as a

00:05:38,800 --> 00:05:42,400
developer

00:05:39,520 --> 00:05:43,039
because for me um the consequence of

00:05:42,400 --> 00:05:45,680
about

00:05:43,039 --> 00:05:47,120
writing good code that is reliable that

00:05:45,680 --> 00:05:50,880
is easy to maintain

00:05:47,120 --> 00:05:54,160
that is um that doesn't use all my

00:05:50,880 --> 00:05:55,520
like computer resources um is important

00:05:54,160 --> 00:05:57,680
because by consequence

00:05:55,520 --> 00:05:59,440
usually means that the customers are

00:05:57,680 --> 00:06:02,639
happier but they don't care

00:05:59,440 --> 00:06:05,280
i have to find a way to write

00:06:02,639 --> 00:06:06,000
those stuff in a way that has a direct

00:06:05,280 --> 00:06:09,120
impact to

00:06:06,000 --> 00:06:10,080
them and one of the best way is to use

00:06:09,120 --> 00:06:12,479
the metrics

00:06:10,080 --> 00:06:14,080
that they think that we think are

00:06:12,479 --> 00:06:16,080
important for the customer

00:06:14,080 --> 00:06:18,080
so if you think that the customer

00:06:16,080 --> 00:06:18,960
doesn't care about cpu in your ecommerce

00:06:18,080 --> 00:06:21,520
what does it

00:06:18,960 --> 00:06:22,160
care about maybe they care about like

00:06:21,520 --> 00:06:23,840
the

00:06:22,160 --> 00:06:25,600
the number of products that you can

00:06:23,840 --> 00:06:28,240
suggest to them or

00:06:25,600 --> 00:06:29,919
the number or the latency to opening a

00:06:28,240 --> 00:06:32,400
detail of the product

00:06:29,919 --> 00:06:34,240
so all those metrics has to be

00:06:32,400 --> 00:06:35,759
aggregated with the cpu with the memory

00:06:34,240 --> 00:06:38,479
with the one that we know about

00:06:35,759 --> 00:06:40,240
to get something useful out of them if

00:06:38,479 --> 00:06:43,440
you look only at one

00:06:40,240 --> 00:06:44,800
uh only at one signal is usually like

00:06:43,440 --> 00:06:46,639
complicated to

00:06:44,800 --> 00:06:51,120
uh to make it to work usually it doesn't

00:06:46,639 --> 00:06:53,039
describe enough the world that we are in

00:06:51,120 --> 00:06:54,960
so let's take a break because there is a

00:06:53,039 --> 00:06:57,599
lot already here and i'm going to give

00:06:54,960 --> 00:07:00,160
you a brief presentation about myself

00:06:57,599 --> 00:07:02,000
so i'm john lucarbezano and i come from

00:07:00,160 --> 00:07:04,800
italy i live in touring work

00:07:02,000 --> 00:07:05,120
close the house in the north and i work

00:07:04,800 --> 00:07:07,840
at

00:07:05,120 --> 00:07:09,039
pocket as a senior staff sort of a

00:07:07,840 --> 00:07:11,520
software engineer

00:07:09,039 --> 00:07:12,160
and you can find me around has a john

00:07:11,520 --> 00:07:14,800
arb

00:07:12,160 --> 00:07:16,560
i'm on twitter and i blog i use twitter

00:07:14,800 --> 00:07:18,560
a lot so if you have any questions or if

00:07:16,560 --> 00:07:20,400
or you if you're looking to chat about

00:07:18,560 --> 00:07:23,440
those stuff like cloud computing

00:07:20,400 --> 00:07:25,120
observability monitoring just

00:07:23,440 --> 00:07:27,440
see you there and when i'm not

00:07:25,120 --> 00:07:28,160
developing i grow vegetables in my

00:07:27,440 --> 00:07:30,319
garden

00:07:28,160 --> 00:07:32,240
so this is the best season to see some

00:07:30,319 --> 00:07:35,199
pictures about like tomatoes

00:07:32,240 --> 00:07:37,440
and potatoes and so on so uh see you

00:07:35,199 --> 00:07:39,919
there

00:07:37,440 --> 00:07:42,160
so my question for you or let's say the

00:07:39,919 --> 00:07:45,120
question i usually try to do

00:07:42,160 --> 00:07:45,520
at myself when i design a system or when

00:07:45,120 --> 00:07:49,199
i

00:07:45,520 --> 00:07:52,319
code is how do i tell a story

00:07:49,199 --> 00:07:54,240
for our cast so let's say that i

00:07:52,319 --> 00:07:56,160
let let's say that i have a you know

00:07:54,240 --> 00:07:59,039
website that

00:07:56,160 --> 00:08:00,879
serves no let's let's stay straight to

00:07:59,039 --> 00:08:04,560
the e-commerce because it's easy

00:08:00,879 --> 00:08:07,360
um so how how i tell

00:08:04,560 --> 00:08:08,560
a story for a specific payment for a

00:08:07,360 --> 00:08:11,039
customer

00:08:08,560 --> 00:08:13,520
like as we know the microservices like

00:08:11,039 --> 00:08:14,720
if we do microservices we have a lot of

00:08:13,520 --> 00:08:17,520
different pieces

00:08:14,720 --> 00:08:18,319
and the payment request goes through all

00:08:17,520 --> 00:08:21,759
of them

00:08:18,319 --> 00:08:24,400
trying to you know fulfill their cast

00:08:21,759 --> 00:08:26,720
but how do we describe all the story for

00:08:24,400 --> 00:08:28,319
a specific payment or let's say that you

00:08:26,720 --> 00:08:32,320
are designing a new feature

00:08:28,319 --> 00:08:33,919
like you are adding like um

00:08:32,320 --> 00:08:35,680
i don't know you are having like a

00:08:33,919 --> 00:08:39,120
comment box a way to leave

00:08:35,680 --> 00:08:41,360
feedback to uh to a product

00:08:39,120 --> 00:08:42,719
these will may involve like writing a

00:08:41,360 --> 00:08:45,360
few microservices

00:08:42,719 --> 00:08:47,040
deploy them interact with some other

00:08:45,360 --> 00:08:48,000
microservices that are already there

00:08:47,040 --> 00:08:51,040
like the metadata

00:08:48,000 --> 00:08:53,600
database for example and how do you

00:08:51,040 --> 00:08:54,640
tell the story of this new feature from

00:08:53,600 --> 00:08:56,560
the outside

00:08:54,640 --> 00:08:58,399
so let's say that you wake up tomorrow

00:08:56,560 --> 00:09:01,760
and nothing works because

00:08:58,399 --> 00:09:03,600
something like is broken how do you look

00:09:01,760 --> 00:09:05,360
and trying to figure out that that

00:09:03,600 --> 00:09:07,600
solution so this question

00:09:05,360 --> 00:09:09,519
is very important and i do it during

00:09:07,600 --> 00:09:11,920
like code review for example

00:09:09,519 --> 00:09:13,839
because that's the good place where i

00:09:11,920 --> 00:09:15,760
can interact with myself or with the

00:09:13,839 --> 00:09:16,320
developer that i'm reviewing the code

00:09:15,760 --> 00:09:18,959
for

00:09:16,320 --> 00:09:19,839
and we can try to figure out how to make

00:09:18,959 --> 00:09:21,600
that feature

00:09:19,839 --> 00:09:24,959
observable and that's where

00:09:21,600 --> 00:09:24,959
observability comes from

00:09:25,680 --> 00:09:28,720
or i mean what about like third-party

00:09:27,920 --> 00:09:30,640
services

00:09:28,720 --> 00:09:32,080
maybe for the code you write that's

00:09:30,640 --> 00:09:34,720
simple because you can

00:09:32,080 --> 00:09:36,160
write logs or you can send events but

00:09:34,720 --> 00:09:38,160
like how do you

00:09:36,160 --> 00:09:39,200
figure out what's going on in my sequel

00:09:38,160 --> 00:09:40,880
if your pain

00:09:39,200 --> 00:09:43,839
your payments at the end goes to my

00:09:40,880 --> 00:09:43,839
sequel for example

00:09:44,399 --> 00:09:48,480
it it's also very hard to make

00:09:46,640 --> 00:09:50,640
developers to agree on

00:09:48,480 --> 00:09:51,600
something we all know that like they

00:09:50,640 --> 00:09:54,240
like to complain

00:09:51,600 --> 00:09:55,279
we are complain driven people and that

00:09:54,240 --> 00:09:58,480
makes everything hard

00:09:55,279 --> 00:09:59,760
so how do you desi how do you tell the

00:09:58,480 --> 00:10:01,839
story of your request

00:09:59,760 --> 00:10:03,360
if you write like microservices that

00:10:01,839 --> 00:10:06,079
come from different languages

00:10:03,360 --> 00:10:07,519
in some way you have to agree at some

00:10:06,079 --> 00:10:10,320
standard at the end

00:10:07,519 --> 00:10:11,200
and this is hard so open telemetry helps

00:10:10,320 --> 00:10:14,079
you to do that

00:10:11,200 --> 00:10:14,399
so open telemetry is a specification

00:10:14,079 --> 00:10:17,760
that

00:10:14,399 --> 00:10:20,240
describes how you instrument your code

00:10:17,760 --> 00:10:21,360
to be able to figure out what's going on

00:10:20,240 --> 00:10:23,440
in your application

00:10:21,360 --> 00:10:25,760
from the outside because this is what we

00:10:23,440 --> 00:10:27,440
do with the monitoring i mean we open a

00:10:25,760 --> 00:10:30,160
dashboard we look at the logs but

00:10:27,440 --> 00:10:31,600
we are outside looking for the inside

00:10:30,160 --> 00:10:32,800
state of the application

00:10:31,600 --> 00:10:34,880
and this is the definition of

00:10:32,800 --> 00:10:37,040
observability in control theory

00:10:34,880 --> 00:10:38,240
so trying to figure out what's going on

00:10:37,040 --> 00:10:40,720
inside the system

00:10:38,240 --> 00:10:43,279
from the outside so you try to dig in

00:10:40,720 --> 00:10:45,600
the internal state of your application

00:10:43,279 --> 00:10:47,839
from your point of view from your

00:10:45,600 --> 00:10:50,800
desktop

00:10:47,839 --> 00:10:51,120
and oftentimes telemetry helps you gives

00:10:50,800 --> 00:10:53,839
you

00:10:51,120 --> 00:10:55,440
specification and client libraries that

00:10:53,839 --> 00:10:58,640
you can use in your code

00:10:55,440 --> 00:11:00,320
to expose metrics in a way that are the

00:10:58,640 --> 00:11:01,680
same across many languages

00:11:00,320 --> 00:11:04,160
because that's what we need at the end

00:11:01,680 --> 00:11:06,320
of the story we need the full story

00:11:04,160 --> 00:11:08,000
no matter which languages you're using

00:11:06,320 --> 00:11:10,079
which cloud provider you're using

00:11:08,000 --> 00:11:12,720
or whatever we just have the first we

00:11:10,079 --> 00:11:16,959
just need the full story

00:11:12,720 --> 00:11:19,040
so your application um may have

00:11:16,959 --> 00:11:20,959
like a language or at least it has a

00:11:19,040 --> 00:11:23,040
language that it speaks

00:11:20,959 --> 00:11:25,279
and the language that the application

00:11:23,040 --> 00:11:25,920
speaks is the one that you are able to

00:11:25,279 --> 00:11:29,200
teach to

00:11:25,920 --> 00:11:31,200
the application itself so logs

00:11:29,200 --> 00:11:32,640
for example are a language that their

00:11:31,200 --> 00:11:35,440
application use

00:11:32,640 --> 00:11:35,760
to tell you something and we are the the

00:11:35,440 --> 00:11:38,959
one

00:11:35,760 --> 00:11:39,920
writing logs so if we like after a

00:11:38,959 --> 00:11:42,079
couple of weeks

00:11:39,920 --> 00:11:43,040
get back to the logs and we can't figure

00:11:42,079 --> 00:11:45,120
out what they are

00:11:43,040 --> 00:11:47,519
it's our fault as a developer because we

00:11:45,120 --> 00:11:51,760
didn't write code that is understandable

00:11:47,519 --> 00:11:54,480
from the outside at least so a bunch of

00:11:51,760 --> 00:11:56,560
like stuff that you can look at to make

00:11:54,480 --> 00:11:57,519
your application to speak in a clear

00:11:56,560 --> 00:12:00,880
language

00:11:57,519 --> 00:12:03,120
is to use structured logs so think about

00:12:00,880 --> 00:12:04,399
structural logs not has a message that

00:12:03,120 --> 00:12:06,560
has a timestamp

00:12:04,399 --> 00:12:08,000
but has a timestamp that has a set of

00:12:06,560 --> 00:12:10,480
key value pairs

00:12:08,000 --> 00:12:11,760
maybe one is the message that is the

00:12:10,480 --> 00:12:14,720
human readable one

00:12:11,760 --> 00:12:16,240
but there are other stuff that you can

00:12:14,720 --> 00:12:18,639
maybe print as a json

00:12:16,240 --> 00:12:19,360
and parse after that so you can think

00:12:18,639 --> 00:12:22,639
about

00:12:19,360 --> 00:12:25,600
those other stuff as a way to

00:12:22,639 --> 00:12:26,800
you know print the state the context of

00:12:25,600 --> 00:12:29,120
your application

00:12:26,800 --> 00:12:30,320
so in the e-commerce it will be like the

00:12:29,120 --> 00:12:33,519
product id

00:12:30,320 --> 00:12:35,279
it will be the customer id

00:12:33,519 --> 00:12:37,120
it will be the payment service that you

00:12:35,279 --> 00:12:39,519
may use so

00:12:37,120 --> 00:12:41,360
all those stuff comes together in your

00:12:39,519 --> 00:12:43,040
log line so you can have the measure

00:12:41,360 --> 00:12:43,760
message but you can also build the

00:12:43,040 --> 00:12:46,240
context

00:12:43,760 --> 00:12:47,839
around that message at that specific

00:12:46,240 --> 00:12:51,200
point in time

00:12:47,839 --> 00:12:52,320
and this is how you do structural logs

00:12:51,200 --> 00:12:55,680
because they are not

00:12:52,320 --> 00:12:57,920
like something that you have to

00:12:55,680 --> 00:12:59,680
string mesh or that you have to index

00:12:57,920 --> 00:13:01,519
like in a search engine

00:12:59,680 --> 00:13:04,000
but it's something that you can parse as

00:13:01,519 --> 00:13:07,040
a json and from there it's way easier to

00:13:04,000 --> 00:13:09,040
make aggregation and so on so context

00:13:07,040 --> 00:13:12,560
propagation is disability

00:13:09,040 --> 00:13:14,959
this ability to you know enrich

00:13:12,560 --> 00:13:15,839
your log with information that comes

00:13:14,959 --> 00:13:17,680
from

00:13:15,839 --> 00:13:20,160
the application in the at the point

00:13:17,680 --> 00:13:23,279
where the logs get printed

00:13:20,160 --> 00:13:24,160
so the correlation is an id that usually

00:13:23,279 --> 00:13:27,360
floats

00:13:24,160 --> 00:13:29,519
um it gets generated from every request

00:13:27,360 --> 00:13:30,399
every request has its own one and it

00:13:29,519 --> 00:13:33,040
goes through

00:13:30,399 --> 00:13:34,160
all the requests in this way you can say

00:13:33,040 --> 00:13:37,440
okay give me

00:13:34,160 --> 00:13:38,399
um all the logs that comes from the

00:13:37,440 --> 00:13:40,800
recast id

00:13:38,399 --> 00:13:42,399
or the correlation id one two three four

00:13:40,800 --> 00:13:46,160
five and you get

00:13:42,399 --> 00:13:49,279
only the one that are related to um

00:13:46,160 --> 00:13:50,320
to that specific request this

00:13:49,279 --> 00:13:52,560
correlation id

00:13:50,320 --> 00:13:53,600
of this request id is something that we

00:13:52,560 --> 00:13:56,160
see a lot when

00:13:53,600 --> 00:13:57,600
when we do traces i will tell you what

00:13:56,160 --> 00:14:00,000
like what tracing is

00:13:57,600 --> 00:14:02,399
later but think about it when you open

00:14:00,000 --> 00:14:04,639
the the dev tools on chrome

00:14:02,399 --> 00:14:05,440
and you go in the network you see all

00:14:04,639 --> 00:14:08,320
the bars

00:14:05,440 --> 00:14:10,480
that represent the time spent from the

00:14:08,320 --> 00:14:11,920
browser downloading all the assets that

00:14:10,480 --> 00:14:15,040
your page requests

00:14:11,920 --> 00:14:16,880
and you see that all the bars

00:14:15,040 --> 00:14:19,680
have time and you can figure out the

00:14:16,880 --> 00:14:23,360
entire picture that is called a trace

00:14:19,680 --> 00:14:25,760
um split by asset this is a trace

00:14:23,360 --> 00:14:27,760
and every line is a span other than that

00:14:25,760 --> 00:14:30,800
your application can also expose

00:14:27,760 --> 00:14:31,839
events and events are like the number of

00:14:30,800 --> 00:14:35,199
logins

00:14:31,839 --> 00:14:36,560
or the number of products that a

00:14:35,199 --> 00:14:39,199
customer so

00:14:36,560 --> 00:14:40,959
split group by product itself all those

00:14:39,199 --> 00:14:43,440
stuff are events that usually

00:14:40,959 --> 00:14:44,079
you can see them as a counter so numbers

00:14:43,440 --> 00:14:46,959
that goes

00:14:44,079 --> 00:14:47,440
up or gauge that are numbered that you

00:14:46,959 --> 00:14:49,279
know

00:14:47,440 --> 00:14:50,880
goes back and forth and you can

00:14:49,279 --> 00:14:54,959
aggregate them and group

00:14:50,880 --> 00:14:57,680
by a specific key

00:14:54,959 --> 00:14:59,600
so when i think about like monitoring or

00:14:57,680 --> 00:15:00,480
infrastructure monitoring i think about

00:14:59,600 --> 00:15:03,360
something like this

00:15:00,480 --> 00:15:03,680
i have the telemetry generator that are

00:15:03,360 --> 00:15:05,760
like

00:15:03,680 --> 00:15:07,600
our applications it will be it will

00:15:05,760 --> 00:15:09,360
maybe your application

00:15:07,600 --> 00:15:11,040
or it will maybe a third party

00:15:09,360 --> 00:15:14,320
application like mysql

00:15:11,040 --> 00:15:17,120
rabbit and q or whatever

00:15:14,320 --> 00:15:17,839
you send all those metrics or to a

00:15:17,120 --> 00:15:19,680
collector

00:15:17,839 --> 00:15:22,560
or the collector goes and takes the

00:15:19,680 --> 00:15:23,680
metrics pull versus push is a debate

00:15:22,560 --> 00:15:25,600
that

00:15:23,680 --> 00:15:26,880
in monitoring will stay forever so

00:15:25,600 --> 00:15:28,800
that's not important but there is a

00:15:26,880 --> 00:15:32,399
collector that usually

00:15:28,800 --> 00:15:34,880
applies back pressure back back pressure

00:15:32,399 --> 00:15:37,040
and push them to the storage uh the

00:15:34,880 --> 00:15:40,720
storage is the place where your metrics

00:15:37,040 --> 00:15:43,360
leaves so i put together a list of

00:15:40,720 --> 00:15:45,120
for all of those categories as i said

00:15:43,360 --> 00:15:46,800
the telemetry generator is the easiest

00:15:45,120 --> 00:15:49,759
one because it's everything like

00:15:46,800 --> 00:15:51,279
everything that expose a metrics your

00:15:49,759 --> 00:15:54,399
application in go

00:15:51,279 --> 00:15:57,120
javascript node.js whatever

00:15:54,399 --> 00:15:58,720
the collector are agents that usually

00:15:57,120 --> 00:16:00,800
runs inside a server

00:15:58,720 --> 00:16:02,639
and collects all the metrics coming from

00:16:00,800 --> 00:16:04,720
the your applications and

00:16:02,639 --> 00:16:06,320
push them to a storage there are

00:16:04,720 --> 00:16:09,199
collectors open source like

00:16:06,320 --> 00:16:11,680
telegraph or prometheus exporter or open

00:16:09,199 --> 00:16:13,839
telemetry has a collector itself

00:16:11,680 --> 00:16:15,759
jaeger new reddick has an agent blog

00:16:13,839 --> 00:16:17,680
stash is an agent and so on

00:16:15,759 --> 00:16:19,839
the storage are places where you can

00:16:17,680 --> 00:16:21,759
store those information

00:16:19,839 --> 00:16:24,079
cassandra is one influx fluxdb

00:16:21,759 --> 00:16:26,480
prometheus there are also has a service

00:16:24,079 --> 00:16:28,399
one like honeycomb or new relic

00:16:26,480 --> 00:16:29,600
or open source like elastic

00:16:28,399 --> 00:16:31,440
elasticsearch

00:16:29,600 --> 00:16:34,079
those are usually called time series

00:16:31,440 --> 00:16:35,839
databases

00:16:34,079 --> 00:16:37,199
obviously you can store those kind of

00:16:35,839 --> 00:16:39,759
metrics everywhere

00:16:37,199 --> 00:16:40,959
but if you use a time series database it

00:16:39,759 --> 00:16:42,959
is designed

00:16:40,959 --> 00:16:46,079
for time series let's say so it's a

00:16:42,959 --> 00:16:46,079
little bit more efficient

00:16:46,480 --> 00:16:49,839
some of the technology that i touched or

00:16:48,480 --> 00:16:52,880
that we will touch

00:16:49,839 --> 00:16:54,800
during this talk has those logos i just

00:16:52,880 --> 00:16:56,160
pushed i just put them there because i

00:16:54,800 --> 00:16:58,959
think it will give you

00:16:56,160 --> 00:17:00,560
an idea or maybe you will rely on them

00:16:58,959 --> 00:17:02,079
like googling around or

00:17:00,560 --> 00:17:04,559
you know surfing the net for those

00:17:02,079 --> 00:17:05,360
information so let's back to what it is

00:17:04,559 --> 00:17:08,480
a trace

00:17:05,360 --> 00:17:10,559
so a trace looks like this so

00:17:08,480 --> 00:17:11,760
it's like the traces of is the full

00:17:10,559 --> 00:17:15,520
picture and

00:17:11,760 --> 00:17:18,880
you see um at the left that there is a

00:17:15,520 --> 00:17:22,000
column with a bunch of ips and those are

00:17:18,880 --> 00:17:23,760
the services that you have in your

00:17:22,000 --> 00:17:27,520
microservices environment

00:17:23,760 --> 00:17:31,679
and every uh span that is the bar

00:17:27,520 --> 00:17:34,640
is is our cast so you can see

00:17:31,679 --> 00:17:36,640
that a specific request goes across your

00:17:34,640 --> 00:17:39,120
entire system and you can see

00:17:36,640 --> 00:17:40,000
how much time it is it gets expands to

00:17:39,120 --> 00:17:42,320
each of them

00:17:40,000 --> 00:17:43,039
or you can even see like how many times

00:17:42,320 --> 00:17:46,880
a service

00:17:43,039 --> 00:17:49,120
is reached um during uh to fulfill

00:17:46,880 --> 00:17:51,120
our cast like for example during one of

00:17:49,120 --> 00:17:54,880
my debugging session with traces i

00:17:51,120 --> 00:17:57,679
and i realized that i were calling like

00:17:54,880 --> 00:17:58,160
the authentication service uh for four

00:17:57,679 --> 00:18:01,520
times

00:17:58,160 --> 00:18:04,240
five times for every cast because

00:18:01,520 --> 00:18:06,320
i was all the time like requiring to

00:18:04,240 --> 00:18:07,679
check the authentication token token and

00:18:06,320 --> 00:18:09,760
that was too much

00:18:07,679 --> 00:18:12,000
um so i was able to make some

00:18:09,760 --> 00:18:14,080
optimization and to save some

00:18:12,000 --> 00:18:16,080
requests and make my my you know

00:18:14,080 --> 00:18:18,720
response way faster

00:18:16,080 --> 00:18:19,679
when you click on the span you have the

00:18:18,720 --> 00:18:23,600
ability

00:18:19,679 --> 00:18:26,000
to see like the metadata attached to

00:18:23,600 --> 00:18:26,320
every span so for example i'm saving the

00:18:26,000 --> 00:18:28,559
com

00:18:26,320 --> 00:18:30,080
the name of the components in this case

00:18:28,559 --> 00:18:33,120
i was i was tracing

00:18:30,080 --> 00:18:36,240
the aws request so from the aws

00:18:33,120 --> 00:18:36,799
client the sdk i were tracing i was

00:18:36,240 --> 00:18:40,080
tracing

00:18:36,799 --> 00:18:41,360
all the requests that i were i was doing

00:18:40,080 --> 00:18:43,919
to the aws

00:18:41,360 --> 00:18:44,960
this visualization those are screenshot

00:18:43,919 --> 00:18:48,720
that comes from

00:18:44,960 --> 00:18:50,799
zipkin zipkin is a popular tracer

00:18:48,720 --> 00:18:52,080
written in java if you are more familiar

00:18:50,799 --> 00:18:54,880
with go

00:18:52,080 --> 00:18:56,400
you can use jaeger as well there are

00:18:54,880 --> 00:18:58,000
links about those stuff at the end of

00:18:56,400 --> 00:19:01,120
the slides as well

00:18:58,000 --> 00:19:01,840
so the obviously it doesn't care i don't

00:19:01,120 --> 00:19:05,039
care about

00:19:01,840 --> 00:19:07,360
like the language that you write to

00:19:05,039 --> 00:19:09,440
it's like you can you can look at them

00:19:07,360 --> 00:19:10,880
as a database so jager and zipkin are

00:19:09,440 --> 00:19:12,960
like a database that you can

00:19:10,880 --> 00:19:14,480
push all your metrics in so it doesn't

00:19:12,960 --> 00:19:16,960
matter where they come from

00:19:14,480 --> 00:19:19,120
and later i will show you a few examples

00:19:16,960 --> 00:19:20,960
with javascript obviously

00:19:19,120 --> 00:19:23,280
so when i think about like code

00:19:20,960 --> 00:19:24,080
instrumentation is critical for you for

00:19:23,280 --> 00:19:27,440
your application

00:19:24,080 --> 00:19:30,559
because that's how a developer

00:19:27,440 --> 00:19:31,919
teaches the application the language the

00:19:30,559 --> 00:19:34,799
proper language that

00:19:31,919 --> 00:19:35,520
you will look at when trying to solve an

00:19:34,799 --> 00:19:37,919
issue

00:19:35,520 --> 00:19:40,080
and usually your application has logging

00:19:37,919 --> 00:19:41,039
metrics and tracing it is a big part of

00:19:40,080 --> 00:19:43,600
your application

00:19:41,039 --> 00:19:45,039
it's not just few lines of code there

00:19:43,600 --> 00:19:46,960
are proper libraries

00:19:45,039 --> 00:19:48,480
and in some way you have to organize

00:19:46,960 --> 00:19:50,480
them so in

00:19:48,480 --> 00:19:51,520
the idea is that you can you should try

00:19:50,480 --> 00:19:54,080
to encapsulate

00:19:51,520 --> 00:19:55,280
those stuff as far away as you can from

00:19:54,080 --> 00:19:57,520
the business logic

00:19:55,280 --> 00:19:59,360
this is hard for logging but for tracing

00:19:57,520 --> 00:19:59,760
a metrics it's a bit a bit is a little

00:19:59,360 --> 00:20:02,080
bit

00:19:59,760 --> 00:20:02,960
easier and you can use like event

00:20:02,080 --> 00:20:06,000
listener

00:20:02,960 --> 00:20:08,000
and stuff like that

00:20:06,000 --> 00:20:09,039
another important part is the

00:20:08,000 --> 00:20:11,919
propagation

00:20:09,039 --> 00:20:14,240
because as you realized like there is a

00:20:11,919 --> 00:20:16,559
bag of information that has to go

00:20:14,240 --> 00:20:18,640
from a service to another and how do you

00:20:16,559 --> 00:20:20,960
move the correlation id between

00:20:18,640 --> 00:20:22,960
all those stuff it depends on the lang

00:20:20,960 --> 00:20:24,640
on the protocol that you are using for

00:20:22,960 --> 00:20:27,760
example in http

00:20:24,640 --> 00:20:29,600
um or tcp you can use the headers so one

00:20:27,760 --> 00:20:32,480
of the propagation formats

00:20:29,600 --> 00:20:33,360
is called b3 and it works in this way so

00:20:32,480 --> 00:20:36,480
this is a

00:20:33,360 --> 00:20:37,120
tcp or an http request as a as you can

00:20:36,480 --> 00:20:40,400
see

00:20:37,120 --> 00:20:43,600
the headers contains a bunch of x

00:20:40,400 --> 00:20:44,960
b3 stuff and those are information from

00:20:43,600 --> 00:20:48,000
the trace itself

00:20:44,960 --> 00:20:51,280
so the req the the service that

00:20:48,000 --> 00:20:53,520
they make their cast pass those headers

00:20:51,280 --> 00:20:54,640
and the server that receive their cast

00:20:53,520 --> 00:20:57,760
is able to

00:20:54,640 --> 00:21:01,120
um bundle them and you know

00:20:57,760 --> 00:21:02,400
create its spam that has the same trace

00:21:01,120 --> 00:21:04,799
id as a parent

00:21:02,400 --> 00:21:06,480
so you can create the hierarchy that we

00:21:04,799 --> 00:21:08,640
saw before

00:21:06,480 --> 00:21:10,480
so this is a bit of an overview about

00:21:08,640 --> 00:21:12,720
how tracing works in practice

00:21:10,480 --> 00:21:14,960
but let's see how open telemetry gis

00:21:12,720 --> 00:21:17,440
works so hoping telemetry js

00:21:14,960 --> 00:21:18,799
is a library that you know follow the

00:21:17,440 --> 00:21:20,000
open tracing experience the open

00:21:18,799 --> 00:21:23,120
telemetry is pretty

00:21:20,000 --> 00:21:24,240
specification but and it is everything

00:21:23,120 --> 00:21:26,880
in javascript

00:21:24,240 --> 00:21:27,760
so you can check it out um i learned a

00:21:26,880 --> 00:21:30,640
lot about

00:21:27,760 --> 00:21:31,520
looking just looking at the foldering so

00:21:30,640 --> 00:21:33,440
i decided

00:21:31,520 --> 00:21:35,520
to share the foldering with you because

00:21:33,440 --> 00:21:36,000
i think it's critical to figure to you

00:21:35,520 --> 00:21:38,000
know

00:21:36,000 --> 00:21:39,280
have a good understanding about how the

00:21:38,000 --> 00:21:40,880
application works

00:21:39,280 --> 00:21:43,360
so as you can see there is a folder it's

00:21:40,880 --> 00:21:44,000
called examples and there are examples

00:21:43,360 --> 00:21:47,200
about how

00:21:44,000 --> 00:21:50,720
to trace like http uh request

00:21:47,200 --> 00:21:51,520
https request or dns request or sql

00:21:50,720 --> 00:21:53,200
requests and

00:21:51,520 --> 00:21:54,720
those kind of stuff so you get a sample

00:21:53,200 --> 00:21:57,200
application that

00:21:54,720 --> 00:21:59,200
helps you um to figure out what's going

00:21:57,200 --> 00:22:00,400
on there is another directory that's

00:21:59,200 --> 00:22:03,600
called packages

00:22:00,400 --> 00:22:06,799
and packages uh gives you

00:22:03,600 --> 00:22:10,400
um a concrete implementation

00:22:06,799 --> 00:22:12,799
about uh like how to trace specific

00:22:10,400 --> 00:22:13,679
components like for example you can

00:22:12,799 --> 00:22:18,080
trace

00:22:13,679 --> 00:22:19,919
um grpc recast or http request https

00:22:18,080 --> 00:22:21,919
request and so on

00:22:19,919 --> 00:22:23,120
those stuff you just have to import

00:22:21,919 --> 00:22:25,200
those packages

00:22:23,120 --> 00:22:26,720
and your up your application will be

00:22:25,200 --> 00:22:29,360
traced automatically

00:22:26,720 --> 00:22:30,960
so as you can see there are like prefix

00:22:29,360 --> 00:22:32,880
open telemetry plugins

00:22:30,960 --> 00:22:34,400
for the plugin that helps you to

00:22:32,880 --> 00:22:36,720
instrument your application

00:22:34,400 --> 00:22:37,760
but there are also open telemetry

00:22:36,720 --> 00:22:40,960
exporter

00:22:37,760 --> 00:22:41,760
that are that those packages contains

00:22:40,960 --> 00:22:44,559
the code

00:22:41,760 --> 00:22:46,000
that teaches open telemetry where to

00:22:44,559 --> 00:22:48,080
push your metrics

00:22:46,000 --> 00:22:51,120
so as you can see there is jaeger and

00:22:48,080 --> 00:22:53,520
zipkin that are the popular tracer that

00:22:51,120 --> 00:22:56,080
i told you about there is also an

00:22:53,520 --> 00:22:58,240
exporter for prometheus because

00:22:56,080 --> 00:22:59,280
that is a time series database that it's

00:22:58,240 --> 00:23:02,799
used to store

00:22:59,280 --> 00:23:06,080
events and so because

00:23:02,799 --> 00:23:09,840
the open telemetry supports traces

00:23:06,080 --> 00:23:09,840
and events

00:23:11,039 --> 00:23:15,679
so this is one of the example i took

00:23:13,120 --> 00:23:18,880
from the examples directory

00:23:15,679 --> 00:23:22,080
and as you can see this is a server um

00:23:18,880 --> 00:23:25,440
written with the http package and

00:23:22,080 --> 00:23:28,080
for what concerns traces it's easy

00:23:25,440 --> 00:23:29,200
it is just easy as importing like a

00:23:28,080 --> 00:23:33,200
single file

00:23:29,200 --> 00:23:36,960
in this case the example http server

00:23:33,200 --> 00:23:40,320
and that file

00:23:36,960 --> 00:23:43,200
provision and provide you a trace

00:23:40,320 --> 00:23:44,000
configured as you wish with the right

00:23:43,200 --> 00:23:46,000
plugins

00:23:44,000 --> 00:23:47,760
and with the right exporter so let's

00:23:46,000 --> 00:23:51,600
have a look at how the example

00:23:47,760 --> 00:23:54,159
http server look like

00:23:51,600 --> 00:23:54,799
this is it as you can see we import we

00:23:54,159 --> 00:23:57,520
recruit

00:23:54,799 --> 00:23:59,279
we require like a bunch of core

00:23:57,520 --> 00:24:02,480
libraries from open telemetry

00:23:59,279 --> 00:24:05,520
the api the node and the tracing

00:24:02,480 --> 00:24:08,559
and you also have to decide

00:24:05,520 --> 00:24:09,600
um where to push your matrix and in this

00:24:08,559 --> 00:24:13,360
example

00:24:09,600 --> 00:24:16,240
based on an environment variable we can

00:24:13,360 --> 00:24:19,600
switch between jaeger and zip team so we

00:24:16,240 --> 00:24:22,880
import both exporter and as you can see

00:24:19,600 --> 00:24:26,400
we inject into the tracer

00:24:22,880 --> 00:24:29,200
the concrete exporter so

00:24:26,400 --> 00:24:30,400
here you can see that there are no

00:24:29,200 --> 00:24:33,279
plugins

00:24:30,400 --> 00:24:33,919
and this is because the tracer itself

00:24:33,279 --> 00:24:37,760
comes

00:24:33,919 --> 00:24:39,279
comes from uh comes with a specific set

00:24:37,760 --> 00:24:43,279
of plugins already

00:24:39,279 --> 00:24:44,880
um provisional by default

00:24:43,279 --> 00:24:47,279
so you don't have to do anything more

00:24:44,880 --> 00:24:49,039
than that to get a trace from an http

00:24:47,279 --> 00:24:51,760
request

00:24:49,039 --> 00:24:54,480
and also to get it propagated through

00:24:51,760 --> 00:24:54,480
the next one

00:24:56,080 --> 00:25:00,880
so how does it work i mean it looks too

00:24:59,039 --> 00:25:04,080
easy and it is true

00:25:00,880 --> 00:25:07,039
and i think as a javascript developer we

00:25:04,080 --> 00:25:07,840
are in the unique in you know we are

00:25:07,039 --> 00:25:11,120
lucky

00:25:07,840 --> 00:25:14,480
because we can drop our

00:25:11,120 --> 00:25:15,440
like functions every function from the

00:25:14,480 --> 00:25:17,919
outside

00:25:15,440 --> 00:25:18,720
and this is cool because it helps you to

00:25:17,919 --> 00:25:21,919
write

00:25:18,720 --> 00:25:24,400
automations uh to write you know um

00:25:21,919 --> 00:25:26,480
tracing code that doesn't go into the

00:25:24,400 --> 00:25:29,440
business logic because you can do it by

00:25:26,480 --> 00:25:31,919
by from the outside and this is uh

00:25:29,440 --> 00:25:34,880
important and

00:25:31,919 --> 00:25:36,159
shimmer is the library that is used by

00:25:34,880 --> 00:25:39,919
open telemetry

00:25:36,159 --> 00:25:41,440
uh to to instrument all the code from

00:25:39,919 --> 00:25:42,720
the outside and this is why you don't

00:25:41,440 --> 00:25:45,600
you don't have to

00:25:42,720 --> 00:25:46,480
go in every line of your code and do the

00:25:45,600 --> 00:25:48,480
instrumentation

00:25:46,480 --> 00:25:50,320
as you will may do in other languages

00:25:48,480 --> 00:25:51,760
like golang because golden doesn't have

00:25:50,320 --> 00:25:53,520
this ability

00:25:51,760 --> 00:25:55,520
java has it because you can instrument

00:25:53,520 --> 00:25:57,440
the jvm um

00:25:55,520 --> 00:25:58,720
but not for for javascript this is very

00:25:57,440 --> 00:26:02,400
cool and yeah

00:25:58,720 --> 00:26:05,039
if you have to write your uh specific

00:26:02,400 --> 00:26:07,279
instrumentation for your business code

00:26:05,039 --> 00:26:07,760
uh you can use shimmer as well because

00:26:07,279 --> 00:26:09,440
it's

00:26:07,760 --> 00:26:11,679
it's very simple and you don't have to

00:26:09,440 --> 00:26:14,799
go where your application

00:26:11,679 --> 00:26:18,799
is so this is it

00:26:14,799 --> 00:26:21,200
um i i leave i will leave you a bunch of

00:26:18,799 --> 00:26:24,159
links because the topic is very big

00:26:21,200 --> 00:26:25,679
and i hope this slides and presentation

00:26:24,159 --> 00:26:27,600
will help you

00:26:25,679 --> 00:26:29,679
you know to figure out that this is a

00:26:27,600 --> 00:26:31,919
topic and it's not too

00:26:29,679 --> 00:26:33,840
hard compared with other languages for

00:26:31,919 --> 00:26:34,640
javascript developer to pick it up with

00:26:33,840 --> 00:26:36,559
tracing

00:26:34,640 --> 00:26:38,559
and i think it's super important when

00:26:36,559 --> 00:26:40,880
you do when you have a distributed

00:26:38,559 --> 00:26:42,159
system or also with a monolith that is

00:26:40,880 --> 00:26:45,039
very asynchronous

00:26:42,159 --> 00:26:47,360
so i use it a lot when i have cues or

00:26:45,039 --> 00:26:50,000
when i do even sourcing because

00:26:47,360 --> 00:26:51,919
i can tell the story for all the events

00:26:50,000 --> 00:26:53,200
or for all the process and i can follow

00:26:51,919 --> 00:26:55,840
the message in the queues

00:26:53,200 --> 00:26:57,600
and i can tell for how long it stays and

00:26:55,840 --> 00:26:59,919
which worker processing

00:26:57,600 --> 00:27:02,159
and and so on so the first link is my

00:26:59,919 --> 00:27:04,080
github into my twitter account because

00:27:02,159 --> 00:27:05,760
you can reach me out there my dms are

00:27:04,080 --> 00:27:07,520
open the second one is the open

00:27:05,760 --> 00:27:08,640
telemetry when you can learn more about

00:27:07,520 --> 00:27:10,720
the specification

00:27:08,640 --> 00:27:12,480
and you can see all the other languages

00:27:10,720 --> 00:27:16,000
supported like python

00:27:12,480 --> 00:27:16,880
golem php and so on and the third one is

00:27:16,000 --> 00:27:19,520
my blog where i

00:27:16,880 --> 00:27:20,159
wrote about tracing and open telemetry

00:27:19,520 --> 00:27:22,000
as well

00:27:20,159 --> 00:27:23,279
jaeger is the pop one of the popular

00:27:22,000 --> 00:27:26,640
tracer that i

00:27:23,279 --> 00:27:27,440
um spoke about so you can use it in open

00:27:26,640 --> 00:27:31,679
source

00:27:27,440 --> 00:27:34,240
and it's also sponsored by them the cncf

00:27:31,679 --> 00:27:35,919
so honeycomb is a company that provides

00:27:34,240 --> 00:27:38,399
an as a service solution for

00:27:35,919 --> 00:27:39,200
for observability and they have a cool

00:27:38,399 --> 00:27:41,520
blog where they

00:27:39,200 --> 00:27:42,960
write a lot about this stuff those

00:27:41,520 --> 00:27:45,840
topics so check them out

00:27:42,960 --> 00:27:48,159
and because they are like on top of the

00:27:45,840 --> 00:27:50,880
of this topic

00:27:48,159 --> 00:27:52,799
the the open telemetry has a guitar

00:27:50,880 --> 00:27:55,279
community so you can go there in chat

00:27:52,799 --> 00:27:57,039
they are super reliable i learned a lot

00:27:55,279 --> 00:27:58,799
from them and you can also contribute

00:27:57,039 --> 00:28:00,240
because it's open source so check out

00:27:58,799 --> 00:28:03,200
the repository itself

00:28:00,240 --> 00:28:04,880
and the last link is an application in

00:28:03,200 --> 00:28:06,559
node.js that i wrote

00:28:04,880 --> 00:28:09,120
and that i instrumented with

00:28:06,559 --> 00:28:12,080
opentelemetry uh it is a

00:28:09,120 --> 00:28:12,880
a sample application so it contains also

00:28:12,080 --> 00:28:14,640
other

00:28:12,880 --> 00:28:16,080
application other languages so it's an

00:28:14,640 --> 00:28:19,279
e-commerce it's an e-commerce

00:28:16,080 --> 00:28:21,520
like it's a dummy e-commerce uh that

00:28:19,279 --> 00:28:22,480
uh it's in it's written in five

00:28:21,520 --> 00:28:25,600
different languages

00:28:22,480 --> 00:28:28,159
and it is instrumented with tracing and

00:28:25,600 --> 00:28:30,320
logs so you can have a look about how it

00:28:28,159 --> 00:28:32,320
works in practice over there

00:28:30,320 --> 00:28:36,640
so thank you for your time and let me

00:28:32,320 --> 00:28:36,640

YouTube URL: https://www.youtube.com/watch?v=jiIEPbuPb3c


