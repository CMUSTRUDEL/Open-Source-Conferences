Title: Low Code for the Node.js Developer - Nick O Leary, IBM
Publication date: 2020-06-17
Playlist: OpenJS World 2020
Description: 
	
Captions: 
	00:00:05,820 --> 00:00:10,900
hi my name's Nick O'Leary I'm an open

00:00:09,099 --> 00:00:14,259
source developer at IBM and the project

00:00:10,900 --> 00:00:16,690
lead of node-red in this talk I'm going

00:00:14,259 --> 00:00:18,310
to cover loco development and why it's

00:00:16,690 --> 00:00:21,190
interesting for JavaScript and node

00:00:18,310 --> 00:00:23,200
developers alike I'm going to use

00:00:21,190 --> 00:00:25,090
node-red as an example of a loco

00:00:23,200 --> 00:00:27,580
development tool and show how it can be

00:00:25,090 --> 00:00:29,800
easily extended by adding new nodes to

00:00:27,580 --> 00:00:31,570
its palette of capabilities I'll also

00:00:29,800 --> 00:00:33,489
talk about what lessons developing

00:00:31,570 --> 00:00:35,980
modules for a loco development

00:00:33,489 --> 00:00:40,210
environment can be applied when creating

00:00:35,980 --> 00:00:42,699
regular node.js modules so to start

00:00:40,210 --> 00:00:44,499
let's talk about loco development to

00:00:42,699 --> 00:00:46,089
help put it into context let's just step

00:00:44,499 --> 00:00:48,489
back and think about how coding has

00:00:46,089 --> 00:00:51,100
evolved in the beginning there was

00:00:48,489 --> 00:00:53,769
machine code the raw binary used by the

00:00:51,100 --> 00:00:55,780
computer to control its circuits as a

00:00:53,769 --> 00:00:58,510
developer you had to speak the

00:00:55,780 --> 00:01:00,010
computer's native language the second

00:00:58,510 --> 00:01:02,289
generation of languages were assembly

00:01:00,010 --> 00:01:03,999
languages these were the first steps

00:01:02,289 --> 00:01:06,659
towards accommodating of programmers

00:01:03,999 --> 00:01:08,619
needs rather than those of the computer

00:01:06,659 --> 00:01:11,049
we then have a third generation

00:01:08,619 --> 00:01:12,790
languages which is what many of us think

00:01:11,049 --> 00:01:16,960
of when we talk about programming

00:01:12,790 --> 00:01:19,689
languages today see Java Python

00:01:16,960 --> 00:01:21,430
JavaScript and so on they are much more

00:01:19,689 --> 00:01:24,159
independent of the machine they run on

00:01:21,430 --> 00:01:24,640
they are far more portable some more

00:01:24,159 --> 00:01:26,799
than others

00:01:24,640 --> 00:01:29,350
they provide structured data types

00:01:26,799 --> 00:01:31,509
rather than simple bits and bytes they

00:01:29,350 --> 00:01:34,479
provide easier ways to organize and

00:01:31,509 --> 00:01:37,090
structure code and then we come to the

00:01:34,479 --> 00:01:38,469
fourth generation of languages they tend

00:01:37,090 --> 00:01:40,750
to be more domain-specific

00:01:38,469 --> 00:01:42,700
tools with much less of a focus on bits

00:01:40,750 --> 00:01:45,219
and bytes and more interested in the

00:01:42,700 --> 00:01:46,719
higher level data they work with and the

00:01:45,219 --> 00:01:48,399
key thing to recognize is the increased

00:01:46,719 --> 00:01:50,890
labor abstraction as you go through

00:01:48,399 --> 00:01:52,840
these generations of language each

00:01:50,890 --> 00:01:54,820
abstraction moves your way from having

00:01:52,840 --> 00:01:56,560
to understand the machine code from

00:01:54,820 --> 00:01:58,479
having to deal with low-level memory

00:01:56,560 --> 00:02:00,609
management from having to decide how

00:01:58,479 --> 00:02:05,170
best to represent your data in whatever

00:02:00,609 --> 00:02:06,670
binary format as developers we accept

00:02:05,170 --> 00:02:08,679
those abstractions for what they are

00:02:06,670 --> 00:02:11,080
they're our convenience to make us more

00:02:08,679 --> 00:02:11,920
productive and those abstractions do

00:02:11,080 --> 00:02:13,900
more than just that

00:02:11,920 --> 00:02:15,340
a modern compiler can generate

00:02:13,900 --> 00:02:17,379
machine code that's highly optimized

00:02:15,340 --> 00:02:19,959
probably far more so than if you try to

00:02:17,379 --> 00:02:21,700
write it by hand because they can fold

00:02:19,959 --> 00:02:25,269
in the decades of experience and

00:02:21,700 --> 00:02:26,739
knowledge that exists low code

00:02:25,269 --> 00:02:28,480
programming is a style of

00:02:26,739 --> 00:02:30,549
fourth-generation programming language

00:02:28,480 --> 00:02:33,159
it typically involves some sort of

00:02:30,549 --> 00:02:35,530
graphically driven development where the

00:02:33,159 --> 00:02:38,409
developers assembling and configuring

00:02:35,530 --> 00:02:41,500
components rather than hand coding

00:02:38,409 --> 00:02:43,689
discrete parts of an application they're

00:02:41,500 --> 00:02:47,700
graphical nature provides that increased

00:02:43,689 --> 00:02:50,319
abstraction over screens full of code

00:02:47,700 --> 00:02:51,730
now before getting too deep I want to

00:02:50,319 --> 00:02:53,349
briefly mention the other type of

00:02:51,730 --> 00:02:55,299
programming that often gets bundled

00:02:53,349 --> 00:02:58,209
together with low code programming and

00:02:55,299 --> 00:03:00,069
that's no code programming now there's

00:02:58,209 --> 00:03:03,189
an important distinction no code

00:03:00,069 --> 00:03:04,780
programming means just that the user who

00:03:03,189 --> 00:03:06,819
may well not consider themselves a

00:03:04,780 --> 00:03:08,530
developer in the slightest does not need

00:03:06,819 --> 00:03:11,530
to touch anything that looks remotely

00:03:08,530 --> 00:03:14,560
like code a great example that menu

00:03:11,530 --> 00:03:17,139
review be familiar with is if this than

00:03:14,560 --> 00:03:19,000
that as a web service it allows you to

00:03:17,139 --> 00:03:20,019
create workflows in your browser purely

00:03:19,000 --> 00:03:22,120
through clicking options

00:03:20,019 --> 00:03:24,730
whilst it's very versatile it does keep

00:03:22,120 --> 00:03:26,500
you somewhat constrained to the types of

00:03:24,730 --> 00:03:28,209
integrations they support and there's

00:03:26,500 --> 00:03:29,859
nothing wrong with that except when you

00:03:28,209 --> 00:03:31,690
want to do that extra little thing

00:03:29,859 --> 00:03:36,129
that's slightly off the rails that they

00:03:31,690 --> 00:03:37,299
keep you on low code by contrast still

00:03:36,129 --> 00:03:39,790
allows the user to create workflows

00:03:37,299 --> 00:03:42,310
through visual tools but it does give

00:03:39,790 --> 00:03:44,620
the user some more leeway to insert bits

00:03:42,310 --> 00:03:46,060
of code when it's needed different loco

00:03:44,620 --> 00:03:49,989
tools provide different degrees of

00:03:46,060 --> 00:03:52,299
flexibility in that regard the higher

00:03:49,989 --> 00:03:54,699
level of abstraction also helps to make

00:03:52,299 --> 00:03:57,220
it more accessible to a wider range of

00:03:54,699 --> 00:03:59,349
users by hiding the individual lines of

00:03:57,220 --> 00:04:00,699
code a user is able to focus on solving

00:03:59,349 --> 00:04:01,440
whatever problem they're trying to

00:04:00,699 --> 00:04:04,239
address

00:04:01,440 --> 00:04:06,879
they can also be tailored to particular

00:04:04,239 --> 00:04:09,280
problem domains so they're presented in

00:04:06,879 --> 00:04:11,500
terms of domain experts who may not be a

00:04:09,280 --> 00:04:14,260
developer is able to relate more closely

00:04:11,500 --> 00:04:16,930
to and making it easier for a wider

00:04:14,260 --> 00:04:21,519
range of users to be able to create

00:04:16,930 --> 00:04:23,529
applications is a good thing but how

00:04:21,519 --> 00:04:25,960
does this relate to no js' and

00:04:23,529 --> 00:04:27,020
JavaScript well with node you see a

00:04:25,960 --> 00:04:30,020
similar pattern of

00:04:27,020 --> 00:04:32,030
distraction node core provides a set of

00:04:30,020 --> 00:04:35,240
standard libraries to provide an

00:04:32,030 --> 00:04:38,180
abstraction over the v8 engine you have

00:04:35,240 --> 00:04:40,069
things like HTTP module but more than

00:04:38,180 --> 00:04:42,379
not you'll use a module that wraps the

00:04:40,069 --> 00:04:43,220
low-level HTTP API into something more

00:04:42,379 --> 00:04:45,860
consumable

00:04:43,220 --> 00:04:46,340
Axios got or whichever is the flavor of

00:04:45,860 --> 00:04:48,289
the month

00:04:46,340 --> 00:04:49,819
these modules don't stop you as a

00:04:48,289 --> 00:04:52,220
developer from using the lower-level

00:04:49,819 --> 00:04:56,000
api's but it's often more comfortable to

00:04:52,220 --> 00:04:58,190
use the higher level abstractions and it

00:04:56,000 --> 00:04:59,990
goes in the other direction as well for

00:04:58,190 --> 00:05:02,300
those tasks that need the performance of

00:04:59,990 --> 00:05:04,130
native code you could choose to create a

00:05:02,300 --> 00:05:05,659
compiled add-on and integrate it

00:05:04,130 --> 00:05:10,639
relatively seamlessly with your

00:05:05,659 --> 00:05:12,979
JavaScript code so that now brings us to

00:05:10,639 --> 00:05:17,720
node-red a low code development tool

00:05:12,979 --> 00:05:19,819
built on top of node.js if you haven't

00:05:17,720 --> 00:05:21,800
seen node read before this is what it

00:05:19,819 --> 00:05:24,020
looks like you get a browser-based

00:05:21,800 --> 00:05:26,240
editor with a pallet of nodes down the

00:05:24,020 --> 00:05:27,770
left-hand side and a workspace in the

00:05:26,240 --> 00:05:32,389
middle where you drag on the nodes to

00:05:27,770 --> 00:05:34,340
create your flows each node represents a

00:05:32,389 --> 00:05:36,710
discrete piece of functionality and it

00:05:34,340 --> 00:05:38,659
acts as a black box it receives a

00:05:36,710 --> 00:05:40,370
message does something with that message

00:05:38,659 --> 00:05:43,610
and then passes it on to whatever other

00:05:40,370 --> 00:05:46,310
nodes it's wired to so in this

00:05:43,610 --> 00:05:49,279
environment you're drawing the logical

00:05:46,310 --> 00:05:51,740
flow of information here I have a flow

00:05:49,279 --> 00:05:53,779
that defines an HTTP endpoint when the

00:05:51,740 --> 00:05:56,240
HTTP request arrives at node read this

00:05:53,779 --> 00:05:58,460
node is triggered the message it passes

00:05:56,240 --> 00:06:01,520
on contains information about the

00:05:58,460 --> 00:06:03,169
incoming request we pass that to a

00:06:01,520 --> 00:06:07,509
template node that generates HTML

00:06:03,169 --> 00:06:07,509
content using the data provided

00:06:10,009 --> 00:06:16,430
and then passes to a response node to

00:06:13,009 --> 00:06:18,469
respond to the request and we can also

00:06:16,430 --> 00:06:21,969
add in debug nodes to examine the

00:06:18,469 --> 00:06:21,969
messages passing through a flow

00:06:26,470 --> 00:06:33,100
so when I now load this URL in my

00:06:29,210 --> 00:06:33,100
browser you get an HTML page

00:06:36,060 --> 00:06:42,080
and in the ignorant editor we see the

00:06:38,639 --> 00:06:42,080
message in the debug sidebar

00:06:44,230 --> 00:06:49,300
and that's what no dreads about building

00:06:46,960 --> 00:06:51,880
applications by drawing the logical flow

00:06:49,300 --> 00:06:55,890
of events the nodes representing each

00:06:51,880 --> 00:06:58,690
step the event or message passes through

00:06:55,890 --> 00:07:01,000
now no dread comes with 30 or so core

00:06:58,690 --> 00:07:03,520
nodes covering a wide set of basic

00:07:01,000 --> 00:07:05,590
building blocks knows to handle setting

00:07:03,520 --> 00:07:08,730
message properties branching the flow

00:07:05,590 --> 00:07:10,750
based on logic handling HTTP TCP UDP

00:07:08,730 --> 00:07:13,840
connections splitting and joining

00:07:10,750 --> 00:07:15,340
messages all sorts of things and as a

00:07:13,840 --> 00:07:17,440
platform the main way its capabilities

00:07:15,340 --> 00:07:20,110
can be extended is by adding extra nodes

00:07:17,440 --> 00:07:21,850
to this pallet as it stands there are

00:07:20,110 --> 00:07:24,400
over two and a half thousand contributed

00:07:21,850 --> 00:07:26,020
nodes available covering a huge range of

00:07:24,400 --> 00:07:29,320
topics such as talking to hardware

00:07:26,020 --> 00:07:31,150
devices databases web api's other pieces

00:07:29,320 --> 00:07:34,360
of pre-canned logic and so on and

00:07:31,150 --> 00:07:36,670
there's always room for more so let's

00:07:34,360 --> 00:07:40,480
talk a bit about what a node actually is

00:07:36,670 --> 00:07:43,720
under the covers a nodes implemented in

00:07:40,480 --> 00:07:46,150
two parts a node.js module that provides

00:07:43,720 --> 00:07:48,610
its runtime functionality defining what

00:07:46,150 --> 00:07:50,290
the node actually does in a flow and it

00:07:48,610 --> 00:07:52,360
has an HTML file that it's used by the

00:07:50,290 --> 00:07:56,290
editor to define its appearance help

00:07:52,360 --> 00:07:58,300
text and it's edit dialogue those two

00:07:56,290 --> 00:08:00,400
files are then packaged as a regular

00:07:58,300 --> 00:08:02,860
node module by adding a packaged or JSON

00:08:00,400 --> 00:08:05,020
file that contains a custom node read

00:08:02,860 --> 00:08:08,140
section that identifies the files and

00:08:05,020 --> 00:08:10,030
the module containing nodes let's dive

00:08:08,140 --> 00:08:14,530
into a nodes code to see how its

00:08:10,030 --> 00:08:16,960
structured a node module has to export a

00:08:14,530 --> 00:08:18,760
single function this function is called

00:08:16,960 --> 00:08:21,160
when the module is being loaded into the

00:08:18,760 --> 00:08:23,320
node-red runtime it gets passed in an

00:08:21,160 --> 00:08:27,010
object that's the nodes handle into the

00:08:23,320 --> 00:08:29,590
runtime api next the code defines a

00:08:27,010 --> 00:08:31,240
constructor function for a node this

00:08:29,590 --> 00:08:33,220
gets called whenever the runtime needs

00:08:31,240 --> 00:08:36,610
to create a new instance of that node

00:08:33,220 --> 00:08:39,310
that happens whenever the users made

00:08:36,610 --> 00:08:41,919
some changes in the editor they click

00:08:39,310 --> 00:08:43,840
the deploy button the editor packages up

00:08:41,919 --> 00:08:46,840
the configuration in a JSON format and

00:08:43,840 --> 00:08:48,460
sends it back to the runtime the runtime

00:08:46,840 --> 00:08:51,160
then loops through all the nodes and the

00:08:48,460 --> 00:08:53,230
flow configuration and creates instances

00:08:51,160 --> 00:08:56,440
of each one passing in the configuration

00:08:53,230 --> 00:08:58,930
for that particular instance

00:08:56,440 --> 00:09:00,250
so within the constructor function the

00:08:58,930 --> 00:09:03,160
first thing has to do is call this

00:09:00,250 --> 00:09:05,140
utility function called create node that

00:09:03,160 --> 00:09:07,090
turns this object into a proper node red

00:09:05,140 --> 00:09:08,650
node it can then do whatever work it

00:09:07,090 --> 00:09:12,310
needs to do to get ready to start

00:09:08,650 --> 00:09:14,740
handling messages for example it needs

00:09:12,310 --> 00:09:16,300
to validate its configuration maybe it

00:09:14,740 --> 00:09:20,260
needs to establish a connection to a

00:09:16,300 --> 00:09:22,060
remote system whatever it needs to do so

00:09:20,260 --> 00:09:24,460
at this point we've defined the code for

00:09:22,060 --> 00:09:26,440
creating the node next we need to define

00:09:24,460 --> 00:09:28,750
how the node will handle messages the

00:09:26,440 --> 00:09:32,110
run time passes it this is done by

00:09:28,750 --> 00:09:33,730
adding a handler for the input event the

00:09:32,110 --> 00:09:36,370
event is triggered whenever there's a

00:09:33,730 --> 00:09:38,080
message for the node an important point

00:09:36,370 --> 00:09:40,150
to know here is the events are handed

00:09:38,080 --> 00:09:42,550
completely asynchronously to when

00:09:40,150 --> 00:09:44,650
they're emitted which is unlike the core

00:09:42,550 --> 00:09:49,480
node event emitter object which is fully

00:09:44,650 --> 00:09:52,300
synchronous the event handler is passed

00:09:49,480 --> 00:09:55,690
the message being received a send

00:09:52,300 --> 00:09:57,520
function and a done function the handler

00:09:55,690 --> 00:10:00,250
can do whatever work it needs to in

00:09:57,520 --> 00:10:02,350
response to that message if it wants to

00:10:00,250 --> 00:10:03,670
send a message on within the flow it can

00:10:02,350 --> 00:10:06,910
pass the new message to the send

00:10:03,670 --> 00:10:08,950
function once it's finished its work for

00:10:06,910 --> 00:10:11,650
that message it calls the done function

00:10:08,950 --> 00:10:13,450
now this send done Parra functions were

00:10:11,650 --> 00:10:15,880
new additions in node Reds wander over

00:10:13,450 --> 00:10:18,220
lease late last year before that nodes

00:10:15,880 --> 00:10:20,440
would use the node object's own send

00:10:18,220 --> 00:10:22,390
function the reason for using the passed

00:10:20,440 --> 00:10:24,490
in function though is it has the runtime

00:10:22,390 --> 00:10:26,980
to correlate to the call to send with

00:10:24,490 --> 00:10:28,660
the message that was received allowing

00:10:26,980 --> 00:10:30,550
for better traceability of your flows

00:10:28,660 --> 00:10:34,690
that's something we need to make easier

00:10:30,550 --> 00:10:36,490
to do within the project generally now

00:10:34,690 --> 00:10:39,070
finally the node may also register a

00:10:36,490 --> 00:10:40,540
handler for the close event this gets

00:10:39,070 --> 00:10:42,220
called when if the node is being stopped

00:10:40,540 --> 00:10:43,750
by the runtime either because a new set

00:10:42,220 --> 00:10:45,760
of flows are being deployed or the

00:10:43,750 --> 00:10:47,470
runtime itself is being stopped this

00:10:45,760 --> 00:10:49,690
allows the node to clean up any internal

00:10:47,470 --> 00:10:52,089
state such as its database connections

00:10:49,690 --> 00:10:54,310
or whatever resources is created and

00:10:52,089 --> 00:10:56,470
that's largely it in terms of the

00:10:54,310 --> 00:10:57,880
framework for creating a node there are

00:10:56,470 --> 00:10:59,890
a bunch of other API s for logging

00:10:57,880 --> 00:11:01,570
errors updating node status and other

00:10:59,890 --> 00:11:03,210
features that we don't need to get into

00:11:01,570 --> 00:11:05,530
for this talk

00:11:03,210 --> 00:11:07,150
so once we've created this construct

00:11:05,530 --> 00:11:09,610
function the very final thing is to

00:11:07,150 --> 00:11:14,200
register it with the runtime using

00:11:09,610 --> 00:11:15,880
this call to register type switching to

00:11:14,200 --> 00:11:18,250
the HTML side of the node there are

00:11:15,880 --> 00:11:20,769
three things the HTML content for the

00:11:18,250 --> 00:11:22,450
nodes edit dialog help text and the jot

00:11:20,769 --> 00:11:24,100
script code used to register the node

00:11:22,450 --> 00:11:25,990
with the editor which defines various

00:11:24,100 --> 00:11:27,459
aspects of its appearance and lists out

00:11:25,990 --> 00:11:30,250
the properties of the node that can be

00:11:27,459 --> 00:11:31,630
configured by the user the definition

00:11:30,250 --> 00:11:33,130
also includes optional JavaScript

00:11:31,630 --> 00:11:34,720
functions that will be run when the Edit

00:11:33,130 --> 00:11:36,940
dialog for node is being opened or

00:11:34,720 --> 00:11:38,800
closed this allows the Edit dialog

00:11:36,940 --> 00:11:41,470
provide a much richer user experience

00:11:38,800 --> 00:11:43,690
than just a plain HTML form the edit of

00:11:41,470 --> 00:11:45,370
bundles jQuery but doesn't otherwise use

00:11:43,690 --> 00:11:47,680
any JavaScript toolkit for its UI

00:11:45,370 --> 00:11:49,600
generation we occasionally get asked

00:11:47,680 --> 00:11:51,490
about angular react or one of the other

00:11:49,600 --> 00:11:53,920
various JavaScript frameworks but we've

00:11:51,490 --> 00:11:59,079
generally tried not to tie ourselves to

00:11:53,920 --> 00:12:00,760
one framework or another the editor does

00:11:59,079 --> 00:12:03,070
provide a number of useful widgets that

00:12:00,760 --> 00:12:05,320
nose can use to go there you eyes such

00:12:03,070 --> 00:12:07,510
as the typed input which allows the user

00:12:05,320 --> 00:12:09,670
to specify the type of a property as

00:12:07,510 --> 00:12:11,769
well as its value this makes for a much

00:12:09,670 --> 00:12:13,300
more consistent user experience rather

00:12:11,769 --> 00:12:17,230
than having each node creates its own

00:12:13,300 --> 00:12:19,149
way to do it so given the time available

00:12:17,230 --> 00:12:21,550
today I'm not going to delve any deeper

00:12:19,149 --> 00:12:22,839
into how to create nodes instead I

00:12:21,550 --> 00:12:24,760
wanted to talk a bit more about the

00:12:22,839 --> 00:12:30,850
general design principles that apply

00:12:24,760 --> 00:12:32,800
when creating them when designing a node

00:12:30,850 --> 00:12:35,170
for no dread the first thing to consider

00:12:32,800 --> 00:12:37,180
is who the audience is who are the

00:12:35,170 --> 00:12:38,829
people that will install the module ad

00:12:37,180 --> 00:12:41,320
it's the palette and drag it into their

00:12:38,829 --> 00:12:43,510
workspace with low code platforms like

00:12:41,320 --> 00:12:45,730
node read you have to remember the users

00:12:43,510 --> 00:12:48,160
come from a much broader range of

00:12:45,730 --> 00:12:49,720
experience they may already be deeply

00:12:48,160 --> 00:12:52,690
familiar with whatever functionality

00:12:49,720 --> 00:12:54,820
your node provides or they may have no

00:12:52,690 --> 00:12:56,949
knowledge of the underlying details and

00:12:54,820 --> 00:12:59,890
just know they need that functionality

00:12:56,949 --> 00:13:01,600
in the node provides they may have a

00:12:59,890 --> 00:13:03,130
very detailed set of requirements for

00:13:01,600 --> 00:13:06,390
the node or they may just want it to

00:13:03,130 --> 00:13:08,800
work and not worry about those details

00:13:06,390 --> 00:13:13,720
so here are some of the principles to

00:13:08,800 --> 00:13:17,079
apply when designing a node the first is

00:13:13,720 --> 00:13:19,209
making it intuitive the nodes

00:13:17,079 --> 00:13:21,940
configuration is stored as a set of JSON

00:13:19,209 --> 00:13:23,160
key value pairs expressing that as a

00:13:21,940 --> 00:13:25,680
plain list of texts Bach

00:13:23,160 --> 00:13:28,379
labels assumes the user will know what's

00:13:25,680 --> 00:13:30,629
expected in each box for a simple note

00:13:28,379 --> 00:13:32,399
that expects perhaps just a URL username

00:13:30,629 --> 00:13:34,259
and password that may well be good

00:13:32,399 --> 00:13:36,209
enough but when there starts to be lots

00:13:34,259 --> 00:13:39,720
of other options a different approach

00:13:36,209 --> 00:13:41,850
might be needed one of the approaches we

00:13:39,720 --> 00:13:44,579
took with the core trigger note for

00:13:41,850 --> 00:13:47,040
example was to build the UI in such a

00:13:44,579 --> 00:13:49,490
way that the user could read how it was

00:13:47,040 --> 00:13:52,769
configured almost as an English sentence

00:13:49,490 --> 00:13:55,800
send hello then wait for five seconds

00:13:52,769 --> 00:13:57,360
then send goodbye it doesn't approach

00:13:55,800 --> 00:14:01,110
that would work in all cases but it

00:13:57,360 --> 00:14:02,639
certainly helped in this case every

00:14:01,110 --> 00:14:05,040
feature an option you add to the node

00:14:02,639 --> 00:14:07,379
increases the cognitive burden of using

00:14:05,040 --> 00:14:08,879
the node for feature rich nodes it can

00:14:07,379 --> 00:14:10,949
be quite hard to design their UI to

00:14:08,879 --> 00:14:12,660
write all of those features without also

00:14:10,949 --> 00:14:15,019
making it much harder to find a

00:14:12,660 --> 00:14:16,709
particular option a user needs to use

00:14:15,019 --> 00:14:18,930
providing your user with a clear

00:14:16,709 --> 00:14:21,300
hierarchy of choice can also help them

00:14:18,930 --> 00:14:23,189
reach their desired configuration by

00:14:21,300 --> 00:14:25,019
that I mean only presenting options that

00:14:23,189 --> 00:14:27,269
are relevant to the choices a user is

00:14:25,019 --> 00:14:29,040
made up to that point there's certainly

00:14:27,269 --> 00:14:31,620
a balance to be made here having options

00:14:29,040 --> 00:14:34,680
appear and disappear if overdone could

00:14:31,620 --> 00:14:38,399
also be confusing to the user the key is

00:14:34,680 --> 00:14:39,839
finding that right balance the next

00:14:38,399 --> 00:14:42,060
principle is about having sensible

00:14:39,839 --> 00:14:43,949
defaults and this very much follows on

00:14:42,060 --> 00:14:46,439
from the making the node intuitive to

00:14:43,949 --> 00:14:49,649
use it should come with a sensible set

00:14:46,439 --> 00:14:51,420
of default configuration values don't

00:14:49,649 --> 00:14:53,339
force the user to have to set everything

00:14:51,420 --> 00:14:56,519
they the first time they want to use the

00:14:53,339 --> 00:14:59,040
node a good example of this is the split

00:14:56,519 --> 00:15:01,110
node this node can be used to turn a

00:14:59,040 --> 00:15:03,720
single message into a stream of multiple

00:15:01,110 --> 00:15:05,639
messages by default if you give to

00:15:03,720 --> 00:15:08,370
string payload you'll send a message for

00:15:05,639 --> 00:15:10,319
each line of text in that string if you

00:15:08,370 --> 00:15:12,240
give it an array it sends a message for

00:15:10,319 --> 00:15:13,800
each element of the array and if you

00:15:12,240 --> 00:15:16,259
give it an object it will send a message

00:15:13,800 --> 00:15:18,180
for each key value pair you don't have

00:15:16,259 --> 00:15:20,309
to configure it to do any of that but if

00:15:18,180 --> 00:15:24,230
you do want to change its behavior you

00:15:20,309 --> 00:15:27,839
can very easily do so within the node

00:15:24,230 --> 00:15:30,329
his partner node the join node will by

00:15:27,839 --> 00:15:31,829
default attempt to join a stream of

00:15:30,329 --> 00:15:33,990
messages back together into a single

00:15:31,829 --> 00:15:36,270
message essentially reversing whatever

00:15:33,990 --> 00:15:38,070
the split node did but again

00:15:36,270 --> 00:15:39,810
can easily give the join node a manual

00:15:38,070 --> 00:15:44,730
configuration if you wanted to do

00:15:39,810 --> 00:15:46,500
something different the third Prince was

00:15:44,730 --> 00:15:49,680
about choosing what can be controlled

00:15:46,500 --> 00:15:51,960
dynamically nodes exposed to different

00:15:49,680 --> 00:15:53,760
API surfaces to the user the

00:15:51,960 --> 00:15:55,380
configuration properties set in the edit

00:15:53,760 --> 00:15:57,300
dialog and the properties of the

00:15:55,380 --> 00:15:59,850
individual messages passed of the node

00:15:57,300 --> 00:16:01,380
both the means to control the nodes

00:15:59,850 --> 00:16:03,150
behavior but that doesn't mean

00:16:01,380 --> 00:16:07,920
everything should be exposed in both

00:16:03,150 --> 00:16:10,320
ways the HTTP requests node allows you

00:16:07,920 --> 00:16:12,660
to set the URL of the request in the

00:16:10,320 --> 00:16:14,130
node itself that's useful if you're

00:16:12,660 --> 00:16:17,040
sending the request to a fixed end point

00:16:14,130 --> 00:16:19,500
whether URL never changes but the node

00:16:17,040 --> 00:16:22,320
also allows you to pass in message to RL

00:16:19,500 --> 00:16:24,810
to set the URL on a per message basis

00:16:22,320 --> 00:16:26,730
the node also lets you set custom HT

00:16:24,810 --> 00:16:28,710
headers for the request by setting

00:16:26,730 --> 00:16:30,360
message dot headers but that's an

00:16:28,710 --> 00:16:33,330
example of an option that's not exposed

00:16:30,360 --> 00:16:35,040
in the nodes edit dialog there's an

00:16:33,330 --> 00:16:37,110
important design principle here as well

00:16:35,040 --> 00:16:39,480
that a message property should not

00:16:37,110 --> 00:16:41,850
override a property the user has

00:16:39,480 --> 00:16:45,000
explicitly set in the nodes edit dialog

00:16:41,850 --> 00:16:46,830
for example in the request node case if

00:16:45,000 --> 00:16:49,350
the user has provided euro in the edit

00:16:46,830 --> 00:16:51,780
dialog then the node will ignore message

00:16:49,350 --> 00:16:53,580
dot URL this was a deliberate choice to

00:16:51,780 --> 00:16:55,920
avoid the cases where a nodes behavior

00:16:53,580 --> 00:16:57,720
changes unexpectedly because a user

00:16:55,920 --> 00:17:01,310
didn't realize a property happen to

00:16:57,720 --> 00:17:01,310
still be set on a message in the flow

00:17:01,610 --> 00:17:07,050
the fourth principle is about being

00:17:03,990 --> 00:17:08,970
forgiving notes should be forgiving in

00:17:07,050 --> 00:17:11,190
what they receive and be kind when

00:17:08,970 --> 00:17:14,070
things go wrong and a good example is

00:17:11,190 --> 00:17:15,780
the mqt node an empty message payload is

00:17:14,070 --> 00:17:17,880
just a collection of points but the node

00:17:15,780 --> 00:17:19,260
will accept any JavaScript type and try

00:17:17,880 --> 00:17:21,180
to do the right thing with it

00:17:19,260 --> 00:17:22,620
strings numbers boolean's all get

00:17:21,180 --> 00:17:24,900
handled as we think the user would

00:17:22,620 --> 00:17:27,150
expect them to be passing in an array or

00:17:24,900 --> 00:17:28,950
objects will lead it to be stringify to

00:17:27,150 --> 00:17:32,190
jason automatically before it gets

00:17:28,950 --> 00:17:33,780
published and I'm sure we've all tripped

00:17:32,190 --> 00:17:35,820
over the handling of false like values

00:17:33,780 --> 00:17:37,950
in JavaScript if a node accepts a true

00:17:35,820 --> 00:17:39,510
false flag as a message property take

00:17:37,950 --> 00:17:42,330
care to consider how it handles non

00:17:39,510 --> 00:17:45,150
boolean type values should undefined

00:17:42,330 --> 00:17:49,010
null 0 and empty string behave as you

00:17:45,150 --> 00:17:51,290
think it would v prince was handling

00:17:49,010 --> 00:17:53,030
with grace one of the most important

00:17:51,290 --> 00:17:54,650
things is ensuring nodes have the proper

00:17:53,030 --> 00:17:57,169
error handling to avoid the dreaded

00:17:54,650 --> 00:17:59,570
uncaught exception an uncaught exception

00:17:57,169 --> 00:18:00,980
will cause the runtime to shut down in

00:17:59,570 --> 00:18:03,530
the immortal words of the nodejs

00:18:00,980 --> 00:18:05,120
documentation is simply not safe to

00:18:03,530 --> 00:18:07,190
resume normal operation after an

00:18:05,120 --> 00:18:09,770
uncaught exception attempting to resume

00:18:07,190 --> 00:18:11,480
normal after an uncaught exception can

00:18:09,770 --> 00:18:13,669
be similar to pulling out the power cord

00:18:11,480 --> 00:18:15,530
and upgrading computer nine out of ten

00:18:13,669 --> 00:18:18,260
times nothing happens but the tenth time

00:18:15,530 --> 00:18:22,040
the system becomes corrupted restarting

00:18:18,260 --> 00:18:24,440
is the only option we have the sixth

00:18:22,040 --> 00:18:26,000
principle is about being consistent with

00:18:24,440 --> 00:18:27,410
such a large ecosystem of nodes

00:18:26,000 --> 00:18:29,299
available there are a whole bunch of

00:18:27,410 --> 00:18:31,610
well-established patterns for how nodes

00:18:29,299 --> 00:18:33,919
look and behave what is good to

00:18:31,610 --> 00:18:36,530
challenge those norms it's less good to

00:18:33,919 --> 00:18:38,510
reinvent the wheels for sake of it use

00:18:36,530 --> 00:18:40,850
the patterns that exist use the common

00:18:38,510 --> 00:18:42,679
UI widgets node-red provides follow the

00:18:40,850 --> 00:18:45,910
style guide for the help text it all

00:18:42,679 --> 00:18:48,620
makes for a better user experience

00:18:45,910 --> 00:18:51,169
ultimately the key is to have empathy

00:18:48,620 --> 00:18:53,510
for the user of the node the goal isn't

00:18:51,169 --> 00:18:54,980
to outwit them the goal is to empower

00:18:53,510 --> 00:18:56,900
them to achieve what they're trying to

00:18:54,980 --> 00:19:00,590
do with as good a user experience as we

00:18:56,900 --> 00:19:02,390
can manage and these rule lessons that

00:19:00,590 --> 00:19:05,419
apply just as well when designing a

00:19:02,390 --> 00:19:07,910
regular node.js module api's are all

00:19:05,419 --> 00:19:09,350
about user experience just because

00:19:07,910 --> 00:19:11,510
you're exposing your module VAR an

00:19:09,350 --> 00:19:14,059
exported code API rather than the visual

00:19:11,510 --> 00:19:15,590
wrappings of a low code environment you

00:19:14,059 --> 00:19:18,320
still want to ensure the user experience

00:19:15,590 --> 00:19:20,750
means it's a joy to use a well defined

00:19:18,320 --> 00:19:22,490
API that puts the user first above the

00:19:20,750 --> 00:19:25,250
internal implementation details will

00:19:22,490 --> 00:19:27,650
always provide a better end result get

00:19:25,250 --> 00:19:29,270
the externals right first as they are so

00:19:27,650 --> 00:19:33,799
much harder to change down the line

00:19:29,270 --> 00:19:35,570
compared to internals now if you

00:19:33,799 --> 00:19:37,220
maintain a node.js module that you think

00:19:35,570 --> 00:19:39,290
would be interesting to expose in a low

00:19:37,220 --> 00:19:41,540
code programming environment I hope I've

00:19:39,290 --> 00:19:43,250
given you a bit of a bit of a flavor of

00:19:41,540 --> 00:19:46,490
some inspiration to try it out with no

00:19:43,250 --> 00:19:49,130
dread if you're interested in learning

00:19:46,490 --> 00:19:52,780
more then please do get in touch via the

00:19:49,130 --> 00:19:55,370
project slack or discourse forum

00:19:52,780 --> 00:19:59,200
I've been Nick O'Leary from the node-red

00:19:55,370 --> 00:19:59,200
project thanks for listening

00:20:04,730 --> 00:20:06,790

YouTube URL: https://www.youtube.com/watch?v=y-vlPdW5IoM


