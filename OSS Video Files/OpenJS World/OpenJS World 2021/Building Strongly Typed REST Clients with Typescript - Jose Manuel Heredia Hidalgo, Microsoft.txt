Title: Building Strongly Typed REST Clients with Typescript - Jose Manuel Heredia Hidalgo, Microsoft
Publication date: 2021-05-28
Playlist: OpenJS World 2021
Description: 
	In this talk we'll use TypeScript to create a client library that works with a REST API. Come see how we create a type-safe client with tooling tailored to your service
Captions: 
	00:00:00,640 --> 00:00:04,080
hello thanks for tuning in my name is

00:00:03,360 --> 00:00:06,000
jose

00:00:04,080 --> 00:00:08,559
and i'm a software engineer in the azure

00:00:06,000 --> 00:00:10,480
sdk team at microsoft

00:00:08,559 --> 00:00:12,080
i'm sure some of you have worked with

00:00:10,480 --> 00:00:14,080
rest api before

00:00:12,080 --> 00:00:15,360
and notice how the editors provide

00:00:14,080 --> 00:00:16,960
little to no help

00:00:15,360 --> 00:00:18,960
when discovering which resources are

00:00:16,960 --> 00:00:21,920
available for you to work with

00:00:18,960 --> 00:00:23,199
or even when building up your request

00:00:21,920 --> 00:00:25,199
payload

00:00:23,199 --> 00:00:26,640
in this talk we're going to see how we

00:00:25,199 --> 00:00:28,720
can use typescript

00:00:26,640 --> 00:00:30,720
to build a client that will help our

00:00:28,720 --> 00:00:33,200
rest api users

00:00:30,720 --> 00:00:34,960
with suggesting which resources they can

00:00:33,200 --> 00:00:37,200
use

00:00:34,960 --> 00:00:39,360
which operations they can execute on

00:00:37,200 --> 00:00:41,680
those resources that they have selected

00:00:39,360 --> 00:00:43,280
and also we will help them build the

00:00:41,680 --> 00:00:45,600
request payload

00:00:43,280 --> 00:00:46,879
before jumping into the code let's take

00:00:45,600 --> 00:00:49,760
a look at the sample res

00:00:46,879 --> 00:00:49,760
api call

00:00:50,399 --> 00:00:55,039
this is a simple call to our imaginary

00:00:53,440 --> 00:00:56,840
book catalog service

00:00:55,039 --> 00:00:58,239
that we will be using throughout the

00:00:56,840 --> 00:01:00,640
talk

00:00:58,239 --> 00:01:02,719
the first part is a method which

00:01:00,640 --> 00:01:04,640
describes the operation to be executed

00:01:02,719 --> 00:01:07,280
on a resource

00:01:04,640 --> 00:01:09,520
following is a resource which is

00:01:07,280 --> 00:01:11,280
composed of a base url that remains

00:01:09,520 --> 00:01:14,720
constant for the service

00:01:11,280 --> 00:01:17,280
and a path which identifies the resource

00:01:14,720 --> 00:01:19,840
then we have the payload which is the

00:01:17,280 --> 00:01:22,479
data sent to the service

00:01:19,840 --> 00:01:25,680
in this case we're sending a request to

00:01:22,479 --> 00:01:28,159
add a book to our catalog

00:01:25,680 --> 00:01:29,759
on the right we have an image with the

00:01:28,159 --> 00:01:32,560
structure of the service we are going to

00:01:29,759 --> 00:01:35,200
be writing our client for

00:01:32,560 --> 00:01:35,920
it has two resources the first one

00:01:35,200 --> 00:01:39,439
supports

00:01:35,920 --> 00:01:40,479
get post and put methods our second

00:01:39,439 --> 00:01:43,040
resource

00:01:40,479 --> 00:01:43,759
takes a book id as a path parameter and

00:01:43,040 --> 00:01:47,439
supports

00:01:43,759 --> 00:01:48,720
get and delete methods you can find the

00:01:47,439 --> 00:01:53,840
code from this talk

00:01:48,720 --> 00:01:55,680
on this url and now let's get started

00:01:53,840 --> 00:01:56,960
going to start by creating a simple

00:01:55,680 --> 00:02:00,320
factory function

00:01:56,960 --> 00:02:00,320
that takes the base url

00:02:04,960 --> 00:02:09,840
we're going to call it the books client

00:02:13,280 --> 00:02:16,959
for now let's put it that it will return

00:02:15,680 --> 00:02:20,000
the void

00:02:16,959 --> 00:02:23,840
i need to take a base url

00:02:20,000 --> 00:02:23,840
which is going to be string

00:02:24,319 --> 00:02:30,319
all right so we have the books client

00:02:27,440 --> 00:02:31,840
and our users will create a books claim

00:02:30,319 --> 00:02:37,040
by calling this faction

00:02:31,840 --> 00:02:39,519
factory method because client apollo's

00:02:37,040 --> 00:02:50,560
books client and the books client will

00:02:39,519 --> 00:02:53,040
take a base url let's use localhost

00:02:50,560 --> 00:02:53,599
now we need our client to have a pad

00:02:53,040 --> 00:02:54,879
function

00:02:53,599 --> 00:02:57,519
that takes the pad that we're going to

00:02:54,879 --> 00:03:00,480
be using on the rest api

00:02:57,519 --> 00:03:04,000
for that we need to change the return

00:03:00,480 --> 00:03:06,560
type that we set this void

00:03:04,000 --> 00:03:07,519
to have the shape that we want so we

00:03:06,560 --> 00:03:10,720
want to have

00:03:07,519 --> 00:03:12,400
an object that has a property named path

00:03:10,720 --> 00:03:14,319
and this property is going to be a

00:03:12,400 --> 00:03:17,440
function

00:03:14,319 --> 00:03:20,080
let's let's put void as a return type

00:03:17,440 --> 00:03:20,959
for as a placeholder but this function

00:03:20,080 --> 00:03:24,000
needs to take

00:03:20,959 --> 00:03:27,840
a string so let's do

00:03:24,000 --> 00:03:33,040
pad of type string

00:03:27,840 --> 00:03:34,720
so now our client has a pad function

00:03:33,040 --> 00:03:37,840
and it takes string if we don't pass a

00:03:34,720 --> 00:03:37,840
string then we get an error

00:03:40,640 --> 00:03:45,680
now we need that our path function only

00:03:43,440 --> 00:03:47,120
accepts the paths that are available in

00:03:45,680 --> 00:03:50,480
the rest api

00:03:47,120 --> 00:03:53,280
right now it accepts any string

00:03:50,480 --> 00:03:53,920
so for that let's start with moving the

00:03:53,280 --> 00:03:58,080
pad

00:03:53,920 --> 00:03:58,080
function definition type to its own type

00:03:58,319 --> 00:04:04,480
let's do export type

00:04:01,840 --> 00:04:06,720
pad and we're going to have the same

00:04:04,480 --> 00:04:11,040
thing as we have here

00:04:06,720 --> 00:04:11,040
and this is the type pad

00:04:12,640 --> 00:04:17,280
so now we need to limit the path it

00:04:15,200 --> 00:04:19,359
cannot be the whole string

00:04:17,280 --> 00:04:21,199
so for that we can create an interface

00:04:19,359 --> 00:04:24,400
that defines the shape of our

00:04:21,199 --> 00:04:27,600
rest api where the keys are the

00:04:24,400 --> 00:04:28,320
paths that are that are accepted and

00:04:27,600 --> 00:04:30,800
then

00:04:28,320 --> 00:04:31,520
the values are more details about the

00:04:30,800 --> 00:04:35,600
service

00:04:31,520 --> 00:04:35,600
so let's start with the interface

00:04:36,000 --> 00:04:39,520
we're going to call it the book library

00:04:41,280 --> 00:04:44,639
and our keys are going to be our paths

00:04:43,120 --> 00:04:48,240
so we have one pad that is

00:04:44,639 --> 00:04:48,240
slash book

00:04:49,440 --> 00:04:57,840
and slash book slash

00:04:52,880 --> 00:04:57,840
book id

00:04:58,160 --> 00:05:03,440
we want the pad type to be one of the

00:05:00,560 --> 00:05:07,919
keys of the book library interface

00:05:03,440 --> 00:05:07,919
we can set the type of path to kioff

00:05:08,960 --> 00:05:13,440
book library so now we get an error

00:05:12,240 --> 00:05:15,199
because the empty string

00:05:13,440 --> 00:05:17,759
is not a key of the book library

00:05:15,199 --> 00:05:21,199
interface

00:05:17,759 --> 00:05:23,919
and if you start writing

00:05:21,199 --> 00:05:26,960
then you will get suggestions about the

00:05:23,919 --> 00:05:26,960
pads that you can choose

00:05:32,880 --> 00:05:36,320
now we need to be able to detect if the

00:05:35,840 --> 00:05:38,160
pad

00:05:36,320 --> 00:05:40,160
has a pad parameter then it should be

00:05:38,160 --> 00:05:43,039
filled in

00:05:40,160 --> 00:05:45,919
for that we can use typescript template

00:05:43,039 --> 00:05:45,919
literal types

00:05:46,080 --> 00:05:52,160
so let's start by creating a helper type

00:05:49,680 --> 00:05:56,240
that will help us

00:05:52,160 --> 00:06:00,240
detect if the string that we are passing

00:05:56,240 --> 00:06:02,400
has at least one pad parameter

00:06:00,240 --> 00:06:05,759
so let's create a type type and we're

00:06:02,400 --> 00:06:07,120
going to call it path parameter

00:06:05,759 --> 00:06:09,039
since we're going to be working on a

00:06:07,120 --> 00:06:12,720
string we're going to call it

00:06:09,039 --> 00:06:14,720
a t-pad and it's going to be just a

00:06:12,720 --> 00:06:17,759
string so we can say extends

00:06:14,720 --> 00:06:20,960
string okay so

00:06:17,759 --> 00:06:24,160
now for detecting uh if t

00:06:20,960 --> 00:06:25,280
pad has any parameters we can we can

00:06:24,160 --> 00:06:28,479
start by saying

00:06:25,280 --> 00:06:30,240
t path so this is the the check

00:06:28,479 --> 00:06:32,319
that we're going to be doing so t pad

00:06:30,240 --> 00:06:35,680
extends

00:06:32,319 --> 00:06:36,080
and now we need to uh do our template

00:06:35,680 --> 00:06:38,720
here

00:06:36,080 --> 00:06:40,080
and then if it matches our template

00:06:38,720 --> 00:06:40,720
we're going to say that it's going to be

00:06:40,080 --> 00:06:43,759
true

00:06:40,720 --> 00:06:47,759
otherwise it's going to be false

00:06:43,759 --> 00:06:51,440
okay now let's define our template

00:06:47,759 --> 00:06:53,520
so we can say that our parameters are

00:06:51,440 --> 00:06:56,560
surrounded by

00:06:53,520 --> 00:06:58,960
curly braces and then we have a

00:06:56,560 --> 00:07:01,280
head that is anything that precedes the

00:06:58,960 --> 00:07:04,319
template

00:07:01,280 --> 00:07:07,599
i mean the the parameter and then a tail

00:07:04,319 --> 00:07:10,960
that is everything that succeeds

00:07:07,599 --> 00:07:14,080
the the parameter so in this case

00:07:10,960 --> 00:07:16,240
the head is going to be book

00:07:14,080 --> 00:07:17,120
the parameter is going to be book id and

00:07:16,240 --> 00:07:20,319
then the tail

00:07:17,120 --> 00:07:21,599
is going to be an empty string if we had

00:07:20,319 --> 00:07:24,720
something different like

00:07:21,599 --> 00:07:26,800
a bar here for example then

00:07:24,720 --> 00:07:29,039
the head would be book then the

00:07:26,800 --> 00:07:32,160
parameter again would be book id

00:07:29,039 --> 00:07:33,599
and the tail would be slash bar so with

00:07:32,160 --> 00:07:34,639
this we can start building our

00:07:33,599 --> 00:07:37,280
parameters so

00:07:34,639 --> 00:07:38,240
we will we can say that first we'll have

00:07:37,280 --> 00:07:41,599
the head

00:07:38,240 --> 00:07:44,160
we can use the infer keyword

00:07:41,599 --> 00:07:45,840
for typescript that will look at the at

00:07:44,160 --> 00:07:46,479
the string that we pass and then it will

00:07:45,840 --> 00:07:50,479
infer

00:07:46,479 --> 00:07:52,479
the part the head so we say head

00:07:50,479 --> 00:07:53,840
and then after the head we're gonna have

00:07:52,479 --> 00:07:55,919
a slash

00:07:53,840 --> 00:07:58,000
and we're gonna have curly braces and

00:07:55,919 --> 00:07:58,479
whatever is inside curly braces is going

00:07:58,000 --> 00:08:01,360
to be

00:07:58,479 --> 00:08:04,080
our parameter so we can again say infer

00:08:01,360 --> 00:08:08,000
the parameter

00:08:04,080 --> 00:08:12,000
parameter and just after the parameter

00:08:08,000 --> 00:08:15,919
we're going to have the tail so again

00:08:12,000 --> 00:08:18,319
let javas typescript infer

00:08:15,919 --> 00:08:18,319
the tail

00:08:19,120 --> 00:08:26,560
okay so now we have our template

00:08:22,800 --> 00:08:29,840
so this will match perfectly so book

00:08:26,560 --> 00:08:34,399
bokeh the bar and and bar

00:08:29,840 --> 00:08:34,399
so let's create a test type for this

00:08:36,880 --> 00:08:47,279
to cost full of type add parameter

00:08:42,880 --> 00:08:50,959
and then this guy will take

00:08:47,279 --> 00:08:50,959
book so let's say if book

00:08:51,760 --> 00:08:55,839
let's see if book matches so it's false

00:08:54,560 --> 00:08:58,880
it doesn't match because

00:08:55,839 --> 00:08:59,680
book doesn't have a pad parameter but

00:08:58,880 --> 00:09:04,160
what if we

00:08:59,680 --> 00:09:04,160
add bokeh d

00:09:05,040 --> 00:09:11,440
all right is it true cool and then if we

00:09:08,399 --> 00:09:15,279
have something in the tail

00:09:11,440 --> 00:09:17,279
true again okay so this is looking good

00:09:15,279 --> 00:09:19,839
so we're able now to detect if there's

00:09:17,279 --> 00:09:23,040
at least one parameter

00:09:19,839 --> 00:09:24,399
now we need to use this to make it to

00:09:23,040 --> 00:09:27,760
have required parameters

00:09:24,399 --> 00:09:28,480
on our path function right so how do we

00:09:27,760 --> 00:09:31,600
do that

00:09:28,480 --> 00:09:33,920
so we can use tuple types

00:09:31,600 --> 00:09:35,680
to do that so for example instead of

00:09:33,920 --> 00:09:36,720
returning a true we can say we're going

00:09:35,680 --> 00:09:40,880
to return

00:09:36,720 --> 00:09:42,480
a tuple with a string parameter

00:09:40,880 --> 00:09:44,560
we're going to have a string parameter

00:09:42,480 --> 00:09:45,760
because we we know that we found the

00:09:44,560 --> 00:09:48,720
parameter

00:09:45,760 --> 00:09:49,040
so the list of required parameters for

00:09:48,720 --> 00:09:51,360
for

00:09:49,040 --> 00:09:52,720
for the path function is going to be at

00:09:51,360 --> 00:09:55,440
least this uh

00:09:52,720 --> 00:09:56,320
single string otherwise if we didn't

00:09:55,440 --> 00:09:59,360
find any

00:09:56,320 --> 00:10:01,279
any parameters then we'll say there are

00:09:59,360 --> 00:10:04,880
no parameters so we can return

00:10:01,279 --> 00:10:07,680
an empty tuple let's try to use

00:10:04,880 --> 00:10:09,200
these integrate these into the into the

00:10:07,680 --> 00:10:11,920
path function

00:10:09,200 --> 00:10:13,360
so right now we have the pad is type of

00:10:11,920 --> 00:10:15,760
um

00:10:13,360 --> 00:10:16,720
the keys of the book library and now we

00:10:15,760 --> 00:10:19,920
say that you

00:10:16,720 --> 00:10:22,880
can have a pad parameter

00:10:19,920 --> 00:10:25,600
and this will be of type pad parameter

00:10:22,880 --> 00:10:28,800
okay but that parameter needs to be

00:10:25,600 --> 00:10:31,440
working on a string and we would like

00:10:28,800 --> 00:10:32,480
pad parameter to be working on the path

00:10:31,440 --> 00:10:35,200
that we're passing

00:10:32,480 --> 00:10:36,560
the exact path that was used as the

00:10:35,200 --> 00:10:38,399
first parameter

00:10:36,560 --> 00:10:39,760
so for that i think we can we can just

00:10:38,399 --> 00:10:43,440
lift this up

00:10:39,760 --> 00:10:46,320
and put it as a generic of the pad

00:10:43,440 --> 00:10:47,200
or maybe just as generic of the function

00:10:46,320 --> 00:10:50,320
so you can say

00:10:47,200 --> 00:10:55,440
that we're going to be taking a t-pad

00:10:50,320 --> 00:10:55,440
and the t-pad is extending extends

00:10:55,680 --> 00:11:01,120
so it has to be one of the keys of book

00:10:58,839 --> 00:11:04,240
library

00:11:01,120 --> 00:11:07,279
and now let me format it okay

00:11:04,240 --> 00:11:10,079
so okay so we have this

00:11:07,279 --> 00:11:10,640
generic definition here so t-pad is

00:11:10,079 --> 00:11:13,920
going to be

00:11:10,640 --> 00:11:14,560
any of the keys of book library so now

00:11:13,920 --> 00:11:19,760
we can

00:11:14,560 --> 00:11:22,079
change that type to just be a d-pad

00:11:19,760 --> 00:11:24,320
which is basically the same that we had

00:11:22,079 --> 00:11:27,760
and now the pad parameters

00:11:24,320 --> 00:11:28,000
are going to be the helper tab that we

00:11:27,760 --> 00:11:30,560
just

00:11:28,000 --> 00:11:33,120
created and it's going to be working on

00:11:30,560 --> 00:11:33,120
t-pad

00:11:40,839 --> 00:11:46,160
cool

00:11:43,760 --> 00:11:47,040
nice so let's see what pad looks like

00:11:46,160 --> 00:11:50,880
okay

00:11:47,040 --> 00:11:53,120
so since book doesn't match

00:11:50,880 --> 00:11:56,240
the template that we defined then it's

00:11:53,120 --> 00:11:57,360
saying that it needs a pad parameter of

00:11:56,240 --> 00:12:00,320
an empty tuple

00:11:57,360 --> 00:12:00,320
which is uh

00:12:00,880 --> 00:12:04,480
this this means it doesn't have any

00:12:02,720 --> 00:12:05,200
parameters but we're still requiring the

00:12:04,480 --> 00:12:08,160
parameters

00:12:05,200 --> 00:12:09,120
so what we can do is we can just do the

00:12:08,160 --> 00:12:12,160
spread

00:12:09,120 --> 00:12:14,000
on on the pad parameters because we know

00:12:12,160 --> 00:12:17,040
that this type is going to be

00:12:14,000 --> 00:12:19,040
in the form of a tuple but we want

00:12:17,040 --> 00:12:20,959
we want the the pad parameters to be

00:12:19,040 --> 00:12:24,160
just positional parameters after

00:12:20,959 --> 00:12:26,079
the after the path so we can say that

00:12:24,160 --> 00:12:27,600
the path parameter and we're going to

00:12:26,079 --> 00:12:30,639
spread it

00:12:27,600 --> 00:12:34,959
it's going to be a rest parameter so

00:12:30,639 --> 00:12:38,240
now you see the the type of the path

00:12:34,959 --> 00:12:39,680
function when it has book then we don't

00:12:38,240 --> 00:12:43,600
have any parameters

00:12:39,680 --> 00:12:46,079
but if we were doing the

00:12:43,600 --> 00:12:47,519
one that has a parameter then it's

00:12:46,079 --> 00:12:49,279
complaining now because we're not

00:12:47,519 --> 00:12:51,680
passing a path parameter

00:12:49,279 --> 00:12:52,399
you see here we get a not a very nice

00:12:51,680 --> 00:12:54,320
name

00:12:52,399 --> 00:12:55,680
we can just name it pad parameter

00:12:54,320 --> 00:12:59,360
because tuples

00:12:55,680 --> 00:13:07,519
allowed you in allow you to have a label

00:12:59,360 --> 00:13:11,120
so you could do pad parameter

00:13:07,519 --> 00:13:13,360
yep so now it will be pat parameter

00:13:11,120 --> 00:13:14,320
fortunately type step group doesn't

00:13:13,360 --> 00:13:18,000
support yet

00:13:14,320 --> 00:13:19,600
dynamic labels so i will need to just

00:13:18,000 --> 00:13:24,720
skip

00:13:19,600 --> 00:13:28,399
predefined label for for for the tuple

00:13:24,720 --> 00:13:31,440
so okay so now it's complaining about

00:13:28,399 --> 00:13:33,360
not having the the path parameter so we

00:13:31,440 --> 00:13:36,800
can pass any path

00:13:33,360 --> 00:13:39,680
will be happy now our pet parameter

00:13:36,800 --> 00:13:41,279
helper type still has a problem and the

00:13:39,680 --> 00:13:45,040
problem is that it's only able

00:13:41,279 --> 00:13:48,560
to identify one

00:13:45,040 --> 00:13:52,480
path parameter for example if you

00:13:48,560 --> 00:13:52,480
if you had another

00:13:52,560 --> 00:13:58,320
pad parameter here let's say bar id

00:13:56,079 --> 00:14:01,360
then pad parameter will still just

00:13:58,320 --> 00:14:05,199
detect the single path parameter

00:14:01,360 --> 00:14:08,399
so in order to fix this we can

00:14:05,199 --> 00:14:08,720
we can actually recursively call our

00:14:08,399 --> 00:14:12,560
path

00:14:08,720 --> 00:14:13,839
parameter helper type to identify the

00:14:12,560 --> 00:14:15,920
rest of the strings so

00:14:13,839 --> 00:14:16,880
so far whenever we have already

00:14:15,920 --> 00:14:20,240
identified a

00:14:16,880 --> 00:14:21,839
pad parameter we have looked into this

00:14:20,240 --> 00:14:22,880
part of the template the head and the

00:14:21,839 --> 00:14:25,519
parameter

00:14:22,880 --> 00:14:26,720
but then we still need to look at the

00:14:25,519 --> 00:14:30,160
tail

00:14:26,720 --> 00:14:33,360
so what we can do is we can say

00:14:30,160 --> 00:14:34,079
that if you find a parameter then the

00:14:33,360 --> 00:14:36,720
parameter

00:14:34,079 --> 00:14:36,720
is going to be

00:14:37,600 --> 00:14:42,720
looking at the tail so we will do pad

00:14:42,839 --> 00:14:48,480
parameter

00:14:44,639 --> 00:14:59,839
that parameter on

00:14:48,480 --> 00:14:59,839
the tail

00:15:01,199 --> 00:15:09,360
and since since this again returns

00:15:05,040 --> 00:15:12,480
a tuple then we can just spread parents

00:15:09,360 --> 00:15:15,600
and now

00:15:12,480 --> 00:15:17,040
our helper type is finding both of the

00:15:15,600 --> 00:15:20,720
parameters

00:15:17,040 --> 00:15:23,360
and if you could keep adding parameters

00:15:20,720 --> 00:15:23,920
it will keep detecting them once we set

00:15:23,360 --> 00:15:26,880
the path

00:15:23,920 --> 00:15:29,839
we need to expose methods for the pairs

00:15:26,880 --> 00:15:33,120
that are supported by the rest api

00:15:29,839 --> 00:15:36,399
so for example book should support get

00:15:33,120 --> 00:15:40,399
post input while book on book id

00:15:36,399 --> 00:15:43,199
should support get and delete

00:15:40,399 --> 00:15:45,199
so let's add some placeholder function

00:15:43,199 --> 00:15:48,560
definitions on our interface

00:15:45,199 --> 00:15:48,560
for each of the paths

00:15:49,040 --> 00:15:52,639
now that we have the placeholders for

00:15:51,120 --> 00:15:54,720
each of the functions

00:15:52,639 --> 00:15:55,680
we can start using this interface in

00:15:54,720 --> 00:16:00,160
order to set the

00:15:55,680 --> 00:16:00,160
right return type for the pad function

00:16:00,480 --> 00:16:05,839
so for doing that we can replace the

00:16:03,199 --> 00:16:07,680
void placeholder that we had

00:16:05,839 --> 00:16:09,680
when we're working with interfaces we

00:16:07,680 --> 00:16:10,880
can access the content of each of the

00:16:09,680 --> 00:16:15,040
keys

00:16:10,880 --> 00:16:15,040
so for example we could do book library

00:16:15,600 --> 00:16:18,959
on one of the two keys that it has

00:16:17,920 --> 00:16:21,360
defined

00:16:18,959 --> 00:16:24,240
when you set the key this will be

00:16:21,360 --> 00:16:27,279
whatever is defined inside

00:16:24,240 --> 00:16:28,800
however we don't want to have it hard

00:16:27,279 --> 00:16:31,680
coded this way

00:16:28,800 --> 00:16:33,120
we would like to be using whatever path

00:16:31,680 --> 00:16:35,440
has been passed to the

00:16:33,120 --> 00:16:38,079
to the function and since we're using a

00:16:35,440 --> 00:16:41,360
generic d-pad then we can work with that

00:16:38,079 --> 00:16:42,639
so instead of passing in a string we can

00:16:41,360 --> 00:16:45,600
just use the t-pad

00:16:42,639 --> 00:16:45,600
that is being used

00:16:46,320 --> 00:16:52,000
to use t-pad here with this

00:16:49,600 --> 00:16:54,399
working on this pad we should get delete

00:16:52,000 --> 00:16:58,320
and post

00:16:54,399 --> 00:17:02,639
delete and post and if we set

00:16:58,320 --> 00:17:04,079
the slash book pad which doesn't require

00:17:02,639 --> 00:17:07,360
any parameters

00:17:04,079 --> 00:17:09,839
we should get a post to put in the get

00:17:07,360 --> 00:17:13,280
methods

00:17:09,839 --> 00:17:13,919
post get input methods now we need to

00:17:13,280 --> 00:17:15,760
set

00:17:13,919 --> 00:17:17,439
real return types we have set

00:17:15,760 --> 00:17:19,760
placeholder voids here

00:17:17,439 --> 00:17:20,480
but we need to use real types for for

00:17:19,760 --> 00:17:23,280
the

00:17:20,480 --> 00:17:24,880
operations that we're executing so for

00:17:23,280 --> 00:17:29,039
that i have already created

00:17:24,880 --> 00:17:30,559
a few definitions for response types

00:17:29,039 --> 00:17:32,320
so let's start looking at the general

00:17:30,559 --> 00:17:34,640
response type that has

00:17:32,320 --> 00:17:35,919
a status code which is a required

00:17:34,640 --> 00:17:38,400
property because

00:17:35,919 --> 00:17:40,240
any response will have status code which

00:17:38,400 --> 00:17:44,160
is string

00:17:40,240 --> 00:17:46,960
then we have an optional body

00:17:44,160 --> 00:17:48,240
property this is unknown on the general

00:17:46,960 --> 00:17:51,360
response because

00:17:48,240 --> 00:17:53,360
this is very specific for the for each

00:17:51,360 --> 00:17:55,840
request that we're going to be sending

00:17:53,360 --> 00:17:58,000
and then we have the headers which is

00:17:55,840 --> 00:18:01,919
basically a key value pair of strings

00:17:58,000 --> 00:18:05,120
and an unknown type

00:18:01,919 --> 00:18:07,840
for the value then

00:18:05,120 --> 00:18:08,799
we have an error response this is any

00:18:07,840 --> 00:18:10,960
response that is

00:18:08,799 --> 00:18:13,120
returned by the service will have a

00:18:10,960 --> 00:18:14,320
status code we know beforehand that our

00:18:13,120 --> 00:18:17,919
service may return

00:18:14,320 --> 00:18:20,960
400 for invalid input 404

00:18:17,919 --> 00:18:24,080
when the resource is not found or 500 or

00:18:20,960 --> 00:18:24,640
there was an internal service error when

00:18:24,080 --> 00:18:27,039
the

00:18:24,640 --> 00:18:29,039
service returns an error you will have

00:18:27,039 --> 00:18:29,919
in the body we will have an error code

00:18:29,039 --> 00:18:33,039
and a message

00:18:29,919 --> 00:18:35,280
about the error and then

00:18:33,039 --> 00:18:37,280
we have some types for each of the

00:18:35,280 --> 00:18:41,360
specific

00:18:37,280 --> 00:18:43,919
requests that we have so for example

00:18:41,360 --> 00:18:45,120
when we send a post request to the to

00:18:43,919 --> 00:18:49,120
the slash book

00:18:45,120 --> 00:18:52,400
pad then i will get a 200

00:18:49,120 --> 00:18:56,160
if it's successful and the two sorry

00:18:52,400 --> 00:18:57,760
200 201 and the 201 doesn't have a body

00:18:56,160 --> 00:18:59,600
so we're going to say that the body in

00:18:57,760 --> 00:19:02,160
this case is optional

00:18:59,600 --> 00:19:03,919
but um it's going to be a never type so

00:19:02,160 --> 00:19:05,120
what you should never expect to have a

00:19:03,919 --> 00:19:08,960
body

00:19:05,120 --> 00:19:10,799
then we have the list books 200 response

00:19:08,960 --> 00:19:13,200
which is the success response when you

00:19:10,799 --> 00:19:16,559
call get on the slash books

00:19:13,200 --> 00:19:19,360
pad so the status is 200

00:19:16,559 --> 00:19:21,200
and you will get a body and the body is

00:19:19,360 --> 00:19:23,520
going to be an array of books

00:19:21,200 --> 00:19:26,559
now that we have our types defined then

00:19:23,520 --> 00:19:29,760
we can start using them

00:19:26,559 --> 00:19:32,160
in our book library definition so

00:19:29,760 --> 00:19:33,440
let's start filling it out since we're

00:19:32,160 --> 00:19:35,760
calling a service

00:19:33,440 --> 00:19:38,240
we're going to be getting promises so

00:19:35,760 --> 00:19:41,360
let's start with promise

00:19:38,240 --> 00:19:45,200
and then slash book get

00:19:41,360 --> 00:19:49,840
will get a list books 200 response

00:19:45,200 --> 00:19:53,440
or it will get an error response in case

00:19:49,840 --> 00:19:56,240
there was an error the post will also

00:19:53,440 --> 00:19:56,240
have a promise

00:19:56,640 --> 00:20:05,120
of add book to a one response

00:20:00,160 --> 00:20:05,120
or an error response put

00:20:05,440 --> 00:20:10,559
promise of update

00:20:11,000 --> 00:20:16,480
201 response or

00:20:13,360 --> 00:20:16,480
the error response

00:20:17,120 --> 00:20:24,000
then this get on with book id

00:20:20,400 --> 00:20:24,000
will give you a promise

00:20:29,919 --> 00:20:38,080
of get

00:20:33,039 --> 00:20:39,840
book 200 response or an error response

00:20:38,080 --> 00:20:43,679
and then the delete will give you

00:20:39,840 --> 00:20:43,679
promise with delete

00:20:44,240 --> 00:20:49,840
201 response or an error response

00:20:53,280 --> 00:21:00,000
now we can see that our delete function

00:20:57,440 --> 00:21:02,640
returns a delete book to a one response

00:21:00,000 --> 00:21:04,960
or an error response let's assign this

00:21:02,640 --> 00:21:08,240
to a variable so that we can explore

00:21:04,960 --> 00:21:08,240
the shapes of the results

00:21:13,280 --> 00:21:18,960
so let's see what result has result okay

00:21:16,640 --> 00:21:20,000
so it has a catch and then because uh

00:21:18,960 --> 00:21:22,320
because

00:21:20,000 --> 00:21:24,960
the operations return a promise so we

00:21:22,320 --> 00:21:24,960
can await

00:21:25,280 --> 00:21:28,799
once we wait we should be able to see

00:21:27,919 --> 00:21:32,080
what's in there

00:21:28,799 --> 00:21:35,440
so it has a the general structure body

00:21:32,080 --> 00:21:35,840
headers and status here we see status we

00:21:35,440 --> 00:21:39,200
see

00:21:35,840 --> 00:21:40,080
that it can have 201 or any of the

00:21:39,200 --> 00:21:43,760
errors

00:21:40,080 --> 00:21:44,400
error status codes if we explore the

00:21:43,760 --> 00:21:48,159
body

00:21:44,400 --> 00:21:50,880
then it will tell us that it can be

00:21:48,159 --> 00:21:52,480
either an error body or an undefined

00:21:50,880 --> 00:21:53,600
that's because at this point we didn't

00:21:52,480 --> 00:21:57,520
know

00:21:53,600 --> 00:22:00,480
what kind of response we got we can be

00:21:57,520 --> 00:22:01,280
getting a 201 or we can be getting any

00:22:00,480 --> 00:22:05,039
other

00:22:01,280 --> 00:22:05,919
error response so if we go back to

00:22:05,039 --> 00:22:07,919
responses

00:22:05,919 --> 00:22:10,000
you will see that we're defining our

00:22:07,919 --> 00:22:12,880
status codes for each of the

00:22:10,000 --> 00:22:13,760
specific responses as string literal

00:22:12,880 --> 00:22:16,480
unions

00:22:13,760 --> 00:22:17,120
and this will help our editor tools to

00:22:16,480 --> 00:22:20,720
be able

00:22:17,120 --> 00:22:24,159
to to narrow down the types

00:22:20,720 --> 00:22:27,280
so for example here if we were to say

00:22:24,159 --> 00:22:30,559
that we wanted to throw an error on on a

00:22:27,280 --> 00:22:34,559
non-successful result we can say

00:22:30,559 --> 00:22:36,960
if result dot status

00:22:34,559 --> 00:22:38,640
is not equals to 201 which is our

00:22:36,960 --> 00:22:41,919
success

00:22:38,640 --> 00:22:43,280
then we will throw and we'll draw the

00:22:41,919 --> 00:22:46,559
result

00:22:43,280 --> 00:22:51,600
body which has the error

00:22:46,559 --> 00:22:54,240
properties through control flow analysis

00:22:51,600 --> 00:22:55,200
typescript is able to infer that inside

00:22:54,240 --> 00:22:58,480
this

00:22:55,200 --> 00:23:01,520
block the result is a

00:22:58,480 --> 00:23:03,120
narrow response and also

00:23:01,520 --> 00:23:05,440
since the rest of the code is not going

00:23:03,120 --> 00:23:06,960
to be executed it's able to infer that

00:23:05,440 --> 00:23:08,880
the result is going to be the success

00:23:06,960 --> 00:23:12,320
result so let's use the

00:23:08,880 --> 00:23:15,280
get method the get method

00:23:12,320 --> 00:23:15,679
success is at 200 so let's update this

00:23:15,280 --> 00:23:18,400
so

00:23:15,679 --> 00:23:20,000
outside of here we should be able to see

00:23:18,400 --> 00:23:23,679
that the body is a book

00:23:20,000 --> 00:23:26,480
so calling result that body

00:23:23,679 --> 00:23:27,840
body has a shape of a book and it has

00:23:26,480 --> 00:23:29,840
all the properties

00:23:27,840 --> 00:23:33,120
from the book author scholar id

00:23:29,840 --> 00:23:33,120
publisher and title

00:23:33,919 --> 00:23:38,080
the last step is to add the input

00:23:36,559 --> 00:23:41,200
parameters to our

00:23:38,080 --> 00:23:42,880
functions for that i have already

00:23:41,200 --> 00:23:46,159
defined a few types for the

00:23:42,880 --> 00:23:49,039
input parameters and also for the book

00:23:46,159 --> 00:23:50,000
our book has an id a title a list of

00:23:49,039 --> 00:23:52,400
authors

00:23:50,000 --> 00:23:53,039
an optional published year and a set of

00:23:52,400 --> 00:23:56,559
colors

00:23:53,039 --> 00:23:59,520
that you can choose from now let's look

00:23:56,559 --> 00:24:02,720
at our request options

00:23:59,520 --> 00:24:05,360
we have a general type that has a body

00:24:02,720 --> 00:24:07,200
headers and query parameters all of them

00:24:05,360 --> 00:24:09,279
are optional in the base

00:24:07,200 --> 00:24:11,279
however we're defining the specific

00:24:09,279 --> 00:24:14,720
shapes for each of the requests

00:24:11,279 --> 00:24:16,960
for example our get requests have

00:24:14,720 --> 00:24:19,520
an optional never body because they will

00:24:16,960 --> 00:24:23,279
never contain a body

00:24:19,520 --> 00:24:26,400
however our post input operations

00:24:23,279 --> 00:24:29,039
have a required body of shape book

00:24:26,400 --> 00:24:29,600
and also the update operation has an

00:24:29,039 --> 00:24:32,720
optional

00:24:29,600 --> 00:24:36,000
e tag that is passed into the headers

00:24:32,720 --> 00:24:38,400
the same thing for the delete so now

00:24:36,000 --> 00:24:42,400
let's fill them in

00:24:38,400 --> 00:24:42,400
the get has an optional input

00:24:43,760 --> 00:24:53,679
of type list

00:24:47,520 --> 00:24:53,679
book options post has a required one

00:24:54,400 --> 00:25:00,880
of type create

00:24:57,440 --> 00:25:04,480
book options put

00:25:00,880 --> 00:25:04,480
also has a required input

00:25:05,360 --> 00:25:08,960
update book options

00:25:10,320 --> 00:25:18,159
here this will have also an optional one

00:25:14,640 --> 00:25:19,679
input optional of tab and get book

00:25:18,159 --> 00:25:21,760
options

00:25:19,679 --> 00:25:29,840
and finally the delete also has an

00:25:21,760 --> 00:25:29,840
optional input

00:25:31,200 --> 00:25:36,000
with this we'll be able to help our

00:25:33,279 --> 00:25:40,159
users to build their request payload

00:25:36,000 --> 00:25:43,840
let's set the base book pad

00:25:40,159 --> 00:25:43,840
and select the post method

00:25:45,520 --> 00:25:50,559
we will be able to start building our

00:25:47,600 --> 00:25:52,799
request if we create an empty object

00:25:50,559 --> 00:25:54,400
and hit ctrl space we get the

00:25:52,799 --> 00:25:55,360
suggestions for the properties that we

00:25:54,400 --> 00:25:57,840
can pass

00:25:55,360 --> 00:25:59,360
we see that the body is the required one

00:25:57,840 --> 00:26:01,679
we select the body

00:25:59,360 --> 00:26:02,960
and we start with another empty object

00:26:01,679 --> 00:26:05,039
we see that the

00:26:02,960 --> 00:26:06,960
that we get the required properties from

00:26:05,039 --> 00:26:10,080
the book authors caller

00:26:06,960 --> 00:26:13,279
id title and we can start building up

00:26:10,080 --> 00:26:13,279
our request payload

00:26:15,600 --> 00:26:19,520
thanks for joining me today i hope this

00:26:18,320 --> 00:26:21,600
was helpful

00:26:19,520 --> 00:26:22,880
here's a link to the code and my handle

00:26:21,600 --> 00:26:28,960
on github

00:26:22,880 --> 00:26:28,960

YouTube URL: https://www.youtube.com/watch?v=xdylpZ3jOGs


