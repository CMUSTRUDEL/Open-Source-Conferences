Title: A Robust, Modular UI Automation Framework with WebdriverIO - Olga Smolyar, InterSystems
Publication date: 2021-05-29
Playlist: OpenJS World 2021
Description: 
	A Robust, Modular UI Automation Framework with WebdriverIO - Olga Smolyar, InterSystems

Including automated UI testing as part of a DevOps pipeline has become an industry-standard practice. A variety of tools are available, both open-source and commercial, that provide APIs for simulating user interaction with a web interface. WebdriverIO has emerged as the leading javascript-based platform for functional and UI testing, providing an array of protocols, services, and BDD/TDD frameworks.  
Historically, UI automation has been a brittle undertaking, requiring considerable effort to safeguard test suites against flakiness and unreliable results. WebdriverIO addresses some of the inherent instability intrinsically.
Harnessing the full power of any UI automation tool requires the use of strategies to build a robust framework on top of the interaction layer provided by its APIs. We discuss here some of these strategies in the context of a modular, flexible and robust functional testing framework built with WebdriverIO and Cucumber.

Join the speaker for live Q&A on Slack, channel - #openjs_world-automation_ci_cd
Thursday, June 3 from 12:40 - 13:00 PDT / 21:40 - 22:00 CEST
Thursday, June 3 from 13:00 - 13:20 PDT /  22:00 - 22:20 CEST
Captions: 
	00:00:00,000 --> 00:00:03,360
hello and welcome to openjs foundation's

00:00:02,879 --> 00:00:06,720
world

00:00:03,360 --> 00:00:08,720
2021 talk on ui

00:00:06,720 --> 00:00:12,240
automation with webdriver io and

00:00:08,720 --> 00:00:14,920
cucumber a robust modular btt framework

00:00:12,240 --> 00:00:16,400
i'm olga smolyar representing entry

00:00:14,920 --> 00:00:18,080
systems ui

00:00:16,400 --> 00:00:20,400
automation has historically been

00:00:18,080 --> 00:00:22,400
regarded as a brittle undertaking

00:00:20,400 --> 00:00:23,920
requiring considerable effort to

00:00:22,400 --> 00:00:27,199
safeguard against

00:00:23,920 --> 00:00:29,039
unreliable results and flakiness

00:00:27,199 --> 00:00:31,359
at the same time there's been a desire

00:00:29,039 --> 00:00:32,000
to shift various automation suites

00:00:31,359 --> 00:00:35,600
leftward

00:00:32,000 --> 00:00:37,760
in a devops or qa pipeline

00:00:35,600 --> 00:00:39,440
this in turn increases pressure on the

00:00:37,760 --> 00:00:42,719
automation suites to be

00:00:39,440 --> 00:00:45,200
more reliable and more robust

00:00:42,719 --> 00:00:47,520
webdriver io has emerged as the leading

00:00:45,200 --> 00:00:50,079
javascript-based platform for functional

00:00:47,520 --> 00:00:52,320
and ui testing

00:00:50,079 --> 00:00:54,160
webdriver io is highly extensible and

00:00:52,320 --> 00:00:55,600
supports an array of protocols and

00:00:54,160 --> 00:00:57,600
services

00:00:55,600 --> 00:00:59,680
it also addresses some of the

00:00:57,600 --> 00:01:03,440
instability inherent to ui

00:00:59,680 --> 00:01:06,320
automation intrinsically via built-in

00:01:03,440 --> 00:01:08,240
strategies such as its automatic weight

00:01:06,320 --> 00:01:09,920
a locator weight strategy and other

00:01:08,240 --> 00:01:12,159
techniques

00:01:09,920 --> 00:01:14,640
however harnessing the full power of any

00:01:12,159 --> 00:01:16,159
ui automation tool requires the use of

00:01:14,640 --> 00:01:17,920
additional strategies

00:01:16,159 --> 00:01:21,759
to build a framework on top of the

00:01:17,920 --> 00:01:23,360
interaction layer provided by its apis

00:01:21,759 --> 00:01:24,880
we're going to talk about this in the

00:01:23,360 --> 00:01:26,880
context of the ui

00:01:24,880 --> 00:01:28,880
automation framework we use at

00:01:26,880 --> 00:01:31,520
intersystems

00:01:28,880 --> 00:01:34,079
for a bit of background intersystems is

00:01:31,520 --> 00:01:36,880
a leading provider of data technology

00:01:34,079 --> 00:01:37,840
across a range of sectors some of our

00:01:36,880 --> 00:01:41,040
main products

00:01:37,840 --> 00:01:43,759
are intersystems iris and iris for help

00:01:41,040 --> 00:01:45,200
which are data platforms and health

00:01:43,759 --> 00:01:48,720
share and track care which

00:01:45,200 --> 00:01:51,680
are product suites specific to the

00:01:48,720 --> 00:01:51,680
healthcare industry

00:01:52,880 --> 00:01:57,119
the quality development organization

00:01:54,880 --> 00:01:59,280
consists of about 70 people

00:01:57,119 --> 00:02:02,079
and the data platforms division runs a

00:01:59,280 --> 00:02:04,320
little over 5 000 selenium tests and

00:02:02,079 --> 00:02:06,880
many tens of thousands of other backend

00:02:04,320 --> 00:02:09,360
tests and the health share division

00:02:06,880 --> 00:02:11,440
which uses an agile methodology consists

00:02:09,360 --> 00:02:15,120
of nine scrum teams running

00:02:11,440 --> 00:02:18,879
about 700 selenium tests currently

00:02:15,120 --> 00:02:20,720
using selenium grid and jenkins

00:02:18,879 --> 00:02:22,000
we also have a selenium community of

00:02:20,720 --> 00:02:24,000
practice which

00:02:22,000 --> 00:02:25,840
meets bi-weekly across these various

00:02:24,000 --> 00:02:28,720
scrum teams and divisions

00:02:25,840 --> 00:02:29,680
and hosts presentations roundtables

00:02:28,720 --> 00:02:32,239
workshops

00:02:29,680 --> 00:02:34,800
and code reviews it has also been

00:02:32,239 --> 00:02:37,840
instrumental in extending the framework

00:02:34,800 --> 00:02:37,840
which we're going to look at

00:02:38,160 --> 00:02:42,720
some of the framework features and

00:02:39,920 --> 00:02:46,080
strategies we'd like to share

00:02:42,720 --> 00:02:49,440
include separation of concerns

00:02:46,080 --> 00:02:52,319
across a range of levels

00:02:49,440 --> 00:02:53,440
the use of bdd principles which allow

00:02:52,319 --> 00:02:55,519
among other things

00:02:53,440 --> 00:02:57,440
streamlined test data for input and

00:02:55,519 --> 00:02:59,200
validation

00:02:57,440 --> 00:03:01,599
and a number of guardrails that we've

00:02:59,200 --> 00:03:02,319
put in place to address the reliability

00:03:01,599 --> 00:03:04,640
aspects

00:03:02,319 --> 00:03:07,040
mentioned earlier including implicit

00:03:04,640 --> 00:03:10,640
constructor-based page validation

00:03:07,040 --> 00:03:13,120
stateful navigation and static typing of

00:03:10,640 --> 00:03:15,120
various entities

00:03:13,120 --> 00:03:17,120
finally we'll look at some utilities

00:03:15,120 --> 00:03:19,040
that we've developed for efficient data

00:03:17,120 --> 00:03:21,280
input and validation

00:03:19,040 --> 00:03:23,360
including get and set universal for type

00:03:21,280 --> 00:03:25,360
agnostic element interaction

00:03:23,360 --> 00:03:26,879
get and set properties for bulk

00:03:25,360 --> 00:03:30,000
population of inputs

00:03:26,879 --> 00:03:32,799
and a custom table validator

00:03:30,000 --> 00:03:35,280
separation of concerns is implemented

00:03:32,799 --> 00:03:37,360
via modularization and object-oriented

00:03:35,280 --> 00:03:39,680
principles which confer the obvious

00:03:37,360 --> 00:03:40,799
advantages of maintainability

00:03:39,680 --> 00:03:44,080
reusability

00:03:40,799 --> 00:03:45,599
flexibility and readability the approach

00:03:44,080 --> 00:03:48,239
we take

00:03:45,599 --> 00:03:50,000
is to maintain a separation between page

00:03:48,239 --> 00:03:53,360
level document object model

00:03:50,000 --> 00:03:56,560
and business logic between navigation

00:03:53,360 --> 00:03:57,439
and validation between input data and

00:03:56,560 --> 00:04:00,319
functionality

00:03:57,439 --> 00:04:03,200
and between code expertise and business

00:04:00,319 --> 00:04:03,200
domain knowledge

00:04:03,840 --> 00:04:10,480
this is a schematic of the structure of

00:04:06,720 --> 00:04:12,480
our ui automation's architecture

00:04:10,480 --> 00:04:14,720
because this slide is a bit busy we'll

00:04:12,480 --> 00:04:17,280
go through it layer by layer

00:04:14,720 --> 00:04:18,239
at the bottom is the open source layer

00:04:17,280 --> 00:04:20,959
including

00:04:18,239 --> 00:04:23,600
webdriver i o of course and a number of

00:04:20,959 --> 00:04:23,600
services

00:04:24,000 --> 00:04:29,919
including typescript cucumber and the

00:04:27,919 --> 00:04:31,680
allure reporter which another

00:04:29,919 --> 00:04:34,880
breakout session in this conference will

00:04:31,680 --> 00:04:34,880
be addressing also

00:04:35,440 --> 00:04:42,160
next is the ui map layer which contains

00:04:38,960 --> 00:04:44,880
locator maps that resolve elements based

00:04:42,160 --> 00:04:47,120
on selectors and give them names

00:04:44,880 --> 00:04:47,919
additionally we define custom commands

00:04:47,120 --> 00:04:51,280
to extend

00:04:47,919 --> 00:04:53,520
webdriverio to add logging and

00:04:51,280 --> 00:04:54,639
optional parameters as well as new

00:04:53,520 --> 00:04:57,280
commands

00:04:54,639 --> 00:04:59,840
such as get and set universal get and

00:04:57,280 --> 00:05:03,840
set properties

00:04:59,840 --> 00:05:06,000
set checkbox and radio and many others

00:05:03,840 --> 00:05:08,639
we also define common utilities

00:05:06,000 --> 00:05:11,840
including page stack and process table

00:05:08,639 --> 00:05:14,160
and other commonly used functions

00:05:11,840 --> 00:05:15,919
these rectangles shaded in blue are part

00:05:14,160 --> 00:05:19,120
of a common repository that

00:05:15,919 --> 00:05:21,919
teams can map their

00:05:19,120 --> 00:05:24,800
um their code to to take advantage of

00:05:21,919 --> 00:05:26,560
the latest developments in common code

00:05:24,800 --> 00:05:29,520
whereas the rest of the framework is

00:05:26,560 --> 00:05:31,600
project or team specific

00:05:29,520 --> 00:05:34,720
the page object layer facilitates

00:05:31,600 --> 00:05:38,000
logic-less interaction with elements

00:05:34,720 --> 00:05:41,120
page object classes extend locator maps

00:05:38,000 --> 00:05:44,479
and define custom atomic

00:05:41,120 --> 00:05:46,720
methods on elements if needed they also

00:05:44,479 --> 00:05:49,600
include page validations in their

00:05:46,720 --> 00:05:51,919
constructor for implicit validation

00:05:49,600 --> 00:05:54,400
they can also refer to common widgets

00:05:51,919 --> 00:05:56,400
and panels

00:05:54,400 --> 00:05:58,720
the business layer contains the

00:05:56,400 --> 00:05:59,520
application's navigation and validation

00:05:58,720 --> 00:06:01,440
logic

00:05:59,520 --> 00:06:03,840
and is implemented via so-called

00:06:01,440 --> 00:06:06,800
business ui service classes

00:06:03,840 --> 00:06:08,639
these extend page object classes and

00:06:06,800 --> 00:06:12,800
implement workflows within

00:06:08,639 --> 00:06:16,400
and across pages they also model the

00:06:12,800 --> 00:06:16,400
relationships among pages

00:06:17,199 --> 00:06:20,240
and the flow within the application for

00:06:19,520 --> 00:06:22,080
one thing

00:06:20,240 --> 00:06:23,680
by having their navigation methods

00:06:22,080 --> 00:06:26,479
return an instance

00:06:23,680 --> 00:06:27,520
of the landing page meaning anytime an

00:06:26,479 --> 00:06:30,160
action

00:06:27,520 --> 00:06:32,160
results in navigation to a new page the

00:06:30,160 --> 00:06:34,639
method that performs the action

00:06:32,160 --> 00:06:37,440
instantiates and returns an instance of

00:06:34,639 --> 00:06:39,840
the child page class

00:06:37,440 --> 00:06:40,800
in the shaded rectangle is the class

00:06:39,840 --> 00:06:44,160
hierarchy

00:06:40,800 --> 00:06:47,759
that comprises the page object

00:06:44,160 --> 00:06:50,080
as a given page object and

00:06:47,759 --> 00:06:51,840
represents a page or panel in the

00:06:50,080 --> 00:06:53,440
application

00:06:51,840 --> 00:06:57,120
depending on the complexity of the

00:06:53,440 --> 00:07:01,280
application this can be simplified

00:06:57,120 --> 00:07:04,080
and can condense to just one or two

00:07:01,280 --> 00:07:04,800
classes or files per page if there are

00:07:04,080 --> 00:07:07,199
not many

00:07:04,800 --> 00:07:08,800
elements per page or the business logic

00:07:07,199 --> 00:07:11,199
is not very complex

00:07:08,800 --> 00:07:12,080
but we find this separation quite useful

00:07:11,199 --> 00:07:14,720
especially

00:07:12,080 --> 00:07:17,039
in order to provide flexibility for

00:07:14,720 --> 00:07:19,120
multiple teams testing different types

00:07:17,039 --> 00:07:22,000
of applications

00:07:19,120 --> 00:07:22,800
business ui services reference business

00:07:22,000 --> 00:07:25,199
option type

00:07:22,800 --> 00:07:28,639
definitions which specify the available

00:07:25,199 --> 00:07:31,919
parameters for their methods

00:07:28,639 --> 00:07:35,120
and likewise there are business option

00:07:31,919 --> 00:07:37,120
classes that specify defaults and

00:07:35,120 --> 00:07:39,039
construct the custom cucumber world

00:07:37,120 --> 00:07:42,319
object

00:07:39,039 --> 00:07:43,039
the cucumber world object is designed to

00:07:42,319 --> 00:07:46,800
maintain

00:07:43,039 --> 00:07:48,800
maintain state among steps in a scenario

00:07:46,800 --> 00:07:50,080
it contains business options and other

00:07:48,800 --> 00:07:52,720
data

00:07:50,080 --> 00:07:53,759
finally the test layer which is powered

00:07:52,720 --> 00:07:55,759
by cucumber

00:07:53,759 --> 00:07:57,520
consists of feature files and step

00:07:55,759 --> 00:07:59,520
definitions

00:07:57,520 --> 00:08:00,720
feature files use the so-called gurken

00:07:59,520 --> 00:08:03,680
syntax

00:08:00,720 --> 00:08:04,319
to define test scenarios and scenario

00:08:03,680 --> 00:08:08,160
outlines

00:08:04,319 --> 00:08:10,720
and to specify test data feature files

00:08:08,160 --> 00:08:11,599
call steps defined in step definition

00:08:10,720 --> 00:08:16,000
files

00:08:11,599 --> 00:08:18,319
which map steps to ui service methods

00:08:16,000 --> 00:08:21,680
they can be used to chain navigation and

00:08:18,319 --> 00:08:23,759
validation commands for readability

00:08:21,680 --> 00:08:26,639
the test layer is isolated from

00:08:23,759 --> 00:08:29,360
dependencies on downstream pages

00:08:26,639 --> 00:08:31,520
by the mechanism described here where

00:08:29,360 --> 00:08:34,399
business ui services

00:08:31,520 --> 00:08:35,519
return instances of pages that they

00:08:34,399 --> 00:08:37,919
navigate to

00:08:35,519 --> 00:08:38,959
so that rather than having to import and

00:08:37,919 --> 00:08:41,440
depend on

00:08:38,959 --> 00:08:42,080
every page a test interacts with it

00:08:41,440 --> 00:08:44,399
usually

00:08:42,080 --> 00:08:45,519
only has to import the login page and

00:08:44,399 --> 00:08:49,760
all the rest are

00:08:45,519 --> 00:08:54,880
organically generated during navigation

00:08:49,760 --> 00:08:57,040
of the workflow

00:08:54,880 --> 00:08:58,640
next we'll take a quick look at our use

00:08:57,040 --> 00:09:01,360
of bdd principles which

00:08:58,640 --> 00:09:02,720
is basically about cucumber and what is

00:09:01,360 --> 00:09:05,279
cucumber

00:09:02,720 --> 00:09:06,080
it's a behavior-driven development test

00:09:05,279 --> 00:09:08,480
framework

00:09:06,080 --> 00:09:09,760
which defines a test layer on top of a

00:09:08,480 --> 00:09:12,000
test framework

00:09:09,760 --> 00:09:14,640
written in other languages for which

00:09:12,000 --> 00:09:16,800
cucumber provides findings

00:09:14,640 --> 00:09:18,880
it provides a business facing language

00:09:16,800 --> 00:09:21,279
which gets mapped to code via step

00:09:18,880 --> 00:09:24,880
definitions

00:09:21,279 --> 00:09:26,720
if you look at cucumber's website they

00:09:24,880 --> 00:09:28,800
build themselves as an open source tool

00:09:26,720 --> 00:09:31,200
for executable specifications

00:09:28,800 --> 00:09:33,839
that merges specification and test

00:09:31,200 --> 00:09:37,279
documentation into one cohesive whole

00:09:33,839 --> 00:09:40,880
so this describes an ideal of bdd

00:09:37,279 --> 00:09:43,920
development where end-to-end

00:09:40,880 --> 00:09:48,080
traceability from requirements to code

00:09:43,920 --> 00:09:49,920
is implemented using gherkin but

00:09:48,080 --> 00:09:51,839
it can also be used to simply write

00:09:49,920 --> 00:09:53,040
tests and more in the spirit of test

00:09:51,839 --> 00:09:55,680
driven development

00:09:53,040 --> 00:09:56,720
and then write the code both application

00:09:55,680 --> 00:09:59,200
and test code

00:09:56,720 --> 00:10:02,720
to make the test pass and this is more

00:09:59,200 --> 00:10:05,279
what enter systems strives for

00:10:02,720 --> 00:10:06,079
this is a simple example of a feature

00:10:05,279 --> 00:10:09,519
file

00:10:06,079 --> 00:10:11,200
with standard sections

00:10:09,519 --> 00:10:14,399
the feature provides the name of the

00:10:11,200 --> 00:10:17,519
feature and a free form description

00:10:14,399 --> 00:10:20,800
the background section is optional and

00:10:17,519 --> 00:10:23,760
gets executed once before each scenario

00:10:20,800 --> 00:10:24,320
whereas scenario is basically a test

00:10:23,760 --> 00:10:27,680
it's one

00:10:24,320 --> 00:10:31,120
set of steps with no examples table

00:10:27,680 --> 00:10:33,440
whereas a scenario outline is a set of

00:10:31,120 --> 00:10:38,399
steps that gets repeated for each row

00:10:33,440 --> 00:10:38,399
of an examples table like a for loop

00:10:38,880 --> 00:10:42,079
the keywords given when then and and are

00:10:41,440 --> 00:10:45,200
used

00:10:42,079 --> 00:10:47,120
to provide logical flow for the

00:10:45,200 --> 00:10:50,160
scenarios

00:10:47,120 --> 00:10:52,240
additionally most ides have plugins that

00:10:50,160 --> 00:10:53,279
support cucumber with stub text auto

00:10:52,240 --> 00:10:55,920
completion

00:10:53,279 --> 00:10:58,800
and very useful keyboard shortcuts for

00:10:55,920 --> 00:11:00,720
formatting tables

00:10:58,800 --> 00:11:02,000
individual steps can also be configured

00:11:00,720 --> 00:11:05,120
to accept a table

00:11:02,000 --> 00:11:06,800
as an input parameter this is a

00:11:05,120 --> 00:11:09,680
capability of cucumber that we find

00:11:06,800 --> 00:11:13,200
particularly useful

00:11:09,680 --> 00:11:16,640
for streamlining and organizing our data

00:11:13,200 --> 00:11:19,120
visually when steps accept a data table

00:11:16,640 --> 00:11:22,000
they are passed an object with methods

00:11:19,120 --> 00:11:25,920
that can be used to access the data

00:11:22,000 --> 00:11:28,880
depending on the type of um

00:11:25,920 --> 00:11:30,000
the format in which the step data table

00:11:28,880 --> 00:11:31,920
is presented

00:11:30,000 --> 00:11:34,480
along with the method that's used to

00:11:31,920 --> 00:11:36,320
parse it different data structures are

00:11:34,480 --> 00:11:38,560
generated

00:11:36,320 --> 00:11:39,839
the most common one table.rosehesh

00:11:38,560 --> 00:11:42,160
simply takes

00:11:39,839 --> 00:11:43,200
two columns interpreted as keys and

00:11:42,160 --> 00:11:46,680
values

00:11:43,200 --> 00:11:49,760
to create an object similarly

00:11:46,680 --> 00:11:52,399
table.hashes creates an array of objects

00:11:49,760 --> 00:11:53,760
corresponding to the rows of a table

00:11:52,399 --> 00:11:56,079
and we'll come back to this one when

00:11:53,760 --> 00:11:59,360
looking at our process table

00:11:56,079 --> 00:11:59,360
validation utility

00:11:59,519 --> 00:12:05,519
scalar parameters can also be embedded

00:12:01,600 --> 00:12:05,519
in line in the step definition

00:12:05,839 --> 00:12:10,560
next we'll take a look at some of our

00:12:08,839 --> 00:12:12,959
guardrails firstly

00:12:10,560 --> 00:12:13,920
implicit page validation within page

00:12:12,959 --> 00:12:18,240
constructors

00:12:13,920 --> 00:12:20,720
allows page validation on navigation

00:12:18,240 --> 00:12:22,560
this implicitly enforces that correct

00:12:20,720 --> 00:12:24,399
navigation has occurred before

00:12:22,560 --> 00:12:26,720
continuing with the test

00:12:24,399 --> 00:12:29,200
this is an example of a constructor that

00:12:26,720 --> 00:12:32,240
calls a validation method

00:12:29,200 --> 00:12:34,639
which can validate any aspects

00:12:32,240 --> 00:12:37,320
of a page and in this case it's just

00:12:34,639 --> 00:12:40,240
looking for the title

00:12:37,320 --> 00:12:43,440
context.page is a global

00:12:40,240 --> 00:12:45,360
that constructors also take care of that

00:12:43,440 --> 00:12:46,959
keeps track of the current page for

00:12:45,360 --> 00:12:49,600
stateful navigation

00:12:46,959 --> 00:12:50,639
by this we mean that step definitions

00:12:49,600 --> 00:12:53,680
and methods

00:12:50,639 --> 00:12:56,800
can check whether the current page class

00:12:53,680 --> 00:13:00,800
matches where they expect to start

00:12:56,800 --> 00:13:04,839
and if not they can navigate to it

00:13:00,800 --> 00:13:07,200
additionally all ui service constructors

00:13:04,839 --> 00:13:09,680
contain

00:13:07,200 --> 00:13:10,560
a param at least one parameter called

00:13:09,680 --> 00:13:12,800
validate

00:13:10,560 --> 00:13:13,680
and this allows you by the classes to be

00:13:12,800 --> 00:13:16,639
imported

00:13:13,680 --> 00:13:18,000
into other files without the compiler

00:13:16,639 --> 00:13:21,200
trying to execute

00:13:18,000 --> 00:13:24,079
page validation while loading the files

00:13:21,200 --> 00:13:24,800
which would cause an error instead the

00:13:24,079 --> 00:13:27,200
validation

00:13:24,800 --> 00:13:28,880
only gets executed when the constructor

00:13:27,200 --> 00:13:31,120
is invoked by

00:13:28,880 --> 00:13:32,959
the page getting instantiated by another

00:13:31,120 --> 00:13:35,600
page's

00:13:32,959 --> 00:13:37,680
navigation method that passes the

00:13:35,600 --> 00:13:39,680
validate parameter as true

00:13:37,680 --> 00:13:42,000
additionally divergent paths for

00:13:39,680 --> 00:13:46,480
expected landing pages can be

00:13:42,000 --> 00:13:49,040
parametrized using multiple values or

00:13:46,480 --> 00:13:49,519
constructor parameters as shown here

00:13:49,040 --> 00:13:52,000
where

00:13:49,519 --> 00:13:52,959
a login page can expect to land on the

00:13:52,000 --> 00:13:56,000
home page

00:13:52,959 --> 00:13:58,800
if given valid credentials or

00:13:56,000 --> 00:14:01,920
land on an error and the appropriate

00:13:58,800 --> 00:14:04,800
validation pathways can be controlled

00:14:01,920 --> 00:14:07,760
using these parameters

00:14:04,800 --> 00:14:08,320
in addition to the current page we also

00:14:07,760 --> 00:14:11,279
maintain

00:14:08,320 --> 00:14:11,760
a page stack which we refer to as stack

00:14:11,279 --> 00:14:14,000
p

00:14:11,760 --> 00:14:16,480
an array that keeps track of the page

00:14:14,000 --> 00:14:19,040
navigation history

00:14:16,480 --> 00:14:20,959
and this was devised to support

00:14:19,040 --> 00:14:23,920
backwards navigation

00:14:20,959 --> 00:14:25,120
while avoiding circular dependencies

00:14:23,920 --> 00:14:27,600
these would arise

00:14:25,120 --> 00:14:30,000
if each forward navigation action

00:14:27,600 --> 00:14:32,720
imports and constructs an instance

00:14:30,000 --> 00:14:34,959
of its child landing page then backward

00:14:32,720 --> 00:14:38,800
navigation would require the child

00:14:34,959 --> 00:14:39,279
page to import and instantiate its

00:14:38,800 --> 00:14:42,320
parent

00:14:39,279 --> 00:14:46,079
and this would of course cause an

00:14:42,320 --> 00:14:49,360
error instead we devise these

00:14:46,079 --> 00:14:51,519
utility methods push p pushes the

00:14:49,360 --> 00:14:53,760
current page onto the page stack

00:14:51,519 --> 00:14:55,600
when it's called in the page constructor

00:14:53,760 --> 00:14:58,639
it sets context.page

00:14:55,600 --> 00:15:02,800
to the current page class and

00:14:58,639 --> 00:15:04,160
prints out the page stack as seen here

00:15:02,800 --> 00:15:06,720
on the right

00:15:04,160 --> 00:15:08,000
poppy pops the last page off the page

00:15:06,720 --> 00:15:10,959
stack

00:15:08,000 --> 00:15:13,120
when navigating backwards from a page

00:15:10,959 --> 00:15:15,440
for instance by closing a modal

00:15:13,120 --> 00:15:16,639
clicking a browser back button or using

00:15:15,440 --> 00:15:19,600
breadcrumbs

00:15:16,639 --> 00:15:21,839
this can also optionally validate that

00:15:19,600 --> 00:15:24,839
we've landed back on the parent page

00:15:21,839 --> 00:15:27,519
and sets context.page to the correct

00:15:24,839 --> 00:15:30,480
page

00:15:27,519 --> 00:15:31,360
it also prints the stack so on the right

00:15:30,480 --> 00:15:36,000
here we have

00:15:31,360 --> 00:15:39,680
a snippet of our console output

00:15:36,000 --> 00:15:42,880
showing the custom commands logging

00:15:39,680 --> 00:15:44,560
that logs the action and selector for

00:15:42,880 --> 00:15:48,000
each

00:15:44,560 --> 00:15:51,519
interaction or weight command

00:15:48,000 --> 00:15:54,639
and the page stack on each

00:15:51,519 --> 00:15:57,199
navigation and taken together

00:15:54,639 --> 00:15:58,959
these provide a great snapshot of what

00:15:57,199 --> 00:16:02,079
the test was doing

00:15:58,959 --> 00:16:05,680
if an error occurs during development or

00:16:02,079 --> 00:16:06,959
troubleshooting we mentioned that we use

00:16:05,680 --> 00:16:10,480
typescript for

00:16:06,959 --> 00:16:12,800
ensuring type safety across

00:16:10,480 --> 00:16:14,399
the framework but in particular we use

00:16:12,800 --> 00:16:17,920
it to

00:16:14,399 --> 00:16:18,399
define business options which correspond

00:16:17,920 --> 00:16:20,959
to

00:16:18,399 --> 00:16:23,040
the properties applicable to a specific

00:16:20,959 --> 00:16:27,040
functional area

00:16:23,040 --> 00:16:29,600
or workflow or page in this example here

00:16:27,040 --> 00:16:30,800
role business options represents all the

00:16:29,600 --> 00:16:34,079
possible input

00:16:30,800 --> 00:16:36,480
values that might be provided when

00:16:34,079 --> 00:16:37,600
creating or editing a role in an admin

00:16:36,480 --> 00:16:41,440
application

00:16:37,600 --> 00:16:43,680
whereas role validation options list

00:16:41,440 --> 00:16:45,440
the validation touch points that we

00:16:43,680 --> 00:16:47,759
might want to harvest

00:16:45,440 --> 00:16:49,360
while navigating through the workflow

00:16:47,759 --> 00:16:51,440
and then

00:16:49,360 --> 00:16:54,399
check later to see if they match

00:16:51,440 --> 00:16:54,399
expected values

00:16:55,279 --> 00:16:58,320
and this is one way in which we separate

00:16:57,040 --> 00:17:01,759
the validation

00:16:58,320 --> 00:17:04,799
and navigation logic type

00:17:01,759 --> 00:17:07,439
the type definitions are then used

00:17:04,799 --> 00:17:09,520
to build the context interface which is

00:17:07,439 --> 00:17:10,079
gets used as the type of cucumber

00:17:09,520 --> 00:17:12,880
world's

00:17:10,079 --> 00:17:14,079
context property and multiple type

00:17:12,880 --> 00:17:18,079
definition files

00:17:14,079 --> 00:17:20,640
can extend the context interface

00:17:18,079 --> 00:17:23,919
next business option files are used to

00:17:20,640 --> 00:17:26,959
construct the cucumber world object

00:17:23,919 --> 00:17:30,080
whereby their constructor initializes

00:17:26,959 --> 00:17:32,559
the business options with defaults

00:17:30,080 --> 00:17:34,000
where applicable and these can get

00:17:32,559 --> 00:17:36,559
populated

00:17:34,000 --> 00:17:37,600
or overridden within step definitions by

00:17:36,559 --> 00:17:40,640
data passed in

00:17:37,600 --> 00:17:40,640
by the feature files

00:17:40,799 --> 00:17:44,799
the classes get instantiated and merged

00:17:43,039 --> 00:17:47,039
into cucumber world objects

00:17:44,799 --> 00:17:48,080
context property during world

00:17:47,039 --> 00:17:51,679
construction

00:17:48,080 --> 00:17:53,600
for each scenario for a closer look at

00:17:51,679 --> 00:17:58,080
the cucumber world object

00:17:53,600 --> 00:18:00,160
this is provided to maintain context

00:17:58,080 --> 00:18:02,799
between and among steps within a

00:18:00,160 --> 00:18:02,799
scenario

00:18:03,679 --> 00:18:08,960
this is needed because for instance if

00:18:06,240 --> 00:18:12,000
one step appends a time stamp to

00:18:08,960 --> 00:18:15,520
a unique entity that's being created

00:18:12,000 --> 00:18:17,600
other steps

00:18:15,520 --> 00:18:19,679
will be able to have access to that same

00:18:17,600 --> 00:18:22,720
type stamped value

00:18:19,679 --> 00:18:24,960
using the world object

00:18:22,720 --> 00:18:27,600
this gets regenerated automatically by

00:18:24,960 --> 00:18:30,640
cucumber using the world constructor

00:18:27,600 --> 00:18:32,080
which can be overridden or extended as

00:18:30,640 --> 00:18:34,240
follows

00:18:32,080 --> 00:18:36,799
in this example we have our business

00:18:34,240 --> 00:18:39,360
option classes getting instantiated

00:18:36,799 --> 00:18:40,640
merged and populated into the context

00:18:39,360 --> 00:18:42,640
property

00:18:40,640 --> 00:18:44,559
and the custom world constructor can be

00:18:42,640 --> 00:18:47,360
tied to step definitions

00:18:44,559 --> 00:18:47,360
as shown here

00:18:48,320 --> 00:18:52,080
the world object is exposed within

00:18:50,160 --> 00:18:56,160
cucumber step definitions

00:18:52,080 --> 00:18:57,360
as this keyword and also within certain

00:18:56,160 --> 00:19:00,240
hooks as a parameter

00:18:57,360 --> 00:19:01,200
but it's not accessible anywhere else in

00:19:00,240 --> 00:19:04,400
the code

00:19:01,200 --> 00:19:07,520
such as the page object hierarchy

00:19:04,400 --> 00:19:08,240
so individual business options sets get

00:19:07,520 --> 00:19:11,200
passed

00:19:08,240 --> 00:19:12,400
by step definitions to ui service

00:19:11,200 --> 00:19:14,559
methods

00:19:12,400 --> 00:19:16,000
which provides an additional layer of

00:19:14,559 --> 00:19:19,679
access control

00:19:16,000 --> 00:19:19,679
and avoids the use of globals

00:19:20,720 --> 00:19:24,240
another result of this is that step

00:19:23,360 --> 00:19:26,960
definitions

00:19:24,240 --> 00:19:28,400
must be defined using function syntax

00:19:26,960 --> 00:19:30,400
not arrow syntax

00:19:28,400 --> 00:19:31,760
in order to use cucumber world because

00:19:30,400 --> 00:19:35,440
arrow functions

00:19:31,760 --> 00:19:35,440
don't have this keyword

00:19:35,679 --> 00:19:39,760
so finally we'll look at some of the

00:19:38,400 --> 00:19:44,320
utilities that we use

00:19:39,760 --> 00:19:47,200
for efficient data input and validation

00:19:44,320 --> 00:19:48,400
get and set universal extend webdriverio

00:19:47,200 --> 00:19:50,559
element

00:19:48,400 --> 00:19:52,480
and they first determine the element

00:19:50,559 --> 00:19:54,720
type using tag name

00:19:52,480 --> 00:19:56,160
and type and then they call the

00:19:54,720 --> 00:19:59,360
appropriate command

00:19:56,160 --> 00:20:00,000
to get or set the value based on the

00:19:59,360 --> 00:20:03,520
element's

00:20:00,000 --> 00:20:05,679
tag name and type and this is useful

00:20:03,520 --> 00:20:06,960
because it precludes the need for page

00:20:05,679 --> 00:20:10,080
objects to define

00:20:06,960 --> 00:20:11,919
accessors for every element based on the

00:20:10,080 --> 00:20:14,559
element type

00:20:11,919 --> 00:20:16,240
they're also harnessed in these two

00:20:14,559 --> 00:20:20,400
important custom commands

00:20:16,240 --> 00:20:22,799
get and set properties sub properties

00:20:20,400 --> 00:20:24,400
call set universal iterating over an

00:20:22,799 --> 00:20:26,080
item array of properties

00:20:24,400 --> 00:20:28,000
from which it constructs the page's

00:20:26,080 --> 00:20:29,760
locators

00:20:28,000 --> 00:20:31,520
and the corresponding business option

00:20:29,760 --> 00:20:34,960
value for each

00:20:31,520 --> 00:20:36,720
so this notation takes care of takes

00:20:34,960 --> 00:20:39,520
advantage of javascript's

00:20:36,720 --> 00:20:41,039
accessor properties and access or

00:20:39,520 --> 00:20:43,360
notation

00:20:41,039 --> 00:20:43,360
which

00:20:44,080 --> 00:20:49,919
of course is what makes this construct

00:20:47,520 --> 00:20:51,760
possible because a language that doesn't

00:20:49,919 --> 00:20:54,080
allow

00:20:51,760 --> 00:20:56,640
accessing properties using variables

00:20:54,080 --> 00:21:00,080
would not be able to

00:20:56,640 --> 00:21:00,080
to perform this type of

00:21:00,400 --> 00:21:06,320
interpolation so in order for it to make

00:21:02,720 --> 00:21:10,159
this work names of locator definitions

00:21:06,320 --> 00:21:10,159
must match the business option names

00:21:11,039 --> 00:21:15,360
so an example of how we would use set

00:21:13,679 --> 00:21:18,480
properties to fill

00:21:15,360 --> 00:21:21,600
in this input form with one command

00:21:18,480 --> 00:21:22,720
we would first define the locators whose

00:21:21,600 --> 00:21:25,440
names have to match

00:21:22,720 --> 00:21:26,400
the business options and the ui service

00:21:25,440 --> 00:21:28,480
class would

00:21:26,400 --> 00:21:31,840
define an edit array listing all the

00:21:28,480 --> 00:21:31,840
business options

00:21:32,799 --> 00:21:39,039
and then in order to use set properties

00:21:36,799 --> 00:21:40,720
we would pass an instance of the current

00:21:39,039 --> 00:21:43,840
page this

00:21:40,720 --> 00:21:46,559
which gives access to the

00:21:43,840 --> 00:21:46,559
along with

00:21:47,039 --> 00:21:51,679
desired business option values user

00:21:49,520 --> 00:21:53,679
options or validation options here

00:21:51,679 --> 00:21:55,440
and the array of locator and option

00:21:53,679 --> 00:21:58,240
names to iterate over

00:21:55,440 --> 00:22:00,159
so then get and set properties call get

00:21:58,240 --> 00:22:01,280
or set universal for each item in the

00:22:00,159 --> 00:22:03,600
property array

00:22:01,280 --> 00:22:05,440
referencing the corresponding locator

00:22:03,600 --> 00:22:08,480
and business option value

00:22:05,440 --> 00:22:10,559
if provided and this is why we mentioned

00:22:08,480 --> 00:22:13,679
in the beginning that page objects only

00:22:10,559 --> 00:22:17,120
define accessors if they're needed

00:22:13,679 --> 00:22:18,159
so if an accessor needs some kind of

00:22:17,120 --> 00:22:21,760
custom handling

00:22:18,159 --> 00:22:27,760
such as first expanding a panel

00:22:21,760 --> 00:22:27,760
or switching a tab on a page or

00:22:27,919 --> 00:22:31,919
any kind of custom weight or other

00:22:30,880 --> 00:22:33,760
custom parameter

00:22:31,919 --> 00:22:35,760
then we define an accessor in the page

00:22:33,760 --> 00:22:40,720
object and otherwise we

00:22:35,760 --> 00:22:43,200
use the ui services to simply

00:22:40,720 --> 00:22:45,440
set groups of standard input elements

00:22:43,200 --> 00:22:49,120
all at once and similarly for

00:22:45,440 --> 00:22:52,720
the getters finally

00:22:49,120 --> 00:22:52,720
the process table utility

00:22:53,440 --> 00:23:00,320
is used to validate data provided in

00:22:57,440 --> 00:23:00,720
cucumber step data tables and it can

00:23:00,320 --> 00:23:03,200
parse

00:23:00,720 --> 00:23:04,799
an html table given only the table

00:23:03,200 --> 00:23:08,080
selector

00:23:04,799 --> 00:23:09,200
it processes a given subset of rows and

00:23:08,080 --> 00:23:12,320
columns

00:23:09,200 --> 00:23:13,039
and returns two arrays of objects text

00:23:12,320 --> 00:23:15,280
and elements

00:23:13,039 --> 00:23:16,159
from the table both corresponding

00:23:15,280 --> 00:23:19,440
exactly

00:23:16,159 --> 00:23:23,440
to cucumbers hash's input table format

00:23:19,440 --> 00:23:27,039
and the resulting data structure

00:23:23,440 --> 00:23:28,880
what this allows us to do is to define

00:23:27,039 --> 00:23:31,120
a validation step like the one shown

00:23:28,880 --> 00:23:32,159
here um and the expected data for row

00:23:31,120 --> 00:23:34,799
numbers xyz

00:23:32,159 --> 00:23:36,799
is retrieved and then as the input step

00:23:34,799 --> 00:23:39,039
we simply

00:23:36,799 --> 00:23:40,400
indicate the portion of the table the

00:23:39,039 --> 00:23:41,039
columns and rows that we want to

00:23:40,400 --> 00:23:43,600
validate

00:23:41,039 --> 00:23:45,360
and then use process table to compare

00:23:43,600 --> 00:23:49,760
the actual

00:23:45,360 --> 00:23:51,760
table contents to the expected subset

00:23:49,760 --> 00:23:53,919
process table also accepts faux

00:23:51,760 --> 00:23:56,799
selectors to accommodate non-standard

00:23:53,919 --> 00:23:56,799
table structure

00:23:57,760 --> 00:24:01,120
finally we mentioned that we use allure

00:23:59,840 --> 00:24:03,760
reports

00:24:01,120 --> 00:24:05,840
so just a quick plug for them as being

00:24:03,760 --> 00:24:08,080
intuitive and interactable

00:24:05,840 --> 00:24:09,520
and allowing very transparent

00:24:08,080 --> 00:24:11,440
troubleshooting

00:24:09,520 --> 00:24:13,120
by allowing you to drill down to

00:24:11,440 --> 00:24:15,200
scenarios and steps

00:24:13,120 --> 00:24:17,200
in order to view stack traces and

00:24:15,200 --> 00:24:19,440
screenshots for failures

00:24:17,200 --> 00:24:20,559
they also provide a variety of reports

00:24:19,440 --> 00:24:22,640
and metrics

00:24:20,559 --> 00:24:25,039
and integrate with jenkins and other

00:24:22,640 --> 00:24:27,279
build managers

00:24:25,039 --> 00:24:29,279
here's an example of a top-level suite

00:24:27,279 --> 00:24:31,679
view of an allure report

00:24:29,279 --> 00:24:33,120
with each row here corresponding to a

00:24:31,679 --> 00:24:35,520
feature file

00:24:33,120 --> 00:24:36,480
and failures classified into product

00:24:35,520 --> 00:24:39,120
defects or

00:24:36,480 --> 00:24:41,360
assertion failures and test defects or

00:24:39,120 --> 00:24:47,520
broken tests

00:24:41,360 --> 00:24:50,960
you can drill into these colored bars

00:24:47,520 --> 00:24:53,520
to get to the scenario view which lists

00:24:50,960 --> 00:24:56,000
the names of scenarios in a feature file

00:24:53,520 --> 00:24:58,640
on the left hand column

00:24:56,000 --> 00:24:59,120
and if you select one of them it shows

00:24:58,640 --> 00:25:01,200
the

00:24:59,120 --> 00:25:02,159
steps of the scenario in the right hand

00:25:01,200 --> 00:25:05,360
panel

00:25:02,159 --> 00:25:09,679
along with screenshots and

00:25:05,360 --> 00:25:09,679
stack traces for any failed steps

00:25:09,919 --> 00:25:16,320
some takeaways that

00:25:13,039 --> 00:25:19,440
we hope you'll gather from this talk

00:25:16,320 --> 00:25:22,080
are one the importance of separation of

00:25:19,440 --> 00:25:22,080
concerns

00:25:22,320 --> 00:25:28,080
including the use of bdd principles

00:25:25,440 --> 00:25:30,240
use of guard rails to model and enforce

00:25:28,080 --> 00:25:32,960
application logic

00:25:30,240 --> 00:25:34,480
common utilities for efficiency and

00:25:32,960 --> 00:25:36,960
flexibility

00:25:34,480 --> 00:25:38,000
and the use of tools for debugging and

00:25:36,960 --> 00:25:42,240
analysis

00:25:38,000 --> 00:25:46,559
that allow rich logging and reporting

00:25:42,240 --> 00:25:46,559

YouTube URL: https://www.youtube.com/watch?v=86zerP8DMHE


