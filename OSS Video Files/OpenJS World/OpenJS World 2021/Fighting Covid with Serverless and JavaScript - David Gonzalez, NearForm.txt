Title: Fighting Covid with Serverless and JavaScript - David Gonzalez, NearForm
Publication date: 2021-05-29
Playlist: OpenJS World 2021
Description: 
	Fighting Covid with Serverless and JavaScript - David Gonzalez, NearForm

At NearForm, we built a number of Covid tracking applications but more important: we also open sourced the core. This source can be found at https://github.com/covidgreen/. In this talk, I will explain what are the major pitfalls we found along the way but also how to operate a planetary scale application with a very reduced team of people and a surprisingly low number of outages. Table of contents: - Introduction - Why Serverless - What were the biggest problems - Recommendations for running large scale geographically dispersed apps

Join the speaker for live Q&A on Slack, channel - #openjs_world-automation_ci_cd
Thursday, June 3 from 02:00 - 02:20 PDT / 11:00 - 11:20 CEST
Thursday, June 3 from 07:40 - 08:00 PDT /  16:40 - 17:00 CEST
Captions: 
	00:00:00,000 --> 00:00:03,520
hi everyone my name is debbie gonzalez

00:00:02,159 --> 00:00:05,200
and i'm going to talk to you about

00:00:03,520 --> 00:00:07,359
fighting copy 19 with serverless

00:00:05,200 --> 00:00:10,960
javascript

00:00:07,359 --> 00:00:13,040
first of all some presentations i

00:00:10,960 --> 00:00:14,799
work as a devops architect for a company

00:00:13,040 --> 00:00:16,320
called uniform by the way we are hiring

00:00:14,799 --> 00:00:17,199
if you are looking for a job just send

00:00:16,320 --> 00:00:18,800
me an email

00:00:17,199 --> 00:00:20,720
and i'll be more than happy to introduce

00:00:18,800 --> 00:00:22,640
you to the pertinent people

00:00:20,720 --> 00:00:24,480
i'm also a part-time lecturer at cct

00:00:22,640 --> 00:00:26,000
college in dublin i lecture mainly in

00:00:24,480 --> 00:00:28,880
cloud and devops

00:00:26,000 --> 00:00:30,000
and in general software development i am

00:00:28,880 --> 00:00:31,760
what my wife calls

00:00:30,000 --> 00:00:33,520
a technology geek because i like

00:00:31,760 --> 00:00:35,840
technology so much

00:00:33,520 --> 00:00:38,399
and i got a few years back a nomination

00:00:35,840 --> 00:00:40,320
as a google developer expert in gcp

00:00:38,399 --> 00:00:43,360
but i'm also a member of the nodejs

00:00:40,320 --> 00:00:45,360
foundation in the security working group

00:00:43,360 --> 00:00:47,200
i wrote two books one of them called

00:00:45,360 --> 00:00:48,800
developing microservices with node.js

00:00:47,200 --> 00:00:50,000
and another one called implementing

00:00:48,800 --> 00:00:52,320
modern devops and

00:00:50,000 --> 00:00:54,160
they are there for you to check out and

00:00:52,320 --> 00:00:54,719
today we are going to talk about the

00:00:54,160 --> 00:00:58,399
problem

00:00:54,719 --> 00:00:59,920
of copied in particular so think of the

00:00:58,399 --> 00:01:03,520
situation where you get

00:00:59,920 --> 00:01:06,159
into a boost and you spend like half an

00:01:03,520 --> 00:01:08,479
hour going into your destination

00:01:06,159 --> 00:01:10,400
but turns out the next day you test

00:01:08,479 --> 00:01:12,799
positive for copy 19

00:01:10,400 --> 00:01:14,320
so how do you warn the people who have

00:01:12,799 --> 00:01:15,680
been with you in the booths which are a

00:01:14,320 --> 00:01:17,600
close contact

00:01:15,680 --> 00:01:19,280
that you have copied 19 and they have

00:01:17,600 --> 00:01:21,920
been in touch with you

00:01:19,280 --> 00:01:22,960
should then they should be tested but

00:01:21,920 --> 00:01:25,840
you don't know them

00:01:22,960 --> 00:01:26,960
so that's a very sort of tricky problem

00:01:25,840 --> 00:01:29,759
and in the beginning of

00:01:26,960 --> 00:01:31,360
all the copied pandemic we didn't know

00:01:29,759 --> 00:01:34,560
too much about the disease

00:01:31,360 --> 00:01:37,040
we didn't know how close or or

00:01:34,560 --> 00:01:38,240
for how long you should have been in

00:01:37,040 --> 00:01:39,920
contact to a person

00:01:38,240 --> 00:01:41,360
but the reality is that the videos was

00:01:39,920 --> 00:01:43,280
spreading very quickly

00:01:41,360 --> 00:01:44,960
there is another interesting point about

00:01:43,280 --> 00:01:46,960
kobe 19 is that

00:01:44,960 --> 00:01:48,320
everybody talks about the heart immunity

00:01:46,960 --> 00:01:50,799
at 70 percent

00:01:48,320 --> 00:01:52,399
like once 70 percent of the people are

00:01:50,799 --> 00:01:55,280
immune to the virus

00:01:52,399 --> 00:01:57,360
in theory we should have what the

00:01:55,280 --> 00:01:58,399
scientifics called health immunity which

00:01:57,360 --> 00:01:59,840
means

00:01:58,399 --> 00:02:02,000
there are not enough individuals who

00:01:59,840 --> 00:02:04,159
can't transmit the virus so

00:02:02,000 --> 00:02:05,280
the pandemic will reduce and eventually

00:02:04,159 --> 00:02:07,040
will disappear

00:02:05,280 --> 00:02:09,039
but that's not the reality the reality

00:02:07,040 --> 00:02:11,920
is that the head immunity depends

00:02:09,039 --> 00:02:12,560
on the transmissibility number of the

00:02:11,920 --> 00:02:14,879
virus

00:02:12,560 --> 00:02:16,400
in particular the air of that formula

00:02:14,879 --> 00:02:18,959
that we all learn

00:02:16,400 --> 00:02:19,840
in college or in high school and we all

00:02:18,959 --> 00:02:22,879
hate it

00:02:19,840 --> 00:02:24,400
which is how easy does the videos spread

00:02:22,879 --> 00:02:28,160
across the people

00:02:24,400 --> 00:02:30,400
so that's why when the pandemic started

00:02:28,160 --> 00:02:31,440
many of pretty much all the countries in

00:02:30,400 --> 00:02:34,000
the world

00:02:31,440 --> 00:02:35,200
dictated a severe lockdown where people

00:02:34,000 --> 00:02:37,760
will not

00:02:35,200 --> 00:02:38,720
be able to get close to each other and

00:02:37,760 --> 00:02:42,480
block

00:02:38,720 --> 00:02:44,800
the people in clusters so that means

00:02:42,480 --> 00:02:46,160
that her immunity number or that number

00:02:44,800 --> 00:02:48,879
will go down

00:02:46,160 --> 00:02:49,680
ideally below one and the head immunity

00:02:48,879 --> 00:02:52,000
will be

00:02:49,680 --> 00:02:53,519
less than 70 percent until we have a

00:02:52,000 --> 00:02:56,400
solution for the virus

00:02:53,519 --> 00:02:57,200
so one way one way to avoid this this

00:02:56,400 --> 00:02:59,599
transmission

00:02:57,200 --> 00:03:00,239
is by isolating close contacts as i said

00:02:59,599 --> 00:03:02,400
before

00:03:00,239 --> 00:03:04,560
so if you are only seeing your family

00:03:02,400 --> 00:03:07,440
the reality is that

00:03:04,560 --> 00:03:08,239
um you will only transmit the videos to

00:03:07,440 --> 00:03:11,840
your family

00:03:08,239 --> 00:03:13,120
and the only possible vector if somebody

00:03:11,840 --> 00:03:15,280
in that cluster

00:03:13,120 --> 00:03:17,760
going out for shopping or going out

00:03:15,280 --> 00:03:20,400
contacting other people so we reduce

00:03:17,760 --> 00:03:22,319
the ability for the videos to spread

00:03:20,400 --> 00:03:24,720
what is a close contact with time

00:03:22,319 --> 00:03:26,080
it was determined that it's 15 minutes

00:03:24,720 --> 00:03:29,599
closer than 2 meters

00:03:26,080 --> 00:03:33,200
and that is why

00:03:29,599 --> 00:03:34,480
what google and apple implemented in the

00:03:33,200 --> 00:03:37,680
contact tracing api

00:03:34,480 --> 00:03:40,959
in android and ios

00:03:37,680 --> 00:03:42,799
so at near form we built

00:03:40,959 --> 00:03:44,319
a contact tracer initially for the

00:03:42,799 --> 00:03:46,959
government of ireland

00:03:44,319 --> 00:03:48,400
for the hsc which is the health service

00:03:46,959 --> 00:03:49,840
executive here in ireland which is where

00:03:48,400 --> 00:03:52,480
i live by the way

00:03:49,840 --> 00:03:53,680
and um the obvious choice for us was

00:03:52,480 --> 00:03:56,640
using aws

00:03:53,680 --> 00:03:58,080
we know aws we use aws in pretty much

00:03:56,640 --> 00:03:59,760
every project

00:03:58,080 --> 00:04:01,840
but then there was another not so

00:03:59,760 --> 00:04:03,120
obvious choice which was a good card

00:04:01,840 --> 00:04:06,799
which was using

00:04:03,120 --> 00:04:08,959
serverless in that case we used

00:04:06,799 --> 00:04:10,239
a lot of javascript what i mean a lot of

00:04:08,959 --> 00:04:12,799
javascript is that

00:04:10,239 --> 00:04:14,239
pretty much absolutely everything well

00:04:12,799 --> 00:04:16,799
pretty much you know absolutely

00:04:14,239 --> 00:04:18,000
everything in the application is written

00:04:16,799 --> 00:04:20,400
in javascript

00:04:18,000 --> 00:04:21,359
from the application itself built in

00:04:20,400 --> 00:04:25,280
react native

00:04:21,359 --> 00:04:28,240
to the back-end api built in node.js

00:04:25,280 --> 00:04:29,600
lambdas were built also in ogs and you

00:04:28,240 --> 00:04:30,320
know like pretty much every single

00:04:29,600 --> 00:04:33,360
service

00:04:30,320 --> 00:04:35,759
was a javascript base

00:04:33,360 --> 00:04:37,680
we're deploying them in lambdas and in

00:04:35,759 --> 00:04:40,560
csvargate

00:04:37,680 --> 00:04:41,759
for those who are not very familiar with

00:04:40,560 --> 00:04:44,720
serverless

00:04:41,759 --> 00:04:47,040
in general when people talk about

00:04:44,720 --> 00:04:50,320
serverless they refer to lambdas

00:04:47,040 --> 00:04:52,639
the reality is that there is a way more

00:04:50,320 --> 00:04:53,680
catalogue of services than land does in

00:04:52,639 --> 00:04:56,960
aws

00:04:53,680 --> 00:05:00,240
google cloud or azure that

00:04:56,960 --> 00:05:02,639
will greatly help you to deploy and and

00:05:00,240 --> 00:05:04,080
evolve your applications one of them is

00:05:02,639 --> 00:05:05,600
ecs fargate

00:05:04,080 --> 00:05:08,160
so if you are familiar with

00:05:05,600 --> 00:05:09,680
orchestration like kubernetes or ecs

00:05:08,160 --> 00:05:12,720
itself

00:05:09,680 --> 00:05:13,440
you need to have a cluster of bms which

00:05:12,720 --> 00:05:16,080
will run

00:05:13,440 --> 00:05:18,080
your containers on the target version of

00:05:16,080 --> 00:05:19,600
ecs or ekgs

00:05:18,080 --> 00:05:21,520
you really don't need to manage that

00:05:19,600 --> 00:05:23,039
cluster because that's managed by aws

00:05:21,520 --> 00:05:25,440
you just need to worry about

00:05:23,039 --> 00:05:27,120
how much memory and how many cpus you

00:05:25,440 --> 00:05:30,320
need for your tasks and

00:05:27,120 --> 00:05:33,840
aws will do the rest the only component

00:05:30,320 --> 00:05:36,560
in our infrastructure that was not um

00:05:33,840 --> 00:05:38,320
that was not serverless was rds and the

00:05:36,560 --> 00:05:41,840
reason for that is because

00:05:38,320 --> 00:05:43,360
when we started the the project itself

00:05:41,840 --> 00:05:44,560
and that was built very quickly by the

00:05:43,360 --> 00:05:46,240
way was built in something like three

00:05:44,560 --> 00:05:47,919
weeks and that was very impressive by

00:05:46,240 --> 00:05:50,479
the person who started

00:05:47,919 --> 00:05:51,440
and we actually did not want to risk to

00:05:50,479 --> 00:05:53,919
use

00:05:51,440 --> 00:05:54,800
servers database the rds was not super

00:05:53,919 --> 00:05:57,840
mature

00:05:54,800 --> 00:06:00,960
and we prefer to go for the the

00:05:57,840 --> 00:06:04,080
you know the the comfort area

00:06:00,960 --> 00:06:06,479
of or database skills

00:06:04,080 --> 00:06:07,680
the api gave here is marked in bold and

00:06:06,479 --> 00:06:09,360
there is a

00:06:07,680 --> 00:06:11,680
i would say a foreign but it's not very

00:06:09,360 --> 00:06:14,639
funny about the api gateway

00:06:11,680 --> 00:06:15,039
and so the api gateway is key pretty

00:06:14,639 --> 00:06:16,880
much

00:06:15,039 --> 00:06:19,840
for every distributed infrastructure

00:06:16,880 --> 00:06:21,759
nowadays i've seen many customers

00:06:19,840 --> 00:06:23,840
mainly building node.js applications

00:06:21,759 --> 00:06:26,800
which fail miserably

00:06:23,840 --> 00:06:27,680
because they don't have an api gateway

00:06:26,800 --> 00:06:30,639
strategy

00:06:27,680 --> 00:06:32,840
in general we made a heavy usage of the

00:06:30,639 --> 00:06:36,000
api gateway

00:06:32,840 --> 00:06:39,199
because every single car into the system

00:06:36,000 --> 00:06:41,280
will hit the api gateway and then with

00:06:39,199 --> 00:06:44,240
jwt and distributed authentication

00:06:41,280 --> 00:06:45,199
we could redirect the user from uh ecs

00:06:44,240 --> 00:06:48,319
fargate

00:06:45,199 --> 00:06:50,160
methods in in a fastified server into a

00:06:48,319 --> 00:06:53,120
lambda who will do something else

00:06:50,160 --> 00:06:53,759
or even s3 then we also use the useful

00:06:53,120 --> 00:06:57,280
suspects

00:06:53,759 --> 00:06:59,120
sqs sns ppc like you know

00:06:57,280 --> 00:07:01,520
typical building blocks of aws that

00:06:59,120 --> 00:07:05,039
everybody would use

00:07:01,520 --> 00:07:07,440
um also serverless

00:07:05,039 --> 00:07:10,319
has another problem okay and this is a

00:07:07,440 --> 00:07:13,280
spoiler alert lambdas are bad

00:07:10,319 --> 00:07:15,759
with three dots and we will i will

00:07:13,280 --> 00:07:18,800
explain you more about that in a second

00:07:15,759 --> 00:07:20,800
so lambdas are a very dangerous ally and

00:07:18,800 --> 00:07:23,440
node.js and landas are the perfect

00:07:20,800 --> 00:07:25,919
perfect combination in aws because

00:07:23,440 --> 00:07:27,039
the speeds at what you can develop a

00:07:25,919 --> 00:07:29,280
system

00:07:27,039 --> 00:07:30,080
with some components based in lambda

00:07:29,280 --> 00:07:32,400
it's

00:07:30,080 --> 00:07:34,960
unreal i mean you can be very productive

00:07:32,400 --> 00:07:37,599
at modeling a system with dandas

00:07:34,960 --> 00:07:38,639
but if you model your full system using

00:07:37,599 --> 00:07:41,039
dandas

00:07:38,639 --> 00:07:42,720
it's what i call the 2021 version of

00:07:41,039 --> 00:07:44,639
let's use a store procedures

00:07:42,720 --> 00:07:45,840
you just do that don't do that you

00:07:44,639 --> 00:07:48,639
should or

00:07:45,840 --> 00:07:49,919
in my opinion you should actually

00:07:48,639 --> 00:07:53,039
combine lambdas

00:07:49,919 --> 00:07:54,400
with um some other components like ecs

00:07:53,039 --> 00:07:57,039
fargate

00:07:54,400 --> 00:07:59,199
k native or you know like lately google

00:07:57,039 --> 00:08:01,759
for example in gcp have

00:07:59,199 --> 00:08:04,000
released something called gke autopilot

00:08:01,759 --> 00:08:06,160
which allows you to run a kubernetes

00:08:04,000 --> 00:08:08,000
cluster without having any servers i

00:08:06,160 --> 00:08:11,120
know you also have ecs

00:08:08,000 --> 00:08:12,720
eks fargate but the issue with eks

00:08:11,120 --> 00:08:14,479
target that comes at a compromise like

00:08:12,720 --> 00:08:16,080
for example you cannot use diamond sets

00:08:14,479 --> 00:08:18,800
or things like that

00:08:16,080 --> 00:08:20,080
my opinion if you ask me k native is

00:08:18,800 --> 00:08:23,039
going to eat the world

00:08:20,080 --> 00:08:24,560
k native is a serverless implementation

00:08:23,039 --> 00:08:26,800
on top of kubernetes

00:08:24,560 --> 00:08:29,280
which gives you all the building blocks

00:08:26,800 --> 00:08:32,399
of a serverless architecture

00:08:29,280 --> 00:08:34,320
that run nicely into kubernetes and then

00:08:32,399 --> 00:08:36,640
together with the cluster auto scaler

00:08:34,320 --> 00:08:37,440
and a few other touches here and there

00:08:36,640 --> 00:08:42,000
you can actually

00:08:37,440 --> 00:08:44,800
end up um having a very interesting

00:08:42,000 --> 00:08:46,399
server-side combination of um of

00:08:44,800 --> 00:08:48,240
primitives

00:08:46,399 --> 00:08:50,399
the bogina distributed message-based

00:08:48,240 --> 00:08:52,080
system is the first circle of hell i can

00:08:50,399 --> 00:08:54,240
tell you because the picture on the

00:08:52,080 --> 00:08:57,200
right is the picture of me after

00:08:54,240 --> 00:08:58,320
solving a book for like about 12 hours

00:08:57,200 --> 00:09:01,200
in a row

00:08:58,320 --> 00:09:02,800
so we all know how hard could be to

00:09:01,200 --> 00:09:03,839
follow the flow of a javascript

00:09:02,800 --> 00:09:05,760
application

00:09:03,839 --> 00:09:07,519
using promises or using callbacks or

00:09:05,760 --> 00:09:08,959
using async await i hope everybody is

00:09:07,519 --> 00:09:10,560
using a single weight

00:09:08,959 --> 00:09:12,160
it's just like there's no reason for

00:09:10,560 --> 00:09:13,200
anybody to go back to callbacks right

00:09:12,160 --> 00:09:14,880
now

00:09:13,200 --> 00:09:16,959
and if you are using promises you are

00:09:14,880 --> 00:09:19,680
using async await but because it's just

00:09:16,959 --> 00:09:22,560
a synthetic solar on top of promises

00:09:19,680 --> 00:09:23,839
if you are trying to follow the

00:09:22,560 --> 00:09:27,680
execution

00:09:23,839 --> 00:09:30,560
of a request across a number of

00:09:27,680 --> 00:09:32,399
services lambdas and cloud native

00:09:30,560 --> 00:09:34,000
services like api gateway

00:09:32,399 --> 00:09:35,760
good luck with that because you are

00:09:34,000 --> 00:09:39,360
going to need like a few hours

00:09:35,760 --> 00:09:42,320
of coming in and out so my advice

00:09:39,360 --> 00:09:43,839
is make your system as simple and as

00:09:42,320 --> 00:09:45,680
straightforward as possible

00:09:43,839 --> 00:09:47,120
i read this morning on linkedin a very

00:09:45,680 --> 00:09:50,320
interesting phrase which

00:09:47,120 --> 00:09:52,399
basically said architecture in software

00:09:50,320 --> 00:09:53,920
it's there to make your life easier

00:09:52,399 --> 00:09:55,920
everything else is just religion

00:09:53,920 --> 00:09:57,680
and that is something that should be a

00:09:55,920 --> 00:09:59,839
mantra in serverless

00:09:57,680 --> 00:10:00,720
especially working with javascript i

00:09:59,839 --> 00:10:03,519
love javascript

00:10:00,720 --> 00:10:04,160
it's you know like my go-to language for

00:10:03,519 --> 00:10:07,040
pretty much

00:10:04,160 --> 00:10:08,720
99 of the work i do nowadays but the

00:10:07,040 --> 00:10:12,079
reality is

00:10:08,720 --> 00:10:12,560
the javascript flow is somehow hard to

00:10:12,079 --> 00:10:14,160
follow

00:10:12,560 --> 00:10:16,240
because our brain is used to a

00:10:14,160 --> 00:10:18,720
procedural language but

00:10:16,240 --> 00:10:20,560
with javascript that that's not the case

00:10:18,720 --> 00:10:22,480
even though with async await you can

00:10:20,560 --> 00:10:23,839
make it look like but it's really not

00:10:22,480 --> 00:10:25,040
there you need to have things into

00:10:23,839 --> 00:10:27,200
consideration

00:10:25,040 --> 00:10:28,160
but imagine combining that with a very

00:10:27,200 --> 00:10:31,760
complex flow

00:10:28,160 --> 00:10:33,600
of a very complex flow

00:10:31,760 --> 00:10:35,279
of servers passing requests to other

00:10:33,600 --> 00:10:36,240
servers or lambdas passing requests to

00:10:35,279 --> 00:10:40,000
the landers

00:10:36,240 --> 00:10:41,360
it can get really really problematic

00:10:40,000 --> 00:10:44,079
and this is the continuation of the

00:10:41,360 --> 00:10:45,760
three dots and lambdas are bad

00:10:44,079 --> 00:10:47,440
in the majority of the cases but there

00:10:45,760 --> 00:10:51,040
are other

00:10:47,440 --> 00:10:52,959
times where lambdas are their perfect

00:10:51,040 --> 00:10:54,399
er like they find their perfect fit for

00:10:52,959 --> 00:10:56,880
example for an

00:10:54,399 --> 00:10:58,160
asynctask runner let's imagine you don't

00:10:56,880 --> 00:10:59,519
need to imagine i will show you the code

00:10:58,160 --> 00:11:02,160
of that in a second

00:10:59,519 --> 00:11:04,079
is that you have a lambda which needs to

00:11:02,160 --> 00:11:06,079
run every night to send statistics to

00:11:04,079 --> 00:11:07,360
the central statistic office or to

00:11:06,079 --> 00:11:09,120
recalculate

00:11:07,360 --> 00:11:10,880
how many people have been exposed to

00:11:09,120 --> 00:11:13,200
copied or things like that

00:11:10,880 --> 00:11:14,000
and so lambdas are the perfect place for

00:11:13,200 --> 00:11:15,120
that because

00:11:14,000 --> 00:11:17,440
you can delegate into your

00:11:15,120 --> 00:11:19,360
infrastructure the running of lambda

00:11:17,440 --> 00:11:20,800
and that makes your life so much easier

00:11:19,360 --> 00:11:22,640
because you don't need to worry about

00:11:20,800 --> 00:11:24,079
the application being up at the time

00:11:22,640 --> 00:11:25,920
you don't need to worry about retries

00:11:24,079 --> 00:11:28,560
mechanism and things like that so

00:11:25,920 --> 00:11:31,680
it's just convenient they're also the

00:11:28,560 --> 00:11:34,000
perfect jwt validator in the api gateway

00:11:31,680 --> 00:11:36,160
so one of the reasons of the api gateway

00:11:34,000 --> 00:11:38,000
to be alive or to be in the architecture

00:11:36,160 --> 00:11:38,959
of pretty much every microservices

00:11:38,000 --> 00:11:42,160
system

00:11:38,959 --> 00:11:43,600
is that you

00:11:42,160 --> 00:11:46,079
probably are using distributed

00:11:43,600 --> 00:11:48,320
authentication with jwt

00:11:46,079 --> 00:11:49,440
and you really want to do that at that

00:11:48,320 --> 00:11:51,760
validation and number

00:11:49,440 --> 00:11:53,440
verification at the edge because

00:11:51,760 --> 00:11:56,320
otherwise

00:11:53,440 --> 00:11:58,160
you need to do that in every service and

00:11:56,320 --> 00:12:00,079
can get very problematic

00:11:58,160 --> 00:12:02,079
so one of the things that we did as a

00:12:00,079 --> 00:12:03,839
design principle is every single request

00:12:02,079 --> 00:12:06,480
that needs to be authenticated

00:12:03,839 --> 00:12:07,760
will be authenticated in the api gateway

00:12:06,480 --> 00:12:10,560
calling

00:12:07,760 --> 00:12:12,480
a nodejs lambda which was validating the

00:12:10,560 --> 00:12:14,160
gwd token

00:12:12,480 --> 00:12:16,480
then once the token is validated you can

00:12:14,160 --> 00:12:19,440
pass the request into the

00:12:16,480 --> 00:12:20,079
required server with the confidence that

00:12:19,440 --> 00:12:22,720
the token

00:12:20,079 --> 00:12:24,000
is validated and the person or the phone

00:12:22,720 --> 00:12:26,160
or the

00:12:24,000 --> 00:12:27,120
system who is calling the system the the

00:12:26,160 --> 00:12:28,959
server

00:12:27,120 --> 00:12:30,320
actually is alleged one and it has been

00:12:28,959 --> 00:12:32,000
validated

00:12:30,320 --> 00:12:33,920
another very good point on lambdas is

00:12:32,000 --> 00:12:34,560
that the scalability is just out of this

00:12:33,920 --> 00:12:37,040
world

00:12:34,560 --> 00:12:39,279
and you can easily choke other services

00:12:37,040 --> 00:12:43,200
i'm going to give you here

00:12:39,279 --> 00:12:46,639
very interesting um very interesting

00:12:43,200 --> 00:12:49,360
situation where we

00:12:46,639 --> 00:12:50,959
needed the secret for the jwt validation

00:12:49,360 --> 00:12:52,480
and what happened was that

00:12:50,959 --> 00:12:54,079
that secret was a story in the secrets

00:12:52,480 --> 00:12:57,120
manager so

00:12:54,079 --> 00:13:00,000
on peaks in ireland and in other tenants

00:12:57,120 --> 00:13:01,360
um we actually had over 4 000 requests

00:13:00,000 --> 00:13:04,399
per second

00:13:01,360 --> 00:13:06,880
into the secrets manager

00:13:04,399 --> 00:13:09,040
and if i recall correctly the maximum

00:13:06,880 --> 00:13:12,880
hard limit of secrets manager

00:13:09,040 --> 00:13:15,600
per account per second was set to 2000

00:13:12,880 --> 00:13:17,360
or 4000 i don't actually remember but it

00:13:15,600 --> 00:13:18,800
was like all number of requests were

00:13:17,360 --> 00:13:20,959
over that on peaks

00:13:18,800 --> 00:13:23,200
and we found out because we were getting

00:13:20,959 --> 00:13:26,720
some errors that we couldn't explain

00:13:23,200 --> 00:13:28,959
until we moved the secret

00:13:26,720 --> 00:13:30,079
from the secrets manager into an

00:13:28,959 --> 00:13:33,279
environment variable

00:13:30,079 --> 00:13:35,120
in the in the jwt validator lambda

00:13:33,279 --> 00:13:36,880
i know it's not the perfect solution but

00:13:35,120 --> 00:13:38,399
we had to make a compromise in there in

00:13:36,880 --> 00:13:41,440
order to make sure that

00:13:38,399 --> 00:13:41,920
first we we will kill the secret span a

00:13:41,440 --> 00:13:43,839
year

00:13:41,920 --> 00:13:45,519
and second we will save like a

00:13:43,839 --> 00:13:48,800
significant amount of money

00:13:45,519 --> 00:13:52,079
on cars into the secrets manager

00:13:48,800 --> 00:13:52,880
lambdas are also very very very very

00:13:52,079 --> 00:13:55,519
cheap

00:13:52,880 --> 00:13:56,240
unless they spy a lot of contour like if

00:13:55,519 --> 00:13:59,760
you don't have

00:13:56,240 --> 00:14:00,399
a good mechanism to um to check lambdas

00:13:59,760 --> 00:14:02,720
and to

00:14:00,399 --> 00:14:05,440
you know keep them at at bay you can end

00:14:02,720 --> 00:14:08,079
up with a serious hefty build from aws

00:14:05,440 --> 00:14:09,760
or from any other club provider but if

00:14:08,079 --> 00:14:12,160
you have them under control

00:14:09,760 --> 00:14:13,360
you will be paying less than 100 euros

00:14:12,160 --> 00:14:16,399
per month

00:14:13,360 --> 00:14:19,680
to run a significant amount of code

00:14:16,399 --> 00:14:22,639
and workloads that will help you to

00:14:19,680 --> 00:14:24,480
actually deliver your system with a very

00:14:22,639 --> 00:14:26,480
high level of stability

00:14:24,480 --> 00:14:27,920
and then latency like many people will

00:14:26,480 --> 00:14:30,320
come to me saying oh but you know

00:14:27,920 --> 00:14:31,199
lambda's introduced latency i will tell

00:14:30,320 --> 00:14:33,760
them latency

00:14:31,199 --> 00:14:35,839
what latency like you can work around

00:14:33,760 --> 00:14:36,800
that you can actually build your node.js

00:14:35,839 --> 00:14:39,839
lambda

00:14:36,800 --> 00:14:42,480
and using midi or any other middleware

00:14:39,839 --> 00:14:42,480
and then

00:14:42,959 --> 00:14:47,680
your call start will be sub second and

00:14:45,760 --> 00:14:49,519
every subsequent call

00:14:47,680 --> 00:14:51,120
will actually be immediate there is not

00:14:49,519 --> 00:14:53,760
going to be call runes

00:14:51,120 --> 00:14:54,639
anymore um and the lambda will scale up

00:14:53,760 --> 00:14:58,160
or down

00:14:54,639 --> 00:15:00,079
depending on load and basically um that

00:14:58,160 --> 00:15:01,920
latency is i think on the on the past

00:15:00,079 --> 00:15:03,519
of course there are some situations

00:15:01,920 --> 00:15:07,519
where your

00:15:03,519 --> 00:15:09,600
um like landa would play against you

00:15:07,519 --> 00:15:10,720
but the reality is that it's actually

00:15:09,600 --> 00:15:13,199
has gotten good

00:15:10,720 --> 00:15:15,279
um and it doesn't worry me anymore they

00:15:13,199 --> 00:15:17,760
call start or similar so

00:15:15,279 --> 00:15:19,040
it's it's very fast one of the patterns

00:15:17,760 --> 00:15:21,440
that we heavily use

00:15:19,040 --> 00:15:23,519
in the copied applications was we had or

00:15:21,440 --> 00:15:25,920
what we call our exposures lambda

00:15:23,519 --> 00:15:27,040
which was annotated lambda which was

00:15:25,920 --> 00:15:30,079
actually getting

00:15:27,040 --> 00:15:33,120
the list of all the random ideas that

00:15:30,079 --> 00:15:36,240
got exposed into like like

00:15:33,120 --> 00:15:37,920
they got tested got a positive and

00:15:36,240 --> 00:15:40,959
positive result as you are infected by

00:15:37,920 --> 00:15:42,480
copy then that person gets an sms from

00:15:40,959 --> 00:15:44,880
the health provider

00:15:42,480 --> 00:15:46,000
and then you bloat the random id into

00:15:44,880 --> 00:15:48,320
the server

00:15:46,000 --> 00:15:50,639
and then all the phones in the tenant

00:15:48,320 --> 00:15:53,680
download the file with the random id so

00:15:50,639 --> 00:15:56,160
there is no way to track who is um

00:15:53,680 --> 00:15:57,279
who is actually the person who got

00:15:56,160 --> 00:15:59,199
infected but

00:15:57,279 --> 00:16:01,279
your phone will download the full list

00:15:59,199 --> 00:16:02,720
of people and then match your close

00:16:01,279 --> 00:16:04,880
contacts with the people

00:16:02,720 --> 00:16:06,320
on well with the random ideas on that

00:16:04,880 --> 00:16:08,000
list and if there is a match it will

00:16:06,320 --> 00:16:10,079
send you a notification saying

00:16:08,000 --> 00:16:11,040
hey you've been exposed to somebody with

00:16:10,079 --> 00:16:14,160
um

00:16:11,040 --> 00:16:16,639
with copied please go and get tested

00:16:14,160 --> 00:16:17,519
in order to serve these files what we

00:16:16,639 --> 00:16:20,639
usually do

00:16:17,519 --> 00:16:23,199
is we pre-calculate them in lambdas like

00:16:20,639 --> 00:16:25,440
that's an async task every five minutes

00:16:23,199 --> 00:16:26,240
the lambda files off and then creates a

00:16:25,440 --> 00:16:29,680
file with

00:16:26,240 --> 00:16:31,279
the last um people exposed

00:16:29,680 --> 00:16:33,600
with the last random ids exposed from

00:16:31,279 --> 00:16:36,720
the database and then we serve them

00:16:33,600 --> 00:16:38,720
from the api gateway straight

00:16:36,720 --> 00:16:40,399
from s3 so that means when your phone

00:16:38,720 --> 00:16:42,480
which is the majority of the cards that

00:16:40,399 --> 00:16:45,199
we do back into the servers

00:16:42,480 --> 00:16:46,880
is asking for give me the list of people

00:16:45,199 --> 00:16:50,160
who

00:16:46,880 --> 00:16:51,519
the list of devices who have been tested

00:16:50,160 --> 00:16:53,759
positive

00:16:51,519 --> 00:16:55,920
and we sell that straight from s3 and

00:16:53,759 --> 00:16:59,199
literally words from aws

00:16:55,920 --> 00:17:00,399
s3 has billions of concurrent requests

00:16:59,199 --> 00:17:02,720
available for you

00:17:00,399 --> 00:17:04,240
so you won't be able to exhaust the

00:17:02,720 --> 00:17:05,679
bandwidth of s3

00:17:04,240 --> 00:17:07,679
and that's what they call a winner

00:17:05,679 --> 00:17:09,839
winner chicken dinner because

00:17:07,679 --> 00:17:11,280
out of like 20 30 or 40 millions of

00:17:09,839 --> 00:17:14,319
requests a day

00:17:11,280 --> 00:17:14,880
about 15 million something like that

00:17:14,319 --> 00:17:17,520
will be

00:17:14,880 --> 00:17:18,000
phones looking for the list of the

00:17:17,520 --> 00:17:20,799
exposed

00:17:18,000 --> 00:17:21,600
devices and that's it's all managed by

00:17:20,799 --> 00:17:23,520
aws

00:17:21,600 --> 00:17:25,199
we don't even execute any code ourselves

00:17:23,520 --> 00:17:27,600
it's just api gateway

00:17:25,199 --> 00:17:28,880
s3 well the only code we execute is the

00:17:27,600 --> 00:17:31,520
gwt validator

00:17:28,880 --> 00:17:33,200
which is a very small nodejs lambda but

00:17:31,520 --> 00:17:33,919
everything else is just a straight serve

00:17:33,200 --> 00:17:37,679
from

00:17:33,919 --> 00:17:41,039
an s3 how does it look like

00:17:37,679 --> 00:17:43,200
so we have this as

00:17:41,039 --> 00:17:46,240
open source so i will show you the code

00:17:43,200 --> 00:17:48,640
and the repositories in a second

00:17:46,240 --> 00:17:49,679
what we do is we keep the philosophy of

00:17:48,640 --> 00:17:52,960
we'll build

00:17:49,679 --> 00:17:53,679
one instance and deploy it everywhere

00:17:52,960 --> 00:17:55,280
approach

00:17:53,679 --> 00:17:57,120
most of the time okay we have some

00:17:55,280 --> 00:17:59,280
tenants which um

00:17:57,120 --> 00:18:01,280
have some special requirements and also

00:17:59,280 --> 00:18:03,760
thanks telephone for being aguard

00:18:01,280 --> 00:18:05,200
so terraform is amazing but there are

00:18:03,760 --> 00:18:07,919
some corners where

00:18:05,200 --> 00:18:08,480
a terraform plays against you so the

00:18:07,919 --> 00:18:11,600
fact

00:18:08,480 --> 00:18:14,400
that if you want to do an if else if

00:18:11,600 --> 00:18:15,679
something create this resource otherwise

00:18:14,400 --> 00:18:18,080
don't create it

00:18:15,679 --> 00:18:18,880
converts a simple resource into an array

00:18:18,080 --> 00:18:21,440
of resources

00:18:18,880 --> 00:18:22,240
it's just mind-blowing and the fact that

00:18:21,440 --> 00:18:25,600
there is not

00:18:22,240 --> 00:18:26,640
an easy way to just include or remove

00:18:25,600 --> 00:18:29,039
modules

00:18:26,640 --> 00:18:30,400
until tera from 013 it's another

00:18:29,039 --> 00:18:32,720
interesting fact

00:18:30,400 --> 00:18:34,000
but um all in all terraform is it's a

00:18:32,720 --> 00:18:37,679
powerful ally

00:18:34,000 --> 00:18:40,880
so just um be careful with some corners

00:18:37,679 --> 00:18:42,080
the way we build it is we build the gold

00:18:40,880 --> 00:18:44,720
standard which is the

00:18:42,080 --> 00:18:45,280
copy green infrastructure repository and

00:18:44,720 --> 00:18:48,080
then

00:18:45,280 --> 00:18:49,919
we use that as a module in every single

00:18:48,080 --> 00:18:50,960
tenant injecting the configuration that

00:18:49,919 --> 00:18:54,080
we want

00:18:50,960 --> 00:18:57,039
plus some customization that we need um

00:18:54,080 --> 00:18:58,320
for each tenant so that way we can

00:18:57,039 --> 00:18:59,919
actually release a new version of

00:18:58,320 --> 00:19:01,760
covering grid copy green

00:18:59,919 --> 00:19:04,160
and then used by every single tenant and

00:19:01,760 --> 00:19:05,039
roll it out to the nine tenants per two

00:19:04,160 --> 00:19:07,760
environments

00:19:05,039 --> 00:19:08,559
that means 18 environments pretty much

00:19:07,760 --> 00:19:12,799
immediately

00:19:08,559 --> 00:19:15,679
so we were very mindful to have

00:19:12,799 --> 00:19:16,880
a repeatable process and aside from that

00:19:15,679 --> 00:19:19,840
repeatable process

00:19:16,880 --> 00:19:20,160
we wanted it to be as simple as possible

00:19:19,840 --> 00:19:22,480
so

00:19:20,160 --> 00:19:23,200
complexity is the the evil number one on

00:19:22,480 --> 00:19:26,240
every system

00:19:23,200 --> 00:19:27,360
so if you want deploy with one click and

00:19:26,240 --> 00:19:30,400
draw back with one click

00:19:27,360 --> 00:19:30,799
you're almost safe from disaster so yeah

00:19:30,400 --> 00:19:32,960
that's

00:19:30,799 --> 00:19:34,799
that's your approach the applications

00:19:32,960 --> 00:19:38,000
themselves are react native

00:19:34,799 --> 00:19:41,200
so we at near form we breathe node.js

00:19:38,000 --> 00:19:42,640
inside out we i think we contribute to

00:19:41,200 --> 00:19:45,039
the code of nodejs

00:19:42,640 --> 00:19:47,120
something like 40 of the code it's

00:19:45,039 --> 00:19:49,520
people working in node.js

00:19:47,120 --> 00:19:51,280
and so it made sense to use react native

00:19:49,520 --> 00:19:54,240
because like

00:19:51,280 --> 00:19:55,679
we know javascript we like you know i

00:19:54,240 --> 00:19:58,799
say not js but

00:19:55,679 --> 00:20:02,000
the reality is it's just javascript and

00:19:58,799 --> 00:20:03,919
we know react very well so

00:20:02,000 --> 00:20:05,200
having the application done in vr native

00:20:03,919 --> 00:20:08,080
is you know

00:20:05,200 --> 00:20:09,760
the obvious choice and also the copy

00:20:08,080 --> 00:20:10,880
green initiative is a linux foundation

00:20:09,760 --> 00:20:14,000
public health project

00:20:10,880 --> 00:20:15,360
so that means that we are part well

00:20:14,000 --> 00:20:17,679
the project is part of the linux

00:20:15,360 --> 00:20:19,600
foundation and

00:20:17,679 --> 00:20:21,440
what i'm gonna do now is and go i'm

00:20:19,600 --> 00:20:23,120
going to go and show you the codes

00:20:21,440 --> 00:20:25,440
and i'm not going to show you the code

00:20:23,120 --> 00:20:27,919
as of a demo or something like that

00:20:25,440 --> 00:20:28,559
but i'm going to show you that in github

00:20:27,919 --> 00:20:30,960
if you go

00:20:28,559 --> 00:20:32,000
into copied green you will see a number

00:20:30,960 --> 00:20:35,520
of repositories

00:20:32,000 --> 00:20:37,120
so we have in general the top one

00:20:35,520 --> 00:20:38,960
is the copied green infrastructure but

00:20:37,120 --> 00:20:41,520
not the top because it was

00:20:38,960 --> 00:20:42,640
used the most because it was the updated

00:20:41,520 --> 00:20:45,840
the latest

00:20:42,640 --> 00:20:48,480
and so it's where your infrastructure

00:20:45,840 --> 00:20:49,120
leaves in you can come in this is public

00:20:48,480 --> 00:20:51,200
by the way

00:20:49,120 --> 00:20:53,120
and there's no restrictions in this and

00:20:51,200 --> 00:20:54,720
you can see how this is being worked by

00:20:53,120 --> 00:20:56,640
column at the moment

00:20:54,720 --> 00:20:58,720
and this is where you have all the

00:20:56,640 --> 00:21:00,080
infrastructure we have built

00:20:58,720 --> 00:21:01,760
you also have some level of

00:21:00,080 --> 00:21:03,679
documentation which

00:21:01,760 --> 00:21:06,320
is not always super accurate but in

00:21:03,679 --> 00:21:08,799
general describes the system very well

00:21:06,320 --> 00:21:09,760
and allows you to pick around and see

00:21:08,799 --> 00:21:11,919
what we have built

00:21:09,760 --> 00:21:13,120
obviously it's not perfect but i'm of

00:21:11,919 --> 00:21:15,440
the opinion that perfect

00:21:13,120 --> 00:21:17,120
is the enemy of don so i preferred it to

00:21:15,440 --> 00:21:20,640
be working than you know

00:21:17,120 --> 00:21:22,320
being running around seeking perfection

00:21:20,640 --> 00:21:24,080
where there was a global pandemic and we

00:21:22,320 --> 00:21:27,200
needed this out very quickly

00:21:24,080 --> 00:21:30,640
and very efficiently

00:21:27,200 --> 00:21:31,440
if i can take one second of your

00:21:30,640 --> 00:21:33,039
attention

00:21:31,440 --> 00:21:34,559
i like to be very grateful to all the

00:21:33,039 --> 00:21:35,120
people contributing to this project

00:21:34,559 --> 00:21:37,360
because

00:21:35,120 --> 00:21:39,120
the team was amazing and it would not

00:21:37,360 --> 00:21:39,760
have been possible without any single of

00:21:39,120 --> 00:21:42,880
them

00:21:39,760 --> 00:21:44,720
so that's my cutout for them

00:21:42,880 --> 00:21:46,480
we also have other interesting

00:21:44,720 --> 00:21:47,440
repositories which is for example the

00:21:46,480 --> 00:21:50,240
back-end api

00:21:47,440 --> 00:21:50,720
so this back-end api is just the server

00:21:50,240 --> 00:21:53,840
side

00:21:50,720 --> 00:21:56,880
that we um we build

00:21:53,840 --> 00:21:58,559
in in near form for supporting the

00:21:56,880 --> 00:22:02,559
server-side loads

00:21:58,559 --> 00:22:03,600
in general well in general no it follows

00:22:02,559 --> 00:22:07,120
the standard

00:22:03,600 --> 00:22:11,760
um layouts that we have in earphone so

00:22:07,120 --> 00:22:14,640
we use fastify fastify allows us to have

00:22:11,760 --> 00:22:16,320
um plugins and then what we do is we

00:22:14,640 --> 00:22:20,000
configure our plugins

00:22:16,320 --> 00:22:22,320
and for postgre and

00:22:20,000 --> 00:22:23,919
verifying the devices like that's the

00:22:22,320 --> 00:22:27,440
device verification to prevent

00:22:23,919 --> 00:22:31,440
temporary devices some jwt code here

00:22:27,440 --> 00:22:35,760
but also allows us to inject the

00:22:31,440 --> 00:22:38,000
allows us to inject the the roots

00:22:35,760 --> 00:22:39,039
as plugins so whenever you go into a

00:22:38,000 --> 00:22:41,360
root

00:22:39,039 --> 00:22:42,400
for example metrics you will find three

00:22:41,360 --> 00:22:43,760
files well

00:22:42,400 --> 00:22:45,919
four files in this case including the

00:22:43,760 --> 00:22:49,039
test the first one is the index

00:22:45,919 --> 00:22:50,480
which is what is the handler and this is

00:22:49,039 --> 00:22:52,000
a facilify handler okay

00:22:50,480 --> 00:22:55,039
it's a fast effect handler which has

00:22:52,000 --> 00:22:56,960
become a plugin and then we do a schema

00:22:55,039 --> 00:22:59,760
validation this schema validation

00:22:56,960 --> 00:23:00,159
it's coming from a file called schema

00:22:59,760 --> 00:23:02,559
and this

00:23:00,159 --> 00:23:03,440
schema defines how should your request

00:23:02,559 --> 00:23:06,799
look like

00:23:03,440 --> 00:23:07,360
super important every time you accept

00:23:06,799 --> 00:23:10,799
data

00:23:07,360 --> 00:23:11,440
from your users always without any

00:23:10,799 --> 00:23:14,240
exception

00:23:11,440 --> 00:23:16,400
validated otherwise you might end up in

00:23:14,240 --> 00:23:19,280
a security

00:23:16,400 --> 00:23:20,400
in a security issue or creating a

00:23:19,280 --> 00:23:23,760
vulnerability which

00:23:20,400 --> 00:23:26,720
it's because of the lack of proper

00:23:23,760 --> 00:23:28,159
input validation which might end up in a

00:23:26,720 --> 00:23:30,720
command injection

00:23:28,159 --> 00:23:31,360
process scripting or you know god knows

00:23:30,720 --> 00:23:33,440
what so

00:23:31,360 --> 00:23:34,480
i'd be very careful with not validating

00:23:33,440 --> 00:23:37,200
data

00:23:34,480 --> 00:23:39,679
then we also have the query which is how

00:23:37,200 --> 00:23:41,760
do we fetch data from the database

00:23:39,679 --> 00:23:43,200
and this is you know like it's not even

00:23:41,760 --> 00:23:45,520
the fetch the data is just

00:23:43,200 --> 00:23:46,480
building the query we use a library

00:23:45,520 --> 00:23:49,200
called sql

00:23:46,480 --> 00:23:50,159
which we built in-house in your form

00:23:49,200 --> 00:23:51,919
which prevents

00:23:50,159 --> 00:23:53,279
sql injection by using prepared

00:23:51,919 --> 00:23:55,840
statement even look

00:23:53,279 --> 00:23:57,440
even though like even though looks like

00:23:55,840 --> 00:23:59,600
you have just concatenated the string

00:23:57,440 --> 00:24:02,080
the reality is this sql library

00:23:59,600 --> 00:24:03,679
will go take all these parameters and

00:24:02,080 --> 00:24:07,360
create a prepared statement with

00:24:03,679 --> 00:24:10,799
it so it's safe to actually um

00:24:07,360 --> 00:24:12,720
it's safe to actually use it this way

00:24:10,799 --> 00:24:14,320
i will actually recommend you to go and

00:24:12,720 --> 00:24:16,799
check it because it's

00:24:14,320 --> 00:24:18,320
it's one of those interesting ideas if

00:24:16,799 --> 00:24:20,240
you go to any other roots

00:24:18,320 --> 00:24:22,559
you will see always or pretty much

00:24:20,240 --> 00:24:26,159
always the same

00:24:22,559 --> 00:24:28,720
the same structure so index test test

00:24:26,159 --> 00:24:29,440
query schema and it's the same

00:24:28,720 --> 00:24:33,039
everywhere

00:24:29,440 --> 00:24:36,480
so index where schema and test

00:24:33,039 --> 00:24:39,279
so what does that mean that means that

00:24:36,480 --> 00:24:40,640
somebody jumping up on this application

00:24:39,279 --> 00:24:42,320
does not take long

00:24:40,640 --> 00:24:43,760
because basically you just need to copy

00:24:42,320 --> 00:24:45,679
and paste a route

00:24:43,760 --> 00:24:47,360
immediately what's there remove what he

00:24:45,679 --> 00:24:50,080
doesn't or she doesn't need

00:24:47,360 --> 00:24:50,640
and then start coding around so that

00:24:50,080 --> 00:24:53,840
becomes

00:24:50,640 --> 00:24:54,960
very helpful then the last repository i

00:24:53,840 --> 00:24:56,880
want to talk to you about

00:24:54,960 --> 00:24:58,880
is the lambdas as i said before

00:24:56,880 --> 00:25:02,559
orlando's are kind of like

00:24:58,880 --> 00:25:03,919
um created to support the main workload

00:25:02,559 --> 00:25:06,480
which is the api

00:25:03,919 --> 00:25:08,960
and if you remember i was talking about

00:25:06,480 --> 00:25:12,400
one lambda which was packing the

00:25:08,960 --> 00:25:14,000
the closed contacts into a file and then

00:25:12,400 --> 00:25:15,520
putting it putting it in an extra book

00:25:14,000 --> 00:25:19,520
that then would have been served

00:25:15,520 --> 00:25:21,120
into a customers via api gateway and s3

00:25:19,520 --> 00:25:23,120
so this is the lambda that does that is

00:25:21,120 --> 00:25:24,320
the exposures again it's all open source

00:25:23,120 --> 00:25:27,360
you can go there

00:25:24,320 --> 00:25:30,000
and check um check what

00:25:27,360 --> 00:25:30,480
you want but this will actually do that

00:25:30,000 --> 00:25:34,000
work

00:25:30,480 --> 00:25:36,400
and it will give us

00:25:34,000 --> 00:25:38,000
it will give us the required file which

00:25:36,400 --> 00:25:40,640
then will be served via the

00:25:38,000 --> 00:25:42,640
api gateway and the phones will get the

00:25:40,640 --> 00:25:44,240
data that they are looking for

00:25:42,640 --> 00:25:46,320
so that's the perfect usage for lambda

00:25:44,240 --> 00:25:47,200
then we use other patterns here like for

00:25:46,320 --> 00:25:49,440
example

00:25:47,200 --> 00:25:50,559
you don't see here an sms lambda because

00:25:49,440 --> 00:25:53,360
every single tenant

00:25:50,559 --> 00:25:54,240
is using a different sms provider so

00:25:53,360 --> 00:25:57,039
what we do

00:25:54,240 --> 00:25:59,120
is we send a sqs message which is

00:25:57,039 --> 00:26:02,000
basically a message into a queue

00:25:59,120 --> 00:26:05,520
and then the lambda is created per

00:26:02,000 --> 00:26:07,520
tenant so that means ireland will have

00:26:05,520 --> 00:26:09,120
one provider which i believe in this

00:26:07,520 --> 00:26:11,440
case might be twilio

00:26:09,120 --> 00:26:13,279
the uk regions will have other provider

00:26:11,440 --> 00:26:14,240
which is a property provider that they

00:26:13,279 --> 00:26:17,440
build for

00:26:14,240 --> 00:26:19,120
sms notifications and so on the reality

00:26:17,440 --> 00:26:20,159
is the message is the same for every

00:26:19,120 --> 00:26:22,320
single

00:26:20,159 --> 00:26:24,480
tenant but how you deliver that message

00:26:22,320 --> 00:26:27,440
it's different so that is the couple

00:26:24,480 --> 00:26:28,400
using a lambda and it's working very

00:26:27,440 --> 00:26:30,400
well

00:26:28,400 --> 00:26:31,679
all the automation to deploy this is

00:26:30,400 --> 00:26:33,600
done in two phases

00:26:31,679 --> 00:26:34,720
the first one is we deploy the

00:26:33,600 --> 00:26:36,960
infrastructure

00:26:34,720 --> 00:26:38,960
and we use github actions for that

00:26:36,960 --> 00:26:41,120
github actions is fantastic because it's

00:26:38,960 --> 00:26:44,400
very close to your code

00:26:41,120 --> 00:26:46,720
it only have one um

00:26:44,400 --> 00:26:48,240
one i will not call it issue but i will

00:26:46,720 --> 00:26:49,919
call shortcoming

00:26:48,240 --> 00:26:52,880
which is there is not a manual

00:26:49,919 --> 00:26:55,919
validation step in the middle between

00:26:52,880 --> 00:26:59,039
one job and another so that means

00:26:55,919 --> 00:27:01,520
if i want to do a plan on terraform

00:26:59,039 --> 00:27:02,640
and then and apply out of that plan it

00:27:01,520 --> 00:27:04,960
becomes very hard

00:27:02,640 --> 00:27:06,400
because i don't have this intermediary

00:27:04,960 --> 00:27:08,720
hold on step

00:27:06,400 --> 00:27:09,440
and then apply so what we've done

00:27:08,720 --> 00:27:13,200
otherwise

00:27:09,440 --> 00:27:14,559
is we have a a job which is planned and

00:27:13,200 --> 00:27:16,480
then we see the plan

00:27:14,559 --> 00:27:18,399
and then another job which will be plan

00:27:16,480 --> 00:27:20,320
and apply so that means

00:27:18,399 --> 00:27:22,080
you see the plan first and then create

00:27:20,320 --> 00:27:23,919
the plan again and apply

00:27:22,080 --> 00:27:25,279
which will apply the changes in the

00:27:23,919 --> 00:27:27,200
infrastructure

00:27:25,279 --> 00:27:29,679
we make a clear separation between

00:27:27,200 --> 00:27:31,840
infrastructure and code so that means

00:27:29,679 --> 00:27:32,960
we deployed the lambdas as part of the

00:27:31,840 --> 00:27:34,880
infrastructure

00:27:32,960 --> 00:27:36,159
you can see that here on every single

00:27:34,880 --> 00:27:38,159
lambda but

00:27:36,159 --> 00:27:39,679
if you go to for example the exposures

00:27:38,159 --> 00:27:40,880
lambda which is what we have already

00:27:39,679 --> 00:27:44,080
talked about

00:27:40,880 --> 00:27:47,840
what we deploy is a plates holder

00:27:44,080 --> 00:27:51,120
we don't deploy the final code why

00:27:47,840 --> 00:27:53,919
well for one simple reason um in

00:27:51,120 --> 00:27:55,039
this project we have separated the

00:27:53,919 --> 00:27:56,799
deployment and

00:27:55,039 --> 00:27:58,799
pretty much everybody who is involved in

00:27:56,799 --> 00:28:00,720
the project can do deployments

00:27:58,799 --> 00:28:03,039
um at any stage not that we are a big

00:28:00,720 --> 00:28:06,159
team we are like on the biggest

00:28:03,039 --> 00:28:08,559
moment we were like five people but we

00:28:06,159 --> 00:28:11,840
have a very high level of communication

00:28:08,559 --> 00:28:13,600
we also don't do deployments alone and

00:28:11,840 --> 00:28:15,120
that allows us to deploy the

00:28:13,600 --> 00:28:16,720
infrastructure and then deploy the

00:28:15,120 --> 00:28:17,919
lambdas without having to redeploy the

00:28:16,720 --> 00:28:20,080
infrastructure

00:28:17,919 --> 00:28:22,240
and same with the acs target so in that

00:28:20,080 --> 00:28:25,520
case the lambdas were deployed with

00:28:22,240 --> 00:28:27,120
a github actions pipeline

00:28:25,520 --> 00:28:29,120
whereas the infrastructure will be

00:28:27,120 --> 00:28:30,159
another pipeline so that way we we kind

00:28:29,120 --> 00:28:32,799
of segregate

00:28:30,159 --> 00:28:33,840
what the blast radio sees if something

00:28:32,799 --> 00:28:35,840
goes wrong

00:28:33,840 --> 00:28:37,520
and again some people will be like oh

00:28:35,840 --> 00:28:40,480
you should deploy lambdas with

00:28:37,520 --> 00:28:42,320
the terraform as well but it's yes you

00:28:40,480 --> 00:28:44,240
know we thought it was a good idea and

00:28:42,320 --> 00:28:46,159
we actually believe is still

00:28:44,240 --> 00:28:47,600
one of the best ideas that we we could

00:28:46,159 --> 00:28:59,600
have taken

00:28:47,600 --> 00:29:01,840
so back into the presentation now

00:28:59,600 --> 00:29:03,120
so we have learned a few lessons along

00:29:01,840 --> 00:29:06,159
the way the first one

00:29:03,120 --> 00:29:07,520
is the terraform ecosystem is a mess if

00:29:06,159 --> 00:29:09,360
you are using telephone third-party

00:29:07,520 --> 00:29:11,200
modules territorial investment is not

00:29:09,360 --> 00:29:13,520
massive but you are getting yourself

00:29:11,200 --> 00:29:15,120
in a into a corner and and i have an

00:29:13,520 --> 00:29:18,559
example here which is

00:29:15,120 --> 00:29:21,440
lds there is one module that that um

00:29:18,559 --> 00:29:22,159
creates an rds cluster and basically

00:29:21,440 --> 00:29:25,600
what happened

00:29:22,159 --> 00:29:26,080
is at a given version that model was

00:29:25,600 --> 00:29:28,720
calling

00:29:26,080 --> 00:29:29,679
the cluster default and then one version

00:29:28,720 --> 00:29:32,080
later

00:29:29,679 --> 00:29:33,919
the cluster was called primary and

00:29:32,080 --> 00:29:36,960
secondary i i guess it's because

00:29:33,919 --> 00:29:39,039
some change on the way that rds deploys

00:29:36,960 --> 00:29:41,039
or similar but what does that mean that

00:29:39,039 --> 00:29:44,240
means that we have to recreate

00:29:41,039 --> 00:29:47,120
the we have to recreate the cluster or

00:29:44,240 --> 00:29:50,559
we have to actually move the state

00:29:47,120 --> 00:29:53,279
elements across and one by one

00:29:50,559 --> 00:29:56,000
for nine tenants by two environments

00:29:53,279 --> 00:29:59,120
pertaining so that means 18 talents

00:29:56,000 --> 00:30:01,440
very stressful and not very desired

00:29:59,120 --> 00:30:02,960
and thing to do so the only solution we

00:30:01,440 --> 00:30:04,240
have there well not the only but the

00:30:02,960 --> 00:30:07,200
most

00:30:04,240 --> 00:30:08,000
it's a same solution was to fork the rds

00:30:07,200 --> 00:30:11,120
module

00:30:08,000 --> 00:30:12,559
and patch it to keep the nomenclature so

00:30:11,120 --> 00:30:15,120
it's a bit unfortunate

00:30:12,559 --> 00:30:16,640
the same way that i would not recommend

00:30:15,120 --> 00:30:19,840
anybody to create a

00:30:16,640 --> 00:30:20,640
node.js api without using fastify or

00:30:19,840 --> 00:30:23,279
happy

00:30:20,640 --> 00:30:24,080
or any other http library because it

00:30:23,279 --> 00:30:26,399
will be

00:30:24,080 --> 00:30:27,919
a nonsense i would actually recommend

00:30:26,399 --> 00:30:29,760
and encourage everybody to

00:30:27,919 --> 00:30:30,960
write your infrastructure interactive

00:30:29,760 --> 00:30:33,279
without using

00:30:30,960 --> 00:30:35,200
third party modules unless it's very

00:30:33,279 --> 00:30:38,399
clear that the party module

00:30:35,200 --> 00:30:40,640
serves one purpose and it doesn't go

00:30:38,399 --> 00:30:41,760
into the wild because it can get you

00:30:40,640 --> 00:30:45,279
into a really

00:30:41,760 --> 00:30:47,360
really bad corner and missing the async

00:30:45,279 --> 00:30:49,360
in one of the first 500s can destroy the

00:30:47,360 --> 00:30:51,919
throughput in your cloud native system

00:30:49,360 --> 00:30:52,880
so at some point we had containers

00:30:51,919 --> 00:30:56,159
starting

00:30:52,880 --> 00:30:58,960
turns out it was we missed the async

00:30:56,159 --> 00:31:00,799
in one of the festival handlers and what

00:30:58,960 --> 00:31:02,559
happened was that

00:31:00,799 --> 00:31:04,799
of course when you throw an error

00:31:02,559 --> 00:31:07,840
instead of resolving into a promise

00:31:04,799 --> 00:31:10,080
it will actually throw an error and kill

00:31:07,840 --> 00:31:11,519
your javascript application kill your

00:31:10,080 --> 00:31:13,840
node.js application

00:31:11,519 --> 00:31:14,799
so the container has to restart and that

00:31:13,840 --> 00:31:17,679
happens very often

00:31:14,799 --> 00:31:19,120
your throughput goes into the floor so

00:31:17,679 --> 00:31:20,640
be very careful with that

00:31:19,120 --> 00:31:23,360
and i wish there was an easy way to

00:31:20,640 --> 00:31:24,880
detect non-asynch handlers and issue a

00:31:23,360 --> 00:31:26,640
warning or something like that

00:31:24,880 --> 00:31:29,039
but it's something i haven't think too

00:31:26,640 --> 00:31:30,720
much yet on that

00:31:29,039 --> 00:31:32,799
monitoring is harder than you think

00:31:30,720 --> 00:31:34,640
there is a sweet spot between the houses

00:31:32,799 --> 00:31:37,279
on fire but nobody cares because you

00:31:34,640 --> 00:31:39,440
have one alert every 20 seconds

00:31:37,279 --> 00:31:40,720
um well because you don't have alerts

00:31:39,440 --> 00:31:42,000
basically and

00:31:40,720 --> 00:31:44,159
can you stop alerting me on every

00:31:42,000 --> 00:31:45,039
request twice because you have too many

00:31:44,159 --> 00:31:47,279
alerts

00:31:45,039 --> 00:31:48,799
and it's incredibly narrow that space

00:31:47,279 --> 00:31:51,360
like where you're alerting

00:31:48,799 --> 00:31:52,720
is perfect it's almost a non-existent

00:31:51,360 --> 00:31:54,159
state it's like you know

00:31:52,720 --> 00:31:56,559
when you do yoga or something like that

00:31:54,159 --> 00:31:59,600
this purity and clarity of mind

00:31:56,559 --> 00:32:01,519
it's it's it's not about the destination

00:31:59,600 --> 00:32:02,960
it's about the trip so this is the same

00:32:01,519 --> 00:32:06,000
monitoring is not a

00:32:02,960 --> 00:32:09,360
build it once forgets and

00:32:06,000 --> 00:32:10,799
um it will always work because it won't

00:32:09,360 --> 00:32:13,519
you should always have two monitoring

00:32:10,799 --> 00:32:17,600
levels infrastructure and app monitoring

00:32:13,519 --> 00:32:18,320
so for example what happens if your node

00:32:17,600 --> 00:32:20,240
event loop

00:32:18,320 --> 00:32:23,039
starts having delays you won't catch

00:32:20,240 --> 00:32:25,360
that with the infrastructure monitoring

00:32:23,039 --> 00:32:26,640
but if your database is down your

00:32:25,360 --> 00:32:28,159
application is going to fail

00:32:26,640 --> 00:32:29,840
but you probably will need to monitor

00:32:28,159 --> 00:32:32,399
that on the infrastructure

00:32:29,840 --> 00:32:34,320
so we are very heavy on infrastructure

00:32:32,399 --> 00:32:37,039
monitoring here

00:32:34,320 --> 00:32:38,080
and very light on our monitoring but we

00:32:37,039 --> 00:32:40,240
absolutely

00:32:38,080 --> 00:32:43,200
capture every single lock line for at

00:32:40,240 --> 00:32:46,320
least 30 days for every single

00:32:43,200 --> 00:32:48,240
line of code executed in our system so

00:32:46,320 --> 00:32:50,000
if something is wrong

00:32:48,240 --> 00:32:52,399
we can catch it very quickly and we can

00:32:50,000 --> 00:32:54,320
actually act very quickly so

00:32:52,399 --> 00:32:56,080
the other day i actually amazed myself

00:32:54,320 --> 00:32:58,000
because i managed to go from

00:32:56,080 --> 00:32:59,600
i am looking into something else and

00:32:58,000 --> 00:33:01,279
into all this one alert

00:32:59,600 --> 00:33:02,640
let me look into that in about 15

00:33:01,279 --> 00:33:04,880
seconds because

00:33:02,640 --> 00:33:06,240
we've gotten so good with cloud watch

00:33:04,880 --> 00:33:07,200
that it gets up to a point where it's

00:33:06,240 --> 00:33:10,000
almost like

00:33:07,200 --> 00:33:11,360
an extension of your hands so yeah

00:33:10,000 --> 00:33:14,559
that's one of the

00:33:11,360 --> 00:33:15,919
recommendations i have vertical slices

00:33:14,559 --> 00:33:17,200
of the systems are better than big

00:33:15,919 --> 00:33:19,519
systems so that

00:33:17,200 --> 00:33:21,120
is on the domain of system design should

00:33:19,519 --> 00:33:22,960
you be sharding your system should you

00:33:21,120 --> 00:33:25,679
be crucial in your system

00:33:22,960 --> 00:33:26,559
my advice is if you can slice them

00:33:25,679 --> 00:33:29,440
vertically

00:33:26,559 --> 00:33:30,480
in countries or in regions or in user

00:33:29,440 --> 00:33:31,840
groups

00:33:30,480 --> 00:33:34,399
it's going to make your life a lot

00:33:31,840 --> 00:33:35,519
easier and if i tell you we are

00:33:34,399 --> 00:33:37,919
processing

00:33:35,519 --> 00:33:40,480
85 millions of requests a day you will

00:33:37,919 --> 00:33:42,720
be like oh my god that's a lot

00:33:40,480 --> 00:33:44,080
but well actually it's more than 85 it's

00:33:42,720 --> 00:33:47,840
like a few hundred but

00:33:44,080 --> 00:33:50,799
yeah um if i tell you we are processing

00:33:47,840 --> 00:33:52,000
5 millions of requests a day 80 times

00:33:50,799 --> 00:33:54,080
it's not super impressive

00:33:52,000 --> 00:33:56,559
because 5 millions of requests a day is

00:33:54,080 --> 00:34:00,399
pretty much manageable with two servers

00:33:56,559 --> 00:34:02,720
so that is something that i'm grateful

00:34:00,399 --> 00:34:05,200
the approach wasn't global because

00:34:02,720 --> 00:34:08,159
otherwise having to manage a big system

00:34:05,200 --> 00:34:09,760
it it's actually much harder than

00:34:08,159 --> 00:34:10,800
managing a smaller system especially if

00:34:09,760 --> 00:34:12,879
you are using

00:34:10,800 --> 00:34:15,119
infrastructure as code and repeatable

00:34:12,879 --> 00:34:18,079
infrastructure which is yes

00:34:15,119 --> 00:34:19,280
the overhead is minimal so yeah i would

00:34:18,079 --> 00:34:21,520
recommend you to

00:34:19,280 --> 00:34:22,960
slide your system vertically and be the

00:34:21,520 --> 00:34:25,040
master of your trade and apprentice of

00:34:22,960 --> 00:34:27,200
the rest of them that's devops so you

00:34:25,040 --> 00:34:28,720
you need to focus in one area like me

00:34:27,200 --> 00:34:30,720
for example infrastructure

00:34:28,720 --> 00:34:33,200
but also be able to read and understand

00:34:30,720 --> 00:34:36,879
node.js and sometimes write it

00:34:33,200 --> 00:34:38,800
and because basically like

00:34:36,879 --> 00:34:40,960
you cannot isolate yourself if you want

00:34:38,800 --> 00:34:42,800
your team to succeed

00:34:40,960 --> 00:34:44,000
and that's about it thank you very much

00:34:42,800 --> 00:34:47,359
this is my email

00:34:44,000 --> 00:34:48,000
that's my twitter handle um my linkedin

00:34:47,359 --> 00:34:51,040
is there of course

00:34:48,000 --> 00:34:53,119
feel free to connect with me and like

00:34:51,040 --> 00:34:54,480
as this is being recorded i am not sure

00:34:53,119 --> 00:34:56,240
if there's gonna be questions but if

00:34:54,480 --> 00:34:58,240
there are you have any questions

00:34:56,240 --> 00:35:00,480
feel absolutely free to contact me over

00:34:58,240 --> 00:35:01,599
email twitter or linkedin and i'd be

00:35:00,480 --> 00:35:03,839
more than happy

00:35:01,599 --> 00:35:04,800
to answer all of them thank you very

00:35:03,839 --> 00:35:08,720
much

00:35:04,800 --> 00:35:08,720

YouTube URL: https://www.youtube.com/watch?v=X89gW0_Gu9M


