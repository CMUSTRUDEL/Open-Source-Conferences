Title: Lightning Talk: Event Based Communication in Complex Micro-service... - Sapna Upreti & Prabal Raghav
Publication date: 2021-05-28
Playlist: OpenJS World 2021
Description: 
	The fire and forget communication approach for complex micro service architecture. Event based communication solves a lot of asynchronous issues that the architecture has and it makes application very loosely coupled. Often ignored because of the high complexity of implementation.
Captions: 
	00:00:00,960 --> 00:00:04,480
hello everyone welcome to openjs world

00:00:03,439 --> 00:00:06,480
00:00:04,480 --> 00:00:07,839
hope you are doing well let's do the

00:00:06,480 --> 00:00:09,679
basic introduction of

00:00:07,839 --> 00:00:11,120
us before we tell you why we need 10

00:00:09,679 --> 00:00:13,280
minutes of your time

00:00:11,120 --> 00:00:15,120
so hi this is sabna and i'm the

00:00:13,280 --> 00:00:17,119
technical head at node expert

00:00:15,120 --> 00:00:20,400
and i have rubble raghav with me who is

00:00:17,119 --> 00:00:22,240
a technical lead at node expert

00:00:20,400 --> 00:00:23,760
so uh the topic that we are going to

00:00:22,240 --> 00:00:25,359
present today is event based

00:00:23,760 --> 00:00:26,320
communication in microservice

00:00:25,359 --> 00:00:29,519
architecture

00:00:26,320 --> 00:00:31,279
so microservices so they have a lot of

00:00:29,519 --> 00:00:33,360
different architecture pattern every

00:00:31,279 --> 00:00:35,680
micro service has their own architecture

00:00:33,360 --> 00:00:37,600
pattern customized to the requirement

00:00:35,680 --> 00:00:39,280
we would like to take this opportunity

00:00:37,600 --> 00:00:41,760
to talk about our journey

00:00:39,280 --> 00:00:43,680
journey from monolith to microservice

00:00:41,760 --> 00:00:46,640
architecture application that use

00:00:43,680 --> 00:00:48,399
event for ipc we would be taking an

00:00:46,640 --> 00:00:50,719
example with a

00:00:48,399 --> 00:00:52,960
similar use case as we face in our live

00:00:50,719 --> 00:00:56,079
project so what better example

00:00:52,960 --> 00:00:58,399
than a retail industry so um

00:00:56,079 --> 00:01:00,079
let's talk about an application that

00:00:58,399 --> 00:01:03,920
lets you order things

00:01:00,079 --> 00:01:06,479
pay for it online deliver it on address

00:01:03,920 --> 00:01:07,520
so to start with we have monolithic

00:01:06,479 --> 00:01:09,600
architecture

00:01:07,520 --> 00:01:11,920
so in a in a monolithic architecture

00:01:09,600 --> 00:01:13,439
there is just a single service or server

00:01:11,920 --> 00:01:16,880
on which all the model

00:01:13,439 --> 00:01:19,920
business logic read and write operations

00:01:16,880 --> 00:01:20,799
happen so you may have multiple instance

00:01:19,920 --> 00:01:23,200
of

00:01:20,799 --> 00:01:23,840
same server running on load balancing

00:01:23,200 --> 00:01:26,880
income

00:01:23,840 --> 00:01:27,119
in the form of horizontal scaling but it

00:01:26,880 --> 00:01:29,920
is

00:01:27,119 --> 00:01:31,280
still on single server this architecture

00:01:29,920 --> 00:01:34,079
might be suitable for

00:01:31,280 --> 00:01:35,360
smaller and simpler application but not

00:01:34,079 --> 00:01:38,000
for

00:01:35,360 --> 00:01:40,400
large enterprise grade application it

00:01:38,000 --> 00:01:41,040
will runs into tons of problem let's see

00:01:40,400 --> 00:01:43,040
how

00:01:41,040 --> 00:01:44,880
but before that let's see how ordering

00:01:43,040 --> 00:01:45,680
something will look like in a monolithic

00:01:44,880 --> 00:01:49,439
world

00:01:45,680 --> 00:01:51,600
first we make sure payment is paid

00:01:49,439 --> 00:01:53,280
we place the order hence and after

00:01:51,600 --> 00:01:55,759
successfully placing the order

00:01:53,280 --> 00:01:56,640
we independently update the inventory

00:01:55,759 --> 00:01:59,680
generate bill

00:01:56,640 --> 00:02:02,079
and schedule delivery all the ipc calls

00:01:59,680 --> 00:02:04,320
are like normal function calls since

00:02:02,079 --> 00:02:06,719
they are on the same system

00:02:04,320 --> 00:02:08,479
it is definitely a lot of simpler to

00:02:06,719 --> 00:02:09,039
implement from an infrastructure point

00:02:08,479 --> 00:02:10,959
of view

00:02:09,039 --> 00:02:13,200
it can be tempting to begin with this

00:02:10,959 --> 00:02:15,680
initially if application is on

00:02:13,200 --> 00:02:17,200
mvp phase or poc phase or if the

00:02:15,680 --> 00:02:18,959
application will solve

00:02:17,200 --> 00:02:20,239
the simple problem so that is how we

00:02:18,959 --> 00:02:22,720
started

00:02:20,239 --> 00:02:25,120
we have written uh so yeah that is how

00:02:22,720 --> 00:02:28,239
we started so if you look into the

00:02:25,120 --> 00:02:30,000
diagram you can you will be seeing uh ui

00:02:28,239 --> 00:02:30,879
interacting with single server where we

00:02:30,000 --> 00:02:33,440
have all the

00:02:30,879 --> 00:02:35,519
methods written so uh we have given you

00:02:33,440 --> 00:02:38,800
example of how we have written it

00:02:35,519 --> 00:02:41,280
on the left hand side but there are

00:02:38,800 --> 00:02:42,000
certain disadvantages to it this however

00:02:41,280 --> 00:02:43,920
does not

00:02:42,000 --> 00:02:45,280
work if the business problem you look to

00:02:43,920 --> 00:02:47,440
solve is large

00:02:45,280 --> 00:02:49,120
and complex difficult to implement

00:02:47,440 --> 00:02:51,040
continuous delivery with single

00:02:49,120 --> 00:02:53,040
since a single module change need a

00:02:51,040 --> 00:02:54,560
complete redeployment of the application

00:02:53,040 --> 00:02:57,599
and retesting it

00:02:54,560 --> 00:02:58,720
a single module failure can bring down

00:02:57,599 --> 00:03:01,440
the entire system

00:02:58,720 --> 00:03:02,000
this would not have a scale well for us

00:03:01,440 --> 00:03:04,239
so that's

00:03:02,000 --> 00:03:05,519
why we moved to microservice

00:03:04,239 --> 00:03:08,879
architecture

00:03:05,519 --> 00:03:11,200
so microservices are logic couple

00:03:08,879 --> 00:03:12,239
services integrated to be part of larger

00:03:11,200 --> 00:03:14,159
application

00:03:12,239 --> 00:03:16,319
microservices can follow different

00:03:14,159 --> 00:03:18,560
design pattern and philosophies

00:03:16,319 --> 00:03:19,840
let's take the simplest design pattern

00:03:18,560 --> 00:03:21,680
with as less

00:03:19,840 --> 00:03:23,519
possible infrastructure component so

00:03:21,680 --> 00:03:26,000
that is how we also

00:03:23,519 --> 00:03:27,040
moved here so let's break down our

00:03:26,000 --> 00:03:30,080
single service so

00:03:27,040 --> 00:03:30,480
in our previous example you have seen we

00:03:30,080 --> 00:03:32,400
had

00:03:30,480 --> 00:03:34,319
a single application server where we had

00:03:32,400 --> 00:03:37,360
all the functions written but here

00:03:34,319 --> 00:03:40,560
you can see we have broken down our

00:03:37,360 --> 00:03:43,120
you know independent module into

00:03:40,560 --> 00:03:45,519
various microservices so we have and in

00:03:43,120 --> 00:03:47,599
each microservice has its own database

00:03:45,519 --> 00:03:49,519
a simple design will use request

00:03:47,599 --> 00:03:51,840
response synchronous communication

00:03:49,519 --> 00:03:54,080
as means for different services to

00:03:51,840 --> 00:03:54,480
interact this will be beneficial as it

00:03:54,080 --> 00:03:56,080
needs

00:03:54,480 --> 00:03:58,000
lesser infrastructure component you

00:03:56,080 --> 00:04:00,080
don't have to maintain message queues

00:03:58,000 --> 00:04:01,519
even stream and even source

00:04:00,080 --> 00:04:03,760
comparatively easier

00:04:01,519 --> 00:04:04,799
easiest of all the micro service pattern

00:04:03,760 --> 00:04:07,040
to develop

00:04:04,799 --> 00:04:08,319
test and deploy this lets us

00:04:07,040 --> 00:04:11,360
independently develop

00:04:08,319 --> 00:04:12,400
and release services if one service

00:04:11,360 --> 00:04:15,120
crashes

00:04:12,400 --> 00:04:16,880
the application still stays running

00:04:15,120 --> 00:04:18,479
although synchronous communication

00:04:16,880 --> 00:04:20,400
between microservices simplest the

00:04:18,479 --> 00:04:22,560
biggest advantage we get

00:04:20,400 --> 00:04:23,759
acknowledgement of requests being made

00:04:22,560 --> 00:04:26,560
so it enables

00:04:23,759 --> 00:04:28,080
faster you know enable ci cd isolate

00:04:26,560 --> 00:04:29,680
core tolerance

00:04:28,080 --> 00:04:31,280
better faster development testing and

00:04:29,680 --> 00:04:32,800
deployment process

00:04:31,280 --> 00:04:34,800
there are still lots of problem with

00:04:32,800 --> 00:04:36,560
this pattern read and write operation

00:04:34,800 --> 00:04:38,240
will take more time since we are now

00:04:36,560 --> 00:04:38,880
waiting for acknowledgement from each

00:04:38,240 --> 00:04:42,080
service

00:04:38,880 --> 00:04:44,160
recall there are high chances of us

00:04:42,080 --> 00:04:45,360
getting error or timeouts if the service

00:04:44,160 --> 00:04:48,320
being called is under

00:04:45,360 --> 00:04:50,560
lot of stress or down since much

00:04:48,320 --> 00:04:52,800
aggregation happen over the network

00:04:50,560 --> 00:04:54,800
we need to be best for backtracking to

00:04:52,800 --> 00:04:56,800
ensure transactions are followed in an

00:04:54,800 --> 00:04:59,360
operation for example

00:04:56,800 --> 00:05:01,440
let's assume an order being placed the

00:04:59,360 --> 00:05:01,680
payment is done successfully but there

00:05:01,440 --> 00:05:03,440
is

00:05:01,680 --> 00:05:05,919
an issue in order service let's say it

00:05:03,440 --> 00:05:07,520
is down we have to backtrack the payment

00:05:05,919 --> 00:05:09,600
and initiate a refund

00:05:07,520 --> 00:05:11,840
this need to be coded manually and is

00:05:09,600 --> 00:05:14,240
needed to be insured for every operation

00:05:11,840 --> 00:05:16,400
that has multiple service call in it

00:05:14,240 --> 00:05:18,880
does this achieve all that we were

00:05:16,400 --> 00:05:21,680
looking to achieve in a microservice

00:05:18,880 --> 00:05:23,440
definitely not we have just distributed

00:05:21,680 --> 00:05:26,320
our monolith

00:05:23,440 --> 00:05:27,759
over the network uh which has further

00:05:26,320 --> 00:05:29,919
decreased its performance

00:05:27,759 --> 00:05:31,680
we did get some benefit over it but

00:05:29,919 --> 00:05:34,560
still things are tightly covered

00:05:31,680 --> 00:05:35,840
so in order to fix the issue let's add

00:05:34,560 --> 00:05:37,840
the even base

00:05:35,840 --> 00:05:38,880
asynchronous call rather than a request

00:05:37,840 --> 00:05:41,919
response

00:05:38,880 --> 00:05:41,919
synchronous call

00:05:45,120 --> 00:05:48,240
uh thank you sapna for building all that

00:05:46,720 --> 00:05:51,039
up so

00:05:48,240 --> 00:05:52,000
even based communication uh why even

00:05:51,039 --> 00:05:54,960
based

00:05:52,000 --> 00:05:56,560
so this uh method of communication in

00:05:54,960 --> 00:05:58,080
microservices architecture models the

00:05:56,560 --> 00:05:59,680
real world very well

00:05:58,080 --> 00:06:01,360
you can take examples of lot of

00:05:59,680 --> 00:06:02,960
different sectors in real world

00:06:01,360 --> 00:06:05,440
not related to microservice or

00:06:02,960 --> 00:06:07,919
engineering but they do

00:06:05,440 --> 00:06:09,440
but they do follow this event-based uh

00:06:07,919 --> 00:06:11,199
communication really well

00:06:09,440 --> 00:06:13,199
you will never see an accountant uh

00:06:11,199 --> 00:06:14,479
deleting old records you will obviously

00:06:13,199 --> 00:06:16,720
see him adding new things

00:06:14,479 --> 00:06:18,400
maintaining the old data as well same

00:06:16,720 --> 00:06:20,400
thing happens in a contract

00:06:18,400 --> 00:06:22,319
you don't uh cross off things in a

00:06:20,400 --> 00:06:24,560
contract you make amendments or you make

00:06:22,319 --> 00:06:27,199
addendums to it as we call it

00:06:24,560 --> 00:06:28,479
uh so everything old and new is still

00:06:27,199 --> 00:06:31,840
there

00:06:28,479 --> 00:06:34,319
and even if you take uh

00:06:31,840 --> 00:06:36,080
example of libraries uh for example

00:06:34,319 --> 00:06:38,479
there is a library called readers

00:06:36,080 --> 00:06:41,280
it also does this event uh based

00:06:38,479 --> 00:06:44,160
communication really well

00:06:41,280 --> 00:06:44,880
so uh so in event based communication

00:06:44,160 --> 00:06:47,120
there are

00:06:44,880 --> 00:06:48,639
producers consumers and an

00:06:47,120 --> 00:06:50,800
infrastructure component

00:06:48,639 --> 00:06:51,919
that could be rabbit mq a message queue

00:06:50,800 --> 00:06:55,120
or uh

00:06:51,919 --> 00:06:57,520
after that uh that handles your uh

00:06:55,120 --> 00:06:59,440
events or messages so a producer

00:06:57,520 --> 00:07:00,960
produces event a consumer consumes an

00:06:59,440 --> 00:07:02,639
event

00:07:00,960 --> 00:07:04,639
but a producer might not know who the

00:07:02,639 --> 00:07:05,360
consumer is and the consumers themselves

00:07:04,639 --> 00:07:08,479
don't know how

00:07:05,360 --> 00:07:10,000
what all different consumers are uh and

00:07:08,479 --> 00:07:13,199
they've passed this information using

00:07:10,000 --> 00:07:13,199
that infrastructure component

00:07:14,319 --> 00:07:20,639
so um so so when we

00:07:17,440 --> 00:07:21,759
replaced this request response uh with

00:07:20,639 --> 00:07:23,599
an event

00:07:21,759 --> 00:07:25,599
uh we could have done the old pub sub

00:07:23,599 --> 00:07:27,680
implementation using rabbit mq or redis

00:07:25,599 --> 00:07:29,199
but we instant went for an event stream

00:07:27,680 --> 00:07:31,039
because we know it would be much more

00:07:29,199 --> 00:07:33,120
future proof because even stream can do

00:07:31,039 --> 00:07:36,560
a lot more and also a person

00:07:33,120 --> 00:07:38,160
ah so hence we choose apache kafka

00:07:36,560 --> 00:07:39,599
as an infrastructure component to help

00:07:38,160 --> 00:07:42,800
us out

00:07:39,599 --> 00:07:47,120
and so let's see an example

00:07:42,800 --> 00:07:48,160
let's see how our microservices map up

00:07:47,120 --> 00:07:51,199
to and

00:07:48,160 --> 00:07:52,639
event uh to an event driven

00:07:51,199 --> 00:07:55,840
communication

00:07:52,639 --> 00:07:57,680
uh so so in this uh what do you think

00:07:55,840 --> 00:08:00,319
would happen

00:07:57,680 --> 00:08:01,919
in an application ui if an order is

00:08:00,319 --> 00:08:04,000
placed that order would

00:08:01,919 --> 00:08:06,080
hit the payment service first let's

00:08:04,000 --> 00:08:08,720
assume the payment is successful

00:08:06,080 --> 00:08:09,280
uh the ui would be acknowledged then and

00:08:08,720 --> 00:08:11,280
there

00:08:09,280 --> 00:08:13,039
and an end user would see a sense of

00:08:11,280 --> 00:08:16,319
successful message on the ui

00:08:13,039 --> 00:08:18,879
without seeing um without seeing what

00:08:16,319 --> 00:08:19,680
happens uh to the downstream services

00:08:18,879 --> 00:08:23,360
then

00:08:19,680 --> 00:08:25,680
the producer produces an event and

00:08:23,360 --> 00:08:26,720
and the order services consumes it order

00:08:25,680 --> 00:08:28,479
services does

00:08:26,720 --> 00:08:30,319
uh its business logic and it for the

00:08:28,479 --> 00:08:32,399
producers and transactional

00:08:30,319 --> 00:08:34,080
uh event which makes sure that the other

00:08:32,399 --> 00:08:36,240
downstream services that we consume that

00:08:34,080 --> 00:08:38,000
event they don't fire their own email

00:08:36,240 --> 00:08:39,599
in the process thus maintaining a

00:08:38,000 --> 00:08:43,039
transaction loan

00:08:39,599 --> 00:08:44,720
so let's say what were to happen if in

00:08:43,039 --> 00:08:46,399
if an inventory service or the billing

00:08:44,720 --> 00:08:50,080
service was to get down

00:08:46,399 --> 00:08:53,279
in this case um in this

00:08:50,080 --> 00:08:55,440
case uh you would uh that you would

00:08:53,279 --> 00:08:56,880
queue up all the events to that service

00:08:55,440 --> 00:08:58,480
and once that service is back up it

00:08:56,880 --> 00:09:01,440
would start to consume

00:08:58,480 --> 00:09:02,959
so no communication uh communication

00:09:01,440 --> 00:09:06,320
failure would have happened

00:09:02,959 --> 00:09:08,000
uh kafka does that it maintains all the

00:09:06,320 --> 00:09:10,000
things in a queue for something that is

00:09:08,000 --> 00:09:13,200
not working

00:09:10,000 --> 00:09:16,720
and all the services would be

00:09:13,200 --> 00:09:20,000
uh would be in this sort of same state

00:09:16,720 --> 00:09:22,720
so now let's see uh what were to happen

00:09:20,000 --> 00:09:24,560
if uh to an end user we need to show

00:09:22,720 --> 00:09:28,399
updates on his ui

00:09:24,560 --> 00:09:31,760
uh what we can do so what we did was

00:09:28,399 --> 00:09:34,320
uh we attached something called as the

00:09:31,760 --> 00:09:36,560
uh attach something called as the

00:09:34,320 --> 00:09:37,279
websocket service this web socket

00:09:36,560 --> 00:09:40,560
service

00:09:37,279 --> 00:09:43,680
uh was responsible for uh

00:09:40,560 --> 00:09:46,560
pushing things on the ui so rather than

00:09:43,680 --> 00:09:47,839
ui pulling the back end for the data

00:09:46,560 --> 00:09:50,240
this web socket service

00:09:47,839 --> 00:09:51,920
itself pushed changes on the ui when the

00:09:50,240 --> 00:09:53,680
time was right

00:09:51,920 --> 00:09:55,440
so once all the transaction for a

00:09:53,680 --> 00:09:55,760
particular placing another was complete

00:09:55,440 --> 00:09:57,519
it

00:09:55,760 --> 00:09:59,279
then it would the websocket service

00:09:57,519 --> 00:10:00,720
would update the ui and show an order

00:09:59,279 --> 00:10:02,399
successful message

00:10:00,720 --> 00:10:03,600
the order successful message would not

00:10:02,399 --> 00:10:04,000
have been there you could have seen

00:10:03,600 --> 00:10:07,600
something

00:10:04,000 --> 00:10:09,120
like order pending but uh this is how we

00:10:07,600 --> 00:10:10,880
can update the ui and it would have been

00:10:09,120 --> 00:10:12,560
reactive the end user might not even

00:10:10,880 --> 00:10:16,079
have to refresh the screen

00:10:12,560 --> 00:10:18,320
and reloading this uh refresh the screen

00:10:16,079 --> 00:10:21,519
and this would have just updated his uh

00:10:18,320 --> 00:10:24,560
ui very smoothly this

00:10:21,519 --> 00:10:28,880
uh this procedure can also be

00:10:24,560 --> 00:10:30,399
also be expanded to use something like a

00:10:28,880 --> 00:10:33,200
materialized view

00:10:30,399 --> 00:10:33,600
or if you have a very complex list page

00:10:33,200 --> 00:10:36,000
that

00:10:33,600 --> 00:10:37,600
is that is compromised of data from

00:10:36,000 --> 00:10:39,600
different services

00:10:37,600 --> 00:10:41,839
which obviously takes time if you take

00:10:39,600 --> 00:10:44,320
uh the request response approach

00:10:41,839 --> 00:10:44,880
so you can uh so you can create a

00:10:44,320 --> 00:10:47,519
service

00:10:44,880 --> 00:10:49,279
and push all that aggregated data to

00:10:47,519 --> 00:10:50,959
that service which is further consumed

00:10:49,279 --> 00:10:53,440
by this web socket service

00:10:50,959 --> 00:10:56,000
and updates the list on the ui and it

00:10:53,440 --> 00:10:59,200
does that in a fast manner

00:10:56,000 --> 00:11:01,360
so that's how it is we started from a

00:10:59,200 --> 00:11:03,600
basic moon lift for our poc and we

00:11:01,360 --> 00:11:05,120
moved all the way up till an event based

00:11:03,600 --> 00:11:07,360
structure

00:11:05,120 --> 00:11:09,440
for an app when it started to go so we

00:11:07,360 --> 00:11:11,680
could scale it easily

00:11:09,440 --> 00:11:11,680
so

00:11:13,440 --> 00:11:18,399
let us know if you have any questions

00:11:15,839 --> 00:11:20,640
slap us

00:11:18,399 --> 00:11:23,600
and till then thank you for listening to

00:11:20,640 --> 00:11:23,600

YouTube URL: https://www.youtube.com/watch?v=LBkUUZeIJ6Q


