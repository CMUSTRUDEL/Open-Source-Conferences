Title: Hit the Ground Running with WebAssembly - Robert Aboukhalil, Invitae
Publication date: 2021-05-28
Playlist: OpenJS World 2021
Description: 
	For over 20 years, JavaScript was the only scripting language you could use reliably in a browser. That all changed a few years ago, when WebAssembly became supported by all major browsers. This talk is a 29,032-foot overview of WebAssembly, why it's awesome, and how to get started using it. As concrete use cases, Robert will mention two open source tools he contributed to where WebAssembly improved performance, and enabled reusing C/C++ code on the web. The talk will also cover upcoming WebAssembly features such as threads and SIMD, and will end with a discussion of use cases where WebAssembly shines (...and when the added complexity might not be worth it!)
Captions: 
	00:00:00,799 --> 00:00:04,960
hey everyone thanks for tuning in

00:00:03,199 --> 00:00:06,399
today i wanted to talk to you about

00:00:04,960 --> 00:00:09,519
webassembly

00:00:06,399 --> 00:00:10,559
what it is why it's awesome and how you

00:00:09,519 --> 00:00:13,920
can start using it

00:00:10,559 --> 00:00:15,839
in your own web applications

00:00:13,920 --> 00:00:17,039
so let me start by introducing myself so

00:00:15,839 --> 00:00:20,640
my name is robert

00:00:17,039 --> 00:00:23,840
buchaliel and my background is a mix of

00:00:20,640 --> 00:00:26,960
software engineering and bioinformatics

00:00:23,840 --> 00:00:29,760
i'm the maintainer of the library bio

00:00:26,960 --> 00:00:31,439
asm so this is a collection of

00:00:29,760 --> 00:00:33,280
bioinformatics tools that we've

00:00:31,439 --> 00:00:37,040
pre-compiled to webassembly

00:00:33,280 --> 00:00:39,680
and are hosting for free on cdn so that

00:00:37,040 --> 00:00:41,600
other bioinformatics web apps can make

00:00:39,680 --> 00:00:44,640
use of it

00:00:41,600 --> 00:00:46,800
i'm also the author of the book level up

00:00:44,640 --> 00:00:48,079
with webassembly so if you're just

00:00:46,800 --> 00:00:50,000
getting started

00:00:48,079 --> 00:00:52,160
with webassembly feel free to check it

00:00:50,000 --> 00:00:52,160
out

00:00:52,960 --> 00:00:58,239
all right so what is web assembly anyway

00:00:55,840 --> 00:01:00,239
well i like to think of webassembly

00:00:58,239 --> 00:01:01,280
as really just being yet another

00:01:00,239 --> 00:01:03,920
language

00:01:01,280 --> 00:01:05,680
that you can use in the browser

00:01:03,920 --> 00:01:09,920
alongside javascript

00:01:05,680 --> 00:01:13,040
html and css now to give you a sense

00:01:09,920 --> 00:01:17,520
for what this language looks like

00:01:13,040 --> 00:01:20,560
let's take a look at a simple example

00:01:17,520 --> 00:01:24,159
here i'm defining a function

00:01:20,560 --> 00:01:26,159
called hello and all this function does

00:01:24,159 --> 00:01:29,600
is return the string

00:01:26,159 --> 00:01:31,360
openjs world now

00:01:29,600 --> 00:01:34,000
you don't need to know anything about

00:01:31,360 --> 00:01:36,079
webassembly just looking at this

00:01:34,000 --> 00:01:38,400
you can tell this is not a language that

00:01:36,079 --> 00:01:40,720
you probably want to code

00:01:38,400 --> 00:01:41,600
and that's good because you don't have

00:01:40,720 --> 00:01:44,720
to

00:01:41,600 --> 00:01:46,880
in fact the whole idea of webassembly

00:01:44,720 --> 00:01:48,159
is that you can take code written in

00:01:46,880 --> 00:01:53,200
other languages

00:01:48,159 --> 00:01:54,640
and compile that down to webassembly

00:01:53,200 --> 00:01:56,960
and so that's why it's called a

00:01:54,640 --> 00:01:58,640
compilation target because you take code

00:01:56,960 --> 00:02:00,479
written in these other languages

00:01:58,640 --> 00:02:01,680
compile it to webassembly and then you

00:02:00,479 --> 00:02:05,680
run it in

00:02:01,680 --> 00:02:07,119
the browser so where is webassembly

00:02:05,680 --> 00:02:10,399
actually useful though

00:02:07,119 --> 00:02:14,000
well here are a few use cases

00:02:10,399 --> 00:02:16,160
one is code reuse you know all these

00:02:14,000 --> 00:02:19,440
applications i'm showing here

00:02:16,160 --> 00:02:21,440
are very large code bases

00:02:19,440 --> 00:02:22,879
hundreds of thousands millions of lines

00:02:21,440 --> 00:02:26,000
of code

00:02:22,879 --> 00:02:28,319
where web assembly was really essential

00:02:26,000 --> 00:02:31,360
to let them transition

00:02:28,319 --> 00:02:32,640
these apps from running on a desktop or

00:02:31,360 --> 00:02:35,680
in a command line

00:02:32,640 --> 00:02:38,080
onto the web without having to rewrite

00:02:35,680 --> 00:02:38,959
everything in javascript so this is very

00:02:38,080 --> 00:02:42,160
convenient

00:02:38,959 --> 00:02:45,599
from the code reusability perspective

00:02:42,160 --> 00:02:47,440
the other big use case is performance so

00:02:45,599 --> 00:02:48,879
in in these four applications what

00:02:47,440 --> 00:02:50,800
they've done is

00:02:48,879 --> 00:02:52,480
look at the most compute intensive part

00:02:50,800 --> 00:02:53,840
of their apps that were written in

00:02:52,480 --> 00:02:57,519
javascript

00:02:53,840 --> 00:03:01,200
and replaced those with webassembly

00:02:57,519 --> 00:03:02,080
and what they noticed was a large speed

00:03:01,200 --> 00:03:05,519
up

00:03:02,080 --> 00:03:08,480
and better performance now of course

00:03:05,519 --> 00:03:10,640
sidenote this is not guaranteed to work

00:03:08,480 --> 00:03:12,400
right just because you use webassembly

00:03:10,640 --> 00:03:15,200
does not mean that your app will always

00:03:12,400 --> 00:03:18,319
be faster but for a certain category

00:03:15,200 --> 00:03:20,879
of data intensive applications it

00:03:18,319 --> 00:03:20,879
can help

00:03:21,519 --> 00:03:25,040
the other use case behind webassembly is

00:03:23,680 --> 00:03:27,599
portability

00:03:25,040 --> 00:03:30,319
so the idea here is that you can also

00:03:27,599 --> 00:03:32,720
use webassembly outside the browser

00:03:30,319 --> 00:03:34,400
really anywhere where you can find a

00:03:32,720 --> 00:03:37,040
webassembly runtime

00:03:34,400 --> 00:03:38,319
that can execute your code you can have

00:03:37,040 --> 00:03:40,959
webassembly

00:03:38,319 --> 00:03:42,640
and so here i'm showing for examples for

00:03:40,959 --> 00:03:46,400
example cloudflare and fastly

00:03:42,640 --> 00:03:48,799
these are providing serverless functions

00:03:46,400 --> 00:03:50,560
that run webassembly at the edge the

00:03:48,799 --> 00:03:52,720
nice thing about using webassembly for

00:03:50,560 --> 00:03:53,760
serverless is that they initialize a lot

00:03:52,720 --> 00:03:57,200
faster

00:03:53,760 --> 00:03:58,959
and are cheaper because webassembly

00:03:57,200 --> 00:04:01,280
you know is more a lot more lightweight

00:03:58,959 --> 00:04:02,959
than using containers for example

00:04:01,280 --> 00:04:04,640
you can also run webassembly on your

00:04:02,959 --> 00:04:07,840
server if you use

00:04:04,640 --> 00:04:11,360
runtimes like wasm time wasmer or

00:04:07,840 --> 00:04:13,200
even node.js right can run webassembly

00:04:11,360 --> 00:04:15,280
you can also run your webassembly

00:04:13,200 --> 00:04:18,320
binaries on raspberry pi

00:04:15,280 --> 00:04:19,120
as shown in this screenshot from from

00:04:18,320 --> 00:04:22,079
the wasm

00:04:19,120 --> 00:04:24,560
3 team which also build a webassembly

00:04:22,079 --> 00:04:24,560
runtime

00:04:25,360 --> 00:04:30,720
so all these use cases look great

00:04:28,400 --> 00:04:32,320
but can you actually use it today and

00:04:30,720 --> 00:04:35,520
the answer is yes

00:04:32,320 --> 00:04:38,479
about 93 percent of users

00:04:35,520 --> 00:04:39,600
on the web today are running browsers

00:04:38,479 --> 00:04:43,840
that support

00:04:39,600 --> 00:04:45,680
webassembly and so this is great news

00:04:43,840 --> 00:04:47,360
one thing that's interesting though is

00:04:45,680 --> 00:04:49,919
you know how many developers

00:04:47,360 --> 00:04:51,520
actually use webassembly and so to get a

00:04:49,919 --> 00:04:52,160
sense for that what we can do is look at

00:04:51,520 --> 00:04:54,960
the

00:04:52,160 --> 00:04:56,560
state of javascript this is a survey

00:04:54,960 --> 00:04:59,600
that is done every year

00:04:56,560 --> 00:05:02,320
they pull 20 000 javascript developers

00:04:59,600 --> 00:05:03,440
and one of the questions they ask is are

00:05:02,320 --> 00:05:05,039
you familiar

00:05:03,440 --> 00:05:07,440
with webassembly and so here are the

00:05:05,039 --> 00:05:07,440
results

00:05:08,479 --> 00:05:13,440
about 75 percent of developers who

00:05:11,919 --> 00:05:15,919
answered this survey

00:05:13,440 --> 00:05:17,680
know what webassembly is but had not had

00:05:15,919 --> 00:05:21,120
a chance to use it

00:05:17,680 --> 00:05:22,720
15 had never heard of it and only about

00:05:21,120 --> 00:05:25,600
00:05:22,720 --> 00:05:27,280
of the respondents for that survey said

00:05:25,600 --> 00:05:30,800
that they had actually used

00:05:27,280 --> 00:05:32,479
webassembly so

00:05:30,800 --> 00:05:34,320
you know we only have two data points

00:05:32,479 --> 00:05:37,280
here 2019

00:05:34,320 --> 00:05:38,000
and 2020 for the percentage of

00:05:37,280 --> 00:05:40,320
developers

00:05:38,000 --> 00:05:42,080
who have used webassembly around 10

00:05:40,320 --> 00:05:44,560
percent

00:05:42,080 --> 00:05:46,560
but if we're interested in projecting

00:05:44,560 --> 00:05:50,479
future webassembly usage

00:05:46,560 --> 00:05:53,600
what we can do is use very sophisticated

00:05:50,479 --> 00:05:54,560
mathematical modeling techniques to try

00:05:53,600 --> 00:05:59,280
to

00:05:54,560 --> 00:06:01,360
impute what is the usage going to be

00:05:59,280 --> 00:06:03,280
in the future and so what we can see is

00:06:01,360 --> 00:06:05,440
by 2047

00:06:03,280 --> 00:06:06,560
over 100 percent of javascript

00:06:05,440 --> 00:06:09,600
developers

00:06:06,560 --> 00:06:12,000
will be using webassembly

00:06:09,600 --> 00:06:12,880
now you know i'm kidding of course

00:06:12,000 --> 00:06:16,080
that's not how

00:06:12,880 --> 00:06:18,479
anything works uh but it will be

00:06:16,080 --> 00:06:20,160
interesting to see how that number

00:06:18,479 --> 00:06:22,800
actually plays out

00:06:20,160 --> 00:06:22,800
over time

00:06:24,800 --> 00:06:30,319
all right now what i'd like to do is

00:06:27,520 --> 00:06:32,800
concretely give you two examples

00:06:30,319 --> 00:06:33,759
of applications that i had the chance to

00:06:32,800 --> 00:06:36,160
work on

00:06:33,759 --> 00:06:37,600
where web assembly was really useful

00:06:36,160 --> 00:06:42,160
both in terms of

00:06:37,600 --> 00:06:42,160
performance and code reuse

00:06:42,479 --> 00:06:47,120
so the first one is fastq bio this is a

00:06:45,440 --> 00:06:50,400
an interactive web tool

00:06:47,120 --> 00:06:51,120
that lets the user input dna sequencing

00:06:50,400 --> 00:06:53,520
data

00:06:51,120 --> 00:06:54,560
and rapidly evaluate the quality of that

00:06:53,520 --> 00:06:58,960
data

00:06:54,560 --> 00:06:58,960
while the data stays inside the browser

00:06:59,039 --> 00:07:02,720
so when we set out to build this we kind

00:07:01,440 --> 00:07:04,800
of looked around

00:07:02,720 --> 00:07:06,240
and there were several tools that could

00:07:04,800 --> 00:07:07,840
help

00:07:06,240 --> 00:07:09,440
calculate these statistics that we're

00:07:07,840 --> 00:07:10,000
interested in but none of them were

00:07:09,440 --> 00:07:12,319
written

00:07:10,000 --> 00:07:14,960
in javascript right so we have one in c

00:07:12,319 --> 00:07:17,360
c plus and java

00:07:14,960 --> 00:07:19,599
and you know the time that i built this

00:07:17,360 --> 00:07:23,680
i hadn't really heard of webassembly

00:07:19,599 --> 00:07:26,960
so we figured the only options were

00:07:23,680 --> 00:07:28,240
number one host one of these tools on a

00:07:26,960 --> 00:07:31,599
server

00:07:28,240 --> 00:07:35,120
and expose an api that lets you

00:07:31,599 --> 00:07:37,680
make custom queries to that tool

00:07:35,120 --> 00:07:38,720
and you know while we could have done

00:07:37,680 --> 00:07:41,360
that

00:07:38,720 --> 00:07:42,639
that gets expensive real fast especially

00:07:41,360 --> 00:07:45,039
if you have a lot of users and you need

00:07:42,639 --> 00:07:46,560
to scale it up

00:07:45,039 --> 00:07:49,120
it's also problematic because you need

00:07:46,560 --> 00:07:51,440
to make sure that it's secure

00:07:49,120 --> 00:07:53,440
and it doesn't accidentally let users

00:07:51,440 --> 00:07:56,960
execute arbitrary commands

00:07:53,440 --> 00:07:58,720
on your servers and start mining bitcoin

00:07:56,960 --> 00:08:01,039
um but but also

00:07:58,720 --> 00:08:03,039
there's a data upload issue right you

00:08:01,039 --> 00:08:06,240
know the main use case

00:08:03,039 --> 00:08:08,240
for this application was to analyze

00:08:06,240 --> 00:08:09,840
files that were already on the user's

00:08:08,240 --> 00:08:13,039
local computer

00:08:09,840 --> 00:08:14,879
and so this would be inconvenient

00:08:13,039 --> 00:08:16,560
to have them uploading the data to the

00:08:14,879 --> 00:08:19,520
cloud before they can

00:08:16,560 --> 00:08:19,520
even analyze it

00:08:20,240 --> 00:08:26,800
so the the second approach would be

00:08:23,759 --> 00:08:30,319
let's rewrite a part of these tools

00:08:26,800 --> 00:08:30,800
in javascript a few problems there as

00:08:30,319 --> 00:08:34,000
well

00:08:30,800 --> 00:08:35,039
one this takes time obviously number two

00:08:34,000 --> 00:08:38,080
it's error-prone

00:08:35,039 --> 00:08:39,200
right anytime you're rewriting a complex

00:08:38,080 --> 00:08:42,640
algorithm

00:08:39,200 --> 00:08:45,680
that has edge cases you're gonna likely

00:08:42,640 --> 00:08:49,120
introduce errors

00:08:45,680 --> 00:08:50,640
the other thing is that we're now

00:08:49,120 --> 00:08:54,240
maintaining a separate

00:08:50,640 --> 00:08:55,120
copy of this tool written in a different

00:08:54,240 --> 00:08:57,040
language

00:08:55,120 --> 00:08:59,279
and so we won't be benefiting from all

00:08:57,040 --> 00:09:00,399
the updates and all the bug fixes and

00:08:59,279 --> 00:09:03,440
new features

00:09:00,399 --> 00:09:06,880
that get added onto those original

00:09:03,440 --> 00:09:10,000
tools so

00:09:06,880 --> 00:09:12,399
despite the uh

00:09:10,000 --> 00:09:13,839
the challenges we ended up going with

00:09:12,399 --> 00:09:15,760
option number two

00:09:13,839 --> 00:09:18,000
so we rewrote a small portion of the

00:09:15,760 --> 00:09:21,040
tool ctk

00:09:18,000 --> 00:09:23,120
in javascript and it worked

00:09:21,040 --> 00:09:24,640
however uh then i came across

00:09:23,120 --> 00:09:27,920
webassembly

00:09:24,640 --> 00:09:29,040
and that's when the third option opened

00:09:27,920 --> 00:09:32,160
up

00:09:29,040 --> 00:09:33,040
and this is really where webassembly

00:09:32,160 --> 00:09:36,640
shines

00:09:33,040 --> 00:09:39,360
like these are all existing tools

00:09:36,640 --> 00:09:40,959
that are written in in languages other

00:09:39,360 --> 00:09:43,440
than javascript

00:09:40,959 --> 00:09:45,760
that we can now compile to webassembly

00:09:43,440 --> 00:09:48,720
and run directly in the browser

00:09:45,760 --> 00:09:50,000
so not only do we get to run it in the

00:09:48,720 --> 00:09:53,519
browser but there's also

00:09:50,000 --> 00:09:54,959
no need to rewrite any of the code so we

00:09:53,519 --> 00:09:58,240
get the best of both

00:09:54,959 --> 00:10:01,279
worlds but what's interesting here

00:09:58,240 --> 00:10:05,360
is also that on top

00:10:01,279 --> 00:10:06,160
of the code reuse that we got we also

00:10:05,360 --> 00:10:09,040
saw

00:10:06,160 --> 00:10:11,120
some performance improvements so what we

00:10:09,040 --> 00:10:15,279
are able to do is actually

00:10:11,120 --> 00:10:17,760
speed up the app by 20x by switching

00:10:15,279 --> 00:10:19,920
to webassembly from our javascript

00:10:17,760 --> 00:10:21,839
implementation

00:10:19,920 --> 00:10:24,480
so if you want all the details for this

00:10:21,839 --> 00:10:29,120
you can check out my perf matters

00:10:24,480 --> 00:10:29,120
2019 talk at on youtube

00:10:31,120 --> 00:10:35,760
all right case study number two so this

00:10:33,360 --> 00:10:38,240
is an app that's called ribbon

00:10:35,760 --> 00:10:39,200
it's an interactive tool lets you

00:10:38,240 --> 00:10:43,519
explore

00:10:39,200 --> 00:10:46,480
complex rearrangements in genomes

00:10:43,519 --> 00:10:47,440
part of this application involves

00:10:46,480 --> 00:10:50,240
parsing

00:10:47,440 --> 00:10:51,839
a special bioinformatics binary file

00:10:50,240 --> 00:10:55,440
format

00:10:51,839 --> 00:10:57,360
and to do this parsing

00:10:55,440 --> 00:10:58,800
we have a few existing tools that we can

00:10:57,360 --> 00:11:01,680
use written c

00:10:58,800 --> 00:11:03,600
and rus you know again this is very

00:11:01,680 --> 00:11:06,240
often the case in bioinformatics

00:11:03,600 --> 00:11:08,160
by the way where a lot of the tools are

00:11:06,240 --> 00:11:11,600
written in c and c plus plus and rest

00:11:08,160 --> 00:11:12,959
and so on and so here

00:11:11,600 --> 00:11:14,399
we kind of end up with the same

00:11:12,959 --> 00:11:15,839
situation right in terms of

00:11:14,399 --> 00:11:18,480
implementation

00:11:15,839 --> 00:11:20,480
do we host the tool on a server probably

00:11:18,480 --> 00:11:21,360
not same issues as before with the cost

00:11:20,480 --> 00:11:23,279
of security

00:11:21,360 --> 00:11:25,120
and you know uploading the data to the

00:11:23,279 --> 00:11:29,839
cloud

00:11:25,120 --> 00:11:29,839
the other option being rewriting it

00:11:30,720 --> 00:11:35,279
this time however it won't take us much

00:11:34,399 --> 00:11:38,320
time because

00:11:35,279 --> 00:11:39,279
someone else had actually already

00:11:38,320 --> 00:11:42,160
rewritten

00:11:39,279 --> 00:11:42,800
portions of of samtools in javascript

00:11:42,160 --> 00:11:45,839
and so we

00:11:42,800 --> 00:11:48,959
just ended up using that but

00:11:45,839 --> 00:11:51,519
after the success that we saw with

00:11:48,959 --> 00:11:52,800
fastq bio we figured well let's try

00:11:51,519 --> 00:11:57,040
webassembly here

00:11:52,800 --> 00:12:00,399
as well and so what we saw

00:11:57,040 --> 00:12:01,839
was again interestingly enough we saw a

00:12:00,399 --> 00:12:04,880
two to three x

00:12:01,839 --> 00:12:06,560
improvement in terms of runtime but

00:12:04,880 --> 00:12:07,120
probably even more important than that

00:12:06,560 --> 00:12:10,240
we're

00:12:07,120 --> 00:12:12,720
we're now able to reuse

00:12:10,240 --> 00:12:14,639
a hundred thousand lines of very

00:12:12,720 --> 00:12:20,000
complicated c code

00:12:14,639 --> 00:12:20,000
that parses unique genomics file formats

00:12:20,560 --> 00:12:24,320
and what's really nice about that is

00:12:22,160 --> 00:12:27,040
that we're now able to use

00:12:24,320 --> 00:12:27,839
features that are available in the c

00:12:27,040 --> 00:12:29,360
library

00:12:27,839 --> 00:12:30,959
but were not implemented in the

00:12:29,360 --> 00:12:33,440
javascript one

00:12:30,959 --> 00:12:34,240
for example we can now do a very quick

00:12:33,440 --> 00:12:37,279
check

00:12:34,240 --> 00:12:37,680
on the validity of the file formats we

00:12:37,279 --> 00:12:40,480
can

00:12:37,680 --> 00:12:42,240
down sample the data randomly to reduce

00:12:40,480 --> 00:12:43,360
the amount of memory that we're using

00:12:42,240 --> 00:12:46,880
and how much compute

00:12:43,360 --> 00:12:50,079
we need on the user's computer and

00:12:46,880 --> 00:12:53,600
all these are only possible because

00:12:50,079 --> 00:12:57,519
we're just relying on the off-the-shelf

00:12:53,600 --> 00:12:57,519
tool that we've compiled to webassembly

00:13:02,160 --> 00:13:07,839
all right so if

00:13:05,200 --> 00:13:09,360
you're building these kinds of data

00:13:07,839 --> 00:13:11,680
intensive web apps

00:13:09,360 --> 00:13:13,120
there are several interesting tools that

00:13:11,680 --> 00:13:15,360
you can use

00:13:13,120 --> 00:13:17,680
with webassembly and one is threats you

00:13:15,360 --> 00:13:21,760
know obviously a lot of tools

00:13:17,680 --> 00:13:24,560
use threads to speed up execution

00:13:21,760 --> 00:13:26,800
and webassembly does support threads

00:13:24,560 --> 00:13:30,639
using web workers

00:13:26,800 --> 00:13:32,399
and the way that

00:13:30,639 --> 00:13:34,079
shared memory is implemented between

00:13:32,399 --> 00:13:37,360
threads is using this thing called

00:13:34,079 --> 00:13:41,040
shared array buffer

00:13:37,360 --> 00:13:43,440
however with the spectrum malware that

00:13:41,040 --> 00:13:46,639
showed up around 2018

00:13:43,440 --> 00:13:49,120
what happened was that browsers ended up

00:13:46,639 --> 00:13:50,959
turning off support for shared array

00:13:49,120 --> 00:13:54,320
buffer

00:13:50,959 --> 00:13:56,399
until relatively recently and so you

00:13:54,320 --> 00:13:59,440
know a few years later

00:13:56,399 --> 00:14:01,760
we're still at about 70 percent

00:13:59,440 --> 00:14:03,839
of users running browsers that support

00:14:01,760 --> 00:14:05,519
shared array buffer

00:14:03,839 --> 00:14:08,320
so you know we're getting there but

00:14:05,519 --> 00:14:10,560
we're not quite all the way there and so

00:14:08,320 --> 00:14:13,199
for if you are using threads

00:14:10,560 --> 00:14:14,560
it's probably a good idea to use feature

00:14:13,199 --> 00:14:17,199
detection

00:14:14,560 --> 00:14:20,079
where you test does the user support

00:14:17,199 --> 00:14:21,920
shared array buffer

00:14:20,079 --> 00:14:24,000
then use webassembly with threads

00:14:21,920 --> 00:14:26,000
otherwise use the version of the

00:14:24,000 --> 00:14:30,480
webassembly binary that does not

00:14:26,000 --> 00:14:31,360
have threading in it another really

00:14:30,480 --> 00:14:34,480
powerful tool

00:14:31,360 --> 00:14:35,600
is simdi so cimd stands for single

00:14:34,480 --> 00:14:39,120
instruction

00:14:35,600 --> 00:14:40,160
multiple data and the idea is that this

00:14:39,120 --> 00:14:43,120
is

00:14:40,160 --> 00:14:44,320
a way to parallelize code that is very

00:14:43,120 --> 00:14:47,360
commonly used

00:14:44,320 --> 00:14:49,040
in data analysis image processing and so

00:14:47,360 --> 00:14:51,920
on

00:14:49,040 --> 00:14:54,240
and so the idea is as the name suggests

00:14:51,920 --> 00:14:57,760
you can process multiple data sets

00:14:54,240 --> 00:14:59,120
within a single cpu instruction

00:14:57,760 --> 00:15:01,120
so just to give you a very concrete

00:14:59,120 --> 00:15:04,079
example let's say you have

00:15:01,120 --> 00:15:05,839
points in a three-dimensional space and

00:15:04,079 --> 00:15:08,560
you're interested in calculating

00:15:05,839 --> 00:15:10,800
the distance between these points using

00:15:08,560 --> 00:15:14,800
this formula

00:15:10,800 --> 00:15:17,680
so here what you could do is calculate

00:15:14,800 --> 00:15:19,199
these three subtractions one after the

00:15:17,680 --> 00:15:21,519
other

00:15:19,199 --> 00:15:22,880
therefore taking up about three cpu

00:15:21,519 --> 00:15:26,000
instructions

00:15:22,880 --> 00:15:30,240
or you could use sim d and

00:15:26,000 --> 00:15:31,759
add and insert those coordinates in an

00:15:30,240 --> 00:15:34,320
extra large

00:15:31,759 --> 00:15:36,639
cpu register that can fit four of these

00:15:34,320 --> 00:15:38,560
numbers at a time

00:15:36,639 --> 00:15:41,120
and do the same for the second data

00:15:38,560 --> 00:15:42,959
point and then what you can do is use a

00:15:41,120 --> 00:15:46,720
sim destruction

00:15:42,959 --> 00:15:50,079
that will subtract all three coordinates

00:15:46,720 --> 00:15:52,399
within a single cpu instruction

00:15:50,079 --> 00:15:54,720
so obviously this has a lot of potential

00:15:52,399 --> 00:15:55,040
for speeding up the calculation which is

00:15:54,720 --> 00:15:58,360
why

00:15:55,040 --> 00:16:01,440
it's it's so commonly used in a lot of

00:15:58,360 --> 00:16:04,560
mathematical and data analysis heavy

00:16:01,440 --> 00:16:06,720
tasks and

00:16:04,560 --> 00:16:08,800
the reason why i mentioned cmd is

00:16:06,720 --> 00:16:11,600
because there is a webassembly

00:16:08,800 --> 00:16:13,120
simd proposal currently focused on

00:16:11,600 --> 00:16:16,720
128-bit

00:16:13,120 --> 00:16:19,519
registers for most browsers

00:16:16,720 --> 00:16:21,600
this isn't actually supported unless you

00:16:19,519 --> 00:16:26,720
enable a flag but it will be

00:16:21,600 --> 00:16:26,720
enabled by default in chrome 91.

00:16:27,600 --> 00:16:32,639
now i recently did a test drive

00:16:30,720 --> 00:16:34,079
of webassembly simd what i wanted to do

00:16:32,639 --> 00:16:36,959
was essentially

00:16:34,079 --> 00:16:37,920
align dna sequences to a reference

00:16:36,959 --> 00:16:41,440
genome

00:16:37,920 --> 00:16:45,519
and benchmark the run time

00:16:41,440 --> 00:16:48,240
with and without webassembly simd

00:16:45,519 --> 00:16:49,120
and what i found was really really

00:16:48,240 --> 00:16:52,639
interesting

00:16:49,120 --> 00:16:54,480
where as you can see the webassembly

00:16:52,639 --> 00:16:57,519
with simdi

00:16:54,480 --> 00:16:59,920
gives us pretty close to the native cmd

00:16:57,519 --> 00:17:02,639
performance but in the browser

00:16:59,920 --> 00:17:04,640
which is really fantastic for those

00:17:02,639 --> 00:17:06,559
applications that can benefit

00:17:04,640 --> 00:17:07,679
from some d now what's really

00:17:06,559 --> 00:17:10,480
interesting about this

00:17:07,679 --> 00:17:11,919
is that you know when we compare

00:17:10,480 --> 00:17:14,799
performance

00:17:11,919 --> 00:17:16,319
between javascript and web assembly one

00:17:14,799 --> 00:17:18,079
can always argue

00:17:16,319 --> 00:17:20,160
well you didn't optimize your javascript

00:17:18,079 --> 00:17:22,480
enough and it's not because of the web

00:17:20,160 --> 00:17:25,600
assembly that your app is faster

00:17:22,480 --> 00:17:28,000
and that could be very true but

00:17:25,600 --> 00:17:29,840
when now we're talking about simd this

00:17:28,000 --> 00:17:32,640
is a whole new game

00:17:29,840 --> 00:17:35,120
because javascript does not have access

00:17:32,640 --> 00:17:38,320
to cmd instructions whereas

00:17:35,120 --> 00:17:38,960
webassembly does and so this is why this

00:17:38,320 --> 00:17:41,280
is a really

00:17:38,960 --> 00:17:42,080
really exciting advancement i'm looking

00:17:41,280 --> 00:17:44,840
forward

00:17:42,080 --> 00:17:47,039
to seeing that enabled in all the

00:17:44,840 --> 00:17:48,799
browsers

00:17:47,039 --> 00:17:51,039
if you're interested in learning more

00:17:48,799 --> 00:17:53,440
about webassembly simd

00:17:51,039 --> 00:17:55,039
in particular you can check out my

00:17:53,440 --> 00:18:01,200
recent webassembly live

00:17:55,039 --> 00:18:04,559
talk that is available on youtube

00:18:01,200 --> 00:18:06,799
all right so so far i focused

00:18:04,559 --> 00:18:08,720
mostly on how awesome webassembly is but

00:18:06,799 --> 00:18:09,919
before we end i i do want to spend a

00:18:08,720 --> 00:18:13,039
moment

00:18:09,919 --> 00:18:16,080
talking about when you should not

00:18:13,039 --> 00:18:18,480
use webassembly so to me it kind of

00:18:16,080 --> 00:18:20,160
comes down to three things

00:18:18,480 --> 00:18:23,679
if your app is not compute intensive

00:18:20,160 --> 00:18:25,280
enough or it's too compute intensive

00:18:23,679 --> 00:18:28,400
or if webassembly adds too much

00:18:25,280 --> 00:18:28,880
complexity to your code then you should

00:18:28,400 --> 00:18:31,120
not

00:18:28,880 --> 00:18:32,240
use webassembly so i want to just dive

00:18:31,120 --> 00:18:35,120
into

00:18:32,240 --> 00:18:35,520
each of those a little bit deeper so

00:18:35,120 --> 00:18:37,200
first

00:18:35,520 --> 00:18:38,799
if your app is not compute intensive

00:18:37,200 --> 00:18:41,200
enough so if it doesn't involve

00:18:38,799 --> 00:18:41,840
graphics if it doesn't involve data

00:18:41,200 --> 00:18:45,120
processing

00:18:41,840 --> 00:18:47,600
simulations audio processing video

00:18:45,120 --> 00:18:48,880
image you know all these kinds of

00:18:47,600 --> 00:18:51,120
compute

00:18:48,880 --> 00:18:52,880
heavy tasks for example if you're

00:18:51,120 --> 00:18:55,280
building a crud app

00:18:52,880 --> 00:18:57,760
just use javascript that's kind of the

00:18:55,280 --> 00:18:59,840
idea here

00:18:57,760 --> 00:19:01,440
at the other end of the spectrum if

00:18:59,840 --> 00:19:03,280
you're trying to do too much compute

00:19:01,440 --> 00:19:04,400
intensive work

00:19:03,280 --> 00:19:06,559
it's just not going to work in the

00:19:04,400 --> 00:19:07,919
browser whether you use webassembly or

00:19:06,559 --> 00:19:10,240
not

00:19:07,919 --> 00:19:11,520
you know for example if if i'm trying to

00:19:10,240 --> 00:19:14,640
assemble

00:19:11,520 --> 00:19:15,600
very large genomes in the browsers it's

00:19:14,640 --> 00:19:19,440
just not going to work

00:19:15,600 --> 00:19:22,320
right i'm going to need to deploy that

00:19:19,440 --> 00:19:25,520
in the cloud where i can have more hefty

00:19:22,320 --> 00:19:28,960
compute power

00:19:25,520 --> 00:19:32,080
and finally you know code reuse

00:19:28,960 --> 00:19:35,200
and performance are really nice

00:19:32,080 --> 00:19:37,120
and all but it's also important that we

00:19:35,200 --> 00:19:39,600
consider the complexity

00:19:37,120 --> 00:19:40,320
the webassembly adds to our code base to

00:19:39,600 --> 00:19:43,520
our build

00:19:40,320 --> 00:19:46,720
process but also to

00:19:43,520 --> 00:19:50,080
the maintainability of the code

00:19:46,720 --> 00:19:52,320
for your entire team

00:19:50,080 --> 00:19:54,160
right it's it's a bit hard to give

00:19:52,320 --> 00:19:56,000
concrete examples here because this will

00:19:54,160 --> 00:19:57,840
really depend on your team and how

00:19:56,000 --> 00:19:59,120
comfortable they they are with

00:19:57,840 --> 00:20:02,240
with introducing something like

00:19:59,120 --> 00:20:05,440
webassembly but at the end of the day

00:20:02,240 --> 00:20:07,520
webassembly is a really powerful tool

00:20:05,440 --> 00:20:09,360
you just have to make sure that the

00:20:07,520 --> 00:20:12,960
added complexity

00:20:09,360 --> 00:20:12,960
is worth it for your application

00:20:13,840 --> 00:20:18,000
all right so that's all i had to share

00:20:16,320 --> 00:20:19,760
please check out my book if you're

00:20:18,000 --> 00:20:22,400
just getting started with webassembly

00:20:19,760 --> 00:20:24,400
and you're looking for a practical guide

00:20:22,400 --> 00:20:26,000
i also have a whole bunch of other

00:20:24,400 --> 00:20:28,960
articles and videos

00:20:26,000 --> 00:20:29,520
that you can check out and with that i

00:20:28,960 --> 00:20:33,600
want to

00:20:29,520 --> 00:20:33,600

YouTube URL: https://www.youtube.com/watch?v=IB-CNg3b9EM


