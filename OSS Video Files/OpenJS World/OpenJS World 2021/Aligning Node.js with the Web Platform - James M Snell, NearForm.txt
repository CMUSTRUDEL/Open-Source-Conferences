Title: Aligning Node.js with the Web Platform - James M Snell, NearForm
Publication date: 2021-05-28
Playlist: OpenJS World 2021
Description: 
	There's always been an argument that Node.js is not a Web Browser and therefore shouldn't act like one, and while that's true in many respects, there's still significant benefit in ensuring that JavaScript that works in the browser works the same way on the server. In recent years a great deal of effort has gone into aligning Node.js with the Web Platform, including implementation of the WHATWG URL API, TextEncoder, Intl, and more. Node.js 15 has moved even closer with the addition of EventTarget, AbortController, and the Web Crypto API. This talk will introduce developers to the new Web Platform superpowers that are now built in to Node.js and pull the curtain back on ongoing efforts for what may be coming in the near future.
Captions: 
	00:00:01,520 --> 00:00:06,480
hello everyone i am james snell

00:00:03,919 --> 00:00:08,080
i hope you are enjoying your openjs

00:00:06,480 --> 00:00:11,360
world so far

00:00:08,080 --> 00:00:14,480
um i am here to talk to you about

00:00:11,360 --> 00:00:17,039
aligning node.js with the web platform

00:00:14,480 --> 00:00:17,760
a little about me first uh i am the head

00:00:17,039 --> 00:00:20,960
of research

00:00:17,760 --> 00:00:21,840
at near form a consultancy uh services

00:00:20,960 --> 00:00:24,800
provider

00:00:21,840 --> 00:00:25,599
uh that focuses primarily on node react

00:00:24,800 --> 00:00:29,039
native

00:00:25,599 --> 00:00:30,080
uh that entire uh entire related stack

00:00:29,039 --> 00:00:32,320
of technologies

00:00:30,080 --> 00:00:34,160
i am a core contributor to the node

00:00:32,320 --> 00:00:36,000
project i'm a technical steering

00:00:34,160 --> 00:00:38,000
committee member there and i've

00:00:36,000 --> 00:00:40,239
contributed quite a few things to

00:00:38,000 --> 00:00:42,399
to to that platform over the years the

00:00:40,239 --> 00:00:43,440
url implementation text encoder text

00:00:42,399 --> 00:00:47,840
decoder

00:00:43,440 --> 00:00:50,160
performance hooks um web crypto api hp2

00:00:47,840 --> 00:00:51,920
and most recently i've been working on

00:00:50,160 --> 00:00:55,039
an implementation of the new quick

00:00:51,920 --> 00:00:57,600
protocol um if you look at

00:00:55,039 --> 00:00:58,079
back at the contributions that i have

00:00:57,600 --> 00:01:00,800
made

00:00:58,079 --> 00:01:03,680
you'll see that there is a common theme

00:01:00,800 --> 00:01:07,760
a lot of it has to do with aligning

00:01:03,680 --> 00:01:09,360
node to the the the to the web platform

00:01:07,760 --> 00:01:12,240
uh and there's a you know when i started

00:01:09,360 --> 00:01:14,159
with node uh back in 2015

00:01:12,240 --> 00:01:15,600
there was a common reframe that we would

00:01:14,159 --> 00:01:16,799
hear from a lot of the node core

00:01:15,600 --> 00:01:19,920
contributors

00:01:16,799 --> 00:01:21,439
uh that this assertion that node is not

00:01:19,920 --> 00:01:23,759
a web browser

00:01:21,439 --> 00:01:25,200
uh it shouldn't act like a web browser

00:01:23,759 --> 00:01:28,400
it shouldn't have the same

00:01:25,200 --> 00:01:30,720
things that a web browser has um

00:01:28,400 --> 00:01:33,600
that there is this what i call this gulf

00:01:30,720 --> 00:01:35,759
of unsameness that existed between

00:01:33,600 --> 00:01:36,880
uh you know node.js as a javascript

00:01:35,759 --> 00:01:39,360
runtime and

00:01:36,880 --> 00:01:40,479
the javascript that you would run in in

00:01:39,360 --> 00:01:43,759
browsers

00:01:40,479 --> 00:01:44,320
and and want to a large extent that is

00:01:43,759 --> 00:01:46,159
true

00:01:44,320 --> 00:01:47,439
uh you know node doesn't do rendering of

00:01:46,159 --> 00:01:50,560
web pages for instance

00:01:47,439 --> 00:01:55,119
um there

00:01:50,560 --> 00:01:55,439
is there is an area of overlap that it

00:01:55,119 --> 00:01:58,719
does

00:01:55,439 --> 00:02:01,439
that does exist this gulf of unsameness

00:01:58,719 --> 00:02:02,799
this this idea that these are completely

00:02:01,439 --> 00:02:04,159
different environments

00:02:02,799 --> 00:02:05,840
that they should operate in different

00:02:04,159 --> 00:02:08,239
ways they should do things

00:02:05,840 --> 00:02:09,440
differently it's actually fundamentally

00:02:08,239 --> 00:02:12,879
wrong

00:02:09,440 --> 00:02:13,200
um there is an area of overlap um there

00:02:12,879 --> 00:02:16,400
are

00:02:13,200 --> 00:02:19,520
things that both browsers and node do

00:02:16,400 --> 00:02:21,680
right um uh uh crypto

00:02:19,520 --> 00:02:24,160
is is a good example of this you know

00:02:21,680 --> 00:02:26,640
you may want to encrypt or decrypt some

00:02:24,160 --> 00:02:29,040
bit of information in both environments

00:02:26,640 --> 00:02:31,519
um you may want to encode from

00:02:29,040 --> 00:02:35,360
you know some bit of text from you know

00:02:31,519 --> 00:02:37,760
utf-8 to utf-16 or whatever

00:02:35,360 --> 00:02:39,200
in both environments right you might

00:02:37,760 --> 00:02:42,239
want to generate a

00:02:39,200 --> 00:02:42,879
uuid in both environments there are

00:02:42,239 --> 00:02:45,440
things

00:02:42,879 --> 00:02:46,400
that you know there are common tasks

00:02:45,440 --> 00:02:49,519
that you're going to do

00:02:46,400 --> 00:02:52,879
in both of these places so

00:02:49,519 --> 00:02:53,760
the idea of aligning nodes the web

00:02:52,879 --> 00:02:56,879
platform

00:02:53,760 --> 00:03:00,080
is really about finding those areas of

00:02:56,879 --> 00:03:02,800
commonality those areas of overlap

00:03:00,080 --> 00:03:03,200
where you know you you might have to do

00:03:02,800 --> 00:03:06,159
one

00:03:03,200 --> 00:03:08,480
thing you know encrypt some data but you

00:03:06,159 --> 00:03:10,959
don't want to have to do it

00:03:08,480 --> 00:03:11,599
in two completely different ways or you

00:03:10,959 --> 00:03:13,200
know worse

00:03:11,599 --> 00:03:15,040
three or four or five completely

00:03:13,200 --> 00:03:16,480
different ways right depending on

00:03:15,040 --> 00:03:18,159
you know where your javascript happens

00:03:16,480 --> 00:03:21,440
to be running

00:03:18,159 --> 00:03:24,560
so you know what we want to do is

00:03:21,440 --> 00:03:26,640
find the commonalities and look at the

00:03:24,560 --> 00:03:29,040
apis and figure out

00:03:26,640 --> 00:03:30,400
where it makes the most sense to bring

00:03:29,040 --> 00:03:31,840
those together

00:03:30,400 --> 00:03:33,440
now whenever this question comes up

00:03:31,840 --> 00:03:35,200
whenever this discussion comes up about

00:03:33,440 --> 00:03:36,319
you know aligning node with the web

00:03:35,200 --> 00:03:39,680
platform

00:03:36,319 --> 00:03:43,280
um there there is often criticism

00:03:39,680 --> 00:03:45,360
uh as to where does that stop right

00:03:43,280 --> 00:03:47,200
are we going to implement everything

00:03:45,360 --> 00:03:49,040
that you find in browsers

00:03:47,200 --> 00:03:50,159
in node and i just want to pop over and

00:03:49,040 --> 00:03:51,680
look at this real quick if you look at

00:03:50,159 --> 00:03:55,680
the mdn page

00:03:51,680 --> 00:03:56,400
for web apis these are all of the apis

00:03:55,680 --> 00:03:59,519
that are

00:03:56,400 --> 00:04:03,280
that are available in web browsers today

00:03:59,519 --> 00:04:06,000
what you'll find is there is a massive

00:04:03,280 --> 00:04:07,439
massive number of of object types of

00:04:06,000 --> 00:04:10,959
interfaces

00:04:07,439 --> 00:04:13,120
uh of um you know different apis that do

00:04:10,959 --> 00:04:16,479
different things svg

00:04:13,120 --> 00:04:20,239
manipulation html uh

00:04:16,479 --> 00:04:24,720
uh dom access uh you have in here

00:04:20,239 --> 00:04:28,080
uh time ranges for timing events

00:04:24,720 --> 00:04:31,199
uh you have a local storage you have

00:04:28,080 --> 00:04:33,919
video playback uh even you know new

00:04:31,199 --> 00:04:34,880
apis for virtual reality display events

00:04:33,919 --> 00:04:37,360
right

00:04:34,880 --> 00:04:39,479
you have all of these apis that exist

00:04:37,360 --> 00:04:42,560
within the browsers to do these

00:04:39,479 --> 00:04:45,199
extremely rich user interface

00:04:42,560 --> 00:04:47,040
user interaction types of types of

00:04:45,199 --> 00:04:49,840
applications

00:04:47,040 --> 00:04:50,960
and so the question very naturally comes

00:04:49,840 --> 00:04:53,120
up

00:04:50,960 --> 00:04:55,440
do all of these apis make sense to

00:04:53,120 --> 00:04:59,280
implement in node

00:04:55,440 --> 00:05:02,320
and the answer clearly emphatically

00:04:59,280 --> 00:05:04,400
and absolutely is no

00:05:02,320 --> 00:05:07,039
there's never going to be a time where

00:05:04,400 --> 00:05:10,160
we will actively go through and make

00:05:07,039 --> 00:05:11,919
node do everything that a browser does

00:05:10,160 --> 00:05:14,479
uh there will never be a time where it

00:05:11,919 --> 00:05:16,800
implements you know all of these apis

00:05:14,479 --> 00:05:18,720
built into the core of node it's just

00:05:16,800 --> 00:05:22,000
never going to happen

00:05:18,720 --> 00:05:24,880
but what is happening what we are doing

00:05:22,000 --> 00:05:26,720
are finding the areas of overlap finding

00:05:24,880 --> 00:05:27,360
the areas where these things are similar

00:05:26,720 --> 00:05:30,080
enough

00:05:27,360 --> 00:05:31,759
or where you're doing the same task and

00:05:30,080 --> 00:05:33,120
you want to be able to write some bit of

00:05:31,759 --> 00:05:35,039
javascript

00:05:33,120 --> 00:05:37,280
that works in them in all these

00:05:35,039 --> 00:05:39,759
different environments

00:05:37,280 --> 00:05:40,560
so this talk is uh this this is really a

00:05:39,759 --> 00:05:43,360
follow-on

00:05:40,560 --> 00:05:44,000
to a talk i gave previously at another

00:05:43,360 --> 00:05:46,400
event

00:05:44,000 --> 00:05:47,520
where i introduced some of the apis that

00:05:46,400 --> 00:05:52,160
we were working on

00:05:47,520 --> 00:05:53,680
uh within node uh that really speak to

00:05:52,160 --> 00:05:55,199
this alignment

00:05:53,680 --> 00:05:56,960
and you know here i just want to touch

00:05:55,199 --> 00:06:00,319
on a few brief examples

00:05:56,960 --> 00:06:03,039
but then dive deeper into a specific

00:06:00,319 --> 00:06:04,560
set of apis that are leading us closer

00:06:03,039 --> 00:06:07,759
and closer towards a

00:06:04,560 --> 00:06:11,280
node core implementation of the fetch

00:06:07,759 --> 00:06:13,120
api that exists in browsers today

00:06:11,280 --> 00:06:14,560
so let me take a step back in just a

00:06:13,120 --> 00:06:17,840
little bit and let's look at where

00:06:14,560 --> 00:06:19,759
we have been look at where we are

00:06:17,840 --> 00:06:21,600
now and then look at where we are going

00:06:19,759 --> 00:06:24,560
with these apis

00:06:21,600 --> 00:06:27,039
uh it was a number of years ago um now

00:06:24,560 --> 00:06:28,240
that we introduced the what wg url

00:06:27,039 --> 00:06:31,440
parser

00:06:28,240 --> 00:06:34,639
uh and and really this was the first

00:06:31,440 --> 00:06:36,479
of the web platform apis uh when i meet

00:06:34,639 --> 00:06:38,479
when i say web platform i mean

00:06:36,479 --> 00:06:40,160
additional apis that are not part of

00:06:38,479 --> 00:06:42,880
javascript the language

00:06:40,160 --> 00:06:43,759
itself all right these are apis that are

00:06:42,880 --> 00:06:47,360
defined

00:06:43,759 --> 00:06:50,080
externally to tc39 uh whether it's

00:06:47,360 --> 00:06:52,000
uh in browsers whether it's part of w3c

00:06:50,080 --> 00:06:54,319
whether it's part of the what wg

00:06:52,000 --> 00:06:56,639
all these other area you know other

00:06:54,319 --> 00:06:58,639
venues where these apis are created that

00:06:56,639 --> 00:07:01,599
they typically would go into the browser

00:06:58,639 --> 00:07:04,560
but aren't part of the language itself

00:07:01,599 --> 00:07:05,199
url was our first example of this uh and

00:07:04,560 --> 00:07:08,560
and

00:07:05,199 --> 00:07:12,240
really the the motivation behind

00:07:08,560 --> 00:07:15,360
behind adding the url uh uh api

00:07:12,240 --> 00:07:16,720
was that the existing url parse that

00:07:15,360 --> 00:07:20,400
existing api

00:07:16,720 --> 00:07:23,520
in node for parsing urls actually has

00:07:20,400 --> 00:07:25,599
a number of fundamental bugs

00:07:23,520 --> 00:07:28,560
in terms of how it is handling things

00:07:25,599 --> 00:07:32,560
like usernames and passwords

00:07:28,560 --> 00:07:35,919
how it handles certain edge cases um

00:07:32,560 --> 00:07:38,319
and how the url is structured um

00:07:35,919 --> 00:07:40,240
and the implementation has been so

00:07:38,319 --> 00:07:44,160
performance optimized

00:07:40,240 --> 00:07:44,720
that is it is extremely difficult to

00:07:44,160 --> 00:07:48,000
make

00:07:44,720 --> 00:07:49,759
changes to fix bugs without

00:07:48,000 --> 00:07:52,639
negatively impacting the performance

00:07:49,759 --> 00:07:54,560
optimization that's there

00:07:52,639 --> 00:07:56,639
for example you know when i originally

00:07:54,560 --> 00:07:59,199
tried to fix the parsing of the username

00:07:56,639 --> 00:08:00,800
and password uh it ended up being

00:07:59,199 --> 00:08:03,039
something like a 75 performance

00:08:00,800 --> 00:08:05,120
reduction percep

00:08:03,039 --> 00:08:06,560
reduction in performance of just the

00:08:05,120 --> 00:08:09,599
typical

00:08:06,560 --> 00:08:11,039
pricing operation um it's the kind of

00:08:09,599 --> 00:08:13,120
code that if you look at it wrong

00:08:11,039 --> 00:08:14,160
it slows down so you know i really

00:08:13,120 --> 00:08:17,599
wanted to just kind of

00:08:14,160 --> 00:08:19,680
leave that existing url parser alone

00:08:17,599 --> 00:08:20,720
and not touch it anymore but we still

00:08:19,680 --> 00:08:25,520
needed a way

00:08:20,720 --> 00:08:27,919
of parsing correctly without the bugs

00:08:25,520 --> 00:08:28,639
and about this time i started looking at

00:08:27,919 --> 00:08:30,879
well

00:08:28,639 --> 00:08:32,399
what if we just use the same api that's

00:08:30,879 --> 00:08:35,360
in the browser

00:08:32,399 --> 00:08:36,080
what if we just introduced a new parser

00:08:35,360 --> 00:08:39,360
and had it be

00:08:36,080 --> 00:08:42,159
a standard interface so you could do new

00:08:39,360 --> 00:08:42,800
url in the browser and you could do new

00:08:42,159 --> 00:08:44,880
url

00:08:42,800 --> 00:08:45,920
in node and it would just work the same

00:08:44,880 --> 00:08:48,720
way

00:08:45,920 --> 00:08:50,320
uh this actually ended up being fairly

00:08:48,720 --> 00:08:51,760
controversial

00:08:50,320 --> 00:08:53,920
uh you know i actually had you know you

00:08:51,760 --> 00:08:55,839
know some of the other node core

00:08:53,920 --> 00:08:59,200
contributors up in arms about

00:08:55,839 --> 00:09:02,000
this idea that we would have this second

00:08:59,200 --> 00:09:02,320
you know different way of parsing a url

00:09:02,000 --> 00:09:03,839
what

00:09:02,320 --> 00:09:05,600
what would we do with the existing one

00:09:03,839 --> 00:09:07,200
what would we do with url parse would

00:09:05,600 --> 00:09:07,600
that go away would that be removed would

00:09:07,200 --> 00:09:10,000
code

00:09:07,600 --> 00:09:11,200
subtly stop breaking and the answer was

00:09:10,000 --> 00:09:14,560
no this is just

00:09:11,200 --> 00:09:16,080
an additional way of parsing urls in

00:09:14,560 --> 00:09:18,880
node

00:09:16,080 --> 00:09:19,440
uh today it is fully spec compliant it

00:09:18,880 --> 00:09:22,320
it you know

00:09:19,440 --> 00:09:25,360
new url is the recommended uh kind of

00:09:22,320 --> 00:09:27,680
default way of handling urls in node

00:09:25,360 --> 00:09:28,640
um we've verified the implementation on

00:09:27,680 --> 00:09:31,600
the same

00:09:28,640 --> 00:09:32,000
web platform tests that the browsers use

00:09:31,600 --> 00:09:35,120
uh

00:09:32,000 --> 00:09:37,200
we know we are we are spec compliant uh

00:09:35,120 --> 00:09:39,040
in fact you know it it i'm proud to say

00:09:37,200 --> 00:09:41,600
that node is even more

00:09:39,040 --> 00:09:43,519
spec compliant on on urls than the

00:09:41,600 --> 00:09:46,080
chrome browser is

00:09:43,519 --> 00:09:47,839
so you know it it it's it's been a while

00:09:46,080 --> 00:09:50,880
uh it's been a while coming

00:09:47,839 --> 00:09:51,360
but you know new url is now the de facto

00:09:50,880 --> 00:09:53,440
way

00:09:51,360 --> 00:09:56,720
the fact of standard way of handling

00:09:53,440 --> 00:09:59,120
urls in in in node

00:09:56,720 --> 00:10:00,880
uh but that was the first step right um

00:09:59,120 --> 00:10:02,959
uh there were you know as we just saw in

00:10:00,880 --> 00:10:05,839
the mba there's so many more apis

00:10:02,959 --> 00:10:06,959
what other apis have uh makes sense to

00:10:05,839 --> 00:10:10,640
implement

00:10:06,959 --> 00:10:13,920
well uh text encoder and text encoder

00:10:10,640 --> 00:10:14,800
you know being able to handle text uh

00:10:13,920 --> 00:10:18,079
and convert

00:10:14,800 --> 00:10:19,200
from multiple character encodings is

00:10:18,079 --> 00:10:23,040
something that you're going to be

00:10:19,200 --> 00:10:24,880
doing in both environments node uh uh

00:10:23,040 --> 00:10:26,480
or in the browser server side client

00:10:24,880 --> 00:10:27,760
site it doesn't matter you have to be

00:10:26,480 --> 00:10:29,279
able to handle text

00:10:27,760 --> 00:10:32,000
text encoder and text code were the

00:10:29,279 --> 00:10:34,399
second kind of standard browser apis

00:10:32,000 --> 00:10:35,760
that were added to node uh and you know

00:10:34,399 --> 00:10:38,000
and and those went in

00:10:35,760 --> 00:10:39,120
much quieter than url it was much less

00:10:38,000 --> 00:10:41,200
controversial

00:10:39,120 --> 00:10:43,120
i think you know we we finally got that

00:10:41,200 --> 00:10:44,240
you know that first one done so the next

00:10:43,120 --> 00:10:47,440
ones after that

00:10:44,240 --> 00:10:48,320
um yeah came much more naturally after

00:10:47,440 --> 00:10:52,000
that

00:10:48,320 --> 00:10:53,920
uh the worker threats api uh

00:10:52,000 --> 00:10:56,720
was added thanks to a tremendous amount

00:10:53,920 --> 00:11:00,160
of um effort from uh anna henningsen

00:10:56,720 --> 00:11:01,760
uh you know who who basically just said

00:11:00,160 --> 00:11:03,200
you know it's happening right you know

00:11:01,760 --> 00:11:04,640
worker thread is going to be there it's

00:11:03,200 --> 00:11:05,760
going to implement the standard apis as

00:11:04,640 --> 00:11:07,279
much as possible

00:11:05,760 --> 00:11:08,880
um we're going to have message channel

00:11:07,279 --> 00:11:11,200
we're going to have message ports for

00:11:08,880 --> 00:11:12,079
uh for passing messages back back and

00:11:11,200 --> 00:11:15,120
forth

00:11:12,079 --> 00:11:16,480
and it was just all going to work now

00:11:15,120 --> 00:11:18,480
the worker threads api

00:11:16,480 --> 00:11:19,680
does not match exactly workers in the

00:11:18,480 --> 00:11:22,480
browser there are

00:11:19,680 --> 00:11:23,680
a number of important differences but in

00:11:22,480 --> 00:11:25,920
the primitive

00:11:23,680 --> 00:11:27,760
apis that are part of it like message

00:11:25,920 --> 00:11:31,200
channel and message port

00:11:27,760 --> 00:11:33,040
those the apis and the way that they

00:11:31,200 --> 00:11:34,399
operate is exactly the same as in the

00:11:33,040 --> 00:11:36,320
browser

00:11:34,399 --> 00:11:37,839
so you can pass messages back and forth

00:11:36,320 --> 00:11:40,399
across threads

00:11:37,839 --> 00:11:42,399
uh you have uh the structured cloning

00:11:40,399 --> 00:11:42,880
where objects either are cloned or

00:11:42,399 --> 00:11:46,160
caught

00:11:42,880 --> 00:11:48,959
or transferred uh over between

00:11:46,160 --> 00:11:50,079
all of that just works now in node using

00:11:48,959 --> 00:11:52,800
the same apis

00:11:50,079 --> 00:11:54,240
the same mechanisms that that exist in

00:11:52,800 --> 00:11:56,480
the browser

00:11:54,240 --> 00:11:58,160
more recently i also added the broadcast

00:11:56,480 --> 00:11:59,760
channel which is which is fairly new to

00:11:58,160 --> 00:12:02,399
browsers as well

00:11:59,760 --> 00:12:03,360
that gives you a one-to-many uh

00:12:02,399 --> 00:12:05,120
messaging model

00:12:03,360 --> 00:12:06,800
whereas message channel and message port

00:12:05,120 --> 00:12:11,040
is always one-to-one

00:12:06,800 --> 00:12:12,880
uh broadcast channel every uh uh

00:12:11,040 --> 00:12:15,360
every instance of a broadcast channel

00:12:12,880 --> 00:12:17,920
that that is listening to the same id

00:12:15,360 --> 00:12:20,000
can receive a copy of the message uh uh

00:12:17,920 --> 00:12:23,360
it gives just a little more flexible

00:12:20,000 --> 00:12:25,200
uh messaging model uh uh you know when

00:12:23,360 --> 00:12:27,920
you're dealing with multiple threads

00:12:25,200 --> 00:12:30,079
but it's the same api that exists in

00:12:27,920 --> 00:12:33,760
browsers today

00:12:30,079 --> 00:12:35,680
um a couple of other critical ones

00:12:33,760 --> 00:12:37,360
include event target and abort

00:12:35,680 --> 00:12:39,680
controller

00:12:37,360 --> 00:12:41,600
event target has existed in in in

00:12:39,680 --> 00:12:44,240
browsers pretty much forever

00:12:41,600 --> 00:12:45,040
uh node has always had its own event

00:12:44,240 --> 00:12:48,000
emitter

00:12:45,040 --> 00:12:48,800
which was similar did essentially the

00:12:48,000 --> 00:12:51,360
same thing

00:12:48,800 --> 00:12:52,399
but and then but was you know almost

00:12:51,360 --> 00:12:55,600
entirely different

00:12:52,399 --> 00:12:56,160
uh than event target uh you know so we

00:12:55,600 --> 00:12:59,360
had

00:12:56,160 --> 00:13:02,160
this event model in both environments

00:12:59,360 --> 00:13:03,680
but you know the the the way it worked

00:13:02,160 --> 00:13:08,160
the various nuances between

00:13:03,680 --> 00:13:10,720
between two very very dissimilar

00:13:08,160 --> 00:13:10,720
apis

00:13:11,360 --> 00:13:15,120
for the longest time the fact that event

00:13:13,200 --> 00:13:19,200
emitter existed in node

00:13:15,120 --> 00:13:21,120
was a reason not to have event target

00:13:19,200 --> 00:13:22,800
why would we want to have a second way

00:13:21,120 --> 00:13:25,519
of handling events

00:13:22,800 --> 00:13:26,079
um and eventually we just got to the

00:13:25,519 --> 00:13:29,200
point

00:13:26,079 --> 00:13:33,200
where why not have it um

00:13:29,200 --> 00:13:36,000
it's it it's not difficult to do

00:13:33,200 --> 00:13:37,360
the api is there it can be available it

00:13:36,000 --> 00:13:40,800
can be used

00:13:37,360 --> 00:13:43,440
why not just you know have that same api

00:13:40,800 --> 00:13:44,639
available as long as event emitter was

00:13:43,440 --> 00:13:46,000
isn't going anywhere

00:13:44,639 --> 00:13:47,680
which is not it's still going to be a

00:13:46,000 --> 00:13:49,760
note it's still supported

00:13:47,680 --> 00:13:51,839
it's still one of the core apis and it

00:13:49,760 --> 00:13:54,639
is still the most commonly used

00:13:51,839 --> 00:13:56,320
one of the most broadly used apis in in

00:13:54,639 --> 00:13:58,480
the entire node ecosystem

00:13:56,320 --> 00:14:00,639
nothing is happening to event emitter

00:13:58,480 --> 00:14:03,519
but now we have event target there

00:14:00,639 --> 00:14:04,800
and we can use that same event model

00:14:03,519 --> 00:14:07,839
that exists in browsers

00:14:04,800 --> 00:14:09,519
in node that is important because of a

00:14:07,839 --> 00:14:12,480
board controller

00:14:09,519 --> 00:14:12,959
a board controller is a way of allowing

00:14:12,480 --> 00:14:16,399
us to

00:14:12,959 --> 00:14:17,440
inject a signal to cancel asynchronous

00:14:16,399 --> 00:14:19,199
operations

00:14:17,440 --> 00:14:20,639
board controller became popular as part

00:14:19,199 --> 00:14:22,800
of the fetch api

00:14:20,639 --> 00:14:23,839
in browsers where you could start a

00:14:22,800 --> 00:14:25,680
request

00:14:23,839 --> 00:14:28,800
and then use the abort controller to

00:14:25,680 --> 00:14:31,760
cancel that prematurely if necessary

00:14:28,800 --> 00:14:32,720
it's paired with a uh with another

00:14:31,760 --> 00:14:36,079
interface

00:14:32,720 --> 00:14:38,560
called abort signal and you create it

00:14:36,079 --> 00:14:40,079
you have a signal signal itself is an

00:14:38,560 --> 00:14:43,199
implementation of event

00:14:40,079 --> 00:14:46,720
target so it has an an abort

00:14:43,199 --> 00:14:50,000
event when you call the abort method

00:14:46,720 --> 00:14:52,800
on the abort controller it will trigger

00:14:50,000 --> 00:14:53,279
a event to be dispatched on the abort

00:14:52,800 --> 00:14:58,079
signal

00:14:53,279 --> 00:15:00,959
object causing that event to be fired

00:14:58,079 --> 00:15:02,639
that has become the as now and this is

00:15:00,959 --> 00:15:03,839
recent within the past year

00:15:02,639 --> 00:15:06,320
the board controller and abort signal

00:15:03,839 --> 00:15:09,360
have become the de facto way of

00:15:06,320 --> 00:15:10,079
canceling asynchronous operations that

00:15:09,360 --> 00:15:13,279
are happening

00:15:10,079 --> 00:15:14,880
in node and we now have support for uh

00:15:13,279 --> 00:15:17,360
using a board controller in child

00:15:14,880 --> 00:15:20,639
process process event target file system

00:15:17,360 --> 00:15:24,079
http net read line and rupple uh

00:15:20,639 --> 00:15:28,160
streams api awaitable timers udp

00:15:24,079 --> 00:15:30,639
in dram and and and more kind of um

00:15:28,160 --> 00:15:31,680
in terms of where you'll see support for

00:15:30,639 --> 00:15:35,120
that api

00:15:31,680 --> 00:15:38,720
uh uh uh being implemented

00:15:35,120 --> 00:15:40,480
so this this browser api

00:15:38,720 --> 00:15:41,759
right this thing that originated as part

00:15:40,480 --> 00:15:44,959
of fetch

00:15:41,759 --> 00:15:48,720
has now become a critical component

00:15:44,959 --> 00:15:50,399
of the node api um you know because

00:15:48,720 --> 00:15:52,160
you know it serves a very important

00:15:50,399 --> 00:15:54,959
purpose and it's something that we need

00:15:52,160 --> 00:15:55,839
in both places browsers and and on note

00:15:54,959 --> 00:15:58,240
so it's something that

00:15:55,839 --> 00:15:58,959
just made sense to implement i do want

00:15:58,240 --> 00:16:01,279
to point out

00:15:58,959 --> 00:16:02,720
um you know yeah there are some tricks

00:16:01,279 --> 00:16:04,399
to using a board controller there are

00:16:02,720 --> 00:16:06,560
some things you need to know

00:16:04,399 --> 00:16:08,240
and very soon i am and i have a blog

00:16:06,560 --> 00:16:09,120
post coming out you know you know here's

00:16:08,240 --> 00:16:10,480
just a draft

00:16:09,120 --> 00:16:12,880
i'm going to have a blog post coming out

00:16:10,480 --> 00:16:15,040
on the near form blog going to detail on

00:16:12,880 --> 00:16:16,399
how to use the abort signal in a board

00:16:15,040 --> 00:16:19,519
controller correctly

00:16:16,399 --> 00:16:20,959
so keep an eye out for that uh uh

00:16:19,519 --> 00:16:23,759
you know i i think it's going to be

00:16:20,959 --> 00:16:25,519
useful so switching back here

00:16:23,759 --> 00:16:26,800
you know going on some of the other

00:16:25,519 --> 00:16:28,320
things that we have done we've

00:16:26,800 --> 00:16:30,959
implemented the performance

00:16:28,320 --> 00:16:35,320
api from browsers in node right so you

00:16:30,959 --> 00:16:37,360
have what's called the user timing api

00:16:35,320 --> 00:16:38,399
performance.now for getting the current

00:16:37,360 --> 00:16:42,240
time

00:16:38,399 --> 00:16:44,720
um uh this performance observer object

00:16:42,240 --> 00:16:47,759
uh that allows you to listen to you know

00:16:44,720 --> 00:16:50,800
for performance related events

00:16:47,759 --> 00:16:51,920
um you have this performance mark and

00:16:50,800 --> 00:16:54,959
performance measure

00:16:51,920 --> 00:16:58,320
these are all apis that originated in br

00:16:54,959 --> 00:17:02,240
in the browsers for measuring um

00:16:58,320 --> 00:17:04,400
performance related events that occur

00:17:02,240 --> 00:17:06,640
um a couple of years it was a couple of

00:17:04,400 --> 00:17:08,400
years ago now that i decided just to go

00:17:06,640 --> 00:17:12,400
ahead and implement this for node

00:17:08,400 --> 00:17:16,160
and and and make it possible to

00:17:12,400 --> 00:17:19,679
use these common primitive apis

00:17:16,160 --> 00:17:20,559
to to do very simple performance

00:17:19,679 --> 00:17:22,799
measurements

00:17:20,559 --> 00:17:24,799
within node itself previously to this

00:17:22,799 --> 00:17:26,400
you know folks had to go up and use

00:17:24,799 --> 00:17:29,520
dependency libraries for

00:17:26,400 --> 00:17:29,760
injecting uh instrumentation for you

00:17:29,520 --> 00:17:32,000
know

00:17:29,760 --> 00:17:33,360
measuring how long it would take to run

00:17:32,000 --> 00:17:34,880
a particular function

00:17:33,360 --> 00:17:36,559
right there's you know dependency

00:17:34,880 --> 00:17:40,400
libraries out there for benchmarks

00:17:36,559 --> 00:17:42,799
uh for uh you know apms out there for

00:17:40,400 --> 00:17:43,760
inject this functionality with the

00:17:42,799 --> 00:17:46,720
introduction of

00:17:43,760 --> 00:17:47,280
the performance api as a module in node

00:17:46,720 --> 00:17:50,640
it's part

00:17:47,280 --> 00:17:54,320
what's called perforce right the basic

00:17:50,640 --> 00:17:56,240
mechanisms for doing very primitive

00:17:54,320 --> 00:17:57,360
very rudimentary performance

00:17:56,240 --> 00:18:00,400
measurements

00:17:57,360 --> 00:18:03,120
are there as part of the platform now

00:18:00,400 --> 00:18:04,960
and are there ready to be used without

00:18:03,120 --> 00:18:06,480
any dependencies needed

00:18:04,960 --> 00:18:08,400
all right so it's all there and it's the

00:18:06,480 --> 00:18:10,320
com same api that you would find in the

00:18:08,400 --> 00:18:12,640
browser

00:18:10,320 --> 00:18:13,360
all right so you know this has been a

00:18:12,640 --> 00:18:15,440
slow march

00:18:13,360 --> 00:18:17,280
this has taken you know you know several

00:18:15,440 --> 00:18:19,360
years to get to the point where

00:18:17,280 --> 00:18:20,720
you know we've only implemented a a

00:18:19,360 --> 00:18:23,039
limited handful

00:18:20,720 --> 00:18:23,919
of the apis that are that exist in the

00:18:23,039 --> 00:18:28,000
browsers

00:18:23,919 --> 00:18:29,440
but it's a very powerful set of apis uh

00:18:28,000 --> 00:18:31,840
it enables

00:18:29,440 --> 00:18:33,440
uh uh quite a bit um you know we have

00:18:31,840 --> 00:18:34,480
the message passing you know for working

00:18:33,440 --> 00:18:36,480
with multiple threads

00:18:34,480 --> 00:18:38,160
we have an implementation of the web

00:18:36,480 --> 00:18:40,320
crypto api

00:18:38,160 --> 00:18:42,240
so if you want to digitally sign

00:18:40,320 --> 00:18:44,799
something or decrypt something

00:18:42,240 --> 00:18:46,480
right you can do it the same way now in

00:18:44,799 --> 00:18:48,240
node as you do in the browsers

00:18:46,480 --> 00:18:50,480
you can write that code once and it

00:18:48,240 --> 00:18:51,600
works in both places

00:18:50,480 --> 00:18:53,919
without you know without any

00:18:51,600 --> 00:18:57,039
modification

00:18:53,919 --> 00:18:59,280
um so you know that just that just this

00:18:57,039 --> 00:19:00,240
with this limited city set of apis that

00:18:59,280 --> 00:19:03,120
exists

00:19:00,240 --> 00:19:04,880
so far it's already very powerful in

00:19:03,120 --> 00:19:08,000
what you can accomplish in terms of

00:19:04,880 --> 00:19:10,160
writing clear consistent code that just

00:19:08,000 --> 00:19:11,679
works across these several different

00:19:10,160 --> 00:19:13,200
environments

00:19:11,679 --> 00:19:14,880
but there's more to do there's more to

00:19:13,200 --> 00:19:16,880
come um and

00:19:14,880 --> 00:19:18,320
and one of the things that we get asked

00:19:16,880 --> 00:19:21,200
about the most

00:19:18,320 --> 00:19:23,440
uh the one api that i think that that

00:19:21,200 --> 00:19:26,559
you know that we've consistently seen

00:19:23,440 --> 00:19:27,760
folks ask for time and time again is

00:19:26,559 --> 00:19:30,960
fetch

00:19:27,760 --> 00:19:31,840
now fetch is such a simple it's just a

00:19:30,960 --> 00:19:35,280
method

00:19:31,840 --> 00:19:39,679
that triggers an http request

00:19:35,280 --> 00:19:42,000
right it returns a promise that

00:19:39,679 --> 00:19:42,960
resolves that promise fulfills when that

00:19:42,000 --> 00:19:45,120
hp request

00:19:42,960 --> 00:19:47,600
has been completed all right so you want

00:19:45,120 --> 00:19:48,480
to go fetch a a document you want to go

00:19:47,600 --> 00:19:50,080
get an image

00:19:48,480 --> 00:19:52,400
um you want to go to a server and get it

00:19:50,080 --> 00:19:54,799
get a page return that content

00:19:52,400 --> 00:19:55,760
right so you call fetch pass in the

00:19:54,799 --> 00:19:57,760
request

00:19:55,760 --> 00:19:59,360
information that you have and you get

00:19:57,760 --> 00:20:02,799
back a response

00:19:59,360 --> 00:20:06,159
the api is simple

00:20:02,799 --> 00:20:08,720
but fetch itself is really quite

00:20:06,159 --> 00:20:12,080
complicated

00:20:08,720 --> 00:20:17,520
there is a lot to it fetch isn't

00:20:12,080 --> 00:20:19,520
just one api it's several apis

00:20:17,520 --> 00:20:20,559
working together and i kind of want to

00:20:19,520 --> 00:20:22,559
break down

00:20:20,559 --> 00:20:23,840
you know some parts of that so it's

00:20:22,559 --> 00:20:27,120
clear kind of

00:20:23,840 --> 00:20:30,240
what we need to do in order to to

00:20:27,120 --> 00:20:33,280
to to implement fetch properly

00:20:30,240 --> 00:20:35,919
in a spec compliant way in node

00:20:33,280 --> 00:20:36,880
okay so one of the things we have to

00:20:35,919 --> 00:20:40,480
implement

00:20:36,880 --> 00:20:42,799
one of several is blob

00:20:40,480 --> 00:20:44,559
blob is an api that exists in in

00:20:42,799 --> 00:20:45,280
browsers it's part of fetch and it's

00:20:44,559 --> 00:20:48,799
part of the

00:20:45,280 --> 00:20:49,760
file api that's there and essentially

00:20:48,799 --> 00:20:53,280
what a blob

00:20:49,760 --> 00:20:56,000
is is an immutable opaque data source

00:20:53,280 --> 00:20:56,960
right so if you think like a typed array

00:20:56,000 --> 00:21:00,000
all right

00:20:56,960 --> 00:21:02,159
it acts like an array it stores data but

00:21:00,000 --> 00:21:03,039
you know you can kind of randomly access

00:21:02,159 --> 00:21:05,600
any of the

00:21:03,039 --> 00:21:06,720
any of the bytes you know change them

00:21:05,600 --> 00:21:10,880
you know modify it

00:21:06,720 --> 00:21:13,840
it's not immutable in any way a blob

00:21:10,880 --> 00:21:14,799
is entirely opaque it does it stores the

00:21:13,840 --> 00:21:17,039
data

00:21:14,799 --> 00:21:19,520
but it doesn't provide any accessors

00:21:17,039 --> 00:21:21,360
into individual bytes

00:21:19,520 --> 00:21:22,799
it doesn't allow individual bytes to be

00:21:21,360 --> 00:21:26,080
modified uh

00:21:22,799 --> 00:21:28,480
it's just encapsulates that data

00:21:26,080 --> 00:21:29,280
the other characteristic about blob is

00:21:28,480 --> 00:21:32,559
that it's not

00:21:29,280 --> 00:21:36,000
just a single uh uh

00:21:32,559 --> 00:21:38,559
uh group of data right

00:21:36,000 --> 00:21:39,120
it's not just a single chunk of data uh

00:21:38,559 --> 00:21:41,200
in a

00:21:39,120 --> 00:21:43,039
array buffer and a typed array

00:21:41,200 --> 00:21:47,120
underneath that's still just

00:21:43,039 --> 00:21:49,600
a a a single chunk of allocated memory

00:21:47,120 --> 00:21:51,039
right a blob can actually be made up of

00:21:49,600 --> 00:21:53,360
multiple pieces

00:21:51,039 --> 00:21:54,720
each piece what i'm calling a data

00:21:53,360 --> 00:21:58,000
source here

00:21:54,720 --> 00:22:00,320
is a it is itself a chunk of

00:21:58,000 --> 00:22:01,760
data uh now it could be a string it

00:22:00,320 --> 00:22:02,240
could be an array buffer it could be a

00:22:01,760 --> 00:22:05,039
typed

00:22:02,240 --> 00:22:06,480
array it could be a a readable stream it

00:22:05,039 --> 00:22:08,240
could be another blob

00:22:06,480 --> 00:22:10,320
whatever you know that makes up that

00:22:08,240 --> 00:22:13,440
data source the blob itself

00:22:10,320 --> 00:22:14,480
is a sequence of these data sources so

00:22:13,440 --> 00:22:16,640
that when you read

00:22:14,480 --> 00:22:18,720
a blob and you get a string what you're

00:22:16,640 --> 00:22:19,360
going to get is a concatenation of all

00:22:18,720 --> 00:22:21,120
the data

00:22:19,360 --> 00:22:22,960
from each of the member data sources

00:22:21,120 --> 00:22:26,400
that's there

00:22:22,960 --> 00:22:29,039
now the data for those data sources

00:22:26,400 --> 00:22:30,880
might not actually exist when the blob

00:22:29,039 --> 00:22:33,840
object is created

00:22:30,880 --> 00:22:35,760
right it might be a stream right think

00:22:33,840 --> 00:22:37,919
of a an hp request

00:22:35,760 --> 00:22:39,840
you submit the request you get back but

00:22:37,919 --> 00:22:43,200
there still might be a stream of data

00:22:39,840 --> 00:22:43,200
being returned by the server

00:22:43,520 --> 00:22:46,960
what the apis are going to do is it's

00:22:44,960 --> 00:22:48,960
going to create a blob for you

00:22:46,960 --> 00:22:51,280
right before it has received all that

00:22:48,960 --> 00:22:52,000
data and all the data is just going to

00:22:51,280 --> 00:22:53,760
stream

00:22:52,000 --> 00:22:56,159
into that blob as part of that data

00:22:53,760 --> 00:22:58,559
storage right so that blob can grow

00:22:56,159 --> 00:22:59,440
over time the data that contains can can

00:22:58,559 --> 00:23:00,640
evolve

00:22:59,440 --> 00:23:02,159
but several things about it are

00:23:00,640 --> 00:23:03,919
interesting one like i said it's

00:23:02,159 --> 00:23:04,720
immutable the data can't be changed once

00:23:03,919 --> 00:23:07,280
it's there

00:23:04,720 --> 00:23:09,280
and reading it is item potent what that

00:23:07,280 --> 00:23:11,840
means is when i read it once

00:23:09,280 --> 00:23:13,120
right i'm going to get some data right

00:23:11,840 --> 00:23:14,159
the next time i read it i'm going to get

00:23:13,120 --> 00:23:16,320
the exact same data

00:23:14,159 --> 00:23:18,240
all right so once the data has been

00:23:16,320 --> 00:23:19,760
loaded into the blob like i said it you

00:23:18,240 --> 00:23:21,440
know it may not be there all right away

00:23:19,760 --> 00:23:23,919
but it's going to stream in

00:23:21,440 --> 00:23:25,360
once it's loaded i can read it again and

00:23:23,919 --> 00:23:27,360
again and again

00:23:25,360 --> 00:23:28,720
and i'm going to get the same data back

00:23:27,360 --> 00:23:29,919
right so it goes speaks to that

00:23:28,720 --> 00:23:32,559
immutability

00:23:29,919 --> 00:23:34,320
of what that blob is right but again

00:23:32,559 --> 00:23:37,760
there's no api for getting

00:23:34,320 --> 00:23:40,880
you know the byte at index you know 50

00:23:37,760 --> 00:23:42,320
in in in a blob what you do is you get a

00:23:40,880 --> 00:23:44,559
promise to get a string

00:23:42,320 --> 00:23:45,840
that has the entire content or a promise

00:23:44,559 --> 00:23:46,960
to get an array buffer that has the

00:23:45,840 --> 00:23:49,520
entire content

00:23:46,960 --> 00:23:51,120
or you can get a stream readable um that

00:23:49,520 --> 00:23:54,080
you know that that will

00:23:51,120 --> 00:23:54,559
give you the content as it is available

00:23:54,080 --> 00:23:57,440
right

00:23:54,559 --> 00:23:58,960
so there's ways of consuming the blob um

00:23:57,440 --> 00:23:59,840
but it just doesn't have that same level

00:23:58,960 --> 00:24:01,760
of data

00:23:59,840 --> 00:24:03,520
access now why am i talking about blobs

00:24:01,760 --> 00:24:07,840
so much well fetch

00:24:03,520 --> 00:24:11,520
includes support for the blob api

00:24:07,840 --> 00:24:14,159
when you submit a a a request

00:24:11,520 --> 00:24:15,279
right that request that input data could

00:24:14,159 --> 00:24:18,240
come from a blob

00:24:15,279 --> 00:24:20,080
um when you get the response back right

00:24:18,240 --> 00:24:21,679
blob is one of the options for getting

00:24:20,080 --> 00:24:23,039
that data back

00:24:21,679 --> 00:24:24,960
now there's other options there's string

00:24:23,039 --> 00:24:27,600
and array buffer there's other things

00:24:24,960 --> 00:24:29,600
but if you look at the at the fetch api

00:24:27,600 --> 00:24:32,640
the standard the spec

00:24:29,600 --> 00:24:36,000
right it says one of the options

00:24:32,640 --> 00:24:38,320
is to get a blob all right

00:24:36,000 --> 00:24:39,520
blob doesn't exist in node if we want to

00:24:38,320 --> 00:24:42,960
do fetch

00:24:39,520 --> 00:24:46,000
correctly in a spec compliant way

00:24:42,960 --> 00:24:48,880
then we have to implement blub um

00:24:46,000 --> 00:24:49,360
it really is a symbol of that now we do

00:24:48,880 --> 00:24:52,159
have a

00:24:49,360 --> 00:24:52,799
a initial simple implementation of blob

00:24:52,159 --> 00:24:55,679
in core

00:24:52,799 --> 00:24:57,760
experimental right now um there is

00:24:55,679 --> 00:25:00,320
additional work that needs to be done

00:24:57,760 --> 00:25:02,000
right now that it only works with static

00:25:00,320 --> 00:25:03,919
data sources where the data is all

00:25:02,000 --> 00:25:06,880
available when the blob is created

00:25:03,919 --> 00:25:08,400
we have to further uh enable that to

00:25:06,880 --> 00:25:10,159
support the streaming

00:25:08,400 --> 00:25:11,679
in of data for the individual data

00:25:10,159 --> 00:25:13,520
sources and that's something that's

00:25:11,679 --> 00:25:15,919
going to take some time to complete

00:25:13,520 --> 00:25:17,200
this is just one small part of the

00:25:15,919 --> 00:25:19,600
overall

00:25:17,200 --> 00:25:21,279
fetch implementation something else that

00:25:19,600 --> 00:25:23,120
we need for fetch

00:25:21,279 --> 00:25:25,520
if you look at the spec and it says hey

00:25:23,120 --> 00:25:27,919
it's there it needs to be supported

00:25:25,520 --> 00:25:28,880
is form data and headers these are two

00:25:27,919 --> 00:25:30,880
objects

00:25:28,880 --> 00:25:32,960
that the fetch api is designed to work

00:25:30,880 --> 00:25:35,760
with if you want to send

00:25:32,960 --> 00:25:36,880
html form data for the content of an

00:25:35,760 --> 00:25:38,400
html form

00:25:36,880 --> 00:25:41,039
serialize on the wire you would use the

00:25:38,400 --> 00:25:43,440
form data object to create that

00:25:41,039 --> 00:25:44,240
right it's a simple object that's used

00:25:43,440 --> 00:25:47,840
to parse

00:25:44,240 --> 00:25:50,080
and produce this encoded form data

00:25:47,840 --> 00:25:51,039
and you could use it as the body of a

00:25:50,080 --> 00:25:54,480
fetch request

00:25:51,039 --> 00:25:54,480
or get it back as a response

00:25:54,559 --> 00:25:58,799
um you know we have a question we have a

00:25:57,360 --> 00:25:59,919
decision to make with a node do we

00:25:58,799 --> 00:26:01,679
want to implement this do we want to

00:25:59,919 --> 00:26:02,320
support this um is this part of the

00:26:01,679 --> 00:26:04,480
fetch

00:26:02,320 --> 00:26:06,080
api that we want to support in us in a

00:26:04,480 --> 00:26:08,960
standard way

00:26:06,080 --> 00:26:10,000
um and you know that you know i have it

00:26:08,960 --> 00:26:11,840
marked as optional

00:26:10,000 --> 00:26:14,080
because it's still up in the air whether

00:26:11,840 --> 00:26:16,400
within node it makes sense for us to

00:26:14,080 --> 00:26:19,120
actually provide this api

00:26:16,400 --> 00:26:20,960
uh the headers object similarly is for

00:26:19,120 --> 00:26:22,880
working with http headers it's a

00:26:20,960 --> 00:26:24,400
standard part of the fetch api

00:26:22,880 --> 00:26:26,240
that if we want to implement fetch

00:26:24,400 --> 00:26:28,400
correctly we have to do this now

00:26:26,240 --> 00:26:30,080
the challenge is you know where do we

00:26:28,400 --> 00:26:32,080
use this we implement the headers

00:26:30,080 --> 00:26:33,279
object should we integrate it with the

00:26:32,080 --> 00:26:38,159
existing http

00:26:33,279 --> 00:26:39,520
um api that we have in node

00:26:38,159 --> 00:26:41,840
or is it just a standalone thing that

00:26:39,520 --> 00:26:43,919
only works with fetch

00:26:41,840 --> 00:26:46,240
it's one thing just to implement

00:26:43,919 --> 00:26:49,600
something it's another thing to

00:26:46,240 --> 00:26:50,799
figure out where all it fits how it fits

00:26:49,600 --> 00:26:53,679
with all the existing

00:26:50,799 --> 00:26:54,400
legacy api that we have we have to

00:26:53,679 --> 00:26:57,360
address

00:26:54,400 --> 00:26:58,080
that concern before we can really move

00:26:57,360 --> 00:27:00,640
forward

00:26:58,080 --> 00:27:01,919
otherwise node just becomes this kind of

00:27:00,640 --> 00:27:03,919
you know grab bag

00:27:01,919 --> 00:27:05,760
mess of things that aren't really well

00:27:03,919 --> 00:27:08,080
integrated with each other

00:27:05,760 --> 00:27:09,200
we have to make those decisions on how

00:27:08,080 --> 00:27:11,919
to implement these

00:27:09,200 --> 00:27:12,400
and how to integrate them as opposed to

00:27:11,919 --> 00:27:15,840
just

00:27:12,400 --> 00:27:18,480
simply implementing them the other

00:27:15,840 --> 00:27:21,279
big thing we need to figure out before

00:27:18,480 --> 00:27:23,600
we can do fetch properly

00:27:21,279 --> 00:27:26,320
really is figure out the implementation

00:27:23,600 --> 00:27:30,080
of the what wg streams api

00:27:26,320 --> 00:27:31,039
um fetch is is largely built around what

00:27:30,080 --> 00:27:33,200
wg streams

00:27:31,039 --> 00:27:34,080
it you know what jpg is has become

00:27:33,200 --> 00:27:37,679
critical

00:27:34,080 --> 00:27:41,279
to to many browser apis

00:27:37,679 --> 00:27:44,480
and i don't think anyone in node

00:27:41,279 --> 00:27:47,919
is excited to add yet another

00:27:44,480 --> 00:27:50,159
streams api to node we already have uh

00:27:47,919 --> 00:27:53,039
one it's extremely complex it's gone

00:27:50,159 --> 00:27:55,520
through many different versions

00:27:53,039 --> 00:27:57,600
uh it has all kinds of you know warts

00:27:55,520 --> 00:27:59,840
and everything else to it and just this

00:27:57,600 --> 00:28:00,960
prospect of adding another api

00:27:59,840 --> 00:28:03,679
particularly one that's going to be

00:28:00,960 --> 00:28:05,279
slower

00:28:03,679 --> 00:28:07,200
you know it's not something that's very

00:28:05,279 --> 00:28:08,640
attractive to folks so it's something

00:28:07,200 --> 00:28:10,480
we're working through it's something

00:28:08,640 --> 00:28:12,559
that needs to happen

00:28:10,480 --> 00:28:14,080
yes and it and i do anticipate it

00:28:12,559 --> 00:28:16,480
happening for sure

00:28:14,080 --> 00:28:18,480
it just might take some time now there

00:28:16,480 --> 00:28:19,360
are other considerations for fetch as

00:28:18,480 --> 00:28:21,919
well

00:28:19,360 --> 00:28:23,120
uh fetch requires support for cores

00:28:21,919 --> 00:28:25,840
which is this you know

00:28:23,120 --> 00:28:26,960
you know um cross-origin you know

00:28:25,840 --> 00:28:29,279
resources and all

00:28:26,960 --> 00:28:30,000
you know this this model about limiting

00:28:29,279 --> 00:28:32,399
requests across

00:28:30,000 --> 00:28:34,080
origins well node doesn't have any

00:28:32,399 --> 00:28:36,240
concept of origin

00:28:34,080 --> 00:28:38,399
um cores doesn't really make sense in

00:28:36,240 --> 00:28:40,559
the node environment

00:28:38,399 --> 00:28:41,600
so is this something that we would even

00:28:40,559 --> 00:28:43,200
implement is this something

00:28:41,600 --> 00:28:46,080
we even need to worry about do we need

00:28:43,200 --> 00:28:48,000
to introduce this to node

00:28:46,080 --> 00:28:51,039
this concept of origins you know these

00:28:48,000 --> 00:28:54,320
are things that are just open questions

00:28:51,039 --> 00:28:54,960
fetch has support for http caching node

00:28:54,320 --> 00:28:57,120
has no

00:28:54,960 --> 00:28:58,960
implementation of http caching do we

00:28:57,120 --> 00:29:00,399
need one should do we need to

00:28:58,960 --> 00:29:02,320
uh do we need is that something we need

00:29:00,399 --> 00:29:03,279
to go through and implement

00:29:02,320 --> 00:29:05,200
we also need to figure out what we're

00:29:03,279 --> 00:29:07,279
going to do with the http state now

00:29:05,200 --> 00:29:10,240
fetch in the browser assumes

00:29:07,279 --> 00:29:12,640
that states any state that's maintained

00:29:10,240 --> 00:29:14,080
cookies all that kind of stuff is bound

00:29:12,640 --> 00:29:15,919
to the origin model

00:29:14,080 --> 00:29:17,360
right you know the cookies that it that

00:29:15,919 --> 00:29:19,520
that it uh

00:29:17,360 --> 00:29:20,480
stores are going to be scoped only to

00:29:19,520 --> 00:29:22,159
the origin

00:29:20,480 --> 00:29:24,480
uh in which the current web page is

00:29:22,159 --> 00:29:26,720
running it but again node doesn't have a

00:29:24,480 --> 00:29:28,159
concept of origin uh and

00:29:26,720 --> 00:29:30,480
and unlike the browser which has a

00:29:28,159 --> 00:29:34,080
single user node could have

00:29:30,480 --> 00:29:37,360
millions of users simultaneously uh

00:29:34,080 --> 00:29:40,640
global states is a big problem and fetch

00:29:37,360 --> 00:29:41,840
relies a a great deal the api

00:29:40,640 --> 00:29:44,159
they actually if you look at the actual

00:29:41,840 --> 00:29:45,440
api spec it relies a great deal on

00:29:44,159 --> 00:29:48,399
global state

00:29:45,440 --> 00:29:50,240
being maintained we need to figure out

00:29:48,399 --> 00:29:50,799
kind of how that fits within the node

00:29:50,240 --> 00:29:53,679
model

00:29:50,799 --> 00:29:55,679
it's not just about implementing the api

00:29:53,679 --> 00:29:57,840
we have to figure out how it integrates

00:29:55,679 --> 00:30:00,159
with everything else

00:29:57,840 --> 00:30:01,039
and then another challenge we have is

00:30:00,159 --> 00:30:03,360
figuring out

00:30:01,039 --> 00:30:05,279
seamless version discovery between hp1

00:30:03,360 --> 00:30:07,840
hp2 and hp3

00:30:05,279 --> 00:30:09,760
because of the what the very organic way

00:30:07,840 --> 00:30:11,039
uh an incremental way that these apis

00:30:09,760 --> 00:30:12,960
evolved over time

00:30:11,039 --> 00:30:14,080
within node they are not very well

00:30:12,960 --> 00:30:15,840
integrated

00:30:14,080 --> 00:30:17,200
and you know in order to do fetch

00:30:15,840 --> 00:30:19,200
correctly with with

00:30:17,200 --> 00:30:21,039
good performance we really do need to

00:30:19,200 --> 00:30:22,559
get those integrated well

00:30:21,039 --> 00:30:25,679
in the meantime while you're waiting for

00:30:22,559 --> 00:30:28,880
fetch you really should look at mundichi

00:30:25,679 --> 00:30:31,919
untichi is a alternative

00:30:28,880 --> 00:30:33,520
http client that's starting to be

00:30:31,919 --> 00:30:35,679
developed as part of node

00:30:33,520 --> 00:30:37,679
with the intent of it becoming the next

00:30:35,679 --> 00:30:39,279
node client api

00:30:37,679 --> 00:30:40,799
and it is very similar if you're if

00:30:39,279 --> 00:30:44,000
you're familiar with fetch

00:30:40,799 --> 00:30:47,600
you should be able to look at uh uh um

00:30:44,000 --> 00:30:50,720
work with undici uh uh uh

00:30:47,600 --> 00:30:54,080
yeah it's very very familiar uh

00:30:50,720 --> 00:30:54,880
uh a way of doing it so that is the

00:30:54,080 --> 00:30:57,760
quick version

00:30:54,880 --> 00:30:58,960
of this i you know um unfortunately i've

00:30:57,760 --> 00:31:01,200
run out of time uh

00:30:58,960 --> 00:31:02,000
to to to go into more detail the whole

00:31:01,200 --> 00:31:04,320
point of this

00:31:02,000 --> 00:31:06,000
conversation really has been to go

00:31:04,320 --> 00:31:09,039
through and outline

00:31:06,000 --> 00:31:11,840
where we're at where we're going why

00:31:09,039 --> 00:31:12,559
um certain decisions around what browser

00:31:11,840 --> 00:31:15,279
apis

00:31:12,559 --> 00:31:16,480
take a long time uh you know what the

00:31:15,279 --> 00:31:19,200
considerations are

00:31:16,480 --> 00:31:19,600
when we're going through this it never

00:31:19,200 --> 00:31:22,000
ever

00:31:19,600 --> 00:31:24,000
is just about the implementation of the

00:31:22,000 --> 00:31:26,399
api and that's it

00:31:24,000 --> 00:31:28,480
all of the difficulty comes in where it

00:31:26,399 --> 00:31:30,880
fits in the larger platform

00:31:28,480 --> 00:31:33,440
in the larger strategy so that we are

00:31:30,880 --> 00:31:34,640
delivering benefit for the entire node

00:31:33,440 --> 00:31:37,279
ecosystem

00:31:34,640 --> 00:31:39,840
rather than just implementing an api for

00:31:37,279 --> 00:31:42,000
the sake of having that api

00:31:39,840 --> 00:31:43,120
so with that uh you know i thank you all

00:31:42,000 --> 00:31:44,880
for uh for

00:31:43,120 --> 00:31:46,960
for joining me i hope you enjoy the rest

00:31:44,880 --> 00:31:49,279
of the sessions and the discussions

00:31:46,960 --> 00:31:50,760
around openjs world and i'll catch you

00:31:49,279 --> 00:31:53,760
all later

00:31:50,760 --> 00:31:53,760

YouTube URL: https://www.youtube.com/watch?v=6EDaayYnw6M


