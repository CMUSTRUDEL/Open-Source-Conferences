Title: Building Modern Native Add-ons for Node.js in 2021 - Kevin Eady, Hive Streaming & Gabriel Schulhof
Publication date: 2021-05-29
Playlist: OpenJS World 2021
Description: 
	Building Modern Native Add-ons for Node.js in 2021 - Kevin Eady, Hive Streaming & Gabriel Schulhof

Quickly get up to speed developing modern Node.js native addons. This fast-paced talk, presented by members of the Node-API team for all native add-on developers, covers recent enhancements to Node-API. Support for multi-threaded and asynchronous programming in Node-API has been significantly improved. New abstractions such as thread-safe functions and the Addon class greatly simplify the effort needed to implement asynchronous add-ons. New helper methods support date objects, BigInts, retrieving object property names, and detaching ArrayBuffers. Tools used to build and deploy native add-ons also continue to improve. Developers can build with CMake.js in addition to node-gyp. Prebuilding binaries significantly improves the experience of native add-on users. Deployment options permit serving these binaries from GitHub releases or bundling the binaries in the npm module itself.

Join the speaker for live Q&A on Slack: Thursday, June 3 from 12:00 - 12:20 PDT / 21:00 - 21:20 CEST, channel - #openjs_world-development
Captions: 
	00:00:00,160 --> 00:00:04,080
hello everybody welcome to opengds world

00:00:02,560 --> 00:00:07,359
2021 and our

00:00:04,080 --> 00:00:11,040
uh presentation about uh node.js

00:00:07,359 --> 00:00:13,200
uh node api um we're gonna be talking

00:00:11,040 --> 00:00:13,920
mostly about how to build modern native

00:00:13,200 --> 00:00:16,640
add-ons

00:00:13,920 --> 00:00:18,320
uh node.js is uh node api has been

00:00:16,640 --> 00:00:20,720
around for a while

00:00:18,320 --> 00:00:22,960
and uh it has enabled everybody to build

00:00:20,720 --> 00:00:25,760
uh api stable add-ons but

00:00:22,960 --> 00:00:26,960
we've we've had uh significant features

00:00:25,760 --> 00:00:28,840
added recently and

00:00:26,960 --> 00:00:31,840
those are the ones we would like to talk

00:00:28,840 --> 00:00:31,840
about

00:00:32,239 --> 00:00:35,760
and my name is gabriel i'm a member of

00:00:35,440 --> 00:00:39,200
the

00:00:35,760 --> 00:00:41,440
node.js tsc and of the node.js node api

00:00:39,200 --> 00:00:43,040
working group and i originally

00:00:41,440 --> 00:00:45,600
contributed

00:00:43,040 --> 00:00:47,440
some portions of node api like promises

00:00:45,600 --> 00:00:50,879
exception handling environment

00:00:47,440 --> 00:00:53,840
propagation mode module loading wrapping

00:00:50,879 --> 00:00:54,640
unwrapping of objects threat safe

00:00:53,840 --> 00:00:59,359
functions

00:00:54,640 --> 00:01:02,399
and context-aware add-ons

00:00:59,359 --> 00:01:04,960
and i am kevin eady i'm a

00:01:02,399 --> 00:01:06,320
api team member primarily working on the

00:01:04,960 --> 00:01:09,040
node add-on api

00:01:06,320 --> 00:01:10,720
wrapper we'll talk about that shortly

00:01:09,040 --> 00:01:12,880
and i'm focusing mainly on

00:01:10,720 --> 00:01:16,080
threadsafe functions and asynchronous

00:01:12,880 --> 00:01:16,080
programming in general

00:01:16,159 --> 00:01:22,400
building native apps so

00:01:19,520 --> 00:01:23,200
when you need to compile your c plus

00:01:22,400 --> 00:01:26,799
code

00:01:23,200 --> 00:01:28,640
to run on node we there exists

00:01:26,799 --> 00:01:30,079
multiple ways to compile your code

00:01:28,640 --> 00:01:33,600
currently

00:01:30,079 --> 00:01:36,640
one method to use this is node gipp

00:01:33,600 --> 00:01:40,799
this is the de facto method that

00:01:36,640 --> 00:01:44,079
exists whenever you install node

00:01:40,799 --> 00:01:45,119
this application this build system is

00:01:44,079 --> 00:01:48,720
installed

00:01:45,119 --> 00:01:52,479
on your machine as well this allows

00:01:48,720 --> 00:01:54,799
any dependencies that you install

00:01:52,479 --> 00:01:55,520
they don't necessarily have to also

00:01:54,799 --> 00:01:59,759
install

00:01:55,520 --> 00:02:02,799
this in order to compile their add-ons

00:01:59,759 --> 00:02:05,840
another alternative is cmake.js

00:02:02,799 --> 00:02:06,560
if you have used c plus build systems in

00:02:05,840 --> 00:02:10,080
the past

00:02:06,560 --> 00:02:11,520
you may be familiar with cmake this one

00:02:10,080 --> 00:02:14,800
allows you

00:02:11,520 --> 00:02:18,400
to easily integrate with other

00:02:14,800 --> 00:02:21,680
c plus plus projects that are also

00:02:18,400 --> 00:02:24,239
c make based this will

00:02:21,680 --> 00:02:25,760
easily allow you to incorporate the

00:02:24,239 --> 00:02:28,400
dependency trees

00:02:25,760 --> 00:02:28,400
that you need

00:02:30,319 --> 00:02:34,640
however all of those require compiling

00:02:33,760 --> 00:02:38,720
the code

00:02:34,640 --> 00:02:42,080
every time you install the package

00:02:38,720 --> 00:02:46,000
there are additional methods that

00:02:42,080 --> 00:02:49,680
allow you to download pre-compiled

00:02:46,000 --> 00:02:50,000
binaries and use those so that you do

00:02:49,680 --> 00:02:52,640
not

00:02:50,000 --> 00:02:54,560
have to compile every time the package

00:02:52,640 --> 00:02:58,319
is installed

00:02:54,560 --> 00:03:01,280
one method is node pre-gipp

00:02:58,319 --> 00:03:02,800
this one integrates easily with github

00:03:01,280 --> 00:03:06,000
releases

00:03:02,800 --> 00:03:09,040
and another one is pre-build

00:03:06,000 --> 00:03:10,640
this one integrates easily with amazon

00:03:09,040 --> 00:03:13,840
s3

00:03:10,640 --> 00:03:17,200
so these two solutions when you

00:03:13,840 --> 00:03:18,959
compile your code as a developer as the

00:03:17,200 --> 00:03:22,159
package maintainer

00:03:18,959 --> 00:03:26,319
you can upload the built

00:03:22,159 --> 00:03:29,440
binaries to a repository

00:03:26,319 --> 00:03:32,560
either github or s3 and

00:03:29,440 --> 00:03:35,120
depending on which solution you use

00:03:32,560 --> 00:03:38,239
it will download those directly instead

00:03:35,120 --> 00:03:38,239
of having to compile

00:03:39,760 --> 00:03:43,440
node apis can only be called from the

00:03:41,760 --> 00:03:47,760
node thread

00:03:43,440 --> 00:03:51,440
there exists multiple apis

00:03:47,760 --> 00:03:53,680
in order to facilitate

00:03:51,440 --> 00:03:54,640
the communication between your

00:03:53,680 --> 00:03:58,640
application

00:03:54,640 --> 00:04:01,120
and the native node thread

00:03:58,640 --> 00:04:03,200
there exists multiple different ways to

00:04:01,120 --> 00:04:07,200
perform asynchronous programming

00:04:03,200 --> 00:04:09,599
with node we have the async worker

00:04:07,200 --> 00:04:11,200
which will be able to create a single

00:04:09,599 --> 00:04:14,400
worker thread

00:04:11,200 --> 00:04:16,560
which will execute your logic

00:04:14,400 --> 00:04:18,079
on this worker thread and when your

00:04:16,560 --> 00:04:20,639
logic is completed

00:04:18,079 --> 00:04:23,199
you can call back to the node thread

00:04:20,639 --> 00:04:25,199
with the result

00:04:23,199 --> 00:04:26,240
on this callback you're able to

00:04:25,199 --> 00:04:29,280
transform

00:04:26,240 --> 00:04:32,320
your native c plus data into

00:04:29,280 --> 00:04:32,320
the node data

00:04:32,400 --> 00:04:36,240
as well as the async worker we have some

00:04:34,960 --> 00:04:38,800
node add-on api

00:04:36,240 --> 00:04:39,600
specific extensions the async progress

00:04:38,800 --> 00:04:42,400
worker

00:04:39,600 --> 00:04:43,840
and the async progress queue worker what

00:04:42,400 --> 00:04:47,680
these allow you to do

00:04:43,840 --> 00:04:51,280
is ping from your

00:04:47,680 --> 00:04:56,160
your native thread to

00:04:51,280 --> 00:04:58,880
the node thread various progress updates

00:04:56,160 --> 00:05:00,000
then finally we have thread safe

00:04:58,880 --> 00:05:03,440
functions

00:05:00,000 --> 00:05:07,520
these are full featured apis

00:05:03,440 --> 00:05:10,560
that allow you to create as many threads

00:05:07,520 --> 00:05:13,759
as you want and ping

00:05:10,560 --> 00:05:18,240
into the node api as

00:05:13,759 --> 00:05:22,000
you find necessary

00:05:18,240 --> 00:05:24,240
uh one one one small addition is that

00:05:22,000 --> 00:05:26,160
one of the crucial differences between

00:05:24,240 --> 00:05:28,160
the the async workers progress or

00:05:26,160 --> 00:05:30,880
otherwise in the threats they function

00:05:28,160 --> 00:05:31,199
is that in the case of the async workers

00:05:30,880 --> 00:05:33,039
the

00:05:31,199 --> 00:05:34,639
the threading implementation is not up

00:05:33,039 --> 00:05:36,320
to you so

00:05:34,639 --> 00:05:38,000
in in the case of async workers you're

00:05:36,320 --> 00:05:39,520
relying on node.js to create

00:05:38,000 --> 00:05:42,080
the threads whereas in the case of the

00:05:39,520 --> 00:05:44,080
threadsafe function node.js creates only

00:05:42,080 --> 00:05:44,960
the communication mechanism and it is up

00:05:44,080 --> 00:05:47,759
to you to use

00:05:44,960 --> 00:05:50,880
your own threading implementation or to

00:05:47,759 --> 00:05:53,840
create a new threading implementation

00:05:50,880 --> 00:05:53,840
back to you kevin

00:05:56,720 --> 00:05:59,759
all right and the first example we'll

00:05:59,039 --> 00:06:03,120
talk about

00:05:59,759 --> 00:06:03,120
is async workers

00:06:03,840 --> 00:06:06,960
so async worker is implemented in both

00:06:06,560 --> 00:06:10,639
the

00:06:06,960 --> 00:06:13,759
node api which is the c based

00:06:10,639 --> 00:06:16,720
abi stable that we have

00:06:13,759 --> 00:06:19,440
as well as node add-on api which is the

00:06:16,720 --> 00:06:23,440
c plus plus wrapper

00:06:19,440 --> 00:06:25,600
the async worker as gabriel mentioned

00:06:23,440 --> 00:06:27,600
this would end up creating the worker

00:06:25,600 --> 00:06:30,319
thread internally

00:06:27,600 --> 00:06:31,039
which internally may be a lib uv worker

00:06:30,319 --> 00:06:33,360
thread

00:06:31,039 --> 00:06:34,639
but you as the programmer have no

00:06:33,360 --> 00:06:37,280
control over

00:06:34,639 --> 00:06:38,880
what that worker threat is it is a

00:06:37,280 --> 00:06:42,400
thread created

00:06:38,880 --> 00:06:42,400
by the underlying system

00:06:42,479 --> 00:06:46,319
when you create this async worker you

00:06:44,960 --> 00:06:49,199
provide

00:06:46,319 --> 00:06:49,759
two callbacks the execute and the

00:06:49,199 --> 00:06:53,120
complete

00:06:49,759 --> 00:06:54,080
callback the execute callback is what

00:06:53,120 --> 00:06:57,680
you use

00:06:54,080 --> 00:07:00,960
to run your native

00:06:57,680 --> 00:07:04,479
c plus plus logic outside

00:07:00,960 --> 00:07:07,280
of the node thread when that finishes

00:07:04,479 --> 00:07:07,759
you call the complete callback with your

00:07:07,280 --> 00:07:10,880
re

00:07:07,759 --> 00:07:12,160
with your c plus result and there you

00:07:10,880 --> 00:07:15,199
can transform

00:07:12,160 --> 00:07:17,840
your native c plus data into the node

00:07:15,199 --> 00:07:17,840
data

00:07:19,680 --> 00:07:25,360
in addition to a

00:07:22,800 --> 00:07:28,160
normal async worker like i mentioned we

00:07:25,360 --> 00:07:30,400
have the progress worker

00:07:28,160 --> 00:07:33,280
this has an additional callback which is

00:07:30,400 --> 00:07:36,479
the on progress callback

00:07:33,280 --> 00:07:40,319
the on progress callback executes

00:07:36,479 --> 00:07:44,000
also on the node thread which allows

00:07:40,319 --> 00:07:47,039
you to ping into from your

00:07:44,000 --> 00:07:50,400
c splits thread into the node thread

00:07:47,039 --> 00:07:53,680
and the final variant that we have is a

00:07:50,400 --> 00:07:55,440
progress day sync progress q worker this

00:07:53,680 --> 00:07:58,400
guarantees a progress

00:07:55,440 --> 00:07:59,599
update every time that you would like to

00:07:58,400 --> 00:08:01,759
send a progress

00:07:59,599 --> 00:08:03,360
update um next we'll talk about thread

00:08:01,759 --> 00:08:06,479
safe functions

00:08:03,360 --> 00:08:09,039
these are feature-rich apis

00:08:06,479 --> 00:08:09,919
that give you full control of how you

00:08:09,039 --> 00:08:13,840
would like to

00:08:09,919 --> 00:08:16,560
use node in any of your multi-threaded

00:08:13,840 --> 00:08:16,560
applications

00:08:18,639 --> 00:08:25,120
thread save functions are backed by a

00:08:21,840 --> 00:08:28,639
message queue and

00:08:25,120 --> 00:08:32,000
when you in your native c plus code

00:08:28,639 --> 00:08:35,039
want to communicate with the node

00:08:32,000 --> 00:08:38,399
thread it's basically a

00:08:35,039 --> 00:08:39,200
request that you post on this message

00:08:38,399 --> 00:08:42,320
queue

00:08:39,200 --> 00:08:45,600
to say i would like to execute

00:08:42,320 --> 00:08:46,399
some code the way that you place a

00:08:45,600 --> 00:08:48,240
request

00:08:46,399 --> 00:08:51,040
on this message queue there's two

00:08:48,240 --> 00:08:54,240
different ways there's a blocking call

00:08:51,040 --> 00:08:57,519
which will wait for

00:08:54,240 --> 00:09:00,880
the queue to have space

00:08:57,519 --> 00:09:05,279
for you to put in your

00:09:00,880 --> 00:09:08,320
request and then we also have a

00:09:05,279 --> 00:09:11,839
non-blocking call which

00:09:08,320 --> 00:09:13,839
if your queue is full you would end up

00:09:11,839 --> 00:09:16,640
receiving a special status

00:09:13,839 --> 00:09:18,160
saying the queue is full with thread

00:09:16,640 --> 00:09:21,200
safe functions

00:09:18,160 --> 00:09:22,720
at construction you specify some few

00:09:21,200 --> 00:09:25,040
data

00:09:22,720 --> 00:09:26,720
what you have first is your initial

00:09:25,040 --> 00:09:31,600
thread count

00:09:26,720 --> 00:09:33,680
you also specify your maximum queue size

00:09:31,600 --> 00:09:36,399
this goes back to how we were talking

00:09:33,680 --> 00:09:39,519
about the

00:09:36,399 --> 00:09:43,040
blocking calls and non-blocking calls

00:09:39,519 --> 00:09:46,160
if you specify an unlimited queue size

00:09:43,040 --> 00:09:48,240
then you would never be

00:09:46,160 --> 00:09:49,360
it would never block because you would

00:09:48,240 --> 00:09:52,240
always have

00:09:49,360 --> 00:09:53,040
space to put something in the queue

00:09:52,240 --> 00:09:57,279
right

00:09:53,040 --> 00:10:00,080
but if you have say a cue size of 100

00:09:57,279 --> 00:10:01,680
and the queue is full and you try to

00:10:00,080 --> 00:10:03,920
make a post

00:10:01,680 --> 00:10:05,839
at that point if you make a blocking

00:10:03,920 --> 00:10:09,120
call it will block and wait

00:10:05,839 --> 00:10:12,320
until there's space and the non-blocking

00:10:09,120 --> 00:10:15,440
will just say it's full

00:10:12,320 --> 00:10:16,320
and you have a couple of callbacks we

00:10:15,440 --> 00:10:20,399
have a

00:10:16,320 --> 00:10:23,600
javascript function callback a call js

00:10:20,399 --> 00:10:25,760
callback and the finalizer callback

00:10:23,600 --> 00:10:27,440
the initial thread count is like i said

00:10:25,760 --> 00:10:30,720
you provide at the beginning

00:10:27,440 --> 00:10:33,680
and it's stored internally

00:10:30,720 --> 00:10:35,040
once this counter reaches a zero the

00:10:33,680 --> 00:10:38,320
thread say function is

00:10:35,040 --> 00:10:43,040
no longer available for use

00:10:38,320 --> 00:10:43,040
and will be cleaned up and finalized

00:10:44,399 --> 00:10:51,440
and as kevin pointed out uh

00:10:47,920 --> 00:10:52,399
having things that defined statically at

00:10:51,440 --> 00:10:54,399
the global scope

00:10:52,399 --> 00:10:55,519
is no longer such a good idea because

00:10:54,399 --> 00:10:59,200
nowadays

00:10:55,519 --> 00:11:00,320
you can have uh threads running not only

00:10:59,200 --> 00:11:03,279
on the native side

00:11:00,320 --> 00:11:04,480
but you can also run javascript in

00:11:03,279 --> 00:11:05,920
multiple threads

00:11:04,480 --> 00:11:07,440
now this is not the same as native

00:11:05,920 --> 00:11:09,440
threads because what you're basically

00:11:07,440 --> 00:11:10,480
doing on the javascript side is creating

00:11:09,440 --> 00:11:13,600
a whole

00:11:10,480 --> 00:11:14,160
node.js world every time you you start a

00:11:13,600 --> 00:11:16,959
new

00:11:14,160 --> 00:11:17,760
node.js thread and what that basically

00:11:16,959 --> 00:11:19,839
means

00:11:17,760 --> 00:11:21,440
is that if you require a native add-on

00:11:19,839 --> 00:11:22,959
from one thread and then you require it

00:11:21,440 --> 00:11:25,839
from another thread that's going to be

00:11:22,959 --> 00:11:29,200
two copies of the native add-on right

00:11:25,839 --> 00:11:31,440
but uh but you know

00:11:29,200 --> 00:11:32,959
having variables at the global scope

00:11:31,440 --> 00:11:36,399
thus is not

00:11:32,959 --> 00:11:39,839
threat safe because um you don't

00:11:36,399 --> 00:11:42,240
necessarily load multiple copies of

00:11:39,839 --> 00:11:43,120
the memory area where these global

00:11:42,240 --> 00:11:45,839
variables are

00:11:43,120 --> 00:11:46,240
are stored because usually when you look

00:11:45,839 --> 00:11:47,920
since

00:11:46,240 --> 00:11:49,680
since native add-ons are stored as

00:11:47,920 --> 00:11:51,279
shared libraries a shared library is not

00:11:49,680 --> 00:11:52,720
loaded multiple times from disk it's

00:11:51,279 --> 00:11:55,040
only loaded once

00:11:52,720 --> 00:11:57,360
and so so what you consider to be a

00:11:55,040 --> 00:12:01,120
global static variable exists only once

00:11:57,360 --> 00:12:02,800
in the in in actual memory and so if you

00:12:01,120 --> 00:12:04,480
start accessing the same global static

00:12:02,800 --> 00:12:05,920
variables from multiple threads

00:12:04,480 --> 00:12:08,560
then you end up shooting yourself in the

00:12:05,920 --> 00:12:11,680
foot that's sooner or later sec faulting

00:12:08,560 --> 00:12:13,920
and yes c plus plus nowadays has

00:12:11,680 --> 00:12:15,440
something called thread local as a as a

00:12:13,920 --> 00:12:17,760
storage class specifier

00:12:15,440 --> 00:12:18,720
however that is also not recommended

00:12:17,760 --> 00:12:21,600
because

00:12:18,720 --> 00:12:22,720
uh a javascript thread may or may not

00:12:21,600 --> 00:12:24,639
coincide with

00:12:22,720 --> 00:12:26,480
with a native thread so it is possible

00:12:24,639 --> 00:12:28,240
to create a javascript world

00:12:26,480 --> 00:12:30,320
without creating a new thread in which

00:12:28,240 --> 00:12:32,000
case into that javascript world

00:12:30,320 --> 00:12:34,320
a native add-on will be loaded but

00:12:32,000 --> 00:12:37,279
really it's two worlds running

00:12:34,320 --> 00:12:38,399
uh in sequence back and forth time

00:12:37,279 --> 00:12:40,320
sliced

00:12:38,399 --> 00:12:41,839
and cooperatively multitasking on the

00:12:40,320 --> 00:12:44,399
same thread

00:12:41,839 --> 00:12:47,120
and so the best solution is to use

00:12:44,399 --> 00:12:49,360
self-contained add-ons

00:12:47,120 --> 00:12:51,440
where it is guaranteed that multiple

00:12:49,360 --> 00:12:54,079
instances can be launched

00:12:51,440 --> 00:12:55,760
and uh the the cleanup is no longer

00:12:54,079 --> 00:12:57,760
process cleanup it's cleanup of this

00:12:55,760 --> 00:13:00,399
javascript world which may be

00:12:57,760 --> 00:13:01,200
the process it may be a thread or it may

00:13:00,399 --> 00:13:03,600
be multiple

00:13:01,200 --> 00:13:04,560
javascript worlds we call them

00:13:03,600 --> 00:13:06,480
environments

00:13:04,560 --> 00:13:07,600
running on the same thread since you

00:13:06,480 --> 00:13:10,399
don't know which it is

00:13:07,600 --> 00:13:11,040
it's best to to use these apis to store

00:13:10,399 --> 00:13:16,160
what

00:13:11,040 --> 00:13:19,279
you need in terms of uh global data

00:13:16,160 --> 00:13:22,000
and accordingly we made an api and

00:13:19,279 --> 00:13:23,839
a per add-on instance variable it is no

00:13:22,000 --> 00:13:26,639
longer shared among add-ons

00:13:23,839 --> 00:13:28,160
and so this gives us a good hook for for

00:13:26,639 --> 00:13:31,360
adding native data

00:13:28,160 --> 00:13:31,360
may i have the next slide please

00:13:32,720 --> 00:13:37,440
so we have several tools that support

00:13:34,959 --> 00:13:38,480
this on the c side we have an api module

00:13:37,440 --> 00:13:42,240
in it

00:13:38,480 --> 00:13:45,600
which which is basically a macro uh that

00:13:42,240 --> 00:13:47,519
plays the role of uh a function header

00:13:45,600 --> 00:13:50,160
with and it gives you the formal

00:13:47,519 --> 00:13:53,199
parameters env and exports

00:13:50,160 --> 00:13:56,160
uh where env is an api environment

00:13:53,199 --> 00:13:58,160
and exports is an api value so it's it's

00:13:56,160 --> 00:14:01,680
a very usual arrangement

00:13:58,160 --> 00:14:02,959
so basically uh it is when you call an

00:14:01,680 --> 00:14:04,880
api module in it

00:14:02,959 --> 00:14:06,560
it is expected that it's followed by a

00:14:04,880 --> 00:14:07,600
body that is the implementation of a

00:14:06,560 --> 00:14:10,480
function

00:14:07,600 --> 00:14:11,680
which can assume that variables e and v

00:14:10,480 --> 00:14:15,120
exists

00:14:11,680 --> 00:14:17,760
uh env and exports exist and that env

00:14:15,120 --> 00:14:19,360
is of type an api and exports is of type

00:14:17,760 --> 00:14:21,399
and api value

00:14:19,360 --> 00:14:22,800
and so here you do the usual

00:14:21,399 --> 00:14:25,279
initialization

00:14:22,800 --> 00:14:27,040
uh except that now you you can be

00:14:25,279 --> 00:14:28,560
certain that this add-on can be loaded

00:14:27,040 --> 00:14:30,160
multiple times and

00:14:28,560 --> 00:14:31,839
from multiple threads and so forth

00:14:30,160 --> 00:14:35,360
whereas with with

00:14:31,839 --> 00:14:39,040
um what did we have before um

00:14:35,360 --> 00:14:41,120
an api if you just use an api module

00:14:39,040 --> 00:14:42,399
without using an api module in it then

00:14:41,120 --> 00:14:44,639
that may or may not be

00:14:42,399 --> 00:14:46,800
nowadays an api module works as well but

00:14:44,639 --> 00:14:48,560
there was a period when it didn't and so

00:14:46,800 --> 00:14:50,399
so we introduced this macro which

00:14:48,560 --> 00:14:53,519
ensures that it will always work

00:14:50,399 --> 00:14:53,519
may have the next slide please

00:14:54,560 --> 00:14:58,079
so where do you put your data just

00:14:56,800 --> 00:15:00,079
because your module is

00:14:58,079 --> 00:15:01,279
is is now supports getting loaded

00:15:00,079 --> 00:15:03,600
multiple times

00:15:01,279 --> 00:15:06,079
you still need a place other than global

00:15:03,600 --> 00:15:08,959
static to put your data right and so

00:15:06,079 --> 00:15:10,000
to to support that we introduced methods

00:15:08,959 --> 00:15:13,040
napi get an

00:15:10,000 --> 00:15:14,639
api set instance data and it's they're

00:15:13,040 --> 00:15:18,000
very simple methods

00:15:14,639 --> 00:15:18,880
they basically associate one void star

00:15:18,000 --> 00:15:22,079
pointer

00:15:18,880 --> 00:15:24,720
with uh an instance of napi

00:15:22,079 --> 00:15:27,040
n and set obviously sets it get

00:15:24,720 --> 00:15:27,519
obviously gets it if you set it twice

00:15:27,040 --> 00:15:30,160
then

00:15:27,519 --> 00:15:32,399
then it forgets the old one so be very

00:15:30,160 --> 00:15:35,519
careful it's basically a matter of

00:15:32,399 --> 00:15:37,279
of uh uh project management to decide

00:15:35,519 --> 00:15:39,360
who gets the privilege of

00:15:37,279 --> 00:15:41,440
of of calling this and and setting the

00:15:39,360 --> 00:15:43,920
the data for everybody

00:15:41,440 --> 00:15:45,040
and it is their responsibility to then

00:15:43,920 --> 00:15:47,440
sort of

00:15:45,040 --> 00:15:49,440
uh delegate access to this so that

00:15:47,440 --> 00:15:51,199
others may attach pointers if you

00:15:49,440 --> 00:15:53,120
if your project structure happens to be

00:15:51,199 --> 00:15:55,040
such otherwise

00:15:53,120 --> 00:15:58,480
it is under your sole discretion what

00:15:55,040 --> 00:16:00,480
you do with these two apis

00:15:58,480 --> 00:16:02,639
it accepts a clean up parameter so the

00:16:00,480 --> 00:16:04,880
usual napi finalize

00:16:02,639 --> 00:16:06,320
uh mechanism works with this data as

00:16:04,880 --> 00:16:08,880
well so that you can

00:16:06,320 --> 00:16:09,600
it basically acts as a destructor uh

00:16:08,880 --> 00:16:12,399
when you're

00:16:09,600 --> 00:16:14,560
when your add-on is being uh cleaned up

00:16:12,399 --> 00:16:16,079
and so that way that way you can align

00:16:14,560 --> 00:16:17,759
the life cycle of your data with the

00:16:16,079 --> 00:16:20,560
life cycle of your add-on

00:16:17,759 --> 00:16:20,560
next slide please

00:16:20,959 --> 00:16:25,040
so here's an example right we define a

00:16:23,440 --> 00:16:28,639
structure called add-on data

00:16:25,040 --> 00:16:28,639
right and we define a

00:16:28,800 --> 00:16:34,480
deleter for it a finalizer and so

00:16:32,000 --> 00:16:36,720
so we use an api module in it because

00:16:34,480 --> 00:16:38,800
this guarantees that our module will be

00:16:36,720 --> 00:16:39,920
uh available multiple times and it will

00:16:38,800 --> 00:16:41,680
be loadable and

00:16:39,920 --> 00:16:44,880
will work correctly when loaded multiple

00:16:41,680 --> 00:16:47,440
times and inside the body we create

00:16:44,880 --> 00:16:48,560
an object of type of type add-on data

00:16:47,440 --> 00:16:51,839
and we call net

00:16:48,560 --> 00:16:54,959
an api set instance data and we pass it

00:16:51,839 --> 00:16:56,399
the this data and the and the deleter

00:16:54,959 --> 00:16:58,880
right the finalizer

00:16:56,399 --> 00:17:00,160
and if you look on line 5 through 10

00:16:58,880 --> 00:17:02,839
that's when

00:17:00,160 --> 00:17:04,880
uh our function gets called from

00:17:02,839 --> 00:17:07,439
javascript

00:17:04,880 --> 00:17:08,240
and we can maintain so we can access

00:17:07,439 --> 00:17:11,039
this global

00:17:08,240 --> 00:17:11,520
data by using an api get instance data

00:17:11,039 --> 00:17:13,439
and then

00:17:11,520 --> 00:17:15,120
you can you know basically use it in

00:17:13,439 --> 00:17:16,480
whatever stateful way you would use a

00:17:15,120 --> 00:17:18,559
global variable that

00:17:16,480 --> 00:17:19,520
you would have had in in previous

00:17:18,559 --> 00:17:23,199
versions of

00:17:19,520 --> 00:17:25,600
of of your add-on implementation

00:17:23,199 --> 00:17:26,799
so yeah i i guess that's that's the most

00:17:25,600 --> 00:17:30,840
basic usage of

00:17:26,799 --> 00:17:32,160
of set and get instance data next slide

00:17:30,840 --> 00:17:35,360
please

00:17:32,160 --> 00:17:36,400
so in in uh node add-on api we we have

00:17:35,360 --> 00:17:39,520
the luxury of

00:17:36,400 --> 00:17:42,720
of of uh uh having more convenient c

00:17:39,520 --> 00:17:43,440
plus plus uh abstractions on top of this

00:17:42,720 --> 00:17:46,799
and one of the

00:17:43,440 --> 00:17:47,600
one of the most uh intuitive ways that

00:17:46,799 --> 00:17:51,120
you can

00:17:47,600 --> 00:17:52,960
you can create uh and make use of uh

00:17:51,120 --> 00:17:54,559
uh create self-contained add-ons and

00:17:52,960 --> 00:17:57,200
make use of add-on

00:17:54,559 --> 00:17:58,720
and api set and get instance data is by

00:17:57,200 --> 00:18:01,280
using the add-on class

00:17:58,720 --> 00:18:03,919
the add-on class works almost exactly

00:18:01,280 --> 00:18:07,200
the same way as object wrap meaning that

00:18:03,919 --> 00:18:09,360
you you you take a c plus plus class and

00:18:07,200 --> 00:18:10,720
you basically expose it to javascript

00:18:09,360 --> 00:18:13,679
only in this case

00:18:10,720 --> 00:18:14,160
um the life cycle of an instance of this

00:18:13,679 --> 00:18:16,320
class

00:18:14,160 --> 00:18:17,679
coincides with the life cycle of an

00:18:16,320 --> 00:18:21,919
add-on instance

00:18:17,679 --> 00:18:25,120
so basically methods that you add

00:18:21,919 --> 00:18:25,120
using the instance method

00:18:26,240 --> 00:18:31,919
api to this add-on class are basically

00:18:29,440 --> 00:18:33,600
your your bindings they are not

00:18:31,919 --> 00:18:35,280
they are not associated with with a

00:18:33,600 --> 00:18:36,960
class that you might expose

00:18:35,280 --> 00:18:39,200
but they are associated with the add-on

00:18:36,960 --> 00:18:41,600
itself and uh

00:18:39,200 --> 00:18:43,679
in the next slide which i'm now kindly

00:18:41,600 --> 00:18:46,400
asking for you will see how how this all

00:18:43,679 --> 00:18:46,400
hangs together

00:18:46,480 --> 00:18:49,520
so so this is the this is the definition

00:18:48,960 --> 00:18:52,640
this is

00:18:49,520 --> 00:18:56,480
a complete and functioning uh

00:18:52,640 --> 00:19:00,799
node add-on api add-on the class

00:18:56,480 --> 00:19:04,640
my add-on is a subclass of an api add-on

00:19:00,799 --> 00:19:05,200
and it in the in the constructor you

00:19:04,640 --> 00:19:07,679
basically

00:19:05,200 --> 00:19:10,000
define all the methods that you would

00:19:07,679 --> 00:19:12,799
like your add-on to have

00:19:10,000 --> 00:19:13,280
and you use that using define add-on and

00:19:12,799 --> 00:19:14,960
in this

00:19:13,280 --> 00:19:17,840
in this case we define a very simple

00:19:14,960 --> 00:19:21,840
add-on which just increments a value

00:19:17,840 --> 00:19:24,480
and um it and basically

00:19:21,840 --> 00:19:26,000
uh doesn't do anything else and so we

00:19:24,480 --> 00:19:28,240
expose that method as

00:19:26,000 --> 00:19:29,679
the increment method to javascript and

00:19:28,240 --> 00:19:32,000
when the method gets called

00:19:29,679 --> 00:19:32,799
it increments a value called x and you

00:19:32,000 --> 00:19:35,440
notice

00:19:32,799 --> 00:19:37,039
notice that uh the increment method on

00:19:35,440 --> 00:19:39,760
line 8 through 10

00:19:37,039 --> 00:19:41,760
is basically the c plus version of the

00:19:39,760 --> 00:19:45,120
method in the previous example

00:19:41,760 --> 00:19:46,799
that is that has the an api get instance

00:19:45,120 --> 00:19:49,039
data call built in so by

00:19:46,799 --> 00:19:50,480
so so the increment method is an

00:19:49,039 --> 00:19:52,640
instance method

00:19:50,480 --> 00:19:53,919
of class miad on it's not a static

00:19:52,640 --> 00:19:57,039
method right and so

00:19:53,919 --> 00:20:00,240
the instance that it receives was stored

00:19:57,039 --> 00:20:03,280
uh in on the environment using napi

00:20:00,240 --> 00:20:07,120
set instance data and so even though

00:20:03,280 --> 00:20:10,640
even though increment is not uh is not a

00:20:07,120 --> 00:20:12,720
a javascript uh object instance method

00:20:10,640 --> 00:20:14,640
it is a c plus plus instance method and

00:20:12,720 --> 00:20:16,080
so you can easily access this state

00:20:14,640 --> 00:20:18,960
and you don't have to store any global

00:20:16,080 --> 00:20:19,679
variables so in older versions of this

00:20:18,960 --> 00:20:21,520
api

00:20:19,679 --> 00:20:23,760
into x equals zero would have been

00:20:21,520 --> 00:20:25,200
declared at the global scope but now you

00:20:23,760 --> 00:20:27,760
don't have to do that

00:20:25,200 --> 00:20:28,640
and the the construction and destruction

00:20:27,760 --> 00:20:32,000
of these

00:20:28,640 --> 00:20:35,280
uh instances is handled by an api

00:20:32,000 --> 00:20:38,559
or no data on api itself and you declare

00:20:35,280 --> 00:20:40,720
that you wish your add-on to be

00:20:38,559 --> 00:20:42,559
represented by class my add-on by using

00:20:40,720 --> 00:20:45,200
this new macro called node api

00:20:42,559 --> 00:20:46,960
add-on we have node api module which

00:20:45,200 --> 00:20:47,679
just which creates an old-fashioned

00:20:46,960 --> 00:20:50,080
module

00:20:47,679 --> 00:20:51,679
where you have to use uh the instance

00:20:50,080 --> 00:20:55,039
data yourself

00:20:51,679 --> 00:20:58,640
um but this this uh

00:20:55,039 --> 00:21:00,480
this macro uh additionally gives you the

00:20:58,640 --> 00:21:02,000
uh the convenience of not having to do

00:21:00,480 --> 00:21:05,039
that anymore and and

00:21:02,000 --> 00:21:07,360
and uh the methods of of

00:21:05,039 --> 00:21:08,240
the my add-on class will will uh

00:21:07,360 --> 00:21:10,960
retrieve the

00:21:08,240 --> 00:21:12,559
instance data from the environment for

00:21:10,960 --> 00:21:14,240
you and so you can just treat

00:21:12,559 --> 00:21:17,840
everything as an instance variable next

00:21:14,240 --> 00:21:17,840
slide please

00:21:18,159 --> 00:21:22,799
so um what else what else do we have

00:21:20,799 --> 00:21:26,159
besides besides multi-threading

00:21:22,799 --> 00:21:26,159
and and

00:21:26,320 --> 00:21:30,720
context-sensitive add-ons which can be

00:21:27,919 --> 00:21:32,480
loaded multiple times

00:21:30,720 --> 00:21:34,240
we also we also added several like

00:21:32,480 --> 00:21:36,159
convenience methods because they proved

00:21:34,240 --> 00:21:39,760
very popular

00:21:36,159 --> 00:21:41,679
one of them is date object obviously

00:21:39,760 --> 00:21:42,320
it's it's used extensively in javascript

00:21:41,679 --> 00:21:44,080
and

00:21:42,320 --> 00:21:46,720
very often it gets transferred to the

00:21:44,080 --> 00:21:49,760
native side we added big end support

00:21:46,720 --> 00:21:52,559
as as it rolled around in the in in the

00:21:49,760 --> 00:21:55,679
engine we also rolled it out into

00:21:52,559 --> 00:21:57,520
our api we added support for detaching

00:21:55,679 --> 00:22:00,720
array buffers

00:21:57,520 --> 00:22:02,240
which means basically you you promise

00:22:00,720 --> 00:22:03,919
that you will no longer use the array

00:22:02,240 --> 00:22:06,000
buffer and it just turns into

00:22:03,919 --> 00:22:06,960
sort of a stub object and it cannot be

00:22:06,000 --> 00:22:11,039
used anymore

00:22:06,960 --> 00:22:13,600
next slide please and we also added

00:22:11,039 --> 00:22:15,120
an api to freeze and seal javascript

00:22:13,600 --> 00:22:18,080
objects this is very useful

00:22:15,120 --> 00:22:20,640
for for electron it basically renders a

00:22:18,080 --> 00:22:23,760
javascript object variously

00:22:20,640 --> 00:22:26,480
unable to be extended and so forth and

00:22:23,760 --> 00:22:28,320
the properties are all frozen so they

00:22:26,480 --> 00:22:32,480
cannot be changed anymore

00:22:28,320 --> 00:22:35,039
and we also added uh an api to tag a

00:22:32,480 --> 00:22:38,480
javascript object for type checking now

00:22:35,039 --> 00:22:41,840
what this means is that um

00:22:38,480 --> 00:22:44,320
once once an object is tagged uh

00:22:41,840 --> 00:22:46,000
you you can later check what what the

00:22:44,320 --> 00:22:47,039
value of the tag is and you can be

00:22:46,000 --> 00:22:49,440
certain that

00:22:47,039 --> 00:22:50,480
that the the native data that you

00:22:49,440 --> 00:22:52,080
associated with that

00:22:50,480 --> 00:22:53,600
object is indeed a pointer of the

00:22:52,080 --> 00:22:56,799
correct type

00:22:53,600 --> 00:22:59,120
so the story behind this is that

00:22:56,799 --> 00:23:01,840
we realized that using prototype

00:22:59,120 --> 00:23:04,720
manipulation it is possible to fool

00:23:01,840 --> 00:23:05,600
a native add-on into thinking that an

00:23:04,720 --> 00:23:07,600
instance of a

00:23:05,600 --> 00:23:09,840
of a certain class of of javascript

00:23:07,600 --> 00:23:12,080
object is of that class

00:23:09,840 --> 00:23:13,919
while while in reality being an instance

00:23:12,080 --> 00:23:15,760
of a different class and so

00:23:13,919 --> 00:23:17,679
so what this means is if both of these

00:23:15,760 --> 00:23:19,200
javascript classes were created using

00:23:17,679 --> 00:23:20,960
object wrap meaning that

00:23:19,200 --> 00:23:23,520
their methods are backed by native

00:23:20,960 --> 00:23:27,200
methods then it is possible to

00:23:23,520 --> 00:23:29,360
to retrieve a pointer that refers to a

00:23:27,200 --> 00:23:32,320
native structure of a different type and

00:23:29,360 --> 00:23:34,320
cast it to the wrong type of structure

00:23:32,320 --> 00:23:36,000
using prototype manipulation and this is

00:23:34,320 --> 00:23:37,760
especially true if you have

00:23:36,000 --> 00:23:39,840
multiple native add-ons interacting with

00:23:37,760 --> 00:23:41,360
one another and objects from one native

00:23:39,840 --> 00:23:42,799
add-on end up being passed into the

00:23:41,360 --> 00:23:45,840
other and so forth

00:23:42,799 --> 00:23:48,480
and so to avoid that we are

00:23:45,840 --> 00:23:50,000
now making it possible to unambiguously

00:23:48,480 --> 00:23:53,200
tag an object using

00:23:50,000 --> 00:23:54,159
uh like a uuid and which is basically

00:23:53,200 --> 00:23:57,520
stored as

00:23:54,159 --> 00:23:59,840
two two consecutive 64-bit integers

00:23:57,520 --> 00:24:01,440
and so you can you can basically paint

00:23:59,840 --> 00:24:03,840
the object with the uuid

00:24:01,440 --> 00:24:04,880
and then later on retrieve the uuid and

00:24:03,840 --> 00:24:07,360
compare it

00:24:04,880 --> 00:24:08,880
with one that is stored in your add-on

00:24:07,360 --> 00:24:11,679
and yes you can store this

00:24:08,880 --> 00:24:13,360
in a global static way because it's

00:24:11,679 --> 00:24:15,520
read-only you store it once

00:24:13,360 --> 00:24:16,960
it's const and so you can read it from

00:24:15,520 --> 00:24:18,080
any number of threads you cannot write

00:24:16,960 --> 00:24:20,720
to it so this

00:24:18,080 --> 00:24:21,600
so the so the context sensitivity is not

00:24:20,720 --> 00:24:24,880
affected by

00:24:21,600 --> 00:24:26,559
uh by by this uh

00:24:24,880 --> 00:24:29,360
uh by these tags so these tags are

00:24:26,559 --> 00:24:32,640
unaffected by context sensitivity

00:24:29,360 --> 00:24:35,200
next slide please

00:24:32,640 --> 00:24:36,880
all right so this is all these are all

00:24:35,200 --> 00:24:37,679
the modern tools that are available to

00:24:36,880 --> 00:24:40,159
you

00:24:37,679 --> 00:24:41,679
so you know where do you get started so

00:24:40,159 --> 00:24:43,600
one of one of the best ways to get

00:24:41,679 --> 00:24:45,520
started really is is to just

00:24:43,600 --> 00:24:46,799
pick something that you want to do like

00:24:45,520 --> 00:24:49,600
what do you wish

00:24:46,799 --> 00:24:50,559
node.js had that you had when you were

00:24:49,600 --> 00:24:53,760
still doing c

00:24:50,559 --> 00:24:56,880
plus what kind of cool library that does

00:24:53,760 --> 00:24:58,400
image processing encryption uh some

00:24:56,880 --> 00:25:00,799
network protocol

00:24:58,400 --> 00:25:02,640
you pick one of those libraries and you

00:25:00,799 --> 00:25:04,080
start writing bindings for it right

00:25:02,640 --> 00:25:05,679
and you can use all the tools that we

00:25:04,080 --> 00:25:06,640
discussed and you can look at these

00:25:05,679 --> 00:25:09,919
resources

00:25:06,640 --> 00:25:12,559
to see all the basics for for writing uh

00:25:09,919 --> 00:25:14,799
add-ons so for example the node api

00:25:12,559 --> 00:25:16,320
documentation is a great place to start

00:25:14,799 --> 00:25:18,080
it's a c api so

00:25:16,320 --> 00:25:19,600
if that's not to your liking then you

00:25:18,080 --> 00:25:20,320
can jump straight to the c plus plus

00:25:19,600 --> 00:25:22,320
wrapper

00:25:20,320 --> 00:25:24,320
uh which will result in code that

00:25:22,320 --> 00:25:27,120
essentially ends up calling the c api

00:25:24,320 --> 00:25:28,720
in in certain well-known and and and uh

00:25:27,120 --> 00:25:30,559
often use patterns

00:25:28,720 --> 00:25:32,080
so you can think of the c plus wrapper

00:25:30,559 --> 00:25:33,840
as basically a really really really

00:25:32,080 --> 00:25:36,880
fancy set of like

00:25:33,840 --> 00:25:38,000
macros um so you do not sacrifice api

00:25:36,880 --> 00:25:39,360
stability if you use the c

00:25:38,000 --> 00:25:41,600
plus press wrapper that's probably the

00:25:39,360 --> 00:25:45,039
most important take away

00:25:41,600 --> 00:25:47,840
we have a great many uh tutorials

00:25:45,039 --> 00:25:49,600
uh we have examples of of simple add-ons

00:25:47,840 --> 00:25:51,200
and simple calling patterns and how you

00:25:49,600 --> 00:25:52,159
get from javascript to native and back

00:25:51,200 --> 00:25:55,200
to javascript

00:25:52,159 --> 00:25:58,320
synchronously asynchronously using

00:25:55,200 --> 00:26:00,000
safe functions all those examples are

00:25:58,320 --> 00:26:02,400
are at the link you can see

00:26:00,000 --> 00:26:03,440
we have we have a workshop that that you

00:26:02,400 --> 00:26:05,279
can watch

00:26:03,440 --> 00:26:07,600
uh and we even have a conversion tool

00:26:05,279 --> 00:26:09,760
which uses regular expression to take

00:26:07,600 --> 00:26:10,720
regular expressions to to take your

00:26:09,760 --> 00:26:12,720
existing

00:26:10,720 --> 00:26:13,919
uh project if you've already ported

00:26:12,720 --> 00:26:15,360
something to

00:26:13,919 --> 00:26:16,880
to node and you've already written

00:26:15,360 --> 00:26:17,360
bindings for it however you wrote them

00:26:16,880 --> 00:26:20,159
in nan

00:26:17,360 --> 00:26:21,919
or or directly in v8 then we'll try to

00:26:20,159 --> 00:26:23,679
do a decent job of catching all the

00:26:21,919 --> 00:26:25,039
places where we can do like a one-to-one

00:26:23,679 --> 00:26:27,200
mapping expect

00:26:25,039 --> 00:26:28,880
many compilation errors afterwards

00:26:27,200 --> 00:26:30,559
because obviously it's not a perfect

00:26:28,880 --> 00:26:34,240
tool but it should give you a

00:26:30,559 --> 00:26:36,640
a good start um on uh on getting

00:26:34,240 --> 00:26:38,960
getting to an api and to abi stability

00:26:36,640 --> 00:26:41,039
as a result all right

00:26:38,960 --> 00:26:43,679
then we have we have a generator which

00:26:41,039 --> 00:26:45,840
basically creates a skeleton

00:26:43,679 --> 00:26:49,120
module for you which you can then flesh

00:26:45,840 --> 00:26:49,120
out and add bindings to

00:26:50,640 --> 00:26:53,919
and we have two different versions of

00:26:52,559 --> 00:26:56,799
this uh

00:26:53,919 --> 00:26:58,320
gen epi is is is is another is another

00:26:56,799 --> 00:27:00,080
option you might have

00:26:58,320 --> 00:27:01,919
and we have if you if you're not a big

00:27:00,080 --> 00:27:02,320
fan of cnc plus plus we have bindings

00:27:01,919 --> 00:27:05,919
for

00:27:02,320 --> 00:27:07,279
neon i mean for rust via via neon and we

00:27:05,919 --> 00:27:10,159
also have

00:27:07,279 --> 00:27:12,080
an api rs so you can write your add-on

00:27:10,159 --> 00:27:15,039
in rust essentially and then you can

00:27:12,080 --> 00:27:17,120
you can use the an api implementation

00:27:15,039 --> 00:27:18,880
provided by node.js via

00:27:17,120 --> 00:27:21,279
the rust language rather than directly

00:27:18,880 --> 00:27:23,520
using c or c plus plus

00:27:21,279 --> 00:27:24,320
and finally uh the the things kevin

00:27:23,520 --> 00:27:26,960
talked about

00:27:24,320 --> 00:27:28,799
uh at the beginning about uh packaging

00:27:26,960 --> 00:27:32,240
your ad on once you have it

00:27:28,799 --> 00:27:34,720
um pre-build is a is a great solution um

00:27:32,240 --> 00:27:36,159
and and one thing that i might add to

00:27:34,720 --> 00:27:39,039
all of these uh

00:27:36,159 --> 00:27:40,720
solutions is that uh they all fall back

00:27:39,039 --> 00:27:43,600
to compiling the code

00:27:40,720 --> 00:27:45,840
if you happen not to have provided uh a

00:27:43,600 --> 00:27:48,399
precompiled binary for that specific

00:27:45,840 --> 00:27:48,880
platform or that specific architecture

00:27:48,399 --> 00:27:50,559
so

00:27:48,880 --> 00:27:53,679
they all try to compile the code if they

00:27:50,559 --> 00:27:55,520
fail to download a pre-built binary so

00:27:53,679 --> 00:27:57,440
so it'll it'll solve a lot of your

00:27:55,520 --> 00:27:59,600
problems and if it doesn't

00:27:57,440 --> 00:28:00,960
and you get a you know you may get fewer

00:27:59,600 --> 00:28:02,559
bug reports because people actually

00:28:00,960 --> 00:28:03,919
figured out that if they have a compiler

00:28:02,559 --> 00:28:05,679
it'll still work

00:28:03,919 --> 00:28:08,399
so it's it's a good fallback to have

00:28:05,679 --> 00:28:08,399
next slide please

00:28:09,520 --> 00:28:13,360
yeah so so these are these are links to

00:28:12,080 --> 00:28:16,640
to the other tools that kevin

00:28:13,360 --> 00:28:18,159
was talking about pre-build defy

00:28:16,640 --> 00:28:19,840
is another tool that allows you to

00:28:18,159 --> 00:28:23,360
pre-package and uh

00:28:19,840 --> 00:28:26,159
and build add-ons uh no pre-jip likewise

00:28:23,360 --> 00:28:27,200
different slightly different flavors uh

00:28:26,159 --> 00:28:29,760
c-mac js

00:28:27,200 --> 00:28:30,559
is not such a package however it is a

00:28:29,760 --> 00:28:33,760
way to

00:28:30,559 --> 00:28:35,840
avoid using nodejib um and uh

00:28:33,760 --> 00:28:38,000
it it integrates better in fact no jip

00:28:35,840 --> 00:28:40,559
is is sort of kind of

00:28:38,000 --> 00:28:42,080
uh unmaintained now so we're using it

00:28:40,559 --> 00:28:45,279
for node and we're maintaining it

00:28:42,080 --> 00:28:47,679
only in so far as node.js needs it

00:28:45,279 --> 00:28:49,679
and so it's it's actually it's actually

00:28:47,679 --> 00:28:50,880
a good idea to migrate to to a more

00:28:49,679 --> 00:28:55,120
widely used

00:28:50,880 --> 00:28:55,120
uh build system if you can

00:28:55,360 --> 00:28:59,440
and so uh we have an example like a real

00:28:58,559 --> 00:29:02,480
life example

00:28:59,440 --> 00:29:06,000
from mongodb uh about uh

00:29:02,480 --> 00:29:06,399
how how one specific add-on was migrated

00:29:06,000 --> 00:29:09,919
from

00:29:06,399 --> 00:29:10,799
from nan to to node api um and so you

00:29:09,919 --> 00:29:13,679
can read up on

00:29:10,799 --> 00:29:14,640
on the ins and outs gotchas and so forth

00:29:13,679 --> 00:29:16,799
of

00:29:14,640 --> 00:29:18,799
of of people who have gathered real life

00:29:16,799 --> 00:29:19,360
experience in in this area that may also

00:29:18,799 --> 00:29:21,440
help you

00:29:19,360 --> 00:29:23,679
with with your own porting next slide

00:29:21,440 --> 00:29:23,679
please

00:29:24,720 --> 00:29:28,320
and finally if you would like to

00:29:26,480 --> 00:29:31,600
contribute to to our effort

00:29:28,320 --> 00:29:32,080
you can you can uh read about uh our

00:29:31,600 --> 00:29:35,360
work

00:29:32,080 --> 00:29:37,919
at abi stable node uh that's where we

00:29:35,360 --> 00:29:39,760
keep sort of the the design discussions

00:29:37,919 --> 00:29:41,200
and and the milestones that we wish to

00:29:39,760 --> 00:29:44,720
achieve

00:29:41,200 --> 00:29:46,799
and uh of course if you find issues uh

00:29:44,720 --> 00:29:48,640
and you would wish to contribute to an

00:29:46,799 --> 00:29:49,200
api or any other part of node you can

00:29:48,640 --> 00:29:52,159
just

00:29:49,200 --> 00:29:54,240
open the repo and and uh file an issue

00:29:52,159 --> 00:29:56,399
file a pr

00:29:54,240 --> 00:29:58,159
and if you wish to contribute to the

00:29:56,399 --> 00:30:00,799
wrappers then know that on api is the

00:29:58,159 --> 00:30:03,440
place to go that's where we maintain

00:30:00,799 --> 00:30:05,840
pull requests and issues that that

00:30:03,440 --> 00:30:08,960
people find while using

00:30:05,840 --> 00:30:10,799
our our node api wrappers the the c

00:30:08,960 --> 00:30:13,200
plus wrappers and of course you're

00:30:10,799 --> 00:30:16,799
always welcome to to join our meeting

00:30:13,200 --> 00:30:19,200
uh it's uh weekly on fridays at 8 a.m

00:30:16,799 --> 00:30:21,440
pacific time

00:30:19,200 --> 00:30:23,600
and we always we're always happy to see

00:30:21,440 --> 00:30:25,760
new faces so by all means if you wish

00:30:23,600 --> 00:30:27,120
if you're interested in getting up to

00:30:25,760 --> 00:30:29,279
speed with contributing

00:30:27,120 --> 00:30:30,799
or if you just found the typo and you

00:30:29,279 --> 00:30:33,679
feel like you need to share it with the

00:30:30,799 --> 00:30:35,440
with the group by all means uh come on

00:30:33,679 --> 00:30:36,320
to the meeting and we'll be happy to

00:30:35,440 --> 00:30:38,480
receive you

00:30:36,320 --> 00:30:39,520
that was it folks thank you for

00:30:38,480 --> 00:30:44,240
listening

00:30:39,520 --> 00:30:44,240

YouTube URL: https://www.youtube.com/watch?v=4cCSPw-I0GE


