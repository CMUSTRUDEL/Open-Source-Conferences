Title: Type-safe GraphQL with TypeScript - Aaron Powell, Microsoft
Publication date: 2021-05-28
Playlist: OpenJS World 2021
Description: 
	When building with GraphQL you define the schema up front and this can be really handy go use when it comes to writing the queries, resolvers, etc., especially if it’s in TypeScript. So, how do you go about doing the type generation? We’ll take a look at a tool that can generate you the TypeScript types, then implement our backend using them before looking at how they can plug into the front end with React Hooks. We’ll cap off by learning how to model our storage platform effectively using its own types and combine them with the GraphQL schema types.
Captions: 
	00:00:00,560 --> 00:00:04,240
hey folks welcome to typesafegraphql

00:00:03,120 --> 00:00:05,520
with thai script

00:00:04,240 --> 00:00:07,759
my name is aaron powell and i'm a

00:00:05,520 --> 00:00:09,599
principal cloud advocate at microsoft

00:00:07,759 --> 00:00:10,880
over the last 15 or so years i've been

00:00:09,599 --> 00:00:12,639
doing web development

00:00:10,880 --> 00:00:14,960
starting with languages like classic asp

00:00:12,639 --> 00:00:16,960
and php through to.net

00:00:14,960 --> 00:00:18,160
compiled languages on the server and

00:00:16,960 --> 00:00:20,000
then eventually to

00:00:18,160 --> 00:00:22,240
javascript on the server and javascript

00:00:20,000 --> 00:00:24,000
in the client in my time i've

00:00:22,240 --> 00:00:25,599
been building web applications i've seen

00:00:24,000 --> 00:00:28,240
all sorts of different ways we can do

00:00:25,599 --> 00:00:30,160
data access whether it's just normal

00:00:28,240 --> 00:00:33,440
page refreshes and getting more data on

00:00:30,160 --> 00:00:35,280
requests to custom built apis to serve

00:00:33,440 --> 00:00:37,920
out you know kind of like

00:00:35,280 --> 00:00:38,719
ajaxis sort of endpoints for an

00:00:37,920 --> 00:00:39,920
application

00:00:38,719 --> 00:00:42,480
through to really strict rest

00:00:39,920 --> 00:00:42,879
implementations but today i want to talk

00:00:42,480 --> 00:00:44,480
about

00:00:42,879 --> 00:00:46,800
specifically graphql which is another

00:00:44,480 --> 00:00:47,840
way which we can do data access

00:00:46,800 --> 00:00:49,200
if you want to get in touch with me

00:00:47,840 --> 00:00:50,719
after the session you'll find all my

00:00:49,200 --> 00:00:52,559
details here on the slides

00:00:50,719 --> 00:00:53,920
and do feel free to reach out if you've

00:00:52,559 --> 00:00:55,360
got any questions that i don't get a

00:00:53,920 --> 00:00:57,920
chance to cover off in the q

00:00:55,360 --> 00:00:58,640
a i'll do my best to answer them after

00:00:57,920 --> 00:01:02,000
the session

00:00:58,640 --> 00:01:03,359
if i uh or at least help you along the

00:01:02,000 --> 00:01:04,799
way of finding the answers if i don't

00:01:03,359 --> 00:01:06,479
know them myself

00:01:04,799 --> 00:01:07,840
but that's enough about me you're here

00:01:06,479 --> 00:01:08,560
not to learn about me and my background

00:01:07,840 --> 00:01:10,720
my history

00:01:08,560 --> 00:01:12,000
you're here to learn about graphql and

00:01:10,720 --> 00:01:14,240
typescript and how we can work with

00:01:12,000 --> 00:01:16,000
those together

00:01:14,240 --> 00:01:17,360
but before we get into looking at how we

00:01:16,000 --> 00:01:19,040
can build an application i want to talk

00:01:17,360 --> 00:01:21,759
a bit about what graphql is

00:01:19,040 --> 00:01:23,280
and why it's interesting graphql was

00:01:21,759 --> 00:01:26,320
originally created by facebook

00:01:23,280 --> 00:01:27,920
as a query language for doing client and

00:01:26,320 --> 00:01:30,320
server in your actions

00:01:27,920 --> 00:01:32,479
it's not how you implement a server or

00:01:30,320 --> 00:01:34,560
it's not a client implementation

00:01:32,479 --> 00:01:36,240
but it's more a specification of how

00:01:34,560 --> 00:01:37,360
those two can talk to each other

00:01:36,240 --> 00:01:38,840
so you still build a server

00:01:37,360 --> 00:01:40,079
implementation whether it's in

00:01:38,840 --> 00:01:43,360
javascript

00:01:40,079 --> 00:01:44,159
net node python etc we can build

00:01:43,360 --> 00:01:45,360
whatever we need

00:01:44,159 --> 00:01:47,439
for the kinds of applications we're

00:01:45,360 --> 00:01:48,640
building and then we can build a client

00:01:47,439 --> 00:01:48,960
that's also going to be able to talk

00:01:48,640 --> 00:01:50,880
over

00:01:48,960 --> 00:01:52,640
the same protocol generate the kinds of

00:01:50,880 --> 00:01:54,079
queries that are expected and send them

00:01:52,640 --> 00:01:55,600
to the server

00:01:54,079 --> 00:01:57,200
so what makes graphical different to

00:01:55,600 --> 00:01:59,200
rest because rest is the most common way

00:01:57,200 --> 00:02:01,439
that people have built apis in

00:01:59,200 --> 00:02:02,960
at least in the past well the main

00:02:01,439 --> 00:02:04,479
difference is that rest is very

00:02:02,960 --> 00:02:06,159
centered around the way the server

00:02:04,479 --> 00:02:07,200
visualizes its data and wants to expose

00:02:06,159 --> 00:02:08,479
that out

00:02:07,200 --> 00:02:10,479
let's say we're building a trivia

00:02:08,479 --> 00:02:12,080
application and inside of that we're

00:02:10,479 --> 00:02:12,560
going to have made three primary model

00:02:12,080 --> 00:02:14,640
types

00:02:12,560 --> 00:02:16,000
we've got our game we've got players and

00:02:14,640 --> 00:02:17,599
we've got questions

00:02:16,000 --> 00:02:19,200
now in a rest scenario at least in a

00:02:17,599 --> 00:02:21,120
very strict approach to doing rest

00:02:19,200 --> 00:02:22,400
probably have a game endpoint so slash

00:02:21,120 --> 00:02:24,720
api slash game

00:02:22,400 --> 00:02:25,680
and then from that we can get back uh an

00:02:24,720 --> 00:02:27,760
ap a game

00:02:25,680 --> 00:02:29,680
based off its id and then from that we

00:02:27,760 --> 00:02:31,040
would have an array of ids of

00:02:29,680 --> 00:02:33,040
questions and players that we then have

00:02:31,040 --> 00:02:35,280
to follow through and then do additional

00:02:33,040 --> 00:02:37,680
requests to get all that information

00:02:35,280 --> 00:02:38,800
now this might be a little bit over uh

00:02:37,680 --> 00:02:40,640
complex for

00:02:38,800 --> 00:02:42,319
some scenarios where you are fetching

00:02:40,640 --> 00:02:43,920
data but it's also going to be ideal for

00:02:42,319 --> 00:02:45,040
others

00:02:43,920 --> 00:02:47,440
i'm not here to tell you that you should

00:02:45,040 --> 00:02:48,560
be using graphql or rest in uh for your

00:02:47,440 --> 00:02:50,480
kind of applications you've got to work

00:02:48,560 --> 00:02:51,599
out that one on yourself on your own

00:02:50,480 --> 00:02:53,920
depending on the kinds of applications

00:02:51,599 --> 00:02:56,160
you're building graphql though

00:02:53,920 --> 00:02:57,360
is a kind of the flipped model for

00:02:56,160 --> 00:02:58,879
compared to rest

00:02:57,360 --> 00:03:00,879
so where rest is all about what the

00:02:58,879 --> 00:03:01,840
server defines how you do your data

00:03:00,879 --> 00:03:03,599
access

00:03:01,840 --> 00:03:05,200
graphql is more about how the client

00:03:03,599 --> 00:03:06,800
wants to be able to get data

00:03:05,200 --> 00:03:08,560
you still expose the data models that

00:03:06,800 --> 00:03:10,560
your server has available to it

00:03:08,560 --> 00:03:12,400
but it is up to the client to determine

00:03:10,560 --> 00:03:13,680
how it wants to query for that data

00:03:12,400 --> 00:03:15,200
and then to build other queries that are

00:03:13,680 --> 00:03:16,720
going to be right for the particular

00:03:15,200 --> 00:03:18,480
requests that it needs to be doing

00:03:16,720 --> 00:03:21,040
and for the data it needs at that point

00:03:18,480 --> 00:03:22,720
in time now this can avoid scenarios

00:03:21,040 --> 00:03:24,239
where you're over fetching data

00:03:22,720 --> 00:03:26,000
getting data that you don't actually

00:03:24,239 --> 00:03:28,400
need at that point in time because

00:03:26,000 --> 00:03:30,000
you're trying to say just display the

00:03:28,400 --> 00:03:30,799
the high score board at the end of the

00:03:30,000 --> 00:03:32,319
trivia game

00:03:30,799 --> 00:03:34,560
well maybe you don't need all the

00:03:32,319 --> 00:03:35,920
questions but you unfortunately might

00:03:34,560 --> 00:03:37,440
have to get those if the

00:03:35,920 --> 00:03:39,280
depending on how the rest model is set

00:03:37,440 --> 00:03:40,720
up in graphql you can be a lot more

00:03:39,280 --> 00:03:42,080
selective about that and only get the

00:03:40,720 --> 00:03:43,519
data that you need

00:03:42,080 --> 00:03:45,680
but as i said i'm not here to tell you

00:03:43,519 --> 00:03:46,799
exactly when to use rest versus graphql

00:03:45,680 --> 00:03:49,200
i'm here to look at the specific

00:03:46,799 --> 00:03:50,879
scenarios of how we can do type safety

00:03:49,200 --> 00:03:53,200
with graphql

00:03:50,879 --> 00:03:54,560
so why is type safety with graphql a

00:03:53,200 --> 00:03:56,560
topic of conversation

00:03:54,560 --> 00:03:58,799
well with the graphql schema that we can

00:03:56,560 --> 00:04:01,599
build out it's going to be type safe

00:03:58,799 --> 00:04:02,720
we define strongly typed data models and

00:04:01,599 --> 00:04:04,560
the fields that are available

00:04:02,720 --> 00:04:06,080
inside of those data models we then

00:04:04,560 --> 00:04:07,840
define strongly types the queries and

00:04:06,080 --> 00:04:09,040
mutations so how we can get data and how

00:04:07,840 --> 00:04:11,360
we can change data

00:04:09,040 --> 00:04:12,640
that are available inside of our our

00:04:11,360 --> 00:04:14,080
server and for our clients to

00:04:12,640 --> 00:04:15,680
communicate on

00:04:14,080 --> 00:04:17,120
so having this type information

00:04:15,680 --> 00:04:18,720
originally to start with is a good

00:04:17,120 --> 00:04:19,680
building block for building a type safe

00:04:18,720 --> 00:04:21,519
application

00:04:19,680 --> 00:04:22,960
but with javascript well we can lose a

00:04:21,519 --> 00:04:24,639
lot of that type safety anyway because

00:04:22,960 --> 00:04:25,440
javascript is an inherently untyped

00:04:24,639 --> 00:04:28,080
language

00:04:25,440 --> 00:04:29,120
that's where typescript can come to play

00:04:28,080 --> 00:04:29,759
so what are we going to be building

00:04:29,120 --> 00:04:30,800
today

00:04:29,759 --> 00:04:32,479
well we're going to be building an

00:04:30,800 --> 00:04:33,840
application with two components we're

00:04:32,479 --> 00:04:35,199
going to start with the server

00:04:33,840 --> 00:04:37,600
and for that server i'm going to be

00:04:35,199 --> 00:04:39,199
using the apollo graphql framework

00:04:37,600 --> 00:04:40,960
so this is a server implementation of

00:04:39,199 --> 00:04:42,800
graphql that can run in a variety of

00:04:40,960 --> 00:04:44,880
different manners whether it's on a web

00:04:42,800 --> 00:04:46,720
server platform like express or cover

00:04:44,880 --> 00:04:48,000
or you can run it in a serverless model

00:04:46,720 --> 00:04:49,840
which i'm going to be using azure

00:04:48,000 --> 00:04:51,680
functions to do

00:04:49,840 --> 00:04:53,280
i just like the serverless model but

00:04:51,680 --> 00:04:54,000
it's the same approach whether you're

00:04:53,280 --> 00:04:56,000
doing a

00:04:54,000 --> 00:04:57,120
a server or a serverless model or

00:04:56,000 --> 00:04:58,240
whether you're using any of the

00:04:57,120 --> 00:05:00,000
different

00:04:58,240 --> 00:05:02,320
underlying providers that apollo

00:05:00,000 --> 00:05:04,080
supports

00:05:02,320 --> 00:05:05,039
and then from a client standpoint well

00:05:04,080 --> 00:05:06,000
we're going to need a client that's

00:05:05,039 --> 00:05:07,199
going to connect to that and i'm going

00:05:06,000 --> 00:05:09,440
to be building a react

00:05:07,199 --> 00:05:10,560
based web application now the stuff that

00:05:09,440 --> 00:05:13,520
i'm covering up here

00:05:10,560 --> 00:05:14,800
isn't exclusively supported by react it

00:05:13,520 --> 00:05:16,080
could be applied to any of the other

00:05:14,800 --> 00:05:16,880
javascript frameworks you might be using

00:05:16,080 --> 00:05:19,440
whether it's felt

00:05:16,880 --> 00:05:21,039
angular vue et cetera i just prefer

00:05:19,440 --> 00:05:22,720
react because it's the one that i've

00:05:21,039 --> 00:05:24,639
had the most experience with and it's

00:05:22,720 --> 00:05:26,320
kind of my my go-to approach with doing

00:05:24,639 --> 00:05:28,160
web applications but like i said

00:05:26,320 --> 00:05:29,840
it's entirely up to you um how you want

00:05:28,160 --> 00:05:30,560
to do the client and the stuff i will be

00:05:29,840 --> 00:05:32,160
showing you

00:05:30,560 --> 00:05:33,840
is applicable to pretty much every

00:05:32,160 --> 00:05:35,520
javascript framework

00:05:33,840 --> 00:05:37,360
but i said we want to do end-to-end type

00:05:35,520 --> 00:05:38,639
safety so that's where typescript's

00:05:37,360 --> 00:05:40,080
going to come into play

00:05:38,639 --> 00:05:42,240
i'm going to be using typescript as a

00:05:40,080 --> 00:05:44,479
way to model out our

00:05:42,240 --> 00:05:46,720
backend and also do strongly type

00:05:44,479 --> 00:05:48,639
front-ends but what i want is the type

00:05:46,720 --> 00:05:50,800
information i have in my graphql schema

00:05:48,639 --> 00:05:52,639
available on both client and server so

00:05:50,800 --> 00:05:54,880
they are literally talking the same

00:05:52,639 --> 00:05:57,039
language

00:05:54,880 --> 00:05:58,080
so let's jump out of the slides and have

00:05:57,039 --> 00:05:59,759
a look at how we can do that

00:05:58,080 --> 00:06:02,000
with a bit of a demo i'm going to go

00:05:59,759 --> 00:06:02,720
through a subset of a larger workshop

00:06:02,000 --> 00:06:03,759
that i've got

00:06:02,720 --> 00:06:05,360
share the link to that at the end if

00:06:03,759 --> 00:06:06,400
you're interested and we're going to be

00:06:05,360 --> 00:06:08,000
building out a couple of different

00:06:06,400 --> 00:06:09,680
pieces that look at the specific type

00:06:08,000 --> 00:06:12,000
safe aspects of building a graphql

00:06:09,680 --> 00:06:12,000
server

00:06:13,039 --> 00:06:16,240
so here we are in vs code and it's time

00:06:15,120 --> 00:06:18,720
to get started

00:06:16,240 --> 00:06:20,240
i said this is a workshop where i've

00:06:18,720 --> 00:06:22,479
already got some of the stuff set up

00:06:20,240 --> 00:06:23,919
and here is a graphql schema that i've

00:06:22,479 --> 00:06:25,600
pre-defined

00:06:23,919 --> 00:06:27,120
as we can see i've got a number of types

00:06:25,600 --> 00:06:27,680
that are available i have a question

00:06:27,120 --> 00:06:30,560
type

00:06:27,680 --> 00:06:32,000
a game that game has questions available

00:06:30,560 --> 00:06:34,639
to it so we've got types that reference

00:06:32,000 --> 00:06:35,360
other types that we have i have some

00:06:34,639 --> 00:06:36,479
enums

00:06:35,360 --> 00:06:39,039
and if we scroll down a little bit

00:06:36,479 --> 00:06:41,039
further we'll see that we have a query

00:06:39,039 --> 00:06:43,440
so this is the entry point when someone

00:06:41,039 --> 00:06:45,120
is doing a request against their fql

00:06:43,440 --> 00:06:46,400
server and these are the things that

00:06:45,120 --> 00:06:48,080
you're able to do against it you're able

00:06:46,400 --> 00:06:49,680
to get back again by its id

00:06:48,080 --> 00:06:51,840
you're able to get back all the games in

00:06:49,680 --> 00:06:53,599
the system and you're able to get back

00:06:51,840 --> 00:06:55,360
a player's results for a particular game

00:06:53,599 --> 00:06:57,199
so there are answers so we can work out

00:06:55,360 --> 00:06:59,120
how many they got correct and versus how

00:06:57,199 --> 00:07:00,160
many they got incorrect

00:06:59,120 --> 00:07:01,039
what we're going to need to do is we're

00:07:00,160 --> 00:07:02,560
going to need to implement some

00:07:01,039 --> 00:07:04,240
resolvers that work with these

00:07:02,560 --> 00:07:05,680
so resolvers are functions that handle

00:07:04,240 --> 00:07:07,680
the queries or handle

00:07:05,680 --> 00:07:09,039
the graphql objects as they're being

00:07:07,680 --> 00:07:10,800
parsed through

00:07:09,039 --> 00:07:12,720
so let's pop over to another file called

00:07:10,800 --> 00:07:14,240
resolvers.ts

00:07:12,720 --> 00:07:16,639
i'm going to put the schema on the side

00:07:14,240 --> 00:07:18,479
here so inside of resolvers

00:07:16,639 --> 00:07:20,000
i'm going to start building out those

00:07:18,479 --> 00:07:20,639
queries that i've got here on the side

00:07:20,000 --> 00:07:22,800
and

00:07:20,639 --> 00:07:24,479
functions that handle those so in my

00:07:22,800 --> 00:07:25,759
resolver i have query which is a type

00:07:24,479 --> 00:07:27,280
name that matches the same type that i

00:07:25,759 --> 00:07:28,800
had inside of my schema

00:07:27,280 --> 00:07:30,639
and let's start with the easiest one

00:07:28,800 --> 00:07:32,479
which is game so

00:07:30,639 --> 00:07:33,680
sorry games because we just want to get

00:07:32,479 --> 00:07:36,400
all the games and

00:07:33,680 --> 00:07:37,759
well i need to return something but this

00:07:36,400 --> 00:07:38,880
is just an object that i've created it

00:07:37,759 --> 00:07:40,880
doesn't understand any type of

00:07:38,880 --> 00:07:41,919
information it's got no correlation to

00:07:40,880 --> 00:07:44,479
the type of information that we have

00:07:41,919 --> 00:07:45,919
with inside of our schema but because

00:07:44,479 --> 00:07:47,039
i've worked with apollo before i know

00:07:45,919 --> 00:07:47,520
that the first argument is going to be

00:07:47,039 --> 00:07:50,240
the

00:07:47,520 --> 00:07:52,080
parent of this in the object graph but

00:07:50,240 --> 00:07:52,639
this is a root entry point for a graphql

00:07:52,080 --> 00:07:54,879
schema

00:07:52,639 --> 00:07:56,479
so i don't have a parent at this point

00:07:54,879 --> 00:07:57,440
any arguments that could be provided to

00:07:56,479 --> 00:07:58,720
this operation

00:07:57,440 --> 00:08:00,240
i don't have any arguments at this point

00:07:58,720 --> 00:08:01,120
in time because games doesn't take any

00:08:00,240 --> 00:08:04,000
arguments

00:08:01,120 --> 00:08:04,879
and then finally i have a context where

00:08:04,000 --> 00:08:06,560
i can provide

00:08:04,879 --> 00:08:08,560
something oh i can get access to like

00:08:06,560 --> 00:08:10,240
services that have been injected

00:08:08,560 --> 00:08:12,080
and other stuff that are available for

00:08:10,240 --> 00:08:13,919
the lifetime of this request

00:08:12,080 --> 00:08:15,120
one of those things is data sources and

00:08:13,919 --> 00:08:16,639
that's going to give me access to my

00:08:15,120 --> 00:08:17,919
underlying database

00:08:16,639 --> 00:08:19,360
now i know that that's there because

00:08:17,919 --> 00:08:20,000
i've implemented this application and

00:08:19,360 --> 00:08:21,599
i've

00:08:20,000 --> 00:08:23,360
i know the code base so i know what's

00:08:21,599 --> 00:08:24,240
there but i don't have any type

00:08:23,360 --> 00:08:26,080
information

00:08:24,240 --> 00:08:27,440
i don't know that if i do data sources

00:08:26,080 --> 00:08:28,800
that there are any fields of this i

00:08:27,440 --> 00:08:30,879
could access

00:08:28,800 --> 00:08:32,800
having worked on this code base i know

00:08:30,879 --> 00:08:34,560
that i can do game which is a property

00:08:32,800 --> 00:08:36,240
available there and i can get games

00:08:34,560 --> 00:08:39,200
off that and that's going to return

00:08:36,240 --> 00:08:41,200
something that can be handled by graphql

00:08:39,200 --> 00:08:43,039
similarly if i want to implement the

00:08:41,200 --> 00:08:45,200
games uh

00:08:43,039 --> 00:08:46,720
the the the gauge resolver uh so i do

00:08:45,200 --> 00:08:47,360
game and then again we don't have a

00:08:46,720 --> 00:08:48,720
parent

00:08:47,360 --> 00:08:50,480
i know that the second argument will

00:08:48,720 --> 00:08:51,760
have uh objects

00:08:50,480 --> 00:08:53,760
an object which is the arguments that

00:08:51,760 --> 00:08:56,800
are provided by um the query

00:08:53,760 --> 00:08:59,519
and i can decompose this with the id and

00:08:56,800 --> 00:09:00,720
finally i can get data sources again and

00:08:59,519 --> 00:09:04,240
i know that i can return

00:09:00,720 --> 00:09:05,839
data sources game.getgame and provided

00:09:04,240 --> 00:09:07,600
with the id

00:09:05,839 --> 00:09:10,240
but again i only know this information

00:09:07,600 --> 00:09:12,240
because i built the code base myself

00:09:10,240 --> 00:09:13,279
if we have a look at any this it's all

00:09:12,240 --> 00:09:16,240
just untyped

00:09:13,279 --> 00:09:17,839
i have my nes everywhere and well now

00:09:16,240 --> 00:09:18,720
transcript really isn't giving me any

00:09:17,839 --> 00:09:20,480
value

00:09:18,720 --> 00:09:21,839
so i need to work out how can we get

00:09:20,480 --> 00:09:23,680
some of that schema value

00:09:21,839 --> 00:09:25,839
schema typed information here to make

00:09:23,680 --> 00:09:27,920
touchscript giving us some actual value

00:09:25,839 --> 00:09:29,279
or i just throw away typescript those

00:09:27,920 --> 00:09:30,959
are kind of the two endpoints that i've

00:09:29,279 --> 00:09:33,040
got here

00:09:30,959 --> 00:09:34,560
we'll jump through to a slightly more

00:09:33,040 --> 00:09:37,519
completed version of the application

00:09:34,560 --> 00:09:38,320
and have a look at that let's open up

00:09:37,519 --> 00:09:40,160
the resolvers again

00:09:38,320 --> 00:09:41,519
and we'll see that i've gone through and

00:09:40,160 --> 00:09:44,160
well i've got the same results

00:09:41,519 --> 00:09:45,680
for game and games i also have my player

00:09:44,160 --> 00:09:46,160
results so this is how i can get back

00:09:45,680 --> 00:09:48,240
the

00:09:46,160 --> 00:09:49,519
uh results that a player has submitted

00:09:48,240 --> 00:09:51,360
so their answers

00:09:49,519 --> 00:09:52,560
and we'll see again we're decomposing a

00:09:51,360 --> 00:09:54,959
couple of um

00:09:52,560 --> 00:09:56,480
fields out of there and without having

00:09:54,959 --> 00:09:58,240
the schema side by side

00:09:56,480 --> 00:10:00,080
do i know that it's game id and player

00:09:58,240 --> 00:10:01,279
id i

00:10:00,080 --> 00:10:03,600
i'm going to assume they are because

00:10:01,279 --> 00:10:04,000
that's what i i wrote previously in in

00:10:03,600 --> 00:10:06,720
the demo

00:10:04,000 --> 00:10:07,760
before i started um but yeah if you

00:10:06,720 --> 00:10:09,600
didn't have that scheme

00:10:07,760 --> 00:10:11,040
like immediately available it's it's a

00:10:09,600 --> 00:10:11,760
little bit opaque we don't know what's

00:10:11,040 --> 00:10:14,240
there

00:10:11,760 --> 00:10:15,360
well so this is an async function so

00:10:14,240 --> 00:10:17,920
we're awaiting on

00:10:15,360 --> 00:10:18,800
the get game method on our game data

00:10:17,920 --> 00:10:20,079
source

00:10:18,800 --> 00:10:21,920
but did we realize that that was

00:10:20,079 --> 00:10:22,880
something that returned a promise by

00:10:21,920 --> 00:10:24,640
looking at it

00:10:22,880 --> 00:10:26,000
previously no we didn't we know that

00:10:24,640 --> 00:10:27,519
because we know this code base and we

00:10:26,000 --> 00:10:28,640
can dig through it

00:10:27,519 --> 00:10:30,839
so this is where we want to start

00:10:28,640 --> 00:10:32,880
looking at how we can get that type safe

00:10:30,839 --> 00:10:36,560
information i'm going to

00:10:32,880 --> 00:10:37,519
install a new package install there it

00:10:36,560 --> 00:10:41,120
is

00:10:37,519 --> 00:10:43,279
i called graphql code gen cli so graphql

00:10:41,120 --> 00:10:46,560
code gen is a series of packages

00:10:43,279 --> 00:10:48,079
for generating code from graphql

00:10:46,560 --> 00:10:50,240
and this is a command line tool that

00:10:48,079 --> 00:10:52,880
will then allow me to generate out

00:10:50,240 --> 00:10:54,079
uh the the typescript definitions that i

00:10:52,880 --> 00:10:57,440
need

00:10:54,079 --> 00:10:59,680
so let's run npx

00:10:57,440 --> 00:11:01,360
graphql code gen in it and it's going to

00:10:59,680 --> 00:11:02,320
prompt us through a bit of a wizard on

00:11:01,360 --> 00:11:03,680
what we want

00:11:02,320 --> 00:11:06,000
we want to build a back end or api

00:11:03,680 --> 00:11:10,399
server uh the schema is at

00:11:06,000 --> 00:11:14,000
slash graphql schema dot graphql

00:11:10,399 --> 00:11:15,680
graph ql there we go uh

00:11:14,000 --> 00:11:17,839
we want to generate the typescript model

00:11:15,680 --> 00:11:19,519
definitions and we also want to generate

00:11:17,839 --> 00:11:22,079
the typescript resolver definitions so

00:11:19,519 --> 00:11:24,880
we can strongly type our resolvers

00:11:22,079 --> 00:11:26,320
uh we want to output this to say graph

00:11:24,880 --> 00:11:29,680
dot slash graph

00:11:26,320 --> 00:11:31,120
ql slash generated dot ts

00:11:29,680 --> 00:11:32,720
uh we generate an introspection file so

00:11:31,120 --> 00:11:34,640
that's just some debugging information

00:11:32,720 --> 00:11:35,839
we'll leave the default yaml file name

00:11:34,640 --> 00:11:37,920
and we're going to add a

00:11:35,839 --> 00:11:39,200
npm run script called gen that will be

00:11:37,920 --> 00:11:39,920
so that we can just run the code

00:11:39,200 --> 00:11:41,600
generator

00:11:39,920 --> 00:11:43,839
without having to do npx every single

00:11:41,600 --> 00:11:44,160
time uh so this is now going to go ahead

00:11:43,839 --> 00:11:46,000
and

00:11:44,160 --> 00:11:47,680
it's going to create us our yaml file

00:11:46,000 --> 00:11:49,760
for our config

00:11:47,680 --> 00:11:51,680
it's going to then update our package

00:11:49,760 --> 00:11:52,959
json with that new run script and with

00:11:51,680 --> 00:11:53,760
some additional dependencies that we're

00:11:52,959 --> 00:11:55,760
going to need

00:11:53,760 --> 00:11:57,600
and basically get our environment ready

00:11:55,760 --> 00:11:58,560
so that we can go ahead and build our

00:11:57,600 --> 00:12:01,120
graphql

00:11:58,560 --> 00:12:03,680
um our strongly typed information from

00:12:01,120 --> 00:12:07,360
our graphql schema file

00:12:03,680 --> 00:12:08,880
all right so if we do npm npm run gen

00:12:07,360 --> 00:12:11,040
we'll see that that's gone ahead and

00:12:08,880 --> 00:12:12,800
done it oh and it looks like

00:12:11,040 --> 00:12:16,240
i have got an error in something that

00:12:12,800 --> 00:12:16,240
i've added and

00:12:19,279 --> 00:12:23,120
i forgot to install my dependencies oops

00:12:21,360 --> 00:12:24,880
npm install

00:12:23,120 --> 00:12:26,880
because it added some new things to my

00:12:24,880 --> 00:12:28,240
package json and i completely forgot to

00:12:26,880 --> 00:12:29,920
do an npm install to make sure that they

00:12:28,240 --> 00:12:32,720
are installed as well so

00:12:29,920 --> 00:12:33,920
that's just a the joys of live demo is

00:12:32,720 --> 00:12:34,880
you've got to remember all the steps

00:12:33,920 --> 00:12:38,000
that you meant to run

00:12:34,880 --> 00:12:40,800
npm run gen we'll do that again

00:12:38,000 --> 00:12:42,079
take two and excellent that's worked

00:12:40,800 --> 00:12:46,000
successfully

00:12:42,079 --> 00:12:48,720
let's close off our terminal have a look

00:12:46,000 --> 00:12:50,000
and here is our new generated file so

00:12:48,720 --> 00:12:51,920
this has got a whole bunch of

00:12:50,000 --> 00:12:53,279
typescript type definitions we'll see

00:12:51,920 --> 00:12:55,839
that we've got question here

00:12:53,279 --> 00:12:56,880
and if we were to pop open our schema on

00:12:55,839 --> 00:12:58,639
the side

00:12:56,880 --> 00:13:00,399
go back to generated we'll see that

00:12:58,639 --> 00:13:01,839
that's what the same feels we have an id

00:13:00,399 --> 00:13:04,720
which is an id type

00:13:01,839 --> 00:13:06,000
which is using the scalar type of id

00:13:04,720 --> 00:13:09,360
we'll see that we've got

00:13:06,000 --> 00:13:10,079
our um our question correct answer and

00:13:09,360 --> 00:13:13,040
answers

00:13:10,079 --> 00:13:13,680
which are strings or arrays of strings

00:13:13,040 --> 00:13:15,360
we'll see

00:13:13,680 --> 00:13:18,079
a bit further down we have game which

00:13:15,360 --> 00:13:19,920
has uh scalar types and then it's got

00:13:18,079 --> 00:13:21,600
um some like some optional type so the

00:13:19,920 --> 00:13:23,279
game state is an optional value

00:13:21,600 --> 00:13:25,040
or we've got arrays which have got

00:13:23,279 --> 00:13:26,320
player and questions so on and so forth

00:13:25,040 --> 00:13:26,959
you kind of get the idea of where i'm

00:13:26,320 --> 00:13:28,320
going here

00:13:26,959 --> 00:13:30,079
one to one mapping between what our

00:13:28,320 --> 00:13:31,360
schema had

00:13:30,079 --> 00:13:34,240
what that does mean is that i can come

00:13:31,360 --> 00:13:35,600
into my resolver function a file here

00:13:34,240 --> 00:13:38,880
and then i can say that i want to

00:13:35,600 --> 00:13:42,639
strongly type this as resolvers

00:13:38,880 --> 00:13:44,160
resolvers resolvers

00:13:42,639 --> 00:13:46,639
there we go and that's going to come

00:13:44,160 --> 00:13:47,839
from api graphql generated so this will

00:13:46,639 --> 00:13:50,880
import that in

00:13:47,839 --> 00:13:53,199
and now we'll see that say

00:13:50,880 --> 00:13:55,120
the id is stronger type to string

00:13:53,199 --> 00:13:58,160
fantastic because we know that that

00:13:55,120 --> 00:13:58,880
is of our schema coming in as a string

00:13:58,160 --> 00:14:00,959
id

00:13:58,880 --> 00:14:02,480
we know that that's correct excellent so

00:14:00,959 --> 00:14:04,320
we can we know that that's there

00:14:02,480 --> 00:14:06,240
we know that same with player id is

00:14:04,320 --> 00:14:07,920
going to be all correct

00:14:06,240 --> 00:14:09,920
we know that the player results needs to

00:14:07,920 --> 00:14:10,720
return a particular type and so on and

00:14:09,920 --> 00:14:12,320
so forth so

00:14:10,720 --> 00:14:13,760
we're getting some of that type safe

00:14:12,320 --> 00:14:15,199
information

00:14:13,760 --> 00:14:16,560
we still don't know what our data source

00:14:15,199 --> 00:14:18,079
is though which is a little bit of a

00:14:16,560 --> 00:14:20,959
problem because well

00:14:18,079 --> 00:14:22,880
is it game or is it games i i'd have to

00:14:20,959 --> 00:14:24,560
dig through my own code base to remember

00:14:22,880 --> 00:14:26,720
um you know it's the kind of thing that

00:14:24,560 --> 00:14:29,360
you don't hit to run time

00:14:26,720 --> 00:14:30,720
but let's just do an npm start kick off

00:14:29,360 --> 00:14:32,320
our api and have a look at what's

00:14:30,720 --> 00:14:33,519
actually up and running

00:14:32,320 --> 00:14:35,360
now we'll give this a moment it's going

00:14:33,519 --> 00:14:37,199
to compile our typescript

00:14:35,360 --> 00:14:39,600
and there we go that's all up and

00:14:37,199 --> 00:14:44,959
running we'll start our local web server

00:14:39,600 --> 00:14:46,720
here we go here's our graphql endpoint

00:14:44,959 --> 00:14:48,160
and we'll zoom that in once it loads

00:14:46,720 --> 00:14:49,440
excellent uh this will load up the

00:14:48,160 --> 00:14:51,760
graphql playground

00:14:49,440 --> 00:14:53,680
and we'll see that excellent we can

00:14:51,760 --> 00:14:54,079
perform a query and here's a query that

00:14:53,680 --> 00:14:55,199
i've

00:14:54,079 --> 00:14:57,120
previously done so it's just going to

00:14:55,199 --> 00:14:58,000
dump out all the games the state of the

00:14:57,120 --> 00:15:00,160
game its id

00:14:58,000 --> 00:15:01,440
and uh the questions that were asked so

00:15:00,160 --> 00:15:03,440
if you hit run on this

00:15:01,440 --> 00:15:05,040
um it turns out that we get another

00:15:03,440 --> 00:15:06,959
error

00:15:05,040 --> 00:15:08,240
and you think that even if you're doing

00:15:06,959 --> 00:15:09,600
a pre-recorded talk you wouldn't have

00:15:08,240 --> 00:15:11,440
runtime errors and stuff like that you

00:15:09,600 --> 00:15:12,720
should get those in anything

00:15:11,440 --> 00:15:14,639
but no this is actually an area that i

00:15:12,720 --> 00:15:15,040
expect what it's saying is it can't

00:15:14,639 --> 00:15:17,199
return

00:15:15,040 --> 00:15:18,639
null from a non-null field question dot

00:15:17,199 --> 00:15:21,519
correct answer

00:15:18,639 --> 00:15:22,320
well that's because what we're doing is

00:15:21,519 --> 00:15:23,519
well

00:15:22,320 --> 00:15:25,120
actually let's just jump back to v's

00:15:23,519 --> 00:15:26,160
code and we'll have a look at that close

00:15:25,120 --> 00:15:28,160
off our terminal

00:15:26,160 --> 00:15:29,279
and we'll see that in our schema if we

00:15:28,160 --> 00:15:32,320
go up to the top

00:15:29,279 --> 00:15:36,000
we have correct answer but

00:15:32,320 --> 00:15:38,160
if we were to go through to data

00:15:36,000 --> 00:15:40,720
types so this is the definition of our

00:15:38,160 --> 00:15:43,040
our database so this is our database is

00:15:40,720 --> 00:15:44,160
the way our database visualizes types

00:15:43,040 --> 00:15:46,240
well we'll see that

00:15:44,160 --> 00:15:47,440
we actually saw correct underscore

00:15:46,240 --> 00:15:50,399
answer not correct

00:15:47,440 --> 00:15:50,720
answer as pascal case and similarly we

00:15:50,399 --> 00:15:54,079
have

00:15:50,720 --> 00:15:55,759
incorrect answers not answers in rate so

00:15:54,079 --> 00:15:56,160
the way that the schema is exposing

00:15:55,759 --> 00:15:59,199
stuff

00:15:56,160 --> 00:16:00,240
doesn't 100 map to what our database is

00:15:59,199 --> 00:16:01,680
because we don't want to expose our

00:16:00,240 --> 00:16:04,160
database directly

00:16:01,680 --> 00:16:05,600
and we are doing a bit of translation so

00:16:04,160 --> 00:16:06,160
we need to do something that tells us

00:16:05,600 --> 00:16:07,759
well

00:16:06,160 --> 00:16:09,440
that these two models need to map back

00:16:07,759 --> 00:16:11,519
and forth between each other as well

00:16:09,440 --> 00:16:13,120
something that we're currently not doing

00:16:11,519 --> 00:16:13,600
and for that we can add some model

00:16:13,120 --> 00:16:16,880
mapping

00:16:13,600 --> 00:16:20,880
inside of our code gen file

00:16:16,880 --> 00:16:22,560
so let's open up our cogen yaml

00:16:20,880 --> 00:16:24,399
and we're going to add some model

00:16:22,560 --> 00:16:26,320
mappers

00:16:24,399 --> 00:16:28,000
actually we'll jump across and i'll show

00:16:26,320 --> 00:16:28,880
this in a completed version rather than

00:16:28,000 --> 00:16:30,320
uh

00:16:28,880 --> 00:16:31,680
rather than potentially running doing

00:16:30,320 --> 00:16:32,800
some more runtime errors we're running

00:16:31,680 --> 00:16:34,480
out of time for today

00:16:32,800 --> 00:16:36,959
so let's try and get things working as

00:16:34,480 --> 00:16:40,079
much as we can

00:16:36,959 --> 00:16:42,800
let's come into api

00:16:40,079 --> 00:16:43,680
gogen.yaml and if we have a look here

00:16:42,800 --> 00:16:46,720
i've generated

00:16:43,680 --> 00:16:47,839
i've configured my code generator so

00:16:46,720 --> 00:16:49,360
it's got some context

00:16:47,839 --> 00:16:51,360
come back to that in a moment but most

00:16:49,360 --> 00:16:52,880
importantly we have mappers

00:16:51,360 --> 00:16:54,880
this map is saying when you find a

00:16:52,880 --> 00:16:58,000
graphql type of question

00:16:54,880 --> 00:16:59,680
we're going to use our graph question

00:16:58,000 --> 00:17:01,440
model type which is defined in

00:16:59,680 --> 00:17:06,079
typescript

00:17:01,440 --> 00:17:10,319
if we do npm run gen here

00:17:06,079 --> 00:17:12,959
oh uh npm l i am in the wrong folder

00:17:10,319 --> 00:17:14,640
where are we where are we going we are

00:17:12,959 --> 00:17:19,760
going to

00:17:14,640 --> 00:17:23,520
uh completed api there we go

00:17:19,760 --> 00:17:24,170
and npm run gen so we'll just generate

00:17:23,520 --> 00:17:26,079
out our

00:17:24,170 --> 00:17:29,360
[Music]

00:17:26,079 --> 00:17:31,520
typescript file excellent that'll be

00:17:29,360 --> 00:17:34,480
ready in just a minute there we go

00:17:31,520 --> 00:17:35,840
and if we have a graphql generated now

00:17:34,480 --> 00:17:36,960
we have a bit of additional information

00:17:35,840 --> 00:17:40,640
that's mapping between

00:17:36,960 --> 00:17:41,840
our our questions and our players

00:17:40,640 --> 00:17:43,280
because what it's doing is it's

00:17:41,840 --> 00:17:44,559
detecting that whenever it finds a

00:17:43,280 --> 00:17:45,520
question it's going to return a question

00:17:44,559 --> 00:17:47,440
model

00:17:45,520 --> 00:17:48,640
so how does this work with inside of our

00:17:47,440 --> 00:17:50,960
resolver

00:17:48,640 --> 00:17:53,280
well now our resolver function is going

00:17:50,960 --> 00:17:55,760
to return a type of

00:17:53,280 --> 00:17:57,120
this this is returning a game model

00:17:55,760 --> 00:18:00,160
which is expected here

00:17:57,120 --> 00:18:01,120
or player results is going to return a

00:18:00,160 --> 00:18:03,120
different kind of model

00:18:01,120 --> 00:18:04,400
and we're then going to map those a bit

00:18:03,120 --> 00:18:08,000
further down with

00:18:04,400 --> 00:18:09,200
our our object mappers with inside of

00:18:08,000 --> 00:18:10,880
our resolver

00:18:09,200 --> 00:18:12,400
so here it's saying if you find a

00:18:10,880 --> 00:18:14,160
question so this is the type that you

00:18:12,400 --> 00:18:17,679
need to return from graphql

00:18:14,160 --> 00:18:19,840
we're going to receive a question model

00:18:17,679 --> 00:18:21,679
so that's its parent this time

00:18:19,840 --> 00:18:23,520
and then from that we're going to

00:18:21,679 --> 00:18:25,039
generate a new thing which is going to

00:18:23,520 --> 00:18:26,240
return an array of strings

00:18:25,039 --> 00:18:28,080
so we're going to take the incorrect

00:18:26,240 --> 00:18:31,120
answers the correct answer

00:18:28,080 --> 00:18:32,720
and then return that out similarly with

00:18:31,120 --> 00:18:34,799
a correct answer we're just going to

00:18:32,720 --> 00:18:35,360
return the correct underscore answer

00:18:34,799 --> 00:18:38,640
field

00:18:35,360 --> 00:18:39,280
from the question model so now if i

00:18:38,640 --> 00:18:41,520
change my

00:18:39,280 --> 00:18:42,880
underlying data structure so inside of

00:18:41,520 --> 00:18:44,480
my database it's only called correct

00:18:42,880 --> 00:18:44,799
answer i change it to correct answer

00:18:44,480 --> 00:18:46,799
with

00:18:44,799 --> 00:18:48,160
you know with a pascal case well then

00:18:46,799 --> 00:18:49,760
this will start being a

00:18:48,160 --> 00:18:51,760
compilation error because this field no

00:18:49,760 --> 00:18:53,280
longer exists and then i know that i can

00:18:51,760 --> 00:18:55,679
remove this bit of code because i no

00:18:53,280 --> 00:18:57,760
longer need to do that custom mapping

00:18:55,679 --> 00:18:59,039
so this type end-to-end type safety is

00:18:57,760 --> 00:18:59,919
going all the way from our underlying

00:18:59,039 --> 00:19:01,760
database

00:18:59,919 --> 00:19:03,360
through to what our schema has defined

00:19:01,760 --> 00:19:04,240
and then we're having our resolver the

00:19:03,360 --> 00:19:06,240
thing that works

00:19:04,240 --> 00:19:08,880
to kind of merge those two together

00:19:06,240 --> 00:19:10,320
understand that type safety

00:19:08,880 --> 00:19:12,480
the other thing that i'm doing here is

00:19:10,320 --> 00:19:14,240
well i want my client application my

00:19:12,480 --> 00:19:17,360
react application to also work

00:19:14,240 --> 00:19:19,440
with this type information

00:19:17,360 --> 00:19:21,039
so if i come down into my touchscreen

00:19:19,440 --> 00:19:23,360
application i have

00:19:21,039 --> 00:19:24,880
say a page where we're going to create a

00:19:23,360 --> 00:19:26,320
new game

00:19:24,880 --> 00:19:28,640
so this is going to need to perform a

00:19:26,320 --> 00:19:30,559
mutation against our graphql server

00:19:28,640 --> 00:19:33,120
so it's going to need to create a new

00:19:30,559 --> 00:19:36,320
game so what i've done is i've created

00:19:33,120 --> 00:19:37,679
a reusable little bit of graphql

00:19:36,320 --> 00:19:39,840
a little graphql career that's really

00:19:37,679 --> 00:19:40,960
useful called great game that is just

00:19:39,840 --> 00:19:42,320
the mutation

00:19:40,960 --> 00:19:43,440
great game and this is what it's going

00:19:42,320 --> 00:19:44,160
to do and it's going to return me the

00:19:43,440 --> 00:19:45,280
game id

00:19:44,160 --> 00:19:46,480
i don't need all the other fields i

00:19:45,280 --> 00:19:48,640
don't need the questions at this point

00:19:46,480 --> 00:19:52,320
in time because i only need the id

00:19:48,640 --> 00:19:55,520
to go through to the next screen

00:19:52,320 --> 00:19:58,640
inside of my concrete yaml file for

00:19:55,520 --> 00:19:59,600
so my code gen yaml file for uh graphql

00:19:58,640 --> 00:20:01,200
code generator

00:19:59,600 --> 00:20:03,360
i've also said that i've got to generate

00:20:01,200 --> 00:20:05,600
a tsx file

00:20:03,360 --> 00:20:06,960
which is going to contain some react

00:20:05,600 --> 00:20:10,320
hooks

00:20:06,960 --> 00:20:12,880
and it's going to use the typescript

00:20:10,320 --> 00:20:14,159
plugin as a type operations plugin so

00:20:12,880 --> 00:20:16,720
it's going to load

00:20:14,159 --> 00:20:18,080
these files these operation files here

00:20:16,720 --> 00:20:19,919
so these are those pre-written

00:20:18,080 --> 00:20:21,120
queries and mutations and then it's

00:20:19,919 --> 00:20:24,320
going to generate me a

00:20:21,120 --> 00:20:26,880
typed document node so this is going to

00:20:24,320 --> 00:20:28,960
so this could generate me specific react

00:20:26,880 --> 00:20:30,400
uh hooks if i wanted them as react hooks

00:20:28,960 --> 00:20:30,880
or pyrolytic components and things like

00:20:30,400 --> 00:20:32,880
that

00:20:30,880 --> 00:20:34,799
but i've told it that i'm not going to

00:20:32,880 --> 00:20:36,320
use those plugins at this point in time

00:20:34,799 --> 00:20:38,400
instead i'm just going to return typed

00:20:36,320 --> 00:20:39,280
document nodes so these document nodes

00:20:38,400 --> 00:20:40,480
can be loaded by

00:20:39,280 --> 00:20:42,640
anything that's going to be consuming

00:20:40,480 --> 00:20:45,440
graphql whether it's

00:20:42,640 --> 00:20:45,760
react or angular or felt et cetera i'm

00:20:45,440 --> 00:20:47,120
just

00:20:45,760 --> 00:20:49,039
i said so happen to be doing this with

00:20:47,120 --> 00:20:52,320
react

00:20:49,039 --> 00:20:54,400
so this create dot game document is the

00:20:52,320 --> 00:20:57,120
thing that's been code generated for me

00:20:54,400 --> 00:20:57,760
i can then pass this to a used mutation

00:20:57,120 --> 00:21:00,720
which is

00:20:57,760 --> 00:21:01,520
from the apollo client for graphql so

00:21:00,720 --> 00:21:03,280
this is a

00:21:01,520 --> 00:21:04,559
custom react hook that apollo has given

00:21:03,280 --> 00:21:07,280
us

00:21:04,559 --> 00:21:07,919
i also have just some state some normal

00:21:07,280 --> 00:21:09,760
like

00:21:07,919 --> 00:21:11,440
um react state that's available to me as

00:21:09,760 --> 00:21:12,320
well that i'm putting some type

00:21:11,440 --> 00:21:14,000
information in

00:21:12,320 --> 00:21:15,919
that i'm putting some objects in and

00:21:14,000 --> 00:21:16,720
these i'm combining together to create a

00:21:15,919 --> 00:21:19,679
strongly typed

00:21:16,720 --> 00:21:20,799
version of um a query against our

00:21:19,679 --> 00:21:22,720
graphql server

00:21:20,799 --> 00:21:24,880
so i have my create game operation

00:21:22,720 --> 00:21:27,600
that's here that when executed

00:21:24,880 --> 00:21:29,120
so depending on when an effect is traded

00:21:27,600 --> 00:21:30,400
so someone has clicked the button to

00:21:29,120 --> 00:21:32,000
actually create the game

00:21:30,400 --> 00:21:33,360
it's going to call that hook which is

00:21:32,000 --> 00:21:35,039
going to perform some operations

00:21:33,360 --> 00:21:37,840
eventually we'll get back some data

00:21:35,039 --> 00:21:39,120
and that data is going to have if we

00:21:37,840 --> 00:21:40,240
have a look at that getting unpacked

00:21:39,120 --> 00:21:42,720
here we go

00:21:40,240 --> 00:21:44,240
down here on line 21 that gets unpacked

00:21:42,720 --> 00:21:46,240
we're not loading and we've called and

00:21:44,240 --> 00:21:49,679
there wasn't an error and we received

00:21:46,240 --> 00:21:50,799
the create game response then i know

00:21:49,679 --> 00:21:52,880
that i have

00:21:50,799 --> 00:21:54,240
an id field here which is going to be a

00:21:52,880 --> 00:21:56,000
string which is the value that i get

00:21:54,240 --> 00:21:58,960
back from performing that mutation

00:21:56,000 --> 00:21:59,520
against my graphql server so this might

00:21:58,960 --> 00:22:01,200
seem

00:21:59,520 --> 00:22:03,120
kind of a lot of parts that are all

00:22:01,200 --> 00:22:04,559
connected together but it all comes down

00:22:03,120 --> 00:22:06,559
to relying on

00:22:04,559 --> 00:22:08,000
the code that i'm generating out of here

00:22:06,559 --> 00:22:10,159
looking at

00:22:08,000 --> 00:22:11,200
a schema that i've got here combining

00:22:10,159 --> 00:22:13,760
that with some

00:22:11,200 --> 00:22:14,240
pre-written commands and operations that

00:22:13,760 --> 00:22:16,320
i've got

00:22:14,240 --> 00:22:17,440
with inside of my graphql application so

00:22:16,320 --> 00:22:18,400
the client has some pre-written

00:22:17,440 --> 00:22:19,840
operations

00:22:18,400 --> 00:22:21,600
working with a schema that i've got

00:22:19,840 --> 00:22:23,520
elsewhere and we're using the types

00:22:21,600 --> 00:22:27,520
end-to-end across those so that i can

00:22:23,520 --> 00:22:28,880
generate out type safe resolvers

00:22:27,520 --> 00:22:30,880
so these are the resolvers that are

00:22:28,880 --> 00:22:31,679
going to be returning custom model

00:22:30,880 --> 00:22:35,039
mappers

00:22:31,679 --> 00:22:37,200
so that i can map the underlying data

00:22:35,039 --> 00:22:38,799
structures of my database through to the

00:22:37,200 --> 00:22:40,799
types that my schema says are available

00:22:38,799 --> 00:22:43,600
to the clients and eventually have

00:22:40,799 --> 00:22:44,480
a client that is capable of using these

00:22:43,600 --> 00:22:47,039
operations

00:22:44,480 --> 00:22:47,520
generating some type information of them

00:22:47,039 --> 00:22:50,000
and then

00:22:47,520 --> 00:22:51,440
when say a mutation is called i get the

00:22:50,000 --> 00:22:54,000
data back and i get that

00:22:51,440 --> 00:22:55,280
data back in a tight way that i can have

00:22:54,000 --> 00:22:57,360
that field available to me

00:22:55,280 --> 00:22:58,720
and i know what it is and i can i can

00:22:57,360 --> 00:23:00,320
perform the correct step

00:22:58,720 --> 00:23:02,799
through in my application to get to the

00:23:00,320 --> 00:23:02,799
next point

00:23:06,159 --> 00:23:09,679
so i know that i was a real lot of

00:23:08,080 --> 00:23:10,720
information we covered in a very short

00:23:09,679 --> 00:23:12,960
period of time

00:23:10,720 --> 00:23:13,760
but i hope it gives you an idea of how

00:23:12,960 --> 00:23:15,679
you can do

00:23:13,760 --> 00:23:18,320
type-safe end-to-end graphql

00:23:15,679 --> 00:23:18,320
applications

00:23:19,200 --> 00:23:22,640
we looked at a subset of a workshop that

00:23:21,600 --> 00:23:23,919
i've got

00:23:22,640 --> 00:23:25,200
there's about eight different modules in

00:23:23,919 --> 00:23:26,880
that workshop that cover off how to

00:23:25,200 --> 00:23:27,760
build a graphql application with

00:23:26,880 --> 00:23:30,559
typescript

00:23:27,760 --> 00:23:31,600
um all the way from uh the first setting

00:23:30,559 --> 00:23:33,520
up of the server

00:23:31,600 --> 00:23:35,760
through to how we do that uh end-to-end

00:23:33,520 --> 00:23:37,440
type safety with a react application

00:23:35,760 --> 00:23:38,880
talking through to the graphql server

00:23:37,440 --> 00:23:40,080
back end so

00:23:38,880 --> 00:23:41,440
the link's there on the slide if you

00:23:40,080 --> 00:23:42,559
want to go check that out and have a bit

00:23:41,440 --> 00:23:45,120
more of a poke around

00:23:42,559 --> 00:23:46,799
in the code that was used inside of this

00:23:45,120 --> 00:23:48,159
demo

00:23:46,799 --> 00:23:49,840
the way that i approached this was using

00:23:48,159 --> 00:23:51,520
graphql code genre

00:23:49,840 --> 00:23:53,520
i like to go schema first in the way

00:23:51,520 --> 00:23:55,919
that i build out my typescript

00:23:53,520 --> 00:23:57,679
oh sorry my graphql servers so i tend to

00:23:55,919 --> 00:24:00,159
generate a graphql schema file and then

00:23:57,679 --> 00:24:01,600
want to export that as type information

00:24:00,159 --> 00:24:03,600
but there are other ways if you wanted

00:24:01,600 --> 00:24:05,600
to do more of

00:24:03,600 --> 00:24:07,039
use the typescript objects that you're

00:24:05,600 --> 00:24:07,520
creating so like classes and things like

00:24:07,039 --> 00:24:09,520
that

00:24:07,520 --> 00:24:11,360
and then use that to generate a graphql

00:24:09,520 --> 00:24:12,640
schema from it so kind of go the other

00:24:11,360 --> 00:24:15,279
way or

00:24:12,640 --> 00:24:17,279
and so there's there are projects out

00:24:15,279 --> 00:24:19,600
there that will do that

00:24:17,279 --> 00:24:20,480
that i haven't played around with much

00:24:19,600 --> 00:24:23,520
um but yeah

00:24:20,480 --> 00:24:24,240
if you prefer to do more of a a code

00:24:23,520 --> 00:24:25,919
first approach

00:24:24,240 --> 00:24:27,200
rather than a schema first approach um

00:24:25,919 --> 00:24:28,559
you can definitely tackle it in that

00:24:27,200 --> 00:24:29,840
regards

00:24:28,559 --> 00:24:31,760
if you're wanting to learn a bit more

00:24:29,840 --> 00:24:33,200
about how you can run graphql on azure

00:24:31,760 --> 00:24:34,400
um there's a link to a blog series that

00:24:33,200 --> 00:24:36,080
i've been writing that looks at all the

00:24:34,400 --> 00:24:38,240
different aspects of how we can

00:24:36,080 --> 00:24:39,600
do things like well actually taking this

00:24:38,240 --> 00:24:41,120
workshop that i've got here

00:24:39,600 --> 00:24:43,120
um how you can run that kind of a code

00:24:41,120 --> 00:24:44,480
base inside of azure as well as how you

00:24:43,120 --> 00:24:46,400
can run things

00:24:44,480 --> 00:24:48,240
on a server infrastructure rather than a

00:24:46,400 --> 00:24:51,039
service approach

00:24:48,240 --> 00:24:52,799
but that's all that i had time for today

00:24:51,039 --> 00:24:55,039
and all i wanted to cover off

00:24:52,799 --> 00:24:56,480
thank you for uh sticking around for the

00:24:55,039 --> 00:24:59,520
session thank you for

00:24:56,480 --> 00:25:00,000
letting me present some of my learnings

00:24:59,520 --> 00:25:02,559
that i've had

00:25:00,000 --> 00:25:03,760
when building strongly typed graphql

00:25:02,559 --> 00:25:05,039
applications

00:25:03,760 --> 00:25:06,400
i hope this has been interesting i hope

00:25:05,039 --> 00:25:07,840
you've learned something and i hope that

00:25:06,400 --> 00:25:08,400
it shows you that it is definitely

00:25:07,840 --> 00:25:10,159
possible

00:25:08,400 --> 00:25:11,840
to use the type of information we've got

00:25:10,159 --> 00:25:15,200
in graphql with

00:25:11,840 --> 00:25:17,200
a server and a client all together so we

00:25:15,200 --> 00:25:19,840
can do end-to-end type safety

00:25:17,200 --> 00:25:19,840

YouTube URL: https://www.youtube.com/watch?v=G2HUgV30EG4


