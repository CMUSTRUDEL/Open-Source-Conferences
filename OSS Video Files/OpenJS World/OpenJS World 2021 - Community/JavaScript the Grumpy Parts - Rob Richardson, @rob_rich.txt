Title: JavaScript the Grumpy Parts - Rob Richardson, @rob_rich
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - Community
Description: 
	We love JavaScript, but we must admit: it's weird. Why does `this` behave as it does? How does variable scope work? Why do we have such comical behavior when comparing mixed types? Let's pull back the covers of these scenarios, and learn how it truly works. You may find a new reason to fall in love with JavaScript.
Captions: 
	00:00:02,879 --> 00:00:05,279
hi

00:00:03,199 --> 00:00:07,200
welcome to openjs we're going to talk

00:00:05,279 --> 00:00:10,160
about javascript the grumpy parts

00:00:07,200 --> 00:00:11,920
javascript is kind of weird but well

00:00:10,160 --> 00:00:13,920
let's dig in and see how it works and

00:00:11,920 --> 00:00:16,400
see if we can understand why it's weird

00:00:13,920 --> 00:00:17,760
and make it a little bit less mysterious

00:00:16,400 --> 00:00:18,960
here's the part where i tell you i'm

00:00:17,760 --> 00:00:20,000
definitely going to post the slides on

00:00:18,960 --> 00:00:22,640
my site tonight

00:00:20,000 --> 00:00:24,320
and well they're already there i've been

00:00:22,640 --> 00:00:27,599
the person chasing the

00:00:24,320 --> 00:00:29,519
the st speaker as well and yeah

00:00:27,599 --> 00:00:30,800
here's javascript grumpy parts the

00:00:29,519 --> 00:00:32,559
slides are online

00:00:30,800 --> 00:00:34,399
right now while you're here on

00:00:32,559 --> 00:00:36,399
robrich.org click on

00:00:34,399 --> 00:00:38,079
about me and you'll get to this spot

00:00:36,399 --> 00:00:39,280
that talks a little bit about the things

00:00:38,079 --> 00:00:42,079
that i do

00:00:39,280 --> 00:00:44,399
i'm a microsoft mvp a friend of redgate

00:00:42,079 --> 00:00:44,960
a cyril developer evangelist and let me

00:00:44,399 --> 00:00:47,760
tell you

00:00:44,960 --> 00:00:49,039
about azgiv camp azgive camp brings

00:00:47,760 --> 00:00:50,879
volunteer developers

00:00:49,039 --> 00:00:53,039
together with charities to build free

00:00:50,879 --> 00:00:54,640
software we start friday after work

00:00:53,039 --> 00:00:56,320
sunday afternoon we deliver that

00:00:54,640 --> 00:00:58,480
completed software to the charities

00:00:56,320 --> 00:00:59,440
sleep is optional caffeine provided if

00:00:58,480 --> 00:01:01,600
you're in phoenix

00:00:59,440 --> 00:01:02,879
come join us for the next a-z gift camp

00:01:01,600 --> 00:01:03,920
or if you'd like a gift camp where

00:01:02,879 --> 00:01:06,080
you're connecting from

00:01:03,920 --> 00:01:07,360
hit me up on email or on twitter and

00:01:06,080 --> 00:01:08,799
let's get a gift camp in your

00:01:07,360 --> 00:01:10,240
neighborhood too

00:01:08,799 --> 00:01:12,000
some of the other things that i've done

00:01:10,240 --> 00:01:13,600
i worked on the gulp team as a core

00:01:12,000 --> 00:01:14,320
contributor in version two and version

00:01:13,600 --> 00:01:17,439
three

00:01:14,320 --> 00:01:19,200
and dot net rocks i replied to a.net

00:01:17,439 --> 00:01:20,080
rocks podcast episode they read my

00:01:19,200 --> 00:01:22,799
comment on the air

00:01:20,080 --> 00:01:26,240
and they sent me a mug so there's my

00:01:22,799 --> 00:01:28,400
claim to fame my coveted.net rocksmug

00:01:26,240 --> 00:01:30,720
so let's dig into javascript the grumpy

00:01:28,400 --> 00:01:30,720
parts

00:01:32,240 --> 00:01:35,840
now we will need to go a little fast

00:01:33,840 --> 00:01:36,479
because well we only have a half hour

00:01:35,840 --> 00:01:38,799
together

00:01:36,479 --> 00:01:40,079
but i would like to thank john mills he

00:01:38,799 --> 00:01:42,479
has a talk a job

00:01:40,079 --> 00:01:43,920
a guide to javascript's gary side that

00:01:42,479 --> 00:01:46,079
helped inspire this talk

00:01:43,920 --> 00:01:48,560
now he goes into different directions

00:01:46,079 --> 00:01:49,520
but his talk is amazing and so if you

00:01:48,560 --> 00:01:52,880
have a chance

00:01:49,520 --> 00:01:55,119
listen to him as well we'll probably hit

00:01:52,880 --> 00:01:55,759
the end of my knowledge and that'll be

00:01:55,119 --> 00:01:59,360
really fun

00:01:55,759 --> 00:02:04,399
i look forward to the part where i say

00:01:59,360 --> 00:02:07,520
i don't know in the beginning

00:02:04,399 --> 00:02:11,360
brendan ike created javascript

00:02:07,520 --> 00:02:13,520
in 10 days 25 years ago

00:02:11,360 --> 00:02:15,280
i've written some code 25 years ago and

00:02:13,520 --> 00:02:17,360
it was pretty awful

00:02:15,280 --> 00:02:20,720
and yet here we all are talking about

00:02:17,360 --> 00:02:21,840
javascript brendan did an amazing job

00:02:20,720 --> 00:02:24,319
if you'd like to learn more about

00:02:21,840 --> 00:02:26,239
brendan read more or watch more to see

00:02:24,319 --> 00:02:28,239
how he invented javascript it's really

00:02:26,239 --> 00:02:29,920
cool each of these blue links in the

00:02:28,239 --> 00:02:31,680
slides here from rawritch.org

00:02:29,920 --> 00:02:34,319
are links to be able to dial into

00:02:31,680 --> 00:02:36,560
additional information

00:02:34,319 --> 00:02:38,560
now what's really cool is we now have a

00:02:36,560 --> 00:02:39,440
bunch of javascript engines that are for

00:02:38,560 --> 00:02:42,400
the most part

00:02:39,440 --> 00:02:43,040
really high fidelity in v8 we have

00:02:42,400 --> 00:02:46,080
chrome

00:02:43,040 --> 00:02:48,959
in spider monkey we have firefox in uh

00:02:46,080 --> 00:02:51,440
in internet explorer we have chakra in

00:02:48,959 --> 00:02:54,319
safari we have javascript core

00:02:51,440 --> 00:02:54,800
and each of these javascript engines

00:02:54,319 --> 00:02:57,280
works

00:02:54,800 --> 00:02:59,840
pretty much the same brendan ike's

00:02:57,280 --> 00:03:01,680
library was cloned with amazing fidelity

00:02:59,840 --> 00:03:03,519
now we talk about differences between

00:03:01,680 --> 00:03:05,920
javascript in different browsers

00:03:03,519 --> 00:03:06,800
html5 has made that a little bit less of

00:03:05,920 --> 00:03:08,560
a concern

00:03:06,800 --> 00:03:10,800
but that was about our interaction with

00:03:08,560 --> 00:03:13,959
the document object model the dom

00:03:10,800 --> 00:03:16,400
the javascript runtime itself is

00:03:13,959 --> 00:03:19,840
amazingly compatible

00:03:16,400 --> 00:03:19,840
including all the bugs

00:03:20,000 --> 00:03:24,239
so javascript was copied with incredible

00:03:22,239 --> 00:03:26,560
precision including the bugs let's take

00:03:24,239 --> 00:03:29,440
a look at some of the weird things

00:03:26,560 --> 00:03:31,920
now some of the major design goals of

00:03:29,440 --> 00:03:32,400
this language was it was a language that

00:03:31,920 --> 00:03:35,599
well

00:03:32,400 --> 00:03:38,720
runs over there when we develop

00:03:35,599 --> 00:03:41,840
javascript we ship our source code

00:03:38,720 --> 00:03:44,000
a js file the browser is the one that

00:03:41,840 --> 00:03:47,040
compiles that js code into

00:03:44,000 --> 00:03:50,799
executable and runs it now that isn't

00:03:47,040 --> 00:03:53,040
quite right but we can use that analogy

00:03:50,799 --> 00:03:55,200
it runs over there after the developer

00:03:53,040 --> 00:03:56,239
has left so one of its primary

00:03:55,200 --> 00:03:59,599
objectives

00:03:56,239 --> 00:04:03,280
is to keep running as often as possible

00:03:59,599 --> 00:04:05,120
now if it keeps running

00:04:03,280 --> 00:04:06,959
it's going to try to be as forgiving as

00:04:05,120 --> 00:04:10,000
possible so

00:04:06,959 --> 00:04:11,360
well if it notices a syntax error it'll

00:04:10,000 --> 00:04:14,400
back up and see if it can put a

00:04:11,360 --> 00:04:16,560
semicolon in to be able to solve that

00:04:14,400 --> 00:04:17,519
now are semicolons required in

00:04:16,560 --> 00:04:20,560
javascript

00:04:17,519 --> 00:04:23,120
well yes they are but the engine may

00:04:20,560 --> 00:04:25,680
insert them automatically so if you see

00:04:23,120 --> 00:04:27,840
javascript without semicolons

00:04:25,680 --> 00:04:29,680
that's why we're leveraging that piece

00:04:27,840 --> 00:04:33,199
of the compiler that says

00:04:29,680 --> 00:04:33,199
hey let me fix that for you

00:04:33,840 --> 00:04:37,360
so let's take a look at some of the

00:04:35,280 --> 00:04:39,840
weird things in javascript

00:04:37,360 --> 00:04:41,040
this is the javascript watt talk and i'm

00:04:39,840 --> 00:04:42,000
not going to play it for you but i

00:04:41,040 --> 00:04:43,840
invite you to grab

00:04:42,000 --> 00:04:46,320
these slides from robrich.org and click

00:04:43,840 --> 00:04:47,520
play what's particularly cool is this is

00:04:46,320 --> 00:04:50,160
brendan ike

00:04:47,520 --> 00:04:51,120
playing the javascript wet talk at one

00:04:50,160 --> 00:04:54,840
of his talks

00:04:51,120 --> 00:04:56,000
and his commentary throughout it it is

00:04:54,840 --> 00:04:57,360
amazing

00:04:56,000 --> 00:04:59,360
so let's take a look at some weird

00:04:57,360 --> 00:05:01,600
things undefined well

00:04:59,360 --> 00:05:03,919
undefined is just a variable so what if

00:05:01,600 --> 00:05:07,120
we define it

00:05:03,919 --> 00:05:08,080
in more recent versions of javascript of

00:05:07,120 --> 00:05:10,080
ecmascript

00:05:08,080 --> 00:05:11,440
it is defined as a constant so we can't

00:05:10,080 --> 00:05:12,960
override it but

00:05:11,440 --> 00:05:14,560
this led to some really really

00:05:12,960 --> 00:05:17,840
interesting bugs if so

00:05:14,560 --> 00:05:21,840
for example we defined javascript

00:05:17,840 --> 00:05:24,960
type of null type of null is an object

00:05:21,840 --> 00:05:26,560
hmm should it be null should it be an

00:05:24,960 --> 00:05:29,600
object

00:05:26,560 --> 00:05:32,800
this is probably one of those bugs

00:05:29,600 --> 00:05:34,479
brenda knight created it in 10 days and

00:05:32,800 --> 00:05:35,919
a few weeks after that he said you know

00:05:34,479 --> 00:05:36,960
there's some bugs here i'd like to come

00:05:35,919 --> 00:05:38,800
back and fix

00:05:36,960 --> 00:05:40,479
and he was told hey there's 40

00:05:38,800 --> 00:05:41,680
developers already building with

00:05:40,479 --> 00:05:43,919
javascript right now

00:05:41,680 --> 00:05:46,639
we need to not change it that would be

00:05:43,919 --> 00:05:50,160
uh backwards incompatible

00:05:46,639 --> 00:05:52,560
40 developers hmm i bet there's 40

00:05:50,160 --> 00:05:54,080
developers in this room that wish we had

00:05:52,560 --> 00:05:55,680
gone back and fixed it

00:05:54,080 --> 00:05:57,520
but he made the best decision that he

00:05:55,680 --> 00:06:00,479
could at the time

00:05:57,520 --> 00:06:01,120
here's another one type of nan well not

00:06:00,479 --> 00:06:04,240
a number

00:06:01,120 --> 00:06:06,080
is well a number

00:06:04,240 --> 00:06:08,000
i get that not a number is kind of in

00:06:06,080 --> 00:06:10,080
the number group it's

00:06:08,000 --> 00:06:12,000
more in the number group than say in the

00:06:10,080 --> 00:06:13,199
date group or the object group or the

00:06:12,000 --> 00:06:15,759
function group

00:06:13,199 --> 00:06:18,639
but not a number being a number yeah

00:06:15,759 --> 00:06:18,639
that's kind of weird

00:06:19,039 --> 00:06:23,840
so these are some of the weird things in

00:06:22,000 --> 00:06:25,280
javascript and let's see if we can dig

00:06:23,840 --> 00:06:28,080
in and understand

00:06:25,280 --> 00:06:29,440
how they came to be and why they are

00:06:28,080 --> 00:06:30,880
that way

00:06:29,440 --> 00:06:33,360
now first up let's take a look at the

00:06:30,880 --> 00:06:35,199
javascript compiler now i grant that in

00:06:33,360 --> 00:06:36,639
modern javascript engines we have

00:06:35,199 --> 00:06:39,840
mechanisms for

00:06:36,639 --> 00:06:41,919
code split tree shaking and

00:06:39,840 --> 00:06:43,840
just-in-time compilation and those are

00:06:41,919 --> 00:06:46,880
amazing but at its core

00:06:43,840 --> 00:06:48,720
javascript is a two-phase compiler the

00:06:46,880 --> 00:06:50,720
first phase goes and looks for

00:06:48,720 --> 00:06:52,400
variable declarations and it kind of

00:06:50,720 --> 00:06:55,199
sets aside that memory for those

00:06:52,400 --> 00:06:56,400
variables the next phase is to run the

00:06:55,199 --> 00:06:58,639
code

00:06:56,400 --> 00:06:59,919
now because javascript has this two

00:06:58,639 --> 00:07:01,919
phase compiler

00:06:59,919 --> 00:07:03,520
then we can use that knowledge to

00:07:01,919 --> 00:07:05,520
understand some code

00:07:03,520 --> 00:07:07,199
and really dig in deep if you'd like to

00:07:05,520 --> 00:07:08,880
learn more about the two phase compiler

00:07:07,199 --> 00:07:11,360
i would invite you to click through

00:07:08,880 --> 00:07:13,919
to the slides at robrich.org and click

00:07:11,360 --> 00:07:16,639
to read more or watch more

00:07:13,919 --> 00:07:19,199
so let's take a look at this code what's

00:07:16,639 --> 00:07:19,199
it going to do

00:07:20,800 --> 00:07:24,080
let's think like the compiler and see if

00:07:22,479 --> 00:07:25,759
we can figure it out

00:07:24,080 --> 00:07:27,360
now the first phase we go look for

00:07:25,759 --> 00:07:30,160
variable declarations

00:07:27,360 --> 00:07:31,599
here's one var foo equals bar okay so

00:07:30,160 --> 00:07:33,120
we're not setting it to bar yet that

00:07:31,599 --> 00:07:37,440
would be the execution phase

00:07:33,120 --> 00:07:40,319
but we are declaring this variable varfu

00:07:37,440 --> 00:07:42,000
next phase let's go execute the code so

00:07:40,319 --> 00:07:44,879
we start out declaring this function

00:07:42,000 --> 00:07:47,039
then we'll call it so we'll start off

00:07:44,879 --> 00:07:49,440
and we'll console log foo

00:07:47,039 --> 00:07:50,720
well we already have this foo variable

00:07:49,440 --> 00:07:52,960
declared

00:07:50,720 --> 00:07:54,560
we haven't set its value yet so we get

00:07:52,960 --> 00:07:57,440
undefined

00:07:54,560 --> 00:07:58,000
if true now variables in javascript by

00:07:57,440 --> 00:08:01,280
default

00:07:58,000 --> 00:08:01,919
are function scoped not curly brace

00:08:01,280 --> 00:08:04,720
scoped

00:08:01,919 --> 00:08:05,599
so we know that this foo variable exists

00:08:04,720 --> 00:08:07,280
out here

00:08:05,599 --> 00:08:08,879
now we're going to set it to bar and

00:08:07,280 --> 00:08:09,599
then we'll leave the curly braces this

00:08:08,879 --> 00:08:12,319
variable

00:08:09,599 --> 00:08:13,360
continues on and we console log bar so

00:08:12,319 --> 00:08:17,599
we get undefined

00:08:13,360 --> 00:08:18,960
and bar so in our minds we've kind of

00:08:17,599 --> 00:08:22,639
tricked ourselves to

00:08:18,960 --> 00:08:24,560
believing that the variables get hoisted

00:08:22,639 --> 00:08:26,160
it makes sense to believe that well we

00:08:24,560 --> 00:08:27,759
just kind of moved this variable

00:08:26,160 --> 00:08:29,199
declaration up here and we set it to

00:08:27,759 --> 00:08:32,800
undefined

00:08:29,199 --> 00:08:34,240
now that variable hoisting is a cool lie

00:08:32,800 --> 00:08:36,000
that we tell ourselves but that's not

00:08:34,240 --> 00:08:39,440
actually how it works how it works is

00:08:36,000 --> 00:08:43,039
this two phase compiler

00:08:39,440 --> 00:08:45,120
yes variable hoisting it's a lie

00:08:43,039 --> 00:08:46,160
it's a convenient lie and it helps us to

00:08:45,120 --> 00:08:48,160
think about this

00:08:46,160 --> 00:08:49,760
in kind of a more synchronous way

00:08:48,160 --> 00:08:50,560
without having to separate that

00:08:49,760 --> 00:08:52,959
two-phase

00:08:50,560 --> 00:08:53,760
compiler mechanism now that's

00:08:52,959 --> 00:08:57,040
interesting

00:08:53,760 --> 00:08:58,560
but well it is a lie it's a very

00:08:57,040 --> 00:09:02,080
convenient lie and i like it

00:08:58,560 --> 00:09:04,320
but hoisting is a lie

00:09:02,080 --> 00:09:06,480
so as we think like the compiler we can

00:09:04,320 --> 00:09:10,240
see how that variable hoisting

00:09:06,480 --> 00:09:14,000
it isn't actually moved rather it's

00:09:10,240 --> 00:09:16,240
well it's a two-phase compiler

00:09:14,000 --> 00:09:18,720
so we saw this code and we saw how we

00:09:16,240 --> 00:09:21,040
could execute it in interesting ways

00:09:18,720 --> 00:09:23,839
let's take a look at defining and not

00:09:21,040 --> 00:09:26,320
defining variables in various scopes

00:09:23,839 --> 00:09:28,080
now we had a mechanism before where we

00:09:26,320 --> 00:09:30,080
declared some foo variables

00:09:28,080 --> 00:09:31,360
let's declare this foo variable and this

00:09:30,080 --> 00:09:33,600
foo variable

00:09:31,360 --> 00:09:34,800
take a minute to pause the video and

00:09:33,600 --> 00:09:37,839
think through this

00:09:34,800 --> 00:09:39,440
what will it do

00:09:37,839 --> 00:09:41,839
now let's think like the compiler and

00:09:39,440 --> 00:09:43,360
figure it out first phase we go look for

00:09:41,839 --> 00:09:46,480
variable declarations

00:09:43,360 --> 00:09:46,959
we find this one foo so let's declare

00:09:46,480 --> 00:09:49,600
that one

00:09:46,959 --> 00:09:51,839
we find this one let's declare that one

00:09:49,600 --> 00:09:52,800
now variables are declared with function

00:09:51,839 --> 00:09:54,959
scope so

00:09:52,800 --> 00:09:56,160
we have two different foo variables in

00:09:54,959 --> 00:09:58,160
different scopes

00:09:56,160 --> 00:09:59,920
an inner foo and an outer foo if you

00:09:58,160 --> 00:10:02,880
will now

00:09:59,920 --> 00:10:05,279
second phase let's run the code so let's

00:10:02,880 --> 00:10:07,519
take this outer foo and set it to bar

00:10:05,279 --> 00:10:08,800
we'll declare this function we'll call

00:10:07,519 --> 00:10:11,680
that function

00:10:08,800 --> 00:10:13,920
and now we declare this inner foo and

00:10:11,680 --> 00:10:16,640
set it to baz

00:10:13,920 --> 00:10:18,800
now if true now the curly braces don't

00:10:16,640 --> 00:10:21,440
define scope in javascript

00:10:18,800 --> 00:10:23,600
variables are scoped to functions so we

00:10:21,440 --> 00:10:24,800
go looking for this foo variable to set

00:10:23,600 --> 00:10:26,560
it to bam

00:10:24,800 --> 00:10:28,640
is there a food variable in the scope

00:10:26,560 --> 00:10:31,040
yes there is right here foo

00:10:28,640 --> 00:10:33,120
so we set it from baz to bam and we'll

00:10:31,040 --> 00:10:35,600
console log bam

00:10:33,120 --> 00:10:37,519
we leave the curly brace scope functions

00:10:35,600 --> 00:10:40,160
our functions to find the scope

00:10:37,519 --> 00:10:40,880
and so now we cancel log foo and we get

00:10:40,160 --> 00:10:43,519
this bam

00:10:40,880 --> 00:10:44,720
again we leave our function and now we

00:10:43,519 --> 00:10:47,200
need to find this

00:10:44,720 --> 00:10:48,320
outer variable is there a variable

00:10:47,200 --> 00:10:51,279
defined in this scope

00:10:48,320 --> 00:10:51,920
yes there is right here so we'll output

00:10:51,279 --> 00:10:57,360
bam

00:10:51,920 --> 00:10:57,360
bam and bar is that what you got

00:10:57,519 --> 00:11:00,880
let's change this up a little bit

00:10:59,200 --> 00:11:02,480
instead of declaring the variable here

00:11:00,880 --> 00:11:06,480
let's declare it here

00:11:02,480 --> 00:11:08,160
stop the video here how does this work

00:11:06,480 --> 00:11:10,320
let's think like the compiler and figure

00:11:08,160 --> 00:11:11,519
it out our first phase is to define all

00:11:10,320 --> 00:11:14,720
of the variables

00:11:11,519 --> 00:11:16,800
define this one to find that one and the

00:11:14,720 --> 00:11:19,680
second phase is to execute this

00:11:16,800 --> 00:11:20,560
so we'll set our outer food to bar we'll

00:11:19,680 --> 00:11:23,040
call our

00:11:20,560 --> 00:11:24,720
function set our inner food to baths

00:11:23,040 --> 00:11:26,800
wait a minute

00:11:24,720 --> 00:11:28,560
where do we get this in our food well we

00:11:26,800 --> 00:11:29,440
go looking for variables in the current

00:11:28,560 --> 00:11:32,800
scope

00:11:29,440 --> 00:11:35,760
here's one this variable is defined as

00:11:32,800 --> 00:11:37,040
a function based variable so we'll set

00:11:35,760 --> 00:11:39,120
it to baz

00:11:37,040 --> 00:11:42,079
then we'll set it to bam we'll console

00:11:39,120 --> 00:11:44,640
log bam we'll cancel log bam again

00:11:42,079 --> 00:11:46,560
and as we leave the function then we

00:11:44,640 --> 00:11:50,720
console log bar

00:11:46,560 --> 00:11:52,800
bam bam bar is that what you got

00:11:50,720 --> 00:11:54,839
let's do it again but instead we won't

00:11:52,800 --> 00:11:57,519
declare these variables at

00:11:54,839 --> 00:12:01,760
all okay first step

00:11:57,519 --> 00:12:04,560
let's go look for variables to declare

00:12:01,760 --> 00:12:05,519
here's a variable let's declare that one

00:12:04,560 --> 00:12:07,920
second phase

00:12:05,519 --> 00:12:09,519
let's go execute it okay so let's set

00:12:07,920 --> 00:12:11,519
this variable to bar

00:12:09,519 --> 00:12:13,600
let's call our function now we go

00:12:11,519 --> 00:12:14,959
looking for a food variable

00:12:13,600 --> 00:12:17,200
is there a food variable in the current

00:12:14,959 --> 00:12:19,920
scope there isn't

00:12:17,200 --> 00:12:20,720
so we walk up scopes javascript is

00:12:19,920 --> 00:12:23,120
trying to help us

00:12:20,720 --> 00:12:24,480
of course the code is running over there

00:12:23,120 --> 00:12:26,639
once the user

00:12:24,480 --> 00:12:27,839
once the developer has left so we go

00:12:26,639 --> 00:12:29,680
looking up scopes

00:12:27,839 --> 00:12:31,200
oh here's a foo variable let's use this

00:12:29,680 --> 00:12:34,639
one so where it was

00:12:31,200 --> 00:12:37,200
bar it is now baz let's do that again

00:12:34,639 --> 00:12:38,480
and where it was bazz it is now bam so

00:12:37,200 --> 00:12:41,760
we'll console log bam

00:12:38,480 --> 00:12:44,240
and bam as we leave our function we now

00:12:41,760 --> 00:12:46,160
console log the foo in the outer scope

00:12:44,240 --> 00:12:48,560
do we have a foo in this outer scope

00:12:46,160 --> 00:12:51,680
yes we have this one that we set to bam

00:12:48,560 --> 00:12:55,360
so we get bam bam bam

00:12:51,680 --> 00:12:57,839
flintstones let's do it again

00:12:55,360 --> 00:12:59,600
but in this case let's not declare it at

00:12:57,839 --> 00:13:02,240
all pause the video and figure out what

00:12:59,600 --> 00:13:02,240
happens here

00:13:03,120 --> 00:13:06,160
now let's think like the compiler and

00:13:04,720 --> 00:13:08,320
figure it out first phase

00:13:06,160 --> 00:13:09,760
let's go define all of our variables

00:13:08,320 --> 00:13:13,120
there aren't any

00:13:09,760 --> 00:13:15,040
second phase let's go execute so foo

00:13:13,120 --> 00:13:16,880
equals bar is there a food variable in

00:13:15,040 --> 00:13:19,200
the scope there isn't

00:13:16,880 --> 00:13:20,000
let's climb up the scope well in this

00:13:19,200 --> 00:13:21,680
case

00:13:20,000 --> 00:13:23,600
we'll climb all the way up to the global

00:13:21,680 --> 00:13:24,160
scope and we will define a variable

00:13:23,600 --> 00:13:26,160
there

00:13:24,160 --> 00:13:28,480
javascript is trying to help us succeed

00:13:26,160 --> 00:13:31,839
and so we define a global variable

00:13:28,480 --> 00:13:34,880
foo and set its value to bar

00:13:31,839 --> 00:13:37,040
now let's call our function do we have a

00:13:34,880 --> 00:13:39,600
food variable set in this scope

00:13:37,040 --> 00:13:41,199
we don't so let's climb up the scopes

00:13:39,600 --> 00:13:41,839
until we get to that global variable

00:13:41,199 --> 00:13:45,680
that we built

00:13:41,839 --> 00:13:47,440
here and we'll set that to baz

00:13:45,680 --> 00:13:48,880
let's go find that variable again set it

00:13:47,440 --> 00:13:52,320
to bam bam

00:13:48,880 --> 00:13:54,320
bam we leave here and we log bam again

00:13:52,320 --> 00:13:57,360
now that's interesting javascript helped

00:13:54,320 --> 00:13:59,519
us by declaring a global variable

00:13:57,360 --> 00:14:01,120
but well what if that variable was

00:13:59,519 --> 00:14:03,920
called i

00:14:01,120 --> 00:14:05,920
and what if you used it and i used it

00:14:03,920 --> 00:14:07,680
now we may overwrite each other it is

00:14:05,920 --> 00:14:09,360
after all a global variable

00:14:07,680 --> 00:14:11,519
javascript tried to help our code

00:14:09,360 --> 00:14:13,600
succeed but it may have done us a

00:14:11,519 --> 00:14:17,279
disservice by

00:14:13,600 --> 00:14:20,399
just automatically creating a variable

00:14:17,279 --> 00:14:23,680
let's do this again but now let's set

00:14:20,399 --> 00:14:23,680
foo to bam

00:14:23,760 --> 00:14:28,800
pause the video here see what happens

00:14:27,360 --> 00:14:30,880
now let's think like the compiler and

00:14:28,800 --> 00:14:33,360
figure it out first step

00:14:30,880 --> 00:14:34,720
let's define this foo variable second

00:14:33,360 --> 00:14:36,959
step let's execute

00:14:34,720 --> 00:14:37,839
we'll set foo to bar we'll call our

00:14:36,959 --> 00:14:40,000
function

00:14:37,839 --> 00:14:41,120
foo is there a foo defined in this scope

00:14:40,000 --> 00:14:43,839
there is not

00:14:41,120 --> 00:14:45,360
okay here's a foo so let's set it from

00:14:43,839 --> 00:14:48,079
bar to baz

00:14:45,360 --> 00:14:48,639
now we'll set it to bam is there a bam

00:14:48,079 --> 00:14:51,519
variable

00:14:48,639 --> 00:14:52,560
defined in here there is not how about

00:14:51,519 --> 00:14:54,800
in this scope

00:14:52,560 --> 00:14:56,240
nope let's keep climbing up the scopes

00:14:54,800 --> 00:14:59,600
until we find it well

00:14:56,240 --> 00:15:01,600
we didn't find it so how do we get its

00:14:59,600 --> 00:15:03,279
variable its value

00:15:01,600 --> 00:15:04,880
we don't have a variable to get its

00:15:03,279 --> 00:15:07,680
value out of so we get

00:15:04,880 --> 00:15:08,320
a reference error bam is not defined now

00:15:07,680 --> 00:15:10,399
we could

00:15:08,320 --> 00:15:13,360
set a new variable correctly but we

00:15:10,399 --> 00:15:15,839
could not get a new variable

00:15:13,360 --> 00:15:17,440
yeah that is kind of weird but as we

00:15:15,839 --> 00:15:19,839
think like the compiler

00:15:17,440 --> 00:15:21,279
it makes sense we can't read from a

00:15:19,839 --> 00:15:23,199
variable that doesn't exist

00:15:21,279 --> 00:15:24,480
but javascript is going to try to help

00:15:23,199 --> 00:15:26,800
our code succeed

00:15:24,480 --> 00:15:28,800
so it will go create variables and set

00:15:26,800 --> 00:15:31,040
them if they aren't defined

00:15:28,800 --> 00:15:32,240
almost being equal i'd rather it just

00:15:31,040 --> 00:15:34,800
through an exception

00:15:32,240 --> 00:15:36,480
well kind of i'd rather it through an

00:15:34,800 --> 00:15:38,959
exception while i was developing it but

00:15:36,480 --> 00:15:41,040
out there in the wild

00:15:38,959 --> 00:15:44,320
yeah i'd rather my user be able to

00:15:41,040 --> 00:15:47,920
continue on as much as they could

00:15:44,320 --> 00:15:48,880
so let's do it again now we've defined

00:15:47,920 --> 00:15:52,320
variables here

00:15:48,880 --> 00:15:55,920
with var but let's switch it up to let

00:15:52,320 --> 00:15:58,959
now let is new in es6 or es2015 and let

00:15:55,920 --> 00:16:02,000
is defined as bound to curly braces

00:15:58,959 --> 00:16:04,399
instead of bound to function scope

00:16:02,000 --> 00:16:05,920
pause pause the video here and see what

00:16:04,399 --> 00:16:07,360
happens

00:16:05,920 --> 00:16:09,120
now let's think like the compiler and

00:16:07,360 --> 00:16:10,480
figure it out first

00:16:09,120 --> 00:16:12,160
we need to go define all of our

00:16:10,480 --> 00:16:15,199
variables here's one

00:16:12,160 --> 00:16:17,360
and here's one next let's execute let's

00:16:15,199 --> 00:16:20,720
set the outer food to bar

00:16:17,360 --> 00:16:22,959
then let's call our function

00:16:20,720 --> 00:16:24,480
now we're looking for a foo variable is

00:16:22,959 --> 00:16:25,519
there a food variable defined in this

00:16:24,480 --> 00:16:28,480
scope

00:16:25,519 --> 00:16:30,240
no this let means that this variable is

00:16:28,480 --> 00:16:32,399
defined to an inner scope

00:16:30,240 --> 00:16:33,759
so we go looking for another foo

00:16:32,399 --> 00:16:35,519
variable in an outer scope

00:16:33,759 --> 00:16:38,160
oh there's one right here so we'll

00:16:35,519 --> 00:16:41,199
change it from bar to baz

00:16:38,160 --> 00:16:43,759
then inside of our if block let's create

00:16:41,199 --> 00:16:46,240
a new variable and we'll set that to bam

00:16:43,759 --> 00:16:47,519
so let's console log bam inside here

00:16:46,240 --> 00:16:49,519
then let's console.log

00:16:47,519 --> 00:16:50,560
this variable we don't have one defined

00:16:49,519 --> 00:16:52,000
in this scope

00:16:50,560 --> 00:16:54,399
but we have one defined in the outer

00:16:52,000 --> 00:16:58,240
scope so here we will output

00:16:54,399 --> 00:16:59,680
baz bam baz and then out here we're

00:16:58,240 --> 00:17:01,120
looking for this variable and we'll

00:16:59,680 --> 00:17:05,760
output baz again

00:17:01,120 --> 00:17:10,319
bam baz baz great

00:17:05,760 --> 00:17:10,319
now let's not define the variable

00:17:11,039 --> 00:17:14,959
okay let's think like the compiler and

00:17:13,760 --> 00:17:17,199
see if we can figure it out

00:17:14,959 --> 00:17:19,039
first we declare our all our variables

00:17:17,199 --> 00:17:21,919
there's just one right here

00:17:19,039 --> 00:17:22,480
second we'll execute we'll call our

00:17:21,919 --> 00:17:24,079
function

00:17:22,480 --> 00:17:25,919
we'll go looking for a variable there

00:17:24,079 --> 00:17:28,000
isn't one in this scope there isn't one

00:17:25,919 --> 00:17:29,919
in the outer scope so we define a new

00:17:28,000 --> 00:17:32,799
global variable called foo

00:17:29,919 --> 00:17:33,840
and set its value to baz inside this if

00:17:32,799 --> 00:17:35,919
block we have this

00:17:33,840 --> 00:17:38,000
curly brace scoped variable so we output

00:17:35,919 --> 00:17:40,480
bam and then baz

00:17:38,000 --> 00:17:42,000
and then out here we go looking for a

00:17:40,480 --> 00:17:44,160
variable in the current scope

00:17:42,000 --> 00:17:45,679
we don't find it we climb up the tree

00:17:44,160 --> 00:17:47,280
until we get to that same global

00:17:45,679 --> 00:17:50,480
variable defined here

00:17:47,280 --> 00:17:52,400
and we output paths wait a minute

00:17:50,480 --> 00:17:53,760
did this variable leak outside the

00:17:52,400 --> 00:17:56,559
function

00:17:53,760 --> 00:17:58,080
well yeah because we didn't define it

00:17:56,559 --> 00:18:00,799
scoped to anything

00:17:58,080 --> 00:18:01,760
it was created as a global variable

00:18:00,799 --> 00:18:04,799
that's weird

00:18:01,760 --> 00:18:05,520
but well javascript helped us and when

00:18:04,799 --> 00:18:07,440
it helped us

00:18:05,520 --> 00:18:08,960
it created a mechanism where our code

00:18:07,440 --> 00:18:10,320
would continue to run

00:18:08,960 --> 00:18:12,400
even if it's in a little bit of an

00:18:10,320 --> 00:18:14,000
unexpected way

00:18:12,400 --> 00:18:16,000
let's do it again but let's define these

00:18:14,000 --> 00:18:18,320
two variables here

00:18:16,000 --> 00:18:19,840
what happens in this case let's think

00:18:18,320 --> 00:18:22,240
like the compiler

00:18:19,840 --> 00:18:24,080
well everything works well inside this

00:18:22,240 --> 00:18:26,480
function once we get out here

00:18:24,080 --> 00:18:28,000
we're going to get to this foo variable

00:18:26,480 --> 00:18:30,720
and we're going to go look for a global

00:18:28,000 --> 00:18:31,840
foo variable well there's no variable

00:18:30,720 --> 00:18:33,760
defined in this scope

00:18:31,840 --> 00:18:35,520
let's keep looking for a global variable

00:18:33,760 --> 00:18:36,640
nothing was defined here because all

00:18:35,520 --> 00:18:39,840
these variables were

00:18:36,640 --> 00:18:42,799
defined so we get a

00:18:39,840 --> 00:18:44,240
reference area foo is not defined foo is

00:18:42,799 --> 00:18:47,200
not defined because

00:18:44,240 --> 00:18:49,600
well because i defined these variables

00:18:47,200 --> 00:18:51,840
inside this containing function

00:18:49,600 --> 00:18:54,000
then they expired once we left that

00:18:51,840 --> 00:18:56,720
scope

00:18:54,000 --> 00:18:57,200
let's do it again but let's switch from

00:18:56,720 --> 00:19:00,880
let

00:18:57,200 --> 00:19:03,440
to const now const in es6

00:19:00,880 --> 00:19:05,600
is a variable that can't change now the

00:19:03,440 --> 00:19:09,120
contents of that object can change

00:19:05,600 --> 00:19:09,120
but the variable itself cannot

00:19:09,520 --> 00:19:16,240
so let's dig in and take a look

00:19:13,200 --> 00:19:19,360
well we define our variable

00:19:16,240 --> 00:19:20,799
we call into our function and now we're

00:19:19,360 --> 00:19:23,280
looking for a variable

00:19:20,799 --> 00:19:25,200
called foo in the current scope this one

00:19:23,280 --> 00:19:26,799
is an inner scope so we can't grab that

00:19:25,200 --> 00:19:27,520
one so we go looking for this outer

00:19:26,799 --> 00:19:30,000
scope

00:19:27,520 --> 00:19:31,600
and we go try to set it ooh we can't set

00:19:30,000 --> 00:19:33,120
a constant so we get assignment to a

00:19:31,600 --> 00:19:35,280
constant variable

00:19:33,120 --> 00:19:37,280
now if we're using babel to transpile

00:19:35,280 --> 00:19:40,000
from es6 to es5

00:19:37,280 --> 00:19:42,000
where const doesn't exist then it

00:19:40,000 --> 00:19:45,120
changes this const to a let

00:19:42,000 --> 00:19:47,679
or no it changes a const to a var and

00:19:45,120 --> 00:19:49,440
yes we can assign a var so we'll get

00:19:47,679 --> 00:19:52,240
different behavior

00:19:49,440 --> 00:19:52,960
every evergreen browser supports es6 or

00:19:52,240 --> 00:19:55,600
better now

00:19:52,960 --> 00:19:56,080
so probably we want to turn down babel

00:19:55,600 --> 00:19:58,320
to

00:19:56,080 --> 00:20:00,799
output es6 or better and ensure that

00:19:58,320 --> 00:20:02,080
that const is indeed const

00:20:00,799 --> 00:20:05,440
but that's why you might get different

00:20:02,080 --> 00:20:08,799
behavior inside of

00:20:05,440 --> 00:20:10,559
babel so we took a look at defining

00:20:08,799 --> 00:20:13,679
variables let's take a look at

00:20:10,559 --> 00:20:15,679
this what is this

00:20:13,679 --> 00:20:17,280
well it's the thing to the left of the

00:20:15,679 --> 00:20:19,440
dot

00:20:17,280 --> 00:20:21,200
let's take a look at some examples and

00:20:19,440 --> 00:20:22,080
we have this speak function where we

00:20:21,200 --> 00:20:25,360
console.log

00:20:22,080 --> 00:20:28,320
this dot name now we're defining name

00:20:25,360 --> 00:20:29,120
out here in a global way well global to

00:20:28,320 --> 00:20:31,280
this space

00:20:29,120 --> 00:20:32,840
so if we call speak what is the thing to

00:20:31,280 --> 00:20:36,960
the left of the dot

00:20:32,840 --> 00:20:39,200
well global so we get ninja

00:20:36,960 --> 00:20:40,720
now let's call obj1.speak we could

00:20:39,200 --> 00:20:41,200
definitely have created the speak

00:20:40,720 --> 00:20:44,559
function

00:20:41,200 --> 00:20:46,520
in the middle here but i just copied it

00:20:44,559 --> 00:20:47,679
into place for each of the objects so

00:20:46,520 --> 00:20:49,280
obj1.speak

00:20:47,679 --> 00:20:52,080
what is the thing to the left of the dot

00:20:49,280 --> 00:20:56,320
well it's obj1 so we get doctor

00:20:52,080 --> 00:20:59,919
obj2.speak we get skywalker perfect

00:20:56,320 --> 00:21:04,000
ninja dr skywalker let's do it again

00:20:59,919 --> 00:21:06,799
but let's grab it out as a function

00:21:04,000 --> 00:21:08,960
now in this case it's no longer the

00:21:06,799 --> 00:21:10,559
thing to the left of the dot

00:21:08,960 --> 00:21:12,400
or rather the thing to the left of the

00:21:10,559 --> 00:21:15,440
dot is global

00:21:12,400 --> 00:21:16,720
so obj1.speak will work correctly we'll

00:21:15,440 --> 00:21:18,960
get doctor

00:21:16,720 --> 00:21:20,480
dot speak we'll get undefined we didn't

00:21:18,960 --> 00:21:22,799
define a global

00:21:20,480 --> 00:21:22,799
name

00:21:23,600 --> 00:21:26,960
so let's create a new mechanism where we

00:21:25,440 --> 00:21:29,919
can go grab a button

00:21:26,960 --> 00:21:31,120
now we grab it by id and then we click

00:21:29,919 --> 00:21:33,520
the button

00:21:31,120 --> 00:21:35,200
to call the speak function now what's

00:21:33,520 --> 00:21:37,679
the thing to the left of the dot

00:21:35,200 --> 00:21:38,720
well it's the button so when i say this

00:21:37,679 --> 00:21:40,880
dot id

00:21:38,720 --> 00:21:42,159
knowing that i have a get element by id

00:21:40,880 --> 00:21:45,919
i'm going to output

00:21:42,159 --> 00:21:48,000
the button perfect

00:21:45,919 --> 00:21:49,760
now what if we want to change the speak

00:21:48,000 --> 00:21:53,200
function to output the name

00:21:49,760 --> 00:21:54,240
in 100 milliseconds instead okay so

00:21:53,200 --> 00:21:58,000
let's do it

00:21:54,240 --> 00:22:00,559
now when we call obj1.speak

00:21:58,000 --> 00:22:01,919
set timeout is going to create a whole

00:22:00,559 --> 00:22:04,960
new stack

00:22:01,919 --> 00:22:06,480
so what is this in this new stack well

00:22:04,960 --> 00:22:09,520
it's the global function so we're going

00:22:06,480 --> 00:22:09,520
to get ninja twice

00:22:09,919 --> 00:22:13,039
let's see if we can fix that we can

00:22:12,400 --> 00:22:17,120
alter

00:22:13,039 --> 00:22:20,559
what this means by calling dot call

00:22:17,120 --> 00:22:21,520
now we'll say dot call and we'll pass in

00:22:20,559 --> 00:22:24,640
what we want

00:22:21,520 --> 00:22:25,760
this to be so taking a look at this code

00:22:24,640 --> 00:22:27,919
obj1.speak

00:22:25,760 --> 00:22:30,000
obviously works as expected but we don't

00:22:27,919 --> 00:22:33,039
have a speak function in object2

00:22:30,000 --> 00:22:33,760
so we'll say obj1.speak.call and set

00:22:33,039 --> 00:22:38,000
this to be

00:22:33,760 --> 00:22:39,200
obj2 now this is set to be obj2 we've

00:22:38,000 --> 00:22:42,240
overridden it

00:22:39,200 --> 00:22:45,280
and so we'll get dr n skywalker

00:22:42,240 --> 00:22:48,159
great well let's do that same mechanism

00:22:45,280 --> 00:22:48,640
we'll say dot call this to try and fix

00:22:48,159 --> 00:22:52,080
our

00:22:48,640 --> 00:22:54,720
problem here with our set timeout

00:22:52,080 --> 00:22:56,880
now it's going to say dot call but this

00:22:54,720 --> 00:22:59,039
executes it right away

00:22:56,880 --> 00:23:00,880
so we will get the right answer ninja

00:22:59,039 --> 00:23:04,480
and doctor but we didn't wait

00:23:00,880 --> 00:23:07,360
the necessary 100 milliseconds

00:23:04,480 --> 00:23:08,080
let's look at bind now bind is a great

00:23:07,360 --> 00:23:10,880
way to create

00:23:08,080 --> 00:23:12,320
a closure a new function that has this

00:23:10,880 --> 00:23:14,320
set the way we expect

00:23:12,320 --> 00:23:16,000
we can kind of think of it like this

00:23:14,320 --> 00:23:17,039
this isn't the correct syntax but we can

00:23:16,000 --> 00:23:18,720
think of it this way

00:23:17,039 --> 00:23:20,799
let's pass in a function and what we

00:23:18,720 --> 00:23:21,440
want this to be we'll return a new

00:23:20,799 --> 00:23:24,559
function

00:23:21,440 --> 00:23:27,360
we'll say function.call with that

00:23:24,559 --> 00:23:28,960
set now we have this new function that

00:23:27,360 --> 00:23:30,640
we can call whenever we're ready

00:23:28,960 --> 00:23:32,559
and that will actually do the function

00:23:30,640 --> 00:23:34,840
calling

00:23:32,559 --> 00:23:37,360
so let's look at the real syntax

00:23:34,840 --> 00:23:40,559
obj1.speak.bind obj2

00:23:37,360 --> 00:23:42,400
okay so because we're saying bind we get

00:23:40,559 --> 00:23:45,279
this new obj2speak

00:23:42,400 --> 00:23:45,600
function and we can call it later and

00:23:45,279 --> 00:23:48,480
this

00:23:45,600 --> 00:23:52,159
is already bound to obj2 so we get

00:23:48,480 --> 00:23:52,159
doctor and skywalker perfect

00:23:53,760 --> 00:23:57,440
now we'll probably see in our code

00:23:55,720 --> 00:24:00,480
object2.speak.bind obj2

00:23:57,440 --> 00:24:02,840
a lot what it's trying to do is saying

00:24:00,480 --> 00:24:04,159
i want to set this i don't want any

00:24:02,840 --> 00:24:06,000
ambiguity

00:24:04,159 --> 00:24:09,760
that's perfect if you find that in your

00:24:06,000 --> 00:24:11,840
code that's exactly what it's doing

00:24:09,760 --> 00:24:13,520
now let's come back to our set timeout

00:24:11,840 --> 00:24:15,919
function and let's call dot bind

00:24:13,520 --> 00:24:18,000
this now that bind this will return a

00:24:15,919 --> 00:24:20,559
new function that we can call later say

00:24:18,000 --> 00:24:22,000
in 100 milliseconds so now that we

00:24:20,559 --> 00:24:25,919
called dot bind

00:24:22,000 --> 00:24:26,960
well we've got ninja and doctor it works

00:24:25,919 --> 00:24:30,000
correctly

00:24:26,960 --> 00:24:33,120
very nice now

00:24:30,000 --> 00:24:33,600
let's change to an arrow function now

00:24:33,120 --> 00:24:36,720
what an

00:24:33,600 --> 00:24:37,919
arrow function does is it binds the

00:24:36,720 --> 00:24:40,080
variables

00:24:37,919 --> 00:24:41,919
at the point where the function is

00:24:40,080 --> 00:24:44,000
defined we can think of it kind of like

00:24:41,919 --> 00:24:47,039
this

00:24:44,000 --> 00:24:48,400
so let's define this function bind it

00:24:47,039 --> 00:24:50,559
the way we expect

00:24:48,400 --> 00:24:52,159
and let's see how this goes so we've got

00:24:50,559 --> 00:24:52,559
the speak function and we'll turn it

00:24:52,159 --> 00:24:56,320
into an

00:24:52,559 --> 00:24:58,159
arrow function now because it binds at

00:24:56,320 --> 00:25:01,760
the point where it's created

00:24:58,159 --> 00:25:04,480
then well this is bound

00:25:01,760 --> 00:25:05,440
to the global scope at the point where

00:25:04,480 --> 00:25:08,559
it's created

00:25:05,440 --> 00:25:11,279
we get ninja ninja ninja oops

00:25:08,559 --> 00:25:13,919
that isn't what we expected okay so

00:25:11,279 --> 00:25:16,720
let's say obj2.speak.bindobj2 we have

00:25:13,919 --> 00:25:20,799
this trick that allows us to bind this

00:25:16,720 --> 00:25:21,360
well kind of this is already bound into

00:25:20,799 --> 00:25:23,279
place

00:25:21,360 --> 00:25:24,799
so wrapping it in another function that

00:25:23,279 --> 00:25:26,400
binds it to something else

00:25:24,799 --> 00:25:28,159
then when it calls this inner function

00:25:26,400 --> 00:25:32,559
it's already bound so

00:25:28,159 --> 00:25:36,559
we can't re-bind it so yeah

00:25:32,559 --> 00:25:39,039
nope that didn't work okay so here in

00:25:36,559 --> 00:25:40,880
our function let's use an arrow function

00:25:39,039 --> 00:25:42,320
here we know that it binds at the point

00:25:40,880 --> 00:25:45,600
where it's created

00:25:42,320 --> 00:25:48,000
so let's use that to grab this

00:25:45,600 --> 00:25:49,440
and now yes ninja doctor it works as

00:25:48,000 --> 00:25:52,559
expected

00:25:49,440 --> 00:25:54,000
perfect now what if we changed speak to

00:25:52,559 --> 00:25:56,400
be an arrow function

00:25:54,000 --> 00:25:57,440
well then it wouldn't behave as expected

00:25:56,400 --> 00:26:00,000
now it would

00:25:57,440 --> 00:26:01,360
bind to the global this but because we

00:26:00,000 --> 00:26:03,440
have this outer one as

00:26:01,360 --> 00:26:06,720
function and this inner one is an arrow

00:26:03,440 --> 00:26:08,320
function it behaves as expected

00:26:06,720 --> 00:26:10,240
now that's a little weird knowing that

00:26:08,320 --> 00:26:11,360
arrow functions bind at the point where

00:26:10,240 --> 00:26:13,679
they're created

00:26:11,360 --> 00:26:14,799
will help us to understand a little bit

00:26:13,679 --> 00:26:17,520
about how it works

00:26:14,799 --> 00:26:19,520
we shouldn't just change every function

00:26:17,520 --> 00:26:23,760
to be an arrow function

00:26:19,520 --> 00:26:26,640
that would be well to bind this too much

00:26:23,760 --> 00:26:28,000
and we've seen that we can't override it

00:26:26,640 --> 00:26:29,520
now let's briefly take a look at the

00:26:28,000 --> 00:26:32,159
event loop

00:26:29,520 --> 00:26:34,159
i love this website where we get to look

00:26:32,159 --> 00:26:36,240
at how the event loop works

00:26:34,159 --> 00:26:37,679
let's open this in a new tab and flip

00:26:36,240 --> 00:26:40,080
over to that tab

00:26:37,679 --> 00:26:42,000
and we can take a look at this this

00:26:40,080 --> 00:26:44,960
video is awesome

00:26:42,000 --> 00:26:46,640
now we have some code here and we have

00:26:44,960 --> 00:26:47,200
the call stack what it's running right

00:26:46,640 --> 00:26:50,080
now

00:26:47,200 --> 00:26:50,880
a callback queue and web apis for

00:26:50,080 --> 00:26:52,559
example

00:26:50,880 --> 00:26:54,000
i'm waiting for a database or a rest

00:26:52,559 --> 00:26:56,400
call to complete

00:26:54,000 --> 00:26:58,080
so let's copy this code and we'll go set

00:26:56,400 --> 00:26:59,520
it in place and take a look at how it

00:26:58,080 --> 00:27:02,320
works

00:26:59,520 --> 00:27:03,200
save and run now we start out with that

00:27:02,320 --> 00:27:05,919
set timeout

00:27:03,200 --> 00:27:06,640
okay now it's counting for i equals one

00:27:05,919 --> 00:27:09,679
to three

00:27:06,640 --> 00:27:10,240
and it's counting and it's setting new

00:27:09,679 --> 00:27:13,440
content

00:27:10,240 --> 00:27:14,240
up here to finish once that finishes it

00:27:13,440 --> 00:27:16,240
comes back

00:27:14,240 --> 00:27:17,279
down here into the callback queue that

00:27:16,240 --> 00:27:19,200
as the

00:27:17,279 --> 00:27:20,720
call stack empties it goes and grabs the

00:27:19,200 --> 00:27:23,919
next thing from the callback queue

00:27:20,720 --> 00:27:24,720
and sets it in place now this highlights

00:27:23,919 --> 00:27:27,760
that great

00:27:24,720 --> 00:27:30,000
scenario where what is it outputting

00:27:27,760 --> 00:27:32,080
well it's outputting the current i what

00:27:30,000 --> 00:27:36,159
is the i by the time it gets here

00:27:32,080 --> 00:27:38,559
well it's um three

00:27:36,159 --> 00:27:39,840
so we're gonna console log three three

00:27:38,559 --> 00:27:41,840
times

00:27:39,840 --> 00:27:43,039
but we get a sense for the call stack

00:27:41,840 --> 00:27:46,080
the callback queue

00:27:43,039 --> 00:27:47,840
web apis it is a perfect mechanism for

00:27:46,080 --> 00:27:49,919
being able to visualize those three

00:27:47,840 --> 00:27:51,200
pieces

00:27:49,919 --> 00:27:55,200
i would invite you to play with that

00:27:51,200 --> 00:27:55,200
site because it is really really fun

00:27:55,840 --> 00:27:59,679
so we've got that stack where as the

00:27:59,039 --> 00:28:01,440
content

00:27:59,679 --> 00:28:02,799
is run it's going to run through all of

00:28:01,440 --> 00:28:04,159
the pieces in the stack

00:28:02,799 --> 00:28:05,919
it's not going to look at anything in

00:28:04,159 --> 00:28:06,640
the callback queue until the stack is

00:28:05,919 --> 00:28:08,320
empty

00:28:06,640 --> 00:28:09,840
once the stack is empty it will grab the

00:28:08,320 --> 00:28:10,960
next piece from the callback queue and

00:28:09,840 --> 00:28:14,000
set it on the stack

00:28:10,960 --> 00:28:16,880
and process it read more or watch more

00:28:14,000 --> 00:28:19,200
about this and learn some more about it

00:28:16,880 --> 00:28:20,640
now as we look at node we can think of

00:28:19,200 --> 00:28:22,559
it like this

00:28:20,640 --> 00:28:24,320
now this isn't the physical layout but

00:28:22,559 --> 00:28:26,399
this is a good logical layout each

00:28:24,320 --> 00:28:29,440
request has its own

00:28:26,399 --> 00:28:30,000
stack and callback queue and the things

00:28:29,440 --> 00:28:33,440
that it's waiting

00:28:30,000 --> 00:28:35,520
for now as as node goes through it looks

00:28:33,440 --> 00:28:36,720
at each request and gets it a little bit

00:28:35,520 --> 00:28:38,399
farther

00:28:36,720 --> 00:28:39,919
well what if this request is going to

00:28:38,399 --> 00:28:42,559
count from one to a billion

00:28:39,919 --> 00:28:44,000
well then the the callback queue can't

00:28:42,559 --> 00:28:45,919
get further

00:28:44,000 --> 00:28:48,640
so we'll not we'll want to do a lot of

00:28:45,919 --> 00:28:50,799
things to get to yield the thread

00:28:48,640 --> 00:28:52,080
as much as possible so that the other

00:28:50,799 --> 00:28:54,159
tasks have a

00:28:52,080 --> 00:28:55,440
a chance to get caught up and then we'll

00:28:54,159 --> 00:28:59,039
come back and

00:28:55,440 --> 00:29:01,039
and compute a few more

00:28:59,039 --> 00:29:02,159
so we might see something like this set

00:29:01,039 --> 00:29:06,240
timeout zero

00:29:02,159 --> 00:29:07,760
why would i wait zero seconds well

00:29:06,240 --> 00:29:09,440
because we're trying to yield the

00:29:07,760 --> 00:29:10,559
threads so that the rest of the quests

00:29:09,440 --> 00:29:13,360
can get caught up

00:29:10,559 --> 00:29:15,200
we might also do this process.next tick

00:29:13,360 --> 00:29:16,559
and in more modern versions of node we

00:29:15,200 --> 00:29:18,559
don't even need the empty

00:29:16,559 --> 00:29:19,919
function here we can just say await

00:29:18,559 --> 00:29:22,080
process dot next tick

00:29:19,919 --> 00:29:23,039
and now we've yielded the thread for a

00:29:22,080 --> 00:29:25,760
second and

00:29:23,039 --> 00:29:26,399
let everybody else catch up that is

00:29:25,760 --> 00:29:28,080
perfect

00:29:26,399 --> 00:29:29,840
now if there's no other requests that

00:29:28,080 --> 00:29:30,080
need any attention it will come back to

00:29:29,840 --> 00:29:33,760
us

00:29:30,080 --> 00:29:33,760
nearly immediately and continue on

00:29:34,080 --> 00:29:38,000
async can await now we only have a

00:29:36,080 --> 00:29:41,039
minute so let's cruise through this

00:29:38,000 --> 00:29:43,600
really fast async and weight was clearly

00:29:41,039 --> 00:29:44,640
borrowed from c-sharp it builds a

00:29:43,600 --> 00:29:47,679
similar state

00:29:44,640 --> 00:29:47,679
machine as

00:29:48,799 --> 00:29:52,840
as the task parallel library in c-sharp

00:29:50,960 --> 00:29:57,039
but it does it with promises

00:29:52,840 --> 00:30:00,000
and generators

00:29:57,039 --> 00:30:01,760
so well what if we have this promise

00:30:00,000 --> 00:30:03,600
based library here and we want to

00:30:01,760 --> 00:30:04,559
upgrade some of the things to async and

00:30:03,600 --> 00:30:07,360
await

00:30:04,559 --> 00:30:08,720
how do we do that well the cool part is

00:30:07,360 --> 00:30:10,559
that async and await

00:30:08,720 --> 00:30:13,039
has this mechanism where we can just

00:30:10,559 --> 00:30:17,279
await things and start to feel

00:30:13,039 --> 00:30:20,159
as if it was synchronous that's amazing

00:30:17,279 --> 00:30:21,679
now because it feels synchronous we can

00:30:20,159 --> 00:30:23,760
start to think about it

00:30:21,679 --> 00:30:25,760
with you know standard fallback

00:30:23,760 --> 00:30:27,840
mechanisms but we know it'll stop here

00:30:25,760 --> 00:30:29,039
until this is done and it'll stop here

00:30:27,840 --> 00:30:31,120
until this is done

00:30:29,039 --> 00:30:33,440
and it's not blocking the thread it's

00:30:31,120 --> 00:30:35,120
yielding the thread for other things

00:30:33,440 --> 00:30:36,720
and then when it comes back then it'll

00:30:35,120 --> 00:30:39,120
be able to continue on

00:30:36,720 --> 00:30:40,640
we can think a lot more synchronously in

00:30:39,120 --> 00:30:44,240
spite of the fact that it's actually

00:30:40,640 --> 00:30:47,120
executing asynchronously that's amazing

00:30:44,240 --> 00:30:48,960
now do we have to wait until we do a big

00:30:47,120 --> 00:30:52,080
bang refactor to get everything

00:30:48,960 --> 00:30:53,279
nope async and await works as promises

00:30:52,080 --> 00:30:56,159
under the hood

00:30:53,279 --> 00:30:56,960
so we have this async function and let's

00:30:56,159 --> 00:31:00,000
call it but

00:30:56,960 --> 00:31:02,080
not await it what is res

00:31:00,000 --> 00:31:03,679
well res is a promise that we can just

00:31:02,080 --> 00:31:05,919
dot then with

00:31:03,679 --> 00:31:07,600
now we could choose to await it so that

00:31:05,919 --> 00:31:09,440
we would resolve the promise

00:31:07,600 --> 00:31:11,120
but knowing that it is a promise under

00:31:09,440 --> 00:31:15,039
the hood we could

00:31:11,120 --> 00:31:15,519
dot then so let's imagine that i have

00:31:15,039 --> 00:31:17,600
this

00:31:15,519 --> 00:31:20,000
legacy function that i need to call from

00:31:17,600 --> 00:31:22,320
this new async code that i'm writing

00:31:20,000 --> 00:31:23,200
do i have to use promises and a dot then

00:31:22,320 --> 00:31:26,799
athon

00:31:23,200 --> 00:31:30,240
no i can just well await

00:31:26,799 --> 00:31:30,960
that function i know how to await

00:31:30,240 --> 00:31:34,240
promises

00:31:30,960 --> 00:31:36,559
and it works just fine simultaneously

00:31:34,240 --> 00:31:37,679
if we go the other way then we can take

00:31:36,559 --> 00:31:41,519
a look at this

00:31:37,679 --> 00:31:43,679
async function and call it using

00:31:41,519 --> 00:31:46,720
promises now in this case we would like

00:31:43,679 --> 00:31:48,799
to do a lot of things in parallel

00:31:46,720 --> 00:31:51,200
now we want to call lib1 column two

00:31:48,799 --> 00:31:54,399
notice how we're not awaiting them

00:31:51,200 --> 00:31:56,000
so we have three promises well how do we

00:31:54,399 --> 00:31:58,480
await a bunch of promises

00:31:56,000 --> 00:31:59,120
we have this promise.all and we can

00:31:58,480 --> 00:32:01,519
await

00:31:59,120 --> 00:32:03,519
that and then we have all our results

00:32:01,519 --> 00:32:05,840
all these things happen simultaneously

00:32:03,519 --> 00:32:06,559
well kind of javascript is still single

00:32:05,840 --> 00:32:08,720
threaded

00:32:06,559 --> 00:32:12,000
but i didn't have to wait for one to

00:32:08,720 --> 00:32:14,559
finish before i started too

00:32:12,000 --> 00:32:17,440
that's perfect javascript it's an

00:32:14,559 --> 00:32:20,480
amazing experience for a 10-day project

00:32:17,440 --> 00:32:22,399
25 years ago i think brendan ike did an

00:32:20,480 --> 00:32:24,880
amazing job

00:32:22,399 --> 00:32:26,960
the code i wrote 25 years ago is not

00:32:24,880 --> 00:32:28,720
nearly as good as the code he wrote 25

00:32:26,960 --> 00:32:30,399
years ago

00:32:28,720 --> 00:32:32,559
find me in that place that the

00:32:30,399 --> 00:32:34,399
conference has designated for q a

00:32:32,559 --> 00:32:36,320
or if you're watching this later hit me

00:32:34,399 --> 00:32:38,399
up on twitter at rob underscore ridge

00:32:36,320 --> 00:32:39,840
you can grab the slides right now from

00:32:38,399 --> 00:32:43,840
robrich.org

00:32:39,840 --> 00:32:43,840

YouTube URL: https://www.youtube.com/watch?v=LflK0oLPnFw


