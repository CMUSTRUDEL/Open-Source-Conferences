Title: Security, modules and Node js
Publication date: 2019-06-04
Playlist: OpenJS Foundation Collaborator Summit, Berlin, May 2019
Description: 
	OpenJS Foundation Collaborator Summit, Berlin, 2019

More details: https://github.com/nodejs/summit/issues/155
Captions: 
	00:00:01,669 --> 00:00:11,639
right so the sessions on security

00:00:04,980 --> 00:00:14,549
modules no Jess and I want to just give

00:00:11,639 --> 00:00:16,710
a brief introduction to the topic can

00:00:14,549 --> 00:00:21,830
you won't get me okay it's all right so

00:00:16,710 --> 00:00:24,180
back good brief introduction and then

00:00:21,830 --> 00:00:26,910
hopefully a discussion if people are

00:00:24,180 --> 00:00:27,689
interested have thoughts if we've got a

00:00:26,910 --> 00:00:35,899
need security

00:00:27,689 --> 00:00:40,730
experiment please poke holes in yeah

00:00:35,899 --> 00:00:48,780
what this is you know me my name is

00:00:40,730 --> 00:00:50,899
guided modules marketing group set up

00:00:48,780 --> 00:00:56,969
the zoom chat so we can actually get

00:00:50,899 --> 00:01:05,420
this sorry do you know what the meeting

00:00:56,969 --> 00:01:12,900
is yep take one take one double six

00:01:05,420 --> 00:01:15,720
eight six four two basic sports do not

00:01:12,900 --> 00:01:25,049
connect on you because audio is coming

00:01:15,720 --> 00:01:32,189
from here table yeah great okay so we

00:01:25,049 --> 00:01:42,140
should be live all right can you share

00:01:32,189 --> 00:01:42,140
your screen to the in the center just

00:01:50,390 --> 00:01:56,729
joining us I was just saying that

00:01:54,240 --> 00:01:59,369
working on the integration of yes

00:01:56,729 --> 00:02:02,369
modules in there Jess has but if you

00:01:59,369 --> 00:02:04,740
touch points with the security of Nijs

00:02:02,369 --> 00:02:06,750
so as we shift E is modules and all the

00:02:04,740 --> 00:02:09,660
decisions were making around yes watch

00:02:06,750 --> 00:02:13,530
our fencing the security of their Jets

00:02:09,660 --> 00:02:15,960
and future and the other thing is that

00:02:13,530 --> 00:02:18,870
whether simply has its own security

00:02:15,960 --> 00:02:22,710
models which as we integrate webassembly

00:02:18,870 --> 00:02:24,210
internode also effect no yes so no des

00:02:22,710 --> 00:02:27,660
is sort of surrounded by a lot of

00:02:24,210 --> 00:02:29,940
interesting things going on and in

00:02:27,660 --> 00:02:32,520
particular security is a huge area there

00:02:29,940 --> 00:02:34,290
is so much that can be discussed the

00:02:32,520 --> 00:02:36,360
problem that I'm focusing on here is

00:02:34,290 --> 00:02:38,730
very specifically the problem with

00:02:36,360 --> 00:02:41,720
running untrusted code from learning

00:02:38,730 --> 00:02:44,190
modules and I'm thinking about that and

00:02:41,720 --> 00:02:46,650
if there are things that we can do about

00:02:44,190 --> 00:02:48,500
that and this is all very very much

00:02:46,650 --> 00:02:51,540
long-term thinking so I'm not suggesting

00:02:48,500 --> 00:02:53,910
changing though today which I'm

00:02:51,540 --> 00:02:56,040
suggesting just thinking about the

00:02:53,910 --> 00:02:57,959
longer term with the project and the

00:02:56,040 --> 00:03:00,480
longer term security positioning of the

00:02:57,959 --> 00:03:02,430
project and if there's small tweaks we

00:03:00,480 --> 00:03:05,940
can do today and think about today

00:03:02,430 --> 00:03:09,630
sister time for the future in particular

00:03:05,940 --> 00:03:11,730
I have a PR up and this is actually what

00:03:09,630 --> 00:03:16,410
started the motivation for the session

00:03:11,730 --> 00:03:19,110
was for requests who removed global dog

00:03:16,410 --> 00:03:22,760
process which is currently available in

00:03:19,110 --> 00:03:27,180
all modules but just for es modules and

00:03:22,760 --> 00:03:35,640
currently the tear is the block but not

00:03:27,180 --> 00:03:38,390
this entire section is together the

00:03:35,640 --> 00:03:41,970
inspiration here is almost entirely from

00:03:38,390 --> 00:03:45,200
the SES project secure atmosphere

00:03:41,970 --> 00:03:48,570
project and this is the problem with

00:03:45,200 --> 00:03:50,940
making tackling running secured third

00:03:48,570 --> 00:03:53,430
party Java scripts without security

00:03:50,940 --> 00:03:56,459
risks so that everything I'm talking

00:03:53,430 --> 00:03:59,100
about you can basically get exactly the

00:03:56,459 --> 00:04:02,519
same things from this mark Milley game

00:03:59,100 --> 00:04:05,400
since he said tc39 called extremely

00:04:02,519 --> 00:04:07,200
module adjuster recent Java scripts and

00:04:05,400 --> 00:04:09,660
I would strongly recommend taking down

00:04:07,200 --> 00:04:11,760
that youtube link and watching it

00:04:09,660 --> 00:04:15,989
because it's a very interesting talk

00:04:11,760 --> 00:04:17,970
about this topic and one of the key

00:04:15,989 --> 00:04:21,570
insights there is that javascript is

00:04:17,970 --> 00:04:23,220
very very close to having some very very

00:04:21,570 --> 00:04:25,349
strong security proxies

00:04:23,220 --> 00:04:26,669
it has no security prophecies right now

00:04:25,349 --> 00:04:29,129
but it

00:04:26,669 --> 00:04:35,460
close to having some incredibly strong

00:04:29,129 --> 00:04:37,889
security properties and so there's some

00:04:35,460 --> 00:04:39,449
ways committing none in those

00:04:37,889 --> 00:04:42,740
directions and the other thing about

00:04:39,449 --> 00:04:46,069
this is modern innovations that is being

00:04:42,740 --> 00:04:48,599
surprising in comparison to other

00:04:46,069 --> 00:04:51,599
languages that you'd consider maybe

00:04:48,599 --> 00:04:54,180
technically superior so this is the

00:04:51,599 --> 00:04:57,029
example of what we're looking at the

00:04:54,180 --> 00:04:59,729
type of attacks that are possible this

00:04:57,029 --> 00:05:04,439
was earlier in the year we've got a deep

00:04:59,729 --> 00:05:06,629
dependency of a dependency of a widely

00:05:04,439 --> 00:05:09,629
installed package that maybe isn't

00:05:06,629 --> 00:05:11,279
maintained that well someone ends up

00:05:09,629 --> 00:05:13,050
maintaining or getting getting the

00:05:11,279 --> 00:05:16,050
rights to that pipe published for that

00:05:13,050 --> 00:05:17,490
package and in this case it was to get

00:05:16,050 --> 00:05:19,830
cookies packaged and they were able to

00:05:17,490 --> 00:05:21,839
publish a backdoor into the node modules

00:05:19,830 --> 00:05:24,210
and then anyone who's running upgrades

00:05:21,839 --> 00:05:27,650
of their dependencies without a log file

00:05:24,210 --> 00:05:29,729
is potentially getting this backdoor and

00:05:27,650 --> 00:05:32,009
because it was a cookie for posture

00:05:29,729 --> 00:05:34,680
could actually take commands that would

00:05:32,009 --> 00:05:38,400
allow remote institutions and things

00:05:34,680 --> 00:05:40,319
like that so you've gone from not

00:05:38,400 --> 00:05:42,089
knowing that you were using this package

00:05:40,319 --> 00:05:45,779
and this person had access to your

00:05:42,089 --> 00:05:47,759
application to them having full read

00:05:45,779 --> 00:05:51,509
access and being able to have control

00:05:47,759 --> 00:05:53,069
and ability to do anything they want and

00:05:51,509 --> 00:05:58,949
this is the model for a security tool

00:05:53,069 --> 00:06:03,960
just like scare people right so the the

00:05:58,949 --> 00:06:06,029
threat scenario is you you have all

00:06:03,960 --> 00:06:08,430
these retainers who depend on at any

00:06:06,029 --> 00:06:11,430
given time someone could get access to

00:06:08,430 --> 00:06:13,460
one of them push it out a patch you

00:06:11,430 --> 00:06:17,639
install the patch without knowing it and

00:06:13,460 --> 00:06:22,319
now you've been compromised because the

00:06:17,639 --> 00:06:24,169
security model no js' is service in any

00:06:22,319 --> 00:06:27,029
package you can do anything

00:06:24,169 --> 00:06:29,789
that cookie parser has full route access

00:06:27,029 --> 00:06:33,479
to the file system so the maintainer of

00:06:29,789 --> 00:06:34,740
that cookie box we can push and then

00:06:33,479 --> 00:06:37,319
what happens is when this gets

00:06:34,740 --> 00:06:40,170
discovered we have a the security

00:06:37,319 --> 00:06:42,390
process that kicks in we've made

00:06:40,170 --> 00:06:45,180
incredible starts in I'm getting to a

00:06:42,390 --> 00:06:48,150
position where security audiences are

00:06:45,180 --> 00:06:51,300
now completely widespread and that's

00:06:48,150 --> 00:06:54,840
amazing how that process has been built

00:06:51,300 --> 00:06:57,710
its it means that there's a very very

00:06:54,840 --> 00:07:00,810
short window before you security gets

00:06:57,710 --> 00:07:02,400
prominence he gets discovered but the

00:07:00,810 --> 00:07:07,380
problem was the security what it's

00:07:02,400 --> 00:07:10,370
saying is it can only deal with security

00:07:07,380 --> 00:07:13,350
vulnerabilities that are learn about and

00:07:10,370 --> 00:07:16,080
there is still that's that case where

00:07:13,350 --> 00:07:19,980
what about the this sort of maintainer

00:07:16,080 --> 00:07:22,350
that's been compromised

00:07:19,980 --> 00:07:24,780
and there's that still smoke that that

00:07:22,350 --> 00:07:27,120
small window of time where they're

00:07:24,780 --> 00:07:29,190
they're able to push up damaging code

00:07:27,120 --> 00:07:31,530
and there's nothing you can really do

00:07:29,190 --> 00:07:33,410
about that and we're especially

00:07:31,530 --> 00:07:35,910
vulnerable because in the node.js

00:07:33,410 --> 00:07:38,610
ecosystem we depend on a lot of

00:07:35,910 --> 00:07:40,440
maintainer and it's it's not going away

00:07:38,610 --> 00:07:42,690
where you know it's growing over time

00:07:40,440 --> 00:07:45,840
they might have third party code using

00:07:42,690 --> 00:07:48,960
and we update incredibly fast as well

00:07:45,840 --> 00:07:50,670
and with tools like defender box you're

00:07:48,960 --> 00:07:52,200
you're updating patches all the time and

00:07:50,670 --> 00:07:54,120
that's great because on the other hand

00:07:52,200 --> 00:07:56,280
you're you're patching vulnerabilities

00:07:54,120 --> 00:07:58,020
that are being discovered but it also

00:07:56,280 --> 00:08:00,720
means it's very easy to very quickly

00:07:58,020 --> 00:08:02,130
have one of those maintainer so you

00:08:00,720 --> 00:08:04,860
don't even know about I can be following

00:08:02,130 --> 00:08:07,200
for them to just push up something

00:08:04,860 --> 00:08:09,630
that's malicious for it to propagate

00:08:07,200 --> 00:08:12,390
very fast before it's eventually quartz

00:08:09,630 --> 00:08:16,170
pendant mitigated so it's just funny

00:08:12,390 --> 00:08:17,790
phone it's this new module all of this

00:08:16,170 --> 00:08:20,210
these boundaries out there I'm

00:08:17,790 --> 00:08:22,610
sweltering stop parking little too much

00:08:20,210 --> 00:08:25,320
but the idea is can we know somehow

00:08:22,610 --> 00:08:35,190
restrict those permissions so that it's

00:08:25,320 --> 00:08:40,800
not as thank you that makes things

00:08:35,190 --> 00:08:42,660
hundred times worse yes sir we should

00:08:40,800 --> 00:08:45,900
stop install scripts and we should just

00:08:42,660 --> 00:08:51,150
run install scripts that need to build

00:08:45,900 --> 00:08:53,430
binaries and can do it in ways that no

00:08:51,150 --> 00:08:57,850
no it's worse than ever

00:08:53,430 --> 00:08:59,980
if you own if you try and speak to

00:08:57,850 --> 00:09:01,770
anyone about securing JavaScript's or

00:08:59,980 --> 00:09:05,290
securing drugs because it works today

00:09:01,770 --> 00:09:07,300
know very quickly that the general

00:09:05,290 --> 00:09:09,070
assumption is that's just not possible

00:09:07,300 --> 00:09:11,500
because that's not how JavaScript works

00:09:09,070 --> 00:09:14,890
the language has too many security holes

00:09:11,500 --> 00:09:16,450
and we can't patch them and the only

00:09:14,890 --> 00:09:19,810
nice if you're any model for javascript

00:09:16,450 --> 00:09:20,890
is process isolation but versus sound

00:09:19,810 --> 00:09:24,700
parsing that's what the browser does

00:09:20,890 --> 00:09:29,890
that's what the v8 chrome engines do and

00:09:24,700 --> 00:09:31,900
that's the only security model and to

00:09:29,890 --> 00:09:34,420
try and fix individual things like that

00:09:31,900 --> 00:09:37,150
PR that I've got up to remove the global

00:09:34,420 --> 00:09:40,390
duck versus you just it's one small leak

00:09:37,150 --> 00:09:43,450
of a huge problem so don't even bother

00:09:40,390 --> 00:09:46,240
and that's before you even get into all

00:09:43,450 --> 00:09:52,270
this meltdown Specter stuff where we

00:09:46,240 --> 00:09:54,880
have these CPU hacks where even if you

00:09:52,270 --> 00:09:57,460
plug all those same vs. issues it's

00:09:54,880 --> 00:09:59,110
still possible for there to be same

00:09:57,460 --> 00:10:01,210
versus Bonnar but it's seizing the CPU

00:09:59,110 --> 00:10:03,460
itself so once we solve the language

00:10:01,210 --> 00:10:07,990
we're still broke the problems of the

00:10:03,460 --> 00:10:10,000
CPU architectures so the the counter

00:10:07,990 --> 00:10:11,650
counter argument is no GIS is not a

00:10:10,000 --> 00:10:14,250
browser we shouldn't take our security

00:10:11,650 --> 00:10:15,400
advice from the browser environments

00:10:14,250 --> 00:10:18,060
Noches

00:10:15,400 --> 00:10:21,100
has very different security properties

00:10:18,060 --> 00:10:23,250
and it's really not an option for us in

00:10:21,100 --> 00:10:25,480
there just to adduct

00:10:23,250 --> 00:10:27,910
sandboxing with negligence the way that

00:10:25,480 --> 00:10:31,440
are written now code sharing the

00:10:27,910 --> 00:10:34,060
language if we just sort of vault on

00:10:31,440 --> 00:10:36,910
some some kind of sandbox thing around

00:10:34,060 --> 00:10:38,350
that it's it's gonna break a lot of

00:10:36,910 --> 00:10:40,570
features and the way that thing's

00:10:38,350 --> 00:10:42,070
already behaved is there expect to be

00:10:40,570 --> 00:10:45,520
able to share the same bindings and the

00:10:42,070 --> 00:10:51,190
same function instances so it's not

00:10:45,520 --> 00:10:53,200
necessarily we can just so then is the

00:10:51,190 --> 00:10:56,440
question is well we just left with a

00:10:53,200 --> 00:11:01,360
security auditing and we kind of have

00:10:56,440 --> 00:11:02,590
this process where we know that any

00:11:01,360 --> 00:11:04,690
malicious maintainer

00:11:02,590 --> 00:11:06,970
could come in or search engine in that

00:11:04,690 --> 00:11:10,240
way insert projects or

00:11:06,970 --> 00:11:14,199
still the are the keys of a maintainer

00:11:10,240 --> 00:11:16,720
and when that happens it's just kind of

00:11:14,199 --> 00:11:18,310
a process where we all have to very

00:11:16,720 --> 00:11:20,079
quickly respond to that and that's just

00:11:18,310 --> 00:11:23,170
the way things are and we just sort of

00:11:20,079 --> 00:11:24,370
accept this kind of sacrifice every now

00:11:23,170 --> 00:11:26,019
and then that a few people are going to

00:11:24,370 --> 00:11:31,000
get hacked from time to time that's just

00:11:26,019 --> 00:11:32,680
the way things are and the so that the

00:11:31,000 --> 00:11:35,410
response of those arguments about trying

00:11:32,680 --> 00:11:38,019
to get perfect security is what can we

00:11:35,410 --> 00:11:40,660
do to mitigate those risks sort of

00:11:38,019 --> 00:11:42,910
reduce those risks not perfectly solve

00:11:40,660 --> 00:11:45,310
them not create an ecosystem where

00:11:42,910 --> 00:11:48,160
everything is perfectly secure but what

00:11:45,310 --> 00:11:51,850
can we do to make sure that as much as

00:11:48,160 --> 00:11:55,420
possible we reduce that risk which right

00:11:51,850 --> 00:11:56,980
now is quite high because any of the

00:11:55,420 --> 00:12:00,790
hundreds of maintains that have exists

00:11:56,980 --> 00:12:02,069
in my app can get a full read access so

00:12:00,790 --> 00:12:04,389
it's not a black-and-white issue

00:12:02,069 --> 00:12:06,910
there won't be an attack surface at

00:12:04,389 --> 00:12:08,589
minimum you can be hacked so if you

00:12:06,910 --> 00:12:10,930
think of this critical attack

00:12:08,589 --> 00:12:13,629
probability as something like how many

00:12:10,930 --> 00:12:17,649
maintain is had published access to all

00:12:13,629 --> 00:12:19,269
our grid pods times the average security

00:12:17,649 --> 00:12:21,670
standards of those maintenance so do

00:12:19,269 --> 00:12:24,399
they use two-factor authentication how

00:12:21,670 --> 00:12:26,439
susceptible are they to spoofing or

00:12:24,399 --> 00:12:30,750
other types of hacking attacks

00:12:26,439 --> 00:12:33,279
ideally NPM by default would use survey

00:12:30,750 --> 00:12:36,339
but that's that would be a huge ones

00:12:33,279 --> 00:12:37,660
reduce overall probability and then the

00:12:36,339 --> 00:12:42,040
third thing that factors into this

00:12:37,660 --> 00:12:51,129
protein was that you might want to reach

00:12:42,040 --> 00:12:53,740
to NPM data from the registry gives us

00:12:51,129 --> 00:12:56,790
the information that published was

00:12:53,740 --> 00:13:00,210
published as to FA enable

00:12:56,790 --> 00:13:04,290
and that is that's probably valuable in

00:13:00,210 --> 00:13:06,080
this context that's a very good point

00:13:04,290 --> 00:13:11,550
that you could have some kind of like

00:13:06,080 --> 00:13:17,970
upgrade doubled our security session you

00:13:11,550 --> 00:13:20,370
can at that point essentially it is not

00:13:17,970 --> 00:13:22,530
a solution but at least you know your

00:13:20,370 --> 00:13:24,990
data to measure that and right now we

00:13:22,530 --> 00:13:36,510
got so so you can say I only want to get

00:13:24,990 --> 00:13:38,370
patch updates from because that way you

00:13:36,510 --> 00:13:40,020
can drive the two of the adoptions the

00:13:38,370 --> 00:13:42,030
user as opposed to expecting it to be

00:13:40,020 --> 00:13:44,930
some kind of stable thing that can be

00:13:42,030 --> 00:13:47,280
more cemented yeah okay that's great

00:13:44,930 --> 00:13:50,520
yeah and then the third factor that

00:13:47,280 --> 00:13:52,530
comes into the probability is if that

00:13:50,520 --> 00:13:54,270
maintain it does get hacked and we know

00:13:52,530 --> 00:13:57,450
that they're on they're able to operate

00:13:54,270 --> 00:14:00,350
on packages how capable of this

00:13:57,450 --> 00:14:04,230
maintained is even if they wanted to to

00:14:00,350 --> 00:14:06,840
get access to our systems and at the

00:14:04,230 --> 00:14:09,480
moment that's one sir any maintain that

00:14:06,840 --> 00:14:12,330
gets full access the question is can we

00:14:09,480 --> 00:14:14,100
possibly think of a way or an ecosystem

00:14:12,330 --> 00:14:19,230
in future where we could reduce that

00:14:14,100 --> 00:14:21,840
down so that it's it's average is less

00:14:19,230 --> 00:14:24,420
than one and that's what we can mitigate

00:14:21,840 --> 00:14:26,430
so if we can just start reducing my

00:14:24,420 --> 00:14:28,920
capability over time and reduce the the

00:14:26,430 --> 00:14:31,080
Commission's that we give we could

00:14:28,920 --> 00:14:35,010
possibly start to mitigate the server

00:14:31,080 --> 00:14:37,050
probability well so and then the other

00:14:35,010 --> 00:14:39,180
thing is we don't want to just reduce

00:14:37,050 --> 00:14:41,970
this probability by reducing the number

00:14:39,180 --> 00:14:44,910
of maintained we don't want to retreat

00:14:41,970 --> 00:14:47,730
into some kind of Levitz ism where we

00:14:44,910 --> 00:14:50,220
think no me open source and secure we're

00:14:47,730 --> 00:14:51,660
just going to rely on our own company

00:14:50,220 --> 00:14:53,910
code or something like we want to

00:14:51,660 --> 00:14:57,960
encourage these healthy ecosystems where

00:14:53,910 --> 00:15:00,750
we can safely share code and sorry we

00:14:57,960 --> 00:15:04,700
can focus on these these other two then

00:15:00,750 --> 00:15:06,750
we can compensate for the photo security

00:15:04,700 --> 00:15:08,880
so I'm just going to take a step back

00:15:06,750 --> 00:15:09,510
and speak about the security model a

00:15:08,880 --> 00:15:13,910
little bit

00:15:09,510 --> 00:15:17,910
webassembly here is an example of

00:15:13,910 --> 00:15:22,139
running weather simply through its

00:15:17,910 --> 00:15:24,660
modules in ojs today that main should

00:15:22,139 --> 00:15:28,800
probably be a main MJS or I could have a

00:15:24,660 --> 00:15:33,300
package.json and in this example I'm

00:15:28,800 --> 00:15:35,220
loading say a JavaScript pasta that's in

00:15:33,300 --> 00:15:37,829
the third party module that I've

00:15:35,220 --> 00:15:39,930
installed and I'm learning it from a

00:15:37,829 --> 00:15:42,420
wizened so I'm learning it's memory

00:15:39,930 --> 00:15:46,440
which is just offer and a pass function

00:15:42,420 --> 00:15:48,180
and at the bottom there I am running the

00:15:46,440 --> 00:15:49,500
process so I'd say writing a string in

00:15:48,180 --> 00:15:51,570
sleep into the buffer and they're

00:15:49,500 --> 00:15:52,860
passing it and getting appoints it's the

00:15:51,570 --> 00:15:55,620
data structure a memory of something

00:15:52,860 --> 00:15:58,440
it's a very rudimentary example just

00:15:55,620 --> 00:16:02,279
showing the sort of minimum webassembly

00:15:58,440 --> 00:16:04,110
interfaces we have today but what this

00:16:02,279 --> 00:16:06,240
demonstrates is the security model where

00:16:04,110 --> 00:16:08,010
we could have for example and it's the

00:16:06,240 --> 00:16:10,829
to the to practice of the security model

00:16:08,010 --> 00:16:12,660
so the one thing is having information

00:16:10,829 --> 00:16:14,940
be compromised to say for example we've

00:16:12,660 --> 00:16:16,440
got some information we don't want that

00:16:14,940 --> 00:16:19,680
third-party modules to be able to

00:16:16,440 --> 00:16:21,870
discover the highly coveted shrug emoji

00:16:19,680 --> 00:16:25,529
and then we also have a function here

00:16:21,870 --> 00:16:27,720
that we don't want to be run by by our

00:16:25,529 --> 00:16:30,959
third-party modules so if this function

00:16:27,720 --> 00:16:33,300
represents the capability that the new

00:16:30,959 --> 00:16:34,589
clearance function where you don't want

00:16:33,300 --> 00:16:37,980
the third party current to be able to

00:16:34,589 --> 00:16:40,110
call that function so do we know that we

00:16:37,980 --> 00:16:41,699
can safely load this third-party code

00:16:40,110 --> 00:16:44,220
this third party web assembly code

00:16:41,699 --> 00:16:45,720
without either exposing secrets or

00:16:44,220 --> 00:16:49,920
exposing the ability to call these

00:16:45,720 --> 00:16:52,230
protected functions here is what might

00:16:49,920 --> 00:16:54,420
be inside that one like sembly module it

00:16:52,230 --> 00:16:56,959
defines its memory it defines its past

00:16:54,420 --> 00:16:59,399
function and then it exports them and

00:16:56,959 --> 00:17:01,500
the amazing thing about web assembly is

00:16:59,399 --> 00:17:04,470
if we know that that module has no

00:17:01,500 --> 00:17:07,140
influence so if we know for a fact that

00:17:04,470 --> 00:17:11,549
this web assembly module itself isn't

00:17:07,140 --> 00:17:15,540
able to import anything else from a file

00:17:11,549 --> 00:17:17,370
system or the module system then we

00:17:15,540 --> 00:17:20,900
don't care what code is in this passing

00:17:17,370 --> 00:17:23,540
function it could be downloaded from the

00:17:20,900 --> 00:17:25,580
Dodge's side of the internet it doesn't

00:17:23,540 --> 00:17:28,520
matter what's in that function because

00:17:25,580 --> 00:17:30,530
it won't have access to wouldn't be able

00:17:28,520 --> 00:17:32,780
to get access the secret information or

00:17:30,530 --> 00:17:36,320
the the function capabilities we have on

00:17:32,780 --> 00:17:38,570
our other one and so web assembly is a

00:17:36,320 --> 00:17:41,720
secure sandbox down to the inputs that

00:17:38,570 --> 00:17:44,750
is given and if we can control which

00:17:41,720 --> 00:17:46,910
imports are available then we can run

00:17:44,750 --> 00:17:50,450
unknown third party web assembly code on

00:17:46,910 --> 00:17:54,470
the same process with zero risk and even

00:17:50,450 --> 00:17:56,240
was meltdown inspector we don't have

00:17:54,470 --> 00:17:58,460
that problem even because multi

00:17:56,240 --> 00:18:01,820
inspector are timing attacks they need

00:17:58,460 --> 00:18:05,300
access to timers in the environment and

00:18:01,820 --> 00:18:07,460
in this code example the web assembly

00:18:05,300 --> 00:18:10,490
code has no access to its home it can't

00:18:07,460 --> 00:18:12,890
access any timing functions so it can't

00:18:10,490 --> 00:18:15,950
do any reverse engineering of the CPU

00:18:12,890 --> 00:18:20,540
cache to try and discover sensitive

00:18:15,950 --> 00:18:22,940
information so this is also a

00:18:20,540 --> 00:18:25,370
demonstration of Berlin so the marginal

00:18:22,940 --> 00:18:29,000
only has as much access as it needs to

00:18:25,370 --> 00:18:32,170
to do its job and a st+ is a metered

00:18:29,000 --> 00:18:32,170
access to the file system

00:18:35,500 --> 00:18:41,330
saying what assembly doesn't have access

00:18:37,970 --> 00:18:44,000
to javascript engines like object so

00:18:41,330 --> 00:18:46,910
yeah it doesn't have any global object

00:18:44,000 --> 00:18:50,960
like javascript does and so it wouldn't

00:18:46,910 --> 00:18:58,120
have access to to access anything so i

00:18:50,960 --> 00:18:58,120
can't construct an object access exactly

00:18:58,510 --> 00:19:02,890
unlike every other programming language

00:19:03,610 --> 00:19:11,180
and that's exactly the next thing i'm

00:19:06,500 --> 00:19:12,980
going to get since but what about

00:19:11,180 --> 00:19:14,840
JavaScript well JavaScript has all of

00:19:12,980 --> 00:19:19,760
these exact same security properties

00:19:14,840 --> 00:19:21,050
that webassembly has and this is what we

00:19:19,760 --> 00:19:25,840
mean when we say it's very close to

00:19:21,050 --> 00:19:31,850
having a strong security security

00:19:25,840 --> 00:19:32,330
what's the word properties so except for

00:19:31,850 --> 00:19:34,220
boiling

00:19:32,330 --> 00:19:36,500
one we

00:19:34,220 --> 00:19:40,309
mobile capabilities we have global dog

00:19:36,500 --> 00:19:42,490
versus if we implement fetch like the

00:19:40,309 --> 00:19:45,019
browser service we have global dog fetch

00:19:42,490 --> 00:19:46,429
we have a readable global and mutable

00:19:45,019 --> 00:19:49,340
intrinsic so you can write a write

00:19:46,429 --> 00:19:50,509
object prototype you can add things to

00:19:49,340 --> 00:19:53,360
the global you can read sensitive

00:19:50,509 --> 00:19:57,799
information we have access to timers and

00:19:53,360 --> 00:19:59,029
we have unrestricted access samples so

00:19:57,799 --> 00:20:01,909
I'm just going to go through these in a

00:19:59,029 --> 00:20:04,250
little bit more detail global

00:20:01,909 --> 00:20:05,179
capabilities of process you can have a

00:20:04,250 --> 00:20:07,730
whole bunch of sensitive information

00:20:05,179 --> 00:20:08,929
process persist under environments

00:20:07,730 --> 00:20:12,879
probably going to have some security

00:20:08,929 --> 00:20:15,200
tokens on it you can read the Snowman in

00:20:12,879 --> 00:20:17,389
so these are all things that can contain

00:20:15,200 --> 00:20:19,580
sensitive information that you don't

00:20:17,389 --> 00:20:23,509
want peeking out and if we have a global

00:20:19,580 --> 00:20:27,409
fetch well in this example but like a

00:20:23,509 --> 00:20:28,580
JavaScript parser and then underneath it

00:20:27,409 --> 00:20:30,049
can just have a whole bunch of code that

00:20:28,580 --> 00:20:33,350
steal secrets off the process

00:20:30,049 --> 00:20:34,960
environments it can you know okay to

00:20:33,350 --> 00:20:37,580
take one of those from the Global's and

00:20:34,960 --> 00:20:39,679
if we have a fetched level it'll be able

00:20:37,580 --> 00:20:42,740
to share those secrets with a third

00:20:39,679 --> 00:20:45,289
party server and this is one of the

00:20:42,740 --> 00:20:47,690
arguments for why me Pro me don't want

00:20:45,289 --> 00:20:49,820
offense level energy yes and I would

00:20:47,690 --> 00:20:53,690
argue strongly against a vegetable in

00:20:49,820 --> 00:20:55,580
DOJ's is because it makes this global

00:20:53,690 --> 00:21:00,200
capability available to all third party

00:20:55,580 --> 00:21:01,970
packages which if we don't have then

00:21:00,200 --> 00:21:04,820
those packages don't have the ability to

00:21:01,970 --> 00:21:06,559
to share these secrets anymore we've

00:21:04,820 --> 00:21:09,440
also got deal everything you can open

00:21:06,559 --> 00:21:12,259
any node native binary and get full

00:21:09,440 --> 00:21:14,750
access to make service business and

00:21:12,259 --> 00:21:17,210
we've got persist on a chart time which

00:21:14,750 --> 00:21:19,610
is ideal for doing about 10 specs it's

00:21:17,210 --> 00:21:21,019
like climbing attacks because you don't

00:21:19,610 --> 00:21:22,610
even have to construct a timer anymore

00:21:21,019 --> 00:21:23,779
to do those attacks you've got this

00:21:22,610 --> 00:21:26,090
perfect

00:21:23,779 --> 00:21:30,980
CPU timer that you can use to detect

00:21:26,090 --> 00:21:32,480
when it's optimizing the other thing is

00:21:30,980 --> 00:21:34,370
that these mutable Global's the mutable

00:21:32,480 --> 00:21:36,230
intrinsic s-- you could have a

00:21:34,370 --> 00:21:37,309
third-party package that over arrest

00:21:36,230 --> 00:21:40,549
json stringify

00:21:37,309 --> 00:21:42,769
and now you're using stringify on your

00:21:40,549 --> 00:21:44,269
app and it's behaving the same but in

00:21:42,769 --> 00:21:45,649
the meantime it could be stealing all

00:21:44,269 --> 00:21:47,110
that information that's running through

00:21:45,649 --> 00:21:49,769
JSON that string

00:21:47,110 --> 00:21:52,990
so and then sending it off to

00:21:49,769 --> 00:21:54,760
third-party server objects on to

00:21:52,990 --> 00:21:57,190
streaming prototypes like to straight

00:21:54,760 --> 00:22:00,159
and you ever ridden to do the same thing

00:21:57,190 --> 00:22:03,250
and as the this finding so you suddenly

00:22:00,159 --> 00:22:05,679
exposed just by calling to string on an

00:22:03,250 --> 00:22:09,279
object without realizing you've exposed

00:22:05,679 --> 00:22:11,620
that that object itself system of their

00:22:09,279 --> 00:22:13,809
body code and so these traps in

00:22:11,620 --> 00:22:16,360
JavaScript allow third-party codes

00:22:13,809 --> 00:22:18,279
intercept objects that you thought were

00:22:16,360 --> 00:22:21,250
only within your own application code

00:22:18,279 --> 00:22:25,740
and here is an example another example

00:22:21,250 --> 00:22:29,019
of ways in which you can inject into

00:22:25,740 --> 00:22:32,019
intrinsics and this one's a little bit

00:22:29,019 --> 00:22:34,179
more convoluted but say for example you

00:22:32,019 --> 00:22:37,059
have a walk function that has objects of

00:22:34,179 --> 00:22:40,779
two types and it's either a type A or

00:22:37,059 --> 00:22:42,460
type B and the one type has a children

00:22:40,779 --> 00:22:44,860
property and the other type deserts and

00:22:42,460 --> 00:22:46,539
you check which type you've got by

00:22:44,860 --> 00:22:49,059
checking if you can do that property

00:22:46,539 --> 00:22:51,460
access and if it returns undefined but

00:22:49,059 --> 00:22:52,600
that property exists to explore children

00:22:51,460 --> 00:22:55,690
is going to get all the way down the

00:22:52,600 --> 00:22:58,120
prototype chain object so if some

00:22:55,690 --> 00:23:00,220
malicious code had defined children on

00:22:58,120 --> 00:23:03,820
the object prototype it's got again a

00:23:00,220 --> 00:23:07,630
trap and it kills us still the object in

00:23:03,820 --> 00:23:10,419
this example the classes these are not

00:23:07,630 --> 00:23:13,330
just objects their classes and you could

00:23:10,419 --> 00:23:14,710
have potentially functions or

00:23:13,330 --> 00:23:18,039
capabilities on the subjects as well

00:23:14,710 --> 00:23:19,990
they're not being made available so it's

00:23:18,039 --> 00:23:23,919
these are the ways in which we're

00:23:19,990 --> 00:23:39,250
spilling these security properties any

00:23:23,919 --> 00:23:49,299
questions okay and in three six sorry

00:23:39,250 --> 00:23:51,490
and primordius which so the way we are

00:23:49,299 --> 00:23:54,820
tracking primordia primordia in node

00:23:51,490 --> 00:23:58,570
it's introduces some performance

00:23:54,820 --> 00:23:59,620
overhead and accessing robust is faster

00:23:58,570 --> 00:24:02,340
than

00:23:59,620 --> 00:24:18,340
not accessing Global's to some extent

00:24:02,340 --> 00:24:54,730
and doing a level of production so it's

00:24:18,340 --> 00:24:59,110
not just about it's also moving it

00:24:54,730 --> 00:25:16,150
instead of constantly in the file and

00:24:59,110 --> 00:25:19,450
then just using that instead each

00:25:16,150 --> 00:25:22,090
relates because you have you know the

00:25:19,450 --> 00:25:25,750
problem with the globe us and the way

00:25:22,090 --> 00:25:34,000
you're doing the global stuff we want to

00:25:25,750 --> 00:25:38,940
you your incident the pr if granting

00:25:34,000 --> 00:25:42,340
security on those type of global things

00:25:38,940 --> 00:25:47,220
needs to not have an impact on the

00:25:42,340 --> 00:25:52,180
performance of node and this is chuh

00:25:47,220 --> 00:25:55,090
different so to be very clear little

00:25:52,180 --> 00:25:58,000
purses is it's there is nothing else

00:25:55,090 --> 00:26:01,660
that I'm proposing changing and that

00:25:58,000 --> 00:26:03,820
behavior global purses does course so

00:26:01,660 --> 00:26:06,390
that kind of created a PR and saying

00:26:03,820 --> 00:26:08,320
well these Global's it's this example

00:26:06,390 --> 00:26:10,900
where we've done all these things on

00:26:08,320 --> 00:26:11,750
person s in the global scope and I'm

00:26:10,900 --> 00:26:13,850
saying

00:26:11,750 --> 00:26:15,980
we should deprecated process so we can

00:26:13,850 --> 00:26:18,289
allow this not to be possible anymore

00:26:15,980 --> 00:26:20,389
for people to promote education tokens

00:26:18,289 --> 00:26:22,250
or persistent environments in any

00:26:20,389 --> 00:26:24,529
JavaScript environment but we're only

00:26:22,250 --> 00:26:30,679
deprecating process and ES modules and

00:26:24,529 --> 00:27:28,340
the way that I constructed that object

00:26:30,679 --> 00:27:30,470
and you're right so what we've got now

00:27:28,340 --> 00:27:33,169
to mitigate these these problems of the

00:27:30,470 --> 00:27:35,090
Global's and their tricks is we have a

00:27:33,169 --> 00:27:38,240
frozen intrinsics flag that landed in

00:27:35,090 --> 00:27:40,070
eleven weights and what this does is it

00:27:38,240 --> 00:27:44,690
goes through all these objects like JSON

00:27:40,070 --> 00:27:48,169
object object prototype question at

00:27:44,690 --> 00:27:49,549
least so maybe in the intrinsics that

00:27:48,169 --> 00:27:51,860
are available anything that's on the

00:27:49,549 --> 00:27:53,809
global object nominee and it freezes it

00:27:51,860 --> 00:27:57,860
so that you can't do if you try to do

00:27:53,809 --> 00:28:00,080
any of these lines of code in strict

00:27:57,860 --> 00:28:05,210
mode you'll get an error if you try to

00:28:00,080 --> 00:28:07,070
override these these defaults and what

00:28:05,210 --> 00:28:09,889
we're what we're doing is we're seeing

00:28:07,070 --> 00:28:12,710
if those who are interested in exploring

00:28:09,889 --> 00:28:17,509
these security properties of one to see

00:28:12,710 --> 00:28:21,080
if they can enable module emissions this

00:28:17,509 --> 00:28:22,879
is absolutely critical to that but it's

00:28:21,080 --> 00:28:25,110
opt-in so we're not changing the default

00:28:22,879 --> 00:28:27,390
experience in mode you can opt into it

00:28:25,110 --> 00:28:30,450
and then third-party packages will

00:28:27,390 --> 00:28:32,940
likely hidden cases with our bug squared

00:28:30,450 --> 00:28:34,230
where it runs up against this flag and

00:28:32,940 --> 00:28:37,010
that's where we want to get feedback on

00:28:34,230 --> 00:28:41,429
and see how people are using this and

00:28:37,010 --> 00:28:43,799
potentially get ecosystem peons that fix

00:28:41,429 --> 00:28:46,380
in cases where it breaks or if there are

00:28:43,799 --> 00:28:48,299
problems integrating this this change of

00:28:46,380 --> 00:28:50,160
a which is quite a big change into

00:28:48,299 --> 00:28:51,660
Hayden's do you think back in the day we

00:28:50,160 --> 00:28:54,420
had things like the Poorna type library

00:28:51,660 --> 00:28:56,760
that was entirely builds off the

00:28:54,420 --> 00:28:58,650
concepts of overriding gates prototypes

00:28:56,760 --> 00:29:01,380
and the browser

00:28:58,650 --> 00:29:03,690
it's quite an it might have make a

00:29:01,380 --> 00:29:06,080
change to think on these things this

00:29:03,690 --> 00:29:08,669
person but this is critical to getting

00:29:06,080 --> 00:29:12,059
security prophecies in JavaScript once

00:29:08,669 --> 00:29:13,860
it and then see how far we can get in

00:29:12,059 --> 00:29:15,990
executing node modules under this flag

00:29:13,860 --> 00:29:17,360
and if anyone is using this or

00:29:15,990 --> 00:29:19,440
interested in exploring it further

00:29:17,360 --> 00:29:24,270
please do chance me Oh anyone else

00:29:19,440 --> 00:29:26,970
involved in this work the the code cases

00:29:24,270 --> 00:29:29,900
there are scenarios where setting to

00:29:26,970 --> 00:29:32,220
string upon objects that aren't that

00:29:29,900 --> 00:29:35,549
don't happen to begin with and these are

00:29:32,220 --> 00:29:37,500
sort of the the subtle bugs that that

00:29:35,549 --> 00:29:40,830
can happen and in the cases we need to

00:29:37,500 --> 00:29:43,980
announce when it happens on the one hand

00:29:40,830 --> 00:29:45,929
it's regarded as a spec bug that you

00:29:43,980 --> 00:29:49,200
can't define any of the object methods

00:29:45,929 --> 00:29:51,570
on an object that has a foreign object

00:29:49,200 --> 00:29:54,270
prototype and you need to make sure they

00:29:51,570 --> 00:29:55,980
are defined up front but it's very these

00:29:54,270 --> 00:29:57,299
are the sort of bugs that you get but

00:29:55,980 --> 00:29:59,549
hopefully they've thrown in mind because

00:29:57,299 --> 00:30:02,030
object doesn't have any properties on

00:29:59,549 --> 00:30:02,030
its prototype

00:30:02,419 --> 00:30:07,140
the third thing is timers and

00:30:05,210 --> 00:30:10,049
unfortunately we can never Nippert

00:30:07,140 --> 00:30:12,210
eight-day no in javascript in node.js

00:30:10,049 --> 00:30:13,620
it's pretty hard to get into the

00:30:12,210 --> 00:30:15,660
ecosystem I mean maybe we could make

00:30:13,620 --> 00:30:17,130
some progress on that but we just have

00:30:15,660 --> 00:30:19,230
to accept that we have access to five

00:30:17,130 --> 00:30:23,760
minutes which means we have a meltdown

00:30:19,230 --> 00:30:28,110
inspector attacks and so we just like to

00:30:23,760 --> 00:30:30,630
assume that it will be possible for the

00:30:28,110 --> 00:30:32,340
sort of reverse engineering attacks

00:30:30,630 --> 00:30:35,370
timing attacks on the CPUs to take place

00:30:32,340 --> 00:30:38,700
and sensitive information in the same

00:30:35,370 --> 00:30:41,039
process can be read

00:30:38,700 --> 00:30:42,960
so you've got a token a secure token or

00:30:41,039 --> 00:30:44,820
a secure informational essential

00:30:42,960 --> 00:30:47,159
information that's running in the same

00:30:44,820 --> 00:30:48,899
application just like the the

00:30:47,159 --> 00:30:52,169
webassembly example that I showed at the

00:30:48,899 --> 00:30:54,539
beginning if you're in JavaScript you

00:30:52,169 --> 00:30:56,190
have to assume that there exists an

00:30:54,539 --> 00:31:00,379
attack that will be able to discover

00:30:56,190 --> 00:31:00,379
that information in a module running

00:31:00,499 --> 00:32:30,590
even though there are consider them yes

00:31:20,399 --> 00:32:30,590
if you're on course you wouldn't change

00:32:32,539 --> 00:32:38,809
it workers are running in the same

00:32:34,679 --> 00:32:38,809
process and they all say it's acceptable

00:32:42,389 --> 00:32:56,410
we are modular operations for workers

00:32:52,270 --> 00:33:02,890
which are well as you mentioned soon

00:32:56,410 --> 00:33:04,870
you're gonna you cannot yeah maybe we

00:33:02,890 --> 00:33:07,480
could add a flag to know to disable date

00:33:04,870 --> 00:33:09,820
or no but I'm not optimistic about that

00:33:07,480 --> 00:33:11,650
working in the ecosystem I just think

00:33:09,820 --> 00:33:14,200
it'll break too much already this

00:33:11,650 --> 00:33:16,120
present intrinsics is a tough one and

00:33:14,200 --> 00:33:18,190
will take a lot of collective effort to

00:33:16,120 --> 00:33:19,570
be able to support the ecosystem and PR

00:33:18,190 --> 00:33:23,710
the ecosystem to support it

00:33:19,570 --> 00:33:27,010
they danger now is even more drastic but

00:33:23,710 --> 00:33:28,540
yeah in workers I'll talk about that's

00:33:27,010 --> 00:33:30,309
one of the reasons why I want it was so

00:33:28,540 --> 00:33:33,130
deprecated leveled up process because

00:33:30,309 --> 00:33:35,290
they need own of HR time it's harder to

00:33:33,130 --> 00:33:36,730
construct a high-resolution toilet what

00:33:35,290 --> 00:33:38,830
they don't know but I believe it is

00:33:36,730 --> 00:33:41,679
possible there there are various very

00:33:38,830 --> 00:33:44,590
subtle techniques but yeah persist

00:33:41,679 --> 00:33:50,530
audience might need for that fancy works

00:33:44,590 --> 00:33:53,020
it's radical members so but the key

00:33:50,530 --> 00:33:54,460
thing I want to mention here is just

00:33:53,020 --> 00:33:57,370
because you can discover a secret

00:33:54,460 --> 00:33:59,950
doesn't mean you're stirring it so to

00:33:57,370 --> 00:34:02,260
complete the act of stealing a secret

00:33:59,950 --> 00:34:04,990
means being able to propagate that

00:34:02,260 --> 00:34:06,700
information to another server so you

00:34:04,990 --> 00:34:09,820
need to have the timer capabilities

00:34:06,700 --> 00:34:11,290
which may be let's give up one but then

00:34:09,820 --> 00:34:13,540
you also need to have the capability to

00:34:11,290 --> 00:34:15,220
share that secret so even if you're

00:34:13,540 --> 00:34:17,889
running code on the same versus that in

00:34:15,220 --> 00:34:20,020
theory could be discovering for your

00:34:17,889 --> 00:34:23,290
internal authentication codes and things

00:34:20,020 --> 00:34:25,270
is only can be considered insecure if it

00:34:23,290 --> 00:34:27,609
also then is able to share that

00:34:25,270 --> 00:34:29,260
information with a third part if that

00:34:27,609 --> 00:34:31,570
code is in a sandbox where it doesn't

00:34:29,260 --> 00:34:33,940
know the ability to ask in a sandbox

00:34:31,570 --> 00:34:37,000
then a con share the secret serve was

00:34:33,940 --> 00:34:40,210
the secret really activist so this is

00:34:37,000 --> 00:34:42,550
the capability to exfiltrate and if we

00:34:40,210 --> 00:34:45,100
move the the focus for javascript from

00:34:42,550 --> 00:34:48,460
the capability for timers and except

00:34:45,100 --> 00:34:49,780
we've lost that war and rather just move

00:34:48,460 --> 00:34:52,929
it to the to focusing on the

00:34:49,780 --> 00:34:55,119
capabilities for exfiltration then that

00:34:52,929 --> 00:34:57,010
could be a way that we still maintain a

00:34:55,119 --> 00:35:00,310
strong security model making sure that

00:34:57,010 --> 00:35:03,609
secrets crumble stolen so this means

00:35:00,310 --> 00:35:05,410
protecting your side tunnels so things

00:35:03,609 --> 00:35:08,620
like HTTP

00:35:05,410 --> 00:36:00,850
Finch any any other realities on touch

00:35:08,620 --> 00:36:02,440
the network we need to think about and

00:36:00,850 --> 00:36:13,540
so I was just curious if there was any

00:36:02,440 --> 00:36:16,920
way right so yeah so that's the third

00:36:13,540 --> 00:36:20,470
way to construct a timer is with chénier

00:36:16,920 --> 00:36:22,240
you can kind of have something that runs

00:36:20,470 --> 00:36:24,280
in a separate thread it's always

00:36:22,240 --> 00:36:26,470
incrementing a single memory location

00:36:24,280 --> 00:36:30,130
and you can sort of form a timing

00:36:26,470 --> 00:36:31,900
mechanism so access to shared memory in

00:36:30,130 --> 00:36:35,070
WebAssign javascript should be regarded

00:36:31,900 --> 00:36:37,360
a a timer mechanism

00:36:35,070 --> 00:36:41,200
ideally but webassembly if we want to be

00:36:37,360 --> 00:36:42,580
able to be secure for not being a lot

00:36:41,200 --> 00:36:44,770
not allowing those kind of secret

00:36:42,580 --> 00:36:46,480
attacks we wouldn't want to restrict

00:36:44,770 --> 00:36:49,990
access to shared memory and treated as a

00:36:46,480 --> 00:36:51,250
mission because we don't have that time

00:36:49,990 --> 00:36:54,580
a problem in whether something like we

00:36:51,250 --> 00:36:59,500
do JavaScript but in JavaScript because

00:36:54,580 --> 00:37:03,130
we have time it's there unless we can

00:36:59,500 --> 00:37:05,380
get rid of they know that's that's its

00:37:03,130 --> 00:37:07,000
early so that the fact that there might

00:37:05,380 --> 00:37:10,360
be ways for should memory to construct

00:37:07,000 --> 00:37:15,090
timelessness yeah it could be another

00:37:10,360 --> 00:37:15,090
another way of getting time sure

00:37:21,990 --> 00:37:28,650
there are many sources of time yes

00:37:29,820 --> 00:37:35,290
simply with workers right now they spin

00:37:33,250 --> 00:37:45,670
them up they're given a full copy the

00:37:35,290 --> 00:37:50,920
environment I'm looking at the start it

00:37:45,670 --> 00:37:53,170
wanted access to require so hopefully

00:37:50,920 --> 00:38:03,430
you know what they won't solve a doubt

00:37:53,170 --> 00:38:06,730
if you were yeah I mostly purple poor

00:38:03,430 --> 00:38:15,310
modular is when we get to that to

00:38:06,730 --> 00:38:18,760
quickly debate similar so yeah we need

00:38:15,310 --> 00:38:21,700
to have a secure sort of care concept of

00:38:18,760 --> 00:38:24,730
this capability to extract a secret to

00:38:21,700 --> 00:38:26,140
send it back off to malicious server or

00:38:24,730 --> 00:38:28,869
something like that as long as we can

00:38:26,140 --> 00:38:32,500
control that access we can control the

00:38:28,869 --> 00:38:34,000
the secret from getting on and then the

00:38:32,500 --> 00:38:36,340
thing you watch out for is what support

00:38:34,000 --> 00:38:38,470
covert spy channels suicide channels

00:38:36,340 --> 00:38:40,240
that we didn't even know we were doing

00:38:38,470 --> 00:38:42,670
so say for example you're rendering some

00:38:40,240 --> 00:38:44,109
HTML and your HTML rendering attacked

00:38:42,670 --> 00:38:46,810
and now it's spitting out secret

00:38:44,109 --> 00:38:48,970
information for that curb invisible HTML

00:38:46,810 --> 00:38:51,040
or something it's it's a sign channel

00:38:48,970 --> 00:38:52,900
that you didn't intend to exist a sudden

00:38:51,040 --> 00:38:55,750
exists but these are the sort of things

00:38:52,900 --> 00:38:58,540
that we will still rely on security

00:38:55,750 --> 00:39:00,640
audits for but the difference with cocoa

00:38:58,540 --> 00:39:03,310
inside tunnels is where they're not

00:39:00,640 --> 00:39:06,369
suspected to be they can simply be

00:39:03,310 --> 00:39:07,750
Marcus purity bugs yeah there's still

00:39:06,369 --> 00:39:12,160
gonna be my own abilities and let's say

00:39:07,750 --> 00:39:14,410
anything curious but if we think in so

00:39:12,160 --> 00:39:17,080
the first thing is you the ways that you

00:39:14,410 --> 00:39:19,750
get findings in a module is you've got

00:39:17,080 --> 00:39:23,200
the global we've got the intrinsics we

00:39:19,750 --> 00:39:25,270
brought the timers and then the way that

00:39:23,200 --> 00:39:27,520
you would access the outside world at

00:39:25,270 --> 00:39:29,640
this point is through in what's so if

00:39:27,520 --> 00:39:30,850
you think of imports as a kind of

00:39:29,640 --> 00:39:33,550
capability

00:39:30,850 --> 00:39:35,920
when you import refile from FS you're

00:39:33,550 --> 00:39:38,380
you're asking for the ability to read

00:39:35,920 --> 00:39:39,820
files as a capability you're asking for

00:39:38,380 --> 00:39:43,810
the permissions to read files and

00:39:39,820 --> 00:39:46,300
actually at the resolver level we can

00:39:43,810 --> 00:39:49,030
have a security model because you could

00:39:46,300 --> 00:39:50,740
just throw on importing from FS and say

00:39:49,030 --> 00:39:53,220
no you're not allowed to do porn efforts

00:39:50,740 --> 00:39:56,710
so pretreat imports in JavaScript as

00:39:53,220 --> 00:39:57,820
capabilities then we're getting

00:39:56,710 --> 00:40:00,460
something similar to that let some

00:39:57,820 --> 00:40:02,470
security model where we've now

00:40:00,460 --> 00:40:05,320
determined modules and Bijlee into

00:40:02,470 --> 00:40:07,300
secured star boxes and we can control

00:40:05,320 --> 00:40:09,250
the network capabilities we know that

00:40:07,300 --> 00:40:11,020
secrets from organizational secrets go

00:40:09,250 --> 00:40:12,610
on even if those packages of modules are

00:40:11,020 --> 00:40:15,210
completely hacked they weren't

00:40:12,610 --> 00:40:18,220
necessarily have access to these things

00:40:15,210 --> 00:40:19,960
so I want to briefly just go through a

00:40:18,220 --> 00:40:22,870
very very clean - dino-man

00:40:19,960 --> 00:40:25,150
wise these security models and II know

00:40:22,870 --> 00:40:27,490
it does something like this you run on a

00:40:25,150 --> 00:40:31,690
server and as soon as you run that soon

00:40:27,490 --> 00:40:33,070
you get a question this is app is

00:40:31,690 --> 00:40:35,080
requesting network access

00:40:33,070 --> 00:40:38,410
do you want to groans it need a few

00:40:35,080 --> 00:40:41,380
options and only once you accept that is

00:40:38,410 --> 00:40:44,740
the is the server it hasn't touched the

00:40:41,380 --> 00:40:48,040
server and then later on it requests

00:40:44,740 --> 00:40:52,300
read access to a file and you have to

00:40:48,040 --> 00:40:54,550
Grove that reacts s as well when concern

00:40:52,300 --> 00:40:57,490
with that is it assumes that the user is

00:40:54,550 --> 00:40:58,870
around to interact with the person what

00:40:57,490 --> 00:41:01,180
if they're not is your server just

00:40:58,870 --> 00:41:02,310
Brennan hiding old home so I'm not so

00:41:01,180 --> 00:41:04,450
sure about that

00:41:02,310 --> 00:41:06,070
there is another way to grow these

00:41:04,450 --> 00:41:08,800
permissions on start up with three flags

00:41:06,070 --> 00:41:11,530
which seems better but again is hold on

00:41:08,800 --> 00:41:12,730
location Commission's so that's great if

00:41:11,530 --> 00:41:14,320
you're running an application but you

00:41:12,730 --> 00:41:17,200
know it's just going to take in text and

00:41:14,320 --> 00:41:18,730
spit out text but as soon as you've got

00:41:17,200 --> 00:41:20,170
any interesting application it's

00:41:18,730 --> 00:41:22,420
probably gonna have a lot of permissions

00:41:20,170 --> 00:41:24,070
and then you've got that third party

00:41:22,420 --> 00:41:26,740
code problem that any third party code

00:41:24,070 --> 00:41:28,270
is can have those same permissions so

00:41:26,740 --> 00:41:29,470
any third party in this example if

00:41:28,270 --> 00:41:30,970
you're running is everybody current it

00:41:29,470 --> 00:41:34,390
also has the ability to talk to that

00:41:30,970 --> 00:41:37,660
server of this one C has a really

00:41:34,390 --> 00:41:39,880
interesting capabilities model where

00:41:37,660 --> 00:41:44,490
when you run the process you have to

00:41:39,880 --> 00:41:47,730
specify explicitly which directories are

00:41:44,490 --> 00:41:49,320
access and once those directories were

00:41:47,730 --> 00:41:52,650
given access the idea is that you have

00:41:49,320 --> 00:41:54,950
these special references that represent

00:41:52,650 --> 00:41:58,320
those directories and this example the

00:41:54,950 --> 00:42:01,740
key word on the score FD and temp

00:41:58,320 --> 00:42:03,170
underscore FD which I think the the

00:42:01,740 --> 00:42:05,730
ultimate goal is to treat them like

00:42:03,170 --> 00:42:07,710
references to in JavaScript you could

00:42:05,730 --> 00:42:09,630
think of them like symbols that ideally

00:42:07,710 --> 00:42:11,190
wouldn't be for Janelle I think right

00:42:09,630 --> 00:42:12,890
now they actually are Portugal but I

00:42:11,190 --> 00:42:15,750
think the plan is for them not to be and

00:42:12,890 --> 00:42:18,210
then when you load a file you say here's

00:42:15,750 --> 00:42:20,910
my special symbol for this folder and a

00:42:18,210 --> 00:42:22,020
temp folder that I got access to and the

00:42:20,910 --> 00:42:23,820
only way you can get access to that

00:42:22,020 --> 00:42:25,830
symbol will suppose you only get access

00:42:23,820 --> 00:42:27,060
to if you've given the symbol so if you

00:42:25,830 --> 00:42:28,619
don't have the symbol you don't have

00:42:27,060 --> 00:42:30,720
access so you can't just pour just

00:42:28,619 --> 00:42:32,369
string it and make it up you have to get

00:42:30,720 --> 00:42:34,290
access to that symbol and then you have

00:42:32,369 --> 00:42:36,090
access to load relative to that folder

00:42:34,290 --> 00:42:38,070
so it's really nice because it's this

00:42:36,090 --> 00:42:39,540
model by binding if you've got if you've

00:42:38,070 --> 00:42:40,830
got access the finding or someone else

00:42:39,540 --> 00:42:43,490
is giving you access to the buy me

00:42:40,830 --> 00:42:46,490
you've got access to the folder and

00:42:43,490 --> 00:42:50,460
these are unique reportable references

00:42:46,490 --> 00:42:52,890
so the principles are as I said we're

00:42:50,460 --> 00:42:55,740
not all suggesting changing the default

00:42:52,890 --> 00:42:57,660
experience emerges not suggesting that

00:42:55,740 --> 00:43:00,270
we we changed the way we're doing things

00:42:57,660 --> 00:43:02,190
today not suggesting that notice

00:43:00,270 --> 00:43:06,119
overnight influence a capabilities-based

00:43:02,190 --> 00:43:08,609
security model rather the question is we

00:43:06,119 --> 00:43:10,890
have no J's as a project is the steering

00:43:08,609 --> 00:43:12,990
force of JavaScript that does not run in

00:43:10,890 --> 00:43:16,710
the browser and JavaScript in browser

00:43:12,990 --> 00:43:18,900
for that matter can we use our power to

00:43:16,710 --> 00:43:22,100
try and steer this ecosystem in a

00:43:18,900 --> 00:43:24,390
unofficial direction and for those

00:43:22,100 --> 00:43:27,180
companies for those organizations that

00:43:24,390 --> 00:43:29,160
are interested in getting these security

00:43:27,180 --> 00:43:31,170
properties which a lot of companies are

00:43:29,160 --> 00:43:34,680
interested in what can we do it as a

00:43:31,170 --> 00:43:36,570
project to help start to move in those

00:43:34,680 --> 00:43:38,609
directions that they can potentially

00:43:36,570 --> 00:43:40,380
wrap or instead of I would say no it's

00:43:38,609 --> 00:43:44,130
not secure we're gonna go through our

00:43:40,380 --> 00:43:46,109
project like say for something you know

00:43:44,130 --> 00:43:48,290
what can we do to try and provide those

00:43:46,109 --> 00:43:51,060
properties through night itself and

00:43:48,290 --> 00:43:53,700
unblock that work allow that work to

00:43:51,060 --> 00:43:56,280
happen on top of node not getting right

00:43:53,700 --> 00:43:57,830
into core but just on top and user land

00:43:56,280 --> 00:44:00,480
and just luck

00:43:57,830 --> 00:44:03,390
well we could already do import

00:44:00,480 --> 00:44:06,120
permissions through loaders loaders give

00:44:03,390 --> 00:44:07,710
the ability to hook the resolver which

00:44:06,120 --> 00:44:10,080
means you can provide a custom in

00:44:07,710 --> 00:44:12,030
offense instance but every module every

00:44:10,080 --> 00:44:14,640
package can get its own FS with its own

00:44:12,030 --> 00:44:16,380
script permissions well we could do

00:44:14,640 --> 00:44:17,820
something like likewise ease capability

00:44:16,380 --> 00:44:20,630
were you passing it but that's a bit

00:44:17,820 --> 00:44:23,340
more drastic but the idea is you could

00:44:20,630 --> 00:44:25,860
you could wrap these API up through a

00:44:23,340 --> 00:44:28,490
loader in third-party elsewhere in New

00:44:25,860 --> 00:44:31,400
Zealand and you would be able to get

00:44:28,490 --> 00:44:33,630
these import most security properties

00:44:31,400 --> 00:44:36,270
that can restrict permission so you

00:44:33,630 --> 00:44:41,520
could say this package only has

00:44:36,270 --> 00:44:43,260
permission to the network but it doesn't

00:44:41,520 --> 00:44:45,510
have permissions to the file system and

00:44:43,260 --> 00:44:48,120
it doesn't get FS and you could just

00:44:45,510 --> 00:44:50,670
restrict it and this is a huge wide open

00:44:48,120 --> 00:44:52,410
space to explore but if we can start

00:44:50,670 --> 00:44:53,820
exploring it in New Zealand I think

00:44:52,410 --> 00:44:55,370
would be very interesting to see where

00:44:53,820 --> 00:44:58,350
things go

00:44:55,370 --> 00:45:00,660
here's a sort of a complete Mike of

00:44:58,350 --> 00:45:03,080
some ideas again this is literally just

00:45:00,660 --> 00:45:05,400
like darling downloads and it's terrible

00:45:03,080 --> 00:45:07,830
but if you can control the imports of a

00:45:05,400 --> 00:45:10,500
package so you say the local project can

00:45:07,830 --> 00:45:12,990
only import FS and some third-party

00:45:10,500 --> 00:45:15,090
package there nobody has read access at

00:45:12,990 --> 00:45:17,550
the current folder and a third-party

00:45:15,090 --> 00:45:20,670
package doesn't is not permitted any

00:45:17,550 --> 00:45:22,350
inputs and you restrict imports by just

00:45:20,670 --> 00:45:24,540
saying packages are only allowed to

00:45:22,350 --> 00:45:27,060
import what they explicitly declared as

00:45:24,540 --> 00:45:28,680
dependencies in their package JSON so

00:45:27,060 --> 00:45:29,850
there's a whole lot of problems to think

00:45:28,680 --> 00:45:34,560
about this stuff but I think would be

00:45:29,850 --> 00:45:36,000
worthwhile first to to think about neat

00:45:34,560 --> 00:45:39,750
new work that can build in New Zealand

00:45:36,000 --> 00:45:45,500
that attempts to stuff if they place

00:45:39,750 --> 00:45:53,430
where all those IQ written down so i

00:45:45,500 --> 00:45:56,160
don't think i i've seen it a few people

00:45:53,430 --> 00:45:57,660
have suggested things like this so i

00:45:56,160 --> 00:46:00,600
think someone suggested a package JSON

00:45:57,660 --> 00:46:02,430
schema for this kind of stuff but i'm

00:46:00,600 --> 00:46:04,320
hoping that we can get in places

00:46:02,430 --> 00:46:06,510
together where we where we can discuss

00:46:04,320 --> 00:46:08,780
it because it's known as the time to be

00:46:06,510 --> 00:46:11,130
experimenting so that we can start to

00:46:08,780 --> 00:46:14,070
you know grow these models out

00:46:11,130 --> 00:46:16,770
it's really giving them we already have

00:46:14,070 --> 00:46:19,020
the loader or a command they could be an

00:46:16,770 --> 00:46:22,640
easy open source project that if it's

00:46:19,020 --> 00:46:22,640
all these IDs from the user man yes

00:46:23,500 --> 00:46:28,299
so the idea is to restrict only imports

00:46:26,109 --> 00:46:29,740
to maybe what's in the dependencies of

00:46:28,299 --> 00:46:31,660
the package.json so you treat the

00:46:29,740 --> 00:46:34,960
package.json dependencies as a sort of

00:46:31,660 --> 00:46:37,480
the layer word says I only import these

00:46:34,960 --> 00:46:41,289
packages and then maybe think about what

00:46:37,480 --> 00:46:43,059
hope missions you have and then I was

00:46:41,289 --> 00:46:45,490
thinking sort of package management time

00:46:43,059 --> 00:46:47,410
so as you install a package you kind of

00:46:45,490 --> 00:46:49,809
verify the permissions then as opposed

00:46:47,410 --> 00:46:51,880
to during runtime like Dino or you could

00:46:49,809 --> 00:46:53,589
say I can see what these packages are

00:46:51,880 --> 00:46:55,630
depending on it and then you have some

00:46:53,589 --> 00:47:00,369
kind of policy file that's treated like

00:46:55,630 --> 00:47:02,890
a lock file where the you you sort of

00:47:00,369 --> 00:47:04,780
know what each package is accessing so

00:47:02,890 --> 00:47:07,660
that if it tries to change in security

00:47:04,780 --> 00:47:12,130
policy on an upgrade path then you can

00:47:07,660 --> 00:47:14,200
be prompted for it on uninstall and and

00:47:12,130 --> 00:47:16,960
then read prompts and again these are

00:47:14,200 --> 00:47:18,670
this huge usability spaces here lots of

00:47:16,960 --> 00:47:20,410
space to make horrible complicated

00:47:18,670 --> 00:47:22,990
things that are paid to use but that's

00:47:20,410 --> 00:47:25,150
why it should be that's where we should

00:47:22,990 --> 00:47:27,160
be exploring and prototyping and and

00:47:25,150 --> 00:47:30,400
seeing what what ideas we can come up

00:47:27,160 --> 00:47:32,049
with in these phases again maybe in

00:47:30,400 --> 00:47:36,099
small times not the right time but I

00:47:32,049 --> 00:47:37,839
kind of like the permissions I don't

00:47:36,099 --> 00:47:41,619
know but we should be having these

00:47:37,839 --> 00:47:44,579
discussions so it's a summarized if we

00:47:41,619 --> 00:47:47,500
can deprecated it's a global the process

00:47:44,579 --> 00:47:51,010
and do not have to infer the global

00:47:47,500 --> 00:47:53,020
capabilities then if you in your company

00:47:51,010 --> 00:47:54,849
want security and you can execute on a

00:47:53,020 --> 00:47:57,430
personal inconsistent first and global

00:47:54,849 --> 00:47:59,950
if we accept that we've lost the war on

00:47:57,430 --> 00:48:02,289
time is and just allow people to just

00:47:59,950 --> 00:48:03,910
focus on the ability to not get for

00:48:02,289 --> 00:48:05,200
itself and assume that people are going

00:48:03,910 --> 00:48:08,440
to be able to use my perspective

00:48:05,200 --> 00:48:11,349
discover them then we can play around

00:48:08,440 --> 00:48:14,230
with imports and permission models on

00:48:11,349 --> 00:48:15,760
top of that and that's that gives us a

00:48:14,230 --> 00:48:16,930
conference of watching the security so

00:48:15,760 --> 00:48:19,660
that's a complete picture

00:48:16,930 --> 00:48:21,190
that's plugging all the leaks and in

00:48:19,660 --> 00:48:24,099
please if you can see another link let

00:48:21,190 --> 00:48:25,510
me know it but you know security coming

00:48:24,099 --> 00:48:27,279
from the direction that agaric have

00:48:25,510 --> 00:48:29,529
worked out that is that is the young

00:48:27,279 --> 00:48:32,020
that isn't a complete picture or modulus

00:48:29,529 --> 00:48:34,510
period so that's remember being very

00:48:32,020 --> 00:48:36,490
close to these strong security

00:48:34,510 --> 00:48:37,839
properties so you can't access anything

00:48:36,490 --> 00:48:41,289
else that's

00:48:37,839 --> 00:48:43,299
and then you get package security models

00:48:41,289 --> 00:48:45,010
so just as an example what what's

00:48:43,299 --> 00:48:49,599
münster so how does this mitigate the

00:48:45,010 --> 00:48:51,700
note1 its security well if you think

00:48:49,599 --> 00:48:53,470
right now we have this every dependency

00:48:51,700 --> 00:48:57,789
in your app has full access to

00:48:53,470 --> 00:48:59,650
everything then we can potentially get a

00:48:57,789 --> 00:49:01,900
model where as those permissions are

00:48:59,650 --> 00:49:04,210
reduced and in this example the first

00:49:01,900 --> 00:49:07,750
dependency only has access to fetch

00:49:04,210 --> 00:49:10,000
which means yes it could possibly steal

00:49:07,750 --> 00:49:11,829
organizational secrets if it is act or

00:49:10,000 --> 00:49:14,170
any maintainer of that dependency in

00:49:11,829 --> 00:49:16,089
fact adept to no longer has any

00:49:14,170 --> 00:49:18,460
collisions with sisters play posture and

00:49:16,089 --> 00:49:20,289
it doesn't mean to access anything so I

00:49:18,460 --> 00:49:22,210
don't care if it's act if it gets back

00:49:20,289 --> 00:49:25,299
to calling damage worried my server

00:49:22,210 --> 00:49:28,480
damage my company depth 3 only has

00:49:25,299 --> 00:49:30,940
access to read from the local the local

00:49:28,480 --> 00:49:32,500
folder so if it gets hacked yes it can

00:49:30,940 --> 00:49:33,789
read sensitive information but it

00:49:32,500 --> 00:49:37,569
doesn't have network access or

00:49:33,789 --> 00:49:38,770
side-wheel access so I can't exfiltrated

00:49:37,569 --> 00:49:41,349
other secrets so I don't actually care

00:49:38,770 --> 00:49:43,420
about 3 girls hearts if that ball gets

00:49:41,349 --> 00:49:46,000
hacked it's got access to fetch and the

00:49:43,420 --> 00:49:47,829
read so if that stays on or anyone

00:49:46,000 --> 00:49:50,049
because I can share organizational

00:49:47,829 --> 00:49:51,940
secrets and n5 has write access so that

00:49:50,049 --> 00:49:54,460
can probably become a full vertical

00:49:51,940 --> 00:49:58,000
backdoor situation but we've gone from

00:49:54,460 --> 00:49:59,890
having 5 dependencies that immediately

00:49:58,000 --> 00:50:01,779
get read access if they were hacked to

00:49:59,890 --> 00:50:05,349
just having one dependence in at least

00:50:01,779 --> 00:50:07,420
root access and two dependencies that

00:50:05,349 --> 00:50:10,210
leads to the possible lots of sets of

00:50:07,420 --> 00:50:12,339
information and that's the idea of a

00:50:10,210 --> 00:50:14,020
reduced attack surface and mitigating

00:50:12,339 --> 00:50:16,599
that risk because we've reduced the risk

00:50:14,020 --> 00:50:17,980
and it's a lot of work to get a small

00:50:16,599 --> 00:50:19,569
improvement but the idea is if we can

00:50:17,980 --> 00:50:21,430
have lots of dependencies looking like

00:50:19,569 --> 00:50:23,260
dependencies to divinities three there

00:50:21,430 --> 00:50:25,690
then we can get a very secure

00:50:23,260 --> 00:50:28,180
application model and to reiterate

00:50:25,690 --> 00:50:30,730
elicit from inning which is this is not

00:50:28,180 --> 00:50:34,839
about adding these kind of features

00:50:30,730 --> 00:50:36,579
today it's about saying let's let's

00:50:34,839 --> 00:50:38,380
enable these these things and then

00:50:36,579 --> 00:50:40,900
experiment in user line and see we can

00:50:38,380 --> 00:50:42,849
go without having to say if you want to

00:50:40,900 --> 00:50:45,279
secure JavaScript you've got a fourth

00:50:42,849 --> 00:50:47,740
yuka system you've got the project

00:50:45,279 --> 00:50:50,270
what can we let's try and experiment on

00:50:47,740 --> 00:50:52,040
top of load to do these things and

00:50:50,270 --> 00:50:54,770
work towards a new long-term future this

00:50:52,040 --> 00:50:59,570
is very much many years to be something

00:50:54,770 --> 00:51:01,160
that happens so lumen longer is every

00:50:59,570 --> 00:51:03,910
package of target you've only got a few

00:51:01,160 --> 00:51:54,950
packages that have high permissions and

00:51:03,910 --> 00:52:00,460
maintain their targets we cannot afford

00:51:54,950 --> 00:52:10,810
at this point in time to reduce the

00:52:00,460 --> 00:52:17,660
throughput of note in any form it's very

00:52:10,810 --> 00:52:23,420
very hot pads in and on applications the

00:52:17,660 --> 00:52:27,260
process next do you remember what the

00:52:23,420 --> 00:52:29,859
numbers were still each this was on a

00:52:27,260 --> 00:52:37,910
micro benchmark it was just a success

00:52:29,859 --> 00:52:41,270
didn't slow down because that is the

00:52:37,910 --> 00:52:47,119
hottest but processor that stick is

00:52:41,270 --> 00:52:59,900
using everywhere and it's that is kind

00:52:47,119 --> 00:53:03,740
of it's that's so as I say this is a

00:52:59,900 --> 00:53:05,660
space where in the JavaScript space

00:53:03,740 --> 00:53:07,250
we're either gonna have to rely on other

00:53:05,660 --> 00:53:11,540
service side JavaScript projects

00:53:07,250 --> 00:53:12,980
ferreting work here or because the

00:53:11,540 --> 00:53:16,490
browser will take the first step and

00:53:12,980 --> 00:53:18,530
node.js has an opportunity here to lead

00:53:16,490 --> 00:53:21,500
the ecosystem without fragmenting the

00:53:18,530 --> 00:53:26,270
ecosystem and slowly and on security

00:53:21,500 --> 00:53:29,270
potentially and as I say we've got

00:53:26,270 --> 00:53:31,670
frozen entrances we just need to follow

00:53:29,270 --> 00:53:34,910
through with some kind of frozen Globo

00:53:31,670 --> 00:53:37,250
ID here and and then deprecated leveled

00:53:34,910 --> 00:53:37,790
up process and that is it that's all I'm

00:53:37,250 --> 00:53:42,650
asking

00:53:37,790 --> 00:53:44,569
so Mattel's argument is exactly and if

00:53:42,650 --> 00:53:47,230
anyone wants to hack on unloaders the

00:53:44,569 --> 00:53:47,230
two Commission's

00:53:48,520 --> 00:53:53,349
so then in anything else to talk about

00:53:58,750 --> 00:54:04,569
it's still a significant performance eat

00:54:05,140 --> 00:54:12,410
so you know these model to be successful

00:54:09,559 --> 00:54:15,589
accessing frozen objects should not have

00:54:12,410 --> 00:54:19,250
any performance cost and at this point

00:54:15,589 --> 00:54:23,150
in time is pretty drastic it improved

00:54:19,250 --> 00:54:29,540
but is still there and it's you know

00:54:23,150 --> 00:54:47,599
it's you demoed them the model where I

00:54:29,540 --> 00:54:48,829
want to reach he's not security not

00:54:47,599 --> 00:54:51,500
suggesting making it the default

00:54:48,829 --> 00:55:01,250
reasoning the person in physics is not

00:54:51,500 --> 00:55:04,010
seen it's just say in fact he is we need

00:55:01,250 --> 00:55:06,880
to make it viable for companies to make

00:55:04,010 --> 00:55:06,880
those defaults

00:55:07,770 --> 00:55:10,920
[Music]

00:55:38,240 --> 00:55:45,540
and but I hope that this has given you

00:55:43,920 --> 00:55:48,000
something to think about in terms of the

00:55:45,540 --> 00:55:51,750
security model that we could enable

00:55:48,000 --> 00:55:54,480
people to build on top of it and I think

00:55:51,750 --> 00:55:56,720
it's that point that we're so close to

00:55:54,480 --> 00:56:01,130
it and if we just do this one thing

00:55:56,720 --> 00:56:01,130
because if we can open that door to

00:56:13,160 --> 00:56:21,660
solution it's not necessarily there does

00:56:20,160 --> 00:56:33,720
anyone else wanna ask any questions

00:56:21,660 --> 00:56:44,010
about these models when you talk about

00:56:33,720 --> 00:56:46,730
the deprecation of process targeting

00:56:44,010 --> 00:56:50,400
here is we want uses who are writing

00:56:46,730 --> 00:56:52,619
atmosphere modules in their chance not

00:56:50,400 --> 00:56:54,599
to assume that the global process is

00:56:52,619 --> 00:56:56,280
available so what we're doing is

00:56:54,599 --> 00:56:58,260
remaining and available we're making it

00:56:56,280 --> 00:57:00,359
a get to it gives you a warning it says

00:56:58,260 --> 00:57:02,099
please don't use the global top versus

00:57:00,359 --> 00:57:04,109
now if we do anything less than that

00:57:02,099 --> 00:57:04,740
people will use it they will publish it

00:57:04,109 --> 00:57:06,300
7:00 p.m.

00:57:04,740 --> 00:57:08,160
it'll be so ingrained and they'll be

00:57:06,300 --> 00:57:09,599
able to change it this is why browsers

00:57:08,160 --> 00:57:11,970
coin the duck to any type of security

00:57:09,599 --> 00:57:13,770
models like this because they have all

00:57:11,970 --> 00:57:15,390
these levels and these things that

00:57:13,770 --> 00:57:17,520
cannot be deprecated and we have an

00:57:15,390 --> 00:57:19,680
opportunity in the switch to echo strip

00:57:17,520 --> 00:57:21,599
modules where we can specifically

00:57:19,680 --> 00:57:24,119
deprecated leveled up versus which is

00:57:21,599 --> 00:57:27,970
the only thing we need to remove to to

00:57:24,119 --> 00:57:30,440
get to get into that kind of let's face

00:57:27,970 --> 00:57:51,859
but let's continue this discussion

00:57:30,440 --> 00:57:54,200
further to should be the same in other

00:57:51,859 --> 00:57:55,280
words does this mean that we should as

00:57:54,200 --> 00:57:59,210
soon as possible

00:57:55,280 --> 00:58:02,180
introduce an alternative API to get next

00:57:59,210 --> 00:58:03,890
week presumably also whether this dog

00:58:02,180 --> 00:58:09,950
has been using renamed this next stick

00:58:03,890 --> 00:58:13,010
to it actually you Brits so you say

00:58:09,950 --> 00:58:14,750
treated as a separate API was limping

00:58:13,010 --> 00:58:19,099
and then if we did different get at that

00:58:14,750 --> 00:58:34,000
time we deprecated something I feel like

00:58:19,099 --> 00:58:34,000
we should change but there's no

00:59:11,319 --> 00:59:21,040
questions I don't have any questions no

00:59:23,020 --> 00:59:26,930
yeah I don't see any questions there so

00:59:25,099 --> 00:59:30,050
we'll pull it there and thanks everyone

00:59:26,930 --> 00:59:32,060
please check further with with anyone

00:59:30,050 --> 00:59:34,200
want to screen for myself about this

00:59:32,060 --> 00:59:36,710
we're here to discuss

00:59:34,200 --> 00:59:36,710

YouTube URL: https://www.youtube.com/watch?v=WGOhdVE9S6M


