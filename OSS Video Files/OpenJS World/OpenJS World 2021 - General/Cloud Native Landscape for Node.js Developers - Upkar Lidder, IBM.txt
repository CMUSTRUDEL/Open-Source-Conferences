Title: Cloud Native Landscape for Node.js Developers - Upkar Lidder, IBM
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - General
Description: 
	Cloud Native Landscape for Node.js Developers - Upkar Lidder, IBM

Get the lay of the Kubernetes land as a Node.js developer. Did you know there are more than 1500 projects listed on the CNCF landscape! It can be quickly get overwhelming if you havenâ€™t developed for Cloud Native before. The talk will give a high level overview of Cloud Native Computing and then dive into tools and tips you can use to get started right after the talk. - what is Cloud Native and why should you care - develop modern applications using Cloud Native - some practical starting tips and common pitfalls to be aware of We will start with some of the basic Cloud Native tenets. Upkar will show you how to take your Node.js application from your laptops to containers on K8s platform using continuous deployment and continuous integration. We will end the talk with how you can get started today and some practical advise on architecting your Node.js application for Cloud Native.

Join the speaker for live Q&A on Slack: Thursday, June 3 from 11:40 - 12:00 PDT / 20:40 - 21:00 CEST, channel - #openjs_world-general
Captions: 
	00:00:00,399 --> 00:00:04,080
hello welcome to the session on cloud

00:00:02,320 --> 00:00:05,520
native for node.js developers

00:00:04,080 --> 00:00:07,520
my name is luka litter and i'm a

00:00:05,520 --> 00:00:09,040
developer advocate at ibm

00:00:07,520 --> 00:00:12,480
this is a beginner session on cloud

00:00:09,040 --> 00:00:14,240
native curated for node.js developers

00:00:12,480 --> 00:00:15,839
so before we dive into what cloud native

00:00:14,240 --> 00:00:16,560
is and what it means to you as a node

00:00:15,839 --> 00:00:18,800
developer

00:00:16,560 --> 00:00:20,720
you may have some questions you may be

00:00:18,800 --> 00:00:21,359
asking what makes a cloud native

00:00:20,720 --> 00:00:23,199
application

00:00:21,359 --> 00:00:24,800
cloud native if you're using

00:00:23,199 --> 00:00:27,519
microservices

00:00:24,800 --> 00:00:29,119
you may already be doing some parts of

00:00:27,519 --> 00:00:31,279
cloud native

00:00:29,119 --> 00:00:32,880
is cloud native just a buzzword and why

00:00:31,279 --> 00:00:34,399
should you care about it

00:00:32,880 --> 00:00:35,840
we'll hopefully be able to answer some

00:00:34,399 --> 00:00:37,840
of these questions by the end of this

00:00:35,840 --> 00:00:40,079
talk

00:00:37,840 --> 00:00:42,160
a cloud native application consists of

00:00:40,079 --> 00:00:44,399
discrete reusable components

00:00:42,160 --> 00:00:47,120
known as microservices that are designed

00:00:44,399 --> 00:00:50,160
to integrate into any cloud environment

00:00:47,120 --> 00:00:51,760
this is the definition from ibm

00:00:50,160 --> 00:00:54,000
i've highlighted some of the keywords

00:00:51,760 --> 00:00:57,039
that i want you to pay attention to

00:00:54,000 --> 00:00:58,480
discrete reusable microservices

00:00:57,039 --> 00:01:01,039
and integration into any cloud

00:00:58,480 --> 00:01:03,600
environment i would like to point out

00:01:01,039 --> 00:01:05,360
that these words or concepts are not new

00:01:03,600 --> 00:01:07,600
as developers we like to write our code

00:01:05,360 --> 00:01:11,119
in smaller reusable chunks

00:01:07,600 --> 00:01:11,119
that can be tested independently

00:01:11,760 --> 00:01:15,040
so that was a very high level definition

00:01:14,080 --> 00:01:18,400
of cloud native

00:01:15,040 --> 00:01:18,400
let's dive a little bit deeper

00:01:18,479 --> 00:01:22,640
all native cloud native applications are

00:01:20,560 --> 00:01:24,479
built with cloud in mind

00:01:22,640 --> 00:01:26,320
this means from the time you start

00:01:24,479 --> 00:01:28,720
gathering requirements creating user

00:01:26,320 --> 00:01:30,400
stories to architecting the application

00:01:28,720 --> 00:01:32,000
you're already thinking about how the

00:01:30,400 --> 00:01:33,840
different pieces will fit together in

00:01:32,000 --> 00:01:35,439
the cloud native world

00:01:33,840 --> 00:01:39,040
cloud deployment in a cloud native

00:01:35,439 --> 00:01:39,040
application is not an afterthought

00:01:39,119 --> 00:01:44,720
microservices is not a new concept

00:01:42,240 --> 00:01:47,360
cloud native application uses a

00:01:44,720 --> 00:01:49,119
microservices architecture

00:01:47,360 --> 00:01:50,720
with cloud native it is likely the way

00:01:49,119 --> 00:01:52,560
of doing things

00:01:50,720 --> 00:01:54,079
breaking your app into microservices is

00:01:52,560 --> 00:01:57,040
a natural way to architect your

00:01:54,079 --> 00:01:58,479
application for the cloud native world

00:01:57,040 --> 00:02:01,119
since the application is built using

00:01:58,479 --> 00:02:02,719
microservices it is highly scalable and

00:02:01,119 --> 00:02:04,719
dynamic

00:02:02,719 --> 00:02:06,399
think of it as a plug-and-play model

00:02:04,719 --> 00:02:07,200
where different components can be scaled

00:02:06,399 --> 00:02:10,640
up and down

00:02:07,200 --> 00:02:11,840
and also replaced with other components

00:02:10,640 --> 00:02:14,640
it's a little bit more involved than

00:02:11,840 --> 00:02:16,080
that but that's the idea

00:02:14,640 --> 00:02:18,160
with the developing standards in the

00:02:16,080 --> 00:02:19,840
cloud native landscape applications

00:02:18,160 --> 00:02:22,959
generally use managed and hosted

00:02:19,840 --> 00:02:24,800
services on the cloud

00:02:22,959 --> 00:02:26,720
another key characteristic of cloud

00:02:24,800 --> 00:02:28,239
native application is that devops is

00:02:26,720 --> 00:02:29,520
built into the application from the

00:02:28,239 --> 00:02:31,599
ground up

00:02:29,520 --> 00:02:34,959
developers and operations teams work

00:02:31,599 --> 00:02:34,959
together to set up the environment

00:02:35,120 --> 00:02:39,280
these microservices are generally built

00:02:37,440 --> 00:02:40,959
on containers

00:02:39,280 --> 00:02:42,400
containerization helps realize the

00:02:40,959 --> 00:02:45,519
various benefits of cloud native

00:02:42,400 --> 00:02:45,519
application development

00:02:46,480 --> 00:02:49,680
so now you know have a little bit more

00:02:47,920 --> 00:02:53,120
understanding about cloud native

00:02:49,680 --> 00:02:53,120
let's talk about microservices

00:02:54,000 --> 00:02:57,599
if you're creating a microservices-based

00:02:55,840 --> 00:02:58,959
architecture you're more most likely

00:02:57,599 --> 00:03:00,480
splitting your application up into

00:02:58,959 --> 00:03:02,800
multiple services

00:03:00,480 --> 00:03:04,959
where each service is loosely coupled

00:03:02,800 --> 00:03:05,840
with each other but is quite independent

00:03:04,959 --> 00:03:08,239
and isolated

00:03:05,840 --> 00:03:11,120
isolated from each other and together

00:03:08,239 --> 00:03:12,480
they make up the complete application

00:03:11,120 --> 00:03:14,319
in the cloud native world these

00:03:12,480 --> 00:03:15,760
microservices are packaged into what we

00:03:14,319 --> 00:03:17,599
call containers

00:03:15,760 --> 00:03:19,200
containers are packages of your software

00:03:17,599 --> 00:03:20,080
that include everything that is needed

00:03:19,200 --> 00:03:25,120
to run it

00:03:20,080 --> 00:03:25,120
including code dependencies binaries etc

00:03:26,400 --> 00:03:29,680
so why do we want to use microservices

00:03:28,159 --> 00:03:32,239
architecture in the cloud native world

00:03:29,680 --> 00:03:33,920
what benefits do we get out of it

00:03:32,239 --> 00:03:36,239
with each microservice small and

00:03:33,920 --> 00:03:38,080
independent developers are able to focus

00:03:36,239 --> 00:03:38,720
on their area of code instead of having

00:03:38,080 --> 00:03:40,720
to manage

00:03:38,720 --> 00:03:42,159
all parts of the application this

00:03:40,720 --> 00:03:44,239
results in increased developer

00:03:42,159 --> 00:03:47,120
productivity

00:03:44,239 --> 00:03:48,959
secondly with services isolated from

00:03:47,120 --> 00:03:51,200
each other the failures are bugs are

00:03:48,959 --> 00:03:53,439
easier to debug in some cases

00:03:51,200 --> 00:03:54,959
however as the number of services or

00:03:53,439 --> 00:03:57,439
microservices grow

00:03:54,959 --> 00:03:58,239
so does the complexity a microservice

00:03:57,439 --> 00:04:00,080
architecture

00:03:58,239 --> 00:04:01,760
not done correctly can lead to a lot

00:04:00,080 --> 00:04:04,239
more problems than a well-managed

00:04:01,760 --> 00:04:04,239
monolith

00:04:05,599 --> 00:04:09,040
microservices together with containers

00:04:07,519 --> 00:04:11,200
provide maximum flexibility and

00:04:09,040 --> 00:04:12,640
portability in a multi-cloud environment

00:04:11,200 --> 00:04:14,319
where you can pick up your service from

00:04:12,640 --> 00:04:16,160
one cloud environment and port it into

00:04:14,319 --> 00:04:18,000
another easily

00:04:16,160 --> 00:04:20,000
finally as a result of breaking the

00:04:18,000 --> 00:04:21,919
application into multiple services

00:04:20,000 --> 00:04:24,240
developers are able to update or replace

00:04:21,919 --> 00:04:27,120
the services with minimal downtime

00:04:24,240 --> 00:04:29,040
to the application so just to summarize

00:04:27,120 --> 00:04:31,040
microservices are loosely coupled

00:04:29,040 --> 00:04:33,040
but remain independent allowing

00:04:31,040 --> 00:04:34,639
incremental and automated

00:04:33,040 --> 00:04:37,840
improvement of an application without

00:04:34,639 --> 00:04:37,840
causing any downtime

00:04:39,199 --> 00:04:42,479
now you might ask what are some of the

00:04:40,639 --> 00:04:44,080
downsides of the market microservices

00:04:42,479 --> 00:04:46,000
architecture

00:04:44,080 --> 00:04:47,280
and if you know if it's so cool why

00:04:46,000 --> 00:04:49,120
isn't everybody doing it

00:04:47,280 --> 00:04:50,720
so while it's definitely more suited for

00:04:49,120 --> 00:04:52,960
cloud native application

00:04:50,720 --> 00:04:54,560
uh they also create the necessity of

00:04:52,960 --> 00:04:56,639
managing more elements

00:04:54,560 --> 00:04:58,639
so rather than one large application now

00:04:56,639 --> 00:05:02,080
it becomes necessary to manage

00:04:58,639 --> 00:05:03,680
far more small discrete services

00:05:02,080 --> 00:05:05,360
microservices architecture needs

00:05:03,680 --> 00:05:07,520
different tools in order to monitor

00:05:05,360 --> 00:05:10,639
monitor all of these different services

00:05:07,520 --> 00:05:12,400
this presents a learning curve finally

00:05:10,639 --> 00:05:15,039
while microservices provide a path to

00:05:12,400 --> 00:05:16,880
rapid development and flexibility

00:05:15,039 --> 00:05:19,440
they do require a change in culture and

00:05:16,880 --> 00:05:21,520
mindset so it is not too uncommon to

00:05:19,440 --> 00:05:23,680
build and release multiple times a week

00:05:21,520 --> 00:05:26,720
or even multiple times a day in the

00:05:23,680 --> 00:05:26,720
microservices world

00:05:28,560 --> 00:05:31,199
all right let's talk a little bit about

00:05:30,000 --> 00:05:32,320
something called the 12-factor

00:05:31,199 --> 00:05:33,600
application because i think it's

00:05:32,320 --> 00:05:35,199
important in the

00:05:33,600 --> 00:05:37,120
not only the cloud native space but in

00:05:35,199 --> 00:05:39,360
general as well to know about this

00:05:37,120 --> 00:05:41,120
so the 12 factor application is a

00:05:39,360 --> 00:05:42,960
methodology for building software as a

00:05:41,120 --> 00:05:44,800
service applications

00:05:42,960 --> 00:05:46,000
it encompasses the best practices in

00:05:44,800 --> 00:05:48,639
building a complex sas

00:05:46,000 --> 00:05:50,160
application so all these factors like i

00:05:48,639 --> 00:05:52,240
said apply to the cloud-native

00:05:50,160 --> 00:05:53,919
application development

00:05:52,240 --> 00:05:56,080
and there are a lot of tools in the

00:05:53,919 --> 00:05:58,880
cloud native world that make

00:05:56,080 --> 00:06:00,639
some of this easier let's look at some

00:05:58,880 --> 00:06:01,680
of these factors so

00:06:00,639 --> 00:06:06,160
also by the way you can get more

00:06:01,680 --> 00:06:08,720
information at 12factor.net

00:06:06,160 --> 00:06:10,000
so the first factor is code base which

00:06:08,720 --> 00:06:12,319
simply states that

00:06:10,000 --> 00:06:13,360
all code be tracked in a version control

00:06:12,319 --> 00:06:17,039
system

00:06:13,360 --> 00:06:17,039
such as git or subversion

00:06:17,360 --> 00:06:21,199
let's look at a couple of other ones as

00:06:18,720 --> 00:06:22,639
well so the next one is dependencies the

00:06:21,199 --> 00:06:23,919
dependencies factor states that

00:06:22,639 --> 00:06:27,759
application must declare

00:06:23,919 --> 00:06:30,240
all dependencies completely and exactly

00:06:27,759 --> 00:06:31,360
via some sort of declarative manifest

00:06:30,240 --> 00:06:33,520
file

00:06:31,360 --> 00:06:35,440
right furthermore the full and explicit

00:06:33,520 --> 00:06:37,120
dependency specification

00:06:35,440 --> 00:06:39,039
should be applied uniformly to all

00:06:37,120 --> 00:06:43,039
environments like production test

00:06:39,039 --> 00:06:43,039
integration development etc

00:06:44,400 --> 00:06:48,720
next config factor states that all

00:06:46,960 --> 00:06:49,199
configuration must be stored outside of

00:06:48,720 --> 00:06:51,599
code

00:06:49,199 --> 00:06:54,720
and there is a strict separation of

00:06:51,599 --> 00:06:56,240
concern between code and configuration

00:06:54,720 --> 00:06:57,440
and the reason being your code should

00:06:56,240 --> 00:06:58,160
stay the same between different

00:06:57,440 --> 00:06:59,840
environments

00:06:58,160 --> 00:07:01,280
whereas your configuration might vary

00:06:59,840 --> 00:07:04,400
between test

00:07:01,280 --> 00:07:04,400
and development for example

00:07:05,680 --> 00:07:09,440
the build release run factor states that

00:07:08,400 --> 00:07:12,560
the 12

00:07:09,440 --> 00:07:14,400
a 12 factor app uses strict separation

00:07:12,560 --> 00:07:17,199
between the build

00:07:14,400 --> 00:07:17,919
release and run stages and with

00:07:17,199 --> 00:07:21,360
containers

00:07:17,919 --> 00:07:23,520
again they facilitate this

00:07:21,360 --> 00:07:24,400
build release and run stages separately

00:07:23,520 --> 00:07:26,080
because you're building

00:07:24,400 --> 00:07:27,599
when you're building your image that's

00:07:26,080 --> 00:07:28,479
the build phase and when you're

00:07:27,599 --> 00:07:30,000
deploying

00:07:28,479 --> 00:07:31,840
that's the release phase and then

00:07:30,000 --> 00:07:34,479
something like kubernetes will

00:07:31,840 --> 00:07:36,240
which we'll get to in a minute then

00:07:34,479 --> 00:07:39,199
separate out the run stage from your

00:07:36,240 --> 00:07:39,199
release stage as well

00:07:40,479 --> 00:07:44,479
okay i'm going to skip a couple of these

00:07:41,840 --> 00:07:46,479
let's talk about dev prod parity so dev

00:07:44,479 --> 00:07:48,479
pro parity reduces the gap between

00:07:46,479 --> 00:07:50,560
development and production environments

00:07:48,479 --> 00:07:52,400
a developer may write code and have it

00:07:50,560 --> 00:07:53,680
have it deployed within hours or minutes

00:07:52,400 --> 00:07:56,720
after doing that

00:07:53,680 --> 00:07:58,319
right the parity just means uh you know

00:07:56,720 --> 00:08:00,160
that you're not concerned that something

00:07:58,319 --> 00:08:01,759
works on your development box but then

00:08:00,160 --> 00:08:04,479
doesn't work on production

00:08:01,759 --> 00:08:06,080
so to make the mass similar as possible

00:08:04,479 --> 00:08:08,720
and finally looking at logs

00:08:06,080 --> 00:08:10,240
um the logs factor say is to treat logs

00:08:08,720 --> 00:08:11,919
as event streams

00:08:10,240 --> 00:08:13,440
right so logs have no beginning or end

00:08:11,919 --> 00:08:14,400
but they're flowing continuously as a

00:08:13,440 --> 00:08:17,199
stream

00:08:14,400 --> 00:08:18,720
and um there is a mechanism in the cloud

00:08:17,199 --> 00:08:19,840
native world

00:08:18,720 --> 00:08:21,680
when you're using something like

00:08:19,840 --> 00:08:23,280
kubernetes to then capture all of these

00:08:21,680 --> 00:08:26,560
streaming logs

00:08:23,280 --> 00:08:28,000
um and in that way the production

00:08:26,560 --> 00:08:30,240
or the platform that that your

00:08:28,000 --> 00:08:31,759
application did gets deployed on

00:08:30,240 --> 00:08:34,479
is responsible for aggregating and

00:08:31,759 --> 00:08:36,560
storing logs and not your code base

00:08:34,479 --> 00:08:38,080
and we'll go into logging again at the

00:08:36,560 --> 00:08:40,640
end of the presentation

00:08:38,080 --> 00:08:42,080
so the next question might be uh how do

00:08:40,640 --> 00:08:42,880
you convert your existing applications

00:08:42,080 --> 00:08:44,480
to be more

00:08:42,880 --> 00:08:46,399
cloud native so there are a couple of

00:08:44,480 --> 00:08:47,120
different tasks involved as listed on

00:08:46,399 --> 00:08:49,600
this slide

00:08:47,120 --> 00:08:50,720
so it all starts out but or even before

00:08:49,600 --> 00:08:51,600
development there's a couple of

00:08:50,720 --> 00:08:53,120
activities but let's

00:08:51,600 --> 00:08:54,880
start with development or sorry

00:08:53,120 --> 00:08:56,560
deployment this all starts with

00:08:54,880 --> 00:08:57,920
deployment when you're

00:08:56,560 --> 00:08:59,360
when you're building applications for

00:08:57,920 --> 00:09:00,959
cloud native you need to package your

00:08:59,360 --> 00:09:02,480
code independencies in a way

00:09:00,959 --> 00:09:03,920
that you're able to run any cloud

00:09:02,480 --> 00:09:05,040
platform if you remember that was the

00:09:03,920 --> 00:09:07,120
definition

00:09:05,040 --> 00:09:08,160
uh that we had for cloud native and the

00:09:07,120 --> 00:09:11,279
container technology

00:09:08,160 --> 00:09:12,880
make that easy secondly cloud native in

00:09:11,279 --> 00:09:15,040
the cloud native world the

00:09:12,880 --> 00:09:16,320
you know there's concept of self-healing

00:09:15,040 --> 00:09:17,920
or checking for the health of an

00:09:16,320 --> 00:09:21,120
application

00:09:17,920 --> 00:09:22,160
so if you're writing your nodejs app it

00:09:21,120 --> 00:09:24,560
is a good practice

00:09:22,160 --> 00:09:25,600
to write certain health checks uh and

00:09:24,560 --> 00:09:26,399
implement health checks in your

00:09:25,600 --> 00:09:28,160
application

00:09:26,399 --> 00:09:30,320
and we'll look at what these health

00:09:28,160 --> 00:09:31,279
checks are uh two common examples are

00:09:30,320 --> 00:09:34,560
liveliness and

00:09:31,279 --> 00:09:37,200
readiness and then we come down to

00:09:34,560 --> 00:09:38,560
monitoring so you need to be able to

00:09:37,200 --> 00:09:39,920
monitor

00:09:38,560 --> 00:09:42,320
and collect metrics from your

00:09:39,920 --> 00:09:43,519
applications so that the platform can

00:09:42,320 --> 00:09:46,800
check your application

00:09:43,519 --> 00:09:48,480
over time and finally we'll talk a

00:09:46,800 --> 00:09:51,519
little bit about logging as well

00:09:48,480 --> 00:09:53,200
so as you can see um

00:09:51,519 --> 00:09:55,839
you know you may already be doing some

00:09:53,200 --> 00:09:58,640
of this in your application development

00:09:55,839 --> 00:09:59,920
but these are some of the key tenets of

00:09:58,640 --> 00:10:03,680
cloud native

00:09:59,920 --> 00:10:04,800
world so on the screen right now on the

00:10:03,680 --> 00:10:06,240
left hand side

00:10:04,800 --> 00:10:07,680
this should be familiar to you if you're

00:10:06,240 --> 00:10:10,720
a node.js developer this is a

00:10:07,680 --> 00:10:11,120
package.json file package.json file

00:10:10,720 --> 00:10:13,920
found

00:10:11,120 --> 00:10:15,360
in typical express apps so we talked

00:10:13,920 --> 00:10:18,240
about using containers to package your

00:10:15,360 --> 00:10:20,399
code libraries in any dependencies

00:10:18,240 --> 00:10:22,560
docker is a popular tool for creating

00:10:20,399 --> 00:10:25,600
and running linux containers

00:10:22,560 --> 00:10:27,839
the the docker file on the right inside

00:10:25,600 --> 00:10:28,640
has a series of steps on how to build an

00:10:27,839 --> 00:10:31,279
image for

00:10:28,640 --> 00:10:32,320
that express application and run a

00:10:31,279 --> 00:10:35,040
container

00:10:32,320 --> 00:10:37,600
from that image so let's get let's go

00:10:35,040 --> 00:10:39,600
through this file

00:10:37,600 --> 00:10:40,800
so first i define a base image from

00:10:39,600 --> 00:10:43,519
which i'm creating

00:10:40,800 --> 00:10:45,279
this new image for my application there

00:10:43,519 --> 00:10:46,320
are a number of benefits in using a base

00:10:45,279 --> 00:10:48,560
image like this

00:10:46,320 --> 00:10:49,680
first assuming the base image comes from

00:10:48,560 --> 00:10:51,120
a credible source

00:10:49,680 --> 00:10:54,000
the developer doesn't have to worry too

00:10:51,120 --> 00:10:57,920
much about the base os security

00:10:54,000 --> 00:10:59,680
second the base image is usually

00:10:57,920 --> 00:11:00,079
optimized and minimized so it takes less

00:10:59,680 --> 00:11:02,800
space

00:11:00,079 --> 00:11:04,079
and storage and is faster to run next we

00:11:02,800 --> 00:11:07,680
define the working directory for the

00:11:04,079 --> 00:11:07,680
next set of instructions in this file

00:11:08,800 --> 00:11:14,240
we then copy the dependencies and other

00:11:11,680 --> 00:11:16,399
file source files into the image

00:11:14,240 --> 00:11:18,640
next we run npm install in order to

00:11:16,399 --> 00:11:20,640
install these dependencies

00:11:18,640 --> 00:11:22,079
after this we copy the server and public

00:11:20,640 --> 00:11:24,640
called code into

00:11:22,079 --> 00:11:24,640
our image

00:11:27,279 --> 00:11:30,240
after this we set some environment

00:11:28,560 --> 00:11:31,279
variables including the production

00:11:30,240 --> 00:11:33,680
environment

00:11:31,279 --> 00:11:35,279
and the port we want our app to run on

00:11:33,680 --> 00:11:39,200
finally after exposing

00:11:35,279 --> 00:11:40,959
port um 3000 we issue the npm

00:11:39,200 --> 00:11:42,399
start command which you can see comes

00:11:40,959 --> 00:11:44,720
directly from

00:11:42,399 --> 00:11:45,839
the package.json file to start our

00:11:44,720 --> 00:11:47,360
application

00:11:45,839 --> 00:11:48,880
now this is one way to write a docker

00:11:47,360 --> 00:11:50,160
file there are a number of other ways

00:11:48,880 --> 00:11:51,040
you could have i could have done this as

00:11:50,160 --> 00:11:54,320
well

00:11:51,040 --> 00:11:54,320
but this is a good start for us

00:11:55,600 --> 00:11:59,440
all right so speaking of deployment a

00:11:57,680 --> 00:12:00,160
little bit more i'm sorry if the text is

00:11:59,440 --> 00:12:03,519
a little bit

00:12:00,160 --> 00:12:05,120
hard to see excuse me

00:12:03,519 --> 00:12:07,920
now that you have a docker image you can

00:12:05,120 --> 00:12:09,760
deploy where does it actually live

00:12:07,920 --> 00:12:11,040
so you have to run it somewhere and this

00:12:09,760 --> 00:12:12,880
is where kubernetes come in so

00:12:11,040 --> 00:12:14,240
kubernetes is an open source container

00:12:12,880 --> 00:12:16,560
orchestration platform

00:12:14,240 --> 00:12:18,880
that automates deployment management and

00:12:16,560 --> 00:12:20,800
scaling of applications

00:12:18,880 --> 00:12:22,399
clusters are the building blocks of

00:12:20,800 --> 00:12:23,839
kubernetes architecture

00:12:22,399 --> 00:12:25,920
okay so the clusters are made up of

00:12:23,839 --> 00:12:29,279
nodes each of which represents

00:12:25,920 --> 00:12:29,839
a single host each cluster consists of

00:12:29,279 --> 00:12:32,160
multiple

00:12:29,839 --> 00:12:33,920
or may consist of multiple worker nodes

00:12:32,160 --> 00:12:35,839
that deploy run and manage your

00:12:33,920 --> 00:12:39,120
containerized application

00:12:35,839 --> 00:12:40,880
okay you if you have uh

00:12:39,120 --> 00:12:42,560
if you have read about kubernetes you

00:12:40,880 --> 00:12:44,079
may have read about pods

00:12:42,560 --> 00:12:46,000
so pods are groups of one or more

00:12:44,079 --> 00:12:49,120
containers that share the same

00:12:46,000 --> 00:12:50,320
compute resources network and memory uh

00:12:49,120 --> 00:12:52,480
they also

00:12:50,320 --> 00:12:54,800
they're also sort of the smallest unit

00:12:52,480 --> 00:12:57,519
of scalability in kubernetes

00:12:54,800 --> 00:12:59,040
um so that means if a container and a

00:12:57,519 --> 00:12:59,600
pod is getting more traffic than it can

00:12:59,040 --> 00:13:01,360
handle

00:12:59,600 --> 00:13:03,040
kubernetes will replicate the pod to

00:13:01,360 --> 00:13:05,200
other nodes in the cluster if you ask it

00:13:03,040 --> 00:13:08,079
to do so

00:13:05,200 --> 00:13:08,959
and then from the part the next level up

00:13:08,079 --> 00:13:10,959
is the deployment

00:13:08,959 --> 00:13:12,320
a deployment provides declarative

00:13:10,959 --> 00:13:15,279
updates for

00:13:12,320 --> 00:13:16,399
pods all right so there are two code

00:13:15,279 --> 00:13:19,279
snippets on the slide

00:13:16,399 --> 00:13:20,560
the one on the left is a declaration of

00:13:19,279 --> 00:13:23,519
a deployment

00:13:20,560 --> 00:13:24,639
you can see the kind of deployment and

00:13:23,519 --> 00:13:27,600
then we label

00:13:24,639 --> 00:13:28,560
our deployment replicas replicas of one

00:13:27,600 --> 00:13:31,120
just means

00:13:28,560 --> 00:13:31,920
that i just want one instance of the

00:13:31,120 --> 00:13:35,440
application

00:13:31,920 --> 00:13:38,079
running in my cluster and then

00:13:35,440 --> 00:13:39,680
the container section the specs and the

00:13:38,079 --> 00:13:42,639
spec

00:13:39,680 --> 00:13:44,320
tells kubernetes where to get the

00:13:42,639 --> 00:13:46,000
container image from so in this case you

00:13:44,320 --> 00:13:48,639
can see

00:13:46,000 --> 00:13:49,600
the image is coming from us.icr.io

00:13:48,639 --> 00:13:52,160
that's the

00:13:49,600 --> 00:13:52,959
image container registry on ibm with a

00:13:52,160 --> 00:13:56,160
namespace

00:13:52,959 --> 00:13:57,600
and then the name and uh the tag of the

00:13:56,160 --> 00:13:59,839
image

00:13:57,600 --> 00:14:02,160
there's an there's an additional

00:13:59,839 --> 00:14:03,279
quotation mark in the slide i'll remove

00:14:02,160 --> 00:14:05,279
that later

00:14:03,279 --> 00:14:07,360
um and then there's an there's something

00:14:05,279 --> 00:14:09,519
called an image pull secret so if your

00:14:07,360 --> 00:14:10,880
container registry is private which icr

00:14:09,519 --> 00:14:13,760
is then you have to tell it

00:14:10,880 --> 00:14:14,959
how to get access to that image registry

00:14:13,760 --> 00:14:17,680
and you do that through

00:14:14,959 --> 00:14:19,199
image pull secret so that's what a

00:14:17,680 --> 00:14:20,720
typical deployment will look like

00:14:19,199 --> 00:14:22,800
and then on the right hand side you have

00:14:20,720 --> 00:14:24,880
something called a service so service is

00:14:22,800 --> 00:14:28,240
how deployments

00:14:24,880 --> 00:14:30,320
are exposed to the internet if you

00:14:28,240 --> 00:14:31,920
do not have a service you're not able to

00:14:30,320 --> 00:14:32,720
reach your deployment from the app from

00:14:31,920 --> 00:14:35,279
outside

00:14:32,720 --> 00:14:36,800
the cluster so in this case you can see

00:14:35,279 --> 00:14:41,040
i'm defining a service

00:14:36,800 --> 00:14:43,120
and the service is exposing port 4000

00:14:41,040 --> 00:14:44,800
outside the cluster now there are three

00:14:43,120 --> 00:14:46,480
kinds of services and we don't go

00:14:44,800 --> 00:14:48,639
i don't go through it here but there's

00:14:46,480 --> 00:14:52,240
node port load balancer

00:14:48,639 --> 00:14:53,680
and cluster ip node port is

00:14:52,240 --> 00:14:56,000
sometimes used for development and

00:14:53,680 --> 00:14:59,040
that's where you can directly hit

00:14:56,000 --> 00:15:00,480
the service through the opened port

00:14:59,040 --> 00:15:02,079
it is not very secure and not

00:15:00,480 --> 00:15:04,160
recommended for production

00:15:02,079 --> 00:15:06,240
load balancer is another one where every

00:15:04,160 --> 00:15:10,000
service gets a different load balancer

00:15:06,240 --> 00:15:12,880
in front of your cluster

00:15:10,000 --> 00:15:15,120
and you know though it's easy to use it

00:15:12,880 --> 00:15:16,720
can get expensive to

00:15:15,120 --> 00:15:18,639
put a load balancer in front of each and

00:15:16,720 --> 00:15:22,160
every service and the third one is

00:15:18,639 --> 00:15:23,920
cluster ip i've seen that used most in

00:15:22,160 --> 00:15:25,199
in the work that i've done and that's

00:15:23,920 --> 00:15:27,440
where you have something like an

00:15:25,199 --> 00:15:29,040
ingress gateway in front of your cluster

00:15:27,440 --> 00:15:32,160
and which routes

00:15:29,040 --> 00:15:33,120
traffic to the right service based on

00:15:32,160 --> 00:15:35,440
some rules

00:15:33,120 --> 00:15:36,320
cluster ip service is available and

00:15:35,440 --> 00:15:39,120
accessible from

00:15:36,320 --> 00:15:42,240
inside this inside the cluster through

00:15:39,120 --> 00:15:42,240
the ingress gateway

00:15:42,639 --> 00:15:45,920
as you can tell there's there's tons to

00:15:44,160 --> 00:15:47,920
learn about in kubernetes

00:15:45,920 --> 00:15:49,759
but again i don't want to you know get

00:15:47,920 --> 00:15:51,279
in the weeds in this talk

00:15:49,759 --> 00:15:52,880
i want to keep it more high level and

00:15:51,279 --> 00:15:54,880
give you a flavor

00:15:52,880 --> 00:15:56,800
of what you might run into when you when

00:15:54,880 --> 00:16:00,160
you um you know when you want to go

00:15:56,800 --> 00:16:00,160
cloud native with your application

00:16:01,519 --> 00:16:04,480
all right so let's talk about health

00:16:02,639 --> 00:16:05,680
checks so you know you've got you've

00:16:04,480 --> 00:16:08,399
dockerized

00:16:05,680 --> 00:16:10,480
containerized your node.js application

00:16:08,399 --> 00:16:11,920
you've got a deployment file

00:16:10,480 --> 00:16:13,680
that specified a deployment and then

00:16:11,920 --> 00:16:16,000
you've got another yaml file

00:16:13,680 --> 00:16:16,800
that defined the service and by the way

00:16:16,000 --> 00:16:18,800
all of

00:16:16,800 --> 00:16:20,240
the let me go back a little bit all of

00:16:18,800 --> 00:16:22,079
this code here is written in this

00:16:20,240 --> 00:16:23,680
language called yaml

00:16:22,079 --> 00:16:25,920
you either love it or you hate it but

00:16:23,680 --> 00:16:29,440
this is this is what we get to use in

00:16:25,920 --> 00:16:30,880
at least in kubernetes all right so hell

00:16:29,440 --> 00:16:32,639
check so now that you've got your app up

00:16:30,880 --> 00:16:35,519
and running

00:16:32,639 --> 00:16:36,079
how do you utilize the different uh sort

00:16:35,519 --> 00:16:39,120
of healing

00:16:36,079 --> 00:16:41,600
self-healing features in kubernetes

00:16:39,120 --> 00:16:43,279
so hell checks are a way for kubernetes

00:16:41,600 --> 00:16:44,160
to check if your application is ready

00:16:43,279 --> 00:16:46,800
and healthy

00:16:44,160 --> 00:16:49,120
those mean two different things when a

00:16:46,800 --> 00:16:52,160
container fails kubernetes can restart

00:16:49,120 --> 00:16:53,839
it or replace it automatically

00:16:52,160 --> 00:16:55,279
it can also take down containers that

00:16:53,839 --> 00:16:56,399
don't meet your health check

00:16:55,279 --> 00:16:58,560
requirements

00:16:56,399 --> 00:17:00,320
so there are three types of health

00:16:58,560 --> 00:17:00,800
checks the first one is running a

00:17:00,320 --> 00:17:02,480
command

00:17:00,800 --> 00:17:03,680
this is useful if your application runs

00:17:02,480 --> 00:17:05,360
for a long period of time in the

00:17:03,680 --> 00:17:07,120
background like a bad job

00:17:05,360 --> 00:17:09,120
and doesn't provide an end point to the

00:17:07,120 --> 00:17:11,280
external world outside your cluster

00:17:09,120 --> 00:17:12,559
so you can sort of probe and run this

00:17:11,280 --> 00:17:15,839
command and see what the

00:17:12,559 --> 00:17:16,880
the um the output or result of the

00:17:15,839 --> 00:17:19,600
command just

00:17:16,880 --> 00:17:20,959
to to save your services you know alive

00:17:19,600 --> 00:17:23,919
or not

00:17:20,959 --> 00:17:25,839
uh second is http probe and this is

00:17:23,919 --> 00:17:26,720
useful if your application can expose an

00:17:25,839 --> 00:17:30,000
endpoint that

00:17:26,720 --> 00:17:31,840
can that accepts an http get request and

00:17:30,000 --> 00:17:35,200
since this talk is for node.js

00:17:31,840 --> 00:17:38,080
ecosystem and developers i i would guess

00:17:35,200 --> 00:17:41,120
this is the more popular kind of

00:17:38,080 --> 00:17:43,360
or type of health check or probe

00:17:41,120 --> 00:17:45,120
and the last one is a tcp pro and this

00:17:43,360 --> 00:17:46,880
one uses a

00:17:45,120 --> 00:17:49,919
tcp socket to check the health of the

00:17:46,880 --> 00:17:52,960
system now how are these used

00:17:49,919 --> 00:17:54,799
so there are two major use cases

00:17:52,960 --> 00:17:56,799
the first one is liveliness and

00:17:54,799 --> 00:17:58,400
liveliness basically says

00:17:56,799 --> 00:18:00,559
tells kubernetes to restart the

00:17:58,400 --> 00:18:02,160
container when the liveliness endpoint

00:18:00,559 --> 00:18:03,600
does not respond

00:18:02,160 --> 00:18:05,360
and that indicates the application is

00:18:03,600 --> 00:18:06,320
down so kubernetes is going to try and

00:18:05,360 --> 00:18:08,240
restart

00:18:06,320 --> 00:18:09,520
and the second one is readiness and

00:18:08,240 --> 00:18:11,840
readiness

00:18:09,520 --> 00:18:12,880
basically says do not send any traffic

00:18:11,840 --> 00:18:14,880
to this application

00:18:12,880 --> 00:18:16,799
until it is ready now this is especially

00:18:14,880 --> 00:18:18,480
important when we scale up or down

00:18:16,799 --> 00:18:20,559
as we don't want to route traffic to a

00:18:18,480 --> 00:18:24,880
pot which is not completely ready

00:18:20,559 --> 00:18:24,880
so what do these things look like um

00:18:25,200 --> 00:18:30,400
so here's what a typical

00:18:28,720 --> 00:18:32,240
yaml file for each of them might look

00:18:30,400 --> 00:18:33,280
like let's focus on the http get on the

00:18:32,240 --> 00:18:36,160
right hand side

00:18:33,280 --> 00:18:36,960
so you can see i'm defining my health or

00:18:36,160 --> 00:18:39,520
my lively

00:18:36,960 --> 00:18:40,160
my liveliness probe as an http get

00:18:39,520 --> 00:18:43,840
endpoint

00:18:40,160 --> 00:18:46,960
of forward slash health on port 8080

00:18:43,840 --> 00:18:48,480
and then i have an initial delay seconds

00:18:46,960 --> 00:18:50,880
of three and period seconds of

00:18:48,480 --> 00:18:53,200
three as well so initial delay second

00:18:50,880 --> 00:18:54,240
controls how quickly to start checking

00:18:53,200 --> 00:18:56,799
right so you want to give your

00:18:54,240 --> 00:18:59,039
application enough time to come up

00:18:56,799 --> 00:19:01,440
and then period seconds checks how off

00:18:59,039 --> 00:19:01,840
or tells kubernetes how often to check

00:19:01,440 --> 00:19:03,600
it

00:19:01,840 --> 00:19:05,280
so you're saying wait for three seconds

00:19:03,600 --> 00:19:08,080
and then check every three seconds

00:19:05,280 --> 00:19:08,799
to see if the application is up or not

00:19:08,080 --> 00:19:10,320
all right

00:19:08,799 --> 00:19:11,520
and there are other things as well which

00:19:10,320 --> 00:19:13,120
you haven't defined here so there's

00:19:11,520 --> 00:19:14,720
something called failure threshold

00:19:13,120 --> 00:19:17,039
that controls how many times the probe

00:19:14,720 --> 00:19:18,240
needs to fail before the container will

00:19:17,039 --> 00:19:20,080
restart

00:19:18,240 --> 00:19:23,760
and then on your code side you would

00:19:20,080 --> 00:19:25,520
define your endpoint

00:19:23,760 --> 00:19:27,120
inside your node.js so you would have a

00:19:25,520 --> 00:19:28,559
route if you're using express for

00:19:27,120 --> 00:19:30,640
example of health

00:19:28,559 --> 00:19:31,600
which can return anything with a status

00:19:30,640 --> 00:19:34,960
of 200.

00:19:31,600 --> 00:19:38,480
a lot of time people return status okay

00:19:34,960 --> 00:19:39,200
just a simple json let's talk about

00:19:38,480 --> 00:19:42,240
monitoring

00:19:39,200 --> 00:19:43,520
so it is important to export key metrics

00:19:42,240 --> 00:19:45,039
from a container that you need to

00:19:43,520 --> 00:19:46,559
understand and track the health of your

00:19:45,039 --> 00:19:49,600
application and this might look

00:19:46,559 --> 00:19:50,880
different for different apps

00:19:49,600 --> 00:19:52,640
but a really good place to start

00:19:50,880 --> 00:19:55,200
monitoring solution

00:19:52,640 --> 00:19:57,120
is by by implementing google's four

00:19:55,200 --> 00:19:58,400
golden signals

00:19:57,120 --> 00:20:01,039
there's a nice paper on this if you want

00:19:58,400 --> 00:20:02,960
to go read it in their sre pdf

00:20:01,039 --> 00:20:06,559
so the golden signals are latency

00:20:02,960 --> 00:20:08,240
traffic errors and saturation so latency

00:20:06,559 --> 00:20:09,120
is the time it takes to service a

00:20:08,240 --> 00:20:11,919
request

00:20:09,120 --> 00:20:13,679
right that's sort of your response time

00:20:11,919 --> 00:20:14,320
traffic is the amount of activity in the

00:20:13,679 --> 00:20:15,679
application

00:20:14,320 --> 00:20:17,760
and you definitely want to keep an eye

00:20:15,679 --> 00:20:19,679
on that as well

00:20:17,760 --> 00:20:21,600
errors are the rate of at which the

00:20:19,679 --> 00:20:24,000
requests are failing

00:20:21,600 --> 00:20:25,200
the obvious one and saturation is how

00:20:24,000 --> 00:20:27,600
full your services

00:20:25,200 --> 00:20:28,880
now that's kind of hard to measure you

00:20:27,600 --> 00:20:32,880
can do for example

00:20:28,880 --> 00:20:36,799
cpu capacity or memory or disk io

00:20:32,880 --> 00:20:39,760
to measure the saturation

00:20:36,799 --> 00:20:41,039
and the de facto tool is uh for for

00:20:39,760 --> 00:20:44,000
doing metrics on

00:20:41,039 --> 00:20:45,760
something like kubernetes is prominent

00:20:44,000 --> 00:20:48,799
prometheus excuse me

00:20:45,760 --> 00:20:50,640
so prometheus is very popular it defines

00:20:48,799 --> 00:20:53,200
a set of metrics you should export and

00:20:50,640 --> 00:20:54,799
gives you the ability to add additional

00:20:53,200 --> 00:20:56,480
metrics that are very specific to your

00:20:54,799 --> 00:20:57,760
application and important to your

00:20:56,480 --> 00:21:01,200
business

00:20:57,760 --> 00:21:03,360
here's an example sorry

00:21:01,200 --> 00:21:04,960
here's an example of what prometheus

00:21:03,360 --> 00:21:05,280
gives through out of the box so you can

00:21:04,960 --> 00:21:07,840
see

00:21:05,280 --> 00:21:09,520
it's giving you a number of stats on

00:21:07,840 --> 00:21:12,720
memory and cpu

00:21:09,520 --> 00:21:15,120
right and it's easy enough to install

00:21:12,720 --> 00:21:17,840
um in your application or in your

00:21:15,120 --> 00:21:17,840
cluster i should say

00:21:19,919 --> 00:21:24,000
all right let's talk about logging so in

00:21:22,080 --> 00:21:26,400
a container in container development

00:21:24,000 --> 00:21:27,280
writing logs out to disk generally does

00:21:26,400 --> 00:21:29,280
not make sense

00:21:27,280 --> 00:21:31,120
and it's not a good idea because of the

00:21:29,280 --> 00:21:32,880
extra steps needed to make the logs

00:21:31,120 --> 00:21:35,760
available outside the container

00:21:32,880 --> 00:21:37,120
right so remember containers are formal

00:21:35,760 --> 00:21:39,360
once you

00:21:37,120 --> 00:21:41,039
you know for whatever reason if your pod

00:21:39,360 --> 00:21:43,679
dies because of

00:21:41,039 --> 00:21:44,720
some exception in the application or

00:21:43,679 --> 00:21:46,880
otherwise

00:21:44,720 --> 00:21:48,799
uh all of your logs will be lost right

00:21:46,880 --> 00:21:52,240
and remember we also talked about how

00:21:48,799 --> 00:21:55,280
in the 12-factor app it specifies logs

00:21:52,240 --> 00:21:57,440
should be uh streaming right and don't

00:21:55,280 --> 00:21:59,600
have a beginning or an end

00:21:57,440 --> 00:22:01,200
so a couple of tips here so first is

00:21:59,600 --> 00:22:03,120
always log out to standard output and

00:22:01,200 --> 00:22:04,960
standard error

00:22:03,120 --> 00:22:06,400
kubernetes as a platform understands

00:22:04,960 --> 00:22:07,919
those things and knows how to pick up

00:22:06,400 --> 00:22:09,919
logs from there

00:22:07,919 --> 00:22:12,880
second is never never store logs in your

00:22:09,919 --> 00:22:16,159
container as we said they are temporary

00:22:12,880 --> 00:22:18,320
and then my personal tip is use pinot

00:22:16,159 --> 00:22:20,559
for structured json logging and there's

00:22:18,320 --> 00:22:21,760
an example given at the bottom here so

00:22:20,559 --> 00:22:23,679
you have some nice

00:22:21,760 --> 00:22:25,520
nicely formatted logs coming out of your

00:22:23,679 --> 00:22:29,080
system

00:22:25,520 --> 00:22:30,799
and by the way um there is an article on

00:22:29,080 --> 00:22:32,960
developer.ibm.com that

00:22:30,799 --> 00:22:34,080
michael dawson wrote uh he's with red

00:22:32,960 --> 00:22:37,360
hat now

00:22:34,080 --> 00:22:40,960
and that article describes

00:22:37,360 --> 00:22:42,799
some other you know some other

00:22:40,960 --> 00:22:44,400
characteristics of cloud native

00:22:42,799 --> 00:22:48,240
applications that are important to

00:22:44,400 --> 00:22:48,240
understand as a node.js developer

00:22:50,720 --> 00:22:53,600
all right so here are a couple of tools

00:22:52,080 --> 00:22:55,200
that i would suggest to look at when

00:22:53,600 --> 00:22:56,640
you're starting off on your cloud native

00:22:55,200 --> 00:22:59,840
journey

00:22:56,640 --> 00:23:00,960
with node.js so first is the ipm and red

00:22:59,840 --> 00:23:03,840
hat

00:23:00,960 --> 00:23:05,600
node.js reference architecture so the

00:23:03,840 --> 00:23:07,360
reference architecture talks about a

00:23:05,600 --> 00:23:10,880
number of different components including

00:23:07,360 --> 00:23:13,600
what frameworks to use template engines

00:23:10,880 --> 00:23:15,280
what you use for internationalization

00:23:13,600 --> 00:23:16,240
authorization authentication some of the

00:23:15,280 --> 00:23:20,000
best practices

00:23:16,240 --> 00:23:21,440
and the tools that the developers at red

00:23:20,000 --> 00:23:23,760
hat and ibm use on

00:23:21,440 --> 00:23:24,640
in their daily work also talks about

00:23:23,760 --> 00:23:26,240
development

00:23:24,640 --> 00:23:27,520
operations there's a big section on

00:23:26,240 --> 00:23:28,240
health checks if you want to get more

00:23:27,520 --> 00:23:30,320
information

00:23:28,240 --> 00:23:33,280
as well as on metrics and there's also a

00:23:30,320 --> 00:23:35,679
workshop that you can go through

00:23:33,280 --> 00:23:37,679
to try out some of these things and i i

00:23:35,679 --> 00:23:39,760
should also mention that

00:23:37,679 --> 00:23:41,840
in this conference there they are also

00:23:39,760 --> 00:23:45,760
doing a workshop that i hope you attend

00:23:41,840 --> 00:23:48,720
that will go through converting a

00:23:45,760 --> 00:23:50,080
a simple node.js express or node and

00:23:48,720 --> 00:23:53,039
express.js application

00:23:50,080 --> 00:23:54,559
into something that can run in a cloud

00:23:53,039 --> 00:23:57,520
native landscape

00:23:54,559 --> 00:24:00,000
on on the cloud so it's a really good

00:23:57,520 --> 00:24:00,000
resource

00:24:00,320 --> 00:24:07,520
the other one is project audio

00:24:03,760 --> 00:24:09,120
and audio is a cli tool for developers

00:24:07,520 --> 00:24:10,159
who write build and deploy application

00:24:09,120 --> 00:24:12,640
on kubernetes

00:24:10,159 --> 00:24:14,640
and open shift so it gives you a lot of

00:24:12,640 --> 00:24:16,720
scaffolding out of the box

00:24:14,640 --> 00:24:18,799
that you know that you would you might

00:24:16,720 --> 00:24:22,320
not know about when you're starting off

00:24:18,799 --> 00:24:24,480
so it's nice to have that

00:24:22,320 --> 00:24:26,720
help in guardrails as you're starting

00:24:24,480 --> 00:24:29,679
off your journey in cloud native so

00:24:26,720 --> 00:24:30,480
highly recommend this tool as well ibm

00:24:29,679 --> 00:24:33,600
code engine

00:24:30,480 --> 00:24:34,880
is a new service from ibm

00:24:33,600 --> 00:24:37,200
a little bit of a shameless plug here

00:24:34,880 --> 00:24:40,400
but i think the team did a wonderful job

00:24:37,200 --> 00:24:42,480
and ibm code engine though built on and

00:24:40,400 --> 00:24:46,400
based on kubernetes and

00:24:42,480 --> 00:24:48,400
things like k native tecton and istio

00:24:46,400 --> 00:24:49,919
hides all of that and abstracts all of

00:24:48,400 --> 00:24:53,279
that away from the developer

00:24:49,919 --> 00:24:54,799
so you as a developer give your image or

00:24:53,279 --> 00:24:57,200
container or source code

00:24:54,799 --> 00:24:59,919
to code engine and it takes care of all

00:24:57,200 --> 00:25:03,679
of that you know scaling

00:24:59,919 --> 00:25:06,880
ssl tls security

00:25:03,679 --> 00:25:09,120
rolling updates all of those things are

00:25:06,880 --> 00:25:11,600
sort of taken care for you

00:25:09,120 --> 00:25:12,240
and it gives you a very simple ui and a

00:25:11,600 --> 00:25:14,640
cli

00:25:12,240 --> 00:25:17,200
to to go cloud native with the

00:25:14,640 --> 00:25:17,200
application

00:25:17,760 --> 00:25:21,760
i personally really enjoy these two

00:25:19,919 --> 00:25:23,840
tools the first one is called stern

00:25:21,760 --> 00:25:26,320
and i use it for logging in my local

00:25:23,840 --> 00:25:29,679
system so if i'm testing something on

00:25:26,320 --> 00:25:32,559
you know mini cube or mini shift um

00:25:29,679 --> 00:25:33,919
i have stern running to see what logs

00:25:32,559 --> 00:25:36,159
are flowing through

00:25:33,919 --> 00:25:37,520
and scaffold scaffold is the one i use

00:25:36,159 --> 00:25:40,720
to quickly deploy

00:25:37,520 --> 00:25:41,360
an application to to a kubernetes

00:25:40,720 --> 00:25:44,000
cluster

00:25:41,360 --> 00:25:45,760
so i have a test cluster where i deploy

00:25:44,000 --> 00:25:47,600
applications

00:25:45,760 --> 00:25:49,200
you know just to just to test it out or

00:25:47,600 --> 00:25:51,039
doing pocs and things like that

00:25:49,200 --> 00:25:52,880
and scaffolding gives me a really quick

00:25:51,039 --> 00:25:55,760
way to go from

00:25:52,880 --> 00:25:56,880
something like vs code to a deployed

00:25:55,760 --> 00:25:58,159
application so it gives you a

00:25:56,880 --> 00:26:01,520
development environment

00:25:58,159 --> 00:26:03,600
for uh kubernetes

00:26:01,520 --> 00:26:05,760
all right great that that was all for me

00:26:03,600 --> 00:26:07,679
um i hope you enjoyed the talk

00:26:05,760 --> 00:26:08,960
uh if you have any questions on cloud

00:26:07,679 --> 00:26:11,200
native um

00:26:08,960 --> 00:26:13,279
and how to how to move forward in that

00:26:11,200 --> 00:26:15,760
journey please do connect on linkedin

00:26:13,279 --> 00:26:17,520
or twitter i've got both of those um

00:26:15,760 --> 00:26:19,200
written out here on this slide

00:26:17,520 --> 00:26:20,640
as well as i've got a course on coursera

00:26:19,200 --> 00:26:21,279
called introduction to containers with

00:26:20,640 --> 00:26:23,600
docker

00:26:21,279 --> 00:26:25,279
kubernetes and openshift if you're

00:26:23,600 --> 00:26:26,640
interested to learn more do take that

00:26:25,279 --> 00:26:29,679
course you can audit it

00:26:26,640 --> 00:26:31,039
it's free and as you can see people have

00:26:29,679 --> 00:26:33,440
liked that course

00:26:31,039 --> 00:26:34,880
so let's stay in touch and thank you

00:26:33,440 --> 00:26:39,840
very much for

00:26:34,880 --> 00:26:39,840

YouTube URL: https://www.youtube.com/watch?v=oY-3hxgqWBk


