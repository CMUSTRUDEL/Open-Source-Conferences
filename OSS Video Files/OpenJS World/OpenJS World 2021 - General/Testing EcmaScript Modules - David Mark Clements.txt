Title: Testing EcmaScript Modules - David Mark Clements
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - General
Description: 
	Browsers and Node.js have gone through an evolution with regard to their module systems. In Node we're in the middle of a transition between CommonJS Modules (CJS), the original Node module system, and EcmaScript Modules (ESM), the TC39 specification for a JavaScript module system. As it stands, ESM is something of a black box and this can make testing a challenge. In this talk, David Mark Clements explains the testing strategy and supporting libraries he developed for testing ESM implementations, particular when it comes to mocking ESM dependencies.
Captions: 
	00:00:00,960 --> 00:00:07,759
hello and welcome to

00:00:03,439 --> 00:00:11,040
uh testing ecmascript modules in node.js

00:00:07,759 --> 00:00:14,320
with me david mark clements uh in the

00:00:11,040 --> 00:00:16,720
bottom left bottom right uh

00:00:14,320 --> 00:00:17,600
mistakes are staying in by the way uh in

00:00:16,720 --> 00:00:21,600
the bottom

00:00:17,600 --> 00:00:24,720
right of the slide um there's a url

00:00:21,600 --> 00:00:26,240
um you can use that short url if you

00:00:24,720 --> 00:00:27,920
don't have

00:00:26,240 --> 00:00:30,560
access to the link through some chat

00:00:27,920 --> 00:00:34,239
mechanism or or otherwise

00:00:30,560 --> 00:00:37,120
to load these slides and follow along

00:00:34,239 --> 00:00:38,480
if you so choose so we're going to be

00:00:37,120 --> 00:00:41,680
talking about

00:00:38,480 --> 00:00:44,960
ecmascript modules and actually testing

00:00:41,680 --> 00:00:47,760
ecmascript modules which are relatively

00:00:44,960 --> 00:00:49,120
new well they're not that new but

00:00:47,760 --> 00:00:53,120
they're relatively new in

00:00:49,120 --> 00:00:59,840
node speaking of node

00:00:53,120 --> 00:00:59,840
node now has two module systems um

00:01:00,960 --> 00:01:06,320
the original is uh referred to as common

00:01:04,720 --> 00:01:09,600
js

00:01:06,320 --> 00:01:10,000
it's a slight misnomer the uh at the

00:01:09,600 --> 00:01:11,680
time

00:01:10,000 --> 00:01:13,040
when node was going through a rapid

00:01:11,680 --> 00:01:16,640
phase of

00:01:13,040 --> 00:01:20,000
innovation and and and coming together

00:01:16,640 --> 00:01:23,040
uh it was uh there was no module

00:01:20,000 --> 00:01:24,640
specification for javascript

00:01:23,040 --> 00:01:26,479
ecmascript by the way is the official

00:01:24,640 --> 00:01:28,720
name of javascript if you didn't know

00:01:26,479 --> 00:01:28,720
that

00:01:28,960 --> 00:01:35,600
but there were some experimental uh

00:01:32,600 --> 00:01:38,479
specifications for something that was

00:01:35,600 --> 00:01:41,280
broadly referred to as common js

00:01:38,479 --> 00:01:42,880
require.js in the browser was was was

00:01:41,280 --> 00:01:45,840
related to that

00:01:42,880 --> 00:01:47,280
um but whereas require.js uh the

00:01:45,840 --> 00:01:50,479
front-end require.js

00:01:47,280 --> 00:01:53,759
uh worked asynchronously um

00:01:50,479 --> 00:01:57,840
the common js implementation that

00:01:53,759 --> 00:02:00,399
that note was inspired by let's say

00:01:57,840 --> 00:02:03,439
is synchronous so when a dependency

00:02:00,399 --> 00:02:03,439
loads a dependency

00:02:03,520 --> 00:02:09,840
say require foo

00:02:06,719 --> 00:02:11,440
the file is synchronously loaded

00:02:09,840 --> 00:02:13,760
from the file system and what that means

00:02:11,440 --> 00:02:15,599
is that execution blocks

00:02:13,760 --> 00:02:18,319
until that file is loaded and then

00:02:15,599 --> 00:02:21,520
evaluated and then whatever that file

00:02:18,319 --> 00:02:24,640
exports on the module.exports

00:02:21,520 --> 00:02:27,840
object is returned from the

00:02:24,640 --> 00:02:29,920
require function the object that gets

00:02:27,840 --> 00:02:33,680
returned is mutable because

00:02:29,920 --> 00:02:36,560
it's really just evaluating a file

00:02:33,680 --> 00:02:38,319
wrapping a function wrapper around it

00:02:36,560 --> 00:02:40,000
and then um

00:02:38,319 --> 00:02:42,319
seeing what that function wrapper does

00:02:40,000 --> 00:02:44,560
to the module exports object

00:02:42,319 --> 00:02:46,160
so there's a mini that's manipulating an

00:02:44,560 --> 00:02:51,440
object essentially

00:02:46,160 --> 00:02:56,000
and then returns that that result um uh

00:02:51,440 --> 00:02:59,040
the if a file has already been loaded

00:02:56,000 --> 00:02:59,840
uh then the cache is used so it's not

00:02:59,040 --> 00:03:02,959
going to

00:02:59,840 --> 00:03:06,080
reload files that represent a dependency

00:03:02,959 --> 00:03:09,360
over and over again they come from the

00:03:06,080 --> 00:03:09,360
require cache object

00:03:09,760 --> 00:03:16,080
so common js is the original

00:03:12,879 --> 00:03:19,599
module system of node

00:03:16,080 --> 00:03:23,200
and it can only load other common js

00:03:19,599 --> 00:03:26,959
modules at initialization time um

00:03:23,200 --> 00:03:31,200
you can use the dynamic import function

00:03:26,959 --> 00:03:31,200
to asynchronously load

00:03:31,519 --> 00:03:36,720
an esm module from a cgs module

00:03:34,560 --> 00:03:38,400
but only after an initialization so it

00:03:36,720 --> 00:03:41,599
can't be part of that

00:03:38,400 --> 00:03:44,640
initial uh uh dependency tree

00:03:41,599 --> 00:03:49,599
has to be loaded later and then

00:03:44,640 --> 00:03:52,720
and then used um ecmascript modules

00:03:49,599 --> 00:03:56,159
um are

00:03:52,720 --> 00:03:56,799
an official specification for the module

00:03:56,159 --> 00:04:00,000
system

00:03:56,799 --> 00:04:03,439
in node or in in node or in the browser

00:04:00,000 --> 00:04:04,640
um and i think i don't think it's unfair

00:04:03,439 --> 00:04:07,360
to say that that

00:04:04,640 --> 00:04:09,040
the the specification was primarily

00:04:07,360 --> 00:04:12,319
browser focused

00:04:09,040 --> 00:04:13,360
um and what's intended for is kind of a

00:04:12,319 --> 00:04:16,479
replacement

00:04:13,360 --> 00:04:18,000
or a let's say an analog of the script

00:04:16,479 --> 00:04:19,359
tag in the browser if you think of a

00:04:18,000 --> 00:04:21,759
script tag it gets

00:04:19,359 --> 00:04:23,199
it's html that gets passed out and then

00:04:21,759 --> 00:04:25,440
whatever

00:04:23,199 --> 00:04:27,360
source you specify is then loaded by the

00:04:25,440 --> 00:04:29,520
browser and the browser can choose

00:04:27,360 --> 00:04:31,680
to a certain extent how it wants to do

00:04:29,520 --> 00:04:31,680
that

00:04:32,320 --> 00:04:39,120
the ecmascript module's import syntax

00:04:36,400 --> 00:04:40,320
is supposed to be and is statically

00:04:39,120 --> 00:04:42,080
analyzable in

00:04:40,320 --> 00:04:43,759
a similar way to script tags in the

00:04:42,080 --> 00:04:45,919
browser

00:04:43,759 --> 00:04:47,840
let's um make sure that we differentiate

00:04:45,919 --> 00:04:48,960
here because if you use typescript or if

00:04:47,840 --> 00:04:52,560
you use babel

00:04:48,960 --> 00:04:57,520
you might think that you already

00:04:52,560 --> 00:05:02,560
use esm modules because an esm module

00:04:57,520 --> 00:05:02,560
essentially sort of looks like this

00:05:04,240 --> 00:05:11,840
and uh you do see that uh in in

00:05:07,840 --> 00:05:11,840
code all around the place

00:05:15,280 --> 00:05:22,160
but it's not the same as native

00:05:18,880 --> 00:05:22,880
esm modules i refer to these as do some

00:05:22,160 --> 00:05:26,400
others

00:05:22,880 --> 00:05:29,199
as as faux esm because

00:05:26,400 --> 00:05:31,919
uh if we just focus on node for a second

00:05:29,199 --> 00:05:34,960
uh if you're using a typescript or babel

00:05:31,919 --> 00:05:37,440
um that syntax is essentially being

00:05:34,960 --> 00:05:38,000
uh transpiled or compiled in the case of

00:05:37,440 --> 00:05:41,919
typescript

00:05:38,000 --> 00:05:45,520
i suppose um down to

00:05:41,919 --> 00:05:46,240
common js syntax so when you're using

00:05:45,520 --> 00:05:50,000
fosa

00:05:46,240 --> 00:05:52,080
faux esm you're really using common js

00:05:50,000 --> 00:05:55,199
for the most part i'm sure things will

00:05:52,080 --> 00:05:55,199
evolve slowly over time

00:05:55,440 --> 00:06:00,000
but when i'm talking about ecmascript

00:05:58,720 --> 00:06:02,880
modules here

00:06:00,000 --> 00:06:05,360
i'm talking about the natively

00:06:02,880 --> 00:06:08,080
implemented specification

00:06:05,360 --> 00:06:08,479
um that is present in some browsers i

00:06:08,080 --> 00:06:10,720
think

00:06:08,479 --> 00:06:11,520
chrome has support uh probably some

00:06:10,720 --> 00:06:14,800
others as well

00:06:11,520 --> 00:06:17,840
uh not paid too much attention um

00:06:14,800 --> 00:06:21,120
but in node they are uh in

00:06:17,840 --> 00:06:23,600
version 12 and version 14 and version

00:06:21,120 --> 00:06:23,600
16.

00:06:24,639 --> 00:06:30,639
something that

00:06:27,680 --> 00:06:32,240
is a very large differentiation between

00:06:30,639 --> 00:06:35,919
common js modules

00:06:32,240 --> 00:06:38,960
and native ecmascript modules

00:06:35,919 --> 00:06:42,000
is that esm

00:06:38,960 --> 00:06:46,000
loads asynchronously

00:06:42,000 --> 00:06:48,800
so uh the file

00:06:46,000 --> 00:06:50,560
for instance could be loaded

00:06:48,800 --> 00:06:51,520
asynchronously from the sources file

00:06:50,560 --> 00:06:54,000
system

00:06:51,520 --> 00:06:55,520
uh the the thread wouldn't necessarily

00:06:54,000 --> 00:06:57,919
then be blocked

00:06:55,520 --> 00:06:59,599
and uh you could potentially load

00:06:57,919 --> 00:07:03,919
multiple files

00:06:59,599 --> 00:07:06,400
um at once and there's there's other

00:07:03,919 --> 00:07:07,520
there's advantages to that um along with

00:07:06,400 --> 00:07:11,280
it there's

00:07:07,520 --> 00:07:14,880
um in node 14

00:07:11,280 --> 00:07:18,880
and node 16 but not in node 12

00:07:14,880 --> 00:07:22,160
there's top level await

00:07:18,880 --> 00:07:25,440
abbreviated tla so in a

00:07:22,160 --> 00:07:29,199
node 14 or node 16

00:07:25,440 --> 00:07:34,000
esm module you can do

00:07:29,199 --> 00:07:34,000
a weight let's say a weight foo

00:07:35,520 --> 00:07:39,680
and because the modules are loaded

00:07:38,319 --> 00:07:41,120
asynchronously

00:07:39,680 --> 00:07:43,360
this means that you can do some

00:07:41,120 --> 00:07:46,560
asynchronous initialization

00:07:43,360 --> 00:07:48,000
in in your in your module if if you need

00:07:46,560 --> 00:07:52,160
to

00:07:48,000 --> 00:07:54,400
um unlike common js

00:07:52,160 --> 00:07:56,000
um which is essentially just returning

00:07:54,400 --> 00:07:59,680
an object

00:07:56,000 --> 00:08:02,560
that you create um the

00:07:59,680 --> 00:08:03,919
uh the the modules that you can as when

00:08:02,560 --> 00:08:06,879
you import them

00:08:03,919 --> 00:08:09,199
are immutable they're read only um so

00:08:06,879 --> 00:08:13,440
they can't they can't be manipulated

00:08:09,199 --> 00:08:16,879
um kind of an advantage i think over cjs

00:08:13,440 --> 00:08:20,240
um there's

00:08:16,879 --> 00:08:22,160
um instead of the invisible function

00:08:20,240 --> 00:08:24,720
wrapper that you have with common js

00:08:22,160 --> 00:08:27,680
where it's essentially just

00:08:24,720 --> 00:08:30,240
in a common js situation uh you say have

00:08:27,680 --> 00:08:30,240
consu

00:08:33,120 --> 00:08:36,560
equals require

00:08:37,680 --> 00:08:42,880
uh if this was a common js module

00:08:41,200 --> 00:08:45,440
what would actually be happening what

00:08:42,880 --> 00:08:50,000
node actually does behind the scenes

00:08:45,440 --> 00:08:51,920
is wrap it like this in a function

00:08:50,000 --> 00:08:53,519
and then i'm not sure exactly what order

00:08:51,920 --> 00:08:54,560
the arguments are but it's something

00:08:53,519 --> 00:08:57,760
like mod

00:08:54,560 --> 00:09:00,399
module exports

00:08:57,760 --> 00:09:00,399
require

00:09:01,120 --> 00:09:05,760
file name don't name this is off the top

00:09:04,640 --> 00:09:07,200
of my head so i'm not i'm not sure

00:09:05,760 --> 00:09:09,680
exactly on the order of that but

00:09:07,200 --> 00:09:11,360
essentially that's how a a node common

00:09:09,680 --> 00:09:15,440
js module works it's

00:09:11,360 --> 00:09:15,440
it's wrapped and then um

00:09:17,360 --> 00:09:21,120
and then the the arguments are passed in

00:09:20,240 --> 00:09:25,200
from

00:09:21,120 --> 00:09:29,760
the node initialization stuff

00:09:25,200 --> 00:09:32,320
and so when you

00:09:29,760 --> 00:09:32,320
modify

00:09:32,800 --> 00:09:39,200
module exports for instance

00:09:37,040 --> 00:09:41,600
that is the thing that's then taken and

00:09:39,200 --> 00:09:41,600
returned

00:09:42,000 --> 00:09:45,040
so that's kind of how common.js works

00:09:43,760 --> 00:09:49,200
but uh

00:09:45,040 --> 00:09:50,880
esm is an entirely new specified module

00:09:49,200 --> 00:09:53,279
scope

00:09:50,880 --> 00:09:54,800
it behaves differently it behaves more

00:09:53,279 --> 00:09:58,160
as if

00:09:54,800 --> 00:10:01,600
with a function you had the use strict

00:09:58,160 --> 00:10:02,160
pragma there are some minor differences

00:10:01,600 --> 00:10:04,240
but

00:10:02,160 --> 00:10:05,600
essentially it will be in use strict

00:10:04,240 --> 00:10:08,320
mode which

00:10:05,600 --> 00:10:09,120
means that you can't use things like

00:10:08,320 --> 00:10:12,000
width and

00:10:09,120 --> 00:10:14,800
eval works a little differently in other

00:10:12,000 --> 00:10:18,320
things along those lines

00:10:14,800 --> 00:10:21,680
the import statements

00:10:18,320 --> 00:10:25,440
are statically passed and then

00:10:21,680 --> 00:10:28,720
uh and then loaded based on that passing

00:10:25,440 --> 00:10:30,240
um there is also a dynamic import

00:10:28,720 --> 00:10:32,560
function

00:10:30,240 --> 00:10:34,720
which is why top level await can be

00:10:32,560 --> 00:10:38,320
quite useful

00:10:34,720 --> 00:10:41,519
uh if i for whatever reason

00:10:38,320 --> 00:10:44,079
needed to do a dynamic import

00:10:41,519 --> 00:10:44,079
i can say

00:10:44,959 --> 00:10:53,440
uh a weight import right

00:10:49,120 --> 00:10:57,600
um the exporting

00:10:53,440 --> 00:11:00,640
uh in esm is syntax based instead of

00:10:57,600 --> 00:11:04,000
modifying uh an object so

00:11:00,640 --> 00:11:08,240
export const meow

00:11:04,000 --> 00:11:11,600
equals cat for instance or you also have

00:11:08,240 --> 00:11:14,000
the export default say export function

00:11:11,600 --> 00:11:16,000
right um

00:11:14,000 --> 00:11:18,000
so you have this this slightly different

00:11:16,000 --> 00:11:19,680
thing with the default export which is

00:11:18,000 --> 00:11:22,000
its own special thing

00:11:19,680 --> 00:11:23,600
uh which would sort of be the equivalent

00:11:22,000 --> 00:11:26,320
of what module exports is

00:11:23,600 --> 00:11:28,000
but then you have these these you can do

00:11:26,320 --> 00:11:31,680
named exports as well

00:11:28,000 --> 00:11:32,800
um uh which which is kind of similar to

00:11:31,680 --> 00:11:35,760
how you'd have

00:11:32,800 --> 00:11:37,600
an object with properties on but it's

00:11:35,760 --> 00:11:42,880
it's classified slightly differently

00:11:37,600 --> 00:11:42,880
um very crucial here

00:11:42,959 --> 00:11:49,279
commonjs has required.cache and

00:11:47,279 --> 00:11:50,320
that you can sort of mess around with a

00:11:49,279 --> 00:11:53,760
little bit

00:11:50,320 --> 00:11:55,760
um which which holds a cache of all of

00:11:53,760 --> 00:11:59,279
the loaded modules

00:11:55,760 --> 00:12:03,120
the esm does not expose

00:11:59,279 --> 00:12:05,440
a module cache that so you can't

00:12:03,120 --> 00:12:06,480
inject anything into it you can't read

00:12:05,440 --> 00:12:10,800
anything from it

00:12:06,480 --> 00:12:11,360
it's black boxed esm modules can load

00:12:10,800 --> 00:12:15,680
both

00:12:11,360 --> 00:12:18,800
common js and ecmascript modules

00:12:15,680 --> 00:12:22,839
so in terms of the ecosystem um

00:12:18,800 --> 00:12:27,600
the ecosystem is very common js heavy

00:12:22,839 --> 00:12:31,120
um and common js can't load esm

00:12:27,600 --> 00:12:34,639
so that is a definitely a friction point

00:12:31,120 --> 00:12:36,720
um so before you move to esm

00:12:34,639 --> 00:12:38,000
uh do like if you were to publish a

00:12:36,720 --> 00:12:41,200
module for consumption

00:12:38,000 --> 00:12:42,880
do do consider that um a lot of

00:12:41,200 --> 00:12:44,399
deployed projects are still just written

00:12:42,880 --> 00:12:46,720
in common js

00:12:44,399 --> 00:12:49,519
um one other thing that's not on here on

00:12:46,720 --> 00:12:49,519
the slide is that

00:12:50,480 --> 00:12:58,160
there's no way for

00:12:53,760 --> 00:13:01,279
node to know just by passing the content

00:12:58,160 --> 00:13:04,800
whether a module dependency

00:13:01,279 --> 00:13:06,720
file is common js or esm

00:13:04,800 --> 00:13:08,240
it has to assume that either by the file

00:13:06,720 --> 00:13:11,279
extension which

00:13:08,240 --> 00:13:14,079
for if it's dot js or cjs by default

00:13:11,279 --> 00:13:16,160
it's common js or if it's dot mjs it's

00:13:14,079 --> 00:13:19,279
esm

00:13:16,160 --> 00:13:22,399
or by a type field on the package json

00:13:19,279 --> 00:13:25,120
that sets the type to module

00:13:22,399 --> 00:13:26,560
in which case dot js files will be

00:13:25,120 --> 00:13:31,440
interpreted as

00:13:26,560 --> 00:13:35,519
ecmascript modules it's complicated

00:13:31,440 --> 00:13:38,639
no doubt about that so i wanted to see

00:13:35,519 --> 00:13:41,199
uh if i could build some stuff with

00:13:38,639 --> 00:13:43,040
esm see where the pain points were and

00:13:41,199 --> 00:13:47,519
the first problem i hit

00:13:43,040 --> 00:13:51,920
uh was that testing it is very difficult

00:13:47,519 --> 00:13:54,959
at the minute because

00:13:51,920 --> 00:13:54,959
primarily because

00:13:55,120 --> 00:14:02,320
if you can't manipulate the

00:13:58,320 --> 00:14:05,199
um the cash then

00:14:02,320 --> 00:14:05,920
you can't override dependencies which

00:14:05,199 --> 00:14:09,120
means you

00:14:05,920 --> 00:14:11,279
can't mock dependencies so i went about

00:14:09,120 --> 00:14:14,000
finding a different way to do that for

00:14:11,279 --> 00:14:14,000
for esm

00:14:15,040 --> 00:14:21,760
but before we talk about that

00:14:18,079 --> 00:14:25,360
um i want to kind of contextualize

00:14:21,760 --> 00:14:27,680
um uh

00:14:25,360 --> 00:14:28,399
my approach and and why i've taken the

00:14:27,680 --> 00:14:31,519
approach that i've

00:14:28,399 --> 00:14:32,320
taken and the things that i that i feel

00:14:31,519 --> 00:14:34,720
are important

00:14:32,320 --> 00:14:36,160
um with the testing strategy so to be

00:14:34,720 --> 00:14:37,519
clear we're talking about unit testing

00:14:36,160 --> 00:14:41,040
here

00:14:37,519 --> 00:14:43,839
um for me and and we can get into

00:14:41,040 --> 00:14:46,320
semantics but for me

00:14:43,839 --> 00:14:48,399
you have to think about what what the

00:14:46,320 --> 00:14:50,320
unit is

00:14:48,399 --> 00:14:52,240
particularly in other languages the unit

00:14:50,320 --> 00:14:54,320
can can actually be a file in the lib

00:14:52,240 --> 00:14:58,000
folder or something like that

00:14:54,320 --> 00:14:59,440
for me the unit is the api

00:14:58,000 --> 00:15:01,440
boundaries of a thing that you're

00:14:59,440 --> 00:15:03,279
building um

00:15:01,440 --> 00:15:06,240
if you're building a large monolith it's

00:15:03,279 --> 00:15:08,240
something different so

00:15:06,240 --> 00:15:09,519
if you're building a small module that's

00:15:08,240 --> 00:15:13,440
to be consumed

00:15:09,519 --> 00:15:16,639
then my perspective is that you should

00:15:13,440 --> 00:15:18,880
write tests that test the module

00:15:16,639 --> 00:15:20,399
from the outside and not try and test

00:15:18,880 --> 00:15:22,560
any of the module internals

00:15:20,399 --> 00:15:24,240
just make sure you hit those internals

00:15:22,560 --> 00:15:26,959
on your test coverage

00:15:24,240 --> 00:15:27,760
and if you can't find a way to hit those

00:15:26,959 --> 00:15:29,920
internals

00:15:27,760 --> 00:15:31,519
that any internal logic then remove that

00:15:29,920 --> 00:15:32,240
logic because there's not a way for it

00:15:31,519 --> 00:15:35,759
to

00:15:32,240 --> 00:15:38,240
to be reached um a microservice

00:15:35,759 --> 00:15:40,000
i think should be defined as the unit in

00:15:38,240 --> 00:15:41,120
which case you test the edges of that

00:15:40,000 --> 00:15:44,320
service so if it's

00:15:41,120 --> 00:15:46,880
http based say restful then you you hit

00:15:44,320 --> 00:15:48,480
input endpoints of that of that service

00:15:46,880 --> 00:15:50,560
um some people at that point might be

00:15:48,480 --> 00:15:52,079
saying well those are integration tests

00:15:50,560 --> 00:15:53,920
call it whatever you want this is this

00:15:52,079 --> 00:15:55,440
is the the testing strategy that i use

00:15:53,920 --> 00:15:57,759
for whatever i'm building

00:15:55,440 --> 00:15:59,360
um if i'm building a front-end

00:15:57,759 --> 00:16:02,480
application and i'm dealing with say

00:15:59,360 --> 00:16:04,079
a react component then in that case the

00:16:02,480 --> 00:16:06,560
react component is actually

00:16:04,079 --> 00:16:07,360
the unit so it kind of depends on what

00:16:06,560 --> 00:16:09,759
you're working on

00:16:07,360 --> 00:16:11,360
and and you know the methodology if it's

00:16:09,759 --> 00:16:14,399
a monolith like a

00:16:11,360 --> 00:16:16,320
like a react application or a small

00:16:14,399 --> 00:16:19,759
library or a small service those

00:16:16,320 --> 00:16:24,639
those are different things so

00:16:19,759 --> 00:16:28,079
i don't want to test internals

00:16:24,639 --> 00:16:28,079
i want to test the edges

00:16:29,040 --> 00:16:34,320
via the exposed interfaces

00:16:32,079 --> 00:16:35,199
i don't want to mock any internals

00:16:34,320 --> 00:16:38,000
because you just

00:16:35,199 --> 00:16:39,920
end up in a situation where if you start

00:16:38,000 --> 00:16:41,759
mocking internals

00:16:39,920 --> 00:16:43,680
a lot of the time it's just a very

00:16:41,759 --> 00:16:44,480
elaborate way to test whether true is

00:16:43,680 --> 00:16:47,839
true

00:16:44,480 --> 00:16:47,839
and those aren't really tests

00:16:48,320 --> 00:16:55,040
but dependencies i'm

00:16:51,759 --> 00:16:55,440
all for mocking in you know some there's

00:16:55,040 --> 00:16:59,199
always

00:16:55,440 --> 00:17:00,639
exceptions but um if you if you want a

00:16:59,199 --> 00:17:03,519
dependency to

00:17:00,639 --> 00:17:04,559
uh behave in a certain way and you don't

00:17:03,519 --> 00:17:08,959
want to

00:17:04,559 --> 00:17:12,799
figure out how to make that happen

00:17:08,959 --> 00:17:15,839
with an integration environment and

00:17:12,799 --> 00:17:17,439
databases and sending up everything

00:17:15,839 --> 00:17:19,280
all of which is reliable once you start

00:17:17,439 --> 00:17:21,839
working across the network and that

00:17:19,280 --> 00:17:24,559
makes your tests inherently unreliable

00:17:21,839 --> 00:17:26,240
then then make the the library that

00:17:24,559 --> 00:17:27,360
you're using that that integrates with

00:17:26,240 --> 00:17:30,559
those things

00:17:27,360 --> 00:17:31,760
uh behave how you want it to behave for

00:17:30,559 --> 00:17:35,039
that test scenario

00:17:31,760 --> 00:17:37,280
by mocking it this is black box black

00:17:35,039 --> 00:17:40,720
box testing

00:17:37,280 --> 00:17:40,720
and as i say

00:17:41,039 --> 00:17:43,919
name it as you wish

00:17:44,840 --> 00:17:51,600
uh let's talk about

00:17:48,799 --> 00:17:52,960
uh test libraries and test frameworks

00:17:51,600 --> 00:17:54,240
what i'm calling test libraries and test

00:17:52,960 --> 00:17:56,000
frameworks there's really two kinds

00:17:54,240 --> 00:17:59,280
there's one's where you have

00:17:56,000 --> 00:18:00,559
uh implicit global so like mocha and

00:17:59,280 --> 00:18:03,760
jess they they

00:18:00,559 --> 00:18:05,360
mocker has like you know usually has a

00:18:03,760 --> 00:18:07,840
describe and it

00:18:05,360 --> 00:18:10,320
uh functions and some other stuff uh

00:18:07,840 --> 00:18:16,400
jest has an implicit test function

00:18:10,320 --> 00:18:19,440
um those are called frameworks um

00:18:16,400 --> 00:18:23,360
but a test uh

00:18:19,440 --> 00:18:26,960
also what i would call frameworks are um

00:18:23,360 --> 00:18:30,640
a framework uh a test code that needs

00:18:26,960 --> 00:18:34,640
a test runner eg a separate

00:18:30,640 --> 00:18:36,240
cli tool that runs that test code

00:18:34,640 --> 00:18:37,679
and the reason it needs that runner is

00:18:36,240 --> 00:18:38,960
because you have things like these

00:18:37,679 --> 00:18:42,000
implicit globals and

00:18:38,960 --> 00:18:44,640
and possibly other implicit behavior

00:18:42,000 --> 00:18:45,200
that's that's a that's a test framework

00:18:44,640 --> 00:18:48,240
in

00:18:45,200 --> 00:18:52,400
as i as i define it

00:18:48,240 --> 00:18:55,600
a test library is something that can run

00:18:52,400 --> 00:18:57,760
independently um

00:18:55,600 --> 00:18:58,720
it doesn't have implicit globals you

00:18:57,760 --> 00:19:03,120
have to

00:18:58,720 --> 00:19:05,200
import or require uh any any of the

00:19:03,120 --> 00:19:07,600
api surface of that test library that

00:19:05,200 --> 00:19:10,559
you use and it should be able to

00:19:07,600 --> 00:19:11,919
be executed directly with node although

00:19:10,559 --> 00:19:13,600
a test runner isn't

00:19:11,919 --> 00:19:15,039
like out of the question you can still

00:19:13,600 --> 00:19:18,160
have a test runner for it

00:19:15,039 --> 00:19:21,679
but it's not uh required

00:19:18,160 --> 00:19:23,360
it can it can be used directly with node

00:19:21,679 --> 00:19:26,640
or it can be used with a test runner

00:19:23,360 --> 00:19:27,280
so an example of a test libraries would

00:19:26,640 --> 00:19:30,799
be

00:19:27,280 --> 00:19:30,799
tap and tape

00:19:32,160 --> 00:19:38,240
i prefer test libraries over test

00:19:35,280 --> 00:19:40,880
frameworks personally

00:19:38,240 --> 00:19:42,799
because of if you don't have implicit

00:19:40,880 --> 00:19:45,919
globals you don't have the magic i think

00:19:42,799 --> 00:19:47,440
less magic is a good thing

00:19:45,919 --> 00:19:49,120
anytime you have things that are

00:19:47,440 --> 00:19:51,679
implicit there's there's

00:19:49,120 --> 00:19:52,720
linters and other other things that do

00:19:51,679 --> 00:19:55,840
static analysis

00:19:52,720 --> 00:19:57,520
that uh you you increase the burden on

00:19:55,840 --> 00:19:59,840
of of knowing these things and

00:19:57,520 --> 00:20:00,960
syntax highlighting and editors and

00:19:59,840 --> 00:20:04,400
stuff uh

00:20:00,960 --> 00:20:07,600
all of that kind of stuff um it it

00:20:04,400 --> 00:20:09,280
it just it just for me uh places an

00:20:07,600 --> 00:20:10,880
unnecessary burden on other parts of the

00:20:09,280 --> 00:20:15,039
ecosystem

00:20:10,880 --> 00:20:16,640
um the other thing is

00:20:15,039 --> 00:20:18,320
when you're trying to debug like if

00:20:16,640 --> 00:20:20,880
you're writing tests it's because

00:20:18,320 --> 00:20:22,000
you're trying to apply rigor to your

00:20:20,880 --> 00:20:24,240
code and sometimes

00:20:22,000 --> 00:20:26,799
that can expose problems that you come

00:20:24,240 --> 00:20:30,080
across while you're writing your tests

00:20:26,799 --> 00:20:30,960
so um being able to debug is is quite

00:20:30,080 --> 00:20:34,720
important

00:20:30,960 --> 00:20:37,440
um debugging

00:20:34,720 --> 00:20:39,039
through the test runners of test

00:20:37,440 --> 00:20:40,799
frameworks and the implicit logic and

00:20:39,039 --> 00:20:43,440
the wrapping that they do

00:20:40,799 --> 00:20:44,000
it's not the end of the world but it

00:20:43,440 --> 00:20:46,159
does

00:20:44,000 --> 00:20:47,760
increase the complexity of debugging

00:20:46,159 --> 00:20:49,600
exercise

00:20:47,760 --> 00:20:51,360
if you can run things directly with node

00:20:49,600 --> 00:20:53,360
you know exactly what flags are applied

00:20:51,360 --> 00:20:56,400
you know

00:20:53,360 --> 00:20:59,120
you know exactly

00:20:56,400 --> 00:21:01,760
what code is being executed from

00:20:59,120 --> 00:21:04,960
initialization onwards

00:21:01,760 --> 00:21:08,640
for me it simplifies uh that process

00:21:04,960 --> 00:21:11,840
um putting putting um

00:21:08,640 --> 00:21:14,000
uh individual uh

00:21:11,840 --> 00:21:15,200
i mean the way that i write write test

00:21:14,000 --> 00:21:18,400
is i i

00:21:15,200 --> 00:21:19,600
break it up by file oftentimes so a test

00:21:18,400 --> 00:21:21,679
directory may have

00:21:19,600 --> 00:21:23,039
you know five six seven eight however

00:21:21,679 --> 00:21:26,080
many files

00:21:23,039 --> 00:21:27,840
and then running npm test will execute

00:21:26,080 --> 00:21:30,480
all of the tests and all those files but

00:21:27,840 --> 00:21:31,120
if one test in one file breaks i don't

00:21:30,480 --> 00:21:33,360
want to run

00:21:31,120 --> 00:21:34,320
all of the tests again so if you have a

00:21:33,360 --> 00:21:35,760
test runner

00:21:34,320 --> 00:21:39,919
what you can do is you can install it

00:21:35,760 --> 00:21:42,159
globally and then you can use that to

00:21:39,919 --> 00:21:43,120
to run your tests and that's fine and

00:21:42,159 --> 00:21:45,039
you can isolate and

00:21:43,120 --> 00:21:46,320
you can use that to run just one one

00:21:45,039 --> 00:21:48,400
file and you

00:21:46,320 --> 00:21:50,000
granted you can do that but when you're

00:21:48,400 --> 00:21:52,240
switching node versions

00:21:50,000 --> 00:21:53,600
uh now you've got a new problem you've

00:21:52,240 --> 00:21:55,760
got to reinstall your

00:21:53,600 --> 00:21:58,480
test runner or you've got to import it

00:21:55,760 --> 00:22:00,320
over from another uh

00:21:58,480 --> 00:22:02,000
where it's installed elsewhere if you're

00:22:00,320 --> 00:22:03,919
using nvm for instance i mean

00:22:02,000 --> 00:22:05,039
it gets it gets complicated no matter

00:22:03,919 --> 00:22:06,480
what um

00:22:05,039 --> 00:22:08,080
if you can just run it directly with

00:22:06,480 --> 00:22:09,440
node there's

00:22:08,080 --> 00:22:11,280
it's fine you just you just write

00:22:09,440 --> 00:22:14,000
directly with node uh

00:22:11,280 --> 00:22:16,240
so you can just like isolate that that

00:22:14,000 --> 00:22:19,760
one file with the failing test just

00:22:16,240 --> 00:22:22,640
run it straight um

00:22:19,760 --> 00:22:23,120
it's um it's good to isolate your

00:22:22,640 --> 00:22:25,120
problem

00:22:23,120 --> 00:22:26,880
in tests is what i'm saying and it's

00:22:25,120 --> 00:22:31,200
good to do that in the

00:22:26,880 --> 00:22:35,039
least uh noisy and least

00:22:31,200 --> 00:22:35,039
overheady way

00:22:35,120 --> 00:22:37,360
okay

00:22:38,159 --> 00:22:42,400
cool so let's talk about mocking

00:22:39,760 --> 00:22:42,400
dependencies

00:22:43,039 --> 00:22:49,520
so in in common.js uh

00:22:46,559 --> 00:22:50,559
no matter what library you use there's

00:22:49,520 --> 00:22:54,240
manipulation of

00:22:50,559 --> 00:22:58,159
of require.cache going on proxy choir is

00:22:54,240 --> 00:23:01,840
a a very popular uh mocking library

00:22:58,159 --> 00:23:03,919
um for

00:23:01,840 --> 00:23:05,200
mocking things i think jest has its own

00:23:03,919 --> 00:23:08,320
mocking

00:23:05,200 --> 00:23:09,919
thing as part of it but generally the

00:23:08,320 --> 00:23:12,080
concept is that you

00:23:09,919 --> 00:23:13,200
supply stubs what i'm calling the mox

00:23:12,080 --> 00:23:16,640
object here

00:23:13,200 --> 00:23:20,080
and um you use uh

00:23:16,640 --> 00:23:23,520
you you specify uh

00:23:20,080 --> 00:23:25,520
essentially the requirable name space

00:23:23,520 --> 00:23:26,640
whether that's a native module like fs

00:23:25,520 --> 00:23:29,679
or

00:23:26,640 --> 00:23:33,039
an ecosystem module like open or a path

00:23:29,679 --> 00:23:36,159
to a specific file in your project

00:23:33,039 --> 00:23:38,240
um you set them up and you you

00:23:36,159 --> 00:23:40,159
you supply the things that you actually

00:23:38,240 --> 00:23:42,480
uh want to override and

00:23:40,159 --> 00:23:43,440
you implement that uh behavior that you

00:23:42,480 --> 00:23:47,279
want

00:23:43,440 --> 00:23:49,840
uh and then you just uh pass the

00:23:47,279 --> 00:23:52,080
the file that you actually want to test

00:23:49,840 --> 00:23:54,799
say say the the entry point

00:23:52,080 --> 00:23:56,559
for your module or the path to your

00:23:54,799 --> 00:23:58,720
react component i suppose

00:23:56,559 --> 00:24:00,240
uh if you're doing sort of server side

00:23:58,720 --> 00:24:03,360
testing of rack components

00:24:00,240 --> 00:24:04,640
uh and you you and then and then that

00:24:03,360 --> 00:24:08,080
will be loaded

00:24:04,640 --> 00:24:10,159
but as as it's loaded the um

00:24:08,080 --> 00:24:11,360
the dependencies that that it's looking

00:24:10,159 --> 00:24:14,480
for uh

00:24:11,360 --> 00:24:16,320
will uh use the

00:24:14,480 --> 00:24:18,000
the the marks that you've defined if if

00:24:16,320 --> 00:24:19,279
there's dependencies that

00:24:18,000 --> 00:24:21,679
correspond with mocks that you've

00:24:19,279 --> 00:24:24,080
defined right

00:24:21,679 --> 00:24:26,559
and it and it does that by basically

00:24:24,080 --> 00:24:28,080
overriding require cash because require

00:24:26,559 --> 00:24:31,200
cash

00:24:28,080 --> 00:24:33,679
is is checked by require

00:24:31,200 --> 00:24:35,440
before it's going to load a file so say

00:24:33,679 --> 00:24:38,159
your say your

00:24:35,440 --> 00:24:39,120
your path to file being tested dot js

00:24:38,159 --> 00:24:41,760
file loads

00:24:39,120 --> 00:24:43,600
the dot four slash path four slash two

00:24:41,760 --> 00:24:46,880
four slash file dot js

00:24:43,600 --> 00:24:48,799
uh file as a dependency um if you

00:24:46,880 --> 00:24:49,440
override that namespace and require

00:24:48,799 --> 00:24:51,840
cache

00:24:49,440 --> 00:24:53,679
it's just gonna uh the require function

00:24:51,840 --> 00:24:55,760
is just gonna require whatever

00:24:53,679 --> 00:24:58,480
is gonna return sorry whatsoever and

00:24:55,760 --> 00:24:58,480
require cache

00:24:58,559 --> 00:25:04,720
so as i mentioned um

00:25:01,600 --> 00:25:08,159
the esm uh

00:25:04,720 --> 00:25:12,640
loading algorithm uh does not

00:25:08,159 --> 00:25:13,279
expose some any equivalent to require

00:25:12,640 --> 00:25:15,600
cash

00:25:13,279 --> 00:25:17,600
it's also more complicated the the way

00:25:15,600 --> 00:25:20,799
that the dependency trees are

00:25:17,600 --> 00:25:21,760
are loaded so um a required cash

00:25:20,799 --> 00:25:24,080
wouldn't even work

00:25:21,760 --> 00:25:25,279
it would have to be something more

00:25:24,080 --> 00:25:27,760
substantial

00:25:25,279 --> 00:25:29,039
to expose i still think we could really

00:25:27,760 --> 00:25:32,400
do with something like that

00:25:29,039 --> 00:25:34,960
in node um but um i think we're uh

00:25:32,400 --> 00:25:36,559
some way off from that and not sure if

00:25:34,960 --> 00:25:40,159
it will actually happen

00:25:36,559 --> 00:25:41,279
um just just to be clear we're not

00:25:40,159 --> 00:25:44,720
talking about

00:25:41,279 --> 00:25:47,279
co esm module like code that

00:25:44,720 --> 00:25:48,720
transpiles down to cgs we're talking

00:25:47,279 --> 00:25:51,760
about native esm

00:25:48,720 --> 00:25:51,760
not transpire code

00:25:53,360 --> 00:26:02,960
so there is a way

00:25:57,679 --> 00:26:07,840
um and it's with uh the loaders api

00:26:02,960 --> 00:26:07,840
um if i click this link

00:26:08,720 --> 00:26:15,279
we can see uh the description of loaders

00:26:11,760 --> 00:26:19,039
but we can also see that the stability

00:26:15,279 --> 00:26:22,840
is experimental um

00:26:19,039 --> 00:26:25,840
while ecmascript modules themselves uh

00:26:22,840 --> 00:26:25,840
are

00:26:26,000 --> 00:26:33,200
not experimental anymore the loader api

00:26:30,080 --> 00:26:33,200
is still experimental

00:26:33,840 --> 00:26:41,600
so you know

00:26:37,200 --> 00:26:44,720
caveat mtor as it were um

00:26:41,600 --> 00:26:47,440
the if you're if you if you want to use

00:26:44,720 --> 00:26:49,919
ecmascript modules and you want to test

00:26:47,440 --> 00:26:52,400
those image script modules

00:26:49,919 --> 00:26:53,279
then you have to use this experimental

00:26:52,400 --> 00:26:55,679
loader api

00:26:53,279 --> 00:26:58,240
if you're into mocking dependencies

00:26:55,679 --> 00:26:58,240
basically

00:26:58,640 --> 00:27:02,080
so an esm loader is specified by passing

00:27:01,600 --> 00:27:06,320
a

00:27:02,080 --> 00:27:10,559
loader flag to the node binary

00:27:06,320 --> 00:27:13,279
you can only specify one loader so

00:27:10,559 --> 00:27:15,600
if you have two reasons that you need

00:27:13,279 --> 00:27:16,880
loaders

00:27:15,600 --> 00:27:19,120
now you got to figure out a way to

00:27:16,880 --> 00:27:20,960
specify to solve both of those reasons

00:27:19,120 --> 00:27:24,080
with one loader

00:27:20,960 --> 00:27:27,120
this is why the api is experimental

00:27:24,080 --> 00:27:27,120
i'm hoping that

00:27:27,600 --> 00:27:35,840
there will be efforts to allow for

00:27:29,679 --> 00:27:35,840
multiple loaders in future um

00:27:35,919 --> 00:27:40,799
it's likely to change as well so um

00:27:38,880 --> 00:27:44,080
whatever i'm discussing here

00:27:40,799 --> 00:27:47,120
could break uh soon uh

00:27:44,080 --> 00:27:49,039
or it could last um

00:27:47,120 --> 00:27:51,520
we'll see uh that's the nature of

00:27:49,039 --> 00:27:54,720
experimental apis

00:27:51,520 --> 00:27:56,480
this is the only way that

00:27:54,720 --> 00:27:59,039
well it's the only way that i can think

00:27:56,480 --> 00:28:01,440
of and after talking to

00:27:59,039 --> 00:28:02,399
various people involved in the node

00:28:01,440 --> 00:28:03,840
project

00:28:02,399 --> 00:28:05,760
i'm pretty sure it's the only way you

00:28:03,840 --> 00:28:08,480
can modify the esm

00:28:05,760 --> 00:28:08,480
module loading

00:28:10,559 --> 00:28:14,840
so what we can do then is we can use a

00:28:13,360 --> 00:28:17,600
loader to

00:28:14,840 --> 00:28:20,799
modify uh the

00:28:17,600 --> 00:28:27,120
loading algorithm um

00:28:20,799 --> 00:28:27,120
of esm of of the esm module system

00:28:27,440 --> 00:28:35,120
and then somehow have some sort of api

00:28:32,000 --> 00:28:38,080
uh that allows us to to

00:28:35,120 --> 00:28:39,200
to provide mocks for our tests but that

00:28:38,080 --> 00:28:41,919
means that

00:28:39,200 --> 00:28:43,360
every time if you want to run your test

00:28:41,919 --> 00:28:44,799
directly with node

00:28:43,360 --> 00:28:48,320
every time you do that you're going to

00:28:44,799 --> 00:28:51,520
have to specify the loader flag

00:28:48,320 --> 00:28:53,600
which you know is not ideal it's

00:28:51,520 --> 00:28:56,080
i know you know who cares about a few

00:28:53,600 --> 00:28:57,760
few more typing a few more things but

00:28:56,080 --> 00:28:59,840
it's really about the cognitive overhead

00:28:57,760 --> 00:29:01,440
and having to remember to type out this

00:28:59,840 --> 00:29:03,200
fairly lengthy thing every time dash

00:29:01,440 --> 00:29:07,120
dash loader equals

00:29:03,200 --> 00:29:08,320
whatever the thing is i'm loading so

00:29:07,120 --> 00:29:10,480
what you could do is you could wrap a

00:29:08,320 --> 00:29:13,919
cli around node um

00:29:10,480 --> 00:29:16,720
with uh that then uh uses child process

00:29:13,919 --> 00:29:17,919
to spawn uh with that load of like

00:29:16,720 --> 00:29:20,240
preset

00:29:17,919 --> 00:29:21,440
um but now you're back to uh test

00:29:20,240 --> 00:29:24,559
runners um

00:29:21,440 --> 00:29:27,279
and uh i'm trying to avoid

00:29:24,559 --> 00:29:28,080
this scenario where i have a test

00:29:27,279 --> 00:29:30,399
framework

00:29:28,080 --> 00:29:33,600
i personally want to keep this idea of

00:29:30,399 --> 00:29:33,600
having a test library

00:29:34,880 --> 00:29:41,440
there's also worker threads so

00:29:38,080 --> 00:29:44,480
worker threads is the ability to it's a

00:29:41,440 --> 00:29:47,600
another fairly new node api um

00:29:44,480 --> 00:29:50,880
where you can spawn another uh

00:29:47,600 --> 00:29:53,520
instance of of the of a javascript

00:29:50,880 --> 00:29:55,200
environment with with node around it it

00:29:53,520 --> 00:29:57,600
is slightly different to

00:29:55,200 --> 00:29:59,279
the the main thread of node but it's

00:29:57,600 --> 00:30:02,320
it's it's pretty much good enough

00:29:59,279 --> 00:30:04,480
uh we'll talk about more that the the

00:30:02,320 --> 00:30:08,399
discrepancies later

00:30:04,480 --> 00:30:10,159
um and when you spawn a worker threat

00:30:08,399 --> 00:30:11,679
which again it's a thread it's not a

00:30:10,159 --> 00:30:14,880
process but you can

00:30:11,679 --> 00:30:17,440
still set the loader flag when you

00:30:14,880 --> 00:30:18,640
create that worker thread

00:30:17,440 --> 00:30:20,640
bear that in mind we're going to come

00:30:18,640 --> 00:30:22,880
back to it

00:30:20,640 --> 00:30:23,679
so with all of that information that

00:30:22,880 --> 00:30:27,440
i've

00:30:23,679 --> 00:30:28,080
laid before you uh now i'm going to talk

00:30:27,440 --> 00:30:31,200
about

00:30:28,080 --> 00:30:35,600
um my attempts uh and my

00:30:31,200 --> 00:30:39,120
you know they work um

00:30:35,600 --> 00:30:45,120
uh to to to have some way of

00:30:39,120 --> 00:30:45,120
of uh of of mocking uh esm dependencies

00:30:45,679 --> 00:30:52,159
so the first one uh is called

00:30:48,880 --> 00:30:55,440
lazaretto um

00:30:52,159 --> 00:30:57,760
lazaretto uh was

00:30:55,440 --> 00:30:59,039
built for a slightly different purpose

00:30:57,760 --> 00:31:02,240
but it was part of

00:30:59,039 --> 00:31:05,360
my my personal journey into

00:31:02,240 --> 00:31:09,120
into figuring out uh

00:31:05,360 --> 00:31:13,919
you know how to make this work uh

00:31:09,120 --> 00:31:17,200
i uh side topic i'm the

00:31:13,919 --> 00:31:20,720
technical uh lead and primary author of

00:31:17,200 --> 00:31:22,720
the opengs certifications one

00:31:20,720 --> 00:31:23,919
node.js application developer and the

00:31:22,720 --> 00:31:27,279
other node.js

00:31:23,919 --> 00:31:28,640
services developer i'm also the author

00:31:27,279 --> 00:31:29,840
of the training courses for the

00:31:28,640 --> 00:31:32,240
certification

00:31:29,840 --> 00:31:32,960
and also there's uh if you look at point

00:31:32,240 --> 00:31:35,360
two c

00:31:32,960 --> 00:31:36,159
there um there's a free course that you

00:31:35,360 --> 00:31:38,240
can also take

00:31:36,159 --> 00:31:39,679
um you can also get certified in that

00:31:38,240 --> 00:31:41,360
free course uh

00:31:39,679 --> 00:31:43,120
um but you have to have to pay for that

00:31:41,360 --> 00:31:46,320
but you can take the free course uh

00:31:43,120 --> 00:31:47,360
to to get acquainted with node.js in

00:31:46,320 --> 00:31:50,080
general

00:31:47,360 --> 00:31:51,840
and then there's two other courses that

00:31:50,080 --> 00:31:55,360
talk about specializing

00:31:51,840 --> 00:31:57,279
in services development which is uh

00:31:55,360 --> 00:31:59,600
you know building node services and and

00:31:57,279 --> 00:32:02,080
http and

00:31:59,600 --> 00:32:03,200
security and then node application

00:32:02,080 --> 00:32:06,960
development which is

00:32:03,200 --> 00:32:06,960
um pretty much everything else

00:32:07,120 --> 00:32:14,480
so i've told you all of that because

00:32:11,360 --> 00:32:15,519
i had to build lazaretto when we

00:32:14,480 --> 00:32:19,360
upgraded

00:32:15,519 --> 00:32:22,000
the uh um

00:32:19,360 --> 00:32:24,080
the the examination environment uh i

00:32:22,000 --> 00:32:26,640
think was last october

00:32:24,080 --> 00:32:27,360
so that we could support ecmascript

00:32:26,640 --> 00:32:29,120
modules

00:32:27,360 --> 00:32:30,880
if if candidates now want to use

00:32:29,120 --> 00:32:31,840
openscript modules in their answers they

00:32:30,880 --> 00:32:35,120
can

00:32:31,840 --> 00:32:36,080
um because because those the ecmascript

00:32:35,120 --> 00:32:37,519
modules were

00:32:36,080 --> 00:32:39,679
were made official and they were no

00:32:37,519 --> 00:32:44,559
longer experimental um

00:32:39,679 --> 00:32:44,559
we need to be able to support them so

00:32:44,720 --> 00:32:48,559
because the the exams are actually

00:32:47,120 --> 00:32:52,000
automatically

00:32:48,559 --> 00:32:55,039
graded i needed to be able to

00:32:52,000 --> 00:32:57,200
load a candidate's answer that may be

00:32:55,039 --> 00:33:00,640
cgs or maybe esm

00:32:57,200 --> 00:33:04,000
and then sometimes mock dependencies

00:33:00,640 --> 00:33:05,679
um so that's that's

00:33:04,000 --> 00:33:07,360
that was the primary purpose of

00:33:05,679 --> 00:33:09,840
lazaretto

00:33:07,360 --> 00:33:11,600
so the way it works is it uh it accepts

00:33:09,840 --> 00:33:13,760
a mock a mox object

00:33:11,600 --> 00:33:14,799
uh similar to the one that the proxy

00:33:13,760 --> 00:33:19,200
require

00:33:14,799 --> 00:33:22,480
uh takes that i've gone through um

00:33:19,200 --> 00:33:25,519
uh you you you pass it an entry point

00:33:22,480 --> 00:33:28,960
and then it loads a worker thread

00:33:25,519 --> 00:33:28,960
with the loader flag

00:33:31,440 --> 00:33:38,320
because it runs uh in a new thread

00:33:35,919 --> 00:33:38,960
what it initially does is uh it has to

00:33:38,320 --> 00:33:42,000
take the

00:33:38,960 --> 00:33:46,159
those uh uh mock

00:33:42,000 --> 00:33:48,880
uh uh the functions on the mock object

00:33:46,159 --> 00:33:50,159
um which actually the the functions on

00:33:48,880 --> 00:33:51,440
the mock-up is slightly different to the

00:33:50,159 --> 00:33:54,880
proxy require

00:33:51,440 --> 00:33:58,240
mock object because it takes uh

00:33:54,880 --> 00:34:00,480
each each mocked namespace is assigned

00:33:58,240 --> 00:34:02,880
to a function and then that function

00:34:00,480 --> 00:34:03,760
returns the actual mark but those

00:34:02,880 --> 00:34:06,640
functions get

00:34:03,760 --> 00:34:09,839
get stringified basically and included

00:34:06,640 --> 00:34:12,879
in the worker thread and evaluated

00:34:09,839 --> 00:34:14,720
as part of as part of that

00:34:12,879 --> 00:34:16,240
this isn't ideal because it means you

00:34:14,720 --> 00:34:19,599
lose

00:34:16,240 --> 00:34:19,919
access to the closure scope but what

00:34:19,599 --> 00:34:22,800
this

00:34:19,919 --> 00:34:24,480
is what this is good for uh is that

00:34:22,800 --> 00:34:25,919
because it's running in a worker thread

00:34:24,480 --> 00:34:27,359
and because you can pass messages

00:34:25,919 --> 00:34:28,240
between the main thread and the worker

00:34:27,359 --> 00:34:30,960
thread

00:34:28,240 --> 00:34:31,839
um it allowed allowed me to do some

00:34:30,960 --> 00:34:35,760
white box

00:34:31,839 --> 00:34:38,960
uh sort of testing strategy as well

00:34:35,760 --> 00:34:42,320
so i can um within the closure scope

00:34:38,960 --> 00:34:43,040
of the candidates executed code i can

00:34:42,320 --> 00:34:46,079
also

00:34:43,040 --> 00:34:49,839
uh run expressions and and check for

00:34:46,079 --> 00:34:49,839
things um

00:34:50,320 --> 00:34:55,200
yeah uh let's let's take a quick look at

00:34:53,359 --> 00:34:56,720
the api of that because that that's a

00:34:55,200 --> 00:35:00,640
lot to take in

00:34:56,720 --> 00:35:02,720
um so yeah so we say we have a mock

00:35:00,640 --> 00:35:04,640
object like this

00:35:02,720 --> 00:35:06,400
we have a function and then that

00:35:04,640 --> 00:35:08,400
function can be async

00:35:06,400 --> 00:35:10,640
an 18 function and then it returns the

00:35:08,400 --> 00:35:14,720
actual the actual mark

00:35:10,640 --> 00:35:19,520
we pass in uh we get a sandbox

00:35:14,720 --> 00:35:23,200
by awaiting lazaretto pass in our stuff

00:35:19,520 --> 00:35:26,400
um the sandbox as well can

00:35:23,200 --> 00:35:28,880
where i uh actually

00:35:26,400 --> 00:35:30,000
uh call and evaluate code within the

00:35:28,880 --> 00:35:33,520
worker thread context

00:35:30,000 --> 00:35:34,240
as well so take a look at that it's

00:35:33,520 --> 00:35:36,079
interesting

00:35:34,240 --> 00:35:38,560
it's more i wouldn't i wouldn't

00:35:36,079 --> 00:35:44,400
recommend

00:35:38,560 --> 00:35:46,320
using this um

00:35:44,400 --> 00:35:47,839
i wouldn't recommend using using this

00:35:46,320 --> 00:35:52,000
other than what i use it for

00:35:47,839 --> 00:35:54,640
right now uh or ever um

00:35:52,000 --> 00:35:56,480
because it is it is very specific to the

00:35:54,640 --> 00:36:00,640
use case

00:35:56,480 --> 00:36:02,960
um but it's part of of of that work

00:36:00,640 --> 00:36:04,240
uh or or of getting to getting to that

00:36:02,960 --> 00:36:07,440
place

00:36:04,240 --> 00:36:10,720
um so

00:36:07,440 --> 00:36:13,680
lazareto the way i built it it can mock

00:36:10,720 --> 00:36:16,240
both cgs and esm modules because

00:36:13,680 --> 00:36:19,359
you know someone could be implementing

00:36:16,240 --> 00:36:22,560
using esm but then consuming cgs modules

00:36:19,359 --> 00:36:24,880
um it can be direct directly executed

00:36:22,560 --> 00:36:29,040
with node no test runner required

00:36:24,880 --> 00:36:31,680
um the there's a context object

00:36:29,040 --> 00:36:33,599
that that's used to pass state between

00:36:31,680 --> 00:36:36,560
the main thread and the

00:36:33,599 --> 00:36:38,640
uh the worker thread and that's a way i

00:36:36,560 --> 00:36:41,520
can

00:36:38,640 --> 00:36:42,960
receive state back and that i can assert

00:36:41,520 --> 00:36:46,320
against in the main thread

00:36:42,960 --> 00:36:48,960
um but it's limited by the uh

00:36:46,320 --> 00:36:49,520
by the the out the cloning algorithm

00:36:48,960 --> 00:36:54,320
that

00:36:49,520 --> 00:36:57,760
that uh the the worker thread api uh

00:36:54,320 --> 00:36:59,599
relies on um which which yeah

00:36:57,760 --> 00:37:01,920
there's things that just won't when

00:36:59,599 --> 00:37:01,920
clone

00:37:04,079 --> 00:37:10,000
yeah the white box testing cool okay so

00:37:07,040 --> 00:37:13,599
that was the first pass

00:37:10,000 --> 00:37:16,400
then i started um building a cli tool

00:37:13,599 --> 00:37:18,320
and i wanted to try and build it in esm

00:37:16,400 --> 00:37:21,520
and so i wrote mock alicia's

00:37:18,320 --> 00:37:23,839
uh to do that and i wanted this to work

00:37:21,520 --> 00:37:28,240
differently i didn't want to have to

00:37:23,839 --> 00:37:31,599
uh have code that gets evaluated

00:37:28,240 --> 00:37:33,520
and then inject code mocks

00:37:31,599 --> 00:37:34,640
that have to have stringified functions

00:37:33,520 --> 00:37:37,440
that then gets all

00:37:34,640 --> 00:37:39,599
concatenated together and then run in a

00:37:37,440 --> 00:37:41,280
really esoteric way

00:37:39,599 --> 00:37:43,680
i wanted to see if i could improve on

00:37:41,280 --> 00:37:46,720
the approach

00:37:43,680 --> 00:37:49,680
so um

00:37:46,720 --> 00:37:51,359
unlike lazaretto which is is is for a

00:37:49,680 --> 00:37:53,760
very specific use case

00:37:51,359 --> 00:37:54,560
markalicious is more for a generic use

00:37:53,760 --> 00:37:58,000
case just

00:37:54,560 --> 00:38:01,760
you know the general unit testing uh

00:37:58,000 --> 00:38:06,880
approach that i've described already

00:38:01,760 --> 00:38:06,880
so it doesn't need to

00:38:07,520 --> 00:38:11,920
evaluate code in a separate thread to

00:38:10,400 --> 00:38:16,160
the actual test code

00:38:11,920 --> 00:38:17,599
it can still use a worker thread

00:38:16,160 --> 00:38:19,359
in certain scenarios which i'll explain

00:38:17,599 --> 00:38:23,520
in a second but

00:38:19,359 --> 00:38:26,640
um it doesn't it the the actual tests

00:38:23,520 --> 00:38:27,520
uh that are running also run in the

00:38:26,640 --> 00:38:31,440
worker thread

00:38:27,520 --> 00:38:35,920
which solves the how do we get a mocked

00:38:31,440 --> 00:38:38,960
thing from one thread into the other um

00:38:35,920 --> 00:38:43,599
it can also be used for both esm and cgs

00:38:38,960 --> 00:38:43,599
um from an esm or cgs parent

00:38:44,000 --> 00:38:48,960
and lazaretto tends to be

00:38:49,200 --> 00:38:52,560
fit for purpose uh for what it's doing

00:38:52,079 --> 00:38:55,920
but

00:38:52,560 --> 00:38:58,560
um when you get into sort of more uh uh

00:38:55,920 --> 00:39:00,720
in-depth implementations you can get

00:38:58,560 --> 00:39:04,160
into situations where

00:39:00,720 --> 00:39:08,640
um the dependencies

00:39:04,160 --> 00:39:12,720
uh are sort of fork out uh with with esm

00:39:08,640 --> 00:39:15,040
um long story short

00:39:12,720 --> 00:39:16,079
mochalicious had to also introduce cache

00:39:15,040 --> 00:39:19,280
busting

00:39:16,079 --> 00:39:22,240
um to make sure that um

00:39:19,280 --> 00:39:22,720
that uh a file that's loaded uh doesn't

00:39:22,240 --> 00:39:25,760
start

00:39:22,720 --> 00:39:29,200
start blocking our dependencies if

00:39:25,760 --> 00:39:32,320
the if the file's loaded before our um

00:39:29,200 --> 00:39:35,280
our mock is is is inserted um

00:39:32,320 --> 00:39:36,000
there's no way to to uh to mock it

00:39:35,280 --> 00:39:38,400
anymore so

00:39:36,000 --> 00:39:39,760
makalicious solves for that edge case as

00:39:38,400 --> 00:39:41,440
well

00:39:39,760 --> 00:39:43,200
by cache busting i mean if you've ever

00:39:41,440 --> 00:39:47,280
worked in the browser

00:39:43,200 --> 00:39:50,160
and you couldn't get a script to load

00:39:47,280 --> 00:39:50,480
uh differently or that sorry you can get

00:39:50,160 --> 00:39:52,320
a

00:39:50,480 --> 00:39:54,880
script the latest version of a script

00:39:52,320 --> 00:39:57,520
load you'd stick a question mark

00:39:54,880 --> 00:39:58,720
for the query string parameter and you'd

00:39:57,520 --> 00:40:01,119
uh

00:39:58,720 --> 00:40:02,400
you know put some random hash on there

00:40:01,119 --> 00:40:03,359
or something and then you were always

00:40:02,400 --> 00:40:05,920
getting that

00:40:03,359 --> 00:40:07,359
that latest script and we essentially

00:40:05,920 --> 00:40:09,280
have to use the same approach in mock

00:40:07,359 --> 00:40:12,720
alicia's because it's dealing with

00:40:09,280 --> 00:40:14,480
file urls uh rather than just paths and

00:40:12,720 --> 00:40:17,200
so because they're file urls

00:40:14,480 --> 00:40:19,359
we can jam that query string on the end

00:40:17,200 --> 00:40:21,359
it's

00:40:19,359 --> 00:40:22,640
there's a lot of there's a lot of weird

00:40:21,359 --> 00:40:26,000
stuff

00:40:22,640 --> 00:40:27,599
in in all of this um so this is what

00:40:26,000 --> 00:40:28,160
using mocalicious would look like which

00:40:27,599 --> 00:40:30,720
is

00:40:28,160 --> 00:40:32,000
fairly similar to the the proxy choir uh

00:40:30,720 --> 00:40:34,640
uh thing

00:40:32,000 --> 00:40:36,079
um we just uh pass in the the entry

00:40:34,640 --> 00:40:36,640
point file that's the path to file being

00:40:36,079 --> 00:40:40,079
tested

00:40:36,640 --> 00:40:43,359
and then we passed it on marks object

00:40:40,079 --> 00:40:46,240
and yeah pretty pretty much the same

00:40:43,359 --> 00:40:48,079
um proxy require current uh has a proxy

00:40:46,240 --> 00:40:50,640
choir has a

00:40:48,079 --> 00:40:52,000
sort of like a a full through mechanism

00:40:50,640 --> 00:40:53,839
by default where it uses

00:40:52,000 --> 00:40:55,040
the underlying module mocalicious

00:40:53,839 --> 00:40:56,880
doesn't have that currently so you have

00:40:55,040 --> 00:41:00,640
to kind of do that part yourself

00:40:56,880 --> 00:41:03,839
um but it's it's geared towards

00:41:00,640 --> 00:41:07,280
mocking esm as well so

00:41:03,839 --> 00:41:11,599
this this default property is the

00:41:07,280 --> 00:41:14,400
uh maps to the x the default export

00:41:11,599 --> 00:41:16,160
uh if you don't provide that in an

00:41:14,400 --> 00:41:17,440
object and you just have say a function

00:41:16,160 --> 00:41:18,560
like in this case then that becomes the

00:41:17,440 --> 00:41:21,359
default export

00:41:18,560 --> 00:41:23,200
it does it does it it doesn't violate

00:41:21,359 --> 00:41:26,160
any expectations basically it just does

00:41:23,200 --> 00:41:26,160
what you think it's going to do

00:41:27,440 --> 00:41:34,240
so much alicia's uh has

00:41:31,119 --> 00:41:38,000
an auto load mode and a load uh

00:41:34,240 --> 00:41:38,720
manual load mode first time i said that

00:41:38,000 --> 00:41:41,839
out loud i

00:41:38,720 --> 00:41:43,520
didn't realize what a sort of um weird

00:41:41,839 --> 00:41:46,000
thing that is to say

00:41:43,520 --> 00:41:47,359
uh so if we go with the the normal

00:41:46,000 --> 00:41:49,760
loaded mode

00:41:47,359 --> 00:41:51,599
you can just specify the loader flag so

00:41:49,760 --> 00:41:54,079
dash loader equals mocalicious

00:41:51,599 --> 00:41:54,720
forward slash loader.mjs and then

00:41:54,079 --> 00:41:56,800
whatever

00:41:54,720 --> 00:41:59,359
it is that you're running so maybe

00:41:56,800 --> 00:42:01,359
test.js would be better than appjs there

00:41:59,359 --> 00:42:04,319
if the loader flag is emitted though

00:42:01,359 --> 00:42:06,160
what mocalicious does

00:42:04,319 --> 00:42:07,839
is it starts a worker thread

00:42:06,160 --> 00:42:09,920
automatically

00:42:07,839 --> 00:42:11,920
with the load of flag preset on that

00:42:09,920 --> 00:42:14,839
worker thread

00:42:11,920 --> 00:42:16,400
and then crucially it blocks the main

00:42:14,839 --> 00:42:19,680
thread

00:42:16,400 --> 00:42:20,960
so if you initialize mocalicious at the

00:42:19,680 --> 00:42:24,480
top of some tests

00:42:20,960 --> 00:42:27,200
before you run any of the tests

00:42:24,480 --> 00:42:28,640
the main thread will just halt right

00:42:27,200 --> 00:42:29,440
there if you haven't used the loader

00:42:28,640 --> 00:42:32,640
flag

00:42:29,440 --> 00:42:35,440
it will just it will just halt and then

00:42:32,640 --> 00:42:37,359
all of the tests will be reloaded in the

00:42:35,440 --> 00:42:40,800
worker thread

00:42:37,359 --> 00:42:44,400
the the worker thread will then

00:42:40,800 --> 00:42:47,440
uh have the loader flag set

00:42:44,400 --> 00:42:51,680
in such a way that the loader um

00:42:47,440 --> 00:42:55,520
can replace uh um dependencies

00:42:51,680 --> 00:42:58,800
with the mocks specified in each test

00:42:55,520 --> 00:43:01,520
and because uh

00:42:58,800 --> 00:43:03,680
um and that just happens in sort of like

00:43:01,520 --> 00:43:07,040
some sort of piece of global state

00:43:03,680 --> 00:43:10,319
um but the worker thread

00:43:07,040 --> 00:43:13,359
part uh is really just about making

00:43:10,319 --> 00:43:18,560
that that uh that loader

00:43:13,359 --> 00:43:20,480
uh um uh automatically present

00:43:18,560 --> 00:43:22,079
and again that that's about just being

00:43:20,480 --> 00:43:23,599
able to run a file with node

00:43:22,079 --> 00:43:25,119
it's a ridiculous amount of i

00:43:23,599 --> 00:43:26,400
acknowledge it's a ridiculous amount of

00:43:25,119 --> 00:43:29,359
effort to go to

00:43:26,400 --> 00:43:31,680
to just run a firewood node but it it's

00:43:29,359 --> 00:43:36,000
just a really important thing to me

00:43:31,680 --> 00:43:36,000
for some reason um

00:43:36,480 --> 00:43:41,839
so just to just to sort of talk through

00:43:38,960 --> 00:43:46,319
that so the way that it works is

00:43:41,839 --> 00:43:49,200
uh we set up a loader call moccalicious

00:43:46,319 --> 00:43:50,720
and pass in uh import meta url which in

00:43:49,200 --> 00:43:52,319
is the same as underscore underscore

00:43:50,720 --> 00:43:55,440
file name basically

00:43:52,319 --> 00:43:57,680
uh in cjs it's just referring to uh

00:43:55,440 --> 00:43:59,280
itself so if our test file was like you

00:43:57,680 --> 00:44:01,280
know dot forward slash test forward

00:43:59,280 --> 00:44:04,000
slash index.test.js

00:44:01,280 --> 00:44:05,440
then um import meta url would be the

00:44:04,000 --> 00:44:07,520
full absolute path

00:44:05,440 --> 00:44:08,960
to that file being executed so that's

00:44:07,520 --> 00:44:12,720
tells mocalicious

00:44:08,960 --> 00:44:14,880
load this file um if the load if if when

00:44:12,720 --> 00:44:16,800
this this code here was executed if it

00:44:14,880 --> 00:44:18,480
was executed without the loader flag

00:44:16,800 --> 00:44:22,079
marklelicious detects that there's no

00:44:18,480 --> 00:44:25,599
loader flag set and then it will um

00:44:22,079 --> 00:44:28,319
execute the this same file

00:44:25,599 --> 00:44:29,119
in a worker thread with the loader flag

00:44:28,319 --> 00:44:31,280
set

00:44:29,119 --> 00:44:32,400
and it will block at this point in the

00:44:31,280 --> 00:44:34,640
main thread

00:44:32,400 --> 00:44:36,160
then in the worker thread it will run

00:44:34,640 --> 00:44:38,160
this test

00:44:36,160 --> 00:44:40,319
uh output the results and so on and so

00:44:38,160 --> 00:44:43,599
forth and then

00:44:40,319 --> 00:44:45,760
when the worker thread exits this will

00:44:43,599 --> 00:44:46,800
force exit from the process so this test

00:44:45,760 --> 00:44:51,680
will never run

00:44:46,800 --> 00:44:52,800
in the main thread um and that's

00:44:51,680 --> 00:44:55,440
that was one of the key parts of

00:44:52,800 --> 00:44:55,440
makalicious

00:44:55,520 --> 00:45:00,319
uh however some things don't work in

00:44:58,400 --> 00:45:02,079
worker threads it was good enough for me

00:45:00,319 --> 00:45:05,599
and my use cases and i knew how to dance

00:45:02,079 --> 00:45:09,280
around some of these pieces

00:45:05,599 --> 00:45:11,680
but yeah

00:45:09,280 --> 00:45:12,880
worker threads don't support process ch

00:45:11,680 --> 00:45:14,720
dirt for instance so if you do a

00:45:12,880 --> 00:45:17,280
process.ch der

00:45:14,720 --> 00:45:18,400
in your test it's going to break in the

00:45:17,280 --> 00:45:20,000
worker thread and it will break

00:45:18,400 --> 00:45:21,200
explicitly and give you advice on what

00:45:20,000 --> 00:45:24,319
to do

00:45:21,200 --> 00:45:25,839
um uh but uh

00:45:24,319 --> 00:45:28,160
yeah there's some other stuff like that

00:45:25,839 --> 00:45:32,160
now makalicious also

00:45:28,160 --> 00:45:35,200
does a bunch of stuff where it uh

00:45:32,160 --> 00:45:37,119
sort of patches some of these things for

00:45:35,200 --> 00:45:47,119
instance

00:45:37,119 --> 00:45:48,640
uh well i'll show you

00:45:47,119 --> 00:45:50,800
so if we're on the in the makalicious

00:45:48,640 --> 00:45:53,839
repo um

00:45:50,800 --> 00:45:56,319
uh in for instance in uh worker threads

00:45:53,839 --> 00:45:56,960
there's these methods on process.stdl

00:45:56,319 --> 00:46:00,000
that

00:45:56,960 --> 00:46:02,480
aren't present so it recreates them

00:46:00,000 --> 00:46:03,119
uh there's other stuff that it recreates

00:46:02,480 --> 00:46:06,040
as well

00:46:03,119 --> 00:46:08,800
all around this area um it recreates

00:46:06,040 --> 00:46:11,839
process.sgdn as well in in a way that's

00:46:08,800 --> 00:46:13,839
compatible with our implementation

00:46:11,839 --> 00:46:16,640
let's not get too much into the into the

00:46:13,839 --> 00:46:16,640
weeds on that though

00:46:17,280 --> 00:46:19,599
um

00:46:22,800 --> 00:46:28,720
so if if if you are if you are doing any

00:46:26,720 --> 00:46:31,359
of those things that cause

00:46:28,720 --> 00:46:32,000
issues then you have to just go back to

00:46:31,359 --> 00:46:35,280
using the

00:46:32,000 --> 00:46:38,880
the loader flag um but it will work

00:46:35,280 --> 00:46:42,079
so the autoload mode is is tentative

00:46:38,880 --> 00:46:43,839
at best let's say um

00:46:42,079 --> 00:46:46,319
but if you have to specify the load of

00:46:43,839 --> 00:46:49,359
flag it's kind of a

00:46:46,319 --> 00:46:51,200
i don't know i just i don't like it i

00:46:49,359 --> 00:46:53,440
don't like having to do that

00:46:51,200 --> 00:46:54,240
so then i wrote a thing called tapex

00:46:53,440 --> 00:46:57,599
which is just a

00:46:54,240 --> 00:47:01,839
thin wrapper around tap

00:46:57,599 --> 00:47:04,960
no tap and and it basically

00:47:01,839 --> 00:47:07,599
um makes developing uh

00:47:04,960 --> 00:47:08,800
with esm or writing tests for esm i

00:47:07,599 --> 00:47:11,599
should say easy

00:47:08,800 --> 00:47:12,000
um it it it pulls in mochalicious itself

00:47:11,599 --> 00:47:16,319
and

00:47:12,000 --> 00:47:20,000
exposes it uh from from uh from tapex

00:47:16,319 --> 00:47:21,680
um and uh the test runner uh for tap is

00:47:20,000 --> 00:47:23,440
also wrapped by tapex

00:47:21,680 --> 00:47:25,119
in a way where it just adds the loader

00:47:23,440 --> 00:47:28,800
flag for you so

00:47:25,119 --> 00:47:32,000
um you can just uh run uh you know tap

00:47:28,800 --> 00:47:35,280
test and it will work as a runner uh

00:47:32,000 --> 00:47:36,800
this is this is like you know a scenario

00:47:35,280 --> 00:47:40,240
i've created where it's like

00:47:36,800 --> 00:47:41,920
you know 90 good enough uh and if i

00:47:40,240 --> 00:47:43,839
get myself into a situation where i

00:47:41,920 --> 00:47:45,920
can't run the thing with node anymore

00:47:43,839 --> 00:47:48,720
then i either change that situation or i

00:47:45,920 --> 00:47:51,520
just go right i'll just run it with tap

00:47:48,720 --> 00:47:52,000
the other thing is that esm modules and

00:47:51,520 --> 00:47:54,079
this is another

00:47:52,000 --> 00:47:55,760
thing if you start using asm and you

00:47:54,079 --> 00:47:58,000
have to test them

00:47:55,760 --> 00:47:59,599
they're currently incompatible with nyc

00:47:58,000 --> 00:48:01,359
which is a thing built on top of

00:47:59,599 --> 00:48:02,960
istanbul you might be familiar with

00:48:01,359 --> 00:48:04,000
istanbul which is the code coverage

00:48:02,960 --> 00:48:06,880
reporter

00:48:04,000 --> 00:48:08,640
luckily va and i'm sure they'll fix that

00:48:06,880 --> 00:48:09,520
at some point but luckily v8 has

00:48:08,640 --> 00:48:12,640
something

00:48:09,520 --> 00:48:14,400
uh now uh that's um that

00:48:12,640 --> 00:48:16,160
where it has its own code coverage

00:48:14,400 --> 00:48:18,480
instrumentation um

00:48:16,160 --> 00:48:20,480
in the actual javascript engine v8 is

00:48:18,480 --> 00:48:23,839
the javascript engine that node uses

00:48:20,480 --> 00:48:28,319
um there's a coverage reporter called c8

00:48:23,839 --> 00:48:31,760
um that that can create reports based on

00:48:28,319 --> 00:48:34,319
v8 instrument instrumentation output

00:48:31,760 --> 00:48:36,480
so tapx also replaces that coverage

00:48:34,319 --> 00:48:40,079
report so you can do

00:48:36,480 --> 00:48:41,440
proper coverage reporting with esm um

00:48:40,079 --> 00:48:45,200
it doesn't work in note 12 though

00:48:41,440 --> 00:48:45,200
because the coverage stuff is too buggy

00:48:46,839 --> 00:48:53,599
so that leads me to this question

00:48:50,319 --> 00:48:53,599
is esm ready

00:48:53,839 --> 00:48:58,720
i don't think so you've seen how much

00:48:57,280 --> 00:49:02,000
i've had to do

00:48:58,720 --> 00:49:04,880
um to just to make the testing

00:49:02,000 --> 00:49:05,760
work and yes okay maybe i had a couple

00:49:04,880 --> 00:49:08,800
of

00:49:05,760 --> 00:49:12,160
um pretty um

00:49:08,800 --> 00:49:15,440
uh pretty strict red lines

00:49:12,160 --> 00:49:16,240
um but those things are important to my

00:49:15,440 --> 00:49:19,760
workflow

00:49:16,240 --> 00:49:23,520
um and i i stand by the effort

00:49:19,760 --> 00:49:25,760
um but it's still very rough and it's

00:49:23,520 --> 00:49:26,559
and as i say you know my the methods

00:49:25,760 --> 00:49:28,240
i've used

00:49:26,559 --> 00:49:30,000
to try and make it work they're good

00:49:28,240 --> 00:49:33,520
enough for me are they good enough

00:49:30,000 --> 00:49:36,559
for everyone i don't i don't know

00:49:33,520 --> 00:49:38,880
um i think i think makalicious could

00:49:36,559 --> 00:49:40,880
with you know we're about 80 percent

00:49:38,880 --> 00:49:43,200
there with mochalicious

00:49:40,880 --> 00:49:44,319
and another 20 to go but it's gonna take

00:49:43,200 --> 00:49:46,960
like you know

00:49:44,319 --> 00:49:48,000
80 percent more effort on top to get

00:49:46,960 --> 00:49:50,640
that final 20

00:49:48,000 --> 00:49:53,920
piece to make my collisions actually uh

00:49:50,640 --> 00:49:53,920
work for everyone easily

00:49:54,960 --> 00:49:58,160
well at least at least if at least in

00:49:57,200 --> 00:50:01,599
terms of running

00:49:58,160 --> 00:50:02,800
the file directly with node um

00:50:01,599 --> 00:50:05,040
the other problem is i talked about

00:50:02,800 --> 00:50:06,800
debug ability of running a file

00:50:05,040 --> 00:50:09,359
a test file directory with node totally

00:50:06,800 --> 00:50:10,559
true but with mocalicious because it's

00:50:09,359 --> 00:50:12,880
going through

00:50:10,559 --> 00:50:13,839
it's using the web uh the worker thread

00:50:12,880 --> 00:50:17,280
approach

00:50:13,839 --> 00:50:18,480
uh not very easy to debug worker threads

00:50:17,280 --> 00:50:20,720
right now so

00:50:18,480 --> 00:50:22,559
gotta wait for that to catch up as well

00:50:20,720 --> 00:50:25,680
um

00:50:22,559 --> 00:50:28,960
loader apis are experimental

00:50:25,680 --> 00:50:31,680
so you know all of this work

00:50:28,960 --> 00:50:32,880
to get the testing to work could also be

00:50:31,680 --> 00:50:34,800
wasted or it will

00:50:32,880 --> 00:50:37,520
may need some serious updating or maybe

00:50:34,800 --> 00:50:37,520
it'll be okay

00:50:37,680 --> 00:50:42,400
but until that's stable you really

00:50:40,640 --> 00:50:45,280
you're really limited on the use cases

00:50:42,400 --> 00:50:46,640
i mean putting some esm code into

00:50:45,280 --> 00:50:49,680
production

00:50:46,640 --> 00:50:52,800
uh without having any way to instrument

00:50:49,680 --> 00:50:55,760
other than via an experimental api

00:50:52,800 --> 00:50:56,880
means that uh things like apms like new

00:50:55,760 --> 00:50:58,559
relic and so forth

00:50:56,880 --> 00:51:00,319
they're going to struggle to support

00:50:58,559 --> 00:51:02,079
that because

00:51:00,319 --> 00:51:04,240
the primitives aren't there to support

00:51:02,079 --> 00:51:07,280
it and the ones that are

00:51:04,240 --> 00:51:08,800
are experimental so um

00:51:07,280 --> 00:51:10,559
there's there's a lot more that needs to

00:51:08,800 --> 00:51:14,240
happen yet i think

00:51:10,559 --> 00:51:15,839
uh current tooling uh

00:51:14,240 --> 00:51:18,079
code editors lenders test frameworks

00:51:15,839 --> 00:51:21,520
spill touring um

00:51:18,079 --> 00:51:24,480
there's that's the whole issue of fosm

00:51:21,520 --> 00:51:25,760
and a lot of that tooling is is based

00:51:24,480 --> 00:51:29,680
around

00:51:25,760 --> 00:51:32,480
um around the way

00:51:29,680 --> 00:51:33,839
that transpiled ecmascript modules works

00:51:32,480 --> 00:51:36,480
and not around how

00:51:33,839 --> 00:51:37,839
native esm works so that all has to

00:51:36,480 --> 00:51:41,440
catch up and also

00:51:37,839 --> 00:51:43,440
how do you differentiate um

00:51:41,440 --> 00:51:44,880
esm modules also break compatibility

00:51:43,440 --> 00:51:48,079
with cjs

00:51:44,880 --> 00:51:49,280
because cgs can't load esm in the init

00:51:48,079 --> 00:51:52,480
phase

00:51:49,280 --> 00:51:54,319
and uh that's going to start to cause

00:51:52,480 --> 00:51:56,240
is already causing and will cause a lot

00:51:54,319 --> 00:51:58,559
more ecosystem friction

00:51:56,240 --> 00:52:00,000
um there's a thing called conditional

00:51:58,559 --> 00:52:01,520
exports

00:52:00,000 --> 00:52:03,200
you can find this in the node docs i

00:52:01,520 --> 00:52:06,480
would say look

00:52:03,200 --> 00:52:08,640
look that up because um you can

00:52:06,480 --> 00:52:09,680
you can use that to provide support for

00:52:08,640 --> 00:52:11,920
both esm

00:52:09,680 --> 00:52:13,359
and cgs so i would say if you're if

00:52:11,920 --> 00:52:16,559
you're going to

00:52:13,359 --> 00:52:16,800
create esm modules um that you want to

00:52:16,559 --> 00:52:18,319
be

00:52:16,800 --> 00:52:20,000
consumed that you want people to be able

00:52:18,319 --> 00:52:24,000
to consume uh

00:52:20,000 --> 00:52:27,119
then um either make them cgs

00:52:24,000 --> 00:52:28,640
or or make them both cjs and esm and

00:52:27,119 --> 00:52:32,480
check out conditional exports in the

00:52:28,640 --> 00:52:34,480
docs on how to do that um so

00:52:32,480 --> 00:52:35,760
my conclusion is i don't think the esm

00:52:34,480 --> 00:52:37,839
is is ready for

00:52:35,760 --> 00:52:39,520
most cases the one case i've used it for

00:52:37,839 --> 00:52:42,800
is building a cli

00:52:39,520 --> 00:52:44,640
uh a little cli tool uh

00:52:42,800 --> 00:52:46,079
because i'm not so worried about

00:52:44,640 --> 00:52:48,960
application performance monitoring and i

00:52:46,079 --> 00:52:51,680
solved the testing part

00:52:48,960 --> 00:52:52,400
in terms of when esm will be ready

00:52:51,680 --> 00:52:57,040
unclear

00:52:52,400 --> 00:52:57,040
timeline is unclear to me i would say

00:52:57,119 --> 00:53:04,000
at very least we we need to have uh

00:53:00,160 --> 00:53:06,480
the loaders api uh as being as stable

00:53:04,000 --> 00:53:07,520
and then you need to have uh every

00:53:06,480 --> 00:53:08,880
everyone's

00:53:07,520 --> 00:53:12,319
implementations on top of that by

00:53:08,880 --> 00:53:15,920
everyone i mean the apms mostly

00:53:12,319 --> 00:53:18,640
okay um here's some things we discussed

00:53:15,920 --> 00:53:20,559
and some links um i hope this was

00:53:18,640 --> 00:53:23,839
valuable to you i know it was quite

00:53:20,559 --> 00:53:24,559
uh intense in places um i'll be in the

00:53:23,839 --> 00:53:27,280
the chat

00:53:24,559 --> 00:53:29,200
whenever i'm gonna be in the chat uh to

00:53:27,280 --> 00:53:32,079
help answer questions and stuff

00:53:29,200 --> 00:53:33,440
um i would love to have gone deeper but

00:53:32,079 --> 00:53:34,400
i'm really just trying to give you a

00:53:33,440 --> 00:53:37,680
broad overview

00:53:34,400 --> 00:53:40,880
um such as it is um

00:53:37,680 --> 00:53:47,920
thanks very much for watching uh

00:53:40,880 --> 00:53:47,920

YouTube URL: https://www.youtube.com/watch?v=ZdrNw7zxa5Y


