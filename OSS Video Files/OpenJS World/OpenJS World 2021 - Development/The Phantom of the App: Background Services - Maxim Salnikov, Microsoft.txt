Title: The Phantom of the App: Background Services - Maxim Salnikov, Microsoft
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - Development
Description: 
	Your user closes the browser tab and your excellent frontend app immediately disappears. But what if you want to build even better UX by keeping a portion of your app always alive - to send & receive events, to finish network operations, and to run some code even when a user does not have your website open? During my session, let's explore all the possibilities we have in the Service Worker-driven APIs to create true Phantoms of our apps. All for good: to keep the app itself and content always fresh, network operations - resilient, and user - notified
Captions: 
	00:00:01,599 --> 00:00:06,240
hello dr developers

00:00:03,679 --> 00:00:06,879
let's talk today about the background

00:00:06,240 --> 00:00:09,679
services

00:00:06,879 --> 00:00:10,639
available in the modern browsers for us

00:00:09,679 --> 00:00:13,200
to build

00:00:10,639 --> 00:00:13,759
web front applications with improved

00:00:13,200 --> 00:00:17,279
user

00:00:13,759 --> 00:00:18,080
experience in my session we'll go

00:00:17,279 --> 00:00:20,960
through the list

00:00:18,080 --> 00:00:22,480
of available background services and

00:00:20,960 --> 00:00:25,920
i'll also explain

00:00:22,480 --> 00:00:28,320
how to use this superpower for

00:00:25,920 --> 00:00:28,960
organizing the best in class web

00:00:28,320 --> 00:00:33,120
front-end

00:00:28,960 --> 00:00:35,520
applications my name is maxim salnikov

00:00:33,120 --> 00:00:36,880
i work as a developer engagement lead at

00:00:35,520 --> 00:00:39,920
microsoft norway

00:00:36,880 --> 00:00:43,440
and i'm big big fan of the modern

00:00:39,920 --> 00:00:45,840
web front-end development

00:00:43,440 --> 00:00:46,559
uh to share my knowledge to share my

00:00:45,840 --> 00:00:49,039
passion and

00:00:46,559 --> 00:00:49,760
expertise with this area i organize

00:00:49,039 --> 00:00:52,800
multiple

00:00:49,760 --> 00:00:56,160
meetups and conferences and i'm

00:00:52,800 --> 00:00:59,359
often speaking and presenting at

00:00:56,160 --> 00:01:02,480
events like conferences meetups

00:00:59,359 --> 00:01:05,280
workshops hackathons um

00:01:02,480 --> 00:01:06,320
all for the technical community you can

00:01:05,280 --> 00:01:09,360
find me on twitter

00:01:06,320 --> 00:01:11,680
webmax ru i tweet mainly about

00:01:09,360 --> 00:01:12,799
web platform about progressive above

00:01:11,680 --> 00:01:15,439
service workers

00:01:12,799 --> 00:01:18,400
and everything around i'll be happy to

00:01:15,439 --> 00:01:21,840
stay connected with you

00:01:18,400 --> 00:01:22,400
back to our topic what is the current

00:01:21,840 --> 00:01:26,560
state

00:01:22,400 --> 00:01:29,600
of web platform in terms of

00:01:26,560 --> 00:01:33,200
what can we do for our front-end

00:01:29,600 --> 00:01:35,680
part of web project well

00:01:33,200 --> 00:01:37,280
we can provide some functionality which

00:01:35,680 --> 00:01:40,560
was never available

00:01:37,280 --> 00:01:41,040
on the web before for example we can

00:01:40,560 --> 00:01:44,240
keep

00:01:41,040 --> 00:01:45,119
our web front-end application and data

00:01:44,240 --> 00:01:48,479
it consumes

00:01:45,119 --> 00:01:51,520
always fresh or we

00:01:48,479 --> 00:01:55,119
can organize notifications for

00:01:51,520 --> 00:01:55,439
some future point in time regardless of

00:01:55,119 --> 00:01:58,560
the

00:01:55,439 --> 00:02:01,600
connection status so we

00:01:58,560 --> 00:02:05,840
somehow can inform our dear users

00:02:01,600 --> 00:02:09,200
about some scheduled event regardless of

00:02:05,840 --> 00:02:12,080
their connection status or

00:02:09,200 --> 00:02:12,720
we can automatically replay requests

00:02:12,080 --> 00:02:15,760
which were

00:02:12,720 --> 00:02:16,400
failed for for whatever reason for

00:02:15,760 --> 00:02:19,680
example

00:02:16,400 --> 00:02:22,800
when our dear users suddenly

00:02:19,680 --> 00:02:25,840
went offline

00:02:22,800 --> 00:02:28,480
or we can provide

00:02:25,840 --> 00:02:31,200
long fetches which are connection

00:02:28,480 --> 00:02:34,480
resilient i mean of course we cannot

00:02:31,200 --> 00:02:37,120
have any magic secret internet channel

00:02:34,480 --> 00:02:37,760
but at least our fetch will not be

00:02:37,120 --> 00:02:39,120
canceled

00:02:37,760 --> 00:02:41,040
if something went wrong with the

00:02:39,120 --> 00:02:44,239
connection it can be

00:02:41,040 --> 00:02:44,640
paused it can be continued after so very

00:02:44,239 --> 00:02:48,160
good

00:02:44,640 --> 00:02:51,599
user experience you can

00:02:48,160 --> 00:02:54,800
tell me that some of these points

00:02:51,599 --> 00:02:57,120
we can implement in our

00:02:54,800 --> 00:02:58,080
javascript code in our front-end

00:02:57,120 --> 00:03:01,280
application

00:02:58,080 --> 00:03:03,680
without any need to

00:03:01,280 --> 00:03:04,480
learn background services without any

00:03:03,680 --> 00:03:07,680
need to

00:03:04,480 --> 00:03:10,540
use service worker

00:03:07,680 --> 00:03:12,239
some of them with one

00:03:10,540 --> 00:03:16,319
[Music]

00:03:12,239 --> 00:03:19,760
one limitation this functionality cannot

00:03:16,319 --> 00:03:22,080
work after user closed the tab

00:03:19,760 --> 00:03:22,959
with our application right so the code

00:03:22,080 --> 00:03:26,080
we have in

00:03:22,959 --> 00:03:28,959
our main javascript bundle will

00:03:26,080 --> 00:03:29,360
disappear right after our application

00:03:28,959 --> 00:03:32,480
tab

00:03:29,360 --> 00:03:33,120
was closed but not with the background

00:03:32,480 --> 00:03:36,879
services

00:03:33,120 --> 00:03:40,640
we can have all these features available

00:03:36,879 --> 00:03:42,400
in the background this is why it has a

00:03:40,640 --> 00:03:45,360
name like this right

00:03:42,400 --> 00:03:48,080
and i will explain how this works but

00:03:45,360 --> 00:03:51,760
first what is a background service

00:03:48,080 --> 00:03:55,920
this is a part of the browser of

00:03:51,760 --> 00:03:59,439
browsers engine which allows us to

00:03:55,920 --> 00:04:02,799
write and run a code which will work

00:03:59,439 --> 00:04:06,480
in a background and of course this

00:04:02,799 --> 00:04:10,239
this code is quite specific in

00:04:06,480 --> 00:04:14,080
in multiple terms compared to

00:04:10,239 --> 00:04:15,840
our main javascript code

00:04:14,080 --> 00:04:17,280
first it runs in a parallel thread

00:04:15,840 --> 00:04:20,799
parallel to our

00:04:17,280 --> 00:04:24,400
main thread it's always good because

00:04:20,799 --> 00:04:27,199
this way we have less competition for

00:04:24,400 --> 00:04:29,440
processor resources for memory so it

00:04:27,199 --> 00:04:32,639
allows us to build

00:04:29,440 --> 00:04:36,880
smoother and faster ui's

00:04:32,639 --> 00:04:40,080
it has completely different life cycle

00:04:36,880 --> 00:04:42,800
as i already mentioned life cycle of

00:04:40,080 --> 00:04:44,160
the main application thread is quite

00:04:42,800 --> 00:04:47,280
trivial

00:04:44,160 --> 00:04:51,199
we start on our javascript code

00:04:47,280 --> 00:04:54,720
right after the user opens the tab and

00:04:51,199 --> 00:04:57,120
types our our url and some first

00:04:54,720 --> 00:04:58,000
bytes of our javascript bundle were

00:04:57,120 --> 00:05:01,120
fetched

00:04:58,000 --> 00:05:02,880
and we close everything we

00:05:01,120 --> 00:05:04,400
unload from memory everything right

00:05:02,880 --> 00:05:07,680
after user

00:05:04,400 --> 00:05:11,039
closes the tab or maybe the browser

00:05:07,680 --> 00:05:14,960
itself it's not applicable

00:05:11,039 --> 00:05:18,400
to the code we have as a part of

00:05:14,960 --> 00:05:18,400
background services

00:05:18,880 --> 00:05:26,320
it started by completely

00:05:22,160 --> 00:05:29,440
different occasion which is event so

00:05:26,320 --> 00:05:32,479
basically everything we have in

00:05:29,440 --> 00:05:35,600
our background services is a reaction

00:05:32,479 --> 00:05:39,600
to this or that event so

00:05:35,600 --> 00:05:42,960
event came our code

00:05:39,600 --> 00:05:46,400
ran and then this

00:05:42,960 --> 00:05:48,720
this code disappears so

00:05:46,400 --> 00:05:50,240
background services is not something

00:05:48,720 --> 00:05:53,280
that we

00:05:50,240 --> 00:05:57,120
want to run for for

00:05:53,280 --> 00:06:00,319
too long so it's a fast and uh

00:05:57,120 --> 00:06:03,840
short reaction to particular event

00:06:00,319 --> 00:06:06,560
um there are multiple reasons for this

00:06:03,840 --> 00:06:08,080
and i believe the main one is we don't

00:06:06,560 --> 00:06:11,759
want to

00:06:08,080 --> 00:06:12,479
over use the resources of the browser

00:06:11,759 --> 00:06:15,199
for

00:06:12,479 --> 00:06:15,919
running code which is part of background

00:06:15,199 --> 00:06:19,199
services

00:06:15,919 --> 00:06:19,199
just imagine if

00:06:19,280 --> 00:06:24,880
every application will register

00:06:23,280 --> 00:06:28,560
something that will run for

00:06:24,880 --> 00:06:28,560
long in background well

00:06:29,120 --> 00:06:32,800
nothing left from from processor time

00:06:31,520 --> 00:06:36,240
and memory

00:06:32,800 --> 00:06:39,680
um another very important

00:06:36,240 --> 00:06:43,759
part of this difference is the fact

00:06:39,680 --> 00:06:47,199
that this code is always ready to

00:06:43,759 --> 00:06:48,080
let's call this wake up regardless of

00:06:47,199 --> 00:06:52,560
the state

00:06:48,080 --> 00:06:55,760
of um the main application um itself so

00:06:52,560 --> 00:06:56,960
the code can wake up and run

00:06:55,760 --> 00:07:00,160
[Music]

00:06:56,960 --> 00:07:03,039
even when the browser itself or to be

00:07:00,160 --> 00:07:03,840
more precise its visible part is is

00:07:03,039 --> 00:07:06,960
closed

00:07:03,840 --> 00:07:10,319
and looking at these um

00:07:06,960 --> 00:07:10,880
parameters i have analogy with phantom

00:07:10,319 --> 00:07:14,240
or

00:07:10,880 --> 00:07:17,759
ghost because our application is

00:07:14,240 --> 00:07:18,080
dead there it doesn't exist in in memory

00:07:17,759 --> 00:07:20,479
and

00:07:18,080 --> 00:07:21,759
uh the tab this application is closed

00:07:20,479 --> 00:07:23,680
but pieces of

00:07:21,759 --> 00:07:25,039
this application which we have as a part

00:07:23,680 --> 00:07:28,400
of background services

00:07:25,039 --> 00:07:32,000
is waking up here and there um

00:07:28,400 --> 00:07:34,880
they live they live their

00:07:32,000 --> 00:07:35,599
own very short life and then magically

00:07:34,880 --> 00:07:39,280
disappears

00:07:35,599 --> 00:07:42,720
like ghosts like phantom um what kind of

00:07:39,280 --> 00:07:45,440
events can wake up our

00:07:42,720 --> 00:07:47,520
server our code which is a part of

00:07:45,440 --> 00:07:50,160
service worker of course

00:07:47,520 --> 00:07:51,120
first everything connected to the

00:07:50,160 --> 00:07:53,680
network state

00:07:51,120 --> 00:07:55,599
yeah for example the situation when we

00:07:53,680 --> 00:07:58,639
go from offline state to

00:07:55,599 --> 00:08:01,120
online state there is a corresponding

00:07:58,639 --> 00:08:02,240
event which we can receive in our

00:08:01,120 --> 00:08:04,639
service worker

00:08:02,240 --> 00:08:05,520
and write corresponding code of course

00:08:04,639 --> 00:08:10,240
in that case

00:08:05,520 --> 00:08:13,680
uh we are mainly talking about

00:08:10,240 --> 00:08:16,319
the code which will try to replay failed

00:08:13,680 --> 00:08:17,440
request which we tried to do while we're

00:08:16,319 --> 00:08:20,879
offline

00:08:17,440 --> 00:08:24,479
also if we do a long fetch

00:08:20,879 --> 00:08:27,840
but if we download some bulky resource

00:08:24,479 --> 00:08:28,960
it will also send us statuses to service

00:08:27,840 --> 00:08:31,840
worker is

00:08:28,960 --> 00:08:33,599
is it succeeded or or failed and what is

00:08:31,840 --> 00:08:36,959
their progress

00:08:33,599 --> 00:08:40,880
next is a family of events

00:08:36,959 --> 00:08:43,360
based on timings specific timings or

00:08:40,880 --> 00:08:44,080
some intervals we'll have a closer look

00:08:43,360 --> 00:08:47,440
on

00:08:44,080 --> 00:08:50,880
this in the next

00:08:47,440 --> 00:08:54,720
chapter of this slide deck and of course

00:08:50,880 --> 00:08:56,399
we can wake up our service worker from

00:08:54,720 --> 00:09:01,120
the back end here we

00:08:56,399 --> 00:09:04,720
talk mainly about web push notifications

00:09:01,120 --> 00:09:06,959
i already mentioned that all the code we

00:09:04,720 --> 00:09:08,399
have as a part of background services

00:09:06,959 --> 00:09:12,080
intended to be

00:09:08,399 --> 00:09:15,040
located at service worker inside service

00:09:12,080 --> 00:09:18,240
worker basically this is the only place

00:09:15,040 --> 00:09:18,800
of our application where we can get life

00:09:18,240 --> 00:09:21,120
cycle

00:09:18,800 --> 00:09:22,240
we need which is completely separate

00:09:21,120 --> 00:09:25,120
from

00:09:22,240 --> 00:09:26,160
the main thread and this is the only

00:09:25,120 --> 00:09:29,839
place

00:09:26,160 --> 00:09:31,519
where the code is like always on on duty

00:09:29,839 --> 00:09:34,320
regardless of

00:09:31,519 --> 00:09:34,800
anything and then multiple sources can

00:09:34,320 --> 00:09:37,519
send

00:09:34,800 --> 00:09:39,519
events to our service worker first

00:09:37,519 --> 00:09:43,200
application itself

00:09:39,519 --> 00:09:43,600
then browser then operating system proxy

00:09:43,200 --> 00:09:47,760
via

00:09:43,600 --> 00:09:49,839
browser then internet again here we

00:09:47,760 --> 00:09:51,519
go back to the case with push

00:09:49,839 --> 00:09:54,160
notifications

00:09:51,519 --> 00:09:56,320
but how can we react what kind of

00:09:54,160 --> 00:10:00,160
payload what kind of code can we

00:09:56,320 --> 00:10:03,200
write in the service worker to provide

00:10:00,160 --> 00:10:05,360
better user experience first

00:10:03,200 --> 00:10:07,120
we can organize bi-directional

00:10:05,360 --> 00:10:09,279
communication channel

00:10:07,120 --> 00:10:10,160
between service worker and application

00:10:09,279 --> 00:10:13,760
for example

00:10:10,160 --> 00:10:16,880
to update number of

00:10:13,760 --> 00:10:20,000
unread messages on our

00:10:16,880 --> 00:10:20,880
ui if we build something like mail

00:10:20,000 --> 00:10:24,160
client or

00:10:20,880 --> 00:10:27,120
news client but what if

00:10:24,160 --> 00:10:28,000
um the tablets application is not open

00:10:27,120 --> 00:10:30,160
what if

00:10:28,000 --> 00:10:31,200
it's only service worker who is always

00:10:30,160 --> 00:10:34,720
on on duty

00:10:31,200 --> 00:10:37,279
well we can start the the browser and

00:10:34,720 --> 00:10:39,360
open this application from our service

00:10:37,279 --> 00:10:41,279
worker and maybe then to organize this

00:10:39,360 --> 00:10:44,079
bidirectional channel

00:10:41,279 --> 00:10:45,040
or maybe for some scenarios we don't

00:10:44,079 --> 00:10:48,399
need to

00:10:45,040 --> 00:10:50,399
do this let's say obtrusive

00:10:48,399 --> 00:10:52,160
action like starting the browser maybe

00:10:50,399 --> 00:10:55,200
we just want to show the

00:10:52,160 --> 00:10:57,920
notification it's possible um and

00:10:55,200 --> 00:10:58,839
yeah in that scenario we only need

00:10:57,920 --> 00:11:01,839
service

00:10:58,839 --> 00:11:05,600
worker and maybe the most

00:11:01,839 --> 00:11:09,120
interesting scenario when we can run

00:11:05,600 --> 00:11:12,480
some custom code without any kind of

00:11:09,120 --> 00:11:14,079
user notification i mean we do not start

00:11:12,480 --> 00:11:17,440
the application itself

00:11:14,079 --> 00:11:17,760
we do not show any notification sounds a

00:11:17,440 --> 00:11:21,120
bit

00:11:17,760 --> 00:11:22,640
scary but i'll explain you why it's

00:11:21,120 --> 00:11:25,519
still

00:11:22,640 --> 00:11:25,519
it's still cool

00:11:25,760 --> 00:11:32,000
back to background services how to find

00:11:28,880 --> 00:11:33,600
the list of what's available in the

00:11:32,000 --> 00:11:37,839
particular browser

00:11:33,600 --> 00:11:41,440
first it's not a surprise that

00:11:37,839 --> 00:11:42,399
majority of these services are only

00:11:41,440 --> 00:11:45,200
implemented

00:11:42,399 --> 00:11:46,480
in chromium-based browsers basically if

00:11:45,200 --> 00:11:50,160
we look at this list

00:11:46,480 --> 00:11:50,800
only push messaging is also implemented

00:11:50,160 --> 00:11:54,079
in

00:11:50,800 --> 00:11:54,959
firefox browser how to find this list go

00:11:54,079 --> 00:11:58,160
to devtools

00:11:54,959 --> 00:11:59,920
application tab and somewhere

00:11:58,160 --> 00:12:01,279
on the left hand side in the bottom

00:11:59,920 --> 00:12:04,720
you'll find this list

00:12:01,279 --> 00:12:07,440
of course as any part of devtools it's

00:12:04,720 --> 00:12:08,160
very convenient and very important for

00:12:07,440 --> 00:12:10,880
us

00:12:08,160 --> 00:12:12,320
developers because this particular piece

00:12:10,880 --> 00:12:15,200
of dev tools helps us

00:12:12,320 --> 00:12:15,760
to debug these background services which

00:12:15,200 --> 00:12:18,720
might be

00:12:15,760 --> 00:12:20,320
non-trivial tasks at all um without this

00:12:18,720 --> 00:12:23,519
special feature of

00:12:20,320 --> 00:12:24,160
devtools as i mentioned it's all based

00:12:23,519 --> 00:12:27,519
on the

00:12:24,160 --> 00:12:30,000
events and sometimes it's uh very

00:12:27,519 --> 00:12:30,800
challenging to predict when this event

00:12:30,000 --> 00:12:34,240
will come

00:12:30,800 --> 00:12:37,680
and in which form and what kind of

00:12:34,240 --> 00:12:38,880
reaction will be provided from my

00:12:37,680 --> 00:12:42,160
service worker side

00:12:38,880 --> 00:12:44,880
so devtools gives us a chance to

00:12:42,160 --> 00:12:45,760
record all these events which is super

00:12:44,880 --> 00:12:49,040
convenient for

00:12:45,760 --> 00:12:52,079
testing and debugging okay

00:12:49,040 --> 00:12:55,519
let's briefly go through this

00:12:52,079 --> 00:12:56,320
list i'll explain you what kind of

00:12:55,519 --> 00:12:59,600
services

00:12:56,320 --> 00:13:03,440
are those and we'll stay on

00:12:59,600 --> 00:13:07,360
a couple of them to have more details

00:13:03,440 --> 00:13:10,480
let's start with api called payment

00:13:07,360 --> 00:13:14,320
handler it's quite niche one

00:13:10,480 --> 00:13:16,959
for the scenario when you wish to build

00:13:14,320 --> 00:13:17,680
web-based payment service or even more

00:13:16,959 --> 00:13:20,160
precise

00:13:17,680 --> 00:13:21,440
web heavily web front and web

00:13:20,160 --> 00:13:24,320
front-end-based

00:13:21,440 --> 00:13:25,360
payment service it's uniqueness in the

00:13:24,320 --> 00:13:29,040
fact that

00:13:25,360 --> 00:13:31,920
i believe it's the only uh api

00:13:29,040 --> 00:13:34,079
and only possibility to install service

00:13:31,920 --> 00:13:36,560
worker on the flight without even

00:13:34,079 --> 00:13:37,920
visiting the origin of uh of this

00:13:36,560 --> 00:13:40,000
particular service worker

00:13:37,920 --> 00:13:42,079
with multiple limitations but still it's

00:13:40,000 --> 00:13:45,120
quite interesting feature

00:13:42,079 --> 00:13:48,639
and mainly we use this api for

00:13:45,120 --> 00:13:52,480
managing ui of the payment services

00:13:48,639 --> 00:13:56,240
background thing i already explained the

00:13:52,480 --> 00:13:59,680
scenario when user in offline do some

00:13:56,240 --> 00:14:02,480
actions and for example they write a

00:13:59,680 --> 00:14:05,040
blog post and then they hit the button

00:14:02,480 --> 00:14:06,800
post or send

00:14:05,040 --> 00:14:08,959
and there is no internet connection at

00:14:06,800 --> 00:14:09,600
this particular moment so instead of

00:14:08,959 --> 00:14:12,240
showing

00:14:09,600 --> 00:14:13,120
server not found or some other error

00:14:12,240 --> 00:14:16,160
what we can do

00:14:13,120 --> 00:14:19,519
we can preserve the data and

00:14:16,160 --> 00:14:23,600
register a synchronization and

00:14:19,519 --> 00:14:26,079
then at the first occasion when

00:14:23,600 --> 00:14:27,440
online is back when the connection is

00:14:26,079 --> 00:14:30,560
available

00:14:27,440 --> 00:14:33,360
and the code we wrote within this

00:14:30,560 --> 00:14:35,519
particular event listener will happen

00:14:33,360 --> 00:14:38,000
and in this code in many cases we just

00:14:35,519 --> 00:14:39,040
repeat the fetch for example sending

00:14:38,000 --> 00:14:42,320
this data to

00:14:39,040 --> 00:14:45,199
our api and

00:14:42,320 --> 00:14:46,639
as i mentioned uh before this will

00:14:45,199 --> 00:14:49,600
happen

00:14:46,639 --> 00:14:51,279
automatically in the background even if

00:14:49,600 --> 00:14:54,240
the user closed the tab

00:14:51,279 --> 00:14:55,440
even if they completely forgot that

00:14:54,240 --> 00:14:57,440
something went wrong

00:14:55,440 --> 00:14:58,560
of course uh i think it's a good idea to

00:14:57,440 --> 00:15:01,600
provide some

00:14:58,560 --> 00:15:03,440
ui notification about hey now we cannot

00:15:01,600 --> 00:15:06,160
send your data to the servers but

00:15:03,440 --> 00:15:08,079
it will be delivered later automatically

00:15:06,160 --> 00:15:11,600
it's the main power of this

00:15:08,079 --> 00:15:15,600
particular api background fetch gives

00:15:11,600 --> 00:15:17,920
us possibility to detach data fetching

00:15:15,600 --> 00:15:20,000
process from the application

00:15:17,920 --> 00:15:21,920
lifespan from the main thread of the

00:15:20,000 --> 00:15:24,639
application lifespan

00:15:21,920 --> 00:15:26,839
for example we want to download some

00:15:24,639 --> 00:15:30,480
large resource some

00:15:26,839 --> 00:15:33,600
mp4 video file

00:15:30,480 --> 00:15:36,639
and the download started and then

00:15:33,600 --> 00:15:38,320
user for example decided to close the

00:15:36,639 --> 00:15:39,040
application or something bad happened

00:15:38,320 --> 00:15:42,480
with the

00:15:39,040 --> 00:15:45,920
internet connection again then

00:15:42,480 --> 00:15:48,010
we have all the tools to for example

00:15:45,920 --> 00:15:49,279
pause this download and then to

00:15:48,010 --> 00:15:51,600
[Music]

00:15:49,279 --> 00:15:53,279
continue with this when it becomes

00:15:51,600 --> 00:15:56,399
possible so we'll have the

00:15:53,279 --> 00:15:57,759
ui very similar to ui we have for let's

00:15:56,399 --> 00:16:01,600
say classical download

00:15:57,759 --> 00:16:05,040
using anchor tag at the same time

00:16:01,600 --> 00:16:06,000
what differentiates this way to download

00:16:05,040 --> 00:16:08,240
resources from

00:16:06,000 --> 00:16:10,639
the one with anchor tag we have full

00:16:08,240 --> 00:16:12,000
control over the bytes downloaded so

00:16:10,639 --> 00:16:15,120
it's not

00:16:12,000 --> 00:16:17,920
just the next file on our

00:16:15,120 --> 00:16:18,320
operating system which was downloaded no

00:16:17,920 --> 00:16:20,720
we

00:16:18,320 --> 00:16:23,040
have these bytes available in our

00:16:20,720 --> 00:16:25,360
javascript code and we decide what to do

00:16:23,040 --> 00:16:26,720
in many cases we just want to put them

00:16:25,360 --> 00:16:31,120
into cache storage for

00:16:26,720 --> 00:16:34,320
later usage from our front-end code

00:16:31,120 --> 00:16:34,720
push messaging it's the most mature api

00:16:34,320 --> 00:16:37,759
from

00:16:34,720 --> 00:16:38,959
that list and here i just want to remind

00:16:37,759 --> 00:16:41,120
that we have possibility

00:16:38,959 --> 00:16:42,399
in addition to showing the notification

00:16:41,120 --> 00:16:46,399
itself to also

00:16:42,399 --> 00:16:50,480
run custom code so we are closing to

00:16:46,399 --> 00:16:53,519
running custom code as a background task

00:16:50,480 --> 00:16:55,680
but in that case we must

00:16:53,519 --> 00:16:57,360
show the notification so there is no

00:16:55,680 --> 00:17:00,800
chance for us to organize this

00:16:57,360 --> 00:17:03,519
in invisible for the user way

00:17:00,800 --> 00:17:04,079
okay what's left notifications uh on the

00:17:03,519 --> 00:17:06,000
one hand

00:17:04,079 --> 00:17:07,439
it's the best friend of uh push

00:17:06,000 --> 00:17:09,520
messaging api

00:17:07,439 --> 00:17:11,199
as i mentioned there is no sense in

00:17:09,520 --> 00:17:12,240
sending push notifications without

00:17:11,199 --> 00:17:15,600
showing the

00:17:12,240 --> 00:17:18,799
the notification itself but hereafter

00:17:15,600 --> 00:17:20,000
we'll talk about different uh part of

00:17:18,799 --> 00:17:22,640
this api called

00:17:20,000 --> 00:17:23,839
notification triggers and both

00:17:22,640 --> 00:17:26,160
notification triggers

00:17:23,839 --> 00:17:28,160
and periodic background sync are

00:17:26,160 --> 00:17:33,120
time-based activities we can

00:17:28,160 --> 00:17:35,679
run as a part of background services

00:17:33,120 --> 00:17:36,640
i believe this is the only what makes

00:17:35,679 --> 00:17:39,840
them similar

00:17:36,640 --> 00:17:42,960
and they have very many differences i

00:17:39,840 --> 00:17:46,160
gathered full table of this to better

00:17:42,960 --> 00:17:50,240
explain these apis

00:17:46,160 --> 00:17:52,720
first what are they designed for

00:17:50,240 --> 00:17:55,919
periodic background thing it's to give a

00:17:52,720 --> 00:17:59,440
chance to the developers to organize

00:17:55,919 --> 00:18:00,160
refresh of the application and data it

00:17:59,440 --> 00:18:02,960
consumes

00:18:00,160 --> 00:18:04,160
in a background that means that it only

00:18:02,960 --> 00:18:07,200
makes sense to

00:18:04,160 --> 00:18:09,600
run this um this code

00:18:07,200 --> 00:18:10,400
and to send this event event to the

00:18:09,600 --> 00:18:14,480
service worker

00:18:10,400 --> 00:18:15,280
while the user is online notification

00:18:14,480 --> 00:18:18,400
triggers

00:18:15,280 --> 00:18:21,840
is designed to give us

00:18:18,400 --> 00:18:24,559
developers a chance to schedule

00:18:21,840 --> 00:18:26,240
some notifications for the future time

00:18:24,559 --> 00:18:29,600
regardless of the

00:18:26,240 --> 00:18:32,799
connection okay let's go through

00:18:29,600 --> 00:18:35,919
some of the parameters timing

00:18:32,799 --> 00:18:37,919
as the name of this api says periodic

00:18:35,919 --> 00:18:41,520
background synth is something based on

00:18:37,919 --> 00:18:43,760
intervals while notification triggers we

00:18:41,520 --> 00:18:45,200
schedule this trigger this notification

00:18:43,760 --> 00:18:48,799
for one particular

00:18:45,200 --> 00:18:52,640
timestamp in the future what can we

00:18:48,799 --> 00:18:55,679
do here and there in pbs we

00:18:52,640 --> 00:18:56,320
write the custom code itself so there is

00:18:55,679 --> 00:18:59,600
no

00:18:56,320 --> 00:19:00,080
any magic way for having our application

00:18:59,600 --> 00:19:02,640
fresh

00:19:00,080 --> 00:19:03,120
and data it consumes fresh without the

00:19:02,640 --> 00:19:05,200
code

00:19:03,120 --> 00:19:07,919
we write ourselves so we just have this

00:19:05,200 --> 00:19:10,559
trigger when to run this code

00:19:07,919 --> 00:19:11,280
notification triggers is limited to only

00:19:10,559 --> 00:19:14,400
show the

00:19:11,280 --> 00:19:18,240
notification visibility for

00:19:14,400 --> 00:19:18,559
the user pbs is completely transparent i

00:19:18,240 --> 00:19:20,799
mean

00:19:18,559 --> 00:19:22,960
it happens in background if we don't

00:19:20,799 --> 00:19:23,600
want to inform user about some code is

00:19:22,960 --> 00:19:26,960
running

00:19:23,600 --> 00:19:28,799
we do not inform user in

00:19:26,960 --> 00:19:30,080
notification triggers obviously the

00:19:28,799 --> 00:19:32,880
notification is

00:19:30,080 --> 00:19:35,280
intended to be visible its native

00:19:32,880 --> 00:19:39,200
browser's notification

00:19:35,280 --> 00:19:42,720
if we look at these three

00:19:39,200 --> 00:19:46,080
criteria these three descriptions of

00:19:42,720 --> 00:19:47,039
periodic background sync once scheduled

00:19:46,080 --> 00:19:49,840
it will run for

00:19:47,039 --> 00:19:52,480
more or less forever until user

00:19:49,840 --> 00:19:55,760
explicitly deregister this or

00:19:52,480 --> 00:19:59,360
maybe re-install browser from scratch

00:19:55,760 --> 00:20:03,280
we can have custom code there within

00:19:59,360 --> 00:20:06,159
this event handler hello bitcoin mining

00:20:03,280 --> 00:20:07,039
and this will happen all completely

00:20:06,159 --> 00:20:10,159
invisible for

00:20:07,039 --> 00:20:10,640
the user sounds scary right it's exactly

00:20:10,159 --> 00:20:13,600
the

00:20:10,640 --> 00:20:14,240
the custom code i mentioned in my slide

00:20:13,600 --> 00:20:17,280
where i

00:20:14,240 --> 00:20:19,039
described sources of the events

00:20:17,280 --> 00:20:21,760
this is why there are multiple

00:20:19,039 --> 00:20:25,120
limitations and multiple considerations

00:20:21,760 --> 00:20:27,520
about this api about the case when this

00:20:25,120 --> 00:20:28,400
event can ever come to the service

00:20:27,520 --> 00:20:30,720
worker

00:20:28,400 --> 00:20:31,679
first and foremost the final decision

00:20:30,720 --> 00:20:34,000
maker on

00:20:31,679 --> 00:20:35,840
send or not send this event to service

00:20:34,000 --> 00:20:38,720
worker is the browser is

00:20:35,840 --> 00:20:39,360
what we call user agent and it takes

00:20:38,720 --> 00:20:43,440
decision

00:20:39,360 --> 00:20:46,480
based on multiple uh parameters

00:20:43,440 --> 00:20:49,760
first connection i already mentioned

00:20:46,480 --> 00:20:52,880
that it all makes sense for pbs to run

00:20:49,760 --> 00:20:55,360
in online only

00:20:52,880 --> 00:20:57,520
it was designed to run like this while

00:20:55,360 --> 00:20:58,720
maybe the main power of notification

00:20:57,520 --> 00:21:02,000
trigger

00:20:58,720 --> 00:21:04,799
is for offline mode when we don't have

00:21:02,000 --> 00:21:05,840
any chance to reach out to particular um

00:21:04,799 --> 00:21:08,880
user device

00:21:05,840 --> 00:21:12,080
uh for example to to wake them up

00:21:08,880 --> 00:21:12,880
uh if we build some web front end based

00:21:12,080 --> 00:21:16,080
alarm clock

00:21:12,880 --> 00:21:20,080
so notification triggers will work on

00:21:16,080 --> 00:21:21,280
both online and offline uh prerequisites

00:21:20,080 --> 00:21:24,320
needed to

00:21:21,280 --> 00:21:25,840
ever run this code as a part of these

00:21:24,320 --> 00:21:27,919
apis

00:21:25,840 --> 00:21:29,360
notification triggers it only requires

00:21:27,919 --> 00:21:31,120
permission for them

00:21:29,360 --> 00:21:32,880
for showing notification and it's the

00:21:31,120 --> 00:21:36,400
same permission like we have for

00:21:32,880 --> 00:21:40,080
web push while it's way more serious for

00:21:36,400 --> 00:21:42,640
pbs first um there is some

00:21:40,080 --> 00:21:43,760
separate explicit permission required

00:21:42,640 --> 00:21:47,039
from user side

00:21:43,760 --> 00:21:50,559
to run this code in background

00:21:47,039 --> 00:21:53,120
and second maybe even more important uh

00:21:50,559 --> 00:21:55,280
is the fact that application has to be

00:21:53,120 --> 00:21:57,840
installed on user machine

00:21:55,280 --> 00:21:58,720
luckily these days it's quite simple to

00:21:57,840 --> 00:22:00,480
organize

00:21:58,720 --> 00:22:02,559
installation of your web front

00:22:00,480 --> 00:22:06,159
application using web app manifest

00:22:02,559 --> 00:22:08,799
using um the fact that browsers are well

00:22:06,159 --> 00:22:11,280
integrated with operating systems now

00:22:08,799 --> 00:22:12,000
but still it's a quite a serious

00:22:11,280 --> 00:22:15,039
requirement

00:22:12,000 --> 00:22:16,000
also what i'm not listed here um but

00:22:15,039 --> 00:22:20,400
also

00:22:16,000 --> 00:22:22,880
very important this event

00:22:20,400 --> 00:22:23,600
as a part of periodic background sync

00:22:22,880 --> 00:22:26,799
will

00:22:23,600 --> 00:22:27,600
come to the service worker only on the

00:22:26,799 --> 00:22:30,080
same

00:22:27,600 --> 00:22:30,640
network where it was registered let's

00:22:30,080 --> 00:22:33,520
say

00:22:30,640 --> 00:22:34,159
it it's the same wi-fi network for

00:22:33,520 --> 00:22:37,520
example

00:22:34,159 --> 00:22:40,400
again it's uh designed like this to not

00:22:37,520 --> 00:22:40,960
break the user privacy let's have a look

00:22:40,400 --> 00:22:44,640
at some

00:22:40,960 --> 00:22:47,679
code periodic background sync it all

00:22:44,640 --> 00:22:50,320
starts from the registration of this

00:22:47,679 --> 00:22:51,760
particular sync or periodic seem to be

00:22:50,320 --> 00:22:53,679
more precise

00:22:51,760 --> 00:22:56,240
in the majority of the scenarios we do

00:22:53,679 --> 00:22:59,039
it in our main javascript bundle

00:22:56,240 --> 00:22:59,840
and i always recommend to do feature

00:22:59,039 --> 00:23:02,559
detection

00:22:59,840 --> 00:23:04,320
because this api might be available or

00:23:02,559 --> 00:23:05,360
might be not available under particular

00:23:04,320 --> 00:23:08,799
circumstances

00:23:05,360 --> 00:23:09,679
and we don't want to pollute our console

00:23:08,799 --> 00:23:12,880
with

00:23:09,679 --> 00:23:13,679
red lines and we definitely don't want

00:23:12,880 --> 00:23:17,039
to ruin

00:23:13,679 --> 00:23:19,760
core user experience and then

00:23:17,039 --> 00:23:20,240
we provide only one parameter called

00:23:19,760 --> 00:23:22,400
mean

00:23:20,240 --> 00:23:23,679
interval so we don't have full control

00:23:22,400 --> 00:23:26,320
over this uh

00:23:23,679 --> 00:23:27,919
intervals where we want to receive this

00:23:26,320 --> 00:23:30,880
event in our service worker

00:23:27,919 --> 00:23:33,520
we only can say something like hey

00:23:30,880 --> 00:23:37,679
please do not send this

00:23:33,520 --> 00:23:41,039
event more often than more often than

00:23:37,679 --> 00:23:44,240
24 hours for example uh

00:23:41,039 --> 00:23:44,880
and what's next next we go to the

00:23:44,240 --> 00:23:48,159
service

00:23:44,880 --> 00:23:50,799
worker and with inside service worker we

00:23:48,159 --> 00:23:51,679
receive periodic sync event if we are

00:23:50,799 --> 00:23:55,840
lucky if we

00:23:51,679 --> 00:23:59,120
if all these conditions are

00:23:55,840 --> 00:24:01,760
are true and what's next next we

00:23:59,120 --> 00:24:03,120
write our own code and there is no magic

00:24:01,760 --> 00:24:05,440
which will help

00:24:03,120 --> 00:24:06,320
us to update the application we have to

00:24:05,440 --> 00:24:10,080
write everything

00:24:06,320 --> 00:24:12,799
manually in majority of scenarios you

00:24:10,080 --> 00:24:14,000
fetch for example updated version of the

00:24:12,799 --> 00:24:17,600
application shell

00:24:14,000 --> 00:24:20,880
maybe you trigger some api endpoints to

00:24:17,600 --> 00:24:24,240
keep the data it consumes only also

00:24:20,880 --> 00:24:25,919
fresh and i

00:24:24,240 --> 00:24:27,440
think that if we receive this event we

00:24:25,919 --> 00:24:32,159
are already lucky

00:24:27,440 --> 00:24:33,679
but we can do step further towards best

00:24:32,159 --> 00:24:37,120
user experience and do

00:24:33,679 --> 00:24:37,600
extra checks before running our update

00:24:37,120 --> 00:24:39,200
code

00:24:37,600 --> 00:24:40,880
for example we can check network

00:24:39,200 --> 00:24:44,000
connection type and only

00:24:40,880 --> 00:24:46,880
run this update when we are on a fast

00:24:44,000 --> 00:24:47,600
stable network maybe the user in data

00:24:46,880 --> 00:24:50,799
saver mode

00:24:47,600 --> 00:24:53,520
and then i i suggest we can skip

00:24:50,799 --> 00:24:54,159
update at all and after all if we are

00:24:53,520 --> 00:24:56,320
talking about

00:24:54,159 --> 00:24:57,200
fetching some data maybe it's a good

00:24:56,320 --> 00:24:59,120
idea to check

00:24:57,200 --> 00:25:00,880
if there is a space available on the

00:24:59,120 --> 00:25:04,000
user's device

00:25:00,880 --> 00:25:06,640
if we talk about timing how

00:25:04,000 --> 00:25:07,279
often can we receive these events if we

00:25:06,640 --> 00:25:10,159
only

00:25:07,279 --> 00:25:11,039
say if we only provide a minimum

00:25:10,159 --> 00:25:14,000
interval

00:25:11,039 --> 00:25:15,840
in the best case scenario it's 12 hours

00:25:14,000 --> 00:25:18,720
and by the way it's something that

00:25:15,840 --> 00:25:20,080
not part of the specification every

00:25:18,720 --> 00:25:24,000
browser decides

00:25:20,080 --> 00:25:27,279
themselves what is this let's say timing

00:25:24,000 --> 00:25:30,720
schema what it depends

00:25:27,279 --> 00:25:31,600
on engagement score this is artificial

00:25:30,720 --> 00:25:34,799
index

00:25:31,600 --> 00:25:38,080
calculated by by the browser

00:25:34,799 --> 00:25:40,400
and it's about how long and how often

00:25:38,080 --> 00:25:43,520
the user interacts with your application

00:25:40,400 --> 00:25:46,720
so browser tries to do the best

00:25:43,520 --> 00:25:50,000
guess how popular your application is

00:25:46,720 --> 00:25:52,559
for particular user to

00:25:50,000 --> 00:25:53,200
decide on how much resources it might

00:25:52,559 --> 00:25:56,559
dedicate

00:25:53,200 --> 00:25:58,400
to this particular application if we

00:25:56,559 --> 00:26:02,080
look at the notification triggers

00:25:58,400 --> 00:26:05,760
it starts also in the main

00:26:02,080 --> 00:26:07,039
thread and same i strongly recommend you

00:26:05,760 --> 00:26:09,120
to start with feature

00:26:07,039 --> 00:26:10,960
detection and by the way here i

00:26:09,120 --> 00:26:11,279
illustrated how this notification might

00:26:10,960 --> 00:26:14,960
look

00:26:11,279 --> 00:26:18,799
like on windows 10 operating system

00:26:14,960 --> 00:26:19,120
uh here we specify exact time point when

00:26:18,799 --> 00:26:22,799
we

00:26:19,120 --> 00:26:25,919
want to show this uh notification and

00:26:22,799 --> 00:26:26,480
then as a trigger we provide timestamp

00:26:25,919 --> 00:26:28,559
trigger

00:26:26,480 --> 00:26:29,600
and maybe in the future we'll have more

00:26:28,559 --> 00:26:32,320
triggers not

00:26:29,600 --> 00:26:33,919
only based on timing but maybe based on

00:26:32,320 --> 00:26:38,000
geolocation maybe based on

00:26:33,919 --> 00:26:41,120
some other parameters so i hope i uh

00:26:38,000 --> 00:26:42,880
inspired you to have a closer look on

00:26:41,120 --> 00:26:44,640
background services and maybe on these

00:26:42,880 --> 00:26:48,720
two specific apis

00:26:44,640 --> 00:26:52,400
what's about availability and

00:26:48,720 --> 00:26:53,360
behavior of these apis on particular

00:26:52,400 --> 00:26:56,080
browsers and

00:26:53,360 --> 00:26:57,200
on particular operating systems i have a

00:26:56,080 --> 00:26:59,760
long answer for you

00:26:57,200 --> 00:27:00,320
it really depends platform and operating

00:26:59,760 --> 00:27:03,039
system

00:27:00,320 --> 00:27:03,760
browser and its version browser settings

00:27:03,039 --> 00:27:06,799
and even

00:27:03,760 --> 00:27:09,919
flags and after all

00:27:06,799 --> 00:27:11,200
origin itself and the fact is

00:27:09,919 --> 00:27:14,240
application installed

00:27:11,200 --> 00:27:16,640
or not you can get all this

00:27:14,240 --> 00:27:19,039
details about every single browser and

00:27:16,640 --> 00:27:21,840
every single situation on the links i

00:27:19,039 --> 00:27:23,279
mentioned on this slide but i have a

00:27:21,840 --> 00:27:25,679
shorter answer for you

00:27:23,279 --> 00:27:27,120
let's just think about these features

00:27:25,679 --> 00:27:30,159
like part of

00:27:27,120 --> 00:27:33,919
progressive web application and

00:27:30,159 --> 00:27:34,480
p in this acronym means progressive in

00:27:33,919 --> 00:27:37,039
terms of

00:27:34,480 --> 00:27:38,240
progressive enhancement so let's just

00:27:37,039 --> 00:27:41,120
think about these

00:27:38,240 --> 00:27:43,120
features like about something that might

00:27:41,120 --> 00:27:43,679
improve user experience and it might

00:27:43,120 --> 00:27:47,120
happen

00:27:43,679 --> 00:27:48,559
or not and of course technically feature

00:27:47,120 --> 00:27:54,240
detection is the mechanism

00:27:48,559 --> 00:27:54,240
where we check all these availabilities

00:27:54,399 --> 00:28:01,279
let's sum up the goal of

00:27:57,679 --> 00:28:03,440
these apis and many other apis which are

00:28:01,279 --> 00:28:06,559
part of service worker family

00:28:03,440 --> 00:28:10,399
is to catch up with

00:28:06,559 --> 00:28:13,840
what native code can do and in

00:28:10,399 --> 00:28:17,520
some scenarios web can do even

00:28:13,840 --> 00:28:20,559
better than native code these days

00:28:17,520 --> 00:28:24,320
let's really keep user experience

00:28:20,559 --> 00:28:27,919
in the focus and by using these apis

00:28:24,320 --> 00:28:30,960
we give something right in term

00:28:27,919 --> 00:28:34,960
in terms of better features

00:28:30,960 --> 00:28:37,679
more convenient usage of the

00:28:34,960 --> 00:28:39,600
application but we require something in

00:28:37,679 --> 00:28:42,240
return

00:28:39,600 --> 00:28:43,919
multiple things first all these annoying

00:28:42,240 --> 00:28:47,200
permissions

00:28:43,919 --> 00:28:51,360
second all security and

00:28:47,200 --> 00:28:54,240
privacy considerations third

00:28:51,360 --> 00:28:55,600
consumption of resources needed for

00:28:54,240 --> 00:28:58,720
running this

00:28:55,600 --> 00:29:00,880
background services so let's

00:28:58,720 --> 00:29:02,080
let's together with authors of these

00:29:00,880 --> 00:29:04,799
specifications

00:29:02,080 --> 00:29:05,679
find proper balance between what we give

00:29:04,799 --> 00:29:09,440
and what we

00:29:05,679 --> 00:29:12,000
require in return when it comes

00:29:09,440 --> 00:29:14,159
to developer experience i'm super happy

00:29:12,000 --> 00:29:17,200
with the current situation we have

00:29:14,159 --> 00:29:19,840
web standards we have great tooling

00:29:17,200 --> 00:29:21,360
and what i'm super happy about it's just

00:29:19,840 --> 00:29:24,960
a beginning of

00:29:21,360 --> 00:29:28,080
this great great journey i invite you to

00:29:24,960 --> 00:29:29,520
join open slack team i organized few

00:29:28,080 --> 00:29:32,960
years ago where we

00:29:29,520 --> 00:29:35,279
have more than 2 000 developers now

00:29:32,960 --> 00:29:38,960
discussing pwas service workers

00:29:35,279 --> 00:29:44,960
background services etc etc

00:29:38,960 --> 00:29:44,960

YouTube URL: https://www.youtube.com/watch?v=uo4snQYiGbE


