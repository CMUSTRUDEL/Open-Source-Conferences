Title: Shiver My Timbers! Migrating yargs to ECMAScript Modules - Benjamin Coe, Google
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - Development
Description: 
	Shiver My Timbers! Migrating yargs to ECMAScript Modules - Benjamin Coe, Google

The ECMAScript Modules standard has existed for 11 years, but it was only in April 2020 that the Node.js implementation was marked stable. Up until this point, it was difficult for the npm community to truly adopt modules, given the importance of Node.js to JavaScript tooling. Stability declared, library authors can now start thinking about a future that includes modules. ECMAScript Modules create exciting possibilities for library authors: it's now possible to target multiple JavaScript platforms, such as Deno, Node.js, and the modern web; modules have a separate loading step, making it possible to perform optimizations like tree shaking; and, they're standards backed. In this talk, Ben provides a recipe for releasing libraries that support both CommonJS (require statements) and ECMAScript modules (import and export statements), based on their experience migrating the library yargs.

Join the speaker for live Q&A on Slack: Thursday, June 3 from 11:00 - 11:20 PDT / 20:00 - 20:20 CEST, channel - #openjs_world-development
Captions: 
	00:00:00,000 --> 00:00:03,520
hello my name is benjamin cove and i'm

00:00:01,839 --> 00:00:04,560
going to be giving a talk today entitled

00:00:03,520 --> 00:00:07,279
shiver me timbers

00:00:04,560 --> 00:00:07,919
migrating yards to ecmascript modules

00:00:07,279 --> 00:00:09,840
this talk

00:00:07,919 --> 00:00:11,200
is essentially a discussion of what the

00:00:09,840 --> 00:00:13,040
process was like

00:00:11,200 --> 00:00:14,799
migrating yargs to a form that works for

00:00:13,040 --> 00:00:18,240
both ecmascript modules and

00:00:14,799 --> 00:00:19,359
common js modules but first a little bit

00:00:18,240 --> 00:00:21,760
about me

00:00:19,359 --> 00:00:23,279
as i said my name is benjamin co i'm an

00:00:21,760 --> 00:00:24,640
engineering manager at google where i

00:00:23,279 --> 00:00:26,800
lead a team focused on

00:00:24,640 --> 00:00:28,560
automation mainly in support of gcp

00:00:26,800 --> 00:00:30,160
client libraries

00:00:28,560 --> 00:00:32,559
i was also the third employee at npm

00:00:30,160 --> 00:00:34,239
incorporated and this is where i became

00:00:32,559 --> 00:00:36,000
fairly involved in the node.js open

00:00:34,239 --> 00:00:38,160
source community

00:00:36,000 --> 00:00:39,680
in the process of doing so i began

00:00:38,160 --> 00:00:40,719
maintaining the library yards which

00:00:39,680 --> 00:00:41,920
we're going to talk about a little bit

00:00:40,719 --> 00:00:43,760
today

00:00:41,920 --> 00:00:45,360
and i've also collaborated on various

00:00:43,760 --> 00:00:46,079
other open source projects such as

00:00:45,360 --> 00:00:48,960
node.js

00:00:46,079 --> 00:00:50,160
and the v8 javascript engine i will be

00:00:48,960 --> 00:00:52,320
outlining an approach

00:00:50,160 --> 00:00:54,000
that allows you to migrate your library

00:00:52,320 --> 00:00:55,600
to ecmascript modules

00:00:54,000 --> 00:00:58,640
in such a way that you don't break your

00:00:55,600 --> 00:01:00,800
existing user base of common js

00:00:58,640 --> 00:01:02,239
dependence this is an approach that

00:01:00,800 --> 00:01:03,840
works well if you have a library like

00:01:02,239 --> 00:01:05,040
yards that has a large number of

00:01:03,840 --> 00:01:06,560
dependents

00:01:05,040 --> 00:01:10,000
and might not be the best approach if

00:01:06,560 --> 00:01:11,360
you're writing a brand new library today

00:01:10,000 --> 00:01:13,520
given that this talk is from the

00:01:11,360 --> 00:01:15,200
perspective of migrating yards to

00:01:13,520 --> 00:01:16,799
ecmascript modules

00:01:15,200 --> 00:01:18,479
i just wanted to make sure that if you'd

00:01:16,799 --> 00:01:21,040
never heard of yargs before you had a

00:01:18,479 --> 00:01:23,280
passing understanding of what it does

00:01:21,040 --> 00:01:24,479
basically yargs is a library that takes

00:01:23,280 --> 00:01:27,360
the string arguments

00:01:24,479 --> 00:01:28,400
passed into a command line program and

00:01:27,360 --> 00:01:30,000
it parses these

00:01:28,400 --> 00:01:32,479
in such a way that they're more easily

00:01:30,000 --> 00:01:34,000
consumed by the person writing a command

00:01:32,479 --> 00:01:35,840
line application

00:01:34,000 --> 00:01:38,720
so rather than just getting these as a

00:01:35,840 --> 00:01:39,920
string as they're passed in arc v

00:01:38,720 --> 00:01:41,600
you get them given to you as a

00:01:39,920 --> 00:01:44,320
javascript object that you can then grab

00:01:41,600 --> 00:01:46,399
properties off of

00:01:44,320 --> 00:01:48,159
here's the example of the parsed object

00:01:46,399 --> 00:01:49,680
that you get for a really simple command

00:01:48,159 --> 00:01:50,640
line program where you're setting the

00:01:49,680 --> 00:01:53,680
propertyhello

00:01:50,640 --> 00:01:54,880
equal to world once you've defined the

00:01:53,680 --> 00:01:56,479
properties that your command line

00:01:54,880 --> 00:01:58,960
program accepts

00:01:56,479 --> 00:02:00,479
yards also will provide for you a pretty

00:01:58,960 --> 00:02:02,240
help output

00:02:00,479 --> 00:02:06,159
here's an example from the test runner

00:02:02,240 --> 00:02:06,159
mocha one of yarg's many dependents

00:02:06,399 --> 00:02:09,360
now that you hopefully have an

00:02:07,520 --> 00:02:10,720
understanding of what yargs is the

00:02:09,360 --> 00:02:12,720
majority of this talk is going to be

00:02:10,720 --> 00:02:15,200
discussing our motivation for

00:02:12,720 --> 00:02:16,640
migrating yarg's two ecmascript modules

00:02:15,200 --> 00:02:18,480
and what the experience was like

00:02:16,640 --> 00:02:21,120
being an early adopter of ecmascript

00:02:18,480 --> 00:02:22,879
modules within the node.js ecosystem

00:02:21,120 --> 00:02:24,239
so let's look through the agenda i'm

00:02:22,879 --> 00:02:26,080
going to begin by talking a little bit

00:02:24,239 --> 00:02:27,680
about the history of module systems in

00:02:26,080 --> 00:02:28,879
javascript which is actually a fairly

00:02:27,680 --> 00:02:31,760
fascinating topic

00:02:28,879 --> 00:02:32,959
and has been many years in the making

00:02:31,760 --> 00:02:35,440
we're then going to discuss

00:02:32,959 --> 00:02:36,239
the benefits of esm or ecmascript

00:02:35,440 --> 00:02:37,920
modules

00:02:36,239 --> 00:02:40,239
and why we should be excited about this

00:02:37,920 --> 00:02:41,760
shift in the community

00:02:40,239 --> 00:02:42,800
assuming that we've sold you we're going

00:02:41,760 --> 00:02:44,160
to speak to some of the options

00:02:42,800 --> 00:02:44,800
available to library authors for

00:02:44,160 --> 00:02:47,040
supporting

00:02:44,800 --> 00:02:48,720
ecmascript modules and then we're going

00:02:47,040 --> 00:02:50,640
to speak to the specific approach taken

00:02:48,720 --> 00:02:53,040
by yargs to support both ecmascript

00:02:50,640 --> 00:02:54,640
modules and common js modules

00:02:53,040 --> 00:02:56,400
which is a topic we'll also touch on

00:02:54,640 --> 00:02:58,000
briefly

00:02:56,400 --> 00:02:59,360
having shown you the approach we took

00:02:58,000 --> 00:03:00,959
i'm going to show off some of the neat

00:02:59,360 --> 00:03:02,959
benefits we get in our library as a

00:03:00,959 --> 00:03:06,480
result of the migration

00:03:02,959 --> 00:03:09,040
and i'll conclude by both discussing

00:03:06,480 --> 00:03:09,760
the challenges we faced and the benefits

00:03:09,040 --> 00:03:12,239
we gained

00:03:09,760 --> 00:03:14,319
from this migration and i'll share the

00:03:12,239 --> 00:03:17,519
links and a bit of a bibliography from

00:03:14,319 --> 00:03:20,879
all the research we did for this talk

00:03:17,519 --> 00:03:21,599
so what is a module exactly at its

00:03:20,879 --> 00:03:23,519
essence

00:03:21,599 --> 00:03:25,760
a module is just a reusable snippet of

00:03:23,519 --> 00:03:28,159
code that may or may not be published to

00:03:25,760 --> 00:03:29,920
a registry such as npm

00:03:28,159 --> 00:03:32,000
other ways you might reuse a module

00:03:29,920 --> 00:03:34,959
would be between files in the same

00:03:32,000 --> 00:03:36,640
code base or perhaps between libraries

00:03:34,959 --> 00:03:39,040
and a monorepo

00:03:36,640 --> 00:03:40,879
what is important if you wish to share a

00:03:39,040 --> 00:03:43,519
module with other folks in a community

00:03:40,879 --> 00:03:44,400
like on mpm is that you have an agreed

00:03:43,519 --> 00:03:48,879
upon way to

00:03:44,400 --> 00:03:50,720
export and import code from that module

00:03:48,879 --> 00:03:52,080
most of the folks attending this talk

00:03:50,720 --> 00:03:53,599
are probably familiar with syntax that

00:03:52,080 --> 00:03:55,280
looks something like this

00:03:53,599 --> 00:03:56,799
the use of a require statement to pull

00:03:55,280 --> 00:03:57,760
in either the default exports from a

00:03:56,799 --> 00:04:00,159
library

00:03:57,760 --> 00:04:01,680
or in the case of yard helpers to pull

00:04:00,159 --> 00:04:04,239
in a sub-module from

00:04:01,680 --> 00:04:07,200
within that library this is an example

00:04:04,239 --> 00:04:09,360
of common js

00:04:07,200 --> 00:04:10,879
common js was one of the first module

00:04:09,360 --> 00:04:11,599
systems proposed in the javascript

00:04:10,879 --> 00:04:14,319
community

00:04:11,599 --> 00:04:15,599
began its life in 2009 initially called

00:04:14,319 --> 00:04:17,440
server.js

00:04:15,599 --> 00:04:19,359
when it was proposed by then mozilla

00:04:17,440 --> 00:04:20,880
engineer kevin dangor

00:04:19,359 --> 00:04:22,639
this was essentially just an effort to

00:04:20,880 --> 00:04:24,639
get the community to rally behind a set

00:04:22,639 --> 00:04:26,720
way to define their exports

00:04:24,639 --> 00:04:29,600
and a syntax around how requiring would

00:04:26,720 --> 00:04:32,160
work for fetching in these exports

00:04:29,600 --> 00:04:33,600
the approach gained some popularity and

00:04:32,160 --> 00:04:36,479
to indicate that it was

00:04:33,600 --> 00:04:38,639
applicable both to the web and to server

00:04:36,479 --> 00:04:41,040
side javascript it was renamed to

00:04:38,639 --> 00:04:42,720
commonjs from server.js midway through

00:04:41,040 --> 00:04:45,040
the year

00:04:42,720 --> 00:04:45,840
later in the same year ryan dahl

00:04:45,040 --> 00:04:48,880
presented

00:04:45,840 --> 00:04:50,479
node.js at the node configu conference

00:04:48,880 --> 00:04:52,880
this was presented as a server-side

00:04:50,479 --> 00:04:54,880
javascript built on v8 using the common

00:04:52,880 --> 00:04:57,600
js module system

00:04:54,880 --> 00:04:58,000
as we know node.js became quite popular

00:04:57,600 --> 00:04:59,919
and

00:04:58,000 --> 00:05:02,320
along with it the common js module

00:04:59,919 --> 00:05:02,320
system

00:05:02,880 --> 00:05:06,639
despite its emerging popularity on

00:05:04,800 --> 00:05:09,520
platforms like node.js

00:05:06,639 --> 00:05:11,120
commonjs was not adopted by web browsers

00:05:09,520 --> 00:05:13,199
one reason for this

00:05:11,120 --> 00:05:14,560
is that common js assumed that modules

00:05:13,199 --> 00:05:15,759
would be loaded one after another

00:05:14,560 --> 00:05:17,280
synchronously

00:05:15,759 --> 00:05:19,680
this isn't a problem when you're loading

00:05:17,280 --> 00:05:21,440
from the disk because that's very fast

00:05:19,680 --> 00:05:23,360
but on a website where you're trying to

00:05:21,440 --> 00:05:25,840
load multiple scripts from

00:05:23,360 --> 00:05:27,600
an http endpoint it can become

00:05:25,840 --> 00:05:31,199
prohibitively slow not to try to load

00:05:27,600 --> 00:05:31,199
multiple scripts at the same time

00:05:31,440 --> 00:05:36,720
in an effort to address this problem

00:05:33,840 --> 00:05:38,880
chris sip proposed in september of 2010

00:05:36,720 --> 00:05:40,080
the asynchronous module definition spec

00:05:38,880 --> 00:05:42,160
or amd

00:05:40,080 --> 00:05:44,160
the idea being that this would be an

00:05:42,160 --> 00:05:45,600
extension to common js

00:05:44,160 --> 00:05:48,560
that addressed the problem of loading

00:05:45,600 --> 00:05:50,320
multiple scripts in parallel

00:05:48,560 --> 00:05:51,680
ultimately this was not adopted by

00:05:50,320 --> 00:05:54,880
common js but

00:05:51,680 --> 00:05:56,880
amd in a standalone form was adopted by

00:05:54,880 --> 00:05:57,840
popular frameworks such as the dojo

00:05:56,880 --> 00:06:01,120
toolkit

00:05:57,840 --> 00:06:02,400
and require js despite solving the

00:06:01,120 --> 00:06:04,160
problem of loading scripts in an

00:06:02,400 --> 00:06:05,199
asynchronous manner one of the problems

00:06:04,160 --> 00:06:08,479
facing

00:06:05,199 --> 00:06:10,960
web browser adoption of common js

00:06:08,479 --> 00:06:13,759
ultimately web browsers did not adopt

00:06:10,960 --> 00:06:13,759
amd either

00:06:16,160 --> 00:06:22,240
in parallel with the development of

00:06:18,720 --> 00:06:26,080
common js and the proposal of amd

00:06:22,240 --> 00:06:26,720
in september of 2009 ehab awad and chris

00:06:26,080 --> 00:06:29,360
cowell

00:06:26,720 --> 00:06:29,759
presented an early draft of the concept

00:06:29,360 --> 00:06:32,240
of

00:06:29,759 --> 00:06:33,680
ecmascript modules so this was the idea

00:06:32,240 --> 00:06:36,880
of getting modules built into the

00:06:33,680 --> 00:06:40,000
javascript language itself

00:06:36,880 --> 00:06:40,800
ehob was a worked on the kaha team which

00:06:40,000 --> 00:06:42,240
is a team that

00:06:40,800 --> 00:06:44,080
was a team at google concerned with

00:06:42,240 --> 00:06:46,400
sandboxing javascript such that

00:06:44,080 --> 00:06:50,240
untrusted javascript could run

00:06:46,400 --> 00:06:52,160
in a web page so this initial

00:06:50,240 --> 00:06:53,280
pitch for ecmascript modules didn't just

00:06:52,160 --> 00:06:56,639
address issues like

00:06:53,280 --> 00:06:58,479
asynchronous loading it addressed the

00:06:56,639 --> 00:07:01,680
topic of how you would use modules in a

00:06:58,479 --> 00:07:05,199
secure manner in a website

00:07:01,680 --> 00:07:07,199
proposal evolved and by february of 2012

00:07:05,199 --> 00:07:08,479
the v8 javascript engine the engine used

00:07:07,199 --> 00:07:10,000
by chromium

00:07:08,479 --> 00:07:14,000
had adopted some of the initial

00:07:10,000 --> 00:07:17,759
proposals of ecmascript modules

00:07:14,000 --> 00:07:19,440
by july 2017 node.js had shipped its own

00:07:17,759 --> 00:07:20,800
experimental ecmascript module

00:07:19,440 --> 00:07:22,319
implementation

00:07:20,800 --> 00:07:24,319
but this was behind the flag

00:07:22,319 --> 00:07:25,120
experimental modules so you couldn't use

00:07:24,319 --> 00:07:27,919
it without

00:07:25,120 --> 00:07:28,880
your user setting a flag one of the

00:07:27,919 --> 00:07:31,199
reasons why

00:07:28,880 --> 00:07:33,039
ecmascript modules are so topical today

00:07:31,199 --> 00:07:36,160
and why this is an important talk

00:07:33,039 --> 00:07:37,599
is it wasn't until may 2021 so quite

00:07:36,160 --> 00:07:39,919
recently

00:07:37,599 --> 00:07:43,440
that ecmascript modules became available

00:07:39,919 --> 00:07:45,599
on all versions of node.js

00:07:43,440 --> 00:07:47,680
so for the first time in the history of

00:07:45,599 --> 00:07:50,400
module systems in javascript

00:07:47,680 --> 00:07:52,479
with ecmascript modules module authors

00:07:50,400 --> 00:07:53,919
can now write code that will work both

00:07:52,479 --> 00:07:56,479
on node.js

00:07:53,919 --> 00:07:57,599
and all common browsers such as chromium

00:07:56,479 --> 00:08:00,160
firefox

00:07:57,599 --> 00:08:02,000
and safari along with new platforms like

00:08:00,160 --> 00:08:04,319
dino which have themselves adopted

00:08:02,000 --> 00:08:06,800
ecmascript modules

00:08:04,319 --> 00:08:08,400
so as a library author what are some of

00:08:06,800 --> 00:08:09,840
the benefits of adopting ecmascript

00:08:08,400 --> 00:08:12,160
modules

00:08:09,840 --> 00:08:14,400
as we've already discussed a little bit

00:08:12,160 --> 00:08:16,800
ecmascript modules perform asynchronous

00:08:14,400 --> 00:08:19,440
loading when you load a dependency

00:08:16,800 --> 00:08:20,960
here's an example of an esm module

00:08:19,440 --> 00:08:22,000
loading in the web browser if you look

00:08:20,960 --> 00:08:23,120
at the timeline

00:08:22,000 --> 00:08:25,039
you'll notice that many of the

00:08:23,120 --> 00:08:27,120
dependencies load in parallel

00:08:25,039 --> 00:08:29,520
making the overload all load time much

00:08:27,120 --> 00:08:29,520
shorter

00:08:30,000 --> 00:08:33,360
the next benefit that i think's worth

00:08:31,520 --> 00:08:36,080
calling out is the fact that

00:08:33,360 --> 00:08:38,399
if you're using nodejs esm modules

00:08:36,080 --> 00:08:41,200
support top level await

00:08:38,399 --> 00:08:41,599
so in the past uh to write code like

00:08:41,200 --> 00:08:43,279
this

00:08:41,599 --> 00:08:45,680
where we have an await at the top level

00:08:43,279 --> 00:08:47,839
you can see it awaiting yards there

00:08:45,680 --> 00:08:49,519
we would have had to have had a function

00:08:47,839 --> 00:08:50,560
that we wrapped this in and then invoked

00:08:49,519 --> 00:08:52,839
that function

00:08:50,560 --> 00:08:54,560
having top level await is much more

00:08:52,839 --> 00:08:56,880
elegant

00:08:54,560 --> 00:08:57,920
the fact that ecmascript modules are a

00:08:56,880 --> 00:08:59,839
standard

00:08:57,920 --> 00:09:01,839
developed by the same standardization

00:08:59,839 --> 00:09:02,560
body that standardizes the javascript

00:09:01,839 --> 00:09:04,880
language

00:09:02,560 --> 00:09:06,560
is a huge benefit it guarantees that

00:09:04,880 --> 00:09:08,000
code we write in one place can work in

00:09:06,560 --> 00:09:09,440
another place if they're standards

00:09:08,000 --> 00:09:11,839
compliant

00:09:09,440 --> 00:09:13,760
here's an example from the simpsons of

00:09:11,839 --> 00:09:14,560
one of the pitfalls of not standardizing

00:09:13,760 --> 00:09:16,880
things

00:09:14,560 --> 00:09:18,720
in which patty attempts to plug a razor

00:09:16,880 --> 00:09:20,720
into a plug that has not followed a

00:09:18,720 --> 00:09:22,800
standard

00:09:20,720 --> 00:09:24,720
with a standard in place we can start to

00:09:22,800 --> 00:09:26,480
write javascript that we know will run

00:09:24,720 --> 00:09:28,880
on multiple platforms so we can write

00:09:26,480 --> 00:09:31,519
javascript that will work on node.js

00:09:28,880 --> 00:09:34,959
dino and all modern browsers with

00:09:31,519 --> 00:09:36,720
minimal changes to the underlying code

00:09:34,959 --> 00:09:38,399
at this point you're hopefully saying

00:09:36,720 --> 00:09:40,240
all right i'm sold i'd love to start

00:09:38,399 --> 00:09:41,519
using ecmascript modules inside of my

00:09:40,240 --> 00:09:43,920
projects

00:09:41,519 --> 00:09:45,519
but how do i do so in this part of the

00:09:43,920 --> 00:09:47,839
talk we're going to outline the two

00:09:45,519 --> 00:09:51,839
main paths that one can go down to adopt

00:09:47,839 --> 00:09:51,839
esm modules inside of their libraries

00:09:51,920 --> 00:09:55,440
the easiest approach you can take to

00:09:53,440 --> 00:09:57,519
start adopting pure esm

00:09:55,440 --> 00:09:59,600
is to quite simply switch to using

00:09:57,519 --> 00:10:00,880
ecmascript module syntax inside your

00:09:59,600 --> 00:10:03,040
libraries

00:10:00,880 --> 00:10:05,120
just switch to a dot mgs extension

00:10:03,040 --> 00:10:06,640
rather than the dot js extension on your

00:10:05,120 --> 00:10:08,800
library files

00:10:06,640 --> 00:10:10,560
or alternatively set the type module in

00:10:08,800 --> 00:10:11,200
your package json or in the case of the

00:10:10,560 --> 00:10:13,519
web

00:10:11,200 --> 00:10:15,440
type module in your script include and

00:10:13,519 --> 00:10:17,200
that's it you begin rating import and

00:10:15,440 --> 00:10:19,920
export statements using

00:10:17,200 --> 00:10:22,000
the new syntax and you'll have code that

00:10:19,920 --> 00:10:22,720
pretty much works in modern node.js

00:10:22,000 --> 00:10:24,800
versions

00:10:22,720 --> 00:10:25,760
and in the web and in platforms like

00:10:24,800 --> 00:10:28,320
dino

00:10:25,760 --> 00:10:30,399
there are some caveats however this will

00:10:28,320 --> 00:10:30,800
only work in newer versions of node.js

00:10:30,399 --> 00:10:33,920
so

00:10:30,800 --> 00:10:36,480
versions newer than 12 point x and it

00:10:33,920 --> 00:10:37,839
forces the hand of your dependents

00:10:36,480 --> 00:10:39,519
if they want to adopt the newest version

00:10:37,839 --> 00:10:40,320
of your library they'll also need to use

00:10:39,519 --> 00:10:41,680
esm

00:10:40,320 --> 00:10:45,120
or they'll have to use the somewhat

00:10:41,680 --> 00:10:47,040
clunky dynamic import syntax

00:10:45,120 --> 00:10:49,920
another option available to library

00:10:47,040 --> 00:10:54,000
authors rather than writing purely esm

00:10:49,920 --> 00:10:56,320
is to rate a dual esm common js module

00:10:54,000 --> 00:10:58,800
what this entails is the library author

00:10:56,320 --> 00:11:02,160
rating their library either in common js

00:10:58,800 --> 00:11:04,560
or ecmascript they then use a build tool

00:11:02,160 --> 00:11:06,320
such as rollup or babel to target the

00:11:04,560 --> 00:11:07,200
other flavor so if you've written common

00:11:06,320 --> 00:11:09,360
js

00:11:07,200 --> 00:11:10,399
the build tool will create ecmascript

00:11:09,360 --> 00:11:12,160
modules for you

00:11:10,399 --> 00:11:14,000
or if you've written ecmascript modules

00:11:12,160 --> 00:11:17,680
you'll use a build tool to target common

00:11:14,000 --> 00:11:19,440
js in your package.json you then use

00:11:17,680 --> 00:11:21,600
what's called an exports map

00:11:19,440 --> 00:11:23,360
to indicate what files should come in

00:11:21,600 --> 00:11:25,040
when you use a require statement

00:11:23,360 --> 00:11:27,360
versus what file should come in when you

00:11:25,040 --> 00:11:29,600
use an import statement

00:11:27,360 --> 00:11:31,360
some challenges and caveats that come up

00:11:29,600 --> 00:11:33,200
with this approach

00:11:31,360 --> 00:11:34,959
are that configuring the compiler to do

00:11:33,200 --> 00:11:36,959
this can be complicated

00:11:34,959 --> 00:11:38,240
configuring the exports map itself can

00:11:36,959 --> 00:11:40,480
be complicated

00:11:38,240 --> 00:11:42,000
and it increases the size of your module

00:11:40,480 --> 00:11:43,440
because you now actually just have two

00:11:42,000 --> 00:11:45,920
versions of your library in the same

00:11:43,440 --> 00:11:45,920
module

00:11:46,000 --> 00:11:50,079
what's nice about taking this approach

00:11:48,160 --> 00:11:52,079
is we can ship a version of the library

00:11:50,079 --> 00:11:54,000
that dependents can consume

00:11:52,079 --> 00:11:56,399
regardless of whether they themselves

00:11:54,000 --> 00:11:57,920
have adopted ecmascript modules yet or

00:11:56,399 --> 00:12:00,399
are still using common js

00:11:57,920 --> 00:12:00,399
modules

00:12:01,040 --> 00:12:05,519
given the option of migrating fully to

00:12:03,519 --> 00:12:07,519
ecmascript modules

00:12:05,519 --> 00:12:09,600
or trying to create a module that

00:12:07,519 --> 00:12:12,880
targets both common js

00:12:09,600 --> 00:12:13,440
and ecmascript modules yargs has opted

00:12:12,880 --> 00:12:17,040
for this

00:12:13,440 --> 00:12:17,040
dual module based approach

00:12:19,360 --> 00:12:23,120
our reasoning was as follows yards is

00:12:21,360 --> 00:12:24,560
one of the more dependent upon libraries

00:12:23,120 --> 00:12:27,920
in the node.js ecosystem

00:12:24,560 --> 00:12:29,519
with other over 24 000 folks using it

00:12:27,920 --> 00:12:31,600
we didn't want to force the hand of all

00:12:29,519 --> 00:12:33,519
these dependents by making them have to

00:12:31,600 --> 00:12:35,519
move to ecmascript to use the latest and

00:12:33,519 --> 00:12:36,800
greatest version of yargs

00:12:35,519 --> 00:12:38,959
rather we'd like them to be able to

00:12:36,800 --> 00:12:40,480
continue using common js still get our

00:12:38,959 --> 00:12:43,440
latest features

00:12:40,480 --> 00:12:45,040
but as they themselves move we provide a

00:12:43,440 --> 00:12:46,959
paved path for them to use the

00:12:45,040 --> 00:12:48,880
ecmascript version of yargs

00:12:46,959 --> 00:12:50,839
which with this dual approach is

00:12:48,880 --> 00:12:53,200
available within the exact same library

00:12:50,839 --> 00:12:55,120
version

00:12:53,200 --> 00:12:57,200
having said this because computers are

00:12:55,120 --> 00:12:58,880
hard there are actually multiple

00:12:57,200 --> 00:13:01,120
approaches one can take to creating one

00:12:58,880 --> 00:13:03,680
of these dual mode modules

00:13:01,120 --> 00:13:04,160
one such approach is if you're using

00:13:03,680 --> 00:13:06,560
pure

00:13:04,160 --> 00:13:08,720
ecmascript module format in your library

00:13:06,560 --> 00:13:10,560
or purecommon.js format

00:13:08,720 --> 00:13:11,920
is you can use a tool like rollup to

00:13:10,560 --> 00:13:14,480
target the alternative

00:13:11,920 --> 00:13:16,880
so as an example if you've written your

00:13:14,480 --> 00:13:18,639
library using ecmascript modules

00:13:16,880 --> 00:13:20,800
you have a rollup build step that

00:13:18,639 --> 00:13:21,680
creates a common js library version for

00:13:20,800 --> 00:13:23,839
you

00:13:21,680 --> 00:13:26,240
michael rogers has written a tool called

00:13:23,839 --> 00:13:27,920
ipjs which is meant to codify and

00:13:26,240 --> 00:13:29,120
simplify this process

00:13:27,920 --> 00:13:31,600
and is worth checking out if you're

00:13:29,120 --> 00:13:33,600
considering this approach

00:13:31,600 --> 00:13:35,760
another approach if you're writing your

00:13:33,600 --> 00:13:37,839
library in typescript

00:13:35,760 --> 00:13:39,680
is to take advantage of the fact that

00:13:37,839 --> 00:13:42,720
typescript itself can compile

00:13:39,680 --> 00:13:44,160
as an ecmascript module in this case

00:13:42,720 --> 00:13:45,839
you can have typescript compile the

00:13:44,160 --> 00:13:48,399
ecmascript module

00:13:45,839 --> 00:13:51,279
and then again use rollup to compile the

00:13:48,399 --> 00:13:53,760
common js version for you

00:13:51,279 --> 00:13:56,079
a third approach you can consider is

00:13:53,760 --> 00:13:57,760
that the javascript compiler babel has

00:13:56,079 --> 00:13:58,639
been adding similar functionality to

00:13:57,760 --> 00:14:00,880
rollup

00:13:58,639 --> 00:14:02,320
and additional compiler options that are

00:14:00,880 --> 00:14:04,320
meant to make it easier to create

00:14:02,320 --> 00:14:07,440
modules that work as dual mode

00:14:04,320 --> 00:14:08,399
ecmascript and common js modules there's

00:14:07,440 --> 00:14:12,480
a blog post

00:14:08,399 --> 00:14:14,000
linked here on this topic

00:14:12,480 --> 00:14:15,920
given that yarg's already used

00:14:14,000 --> 00:14:18,000
typescript in its code codebase

00:14:15,920 --> 00:14:20,320
we opted to go off the approach of using

00:14:18,000 --> 00:14:21,920
typescript in combination with rollup

00:14:20,320 --> 00:14:23,680
in a combination with an exports map

00:14:21,920 --> 00:14:26,959
which is needed to be used for

00:14:23,680 --> 00:14:30,000
all approaches to support a dual mode

00:14:26,959 --> 00:14:32,160
ecmascript common js module

00:14:30,000 --> 00:14:34,320
the approach we developed has the

00:14:32,160 --> 00:14:35,760
following steps in the build process we

00:14:34,320 --> 00:14:39,040
rely on a plugin called

00:14:35,760 --> 00:14:41,680
westberg slash rollup plugin ts

00:14:39,040 --> 00:14:43,440
this teaches roll up about typescript

00:14:41,680 --> 00:14:46,320
syntax

00:14:43,440 --> 00:14:48,000
so when you're compiling yargs we added

00:14:46,320 --> 00:14:50,480
an additional step

00:14:48,000 --> 00:14:51,920
that using this plugin takes an entry

00:14:50,480 --> 00:14:55,120
point in typescript

00:14:51,920 --> 00:14:58,160
and using rollup builds a bundle

00:14:55,120 --> 00:15:00,320
that's a single common js file

00:14:58,160 --> 00:15:02,560
that represents the entire code base of

00:15:00,320 --> 00:15:04,560
yarg so it's basically a

00:15:02,560 --> 00:15:07,680
combined file that has all of our

00:15:04,560 --> 00:15:07,680
library files in it

00:15:07,760 --> 00:15:11,040
along with adding this additional

00:15:09,120 --> 00:15:13,360
compilation step

00:15:11,040 --> 00:15:15,199
we updated our typescript configuration

00:15:13,360 --> 00:15:17,760
so that its module field

00:15:15,199 --> 00:15:19,279
targets es2020 which represents

00:15:17,760 --> 00:15:24,000
ecmascript modules

00:15:19,279 --> 00:15:27,199
rather than its default common js export

00:15:24,000 --> 00:15:29,040
thirdly we defined an exports map inside

00:15:27,199 --> 00:15:30,800
of our package json

00:15:29,040 --> 00:15:32,079
that explains to someone relying on our

00:15:30,800 --> 00:15:33,680
library

00:15:32,079 --> 00:15:35,839
what files should come in as a result of

00:15:33,680 --> 00:15:37,759
import versus what files should come in

00:15:35,839 --> 00:15:40,079
as a result of require

00:15:37,759 --> 00:15:40,959
it's worth mentioning that adding an

00:15:40,079 --> 00:15:42,480
exports map

00:15:40,959 --> 00:15:44,720
to your library should be considered a

00:15:42,480 --> 00:15:46,320
breaking change because it locks down

00:15:44,720 --> 00:15:48,639
within your library what files are

00:15:46,320 --> 00:15:49,920
accessible

00:15:48,639 --> 00:15:52,240
let's take a look at each of our

00:15:49,920 --> 00:15:52,639
configuration files the first example

00:15:52,240 --> 00:15:55,120
here

00:15:52,639 --> 00:15:56,480
is the config for our rollup compilation

00:15:55,120 --> 00:15:58,240
step

00:15:56,480 --> 00:16:01,040
things worth mentioning here are that

00:15:58,240 --> 00:16:02,959
our output format is commonjs

00:16:01,040 --> 00:16:04,160
we're using this rollup plugin

00:16:02,959 --> 00:16:06,639
typescript

00:16:04,160 --> 00:16:07,360
to actually perform the compilation and

00:16:06,639 --> 00:16:10,519
the third

00:16:07,360 --> 00:16:11,839
interesting thing is that we have this

00:16:10,519 --> 00:16:13,920
commonjs.ts

00:16:11,839 --> 00:16:16,000
import file that we created and this is

00:16:13,920 --> 00:16:18,079
just a tiny little file that is meant to

00:16:16,000 --> 00:16:20,320
make the bundle that rollup creates

00:16:18,079 --> 00:16:22,560
match as closely as possible prior

00:16:20,320 --> 00:16:25,680
releases of yards

00:16:22,560 --> 00:16:28,639
the next file shown here is our

00:16:25,680 --> 00:16:30,560
typescript configuration file the only

00:16:28,639 --> 00:16:32,519
real change that's important here

00:16:30,560 --> 00:16:34,560
is that we've switched the module to

00:16:32,519 --> 00:16:38,480
es2020 from its default

00:16:34,560 --> 00:16:38,480
common js build process

00:16:39,759 --> 00:16:44,399
finally here's our package.json with an

00:16:42,160 --> 00:16:47,360
example of an exports map

00:16:44,399 --> 00:16:48,639
we can see here that if you import the

00:16:47,360 --> 00:16:51,360
root of the library

00:16:48,639 --> 00:16:52,880
we're going to give you index.mjs and if

00:16:51,360 --> 00:16:55,120
you require the library we're going to

00:16:52,880 --> 00:16:59,040
give you index.cjs

00:16:55,120 --> 00:17:00,680
similarly if you require yarg helpers

00:16:59,040 --> 00:17:02,320
you're going to get helpers slash

00:17:00,680 --> 00:17:06,079
index.js and if you

00:17:02,320 --> 00:17:09,120
import yaric helpers you're going to get

00:17:06,079 --> 00:17:11,760
helpers helpers.mjs

00:17:09,120 --> 00:17:13,280
i've actually trimmed down our exports

00:17:11,760 --> 00:17:16,000
map a little bit to fit

00:17:13,280 --> 00:17:17,439
within a slide it's worth mentioning

00:17:16,000 --> 00:17:19,679
that this was definitely the most

00:17:17,439 --> 00:17:20,640
tricky part of getting our build process

00:17:19,679 --> 00:17:23,120
to work

00:17:20,640 --> 00:17:24,240
for instance we had to put the exports

00:17:23,120 --> 00:17:26,079
map in an array

00:17:24,240 --> 00:17:28,640
rather than an object to make it work on

00:17:26,079 --> 00:17:30,640
some versions of node 13

00:17:28,640 --> 00:17:32,160
and we even had to remove the extension

00:17:30,640 --> 00:17:34,400
from some of our files

00:17:32,160 --> 00:17:35,520
to trick node into loading it as a

00:17:34,400 --> 00:17:38,559
common js file

00:17:35,520 --> 00:17:39,679
rather than the default mjs file because

00:17:38,559 --> 00:17:42,880
we set our type

00:17:39,679 --> 00:17:46,000
in the package.json to module

00:17:42,880 --> 00:17:48,559
these caveats aside with this new build

00:17:46,000 --> 00:17:50,000
process in place we were able to ship a

00:17:48,559 --> 00:17:52,799
version of yards that

00:17:50,000 --> 00:17:54,880
pretty much worked both in common js and

00:17:52,799 --> 00:17:56,320
mjs as you'd expect

00:17:54,880 --> 00:17:59,200
so for someone who happened to be

00:17:56,320 --> 00:18:01,440
writing a hello.mjs file they could just

00:17:59,200 --> 00:18:02,400
import yargs as you'd expect and then

00:18:01,440 --> 00:18:05,679
use yards

00:18:02,400 --> 00:18:07,919
by invoking it with the arc v

00:18:05,679 --> 00:18:09,559
and if someone was still using common js

00:18:07,919 --> 00:18:12,320
in their module they can create a

00:18:09,559 --> 00:18:15,600
hello.cjs or a hello.js

00:18:12,320 --> 00:18:17,200
and instead require yards

00:18:15,600 --> 00:18:18,880
so now i've got a little bit of a show

00:18:17,200 --> 00:18:20,080
and tell to demonstrate some of the neat

00:18:18,880 --> 00:18:22,160
benefits that we get

00:18:20,080 --> 00:18:24,320
now that yargs has been migrated to

00:18:22,160 --> 00:18:26,400
supporting both ecmascript modules and

00:18:24,320 --> 00:18:27,760
common js modules

00:18:26,400 --> 00:18:31,679
here you can see i've implemented a

00:18:27,760 --> 00:18:33,520
command line interface in a web browser

00:18:31,679 --> 00:18:35,440
and so it works just the same as if you

00:18:33,520 --> 00:18:37,440
were typing into a command line

00:18:35,440 --> 00:18:38,640
in your terminal i can type help and get

00:18:37,440 --> 00:18:40,480
help output

00:18:38,640 --> 00:18:43,360
i have a command alert which will pop up

00:18:40,480 --> 00:18:45,840
an alert inside the web browser

00:18:43,360 --> 00:18:47,440
if we take a look now though at the

00:18:45,840 --> 00:18:51,280
actual source code that's

00:18:47,440 --> 00:18:51,280
allowing yards to run in the web browser

00:18:51,520 --> 00:18:54,559
what's so neat about it is that we

00:18:54,000 --> 00:18:57,360
actually

00:18:54,559 --> 00:19:00,080
just import yargs the same way we would

00:18:57,360 --> 00:19:02,720
import into our normal node.js module

00:19:00,080 --> 00:19:04,559
and we just do so inside of a module

00:19:02,720 --> 00:19:07,600
script tag in the browser

00:19:04,559 --> 00:19:09,760
so in some 40 lines of code

00:19:07,600 --> 00:19:12,400
we're able to have yarg's work

00:19:09,760 --> 00:19:15,600
identically to how to work in node.js

00:19:12,400 --> 00:19:16,480
inside of the web browser if we take a

00:19:15,600 --> 00:19:19,120
look at

00:19:16,480 --> 00:19:20,400
the files loading when we actually load

00:19:19,120 --> 00:19:22,080
this page

00:19:20,400 --> 00:19:24,160
what we would see is that it's actually

00:19:22,080 --> 00:19:25,360
identical files to

00:19:24,160 --> 00:19:27,360
what we see when we're running it in

00:19:25,360 --> 00:19:28,880
node.js so there's unlike in the past

00:19:27,360 --> 00:19:29,840
where you might have had a webpack build

00:19:28,880 --> 00:19:31,520
step

00:19:29,840 --> 00:19:33,679
there's no build step required we're

00:19:31,520 --> 00:19:37,120
able to just load all of the args esm

00:19:33,679 --> 00:19:37,120
dependencies right in the browser

00:19:37,520 --> 00:19:41,679
so in conclusion let's discuss some of

00:19:40,000 --> 00:19:44,400
the things that went well in this

00:19:41,679 --> 00:19:46,640
migration to add ecmascript module and

00:19:44,400 --> 00:19:47,919
common js module support drx

00:19:46,640 --> 00:19:49,679
and some of the things that didn't go

00:19:47,919 --> 00:19:52,160
well so

00:19:49,679 --> 00:19:54,000
in the good column we're successfully

00:19:52,160 --> 00:19:56,240
able to target multiple platforms with

00:19:54,000 --> 00:19:57,840
yards now without a build step so yargs

00:19:56,240 --> 00:19:59,919
works in dino now

00:19:57,840 --> 00:20:02,159
and as i showed in that demonstration

00:19:59,919 --> 00:20:03,440
yargs works in modern web browsers

00:20:02,159 --> 00:20:05,280
i think this is really exciting that

00:20:03,440 --> 00:20:06,480
we're able to target a wider number of

00:20:05,280 --> 00:20:08,480
platforms with yards

00:20:06,480 --> 00:20:10,559
without having to resort to a build

00:20:08,480 --> 00:20:12,400
process

00:20:10,559 --> 00:20:14,080
we're also seeing 10 million downloads a

00:20:12,400 --> 00:20:16,000
week now with these new versions that

00:20:14,080 --> 00:20:17,440
support ecmastrip modules and we've been

00:20:16,000 --> 00:20:19,280
getting minimal bugs

00:20:17,440 --> 00:20:20,880
related specifically to this migration

00:20:19,280 --> 00:20:23,120
so i think it shows that the migration

00:20:20,880 --> 00:20:25,600
has been successful

00:20:23,120 --> 00:20:28,080
we've also and i think most importantly

00:20:25,600 --> 00:20:29,120
created a path forward for yards 25 000

00:20:28,080 --> 00:20:31,120
dependents

00:20:29,120 --> 00:20:33,120
to gradually adopt ecmascript modules

00:20:31,120 --> 00:20:36,080
without having to stop using the latest

00:20:33,120 --> 00:20:38,799
and greatest version of yards

00:20:36,080 --> 00:20:39,919
in the bad column the complexity of our

00:20:38,799 --> 00:20:41,840
build process has increased

00:20:39,919 --> 00:20:42,720
significantly we now have a rollup build

00:20:41,840 --> 00:20:45,280
step

00:20:42,720 --> 00:20:46,640
as well as a typescript build step and

00:20:45,280 --> 00:20:48,960
we have to worry about how these things

00:20:46,640 --> 00:20:50,640
interact with each other

00:20:48,960 --> 00:20:52,240
the size of the args library is also

00:20:50,640 --> 00:20:54,159
increased because we now ship

00:20:52,240 --> 00:20:56,080
two versions of it one that supports

00:20:54,159 --> 00:20:58,480
common js and one sports that

00:20:56,080 --> 00:21:00,320
supports ecmascript modules so there's

00:20:58,480 --> 00:21:02,720
just a larger number of files that end

00:21:00,320 --> 00:21:06,159
up getting published npm

00:21:02,720 --> 00:21:07,840
in the ugly category it was very finicky

00:21:06,159 --> 00:21:09,440
and difficult to get our exports map

00:21:07,840 --> 00:21:11,440
working appropriately

00:21:09,440 --> 00:21:13,919
the core of the problem is that we're

00:21:11,440 --> 00:21:15,440
setting the type module field inside of

00:21:13,919 --> 00:21:18,159
our package json

00:21:15,440 --> 00:21:20,559
which indicates that js extension files

00:21:18,159 --> 00:21:23,039
should be treated as modules

00:21:20,559 --> 00:21:25,120
this in turn meant we had to do some

00:21:23,039 --> 00:21:27,919
weird shenanigans like dropping

00:21:25,120 --> 00:21:29,520
extensions from files to get them to

00:21:27,919 --> 00:21:31,280
load as javascript files in some

00:21:29,520 --> 00:21:33,200
contexts

00:21:31,280 --> 00:21:34,400
the reason we had to do these backflips

00:21:33,200 --> 00:21:36,960
falls under the other

00:21:34,400 --> 00:21:39,520
ugly problem we were running into which

00:21:36,960 --> 00:21:42,240
is that typescript does not yet support

00:21:39,520 --> 00:21:43,440
mgs extensions which meant that for our

00:21:42,240 --> 00:21:46,400
typescript build step

00:21:43,440 --> 00:21:47,760
we had to have js extensions which

00:21:46,400 --> 00:21:50,400
complicated our export maps

00:21:47,760 --> 00:21:50,400
significantly

00:21:50,480 --> 00:21:54,240
the final ugly thing i would say is that

00:21:52,240 --> 00:21:55,360
i was hopeful that now that we supported

00:21:54,240 --> 00:21:57,200
the web browser

00:21:55,360 --> 00:21:58,559
natively without a build step it would

00:21:57,200 --> 00:22:00,960
it would be easier for

00:21:58,559 --> 00:22:02,799
webpack and libraries of the sort to

00:22:00,960 --> 00:22:04,480
create bundles of yards

00:22:02,799 --> 00:22:06,240
we've actually been finding so far that

00:22:04,480 --> 00:22:07,840
there's been quite a few bugs related to

00:22:06,240 --> 00:22:10,320
trying to web pack the new version of

00:22:07,840 --> 00:22:10,320
yargs

00:22:10,640 --> 00:22:15,520
so when all said and done was it worth

00:22:13,679 --> 00:22:17,600
putting in all this extra work to make

00:22:15,520 --> 00:22:20,000
yarg support both common js and

00:22:17,600 --> 00:22:23,200
ecmascript modules

00:22:20,000 --> 00:22:25,039
my opinion is yes yards is dependent

00:22:23,200 --> 00:22:27,600
upon by many libraries

00:22:25,039 --> 00:22:29,200
and i think it's useful that we're able

00:22:27,600 --> 00:22:30,799
to help steward people towards

00:22:29,200 --> 00:22:32,720
ecmascript modules

00:22:30,799 --> 00:22:34,559
without them having to make the swap

00:22:32,720 --> 00:22:36,000
immediately

00:22:34,559 --> 00:22:38,080
my opinion is different if you're

00:22:36,000 --> 00:22:39,679
writing a brand new module as i said

00:22:38,080 --> 00:22:41,520
it adds a lot of complexity having this

00:22:39,679 --> 00:22:42,799
dual mode build process

00:22:41,520 --> 00:22:44,640
i think if i was writing a brand new

00:22:42,799 --> 00:22:46,559
library today i would actually probably

00:22:44,640 --> 00:22:47,600
consider writing it just an ecmascript

00:22:46,559 --> 00:22:49,520
module

00:22:47,600 --> 00:22:51,280
and then listen to the community and see

00:22:49,520 --> 00:22:53,440
if folks are pushing you to have a

00:22:51,280 --> 00:22:54,799
common js version so i wouldn't start

00:22:53,440 --> 00:22:55,840
immediately with this approach that

00:22:54,799 --> 00:22:57,520
yargs has taken

00:22:55,840 --> 00:22:59,600
i myself i'm going to be keeping an eye

00:22:57,520 --> 00:23:01,360
on how the node.js ecosystem adopts

00:22:59,600 --> 00:23:03,679
ecmascript modules

00:23:01,360 --> 00:23:06,000
and i'm going to be looking for ways to

00:23:03,679 --> 00:23:08,080
reduce yards's complexity over time

00:23:06,000 --> 00:23:10,480
so if a year from now it looks like 80

00:23:08,080 --> 00:23:12,000
of folks have adopted ecmascript modules

00:23:10,480 --> 00:23:14,720
i'm going to be considering removing the

00:23:12,000 --> 00:23:16,640
common js build step from yards

00:23:14,720 --> 00:23:18,159
i've included in this last slide some of

00:23:16,640 --> 00:23:20,000
the interesting reading i did when i was

00:23:18,159 --> 00:23:23,039
preparing this talk

00:23:20,000 --> 00:23:26,000
there's a great kind of early 2009

00:23:23,039 --> 00:23:27,919
discussion of what began what kind of

00:23:26,000 --> 00:23:30,000
kicked off ecmascript modules

00:23:27,919 --> 00:23:31,520
which is what server side javascript

00:23:30,000 --> 00:23:34,000
needs

00:23:31,520 --> 00:23:36,000
there's ryan dahl's original node.js

00:23:34,000 --> 00:23:37,760
talk where he presents node.js and talks

00:23:36,000 --> 00:23:41,440
about how it uses the common js

00:23:37,760 --> 00:23:43,600
module system there's my colleague john

00:23:41,440 --> 00:23:44,960
pulled together this great timeline of

00:23:43,600 --> 00:23:46,480
all the

00:23:44,960 --> 00:23:48,720
what was basically happening over the

00:23:46,480 --> 00:23:52,480
years as ecmascript evolved

00:23:48,720 --> 00:23:54,159
and this timeline was part of my reading

00:23:52,480 --> 00:23:56,240
uh sindra sorhus wrote a really good

00:23:54,159 --> 00:23:58,320
post on how they're migrating all of

00:23:56,240 --> 00:24:00,960
their modules over to esm i think this

00:23:58,320 --> 00:24:03,200
is also a great read

00:24:00,960 --> 00:24:04,799
and there's the blog post by babel about

00:24:03,200 --> 00:24:06,960
how they're trying to make a better esm

00:24:04,799 --> 00:24:09,039
cjs interop

00:24:06,960 --> 00:24:11,360
there's a blog post i wrote recently

00:24:09,039 --> 00:24:12,880
about how it's possible to do this dual

00:24:11,360 --> 00:24:14,640
mode module so that the

00:24:12,880 --> 00:24:17,039
ecmascript migration can be a little

00:24:14,640 --> 00:24:19,600
less disruptive for the community

00:24:17,039 --> 00:24:21,360
and finally require.js has a history of

00:24:19,600 --> 00:24:23,279
common js on their website which is an

00:24:21,360 --> 00:24:25,360
interesting read

00:24:23,279 --> 00:24:27,840
thank you so much for listening to me

00:24:25,360 --> 00:24:31,039
today it was a pleasure to be at

00:24:27,840 --> 00:24:33,360
openjs world 2021 i'll be available

00:24:31,039 --> 00:24:35,200
for q a please come with any additional

00:24:33,360 --> 00:24:36,400
questions that you have for me and i'm

00:24:35,200 --> 00:24:41,200
excited to talk to

00:24:36,400 --> 00:24:41,200

YouTube URL: https://www.youtube.com/watch?v=9CNVfD5jXsk


