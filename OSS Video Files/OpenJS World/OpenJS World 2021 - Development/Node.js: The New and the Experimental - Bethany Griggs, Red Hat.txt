Title: Node.js: The New and the Experimental - Bethany Griggs, Red Hat
Publication date: 2021-05-31
Playlist: OpenJS World 2021 - Development
Description: 
	Node.js: The New and the Experimental - Bethany Griggs, Red Hat
Node.js core does not have an official roadmap - it’s the sum of the interests and efforts of the contributors that determine the future of the project. The evolution of a new feature in Node.js can take different twists and turns. Some new features land as experimental, to give time to gather user feedback before they’re considered stable. Other features will land as stable from the start. So what’s in the pipeline?

Join the speaker for live Q&A on Slack: Thursday, June 3 from 02:20 - 02:40 PDT / 11:20 - 11:40 CEST, channel - #openjs_world-development
Captions: 
	00:00:00,000 --> 00:00:03,760
hi everyone my name is beth briggs and

00:00:02,000 --> 00:00:04,640
i'm a senior software engineer at red

00:00:03,760 --> 00:00:06,720
hat

00:00:04,640 --> 00:00:08,400
i game like fedora not long ago when i

00:00:06,720 --> 00:00:11,280
moved over from ibm

00:00:08,400 --> 00:00:11,920
and i'm excited to be here at my second

00:00:11,280 --> 00:00:15,200
virtual

00:00:11,920 --> 00:00:16,640
opengs world conference today my talk is

00:00:15,200 --> 00:00:20,000
titled node.js

00:00:16,640 --> 00:00:21,199
the new and the experimental as part of

00:00:20,000 --> 00:00:24,880
my role at red hat

00:00:21,199 --> 00:00:26,480
i helped to maintain the node.js runtime

00:00:24,880 --> 00:00:28,080
i'm a node.js technical steering

00:00:26,480 --> 00:00:29,679
committee member and i'm particularly

00:00:28,080 --> 00:00:30,400
active in the node.js release working

00:00:29,679 --> 00:00:32,559
group

00:00:30,400 --> 00:00:33,920
so i'm often spending my time looking at

00:00:32,559 --> 00:00:35,840
the content

00:00:33,920 --> 00:00:38,079
and producing the releases of the

00:00:35,840 --> 00:00:39,920
node.js runtime

00:00:38,079 --> 00:00:41,920
some of the other welcome involved in at

00:00:39,920 --> 00:00:43,120
redhat includes contributing to cloud

00:00:41,920 --> 00:00:44,879
development tooling

00:00:43,120 --> 00:00:47,360
and helping to build out a reference

00:00:44,879 --> 00:00:49,440
architecture for enterprise node.js

00:00:47,360 --> 00:00:51,920
applications

00:00:49,440 --> 00:00:52,719
today i want to spend some time talking

00:00:51,920 --> 00:00:54,879
about how

00:00:52,719 --> 00:00:56,239
new features get into the hands of

00:00:54,879 --> 00:00:58,000
node.js users

00:00:56,239 --> 00:01:00,000
and why some features land as

00:00:58,000 --> 00:01:01,760
experimental first

00:01:00,000 --> 00:01:03,520
in the latter half of the talk i'll

00:01:01,760 --> 00:01:06,000
touch upon a few

00:01:03,520 --> 00:01:09,439
recent new and experimental features

00:01:06,000 --> 00:01:09,439
that have landed in the wrong time

00:01:10,000 --> 00:01:14,640
node.js is an impact project under the

00:01:12,320 --> 00:01:16,159
openjs foundation

00:01:14,640 --> 00:01:17,680
formally the project was under the

00:01:16,159 --> 00:01:20,080
node.js foundation

00:01:17,680 --> 00:01:22,400
but the project moved under openjs when

00:01:20,080 --> 00:01:24,720
both the js and node foundations merged

00:01:22,400 --> 00:01:26,799
back in 2019

00:01:24,720 --> 00:01:29,439
and the openjs foundation is a neutral

00:01:26,799 --> 00:01:31,680
home for around 30 javascript projects

00:01:29,439 --> 00:01:34,079
from the likes of jquery electron node

00:01:31,680 --> 00:01:36,320
red to node.js itself

00:01:34,079 --> 00:01:38,000
and foundation values open governance

00:01:36,320 --> 00:01:41,840
transparency which is where it was a

00:01:38,000 --> 00:01:41,840
natural home for the no chess project

00:01:43,040 --> 00:01:47,840
you may be surprised to learn that the

00:01:45,119 --> 00:01:49,680
node.js project has no formal roadmap

00:01:47,840 --> 00:01:51,439
there's no prioritized task list there's

00:01:49,680 --> 00:01:52,840
no single corporate sponsor

00:01:51,439 --> 00:01:54,640
and the project is completely

00:01:52,840 --> 00:01:56,479
decentralized

00:01:54,640 --> 00:01:58,000
generally the features and changes that

00:01:56,479 --> 00:02:00,079
get added to the runtime are

00:01:58,000 --> 00:02:02,560
some of the interests and requirements

00:02:00,079 --> 00:02:05,200
of our contributors

00:02:02,560 --> 00:02:06,799
but what's it like not having a road map

00:02:05,200 --> 00:02:08,080
well i spent a short while trying to

00:02:06,799 --> 00:02:10,959
come up with a good analogy

00:02:08,080 --> 00:02:12,959
and i thought this one was appropriate

00:02:10,959 --> 00:02:13,440
this is a famous roundabout or turning

00:02:12,959 --> 00:02:16,000
circle

00:02:13,440 --> 00:02:17,840
in the uk it's actually made up of five

00:02:16,000 --> 00:02:18,959
smaller roundabouts all arranged in a

00:02:17,840 --> 00:02:20,959
circle

00:02:18,959 --> 00:02:22,879
and as you can see it handles a heavy

00:02:20,959 --> 00:02:24,400
flow of traffic heading in all different

00:02:22,879 --> 00:02:25,680
directions

00:02:24,400 --> 00:02:27,680
some cars are heading in the same

00:02:25,680 --> 00:02:29,200
direction others not and occasionally

00:02:27,680 --> 00:02:31,120
when the cars cross paths

00:02:29,200 --> 00:02:32,959
there are holdups and i think this

00:02:31,120 --> 00:02:34,239
somewhat represents future development

00:02:32,959 --> 00:02:36,239
of node.js

00:02:34,239 --> 00:02:38,480
there are a lot of contributors a lot of

00:02:36,239 --> 00:02:41,200
activity from all different

00:02:38,480 --> 00:02:42,640
areas some folks are heading in a

00:02:41,200 --> 00:02:44,239
similar direction

00:02:42,640 --> 00:02:45,680
whereas others are working on distinct

00:02:44,239 --> 00:02:48,720
parts of your project

00:02:45,680 --> 00:02:50,319
and inevitably sometimes things held up

00:02:48,720 --> 00:02:52,000
be that for technical reasons or the

00:02:50,319 --> 00:02:54,480
consensus needs to be reached on some

00:02:52,000 --> 00:02:56,000
details

00:02:54,480 --> 00:02:59,200
the main takeaway is that there's a

00:02:56,000 --> 00:03:01,280
heavy activity flow in the project

00:02:59,200 --> 00:03:02,800
that folks attending in numerous

00:03:01,280 --> 00:03:04,640
directions so it's not

00:03:02,800 --> 00:03:06,560
always obvious to see what is coming

00:03:04,640 --> 00:03:08,080
next

00:03:06,560 --> 00:03:10,560
so how can you find out what's in the

00:03:08,080 --> 00:03:11,920
pipeline there are a few ways you can

00:03:10,560 --> 00:03:13,280
keep track of what's happening in the

00:03:11,920 --> 00:03:15,480
project

00:03:13,280 --> 00:03:17,599
the project has a medium blog which is

00:03:15,480 --> 00:03:19,120
nodejs.medium.com

00:03:17,599 --> 00:03:21,440
where we post any of our major

00:03:19,120 --> 00:03:24,959
announcements there are twitter

00:03:21,440 --> 00:03:26,799
so node.js uh has its own twitter handle

00:03:24,959 --> 00:03:28,879
but there are also many of the

00:03:26,799 --> 00:03:29,920
active node.js contributors are also

00:03:28,879 --> 00:03:31,519
active on twitter

00:03:29,920 --> 00:03:33,840
so that's also a good place to follow

00:03:31,519 --> 00:03:35,519
what folks are working on

00:03:33,840 --> 00:03:38,159
and you can probably find some of those

00:03:35,519 --> 00:03:40,319
folks at this conference speaking too

00:03:38,159 --> 00:03:41,760
and also github you could follow the

00:03:40,319 --> 00:03:43,840
project on github and its many

00:03:41,760 --> 00:03:46,000
repositories

00:03:43,840 --> 00:03:48,000
but about the github notifications if

00:03:46,000 --> 00:03:50,080
you do subscribe to notecore

00:03:48,000 --> 00:03:52,640
and any of the other repositories be

00:03:50,080 --> 00:03:55,120
warned there is a lot of activity

00:03:52,640 --> 00:03:57,519
and it's really hard to keep up you can

00:03:55,120 --> 00:04:00,319
get several hundred notifications a day

00:03:57,519 --> 00:04:01,840
and admittedly i declare a notification

00:04:00,319 --> 00:04:03,360
bankruptcy every week or so and just

00:04:01,840 --> 00:04:04,720
mark everything is right

00:04:03,360 --> 00:04:06,720
i really do rely on like the

00:04:04,720 --> 00:04:09,840
participating notifications to keep

00:04:06,720 --> 00:04:12,840
track of what i need your address

00:04:09,840 --> 00:04:14,080
rather than keep up with the massive

00:04:12,840 --> 00:04:15,760
notifications

00:04:14,080 --> 00:04:17,359
there are some specific efforts you

00:04:15,760 --> 00:04:19,519
could follow

00:04:17,359 --> 00:04:20,639
so despite having no roadmap there are

00:04:19,519 --> 00:04:22,400
still

00:04:20,639 --> 00:04:24,560
longer-term efforts and planning within

00:04:22,400 --> 00:04:26,560
the project for example

00:04:24,560 --> 00:04:29,840
we have working groups dedicated to

00:04:26,560 --> 00:04:29,840
certain areas of the project

00:04:30,000 --> 00:04:35,759
and these groups act as task forces for

00:04:32,400 --> 00:04:37,199
pushing certain subject areas forward

00:04:35,759 --> 00:04:38,960
for example in the past we had a

00:04:37,199 --> 00:04:42,160
module's effort focused on driving the

00:04:38,960 --> 00:04:43,759
end script module's implementation

00:04:42,160 --> 00:04:46,080
as a note if you're looking to get

00:04:43,759 --> 00:04:47,759
involved in a project a good way is to

00:04:46,080 --> 00:04:49,840
look at these working groups

00:04:47,759 --> 00:04:51,840
see if any of them align with your

00:04:49,840 --> 00:04:54,320
interests and join one of them

00:04:51,840 --> 00:04:55,520
they all have github repositories with

00:04:54,320 --> 00:04:58,960
their own tasks

00:04:55,520 --> 00:05:02,639
and issues and many of them also have

00:04:58,960 --> 00:05:07,039
a publicly streamed video meetings

00:05:02,639 --> 00:05:07,039
that you're free to join and pass it in

00:05:07,120 --> 00:05:10,960
as well as teams and working groups the

00:05:08,800 --> 00:05:12,240
project also has what we call strategic

00:05:10,960 --> 00:05:14,320
initiatives

00:05:12,240 --> 00:05:16,560
uh these are agreed initiatives that the

00:05:14,320 --> 00:05:18,479
project hopes to make progress on

00:05:16,560 --> 00:05:20,000
again there's not really a priority list

00:05:18,479 --> 00:05:22,400
or deadline these are just some

00:05:20,000 --> 00:05:24,880
important goals we've listed

00:05:22,400 --> 00:05:26,800
and we think it would be useful to track

00:05:24,880 --> 00:05:28,800
the status on these over time

00:05:26,800 --> 00:05:31,120
and try and figure out ways we can help

00:05:28,800 --> 00:05:33,280
address these initiatives

00:05:31,120 --> 00:05:34,240
at the moment our technical initiatives

00:05:33,280 --> 00:05:38,240
include

00:05:34,240 --> 00:05:41,360
um promisifying the core apis a currency

00:05:38,240 --> 00:05:43,039
quick improving startup performance

00:05:41,360 --> 00:05:44,800
uh some initiatives around build

00:05:43,039 --> 00:05:47,280
resources and the future of the build

00:05:44,800 --> 00:05:47,280
torching

00:05:47,919 --> 00:05:54,160
and similarly uh under the community

00:05:51,680 --> 00:05:55,840
uh we have some more community focused

00:05:54,160 --> 00:05:57,319
strategic initiatives

00:05:55,840 --> 00:05:59,280
and it includes things like

00:05:57,319 --> 00:06:01,280
internationalization mentorship

00:05:59,280 --> 00:06:02,400
and others such as outreach and website

00:06:01,280 --> 00:06:04,960
redesign

00:06:02,400 --> 00:06:06,560
again these are good areas to look at if

00:06:04,960 --> 00:06:09,039
you're interested in getting involved in

00:06:06,560 --> 00:06:09,039
the project

00:06:09,600 --> 00:06:14,560
and one effort i'd like to call that in

00:06:11,199 --> 00:06:16,639
particular is the next 10 evan

00:06:14,560 --> 00:06:17,680
this team came together last year to

00:06:16,639 --> 00:06:20,560
focus on making

00:06:17,680 --> 00:06:22,479
the next 10 years there was no js is

00:06:20,560 --> 00:06:24,240
successful was the last

00:06:22,479 --> 00:06:25,759
so what we've done within this group is

00:06:24,240 --> 00:06:27,280
we've spent some time looking back on

00:06:25,759 --> 00:06:29,680
the successes of the project

00:06:27,280 --> 00:06:31,520
over the past decade and we've also

00:06:29,680 --> 00:06:34,400
tried to determine the values

00:06:31,520 --> 00:06:35,039
and constituencies of the project the

00:06:34,400 --> 00:06:37,520
idea

00:06:35,039 --> 00:06:40,240
is that we use these as a lens to

00:06:37,520 --> 00:06:42,639
analyze future development free

00:06:40,240 --> 00:06:44,479
and it may even help us identify which

00:06:42,639 --> 00:06:48,080
new features will bring the most value

00:06:44,479 --> 00:06:50,720
to the node.js users

00:06:48,080 --> 00:06:51,440
the next 10 group did put out a survey

00:06:50,720 --> 00:06:54,560
uh

00:06:51,440 --> 00:06:57,319
a couple of months back uh to

00:06:54,560 --> 00:06:59,759
confirm and validate that the

00:06:57,319 --> 00:07:00,720
constituencies and values we defined for

00:06:59,759 --> 00:07:03,680
the project

00:07:00,720 --> 00:07:04,880
did align with those of our users so we

00:07:03,680 --> 00:07:07,520
put this survey out

00:07:04,880 --> 00:07:09,599
and results are now back in so the next

00:07:07,520 --> 00:07:10,720
10 teams at the point of going for these

00:07:09,599 --> 00:07:12,800
results

00:07:10,720 --> 00:07:14,960
figuring out where we align and figuring

00:07:12,800 --> 00:07:17,440
out where we need to adjust

00:07:14,960 --> 00:07:19,599
so again while we do not have a roadmap

00:07:17,440 --> 00:07:20,880
we do look at things like survey results

00:07:19,599 --> 00:07:23,840
user feedback

00:07:20,880 --> 00:07:27,360
and many other aspects to indicate the

00:07:23,840 --> 00:07:27,360
future direction of the project

00:07:28,240 --> 00:07:32,240
so now some ways of keeping up to date

00:07:29,919 --> 00:07:34,240
with the project but typically

00:07:32,240 --> 00:07:36,000
our users will only find out about new

00:07:34,240 --> 00:07:38,960
features when they get into their hands

00:07:36,000 --> 00:07:40,560
finding releases

00:07:38,960 --> 00:07:42,400
and there's a distinct flow in which you

00:07:40,560 --> 00:07:44,400
can expect new features to arrive in

00:07:42,400 --> 00:07:46,319
node.js releases

00:07:44,400 --> 00:07:48,479
node.js has a predictable release

00:07:46,319 --> 00:07:50,479
schedule we always have two major

00:07:48,479 --> 00:07:52,000
releases per year with the even number

00:07:50,479 --> 00:07:53,440
of release lines being promoted to

00:07:52,000 --> 00:07:55,039
long-term support

00:07:53,440 --> 00:07:57,280
the even number of releases are always

00:07:55,039 --> 00:07:59,039
released in april and promoted in

00:07:57,280 --> 00:08:01,599
to long-term support in the following

00:07:59,039 --> 00:08:01,599
october

00:08:01,919 --> 00:08:07,520
within our release schedule we have

00:08:03,919 --> 00:08:09,759
three defined release phases

00:08:07,520 --> 00:08:10,879
current active long-term support and

00:08:09,759 --> 00:08:12,560
maintenance

00:08:10,879 --> 00:08:14,240
and it's during the current phase that

00:08:12,560 --> 00:08:15,759
the release line will pick up most of

00:08:14,240 --> 00:08:17,919
the non-major

00:08:15,759 --> 00:08:19,520
changes that land on node.js call main

00:08:17,919 --> 00:08:21,360
branch

00:08:19,520 --> 00:08:23,120
during the active long-term support

00:08:21,360 --> 00:08:26,000
phase only new features

00:08:23,120 --> 00:08:27,919
fixes and updates that have been ordered

00:08:26,000 --> 00:08:29,599
by the lgs team

00:08:27,919 --> 00:08:32,080
and have been considered appropriate and

00:08:29,599 --> 00:08:34,399
stable land

00:08:32,080 --> 00:08:36,080
and in maintenance that tends to be

00:08:34,399 --> 00:08:37,839
limited to critical bug fixes and

00:08:36,080 --> 00:08:40,000
security updates only

00:08:37,839 --> 00:08:41,360
we rarely add new features but we might

00:08:40,000 --> 00:08:43,200
if we

00:08:41,360 --> 00:08:45,440
come to the agreement that adding this

00:08:43,200 --> 00:08:47,440
new feature is beneficial

00:08:45,440 --> 00:08:49,440
and will help support migration to later

00:08:47,440 --> 00:08:51,440
release lines

00:08:49,440 --> 00:08:53,200
so you can expect to pick up the newest

00:08:51,440 --> 00:08:57,519
features first in the current release

00:08:53,200 --> 00:08:59,440
line which at the moment is node.js 16.

00:08:57,519 --> 00:09:03,040
and typically for current you can expect

00:08:59,440 --> 00:09:03,040
about one release every two weeks

00:09:03,440 --> 00:09:07,040
after some time you can then expect the

00:09:05,600 --> 00:09:08,399
new features that have landed in the

00:09:07,040 --> 00:09:11,519
current release line

00:09:08,399 --> 00:09:13,200
to come back into the long term support

00:09:11,519 --> 00:09:14,959
but not all the features will make it

00:09:13,200 --> 00:09:15,519
back into long-term supported release

00:09:14,959 --> 00:09:17,519
lines

00:09:15,519 --> 00:09:18,800
some will be considered too unstable to

00:09:17,519 --> 00:09:20,480
be brought back

00:09:18,800 --> 00:09:22,000
and sometimes the code delta in the

00:09:20,480 --> 00:09:23,680
release lines it's just too large

00:09:22,000 --> 00:09:26,320
to be able to feasibly bring that

00:09:23,680 --> 00:09:26,320
feature back

00:09:27,600 --> 00:09:31,440
and if you're interested uh the node.js

00:09:30,080 --> 00:09:34,640
release working group does

00:09:31,440 --> 00:09:36,800
keep a draft schedule of

00:09:34,640 --> 00:09:38,959
the upcoming releases in the node.js

00:09:36,800 --> 00:09:41,360
release repository and github

00:09:38,959 --> 00:09:43,200
uh so if you ever just want to gauge

00:09:41,360 --> 00:09:45,519
roughly when the next release will be

00:09:43,200 --> 00:09:47,040
on each of the given release lines check

00:09:45,519 --> 00:09:48,080
out these issues and you should get an

00:09:47,040 --> 00:09:50,080
indication

00:09:48,080 --> 00:09:52,880
all of them of course subject to release

00:09:50,080 --> 00:09:54,720
availability

00:09:52,880 --> 00:09:56,080
and two things i'd like to call out from

00:09:54,720 --> 00:09:59,200
the release schedule uh

00:09:56,080 --> 00:10:01,680
is node.js 10 is now end of life it went

00:09:59,200 --> 00:10:04,959
end of life at the end of april 2021

00:10:01,680 --> 00:10:07,040
so if you're using that be aware that uh

00:10:04,959 --> 00:10:08,800
there are no more security fixes being

00:10:07,040 --> 00:10:10,399
given to that release line

00:10:08,800 --> 00:10:12,480
so if you are on it you should start

00:10:10,399 --> 00:10:14,800
planning to upgrade

00:10:12,480 --> 00:10:17,040
and in case you missed it note 16 was

00:10:14,800 --> 00:10:19,680
released in april

00:10:17,040 --> 00:10:21,440
node.js 16 is at the moment our current

00:10:19,680 --> 00:10:25,440
release line but will be promoted to

00:10:21,440 --> 00:10:25,440
long-term support this coming october

00:10:25,760 --> 00:10:30,560
and if you're interested in learning

00:10:27,440 --> 00:10:32,240
what was included in the hs16 release

00:10:30,560 --> 00:10:34,880
you can check out the release

00:10:32,240 --> 00:10:36,959
announcement on the node.js medium

00:10:34,880 --> 00:10:38,720
and it details some of the new features

00:10:36,959 --> 00:10:40,320
and highlights of the release

00:10:38,720 --> 00:10:41,760
one of the highlights which isn't really

00:10:40,320 --> 00:10:44,959
cast as a new feature

00:10:41,760 --> 00:10:45,360
was uh late 16 marks the first release

00:10:44,959 --> 00:10:47,519
line

00:10:45,360 --> 00:10:49,200
we are shipping pre-built binaries for

00:10:47,519 --> 00:10:50,880
apple silicon

00:10:49,200 --> 00:10:52,800
and just like to call out the build

00:10:50,880 --> 00:10:53,760
working group invested a lot of effort

00:10:52,800 --> 00:10:56,000
into this

00:10:53,760 --> 00:10:57,839
it requires a lot of hidden work to get

00:10:56,000 --> 00:10:59,440
these uh binaries built and made

00:10:57,839 --> 00:11:01,600
available to our users

00:10:59,440 --> 00:11:02,640
from finding donors or hosts for our

00:11:01,600 --> 00:11:04,320
build hardware

00:11:02,640 --> 00:11:05,920
to configuring the machines using

00:11:04,320 --> 00:11:07,920
ansible

00:11:05,920 --> 00:11:10,640
uh to integrating those machines into

00:11:07,920 --> 00:11:12,800
our continuous integration farm

00:11:10,640 --> 00:11:13,680
without disrupting any of our profit

00:11:12,800 --> 00:11:15,839
pipelines

00:11:13,680 --> 00:11:18,000
and so just like to thank max stadium

00:11:15,839 --> 00:11:21,120
and also neoform for helping us

00:11:18,000 --> 00:11:23,440
source these apple silicon machines and

00:11:21,120 --> 00:11:25,279
hosting them for us

00:11:23,440 --> 00:11:27,440
and just call out the hidden effort that

00:11:25,279 --> 00:11:29,440
goes into keeping the project running

00:11:27,440 --> 00:11:32,800
which may not necessarily be reflected

00:11:29,440 --> 00:11:32,800
in prs or commit lists

00:11:33,680 --> 00:11:37,040
that's a bit about how you can follow

00:11:35,120 --> 00:11:38,720
what's coming next and how features end

00:11:37,040 --> 00:11:42,160
up in the various release lines

00:11:38,720 --> 00:11:43,920
what about new features

00:11:42,160 --> 00:11:47,760
how do you know when a feature is safe

00:11:43,920 --> 00:11:50,240
to use in your production applications

00:11:47,760 --> 00:11:51,440
but notice project provides a stability

00:11:50,240 --> 00:11:53,680
index

00:11:51,440 --> 00:11:56,959
throughout the api documentation there

00:11:53,680 --> 00:11:59,200
are indicators of stability for each api

00:11:56,959 --> 00:12:00,320
at the moment there are four stability

00:11:59,200 --> 00:12:03,120
levels

00:12:00,320 --> 00:12:04,480
stability zero deprecated stability one

00:12:03,120 --> 00:12:08,000
experimental

00:12:04,480 --> 00:12:10,240
stability two stable and

00:12:08,000 --> 00:12:11,680
stability three legacy which has only

00:12:10,240 --> 00:12:15,600
recently been added

00:12:11,680 --> 00:12:18,240
so digging into those specific

00:12:15,600 --> 00:12:19,120
0 deprecated an api can be the

00:12:18,240 --> 00:12:22,959
documentation

00:12:19,120 --> 00:12:25,440
or runtime deprecated as you can expect

00:12:22,959 --> 00:12:28,000
a documentation deprecation is just that

00:12:25,440 --> 00:12:29,920
an indication in the api docs that given

00:12:28,000 --> 00:12:31,600
api is deprecated

00:12:29,920 --> 00:12:33,760
and this is an example of the

00:12:31,600 --> 00:12:36,079
deprecation of socket buffer size

00:12:33,760 --> 00:12:39,200
includes a deprecation id the version

00:12:36,079 --> 00:12:41,760
that introduced deprecation

00:12:39,200 --> 00:12:44,720
and documentation deprecations can land

00:12:41,760 --> 00:12:46,800
in minor releases of node

00:12:44,720 --> 00:12:48,399
it's good to be aware of these because

00:12:46,800 --> 00:12:50,839
the deprecated apis

00:12:48,399 --> 00:12:52,880
may be removed in future versions of

00:12:50,839 --> 00:12:54,560
node.js

00:12:52,880 --> 00:12:56,079
and because the documentation

00:12:54,560 --> 00:12:58,800
deprecations are

00:12:56,079 --> 00:13:01,040
just that written in the documentation

00:12:58,800 --> 00:13:04,079
it can be difficult to know or follow

00:13:01,040 --> 00:13:06,800
what is being deprecated over time

00:13:04,079 --> 00:13:08,000
the nodejs does provide a pending

00:13:06,800 --> 00:13:11,519
deprecation

00:13:08,000 --> 00:13:12,480
process flag so some documentation only

00:13:11,519 --> 00:13:14,720
deprecations

00:13:12,480 --> 00:13:16,480
will trigger a runtime warning when

00:13:14,720 --> 00:13:18,639
launched with this flag

00:13:16,480 --> 00:13:20,240
so if you want to see whether you're

00:13:18,639 --> 00:13:23,519
using any of

00:13:20,240 --> 00:13:25,279
the deprecated apis you can start your

00:13:23,519 --> 00:13:26,639
node process with this flag

00:13:25,279 --> 00:13:28,480
and you should start to see warnings

00:13:26,639 --> 00:13:32,480
coming through if you are using

00:13:28,480 --> 00:13:35,040
an api that's amount for deprecation

00:13:32,480 --> 00:13:36,320
we also have runtime deprecations a

00:13:35,040 --> 00:13:38,800
runtime deprecation

00:13:36,320 --> 00:13:40,880
will by default generate a process

00:13:38,800 --> 00:13:41,279
warning that will be printed to standard

00:13:40,880 --> 00:13:43,760
error

00:13:41,279 --> 00:13:45,199
the first time the deprecated api is

00:13:43,760 --> 00:13:46,800
used

00:13:45,199 --> 00:13:48,880
this here is an example one that may be

00:13:46,800 --> 00:13:49,600
familiar the unhandled promise rejection

00:13:48,880 --> 00:13:52,079
warning

00:13:49,600 --> 00:13:52,639
that you may have found familiar node

00:13:52,079 --> 00:13:56,079
versions

00:13:52,639 --> 00:13:58,000
14 and under and because

00:13:56,079 --> 00:13:59,760
a runtime warning is an observable

00:13:58,000 --> 00:14:01,680
change it actually prints something to

00:13:59,760 --> 00:14:04,399
standard hour

00:14:01,680 --> 00:14:05,440
we treat all of these as major or

00:14:04,399 --> 00:14:07,519
breaking changes

00:14:05,440 --> 00:14:09,199
this is because it could break anyone

00:14:07,519 --> 00:14:10,959
who's running their tests and testing

00:14:09,199 --> 00:14:13,279
standard error output

00:14:10,959 --> 00:14:15,600
so generally you should only see new

00:14:13,279 --> 00:14:18,720
runtime deprecation when upgrading

00:14:15,600 --> 00:14:20,560
to a new major version and ideally an

00:14:18,720 --> 00:14:22,800
api will first be documentation

00:14:20,560 --> 00:14:24,480
deprecated and then elevated to a

00:14:22,800 --> 00:14:25,760
runtime deprecation

00:14:24,480 --> 00:14:28,480
and there are a couple of further

00:14:25,760 --> 00:14:31,839
process related flags

00:14:28,480 --> 00:14:33,440
we have the no deprecation flag and what

00:14:31,839 --> 00:14:35,839
this does is it silences

00:14:33,440 --> 00:14:37,120
all the deprecation warnings and you

00:14:35,839 --> 00:14:39,279
should really be cautious

00:14:37,120 --> 00:14:41,279
uh using this as you're likely just

00:14:39,279 --> 00:14:44,320
silencing a problem that will need to be

00:14:41,279 --> 00:14:44,800
fixed a deprecated api that's emitting a

00:14:44,320 --> 00:14:47,120
warning

00:14:44,800 --> 00:14:48,959
may end up being removed so by using

00:14:47,120 --> 00:14:51,360
this uh regularly you're essentially

00:14:48,959 --> 00:14:53,839
just taking your problem down the road

00:14:51,360 --> 00:14:56,399
and there's also the throw deprecation

00:14:53,839 --> 00:14:57,760
and that takes a more extreme state of

00:14:56,399 --> 00:15:00,240
throwing an error when you hit a

00:14:57,760 --> 00:15:02,160
deprecation one and i personally would

00:15:00,240 --> 00:15:04,399
treat these as kind of like smoke test

00:15:02,160 --> 00:15:05,839
i just occasionally run my apps with

00:15:04,399 --> 00:15:08,079
these to

00:15:05,839 --> 00:15:09,440
to see whether any new applications have

00:15:08,079 --> 00:15:12,959
been introduced

00:15:09,440 --> 00:15:15,440
will impact my project then we have the

00:15:12,959 --> 00:15:19,120
legacy stability status

00:15:15,440 --> 00:15:21,680
and what the legacy status covers

00:15:19,120 --> 00:15:22,240
is apis that we want to discourage the

00:15:21,680 --> 00:15:25,519
use of

00:15:22,240 --> 00:15:27,199
without breaking the ecosystem so

00:15:25,519 --> 00:15:28,959
if you are writing new code you

00:15:27,199 --> 00:15:31,040
shouldn't use the legacy apis

00:15:28,959 --> 00:15:32,720
but if you do have applications that are

00:15:31,040 --> 00:15:34,560
still using these apis

00:15:32,720 --> 00:15:36,800
you can be confident that the project's

00:15:34,560 --> 00:15:40,399
unlikely to remove them

00:15:36,800 --> 00:15:43,680
apis that have been indicated as legacy

00:15:40,399 --> 00:15:46,800
include a number of the assert

00:15:43,680 --> 00:15:48,720
apis such as deep equal

00:15:46,800 --> 00:15:51,680
this is because you should be using the

00:15:48,720 --> 00:15:54,480
strict version of each of these

00:15:51,680 --> 00:15:55,360
apis where possible there is a slight

00:15:54,480 --> 00:15:58,320
caveat

00:15:55,360 --> 00:15:59,040
if you are using the strict mode over

00:15:58,320 --> 00:16:02,240
set

00:15:59,040 --> 00:16:03,040
then it's okay to use the equal it's

00:16:02,240 --> 00:16:06,800
only

00:16:03,040 --> 00:16:11,440
the non-strict mode non-strict

00:16:06,800 --> 00:16:13,680
apis that are marked as legacy but again

00:16:11,440 --> 00:16:14,880
they're indicated as legacy as we don't

00:16:13,680 --> 00:16:17,199
plan to remove them

00:16:14,880 --> 00:16:19,839
because we think it will cause too much

00:16:17,199 --> 00:16:19,839
disruption

00:16:19,920 --> 00:16:24,320
also the atob and btoa

00:16:24,720 --> 00:16:29,360
apis they're also legacy

00:16:29,519 --> 00:16:33,680
and then some others include process hr

00:16:32,560 --> 00:16:37,519
time

00:16:33,680 --> 00:16:40,639
the query string module and the url ipi

00:16:37,519 --> 00:16:41,279
and for the url api you should be using

00:16:40,639 --> 00:16:46,880
the

00:16:41,279 --> 00:16:46,880
newer wg url api instead

00:16:46,959 --> 00:16:52,639
so on to experimental features

00:16:50,160 --> 00:16:54,160
no chess project stability index states

00:16:52,639 --> 00:16:56,800
that experimental apis

00:16:54,160 --> 00:16:58,880
may change behavior the traditional

00:16:56,800 --> 00:16:59,839
semantic version contract that we try to

00:16:58,880 --> 00:17:01,839
adhere to

00:16:59,839 --> 00:17:03,279
everywhere else does not apply to

00:17:01,839 --> 00:17:05,919
experimental features

00:17:03,279 --> 00:17:07,600
even in long-term supported releases and

00:17:05,919 --> 00:17:09,919
this is why we tend to say

00:17:07,600 --> 00:17:11,919
use experimental features with caution

00:17:09,919 --> 00:17:16,720
especially in production workloads

00:17:11,919 --> 00:17:18,240
because the api may change even in lts

00:17:16,720 --> 00:17:20,559
and why do some features landers

00:17:18,240 --> 00:17:22,959
experiment when others don't

00:17:20,559 --> 00:17:23,679
well in some cases the most suitable api

00:17:22,959 --> 00:17:26,400
design

00:17:23,679 --> 00:17:27,919
may not be agreed upon upfront we may

00:17:26,400 --> 00:17:29,760
want to get almost a draft of the

00:17:27,919 --> 00:17:30,720
feature out there so we can get user

00:17:29,760 --> 00:17:33,919
feedback

00:17:30,720 --> 00:17:35,679
and evolve the api accordingly

00:17:33,919 --> 00:17:39,919
and so essentially we just don't want to

00:17:35,679 --> 00:17:39,919
lock the api definition in too soon

00:17:40,880 --> 00:17:43,919
and there are a number of whole core

00:17:42,240 --> 00:17:46,000
modules in mode that are still

00:17:43,919 --> 00:17:47,440
designated as experimental

00:17:46,000 --> 00:17:48,799
and when i say core modules i'm

00:17:47,440 --> 00:17:50,320
referring to the ones that are built

00:17:48,799 --> 00:17:54,080
into the runtime itself

00:17:50,320 --> 00:17:56,679
like fs and http and all of these are

00:17:54,080 --> 00:18:01,360
still experimental as of note

00:17:56,679 --> 00:18:03,840
1610 so one of the first experimental

00:18:01,360 --> 00:18:05,200
uh core modules is the async hooks

00:18:03,840 --> 00:18:07,760
module

00:18:05,200 --> 00:18:08,480
the asynchronous module provides an api

00:18:07,760 --> 00:18:10,640
for you to track

00:18:08,480 --> 00:18:12,080
asynchronous resource what's an

00:18:10,640 --> 00:18:14,080
asynchronous resource

00:18:12,080 --> 00:18:16,240
these are things like promises timeouts

00:18:14,080 --> 00:18:18,559
immediates and ticks

00:18:16,240 --> 00:18:20,400
and in particular within this

00:18:18,559 --> 00:18:22,960
experimental module i'd like to call out

00:18:20,400 --> 00:18:24,880
the async local storage class

00:18:22,960 --> 00:18:26,880
and this class is used to create

00:18:24,880 --> 00:18:28,640
asynchronous state within callbacks and

00:18:26,880 --> 00:18:30,880
promise chains

00:18:28,640 --> 00:18:33,039
and this example simulates how it might

00:18:30,880 --> 00:18:35,360
be used within a web server

00:18:33,039 --> 00:18:36,640
so you'd initialize the async local

00:18:35,360 --> 00:18:38,960
storage

00:18:36,640 --> 00:18:40,480
within our server handler we call async

00:18:38,960 --> 00:18:42,960
local storage run

00:18:40,480 --> 00:18:45,440
and what this will do is create an async

00:18:42,960 --> 00:18:48,640
local context for each flow

00:18:45,440 --> 00:18:51,679
and so within our log request with id

00:18:48,640 --> 00:18:53,200
function when we call get store it will

00:18:51,679 --> 00:18:54,960
be able to pull out the id of the

00:18:53,200 --> 00:18:58,240
request

00:18:54,960 --> 00:19:00,480
so the get store returns the values

00:18:58,240 --> 00:19:01,919
specific to the async flow the orders

00:19:00,480 --> 00:19:04,000
are relevant it will always get the

00:19:01,919 --> 00:19:07,039
right one for that async context

00:19:04,000 --> 00:19:10,400
and this is particularly useful for um

00:19:07,039 --> 00:19:12,240
application performance monitoring

00:19:10,400 --> 00:19:14,080
and there are also discussions within

00:19:12,240 --> 00:19:14,799
the project at the moment about whether

00:19:14,080 --> 00:19:17,840
it's

00:19:14,799 --> 00:19:20,400
the right time to elevate async local

00:19:17,840 --> 00:19:23,679
storage to stable status

00:19:20,400 --> 00:19:27,120
another experimental module is the

00:19:23,679 --> 00:19:27,679
diagnostics channel the diagnostics

00:19:27,120 --> 00:19:30,480
channel

00:19:27,679 --> 00:19:32,480
module provides an api to create name

00:19:30,480 --> 00:19:34,400
channels to report message data for

00:19:32,480 --> 00:19:36,880
diagnostic purposes

00:19:34,400 --> 00:19:38,320
and the intention is that you create

00:19:36,880 --> 00:19:39,440
numerous channels to report your

00:19:38,320 --> 00:19:41,039
messages through

00:19:39,440 --> 00:19:43,600
and then you can subscribe to receive

00:19:41,039 --> 00:19:46,080
those messages and the use case for this

00:19:43,600 --> 00:19:49,360
is say you have an app that runs some

00:19:46,080 --> 00:19:50,799
sql queries you could create a dedicated

00:19:49,360 --> 00:19:52,960
channel for those to be

00:19:50,799 --> 00:19:55,200
pushed to and you could subscribe to

00:19:52,960 --> 00:19:57,520
that same channel to receive them

00:19:55,200 --> 00:19:59,679
and just like call out this was recently

00:19:57,520 --> 00:20:02,480
brought back to the note 14 release line

00:19:59,679 --> 00:20:05,360
so the latest note 14 release

00:20:02,480 --> 00:20:05,360
will include this

00:20:05,760 --> 00:20:09,200
and then we have the experimental

00:20:07,679 --> 00:20:10,640
inspector module

00:20:09,200 --> 00:20:12,799
as the name suggests this module

00:20:10,640 --> 00:20:14,720
provides an api for interacting with the

00:20:12,799 --> 00:20:16,720
va inspector

00:20:14,720 --> 00:20:20,000
and in this example we're using the

00:20:16,720 --> 00:20:22,000
inspector module to interact with the

00:20:20,000 --> 00:20:23,440
inspector programmatically to profile

00:20:22,000 --> 00:20:25,200
cpu

00:20:23,440 --> 00:20:27,039
and the way you use this you've required

00:20:25,200 --> 00:20:27,679
modules you initialize an inspector

00:20:27,039 --> 00:20:31,120
session

00:20:27,679 --> 00:20:32,960
you select enable and start the profiler

00:20:31,120 --> 00:20:34,720
you then run the code or task that you

00:20:32,960 --> 00:20:38,480
wish to measure and then you stop the

00:20:34,720 --> 00:20:38,480
profile and write results somewhere

00:20:38,799 --> 00:20:42,480
similarly we have the experimental trace

00:20:41,039 --> 00:20:45,039
events module

00:20:42,480 --> 00:20:47,360
and this module provides a mechanism for

00:20:45,039 --> 00:20:50,720
you to centralize tracing information

00:20:47,360 --> 00:20:52,080
generated by v8 node core and even your

00:20:50,720 --> 00:20:54,000
own application code

00:20:52,080 --> 00:20:56,720
and again it's a case of importing the

00:20:54,000 --> 00:20:58,960
module enabling and disabling the trace

00:20:56,720 --> 00:21:01,120
at the appropriate point in your code

00:20:58,960 --> 00:21:02,880
and the output of this will be a trace

00:21:01,120 --> 00:21:06,400
log file that you can open

00:21:02,880 --> 00:21:08,240
in the frame tracing window

00:21:06,400 --> 00:21:09,520
and then we have the experimental web

00:21:08,240 --> 00:21:11,600
crypto api

00:21:09,520 --> 00:21:12,559
this is an implementation with the node

00:21:11,600 --> 00:21:16,000
of the

00:21:12,559 --> 00:21:17,840
web crypto api

00:21:16,000 --> 00:21:20,000
we also have the experimental web

00:21:17,840 --> 00:21:21,840
assembly system interface core module

00:21:20,000 --> 00:21:25,919
and this provides an implementation of

00:21:21,840 --> 00:21:25,919
the wazi specification

00:21:27,360 --> 00:21:31,760
so that's the experimental cool modules

00:21:29,679 --> 00:21:36,159
but we also have some notable individual

00:21:31,760 --> 00:21:36,159
apis that are designated as experimental

00:21:37,039 --> 00:21:41,520
as you may know the node.js atmosphere

00:21:39,200 --> 00:21:43,200
modules implementation is now stable in

00:21:41,520 --> 00:21:44,159
all currently supported versions of

00:21:43,200 --> 00:21:46,640
node.js

00:21:44,159 --> 00:21:48,240
it's doubling node 12 node 14 and load

00:21:46,640 --> 00:21:49,840
16.

00:21:48,240 --> 00:21:52,000
but although the underlying

00:21:49,840 --> 00:21:53,520
implementation is now stable across all

00:21:52,000 --> 00:21:55,600
release lines

00:21:53,520 --> 00:21:57,280
there are still some specific apis

00:21:55,600 --> 00:22:00,159
related to esm

00:21:57,280 --> 00:22:02,159
that's still designated as experimental

00:22:00,159 --> 00:22:04,400
this includes the loaders api

00:22:02,159 --> 00:22:06,799
the loaders api is used to customize the

00:22:04,400 --> 00:22:10,559
default module resolution algorithm

00:22:06,799 --> 00:22:13,600
so you can optionally supply your own

00:22:10,559 --> 00:22:15,600
custom loader and it will customize how

00:22:13,600 --> 00:22:17,280
the atmosphere modules are loaded

00:22:15,600 --> 00:22:20,000
note that it will not change anything to

00:22:17,280 --> 00:22:21,679
do with how common js modules are loaded

00:22:20,000 --> 00:22:23,200
and there's actually been a new team

00:22:21,679 --> 00:22:26,159
kicked off within the project

00:22:23,200 --> 00:22:28,240
to focus on defining the specification

00:22:26,159 --> 00:22:30,000
so that eventually we can reach a stable

00:22:28,240 --> 00:22:32,640
implementation

00:22:30,000 --> 00:22:34,799
two of the other experimental esm apis

00:22:32,640 --> 00:22:37,919
include json modules

00:22:34,799 --> 00:22:37,919
and whatsapp modules

00:22:38,000 --> 00:22:41,440
and then we have one of the most

00:22:39,200 --> 00:22:43,679
anticipated features that falls under

00:22:41,440 --> 00:22:47,520
the remit of exoscript modules

00:22:43,679 --> 00:22:47,840
which is top level b this feature allows

00:22:47,520 --> 00:22:50,080
you

00:22:47,840 --> 00:22:51,200
to use the await keyword at the top

00:22:50,080 --> 00:22:53,600
level by

00:22:51,200 --> 00:22:54,799
outside of an async function within

00:22:53,600 --> 00:22:57,200
modules

00:22:54,799 --> 00:22:58,640
and this follows the etmascript top

00:22:57,200 --> 00:23:01,440
level of weight proposal that went

00:22:58,640 --> 00:23:02,960
through tc39

00:23:01,440 --> 00:23:04,559
this means that english script modules

00:23:02,960 --> 00:23:06,880
can await resources

00:23:04,559 --> 00:23:08,480
causing other modules to import them to

00:23:06,880 --> 00:23:10,159
have to wait before they start

00:23:08,480 --> 00:23:12,240
evaluating their body

00:23:10,159 --> 00:23:13,840
and what are the use cases for this well

00:23:12,240 --> 00:23:14,559
these are some of the use cases called

00:23:13,840 --> 00:23:17,760
out by the

00:23:14,559 --> 00:23:18,640
tc39 proposal and that includes dynamic

00:23:17,760 --> 00:23:22,320
dependency

00:23:18,640 --> 00:23:23,760
pathing resource initialization and also

00:23:22,320 --> 00:23:26,400
dependency fallbacks

00:23:23,760 --> 00:23:28,400
so you can try to import x if that fails

00:23:26,400 --> 00:23:30,880
in port white

00:23:28,400 --> 00:23:32,000
and then we have policies policies are a

00:23:30,880 --> 00:23:34,320
security feature

00:23:32,000 --> 00:23:37,919
intended to allow guarantees about what

00:23:34,320 --> 00:23:40,240
code node.js is able to load

00:23:37,919 --> 00:23:42,080
you can create a policy manifest which

00:23:40,240 --> 00:23:44,400
will be used to enforce constraints on

00:23:42,080 --> 00:23:46,559
the code loaded by node.js

00:23:44,400 --> 00:23:49,679
in this example policy file we're adding

00:23:46,559 --> 00:23:51,919
an integrity check for the file check js

00:23:49,679 --> 00:23:53,279
and this is inspired by the browser's

00:23:51,919 --> 00:23:56,480
security mechanism

00:23:53,279 --> 00:23:58,640
to enforce resource integrity this means

00:23:56,480 --> 00:24:01,120
that when you try to start your process

00:23:58,640 --> 00:24:03,039
these checks will happen and an error

00:24:01,120 --> 00:24:04,720
will occur if it fails to check

00:24:03,039 --> 00:24:08,320
and this has actually been the nodejust

00:24:04,720 --> 00:24:08,320
core for a couple of years now

00:24:08,799 --> 00:24:12,480
then there's a range of other

00:24:10,720 --> 00:24:16,080
experimental apis

00:24:12,480 --> 00:24:19,200
this includes the buffer blob api

00:24:16,080 --> 00:24:19,760
events capture rejections some of the

00:24:19,200 --> 00:24:23,039
module

00:24:19,760 --> 00:24:25,919
related apis under the vm

00:24:23,039 --> 00:24:29,360
core module and broadcast channel within

00:24:25,919 --> 00:24:29,360
the workers implementation

00:24:29,840 --> 00:24:34,000
and a number of these experimental

00:24:31,520 --> 00:24:36,640
features are hidden behind process flags

00:24:34,000 --> 00:24:37,679
this is to make them opt-in so to use

00:24:36,640 --> 00:24:38,799
some of these features

00:24:37,679 --> 00:24:40,799
you will actually need to start your

00:24:38,799 --> 00:24:42,240
node.js process with the corresponding

00:24:40,799 --> 00:24:46,960
flag

00:24:42,240 --> 00:24:49,039
for example the experimental loader flag

00:24:46,960 --> 00:24:51,600
and at some point features maybe on

00:24:49,039 --> 00:24:55,600
flight and that may or may not coincide

00:24:51,600 --> 00:24:55,600
with them being mounted as stable apis

00:24:56,799 --> 00:25:00,400
and then we have some very experimental

00:24:58,559 --> 00:25:03,360
features they're hidden behind

00:25:00,400 --> 00:25:05,279
build time flags to use these features

00:25:03,360 --> 00:25:06,640
you'd have to compile node.js yourself

00:25:05,279 --> 00:25:08,480
from source

00:25:06,640 --> 00:25:10,559
and why do we expose some features in

00:25:08,480 --> 00:25:11,120
this way but it's predominantly so we

00:25:10,559 --> 00:25:12,880
can

00:25:11,120 --> 00:25:15,360
work on crafting the very early

00:25:12,880 --> 00:25:18,159
implementation details of the feature

00:25:15,360 --> 00:25:20,480
have it built and tested in rci without

00:25:18,159 --> 00:25:22,640
them yet being released

00:25:20,480 --> 00:25:24,400
we do this where we anticipate a lot of

00:25:22,640 --> 00:25:26,960
change to happen to the feature

00:25:24,400 --> 00:25:29,840
or we just consider it too unstable for

00:25:26,960 --> 00:25:29,840
general use

00:25:30,480 --> 00:25:33,919
finally we have stable features the

00:25:32,640 --> 00:25:36,640
stable features

00:25:33,919 --> 00:25:38,640
semantic versioning applies you can have

00:25:36,640 --> 00:25:41,120
confidence that we'll try to keep

00:25:38,640 --> 00:25:42,240
the api contract so you should only

00:25:41,120 --> 00:25:44,640
experience breaking

00:25:42,240 --> 00:25:45,919
api changes when you upgrade to the next

00:25:44,640 --> 00:25:48,640
major version

00:25:45,919 --> 00:25:50,480
there are some very very exceptions for

00:25:48,640 --> 00:25:52,480
example if a security issue

00:25:50,480 --> 00:25:54,559
requires us to make a breaking api

00:25:52,480 --> 00:25:57,440
change and we only do that where

00:25:54,559 --> 00:25:59,120
absolutely necessary

00:25:57,440 --> 00:26:01,200
how do features graduate from

00:25:59,120 --> 00:26:03,440
experimental to stable

00:26:01,200 --> 00:26:04,880
well it's really when the contributors

00:26:03,440 --> 00:26:06,480
most involved in the feature have

00:26:04,880 --> 00:26:08,799
confidence in the api

00:26:06,480 --> 00:26:10,799
and don't believe that major further

00:26:08,799 --> 00:26:13,200
changes are likely

00:26:10,799 --> 00:26:15,200
how can we get there quicker well the

00:26:13,200 --> 00:26:16,720
more use of feedback we receive on an

00:26:15,200 --> 00:26:18,559
experimental feature

00:26:16,720 --> 00:26:21,600
the quicker we can gain confidence and

00:26:18,559 --> 00:26:23,200
consensus in the api structure

00:26:21,600 --> 00:26:24,799
and it's worth noting that not all

00:26:23,200 --> 00:26:26,080
features will ever make it out of

00:26:24,799 --> 00:26:27,840
experimental

00:26:26,080 --> 00:26:29,679
some have already been in that state for

00:26:27,840 --> 00:26:32,400
several years and some may

00:26:29,679 --> 00:26:33,679
be may end up being removed completely

00:26:32,400 --> 00:26:36,240
never having made it out of

00:26:33,679 --> 00:26:38,320
experimental this is again part of the

00:26:36,240 --> 00:26:41,360
reason why we suggest using experimental

00:26:38,320 --> 00:26:41,360
features with caution

00:26:42,000 --> 00:26:45,840
and there are a number of new stable

00:26:43,679 --> 00:26:48,240
features in the latest releases

00:26:45,840 --> 00:26:50,080
these include abort controller so this

00:26:48,240 --> 00:26:52,559
provides cancellation and the boarding

00:26:50,080 --> 00:26:54,640
on some of our promise-based apis

00:26:52,559 --> 00:26:55,679
and there's an ongoing effort to

00:26:54,640 --> 00:26:58,960
incorporate it

00:26:55,679 --> 00:27:00,480
across more apis and it's also recently

00:26:58,960 --> 00:27:04,400
been back ported

00:27:00,480 --> 00:27:07,039
to note 14. we also have the

00:27:04,400 --> 00:27:10,240
crypto random uuid which again has

00:27:07,039 --> 00:27:13,360
recently been back ported to note 14.

00:27:10,240 --> 00:27:16,799
we have npm 7 which features

00:27:13,360 --> 00:27:18,480
mtm diff npm diff allows you to supply

00:27:16,799 --> 00:27:20,480
two different versions of a package and

00:27:18,480 --> 00:27:22,159
we'll show you a dip

00:27:20,480 --> 00:27:23,679
like patch output to show you the

00:27:22,159 --> 00:27:27,120
difference between

00:27:23,679 --> 00:27:29,279
the two versions and also some of the

00:27:27,120 --> 00:27:32,799
recent versions of npm 7 have

00:27:29,279 --> 00:27:32,799
improved workspaces support

00:27:32,880 --> 00:27:37,600
we also have source map v3 support

00:27:35,600 --> 00:27:40,000
source maps provide a method for

00:27:37,600 --> 00:27:43,039
translating from generated source back

00:27:40,000 --> 00:27:44,559
to the original and this is

00:27:43,039 --> 00:27:46,720
aimed to alleviate some of the

00:27:44,559 --> 00:27:48,799
observability challenges we have when

00:27:46,720 --> 00:27:51,120
folks are using alternative flavors of

00:27:48,799 --> 00:27:53,039
javascript like typescript

00:27:51,120 --> 00:27:54,480
and then we have the promisified timers

00:27:53,039 --> 00:27:56,799
api

00:27:54,480 --> 00:27:58,559
and this api provides an alternative set

00:27:56,799 --> 00:28:01,200
of time functions that can return

00:27:58,559 --> 00:28:04,960
promise objects

00:28:01,200 --> 00:28:07,600
and then we always we also have v8 9.0

00:28:04,960 --> 00:28:08,559
and it's viral our va engine updates

00:28:07,600 --> 00:28:11,520
that we get the

00:28:08,559 --> 00:28:13,360
new javascript language features and

00:28:11,520 --> 00:28:16,399
recent versions of v8 brought

00:28:13,360 --> 00:28:19,600
optional training to node 15 and in v8

00:28:16,399 --> 00:28:22,399
9.0 which is in node 16

00:28:19,600 --> 00:28:25,279
we gained the regular expression match

00:28:22,399 --> 00:28:25,279
indices feature

00:28:25,520 --> 00:28:29,120
so if you're interested i'd like to

00:28:27,679 --> 00:28:31,039
encourage you to take a look

00:28:29,120 --> 00:28:33,679
try out and provide feedback on some of

00:28:31,039 --> 00:28:35,200
the experimental features in node.js

00:28:33,679 --> 00:28:38,799
maybe don't rush to use them in your

00:28:35,200 --> 00:28:38,799
critical applications just yet

00:28:38,960 --> 00:28:42,480
with that i'd like to wish you all an

00:28:40,720 --> 00:28:44,240
enjoyable rest of the conference

00:28:42,480 --> 00:28:47,840
i look forward to joining you all in the

00:28:44,240 --> 00:28:47,840

YouTube URL: https://www.youtube.com/watch?v=6XK2SGBneeM


