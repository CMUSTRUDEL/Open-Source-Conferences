Title: RosCon2013 Track2 Day2 04   Dirk Thomas   The next big step for the ROS middleware
Publication date: 2014-08-31
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:05,490
so yes my talk will be about the next

00:00:03,240 --> 00:00:08,820
big snap for the Ross middleware when we

00:00:05,490 --> 00:00:11,429
filled that proposal in December we were

00:00:08,820 --> 00:00:14,099
like expecting two more time working on

00:00:11,429 --> 00:00:17,010
that so it will be more like an Outlook

00:00:14,099 --> 00:00:21,090
what we've already done and what we

00:00:17,010 --> 00:00:24,650
expect to do in the future so the next

00:00:21,090 --> 00:00:27,480
next step we call it Ross to point Oh

00:00:24,650 --> 00:00:29,910
Ross is great as it is it's successful

00:00:27,480 --> 00:00:32,430
people use it you save time as we've

00:00:29,910 --> 00:00:35,340
heard before but there's always room for

00:00:32,430 --> 00:00:38,610
improvement there are a couple of coins

00:00:35,340 --> 00:00:40,860
which we think are not the best things

00:00:38,610 --> 00:00:42,360
which we currently have in Ross so we

00:00:40,860 --> 00:00:44,940
have implemented everything from scratch

00:00:42,360 --> 00:00:47,879
custom TCP communication custom

00:00:44,940 --> 00:00:49,500
serialization because at that time when

00:00:47,879 --> 00:00:51,690
it was initially started like five six

00:00:49,500 --> 00:00:54,329
years ago there was basically nothing

00:00:51,690 --> 00:00:55,860
adequate available which we could use so

00:00:54,329 --> 00:00:59,670
a lot of stuff was developed from

00:00:55,860 --> 00:01:02,160
scratch a lot of features which we now

00:00:59,670 --> 00:01:05,250
would like to see where necessary in the

00:01:02,160 --> 00:01:07,439
first years of Ross and so they're

00:01:05,250 --> 00:01:09,930
probably not supported and difficult to

00:01:07,439 --> 00:01:12,930
add them later like unreliable transport

00:01:09,930 --> 00:01:15,170
when you just like have a request in

00:01:12,930 --> 00:01:17,490
response and the message just gets lost

00:01:15,170 --> 00:01:19,110
well you will never be notified there is

00:01:17,490 --> 00:01:21,420
no timeout mechanism or something like

00:01:19,110 --> 00:01:23,130
that also when people think about

00:01:21,420 --> 00:01:25,020
industrial applications and would like

00:01:23,130 --> 00:01:27,720
to have a normal deterministic startup

00:01:25,020 --> 00:01:29,220
behavior for us well that's also not

00:01:27,720 --> 00:01:31,829
possible the notes come up when they

00:01:29,220 --> 00:01:34,890
come up if they come up but you have no

00:01:31,829 --> 00:01:36,930
way of checking or validating that then

00:01:34,890 --> 00:01:38,340
if you implement like code you have to

00:01:36,930 --> 00:01:39,990
decide if you want to have nodes or no

00:01:38,340 --> 00:01:41,909
let's they have different API because

00:01:39,990 --> 00:01:44,490
they have been designed at different

00:01:41,909 --> 00:01:46,140
times first they were only notes later

00:01:44,490 --> 00:01:50,250
the demand for no let's came so they're

00:01:46,140 --> 00:01:52,890
not really like interchangeable and then

00:01:50,250 --> 00:01:54,930
at that time the product was focused on

00:01:52,890 --> 00:01:57,210
getting the software running on one

00:01:54,930 --> 00:01:59,310
robot nobody was expecting to use it on

00:01:57,210 --> 00:02:02,430
like a lot of robots or multi robots in

00:01:59,310 --> 00:02:04,219
a swarm and the system is not very

00:02:02,430 --> 00:02:07,320
introspective also you cannot really

00:02:04,219 --> 00:02:10,800
look into what's going on and react

00:02:07,320 --> 00:02:12,700
dynamically on unchanging things so

00:02:10,800 --> 00:02:15,310
these are all goals over time we

00:02:12,700 --> 00:02:18,310
collected which would like to change we

00:02:15,310 --> 00:02:21,010
want to get improvements to better like

00:02:18,310 --> 00:02:23,319
address the needs of the current time

00:02:21,010 --> 00:02:26,140
and also for the next year's so we want

00:02:23,319 --> 00:02:28,150
to reuse more libraries which now exists

00:02:26,140 --> 00:02:30,040
we have civilization levels which we

00:02:28,150 --> 00:02:32,440
could use out of the box we want to

00:02:30,040 --> 00:02:34,780
reduce the maintenance work of a core

00:02:32,440 --> 00:02:37,060
team in order to develop new stuff and

00:02:34,780 --> 00:02:39,640
not maintain thousands of lines of code

00:02:37,060 --> 00:02:42,900
which we which are already like back

00:02:39,640 --> 00:02:45,430
dating couple of years we want to keep

00:02:42,900 --> 00:02:47,560
the system more modular than it is

00:02:45,430 --> 00:02:50,230
currently it is well stretched structure

00:02:47,560 --> 00:02:52,540
Colin and modular to some degree but

00:02:50,230 --> 00:02:55,769
there are so many people using Ross in

00:02:52,540 --> 00:02:58,450
so many different ways and domains that

00:02:55,769 --> 00:03:00,220
the more modular we get the the

00:02:58,450 --> 00:03:03,910
infrastructure the better we consider it

00:03:00,220 --> 00:03:05,560
to your specific domain and at best we

00:03:03,910 --> 00:03:08,079
should be able to introspect the system

00:03:05,560 --> 00:03:10,480
more deeply to be at best having a

00:03:08,079 --> 00:03:13,269
dynamic system at the system detects oh

00:03:10,480 --> 00:03:15,519
this bandwidth is going to be like

00:03:13,269 --> 00:03:17,739
saturated then i can adjust dynamically

00:03:15,519 --> 00:03:22,720
my rate all these things are currently

00:03:17,739 --> 00:03:24,569
not or very difficult to achieve I'll

00:03:22,720 --> 00:03:27,090
not go on all the points from the slide

00:03:24,569 --> 00:03:29,739
the list of goals is pretty much

00:03:27,090 --> 00:03:32,530
extremely long and everybody could

00:03:29,739 --> 00:03:35,500
contribute more points to that so why do

00:03:32,530 --> 00:03:39,850
we call it Ross to paano and not Ross

00:03:35,500 --> 00:03:43,480
one point X plus because I got the

00:03:39,850 --> 00:03:46,870
question hey Ross CBP is was version 1.8

00:03:43,480 --> 00:03:49,569
in further so groovy was 1.9 so is hydro

00:03:46,870 --> 00:03:52,569
two point oh and no Hydra is 1 point 10

00:03:49,569 --> 00:03:56,109
so we can continue that until we really

00:03:52,569 --> 00:03:59,470
make the step 2 2 point 0 I always

00:03:56,109 --> 00:04:01,900
stated the the issue is having a node in

00:03:59,470 --> 00:04:03,310
a Noblet which is difficult to decide

00:04:01,900 --> 00:04:05,290
that at programming time because I

00:04:03,310 --> 00:04:09,040
cannot decide it at one time I have to

00:04:05,290 --> 00:04:10,299
make the decision too much earlier if we

00:04:09,040 --> 00:04:12,280
want to change that if you want to have

00:04:10,299 --> 00:04:15,160
a unified API which one of the two are

00:04:12,280 --> 00:04:18,970
we going to break it's not possible to

00:04:15,160 --> 00:04:21,729
like merge them easily hopefully we can

00:04:18,970 --> 00:04:23,560
provide backward a Pai to like map to

00:04:21,729 --> 00:04:25,660
something new that we don't bring

00:04:23,560 --> 00:04:27,980
existing code on that level

00:04:25,660 --> 00:04:30,080
Ross as we've seen in other talks before

00:04:27,980 --> 00:04:32,870
has like two different wire protocols

00:04:30,080 --> 00:04:35,210
you talk with an xml RPC to the master

00:04:32,870 --> 00:04:37,970
and to the note other nodes to negotiate

00:04:35,210 --> 00:04:41,240
things and then they talk tcp Ross or

00:04:37,970 --> 00:04:43,190
UDP if you're a c++ client and why do we

00:04:41,240 --> 00:04:45,560
need two protocols one protocol would be

00:04:43,190 --> 00:04:47,360
technically perfectly enough so in order

00:04:45,560 --> 00:04:49,640
to reduce maintenance it's probably

00:04:47,360 --> 00:04:56,720
feasible to just go to one wire protocol

00:04:49,640 --> 00:04:57,919
and reduce the code size currently we

00:04:56,720 --> 00:05:02,570
don't have deterministic startup

00:04:57,919 --> 00:05:04,400
behavior and one point which might

00:05:02,570 --> 00:05:06,110
contribute to that one is like every

00:05:04,400 --> 00:05:09,050
node right its own main function so you

00:05:06,110 --> 00:05:11,419
lost the framework doesn't have any

00:05:09,050 --> 00:05:14,500
control about how you start your me we

00:05:11,419 --> 00:05:17,570
need a more structured way to make that

00:05:14,500 --> 00:05:20,930
generic over multiple nodes that could

00:05:17,570 --> 00:05:23,510
be a component with a lifecycle or just

00:05:20,930 --> 00:05:26,120
like recommendations how to ride a main

00:05:23,510 --> 00:05:27,919
function to make it deterministic in

00:05:26,120 --> 00:05:30,080
start-up that you can have a startup

00:05:27,919 --> 00:05:31,700
phase or milk starts if they are really

00:05:30,080 --> 00:05:33,830
running and all connections have been

00:05:31,700 --> 00:05:36,919
established then you start really

00:05:33,830 --> 00:05:39,440
exchanging messages and then there is

00:05:36,919 --> 00:05:42,050
the point that Ross colony has a singer

00:05:39,440 --> 00:05:43,010
master only and we have applications

00:05:42,050 --> 00:05:45,470
where we would like to have multiple

00:05:43,010 --> 00:05:46,880
masters where people would say I have

00:05:45,470 --> 00:05:48,650
applications where I don't need a master

00:05:46,880 --> 00:05:50,360
at all I would like to use like a

00:05:48,650 --> 00:05:52,970
peer-to-peer like system where the stuff

00:05:50,360 --> 00:05:55,790
discovers itself automatically how could

00:05:52,970 --> 00:05:59,840
we like address these needs is one

00:05:55,790 --> 00:06:01,490
solution really fitting for all use

00:05:59,840 --> 00:06:05,810
cases or do we have to support multiple

00:06:01,490 --> 00:06:08,060
of those so rustic when all is only

00:06:05,810 --> 00:06:10,550
describing all these efforts it's not

00:06:08,060 --> 00:06:13,600
like a fixed feature set and we will

00:06:10,550 --> 00:06:15,470
deliver on a specific day it's more

00:06:13,600 --> 00:06:17,600
everything which we have in mind for

00:06:15,470 --> 00:06:20,750
like updating these things and making

00:06:17,600 --> 00:06:27,200
innovations and making new decisions in

00:06:20,750 --> 00:06:28,850
the design and probably merging a lot of

00:06:27,200 --> 00:06:30,830
features which have been like built on

00:06:28,850 --> 00:06:34,430
top in Ross over the last couple of

00:06:30,830 --> 00:06:37,280
years there are definitely a lot of API

00:06:34,430 --> 00:06:38,449
and changes implied by these so if we

00:06:37,280 --> 00:06:40,729
think about nodes and no delay

00:06:38,449 --> 00:06:42,969
some API has changed it has to change

00:06:40,729 --> 00:06:45,680
there in order to make it unified and

00:06:42,969 --> 00:06:48,080
deploying them it'll iteratively in the

00:06:45,680 --> 00:06:52,279
current russ releases so every release a

00:06:48,080 --> 00:06:53,779
little bit is not only a significant

00:06:52,279 --> 00:06:56,960
overhead but also dangerous first

00:06:53,779 --> 00:07:00,249
ability so people might prefer to have a

00:06:56,960 --> 00:07:02,719
clean API which is currently stable and

00:07:00,249 --> 00:07:04,639
the new stuff gets developed side by

00:07:02,719 --> 00:07:06,259
side and as soon as it's getting nature

00:07:04,639 --> 00:07:09,800
enough thats can we can be used after

00:07:06,259 --> 00:07:12,710
like a longer time of testing then you

00:07:09,800 --> 00:07:14,659
can switch to the new API hopefully you

00:07:12,710 --> 00:07:16,849
can probably we can provide

00:07:14,659 --> 00:07:20,180
compatibility features that this

00:07:16,849 --> 00:07:22,849
transition is easy or at least make it

00:07:20,180 --> 00:07:25,189
that you can transform one note and then

00:07:22,849 --> 00:07:27,169
the one old note talks to the one new

00:07:25,189 --> 00:07:29,360
node and you don't care that they are

00:07:27,169 --> 00:07:35,479
using two different versions of ross for

00:07:29,360 --> 00:07:37,969
example so the approach we currently

00:07:35,479 --> 00:07:40,309
heading towards is we want to like

00:07:37,969 --> 00:07:42,649
figure out what really the protocols the

00:07:40,309 --> 00:07:44,060
abstract protocols are and what the

00:07:42,649 --> 00:07:47,029
interface between the different modules

00:07:44,060 --> 00:07:49,550
in ross are so what do i need for

00:07:47,029 --> 00:07:52,430
serializing for transport how can I like

00:07:49,550 --> 00:07:54,439
cleanly separate them from each other in

00:07:52,430 --> 00:07:57,319
order to like make them at best

00:07:54,439 --> 00:07:58,999
pluggable so we might make a decision to

00:07:57,319 --> 00:08:01,249
use a specific kind of transport layer

00:07:58,999 --> 00:08:04,399
today the decision might be different

00:08:01,249 --> 00:08:05,990
from what they decided 56 years ago but

00:08:04,399 --> 00:08:07,580
who knows if in three years there's a

00:08:05,990 --> 00:08:09,589
different transport library available

00:08:07,580 --> 00:08:14,569
which is much better much faster much

00:08:09,589 --> 00:08:16,939
smaller in bandwidth so at the the go

00:08:14,569 --> 00:08:18,560
for that one is to keep things pluggable

00:08:16,939 --> 00:08:20,899
and separated that we can like make

00:08:18,560 --> 00:08:22,459
changes in the future and also allow

00:08:20,899 --> 00:08:24,620
other people to provide different

00:08:22,459 --> 00:08:27,580
implementations if they fit their needs

00:08:24,620 --> 00:08:32,180
in their purpose or use case better and

00:08:27,580 --> 00:08:34,310
if it is that API changes are really

00:08:32,180 --> 00:08:37,760
necessary to like code you usually

00:08:34,310 --> 00:08:39,380
interface with then that should be in a

00:08:37,760 --> 00:08:42,349
way that either there is a clean upgrade

00:08:39,380 --> 00:08:44,149
path or that if you have new code as

00:08:42,349 --> 00:08:45,980
mentioned before just be able to

00:08:44,149 --> 00:08:48,709
communicate like a normal Ross network

00:08:45,980 --> 00:08:50,990
with each other with an older note so

00:08:48,709 --> 00:08:51,720
you would like not see that both are

00:08:50,990 --> 00:08:56,970
running

00:08:51,720 --> 00:08:58,709
front api behind the scene the main

00:08:56,970 --> 00:09:01,129
problem of this like last 2 point 0

00:08:58,709 --> 00:09:03,269
effort is they affect so many subsystems

00:09:01,129 --> 00:09:06,079
probably subsystems you've never cared

00:09:03,269 --> 00:09:08,730
about their actually under the hood

00:09:06,079 --> 00:09:10,350
massive specifications utilization as

00:09:08,730 --> 00:09:12,149
well as a transport that's usually the

00:09:10,350 --> 00:09:15,540
first thing to go ask because that's the

00:09:12,149 --> 00:09:17,819
the core communication part for us but

00:09:15,540 --> 00:09:21,089
it's also that a lot of capabilities we

00:09:17,819 --> 00:09:23,759
have like topic service and actions we

00:09:21,089 --> 00:09:26,069
have to like refine what we need for

00:09:23,759 --> 00:09:28,079
like a transport protocol because first

00:09:26,069 --> 00:09:30,569
service it's really a disaster if the

00:09:28,079 --> 00:09:33,389
response doesn't arrive me on a topic

00:09:30,569 --> 00:09:35,220
where fan out TF information like 100

00:09:33,389 --> 00:09:37,019
Hertz it doesn't matter if one of the

00:09:35,220 --> 00:09:38,879
packages probably get lost but that's up

00:09:37,019 --> 00:09:41,370
to the user to decide he has to be able

00:09:38,879 --> 00:09:43,500
to like say this one is must be reliable

00:09:41,370 --> 00:09:46,680
and currently we don't have a way to

00:09:43,500 --> 00:09:49,199
specify that so these services and

00:09:46,680 --> 00:09:51,649
features we provide for the

00:09:49,199 --> 00:09:53,759
communication they really drive the

00:09:51,649 --> 00:09:57,509
requirements of the lower level

00:09:53,759 --> 00:10:00,930
transport layer for the network level

00:09:57,509 --> 00:10:04,379
and there's also the question about

00:10:00,930 --> 00:10:06,839
single multi master no master what do we

00:10:04,379 --> 00:10:09,139
do what do we need for discovery how do

00:10:06,839 --> 00:10:11,399
we do negotiation how do we find out if

00:10:09,139 --> 00:10:13,620
we have like two different transfer

00:10:11,399 --> 00:10:15,180
protocols which one to use like we can

00:10:13,620 --> 00:10:18,290
probably learn from from other domains

00:10:15,180 --> 00:10:20,339
how HTTP connections do that they

00:10:18,290 --> 00:10:22,290
undiscovery decide what kind of

00:10:20,339 --> 00:10:24,689
protocols are you able to talk and then

00:10:22,290 --> 00:10:26,939
figure out and selecting one or probably

00:10:24,689 --> 00:10:28,529
the user wants to define that in a

00:10:26,939 --> 00:10:30,959
custom configuration file because he

00:10:28,529 --> 00:10:36,149
knows better instead of what the system

00:10:30,959 --> 00:10:38,009
would take as a default and beside all

00:10:36,149 --> 00:10:39,959
these things when we want all we want

00:10:38,009 --> 00:10:42,540
mostly more flexibility and more

00:10:39,959 --> 00:10:45,269
pluggable functionality in the system

00:10:42,540 --> 00:10:47,579
there comes the problem of how to manage

00:10:45,269 --> 00:10:49,139
all this configuration some things I

00:10:47,579 --> 00:10:50,939
might configure at Build time or a

00:10:49,139 --> 00:10:53,430
deploy time at best I can change stuff

00:10:50,939 --> 00:10:55,259
at runtime and all these must be like

00:10:53,430 --> 00:10:58,050
configurable in a way that the user does

00:10:55,259 --> 00:10:59,699
not have to fill hundreds and thousands

00:10:58,050 --> 00:11:01,860
of like different configuration flags

00:10:59,699 --> 00:11:05,130
but the system must provide a reasonable

00:11:01,860 --> 00:11:08,430
default behavior and then if the users

00:11:05,130 --> 00:11:10,080
has a good knowledge about that he wants

00:11:08,430 --> 00:11:12,900
to have it very specifically different

00:11:10,080 --> 00:11:14,910
in certain use cases then he needs to be

00:11:12,900 --> 00:11:16,350
able to like override that and this

00:11:14,910 --> 00:11:19,680
configuration part will be pretty

00:11:16,350 --> 00:11:21,870
complex because currently if you if you

00:11:19,680 --> 00:11:23,910
program your note you would select

00:11:21,870 --> 00:11:26,640
between I want to use a TCP connection

00:11:23,910 --> 00:11:29,400
or a UDP connection which is a decision

00:11:26,640 --> 00:11:31,980
at build time basically in the code hard

00:11:29,400 --> 00:11:33,810
coded in a perfect world you would be

00:11:31,980 --> 00:11:36,570
able to specify that at runtime so you

00:11:33,810 --> 00:11:39,000
would start the note and say ok and now

00:11:36,570 --> 00:11:40,830
switch to UDP because I know that this

00:11:39,000 --> 00:11:42,840
is now the correct choice of a better

00:11:40,830 --> 00:11:45,380
choice for that use case because i'm

00:11:42,840 --> 00:11:49,130
using a wireless connection for example

00:11:45,380 --> 00:11:51,960
so what do we have we achieved until now

00:11:49,130 --> 00:11:54,150
when we started this effort with we

00:11:51,960 --> 00:11:56,190
started from the bottom up so the first

00:11:54,150 --> 00:11:58,050
thing we looked at four groovy mostly

00:11:56,190 --> 00:11:59,460
and also in fortran once we started at

00:11:58,050 --> 00:12:02,400
the build system because that's used for

00:11:59,460 --> 00:12:04,410
everything we use the build system was

00:12:02,400 --> 00:12:06,150
the first step to like revamp that and

00:12:04,410 --> 00:12:10,170
make it hopefully more standard

00:12:06,150 --> 00:12:14,310
compliant more straightforward and also

00:12:10,170 --> 00:12:16,110
less code the built infrastructure using

00:12:14,310 --> 00:12:18,480
that kind of build system to produce the

00:12:16,110 --> 00:12:20,310
Debian packages and running

00:12:18,480 --> 00:12:22,590
documentation jobs on the farm that was

00:12:20,310 --> 00:12:25,920
basically a significant part of the time

00:12:22,590 --> 00:12:27,720
we spend during the hydro cycle we are

00:12:25,920 --> 00:12:29,730
not yet completely done with anhydrous

00:12:27,720 --> 00:12:31,620
cycle but hopefully until hydro gets

00:12:29,730 --> 00:12:33,480
released we will have a built farm which

00:12:31,620 --> 00:12:36,000
allows you to run your own build farm

00:12:33,480 --> 00:12:37,590
for example in a company you don't want

00:12:36,000 --> 00:12:38,520
to publish the Debian packages but you

00:12:37,590 --> 00:12:40,950
don't want to build everything from

00:12:38,520 --> 00:12:43,620
source so you should be able to use our

00:12:40,950 --> 00:12:48,630
build farm and do the same thing as we

00:12:43,620 --> 00:12:50,250
do on on the service we run for the

00:12:48,630 --> 00:12:53,100
higher level so for the communication we

00:12:50,250 --> 00:12:54,930
have only spent we have spent less time

00:12:53,100 --> 00:12:56,910
than we would like to because we've so

00:12:54,930 --> 00:12:59,190
many others things also to address but

00:12:56,910 --> 00:13:01,920
we have been prototyping especially

00:12:59,190 --> 00:13:04,320
Morton has spent significant amount of

00:13:01,920 --> 00:13:07,830
time of his internship in writing a

00:13:04,320 --> 00:13:10,410
prototype to try the component based

00:13:07,830 --> 00:13:11,850
life cycle to get this like predictable

00:13:10,410 --> 00:13:14,520
startup and deterministic startup

00:13:11,850 --> 00:13:16,830
behavior and also

00:13:14,520 --> 00:13:21,240
be able to introspect the system and

00:13:16,830 --> 00:13:23,730
this prototype gives us good experience

00:13:21,240 --> 00:13:25,020
where the system can go to so it's like

00:13:23,730 --> 00:13:26,790
learning a lot from these kind of

00:13:25,020 --> 00:13:29,430
prototypes but there are much more

00:13:26,790 --> 00:13:33,330
prototypes we have to do so that will be

00:13:29,430 --> 00:13:35,400
an ongoing process in order to get like

00:13:33,330 --> 00:13:36,660
a better picture what we want to go for

00:13:35,400 --> 00:13:38,580
and what's a priority for the

00:13:36,660 --> 00:13:40,230
development cycle we are currently in

00:13:38,580 --> 00:13:43,200
the in the face of collecting more use

00:13:40,230 --> 00:13:45,270
cases and trying to extract requirements

00:13:43,200 --> 00:13:48,530
from them but use cases are always

00:13:45,270 --> 00:13:51,030
specific and tailored for your domain so

00:13:48,530 --> 00:13:52,830
they might be different for you so I'll

00:13:51,030 --> 00:13:54,720
come later on the next slide that you

00:13:52,830 --> 00:13:56,190
that we look forward for people who

00:13:54,720 --> 00:13:59,580
contribute in use cases in the near

00:13:56,190 --> 00:14:01,320
future and then based on these

00:13:59,580 --> 00:14:04,080
requirements we have to derive design

00:14:01,320 --> 00:14:06,000
decisions it will be difficult to come

00:14:04,080 --> 00:14:08,100
to a content on some of the design

00:14:06,000 --> 00:14:12,600
decisions but that will be an ongoing

00:14:08,100 --> 00:14:15,300
process and we will very likely

00:14:12,600 --> 00:14:17,460
announced soon on Ross users probably

00:14:15,300 --> 00:14:20,190
the process how people can contribute

00:14:17,460 --> 00:14:21,510
use K in the cases how we pre structure

00:14:20,190 --> 00:14:24,690
them how you should just drive your use

00:14:21,510 --> 00:14:27,870
case and in order from that after they

00:14:24,690 --> 00:14:30,030
get like classified because there might

00:14:27,870 --> 00:14:31,410
be used cases which are really great but

00:14:30,030 --> 00:14:34,410
which we cannot cover in the near future

00:14:31,410 --> 00:14:36,990
or they might be used cases which we

00:14:34,410 --> 00:14:40,620
classify us yeah but we would prefer

00:14:36,990 --> 00:14:43,350
something else so they must be like

00:14:40,620 --> 00:14:44,880
agreed on which use cases are the ones

00:14:43,350 --> 00:14:48,870
we want to get like a dress first and

00:14:44,880 --> 00:14:52,410
then come to design requirement based on

00:14:48,870 --> 00:14:54,120
these use cases and one important thing

00:14:52,410 --> 00:14:56,010
is where we like one a pre structure

00:14:54,120 --> 00:14:59,670
that process is we want to make that

00:14:56,010 --> 00:15:01,380
process like document it and allow the

00:14:59,670 --> 00:15:04,320
people to follow that so if somebody

00:15:01,380 --> 00:15:06,480
comes in a year and read the use cases

00:15:04,320 --> 00:15:09,240
he must follow the argumentation chain

00:15:06,480 --> 00:15:11,010
to like why did we do design decisions

00:15:09,240 --> 00:15:12,810
and why is it implemented as it is

00:15:11,010 --> 00:15:15,900
because it doesn't help if in a year

00:15:12,810 --> 00:15:17,520
somebody came comes and says well we

00:15:15,900 --> 00:15:19,020
should make it different but you should

00:15:17,520 --> 00:15:20,910
be able to follow why the decision has

00:15:19,020 --> 00:15:24,270
been made that's the only way to like

00:15:20,910 --> 00:15:26,310
get a sustainable solution and probably

00:15:24,270 --> 00:15:27,900
refine it if you get new use cases or

00:15:26,310 --> 00:15:30,390
you'll find a flaw in your in your

00:15:27,900 --> 00:15:33,090
design process and you can reiterate and

00:15:30,390 --> 00:15:35,220
come to a different conclusion so that

00:15:33,090 --> 00:15:39,810
traceability will be one of the

00:15:35,220 --> 00:15:42,870
challenges in that process so this

00:15:39,810 --> 00:15:46,140
diagram is basically indicating the

00:15:42,870 --> 00:15:48,420
common development cycle it's taken from

00:15:46,140 --> 00:15:50,820
its inspired by another project and

00:15:48,420 --> 00:15:54,170
basically after in the first stage you

00:15:50,820 --> 00:15:56,880
try to collect use cases and derive

00:15:54,170 --> 00:15:58,860
requirements from that one and then in

00:15:56,880 --> 00:16:02,160
the next stage you will come up with a

00:15:58,860 --> 00:16:04,410
conceptual design you make make draft in

00:16:02,160 --> 00:16:08,990
a whiteboard you do technical technology

00:16:04,410 --> 00:16:11,370
research probably evaluate a couple of

00:16:08,990 --> 00:16:13,970
influence and prototypes learn from them

00:16:11,370 --> 00:16:17,730
throw them away and in the next stage

00:16:13,970 --> 00:16:21,150
formalize the system and have prototypes

00:16:17,730 --> 00:16:23,370
for all these sub components in order to

00:16:21,150 --> 00:16:26,100
know that the stuff you've designed and

00:16:23,370 --> 00:16:28,620
really like try to evaluate is the right

00:16:26,100 --> 00:16:30,600
direction or at least feasible so this

00:16:28,620 --> 00:16:32,790
will not be like a one two three three

00:16:30,600 --> 00:16:35,100
process but will probably have a lot of

00:16:32,790 --> 00:16:37,140
iterations and cycles on them to like

00:16:35,100 --> 00:16:42,270
reiterate and add more use cases with

00:16:37,140 --> 00:16:44,580
the time still the ambitious goal for

00:16:42,270 --> 00:16:47,030
that is to have something which we can

00:16:44,580 --> 00:16:49,500
show in the next in the first half of

00:16:47,030 --> 00:16:52,320
2014 so easily next year in roughly a

00:16:49,500 --> 00:16:54,470
year that you can see like a first thing

00:16:52,320 --> 00:16:57,600
how to address certain of these

00:16:54,470 --> 00:17:00,240
components how they could look like and

00:16:57,600 --> 00:17:02,460
get people to look at that look at them

00:17:00,240 --> 00:17:05,400
and try them out it will not be like

00:17:02,460 --> 00:17:06,990
production quality or ready to use but

00:17:05,400 --> 00:17:09,390
people should get experience with it and

00:17:06,990 --> 00:17:11,370
provide feedback and based on that like

00:17:09,390 --> 00:17:13,650
do another iteration and come up with

00:17:11,370 --> 00:17:16,800
the first release by the end of or by

00:17:13,650 --> 00:17:19,670
the second half of 2014 which might be

00:17:16,800 --> 00:17:22,290
site by site between the current Ross

00:17:19,670 --> 00:17:24,630
infrastructure but it should be usable

00:17:22,290 --> 00:17:26,550
for the people and hopefully also like

00:17:24,630 --> 00:17:29,790
integrated with the old system it should

00:17:26,550 --> 00:17:32,550
not be like completely standalone so

00:17:29,790 --> 00:17:34,380
don't expect the don't expect the the

00:17:32,550 --> 00:17:36,600
first release to be like hey that's

00:17:34,380 --> 00:17:38,480
everything Ross Carly has that's the new

00:17:36,600 --> 00:17:40,820
system it does all the job

00:17:38,480 --> 00:17:43,790
it could be that like it covers like the

00:17:40,820 --> 00:17:45,230
core new functionality and tooling and

00:17:43,790 --> 00:17:48,470
things like these they will evolve over

00:17:45,230 --> 00:17:52,460
time so that will be a process which

00:17:48,470 --> 00:17:54,230
takes longer so don't expect on a don't

00:17:52,460 --> 00:17:55,400
expected final release like on fixed

00:17:54,230 --> 00:17:56,840
date which will just like be a

00:17:55,400 --> 00:17:59,090
replacement for everything we have it

00:17:56,840 --> 00:18:00,770
will be a long term process but starting

00:17:59,090 --> 00:18:04,010
this now and like spending time on that

00:18:00,770 --> 00:18:08,450
that's what we're looking to do in the

00:18:04,010 --> 00:18:09,919
next months or even years so I guess for

00:18:08,450 --> 00:18:13,390
that topic we're going to get a lot of

00:18:09,919 --> 00:18:13,390

YouTube URL: https://www.youtube.com/watch?v=YMx2PRfrXf0


