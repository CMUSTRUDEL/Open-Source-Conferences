Title: RosCon2013   Track1 Day1 04   Armin Hornung   3D Mapping with OctoMap
Publication date: 2014-09-02
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,230 --> 00:00:06,600
so thanks for introduction and in this

00:00:03,959 --> 00:00:09,240
talk you will hopefully learn how to

00:00:06,600 --> 00:00:11,160
build memory fish and 3d maps and how

00:00:09,240 --> 00:00:13,259
you can use these maps later on for

00:00:11,160 --> 00:00:15,420
example for navigation planning

00:00:13,259 --> 00:00:21,140
collision avoidance or tasks like

00:00:15,420 --> 00:00:33,090
localization enough the microphone okay

00:00:21,140 --> 00:00:35,460
closer okay just like this so with the

00:00:33,090 --> 00:00:38,100
recent availability of affordable 3d

00:00:35,460 --> 00:00:40,500
sensors we tend to see more and more

00:00:38,100 --> 00:00:44,489
robots actually operating in the 3d

00:00:40,500 --> 00:00:46,469
world so we're beginning to to see less

00:00:44,489 --> 00:00:48,719
and less of these wheeled mobile

00:00:46,469 --> 00:00:51,030
platforms with the 2d laser rangefinder

00:00:48,719 --> 00:00:54,420
but actual robots performing tasks like

00:00:51,030 --> 00:00:58,379
mobile manipulation mapping of outdoor

00:00:54,420 --> 00:01:00,510
terrain of underwater or caves tossed

00:00:58,379 --> 00:01:03,329
like humanoid navigation which I'm most

00:01:00,510 --> 00:01:07,260
interested in but of course also obvious

00:01:03,329 --> 00:01:09,270
applications like disaster response for

00:01:07,260 --> 00:01:11,430
these environments since these are

00:01:09,270 --> 00:01:13,590
typically highly unstructured what we

00:01:11,430 --> 00:01:16,130
actually want is some sort of 3d

00:01:13,590 --> 00:01:19,799
environment representation or a 3d map

00:01:16,130 --> 00:01:21,330
what you want this map for well you've

00:01:19,799 --> 00:01:25,020
seen the movie does the movie talk

00:01:21,330 --> 00:01:27,330
before so to actually perform at us like

00:01:25,020 --> 00:01:29,250
mobile manipulation we need

00:01:27,330 --> 00:01:31,470
collision-free navigation we need

00:01:29,250 --> 00:01:34,500
localization but also things like

00:01:31,470 --> 00:01:38,159
exploration which is especially crucial

00:01:34,500 --> 00:01:42,240
for this disaster scenarios are all

00:01:38,159 --> 00:01:43,829
typical occasions of these 3d maps and

00:01:42,240 --> 00:01:48,329
if we think of a 3d environment

00:01:43,829 --> 00:01:52,530
representation then what are typical

00:01:48,329 --> 00:01:54,720
requirements that we have in mind first

00:01:52,530 --> 00:01:57,930
of all what we want is a realistic

00:01:54,720 --> 00:02:00,180
representation which we also know from

00:01:57,930 --> 00:02:02,549
from 2d occupancy mapping so we want to

00:02:00,180 --> 00:02:04,469
handle sensor noise we want to handle

00:02:02,549 --> 00:02:06,270
dynamic changes in the environment so we

00:02:04,469 --> 00:02:07,990
can react it to these changes with our

00:02:06,270 --> 00:02:10,500
planning

00:02:07,990 --> 00:02:13,300
algorithm or our collision avoidance and

00:02:10,500 --> 00:02:16,420
also we might want to fuse multiple

00:02:13,300 --> 00:02:18,670
sensors in this map then ideally we want

00:02:16,420 --> 00:02:21,160
to represent both free and unknown areas

00:02:18,670 --> 00:02:24,610
in addition to the occupied measurements

00:02:21,160 --> 00:02:26,860
so we cannot just take point clouds and

00:02:24,610 --> 00:02:28,510
regard them as obstacles because this

00:02:26,860 --> 00:02:30,310
doesn't allow us to to reason about the

00:02:28,510 --> 00:02:32,200
free space which is between the sensor

00:02:30,310 --> 00:02:33,880
and the end point and this is really

00:02:32,200 --> 00:02:36,580
crucial for collision free navigation

00:02:33,880 --> 00:02:39,730
where the robot should only navigate in

00:02:36,580 --> 00:02:41,440
the safe area that it has explored

00:02:39,730 --> 00:02:43,780
before but it's also useful for

00:02:41,440 --> 00:02:45,640
explorations so we can find the sort of

00:02:43,780 --> 00:02:46,930
boundary to the unknown space where the

00:02:45,640 --> 00:02:48,519
robot should go next or where the rover

00:02:46,930 --> 00:02:52,959
should look to in order to explore this

00:02:48,519 --> 00:02:54,910
space and last but not least we want to

00:02:52,959 --> 00:02:59,080
handle efficiency in a 3d map since this

00:02:54,910 --> 00:03:01,750
is no longer 2d and the data grows more

00:02:59,080 --> 00:03:03,880
and more dense and we want to have high

00:03:01,750 --> 00:03:05,980
resolution of course so we want to have

00:03:03,880 --> 00:03:08,890
a compact memory representation of this

00:03:05,980 --> 00:03:11,500
3d data so robot can store this map in

00:03:08,890 --> 00:03:13,030
memory or on disk or for exchange

00:03:11,500 --> 00:03:15,160
between robots and also we want

00:03:13,030 --> 00:03:17,680
efficient access to the data structure

00:03:15,160 --> 00:03:21,220
so these are some requirements which we

00:03:17,680 --> 00:03:25,299
had in mind when we designed this octa

00:03:21,220 --> 00:03:27,160
map framework the obvious day a choice

00:03:25,299 --> 00:03:30,280
as the data structure there is the

00:03:27,160 --> 00:03:31,660
octree it's also the name what is an

00:03:30,280 --> 00:03:33,489
octree an octree is the tree based data

00:03:31,660 --> 00:03:35,829
structure on the right you see an

00:03:33,489 --> 00:03:38,260
example of this kind of oak tree at the

00:03:35,829 --> 00:03:40,569
top is a volumetric representation and

00:03:38,260 --> 00:03:43,390
at the bottom you see the same oak tree

00:03:40,569 --> 00:03:45,220
as a tree based representation so it's

00:03:43,390 --> 00:03:47,769
really the same representation of the

00:03:45,220 --> 00:03:51,069
same data structure and we see already

00:03:47,769 --> 00:03:54,519
that this is very nice - to encode

00:03:51,069 --> 00:03:55,840
volumetric data you'll also see that you

00:03:54,519 --> 00:03:58,450
have a recursive subdivision of the

00:03:55,840 --> 00:04:01,840
space we have this single measurement

00:03:58,450 --> 00:04:03,459
here and it's the this tree is

00:04:01,840 --> 00:04:06,959
recursively subdivided into eight

00:04:03,459 --> 00:04:10,569
octants so each each voxel in the space

00:04:06,959 --> 00:04:12,850
can be can be refined incrementally by

00:04:10,569 --> 00:04:15,639
subdividing it to its eight children and

00:04:12,850 --> 00:04:18,250
these children don't have to exist you

00:04:15,639 --> 00:04:20,620
see here the the whole left half of this

00:04:18,250 --> 00:04:21,769
cube hasn't been observed by the robot

00:04:20,620 --> 00:04:23,870
so there's no infirm

00:04:21,769 --> 00:04:26,090
encoded there as opposed to these two

00:04:23,870 --> 00:04:28,819
big trunks which were absorb served us

00:04:26,090 --> 00:04:31,340
as free so this gives us the possibility

00:04:28,819 --> 00:04:33,440
by implicitly encoding the unknown space

00:04:31,340 --> 00:04:36,470
but with missing information to

00:04:33,440 --> 00:04:40,819
differentiate the safe and free areas

00:04:36,470 --> 00:04:43,000
from the unknown areas and what also

00:04:40,819 --> 00:04:45,590
nice about this trace data structure is

00:04:43,000 --> 00:04:47,900
that it's can be allocated as needed so

00:04:45,590 --> 00:04:50,720
as the robot explores new areas the tree

00:04:47,900 --> 00:04:52,370
grows into this direction and we don't

00:04:50,720 --> 00:04:54,169
have to allocate all the memory at once

00:04:52,370 --> 00:05:00,650
as we would have to do for example with

00:04:54,169 --> 00:05:04,310
a 3d voxel grid now this is a a binary

00:05:00,650 --> 00:05:06,289
representation of free and occupied if

00:05:04,310 --> 00:05:08,509
we now think of using octrees for 3d

00:05:06,289 --> 00:05:11,090
occupancy map we actually want to store

00:05:08,509 --> 00:05:13,400
some sort of occupancy probability in

00:05:11,090 --> 00:05:17,389
the nodes so we have a probability that

00:05:13,400 --> 00:05:19,280
this portion of the space is occupied if

00:05:17,389 --> 00:05:21,889
we do if you do this an octree so now

00:05:19,280 --> 00:05:24,620
we're storing probabilities then we

00:05:21,889 --> 00:05:27,440
actually can perform 3d occupancy medal

00:05:24,620 --> 00:05:29,449
in the occupancy mapping we have a

00:05:27,440 --> 00:05:30,919
volumetric 3d model given by the oak

00:05:29,449 --> 00:05:32,630
tree we will have probabilistic

00:05:30,919 --> 00:05:35,330
integration it will be memory efficient

00:05:32,630 --> 00:05:38,180
as we will see and in some sample data

00:05:35,330 --> 00:05:39,889
sets and you'll also have a flexible

00:05:38,180 --> 00:05:42,400
extension of the map area which we won't

00:05:39,889 --> 00:05:46,130
have with with a fixed size box the grid

00:05:42,400 --> 00:05:48,500
and also the nice thing is the octree

00:05:46,130 --> 00:05:50,599
here is encoding the same information as

00:05:48,500 --> 00:05:52,340
a 3d grid but it's doing it much more

00:05:50,599 --> 00:05:54,469
efficient because a 3d grid really has

00:05:52,340 --> 00:05:56,930
to has to be filled to contain all the

00:05:54,469 --> 00:05:58,669
space so all this would have to be

00:05:56,930 --> 00:06:01,969
filled whereas when we only have the

00:05:58,669 --> 00:06:03,409
endpoints in there or the free space in

00:06:01,969 --> 00:06:08,150
between we were having much less

00:06:03,409 --> 00:06:10,190
information stored in the orc tree so

00:06:08,150 --> 00:06:12,590
some more details on optimal framework

00:06:10,190 --> 00:06:14,289
is based on oak trees we have a

00:06:12,590 --> 00:06:17,270
ballistic representation of occupancy

00:06:14,289 --> 00:06:19,810
including the free space and the unknown

00:06:17,270 --> 00:06:22,490
space is implicitly represented in here

00:06:19,810 --> 00:06:24,199
it supports much resolution map queries

00:06:22,490 --> 00:06:26,900
which is a nice property if you want to

00:06:24,199 --> 00:06:29,719
do any time collision checking or any

00:06:26,900 --> 00:06:31,710
time planning so as we will see we will

00:06:29,719 --> 00:06:35,190
get a nice speed up by

00:06:31,710 --> 00:06:38,490
doing coarser queries on the oak trees

00:06:35,190 --> 00:06:41,090
and it offers a lossless compression and

00:06:38,490 --> 00:06:43,230
compact metafiles you see an example

00:06:41,090 --> 00:06:45,180
octree creates from run single laser

00:06:43,230 --> 00:06:48,800
scan of a robot standing in a hallway

00:06:45,180 --> 00:06:51,300
here so what's important here is that

00:06:48,800 --> 00:06:53,310
we're not only encoding the occupied

00:06:51,300 --> 00:06:55,260
areas which you see on the left but also

00:06:53,310 --> 00:06:57,900
the free space in between the robots it

00:06:55,260 --> 00:07:00,330
was standing here and doing a scan with

00:06:57,900 --> 00:07:02,220
the tilting laser so we know which areas

00:07:00,330 --> 00:07:03,930
the robot has seen for example through

00:07:02,220 --> 00:07:07,410
the hall through the door oh here it has

00:07:03,930 --> 00:07:09,690
observed portions of the next room so

00:07:07,410 --> 00:07:11,670
when I'm showing you occupy keep in mind

00:07:09,690 --> 00:07:13,800
that if we always show in the free space

00:07:11,670 --> 00:07:17,190
but it's it's really encoded in the OP

00:07:13,800 --> 00:07:17,910
tree what you also tend to notice on the

00:07:17,190 --> 00:07:21,690
right is that we'll have

00:07:17,910 --> 00:07:23,400
multi-resolution voxels here we're not

00:07:21,690 --> 00:07:25,440
having the the smallest ones only you

00:07:23,400 --> 00:07:27,630
see another corner here are some bigger

00:07:25,440 --> 00:07:29,520
ones here some bigger ones so all the

00:07:27,630 --> 00:07:32,940
free space even from from one this

00:07:29,520 --> 00:07:35,790
single scan we can exploit this lossless

00:07:32,940 --> 00:07:38,340
compression by by pruning children of of

00:07:35,790 --> 00:07:40,640
an of a node which are all and entacle

00:07:38,340 --> 00:07:44,010
so all the free space within this for

00:07:40,640 --> 00:07:45,570
this oak tree is consisting of all of

00:07:44,010 --> 00:07:47,520
these big boxes not only at the corner

00:07:45,570 --> 00:07:49,590
and we're having the smaller voxels and

00:07:47,520 --> 00:07:51,240
this is really the nice property which

00:07:49,590 --> 00:07:54,660
will lead to the memory efficient

00:07:51,240 --> 00:07:57,510
compression some more properties of our

00:07:54,660 --> 00:07:59,730
framework it's open-source license bsd

00:07:57,510 --> 00:08:01,430
so quite permissive if you want to use

00:07:59,730 --> 00:08:05,130
it for commercial products

00:08:01,430 --> 00:08:08,160
implementation is c++ with a very low

00:08:05,130 --> 00:08:10,530
set of dependency so if you have c make

00:08:08,160 --> 00:08:12,240
and c++ i would say that you can already

00:08:10,530 --> 00:08:14,040
compile this and you can actually

00:08:12,240 --> 00:08:16,170
compile it for linux mac and windows

00:08:14,040 --> 00:08:17,910
it's fully documented code is on github

00:08:16,170 --> 00:08:20,090
if you want to check it out or want to

00:08:17,910 --> 00:08:23,580
fork it and contribute new features and

00:08:20,090 --> 00:08:26,070
thanks to the nice ross built farm and

00:08:23,580 --> 00:08:28,440
the release system bloom we're having

00:08:26,070 --> 00:08:30,090
pre-built Debian packages for Ross

00:08:28,440 --> 00:08:33,120
Electric up to the upcoming hydro

00:08:30,090 --> 00:08:34,590
already available so you don't actually

00:08:33,120 --> 00:08:37,980
have to compile this yourself you can

00:08:34,590 --> 00:08:42,420
just install the Debian package so öktem

00:08:37,980 --> 00:08:44,250
app itself is sent alone library it's

00:08:42,420 --> 00:08:46,170
been using a couple of things in Ross so

00:08:44,250 --> 00:08:49,110
to make this easy

00:08:46,170 --> 00:08:51,269
and we have Ross integration in öktem

00:08:49,110 --> 00:08:53,369
across document messages and the octamer

00:08:51,269 --> 00:08:56,369
server package so you don't actually

00:08:53,369 --> 00:08:57,809
have to use Ross but it's really written

00:08:56,369 --> 00:09:00,569
in a way that you can easily use it in

00:08:57,809 --> 00:09:02,970
Ross and as we've seen in the last talk

00:09:00,569 --> 00:09:04,529
what's really nice is that if using octo

00:09:02,970 --> 00:09:06,929
map you can directly employ a collision

00:09:04,529 --> 00:09:08,970
checks in SEL the the flexible collision

00:09:06,929 --> 00:09:12,989
library and it's directly running in

00:09:08,970 --> 00:09:14,939
move it these are some advantages so

00:09:12,989 --> 00:09:17,100
further details we have a publication

00:09:14,939 --> 00:09:19,319
which has been recently accepted to the

00:09:17,100 --> 00:09:21,269
Thomas robots special issue on open

00:09:19,319 --> 00:09:22,559
source software for robotics so if you

00:09:21,269 --> 00:09:24,149
wanna look up some details which are not

00:09:22,559 --> 00:09:26,249
covered by the talk check out the paper

00:09:24,149 --> 00:09:32,189
it's also linked from the optimal home

00:09:26,249 --> 00:09:33,660
page so let's get to some details to

00:09:32,189 --> 00:09:37,559
give you some understanding on what's

00:09:33,660 --> 00:09:39,689
happening under the hood so what we want

00:09:37,559 --> 00:09:43,819
to do as I mentioned before is one we

00:09:39,689 --> 00:09:46,290
want to model occupancy in this map and

00:09:43,819 --> 00:09:47,879
we do this by employing the binary based

00:09:46,290 --> 00:09:51,689
filter which was improbable introduced

00:09:47,879 --> 00:09:54,119
by by mer avec in 85 for 2d grid mapping

00:09:51,689 --> 00:09:57,059
and we're essentially applying this to

00:09:54,119 --> 00:09:59,160
3d maps and what you see up there is the

00:09:57,059 --> 00:10:00,629
formula for the binary based filter it's

00:09:59,160 --> 00:10:02,279
a static state based filter so it

00:10:00,629 --> 00:10:08,160
assumes that the environ doesn't really

00:10:02,279 --> 00:10:09,119
change and if we now switching to using

00:10:08,160 --> 00:10:12,449
lock odds

00:10:09,119 --> 00:10:14,519
instead of probabilities we can get rid

00:10:12,449 --> 00:10:20,399
of all of this and our measurement

00:10:14,519 --> 00:10:22,829
update converts a simple addition of the

00:10:20,399 --> 00:10:24,600
new values up to the old values and this

00:10:22,829 --> 00:10:25,829
for once is more more efficient to

00:10:24,600 --> 00:10:27,779
perform and the other thing is that it's

00:10:25,829 --> 00:10:33,779
miracle II more stable if you have small

00:10:27,779 --> 00:10:36,089
probabilities then to ensure update

00:10:33,779 --> 00:10:40,379
ability with this static state based

00:10:36,089 --> 00:10:42,779
filter we are enforcing or we were we

00:10:40,379 --> 00:10:44,339
offer you this clamping policy to see at

00:10:42,779 --> 00:10:45,929
the top which actually which means that

00:10:44,339 --> 00:10:47,970
probabilities would have to be in a

00:10:45,929 --> 00:10:50,209
certain range so there's a minimum

00:10:47,970 --> 00:10:52,949
probability and the maximum probability

00:10:50,209 --> 00:10:54,299
when when no it's occupancy which is

00:10:52,949 --> 00:10:56,610
lower probability it will stay there it

00:10:54,299 --> 00:10:58,480
won't get less oval or more probable and

00:10:56,610 --> 00:10:59,980
with this we can avoid an

00:10:58,480 --> 00:11:01,870
confidence into a map so if you consider

00:10:59,980 --> 00:11:05,230
you have a robot that measures this door

00:11:01,870 --> 00:11:08,050
has to be closed 20 times then when the

00:11:05,230 --> 00:11:10,120
door suddenly opens you don't want to to

00:11:08,050 --> 00:11:12,130
measure this door at least 20 times open

00:11:10,120 --> 00:11:15,339
to integrate that back into your static

00:11:12,130 --> 00:11:16,959
state binary Bayes filter so by limiting

00:11:15,339 --> 00:11:19,269
the maximum and the minimum probability

00:11:16,959 --> 00:11:24,070
or the log odds we are ensuring that the

00:11:19,269 --> 00:11:26,230
map stays updatable then we're also

00:11:24,070 --> 00:11:30,480
updating the inner nodes and we're doing

00:11:26,230 --> 00:11:34,240
this to enable multi-resolution queries

00:11:30,480 --> 00:11:36,399
so each inner node will have the maximum

00:11:34,240 --> 00:11:38,079
occupancy of its children this is a

00:11:36,399 --> 00:11:40,480
quite conservative setting so we don't

00:11:38,079 --> 00:11:42,519
risk bumping into obstacles and by doing

00:11:40,480 --> 00:11:46,000
this and you're traversing the oak tree

00:11:42,519 --> 00:11:48,100
to generate a reservation or a collision

00:11:46,000 --> 00:11:50,589
model then you can just stop at the

00:11:48,100 --> 00:11:52,420
inner nodes to obtain a course or a

00:11:50,589 --> 00:11:53,649
course a representation of the

00:11:52,420 --> 00:11:55,449
opportunity this is the same map data

00:11:53,649 --> 00:11:57,760
and we're just stopping traversing the

00:11:55,449 --> 00:11:58,899
oak tree one level before the leaf and

00:11:57,760 --> 00:12:01,209
we do that less and less we get a

00:11:58,899 --> 00:12:02,500
coarser representation and we will get

00:12:01,209 --> 00:12:04,269
this faster and this will also make the

00:12:02,500 --> 00:12:07,410
collision takes faster if you do this

00:12:04,269 --> 00:12:09,459
and finally we have the compression

00:12:07,410 --> 00:12:13,060
property which you see illustrate the

00:12:09,459 --> 00:12:15,670
bottom for a quad tree so wherever there

00:12:13,060 --> 00:12:17,889
are nodes which are kind of identical

00:12:15,670 --> 00:12:20,170
they will be merged into that into the

00:12:17,889 --> 00:12:21,220
parent node and we can throw all the

00:12:20,170 --> 00:12:22,810
children away because all the

00:12:21,220 --> 00:12:28,240
information is losslessly encoded in the

00:12:22,810 --> 00:12:30,699
parent node so this is how we update

00:12:28,240 --> 00:12:39,459
single cells of the oak tree or a single

00:12:30,699 --> 00:12:40,690
voxels now with the range sensor we we

00:12:39,459 --> 00:12:42,819
want to reason about the space between

00:12:40,690 --> 00:12:44,560
the robot sensor origin and the end

00:12:42,819 --> 00:12:46,060
point so we can know what is free and

00:12:44,560 --> 00:12:49,029
what is occupied that we've seen in the

00:12:46,060 --> 00:12:53,040
world and to do this we employ a ray

00:12:49,029 --> 00:12:56,920
casting here this is potentially an

00:12:53,040 --> 00:12:59,019
expensive operation since you have to

00:12:56,920 --> 00:13:00,010
update all the space between the origin

00:12:59,019 --> 00:13:01,660
and the end point you have to compute

00:13:00,010 --> 00:13:03,250
this voxel so no not integrating a

00:13:01,660 --> 00:13:04,420
single measurement but all the right so

00:13:03,250 --> 00:13:06,130
this really depends on how long your

00:13:04,420 --> 00:13:08,480
measurement beams are this is just to

00:13:06,130 --> 00:13:10,610
keep in mind this is what makes the

00:13:08,480 --> 00:13:14,390
holistic update expensive in the end so

00:13:10,610 --> 00:13:16,730
there's something to optimize in here

00:13:14,390 --> 00:13:18,350
and we're marking the last box that we

00:13:16,730 --> 00:13:20,360
occupied so we're increasing the

00:13:18,350 --> 00:13:23,149
probability and we're marking all other

00:13:20,360 --> 00:13:24,860
boxes on the Ray to be free

00:13:23,149 --> 00:13:28,220
so we're decreasing probabilities or

00:13:24,860 --> 00:13:29,990
Duloc odds this is implemented in the

00:13:28,220 --> 00:13:31,370
computer a function or in the insert

00:13:29,990 --> 00:13:33,080
Drive function if you want to actually

00:13:31,370 --> 00:13:36,080
insert a single ray measurement into the

00:13:33,080 --> 00:13:37,880
Orca tree now if you don't need all this

00:13:36,080 --> 00:13:39,800
reasoning about free space between the

00:13:37,880 --> 00:13:41,870
robot then you can just update the

00:13:39,800 --> 00:13:46,070
endpoint and all your octree updates

00:13:41,870 --> 00:13:49,339
will be faster immediately so this is

00:13:46,070 --> 00:13:52,880
this one of the bottlenecks to keep in

00:13:49,339 --> 00:13:54,140
mind for from app updates so typically

00:13:52,880 --> 00:13:56,600
what we get from a sensor is not a

00:13:54,140 --> 00:13:59,510
single ray but a complete 3d point cloud

00:13:56,600 --> 00:14:01,520
or a depth image this is also the case

00:13:59,510 --> 00:14:04,580
if we have a laser which is consuming

00:14:01,520 --> 00:14:07,390
laser on a pan tilt unit and what

00:14:04,580 --> 00:14:10,610
happens there is is on the left you see

00:14:07,390 --> 00:14:13,339
an example for a noise free simulator 3d

00:14:10,610 --> 00:14:16,820
scan and if we now integrate this ready

00:14:13,339 --> 00:14:17,959
scan ray by ray into our Rock tree if

00:14:16,820 --> 00:14:19,910
you look like this and this will be

00:14:17,959 --> 00:14:21,950
exactly the same if you use a 3d

00:14:19,910 --> 00:14:26,029
occupancy grid so problem here is that

00:14:21,950 --> 00:14:28,970
you're observing the floor or any kind

00:14:26,029 --> 00:14:30,950
of surface at a shallow angle what we

00:14:28,970 --> 00:14:32,480
actually want to have is this so every

00:14:30,950 --> 00:14:34,760
occupied end point should be integrated

00:14:32,480 --> 00:14:37,310
to be occupied into the map what happens

00:14:34,760 --> 00:14:40,459
is is with the sweeping laser or if

00:14:37,310 --> 00:14:43,220
you're the order of updates of your 3d

00:14:40,459 --> 00:14:44,930
point clouds happen in the same way is

00:14:43,220 --> 00:14:46,940
that you will measure this voxels will

00:14:44,930 --> 00:14:48,709
be occupied and everything else to be

00:14:46,940 --> 00:14:50,779
free in between and when you have the

00:14:48,709 --> 00:14:52,970
next update of the same scan suddenly

00:14:50,779 --> 00:14:55,130
you're occupied voxel will get decrease

00:14:52,970 --> 00:14:56,270
in probability and I will eventually a

00:14:55,130 --> 00:14:57,589
free cup of measurements it will

00:14:56,270 --> 00:14:59,990
disappear even though this is the same

00:14:57,589 --> 00:15:02,420
the same scanner so our solution for

00:14:59,990 --> 00:15:05,060
this is to update each voxel of one

00:15:02,420 --> 00:15:06,800
complete point cloud at most once where

00:15:05,060 --> 00:15:08,329
we give a preference to occupied

00:15:06,800 --> 00:15:10,610
endpoints so that we can ensure that

00:15:08,329 --> 00:15:12,589
everything that's occupied in the scan

00:15:10,610 --> 00:15:15,470
will end up to be occupied in the map

00:15:12,589 --> 00:15:17,779
and this is a implemented in the insert

00:15:15,470 --> 00:15:19,370
scan functionality of tray so and which

00:15:17,779 --> 00:15:20,610
is also more efficient because it's a

00:15:19,370 --> 00:15:26,490
better insertion

00:15:20,610 --> 00:15:28,140
then then inserting single race once

00:15:26,490 --> 00:15:29,610
you've built a map now what can you do

00:15:28,140 --> 00:15:31,380
with it we don't want to build map just

00:15:29,610 --> 00:15:34,320
for the sake of building maps now we're

00:15:31,380 --> 00:15:35,160
gonna do something with it whatever you

00:15:34,320 --> 00:15:37,350
want to do with it

00:15:35,160 --> 00:15:39,630
we have some methods of accessing this

00:15:37,350 --> 00:15:42,089
map map data and the most efficient one

00:15:39,630 --> 00:15:44,519
just as inserting the scans batch is

00:15:42,089 --> 00:15:46,560
traversing all the notes with iterators

00:15:44,519 --> 00:15:48,959
this really works similar to a C++

00:15:46,560 --> 00:15:51,390
standard container like like a vector so

00:15:48,959 --> 00:15:53,640
you create a leaf iterator in this case

00:15:51,390 --> 00:15:57,570
and you'll iterate over the octree and

00:15:53,640 --> 00:15:58,920
all the information that's required will

00:15:57,570 --> 00:16:00,570
then be reconstructed while you're

00:15:58,920 --> 00:16:01,920
iterating the oaktree and with this we

00:16:00,570 --> 00:16:03,510
don't need to store anything in the

00:16:01,920 --> 00:16:06,839
octave that we don't need beyond the

00:16:03,510 --> 00:16:08,430
standard probabilities notice that here

00:16:06,839 --> 00:16:11,550
you're accessing the iterator directly

00:16:08,430 --> 00:16:13,649
so the iterator will give you the

00:16:11,550 --> 00:16:16,170
coordinate of the node where you're at

00:16:13,649 --> 00:16:19,110
right now whereas the node only knows

00:16:16,170 --> 00:16:21,570
its value which is in this case the

00:16:19,110 --> 00:16:24,180
probability is stored in it and there

00:16:21,570 --> 00:16:26,579
are other iterators which you can find

00:16:24,180 --> 00:16:28,470
out about in the documentation for

00:16:26,579 --> 00:16:30,930
example servers all inner nodes this is

00:16:28,470 --> 00:16:33,269
only hurting the leaf nodes or servers

00:16:30,930 --> 00:16:35,370
only nodes in a certain bounding box and

00:16:33,269 --> 00:16:37,380
all this iterators can be accessed with

00:16:35,370 --> 00:16:38,279
the maximum depth so you can from this

00:16:37,380 --> 00:16:42,829
multi-resolution

00:16:38,279 --> 00:16:46,860
map queries finally for or as a second

00:16:42,829 --> 00:16:48,540
example for accessing data we have Ray

00:16:46,860 --> 00:16:50,519
intersection queries this is a chance a

00:16:48,540 --> 00:16:52,170
ray casting on a build map which is

00:16:50,519 --> 00:16:54,269
useful for visibility queries but also

00:16:52,170 --> 00:16:56,579
for localization you have a range sensor

00:16:54,269 --> 00:16:58,260
and you want to check out from this

00:16:56,579 --> 00:16:59,670
position how likely it is that it that

00:16:58,260 --> 00:17:01,110
you actually observe an obstacle over

00:16:59,670 --> 00:17:04,650
there and you can this could do this

00:17:01,110 --> 00:17:06,150
with the cost wave function and as a

00:17:04,650 --> 00:17:08,459
final example of course you can also

00:17:06,150 --> 00:17:11,189
search for single notes just by by

00:17:08,459 --> 00:17:13,770
looking up their coordinates XYZ but

00:17:11,189 --> 00:17:15,270
this if you have multiple queries will

00:17:13,770 --> 00:17:17,760
be the least efficient one because it

00:17:15,270 --> 00:17:19,829
will it will traverse you tree every

00:17:17,760 --> 00:17:21,150
single time so we'll end over traversing

00:17:19,829 --> 00:17:23,220
the tree multiple times from aspect

00:17:21,150 --> 00:17:27,290
queries so if you can use the iterators

00:17:23,220 --> 00:17:29,940
for it one thing to notice here is

00:17:27,290 --> 00:17:31,830
you're getting back a pointer but this

00:17:29,940 --> 00:17:33,770
pointer can be null and this is the case

00:17:31,830 --> 00:17:35,330
if the node doesn't exist

00:17:33,770 --> 00:17:37,670
you're asking the oaktree what is a

00:17:35,330 --> 00:17:39,170
position X Y Z and if you get now back

00:17:37,670 --> 00:17:40,640
then this is an unknown area which

00:17:39,170 --> 00:17:42,770
hasn't been observed before so you can

00:17:40,640 --> 00:17:44,960
do this to differentiate between unknown

00:17:42,770 --> 00:17:47,960
areas in free areas when did not exist

00:17:44,960 --> 00:17:49,550
it's either occupied or free and by

00:17:47,960 --> 00:17:54,110
getting the vector values you'll get

00:17:49,550 --> 00:17:55,850
back the probabilities or by asking the

00:17:54,110 --> 00:17:58,220
octree which is the second example if

00:17:55,850 --> 00:18:00,350
the node is occupied you'll get back if

00:17:58,220 --> 00:18:02,420
it's an occupied node or free node based

00:18:00,350 --> 00:18:04,430
on the probability parameters of the

00:18:02,420 --> 00:18:06,740
octree which you can set with an example

00:18:04,430 --> 00:18:08,360
on the top and you call so check if the

00:18:06,740 --> 00:18:12,170
node is at the threshold at the clamping

00:18:08,360 --> 00:18:14,240
threshold the lower or the upper one you

00:18:12,170 --> 00:18:21,470
some more implementation details only

00:18:14,240 --> 00:18:24,170
curve this briefly the core class is

00:18:21,470 --> 00:18:26,600
octree this is an occupancy oak tree

00:18:24,170 --> 00:18:29,300
it's storing the the probabilities

00:18:26,600 --> 00:18:31,280
you'll notice that all of this is

00:18:29,300 --> 00:18:32,900
templated so you can easily extend it

00:18:31,280 --> 00:18:34,309
through your own implementation and

00:18:32,900 --> 00:18:36,080
actually we're also already providing

00:18:34,309 --> 00:18:39,110
this color oak tree as an example how

00:18:36,080 --> 00:18:41,510
you can do this extension well this oak

00:18:39,110 --> 00:18:42,290
tree is using floats to store the local

00:18:41,510 --> 00:18:44,809
odds which do you know what the

00:18:42,290 --> 00:18:46,640
probabilities these do this you'll see

00:18:44,809 --> 00:18:48,710
the color oak tree is having some color

00:18:46,640 --> 00:18:51,380
attribute which you can use for

00:18:48,710 --> 00:18:54,309
visualizations or for integrating kind

00:18:51,380 --> 00:18:56,750
of data color pointers from the connect

00:18:54,309 --> 00:18:58,730
so most of the common functionality is

00:18:56,750 --> 00:19:00,860
in the occupancy oak tree so you can

00:18:58,730 --> 00:19:02,300
easily derive from it and build up your

00:19:00,860 --> 00:19:05,330
own oak tree data structure

00:19:02,300 --> 00:19:08,360
every have in mind you'll also notice

00:19:05,330 --> 00:19:10,850
that the oak tree nodes only stores data

00:19:08,360 --> 00:19:14,179
is actually only necessary which is a

00:19:10,850 --> 00:19:16,970
value a certain kind of data that's the

00:19:14,179 --> 00:19:19,820
payload that's stored in the nodes and a

00:19:16,970 --> 00:19:22,250
pointer to a child pointer array this is

00:19:19,820 --> 00:19:23,570
everything you need to to to build up

00:19:22,250 --> 00:19:24,950
this office they're not storing their

00:19:23,570 --> 00:19:27,770
own coordinates this would really blow

00:19:24,950 --> 00:19:30,590
up the memory you also know is this

00:19:27,770 --> 00:19:33,679
strange construct of having a pointer to

00:19:30,590 --> 00:19:35,240
an array of pointers of children the

00:19:33,679 --> 00:19:39,650
nice thing here is that we can have the

00:19:35,240 --> 00:19:41,120
same the same class for leaf nodes and

00:19:39,650 --> 00:19:43,130
for inner nodes which will allow us much

00:19:41,120 --> 00:19:44,840
resolution queries but at the same time

00:19:43,130 --> 00:19:46,580
it will allow us to to save memory

00:19:44,840 --> 00:19:49,039
because leaf nodes

00:19:46,580 --> 00:19:50,809
only have one unused null pointer which

00:19:49,039 --> 00:19:52,549
you can use to to find out that it's a

00:19:50,809 --> 00:19:55,279
leaf node whereas inner nodes will have

00:19:52,549 --> 00:19:56,840
one extra pointer with eight child

00:19:55,279 --> 00:20:00,110
pointers and this allows us to actually

00:19:56,840 --> 00:20:08,750
save up to 60 60 to 80 percent of the

00:20:00,110 --> 00:20:11,299
used memory so one other very popular

00:20:08,750 --> 00:20:14,419
use case is writing map files once

00:20:11,299 --> 00:20:17,720
you've recorded them or built them in

00:20:14,419 --> 00:20:20,750
your own mapping application then you

00:20:17,720 --> 00:20:22,820
can write out the full oak tree to a ot

00:20:20,750 --> 00:20:23,840
file which is an or three file but if

00:20:22,820 --> 00:20:25,399
you're only interested in the maximum

00:20:23,840 --> 00:20:27,380
likelihood which is sufficient for

00:20:25,399 --> 00:20:29,090
collision checks for example then you

00:20:27,380 --> 00:20:30,799
only need to encode the difference

00:20:29,090 --> 00:20:33,110
between free and occupied in this case

00:20:30,799 --> 00:20:34,760
you can write the BT file which we call

00:20:33,110 --> 00:20:36,049
the bonsai tree it's really tiny in the

00:20:34,760 --> 00:20:39,289
end it will be a couple of kilobytes

00:20:36,049 --> 00:20:41,480
large only you see again our example oak

00:20:39,289 --> 00:20:43,250
tree here at the top this is what part

00:20:41,480 --> 00:20:45,740
of the oak tree looks in memory and this

00:20:43,250 --> 00:20:50,149
is what the complete binary stream for a

00:20:45,740 --> 00:20:52,850
bt file will look like so so we're using

00:20:50,149 --> 00:20:55,850
only two bytes we require two bytes for

00:20:52,850 --> 00:20:57,740
each level of the oak tree so only two

00:20:55,850 --> 00:21:00,320
bits two for each node to differentiate

00:20:57,740 --> 00:21:02,870
between a free node an unknown node you

00:21:00,320 --> 00:21:05,409
see it here this is free this is unknown

00:21:02,870 --> 00:21:08,720
there's nothing there and an inner node

00:21:05,409 --> 00:21:11,899
which will be recursively reconstructed

00:21:08,720 --> 00:21:14,450
while reading the binary stream this

00:21:11,899 --> 00:21:16,250
just you know how we get this small file

00:21:14,450 --> 00:21:17,980
sizes and you can just call this with

00:21:16,250 --> 00:21:19,669
octree write binary and it will do this

00:21:17,980 --> 00:21:21,649
civilization to the binary stream

00:21:19,669 --> 00:21:23,899
whooshing also lose use for for meshes

00:21:21,649 --> 00:21:28,309
message exchange between different nodes

00:21:23,899 --> 00:21:34,490
in ROS then the reverse case reading map

00:21:28,309 --> 00:21:36,260
files since we have this general

00:21:34,490 --> 00:21:37,820
structure that an octree can actually

00:21:36,260 --> 00:21:40,730
count anything in there you can do your

00:21:37,820 --> 00:21:43,190
own extension we have this factory

00:21:40,730 --> 00:21:45,019
pattern here which is at the top example

00:21:43,190 --> 00:21:47,029
an OT file you can store any kind of oak

00:21:45,019 --> 00:21:49,010
tree so you know introduce this abstract

00:21:47,029 --> 00:21:50,299
oak tree to read from a file will give

00:21:49,010 --> 00:21:52,700
you back a pointer to an abstract oak

00:21:50,299 --> 00:21:54,919
tree and then you need to check if the

00:21:52,700 --> 00:21:56,899
rate was successful and then dynamic

00:21:54,919 --> 00:21:57,789
asked to the the kind of class you

00:21:56,899 --> 00:22:01,419
expect

00:21:57,789 --> 00:22:02,679
mr. K since you don't really know what

00:22:01,419 --> 00:22:04,960
you're reading from the file until you

00:22:02,679 --> 00:22:05,769
look at the file all right but if you

00:22:04,960 --> 00:22:07,330
have a bt file

00:22:05,769 --> 00:22:09,190
that that's usual octree in there

00:22:07,330 --> 00:22:11,470
because it can only encode probability

00:22:09,190 --> 00:22:14,200
or occupancy information at the clamp

00:22:11,470 --> 00:22:16,659
values so this is a bit easier to read

00:22:14,200 --> 00:22:18,340
and write but you're not able to store

00:22:16,659 --> 00:22:20,320
any kind of probabilities or color

00:22:18,340 --> 00:22:23,889
information or anything else in the BG

00:22:20,320 --> 00:22:26,799
file except free and occupied so since

00:22:23,889 --> 00:22:28,509
we're all interested in Ross here we

00:22:26,799 --> 00:22:31,809
have a couple of convenience and helper

00:22:28,509 --> 00:22:34,059
functions to make this easier in the

00:22:31,809 --> 00:22:35,859
case of a fusing Ross we have the

00:22:34,059 --> 00:22:37,629
optimum messages packages there's a lock

00:22:35,859 --> 00:22:41,639
to map message in there that you can use

00:22:37,629 --> 00:22:46,809
to send around octrees between different

00:22:41,639 --> 00:22:48,729
nodes in your system and to to civilize

00:22:46,809 --> 00:22:52,389
and tissue allies there's a convergence

00:22:48,729 --> 00:22:55,690
of H again this looks very similar to

00:22:52,389 --> 00:22:57,429
the previous slides to serialize you're

00:22:55,690 --> 00:22:59,649
calling full map to message or binary

00:22:57,429 --> 00:23:01,509
map this is the OT file and this is

00:22:59,649 --> 00:23:03,609
corresponds to the bt file you're

00:23:01,509 --> 00:23:06,009
serializing this oak tree into this

00:23:03,609 --> 00:23:07,269
message and then you can send it out and

00:23:06,009 --> 00:23:08,889
this will really exploit all the

00:23:07,269 --> 00:23:10,539
properties we've seen before in the file

00:23:08,889 --> 00:23:12,519
so it's just the same as storing a file

00:23:10,539 --> 00:23:14,679
and sending it out and to deserialize

00:23:12,519 --> 00:23:16,029
again notice that this looks like the

00:23:14,679 --> 00:23:18,009
factory pattern we've seen before

00:23:16,029 --> 00:23:22,149
so we're calling the message to map

00:23:18,009 --> 00:23:24,190
function in conversion stage and then

00:23:22,149 --> 00:23:26,979
nito dynamic has two of the octree and

00:23:24,190 --> 00:23:28,330
this again will this this will look if

00:23:26,979 --> 00:23:29,679
it's a binary tree or not so you can

00:23:28,330 --> 00:23:31,419
just call this on any kind of oak tree

00:23:29,679 --> 00:23:33,159
message the message can contain a binary

00:23:31,419 --> 00:23:36,519
tree or a full oak tree there just like

00:23:33,159 --> 00:23:39,909
in there to note the difference and then

00:23:36,519 --> 00:23:43,509
you'll get your your oak tree class out

00:23:39,909 --> 00:23:45,190
of out of the serialized message so

00:23:43,509 --> 00:23:46,809
methylations is really important this is

00:23:45,190 --> 00:23:49,239
3d data and it's a bit harder to

00:23:46,809 --> 00:23:51,040
understand sometimes than just a simple

00:23:49,239 --> 00:23:53,500
2d projection or in

00:23:51,040 --> 00:23:55,510
the image we're bringing our own native

00:23:53,500 --> 00:23:58,960
visualization application based on

00:23:55,510 --> 00:24:01,299
OpenGL and QT but of course since we're

00:23:58,960 --> 00:24:05,049
using Ross more interesting for you will

00:24:01,299 --> 00:24:08,919
be Arvest in october servers the class

00:24:05,049 --> 00:24:11,740
you can use to send out or the ross note

00:24:08,919 --> 00:24:13,929
you can use to send out files and then

00:24:11,740 --> 00:24:15,429
it's also sending out a 3d visualization

00:24:13,929 --> 00:24:17,559
as a marker array that you can then

00:24:15,429 --> 00:24:19,840
display in RVs

00:24:17,559 --> 00:24:21,309
however just recently Julia's camera

00:24:19,840 --> 00:24:23,890
lawful or garage wrote and native

00:24:21,309 --> 00:24:27,040
harvest plugin it's in the octo map

00:24:23,890 --> 00:24:28,330
harvest displays package so you should

00:24:27,040 --> 00:24:30,070
really check this out the string you

00:24:28,330 --> 00:24:31,270
think it's being released starting with

00:24:30,070 --> 00:24:33,610
groovy

00:24:31,270 --> 00:24:35,770
so with this Arvest can natively display

00:24:33,610 --> 00:24:37,510
octo maps so you don't need to like

00:24:35,770 --> 00:24:39,190
convert them to some intermediate format

00:24:37,510 --> 00:24:40,870
like Marco Marco eros which again will

00:24:39,190 --> 00:24:44,049
be pretty large and inefficient so

00:24:40,870 --> 00:24:45,309
Arvest the iris plugin will DC last the

00:24:44,049 --> 00:24:47,470
tree and creative visibility

00:24:45,309 --> 00:24:48,820
visualization for you or even better if

00:24:47,470 --> 00:24:50,410
using movies to this is directly

00:24:48,820 --> 00:24:52,929
integrated in the movie planning scene

00:24:50,410 --> 00:24:58,840
visualization so it will display the

00:24:52,929 --> 00:25:03,700
optimum for you so one example use case

00:24:58,840 --> 00:25:06,820
or some tutorial how to do 3d mapping in

00:25:03,700 --> 00:25:08,559
Ross with octo map there's the optimum

00:25:06,820 --> 00:25:11,020
server for you if you're not using move

00:25:08,559 --> 00:25:13,900
it or heavens yet switch to move it it

00:25:11,020 --> 00:25:16,480
will integrate 3d point cloths by

00:25:13,900 --> 00:25:18,929
building incrementally and an optimum

00:25:16,480 --> 00:25:20,919
representation and will send out this

00:25:18,929 --> 00:25:23,380
representation on service requests and

00:25:20,919 --> 00:25:28,020
auras messages and will also send out a

00:25:23,380 --> 00:25:28,020
visualization what you need to do there

00:25:28,890 --> 00:25:33,250
it's listening to the cloud in topic

00:25:31,059 --> 00:25:36,010
which needs to be a point cloud to so

00:25:33,250 --> 00:25:37,660
need to you need to remap the topic to

00:25:36,010 --> 00:25:41,230
your actual data coming from the sensor

00:25:37,660 --> 00:25:44,740
and what's also important is that you

00:25:41,230 --> 00:25:46,780
you need a TF transform from the map

00:25:44,740 --> 00:25:48,700
frame to your robot sensor frame so your

00:25:46,780 --> 00:25:51,400
robot needs some sort of localization or

00:25:48,700 --> 00:25:52,780
other post estimate and there's an

00:25:51,400 --> 00:25:57,010
example on file that you can look into

00:25:52,780 --> 00:25:59,290
and here's an example that we've worked

00:25:57,010 --> 00:26:02,020
on here the now is mapping this

00:25:59,290 --> 00:26:03,480
environment with an ISO section sensor

00:26:02,020 --> 00:26:05,559
which is mounted on the top

00:26:03,480 --> 00:26:07,270
so it's walking around mapping the

00:26:05,559 --> 00:26:09,640
environment and integrating the data in

00:26:07,270 --> 00:26:12,010
octave map for to building a collision

00:26:09,640 --> 00:26:17,350
map which contains all the obstacles

00:26:12,010 --> 00:26:18,640
that you see over here so I really want

00:26:17,350 --> 00:26:20,770
to stress this since I get a couple of

00:26:18,640 --> 00:26:22,900
requests like iíve seen octa map I want

00:26:20,770 --> 00:26:24,370
to do 3d mapping how do I do this I have

00:26:22,900 --> 00:26:26,020
a robot have a sensor how do I do this

00:26:24,370 --> 00:26:27,610
so this is not an integrated mapping

00:26:26,020 --> 00:26:29,919
system I think we're not at a point

00:26:27,610 --> 00:26:32,110
where we can just plug and play any kind

00:26:29,919 --> 00:26:35,230
of 3d slam system to build up magically

00:26:32,110 --> 00:26:37,360
3d 3d maps by just putting a sensor on

00:26:35,230 --> 00:26:39,280
the robot so octo map here is doing one

00:26:37,360 --> 00:26:41,380
part and this is the mapping it's

00:26:39,280 --> 00:26:43,690
mapping with known poses so it needs a

00:26:41,380 --> 00:26:45,220
post estimate it's converting or

00:26:43,690 --> 00:26:47,770
integrating your point clouds into 3d

00:26:45,220 --> 00:26:50,289
occupancy maps it's not an integrated 3d

00:26:47,770 --> 00:26:52,360
slam system that you can you can just

00:26:50,289 --> 00:26:54,280
start and it will do everything for you

00:26:52,360 --> 00:26:56,559
so it needs the TF from the sensor to

00:26:54,280 --> 00:26:59,230
the map frame some examples that you can

00:26:56,559 --> 00:27:01,929
use is for example a 2d localization

00:26:59,230 --> 00:27:04,390
with G mapping or a MCL and Ross that's

00:27:01,929 --> 00:27:05,500
been running right on the pr2 if you

00:27:04,390 --> 00:27:07,570
have a good otama tree and this is

00:27:05,500 --> 00:27:09,100
sufficient as well or you can do this

00:27:07,570 --> 00:27:11,110
package like RTP DSLAM which does two

00:27:09,100 --> 00:27:13,630
slam for you and publishes the poses or

00:27:11,110 --> 00:27:15,580
any kind of other slam system so so

00:27:13,630 --> 00:27:20,020
that's really room for for more research

00:27:15,580 --> 00:27:23,169
or more development there so since öktem

00:27:20,020 --> 00:27:25,840
app is a standard C make project you'll

00:27:23,169 --> 00:27:28,690
you'll include this and use it just as a

00:27:25,840 --> 00:27:30,730
standard C make library so in your C

00:27:28,690 --> 00:27:33,340
make lists you just need to find octo

00:27:30,730 --> 00:27:36,039
map include directories and link

00:27:33,340 --> 00:27:37,659
libraries and that's it

00:27:36,039 --> 00:27:40,090
for us you also need to add this to your

00:27:37,659 --> 00:27:41,650
manifest if you want to release or for

00:27:40,090 --> 00:27:44,110
the new cut you can build system for

00:27:41,650 --> 00:27:47,020
your packaged XML and additional

00:27:44,110 --> 00:27:52,390
packages to use our octamer messages and

00:27:47,020 --> 00:27:56,320
octamer bras so finally to conclude this

00:27:52,390 --> 00:27:58,690
this part of the part of the tutorial

00:27:56,320 --> 00:28:01,360
and look at the API documentation is

00:27:58,690 --> 00:28:02,890
available from the optimum home page for

00:28:01,360 --> 00:28:04,330
further details on how you can use all

00:28:02,890 --> 00:28:06,220
the classes all the functionality in

00:28:04,330 --> 00:28:08,620
there and if you're not using the latest

00:28:06,220 --> 00:28:12,520
version you can also always compile your

00:28:08,620 --> 00:28:16,280
own documentation by running Mac Docs so

00:28:12,520 --> 00:28:18,350
get some properties of the library or

00:28:16,280 --> 00:28:20,120
how we can do mapping and how it will

00:28:18,350 --> 00:28:21,800
perform on various data sets we all have

00:28:20,120 --> 00:28:23,840
all these data sets and evaluation

00:28:21,800 --> 00:28:25,340
instructions online so if you want to

00:28:23,840 --> 00:28:26,750
work on some improvements or welcome to

00:28:25,340 --> 00:28:29,120
compare your mapping algorithm to it

00:28:26,750 --> 00:28:33,110
then you can look at our data sets there

00:28:29,120 --> 00:28:35,360
and compare the source here are usually

00:28:33,110 --> 00:28:37,310
3d laser scan since this was what we

00:28:35,360 --> 00:28:39,200
were and the sensor we had at the time

00:28:37,310 --> 00:28:41,360
we built the data sets in an outdoors

00:28:39,200 --> 00:28:42,590
from small-scale and large-scale so

00:28:41,360 --> 00:28:45,200
here's an office building this is

00:28:42,590 --> 00:28:46,340
building 79 a dead forever campus before

00:28:45,200 --> 00:28:49,940
we seen this in a couple of thirty

00:28:46,340 --> 00:28:52,250
slanderous heads already here

00:28:49,940 --> 00:28:54,170
the oxford memory is only forty two

00:28:52,250 --> 00:28:56,210
megabytes this is the complete map at

00:28:54,170 --> 00:28:57,200
five centimeter resolution including the

00:28:56,210 --> 00:28:59,840
free space which you don't see

00:28:57,200 --> 00:29:01,820
visualized here to compare this to it's

00:28:59,840 --> 00:29:04,400
very grid it's at 80 megabytes which is

00:29:01,820 --> 00:29:06,890
still ok but this is a very very well

00:29:04,400 --> 00:29:08,330
aligned so our 3d grid will be play nice

00:29:06,890 --> 00:29:10,040
here now if you have a large outdoor

00:29:08,330 --> 00:29:11,780
data set this is the complete computer

00:29:10,040 --> 00:29:13,940
science computer science campus at

00:29:11,780 --> 00:29:16,220
Freiburg this is the building 79 you

00:29:13,940 --> 00:29:19,700
just seen before so it's been quite

00:29:16,220 --> 00:29:22,010
quite large up to 3 meter into the

00:29:19,700 --> 00:29:24,080
longest axis and this in memory is only

00:29:22,010 --> 00:29:26,600
130 mega bytes including free and

00:29:24,080 --> 00:29:28,400
occupied space to compare this to a 3d

00:29:26,600 --> 00:29:29,690
grid if it's optimally aligned and

00:29:28,400 --> 00:29:32,510
you're doing this one shot with

00:29:29,690 --> 00:29:35,720
integration will be 650 megabytes in

00:29:32,510 --> 00:29:37,850
memory and you also see that the the

00:29:35,720 --> 00:29:40,670
beta files are really really tiny all

00:29:37,850 --> 00:29:44,330
this I think that the PNG file is even

00:29:40,670 --> 00:29:47,440
larger than then the oak tree which is

00:29:44,330 --> 00:29:47,440
according all the 3d information

00:29:53,179 --> 00:30:00,210
there's one more this is rough the new

00:29:56,700 --> 00:30:02,159
college data set epoxy it's a similar

00:30:00,210 --> 00:30:03,690
data set with this different central

00:30:02,159 --> 00:30:06,360
setup so here we don't have pan-tilt

00:30:03,690 --> 00:30:07,919
laser but instead it's using a sweeping

00:30:06,360 --> 00:30:09,750
laser to the left and right of the robot

00:30:07,919 --> 00:30:12,210
so it's mapping the environment as the

00:30:09,750 --> 00:30:14,159
robot advances similar properly

00:30:12,210 --> 00:30:16,230
properties it's only 50 megabytes

00:30:14,159 --> 00:30:18,269
there's less of free space encoded here

00:30:16,230 --> 00:30:19,470
so it's a bit smaller you see that robot

00:30:18,269 --> 00:30:20,279
didn't see anything here so it's not

00:30:19,470 --> 00:30:22,019
encoded in the map

00:30:20,279 --> 00:30:24,690
whereas this really cute really needs to

00:30:22,019 --> 00:30:27,809
encode all of this and in the tiny

00:30:24,690 --> 00:30:29,850
bounding box so here's a final example

00:30:27,809 --> 00:30:32,730
this is an indoor environment this is an

00:30:29,850 --> 00:30:34,320
office which was built the data was

00:30:32,730 --> 00:30:36,929
built with a Kinect and then aligned

00:30:34,320 --> 00:30:38,519
with RGB dslam here we encoding the

00:30:36,929 --> 00:30:40,500
color information so it's a bit larger

00:30:38,519 --> 00:30:44,220
so each node is not only encoding the

00:30:40,500 --> 00:30:47,279
probability but also RGB D RGB values so

00:30:44,220 --> 00:30:50,340
this whole office 8 by 7 meters 5 meters

00:30:47,279 --> 00:30:51,769
in hate of the map area at least is 46

00:30:50,340 --> 00:30:54,929
megabytes

00:30:51,769 --> 00:30:56,370
the octrees 22 megabytes writing to file

00:30:54,929 --> 00:30:58,200
including the color information or if

00:30:56,370 --> 00:31:02,940
you drop the color and you write a bt

00:30:58,200 --> 00:31:05,580
file it's only half megabyte large the

00:31:02,940 --> 00:31:08,519
memory usage for several resolutions you

00:31:05,580 --> 00:31:11,370
see that here for the Freiburg campus

00:31:08,519 --> 00:31:14,090
yeah it's a fiber campus this is a lock

00:31:11,370 --> 00:31:16,559
lock access so we're still having a

00:31:14,090 --> 00:31:18,630
exponential dependency on the memory of

00:31:16,559 --> 00:31:19,950
you can't really change that but we can

00:31:18,630 --> 00:31:23,190
change the order of magnitude what you

00:31:19,950 --> 00:31:25,559
see here over here is the the 3d grid

00:31:23,190 --> 00:31:27,480
it's 10 centimeter resolution it will be

00:31:25,559 --> 00:31:29,880
5 gigabytes in memory so this is already

00:31:27,480 --> 00:31:31,889
larger than any 32-bit system can

00:31:29,880 --> 00:31:34,889
actually store in memory whereas the

00:31:31,889 --> 00:31:37,080
oaktree is 1 gigabyte large use of tree

00:31:34,889 --> 00:31:39,059
compression and if use only the maximum

00:31:37,080 --> 00:31:40,889
likelihood oak tree and keep in the

00:31:39,059 --> 00:31:44,100
memory you can perform a more efficient

00:31:40,889 --> 00:31:46,980
compression which will go down to 500

00:31:44,100 --> 00:31:49,169
megabytes for at the smallest resolution

00:31:46,980 --> 00:31:51,690
of 0.1

00:31:49,169 --> 00:31:53,610
meters and centimeters so if you change

00:31:51,690 --> 00:31:57,539
the resolution of course you need less

00:31:53,610 --> 00:31:59,190
memory now in terms of efficiency of

00:31:57,539 --> 00:32:01,019
updating the map of course we have to

00:31:59,190 --> 00:32:02,490
perform ray casting so we need to spend

00:32:01,019 --> 00:32:04,559
some time calculating the race and

00:32:02,490 --> 00:32:06,870
updating all the voxels in between

00:32:04,559 --> 00:32:10,769
here we see the update time averaged

00:32:06,870 --> 00:32:12,779
over 100,000 points and what you also

00:32:10,769 --> 00:32:14,249
see is that this really depends on how

00:32:12,779 --> 00:32:16,379
long your beams are in the Freiburg

00:32:14,249 --> 00:32:18,389
campus we're using a sick laser

00:32:16,379 --> 00:32:21,509
rangefinder having range measurements

00:32:18,389 --> 00:32:23,610
outdoors up to 50 or 80 meters so this

00:32:21,509 --> 00:32:25,230
contributes a lot to this update time

00:32:23,610 --> 00:32:27,889
where it takes a second to integrate

00:32:25,230 --> 00:32:29,909
100,000 points now if you truncate this

00:32:27,889 --> 00:32:32,460
and you're updating only up to a certain

00:32:29,909 --> 00:32:34,320
range I think this is 10 cent 10 meters

00:32:32,460 --> 00:32:35,460
which is sufficient for outdoor mapping

00:32:34,320 --> 00:32:37,919
if you were to get in a couple of skins

00:32:35,460 --> 00:32:40,759
and then it comes about faster or we can

00:32:37,919 --> 00:32:43,139
also do is you can change the resolution

00:32:40,759 --> 00:32:44,850
what you also should keep in mind is if

00:32:43,139 --> 00:32:46,950
you have a Kinect or very dense point

00:32:44,850 --> 00:32:48,539
clouds then it makes sense to subsample

00:32:46,950 --> 00:32:50,340
them before you integrate the optimum

00:32:48,539 --> 00:32:54,749
otherwise it will do ray casting for

00:32:50,340 --> 00:32:57,029
every end point and integrate this then

00:32:54,749 --> 00:32:59,369
to access the map data you'll see that

00:32:57,029 --> 00:33:01,619
on the right this is using the iterators

00:32:59,369 --> 00:33:04,799
so it's running through all the octree

00:33:01,619 --> 00:33:07,289
in 50 milliseconds not doing anything

00:33:04,799 --> 00:33:09,450
just running through the OP tree what

00:33:07,289 --> 00:33:11,279
you also see here nicely is that the

00:33:09,450 --> 00:33:13,169
depth cutoff really pays off we're

00:33:11,279 --> 00:33:15,629
saving about half the time by using a

00:33:13,169 --> 00:33:17,369
coarser resolution so zero cutoff is

00:33:15,629 --> 00:33:19,259
we're using the full oak tree going down

00:33:17,369 --> 00:33:21,029
to the leaves at the smallest resolution

00:33:19,259 --> 00:33:22,980
if we don't need this if you have a map

00:33:21,029 --> 00:33:24,600
which is 10 centimeters but you're fine

00:33:22,980 --> 00:33:26,610
with using 27 meters for a collision

00:33:24,600 --> 00:33:32,730
check then this suddenly will be twice

00:33:26,610 --> 00:33:35,429
as fast so finally I'm coming to some

00:33:32,730 --> 00:33:37,889
applications example use cases of octo

00:33:35,429 --> 00:33:40,169
map what I've worked on is 60

00:33:37,889 --> 00:33:41,789
localization of a humanoid robot using

00:33:40,169 --> 00:33:43,559
an octa map of the environment which is

00:33:41,789 --> 00:33:45,960
built beforehand see the environment

00:33:43,559 --> 00:33:46,590
here this is a now robot with a laser

00:33:45,960 --> 00:33:48,749
rangefinder

00:33:46,590 --> 00:33:51,509
and he'll be using we implemented some

00:33:48,749 --> 00:33:53,639
Monte Carlo localization based on laser

00:33:51,509 --> 00:33:54,690
IMU and joint angle data and this is

00:33:53,639 --> 00:33:55,919
also available in Ross if you're

00:33:54,690 --> 00:33:58,940
interested in this use case you should

00:33:55,919 --> 00:34:02,309
use it you just look at this package

00:33:58,940 --> 00:34:04,200
it's it's also released open source and

00:34:02,309 --> 00:34:05,700
the central model here is Ray casting in

00:34:04,200 --> 00:34:07,350
October and this is directly running in

00:34:05,700 --> 00:34:09,210
October so if you just want the sensor

00:34:07,350 --> 00:34:11,750
model look into opportunity ray casting

00:34:09,210 --> 00:34:11,750
functionality

00:34:15,500 --> 00:34:20,610
so here the nowis in its home

00:34:18,240 --> 00:34:22,050
environment is get on your environment

00:34:20,610 --> 00:34:24,540
now we're doing global localization in

00:34:22,050 --> 00:34:26,580
the octa map you see particles all over

00:34:24,540 --> 00:34:30,270
the place and after integrating some

00:34:26,580 --> 00:34:32,160
measurements this this converges to the

00:34:30,270 --> 00:34:34,230
to the true pose which you see the top

00:34:32,160 --> 00:34:35,400
left in the corresponding video so it's

00:34:34,230 --> 00:34:37,520
integrating a couple of scans and it

00:34:35,400 --> 00:34:39,780
becomes more and more accurate and

00:34:37,520 --> 00:34:41,580
despite is really noisy motion of the

00:34:39,780 --> 00:34:43,919
now we have quite some some drift there

00:34:41,580 --> 00:34:46,440
of this hardwood floor we can actually

00:34:43,919 --> 00:34:54,990
accurately estimate the the 60 pose

00:34:46,440 --> 00:34:58,590
while while it's walking I'll skip over

00:34:54,990 --> 00:35:02,310
that for the sake of time the next use

00:34:58,590 --> 00:35:04,380
case not integral much here is tabletop

00:35:02,310 --> 00:35:06,810
manipulation or even mobile manipulation

00:35:04,380 --> 00:35:08,490
we've seen it and move it they used to

00:35:06,810 --> 00:35:10,770
be a Collider package which was doing

00:35:08,490 --> 00:35:12,150
this for our navigation now it's

00:35:10,770 --> 00:35:14,550
directly running and move it and running

00:35:12,150 --> 00:35:16,350
in like up to real-time updating sensor

00:35:14,550 --> 00:35:18,090
data you'll hopefully see this at the

00:35:16,350 --> 00:35:19,740
booth with a peer to you can really jump

00:35:18,090 --> 00:35:22,140
in and it will stop motion planning and

00:35:19,740 --> 00:35:24,510
replan around you and here octopus used

00:35:22,140 --> 00:35:26,970
as a publicity collision map updating

00:35:24,510 --> 00:35:29,820
from stereo or laser data or just the

00:35:26,970 --> 00:35:31,620
Kinect and this enables dynamic updates

00:35:29,820 --> 00:35:35,460
of the collision map while the robot is

00:35:31,620 --> 00:35:37,290
running and the nice thing here is you

00:35:35,460 --> 00:35:42,660
can directly collision check on

00:35:37,290 --> 00:35:45,210
October's with sel or move it not the

00:35:42,660 --> 00:35:48,060
use case is a navigational clutter or

00:35:45,210 --> 00:35:49,350
mobile manipulation here we're building

00:35:48,060 --> 00:35:50,730
also a collision back with October

00:35:49,350 --> 00:35:54,180
updating it while the robot drives

00:35:50,730 --> 00:35:56,160
around and if we then perform all body

00:35:54,180 --> 00:35:59,040
collision checks of the complete robot

00:35:56,160 --> 00:36:01,650
mode mesh model this enables us to

00:35:59,040 --> 00:36:03,600
actually drive the robot optimally to a

00:36:01,650 --> 00:36:05,820
table to talk under it it doesn't need

00:36:03,600 --> 00:36:10,160
to be tail operated and it also will

00:36:05,820 --> 00:36:13,800
allow us to to traverse narrow passages

00:36:10,160 --> 00:36:15,510
I'll just show the video here this is

00:36:13,800 --> 00:36:19,740
the 3d obstacle map you see there's lots

00:36:15,510 --> 00:36:21,330
of clutter this is kind of lab

00:36:19,740 --> 00:36:22,380
environment at Willow Garage where

00:36:21,330 --> 00:36:23,670
people are sitting and working and

00:36:22,380 --> 00:36:25,240
putting up their chairs and all kinds of

00:36:23,670 --> 00:36:28,640
stuff

00:36:25,240 --> 00:36:30,650
so this was built beforehand so the

00:36:28,640 --> 00:36:32,030
robot can implant in this but it's

00:36:30,650 --> 00:36:34,820
updating what its drives around and

00:36:32,030 --> 00:36:36,680
you'll see now that it drives to the

00:36:34,820 --> 00:36:38,360
table to pick up the basket this is a

00:36:36,680 --> 00:36:40,820
pretty fine motion to pick up motion but

00:36:38,360 --> 00:36:45,850
everything else is planned and executed

00:36:40,820 --> 00:36:50,750
autonomously this was a joint work with

00:36:45,850 --> 00:36:52,280
such unit at Willow and Gil and and

00:36:50,750 --> 00:36:55,550
people from Maxim liquor chef's lab

00:36:52,280 --> 00:36:57,530
where I'm here we're using the surface

00:36:55,550 --> 00:36:59,630
planning library to perform these

00:36:57,530 --> 00:37:02,330
holonomic motions this is the path robot

00:36:59,630 --> 00:37:02,810
computers using these 3d collision

00:37:02,330 --> 00:37:04,760
checks

00:37:02,810 --> 00:37:06,620
now since 3d collision checks are

00:37:04,760 --> 00:37:08,900
expensive we implement a speed-up where

00:37:06,620 --> 00:37:12,290
it's using multiple layers of projected

00:37:08,900 --> 00:37:13,460
2d maps from the octo map to rule out

00:37:12,290 --> 00:37:15,800
collision checks you you're still

00:37:13,460 --> 00:37:17,930
preserving the flexibility of performing

00:37:15,800 --> 00:37:21,140
whole body 3d collision checks but you

00:37:17,930 --> 00:37:23,090
can speed them up by maintaining several

00:37:21,140 --> 00:37:25,670
layers of 2d projections which represent

00:37:23,090 --> 00:37:27,680
the robot so for example you have one

00:37:25,670 --> 00:37:29,450
layer corresponding to the base which is

00:37:27,680 --> 00:37:30,590
really kind of this compact shape and if

00:37:29,450 --> 00:37:32,480
there's a collision there you don't need

00:37:30,590 --> 00:37:34,070
to perform any 3d collision checks and

00:37:32,480 --> 00:37:37,490
you receive this challenging part where

00:37:34,070 --> 00:37:38,660
it has to move sideways since it

00:37:37,490 --> 00:37:40,670
couldn't really put the basket away

00:37:38,660 --> 00:37:46,370
needs to slide under the table with a

00:37:40,670 --> 00:37:47,870
base will be exciting to see and I think

00:37:46,370 --> 00:37:51,170
this could be implemented and move it

00:37:47,870 --> 00:37:57,490
nowadays in I don't know you want what

00:37:51,170 --> 00:37:57,490
you say a couple of days one day okay

00:37:58,930 --> 00:38:04,180
some extensions I'll only show you this

00:38:02,390 --> 00:38:07,100
briefly there are aqua hierarchies

00:38:04,180 --> 00:38:10,130
president by my colleague Kai at Arras

00:38:07,100 --> 00:38:12,350
biosis level 2011 here we have local sub

00:38:10,130 --> 00:38:14,110
maps of we have multiple octo maps with

00:38:12,350 --> 00:38:16,490
different resolutions and this allows us

00:38:14,110 --> 00:38:18,830
to move them independently with

00:38:16,490 --> 00:38:20,300
different coordinate origins and my

00:38:18,830 --> 00:38:22,310
other colleagues Christophe and Boris

00:38:20,300 --> 00:38:24,620
from Freiburg they worked on 3d distance

00:38:22,310 --> 00:38:26,120
maps which you see here based on Optima

00:38:24,620 --> 00:38:27,470
they can be incrementally updated so

00:38:26,120 --> 00:38:29,180
this would be a nice use case for a

00:38:27,470 --> 00:38:31,850
collision checking you see the distance

00:38:29,180 --> 00:38:34,280
we have displayed here and this is also

00:38:31,850 --> 00:38:35,720
already available in the optimum

00:38:34,280 --> 00:38:38,090
distribution it's not yet released in

00:38:35,720 --> 00:38:40,370
Taurus but you can get this dynamic ETS

00:38:38,090 --> 00:38:44,030
from the ultimate homepage bundled with

00:38:40,370 --> 00:38:48,230
optimum so I'll get to the summary of

00:38:44,030 --> 00:38:50,180
this past 40 minutes I present a memory

00:38:48,230 --> 00:38:51,950
efficient map data structure if you

00:38:50,180 --> 00:38:53,900
haven't seen before this is optimal

00:38:51,950 --> 00:38:57,170
it's a volumetric representation of

00:38:53,900 --> 00:38:58,850
occupied free and unknown space the

00:38:57,170 --> 00:39:00,590
implementation of combat functionality

00:38:58,850 --> 00:39:03,140
is already in there so you can do sensor

00:39:00,590 --> 00:39:05,510
updates of your range of your range data

00:39:03,140 --> 00:39:09,020
or single race you can do ray casting

00:39:05,510 --> 00:39:10,970
for localization it's all open source

00:39:09,020 --> 00:39:14,090
BSD license and has a tight integration

00:39:10,970 --> 00:39:17,390
and to move it and Ross and SEL for

00:39:14,090 --> 00:39:19,370
collision checking and whatever you just

00:39:17,390 --> 00:39:21,470
leave me a message if you have some nice

00:39:19,370 --> 00:39:24,380
use case for it we're always happy to

00:39:21,470 --> 00:39:25,700
see like how you can use octo map things

00:39:24,380 --> 00:39:26,750
do you think of its localization and

00:39:25,700 --> 00:39:29,450
collision of borders but maybe there's

00:39:26,750 --> 00:39:31,810
another nice use case thanks for your

00:39:29,450 --> 00:39:31,810

YouTube URL: https://www.youtube.com/watch?v=RRP29VnY8go


