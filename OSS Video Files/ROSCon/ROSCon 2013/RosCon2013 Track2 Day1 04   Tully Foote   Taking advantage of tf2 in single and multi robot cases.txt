Title: RosCon2013 Track2 Day1 04   Tully Foote   Taking advantage of tf2 in single and multi robot cases
Publication date: 2014-08-31
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:05,580
hi there yeah unfortunately the abstract

00:00:04,049 --> 00:00:07,649
for this was a little speculative on

00:00:05,580 --> 00:00:10,070
future development happening between the

00:00:07,649 --> 00:00:12,690
abstract being submitted and now

00:00:10,070 --> 00:00:15,240
unfortunately that development has not

00:00:12,690 --> 00:00:18,210
exactly happened so part of this will be

00:00:15,240 --> 00:00:20,789
a call for more interest from you guys

00:00:18,210 --> 00:00:22,529
and also this is a good segue following

00:00:20,789 --> 00:00:24,750
Daniels talk because a lot of the

00:00:22,529 --> 00:00:28,650
outstanding work in relation to multi

00:00:24,750 --> 00:00:29,820
master and multi-robot environments so

00:00:28,650 --> 00:00:32,340
to start off I'm going to talk about

00:00:29,820 --> 00:00:35,520
what is going on with tf2 what's there

00:00:32,340 --> 00:00:39,450
and what's going forward a quick

00:00:35,520 --> 00:00:42,899
definition of what tf2 is is simply it's

00:00:39,450 --> 00:00:46,800
a refinement of tia we wrote I wrote TF

00:00:42,899 --> 00:00:48,000
almost five plus years ago a lot of

00:00:46,800 --> 00:00:51,449
people have used it all around the world

00:00:48,000 --> 00:00:52,379
and from looking at helping people use

00:00:51,449 --> 00:00:55,980
it I realized there was a lot of

00:00:52,379 --> 00:00:57,629
shortcomings in the ways it was done but

00:00:55,980 --> 00:00:59,489
it's also been proven to be very strong

00:00:57,629 --> 00:01:01,829
so we wanted to come back and just take

00:00:59,489 --> 00:01:02,879
another pass at it and really nup some

00:01:01,829 --> 00:01:06,360
of the things that we could have done

00:01:02,879 --> 00:01:07,680
better but keeping everything as similar

00:01:06,360 --> 00:01:09,689
as possible to make sure that people can

00:01:07,680 --> 00:01:11,250
migrate it forward one of the biggest

00:01:09,689 --> 00:01:13,619
things we want to clean up dependencies

00:01:11,250 --> 00:01:14,580
we've done a templated api i'll come

00:01:13,619 --> 00:01:16,110
back and show you a little bit more

00:01:14,580 --> 00:01:17,310
details about that but means you don't

00:01:16,110 --> 00:01:19,049
the core library doesn't have

00:01:17,310 --> 00:01:22,890
dependencies on all the linear math

00:01:19,049 --> 00:01:25,320
libraries available in Ross we also have

00:01:22,890 --> 00:01:27,330
now first class support for Python the

00:01:25,320 --> 00:01:29,850
previous version had a rapt version of

00:01:27,330 --> 00:01:31,380
the C++ available in Python and the way

00:01:29,850 --> 00:01:34,140
we wrapped it meant that there were some

00:01:31,380 --> 00:01:35,840
ugly things he could run in a corner

00:01:34,140 --> 00:01:39,990
cases that you just couldn't work around

00:01:35,840 --> 00:01:42,689
we also discovered that subscribing to /

00:01:39,990 --> 00:01:45,990
TF on anything by the simplest robot is

00:01:42,689 --> 00:01:47,670
like subscribing to a fire hose and it

00:01:45,990 --> 00:01:50,759
can take up to five percent of your CPU

00:01:47,670 --> 00:01:52,770
just to subscribe to TF even on the pr2

00:01:50,759 --> 00:01:54,509
and if you have 20 little scripts

00:01:52,770 --> 00:01:59,610
running in the background monitoring TF

00:01:54,509 --> 00:02:01,290
that's also in a whole core and related

00:01:59,610 --> 00:02:02,850
that we also identify the static

00:02:01,290 --> 00:02:06,149
transform for something that could be

00:02:02,850 --> 00:02:07,649
treated as a unique case that could be

00:02:06,149 --> 00:02:09,530
treated differently and have significant

00:02:07,649 --> 00:02:12,180
improvements

00:02:09,530 --> 00:02:15,420
so as I mentioned we did the templated

00:02:12,180 --> 00:02:17,099
transform data method we've got template

00:02:15,420 --> 00:02:19,379
templated conversion methods which

00:02:17,099 --> 00:02:21,209
allows you to easily convert from one

00:02:19,379 --> 00:02:23,489
data type to another so if someone gives

00:02:21,209 --> 00:02:25,500
you a bullet trance bullet vector and

00:02:23,489 --> 00:02:28,440
you want an eigenvector there's now just

00:02:25,500 --> 00:02:30,300
a method to convert those and TF will

00:02:28,440 --> 00:02:32,790
actually let you work with both data

00:02:30,300 --> 00:02:35,549
types at the same time we've also

00:02:32,790 --> 00:02:38,730
separated out the Ross Ross API from the

00:02:35,549 --> 00:02:42,989
non Ross stuff so the core tf2 library

00:02:38,730 --> 00:02:44,930
only needs the ross the messages it does

00:02:42,989 --> 00:02:48,720
not need anything any other dependencies

00:02:44,930 --> 00:02:53,250
and we also set up a remote base query

00:02:48,720 --> 00:02:55,170
API I'll come back to the static and one

00:02:53,250 --> 00:02:58,349
other thing that we've done is drop

00:02:55,170 --> 00:03:00,030
support for the TF prefix any of you

00:02:58,349 --> 00:03:02,489
have the done multi-robot stuff you

00:03:00,030 --> 00:03:04,980
probably use TF prefix but it turns out

00:03:02,489 --> 00:03:07,200
that only about like ten percent of this

00:03:04,980 --> 00:03:10,739
code out there implements TF prefix

00:03:07,200 --> 00:03:12,450
correctly if it implements it and having

00:03:10,739 --> 00:03:13,950
something that's partially there and too

00:03:12,450 --> 00:03:17,780
complicated for most developers is

00:03:13,950 --> 00:03:19,769
actually worse than just not having it

00:03:17,780 --> 00:03:21,810
so to give you a little bit of

00:03:19,769 --> 00:03:23,910
explanation about the data conversions

00:03:21,810 --> 00:03:25,530
this is just a little bit of sample code

00:03:23,910 --> 00:03:27,420
here you can see we're pulling in the

00:03:25,530 --> 00:03:29,940
bullet data types the geometry message

00:03:27,420 --> 00:03:34,230
is in the kdl so if you had allocate a

00:03:29,940 --> 00:03:36,209
bullet vector and you can simply just

00:03:34,230 --> 00:03:38,790
call convert and you go from the bullet

00:03:36,209 --> 00:03:42,090
to the message and that's all you need

00:03:38,790 --> 00:03:43,920
to do because somebody like me has gone

00:03:42,090 --> 00:03:46,920
through previously and written the

00:03:43,920 --> 00:03:52,290
convert method that knows how to convert

00:03:46,920 --> 00:03:54,349
a bullet message to those the bullet

00:03:52,290 --> 00:03:56,849
datatype to the message data type and

00:03:54,349 --> 00:03:58,650
likewise if you've already done that you

00:03:56,849 --> 00:04:01,200
can also just trivially go to a kdl

00:03:58,650 --> 00:04:03,900
vector as long as the two message from

00:04:01,200 --> 00:04:05,700
message transforms are there and it's

00:04:03,900 --> 00:04:07,230
even smart enough that the template

00:04:05,700 --> 00:04:09,989
logic will work that if you want to go

00:04:07,230 --> 00:04:12,359
from a bullet type you can see the

00:04:09,989 --> 00:04:14,669
bullet type in the kdl type don't

00:04:12,359 --> 00:04:16,289
necessarily have a direct inversion but

00:04:14,669 --> 00:04:18,299
the compiler smart enough to convert it

00:04:16,289 --> 00:04:21,820
to the message and then convert from the

00:04:18,299 --> 00:04:24,130
message to the kdl data type afterwards

00:04:21,820 --> 00:04:25,990
and the neat thing with this is we've

00:04:24,130 --> 00:04:27,250
now got this new template of transform

00:04:25,990 --> 00:04:32,080
API so you can see that you can

00:04:27,250 --> 00:04:34,600
transform any any data type here this is

00:04:32,080 --> 00:04:39,760
the generic API it looks like the

00:04:34,600 --> 00:04:41,560
regular TF interface and we just simply

00:04:39,760 --> 00:04:43,240
all you have to do is define a do

00:04:41,560 --> 00:04:44,890
transform for your data type so if you

00:04:43,240 --> 00:04:48,010
want to convert any custom data type you

00:04:44,890 --> 00:04:50,050
just define do transform of T and then

00:04:48,010 --> 00:04:51,970
this can t f can handle it which is how

00:04:50,050 --> 00:04:53,410
we break the dependency cycle where TF

00:04:51,970 --> 00:04:55,570
needs to know your data type you just

00:04:53,410 --> 00:04:58,180
have to have this in your header you'll

00:04:55,570 --> 00:05:01,300
also note that we added our return by

00:04:58,180 --> 00:05:03,370
reference which will allow you to change

00:05:01,300 --> 00:05:06,370
things nicely so you can write and print

00:05:03,370 --> 00:05:08,410
the existing TF you have to pre-allocate

00:05:06,370 --> 00:05:09,820
something and then call the transform

00:05:08,410 --> 00:05:13,030
and then you can use it in another line

00:05:09,820 --> 00:05:15,310
you can now like a chain them in one

00:05:13,030 --> 00:05:16,870
line and the cool thing about this is

00:05:15,310 --> 00:05:19,450
you can actually asks you have to

00:05:16,870 --> 00:05:20,920
transform things from one data type to

00:05:19,450 --> 00:05:23,380
another you used to have to convert

00:05:20,920 --> 00:05:25,210
everything into the bullet data type so

00:05:23,380 --> 00:05:27,940
that TF could handle it now you can

00:05:25,210 --> 00:05:29,590
actually ask it to transform a bullet

00:05:27,940 --> 00:05:32,470
back you give it a bullet vector and say

00:05:29,590 --> 00:05:36,010
transform it into a kdl vector that i

00:05:32,470 --> 00:05:38,800
want out using these parameters very

00:05:36,010 --> 00:05:43,060
powerful and makes your code much

00:05:38,800 --> 00:05:45,460
simpler so as I mentioned we have the

00:05:43,060 --> 00:05:48,880
concept of static transforms which are

00:05:45,460 --> 00:05:51,520
simply the implementation is done is

00:05:48,880 --> 00:05:54,010
they're published on a latch topic / TF

00:05:51,520 --> 00:05:55,810
static and this means that each

00:05:54,010 --> 00:05:58,270
publisher publishes things once and

00:05:55,810 --> 00:06:00,970
anytime I nuke a new subscriber connects

00:05:58,270 --> 00:06:03,220
you get all the things from all the

00:06:00,970 --> 00:06:06,400
publishers already this means that all

00:06:03,220 --> 00:06:08,860
data going that's honest at this topic

00:06:06,400 --> 00:06:10,840
will go once to each subscriber and only

00:06:08,860 --> 00:06:12,760
once and they'll just know that it's

00:06:10,840 --> 00:06:15,640
there and if there's an update to it'll

00:06:12,760 --> 00:06:17,140
get republish to them but static topic

00:06:15,640 --> 00:06:22,690
the static transform should not be

00:06:17,140 --> 00:06:25,240
changing and there's also a underneath

00:06:22,690 --> 00:06:27,550
TF keeps the time history of all

00:06:25,240 --> 00:06:29,410
transforms and with the static

00:06:27,550 --> 00:06:31,120
transforms we simply say well it's

00:06:29,410 --> 00:06:33,190
static there's no need to t but keep a

00:06:31,120 --> 00:06:34,690
time history any time you clear the

00:06:33,190 --> 00:06:34,990
transform is published the static it

00:06:34,690 --> 00:06:36,610
will

00:06:34,990 --> 00:06:38,860
exactly the value of this last published

00:06:36,610 --> 00:06:40,720
and not bothered to go through the link

00:06:38,860 --> 00:06:47,200
list and incur the overhead of doing a

00:06:40,720 --> 00:06:48,910
look up another improvement in TF as i

00:06:47,200 --> 00:06:50,860
mentioned that subscribing to / TF is

00:06:48,910 --> 00:06:52,960
like a fire hose it has a lot of

00:06:50,860 --> 00:06:54,940
overhead and it turns out one of the

00:06:52,960 --> 00:06:57,130
standard models and ross is that you

00:06:54,940 --> 00:06:58,680
haven't monitoring usually like python

00:06:57,130 --> 00:07:01,690
script in the background monitoring say

00:06:58,680 --> 00:07:03,190
am i near the table and the way you

00:07:01,690 --> 00:07:05,710
asked to answer the question am i need a

00:07:03,190 --> 00:07:07,630
table you do a lookup from you to the

00:07:05,710 --> 00:07:09,910
table but you may only need to care

00:07:07,630 --> 00:07:11,710
about this once a second and if you want

00:07:09,910 --> 00:07:13,390
us to ask us something like this once a

00:07:11,710 --> 00:07:16,570
second you have to subscribe to the

00:07:13,390 --> 00:07:18,040
whole TF stream where as we've just

00:07:16,570 --> 00:07:21,250
simply put in an action in your face

00:07:18,040 --> 00:07:22,780
that says you can do this query via you

00:07:21,250 --> 00:07:25,120
can submit a query via an action

00:07:22,780 --> 00:07:26,710
interface to a remote process and it

00:07:25,120 --> 00:07:30,430
will give you back exactly the same

00:07:26,710 --> 00:07:31,960
interface in your code and you don't

00:07:30,430 --> 00:07:36,040
have to subscribe to the full TF stream

00:07:31,960 --> 00:07:37,960
so you're trading off overhead for a

00:07:36,040 --> 00:07:39,610
latency because if you're querying over

00:07:37,960 --> 00:07:43,360
action based interface is obvious going

00:07:39,610 --> 00:07:45,040
to be slower than a local query and this

00:07:43,360 --> 00:07:47,470
is also really useful if you say have

00:07:45,040 --> 00:07:52,660
lots of robots and they're running over

00:07:47,470 --> 00:07:55,330
wireless with a limited link so a couple

00:07:52,660 --> 00:07:56,410
of tf2 has actually been around for a

00:07:55,330 --> 00:07:59,590
couple of years is currently in

00:07:56,410 --> 00:08:00,760
experimental mode it's very close to be

00:07:59,590 --> 00:08:04,270
done there's lots of people already

00:08:00,760 --> 00:08:07,120
using it I haven't released it as a full

00:08:04,270 --> 00:08:09,160
release because I want to finish some of

00:08:07,120 --> 00:08:11,860
the outstanding issues that I'll get to

00:08:09,160 --> 00:08:15,190
later but as an example of people using

00:08:11,860 --> 00:08:19,570
peered tf2 is PR two plugs has been

00:08:15,190 --> 00:08:20,860
converted to use tf2 inside of it we

00:08:19,570 --> 00:08:22,570
went through the process of doing this

00:08:20,860 --> 00:08:24,700
if we made sure we verified correctness

00:08:22,570 --> 00:08:28,000
and robustness many of you have probably

00:08:24,700 --> 00:08:29,980
seen PR two plugs running it plugs in

00:08:28,000 --> 00:08:32,610
and you don't think about it and we're

00:08:29,980 --> 00:08:35,700
quite confident that CF 2 is

00:08:32,610 --> 00:08:37,900
mathematically correct because of this

00:08:35,700 --> 00:08:40,510
another example of taking advantage of

00:08:37,900 --> 00:08:44,200
tf2 is the robot web tools recently

00:08:40,510 --> 00:08:47,830
announced out of Willow Garage and a

00:08:44,200 --> 00:08:50,960
bunch of collaborators is a push to me

00:08:47,830 --> 00:08:54,200
ross tools available on websites and it

00:08:50,960 --> 00:08:57,410
turns out that subscribing to TF on your

00:08:54,200 --> 00:08:58,760
browser is also not a good idea and so

00:08:57,410 --> 00:09:02,270
what they put together is a tool that

00:08:58,760 --> 00:09:04,730
will take the TF tree subscribe to it

00:09:02,270 --> 00:09:07,220
build it in local memory and then

00:09:04,730 --> 00:09:11,060
republish it periodically or on demand

00:09:07,220 --> 00:09:13,430
as you set the parameters as an entire

00:09:11,060 --> 00:09:15,650
tree to your web browser so that you can

00:09:13,430 --> 00:09:19,090
use it you get a whole TF tree in your

00:09:15,650 --> 00:09:21,440
web browser but it's much simplified and

00:09:19,090 --> 00:09:27,290
the browser can have much lower

00:09:21,440 --> 00:09:29,060
bandwidth requirements so that's the

00:09:27,290 --> 00:09:33,080
state of TF I want to now look a little

00:09:29,060 --> 00:09:35,270
bit forward one of the major things that

00:09:33,080 --> 00:09:37,100
Daniel brought up earlier is you start

00:09:35,270 --> 00:09:39,620
dealing with multi-robot cases and you

00:09:37,100 --> 00:09:42,110
got partition networks and having a fire

00:09:39,620 --> 00:09:44,090
hose of 1tf going to between multiple

00:09:42,110 --> 00:09:44,960
robots suddenly becomes impossible when

00:09:44,090 --> 00:09:48,680
you start thinking about going for

00:09:44,960 --> 00:09:52,910
wireless likewise there's a major issue

00:09:48,680 --> 00:09:55,070
with disambiguating simulator robots if

00:09:52,910 --> 00:09:59,090
you have two robots and they both have

00:09:55,070 --> 00:10:02,600
the headframe I'll Senate third they

00:09:59,090 --> 00:10:04,940
can't actually share data effectively so

00:10:02,600 --> 00:10:06,170
when you're talking about sharing TF

00:10:04,940 --> 00:10:07,990
data there's a lot of things to think

00:10:06,170 --> 00:10:11,630
about what are the frames are interested

00:10:07,990 --> 00:10:13,640
how often you want updates how much lag

00:10:11,630 --> 00:10:16,850
can you tolerate how much air can you

00:10:13,640 --> 00:10:18,950
tolerate but also how much bandwidth is

00:10:16,850 --> 00:10:22,130
ok you have to think about all these

00:10:18,950 --> 00:10:23,900
things so we need to put together an API

00:10:22,130 --> 00:10:26,660
so you can set these tolerances for

00:10:23,900 --> 00:10:30,980
whatever your application is and makes

00:10:26,660 --> 00:10:33,020
you at available remotely via that and

00:10:30,980 --> 00:10:35,840
as I mentioned going more deeper into

00:10:33,020 --> 00:10:37,700
the multi-robot case so you have two

00:10:35,840 --> 00:10:39,500
robots like this robot one a robot too

00:10:37,700 --> 00:10:40,460
they look very similar they probably

00:10:39,500 --> 00:10:43,940
have the same software running

00:10:40,460 --> 00:10:47,570
underneath and they also have all the

00:10:43,940 --> 00:10:50,060
same frame IDs so just looking it very

00:10:47,570 --> 00:10:52,100
simple each one has a TF topic and a

00:10:50,060 --> 00:10:55,630
scan topic they're publishing a base

00:10:52,100 --> 00:10:58,620
scan in the base link

00:10:55,630 --> 00:11:00,940
and you need to get all the data from

00:10:58,620 --> 00:11:02,290
like robot one a robot to want to be

00:11:00,940 --> 00:11:04,870
able to share their data but it turns

00:11:02,290 --> 00:11:08,170
out that they're both publishing the

00:11:04,870 --> 00:11:09,880
base base link in their scan and if you

00:11:08,170 --> 00:11:11,920
want to just take data from one robot

00:11:09,880 --> 00:11:13,060
and put it on the other one you're going

00:11:11,920 --> 00:11:15,130
to have a major problem because they're

00:11:13,060 --> 00:11:16,510
both going to say well this scan is from

00:11:15,130 --> 00:11:19,690
base link and if they're looking

00:11:16,510 --> 00:11:21,790
opposite directions there the to map the

00:11:19,690 --> 00:11:22,630
two scans are going to be mapped on top

00:11:21,790 --> 00:11:23,920
of each other because they're

00:11:22,630 --> 00:11:25,870
referencing now the wrong coordinate

00:11:23,920 --> 00:11:27,640
frame so you need to be able to do

00:11:25,870 --> 00:11:30,730
something like take base link and turn

00:11:27,640 --> 00:11:33,240
it into robot one base link and that's

00:11:30,730 --> 00:11:35,830
relatively easy to do for the TF topic

00:11:33,240 --> 00:11:40,030
has a nice tree you just take everything

00:11:35,830 --> 00:11:44,020
on robot one prefix robot one and send

00:11:40,030 --> 00:11:46,900
it on a robot to TF topic however the

00:11:44,020 --> 00:11:49,240
data is not that obvious in the case of

00:11:46,900 --> 00:11:50,500
a laser scan it's relatively

00:11:49,240 --> 00:11:53,950
straightforward you just simply do a

00:11:50,500 --> 00:11:56,800
search or place any frame ID replace it

00:11:53,950 --> 00:11:59,260
with the prefix frame ID that you want

00:11:56,800 --> 00:12:03,010
on the other end but there are cases

00:11:59,260 --> 00:12:05,320
where this doesn't actually work if you

00:12:03,010 --> 00:12:09,520
have embedded frame ids inside of the

00:12:05,320 --> 00:12:11,290
middle of a payload which are they may

00:12:09,520 --> 00:12:13,450
not actually want to get referenced if

00:12:11,290 --> 00:12:16,120
it's a saying what is the parameter for

00:12:13,450 --> 00:12:21,040
my settings what is such as a cost map

00:12:16,120 --> 00:12:22,990
parameter or something like that so the

00:12:21,040 --> 00:12:25,150
big things outstanding or how to put

00:12:22,990 --> 00:12:27,340
deal with these multi-robot multimaster

00:12:25,150 --> 00:12:29,500
cases and I'd like to resolve that

00:12:27,340 --> 00:12:35,340
before recommending the entire community

00:12:29,500 --> 00:12:35,340

YouTube URL: https://www.youtube.com/watch?v=K2nMhR7RBNg


