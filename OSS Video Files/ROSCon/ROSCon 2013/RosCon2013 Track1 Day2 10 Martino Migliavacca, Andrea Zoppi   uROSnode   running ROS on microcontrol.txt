Title: RosCon2013 Track1 Day2 10 Martino Migliavacca, Andrea Zoppi   uROSnode   running ROS on microcontrol
Publication date: 2014-08-31
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/ http://roscon.ros.org/2013/?page_id=14
Captions: 
	00:00:00,000 --> 00:00:05,160
so hi to everybody I a multinomial baka

00:00:02,669 --> 00:00:07,140
and with andrea i will talk about mike

00:00:05,160 --> 00:00:09,090
rogers known that is a tiny

00:00:07,140 --> 00:00:13,280
implementation of Eros client running on

00:00:09,090 --> 00:00:16,619
microcontrollers to give some background

00:00:13,280 --> 00:00:18,150
we both work at the artist artificial

00:00:16,619 --> 00:00:21,210
intelligence and robotics lab at

00:00:18,150 --> 00:00:23,250
polytechnic criminal and in the lab in

00:00:21,210 --> 00:00:26,460
during the years we have the opportunity

00:00:23,250 --> 00:00:28,619
to build many robots principally mobile

00:00:26,460 --> 00:00:34,440
robots from a small platforms up to

00:00:28,619 --> 00:00:37,020
bigger unleaded vehicles building this

00:00:34,440 --> 00:00:39,090
robot as you may know it's difficult

00:00:37,020 --> 00:00:41,640
because every time you have to arraign

00:00:39,090 --> 00:00:45,680
vent something from scratch to control

00:00:41,640 --> 00:00:48,360
your custom platform so this is why we

00:00:45,680 --> 00:00:51,210
introduce a r2p the rapid rapid

00:00:48,360 --> 00:00:53,460
prototyping i presented yesterday during

00:00:51,210 --> 00:00:56,910
the lightning talk another view of it

00:00:53,460 --> 00:00:59,460
and it's basically is something with a

00:00:56,910 --> 00:01:01,890
frame or with a set of basic modules

00:00:59,460 --> 00:01:04,140
that implements the most common Arabic

00:01:01,890 --> 00:01:07,560
functionalities we need to prototype a

00:01:04,140 --> 00:01:09,570
robot and the boards are interfaced with

00:01:07,560 --> 00:01:12,530
the real-time canvas protocol and with a

00:01:09,570 --> 00:01:16,770
lightweight publish-subscribe middleware

00:01:12,530 --> 00:01:19,619
the goal of r2p is to implement and

00:01:16,770 --> 00:01:22,860
control the low level software and them

00:01:19,619 --> 00:01:25,110
of the platform but then of course we

00:01:22,860 --> 00:01:27,720
have to implement also the high level

00:01:25,110 --> 00:01:31,619
software which is often developed with

00:01:27,720 --> 00:01:34,770
Ross we are happy ross user users but

00:01:31,619 --> 00:01:36,329
the problem we always filled with ross

00:01:34,770 --> 00:01:41,250
is when you have to interface with the

00:01:36,329 --> 00:01:44,460
address as many devices use custom

00:01:41,250 --> 00:01:46,470
protocols on cellular connection or USB

00:01:44,460 --> 00:01:49,049
connection or even Ethernet connection

00:01:46,470 --> 00:01:51,720
but still with custom protocols so

00:01:49,049 --> 00:01:53,759
usually you have a software load for

00:01:51,720 --> 00:01:56,549
each devices that is device that is

00:01:53,759 --> 00:01:59,189
directly connected to the device and

00:01:56,549 --> 00:02:01,320
then the software node publishes

00:01:59,189 --> 00:02:07,680
messages ross messages over the ross

00:02:01,320 --> 00:02:09,959
network this is not i feel in the not

00:02:07,680 --> 00:02:11,550
not what the distributed architecture of

00:02:09,959 --> 00:02:15,490
ross is for

00:02:11,550 --> 00:02:19,050
so what we would like to have is a set

00:02:15,490 --> 00:02:24,160
of aside I mean many other devices that

00:02:19,050 --> 00:02:27,400
natively speak Ross language so for

00:02:24,160 --> 00:02:29,530
example the sick Lazar who has a witch

00:02:27,400 --> 00:02:31,900
as a hitter regulation could directly

00:02:29,530 --> 00:02:35,350
publish Ross messages over the Rose

00:02:31,900 --> 00:02:38,260
network or we can have robotic basis

00:02:35,350 --> 00:02:41,350
robotic platforms which subscribe

00:02:38,260 --> 00:02:44,590
directly Ross topics and you can draw

00:02:41,350 --> 00:02:46,900
you can control the other and interface

00:02:44,590 --> 00:02:52,000
with yard where as it was a simple Ross

00:02:46,900 --> 00:02:54,640
node another advantage is that our

00:02:52,000 --> 00:02:57,010
devices can then directly speak each

00:02:54,640 --> 00:02:58,750
other without the need of the connection

00:02:57,010 --> 00:03:00,970
to the computer so you can reduce

00:02:58,750 --> 00:03:05,130
latency and it's much easier to

00:03:00,970 --> 00:03:10,030
integrate new devices to your system

00:03:05,130 --> 00:03:12,730
this is why we started developing my

00:03:10,030 --> 00:03:15,310
taurus node which is a lightweight Ross

00:03:12,730 --> 00:03:17,950
client it is not a part of Ross to

00:03:15,310 --> 00:03:21,010
embedded system it is not a standard

00:03:17,950 --> 00:03:23,830
Ross a client it is just a library which

00:03:21,010 --> 00:03:26,830
can interface directly with rose on

00:03:23,830 --> 00:03:28,600
microcontrollers the target platform our

00:03:26,830 --> 00:03:32,080
modern microcontrollers like the cortex

00:03:28,600 --> 00:03:35,230
and family and we decided to develop it

00:03:32,080 --> 00:03:37,900
in a sec so it's easier to part two new

00:03:35,230 --> 00:03:40,959
platforms and up to now it already

00:03:37,900 --> 00:03:44,650
supports the main Ross features like the

00:03:40,959 --> 00:03:47,320
xml RPC management protocol it speaks

00:03:44,650 --> 00:03:49,959
native eros data protocol and it

00:03:47,320 --> 00:03:53,560
features the Rose topics or services and

00:03:49,959 --> 00:03:56,950
Ross parameters now I want to give and

00:03:53,560 --> 00:03:59,110
they are the opportunity to talk about

00:03:56,950 --> 00:04:05,950
the implementation and describe how you

00:03:59,110 --> 00:04:08,489
can use micro Snowden your projects okay

00:04:05,950 --> 00:04:08,489
everybody

00:04:10,200 --> 00:04:17,560
okay macross note is written as a

00:04:15,580 --> 00:04:19,959
modular framework communication

00:04:17,560 --> 00:04:22,740
framework we try to apply an

00:04:19,959 --> 00:04:26,430
object-oriented style on top of ncc and

00:04:22,740 --> 00:04:30,250
so that it is easier to maintain I think

00:04:26,430 --> 00:04:33,480
we focused very hard on a multithreading

00:04:30,250 --> 00:04:36,790
so that we can use an operating system

00:04:33,480 --> 00:04:40,750
generic like POSIX or a real-time

00:04:36,790 --> 00:04:44,230
operating system like h-e-bs and which

00:04:40,750 --> 00:04:46,900
is often used in embedded system and is

00:04:44,230 --> 00:04:52,810
also a real time is also a hot topic I

00:04:46,900 --> 00:04:55,150
see at the arroz con 2013 we added a

00:04:52,810 --> 00:04:57,280
lightweight abstraction layer to

00:04:55,150 --> 00:04:59,350
interface to low-level drivers for

00:04:57,280 --> 00:05:01,480
communication memory management and the

00:04:59,350 --> 00:05:05,410
multis ranking multithreading as well

00:05:01,480 --> 00:05:09,130
and the integration with the user firmer

00:05:05,410 --> 00:05:12,100
is assisted by the use of code generator

00:05:09,130 --> 00:05:16,030
tool and also the users typically

00:05:12,100 --> 00:05:17,530
required only to write the function the

00:05:16,030 --> 00:05:19,480
aegean dollars for the topics and

00:05:17,530 --> 00:05:24,610
services while the messages are

00:05:19,480 --> 00:05:28,420
automatically generated by the way I've

00:05:24,610 --> 00:05:31,240
a few notes about the xml RPC limitation

00:05:28,420 --> 00:05:34,690
because there are some libraries outside

00:05:31,240 --> 00:05:37,210
which can you be used in C but the yarra

00:05:34,690 --> 00:05:40,150
they have a wild memory management the

00:05:37,210 --> 00:05:42,880
buffer everything and then do the

00:05:40,150 --> 00:05:47,500
departing then the parser the contents

00:05:42,880 --> 00:05:50,380
so that we developed a custom library to

00:05:47,500 --> 00:05:53,860
parse xml RPC messages and also stream

00:05:50,380 --> 00:05:56,050
them which parses them on the fly a

00:05:53,860 --> 00:05:58,480
single pass so that we use the least

00:05:56,050 --> 00:06:01,570
possible memory we could on a

00:05:58,480 --> 00:06:04,390
microcontroller and also the

00:06:01,570 --> 00:06:07,240
implementation I was written and to be

00:06:04,390 --> 00:06:09,490
easy to maintain by back end so it is

00:06:07,240 --> 00:06:13,480
not a generator like with with tools

00:06:09,490 --> 00:06:15,670
like bison or iaco or sun and there are

00:06:13,480 --> 00:06:16,590
also some limits because we use a

00:06:15,670 --> 00:06:21,210
microcontroller

00:06:16,590 --> 00:06:25,290
so strings messages at a limit in size

00:06:21,210 --> 00:06:28,710
and also we haven't added the compressed

00:06:25,290 --> 00:06:34,050
streams like a zipper which is sometimes

00:06:28,710 --> 00:06:37,080
really used by a virus core so about the

00:06:34,050 --> 00:06:40,200
generation flow we take the the point of

00:06:37,080 --> 00:06:44,370
view of the user so of the developer of

00:06:40,200 --> 00:06:46,710
the femur the user and uses the code

00:06:44,370 --> 00:06:50,790
generated providing a configuration file

00:06:46,710 --> 00:06:53,460
in which he wrote we write the list of

00:06:50,790 --> 00:06:56,790
top because topic services and their

00:06:53,460 --> 00:06:59,370
types and also other options and then

00:06:56,790 --> 00:07:01,440
the code generator takes the

00:06:59,370 --> 00:07:06,060
descriptions of the messages and

00:07:01,440 --> 00:07:08,420
services from the existing installation

00:07:06,060 --> 00:07:12,860
of Ross on the development machine and

00:07:08,420 --> 00:07:15,990
generate the code for message types

00:07:12,860 --> 00:07:18,150
there are message marshaling and

00:07:15,990 --> 00:07:21,120
marshalling functions and the stubs for

00:07:18,150 --> 00:07:24,090
the topic and routes and services and

00:07:21,120 --> 00:07:26,400
the letter functions ok this is an

00:07:24,090 --> 00:07:29,160
example of configuration file where we

00:07:26,400 --> 00:07:31,710
write for example the node name the

00:07:29,160 --> 00:07:34,110
topics and as well this is the confer

00:07:31,710 --> 00:07:36,840
configuration file to build a turtle

00:07:34,110 --> 00:07:39,480
sink loan so everybody I think knows the

00:07:36,840 --> 00:07:40,920
turtle team and it's good not not only

00:07:39,480 --> 00:07:44,580
because of this but also because it

00:07:40,920 --> 00:07:47,190
covers all most if not all of the

00:07:44,580 --> 00:07:51,030
features needed to build a single Ross

00:07:47,190 --> 00:07:54,900
node so it was a good benchmark we'll

00:07:51,030 --> 00:07:57,990
see later we can see the list of topics

00:07:54,900 --> 00:08:03,630
so they names and they types with the

00:07:57,990 --> 00:08:05,760
classic Ross notation okay this is an

00:08:03,630 --> 00:08:08,490
example of good call don't be scared I

00:08:05,760 --> 00:08:11,340
know this is a syndics quite different

00:08:08,490 --> 00:08:14,310
from what you're you are used to see so

00:08:11,340 --> 00:08:17,220
first because it's the eat sea so there

00:08:14,310 --> 00:08:19,500
is no name spacing and so on but also

00:08:17,220 --> 00:08:22,050
and because this is code automatically

00:08:19,500 --> 00:08:25,080
generated but the user is only required

00:08:22,050 --> 00:08:27,180
typically to fill in the variables the

00:08:25,080 --> 00:08:29,160
message via variables or it from them

00:08:27,180 --> 00:08:33,539
like you always do

00:08:29,160 --> 00:08:36,720
also arose and but they can also be used

00:08:33,539 --> 00:08:39,539
to do optimize the streaming and the

00:08:36,720 --> 00:08:42,960
rate amount of messages on the fly as

00:08:39,539 --> 00:08:44,820
well so I think it's a little more

00:08:42,960 --> 00:08:49,620
powerful than a direct buffering of

00:08:44,820 --> 00:08:52,170
messages okay and to do some evaluations

00:08:49,620 --> 00:08:56,810
we are using the gateway model provided

00:08:52,170 --> 00:09:01,350
for the r2p environment this platform

00:08:56,810 --> 00:09:04,170
amounts modern microcontrollers from st

00:09:01,350 --> 00:09:07,650
which months on an arm cortex-m core

00:09:04,170 --> 00:09:09,930
which is very recently m4 it has a 1

00:09:07,650 --> 00:09:14,550
megabyte of flash memory which is plenty

00:09:09,930 --> 00:09:20,130
of space on modern microcontrollers they

00:09:14,550 --> 00:09:22,680
also 192 kilobytes of RAM in a month

00:09:20,130 --> 00:09:25,580
fast ethernet port which is used to

00:09:22,680 --> 00:09:28,380
interface to the ross network and as

00:09:25,580 --> 00:09:31,100
operating system which shows a chibi us

00:09:28,380 --> 00:09:34,230
a real time because it's very easy to

00:09:31,100 --> 00:09:38,070
build a new application based on dt for

00:09:34,230 --> 00:09:41,210
a new femur and the WIP network stack

00:09:38,070 --> 00:09:46,650
for the management of the tcp/ip

00:09:41,210 --> 00:09:51,180
extremes so we wrote a turtle semen

00:09:46,650 --> 00:09:54,360
clone femur which was compiled with GCC

00:09:51,180 --> 00:09:57,000
at different levels of optimization the

00:09:54,360 --> 00:10:01,110
this was done to to see how big it was

00:09:57,000 --> 00:10:05,730
on the program memory and on the daram

00:10:01,110 --> 00:10:09,510
so we have some not some numbers here in

00:10:05,730 --> 00:10:11,760
the best case we we found that the

00:10:09,510 --> 00:10:14,520
micros know the requires less than 40

00:10:11,760 --> 00:10:17,130
kilobytes of program memory and on the

00:10:14,520 --> 00:10:21,450
memory on the wrong side we have proved

00:10:17,130 --> 00:10:25,140
that topics and services which are

00:10:21,450 --> 00:10:27,300
handled by as isolated threads require

00:10:25,140 --> 00:10:30,530
less than 1 kilobyte each which means

00:10:27,300 --> 00:10:33,850
that we can allocate even tens of

00:10:30,530 --> 00:10:39,200
communication channel at the time

00:10:33,850 --> 00:10:42,110
living on such platform okay we also

00:10:39,200 --> 00:10:44,750
made some communication performance

00:10:42,110 --> 00:10:48,890
benchmark which are simple but I think

00:10:44,750 --> 00:10:51,140
very very significant because we stream

00:10:48,890 --> 00:10:54,800
the one topic by varying the message

00:10:51,140 --> 00:10:56,300
size and measured a cpu usage here you

00:10:54,800 --> 00:10:59,750
can see on the left the transmission

00:10:56,300 --> 00:11:02,810
performance on the relative reception we

00:10:59,750 --> 00:11:05,630
have reached the end transmission at all

00:11:02,810 --> 00:11:09,589
a throughput of 20,000 messages per

00:11:05,630 --> 00:11:14,300
second and this is limited when the

00:11:09,589 --> 00:11:16,550
message is smaller than 100 bytes by the

00:11:14,300 --> 00:11:20,060
Ross topic hurts on my host machine

00:11:16,550 --> 00:11:23,149
which wasn't very fast so the platform

00:11:20,060 --> 00:11:26,120
the platform Wars even faster than my

00:11:23,149 --> 00:11:32,870
computer in doing this and we also see

00:11:26,120 --> 00:11:36,500
that uwp which is the de red okay the

00:11:32,870 --> 00:11:41,150
red line as they the biggest impact on

00:11:36,500 --> 00:11:44,089
on the CPU so it's not the fault of of a

00:11:41,150 --> 00:11:46,880
micro know the decrease of throughput

00:11:44,089 --> 00:11:52,089
when increasing the the message size but

00:11:46,880 --> 00:11:55,580
by because of the tcp/ip processing

00:11:52,089 --> 00:11:57,740
likewise on the other end when we do the

00:11:55,580 --> 00:12:01,520
reception we can see that we can reach

00:11:57,740 --> 00:12:04,580
around 110 thousand messages per second

00:12:01,520 --> 00:12:07,459
here the limit was also my host machine

00:12:04,580 --> 00:12:11,420
when messages were we're a smaller than

00:12:07,459 --> 00:12:13,430
one kilobyte and when messages were

00:12:11,420 --> 00:12:16,010
bigger than two kilobytes we also

00:12:13,430 --> 00:12:18,350
reached the eternal saturation so the

00:12:16,010 --> 00:12:22,610
performance when streaming and the

00:12:18,350 --> 00:12:25,579
receiving streams is not impacted by

00:12:22,610 --> 00:12:29,209
macros node but by the host machine the

00:12:25,579 --> 00:12:31,480
TCP protocol and also by the the

00:12:29,209 --> 00:12:35,540
processing itself made on such

00:12:31,480 --> 00:12:38,209
microcontroller ok as a use case we

00:12:35,540 --> 00:12:40,880
consider the omnidirectional robot tres

00:12:38,209 --> 00:12:42,240
cuatro tres katsu we developed in our

00:12:40,880 --> 00:12:45,390
lab

00:12:42,240 --> 00:12:48,200
it is made out of r2p models are the

00:12:45,390 --> 00:12:51,779
role models which work in a real-time

00:12:48,200 --> 00:12:53,790
over campus and as you can see the

00:12:51,779 --> 00:12:55,920
Gateway module we used for the

00:12:53,790 --> 00:12:58,880
benchmarks is used to interface to the

00:12:55,920 --> 00:13:01,920
Ross network it also does some

00:12:58,880 --> 00:13:07,190
computation like kinematic kinematics

00:13:01,920 --> 00:13:11,160
not only message production and consumer

00:13:07,190 --> 00:13:13,529
the d-orbitals amongst another computer

00:13:11,160 --> 00:13:16,200
which is which is only used as a roast

00:13:13,529 --> 00:13:18,899
master and to stream data from a camera

00:13:16,200 --> 00:13:23,459
to a remote computer so it is not used

00:13:18,899 --> 00:13:28,410
in this case for Ross processing ok this

00:13:23,459 --> 00:13:32,339
is the scheme the schematic of topics

00:13:28,410 --> 00:13:36,000
between the r2p modules and the Rose

00:13:32,339 --> 00:13:38,459
Marie nodes as you can see on in the

00:13:36,000 --> 00:13:42,360
middle there is our gateway which

00:13:38,459 --> 00:13:46,230
translates the messages from RTP and

00:13:42,360 --> 00:13:48,779
arousal and visa versa the user controls

00:13:46,230 --> 00:13:52,770
the de roberto by sending the velocity

00:13:48,779 --> 00:13:56,329
set points and can can read the distance

00:13:52,770 --> 00:14:00,300
of the obstacle near it and can also

00:13:56,329 --> 00:14:04,500
display ad but what is in front of the

00:14:00,300 --> 00:14:08,070
derivatives itself this is V this is a

00:14:04,500 --> 00:14:12,540
video recorded with three cameras day

00:14:08,070 --> 00:14:15,770
one on the Left shows the robot below

00:14:12,540 --> 00:14:18,839
there are my hands which control the

00:14:15,770 --> 00:14:23,339
Detroits color in a first-person first

00:14:18,839 --> 00:14:25,980
person view video game like manner and

00:14:23,339 --> 00:14:28,020
on the top right view there is the

00:14:25,980 --> 00:14:32,010
application we wrote on the remote

00:14:28,020 --> 00:14:34,380
computer which displays the what's in

00:14:32,010 --> 00:14:38,579
front of the robot and the set points of

00:14:34,380 --> 00:14:41,779
the which I made with my hands ok we can

00:14:38,579 --> 00:14:44,670
see that the robot is very reactive so

00:14:41,779 --> 00:14:47,930
micro sonoda can process things very

00:14:44,670 --> 00:14:49,660
fast we had no particular detail on

00:14:47,930 --> 00:14:53,770
communication on

00:14:49,660 --> 00:15:05,020
camera yes and it wasn't a very good

00:14:53,770 --> 00:15:07,510
camera okay micros mode is available on

00:15:05,020 --> 00:15:10,930
github it's an openness open source

00:15:07,510 --> 00:15:16,450
project it's already working there are

00:15:10,930 --> 00:15:18,810
some demos on the digital repository we

00:15:16,450 --> 00:15:21,940
provided the decode with the oxygen

00:15:18,810 --> 00:15:24,060
documentation so it's a I think very

00:15:21,940 --> 00:15:26,980
well documented everything is documented

00:15:24,060 --> 00:15:32,050
it supports the main roster features

00:15:26,980 --> 00:15:35,890
it's a very young project so we have

00:15:32,050 --> 00:15:38,590
some something to do sister to do like

00:15:35,890 --> 00:15:41,140
the addition of the UDP Ross protocol

00:15:38,590 --> 00:15:47,140
for efficient efficient communications

00:15:41,140 --> 00:15:51,790
and maybe C++ brokers to provide an API

00:15:47,140 --> 00:15:54,730
much closer to the current API or C++ so

00:15:51,790 --> 00:15:58,060
it must be even easier to write a firmer

00:15:54,730 --> 00:16:00,790
like you do with Ross C++ on a generic

00:15:58,060 --> 00:16:04,780
computer we are also very open to

00:16:00,790 --> 00:16:06,760
suggestions for a future works and we

00:16:04,780 --> 00:16:12,490
know that there are other projects doing

00:16:06,760 --> 00:16:15,150
similar things so when when I started

00:16:12,490 --> 00:16:19,180
developing with Martino and this package

00:16:15,150 --> 00:16:22,060
we were there wasn't many things there

00:16:19,180 --> 00:16:25,120
were many things on the rocks wiki so we

00:16:22,060 --> 00:16:27,670
try to start from scratch but we are

00:16:25,120 --> 00:16:30,270
very open to any suggestions and maybe I

00:16:27,670 --> 00:16:34,780
don't know mention with some project or

00:16:30,270 --> 00:16:36,850
work as a reference to so for something

00:16:34,780 --> 00:16:41,140
you have to do something you don't have

00:16:36,850 --> 00:16:46,380
to do like we did okay thanks for

00:16:41,140 --> 00:16:46,380
listening and if your questions okay

00:16:48,050 --> 00:16:50,890

YouTube URL: https://www.youtube.com/watch?v=63jU08RtXKc


