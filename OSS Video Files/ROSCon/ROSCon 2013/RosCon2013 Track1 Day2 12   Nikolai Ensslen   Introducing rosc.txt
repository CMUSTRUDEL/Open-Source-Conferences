Title: RosCon2013 Track1 Day2 12   Nikolai Ensslen   Introducing rosc
Publication date: 2014-08-31
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:07,280
thank you and thanks to Morgan Andrea

00:00:03,350 --> 00:00:10,769
and Martino as well to give this session

00:00:07,280 --> 00:00:14,849
some momentum and I hope I won't repeat

00:00:10,769 --> 00:00:17,369
too many things in my talk I'd like to

00:00:14,849 --> 00:00:18,810
introduce you to Rossi which is a new

00:00:17,369 --> 00:00:21,300
client library that we're working on

00:00:18,810 --> 00:00:24,029
it's extremely lightweight portable and

00:00:21,300 --> 00:00:25,849
it tackles the challenges of Ross and

00:00:24,029 --> 00:00:30,750
industrial and product development use

00:00:25,849 --> 00:00:32,579
or it at least tries to do that so I

00:00:30,750 --> 00:00:34,829
need to start by telling you a bit about

00:00:32,579 --> 00:00:36,809
the background of this development if

00:00:34,829 --> 00:00:38,640
you ever build a complete robot from

00:00:36,809 --> 00:00:41,460
scratch you know about this situation

00:00:38,640 --> 00:00:43,200
here you need to put a big effort into

00:00:41,460 --> 00:00:46,050
establishing the infrastructure you need

00:00:43,200 --> 00:00:47,760
to start developing software mostly you

00:00:46,050 --> 00:00:50,579
end up with a couple of pcs running

00:00:47,760 --> 00:00:52,020
various operating systems automation

00:00:50,579 --> 00:00:54,510
industry components and a bunch of

00:00:52,020 --> 00:00:57,570
microcontroller and fpga boards that you

00:00:54,510 --> 00:00:58,829
probably even need to build yourself so

00:00:57,570 --> 00:01:00,960
there are a couple of locations to

00:00:58,829 --> 00:01:03,239
develop for probably using a range of

00:01:00,960 --> 00:01:04,470
development environments but in the end

00:01:03,239 --> 00:01:09,930
everything needs to work together

00:01:04,470 --> 00:01:12,119
properly which is why we think in

00:01:09,930 --> 00:01:13,619
robotics any other end any other

00:01:12,119 --> 00:01:17,070
application that uses a multitude of

00:01:13,619 --> 00:01:18,659
sensors a nap and actuators we need to

00:01:17,070 --> 00:01:21,299
go to words distributed synchronized

00:01:18,659 --> 00:01:23,580
computing and control and we're

00:01:21,299 --> 00:01:26,159
efficient yet powerful nodes carry out a

00:01:23,580 --> 00:01:28,110
connected systems behavior and can

00:01:26,159 --> 00:01:32,240
transmit transparently develop software

00:01:28,110 --> 00:01:35,310
that still runs across all of the system

00:01:32,240 --> 00:01:37,409
so which is why we developed an awesome

00:01:35,310 --> 00:01:39,659
technology and modular hardware software

00:01:37,409 --> 00:01:41,700
platform which we called in arc it aims

00:01:39,659 --> 00:01:43,649
to take all the pain out of systems

00:01:41,700 --> 00:01:45,299
engineering and lets you focus on your

00:01:43,649 --> 00:01:47,040
actual application but I don't want to

00:01:45,299 --> 00:01:51,030
advertise too much here so let's see

00:01:47,040 --> 00:01:52,740
what it has to do with Russ um the

00:01:51,030 --> 00:01:55,140
system architecture that is supported by

00:01:52,740 --> 00:01:57,750
today's Ross is like that you have this

00:01:55,140 --> 00:02:00,930
one pc that runs ross and then a couple

00:01:57,750 --> 00:02:03,180
of distributed devices that you whether

00:02:00,930 --> 00:02:05,579
connect through something like USB if

00:02:03,180 --> 00:02:07,590
it's a camera or a connect or when it

00:02:05,579 --> 00:02:10,530
comes to motor mostly

00:02:07,590 --> 00:02:12,900
filters to which you interface through a

00:02:10,530 --> 00:02:15,660
rose note that could be referred to as a

00:02:12,900 --> 00:02:17,370
proxy also like R a serial for example

00:02:15,660 --> 00:02:19,940
all your custom design like when using

00:02:17,370 --> 00:02:23,700
ethercat you usually have a CAD master

00:02:19,940 --> 00:02:26,099
wrapped into a rose node this is not

00:02:23,700 --> 00:02:28,260
good because while you close position

00:02:26,099 --> 00:02:30,060
control loops over the field passes

00:02:28,260 --> 00:02:33,299
there is a limit of somewhere around 1

00:02:30,060 --> 00:02:34,980
kilohertz for up to 10 axis even when

00:02:33,299 --> 00:02:37,950
we're using high-speed standards like

00:02:34,980 --> 00:02:40,709
EtherCAT for example its safety critical

00:02:37,950 --> 00:02:43,590
because mostly a single pcs in the loop

00:02:40,709 --> 00:02:45,660
and as motion control is a real time

00:02:43,590 --> 00:02:48,269
domain it fights against the other stuff

00:02:45,660 --> 00:02:52,140
running on your PC it lives on the same

00:02:48,269 --> 00:02:54,299
machine and this reduces quality of

00:02:52,140 --> 00:02:57,209
motion control sometimes interruptions

00:02:54,299 --> 00:02:59,400
and you have less resources for higher

00:02:57,209 --> 00:03:05,250
intelligence like your perceptions lamb

00:02:59,400 --> 00:03:08,819
whatever making decisions so now if we

00:03:05,250 --> 00:03:10,349
could allocate motion control as well it

00:03:08,819 --> 00:03:11,819
sends the data preprocessing to the

00:03:10,349 --> 00:03:18,420
distributed notes this would be awesome

00:03:11,819 --> 00:03:20,609
without and the problem is that devices

00:03:18,420 --> 00:03:24,359
usually are no full-fledged pcs where

00:03:20,609 --> 00:03:26,459
you can run any any software and which

00:03:24,359 --> 00:03:31,230
is why we need a small client library

00:03:26,459 --> 00:03:33,540
for small embedded devices and using

00:03:31,230 --> 00:03:36,150
such a client library as you heard

00:03:33,540 --> 00:03:39,480
micros no door assy using this it

00:03:36,150 --> 00:03:41,400
becomes even more possible to distribute

00:03:39,480 --> 00:03:44,280
motion control and make it interact with

00:03:41,400 --> 00:03:45,810
perception at a low level enabling you

00:03:44,280 --> 00:03:52,799
to implement things like reflexes

00:03:45,810 --> 00:03:56,340
without needing a PC at all and to give

00:03:52,799 --> 00:03:58,470
an example I guess you know about only

00:03:56,340 --> 00:04:00,630
directional basis using mecanim wheels

00:03:58,470 --> 00:04:04,260
like the cuckoo bird has it for example

00:04:00,630 --> 00:04:06,840
and classically position control is

00:04:04,260 --> 00:04:09,019
carried out by the pc using a model

00:04:06,840 --> 00:04:12,540
dealing with the McCallum wheels and

00:04:09,019 --> 00:04:15,329
odometry by setting speed and reading

00:04:12,540 --> 00:04:17,789
positions of the four wheels which leads

00:04:15,329 --> 00:04:20,390
to happen a lot of times per second to

00:04:17,789 --> 00:04:20,390
be precise

00:04:20,820 --> 00:04:25,230
now if we move this intelligence to

00:04:22,980 --> 00:04:26,750
distribute motor controllers we don't

00:04:25,230 --> 00:04:29,610
need to close the loop on the pc anymore

00:04:26,750 --> 00:04:32,700
an abstract commands at a few times per

00:04:29,610 --> 00:04:34,940
second is enough just one or just once

00:04:32,700 --> 00:04:38,190
if it's enough for your application and

00:04:34,940 --> 00:04:39,540
of course in this situation the local

00:04:38,190 --> 00:04:42,120
control loops on the devices can be

00:04:39,540 --> 00:04:43,650
closed much faster like up to 10

00:04:42,120 --> 00:04:45,750
kilohertz for position control depending

00:04:43,650 --> 00:04:47,340
on what you do for impedance control of

00:04:45,750 --> 00:04:51,780
course the computational capacity is

00:04:47,340 --> 00:04:55,560
limit and to send such abstract commands

00:04:51,780 --> 00:04:57,300
Ross would be perfect of course it's the

00:04:55,560 --> 00:05:01,920
same story for manipulators only took

00:04:57,300 --> 00:05:03,720
the example of this mobile base all

00:05:01,920 --> 00:05:05,370
right so we want to bring Ross to amber

00:05:03,720 --> 00:05:09,690
the devices but what is an embedded

00:05:05,370 --> 00:05:11,700
device Morgan already did some

00:05:09,690 --> 00:05:14,310
definition on this but within the

00:05:11,700 --> 00:05:16,170
special interest group embedded and

00:05:14,310 --> 00:05:19,470
especially during rust for products

00:05:16,170 --> 00:05:26,010
workshop in February we came up with

00:05:19,470 --> 00:05:28,620
kind of a classification and the we have

00:05:26,010 --> 00:05:30,990
an kind of animated class which refers

00:05:28,620 --> 00:05:34,680
to the cortex a or also an intel atom

00:05:30,990 --> 00:05:36,780
processor where we have the challenge of

00:05:34,680 --> 00:05:41,190
bringing standard ross on to it which is

00:05:36,780 --> 00:05:43,410
also the effort of ross an arm and but

00:05:41,190 --> 00:05:49,770
still use the same type of ross that we

00:05:43,410 --> 00:05:52,710
already have and the the challenge was a

00:05:49,770 --> 00:05:57,290
small embedded devices of course to get

00:05:52,710 --> 00:05:59,910
this new type of client library that

00:05:57,290 --> 00:06:03,420
enables you to run the same it'll bear

00:05:59,910 --> 00:06:06,420
on those devices and both are also

00:06:03,420 --> 00:06:08,550
application domains kind of where we use

00:06:06,420 --> 00:06:09,740
the small embedded devices mostly for

00:06:08,550 --> 00:06:13,890
control and data acquisition

00:06:09,740 --> 00:06:16,260
applications while the big emitted class

00:06:13,890 --> 00:06:19,110
or big embedded also then

00:06:16,260 --> 00:06:22,230
and a big x86 could be also embedded but

00:06:19,110 --> 00:06:24,890
let's say the cortex eight plans for

00:06:22,230 --> 00:06:27,420
things like perception and intelligence

00:06:24,890 --> 00:06:29,190
whatever intelligence is in this case

00:06:27,420 --> 00:06:32,420
can be many things so rusty is an

00:06:29,190 --> 00:06:34,440
implementation of the Ross middleware

00:06:32,420 --> 00:06:37,890
currently this means master

00:06:34,440 --> 00:06:40,140
communication by xml-rpc and no denote

00:06:37,890 --> 00:06:41,970
communication while TCP Ross it's

00:06:40,140 --> 00:06:44,790
lightweight that means by require it

00:06:41,970 --> 00:06:48,000
remains a smaller than 32 kilobyte on

00:06:44,790 --> 00:06:49,740
xmas chips it has no dependencies at all

00:06:48,000 --> 00:06:53,420
and is written in pure see the language

00:06:49,740 --> 00:06:56,010
that is supported mostly by any platform

00:06:53,420 --> 00:06:58,410
our reference platform is x-mas and you

00:06:56,010 --> 00:06:59,670
probably never heard of that and but

00:06:58,410 --> 00:07:04,080
it's an amazing piece of hardware

00:06:59,670 --> 00:07:06,480
multi-core up to 32 cores real-time

00:07:04,080 --> 00:07:09,330
hardware support on the hardware level

00:07:06,480 --> 00:07:12,810
and it's clocked up to 700 megahertz bit

00:07:09,330 --> 00:07:15,630
chip so a developer's FPGA performance

00:07:12,810 --> 00:07:19,290
but also has FPGA like memory resources

00:07:15,630 --> 00:07:21,300
only 64 k per tile and because

00:07:19,290 --> 00:07:23,550
everything needs to happen fast in this

00:07:21,300 --> 00:07:25,950
architecture unlike other micros an

00:07:23,550 --> 00:07:28,470
x-mas also runs programs from ram

00:07:25,950 --> 00:07:31,820
instead from flesh so we use a needle

00:07:28,470 --> 00:07:37,080
users 46k for program as well as data

00:07:31,820 --> 00:07:38,850
and yeah so if you listened to the

00:07:37,080 --> 00:07:42,690
micros no talk before you probably

00:07:38,850 --> 00:07:44,880
wonder how is rusty different so and

00:07:42,690 --> 00:07:47,190
both the web developer teams a couple of

00:07:44,880 --> 00:07:52,650
weeks ago did as well and this is why we

00:07:47,190 --> 00:07:55,170
hooked up and also synced up what yeah

00:07:52,650 --> 00:07:57,540
to see what are we doing different and

00:07:55,170 --> 00:07:59,760
where we going to and first of all

00:07:57,540 --> 00:08:03,650
michael ross is an academic project and

00:07:59,760 --> 00:08:07,170
Rossi is a commercial open source

00:08:03,650 --> 00:08:08,610
project and micro brass is available for

00:08:07,170 --> 00:08:10,020
use today they're working them was

00:08:08,610 --> 00:08:13,110
available and Rossi's to learn the

00:08:10,020 --> 00:08:15,690
development but on a technical base are

00:08:13,110 --> 00:08:18,300
three main differences rusty has tied

00:08:15,690 --> 00:08:20,040
down memory constraints mostly because

00:08:18,300 --> 00:08:23,280
it shall run on bare metal systems and

00:08:20,040 --> 00:08:26,760
the issue i told you before where micros

00:08:23,280 --> 00:08:28,520
until now relies on an OS the bare metal

00:08:26,760 --> 00:08:32,180
reference that we use and the

00:08:28,520 --> 00:08:33,620
also sets or requirements and the fact

00:08:32,180 --> 00:08:35,469
that we want to support more than just

00:08:33,620 --> 00:08:38,390
Ethernet communication in the long term

00:08:35,469 --> 00:08:41,599
leads Russy to have a modular transport

00:08:38,390 --> 00:08:47,630
layer concept where micros uses yet the

00:08:41,599 --> 00:08:49,580
OS infrastructure with LW RP this mod

00:08:47,630 --> 00:08:52,399
reality of rusty especially tackles

00:08:49,580 --> 00:08:54,190
portability rusty has a package concept

00:08:52,399 --> 00:08:57,160
that lets you adapt it to any platform

00:08:54,190 --> 00:08:59,899
main contains the client library itself

00:08:57,160 --> 00:09:02,600
now to support various OSS there are

00:08:59,899 --> 00:09:05,209
support packages that for example lets

00:09:02,600 --> 00:09:08,450
you interface to the ethernet driver of

00:09:05,209 --> 00:09:09,890
your linux on bare metal systems the way

00:09:08,450 --> 00:09:12,079
which you interface to an even the

00:09:09,890 --> 00:09:14,450
device is totally different from how you

00:09:12,079 --> 00:09:17,450
interface a Wi-Fi module for example so

00:09:14,450 --> 00:09:20,240
we also need to support each of these as

00:09:17,450 --> 00:09:22,399
well and the same applies to the various

00:09:20,240 --> 00:09:28,339
platforms they need to be supported as

00:09:22,399 --> 00:09:31,339
there is no s to care for that now of

00:09:28,339 --> 00:09:35,270
course you in the end at you're probably

00:09:31,339 --> 00:09:39,890
already Ross compatible code which is

00:09:35,270 --> 00:09:42,709
also why we'll add Ross c c++ rapper to

00:09:39,890 --> 00:09:44,899
it so that you could potentially use the

00:09:42,709 --> 00:09:47,750
same code that you had if it's fitting

00:09:44,899 --> 00:09:49,520
the platform of course now you take

00:09:47,750 --> 00:09:51,170
you're probably already raw streamlined

00:09:49,520 --> 00:09:53,800
code and put it together with the

00:09:51,170 --> 00:09:57,020
packages you need for your platform and

00:09:53,800 --> 00:09:59,300
receive an executable for an OS or a

00:09:57,020 --> 00:10:03,500
flashing blue bootable image for your

00:09:59,300 --> 00:10:05,360
micro that's it and our goal is that it

00:10:03,500 --> 00:10:08,270
shall just work for you as standard Rose

00:10:05,360 --> 00:10:10,490
does but there is some pain in

00:10:08,270 --> 00:10:15,560
developing this I guess you already

00:10:10,490 --> 00:10:18,560
heard of xml RPC just before in andrea's

00:10:15,560 --> 00:10:22,250
torque divorce already a shorts

00:10:18,560 --> 00:10:24,920
screenshot of this um yeah so this is

00:10:22,250 --> 00:10:28,100
xmlrpc you can imagine the challenge to

00:10:24,920 --> 00:10:31,970
keep a multitude of these messages in a

00:10:28,100 --> 00:10:34,630
few bites ram and running it fast no

00:10:31,970 --> 00:10:34,630
further comment

00:10:41,130 --> 00:10:46,000
so where we are currently we have an

00:10:43,630 --> 00:10:48,460
acceptable fast xmlrpc streaming parser

00:10:46,000 --> 00:10:50,320
which is more or less the biggest part

00:10:48,460 --> 00:10:52,120
of the story it is almost fully

00:10:50,320 --> 00:10:55,300
validating but does not support encoding

00:10:52,120 --> 00:10:58,000
like gzip and you need to set a limit

00:10:55,300 --> 00:11:01,750
for the tag depth that you want to be

00:10:58,000 --> 00:11:04,330
able to part of course it has a message

00:11:01,750 --> 00:11:06,310
generator as well pardon face handling

00:11:04,330 --> 00:11:08,260
which is naturally limited on bare metal

00:11:06,310 --> 00:11:10,600
systems like for example Wi-Fi modules

00:11:08,260 --> 00:11:13,360
where you have up to eight circuits

00:11:10,600 --> 00:11:14,860
mostly and support for TCP Ross

00:11:13,360 --> 00:11:16,390
transport so everything you need to

00:11:14,860 --> 00:11:18,400
communicate with the master in other

00:11:16,390 --> 00:11:20,500
nodes but what is more interesting than

00:11:18,400 --> 00:11:25,870
these essential features is what is

00:11:20,500 --> 00:11:27,940
about to come in the future and jumping

00:11:25,870 --> 00:11:30,070
back to this diagram here where I said

00:11:27,940 --> 00:11:32,290
you could implement reflexes for example

00:11:30,070 --> 00:11:35,560
it's easy to see that real-time

00:11:32,290 --> 00:11:40,660
capability would be very useful here

00:11:35,560 --> 00:11:43,780
where those reflexes being messaged now

00:11:40,660 --> 00:11:45,610
our long-term aim is is well to make all

00:11:43,780 --> 00:11:47,260
software running on the distributed know

00:11:45,610 --> 00:11:49,330
it's communicating with Ross middleware

00:11:47,260 --> 00:11:51,730
that means even locally on one

00:11:49,330 --> 00:11:58,060
microcontroller so here we need

00:11:51,730 --> 00:12:00,910
real-time even more and this is a

00:11:58,060 --> 00:12:04,530
summary of the requirements that we came

00:12:00,910 --> 00:12:06,700
up while talking to Ross industrial

00:12:04,530 --> 00:12:08,950
participants and also the participants

00:12:06,700 --> 00:12:13,480
to at the rust for products workshop

00:12:08,950 --> 00:12:16,420
Mountain View and some of these we want

00:12:13,480 --> 00:12:18,490
to address in the long term with Ross

00:12:16,420 --> 00:12:22,060
Sea which is especially the real-time

00:12:18,490 --> 00:12:24,640
capabilities we want to play around with

00:12:22,060 --> 00:12:28,690
replacing a scene or RPC by something

00:12:24,640 --> 00:12:32,710
else want to evaluate master three

00:12:28,690 --> 00:12:34,780
concepts and want to make it transport

00:12:32,710 --> 00:12:37,480
layer independent because you not always

00:12:34,780 --> 00:12:38,980
have internet at your micro or

00:12:37,480 --> 00:12:43,360
distribute node you also want to use

00:12:38,980 --> 00:12:49,570
canvas if a cat and probably even serial

00:12:43,360 --> 00:12:53,890
link and yeah so I'd like to

00:12:49,570 --> 00:12:57,130
in addition to that you have show you a

00:12:53,890 --> 00:13:00,520
little bit what we currently think could

00:12:57,130 --> 00:13:03,490
lead to a real-time capable Ross and if

00:13:00,520 --> 00:13:06,490
we look at today's Ross their main two

00:13:03,490 --> 00:13:09,850
issues with making it real time capable

00:13:06,490 --> 00:13:12,370
one is that IP transport is not really

00:13:09,850 --> 00:13:13,510
real time naturally and the client

00:13:12,370 --> 00:13:15,790
implementations which are there

00:13:13,510 --> 00:13:20,140
currently do not support artists

00:13:15,790 --> 00:13:23,200
mechanisms in a good fashion like for

00:13:20,140 --> 00:13:29,080
example and scheduling and

00:13:23,200 --> 00:13:32,080
prioritization of processes and this is

00:13:29,080 --> 00:13:34,960
our current state of how we see we could

00:13:32,080 --> 00:13:37,150
realize real time capable Ross at least

00:13:34,960 --> 00:13:40,420
within Rossi so you could also look at

00:13:37,150 --> 00:13:43,720
Rossi as being an experiment lab for the

00:13:40,420 --> 00:13:49,020
aspects or some of the aspect that could

00:13:43,720 --> 00:13:53,590
come into Russ 2.0 and we want to add

00:13:49,020 --> 00:13:57,040
besides the TCP UDP Ross transports

00:13:53,590 --> 00:14:00,730
things like zero eros which would be can

00:13:57,040 --> 00:14:03,430
open over ethercat cameras and local

00:14:00,730 --> 00:14:05,800
Ross which means with no network

00:14:03,430 --> 00:14:07,720
communication at all to make two nodes

00:14:05,800 --> 00:14:10,840
on the same machine communicating with

00:14:07,720 --> 00:14:14,980
each other and once you have mastered

00:14:10,840 --> 00:14:17,110
communication taking place over kind of

00:14:14,980 --> 00:14:21,250
a broadcast channel instead of having a

00:14:17,110 --> 00:14:23,410
master and yeah so but why are we

00:14:21,250 --> 00:14:26,770
focusing on those transport layers this

00:14:23,410 --> 00:14:30,060
is because we think transport is one of

00:14:26,770 --> 00:14:32,350
three aspects that russ and needs to

00:14:30,060 --> 00:14:36,300
change what we need to change with Ross

00:14:32,350 --> 00:14:39,910
to make it real time capable and and to

00:14:36,300 --> 00:14:42,660
enable those real-time capable transport

00:14:39,910 --> 00:14:45,460
layers to work properly we also need to

00:14:42,660 --> 00:14:47,500
separate the master communication which

00:14:45,460 --> 00:14:50,440
is mostly not real time it also does not

00:14:47,500 --> 00:14:52,870
need to be real time from the process

00:14:50,440 --> 00:14:54,290
communication handling process message

00:14:52,870 --> 00:14:58,209
handling

00:14:54,290 --> 00:15:02,630
and this is also why we need to

00:14:58,209 --> 00:15:05,720
implement or do implement Rossi and in a

00:15:02,630 --> 00:15:07,790
multithreading manner that's essentially

00:15:05,720 --> 00:15:11,230
it this is a lot of work and this is why

00:15:07,790 --> 00:15:13,730
I invite you all to join the project

00:15:11,230 --> 00:15:19,389
right now it only has one developer he's

00:15:13,730 --> 00:15:23,120
sitting here and what is this and he is

00:15:19,389 --> 00:15:24,769
yeah also willing to answer your

00:15:23,120 --> 00:15:27,110
questions if you have more deeper

00:15:24,769 --> 00:15:29,630
technical questions and I'd like to also

00:15:27,110 --> 00:15:31,610
state an invitation if you're seriously

00:15:29,630 --> 00:15:33,889
interested in the stuff that is

00:15:31,610 --> 00:15:37,790
discussed in Ross industrial and rust

00:15:33,889 --> 00:15:40,670
for products forums we're going to yeah

00:15:37,790 --> 00:15:43,430
give kind of a chill out event at

00:15:40,670 --> 00:15:46,310
Columbus right over the street and and

00:15:43,430 --> 00:15:47,630
yeah that will be free beer so if you

00:15:46,310 --> 00:15:51,350
want to join the discussions and the

00:15:47,630 --> 00:15:53,709
plans for next year come over and of us

00:15:51,350 --> 00:15:53,709

YouTube URL: https://www.youtube.com/watch?v=nCn1ypiDjZ4


