Title: RosCon2013 Track2 Day1 05   Thomas Roehr   ROS and Rock
Publication date: 2014-08-31
Playlist: ROSCon 2013
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2013 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:05,310
yes already introduced thanks my name is

00:00:02,669 --> 00:00:08,760
to Missoula I'm from robotics Innovation

00:00:05,310 --> 00:00:10,410
Center up in bream and yeah if you don't

00:00:08,760 --> 00:00:12,870
know what we do on the right hand side

00:00:10,410 --> 00:00:15,299
here on the slide see already see couple

00:00:12,870 --> 00:00:17,580
of the robots that we have and by the

00:00:15,299 --> 00:00:19,380
way all also running what I will

00:00:17,580 --> 00:00:24,170
introduce shortly which is named rock

00:00:19,380 --> 00:00:29,990
here okay most of you will be familiar

00:00:24,170 --> 00:00:29,990
obviously with developing with Ross so I

00:00:30,170 --> 00:00:37,680
kind of outlined the ideal of Ross

00:00:34,410 --> 00:00:39,390
workflow so you start by having a kind

00:00:37,680 --> 00:00:43,170
of functional decomposition of a problem

00:00:39,390 --> 00:00:45,590
maybe already your Ross nodes in mine so

00:00:43,170 --> 00:00:48,360
you start developing your algorithms and

00:00:45,590 --> 00:00:51,239
then you want to put these algorithms

00:00:48,360 --> 00:00:55,980
into euros notes and solve the problem

00:00:51,239 --> 00:00:58,920
using the Ross infrastructure so

00:00:55,980 --> 00:01:02,190
possibly well you also want to use the

00:00:58,920 --> 00:01:04,430
Ross parameter server and well once

00:01:02,190 --> 00:01:07,409
you're done with designing your network

00:01:04,430 --> 00:01:10,799
you eventually launch it using the Ross

00:01:07,409 --> 00:01:12,750
launch scripts and yeah now you have

00:01:10,799 --> 00:01:15,330
your networks you have your Ross

00:01:12,750 --> 00:01:17,939
infrastructure up and running and then

00:01:15,330 --> 00:01:20,580
you can use the existing tools like raw

00:01:17,939 --> 00:01:24,689
sweetie f RX graph or the more recent

00:01:20,580 --> 00:01:32,640
versions in order to monitor what's

00:01:24,689 --> 00:01:35,189
going on online so once you have worked

00:01:32,640 --> 00:01:37,710
with a couple of systems and gain some

00:01:35,189 --> 00:01:40,100
experience there some questions might

00:01:37,710 --> 00:01:46,770
arise at least for some of you guys and

00:01:40,100 --> 00:01:50,040
so the question for for some of you

00:01:46,770 --> 00:01:52,890
might okay I've now this big brother big

00:01:50,040 --> 00:01:55,860
note network and it got quite complex so

00:01:52,890 --> 00:01:59,009
how do we actually effectively and

00:01:55,860 --> 00:02:01,350
efficiently start to manage this so what

00:01:59,009 --> 00:02:03,240
do I mean by that so you can actually

00:02:01,350 --> 00:02:05,369
validate what's going on in my network

00:02:03,240 --> 00:02:09,409
can I do that also before I actually

00:02:05,369 --> 00:02:09,409
started before it's up and running and

00:02:09,410 --> 00:02:13,700
actually since not for all task I need

00:02:12,390 --> 00:02:16,430
all of the notes

00:02:13,700 --> 00:02:22,129
actually have to have them all running

00:02:16,430 --> 00:02:25,370
at the same time and eventually also can

00:02:22,129 --> 00:02:28,790
I handle that can I handle errors in my

00:02:25,370 --> 00:02:33,290
node Network not just network errors

00:02:28,790 --> 00:02:36,560
like okay there's a difference so if you

00:02:33,290 --> 00:02:39,890
have these kind of questions then this

00:02:36,560 --> 00:02:41,750
talk might be for you so and then an

00:02:39,890 --> 00:02:45,680
answer might also lie in the integration

00:02:41,750 --> 00:02:51,650
of Ross into rock and rock is here the

00:02:45,680 --> 00:02:53,690
robot construction kit so I guess not

00:02:51,650 --> 00:02:57,410
many of you have heard of the robot

00:02:53,690 --> 00:03:00,010
construction kit so what well I try to

00:02:57,410 --> 00:03:02,930
emphasize here is we have a rock

00:03:00,010 --> 00:03:05,060
independent part and meaning framework

00:03:02,930 --> 00:03:09,470
independent part and some framework

00:03:05,060 --> 00:03:12,230
dependent part as well I will focus now

00:03:09,470 --> 00:03:18,519
on the creation of components components

00:03:12,230 --> 00:03:22,850
meaning similar well to Ross nodes and

00:03:18,519 --> 00:03:25,160
so stressing the fact that where we

00:03:22,850 --> 00:03:27,290
started is actually development at a

00:03:25,160 --> 00:03:29,209
framework independent level so we

00:03:27,290 --> 00:03:32,060
develop libraries which a framework

00:03:29,209 --> 00:03:34,600
independent and that is not well there

00:03:32,060 --> 00:03:38,350
is no rock specific that should be like

00:03:34,600 --> 00:03:41,299
commonly done in order to facilitate

00:03:38,350 --> 00:03:44,989
application of the functionality that is

00:03:41,299 --> 00:03:47,480
none developed so in our case language

00:03:44,989 --> 00:03:50,030
of choice is actually C++ we also have

00:03:47,480 --> 00:03:53,600
on the tooling side quite a lot of

00:03:50,030 --> 00:03:56,780
rubies or what is Ross for what is

00:03:53,600 --> 00:04:00,079
Python and Ross mainly is also here Ruby

00:03:56,780 --> 00:04:02,329
but from experience in general you can't

00:04:00,079 --> 00:04:06,790
predict where frameworks will begin so I

00:04:02,329 --> 00:04:09,470
all if one framework will come up and

00:04:06,790 --> 00:04:11,690
dominate the place for examples player

00:04:09,470 --> 00:04:15,410
stage wasn't in recent like all years

00:04:11,690 --> 00:04:17,810
before now we have Ross and so actually

00:04:15,410 --> 00:04:20,239
what we want is to enable our robots

00:04:17,810 --> 00:04:23,870
with what we have at the best that we

00:04:20,239 --> 00:04:26,360
can and sometimes also industry doesn't

00:04:23,870 --> 00:04:27,230
agree with our choice of framework so

00:04:26,360 --> 00:04:33,270
why

00:04:27,230 --> 00:04:35,190
we still can use our libraries so we

00:04:33,270 --> 00:04:37,889
start there with the general component

00:04:35,190 --> 00:04:41,430
development we put our functionality in

00:04:37,889 --> 00:04:44,010
libraries but then we actually continue

00:04:41,430 --> 00:04:46,530
with a model-based workflow meaning that

00:04:44,010 --> 00:04:49,410
we first specify what are the actual

00:04:46,530 --> 00:04:51,450
interfaces of our components and using

00:04:49,410 --> 00:04:55,169
that kind of specification to generate a

00:04:51,450 --> 00:04:57,930
while called skeleton and this skeleton

00:04:55,169 --> 00:05:00,510
is actually based on Oracle's RTT so we

00:04:57,930 --> 00:05:02,820
have least one of the members developers

00:05:00,510 --> 00:05:07,080
here in the audience as well if you have

00:05:02,820 --> 00:05:09,690
specific questions in there and we

00:05:07,080 --> 00:05:13,080
integrate the functionality into into

00:05:09,690 --> 00:05:19,370
the Oracles RTT component skeleton that

00:05:13,080 --> 00:05:21,810
we generated there so simplified

00:05:19,370 --> 00:05:23,550
illustration of the interface you have

00:05:21,810 --> 00:05:25,650
properties to configure your component

00:05:23,550 --> 00:05:27,330
you have input and output ports that is

00:05:25,650 --> 00:05:33,960
a quite significant difference here

00:05:27,330 --> 00:05:36,840
since we have a connection aware system

00:05:33,960 --> 00:05:38,760
that means we have a dedicated

00:05:36,840 --> 00:05:40,110
connection management between our

00:05:38,760 --> 00:05:42,479
components so there's no

00:05:40,110 --> 00:05:46,440
publish-subscribe but there is it like

00:05:42,479 --> 00:05:49,560
we we control where goes what pretty

00:05:46,440 --> 00:05:53,520
much so what you see here is one

00:05:49,560 --> 00:05:55,650
component that is now the infrastructure

00:05:53,520 --> 00:05:57,950
or providing the infrastructure for a

00:05:55,650 --> 00:06:00,900
library that's called a message driver

00:05:57,950 --> 00:06:05,850
this is actually ripped of the tutorials

00:06:00,900 --> 00:06:07,770
from our website as well so

00:06:05,850 --> 00:06:11,250
specification looks like this you have

00:06:07,770 --> 00:06:13,440
the task context which is actually well

00:06:11,250 --> 00:06:16,979
this is your component description in a

00:06:13,440 --> 00:06:18,780
way you have your output ports you have

00:06:16,979 --> 00:06:22,169
your input ports you can specify them

00:06:18,780 --> 00:06:24,210
you have states that you can specify on

00:06:22,169 --> 00:06:29,070
top of the already existing ones which

00:06:24,210 --> 00:06:32,700
are there with the Oracles and then you

00:06:29,070 --> 00:06:34,710
also can define properties so that's the

00:06:32,700 --> 00:06:36,360
first thing that you do when you start

00:06:34,710 --> 00:06:40,169
developing this component and from that

00:06:36,360 --> 00:06:42,590
you generate automatically the C++

00:06:40,169 --> 00:06:42,590
scallops

00:06:42,949 --> 00:06:48,090
so once you have build your component

00:06:45,750 --> 00:06:50,430
and using this kind of infrastructure

00:06:48,090 --> 00:06:52,590
what you get for free is actually first

00:06:50,430 --> 00:06:55,860
of all a quite streamlined and guided

00:06:52,590 --> 00:06:58,430
workflow up to that point since you just

00:06:55,860 --> 00:07:02,400
fill out this kind of skeleton and

00:06:58,430 --> 00:07:04,470
having that you actually get a really

00:07:02,400 --> 00:07:06,360
consistent user experience so what you

00:07:04,470 --> 00:07:10,560
learn once you can continue learning and

00:07:06,360 --> 00:07:13,949
I continued use in the further usage as

00:07:10,560 --> 00:07:16,080
well so with this component model that

00:07:13,949 --> 00:07:18,919
oracle's provides and that doesn't mean

00:07:16,080 --> 00:07:21,599
that we enforce some kind of

00:07:18,919 --> 00:07:24,020
communication middleware since Oracle's

00:07:21,599 --> 00:07:26,520
actually allows to plug in different

00:07:24,020 --> 00:07:30,380
communication Middle West so it default

00:07:26,520 --> 00:07:35,130
is korba but you can also switch to mq

00:07:30,380 --> 00:07:37,470
for local systems and so in the end what

00:07:35,130 --> 00:07:39,509
we have here or try to achieve here is a

00:07:37,470 --> 00:07:42,599
scalable approach for system integration

00:07:39,509 --> 00:07:45,389
what that exactly means I come to in a

00:07:42,599 --> 00:07:48,240
minute so out of the box as well what

00:07:45,389 --> 00:07:50,729
you get is here no blood functionality

00:07:48,240 --> 00:07:52,560
aktionen functionality and dynamic

00:07:50,729 --> 00:07:55,889
configuration functionality so without

00:07:52,560 --> 00:07:57,990
adding anything you have this kind of

00:07:55,889 --> 00:07:59,639
functionality there if you want to get

00:07:57,990 --> 00:08:02,460
your fingers a bit more dirty you can

00:07:59,639 --> 00:08:04,110
also have some kind of well you have

00:08:02,460 --> 00:08:07,250
transformed of functionality and also a

00:08:04,110 --> 00:08:09,870
thing called stream alignment which is

00:08:07,250 --> 00:08:15,169
at least at the moment so quite unique

00:08:09,870 --> 00:08:17,400
here so regarding system integration

00:08:15,169 --> 00:08:21,120
meaning now we want to build complex

00:08:17,400 --> 00:08:25,110
systems complex systems that allows to

00:08:21,120 --> 00:08:30,000
control our robots and we can start with

00:08:25,110 --> 00:08:33,959
is actually a small Ruby scripts so that

00:08:30,000 --> 00:08:38,339
is a interface which allows you to set

00:08:33,959 --> 00:08:40,890
up small testing well testing test

00:08:38,339 --> 00:08:43,349
setups and the shrew be interface gives

00:08:40,890 --> 00:08:45,270
you access to the processes and while

00:08:43,349 --> 00:08:47,640
components and also gives you access to

00:08:45,270 --> 00:08:49,950
now and here's the integration part two

00:08:47,640 --> 00:08:52,350
rows notes so at the same level that we

00:08:49,950 --> 00:08:55,820
are using Oracle's components we are

00:08:52,350 --> 00:09:00,810
integrating the Ross

00:08:55,820 --> 00:09:03,899
so Ruby script looks like this so for

00:09:00,810 --> 00:09:06,660
those not familiar with Ruby well

00:09:03,899 --> 00:09:09,690
actually it's also a domain-specific

00:09:06,660 --> 00:09:12,660
language that we define here using Ruby

00:09:09,690 --> 00:09:14,490
but so require our cause is just loading

00:09:12,660 --> 00:09:16,200
our functionality and then Oracle's

00:09:14,490 --> 00:09:18,480
initialize initializes also the

00:09:16,200 --> 00:09:21,480
communication layer underneath including

00:09:18,480 --> 00:09:24,209
Cobra we run so called deployments

00:09:21,480 --> 00:09:27,750
deployments were actually the build

00:09:24,209 --> 00:09:29,520
components in this case we have the task

00:09:27,750 --> 00:09:33,290
context which is called message called

00:09:29,520 --> 00:09:37,260
message consumer task which is

00:09:33,290 --> 00:09:39,450
identified man as message consumer on

00:09:37,260 --> 00:09:41,370
the network same with the message

00:09:39,450 --> 00:09:44,070
producer task which will be identified

00:09:41,370 --> 00:09:46,350
as message producer on the network so

00:09:44,070 --> 00:09:49,529
using the inbuilt name service you can

00:09:46,350 --> 00:09:51,330
then access these tasks and then perform

00:09:49,529 --> 00:09:54,200
operations on them like configure in

00:09:51,330 --> 00:09:57,720
order to apply the configuration starter

00:09:54,200 --> 00:10:00,600
and well you can also do a so-called

00:09:57,720 --> 00:10:02,100
well clean up when stopped on these

00:10:00,600 --> 00:10:04,709
components so you have a dedicated

00:10:02,100 --> 00:10:09,630
interface for these kind of components

00:10:04,709 --> 00:10:11,459
to manage them your component network so

00:10:09,630 --> 00:10:14,070
the Ross integration just to show what

00:10:11,459 --> 00:10:15,779
it might look like is here from also

00:10:14,070 --> 00:10:19,800
called task inspector which allows to

00:10:15,779 --> 00:10:23,760
show all running notes on a system so

00:10:19,800 --> 00:10:26,400
there is the well Ross master that has

00:10:23,760 --> 00:10:28,190
to been started Plus in this case we

00:10:26,400 --> 00:10:31,770
have a Priscilla code like the typical

00:10:28,190 --> 00:10:34,650
Priscilla car drivers tutorial if you

00:10:31,770 --> 00:10:38,910
follow that you get a running Priscilla

00:10:34,650 --> 00:10:42,150
car driver and your camera provides an

00:10:38,910 --> 00:10:44,220
image and what you need to do though is

00:10:42,150 --> 00:10:49,260
to implement the type conversion between

00:10:44,220 --> 00:10:51,690
the image format or image data type that

00:10:49,260 --> 00:10:54,240
Ross provides and the one that rocky

00:10:51,690 --> 00:10:58,410
uses actually internally so what you see

00:10:54,240 --> 00:11:00,720
here for example in the just under

00:10:58,410 --> 00:11:05,839
output ports the type name would be

00:11:00,720 --> 00:11:05,839
based samples frame frame this case

00:11:08,390 --> 00:11:15,090
so this is basically just looking at

00:11:12,300 --> 00:11:18,650
singer components but handling the real

00:11:15,090 --> 00:11:22,680
complex problems is well usually

00:11:18,650 --> 00:11:25,980
tackling robots and then usually the

00:11:22,680 --> 00:11:29,760
problems get more complex as we think in

00:11:25,980 --> 00:11:32,820
the first place so what we try to do is

00:11:29,760 --> 00:11:35,100
starting out simple and trying to reuse

00:11:32,820 --> 00:11:39,360
what we have already so that means we

00:11:35,100 --> 00:11:43,830
can try to design part of the overall

00:11:39,360 --> 00:11:47,640
network and try to use it and also try

00:11:43,830 --> 00:11:57,510
to employ error monitoring and arrow

00:11:47,640 --> 00:11:59,880
recovery in that case so I will just

00:11:57,510 --> 00:12:02,130
show you a video which tries to

00:11:59,880 --> 00:12:06,300
illustrate bit of the functionality that

00:12:02,130 --> 00:12:10,280
you that we have through a tool that is

00:12:06,300 --> 00:12:13,200
called the supervision Ruby solid a is a

00:12:10,280 --> 00:12:15,870
ruby the language and roby the

00:12:13,200 --> 00:12:23,250
supervision plan management tool which

00:12:15,870 --> 00:12:25,880
this is the core of and so so what you

00:12:23,250 --> 00:12:29,670
start out is you design subsystems

00:12:25,880 --> 00:12:32,490
separately that means in this case for

00:12:29,670 --> 00:12:36,060
example you try to put on this a bit too

00:12:32,490 --> 00:12:37,860
fast and we stop it you put your

00:12:36,060 --> 00:12:40,500
individual subsystems together using

00:12:37,860 --> 00:12:43,980
your task your components that you have

00:12:40,500 --> 00:12:48,840
to sign before hand so you do this for

00:12:43,980 --> 00:12:51,090
each of the subsystems and you kind of

00:12:48,840 --> 00:12:53,790
first can put them on the side once you

00:12:51,090 --> 00:12:55,530
have them tested properly and then you

00:12:53,790 --> 00:12:57,660
start combining them actually into more

00:12:55,530 --> 00:12:59,100
complex networks and in the first place

00:12:57,660 --> 00:13:01,320
you don't even need to bother whether

00:12:59,100 --> 00:13:04,950
they share any components and stuff like

00:13:01,320 --> 00:13:07,080
that you just model them individually so

00:13:04,950 --> 00:13:12,050
what eventually will happen if you try

00:13:07,080 --> 00:13:15,570
to deploy all these networks together is

00:13:12,050 --> 00:13:17,520
that the supervision automatically

00:13:15,570 --> 00:13:18,700
identifies okay which components are

00:13:17,520 --> 00:13:22,840
actually shared and

00:13:18,700 --> 00:13:24,700
so eliminates like that two components

00:13:22,840 --> 00:13:27,010
would need to be started so it just

00:13:24,700 --> 00:13:32,110
merges the network of components there

00:13:27,010 --> 00:13:35,110
and gives the compact view kind of so

00:13:32,110 --> 00:13:37,840
that also means of course if they share

00:13:35,110 --> 00:13:42,280
components there might arise conflicts

00:13:37,840 --> 00:13:45,160
at runtime if you if there are errors in

00:13:42,280 --> 00:13:47,980
in one of the dedicated components but

00:13:45,160 --> 00:13:50,860
these errors can also be handled meaning

00:13:47,980 --> 00:13:56,620
that each of these okay this is just

00:13:50,860 --> 00:14:00,610
starting again meaning that we can take

00:13:56,620 --> 00:14:03,700
action which is based the supervision is

00:14:00,610 --> 00:14:06,610
based on an event based system and we

00:14:03,700 --> 00:14:09,220
handle individual events in that case

00:14:06,610 --> 00:14:16,300
and we do an error recovery based on the

00:14:09,220 --> 00:14:20,040
information we get there so you have now

00:14:16,300 --> 00:14:23,890
the power to actually do multiple things

00:14:20,040 --> 00:14:27,010
first of all you can do offline system

00:14:23,890 --> 00:14:31,120
design since we use this model based

00:14:27,010 --> 00:14:32,950
approach what you what you generate in

00:14:31,120 --> 00:14:35,320
the first place is a validation of your

00:14:32,950 --> 00:14:37,570
network that's what we call the network

00:14:35,320 --> 00:14:39,220
instantiation which you can do before

00:14:37,570 --> 00:14:43,150
you actually deploy the network at

00:14:39,220 --> 00:14:45,670
runtime then you can also use it to

00:14:43,150 --> 00:14:49,120
distribute your system so if you run one

00:14:45,670 --> 00:14:51,250
say controller of this supervision at

00:14:49,120 --> 00:14:53,700
one system and you have other attached

00:14:51,250 --> 00:14:55,810
systems this can be transparent

00:14:53,700 --> 00:14:57,700
transparently managed through the

00:14:55,810 --> 00:15:02,410
supervision layer so you can have your

00:14:57,700 --> 00:15:05,080
components distributed and for the

00:15:02,410 --> 00:15:07,390
networks what it allows is you don't

00:15:05,080 --> 00:15:09,990
need to have all your components running

00:15:07,390 --> 00:15:11,890
at the same time so if you have certain

00:15:09,990 --> 00:15:14,920
functionality that you need at is

00:15:11,890 --> 00:15:16,960
specific point in time you say I require

00:15:14,920 --> 00:15:20,320
now this kind of network that provides

00:15:16,960 --> 00:15:22,690
the functionality then this supervision

00:15:20,320 --> 00:15:25,930
takes care of actually performing the

00:15:22,690 --> 00:15:27,850
switch like checks whether certain

00:15:25,930 --> 00:15:29,089
components won't need to be restarted

00:15:27,850 --> 00:15:31,639
would to be

00:15:29,089 --> 00:15:35,110
reconfigured and eventually this allows

00:15:31,639 --> 00:15:40,279
really for the user easy management of

00:15:35,110 --> 00:15:42,319
complex tasks and on top of that I mean

00:15:40,279 --> 00:15:43,970
we have offline system design but we

00:15:42,319 --> 00:15:47,449
also have extensive logging and

00:15:43,970 --> 00:15:49,550
displaying facility at runtime and since

00:15:47,449 --> 00:15:51,379
there is a lot of happening in a system

00:15:49,550 --> 00:15:53,449
likely especially if you look at

00:15:51,379 --> 00:15:56,420
individual events which come low level

00:15:53,449 --> 00:16:00,290
from low-level devices up to higher

00:15:56,420 --> 00:16:02,120
level components it will be hard to

00:16:00,290 --> 00:16:04,579
manage if you don't have these kind of

00:16:02,120 --> 00:16:08,019
logging facilities so it allows you to

00:16:04,579 --> 00:16:14,290
have a really proper monitoring as well

00:16:08,019 --> 00:16:14,290
monitoring as in user view at the moment

00:16:14,740 --> 00:16:22,069
so summarizing we don't want to reinvent

00:16:18,800 --> 00:16:24,499
the wheel here we try to use as much as

00:16:22,069 --> 00:16:27,860
we can what's out there so that's why we

00:16:24,499 --> 00:16:30,050
also sit on top of Oracle's RTT as a

00:16:27,860 --> 00:16:33,050
component model which has been already

00:16:30,050 --> 00:16:36,529
proven in industry and it's also

00:16:33,050 --> 00:16:40,129
actually used in a different way de and

00:16:36,529 --> 00:16:41,990
Ross here so what I try to show here is

00:16:40,129 --> 00:16:45,470
actually a scalable approach to system

00:16:41,990 --> 00:16:47,420
integration and so you can start out

00:16:45,470 --> 00:16:51,439
quite simply with the the Ruby based

00:16:47,420 --> 00:16:54,079
interfacing or or Ruby scripts or you

00:16:51,439 --> 00:16:58,670
can then start go on with the complex

00:16:54,079 --> 00:17:02,240
system modeling capabilities so we

00:16:58,670 --> 00:17:05,860
actually provide this this functionality

00:17:02,240 --> 00:17:08,240
or we use this functionality in our

00:17:05,860 --> 00:17:10,279
Institute on different robots the one

00:17:08,240 --> 00:17:13,669
that you have seen already on the title

00:17:10,279 --> 00:17:16,250
page and if you're interested just check

00:17:13,669 --> 00:17:19,100
it out on our website and if you have

00:17:16,250 --> 00:17:22,899
questions or concerns or some remarks I

00:17:19,100 --> 00:17:26,270
just send an email I mean this is like

00:17:22,899 --> 00:17:28,370
yeah well we have our developers mailing

00:17:26,270 --> 00:17:31,820
list you can just hook in there and just

00:17:28,370 --> 00:17:35,320
yeah contact us so really what we good

00:17:31,820 --> 00:17:40,510
if we can have some interaction there

00:17:35,320 --> 00:17:40,510

YouTube URL: https://www.youtube.com/watch?v=Y66KlDBYGDQ


