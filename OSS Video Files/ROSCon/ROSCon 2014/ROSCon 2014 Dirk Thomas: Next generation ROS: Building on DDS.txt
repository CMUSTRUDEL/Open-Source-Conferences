Title: ROSCon 2014 Dirk Thomas: Next generation ROS: Building on DDS
Publication date: 2015-10-19
Playlist: ROSCon 2014
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2014 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,799 --> 00:00:05,120
all right so i'll talk a little bit

00:00:03,280 --> 00:00:06,000
about uh what we currently work on at

00:00:05,120 --> 00:00:09,040
the osrf

00:00:06,000 --> 00:00:10,000
uh in terms of ros 2 or 2.0 you heard

00:00:09,040 --> 00:00:12,160
before

00:00:10,000 --> 00:00:13,840
we had a talk last year this time i want

00:00:12,160 --> 00:00:15,200
to get a little bit more into details

00:00:13,840 --> 00:00:17,920
what we actually have

00:00:15,200 --> 00:00:18,800
done since then and it's mostly focused

00:00:17,920 --> 00:00:21,920
on

00:00:18,800 --> 00:00:23,840
the work we've been doing using dds the

00:00:21,920 --> 00:00:26,160
data distribution

00:00:23,840 --> 00:00:27,519
service which is like an omg standard

00:00:26,160 --> 00:00:29,439
it's a work from all the

00:00:27,519 --> 00:00:30,800
people in the ros team i'm just

00:00:29,439 --> 00:00:34,320
presenting that for

00:00:30,800 --> 00:00:35,200
for all of us today so what is ross you

00:00:34,320 --> 00:00:37,040
already know that

00:00:35,200 --> 00:00:38,719
elsie wouldn't be here it consists of

00:00:37,040 --> 00:00:40,960
the plumbing part like doing

00:00:38,719 --> 00:00:42,640
some communication on the lower level

00:00:40,960 --> 00:00:44,879
but most of the benefit comes from the

00:00:42,640 --> 00:00:46,399
tools the capabilities and of course the

00:00:44,879 --> 00:00:50,239
ecosystem because you can just

00:00:46,399 --> 00:00:50,239
leverage what's already out there

00:00:50,399 --> 00:00:54,480
where are we now we do have like a

00:00:52,320 --> 00:00:56,879
system which is pretty mature after like

00:00:54,480 --> 00:00:58,399
nearly seven years it's robust we have a

00:00:56,879 --> 00:01:01,600
very big community

00:00:58,399 --> 00:01:02,399
and it works well with a variety of

00:01:01,600 --> 00:01:05,280
hardware

00:01:02,399 --> 00:01:06,880
different software and it's very easy to

00:01:05,280 --> 00:01:08,880
contribute to the system and build your

00:01:06,880 --> 00:01:12,000
own thing use as much as you want and

00:01:08,880 --> 00:01:12,000
build the rest for yourself

00:01:14,159 --> 00:01:18,400
we've seen tons of robots using that we

00:01:17,040 --> 00:01:21,040
can inter-operate with

00:01:18,400 --> 00:01:22,400
other software packages we use a lot of

00:01:21,040 --> 00:01:25,119
libraries which provide you a certain

00:01:22,400 --> 00:01:25,119
functionality

00:01:25,520 --> 00:01:29,439
this is just a selection of robots and

00:01:27,759 --> 00:01:31,439
and companies using that

00:01:29,439 --> 00:01:32,720
not not everything is directly related

00:01:31,439 --> 00:01:34,640
to robotics but

00:01:32,720 --> 00:01:36,159
um a lot of people use the software for

00:01:34,640 --> 00:01:38,240
their application

00:01:36,159 --> 00:01:39,759
um so the question is how did we get

00:01:38,240 --> 00:01:42,240
there

00:01:39,759 --> 00:01:43,840
the main point for us is i would think

00:01:42,240 --> 00:01:46,000
the ease of use that you can

00:01:43,840 --> 00:01:48,320
get into it pretty easy and then you can

00:01:46,000 --> 00:01:49,680
use it very flexible for your scenario

00:01:48,320 --> 00:01:52,240
if you're not interested in certain

00:01:49,680 --> 00:01:54,560
parts you just don't use them

00:01:52,240 --> 00:01:55,520
it's pretty scalable even if there are

00:01:54,560 --> 00:01:57,840
concerns if it

00:01:55,520 --> 00:01:59,520
goes to swarm or multi-robot scenarios

00:01:57,840 --> 00:02:01,840
but it's uh very useful

00:01:59,520 --> 00:02:03,840
uh uh use scalable in terms of if you

00:02:01,840 --> 00:02:05,759
have a complex robot for example like

00:02:03,840 --> 00:02:08,800
the pr2

00:02:05,759 --> 00:02:10,560
and i think one of the main benefits of

00:02:08,800 --> 00:02:11,760
ross is that it really enables reuse

00:02:10,560 --> 00:02:13,840
which before

00:02:11,760 --> 00:02:15,280
time ross was available was not really

00:02:13,840 --> 00:02:17,520
common in robotics

00:02:15,280 --> 00:02:19,760
and everybody needed to redevelop all

00:02:17,520 --> 00:02:22,879
the parts himself to just write a paper

00:02:19,760 --> 00:02:24,560
about a certain aspect

00:02:22,879 --> 00:02:26,080
so the question for us what do we do

00:02:24,560 --> 00:02:28,080
with that at osref

00:02:26,080 --> 00:02:30,000
i mean we have a certain amount of

00:02:28,080 --> 00:02:32,080
resources where people can spend

00:02:30,000 --> 00:02:33,840
their time on ros development and we

00:02:32,080 --> 00:02:35,200
could just maintain what we have we can

00:02:33,840 --> 00:02:37,920
do little improvements

00:02:35,200 --> 00:02:39,840
and we can we can try to make everything

00:02:37,920 --> 00:02:40,879
compatible when we do changes in the

00:02:39,840 --> 00:02:43,680
future

00:02:40,879 --> 00:02:45,840
but on the other hand we start that it's

00:02:43,680 --> 00:02:47,120
more useful with our time if we drive

00:02:45,840 --> 00:02:49,040
new development

00:02:47,120 --> 00:02:51,920
because we have the resources to spend

00:02:49,040 --> 00:02:54,480
significant development time on that

00:02:51,920 --> 00:02:56,080
and actually address limitations of the

00:02:54,480 --> 00:02:57,840
current system which

00:02:56,080 --> 00:02:59,519
might not be easily fixable in the

00:02:57,840 --> 00:03:01,120
current implementation

00:02:59,519 --> 00:03:03,200
and we want to make the system fit for

00:03:01,120 --> 00:03:04,720
like future use cases

00:03:03,200 --> 00:03:07,040
which we'll probably see a couple in the

00:03:04,720 --> 00:03:08,959
next slide because there are

00:03:07,040 --> 00:03:12,239
use cases which the current system does

00:03:08,959 --> 00:03:12,239
not address very well

00:03:12,400 --> 00:03:18,879
ryan isolev no thanks

00:03:16,480 --> 00:03:20,400
so for example i mentioned multi-robot

00:03:18,879 --> 00:03:21,200
systems before that's one of the use

00:03:20,400 --> 00:03:23,120
cases where

00:03:21,200 --> 00:03:24,480
ross is not very good because of his

00:03:23,120 --> 00:03:26,239
single master approach

00:03:24,480 --> 00:03:27,920
and you have to like let different

00:03:26,239 --> 00:03:28,879
master systems communicate with each

00:03:27,920 --> 00:03:32,560
other

00:03:28,879 --> 00:03:35,040
so that's something where we do not

00:03:32,560 --> 00:03:35,599
support the developer very well the

00:03:35,040 --> 00:03:37,840
second

00:03:35,599 --> 00:03:40,560
part also for multi-robot is if we have

00:03:37,840 --> 00:03:43,280
unreliable communication for example

00:03:40,560 --> 00:03:44,560
you have a remote desktop monitoring

00:03:43,280 --> 00:03:46,879
your robot which drives around the

00:03:44,560 --> 00:03:48,159
building and it drops out of wireless

00:03:46,879 --> 00:03:50,640
well you might be lucky and it

00:03:48,159 --> 00:03:52,319
reconnects but you might also not

00:03:50,640 --> 00:03:55,360
so this is another case where we are

00:03:52,319 --> 00:03:59,120
currently not providing enough

00:03:55,360 --> 00:04:01,760
functionality to the users another very

00:03:59,120 --> 00:04:02,239
often mentioned problem with ross is

00:04:01,760 --> 00:04:04,799
that

00:04:02,239 --> 00:04:05,360
people who use it for robots to really

00:04:04,799 --> 00:04:07,360
develop

00:04:05,360 --> 00:04:09,120
something a robotic system and sell it

00:04:07,360 --> 00:04:11,040
as a product afterwards

00:04:09,120 --> 00:04:12,959
they use ross for prototyping because it

00:04:11,040 --> 00:04:15,519
allows them to like fastly

00:04:12,959 --> 00:04:16,880
set up a system and prove that their

00:04:15,519 --> 00:04:18,239
approach works

00:04:16,880 --> 00:04:20,079
and as soon as they go to the real

00:04:18,239 --> 00:04:22,240
product they basically throw out ross

00:04:20,079 --> 00:04:23,600
and re-implement everything from scratch

00:04:22,240 --> 00:04:25,360
because they are not

00:04:23,600 --> 00:04:27,919
relying on all these open source

00:04:25,360 --> 00:04:29,040
packages and our custom transport

00:04:27,919 --> 00:04:31,199
because they

00:04:29,040 --> 00:04:34,960
put they base their product on like

00:04:31,199 --> 00:04:34,960
different technology proven technology

00:04:36,000 --> 00:04:39,680
another scenario just as an example is

00:04:38,720 --> 00:04:42,960
if you think about

00:04:39,680 --> 00:04:45,280
small small controllers microcontrollers

00:04:42,960 --> 00:04:46,560
embedded is always difficult to quantify

00:04:45,280 --> 00:04:47,440
everybody has a different understanding

00:04:46,560 --> 00:04:48,479
of embedded

00:04:47,440 --> 00:04:50,479
but you might have even have a

00:04:48,479 --> 00:04:52,479
microcontroller without an operating

00:04:50,479 --> 00:04:54,479
system like really bare metal

00:04:52,479 --> 00:04:56,000
then everybody writes his own code he

00:04:54,479 --> 00:04:59,520
talks somehow to a

00:04:56,000 --> 00:05:01,280
computer raw serial you often um

00:04:59,520 --> 00:05:02,880
but it would be nice if your sensor like

00:05:01,280 --> 00:05:05,440
your camera or your

00:05:02,880 --> 00:05:06,000
your your motor would just talk native

00:05:05,440 --> 00:05:07,440
ros

00:05:06,000 --> 00:05:10,720
and you would not have to deal with like

00:05:07,440 --> 00:05:14,000
an indirection between that one

00:05:10,720 --> 00:05:16,639
and we heard uh about the

00:05:14,000 --> 00:05:17,680
need of uh real time for the control

00:05:16,639 --> 00:05:20,160
loop before

00:05:17,680 --> 00:05:22,160
that's also something which ross allows

00:05:20,160 --> 00:05:23,759
you to work with like for example oracos

00:05:22,160 --> 00:05:25,199
but it doesn't provide you with a lot of

00:05:23,759 --> 00:05:28,800
integration between

00:05:25,199 --> 00:05:28,800
an oracle system for example

00:05:29,520 --> 00:05:33,039
when we looked at exploring and

00:05:32,080 --> 00:05:37,039
prototyping

00:05:33,039 --> 00:05:39,680
how we want to how we imagine ras2

00:05:37,039 --> 00:05:40,320
to look in the future you probably

00:05:39,680 --> 00:05:42,080
remember

00:05:40,320 --> 00:05:44,880
when you were at roscon last year our

00:05:42,080 --> 00:05:49,120
talk where we looked into

00:05:44,880 --> 00:05:51,520
into how we can base ros 2 in the future

00:05:49,120 --> 00:05:53,199
which we gave there so when ross was

00:05:51,520 --> 00:05:54,160
developed originally like seven years

00:05:53,199 --> 00:05:56,400
ago there were

00:05:54,160 --> 00:05:58,800
not that many libraries around to pick

00:05:56,400 --> 00:06:01,360
for transport serialization

00:05:58,800 --> 00:06:03,039
uh distributed discovery etc but the

00:06:01,360 --> 00:06:04,479
times luckily have changed i mean you

00:06:03,039 --> 00:06:06,800
know how fast software

00:06:04,479 --> 00:06:09,199
development goes so nowadays we have a

00:06:06,800 --> 00:06:10,720
lot of libraries available like zero mq

00:06:09,199 --> 00:06:12,960
for transport

00:06:10,720 --> 00:06:14,880
protobuf just as an example for proven

00:06:12,960 --> 00:06:16,720
serialization libraries

00:06:14,880 --> 00:06:19,919
and we thought well that's a good idea

00:06:16,720 --> 00:06:21,919
let's just pick some of those

00:06:19,919 --> 00:06:23,039
take protocol for civilization zero mq

00:06:21,919 --> 00:06:26,720
for transport

00:06:23,039 --> 00:06:28,720
and zero conf

00:06:26,720 --> 00:06:30,240
system for discovery and we just put

00:06:28,720 --> 00:06:31,600
them together and we'll just replace

00:06:30,240 --> 00:06:33,440
what we have

00:06:31,600 --> 00:06:35,759
but actually even if we use those

00:06:33,440 --> 00:06:36,720
libraries we build prototypes it takes a

00:06:35,759 --> 00:06:40,240
huge effort

00:06:36,720 --> 00:06:42,000
to make a really good combined system

00:06:40,240 --> 00:06:44,720
out of those

00:06:42,000 --> 00:06:46,880
so we kept looking after the first

00:06:44,720 --> 00:06:49,919
prototypes we did in the last year

00:06:46,880 --> 00:06:50,880
and one thing which stood out of what's

00:06:49,919 --> 00:06:53,919
actually available

00:06:50,880 --> 00:06:56,319
is the data distribution service dds

00:06:53,919 --> 00:06:58,880
which is an omg standard yet don't be

00:06:56,319 --> 00:07:03,759
scared i mean omg also did corba but

00:06:58,880 --> 00:07:06,960
this one was actually pretty solid and

00:07:03,759 --> 00:07:08,400
so the omg standard defines in dds like

00:07:06,960 --> 00:07:10,800
basically three

00:07:08,400 --> 00:07:12,479
major features that's discovery which is

00:07:10,800 --> 00:07:13,919
a distributed discovery approach so

00:07:12,479 --> 00:07:15,360
there's no central master

00:07:13,919 --> 00:07:17,360
it does that in a distributed

00:07:15,360 --> 00:07:20,560
peer-to-peer fashion

00:07:17,360 --> 00:07:22,080
it defines serialization and it provides

00:07:20,560 --> 00:07:24,080
transport

00:07:22,080 --> 00:07:25,520
these are basically the three major

00:07:24,080 --> 00:07:28,560
functionalities of the

00:07:25,520 --> 00:07:30,160
coreos libraries and

00:07:28,560 --> 00:07:32,000
it's not only like a standard it's

00:07:30,160 --> 00:07:32,960
pretty old actually it's almost like a

00:07:32,000 --> 00:07:35,120
decade old

00:07:32,960 --> 00:07:36,639
but it's not like a fixed standard which

00:07:35,120 --> 00:07:37,840
doesn't evolve but it's very actively

00:07:36,639 --> 00:07:40,400
being worked on by

00:07:37,840 --> 00:07:42,800
a lot of people in the community so it's

00:07:40,400 --> 00:07:45,440
evolving over time for example there are

00:07:42,800 --> 00:07:47,199
new specs available for c plus 11

00:07:45,440 --> 00:07:50,240
specific api

00:07:47,199 --> 00:07:52,080
and um and furthermore so it's really

00:07:50,240 --> 00:07:54,720
evolving so it's not something which is

00:07:52,080 --> 00:07:54,720
already dead

00:07:54,800 --> 00:07:58,000
another very big advantage of dds is

00:07:56,639 --> 00:07:59,360
that it provides a level of

00:07:58,000 --> 00:08:02,560
configurability

00:07:59,360 --> 00:08:04,800
which is far superior than what ros1

00:08:02,560 --> 00:08:06,720
provides you currently so you can define

00:08:04,800 --> 00:08:08,240
certain levels of quality of service

00:08:06,720 --> 00:08:10,240
attributes

00:08:08,240 --> 00:08:11,599
to define the trade-off if you want to

00:08:10,240 --> 00:08:13,120
have a fast discovery

00:08:11,599 --> 00:08:15,520
with a trade-off that you send more

00:08:13,120 --> 00:08:17,759
packages or you do a slower discovery

00:08:15,520 --> 00:08:18,800
with the advantage of using less network

00:08:17,759 --> 00:08:21,759
bandwidth

00:08:18,800 --> 00:08:22,960
so that's very customizable for the user

00:08:21,759 --> 00:08:26,240
then to pick his

00:08:22,960 --> 00:08:28,639
settings it also allows

00:08:26,240 --> 00:08:30,000
from the wire protocol itself that you

00:08:28,639 --> 00:08:31,919
can do real-time

00:08:30,000 --> 00:08:33,200
capable communication so you can write a

00:08:31,919 --> 00:08:36,159
dds client

00:08:33,200 --> 00:08:38,880
and a dds server side which will talk

00:08:36,159 --> 00:08:41,039
over the network which still

00:08:38,880 --> 00:08:44,080
keeps real-time constraints depending on

00:08:41,039 --> 00:08:45,760
if that's relevant for your application

00:08:44,080 --> 00:08:47,680
so the standard itself doesn't give us

00:08:45,760 --> 00:08:49,519
anything yet so we require people to

00:08:47,680 --> 00:08:51,920
actually implement that standard

00:08:49,519 --> 00:08:54,480
and there are currently roughly like 12

00:08:51,920 --> 00:08:56,640
implementations we are aware of

00:08:54,480 --> 00:08:58,640
and those are ones which are partially

00:08:56,640 --> 00:09:00,800
commercial and there are also ones which

00:08:58,640 --> 00:09:03,360
are just open source bsd licensed or

00:09:00,800 --> 00:09:05,839
lgbl licensed

00:09:03,360 --> 00:09:08,640
and some of those implementations are i

00:09:05,839 --> 00:09:11,360
would say far superior when it comes to

00:09:08,640 --> 00:09:12,640
reliability and robustness than what we

00:09:11,360 --> 00:09:14,080
have with ros1

00:09:12,640 --> 00:09:15,839
because they're used in like mission

00:09:14,080 --> 00:09:17,600
critical applications they're used on

00:09:15,839 --> 00:09:20,880
like airplanes they're used like

00:09:17,600 --> 00:09:23,839
in big systems like an electric

00:09:20,880 --> 00:09:25,839
grid for example some of them are even

00:09:23,839 --> 00:09:27,279
dod flight certified

00:09:25,839 --> 00:09:28,720
but usually you have to pay for them the

00:09:27,279 --> 00:09:30,560
open source version will not give that

00:09:28,720 --> 00:09:32,080
to you

00:09:30,560 --> 00:09:33,839
there are also vendors which implement

00:09:32,080 --> 00:09:36,800
very small solutions which can run

00:09:33,839 --> 00:09:39,200
really on an embedded system

00:09:36,800 --> 00:09:40,560
so there's a wide variety of vendors

00:09:39,200 --> 00:09:42,959
which implement the standard

00:09:40,560 --> 00:09:45,040
and different implementations we can we

00:09:42,959 --> 00:09:48,240
can choose from

00:09:45,040 --> 00:09:51,680
um therefore therefore we looked into

00:09:48,240 --> 00:09:52,560
building the ros api you use from the

00:09:51,680 --> 00:09:55,839
client

00:09:52,560 --> 00:09:56,560
library level on top of dds so we try to

00:09:55,839 --> 00:09:59,120
get

00:09:56,560 --> 00:10:01,519
the advantages of dds with like robust

00:09:59,120 --> 00:10:04,959
implementation reliable implementation

00:10:01,519 --> 00:10:07,440
proven really like large-scale systems

00:10:04,959 --> 00:10:08,720
with the ease and ease of use and

00:10:07,440 --> 00:10:11,120
usability you are

00:10:08,720 --> 00:10:12,880
used to from the ros api this is all on

00:10:11,120 --> 00:10:14,800
the level of plumbing

00:10:12,880 --> 00:10:16,000
from the first slide and the big

00:10:14,800 --> 00:10:17,839
advantage will be

00:10:16,000 --> 00:10:19,760
not only that we can leverage all the

00:10:17,839 --> 00:10:22,000
functionalities from dds but

00:10:19,760 --> 00:10:23,120
since our time is limited if our team

00:10:22,000 --> 00:10:24,800
spends less time

00:10:23,120 --> 00:10:27,200
re-implementing another serialization

00:10:24,800 --> 00:10:29,279
library or implementing a new transport

00:10:27,200 --> 00:10:31,279
or gluing together other libraries

00:10:29,279 --> 00:10:33,279
we have more time in the future to spend

00:10:31,279 --> 00:10:36,480
on higher level functionality and that's

00:10:33,279 --> 00:10:39,120
where we will all benefit from

00:10:36,480 --> 00:10:40,240
so the question now uh which was also

00:10:39,120 --> 00:10:43,519
discussed on one of the main

00:10:40,240 --> 00:10:45,600
lists during the spring is well which

00:10:43,519 --> 00:10:47,360
dds implementation do we choose now i

00:10:45,600 --> 00:10:49,680
mean there are 12 implementations just

00:10:47,360 --> 00:10:51,360
let's agree on one well not that easy

00:10:49,680 --> 00:10:53,760
because every implementation might have

00:10:51,360 --> 00:10:55,600
like pros and cons for certain scenarios

00:10:53,760 --> 00:10:57,120
depending on if you have a license as a

00:10:55,600 --> 00:10:58,560
big contractor

00:10:57,120 --> 00:11:00,399
you might be totally fine taking a

00:10:58,560 --> 00:11:01,760
commercial license but

00:11:00,399 --> 00:11:04,640
the majority of the community will

00:11:01,760 --> 00:11:08,000
probably prefer an open license

00:11:04,640 --> 00:11:10,800
so we did a lot of effort in the

00:11:08,000 --> 00:11:13,120
in the last several months to actually

00:11:10,800 --> 00:11:16,000
make this a decision which you can like

00:11:13,120 --> 00:11:17,519
decide at length time so if you are fine

00:11:16,000 --> 00:11:18,959
using a commercial license just link

00:11:17,519 --> 00:11:20,560
that version and if you want to have the

00:11:18,959 --> 00:11:22,800
open source version of

00:11:20,560 --> 00:11:24,480
an implementation you just pick that one

00:11:22,800 --> 00:11:27,040
so we wanted to have the flexibility

00:11:24,480 --> 00:11:28,880
also when it comes to packaging that

00:11:27,040 --> 00:11:30,880
into debian packages

00:11:28,880 --> 00:11:32,399
so there's no final decision yet what

00:11:30,880 --> 00:11:34,079
will be the default

00:11:32,399 --> 00:11:36,320
and this will probably take another

00:11:34,079 --> 00:11:38,480
couple of months until we

00:11:36,320 --> 00:11:39,440
revive that discussion and when we have

00:11:38,480 --> 00:11:42,320
enough

00:11:39,440 --> 00:11:44,160
information about what's actually valid

00:11:42,320 --> 00:11:44,880
um and what the pros and cons are to

00:11:44,160 --> 00:11:47,279
actually

00:11:44,880 --> 00:11:49,680
have a good uh get good information

00:11:47,279 --> 00:11:52,720
based for the decision

00:11:49,680 --> 00:11:54,880
so how did we achieve to be able to uh

00:11:52,720 --> 00:11:56,000
let you choose between different dds

00:11:54,880 --> 00:11:58,639
implementations

00:11:56,000 --> 00:11:59,680
so our current prototype has the

00:11:58,639 --> 00:12:01,600
userland code

00:11:59,680 --> 00:12:04,720
you usually write it yourself we have

00:12:01,600 --> 00:12:07,200
the ros client library currently ros cvp

00:12:04,720 --> 00:12:08,399
in ros2 it's called rcl for ros client

00:12:07,200 --> 00:12:10,560
library

00:12:08,399 --> 00:12:12,160
and instead of using one of the dds

00:12:10,560 --> 00:12:14,160
implementations itself

00:12:12,160 --> 00:12:15,360
it always accesses the dds

00:12:14,160 --> 00:12:17,519
implementations through

00:12:15,360 --> 00:12:19,600
a middleware interface it's just

00:12:17,519 --> 00:12:20,399
basically an api specified as an

00:12:19,600 --> 00:12:22,880
interface

00:12:20,399 --> 00:12:24,079
which everyone which every of these dds

00:12:22,880 --> 00:12:26,720
implementations we implement

00:12:24,079 --> 00:12:28,160
for and so the client library does not

00:12:26,720 --> 00:12:28,800
really care which implementation is

00:12:28,160 --> 00:12:32,720
sitting

00:12:28,800 --> 00:12:34,639
below the big advantage of that one is

00:12:32,720 --> 00:12:36,399
not only that we abstract the code from

00:12:34,639 --> 00:12:38,240
that your user land code doesn't deal

00:12:36,399 --> 00:12:41,440
with dds details

00:12:38,240 --> 00:12:43,360
it's also it also like abstracts all the

00:12:41,440 --> 00:12:44,480
information which are dds specific so

00:12:43,360 --> 00:12:46,320
you could imagine

00:12:44,480 --> 00:12:48,320
implementing something under the hood

00:12:46,320 --> 00:12:50,839
which is not even dds

00:12:48,320 --> 00:12:52,480
we don't plan to do that but it's still

00:12:50,839 --> 00:12:53,920
possible

00:12:52,480 --> 00:12:55,920
optionally if you have like a very

00:12:53,920 --> 00:12:57,600
specific scenario you still

00:12:55,920 --> 00:12:59,120
might want to reach into one of the

00:12:57,600 --> 00:13:00,880
lower levels if you

00:12:59,120 --> 00:13:03,519
actually want to use specific dds

00:13:00,880 --> 00:13:03,519
functionality

00:13:04,160 --> 00:13:08,720
sorry there's also like a link so all of

00:13:07,120 --> 00:13:10,240
this development and also some

00:13:08,720 --> 00:13:12,639
documentation about that one

00:13:10,240 --> 00:13:13,760
is obviously on github i mean we're not

00:13:12,639 --> 00:13:16,720
called open source

00:13:13,760 --> 00:13:17,760
robotic foundation by any chance so if

00:13:16,720 --> 00:13:20,320
you go to the

00:13:17,760 --> 00:13:21,440
ros2 arc unit on github so github slash

00:13:20,320 --> 00:13:23,440
ros2

00:13:21,440 --> 00:13:25,279
you will find a set of repositories and

00:13:23,440 --> 00:13:27,279
the design repository is one where we

00:13:25,279 --> 00:13:30,079
usually like try to document

00:13:27,279 --> 00:13:32,639
our process on design decisions or

00:13:30,079 --> 00:13:32,639
implementation

00:13:32,839 --> 00:13:36,079
questions

00:13:34,000 --> 00:13:37,279
thing i want to like just go into uh

00:13:36,079 --> 00:13:39,760
briefly is

00:13:37,279 --> 00:13:41,199
um how the ros messages will are handled

00:13:39,760 --> 00:13:43,199
in this new system

00:13:41,199 --> 00:13:45,920
the the point is we still want to use

00:13:43,199 --> 00:13:47,600
like the ros.msg format to specify how a

00:13:45,920 --> 00:13:50,160
message looks like

00:13:47,600 --> 00:13:52,240
dds has its own specification format the

00:13:50,160 --> 00:13:55,360
idl files they actually derive from the

00:13:52,240 --> 00:13:58,079
idl format from corba

00:13:55,360 --> 00:13:59,199
so you we usually generate from a

00:13:58,079 --> 00:14:01,680
message file a c

00:13:59,199 --> 00:14:03,199
plus struct or a python class which will

00:14:01,680 --> 00:14:06,320
just give you like the members

00:14:03,199 --> 00:14:08,160
in a programmatic interface and

00:14:06,320 --> 00:14:11,519
from this one we can automatically with

00:14:08,160 --> 00:14:13,760
a code generator derive the dds idl file

00:14:11,519 --> 00:14:16,320
and from that one again each vendor

00:14:13,760 --> 00:14:16,720
implements a tool to generate code like

00:14:16,320 --> 00:14:19,519
c

00:14:16,720 --> 00:14:20,720
plus c code java code whatever to

00:14:19,519 --> 00:14:23,199
actually

00:14:20,720 --> 00:14:24,880
do all the serialization work provide

00:14:23,199 --> 00:14:26,480
publisher and subscriber interfaces for

00:14:24,880 --> 00:14:29,920
those classes

00:14:26,480 --> 00:14:31,040
and this is great in terms of

00:14:29,920 --> 00:14:33,920
flexibility

00:14:31,040 --> 00:14:35,519
but on the other hand that means if you

00:14:33,920 --> 00:14:37,279
have a message package the message

00:14:35,519 --> 00:14:38,560
package will generate vendor-specific

00:14:37,279 --> 00:14:40,000
code

00:14:38,560 --> 00:14:41,600
which is good because it generates

00:14:40,000 --> 00:14:42,560
efficient code which the compiler can

00:14:41,600 --> 00:14:45,040
optimize

00:14:42,560 --> 00:14:46,560
but on the other hand if we think about

00:14:45,040 --> 00:14:49,199
shipping this is debian package this

00:14:46,560 --> 00:14:50,880
means if we support n vendors

00:14:49,199 --> 00:14:52,560
every message package we have in ross

00:14:50,880 --> 00:14:53,920
will be there end times

00:14:52,560 --> 00:14:55,839
which is kind of a pain because we have

00:14:53,920 --> 00:14:59,600
to maintain the build farm

00:14:55,839 --> 00:15:02,480
so another alternative we came up with

00:14:59,600 --> 00:15:04,720
dds specifies uh in the x types

00:15:02,480 --> 00:15:05,920
extensions a dynamic interface where you

00:15:04,720 --> 00:15:08,079
can basically

00:15:05,920 --> 00:15:09,600
programmatically put together your

00:15:08,079 --> 00:15:13,680
message with all the fields

00:15:09,600 --> 00:15:16,160
and access all the members using an api

00:15:13,680 --> 00:15:17,279
which gets rid of all this custom code

00:15:16,160 --> 00:15:20,240
which gets generalized

00:15:17,279 --> 00:15:22,160
generated for each message instead we

00:15:20,240 --> 00:15:22,880
only have to generate the information

00:15:22,160 --> 00:15:25,440
that the code

00:15:22,880 --> 00:15:26,480
knows like the specification at in the

00:15:25,440 --> 00:15:29,199
code so you basically

00:15:26,480 --> 00:15:30,240
generate c plus introspection for each

00:15:29,199 --> 00:15:32,639
message

00:15:30,240 --> 00:15:34,160
and then you have one generic uh code

00:15:32,639 --> 00:15:35,920
path for each vendor

00:15:34,160 --> 00:15:37,360
which will actually be able to read this

00:15:35,920 --> 00:15:39,199
introspection information

00:15:37,360 --> 00:15:40,720
and process them so these are two

00:15:39,199 --> 00:15:42,000
different ways how we can deal with

00:15:40,720 --> 00:15:45,839
messages

00:15:42,000 --> 00:15:46,160
i will um i'll not go into details about

00:15:45,839 --> 00:15:47,279
that

00:15:46,160 --> 00:15:49,920
we'll see something on the on the

00:15:47,279 --> 00:15:52,240
conclusion slide for that

00:15:49,920 --> 00:15:53,600
another aspect we've also worked on

00:15:52,240 --> 00:15:54,880
which is a little bit detached from what

00:15:53,600 --> 00:15:58,320
i mentioned

00:15:54,880 --> 00:15:59,279
until now beside dds and and and ross

00:15:58,320 --> 00:16:03,839
messages

00:15:59,279 --> 00:16:04,720
we also have certain concepts in ros.1.0

00:16:03,839 --> 00:16:07,440
which we are not

00:16:04,720 --> 00:16:09,279
that happy anymore with so if you think

00:16:07,440 --> 00:16:11,440
about our ras package path

00:16:09,279 --> 00:16:12,480
and you want to find a resource or you

00:16:11,440 --> 00:16:15,360
want to find

00:16:12,480 --> 00:16:16,000
for arvis the list of available plugins

00:16:15,360 --> 00:16:17,759
the problem

00:16:16,000 --> 00:16:20,000
tends to be that you have to crawl your

00:16:17,759 --> 00:16:21,120
file system which is great if you only

00:16:20,000 --> 00:16:22,880
have a couple of packages

00:16:21,120 --> 00:16:24,480
but as the system scales and it does

00:16:22,880 --> 00:16:26,160
scale we see that

00:16:24,480 --> 00:16:27,600
with the community grow that we have

00:16:26,160 --> 00:16:30,560
more and more packages

00:16:27,600 --> 00:16:32,720
it's just not performant enough so based

00:16:30,560 --> 00:16:34,560
on that one we figured out

00:16:32,720 --> 00:16:36,240
we thought about how to do a new system

00:16:34,560 --> 00:16:38,880
to to index information

00:16:36,240 --> 00:16:40,800
because a lot of information um we don't

00:16:38,880 --> 00:16:42,160
need to recrawl every time

00:16:40,800 --> 00:16:44,480
because the information is there at

00:16:42,160 --> 00:16:47,680
compile time and if i do some extra

00:16:44,480 --> 00:16:49,920
effort at compile time i can

00:16:47,680 --> 00:16:51,920
pre-compute all these information in a

00:16:49,920 --> 00:16:53,279
way that they are at runtime much faster

00:16:51,920 --> 00:16:55,759
to query

00:16:53,279 --> 00:16:57,279
and so in order to answer questions what

00:16:55,759 --> 00:16:59,360
kind of packages are available

00:16:57,279 --> 00:17:01,199
or where is the share folder for a

00:16:59,360 --> 00:17:04,160
package or what are the

00:17:01,199 --> 00:17:06,400
plugins for ours instead of crawling the

00:17:04,160 --> 00:17:07,679
file system parsing your xml files every

00:17:06,400 --> 00:17:09,600
time over and over

00:17:07,679 --> 00:17:10,880
trying to cache that and then deal with

00:17:09,600 --> 00:17:13,839
that the cache is too

00:17:10,880 --> 00:17:15,039
too old or that we re refresh the cache

00:17:13,839 --> 00:17:18,720
too often

00:17:15,039 --> 00:17:20,480
we actually build a way to

00:17:18,720 --> 00:17:22,400
extract these information at compile

00:17:20,480 --> 00:17:24,480
time put them in a certain

00:17:22,400 --> 00:17:26,000
structure in the file system that we can

00:17:24,480 --> 00:17:28,880
afterwards with very low

00:17:26,000 --> 00:17:31,440
effort query these information i'll not

00:17:28,880 --> 00:17:33,200
go into more details you will find

00:17:31,440 --> 00:17:35,120
under this url there's a long readme

00:17:33,200 --> 00:17:37,039
file which describes all the details

00:17:35,120 --> 00:17:38,640
but so we're also looking into into

00:17:37,039 --> 00:17:39,760
address and addressing these kind of

00:17:38,640 --> 00:17:41,840
conceptual

00:17:39,760 --> 00:17:44,240
shortcomings in ros one to make them

00:17:41,840 --> 00:17:47,120
like better in ros2

00:17:44,240 --> 00:17:48,080
so it's not all about dds what do we

00:17:47,120 --> 00:17:50,559
have right now

00:17:48,080 --> 00:17:51,360
so we do have a prototype up and running

00:17:50,559 --> 00:17:53,760
which is a simple

00:17:51,360 --> 00:17:54,400
talker and listener demo so a symbol

00:17:53,760 --> 00:17:56,480
pops up

00:17:54,400 --> 00:17:58,480
it supports all kinds of messages so we

00:17:56,480 --> 00:18:00,160
have the same message format

00:17:58,480 --> 00:18:01,520
it's a little bit extended so we really

00:18:00,160 --> 00:18:03,280
have default values now

00:18:01,520 --> 00:18:04,960
i guess a lot of people asked for that

00:18:03,280 --> 00:18:07,120
in the in the past

00:18:04,960 --> 00:18:08,480
um you can send fixed size arrays

00:18:07,120 --> 00:18:10,000
there's a differentiation between

00:18:08,480 --> 00:18:12,160
unbounded and bounded areas

00:18:10,000 --> 00:18:13,360
just to make memory allocation more

00:18:12,160 --> 00:18:15,440
efficient

00:18:13,360 --> 00:18:16,640
and time and duration actually like

00:18:15,440 --> 00:18:17,919
built-in types now

00:18:16,640 --> 00:18:20,480
i don't know if you've ever dealt with

00:18:17,919 --> 00:18:21,919
like time objects in ross

00:18:20,480 --> 00:18:24,880
in python and cbs plus they have

00:18:21,919 --> 00:18:27,120
different members which is kind of weird

00:18:24,880 --> 00:18:28,960
um so all this is like unified in that

00:18:27,120 --> 00:18:30,559
process

00:18:28,960 --> 00:18:32,400
this prototype works with currently

00:18:30,559 --> 00:18:33,200
three different implementations we have

00:18:32,400 --> 00:18:35,039
from rti

00:18:33,200 --> 00:18:37,039
the connect implementation using the

00:18:35,039 --> 00:18:37,760
statically generated code i mentioned

00:18:37,039 --> 00:18:41,120
before

00:18:37,760 --> 00:18:41,520
or using the dynamic data api from prism

00:18:41,120 --> 00:18:42,960
tech

00:18:41,520 --> 00:18:45,200
we currently only have the statically

00:18:42,960 --> 00:18:46,160
generated code because they don't expose

00:18:45,200 --> 00:18:48,080
the other part

00:18:46,160 --> 00:18:50,080
as in public api yet that will come in

00:18:48,080 --> 00:18:51,520
the near future

00:18:50,080 --> 00:18:53,760
and the interesting part of that one

00:18:51,520 --> 00:18:56,799
because dds specifies

00:18:53,760 --> 00:18:58,000
in the standard how the wire format

00:18:56,799 --> 00:19:01,039
looks like how the

00:18:58,000 --> 00:19:02,240
behavior to interact between entities in

00:19:01,039 --> 00:19:04,080
this system is

00:19:02,240 --> 00:19:06,000
you can even run a talker with

00:19:04,080 --> 00:19:07,120
implementation a and a listener with

00:19:06,000 --> 00:19:09,520
implementation b

00:19:07,120 --> 00:19:11,200
they will just natively talk to each

00:19:09,520 --> 00:19:14,320
other because the specification is like

00:19:11,200 --> 00:19:16,080
set and we don't have to write that

00:19:14,320 --> 00:19:17,440
what our first experience based on these

00:19:16,080 --> 00:19:19,840
prototypes is

00:19:17,440 --> 00:19:20,480
we do have the case that if you have one

00:19:19,840 --> 00:19:22,480
to n

00:19:20,480 --> 00:19:24,080
communications or multiple subscribers

00:19:22,480 --> 00:19:26,480
it's just faster because dds

00:19:24,080 --> 00:19:27,679
supports multicast which obviously takes

00:19:26,480 --> 00:19:30,960
less bandwidth than

00:19:27,679 --> 00:19:32,640
ros one for some vendors if you do a

00:19:30,960 --> 00:19:33,760
local host communication they already do

00:19:32,640 --> 00:19:35,520
shared memory

00:19:33,760 --> 00:19:36,799
but we will still provide a way similar

00:19:35,520 --> 00:19:38,400
to notelets where you pass shared

00:19:36,799 --> 00:19:41,360
pointers that's a different topic

00:19:38,400 --> 00:19:42,320
we'll probably hear from william later

00:19:41,360 --> 00:19:44,720
you can have

00:19:42,320 --> 00:19:46,880
tweaks to actually enable reliable

00:19:44,720 --> 00:19:48,799
message delivery that will not make the

00:19:46,880 --> 00:19:50,480
message delivery reliable but it will

00:19:48,799 --> 00:19:52,240
make it reliable in terms of if it

00:19:50,480 --> 00:19:54,240
doesn't arrive at the other side

00:19:52,240 --> 00:19:56,640
you will get a notification and you can

00:19:54,240 --> 00:19:58,480
deal with it

00:19:56,640 --> 00:20:00,480
and also with the quality of service

00:19:58,480 --> 00:20:02,240
parameters you can much better tweak it

00:20:00,480 --> 00:20:04,240
to like wireless dropouts so you can

00:20:02,240 --> 00:20:05,440
actually make the trade-off how fast you

00:20:04,240 --> 00:20:07,520
want it to recover

00:20:05,440 --> 00:20:09,120
and spend the necessary bandwidth for

00:20:07,520 --> 00:20:12,720
that

00:20:09,120 --> 00:20:15,120
so what else to expect based on

00:20:12,720 --> 00:20:16,880
using dds we will definitely face much

00:20:15,120 --> 00:20:18,159
better

00:20:16,880 --> 00:20:20,000
scenarios with like network

00:20:18,159 --> 00:20:22,480
configuration to make it tailor it to

00:20:20,000 --> 00:20:23,200
yours to your certain scenario we'll

00:20:22,480 --> 00:20:26,080
have

00:20:23,200 --> 00:20:27,280
much better uh reliable or best effort

00:20:26,080 --> 00:20:28,799
communication

00:20:27,280 --> 00:20:30,799
and you can actually detect if something

00:20:28,799 --> 00:20:32,960
doesn't arrive or if another node dies

00:20:30,799 --> 00:20:36,159
this is just built in functional gdds we

00:20:32,960 --> 00:20:36,159
don't have to worry about that

00:20:36,240 --> 00:20:39,760
this allows us to do much better

00:20:37,760 --> 00:20:41,919
introspection of the system

00:20:39,760 --> 00:20:44,000
because we know that certain things fail

00:20:41,919 --> 00:20:46,480
and can react on them

00:20:44,000 --> 00:20:47,120
we can also have a much better startup

00:20:46,480 --> 00:20:48,640
of a

00:20:47,120 --> 00:20:50,159
deterministic startup of a complex

00:20:48,640 --> 00:20:53,039
system because we know when certain

00:20:50,159 --> 00:20:56,720
nodes reach a certain level

00:20:53,039 --> 00:20:58,400
and having events about new topics and

00:20:56,720 --> 00:21:00,960
some things like that are just built in

00:20:58,400 --> 00:21:03,520
dds

00:21:00,960 --> 00:21:04,480
um i will skip on those one based on the

00:21:03,520 --> 00:21:07,840
time

00:21:04,480 --> 00:21:09,520
um we will hear some of the last bullet

00:21:07,840 --> 00:21:10,400
points in williams talks i will also not

00:21:09,520 --> 00:21:13,120
mention them

00:21:10,400 --> 00:21:14,159
so what's the outlook for us we

00:21:13,120 --> 00:21:16,880
currently work on

00:21:14,159 --> 00:21:18,320
a lot of different topics and there are

00:21:16,880 --> 00:21:19,360
tons of topics you don't have to look to

00:21:18,320 --> 00:21:21,679
the individual notes

00:21:19,360 --> 00:21:23,760
there are tons of topics to work on but

00:21:21,679 --> 00:21:24,240
our goal is to release the first version

00:21:23,760 --> 00:21:27,679
of

00:21:24,240 --> 00:21:28,480
ros2 together with next year's ross jade

00:21:27,679 --> 00:21:31,039
release

00:21:28,480 --> 00:21:32,480
so we planned that for may 2015. this

00:21:31,039 --> 00:21:34,159
will not be the

00:21:32,480 --> 00:21:36,400
the perfect release which contains

00:21:34,159 --> 00:21:37,679
everything but we try to get as high as

00:21:36,400 --> 00:21:41,039
possible in the stack so

00:21:37,679 --> 00:21:42,640
the aim is to have something like arvis

00:21:41,039 --> 00:21:44,480
showing you that it can build on top of

00:21:42,640 --> 00:21:46,080
ross 2.0

00:21:44,480 --> 00:21:47,760
and don't be worried there will still be

00:21:46,080 --> 00:21:49,039
a jade release that will just be

00:21:47,760 --> 00:21:52,159
parallel it will be the

00:21:49,039 --> 00:21:59,840
ros one you're all used to

00:21:52,159 --> 00:21:59,840
okay that's it thank you very much

00:22:04,080 --> 00:22:07,919
we have time for one question

00:22:10,840 --> 00:22:13,840
please

00:22:20,159 --> 00:22:23,679
so so the question was if we have like

00:22:21,840 --> 00:22:26,400
two distros like the ros one

00:22:23,679 --> 00:22:27,600
j turtle and a ross 2.0 first release

00:22:26,400 --> 00:22:29,679
available in parallel

00:22:27,600 --> 00:22:31,039
what would make the user choose between

00:22:29,679 --> 00:22:32,720
them well

00:22:31,039 --> 00:22:34,400
i mean the first the first decision will

00:22:32,720 --> 00:22:35,679
definitely be based on what you want to

00:22:34,400 --> 00:22:38,320
use of the system

00:22:35,679 --> 00:22:39,039
if you require move it nav stack and all

00:22:38,320 --> 00:22:40,559
these

00:22:39,039 --> 00:22:43,039
higher level packages you will very

00:22:40,559 --> 00:22:44,799
likely stay at ros one for quite some

00:22:43,039 --> 00:22:46,640
time because they will not be available

00:22:44,799 --> 00:22:48,960
on day one

00:22:46,640 --> 00:22:50,400
but if you think about a scenario where

00:22:48,960 --> 00:22:54,320
you do not have that

00:22:50,400 --> 00:22:56,320
amount of dependencies you

00:22:54,320 --> 00:22:58,880
might see a lot of features in ros 2.0

00:22:56,320 --> 00:23:00,880
like for example deterministic startup

00:22:58,880 --> 00:23:02,240
reliable communication or if you think

00:23:00,880 --> 00:23:04,000
about multi-robot

00:23:02,240 --> 00:23:05,840
communication much better network

00:23:04,000 --> 00:23:08,240
behavior than ros1

00:23:05,840 --> 00:23:09,760
then you will probably start trying with

00:23:08,240 --> 00:23:12,559
ros 2.0 to see if it

00:23:09,760 --> 00:23:13,440
that fits your needs better um but yes

00:23:12,559 --> 00:23:16,720
it will be like

00:23:13,440 --> 00:23:18,720
some duration until uh enough

00:23:16,720 --> 00:23:20,400
enough components have been transferred

00:23:18,720 --> 00:23:22,880
to work with both

00:23:20,400 --> 00:23:24,960
and we definitely aim that you can do

00:23:22,880 --> 00:23:26,720
that like on a on a note by note level

00:23:24,960 --> 00:23:28,559
so if you have like a simple node which

00:23:26,720 --> 00:23:30,159
doesn't have that many dependencies

00:23:28,559 --> 00:23:32,320
you might be able to migrate that

00:23:30,159 --> 00:23:33,679
earlier and a more complex node having

00:23:32,320 --> 00:23:35,679
more dependencies you might

00:23:33,679 --> 00:23:37,760
migrate later and before you just run a

00:23:35,679 --> 00:23:41,279
mixed system

00:23:37,760 --> 00:23:43,120
yeah only one okay

00:23:41,279 --> 00:23:46,720
sorry no second question you can catch

00:23:43,120 --> 00:23:46,720
me after that one in the in the break

00:23:48,840 --> 00:23:51,840
thanks

00:23:54,400 --> 00:23:56,480

YouTube URL: https://www.youtube.com/watch?v=Wvsn3T4DV2o


