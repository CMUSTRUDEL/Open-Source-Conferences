Title: WIlliam Woodall: ROS 2 0 Developer preview
Publication date: 2015-10-19
Playlist: ROSCon 2014
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2014 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:05,040
hello my name is William I work for the

00:00:03,510 --> 00:00:07,049
open-source robotics foundation I work

00:00:05,040 --> 00:00:10,500
on Ross primarily with Dirk totally

00:00:07,049 --> 00:00:14,670
honest I in last couple months we've

00:00:10,500 --> 00:00:18,180
been working on on the are Ross two

00:00:14,670 --> 00:00:20,640
prototypes and Dirk talked a little bit

00:00:18,180 --> 00:00:23,070
about this earlier this morning but I

00:00:20,640 --> 00:00:25,170
wanted to sort of give an overview try

00:00:23,070 --> 00:00:26,550
to make more concrete what what we're

00:00:25,170 --> 00:00:28,769
talking about when we say Ross two point

00:00:26,550 --> 00:00:31,439
oh like what are some of the changes to

00:00:28,769 --> 00:00:33,180
the API we feel we need to make and what

00:00:31,439 --> 00:00:37,440
other parts of the system do we imagine

00:00:33,180 --> 00:00:39,719
can be better and how so I saw a lot of

00:00:37,440 --> 00:00:40,860
people taking pictures of slides when

00:00:39,719 --> 00:00:43,559
they thought their interesting just take

00:00:40,860 --> 00:00:45,719
just get the slides don't that seems

00:00:43,559 --> 00:00:48,210
silly so if if you guys want to get the

00:00:45,719 --> 00:00:48,930
QR code or copy the thing there this

00:00:48,210 --> 00:00:52,289
will be at the end of the presentation

00:00:48,930 --> 00:00:53,520
as well so first of all what is Ross to

00:00:52,289 --> 00:00:56,670
and again Dirk covered some of these

00:00:53,520 --> 00:00:58,949
things already I think the first thing

00:00:56,670 --> 00:01:00,690
to realize is it Ross too is it's not

00:00:58,949 --> 00:01:01,770
going to break Ross one and Ross

00:01:00,690 --> 00:01:03,769
someone's going to continue to be there

00:01:01,770 --> 00:01:06,060
and it goes supported for five years and

00:01:03,769 --> 00:01:08,340
we're going to have future releases of

00:01:06,060 --> 00:01:12,210
Ross one in the meantime while we're

00:01:08,340 --> 00:01:14,610
working on rots to and Ross to is sort

00:01:12,210 --> 00:01:16,200
of our opportunity to look to the future

00:01:14,610 --> 00:01:17,970
and see how we can make it better so

00:01:16,200 --> 00:01:19,590
that when you realize you want something

00:01:17,970 --> 00:01:21,210
better it's there for you to use it and

00:01:19,590 --> 00:01:22,710
it's too late to start building it when

00:01:21,210 --> 00:01:25,170
you realize you want it so we're

00:01:22,710 --> 00:01:26,820
starting now that being said we are

00:01:25,170 --> 00:01:29,310
breaking the API with Ross one there are

00:01:26,820 --> 00:01:33,479
some issues with the way Ross ones API

00:01:29,310 --> 00:01:35,640
works especially in C++ and Python that

00:01:33,479 --> 00:01:38,220
that we have to break the API to fix

00:01:35,640 --> 00:01:39,479
correctly but conceptually it's very

00:01:38,220 --> 00:01:41,369
similar we're not changing the entire

00:01:39,479 --> 00:01:42,659
game you still have nodes publisher

00:01:41,369 --> 00:01:44,250
subscribers and things like that but

00:01:42,659 --> 00:01:47,189
mostly it's a chance for us to

00:01:44,250 --> 00:01:48,840
re-evaluate our dependencies and some

00:01:47,189 --> 00:01:52,560
design decisions fix some fundamental

00:01:48,840 --> 00:01:54,479
problems it will interoperate with Ross

00:01:52,560 --> 00:01:57,180
one to make transition easier to let

00:01:54,479 --> 00:01:59,009
people try it out without without

00:01:57,180 --> 00:02:00,060
committing wholesale to it it'll

00:01:59,009 --> 00:02:02,159
probably be through some kind of a

00:02:00,060 --> 00:02:05,270
bridge mechanism though we're going to

00:02:02,159 --> 00:02:08,369
continue using Rosslyn's message IDL

00:02:05,270 --> 00:02:10,140
which should be familiar to users and

00:02:08,369 --> 00:02:11,830
help us keep in sync with Rossum one in

00:02:10,140 --> 00:02:15,510
terms of messages

00:02:11,830 --> 00:02:17,740
we're holy embracing C++ 11 in Python 3

00:02:15,510 --> 00:02:21,010
which means that those are going to be

00:02:17,740 --> 00:02:23,470
requirements to use a lots too but it

00:02:21,010 --> 00:02:25,090
also means that we can drop some

00:02:23,470 --> 00:02:27,280
dependencies and things like that like

00:02:25,090 --> 00:02:30,190
hope so far we haven't used boost at all

00:02:27,280 --> 00:02:31,990
which is pretty nice there's all kinds

00:02:30,190 --> 00:02:33,310
of other nice things about C++ 11 i

00:02:31,990 --> 00:02:35,920
highly encourage you to look into if you

00:02:33,310 --> 00:02:38,650
haven't we're going to have a

00:02:35,920 --> 00:02:42,700
full-featured capi the idea here is that

00:02:38,650 --> 00:02:44,620
we can support client libraries and

00:02:42,700 --> 00:02:46,570
other languages more easily and get more

00:02:44,620 --> 00:02:48,730
consistent results because I'm sure if

00:02:46,570 --> 00:02:51,040
any of you ever use raw spy or raw Java

00:02:48,730 --> 00:02:54,300
as long side Ross EVP there are many

00:02:51,040 --> 00:02:56,910
subtle differences which can be annoying

00:02:54,300 --> 00:02:59,440
we're going to use dds as the middleware

00:02:56,910 --> 00:03:00,940
and we're going to be aiming for

00:02:59,440 --> 00:03:02,770
real-time and embedded in Windows

00:03:00,940 --> 00:03:05,530
support in addition to through OS X and

00:03:02,770 --> 00:03:07,720
Linux like we've traditionally done it's

00:03:05,530 --> 00:03:09,490
built on top of standards which makes it

00:03:07,720 --> 00:03:12,040
reproducible by other ppl makes it more

00:03:09,490 --> 00:03:13,959
palatable for mission critical

00:03:12,040 --> 00:03:17,980
situations and companies and things like

00:03:13,959 --> 00:03:20,500
that and it's gonna be awesome so so

00:03:17,980 --> 00:03:21,790
what have we done so far so like I said

00:03:20,500 --> 00:03:23,890
we're using dds is the middle where

00:03:21,790 --> 00:03:27,220
we're going to be able to switch dds

00:03:23,890 --> 00:03:30,160
vendors as a matter of design of the

00:03:27,220 --> 00:03:32,620
system the reference implementation so

00:03:30,160 --> 00:03:33,580
that was a big issue about licensing and

00:03:32,620 --> 00:03:36,550
which will pick for there to be the

00:03:33,580 --> 00:03:38,290
default and you know we want to make it

00:03:36,550 --> 00:03:41,410
so that people can use what makes no

00:03:38,290 --> 00:03:43,120
sense for them and we're going to

00:03:41,410 --> 00:03:44,950
continue use the message files like I

00:03:43,120 --> 00:03:48,910
said so existing what can you do with

00:03:44,950 --> 00:03:51,130
the existing prototype that we have you

00:03:48,910 --> 00:03:52,630
can create nodes and publishers and

00:03:51,130 --> 00:03:55,030
subscribers and we have Alzheimers and

00:03:52,630 --> 00:03:57,459
wall rights which is enough to implement

00:03:55,030 --> 00:03:59,739
basically talker and listener for a

00:03:57,459 --> 00:04:03,100
couple different scenarios which i'll

00:03:59,739 --> 00:04:05,200
show some of today you can switch

00:04:03,100 --> 00:04:07,150
vendors at link time all this dirk

00:04:05,200 --> 00:04:10,090
already covered something i'll be

00:04:07,150 --> 00:04:11,799
talking more about is i'll be showing

00:04:10,090 --> 00:04:13,480
you how the changes in the api we want

00:04:11,799 --> 00:04:15,760
to make support having multiple nodes in

00:04:13,480 --> 00:04:20,229
a single process easier sonoda 'let's

00:04:15,760 --> 00:04:22,510
are sort of sort of implemented on top

00:04:20,229 --> 00:04:24,860
of the existing ross implementation and

00:04:22,510 --> 00:04:25,669
provide sort of pseudo nodes

00:04:24,860 --> 00:04:27,169
and they're not really first-class

00:04:25,669 --> 00:04:30,229
citizens and we want to make that

00:04:27,169 --> 00:04:33,080
different we want nodes to be the first

00:04:30,229 --> 00:04:34,580
class interface both for running

00:04:33,080 --> 00:04:36,469
multiple nodes in a single process or

00:04:34,580 --> 00:04:40,490
one node alone by itself in a process

00:04:36,469 --> 00:04:42,740
and hopefully in doing that improve the

00:04:40,490 --> 00:04:45,439
way you do concurrency and their

00:04:42,740 --> 00:04:48,020
examples on Ross to slash examples if

00:04:45,439 --> 00:04:49,639
you want to look and see so I'm going to

00:04:48,020 --> 00:04:51,229
talk about I'm going to jump right into

00:04:49,639 --> 00:04:52,819
the code because I think most people are

00:04:51,229 --> 00:04:53,930
interested at least when I'm looking at

00:04:52,819 --> 00:04:55,580
a new project I like to see what the

00:04:53,930 --> 00:04:58,069
code is going to look like to start with

00:04:55,580 --> 00:04:59,029
but i'm going to show a talker example

00:04:58,069 --> 00:05:02,599
and i'm going to show you a listener

00:04:59,029 --> 00:05:04,219
example in a different style and i'm

00:05:02,599 --> 00:05:05,840
going to talk about how we want to

00:05:04,219 --> 00:05:08,360
improve the nodal it style of developing

00:05:05,840 --> 00:05:11,240
nodes so you can write more efficient

00:05:08,360 --> 00:05:12,830
code out of the box and drill down into

00:05:11,240 --> 00:05:15,229
that a little bit to give you some

00:05:12,830 --> 00:05:16,310
detail a good example of why we want to

00:05:15,229 --> 00:05:18,860
change it and what are the technical

00:05:16,310 --> 00:05:19,939
reasons behind that and then I'm going

00:05:18,860 --> 00:05:21,500
to talk about some other high-level

00:05:19,939 --> 00:05:25,729
features that we want to change that are

00:05:21,500 --> 00:05:27,529
on the horizon so this this is this is

00:05:25,729 --> 00:05:30,050
code that compiles in our example for

00:05:27,529 --> 00:05:34,129
the most part some small changes to make

00:05:30,050 --> 00:05:35,659
the code fit on the screen in this in

00:05:34,129 --> 00:05:39,199
this situation we're inheriting from

00:05:35,659 --> 00:05:40,550
node and doing all our work in a class

00:05:39,199 --> 00:05:43,400
based system you can see here there's no

00:05:40,550 --> 00:05:45,409
spin because the idea is that you create

00:05:43,400 --> 00:05:47,509
this make a library out of it and then

00:05:45,409 --> 00:05:48,740
we run the execution for you which you

00:05:47,509 --> 00:05:50,089
get a lot of features for we'll talk

00:05:48,740 --> 00:05:53,449
about more later but some things to

00:05:50,089 --> 00:05:55,460
notice here inherits from node when you

00:05:53,449 --> 00:05:57,979
create the node you delegate the name of

00:05:55,460 --> 00:06:02,419
your node to to the constructor of the

00:05:57,979 --> 00:06:04,189
node it'll still support the idea of

00:06:02,419 --> 00:06:05,479
Ross name so you can change the name of

00:06:04,189 --> 00:06:08,419
the node from the command line or from

00:06:05,479 --> 00:06:09,979
your launch file but the way you set the

00:06:08,419 --> 00:06:13,279
default value will be through the

00:06:09,979 --> 00:06:15,229
constructor of the node class we're

00:06:13,279 --> 00:06:17,180
using C++ all over the place some cool

00:06:15,229 --> 00:06:19,580
things on this page user-defined

00:06:17,180 --> 00:06:22,430
literals so you can create a timer with

00:06:19,580 --> 00:06:24,469
hertz or seconds to define a rate or a

00:06:22,430 --> 00:06:27,979
period respectively it's no longer

00:06:24,469 --> 00:06:29,719
ambiguous what the value there is we're

00:06:27,979 --> 00:06:32,870
using Auto wherever it makes sense and

00:06:29,719 --> 00:06:34,520
we're using things that used to be

00:06:32,870 --> 00:06:35,599
provided by boost but to me now how in

00:06:34,520 --> 00:06:37,520
the standard library like shared

00:06:35,599 --> 00:06:40,580
pointers

00:06:37,520 --> 00:06:41,509
so you look at the class design you're

00:06:40,580 --> 00:06:43,310
like well that doesn't work in all

00:06:41,509 --> 00:06:45,889
situations I'm you know integrating with

00:06:43,310 --> 00:06:47,300
another system with an event loop or you

00:06:45,889 --> 00:06:48,800
know doing a driver or have some of

00:06:47,300 --> 00:06:51,500
their special k so I just prefer this

00:06:48,800 --> 00:06:55,220
method you can still do that so and this

00:06:51,500 --> 00:06:57,229
in this example I have one of the

00:06:55,220 --> 00:07:02,449
examples from our examples repository of

00:06:57,229 --> 00:07:04,280
a the listener hello world sort of thing

00:07:02,449 --> 00:07:05,810
that's in the Ross tutorials and then in

00:07:04,280 --> 00:07:08,840
the comments I have the rosslyn

00:07:05,810 --> 00:07:11,449
equivalent to each of those lines so you

00:07:08,840 --> 00:07:16,729
can see that the callback is really

00:07:11,449 --> 00:07:19,039
similar the basically identical and here

00:07:16,729 --> 00:07:20,210
we're using logging macro and Ross will

00:07:19,039 --> 00:07:21,889
have the same thing and the new one I

00:07:20,210 --> 00:07:24,650
just don't have it yet so I'm using

00:07:21,889 --> 00:07:28,009
standard i/o for this now they're

00:07:24,650 --> 00:07:30,590
iostream you can see that the next

00:07:28,009 --> 00:07:31,909
important fact is that the nodes name

00:07:30,590 --> 00:07:34,099
instead of being passed to a global

00:07:31,909 --> 00:07:37,340
function is passed to the constructor of

00:07:34,099 --> 00:07:39,440
the node so this is a very subtle but

00:07:37,340 --> 00:07:41,240
important difference that allows us to

00:07:39,440 --> 00:07:42,680
more easily and transparently have more

00:07:41,240 --> 00:07:45,740
than one node in a single process

00:07:42,680 --> 00:07:47,349
without doing any shenanigans that the

00:07:45,740 --> 00:07:50,120
note let's have to do to accomplish that

00:07:47,349 --> 00:07:52,580
so that's a very important transition

00:07:50,120 --> 00:07:55,909
and then you can see we create a

00:07:52,580 --> 00:07:57,169
subscriber in very similar fashion some

00:07:55,909 --> 00:08:00,560
different names and stuff these aren't

00:07:57,169 --> 00:08:03,139
all set in stone yet I mean sort of bike

00:08:00,560 --> 00:08:06,949
shed stuff that we can discuss later but

00:08:03,139 --> 00:08:10,550
you basically give your topic name a

00:08:06,949 --> 00:08:12,199
queue size and a call back to call when

00:08:10,550 --> 00:08:16,310
you get a new message it's all

00:08:12,199 --> 00:08:19,699
relatively similar to Ross one another

00:08:16,310 --> 00:08:22,190
big difference here is that spin is

00:08:19,699 --> 00:08:24,740
called on the node as opposed to

00:08:22,190 --> 00:08:27,020
globally with no parameters again spin

00:08:24,740 --> 00:08:29,090
here was relying on implicit global

00:08:27,020 --> 00:08:34,399
state about your node which is no longer

00:08:29,090 --> 00:08:36,800
exists so you can see it's a pretty

00:08:34,399 --> 00:08:38,390
subtle subtle difference the biggest

00:08:36,800 --> 00:08:40,219
point I'm trying to point here point out

00:08:38,390 --> 00:08:42,770
here that the most evident change from

00:08:40,219 --> 00:08:46,370
the simple hello world examples here is

00:08:42,770 --> 00:08:48,680
that globes are no longer I'm sorry no

00:08:46,370 --> 00:08:50,050
nodes are no longer global and and

00:08:48,680 --> 00:08:53,860
that's at

00:08:50,050 --> 00:08:55,450
for a few ways in a few ways so mostly

00:08:53,860 --> 00:08:58,810
in the way that the idea of nodal its

00:08:55,450 --> 00:08:59,709
manifest itself in Ross too so I talked

00:08:58,810 --> 00:09:02,560
about some of these things already

00:08:59,709 --> 00:09:05,860
there's you know no global state

00:09:02,560 --> 00:09:07,660
tracking nodes this is why you have to

00:09:05,860 --> 00:09:09,279
pass it to spin there won't be any

00:09:07,660 --> 00:09:10,810
difference between nodes and nodal it's

00:09:09,279 --> 00:09:12,700
one of the big problems with nose and

00:09:10,810 --> 00:09:15,100
nodal it's was that they had subtly

00:09:12,700 --> 00:09:17,079
different api's so that if you wanted to

00:09:15,100 --> 00:09:20,290
make the decision whether your code ran

00:09:17,079 --> 00:09:23,140
in its own process or shared a process

00:09:20,290 --> 00:09:24,670
with other nodes was a decision you had

00:09:23,140 --> 00:09:27,310
to make at the time you're writing your

00:09:24,670 --> 00:09:28,570
code and we want to try to avoid that as

00:09:27,310 --> 00:09:29,589
much as possible in the future so you

00:09:28,570 --> 00:09:32,140
can make that decision at runtime

00:09:29,589 --> 00:09:40,300
instead that configuration time of your

00:09:32,140 --> 00:09:42,700
system so so how does this make these

00:09:40,300 --> 00:09:44,440
better so so as soon as you have this

00:09:42,700 --> 00:09:45,850
concept that I can run multiple nodes in

00:09:44,440 --> 00:09:47,110
the same process you can begin to do

00:09:45,850 --> 00:09:49,050
some really interesting things you can

00:09:47,110 --> 00:09:52,120
do things like thread pooling where you

00:09:49,050 --> 00:09:54,010
you allow many different nodes which are

00:09:52,120 --> 00:09:56,649
completely decoupled from each other to

00:09:54,010 --> 00:09:59,440
share execution resources which can be

00:09:56,649 --> 00:10:00,700
much more efficient then especially than

00:09:59,440 --> 00:10:04,000
having them all in separate processes

00:10:00,700 --> 00:10:06,399
but also even more efficient than having

00:10:04,000 --> 00:10:08,470
a thread for each of them you can also

00:10:06,399 --> 00:10:11,260
do things like passing shared pointers

00:10:08,470 --> 00:10:12,730
around instead of using dds or whatever

00:10:11,260 --> 00:10:15,190
the underlying implementation of the

00:10:12,730 --> 00:10:19,300
middleware to transmit between processes

00:10:15,190 --> 00:10:22,180
IPC which can be a huge win especially

00:10:19,300 --> 00:10:24,579
for pipelines involving images or 3d

00:10:22,180 --> 00:10:26,680
data stuff like that and nodal it's

00:10:24,579 --> 00:10:29,709
provided most of this functionality but

00:10:26,680 --> 00:10:31,510
they had some some drawbacks and a few

00:10:29,709 --> 00:10:32,649
of them where that the api's were

00:10:31,510 --> 00:10:35,589
different putting the nodes and the node

00:10:32,649 --> 00:10:36,910
'let's and that creating and running

00:10:35,589 --> 00:10:39,430
node 'let's was a little bit complicated

00:10:36,910 --> 00:10:41,430
and different notably different than how

00:10:39,430 --> 00:10:45,010
you create and write and run nodes

00:10:41,430 --> 00:10:46,870
regular nodes and there were some

00:10:45,010 --> 00:10:48,550
problems with the way concurrency was

00:10:46,870 --> 00:10:51,399
handled in note 'let's which led it can

00:10:48,550 --> 00:10:53,560
lead to either starvation of the thread

00:10:51,399 --> 00:10:56,730
pool threads starvation people who want

00:10:53,560 --> 00:10:59,440
to use them do them being locked up or

00:10:56,730 --> 00:11:01,480
it led to everyone using their own

00:10:59,440 --> 00:11:03,000
thread which is also not very efficient

00:11:01,480 --> 00:11:05,010
so

00:11:03,000 --> 00:11:07,140
so how are we trying to address the

00:11:05,010 --> 00:11:10,680
issue of the API is being different and

00:11:07,140 --> 00:11:12,960
the basic the basic point is we move the

00:11:10,680 --> 00:11:14,910
all the global state that used to be

00:11:12,960 --> 00:11:16,830
about nodes out of out of the global

00:11:14,910 --> 00:11:21,000
state and into being owned by the node

00:11:16,830 --> 00:11:22,410
class which basically allows you whether

00:11:21,000 --> 00:11:24,810
you create a node and then call

00:11:22,410 --> 00:11:26,790
functions on it or you subclass from a

00:11:24,810 --> 00:11:30,030
node and conk Shinzon yourself on your

00:11:26,790 --> 00:11:33,720
base class the API is the same and the

00:11:30,030 --> 00:11:36,510
behavior is the same so allows you to

00:11:33,720 --> 00:11:41,220
write both the procedural and component

00:11:36,510 --> 00:11:44,310
style api's so how about making it

00:11:41,220 --> 00:11:47,610
easier so to make it easier the primary

00:11:44,310 --> 00:11:49,620
idea is to have a seeming macro where

00:11:47,610 --> 00:11:51,750
you can define the name of your node any

00:11:49,620 --> 00:11:53,730
source code for that node and any other

00:11:51,750 --> 00:11:55,440
compile options you need and this will

00:11:53,730 --> 00:11:58,770
do three things it will create for you a

00:11:55,440 --> 00:12:00,210
library which is a shared library which

00:11:58,770 --> 00:12:02,430
contains the implementation of your node

00:12:00,210 --> 00:12:04,170
and this is to support it being used

00:12:02,430 --> 00:12:05,850
sort of like a plug-in which can be

00:12:04,170 --> 00:12:08,580
dynamically loaded if it needs it needs

00:12:05,850 --> 00:12:10,080
to be it also creates an executable for

00:12:08,580 --> 00:12:12,150
your node where if you run the

00:12:10,080 --> 00:12:13,890
executable for the node it will just run

00:12:12,150 --> 00:12:15,360
that note in its own process like you

00:12:13,890 --> 00:12:17,940
would you would expect if you would

00:12:15,360 --> 00:12:19,650
implemented your own main but you can

00:12:17,940 --> 00:12:22,050
optionally pass it some arguments which

00:12:19,650 --> 00:12:24,810
will cause it to be dynamically loaded

00:12:22,050 --> 00:12:28,290
into a process with other nodes and run

00:12:24,810 --> 00:12:30,390
there and this then this executable will

00:12:28,290 --> 00:12:32,190
serve as sort of a proxy it'll remain

00:12:30,390 --> 00:12:34,710
running while the remote thing is

00:12:32,190 --> 00:12:38,130
executing it and whether when it ends

00:12:34,710 --> 00:12:39,960
naturally or you know fatally through

00:12:38,130 --> 00:12:42,420
like a segfault or something then then

00:12:39,960 --> 00:12:44,220
your your executable in that this is a

00:12:42,420 --> 00:12:46,530
similar pattern to how node let's work

00:12:44,220 --> 00:12:48,690
so that you have some sort of proxy

00:12:46,530 --> 00:12:51,720
object to represent the thing that's

00:12:48,690 --> 00:12:53,250
running somewhere else but either way

00:12:51,720 --> 00:12:54,540
you have this executable which is sort

00:12:53,250 --> 00:12:57,630
of the single point of entry for your

00:12:54,540 --> 00:12:59,490
for your node which is a little bit

00:12:57,630 --> 00:13:01,140
easier to deal with it makes it easier

00:12:59,490 --> 00:13:04,560
to build it and then test it on your own

00:13:01,140 --> 00:13:06,180
and then easily you know then throw it

00:13:04,560 --> 00:13:09,870
and launch file and have it run with

00:13:06,180 --> 00:13:11,130
other nodes in a single process so I

00:13:09,870 --> 00:13:14,940
don't want to spend too much time on

00:13:11,130 --> 00:13:16,220
this I hope I can make it clear why this

00:13:14,940 --> 00:13:20,090
is a problem and how we're going to

00:13:16,220 --> 00:13:23,090
try to address it basically when you

00:13:20,090 --> 00:13:24,680
created a nodal it in Ross one you have

00:13:23,090 --> 00:13:26,900
to you have to either choose between a

00:13:24,680 --> 00:13:28,610
multi-threaded node handle or a single

00:13:26,900 --> 00:13:31,070
threaded note handle if you choose a

00:13:28,610 --> 00:13:32,570
multi-threaded node handle your

00:13:31,070 --> 00:13:35,450
callbacks is sort of like creating an

00:13:32,570 --> 00:13:37,400
async spinner with a value not one

00:13:35,450 --> 00:13:40,220
meaning that your callbacks can get

00:13:37,400 --> 00:13:43,220
called at the same time in different

00:13:40,220 --> 00:13:45,230
threads even reentrant lee you have

00:13:43,220 --> 00:13:49,730
multiple instances of the same callback

00:13:45,230 --> 00:13:52,430
being called at the same time and when

00:13:49,730 --> 00:13:54,410
it did that it would share a pool of

00:13:52,430 --> 00:13:57,230
threads amongst all node 'let's which

00:13:54,410 --> 00:14:01,760
did that if you select a single threaded

00:13:57,230 --> 00:14:03,620
node handle then you get a you get your

00:14:01,760 --> 00:14:05,360
own thread and it behaves like a normal

00:14:03,620 --> 00:14:07,340
ross node where you just call spin every

00:14:05,360 --> 00:14:08,300
call back in your note is executed your

00:14:07,340 --> 00:14:11,930
guarantee that they're going to be

00:14:08,300 --> 00:14:15,500
mutually exclusively executed so you're

00:14:11,930 --> 00:14:17,300
not to worry about thread safety so the

00:14:15,500 --> 00:14:20,990
problem with node list is it is that if

00:14:17,300 --> 00:14:22,690
you have a multi-threaded no delight and

00:14:20,990 --> 00:14:24,890
you have a callback that's not

00:14:22,690 --> 00:14:26,510
reintroducing shared data you will

00:14:24,890 --> 00:14:28,940
usually lock it so that if other

00:14:26,510 --> 00:14:31,370
instances of that same callback try to

00:14:28,940 --> 00:14:32,930
get run at the same time only one does

00:14:31,370 --> 00:14:34,930
it at a time the problem with this is is

00:14:32,930 --> 00:14:38,210
that in this like in this example here

00:14:34,930 --> 00:14:39,380
you've got a node with two callbacks and

00:14:38,210 --> 00:14:41,390
then another node with a single call

00:14:39,380 --> 00:14:44,090
back you have two threads in your thread

00:14:41,390 --> 00:14:46,250
pool you could have two instances of the

00:14:44,090 --> 00:14:48,080
first one the first instance is

00:14:46,250 --> 00:14:50,060
executing holding a lock and the second

00:14:48,080 --> 00:14:52,010
one's waiting on that log so you could

00:14:50,060 --> 00:14:54,110
be running call bat to of node one or

00:14:52,010 --> 00:14:55,460
call back one of node to in that second

00:14:54,110 --> 00:14:58,970
thread but you can't because it's just

00:14:55,460 --> 00:15:00,710
being wasted so to prevent this and this

00:14:58,970 --> 00:15:02,720
is really bad because node 2 is getting

00:15:00,710 --> 00:15:05,030
starved because of the behavior of node

00:15:02,720 --> 00:15:07,030
1 which really sucks so what happens is

00:15:05,030 --> 00:15:08,900
if in node to you want to avoid this

00:15:07,030 --> 00:15:11,150
typically you create a single thread

00:15:08,900 --> 00:15:12,500
node handle you get your own thread but

00:15:11,150 --> 00:15:14,450
that's not really great because having

00:15:12,500 --> 00:15:15,680
many many threads you know increases

00:15:14,450 --> 00:15:19,790
your memory footprint and it makes

00:15:15,680 --> 00:15:22,340
contact swishing less efficient so we've

00:15:19,790 --> 00:15:24,140
introduced this concept in ross 2 which

00:15:22,340 --> 00:15:26,300
is a totally optional concept but i

00:15:24,140 --> 00:15:27,670
think is a really neat concept what

00:15:26,300 --> 00:15:30,089
we're calling callback groups and

00:15:27,670 --> 00:15:32,519
callback groups basically are

00:15:30,089 --> 00:15:35,459
grouping of anything with call back

00:15:32,519 --> 00:15:40,189
Santa Cruz subscriptions service

00:15:35,459 --> 00:15:42,449
handlers timers and things like that and

00:15:40,189 --> 00:15:44,129
there's two types of call back groups

00:15:42,449 --> 00:15:46,139
there's mutually exclusive call back

00:15:44,129 --> 00:15:49,470
groups and reentrant call back groups a

00:15:46,139 --> 00:15:50,790
reentrant call back group basically any

00:15:49,470 --> 00:15:52,709
a call back that's in a reentrant call

00:15:50,790 --> 00:15:54,089
that group has to has to say you're

00:15:52,709 --> 00:15:55,470
basically saying this callback can be

00:15:54,089 --> 00:15:56,999
called at the same time as itself and

00:15:55,470 --> 00:15:59,519
the same time as any other callbacks in

00:15:56,999 --> 00:16:00,899
this group if if your group if your

00:15:59,519 --> 00:16:02,819
callback is in a mutually exclusive

00:16:00,899 --> 00:16:05,040
callback group you're basically saying

00:16:02,819 --> 00:16:07,079
my callback is not reentrant and it's

00:16:05,040 --> 00:16:10,410
also not thread-safe with any other

00:16:07,079 --> 00:16:11,939
callbacks in this in this group and

00:16:10,410 --> 00:16:14,040
that's basically the default behavior

00:16:11,939 --> 00:16:16,379
for a Ross node where you have you just

00:16:14,040 --> 00:16:18,809
call normal spin you create say two

00:16:16,379 --> 00:16:20,459
different subscribers you can access

00:16:18,809 --> 00:16:21,749
shared resources and each of the

00:16:20,459 --> 00:16:22,860
callbacks for that subscriber those

00:16:21,749 --> 00:16:24,120
subscribers because you can guarantee

00:16:22,860 --> 00:16:25,079
they're not going to call it at the same

00:16:24,120 --> 00:16:27,540
time because they're always getting

00:16:25,079 --> 00:16:28,920
called in the same thread and so that

00:16:27,540 --> 00:16:31,980
basically this concept needs to be

00:16:28,920 --> 00:16:35,160
introduced because we're decoupling the

00:16:31,980 --> 00:16:36,749
code that determines what you're doing

00:16:35,160 --> 00:16:38,939
in your callbacks and the code which

00:16:36,749 --> 00:16:40,920
executes them so when you were calling

00:16:38,939 --> 00:16:44,040
spin or calling a sink spinner you were

00:16:40,920 --> 00:16:46,079
controlling how those get executed so

00:16:44,040 --> 00:16:48,149
basically you're adding some concurrency

00:16:46,079 --> 00:16:50,279
information to your callbacks and so

00:16:48,149 --> 00:16:52,679
this helps to this in that example I

00:16:50,279 --> 00:16:54,329
talked about you can put the callbacks

00:16:52,679 --> 00:16:57,480
for node one in a mutually exclusive

00:16:54,329 --> 00:17:00,149
callback group and now the system that's

00:16:57,480 --> 00:17:01,769
executing all of the callbacks for all

00:17:00,149 --> 00:17:03,540
the different nodes is smart enough to

00:17:01,769 --> 00:17:06,059
know that even though node 1 callback

00:17:03,540 --> 00:17:07,589
one could be executed it's not eligible

00:17:06,059 --> 00:17:09,270
because it's already executing an

00:17:07,589 --> 00:17:12,600
instance of it and what that does is it

00:17:09,270 --> 00:17:14,339
allows us to prevent them being called

00:17:12,600 --> 00:17:15,899
back there run at the same time without

00:17:14,339 --> 00:17:17,909
using locks which is a lot more

00:17:15,899 --> 00:17:20,909
efficient and allows you better

00:17:17,909 --> 00:17:22,470
concurrency when sharing amongst threats

00:17:20,909 --> 00:17:25,230
so that's I think that's a really cool

00:17:22,470 --> 00:17:29,039
idea hopefully it wasn't too too

00:17:25,230 --> 00:17:30,720
technically detailed but so so okay

00:17:29,039 --> 00:17:32,789
we're going to improve no blitz why does

00:17:30,720 --> 00:17:34,409
that what does that help us as soon as

00:17:32,789 --> 00:17:36,179
we get people doing this as the default

00:17:34,409 --> 00:17:39,120
or at least making it easier so people

00:17:36,179 --> 00:17:40,980
can choose to do it from the get-go you

00:17:39,120 --> 00:17:43,720
can take advantage of like i said before

00:17:40,980 --> 00:17:46,840
thread pooling passing smart pointers

00:17:43,720 --> 00:17:50,470
set of doing IPC between processes which

00:17:46,840 --> 00:17:52,659
can be slow it also comes up allows you

00:17:50,470 --> 00:17:54,280
to think about some new ideas this one

00:17:52,659 --> 00:17:56,860
is sort of half-baked I sort of came up

00:17:54,280 --> 00:17:59,289
with so it's not fully thought through

00:17:56,860 --> 00:18:01,809
but the idea is that you can create sort

00:17:59,289 --> 00:18:03,610
of a pipeline where you have an input

00:18:01,809 --> 00:18:07,600
topic and an output topic of the same

00:18:03,610 --> 00:18:11,169
type and a call back and so what happens

00:18:07,600 --> 00:18:13,720
is is that some other person publishes a

00:18:11,169 --> 00:18:15,730
message and the system gives you a

00:18:13,720 --> 00:18:17,590
unique pointer of that message and for

00:18:15,730 --> 00:18:18,909
those of you who aren't versed in C++ 11

00:18:17,590 --> 00:18:20,590
terminology and unique pointer is

00:18:18,909 --> 00:18:22,900
basically a scope pointer meaning that

00:18:20,590 --> 00:18:25,150
it's an object that points to something

00:18:22,900 --> 00:18:26,919
in memory and when that object goes out

00:18:25,150 --> 00:18:30,280
of reference it automatically

00:18:26,919 --> 00:18:31,750
automatically deletes that object but

00:18:30,280 --> 00:18:33,280
the other neat trick about them is is

00:18:31,750 --> 00:18:34,600
that you can transfer ownership so if

00:18:33,280 --> 00:18:36,460
you assign a unique pointer to another

00:18:34,600 --> 00:18:38,230
unique pointer the appoint or you're

00:18:36,460 --> 00:18:39,640
assigning from becomes invalid and the

00:18:38,230 --> 00:18:40,809
one you're assigning to becomes valid

00:18:39,640 --> 00:18:43,299
and so in this way you can pass

00:18:40,809 --> 00:18:45,580
ownership of something so before the

00:18:43,299 --> 00:18:47,289
callbacks executed the system owns has

00:18:45,580 --> 00:18:48,760
ownership of the message and then when

00:18:47,289 --> 00:18:50,380
the callback starts executing the

00:18:48,760 --> 00:18:52,720
ownership is owned by the callback the

00:18:50,380 --> 00:18:54,429
callback can mutate the message and then

00:18:52,720 --> 00:18:55,990
return the ownership to the system and

00:18:54,429 --> 00:18:57,940
then the system will publish it for you

00:18:55,990 --> 00:18:59,260
to the outgoing topic and in this way

00:18:57,940 --> 00:19:00,970
you can actually have several these

00:18:59,260 --> 00:19:02,919
chained together and never copy the

00:19:00,970 --> 00:19:05,169
message even in the shared pointer

00:19:02,919 --> 00:19:07,390
system that note let's has you receive

00:19:05,169 --> 00:19:09,220
call backs of a const type so in order

00:19:07,390 --> 00:19:12,429
to modify it and republish it you need

00:19:09,220 --> 00:19:13,390
to copy it first so it's not like I said

00:19:12,429 --> 00:19:15,070
I haven't really thought it through all

00:19:13,390 --> 00:19:16,240
the way but it seems like something that

00:19:15,070 --> 00:19:20,020
you could start doing which is really

00:19:16,240 --> 00:19:21,429
awesome so I just wanted to stop and see

00:19:20,020 --> 00:19:22,900
where we were so that was that was

00:19:21,429 --> 00:19:24,250
pretty in-depth I'm going to be a little

00:19:22,900 --> 00:19:26,380
bit more high-level on the last two

00:19:24,250 --> 00:19:27,520
things here so we're right here we're

00:19:26,380 --> 00:19:30,220
going to talk about dynamic graph

00:19:27,520 --> 00:19:32,830
features so one other really cool thing

00:19:30,220 --> 00:19:34,330
that we've run into several times people

00:19:32,830 --> 00:19:35,770
wanted and systems we're trying to

00:19:34,330 --> 00:19:37,900
design on top of Ross where this would

00:19:35,770 --> 00:19:40,000
be really awesome is the idea of

00:19:37,900 --> 00:19:43,809
remapping or aliasing topics at runtime

00:19:40,000 --> 00:19:46,659
so the idea of for remapping is you say

00:19:43,809 --> 00:19:49,059
I want the camera topic to now be left

00:19:46,659 --> 00:19:50,890
camera for this node and so any

00:19:49,059 --> 00:19:52,780
publishers of subscribers that had for

00:19:50,890 --> 00:19:55,179
that topic camera will now be left

00:19:52,780 --> 00:19:56,500
camera and if it had any connections

00:19:55,179 --> 00:19:57,460
established with camera it would

00:19:56,500 --> 00:19:58,870
disconnect those

00:19:57,460 --> 00:20:01,690
and establish new connections for left

00:19:58,870 --> 00:20:04,630
camera a similar idea is aliasing when

00:20:01,690 --> 00:20:05,890
you say i want camera to be also left

00:20:04,630 --> 00:20:07,270
camera meaning that if it had

00:20:05,890 --> 00:20:09,730
connections with camera it would keep

00:20:07,270 --> 00:20:11,740
them and then any it will establish new

00:20:09,730 --> 00:20:13,990
connections additionally for left camera

00:20:11,740 --> 00:20:17,470
which is a kind of a cool idea which

00:20:13,990 --> 00:20:19,620
which which is similar to sort of

00:20:17,470 --> 00:20:22,240
there's this project with eugene called

00:20:19,620 --> 00:20:24,610
robots in concert where they have this

00:20:22,240 --> 00:20:26,409
idea of exposing topics so you have like

00:20:24,610 --> 00:20:28,120
an internal name for the topic that

00:20:26,409 --> 00:20:30,279
nobody can see and then you can choose

00:20:28,120 --> 00:20:32,260
to expose it in a namespace which i

00:20:30,279 --> 00:20:34,720
think will be a feature that might be

00:20:32,260 --> 00:20:36,580
useful on multi-robot systems so if you

00:20:34,720 --> 00:20:38,559
want to expose the command velocity for

00:20:36,580 --> 00:20:40,390
a robot on the robot it's called command

00:20:38,559 --> 00:20:42,159
velocity but you can also expose it to a

00:20:40,390 --> 00:20:43,510
different part of the system under a

00:20:42,159 --> 00:20:45,460
different name and it's completely

00:20:43,510 --> 00:20:47,289
transparent to the code you write you're

00:20:45,460 --> 00:20:51,820
still just publishing to one thing and

00:20:47,289 --> 00:20:53,380
receiving from one thing so to

00:20:51,820 --> 00:20:55,690
accomplish this basically we would use

00:20:53,380 --> 00:21:00,669
you know nodes would have a default set

00:20:55,690 --> 00:21:04,110
of services which allowed an external

00:21:00,669 --> 00:21:06,610
system to modify the nodes at runtime

00:21:04,110 --> 00:21:08,500
this might currently I'm just thinking

00:21:06,610 --> 00:21:10,960
about for publishers and subscribers but

00:21:08,500 --> 00:21:14,409
obviously it extends somewhat logically

00:21:10,960 --> 00:21:15,730
to services and parameters and so I

00:21:14,409 --> 00:21:16,990
think I think it would be useful for

00:21:15,730 --> 00:21:18,580
development tools and multi-robot

00:21:16,990 --> 00:21:20,380
systems so an example of a developer

00:21:18,580 --> 00:21:22,240
tool that might benefit from this is our

00:21:20,380 --> 00:21:23,590
QT graph you can imagine our QT graph

00:21:22,240 --> 00:21:25,360
where you're looking at your graphs and

00:21:23,590 --> 00:21:27,130
your your nodes in your graph and the

00:21:25,360 --> 00:21:29,380
topics they're talking to and you can

00:21:27,130 --> 00:21:31,090
see oh I forgot to remap this topic on

00:21:29,380 --> 00:21:32,950
this node you can simply select the

00:21:31,090 --> 00:21:34,720
topic you want to remap and which topic

00:21:32,950 --> 00:21:37,179
you want to remap it to and it just does

00:21:34,720 --> 00:21:39,250
it and then when you're done you can say

00:21:37,179 --> 00:21:41,679
give me a configuration diff which will

00:21:39,250 --> 00:21:43,899
allow me to apply this to my you know

00:21:41,679 --> 00:21:46,690
launch configuration so I think that's a

00:21:43,899 --> 00:21:47,890
really powerful feature the other the

00:21:46,690 --> 00:21:49,899
other concept that we've always been

00:21:47,890 --> 00:21:50,679
talking about with Ross too and we've

00:21:49,899 --> 00:21:53,350
been thinking about in more detail

00:21:50,679 --> 00:21:56,320
recently as the lifecycle management of

00:21:53,350 --> 00:21:59,049
nodes so we heard about this a little

00:21:56,320 --> 00:22:01,539
bit with with Ross control and we're

00:21:59,049 --> 00:22:04,120
hoping to make some of these features

00:22:01,539 --> 00:22:07,330
first class in Ross to so that it can be

00:22:04,120 --> 00:22:09,909
reused in things like Ross control but

00:22:07,330 --> 00:22:10,900
the idea is that an Ross one you

00:22:09,909 --> 00:22:12,580
basically have launched

00:22:10,900 --> 00:22:15,100
files and you launch it and if something

00:22:12,580 --> 00:22:17,590
didn't work you close all of them and

00:22:15,100 --> 00:22:19,330
try it again or if you want to know if

00:22:17,590 --> 00:22:21,370
your robots ready it's typically like

00:22:19,330 --> 00:22:22,780
you look for like something to happen on

00:22:21,370 --> 00:22:24,970
the robot or you look at some kind of

00:22:22,780 --> 00:22:26,980
leaf output topic and you hope data is

00:22:24,970 --> 00:22:29,950
coming out of that and not then you have

00:22:26,980 --> 00:22:31,150
to really dig in and so there the point

00:22:29,950 --> 00:22:33,730
I'm getting is there's no real way to

00:22:31,150 --> 00:22:35,470
know once you've run a launch file when

00:22:33,730 --> 00:22:37,180
it's ready or when it's running or if

00:22:35,470 --> 00:22:41,500
it's got a problem or if it's all

00:22:37,180 --> 00:22:43,840
connected or what so a case study of

00:22:41,500 --> 00:22:46,660
this is the capabilities system which is

00:22:43,840 --> 00:22:48,730
in Ross one if any of your interested

00:22:46,660 --> 00:22:51,310
it's got its own wicked arrested or such

00:22:48,730 --> 00:22:52,480
capabilities but this system is

00:22:51,310 --> 00:22:54,580
basically allows you to define

00:22:52,480 --> 00:22:55,930
capabilities for a robot like navigation

00:22:54,580 --> 00:22:58,690
or pick in place or something like that

00:22:55,930 --> 00:23:00,160
and these are basically defined by an

00:22:58,690 --> 00:23:01,630
interface and a launch file which

00:23:00,160 --> 00:23:04,000
implement them and the interface is

00:23:01,630 --> 00:23:08,520
defined in terms of like Ross topics and

00:23:04,000 --> 00:23:10,960
parameters and services and stuff but

00:23:08,520 --> 00:23:12,850
there are a lot of situations where it

00:23:10,960 --> 00:23:14,320
would be really not there's a lot of

00:23:12,850 --> 00:23:16,840
race conditions basically introduced

00:23:14,320 --> 00:23:18,340
where when you launch these things the

00:23:16,840 --> 00:23:20,050
thing that requested for them to be

00:23:18,340 --> 00:23:23,470
launched has no idea when they're

00:23:20,050 --> 00:23:25,120
actually finished launching it is

00:23:23,470 --> 00:23:26,440
especially annoying and like unit tests

00:23:25,120 --> 00:23:28,690
because I'd like to start these things

00:23:26,440 --> 00:23:30,190
and then shut them down again and see

00:23:28,690 --> 00:23:31,510
that there were no exceptions throne but

00:23:30,190 --> 00:23:33,790
i don't know when i can call stopped

00:23:31,510 --> 00:23:36,760
because i don't know when it started

00:23:33,790 --> 00:23:40,660
fully so like there's this problem of

00:23:36,760 --> 00:23:41,950
not being able to get events about the

00:23:40,660 --> 00:23:44,500
state of your system and to get

00:23:41,950 --> 00:23:46,330
aggregate values for the state of your

00:23:44,500 --> 00:23:49,020
system which i think would be really

00:23:46,330 --> 00:23:52,630
valuable especially in products and

00:23:49,020 --> 00:23:56,320
reliable systems so this comes to the

00:23:52,630 --> 00:23:58,390
idea of a verifiable system so you know

00:23:56,320 --> 00:24:00,310
you basically if a node misbehaves you

00:23:58,390 --> 00:24:02,760
just in Ross one you just restart it or

00:24:00,310 --> 00:24:05,740
crash the whole thing and look into it

00:24:02,760 --> 00:24:07,930
in Ross to we're looking at adopting a

00:24:05,740 --> 00:24:09,700
component life cycle as an optional

00:24:07,930 --> 00:24:12,670
thing that you build on top of the basic

00:24:09,700 --> 00:24:16,210
node API and we're looking at like orico

00:24:12,670 --> 00:24:18,730
cesare TT OMG which does dds also has a

00:24:16,210 --> 00:24:22,360
standard called RTC which is implemented

00:24:18,730 --> 00:24:24,280
in open rtm which is pushed mostly by a

00:24:22,360 --> 00:24:26,410
IST in japan

00:24:24,280 --> 00:24:28,990
but both of these have component models

00:24:26,410 --> 00:24:31,390
that we're looking at adapting for use

00:24:28,990 --> 00:24:33,100
in Ross too and you know we're not

00:24:31,390 --> 00:24:34,450
really set on what the states are and

00:24:33,100 --> 00:24:35,830
everything like that but some of the

00:24:34,450 --> 00:24:37,120
goals is we want reliable and

00:24:35,830 --> 00:24:39,430
deterministic notes startup and shutdown

00:24:37,120 --> 00:24:40,630
and we want we want to be able to

00:24:39,430 --> 00:24:42,310
introspect the state of the system we

00:24:40,630 --> 00:24:44,830
want to be able to like run launch file

00:24:42,310 --> 00:24:46,540
and say okay is everything running is

00:24:44,830 --> 00:24:47,620
everything connected or any topics that

00:24:46,540 --> 00:24:52,060
should have been connected that weren't

00:24:47,620 --> 00:24:53,890
things like this and it should work

00:24:52,060 --> 00:24:55,690
regardless of whether you're using the

00:24:53,890 --> 00:24:58,420
nodal at style API talked about before

00:24:55,690 --> 00:25:01,570
or the the you know write your own main

00:24:58,420 --> 00:25:03,940
kind of style and it also brings up this

00:25:01,570 --> 00:25:06,730
idea of my gradable so you know once you

00:25:03,940 --> 00:25:08,710
have the life cycle in place you're able

00:25:06,730 --> 00:25:10,480
to not only introspect the life cycle

00:25:08,710 --> 00:25:14,170
but affect the life cycle externally and

00:25:10,480 --> 00:25:16,690
you have this style of nodal it's where

00:25:14,170 --> 00:25:18,160
you run nodes and then shared process

00:25:16,690 --> 00:25:20,050
you have this idea that you could

00:25:18,160 --> 00:25:22,690
actually my great things so if you had

00:25:20,050 --> 00:25:26,080
let's say you had a a node running in

00:25:22,690 --> 00:25:27,340
its own process and a container running

00:25:26,080 --> 00:25:28,690
some other nodes and you wanted that

00:25:27,340 --> 00:25:30,160
note to be in that process you can

00:25:28,690 --> 00:25:31,930
imagine a graphical tool which allows

00:25:30,160 --> 00:25:33,820
you to say just move this note over

00:25:31,930 --> 00:25:36,580
there and it changes the state of the

00:25:33,820 --> 00:25:41,550
Nodens own process to stopped maybe it

00:25:36,580 --> 00:25:44,080
stores some configuration and it

00:25:41,550 --> 00:25:45,520
launches it in the other process and

00:25:44,080 --> 00:25:47,800
then restores the configuration and goes

00:25:45,520 --> 00:25:51,310
back to running so it's like a live my

00:25:47,800 --> 00:25:52,870
gradable node which again is just a kind

00:25:51,310 --> 00:25:54,940
of a shiny developer tool but it could

00:25:52,870 --> 00:25:56,590
save you a lot of time especially if you

00:25:54,940 --> 00:25:58,480
want to see what it's like like you know

00:25:56,590 --> 00:26:00,610
it's what's the performance different in

00:25:58,480 --> 00:26:03,420
running a note in this process versus

00:26:00,610 --> 00:26:05,920
the other process things like that so

00:26:03,420 --> 00:26:08,110
that's basically all I had to talk about

00:26:05,920 --> 00:26:12,550
but in you know just to recap you know I

00:26:08,110 --> 00:26:14,800
should be excited about Ross two and one

00:26:12,550 --> 00:26:17,350
of the things and I think just having a

00:26:14,800 --> 00:26:19,090
modern API with minimalized dependencies

00:26:17,350 --> 00:26:21,220
and better portability is a huge thing

00:26:19,090 --> 00:26:23,020
like you were going to be using C++ 11

00:26:21,220 --> 00:26:24,820
which is great we're going to have much

00:26:23,020 --> 00:26:26,560
fewer dependencies we hope to cut boost

00:26:24,820 --> 00:26:29,050
as a dependency the current

00:26:26,560 --> 00:26:31,180
implementation only depends on a C++ 11

00:26:29,050 --> 00:26:32,920
compiler and a dds implementation most

00:26:31,180 --> 00:26:36,640
of which don't have any pendant sees

00:26:32,920 --> 00:26:38,260
themselves which will make distributing

00:26:36,640 --> 00:26:41,320
something like a ross sdk much

00:26:38,260 --> 00:26:43,090
more viable you can you know you can and

00:26:41,320 --> 00:26:44,470
shipping things for exotic hardware and

00:26:43,090 --> 00:26:47,640
stuff like that pre compiled binaries

00:26:44,470 --> 00:26:49,480
for that makes it more tractable problem

00:26:47,640 --> 00:26:51,850
you're going to get some benefits from

00:26:49,480 --> 00:26:53,710
dds right out of the box derp talked

00:26:51,850 --> 00:26:56,470
about a bunch of these the ones that i

00:26:53,710 --> 00:26:58,870
think are awesome our UDP multicast is

00:26:56,470 --> 00:27:00,850
automatic when it when it sees that as

00:26:58,870 --> 00:27:03,940
an advantage they all some of them also

00:27:00,850 --> 00:27:08,170
have options for secure communication

00:27:03,940 --> 00:27:10,290
encryption over TLS over tcp/ip it

00:27:08,170 --> 00:27:12,130
allows us to do masterless discovery

00:27:10,290 --> 00:27:13,450
things like this we're going to get a

00:27:12,130 --> 00:27:14,380
lot of benefit from this and we're going

00:27:13,450 --> 00:27:16,270
to be able to spend more of our

00:27:14,380 --> 00:27:18,090
developer time on the robot specific

00:27:16,270 --> 00:27:20,080
features which i think will be great

00:27:18,090 --> 00:27:21,490
we're going to try to make it easier to

00:27:20,080 --> 00:27:23,260
work with multiple nodes in the same

00:27:21,490 --> 00:27:24,910
process which i think is going to allow

00:27:23,260 --> 00:27:27,700
people to write much more efficient code

00:27:24,910 --> 00:27:29,230
especially for like image processing

00:27:27,700 --> 00:27:30,940
algorithms and things like that and

00:27:29,230 --> 00:27:31,740
they're going to be first-class citizens

00:27:30,940 --> 00:27:34,000
there's not going to be any

00:27:31,740 --> 00:27:35,350
differentiation between them and nodes

00:27:34,000 --> 00:27:37,360
in their own process in terms of

00:27:35,350 --> 00:27:40,030
introspect ability or API or anything

00:27:37,360 --> 00:27:42,400
like that we're gonna have some more

00:27:40,030 --> 00:27:43,840
dynamic runtime features lifecycle

00:27:42,400 --> 00:27:45,220
management and so many other things we

00:27:43,840 --> 00:27:47,980
haven't had time to cover here or not

00:27:45,220 --> 00:27:49,630
fully we've not really discussed in a

00:27:47,980 --> 00:27:52,030
design way things like dynamic

00:27:49,630 --> 00:27:54,010
parameters most I think most Ross I

00:27:52,030 --> 00:27:57,310
think the idea is that Ross parameters

00:27:54,010 --> 00:28:00,100
will all be dynamic and owned by nodes

00:27:57,310 --> 00:28:01,690
OB will remove the schism between Ross

00:28:00,100 --> 00:28:04,240
parameters and dynamic reconfigure

00:28:01,690 --> 00:28:05,560
basically we've talked a little bit

00:28:04,240 --> 00:28:08,260
about how we can do synchronous

00:28:05,560 --> 00:28:11,670
execution sort of like how ecto works

00:28:08,260 --> 00:28:15,430
using the asynchronous model because we

00:28:11,670 --> 00:28:17,500
decoupled the code that happens in

00:28:15,430 --> 00:28:19,420
callbacks and the execution of them you

00:28:17,500 --> 00:28:21,280
can you know the naive executors just

00:28:19,420 --> 00:28:22,570
execute things that are ready but you

00:28:21,280 --> 00:28:24,130
could there's no reason you can't have

00:28:22,570 --> 00:28:26,890
an executor with a scheduler that knows

00:28:24,130 --> 00:28:30,220
when to execute what in what order for

00:28:26,890 --> 00:28:31,480
example and more efficient package

00:28:30,220 --> 00:28:33,850
resource management was something dirt

00:28:31,480 --> 00:28:35,140
talked about so with that I'm going to

00:28:33,850 --> 00:28:40,290
yield the rest of the time so we can

00:28:35,140 --> 00:28:40,290
have plenty of questions so that's it

00:28:48,429 --> 00:28:55,600
yeah so so the question was how we're

00:28:53,570 --> 00:28:58,220
going to handle exception handling and

00:28:55,600 --> 00:28:59,780
nodes that share a single process so

00:28:58,220 --> 00:29:01,309
that's a notorious problem and one of

00:28:59,780 --> 00:29:02,780
the main reasons that Rosslyn was

00:29:01,309 --> 00:29:05,210
developed where every node was his own

00:29:02,780 --> 00:29:06,590
process was fault isolation so when it's

00:29:05,210 --> 00:29:07,929
something like a segfault or something

00:29:06,590 --> 00:29:11,690
like that isn't all we can do about it

00:29:07,929 --> 00:29:14,059
typically and so the idea there is that

00:29:11,690 --> 00:29:16,250
we make it so easy to run processes

00:29:14,059 --> 00:29:17,960
either in their own process or together

00:29:16,250 --> 00:29:19,309
that when you do have a problem like

00:29:17,960 --> 00:29:20,990
that you just split everybody in two

00:29:19,309 --> 00:29:22,850
separate processes figure about who had

00:29:20,990 --> 00:29:25,910
the problem and then once you fix it you

00:29:22,850 --> 00:29:29,840
can put them back together again so like

00:29:25,910 --> 00:29:30,950
just raising exceptions yeah so I don't

00:29:29,840 --> 00:29:32,210
know honestly I haven't given a lot of

00:29:30,950 --> 00:29:35,929
thought to that I don't know what the

00:29:32,210 --> 00:29:39,350
other guys think but most likely we can

00:29:35,929 --> 00:29:42,110
do something to prevent exceptions and

00:29:39,350 --> 00:29:43,970
in one node from preventing the

00:29:42,110 --> 00:29:46,250
continued execution of no other nodes in

00:29:43,970 --> 00:29:48,770
the same process I'm not sure how node

00:29:46,250 --> 00:29:51,020
let's handle execute exceptions actually

00:29:48,770 --> 00:29:53,600
I think I think I think even the Ross

00:29:51,020 --> 00:29:55,280
one case could be smarter and not like

00:29:53,600 --> 00:29:57,309
destroy everything when one of the notes

00:29:55,280 --> 00:30:00,440
no let's like throw raises an exception

00:29:57,309 --> 00:30:02,000
just catching that one giving you the

00:30:00,440 --> 00:30:03,799
error message but continued would

00:30:02,000 --> 00:30:07,390
probably be the smarter way but that

00:30:03,799 --> 00:30:07,390
would also be possible in Ross one just

00:30:13,470 --> 00:30:18,460
yes no but the note let management

00:30:16,390 --> 00:30:22,320
manager could actually catch like any

00:30:18,460 --> 00:30:39,340
exceptions but nobody implemented that

00:30:22,320 --> 00:30:40,570
polycrystal welcome that that was the

00:30:39,340 --> 00:30:42,340
other thing I was going to say before I

00:30:40,570 --> 00:30:44,260
we get distracted is that with the

00:30:42,340 --> 00:30:45,760
lifecycle management we can we can we

00:30:44,260 --> 00:30:47,559
have a will probably have a recovery

00:30:45,760 --> 00:30:52,020
state for exceptions normal exceptions

00:30:47,559 --> 00:30:52,020
yeah yeah go ahead

00:31:18,160 --> 00:31:23,530
yeah so so I didn't enter so the summary

00:31:22,030 --> 00:31:25,720
of the question was we talked about

00:31:23,530 --> 00:31:27,910
briefly we mentioned the idea that we

00:31:25,720 --> 00:31:30,100
could do because we decoupled the

00:31:27,910 --> 00:31:31,810
callbacks and the execution model that

00:31:30,100 --> 00:31:33,490
we could do executors with schedulers

00:31:31,810 --> 00:31:36,160
and then the question was will the

00:31:33,490 --> 00:31:37,660
schedulers have options like what kind

00:31:36,160 --> 00:31:40,600
of synchronization that's the method you

00:31:37,660 --> 00:31:42,490
use the answer short answer is yes so

00:31:40,600 --> 00:31:45,040
the concept I didn't introduce here is a

00:31:42,490 --> 00:31:46,480
concept of an executor and so under the

00:31:45,040 --> 00:31:48,400
hood and all of these examples is this

00:31:46,480 --> 00:31:50,650
executor class which you can register

00:31:48,400 --> 00:31:52,150
nodes with and then call different and

00:31:50,650 --> 00:31:53,470
there's and then call it basically spin

00:31:52,150 --> 00:31:54,940
on it and there's different kinds of

00:31:53,470 --> 00:31:56,500
executors and you can implement your own

00:31:54,940 --> 00:31:59,110
executor that does just absolutely

00:31:56,500 --> 00:32:00,760
anything so we may provide some

00:31:59,110 --> 00:32:02,290
out-of-the-box but at the very least

00:32:00,760 --> 00:32:03,130
we're trying to design in a way that if

00:32:02,290 --> 00:32:06,030
you want to do something different

00:32:03,130 --> 00:32:06,030
that's totally possible

00:32:20,570 --> 00:32:24,950
so the question is that there's been

00:32:23,360 --> 00:32:26,690
some concern about the usability of Ross

00:32:24,950 --> 00:32:28,279
moving forward keeps any more and more

00:32:26,690 --> 00:32:30,529
complicated larger learning curve I

00:32:28,279 --> 00:32:31,639
guess is what what is implied there and

00:32:30,529 --> 00:32:35,570
what we're gonna try to do about it in

00:32:31,639 --> 00:32:37,759
Ross to I guess the best explanation I

00:32:35,570 --> 00:32:39,230
can have is that we're not going to well

00:32:37,759 --> 00:32:40,460
the first thing is not make it worse so

00:32:39,230 --> 00:32:42,019
we're trying to minimize the number of

00:32:40,460 --> 00:32:44,539
concepts that you have to know in order

00:32:42,019 --> 00:32:46,159
to get started in ross and so to that

00:32:44,539 --> 00:32:47,539
end callback groups or optional

00:32:46,159 --> 00:32:49,399
executors are optional there's a new

00:32:47,539 --> 00:32:51,110
features that are some in some ways

00:32:49,399 --> 00:32:53,480
represented in Ross one that most people

00:32:51,110 --> 00:32:55,100
don't know about in terms of improving

00:32:53,480 --> 00:32:56,480
the usability I think one of the things

00:32:55,100 --> 00:32:58,970
we can do is that there are a lot of

00:32:56,480 --> 00:33:01,460
things in Ross one that were added after

00:32:58,970 --> 00:33:02,750
the initial design which caused them to

00:33:01,460 --> 00:33:04,100
be more complicated and they have to be

00:33:02,750 --> 00:33:08,059
a good example of this is dynamic

00:33:04,100 --> 00:33:10,519
reconfigure so by simple commonly find

00:33:08,059 --> 00:33:12,769
useful that are currently tacked on top

00:33:10,519 --> 00:33:16,730
into first class citizens we can make

00:33:12,769 --> 00:33:17,990
things simpler yeah actions for example

00:33:16,730 --> 00:33:19,639
actions will be a first class citizen

00:33:17,990 --> 00:33:24,580
instead of something implemented on top

00:33:19,639 --> 00:33:24,580
I don't know if that answers everything

00:33:42,269 --> 00:33:47,549
so the question is given the limited

00:33:45,330 --> 00:33:50,879
resources we have how do we intend to

00:33:47,549 --> 00:33:53,129
rally the community to to work on

00:33:50,879 --> 00:33:55,589
basically porting stuff from rosslyn to

00:33:53,129 --> 00:33:59,969
Ross to as I essentially the question so

00:33:55,589 --> 00:34:02,759
I guess my thought on this is that you

00:33:59,969 --> 00:34:04,709
know with or without us Ross Ross to

00:34:02,759 --> 00:34:06,149
don't succeed it requires that people in

00:34:04,709 --> 00:34:07,499
the community are invested in these

00:34:06,149 --> 00:34:10,230
ideas and they're willing to spend time

00:34:07,499 --> 00:34:12,359
on it that the best thing we can do in

00:34:10,230 --> 00:34:14,159
my opinion is provide these core

00:34:12,359 --> 00:34:15,899
technologies and the infrastructure from

00:34:14,159 --> 00:34:17,789
in which the community can operate and

00:34:15,899 --> 00:34:20,460
in terms of what we're going to do to

00:34:17,789 --> 00:34:22,859
try to drive people into using Ross to

00:34:20,460 --> 00:34:25,079
and moving stuff is we want to

00:34:22,859 --> 00:34:26,940
demonstrate that Ross to is worth their

00:34:25,079 --> 00:34:29,129
time and better I don't know if any

00:34:26,940 --> 00:34:32,639
other people have other other feedback

00:34:29,129 --> 00:34:35,250
and as William show them the example to

00:34:32,639 --> 00:34:37,200
besides having the new client library

00:34:35,250 --> 00:34:39,809
with an API always think that's how we

00:34:37,200 --> 00:34:42,809
imagined it to be they will very likely

00:34:39,809 --> 00:34:44,730
be probably a secondary API which

00:34:42,809 --> 00:34:47,220
strives to be like as close as possible

00:34:44,730 --> 00:34:49,909
to Ross 12 if you want to do the

00:34:47,220 --> 00:34:53,149
transition that it will be like as

00:34:49,909 --> 00:34:53,149
smooth as possible

00:35:00,470 --> 00:35:06,740
yeah so yeah so I guess I guess the cat

00:35:03,839 --> 00:35:09,089
can roll out is it made us a little bit

00:35:06,740 --> 00:35:11,280
disruption at verse so that's why we

00:35:09,089 --> 00:35:13,170
chose I think personally that's why we

00:35:11,280 --> 00:35:14,910
chose to do Ross to is like a separate

00:35:13,170 --> 00:35:16,859
but equal project until it's mature

00:35:14,910 --> 00:35:18,599
enough because just continuously

00:35:16,859 --> 00:35:20,339
disrupting the rosslyn system by

00:35:18,599 --> 00:35:22,710
incrementally putting these improvements

00:35:20,339 --> 00:35:25,560
in I think would be really disruptive so

00:35:22,710 --> 00:35:27,119
I think that people being able to choose

00:35:25,560 --> 00:35:29,010
when they think Ross to is mature enough

00:35:27,119 --> 00:35:31,410
and move over all at once is better than

00:35:29,010 --> 00:35:33,859
just iteratively rolling out things in

00:35:31,410 --> 00:35:33,859
rosslyn

00:35:57,610 --> 00:36:04,400
yeah so the question is we mentioned

00:36:00,680 --> 00:36:06,230
that there will be a capi for us too and

00:36:04,400 --> 00:36:07,970
what does that mean for the client

00:36:06,230 --> 00:36:11,420
libraries are they going to be native or

00:36:07,970 --> 00:36:13,700
wrapping bindings of that I guess my my

00:36:11,420 --> 00:36:16,280
intention with the capi is that it gives

00:36:13,700 --> 00:36:17,600
you the choice so the first thing you'll

00:36:16,280 --> 00:36:19,330
need if you want to do a native

00:36:17,600 --> 00:36:21,980
implementation will be a dds

00:36:19,330 --> 00:36:23,420
implementation now there exists zdf

00:36:21,980 --> 00:36:26,240
limitations for many other languages

00:36:23,420 --> 00:36:27,710
other than C and C++ mostly Java and C

00:36:26,240 --> 00:36:30,200
sharp so if you choose to go that way

00:36:27,710 --> 00:36:32,360
you can but i think the capi is just

00:36:30,200 --> 00:36:36,110
another option and i think probably ross

00:36:32,360 --> 00:36:38,870
perot will use will wrap as bindings the

00:36:36,110 --> 00:36:41,120
capi simply because it minimizes the

00:36:38,870 --> 00:36:42,650
amount of duplication of effort for us

00:36:41,120 --> 00:36:44,360
because we'll probably maintain both of

00:36:42,650 --> 00:36:48,110
them and it'll produce a more consistent

00:36:44,360 --> 00:36:49,520
result between Python and C++ but again

00:36:48,110 --> 00:36:51,920
I think it you know there are pros and

00:36:49,520 --> 00:36:54,860
cons to doing a native verse wrapping

00:36:51,920 --> 00:36:56,540
bindings so I think it'll be up to the

00:36:54,860 --> 00:36:58,960
people developing that and their

00:36:56,540 --> 00:36:58,960
preference

00:37:11,789 --> 00:37:17,440
the question is we mentioned that dds

00:37:15,339 --> 00:37:19,479
does not need a master to do discovery

00:37:17,440 --> 00:37:21,309
and what does that imply with multi

00:37:19,479 --> 00:37:26,859
master multi-robot situations is that

00:37:21,309 --> 00:37:28,809
correct okay so basically I think what

00:37:26,859 --> 00:37:30,789
that means for us is that we have a

00:37:28,809 --> 00:37:33,339
whole lot of new features that dds has

00:37:30,789 --> 00:37:36,069
to try to support this in fact talking

00:37:33,339 --> 00:37:37,420
with the DDS companies they when we

00:37:36,069 --> 00:37:39,009
talked about them with the multi-robot

00:37:37,420 --> 00:37:40,710
situation and they have their own ideas

00:37:39,009 --> 00:37:43,150
about how dds could service that need

00:37:40,710 --> 00:37:44,769
and we will probably try to figure out

00:37:43,150 --> 00:37:46,119
which one's of those capabilities are

00:37:44,769 --> 00:37:48,940
most important for that and expose it

00:37:46,119 --> 00:37:52,869
through the Ross API but in my mind the

00:37:48,940 --> 00:37:54,369
multi-robot situation is is is that it

00:37:52,869 --> 00:37:55,720
hasn't been there's no like silver

00:37:54,369 --> 00:37:57,729
bullet that we've discovered for that

00:37:55,720 --> 00:38:00,430
and depending on your use case there's

00:37:57,729 --> 00:38:02,739
different best solutions so they the

00:38:00,430 --> 00:38:03,789
best thing we can do is make the stuff

00:38:02,739 --> 00:38:05,529
you would use to implement those

00:38:03,789 --> 00:38:07,269
solutions as flexible as possible so

00:38:05,529 --> 00:38:09,190
like Eugene has been working pretty hard

00:38:07,269 --> 00:38:10,719
to do a multi robot system on Ross one

00:38:09,190 --> 00:38:13,559
and there are just some fundamental

00:38:10,719 --> 00:38:15,640
parts about the way the Ross one

00:38:13,559 --> 00:38:17,499
middleware works that makes it difficult

00:38:15,640 --> 00:38:19,660
for them to accomplish that and I just I

00:38:17,499 --> 00:38:21,339
think the best thing we can view rather

00:38:19,660 --> 00:38:22,809
than deciding on this is the best way to

00:38:21,339 --> 00:38:24,910
do it so its way we're going to do it is

00:38:22,809 --> 00:38:26,460
to just give everybody the tools they

00:38:24,910 --> 00:38:29,019
need to do it the way they think is best

00:38:26,460 --> 00:38:31,420
that being said I think if we if we can

00:38:29,019 --> 00:38:33,519
just decide on a good reasonable default

00:38:31,420 --> 00:38:37,989
way to do multi map multi-robot systems

00:38:33,519 --> 00:38:39,849
we can add constructs for that so well

00:38:37,989 --> 00:38:42,269
yeah so dds has features like partitions

00:38:39,849 --> 00:38:42,269
yeah

00:38:48,160 --> 00:38:54,950
the question is how old DDS encryption

00:38:51,200 --> 00:38:58,730
effect Ross api's um the answer is I

00:38:54,950 --> 00:39:00,680
don't know my naive assumption is is

00:38:58,730 --> 00:39:01,880
that you can write Ross code agnostic to

00:39:00,680 --> 00:39:03,440
whether it's being sent over encrypted

00:39:01,880 --> 00:39:04,760
channels and that's like a global

00:39:03,440 --> 00:39:08,780
configuration for your dds

00:39:04,760 --> 00:39:12,470
implementation but I don't know honestly

00:39:08,780 --> 00:39:14,570
I don't know so so even our prototype

00:39:12,470 --> 00:39:16,550
conley does not support obviously all

00:39:14,570 --> 00:39:18,890
the features of BDS because we just

00:39:16,550 --> 00:39:21,110
didn't have the use cases yet but even

00:39:18,890 --> 00:39:22,400
without specific from support for

00:39:21,110 --> 00:39:24,950
certain quality of service parameters

00:39:22,400 --> 00:39:27,320
usually you can configure them in the

00:39:24,950 --> 00:39:28,820
vendor specific way so I could imagine

00:39:27,320 --> 00:39:31,580
that we could run our talk and listen

00:39:28,820 --> 00:39:34,100
example and use if it's using RTI for

00:39:31,580 --> 00:39:35,840
example change the configuration of

00:39:34,100 --> 00:39:37,430
connects in a way that it does use

00:39:35,840 --> 00:39:40,250
encryption authorization and

00:39:37,430 --> 00:39:50,930
authentication which is then transparent

00:39:40,250 --> 00:39:53,420
to our high level our API the question

00:39:50,930 --> 00:39:55,880
is if dds is so amazing and awesome why

00:39:53,420 --> 00:39:59,720
do we need Ross API on top of it and the

00:39:55,880 --> 00:40:02,900
answer is is that the dds api is vast

00:39:59,720 --> 00:40:04,580
and complicated and i think this is one

00:40:02,900 --> 00:40:06,260
of the main reasons that it hasn't got a

00:40:04,580 --> 00:40:08,890
large adoption and universities and

00:40:06,260 --> 00:40:12,140
hobbyist is because one it's difficult

00:40:08,890 --> 00:40:13,160
to get until recently last like last two

00:40:12,140 --> 00:40:14,540
years it's been difficult get a good

00:40:13,160 --> 00:40:17,180
reference implementation that's open

00:40:14,540 --> 00:40:19,670
source and and the other part is that

00:40:17,180 --> 00:40:21,140
it's complicated and when you first look

00:40:19,670 --> 00:40:23,090
at it you think it's unnecessarily

00:40:21,140 --> 00:40:24,500
complicated but as you continue to use

00:40:23,090 --> 00:40:26,540
it you realize that all the pieces have

00:40:24,500 --> 00:40:28,850
a purpose it's just that most of those

00:40:26,540 --> 00:40:31,100
purposes are very narrow corner cases

00:40:28,850 --> 00:40:33,380
that we don't need a support so we put

00:40:31,100 --> 00:40:35,000
our AP on top to make it easy to get

00:40:33,380 --> 00:40:37,910
into and easier for novice programmers

00:40:35,000 --> 00:40:39,590
and expose some of the functionality

00:40:37,910 --> 00:40:41,980
that they provide to power users in a

00:40:39,590 --> 00:40:41,980
different way

00:41:05,410 --> 00:41:10,990
so the question is do we plan to add

00:41:08,620 --> 00:41:13,060
things to Ross to to make development of

00:41:10,990 --> 00:41:15,190
you I interfaces for robots easier and

00:41:13,060 --> 00:41:16,780
particularly I think you imagine user

00:41:15,190 --> 00:41:20,410
interfaces and not developer user

00:41:16,780 --> 00:41:22,900
interfaces like developer tools consumer

00:41:20,410 --> 00:41:24,520
interfaces I don't think we have any

00:41:22,900 --> 00:41:27,430
plans to do that currently I mean we

00:41:24,520 --> 00:41:28,870
could potentially it's just not on my

00:41:27,430 --> 00:41:30,700
scope right now I think there's a need

00:41:28,870 --> 00:41:32,320
for that eventually but that's one of

00:41:30,700 --> 00:41:35,020
those final polishing things you do

00:41:32,320 --> 00:41:37,360
after you have the core tools the

00:41:35,020 --> 00:41:40,690
developer tools and the like robot

00:41:37,360 --> 00:41:43,060
components default robot components so

00:41:40,690 --> 00:41:59,920
i'm not sure i guess i don't know if

00:41:43,060 --> 00:42:10,840
other people have another we take pull

00:41:59,920 --> 00:42:13,390
requests yeah so so the question is is

00:42:10,840 --> 00:42:15,490
there going to be he basically +1 the

00:42:13,390 --> 00:42:17,710
idea of a ross 1 headers that implement

00:42:15,490 --> 00:42:19,900
the ross one API built on top of the

00:42:17,710 --> 00:42:22,150
ross to implementation and maybe

00:42:19,900 --> 00:42:24,670
automatic code conversion in order to

00:42:22,150 --> 00:42:26,170
support the Hercule and effort to

00:42:24,670 --> 00:42:28,600
convert like all the packages in indigo

00:42:26,170 --> 00:42:30,280
to ross to so i think we'll do whatever

00:42:28,600 --> 00:42:31,330
makes sense if the iop eyes are close

00:42:30,280 --> 00:42:33,070
enough we could do some kind of

00:42:31,330 --> 00:42:34,960
automation tool like like I said the

00:42:33,070 --> 00:42:37,060
example I showed it's actually really

00:42:34,960 --> 00:42:39,280
trivial to convert the Ross one an

00:42:37,060 --> 00:42:40,690
example you basically move the node name

00:42:39,280 --> 00:42:41,740
to the construction of the node and pass

00:42:40,690 --> 00:42:44,590
the node to spend it's really

00:42:41,740 --> 00:42:46,180
straightforward but even that could be

00:42:44,590 --> 00:42:47,620
challenging to automate I don't know

00:42:46,180 --> 00:42:50,020
it's something we can look into for the

00:42:47,620 --> 00:42:51,820
Ross one API headers I think it's

00:42:50,020 --> 00:42:53,500
totally possible to do that my concern

00:42:51,820 --> 00:42:56,050
is is that it will work but not as you

00:42:53,500 --> 00:42:58,750
expect like they'll like like the api's

00:42:56,050 --> 00:43:00,580
match and the ideas match but the topics

00:42:58,750 --> 00:43:02,050
may behave differently and for simple

00:43:00,580 --> 00:43:04,030
programs that may be totally fine but

00:43:02,050 --> 00:43:06,940
for more complicated things like move

00:43:04,030 --> 00:43:09,550
base or the RV's you're probably almost

00:43:06,940 --> 00:43:13,440
guaranteed to run into kwality vishu

00:43:09,550 --> 00:43:13,440
'he's that don't line up

00:43:13,720 --> 00:43:26,530
TF all over again ah yes yeah so it's

00:43:22,340 --> 00:43:26,530
true all right let's

00:43:33,029 --> 00:43:35,089
you

00:43:38,270 --> 00:43:40,330

YouTube URL: https://www.youtube.com/watch?v=6IUNm8bc5Zs


