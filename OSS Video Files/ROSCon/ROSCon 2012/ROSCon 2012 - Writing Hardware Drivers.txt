Title: ROSCon 2012 - Writing Hardware Drivers
Publication date: 2014-08-31
Playlist: ROSCon 2012
Description: 
	Chad Rockey
Writing Hardware Drivers

Slides: https://docs.google.com/presentation/d/13yyOB5CXOzpvMa0_wYxDvNzjb_9dfMjDuVo-CvBcoRw/edit
Captions: 
	00:00:06,009 --> 00:00:11,860
hello welcome back hope you enjoyed your

00:00:08,740 --> 00:00:14,500
lunch this is the afternoon session we

00:00:11,860 --> 00:00:16,869
got to talks one on writing hardware

00:00:14,500 --> 00:00:18,820
drivers and one on the connect I'm going

00:00:16,869 --> 00:00:32,320
to start with the Chad on writing

00:00:18,820 --> 00:00:33,880
hardware drivers hi everyone so often in

00:00:32,320 --> 00:00:37,030
the first place you get to after you

00:00:33,880 --> 00:00:38,950
look at the boss tutorials is I want to

00:00:37,030 --> 00:00:40,930
put my robot in Ross or you have a

00:00:38,950 --> 00:00:43,480
collection of hardware so I figured this

00:00:40,930 --> 00:00:45,430
is a good introduction for what to do

00:00:43,480 --> 00:00:48,970
next and how to bring your hardware into

00:00:45,430 --> 00:00:51,040
Ross so first a little about me I'm a

00:00:48,970 --> 00:00:52,989
robotics engineer at Carnegie Mellon's

00:00:51,040 --> 00:00:56,050
national robotics Engineering Center

00:00:52,989 --> 00:00:58,720
I am also a Ross driver maintainer for

00:00:56,050 --> 00:01:02,230
laser drivers so the sick and Hoku yos

00:00:58,720 --> 00:01:04,989
and I am your drivers and occasionally I

00:01:02,230 --> 00:01:07,930
even write stuff I've written to Android

00:01:04,989 --> 00:01:11,369
apps the Android sensors driver and that

00:01:07,930 --> 00:01:14,259
currently supports GPS and full IMU and

00:01:11,369 --> 00:01:16,090
the android robot monitor which reports

00:01:14,259 --> 00:01:23,439
diagnostics which we'll talk about later

00:01:16,090 --> 00:01:25,799
on to your Android phone so I'm gonna go

00:01:23,439 --> 00:01:28,959
through five steps starting your driver

00:01:25,799 --> 00:01:31,590
writing the standalone library writing a

00:01:28,959 --> 00:01:36,459
Ross wrapper dynamic reconfigure and

00:01:31,590 --> 00:01:37,840
diagnostics so the first thing that you

00:01:36,459 --> 00:01:38,979
should do when starting your driver is

00:01:37,840 --> 00:01:40,869
make sure that you're not repeating

00:01:38,979 --> 00:01:42,340
anyone else's work or that there isn't

00:01:40,869 --> 00:01:44,889
something similar that you can work

00:01:42,340 --> 00:01:47,049
together with someone on so you should

00:01:44,889 --> 00:01:49,959
first search the Ross wiki and if you

00:01:47,049 --> 00:01:53,229
find there's especially a good list of

00:01:49,959 --> 00:01:55,119
drivers here at wiki slash sensors I

00:01:53,229 --> 00:01:58,029
think it's we try to keep it up to date

00:01:55,119 --> 00:01:59,679
and you can also search on Ross answers

00:01:58,029 --> 00:02:02,349
to see if anyone has asked for that

00:01:59,679 --> 00:02:04,240
particular piece of hardware and if no

00:02:02,349 --> 00:02:06,219
one has you can even ask because

00:02:04,240 --> 00:02:09,849
sometimes people don't publish things

00:02:06,219 --> 00:02:12,490
too and if you do find an existing

00:02:09,849 --> 00:02:14,620
driver you it's usually best to

00:02:12,490 --> 00:02:16,510
collaborate to make one common code base

00:02:14,620 --> 00:02:18,730
with multiple efforts rather than

00:02:16,510 --> 00:02:23,770
multiple smaller

00:02:18,730 --> 00:02:25,239
drivers with fewer features so one of

00:02:23,770 --> 00:02:26,770
the first things you should do is decide

00:02:25,239 --> 00:02:29,140
your language and platform for your

00:02:26,770 --> 00:02:30,790
drivers so Ross has different

00:02:29,140 --> 00:02:33,819
programming languages that it supports

00:02:30,790 --> 00:02:36,400
one of them the first one is Ross CPP

00:02:33,819 --> 00:02:40,480
which uses C++ this is the

00:02:36,400 --> 00:02:42,610
high-performance library and I primarily

00:02:40,480 --> 00:02:45,010
use it on Linux but I understand that it

00:02:42,610 --> 00:02:47,230
has some OS 10 and windows support and

00:02:45,010 --> 00:02:50,010
it also currently has the best

00:02:47,230 --> 00:02:54,430
diagnostic support and is the most diet

00:02:50,010 --> 00:02:57,519
documented Ross PI is a prototype and

00:02:54,430 --> 00:03:01,780
easy to use language it also recently

00:02:57,519 --> 00:03:03,519
got Diagnostics support which is a set

00:03:01,780 --> 00:03:06,280
of assistant libraries that can help you

00:03:03,519 --> 00:03:09,850
and we'll talk about that later in it

00:03:06,280 --> 00:03:11,709
again is Linux and some Mac Windows one

00:03:09,850 --> 00:03:13,690
of my favorite newer languages is Ross

00:03:11,709 --> 00:03:16,510
Java which we heard about yesterday and

00:03:13,690 --> 00:03:18,910
that's written in pure Java with Android

00:03:16,510 --> 00:03:21,370
support and so I was able to produce

00:03:18,910 --> 00:03:23,799
those apps and then for completeness

00:03:21,370 --> 00:03:26,890
there's also Ross Lisp and lot Ross Lua

00:03:23,799 --> 00:03:28,239
I have never worked with these but if

00:03:26,890 --> 00:03:32,040
for some reason you have existing

00:03:28,239 --> 00:03:34,450
drivers you may want to look into them

00:03:32,040 --> 00:03:36,970
so they're these things called Ross

00:03:34,450 --> 00:03:39,489
enhancement proposals and these are sort

00:03:36,970 --> 00:03:41,920
of standards or collections of good

00:03:39,489 --> 00:03:43,780
ideas that we've documented and put out

00:03:41,920 --> 00:03:47,730
and there are a lot of these that are

00:03:43,780 --> 00:03:50,290
that are relevant to hardware drivers so

00:03:47,730 --> 00:03:52,600
one of the most important ones for me is

00:03:50,290 --> 00:03:55,840
standards of unit and measure and

00:03:52,600 --> 00:03:58,090
coordinate conventions because if your

00:03:55,840 --> 00:03:59,680
driver reports in a wrong frame that can

00:03:58,090 --> 00:04:02,920
be very confusing for the rest of Ross

00:03:59,680 --> 00:04:05,680
so these sorts of things document the

00:04:02,920 --> 00:04:08,260
best practices so you have units of

00:04:05,680 --> 00:04:09,840
measure camera info for camera

00:04:08,260 --> 00:04:13,859
calibrations and intrinsics

00:04:09,840 --> 00:04:16,239
coordinate frames diagnostic systems

00:04:13,859 --> 00:04:18,370
informational distance measurements so

00:04:16,239 --> 00:04:21,070
what to do when you can't report a

00:04:18,370 --> 00:04:22,979
measurement depth images for sensors

00:04:21,070 --> 00:04:25,630
like the Kinect or stereo cameras and

00:04:22,979 --> 00:04:31,479
coordinate frames for human robots for

00:04:25,630 --> 00:04:32,330
the driver for your humanoid so the next

00:04:31,479 --> 00:04:35,360
step that you

00:04:32,330 --> 00:04:37,190
do is to decide your Ross API so these

00:04:35,360 --> 00:04:39,710
are things like your topics your

00:04:37,190 --> 00:04:41,120
messages your services what you need to

00:04:39,710 --> 00:04:42,530
take in from the system and what you

00:04:41,120 --> 00:04:45,680
need to provide to the rest of the

00:04:42,530 --> 00:04:48,020
system so the best place to look here is

00:04:45,680 --> 00:04:50,990
in standard messages common messages and

00:04:48,020 --> 00:04:54,319
standard services these are packages

00:04:50,990 --> 00:04:57,139
that contain the most widely-used api's

00:04:54,319 --> 00:04:59,030
and messages for Ross so you'll see

00:04:57,139 --> 00:05:01,699
things like geometry messages nav

00:04:59,030 --> 00:05:04,190
messages sensor messages so these are

00:05:01,699 --> 00:05:07,190
your laser scans your point clouds your

00:05:04,190 --> 00:05:09,560
Adama trees these are all API reviewed

00:05:07,190 --> 00:05:12,500
and they're the best interface between

00:05:09,560 --> 00:05:15,650
your driver and your clients for

00:05:12,500 --> 00:05:17,539
configuration you have a few options you

00:05:15,650 --> 00:05:20,449
can use parameters through the parameter

00:05:17,539 --> 00:05:22,490
server or if you want a next better step

00:05:20,449 --> 00:05:24,949
you can use dynamic reconfigure which

00:05:22,490 --> 00:05:29,960
we'll talk about later and then finally

00:05:24,949 --> 00:05:32,240
you should use Diagnostics so here's an

00:05:29,960 --> 00:05:34,819
example API this is one of the more

00:05:32,240 --> 00:05:37,639
complicated ones for cameras there are

00:05:34,819 --> 00:05:40,219
two assistant libraries here ones called

00:05:37,639 --> 00:05:43,940
image transport and ones called image

00:05:40,219 --> 00:05:46,460
camera info manager so image transport

00:05:43,940 --> 00:05:49,580
publishes a set of synchronized messages

00:05:46,460 --> 00:05:53,300
between sensor images and sensor camera

00:05:49,580 --> 00:05:55,940
info and what this does is on the topics

00:05:53,300 --> 00:05:58,340
image raw and camera info it publishes

00:05:55,940 --> 00:06:04,279
the synchronize sets for you and it also

00:05:58,340 --> 00:06:06,020
includes helpful things like the pointer

00:06:04,279 --> 00:06:08,150
versions that you can use so that you

00:06:06,020 --> 00:06:12,259
can put this image transport directly

00:06:08,150 --> 00:06:15,110
into a node lit and then camera info

00:06:12,259 --> 00:06:17,719
manager is an API that lets you use the

00:06:15,110 --> 00:06:20,360
calibration tool and then just hit the

00:06:17,719 --> 00:06:22,219
send camera info and then your driver

00:06:20,360 --> 00:06:23,870
over a service receives the new

00:06:22,219 --> 00:06:26,150
intrinsics and immediately begins

00:06:23,870 --> 00:06:27,440
publishing them over the wire this is

00:06:26,150 --> 00:06:29,150
helpful so that you can immediately

00:06:27,440 --> 00:06:31,340
check the quality of your calibration

00:06:29,150 --> 00:06:33,919
without having to bring down your driver

00:06:31,340 --> 00:06:36,110
and bring it back up not all drivers

00:06:33,919 --> 00:06:39,259
have to have this complicated of an API

00:06:36,110 --> 00:06:43,669
but for cameras it was a pretty good

00:06:39,259 --> 00:06:45,090
choice so we can review here so let's

00:06:43,669 --> 00:06:47,120
say as there is

00:06:45,090 --> 00:06:50,520
now there's a new model for Kuya laser

00:06:47,120 --> 00:06:52,139
so are there similar drivers what

00:06:50,520 --> 00:06:54,510
languages and platforms would we like to

00:06:52,139 --> 00:06:59,699
support and what messages should we use

00:06:54,510 --> 00:07:03,120
so right now as far as I'm aware the

00:06:59,699 --> 00:07:05,580
there's the who Kuya node and the urg

00:07:03,120 --> 00:07:09,600
widget and the who Kuya node supports

00:07:05,580 --> 00:07:11,220
the older who use on USB and the urg

00:07:09,600 --> 00:07:13,110
widget actually supports the newer

00:07:11,220 --> 00:07:14,850
networked ones which is a good place to

00:07:13,110 --> 00:07:17,660
start for the newer model if you're

00:07:14,850 --> 00:07:20,970
looking to quickly prototype for tests

00:07:17,660 --> 00:07:26,250
these are both can be supported in Ross

00:07:20,970 --> 00:07:28,979
CPP and you can see Linux and then maybe

00:07:26,250 --> 00:07:30,690
Mac and Windows support the messages

00:07:28,979 --> 00:07:32,880
that we would use for this would be

00:07:30,690 --> 00:07:36,300
sensor messages laser scan since this is

00:07:32,880 --> 00:07:41,070
a planar 2d scanner and diagnostics for

00:07:36,300 --> 00:07:43,470
reporting the status of the driver so

00:07:41,070 --> 00:07:46,410
another common one that people run into

00:07:43,470 --> 00:07:49,860
is your in-house mobile platform so this

00:07:46,410 --> 00:07:53,070
is your base your motors maybe some

00:07:49,860 --> 00:07:55,380
wheel encoders what do you do here so

00:07:53,070 --> 00:07:57,600
we'll look for similar drivers again a

00:07:55,380 --> 00:08:02,160
language and platform and what message

00:07:57,600 --> 00:08:04,470
is that likely we should use so similar

00:08:02,160 --> 00:08:07,410
ones are of course the turtle bot which

00:08:04,470 --> 00:08:11,220
is one of the standard where do I look

00:08:07,410 --> 00:08:13,740
for a good example platform and pioneer

00:08:11,220 --> 00:08:15,810
also has a pretty good example of how to

00:08:13,740 --> 00:08:18,780
take existing hardware and move it in

00:08:15,810 --> 00:08:21,000
the Ross the language and platform is

00:08:18,780 --> 00:08:23,729
your choice since this is your platform

00:08:21,000 --> 00:08:25,500
and the messages that come from this

00:08:23,729 --> 00:08:28,710
tend to be pretty low bandwidth so

00:08:25,500 --> 00:08:33,630
performance you don't need to worry too

00:08:28,710 --> 00:08:37,289
much about that and as for the messages

00:08:33,630 --> 00:08:40,169
the common API is to use on command Bell

00:08:37,289 --> 00:08:43,650
a geometry messages twist which has

00:08:40,169 --> 00:08:46,230
velocities and angular velocities and uh

00:08:43,650 --> 00:08:48,120
no DOM and nav messages odometry and

00:08:46,230 --> 00:08:50,910
this is where your wheel encoders would

00:08:48,120 --> 00:08:52,260
be fused and you would report how far

00:08:50,910 --> 00:08:54,150
you've traveled and your current

00:08:52,260 --> 00:08:57,810
rotation relative to where you started

00:08:54,150 --> 00:09:00,820
and of course diagnostics again

00:08:57,810 --> 00:09:02,709
so the next step is once you've decided

00:09:00,820 --> 00:09:08,350
how you're going to write your library

00:09:02,709 --> 00:09:09,970
and put it in Ross is to do so so one

00:09:08,350 --> 00:09:11,529
question that I had when I started

00:09:09,970 --> 00:09:14,170
writing Ross drivers was why would I

00:09:11,529 --> 00:09:16,709
write a standalone library I just want

00:09:14,170 --> 00:09:19,839
to get it in Ross quickly and be done

00:09:16,709 --> 00:09:21,940
but if there's ever a chance for anyone

00:09:19,839 --> 00:09:24,550
to share use your code then that's

00:09:21,940 --> 00:09:26,440
better for you so a standalone library

00:09:24,550 --> 00:09:29,260
permits other people to use your code

00:09:26,440 --> 00:09:30,940
even outside of Ross and it frees up

00:09:29,260 --> 00:09:34,180
your driver from requiring the Ross

00:09:30,940 --> 00:09:35,770
headers and Ross transports this could

00:09:34,180 --> 00:09:37,839
lead to wider adoption which means

00:09:35,770 --> 00:09:39,850
additional testing which means less bugs

00:09:37,839 --> 00:09:42,490
for you to find and sometimes they even

00:09:39,850 --> 00:09:46,810
provide fixes and it helps you commit

00:09:42,490 --> 00:09:49,630
more to the wider community one trick

00:09:46,810 --> 00:09:51,550
that was common is even easier now is to

00:09:49,630 --> 00:09:53,350
actually use the message headers that

00:09:51,550 --> 00:09:55,660
are auto-generated inside of your

00:09:53,350 --> 00:09:57,730
standalone library it used to be I

00:09:55,660 --> 00:10:00,550
believe that you would just copy them

00:09:57,730 --> 00:10:03,790
over and share them as compiled chunks

00:10:00,550 --> 00:10:05,290
but I think as a Forte they've worked

00:10:03,790 --> 00:10:08,200
really hard to make the message

00:10:05,290 --> 00:10:09,610
generation exist separate from Ross so

00:10:08,200 --> 00:10:15,610
now that you can use these in your

00:10:09,610 --> 00:10:17,260
libraries completely freely and speaking

00:10:15,610 --> 00:10:20,260
of dependencies just like we would like

00:10:17,260 --> 00:10:23,920
to avoid Ross at this of requiring Ross

00:10:20,260 --> 00:10:26,560
at this stage other mistakes that people

00:10:23,920 --> 00:10:29,550
make can be requiring large dependencies

00:10:26,560 --> 00:10:31,480
so open CV and PCL are common

00:10:29,550 --> 00:10:33,730
dependencies that people require in

00:10:31,480 --> 00:10:36,910
drivers that really put place an

00:10:33,730 --> 00:10:38,709
unnecessary burden they reduce the

00:10:36,910 --> 00:10:41,020
portability of the driver because you

00:10:38,709 --> 00:10:44,260
may not be able to compile open CV on

00:10:41,020 --> 00:10:47,770
whatever versions of dependencies you

00:10:44,260 --> 00:10:49,320
have on your like embedded system and

00:10:47,770 --> 00:10:52,120
they can also make the driver

00:10:49,320 --> 00:10:53,920
unnecessarily complicated so you can

00:10:52,120 --> 00:10:56,140
imagine that if we use the open CV and

00:10:53,920 --> 00:10:58,089
our hardware driver we would go first

00:10:56,140 --> 00:11:01,600
from the API we're using the grab the

00:10:58,089 --> 00:11:03,970
image from the camera into open CV CV

00:11:01,600 --> 00:11:05,740
matte format and then finally get to get

00:11:03,970 --> 00:11:07,740
that in the Ross we'd have to go to CV

00:11:05,740 --> 00:11:11,490
bridge and then a censor messages in

00:11:07,740 --> 00:11:16,500
and that's pretty much three unnecessary

00:11:11,490 --> 00:11:18,600
steps and just like we don't want to

00:11:16,500 --> 00:11:21,600
take those unnecessary steps if you do

00:11:18,600 --> 00:11:23,970
keep changing representations then you

00:11:21,600 --> 00:11:26,190
could make mistakes because the more

00:11:23,970 --> 00:11:28,620
hops you make the more of a chance that

00:11:26,190 --> 00:11:33,480
your representations weren't compatible

00:11:28,620 --> 00:11:35,460
and also for images if you copy each of

00:11:33,480 --> 00:11:38,640
those steps you can have very high CPU

00:11:35,460 --> 00:11:41,220
usage another thing that you should

00:11:38,640 --> 00:11:43,800
avoid is using graphical components and

00:11:41,220 --> 00:11:47,700
your driver itself so these are things

00:11:43,800 --> 00:11:51,530
like the PCL visualizer the opencv

00:11:47,700 --> 00:11:54,060
visualizer or any other graphics library

00:11:51,530 --> 00:11:56,070
lots of systems like to run the headless

00:11:54,060 --> 00:12:00,990
which means they don't even have the X

00:11:56,070 --> 00:12:03,480
environment installed or any of that so

00:12:00,990 --> 00:12:05,010
they would have to fork your driver and

00:12:03,480 --> 00:12:06,870
then actually compile a different

00:12:05,010 --> 00:12:09,630
version or if you did that for them

00:12:06,870 --> 00:12:11,430
that's more for you to maintain and I

00:12:09,630 --> 00:12:13,380
always find this unnecessary because I

00:12:11,430 --> 00:12:16,080
use the existing visualization tools

00:12:13,380 --> 00:12:19,290
such as RVs which means once you have

00:12:16,080 --> 00:12:21,420
your driver library compiled and sending

00:12:19,290 --> 00:12:27,030
to Ross you can immediately check it

00:12:21,420 --> 00:12:28,950
using a known good visualization tool so

00:12:27,030 --> 00:12:32,400
we can go over a little bit of review

00:12:28,950 --> 00:12:34,530
here for writing a library so which of

00:12:32,400 --> 00:12:38,220
these dependencies should or should you

00:12:34,530 --> 00:12:43,410
not use in a driver library so CV grab

00:12:38,220 --> 00:12:47,280
frame the boost SEO which is a c++ nest

00:12:43,410 --> 00:12:50,240
network and input/output library I often

00:12:47,280 --> 00:12:55,650
use it for networking and serial and

00:12:50,240 --> 00:12:57,090
finally Qt a graphical framework we

00:12:55,650 --> 00:12:59,730
should probably shouldn't use the open

00:12:57,090 --> 00:13:01,800
CV since we should try to directly fill

00:12:59,730 --> 00:13:04,260
a sensor messages image straight from

00:13:01,800 --> 00:13:08,190
the library we're using the with the

00:13:04,260 --> 00:13:10,560
camera boost SEO we could probably use

00:13:08,190 --> 00:13:12,960
boost tries to have significant

00:13:10,560 --> 00:13:14,640
portability between platforms but if

00:13:12,960 --> 00:13:18,180
there's something better than you should

00:13:14,640 --> 00:13:20,220
use that and you should avoid qt because

00:13:18,180 --> 00:13:21,250
even though it's very cross-platform and

00:13:20,220 --> 00:13:23,200
portable

00:13:21,250 --> 00:13:24,640
graphical components and drivers can

00:13:23,200 --> 00:13:29,640
mean that it won't be able to run on

00:13:24,640 --> 00:13:32,500
headless or embedded machines so now

00:13:29,640 --> 00:13:34,540
I've covered a lower view of writing a

00:13:32,500 --> 00:13:37,600
library now it's time to actually put it

00:13:34,540 --> 00:13:40,030
in the Ross which if you did a good job

00:13:37,600 --> 00:13:43,690
with your library this will just be a

00:13:40,030 --> 00:13:46,690
quick simple implementation so you can

00:13:43,690 --> 00:13:50,890
see here that I've mocked up a very

00:13:46,690 --> 00:13:55,480
simple use of a library inside of Ross

00:13:50,890 --> 00:13:57,520
C++ so the first thing we would do is

00:13:55,480 --> 00:14:01,300
just initialize our library and then

00:13:57,520 --> 00:14:03,370
while Ross is okay just create an IMU

00:14:01,300 --> 00:14:05,530
message fill it in with a library and

00:14:03,370 --> 00:14:07,510
publish and that means that your library

00:14:05,530 --> 00:14:10,000
has abstracted all of the complexity

00:14:07,510 --> 00:14:14,440
from Ross leaving you free to create

00:14:10,000 --> 00:14:16,930
very simple debuggable Ross notes and

00:14:14,440 --> 00:14:18,220
this is just the quick overview of the

00:14:16,930 --> 00:14:20,980
steps that you should take when you

00:14:18,220 --> 00:14:23,380
write your Ross wrapper so first you can

00:14:20,980 --> 00:14:26,050
anit your node which means talk to Ross

00:14:23,380 --> 00:14:27,730
initialize your library then you can

00:14:26,050 --> 00:14:29,920
grab your parameters from the server and

00:14:27,730 --> 00:14:31,870
any configurations that you need to set

00:14:29,920 --> 00:14:35,320
your library how you want it then

00:14:31,870 --> 00:14:37,089
advertise subscribe do your work and

00:14:35,320 --> 00:14:39,010
then make sure that you occasionally

00:14:37,089 --> 00:14:40,720
check in with Ross and that depends on

00:14:39,010 --> 00:14:43,420
the client and threading model you chose

00:14:40,720 --> 00:14:45,490
but as we talked about in yesterday's

00:14:43,420 --> 00:14:47,680
keynote Ross doesn't really force a

00:14:45,490 --> 00:14:49,390
program structure on you so you're free

00:14:47,680 --> 00:14:55,000
to use whatever you feel most

00:14:49,390 --> 00:14:57,760
comfortable with one important part of

00:14:55,000 --> 00:15:00,450
your Ross wrapper will be taking your

00:14:57,760 --> 00:15:02,820
library like if it throws exceptions and

00:15:00,450 --> 00:15:06,220
providing that information to your user

00:15:02,820 --> 00:15:08,770
so one of the primary uses of this is

00:15:06,220 --> 00:15:12,220
Ross out so in Ross CP this is called

00:15:08,770 --> 00:15:17,200
Ross console and in Ross pie you just

00:15:12,220 --> 00:15:19,750
used Longhorn or log error this prints

00:15:17,200 --> 00:15:21,790
to both the console and a tool known as

00:15:19,750 --> 00:15:24,460
rx console so that you can view this

00:15:21,790 --> 00:15:25,960
remotely over the network this is nice

00:15:24,460 --> 00:15:27,850
because this is your first line of

00:15:25,960 --> 00:15:30,270
defense and notifying your user of

00:15:27,850 --> 00:15:33,290
problems so there's different levels

00:15:30,270 --> 00:15:36,050
debug is commonly only used for you

00:15:33,290 --> 00:15:38,449
this is if you say you sent ten bytes on

00:15:36,050 --> 00:15:40,940
a port or if you're trying to D by you

00:15:38,449 --> 00:15:44,240
can say I've reached this step in this

00:15:40,940 --> 00:15:46,279
stage the user typically doesn't care

00:15:44,240 --> 00:15:48,170
about this information and debug

00:15:46,279 --> 00:15:50,870
statements can flood them with

00:15:48,170 --> 00:15:52,819
unnecessary information so the first

00:15:50,870 --> 00:15:55,459
level that they should usually see is

00:15:52,819 --> 00:15:57,440
info so these are nice things like if

00:15:55,459 --> 00:15:59,449
your driver successfully starts up and

00:15:57,440 --> 00:16:02,029
connects it's pretty good to tell them

00:15:59,449 --> 00:16:06,199
this so you can say I've connected on

00:16:02,029 --> 00:16:08,389
you know this USB serial port and now

00:16:06,199 --> 00:16:09,620
the next three stages are all of

00:16:08,389 --> 00:16:12,529
something's gone wrong

00:16:09,620 --> 00:16:18,980
so if you can do a warning if something

00:16:12,529 --> 00:16:21,319
is out of spec or if they or if there's

00:16:18,980 --> 00:16:23,420
a configuration that you think is a

00:16:21,319 --> 00:16:25,160
little funny that your users probably

00:16:23,420 --> 00:16:27,470
wouldn't want to use but you can

00:16:25,160 --> 00:16:29,180
actually continue running that's just

00:16:27,470 --> 00:16:31,699
the warning it means the user should be

00:16:29,180 --> 00:16:33,970
aware that this is a condition but they

00:16:31,699 --> 00:16:37,310
don't necessarily have to take action

00:16:33,970 --> 00:16:39,920
error is something more serious which in

00:16:37,310 --> 00:16:41,839
large numbers or even a single one could

00:16:39,920 --> 00:16:44,269
indicate that there is something wrong

00:16:41,839 --> 00:16:46,310
with how the system is working so for

00:16:44,269 --> 00:16:48,649
instance if your serial port started

00:16:46,310 --> 00:16:50,959
failing checksums and your user saw this

00:16:48,649 --> 00:16:52,579
on the console they might go over and

00:16:50,959 --> 00:16:55,579
realize that their serial port has come

00:16:52,579 --> 00:16:57,560
loose or disconnected and then finally

00:16:55,579 --> 00:17:00,829
the last one which should be used most

00:16:57,560 --> 00:17:02,779
sparingly is fatal and this is when your

00:17:00,829 --> 00:17:05,240
node has absolutely nothing that it can

00:17:02,779 --> 00:17:07,669
do to recover and it's going to close on

00:17:05,240 --> 00:17:09,860
its own so this is something like if

00:17:07,669 --> 00:17:11,390
your platforms voltage is too low and

00:17:09,860 --> 00:17:16,150
you have to shut down to save your

00:17:11,390 --> 00:17:16,150
batteries that's when you reduce fatal

00:17:16,510 --> 00:17:20,630
now I'm going to go off on a tangent

00:17:18,829 --> 00:17:22,220
here and talk about a more advanced

00:17:20,630 --> 00:17:25,189
topic which is the shared memory

00:17:22,220 --> 00:17:27,740
transport and raus and this is another

00:17:25,189 --> 00:17:30,380
stage to write in your Ross wrapper so

00:17:27,740 --> 00:17:32,720
high bandwidth bandwidth applications

00:17:30,380 --> 00:17:34,700
benefit from the shared memory transport

00:17:32,720 --> 00:17:36,850
this is especially good for things like

00:17:34,700 --> 00:17:40,700
images where you can be transmitting

00:17:36,850 --> 00:17:42,950
tens of megabytes per second there's a

00:17:40,700 --> 00:17:45,230
lot of CPU that gets eaten up trying to

00:17:42,950 --> 00:17:45,930
serialize that and uncy realize it just

00:17:45,230 --> 00:17:48,300
the transport

00:17:45,930 --> 00:17:50,070
between nodes so as we saw in the

00:17:48,300 --> 00:17:52,590
lightning talks yesterday the notelets

00:17:50,070 --> 00:17:54,960
let you pass shared memory versions and

00:17:52,590 --> 00:17:57,630
Ross implements this using the boost

00:17:54,960 --> 00:17:59,760
shared pointer and there's actually

00:17:57,630 --> 00:18:03,410
convenience aliases that you can use

00:17:59,760 --> 00:18:06,390
right off the bat so if you just attach

00:18:03,410 --> 00:18:08,310
PTR to the end of your data type that's

00:18:06,390 --> 00:18:11,940
all of a sudden this shared pointer type

00:18:08,310 --> 00:18:14,970
or you could go into the colon pool and

00:18:11,940 --> 00:18:17,760
PTR and then that's the same alias

00:18:14,970 --> 00:18:19,470
there's also Const which is nice for

00:18:17,760 --> 00:18:21,150
these not--let's since it is truly

00:18:19,470 --> 00:18:23,760
shared memory and you have to be aware

00:18:21,150 --> 00:18:25,350
that if you change it in one Noblet all

00:18:23,760 --> 00:18:28,890
the other notes will see that change

00:18:25,350 --> 00:18:30,750
immediately but the nice thing about

00:18:28,890 --> 00:18:35,910
not--let's is that there are they are

00:18:30,750 --> 00:18:38,100
dynamically loaded at runtime there are

00:18:35,910 --> 00:18:40,650
some differences between nodes and nodes

00:18:38,100 --> 00:18:43,860
so know--let's must be classes and they

00:18:40,650 --> 00:18:45,270
have a class that they inherit from they

00:18:43,860 --> 00:18:47,130
interface through Ross through

00:18:45,270 --> 00:18:49,650
convenience functions that are very

00:18:47,130 --> 00:18:51,990
similar to but not exactly like what you

00:18:49,650 --> 00:18:54,450
see with notes so for instance instead

00:18:51,990 --> 00:18:56,400
of just creating a node handle you call

00:18:54,450 --> 00:18:58,590
a convenience function that's get node

00:18:56,400 --> 00:19:00,570
handle and then you're passed a node

00:18:58,590 --> 00:19:03,150
handle that's already taking care of the

00:19:00,570 --> 00:19:05,970
remapping for your specific node lip so

00:19:03,150 --> 00:19:07,890
you see almost no change even though

00:19:05,970 --> 00:19:10,380
you're all your notes are running inside

00:19:07,890 --> 00:19:12,690
the same process the interface is

00:19:10,380 --> 00:19:14,790
identical to what you would have for

00:19:12,690 --> 00:19:16,560
your node so once you have your note

00:19:14,790 --> 00:19:19,260
handle you just ask for your parameters

00:19:16,560 --> 00:19:23,490
and then the private remapping xandrie

00:19:19,260 --> 00:19:25,260
mappings all get applied for you know

00:19:23,490 --> 00:19:26,820
let's also have one thing that you

00:19:25,260 --> 00:19:28,800
should be aware of when they are

00:19:26,820 --> 00:19:31,620
initialized which is the on init

00:19:28,800 --> 00:19:34,250
function not their constructor or main

00:19:31,620 --> 00:19:39,120
so this is called after they're loaded

00:19:34,250 --> 00:19:41,820
and right before they start to do their

00:19:39,120 --> 00:19:45,450
work so this is where you set up like

00:19:41,820 --> 00:19:47,520
where you want your callbacks to go and

00:19:45,450 --> 00:19:49,950
then finally no but it doesn't use Ross

00:19:47,520 --> 00:19:52,200
warned Ross error it uses Noblet warned

00:19:49,950 --> 00:19:57,730
no the error so that you can have

00:19:52,200 --> 00:19:59,350
properly remapped titles to rx console

00:19:57,730 --> 00:20:01,390
and I've already mentioned the

00:19:59,350 --> 00:20:03,520
similarities that you can still remap

00:20:01,390 --> 00:20:06,820
topics free parameters run from launch

00:20:03,520 --> 00:20:09,250
files and noblesse can also be run

00:20:06,820 --> 00:20:10,960
what's called standalone mode or you can

00:20:09,250 --> 00:20:14,620
compile them into a traditional Ross

00:20:10,960 --> 00:20:16,660
node so that the user sees almost no

00:20:14,620 --> 00:20:18,910
difference and they can just sit and go

00:20:16,660 --> 00:20:20,920
Ross run you know your node life and

00:20:18,910 --> 00:20:23,160
they don't actually know it's a Noblet

00:20:20,920 --> 00:20:27,820
unless they need that high performance

00:20:23,160 --> 00:20:30,940
shared memory so we can talk review

00:20:27,820 --> 00:20:34,080
about this so if your driver cannot open

00:20:30,940 --> 00:20:37,810
a port is this a debug info error fatal

00:20:34,080 --> 00:20:40,480
and if your program attempts to recover

00:20:37,810 --> 00:20:42,790
which is a good thing then it should be

00:20:40,480 --> 00:20:44,980
an error so you can simply say oh I

00:20:42,790 --> 00:20:47,500
can't open that port right now I will

00:20:44,980 --> 00:20:49,960
try in one more second and if your

00:20:47,500 --> 00:20:54,630
program simply just says oh the ports

00:20:49,960 --> 00:20:58,300
closed I'm bailing and you can use fatal

00:20:54,630 --> 00:21:00,460
and some review about nodes so if you

00:20:58,300 --> 00:21:03,040
have a stereo camera publishing images

00:21:00,460 --> 00:21:05,220
at 10 megabytes per second should you

00:21:03,040 --> 00:21:07,600
implement a node but for this driver and

00:21:05,220 --> 00:21:09,700
then if you have a laser scanner

00:21:07,600 --> 00:21:12,220
publishing scans at one megabyte per

00:21:09,700 --> 00:21:15,880
second should you implement an oklet and

00:21:12,220 --> 00:21:17,740
of course for the cameras yes you should

00:21:15,880 --> 00:21:19,720
implement a note plate because shared

00:21:17,740 --> 00:21:24,100
memory can save significant resources

00:21:19,720 --> 00:21:25,180
and at lesser bandwidth it's it's up to

00:21:24,100 --> 00:21:27,580
you

00:21:25,180 --> 00:21:30,040
I said maybe for the laser scanner at

00:21:27,580 --> 00:21:32,380
one megabyte per second as we're seeing

00:21:30,040 --> 00:21:37,030
more and more smaller and embedded vices

00:21:32,380 --> 00:21:39,220
come into the Rossum ecosystem the CPU

00:21:37,030 --> 00:21:41,860
usage serializing and uncie realizing

00:21:39,220 --> 00:21:44,500
that data could be could start to eat up

00:21:41,860 --> 00:21:48,550
the entire usage of that board so

00:21:44,500 --> 00:21:49,560
anything that we can save is better all

00:21:48,550 --> 00:21:51,820
right

00:21:49,560 --> 00:21:53,650
so now I'll talk about one of my

00:21:51,820 --> 00:21:57,610
favorite jewels and Ross dynamic

00:21:53,650 --> 00:21:59,410
reconfigure so dynamic reconfigure

00:21:57,610 --> 00:22:02,140
allows you to change parameters during

00:21:59,410 --> 00:22:04,030
runtime without restarting the node this

00:22:02,140 --> 00:22:06,760
initializes parameters and stores

00:22:04,030 --> 00:22:09,530
changes on the parameter server and I

00:22:06,760 --> 00:22:12,110
highly recommend it and it's lots of fun

00:22:09,530 --> 00:22:14,090
I may or may not dynamic reconfigure

00:22:12,110 --> 00:22:19,130
everything I can get my hands on there

00:22:14,090 --> 00:22:21,740
it should or not here I've shown an

00:22:19,130 --> 00:22:24,140
image of what the dynamic reconfigure

00:22:21,740 --> 00:22:26,300
looks like for the ho Q yo node so you

00:22:24,140 --> 00:22:29,360
can see that you can set things like the

00:22:26,300 --> 00:22:32,510
minimum range so this is a 2d laser

00:22:29,360 --> 00:22:35,210
scanner for those who aren't familiar so

00:22:32,510 --> 00:22:37,280
it starts at one end scans and ends at

00:22:35,210 --> 00:22:39,260
another point you can actually tighten

00:22:37,280 --> 00:22:41,630
up that range without restarting your

00:22:39,260 --> 00:22:43,670
driver and then you can turn on the

00:22:41,630 --> 00:22:45,410
intensity returns which is the amount of

00:22:43,670 --> 00:22:47,480
energy the laser gets back from its

00:22:45,410 --> 00:22:50,810
reflection and that can end up more

00:22:47,480 --> 00:22:52,730
bandwidth and you can see here that you

00:22:50,810 --> 00:22:54,200
can even change the port so if you

00:22:52,730 --> 00:22:57,170
launched your driver on your remote

00:22:54,200 --> 00:22:58,730
robot and went oh oops I had to hum

00:22:57,170 --> 00:23:00,890
kuya's plugged in I don't want this one

00:22:58,730 --> 00:23:04,220
I want the other one you can just change

00:23:00,890 --> 00:23:09,290
it right there on the fly and it's

00:23:04,220 --> 00:23:10,790
really fun dynamic reconfigure is good

00:23:09,290 --> 00:23:13,190
for user convenience and remote

00:23:10,790 --> 00:23:15,350
configuration and it's great for

00:23:13,190 --> 00:23:19,610
changing driver modes resolutions and

00:23:15,350 --> 00:23:22,550
rates it's also a great way to test the

00:23:19,610 --> 00:23:24,400
various modes and parameters and if the

00:23:22,550 --> 00:23:26,960
node is running on a remote machine

00:23:24,400 --> 00:23:30,620
dynamic reconfigure is more convenient

00:23:26,960 --> 00:23:33,080
than SSH in a SS 18 into the robot

00:23:30,620 --> 00:23:35,180
changing your parameters control seeing

00:23:33,080 --> 00:23:37,400
your node relaunching it and then going

00:23:35,180 --> 00:23:40,130
back and checking your results you can

00:23:37,400 --> 00:23:42,230
just from your laptop remotely open up

00:23:40,130 --> 00:23:44,600
dynamic reconfigure your little slider

00:23:42,230 --> 00:23:46,010
and then your robots all of a sudden

00:23:44,600 --> 00:23:48,530
using the parameters that you want to

00:23:46,010 --> 00:23:55,310
test this makes iterations on it very

00:23:48,530 --> 00:23:58,910
fast this is the example of Ross PI API

00:23:55,310 --> 00:24:00,710
for dynamic reconfigure so the the part

00:23:58,910 --> 00:24:03,170
you actually start at is at the bottom

00:24:00,710 --> 00:24:06,710
so we first just an in our Ross node and

00:24:03,170 --> 00:24:09,740
then we define our reconfigure service

00:24:06,710 --> 00:24:11,090
with just a config type which is

00:24:09,740 --> 00:24:13,760
something that if you go through the

00:24:11,090 --> 00:24:15,620
dynamic reconfigure tutorials you'll see

00:24:13,760 --> 00:24:17,990
that you can define the types you change

00:24:15,620 --> 00:24:20,420
a priori and then you give this a

00:24:17,990 --> 00:24:22,010
callback and then finally when the user

00:24:20,420 --> 00:24:25,070
goes and changes

00:24:22,010 --> 00:24:27,230
in the GUI this callback triggers so you

00:24:25,070 --> 00:24:29,420
can see here that I've set up something

00:24:27,230 --> 00:24:31,670
for the user to change a color of an LED

00:24:29,420 --> 00:24:33,530
so they could slide it have a little

00:24:31,670 --> 00:24:36,380
slider for a red a green in a blue

00:24:33,530 --> 00:24:39,530
channel and then I in the library I just

00:24:36,380 --> 00:24:42,620
give it those values and then I read

00:24:39,530 --> 00:24:44,900
back from the library what colors it

00:24:42,620 --> 00:24:48,110
could actually support and then I return

00:24:44,900 --> 00:24:50,360
that to the user so in this you know

00:24:48,110 --> 00:24:54,080
less than I don't know ten lines of code

00:24:50,360 --> 00:24:56,810
I've already set up a whole feedback

00:24:54,080 --> 00:24:59,170
loop between my driver and my user and

00:24:56,810 --> 00:25:01,310
of course this is a trivial example but

00:24:59,170 --> 00:25:02,780
you can imagine it becomes more

00:25:01,310 --> 00:25:05,390
significant for things like laser

00:25:02,780 --> 00:25:08,450
scanners where the user may not even

00:25:05,390 --> 00:25:10,610
know the ranges that the laser scan

00:25:08,450 --> 00:25:12,980
supports but if they just try to max it

00:25:10,610 --> 00:25:15,110
out you can correct it and say oh it can

00:25:12,980 --> 00:25:20,540
actually only go this far it's very

00:25:15,110 --> 00:25:23,360
handy so here's a review on dynamic

00:25:20,540 --> 00:25:25,690
reconfigure so should you use this for

00:25:23,360 --> 00:25:27,950
controlling a cameras frames per second

00:25:25,690 --> 00:25:30,470
for changing a motor controllers

00:25:27,950 --> 00:25:34,790
configuration and for changing a

00:25:30,470 --> 00:25:37,610
publisher's topic and for camera frames

00:25:34,790 --> 00:25:40,070
per second yes so this helps your user

00:25:37,610 --> 00:25:42,230
so if they're trying to log and they

00:25:40,070 --> 00:25:45,170
realize oh the camera is outputting too

00:25:42,230 --> 00:25:47,360
fast I need to turn it down or even if

00:25:45,170 --> 00:25:50,380
they can't keep up with the processing

00:25:47,360 --> 00:25:50,380
this helps

00:26:02,580 --> 00:26:13,239
my track I'm off of it so if you're

00:26:11,379 --> 00:26:15,580
going if you have a camera driver that

00:26:13,239 --> 00:26:17,409
supports dynamic reconfigure you can

00:26:15,580 --> 00:26:20,739
change the frames per second on the fly

00:26:17,409 --> 00:26:24,519
so one thing that I do is I say alright

00:26:20,739 --> 00:26:26,619
I can log at 20 megabytes per second so

00:26:24,519 --> 00:26:29,679
I'll open up a terminal and do Ross

00:26:26,619 --> 00:26:31,720
topic bandwidth on my topic and then sit

00:26:29,679 --> 00:26:33,669
there with my slider and drag my frames

00:26:31,720 --> 00:26:36,099
per second down until I figure out where

00:26:33,669 --> 00:26:38,080
that bandwidth limit is and realize yes

00:26:36,099 --> 00:26:40,749
that's where I will not saturate my desk

00:26:38,080 --> 00:26:44,619
and then I can save it and run it with

00:26:40,749 --> 00:26:46,960
that permanently and then for changing a

00:26:44,619 --> 00:26:48,669
motor controllers configuration this is

00:26:46,960 --> 00:26:51,159
probably a good idea because it will

00:26:48,669 --> 00:26:52,450
allow first-time users to quickly

00:26:51,159 --> 00:26:54,099
iterate through the different

00:26:52,450 --> 00:26:56,289
permutations that this may or may not

00:26:54,099 --> 00:26:57,970
support but you should be aware that

00:26:56,289 --> 00:27:00,159
that could be dangerous

00:26:57,970 --> 00:27:04,119
so hopefully your users have adequate

00:27:00,159 --> 00:27:06,609
emergency stops and you should probably

00:27:04,119 --> 00:27:08,889
not use dynamic reconfigure for changing

00:27:06,609 --> 00:27:11,499
a publisher's topic on the fly because

00:27:08,889 --> 00:27:14,169
that contradicts with the Ross remap of

00:27:11,499 --> 00:27:18,970
topics which once you've changed that it

00:27:14,169 --> 00:27:21,179
will cause all sorts of issues and the

00:27:18,970 --> 00:27:24,279
last thing I'd like to talk about is

00:27:21,179 --> 00:27:27,179
Diagnostics which is something that all

00:27:24,279 --> 00:27:31,479
hardware drivers should try to support

00:27:27,179 --> 00:27:33,820
they're very important because not all

00:27:31,479 --> 00:27:37,419
information is contained within the

00:27:33,820 --> 00:27:39,099
common messages that you see so one

00:27:37,419 --> 00:27:40,749
common of one approach is that people

00:27:39,099 --> 00:27:44,739
will create custom messages for this

00:27:40,749 --> 00:27:48,279
driver specific information and we've

00:27:44,739 --> 00:27:50,320
seen this really with GPS because what's

00:27:48,279 --> 00:27:52,539
in sensor messages is a boiled down

00:27:50,320 --> 00:27:54,249
version that's specifically for clients

00:27:52,539 --> 00:27:57,519
that don't necessarily need to

00:27:54,249 --> 00:27:59,440
understand how GPS fixes work just that

00:27:57,519 --> 00:28:01,720
they need the information on how to use

00:27:59,440 --> 00:28:03,639
it such as the position and covariance

00:28:01,720 --> 00:28:05,590
it doesn't contain things like the

00:28:03,639 --> 00:28:09,700
satellite count or the Doppler

00:28:05,590 --> 00:28:11,710
velocities so the diagnostic system

00:28:09,700 --> 00:28:14,840
provides a framework to report these

00:28:11,710 --> 00:28:17,000
Hardware statuses outside of your

00:28:14,840 --> 00:28:19,100
messages so and these can handle

00:28:17,000 --> 00:28:22,130
arbitrary image measurements so things

00:28:19,100 --> 00:28:24,620
like your GPS satellite counts your

00:28:22,130 --> 00:28:26,870
encoder readings from your platform your

00:28:24,620 --> 00:28:32,270
current system voltage your disk space

00:28:26,870 --> 00:28:34,670
free how much you're using your CPU and

00:28:32,270 --> 00:28:36,710
then so here's something

00:28:34,670 --> 00:28:39,020
what's inside of the diagnostic status

00:28:36,710 --> 00:28:41,750
message so the first thing you have is

00:28:39,020 --> 00:28:46,220
your component name which could be just

00:28:41,750 --> 00:28:48,950
your driver name or what it does the

00:28:46,220 --> 00:28:50,840
second element is your hardware ID so

00:28:48,950 --> 00:28:54,170
this is commonly things like serial

00:28:50,840 --> 00:28:56,990
numbers or which internal unit it was or

00:28:54,170 --> 00:29:00,290
where it is on the vehicle if you have

00:28:56,990 --> 00:29:03,650
different encoders the next thing is an

00:29:00,290 --> 00:29:05,720
arbitrary number of key value pairs so

00:29:03,650 --> 00:29:09,500
you can push in things like your voltage

00:29:05,720 --> 00:29:10,970
or your modes or your current and you

00:29:09,500 --> 00:29:13,790
can list as many of these in each

00:29:10,970 --> 00:29:15,260
diagnostic status as you need and then

00:29:13,790 --> 00:29:18,290
finally you have a human readable

00:29:15,260 --> 00:29:20,450
message that will tell your user if

00:29:18,290 --> 00:29:23,780
things are ok or not so for instance if

00:29:20,450 --> 00:29:26,180
your voltage drops below say 22 volts

00:29:23,780 --> 00:29:30,440
you can say oh the battery's low I'm

00:29:26,180 --> 00:29:33,770
going to warn you about this and

00:29:30,440 --> 00:29:36,710
speaking of warning diagnostics also has

00:29:33,770 --> 00:29:39,280
many convenient levels so the first one

00:29:36,710 --> 00:29:42,440
is ok everything's running as expected

00:29:39,280 --> 00:29:45,020
the second one is warning which means

00:29:42,440 --> 00:29:46,760
this behavior could affect operation but

00:29:45,020 --> 00:29:49,610
it's not necessarily something you have

00:29:46,760 --> 00:29:53,090
to look at so this could be if you lost

00:29:49,610 --> 00:29:54,380
your GPS base station an error is a

00:29:53,090 --> 00:29:56,600
problem that needs immediate attention

00:29:54,380 --> 00:29:58,310
so this would be if your battery voltage

00:29:56,600 --> 00:30:00,860
dropped below the level that's safe for

00:29:58,310 --> 00:30:02,240
your batteries then you could alert your

00:30:00,860 --> 00:30:04,400
user that there's an error and that they

00:30:02,240 --> 00:30:06,950
need to recharge immediately and then

00:30:04,400 --> 00:30:09,620
finally in the tools you'll see a fourth

00:30:06,950 --> 00:30:12,350
one known as stale and then this is used

00:30:09,620 --> 00:30:14,810
that when a node dies drops active exits

00:30:12,350 --> 00:30:19,160
or otherwise freezes and you do not get

00:30:14,810 --> 00:30:21,470
new information this is one of the

00:30:19,160 --> 00:30:24,170
Diagnostics viewer tools this is called

00:30:21,470 --> 00:30:26,720
runtime monitor and this is the simpler

00:30:24,170 --> 00:30:28,310
of the two so you can see here that on

00:30:26,720 --> 00:30:30,920
my computer I just

00:30:28,310 --> 00:30:33,710
made a quick note that reports my CPU my

00:30:30,920 --> 00:30:35,600
disk in my network usage and over here

00:30:33,710 --> 00:30:37,700
on the right you can see the key value

00:30:35,600 --> 00:30:41,530
pairs between my utilization my

00:30:37,700 --> 00:30:45,170
temperatures and memory and swap and

00:30:41,530 --> 00:30:48,170
then here's the other tool which is

00:30:45,170 --> 00:30:49,580
robot monitor which actually aggregates

00:30:48,170 --> 00:30:52,220
your Diagnostics into different

00:30:49,580 --> 00:30:55,220
categories so here you can see that I

00:30:52,220 --> 00:30:57,950
visualized CPU and disk and while

00:30:55,220 --> 00:31:00,200
calculating machine primes my CPU

00:30:57,950 --> 00:31:06,620
temperature got above 85 degrees so I

00:31:00,200 --> 00:31:09,250
decided to warn myself bad laptop there

00:31:06,620 --> 00:31:11,840
are a few helper tools for Diagnostics

00:31:09,250 --> 00:31:13,430
C++ has had them for a while and Python

00:31:11,840 --> 00:31:15,440
just got them

00:31:13,430 --> 00:31:17,270
there's the diagnostic status wrapper

00:31:15,440 --> 00:31:19,660
which just helps you fill in the

00:31:17,270 --> 00:31:22,820
messages with convenience functions an

00:31:19,660 --> 00:31:26,060
updater which periodically calls various

00:31:22,820 --> 00:31:27,590
callbacks so you can say once per second

00:31:26,060 --> 00:31:29,930
go through and loop and make sure that

00:31:27,590 --> 00:31:33,020
everything's okay and there's a

00:31:29,930 --> 00:31:35,630
diagnosed publisher which tracks

00:31:33,020 --> 00:31:39,200
statistics so if you use this publisher

00:31:35,630 --> 00:31:41,030
it automatically tracks things like min

00:31:39,200 --> 00:31:43,730
frequency that you can accept in max

00:31:41,030 --> 00:31:49,040
frequency and things like latency or

00:31:43,730 --> 00:31:52,010
time delays so review on Diagnostics

00:31:49,040 --> 00:31:54,770
warned or error if you've lost three

00:31:52,010 --> 00:31:56,930
messages in a second or if you've

00:31:54,770 --> 00:32:00,050
received no images in the last 30

00:31:56,930 --> 00:32:02,330
seconds and then finally should use

00:32:00,050 --> 00:32:05,870
Diagnostics to actually disable your

00:32:02,330 --> 00:32:08,720
vehicle's motion so if you've just lost

00:32:05,870 --> 00:32:11,000
three images but they've resumed you can

00:32:08,720 --> 00:32:13,850
probably diagnose diagnose that as a

00:32:11,000 --> 00:32:15,770
warning your system recovered and things

00:32:13,850 --> 00:32:18,470
seem to be ok it may have just been a

00:32:15,770 --> 00:32:20,150
network or a camera hiccup but if you

00:32:18,470 --> 00:32:23,990
haven't received images in a long time

00:32:20,150 --> 00:32:27,680
that's an error state and Diagnostics

00:32:23,990 --> 00:32:30,230
should only be used to support logging

00:32:27,680 --> 00:32:32,390
and operator display only the drivers

00:32:30,230 --> 00:32:35,710
themselves should actually implement any

00:32:32,390 --> 00:32:35,710
critical safety functions

00:32:36,320 --> 00:32:42,160
and I guess I'll take questions at this

00:32:40,100 --> 00:32:42,160
point

00:32:50,140 --> 00:32:54,980
the question was is dynamic reconfigure

00:32:53,000 --> 00:32:57,110
tied to the GUI implementation or are

00:32:54,980 --> 00:32:59,570
there other interfaces and the answer is

00:32:57,110 --> 00:33:01,910
yes there are other interfaces at its

00:32:59,570 --> 00:33:03,770
base dynamic reconfigure is a set of

00:33:01,910 --> 00:33:07,040
services that are called specifically

00:33:03,770 --> 00:33:10,880
for that node so the GUI is essentially

00:33:07,040 --> 00:33:11,660
the minimal user human client for those

00:33:10,880 --> 00:33:15,320
services

00:33:11,660 --> 00:33:21,950
Python currently has a code API and the

00:33:15,320 --> 00:33:25,210
C++ one has been requested so the

00:33:21,950 --> 00:33:28,340
question was occasionally sensors output

00:33:25,210 --> 00:33:30,590
at the proper rate but with nonsense

00:33:28,340 --> 00:33:32,960
things like a camera going instantly

00:33:30,590 --> 00:33:35,840
black or laser scanner consistently

00:33:32,960 --> 00:33:39,560
outputting random noise and where would

00:33:35,840 --> 00:33:42,460
you put this warning or error so how I

00:33:39,560 --> 00:33:45,260
would do this would be in the diagnostic

00:33:42,460 --> 00:33:49,970
updater you can set to have callbacks

00:33:45,260 --> 00:33:51,980
the checks specific messages so if you

00:33:49,970 --> 00:33:54,140
have a quick library that you've send

00:33:51,980 --> 00:33:56,570
every laser scan through before it gets

00:33:54,140 --> 00:33:59,720
published you could for instance check

00:33:56,570 --> 00:34:01,880
to make sure that the sensor was

00:33:59,720 --> 00:34:03,470
outputting appropriately although I

00:34:01,880 --> 00:34:05,240
guess this would be more appropriate for

00:34:03,470 --> 00:34:08,900
the camera since you could detect all

00:34:05,240 --> 00:34:11,390
black pixels fairly easy just with a

00:34:08,900 --> 00:34:13,280
quick random sampling like especially in

00:34:11,390 --> 00:34:16,250
the middle of your frame and then if

00:34:13,280 --> 00:34:18,650
that's true once per second your it

00:34:16,250 --> 00:34:20,660
would check in and ask oh hey did you

00:34:18,650 --> 00:34:24,460
have you seen this problem and then you

00:34:20,660 --> 00:34:24,460
could report yes I have

00:34:27,339 --> 00:34:36,020
so the question was if you have multiple

00:34:33,710 --> 00:34:39,349
sensors and one of them has gone into a

00:34:36,020 --> 00:34:41,510
failure state you wouldn't want to shut

00:34:39,349 --> 00:34:44,990
down your system until both of those

00:34:41,510 --> 00:34:47,780
have happened and the answer to this

00:34:44,990 --> 00:34:49,849
question is that you shouldn't shut down

00:34:47,780 --> 00:34:52,280
your sensor your system from any

00:34:49,849 --> 00:34:54,379
particular driver but only in very rare

00:34:52,280 --> 00:34:57,170
circumstances should the driver itself

00:34:54,379 --> 00:34:59,390
shut down what it's responsible for so

00:34:57,170 --> 00:35:01,099
in the case of permanently damaging the

00:34:59,390 --> 00:35:02,540
hardware the driver should be

00:35:01,099 --> 00:35:03,920
responsible for preventing that from

00:35:02,540 --> 00:35:05,839
happening

00:35:03,920 --> 00:35:08,920
irregardless of what commands it's

00:35:05,839 --> 00:35:10,960
receiving so this is things like

00:35:08,920 --> 00:35:14,630
protecting your batteries or

00:35:10,960 --> 00:35:19,010
current-limiting if you can only say

00:35:14,630 --> 00:35:20,839
drive at max current for 30 seconds and

00:35:19,010 --> 00:35:24,260
there's no built-in hardware to protect

00:35:20,839 --> 00:35:26,480
it then that's the sort of case where

00:35:24,260 --> 00:35:28,839
the driver should all of a sudden pull a

00:35:26,480 --> 00:35:28,839
stop

00:35:34,720 --> 00:35:41,420
so the question was should you bend the

00:35:39,349 --> 00:35:47,180
rules to make decisions based on the

00:35:41,420 --> 00:35:51,380
Diagnostics messages and the answer to

00:35:47,180 --> 00:35:53,059
that is that if it's critical enough you

00:35:51,380 --> 00:35:57,140
should probably have a separate route to

00:35:53,059 --> 00:36:00,170
do so the diagnostic system is intended

00:35:57,140 --> 00:36:01,730
for human consumption which means you're

00:36:00,170 --> 00:36:04,220
free to as the operator to make

00:36:01,730 --> 00:36:06,079
decisions based on that information but

00:36:04,220 --> 00:36:09,890
anything in a programmatic way should

00:36:06,079 --> 00:36:12,950
have more tests and more constraints to

00:36:09,890 --> 00:36:15,020
guarantee that if it is truly valuable

00:36:12,950 --> 00:36:17,210
enough to make decisions based on

00:36:15,020 --> 00:36:20,980
information you should have a guaranteed

00:36:17,210 --> 00:36:20,980
to critical path to present that

00:36:29,319 --> 00:36:37,089
okay so there are very similar levels

00:36:33,319 --> 00:36:40,069
the question was when should you use

00:36:37,089 --> 00:36:41,269
Ross console versus the Diagnostics and

00:36:40,069 --> 00:36:45,369
the answer is that you should use both

00:36:41,269 --> 00:36:47,689
at the same time the Ross console is

00:36:45,369 --> 00:36:49,670
triggered more or less on things that

00:36:47,689 --> 00:36:53,179
are immediate and have happened right

00:36:49,670 --> 00:36:55,759
now so like if you fail a checksum or if

00:36:53,179 --> 00:36:59,029
your encoder all of a sudden skips an

00:36:55,759 --> 00:37:01,670
update that could be an error but in

00:36:59,029 --> 00:37:06,109
your Diagnostics it would be more

00:37:01,670 --> 00:37:08,599
accumulated problems such as well the

00:37:06,109 --> 00:37:11,209
encoder is skipped 12 updates in the

00:37:08,599 --> 00:37:13,069
last minute this means traditionally in

00:37:11,209 --> 00:37:21,890
our system that the encoder is dead and

00:37:13,069 --> 00:37:24,199
it needs replaced oh this question so

00:37:21,890 --> 00:37:26,869
one very common thing that we like to

00:37:24,199 --> 00:37:29,269
see is that we love these Ross console

00:37:26,869 --> 00:37:31,670
macros and we want to use them

00:37:29,269 --> 00:37:34,150
everywhere we can but they're part of

00:37:31,670 --> 00:37:38,569
Ross and they tie directly into the Ross

00:37:34,150 --> 00:37:41,660
comms so what do we do in our standalone

00:37:38,569 --> 00:37:43,160
library do we just print and hope that

00:37:41,660 --> 00:37:45,619
it makes it out or do we throw

00:37:43,160 --> 00:37:47,209
exceptions and hope that whoever is

00:37:45,619 --> 00:37:49,699
implementing our library catches them

00:37:47,209 --> 00:37:52,759
and the answer to this is that you can

00:37:49,699 --> 00:37:56,329
actually use preprocessor macros right

00:37:52,759 --> 00:37:59,029
that if Ross is present you could print

00:37:56,329 --> 00:38:02,059
to the Ross console and the difference

00:37:59,029 --> 00:38:04,999
is not then you can actually just print

00:38:02,059 --> 00:38:07,189
a terminal I've seen this in libraries

00:38:04,999 --> 00:38:10,339
such as octo map have done this very

00:38:07,189 --> 00:38:12,799
well and so if Ross is present on your

00:38:10,339 --> 00:38:15,049
system and you compile it so then you

00:38:12,799 --> 00:38:17,449
can actually use Ross console inside of

00:38:15,049 --> 00:38:19,309
the standalone library but if someone's

00:38:17,449 --> 00:38:22,009
compiling it without Ross and without

00:38:19,309 --> 00:38:24,829
the Associated flag then it simply just

00:38:22,009 --> 00:38:27,979
turns into the normal standard out or

00:38:24,829 --> 00:38:30,670
standard error and that's a pretty handy

00:38:27,979 --> 00:38:30,670
feature to use

00:38:42,279 --> 00:38:46,729
so the question was is if you have a

00:38:44,719 --> 00:38:48,499
large complicated piece of hardware with

00:38:46,729 --> 00:38:52,009
its own software development kit

00:38:48,499 --> 00:38:55,069
provided by say the manufacturer should

00:38:52,009 --> 00:39:12,079
you write a wrapper for that library and

00:38:55,069 --> 00:39:16,690
then have an own so ok the question is

00:39:12,079 --> 00:39:19,039
how do you deal with SDKs basically and

00:39:16,690 --> 00:39:21,319
the problem is of course is that they

00:39:19,039 --> 00:39:23,539
come from various manufacturers than the

00:39:21,319 --> 00:39:25,999
quality can be high it can be low they

00:39:23,539 --> 00:39:28,190
can be buggy they can be all kinds of

00:39:25,999 --> 00:39:32,029
things they could force you to install

00:39:28,190 --> 00:39:33,709
they could just be headers so it really

00:39:32,029 --> 00:39:38,119
depends on your specific application

00:39:33,709 --> 00:39:42,229
I've worked with a few and I see them

00:39:38,119 --> 00:39:44,989
traditionally as replacing the library

00:39:42,229 --> 00:39:48,109
in my driver development stage so I will

00:39:44,989 --> 00:39:50,209
use these as the library phase and just

00:39:48,109 --> 00:39:52,489
write a thin Ross wrapper across their

00:39:50,209 --> 00:39:59,690
library and if they did a good job

00:39:52,489 --> 00:40:01,249
I have an easy way to go and and I

00:39:59,690 --> 00:40:03,140
likely will have to change

00:40:01,249 --> 00:40:05,299
representations once because their

00:40:03,140 --> 00:40:08,239
library will support whatever data type

00:40:05,299 --> 00:40:12,219
they come with and then I will just

00:40:08,239 --> 00:40:17,089
translate that to Ross and publish and

00:40:12,219 --> 00:40:19,849
does that answer your question yeah so

00:40:17,089 --> 00:40:21,680
it depends on the manufacturer if they

00:40:19,849 --> 00:40:25,690
did a good job your jobs easy if they

00:40:21,680 --> 00:40:25,690

YouTube URL: https://www.youtube.com/watch?v=pagC2WXT1x0


