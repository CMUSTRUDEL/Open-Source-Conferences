Title: ROSCon 2012 - Motion Planning in ROS
Publication date: 2014-08-31
Playlist: ROSCon 2012
Description: 
	Ioan Sucan, Sachin Chitta
Motion Planning in ROS
Captions: 
	00:00:07,040 --> 00:00:14,010
thanks a lot David for a fantastic talk

00:00:11,520 --> 00:00:15,120
my name is Sachin chicka I'm from Willow

00:00:14,010 --> 00:00:19,020
Garage

00:00:15,120 --> 00:00:21,750
and I'm actually representing a huge

00:00:19,020 --> 00:00:23,630
motion planning community that works on

00:00:21,750 --> 00:00:26,939
the motion planning confidence in Ross

00:00:23,630 --> 00:00:27,840
and this talk is together with my

00:00:26,939 --> 00:00:32,580
colleagues

00:00:27,840 --> 00:00:36,600
Johann Chacon and Gil Jones who are both

00:00:32,580 --> 00:00:38,309
sitting on the side so no one's going to

00:00:36,600 --> 00:00:42,840
give part of this talk I'll start off

00:00:38,309 --> 00:00:45,059
and he'll give part of the talk so what

00:00:42,840 --> 00:00:47,610
am I going to talk about a lot of you

00:00:45,059 --> 00:00:49,350
know about the motion planning stacks in

00:00:47,610 --> 00:00:52,170
Ross and you're probably already using

00:00:49,350 --> 00:00:55,070
them but there's probably a lot of you

00:00:52,170 --> 00:00:58,110
who don't know exactly what they do and

00:00:55,070 --> 00:01:00,239
what you can use them for and the idea

00:00:58,110 --> 00:01:04,530
behind this talk is to give you

00:01:00,239 --> 00:01:06,750
information about what you can do with

00:01:04,530 --> 00:01:08,450
all the tools that we have in Ross and

00:01:06,750 --> 00:01:11,130
I'll show you some examples of things

00:01:08,450 --> 00:01:13,229
that we've been able to do so that you

00:01:11,130 --> 00:01:16,590
can see how you can take these things

00:01:13,229 --> 00:01:18,330
and apply them to your own robots so

00:01:16,590 --> 00:01:21,060
sort of the traditional definition of

00:01:18,330 --> 00:01:25,770
motion planning is you're trying to plan

00:01:21,060 --> 00:01:27,630
and execute motions for a robot under a

00:01:25,770 --> 00:01:30,180
given set of constraints and the typical

00:01:27,630 --> 00:01:32,520
set of constraints that most of you are

00:01:30,180 --> 00:01:34,799
familiar with collision constraints so

00:01:32,520 --> 00:01:37,860
you're saying I want robot the robot to

00:01:34,799 --> 00:01:39,509
get from point A to point B without

00:01:37,860 --> 00:01:42,060
colliding with anything but there's

00:01:39,509 --> 00:01:44,040
other sets of constraints that we can

00:01:42,060 --> 00:01:47,790
deal with as well which we'll talk about

00:01:44,040 --> 00:01:51,720
as we go through the talk so here's an

00:01:47,790 --> 00:01:54,210
outline I'll talk about you know the the

00:01:51,720 --> 00:01:57,540
past results we've had and sort of the

00:01:54,210 --> 00:01:59,930
success stories mainly briefly about the

00:01:57,540 --> 00:02:03,060
base navigation stack which is probably

00:01:59,930 --> 00:02:06,780
the most familiar stack for most people

00:02:03,060 --> 00:02:09,179
using Ross with mobile robots I'll talk

00:02:06,780 --> 00:02:11,610
about the our navigation stacks the

00:02:09,179 --> 00:02:14,580
tools that you can use with these and

00:02:11,610 --> 00:02:17,930
then my colleague John will introduce

00:02:14,580 --> 00:02:17,930
you to the future so

00:02:18,810 --> 00:02:24,330
so the armed navigation stacks are

00:02:22,020 --> 00:02:28,280
basically the Rost components that you

00:02:24,330 --> 00:02:31,400
would use to do motion planning for

00:02:28,280 --> 00:02:34,740
manipulators and we started this effort

00:02:31,400 --> 00:02:37,319
almost I think about four years back

00:02:34,740 --> 00:02:40,410
almost four years back and the idea was

00:02:37,319 --> 00:02:43,250
to develop a set of stacks a set of

00:02:40,410 --> 00:02:46,230
capabilities so that you could use

00:02:43,250 --> 00:02:49,890
motion planning on the pr2 robot that

00:02:46,230 --> 00:02:53,160
was a initial focus and our current

00:02:49,890 --> 00:02:54,780
approach we have so the meat of the of

00:02:53,160 --> 00:02:58,080
these tags is of course the motion

00:02:54,780 --> 00:03:00,570
planners and we have you know as we've

00:02:58,080 --> 00:03:02,580
gone through the years we've tried

00:03:00,570 --> 00:03:04,080
different approaches so we have three

00:03:02,580 --> 00:03:08,670
different approaches that you can now

00:03:04,080 --> 00:03:11,190
use one is the sampling based planners

00:03:08,670 --> 00:03:15,390
and these come from the O MPL library

00:03:11,190 --> 00:03:18,480
this comes out of radio Caracas lab in

00:03:15,390 --> 00:03:21,930
rice there's the search phase planners

00:03:18,480 --> 00:03:24,480
which come from which are in this s BPL

00:03:21,930 --> 00:03:28,769
library and they come out of max

00:03:24,480 --> 00:03:32,040
ligatures lab at CMU and stochastic

00:03:28,769 --> 00:03:34,829
trajectory optimization approaches again

00:03:32,040 --> 00:03:39,420
one of them coming from CMU and the

00:03:34,829 --> 00:03:42,840
other one was a joint willow USC effort

00:03:39,420 --> 00:03:44,610
and so you you can see from oh just let

00:03:42,840 --> 00:03:47,280
the movies play again so you can see

00:03:44,610 --> 00:03:49,890
from these movies some of the things

00:03:47,280 --> 00:03:54,269
that we've been able to do with these

00:03:49,890 --> 00:03:57,600
stacks our primary goal was picking

00:03:54,269 --> 00:04:00,090
plays so we want it to be in sort of

00:03:57,600 --> 00:04:03,079
unstructured environments with different

00:04:00,090 --> 00:04:08,040
kinds of objects and try to pick them up

00:04:03,079 --> 00:04:11,040
and put them down effectively and this

00:04:08,040 --> 00:04:16,109
is our current state of the art it's the

00:04:11,040 --> 00:04:19,440
Ross manipulation pipeline this work at

00:04:16,109 --> 00:04:21,600
willow with hygiene and Matei who a lot

00:04:19,440 --> 00:04:24,169
of you know do a lot of our manipulation

00:04:21,600 --> 00:04:26,580
and grasping work so we call this

00:04:24,169 --> 00:04:28,560
manipulation or grasping pipeline and

00:04:26,580 --> 00:04:32,030
what this movie shows you is sort of the

00:04:28,560 --> 00:04:35,240
entire flow of what's going on

00:04:32,030 --> 00:04:38,630
with the manipulation pipeline oh I'll

00:04:35,240 --> 00:04:41,690
just let it start again so it starts off

00:04:38,630 --> 00:04:46,070
with the perception parts so we're

00:04:41,690 --> 00:04:49,010
taking in raw sensor data from all the

00:04:46,070 --> 00:04:51,520
sensors on the on the pr2 robot and

00:04:49,010 --> 00:04:53,830
we're trying to build up a consistent

00:04:51,520 --> 00:04:56,060
representation of the environment and

00:04:53,830 --> 00:04:58,580
there's a lot of little things you have

00:04:56,060 --> 00:05:01,010
to do to get this right data from

00:04:58,580 --> 00:05:04,610
sensors is noisy you have to filter it

00:05:01,010 --> 00:05:07,370
so we're taking out for example the arms

00:05:04,610 --> 00:05:12,200
of the robot itself which include these

00:05:07,370 --> 00:05:15,080
sensors we're building up an environment

00:05:12,200 --> 00:05:18,130
using a package called octo map this

00:05:15,080 --> 00:05:21,020
comes out of the University of Fribourg

00:05:18,130 --> 00:05:24,920
we're doing segmentation and recognition

00:05:21,020 --> 00:05:27,500
and this is based on in-house object

00:05:24,920 --> 00:05:29,450
detection routines so basically the

00:05:27,500 --> 00:05:32,470
robot is building up this continuous

00:05:29,450 --> 00:05:35,210
model of the world once it does that it

00:05:32,470 --> 00:05:38,840
figures out grasps and there's two ways

00:05:35,210 --> 00:05:41,120
of doing this either we can do it online

00:05:38,840 --> 00:05:45,230
just using the point clouds themselves

00:05:41,120 --> 00:05:47,480
or we do a lot of stuff offline for

00:05:45,230 --> 00:05:49,760
certain objects using a software called

00:05:47,480 --> 00:05:53,450
grasp it which comes out of Columbia

00:05:49,760 --> 00:05:55,700
University so using a combination of all

00:05:53,450 --> 00:05:57,800
these we can build out live a

00:05:55,700 --> 00:05:59,480
representation of the environment we can

00:05:57,800 --> 00:06:01,100
generate grasps and this is where the

00:05:59,480 --> 00:06:04,340
motion planning comes in once you have

00:06:01,100 --> 00:06:06,370
the graphs you say how do I get to and

00:06:04,340 --> 00:06:10,250
execute these graphs and that's where

00:06:06,370 --> 00:06:13,669
the motion planning pipeline it finds

00:06:10,250 --> 00:06:15,440
its main use so this demo that you're

00:06:13,669 --> 00:06:17,870
actually seeing is sort of our standard

00:06:15,440 --> 00:06:21,020
demo that we take to conferences and

00:06:17,870 --> 00:06:22,790
here the goal of the rope the robot is

00:06:21,020 --> 00:06:25,610
basically trying to move all the objects

00:06:22,790 --> 00:06:28,220
one from one side to the other side and

00:06:25,610 --> 00:06:31,190
this demo has been expanded on and it's

00:06:28,220 --> 00:06:34,490
been used on multiple robots now and

00:06:31,190 --> 00:06:36,169
it's fairly robust and there's in

00:06:34,490 --> 00:06:39,140
addition to all these elements there's

00:06:36,169 --> 00:06:42,560
all also a set of little things that we

00:06:39,140 --> 00:06:45,110
do put particular problems that we can

00:06:42,560 --> 00:06:45,660
address so one of them is constrained

00:06:45,110 --> 00:06:48,480
planning's

00:06:45,660 --> 00:06:49,860
a lot of times when you're doing motion

00:06:48,480 --> 00:06:51,450
planning when you're doing moving

00:06:49,860 --> 00:06:53,940
objects around you want to keep them

00:06:51,450 --> 00:06:56,310
upright and this is one of the things

00:06:53,940 --> 00:06:58,050
the additional constraints apart from

00:06:56,310 --> 00:07:02,130
just collision constraints that you can

00:06:58,050 --> 00:07:05,070
impose on a motion planner we want to be

00:07:02,130 --> 00:07:07,640
robust to sensor uncertainty we want to

00:07:05,070 --> 00:07:11,790
be robust to errors in object detection

00:07:07,640 --> 00:07:13,580
so our grasping is actually reactive in

00:07:11,790 --> 00:07:17,250
the sense that it can actually correct

00:07:13,580 --> 00:07:19,740
in in a lot of cases for any error that

00:07:17,250 --> 00:07:21,330
you know you detect the object wrong or

00:07:19,740 --> 00:07:24,270
you don't know exactly where it is

00:07:21,330 --> 00:07:28,250
because your calibration is off and you

00:07:24,270 --> 00:07:28,250
can deal with all these kinds of things

00:07:28,490 --> 00:07:34,290
the the stag that you are most familiar

00:07:31,650 --> 00:07:39,630
with and this comes out of work at

00:07:34,290 --> 00:07:42,810
Willow by 8:00 on martyr Epstein Bryan

00:07:39,630 --> 00:07:44,640
Tully and Curt and a lot of people is

00:07:42,810 --> 00:07:47,670
the 2d navigation stack

00:07:44,640 --> 00:07:51,240
I think this stack has now been ported

00:07:47,670 --> 00:07:54,110
to tens if not hundreds of robots it

00:07:51,240 --> 00:07:57,540
probably is the most widely used

00:07:54,110 --> 00:08:00,390
component in Ross right now and that is

00:07:57,540 --> 00:08:03,390
can a while back you didn't really

00:08:00,390 --> 00:08:06,300
believe the robot could do that and he

00:08:03,390 --> 00:08:09,720
was testing it out so it's one advantage

00:08:06,300 --> 00:08:12,060
of being at Willow is that we test our

00:08:09,720 --> 00:08:14,520
robots and now algorithms very hard it's

00:08:12,060 --> 00:08:20,430
a hostile environment for developing

00:08:14,520 --> 00:08:22,740
robot code so that was the 2d navigation

00:08:20,430 --> 00:08:24,930
stack but as two he started doing we've

00:08:22,740 --> 00:08:26,940
started moving towards more mobile

00:08:24,930 --> 00:08:28,650
manipulation tasks and as we started

00:08:26,940 --> 00:08:32,849
doing that with the pr2 the robot we

00:08:28,650 --> 00:08:35,130
realize the 2d navigation is not enough

00:08:32,849 --> 00:08:37,590
for for a few things that we wanted to

00:08:35,130 --> 00:08:40,740
so this is one example where the robot

00:08:37,590 --> 00:08:42,479
sort of has to slide under a table so

00:08:40,740 --> 00:08:45,300
that it can put things down and you can

00:08:42,479 --> 00:08:48,780
imagine if you're using a projected 2d

00:08:45,300 --> 00:08:51,330
map this is actually not possible and

00:08:48,780 --> 00:08:55,050
this is some work we did last year so

00:08:51,330 --> 00:08:57,750
our men and Mike Phillips Mike's not

00:08:55,050 --> 00:09:00,300
here but Armen is here somewhere

00:08:57,750 --> 00:09:02,070
oh there he is

00:09:00,300 --> 00:09:04,140
Armand's from the University of Freiburg

00:09:02,070 --> 00:09:06,660
and he worked on what we call the 3d

00:09:04,140 --> 00:09:09,390
navigation stack so what you see here is

00:09:06,660 --> 00:09:16,230
a representation of one of the Willow

00:09:09,390 --> 00:09:20,070
labs in in octoman which is a software

00:09:16,230 --> 00:09:23,010
that Freiburg developed to represent

00:09:20,070 --> 00:09:25,500
large areas using octrees and basically

00:09:23,010 --> 00:09:27,779
what we're doing here is doing full 3d

00:09:25,500 --> 00:09:30,540
collision checking so that we can deal

00:09:27,779 --> 00:09:32,730
with tasks where the robot needs to get

00:09:30,540 --> 00:09:35,190
closer to obstacles and actually

00:09:32,730 --> 00:09:39,690
manipulate obstacles so in this case the

00:09:35,190 --> 00:09:43,070
robot has to move a laundry basket from

00:09:39,690 --> 00:09:47,400
one part of the room to the other and

00:09:43,070 --> 00:09:49,490
over here we're using the SPL library

00:09:47,400 --> 00:09:51,839
for all the motion planning and

00:09:49,490 --> 00:09:53,700
essentially if you if you've done

00:09:51,839 --> 00:09:55,650
collision checking you'll know that 3d

00:09:53,700 --> 00:09:59,130
collisions full-body 3d collision checks

00:09:55,650 --> 00:10:02,160
are expensive so we came up with some

00:09:59,130 --> 00:10:04,650
neat different ways of doing it some

00:10:02,160 --> 00:10:06,720
hierarchical ways of doing it so that we

00:10:04,650 --> 00:10:11,040
would not have to do 3d collision checks

00:10:06,720 --> 00:10:12,450
most of the time and the robot had to

00:10:11,040 --> 00:10:16,170
get through a fairly constrained

00:10:12,450 --> 00:10:18,089
environment and we deliberately set it

00:10:16,170 --> 00:10:20,490
up so that it had to do that and you can

00:10:18,089 --> 00:10:23,339
see that it was pretty successful and

00:10:20,490 --> 00:10:24,779
getting through the set of chairs and

00:10:23,339 --> 00:10:27,330
you can also see it's sort of looking

00:10:24,779 --> 00:10:32,130
around to see which direction is going

00:10:27,330 --> 00:10:34,200
in so the the intention of showing you

00:10:32,130 --> 00:10:37,020
some of these demos is to give you an

00:10:34,200 --> 00:10:40,140
idea of what you can do with the set of

00:10:37,020 --> 00:10:43,140
capabilities that we have in Ross right

00:10:40,140 --> 00:10:47,040
now so all the arm navigation stuff is

00:10:43,140 --> 00:10:49,620
in electric it's in Forte and you can

00:10:47,040 --> 00:10:52,200
use it the 3d navigation stuff is also

00:10:49,620 --> 00:10:56,940
there but we're working on improving it

00:10:52,200 --> 00:11:01,020
and we should have it out later so we

00:10:56,940 --> 00:11:03,510
did a lot of this effort and you know in

00:11:01,020 --> 00:11:05,370
the beginning we were doing a lot of

00:11:03,510 --> 00:11:08,400
stuff with the pr2 robot that was sort

00:11:05,370 --> 00:11:11,100
of our so robot that we had in-house to

00:11:08,400 --> 00:11:12,720
do stuff but we were always aware of the

00:11:11,100 --> 00:11:16,319
fact that other people would want

00:11:12,720 --> 00:11:18,810
use this and from the beginning we tried

00:11:16,319 --> 00:11:21,360
to keep our stacks as generic as

00:11:18,810 --> 00:11:23,910
possible we tried not to make them very

00:11:21,360 --> 00:11:27,120
PR too specific and this is some work

00:11:23,910 --> 00:11:30,269
actually that Gail Jones dead he's in

00:11:27,120 --> 00:11:32,819
the corner over there this is the arm

00:11:30,269 --> 00:11:36,149
navigation wizard and basically what

00:11:32,819 --> 00:11:39,660
this helps you do is port all these

00:11:36,149 --> 00:11:42,240
stacks to your robot so basically you

00:11:39,660 --> 00:11:44,790
get the you RDF for your robot that

00:11:42,240 --> 00:11:49,860
David just described and that's the

00:11:44,790 --> 00:11:52,379
input to the stack you can define chains

00:11:49,860 --> 00:11:54,209
you can define certain collision

00:11:52,379 --> 00:11:57,000
properties and you basically you can

00:11:54,209 --> 00:11:59,850
create you can sort of auto create all

00:11:57,000 --> 00:12:01,740
the configuration files that you need to

00:11:59,850 --> 00:12:04,860
run the motion planning stacks on gyro

00:12:01,740 --> 00:12:07,470
bars and once you do that you can test

00:12:04,860 --> 00:12:11,069
these out again in the toe in a tool

00:12:07,470 --> 00:12:12,750
that Gil and his interns wrote in the

00:12:11,069 --> 00:12:15,660
tool called the warehouse viewer so this

00:12:12,750 --> 00:12:17,759
is basically a simulated environment in

00:12:15,660 --> 00:12:20,189
you in which you can test out motion

00:12:17,759 --> 00:12:21,839
planning so you can basically ask the

00:12:20,189 --> 00:12:24,029
planner what are you going to do you can

00:12:21,839 --> 00:12:26,129
actually visualize that and test and

00:12:24,029 --> 00:12:27,620
look at it before you start doing this

00:12:26,129 --> 00:12:30,059
on the robot and this can directly

00:12:27,620 --> 00:12:33,240
connect to the robot as well so in this

00:12:30,059 --> 00:12:34,949
you can create walls simple worlds you

00:12:33,240 --> 00:12:37,230
could create motion plan requests so you

00:12:34,949 --> 00:12:39,569
say I want to go from here to there you

00:12:37,230 --> 00:12:42,629
can log all this you can store all this

00:12:39,569 --> 00:12:44,250
information and we retry it later you

00:12:42,629 --> 00:12:47,639
can introspect into different parts of

00:12:44,250 --> 00:12:50,939
the pipeline and this these two tools I

00:12:47,639 --> 00:12:53,309
think have made the the Ross motion

00:12:50,939 --> 00:12:55,759
planning stacks really portable we've

00:12:53,309 --> 00:12:59,279
seen a lot of people actually use these

00:12:55,759 --> 00:13:02,430
to port they're capable to port our

00:12:59,279 --> 00:13:05,040
capabilities on to their robots and we

00:13:02,430 --> 00:13:08,639
if you want more information on this we

00:13:05,040 --> 00:13:11,160
did a tutorial at Aris last year and

00:13:08,639 --> 00:13:15,209
there's a pretty extensive documentation

00:13:11,160 --> 00:13:17,100
on that website that you can look at so

00:13:15,209 --> 00:13:19,350
look for the tutorial document and that

00:13:17,100 --> 00:13:22,649
gives you a step-by-step way of going

00:13:19,350 --> 00:13:24,730
through these tools and and getting

00:13:22,649 --> 00:13:26,530
these things applied on your own

00:13:24,730 --> 00:13:29,440
I think our slides will be up on the

00:13:26,530 --> 00:13:33,210
website so you should you will be able

00:13:29,440 --> 00:13:40,240
to get this information later as well so

00:13:33,210 --> 00:13:42,490
we took all this where's Sean Sean

00:13:40,240 --> 00:13:46,600
Edwards is in the back and so Sean

00:13:42,490 --> 00:13:50,920
Edwards came down from spory to Bulaga

00:13:46,600 --> 00:13:55,510
ROG to teach us how to make good videos

00:13:50,920 --> 00:13:58,600
with music in them no he actually came

00:13:55,510 --> 00:14:01,170
down to see what we were doing with our

00:13:58,600 --> 00:14:04,720
manipulation stacks and apply it to

00:14:01,170 --> 00:14:07,150
industrial robots and it was actually a

00:14:04,720 --> 00:14:10,120
fantastic effort so this is a joint

00:14:07,150 --> 00:14:13,660
collaboration between swari

00:14:10,120 --> 00:14:17,110
yes the telerobotics and Willow Garage

00:14:13,660 --> 00:14:19,660
and a lot of people at Willow were

00:14:17,110 --> 00:14:21,670
involved in this as well and essentially

00:14:19,660 --> 00:14:24,130
it took a lot of the capabilities that

00:14:21,670 --> 00:14:28,210
we have and ported it onto this modern

00:14:24,130 --> 00:14:31,810
an arm you can see that there is a

00:14:28,210 --> 00:14:35,080
different hand also on the arm I won't

00:14:31,810 --> 00:14:37,960
speak too much about that but we can

00:14:35,080 --> 00:14:40,240
also you know generate browse for these

00:14:37,960 --> 00:14:44,760
new types of hands so this is a robot IQ

00:14:40,240 --> 00:14:44,760
hand and you can use our soft

00:14:45,700 --> 00:14:55,850
so the other part that we did is just

00:14:52,570 --> 00:14:57,890
this was just last week we did the it

00:14:55,850 --> 00:15:00,650
mobile manipulation challenge which was

00:14:57,890 --> 00:15:03,080
sort of an application of everything

00:15:00,650 --> 00:15:05,360
that we wanted to do so in this case the

00:15:03,080 --> 00:15:08,240
robot was supposed to act like a waiter

00:15:05,360 --> 00:15:10,910
in a typical sushi restaurant so it had

00:15:08,240 --> 00:15:13,580
the clear tables pick up things from

00:15:10,910 --> 00:15:16,090
tables set tables I tried to pick up

00:15:13,580 --> 00:15:19,820
things from a rotating turntable and

00:15:16,090 --> 00:15:22,100
this really pushed us from a lot of the

00:15:19,820 --> 00:15:24,770
tabletop manipulation things that we've

00:15:22,100 --> 00:15:26,890
been doing so far into actual mobile

00:15:24,770 --> 00:15:29,300
manipulations and this is one of the

00:15:26,890 --> 00:15:31,340
thrusts of what we're going to do in the

00:15:29,300 --> 00:15:33,260
future we want to be able to do stuff

00:15:31,340 --> 00:15:36,110
where the robots are actually moving

00:15:33,260 --> 00:15:39,170
around and manipulating things as they

00:15:36,110 --> 00:15:42,740
do with that so a lot of these videos

00:15:39,170 --> 00:15:45,530
will be online soon so you can see all

00:15:42,740 --> 00:15:48,470
this with that I'm actually going to

00:15:45,530 --> 00:15:51,560
hand over the mic to you on shu-kun

00:15:48,470 --> 00:15:56,600
who's going to talk about our future

00:15:51,560 --> 00:15:59,350
efforts after he does a little bed that

00:15:56,600 --> 00:15:59,350
I had with him

00:16:32,040 --> 00:16:39,070
all right so with that said I was

00:16:37,720 --> 00:16:41,290
actually supposed to do a dance here

00:16:39,070 --> 00:16:43,300
because I always made such and show this

00:16:41,290 --> 00:16:45,279
video whenever he talks about move it so

00:16:43,300 --> 00:16:46,450
he said okay I'll show it but the next

00:16:45,279 --> 00:16:47,250
time you talk about it you're gonna

00:16:46,450 --> 00:16:49,420
dance

00:16:47,250 --> 00:16:53,829
unfortunately Sachin I'm really sorry I

00:16:49,420 --> 00:16:55,510
forgot my dancing shoes home so so I'm

00:16:53,829 --> 00:16:58,649
going to talk about current and future

00:16:55,510 --> 00:17:01,500
efforts in motion planning and Ross

00:16:58,649 --> 00:17:04,900
alright so can you hear me

00:17:01,500 --> 00:17:07,089
so movement is really an evolution of

00:17:04,900 --> 00:17:09,939
the our navigation our navigation

00:17:07,089 --> 00:17:11,260
software stack we learned a lot

00:17:09,939 --> 00:17:14,199
developing the uh navigation software

00:17:11,260 --> 00:17:17,470
stack we made a lot of mistakes lots of

00:17:14,199 --> 00:17:19,740
things were good and now we're trying to

00:17:17,470 --> 00:17:21,850
incorporate the lessons we learned and

00:17:19,740 --> 00:17:23,439
develop a piece of software that is

00:17:21,850 --> 00:17:25,089
better from a software engineering point

00:17:23,439 --> 00:17:27,699
of view and it incorporates new

00:17:25,089 --> 00:17:30,520
capabilities solutions to problems that

00:17:27,699 --> 00:17:33,520
we found and understood while developing

00:17:30,520 --> 00:17:37,530
the UH navigation stack so what we're

00:17:33,520 --> 00:17:40,150
trying to get is a package that is

00:17:37,530 --> 00:17:42,040
intended to help develop it to help

00:17:40,150 --> 00:17:43,510
developing applications that need motion

00:17:42,040 --> 00:17:45,190
planning and this package should be

00:17:43,510 --> 00:17:47,530
efficient it should be generic it should

00:17:45,190 --> 00:17:49,179
be easily extendable and robust and I'm

00:17:47,530 --> 00:17:50,950
going to go I'm going to go into a

00:17:49,179 --> 00:17:52,720
little bit of detail on each of these

00:17:50,950 --> 00:17:56,080
attributes and feel free to ask

00:17:52,720 --> 00:17:57,580
questions so what is move it well it's a

00:17:56,080 --> 00:17:59,260
package that moves things where it

00:17:57,580 --> 00:18:01,450
stands for pretty much anything that has

00:17:59,260 --> 00:18:03,910
actuators initially our navigation was

00:18:01,450 --> 00:18:07,419
geared for arms this is gear for arms as

00:18:03,910 --> 00:18:09,130
well but I mean I guess it's not geared

00:18:07,419 --> 00:18:11,320
for arms it's geared for any groups of

00:18:09,130 --> 00:18:13,090
joints that the robot can can have and

00:18:11,320 --> 00:18:14,410
from a high level perspective it does

00:18:13,090 --> 00:18:16,660
the same thing as the our navigation

00:18:14,410 --> 00:18:18,340
given some sort of input which is

00:18:16,660 --> 00:18:21,550
typically the description of the robot

00:18:18,340 --> 00:18:23,530
and this is really like you RDF s RDF

00:18:21,550 --> 00:18:24,470
type of data that David was presenting

00:18:23,530 --> 00:18:26,990
earlier

00:18:24,470 --> 00:18:30,289
and optionally sensor data this thing

00:18:26,990 --> 00:18:32,450
can produce path plans that typically

00:18:30,289 --> 00:18:37,909
are sent to client libraries usually

00:18:32,450 --> 00:18:40,940
your controllers but not necessarily so

00:18:37,909 --> 00:18:43,190
let me give you an overview of what move

00:18:40,940 --> 00:18:46,190
it actually contains so to begin with

00:18:43,190 --> 00:18:47,840
move it can represent robots it can

00:18:46,190 --> 00:18:50,270
represent geometry so the meshes that

00:18:47,840 --> 00:18:52,240
are loaded from the you RDF it can

00:18:50,270 --> 00:18:54,080
represent the links that joints

00:18:52,240 --> 00:18:55,940
essentially the degrees of freedom that

00:18:54,080 --> 00:18:58,010
you're going to be planning for and we

00:18:55,940 --> 00:18:59,750
support mimic joints this is a new

00:18:58,010 --> 00:19:01,640
feature that we added and it's available

00:18:59,750 --> 00:19:04,039
with with the Ross where tab

00:19:01,640 --> 00:19:07,250
of course we parse the semantically

00:19:04,039 --> 00:19:10,010
description as well and this essentially

00:19:07,250 --> 00:19:12,650
allows allows planning algorithms to

00:19:10,010 --> 00:19:14,210
reason about robot configurations and if

00:19:12,650 --> 00:19:15,890
you have things like arms in your robot

00:19:14,210 --> 00:19:17,630
then you can do forward kinematics

00:19:15,890 --> 00:19:19,669
inverse kinematics with libraries such

00:19:17,630 --> 00:19:22,580
as KVL or your own custom solvers

00:19:19,669 --> 00:19:25,909
whatever you want now an inter an

00:19:22,580 --> 00:19:27,710
important step in in planning is the is

00:19:25,909 --> 00:19:30,740
making the decision of whether a state

00:19:27,710 --> 00:19:34,669
is valid or not what makes a state one

00:19:30,740 --> 00:19:36,380
that is ok to be in or one that we

00:19:34,669 --> 00:19:38,390
should avoid and in move it we define

00:19:36,380 --> 00:19:40,970
this to be the intersection of two

00:19:38,390 --> 00:19:42,799
constraints namely the state needs to be

00:19:40,970 --> 00:19:44,929
collision free and it needs to satisfy

00:19:42,799 --> 00:19:46,730
some additional user specified

00:19:44,929 --> 00:19:47,870
constraints so for the state to be

00:19:46,730 --> 00:19:49,580
collision free that's fairly obvious

00:19:47,870 --> 00:19:52,700
nobody wants robot arms to be

00:19:49,580 --> 00:19:55,159
overlapping with their TVs and for that

00:19:52,700 --> 00:19:58,520
we use the flexible collision checking

00:19:55,159 --> 00:20:01,460
library which was described I guess just

00:19:58,520 --> 00:20:05,090
a few days ago in a crowd and this is a

00:20:01,460 --> 00:20:06,559
very nice library as as opposed to the

00:20:05,090 --> 00:20:08,179
software that we had an obligation stack

00:20:06,559 --> 00:20:09,980
a very cool feature that I feel I should

00:20:08,179 --> 00:20:11,720
mention is that we can actually do

00:20:09,980 --> 00:20:13,510
collision checking in parallel this may

00:20:11,720 --> 00:20:16,880
not sound like much but it actually

00:20:13,510 --> 00:20:18,440
greatly increases the efficiency of

00:20:16,880 --> 00:20:19,669
software that uses this library because

00:20:18,440 --> 00:20:20,870
you can do multiple things in parallel

00:20:19,669 --> 00:20:23,000
you don't have to seer lies

00:20:20,870 --> 00:20:24,409
collision checking and we can do other

00:20:23,000 --> 00:20:26,750
things like probability of collision and

00:20:24,409 --> 00:20:29,570
so on now to complete the notion of a

00:20:26,750 --> 00:20:31,340
validity of a state we need to define

00:20:29,570 --> 00:20:33,409
what it means for a state to satisfy

00:20:31,340 --> 00:20:35,000
some constraints and into a general

00:20:33,409 --> 00:20:36,919
sense this is really you define a

00:20:35,000 --> 00:20:38,000
procedure that's called a constraint

00:20:36,919 --> 00:20:39,500
evaluator and

00:20:38,000 --> 00:20:41,870
given a state this constraint evaluator

00:20:39,500 --> 00:20:43,520
will say yes or no this state is good

00:20:41,870 --> 00:20:44,810
the state is bad it can give you

00:20:43,520 --> 00:20:46,400
additional information such as distance

00:20:44,810 --> 00:20:52,430
but gradients but that doesn't matter

00:20:46,400 --> 00:20:54,680
for this point so move it is we made an

00:20:52,430 --> 00:20:57,230
effort to work on the representation

00:20:54,680 --> 00:20:58,370
sampling an evaluation of constraints

00:20:57,230 --> 00:21:00,800
and I'm going to talk about this in a

00:20:58,370 --> 00:21:03,110
little bit more detail in a few slides

00:21:00,800 --> 00:21:04,280
but we have some types of constraints

00:21:03,110 --> 00:21:06,950
like joint constraints visibility

00:21:04,280 --> 00:21:08,600
constraints and these are already

00:21:06,950 --> 00:21:10,130
predefined but the users can specify

00:21:08,600 --> 00:21:12,080
their own types of constraints if you

00:21:10,130 --> 00:21:13,730
have your own robot that needs some sort

00:21:12,080 --> 00:21:18,320
of I don't know balancing constraints

00:21:13,730 --> 00:21:21,320
that's fine you can define those using

00:21:18,320 --> 00:21:22,670
this basic functionality you can you can

00:21:21,320 --> 00:21:24,500
actually implement motion planning and

00:21:22,670 --> 00:21:26,540
as such and mention we have multiple

00:21:24,500 --> 00:21:27,920
types of motion planners and this is

00:21:26,540 --> 00:21:29,870
implemented all as a generic interface

00:21:27,920 --> 00:21:31,880
and we support essentially three

00:21:29,870 --> 00:21:33,500
categories of planning algorithms the

00:21:31,880 --> 00:21:35,210
first category is sampling based motion

00:21:33,500 --> 00:21:37,940
planners which we take from the MPL

00:21:35,210 --> 00:21:40,670
library from from the cavity lab at Rice

00:21:37,940 --> 00:21:42,320
University we have search search based

00:21:40,670 --> 00:21:44,330
planning techniques the SV PL package

00:21:42,320 --> 00:21:46,430
from Max likhachev slab and I believe we

00:21:44,330 --> 00:21:48,170
have authors from both of these

00:21:46,430 --> 00:21:50,120
libraries in the audience so you can

00:21:48,170 --> 00:21:51,890
contact them later we also have

00:21:50,120 --> 00:21:54,020
optimization optimization based planning

00:21:51,890 --> 00:21:55,790
such as jump and stomp I'm not sure I

00:21:54,020 --> 00:21:57,260
haven't seen any of the authors in the

00:21:55,790 --> 00:22:02,960
audience but raise your hand if you're

00:21:57,260 --> 00:22:04,970
here alright so once you actually obtain

00:22:02,960 --> 00:22:06,880
a motion plan you probably want to

00:22:04,970 --> 00:22:08,900
execute it or at least visualize it and

00:22:06,880 --> 00:22:10,610
it's often the case that some of these

00:22:08,900 --> 00:22:12,890
planners don't necessarily produce the

00:22:10,610 --> 00:22:15,440
best quality of paths I'm sure all of

00:22:12,890 --> 00:22:18,500
you have seen like very weird wavy arm

00:22:15,440 --> 00:22:20,180
motions so a move it actually includes a

00:22:18,500 --> 00:22:22,400
lot of code on optimizing and time

00:22:20,180 --> 00:22:24,470
parameterizing trajectories and then

00:22:22,400 --> 00:22:26,060
these trajectories can be sent to the

00:22:24,470 --> 00:22:29,870
controller and monitored as they're

00:22:26,060 --> 00:22:31,340
being as they're being executed so there

00:22:29,870 --> 00:22:34,940
is software that essentially monitors

00:22:31,340 --> 00:22:37,640
sensor data and then if something that

00:22:34,940 --> 00:22:39,470
shouldn't happen happens like the arm

00:22:37,640 --> 00:22:42,770
moves where it's not supposed to move or

00:22:39,470 --> 00:22:45,560
the path becomes invalid then the

00:22:42,770 --> 00:22:49,190
execution is essentially stopped trying

00:22:45,560 --> 00:22:51,650
to get some safety in there of course

00:22:49,190 --> 00:22:52,370
there's a bunch of nice extras well

00:22:51,650 --> 00:22:54,680
nicest

00:22:52,370 --> 00:22:56,450
personal perspective I guess one of the

00:22:54,680 --> 00:22:59,570
main things is benchmarking so realize

00:22:56,450 --> 00:23:02,020
that while developing their navigation

00:22:59,570 --> 00:23:03,950
stack we couldn't even do things like

00:23:02,020 --> 00:23:07,190
regression testing in terms of

00:23:03,950 --> 00:23:10,300
performance so if if the performance of

00:23:07,190 --> 00:23:12,290
a planner dropped how could we tell and

00:23:10,300 --> 00:23:13,400
benchmarking can actually help with this

00:23:12,290 --> 00:23:15,920
because you can generate a set of

00:23:13,400 --> 00:23:19,130
benchmarks this week generate again next

00:23:15,920 --> 00:23:20,809
week and compare of course this this has

00:23:19,130 --> 00:23:23,360
other advantages as I mentioned in a

00:23:20,809 --> 00:23:24,950
second we can have historic stories of

00:23:23,360 --> 00:23:26,120
planning scenarios this actually exists

00:23:24,950 --> 00:23:29,570
in our navigation as well it's been

00:23:26,120 --> 00:23:31,220
developed by Vigo Jones there's a lot of

00:23:29,570 --> 00:23:33,170
visualization and debugging tools so in

00:23:31,220 --> 00:23:35,600
building this we actually run into bugs

00:23:33,170 --> 00:23:37,010
and we need to fix them and an approach

00:23:35,600 --> 00:23:38,690
we're following now is really we're

00:23:37,010 --> 00:23:40,250
developing the right tools to help us

00:23:38,690 --> 00:23:41,750
find those bugs in the hope that they

00:23:40,250 --> 00:23:44,150
will actually be useful for other users

00:23:41,750 --> 00:23:45,800
and we also have the automatic

00:23:44,150 --> 00:23:47,809
configuration tools that such and

00:23:45,800 --> 00:23:51,140
describe and these will be this will be

00:23:47,809 --> 00:23:53,270
imported now I told you essentially what

00:23:51,140 --> 00:23:55,790
move it consists of let me talk about

00:23:53,270 --> 00:23:57,559
the architecture for a little bit so if

00:23:55,790 --> 00:24:00,200
you have a running system with say

00:23:57,559 --> 00:24:02,150
whatever robot X I like to think of move

00:24:00,200 --> 00:24:04,040
it as a system that consists of four

00:24:02,150 --> 00:24:05,870
components three software components and

00:24:04,040 --> 00:24:08,090
a configuration component so the last

00:24:05,870 --> 00:24:09,740
one here is really robot specific or

00:24:08,090 --> 00:24:12,830
figurations essentially there are user

00:24:09,740 --> 00:24:14,840
settings but with the existing tools you

00:24:12,830 --> 00:24:18,640
can actually generate these these

00:24:14,840 --> 00:24:21,830
settings easier and the first three are

00:24:18,640 --> 00:24:24,350
software the first box is really not our

00:24:21,830 --> 00:24:26,960
software it's it's various third-party

00:24:24,350 --> 00:24:29,660
libraries such as MPLS ppl off the map

00:24:26,960 --> 00:24:31,190
and a number of other libraries the

00:24:29,660 --> 00:24:33,290
functionality I told you about in the

00:24:31,190 --> 00:24:35,570
previous slides is essentially in the

00:24:33,290 --> 00:24:37,970
core functionality box so this one here

00:24:35,570 --> 00:24:40,130
and the communication is separated from

00:24:37,970 --> 00:24:42,559
from these core libraries so everything

00:24:40,130 --> 00:24:45,170
that has to do with Ross parameters Ross

00:24:42,559 --> 00:24:47,480
topics services the type of

00:24:45,170 --> 00:24:51,650
communication that Ross enables is kept

00:24:47,480 --> 00:24:53,059
separate and of course using this is

00:24:51,650 --> 00:24:54,559
what you really want to do because it's

00:24:53,059 --> 00:24:57,050
much easier to use and much nicer and

00:24:54,559 --> 00:24:59,120
everything just works but we're going

00:24:57,050 --> 00:25:00,800
we're going for a modular design we're

00:24:59,120 --> 00:25:03,200
trying to have everything consist of a

00:25:00,800 --> 00:25:05,270
bunch of essentially C++ libraries that

00:25:03,200 --> 00:25:06,240
have lightweight dependencies so that if

00:25:05,270 --> 00:25:07,950
someone doesn't want to

00:25:06,240 --> 00:25:10,470
the whole thing they can just take

00:25:07,950 --> 00:25:15,420
library X and its dependencies and and

00:25:10,470 --> 00:25:16,860
just use that in addition to this we

00:25:15,420 --> 00:25:19,590
wanted to make everything easily

00:25:16,860 --> 00:25:22,020
extensible so there's this thing called

00:25:19,590 --> 00:25:23,820
plug-in Lib and Ross and pretty much

00:25:22,020 --> 00:25:26,250
everything we do

00:25:23,820 --> 00:25:27,570
well not everything but most thing most

00:25:26,250 --> 00:25:29,490
of the important components that people

00:25:27,570 --> 00:25:32,910
might we expect people might want to

00:25:29,490 --> 00:25:35,100
change or implemented as abstract api's

00:25:32,910 --> 00:25:36,780
like a base class and then there's a

00:25:35,100 --> 00:25:39,840
number of plugin implementations for

00:25:36,780 --> 00:25:41,100
that so we have generic interfaces for

00:25:39,840 --> 00:25:44,400
motion planners we have generic

00:25:41,100 --> 00:25:46,200
informations poor kid generic API for

00:25:44,400 --> 00:25:47,670
kinematics solvers for constraint

00:25:46,200 --> 00:25:51,809
samplers and a number of other

00:25:47,670 --> 00:25:53,670
components some key characteristics that

00:25:51,809 --> 00:25:56,010
we're trying to get with this design are

00:25:53,670 --> 00:25:58,200
that I'm just trying to underscore this

00:25:56,010 --> 00:26:00,530
so we really want a simple configuration

00:25:58,200 --> 00:26:03,480
we really want the user to just come

00:26:00,530 --> 00:26:07,500
bring the you RDF and that's RDF and

00:26:03,480 --> 00:26:09,360
then get planning for free also all of

00:26:07,500 --> 00:26:13,320
this needs to all of this was designed

00:26:09,360 --> 00:26:14,820
with efficiency in mind so our code is

00:26:13,320 --> 00:26:16,410
thread-safe I probably don't care about

00:26:14,820 --> 00:26:18,800
this but we were very very careful about

00:26:16,410 --> 00:26:24,050
cost correctness and things like that

00:26:18,800 --> 00:26:26,730
and now just to underscore again this

00:26:24,050 --> 00:26:28,950
our intention to make this general and

00:26:26,730 --> 00:26:31,320
generic we are actually I'm showing a

00:26:28,950 --> 00:26:33,420
demo of move it running on two different

00:26:31,320 --> 00:26:35,429
arms that are not the pr2 so this is the

00:26:33,420 --> 00:26:36,720
universal arm and the motorman arm this

00:26:35,429 --> 00:26:38,610
one is avoiding essentially self

00:26:36,720 --> 00:26:40,920
collision and this one is avoiding the

00:26:38,610 --> 00:26:45,809
FedEx box here this is our standard

00:26:40,920 --> 00:26:48,780
collision object if you want to see a

00:26:45,809 --> 00:26:51,750
demo of this Gil has it running in the

00:26:48,780 --> 00:26:56,780
exhibition section and you should be

00:26:51,750 --> 00:26:59,010
able to see it see it play live so

00:26:56,780 --> 00:27:02,070
because I don't actually have time to go

00:26:59,010 --> 00:27:04,710
into lots of details of like what move

00:27:02,070 --> 00:27:07,590
it has to offer I'm just gonna give you

00:27:04,710 --> 00:27:09,990
a sneak peak of some of the features

00:27:07,590 --> 00:27:11,520
some of the newer features that were not

00:27:09,990 --> 00:27:14,160
possible with the old software but are

00:27:11,520 --> 00:27:15,390
possible with move it and these are just

00:27:14,160 --> 00:27:17,669
these three they're multiplexing

00:27:15,390 --> 00:27:19,470
planners handling generic constraints

00:27:17,669 --> 00:27:23,039
and

00:27:19,470 --> 00:27:25,200
benchmarking so for multiplexing

00:27:23,039 --> 00:27:27,510
planners this is like we've had lots of

00:27:25,200 --> 00:27:29,610
discussions with with Gil and Sachin and

00:27:27,510 --> 00:27:31,860
talking about like what what can we do

00:27:29,610 --> 00:27:33,780
how should we organize things and a

00:27:31,860 --> 00:27:34,980
by-product that's really nice that comes

00:27:33,780 --> 00:27:36,780
out of the fact we have generic

00:27:34,980 --> 00:27:38,429
interfaces for planners is that we can

00:27:36,780 --> 00:27:40,380
multiplex them so you can define a

00:27:38,429 --> 00:27:42,929
generic planner that essentially looks

00:27:40,380 --> 00:27:45,659
like this box satisfies the same

00:27:42,929 --> 00:27:48,059
interface as the MPL chomp or sv PL

00:27:45,659 --> 00:27:49,500
planners it doesn't matter and then you

00:27:48,059 --> 00:27:52,380
can actually load multiple planners

00:27:49,500 --> 00:27:55,309
inside this box handle planning requests

00:27:52,380 --> 00:27:58,350
and then report the plan that was found

00:27:55,309 --> 00:28:00,120
quickest or the fan the plan that was

00:27:58,350 --> 00:28:03,059
found shortest whatever your constraints

00:28:00,120 --> 00:28:04,980
are so this this is really flexible I

00:28:03,059 --> 00:28:07,230
just wanted to show that a simple

00:28:04,980 --> 00:28:09,500
application that is actually trivial to

00:28:07,230 --> 00:28:11,340
do with with the current setup

00:28:09,500 --> 00:28:13,260
another thing I really want to talk

00:28:11,340 --> 00:28:17,390
about is constraints so this is really

00:28:13,260 --> 00:28:19,230
important everything from goals to

00:28:17,390 --> 00:28:20,970
conditions that you want to impose on

00:28:19,230 --> 00:28:23,070
paths are specified in terms of

00:28:20,970 --> 00:28:24,780
constraints so if you want to hold a

00:28:23,070 --> 00:28:26,850
glass of water up right when you're

00:28:24,780 --> 00:28:29,280
moving your robot or you're delivering a

00:28:26,850 --> 00:28:31,110
drink this is actually done with with

00:28:29,280 --> 00:28:33,659
specification of constraints and we have

00:28:31,110 --> 00:28:37,230
a couple of standard types of

00:28:33,659 --> 00:28:39,200
constraints and joint constraints are

00:28:37,230 --> 00:28:41,760
obvious you essentially just limit the

00:28:39,200 --> 00:28:44,280
space of sample values for that

00:28:41,760 --> 00:28:46,470
particular joint value task constraints

00:28:44,280 --> 00:28:47,909
are again fairly obvious the position

00:28:46,470 --> 00:28:49,860
constraints and orientation constraints

00:28:47,909 --> 00:28:51,630
imposed for particular robot links so

00:28:49,860 --> 00:28:54,870
here you typically would do things like

00:28:51,630 --> 00:28:56,789
inverse kinematics to generate states

00:28:54,870 --> 00:28:58,650
that satisfy these constraints and

00:28:56,789 --> 00:29:01,049
another thing that came out actually are

00:28:58,650 --> 00:29:03,539
out of our calibration process are the

00:29:01,049 --> 00:29:05,100
visibility constraints so your you might

00:29:03,539 --> 00:29:07,020
have seen up here to sort of moving a

00:29:05,100 --> 00:29:09,710
checkerboard in front of it like with

00:29:07,020 --> 00:29:11,730
with a pattern that it can recognize

00:29:09,710 --> 00:29:13,440
ideally you want it to hold a

00:29:11,730 --> 00:29:16,440
checkerboard such that it is in the view

00:29:13,440 --> 00:29:19,049
of the sensor and those are our

00:29:16,440 --> 00:29:20,340
visibility constraints now and when you

00:29:19,049 --> 00:29:22,440
actually want to do planning with

00:29:20,340 --> 00:29:25,110
constraints especially for sampling

00:29:22,440 --> 00:29:27,179
based planning a key a key component is

00:29:25,110 --> 00:29:30,270
actually generating states that satisfy

00:29:27,179 --> 00:29:31,860
these constraints and this is not this

00:29:30,270 --> 00:29:33,420
is this is this is an expensive process

00:29:31,860 --> 00:29:35,610
so as I said

00:29:33,420 --> 00:29:37,290
if you're doing if you're doing position

00:29:35,610 --> 00:29:39,690
constraints or annotation constraints

00:29:37,290 --> 00:29:42,390
you do inverse kinematics that's not

00:29:39,690 --> 00:29:44,850
slow but it's not exactly zero time

00:29:42,390 --> 00:29:45,840
either when you're doing visibility

00:29:44,850 --> 00:29:47,970
constraints we're actually doing this

00:29:45,840 --> 00:29:49,980
with rejection sampling and it turns out

00:29:47,970 --> 00:29:51,480
we're throwing away about ninety nine

00:29:49,980 --> 00:29:53,130
point three percent of the samples we

00:29:51,480 --> 00:29:56,580
generate so that's a lot of wasted

00:29:53,130 --> 00:29:58,350
effort so what we're doing is okay we

00:29:56,580 --> 00:30:00,690
know what the constraints could be have

00:29:58,350 --> 00:30:03,030
a set of constraints produce an offline

00:30:00,690 --> 00:30:04,890
do some offline computation generate a

00:30:03,030 --> 00:30:07,080
bunch of states and just store them so

00:30:04,890 --> 00:30:09,060
this is a form of learning it doesn't

00:30:07,080 --> 00:30:10,500
matter how much time or it doesn't

00:30:09,060 --> 00:30:12,690
really matter how much time the offline

00:30:10,500 --> 00:30:16,200
per line computation process takes

00:30:12,690 --> 00:30:18,030
because we we do it once then reload the

00:30:16,200 --> 00:30:20,310
states and then in the planning process

00:30:18,030 --> 00:30:21,270
we reuse this and we gain a lot of

00:30:20,310 --> 00:30:23,010
efficiency I'm not going to go into

00:30:21,270 --> 00:30:24,960
details on how this works I just want to

00:30:23,010 --> 00:30:26,700
show you some results so this this looks

00:30:24,960 --> 00:30:28,440
like like a lot of numbers don't try to

00:30:26,700 --> 00:30:31,500
read them I'll go through them or some

00:30:28,440 --> 00:30:33,210
of them in a bit so these are just two

00:30:31,500 --> 00:30:35,310
different problems with two different

00:30:33,210 --> 00:30:37,680
sets of constraints the visibility

00:30:35,310 --> 00:30:39,270
constraints are actually the ones in

00:30:37,680 --> 00:30:42,390
this image here with a checkerboard

00:30:39,270 --> 00:30:45,270
moving to avoid this obstacle and the

00:30:42,390 --> 00:30:47,790
dual arm constraints in the bottom part

00:30:45,270 --> 00:30:49,590
here are in this particular image where

00:30:47,790 --> 00:30:53,490
the robot is holding a tray at a

00:30:49,590 --> 00:30:54,930
particular orientation so for the

00:30:53,490 --> 00:30:56,190
visibility constraints if you just look

00:30:54,930 --> 00:30:58,290
at numbers I'm not sure you can actually

00:30:56,190 --> 00:30:59,670
see them so I'm gonna read them on the

00:30:58,290 --> 00:31:01,350
columns we have different sampling based

00:30:59,670 --> 00:31:04,230
algorithms and for each algorithm we

00:31:01,350 --> 00:31:08,730
report run time in seconds and success

00:31:04,230 --> 00:31:10,530
rate for varying sizes of the state

00:31:08,730 --> 00:31:12,570
database if you will be the result of

00:31:10,530 --> 00:31:15,570
the offline computation and on the top

00:31:12,570 --> 00:31:17,700
row we have the method that doesn't use

00:31:15,570 --> 00:31:19,590
any offline computation and the method

00:31:17,700 --> 00:31:21,120
that uses varying sizes of offline

00:31:19,590 --> 00:31:22,530
computation so if you just take the

00:31:21,120 --> 00:31:24,750
first algorithm here it takes like Oh

00:31:22,530 --> 00:31:26,310
point 95 seconds on average but if you

00:31:24,750 --> 00:31:27,870
use the data base it takes about point 3

00:31:26,310 --> 00:31:29,910
seconds so that's a factor of 3

00:31:27,870 --> 00:31:32,700
this algorithm takes about 3.9 seconds

00:31:29,910 --> 00:31:34,560
on average and 0.6 to 0.8 if you use the

00:31:32,700 --> 00:31:36,960
database if you look at this problem

00:31:34,560 --> 00:31:39,930
with the dual arm constraints remember

00:31:36,960 --> 00:31:41,610
this is this this this case you really

00:31:39,930 --> 00:31:43,590
have a close chain here so there's a lot

00:31:41,610 --> 00:31:46,200
of implicit inverse kinematics that

00:31:43,590 --> 00:31:46,600
that's that's being done to compute to

00:31:46,200 --> 00:31:49,450
compute

00:31:46,600 --> 00:31:50,410
States and here with the time limits

00:31:49,450 --> 00:31:53,919
that were actually imposed on the

00:31:50,410 --> 00:31:55,390
planners they barely were able to solve

00:31:53,919 --> 00:31:57,250
the problem so you get like two percent

00:31:55,390 --> 00:31:58,720
one percent success rate event and even

00:31:57,250 --> 00:32:00,960
when the planners do succeed the run

00:31:58,720 --> 00:32:03,669
times are high like this is nine seconds

00:32:00,960 --> 00:32:06,429
with with the database of constraints

00:32:03,669 --> 00:32:10,059
this says 0.2 seconds so this is this is

00:32:06,429 --> 00:32:12,340
a significant speed up another thing

00:32:10,059 --> 00:32:14,350
that I'm really fond of is is

00:32:12,340 --> 00:32:16,270
benchmarking say you have your favorite

00:32:14,350 --> 00:32:18,370
robot and you know what environment

00:32:16,270 --> 00:32:21,159
you're going to be using it in what

00:32:18,370 --> 00:32:23,080
planner should you use I don't think

00:32:21,159 --> 00:32:25,840
there's such a thing as a best planner

00:32:23,080 --> 00:32:28,030
there that can be used for any situation

00:32:25,840 --> 00:32:29,530
but for particular situations and

00:32:28,030 --> 00:32:31,600
particular robot you could identify

00:32:29,530 --> 00:32:33,250
perhaps a planet that does better for

00:32:31,600 --> 00:32:35,230
that particular situation so if you're

00:32:33,250 --> 00:32:36,970
in an industrial environment or some

00:32:35,230 --> 00:32:40,659
home environment maybe your choices

00:32:36,970 --> 00:32:41,980
should differ and we will build we built

00:32:40,659 --> 00:32:44,860
a benchmarking infrastructure that

00:32:41,980 --> 00:32:46,480
allows you to run many many planners run

00:32:44,860 --> 00:32:49,990
them many many times average results

00:32:46,480 --> 00:32:51,100
store them in a MySQL database and we're

00:32:49,990 --> 00:32:53,409
also putting all of this information

00:32:51,100 --> 00:32:53,830
online so this is a print screen of a

00:32:53,409 --> 00:32:57,100
planner

00:32:53,830 --> 00:32:58,360
Arina org you can check it out but keep

00:32:57,100 --> 00:33:01,059
in mind this is a website still under

00:32:58,360 --> 00:33:02,980
construction and the intention is to

00:33:01,059 --> 00:33:06,460
have a number of planning algorithms

00:33:02,980 --> 00:33:08,380
described here and their performance

00:33:06,460 --> 00:33:10,150
presented for varying problems and we

00:33:08,380 --> 00:33:12,010
welcome here contributions of both our

00:33:10,150 --> 00:33:16,179
planning algorithms and problems so

00:33:12,010 --> 00:33:17,770
please please send those what I would

00:33:16,179 --> 00:33:20,169
hope to see is that at some point

00:33:17,770 --> 00:33:21,760
someone comes and says look I

00:33:20,169 --> 00:33:24,159
implemented this find you my new

00:33:21,760 --> 00:33:26,080
planning method it is available and move

00:33:24,159 --> 00:33:29,020
it and this is how well it does compared

00:33:26,080 --> 00:33:32,320
to other planners in in planner arena

00:33:29,020 --> 00:33:34,030
that work in terms of data that

00:33:32,320 --> 00:33:37,780
planetary nad organ cludes

00:33:34,030 --> 00:33:40,000
this is just an example so I'm I hope

00:33:37,780 --> 00:33:41,470
you can see it in the back this is

00:33:40,000 --> 00:33:43,059
really just a disk for every planner

00:33:41,470 --> 00:33:44,679
where the size of the disk is the memory

00:33:43,059 --> 00:33:46,929
the planner used the color represents

00:33:44,679 --> 00:33:49,510
the success rate blue means good success

00:33:46,929 --> 00:33:52,090
rate red means bad success rate so very

00:33:49,510 --> 00:33:53,830
low and the x axis corresponds to the

00:33:52,090 --> 00:33:56,650
solution time the y axis corresponds to

00:33:53,830 --> 00:33:58,150
the solution and the solution length if

00:33:56,650 --> 00:34:00,130
you don't like this this type of plots

00:33:58,150 --> 00:34:02,740
that's okay we have

00:34:00,130 --> 00:34:04,420
our plots - so you can just click and

00:34:02,740 --> 00:34:06,750
get this this is all Google charts by

00:34:04,420 --> 00:34:11,649
the way it's fantastic real easy to use

00:34:06,750 --> 00:34:14,889
can I hope you're working on that so

00:34:11,649 --> 00:34:17,110
that said I'm just gonna I'm just gonna

00:34:14,889 --> 00:34:18,850
stop talking about like current movie

00:34:17,110 --> 00:34:21,310
features and I'm just gonna mention a

00:34:18,850 --> 00:34:24,280
few new things things that we are

00:34:21,310 --> 00:34:26,860
looking to work on this summer or in the

00:34:24,280 --> 00:34:28,629
near medium future one of these is

00:34:26,860 --> 00:34:30,580
handling uncertainty so this is in

00:34:28,629 --> 00:34:31,929
connection to the fcl library like doing

00:34:30,580 --> 00:34:33,940
point cloud collision detection and

00:34:31,929 --> 00:34:35,980
things like that we want to continue on

00:34:33,940 --> 00:34:39,190
learning from experience so if the robot

00:34:35,980 --> 00:34:42,370
goes to the same area repeatedly it can

00:34:39,190 --> 00:34:44,290
remember what sets of pads are valid for

00:34:42,370 --> 00:34:46,750
that particular area and then reuse them

00:34:44,290 --> 00:34:48,850
there's no point in redoing all the

00:34:46,750 --> 00:34:50,320
computation over and over again we want

00:34:48,850 --> 00:34:52,810
to work on planning with dynamic

00:34:50,320 --> 00:34:54,730
constraints we want to work on better

00:34:52,810 --> 00:34:57,340
integration with grasping so right now

00:34:54,730 --> 00:34:59,290
unfortunately if you ever see the pr2

00:34:57,340 --> 00:35:02,320
grasping something like it's gonna come

00:34:59,290 --> 00:35:04,210
to an object stop and then move forward

00:35:02,320 --> 00:35:06,190
and actually complete the grasp the last

00:35:04,210 --> 00:35:08,260
the last step the little segment is

00:35:06,190 --> 00:35:10,030
actually it's actually a blind motion

00:35:08,260 --> 00:35:12,520
and we're trying to we're trying to

00:35:10,030 --> 00:35:14,680
replace that with with with safer

00:35:12,520 --> 00:35:17,260
computation we also want to work on

00:35:14,680 --> 00:35:19,090
tighter integration with sensing if you

00:35:17,260 --> 00:35:21,070
this is actually a long topic so if you

00:35:19,090 --> 00:35:23,830
have questions about this let me know

00:35:21,070 --> 00:35:26,380
but one thing that is very interesting

00:35:23,830 --> 00:35:29,050
to me is to use things like octo map to

00:35:26,380 --> 00:35:31,450
figure out where the occluded space is

00:35:29,050 --> 00:35:34,600
and and reason about that in the

00:35:31,450 --> 00:35:36,100
planning process this work would not

00:35:34,600 --> 00:35:37,960
have been possible without the

00:35:36,100 --> 00:35:40,150
contribution of many many many people

00:35:37,960 --> 00:35:43,360
and this list is probably not complete

00:35:40,150 --> 00:35:45,070
so if you see that your name not here

00:35:43,360 --> 00:35:48,640
and it should be here let us know but

00:35:45,070 --> 00:35:53,020
hopefully we got some so thank you all

00:35:48,640 --> 00:35:56,860
or for all your contributions in terms

00:35:53,020 --> 00:36:00,330
of like a concluding remark I just like

00:35:56,860 --> 00:36:03,970
to say that move it is intended to be a

00:36:00,330 --> 00:36:06,250
platform for application development it

00:36:03,970 --> 00:36:07,810
you can develop industrial applications

00:36:06,250 --> 00:36:11,920
you can develop research applications

00:36:07,810 --> 00:36:14,020
we're trying to gain feedback from the

00:36:11,920 --> 00:36:15,880
community so if you have suggestions

00:36:14,020 --> 00:36:17,800
from your experience of using our

00:36:15,880 --> 00:36:19,420
navigation stack or their particular

00:36:17,800 --> 00:36:21,280
things that you would like to see in

00:36:19,420 --> 00:36:24,160
this please let us know we're committed

00:36:21,280 --> 00:36:26,230
to developing these things and to

00:36:24,160 --> 00:36:28,240
solving new problems that that relate to

00:36:26,230 --> 00:36:30,850
motion planning and there's some more

00:36:28,240 --> 00:36:34,330
resources here on our navigation and

00:36:30,850 --> 00:36:35,740
move it this is not yet complete in the

00:36:34,330 --> 00:36:38,890
sense that we don't really have good

00:36:35,740 --> 00:36:41,310
tutorials and good documentation yet so

00:36:38,890 --> 00:36:45,010
we're not really advertising it too much

00:36:41,310 --> 00:36:46,930
also move across our org if you check it

00:36:45,010 --> 00:36:49,780
out you'll notice that's a website under

00:36:46,930 --> 00:36:52,630
construction but there's many ways that

00:36:49,780 --> 00:36:56,470
you can contribute and they are listed

00:36:52,630 --> 00:36:58,270
here and at this point I guess thank you

00:36:56,470 --> 00:37:02,080
very much for listening and if Sachin

00:36:58,270 --> 00:37:04,600
has any remarks that he'd like to add ok

00:37:02,080 --> 00:37:06,869
then I will take questions or we will

00:37:04,600 --> 00:37:06,869
take questions

00:37:13,509 --> 00:37:19,509
actually one last person I wanted the

00:37:17,019 --> 00:37:21,669
pine point out is from max like a chef

00:37:19,509 --> 00:37:24,459
slab sitting all the way at the back Ben

00:37:21,669 --> 00:37:27,999
Cohen one of our roschin volunteers and

00:37:24,459 --> 00:37:45,039
he develops the SPP l arm planners all

00:37:27,999 --> 00:37:47,499
the way in the back so the question was

00:37:45,039 --> 00:37:51,699
does the trajectory optimization have a

00:37:47,499 --> 00:37:55,599
plug-in architecture as well I think the

00:37:51,699 --> 00:37:57,309
answer is yes Gil yes the trajectory

00:37:55,599 --> 00:38:00,419
optimization part but yeah there's a

00:37:57,309 --> 00:38:00,419
plugin architecture there as well

00:38:01,289 --> 00:38:08,069
other questions this was a very clear

00:38:05,529 --> 00:38:08,069
talk yes

00:38:11,230 --> 00:38:15,520
what do you mean so the question is like

00:38:18,280 --> 00:38:23,720
so the question is what is the current

00:38:21,350 --> 00:38:26,810
ability to do dynamic motion planning at

00:38:23,720 --> 00:38:28,610
this point we are essentially doing

00:38:26,810 --> 00:38:30,680
quasi static planning essentially as we

00:38:28,610 --> 00:38:33,350
said under kinematic constraints only we

00:38:30,680 --> 00:38:36,050
do not plan in control space these

00:38:33,350 --> 00:38:37,820
planning libraries that we use do have

00:38:36,050 --> 00:38:41,210
that functionality in particular LPL

00:38:37,820 --> 00:38:44,450
does include such abilities things like

00:38:41,210 --> 00:38:46,520
chomp and stomp do produce paths that

00:38:44,450 --> 00:38:49,100
are amenable to be sent to controllers

00:38:46,520 --> 00:38:50,930
but explicitly we do not we do not

00:38:49,100 --> 00:38:52,240
support that yet but I believe such an

00:38:50,930 --> 00:38:54,920
is going to work on that this summer

00:38:52,240 --> 00:38:58,820
yeah so it is something we're going to

00:38:54,920 --> 00:39:02,360
work on this summer actually install

00:38:58,820 --> 00:39:04,220
particularly you can put in cost

00:39:02,360 --> 00:39:09,140
functions that represent some kind of

00:39:04,220 --> 00:39:11,570
dynamics in it and we know some other

00:39:09,140 --> 00:39:13,730
people at USC have extended it to do

00:39:11,570 --> 00:39:15,560
some of that stuff but hopefully by the

00:39:13,730 --> 00:39:19,390
end of the summer we'll have more

00:39:15,560 --> 00:39:19,390
dynamic motion planning in our stacks

00:39:39,320 --> 00:39:43,370
excellent question thank you so the

00:39:41,430 --> 00:39:45,980
question was if there is a solution for

00:39:43,370 --> 00:39:47,970
planning on uneven terrain or

00:39:45,980 --> 00:39:49,830
essentially where we're not moving on

00:39:47,970 --> 00:39:53,730
flat terrain am I correct

00:39:49,830 --> 00:39:55,170
okay so remember the previous talk when

00:39:53,730 --> 00:39:56,730
there were those two joints that we

00:39:55,170 --> 00:39:58,890
didn't know what to do with the planner

00:39:56,730 --> 00:40:03,080
2d joint and the sixth off joint and the

00:39:58,890 --> 00:40:07,590
you RDF the answer is well we don't have

00:40:03,080 --> 00:40:09,330
examples of this working yet but those

00:40:07,590 --> 00:40:11,820
plant those joints those types of joints

00:40:09,330 --> 00:40:14,640
are for moving in plane essentially is a

00:40:11,820 --> 00:40:17,070
c2 space or S III space like with a

00:40:14,640 --> 00:40:20,040
floating joint and I believe some people

00:40:17,070 --> 00:40:23,040
in Fryeburg actually are doing planning

00:40:20,040 --> 00:40:24,870
like foot step planning with these types

00:40:23,040 --> 00:40:27,720
of joints I don't know if Armand's the

00:40:24,870 --> 00:40:30,120
area okay so that will be described

00:40:27,720 --> 00:40:33,300
later but that is using move it with I

00:40:30,120 --> 00:40:35,930
guess not the usual not the usual set up

00:40:33,300 --> 00:40:35,930
so

00:40:59,890 --> 00:41:05,869
so it's called move it so that I could

00:41:02,840 --> 00:41:07,790
get oh so his question was why is it

00:41:05,869 --> 00:41:10,310
called move it and not arm navigation

00:41:07,790 --> 00:41:13,520
and the second question I think was is

00:41:10,310 --> 00:41:15,080
it going to break the api's it's called

00:41:13,520 --> 00:41:18,320
move it so I could get you on to dance

00:41:15,080 --> 00:41:21,380
to that music no actually it's called

00:41:18,320 --> 00:41:23,510
move it we sort of brainstormed the name

00:41:21,380 --> 00:41:27,530
and there's a software called grasp but

00:41:23,510 --> 00:41:29,270
that does grasping and so from that we

00:41:27,530 --> 00:41:30,740
got to move it we didn't want to call it

00:41:29,270 --> 00:41:33,380
arm navigation because we were moving

00:41:30,740 --> 00:41:36,410
beyond arm now arms and we were getting

00:41:33,380 --> 00:41:38,540
to we're looking at doing full body

00:41:36,410 --> 00:41:40,550
planning and things like that so we

00:41:38,540 --> 00:41:45,290
wanted it to reflect what we were

00:41:40,550 --> 00:41:49,220
actually doing in terms of the API it

00:41:45,290 --> 00:41:53,300
will it will break the API is the gist

00:41:49,220 --> 00:41:56,900
of it as I'm sorry about that we we

00:41:53,300 --> 00:41:59,390
really wanted to try and not do that but

00:41:56,900 --> 00:42:03,920
when you evolve software like this at

00:41:59,390 --> 00:42:08,380
some point the previous API can become

00:42:03,920 --> 00:42:11,570
you know not so it's hard to keep it

00:42:08,380 --> 00:42:13,520
will they look into solutions so that

00:42:11,570 --> 00:42:15,920
they're maybe there's like a bridge so

00:42:13,520 --> 00:42:19,430
that we can maintain some kind of API

00:42:15,920 --> 00:42:23,480
stability the the one thing though is

00:42:19,430 --> 00:42:26,240
that the Ross API that we have it will

00:42:23,480 --> 00:42:30,050
break it but the actual core of what it

00:42:26,240 --> 00:42:33,080
does will stay fairly fairly constant so

00:42:30,050 --> 00:42:36,530
we'll look into a solution so that you

00:42:33,080 --> 00:42:41,000
know it's not a complete breakage so

00:42:36,530 --> 00:42:42,530
just complete this I guess you're

00:42:41,000 --> 00:42:44,780
probably going to be able to fix your

00:42:42,530 --> 00:42:46,880
code by just doing search your place so

00:42:44,780 --> 00:42:48,650
hopefully that's the case if you're

00:42:46,880 --> 00:42:53,260
using Ross level stuff if you depend on

00:42:48,650 --> 00:42:53,260
C++ functionality I'm sorry

00:43:10,280 --> 00:43:12,340

YouTube URL: https://www.youtube.com/watch?v=r1zbuLc8RhI


