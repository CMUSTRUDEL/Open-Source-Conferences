Title: ROSCon 2012 - Introduction to rosjava
Publication date: 2014-08-31
Playlist: ROSCon 2012
Description: 
	Damon Kohler

Slides: http://roscon.ros.org/wp-uploads/2012/06/Introduction%20to%20rosjava%20(ROSCon%202012).pdf
Captions: 
	00:00:00,359 --> 00:00:05,400
good afternoon everyone hopefully the

00:00:03,210 --> 00:00:07,049
morning stocks were great and you got a

00:00:05,400 --> 00:00:10,200
chance to meet a few more people over

00:00:07,049 --> 00:00:12,090
lunch for the the start of the afternoon

00:00:10,200 --> 00:00:14,309
session I'd like to just start by

00:00:12,090 --> 00:00:16,560
introducing Damon Kohler from Google

00:00:14,309 --> 00:00:28,320
who's going to be speaking about Ross

00:00:16,560 --> 00:00:29,849
Java hey everybody I'm Damon cooler I'm

00:00:28,320 --> 00:00:32,399
a software engineer at Google actually

00:00:29,849 --> 00:00:36,570
work in the the Munich office so this

00:00:32,399 --> 00:00:38,340
was a bit of a trick so just quick to

00:00:36,570 --> 00:00:39,480
try and set up some expectations for

00:00:38,340 --> 00:00:42,239
those sorts of things I'm going to try

00:00:39,480 --> 00:00:45,870
and cover this talk is pretty developer

00:00:42,239 --> 00:00:47,340
oriented it's not a tutorial so if

00:00:45,870 --> 00:00:49,050
you're not familiar with Ross or you're

00:00:47,340 --> 00:00:52,079
not familiar with Java some of this

00:00:49,050 --> 00:00:54,719
stuff might be you know a little hard to

00:00:52,079 --> 00:00:57,420
understand but I think I think it'll be

00:00:54,719 --> 00:00:59,879
okay anyway all the code samples are

00:00:57,420 --> 00:01:01,410
pretty abbreviated so don't expect to

00:00:59,879 --> 00:01:03,960
like copy/paste from the slides that

00:01:01,410 --> 00:01:04,920
won't work but what I am gonna try and

00:01:03,960 --> 00:01:06,479
do is cover a lot of the high-level

00:01:04,920 --> 00:01:09,450
concepts that might actually be hard to

00:01:06,479 --> 00:01:11,939
extract from the documentation or things

00:01:09,450 --> 00:01:15,780
that I think you might only be able to

00:01:11,939 --> 00:01:17,790
find and a venue like this so just to

00:01:15,780 --> 00:01:21,930
kind of kick it off I have a little

00:01:17,790 --> 00:01:25,799
video because it was one year ago

00:01:21,930 --> 00:01:28,729
actually that we launched across Java at

00:01:25,799 --> 00:01:28,729
Google i/o

00:02:27,100 --> 00:02:33,620
so one year ago we also launched a cloud

00:02:30,350 --> 00:02:35,720
robotics comm which is basically sort of

00:02:33,620 --> 00:02:41,330
our landing page for the the work we're

00:02:35,720 --> 00:02:42,410
doing with Ross primarily you may have

00:02:41,330 --> 00:02:45,410
noticed that that video was pretty

00:02:42,410 --> 00:02:46,730
Android heavy it turns out that Java is

00:02:45,410 --> 00:02:48,920
probably not the main reason people are

00:02:46,730 --> 00:02:51,740
interested in Ross Java it's an Android

00:02:48,920 --> 00:02:53,870
Android compatibility of course there's

00:02:51,740 --> 00:02:55,340
lots of Java libraries and things like

00:02:53,870 --> 00:02:56,510
that that you can link you sieve and you

00:02:55,340 --> 00:03:00,010
know I happen to actually enjoy working

00:02:56,510 --> 00:03:02,860
in Java which I guess is pretty obvious

00:03:00,010 --> 00:03:06,530
but I think Android is the biggest thing

00:03:02,860 --> 00:03:08,750
so there were are quite some differences

00:03:06,530 --> 00:03:10,270
I think in the the Ross Java client

00:03:08,750 --> 00:03:13,430
library compared to some of the other

00:03:10,270 --> 00:03:15,230
some of the other languages one of the

00:03:13,430 --> 00:03:16,520
biggest ones is actually that the entire

00:03:15,230 --> 00:03:19,850
thing was designed from the beginning to

00:03:16,520 --> 00:03:20,959
be asynchronous so for those who are not

00:03:19,850 --> 00:03:23,480
really familiar with that terminology

00:03:20,959 --> 00:03:25,130
asynchronous means that when you call a

00:03:23,480 --> 00:03:26,660
method that might take a long time to

00:03:25,130 --> 00:03:29,030
actually do whatever it is you intended

00:03:26,660 --> 00:03:30,890
to do you give it some kind of callback

00:03:29,030 --> 00:03:32,959
so that callback gets called whenever

00:03:30,890 --> 00:03:35,290
the MANET method is done and Java that's

00:03:32,959 --> 00:03:40,370
usually with an object a listener object

00:03:35,290 --> 00:03:41,750
and all of the API written in that way

00:03:40,370 --> 00:03:43,910
so you won't find a lot of the blocking

00:03:41,750 --> 00:03:45,380
calls that you might like a service call

00:03:43,910 --> 00:03:47,780
will take a callback rather than

00:03:45,380 --> 00:03:50,810
blocking and until the response comes

00:03:47,780 --> 00:03:53,360
and returning it it's also built on

00:03:50,810 --> 00:03:55,670
something called Neddie which is a niÃ±o

00:03:53,360 --> 00:03:59,180
framework asynchronous and IO framework

00:03:55,670 --> 00:04:02,180
for for network stuff it's really fast

00:03:59,180 --> 00:04:03,590
it's it's well vetted and so it's built

00:04:02,180 --> 00:04:05,900
from the rough drive was built from the

00:04:03,590 --> 00:04:08,390
ground up with that so are asynchronous

00:04:05,900 --> 00:04:10,640
gives you better performance in many

00:04:08,390 --> 00:04:11,989
many cases you can always write a non

00:04:10,640 --> 00:04:14,450
performance asynchronous code as well

00:04:11,989 --> 00:04:15,860
but it also I think one of the more

00:04:14,450 --> 00:04:17,359
important things is it helps kind of

00:04:15,860 --> 00:04:20,299
promote better coupling and cohesion

00:04:17,359 --> 00:04:23,360
through sort of encouraging developers

00:04:20,299 --> 00:04:25,060
to create nice components and many many

00:04:23,360 --> 00:04:27,650
of the same ways that Ross already does

00:04:25,060 --> 00:04:30,440
so one just simple example of

00:04:27,650 --> 00:04:33,050
asynchronous is when you create a new

00:04:30,440 --> 00:04:34,700
subscriber and you want to add you want

00:04:33,050 --> 00:04:35,630
to do something on when a new message

00:04:34,700 --> 00:04:38,030
comes in you would add a message

00:04:35,630 --> 00:04:40,600
listener object and then that would be

00:04:38,030 --> 00:04:43,340
called for every new incoming message

00:04:40,600 --> 00:04:45,260
so another big difference is this

00:04:43,340 --> 00:04:48,650
concept of node versus node main so

00:04:45,260 --> 00:04:51,440
whenever people talk about nodes in in

00:04:48,650 --> 00:04:52,880
the Ross ecosystem it's actually a

00:04:51,440 --> 00:04:54,860
little bit of an overloaded term I found

00:04:52,880 --> 00:04:56,840
so you know sometimes people are talking

00:04:54,860 --> 00:04:58,730
about more like a node in the graph some

00:04:56,840 --> 00:05:02,510
people sometimes you're talking about an

00:04:58,730 --> 00:05:04,130
actual process then there's in the Ross

00:05:02,510 --> 00:05:08,720
EPP world there is the concept of

00:05:04,130 --> 00:05:14,510
notelets which are I guess similar to

00:05:08,720 --> 00:05:16,340
node main really in Ross Java so the API

00:05:14,510 --> 00:05:18,440
actually did in rostro by the API

00:05:16,340 --> 00:05:20,510
actually distinguishes pretty clearly

00:05:18,440 --> 00:05:22,190
between these two things and a node is

00:05:20,510 --> 00:05:25,100
really actually about encapsulating some

00:05:22,190 --> 00:05:27,230
of the things that are required in order

00:05:25,100 --> 00:05:28,580
to have a presence on a Ross graph so

00:05:27,230 --> 00:05:31,310
you have some sort of configuration that

00:05:28,580 --> 00:05:32,960
talks about or describes how that node

00:05:31,310 --> 00:05:35,090
should operate how it should connect to

00:05:32,960 --> 00:05:36,680
a master things like that and it also

00:05:35,090 --> 00:05:38,000
gives you the the factories you need in

00:05:36,680 --> 00:05:40,700
order to create things like publishers

00:05:38,000 --> 00:05:43,400
and subscribers and then it gives you

00:05:40,700 --> 00:05:46,700
all of the clients to actually access

00:05:43,400 --> 00:05:48,530
some of the other things that are behind

00:05:46,700 --> 00:05:50,180
different protocols in the Ross graph so

00:05:48,530 --> 00:05:51,440
that's parameters and talking to the

00:05:50,180 --> 00:05:55,040
master and talking to other nodes

00:05:51,440 --> 00:05:57,800
actually depending on I think many Ross

00:05:55,040 --> 00:05:59,540
users probably don't have or maybe don't

00:05:57,800 --> 00:06:00,680
have a lot of knowledge of what's

00:05:59,540 --> 00:06:02,630
actually happening under the covers with

00:06:00,680 --> 00:06:04,850
some of these api's but there's actually

00:06:02,630 --> 00:06:06,200
a pretty clear distinction at the

00:06:04,850 --> 00:06:08,420
protocol level of how these things work

00:06:06,200 --> 00:06:10,070
and so the node just kind of wraps all

00:06:08,420 --> 00:06:11,180
that up and then the node main is

00:06:10,070 --> 00:06:13,640
actually just a listener

00:06:11,180 --> 00:06:16,010
so whenever the node get started or

00:06:13,640 --> 00:06:18,500
shuts down the node main is notified of

00:06:16,010 --> 00:06:20,390
this and so basically you put all your

00:06:18,500 --> 00:06:22,850
business logic you put your actual robot

00:06:20,390 --> 00:06:25,130
program into a node main instead of into

00:06:22,850 --> 00:06:28,100
your node and this kind of lets you

00:06:25,130 --> 00:06:31,640
create something that is nicely

00:06:28,100 --> 00:06:34,340
asynchronous and really pluggable so you

00:06:31,640 --> 00:06:37,130
can you can run all of your node mains

00:06:34,340 --> 00:06:40,010
in one process for when one JVM rather

00:06:37,130 --> 00:06:41,480
than creating multiple processes for one

00:06:40,010 --> 00:06:42,950
for each node basically which is the

00:06:41,480 --> 00:06:46,280
normal thing unless you're using node

00:06:42,950 --> 00:06:48,950
that's so the life cycle events on a

00:06:46,280 --> 00:06:51,200
node main you have just on start on

00:06:48,950 --> 00:06:54,020
shutdown there's actually also a none

00:06:51,200 --> 00:06:57,169
shutdown complete and these these

00:06:54,020 --> 00:06:59,539
called as the node basically comes up so

00:06:57,169 --> 00:07:01,639
onstart is called once the the node has

00:06:59,539 --> 00:07:04,190
all of its has a slave server running

00:07:01,639 --> 00:07:05,840
and you know everything that it needs to

00:07:04,190 --> 00:07:07,610
do to initialize is all done then

00:07:05,840 --> 00:07:09,680
onstart gets called at that point and

00:07:07,610 --> 00:07:11,810
your node main you're actually able to

00:07:09,680 --> 00:07:13,849
start doing things making publishers

00:07:11,810 --> 00:07:16,039
creating subscribers that sort of thing

00:07:13,849 --> 00:07:17,599
but the life cycle events actually go

00:07:16,039 --> 00:07:19,490
beyond that to into other objects that

00:07:17,599 --> 00:07:22,400
are used as well so publishers for

00:07:19,490 --> 00:07:24,860
example you have you can add listeners

00:07:22,400 --> 00:07:27,620
to them that will be called when master

00:07:24,860 --> 00:07:29,479
registration fails or succeeds when new

00:07:27,620 --> 00:07:31,759
subscribers are added when it gets shut

00:07:29,479 --> 00:07:32,870
down things like that this is just a

00:07:31,759 --> 00:07:34,490
small selection of the ones that exist

00:07:32,870 --> 00:07:36,560
and some of these things will actually

00:07:34,490 --> 00:07:38,300
be called multiple times you know in the

00:07:36,560 --> 00:07:40,220
case of on master registration failure

00:07:38,300 --> 00:07:41,539
that can happen repeatedly and so you

00:07:40,220 --> 00:07:45,169
might actually get you might actually

00:07:41,539 --> 00:07:48,229
see that event multiple times so this is

00:07:45,169 --> 00:07:50,180
just a really bare-bones node main it's

00:07:48,229 --> 00:07:54,740
missing some of the some of the methods

00:07:50,180 --> 00:07:56,509
even but basically the node main extends

00:07:54,740 --> 00:07:58,550
the interface that is a node listener

00:07:56,509 --> 00:08:00,349
and the only thing that it does when it

00:07:58,550 --> 00:08:04,039
extends that is to add this get default

00:08:00,349 --> 00:08:05,449
node name so many of you know who know

00:08:04,039 --> 00:08:07,130
do you usually you give it some sort of

00:08:05,449 --> 00:08:08,479
name there in your and your main method

00:08:07,130 --> 00:08:10,550
that can be overridden later when you

00:08:08,479 --> 00:08:12,229
actually configure things to come up and

00:08:10,550 --> 00:08:15,080
this method sort of serves that purpose

00:08:12,229 --> 00:08:16,159
you also see that it it actually

00:08:15,080 --> 00:08:20,509
returned something called a graph name

00:08:16,159 --> 00:08:22,520
so oftentimes I've seen in various Ross

00:08:20,509 --> 00:08:25,370
client libraries that strings are

00:08:22,520 --> 00:08:27,020
usually treated sort of as you know as

00:08:25,370 --> 00:08:30,380
the data structure to represent things

00:08:27,020 --> 00:08:31,940
like topic names and and types and all

00:08:30,380 --> 00:08:33,500
kinds of stuff so in Ross Java I

00:08:31,940 --> 00:08:35,990
actually tried to wrap those up into

00:08:33,500 --> 00:08:38,120
things that have a bit more meaning and

00:08:35,990 --> 00:08:40,459
possibly also contains some useful

00:08:38,120 --> 00:08:41,959
methods like graph name it can return

00:08:40,459 --> 00:08:43,640
like a new group graph name and then you

00:08:41,959 --> 00:08:44,930
can build off of them and you can

00:08:43,640 --> 00:08:45,459
resolve against them and things like

00:08:44,930 --> 00:08:48,079
that

00:08:45,459 --> 00:08:50,120
then you see the on start method and the

00:08:48,079 --> 00:08:51,890
unstart actually receives the node so

00:08:50,120 --> 00:08:54,230
the node remember is you know it's not a

00:08:51,890 --> 00:08:56,240
process it's it's actually something

00:08:54,230 --> 00:08:57,410
that gives you the ability to create all

00:08:56,240 --> 00:09:01,610
the stuff that you need to do in order

00:08:57,410 --> 00:09:03,110
to get your job done but that comes down

00:09:01,610 --> 00:09:05,089
to then you know the question is well

00:09:03,110 --> 00:09:08,020
where does the node come from and that's

00:09:05,089 --> 00:09:10,640
actually taken care of for you so

00:09:08,020 --> 00:09:13,790
we try to actually create lots more

00:09:10,640 --> 00:09:16,190
threads and instead of processes mostly

00:09:13,790 --> 00:09:19,040
because bringing up JVM is actually

00:09:16,190 --> 00:09:22,400
pretty intensive this is it would be a

00:09:19,040 --> 00:09:24,530
waste to not do this and it also sort of

00:09:22,400 --> 00:09:25,430
allows for in the future to be smarter

00:09:24,530 --> 00:09:27,200
about the way that we communicate

00:09:25,430 --> 00:09:29,300
between nodes that are running on the

00:09:27,200 --> 00:09:31,190
same machine there's not a really an S

00:09:29,300 --> 00:09:33,620
so there you know not a need for a

00:09:31,190 --> 00:09:37,220
socket when two nodes share the same

00:09:33,620 --> 00:09:38,900
memory space so the node main executors

00:09:37,220 --> 00:09:41,240
is actually what is responsible for

00:09:38,900 --> 00:09:42,620
executing your node mains if you're a

00:09:41,240 --> 00:09:44,630
Java developer then you know the

00:09:42,620 --> 00:09:47,420
executors name there probably seems

00:09:44,630 --> 00:09:50,060
pretty familiar and the it does actually

00:09:47,420 --> 00:09:52,670
justin cap wrap up a thread pool an

00:09:50,060 --> 00:09:54,890
executor service it's it's a bit of a

00:09:52,670 --> 00:09:57,350
fancy custom executor service but it's

00:09:54,890 --> 00:09:58,850
still an executor service and actually

00:09:57,350 --> 00:10:02,000
also wraps up a node factory and the

00:09:58,850 --> 00:10:03,710
node factory is what is used basically

00:10:02,000 --> 00:10:05,150
behind the scenes and that is handed off

00:10:03,710 --> 00:10:08,120
to your node listener and then that's

00:10:05,150 --> 00:10:09,290
what you would act on so your main

00:10:08,120 --> 00:10:12,020
method if you were gonna write one

00:10:09,290 --> 00:10:13,880
yourself which I don't recommend would

00:10:12,020 --> 00:10:14,990
look something like this and you would

00:10:13,880 --> 00:10:16,550
basically create one of these node main

00:10:14,990 --> 00:10:18,140
executors and you would have your node

00:10:16,550 --> 00:10:20,450
mains that you've defined elsewhere and

00:10:18,140 --> 00:10:21,710
you would just sort of execute them with

00:10:20,450 --> 00:10:24,710
your with your thread pool and

00:10:21,710 --> 00:10:27,940
everything goes off so another thing you

00:10:24,710 --> 00:10:30,350
won't find is spin you know spin is

00:10:27,940 --> 00:10:32,810
usually what you would see that like in

00:10:30,350 --> 00:10:34,940
your in your main you will just loop

00:10:32,810 --> 00:10:37,430
constantly until the node that you that

00:10:34,940 --> 00:10:39,590
you created is shutdown and you know do

00:10:37,430 --> 00:10:41,950
some business logic there so you don't

00:10:39,590 --> 00:10:44,210
actually need to do that and a Java node

00:10:41,950 --> 00:10:46,220
if you do have something that you want

00:10:44,210 --> 00:10:48,920
to loop through and do continuously

00:10:46,220 --> 00:10:50,240
there is access to the same thread pool

00:10:48,920 --> 00:10:51,950
that the node main executor uses

00:10:50,240 --> 00:10:53,270
everything actually runs in the same

00:10:51,950 --> 00:10:54,740
thread pool including all the network

00:10:53,270 --> 00:10:57,440
communication so everything can be shut

00:10:54,740 --> 00:10:58,880
down cleanly at the end but you actually

00:10:57,440 --> 00:11:01,010
can execute these things that are called

00:10:58,880 --> 00:11:04,370
canceled loops and that's just sort of a

00:11:01,010 --> 00:11:06,800
nicer version of a runnable that is an

00:11:04,370 --> 00:11:09,530
interrupt Abul thread it gives you a

00:11:06,800 --> 00:11:12,020
loop method a setup method and you can

00:11:09,530 --> 00:11:13,340
execute this against the nude and then

00:11:12,020 --> 00:11:14,600
when the node shuts down it will

00:11:13,340 --> 00:11:16,840
actually clean up all these things for

00:11:14,600 --> 00:11:19,370
you so all you don't have to worry about

00:11:16,840 --> 00:11:20,720
you know how do you know how do i cancel

00:11:19,370 --> 00:11:24,769
all these threads when i'm done

00:11:20,720 --> 00:11:28,610
that's taken care of so what does

00:11:24,769 --> 00:11:30,019
publisher and subscribers look like you

00:11:28,610 --> 00:11:33,470
can see that the the publisher actually

00:11:30,019 --> 00:11:35,870
is made with generics so you they're

00:11:33,470 --> 00:11:38,209
typed according to the message type that

00:11:35,870 --> 00:11:39,439
comes in when you create a new one

00:11:38,209 --> 00:11:41,779
you're asking the node to create it for

00:11:39,439 --> 00:11:43,459
you you give it the topic and then the

00:11:41,779 --> 00:11:45,500
the message type and I'll talk a little

00:11:43,459 --> 00:11:48,350
bit more about how messages work in a

00:11:45,500 --> 00:11:49,939
minute as subscribers are basically the

00:11:48,350 --> 00:11:51,829
same and then you can add a message

00:11:49,939 --> 00:11:55,519
listener and so the message listener

00:11:51,829 --> 00:11:57,490
here is just an anonymous object from

00:11:55,519 --> 00:12:00,170
the from the message listener interface

00:11:57,490 --> 00:12:01,579
every time a new message comes in you

00:12:00,170 --> 00:12:08,209
get called and you do whatever you like

00:12:01,579 --> 00:12:12,769
with it so services also pretty similar

00:12:08,209 --> 00:12:14,779
you create the server from the node give

00:12:12,769 --> 00:12:16,699
it the service name give it the type and

00:12:14,779 --> 00:12:18,769
then the responsibility is actually

00:12:16,699 --> 00:12:20,000
something I get questions about pretty

00:12:18,769 --> 00:12:22,759
frequently when people try to use

00:12:20,000 --> 00:12:25,189
services and it's actually changed a

00:12:22,759 --> 00:12:26,779
little bit recently but basically the

00:12:25,189 --> 00:12:28,730
response builder is just a sort of an

00:12:26,779 --> 00:12:30,319
asynchronous way to deal with you know

00:12:28,730 --> 00:12:31,910
incoming requests rather than saying

00:12:30,319 --> 00:12:33,110
like sitting there and waiting for the

00:12:31,910 --> 00:12:36,019
next request to come in and then doing

00:12:33,110 --> 00:12:38,360
something and returning the response you

00:12:36,019 --> 00:12:39,589
just create this you create an instance

00:12:38,360 --> 00:12:42,829
of something that builds that response

00:12:39,589 --> 00:12:44,209
and then that is executed automatically

00:12:42,829 --> 00:12:45,709
right on a different thread and

00:12:44,209 --> 00:12:47,750
everything so in the server and a

00:12:45,709 --> 00:12:51,620
service server all this stuff

00:12:47,750 --> 00:12:53,480
it can actually be asynchronous but the

00:12:51,620 --> 00:12:56,149
protocol kind of makes that really hard

00:12:53,480 --> 00:12:58,120
to do anyway so the the builder takes

00:12:56,149 --> 00:13:00,920
takes or gives you actually a response

00:12:58,120 --> 00:13:03,319
in the in the signature and that's what

00:13:00,920 --> 00:13:05,269
you use so there's one response that

00:13:03,319 --> 00:13:06,829
kind of gets recycled or you don't have

00:13:05,269 --> 00:13:08,689
to worry about how you create it and in

00:13:06,829 --> 00:13:10,699
your builder it's just a little bit

00:13:08,689 --> 00:13:12,680
easier that way so you set up the

00:13:10,699 --> 00:13:15,139
response and then you don't even have to

00:13:12,680 --> 00:13:18,230
return it or anything it just gets sent

00:13:15,139 --> 00:13:20,839
to the consent to the client and the

00:13:18,230 --> 00:13:22,819
client looks pretty similar but you also

00:13:20,839 --> 00:13:24,439
see that rather than blocking and or

00:13:22,819 --> 00:13:28,160
having client call actually return the

00:13:24,439 --> 00:13:29,870
response you get a on success or on

00:13:28,160 --> 00:13:31,850
error and that's where you would

00:13:29,870 --> 00:13:37,370
actually deal with your response

00:13:31,850 --> 00:13:40,730
so the client is also resynchronize so

00:13:37,370 --> 00:13:44,750
now the messages you saw previously that

00:13:40,730 --> 00:13:47,930
in the for instance on the new service

00:13:44,750 --> 00:13:50,480
client right here this dot type so all

00:13:47,930 --> 00:13:53,870
of the messages are actually implemented

00:13:50,480 --> 00:13:54,950
as empty interfaces and then those empty

00:13:53,870 --> 00:13:56,600
interfaces are backed by something

00:13:54,950 --> 00:13:56,990
called dynamic proxy in Java so at

00:13:56,600 --> 00:13:58,430
runtime

00:13:56,990 --> 00:14:00,230
there is an implementation that

00:13:58,430 --> 00:14:02,540
understands how to parse the data the

00:14:00,230 --> 00:14:03,980
message definition and create the actual

00:14:02,540 --> 00:14:07,280
implementation that will back one of

00:14:03,980 --> 00:14:09,470
these interfaces so the interfaces have

00:14:07,280 --> 00:14:11,180
two constants to find on them which is

00:14:09,470 --> 00:14:12,950
the type and the definition and those

00:14:11,180 --> 00:14:15,530
are just strings and then you use that

00:14:12,950 --> 00:14:18,320
string type to actually you know tell

00:14:15,530 --> 00:14:20,420
Java what sort of message this is right

00:14:18,320 --> 00:14:22,900
so it goes and it looks that up uses

00:14:20,420 --> 00:14:26,300
some reflection to to find the message

00:14:22,900 --> 00:14:28,760
the message interface and builds an

00:14:26,300 --> 00:14:30,890
implementation for you so another

00:14:28,760 --> 00:14:33,020
interesting thing for Java is that the

00:14:30,890 --> 00:14:35,660
rostra of a messages package actually

00:14:33,020 --> 00:14:37,310
has the entire world of Rosse messages

00:14:35,660 --> 00:14:38,870
available so whenever you actually add

00:14:37,310 --> 00:14:40,310
that dependency to your project you

00:14:38,870 --> 00:14:42,560
don't have to think about in your

00:14:40,310 --> 00:14:43,850
manifest you know which message packages

00:14:42,560 --> 00:14:45,590
you actually depend on they're always

00:14:43,850 --> 00:14:47,180
available and the reason for that is

00:14:45,590 --> 00:14:49,040
because it's actually really really fast

00:14:47,180 --> 00:14:51,350
to build those messages and it's very

00:14:49,040 --> 00:14:53,480
small since they're basically all just

00:14:51,350 --> 00:14:56,270
empty interfaces it's just an easy way

00:14:53,480 --> 00:14:57,650
to go now also because all of the

00:14:56,270 --> 00:14:59,690
definitions are parsed at runtime that

00:14:57,650 --> 00:15:01,640
means that in Java you can do clever

00:14:59,690 --> 00:15:03,950
things like shapeshifter if you're

00:15:01,640 --> 00:15:05,690
familiar with that from C++ you can

00:15:03,950 --> 00:15:08,630
actually sniff definitions off the wire

00:15:05,690 --> 00:15:12,440
and then build and build a message that

00:15:08,630 --> 00:15:13,970
you could use yourself so in order to

00:15:12,440 --> 00:15:16,370
create messages you actually need to use

00:15:13,970 --> 00:15:17,660
a message factory or one of these nice

00:15:16,370 --> 00:15:20,450
little helper methods like the publisher

00:15:17,660 --> 00:15:22,580
has here this new message

00:15:20,450 --> 00:15:24,950
that's just there's really just a

00:15:22,580 --> 00:15:28,580
convenience method that wraps up a call

00:15:24,950 --> 00:15:30,110
to the to the factory so I've also had

00:15:28,580 --> 00:15:32,630
questions about you know why why is

00:15:30,110 --> 00:15:34,190
there a message factory why why can't I

00:15:32,630 --> 00:15:35,930
just instantiate a message you know why

00:15:34,190 --> 00:15:38,930
is it an empty interface and a lot of it

00:15:35,930 --> 00:15:42,680
has to do with trying to future-proof

00:15:38,930 --> 00:15:44,780
ross java as much as possible so the

00:15:42,680 --> 00:15:45,649
subscribers and the publishers and

00:15:44,780 --> 00:15:48,230
services and thing

00:15:45,649 --> 00:15:50,509
like that in Rostova actually have no

00:15:48,230 --> 00:15:52,999
knowledge of how to work with messages

00:15:50,509 --> 00:15:55,069
directly so the actual implementation

00:15:52,999 --> 00:15:56,420
for a message or the implementation for

00:15:55,069 --> 00:15:58,430
things that know how to serialize and

00:15:56,420 --> 00:16:00,589
deserialize messages all of that stuff

00:15:58,430 --> 00:16:02,329
is actually hidden away in factories

00:16:00,589 --> 00:16:04,749
that get handed around so it adds a bit

00:16:02,329 --> 00:16:07,069
of complication but I think it can be

00:16:04,749 --> 00:16:08,839
hidden pretty neat pretty easily with

00:16:07,069 --> 00:16:10,970
these convenience methods like the new

00:16:08,839 --> 00:16:12,619
message on a publisher but it really

00:16:10,970 --> 00:16:14,629
adds a lot to the flexibility so if you

00:16:12,619 --> 00:16:16,220
wanted to completely replace Ross

00:16:14,629 --> 00:16:21,529
messages with something like protobuf

00:16:16,220 --> 00:16:23,420
that would be possible so another big

00:16:21,529 --> 00:16:24,980
thing and this is actually a pretty

00:16:23,420 --> 00:16:26,480
recent development is the the build

00:16:24,980 --> 00:16:28,579
system for Ross Java is actually based

00:16:26,480 --> 00:16:31,249
on something called Gradle and Gradle is

00:16:28,579 --> 00:16:33,589
a is a really flexible build by

00:16:31,249 --> 00:16:36,170
convention groovy based build system

00:16:33,589 --> 00:16:37,879
it's it's pretty popular right now it

00:16:36,170 --> 00:16:39,740
shares it's completely compatible with

00:16:37,879 --> 00:16:43,129
ant and mave in another job at build

00:16:39,740 --> 00:16:44,600
systems but I think probably what

00:16:43,129 --> 00:16:48,199
everybody here is wondering is you know

00:16:44,600 --> 00:16:50,509
why not Ross make why not cat kitten so

00:16:48,199 --> 00:16:52,029
it turns out that the Java ecosystem is

00:16:50,509 --> 00:16:54,949
really just fundamentally different than

00:16:52,029 --> 00:16:58,009
C++ and Python and things like that and

00:16:54,949 --> 00:16:59,540
there's a whole plethora of frameworks

00:16:58,009 --> 00:17:02,629
available for building your java project

00:16:59,540 --> 00:17:05,240
in one way or another and if you try to

00:17:02,629 --> 00:17:07,250
like step outside of that then it just

00:17:05,240 --> 00:17:09,470
becomes very complicated very quickly so

00:17:07,250 --> 00:17:10,610
you know these people you know people

00:17:09,470 --> 00:17:12,380
that created Gradle and people have

00:17:10,610 --> 00:17:14,149
created maven you know they put a lot of

00:17:12,380 --> 00:17:16,309
thought into this and there's and it's

00:17:14,149 --> 00:17:18,679
just so widespread that dependency

00:17:16,309 --> 00:17:20,870
management through you know Deb's and

00:17:18,679 --> 00:17:23,209
trying to actually wrap things up to

00:17:20,870 --> 00:17:25,730
work with make or see make just becomes

00:17:23,209 --> 00:17:28,010
more headache than it's worth so this is

00:17:25,730 --> 00:17:29,899
this is a very Java centric build system

00:17:28,010 --> 00:17:32,529
but it plays nicely with the with the

00:17:29,899 --> 00:17:36,350
existing with the existing Ross stack

00:17:32,529 --> 00:17:37,610
Ross packages so this is what the you

00:17:36,350 --> 00:17:40,070
know a roster of a package directory

00:17:37,610 --> 00:17:41,899
layout kind of looks like all the way up

00:17:40,070 --> 00:17:44,840
to the stack and most of it looks pretty

00:17:41,899 --> 00:17:47,390
standard in fact if you've used maven or

00:17:44,840 --> 00:17:50,120
anything similar to it before it also

00:17:47,390 --> 00:17:52,010
look familiar you have this this

00:17:50,120 --> 00:17:53,570
build.gradle script here and this is the

00:17:52,010 --> 00:17:56,210
thing that actually defines how your how

00:17:53,570 --> 00:17:58,130
your build is handled but then you also

00:17:56,210 --> 00:17:59,149
have and this is the build by convention

00:17:58,130 --> 00:18:00,679
part

00:17:59,149 --> 00:18:02,719
you have a source directory and then

00:18:00,679 --> 00:18:05,089
below that I mean in a test directory

00:18:02,719 --> 00:18:08,389
and then Java than a resources directory

00:18:05,089 --> 00:18:10,669
so in Java builds typically you have

00:18:08,389 --> 00:18:12,019
different scopes for the kinds of for

00:18:10,669 --> 00:18:15,979
your dependencies and your source files

00:18:12,019 --> 00:18:17,929
so when you ship a jar with that is you

00:18:15,979 --> 00:18:19,070
know designed to be run you know when

00:18:17,929 --> 00:18:20,299
you're when you're shipping a jar that

00:18:19,070 --> 00:18:21,080
contains you know that you're gonna run

00:18:20,299 --> 00:18:23,269
in production

00:18:21,080 --> 00:18:25,039
it doesn't include all the test

00:18:23,269 --> 00:18:26,809
dependencies and things like that those

00:18:25,039 --> 00:18:28,549
are scope two differently those go into

00:18:26,809 --> 00:18:29,690
under the test directory and those are

00:18:28,549 --> 00:18:33,190
there when you actually want to run your

00:18:29,690 --> 00:18:35,210
tests so the nice thing is is that

00:18:33,190 --> 00:18:36,979
because of this build by convention

00:18:35,210 --> 00:18:39,499
basically once you drop all your Java

00:18:36,979 --> 00:18:40,729
source code into these directories you

00:18:39,499 --> 00:18:42,289
don't actually have to define where they

00:18:40,729 --> 00:18:43,940
are or anything in your and your

00:18:42,289 --> 00:18:46,029
build.gradle script it just finds

00:18:43,940 --> 00:18:48,200
everything and does the right thing and

00:18:46,029 --> 00:18:49,879
then the build directory is just where

00:18:48,200 --> 00:18:56,119
everything winds up so that's the

00:18:49,879 --> 00:18:57,830
created directory from Gradle so the the

00:18:56,119 --> 00:18:59,359
basic build Gradle script here and this

00:18:57,830 --> 00:19:01,460
uses the Java plug-in that's what gives

00:18:59,359 --> 00:19:03,710
us that nice build by convention you set

00:19:01,460 --> 00:19:05,899
up your your source you know your Java

00:19:03,710 --> 00:19:07,879
version stuff and then what actually

00:19:05,899 --> 00:19:09,649
becomes interesting here I think is the

00:19:07,879 --> 00:19:14,119
the version and the group assigned to

00:19:09,649 --> 00:19:17,419
this particular package so you're in

00:19:14,119 --> 00:19:19,609
maven you have what's called by

00:19:17,419 --> 00:19:22,399
coordinate system and basically your

00:19:19,609 --> 00:19:25,820
your java package gets an artifact ID a

00:19:22,399 --> 00:19:28,070
group ID and a version and so if you go

00:19:25,820 --> 00:19:30,080
to maven central which is just a large

00:19:28,070 --> 00:19:31,580
online repository of various Java

00:19:30,080 --> 00:19:34,039
dependencies and pretty much everything

00:19:31,580 --> 00:19:36,950
you want there everything is addressable

00:19:34,039 --> 00:19:38,960
that way and so when your build.gradle

00:19:36,950 --> 00:19:42,469
script actually the name of your package

00:19:38,960 --> 00:19:45,469
becomes the artifact ID the group is by

00:19:42,469 --> 00:19:47,210
convention or best practices that we're

00:19:45,469 --> 00:19:49,789
working on defining I guess for Ross

00:19:47,210 --> 00:19:51,979
Java the group ID should be Ross and

00:19:49,789 --> 00:19:53,570
then your stack name and then the

00:19:51,979 --> 00:19:55,159
version is the version actually of your

00:19:53,570 --> 00:19:57,679
of your package so you have version

00:19:55,159 --> 00:19:59,210
packages with this and then you can

00:19:57,679 --> 00:20:00,979
actually see an example of it in action

00:19:59,210 --> 00:20:02,539
here so any of the dependencies we have

00:20:00,979 --> 00:20:04,549
a compile time dependency which means

00:20:02,539 --> 00:20:07,879
it's got to be available all the time

00:20:04,549 --> 00:20:09,589
pretty much and then we have the stack

00:20:07,879 --> 00:20:11,179
which is the group ID right here that's

00:20:09,589 --> 00:20:13,070
the first part of the coordinate then

00:20:11,179 --> 00:20:16,310
the package name right here Ross Java

00:20:13,070 --> 00:20:17,750
and on the version number and then down

00:20:16,310 --> 00:20:19,220
here we actually define the repositories

00:20:17,750 --> 00:20:22,040
where to look for that thing so we

00:20:19,220 --> 00:20:24,560
actually when you do a Gradle build it

00:20:22,040 --> 00:20:27,350
creates a local maven repository culture

00:20:24,560 --> 00:20:30,070
m2 cache or just your local maven

00:20:27,350 --> 00:20:34,130
repository it looks there first because

00:20:30,070 --> 00:20:35,840
you may have made some changes and those

00:20:34,130 --> 00:20:37,760
should be available there in your local

00:20:35,840 --> 00:20:39,170
cache and then maven central is the

00:20:37,760 --> 00:20:41,900
online version where you would actually

00:20:39,170 --> 00:20:42,830
go and find things like guava or j-unit

00:20:41,900 --> 00:20:52,760
or other things that are widely

00:20:42,830 --> 00:20:54,590
available so in order to run notes you

00:20:52,760 --> 00:20:55,940
actually need to use a different Gradle

00:20:54,590 --> 00:21:05,150
plugin there's an application book and

00:20:55,940 --> 00:21:07,100
it's called and in the application

00:21:05,150 --> 00:21:08,870
plug-in you specify a main class name

00:21:07,100 --> 00:21:10,490
and this is why I was saying you

00:21:08,870 --> 00:21:12,350
shouldn't write your own void static

00:21:10,490 --> 00:21:13,970
main because there is one already

00:21:12,350 --> 00:21:16,250
written for you that does some nice

00:21:13,970 --> 00:21:18,710
things like parsing all of the normal

00:21:16,250 --> 00:21:21,680
Ross command line flags and things like

00:21:18,710 --> 00:21:24,530
that and that's called the the or across

00:21:21,680 --> 00:21:26,720
Ross run class basically you just put

00:21:24,530 --> 00:21:30,110
that into your Gradle file and then when

00:21:26,720 --> 00:21:34,310
you use the install app task you can

00:21:30,110 --> 00:21:36,470
actually run from the package a node

00:21:34,310 --> 00:21:37,940
main directly it knows how to load it

00:21:36,470 --> 00:21:40,580
and find it and all that other stuff and

00:21:37,940 --> 00:21:43,120
then also parse any of the the remapping

00:21:40,580 --> 00:21:43,120
arguments

00:21:46,880 --> 00:21:52,399
so there's two lines underneath the main

00:21:49,139 --> 00:21:55,860
class name the install app into and the

00:21:52,399 --> 00:21:58,500
destination dear those are actually a

00:21:55,860 --> 00:22:00,029
workaround from something that's in Ross

00:21:58,500 --> 00:22:01,470
run that actually ignores anything

00:22:00,029 --> 00:22:02,730
that's in the build directory which is

00:22:01,470 --> 00:22:04,440
where these things would normally end up

00:22:02,730 --> 00:22:06,809
so we just move him into a directory

00:22:04,440 --> 00:22:12,419
called dist and then Ross run works as

00:22:06,809 --> 00:22:13,799
you would expect okay so none of that

00:22:12,419 --> 00:22:15,720
had anything to do with the Android and

00:22:13,799 --> 00:22:17,009
we already said the very beginning that

00:22:15,720 --> 00:22:21,409
Android seems to be the most interesting

00:22:17,009 --> 00:22:23,250
thing so we'll get back to that now

00:22:21,409 --> 00:22:24,779
first I wanted to say that there's

00:22:23,250 --> 00:22:26,370
actually a ton of stuff for Android

00:22:24,779 --> 00:22:27,690
already available and it's in the market

00:22:26,370 --> 00:22:29,250
right now you could go download it on

00:22:27,690 --> 00:22:32,399
your phone play with some of those

00:22:29,250 --> 00:22:34,169
robots over there using it I think

00:22:32,399 --> 00:22:36,289
so Chad rocky is actually giving a talk

00:22:34,169 --> 00:22:39,029
I don't know if that's today or tomorrow

00:22:36,289 --> 00:22:40,519
he wrote the sensor driver and the robot

00:22:39,029 --> 00:22:42,840
monitor those are both really cool

00:22:40,519 --> 00:22:45,840
there's at least a few different tele

00:22:42,840 --> 00:22:55,230
apps once we're making maps playing with

00:22:45,840 --> 00:22:56,100
br-2 all sorts of stuff but one thing I

00:22:55,230 --> 00:22:58,200
really wanted to point out is that

00:22:56,100 --> 00:23:01,440
there's actually way more than you can

00:22:58,200 --> 00:23:02,759
do than just using Android as a UI which

00:23:01,440 --> 00:23:03,379
seems to be the most popular thing right

00:23:02,759 --> 00:23:06,840
now

00:23:03,379 --> 00:23:08,759
you know Android is really it's an

00:23:06,840 --> 00:23:11,039
embedded PC but it's getting more and

00:23:08,759 --> 00:23:13,169
more powerful all the time so you can

00:23:11,039 --> 00:23:16,169
actually you know build a complete robot

00:23:13,169 --> 00:23:18,600
that runs off of it so one package that

00:23:16,169 --> 00:23:22,049
I wrote recently is called Android ACM

00:23:18,600 --> 00:23:24,539
serial and this is a CDC ACM serial

00:23:22,049 --> 00:23:27,480
driver so if you have an Android device

00:23:24,539 --> 00:23:29,700
that supports USB master mode our USB

00:23:27,480 --> 00:23:32,779
host mode rather you can actually plug

00:23:29,700 --> 00:23:38,960
in things like an Arduino and I Hoku you

00:23:32,779 --> 00:23:38,960
so a little demonstration of that

00:23:45,380 --> 00:23:51,410
so that entire robot is actually running

00:23:47,760 --> 00:23:51,410
off that tablet that you see on the top

00:23:59,330 --> 00:24:06,290
and we're using it to build maps

00:24:02,220 --> 00:24:06,290
navigate point to point things like that

00:24:10,280 --> 00:24:15,630
so it has the tilting laser scanner

00:24:12,870 --> 00:24:18,919
that's actually being driven it's just a

00:24:15,630 --> 00:24:18,919
hobby servo that we're driving off

00:24:37,220 --> 00:24:41,660
so what does an Android app look like

00:24:38,840 --> 00:24:44,810
actually well the there is the Android

00:24:41,660 --> 00:24:46,940
course stack that provides the Ross

00:24:44,810 --> 00:24:49,400
activity which is a nice wrapper around

00:24:46,940 --> 00:24:52,370
the normal Android activity and

00:24:49,400 --> 00:24:55,270
basically what that gives you is a an

00:24:52,370 --> 00:24:58,670
extra an extra method called a knit

00:24:55,270 --> 00:24:59,990
which gives provides you a node me an

00:24:58,670 --> 00:25:01,550
executor that we talked about already

00:24:59,990 --> 00:25:04,010
and then you can use that node my

00:25:01,550 --> 00:25:06,410
executor just executes a node mains like

00:25:04,010 --> 00:25:11,050
you would you know off of Android if you

00:25:06,410 --> 00:25:13,580
were writing just a normal Java node so

00:25:11,050 --> 00:25:15,800
how does that get started well so when

00:25:13,580 --> 00:25:18,080
the Ross activity gets started it

00:25:15,800 --> 00:25:21,680
actually starts a background service and

00:25:18,080 --> 00:25:22,760
that background service well actually an

00:25:21,680 --> 00:25:24,320
Android they would call it a foreground

00:25:22,760 --> 00:25:26,450
service because it's persistent it tries

00:25:24,320 --> 00:25:27,740
to stay alive it starts set up and then

00:25:26,450 --> 00:25:30,620
simultaneously it launches something

00:25:27,740 --> 00:25:32,120
called the master chooser and that is

00:25:30,620 --> 00:25:33,830
the user's opportunity to choose what

00:25:32,120 --> 00:25:37,220
master in order you know to connect

00:25:33,830 --> 00:25:39,500
their application to and then if the

00:25:37,220 --> 00:25:40,670
user cancels on that choice and decides

00:25:39,500 --> 00:25:41,960
to say or they didn't actually want to

00:25:40,670 --> 00:25:44,960
do this that mean the activity just

00:25:41,960 --> 00:25:47,090
exits but once they've chosen and once

00:25:44,960 --> 00:25:48,830
the node main executor service is ready

00:25:47,090 --> 00:25:52,310
then you're an it method gets called

00:25:48,830 --> 00:25:53,420
with that node main executor so there's

00:25:52,310 --> 00:25:54,680
a lot of stuff kind of happening under

00:25:53,420 --> 00:25:55,880
the covers there when you do that that

00:25:54,680 --> 00:25:57,170
you know you no longer have to worry

00:25:55,880 --> 00:25:59,330
about when you use the Ross activity

00:25:57,170 --> 00:26:00,380
which is like wake and Wi-Fi lock so

00:25:59,330 --> 00:26:02,150
those are things that keep the phone

00:26:00,380 --> 00:26:03,200
alive keep the network running things

00:26:02,150 --> 00:26:06,440
like that that you actually want when

00:26:03,200 --> 00:26:07,580
you're dealing with a robot deals with

00:26:06,440 --> 00:26:09,230
setting up that persistent

00:26:07,580 --> 00:26:11,030
background service and it also provides

00:26:09,230 --> 00:26:12,620
the user with a notification so that

00:26:11,030 --> 00:26:17,540
they can actually cancel the whole thing

00:26:12,620 --> 00:26:21,200
they can kill the app it also defines a

00:26:17,540 --> 00:26:23,180
few patterns for Android development one

00:26:21,200 --> 00:26:25,040
of those is that you know an Android we

00:26:23,180 --> 00:26:26,690
have concepts of views so you know

00:26:25,040 --> 00:26:29,000
there's a text view or an image view

00:26:26,690 --> 00:26:31,400
things like that and then in Ross we

00:26:29,000 --> 00:26:33,200
actually take those same views so you

00:26:31,400 --> 00:26:35,360
would extend a view or create a brand

00:26:33,200 --> 00:26:37,310
new view and then implement a node main

00:26:35,360 --> 00:26:39,290
with it and then you can execute that

00:26:37,310 --> 00:26:40,370
when you get your in your in it method

00:26:39,290 --> 00:26:42,530
when you get your node main executors

00:26:40,370 --> 00:26:44,570
you can execute that view just like a

00:26:42,530 --> 00:26:46,640
node main and now it serves both

00:26:44,570 --> 00:26:48,410
purposes so you can actually drop it in

00:26:46,640 --> 00:26:50,020
to your to your Android application

00:26:48,410 --> 00:26:51,790
layout and then

00:26:50,020 --> 00:26:53,320
do Ross type stuff with a create

00:26:51,790 --> 00:26:56,530
publishers subscribe to stuff things

00:26:53,320 --> 00:26:59,410
like that and what that does is actually

00:26:56,530 --> 00:27:01,690
create data-driven UI so if you have the

00:26:59,410 --> 00:27:05,950
telly app for instance and it has a map

00:27:01,690 --> 00:27:08,320
in the center and then a joystick and we

00:27:05,950 --> 00:27:12,460
actually have our on the joystick and

00:27:08,320 --> 00:27:14,020
the Android core it will change the way

00:27:12,460 --> 00:27:15,970
it's displaying what's happening when

00:27:14,020 --> 00:27:17,320
you spin in place for instance it will

00:27:15,970 --> 00:27:19,000
show sort of an indicator of how far

00:27:17,320 --> 00:27:22,750
you've turned based on odometry messages

00:27:19,000 --> 00:27:24,940
so you execute that that joystick node

00:27:22,750 --> 00:27:26,410
and then it creates a subscriber to the

00:27:24,940 --> 00:27:29,110
odometry and it creates a publisher for

00:27:26,410 --> 00:27:32,800
CMD Bell things like that and gives you

00:27:29,110 --> 00:27:34,570
that full experience all at once so

00:27:32,800 --> 00:27:36,640
there are quite a few Android components

00:27:34,570 --> 00:27:39,280
already this list keeps growing I think

00:27:36,640 --> 00:27:40,810
and I the nice thing is is that if you

00:27:39,280 --> 00:27:42,370
go and you create you know a group or

00:27:40,810 --> 00:27:44,110
your application you create a view and

00:27:42,370 --> 00:27:45,640
you use this pattern and it's really

00:27:44,110 --> 00:27:48,670
easy for other people to reuse your

00:27:45,640 --> 00:27:51,310
component so the Ross text view an image

00:27:48,670 --> 00:27:53,890
view are just subscribers they subscribe

00:27:51,310 --> 00:27:56,440
and then like to a string message and

00:27:53,890 --> 00:27:59,500
then display it or to it to an image and

00:27:56,440 --> 00:28:02,830
display it the camera preview view

00:27:59,500 --> 00:28:04,900
actually takes uses the preview the

00:28:02,830 --> 00:28:08,530
camera preview view is what it's called

00:28:04,900 --> 00:28:09,970
and it publishes those images then

00:28:08,530 --> 00:28:12,190
there's orientation publishers and

00:28:09,970 --> 00:28:13,810
joysticks and then the visualization

00:28:12,190 --> 00:28:17,830
view is pretty new and that is actually

00:28:13,810 --> 00:28:19,540
a XY orthographic OpenGL view that we

00:28:17,830 --> 00:28:21,970
use to actually you saw in the demo

00:28:19,540 --> 00:28:27,010
video during the the navigation and the

00:28:21,970 --> 00:28:31,030
map building that uses that okay so just

00:28:27,010 --> 00:28:33,490
briefly about some best practices so

00:28:31,030 --> 00:28:36,220
java packages basically what we're

00:28:33,490 --> 00:28:37,930
trying to do right now is to use you

00:28:36,220 --> 00:28:40,150
know whatever it is your domain is like

00:28:37,930 --> 00:28:42,820
you would normally do in java followed

00:28:40,150 --> 00:28:44,920
by the the ross package name and that

00:28:42,820 --> 00:28:46,600
seems to work out pretty well so all of

00:28:44,920 --> 00:28:49,200
the ones that are at the core to Ross

00:28:46,600 --> 00:28:51,820
Java right now start with or cross and

00:28:49,200 --> 00:28:53,440
so you don't want to start yours with

00:28:51,820 --> 00:28:57,190
that because some it gets confusing as

00:28:53,440 --> 00:28:59,410
to where it belongs to for messages

00:28:57,190 --> 00:29:02,260
there are quite some collisions with

00:28:59,410 --> 00:29:03,280
like existing Java types so you want to

00:29:02,260 --> 00:29:06,360
be careful not to

00:29:03,280 --> 00:29:09,640
just import those if you import string

00:29:06,360 --> 00:29:12,040
bad things can happen so in general it's

00:29:09,640 --> 00:29:13,540
nice to just actually never import them

00:29:12,040 --> 00:29:15,430
and just use it because they actually

00:29:13,540 --> 00:29:16,780
have a very short package name the

00:29:15,430 --> 00:29:20,140
package name is actually just the

00:29:16,780 --> 00:29:22,080
message package and so you can just do

00:29:20,140 --> 00:29:25,690
send your messages dot string

00:29:22,080 --> 00:29:26,650
everywhere and then to use the use the

00:29:25,690 --> 00:29:27,970
convenience methods when they're

00:29:26,650 --> 00:29:30,370
available for what it is you're trying

00:29:27,970 --> 00:29:32,830
to do so creating a new message Factory

00:29:30,370 --> 00:29:34,960
or handing one around can be could be

00:29:32,830 --> 00:29:37,480
pretty problematic or you know

00:29:34,960 --> 00:29:38,860
cumbersome and so if new messages there

00:29:37,480 --> 00:29:41,680
you know look for something that will

00:29:38,860 --> 00:29:43,660
create what you want and then of course

00:29:41,680 --> 00:29:45,700
because everything is asynchronous here

00:29:43,660 --> 00:29:49,810
you should try to keep up with that so

00:29:45,700 --> 00:29:51,220
prefer callbacks to blocking I know in

00:29:49,810 --> 00:29:52,660
many cases it seems like walking is the

00:29:51,220 --> 00:29:57,190
only answer but usually that's not the

00:29:52,660 --> 00:29:58,720
case so give it some extra thought so

00:29:57,190 --> 00:30:00,640
currently what I'm working on is

00:29:58,720 --> 00:30:02,980
actually just trying to make sure that

00:30:00,640 --> 00:30:05,680
Ross Java has feature parity with Ross

00:30:02,980 --> 00:30:07,210
PI Ross CPE things like that make sure

00:30:05,680 --> 00:30:09,670
that it's actually completely feature

00:30:07,210 --> 00:30:12,250
complete it's pretty close it's not

00:30:09,670 --> 00:30:14,860
quite there yet and so along the way I'm

00:30:12,250 --> 00:30:15,910
trying to stabilize the API for those of

00:30:14,860 --> 00:30:18,400
you that have already been using it for

00:30:15,910 --> 00:30:21,700
quite some time you know it changes

00:30:18,400 --> 00:30:23,110
pretty frequently so and also been

00:30:21,700 --> 00:30:27,330
working a lot on the documentation so I

00:30:23,110 --> 00:30:29,320
hope I hope that is helping everybody

00:30:27,330 --> 00:30:31,630
the most of the documentation is

00:30:29,320 --> 00:30:34,330
auto-generated now from Java doc Java

00:30:31,630 --> 00:30:36,670
doc is having more complete and there's

00:30:34,330 --> 00:30:38,140
also some ynx documentation checked in

00:30:36,670 --> 00:30:41,500
and that and that follows that tracks

00:30:38,140 --> 00:30:43,690
the release process unlike the wiki so

00:30:41,500 --> 00:30:46,290
and overall I'm just trying to push for

00:30:43,690 --> 00:30:46,290
a 1.0 release

00:30:47,960 --> 00:30:53,419
so a few of the the future things I have

00:30:50,629 --> 00:30:55,009
in mind there's been some work on doing

00:30:53,419 --> 00:30:57,679
or SGI type things

00:30:55,009 --> 00:30:59,809
so especially loading nodes over the

00:30:57,679 --> 00:31:01,100
network along with their dependencies

00:30:59,809 --> 00:31:04,820
and things like that controlling their

00:31:01,100 --> 00:31:05,570
lifecycle remotely and then in order to

00:31:04,820 --> 00:31:07,340
support that

00:31:05,570 --> 00:31:08,899
groobie scripts we're doing deployment

00:31:07,340 --> 00:31:11,289
sort of along the length along the same

00:31:08,899 --> 00:31:14,779
lines as the build scripts currently are

00:31:11,289 --> 00:31:17,480
I'd also like to see sort of a pure Java

00:31:14,779 --> 00:31:21,409
deployment of Ross so that means you

00:31:17,480 --> 00:31:25,340
know helper CLI tools like Ross topic

00:31:21,409 --> 00:31:27,230
and things should be available and then

00:31:25,340 --> 00:31:29,059
some other things that may be during one

00:31:27,230 --> 00:31:31,519
of the birds of the feather talk I was

00:31:29,059 --> 00:31:33,289
happy to talk with people about is doing

00:31:31,519 --> 00:31:36,950
multiplexing topics over a single socket

00:31:33,289 --> 00:31:38,779
and sort of trying to rework some of the

00:31:36,950 --> 00:31:40,879
protocols that are currently in Ross

00:31:38,779 --> 00:31:42,860
that don't use topics to just depend on

00:31:40,879 --> 00:31:47,090
topics instead to sort of simplify the

00:31:42,860 --> 00:31:48,950
process of creating a client library and

00:31:47,090 --> 00:31:51,279
that's it so I think we probably have

00:31:48,950 --> 00:31:54,279
time for questions

00:31:51,279 --> 00:31:54,279
Thanks

00:32:24,870 --> 00:32:29,020
okay so the question was it seems like

00:32:27,820 --> 00:32:30,430
everybody wants to do pretty much the

00:32:29,020 --> 00:32:32,230
same thing with their Android phone they

00:32:30,430 --> 00:32:34,060
want to access all of the sensors as

00:32:32,230 --> 00:32:35,500
notes including the camera on gyroscopes

00:32:34,060 --> 00:32:36,400
and things like that is there anything

00:32:35,500 --> 00:32:38,860
that just does that

00:32:36,400 --> 00:32:40,210
and Chad rocky is actually working on

00:32:38,860 --> 00:32:42,750
the sensor driver and I think that's his

00:32:40,210 --> 00:32:44,950
goal so there's a sensor driver app that

00:32:42,750 --> 00:32:47,950
possibly right now when a does

00:32:44,950 --> 00:32:58,660
orientation but yeah I think that's the

00:32:47,950 --> 00:33:01,120
plan that was the yeah so the question

00:32:58,660 --> 00:33:02,800
was what was the RV's looking thing

00:33:01,120 --> 00:33:05,110
running on the tablet that is actually

00:33:02,800 --> 00:33:08,530
the visualization view that's available

00:33:05,110 --> 00:33:11,140
in the the honeycomb package actually

00:33:08,530 --> 00:33:13,600
and that's an XY orthographic OpenGL

00:33:11,140 --> 00:33:16,030
view that has multiple layers so I was

00:33:13,600 --> 00:33:22,450
like a map layer navigation layer path

00:33:16,030 --> 00:33:24,330
layer laser layer all kinds of stuff so

00:33:22,450 --> 00:33:27,690
is there something similar to our X plot

00:33:24,330 --> 00:33:27,690
not that I've seen

00:33:40,010 --> 00:33:46,500
okay so if you're a roster of a user and

00:33:43,020 --> 00:33:48,090
there is no Russ make hmm oh and you

00:33:46,500 --> 00:33:49,740
want to okay so you're not a roster of a

00:33:48,090 --> 00:33:52,670
user there is no Ross make for us to

00:33:49,740 --> 00:33:57,060
have a how do I use rostov of resources

00:33:52,670 --> 00:33:58,920
with the rest of Ross right okay yeah

00:33:57,060 --> 00:34:01,820
you need to right now you would actually

00:33:58,920 --> 00:34:05,190
build those yourself or you know

00:34:01,820 --> 00:34:07,830
download them from you know some

00:34:05,190 --> 00:34:10,770
distribution mechanism so I mean you can

00:34:07,830 --> 00:34:12,660
as a as a package or a stack maintainer

00:34:10,770 --> 00:34:14,130
you could write a pretty simple Ross

00:34:12,660 --> 00:34:19,260
makes script that would just execute

00:34:14,130 --> 00:34:23,370
Gradle in that case it would work but I

00:34:19,260 --> 00:34:24,900
think there's not really a clear idea of

00:34:23,370 --> 00:34:28,950
exactly how that should be integrated

00:34:24,900 --> 00:34:30,420
right now so yeah sorry that's not a

00:34:28,950 --> 00:34:33,020
very great answer to your question but

00:34:30,420 --> 00:34:33,020
it's a hard question

00:34:45,950 --> 00:34:50,569
okay so the question was for the the

00:34:47,990 --> 00:34:54,230
teleoperation app on the on the tablet

00:34:50,569 --> 00:34:55,490
was it an app yes yeah not on the not

00:34:54,230 --> 00:34:58,450
the other web I have seen things that

00:34:55,490 --> 00:34:58,450
are done over html5

00:35:08,230 --> 00:35:14,170
okay so I just barely heard you but I

00:35:11,470 --> 00:35:17,940
think it is there a API for listing

00:35:14,170 --> 00:35:17,940
topics and services yes

00:35:32,520 --> 00:35:36,760
right okay so the question is if I'm

00:35:35,350 --> 00:35:39,130
automatically generating all of these

00:35:36,760 --> 00:35:40,990
messages how does something like Android

00:35:39,130 --> 00:35:42,970
figure it out so originally I thought

00:35:40,990 --> 00:35:44,710
we're gonna go towards you know Android

00:35:42,970 --> 00:35:46,780
isn't support dynamic byte code

00:35:44,710 --> 00:35:48,250
generation which is true but this is not

00:35:46,780 --> 00:35:50,800
dynamic byte code generation this is

00:35:48,250 --> 00:35:54,430
called dynamic proxy and it's basically

00:35:50,800 --> 00:35:55,780
Java sanctioned black magic that's

00:35:54,430 --> 00:35:57,220
pretty awesome

00:35:55,780 --> 00:36:01,060
there's really not a whole lot of

00:35:57,220 --> 00:36:03,430
performance hit there essentially you

00:36:01,060 --> 00:36:06,280
when you depend on the rostra of a

00:36:03,430 --> 00:36:08,170
messages package you pull in that jar

00:36:06,280 --> 00:36:09,310
and that jar includes all of those empty

00:36:08,170 --> 00:36:11,020
interfaces and all those empty

00:36:09,310 --> 00:36:13,840
interfaces contain the definitions of

00:36:11,020 --> 00:36:16,060
strings and so that's where it finds it

00:36:13,840 --> 00:36:23,680
all did that answer your question

00:36:16,060 --> 00:36:25,750
oh so how does the rust row of a

00:36:23,680 --> 00:36:29,160
messages package find them all and it

00:36:25,750 --> 00:36:29,160
does that by growing your Ross path

00:36:34,930 --> 00:36:39,469
okay so is there a particular sorry a

00:36:37,549 --> 00:36:44,119
particular version of Android required

00:36:39,469 --> 00:36:46,459
for running this yes and no so the

00:36:44,119 --> 00:36:48,709
packages right now the base packages for

00:36:46,459 --> 00:36:50,779
the Android type stuff are named after

00:36:48,709 --> 00:36:52,039
the release of Android that is basically

00:36:50,779 --> 00:36:55,219
required for the features in that

00:36:52,039 --> 00:36:58,359
package currently the lowest common

00:36:55,219 --> 00:36:58,359
denominator is Gingerbread

00:37:09,600 --> 00:37:17,090
so can you tell your phone to your

00:37:11,940 --> 00:37:19,020
laptop and access Ross Java yeah maybe

00:37:17,090 --> 00:37:21,450
maybe I don't understand the question

00:37:19,020 --> 00:37:24,390
but I would say I mean it is it is a

00:37:21,450 --> 00:37:26,190
full implementation of Ross so you could

00:37:24,390 --> 00:37:27,420
go on to the your local network and

00:37:26,190 --> 00:37:31,020
access it just like you would anything

00:37:27,420 --> 00:37:32,190
else in Ross how does the Android build

00:37:31,020 --> 00:37:34,770
system integrate with the new Gradle

00:37:32,190 --> 00:37:39,330
based build system presently the way it

00:37:34,770 --> 00:37:41,730
works is that since there is no since

00:37:39,330 --> 00:37:43,740
there is no official Gradle plug-in or

00:37:41,730 --> 00:37:46,050
maven plug-in or anything for that

00:37:43,740 --> 00:37:49,260
matter for Android actually the the only

00:37:46,050 --> 00:37:51,860
Android command-line build tools are

00:37:49,260 --> 00:37:54,740
official that I'm aware of are for ant

00:37:51,860 --> 00:37:58,230
actually we use the Gradle and ant

00:37:54,740 --> 00:38:01,050
compatibility and so really the Android

00:37:58,230 --> 00:38:03,480
build tools are just wrapped very simply

00:38:01,050 --> 00:38:04,920
in Gradle it calls the it calls the

00:38:03,480 --> 00:38:09,300
stuff for you calls the ant scripts for

00:38:04,920 --> 00:38:11,220
you and there is no eclipse project

00:38:09,300 --> 00:38:13,440
generation on the command line for

00:38:11,220 --> 00:38:15,830
Android so there is no eclipse

00:38:13,440 --> 00:38:18,800
generation for Ross Java either

00:38:15,830 --> 00:38:21,900
basically the reason for that is that

00:38:18,800 --> 00:38:24,330
it's become too cumbersome to actually

00:38:21,900 --> 00:38:26,370
try to keep up with the Android changes

00:38:24,330 --> 00:38:28,980
to the Android build system and so I'm

00:38:26,370 --> 00:38:31,860
working with them instead to hopefully

00:38:28,980 --> 00:38:34,310
make that easier for external tools to

00:38:31,860 --> 00:38:34,310

YouTube URL: https://www.youtube.com/watch?v=ATuVExlkirY


