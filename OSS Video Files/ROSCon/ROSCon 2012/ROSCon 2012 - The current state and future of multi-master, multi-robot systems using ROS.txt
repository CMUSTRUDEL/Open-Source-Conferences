Title: ROSCon 2012 - The current state and future of multi-master, multi-robot systems using ROS
Publication date: 2014-08-31
Playlist: ROSCon 2012
Description: 
	Jeff Rousseau
The current state and future of multi-master, multi-robot systems using ROS
Captions: 
	00:00:00,130 --> 00:00:06,220
so next up is a Jeffers oh from aptina

00:00:02,949 --> 00:00:09,400
to talk about multi-robot systems with

00:00:06,220 --> 00:00:11,769
bras so I'm Jeffrey so a software

00:00:09,400 --> 00:00:13,840
engineer at a company called Optima

00:00:11,769 --> 00:00:16,810
where a research and development firm

00:00:13,840 --> 00:00:18,989
based out of boston massachusetts i'm

00:00:16,810 --> 00:00:22,119
also the coordinator on the multi master

00:00:18,989 --> 00:00:23,890
special interest group and this topic

00:00:22,119 --> 00:00:25,769
came about because over the past few

00:00:23,890 --> 00:00:28,720
years I've been struggling with issues

00:00:25,769 --> 00:00:31,210
in my lab trying to get my robots to

00:00:28,720 --> 00:00:34,360
communicate with each other over lossy

00:00:31,210 --> 00:00:35,860
Wi-Fi connections so basically I'm just

00:00:34,360 --> 00:00:39,100
a software engineer trying to scratch an

00:00:35,860 --> 00:00:41,110
itch I'm going to preface this talk with

00:00:39,100 --> 00:00:42,610
a big warning a lot of the techniques

00:00:41,110 --> 00:00:47,260
I'm going to mention today should be

00:00:42,610 --> 00:00:49,630
considered experimental much of the code

00:00:47,260 --> 00:00:53,890
in the multi master multi-robot domain

00:00:49,630 --> 00:00:55,480
is the wild type and then it's written

00:00:53,890 --> 00:00:58,210
for a particular prototype test case

00:00:55,480 --> 00:01:01,120
generally and then left largely

00:00:58,210 --> 00:01:02,560
untouched that said there's a lot of

00:01:01,120 --> 00:01:05,770
code that's out there that does exist

00:01:02,560 --> 00:01:07,539
and does work in its present state I'd

00:01:05,770 --> 00:01:10,530
like to point out that i'm not claiming

00:01:07,539 --> 00:01:13,149
expertise in all networking technologies

00:01:10,530 --> 00:01:16,149
even those relating to the current

00:01:13,149 --> 00:01:17,829
master implementation so I'm not a

00:01:16,149 --> 00:01:20,799
master and all things master related and

00:01:17,829 --> 00:01:23,590
i welcome you to question my assumptions

00:01:20,799 --> 00:01:27,639
because I'm just a single engineer in a

00:01:23,590 --> 00:01:29,020
single lab out of very very many the

00:01:27,639 --> 00:01:31,950
goal of this presentation is to shed

00:01:29,020 --> 00:01:34,569
some light on how masters presently work

00:01:31,950 --> 00:01:37,329
this topic seems to be an area of

00:01:34,569 --> 00:01:39,789
confusion for a number of users with

00:01:37,329 --> 00:01:41,350
ominous names like master it can be a

00:01:39,789 --> 00:01:45,100
bit confusing as to what the actual role

00:01:41,350 --> 00:01:46,929
of a master is an RO system another goal

00:01:45,100 --> 00:01:48,959
is to provide a simple solution for

00:01:46,929 --> 00:01:52,109
sharing limited topics between

00:01:48,959 --> 00:01:56,319
unreliably connected robots such as

00:01:52,109 --> 00:01:59,380
mobile robots that are in a field trying

00:01:56,319 --> 00:02:01,479
to communicate with each other I'll

00:01:59,380 --> 00:02:03,609
present some ideas for some future

00:02:01,479 --> 00:02:05,590
directions there are a number of

00:02:03,609 --> 00:02:09,070
interesting ways we can go with the

00:02:05,590 --> 00:02:11,590
master system in Ross including as what

00:02:09,070 --> 00:02:13,430
I'll mention later possibly getting rid

00:02:11,590 --> 00:02:15,500
of masters altogether

00:02:13,430 --> 00:02:18,799
and finally I'd like to raise some

00:02:15,500 --> 00:02:20,780
awareness for the multi master special

00:02:18,799 --> 00:02:23,299
interest group so we can nail down

00:02:20,780 --> 00:02:25,969
everybody's use cases that we need to

00:02:23,299 --> 00:02:31,250
support ideas for implementation other

00:02:25,969 --> 00:02:34,420
than my own so why run multiple masters

00:02:31,250 --> 00:02:37,689
and i'll give you my bias perspective

00:02:34,420 --> 00:02:41,450
we'll talk about what a ross master is

00:02:37,689 --> 00:02:43,219
what its role is when to split up your

00:02:41,450 --> 00:02:46,189
raw system if it makes sense to do so

00:02:43,219 --> 00:02:49,790
and some ways to do it i'm going to

00:02:46,189 --> 00:02:51,709
cover primarily the foreign relay method

00:02:49,790 --> 00:02:56,060
which has been wrapped in a number of

00:02:51,709 --> 00:03:01,159
different packages i'll mention some of

00:02:56,060 --> 00:03:03,769
those also note some make some notes on

00:03:01,159 --> 00:03:06,530
ross transports they're not really part

00:03:03,769 --> 00:03:08,389
of a multi master solution but they're

00:03:06,530 --> 00:03:11,180
usually lumped together in the same

00:03:08,389 --> 00:03:13,989
category because when you're dealing

00:03:11,180 --> 00:03:18,530
with multiple robots you're dealing with

00:03:13,989 --> 00:03:20,120
connections and connections tend to be a

00:03:18,530 --> 00:03:23,329
cause for concern when dealing with

00:03:20,120 --> 00:03:24,790
multiple robots so i'll discuss some

00:03:23,329 --> 00:03:27,019
limitations on the current master

00:03:24,790 --> 00:03:34,819
implementation and some ideas for the

00:03:27,019 --> 00:03:36,590
future so in a perfect world everything

00:03:34,819 --> 00:03:38,629
is connected all the time robots are

00:03:36,590 --> 00:03:41,750
connected to each other the internet

00:03:38,629 --> 00:03:43,280
everything robots never unexpectedly go

00:03:41,750 --> 00:03:46,159
offline their batteries never die they

00:03:43,280 --> 00:03:50,590
never wander into dead spots on your

00:03:46,159 --> 00:03:52,669
Wi-Fi network bandwidth is plentiful and

00:03:50,590 --> 00:03:55,359
everything's everything's great and

00:03:52,669 --> 00:03:58,129
there's no latency in the system but

00:03:55,359 --> 00:04:00,259
unfortunately when dealing with multiple

00:03:58,129 --> 00:04:01,849
robots especially connected over Wi-Fi

00:04:00,259 --> 00:04:05,120
in the real world we can't assume

00:04:01,849 --> 00:04:08,419
persistent connections machines go down

00:04:05,120 --> 00:04:11,689
suddenly things crash run out of

00:04:08,419 --> 00:04:15,049
batteries etc and bandwidth is usually

00:04:11,689 --> 00:04:18,109
severely limited especially in the field

00:04:15,049 --> 00:04:19,739
when we're dealing with networks like

00:04:18,109 --> 00:04:24,389
802 11

00:04:19,739 --> 00:04:27,780
like a and B stuff like that so high

00:04:24,389 --> 00:04:31,199
band Lewis topics sharing high bandwidth

00:04:27,780 --> 00:04:34,889
topics between robots like TF point

00:04:31,199 --> 00:04:36,930
clouds HD video there they'll easily

00:04:34,889 --> 00:04:42,810
take up the majority of your bandwidth

00:04:36,930 --> 00:04:46,110
between robots so I know done on some

00:04:42,810 --> 00:04:50,699
transports this is like I said this is

00:04:46,110 --> 00:04:53,430
not a multi master topic really but it

00:04:50,699 --> 00:04:55,830
always comes up in conversation so wait

00:04:53,430 --> 00:05:00,389
the primary transport it should be noted

00:04:55,830 --> 00:05:11,780
that Ross is TCP based which has a lot

00:05:00,389 --> 00:05:14,250
of excusing it can cause some issues so

00:05:11,780 --> 00:05:17,069
there are certain times when TCP isn't

00:05:14,250 --> 00:05:21,270
the best choice for communication

00:05:17,069 --> 00:05:25,289
transport between robots especially when

00:05:21,270 --> 00:05:31,500
latency is is prized over reliability so

00:05:25,289 --> 00:05:36,599
TCP is a reliable transport things like

00:05:31,500 --> 00:05:41,840
UDP multicast or not so you might want

00:05:36,599 --> 00:05:44,639
to for operation of robot over telly-op

00:05:41,840 --> 00:05:46,680
you might not care about the reliability

00:05:44,639 --> 00:05:50,520
of those messages you might not care

00:05:46,680 --> 00:05:52,440
that a message is coming in several

00:05:50,520 --> 00:05:54,389
seconds late because it did a bunch of

00:05:52,440 --> 00:05:56,639
retries that that message is old and

00:05:54,389 --> 00:05:58,770
it's not very useful same thing with

00:05:56,639 --> 00:06:03,000
audio and video streams so you might not

00:05:58,770 --> 00:06:05,310
care about getting every frame TCP is

00:06:03,000 --> 00:06:08,639
unicast meaning you need a connection to

00:06:05,310 --> 00:06:10,169
every machine if you have many nodes

00:06:08,639 --> 00:06:13,430
receiving data from relatively few

00:06:10,169 --> 00:06:16,009
publishers like a one two large n

00:06:13,430 --> 00:06:20,370
multicast protocols start to make sense

00:06:16,009 --> 00:06:24,360
so I started to look at a PGM solution

00:06:20,370 --> 00:06:27,080
which is a pseudo reliable multicast

00:06:24,360 --> 00:06:27,080
solution

00:06:28,460 --> 00:06:36,240
but that's just a small aside to the

00:06:32,550 --> 00:06:38,840
conversation about multimaster so let's

00:06:36,240 --> 00:06:42,600
talk about what a master actually is

00:06:38,840 --> 00:06:44,760
it's an xml RPC server that's an

00:06:42,600 --> 00:06:47,880
implementation detail but it's a kind of

00:06:44,760 --> 00:06:49,500
important one if you need to know if you

00:06:47,880 --> 00:06:52,530
need to debug what's going wrong in your

00:06:49,500 --> 00:06:56,850
system you can kind of think of a master

00:06:52,530 --> 00:07:00,780
as dns it's it's it's where nodes go to

00:06:56,850 --> 00:07:03,210
advertise a given topic and type so it's

00:07:00,780 --> 00:07:08,280
a dictionary store of connection

00:07:03,210 --> 00:07:09,810
information and topic names subscribers

00:07:08,280 --> 00:07:11,580
also go there to find their publishers

00:07:09,810 --> 00:07:14,370
and service your eyes are also stored

00:07:11,580 --> 00:07:19,020
there and the master is often bundled

00:07:14,370 --> 00:07:22,650
with a parameter server so raw score is

00:07:19,020 --> 00:07:27,750
actually a instantiation of Ross launch

00:07:22,650 --> 00:07:32,790
that creates a raspa Ram server and a

00:07:27,750 --> 00:07:35,600
master server so let's walk through an

00:07:32,790 --> 00:07:38,910
example of how master transaction works

00:07:35,600 --> 00:07:45,960
so here we have a camera node and an

00:07:38,910 --> 00:07:48,540
image image viewer node trying to talk

00:07:45,960 --> 00:07:51,360
to each other so a camera the camera

00:07:48,540 --> 00:07:55,680
node says to the master i would like to

00:07:51,360 --> 00:07:57,600
publish this topic of this type and the

00:07:55,680 --> 00:08:04,290
master takes its connection information

00:07:57,600 --> 00:08:07,440
for its slave xmlrpc and then the image

00:08:04,290 --> 00:08:09,750
viewer comes along and says i would like

00:08:07,440 --> 00:08:12,000
to receive images on this topic is there

00:08:09,750 --> 00:08:13,200
anybody advertising and the master says

00:08:12,000 --> 00:08:17,880
yes and it gives it the connection

00:08:13,200 --> 00:08:20,220
information and then they they build a

00:08:17,880 --> 00:08:23,360
connection to each other and now the

00:08:20,220 --> 00:08:30,140
transaction to the master is done so

00:08:23,360 --> 00:08:33,890
let's do a quick experiment so I have a

00:08:30,140 --> 00:08:33,890
see if i can find my most

00:08:35,760 --> 00:08:46,410
so have a bun to vm here where's my mess

00:08:47,550 --> 00:08:50,760
there we go

00:08:51,070 --> 00:08:54,660
so if i run a raw score here

00:09:01,300 --> 00:09:04,140
ok

00:09:10,520 --> 00:09:15,440
so basically what I've taken here is I

00:09:12,560 --> 00:09:18,980
have this package that it's basically

00:09:15,440 --> 00:09:21,740
the tutorials for making a simple

00:09:18,980 --> 00:09:26,330
publisher and subscriber and if I run

00:09:21,740 --> 00:09:29,770
the talker start spitting out string

00:09:26,330 --> 00:09:29,770
messages on a chatter topic

00:09:37,560 --> 00:09:43,170
and similarly there's a listener it's

00:09:40,620 --> 00:09:49,500
receiving all those messages so what

00:09:43,170 --> 00:09:53,520
happens if the master goes down there

00:09:49,500 --> 00:09:58,620
still transferring so since like in the

00:09:53,520 --> 00:10:00,510
diagram in the presentation the master

00:09:58,620 --> 00:10:02,180
transactions over and these guys are

00:10:00,510 --> 00:10:05,339
still communicating it with each other

00:10:02,180 --> 00:10:11,430
but there's some issues so what what

00:10:05,339 --> 00:10:14,100
would happen let's first try and do

00:10:11,430 --> 00:10:15,300
a Ross topic list and we can because

00:10:14,100 --> 00:10:17,850
there's no master because the master

00:10:15,300 --> 00:10:23,660
stores all the information for all the

00:10:17,850 --> 00:10:23,660
listing so if we start up a new master

00:10:27,710 --> 00:10:35,490
and we do a rasta pick list there's no

00:10:32,520 --> 00:10:39,360
nodes so these guys are orphaned there's

00:10:35,490 --> 00:10:42,420
no way you can add new listeners to

00:10:39,360 --> 00:10:48,330
these topics that exist and are

00:10:42,420 --> 00:10:50,130
transferring data so basically you're

00:10:48,330 --> 00:10:55,290
kind of in trouble right now and even if

00:10:50,130 --> 00:10:56,880
you tried to do russ node kill all it

00:10:55,290 --> 00:11:00,390
just killed raw so these guys are still

00:10:56,880 --> 00:11:03,540
running so you have to be very careful

00:11:00,390 --> 00:11:05,580
about this type of stuff so if you take

00:11:03,540 --> 00:11:08,940
your master down and you're trying to

00:11:05,580 --> 00:11:12,030
debug something in like our biz and you

00:11:08,940 --> 00:11:15,360
restart your master all those topics

00:11:12,030 --> 00:11:17,580
that you were hoping to look at are not

00:11:15,360 --> 00:11:21,350
going to be there so that's a very

00:11:17,580 --> 00:11:21,350
common problem that I've run into

00:11:27,930 --> 00:11:36,040
so what did we learn let's see so if we

00:11:34,180 --> 00:11:37,959
lose our master publishers and

00:11:36,040 --> 00:11:41,889
subscribers with already established

00:11:37,959 --> 00:11:43,899
connections continue to work sort of if

00:11:41,889 --> 00:11:46,209
masters can't return say they were on a

00:11:43,899 --> 00:11:47,769
foreign machine that's down we can't add

00:11:46,209 --> 00:11:49,959
new subscribers to the existing

00:11:47,769 --> 00:11:53,129
publishers we can't call any raw

00:11:49,959 --> 00:11:55,389
services or access any Ross parameters

00:11:53,129 --> 00:11:58,329
if we start up a new master the old

00:11:55,389 --> 00:12:00,220
nodes are orphaned there's no wait for

00:11:58,329 --> 00:12:03,100
the master to have any idea that they

00:12:00,220 --> 00:12:09,879
even exist so Ross topic list etc all

00:12:03,100 --> 00:12:13,389
those tools they won't work so going

00:12:09,879 --> 00:12:15,610
from a single to multiple masters so

00:12:13,389 --> 00:12:20,350
most nodes that rely heavily on dynamic

00:12:15,610 --> 00:12:22,149
parameters and setting up new nodes on

00:12:20,350 --> 00:12:25,930
the net on the network will not fail

00:12:22,149 --> 00:12:27,910
gracefully if the Masters intermittently

00:12:25,930 --> 00:12:30,759
offline so you say you have a Wi-Fi

00:12:27,910 --> 00:12:33,129
connection to a server and it's kind of

00:12:30,759 --> 00:12:35,559
kind of its kind of flaky this situation

00:12:33,129 --> 00:12:36,730
wouldn't be very useful for a robot with

00:12:35,559 --> 00:12:41,860
high autonomy that's trying to get work

00:12:36,730 --> 00:12:45,670
done another situation and when I deal

00:12:41,860 --> 00:12:47,829
with in my lab is if your robot wants to

00:12:45,670 --> 00:12:51,569
connect to services that it doesn't know

00:12:47,829 --> 00:12:56,620
about a configuration time so right now

00:12:51,569 --> 00:12:58,809
a master needs to exist for publishers

00:12:56,620 --> 00:13:03,790
and scrubbers who to basically start

00:12:58,809 --> 00:13:05,920
doing their jobs so if you have a robot

00:13:03,790 --> 00:13:08,110
that's wandering into a lab that has a

00:13:05,920 --> 00:13:11,920
server with a service on it saying like

00:13:08,110 --> 00:13:13,929
I oh I have a map that that Ross system

00:13:11,920 --> 00:13:16,000
on that server has to exist

00:13:13,929 --> 00:13:20,910
independently of the Ross system that's

00:13:16,000 --> 00:13:24,550
on the robot so these are two reasons

00:13:20,910 --> 00:13:28,749
possibly some debatable good reasons for

00:13:24,550 --> 00:13:30,790
having multiple masters so what I'm

00:13:28,749 --> 00:13:33,699
going to talk about is foreign relay as

00:13:30,790 --> 00:13:36,579
the the main basis for sharing topics

00:13:33,699 --> 00:13:39,339
between two raw systems that are running

00:13:36,579 --> 00:13:39,680
their own masters so let's peek under

00:13:39,339 --> 00:13:44,320
the hood

00:13:39,680 --> 00:13:44,320
of foreign relay so

00:13:52,940 --> 00:14:02,240
yeah so here's a one Russ system this is

00:13:58,310 --> 00:14:05,110
a vm again what we're going to do is

00:14:02,240 --> 00:14:05,110
we're going to start another vm

00:14:12,810 --> 00:14:15,620
hopefully

00:14:23,420 --> 00:14:28,470
okay so this guy is running a rascal

00:14:25,560 --> 00:14:30,710
right now we're going to close down this

00:14:28,470 --> 00:14:30,710
stuff

00:14:42,300 --> 00:14:50,460
so we should be in a happy state right

00:14:44,370 --> 00:15:00,410
now Russ list yep and on the other

00:14:50,460 --> 00:15:00,410
machine will do the same thing

00:15:06,550 --> 00:15:08,610
you

00:15:09,820 --> 00:15:15,160
now what we're going to do is we're so

00:15:13,420 --> 00:15:18,210
just imagine that these are two separate

00:15:15,160 --> 00:15:22,750
robots or a robot and a service on a

00:15:18,210 --> 00:15:26,500
separate server and we're going to run

00:15:22,750 --> 00:15:29,200
 on both of them and Ford chatter

00:15:26,500 --> 00:15:31,290
topic from the tutorials one to the

00:15:29,200 --> 00:15:31,290
other

00:15:50,760 --> 00:15:56,910
so the note I'm going to run right here

00:15:54,390 --> 00:15:59,880
is called foreign relay and if we look

00:15:56,910 --> 00:16:01,740
at it it takes in whether or not you're

00:15:59,880 --> 00:16:05,280
going to advertise to a foreign master

00:16:01,740 --> 00:16:10,410
or subscribe the topic and then the

00:16:05,280 --> 00:16:13,730
foreign master URI so we're going to

00:16:10,410 --> 00:16:13,730
advertise our chatter topic

00:16:22,430 --> 00:16:25,960
let me make sure I'm on the right

00:16:23,630 --> 00:16:25,960
machine

00:16:32,640 --> 00:16:34,700
you

00:16:48,800 --> 00:16:56,390
so if we go over here right now for

00:16:54,260 --> 00:16:58,010
Chado topic so we have two separate raw

00:16:56,390 --> 00:17:00,580
system stuck with each other over a

00:16:58,010 --> 00:17:00,580
foreign relay

00:17:13,150 --> 00:17:16,360
which is pretty neat so let's look at

00:17:15,130 --> 00:17:18,720
what foreign relay is actually doing

00:17:16,360 --> 00:17:18,720
under the hood

00:17:30,419 --> 00:17:33,200
oops

00:17:41,590 --> 00:17:46,390
so one of the first things you might

00:17:43,570 --> 00:17:49,240
notice in this Python node is it's

00:17:46,390 --> 00:17:51,880
actually not a node it's not using the

00:17:49,240 --> 00:17:54,730
raw spy client library it's actually

00:17:51,880 --> 00:17:56,230
calling xml RPC calls directly that's

00:17:54,730 --> 00:18:00,789
that's pretty much all this thing's

00:17:56,230 --> 00:18:03,669
doing so if you look in the the main

00:18:00,789 --> 00:18:05,350
method basically all it does is do a

00:18:03,669 --> 00:18:10,350
parson the arguments you pass it and

00:18:05,350 --> 00:18:10,350
then call the go function

00:18:15,299 --> 00:18:19,639
so basically all it does is get all the

00:18:17,340 --> 00:18:22,019
published topics from the master and

00:18:19,639 --> 00:18:23,639
then it iterates through until it finds

00:18:22,019 --> 00:18:26,580
a match on the topic type and then it

00:18:23,639 --> 00:18:29,940
iterates through and finds a matching

00:18:26,580 --> 00:18:32,220
publisher and it does this at a

00:18:29,940 --> 00:18:36,029
pre-configured rate right now it's one

00:18:32,220 --> 00:18:38,759
hurts and all it does is try and sink

00:18:36,029 --> 00:18:42,749
the state between those two and if you

00:18:38,759 --> 00:18:47,159
do a so that's what these two lines are

00:18:42,749 --> 00:18:49,289
doing right here if it sees any

00:18:47,159 --> 00:18:50,700
differences between advertising and

00:18:49,289 --> 00:18:53,340
subscribing between these two foreign

00:18:50,700 --> 00:18:54,960
masters are between these two masters it

00:18:53,340 --> 00:18:58,529
sinks those differences and unregistered

00:18:54,960 --> 00:19:00,679
when are necessary and registers where

00:18:58,529 --> 00:19:00,679
necessary

00:19:16,980 --> 00:19:19,040
you

00:19:25,549 --> 00:19:31,090
so what are some of the limitations of

00:19:27,830 --> 00:19:34,759
foreign relay so the primary one that I

00:19:31,090 --> 00:19:36,019
found at least in my use case is that

00:19:34,759 --> 00:19:40,460
you need to know the state of your raw

00:19:36,019 --> 00:19:43,399
system at configuration time as this is

00:19:40,460 --> 00:19:47,029
a node you have to write a bunch of

00:19:43,399 --> 00:19:48,320
launch scripts basically that are going

00:19:47,029 --> 00:19:49,999
to relay the topics that you care about

00:19:48,320 --> 00:19:51,830
to the machines that you care about so

00:19:49,999 --> 00:19:54,320
you have to know about those machines

00:19:51,830 --> 00:19:58,899
ahead of time which kind of defeats the

00:19:54,320 --> 00:20:01,460
purpose there's also no good way for

00:19:58,899 --> 00:20:07,399
notes to know when foreign masters go

00:20:01,460 --> 00:20:08,749
away so if if other than attempting to

00:20:07,399 --> 00:20:12,169
make service calls and then catching

00:20:08,749 --> 00:20:15,679
exceptions but that's not a very clean

00:20:12,169 --> 00:20:19,460
way of doing it on a related note

00:20:15,679 --> 00:20:22,249
there's an old issue in the master

00:20:19,460 --> 00:20:24,200
master issue tracker about adding time

00:20:22,249 --> 00:20:27,259
to live to master registrations which

00:20:24,200 --> 00:20:29,809
might be worth revisiting if implemented

00:20:27,259 --> 00:20:32,239
you might be able to detect and notify

00:20:29,809 --> 00:20:38,749
subscribe nodes when their subscriptions

00:20:32,239 --> 00:20:40,519
have expired and I mentioned that

00:20:38,749 --> 00:20:43,489
there's no programmatic interface to

00:20:40,519 --> 00:20:45,049
foreign relay so some people have made

00:20:43,489 --> 00:20:47,389
some clever workarounds this is a

00:20:45,049 --> 00:20:50,419
current popular work round that's used

00:20:47,389 --> 00:20:53,899
in Wi-Fi comms which is something that

00:20:50,419 --> 00:21:00,230
wraps the foreign relay into a more

00:20:53,899 --> 00:21:04,070
general more full-blown multi master

00:21:00,230 --> 00:21:05,960
system and basically if you look at the

00:21:04,070 --> 00:21:11,600
code it's basically just running the

00:21:05,960 --> 00:21:17,119
command line tools drew code it's a hack

00:21:11,600 --> 00:21:20,239
but it works another approach which is 1

00:21:17,119 --> 00:21:22,669
i've i've been working on is to actually

00:21:20,239 --> 00:21:26,179
use the multi master approach in ross

00:21:22,669 --> 00:21:29,739
java where you can unlike most language

00:21:26,179 --> 00:21:32,629
bindings like ross CP cpp and Ross PI

00:21:29,739 --> 00:21:36,499
Java allows you to programmatically

00:21:32,629 --> 00:21:38,150
instantiate masters and nodes can be

00:21:36,499 --> 00:21:43,100
pre-configured

00:21:38,150 --> 00:21:44,750
to attach to a given master so each each

00:21:43,100 --> 00:21:46,670
node can be configured to run on any

00:21:44,750 --> 00:21:48,890
number of master whether its foreign or

00:21:46,670 --> 00:21:51,710
local so this leads to some interesting

00:21:48,890 --> 00:21:53,180
applications where that can I can span

00:21:51,710 --> 00:21:56,450
master boundaries when paired with

00:21:53,180 --> 00:22:02,300
service discovery mechanisms like like 0

00:21:56,450 --> 00:22:05,600
comp so here's an example code snippet

00:22:02,300 --> 00:22:06,890
from Ross Java showing a node and a node

00:22:05,600 --> 00:22:10,880
runner being instantiated with a

00:22:06,890 --> 00:22:12,380
connection to a particular master next

00:22:10,880 --> 00:22:14,480
I'm going to show you an application I

00:22:12,380 --> 00:22:17,020
built using 0 comp service discovery to

00:22:14,480 --> 00:22:19,010
detect for masters and launch runners

00:22:17,020 --> 00:22:20,630
programmatically on the Ross Java side

00:22:19,010 --> 00:22:23,630
with connections to each of those

00:22:20,630 --> 00:22:26,920
foreign masters so this is basically

00:22:23,630 --> 00:22:29,750
just a diagram showing that so each

00:22:26,920 --> 00:22:33,620
machine in this system runs its own raw

00:22:29,750 --> 00:22:35,180
score including the tablet itself so I

00:22:33,620 --> 00:22:37,550
have an Android tablet running a raw

00:22:35,180 --> 00:22:40,520
score and zeroconf and then i have three

00:22:37,550 --> 00:22:42,470
robots or i've only gone up to three in

00:22:40,520 --> 00:22:45,710
my lab but uh that's what I'm limited to

00:22:42,470 --> 00:22:47,300
but three robots running around and if I

00:22:45,710 --> 00:22:50,150
took a new robot into my lab running

00:22:47,300 --> 00:22:51,770
this stack the Android interface would

00:22:50,150 --> 00:22:53,360
detect it through zero comp and then

00:22:51,770 --> 00:23:03,680
attached to its its master

00:22:53,360 --> 00:23:11,390
programmatically and this is a video and

00:23:03,680 --> 00:23:13,190
maybe it'll work so this is a so this is

00:23:11,390 --> 00:23:16,540
me just doing some testing of the

00:23:13,190 --> 00:23:18,920
Android interface um right now there

00:23:16,540 --> 00:23:22,670
where this is this is done with

00:23:18,920 --> 00:23:24,680
simulation but we have we have three

00:23:22,670 --> 00:23:31,510
turtlebot like platforms running around

00:23:24,680 --> 00:23:34,190
our lab right now so this is running a

00:23:31,510 --> 00:23:35,900
html5 interface on top of the Android

00:23:34,190 --> 00:23:38,390
Ross Java which is running its own

00:23:35,900 --> 00:23:40,790
master which is connecting to that

00:23:38,390 --> 00:23:45,050
simulated navigation stack through stage

00:23:40,790 --> 00:23:47,950
in this case but it works just fine on

00:23:45,050 --> 00:23:47,950
actual robots as well

00:23:55,309 --> 00:24:01,970
some notes on this application so Ross

00:23:58,340 --> 00:24:07,639
Java only supports TCP as a transport at

00:24:01,970 --> 00:24:09,559
least for now so if you rely on being

00:24:07,639 --> 00:24:13,669
connected to or actually if your Valley

00:24:09,559 --> 00:24:17,629
on trying to transfer compressed image

00:24:13,669 --> 00:24:19,730
topics for example over Ross Java it

00:24:17,629 --> 00:24:23,600
won't degrade very well as the

00:24:19,730 --> 00:24:25,340
connection gets bad so if you go if you

00:24:23,600 --> 00:24:29,200
go to a place with a weak RSSI and

00:24:25,340 --> 00:24:32,929
you're in your wireless network system

00:24:29,200 --> 00:24:34,249
bad things will start happening but

00:24:32,929 --> 00:24:38,419
hopefully this will be fixed in the

00:24:34,249 --> 00:24:40,789
future on App actual robots I need to

00:24:38,419 --> 00:24:44,389
throttle a number of topics especially

00:24:40,789 --> 00:24:50,179
TF stuff like pose messages coming from

00:24:44,389 --> 00:24:53,330
a mcl to get a decent response time so a

00:24:50,179 --> 00:24:55,070
lot of Tia stuff over Wi-Fi can and

00:24:53,330 --> 00:25:01,070
cause a lot of issues especially if

00:24:55,070 --> 00:25:04,340
you're doing TCP transport so some ideas

00:25:01,070 --> 00:25:06,350
for the future one idea is to have like

00:25:04,340 --> 00:25:10,249
a public master you can kind of think of

00:25:06,350 --> 00:25:12,230
this as a sort of bridge which would

00:25:10,249 --> 00:25:13,700
only expose topics that would be

00:25:12,230 --> 00:25:19,309
interesting and useful to foreign Ross

00:25:13,700 --> 00:25:22,309
Ross machines which would be also

00:25:19,309 --> 00:25:24,110
running their own public master this

00:25:22,309 --> 00:25:28,009
would be geared towards limiting the

00:25:24,110 --> 00:25:35,269
availability to only public api's 24

00:25:28,009 --> 00:25:39,230
machines and to credit Morgan the the

00:25:35,269 --> 00:25:40,490
idea of higher hierarchical masters so

00:25:39,230 --> 00:25:44,119
it's kind of building on the DNS

00:25:40,490 --> 00:25:48,519
metaphor so a super master could have

00:25:44,119 --> 00:25:48,519
like sub masters etc

00:25:51,149 --> 00:25:56,489
and a related idea like I said not

00:25:53,759 --> 00:25:58,139
strictly multimaster but improving

00:25:56,489 --> 00:26:00,599
transports is a pretty important thing

00:25:58,139 --> 00:26:05,369
to do when dealing with leaky Wi-Fi

00:26:00,599 --> 00:26:08,460
connections so UDP Ross is only

00:26:05,369 --> 00:26:11,729
implemented in C++ and it has some

00:26:08,460 --> 00:26:14,549
quirks to it so we might want to expand

00:26:11,729 --> 00:26:17,249
and or actually simplify the protocol

00:26:14,549 --> 00:26:19,700
that is implemented as well as

00:26:17,249 --> 00:26:21,989
investigate other transport mechanisms

00:26:19,700 --> 00:26:25,169
one idea is to actually switch to

00:26:21,989 --> 00:26:28,109
something like zeromq which implements a

00:26:25,169 --> 00:26:39,210
number of them under the hood like open

00:26:28,109 --> 00:26:41,099
PGM and UDP and tcp another idea is to

00:26:39,210 --> 00:26:45,359
totally get rid of masters altogether

00:26:41,099 --> 00:26:48,089
they are a single point of failure so no

00:26:45,359 --> 00:26:50,190
masters at all is also kind of like

00:26:48,089 --> 00:26:52,499
everyone's a master depending on how you

00:26:50,190 --> 00:26:54,779
look at it so much like peer-to-peer

00:26:52,499 --> 00:26:59,729
networks if you have an address of a

00:26:54,779 --> 00:27:04,789
known peer much like the master URI it

00:26:59,729 --> 00:27:08,460
exists now you can property propagate

00:27:04,789 --> 00:27:11,129
queries along along the path of its

00:27:08,460 --> 00:27:12,210
neighbors so that it knows about this is

00:27:11,129 --> 00:27:14,339
this is something that came up in

00:27:12,210 --> 00:27:20,129
conversation with dark yesterday

00:27:14,339 --> 00:27:21,960
actually in one of the big open

00:27:20,129 --> 00:27:24,749
questions at least for me is whether or

00:27:21,960 --> 00:27:27,539
not transports should be built into Ross

00:27:24,749 --> 00:27:31,859
proper or they should reside in sort of

00:27:27,539 --> 00:27:35,029
bridge or gateway nodes to reduce

00:27:31,859 --> 00:27:38,190
complexity of the raw system itself or

00:27:35,029 --> 00:27:41,249
or should it actually belong inside Ross

00:27:38,190 --> 00:27:43,440
and you get to choose the transport the

00:27:41,249 --> 00:27:48,659
author at configuration or runtime of

00:27:43,440 --> 00:27:50,190
your node and another big question that

00:27:48,659 --> 00:27:52,619
a lot comes up a lot on the mailing list

00:27:50,190 --> 00:27:56,460
is whether or not we should share TF

00:27:52,619 --> 00:27:59,309
information between unreliably connected

00:27:56,460 --> 00:28:02,489
machines currently what I do is I

00:27:59,309 --> 00:28:04,830
actually subscribe to I have a TF

00:28:02,489 --> 00:28:06,720
listener that asks for TF messages

00:28:04,830 --> 00:28:08,940
and then puts it on a low-bandwidth

00:28:06,720 --> 00:28:10,409
topic and then forwards it to the robots

00:28:08,940 --> 00:28:14,370
which then insert it into their own

00:28:10,409 --> 00:28:15,990
transform tree but maybe we want to

00:28:14,370 --> 00:28:23,820
think about an automated way of doing

00:28:15,990 --> 00:28:26,429
this and I'd like to plug the multi

00:28:23,820 --> 00:28:28,200
master cig again so if you have a

00:28:26,429 --> 00:28:31,500
particular use case in mind beyond

00:28:28,200 --> 00:28:33,600
multi-robot systems if you have any

00:28:31,500 --> 00:28:36,000
ideas for multi master beyond what I've

00:28:33,600 --> 00:28:39,720
mentioned today you should join this

00:28:36,000 --> 00:28:45,480
thing we've moved from the mailman

00:28:39,720 --> 00:28:51,740
archives from the last cig to a Google

00:28:45,480 --> 00:28:55,139
Group and this is the URL so in summary

00:28:51,740 --> 00:28:57,750
what we've covered we've covered what a

00:28:55,139 --> 00:29:00,570
master is why you might want to have

00:28:57,750 --> 00:29:02,820
more than one we've also covered an

00:29:00,570 --> 00:29:06,389
example foreign relay of a topic from

00:29:02,820 --> 00:29:08,970
one master to another we've mentioned

00:29:06,389 --> 00:29:14,570
some future directions for multi master

00:29:08,970 --> 00:29:17,490
and a plug for the sig of course the

00:29:14,570 --> 00:29:21,990
multi master birds of a feather talk

00:29:17,490 --> 00:29:24,090
will be happening right now after after

00:29:21,990 --> 00:29:26,330
this talk during the lunch break so

00:29:24,090 --> 00:29:29,929
anybody interested should come see me

00:29:26,330 --> 00:29:29,929
does anybody have any questions

00:29:36,650 --> 00:29:42,810
yep so what the question is what has my

00:29:40,590 --> 00:29:46,470
experience been using these experimental

00:29:42,810 --> 00:29:49,800
tools on a regular basis I found that

00:29:46,470 --> 00:29:53,420
they work right in a lab setting I deal

00:29:49,800 --> 00:29:56,880
with my day job I deal with a lot of

00:29:53,420 --> 00:29:58,590
feel double robots things like pack pots

00:29:56,880 --> 00:30:02,520
and stuff like that which we actually

00:29:58,590 --> 00:30:04,500
have rust bindings for by the way and it

00:30:02,520 --> 00:30:07,500
doesn't work so well in the field that

00:30:04,500 --> 00:30:10,320
needs to change if we're going to go

00:30:07,500 --> 00:30:12,750
beyond the lab so especially robots that

00:30:10,320 --> 00:30:15,510
are literally deployed outside that

00:30:12,750 --> 00:30:16,620
don't have access to wireless routers

00:30:15,510 --> 00:30:19,230
and stuff like that they have to deal

00:30:16,620 --> 00:30:22,230
with ad hoc networks with really low

00:30:19,230 --> 00:30:24,450
throughput those tools don't work very

00:30:22,230 --> 00:30:26,930
well right now and some of the problems

00:30:24,450 --> 00:30:29,820
are with synchronization between masters

00:30:26,930 --> 00:30:33,780
it's it just doesn't work that well

00:30:29,820 --> 00:30:36,630
right now we're using xml RPC which is

00:30:33,780 --> 00:30:40,020
over HTTP requests which is over tcp it

00:30:36,630 --> 00:30:41,460
might not be the best choice it works in

00:30:40,020 --> 00:30:43,200
a lot of cases a lot of times you can

00:30:41,460 --> 00:30:45,060
just catch the exceptions when something

00:30:43,200 --> 00:30:46,230
goes wrong and keep trying over and over

00:30:45,060 --> 00:30:49,680
and over until you finally get your

00:30:46,230 --> 00:30:54,960
request through but there's a lot of

00:30:49,680 --> 00:30:57,660
work to do so the question was would it

00:30:54,960 --> 00:31:01,530
be useful to have a machine in the

00:30:57,660 --> 00:31:04,050
middle of trying to simulate a bandwidth

00:31:01,530 --> 00:31:06,240
constraints between two machines I think

00:31:04,050 --> 00:31:08,850
that's a great idea I haven't tried that

00:31:06,240 --> 00:31:12,360
I've been I've been limited to just the

00:31:08,850 --> 00:31:14,250
hardware that I have at my lab and to be

00:31:12,360 --> 00:31:16,350
honest just changing routers makes a

00:31:14,250 --> 00:31:19,260
huge difference and characteristics

00:31:16,350 --> 00:31:21,480
change all the time so having something

00:31:19,260 --> 00:31:27,380
that could programmatically go through

00:31:21,480 --> 00:31:29,790
all those scenarios would be great oh I

00:31:27,380 --> 00:31:33,110
played okay so the question was whether

00:31:29,790 --> 00:31:37,470
or not you can basically cache the data

00:31:33,110 --> 00:31:40,050
that you want to send to a remote ross

00:31:37,470 --> 00:31:42,330
system when the connection becomes

00:31:40,050 --> 00:31:44,010
available i played around with toya

00:31:42,330 --> 00:31:48,870
implementations of this but the main

00:31:44,010 --> 00:31:52,320
problem is when you depend on large

00:31:48,870 --> 00:31:55,010
pieces of existing Ross nodes that don't

00:31:52,320 --> 00:31:59,390
handle the exceptions for missing

00:31:55,010 --> 00:32:02,010
masters a lot of bad things can happen

00:31:59,390 --> 00:32:03,840
but that's probably just something that

00:32:02,010 --> 00:32:06,420
just needs to be fixed in those nodes

00:32:03,840 --> 00:32:11,010
that make assumptions about persistent

00:32:06,420 --> 00:32:14,280
masters it's basically just the the

00:32:11,010 --> 00:32:17,070
nodes get confused because they they

00:32:14,280 --> 00:32:21,530
they think that they're connected to a

00:32:17,070 --> 00:32:26,490
system and they're not or vice versa

00:32:21,530 --> 00:32:29,780
okay I I could actually show you by yeah

00:32:26,490 --> 00:32:33,330
I can't show you about but um the the

00:32:29,780 --> 00:32:38,700
easiest way to think about it is um if

00:32:33,330 --> 00:32:41,970
something went wrong on a on Ross node

00:32:38,700 --> 00:32:46,200
that was a registered to a master and

00:32:41,970 --> 00:32:48,750
didn't unregister and then another node

00:32:46,200 --> 00:32:53,580
tries to connect it tries to open a

00:32:48,750 --> 00:32:56,970
connection to that old a URI string

00:32:53,580 --> 00:32:59,010
that's in the Masters dictionary and

00:32:56,970 --> 00:33:05,070
nothing nothing Goods gonna come out of

00:32:59,010 --> 00:33:07,800
that so does it does that help yeah yeah

00:33:05,070 --> 00:33:15,240
so so in the foreign real eggs with up

00:33:07,800 --> 00:33:18,030
also the the scaling the question is how

00:33:15,240 --> 00:33:20,910
do scale between one node and three

00:33:18,030 --> 00:33:22,380
nodes and whether or not it's just a the

00:33:20,910 --> 00:33:25,140
difference between writing more launch

00:33:22,380 --> 00:33:27,929
scripts and it is as long as you take

00:33:25,140 --> 00:33:30,570
into account bandwidth constraints a lot

00:33:27,929 --> 00:33:32,640
of times you just have to relate to

00:33:30,570 --> 00:33:35,850
throttle topics and only afford those

00:33:32,640 --> 00:33:38,040
throttle topics just to make sure that

00:33:35,850 --> 00:33:39,420
you don't exceed your bandwidth and

00:33:38,040 --> 00:33:44,929
crash the network because everything is

00:33:39,420 --> 00:33:47,340
running over TCP so the question was

00:33:44,929 --> 00:33:51,380
whether or not I believe there's a

00:33:47,340 --> 00:33:56,840
heuristic for determining transport type

00:33:51,380 --> 00:33:59,070
without having to specify it manually I

00:33:56,840 --> 00:34:01,049
think that could get complicated really

00:33:59,070 --> 00:34:05,369
quick

00:34:01,049 --> 00:34:10,159
you might be able to do something simple

00:34:05,369 --> 00:34:12,179
with a frequency and size of message but

00:34:10,159 --> 00:34:16,379
that breaks down because you don't

00:34:12,179 --> 00:34:18,629
actually have any metadata about what

00:34:16,379 --> 00:34:20,129
type of use case that you're running in

00:34:18,629 --> 00:34:23,190
if you're just doing a heuristic

00:34:20,129 --> 00:34:25,200
approach so say for teleoperation you

00:34:23,190 --> 00:34:27,929
care about low latency but not about

00:34:25,200 --> 00:34:29,609
reliability you need to somehow specify

00:34:27,929 --> 00:34:31,230
that metadata in order for something

00:34:29,609 --> 00:34:35,250
like a heuristic approach to you make a

00:34:31,230 --> 00:34:37,700
correct decision if that makes sense any

00:34:35,250 --> 00:34:37,700

YouTube URL: https://www.youtube.com/watch?v=Mr2AlP4ilDc


