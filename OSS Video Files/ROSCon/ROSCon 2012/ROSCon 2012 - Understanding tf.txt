Title: ROSCon 2012 - Understanding tf
Publication date: 2014-08-31
Playlist: ROSCon 2012
Description: 
	Tully Foote
Understanding tf

Slides: http://people.willowgarage.com/tfoote/presentations/ROSCON2012/roscon_tf.odp
Captions: 
	00:00:00,140 --> 00:00:05,790
well good morning again and welcome back

00:00:03,020 --> 00:00:09,480
so this is our second morning session

00:00:05,790 --> 00:00:11,330
we've got two longer in-depth talks this

00:00:09,480 --> 00:00:13,980
morning first we're going to talk about

00:00:11,330 --> 00:00:16,350
TF which is something that most of you

00:00:13,980 --> 00:00:18,750
if you're using Ross probably make use

00:00:16,350 --> 00:00:19,890
of pretty frequently and and we've got

00:00:18,750 --> 00:00:21,180
the author here to tell you about it and

00:00:19,890 --> 00:00:25,769
then after that we'll talk about multi

00:00:21,180 --> 00:00:28,890
robot systems so first it's my pleasure

00:00:25,769 --> 00:00:33,780
to introduce your ross platform manager

00:00:28,890 --> 00:00:37,430
totally foot who had wherewithal to name

00:00:33,780 --> 00:00:37,430
a very common package after himself

00:00:44,239 --> 00:00:48,719
thank you Brian but I have to actually

00:00:47,340 --> 00:00:51,180
give you the credit for that

00:00:48,719 --> 00:00:53,160
it was previously had a longer name and

00:00:51,180 --> 00:00:55,350
due to the naming conventions that you

00:00:53,160 --> 00:00:59,039
implemented we had to shorten it to just

00:00:55,350 --> 00:01:02,670
my initials so yeah I'm here to tell you

00:00:59,039 --> 00:01:05,549
about TF the transform library inside of

00:01:02,670 --> 00:01:06,810
Ross and I know there's a lot of

00:01:05,549 --> 00:01:09,299
different levels here so I'm trying to

00:01:06,810 --> 00:01:10,740
get a little bit for everybody which

00:01:09,299 --> 00:01:12,030
unfortunately means that there's gonna

00:01:10,740 --> 00:01:17,640
be a little bit of redundancy for

00:01:12,030 --> 00:01:21,420
everybody but like with it so motivation

00:01:17,640 --> 00:01:25,259
for TF many of you have seen the DARPA

00:01:21,420 --> 00:01:27,000
urban challenge as an urban challenge I

00:01:25,259 --> 00:01:30,600
was lucky enough to be involved in all

00:01:27,000 --> 00:01:34,170
three of those and there were challenges

00:01:30,600 --> 00:01:37,650
in the challenge this is Alice from Team

00:01:34,170 --> 00:01:43,829
Caltech we had by far the most exciting

00:01:37,650 --> 00:01:46,530
finish of the race if you talk to me

00:01:43,829 --> 00:01:49,770
later I can show you the robots eye view

00:01:46,530 --> 00:01:55,790
of the ending as we go into the press

00:01:49,770 --> 00:01:58,350
box so as I was working on all of these

00:01:55,790 --> 00:02:00,840
vehicles one of the things that kept

00:01:58,350 --> 00:02:03,060
coming up was how do we deal with sensor

00:02:00,840 --> 00:02:05,399
data how do we fuse it how do we keep

00:02:03,060 --> 00:02:07,619
track of it and one of the big things

00:02:05,399 --> 00:02:12,239
was like what happens when the GPS jumps

00:02:07,619 --> 00:02:13,740
you know GPS is not that good it updates

00:02:12,239 --> 00:02:17,130
occasionally

00:02:13,740 --> 00:02:19,020
and all of a sudden you're like I've

00:02:17,130 --> 00:02:20,790
collected all this data I put it in the

00:02:19,020 --> 00:02:22,200
map and now I think I'm ten meters from

00:02:20,790 --> 00:02:24,270
where I was and I know the data that I

00:02:22,200 --> 00:02:26,610
collected a second ago is no longer

00:02:24,270 --> 00:02:27,750
valid and so you started thinking about

00:02:26,610 --> 00:02:30,630
well I need to keep track of more

00:02:27,750 --> 00:02:31,980
coordinate frames and as I continued on

00:02:30,630 --> 00:02:35,100
to the University of Pennsylvania team

00:02:31,980 --> 00:02:36,330
my responsibilities became doing a lot

00:02:35,100 --> 00:02:39,060
of the sensor collection and sensor

00:02:36,330 --> 00:02:41,250
fusion and I kept banging my head

00:02:39,060 --> 00:02:43,050
against this problem of keeping track of

00:02:41,250 --> 00:02:48,540
all these coordinate frames again each

00:02:43,050 --> 00:02:52,830
project so I didn't want to do it again

00:02:48,540 --> 00:02:54,510
and I decided the best thing to do was

00:02:52,830 --> 00:02:58,470
write a library so I never have to do it

00:02:54,510 --> 00:03:00,360
again maybe not the best logic but it

00:02:58,470 --> 00:03:02,220
also means that many of you don't ever

00:03:00,360 --> 00:03:08,120
have to do this again so there's a

00:03:02,220 --> 00:03:10,110
benefit there's also other significant

00:03:08,120 --> 00:03:14,990
motivation for this was to be able to

00:03:10,110 --> 00:03:17,370
save processing and data transport costs

00:03:14,990 --> 00:03:20,250
one of the primary motivations of TF

00:03:17,370 --> 00:03:23,010
we're actually put the stamp on every

00:03:20,250 --> 00:03:27,330
piece of data and then the data gets

00:03:23,010 --> 00:03:29,130
transferred directly to the process that

00:03:27,330 --> 00:03:31,080
wants to use it and they can mutate it

00:03:29,130 --> 00:03:32,730
the way they want you don't have to

00:03:31,080 --> 00:03:35,900
guess what the next person in the

00:03:32,730 --> 00:03:38,730
pipeline will want your data formatted

00:03:35,900 --> 00:03:40,020
and this also has great properties for

00:03:38,730 --> 00:03:42,000
preserving your data if you're logging

00:03:40,020 --> 00:03:44,100
you get the original data in its

00:03:42,000 --> 00:03:45,690
original form and you don't have to

00:03:44,100 --> 00:03:50,250
worry about rounding and other things

00:03:45,690 --> 00:03:52,980
when we run multiple operations on it so

00:03:50,250 --> 00:03:54,570
what is yeah TF is just a library that

00:03:52,980 --> 00:03:57,750
keeps track of coordinate frames for you

00:03:54,570 --> 00:03:59,550
and has nice methods to help you get

00:03:57,750 --> 00:04:02,330
from transfer data from one coordinate

00:03:59,550 --> 00:04:02,330
frame to another

00:04:06,040 --> 00:04:11,990
so the primary waste interaction CF are

00:04:09,290 --> 00:04:14,330
through using a publisher and a listener

00:04:11,990 --> 00:04:16,820
the publisher is just a helper class

00:04:14,330 --> 00:04:18,640
that will allow you to if you are

00:04:16,820 --> 00:04:22,490
something that knows about the

00:04:18,640 --> 00:04:23,810
coordinate frame say the motor joint the

00:04:22,490 --> 00:04:26,000
motor controller that's controlling the

00:04:23,810 --> 00:04:28,400
joint of the elbow all you have to do is

00:04:26,000 --> 00:04:31,790
publish that from the upper arm to the

00:04:28,400 --> 00:04:33,500
lower arm the angle is this and it

00:04:31,790 --> 00:04:35,720
computes the transform and then the

00:04:33,500 --> 00:04:40,490
library will take that in just as an

00:04:35,720 --> 00:04:42,560
discrete element and the other side of

00:04:40,490 --> 00:04:45,560
it is the more complicated side where

00:04:42,560 --> 00:04:47,750
you listen to all these discrete updates

00:04:45,560 --> 00:04:53,210
from each different joint and then you

00:04:47,750 --> 00:04:55,400
build a large tree of how you build a

00:04:53,210 --> 00:04:57,050
large tree representation of what all

00:04:55,400 --> 00:05:04,100
the corner frames are in the robot and

00:04:57,050 --> 00:05:06,080
then you can query over it so as we were

00:05:04,100 --> 00:05:08,510
designing Ross one of the critical

00:05:06,080 --> 00:05:09,919
things we looked at was that Ross is

00:05:08,510 --> 00:05:13,850
gonna be running on a distributed system

00:05:09,919 --> 00:05:16,040
and TF was designed precisely to be also

00:05:13,850 --> 00:05:18,560
distributed there's no central part of

00:05:16,040 --> 00:05:19,910
raw TF where there's a central server

00:05:18,560 --> 00:05:22,430
and everything and knows about

00:05:19,910 --> 00:05:24,740
everything each node is in charge of

00:05:22,430 --> 00:05:26,510
listening for everything on the system

00:05:24,740 --> 00:05:31,840
aggregating it and then providing access

00:05:26,510 --> 00:05:35,090
to it directly from when you query it

00:05:31,840 --> 00:05:37,430
this is one of the most common failures

00:05:35,090 --> 00:05:39,710
of people who are trying to learn TF is

00:05:37,430 --> 00:05:41,600
they bring it up and they ask it for

00:05:39,710 --> 00:05:44,840
something that happened before it got

00:05:41,600 --> 00:05:46,730
started and it doesn't have data because

00:05:44,840 --> 00:05:48,800
there's no you haven't been listening

00:05:46,730 --> 00:05:50,780
for data a second ago before you created

00:05:48,800 --> 00:05:52,610
your listener so if any of you are

00:05:50,780 --> 00:05:55,190
having trouble with this make sure to

00:05:52,610 --> 00:05:58,270
bring your listener up and keep it up so

00:05:55,190 --> 00:05:58,270
it can build this buffer of data

00:06:01,990 --> 00:06:06,100
so I mentioned briefly to the tree

00:06:03,699 --> 00:06:08,530
structure of TF and I want to talk to

00:06:06,100 --> 00:06:12,729
you about the data representation

00:06:08,530 --> 00:06:14,050
underneath so you've got your basic tree

00:06:12,729 --> 00:06:16,979
structure you've got your world

00:06:14,050 --> 00:06:21,460
you've got turtle 1 and turtle 2 here

00:06:16,979 --> 00:06:25,389
and every publisher is publishing joint

00:06:21,460 --> 00:06:26,770
trance the transforms over time on the

00:06:25,389 --> 00:06:28,720
pr2 we're publishing it like four

00:06:26,770 --> 00:06:30,400
hundred Hertz depending on your

00:06:28,720 --> 00:06:32,020
application you can choose to publish at

00:06:30,400 --> 00:06:34,449
a higher lower rate depending on what

00:06:32,020 --> 00:06:38,530
fidelity and update rate you want to be

00:06:34,449 --> 00:06:40,419
able to query the system at and in the

00:06:38,530 --> 00:06:42,400
listener we have these links that we've

00:06:40,419 --> 00:06:46,120
built up and you can see that we're

00:06:42,400 --> 00:06:48,759
collecting this ones a hundredth of a

00:06:46,120 --> 00:06:51,759
second old it's got five seconds of data

00:06:48,759 --> 00:06:55,659
and the average rate is 50 Hertz and

00:06:51,759 --> 00:06:58,389
this is stored in a linked list and each

00:06:55,659 --> 00:07:00,520
different part of link of the tree has a

00:06:58,389 --> 00:07:02,289
linked list as the data structure behind

00:07:00,520 --> 00:07:05,080
it so when you query it we're actually

00:07:02,289 --> 00:07:07,270
traversing the linked list by default we

00:07:05,080 --> 00:07:08,680
store 10 seconds of data that's just a

00:07:07,270 --> 00:07:12,699
parameter you can set in the constructor

00:07:08,680 --> 00:07:14,229
of your listener and the other

00:07:12,699 --> 00:07:15,789
interesting thing about TF is that it

00:07:14,229 --> 00:07:17,349
will work with multiple disconnected

00:07:15,789 --> 00:07:19,120
trees so if you actually have two robots

00:07:17,349 --> 00:07:20,979
and they don't know how they don't know

00:07:19,120 --> 00:07:22,780
the transform between them you can ask

00:07:20,979 --> 00:07:24,909
for the transform from the left hand to

00:07:22,780 --> 00:07:26,169
the right hand of robot one you can ask

00:07:24,909 --> 00:07:28,389
for the transform the left hand of the

00:07:26,169 --> 00:07:30,580
right hand of robot 2 if you ask for the

00:07:28,389 --> 00:07:33,430
left hand or the robot one to the right

00:07:30,580 --> 00:07:36,880
hand of robot 2 it will error and say

00:07:33,430 --> 00:07:38,500
those are not connected but if at some

00:07:36,880 --> 00:07:40,240
later time somebody starts publishing

00:07:38,500 --> 00:07:42,460
the transform between robot 1 and robot

00:07:40,240 --> 00:07:49,990
to the next query that you make it'll

00:07:42,460 --> 00:07:52,870
work so the core of TF is the lookup

00:07:49,990 --> 00:07:54,789
transform method I've got an example

00:07:52,870 --> 00:07:57,520
tree here with two very simple robots

00:07:54,789 --> 00:08:00,520
and we're gonna walk through how to

00:07:57,520 --> 00:08:03,430
transform from the coordinate frame of

00:08:00,520 --> 00:08:05,860
robot one laser to the coordinate frame

00:08:03,430 --> 00:08:08,259
of robot two's base this would be a

00:08:05,860 --> 00:08:11,199
common thing say robot 2 is trying to do

00:08:08,259 --> 00:08:13,419
navigation and it's receiving the sensor

00:08:11,199 --> 00:08:14,650
data from robot 1 it wants to be able to

00:08:13,419 --> 00:08:15,550
know where it is in relation to its base

00:08:14,650 --> 00:08:20,560
so that it can do so

00:08:15,550 --> 00:08:22,510
something like drive and not hit it so

00:08:20,560 --> 00:08:23,470
these are the two note nodes on the tree

00:08:22,510 --> 00:08:26,860
that we're gonna try and traverse

00:08:23,470 --> 00:08:28,660
between and traversing TF tree is

00:08:26,860 --> 00:08:32,050
actually relatively simple you simply

00:08:28,660 --> 00:08:33,910
walk up it compute the transform one

00:08:32,050 --> 00:08:36,070
between the laser and the base for robot

00:08:33,910 --> 00:08:38,470
one compute the transform between the

00:08:36,070 --> 00:08:41,380
base and a dhama tree frame then you

00:08:38,470 --> 00:08:43,750
compute the transform between the OM of

00:08:41,380 --> 00:08:45,610
the map frame and then you go to the

00:08:43,750 --> 00:08:47,320
other side since we've hit the top and

00:08:45,610 --> 00:08:50,710
we compute the transform between robot -

00:08:47,320 --> 00:08:52,840
so I'm framing the map and it turns out

00:08:50,710 --> 00:08:55,870
that's just a little bit of linear

00:08:52,840 --> 00:08:58,500
algebra all of a sudden you have the

00:08:55,870 --> 00:09:00,790
transfer between these two things

00:08:58,500 --> 00:09:03,610
there's some efficiencies under the hood

00:09:00,790 --> 00:09:04,810
we do the traversal of the tree first

00:09:03,610 --> 00:09:07,240
and then the computation of the

00:09:04,810 --> 00:09:10,710
transform later slightly quicker but you

00:09:07,240 --> 00:09:10,710
don't actually need to worry about that

00:09:11,400 --> 00:09:17,350
so each one of those links that I showed

00:09:15,490 --> 00:09:20,470
you walking through it's actually a

00:09:17,350 --> 00:09:22,270
buffer of data and depending on what

00:09:20,470 --> 00:09:25,560
date has been published you may or may

00:09:22,270 --> 00:09:29,200
not have current data on every link so

00:09:25,560 --> 00:09:31,870
here's four different cases in the top

00:09:29,200 --> 00:09:36,190
left that is the great one you've got

00:09:31,870 --> 00:09:38,380
all your frames up to date but in the

00:09:36,190 --> 00:09:40,390
top right if you look here say we

00:09:38,380 --> 00:09:42,700
haven't received this data quite at the

00:09:40,390 --> 00:09:44,290
time we're querying for it's gonna fail

00:09:42,700 --> 00:09:46,570
and you're gonna get that's going to say

00:09:44,290 --> 00:09:49,060
there's an extrapolation error into the

00:09:46,570 --> 00:09:52,060
future because the data is not quite up

00:09:49,060 --> 00:09:56,320
to where you're at you can also get

00:09:52,060 --> 00:09:58,330
failures where different more common is

00:09:56,320 --> 00:09:59,920
you have this more moving wavefront

00:09:58,330 --> 00:10:01,180
where different data has come in from

00:09:59,920 --> 00:10:03,220
different nodes at different times

00:10:01,180 --> 00:10:06,150
because they're slightly farther away on

00:10:03,220 --> 00:10:09,580
the network that are over the wireless

00:10:06,150 --> 00:10:11,320
again that's gonna fail and you can also

00:10:09,580 --> 00:10:12,820
get things where if you query it before

00:10:11,320 --> 00:10:17,520
the transforms that have been published

00:10:12,820 --> 00:10:24,190
for that time stamp it will also fail

00:10:17,520 --> 00:10:26,020
and here is one of the really a lot of

00:10:24,190 --> 00:10:29,110
people make this mistake which is that

00:10:26,020 --> 00:10:30,730
if you ask for x 0 to

00:10:29,110 --> 00:10:33,279
we'll say okay that means you want the

00:10:30,730 --> 00:10:35,550
latest common time and the way you

00:10:33,279 --> 00:10:37,930
compute the latest common time is you

00:10:35,550 --> 00:10:40,420
look at the front wavefront of all these

00:10:37,930 --> 00:10:42,910
things and then you take the minimum of

00:10:40,420 --> 00:10:45,430
it and you query at this point however

00:10:42,910 --> 00:10:47,970
if you're querying at that point there's

00:10:45,430 --> 00:10:51,490
no common time and it will error saying

00:10:47,970 --> 00:10:53,410
saying so so even if you ask for the

00:10:51,490 --> 00:10:55,450
latest value and you have transforms

00:10:53,410 --> 00:10:57,910
over all your data type or all your

00:10:55,450 --> 00:11:05,700
different elements in the tree you still

00:10:57,910 --> 00:11:08,019
may get an error so inside of the cache

00:11:05,700 --> 00:11:11,829
I've mentioned that their store is a

00:11:08,019 --> 00:11:13,390
linked list we look up at the when we're

00:11:11,829 --> 00:11:15,490
looking up inside of linked list we find

00:11:13,390 --> 00:11:19,660
the two closest points and when then we

00:11:15,490 --> 00:11:22,300
do linear interpolation between them we

00:11:19,660 --> 00:11:24,430
use spherical linear interpolation for

00:11:22,300 --> 00:11:27,180
the quaternions and we just use regular

00:11:24,430 --> 00:11:31,390
linear interpolation for the

00:11:27,180 --> 00:11:33,190
translations element so if you have

00:11:31,390 --> 00:11:34,949
anything between time ten and ten and

00:11:33,190 --> 00:11:39,519
eleven it's straightforward

00:11:34,949 --> 00:11:42,250
interpolation and CF does have this

00:11:39,519 --> 00:11:43,930
thing called extrapolation it will allow

00:11:42,250 --> 00:11:47,050
you to go beyond the closest two data

00:11:43,930 --> 00:11:48,790
points I added this in when I first

00:11:47,050 --> 00:11:50,410
wrote the library it's a really trivial

00:11:48,790 --> 00:11:51,880
feature just to let the linear

00:11:50,410 --> 00:11:55,690
interpolation go beyond the ends if you

00:11:51,880 --> 00:11:57,610
have two points I have the there is a

00:11:55,690 --> 00:11:59,980
method in there to turn it on and I

00:11:57,610 --> 00:12:05,110
highly recommend that nobody turned it

00:11:59,980 --> 00:12:06,490
on it turns out that especially if you

00:12:05,110 --> 00:12:08,620
have a high update rate when you have a

00:12:06,490 --> 00:12:10,899
small Rangeley interpolating over if you

00:12:08,620 --> 00:12:14,860
start extrapolating by anything it

00:12:10,899 --> 00:12:19,000
basically will amplify your noise it is

00:12:14,860 --> 00:12:20,649
great in the abstract but I have not yet

00:12:19,000 --> 00:12:22,690
found a case where it has significantly

00:12:20,649 --> 00:12:26,940
improved performance and it usually

00:12:22,690 --> 00:12:29,829
causes significantly impossible to debug

00:12:26,940 --> 00:12:31,480
problems in your system because all the

00:12:29,829 --> 00:12:33,610
data is valid but you've amplified the

00:12:31,480 --> 00:12:37,620
noise and then you're making a decisions

00:12:33,610 --> 00:12:37,620
based on the noise it just doesn't work

00:12:40,690 --> 00:12:46,820
these are some of the values that I feel

00:12:42,890 --> 00:12:48,830
the TF provides to the community as I

00:12:46,820 --> 00:12:50,330
mentioned earlier you save computational

00:12:48,830 --> 00:12:54,260
cost you don't have to transform things

00:12:50,330 --> 00:12:59,990
multiple times this also this saves both

00:12:54,260 --> 00:13:01,190
in accuracy and just CPU cost and the

00:12:59,990 --> 00:13:02,720
user doesn't actually have to worry

00:13:01,190 --> 00:13:04,250
about what frame that the data was

00:13:02,720 --> 00:13:06,890
collected in they can say I want it in

00:13:04,250 --> 00:13:08,840
this coordinate frame it the data is

00:13:06,890 --> 00:13:10,670
stamped there should be data in the TF

00:13:08,840 --> 00:13:16,310
tree give it to me in the frame that I

00:13:10,670 --> 00:13:17,960
want and I'll ignore the rest and the

00:13:16,310 --> 00:13:20,180
best thing is that means that most users

00:13:17,960 --> 00:13:23,870
don't have to know anything about 3d

00:13:20,180 --> 00:13:27,280
coordinate transforms because I know way

00:13:23,870 --> 00:13:27,280
more than any of you ever want to know

00:13:28,780 --> 00:13:32,300
and the other important thing is that as

00:13:31,130 --> 00:13:35,090
we're running on a distributed system

00:13:32,300 --> 00:13:37,460
and there's significant latency all of

00:13:35,090 --> 00:13:41,390
the you can deal with data that comes in

00:13:37,460 --> 00:13:42,830
a little bit from a little bit ago if it

00:13:41,390 --> 00:13:45,080
goes over the wireless network it gets

00:13:42,830 --> 00:13:49,910
buffered it gets resent the data comes

00:13:45,080 --> 00:13:52,460
in it is not the current data and the on

00:13:49,910 --> 00:13:54,770
the other side you can deal with if the

00:13:52,460 --> 00:14:05,300
TF transformations get delayed we have

00:13:54,770 --> 00:14:07,820
methods to help with that so inside of

00:14:05,300 --> 00:14:09,500
TF the core functionality is the lookup

00:14:07,820 --> 00:14:11,960
transform and can't transform

00:14:09,500 --> 00:14:13,520
I went over lookup transform which will

00:14:11,960 --> 00:14:15,230
do the tree traversal and compute the

00:14:13,520 --> 00:14:18,230
transform between two coordinate frames

00:14:15,230 --> 00:14:19,910
can transform will do the same tree

00:14:18,230 --> 00:14:22,430
traversal but it won't even bother

00:14:19,910 --> 00:14:23,960
computing the what the actual transform

00:14:22,430 --> 00:14:25,430
is it'll just return you to or false

00:14:23,960 --> 00:14:28,070
whether or not it can be transformed

00:14:25,430 --> 00:14:30,770
it's much faster and if you need to be

00:14:28,070 --> 00:14:35,510
pulling it at a high rate you should use

00:14:30,770 --> 00:14:36,500
can transform but most of us don't

00:14:35,510 --> 00:14:39,890
actually want to be dealing with

00:14:36,500 --> 00:14:42,980
transforms so you can actually just ask

00:14:39,890 --> 00:14:45,530
TF to transform your data for you we

00:14:42,980 --> 00:14:49,760
have many different data types all this

00:14:45,530 --> 00:14:51,620
common geometric primitives and things

00:14:49,760 --> 00:14:53,060
like point clouds so you can just simply

00:14:51,620 --> 00:14:55,040
ask for your

00:14:53,060 --> 00:14:59,840
in whatever coordinate frame you want at

00:14:55,040 --> 00:15:01,580
the time you want so as I mentioned we

00:14:59,840 --> 00:15:05,720
had a lot of issues dealing with latency

00:15:01,580 --> 00:15:08,570
in a distributed system the cache allows

00:15:05,720 --> 00:15:11,720
you to do that but if the TF data

00:15:08,570 --> 00:15:13,430
arrives after the primary data what do

00:15:11,720 --> 00:15:14,930
you do and this is the case when you

00:15:13,430 --> 00:15:17,090
have a laser scanner and you have

00:15:14,930 --> 00:15:19,670
somebody that's computing the all the

00:15:17,090 --> 00:15:21,290
joints and the transforms to get from

00:15:19,670 --> 00:15:24,380
your laser scanner to say your base

00:15:21,290 --> 00:15:27,290
coordinate frame and if the computation

00:15:24,380 --> 00:15:30,170
of that's that joint information takes

00:15:27,290 --> 00:15:33,260
longer or is delayed on the network you

00:15:30,170 --> 00:15:34,820
have to be able to deal with that so

00:15:33,260 --> 00:15:37,250
there's two basic ways to deal with this

00:15:34,820 --> 00:15:39,740
you can either use wait for transform

00:15:37,250 --> 00:15:41,510
which is your very simple way you sit

00:15:39,740 --> 00:15:43,970
there and you say can I transform can I

00:15:41,510 --> 00:15:45,760
transform can I transform that's all

00:15:43,970 --> 00:15:48,710
wait wait for transform does for you but

00:15:45,760 --> 00:15:54,020
the much cleaner way to do it is to use

00:15:48,710 --> 00:15:56,270
the TF message filter and I'm gonna go

00:15:54,020 --> 00:16:00,980
into dangers of wait for transform in

00:15:56,270 --> 00:16:02,240
general it's only good for scripting if

00:16:00,980 --> 00:16:04,310
you're sitting here and you have a

00:16:02,240 --> 00:16:06,830
dedicated script that's gonna do one

00:16:04,310 --> 00:16:08,570
thing and return when it's done if

00:16:06,830 --> 00:16:10,130
you're doing any asynchronous processing

00:16:08,570 --> 00:16:12,590
you can actually delay your entire

00:16:10,130 --> 00:16:14,270
system cause all downstream processes to

00:16:12,590 --> 00:16:19,450
be delayed due to the latency of your

00:16:14,270 --> 00:16:19,450
incoming TF information on the network

00:16:19,780 --> 00:16:26,300
and so the message filter is much much

00:16:24,530 --> 00:16:29,240
cleaner the way the message filter works

00:16:26,300 --> 00:16:32,060
is that when you subscribe to a piece of

00:16:29,240 --> 00:16:34,250
a topic it actually subscribes for you

00:16:32,060 --> 00:16:36,860
it will put it into a buffer and every

00:16:34,250 --> 00:16:38,600
time new TF data is called it will check

00:16:36,860 --> 00:16:41,210
all the messages that are queued for you

00:16:38,600 --> 00:16:43,220
and hand give you a call back just like

00:16:41,210 --> 00:16:46,460
you subscribe to it but only when the

00:16:43,220 --> 00:16:48,670
transform is available so you can keep

00:16:46,460 --> 00:16:51,230
your asynchronous processing paradigm

00:16:48,670 --> 00:16:54,260
but when you get your call back for your

00:16:51,230 --> 00:16:57,620
data you know that it has well it tested

00:16:54,260 --> 00:16:59,720
true that it has a transform available

00:16:57,620 --> 00:17:02,480
to the coordinate frame that you asked

00:16:59,720 --> 00:17:04,970
for however don't make the mistake that

00:17:02,480 --> 00:17:06,290
that means that if you call transform on

00:17:04,970 --> 00:17:08,420
that object it

00:17:06,290 --> 00:17:09,950
we'll work depending on how long your

00:17:08,420 --> 00:17:11,900
callback goes there may have been

00:17:09,950 --> 00:17:15,290
updates to the TF tree that broke your

00:17:11,900 --> 00:17:17,270
transform so you still need to do the

00:17:15,290 --> 00:17:24,500
exception handling and all those things

00:17:17,270 --> 00:17:26,810
that you should do to keep it robust so

00:17:24,500 --> 00:17:30,680
we got advanced topics we're going to

00:17:26,810 --> 00:17:34,100
chime travel it's also known as the

00:17:30,680 --> 00:17:36,470
advanced API but what I was thinking

00:17:34,100 --> 00:17:39,410
about it it's actually transforming data

00:17:36,470 --> 00:17:41,090
at time it's a really tough concept so

00:17:39,410 --> 00:17:44,870
time travels what we called it under

00:17:41,090 --> 00:17:47,660
development so this is a very simple

00:17:44,870 --> 00:17:49,820
example the turtle boss driving along it

00:17:47,660 --> 00:17:52,340
sees an apple on the ground and it keeps

00:17:49,820 --> 00:17:54,520
driving and now you say well I want to

00:17:52,340 --> 00:17:57,230
drive a path around all known obstacles

00:17:54,520 --> 00:17:58,850
most of us that's really simple you just

00:17:57,230 --> 00:18:00,350
say well I saw the Apple at this time

00:17:58,850 --> 00:18:03,850
and the map placed it in the map and

00:18:00,350 --> 00:18:06,830
then I kept driving and this works great

00:18:03,850 --> 00:18:09,440
but now say I saw the Apple and it fell

00:18:06,830 --> 00:18:12,110
on top of the turtle bottom if you asked

00:18:09,440 --> 00:18:16,250
where the Apple is now it's still on top

00:18:12,110 --> 00:18:18,530
of the turtle bottom but how do we how

00:18:16,250 --> 00:18:21,320
do we actually conceptually deal with

00:18:18,530 --> 00:18:25,580
that in when we're keeping track of this

00:18:21,320 --> 00:18:27,650
Apple and so the trick is that you have

00:18:25,580 --> 00:18:30,050
to know semantically where your data

00:18:27,650 --> 00:18:33,170
where you believe your data is fixed in

00:18:30,050 --> 00:18:35,000
time so what we're going to do is we're

00:18:33,170 --> 00:18:37,760
going to construct the transform from

00:18:35,000 --> 00:18:40,970
the observed obstacle to the fixed frame

00:18:37,760 --> 00:18:44,540
at the time the obstacle with the object

00:18:40,970 --> 00:18:47,120
was observed then we're going to jump

00:18:44,540 --> 00:18:49,910
keep preserve the data in the fixed

00:18:47,120 --> 00:18:51,740
frame and following that we will compute

00:18:49,910 --> 00:18:53,600
the transform from the fixed frame to

00:18:51,740 --> 00:18:59,480
the frame that you want to know where

00:18:53,600 --> 00:19:04,010
the Apple is know where the Apple was so

00:18:59,480 --> 00:19:06,680
here's a bit of a rendering basically

00:19:04,010 --> 00:19:08,780
you see the Apple in the turtlebot frame

00:19:06,680 --> 00:19:10,730
you know the transform for the world at

00:19:08,780 --> 00:19:15,830
time 0 you want to know where the Apple

00:19:10,730 --> 00:19:19,370
is in the turtlebot frame at time 5 so

00:19:15,830 --> 00:19:20,060
if you look at this if the if you're

00:19:19,370 --> 00:19:22,550
doing the

00:19:20,060 --> 00:19:24,860
transform and them Apple isn't fixed in

00:19:22,550 --> 00:19:28,040
the map frame you simply take the

00:19:24,860 --> 00:19:30,680
product of the t0 and inverse product of

00:19:28,040 --> 00:19:34,370
t5 and you're there but if the Apple is

00:19:30,680 --> 00:19:37,880
sitting on top of the turtlebot it's

00:19:34,370 --> 00:19:39,140
here so we transform the Apple into the

00:19:37,880 --> 00:19:42,410
turtlebot frame because that's our fixed

00:19:39,140 --> 00:19:44,300
frame it stays there and then you ask

00:19:42,410 --> 00:19:45,680
for the transform back to the turtlebot

00:19:44,300 --> 00:19:48,170
frame which again is the identity

00:19:45,680 --> 00:19:49,490
transform and you find out that the

00:19:48,170 --> 00:19:52,850
Apple is just sitting on top of the

00:19:49,490 --> 00:19:54,650
turtlebot where you just saw and the

00:19:52,850 --> 00:19:57,320
critical part is figuring out where your

00:19:54,650 --> 00:19:58,910
data is in this fix what the semantic

00:19:57,320 --> 00:20:01,820
information of your data is that implies

00:19:58,910 --> 00:20:08,630
what the fixed frame is in general it's

00:20:01,820 --> 00:20:10,160
where it's located so to give you a

00:20:08,630 --> 00:20:13,790
summary of a couple of our command line

00:20:10,160 --> 00:20:15,620
tools I don't so many of you may not be

00:20:13,790 --> 00:20:17,630
familiar with these but I'm sure some of

00:20:15,620 --> 00:20:19,640
you are TF echo command my two little

00:20:17,630 --> 00:20:20,990
just simply print out what the transform

00:20:19,640 --> 00:20:24,830
is between two coordinate frames that

00:20:20,990 --> 00:20:27,440
you asked for as it's coming in the

00:20:24,830 --> 00:20:29,720
latest time TF monitor if you're having

00:20:27,440 --> 00:20:31,970
trouble with latency and connectivity in

00:20:29,720 --> 00:20:34,900
your transform tree TF monitor is a

00:20:31,970 --> 00:20:37,340
great tool it'll let you understand what

00:20:34,900 --> 00:20:39,620
publishers are publishing what TF

00:20:37,340 --> 00:20:42,350
transforms and what the latency is on

00:20:39,620 --> 00:20:44,570
receiving those in your monitor which

00:20:42,350 --> 00:20:49,070
hopefully is a proxy for your other

00:20:44,570 --> 00:20:52,280
processes and ross WTF great tool that

00:20:49,070 --> 00:20:56,180
Ken mentioned earlier it has a TF plugin

00:20:52,280 --> 00:20:57,830
it will tell you things like this

00:20:56,180 --> 00:21:00,920
transform is being published with two

00:20:57,830 --> 00:21:02,570
parents very fast which suggests that

00:21:00,920 --> 00:21:04,310
two people think they're the authority

00:21:02,570 --> 00:21:05,360
on this there are two nodes think

00:21:04,310 --> 00:21:07,820
they're the authority on this and

00:21:05,360 --> 00:21:09,290
they're fighting when two nodes are

00:21:07,820 --> 00:21:11,540
publishing the same transform with

00:21:09,290 --> 00:21:13,040
different data it's really really bad

00:21:11,540 --> 00:21:15,080
because they will usually enter leave

00:21:13,040 --> 00:21:16,940
and then TF will do the nice

00:21:15,080 --> 00:21:19,460
interpolation for you assuming that it's

00:21:16,940 --> 00:21:21,380
a continuous variable so if you have two

00:21:19,460 --> 00:21:23,150
different transforms that are being

00:21:21,380 --> 00:21:24,800
alternately published you will be

00:21:23,150 --> 00:21:27,320
somewhere in the middle randomly

00:21:24,800 --> 00:21:30,020
depending on what your time how your

00:21:27,320 --> 00:21:33,240
query lines up with the two different

00:21:30,020 --> 00:21:34,500
inner leaf data flows

00:21:33,240 --> 00:21:37,200
so that's definitely something to watch

00:21:34,500 --> 00:21:39,809
for if you're having issues I highly

00:21:37,200 --> 00:21:42,000
recommend Arras WTF and any of you that

00:21:39,809 --> 00:21:43,260
are out there working on things that you

00:21:42,000 --> 00:21:45,480
can see something that can easily be

00:21:43,260 --> 00:21:50,760
detected on a Python script I suggest

00:21:45,480 --> 00:21:53,159
making a Ross WTF plugin and also if

00:21:50,760 --> 00:21:54,419
you're actually publishing transform so

00:21:53,159 --> 00:21:56,760
trying to figure out how things are

00:21:54,419 --> 00:21:59,070
looking in your world there's great

00:21:56,760 --> 00:22:02,940
tools are vyas as a TF visualization

00:21:59,070 --> 00:22:04,470
plug-in it becomes a mess but you can

00:22:02,940 --> 00:22:07,470
turn things off so you can actually see

00:22:04,470 --> 00:22:08,850
just the individual links and also a few

00:22:07,470 --> 00:22:11,760
frames which I showed you this tree

00:22:08,850 --> 00:22:13,860
structure earlier it has great

00:22:11,760 --> 00:22:15,990
information about the currency and the

00:22:13,860 --> 00:22:19,649
buffer information so you can actually

00:22:15,990 --> 00:22:21,000
look visually check what the different

00:22:19,649 --> 00:22:24,270
currencies are of your different

00:22:21,000 --> 00:22:26,429
transforms and in particular if somebody

00:22:24,270 --> 00:22:27,600
has stopped publishing a transform you

00:22:26,429 --> 00:22:29,130
can watch it go out of date really

00:22:27,600 --> 00:22:35,070
quickly and know hey I got to go check

00:22:29,130 --> 00:22:37,880
out what that publisher so there's lots

00:22:35,070 --> 00:22:40,440
of coordinate frames in the robot and

00:22:37,880 --> 00:22:45,179
dealing with coordinate frames is one of

00:22:40,440 --> 00:22:48,929
the harder things to do with TF you can

00:22:45,179 --> 00:22:50,549
see the pr2 here it has many coordinate

00:22:48,929 --> 00:22:51,600
frames and one of the important things

00:22:50,549 --> 00:22:53,520
is that when you're talking about

00:22:51,600 --> 00:22:56,970
coordinate frames you need to be able to

00:22:53,520 --> 00:22:58,169
talk about coordinate frames both both

00:22:56,970 --> 00:23:01,470
parties have to be able to talk about

00:22:58,169 --> 00:23:02,880
coordinate frames with the same name we

00:23:01,470 --> 00:23:05,730
do a lot of this by convention at the

00:23:02,880 --> 00:23:07,380
moment and I highly recommend that as

00:23:05,730 --> 00:23:09,330
you're going out there and you're gonna

00:23:07,380 --> 00:23:11,549
start using start using TF on a new

00:23:09,330 --> 00:23:13,500
robot or something try to make sure that

00:23:11,549 --> 00:23:15,659
your coordinate frames are as closely

00:23:13,500 --> 00:23:19,470
named to the analogous ones and existing

00:23:15,659 --> 00:23:21,480
robots out there so that things will

00:23:19,470 --> 00:23:23,899
work more out of the box and you don't

00:23:21,480 --> 00:23:26,940
have to be Reaper ammeter izing every

00:23:23,899 --> 00:23:29,100
frame ID of course if you're writing a

00:23:26,940 --> 00:23:31,020
node that's gonna be generic you should

00:23:29,100 --> 00:23:33,360
probably parameterize the coordinate

00:23:31,020 --> 00:23:37,640
coordinate frames that it uses so that

00:23:33,360 --> 00:23:37,640
you can reuse it without recompiling

00:23:39,380 --> 00:23:46,740
there are some beginning standards for

00:23:43,200 --> 00:23:48,990
naming coordinate frames wrap 105 is for

00:23:46,740 --> 00:23:51,690
it frames our mobile robot platforms and

00:23:48,990 --> 00:23:55,260
rep 120 is coordinate frames for

00:23:51,690 --> 00:23:57,000
humanoids so if you're doing anything

00:23:55,260 --> 00:23:58,380
with mobile robot platforms or humanoids

00:23:57,000 --> 00:23:59,790
I strongly recommend you follow these

00:23:58,380 --> 00:24:02,040
reps and state that you follow these

00:23:59,790 --> 00:24:05,490
reps and the nice thing is things like

00:24:02,040 --> 00:24:11,750
the navigation stack will work if you

00:24:05,490 --> 00:24:14,490
follow these reps so a couple of tricks

00:24:11,750 --> 00:24:16,170
you can dynamically allocate or

00:24:14,490 --> 00:24:17,610
dynamically creates you have transforms

00:24:16,170 --> 00:24:20,010
just by publishing with a new coordinate

00:24:17,610 --> 00:24:21,420
frame this is really useful when you're

00:24:20,010 --> 00:24:23,970
doing object recognition and you're like

00:24:21,420 --> 00:24:26,220
hey I saw something on the table at this

00:24:23,970 --> 00:24:28,830
coordinate in the camera sensor let's

00:24:26,220 --> 00:24:30,330
just add it to the TF tree you can add

00:24:28,830 --> 00:24:32,820
anything you want to the TF tree it

00:24:30,330 --> 00:24:35,340
won't hurt it and if you stop publishing

00:24:32,820 --> 00:24:38,970
the the old cache data will be there but

00:24:35,340 --> 00:24:42,059
it won't affect your future lookups so

00:24:38,970 --> 00:24:43,800
be careful if you reuse the same frame

00:24:42,059 --> 00:24:45,870
ID for diamond dynamically changing

00:24:43,800 --> 00:24:48,000
things if I see a chair over there and

00:24:45,870 --> 00:24:49,170
ice name it chair one and then ten

00:24:48,000 --> 00:24:52,500
minutes later I see a chair over there

00:24:49,170 --> 00:24:54,360
and I name it change chair one if you

00:24:52,500 --> 00:24:55,800
query for the chair position anywhere in

00:24:54,360 --> 00:24:57,450
between you will get the linear

00:24:55,800 --> 00:24:58,920
interpolation between that side of the

00:24:57,450 --> 00:25:02,429
room and that side of the room they're

00:24:58,920 --> 00:25:04,710
actually different chairs and so that

00:25:02,429 --> 00:25:07,080
date is completely bogus but TF will

00:25:04,710 --> 00:25:10,890
return it to you because you you gave it

00:25:07,080 --> 00:25:13,730
the same frame in different places and

00:25:10,890 --> 00:25:16,050
the other thing is to think about

00:25:13,730 --> 00:25:19,410
semantically important coordinate frames

00:25:16,050 --> 00:25:21,330
so when you're the best example I'll

00:25:19,410 --> 00:25:24,690
have this is the differentiation between

00:25:21,330 --> 00:25:29,990
the map frame and the odom frame in the

00:25:24,690 --> 00:25:33,540
navigation example so going back to my

00:25:29,990 --> 00:25:35,070
grand challenge experience and the GPS

00:25:33,540 --> 00:25:36,870
jumps one of the big things you as

00:25:35,070 --> 00:25:38,820
you're driving along you have this

00:25:36,870 --> 00:25:41,070
global localization that says that

00:25:38,820 --> 00:25:42,870
you're within ten meters of this spot

00:25:41,070 --> 00:25:45,750
and that will have a best estimate and

00:25:42,870 --> 00:25:49,770
keeps jumping and so if you keep track

00:25:45,750 --> 00:25:51,750
of your data in the map frame when you

00:25:49,770 --> 00:25:54,510
get an update from the GPS all of a

00:25:51,750 --> 00:25:56,760
sudden you have the choice of do I try

00:25:54,510 --> 00:25:58,800
to keep track and recompute where all my

00:25:56,760 --> 00:26:00,450
data was because I got a update on my

00:25:58,800 --> 00:26:02,160
position or do

00:26:00,450 --> 00:26:06,750
just throw it out and start over because

00:26:02,160 --> 00:26:09,210
that's easier but if you know that the

00:26:06,750 --> 00:26:11,850
car is gonna be driving forward in a

00:26:09,210 --> 00:26:14,940
continuous manner and when you get a GPS

00:26:11,850 --> 00:26:17,070
update you know that the obstacle that

00:26:14,940 --> 00:26:20,190
you saw one meter in front of you it's

00:26:17,070 --> 00:26:21,270
still one meter in front of you even

00:26:20,190 --> 00:26:24,420
though your estimate of where you are in

00:26:21,270 --> 00:26:27,870
the world changed we can take advantage

00:26:24,420 --> 00:26:30,060
of that by keeping all of the persisting

00:26:27,870 --> 00:26:32,730
all the objects in the ODA metric frame

00:26:30,060 --> 00:26:35,190
and we know that the ODA metric frame

00:26:32,730 --> 00:26:36,840
will drift but we have this other

00:26:35,190 --> 00:26:40,440
coordinate frame which is the map frame

00:26:36,840 --> 00:26:43,020
and we can jump the transfer between the

00:26:40,440 --> 00:26:45,360
map frame and the auto metric frame such

00:26:43,020 --> 00:26:48,350
that if you ask for a specific position

00:26:45,360 --> 00:26:50,850
in the map you can drive to that point

00:26:48,350 --> 00:26:52,730
but the obstacles that you observed in

00:26:50,850 --> 00:26:55,410
the ODA metric frame will always be

00:26:52,730 --> 00:26:57,800
approximately where they are up to the

00:26:55,410 --> 00:27:00,770
level of the drifty of your odometry and

00:26:57,800 --> 00:27:04,260
this allows you to persist the obstacles

00:27:00,770 --> 00:27:06,300
in the otometrics frame the one caveat

00:27:04,260 --> 00:27:11,730
with this is that your auto metric frame

00:27:06,300 --> 00:27:12,840
does build up drift over time and so you

00:27:11,730 --> 00:27:16,440
need to make sure not to persist

00:27:12,840 --> 00:27:18,560
obstacles too long and usually in a

00:27:16,440 --> 00:27:21,840
navigating robot or something like that

00:27:18,560 --> 00:27:25,890
you drive out of the range of that

00:27:21,840 --> 00:27:27,900
you're persisting data before you drift

00:27:25,890 --> 00:27:29,790
too far to make it invalid there's a

00:27:27,900 --> 00:27:31,470
trade-off there but using the auto

00:27:29,790 --> 00:27:33,930
metrics frame is highly recommended and

00:27:31,470 --> 00:27:36,510
when you're doing other system design

00:27:33,930 --> 00:27:38,370
parts I think about the semantic meaning

00:27:36,510 --> 00:27:40,620
of where the data should be stored and

00:27:38,370 --> 00:27:45,360
how you want to update it when you get

00:27:40,620 --> 00:27:50,070
new information and the last thing is in

00:27:45,360 --> 00:27:53,130
general I recommend using the TF message

00:27:50,070 --> 00:27:56,760
filters and not wait for transform in

00:27:53,130 --> 00:27:58,410
any case almost every case it's a couple

00:27:56,760 --> 00:28:03,600
extra lines of code you have to register

00:27:58,410 --> 00:28:08,610
a callback but it'll save you debugging

00:28:03,600 --> 00:28:11,789
time down the road so

00:28:08,610 --> 00:28:14,549
TF is not perfect there are many

00:28:11,789 --> 00:28:18,120
challenges when using it transmission

00:28:14,549 --> 00:28:19,950
over Wi-Fi is a major problem on the pr2

00:28:18,120 --> 00:28:22,260
it can take up to half the Wi-Fi link

00:28:19,950 --> 00:28:24,679
and if you subscribe for multiple things

00:28:22,260 --> 00:28:27,960
on the other side of the Wi-Fi link

00:28:24,679 --> 00:28:29,309
there all of a sudden you can hog all

00:28:27,960 --> 00:28:32,010
your bandwidth just subscribing to TF

00:28:29,309 --> 00:28:34,620
there's a couple of scripts in the TF

00:28:32,010 --> 00:28:36,419
package which will actually subscribe to

00:28:34,620 --> 00:28:38,549
whole TF tree and periodically publish

00:28:36,419 --> 00:28:40,679
one cross section so that if you need a

00:28:38,549 --> 00:28:42,000
low bandwidth display say on the other

00:28:40,679 --> 00:28:44,580
side of a Wi-Fi link for a user

00:28:42,000 --> 00:28:48,029
interface you can do that over Wi-Fi

00:28:44,580 --> 00:28:50,460
with much lower bandwidth disambiguation

00:28:48,029 --> 00:28:53,130
of multiple frame frame IDs on

00:28:50,460 --> 00:28:56,460
homogeneous robots if I have to turtle

00:28:53,130 --> 00:28:58,470
BOTS they both believe that their camera

00:28:56,460 --> 00:29:00,929
isn't and their camera is in the camera

00:28:58,470 --> 00:29:03,510
frame and if you publish data and you

00:29:00,929 --> 00:29:05,639
stamp it with the camera frame all of a

00:29:03,510 --> 00:29:07,260
sudden you don't know which if you don't

00:29:05,639 --> 00:29:12,450
know which robot that camera data came

00:29:07,260 --> 00:29:15,419
from you're out of luck so you either

00:29:12,450 --> 00:29:19,289
have to remap all your parameters and

00:29:15,419 --> 00:29:21,299
we're working on that so another issue

00:29:19,289 --> 00:29:24,090
is that if you are only if you have a

00:29:21,299 --> 00:29:26,309
little script that's gonna say is the

00:29:24,090 --> 00:29:27,870
door open at this time at this location

00:29:26,309 --> 00:29:30,299
and it's gonna be queried like once a

00:29:27,870 --> 00:29:32,130
minute if you're subscribing to TF alt

00:29:30,299 --> 00:29:34,320
for that whole minute and then you just

00:29:32,130 --> 00:29:37,470
want to query one little thing it turns

00:29:34,320 --> 00:29:39,690
out that can take and non-trivial amount

00:29:37,470 --> 00:29:44,519
of CPU time just to keep the link list

00:29:39,690 --> 00:29:47,970
updated and in general the bandwidth of

00:29:44,519 --> 00:29:51,870
TF is a problem especially on the pr2

00:29:47,970 --> 00:29:53,460
where we have 32 degrees of freedom but

00:29:51,870 --> 00:29:55,380
we have something like a hundred

00:29:53,460 --> 00:29:56,490
coordinate frames because you know we

00:29:55,380 --> 00:29:58,049
keep track of all the different links

00:29:56,490 --> 00:29:59,549
the cameras each have one or two

00:29:58,049 --> 00:30:04,110
coordinate frames depending on if you're

00:29:59,549 --> 00:30:06,419
doing optical frame and point clouds and

00:30:04,110 --> 00:30:10,850
one other big complain about TF is that

00:30:06,419 --> 00:30:10,850
has a lot of heavyweight dependencies so

00:30:12,710 --> 00:30:20,159
goals for TF in the future I'd like to

00:30:16,320 --> 00:30:21,480
rework it to be a C++ library take

00:30:20,159 --> 00:30:22,500
advantage of templates to be able to

00:30:21,480 --> 00:30:24,810
break a lot of the depends

00:30:22,500 --> 00:30:27,420
so that you can TF the library does not

00:30:24,810 --> 00:30:29,250
have to have the dependencies but you

00:30:27,420 --> 00:30:33,090
can just depend on a header to add your

00:30:29,250 --> 00:30:35,910
support for your data type the Python

00:30:33,090 --> 00:30:37,590
library is there it works it has a

00:30:35,910 --> 00:30:40,440
couple of quirks because it's wrapping

00:30:37,590 --> 00:30:43,680
the high level C++ library and it turns

00:30:40,440 --> 00:30:46,590
out that wrapping raw cpp inside of raw

00:30:43,680 --> 00:30:47,670
spy there's a lot of things you have to

00:30:46,590 --> 00:30:51,870
jump a lot of hoops you have to jump

00:30:47,670 --> 00:30:53,760
through and also as I mentioned the

00:30:51,870 --> 00:30:55,260
bandwidth issue we can cut a lot of the

00:30:53,760 --> 00:30:56,790
data out of the bandwidth if we don't

00:30:55,260 --> 00:31:00,020
have to publish static transforms

00:30:56,790 --> 00:31:02,760
regularly as the current system requires

00:31:00,020 --> 00:31:04,970
and also to help with the bandwidth

00:31:02,760 --> 00:31:07,260
issue we can actually have a

00:31:04,970 --> 00:31:08,730
client-server type model so that you can

00:31:07,260 --> 00:31:10,230
have one big buffer that keeps track of

00:31:08,730 --> 00:31:11,820
all your data and if you just want to

00:31:10,230 --> 00:31:14,370
query it periodically and you don't care

00:31:11,820 --> 00:31:17,220
about the latency you can just do a

00:31:14,370 --> 00:31:21,600
remote query together and the good news

00:31:17,220 --> 00:31:24,090
is tf2 exists it's in the geometry

00:31:21,600 --> 00:31:25,230
experimental package we have several

00:31:24,090 --> 00:31:27,180
projects that are using it already

00:31:25,230 --> 00:31:29,130
people are quite happy with it its

00:31:27,180 --> 00:31:31,920
orders of magnitude faster it has

00:31:29,130 --> 00:31:35,540
significantly lower dependencies it has

00:31:31,920 --> 00:31:38,340
better unit tests it has documentation

00:31:35,540 --> 00:31:44,370
all this remain to do is merge it in in

00:31:38,340 --> 00:31:46,950
a backwards compatible way so related to

00:31:44,370 --> 00:31:50,580
that since I'm on the podium I'm going

00:31:46,950 --> 00:31:52,910
to mention the groovy SIG's are the

00:31:50,580 --> 00:31:54,960
proposal period is closing this weekend

00:31:52,910 --> 00:31:56,910
these are the ones we have currently on

00:31:54,960 --> 00:32:00,390
the website if you have been talking in

00:31:56,910 --> 00:32:02,370
a bath I recommend if you're interested

00:32:00,390 --> 00:32:04,290
in pursuing that as a development effort

00:32:02,370 --> 00:32:05,730
for groovy please put it up here get a

00:32:04,290 --> 00:32:09,990
documented so the rest of the community

00:32:05,730 --> 00:32:13,920
can know about it and nice shameless

00:32:09,990 --> 00:32:15,330
plug for my box but I'm organizing over

00:32:13,920 --> 00:32:17,640
lunch I'm gonna be doing a bath on the

00:32:15,330 --> 00:32:19,890
future of TF if people are interested in

00:32:17,640 --> 00:32:21,720
actually getting tf2 into the system I'd

00:32:19,890 --> 00:32:24,150
love to talk to you I know about your

00:32:21,720 --> 00:32:25,740
use cases it's not stabilized yet so

00:32:24,150 --> 00:32:30,120
that means we can still tweak the API

00:32:25,740 --> 00:32:33,360
add features and also at 3:30 during the

00:32:30,120 --> 00:32:35,539
break we have the new builds build and

00:32:33,360 --> 00:32:40,559
release system we've developed in

00:32:35,539 --> 00:32:42,809
we're going to be deploying it into

00:32:40,559 --> 00:32:44,760
groovy for public outside of Willow

00:32:42,809 --> 00:32:46,409
Garage we've been dogfooding it in

00:32:44,760 --> 00:32:48,270
flirty and now we're ready to start

00:32:46,409 --> 00:32:50,130
showing to other people if you're

00:32:48,270 --> 00:32:52,049
interested in trying that out getting in

00:32:50,130 --> 00:32:59,929
before we start recommending for public

00:32:52,049 --> 00:32:59,929
use I'd love to see you so questions

00:33:07,460 --> 00:33:13,349
so tf2 is fully functional I would

00:33:10,950 --> 00:33:15,629
there's one open ticket against it which

00:33:13,349 --> 00:33:18,779
is the debug strings are slightly out of

00:33:15,629 --> 00:33:20,820
order we have several projects within

00:33:18,779 --> 00:33:23,489
Willow Garage using it that people using

00:33:20,820 --> 00:33:26,399
it have been quite happy if you want to

00:33:23,489 --> 00:33:27,929
start using it in its current form be

00:33:26,399 --> 00:33:30,509
aware there will be probably a namespace

00:33:27,929 --> 00:33:35,159
change but other than that yes you can

00:33:30,509 --> 00:33:37,169
go ahead and start using it the API is

00:33:35,159 --> 00:33:39,659
fairly stable it's been actually

00:33:37,169 --> 00:33:42,570
developed it like eighteen months ago

00:33:39,659 --> 00:33:45,779
it's a it's not a very big divergence

00:33:42,570 --> 00:33:47,759
from the TF API the backwards

00:33:45,779 --> 00:33:50,249
compatibility way that I plan to deploy

00:33:47,759 --> 00:33:52,679
it is that I believe I can actually take

00:33:50,249 --> 00:33:54,989
the entire TF API and just call through

00:33:52,679 --> 00:33:58,289
to tf2 underneath so we only have to

00:33:54,989 --> 00:34:01,049
have one implementation in the system so

00:33:58,289 --> 00:34:03,450
the question is if you know a lot of the

00:34:01,049 --> 00:34:05,070
transforms around principle axes could

00:34:03,450 --> 00:34:06,629
we reduce the bandwidth and put that

00:34:05,070 --> 00:34:09,470
into tf2 to actually have knowledge of

00:34:06,629 --> 00:34:11,250
what the coordinates what the specific

00:34:09,470 --> 00:34:14,099
transforms are so you can only send one

00:34:11,250 --> 00:34:18,089
data or one about one value instead of

00:34:14,099 --> 00:34:19,919
the full six or seven sorry that is a

00:34:18,089 --> 00:34:23,129
possibility for the future that's not

00:34:19,919 --> 00:34:26,940
mcf to witchdoctor the exact same tf2

00:34:23,129 --> 00:34:28,409
and TF are completely compatible so we

00:34:26,940 --> 00:34:31,289
haven't I haven't gotten to data

00:34:28,409 --> 00:34:33,149
compression at that level so the

00:34:31,289 --> 00:34:36,569
question is is there a tool that should

00:34:33,149 --> 00:34:38,549
I had the graphs of the buffers and how

00:34:36,569 --> 00:34:41,039
they can fail well there it's four out

00:34:38,549 --> 00:34:43,049
of the front or out of the back the best

00:34:41,039 --> 00:34:45,839
tool I can recommend right now is view

00:34:43,049 --> 00:34:48,029
frames which gives you the tree

00:34:45,839 --> 00:34:49,740
structure and it'll tell you the length

00:34:48,029 --> 00:34:52,500
of the buffer and the laugh and the most

00:34:49,740 --> 00:34:54,510
recent one so you can from that you

00:34:52,500 --> 00:34:57,059
could you can pretty quickly figure out

00:34:54,510 --> 00:34:59,010
which one is out of date and you also

00:34:57,059 --> 00:35:02,789
have the in all the exceptions it has

00:34:59,010 --> 00:35:04,079
the frame ID there it'll tell you what

00:35:02,789 --> 00:35:05,579
frames you've queried between so then

00:35:04,079 --> 00:35:08,130
you can just traverse the tree manually

00:35:05,579 --> 00:35:09,809
and view it definitely a tool that would

00:35:08,130 --> 00:35:13,049
give you the bar graph the sliding bar

00:35:09,809 --> 00:35:14,789
graphs would also be interesting sure so

00:35:13,049 --> 00:35:17,779
the question is can explain the buffer

00:35:14,789 --> 00:35:19,980
server client the client server buffered

00:35:17,779 --> 00:35:23,339
relationship

00:35:19,980 --> 00:35:25,980
so basically we in tf2 we took the basic

00:35:23,339 --> 00:35:27,750
way that you interact with TF and made

00:35:25,980 --> 00:35:32,069
it an abstract base class so it's just

00:35:27,750 --> 00:35:34,079
an interface and then there's the data

00:35:32,069 --> 00:35:36,299
storage which hat provides that

00:35:34,079 --> 00:35:38,430
interface but then there's also another

00:35:36,299 --> 00:35:40,920
class which will provide that interface

00:35:38,430 --> 00:35:43,470
and instead of querying a local buffer

00:35:40,920 --> 00:35:46,619
it'll go out over an action sir action

00:35:43,470 --> 00:35:48,750
Lib and query another if you visit and

00:35:46,619 --> 00:35:51,630
she ate a buffer with the action server

00:35:48,750 --> 00:35:53,099
on it any client with the action client

00:35:51,630 --> 00:35:55,829
could just point to that server and say

00:35:53,099 --> 00:35:58,020
hey what's the transform between A to B

00:35:55,829 --> 00:36:01,109
we've added some extra time out so you

00:35:58,020 --> 00:36:02,190
can actually timeout your queries and

00:36:01,109 --> 00:36:04,170
it'll come back and throw an exception

00:36:02,190 --> 00:36:06,390
to you saying I couldn't get it after a

00:36:04,170 --> 00:36:08,609
second the network may be down the

00:36:06,390 --> 00:36:10,260
transform may not be available so you

00:36:08,609 --> 00:36:13,049
can set the timeouts to do these remote

00:36:10,260 --> 00:36:14,549
queries at a with higher latency but you

00:36:13,049 --> 00:36:18,450
don't have to incur the cost of keep

00:36:14,549 --> 00:36:21,390
maintaining the local buffer so the you

00:36:18,450 --> 00:36:25,200
RDF tools the question is how to TF and

00:36:21,390 --> 00:36:28,290
you RDF relate to each other the robot

00:36:25,200 --> 00:36:31,049
modeling tools know how to publish TF

00:36:28,290 --> 00:36:35,520
based on the you RDF there's no

00:36:31,049 --> 00:36:36,720
connection backwards and the your TF and

00:36:35,520 --> 00:36:40,140
all those things that you already F

00:36:36,720 --> 00:36:43,349
defines all the frame IDs for those for

00:36:40,140 --> 00:36:46,710
the all the links in the robot know if

00:36:43,349 --> 00:36:49,349
you loading a your TF does not there is

00:36:46,710 --> 00:36:51,869
a tool I believe it's robot state

00:36:49,349 --> 00:36:54,150
publisher which takes in the joint state

00:36:51,869 --> 00:36:56,839
and the you RDF and publishes the TF

00:36:54,150 --> 00:37:01,170
transform for you for the entire you RDF

00:36:56,839 --> 00:37:02,670
we don't have computing jacobians so the

00:37:01,170 --> 00:37:06,839
question is do we have plans to put

00:37:02,670 --> 00:37:08,730
competing jacobians into the Train TF no

00:37:06,839 --> 00:37:11,700
one's actually asked for that so I

00:37:08,730 --> 00:37:14,400
haven't been looking at that there are

00:37:11,700 --> 00:37:17,190
some rudimentary support for computing

00:37:14,400 --> 00:37:21,150
twists through the tree but that's

00:37:17,190 --> 00:37:26,069
that's all we've looked at beyond static

00:37:21,150 --> 00:37:27,599
transforms we have not so the question

00:37:26,069 --> 00:37:30,690
is has anyone looked at benchmarking TF

00:37:27,599 --> 00:37:33,150
we have not benchmarked TF in any

00:37:30,690 --> 00:37:35,520
specific way in this

00:37:33,150 --> 00:37:36,420
of rewriting for tf2 we took like three

00:37:35,520 --> 00:37:38,609
orders of magnitude out of the

00:37:36,420 --> 00:37:41,640
performance but nobody was complaining

00:37:38,609 --> 00:37:43,619
about performance previously I have had

00:37:41,640 --> 00:37:49,140
one request for slightly higher

00:37:43,619 --> 00:37:50,819
performance Thomas are from Tom he's

00:37:49,140 --> 00:37:53,010
doing that he's doing the uncertainty F

00:37:50,819 --> 00:37:54,660
and he's querying it really fast and a

00:37:53,010 --> 00:37:56,730
whole sort of a whole array of

00:37:54,660 --> 00:38:00,289
transforms and he started asking for

00:37:56,730 --> 00:38:03,690
performance improvements but in general

00:38:00,289 --> 00:38:05,640
where you can do it at many kilohertz

00:38:03,690 --> 00:38:07,799
approaching a megahertz to query the

00:38:05,640 --> 00:38:10,520
tree so I haven't people have not asked

00:38:07,799 --> 00:38:10,520

YouTube URL: https://www.youtube.com/watch?v=2gVo06HR2Tc


