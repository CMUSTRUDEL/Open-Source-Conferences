Title: ROSCon 2017 Vancouver Day 2  How to design ROS powered robots
Publication date: 2021-03-28
Playlist: ROSCon 2017
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2017 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License
Captions: 
	00:00:02,600 --> 00:00:09,440
okay hi everybody

00:00:05,130 --> 00:00:11,940
and look I'm economy from parabolics and

00:00:09,440 --> 00:00:15,179
today I'm gonna talk a little bit about

00:00:11,940 --> 00:00:17,369
our company it's the first time I have a

00:00:15,179 --> 00:00:21,480
talk here at Ruskin it's quite exciting

00:00:17,369 --> 00:00:23,820
and I will give you a short overview of

00:00:21,480 --> 00:00:25,980
the software development at our company

00:00:23,820 --> 00:00:28,800
and then I will dig a little bit into

00:00:25,980 --> 00:00:30,920
some tools that we have been using that

00:00:28,800 --> 00:00:34,649
I think that by convenient for

00:00:30,920 --> 00:00:37,680
developing robot with Ross and then we

00:00:34,649 --> 00:00:39,450
talk I will talk about our control

00:00:37,680 --> 00:00:41,370
architecture and more in detail about

00:00:39,450 --> 00:00:44,219
what body control that is sandy that we

00:00:41,370 --> 00:00:46,110
use on our bipeds and also on Thiago

00:00:44,219 --> 00:00:48,809
robot that you could have seen at our

00:00:46,110 --> 00:00:52,850
booth and some application of this

00:00:48,809 --> 00:00:52,850
software for the space robotic challenge

00:00:52,910 --> 00:00:59,219
we have para bodies started doing robots

00:00:57,120 --> 00:01:03,300
more than 10 years ago before we log

00:00:59,219 --> 00:01:05,880
orig and we got excited when we saw Ross

00:01:03,300 --> 00:01:11,159
and we adopted Ross since the beginning

00:01:05,880 --> 00:01:13,650
almost so in 2011 actually rim the white

00:01:11,159 --> 00:01:17,880
robot with wheels was the first robot

00:01:13,650 --> 00:01:20,040
that was for sale using Ross and in

00:01:17,880 --> 00:01:23,100
particular we were using the full

00:01:20,040 --> 00:01:26,549
navigation stack movie it not yet move

00:01:23,100 --> 00:01:28,250
it but --mine manipulation using joint

00:01:26,549 --> 00:01:32,579
trajectory controllers all this stuff

00:01:28,250 --> 00:01:35,520
and then for MC we contributed to

00:01:32,579 --> 00:01:39,720
developing Ross control so MC was

00:01:35,520 --> 00:01:41,250
therefore first humanoid robot type a

00:01:39,720 --> 00:01:45,299
humanoid robot with Ross control and

00:01:41,250 --> 00:01:47,640
then recently now we have a huge family

00:01:45,299 --> 00:01:50,490
of robots smaller one mobile basis

00:01:47,640 --> 00:01:53,250
mobile manipulators stock bot that is

00:01:50,490 --> 00:01:55,290
for automatic inventory a new Viper that

00:01:53,250 --> 00:01:57,450
we just released last year that is four

00:01:55,290 --> 00:02:01,380
liter controlled for industrial

00:01:57,450 --> 00:02:03,329
applications this has been possible

00:02:01,380 --> 00:02:04,770
thanks to a lot of partners and

00:02:03,329 --> 00:02:07,229
collaborators all around the world we

00:02:04,770 --> 00:02:11,640
shipped robot everywhere and we are

00:02:07,229 --> 00:02:13,920
involved in several European projects so

00:02:11,640 --> 00:02:17,430
what we do we we use Ross

00:02:13,920 --> 00:02:21,599
I mean there can be a lot of answers to

00:02:17,430 --> 00:02:24,270
this question the main reasons that we

00:02:21,599 --> 00:02:27,030
want to deliver robot that works and we

00:02:24,270 --> 00:02:29,910
don't want to reinvent the wheel okay so

00:02:27,030 --> 00:02:33,420
in some sectors Ross can also be

00:02:29,910 --> 00:02:36,350
considered selling argument and for sure

00:02:33,420 --> 00:02:38,550
the it's quite helpful to use all the

00:02:36,350 --> 00:02:39,989
powerful development tools that are

00:02:38,550 --> 00:02:42,060
available with Ross so I'm thinking

00:02:39,989 --> 00:02:44,849
about RVs I'm thinking about the Ziva

00:02:42,060 --> 00:02:48,720
simulation Ross control and a lot of

00:02:44,849 --> 00:02:51,900
introspection and debugging tools we

00:02:48,720 --> 00:02:54,390
want to focus on on building complex or

00:02:51,900 --> 00:02:57,840
bodies application so it's important to

00:02:54,390 --> 00:03:01,230
have shared effort with the community to

00:02:57,840 --> 00:03:04,500
benefit everybody from the the Ross

00:03:01,230 --> 00:03:07,310
libraries and and the core of what we

00:03:04,500 --> 00:03:11,700
are doing we have some public

00:03:07,310 --> 00:03:14,430
repositories in that allowed people to

00:03:11,700 --> 00:03:16,590
test our robot in simulation and test

00:03:14,430 --> 00:03:18,840
some of our libraries so you can have a

00:03:16,590 --> 00:03:21,810
look at the github repository or the

00:03:18,840 --> 00:03:23,790
wiki tutorials for getting an idea of

00:03:21,810 --> 00:03:25,829
what we are doing and which are the

00:03:23,790 --> 00:03:29,579
capabilities and the application of our

00:03:25,829 --> 00:03:32,760
robots soon also we will release the

00:03:29,579 --> 00:03:36,090
simulation of the new biped as I told

00:03:32,760 --> 00:03:39,390
you before as a full-sized human sides

00:03:36,090 --> 00:03:42,359
by bad robot with torque control in

00:03:39,390 --> 00:03:44,850
every joint EtherCAT and has been

00:03:42,359 --> 00:03:47,040
designated design thinking about an

00:03:44,850 --> 00:03:49,799
industrial application because we have

00:03:47,040 --> 00:03:51,660
some pilot project with aerospace

00:03:49,799 --> 00:03:55,100
manufacturer that is interested in

00:03:51,660 --> 00:03:58,109
evaluating such kind of platforms for

00:03:55,100 --> 00:04:02,040
complex tasks such as drilling or

00:03:58,109 --> 00:04:07,140
riveting in unconvenient economical a

00:04:02,040 --> 00:04:09,720
configuration for humans short overview

00:04:07,140 --> 00:04:12,450
of what we have inside our robot we

00:04:09,720 --> 00:04:17,010
Xubuntu we have real-time operative

00:04:12,450 --> 00:04:18,930
system with genome I or preempt RT we

00:04:17,010 --> 00:04:22,800
use the raucous because we really like

00:04:18,930 --> 00:04:25,320
its component based approach and then we

00:04:22,800 --> 00:04:27,240
use in the in the current stable version

00:04:25,320 --> 00:04:30,840
of our robot we have raw scene

00:04:27,240 --> 00:04:33,930
and pal doom that is our software

00:04:30,840 --> 00:04:36,990
destroy we are working on migrating to a

00:04:33,930 --> 00:04:40,410
bun to 16 to kinetic now our new

00:04:36,990 --> 00:04:41,639
district will be air boom and for the

00:04:40,410 --> 00:04:43,860
future we are waiting for

00:04:41,639 --> 00:04:47,150
Rostow because we believe that will give

00:04:43,860 --> 00:04:49,830
us more flexibility and control over

00:04:47,150 --> 00:04:52,349
inter-process communication deployment

00:04:49,830 --> 00:04:55,860
and hopefully more security because at

00:04:52,349 --> 00:04:58,530
the moment is they are quite fragile the

00:04:55,860 --> 00:05:01,949
application because it's everything is

00:04:58,530 --> 00:05:03,810
is let's say open there are no

00:05:01,949 --> 00:05:08,159
encryption in the communication and

00:05:03,810 --> 00:05:13,680
someone publishing on TF can can get

00:05:08,159 --> 00:05:16,620
your system completely stuck one

00:05:13,680 --> 00:05:18,479
important part of our work is to

00:05:16,620 --> 00:05:20,909
validate our software on hardware

00:05:18,479 --> 00:05:23,370
because we build hardware and we develop

00:05:20,909 --> 00:05:27,060
software and the software without order

00:05:23,370 --> 00:05:29,759
validation is nothing so every time that

00:05:27,060 --> 00:05:32,280
a developer has a new package or an

00:05:29,759 --> 00:05:34,949
improvement at an existing package we

00:05:32,280 --> 00:05:37,500
need to deploy such software on the

00:05:34,949 --> 00:05:41,699
robot so we have a script that we call

00:05:37,500 --> 00:05:44,759
pal deploy that basically allow us to

00:05:41,699 --> 00:05:48,270
reproduce the work space on the robot

00:05:44,759 --> 00:05:50,940
and this is done by copying the

00:05:48,270 --> 00:05:53,940
workspace on a folder and thanks to the

00:05:50,940 --> 00:05:57,690
order in the Ross package pad we can

00:05:53,940 --> 00:06:00,389
overlay or we can add new packages to

00:05:57,690 --> 00:06:06,659
the system but the important part of

00:06:00,389 --> 00:06:09,240
this method is that is completely let's

00:06:06,659 --> 00:06:10,770
say can coexist with the install at

00:06:09,240 --> 00:06:13,650
Debian packages that we have been in the

00:06:10,770 --> 00:06:16,669
system and is easy to roll back to a

00:06:13,650 --> 00:06:22,080
working system just deleting the

00:06:16,669 --> 00:06:26,610
deployed workspace and this also is it's

00:06:22,080 --> 00:06:31,099
done together with let's say a policy to

00:06:26,610 --> 00:06:33,449
avoid editing file on the robot to avoid

00:06:31,099 --> 00:06:35,789
pushing before I've invalidated a stern

00:06:33,449 --> 00:06:39,710
lecture roll of a package so through

00:06:35,789 --> 00:06:42,170
this tool we can

00:06:39,710 --> 00:06:45,560
in a convenient way validate our

00:06:42,170 --> 00:06:47,900
software before pushing it to to get

00:06:45,560 --> 00:06:49,700
luck for instance important constraint

00:06:47,900 --> 00:06:50,900
of the system that you need to respect

00:06:49,700 --> 00:06:53,230
API

00:06:50,900 --> 00:06:55,700
ABI compatibility because the

00:06:53,230 --> 00:06:57,920
development environment of the of the

00:06:55,700 --> 00:07:00,650
workstation should have the same version

00:06:57,920 --> 00:07:03,650
of libraries or at least the same API

00:07:00,650 --> 00:07:08,710
ABI of the robot because otherwise you

00:07:03,650 --> 00:07:08,710
have to system that are not consistent

00:07:09,160 --> 00:07:16,190
we believe continuous integration is

00:07:12,250 --> 00:07:19,040
very important and we use github hooks

00:07:16,190 --> 00:07:22,460
together with Jenkins job automatically

00:07:19,040 --> 00:07:25,220
triggered by pushes and we build in

00:07:22,460 --> 00:07:28,760
clean environment we add unit testing to

00:07:25,220 --> 00:07:33,290
our repos and coverage checks and also

00:07:28,760 --> 00:07:34,820
ABI API checks and there are

00:07:33,290 --> 00:07:37,580
notification for developers and

00:07:34,820 --> 00:07:40,310
maintainer in case of these errors

00:07:37,580 --> 00:07:42,500
appears and the continuous integration

00:07:40,310 --> 00:07:46,760
is automatic for master and developed

00:07:42,500 --> 00:07:49,790
branch we try to strict stick to the git

00:07:46,760 --> 00:07:54,350
flow branching model for our software

00:07:49,790 --> 00:07:58,720
repos and additionally we have a way to

00:07:54,350 --> 00:08:02,030
visualize let's say the differences

00:07:58,720 --> 00:08:05,660
during merge request so in this case you

00:08:02,030 --> 00:08:08,360
can see that the merge request of the

00:08:05,660 --> 00:08:11,060
standard test branch into the master

00:08:08,360 --> 00:08:13,250
branch increase the coverage increase

00:08:11,060 --> 00:08:15,740
the number of tests and respect the API

00:08:13,250 --> 00:08:20,120
ABI compatibility so we have this

00:08:15,740 --> 00:08:22,250
graphical that's a way to help the user

00:08:20,120 --> 00:08:25,370
the developer that has to perform a

00:08:22,250 --> 00:08:27,770
merge request and understand what's

00:08:25,370 --> 00:08:33,020
going on after them that the request the

00:08:27,770 --> 00:08:35,540
merge request has been accepted also we

00:08:33,020 --> 00:08:38,420
have a complex releasing system because

00:08:35,540 --> 00:08:41,960
we have more than 800 repos so we can

00:08:38,420 --> 00:08:43,820
visualize the relation relationship

00:08:41,960 --> 00:08:47,510
between the software wrappers that we

00:08:43,820 --> 00:08:51,260
have in terms of dependencies and depend

00:08:47,510 --> 00:08:52,790
this so that we can go on with the

00:08:51,260 --> 00:08:55,550
releasing process step

00:08:52,790 --> 00:08:58,160
by step starting from the low-level

00:08:55,550 --> 00:09:05,390
dependencies and scanning up to the high

00:08:58,160 --> 00:09:08,180
level repositories and also we have a

00:09:05,390 --> 00:09:09,800
remote way to upgrade the software that

00:09:08,180 --> 00:09:13,430
is delivered with our robos through a

00:09:09,800 --> 00:09:17,000
VPN connection so that we can remotely

00:09:13,430 --> 00:09:18,830
connect to a customer facility to check

00:09:17,000 --> 00:09:25,670
the status of the robot to provide the

00:09:18,830 --> 00:09:28,070
Debian upgrades or bug fixing now I'm

00:09:25,670 --> 00:09:31,100
talking a little bit about the control

00:09:28,070 --> 00:09:35,000
architecture of our systems we have

00:09:31,100 --> 00:09:38,510
several robots as I already told you but

00:09:35,000 --> 00:09:41,860
we try to use the same architecture so

00:09:38,510 --> 00:09:44,540
that we can reduce the effort of

00:09:41,860 --> 00:09:48,410
upgrading at the new functionalities or

00:09:44,540 --> 00:09:51,410
validating and testing our platforms for

00:09:48,410 --> 00:09:54,500
this reason I here I divided the system

00:09:51,410 --> 00:09:57,670
into trip into three parts we have at

00:09:54,500 --> 00:10:00,530
the lower level the hardware we reuse

00:09:57,670 --> 00:10:03,470
hardware components but there are always

00:10:00,530 --> 00:10:06,200
differences between robots there are

00:10:03,470 --> 00:10:08,720
differences in communication bus there

00:10:06,200 --> 00:10:12,880
are differences in sensors in kinematics

00:10:08,720 --> 00:10:15,560
structure and we try to abstract these

00:10:12,880 --> 00:10:17,360
thanks to Ross control source control is

00:10:15,560 --> 00:10:19,820
a component that is running in Rocko's

00:10:17,360 --> 00:10:21,410
and in August we have another component

00:10:19,820 --> 00:10:24,130
that is their twitters manager that is

00:10:21,410 --> 00:10:27,200
the guy talking to the hardware and

00:10:24,130 --> 00:10:30,020
inside Ross control we can load plugins

00:10:27,200 --> 00:10:31,490
we can load controllers already of the

00:10:30,020 --> 00:10:33,020
chef controller such as the join

00:10:31,490 --> 00:10:35,600
trajectory controllers the effort

00:10:33,020 --> 00:10:38,120
controllers the diff dry controller but

00:10:35,600 --> 00:10:41,780
also our own controllers that we

00:10:38,120 --> 00:10:44,660
developed following the same interface

00:10:41,780 --> 00:10:46,280
of Ross control so we are the working

00:10:44,660 --> 00:10:51,950
controller and there were body control

00:10:46,280 --> 00:10:55,580
and then this expose everything hardware

00:10:51,950 --> 00:10:58,880
sensor to the Ross echo system so that

00:10:55,580 --> 00:11:01,430
we can use navigation stack move it and

00:10:58,880 --> 00:11:04,270
all other libraries that are available

00:11:01,430 --> 00:11:04,270
in Ross

00:11:04,400 --> 00:11:09,130
I want to stress the important of using

00:11:06,980 --> 00:11:13,010
a real-time system when controlling

00:11:09,130 --> 00:11:16,250
robots because hardware needs real-time

00:11:13,010 --> 00:11:18,980
communication and also because the

00:11:16,250 --> 00:11:22,430
controllers need determinism you want

00:11:18,980 --> 00:11:24,529
the robot to be to perform in a

00:11:22,430 --> 00:11:27,770
deterministic way you want to control

00:11:24,529 --> 00:11:29,480
the timing execution of every controller

00:11:27,770 --> 00:11:35,600
of every functionality so you need to

00:11:29,480 --> 00:11:38,060
have a real-time system ok what is the

00:11:35,600 --> 00:11:41,480
difference between the different robots

00:11:38,060 --> 00:11:44,270
we try to stick to having just different

00:11:41,480 --> 00:11:46,220
you RDF different parameters in your

00:11:44,270 --> 00:11:50,750
file and different launch file so all

00:11:46,220 --> 00:11:54,110
our software is robot agnostic and it's

00:11:50,750 --> 00:11:58,190
configured that in with such parameters

00:11:54,110 --> 00:11:59,120
or at runtime parsing you RDF loading

00:11:58,190 --> 00:12:05,540
different plugins

00:11:59,120 --> 00:12:08,420
and and that's it one of the controllers

00:12:05,540 --> 00:12:10,730
that are cross control plugins is the

00:12:08,420 --> 00:12:14,450
world body control that is one of our

00:12:10,730 --> 00:12:16,400
most complex piece of software and the

00:12:14,450 --> 00:12:20,089
philosophy behind the Ross control the

00:12:16,400 --> 00:12:22,790
ball body control is that we want to

00:12:20,089 --> 00:12:27,470
program the robot with high-level tasks

00:12:22,790 --> 00:12:31,040
we don't want to go deep into kinematics

00:12:27,470 --> 00:12:34,490
into joint control so we want to define

00:12:31,040 --> 00:12:40,220
high level tasks such as respect joint

00:12:34,490 --> 00:12:43,190
limits avoid the self collision put the

00:12:40,220 --> 00:12:46,640
end effector in that position and at the

00:12:43,190 --> 00:12:50,630
same time we want some basic rules to be

00:12:46,640 --> 00:12:53,620
respected such as balance or keep the

00:12:50,630 --> 00:13:00,339
feet on the ground to prevent falling

00:12:53,620 --> 00:13:04,400
and here I can show you some simulation

00:13:00,339 --> 00:13:07,670
of such system on different robots so

00:13:04,400 --> 00:13:10,400
here we have rim scene and Atlas with

00:13:07,670 --> 00:13:13,010
interactive markers we can move the end

00:13:10,400 --> 00:13:16,400
effectors and here you can see the self

00:13:13,010 --> 00:13:18,200
collision avoidance so you have capsule

00:13:16,400 --> 00:13:21,649
around the links of the robot

00:13:18,200 --> 00:13:23,589
and the robot is is avoiding is

00:13:21,649 --> 00:13:26,269
preventing to to collide with himself

00:13:23,589 --> 00:13:29,899
just because there is an aniline solver

00:13:26,269 --> 00:13:32,450
that is caring about this at the same

00:13:29,899 --> 00:13:34,910
time keeping the robot upright keeping a

00:13:32,450 --> 00:13:42,470
reference posture keeping the feet on

00:13:34,910 --> 00:13:45,260
the ground and the wall body control is

00:13:42,470 --> 00:13:47,510
Robert agnostic as I told you so is

00:13:45,260 --> 00:13:49,220
configured through our you RDF and

00:13:47,510 --> 00:13:52,690
through the specification of high-level

00:13:49,220 --> 00:13:56,660
tasks such as center of mass position

00:13:52,690 --> 00:13:59,630
gaze go to task for the end effectors

00:13:56,660 --> 00:14:03,350
and join limited task

00:13:59,630 --> 00:14:07,300
this is translated into a stack of tasks

00:14:03,350 --> 00:14:11,000
in which the order is prioritized and

00:14:07,300 --> 00:14:13,220
that translate to a mathematical problem

00:14:11,000 --> 00:14:16,670
your article quadratic problem that is

00:14:13,220 --> 00:14:18,920
solved online on the robot at 200

00:14:16,670 --> 00:14:24,649
Earth's for instance in Tiago and rim

00:14:18,920 --> 00:14:28,070
see and not one killers on Talos here's

00:14:24,649 --> 00:14:30,769
an example of a stack of tasks for a

00:14:28,070 --> 00:14:35,149
biped for instance so you have the high

00:14:30,769 --> 00:14:36,890
level priority join limits respect self

00:14:35,149 --> 00:14:38,510
collision avoidance the feet on the

00:14:36,890 --> 00:14:40,699
ground the center of mass centered in

00:14:38,510 --> 00:14:43,160
between the feet and then at low

00:14:40,699 --> 00:14:44,630
priority you have towards orientation

00:14:43,160 --> 00:14:47,660
upright you want the robot to be

00:14:44,630 --> 00:14:52,839
straight if possible and at joint

00:14:47,660 --> 00:14:55,790
reference posture and this allow us to

00:14:52,839 --> 00:15:04,010
control the robot in quite intuitive way

00:14:55,790 --> 00:15:06,050
just by specifying simple end position

00:15:04,010 --> 00:15:08,839
for the end effector so here you will

00:15:06,050 --> 00:15:11,269
see in the middle the red dots are the

00:15:08,839 --> 00:15:13,990
position that should be reached by the

00:15:11,269 --> 00:15:16,430
end effectors and on top you see a

00:15:13,990 --> 00:15:19,850
position that is where the robot should

00:15:16,430 --> 00:15:23,500
look and although this is solved online

00:15:19,850 --> 00:15:25,970
so you don't care about joints

00:15:23,500 --> 00:15:30,319
trajectories or joint limits for

00:15:25,970 --> 00:15:31,970
avoiding the robot from folding and we

00:15:30,319 --> 00:15:35,299
think that this is the future so

00:15:31,970 --> 00:15:37,809
we need such such kind of complex

00:15:35,299 --> 00:15:40,789
software that abstract the complexity of

00:15:37,809 --> 00:15:42,289
such platforms that there's so many

00:15:40,789 --> 00:15:44,119
degrees of freedom that otherwise it's

00:15:42,289 --> 00:15:48,679
impossible to care with this complexity

00:15:44,119 --> 00:15:54,189
and and developing a high level

00:15:48,679 --> 00:15:58,239
application here is an example that

00:15:54,189 --> 00:16:01,489
we'll show you also how you can include

00:15:58,239 --> 00:16:04,729
forces with the environment into this

00:16:01,489 --> 00:16:08,449
framework so the idea is that we have a

00:16:04,729 --> 00:16:11,119
force sensor in the right wrist and the

00:16:08,449 --> 00:16:13,669
robot is following the force so you can

00:16:11,119 --> 00:16:17,299
interact physically with the robot and

00:16:13,669 --> 00:16:20,599
the robot will will just follow the

00:16:17,299 --> 00:16:23,659
external perturbation keep in the

00:16:20,599 --> 00:16:26,059
balance you can see that the left arm is

00:16:23,659 --> 00:16:29,779
moved backward to compensate for the

00:16:26,059 --> 00:16:32,359
dynamics introduced by the the the

00:16:29,779 --> 00:16:34,309
person that is shaking the hem and you

00:16:32,359 --> 00:16:37,039
can imagine this method being used for

00:16:34,309 --> 00:16:40,339
so for manipulating a tool for drilling

00:16:37,039 --> 00:16:44,929
for keeping an object from the ground

00:16:40,339 --> 00:16:47,779
for walking and resists perturb and sees

00:16:44,929 --> 00:16:54,829
is the same method it's just a different

00:16:47,779 --> 00:16:57,829
task different stack of tasks we used

00:16:54,829 --> 00:17:00,709
extensively this method in the space

00:16:57,829 --> 00:17:03,949
robotic challenge was you have seen

00:17:00,709 --> 00:17:06,889
yesterday presentation about from our F

00:17:03,949 --> 00:17:10,459
guys about the Gazebo simulation for

00:17:06,889 --> 00:17:13,159
this challenge so current and former

00:17:10,459 --> 00:17:16,189
power robotics employee created a team

00:17:13,159 --> 00:17:18,529
the team Olympus Mons Olympus Mons is

00:17:16,189 --> 00:17:22,669
the tallest mountain in the solar system

00:17:18,529 --> 00:17:24,649
and we participated just for passion

00:17:22,669 --> 00:17:28,159
because we were ineligible for the price

00:17:24,649 --> 00:17:31,399
not being US citizens and we arrived

00:17:28,159 --> 00:17:33,110
third the challenge was complicated

00:17:31,399 --> 00:17:35,980
because the robot had to perform a lot

00:17:33,110 --> 00:17:39,019
of complex tasks of manipulation and

00:17:35,980 --> 00:17:41,750
walking in in a in a simulated

00:17:39,019 --> 00:17:45,030
environment but we managed using the

00:17:41,750 --> 00:17:50,700
whole body control to score well in

00:17:45,030 --> 00:17:55,080
of the of the missions and the result is

00:17:50,700 --> 00:17:58,320
that was was fun a lot of fun I was hard

00:17:55,080 --> 00:18:01,100
because we spent really a lot of hours

00:17:58,320 --> 00:18:03,420
in front of our control station

00:18:01,100 --> 00:18:05,310
controlling this robot on Mars with

00:18:03,420 --> 00:18:07,890
delays in the communication with limited

00:18:05,310 --> 00:18:09,420
bandwidth integrating aggarwal body

00:18:07,890 --> 00:18:11,940
control with the world body control

00:18:09,420 --> 00:18:16,290
provided by the organization through the

00:18:11,940 --> 00:18:18,270
IHMC world body controller but I think

00:18:16,290 --> 00:18:21,540
that was worth because we learned a lot

00:18:18,270 --> 00:18:24,240
and also that all the software that we

00:18:21,540 --> 00:18:29,310
developed for this challenge is now

00:18:24,240 --> 00:18:32,520
already being used on our robots thanks

00:18:29,310 --> 00:18:39,150
to the the modularity of our software so

00:18:32,520 --> 00:18:42,540
we have now Talos robotic challenge in

00:18:39,150 --> 00:18:44,510
which we will have Talos performing the

00:18:42,540 --> 00:18:47,250
same challenge that valkira did on

00:18:44,510 --> 00:18:51,930
gazebo we have already this working

00:18:47,250 --> 00:18:54,180
after really two days of gluing together

00:18:51,930 --> 00:18:57,480
the component that we had already for

00:18:54,180 --> 00:19:01,370
the space robotic challenge I can show

00:18:57,480 --> 00:19:04,740
you some video of the Talos going fast

00:19:01,370 --> 00:19:07,050
picking objects the briefcase connecting

00:19:04,740 --> 00:19:10,740
the cable and so on and so forth and

00:19:07,050 --> 00:19:13,620
more important now we will test this

00:19:10,740 --> 00:19:17,580
software on the real Talos so we will

00:19:13,620 --> 00:19:19,710
make the real Talos challenge ok so now

00:19:17,580 --> 00:19:22,110
in two months there will be you manage

00:19:19,710 --> 00:19:24,720
conference in Birmingham and we awfully

00:19:22,110 --> 00:19:29,670
will show some of this tasks on the real

00:19:24,720 --> 00:19:32,820
robot thanks to the let's say the tools

00:19:29,670 --> 00:19:34,380
provided by Ross and the modularity of

00:19:32,820 --> 00:19:41,040
the software that we have developed on

00:19:34,380 --> 00:19:45,450
top of Ross and I think that's it so

00:19:41,040 --> 00:19:49,290
thanks to Ross community for all that is

00:19:45,450 --> 00:19:53,060
available outside and thanks to you for

00:19:49,290 --> 00:19:54,540
the attention and you can see a lot of

00:19:53,060 --> 00:19:56,520
RBC Malaysia

00:19:54,540 --> 00:19:58,530
Arbus visualization and gazebo

00:19:56,520 --> 00:19:58,890
simulation model so a lot of Thiago's

00:19:58,530 --> 00:20:02,130
that we

00:19:58,890 --> 00:20:03,710
are delivering to happy robot assist

00:20:02,130 --> 00:20:11,590
thank you

00:20:03,710 --> 00:20:14,960
[Applause]

00:20:11,590 --> 00:20:16,220
Thank You Luca we've got time for one

00:20:14,960 --> 00:20:19,010
quick question if that's what you heard

00:20:16,220 --> 00:20:20,990
it for those so you were talking about

00:20:19,010 --> 00:20:24,260
the whole body controller and my

00:20:20,990 --> 00:20:26,120
question is if you can somehow plug in

00:20:24,260 --> 00:20:28,220
collisions with the environment because

00:20:26,120 --> 00:20:32,179
to me it seemed quite simplistic and

00:20:28,220 --> 00:20:35,600
like static design but it would that be

00:20:32,179 --> 00:20:37,720
possible to include more constraints

00:20:35,600 --> 00:20:40,190
yeah yeah sure sure you can add also

00:20:37,720 --> 00:20:42,440
environment constraints yeah so you can

00:20:40,190 --> 00:20:43,429
add the table if you're manipulating as

00:20:42,440 --> 00:20:45,980
a constraint yeah

00:20:43,429 --> 00:20:51,409
can that be done like run during runtime

00:20:45,980 --> 00:20:54,830
like from the sensors yeah I mean maybe

00:20:51,409 --> 00:20:57,260
yeah I am I didn't tell you about the

00:20:54,830 --> 00:21:00,549
pile the stacks of tasks can be

00:20:57,260 --> 00:21:02,510
dynamically so we have a pop and push

00:21:00,549 --> 00:21:05,510
functionality so that you can add tasks

00:21:02,510 --> 00:21:08,240
remove tasks dynamically on the runtime

00:21:05,510 --> 00:21:11,090
so you can add whatever task you want as

00:21:08,240 --> 00:21:12,440
the sensor detect are playing or

00:21:11,090 --> 00:21:15,559
whatever you can add that geometrical

00:21:12,440 --> 00:21:21,350
constraint that is gonna be considered

00:21:15,559 --> 00:21:23,240
by the solver okay thank you well let's

00:21:21,350 --> 00:21:29,539
thank our speakers once more

00:21:23,240 --> 00:21:29,539

YouTube URL: https://www.youtube.com/watch?v=iPaxV9dBYEc


