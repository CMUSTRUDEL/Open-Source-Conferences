Title: ROSCon 2017 Vancouver Day 2  Using ROS2 for Vision Based Manipulation with Industrial Robots
Publication date: 2021-03-28
Playlist: ROSCon 2017
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2017 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License
Captions: 
	00:00:00,050 --> 00:00:07,170
all right thanks yeah so I'm custom

00:00:03,929 --> 00:00:09,059
working at Bosch and that's Adam former

00:00:07,170 --> 00:00:10,830
summer intern at the open robotics we're

00:00:09,059 --> 00:00:11,400
going to show you a bit what we did over

00:00:10,830 --> 00:00:13,679
the summer

00:00:11,400 --> 00:00:17,430
using Rosco for vision-based industrial

00:00:13,679 --> 00:00:19,260
manipulators on robots and let's click

00:00:17,430 --> 00:00:23,220
right in so at the beginning there were

00:00:19,260 --> 00:00:26,519
robots namely you me or the Euro 5 which

00:00:23,220 --> 00:00:27,359
we both were having at and we had Rosco

00:00:26,519 --> 00:00:29,400
right

00:00:27,359 --> 00:00:31,679
and so now if we talk about Russ tude

00:00:29,400 --> 00:00:33,540
and like a bunch of new words floating

00:00:31,679 --> 00:00:36,600
around which are pretty cool and awesome

00:00:33,540 --> 00:00:38,460
everybody waits for we're gonna talk

00:00:36,600 --> 00:00:39,950
about the few of them in particular so

00:00:38,460 --> 00:00:41,969
we're gonna talk about like multimode

00:00:39,950 --> 00:00:45,140
processors we talk about the lifecycle

00:00:41,969 --> 00:00:47,579
notes McHale and talking what is already

00:00:45,140 --> 00:00:52,559
interprocess communication composition

00:00:47,579 --> 00:00:54,180
and the immense resource index and so

00:00:52,559 --> 00:00:57,930
what we did in the end looks like this

00:00:54,180 --> 00:00:59,640
let's hope that video please yeah so we

00:00:57,930 --> 00:01:01,260
see like a dual our manipulator and

00:00:59,640 --> 00:01:03,870
doing the extras motions with both arms

00:01:01,260 --> 00:01:06,689
and we have like controllers written for

00:01:03,870 --> 00:01:08,640
this using the ABB Yuma driver for now

00:01:06,689 --> 00:01:12,270
but like it uses rows to for the

00:01:08,640 --> 00:01:15,689
trajectory controllers and everything a

00:01:12,270 --> 00:01:17,400
quick look about the big picture so like

00:01:15,689 --> 00:01:19,080
the way it works in writing a controller

00:01:17,400 --> 00:01:21,030
framework is that you have to have like

00:01:19,080 --> 00:01:22,979
your robe on the left side here and then

00:01:21,030 --> 00:01:25,729
you write something which is called like

00:01:22,979 --> 00:01:28,229
the robotics traction Hardware layer

00:01:25,729 --> 00:01:30,540
basically it runs you control a loop you

00:01:28,229 --> 00:01:32,759
read the joints from the one side using

00:01:30,540 --> 00:01:34,500
the driver then you have like a

00:01:32,759 --> 00:01:36,840
controller manager which we're gonna

00:01:34,500 --> 00:01:38,670
talk about it in the future and then the

00:01:36,840 --> 00:01:40,020
right joints were like you write their

00:01:38,670 --> 00:01:42,420
joints back to the robot to make the

00:01:40,020 --> 00:01:45,180
robot move now this controller manager

00:01:42,420 --> 00:01:47,009
has then sorts of like all sorts of

00:01:45,180 --> 00:01:48,210
controllers with it's like here we have

00:01:47,009 --> 00:01:49,890
like a joint State Controller work

00:01:48,210 --> 00:01:51,540
whenever you call update on that one it

00:01:49,890 --> 00:01:54,090
would publish the joint States or if you

00:01:51,540 --> 00:01:56,159
call like join trajectory controller you

00:01:54,090 --> 00:01:58,860
get external trajectories and then

00:01:56,159 --> 00:02:02,909
perform them on the robot if you need

00:01:58,860 --> 00:02:04,860
more details on this 2015 Rosco and

00:02:02,909 --> 00:02:06,930
Hamburg Jackie and a door forgave like a

00:02:04,860 --> 00:02:10,560
really nice talk about this link is down

00:02:06,930 --> 00:02:12,590
there check it out so now we use raw

00:02:10,560 --> 00:02:15,800
stupidest so we have like we wrote

00:02:12,590 --> 00:02:18,950
controller manager from from scratch so

00:02:15,800 --> 00:02:20,110
one thing we want to do here is like we

00:02:18,950 --> 00:02:23,000
want to load these controllers

00:02:20,110 --> 00:02:24,620
dynamically on runtime ideally right so

00:02:23,000 --> 00:02:25,849
what we want to do is like can you

00:02:24,620 --> 00:02:28,250
actually see my mouse your moving this

00:02:25,849 --> 00:02:29,330
one awesome so what we actually want to

00:02:28,250 --> 00:02:31,760
do is like we want to wrote these

00:02:29,330 --> 00:02:36,010
controllers by saying okay load that

00:02:31,760 --> 00:02:38,299
package called roschin ross controllers

00:02:36,010 --> 00:02:41,150
load that class or else controllers like

00:02:38,299 --> 00:02:43,610
the joint trajectory controller and call

00:02:41,150 --> 00:02:45,860
that node like it so in trajectory

00:02:43,610 --> 00:02:48,170
controller slash left in the name space

00:02:45,860 --> 00:02:50,690
if left arm then we do the same thing

00:02:48,170 --> 00:02:53,090
for the right arm so we load these notes

00:02:50,690 --> 00:02:54,410
twice now how does a potential

00:02:53,090 --> 00:02:56,750
implementation of this function look

00:02:54,410 --> 00:02:59,690
like the way we implemented is right now

00:02:56,750 --> 00:03:02,239
so we get our package name and the class

00:02:59,690 --> 00:03:03,709
name we fetch the library path from the

00:03:02,239 --> 00:03:05,510
amend resource index and we're going to

00:03:03,709 --> 00:03:07,310
talk about it on the next slide then we

00:03:05,510 --> 00:03:10,129
use classic class loader load the

00:03:07,310 --> 00:03:11,480
instance of a node loaded under the

00:03:10,129 --> 00:03:12,650
umbrella for controller interface we're

00:03:11,480 --> 00:03:12,980
going to talk about this next night as

00:03:12,650 --> 00:03:14,720
well

00:03:12,980 --> 00:03:17,180
but then and that's a new feature in ROS

00:03:14,720 --> 00:03:19,400
to you now we call it like we add the

00:03:17,180 --> 00:03:20,690
node to the executor and we call spin on

00:03:19,400 --> 00:03:23,090
it and so the nice thing about this

00:03:20,690 --> 00:03:25,280
right now here is that we can easily

00:03:23,090 --> 00:03:26,900
have multiple nodes put them in the

00:03:25,280 --> 00:03:29,450
executor called spin eventually on it

00:03:26,900 --> 00:03:31,370
and we have multi notes in one process

00:03:29,450 --> 00:03:33,139
which is pretty amazing and it helps a

00:03:31,370 --> 00:03:37,130
lot for for these sorts of controller

00:03:33,139 --> 00:03:38,540
applications one quick thing another new

00:03:37,130 --> 00:03:40,340
feature of frost to resolves that the

00:03:38,540 --> 00:03:42,139
immense resource index so what was there

00:03:40,340 --> 00:03:44,030
and was one with the grows back it's

00:03:42,139 --> 00:03:45,889
like now their main resource index and

00:03:44,030 --> 00:03:48,410
what it is is basically like a file

00:03:45,889 --> 00:03:51,530
system database if you want to call it

00:03:48,410 --> 00:03:53,569
like that I mean so the way it works now

00:03:51,530 --> 00:03:55,160
if you look into your roster workspace

00:03:53,569 --> 00:03:56,959
install folder you have a share for the

00:03:55,160 --> 00:03:59,660
main resource index and then eventually

00:03:56,959 --> 00:04:01,549
a key for your database called packages

00:03:59,660 --> 00:04:03,549
for example every package which is there

00:04:01,549 --> 00:04:06,290
and in your roster workspace now is

00:04:03,549 --> 00:04:08,599
registered under that key packages with

00:04:06,290 --> 00:04:10,359
a with a file accordingly to the package

00:04:08,599 --> 00:04:12,799
in this case like the controller manager

00:04:10,359 --> 00:04:16,010
and that's pretty cool so our tools can

00:04:12,799 --> 00:04:18,320
now easily fetch all all available

00:04:16,010 --> 00:04:20,359
packages but just asking in that folder

00:04:18,320 --> 00:04:22,789
specifically I give me all files which

00:04:20,359 --> 00:04:24,289
are in there namely all packages but the

00:04:22,789 --> 00:04:25,580
the really nice thing about this is now

00:04:24,289 --> 00:04:28,009
we can also use this

00:04:25,580 --> 00:04:29,930
on individual purposes namely exporting

00:04:28,009 --> 00:04:31,789
controllers so every package which now

00:04:29,930 --> 00:04:33,319
has the controller wants to export it so

00:04:31,789 --> 00:04:35,599
that we can dynamically load it

00:04:33,319 --> 00:04:38,750
afterwards we just put it in that thing

00:04:35,599 --> 00:04:42,190
and by convention I out of nothing just

00:04:38,750 --> 00:04:44,960
chose this convention okay under sorry

00:04:42,190 --> 00:04:46,970
under this key of controllers now we

00:04:44,960 --> 00:04:48,919
have a file called Ross controllers

00:04:46,970 --> 00:04:51,620
which is our package which contains the

00:04:48,919 --> 00:04:54,470
controllers to be exported and if we

00:04:51,620 --> 00:04:56,509
look into this file then we see actually

00:04:54,470 --> 00:04:59,300
okay we have the class name followed

00:04:56,509 --> 00:05:01,729
like semicolon and then the library part

00:04:59,300 --> 00:05:03,500
which library contains actually that

00:05:01,729 --> 00:05:05,030
class and it's like a little wing

00:05:03,500 --> 00:05:08,180
because I notice in the abstract we

00:05:05,030 --> 00:05:10,069
wrote about windows compatibility so I

00:05:08,180 --> 00:05:15,469
put a DLL in here so it actually works

00:05:10,069 --> 00:05:17,479
in Windows now now we have our

00:05:15,469 --> 00:05:19,430
controllers loaded on run time which is

00:05:17,479 --> 00:05:21,889
pretty cool but now let's talk about the

00:05:19,430 --> 00:05:23,509
controllers in itself there's this new

00:05:21,889 --> 00:05:24,310
thing in Ross tools which is called life

00:05:23,509 --> 00:05:27,289
cycle

00:05:24,310 --> 00:05:29,180
light cycle notes and what it actually

00:05:27,289 --> 00:05:32,419
means now if you look at our possible

00:05:29,180 --> 00:05:33,860
controller interface now they all have a

00:05:32,419 --> 00:05:36,650
life cycle with it which means there's a

00:05:33,860 --> 00:05:39,080
state machine attached to Eve to every

00:05:36,650 --> 00:05:40,819
node we can easily now overwrite the

00:05:39,080 --> 00:05:42,830
states of it so we can configure these

00:05:40,819 --> 00:05:44,960
nodes we can activate them stopped and

00:05:42,830 --> 00:05:47,120
clean up shut down everything which is

00:05:44,960 --> 00:05:48,620
really nice for controllers applications

00:05:47,120 --> 00:05:50,389
as well because you want to have like a

00:05:48,620 --> 00:05:54,259
deterministic execution of your

00:05:50,389 --> 00:05:55,879
controllers and so what Ross 2 gives you

00:05:54,259 --> 00:05:57,979
here in terms of life cycle is like you

00:05:55,879 --> 00:06:00,319
have a bunch of callbacks which then

00:05:57,979 --> 00:06:04,460
overwrite in your own implementation and

00:06:00,319 --> 00:06:07,039
configure your nodes as you wish quickly

00:06:04,460 --> 00:06:08,509
look into this we have a possible

00:06:07,039 --> 00:06:10,520
controller my controller which and how

00:06:08,509 --> 00:06:12,590
it's not from this public from this

00:06:10,520 --> 00:06:14,569
controller interface does all the fancy

00:06:12,590 --> 00:06:17,029
stuff with the unactivated callbacks and

00:06:14,569 --> 00:06:18,919
the clean ups and stuff but now how do

00:06:17,029 --> 00:06:21,110
we interact with these notes and for

00:06:18,919 --> 00:06:22,940
this every lifecycle know what gives you

00:06:21,110 --> 00:06:25,190
a bunch of services which attach to it

00:06:22,940 --> 00:06:26,990
and so namely if you now call Ross to

00:06:25,190 --> 00:06:29,029
service list you will see ok my

00:06:26,990 --> 00:06:32,449
controller node has now a service change

00:06:29,029 --> 00:06:34,550
state got all available States and the

00:06:32,449 --> 00:06:36,169
latest an is like cat state where we can

00:06:34,550 --> 00:06:38,479
get the current state of it and what

00:06:36,169 --> 00:06:39,409
that means now we call that service we

00:06:38,479 --> 00:06:41,809
get the response

00:06:39,409 --> 00:06:43,849
our my controller note is now by default

00:06:41,809 --> 00:06:45,559
and a nun configured state so you have

00:06:43,849 --> 00:06:50,300
to call configure or activate or

00:06:45,559 --> 00:06:52,879
whatever to get that note running and so

00:06:50,300 --> 00:06:54,969
in reality the way we look or like the

00:06:52,879 --> 00:06:56,499
way we implement it is now on the ABB

00:06:54,969 --> 00:06:59,809
like that

00:06:56,499 --> 00:07:01,849
so our controller is now configured both

00:06:59,809 --> 00:07:04,309
arms are starting going up and down as a

00:07:01,849 --> 00:07:07,399
trajectory and the moment we call then

00:07:04,309 --> 00:07:12,259
deactivate and that one one controller

00:07:07,399 --> 00:07:14,539
note you will see that the arm stops so

00:07:12,259 --> 00:07:17,209
now it's deactivated the right arm

00:07:14,539 --> 00:07:19,669
continues going up and down we call

00:07:17,209 --> 00:07:25,069
activate again on the left node and they

00:07:19,669 --> 00:07:26,809
both go up the same on the right and so

00:07:25,069 --> 00:07:28,999
eventually if we call deactivate on

00:07:26,809 --> 00:07:30,409
clean up we go back to our initial home

00:07:28,999 --> 00:07:34,429
position which is actually pretty cool

00:07:30,409 --> 00:07:36,679
and makes fun - so now this is pretty

00:07:34,429 --> 00:07:38,239
awesome so our robot moves we can

00:07:36,679 --> 00:07:40,669
control it but like the real fun comes

00:07:38,239 --> 00:07:45,229
actually now with with Adam when when he

00:07:40,669 --> 00:07:47,719
puts a wish all right thanks Carsten so

00:07:45,229 --> 00:07:51,379
I was working in parallel at the same

00:07:47,719 --> 00:07:53,539
time as Carsten and his intern were

00:07:51,379 --> 00:07:55,490
working on this Ross control side of

00:07:53,539 --> 00:07:57,740
things I was working on a pick-and-place

00:07:55,490 --> 00:07:59,509
pipeline using Ross too and the

00:07:57,740 --> 00:08:01,009
motivation for this was to show that

00:07:59,509 --> 00:08:02,089
Ross twos features are really starting

00:08:01,009 --> 00:08:03,439
to get in place to the point where we

00:08:02,089 --> 00:08:05,599
can start to build some fun or cool

00:08:03,439 --> 00:08:07,959
applications with them and as with any

00:08:05,599 --> 00:08:09,860
integration pick-and-place tile demo

00:08:07,959 --> 00:08:11,539
there's gonna be a lot of integration

00:08:09,860 --> 00:08:13,099
work like remapping topics sort of thing

00:08:11,539 --> 00:08:14,509
there's also gonna be some new

00:08:13,099 --> 00:08:16,369
functionality when when there are things

00:08:14,509 --> 00:08:19,489
that you want to build that that aren't

00:08:16,369 --> 00:08:21,110
quite there yet so without further ado

00:08:19,489 --> 00:08:25,489
let's build a simple pick-and-place demo

00:08:21,110 --> 00:08:27,649
in Ross - we're gonna start off as any

00:08:25,489 --> 00:08:29,959
good pick-and-place pipeline does with

00:08:27,649 --> 00:08:33,110
perception so we use the Astro depth

00:08:29,959 --> 00:08:36,469
camera because it's available and you

00:08:33,110 --> 00:08:38,659
can buy one right now and we decided to

00:08:36,469 --> 00:08:40,789
use the driver that we already worked on

00:08:38,659 --> 00:08:42,769
for the turtlebot demo so you saw

00:08:40,789 --> 00:08:45,199
earlier yesterday Chris Islands that

00:08:42,769 --> 00:08:47,449
described the turtlebot - demo running

00:08:45,199 --> 00:08:49,850
in Ross - with cartographer that used

00:08:47,449 --> 00:08:51,950
this exact camera the aura Beck Astra so

00:08:49,850 --> 00:08:55,820
we were able to use the same

00:08:51,950 --> 00:08:57,110
driver and take the point cloud and RGB

00:08:55,820 --> 00:08:59,480
data and send it directly to our object

00:08:57,110 --> 00:09:01,370
detector so the object detector is new

00:08:59,480 --> 00:09:03,050
we built it purely in Ross 2 and it's a

00:09:01,370 --> 00:09:04,490
simplified version of the line modeler

00:09:03,050 --> 00:09:05,810
it actually does use line mode under the

00:09:04,490 --> 00:09:08,360
hood but it's simpler than the

00:09:05,810 --> 00:09:10,610
implementation provided that you might

00:09:08,360 --> 00:09:11,600
find on github today so line mod if

00:09:10,610 --> 00:09:13,490
you're not familiar with it is a

00:09:11,600 --> 00:09:15,199
template matching vision algorithm which

00:09:13,490 --> 00:09:17,660
means you train on either real or

00:09:15,199 --> 00:09:19,820
virtual data we use virtual data in this

00:09:17,660 --> 00:09:21,410
case and then when you observe the real

00:09:19,820 --> 00:09:23,899
world with your camera you simply match

00:09:21,410 --> 00:09:25,100
what you've seen before to what you're

00:09:23,899 --> 00:09:28,040
seeing now and that gives you your six

00:09:25,100 --> 00:09:29,420
degree of freedom pose so if you've

00:09:28,040 --> 00:09:31,010
built vision pipelines before in Ross

00:09:29,420 --> 00:09:32,449
you know that like your computer gets

00:09:31,010 --> 00:09:34,519
really hot your fans starts spinning up

00:09:32,449 --> 00:09:36,079
and that's just that's just the nature

00:09:34,519 --> 00:09:39,740
of vision pipelines but part of that is

00:09:36,079 --> 00:09:41,570
because that as your data is passed from

00:09:39,740 --> 00:09:42,920
node to node it has to be serialized and

00:09:41,570 --> 00:09:44,540
unsterilized as it moves over the wire

00:09:42,920 --> 00:09:46,839
you can fix this to some extent with

00:09:44,540 --> 00:09:49,010
not--let's but that has other issues so

00:09:46,839 --> 00:09:52,360
this is really where we can start to

00:09:49,010 --> 00:09:53,990
apply ross to secret sauce in this case

00:09:52,360 --> 00:09:56,510
shared memory for inter-process

00:09:53,990 --> 00:09:59,060
communication so this is something is

00:09:56,510 --> 00:10:00,769
not new it's been presented before you

00:09:59,060 --> 00:10:02,300
can see there I think it was last Ross

00:10:00,769 --> 00:10:04,550
Connor possibly even to Ross Kahn's ago

00:10:02,300 --> 00:10:07,070
but what this allows you to do is as

00:10:04,550 --> 00:10:08,750
long as you have nodes running on the

00:10:07,070 --> 00:10:11,810
same machine they can actually just

00:10:08,750 --> 00:10:13,550
share memory instead of resizing and

00:10:11,810 --> 00:10:15,589
deserializing the data every single time

00:10:13,550 --> 00:10:16,910
it's passed from node to node so what

00:10:15,589 --> 00:10:18,680
this allows you to do is create a very

00:10:16,910 --> 00:10:20,120
low overhead vision pipeline because

00:10:18,680 --> 00:10:22,250
you're not copying that data over and

00:10:20,120 --> 00:10:24,019
over and over again and we actually saw

00:10:22,250 --> 00:10:26,930
that with this applying inter process

00:10:24,019 --> 00:10:29,930
communication over the pipeline allowed

00:10:26,930 --> 00:10:33,019
our pipeline to run much faster than it

00:10:29,930 --> 00:10:35,000
would otherwise so this is the first

00:10:33,019 --> 00:10:36,649
piece of Ross to magic that we applied

00:10:35,000 --> 00:10:37,910
and the next thing we're gonna do is we

00:10:36,649 --> 00:10:41,810
get our six degree of freedom pose and

00:10:37,910 --> 00:10:43,220
we'll send it to our robot so Ross - of

00:10:41,810 --> 00:10:45,680
course the sports multiple languages the

00:10:43,220 --> 00:10:47,449
central two nodes are our program - C++

00:10:45,680 --> 00:10:50,029
the robot interface uses you our script

00:10:47,449 --> 00:10:52,279
and it's coded in Python so multiple

00:10:50,029 --> 00:10:55,339
languages check you are five robot we

00:10:52,279 --> 00:10:57,829
can control it check alright let's add

00:10:55,339 --> 00:10:59,360
some more Ross to Ross to launch files

00:10:57,829 --> 00:11:01,130
they're written in Python instead of XML

00:10:59,360 --> 00:11:02,690
this was really fun because instead of

00:11:01,130 --> 00:11:04,070
writing a bunch of XML worrying about

00:11:02,690 --> 00:11:05,750
topic remapping and

00:11:04,070 --> 00:11:07,970
and whoops I forgot the trailing slash

00:11:05,750 --> 00:11:09,170
at the end of my XML tag we can just

00:11:07,970 --> 00:11:11,420
code and Python it's much more

00:11:09,170 --> 00:11:15,320
straightforward in my opinion and this

00:11:11,420 --> 00:11:17,780
is just works and then the whole demo

00:11:15,320 --> 00:11:19,040
runs in rust - that's all great if we

00:11:17,780 --> 00:11:21,020
want to visualize that unfortunately we

00:11:19,040 --> 00:11:24,680
don't have our viz in Ross - yet coming

00:11:21,020 --> 00:11:26,810
soon to a Ross near you right so for now

00:11:24,680 --> 00:11:28,730
we can just pass the visualization data

00:11:26,810 --> 00:11:30,860
across the Rasta bridge which has been

00:11:28,730 --> 00:11:33,170
described yesterday I believe and you

00:11:30,860 --> 00:11:36,380
can visualize it in good ol Ross one

00:11:33,170 --> 00:11:37,490
artist so this is the pipeline and we'll

00:11:36,380 --> 00:11:39,080
wrap the whole thing up in a docker

00:11:37,490 --> 00:11:39,440
container I realized I made a little

00:11:39,080 --> 00:11:41,450
mistake

00:11:39,440 --> 00:11:42,590
we we don't include the camera in the

00:11:41,450 --> 00:11:46,360
robot in the docker container

00:11:42,590 --> 00:11:48,710
this next version of docker maybe but

00:11:46,360 --> 00:11:50,480
this is so it's easier to share and also

00:11:48,710 --> 00:11:53,050
if you go look at the github which will

00:11:50,480 --> 00:11:55,070
share a link at the end you can see that

00:11:53,050 --> 00:11:59,120
you can see kind of how you would

00:11:55,070 --> 00:12:01,040
provision a Ross to machine with all of

00:11:59,120 --> 00:12:01,880
these capabilities in docker so we

00:12:01,040 --> 00:12:04,910
thought that was a useful thing to

00:12:01,880 --> 00:12:07,340
provide as well anime testing easy ok so

00:12:04,910 --> 00:12:09,080
you may have noticed we don't have a

00:12:07,340 --> 00:12:10,700
gripper yet right how are we gonna pick

00:12:09,080 --> 00:12:12,140
things up with nova gripper okay so we

00:12:10,700 --> 00:12:13,760
realized halfway through the summer oh

00:12:12,140 --> 00:12:16,820
shoot we don't actually have any

00:12:13,760 --> 00:12:18,650
grippers so how do you make a pick and

00:12:16,820 --> 00:12:20,450
place down without a gripper okay good

00:12:18,650 --> 00:12:24,100
question so we came up with the idea of

00:12:20,450 --> 00:12:30,110
the pinky robot so we present to you our

00:12:24,100 --> 00:12:31,580
ur5 the picky robot it does not like the

00:12:30,110 --> 00:12:31,940
hole or it doesn't it likes whole-wheat

00:12:31,580 --> 00:12:33,770
pasta

00:12:31,940 --> 00:12:37,120
only so we're just gonna take that cup

00:12:33,770 --> 00:12:37,120
of noodle and just get rid of it

00:12:39,160 --> 00:12:42,709
see the detections on the upper left

00:12:41,450 --> 00:12:45,350
they're a little noisy but we can filter

00:12:42,709 --> 00:12:46,880
them and this was again this was trained

00:12:45,350 --> 00:12:48,560
on virtual data so it's actually pretty

00:12:46,880 --> 00:12:50,000
decent for being trained on a CAD model

00:12:48,560 --> 00:12:53,750
that I whipped up pretty quickly and

00:12:50,000 --> 00:12:56,089
then there we go and then we have

00:12:53,750 --> 00:12:57,230
another view here this one we call this

00:12:56,089 --> 00:12:58,220
the cat version we can set the

00:12:57,230 --> 00:13:03,740
preferences so this will just push

00:12:58,220 --> 00:13:07,670
everything off the table and you can see

00:13:03,740 --> 00:13:08,990
on the left you can that's that's Ross

00:13:07,670 --> 00:13:10,279
one RVs running and then the three

00:13:08,990 --> 00:13:12,950
windows on the right those are all

00:13:10,279 --> 00:13:17,990
running directly out of Ross - opening

00:13:12,950 --> 00:13:19,279
up those OpenCV windows one of the thing

00:13:17,990 --> 00:13:22,880
I want to mention because I have time I

00:13:19,279 --> 00:13:24,320
think we are we're using a new proposed

00:13:22,880 --> 00:13:25,820
standard for vision messages so we're

00:13:24,320 --> 00:13:27,920
actually detecting the objects using the

00:13:25,820 --> 00:13:29,360
line mode detector and then we have a

00:13:27,920 --> 00:13:32,529
standard that we would love for people

00:13:29,360 --> 00:13:35,240
to expand upon and use for actually

00:13:32,529 --> 00:13:37,160
defining how objects are passed across

00:13:35,240 --> 00:13:38,690
the network in Ross because when you

00:13:37,160 --> 00:13:40,310
move from your vision pipeline to your

00:13:38,690 --> 00:13:41,630
manipulation pipeline often that's not

00:13:40,310 --> 00:13:43,579
well defined every lab has their own

00:13:41,630 --> 00:13:45,290
standards for that kind of thing so we'd

00:13:43,579 --> 00:13:46,370
like to unify everyone under one common

00:13:45,290 --> 00:13:48,290
banner so that's another thing you can

00:13:46,370 --> 00:13:52,279
look at if you're interested and we use

00:13:48,290 --> 00:13:55,519
it in this demo okay so that's the picky

00:13:52,279 --> 00:13:56,990
robot pick-and-place demo and kind of

00:13:55,519 --> 00:13:58,579
what did the key takeaways of all this

00:13:56,990 --> 00:14:00,529
well we have all these cool Ross -

00:13:58,579 --> 00:14:03,079
features right and we talked about some

00:14:00,529 --> 00:14:04,070
of them today and I think people a lot

00:14:03,079 --> 00:14:05,690
of people are wondering some people are

00:14:04,070 --> 00:14:07,160
looking forward to Ross - some people

00:14:05,690 --> 00:14:08,540
have already said they're using Ross -

00:14:07,160 --> 00:14:11,240
or they're targeting Ross - for the

00:14:08,540 --> 00:14:13,130
robot next year I think what we want to

00:14:11,240 --> 00:14:14,269
say is like if if these are the the

00:14:13,130 --> 00:14:18,079
features of Ross - that you're

00:14:14,269 --> 00:14:21,949
interested in using it works so in some

00:14:18,079 --> 00:14:23,690
sense a timeline is is looking past

00:14:21,949 --> 00:14:25,040
where we already are but where we

00:14:23,690 --> 00:14:29,390
already are has a lot of the features

00:14:25,040 --> 00:14:31,250
that many people need and I as as we saw

00:14:29,390 --> 00:14:33,320
I built that new object detector so as

00:14:31,250 --> 00:14:34,699
you see these new leaf packages that

00:14:33,320 --> 00:14:35,630
maybe don't have any dependencies yet

00:14:34,699 --> 00:14:37,699
but they you need for your particular

00:14:35,630 --> 00:14:40,010
application you can work to move those

00:14:37,699 --> 00:14:42,790
specific packages - Ross - as needed but

00:14:40,010 --> 00:14:45,050
the core we think is already there so

00:14:42,790 --> 00:14:47,120
with that we'd like to thank some people

00:14:45,050 --> 00:14:48,890
who made this effort possible first off

00:14:47,120 --> 00:14:49,970
I'd like to thank my mentor Michaela

00:14:48,890 --> 00:14:51,800
Gattis

00:14:49,970 --> 00:14:58,490
I think Carsten would like to thank his

00:14:51,800 --> 00:15:00,500
intern Calvin gun and yeah also like our

00:14:58,490 --> 00:15:02,330
friends from ABB and Ross industrial who

00:15:00,500 --> 00:15:04,640
helped me personally to get up to speed

00:15:02,330 --> 00:15:07,220
with the AVP Yumi interface so a big

00:15:04,640 --> 00:15:09,800
shout out to this

00:15:07,220 --> 00:15:12,200
yes Oh finally thank you all listening

00:15:09,800 --> 00:15:17,000
code is available dear friends from Ross

00:15:12,200 --> 00:15:19,340
control were like yeah they hosted our

00:15:17,000 --> 00:15:22,430
code here for the Ross to control it's

00:15:19,340 --> 00:15:24,020
like it's a proof of concept go go ahead

00:15:22,430 --> 00:15:26,870
check it out it's there for visibility

00:15:24,020 --> 00:15:33,440
as every good software engineer I did

00:15:26,870 --> 00:15:35,630
write documentation not yeah go ahead be

00:15:33,440 --> 00:15:38,480
patient with it but I keep up the

00:15:35,630 --> 00:15:40,540
documentation soon so thank you thank

00:15:38,480 --> 00:15:40,540
you

00:15:44,350 --> 00:15:52,579
questions don't be shy

00:15:48,879 --> 00:15:55,879
well I'll start and actually while we're

00:15:52,579 --> 00:15:58,489
doing that you go can come on up yeah so

00:15:55,879 --> 00:16:01,399
what was the you guys both are very

00:15:58,489 --> 00:16:02,989
familiar with Ross 1 and Ross - what was

00:16:01,399 --> 00:16:04,970
the most painful thing about building

00:16:02,989 --> 00:16:11,689
this in Ross - or the most most

00:16:04,970 --> 00:16:14,059
difficult thing that's a good question

00:16:11,689 --> 00:16:15,410
so for me it was just kind of unlearning

00:16:14,059 --> 00:16:16,939
the things I already learned on Ross one

00:16:15,410 --> 00:16:18,679
I think because I wanted to use some

00:16:16,939 --> 00:16:19,939
Ross 1 paradigms and it was like well

00:16:18,679 --> 00:16:21,739
you don't actually have to do that

00:16:19,939 --> 00:16:23,089
anymore you can use the shared memory

00:16:21,739 --> 00:16:24,619
your launch files are written in Python

00:16:23,089 --> 00:16:27,499
now which is really cool but I was like

00:16:24,619 --> 00:16:28,910
I kind of miss my old XML but I don't

00:16:27,499 --> 00:16:33,160
know I think the Python is ultimately

00:16:28,910 --> 00:16:35,509
better you have anything you wanna say

00:16:33,160 --> 00:16:37,549
well one of the challenges for me

00:16:35,509 --> 00:16:39,920
personally was also that like so there's

00:16:37,549 --> 00:16:41,449
like you wanted to use a feature and

00:16:39,920 --> 00:16:43,399
then you realized oh no that's not there

00:16:41,449 --> 00:16:45,079
yet right and then so like you have to

00:16:43,399 --> 00:16:46,730
write it yourself but which is fine I

00:16:45,079 --> 00:16:48,199
mean you have to be patient you write it

00:16:46,730 --> 00:16:55,519
yourself but in the end it works on us

00:16:48,199 --> 00:16:58,309
was pretty cool maybe for custom which

00:16:55,519 --> 00:17:02,959
did yes libraries were using and if the

00:16:58,309 --> 00:17:04,870
operative system was real time I was

00:17:02,959 --> 00:17:07,760
waiting for that question

00:17:04,870 --> 00:17:09,559
we we were using a procedure but it

00:17:07,760 --> 00:17:11,209
works with both hands like was that like

00:17:09,559 --> 00:17:19,669
the default version which just comes

00:17:11,209 --> 00:17:21,679
with Ross - is it real time I think with

00:17:19,669 --> 00:17:24,470
rose to be on a good way to providing

00:17:21,679 --> 00:17:26,600
real time capable systems right so like

00:17:24,470 --> 00:17:28,789
we have two shared in for process

00:17:26,600 --> 00:17:32,510
communication we have custom memory a

00:17:28,789 --> 00:17:33,590
locators you know it's always like you

00:17:32,510 --> 00:17:35,029
have to know what you do in the first

00:17:33,590 --> 00:17:36,649
place it's not that like you write code

00:17:35,029 --> 00:17:38,870
pull on the switch on your system is

00:17:36,649 --> 00:17:41,360
real-time it doesn't happen right so if

00:17:38,870 --> 00:17:45,399
you know what you do I think Ross - is

00:17:41,360 --> 00:17:45,399
on the right track for this

00:17:46,840 --> 00:17:50,190

YouTube URL: https://www.youtube.com/watch?v=SPNHD0Za_Zc


