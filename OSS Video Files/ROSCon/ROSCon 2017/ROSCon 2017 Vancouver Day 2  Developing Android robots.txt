Title: ROSCon 2017 Vancouver Day 2  Developing Android robots
Publication date: 2021-03-28
Playlist: ROSCon 2017
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2017 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License
Captions: 
	00:00:00,140 --> 00:00:19,650
hello everyone good morning all right

00:00:17,090 --> 00:00:22,320
hello everyone good morning my name is

00:00:19,650 --> 00:00:24,720
Kwon an electronics engineer from one

00:00:22,320 --> 00:00:27,269
Osiris in South America it looks a lot

00:00:24,720 --> 00:00:30,060
to mention who Leon which is actually my

00:00:27,269 --> 00:00:35,670
boss and pushed this work forward

00:00:30,060 --> 00:00:37,079
I work for a cumin a which we've held

00:00:35,670 --> 00:00:39,390
quadrants also in when Osiris in

00:00:37,079 --> 00:00:40,980
Argentina but part of our team is also

00:00:39,390 --> 00:00:42,870
distributed throughout the country and

00:00:40,980 --> 00:00:45,210
also in Paraguay also in South America

00:00:42,870 --> 00:00:46,920
we provide the software consultancy

00:00:45,210 --> 00:00:49,500
services to our customers which are

00:00:46,920 --> 00:00:51,449
mainly in the US and I would also like

00:00:49,500 --> 00:00:54,000
to mention intermetallics which is a

00:00:51,449 --> 00:00:55,680
company in Belgium and well a small

00:00:54,000 --> 00:00:58,949
column a small company called Google

00:00:55,680 --> 00:01:02,730
perhaps you know it which both helped us

00:00:58,949 --> 00:01:04,409
with this project so the purpose of this

00:01:02,730 --> 00:01:07,290
talk is to answer you some questions

00:01:04,409 --> 00:01:09,270
such as why would you choose Android as

00:01:07,290 --> 00:01:11,640
an alternative platform to win a robot

00:01:09,270 --> 00:01:13,740
on what are the tools of libraries that

00:01:11,640 --> 00:01:16,710
are allowed there and how much will it

00:01:13,740 --> 00:01:18,810
cost you and in terms of development

00:01:16,710 --> 00:01:20,790
hours and effort we will also be

00:01:18,810 --> 00:01:23,040
presenting tango bot which is a robot

00:01:20,790 --> 00:01:26,280
that is powered by a single Android

00:01:23,040 --> 00:01:31,220
device and which is a ready to use

00:01:26,280 --> 00:01:33,630
example so the first reason is

00:01:31,220 --> 00:01:35,130
technological if you take a look back at

00:01:33,630 --> 00:01:37,140
the first Android phone and they

00:01:35,130 --> 00:01:38,460
currently available Android phones we

00:01:37,140 --> 00:01:40,110
will see that there is a huge

00:01:38,460 --> 00:01:43,799
improvement in terms of processing power

00:01:40,110 --> 00:01:46,740
a memory size sensor capabilities

00:01:43,799 --> 00:01:50,369
networking capabilities and I could just

00:01:46,740 --> 00:01:52,470
use a whole talk to fill the list so

00:01:50,369 --> 00:01:55,860
this all these improvements make

00:01:52,470 --> 00:01:58,200
robotics application actually make these

00:01:55,860 --> 00:02:03,689
phones actually suitable for robotics

00:01:58,200 --> 00:02:07,640
applications the second reason is mainly

00:02:03,689 --> 00:02:09,599
social basically if you see this chart

00:02:07,640 --> 00:02:11,580
Android phones are extremely popular

00:02:09,599 --> 00:02:13,170
throughout the world and in fact this

00:02:11,580 --> 00:02:13,980
nowadays the most popular operating

00:02:13,170 --> 00:02:16,110
system if

00:02:13,980 --> 00:02:19,739
take into account both desktop and

00:02:16,110 --> 00:02:22,409
mobile devices and this is good for two

00:02:19,739 --> 00:02:23,069
reasons the first one is that the market

00:02:22,409 --> 00:02:25,709
is huge

00:02:23,069 --> 00:02:27,930
lots of millions of cell phones are sold

00:02:25,709 --> 00:02:29,580
every year and people are really used to

00:02:27,930 --> 00:02:31,379
it so it's a good opportunity for

00:02:29,580 --> 00:02:34,190
robotics together into a wild consumer

00:02:31,379 --> 00:02:37,650
market and the other reason is because

00:02:34,190 --> 00:02:39,390
this huge demand in devices pushes the

00:02:37,650 --> 00:02:42,090
manufacturers to put more and more

00:02:39,390 --> 00:02:45,450
technology into the devices so you will

00:02:42,090 --> 00:02:47,790
get the latest processors that are

00:02:45,450 --> 00:02:50,069
actually pretty efficient perhaps phone

00:02:47,790 --> 00:02:53,760
is not as powerful as the service that

00:02:50,069 --> 00:02:55,410
the pr2 had but they definitely consume

00:02:53,760 --> 00:02:57,629
much less and are much more efficient

00:02:55,410 --> 00:02:59,720
and they already have the enough

00:02:57,629 --> 00:03:02,099
processing power for your applications

00:02:59,720 --> 00:03:03,480
another interesting thing is that with

00:03:02,099 --> 00:03:04,769
the Google Play Store you'll have all

00:03:03,480 --> 00:03:06,510
the deployment system that you need

00:03:04,769 --> 00:03:08,430
which is actually really cool for

00:03:06,510 --> 00:03:13,829
distributing your software and also

00:03:08,430 --> 00:03:15,510
collecting data from your users so going

00:03:13,829 --> 00:03:17,670
to a second question how do you do this

00:03:15,510 --> 00:03:19,919
well the first obstacle that you will

00:03:17,670 --> 00:03:22,260
encounter is that well Android actually

00:03:19,919 --> 00:03:26,459
runs on Java so you won't be able to run

00:03:22,260 --> 00:03:29,010
raus packages as they are also Python

00:03:26,459 --> 00:03:30,989
packages won't be available but you

00:03:29,010 --> 00:03:34,560
actually don't need to rewrite the whole

00:03:30,989 --> 00:03:38,190
road from scratch in 2012 daemon color

00:03:34,560 --> 00:03:39,900
who I think is wrong here presented ROS

00:03:38,190 --> 00:03:43,680
Java which is a complete or

00:03:39,900 --> 00:03:45,709
implementation of Ross in Java so that

00:03:43,680 --> 00:03:48,660
will basically give you access to notes

00:03:45,709 --> 00:03:51,690
services parameters everything that you

00:03:48,660 --> 00:03:53,639
need is there you're with that you're

00:03:51,690 --> 00:03:59,430
just ready to start writing your notes

00:03:53,639 --> 00:04:01,950
and executing them on Android the second

00:03:59,430 --> 00:04:05,819
part which is also important in Ross are

00:04:01,950 --> 00:04:07,919
the libraries basically you don't have

00:04:05,819 --> 00:04:09,629
the same package availability but there

00:04:07,919 --> 00:04:11,370
are some tools that will help you cross

00:04:09,629 --> 00:04:14,730
compile packages and run them on Android

00:04:11,370 --> 00:04:16,709
a few years ago the Gauri serving who is

00:04:14,730 --> 00:04:19,530
actually my colleague percentage Rossi

00:04:16,709 --> 00:04:22,169
VP Android which is a public repository

00:04:19,530 --> 00:04:24,330
that has a recipe that will help you

00:04:22,169 --> 00:04:26,400
cross compile packages so that you can

00:04:24,330 --> 00:04:27,889
run in on android basically you just

00:04:26,400 --> 00:04:30,409
will follow this receipt

00:04:27,889 --> 00:04:33,259
you will get a list of packages

00:04:30,409 --> 00:04:36,050
cross-compiler shared objects that you

00:04:33,259 --> 00:04:37,969
can then link into your application to

00:04:36,050 --> 00:04:41,749
do so you have to write a small rubber

00:04:37,969 --> 00:04:44,270
around them which are basically so that

00:04:41,749 --> 00:04:47,599
the cross compiler is looked like a

00:04:44,270 --> 00:04:49,849
native node native notes are actually a

00:04:47,599 --> 00:04:51,800
component of first java and then you

00:04:49,849 --> 00:04:54,430
will just execute those native nodes as

00:04:51,800 --> 00:04:57,680
if they were regular rostov annals

00:04:54,430 --> 00:04:59,840
behind the scenes native notes use gni

00:04:57,680 --> 00:05:03,229
which stands for a Java native interface

00:04:59,840 --> 00:05:04,400
to call the native code so that will

00:05:03,229 --> 00:05:06,229
give you access for example to

00:05:04,400 --> 00:05:10,610
interesting packages such as Moog bass

00:05:06,229 --> 00:05:13,729
and much others also this work has had

00:05:10,610 --> 00:05:15,259
some contributions in the recent past to

00:05:13,729 --> 00:05:17,750
support for example plugin live and

00:05:15,259 --> 00:05:21,159
other interesting libraries which are

00:05:17,750 --> 00:05:23,629
certainly useful in robotics development

00:05:21,159 --> 00:05:28,039
the third term the third tool you have

00:05:23,629 --> 00:05:30,979
is maven which is basically the place to

00:05:28,039 --> 00:05:33,650
share Java libraries raw Java actually

00:05:30,979 --> 00:05:36,620
hosts one maven repository and that

00:05:33,650 --> 00:05:39,289
allows user to publish java compiler

00:05:36,620 --> 00:05:41,509
artifacts and then with that you can

00:05:39,289 --> 00:05:44,330
just include those libraries into your

00:05:41,509 --> 00:05:46,939
application just by adding simple lines

00:05:44,330 --> 00:05:51,710
to your build script another interesting

00:05:46,939 --> 00:05:53,360
fact is that we are using Gradle to

00:05:51,710 --> 00:05:56,569
build the application and that's

00:05:53,360 --> 00:05:59,270
integrated with Cal King so in the end

00:05:56,569 --> 00:06:01,610
rows Java and Android package will look

00:05:59,270 --> 00:06:06,169
just as a regular ROS package that you

00:06:01,610 --> 00:06:07,849
can build with khaki make so all this

00:06:06,169 --> 00:06:09,889
theory looks nice but perhaps you're

00:06:07,849 --> 00:06:12,110
already wondering where's the robot so

00:06:09,889 --> 00:06:14,870
let me present you a tango bot which is

00:06:12,110 --> 00:06:17,180
an Android power robot it's a turtle bot

00:06:14,870 --> 00:06:19,699
spin-off basically we have replaced the

00:06:17,180 --> 00:06:22,039
laptop for a single Android phone which

00:06:19,699 --> 00:06:24,379
does all the processing and also has all

00:06:22,039 --> 00:06:26,770
the sensors in this case we are using a

00:06:24,379 --> 00:06:29,779
tango enabled device we'll get to that

00:06:26,770 --> 00:06:33,560
because of the interesting sensors that

00:06:29,779 --> 00:06:36,019
it provides the purpose of the tango

00:06:33,560 --> 00:06:39,080
mode is a research platform and also to

00:06:36,019 --> 00:06:40,969
show that Android can drive a robot and

00:06:39,080 --> 00:06:45,469
all of the component

00:06:40,969 --> 00:06:52,610
are open-source so I would like you to

00:06:45,469 --> 00:06:55,309
show you a video about this in the video

00:06:52,610 --> 00:06:57,139
you can see well that's me I'm

00:06:55,309 --> 00:06:59,389
teleporting the road from a client

00:06:57,139 --> 00:07:01,129
application the phone that this owner

00:06:59,389 --> 00:07:03,349
robot is actually doing all the work

00:07:01,129 --> 00:07:05,809
from the client application and just

00:07:03,349 --> 00:07:08,629
visualizing the robot we are using for

00:07:05,809 --> 00:07:10,699
now an empty map which using a global

00:07:08,629 --> 00:07:11,209
map is actually something that has to be

00:07:10,699 --> 00:07:13,999
done yet

00:07:11,209 --> 00:07:16,039
but it certainly can be done those black

00:07:13,999 --> 00:07:18,049
stains are actually local obstacles that

00:07:16,039 --> 00:07:20,809
they wrote is seeing using these sensors

00:07:18,049 --> 00:07:22,789
and now all of that is the navigation

00:07:20,809 --> 00:07:25,699
stack your struggles are a bit inflated

00:07:22,789 --> 00:07:27,979
by the inflation layer of the navigation

00:07:25,699 --> 00:07:29,659
stack you can see that in the client

00:07:27,979 --> 00:07:32,479
library I also have access to the camera

00:07:29,659 --> 00:07:34,039
which is pretty interesting when I tell

00:07:32,479 --> 00:07:36,919
the robot to come back by giving it a

00:07:34,039 --> 00:07:43,059
goal you will see it's amazing dodging

00:07:36,919 --> 00:07:43,059
skills with that computer yeah awesome

00:07:50,100 --> 00:07:55,900
okay that's with the video so now we

00:07:54,160 --> 00:07:57,400
would like to review a little bit the

00:07:55,900 --> 00:07:59,620
hardware and the software components of

00:07:57,400 --> 00:08:02,760
the robot from a generic point of view

00:07:59,620 --> 00:08:05,680
any autonomous Road basically needs

00:08:02,760 --> 00:08:08,320
perception system such as sensors like

00:08:05,680 --> 00:08:10,720
cameras I am use and so on lasers

00:08:08,320 --> 00:08:12,220
whatever you want a processing unit to

00:08:10,720 --> 00:08:14,260
process all the information coming from

00:08:12,220 --> 00:08:17,800
the sensors I'm from the user input and

00:08:14,260 --> 00:08:19,630
then an actuator which is basically the

00:08:17,800 --> 00:08:22,870
mobile base to take the robot where it

00:08:19,630 --> 00:08:25,180
has to go so if we compared to the

00:08:22,870 --> 00:08:28,150
standard turtlebot we basically removed

00:08:25,180 --> 00:08:30,280
the laptop we remove the laser scan the

00:08:28,150 --> 00:08:33,580
Kinect sensor and we replace all that

00:08:30,280 --> 00:08:35,320
with a tango naval phone you actually

00:08:33,580 --> 00:08:38,169
need that tango niall phone to run on

00:08:35,320 --> 00:08:39,970
your own robot because with a usb of the

00:08:38,169 --> 00:08:42,190
phone you can actually drive whatever

00:08:39,970 --> 00:08:44,080
sensor you want to include in this case

00:08:42,190 --> 00:08:45,730
we thought it was convenient because we

00:08:44,080 --> 00:08:47,530
already had all the sensors we needed in

00:08:45,730 --> 00:08:54,880
a single device so we actually didn't

00:08:47,530 --> 00:08:56,800
need to add another device so from if we

00:08:54,880 --> 00:08:59,980
now dive into the software you will see

00:08:56,800 --> 00:09:02,260
that from top to bottom we have first

00:08:59,980 --> 00:09:04,000
the application which is basically an

00:09:02,260 --> 00:09:05,770
Android user interface to show the

00:09:04,000 --> 00:09:08,440
status of the robot and so on to

00:09:05,770 --> 00:09:11,170
configure some things as such as the

00:09:08,440 --> 00:09:12,880
roastmaster URI and so on and it's also

00:09:11,170 --> 00:09:15,220
an old launcher in ROS Java you can

00:09:12,880 --> 00:09:17,410
launch as many notes as you want from a

00:09:15,220 --> 00:09:20,020
single application so it's a sort of big

00:09:17,410 --> 00:09:22,360
launch file then it goes the navigation

00:09:20,020 --> 00:09:25,420
stack the drivers for our sensors and

00:09:22,360 --> 00:09:29,680
the drivers for the my advice let's take

00:09:25,420 --> 00:09:31,600
a look these components one by one from

00:09:29,680 --> 00:09:32,740
a generic point of view the navigation

00:09:31,600 --> 00:09:35,980
stack for those who are not familiar

00:09:32,740 --> 00:09:37,870
with that basically takes sensor input

00:09:35,980 --> 00:09:40,210
and user input and translates it into

00:09:37,870 --> 00:09:43,900
velocity commands that the mobile base

00:09:40,210 --> 00:09:46,720
will interpret and execute the

00:09:43,900 --> 00:09:49,420
navigation stack is pretty complex piece

00:09:46,720 --> 00:09:51,700
of software and it's pretty flexible and

00:09:49,420 --> 00:09:53,620
configurable it has many components such

00:09:51,700 --> 00:09:55,840
as cost maps planners and recovery

00:09:53,620 --> 00:09:56,620
behaviors and recording all that from

00:09:55,840 --> 00:09:59,520
scratch in Java

00:09:56,620 --> 00:10:02,050
is actually a big piece of work and

00:09:59,520 --> 00:10:04,779
nobody wants to do that

00:10:02,050 --> 00:10:07,899
so this is a perfect use case scenario

00:10:04,779 --> 00:10:10,929
for Ross CBP Android the move based

00:10:07,899 --> 00:10:13,029
package that is regular for Ross can be

00:10:10,929 --> 00:10:15,249
cross-compile and then wrapped into a

00:10:13,029 --> 00:10:17,170
native node which can be executed by the

00:10:15,249 --> 00:10:19,600
tango bot application so in this case

00:10:17,170 --> 00:10:22,600
what we only have to do is write all

00:10:19,600 --> 00:10:24,309
those theme wrappers cross-compile the

00:10:22,600 --> 00:10:29,079
package and then we are ready to use it

00:10:24,309 --> 00:10:31,329
in our application so now we like to

00:10:29,079 --> 00:10:32,769
give a few words about tango which is

00:10:31,329 --> 00:10:35,920
the perception system that we are using

00:10:32,769 --> 00:10:38,049
in this case tango is a software and

00:10:35,920 --> 00:10:40,629
hardware stack that has three key

00:10:38,049 --> 00:10:42,850
features which are motion tracking area

00:10:40,629 --> 00:10:44,679
learning and that perception this is all

00:10:42,850 --> 00:10:46,480
about giving the device capabilities to

00:10:44,679 --> 00:10:48,999
understand its surroundings a little bit

00:10:46,480 --> 00:10:51,279
better than regular devices so with

00:10:48,999 --> 00:10:54,339
motion tracking you will get visual

00:10:51,279 --> 00:10:56,769
inertia la flama Tree era learning will

00:10:54,339 --> 00:10:59,079
complement that by learning features in

00:10:56,769 --> 00:11:01,209
the environment and localizing against

00:10:59,079 --> 00:11:03,459
those features and the perception is so

00:11:01,209 --> 00:11:05,679
it's all about the shape of the objects

00:11:03,459 --> 00:11:07,449
that are around the device and that will

00:11:05,679 --> 00:11:10,540
help you in particular with obstacle

00:11:07,449 --> 00:11:13,119
avoidance so how does all this relate

00:11:10,540 --> 00:11:14,740
with cross well our friends at Newton

00:11:13,119 --> 00:11:17,559
metallics developed an application that

00:11:14,740 --> 00:11:21,220
actually gets the data from tango and

00:11:17,559 --> 00:11:25,119
streaming it into rows by publish need

00:11:21,220 --> 00:11:26,769
to regular rows topics the interesting

00:11:25,119 --> 00:11:29,110
fact about this application which you

00:11:26,769 --> 00:11:30,819
can also download from the Play Store if

00:11:29,110 --> 00:11:33,189
you have a tiny little device is that

00:11:30,819 --> 00:11:35,230
the core is actually a roast node that

00:11:33,189 --> 00:11:37,929
we could extract and then include in our

00:11:35,230 --> 00:11:40,269
application it's also in our Java mavens

00:11:37,929 --> 00:11:41,559
repository so to include in an

00:11:40,269 --> 00:11:44,350
application you just have to add the

00:11:41,559 --> 00:11:47,019
dependency in your build script so only

00:11:44,350 --> 00:11:49,660
with that you have access to all the

00:11:47,019 --> 00:11:52,419
tango information in rows nodes in rows

00:11:49,660 --> 00:11:56,470
nodes and run Rose topics and messages

00:11:52,419 --> 00:11:59,049
and so that's how we get a point clouds

00:11:56,470 --> 00:12:01,509
the posts of the robot and also laser

00:11:59,049 --> 00:12:06,669
scans which is pretty much everything we

00:12:01,509 --> 00:12:08,439
need for the perception system going one

00:12:06,669 --> 00:12:10,269
step down we have the raw base driver

00:12:08,439 --> 00:12:12,939
which is also an open source component

00:12:10,269 --> 00:12:15,160
called base controller it basically

00:12:12,939 --> 00:12:15,860
translates the output of the navigation

00:12:15,160 --> 00:12:18,230
stack

00:12:15,860 --> 00:12:20,630
which are twist commands into serial

00:12:18,230 --> 00:12:24,620
commands we can feed into a robot using

00:12:20,630 --> 00:12:27,470
the USB and that's a pretty simple

00:12:24,620 --> 00:12:31,459
component for now it supports a kabuki

00:12:27,470 --> 00:12:33,320
basis husky and I wrote create bases we

00:12:31,459 --> 00:12:35,750
haven't integrated that part into the

00:12:33,320 --> 00:12:41,870
tangled up like a huge applications yet

00:12:35,750 --> 00:12:44,630
but it can be done certainly and then I

00:12:41,870 --> 00:12:46,760
would like to talk about the next steps

00:12:44,630 --> 00:12:49,820
as you have seen in the video we are

00:12:46,760 --> 00:12:53,360
still using an empty map so the plan is

00:12:49,820 --> 00:12:56,930
to sound a sometim add a local map to

00:12:53,360 --> 00:12:58,940
use it and to navigate with for that we

00:12:56,930 --> 00:13:01,730
could use standard G mapping algorithms

00:12:58,940 --> 00:13:04,700
by using the laser scan provided by the

00:13:01,730 --> 00:13:06,800
tango roses trim Europe but we could

00:13:04,700 --> 00:13:09,230
also use some tango features to build

00:13:06,800 --> 00:13:11,570
and navigate a map that's also available

00:13:09,230 --> 00:13:13,310
in the tango Rose node we haven't

00:13:11,570 --> 00:13:15,589
integrated yet into the Tanglewood

00:13:13,310 --> 00:13:18,920
application another interesting feature

00:13:15,589 --> 00:13:22,370
is to add more mobile basis to the

00:13:18,920 --> 00:13:26,570
supported ones such as turtle o3 and so

00:13:22,370 --> 00:13:29,000
on you are all welcome to try out the

00:13:26,570 --> 00:13:30,920
cover tango bot and perhaps submit a

00:13:29,000 --> 00:13:32,660
pull request if you find anything expand

00:13:30,920 --> 00:13:34,880
these features and so on all this all

00:13:32,660 --> 00:13:41,089
the code is open source and it's already

00:13:34,880 --> 00:13:43,089
public in github so I would like to give

00:13:41,089 --> 00:13:46,160
you some closing thoughts about all this

00:13:43,089 --> 00:13:48,050
when you are using Android to develop

00:13:46,160 --> 00:13:51,529
robots you'll find some challenges which

00:13:48,050 --> 00:13:53,690
are typically associated with limited

00:13:51,529 --> 00:13:56,630
package availability and perhaps well

00:13:53,690 --> 00:13:59,420
having to use multiple technologies such

00:13:56,630 --> 00:14:01,070
as multiple build systems perhaps cross

00:13:59,420 --> 00:14:02,660
compiling packages and all of that

00:14:01,070 --> 00:14:04,399
perhaps it's a little bit confusing at

00:14:02,660 --> 00:14:06,140
first but the good part is that there

00:14:04,399 --> 00:14:08,510
are plenty of tutorials around and we

00:14:06,140 --> 00:14:10,459
have some experience with it and we also

00:14:08,510 --> 00:14:12,589
have tango Otis a good starting point so

00:14:10,459 --> 00:14:15,949
everything is documented out there you

00:14:12,589 --> 00:14:19,570
you can just check it out the advantages

00:14:15,949 --> 00:14:22,820
are that the trend keeps on and on and

00:14:19,570 --> 00:14:24,860
it indicates that in the future hundred

00:14:22,820 --> 00:14:27,440
phones will have even more technology

00:14:24,860 --> 00:14:29,390
and will still be even more popular and

00:14:27,440 --> 00:14:31,280
that's a great opportunity for robot

00:14:29,390 --> 00:14:33,880
to get into a while consumer market and

00:14:31,280 --> 00:14:35,840
also make use of all that technology

00:14:33,880 --> 00:14:37,250
another good thing is that you have

00:14:35,840 --> 00:14:39,380
tools already you don't have to write

00:14:37,250 --> 00:14:41,830
anything from everything from scratch in

00:14:39,380 --> 00:14:44,510
Java you can use wrote Java you have

00:14:41,830 --> 00:14:47,060
cross-compiled packages and so on so

00:14:44,510 --> 00:14:49,040
there's a lot of knowledge and things

00:14:47,060 --> 00:14:52,430
that are already out there to get

00:14:49,040 --> 00:14:54,610
started with so thank you very much for

00:14:52,430 --> 00:14:57,860
your time this is a picture of our team

00:14:54,610 --> 00:14:59,570
mostly up to date in Argentina and we

00:14:57,860 --> 00:15:02,330
are really happy to help if you need

00:14:59,570 --> 00:15:05,720
anything with Android and robotics

00:15:02,330 --> 00:15:21,610
development and I think it's now time

00:15:05,720 --> 00:15:25,070
for questions thank you questions yes I

00:15:21,610 --> 00:15:26,600
have a question about Java because the

00:15:25,070 --> 00:15:28,820
last time I used it like one or two

00:15:26,600 --> 00:15:30,620
years ago my experience is that the

00:15:28,820 --> 00:15:33,590
Maven represent area was like half a

00:15:30,620 --> 00:15:35,990
year beyond the status of the apt

00:15:33,590 --> 00:15:37,460
wrapper for Ubuntu so some messy

00:15:35,990 --> 00:15:39,500
definitions changed and I could not

00:15:37,460 --> 00:15:43,040
compile the workspace for things half a

00:15:39,500 --> 00:15:46,190
year so did this change to better well

00:15:43,040 --> 00:15:49,250
in fact we are actually maintaining ROS

00:15:46,190 --> 00:15:50,840
Java in acumen we are doing out the best

00:15:49,250 --> 00:15:53,570
server we can we are also spending some

00:15:50,840 --> 00:15:56,060
time to maintaining that solve all those

00:15:53,570 --> 00:15:58,600
kind of issues if you now open an issue

00:15:56,060 --> 00:16:02,840
some of us will actually respond to it

00:15:58,600 --> 00:16:05,240
yeah it has is some issues but today it

00:16:02,840 --> 00:16:07,730
does it so it's this is not in fact the

00:16:05,240 --> 00:16:12,680
only project I've been working with with

00:16:07,730 --> 00:16:15,530
ROS Java it does it so if you find

00:16:12,680 --> 00:16:18,740
anything it can be solved hasn't been

00:16:15,530 --> 00:16:20,020
accepted like the official Ross message

00:16:18,740 --> 00:16:25,330
generator

00:16:20,020 --> 00:16:28,010
yeah that's not exactly official but

00:16:25,330 --> 00:16:31,070
perhaps my boss can answer that question

00:16:28,010 --> 00:16:33,020
better yeah we have other people here

00:16:31,070 --> 00:16:36,100
like more official can probably answer

00:16:33,020 --> 00:16:38,510
to but it's there it's it's the only

00:16:36,100 --> 00:16:40,880
Java implementation that is widely used

00:16:38,510 --> 00:16:41,690
it's like anything else in Ross it's

00:16:40,880 --> 00:16:42,950
open source

00:16:41,690 --> 00:16:46,550
it's the best

00:16:42,950 --> 00:16:48,290
can do as a community so if you want to

00:16:46,550 --> 00:16:49,610
know which is the right one to use I

00:16:48,290 --> 00:16:51,710
think it's this one if you are building

00:16:49,610 --> 00:16:55,280
a mandroid I can tell you that with

00:16:51,710 --> 00:17:00,710
security we need you to help to make it

00:16:55,280 --> 00:17:06,860
better and more official that way hope

00:17:00,710 --> 00:17:07,940
that answers the question as you what do

00:17:06,860 --> 00:17:10,610
you recommend if somebody wants to

00:17:07,940 --> 00:17:12,620
contribute into this ecosystem should

00:17:10,610 --> 00:17:15,890
they be taking things that are in C++

00:17:12,620 --> 00:17:17,630
and NDK compiling them over and wrapping

00:17:15,890 --> 00:17:21,680
them or rewriting in Java what do you

00:17:17,630 --> 00:17:23,870
recommend I think that depends on the

00:17:21,680 --> 00:17:26,900
case if you have a complex piece of

00:17:23,870 --> 00:17:29,150
software perhaps it's easier to add it

00:17:26,900 --> 00:17:31,730
to the receive to cross compile it as

00:17:29,150 --> 00:17:33,320
another package that can be done like

00:17:31,730 --> 00:17:37,280
the receive that I talked about the

00:17:33,320 --> 00:17:39,710
recipient a repo actually well has a

00:17:37,280 --> 00:17:41,690
list of fixed packages that are cross

00:17:39,710 --> 00:17:44,000
compile but you can Al could add

00:17:41,690 --> 00:17:45,800
whatever you want there so that's also

00:17:44,000 --> 00:17:48,290
you can make a contribution there

00:17:45,800 --> 00:17:51,560
perhaps if the package is really simple

00:17:48,290 --> 00:17:55,760
it is worth writing it on Java so that

00:17:51,560 --> 00:17:58,420
would depend on the case I would say all

00:17:55,760 --> 00:18:03,369
right well thank you very much

00:17:58,420 --> 00:18:03,369

YouTube URL: https://www.youtube.com/watch?v=gD4KPu_1h48


