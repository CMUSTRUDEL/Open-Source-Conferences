Title: ROSCon 2017 Vancouver Day 2  Determinism in ROS â€“ or when things break  sometimes   and how to fix i
Publication date: 2021-03-28
Playlist: ROSCon 2017
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2017 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License
Captions: 
	00:00:00,890 --> 00:00:08,189
all right good morning everybody my name

00:00:06,480 --> 00:00:11,130
is Inga Luke Cibola from Bosch corporate

00:00:08,189 --> 00:00:14,309
research and I will be talking about

00:00:11,130 --> 00:00:18,750
something which is probably not so

00:00:14,309 --> 00:00:20,670
familiar in this community and it's a

00:00:18,750 --> 00:00:22,590
bit more than just acquiring Europe but

00:00:20,670 --> 00:00:26,160
it's more like designing it so that you

00:00:22,590 --> 00:00:29,310
don't have to debug so much but first

00:00:26,160 --> 00:00:32,099
maybe what's what's this determinism in

00:00:29,310 --> 00:00:34,829
robotic software what's this about this

00:00:32,099 --> 00:00:37,649
is probably not so familiar so one one

00:00:34,829 --> 00:00:39,450
thing is what we often hear when we look

00:00:37,649 --> 00:00:45,180
at robotics is that it worked for the

00:00:39,450 --> 00:00:47,340
video so it works now and well let's

00:00:45,180 --> 00:00:49,430
just say that for if you really want to

00:00:47,340 --> 00:00:52,469
go into productive system cell systems

00:00:49,430 --> 00:00:55,140
make your customers happy that that's

00:00:52,469 --> 00:00:57,239
not gonna cut it the system should

00:00:55,140 --> 00:01:00,600
behave the same way every time you use

00:00:57,239 --> 00:01:04,290
it and that's what what we understand is

00:01:00,600 --> 00:01:07,140
a simplified version of determinism so

00:01:04,290 --> 00:01:08,880
for this talk I would like first to give

00:01:07,140 --> 00:01:11,010
you a little bit more of an introduction

00:01:08,880 --> 00:01:13,380
to what kind of problems we can

00:01:11,010 --> 00:01:16,350
encounter when the system is not

00:01:13,380 --> 00:01:18,450
deterministic and I will also say what I

00:01:16,350 --> 00:01:20,460
exactly mean by determinism because the

00:01:18,450 --> 00:01:24,180
scientific definition of that is maybe a

00:01:20,460 --> 00:01:27,720
little bit too strong so to do that

00:01:24,180 --> 00:01:30,390
after that I will explain a little bit

00:01:27,720 --> 00:01:33,960
about how Ross does things internally so

00:01:30,390 --> 00:01:36,689
to put the determinism and stuff into

00:01:33,960 --> 00:01:38,460
perspective and and also give you some

00:01:36,689 --> 00:01:41,130
information for designing your systems

00:01:38,460 --> 00:01:44,040
will outline some common practices how

00:01:41,130 --> 00:01:45,689
people handle these issues and also

00:01:44,040 --> 00:01:49,049
outline a couple of packages that can

00:01:45,689 --> 00:01:50,640
help you and then I will shortly look at

00:01:49,049 --> 00:01:52,619
measurements actually I will show

00:01:50,640 --> 00:01:57,149
measurement throughout and then at the

00:01:52,619 --> 00:02:00,600
end I show you how to get those so this

00:01:57,149 --> 00:02:02,040
is just the the outline so first time to

00:02:00,600 --> 00:02:06,290
finish the motivation background and

00:02:02,040 --> 00:02:09,440
then the intro right so

00:02:06,290 --> 00:02:11,750
the by-the-book definition of a

00:02:09,440 --> 00:02:14,900
deterministic system is some system that

00:02:11,750 --> 00:02:16,640
will always produce the same output when

00:02:14,900 --> 00:02:21,410
starting conditions and inputs are the

00:02:16,640 --> 00:02:25,640
same so for robotics that's often

00:02:21,410 --> 00:02:28,730
problematic because the we have

00:02:25,640 --> 00:02:33,560
randomized algorithms and machine

00:02:28,730 --> 00:02:36,800
learning things which on something else

00:02:33,560 --> 00:02:40,130
sends us just their state so what we are

00:02:36,800 --> 00:02:42,680
mostly interested in is if you take a

00:02:40,130 --> 00:02:46,400
step back from the algorithms and look

00:02:42,680 --> 00:02:48,590
at deterministic execution so the goal

00:02:46,400 --> 00:02:50,900
is that our algorithms are called in the

00:02:48,590 --> 00:02:53,480
right order then what they do internally

00:02:50,900 --> 00:02:54,950
might or might not be deterministic but

00:02:53,480 --> 00:02:57,550
you know as long as they call it in the

00:02:54,950 --> 00:03:00,890
right order that's already a big step

00:02:57,550 --> 00:03:04,370
and the other part which is one thing

00:03:00,890 --> 00:03:07,130
which is quite problematic for us as

00:03:04,370 --> 00:03:09,800
deterministic communication because as

00:03:07,130 --> 00:03:10,610
you all know Ross uses TCP communication

00:03:09,800 --> 00:03:12,320
by default

00:03:10,610 --> 00:03:14,900
that means everything goes through the

00:03:12,320 --> 00:03:16,790
colonel wants this is the best effort

00:03:14,900 --> 00:03:19,730
type communication you have very little

00:03:16,790 --> 00:03:22,400
guarantees on that and again here we use

00:03:19,730 --> 00:03:25,580
the slightly simplified a goal we just

00:03:22,400 --> 00:03:29,989
say if we have a communication link

00:03:25,580 --> 00:03:33,980
between a and B the communication should

00:03:29,989 --> 00:03:39,800
be always either occur before B execute

00:03:33,980 --> 00:03:41,600
or after B execute and this is how

00:03:39,800 --> 00:03:46,040
exactly what that means maybe will

00:03:41,600 --> 00:03:47,660
become clear later right so why do are

00:03:46,040 --> 00:03:50,180
we actually interested in that why why

00:03:47,660 --> 00:03:52,610
should to care right I mean actually

00:03:50,180 --> 00:03:55,130
when I give this talk to gave this talk

00:03:52,610 --> 00:03:57,200
in the RUS industrial context a couple

00:03:55,130 --> 00:03:59,330
of times and sometimes people come up to

00:03:57,200 --> 00:04:02,750
me and say hey you know our systems work

00:03:59,330 --> 00:04:04,430
why should we care and I said and I said

00:04:02,750 --> 00:04:08,360
to them are you really sure that your

00:04:04,430 --> 00:04:10,250
system works all the time and if you say

00:04:08,360 --> 00:04:12,170
many many cases this might not be so

00:04:10,250 --> 00:04:14,480
important but this example here is like

00:04:12,170 --> 00:04:16,329
this robots moving to the left and you

00:04:14,480 --> 00:04:19,340
see there's a person coming there and

00:04:16,329 --> 00:04:22,090
you know we had better be sure

00:04:19,340 --> 00:04:24,530
that D person C robot can't stop in time

00:04:22,090 --> 00:04:26,660
particularly you know in this situation

00:04:24,530 --> 00:04:29,900
it's unloaded but this robot can carry

00:04:26,660 --> 00:04:31,370
250 kilos of payload and you know plus

00:04:29,900 --> 00:04:33,169
some weight for the robot you really

00:04:31,370 --> 00:04:35,780
want wouldn't want to hit a human with

00:04:33,169 --> 00:04:38,090
that so in essence what you want issue

00:04:35,780 --> 00:04:40,040
and sure is that this situation you know

00:04:38,090 --> 00:04:42,800
the robot s is red light on it means it

00:04:40,040 --> 00:04:45,290
stopped and so the person can pass and

00:04:42,800 --> 00:04:48,410
then the robot will do that so how do we

00:04:45,290 --> 00:04:49,010
usually do that we say okay how can I be

00:04:48,410 --> 00:04:52,850
certain of that

00:04:49,010 --> 00:04:55,700
I have obstacle avoidance it's being in

00:04:52,850 --> 00:04:58,100
robots for ages every mobile robot has

00:04:55,700 --> 00:05:00,710
obstacle avoidance but how does it work

00:04:58,100 --> 00:05:03,590
so what do we need first of all we need

00:05:00,710 --> 00:05:06,169
sensors sensors do you know actually

00:05:03,590 --> 00:05:08,330
detect the obstacle and and the question

00:05:06,169 --> 00:05:11,990
is how often do I get data from my

00:05:08,330 --> 00:05:13,970
sensors and what's the delay of the

00:05:11,990 --> 00:05:16,880
sensor so that's I need to know that

00:05:13,970 --> 00:05:18,740
then I have an environment model because

00:05:16,880 --> 00:05:21,139
I can't see everything if you few

00:05:18,740 --> 00:05:24,200
sensors fuse prior information like

00:05:21,139 --> 00:05:29,330
where was the robot when my sensor data

00:05:24,200 --> 00:05:32,930
was taken I then have to reply you know

00:05:29,330 --> 00:05:34,580
break drive around it whatever and you

00:05:32,930 --> 00:05:36,919
know of course I need to be sure that my

00:05:34,580 --> 00:05:40,280
actuation system actually does what I

00:05:36,919 --> 00:05:44,270
wanted to do and I need to combine this

00:05:40,280 --> 00:05:46,760
and trustworthy manner so for the

00:05:44,270 --> 00:05:48,950
purposes of this talk my focus will be

00:05:46,760 --> 00:05:50,690
on the last item here because all the

00:05:48,950 --> 00:05:52,070
other stuff that's fairly well known you

00:05:50,690 --> 00:05:54,260
know we have methods for that we

00:05:52,070 --> 00:05:56,060
understand them fairly well but you know

00:05:54,260 --> 00:06:01,780
actually combining them all in a working

00:05:56,060 --> 00:06:05,200
system that's still a challenge and to

00:06:01,780 --> 00:06:09,169
just want to give you this image here

00:06:05,200 --> 00:06:13,729
something to drink so what is this this

00:06:09,169 --> 00:06:16,610
is a look at the Ross navigation stack

00:06:13,729 --> 00:06:19,130
and the move pace in particular and what

00:06:16,610 --> 00:06:22,010
I did was I looked at you know I get a

00:06:19,130 --> 00:06:24,470
laser scan from my laser scanner it gets

00:06:22,010 --> 00:06:28,340
into the move pace and then the move

00:06:24,470 --> 00:06:29,960
pace needs to out put your reaction to

00:06:28,340 --> 00:06:32,570
that like maybe drive around an obstacle

00:06:29,960 --> 00:06:33,260
and I took a measurement of how long

00:06:32,570 --> 00:06:36,380
that takes

00:06:33,260 --> 00:06:39,830
and as you can see maybe I hope you can

00:06:36,380 --> 00:06:41,840
see that I marked it like the the this

00:06:39,830 --> 00:06:45,380
takes some time right so the processing

00:06:41,840 --> 00:06:48,950
time in the move pace and here on this

00:06:45,380 --> 00:06:50,630
image we see at the on the x-axis is the

00:06:48,950 --> 00:06:52,700
elapsed time of the experiment and the

00:06:50,630 --> 00:06:55,190
y-axis is the time it takes for the move

00:06:52,700 --> 00:06:57,800
pace to react to the laser scan and what

00:06:55,190 --> 00:06:59,750
you can see is that this varies a lot so

00:06:57,800 --> 00:07:02,210
at the in the best instance we have a

00:06:59,750 --> 00:07:03,680
reaction to the laser scan at 11

00:07:02,210 --> 00:07:06,470
milliseconds after the move pace

00:07:03,680 --> 00:07:07,850
received it and in the worst case we

00:07:06,470 --> 00:07:09,890
have a two hundred thirty five

00:07:07,850 --> 00:07:12,710
milliseconds after the move price

00:07:09,890 --> 00:07:15,320
received it and what we can also see is

00:07:12,710 --> 00:07:18,080
that here seem to be these these stable

00:07:15,320 --> 00:07:25,040
periods where we have a certain reaction

00:07:18,080 --> 00:07:27,260
time but it jumps hmm and so the first

00:07:25,040 --> 00:07:29,840
thing that people are familiar with the

00:07:27,260 --> 00:07:31,580
move place might be wondering is you

00:07:29,840 --> 00:07:34,310
know the move pace runs a trend Hertz

00:07:31,580 --> 00:07:36,860
control loop so there should be at most

00:07:34,310 --> 00:07:41,180
100 milliseconds reaction time right if

00:07:36,860 --> 00:07:42,770
you miss you assume that but and so this

00:07:41,180 --> 00:07:46,040
is true here in this example the move

00:07:42,770 --> 00:07:48,170
pace in this example the outputs a

00:07:46,040 --> 00:07:50,210
command every hundred milliseconds plus

00:07:48,170 --> 00:07:52,190
or minus a couple milliseconds for

00:07:50,210 --> 00:07:54,650
planning delay and jitter but the thing

00:07:52,190 --> 00:07:56,840
is this planning command is not always

00:07:54,650 --> 00:08:00,500
based on the latest sensor data

00:07:56,840 --> 00:08:04,160
sometimes the cost map integrates the

00:08:00,500 --> 00:08:05,780
latest sensor data after the commands

00:08:04,160 --> 00:08:08,330
already output and that's why we get

00:08:05,780 --> 00:08:10,400
these these reaction times and so that's

00:08:08,330 --> 00:08:12,260
sort of the running example that I will

00:08:10,400 --> 00:08:15,380
use throughout the talk to give you an

00:08:12,260 --> 00:08:18,920
idea of what what this is all about okay

00:08:15,380 --> 00:08:21,830
so what what are causes for that first a

00:08:18,920 --> 00:08:24,380
sensor data processing we often see bad

00:08:21,830 --> 00:08:26,120
time stamps in sensor data and we also

00:08:24,380 --> 00:08:29,870
often see that people don't use real

00:08:26,120 --> 00:08:31,640
time the process is to receive sensor

00:08:29,870 --> 00:08:33,680
data even when the data arrives at a

00:08:31,640 --> 00:08:36,470
fairly high rate this can lead to lost

00:08:33,680 --> 00:08:38,360
data and everybody who uses a Kinect or

00:08:36,470 --> 00:08:40,250
a free neck where the free neck drivers

00:08:38,360 --> 00:08:43,310
will have seen messages like I lost the

00:08:40,250 --> 00:08:44,840
data and then we have sampling effects I

00:08:43,310 --> 00:08:46,850
will explain that a little bit later

00:08:44,840 --> 00:08:48,380
also in one more detail but

00:08:46,850 --> 00:08:50,660
what this means is that we have

00:08:48,380 --> 00:08:53,720
different threats running asynchronously

00:08:50,660 --> 00:08:56,300
to one another and they communicate and

00:08:53,720 --> 00:08:58,850
one needs an input from the from the

00:08:56,300 --> 00:09:01,220
prior one but it actually runs before it

00:08:58,850 --> 00:09:02,720
receives the input and so sometimes it

00:09:01,220 --> 00:09:04,430
runs before it receives the info and

00:09:02,720 --> 00:09:06,050
sometimes runs after it receives the

00:09:04,430 --> 00:09:10,360
employed so this is sort of like

00:09:06,050 --> 00:09:13,790
sampling continuous signal in non

00:09:10,360 --> 00:09:16,940
equidistant intervals so and this is

00:09:13,790 --> 00:09:20,589
what we call sampling effect great

00:09:16,940 --> 00:09:23,480
so just to also give some perspective I

00:09:20,589 --> 00:09:26,630
will this is not applicable to all

00:09:23,480 --> 00:09:29,029
robotic systems I will this is most

00:09:26,630 --> 00:09:30,620
important for things where you know the

00:09:29,029 --> 00:09:32,870
output depends on the input which is

00:09:30,620 --> 00:09:35,180
always almost always true and it's also

00:09:32,870 --> 00:09:36,949
for dynamic environments you know when

00:09:35,180 --> 00:09:40,519
the environment actually changes fairly

00:09:36,949 --> 00:09:42,920
quickly and I'm also when the you have

00:09:40,519 --> 00:09:44,779
can't predict very well and I also

00:09:42,920 --> 00:09:47,720
assume a typical raw system which is

00:09:44,779 --> 00:09:51,949
running a Linux s multiple nodes and you

00:09:47,720 --> 00:09:54,380
know you have typical bus systems and I

00:09:51,949 --> 00:09:56,810
will in my talk everything I say is

00:09:54,380 --> 00:09:59,360
focused on the critical loop like mostly

00:09:56,810 --> 00:10:01,130
the reaction loop it not not everything

00:09:59,360 --> 00:10:03,290
in your system really has to take care

00:10:01,130 --> 00:10:04,910
of this of these aspects I mean it's

00:10:03,290 --> 00:10:07,910
good if it does but it's also quite a

00:10:04,910 --> 00:10:10,699
bit of effort so let's just say you

00:10:07,910 --> 00:10:12,079
should do this these kinds of you should

00:10:10,699 --> 00:10:16,130
apply this knowledge mostly to the

00:10:12,079 --> 00:10:18,259
critical loop at least at least right so

00:10:16,130 --> 00:10:20,329
a little bit of background on Ross

00:10:18,259 --> 00:10:21,980
I probably have seen something like this

00:10:20,329 --> 00:10:24,380
it's not on the wiki but it's fairly

00:10:21,980 --> 00:10:26,689
well-known they see so there are

00:10:24,380 --> 00:10:28,579
multiple threats within a row cpp node

00:10:26,689 --> 00:10:30,410
we have a network threat which

00:10:28,579 --> 00:10:33,139
asynchronously reads and writes to the

00:10:30,410 --> 00:10:36,769
network there's a time of threat we know

00:10:33,139 --> 00:10:37,850
which manages all the timers and both of

00:10:36,769 --> 00:10:40,790
these threats

00:10:37,850 --> 00:10:43,220
they put callback pointers into the

00:10:40,790 --> 00:10:45,230
callback queue and then there's a spin

00:10:43,220 --> 00:10:46,880
thread on the side which always takes in

00:10:45,230 --> 00:10:51,019
used item from the callback queue and

00:10:46,880 --> 00:10:54,139
executes it and then on the bottom there

00:10:51,019 --> 00:10:55,850
the TF has its own thread this is so

00:10:54,139 --> 00:10:58,160
that you can wait for transform without

00:10:55,850 --> 00:10:59,980
blocking I mean you can disable that

00:10:58,160 --> 00:11:01,960
actually but it's online

00:10:59,980 --> 00:11:04,810
so that's that's the number of threats

00:11:01,960 --> 00:11:06,310
that you have in your CPP and then in

00:11:04,810 --> 00:11:07,810
the callback you to give a little bit

00:11:06,310 --> 00:11:09,790
more information about that so the

00:11:07,810 --> 00:11:11,950
callback queue is a sequential queue has

00:11:09,790 --> 00:11:13,510
no priority so anything I mean there's

00:11:11,950 --> 00:11:17,290
people working that but by default it

00:11:13,510 --> 00:11:21,190
doesn't and so it has a reference for to

00:11:17,290 --> 00:11:23,590
a certain message and a subscription

00:11:21,190 --> 00:11:27,070
queue you know subscription queue is

00:11:23,590 --> 00:11:29,170
allocated per cell per topic and per

00:11:27,070 --> 00:11:31,180
call back to that topic so if you have

00:11:29,170 --> 00:11:32,470
like two callbacks to the scan topic

00:11:31,180 --> 00:11:37,060
then you will have two subscription

00:11:32,470 --> 00:11:38,980
queues and so what and this is also it's

00:11:37,060 --> 00:11:42,310
quite interesting and that if you have

00:11:38,980 --> 00:11:44,260
multiple messages being waiting waiting

00:11:42,310 --> 00:11:45,940
to process be processed in your callback

00:11:44,260 --> 00:11:48,790
use I will refer to the same

00:11:45,940 --> 00:11:50,110
subscription queue object but in the

00:11:48,790 --> 00:11:53,140
subscription queue object there's

00:11:50,110 --> 00:11:57,070
another queue where the messages are

00:11:53,140 --> 00:11:59,440
inserted in order and then whenever the

00:11:57,070 --> 00:12:01,000
subscription queue object comes to the

00:11:59,440 --> 00:12:03,100
top of the callback you and gets

00:12:01,000 --> 00:12:05,290
processed by the spin thread the topmost

00:12:03,100 --> 00:12:07,840
item will be taken from it and being

00:12:05,290 --> 00:12:10,450
purchased and then it's it's done and

00:12:07,840 --> 00:12:11,980
then the next reference a bit further

00:12:10,450 --> 00:12:15,280
down in the callback queue will process

00:12:11,980 --> 00:12:16,720
the other items right and the size of

00:12:15,280 --> 00:12:18,520
the subscription Q is defined by the

00:12:16,720 --> 00:12:23,080
SUBSCRIBE call the queue size argument

00:12:18,520 --> 00:12:25,990
and the other thing I said and one thing

00:12:23,080 --> 00:12:27,940
you should notice is that there the

00:12:25,990 --> 00:12:30,640
subscription queue can be limited right

00:12:27,940 --> 00:12:32,200
and if you have an item sitting in the

00:12:30,640 --> 00:12:34,900
callback queue waiting to be processed

00:12:32,200 --> 00:12:37,330
and subscription queue is full and you

00:12:34,900 --> 00:12:39,730
have another message coming in it will

00:12:37,330 --> 00:12:41,530
replace the oldest are not replaced but

00:12:39,730 --> 00:12:43,840
it will kick out the oldest object in

00:12:41,530 --> 00:12:46,720
the queue and put the new item at the

00:12:43,840 --> 00:12:48,730
end but it won't add a new entry into

00:12:46,720 --> 00:12:51,370
the callback queue it will keep the

00:12:48,730 --> 00:12:53,350
existing entry Nicole thank you only

00:12:51,370 --> 00:12:55,590
when there's a new item added then it

00:12:53,350 --> 00:12:58,540
will add a new item so this can lead to

00:12:55,590 --> 00:13:00,490
newer messages being earlier in the

00:12:58,540 --> 00:13:06,520
callback you just something to keep in

00:13:00,490 --> 00:13:10,090
mind right I think you should also also

00:13:06,520 --> 00:13:11,620
know if you have two callbacks assigned

00:13:10,090 --> 00:13:12,690
to the same topic or more than one

00:13:11,620 --> 00:13:15,270
callback and

00:13:12,690 --> 00:13:21,270
and there will be processed in order

00:13:15,270 --> 00:13:24,240
there of their subscription okay so the

00:13:21,270 --> 00:13:29,130
next thing up is you know almost across

00:13:24,240 --> 00:13:31,140
systems run on Linux and so as we saw

00:13:29,130 --> 00:13:33,570
raw cpp internally has a number of

00:13:31,140 --> 00:13:34,860
threats already we also have multi might

00:13:33,570 --> 00:13:37,500
have multiple nodes we have even more

00:13:34,860 --> 00:13:39,870
threats so all of these threats are

00:13:37,500 --> 00:13:41,340
scheduled by the Linux scheduler and a

00:13:39,870 --> 00:13:45,090
Linux scheduler as you might know has a

00:13:41,340 --> 00:13:46,830
hierarchy of scheduling approaches the

00:13:45,090 --> 00:13:48,480
highest one is the real-time scheduler

00:13:46,830 --> 00:13:50,550
which is a priority based ranked view

00:13:48,480 --> 00:13:52,740
but that's only used if you take

00:13:50,550 --> 00:13:55,890
explicit measures the one that's used by

00:13:52,740 --> 00:13:58,110
default is the Fair scheduler and the

00:13:55,890 --> 00:14:01,530
peer scheduler tries doesn't have any

00:13:58,110 --> 00:14:04,020
notion of importance it doesn't know

00:14:01,530 --> 00:14:07,320
that you know your motor controller

00:14:04,020 --> 00:14:10,560
drive control loop it's more important

00:14:07,320 --> 00:14:12,570
for example than your symbolic planner

00:14:10,560 --> 00:14:16,290
or something like that what it does it

00:14:12,570 --> 00:14:19,970
tries to allocate fair amounts of

00:14:16,290 --> 00:14:23,100
processing time to all the processes

00:14:19,970 --> 00:14:25,050
yeah so I think I'm getting a little bit

00:14:23,100 --> 00:14:27,210
behind time here I'm trying to speed up

00:14:25,050 --> 00:14:29,130
anyway what I'm just saying is that you

00:14:27,210 --> 00:14:31,140
should be aware that the fair scheduler

00:14:29,130 --> 00:14:34,290
doesn't have any notion of priority and

00:14:31,140 --> 00:14:35,820
that's what you if you really need fixed

00:14:34,290 --> 00:14:37,650
priority processing you need to really

00:14:35,820 --> 00:14:39,240
use a real-time scheduler and the

00:14:37,650 --> 00:14:41,820
real-time scheduler again in the Linux

00:14:39,240 --> 00:14:44,790
kernel is not really real time and we'll

00:14:41,820 --> 00:14:49,410
give you an example so first of all this

00:14:44,790 --> 00:14:54,620
is wake up latency and so the do you

00:14:49,410 --> 00:14:54,620
actually see my mouse yeah maybe not

00:14:57,530 --> 00:15:07,560
anyway let's see here so here on the

00:15:04,590 --> 00:15:08,910
left hand side those are scheduled

00:15:07,560 --> 00:15:10,860
that's the reaction time so I have a

00:15:08,910 --> 00:15:13,320
loop every two minute microseconds I try

00:15:10,860 --> 00:15:15,570
to activate it and that's the the wakeup

00:15:13,320 --> 00:15:17,430
time it takes from the point in activate

00:15:15,570 --> 00:15:20,400
it until it actually runs so for

00:15:17,430 --> 00:15:23,250
real-time processes under load this is

00:15:20,400 --> 00:15:25,580
all vile running stress test this is

00:15:23,250 --> 00:15:27,800
below ten microseconds on the average

00:15:25,580 --> 00:15:30,920
for an unreal time processes between 50

00:15:27,800 --> 00:15:34,730
and 60 microseconds on a core i7 so

00:15:30,920 --> 00:15:37,070
fairly powerful machine but what we also

00:15:34,730 --> 00:15:40,280
see we have significant outliers so we

00:15:37,070 --> 00:15:42,230
do have air down here this is

00:15:40,280 --> 00:15:44,840
microseconds so here two milliseconds

00:15:42,230 --> 00:15:48,050
for six milliseconds so we see that

00:15:44,840 --> 00:15:51,260
there are these outliers here in the

00:15:48,050 --> 00:15:52,670
histogram so what what I'm what I'm

00:15:51,260 --> 00:15:54,950
trying to say with that is that you

00:15:52,670 --> 00:15:56,780
can't expect that you your process runs

00:15:54,950 --> 00:15:58,700
as soon as it is ready there will be

00:15:56,780 --> 00:16:01,430
delays and the route delays can be

00:15:58,700 --> 00:16:04,400
significant they can and we can this is

00:16:01,430 --> 00:16:07,310
a ten-second example if you run for a

00:16:04,400 --> 00:16:09,020
couple of minutes or hours we see bigger

00:16:07,310 --> 00:16:13,130
delays particularly if system is

00:16:09,020 --> 00:16:15,800
stressed and that's why you want to use

00:16:13,130 --> 00:16:18,890
Linux with RT preempt this is the reason

00:16:15,800 --> 00:16:21,440
for that is the kernel subsystem it can

00:16:18,890 --> 00:16:24,170
block the real-time processes in the

00:16:21,440 --> 00:16:26,510
vanilla kernel so if you want to do like

00:16:24,170 --> 00:16:28,820
what we did some testing on that so if

00:16:26,510 --> 00:16:30,530
you have UDP traffic for example it can

00:16:28,820 --> 00:16:34,190
easily get these five millisecond delays

00:16:30,530 --> 00:16:36,590
if people access progress and a stress

00:16:34,190 --> 00:16:39,290
testing environment which is probably

00:16:36,590 --> 00:16:40,850
rare but it could happen then you even

00:16:39,290 --> 00:16:43,160
for real-time process if you see up to

00:16:40,850 --> 00:16:46,070
60 milliseconds delay so use the

00:16:43,160 --> 00:16:48,200
real-time preamp patch that's where you

00:16:46,070 --> 00:16:52,010
can get it we're doing about in all of

00:16:48,200 --> 00:16:54,290
our systems right and well I will skip

00:16:52,010 --> 00:16:58,100
that we would like some community

00:16:54,290 --> 00:16:59,720
information but cacey so let's look at

00:16:58,100 --> 00:17:02,060
timestamp time stamping is the first

00:16:59,720 --> 00:17:04,070
thing you would you will do when you lay

00:17:02,060 --> 00:17:06,680
this data comes in time stamping is

00:17:04,070 --> 00:17:08,930
important for merging data and what we

00:17:06,680 --> 00:17:10,760
often see is people do this kind of loop

00:17:08,930 --> 00:17:12,350
in their drivers they wait for a sensor

00:17:10,760 --> 00:17:13,790
data they read it and then they take the

00:17:12,350 --> 00:17:16,880
system time and that's the timestamp

00:17:13,790 --> 00:17:18,320
well that's a problem because if you

00:17:16,880 --> 00:17:20,180
look at time if you look at what's

00:17:18,320 --> 00:17:22,070
happening in the sensor first there's

00:17:20,180 --> 00:17:23,630
some acquisition in the sensor then a

00:17:22,070 --> 00:17:25,880
sensor does some internal processing

00:17:23,630 --> 00:17:27,890
which can be significant for cameras and

00:17:25,880 --> 00:17:31,130
stuff then is a transmission from the

00:17:27,890 --> 00:17:33,170
sensor device to the PC the kernel read

00:17:31,130 --> 00:17:35,780
the kernel schedules of userspace

00:17:33,170 --> 00:17:37,120
process and then it wakes up so what we

00:17:35,780 --> 00:17:39,110
want for

00:17:37,120 --> 00:17:41,570
you know in the middle of the

00:17:39,110 --> 00:17:44,390
acquisition integral but what we get if

00:17:41,570 --> 00:17:47,810
we do the above is some time back there

00:17:44,390 --> 00:17:51,460
and that can easily be 30 40 50 100

00:17:47,810 --> 00:17:54,260
millisecond depending on your system so

00:17:51,460 --> 00:17:58,700
so and also I'll should also say the

00:17:54,260 --> 00:18:00,770
delay is not necessarily constant some

00:17:58,700 --> 00:18:02,570
some drivers will you see that people

00:18:00,770 --> 00:18:04,580
are subtracting offset to account for

00:18:02,570 --> 00:18:06,680
the transmission and all that but all of

00:18:04,580 --> 00:18:10,460
these steps here well maybe with the

00:18:06,680 --> 00:18:12,020
exception of acquisition can be variable

00:18:10,460 --> 00:18:13,370
length so you can't just subtract

00:18:12,020 --> 00:18:15,230
something

00:18:13,370 --> 00:18:17,150
well there's multiple approaches to

00:18:15,230 --> 00:18:19,850
remedy that one is the sender with a

00:18:17,150 --> 00:18:21,320
clock so either the sensor has a clock

00:18:19,850 --> 00:18:23,540
or you can attach it to a clock line

00:18:21,320 --> 00:18:24,200
then the sensor data includes the

00:18:23,540 --> 00:18:27,770
timestamp

00:18:24,200 --> 00:18:29,330
if you do that and you know okay what

00:18:27,770 --> 00:18:32,180
which point in time does the timestamp

00:18:29,330 --> 00:18:33,860
refer to and of processing beginning of

00:18:32,180 --> 00:18:36,520
processing middle of something like that

00:18:33,860 --> 00:18:38,660
and how is the clock synchronized and

00:18:36,520 --> 00:18:41,290
then there's clocks and clock

00:18:38,660 --> 00:18:43,640
misalignment handling and drift so and

00:18:41,290 --> 00:18:45,770
this gets worse if you need multiple

00:18:43,640 --> 00:18:49,070
sensors so how do you synchronize clocks

00:18:45,770 --> 00:18:51,650
well if you have a big sensor with a

00:18:49,070 --> 00:18:53,750
microcontroller in it you can use well

00:18:51,650 --> 00:18:57,080
if you're between multiple machines NTP

00:18:53,750 --> 00:18:58,880
which can do millisecond accuracy as you

00:18:57,080 --> 00:19:01,970
have on the local box you can precision

00:18:58,880 --> 00:19:03,470
time with microsecond accuracy if you

00:19:01,970 --> 00:19:06,590
have your own hardware you can use a

00:19:03,470 --> 00:19:09,380
clock line many real-time bus systems

00:19:06,590 --> 00:19:15,440
include clock doing and but yeah well

00:19:09,380 --> 00:19:18,020
that's I should add one other item here

00:19:15,440 --> 00:19:21,470
but you know that's that's all high-end

00:19:18,020 --> 00:19:23,690
in many senses you don't have that so

00:19:21,470 --> 00:19:25,220
what you then get is you have some clock

00:19:23,690 --> 00:19:28,220
misalignment between your sensor and

00:19:25,220 --> 00:19:31,280
your PC and you need to handle that and

00:19:28,220 --> 00:19:32,870
this offset will also drift that's

00:19:31,280 --> 00:19:35,930
something that many people don't

00:19:32,870 --> 00:19:40,310
another verify or not don't see the

00:19:35,930 --> 00:19:43,700
significance but the thing is yeah the

00:19:40,310 --> 00:19:47,090
thing is the real-time clock on these

00:19:43,700 --> 00:19:50,110
systems is never really accurate

00:19:47,090 --> 00:19:52,510
there's quartz in there which has

00:19:50,110 --> 00:19:55,000
frequency which is not usually the exact

00:19:52,510 --> 00:19:56,740
frequency and then this frequency also

00:19:55,000 --> 00:19:59,170
differs with temperature and sometimes

00:19:56,740 --> 00:20:01,000
to supply voltage and also on and this

00:19:59,170 --> 00:20:02,980
is a systematic error so it really adds

00:20:01,000 --> 00:20:04,809
up so it's not like the many people

00:20:02,980 --> 00:20:06,309
expect okay maybe there's an error but

00:20:04,809 --> 00:20:09,160
it will be sometimes positive sometimes

00:20:06,309 --> 00:20:11,650
negative so it evens averages out but

00:20:09,160 --> 00:20:15,880
this is not the case the drift is a

00:20:11,650 --> 00:20:18,660
systematic error and it will increase so

00:20:15,880 --> 00:20:21,670
and we see the the example here by Olson

00:20:18,660 --> 00:20:23,799
if you have turning 90 degrees per

00:20:21,670 --> 00:20:25,870
second which is actually not that fast

00:20:23,799 --> 00:20:28,630
and you have object 210 meters distance

00:20:25,870 --> 00:20:30,700
that gives you 60 like o'clock

00:20:28,630 --> 00:20:32,799
misalignment of 10 milliseconds gives

00:20:30,700 --> 00:20:35,320
you 16 centimeters of location error and

00:20:32,799 --> 00:20:37,960
10 milliseconds on an uncompensated

00:20:35,320 --> 00:20:40,419
real-time clock can happen in just a few

00:20:37,960 --> 00:20:42,669
minutes really I mean I'm not kidding

00:20:40,419 --> 00:20:44,530
this is I mean you can improve this with

00:20:42,669 --> 00:20:46,780
better clock chips and all that but you

00:20:44,530 --> 00:20:49,840
will have to it so the approaches you

00:20:46,780 --> 00:20:53,500
need to estimate that the Olsens method

00:20:49,840 --> 00:20:55,030
is fairly easy well basically this is

00:20:53,500 --> 00:20:56,350
another visualization of the problem you

00:20:55,030 --> 00:20:58,330
have some scan here then it's

00:20:56,350 --> 00:21:02,530
transmitted to the host

00:20:58,330 --> 00:21:04,210
there's predicted systemic latency in

00:21:02,530 --> 00:21:06,820
the near future and you want to estimate

00:21:04,210 --> 00:21:10,510
that and and fairly easy method is

00:21:06,820 --> 00:21:13,000
actually to to use if you have jitter

00:21:10,510 --> 00:21:15,340
use the smallest observe offset that you

00:21:13,000 --> 00:21:19,929
ever observed and that's and you're

00:21:15,340 --> 00:21:22,270
upset and then for drift you usually

00:21:19,929 --> 00:21:24,070
need to do some calibration initially

00:21:22,270 --> 00:21:26,470
run your system up to operating

00:21:24,070 --> 00:21:28,360
temperature and then you measure the

00:21:26,470 --> 00:21:30,669
offsets over a long time and you see how

00:21:28,360 --> 00:21:32,860
it drifts and then once you have those

00:21:30,669 --> 00:21:35,410
two two items you can use them to

00:21:32,860 --> 00:21:36,910
compute a clock drift model and use this

00:21:35,410 --> 00:21:38,530
model to correct the time stamp that

00:21:36,910 --> 00:21:41,919
you're getting from the sensor this is

00:21:38,530 --> 00:21:43,179
all explained very well by Olson and the

00:21:41,919 --> 00:21:45,910
tonnage of approach is that you have a

00:21:43,179 --> 00:21:48,940
trigger a trigger means that the host

00:21:45,910 --> 00:21:51,070
sends a signal to the sensor device when

00:21:48,940 --> 00:21:53,559
the acquisition should start and this

00:21:51,070 --> 00:21:56,200
many camera cameras for example can do

00:21:53,559 --> 00:21:59,640
this software for other devices you may

00:21:56,200 --> 00:22:02,200
need to use a hardware trigger line and

00:21:59,640 --> 00:22:04,270
again if you have a software trigger you

00:22:02,200 --> 00:22:06,580
need to know the communication delay

00:22:04,270 --> 00:22:08,290
in the times of firewire cameras we knew

00:22:06,580 --> 00:22:10,090
that fairly exactly in the times of

00:22:08,290 --> 00:22:12,670
Gigabit Ethernet cameras well that's a

00:22:10,090 --> 00:22:15,940
bit harder to guess but you can measure

00:22:12,670 --> 00:22:19,120
it again and what you should also know

00:22:15,940 --> 00:22:21,070
is the particularly for high rate

00:22:19,120 --> 00:22:23,290
sensors if you don't use a real-time

00:22:21,070 --> 00:22:25,300
receiver threat there's a big chance of

00:22:23,290 --> 00:22:33,370
lost messages and you need to account

00:22:25,300 --> 00:22:36,309
for that also and well this is not so

00:22:33,370 --> 00:22:38,350
easy for this software you need a

00:22:36,309 --> 00:22:40,450
real-time process that's fairly easy and

00:22:38,350 --> 00:22:43,090
but for the hard work I usually need

00:22:40,450 --> 00:22:44,770
custom hardware and you know I've seen a

00:22:43,090 --> 00:22:47,500
couple of scientific papers which they

00:22:44,770 --> 00:22:49,809
you know this is so difficult you know

00:22:47,500 --> 00:22:51,970
and this is so big effort to integrate

00:22:49,809 --> 00:22:54,870
so we're using this hugely complicated

00:22:51,970 --> 00:22:58,179
method to estimate the clock drift

00:22:54,870 --> 00:23:01,420
seriously it's not so difficult to

00:22:58,179 --> 00:23:04,090
design hardware and you can often add

00:23:01,420 --> 00:23:06,220
this you know have an Arduino board add

00:23:04,090 --> 00:23:07,990
it to your existing sensor board and do

00:23:06,220 --> 00:23:10,840
a trigger on that it's really not that

00:23:07,990 --> 00:23:12,670
difficult and it vastly simplifies the

00:23:10,840 --> 00:23:15,070
whole term synchronization issue so

00:23:12,670 --> 00:23:16,570
that's that's why I saying this is this

00:23:15,070 --> 00:23:20,170
is my preferred solution have an

00:23:16,570 --> 00:23:22,090
explicit trigger and then you know about

00:23:20,170 --> 00:23:23,650
your system when your system - and when

00:23:22,090 --> 00:23:27,250
your sense of time someplace and that

00:23:23,650 --> 00:23:29,080
it's synchronized right okay so that's

00:23:27,250 --> 00:23:32,260
for one sensor if you have multiple

00:23:29,080 --> 00:23:33,730
sensor you need to store sukoon and if

00:23:32,260 --> 00:23:37,510
you want to process them together you

00:23:33,730 --> 00:23:39,160
need to synchronize so the simple

00:23:37,510 --> 00:23:41,380
approach is you know receive data you

00:23:39,160 --> 00:23:44,340
store it and then when some condition

00:23:41,380 --> 00:23:46,929
holds you start processing it and

00:23:44,340 --> 00:23:48,640
typical conditions for that is when you

00:23:46,929 --> 00:23:51,880
have new data from all of your sensors

00:23:48,640 --> 00:23:55,270
or when the data is some right sequence

00:23:51,880 --> 00:23:57,610
number or has right timestamps and or

00:23:55,270 --> 00:23:59,290
maybe some sometimes you have a most

00:23:57,610 --> 00:24:01,120
important sensor and whenever you get

00:23:59,290 --> 00:24:05,230
new data on that sensor then you will

00:24:01,120 --> 00:24:06,880
process the other approach is you make

00:24:05,230 --> 00:24:09,520
an explicit request to the sensor and

00:24:06,880 --> 00:24:13,750
then compute of course that blocks but

00:24:09,520 --> 00:24:15,460
maybe not so long can be useful and what

00:24:13,750 --> 00:24:16,480
we often see in browsers if people march

00:24:15,460 --> 00:24:20,080
on the timestamp

00:24:16,480 --> 00:24:21,519
and well that's why I explained all the

00:24:20,080 --> 00:24:23,859
things on how to get the right time

00:24:21,519 --> 00:24:25,629
stamp that's that's a reason for that

00:24:23,859 --> 00:24:27,909
because this is fairly easy this is also

00:24:25,629 --> 00:24:30,789
working well but of course the times I

00:24:27,909 --> 00:24:32,259
need to be correct and you should know

00:24:30,789 --> 00:24:35,739
that the message filter synchronize a

00:24:32,259 --> 00:24:38,129
note makes it's quite easy and there's

00:24:35,739 --> 00:24:40,629
also if you have multiple sensors and

00:24:38,129 --> 00:24:42,759
there's also a very common case of where

00:24:40,629 --> 00:24:45,730
you want to merge the sensor with the

00:24:42,759 --> 00:24:47,889
post to for example in a move pace to

00:24:45,730 --> 00:24:49,509
know where the robot was when the sensor

00:24:47,889 --> 00:24:52,809
message was taken there's the TF message

00:24:49,509 --> 00:24:58,029
filter for that and the TF message

00:24:52,809 --> 00:24:59,950
filter is a tricky Beast right so the

00:24:58,029 --> 00:25:02,350
purpose of that is Tata just said you

00:24:59,950 --> 00:25:03,609
know you only start processing the

00:25:02,350 --> 00:25:06,759
sensor data once you know where the

00:25:03,609 --> 00:25:08,470
robot is so you have to give it a target

00:25:06,759 --> 00:25:11,649
frame that you want to interpret the

00:25:08,470 --> 00:25:13,570
sensor data in and then it takes out the

00:25:11,649 --> 00:25:16,269
first version of that the one with

00:25:13,570 --> 00:25:18,340
version in twist EF version one which is

00:25:16,269 --> 00:25:21,879
still available and still works it does

00:25:18,340 --> 00:25:24,429
a 50 Hertz timer so what it does is you

00:25:21,879 --> 00:25:27,399
know it registers a new timer and then

00:25:24,429 --> 00:25:30,220
every 20 milliseconds it checks whether

00:25:27,399 --> 00:25:31,960
the target frame and sense of frame to

00:25:30,220 --> 00:25:34,659
target frame transformation is available

00:25:31,960 --> 00:25:36,399
so this will encourage I like just

00:25:34,659 --> 00:25:39,850
saying it you know 20 milliseconds is

00:25:36,399 --> 00:25:41,799
not too bad but there is a delay that's

00:25:39,850 --> 00:25:43,869
why in the version 2 of the message

00:25:41,799 --> 00:25:46,869
filter it uses a different approach it

00:25:43,869 --> 00:25:50,499
registers a callback with TF t F version

00:25:46,869 --> 00:25:52,960
2 does supports that and so whenever

00:25:50,499 --> 00:25:54,759
something some new sensor data comes in

00:25:52,960 --> 00:25:57,369
then it is being checked whether the

00:25:54,759 --> 00:25:58,989
transform is now available not when new

00:25:57,369 --> 00:26:01,389
sensor data comes in when you TF

00:25:58,989 --> 00:26:02,950
transform data comes in then it checks

00:26:01,389 --> 00:26:08,409
whether it now has a sensor transform

00:26:02,950 --> 00:26:10,239
and so on unfortunately it somehow does

00:26:08,409 --> 00:26:13,059
registers this callback on every new

00:26:10,239 --> 00:26:15,129
item of sensor data and you know because

00:26:13,059 --> 00:26:17,409
this is all cross thread synchronized

00:26:15,129 --> 00:26:20,799
there's a lot of mutexes going on and

00:26:17,409 --> 00:26:23,019
this is hugely expensive so if you have

00:26:20,799 --> 00:26:27,099
high rate data and that's not a good

00:26:23,019 --> 00:26:29,220
solution we could fix this actually it's

00:26:27,099 --> 00:26:32,170
not that difficult to fix

00:26:29,220 --> 00:26:33,580
but I'm wondering why that is so if

00:26:32,170 --> 00:26:35,860
somebody knows the reason for the

00:26:33,580 --> 00:26:38,350
current implementation which seems in if

00:26:35,860 --> 00:26:40,450
you know seems odd I would like to know

00:26:38,350 --> 00:26:42,310
and if nobody comes up to me and says

00:26:40,450 --> 00:26:44,380
this is done because we need it for

00:26:42,310 --> 00:26:46,870
whatever then are we gonna change it

00:26:44,380 --> 00:26:49,980
because this is really not not necessary

00:26:46,870 --> 00:26:54,270
maybe we change it for a roster right

00:26:49,980 --> 00:26:57,000
okay and so nice idea we're working on

00:26:54,270 --> 00:27:01,060
good and this is the link to

00:26:57,000 --> 00:27:04,600
documentation okay so enough enough for

00:27:01,060 --> 00:27:06,670
censors I want to explain the original

00:27:04,600 --> 00:27:07,990
example a little bit more to sampling

00:27:06,670 --> 00:27:11,170
effects in the move pace

00:27:07,990 --> 00:27:13,030
so what's sampling sampling or

00:27:11,170 --> 00:27:15,010
traditionally means a discrete

00:27:13,030 --> 00:27:17,800
measurement of a continuous signal and

00:27:15,010 --> 00:27:20,710
we often do that in regular intervals

00:27:17,800 --> 00:27:23,950
and we also sometimes called the result

00:27:20,710 --> 00:27:26,440
of that a sample and this is so as you

00:27:23,950 --> 00:27:28,900
can can guess from that this is a term

00:27:26,440 --> 00:27:33,040
that originates from analog systems

00:27:28,900 --> 00:27:37,270
which were getting digital we also use

00:27:33,040 --> 00:27:38,920
this now in our know message based

00:27:37,270 --> 00:27:40,570
systems and in the message based systems

00:27:38,920 --> 00:27:43,540
what we often have a SATA data

00:27:40,570 --> 00:27:47,680
acquisition and the use of the data are

00:27:43,540 --> 00:27:49,600
separated and and so if you do that we

00:27:47,680 --> 00:27:51,640
can this is usually done uniformity law

00:27:49,600 --> 00:27:53,380
relation and because one person writes

00:27:51,640 --> 00:27:54,760
the driver and another one writes an

00:27:53,380 --> 00:27:57,460
algorithm and there's many algorithms

00:27:54,760 --> 00:27:59,350
and that's just one driver and so we can

00:27:57,460 --> 00:28:02,460
do this in two ways either the driver

00:27:59,350 --> 00:28:04,870
can pass this on directly to the user or

00:28:02,460 --> 00:28:07,030
the driver put something into storage

00:28:04,870 --> 00:28:10,240
and then the user looks at the storage

00:28:07,030 --> 00:28:14,170
independently and if you in the second

00:28:10,240 --> 00:28:16,630
case it's fairly obvious if you consider

00:28:14,170 --> 00:28:18,400
it that you know if you put something

00:28:16,630 --> 00:28:21,160
into storage and then somebody else

00:28:18,400 --> 00:28:22,900
reads it there's a potential to read it

00:28:21,160 --> 00:28:25,030
before new data has been added to the

00:28:22,900 --> 00:28:28,630
storage if it's in regular intervals and

00:28:25,030 --> 00:28:30,670
if that happens and that's actually okay

00:28:28,630 --> 00:28:32,770
if you know if you always read it before

00:28:30,670 --> 00:28:35,140
it new data is being at it then that's

00:28:32,770 --> 00:28:36,610
fine but if sometimes you read it

00:28:35,140 --> 00:28:38,290
just before new data is being added in

00:28:36,610 --> 00:28:41,040
sometimes you read later that's what we

00:28:38,290 --> 00:28:43,450
call a sampling effect

00:28:41,040 --> 00:28:47,320
yeah we have that if you have mismatched

00:28:43,450 --> 00:28:50,860
rights then you can can get this quite

00:28:47,320 --> 00:28:54,309
often and rights are affected by

00:28:50,860 --> 00:28:56,290
scheduling so even if you have ten Hertz

00:28:54,309 --> 00:28:57,700
here and ten yards there maybe if the

00:28:56,290 --> 00:29:01,090
other ten Hertz is always delighted

00:28:57,700 --> 00:29:03,340
jitter you can get these things and so

00:29:01,090 --> 00:29:05,680
this is a visualization of that in a

00:29:03,340 --> 00:29:07,690
very simple example so what we see here

00:29:05,680 --> 00:29:10,450
is on the one side we have three

00:29:07,690 --> 00:29:13,750
different tasks and they always process

00:29:10,450 --> 00:29:15,400
and here what you see here is the orange

00:29:13,750 --> 00:29:19,630
part is where the actual computation is

00:29:15,400 --> 00:29:21,130
going on and the yellow part is where it

00:29:19,630 --> 00:29:22,570
would have been available to run but

00:29:21,130 --> 00:29:25,809
something else was running so it wasn't

00:29:22,570 --> 00:29:28,000
scheduled yet and what we see is tasks

00:29:25,809 --> 00:29:30,309
one put something to task two and task

00:29:28,000 --> 00:29:32,710
two is triggered here by that and then

00:29:30,309 --> 00:29:34,630
computes and antastic gets it and then

00:29:32,710 --> 00:29:37,210
we see in okay another one for task 1

00:29:34,630 --> 00:29:40,570
task to task three and then another one

00:29:37,210 --> 00:29:42,910
for tasks from task want to task - but

00:29:40,570 --> 00:29:47,980
then before task 3 gets a chance to run

00:29:42,910 --> 00:29:52,690
task 1 gives another thing here to task

00:29:47,980 --> 00:29:55,150
2 and then to ask reruns and so actually

00:29:52,690 --> 00:29:58,390
this intermediate result from tasked

00:29:55,150 --> 00:30:00,550
with lost and this is also another one

00:29:58,390 --> 00:30:03,309
where where these kind of scheduling

00:30:00,550 --> 00:30:05,890
judges can even if you have if you look

00:30:03,309 --> 00:30:09,100
at everything seems fine you can have

00:30:05,890 --> 00:30:12,670
these effects where some item of data is

00:30:09,100 --> 00:30:15,340
lost its lost and if you look at the

00:30:12,670 --> 00:30:17,800
move pace so the principle in turn

00:30:15,340 --> 00:30:19,809
processing stages in move pace our first

00:30:17,800 --> 00:30:22,240
received some sensor data in this case I

00:30:19,809 --> 00:30:23,620
said laser scan then you want to know

00:30:22,240 --> 00:30:26,860
where the robot was received suppose

00:30:23,620 --> 00:30:29,980
merge that then you use this to mark

00:30:26,860 --> 00:30:31,990
occupied in free space perform local

00:30:29,980 --> 00:30:34,390
obstacle avoidance and then output the

00:30:31,990 --> 00:30:37,360
velocity command and this should be in

00:30:34,390 --> 00:30:40,120
that order but if you look at how the

00:30:37,360 --> 00:30:41,320
move pace is implemented then you see

00:30:40,120 --> 00:30:45,330
that there's actually four different

00:30:41,320 --> 00:30:49,660
threats in the move page one is for

00:30:45,330 --> 00:30:51,429
reading the sensor data one is for for

00:30:49,660 --> 00:30:52,210
the cost for the local cost map one is a

00:30:51,429 --> 00:30:54,580
TF

00:30:52,210 --> 00:30:56,260
threat which

00:30:54,580 --> 00:30:58,810
it's important for synchronizing and

00:30:56,260 --> 00:31:00,370
then we have the cost there's one thread

00:30:58,810 --> 00:31:03,490
updates across mapping and another

00:31:00,370 --> 00:31:05,560
thread does the local planning and as I

00:31:03,490 --> 00:31:09,820
try it so like these these ranges here

00:31:05,560 --> 00:31:12,520
they visualize when the process could

00:31:09,820 --> 00:31:15,400
run in principle so in any of these

00:31:12,520 --> 00:31:16,930
times it could run in principle and so

00:31:15,400 --> 00:31:19,180
what this means for example the move

00:31:16,930 --> 00:31:20,890
based plan thread it has to be done

00:31:19,180 --> 00:31:26,230
before the velocity command is its

00:31:20,890 --> 00:31:27,790
output and it also has to run after

00:31:26,230 --> 00:31:30,340
receiving the post because it gets a

00:31:27,790 --> 00:31:32,620
prosumer geometry but in between those

00:31:30,340 --> 00:31:34,630
it could it could for example run

00:31:32,620 --> 00:31:36,760
between you know after receiving the

00:31:34,630 --> 00:31:39,190
post but before it's a sensor data and

00:31:36,760 --> 00:31:42,280
the post FP merged and so then it will

00:31:39,190 --> 00:31:45,160
run before the customer update and so

00:31:42,280 --> 00:31:50,650
this is the same image as before

00:31:45,160 --> 00:31:52,720
in terms of content but what we have

00:31:50,650 --> 00:31:54,550
done here is we looked at these various

00:31:52,720 --> 00:31:58,240
processing stages in the move pace and

00:31:54,550 --> 00:32:00,130
how much time do they take and so to to

00:31:58,240 --> 00:32:03,070
narrow down a little bit more of where

00:32:00,130 --> 00:32:05,410
this where this strange difference in

00:32:03,070 --> 00:32:07,420
response times is coming from and so the

00:32:05,410 --> 00:32:10,030
red line on the bottom that you see here

00:32:07,420 --> 00:32:11,590
that's the delay between when the laser

00:32:10,030 --> 00:32:13,450
data is coming in and when the post is

00:32:11,590 --> 00:32:15,910
coming in so you see that's almost

00:32:13,450 --> 00:32:18,340
always very constant but after that

00:32:15,910 --> 00:32:20,230
things start to become very different so

00:32:18,340 --> 00:32:22,080
sometimes for example as you see here in

00:32:20,230 --> 00:32:24,880
the beginning sometimes it takes a while

00:32:22,080 --> 00:32:26,650
after the sensor data is available until

00:32:24,880 --> 00:32:29,980
the cosmo is actually updated and that

00:32:26,650 --> 00:32:32,320
is because the spin thread puts it into

00:32:29,980 --> 00:32:34,360
a buffer and then the cosmic update

00:32:32,320 --> 00:32:36,430
threat has a 10 Hertz rate and takes it

00:32:34,360 --> 00:32:37,990
from the buffer so depending on what the

00:32:36,430 --> 00:32:39,940
relationship between when the spin

00:32:37,990 --> 00:32:42,730
thread puts it in and when the update

00:32:39,940 --> 00:32:45,640
thread takes it out is we can get this

00:32:42,730 --> 00:32:47,320
delay and then again the plan thread is

00:32:45,640 --> 00:32:49,450
a different thread so again we see a

00:32:47,320 --> 00:32:55,390
delay between the update and plan thread

00:32:49,450 --> 00:32:57,250
and then the gray part there is just you

00:32:55,390 --> 00:32:59,800
know the planner takes some time to

00:32:57,250 --> 00:33:01,660
compute and as we can see this time to

00:32:59,800 --> 00:33:04,240
compute for the planner that's fairly

00:33:01,660 --> 00:33:05,380
consistent so I mean this this could

00:33:04,240 --> 00:33:07,240
have been an alternative explanation

00:33:05,380 --> 00:33:09,880
right that it planning

00:33:07,240 --> 00:33:11,770
time is so different but as we can see

00:33:09,880 --> 00:33:15,400
that's not the case planning time is

00:33:11,770 --> 00:33:17,770
actually quite consistent so and we did

00:33:15,400 --> 00:33:18,970
this as I said for five runs and each of

00:33:17,770 --> 00:33:21,520
the five runs we had three different

00:33:18,970 --> 00:33:23,559
targets for the move pace to drive to so

00:33:21,520 --> 00:33:26,260
that's the data where we use you

00:33:23,559 --> 00:33:29,160
and so we see you not just delays but

00:33:26,260 --> 00:33:31,840
also this change in execution order and

00:33:29,160 --> 00:33:34,540
then the first okay first of all I

00:33:31,840 --> 00:33:36,820
should have said before that the sender

00:33:34,540 --> 00:33:38,410
rate and the controller eight person

00:33:36,820 --> 00:33:40,120
synchronized so now we did that okay I

00:33:38,410 --> 00:33:43,210
said okay let's let's run the controller

00:33:40,120 --> 00:33:44,830
at the sensor rate and this gets out

00:33:43,210 --> 00:33:49,150
quite a bit lower but you still it's

00:33:44,830 --> 00:33:54,790
very inconsistent jittery and yeah again

00:33:49,150 --> 00:33:56,500
we have this reordering and so then this

00:33:54,790 --> 00:33:59,050
is again the one from before so we

00:33:56,500 --> 00:34:02,020
refract it up and that's the result

00:33:59,050 --> 00:34:05,050
after refactoring and what you can see

00:34:02,020 --> 00:34:07,600
here is that suddenly we are getting way

00:34:05,050 --> 00:34:09,520
below fifty milliseconds and we're down

00:34:07,600 --> 00:34:12,820
here and even the planning time is

00:34:09,520 --> 00:34:15,580
reduced that's odd but that's because

00:34:12,820 --> 00:34:17,139
there's nothing else I'm entering it and

00:34:15,580 --> 00:34:19,060
if you look at this more statistically

00:34:17,139 --> 00:34:21,100
what you could so this is a distribution

00:34:19,060 --> 00:34:23,290
of the reaction time for the various

00:34:21,100 --> 00:34:25,359
parts and as we could say this custom

00:34:23,290 --> 00:34:28,750
have update here that had a really large

00:34:25,359 --> 00:34:32,260
variance before and now it's almost zero

00:34:28,750 --> 00:34:33,850
and the thing is and if you put that in

00:34:32,260 --> 00:34:35,859
numbers for before we had to mean

00:34:33,850 --> 00:34:39,040
response time from 85 milliseconds and

00:34:35,859 --> 00:34:41,879
now we have nine and it's no longer 60

00:34:39,040 --> 00:34:45,720
milliseconds standard deviation but five

00:34:41,879 --> 00:34:49,659
so and the mark next to that is bounded

00:34:45,720 --> 00:34:53,139
so this is what you can get if you look

00:34:49,659 --> 00:34:55,210
at these things with with an eye towards

00:34:53,139 --> 00:34:57,940
the sampling effects and preventing them

00:34:55,210 --> 00:35:00,670
and now I will give some ideas on and

00:34:57,940 --> 00:35:02,820
common practices on how to do that and I

00:35:00,670 --> 00:35:06,670
have two minutes left okay

00:35:02,820 --> 00:35:09,220
see right so architectural choices again

00:35:06,670 --> 00:35:11,320
just that's good because this when the

00:35:09,220 --> 00:35:13,300
day if the computations directly caused

00:35:11,320 --> 00:35:16,000
by within the callback then we call that

00:35:13,300 --> 00:35:17,590
data trigger when the actual computation

00:35:16,000 --> 00:35:20,020
is triggered prior timer we call the

00:35:17,590 --> 00:35:20,570
time trigger for time triggering what we

00:35:20,020 --> 00:35:22,930
see in wrong

00:35:20,570 --> 00:35:26,180
two different patterns one is you have

00:35:22,930 --> 00:35:28,250
well Ross timer and the other s that you

00:35:26,180 --> 00:35:31,850
have a timer loop where you call spin

00:35:28,250 --> 00:35:34,010
once and because we always like to

00:35:31,850 --> 00:35:36,200
visualize our systems what we found

00:35:34,010 --> 00:35:38,960
they're useful is to put these things

00:35:36,200 --> 00:35:40,910
make these things explicit so ordinarily

00:35:38,960 --> 00:35:42,950
a Ross notice a black box and you don't

00:35:40,910 --> 00:35:45,860
know what's going on inside so we have

00:35:42,950 --> 00:35:48,230
this small visual notation where you say

00:35:45,860 --> 00:35:51,020
okay if we put a t here that means it's

00:35:48,230 --> 00:35:53,780
a data triggered system we can also say

00:35:51,020 --> 00:35:55,820
it there's a timer inside and fef and

00:35:53,780 --> 00:35:57,350
are here that means it's a register so

00:35:55,820 --> 00:35:59,900
something is just stored for later

00:35:57,350 --> 00:36:02,380
processing and if we have this sort of

00:35:59,900 --> 00:36:06,830
data trigger system we also put the

00:36:02,380 --> 00:36:09,710
queue size and then the easiest way to

00:36:06,830 --> 00:36:11,330
achieve full determinism is have data

00:36:09,710 --> 00:36:13,850
trigger pipelines throughout you know

00:36:11,330 --> 00:36:15,740
just you know data in processing that

00:36:13,850 --> 00:36:18,800
out and do that in a pipeline and that's

00:36:15,740 --> 00:36:20,860
that's perfectly deterministic in the

00:36:18,800 --> 00:36:24,470
sense that you don't have reorderings

00:36:20,860 --> 00:36:26,120
okay so this minimizes delay if all you

00:36:24,470 --> 00:36:28,550
care about is delay that's what you

00:36:26,120 --> 00:36:31,790
should do but it maximizes jitter

00:36:28,550 --> 00:36:33,860
because all of the input jitter all of

00:36:31,790 --> 00:36:37,340
the processing time jitter will be

00:36:33,860 --> 00:36:38,930
directly passed on so it and yeah and

00:36:37,340 --> 00:36:42,500
another thing you have to keep in mind

00:36:38,930 --> 00:36:44,180
is the queue size part if you put QC 0

00:36:42,500 --> 00:36:47,420
you get everything but you can get out

00:36:44,180 --> 00:36:50,540
of memory if you don't keep up skew size

00:36:47,420 --> 00:36:52,940
one seems to be a bit frowned upon by

00:36:50,540 --> 00:36:54,800
people you know you can lose data but

00:36:52,940 --> 00:36:57,260
actually it's quite useful because if

00:36:54,800 --> 00:36:58,880
you only care about the newest data like

00:36:57,260 --> 00:37:01,100
if you want to run the laser scan not

00:36:58,880 --> 00:37:02,660
for mapping in mapping usually all the

00:37:01,100 --> 00:37:04,730
laser scans but if you want to use it

00:37:02,660 --> 00:37:08,120
for obstacle avoidance you really only

00:37:04,730 --> 00:37:09,530
need the latest laser scan and as long

00:37:08,120 --> 00:37:13,640
as your robot isn't driving really fast

00:37:09,530 --> 00:37:15,740
so that's that's quite useful and the

00:37:13,640 --> 00:37:20,180
other things are not as useful that you

00:37:15,740 --> 00:37:22,430
would think okay the other thing is if

00:37:20,180 --> 00:37:23,750
you have timers so timers should be used

00:37:22,430 --> 00:37:25,940
whenever it's more important that

00:37:23,750 --> 00:37:28,700
computation occurs on regular intervals

00:37:25,940 --> 00:37:29,670
and the absolute maximum reaction time

00:37:28,700 --> 00:37:34,410
is not so important

00:37:29,670 --> 00:37:38,940
then you should know the timer is not

00:37:34,410 --> 00:37:40,410
something which is as a global clock or

00:37:38,940 --> 00:37:42,960
anything but if you have a 50 Hertz

00:37:40,410 --> 00:37:46,319
timer it starts when you create it or

00:37:42,960 --> 00:37:48,510
when you call start and what we then see

00:37:46,319 --> 00:37:51,450
is also hardware devices often start by

00:37:48,510 --> 00:37:52,680
new you start running them when you open

00:37:51,450 --> 00:37:55,020
the driver that's when they start

00:37:52,680 --> 00:37:58,170
running so what we have found quite

00:37:55,020 --> 00:38:00,839
useful is that you have a stage where

00:37:58,170 --> 00:38:04,079
you know all the nodes start up and then

00:38:00,839 --> 00:38:06,900
after that you give a trigger signal on

00:38:04,079 --> 00:38:08,339
a topic and when the nodes received a

00:38:06,900 --> 00:38:11,400
trigger signal that's when they start

00:38:08,339 --> 00:38:12,720
the timers and because that you know of

00:38:11,400 --> 00:38:14,670
course the trigger signal could also be

00:38:12,720 --> 00:38:16,260
delayed we usually usually do that with

00:38:14,670 --> 00:38:17,760
you know putting a timestamp into the

00:38:16,260 --> 00:38:21,000
trigger signal and then it starts on a

00:38:17,760 --> 00:38:22,650
timestamp and then of course the last

00:38:21,000 --> 00:38:24,569
approach which is the one that's mostly

00:38:22,650 --> 00:38:28,049
used in Ross's explicit synchronization

00:38:24,569 --> 00:38:30,329
and you put a sequence number or time

00:38:28,049 --> 00:38:33,180
stem in the message most people do this

00:38:30,329 --> 00:38:35,730
on the timestamp but the sequence number

00:38:33,180 --> 00:38:38,010
if you have the synchronize starts that

00:38:35,730 --> 00:38:40,290
are set before then you can actually do

00:38:38,010 --> 00:38:44,640
it on a sequence number and this is

00:38:40,290 --> 00:38:46,470
quite this is also quite useful for many

00:38:44,640 --> 00:38:48,210
things also when you don't have time

00:38:46,470 --> 00:38:51,180
stems for example you can still use the

00:38:48,210 --> 00:38:52,920
sequence number and there's the Ross

00:38:51,180 --> 00:38:55,079
tool life cycle which we also backward

00:38:52,920 --> 00:38:57,000
to Ross one can help you and this is you

00:38:55,079 --> 00:38:59,700
know just so that means you have to have

00:38:57,000 --> 00:39:01,740
stamped a to you and if you have across

00:38:59,700 --> 00:39:04,530
threads you can use synchronization

00:39:01,740 --> 00:39:06,030
objects in the same process which is

00:39:04,530 --> 00:39:09,390
what we did in the move pace we just put

00:39:06,030 --> 00:39:12,930
a condition variable and of course the

00:39:09,390 --> 00:39:15,000
usual concurrency management stuff and

00:39:12,930 --> 00:39:17,700
so the last thing do you saw all these

00:39:15,000 --> 00:39:20,910
these timing measurements that I gave

00:39:17,700 --> 00:39:22,890
you earlier we have how did we do that

00:39:20,910 --> 00:39:25,460
what we did is we used instrumentation

00:39:22,890 --> 00:39:28,380
of Ross CPP we put Linux trace toolkit

00:39:25,460 --> 00:39:29,849
instrumentation in there and I can say

00:39:28,380 --> 00:39:33,299
that we're actually just working on

00:39:29,849 --> 00:39:35,099
pushing making that open source so it's

00:39:33,299 --> 00:39:36,480
it's already all as you know the

00:39:35,099 --> 00:39:38,010
management approval is being done and

00:39:36,480 --> 00:39:39,960
all that stuff I just need to you know

00:39:38,010 --> 00:39:42,059
get around to actually pushing it and

00:39:39,960 --> 00:39:43,170
get up and what we do is whenever

00:39:42,059 --> 00:39:45,089
there's a message entry

00:39:43,170 --> 00:39:46,829
in exit when there's a callback entry

00:39:45,089 --> 00:39:48,599
and exit how the cue delay and in

00:39:46,829 --> 00:39:51,540
message filters we put traces trace

00:39:48,599 --> 00:39:53,099
points and we have this small trace

00:39:51,540 --> 00:39:55,890
tools package which we will also make

00:39:53,099 --> 00:39:58,010
open source which is a generic wrapper

00:39:55,890 --> 00:40:00,450
for the Linux trace who took it so

00:39:58,010 --> 00:40:01,980
yesterday somebody used F trace for

00:40:00,450 --> 00:40:04,970
example you could also put F trace in

00:40:01,980 --> 00:40:07,380
there would just work just as well and

00:40:04,970 --> 00:40:11,130
we have a generic model for the trace

00:40:07,380 --> 00:40:14,130
data and some Python code to analyze

00:40:11,130 --> 00:40:16,079
that so if if you're interested in that

00:40:14,130 --> 00:40:18,569
getting early access and talk to me and

00:40:16,079 --> 00:40:20,069
we have well you probably can't read

00:40:18,569 --> 00:40:22,170
that sorry about it

00:40:20,069 --> 00:40:23,400
this is just some passing the experiment

00:40:22,170 --> 00:40:30,720
code to run all the stuff and make a

00:40:23,400 --> 00:40:33,750
plot okay so to summarize and almost

00:40:30,720 --> 00:40:35,010
almost some time so deterministic

00:40:33,750 --> 00:40:36,720
behavior it's not something that just

00:40:35,010 --> 00:40:38,220
happens you have to think about it you

00:40:36,720 --> 00:40:40,740
have to consider the architecture system

00:40:38,220 --> 00:40:44,010
and if if a non-deterministic system

00:40:40,740 --> 00:40:45,780
there will be you know 99% of the time

00:40:44,010 --> 00:40:47,490
your jitter and all that will be okay

00:40:45,780 --> 00:40:48,329
but then there will be a switch and then

00:40:47,490 --> 00:40:51,569
you will be in trouble

00:40:48,329 --> 00:40:55,099
I promise it and I know these things

00:40:51,569 --> 00:40:57,809
they are not rare they happen frequently

00:40:55,099 --> 00:40:59,760
and then you know one of the most

00:40:57,809 --> 00:41:02,640
important things is make sure proper x

00:40:59,760 --> 00:41:06,569
times use common merging parents and you

00:41:02,640 --> 00:41:08,400
know design measure measure and this is

00:41:06,569 --> 00:41:09,540
just a call to the community if there

00:41:08,400 --> 00:41:11,040
are people interested in this stuff

00:41:09,540 --> 00:41:13,349
please talk to me we can there's a lot

00:41:11,040 --> 00:41:17,290
of things we could do thank you a lot

00:41:13,349 --> 00:41:21,449
for attention on this dry topic I guess

00:41:17,290 --> 00:41:21,449
[Applause]

00:41:23,100 --> 00:41:26,370
thank you very much Inga that's

00:41:24,900 --> 00:41:30,150
definitely formative and we'll follow up

00:41:26,370 --> 00:41:35,460
about the TF is anyone have questions we

00:41:30,150 --> 00:41:37,740
have time for one or two awesome thank

00:41:35,460 --> 00:41:41,730
you for interesting presentation I have

00:41:37,740 --> 00:41:44,040
more down-to-earth question about usage

00:41:41,730 --> 00:41:47,610
or not usage of as techniques but for

00:41:44,040 --> 00:41:49,890
example I built robot how can I using

00:41:47,610 --> 00:41:53,160
some empirical checks how can I I

00:41:49,890 --> 00:41:56,370
determine that my robot is fairly good

00:41:53,160 --> 00:41:58,530
in this matrix like of determinism or is

00:41:56,370 --> 00:42:01,410
fairly bad do you have some kind of

00:41:58,530 --> 00:42:03,690
questionnaire where your would you check

00:42:01,410 --> 00:42:05,700
and you say okay so you don't have to

00:42:03,690 --> 00:42:07,910
apply the majority of this because in

00:42:05,700 --> 00:42:09,930
your use case robot would be a

00:42:07,910 --> 00:42:12,180
deterministic or more or less

00:42:09,930 --> 00:42:14,460
deterministic or some kind of scale of

00:42:12,180 --> 00:42:16,050
determinism so you don't have have to

00:42:14,460 --> 00:42:18,870
spend that much of effort because this

00:42:16,050 --> 00:42:20,880
is something you have to do like this is

00:42:18,870 --> 00:42:22,980
not something simple to do so do you

00:42:20,880 --> 00:42:27,390
have any or think of some kind of

00:42:22,980 --> 00:42:29,730
questionnaire or guide thank you

00:42:27,390 --> 00:42:31,710
yeah I mean what we have to look at the

00:42:29,730 --> 00:42:33,930
architecture of your system see what

00:42:31,710 --> 00:42:36,030
your activations are how you do is the

00:42:33,930 --> 00:42:38,130
time stamping all that that's one way

00:42:36,030 --> 00:42:41,910
and the other way is just measuring it

00:42:38,130 --> 00:42:44,760
you know and looking we in the trace

00:42:41,910 --> 00:42:46,500
tools analysis code there's an analysis

00:42:44,760 --> 00:42:48,270
which looks at the order in which your

00:42:46,500 --> 00:42:50,910
callbacks are being called and if you

00:42:48,270 --> 00:42:54,300
see that the order is flipping then you

00:42:50,910 --> 00:42:56,250
you have a problem in that respect and

00:42:54,300 --> 00:42:59,220
you can also do this latency measurement

00:42:56,250 --> 00:43:01,290
and you know if you see these switches

00:42:59,220 --> 00:43:03,840
between low latency and high latency

00:43:01,290 --> 00:43:06,720
then you have such a problem I mean

00:43:03,840 --> 00:43:09,000
that's it's not really like if you don't

00:43:06,720 --> 00:43:10,620
use package X you won't have a problem

00:43:09,000 --> 00:43:14,280
it's not like that you have to look at

00:43:10,620 --> 00:43:17,540
the architecture and one more question

00:43:14,280 --> 00:43:20,370
and go if you could answer on this sure

00:43:17,540 --> 00:43:22,890
thank you for interesting talk a short

00:43:20,370 --> 00:43:26,160
question related to RT preempt so you

00:43:22,890 --> 00:43:29,430
were talking about to fix some of the

00:43:26,160 --> 00:43:30,030
wake-up delays but does it how does it

00:43:29,430 --> 00:43:32,810
help does it

00:43:30,030 --> 00:43:36,530
get you rid of the

00:43:32,810 --> 00:43:39,260
the outliers or does it also decrease it

00:43:36,530 --> 00:43:41,360
delay itself we're not changing our T

00:43:39,260 --> 00:43:45,080
preempt what I was trying to say is that

00:43:41,360 --> 00:43:46,940
if you don't use RT preempt then even if

00:43:45,080 --> 00:43:48,410
you have a real time scheduled process

00:43:46,940 --> 00:43:51,050
you will still see these outliers

00:43:48,410 --> 00:43:54,680
because the kernel can still override it

00:43:51,050 --> 00:43:57,590
yes if you use RT preempt you won't see

00:43:54,680 --> 00:44:00,260
those you won't see the outliers anymore

00:43:57,590 --> 00:44:02,450
or anything okay at least I mean the

00:44:00,260 --> 00:44:06,340
open source automation development lab

00:44:02,450 --> 00:44:08,990
did extensive test cases for years and

00:44:06,340 --> 00:44:10,820
with RT preempt and i didn't see any

00:44:08,990 --> 00:44:13,780
okay so i think that's good enough for

00:44:10,820 --> 00:44:13,780
us Thanks

00:44:15,340 --> 00:44:23,839
thanks again Ingo

00:44:17,760 --> 00:44:23,839

YouTube URL: https://www.youtube.com/watch?v=II8yCw5tPE0


