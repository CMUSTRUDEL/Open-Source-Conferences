Title: ROSCon 2017 Vancouver Day 2  ROS Compliant FPGA Component Technology   FPGA installation into ROS
Publication date: 2021-03-28
Playlist: ROSCon 2017
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2017 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License
Captions: 
	00:00:00,290 --> 00:00:07,280
Thank You interaction I'm Takeshi Okada

00:00:03,240 --> 00:00:13,259
from with Mary University and this

00:00:07,280 --> 00:00:16,680
presentation is about as I introduced

00:00:13,259 --> 00:00:21,810
the installation of FPGA interval system

00:00:16,680 --> 00:00:25,670
and how to do it we are doing research

00:00:21,810 --> 00:00:29,490
on it and this is a joint presentation

00:00:25,670 --> 00:00:32,009
of two universities one it was not

00:00:29,490 --> 00:00:34,739
really dusty my University and the other

00:00:32,009 --> 00:00:37,140
is Kyushu Institute of Technology qtek

00:00:34,739 --> 00:00:41,100
from to tech you Tolui Tschida will

00:00:37,140 --> 00:00:42,690
present part of this presentation he's a

00:00:41,100 --> 00:00:47,840
PhD candidate

00:00:42,690 --> 00:00:55,820
okay let's I will try to start with a

00:00:47,840 --> 00:01:00,239
video from cute robot from Tooting okay

00:00:55,820 --> 00:01:02,489
so at first we showed a short video we

00:01:00,239 --> 00:01:05,369
develop homes harvest robots now the

00:01:02,489 --> 00:01:09,030
robot try to recognize the six objects

00:01:05,369 --> 00:01:11,869
on the sheriff but on the robot the

00:01:09,030 --> 00:01:16,680
computational resources are very limited

00:01:11,869 --> 00:01:19,560
so the robot need over one minute to

00:01:16,680 --> 00:01:27,030
recognize with deep neural networks so

00:01:19,560 --> 00:01:30,390
it's very big program okay just we feel

00:01:27,030 --> 00:01:33,560
that it's a natural to feel that one

00:01:30,390 --> 00:01:36,810
minute it's too long for the task so

00:01:33,560 --> 00:01:41,189
actually the robot implements Google net

00:01:36,810 --> 00:01:45,600
inside it and it takes four seconds for

00:01:41,189 --> 00:01:48,899
a single inference and using usual

00:01:45,600 --> 00:01:54,840
laptop so there's a needle for

00:01:48,899 --> 00:01:59,659
accelerator the first choice is nowadays

00:01:54,840 --> 00:02:03,420
is GPU GP however the thinking about

00:01:59,659 --> 00:02:06,509
embedding GPU into robot it's a have a

00:02:03,420 --> 00:02:11,009
power consumption and heat problem so

00:02:06,509 --> 00:02:13,840
FPGA FPGA can theorize optimize the

00:02:11,009 --> 00:02:16,420
circuit for the application

00:02:13,840 --> 00:02:21,459
and achieve high performance power

00:02:16,420 --> 00:02:25,750
efficiency this is a concrete example of

00:02:21,459 --> 00:02:30,610
a variation of CPU GPU FPGA comparison

00:02:25,750 --> 00:02:33,730
and this uses a modern deep neural

00:02:30,610 --> 00:02:38,879
network bridge eg 16 and dataset is

00:02:33,730 --> 00:02:43,330
cycle 10 ok look at the table the

00:02:38,879 --> 00:02:47,220
efficiency is measured at fifth frame

00:02:43,330 --> 00:02:51,310
pasok power what is in that case of

00:02:47,220 --> 00:02:57,190
Nvidia Jetson tx1 the CPU part the

00:02:51,310 --> 00:03:00,750
efficiency is 0.03 and but the GPU part

00:02:57,190 --> 00:03:07,599
is much higher ten times higher and even

00:03:00,750 --> 00:03:11,230
better is FPGA so I want to look back

00:03:07,599 --> 00:03:15,000
the current trend is five over three

00:03:11,230 --> 00:03:17,819
five or six years trend on FPGA

00:03:15,000 --> 00:03:24,870
application is like image recognition

00:03:17,819 --> 00:03:30,549
security and week later and device in

00:03:24,870 --> 00:03:34,739
2011 arm and FPGA has become a single

00:03:30,549 --> 00:03:39,400
chip and after that there was a interest

00:03:34,739 --> 00:03:45,190
ultra acquisition and it is announced

00:03:39,400 --> 00:03:49,180
that ji-yong + FPGA is so we thought as

00:03:45,190 --> 00:03:54,060
a single product but I think embedded

00:03:49,180 --> 00:03:56,680
world is still continuous and tools

00:03:54,060 --> 00:04:03,130
high-level synthesis has become a

00:03:56,680 --> 00:04:08,590
standard input design entry to stand out

00:04:03,130 --> 00:04:10,389
- and service in this April Amazon

00:04:08,590 --> 00:04:13,299
started

00:04:10,389 --> 00:04:18,970
if one instance which include Expedia

00:04:13,299 --> 00:04:23,440
board inside the server so this yes FPGA

00:04:18,970 --> 00:04:26,560
is very much moving movement so however

00:04:23,440 --> 00:04:27,200
the problem of introducing if PGA is

00:04:26,560 --> 00:04:31,210
still

00:04:27,200 --> 00:04:35,630
it's come from this card design or FPGA

00:04:31,210 --> 00:04:42,040
why FPGA if cars develop its as you know

00:04:35,630 --> 00:04:45,320
you need to write HDL it is looks like a

00:04:42,040 --> 00:04:47,510
software language but it's just write

00:04:45,320 --> 00:04:52,160
structure of a circuit so it's very

00:04:47,510 --> 00:04:54,770
tough to write a logic and even you use

00:04:52,160 --> 00:04:59,960
high level synthesis which can generate

00:04:54,770 --> 00:05:03,170
a circuit from C language behavior but

00:04:59,960 --> 00:05:07,460
it still need Bahamas tuning techniques

00:05:03,170 --> 00:05:11,240
it's you need to know deep about FPGA

00:05:07,460 --> 00:05:15,680
processing and memory access so you need

00:05:11,240 --> 00:05:18,830
training to exploit Thomas and another

00:05:15,680 --> 00:05:23,420
big problem is known from part time so

00:05:18,830 --> 00:05:27,830
my quick solution is to make it make

00:05:23,420 --> 00:05:33,350
FPGAs good FPGA design into a component

00:05:27,830 --> 00:05:38,180
and how about just use it for plug it to

00:05:33,350 --> 00:05:44,210
robot that's my proposal so let's make

00:05:38,180 --> 00:05:47,600
rows not as a VGA component and this

00:05:44,210 --> 00:05:52,540
right shows are three types of component

00:05:47,600 --> 00:05:56,500
of Q Tech and with no me a dagger

00:05:52,540 --> 00:06:00,470
proposing the first one is comforta

00:05:56,500 --> 00:06:06,350
which comes with provost from qtek and

00:06:00,470 --> 00:06:13,280
this is a combination of a PC and FPGA

00:06:06,350 --> 00:06:18,170
chip in this case PC part do that most

00:06:13,280 --> 00:06:22,430
of the Raja and AM do the bridge to

00:06:18,170 --> 00:06:26,270
connect to pc and FPGA and FPGA dosa

00:06:22,430 --> 00:06:28,070
they are application logic the second

00:06:26,270 --> 00:06:31,370
one is a roast comprehend the FPGA

00:06:28,070 --> 00:06:34,810
component on programmable sock here

00:06:31,370 --> 00:06:39,650
program oh-seok means a unpress FPGA and

00:06:34,810 --> 00:06:40,540
in this this is proposed by us with no

00:06:39,650 --> 00:06:45,930
me a university

00:06:40,540 --> 00:06:50,800
and in this case roast Linux random arm

00:06:45,930 --> 00:06:54,460
inside the chip and FPGA do the

00:06:50,800 --> 00:06:58,680
application logic the benefit of number

00:06:54,460 --> 00:07:03,460
two is single chip can be a roast not

00:06:58,680 --> 00:07:06,930
that's maybe you can imagine good world

00:07:03,460 --> 00:07:10,810
just a single chip is a loss not

00:07:06,930 --> 00:07:14,080
compared to however this has a problem

00:07:10,810 --> 00:07:18,460
that processor is not so high

00:07:14,080 --> 00:07:22,650
performance so the latency of those

00:07:18,460 --> 00:07:27,250
communication may cause a problem in

00:07:22,650 --> 00:07:33,340
some applications so number one cometa

00:07:27,250 --> 00:07:36,400
may be natural solution current country

00:07:33,340 --> 00:07:40,600
and number two is a factory have a

00:07:36,400 --> 00:07:44,710
problem but it's it can have a potential

00:07:40,600 --> 00:07:50,890
and number three is also proposed by us

00:07:44,710 --> 00:07:53,460
and to dissolve the problem we put all

00:07:50,890 --> 00:07:57,160
the lost communication into hardware

00:07:53,460 --> 00:08:01,870
it's called fully Hardware buyer Rosco

00:07:57,160 --> 00:08:07,510
chromatic PG component okay I will

00:08:01,870 --> 00:08:12,540
explain one by one and this is a

00:08:07,510 --> 00:08:15,520
commuter experiment as an example of

00:08:12,540 --> 00:08:20,770
following for human by using image

00:08:15,520 --> 00:08:25,120
processing the central black blue blue

00:08:20,770 --> 00:08:28,900
box is a conventional PC Rose image

00:08:25,120 --> 00:08:31,770
processing which takes RGB D camera

00:08:28,900 --> 00:08:36,490
image input by opening a driver

00:08:31,770 --> 00:08:38,620
binarization and whole feature a Marco

00:08:36,490 --> 00:08:43,300
home feature extraction and real

00:08:38,620 --> 00:08:46,270
adaboost and tracking human and this is

00:08:43,300 --> 00:08:52,530
commercial and right side is a proposal

00:08:46,270 --> 00:08:54,340
of using FPGA an ARM processor and that

00:08:52,530 --> 00:08:57,640
main part of

00:08:54,340 --> 00:09:04,990
thing is done in a physiologic and um

00:08:57,640 --> 00:09:08,590
does a breaching and this is a result

00:09:04,990 --> 00:09:13,980
about performance the left hand side

00:09:08,590 --> 00:09:16,870
table shows the performance and at first

00:09:13,980 --> 00:09:21,850
both have comparable performance

00:09:16,870 --> 00:09:26,800
framerate and power is very very much

00:09:21,850 --> 00:09:29,770
reduced and efficiency indicated by

00:09:26,800 --> 00:09:35,170
frame per second per watt is 3.3 times

00:09:29,770 --> 00:09:39,810
better and right hand side shows the CPU

00:09:35,170 --> 00:09:43,810
Road at the conventional PC CPU and

00:09:39,810 --> 00:09:48,640
upper one is the status of I'd ring and

00:09:43,810 --> 00:09:56,310
after her own human image processing

00:09:48,640 --> 00:10:03,520
algorithm runs its CPU load up much but

00:09:56,310 --> 00:10:06,370
we can use heavy tasks abroad into the

00:10:03,520 --> 00:10:10,390
proposed arm process PGH processing

00:10:06,370 --> 00:10:17,130
environment that's a benefit of using

00:10:10,390 --> 00:10:25,630
the cometa approach the second one is a

00:10:17,130 --> 00:10:30,810
one chip ross not using FPGA and to make

00:10:25,630 --> 00:10:33,970
a man chip was node we have developed

00:10:30,810 --> 00:10:39,430
automatic generation to name is craig

00:10:33,970 --> 00:10:43,420
comp this targets programmable SOC and

00:10:39,430 --> 00:10:47,320
this tool can input HDL and some

00:10:43,420 --> 00:10:51,370
configuration file and then using the

00:10:47,320 --> 00:10:55,840
create tool click on you can get working

00:10:51,370 --> 00:10:59,980
both node with the hardware between HDL

00:10:55,840 --> 00:11:03,850
the bridge part is automatically

00:10:59,980 --> 00:11:07,750
generated this is very simple and easy

00:11:03,850 --> 00:11:14,639
to use so i we had an experiment

00:11:07,750 --> 00:11:18,430
using this tool and six students aha

00:11:14,639 --> 00:11:21,879
this experiment and following a tutorial

00:11:18,430 --> 00:11:25,300
and one hour they can do it

00:11:21,879 --> 00:11:28,300
the tool is opened open source and share

00:11:25,300 --> 00:11:35,040
at github so if you have interest free

00:11:28,300 --> 00:11:39,850
city and also an example components

00:11:35,040 --> 00:11:45,819
share at github and Ross week so please

00:11:39,850 --> 00:11:47,800
check it a third one is a fully height

00:11:45,819 --> 00:11:54,389
of a hardwired Ross comprende feature

00:11:47,800 --> 00:11:57,670
component this is an demo movie and here

00:11:54,389 --> 00:12:00,009
in the right hand side there's a fpga

00:11:57,670 --> 00:12:10,199
board connected with Gigabit Ethernet

00:12:00,009 --> 00:12:16,870
and USB camera attached on the note OPC

00:12:10,199 --> 00:12:20,889
inputs the image and on the Left down is

00:12:16,870 --> 00:12:24,129
the first key point extraction result by

00:12:20,889 --> 00:12:27,870
PC and right hand side is done by FPGA

00:12:24,129 --> 00:12:31,059
it's the same result so

00:12:27,870 --> 00:12:36,370
fpg is really working

00:12:31,059 --> 00:12:40,540
I thought I give a much more good image

00:12:36,370 --> 00:12:48,490
by screen capture but if I press screen

00:12:40,540 --> 00:12:51,490
capture you can't see FPGA so this is

00:12:48,490 --> 00:12:54,790
the structure diagram of the evaluation

00:12:51,490 --> 00:12:57,730
system FPGA is access to be a Gigabit

00:12:54,790 --> 00:13:02,079
Ethernet and image processing socket is

00:12:57,730 --> 00:13:07,839
in the middle of the FPGA it's written

00:13:02,079 --> 00:13:12,459
in C++ open CV and hardware is generated

00:13:07,839 --> 00:13:16,959
using AES and subscriber publisher part

00:13:12,459 --> 00:13:20,139
is written by hand currently but later

00:13:16,959 --> 00:13:20,980
on we are planning to make automatic

00:13:20,139 --> 00:13:25,779
generation 2

00:13:20,980 --> 00:13:29,500
for the hardware and here we use a

00:13:25,779 --> 00:13:31,860
tcp/ip stack fully hardwired named a

00:13:29,500 --> 00:13:31,860
cyclicity

00:13:32,130 --> 00:13:41,620
this is a cold actual code working and

00:13:36,990 --> 00:13:47,889
fpga it's very simple just calling open

00:13:41,620 --> 00:13:56,199
civil functions only fibrin of function

00:13:47,889 --> 00:14:03,339
course did the demonstration but not so

00:13:56,199 --> 00:14:06,760
easy okay

00:14:03,339 --> 00:14:11,350
I want to explain more detail about how

00:14:06,760 --> 00:14:14,730
we use BGA lost node especially the

00:14:11,350 --> 00:14:18,040
hardware published on the SUBSCRIBE and

00:14:14,730 --> 00:14:23,260
we need worse why approach all that

00:14:18,040 --> 00:14:26,589
means what packet is communicated

00:14:23,260 --> 00:14:30,899
communicate while publish and subscribe

00:14:26,589 --> 00:14:35,949
and the message is imitated and

00:14:30,899 --> 00:14:39,550
generated and interpretated in Al PJ

00:14:35,949 --> 00:14:43,139
hardware so anyone can be a loss node

00:14:39,550 --> 00:14:46,360
who talks tcp/ip in Ross manner so

00:14:43,139 --> 00:14:49,690
anyone software hardware or something

00:14:46,360 --> 00:14:57,160
anyone can be a rose not so Redhawks

00:14:49,690 --> 00:15:01,180
rose via protocol this a basic of

00:14:57,160 --> 00:15:05,199
pub/sub messaging yeah there's a three

00:15:01,180 --> 00:15:09,130
nose on the top there's a master Rosco

00:15:05,199 --> 00:15:14,380
and left hand side publisher and right

00:15:09,130 --> 00:15:19,029
hand side is subscriber and by using XML

00:15:14,380 --> 00:15:21,279
RPC the location of topic is registered

00:15:19,029 --> 00:15:25,750
and request by request

00:15:21,279 --> 00:15:30,000
the topic is obtained by AG address and

00:15:25,750 --> 00:15:36,060
port and this part is done in XML RPC

00:15:30,000 --> 00:15:41,740
protocol and after that the actual

00:15:36,060 --> 00:15:45,310
data port or TCP Rose is obtained during

00:15:41,740 --> 00:15:48,300
the actual communication starts and the

00:15:45,310 --> 00:15:53,130
performance issue is concerned to the

00:15:48,300 --> 00:15:58,060
actual data communication part so with

00:15:53,130 --> 00:16:02,260
we think the FPGA should be introduced

00:15:58,060 --> 00:16:05,500
in this part this Epirus protocol is

00:16:02,260 --> 00:16:10,660
like this this is a chapter packet TCP

00:16:05,500 --> 00:16:15,100
packet by Wireshark and the red box part

00:16:10,660 --> 00:16:19,630
is the actual data so it's very raw and

00:16:15,100 --> 00:16:30,150
binary protocol so it's good to handle

00:16:19,630 --> 00:16:35,290
in FPGA and this is hardwired publish'

00:16:30,150 --> 00:16:38,490
implemented in the demonstration and of

00:16:35,290 --> 00:16:44,110
course subscriber must be and they were

00:16:38,490 --> 00:16:47,560
implemented through similarly and our

00:16:44,110 --> 00:16:48,670
idea is to split felicia from the

00:16:47,560 --> 00:16:52,300
complex

00:16:48,670 --> 00:16:55,930
xml-rpc part as a software and the real

00:16:52,300 --> 00:16:59,890
data france potential into fpga that

00:16:55,930 --> 00:17:03,750
makes that design very simple i think

00:16:59,890 --> 00:17:04,990
this idea can be applied to very a

00:17:03,750 --> 00:17:10,650
minute

00:17:04,990 --> 00:17:15,180
small CPUs so please Huck zeros protocol

00:17:10,650 --> 00:17:19,030
and using this idea you can make

00:17:15,180 --> 00:17:26,500
parrisha Hardware only with one tcp/ip

00:17:19,030 --> 00:17:33,150
port and we evaluated the performance by

00:17:26,500 --> 00:17:37,060
comparing PC and and FPGA and and that

00:17:33,150 --> 00:17:42,310
used a loss message type is a realistic

00:17:37,060 --> 00:17:47,170
one since I messages imaging and this is

00:17:42,310 --> 00:17:49,010
a board we used for evaluation and this

00:17:47,170 --> 00:17:52,520
hardware utilization is

00:17:49,010 --> 00:17:55,850
does not include image processing to

00:17:52,520 --> 00:18:03,170
just read a reading pass-throughs video

00:17:55,850 --> 00:18:08,390
image and from left hand side blue blue

00:18:03,170 --> 00:18:14,060
is PC and center is arm and right hand

00:18:08,390 --> 00:18:16,670
is FPGA so fpg can accelerate and image

00:18:14,060 --> 00:18:24,490
that transfer processing and data sizes

00:18:16,670 --> 00:18:24,490
are about 6 mega byte means through HD

00:18:24,820 --> 00:18:30,350
okay

00:18:26,020 --> 00:18:34,790
I'll summarize my talk and our proposal

00:18:30,350 --> 00:18:38,330
is three types of FPGA component and we

00:18:34,790 --> 00:18:40,730
are thinking of application DNN deep

00:18:38,330 --> 00:18:45,680
learning architecture for object

00:18:40,730 --> 00:18:53,320
recognition and SRAM maybe this is

00:18:45,680 --> 00:18:56,510
future work and we are our joint team is

00:18:53,320 --> 00:18:59,690
have a plan to challenge at next year's

00:18:56,510 --> 00:19:05,870
Robocop actually DC has Robocop learning

00:18:59,690 --> 00:19:09,430
and this July that Q tech team is a

00:19:05,870 --> 00:19:15,500
first-place winner or at home Monique

00:19:09,430 --> 00:19:19,060
okay so we are now we are not planning

00:19:15,500 --> 00:19:20,290
to the next year thank you that's all

00:19:19,060 --> 00:19:26,990
thank you

00:19:20,290 --> 00:19:28,250
[Applause]

00:19:26,990 --> 00:19:32,240
I didn't think anybody would ever

00:19:28,250 --> 00:19:35,059
implement TCP Ross in an FPGA questions

00:19:32,240 --> 00:19:36,740
over here so how much optimization did

00:19:35,059 --> 00:19:39,559
you do of things like your deep neural

00:19:36,740 --> 00:19:42,140
network algorithm post putting it onto

00:19:39,559 --> 00:19:43,880
an FPGA did you just report it over or

00:19:42,140 --> 00:19:45,140
did you actually do a lot of work to try

00:19:43,880 --> 00:19:48,010
to optimize it and could you speak to

00:19:45,140 --> 00:19:51,919
that place ah question is how much of

00:19:48,010 --> 00:19:52,490
optimization PGA specific optimization

00:19:51,919 --> 00:20:00,710
did you do

00:19:52,490 --> 00:20:06,740
yet in the demonstration I didn't do any

00:20:00,710 --> 00:20:10,520
optimization but technique to optimize

00:20:06,740 --> 00:20:16,610
by splitting memory localization and

00:20:10,520 --> 00:20:19,580
many things yet it takes time by FPGA

00:20:16,610 --> 00:20:26,020
expert so my proposal is to make it a

00:20:19,580 --> 00:20:26,020
component and robot developer just music

00:20:26,200 --> 00:20:32,150
and it looks like you have use

00:20:28,700 --> 00:20:34,640
implemented one message type image how

00:20:32,150 --> 00:20:37,010
difficult will it be to scale this up to

00:20:34,640 --> 00:20:40,600
handle all the message formats to auto

00:20:37,010 --> 00:20:40,600
generate the code for the FPGA

00:20:41,890 --> 00:20:49,909
scalability - specifically to handle any

00:20:45,320 --> 00:20:52,840
message type it's impossible yeah the

00:20:49,909 --> 00:20:58,480
hardware part is very I think very tough

00:20:52,840 --> 00:21:04,370
now that my demonstration is just

00:20:58,480 --> 00:21:13,159
bizarre array array size and gets the

00:21:04,370 --> 00:21:18,700
image rings and we skip some part the

00:21:13,159 --> 00:21:23,690
images but to generalize it it's maybe

00:21:18,700 --> 00:21:26,840
some trick and back and my crime is to

00:21:23,690 --> 00:21:29,059
interpret message file or message the

00:21:26,840 --> 00:21:33,679
finish on mobile rose and make a

00:21:29,059 --> 00:21:35,110
generator necessary Hardware only and by

00:21:33,679 --> 00:21:38,600
skipping something

00:21:35,110 --> 00:21:44,859
okay well thank you again

00:21:38,600 --> 00:21:44,859

YouTube URL: https://www.youtube.com/watch?v=ilSeXV4UfAU


