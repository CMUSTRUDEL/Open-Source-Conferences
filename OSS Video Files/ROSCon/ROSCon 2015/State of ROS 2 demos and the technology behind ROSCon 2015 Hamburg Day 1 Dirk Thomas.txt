Title: State of ROS 2 demos and the technology behind ROSCon 2015 Hamburg Day 1 Dirk Thomas
Publication date: 2015-12-08
Playlist: ROSCon 2015
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2015 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,240 --> 00:00:04,500
so first I want to introduce the goals

00:00:02,639 --> 00:00:06,240
for us - and you've probably seen them

00:00:04,500 --> 00:00:07,649
last year at Rosco and its base is the

00:00:06,240 --> 00:00:10,170
same slide there would be a platform

00:00:07,649 --> 00:00:12,300
image at the bottom you don't see but

00:00:10,170 --> 00:00:14,429
there are things in rows one which are

00:00:12,300 --> 00:00:15,780
not working as as good as they can and

00:00:14,429 --> 00:00:18,510
there are scenarios which are not work

00:00:15,780 --> 00:00:20,640
address well well enough and these are

00:00:18,510 --> 00:00:23,039
things we want to solve in Russ - to

00:00:20,640 --> 00:00:24,840
make these use cases better and the

00:00:23,039 --> 00:00:26,699
first one is clearly a scenario with

00:00:24,840 --> 00:00:28,590
multiple robots when you have unreliable

00:00:26,699 --> 00:00:30,779
networks involved cross one doesn't

00:00:28,590 --> 00:00:32,610
perform very well another thing when you

00:00:30,779 --> 00:00:34,380
when you develop a prototype rows one is

00:00:32,610 --> 00:00:36,660
great but as soon as you want to deploy

00:00:34,380 --> 00:00:38,700
it in a product you might hesitate if it

00:00:36,660 --> 00:00:41,309
really performs that well when it's at a

00:00:38,700 --> 00:00:43,770
customer site so you made me strong Russ

00:00:41,309 --> 00:00:45,300
one at that point the next one is the

00:00:43,770 --> 00:00:47,579
microcontroller we already heard from

00:00:45,300 --> 00:00:49,860
Morgan how much pain it is to actually

00:00:47,579 --> 00:00:53,129
run was one or try to invent in a small

00:00:49,860 --> 00:00:55,649
micro controller and how the rescue will

00:00:53,129 --> 00:00:57,360
address that another case we are here

00:00:55,649 --> 00:00:59,399
another presentation later is real time

00:00:57,360 --> 00:01:01,320
which is also something Ross one is not

00:00:59,399 --> 00:01:03,840
that good and usually delegates to other

00:01:01,320 --> 00:01:06,299
toolkits and the fifth one which you

00:01:03,840 --> 00:01:09,540
also don't see on that slide is platform

00:01:06,299 --> 00:01:11,670
support Linux is obviously our tier one

00:01:09,540 --> 00:01:13,200
platform it's well supported OS X you

00:01:11,670 --> 00:01:15,869
can build it from source it works pretty

00:01:13,200 --> 00:01:17,369
decent but if you try it on Windows

00:01:15,869 --> 00:01:19,920
you're pretty much in the rain it's like

00:01:17,369 --> 00:01:22,020
it's not well supported you can do it if

00:01:19,920 --> 00:01:25,170
you have a very high pain tolerance but

00:01:22,020 --> 00:01:27,150
it's not supported for us so this is

00:01:25,170 --> 00:01:30,720
things we want to address it Ross - like

00:01:27,150 --> 00:01:32,610
from the beginning so all the rest of

00:01:30,720 --> 00:01:34,049
the talk will really be demos where you

00:01:32,610 --> 00:01:35,970
see certain parts which we all we have

00:01:34,049 --> 00:01:38,729
working plus some technical background

00:01:35,970 --> 00:01:40,350
how they work and all of those work only

00:01:38,729 --> 00:01:42,689
on all three platforms so we can build

00:01:40,350 --> 00:01:46,250
the prototype of Linux OS X Windows and

00:01:42,689 --> 00:01:49,350
they actually work on those if you

00:01:46,250 --> 00:01:50,939
happen to want more details about the

00:01:49,350 --> 00:01:52,710
demos or run the tutorials yourself you

00:01:50,939 --> 00:01:54,479
can do them they are on github or us -

00:01:52,710 --> 00:01:57,060
slash Ross - there's a wiki you'll find

00:01:54,479 --> 00:01:58,649
a lot of information and we will give

00:01:57,060 --> 00:02:00,659
you more information than was written

00:01:58,649 --> 00:02:01,960
down in there so I'll start with a very

00:02:00,659 --> 00:02:05,190
simple demo for

00:02:01,960 --> 00:02:05,190
a public web demo

00:02:17,200 --> 00:02:22,180
so on the left side you see the first

00:02:20,170 --> 00:02:26,080
Chell running a publisher very

00:02:22,180 --> 00:02:31,020
spectacular publishing HelloWorld and on

00:02:26,080 --> 00:02:34,510
the second side so I get my cursor over

00:02:31,020 --> 00:02:35,830
will see a listener it gets the message

00:02:34,510 --> 00:02:51,580
whole world okay that's not that

00:02:35,830 --> 00:02:53,319
spectacular but actually it is so we've

00:02:51,580 --> 00:02:54,790
seen these two processes the first thing

00:02:53,319 --> 00:02:56,950
you hopefully noticed there was no

00:02:54,790 --> 00:02:59,350
search window running Arras core because

00:02:56,950 --> 00:03:01,569
since Ross tool works on top of DDS in

00:02:59,350 --> 00:03:02,920
this case it's it doesn't need a central

00:03:01,569 --> 00:03:07,000
master it works completely distributed

00:03:02,920 --> 00:03:10,420
and the talk itself uses the similar to

00:03:07,000 --> 00:03:13,390
rusty UPS C++ client library which then

00:03:10,420 --> 00:03:14,950
uses a middleware interface and under

00:03:13,390 --> 00:03:16,660
this interface we can implement the

00:03:14,950 --> 00:03:18,400
interface with different vendors because

00:03:16,660 --> 00:03:20,410
VBS is a specification there are

00:03:18,400 --> 00:03:22,570
multiple vendors providing that

00:03:20,410 --> 00:03:24,370
so there's comics on one side and

00:03:22,570 --> 00:03:26,290
opensplice on the other and actually

00:03:24,370 --> 00:03:27,549
what we saw in the demo was a talk I was

00:03:26,290 --> 00:03:29,500
using using opensplice

00:03:27,549 --> 00:03:31,510
which was selected at linked time of the

00:03:29,500 --> 00:03:34,810
executable and the listener was using

00:03:31,510 --> 00:03:37,120
connects and since both of those vendors

00:03:34,810 --> 00:03:38,859
implement the DDS protocol according to

00:03:37,120 --> 00:03:40,420
the interoperability standard they

00:03:38,859 --> 00:03:44,769
actually can talk to each other either

00:03:40,420 --> 00:03:46,450
their different vendors a short look to

00:03:44,769 --> 00:03:48,519
the source code that's the Ross one code

00:03:46,450 --> 00:03:49,989
so you have a callback which gets called

00:03:48,519 --> 00:03:51,930
when you receive a message and the main

00:03:49,989 --> 00:03:55,900
function which initializes the code and

00:03:51,930 --> 00:03:58,359
hits a subscriber and then spins will

00:03:55,900 --> 00:04:01,150
keep the code in comments here how does

00:03:58,359 --> 00:04:02,980
that look code look for us too so the

00:04:01,150 --> 00:04:05,019
first thing you'll probably notice is we

00:04:02,980 --> 00:04:06,640
use like a C++ stuff so for example

00:04:05,019 --> 00:04:08,700
order to keep like the line short

00:04:06,640 --> 00:04:11,049
otherwise it wouldn't fit on the slide

00:04:08,700 --> 00:04:13,180
you have the callback signature which

00:04:11,049 --> 00:04:15,069
it's not obvious from the type def but

00:04:13,180 --> 00:04:17,289
it's not using boost anymore it's using

00:04:15,069 --> 00:04:19,180
STD share pointers because we have the r

00:04:17,289 --> 00:04:21,519
NS DD now so we don't have to use an

00:04:19,180 --> 00:04:23,110
external library for that the call that

00:04:21,519 --> 00:04:24,320
here is still a normal function but

00:04:23,110 --> 00:04:27,520
since it

00:04:24,320 --> 00:04:29,480
we could easily use a lambda for that

00:04:27,520 --> 00:04:31,760
but there are other like differences

00:04:29,480 --> 00:04:33,800
between what one was - for example the

00:04:31,760 --> 00:04:35,270
note name you pass them it doesn't get

00:04:33,800 --> 00:04:37,730
passed into the init function - the

00:04:35,270 --> 00:04:38,960
global one before but now it gets passed

00:04:37,730 --> 00:04:41,240
to the node because it makes more sense

00:04:38,960 --> 00:04:42,800
it's the name of the node so that allows

00:04:41,240 --> 00:04:44,210
you for example to create a second node

00:04:42,800 --> 00:04:45,950
with a different name within the same

00:04:44,210 --> 00:04:49,880
process something which is not possible

00:04:45,950 --> 00:04:51,800
in row so on either another part another

00:04:49,880 --> 00:04:54,800
difference is when you create a

00:04:51,800 --> 00:04:57,470
subscriber you pass arguments like the

00:04:54,800 --> 00:04:58,750
topic and also some QoS profile we hear

00:04:57,470 --> 00:05:01,700
more about that later

00:04:58,750 --> 00:05:03,320
but this function is templated on the on

00:05:01,700 --> 00:05:04,760
the actual message type in Ross one that

00:05:03,320 --> 00:05:07,100
was not the case so you can sometimes

00:05:04,760 --> 00:05:09,110
fool rusty VP and create a subscriber

00:05:07,100 --> 00:05:11,060
for one time type and then actually

00:05:09,110 --> 00:05:15,020
letting in to handle another one which

00:05:11,060 --> 00:05:16,490
is pretty ugly and the last one I want

00:05:15,020 --> 00:05:18,410
to mention here is the spin function

00:05:16,490 --> 00:05:21,200
before it was a global function relying

00:05:18,410 --> 00:05:23,360
on singleton behind-the-scene it

00:05:21,200 --> 00:05:25,370
magically knew which node to like deal

00:05:23,360 --> 00:05:27,860
with and now you actually pass in the

00:05:25,370 --> 00:05:29,690
node you can do a spin call on multiple

00:05:27,860 --> 00:05:31,760
function on multiple nodes for example

00:05:29,690 --> 00:05:33,320
or there are also different execution

00:05:31,760 --> 00:05:35,060
models where you might not call a simple

00:05:33,320 --> 00:05:38,960
spin function but create like more

00:05:35,060 --> 00:05:41,260
complex scenarios I also mentioned

00:05:38,960 --> 00:05:43,670
briefly the DDS vendors

00:05:41,260 --> 00:05:45,890
currently we have implementations for

00:05:43,670 --> 00:05:48,860
RTI connects present a Corbin splice and

00:05:45,890 --> 00:05:53,930
since very recently from a pro siva fast

00:05:48,860 --> 00:05:55,400
RTS don't confuse it with free RT PS RTI

00:05:53,930 --> 00:05:57,200
is a commercial license it's well

00:05:55,400 --> 00:05:58,730
supported the government uses that in a

00:05:57,200 --> 00:06:00,290
lot of projects we get government

00:05:58,730 --> 00:06:03,200
funding so it's good as they can use

00:06:00,290 --> 00:06:04,940
that they're actually two variations are

00:06:03,200 --> 00:06:06,380
static and the dynamic runtime

00:06:04,940 --> 00:06:08,660
implementation of the types which is

00:06:06,380 --> 00:06:10,910
more technical detail opensplice is

00:06:08,660 --> 00:06:13,700
commercial and LGPL available so

00:06:10,910 --> 00:06:15,200
especially for us as the default one we

00:06:13,700 --> 00:06:18,140
currently use opens right because of

00:06:15,200 --> 00:06:19,160
that twin else we started working with

00:06:18,140 --> 00:06:20,870
that but since they only have a

00:06:19,160 --> 00:06:23,210
commercial license we didn't continue

00:06:20,870 --> 00:06:25,540
for now maybe the vendor will pick it up

00:06:23,210 --> 00:06:27,800
and provide an implementation on its own

00:06:25,540 --> 00:06:29,480
first our two Bs is very interesting

00:06:27,800 --> 00:06:32,030
it's a pretty new implementation it's

00:06:29,480 --> 00:06:33,440
also LGPL there's one feature which is

00:06:32,030 --> 00:06:35,380
still missing for messages which are

00:06:33,440 --> 00:06:37,300
bigger so it doesn't support

00:06:35,380 --> 00:06:39,010
egman tation yet but they're actively

00:06:37,300 --> 00:06:40,480
working on that and try to get that

00:06:39,010 --> 00:06:42,610
resolved by the end of the year and then

00:06:40,480 --> 00:06:45,040
I think fast our TPS will be an

00:06:42,610 --> 00:06:46,990
interesting alternative we already heard

00:06:45,040 --> 00:06:48,550
about VR TPS and Morgan's talk before

00:06:46,990 --> 00:06:50,140
which is aiming more for small systems

00:06:48,550 --> 00:06:52,770
it doesn't implement the full

00:06:50,140 --> 00:06:55,780
specification but we're working on that

00:06:52,770 --> 00:07:09,310
so now I hand over to William for the

00:06:55,780 --> 00:07:10,320
next demo hello my name is William so

00:07:09,310 --> 00:07:11,980
I'm gonna talk a little bit about

00:07:10,320 --> 00:07:15,100
transparent inter process communication

00:07:11,980 --> 00:07:19,030
so for those of you who don't know what

00:07:15,100 --> 00:07:21,430
that is basically that's where you skip

00:07:19,030 --> 00:07:22,840
the serialization and network part when

00:07:21,430 --> 00:07:25,030
publishing and subscribing so when we're

00:07:22,840 --> 00:07:27,450
in the same process with another node or

00:07:25,030 --> 00:07:29,860
when you're publishing and subscribing

00:07:27,450 --> 00:07:32,110
to the same topic within a single node

00:07:29,860 --> 00:07:33,310
you can skip a lot of the work and save

00:07:32,110 --> 00:07:37,510
a lot of time and get a big performance

00:07:33,310 --> 00:07:38,620
abuse sort of related topic that I'm not

00:07:37,510 --> 00:07:40,320
going to talk about here but I talked

00:07:38,620 --> 00:07:43,410
about previously in previous Ross cons

00:07:40,320 --> 00:07:47,200
the fact in dirt touched on was that

00:07:43,410 --> 00:07:49,510
we're changing the API design for nodes

00:07:47,200 --> 00:07:51,190
and Ross one when we're going to Ross

00:07:49,510 --> 00:07:52,690
two so that you can have multiple

00:07:51,190 --> 00:07:55,060
processes in the same node so this

00:07:52,690 --> 00:07:57,790
becomes more applicable it was used in

00:07:55,060 --> 00:07:59,380
not--let's but we hope that people can

00:07:57,790 --> 00:08:03,400
use it more and get a performance boost

00:07:59,380 --> 00:08:04,960
more frequently so like I was saying the

00:08:03,400 --> 00:08:07,120
way the inter inter process

00:08:04,960 --> 00:08:09,310
publish/subscribe works is that you have

00:08:07,120 --> 00:08:11,350
a published call that gets serialized

00:08:09,310 --> 00:08:13,360
the message you give it and that gets

00:08:11,350 --> 00:08:14,710
into the network sack which is picked up

00:08:13,360 --> 00:08:16,360
by the network stack on the other node

00:08:14,710 --> 00:08:18,550
deserialized and finally give them back

00:08:16,360 --> 00:08:20,740
to your callback we can skim both of

00:08:18,550 --> 00:08:24,490
those steps with inter process and go

00:08:20,740 --> 00:08:25,780
directly to passing the data from the

00:08:24,490 --> 00:08:28,450
publisher to the subscriber without

00:08:25,780 --> 00:08:30,670
realizing or going to the network you

00:08:28,450 --> 00:08:32,620
know we often hear about what Ross two

00:08:30,670 --> 00:08:34,570
is going to do better than Ross one or

00:08:32,620 --> 00:08:37,060
what Ross one does poorly at but ross

00:08:34,570 --> 00:08:40,060
one does really well in a lot of cases

00:08:37,060 --> 00:08:42,099
and this is one of them it already has

00:08:40,060 --> 00:08:43,419
the ability to do most of this stuff it

00:08:42,099 --> 00:08:46,110
can avoid serialization in DC

00:08:43,419 --> 00:08:49,710
realizations and the cases I mentioned

00:08:46,110 --> 00:08:52,140
can avoid the network stack and I can

00:08:49,710 --> 00:08:54,150
avoid copies allowing you to do zero

00:08:52,140 --> 00:08:55,800
copy communication between publishers

00:08:54,150 --> 00:09:00,120
and subscribers within a single process

00:08:55,800 --> 00:09:02,610
but there are some caveats to that one

00:09:00,120 --> 00:09:04,830
of which is I quoted here from the

00:09:02,610 --> 00:09:06,570
documentation on the wiki when you're

00:09:04,830 --> 00:09:08,550
doing this zero copy inter process

00:09:06,570 --> 00:09:10,470
communication with Ross one there's an

00:09:08,550 --> 00:09:14,220
implicit agreement that when you give it

00:09:10,470 --> 00:09:15,690
this message as a shared pointer that

00:09:14,220 --> 00:09:17,550
you're not supposed to modify it after

00:09:15,690 --> 00:09:20,990
you call publish because it's going to

00:09:17,550 --> 00:09:23,100
then take that shared pointer uncopyable

00:09:20,990 --> 00:09:26,850
eight that then some really weird

00:09:23,100 --> 00:09:29,900
behavior could happen so diving into

00:09:26,850 --> 00:09:32,040
that a little more taking this example

00:09:29,900 --> 00:09:33,510
you can see if the first thing we do is

00:09:32,040 --> 00:09:35,760
create a new message and put it into a

00:09:33,510 --> 00:09:37,920
shared pointer and then we assign some

00:09:35,760 --> 00:09:40,350
information into that message and then

00:09:37,920 --> 00:09:41,820
we call publish on it and then after

00:09:40,350 --> 00:09:43,380
that I do the really bad thing which is

00:09:41,820 --> 00:09:45,090
I modify the data after giving it to

00:09:43,380 --> 00:09:47,070
publish so I violated this contract so

00:09:45,090 --> 00:09:49,050
the question I have is will the

00:09:47,070 --> 00:09:52,140
subscribing callbacks to this topic get

00:09:49,050 --> 00:09:53,340
testing or testing too and you have to

00:09:52,140 --> 00:09:54,510
look into the implementation to figure

00:09:53,340 --> 00:09:56,820
out what happens actually they'll

00:09:54,510 --> 00:09:58,710
actually get testing because what

00:09:56,820 --> 00:10:00,690
happens when you call publish that third

00:09:58,710 --> 00:10:02,070
line in this example it actually goes

00:10:00,690 --> 00:10:03,660
all the way through and calls the

00:10:02,070 --> 00:10:06,060
subscription callbacks directly they

00:10:03,660 --> 00:10:07,380
don't get rescheduled into the into the

00:10:06,060 --> 00:10:10,620
spin function they get called through

00:10:07,380 --> 00:10:12,390
directly and so they are going to get

00:10:10,620 --> 00:10:13,590
testing because the line which modifies

00:10:12,390 --> 00:10:15,420
that the testing two doesn't happen

00:10:13,590 --> 00:10:18,420
after until after those callbacks have

00:10:15,420 --> 00:10:20,040
been executed but if they store that

00:10:18,420 --> 00:10:21,450
share pointer and then use it later they

00:10:20,040 --> 00:10:24,600
may get the different value and that's

00:10:21,450 --> 00:10:27,030
very surprising behavior I think if you

00:10:24,600 --> 00:10:28,950
didn't read the documentation and made

00:10:27,030 --> 00:10:32,970
this mistake the other concern here is

00:10:28,950 --> 00:10:34,230
that if you if the subscriber callbacks

00:10:32,970 --> 00:10:35,880
they're getting called directly from

00:10:34,230 --> 00:10:37,680
your publish call or blocking or take a

00:10:35,880 --> 00:10:39,630
very long time it can be very surprising

00:10:37,680 --> 00:10:41,550
so you have a situation where you have a

00:10:39,630 --> 00:10:42,600
publisher and subscriber which work well

00:10:41,550 --> 00:10:44,310
together and then you add a new

00:10:42,600 --> 00:10:45,720
subscriber to the mix and suddenly your

00:10:44,310 --> 00:10:47,160
publish call is blocking you don't

00:10:45,720 --> 00:10:49,740
understand what's happening it can be

00:10:47,160 --> 00:10:50,640
very confusing and hard to debug so

00:10:49,740 --> 00:10:51,930
these are some of the things we'd like

00:10:50,640 --> 00:10:54,390
you know if we're going to encourage

00:10:51,930 --> 00:10:55,890
people to try to use multiple nodes in a

00:10:54,390 --> 00:10:56,550
single process to get efficiency gains

00:10:55,890 --> 00:10:59,130
we wouldn't try to

00:10:56,550 --> 00:11:01,709
as a unsurprising experience as possible

00:10:59,130 --> 00:11:02,850
and a safe as experience as possible so

00:11:01,709 --> 00:11:03,959
we want to try to fix some of these

00:11:02,850 --> 00:11:07,709
things in Ross too and that's what I

00:11:03,959 --> 00:11:08,940
want to talk about today so so Ross -

00:11:07,709 --> 00:11:10,110
we're going to do the same things as

00:11:08,940 --> 00:11:12,690
Ross one we're going to avoid

00:11:10,110 --> 00:11:14,850
serialization deserialization bye-bye

00:11:12,690 --> 00:11:17,070
shortcutting the middleware as well as

00:11:14,850 --> 00:11:19,140
the network stack and all that but we

00:11:17,070 --> 00:11:21,630
want to provide a safer interface to

00:11:19,140 --> 00:11:23,040
zero copy publishing and subscribing by

00:11:21,630 --> 00:11:26,040
using unique pointers which is a new

00:11:23,040 --> 00:11:28,350
feature in C++ 11 it's been in boost but

00:11:26,040 --> 00:11:31,680
we don't use it in Ross 1 as far as I

00:11:28,350 --> 00:11:33,089
know and also we want to try to strive

00:11:31,680 --> 00:11:34,800
for more consistency between the

00:11:33,089 --> 00:11:37,110
inter-process behavior and the intro

00:11:34,800 --> 00:11:38,839
process behavior so that you can get a

00:11:37,110 --> 00:11:41,130
better or less surprising experience

00:11:38,839 --> 00:11:45,720
when using the API is in different ways

00:11:41,130 --> 00:11:48,660
so yeah so basically we want to try to

00:11:45,720 --> 00:11:50,519
solve this this implicit contract by

00:11:48,660 --> 00:11:51,810
making it explicit instead where you're

00:11:50,519 --> 00:11:53,040
not going to modify the data after you

00:11:51,810 --> 00:11:54,990
give it to the middleware to share with

00:11:53,040 --> 00:11:56,279
other callbacks so we're going to do

00:11:54,990 --> 00:11:57,510
this using a neat corner for those of

00:11:56,279 --> 00:11:59,430
you don't know how unique pointer works

00:11:57,510 --> 00:12:02,190
I've got a little example here I create

00:11:59,430 --> 00:12:05,310
two unique pointers a and B and I put I

00:12:02,190 --> 00:12:07,560
allocate a new class and put it into a

00:12:05,310 --> 00:12:09,660
but I don't put anything to B so before

00:12:07,560 --> 00:12:12,720
the the last uncommon deadline in that

00:12:09,660 --> 00:12:16,260
example a is a valid pointer to to a

00:12:12,720 --> 00:12:17,670
class instance the type capital a and B

00:12:16,260 --> 00:12:21,089
is a null pointer but when I do the

00:12:17,670 --> 00:12:23,279
assignment of A to B it transfers the

00:12:21,089 --> 00:12:25,350
ownership and afterwards a is now

00:12:23,279 --> 00:12:26,670
invalid and B has the valid pointer so

00:12:25,350 --> 00:12:28,529
it doesn't allow you to share the data

00:12:26,670 --> 00:12:30,510
at all your your actually hate your it's

00:12:28,529 --> 00:12:33,120
a way to track ownership with allocated

00:12:30,510 --> 00:12:35,190
memory and give it to other people other

00:12:33,120 --> 00:12:38,310
parts of the system and so if we utilize

00:12:35,190 --> 00:12:39,839
this to apply it to publishing in Ross -

00:12:38,310 --> 00:12:41,250
you can see in this example we're

00:12:39,839 --> 00:12:42,990
creating a unique pointer rather than a

00:12:41,250 --> 00:12:44,670
shared pointer as we did before I

00:12:42,990 --> 00:12:46,440
assigned testing to it and I call

00:12:44,670 --> 00:12:48,120
publish on it and what's happening in

00:12:46,440 --> 00:12:49,589
that published line is I'm giving the

00:12:48,120 --> 00:12:51,360
ownership of that message to the

00:12:49,589 --> 00:12:52,980
middleware I no longer have access to it

00:12:51,360 --> 00:12:55,110
so previously the line where I added

00:12:52,980 --> 00:12:56,550
testing to to the data that would

00:12:55,110 --> 00:12:57,870
actually be a segfault because you're

00:12:56,550 --> 00:12:59,490
accessing a null pointer there and

00:12:57,870 --> 00:13:03,060
there's no longer this implicit contract

00:12:59,490 --> 00:13:04,649
it's an explicit thing I forgot to

00:13:03,060 --> 00:13:07,910
mention this is not always the best

00:13:04,649 --> 00:13:09,290
solution sometimes you actually want to

00:13:07,910 --> 00:13:11,210
have this implicit contract where you

00:13:09,290 --> 00:13:12,710
give a shared pointer and then later

00:13:11,210 --> 00:13:14,150
you're going to reuse it or something

00:13:12,710 --> 00:13:15,830
like that that takes a more overall

00:13:14,150 --> 00:13:17,420
system design but it's something you may

00:13:15,830 --> 00:13:19,640
want to do so it's something you know

00:13:17,420 --> 00:13:20,660
it's not all it's not Silver Bullet is

00:13:19,640 --> 00:13:23,600
what I'm saying we might want to

00:13:20,660 --> 00:13:25,040
preserve the feature of that's in Ross 1

00:13:23,600 --> 00:13:27,560
but I don't think it should be the

00:13:25,040 --> 00:13:28,880
default I guess is what I'm saying if we

00:13:27,560 --> 00:13:30,620
think about it from the subscribing side

00:13:28,880 --> 00:13:33,230
first let's look at a at a typical

00:13:30,620 --> 00:13:34,940
example so this is like a Ross 1 typical

00:13:33,230 --> 00:13:37,730
thing you have a callback you receive a

00:13:34,940 --> 00:13:39,650
shared pointer of a message and if you

00:13:37,730 --> 00:13:41,690
want to modify that message it actually

00:13:39,650 --> 00:13:44,030
comes in as Const and the reason it

00:13:41,690 --> 00:13:45,590
comes in is cost is because the

00:13:44,030 --> 00:13:47,630
middleware may need to give that same

00:13:45,590 --> 00:13:49,160
shared pointer to other callbacks and so

00:13:47,630 --> 00:13:51,620
it can't allow you to modify it in

00:13:49,160 --> 00:13:53,150
between and so if you want to modify it

00:13:51,620 --> 00:13:54,530
you need to make a copy of it first and

00:13:53,150 --> 00:13:55,820
this is pretty common with something

00:13:54,530 --> 00:13:57,560
like a transfer function where you like

00:13:55,820 --> 00:13:59,030
get let's say an image in you want to

00:13:57,560 --> 00:14:01,400
mutate it and publish it out to another

00:13:59,030 --> 00:14:04,850
another topic is sort of like part of a

00:14:01,400 --> 00:14:06,770
pipeline and so we can't gain a lot of

00:14:04,850 --> 00:14:08,000
benefit by using unique pointer here but

00:14:06,770 --> 00:14:09,560
it can simplify our code a little bit

00:14:08,000 --> 00:14:11,240
because when we ask the middleware for a

00:14:09,560 --> 00:14:13,760
unique pointer then the middleware has

00:14:11,240 --> 00:14:15,470
to make the copy for us so it's like a

00:14:13,760 --> 00:14:18,080
little less code and there's one very

00:14:15,470 --> 00:14:20,180
special case where this can be it can

00:14:18,080 --> 00:14:21,920
avoid copies all together and that's the

00:14:20,180 --> 00:14:23,450
case where you have one publisher and

00:14:21,920 --> 00:14:25,250
one subscriber so it's a one-to-one

00:14:23,450 --> 00:14:27,560
relationship on the topic it's not

00:14:25,250 --> 00:14:29,660
something and you can you can depend on

00:14:27,560 --> 00:14:30,620
but in the in that case the middleware

00:14:29,660 --> 00:14:34,550
will do the most efficient thing

00:14:30,620 --> 00:14:40,100
possible so I'm gonna run a demo really

00:14:34,550 --> 00:14:43,450
quick ok Dirk's gonna do it so this is a

00:14:40,100 --> 00:14:45,530
really simple toy problem that I set up

00:14:43,450 --> 00:14:47,120
so we're going to run it for like a

00:14:45,530 --> 00:14:50,920
second or two and then I'll get dirt to

00:14:47,120 --> 00:14:50,920
stop it so Dukey go ahead and stop it

00:14:52,360 --> 00:14:58,430
okay so it's a little bit hard to read

00:14:56,150 --> 00:14:59,870
with this resolution but if you look the

00:14:58,430 --> 00:15:02,540
first thing that happens is we say I'm

00:14:59,870 --> 00:15:05,360
gonna publish the first value of 42 with

00:15:02,540 --> 00:15:07,100
a pointer address of that hex value and

00:15:05,360 --> 00:15:08,630
then it sleeps for a second and then it

00:15:07,100 --> 00:15:10,910
increments the value and publishes it

00:15:08,630 --> 00:15:13,430
again sees now we have a 43 and it's the

00:15:10,910 --> 00:15:15,680
same pointer and the point is is that we

00:15:13,430 --> 00:15:17,630
receive a message we wait a second we

00:15:15,680 --> 00:15:20,220
increment we publish it again and it has

00:15:17,630 --> 00:15:24,450
the same address all the way through

00:15:20,220 --> 00:15:28,430
and to make sense of that we'll look at

00:15:24,450 --> 00:15:30,540
the code a little bit so I've tried to

00:15:28,430 --> 00:15:32,670
slim this code down a little bit so it's

00:15:30,540 --> 00:15:35,190
easier to parse but I I'll go through it

00:15:32,670 --> 00:15:36,810
really quickly so we have basically a

00:15:35,190 --> 00:15:38,640
struct or a class here

00:15:36,810 --> 00:15:41,460
that's inheriting from the node class

00:15:38,640 --> 00:15:45,030
and in the C++ client library for Ross

00:15:41,460 --> 00:15:47,250
too so it's it's overriding the built in

00:15:45,030 --> 00:15:49,020
function in some places so we have like

00:15:47,250 --> 00:15:51,090
a constructor that takes a name an input

00:15:49,020 --> 00:15:53,580
topic and an output topic and then this

00:15:51,090 --> 00:15:55,170
code I have here is the callback for

00:15:53,580 --> 00:15:56,610
when it receives a message on the input

00:15:55,170 --> 00:15:58,830
topic so you can see it receives a

00:15:56,610 --> 00:16:00,840
unique pointer it prints out the value

00:15:58,830 --> 00:16:03,120
and the address of that pointer it waits

00:16:00,840 --> 00:16:05,460
for a second it increments the value of

00:16:03,120 --> 00:16:08,130
the data publishes what that value and

00:16:05,460 --> 00:16:09,780
pointer is and and publishes it along to

00:16:08,130 --> 00:16:12,210
the output topic and where this gets

00:16:09,780 --> 00:16:13,830
interesting is is looking at the custom

00:16:12,210 --> 00:16:15,840
main file I've written for this example

00:16:13,830 --> 00:16:18,000
so what's happening is I'm creating two

00:16:15,840 --> 00:16:19,680
instances of this class with different

00:16:18,000 --> 00:16:21,750
input and output topics such as a form

00:16:19,680 --> 00:16:23,610
of cycles so if one of them receives on

00:16:21,750 --> 00:16:26,910
topic one and outputs on topic two and

00:16:23,610 --> 00:16:28,230
one of them receives on topic two and

00:16:26,910 --> 00:16:30,390
outputs on topic one and they have

00:16:28,230 --> 00:16:32,250
different names and then so I create one

00:16:30,390 --> 00:16:34,890
of each of those and then I start the

00:16:32,250 --> 00:16:36,690
cycle off by calling the publish

00:16:34,890 --> 00:16:38,970
function on the publisher inside of the

00:16:36,690 --> 00:16:41,340
first class with an initial value and

00:16:38,970 --> 00:16:42,960
message and then I just add them to an

00:16:41,340 --> 00:16:44,970
executor and call spin this is equip

00:16:42,960 --> 00:16:47,220
this is how you would do multiple nodes

00:16:44,970 --> 00:16:51,390
this is equivalent of Ross spin for

00:16:47,220 --> 00:16:53,160
multiple nodes essentially but so the

00:16:51,390 --> 00:16:54,480
result of that is is that these things

00:16:53,160 --> 00:16:56,010
you know I kick it off with that first

00:16:54,480 --> 00:16:57,360
publish and it goes round and round in a

00:16:56,010 --> 00:16:59,850
circle always we're using the same

00:16:57,360 --> 00:17:01,500
message and every allocating and so this

00:16:59,850 --> 00:17:02,910
is kind of just a it's not really

00:17:01,500 --> 00:17:04,500
something I expect people to do in

00:17:02,910 --> 00:17:05,730
practice but it sort of demonstrates the

00:17:04,500 --> 00:17:10,589
middlewares to being as efficient as

00:17:05,730 --> 00:17:12,000
possible in that case so that case it's

00:17:10,589 --> 00:17:13,890
kind of interesting so what can we say

00:17:12,000 --> 00:17:16,380
about using unique pointers in this way

00:17:13,890 --> 00:17:17,910
so it can help us make efficient

00:17:16,380 --> 00:17:19,500
pipelines in the case that it's

00:17:17,910 --> 00:17:21,329
one-to-one again it's not something you

00:17:19,500 --> 00:17:23,790
rely on because somebody adds

00:17:21,329 --> 00:17:24,810
introspection within the same process

00:17:23,790 --> 00:17:26,860
you might not have that relationship

00:17:24,810 --> 00:17:30,370
anymore but it will be

00:17:26,860 --> 00:17:31,600
form it when you have that scenario it's

00:17:30,370 --> 00:17:32,590
not always the preferred signature

00:17:31,600 --> 00:17:34,000
sometimes you want to use shared

00:17:32,590 --> 00:17:35,470
pointers and we should support that too

00:17:34,000 --> 00:17:38,320
but maybe it shouldn't be the default

00:17:35,470 --> 00:17:39,970
behavior perhaps the the semantic break

00:17:38,320 --> 00:17:42,010
from Ross one should be that if you

00:17:39,970 --> 00:17:43,900
publish a SharePoint by default it makes

00:17:42,010 --> 00:17:45,220
a copy rather than having this implicit

00:17:43,900 --> 00:17:46,510
agreement and if you want to do that

00:17:45,220 --> 00:17:48,370
implicit agreement where you give it a

00:17:46,510 --> 00:17:49,900
shared pointer it doesn't copy it you

00:17:48,370 --> 00:17:52,059
need to tell it that's what you want to

00:17:49,900 --> 00:17:54,549
do it needs to be explicit and this

00:17:52,059 --> 00:17:56,380
really matters in percent in situations

00:17:54,549 --> 00:17:57,910
where you want to have really high

00:17:56,380 --> 00:17:59,650
performance publish/subscribe but you

00:17:57,910 --> 00:18:01,330
want to preserve the behavior between

00:17:59,650 --> 00:18:05,080
Android process and Inter process and

00:18:01,330 --> 00:18:07,090
you want to minimize copying of data and

00:18:05,080 --> 00:18:08,440
just quickly about the consistency

00:18:07,090 --> 00:18:11,320
between the two

00:18:08,440 --> 00:18:12,760
you know I explained how in intra

00:18:11,320 --> 00:18:14,140
process in Ross one when you call

00:18:12,760 --> 00:18:15,700
publish that goes through to the

00:18:14,140 --> 00:18:18,250
callbacks that are connected to that

00:18:15,700 --> 00:18:19,540
within the same process that's starkly

00:18:18,250 --> 00:18:20,980
different from what happens in inter

00:18:19,540 --> 00:18:23,590
process where you call publish it's

00:18:20,980 --> 00:18:25,540
always blocking and I think that should

00:18:23,590 --> 00:18:27,070
be preserved and we we work around that

00:18:25,540 --> 00:18:28,720
with a different way of implementing an

00:18:27,070 --> 00:18:31,120
intra process if you want more details

00:18:28,720 --> 00:18:34,600
about that we can talk about later and

00:18:31,120 --> 00:18:36,280
so next thing we want to do is make the

00:18:34,600 --> 00:18:38,049
make the inter process implementation a

00:18:36,280 --> 00:18:40,179
little more intelligent so that it can

00:18:38,049 --> 00:18:42,100
be as efficient as possible in every

00:18:40,179 --> 00:18:43,510
scenario including when you're giving it

00:18:42,100 --> 00:18:45,880
shared pointers a set of unique partners

00:18:43,510 --> 00:18:47,140
and things like that and really take a

00:18:45,880 --> 00:18:48,730
hard look at the implementation we have

00:18:47,140 --> 00:18:50,590
for the intra process and make sure it

00:18:48,730 --> 00:18:53,520
works for cases like real time and

00:18:50,590 --> 00:18:56,350
static allocation and stuff like that

00:18:53,520 --> 00:18:57,549
and we still have some work to do and

00:18:56,350 --> 00:18:59,080
some other features like tank

00:18:57,549 --> 00:19:01,450
masquerading which is like when you want

00:18:59,080 --> 00:19:04,150
to publish a custom type like an open CV

00:19:01,450 --> 00:19:07,570
map or a PCL point-cloud rather than our

00:19:04,150 --> 00:19:09,760
generated code types and we need to work

00:19:07,570 --> 00:19:11,080
on running multiple nodes in a single

00:19:09,760 --> 00:19:14,110
process adding infrastructure to make

00:19:11,080 --> 00:19:15,400
that easy to do and convenient and then

00:19:14,110 --> 00:19:17,820
finally I'm going to pass off to my

00:19:15,400 --> 00:19:17,820
colleague

00:19:19,760 --> 00:19:30,860
hi sorry for the voice I'm not I'm not a

00:19:24,820 --> 00:19:33,710
100% today but that's fine I'm a Shiva

00:19:30,860 --> 00:19:40,010
and I happen to work outdoors RF as well

00:19:33,710 --> 00:19:43,690
on roster as well so I'm gonna talk I'm

00:19:40,010 --> 00:19:48,820
gonna talk about quality of service in

00:19:43,690 --> 00:19:53,000
bross - sir I'm gonna give you a bit of

00:19:48,820 --> 00:19:56,180
context about what we mean by quality of

00:19:53,000 --> 00:19:59,510
service and what's the status of quality

00:19:56,180 --> 00:20:03,350
of service in Ross watt so in the

00:19:59,510 --> 00:20:08,090
networking spectrum we got on one end

00:20:03,350 --> 00:20:10,480
UDP which is connectionless and that

00:20:08,090 --> 00:20:13,070
means that there's no acknowledgment

00:20:10,480 --> 00:20:18,110
whether a package has arrived to the

00:20:13,070 --> 00:20:23,390
other end or not on the other end of the

00:20:18,110 --> 00:20:25,190
spectrum we got TCP which and the

00:20:23,390 --> 00:20:28,550
contrary gives you a knowledge man

00:20:25,190 --> 00:20:36,470
whether a packet has arrived

00:20:28,550 --> 00:20:39,890
it'll retry and so on but but DDS by

00:20:36,470 --> 00:20:43,730
using DDS we can we can gain we can have

00:20:39,890 --> 00:20:46,430
access to more gun writing between the

00:20:43,730 --> 00:20:51,470
tube because it is implemented on top of

00:20:46,430 --> 00:20:54,890
UDP and - in order to have this general

00:20:51,470 --> 00:20:57,230
idea he here the DDS implements

00:20:54,890 --> 00:21:05,110
reliability on top of UDP we'll see how

00:20:57,230 --> 00:21:11,030
this is important later but we'll see

00:21:05,110 --> 00:21:14,320
okay so what's the status off of quality

00:21:11,030 --> 00:21:17,540
of service in Ross Wan we got we got

00:21:14,320 --> 00:21:20,570
quite a few options in Russ Wan which

00:21:17,540 --> 00:21:25,520
were not which we're added as an

00:21:20,570 --> 00:21:29,090
afterthought like UDP Ross which is

00:21:25,520 --> 00:21:33,540
great for best effort disappear oz which

00:21:29,090 --> 00:21:36,990
is the standard protocol in Ross Wan

00:21:33,540 --> 00:21:41,640
which it which makes police describe

00:21:36,990 --> 00:21:43,890
reliable will well the problem with this

00:21:41,640 --> 00:21:48,710
is that good it'd be Ross doesn't talk

00:21:43,890 --> 00:21:53,670
to to soupy Ross so it's all or nothing

00:21:48,710 --> 00:21:59,100
you you make your network all of all of

00:21:53,670 --> 00:22:02,070
your subscribers best effort or reliable

00:21:59,100 --> 00:22:07,230
there's no middle ground

00:22:02,070 --> 00:22:10,370
queuing with with rust you we got we got

00:22:07,230 --> 00:22:13,050
also got kind of the castle of queuing

00:22:10,370 --> 00:22:16,860
but fear and also we can also store all

00:22:13,050 --> 00:22:19,730
the messages that that subscribe that a

00:22:16,860 --> 00:22:25,250
data writer the rate data reader

00:22:19,730 --> 00:22:28,130
receives or data writer writes and

00:22:25,250 --> 00:22:32,360
latching watching more or less

00:22:28,130 --> 00:22:35,670
translates to durability in brass tube

00:22:32,360 --> 00:22:40,650
latching is a feature that it's a bit

00:22:35,670 --> 00:22:42,650
little-known which well if it allows you

00:22:40,650 --> 00:22:47,700
to implement storing forward

00:22:42,650 --> 00:22:52,860
semantics besides this there's more QoS

00:22:47,700 --> 00:22:55,130
Capaldi's in Ross to thanks to DDS but

00:22:52,860 --> 00:22:58,500
this is more or less like a mapping of

00:22:55,130 --> 00:23:04,100
not one-to-one mapping between Ross Juan

00:22:58,500 --> 00:23:06,720
and roster but it gets the point so

00:23:04,100 --> 00:23:11,700
there's the thing we've said for the

00:23:06,720 --> 00:23:13,620
last year and a half that by not using

00:23:11,700 --> 00:23:16,350
but not implement our own communication

00:23:13,620 --> 00:23:19,260
protocol and by delegating all that

00:23:16,350 --> 00:23:23,900
stuff to DDS we can focus on others and

00:23:19,260 --> 00:23:27,720
all things well it's the same with POS

00:23:23,900 --> 00:23:31,980
we have any plan Takeo as ourselves we

00:23:27,720 --> 00:23:35,880
just let it let it to the DDS vendor the

00:23:31,980 --> 00:23:38,550
underlying DES vendor to handle all

00:23:35,880 --> 00:23:40,890
that's all that stuff which is great

00:23:38,550 --> 00:23:44,450
because for example we don't have to

00:23:40,890 --> 00:23:44,450
document it thoroughly

00:23:44,670 --> 00:23:52,000
it's a it's documented and your DDS

00:23:49,270 --> 00:23:55,030
vendor of choice it's also part of the

00:23:52,000 --> 00:23:59,790
standard so you get the kind of the same

00:23:55,030 --> 00:23:59,790
behavior whatever vendor we are using

00:24:00,120 --> 00:24:08,260
the other thing that I mentioned is the

00:24:02,559 --> 00:24:10,780
DDS is built on top of UDP why is why is

00:24:08,260 --> 00:24:13,270
it so important well it's a it's so

00:24:10,780 --> 00:24:15,820
important cuz you can also have

00:24:13,270 --> 00:24:19,270
multicast which is not implemented

00:24:15,820 --> 00:24:20,050
either in UDP roz and obviously not into

00:24:19,270 --> 00:24:24,460
spiritus

00:24:20,050 --> 00:24:28,830
that's that wouldn't be possible why is

00:24:24,460 --> 00:24:33,100
it important because in a pub sub

00:24:28,830 --> 00:24:36,240
framework like Ross not making extra

00:24:33,100 --> 00:24:40,080
copies of the message to each and every

00:24:36,240 --> 00:24:45,630
subscriber it's kind of a big deal

00:24:40,080 --> 00:24:45,630
it makes your network less congested and

00:24:46,080 --> 00:24:53,350
and that's always a good thing obviously

00:24:49,080 --> 00:24:58,990
and all of this is motivated by our goal

00:24:53,350 --> 00:25:03,300
of reaching more users there Rozlyn was

00:24:58,990 --> 00:25:08,320
built with PR - with the pho in mind

00:25:03,300 --> 00:25:13,030
obviously rusty Ross one has has been

00:25:08,320 --> 00:25:16,600
ported to other robots but but always a

00:25:13,030 --> 00:25:21,280
bit of an afterthought so with Ross - we

00:25:16,600 --> 00:25:26,020
want to tap into all these robots like

00:25:21,280 --> 00:25:27,640
drones drones use unreliable networks so

00:25:26,020 --> 00:25:33,010
that's why it's so important to have

00:25:27,640 --> 00:25:36,840
quality of service the Internet of

00:25:33,010 --> 00:25:40,420
Things requires efficient multicast and

00:25:36,840 --> 00:25:44,280
high latency links you know if you have

00:25:40,420 --> 00:25:44,280
a robot in space for example

00:25:44,840 --> 00:25:49,220
I don't know who would put drawers in a

00:25:47,510 --> 00:25:51,409
robot in space

00:25:49,220 --> 00:25:57,200
probably the same folks you say that

00:25:51,409 --> 00:26:01,750
there's water in Mars I don't so you got

00:25:57,200 --> 00:26:04,880
a hitch latency as you can expect so

00:26:01,750 --> 00:26:07,820
that's also that's also important to

00:26:04,880 --> 00:26:09,950
have quality of service in that case to

00:26:07,820 --> 00:26:14,630
control didn't air the behavior of the

00:26:09,950 --> 00:26:18,710
network much better so I'm gonna show it

00:26:14,630 --> 00:26:28,010
true that most actually Derek is gonna

00:26:18,710 --> 00:26:32,830
show them yeah so we're gonna simulate

00:26:28,010 --> 00:26:37,580
we're gonna simulate that there's 25% of

00:26:32,830 --> 00:26:40,940
packet loss we all know that localhost

00:26:37,580 --> 00:26:45,490
is the only reliable network so we're

00:26:40,940 --> 00:26:48,980
gonna simulate that so as you can see

00:26:45,490 --> 00:26:52,330
there's kind of a bit of latency in this

00:26:48,980 --> 00:26:57,080
this demo is what Ross Swann would do

00:26:52,330 --> 00:26:59,570
with disappearance all the images all

00:26:57,080 --> 00:27:02,679
image to all the frames are sent are

00:26:59,570 --> 00:27:07,549
polished and all the frames are are

00:27:02,679 --> 00:27:09,950
acknowledged that means that you'll get

00:27:07,549 --> 00:27:15,020
all the frames obviously but at the

00:27:09,950 --> 00:27:19,100
expense of at the expense of having a

00:27:15,020 --> 00:27:23,120
high latency so we are going to show how

00:27:19,100 --> 00:27:27,110
with a reliable with using best effort

00:27:23,120 --> 00:27:31,070
you know well there's some frames being

00:27:27,110 --> 00:27:36,649
dropped but video becomes more fluid and

00:27:31,070 --> 00:27:40,580
here's a cool thing the the window on

00:27:36,649 --> 00:27:45,190
the left it's always been a reliable

00:27:40,580 --> 00:27:48,559
publisher but the window on the right

00:27:45,190 --> 00:27:51,230
it's a it's a subscriber that's using

00:27:48,559 --> 00:27:54,530
best effort that's something you cannot

00:27:51,230 --> 00:27:57,470
have in Ross one you cannot have UDP

00:27:54,530 --> 00:27:59,120
Ross talk to you disappear us

00:27:57,470 --> 00:28:01,789
obviously because there are different

00:27:59,120 --> 00:28:04,669
protocols but in this case both are

00:28:01,789 --> 00:28:08,600
using UDP with different quality of

00:28:04,669 --> 00:28:10,250
service settings and and you may and why

00:28:08,600 --> 00:28:14,450
is this important well if you have a

00:28:10,250 --> 00:28:20,600
sensor and you you care more about

00:28:14,450 --> 00:28:23,539
having the readings quickly at the

00:28:20,600 --> 00:28:31,789
expense of losing some that's that's

00:28:23,539 --> 00:28:33,860
what you would want you to use so how do

00:28:31,789 --> 00:28:37,659
you well there's a second demo that we

00:28:33,860 --> 00:28:41,690
just sew so how do you access key os

00:28:37,659 --> 00:28:44,690
through the Ross to API well we came up

00:28:41,690 --> 00:28:48,169
with this and when I say we can map week

00:28:44,690 --> 00:28:53,419
more or less were inspired by the DDS

00:28:48,169 --> 00:28:59,779
spec which is key OS profiles qsr

00:28:53,419 --> 00:29:03,200
profiles okay sure sure I think this Oh

00:28:59,779 --> 00:29:08,049
what this is the last mile on slides

00:29:03,200 --> 00:29:12,799
okay so qsr profiles our set of qsr

00:29:08,049 --> 00:29:17,210
policies that provide all these QoS

00:29:12,799 --> 00:29:19,460
settings we have we have we have a set

00:29:17,210 --> 00:29:21,830
of predefined profiles that you may use

00:29:19,460 --> 00:29:25,129
off the shelf

00:29:21,830 --> 00:29:27,049
we are still tweaking these values the

00:29:25,129 --> 00:29:29,440
values for these profiles we want to

00:29:27,049 --> 00:29:32,960
receive feedback from the community and

00:29:29,440 --> 00:29:35,629
more use cases because obviously we

00:29:32,960 --> 00:29:42,019
cannot test this and all the use cases

00:29:35,629 --> 00:29:44,210
you guys won t use roster and and

00:29:42,019 --> 00:29:47,539
obviously because there's people who are

00:29:44,210 --> 00:29:49,460
our people have already using DDS we

00:29:47,539 --> 00:29:54,200
don't want we don't want to disrupt

00:29:49,460 --> 00:29:57,220
their deployment so at all times you can

00:29:54,200 --> 00:30:00,649
still pass system the fall option and

00:29:57,220 --> 00:30:04,639
you can use your own the the tools that

00:30:00,649 --> 00:30:08,210
come with the DDS vendor to tweak the

00:30:04,639 --> 00:30:12,340
QoS settings and we want to be we want

00:30:08,210 --> 00:30:12,340
getting your way that's it

00:30:13,780 --> 00:30:19,610
all right now we get to the next demo

00:30:16,070 --> 00:30:22,310
that's also the last so we do have now

00:30:19,610 --> 00:30:24,080
some prototype for us - it has a lot of

00:30:22,310 --> 00:30:26,450
new feeder mean features especially a

00:30:24,080 --> 00:30:28,550
superior communication protocol but

00:30:26,450 --> 00:30:30,020
there's one with all tools and all the

00:30:28,550 --> 00:30:33,260
existing functionalities so how do we

00:30:30,020 --> 00:30:34,790
get that together so imagine you have a

00:30:33,260 --> 00:30:37,340
roast to publisher which publishes

00:30:34,790 --> 00:30:39,230
images and you have a cross one tool

00:30:37,340 --> 00:30:41,570
like our QT which already subscribes to

00:30:39,230 --> 00:30:42,890
images provides a UI and everything how

00:30:41,570 --> 00:30:45,710
can you make them like talk to each

00:30:42,890 --> 00:30:48,170
other and one approach we currently the

00:30:45,710 --> 00:30:50,330
worked on is like a network bridge which

00:30:48,170 --> 00:30:53,270
will like sit as a separate process and

00:30:50,330 --> 00:30:56,090
it actually is a Ross one node as well

00:30:53,270 --> 00:30:58,400
as a Ross - node at the same time and it

00:30:56,090 --> 00:31:00,650
looks at the Ross master and at the DDS

00:30:58,400 --> 00:31:03,110
discovery protocol to check what topics

00:31:00,650 --> 00:31:04,910
are available and when things it finds

00:31:03,110 --> 00:31:08,060
two matching topics which it can like

00:31:04,910 --> 00:31:11,150
exchange it just signs up on one side

00:31:08,060 --> 00:31:12,380
and publishes on the other side and in

00:31:11,150 --> 00:31:25,310
order to show you that that's not only

00:31:12,380 --> 00:31:29,470
like thank you since we use Ross one we

00:31:25,310 --> 00:31:32,420
have to start the raw score as always I

00:31:29,470 --> 00:31:34,700
start the bridge in the second one a lot

00:31:32,420 --> 00:31:36,860
of windows here first I just so show

00:31:34,700 --> 00:31:41,930
Ross one node which is published in the

00:31:36,860 --> 00:31:45,040
images and rqt as you might have used

00:31:41,930 --> 00:31:55,600
already which should show us the images

00:31:45,040 --> 00:31:55,600
oh well that's me

00:31:55,629 --> 00:32:00,369
so you're gonna like stop the other one

00:32:01,600 --> 00:32:08,629
and now instead of using Ross one node

00:32:05,779 --> 00:32:12,529
I'll start in the last window node which

00:32:08,629 --> 00:32:13,789
is the Ross - note publishing images and

00:32:12,529 --> 00:32:16,850
you're gonna trust us the screen is

00:32:13,789 --> 00:32:28,879
again here no seriously I showed it

00:32:16,850 --> 00:32:30,529
briefly I want to show also that you can

00:32:28,879 --> 00:32:32,629
basically also have a back topic so you

00:32:30,529 --> 00:32:34,460
can send a message back and that gets

00:32:32,629 --> 00:32:35,389
transferred from the Ross one node back

00:32:34,460 --> 00:32:38,440
to the Ross two notes so it's

00:32:35,389 --> 00:32:38,440
bi-directional if you want

00:32:46,210 --> 00:32:51,560
alright so the technical background for

00:32:50,150 --> 00:32:53,630
that is currently the bridge is

00:32:51,560 --> 00:32:56,420
implemented in C++ simply because we

00:32:53,630 --> 00:32:58,820
don't have any Python code yet how it

00:32:56,420 --> 00:33:00,410
works it uses the Ross the Roskam has G

00:32:58,820 --> 00:33:02,660
API it's a Python package and Ross one

00:33:00,410 --> 00:33:04,670
to find all messages it's kind of I

00:33:02,660 --> 00:33:07,310
believe calls your file system finds all

00:33:04,670 --> 00:33:08,840
dot MSG files take some time and Russ -

00:33:07,310 --> 00:33:10,580
we have worked on that to improve the

00:33:08,840 --> 00:33:13,010
look up so you basically look up at an

00:33:10,580 --> 00:33:15,340
index but generated compile time so no

00:33:13,010 --> 00:33:17,300
crawling anymore one of the benefits

00:33:15,340 --> 00:33:19,040
another one of the other benefits from

00:33:17,300 --> 00:33:21,710
Ross - over Ross one which goes beyond

00:33:19,040 --> 00:33:23,690
like usually just using DDS then the

00:33:21,710 --> 00:33:26,690
bridge looks at other us1 types and the

00:33:23,690 --> 00:33:30,400
last two times and based based on some

00:33:26,690 --> 00:33:32,750
automatic rules for example same name it

00:33:30,400 --> 00:33:35,210
considers some of them to be like pairs

00:33:32,750 --> 00:33:36,770
you can also customize that if you have

00:33:35,210 --> 00:33:39,620
like a specific mapping which is not

00:33:36,770 --> 00:33:41,660
covered by the automatic rule and it

00:33:39,620 --> 00:33:44,360
generates code to transform transform

00:33:41,660 --> 00:33:44,780
ross11 messages into rows - and vice

00:33:44,360 --> 00:33:46,790
versa

00:33:44,780 --> 00:33:48,680
and afterwards you build an executable

00:33:46,790 --> 00:33:53,390
which basically is compiled against Ross

00:33:48,680 --> 00:33:55,730
CVP in Ross one C++ library or our CLC P

00:33:53,390 --> 00:33:57,680
which is the Russ - equivalent one

00:33:55,730 --> 00:33:59,630
challenge for that since this is all C++

00:33:57,680 --> 00:34:01,430
you need to include all your headers and

00:33:59,630 --> 00:34:04,160
all these headers must be not colliding

00:34:01,430 --> 00:34:06,110
so if we've been careful but until now

00:34:04,160 --> 00:34:08,899
to like have different namespaces for

00:34:06,110 --> 00:34:12,230
new classes in order to be able to build

00:34:08,899 --> 00:34:14,629
a program like this then a short

00:34:12,230 --> 00:34:16,220
sentence on the roadmap I don't know how

00:34:14,629 --> 00:34:19,070
many of noticed but we announced earlier

00:34:16,220 --> 00:34:20,810
this month sorry last month the alpha

00:34:19,070 --> 00:34:23,899
one release which was the first time we

00:34:20,810 --> 00:34:25,730
did like a release of Ross - which was

00:34:23,899 --> 00:34:27,679
one big archive with all the demos and

00:34:25,730 --> 00:34:31,460
tutorials you can go to the wiki page

00:34:27,679 --> 00:34:33,110
and just try them out we have also put

00:34:31,460 --> 00:34:34,940
together a road map where you described

00:34:33,110 --> 00:34:38,510
what upcoming features we will work on

00:34:34,940 --> 00:34:40,310
next and also what other features are we

00:34:38,510 --> 00:34:43,490
have planned and in which order we might

00:34:40,310 --> 00:34:46,010
want to tackle them and for example the

00:34:43,490 --> 00:34:48,860
next work items for the alpha 2 is we

00:34:46,010 --> 00:34:50,409
focus on component lifecycle that you

00:34:48,860 --> 00:34:53,480
can also introspect that life cycle

00:34:50,409 --> 00:34:54,919
through the service for example and you

00:34:53,480 --> 00:34:57,060
can orchestrate us so you can change

00:34:54,919 --> 00:34:59,610
style change States remotely

00:34:57,060 --> 00:35:02,340
we use things we have from Ross one like

00:34:59,610 --> 00:35:04,380
class load and plugin lib and also make

00:35:02,340 --> 00:35:05,820
the lounge system use that so actually

00:35:04,380 --> 00:35:08,310
be able to have a lounge file which

00:35:05,820 --> 00:35:10,590
starts multiple notes waits until they

00:35:08,310 --> 00:35:11,430
are all initialized and every network

00:35:10,590 --> 00:35:13,740
connected connection has been

00:35:11,430 --> 00:35:16,440
established and then start them which is

00:35:13,740 --> 00:35:18,510
makes it way more predictable and other

00:35:16,440 --> 00:35:20,550
topics are continuing to work on some

00:35:18,510 --> 00:35:22,800
technical challenge in C++ which we

00:35:20,550 --> 00:35:25,920
currently facing and then also revisit

00:35:22,800 --> 00:35:29,100
the C API and try to make a first API

00:35:25,920 --> 00:35:30,900
implemented Python implementation two

00:35:29,100 --> 00:35:33,000
other related presentations you always

00:35:30,900 --> 00:35:34,860
saw the first one this morning from

00:35:33,000 --> 00:35:38,040
Morgan inaudible embedded systems for us

00:35:34,860 --> 00:35:40,980
to and after this one you will see the

00:35:38,040 --> 00:35:42,240
talk about real time from Jackie if you

00:35:40,980 --> 00:35:44,880
want to get the slides you can just scan

00:35:42,240 --> 00:35:47,930
the QR code and I'm happy to take some

00:35:44,880 --> 00:35:47,930
questions or we are

00:35:51,290 --> 00:35:55,180
the question is

00:35:52,900 --> 00:35:56,770
the API is partially different is there

00:35:55,180 --> 00:35:59,050
a way to like migrate existing code

00:35:56,770 --> 00:36:02,320
automatically through some tool which

00:35:59,050 --> 00:36:05,920
does all that the answer for that is we

00:36:02,320 --> 00:36:08,200
don't know yet because a the API is not

00:36:05,920 --> 00:36:11,080
finished yet we we have like a first

00:36:08,200 --> 00:36:12,250
prototype version but there is no reason

00:36:11,080 --> 00:36:13,990
to believe that that's like the final

00:36:12,250 --> 00:36:15,880
result we can always tweak them based on

00:36:13,990 --> 00:36:17,350
feedback because it's the more we

00:36:15,880 --> 00:36:18,730
develop on top the more we will learn

00:36:17,350 --> 00:36:24,520
from it

00:36:18,730 --> 00:36:26,620
and the other part is the migration

00:36:24,520 --> 00:36:30,160
would be one step but we try to make it

00:36:26,620 --> 00:36:31,750
probably on top of the API we imagine we

00:36:30,160 --> 00:36:33,970
probably put an API which is very

00:36:31,750 --> 00:36:35,740
similar to the Rosco API to let you keep

00:36:33,970 --> 00:36:37,720
most of your code as like a backward

00:36:35,740 --> 00:36:39,610
compatibility layer but that needs to be

00:36:37,720 --> 00:36:42,190
figured out how much can we abstract and

00:36:39,610 --> 00:36:43,570
how much changes is necessary and it's I

00:36:42,190 --> 00:36:46,990
think that's currently on the list for

00:36:43,570 --> 00:36:49,270
the Alpha 3 so after that package the

00:36:46,990 --> 00:36:51,490
next iteration and then we have to look

00:36:49,270 --> 00:36:53,740
in can we cover those changes by like a

00:36:51,490 --> 00:36:55,930
tool I mean we've seen other projects

00:36:53,740 --> 00:36:58,540
doing this like qts 3 to 4 was a nice

00:36:55,930 --> 00:36:59,620
tool to convert existing QT 3 code so I

00:36:58,540 --> 00:37:02,790
think something like that is definitely

00:36:59,620 --> 00:37:06,460
possible do we cover a hundred percent

00:37:02,790 --> 00:37:09,340
we'll see I would just add to that that

00:37:06,460 --> 00:37:10,780
the static conversion may be possible

00:37:09,340 --> 00:37:12,490
but we have to be really careful and

00:37:10,780 --> 00:37:14,710
maybe this is parts where QT three

00:37:12,490 --> 00:37:16,360
didn't do for parts of - QT 4 because

00:37:14,710 --> 00:37:17,890
there might be semantic differences like

00:37:16,360 --> 00:37:20,020
when I talked about the changes in inter

00:37:17,890 --> 00:37:21,370
process publishing like the API could

00:37:20,020 --> 00:37:23,560
certainly be adapted but that behavior

00:37:21,370 --> 00:37:25,870
may not be the same and so like we may

00:37:23,560 --> 00:37:27,430
have the tool like say flag it and say

00:37:25,870 --> 00:37:28,750
you need to look at this yourself and

00:37:27,430 --> 00:37:32,770
here's a document it tells you why you

00:37:28,750 --> 00:37:37,140
need to look at it but yeah other

00:37:32,770 --> 00:37:37,140
questions over there

00:37:38,970 --> 00:37:46,770
I believe the question was will Ross to

00:37:42,900 --> 00:37:48,119
support inter-process shared memory as

00:37:46,770 --> 00:37:50,670
in like the operating system shared

00:37:48,119 --> 00:37:53,400
memory that's actually handled by the

00:37:50,670 --> 00:37:55,349
middleware so for example opensplice and

00:37:53,400 --> 00:37:57,720
connects both and I think are faster

00:37:55,349 --> 00:38:00,869
OTPs as well they all have a shared

00:37:57,720 --> 00:38:02,670
memory shortcut but that's below us so

00:38:00,869 --> 00:38:05,490
basically we're going to do shortcuts in

00:38:02,670 --> 00:38:07,170
the in process intra process step and

00:38:05,490 --> 00:38:08,640
the middleware would be up it would be

00:38:07,170 --> 00:38:12,500
up to the middleware to do shared memory

00:38:08,640 --> 00:38:12,500
but they do implement it most of them

00:38:12,589 --> 00:38:17,280
because another advantage which William

00:38:15,450 --> 00:38:19,410
described was a short cutting it just by

00:38:17,280 --> 00:38:20,790
passing a pointer is like you don't need

00:38:19,410 --> 00:38:21,780
to do serialization if you use like

00:38:20,790 --> 00:38:29,390
shared memory you still have a

00:38:21,780 --> 00:38:29,390
civilizations tab more questions yeah

00:38:41,720 --> 00:38:47,100
so the question was we have different we

00:38:45,060 --> 00:38:48,990
will have different api's besides C++

00:38:47,100 --> 00:38:50,250
like C and Python if we can generate

00:38:48,990 --> 00:38:52,800
them and don't have to write them

00:38:50,250 --> 00:38:54,690
manually so I think there's there's one

00:38:52,800 --> 00:38:55,980
very different saying in Ross too then

00:38:54,690 --> 00:38:58,110
in Ross one in Ross one it was like

00:38:55,980 --> 00:38:59,910
every language was built like completely

00:38:58,110 --> 00:39:01,230
native so Python was a completely Python

00:38:59,910 --> 00:39:04,710
implementation Java we heard before

00:39:01,230 --> 00:39:07,800
completely Java implementation for us to

00:39:04,710 --> 00:39:08,610
I think the goal is to allow us to not

00:39:07,800 --> 00:39:11,430
do that again

00:39:08,610 --> 00:39:13,950
so most of the experimentation currently

00:39:11,430 --> 00:39:16,980
C++ but will probably push a few of that

00:39:13,950 --> 00:39:20,550
in C or at least rip it and C API and

00:39:16,980 --> 00:39:22,440
then try to use bindings for Python but

00:39:20,550 --> 00:39:24,060
I don't think it will all be generated I

00:39:22,440 --> 00:39:25,410
think there's always like some part

00:39:24,060 --> 00:39:27,390
which you want to make like more

00:39:25,410 --> 00:39:30,120
personick because you want to have an

00:39:27,390 --> 00:39:31,560
almost native experience so maybe

00:39:30,120 --> 00:39:33,420
something like the threading you will

00:39:31,560 --> 00:39:34,880
use something in Python and not we use

00:39:33,420 --> 00:39:37,770
what you have implemented in C or C++

00:39:34,880 --> 00:39:39,840
but of course the goal is to share as

00:39:37,770 --> 00:39:49,320
much reuse as much cause as possible

00:39:39,840 --> 00:39:52,340
just to keep our effort low middle there

00:39:49,320 --> 00:39:52,340
you go I see you now

00:40:11,490 --> 00:40:15,790
yes so the question was in one of the

00:40:14,200 --> 00:40:17,890
slides we had an example where you

00:40:15,790 --> 00:40:20,829
inherited from a node class as opposed

00:40:17,890 --> 00:40:22,839
to instantiating a node and writing your

00:40:20,829 --> 00:40:24,940
own main function and using it that way

00:40:22,839 --> 00:40:27,099
and why are we changing that so

00:40:24,940 --> 00:40:28,839
basically we did have this mantra and

00:40:27,099 --> 00:40:30,040
Ross one we won't wrap your main and I

00:40:28,839 --> 00:40:31,660
think that's important and you can still

00:40:30,040 --> 00:40:32,680
do that in Ross one you can still do it

00:40:31,660 --> 00:40:34,180
like you did in Ross

00:40:32,680 --> 00:40:36,910
we had another example in the slides

00:40:34,180 --> 00:40:38,800
where we had a listener program which

00:40:36,910 --> 00:40:40,180
had its own main and we had a Ross two

00:40:38,800 --> 00:40:42,940
version of that that was very similar

00:40:40,180 --> 00:40:46,240
but the point is is that we would we

00:40:42,940 --> 00:40:48,309
would like to propose encouraging people

00:40:46,240 --> 00:40:50,890
to do it as inheritance from a class

00:40:48,309 --> 00:40:53,589
instead the benefit being if you do that

00:40:50,890 --> 00:40:55,660
then you get to defer execution of your

00:40:53,589 --> 00:40:56,980
node and therefore you get more

00:40:55,660 --> 00:40:58,660
reusability because then you can later

00:40:56,980 --> 00:41:00,280
decide if you want to have your own main

00:40:58,660 --> 00:41:01,480
or share a main with other people there

00:41:00,280 --> 00:41:02,829
will always do the case where you need

00:41:01,480 --> 00:41:04,210
to have your own main function for

00:41:02,829 --> 00:41:05,230
whatever reason handle the road and

00:41:04,210 --> 00:41:08,020
threading and stuff and we want to

00:41:05,230 --> 00:41:09,280
enable that but for the default case you

00:41:08,020 --> 00:41:10,990
can get a lot of benefit or we can

00:41:09,280 --> 00:41:13,299
provide a lot of more benefit if we have

00:41:10,990 --> 00:41:15,250
them in more of a component style where

00:41:13,299 --> 00:41:18,849
you're like you know modifying a

00:41:15,250 --> 00:41:19,900
subclass yeah currently you have to

00:41:18,849 --> 00:41:21,099
choose that at programming coming

00:41:19,900 --> 00:41:22,299
because not--let's are the same way if

00:41:21,099 --> 00:41:23,559
you want to make a node lit you inherit

00:41:22,299 --> 00:41:25,540
from a class and that's because

00:41:23,559 --> 00:41:28,900
execution is deferred from you to the

00:41:25,540 --> 00:41:30,910
system and I'll just add that that we're

00:41:28,900 --> 00:41:32,440
adding that feature the ability to have

00:41:30,910 --> 00:41:34,420
this component model that you can

00:41:32,440 --> 00:41:36,190
inherit from if you one was based on

00:41:34,420 --> 00:41:38,200
feedback from users especially users in

00:41:36,190 --> 00:41:39,910
industries so don't wrap your main gives

00:41:38,200 --> 00:41:41,829
you the most flexibility possible which

00:41:39,910 --> 00:41:43,780
is great except when you don't want that

00:41:41,829 --> 00:41:46,809
flexibility where when what you want is

00:41:43,780 --> 00:41:49,780
a very clear way to describe a component

00:41:46,809 --> 00:41:51,339
of computation and have everybody be

00:41:49,780 --> 00:41:52,839
able to follow that model and then

00:41:51,339 --> 00:41:54,220
compose the system correctly at runtime

00:41:52,839 --> 00:41:55,510
so this is something that people had

00:41:54,220 --> 00:41:57,250
asked for but there's you absolutely

00:41:55,510 --> 00:41:59,400
don't have to use it you can write your

00:41:57,250 --> 00:42:03,059
own main function if you don't like it

00:41:59,400 --> 00:42:03,059
more questions Oh

00:42:12,770 --> 00:42:17,670
yeah so the question was what is the

00:42:15,660 --> 00:42:19,470
behavior or the interface of Ross topic

00:42:17,670 --> 00:42:21,030
list for example since there's no master

00:42:19,470 --> 00:42:22,109
anymore this is actually a really great

00:42:21,030 --> 00:42:26,460
question

00:42:22,109 --> 00:42:28,710
so with DDS because it's all distributed

00:42:26,460 --> 00:42:30,330
discovery you actually have to wait a

00:42:28,710 --> 00:42:32,700
little bit of time before you get to

00:42:30,330 --> 00:42:34,020
hear from everyone and that's sort of an

00:42:32,700 --> 00:42:35,160
experience breaker for something like

00:42:34,020 --> 00:42:37,859
Ross topic list where you want an

00:42:35,160 --> 00:42:39,480
immediate response and so we're looking

00:42:37,859 --> 00:42:40,680
at ways to fix that I think probably

00:42:39,480 --> 00:42:41,910
what we'll have is we'll probably still

00:42:40,680 --> 00:42:43,830
have something like the raw score

00:42:41,910 --> 00:42:47,250
command the difference will be that it

00:42:43,830 --> 00:42:48,630
won't be required to run nodes and stuff

00:42:47,250 --> 00:42:50,250
like that but if you have it running

00:42:48,630 --> 00:42:51,720
then Ross topic list can be faster and

00:42:50,250 --> 00:42:53,640
it can act as a service that's something

00:42:51,720 --> 00:43:00,119
we're actually still looking at you have

00:42:53,640 --> 00:43:02,160
a follow-up okay so the follow-up

00:43:00,119 --> 00:43:04,710
question was what about parameters so we

00:43:02,160 --> 00:43:06,750
just wrote a white paper or an article

00:43:04,710 --> 00:43:08,400
about about parameters and how we'd like

00:43:06,750 --> 00:43:11,400
to see them in Ross too

00:43:08,400 --> 00:43:13,200
and just quickly the gist is that we

00:43:11,400 --> 00:43:14,670
have this idea of parameters in Ross one

00:43:13,200 --> 00:43:18,090
which are static and we have dynamic

00:43:14,670 --> 00:43:19,200
reconfigure the main like conceptual

00:43:18,090 --> 00:43:20,940
difference is that and dynamic

00:43:19,200 --> 00:43:23,250
reconfigure the parameters are owned by

00:43:20,940 --> 00:43:24,869
the node and tied to the lifetime of the

00:43:23,250 --> 00:43:27,359
node we'd like to see that as the

00:43:24,869 --> 00:43:28,920
default in in Ross one there are some

00:43:27,359 --> 00:43:31,230
use cases where having a global

00:43:28,920 --> 00:43:33,450
parameter server or having parameters

00:43:31,230 --> 00:43:34,830
exist beyond the lifecycle of a process

00:43:33,450 --> 00:43:38,520
are important and we're looking at ways

00:43:34,830 --> 00:43:40,380
to to to do that without having to have

00:43:38,520 --> 00:43:42,240
a parameter server but that could be

00:43:40,380 --> 00:43:44,280
emulated with the with this design that

00:43:42,240 --> 00:43:46,650
I'm then I described basically you run a

00:43:44,280 --> 00:43:49,230
node that is the global parameter server

00:43:46,650 --> 00:43:50,609
which just accepts all changes and then

00:43:49,230 --> 00:43:53,520
you know you can basically emulate the

00:43:50,609 --> 00:43:55,800
global parameter Esteve would like we

00:43:53,520 --> 00:43:58,290
have an implementation of that white

00:43:55,800 --> 00:43:59,390
paper red we have any clue date for the

00:43:58,290 --> 00:44:01,710
pre-alpha

00:43:59,390 --> 00:44:06,000
because there are still some things that

00:44:01,710 --> 00:44:11,190
we have to iron out but you may check it

00:44:06,000 --> 00:44:13,070
out from the frost you were able all

00:44:11,190 --> 00:44:16,070
right one more question

00:44:13,070 --> 00:44:16,070
Moritz

00:44:42,060 --> 00:44:47,220
yes so the question is a general

00:44:45,420 --> 00:44:48,720
question about migration since we are

00:44:47,220 --> 00:44:50,850
breaking the API and even changing

00:44:48,720 --> 00:44:52,680
semantics of the API there will be

00:44:50,850 --> 00:44:54,750
manual labor involved in the conversion

00:44:52,680 --> 00:44:56,430
of things and the question was what do

00:44:54,750 --> 00:44:57,870
we how do we see that going forward with

00:44:56,430 --> 00:44:59,220
starting with low-level tools all the

00:44:57,870 --> 00:45:02,550
way up to things like our vision move it

00:44:59,220 --> 00:45:05,540
is that a fair summary so at least the

00:45:02,550 --> 00:45:08,340
way I see it is is that Ross Wan will

00:45:05,540 --> 00:45:10,500
will continue to be the the mainstay of

00:45:08,340 --> 00:45:12,240
most people and and Ross too will exist

00:45:10,500 --> 00:45:14,670
on the periphery and special cases where

00:45:12,240 --> 00:45:15,900
it excels I will use make use of the

00:45:14,670 --> 00:45:17,280
bridge that's why we think the bridge is

00:45:15,900 --> 00:45:19,200
so important it's so important to have

00:45:17,280 --> 00:45:21,120
an efficient bridge is it because tools

00:45:19,200 --> 00:45:23,340
like RVs and Ross bag in their early

00:45:21,120 --> 00:45:25,020
days will probably stay on Ross Wan will

00:45:23,340 --> 00:45:26,970
slowly start moving things over to Ross

00:45:25,020 --> 00:45:28,260
- but there will be more than just

00:45:26,970 --> 00:45:30,090
converting the API it'll be an

00:45:28,260 --> 00:45:31,830
opportunity to reevaluate how those

00:45:30,090 --> 00:45:33,450
tools are designed and take advantage of

00:45:31,830 --> 00:45:36,690
advantages in Ross - to make them better

00:45:33,450 --> 00:45:38,640
for example rviz could be made to use

00:45:36,690 --> 00:45:41,040
have configurations for things like

00:45:38,640 --> 00:45:42,510
unreliable that's a lot more quality of

00:45:41,040 --> 00:45:45,090
service settings so you can get a better

00:45:42,510 --> 00:45:47,190
use out of the tool things like you know

00:45:45,090 --> 00:45:50,700
things like the the navigation stack

00:45:47,190 --> 00:45:52,320
might be able to use the the multi nodes

00:45:50,700 --> 00:45:54,780
in a single process as a better design

00:45:52,320 --> 00:45:57,000
pattern things like that so I think

00:45:54,780 --> 00:45:59,150
it'll be probably a pretty slow process

00:45:57,000 --> 00:46:01,140
but we want to make it a heterogeneous

00:45:59,150 --> 00:46:02,190
system process where you can do it

00:46:01,140 --> 00:46:03,570
through attrition and you can really

00:46:02,190 --> 00:46:06,780
take the time to take advantage of the

00:46:03,570 --> 00:46:07,920
improvements in Ross - as you go at

00:46:06,780 --> 00:46:11,130
least that's the way I see it maybe

00:46:07,920 --> 00:46:12,420
other people on the team I just add that

00:46:11,130 --> 00:46:14,160
one other thing that we haven't started

00:46:12,420 --> 00:46:15,870
work on yet but that we've talked a bit

00:46:14,160 --> 00:46:18,390
about is something we're colloquially

00:46:15,870 --> 00:46:20,100
referring to as a library shim this is

00:46:18,390 --> 00:46:21,690
something you could imagine in in any

00:46:20,100 --> 00:46:22,860
language starting with C++ but you could

00:46:21,690 --> 00:46:24,150
do the same thing in Python you could

00:46:22,860 --> 00:46:26,130
take your existing it would present a

00:46:24,150 --> 00:46:27,630
Ross one API but under the hood would

00:46:26,130 --> 00:46:29,730
call into the Ross two libraries and

00:46:27,630 --> 00:46:30,990
William will remind me every time I talk

00:46:29,730 --> 00:46:32,400
about this that there would be caveats

00:46:30,990 --> 00:46:34,890
on what exactly the behavior of the

00:46:32,400 --> 00:46:36,360
system would be but the idea is that we

00:46:34,890 --> 00:46:39,390
can give you qualitatively the same

00:46:36,360 --> 00:46:41,010
behavior using the existing API and that

00:46:39,390 --> 00:46:42,000
that's the thing that we just can't we

00:46:41,010 --> 00:46:43,770
haven't been able to estimate the

00:46:42,000 --> 00:46:46,020
difficulty or completeness of that

00:46:43,770 --> 00:46:47,790
project yet but I think that is

00:46:46,020 --> 00:46:49,830
something that we will pick up and use

00:46:47,790 --> 00:46:51,210
and so they're gonna be different

00:46:49,830 --> 00:46:53,550
migration paths for different use cases

00:46:51,210 --> 00:46:54,870
where we're not you know a gang of

00:46:53,550 --> 00:46:55,970
supervillains out to give you a really

00:46:54,870 --> 00:46:58,100
bad day

00:46:55,970 --> 00:46:59,930
we're really we want to make this as

00:46:58,100 --> 00:47:01,940
useful as possible and make it as easy

00:46:59,930 --> 00:47:03,140
as possible to migrate so we're totally

00:47:01,940 --> 00:47:04,490
aware of those issues and we want to

00:47:03,140 --> 00:47:08,510
keep the feedback coming on how we can

00:47:04,490 --> 00:47:09,830
make it as easy as possible and with

00:47:08,510 --> 00:47:12,190
that we're done so let's thank our

00:47:09,830 --> 00:47:12,190

YouTube URL: https://www.youtube.com/watch?v=LmWBEL7mazU


