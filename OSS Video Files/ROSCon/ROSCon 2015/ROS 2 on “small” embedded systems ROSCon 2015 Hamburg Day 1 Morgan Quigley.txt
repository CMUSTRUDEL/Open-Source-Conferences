Title: ROS 2 on “small” embedded systems ROSCon 2015 Hamburg Day 1 Morgan Quigley
Publication date: 2015-12-08
Playlist: ROSCon 2015
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2015 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,030 --> 00:00:04,859
hello everyone thanks for coming so yeah

00:00:02,970 --> 00:00:06,629
this talk will be about Ross - on what

00:00:04,859 --> 00:00:08,250
I'd like to call small embedded systems

00:00:06,629 --> 00:00:10,650
and I'll get into a little more of what

00:00:08,250 --> 00:00:12,809
I mean by that that adjective there so

00:00:10,650 --> 00:00:15,690
the first question of course at any talk

00:00:12,809 --> 00:00:17,460
is why do we care and in what I want to

00:00:15,690 --> 00:00:18,810
say the reason we care for small

00:00:17,460 --> 00:00:19,439
embedded systems is because they're

00:00:18,810 --> 00:00:21,359
everywhere

00:00:19,439 --> 00:00:22,859
nowadays so by that I mean the

00:00:21,359 --> 00:00:25,260
microcontrollers nowadays are

00:00:22,859 --> 00:00:26,580
effectively in every every gadget now

00:00:25,260 --> 00:00:28,380
that has a blinking line on it odds are

00:00:26,580 --> 00:00:30,359
there's a microcontroller in there so

00:00:28,380 --> 00:00:32,160
this picture is just to try to show the

00:00:30,359 --> 00:00:33,899
the ratio of microcontrollers nowadays

00:00:32,160 --> 00:00:35,820
so that they grow up out there on the

00:00:33,899 --> 00:00:36,960
left is the robot we did in

00:00:35,820 --> 00:00:40,350
collaboration with Sandia National

00:00:36,960 --> 00:00:42,510
Laboratories and IHMC and that's a big I

00:00:40,350 --> 00:00:44,879
think walking humanoid assuming a big

00:00:42,510 --> 00:00:48,000
complicated machine person size person

00:00:44,879 --> 00:00:50,579
moss but there's only actually two

00:00:48,000 --> 00:00:52,230
full-on computers on there so two x86

00:00:50,579 --> 00:00:54,989
machines up on the very top of the torso

00:00:52,230 --> 00:00:57,149
the rest of the machine has FPGAs for

00:00:54,989 --> 00:00:58,590
high speed data transfer but then this

00:00:57,149 --> 00:01:00,030
gigantic constellation of

00:00:58,590 --> 00:01:02,550
microcontrollers where all the sensors

00:01:00,030 --> 00:01:03,239
are so there's all this data flying

00:01:02,550 --> 00:01:04,650
around with all these little

00:01:03,239 --> 00:01:06,270
microcontrollers wouldn't it be great if

00:01:04,650 --> 00:01:08,400
we could standardize how these things

00:01:06,270 --> 00:01:10,650
talk to each other and so then we can

00:01:08,400 --> 00:01:13,290
write generic tools just like we have in

00:01:10,650 --> 00:01:14,430
the Ross at the higher level as if this

00:01:13,290 --> 00:01:15,869
trend continues in the future this will

00:01:14,430 --> 00:01:17,189
become and even you know a bigger and

00:01:15,869 --> 00:01:20,909
bigger issue as microcontrollers

00:01:17,189 --> 00:01:23,490
continue to go everywhere so the second

00:01:20,909 --> 00:01:24,780
goal would be if we can fit ross to or

00:01:23,490 --> 00:01:27,030
at least some implementation or some

00:01:24,780 --> 00:01:29,159
point of it inside sensors now we can

00:01:27,030 --> 00:01:30,570
get rid of driver nodes because ross -

00:01:29,159 --> 00:01:31,979
can actually running the sensor itself

00:01:30,570 --> 00:01:35,250
or in the actuator on the edge of the

00:01:31,979 --> 00:01:38,250
system so once we have then nodes like

00:01:35,250 --> 00:01:39,720
actual ross - clients talking the system

00:01:38,250 --> 00:01:41,280
maybe we can start to push more and more

00:01:39,720 --> 00:01:42,750
of the real-time processing into the

00:01:41,280 --> 00:01:44,579
sensors and actuators at the edges of

00:01:42,750 --> 00:01:46,409
the system because modern

00:01:44,579 --> 00:01:47,220
microcontrollers really are just getting

00:01:46,409 --> 00:01:48,240
more and more awesome

00:01:47,220 --> 00:01:49,500
it's the kind of thing where you go to

00:01:48,240 --> 00:01:50,909
the tradeshow every year and they're

00:01:49,500 --> 00:01:52,290
like oh yeah here's this thing and this

00:01:50,909 --> 00:01:54,060
rounds twice as fast as last year I

00:01:52,290 --> 00:01:55,290
don't have a nice day so that's still

00:01:54,060 --> 00:01:57,000
happening in the microcontroller world

00:01:55,290 --> 00:01:58,860
it's really exciting and so when we

00:01:57,000 --> 00:02:01,740
partition these computational units then

00:01:58,860 --> 00:02:03,149
we can have their little tiny real time

00:02:01,740 --> 00:02:04,290
things like say for example you take a

00:02:03,149 --> 00:02:05,820
little sensor reading you have a little

00:02:04,290 --> 00:02:07,079
bit of pipeline you want to do a small

00:02:05,820 --> 00:02:08,940
bit of processing and then pass it down

00:02:07,079 --> 00:02:10,470
it's easier to hook that in when there's

00:02:08,940 --> 00:02:12,700
a small system it's just a smaller thing

00:02:10,470 --> 00:02:16,660
- to take care of him to schedule

00:02:12,700 --> 00:02:18,040
so embedded systems is a big term if you

00:02:16,660 --> 00:02:19,300
ask 10 people they think embedded

00:02:18,040 --> 00:02:21,790
systems are you'll get 10 pretty

00:02:19,300 --> 00:02:23,349
different answers so there's kind of

00:02:21,790 --> 00:02:25,180
four worlds I'm going to draw here so

00:02:23,349 --> 00:02:27,580
that the left side there the first

00:02:25,180 --> 00:02:29,500
column the 8-bit world that was made

00:02:27,580 --> 00:02:32,470
famous by the Arduino and the AVR

00:02:29,500 --> 00:02:34,600
processor is Lately they're pretty small

00:02:32,470 --> 00:02:36,310
so this talk can't deal with them

00:02:34,600 --> 00:02:38,170
they're too small so the second column

00:02:36,310 --> 00:02:40,660
that I'm going to talk about here is the

00:02:38,170 --> 00:02:42,730
32-bit microcontroller world so that's

00:02:40,660 --> 00:02:45,610
things like the stm32 which is used on

00:02:42,730 --> 00:02:47,319
the pixel px4 which we just saw those

00:02:45,610 --> 00:02:48,910
you can actually get on the high end of

00:02:47,319 --> 00:02:50,799
that class you can have Ethernet

00:02:48,910 --> 00:02:53,890
interfaces and we can just natively plug

00:02:50,799 --> 00:02:55,989
that in the last two so I sometimes

00:02:53,890 --> 00:02:57,519
called the third column the RMA class

00:02:55,989 --> 00:03:00,549
it's like a smartphone without a screen

00:02:57,519 --> 00:03:02,200
on it it's the things like Oh droid gum

00:03:00,549 --> 00:03:04,390
sticks you know beaglebones those kind

00:03:02,200 --> 00:03:07,209
of things those are you can actually

00:03:04,390 --> 00:03:08,709
just run Ross normally on them the and

00:03:07,209 --> 00:03:10,360
then the last column I like to call

00:03:08,709 --> 00:03:11,950
those laptops without screens those are

00:03:10,360 --> 00:03:14,200
things like the Intel Nokes the small

00:03:11,950 --> 00:03:15,610
form-factor x86 s so all these things

00:03:14,200 --> 00:03:17,230
can be called embedded systems because

00:03:15,610 --> 00:03:18,730
they don't have screens on them but in

00:03:17,230 --> 00:03:21,579
this talk we just can talk about 32-bit

00:03:18,730 --> 00:03:23,890
microcontrollers for now so even within

00:03:21,579 --> 00:03:26,079
that category you can divide it into all

00:03:23,890 --> 00:03:27,730
sorts of different ways there's things

00:03:26,079 --> 00:03:30,190
that are relatively small as in they

00:03:27,730 --> 00:03:32,829
have few numbers of kilobytes of SRAM

00:03:30,190 --> 00:03:34,269
they cost just a dollar or two and then

00:03:32,829 --> 00:03:35,680
there's what I'll call big 32-bit

00:03:34,269 --> 00:03:38,350
microcontrollers and these are the

00:03:35,680 --> 00:03:39,970
systems like we see on the px4 and many

00:03:38,350 --> 00:03:41,200
other platforms they're really amazing

00:03:39,970 --> 00:03:43,690
computers in their own right they just

00:03:41,200 --> 00:03:44,799
happen to exist on a single chip so some

00:03:43,690 --> 00:03:47,350
of the constraints may have though to

00:03:44,799 --> 00:03:49,000
deal with their the SRAM is the biggest

00:03:47,350 --> 00:03:50,620
limitation and oftentimes if you're

00:03:49,000 --> 00:03:52,000
running from on ship Ram to keep the

00:03:50,620 --> 00:03:54,609
board small and light and cheap you

00:03:52,000 --> 00:03:55,780
typically have them like on the very top

00:03:54,609 --> 00:03:57,459
end chips you'll have a few hundred

00:03:55,780 --> 00:03:58,900
kilobytes to vestrum so that's that's

00:03:57,459 --> 00:04:00,190
tricky and that's actually what most of

00:03:58,900 --> 00:04:03,459
this talk is about is how do we deal

00:04:00,190 --> 00:04:05,260
with getting a general-purpose

00:04:03,459 --> 00:04:09,459
motive our client into something that

00:04:05,260 --> 00:04:10,600
small so what happened in the past

00:04:09,459 --> 00:04:12,910
what's gonna happen in the future

00:04:10,600 --> 00:04:14,799
ideally here so on the left side this is

00:04:12,910 --> 00:04:16,269
like the sad column this is the like sad

00:04:14,799 --> 00:04:18,100
music you know black-and-white part of

00:04:16,269 --> 00:04:20,979
the of the infomercial

00:04:18,100 --> 00:04:23,200
so with Ross one there was numerous

00:04:20,979 --> 00:04:24,490
issues that made it hard to embed so one

00:04:23,200 --> 00:04:25,500
of them was the startup sequencing

00:04:24,490 --> 00:04:27,480
problem that means that

00:04:25,500 --> 00:04:29,460
had to have raw score up before their

00:04:27,480 --> 00:04:30,480
clients did connect to it and that's

00:04:29,460 --> 00:04:32,250
sometimes a little tricky because

00:04:30,480 --> 00:04:34,470
microcontrollers boot effectively

00:04:32,250 --> 00:04:36,210
instantaneously and then as opposed to

00:04:34,470 --> 00:04:37,680
trying to connect to a full-on like

00:04:36,210 --> 00:04:39,270
Linux computer which is having maybe a

00:04:37,680 --> 00:04:41,220
multiple second boot time at best and

00:04:39,270 --> 00:04:42,390
then it'll fire up raw score so that was

00:04:41,220 --> 00:04:44,340
always tricky you had to either reset

00:04:42,390 --> 00:04:47,340
the microcontroller or delay the boot

00:04:44,340 --> 00:04:48,570
sequence on home even more practically

00:04:47,340 --> 00:04:50,550
though xml-rpc

00:04:48,570 --> 00:04:52,530
which rosslyn uses for negotiation is

00:04:50,550 --> 00:04:53,760
just difficult to deal with in highly

00:04:52,530 --> 00:04:55,620
constrained memory environments it's

00:04:53,760 --> 00:04:57,030
it's a tree structure it's coming at you

00:04:55,620 --> 00:04:58,410
and ASCII you're having to separate this

00:04:57,030 --> 00:05:00,570
parse tree and buffer everything right

00:04:58,410 --> 00:05:01,950
there's been heroic efforts to make that

00:05:00,570 --> 00:05:04,800
work but it's it's just fundamentally

00:05:01,950 --> 00:05:07,560
difficult problem rosslyn also uses TCP

00:05:04,800 --> 00:05:10,770
everywhere there is some UDP support but

00:05:07,560 --> 00:05:12,600
TCP in general needs some buffering to

00:05:10,770 --> 00:05:13,800
do with high performance TCP you want to

00:05:12,600 --> 00:05:15,840
buffer the packets that are in flight

00:05:13,800 --> 00:05:17,460
and so that that can be a tricky if your

00:05:15,840 --> 00:05:19,290
memory constrained so then the natural

00:05:17,460 --> 00:05:21,270
thing is let's use UDP so that's why

00:05:19,290 --> 00:05:23,460
there's UDP ross but that implementation

00:05:21,270 --> 00:05:25,440
is i think it's fair to say not complete

00:05:23,460 --> 00:05:26,910
it doesn't deal with the multi casting

00:05:25,440 --> 00:05:29,160
which is one of the big benefits of UDP

00:05:26,910 --> 00:05:30,450
and then if you have large messages you

00:05:29,160 --> 00:05:32,520
have to fragment them to fit them into

00:05:30,450 --> 00:05:34,500
Ethernet frames but there's not support

00:05:32,520 --> 00:05:35,850
need to be raus for for sending missed

00:05:34,500 --> 00:05:37,890
fragments if you have a really big image

00:05:35,850 --> 00:05:39,570
big message like a big image of point

00:05:37,890 --> 00:05:41,760
cloud and you drop one of those Ethernet

00:05:39,570 --> 00:05:43,020
frames it's well you better wait for the

00:05:41,760 --> 00:05:45,690
next message because you can't recover

00:05:43,020 --> 00:05:47,940
them so anyway embedding rails one tends

00:05:45,690 --> 00:05:50,610
to be difficult with Ross too this is

00:05:47,940 --> 00:05:52,140
the happy column you know happy music

00:05:50,610 --> 00:05:54,660
like full color probably infomercial

00:05:52,140 --> 00:05:56,970
here so there's no master node it's

00:05:54,660 --> 00:05:58,740
actually a fully distributed system this

00:05:56,970 --> 00:06:00,390
multicast UDP discovery that just means

00:05:58,740 --> 00:06:01,770
all the nodes come up and they started

00:06:00,390 --> 00:06:04,979
sending multicast packets the network

00:06:01,770 --> 00:06:07,200
and those in our GPS that's the protocol

00:06:04,979 --> 00:06:09,450
beneath DDS which is beneath Ross or

00:06:07,200 --> 00:06:10,710
else - it's just a list it's a parameter

00:06:09,450 --> 00:06:12,330
list so instead of this tree structure

00:06:10,710 --> 00:06:14,210
you having to parse out nasty it's just

00:06:12,330 --> 00:06:18,150
a well-defined list of parameters the

00:06:14,210 --> 00:06:21,360
RTP s or UDP data streams they're much

00:06:18,150 --> 00:06:22,710
more sophisticated than UDP ross so you

00:06:21,360 --> 00:06:24,750
can have all sorts of quality of service

00:06:22,710 --> 00:06:26,430
settings you can dial it one way you can

00:06:24,750 --> 00:06:27,810
get TCP where every packet has to be

00:06:26,430 --> 00:06:29,040
acknowledged you can dial it the other

00:06:27,810 --> 00:06:30,810
way and you get effectively a

00:06:29,040 --> 00:06:32,070
fire-and-forget UDP where you just send

00:06:30,810 --> 00:06:32,449
the message on the wire and you know

00:06:32,070 --> 00:06:34,279
have an

00:06:32,449 --> 00:06:36,020
they move on to the next one you can

00:06:34,279 --> 00:06:37,520
also in more interesting perhaps for

00:06:36,020 --> 00:06:38,659
robotics put it everywhere thing in

00:06:37,520 --> 00:06:40,159
between so maybe you want to send

00:06:38,659 --> 00:06:41,539
messages up to a few times

00:06:40,159 --> 00:06:42,589
and if it doesn't get there then you

00:06:41,539 --> 00:06:44,629
move on or maybe want to wait 100

00:06:42,589 --> 00:06:46,460
microseconds if it doesn't get there by

00:06:44,629 --> 00:06:47,629
then then you move on so what we're

00:06:46,460 --> 00:06:49,249
trying to do is showing all these great

00:06:47,629 --> 00:06:51,229
things you know these are great but

00:06:49,249 --> 00:06:52,370
that's awesome let's have them so what

00:06:51,229 --> 00:06:54,110
we're trying to show is we can get them

00:06:52,370 --> 00:06:55,460
with free portable small code that we

00:06:54,110 --> 00:06:57,860
can fit in the on shape memory of

00:06:55,460 --> 00:06:59,180
microcontrollers so to that if in fact

00:06:57,860 --> 00:07:00,650
we've been working for the past few

00:06:59,180 --> 00:07:02,870
months on a thing called free art EPS

00:07:00,650 --> 00:07:05,120
which is an Apache 2 license

00:07:02,870 --> 00:07:07,069
implementation of the RTP S transport

00:07:05,120 --> 00:07:09,169
and that's the the network protocol

00:07:07,069 --> 00:07:11,659
beneath DDS as well as its serialization

00:07:09,169 --> 00:07:13,039
layer called CDR so this is a work in

00:07:11,659 --> 00:07:14,749
progress I'd say it's like that the

00:07:13,039 --> 00:07:16,189
proof of concept stage went a little bit

00:07:14,749 --> 00:07:18,259
beyond I wouldn't recommend putting this

00:07:16,189 --> 00:07:20,479
on your in a million dollar vehicle this

00:07:18,259 --> 00:07:25,610
weekend and I want to wait a few

00:07:20,479 --> 00:07:27,800
weekends but ok so it's this layered

00:07:25,610 --> 00:07:29,839
deal so we can debug this by pointing it

00:07:27,800 --> 00:07:32,330
towards Linux with the POSIX UDP stack

00:07:29,839 --> 00:07:34,370
beneath it but really all it needs is a

00:07:32,330 --> 00:07:36,560
UDP transport layer so it just calls

00:07:34,370 --> 00:07:38,479
functions like send UDP packet somebody

00:07:36,560 --> 00:07:40,159
has to implement that so you can either

00:07:38,479 --> 00:07:41,569
point that towards POSIX networking or

00:07:40,159 --> 00:07:43,159
you can point it towards a very thin

00:07:41,569 --> 00:07:45,800
networking stack which we've written and

00:07:43,159 --> 00:07:48,319
then targeted toward stm32 and the Atmel

00:07:45,800 --> 00:07:49,939
Sam V microcontrollers and calling our

00:07:48,319 --> 00:07:52,249
thing a UDP stack is really generous

00:07:49,939 --> 00:07:54,439
it's just it's just stuffs of buffer and

00:07:52,249 --> 00:07:55,819
calls it through to the DES transceiver

00:07:54,439 --> 00:07:58,580
on the microcontroller themselves so

00:07:55,819 --> 00:07:59,899
it's very thin networking stack the

00:07:58,580 --> 00:08:02,120
important thing here is that we really

00:07:59,899 --> 00:08:03,789
don't need a full DDF stack in order to

00:08:02,120 --> 00:08:05,930
interoperate with thralls two nodes

00:08:03,789 --> 00:08:08,089
really what we need to have is the

00:08:05,930 --> 00:08:11,389
network traffic on the wire that's our

00:08:08,089 --> 00:08:12,919
TPS packets so that's that really opens

00:08:11,389 --> 00:08:14,749
up the space a lot because once we

00:08:12,919 --> 00:08:16,339
realize we don't know Ross has its own

00:08:14,749 --> 00:08:18,080
API we don't really need to follow the

00:08:16,339 --> 00:08:20,270
DDS API instead we just need to produce

00:08:18,080 --> 00:08:22,430
the network traffic that that the DDS

00:08:20,270 --> 00:08:24,860
nodes can understand so on the left side

00:08:22,430 --> 00:08:26,659
there is the full Ross to of stack which

00:08:24,860 --> 00:08:29,029
will have talks more about that over the

00:08:26,659 --> 00:08:31,039
next few days it's very elegant API

00:08:29,029 --> 00:08:32,479
there's all sorts of template you know

00:08:31,039 --> 00:08:34,099
awesomeness so that the code looks very

00:08:32,479 --> 00:08:36,500
cool and it's all very sophisticated and

00:08:34,099 --> 00:08:37,579
you can swap DDS vendors without having

00:08:36,500 --> 00:08:39,199
to change your source code there's all

00:08:37,579 --> 00:08:40,250
these nice layers of abstractions that

00:08:39,199 --> 00:08:42,110
really help the code look nice

00:08:40,250 --> 00:08:44,200
unfortunately there's there's a cost of

00:08:42,110 --> 00:08:46,930
course in memory consumption with

00:08:44,200 --> 00:08:49,240
stacking those things up so we're

00:08:46,930 --> 00:08:50,470
working on on targeting that so instead

00:08:49,240 --> 00:08:51,820
of having an open slice at the bottom

00:08:50,470 --> 00:08:53,800
you can have this free our TPS

00:08:51,820 --> 00:08:55,209
implementation we're not quite yet to

00:08:53,800 --> 00:08:56,920
the point where we can fit that whole

00:08:55,209 --> 00:08:59,079
stack instead of a microcontroller is on

00:08:56,920 --> 00:09:01,060
chip memory so for now we have this

00:08:59,079 --> 00:09:02,800
minimalist API there on the right side

00:09:01,060 --> 00:09:05,110
which you can write very simple code

00:09:02,800 --> 00:09:08,370
which directly calls the RT PS transport

00:09:05,110 --> 00:09:11,980
functions so you know the IP is the only

00:09:08,370 --> 00:09:14,410
but it works so what's great about this

00:09:11,980 --> 00:09:16,120
though is because our TPS has these

00:09:14,410 --> 00:09:18,910
buffers which are of known size the

00:09:16,120 --> 00:09:20,470
discovery for topics and for knows you

00:09:18,910 --> 00:09:22,300
you have a pretty good idea how big

00:09:20,470 --> 00:09:23,860
those are gonna be and then in the

00:09:22,300 --> 00:09:25,660
embedded case if you're writing say an

00:09:23,860 --> 00:09:27,220
embedded node which is going to take a

00:09:25,660 --> 00:09:28,750
nursery unit messages and send them or a

00:09:27,220 --> 00:09:30,519
smart camera that's going to send out

00:09:28,750 --> 00:09:31,990
Roth's image messages or something odds

00:09:30,519 --> 00:09:33,940
are you have a good idea about what the

00:09:31,990 --> 00:09:35,740
buffer sizes should be so you can choose

00:09:33,940 --> 00:09:38,019
them at compile time and at link time

00:09:35,740 --> 00:09:39,310
and that just goes into the executable

00:09:38,019 --> 00:09:41,279
image you don't have to have anything on

00:09:39,310 --> 00:09:43,089
the heap so these can be all static

00:09:41,279 --> 00:09:44,410
everything's pre-allocated you're not

00:09:43,089 --> 00:09:46,810
worrying about you know Malik's over

00:09:44,410 --> 00:09:47,769
running or or anything like that there

00:09:46,810 --> 00:09:49,329
are trade-offs of course you have to

00:09:47,769 --> 00:09:51,100
then decide how many nodes can this

00:09:49,329 --> 00:09:52,779
thing discover that's that's the size of

00:09:51,100 --> 00:09:53,920
buffer you can allocate but you can make

00:09:52,779 --> 00:09:55,600
those trade-offs on a per application

00:09:53,920 --> 00:09:57,190
basis and this is all open source so

00:09:55,600 --> 00:10:00,430
it's easy to tweak and rebuild as as

00:09:57,190 --> 00:10:02,410
needed so we always start of course in

00:10:00,430 --> 00:10:04,480
middlewares by sending strings around so

00:10:02,410 --> 00:10:06,910
the minimal proof of concept here is can

00:10:04,480 --> 00:10:09,250
we send an RTP ash string from a

00:10:06,910 --> 00:10:11,380
embedded microcontroller and then catch

00:10:09,250 --> 00:10:12,910
that on a full DDS implementation with

00:10:11,380 --> 00:10:15,760
the nice Ralph's TV API on top of that

00:10:12,910 --> 00:10:18,100
so to do that we've made this talker

00:10:15,760 --> 00:10:19,540
example it's all static again no no

00:10:18,100 --> 00:10:22,089
Malick's happening here is no dynamic

00:10:19,540 --> 00:10:23,649
memory no use of the heap at all and so

00:10:22,089 --> 00:10:26,709
this currently takes 100 kilobytes of

00:10:23,649 --> 00:10:28,000
RAM to run and about 60km but there's

00:10:26,709 --> 00:10:29,860
lots of ways we can improve that in the

00:10:28,000 --> 00:10:31,329
future this is just the first proof of

00:10:29,860 --> 00:10:32,890
concept and we can certainly optimize

00:10:31,329 --> 00:10:34,120
that later but that cartoon at the

00:10:32,890 --> 00:10:36,160
bottom there just shows we have this

00:10:34,120 --> 00:10:37,990
talker known which is running either on

00:10:36,160 --> 00:10:39,430
on your POSIX hosts or on a

00:10:37,990 --> 00:10:42,040
microcontroller just bare-metal

00:10:39,430 --> 00:10:43,779
microcontroller blasting our TPS Network

00:10:42,040 --> 00:10:45,339
packets at an open slice listener which

00:10:43,779 --> 00:10:48,490
then eventually bubble up into the rows

00:10:45,339 --> 00:10:50,319
to space on top so this thing fits on a

00:10:48,490 --> 00:10:51,819
single page this is the full program I

00:10:50,319 --> 00:10:53,290
apologize it's a little bit too much

00:10:51,819 --> 00:10:54,760
code to look at but just going through

00:10:53,290 --> 00:10:56,529
those big bubbles that call out bubbles

00:10:54,760 --> 00:10:58,240
they're the first you see the the

00:10:56,529 --> 00:11:00,009
your allocation so that those are the

00:10:58,240 --> 00:11:01,600
explicit buffers this is gonna use or

00:11:00,009 --> 00:11:04,360
we're statically allocating this whole

00:11:01,600 --> 00:11:05,470
thing so we can that way we can find out

00:11:04,360 --> 00:11:06,730
if you have too much about friend going

00:11:05,470 --> 00:11:07,990
on if you don't have enough memory at

00:11:06,730 --> 00:11:09,670
least the linker will tell you when it

00:11:07,990 --> 00:11:11,999
tries to link it rather than you find it

00:11:09,670 --> 00:11:14,110
later on the line at a drum time so

00:11:11,999 --> 00:11:16,059
there's some initialization stuff that

00:11:14,110 --> 00:11:18,160
starts up and then that second call out

00:11:16,059 --> 00:11:19,930
there we tick the discovery machinery so

00:11:18,160 --> 00:11:21,579
that's that's how our TPS finds these

00:11:19,930 --> 00:11:23,499
are the mills this multicast UDP

00:11:21,579 --> 00:11:24,970
machinery such as they send out packets

00:11:23,499 --> 00:11:26,230
on the wire and say hi you know what's

00:11:24,970 --> 00:11:28,389
your name here's my name here's how you

00:11:26,230 --> 00:11:31,180
find me so that needs to happen on the

00:11:28,389 --> 00:11:32,889
order of every second or so and then the

00:11:31,180 --> 00:11:35,139
last bit those last four lines there are

00:11:32,889 --> 00:11:38,499
it's just often serialize the message

00:11:35,139 --> 00:11:41,290
buffer and then Samantha wire so this is

00:11:38,499 --> 00:11:44,290
the kind of flow of the free RTP s right

00:11:41,290 --> 00:11:46,089
now in the client side so strings are

00:11:44,290 --> 00:11:48,129
fun but typically in robotics we want to

00:11:46,089 --> 00:11:49,720
send more than strings so to do that in

00:11:48,129 --> 00:11:52,180
to make sure our abstractions are

00:11:49,720 --> 00:11:53,319
working with have a few demos here for

00:11:52,180 --> 00:11:54,759
the sake of time I don't have the

00:11:53,319 --> 00:11:56,589
widgets here on the podium with me but

00:11:54,759 --> 00:11:57,699
I'll have them after we can show play

00:11:56,589 --> 00:11:59,589
around from during the lunch break or

00:11:57,699 --> 00:12:01,689
the or any other breaks during the the

00:11:59,589 --> 00:12:04,089
comforts here so the first one is an

00:12:01,689 --> 00:12:05,910
inertial unit demo that's using a one of

00:12:04,089 --> 00:12:08,620
the popular development boards is the

00:12:05,910 --> 00:12:10,689
stm32f4discovery you can get that and

00:12:08,620 --> 00:12:12,189
the Ethernet stack really cheap so

00:12:10,689 --> 00:12:14,559
there's a there's a microcontroller on

00:12:12,189 --> 00:12:17,199
that board so this demo pulls that micro

00:12:14,559 --> 00:12:19,089
pulls accelerometer at kilohertz on the

00:12:17,199 --> 00:12:21,279
board and then just ships that out over

00:12:19,089 --> 00:12:22,720
the Internet so they also perform a

00:12:21,279 --> 00:12:25,269
statistics on that in terms of jitter

00:12:22,720 --> 00:12:27,490
and legacy the next one is a more

00:12:25,269 --> 00:12:29,110
complicated demo to show how we can make

00:12:27,490 --> 00:12:31,480
a smart camera with the microcontroller

00:12:29,110 --> 00:12:33,220
so I have this all so I'm happy to show

00:12:31,480 --> 00:12:35,199
that afterwards it's an image sensors to

00:12:33,220 --> 00:12:39,490
draw a CMOS image sensor that wires into

00:12:35,199 --> 00:12:41,079
a cortex m7 development board then I can

00:12:39,490 --> 00:12:42,639
barely fit a frame buffer on that but

00:12:41,079 --> 00:12:44,769
there is just barely enough room to fit

00:12:42,639 --> 00:12:46,929
a VGA frame buffer and for your TPS and

00:12:44,769 --> 00:12:48,939
slim we can actually send out sensory

00:12:46,929 --> 00:12:51,129
messages image messages on the line and

00:12:48,939 --> 00:12:52,809
then on the receiving side of things so

00:12:51,129 --> 00:12:54,399
we can subscribe there's just a LED

00:12:52,809 --> 00:12:55,689
blinker program like we always love to

00:12:54,399 --> 00:12:57,579
build of course in computer engineering

00:12:55,689 --> 00:13:01,990
the world's most complicated LED blink

00:12:57,579 --> 00:13:03,009
terminal so I think so the first demo

00:13:01,990 --> 00:13:06,670
I'm gonna show of some performance data

00:13:03,009 --> 00:13:08,350
on this is stm32f4discovery board it's

00:13:06,670 --> 00:13:10,420
been a little bit hot rounded to use the

00:13:08,350 --> 00:13:12,309
ethernet physical layer transceiver and

00:13:10,420 --> 00:13:14,079
the accelerometer at the same time or

00:13:12,309 --> 00:13:15,779
just one jumper you had to add but what

00:13:14,079 --> 00:13:18,189
we're trying to do is to hook that into

00:13:15,779 --> 00:13:19,629
some lab test bench equipment and get

00:13:18,189 --> 00:13:24,040
direct measurements of the jitter or

00:13:19,629 --> 00:13:26,319
latency of this so as we start running

00:13:24,040 --> 00:13:28,209
this here I would wave my hands okay

00:13:26,319 --> 00:13:30,399
anyway on that box that would have

00:13:28,209 --> 00:13:32,410
circled that in red there that shows the

00:13:30,399 --> 00:13:34,929
standard deviation of the time period

00:13:32,410 --> 00:13:36,610
here so that yellow trace is the chip

00:13:34,929 --> 00:13:38,620
select line of the nurse'll unit little

00:13:36,610 --> 00:13:40,089
micro the accelerometer so when you pull

00:13:38,620 --> 00:13:41,740
that low you talk to it you put it up

00:13:40,089 --> 00:13:43,209
high cuz you're going talking to it then

00:13:41,740 --> 00:13:44,649
that green trace shows when we're

00:13:43,209 --> 00:13:46,179
actually sending Ethernet packets so

00:13:44,649 --> 00:13:47,980
that that line goes high wanted you're

00:13:46,179 --> 00:13:49,329
blasting stuff out on the network so

00:13:47,980 --> 00:13:52,029
when there's nothing this is a clean

00:13:49,329 --> 00:13:53,559
Network segment now this shows the the

00:13:52,029 --> 00:13:55,029
jitter standard deviation is 28

00:13:53,559 --> 00:13:56,620
nanoseconds so that's pretty good that's

00:13:55,029 --> 00:13:58,809
like one clock cycle sim slave the clock

00:13:56,620 --> 00:14:00,670
that's running the ethernet receiver so

00:13:58,809 --> 00:14:02,829
but what we oftentimes care more about

00:14:00,670 --> 00:14:04,360
in real time stuff is the over at like

00:14:02,829 --> 00:14:06,420
the worst case and so that shows we're

00:14:04,360 --> 00:14:08,769
getting worst case there is about 200

00:14:06,420 --> 00:14:10,029
nanoseconds so that's great began this

00:14:08,769 --> 00:14:11,319
is the best case nothing else is on

00:14:10,029 --> 00:14:13,059
network so they're trying to make it

00:14:11,319 --> 00:14:14,769
more difficult now in my workstation is

00:14:13,059 --> 00:14:16,870
pinging this poor microcontroller at 8

00:14:14,769 --> 00:14:18,790
kilohertz while it's also trying to give

00:14:16,870 --> 00:14:20,649
us the accelerometer back at one killers

00:14:18,790 --> 00:14:22,059
so now when there's there's more stuff

00:14:20,649 --> 00:14:23,709
going on as it expects there's more

00:14:22,059 --> 00:14:26,350
cache misses and there's more jitter it

00:14:23,709 --> 00:14:29,620
happening so now we're showing about a

00:14:26,350 --> 00:14:31,179
to microsecond jitter or so so this is

00:14:29,620 --> 00:14:32,500
on a 1 millisecond period we have 2

00:14:31,179 --> 00:14:34,389
microseconds of jitter so it's about

00:14:32,500 --> 00:14:37,209
point two percent jitter that's pretty

00:14:34,389 --> 00:14:39,429
good so then now if we look we zoom in

00:14:37,209 --> 00:14:41,829
now what we care about oftentimes also

00:14:39,429 --> 00:14:43,360
is latency so the yellow trace remember

00:14:41,829 --> 00:14:45,069
the yellow trace goes down we talk to

00:14:43,360 --> 00:14:46,569
the the accelerometer we get us data

00:14:45,069 --> 00:14:48,220
back and then we want it there's a delay

00:14:46,569 --> 00:14:50,170
while we're crafting our packets and

00:14:48,220 --> 00:14:51,370
stuff until the green trace goes back up

00:14:50,170 --> 00:14:52,899
there and that's actually when we're

00:14:51,370 --> 00:14:54,579
sending out the our TPS message so we

00:14:52,899 --> 00:14:56,740
want that delay to be small and also to

00:14:54,579 --> 00:14:58,110
be predictable and so this measurement

00:14:56,740 --> 00:15:00,370
here shows that after taking

00:14:58,110 --> 00:15:02,250
7000 measurements on the oscilloscope it

00:15:00,370 --> 00:15:04,800
says that the what

00:15:02,250 --> 00:15:07,170
there as we have about a 34 or 35 micro

00:15:04,800 --> 00:15:08,730
second delay and the jitter is about two

00:15:07,170 --> 00:15:10,050
microseconds so those are the kind of

00:15:08,730 --> 00:15:11,400
ballpark where we are we can improve

00:15:10,050 --> 00:15:13,200
this of course over time but I wanted to

00:15:11,400 --> 00:15:16,710
just show where were things are as it

00:15:13,200 --> 00:15:18,870
stands so to summarize Ross - with the

00:15:16,710 --> 00:15:20,970
DDS underneath it and our TPS underneath

00:15:18,870 --> 00:15:22,620
that is much more embeddable than our

00:15:20,970 --> 00:15:24,210
Rosslyn protocols it's just much more

00:15:22,620 --> 00:15:26,070
firmly to these static memory situations

00:15:24,210 --> 00:15:28,590
of Highly memory constrained systems

00:15:26,070 --> 00:15:30,720
going forward I'd love to attack more

00:15:28,590 --> 00:15:32,790
microcontrollers especially small ones

00:15:30,720 --> 00:15:34,110
so this is relatively big 32-bit

00:15:32,790 --> 00:15:36,570
microcontrollers that I'm showing these

00:15:34,110 --> 00:15:38,310
demos on right now oftentimes we want

00:15:36,570 --> 00:15:40,380
things to get smaller and ironically if

00:15:38,310 --> 00:15:42,240
you'll see these def boards the ethernet

00:15:40,380 --> 00:15:43,590
connector in its transceiver is actually

00:15:42,240 --> 00:15:45,900
larger than the microcontroller nowadays

00:15:43,590 --> 00:15:47,190
so we don't want that you know be grid

00:15:45,900 --> 00:15:48,780
as we string things down to use

00:15:47,190 --> 00:15:51,540
different physical layers in Ethernet so

00:15:48,780 --> 00:15:53,340
raw USB like the full speed high-speed

00:15:51,540 --> 00:15:54,900
super speed USB is kind of where things

00:15:53,340 --> 00:15:56,640
have gone because of in part connector

00:15:54,900 --> 00:15:57,930
size and the transceivers are built in

00:15:56,640 --> 00:15:59,910
the microcontrollers that save some

00:15:57,930 --> 00:16:01,470
board space but then there's also a

00:15:59,910 --> 00:16:04,740
whole other world of unframed serial

00:16:01,470 --> 00:16:06,690
protocols like rs45 now TTL I'll just

00:16:04,740 --> 00:16:08,160
draw you arts there's there's lots of

00:16:06,690 --> 00:16:09,930
ways things can communicate whether that

00:16:08,160 --> 00:16:11,310
or even over wireless as well so there's

00:16:09,930 --> 00:16:14,540
some future areas we're going to go

00:16:11,310 --> 00:16:14,540
after so thanks for your time

00:16:17,140 --> 00:16:21,329
Thank You Morgan any questions

00:16:27,080 --> 00:16:30,950
so right now this thing just oh sorry

00:16:29,690 --> 00:16:33,320
question is do we need a real-time

00:16:30,950 --> 00:16:35,540
operating system beneath free RT PS and

00:16:33,320 --> 00:16:37,370
so right now the demos are written if we

00:16:35,540 --> 00:16:38,570
go back a few slides underneath that I

00:16:37,370 --> 00:16:40,279
have this what I was calling a

00:16:38,570 --> 00:16:42,170
minimalist DDP before stock that's

00:16:40,279 --> 00:16:44,540
really nothing other than stuffing the

00:16:42,170 --> 00:16:45,950
the DMA descriptors for the ethernet

00:16:44,540 --> 00:16:48,320
transceivers and just having it run so

00:16:45,950 --> 00:16:50,149
dancers we don't require it you can

00:16:48,320 --> 00:16:51,680
certainly do that and you know many many

00:16:50,149 --> 00:16:52,880
applications would want that for various

00:16:51,680 --> 00:16:54,620
other scheduling reasons if you're doing

00:16:52,880 --> 00:16:55,640
more than one thing on the machine these

00:16:54,620 --> 00:16:57,620
demos there's really only one thing

00:16:55,640 --> 00:16:59,180
happening per demo whether it's an arson

00:16:57,620 --> 00:17:02,540
unit demo or the camera demo or a

00:16:59,180 --> 00:17:05,000
blinker so it's just going draw straight

00:17:02,540 --> 00:17:07,809
bare-metal but you can certainly put an

00:17:05,000 --> 00:17:07,809
offering system beneath that

00:17:37,020 --> 00:17:41,559
okay it's a great question the question

00:17:39,160 --> 00:17:43,000
is a real-time can be difficult to

00:17:41,559 --> 00:17:44,830
guarantee when there's a lot of stuff in

00:17:43,000 --> 00:17:46,150
the system going on lots of packages

00:17:44,830 --> 00:17:49,750
lots of packets is that a fair summary

00:17:46,150 --> 00:17:51,010
okay yeah so yeah real-time is a whole

00:17:49,750 --> 00:17:52,809
can of worms there's actually gonna be a

00:17:51,010 --> 00:17:54,490
talk about using raw stew with real time

00:17:52,809 --> 00:17:55,690
of stuff that Jackie's gonna give and

00:17:54,490 --> 00:17:57,940
that'll go into more detail on these

00:17:55,690 --> 00:17:59,140
things but yeah you certainly I can't

00:17:57,940 --> 00:18:00,760
sit up here and say because you have

00:17:59,140 --> 00:18:02,110
real you know your microcontroller has

00:18:00,760 --> 00:18:02,290
low jitter the whole thing is hard real

00:18:02,110 --> 00:18:03,790
time

00:18:02,290 --> 00:18:04,570
yeah that's certainly a there's a lot

00:18:03,790 --> 00:18:06,220
more going on in these systems

00:18:04,570 --> 00:18:07,960
essentially what this is trying to say

00:18:06,220 --> 00:18:10,030
is that this piece of the system can

00:18:07,960 --> 00:18:11,559
obey real time things depending on what

00:18:10,030 --> 00:18:13,030
you're doing on the microcontroller you

00:18:11,559 --> 00:18:14,620
can show that you can have good timing

00:18:13,030 --> 00:18:16,210
on your network packets know whatever

00:18:14,620 --> 00:18:19,410
else happens beyond that on the network

00:18:16,210 --> 00:18:19,410
certainly could could tear that apart

00:18:26,460 --> 00:18:29,770
okay so the question is what other

00:18:28,510 --> 00:18:31,570
physical layers are going to support

00:18:29,770 --> 00:18:39,370
whether that's can or EtherCAT is it a

00:18:31,570 --> 00:18:41,170
fair summary okay thank you so the

00:18:39,370 --> 00:18:42,640
clarification there was that some

00:18:41,170 --> 00:18:44,190
physical layers such as canvas or

00:18:42,640 --> 00:18:46,030
EtherCAT they can actually have multiple

00:18:44,190 --> 00:18:48,160
microcontrollers on that same physical

00:18:46,030 --> 00:18:49,929
bus so they rather than talking straight

00:18:48,160 --> 00:18:51,309
to Ethernet they might need to talk to

00:18:49,929 --> 00:18:53,080
each other before one of them starts to

00:18:51,309 --> 00:18:56,080
relay it's the human is it is that fair

00:18:53,080 --> 00:18:58,390
okay so yes that's certainly on the the

00:18:56,080 --> 00:19:00,460
future work slide another yeah clearly

00:18:58,390 --> 00:19:02,350
but but that I think that it's

00:19:00,460 --> 00:19:04,000
interesting to look at that case I think

00:19:02,350 --> 00:19:05,050
it's an important use case because often

00:19:04,000 --> 00:19:06,460
times you know like the previous

00:19:05,050 --> 00:19:08,950
question said if we're trying to have a

00:19:06,460 --> 00:19:10,720
particular system or part of the system

00:19:08,950 --> 00:19:12,010
be hard real-time you know it's often

00:19:10,720 --> 00:19:13,360
times you want to partition it and one

00:19:12,010 --> 00:19:14,470
way it's easy to partition that is with

00:19:13,360 --> 00:19:15,640
these other physical layers where

00:19:14,470 --> 00:19:17,559
microcontroller talking to

00:19:15,640 --> 00:19:19,450
microcontroller so that's certainly an

00:19:17,559 --> 00:19:20,679
area of future work we're not there yet

00:19:19,450 --> 00:19:23,520
but I think it's a very interesting

00:19:20,679 --> 00:19:23,520
place to go in the future

00:19:36,040 --> 00:19:40,270
okay Thanks so the question was what

00:19:38,440 --> 00:19:41,590
about time synchronization where if we

00:19:40,270 --> 00:19:43,180
have lots of different parts the system

00:19:41,590 --> 00:19:44,650
they each have their own clocks and how

00:19:43,180 --> 00:19:46,360
can we deal with that that's certainly

00:19:44,650 --> 00:19:47,590
an issue if you look at these traces

00:19:46,360 --> 00:19:50,080
here you can see that I'm actually

00:19:47,590 --> 00:19:51,310
running it it's slightly faster than one

00:19:50,080 --> 00:19:52,480
kilohertz because of the clock speed

00:19:51,310 --> 00:19:54,880
differences that's always the case

00:19:52,480 --> 00:19:56,140
clocks aren't perfect that's certainly

00:19:54,880 --> 00:19:58,030
an issue I think that's somewhat

00:19:56,140 --> 00:19:59,380
orthogonal to this I think that time

00:19:58,030 --> 00:20:01,060
synchronization whether we're using the

00:19:59,380 --> 00:20:02,920
ethernet standard protocols or some

00:20:01,060 --> 00:20:05,080
other mechanism whether gps pulses or

00:20:02,920 --> 00:20:06,340
something I think that's certainly

00:20:05,080 --> 00:20:07,990
something that needs to happen to build

00:20:06,340 --> 00:20:09,070
large systems but it's not not quite

00:20:07,990 --> 00:20:10,600
addressed by here I think that would be

00:20:09,070 --> 00:20:13,920
another kind of parallel process that's

00:20:10,600 --> 00:20:13,920
keeping the timing information correct

00:20:37,290 --> 00:20:41,380
right so the question is about how when

00:20:40,180 --> 00:20:44,230
we start up a bigger about system

00:20:41,380 --> 00:20:45,460
oftentimes we have to deal with lots of

00:20:44,230 --> 00:20:46,960
different controllers coming up online

00:20:45,460 --> 00:20:48,490
perhaps you have the same motor

00:20:46,960 --> 00:20:49,600
controller for example but you have 20

00:20:48,490 --> 00:20:51,730
of them and they need to tell you which

00:20:49,600 --> 00:20:53,080
motors belong to which joints and yeah I

00:20:51,730 --> 00:20:55,060
think like you said it is a bit of a

00:20:53,080 --> 00:20:57,010
separate problem to deal with whether

00:20:55,060 --> 00:20:58,870
that's a new configuration maybe it's a

00:20:57,010 --> 00:21:00,100
different other than real time discovery

00:20:58,870 --> 00:21:01,600
we could even hard-code some of those

00:21:00,100 --> 00:21:03,760
things by MAC address and map those to

00:21:01,600 --> 00:21:05,290
tell 'fuck types like you mentioned I do

00:21:03,760 --> 00:21:07,000
think it's a bit of a separate issue

00:21:05,290 --> 00:21:08,440
this is this talk is just purely dealing

00:21:07,000 --> 00:21:09,910
with the transport layer of how can we

00:21:08,440 --> 00:21:12,090
send messages from one node to another

00:21:09,910 --> 00:21:12,090
node

00:21:26,340 --> 00:21:30,309
okay sure so the question was I I figure

00:21:29,139 --> 00:21:32,019
out the number 100 kilobytes there

00:21:30,309 --> 00:21:34,269
without explaining it at all or doing

00:21:32,019 --> 00:21:35,980
any kind of any kind of plus there so

00:21:34,269 --> 00:21:38,919
yeah the whole demo takes 100 kilobytes

00:21:35,980 --> 00:21:40,629
to in the when it is done linking up

00:21:38,919 --> 00:21:42,850
obviously the IME messages themselves

00:21:40,629 --> 00:21:44,740
are like a few tens of bytes so it's not

00:21:42,850 --> 00:21:46,899
just message buffering here so a lot of

00:21:44,740 --> 00:21:48,460
that I can certainly talk offline we can

00:21:46,899 --> 00:21:50,200
show a linker the linker Maps and stuff

00:21:48,460 --> 00:21:52,299
it's a lot of it is just the when I

00:21:50,200 --> 00:21:53,769
called a bare-metal UDP stack there

00:21:52,299 --> 00:21:55,210
actually is a has to have a ring buffer

00:21:53,769 --> 00:21:56,769
and they made descriptors and places for

00:21:55,210 --> 00:21:58,450
that tool and that's actually the bulk

00:21:56,769 --> 00:22:01,169
of it is dealing with the inbound and

00:21:58,450 --> 00:22:03,730
outbound Ethernet buffers some of it is

00:22:01,169 --> 00:22:05,350
code buffers that you also need for the

00:22:03,730 --> 00:22:07,119
discovery but that actually tends to be

00:22:05,350 --> 00:22:07,919
smaller this is a lot of it is just that

00:22:07,119 --> 00:22:10,299
you can't buffer

00:22:07,919 --> 00:22:11,470
so with smaller physical layers we could

00:22:10,299 --> 00:22:14,799
definitely drive that down if we're just

00:22:11,470 --> 00:22:16,779
doing you know a sequence of packets on

00:22:14,799 --> 00:22:18,490
like a UART or a TTL serial line of some

00:22:16,779 --> 00:22:19,809
sort that just all the odds are the

00:22:18,490 --> 00:22:21,190
locator is gonna be much smaller the

00:22:19,809 --> 00:22:23,019
descriptors and dent afire ZAR smaller

00:22:21,190 --> 00:22:25,799
everything can shrink down as we go to a

00:22:23,019 --> 00:22:25,799

YouTube URL: https://www.youtube.com/watch?v=3rMGE8Q3dsk


