Title: Real time Performance in ROS 2 ROSCon 2015 Hamburg Day 1 Jackie Kay
Publication date: 2015-12-08
Playlist: ROSCon 2015
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2015 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,030 --> 00:00:05,370
hi everyone so first before we get

00:00:03,149 --> 00:00:07,200
started I want to thank Adolfo who could

00:00:05,370 --> 00:00:08,760
proposes to talk with me he

00:00:07,200 --> 00:00:10,950
unfortunately couldn't make it he's in

00:00:08,760 --> 00:00:13,590
Barcelona right now but he did a lot of

00:00:10,950 --> 00:00:14,610
great work making beautiful slides

00:00:13,590 --> 00:00:17,880
you're gonna see they're awesome

00:00:14,610 --> 00:00:20,400
beautifying my really ugly slides and he

00:00:17,880 --> 00:00:23,609
contributes a lot via his work on Ross

00:00:20,400 --> 00:00:26,340
control and also he's added a lot of

00:00:23,609 --> 00:00:28,199
great ideas and designed to the Ross to

00:00:26,340 --> 00:00:33,780
work that we've done so thanks and all

00:00:28,199 --> 00:00:35,940
fo so I just want to like get a

00:00:33,780 --> 00:00:38,399
temperature reading on the audience who

00:00:35,940 --> 00:00:43,110
here has worked very extensively with a

00:00:38,399 --> 00:00:46,230
real-time system before awesome ok who

00:00:43,110 --> 00:00:49,860
here has not but is familiar with the

00:00:46,230 --> 00:00:51,840
concepts okay that's like almost who

00:00:49,860 --> 00:00:53,340
here has no idea or like has heard this

00:00:51,840 --> 00:00:55,320
buzzword a lot and but actually like

00:00:53,340 --> 00:01:05,339
doesn't know and doesn't know the

00:00:55,320 --> 00:01:07,710
definition ok great so I'm gonna start

00:01:05,339 --> 00:01:09,119
out with kind of a concrete example with

00:01:07,710 --> 00:01:11,850
a situation that we're all really

00:01:09,119 --> 00:01:13,799
familiar with which is you know making a

00:01:11,850 --> 00:01:16,950
robot do something and then this is kind

00:01:13,799 --> 00:01:20,340
of the motivating use case for Ross

00:01:16,950 --> 00:01:21,990
control but we're gonna kind of extend

00:01:20,340 --> 00:01:25,590
this and it's not going to be specific

00:01:21,990 --> 00:01:27,060
to Ross so yeah you have you have a

00:01:25,590 --> 00:01:28,170
robot anyone make it do something you

00:01:27,060 --> 00:01:31,560
want to make it execute a simple

00:01:28,170 --> 00:01:35,340
position trajectory controller and you

00:01:31,560 --> 00:01:37,770
you wrote some code on your desktop some

00:01:35,340 --> 00:01:39,409
controller code and when we expand what

00:01:37,770 --> 00:01:44,040
this looks like

00:01:39,409 --> 00:01:46,110
nice it's composed of many separate

00:01:44,040 --> 00:01:48,119
software modules that were independent

00:01:46,110 --> 00:01:50,340
and they may have been done by you or

00:01:48,119 --> 00:01:52,680
someone in your lab or company or

00:01:50,340 --> 00:01:54,000
someone you know who distributed it

00:01:52,680 --> 00:01:57,030
you've never met it's open source

00:01:54,000 --> 00:01:59,850
whatever and you can kind of break down

00:01:57,030 --> 00:02:02,790
your controller into you know an

00:01:59,850 --> 00:02:04,890
abstract action interface to manage the

00:02:02,790 --> 00:02:06,180
logic and inverse kinematics you might

00:02:04,890 --> 00:02:08,580
want a different inverse kinematics

00:02:06,180 --> 00:02:10,800
algorithm that varies on your robot

00:02:08,580 --> 00:02:12,140
geometry you know a signal interpolator

00:02:10,800 --> 00:02:15,860
is that green thing

00:02:12,140 --> 00:02:19,310
PID feedback loop and you know these all

00:02:15,860 --> 00:02:21,020
these modules all have they they're like

00:02:19,310 --> 00:02:23,330
functions with a certain input and

00:02:21,020 --> 00:02:24,740
output but but that logic isn't

00:02:23,330 --> 00:02:26,660
necessarily tied to their execution

00:02:24,740 --> 00:02:28,730
logic and their their performance

00:02:26,660 --> 00:02:34,640
requirements that might change based on

00:02:28,730 --> 00:02:37,850
your application so kind of scoping out

00:02:34,640 --> 00:02:39,470
again we might want to also do something

00:02:37,850 --> 00:02:42,560
like change our controller during

00:02:39,470 --> 00:02:43,850
execution during runtime so for example

00:02:42,560 --> 00:02:45,920
we were doing a position controller

00:02:43,850 --> 00:02:49,400
before and now we're doing kind of a an

00:02:45,920 --> 00:02:51,440
impedance controller and it would be

00:02:49,400 --> 00:02:54,019
nice you know if we could decide we're

00:02:51,440 --> 00:02:55,640
doing something else without you know

00:02:54,019 --> 00:02:58,160
resetting the robot without doing

00:02:55,640 --> 00:03:00,230
significant work or having a significant

00:02:58,160 --> 00:03:03,110
penalty on our execution switch out this

00:03:00,230 --> 00:03:05,959
controller so the system topology can

00:03:03,110 --> 00:03:07,910
change that would be cool and on the

00:03:05,959 --> 00:03:10,220
other side we kind of see the same story

00:03:07,910 --> 00:03:12,019
but with hardware with the hardware

00:03:10,220 --> 00:03:13,880
interface to the robot so this is kind

00:03:12,019 --> 00:03:16,760
of an awesome diagram with like you know

00:03:13,880 --> 00:03:18,860
this is gravity compensation this is

00:03:16,760 --> 00:03:21,620
your traffic speed limit which is your

00:03:18,860 --> 00:03:26,299
joint limiting these you know gearboxes

00:03:21,620 --> 00:03:28,670
this is funnel is a like a filter but

00:03:26,299 --> 00:03:30,769
you know you have these views interfaces

00:03:28,670 --> 00:03:33,560
to the different components of your

00:03:30,769 --> 00:03:35,329
robot maybe you have like the clear a

00:03:33,560 --> 00:03:38,959
clear path robot with a you know a

00:03:35,329 --> 00:03:41,540
Baxter and the mobile base and you want

00:03:38,959 --> 00:03:43,820
to swap that out so if you had these

00:03:41,540 --> 00:03:46,250
kind of composable components you could

00:03:43,820 --> 00:03:47,870
like maybe also you know you're doing

00:03:46,250 --> 00:03:50,900
the DRC and you have different grippers

00:03:47,870 --> 00:03:53,030
for atlas it be cool if one runtime or

00:03:50,900 --> 00:03:56,570
during runtime very easily you could

00:03:53,030 --> 00:03:59,810
switch out that gripper but you know

00:03:56,570 --> 00:04:03,320
tying it back to the the topic the the

00:03:59,810 --> 00:04:04,880
title of this talk again some of these

00:04:03,320 --> 00:04:07,010
blocks and especially on the hardware

00:04:04,880 --> 00:04:11,510
side are going to be subject to real

00:04:07,010 --> 00:04:13,310
time constraints cool so you guys

00:04:11,510 --> 00:04:15,320
apparently all know what this is so I'm

00:04:13,310 --> 00:04:16,970
just gonna skim through this so we're

00:04:15,320 --> 00:04:18,950
all on the same page maybe our remote

00:04:16,970 --> 00:04:21,590
viewers like don't know or someone's

00:04:18,950 --> 00:04:22,710
consulting this talk to learn about it

00:04:21,590 --> 00:04:26,259
so

00:04:22,710 --> 00:04:26,590
people often complained conflate excuse

00:04:26,259 --> 00:04:28,840
me

00:04:26,590 --> 00:04:30,460
real-time performance and low latency

00:04:28,840 --> 00:04:31,719
but the definition of real-time

00:04:30,460 --> 00:04:34,300
performance is that your

00:04:31,719 --> 00:04:37,870
deterministically meeting a deadline and

00:04:34,300 --> 00:04:39,729
that when if you compute something after

00:04:37,870 --> 00:04:42,539
you've exceeded your deadline then that

00:04:39,729 --> 00:04:45,639
is an error or that is incorrect data

00:04:42,539 --> 00:04:47,560
and often latency and real-time

00:04:45,639 --> 00:04:49,539
performance are actually at odds because

00:04:47,560 --> 00:04:51,639
you may need more time to deliver the

00:04:49,539 --> 00:04:53,199
correct data and if you're trying to get

00:04:51,639 --> 00:04:58,509
a low latency system you're gonna you

00:04:53,199 --> 00:05:00,990
know exceed your deadline a lot so kind

00:04:58,509 --> 00:05:04,060
of a nice visual representation of this

00:05:00,990 --> 00:05:06,069
some terminology the deadline is is

00:05:04,060 --> 00:05:08,199
often you know this desired like

00:05:06,069 --> 00:05:10,509
constant update rate and you're gonna

00:05:08,199 --> 00:05:13,560
have a an allowable margin of error

00:05:10,509 --> 00:05:16,210
which is usually called the Kidder and

00:05:13,560 --> 00:05:21,699
you know some people call like exceeding

00:05:16,210 --> 00:05:24,039
the jibber the jitter overrun so the

00:05:21,699 --> 00:05:26,139
there's also different kinds of

00:05:24,039 --> 00:05:29,409
real-time cutter categorizations that

00:05:26,139 --> 00:05:30,849
depend on your use case and that they're

00:05:29,409 --> 00:05:34,440
often defined by what you do with the

00:05:30,849 --> 00:05:37,509
data after you've exceeded deadlines I

00:05:34,440 --> 00:05:40,319
guess another show of hands who here has

00:05:37,509 --> 00:05:42,279
worked on a hard real-time system before

00:05:40,319 --> 00:05:43,990
that's most of the people who raised

00:05:42,279 --> 00:05:49,120
their hands initially so cool you guys

00:05:43,990 --> 00:05:50,740
are pros so ya heard real-time system is

00:05:49,120 --> 00:05:53,500
when if you miss a deadline

00:05:50,740 --> 00:05:57,029
that's system failure you know go to a

00:05:53,500 --> 00:05:59,370
failure mode something is really bad and

00:05:57,029 --> 00:06:01,779
that's that's really important for

00:05:59,370 --> 00:06:05,379
systems where there's a lot of money or

00:06:01,779 --> 00:06:07,240
like human lives on the line if you have

00:06:05,379 --> 00:06:10,210
a malfunction and your nuclear reactor

00:06:07,240 --> 00:06:12,009
it could be really bad if you miss a

00:06:10,210 --> 00:06:14,110
data packet on your autonomous satellite

00:06:12,009 --> 00:06:17,439
you're gonna go out of orbit stuff like

00:06:14,110 --> 00:06:20,080
that a soft real-time system is one

00:06:17,439 --> 00:06:21,729
where you're tracking you're meeting

00:06:20,080 --> 00:06:23,740
your deadlines but you don't necessarily

00:06:21,729 --> 00:06:26,800
throw the data after you're aware that

00:06:23,740 --> 00:06:28,659
you missed a deadline for example you

00:06:26,800 --> 00:06:30,909
might be watching videos on YouTube and

00:06:28,659 --> 00:06:32,949
you start missing a lot of frames then

00:06:30,909 --> 00:06:35,050
the player might adapt its quality of

00:06:32,949 --> 00:06:37,750
service to

00:06:35,050 --> 00:06:40,150
that situation so it may give you more

00:06:37,750 --> 00:06:42,099
best-effort quality of service to

00:06:40,150 --> 00:06:45,580
delivery more cat videos or whatever

00:06:42,099 --> 00:06:48,129
you're watching and everything of those

00:06:45,580 --> 00:06:52,330
spectrum right so the the third category

00:06:48,129 --> 00:06:54,909
is firm real-time systems where you you

00:06:52,330 --> 00:06:57,669
may miss a deadline and you're gonna

00:06:54,909 --> 00:07:06,879
discard that do you want me to stop like

00:06:57,669 --> 00:07:10,569
moving around okay so you miss a

00:07:06,879 --> 00:07:13,449
deadline and you're gonna discard that

00:07:10,569 --> 00:07:15,370
data sample that you calculated instead

00:07:13,449 --> 00:07:16,599
of publishing it to you know another

00:07:15,370 --> 00:07:19,590
note that's going to process that data

00:07:16,599 --> 00:07:22,960
or instead of reacting to it in some way

00:07:19,590 --> 00:07:26,310
so but you're not gonna cause a total

00:07:22,960 --> 00:07:28,960
system error so this is I like this very

00:07:26,310 --> 00:07:31,270
you know concrete example here where

00:07:28,960 --> 00:07:33,400
you're making an autonomous assembly

00:07:31,270 --> 00:07:35,979
line you know you're manufacturing your

00:07:33,400 --> 00:07:38,590
green squares and you sense that you've

00:07:35,979 --> 00:07:41,830
missed a deadline and that means you

00:07:38,590 --> 00:07:43,630
could have made an error in in your

00:07:41,830 --> 00:07:45,250
assembly line something could be wrong

00:07:43,630 --> 00:07:47,529
with that product but you don't have

00:07:45,250 --> 00:07:49,210
more quality control but this is a kind

00:07:47,529 --> 00:07:50,529
of automated quality control where when

00:07:49,210 --> 00:07:55,630
you miss a deadline you discard the

00:07:50,529 --> 00:08:02,830
object and put it in the discarded red

00:07:55,630 --> 00:08:06,539
triangles box so you know take a step

00:08:02,830 --> 00:08:08,830
back from all this theory why do we care

00:08:06,539 --> 00:08:10,150
since you know a lot of people in this

00:08:08,830 --> 00:08:12,219
room have worked on real-time systems

00:08:10,150 --> 00:08:14,590
and we've heard people talk about it all

00:08:12,219 --> 00:08:16,960
day I think you guys all know why we

00:08:14,590 --> 00:08:18,729
care it's it's really important in

00:08:16,960 --> 00:08:20,740
robotics to know how to deal with time

00:08:18,729 --> 00:08:22,779
varying data and especially if we're

00:08:20,740 --> 00:08:25,770
going to make a system that's reactive

00:08:22,779 --> 00:08:28,300
that's going to adapt quickly and

00:08:25,770 --> 00:08:31,240
controllers that are going to adapt to

00:08:28,300 --> 00:08:33,760
you know variations in this unstable

00:08:31,240 --> 00:08:37,990
dynamic system you kind of need to be

00:08:33,760 --> 00:08:39,519
able to process data without missing

00:08:37,990 --> 00:08:41,589
deadlines and you're gonna need to

00:08:39,519 --> 00:08:43,630
profile your system to know what the

00:08:41,589 --> 00:08:45,870
maximum allowable latency you can have

00:08:43,630 --> 00:08:45,870
is

00:08:46,980 --> 00:08:54,220
so this has all been very high-level but

00:08:51,000 --> 00:08:57,460
you know this is Ross Kahn and I'm

00:08:54,220 --> 00:09:00,850
talking about Ross too so we really want

00:08:57,460 --> 00:09:02,980
Russ to to be real time safe we want it

00:09:00,850 --> 00:09:05,680
to not get in the way of your real-time

00:09:02,980 --> 00:09:10,750
system so how are you going to

00:09:05,680 --> 00:09:13,270
accomplish that well these are some like

00:09:10,750 --> 00:09:15,250
tricks of the trade and practice best

00:09:13,270 --> 00:09:18,490
practices so I thought I'd go over them

00:09:15,250 --> 00:09:20,050
to give you all an idea of what you know

00:09:18,490 --> 00:09:21,880
what I've gone through simplemente the

00:09:20,050 --> 00:09:25,110
system and what people who have

00:09:21,880 --> 00:09:27,370
implemented real-time systems before do

00:09:25,110 --> 00:09:30,910
first need to pick your operating system

00:09:27,370 --> 00:09:34,089
correctly and the the default operating

00:09:30,910 --> 00:09:35,830
the default scheduler on Linux is not

00:09:34,089 --> 00:09:37,450
considered real time safe it uses a

00:09:35,830 --> 00:09:39,070
non-deterministic scheduler that

00:09:37,450 --> 00:09:43,000
optimizes for fairness

00:09:39,070 --> 00:09:45,010
instead of determinism or priority right

00:09:43,000 --> 00:09:48,160
so our de preempt is a kernel patch

00:09:45,010 --> 00:09:50,980
which changes Linux threads to be fully

00:09:48,160 --> 00:09:52,290
preemptable and that's kind of

00:09:50,980 --> 00:09:54,730
considered soft real-time performance

00:09:52,290 --> 00:09:56,709
because you can you can get real-time

00:09:54,730 --> 00:09:59,680
like performance but there's nothing

00:09:56,709 --> 00:10:01,480
built into the kernel to to fail when

00:09:59,680 --> 00:10:03,430
you sense an exceeded deadline in fact

00:10:01,480 --> 00:10:05,050
the kernel has no concept of and

00:10:03,430 --> 00:10:08,880
exceeded deadlines that's your code

00:10:05,050 --> 00:10:11,290
level I've listed some other solutions

00:10:08,880 --> 00:10:11,860
on this slide mostly so you can google

00:10:11,290 --> 00:10:13,240
them later

00:10:11,860 --> 00:10:14,800
I'm not going to talk too much about the

00:10:13,240 --> 00:10:17,589
proprietary solutions because we're an

00:10:14,800 --> 00:10:20,200
open-source company but you know we like

00:10:17,589 --> 00:10:24,100
the POSIX in her face so that's that's a

00:10:20,200 --> 00:10:27,400
big plus and the fun fact the standard

00:10:24,100 --> 00:10:29,529
library in C++ the the thread library in

00:10:27,400 --> 00:10:30,970
C++ 11 doesn't expose some important

00:10:29,529 --> 00:10:33,970
things I'm going to talk about like

00:10:30,970 --> 00:10:36,279
thread scheduling so as I said you know

00:10:33,970 --> 00:10:39,640
the default thread scheduler on linux

00:10:36,279 --> 00:10:42,130
not real time safe and as well as the

00:10:39,640 --> 00:10:44,260
way the colonel handles threads but even

00:10:42,130 --> 00:10:47,080
after you you know if you select RT

00:10:44,260 --> 00:10:48,940
preempts as your operating system

00:10:47,080 --> 00:10:51,720
solution then you have to choose your

00:10:48,940 --> 00:10:54,820
scheduler correctly you need to choose a

00:10:51,720 --> 00:10:56,920
deterministic thread scheduler like FIFO

00:10:54,820 --> 00:10:57,130
round-robin deadline is kind of a new

00:10:56,920 --> 00:11:00,310
earth

00:10:57,130 --> 00:11:02,650
in the newer Linux kernel 3.18 or

00:11:00,310 --> 00:11:05,770
something and you need to choose a high

00:11:02,650 --> 00:11:07,540
priority level the priority level is how

00:11:05,770 --> 00:11:09,100
the the deterministic scheduler

00:11:07,540 --> 00:11:11,440
determines which threads can cramped

00:11:09,100 --> 00:11:12,640
others and you want your real-time for

00:11:11,440 --> 00:11:15,880
it to be pre-empting all the other

00:11:12,640 --> 00:11:19,350
threads which are not as good is that a

00:11:15,880 --> 00:11:22,510
question or use thank you

00:11:19,350 --> 00:11:25,540
so scheduling is not the only kind of

00:11:22,510 --> 00:11:28,780
hidden danger we can run into the

00:11:25,540 --> 00:11:31,000
default heap allocator in most systems

00:11:28,780 --> 00:11:33,970
and you know any major operating system

00:11:31,000 --> 00:11:37,210
I can think of is not deterministic or

00:11:33,970 --> 00:11:38,950
it may incur prohibitive penalties on

00:11:37,210 --> 00:11:41,170
your performance which is why usually

00:11:38,950 --> 00:11:43,390
people making real-time systems avoid

00:11:41,170 --> 00:11:46,890
heap allocation during a critical

00:11:43,390 --> 00:11:51,070
section during a real-time execution

00:11:46,890 --> 00:11:54,490
there are alternatives like an f1

00:11:51,070 --> 00:11:57,070
alligator is usually a memory allocator

00:11:54,490 --> 00:11:59,380
that is deterministic or it runs in a

00:11:57,070 --> 00:12:00,850
known constant time which you can

00:11:59,380 --> 00:12:02,200
profile and you can know that your

00:12:00,850 --> 00:12:04,090
memory allocations will only take that

00:12:02,200 --> 00:12:09,130
amount but I'm not going to talk too

00:12:04,090 --> 00:12:10,360
much about those today there's a anytime

00:12:09,130 --> 00:12:13,960
when you're doing multi-threaded code

00:12:10,360 --> 00:12:16,510
and you use new Texas or locks for a

00:12:13,960 --> 00:12:18,280
shared resource then you could run into

00:12:16,510 --> 00:12:20,350
a situation where you block for an

00:12:18,280 --> 00:12:22,960
indeterminate amount of time on that

00:12:20,350 --> 00:12:24,160
thread on that lock that's protecting

00:12:22,960 --> 00:12:26,650
the shared resource because you don't

00:12:24,160 --> 00:12:29,230
know how much another thread is going to

00:12:26,650 --> 00:12:31,060
need how long that other friend is going

00:12:29,230 --> 00:12:32,980
to need for that shared resource and

00:12:31,060 --> 00:12:37,330
also there's kind of this danger of

00:12:32,980 --> 00:12:39,220
deadlock be really bad there's kind of

00:12:37,330 --> 00:12:41,500
any there's a category of dangers for

00:12:39,220 --> 00:12:45,310
anything where you're walking on a

00:12:41,500 --> 00:12:46,720
response from a physical device is it

00:12:45,310 --> 00:12:49,540
generally means that you're going to

00:12:46,720 --> 00:12:53,800
incur a large latency penalty so

00:12:49,540 --> 00:12:57,220
printing to the screen is one if you

00:12:53,800 --> 00:13:00,250
block on sending a network packet but

00:12:57,220 --> 00:13:03,100
like TCP does then you're gonna be

00:13:00,250 --> 00:13:05,710
waiting for that packet to crawl through

00:13:03,100 --> 00:13:08,470
you know Ethernet cables it's gonna

00:13:05,710 --> 00:13:09,660
crawl through like the whole stock of

00:13:08,470 --> 00:13:12,570
the internet maybe

00:13:09,660 --> 00:13:15,840
you're not really sure so you don't want

00:13:12,570 --> 00:13:17,760
to block on a network call and panda you

00:13:15,840 --> 00:13:19,170
know in general anytime any device

00:13:17,760 --> 00:13:22,860
driver where you're blocking on a

00:13:19,170 --> 00:13:24,030
response so accessing the hard disk is

00:13:22,860 --> 00:13:25,710
another interaction with a physical

00:13:24,030 --> 00:13:30,990
device which is common and often not

00:13:25,710 --> 00:13:33,060
transparent to a user or a developer and

00:13:30,990 --> 00:13:34,680
I mentioned this with the heap allocator

00:13:33,060 --> 00:13:40,260
but I didn't go into too much detail so

00:13:34,680 --> 00:13:42,240
when you swap memory from RAM into main

00:13:40,260 --> 00:13:44,820
memory to make more room in your RAM for

00:13:42,240 --> 00:13:47,370
memory you're requesting and you could

00:13:44,820 --> 00:13:48,800
incur a very large penalty there's a lot

00:13:47,370 --> 00:13:50,910
there's a lot of unknown stuff going on

00:13:48,800 --> 00:13:53,490
to you especially if you're writing a

00:13:50,910 --> 00:13:55,800
portable program so the operating system

00:13:53,490 --> 00:13:57,930
when it's retrieving or when it's

00:13:55,800 --> 00:14:00,920
writing the memory from ram into main

00:13:57,930 --> 00:14:03,150
memory so you don't want to do that and

00:14:00,920 --> 00:14:05,160
actually what I just described is called

00:14:03,150 --> 00:14:07,260
the page fault it's called a major page

00:14:05,160 --> 00:14:09,210
fault actually so you know that's kind

00:14:07,260 --> 00:14:11,820
of the word that people will use you

00:14:09,210 --> 00:14:17,190
don't want to have page faults on in

00:14:11,820 --> 00:14:20,250
your real-time execution phase so I

00:14:17,190 --> 00:14:22,950
think now we're ready to talk about the

00:14:20,250 --> 00:14:26,400
the design choices that we're making in

00:14:22,950 --> 00:14:30,810
RAAS 2 to kind of facilitate an easy way

00:14:26,400 --> 00:14:34,320
for you to make real-time save code and

00:14:30,810 --> 00:14:38,490
to motivate this I've Illustrated kind

00:14:34,320 --> 00:14:39,990
of the a broad illustration of the

00:14:38,490 --> 00:14:41,310
different libraries that interact with

00:14:39,990 --> 00:14:43,890
each other or don't interact with each

00:14:41,310 --> 00:14:46,230
other when you write ross one code or

00:14:43,890 --> 00:14:48,600
Ross 2 code and you don't need to know

00:14:46,230 --> 00:14:50,520
all the details here but it's it's kind

00:14:48,600 --> 00:14:56,060
of the different choices you can make in

00:14:50,520 --> 00:14:59,550
your one program so here the green

00:14:56,060 --> 00:15:01,950
sections the green blocks are blocks

00:14:59,550 --> 00:15:06,330
that can be made real-time safe by our

00:15:01,950 --> 00:15:08,640
definition in Ross one I've also omitted

00:15:06,330 --> 00:15:10,020
Python because there's like there's a

00:15:08,640 --> 00:15:14,550
lot of problems with Python for this

00:15:10,020 --> 00:15:17,580
application in Ross one people rely on

00:15:14,550 --> 00:15:21,540
these external frameworks for real-time

00:15:17,580 --> 00:15:22,840
safe execution ross cpp the

00:15:21,540 --> 00:15:26,170
implementation is not

00:15:22,840 --> 00:15:29,230
realsense safe TCB Ross definitely want

00:15:26,170 --> 00:15:32,290
to avoid that as it just said UDP Ross

00:15:29,230 --> 00:15:33,790
you know maybe very good but again

00:15:32,290 --> 00:15:36,250
there's there's a lot of problems we've

00:15:33,790 --> 00:15:39,610
gone over or three DP or us and also

00:15:36,250 --> 00:15:41,890
it's blocked by the fact that it's a bit

00:15:39,610 --> 00:15:43,660
baked into the implementation it's it's

00:15:41,890 --> 00:15:48,130
built into the implementation of CTP

00:15:43,660 --> 00:15:50,850
it's not modular so the improvement

00:15:48,130 --> 00:15:54,400
we're trying to make in Ross - is that

00:15:50,850 --> 00:15:57,820
any path you can take through you know

00:15:54,400 --> 00:16:00,040
certain stocks it's configurable you can

00:15:57,820 --> 00:16:02,490
you can make the client library the

00:16:00,040 --> 00:16:05,110
equivalent of Ross CBP real time safe

00:16:02,490 --> 00:16:07,210
and as long as you choose your

00:16:05,110 --> 00:16:10,630
middleware and your operating system

00:16:07,210 --> 00:16:15,880
correctly then you can be successful in

00:16:10,630 --> 00:16:17,260
some kind of real time execution so how

00:16:15,880 --> 00:16:21,400
do we make things configurable we make

00:16:17,260 --> 00:16:23,650
them modular right there's kind of an

00:16:21,400 --> 00:16:25,990
idea where you know we've mentioned the

00:16:23,650 --> 00:16:29,890
executor a few times today the executor

00:16:25,990 --> 00:16:32,800
is this way of taking out the scheduling

00:16:29,890 --> 00:16:34,810
of your program separating it from the

00:16:32,800 --> 00:16:36,850
logic of your node by inserting the

00:16:34,810 --> 00:16:39,300
logic of the node into the executor

00:16:36,850 --> 00:16:42,640
which handles the the scheduling of

00:16:39,300 --> 00:16:45,730
tasks you need to do then the you've

00:16:42,640 --> 00:16:47,710
separated those two components and we're

00:16:45,730 --> 00:16:51,610
taking a similar strategy with memory

00:16:47,710 --> 00:16:56,140
management which I'll go into a little

00:16:51,610 --> 00:16:59,620
more detail this is a very simple kind

00:16:56,140 --> 00:17:01,930
of cartoon of the implementation of spin

00:16:59,620 --> 00:17:07,690
in Ross - it's a function of the

00:17:01,930 --> 00:17:10,510
executor executor exit executor and in

00:17:07,690 --> 00:17:12,760
in the real time case you're gonna have

00:17:10,510 --> 00:17:14,709
these phases right where you you pre

00:17:12,760 --> 00:17:17,140
allocate all of the memory into these

00:17:14,709 --> 00:17:20,890
pools you D allocate them when you're

00:17:17,140 --> 00:17:23,200
done when you're spinning you you

00:17:20,890 --> 00:17:26,110
consult those pre-allocated pools of

00:17:23,200 --> 00:17:28,840
memory if you need to allocate some

00:17:26,110 --> 00:17:30,130
representation of an object and kind of

00:17:28,840 --> 00:17:32,370
on the topic synchronization and

00:17:30,130 --> 00:17:34,800
blocking the

00:17:32,370 --> 00:17:36,930
you block to wait for work to come in

00:17:34,800 --> 00:17:40,260
asynchronously like you're you're

00:17:36,930 --> 00:17:41,970
waiting for your you know publisher

00:17:40,260 --> 00:17:44,550
you're subscribed to to send a message

00:17:41,970 --> 00:17:45,870
and you block but you're not you're

00:17:44,550 --> 00:17:47,550
gonna block with the time out you're

00:17:45,870 --> 00:17:48,720
gonna wake up and if nothing came in

00:17:47,550 --> 00:17:51,960
you're just gonna say nothing came in

00:17:48,720 --> 00:17:54,809
but I'm updating so it's okay

00:17:51,960 --> 00:17:55,980
you can block indefinitely but again

00:17:54,809 --> 00:17:58,590
we're not going to do that in this case

00:17:55,980 --> 00:18:02,520
so the blocking is handled by the DDS

00:17:58,590 --> 00:18:03,809
implementation and that allows us to say

00:18:02,520 --> 00:18:05,700
you know if we trust this DDS

00:18:03,809 --> 00:18:07,590
implementation to be real time safe and

00:18:05,700 --> 00:18:09,450
it should be because that's actually a

00:18:07,590 --> 00:18:11,940
part of the spec and what it's kind of

00:18:09,450 --> 00:18:19,530
built for then you know this blocking is

00:18:11,940 --> 00:18:21,690
fine so the way we handle this we

00:18:19,530 --> 00:18:23,750
specify this pre allocation strategy is

00:18:21,690 --> 00:18:26,340
to the constructor of the executor

00:18:23,750 --> 00:18:28,320
optionally you can pass an object that's

00:18:26,340 --> 00:18:30,540
called a memory strategy and that memory

00:18:28,320 --> 00:18:32,490
strategy owns the pre-allocated pools

00:18:30,540 --> 00:18:35,040
that you use in for real-time execution

00:18:32,490 --> 00:18:38,250
but by default it has no state and it

00:18:35,040 --> 00:18:41,570
just calls new and delete when the user

00:18:38,250 --> 00:18:48,929
wants to new and delete something oops

00:18:41,570 --> 00:18:51,240
okay so that comic I just showed you

00:18:48,929 --> 00:18:57,630
Maps kind of nicely to this idea of node

00:18:51,240 --> 00:18:59,820
lifecycle essentially you know you this

00:18:57,630 --> 00:19:02,130
came up in the the talk someone asked a

00:18:59,820 --> 00:19:03,720
question about this where you know do

00:19:02,130 --> 00:19:06,720
you want to write a custom main or not

00:19:03,720 --> 00:19:09,030
and for real-time execution it would be

00:19:06,720 --> 00:19:10,650
really nice if instead of you know

00:19:09,030 --> 00:19:12,059
saying alright I've got this

00:19:10,650 --> 00:19:15,090
initialization phase and then I call

00:19:12,059 --> 00:19:17,220
spin and then something happens and then

00:19:15,090 --> 00:19:20,250
we're out of spin and then we're in the

00:19:17,220 --> 00:19:22,260
teardown face then instead we have this

00:19:20,250 --> 00:19:24,630
defined API and this defines state

00:19:22,260 --> 00:19:27,929
machine where all you need to do is

00:19:24,630 --> 00:19:30,600
write what what the executor does and

00:19:27,929 --> 00:19:34,020
the the subscribers and the publishers

00:19:30,600 --> 00:19:35,520
for your node and we we've you know

00:19:34,020 --> 00:19:37,170
getting we're getting inspiration from

00:19:35,520 --> 00:19:40,980
these existing frameworks a lot of

00:19:37,170 --> 00:19:42,720
people in the Ross community use so

00:19:40,980 --> 00:19:45,360
we're actually actively designing this

00:19:42,720 --> 00:19:47,280
right now so this picture could be

00:19:45,360 --> 00:19:50,510
to change but it's kind of the basic

00:19:47,280 --> 00:19:53,460
ideas which is pretty easy to understand

00:19:50,510 --> 00:19:57,299
you have a state machine you create your

00:19:53,460 --> 00:20:02,400
node and on each transition in this

00:19:57,299 --> 00:20:04,080
diagram this is kind of a message right

00:20:02,400 --> 00:20:06,690
it's it's either a function or it's a

00:20:04,080 --> 00:20:08,880
service call and there's some kind of

00:20:06,690 --> 00:20:10,620
callback that happens so you say I'm

00:20:08,880 --> 00:20:13,740
initializing my node or I'm creating my

00:20:10,620 --> 00:20:16,500
node and this is my user callback for

00:20:13,740 --> 00:20:18,780
what happens when I do that and in a

00:20:16,500 --> 00:20:22,020
real-time execution context that means

00:20:18,780 --> 00:20:25,790
you know I'm I'm in oncreate and I

00:20:22,020 --> 00:20:28,230
pre-allocate all with my pools memory

00:20:25,790 --> 00:20:31,610
inactive is kind of a state where you

00:20:28,230 --> 00:20:34,049
are not doing anything but you are

00:20:31,610 --> 00:20:36,390
constructed all the objects are in

00:20:34,049 --> 00:20:38,280
memory right but you could be

00:20:36,390 --> 00:20:41,700
reconfigured so some of your parameters

00:20:38,280 --> 00:20:45,450
could change you being the node active

00:20:41,700 --> 00:20:48,679
is the only state where the information

00:20:45,450 --> 00:20:51,750
you're producing as a node is is valid

00:20:48,679 --> 00:20:53,640
in the other states these are kind of

00:20:51,750 --> 00:20:57,179
configuration States that are saying I

00:20:53,640 --> 00:20:59,549
exist but I'm not doing anything that's

00:20:57,179 --> 00:21:03,210
relevant to the correctness of my

00:20:59,549 --> 00:21:06,059
program and you know parallel to created

00:21:03,210 --> 00:21:08,490
we have a state that's ondestroy

00:21:06,059 --> 00:21:10,470
so customizing that is kind of like a

00:21:08,490 --> 00:21:13,410
bit like customizing your having a

00:21:10,470 --> 00:21:14,790
custom destructor for an object and also

00:21:13,410 --> 00:21:18,000
you might want to be able to react to

00:21:14,790 --> 00:21:19,770
errors kind of you know going back to in

00:21:18,000 --> 00:21:23,309
hard real-time systems if you have an

00:21:19,770 --> 00:21:26,460
error mode you want to reset if you

00:21:23,309 --> 00:21:29,580
reached an exception so the takeaway for

00:21:26,460 --> 00:21:32,040
this is this abstraction is really nice

00:21:29,580 --> 00:21:35,280
if we want to denote this as the only

00:21:32,040 --> 00:21:40,950
real-time safe or real-time critical

00:21:35,280 --> 00:21:42,960
section of our code and it also has a

00:21:40,950 --> 00:21:45,030
lot of benefits besides real-time safety

00:21:42,960 --> 00:21:47,600
for anyone in this talk who's totally

00:21:45,030 --> 00:21:51,799
not interested in the subject at all

00:21:47,600 --> 00:21:55,110
so going back a little to our original

00:21:51,799 --> 00:21:57,780
original example we talked a lot about

00:21:55,110 --> 00:21:58,630
composing nodes and I'll go into a

00:21:57,780 --> 00:22:04,180
little more depth

00:21:58,630 --> 00:22:07,960
about this right now so one connection

00:22:04,180 --> 00:22:10,900
to note composability and what I just

00:22:07,960 --> 00:22:13,600
described is that when you compose

00:22:10,900 --> 00:22:16,300
several nodes in the same process a

00:22:13,600 --> 00:22:19,980
potential benefit is that you could sync

00:22:16,300 --> 00:22:22,200
up their lifecycle because their their

00:22:19,980 --> 00:22:25,780
execution is kind of tied to each other

00:22:22,200 --> 00:22:28,210
as I said before you know there's this

00:22:25,780 --> 00:22:31,900
nice separation of execution and logic

00:22:28,210 --> 00:22:33,430
and there's also a performance benefit

00:22:31,900 --> 00:22:37,500
we get because we really care about

00:22:33,430 --> 00:22:40,090
performance in real time and that's the

00:22:37,500 --> 00:22:44,260
shared interprocess pipeline that

00:22:40,090 --> 00:22:46,450
william presented so the idea with node

00:22:44,260 --> 00:22:49,000
composability if is if you put many

00:22:46,450 --> 00:22:52,930
nodes in the same process then they can

00:22:49,000 --> 00:22:55,000
take advantage of this pipeline so

00:22:52,930 --> 00:22:57,910
speaking of communications there I

00:22:55,000 --> 00:23:01,600
wanted to illustrate the different kinds

00:22:57,910 --> 00:23:05,100
of Ross to communications in the context

00:23:01,600 --> 00:23:08,350
of their real time safety so it kind of

00:23:05,100 --> 00:23:10,450
like the more locality that you have and

00:23:08,350 --> 00:23:11,410
the two nodes or entities that are

00:23:10,450 --> 00:23:15,600
talking to each other the more

00:23:11,410 --> 00:23:19,060
determinism you have and vice versa so

00:23:15,600 --> 00:23:21,040
inter-process and over and you know

00:23:19,060 --> 00:23:25,480
between device communication there's

00:23:21,040 --> 00:23:26,980
this extra you know distance they have

00:23:25,480 --> 00:23:29,680
to travel and there's more chances for

00:23:26,980 --> 00:23:33,280
non-determinism to rear its ugly head

00:23:29,680 --> 00:23:34,810
but luckily DDS has a lot of stuff we

00:23:33,280 --> 00:23:38,410
kind of get for free like quality of

00:23:34,810 --> 00:23:42,220
service that make inter process and

00:23:38,410 --> 00:23:45,880
Inter device communication kind of soft

00:23:42,220 --> 00:23:49,270
real-time safe again the inter process

00:23:45,880 --> 00:23:51,340
in process inter process pipeline is

00:23:49,270 --> 00:23:54,310
really helpful for us because we can

00:23:51,340 --> 00:24:00,010
avoid incurring penalties on copying

00:23:54,310 --> 00:24:02,950
memory but coordinating the shared

00:24:00,010 --> 00:24:07,030
access to these shared resources also

00:24:02,950 --> 00:24:09,880
could could introduce non determinism as

00:24:07,030 --> 00:24:11,680
I said before synchronization primitives

00:24:09,880 --> 00:24:13,540
mutexes locks there

00:24:11,680 --> 00:24:17,620
all tricky to coordinate unless you do

00:24:13,540 --> 00:24:20,410
it in a locked free manner and you know

00:24:17,620 --> 00:24:22,840
the the simplest and easiest thing to do

00:24:20,410 --> 00:24:24,160
is say you know I have these variables

00:24:22,840 --> 00:24:25,960
in the threat I have a class shares

00:24:24,160 --> 00:24:27,610
memory you know I don't need to worry

00:24:25,960 --> 00:24:29,320
about other threats accessing it but

00:24:27,610 --> 00:24:35,530
again that's very simple and I might not

00:24:29,320 --> 00:24:38,370
be suited to your use case so you know

00:24:35,530 --> 00:24:41,440
the update on where Roscoe is today

00:24:38,370 --> 00:24:45,220
basically we we've worked a lot on

00:24:41,440 --> 00:24:47,170
memory allocation and making the making

00:24:45,220 --> 00:24:49,030
raus to configurable so your executor

00:24:47,170 --> 00:24:52,420
can have real time safe memory

00:24:49,030 --> 00:24:54,370
allocation through having a kind of

00:24:52,420 --> 00:24:56,410
memory pools their allocated on the heap

00:24:54,370 --> 00:24:59,770
beforehand and you need to know have a

00:24:56,410 --> 00:25:01,870
hard limit a known limit on the entities

00:24:59,770 --> 00:25:03,430
that you're going to publish and

00:25:01,870 --> 00:25:04,990
subscribe to and Morgan actually

00:25:03,430 --> 00:25:07,540
mentioned this and this talked about for

00:25:04,990 --> 00:25:10,750
your TPS because you can't dynamically

00:25:07,540 --> 00:25:14,490
grow the size of the memory that you're

00:25:10,750 --> 00:25:16,900
using in the real time safe section

00:25:14,490 --> 00:25:19,150
there's also a current limitation where

00:25:16,900 --> 00:25:21,850
the messages have to have a static size

00:25:19,150 --> 00:25:23,500
so we can't use things like strings but

00:25:21,850 --> 00:25:28,270
adolfo actually has a really interesting

00:25:23,500 --> 00:25:31,840
ways of getting around that so you know

00:25:28,270 --> 00:25:33,520
what's coming up for us we talked a lot

00:25:31,840 --> 00:25:36,700
about component lifecycle and that's

00:25:33,520 --> 00:25:39,790
kind of the the biggest next thing we're

00:25:36,700 --> 00:25:42,040
going to tackle as well as and go kind

00:25:39,790 --> 00:25:45,610
of goes hand-in-hand in that is the node

00:25:42,040 --> 00:25:48,730
composability and there's actually kind

00:25:45,610 --> 00:25:50,170
of a caveat with the intro process

00:25:48,730 --> 00:25:51,910
pipeline right now is that it's actually

00:25:50,170 --> 00:25:55,030
not real time safe because it uses

00:25:51,910 --> 00:25:56,710
mutexes standard mutex and so the

00:25:55,030 --> 00:25:58,990
alternative to that is implementing it

00:25:56,710 --> 00:26:00,310
in a lock free way so anyone who's not

00:25:58,990 --> 00:26:02,920
familiar with lock free programming

00:26:00,310 --> 00:26:04,720
really quick it's kind of like instead

00:26:02,920 --> 00:26:06,160
of waiting in line to go through one

00:26:04,720 --> 00:26:08,620
door that one person can fit through

00:26:06,160 --> 00:26:17,200
it's like using a revolving door think

00:26:08,620 --> 00:26:17,770
about that so to go over why this is a

00:26:17,200 --> 00:26:19,690
good idea

00:26:17,770 --> 00:26:21,880
we're going to use a specific example

00:26:19,690 --> 00:26:23,970
which is Ross control because that's

00:26:21,880 --> 00:26:25,740
what a lot of people in this room is for

00:26:23,970 --> 00:26:28,010
familiar with and it also is the creator

00:26:25,740 --> 00:26:31,500
and maintainer

00:26:28,010 --> 00:26:33,510
so it basically Ross controlled does

00:26:31,500 --> 00:26:36,660
these first two things and it doesn't

00:26:33,510 --> 00:26:39,540
really well it does not be the third

00:26:36,660 --> 00:26:42,660
thing and it's it's an often requested

00:26:39,540 --> 00:26:45,560
feature actually but it would be very

00:26:42,660 --> 00:26:47,910
difficult it's it is difficult for

00:26:45,560 --> 00:26:51,530
Adolfo to implement this in rescue right

00:26:47,910 --> 00:26:53,880
now so Ross control no note

00:26:51,530 --> 00:26:55,380
composability but as we saw in our

00:26:53,880 --> 00:26:58,740
example it would be really nice to have

00:26:55,380 --> 00:27:00,450
that for something like Ross control

00:26:58,740 --> 00:27:01,890
where there are many blocks in your

00:27:00,450 --> 00:27:04,650
system diagram of what your controllers

00:27:01,890 --> 00:27:08,040
gonna look like I don't foot did this

00:27:04,650 --> 00:27:12,360
great kind of data analysis on his

00:27:08,040 --> 00:27:15,990
codebase and saw that 55% of the code

00:27:12,360 --> 00:27:18,500
base 25 plus 30 is dedicated to things

00:27:15,990 --> 00:27:21,720
were planning to do natively in Ross -

00:27:18,500 --> 00:27:25,350
so that means that when Ross control

00:27:21,720 --> 00:27:28,170
gets migrated to Russ - it will be half

00:27:25,350 --> 00:27:30,090
as big and that is a big win and it

00:27:28,170 --> 00:27:35,610
makes it all foes life a lot easier as

00:27:30,090 --> 00:27:36,990
the maintainer of this repository so I

00:27:35,610 --> 00:27:39,480
mentioned I may have mentioned earlier

00:27:36,990 --> 00:27:40,920
that I did benchmarking on all these

00:27:39,480 --> 00:27:43,830
claims that I'm making in the

00:27:40,920 --> 00:27:47,310
presentation and I'll just talk a little

00:27:43,830 --> 00:27:49,350
bit about them this is the setup that I

00:27:47,310 --> 00:27:51,180
made it's it's an inverted pendulum

00:27:49,350 --> 00:27:53,430
simulator and the inverted pendulum is

00:27:51,180 --> 00:27:56,220
kind of this classic difficult control

00:27:53,430 --> 00:27:59,070
problem that is also you know it's like

00:27:56,220 --> 00:28:00,630
simplification of a humanoid Walker this

00:27:59,070 --> 00:28:02,460
is kind of the schematic you know we

00:28:00,630 --> 00:28:05,400
don't know if our key to yet in Raza - I

00:28:02,460 --> 00:28:07,620
guess could use the bridge um we have a

00:28:05,400 --> 00:28:09,090
PID controller and a simulator and these

00:28:07,620 --> 00:28:10,580
are two separate nodes kind of to

00:28:09,090 --> 00:28:13,110
motivate when we have node composability

00:28:10,580 --> 00:28:15,320
the simulator could be swapped out with

00:28:13,110 --> 00:28:18,180
a hardware interface to a real pendulum

00:28:15,320 --> 00:28:19,860
we also have two non real-time processes

00:28:18,180 --> 00:28:23,070
that are interacting with the real-time

00:28:19,860 --> 00:28:29,370
process one for tally up so if the user

00:28:23,070 --> 00:28:31,620
once wanted to type in a command a an

00:28:29,370 --> 00:28:34,080
angle for this pendulum to balance

00:28:31,620 --> 00:28:35,239
itself at and we have a logger which

00:28:34,080 --> 00:28:36,769
does

00:28:35,239 --> 00:28:40,639
operations I said were non-real-time

00:28:36,769 --> 00:28:42,979
safe like console output and recording

00:28:40,639 --> 00:28:46,969
all the benchmarking results to hard

00:28:42,979 --> 00:28:49,909
disk so more in-depth technical details

00:28:46,969 --> 00:28:51,889
I used RT preempt which is again the

00:28:49,909 --> 00:28:55,460
Linux kernel patch not a hard real-time

00:28:51,889 --> 00:28:57,979
system I chose a round-robin scheduler

00:28:55,460 --> 00:29:00,529
and third priority 98 because third

00:28:57,979 --> 00:29:02,929
priority 99 ends up clobbering

00:29:00,529 --> 00:29:08,179
some important systems processes she's

00:29:02,929 --> 00:29:12,109
really bad there's a nice trick where

00:29:08,179 --> 00:29:14,899
you can replace the malloc call which

00:29:12,109 --> 00:29:17,089
was really helpful for tracking Malick's

00:29:14,899 --> 00:29:20,179
and heap allocations made on the

00:29:17,089 --> 00:29:23,080
real-time execution path and I get our

00:29:20,179 --> 00:29:25,429
usage is a system column on Linux for

00:29:23,080 --> 00:29:29,149
tracking resource allocations for a

00:29:25,429 --> 00:29:32,269
particular process so kind of the goal

00:29:29,149 --> 00:29:34,489
that I've set for the system is a one

00:29:32,269 --> 00:29:36,559
kilohertz update loop with three percent

00:29:34,489 --> 00:29:39,739
jitter and this is kind of a golden

00:29:36,559 --> 00:29:42,379
standard that we hear a lot about in

00:29:39,739 --> 00:29:46,519
robotics basically based on how fast

00:29:42,379 --> 00:29:49,219
your motor can update oh yeah and you

00:29:46,519 --> 00:29:53,779
can see the code on github oops

00:29:49,219 --> 00:29:56,690
spoilers so I'm happy to report there

00:29:53,779 --> 00:29:58,729
were zero runtime allocations and the

00:29:56,690 --> 00:30:01,309
way I figured this out is that my custom

00:29:58,729 --> 00:30:03,979
malloc basically looks at this global

00:30:01,309 --> 00:30:07,279
boolean that gets set to true it's kind

00:30:03,979 --> 00:30:10,009
of faking the life cycle this is like

00:30:07,279 --> 00:30:12,169
the active stage so if it's active then

00:30:10,009 --> 00:30:14,749
we just throw an error and we never see

00:30:12,169 --> 00:30:17,479
that exception when we're running the

00:30:14,749 --> 00:30:19,669
benchmark we also see zero major page

00:30:17,479 --> 00:30:21,679
faults because I collect the page faults

00:30:19,669 --> 00:30:23,330
on every iteration of the loop and

00:30:21,679 --> 00:30:27,499
there's some minor page faults minor

00:30:23,330 --> 00:30:29,269
page faults or when the address and RAM

00:30:27,499 --> 00:30:33,409
isn't yet mapped into the memory

00:30:29,269 --> 00:30:35,779
management unit but as you'll see in the

00:30:33,409 --> 00:30:41,149
next slide the penalty incurred by that

00:30:35,779 --> 00:30:43,489
is okay it's okay so this is a time

00:30:41,149 --> 00:30:46,009
series of the latency where the latency

00:30:43,489 --> 00:30:46,990
is the time between the last two

00:30:46,009 --> 00:30:51,070
execution

00:30:46,990 --> 00:30:54,640
iterations - one millisecond our goal

00:30:51,070 --> 00:30:59,950
and I've highlighted with the dashed

00:30:54,640 --> 00:31:02,470
line what are acceptable jitter is so

00:30:59,950 --> 00:31:05,080
you can see pretty I hope you can see

00:31:02,470 --> 00:31:08,200
these lines there's one instance of

00:31:05,080 --> 00:31:10,210
overrun and that instance is three point

00:31:08,200 --> 00:31:12,399
five percent of our update rate which is

00:31:10,210 --> 00:31:15,309
0.5% above what we said are allowable

00:31:12,399 --> 00:31:17,500
shooter was and this histogram is just

00:31:15,309 --> 00:31:21,130
to give you an idea that the mean of the

00:31:17,500 --> 00:31:23,529
data is really quite far away from this

00:31:21,130 --> 00:31:25,570
data point but again the scale of this

00:31:23,529 --> 00:31:27,760
is really big because there's a data

00:31:25,570 --> 00:31:30,370
point here but again it only happens

00:31:27,760 --> 00:31:35,740
once so you can't even see anything

00:31:30,370 --> 00:31:37,929
there so I also had a longer run that

00:31:35,740 --> 00:31:39,820
was seven times as long and applies some

00:31:37,929 --> 00:31:41,529
stress on the system so stress is a

00:31:39,820 --> 00:31:43,570
really nice tool that just spins up

00:31:41,529 --> 00:31:46,659
worker threads that do stuff over and

00:31:43,570 --> 00:31:50,919
over again so there it's putting stress

00:31:46,659 --> 00:31:52,809
on the CPU and stress on IO so here

00:31:50,919 --> 00:31:54,010
there were three instances over run and

00:31:52,809 --> 00:31:58,419
there the spikes are a lot bigger

00:31:54,010 --> 00:31:59,770
they're 25% of the update loop but you

00:31:58,419 --> 00:32:01,240
know it's still pretty good that we're

00:31:59,770 --> 00:32:04,539
not exceeding right not actually

00:32:01,240 --> 00:32:07,059
exceeding one millisecond and again the

00:32:04,539 --> 00:32:10,570
histogram you know scale is still crazy

00:32:07,059 --> 00:32:18,340
but we're like an acceptable margin away

00:32:10,570 --> 00:32:21,220
from our maximum jitter so these results

00:32:18,340 --> 00:32:24,039
are I think quite encouraging and I

00:32:21,220 --> 00:32:26,140
think they would be suited to a soft

00:32:24,039 --> 00:32:27,640
real-time system but of course you know

00:32:26,140 --> 00:32:28,960
there's still a long path ahead of us

00:32:27,640 --> 00:32:30,159
there's a lot of features we need to

00:32:28,960 --> 00:32:32,559
implement that I went over that would be

00:32:30,159 --> 00:32:34,000
nice to have and it would make real-time

00:32:32,559 --> 00:32:37,390
systems in Ross a lot more convenient

00:32:34,000 --> 00:32:40,029
and we also need to audit the code for

00:32:37,390 --> 00:32:41,950
real-time safety and more features but

00:32:40,029 --> 00:32:44,649
it's a very exciting field there's a lot

00:32:41,950 --> 00:32:46,539
of interest in it and if you are

00:32:44,649 --> 00:32:48,429
interested if you want to learn more if

00:32:46,539 --> 00:32:50,799
you want to lend your expertise working

00:32:48,429 --> 00:32:53,710
on real-time systems then please talk to

00:32:50,799 --> 00:32:55,029
me talk to the team get involved on sig

00:32:53,710 --> 00:32:57,840
and gee we'd love to hear from you

00:32:55,029 --> 00:32:57,840
thanks

00:33:01,059 --> 00:33:09,330
we've got

00:33:02,950 --> 00:33:09,330
since Peter

00:33:11,440 --> 00:33:14,250
hmm

00:33:17,610 --> 00:33:24,880
so the question was what is the source

00:33:20,140 --> 00:33:26,680
of the overrun in this slide so I need I

00:33:24,880 --> 00:33:28,840
need to run more data just to see what

00:33:26,680 --> 00:33:30,520
the conclusion is and there isn't enough

00:33:28,840 --> 00:33:33,760
introspection to see like exactly the

00:33:30,520 --> 00:33:38,590
line of code where the you know where

00:33:33,760 --> 00:33:39,910
the latency was but I actually think it

00:33:38,590 --> 00:33:41,830
has to do with the stress command

00:33:39,910 --> 00:33:45,430
because I don't see latency of this

00:33:41,830 --> 00:33:48,970
sighs when I run it without stress

00:33:45,430 --> 00:33:51,400
basically so you know as I said on the

00:33:48,970 --> 00:33:53,200
last slide I wasn't and again you know

00:33:51,400 --> 00:33:54,400
the the size of the data is different so

00:33:53,200 --> 00:33:58,270
maybe this isn't statistically

00:33:54,400 --> 00:34:01,720
significant but this the size of this

00:33:58,270 --> 00:34:06,640
overrun the maximum one is 25% of one

00:34:01,720 --> 00:34:08,740
millisecond you know 2,250 microseconds

00:34:06,640 --> 00:34:22,090
and the size of this jitter is way

00:34:08,740 --> 00:34:24,460
smaller mm-hmm yeah yeah yes so so he

00:34:22,090 --> 00:34:27,280
pointed out that the latency in this

00:34:24,460 --> 00:34:29,500
graph is probably due to startup and I

00:34:27,280 --> 00:34:30,880
totally agree there's minor page faults

00:34:29,500 --> 00:34:33,510
on the first iteration of the loop and

00:34:30,880 --> 00:34:36,510
so this probably interrupts that are

00:34:33,510 --> 00:34:36,510
Dave

00:34:39,750 --> 00:34:50,369
well in the wrong direction so he asked

00:34:48,629 --> 00:34:53,070
if in node lifecycle

00:34:50,369 --> 00:34:56,820
these are controller nodes or just any

00:34:53,070 --> 00:34:58,680
node right yeah so we'd like notes like

00:34:56,820 --> 00:35:01,500
node lifecycle to be available for any

00:34:58,680 --> 00:35:09,270
node that's kind of the idea in

00:35:01,500 --> 00:35:11,040
implementing it in the core stack so he

00:35:09,270 --> 00:35:13,859
asked if we need it in all applications

00:35:11,040 --> 00:35:16,500
so actually in Stefan's talk earlier

00:35:13,859 --> 00:35:19,740
today he had a pattern that was really

00:35:16,500 --> 00:35:21,750
similar to this in one of his tools so I

00:35:19,740 --> 00:35:27,200
think it would be useful in other

00:35:21,750 --> 00:35:27,200
applications yeah in the back

00:35:46,200 --> 00:35:57,370
this one is it real the executor is a

00:35:55,840 --> 00:36:03,300
real-time program is that what you said

00:35:57,370 --> 00:36:03,300
threat threat yes yes

00:36:17,089 --> 00:36:20,089
yeah

00:36:30,930 --> 00:36:37,930
right so he pointed out that you know

00:36:36,460 --> 00:36:40,210
I've made a huge oversight and not

00:36:37,930 --> 00:36:43,029
including any other system than are too

00:36:40,210 --> 00:36:44,859
cramped which I totally agree with it's

00:36:43,029 --> 00:36:48,130
it's very important that we design for

00:36:44,859 --> 00:36:49,210
more than one platform I just haven't

00:36:48,130 --> 00:36:52,059
done it for this initial proof of

00:36:49,210 --> 00:36:56,640
concept but I also want to point out

00:36:52,059 --> 00:36:59,319
that this this code is not specific to

00:36:56,640 --> 00:37:02,049
like Russ to is not specific to Artie

00:36:59,319 --> 00:37:05,229
preamps the executor that I implemented

00:37:02,049 --> 00:37:06,880
uses pthreads and it's kind of made with

00:37:05,229 --> 00:37:09,160
Artie preempt in mind but you could

00:37:06,880 --> 00:37:10,989
implement a different executor that uses

00:37:09,160 --> 00:37:17,849
whatever permit is are available in

00:37:10,989 --> 00:37:17,849
Zeinab I will talk later in the middle

00:37:27,110 --> 00:37:31,130
sorry can you repeat the last part

00:37:36,420 --> 00:37:42,119
you sorry I have it a little too quiet

00:37:48,000 --> 00:37:54,100
so you're asking if you can specify a

00:37:52,060 --> 00:37:56,890
certain deadline on the API level like

00:37:54,100 --> 00:38:01,960
have a have an API called it says set

00:37:56,890 --> 00:38:05,070
deadline whatever so I I think having

00:38:01,960 --> 00:38:08,080
such an API call what kind of breaks

00:38:05,070 --> 00:38:10,600
well this is total opinion but I think

00:38:08,080 --> 00:38:12,130
that would break the goal to have Ross

00:38:10,600 --> 00:38:13,930
to kind of available for both real-time

00:38:12,130 --> 00:38:15,490
and non real-time systems so a set

00:38:13,930 --> 00:38:17,950
deadline would be meaningless in a non

00:38:15,490 --> 00:38:20,890
real-time system I think that would be

00:38:17,950 --> 00:38:23,410
suitable is like a parameter that could

00:38:20,890 --> 00:38:24,820
be read by a real-time executor and that

00:38:23,410 --> 00:38:27,430
way you can use a parameter interface to

00:38:24,820 --> 00:38:34,530
change your deadline if you wanted to or

00:38:27,430 --> 00:38:34,530
specify that in maybe a launch file Mike

00:38:54,510 --> 00:38:59,530
absolutely

00:38:55,660 --> 00:39:01,630
so Mike just this is just a statement so

00:38:59,530 --> 00:39:03,640
I'm not gonna respond to it but he

00:39:01,630 --> 00:39:07,540
pointed out that a big win with this

00:39:03,640 --> 00:39:09,160
design is that frost control controllers

00:39:07,540 --> 00:39:11,140
and components are kind of first-class

00:39:09,160 --> 00:39:13,930
citizens that can be inspected with

00:39:11,140 --> 00:39:17,770
tools which is not how Ross mutual works

00:39:13,930 --> 00:39:19,390
right now yeah I mean in a in a sentence

00:39:17,770 --> 00:39:21,370
the headline air is that you can call

00:39:19,390 --> 00:39:22,900
publish and you can have your subscriber

00:39:21,370 --> 00:39:24,400
callbacks invoked in a real-time safe

00:39:22,900 --> 00:39:25,990
way which you just can't do in any

00:39:24,400 --> 00:39:29,440
fashion and ruslan without implementing

00:39:25,990 --> 00:39:32,040
a completely parallel system one more

00:39:29,440 --> 00:39:32,040
bill

00:39:44,210 --> 00:39:50,510
so I'm publishing the error as a message

00:39:47,540 --> 00:39:54,740
right now in my example it so it could

00:39:50,510 --> 00:39:58,130
certainly be published to a tool an

00:39:54,740 --> 00:40:02,150
external tool yeah but it's kind of an

00:39:58,130 --> 00:40:04,450
implementation detail alright thanks

00:40:02,150 --> 00:40:04,450

YouTube URL: https://www.youtube.com/watch?v=lwgOagS4kGQ


