Title: ROS + Docker ROSCon 2015 Hamburg Day 1 Ruffin White
Publication date: 2015-12-08
Playlist: ROSCon 2015
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2015 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,030 --> 00:00:03,890
thank you yep my name is Ruffin and

00:00:02,010 --> 00:00:06,629
today I'm going to be talking about

00:00:03,890 --> 00:00:10,230
enabling repeatable reproducible and

00:00:06,629 --> 00:00:13,170
deployable software robotic software via

00:00:10,230 --> 00:00:16,199
Linux containers and so if you've been

00:00:13,170 --> 00:00:18,180
following the latest issue of say

00:00:16,199 --> 00:00:20,609
robotics and automation or maybe

00:00:18,180 --> 00:00:23,010
computing way back in 2007 you've been

00:00:20,609 --> 00:00:27,269
seeing that these projects of kind of

00:00:23,010 --> 00:00:29,400
making repeatable research or code bases

00:00:27,269 --> 00:00:33,960
easier either through ipython notebooks

00:00:29,400 --> 00:00:35,430
or for Linux containers I've just been

00:00:33,960 --> 00:00:37,200
kind of accumulating and so there's

00:00:35,430 --> 00:00:39,450
there's a lot of people talking about

00:00:37,200 --> 00:00:43,620
these topics and so here I've just

00:00:39,450 --> 00:00:49,829
listed a few citations of some of the

00:00:43,620 --> 00:00:52,649
articles about this and so who has who

00:00:49,829 --> 00:00:54,660
has used Linux container do people know

00:00:52,649 --> 00:00:58,370
what links containers are alright

00:00:54,660 --> 00:01:01,199
roughly like 10% for the non-initiated

00:00:58,370 --> 00:01:04,320
I'm a double D so I'm not a complete

00:01:01,199 --> 00:01:06,479
software engineer but how I interpreted

00:01:04,320 --> 00:01:09,740
Linux containers is there's someone on

00:01:06,479 --> 00:01:14,070
the spectrum of virtual machines and

00:01:09,740 --> 00:01:15,509
running the code bare metal and so loose

00:01:14,070 --> 00:01:17,220
containers kind of shared a lot of nice

00:01:15,509 --> 00:01:20,759
properties with virtual machines and

00:01:17,220 --> 00:01:23,700
that your namespaces are isolated and

00:01:20,759 --> 00:01:26,780
you have a portable environment but they

00:01:23,700 --> 00:01:30,450
have some slight differences and that

00:01:26,780 --> 00:01:32,759
they don't have a hypervisor to do the

00:01:30,450 --> 00:01:35,040
memory and process management you

00:01:32,759 --> 00:01:36,240
utilize the kernels resources directly

00:01:35,040 --> 00:01:37,979
and so you can get bare metal

00:01:36,240 --> 00:01:41,280
performance which is really nice and

00:01:37,979 --> 00:01:43,680
that the Linux containers that you're

00:01:41,280 --> 00:01:46,530
constructing they're built on sort of a

00:01:43,680 --> 00:01:49,290
hierarchical structure so just like how

00:01:46,530 --> 00:01:51,570
we do with getting revision control you

00:01:49,290 --> 00:01:53,729
can stack changes in the same way we can

00:01:51,570 --> 00:01:57,090
we can treat the filesystem as sort of

00:01:53,729 --> 00:02:00,960
this branching phenomena and then that's

00:01:57,090 --> 00:02:04,710
really nice for evaluating differences

00:02:00,960 --> 00:02:07,590
between containers or monitoring the

00:02:04,710 --> 00:02:10,500
progress of the changes and this project

00:02:07,590 --> 00:02:12,330
has has been that has been attracted so

00:02:10,500 --> 00:02:13,459
much attention that this is like started

00:02:12,330 --> 00:02:16,099
its own initiative called

00:02:13,459 --> 00:02:19,420
the open container initiative and so is

00:02:16,099 --> 00:02:23,209
getting a lot of sponsors either from

00:02:19,420 --> 00:02:25,129
Intel and Red Hat and so the code base

00:02:23,209 --> 00:02:26,959
is just going to grow and mature and so

00:02:25,129 --> 00:02:28,870
it's really something that we can i

00:02:26,959 --> 00:02:34,280
think is roboticist we can build off of

00:02:28,870 --> 00:02:36,470
and so these roboticist we use a lot of

00:02:34,280 --> 00:02:38,780
open source software and I see there's a

00:02:36,470 --> 00:02:40,250
lot similarities in between us and sort

00:02:38,780 --> 00:02:42,530
of the web development community and

00:02:40,250 --> 00:02:46,129
that we're just you know wrangling

00:02:42,530 --> 00:02:48,760
thousands of cats around the computer

00:02:46,129 --> 00:02:53,659
ecosystem and we're trying to make

00:02:48,760 --> 00:02:56,120
deployable applications and that the

00:02:53,659 --> 00:02:57,200
looneys container revolution there's

00:02:56,120 --> 00:02:59,629
kind of come up in the web they don't

00:02:57,200 --> 00:03:05,150
look any we can we can really utilize

00:02:59,629 --> 00:03:09,620
and so with with Ross we have we have a

00:03:05,150 --> 00:03:12,620
long history of different distros the

00:03:09,620 --> 00:03:13,989
progress that we made since 2010 has

00:03:12,620 --> 00:03:16,519
been really remarkable

00:03:13,989 --> 00:03:19,010
but as roboticists we not just do a

00:03:16,519 --> 00:03:21,650
software we use different hardware

00:03:19,010 --> 00:03:23,599
drivers different peripherals different

00:03:21,650 --> 00:03:26,540
modalities of sensing and acquiring data

00:03:23,599 --> 00:03:28,669
from from our real world and along with

00:03:26,540 --> 00:03:34,400
those we we have a host of different

00:03:28,669 --> 00:03:38,000
platforms and some different big small

00:03:34,400 --> 00:03:41,419
flying floating they use electrics or

00:03:38,000 --> 00:03:44,590
engines and so wrangling all that is is

00:03:41,419 --> 00:03:49,909
really quite challenging and so this is

00:03:44,590 --> 00:03:52,760
playing back to a talk given at Ross you

00:03:49,909 --> 00:03:54,470
know sorry at Twitter University talk by

00:03:52,760 --> 00:03:57,440
one of the founders of the doctor

00:03:54,470 --> 00:03:59,090
projects and he goes on to explain this

00:03:57,440 --> 00:04:02,000
kind of concept at the matrix of Hell

00:03:59,090 --> 00:04:04,250
where on maybe one axis we have all the

00:04:02,000 --> 00:04:06,169
different variants of the software

00:04:04,250 --> 00:04:07,970
components that we're trying to run

00:04:06,169 --> 00:04:09,769
another we have all the hardware

00:04:07,970 --> 00:04:11,690
components and targets we're trying to

00:04:09,769 --> 00:04:14,269
deploy them and execute them on and

00:04:11,690 --> 00:04:16,159
getting every software component running

00:04:14,269 --> 00:04:18,919
on every hardware component is is really

00:04:16,159 --> 00:04:20,359
quite challenging and then for a long

00:04:18,919 --> 00:04:22,580
time the software development has just

00:04:20,359 --> 00:04:27,289
been really too hard and so on

00:04:22,580 --> 00:04:28,759
is really hard for robotics I'd like to

00:04:27,289 --> 00:04:32,419
bring up we kind of have this

00:04:28,759 --> 00:04:34,159
multi-dimensional matrix of hell and it

00:04:32,419 --> 00:04:39,439
just goes up to n dimensions you will

00:04:34,159 --> 00:04:41,270
have distros platforms peripherals and

00:04:39,439 --> 00:04:43,610
then oops I forgot to mention

00:04:41,270 --> 00:04:45,469
open-source libraries where do those go

00:04:43,610 --> 00:04:48,050
I can't represent this in 2d oh but

00:04:45,469 --> 00:04:50,629
there's also operating systems so it's

00:04:48,050 --> 00:04:54,169
just there's just so much complexity and

00:04:50,629 --> 00:04:55,849
then making something portable robust is

00:04:54,169 --> 00:04:57,500
is really quite challenging for us as

00:04:55,849 --> 00:04:59,690
roboticists because we're working we're

00:04:57,500 --> 00:05:02,240
not just software engineers we're

00:04:59,690 --> 00:05:04,789
hardware engineers and so we really

00:05:02,240 --> 00:05:07,340
don't want to have to deal with with all

00:05:04,789 --> 00:05:09,979
these complexities so what better way

00:05:07,340 --> 00:05:13,219
can we do that well just this is a

00:05:09,979 --> 00:05:16,340
little bit of background so how I got

00:05:13,219 --> 00:05:19,060
started is as a graduate student new

00:05:16,340 --> 00:05:22,029
graduate student in in my robotics lab

00:05:19,060 --> 00:05:24,800
I'm dealing with like code bases from

00:05:22,029 --> 00:05:26,270
older generation students and you know

00:05:24,800 --> 00:05:28,550
they're graduating and the tribal

00:05:26,270 --> 00:05:30,680
knowledge is lost and also when you

00:05:28,550 --> 00:05:33,860
encounter you know research papers it's

00:05:30,680 --> 00:05:35,750
it's just the literature you know people

00:05:33,860 --> 00:05:38,300
publish code on sort of the best effort

00:05:35,750 --> 00:05:41,270
basis and maintain that on the best

00:05:38,300 --> 00:05:43,069
effort so reproducing someone's work is

00:05:41,270 --> 00:05:44,599
really quite challenging

00:05:43,069 --> 00:05:47,120
another thing is maybe if you're

00:05:44,599 --> 00:05:50,599
collaborating with lab mates

00:05:47,120 --> 00:05:52,629
the computational environments change so

00:05:50,599 --> 00:05:54,830
fast that's kind of hard to keep up

00:05:52,629 --> 00:05:56,810
maybe if I'm doing a project where I

00:05:54,830 --> 00:05:58,310
just need to collect a data set a lab

00:05:56,810 --> 00:06:00,379
mate is already written written

00:05:58,310 --> 00:06:03,229
something that brought clicks ross bags

00:06:00,379 --> 00:06:04,909
for me but in the over the timespan that

00:06:03,229 --> 00:06:07,339
maybe three weeks the Debian packages

00:06:04,909 --> 00:06:10,360
change so that's something that I guess

00:06:07,339 --> 00:06:12,979
the snap framework is trying to resolve

00:06:10,360 --> 00:06:16,310
but it may be more complicated that

00:06:12,979 --> 00:06:18,589
maybe it might be a Ross environment

00:06:16,310 --> 00:06:21,229
variable that was set particularly on

00:06:18,589 --> 00:06:26,900
that one robot and so reproducing that

00:06:21,229 --> 00:06:28,400
is is really quite challenging so how do

00:06:26,900 --> 00:06:31,190
i how do I see that learner's containers

00:06:28,400 --> 00:06:31,889
can kind of help simplify a lot of this

00:06:31,190 --> 00:06:34,080
stuff is

00:06:31,889 --> 00:06:36,389
I see this being used for maybe

00:06:34,080 --> 00:06:37,889
cross-compilation environment set up so

00:06:36,389 --> 00:06:40,379
you have some really complicated

00:06:37,889 --> 00:06:42,229
cross-compilation tool chain and you

00:06:40,379 --> 00:06:45,240
want to share that with other people

00:06:42,229 --> 00:06:47,599
having someone execute a line of scripts

00:06:45,240 --> 00:06:49,949
might not be suitable for everyone

00:06:47,599 --> 00:06:52,949
especially maybe if their prefer on

00:06:49,949 --> 00:06:55,590
working at different distros another

00:06:52,949 --> 00:06:58,229
thing is maybe custom dependencies maybe

00:06:55,590 --> 00:07:00,300
your for me I trying to build Omni

00:06:58,229 --> 00:07:03,360
mapper project which uses a different

00:07:00,300 --> 00:07:05,159
version of igan because GT Sam is not

00:07:03,360 --> 00:07:09,360
compliant and so I have to custom build

00:07:05,159 --> 00:07:10,529
PCL when that takes a long time and you

00:07:09,360 --> 00:07:13,080
know managing all these custom

00:07:10,529 --> 00:07:15,960
dependencies is really quite tricky in

00:07:13,080 --> 00:07:18,750
the share also I see this really a

00:07:15,960 --> 00:07:21,900
Keable for multiple robots so if we're

00:07:18,750 --> 00:07:24,389
trying to tackle swarm robotics you know

00:07:21,900 --> 00:07:27,389
hand gardening a certain environment on

00:07:24,389 --> 00:07:30,710
the one robot is not going to scale we

00:07:27,389 --> 00:07:33,779
need need a better way to to deploy

00:07:30,710 --> 00:07:35,819
certain changes or updates across our

00:07:33,779 --> 00:07:38,789
fleet of swarm robots and that's really

00:07:35,819 --> 00:07:40,800
quite similar to what DevOps and what

00:07:38,789 --> 00:07:44,729
developers do is they they have you know

00:07:40,800 --> 00:07:47,250
the study of a cluster of engines for

00:07:44,729 --> 00:07:50,639
either their HTML services and they

00:07:47,250 --> 00:07:53,940
really want to distribute the changes or

00:07:50,639 --> 00:07:55,110
web update page updates across that so

00:07:53,940 --> 00:07:58,319
we really wanted to do something quite

00:07:55,110 --> 00:08:01,110
similar I'm going to talk about maybe

00:07:58,319 --> 00:08:03,960
three areas that this is maybe

00:08:01,110 --> 00:08:07,259
particularly of interest to when is

00:08:03,960 --> 00:08:10,740
education research and Industry all

00:08:07,259 --> 00:08:13,979
right and so I have a couple video

00:08:10,740 --> 00:08:17,120
demonstrations that I can go into so

00:08:13,979 --> 00:08:17,120
I'll just start some of that

00:08:22,610 --> 00:08:29,280
okay so what I have here is I have some

00:08:27,720 --> 00:08:31,050
kind of host environment and then maybe

00:08:29,280 --> 00:08:33,180
this browser that has all my

00:08:31,050 --> 00:08:34,620
instructions that I'm executing and so

00:08:33,180 --> 00:08:38,279
I've done right here she's just like

00:08:34,620 --> 00:08:40,800
docker run and some interactive and then

00:08:38,279 --> 00:08:44,430
specifying Ross indigo and what that

00:08:40,800 --> 00:08:46,860
will do is download and pull the version

00:08:44,430 --> 00:08:49,140
or image of Ross and then I have a

00:08:46,860 --> 00:08:52,440
running Ross environment and then what

00:08:49,140 --> 00:08:56,130
I'm doing further is I'm clothing some

00:08:52,440 --> 00:08:58,080
Ross tutorial package and then this this

00:08:56,130 --> 00:09:00,990
image that I've downloaded already has

00:08:58,080 --> 00:09:03,990
this nice virgin catkin workspace set

00:09:00,990 --> 00:09:08,190
for me so then I can just you know cat

00:09:03,990 --> 00:09:12,029
can built the project and then what I'm

00:09:08,190 --> 00:09:13,860
doing after that is I'm committing my my

00:09:12,029 --> 00:09:14,970
changes to a new container that I can

00:09:13,860 --> 00:09:19,380
share and distribute it with my

00:09:14,970 --> 00:09:21,360
colleagues and then after that once I've

00:09:19,380 --> 00:09:24,649
once I've shared it maybe then I want to

00:09:21,360 --> 00:09:26,700
start running it and so we can leverage

00:09:24,649 --> 00:09:29,610
networking tools within the docker

00:09:26,700 --> 00:09:32,010
framework to spin up separate Ross nodes

00:09:29,610 --> 00:09:34,380
in separate containers and so each

00:09:32,010 --> 00:09:36,450
container can have its own Ross node and

00:09:34,380 --> 00:09:38,070
then that way in the same sense we can

00:09:36,450 --> 00:09:40,260
distribute containers across multiple

00:09:38,070 --> 00:09:42,089
machines and so if you still want if

00:09:40,260 --> 00:09:44,190
you're you're still comfortable in like

00:09:42,089 --> 00:09:46,829
using the node framework but want to use

00:09:44,190 --> 00:09:48,959
multiple machines multiple masters is

00:09:46,829 --> 00:09:52,470
somewhat complicated but in this sense

00:09:48,959 --> 00:09:56,160
we can create a virtual network layer to

00:09:52,470 --> 00:10:00,930
maybe connect multiple robots on on a

00:09:56,160 --> 00:10:02,970
single Ross framework see then here I'm

00:10:00,930 --> 00:10:04,680
introspecting the container so I'm

00:10:02,970 --> 00:10:06,930
looking at like you know when was a

00:10:04,680 --> 00:10:09,329
committed who authored the commit we're

00:10:06,930 --> 00:10:12,300
there any commit messages inside of it

00:10:09,329 --> 00:10:14,760
everything is hash based and so docker

00:10:12,300 --> 00:10:17,520
is also including some components where

00:10:14,760 --> 00:10:19,790
we can authenticate containers so maybe

00:10:17,520 --> 00:10:19,790
if you

00:10:20,720 --> 00:10:26,279
let's leave let me go back to the

00:10:22,800 --> 00:10:27,899
educational stuff so here when I started

00:10:26,279 --> 00:10:30,120
getting into Ross one of the big off

00:10:27,899 --> 00:10:32,040
putting stuff is it's just getting to

00:10:30,120 --> 00:10:32,560
the environment set up where I can run

00:10:32,040 --> 00:10:35,230
data to

00:10:32,560 --> 00:10:36,790
and I think that off puts a lot of other

00:10:35,230 --> 00:10:40,269
people but how I got around it was I

00:10:36,790 --> 00:10:43,120
started using virtual machine so that

00:10:40,269 --> 00:10:46,300
someone had had been taken care and

00:10:43,120 --> 00:10:48,339
taking enough care to share a virtual

00:10:46,300 --> 00:10:50,199
machine session with Ross pre-installed

00:10:48,339 --> 00:10:52,740
I can download and in the same sense

00:10:50,199 --> 00:10:55,809
that I think containers helped bootstrap

00:10:52,740 --> 00:10:58,689
kind of coursework where the instructor

00:10:55,809 --> 00:11:00,579
could authentic that could could

00:10:58,689 --> 00:11:02,620
construct the entire container for their

00:11:00,579 --> 00:11:06,490
coursework and then that way students

00:11:02,620 --> 00:11:08,470
can fail fast learn fast they'll have

00:11:06,490 --> 00:11:10,660
this kind of disposable work environment

00:11:08,470 --> 00:11:12,459
that they they're not afraid to try

00:11:10,660 --> 00:11:15,730
different dependencies they're not

00:11:12,459 --> 00:11:17,769
afraid of hosing their system because

00:11:15,730 --> 00:11:19,269
when you do when you destroy a container

00:11:17,769 --> 00:11:20,980
you can close it and you can restart a

00:11:19,269 --> 00:11:23,470
new one and if you're interested in

00:11:20,980 --> 00:11:25,509
saving those changes you can so it

00:11:23,470 --> 00:11:27,490
really helps them in that sense here I'm

00:11:25,509 --> 00:11:31,649
just doing a talker listener kind of

00:11:27,490 --> 00:11:31,649
note framework in multiple containers

00:11:35,490 --> 00:11:40,509
and then I think later I'd show that the

00:11:38,139 --> 00:11:45,809
process IDs that they're all in separate

00:11:40,509 --> 00:11:45,809
containers and stuff like that all right

00:11:46,019 --> 00:11:53,740
all right for for research see maybe you

00:11:51,399 --> 00:11:56,439
might know that deep learning is kind of

00:11:53,740 --> 00:11:58,899
a hot topic in computer vision and so

00:11:56,439 --> 00:12:00,850
maybe if you wanted if I'm a researcher

00:11:58,899 --> 00:12:03,879
and I want to try different computer

00:12:00,850 --> 00:12:06,250
vision algorithms it takes a lot of time

00:12:03,879 --> 00:12:08,860
for me to to iterate through each one I

00:12:06,250 --> 00:12:11,319
mean I might succeed in finding one that

00:12:08,860 --> 00:12:12,910
works just for me one I might you know

00:12:11,319 --> 00:12:15,129
it looks really good at first but I try

00:12:12,910 --> 00:12:16,929
that on my on my application and it's

00:12:15,129 --> 00:12:19,480
pretty terrible so it's just a waste

00:12:16,929 --> 00:12:22,649
effort but if I'm spending like you know

00:12:19,480 --> 00:12:25,179
days or weeks trying to reimplementation

00:12:22,649 --> 00:12:27,550
then that's too much time and the

00:12:25,179 --> 00:12:30,579
iterative cycle it's way too long but

00:12:27,550 --> 00:12:33,189
here let's say if I want to use test

00:12:30,579 --> 00:12:40,079
someone's cafe model here I've just

00:12:33,189 --> 00:12:40,079
written a small Ross node that a

00:12:40,700 --> 00:12:48,750
that's it okay so I just written the

00:12:46,770 --> 00:12:50,340
small Rasta note that that continuously

00:12:48,750 --> 00:12:52,440
takes a live image stream from an

00:12:50,340 --> 00:12:54,660
open-ended device this is all running

00:12:52,440 --> 00:12:56,850
inside the container so when I mount the

00:12:54,660 --> 00:13:00,480
container I'm mounting the Nvidia device

00:12:56,850 --> 00:13:01,950
I can do I can have the GPU do

00:13:00,480 --> 00:13:03,930
high-speed performance so I keep out the

00:13:01,950 --> 00:13:06,420
framerate in the camera

00:13:03,930 --> 00:13:09,180
I've also mounted I've also exposed X

00:13:06,420 --> 00:13:12,540
Server so then I can have buoys such as

00:13:09,180 --> 00:13:15,090
RVs and Terminator inside the container

00:13:12,540 --> 00:13:19,950
exposed to my host environment and then

00:13:15,090 --> 00:13:22,380
I have the the Nvidia drivers exposed so

00:13:19,950 --> 00:13:25,770
and then as well as some kernel modules

00:13:22,380 --> 00:13:28,950
so in the end this YouTube video I have

00:13:25,770 --> 00:13:32,010
a link to to the code base that you can

00:13:28,950 --> 00:13:34,170
try it so my my goal is that you could

00:13:32,010 --> 00:13:35,820
pull down this container and as long as

00:13:34,170 --> 00:13:38,550
you have the same equivalent Nvidia

00:13:35,820 --> 00:13:40,620
driver installed on your system I think

00:13:38,550 --> 00:13:42,900
it's clear that 7.5 whether the default

00:13:40,620 --> 00:13:45,420
was there that you could implement the

00:13:42,900 --> 00:13:50,580
same thing so here you just see you know

00:13:45,420 --> 00:13:51,690
it's classifying coffee cups different

00:13:50,580 --> 00:13:55,800
joypads

00:13:51,690 --> 00:13:57,750
and you know it's like 50% sure that's

00:13:55,800 --> 00:13:59,850
joke that's it that's that's some stock

00:13:57,750 --> 00:14:02,880
and then just to show you that this is a

00:13:59,850 --> 00:14:05,640
live demo it's really sugar that's a

00:14:02,880 --> 00:14:07,530
tiger or Jaguar this is running on the

00:14:05,640 --> 00:14:10,110
computer it's not a ross bag so it's

00:14:07,530 --> 00:14:11,970
it's it's classifying my own computer is

00:14:10,110 --> 00:14:17,700
it you know house and whatnot that's

00:14:11,970 --> 00:14:19,500
going to last industry so for those who

00:14:17,700 --> 00:14:24,000
may be interested in doing continuous

00:14:19,500 --> 00:14:27,270
integration where you would really like

00:14:24,000 --> 00:14:30,480
to improve that so I think docker with

00:14:27,270 --> 00:14:33,090
gazebo offers a lot of tools and maybe

00:14:30,480 --> 00:14:34,970
providing same services as Jenkins or

00:14:33,090 --> 00:14:37,140
Travis where we want these cloud-based

00:14:34,970 --> 00:14:39,000
continuous integration services where

00:14:37,140 --> 00:14:42,480
we're scaling up and down simulations as

00:14:39,000 --> 00:14:45,980
we need and so here I just started a

00:14:42,480 --> 00:14:49,189
gazebo container then I

00:14:45,980 --> 00:14:53,029
go into the container download a double

00:14:49,189 --> 00:14:55,069
pendulum model start a simulation record

00:14:53,029 --> 00:14:57,259
a certain log file and then I can

00:14:55,069 --> 00:14:59,239
introspect that log file let's see

00:14:57,259 --> 00:15:01,910
here's here's it's there's the log file

00:14:59,239 --> 00:15:03,889
data alright but then because that the

00:15:01,910 --> 00:15:06,739
container has exposed the network

00:15:03,889 --> 00:15:10,339
peripheral I can also connect a maybe GZ

00:15:06,739 --> 00:15:15,279
client to the container so then my host

00:15:10,339 --> 00:15:15,279
system I can have some user interface

00:15:15,699 --> 00:15:24,139
and so I've tested stuff using Gazebo

00:15:20,629 --> 00:15:25,790
Linux containers with AWS and there's a

00:15:24,139 --> 00:15:27,769
lot of promise I believe in some of

00:15:25,790 --> 00:15:30,499
those shows it's really quite quite easy

00:15:27,769 --> 00:15:33,399
to try different versions of you 0 4 5

00:15:30,499 --> 00:15:33,399
and 6 if you want

00:15:37,980 --> 00:15:42,780
and what other ways the reusing Ducker

00:15:40,530 --> 00:15:44,580
in Ross were using it for continuous

00:15:42,780 --> 00:15:46,670
integration and bill farms and then the

00:15:44,580 --> 00:15:49,340
second generation bill farm for Ross

00:15:46,670 --> 00:15:52,080
future ways I see this being used as

00:15:49,340 --> 00:15:54,720
maybe integrating Ross launched with the

00:15:52,080 --> 00:15:57,660
dr. API so that you know Ross launched

00:15:54,720 --> 00:16:01,050
spins up a new container per every Dras

00:15:57,660 --> 00:16:04,260
node also connecting at wear just like

00:16:01,050 --> 00:16:06,450
with docker we can point the docker CLI

00:16:04,260 --> 00:16:09,840
to a docker swarm well we could point

00:16:06,450 --> 00:16:13,620
maybe a Ross launch to a container swarm

00:16:09,840 --> 00:16:15,600
of Ross nodes and so that's also using

00:16:13,620 --> 00:16:17,970
some of the virtual networking layer

00:16:15,600 --> 00:16:20,400
there's official repos for Ross and

00:16:17,970 --> 00:16:22,770
gazebo available so go ahead and try

00:16:20,400 --> 00:16:24,720
them out they're getting a lot of poles

00:16:22,770 --> 00:16:25,830
I think as of recently I think someone's

00:16:24,720 --> 00:16:29,670
connected their continuous integration

00:16:25,830 --> 00:16:32,510
to the Ross one is over 25,000 but

00:16:29,670 --> 00:16:37,230
there's also ones free-cos Evo this both

00:16:32,510 --> 00:16:40,740
Ross indigo and Jade and then for gazebo

00:16:37,230 --> 00:16:44,040
we have five six and seven or then we

00:16:40,740 --> 00:16:46,770
also have a gazebo X which is sort of

00:16:44,040 --> 00:16:48,630
the latest and greatest kind of default

00:16:46,770 --> 00:16:52,500
version of what's at the head of the

00:16:48,630 --> 00:16:54,060
master branch and also Ross to example

00:16:52,500 --> 00:16:56,460
so if you want to try Ross to yourself

00:16:54,060 --> 00:17:01,140
you can check out the the state of the

00:16:56,460 --> 00:17:03,720
Ross - project tip of the hat to OS RF

00:17:01,140 --> 00:17:06,959
and my lab I really could have done this

00:17:03,720 --> 00:17:10,920
without at the time I had it ôs RF - to

00:17:06,959 --> 00:17:13,560
kind of polish some of the code bases

00:17:10,920 --> 00:17:16,949
and submitting the official framework to

00:17:13,560 --> 00:17:18,240
docker hub and so here's some robotic

00:17:16,949 --> 00:17:20,329
resources and I'd like to open for

00:17:18,240 --> 00:17:20,329
questions

00:17:27,280 --> 00:17:34,760
so the question was how exactly does the

00:17:30,530 --> 00:17:37,280
the Ross networking McCorkle ID with

00:17:34,760 --> 00:17:41,390
sort of this docker frame of networking

00:17:37,280 --> 00:17:43,400
is that if you if you look at some of

00:17:41,390 --> 00:17:44,929
the the tutorials are they kind of the

00:17:43,400 --> 00:17:48,770
documentation I wrote in an official

00:17:44,929 --> 00:17:52,070
docker hub repo like I go through a test

00:17:48,770 --> 00:17:54,140
case scenario where yeah we're trying to

00:17:52,070 --> 00:17:56,210
split multiple nodes and multiple

00:17:54,140 --> 00:17:57,710
containers and it's really quite

00:17:56,210 --> 00:17:59,360
transparent the only thing we need to do

00:17:57,710 --> 00:18:00,470
when we start up a container is when you

00:17:59,360 --> 00:18:04,460
just need to set the environment

00:18:00,470 --> 00:18:05,929
variable and then and because the the

00:18:04,460 --> 00:18:08,240
docker networking stuff is still a bit

00:18:05,929 --> 00:18:10,160
beta but how it works is we can set a

00:18:08,240 --> 00:18:12,110
container and define its service and

00:18:10,160 --> 00:18:13,820
then on this virtual network that

00:18:12,110 --> 00:18:15,830
interlinks the containers the containers

00:18:13,820 --> 00:18:17,840
find each other based on whatever

00:18:15,830 --> 00:18:19,070
service you called it and so if you set

00:18:17,840 --> 00:18:21,770
the same strings we learned that

00:18:19,070 --> 00:18:24,110
variables you sort of get this sort of

00:18:21,770 --> 00:18:25,880
the Ross networking scheme where I can

00:18:24,110 --> 00:18:28,040
have a master running on one machine but

00:18:25,880 --> 00:18:29,510
as long as I when I'm starting nodes in

00:18:28,040 --> 00:18:32,030
this environment that this pointing to

00:18:29,510 --> 00:18:34,730
master it's quite transparent with Ross

00:18:32,030 --> 00:18:36,710
- it's really cool because you see that

00:18:34,730 --> 00:18:38,780
with the Ross - example I don't need to

00:18:36,710 --> 00:18:40,700
set those parameters and the service

00:18:38,780 --> 00:18:42,710
discovery finds the inter link between

00:18:40,700 --> 00:18:45,700
the two containers automatically so it's

00:18:42,710 --> 00:18:45,700
kind of cool to play with

00:19:01,840 --> 00:19:07,070
the question was whether where the

00:19:05,240 --> 00:19:08,870
details on Jenkins with us there's

00:19:07,070 --> 00:19:10,820
they're not quite any dependencies on

00:19:08,870 --> 00:19:13,940
Jenkins it was just sort of an analogy

00:19:10,820 --> 00:19:15,320
where in the same sentiment when we were

00:19:13,940 --> 00:19:18,039
using Jenkins and docker to make a

00:19:15,320 --> 00:19:21,289
sterile environment to build a package

00:19:18,039 --> 00:19:23,389
we can also use some other continuous

00:19:21,289 --> 00:19:26,029
integration to start containers to start

00:19:23,389 --> 00:19:27,620
the simulation and so that way you know

00:19:26,029 --> 00:19:29,539
if your simulation is environment

00:19:27,620 --> 00:19:32,029
dependent you have an easy way of

00:19:29,539 --> 00:19:33,590
tossing up your environment to the state

00:19:32,029 --> 00:19:42,970
cloud or to the build farm for this

00:19:33,590 --> 00:19:47,169
continuous integration for robots yeah

00:19:42,970 --> 00:19:47,169

YouTube URL: https://www.youtube.com/watch?v=I_1lt7vYse8


