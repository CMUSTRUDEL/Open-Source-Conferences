Title: ROSCon2016 Seoul Day 1   Adaptive Fault Tolerance on ROS   A Component Based Approach
Publication date: 2016-10-21
Playlist: ROSCon 2016
Description: 
	
Captions: 
	00:00:00,060 --> 00:00:05,040
thank you very much for the introduction

00:00:01,620 --> 00:00:08,280
so I present myself and Messier me from

00:00:05,040 --> 00:00:11,070
the comic fact car manufacturer Renault

00:00:08,280 --> 00:00:11,849
and from the laboratory laboratory last

00:00:11,070 --> 00:00:13,950
series

00:00:11,849 --> 00:00:15,470
I'm actually in first year PhD student

00:00:13,950 --> 00:00:19,560
and I will present you my work on

00:00:15,470 --> 00:00:21,869
adaptive photo reference on Ross so

00:00:19,560 --> 00:00:25,050
first of all I would like to show you

00:00:21,869 --> 00:00:27,750
some definition to have the theory

00:00:25,050 --> 00:00:29,580
behind a project so first we start with

00:00:27,750 --> 00:00:33,360
dependability which is the ability for

00:00:29,580 --> 00:00:35,489
service to continue to for system to

00:00:33,360 --> 00:00:39,030
have a service that can be trusted when

00:00:35,489 --> 00:00:40,829
you suspect errors or changes so I will

00:00:39,030 --> 00:00:44,760
not talk about security I will only talk

00:00:40,829 --> 00:00:47,550
about safety which can be just described

00:00:44,760 --> 00:00:50,070
with four main subject which has a

00:00:47,550 --> 00:00:51,690
prevention the removal the forecasting

00:00:50,070 --> 00:00:54,420
and the tolerance of errors in the

00:00:51,690 --> 00:00:56,039
systems so I will talk myself about

00:00:54,420 --> 00:00:58,680
fault tolerance which is a design

00:00:56,039 --> 00:01:01,699
implementation of safety of soft of

00:00:58,680 --> 00:01:04,619
fault tolerance mechanism in order to

00:01:01,699 --> 00:01:07,830
ensure the transition to a safe state to

00:01:04,619 --> 00:01:09,450
save States for the systems but I will

00:01:07,830 --> 00:01:11,729
also talk about resiliency which is a

00:01:09,450 --> 00:01:14,939
persistence of the system when it says

00:01:11,729 --> 00:01:17,490
changes so what exactly is adaptive

00:01:14,939 --> 00:01:20,189
fault tolerance it's a mix of resiliency

00:01:17,490 --> 00:01:21,950
and fault tolerance so it's a design and

00:01:20,189 --> 00:01:24,840
implementation of fault tolerance

00:01:21,950 --> 00:01:27,390
mechanism that can be switched adapt or

00:01:24,840 --> 00:01:31,049
composed when the system fails changes

00:01:27,390 --> 00:01:34,259
and errors so first the problem

00:01:31,049 --> 00:01:36,570
statements why we discuss about adaptive

00:01:34,259 --> 00:01:39,960
photoresist once the system is deployed

00:01:36,570 --> 00:01:43,229
we cannot see we can not face every

00:01:39,960 --> 00:01:45,149
change we cannot predict what the system

00:01:43,229 --> 00:01:49,590
will be able to react with environment

00:01:45,149 --> 00:01:53,369
change with development problem and so

00:01:49,590 --> 00:01:55,890
we want to develop safety mechanism that

00:01:53,369 --> 00:01:58,170
can be adapting that can adapt

00:01:55,890 --> 00:02:00,240
themselves to the situation to the Arve

00:01:58,170 --> 00:02:02,250
to the environment to the system

00:02:00,240 --> 00:02:05,310
architecture and for that we need three

00:02:02,250 --> 00:02:07,740
points the separation of concerns which

00:02:05,310 --> 00:02:10,110
is a separation between functionality

00:02:07,740 --> 00:02:11,319
and a safety port the design for

00:02:10,110 --> 00:02:14,739
adaptation to

00:02:11,319 --> 00:02:17,739
to change and adapt the mechanism in the

00:02:14,739 --> 00:02:20,200
easiest and fastest way and the remote

00:02:17,739 --> 00:02:23,109
find I find the granted updates

00:02:20,200 --> 00:02:25,540
sorry for my English in order to develop

00:02:23,109 --> 00:02:29,620
them offline and to implement them

00:02:25,540 --> 00:02:31,560
online on the embedded systems so the

00:02:29,620 --> 00:02:33,819
point is to design the systems as a

00:02:31,560 --> 00:02:36,790
component that can be connected and that

00:02:33,819 --> 00:02:40,680
way we here for us and the point is to

00:02:36,790 --> 00:02:44,049
have two type of resiliency a hot

00:02:40,680 --> 00:02:45,639
resiliency that is the modification of

00:02:44,049 --> 00:02:48,849
the component graph that's adaptation of

00:02:45,639 --> 00:02:52,590
the mechanism at runtime and the cold

00:02:48,849 --> 00:02:55,599
resiliency which is the analysis of the

00:02:52,590 --> 00:02:57,310
safety analyzes the development of the

00:02:55,599 --> 00:03:00,849
new component and the update of these

00:02:57,310 --> 00:03:03,400
components to the embedded systems so I

00:03:00,849 --> 00:03:05,620
wouldn't use three example of fault

00:03:03,400 --> 00:03:08,620
tolerance mechanisms first one is a

00:03:05,620 --> 00:03:11,739
primary backup replication so as you can

00:03:08,620 --> 00:03:14,500
see you as a services duplicate is

00:03:11,739 --> 00:03:17,169
replicated the clients understand the

00:03:14,500 --> 00:03:18,849
request to one of the replicas then it

00:03:17,169 --> 00:03:21,720
checked its compute and checkpoints it

00:03:18,849 --> 00:03:24,099
states to zero to the other replication

00:03:21,720 --> 00:03:27,009
the second one is the leader of follower

00:03:24,099 --> 00:03:29,620
replication the difference it it's

00:03:27,009 --> 00:03:31,930
always for crush fault tolerance which

00:03:29,620 --> 00:03:34,180
means if the adware crash we have to

00:03:31,930 --> 00:03:37,090
need penny we need to have a replication

00:03:34,180 --> 00:03:38,379
to ensure the states of the systems the

00:03:37,090 --> 00:03:40,299
difference between the primary backup

00:03:38,379 --> 00:03:43,329
replication and the leader for the

00:03:40,299 --> 00:03:45,310
replication it that the requests are

00:03:43,329 --> 00:03:49,060
send it to all the replication but only

00:03:45,310 --> 00:03:52,989
the leader the first replication compute

00:03:49,060 --> 00:03:55,229
send the answer to the others the last

00:03:52,989 --> 00:03:58,629
one will be the timer didn't see which

00:03:55,229 --> 00:04:00,009
tolerates the transient crash fault the

00:03:58,629 --> 00:04:02,469
for one request

00:04:00,009 --> 00:04:04,269
the system will compute the service the

00:04:02,469 --> 00:04:07,509
service multiple time and then compare

00:04:04,269 --> 00:04:08,800
the answer to see various errors in the

00:04:07,509 --> 00:04:12,880
systems

00:04:08,800 --> 00:04:15,400
so to do that you as you can see for the

00:04:12,880 --> 00:04:17,620
same fault model we can have different

00:04:15,400 --> 00:04:20,709
application behavior or DIF resources

00:04:17,620 --> 00:04:22,870
for example the primary backup need to

00:04:20,709 --> 00:04:25,560
save it states the answer and to send a

00:04:22,870 --> 00:04:29,710
check point which is a large bandwidth

00:04:25,560 --> 00:04:32,560
but it not need to have a data

00:04:29,710 --> 00:04:36,180
deterministic applications the leader

00:04:32,560 --> 00:04:38,740
follower in the contrary needs to have a

00:04:36,180 --> 00:04:41,550
deterministic application because if one

00:04:38,740 --> 00:04:44,590
of the replication is not completed

00:04:41,550 --> 00:04:47,500
sorry if not if one of the replication

00:04:44,590 --> 00:04:50,620
does not compute as the others the

00:04:47,500 --> 00:04:52,870
replication doesn't works so the point

00:04:50,620 --> 00:04:55,450
is to have a graph of mechanism and to

00:04:52,870 --> 00:04:57,670
switch from one to another for example

00:04:55,450 --> 00:05:01,480
we start with the leader follower

00:04:57,670 --> 00:05:04,030
replication and we have a drop of energy

00:05:01,480 --> 00:05:06,370
so we switch to a ppl appear primary

00:05:04,030 --> 00:05:09,520
backup replications which asked less

00:05:06,370 --> 00:05:12,330
energy so to do that we need the SIP

00:05:09,520 --> 00:05:18,100
what I called the separation of concerns

00:05:12,330 --> 00:05:21,160
which is to detach the safety from the

00:05:18,100 --> 00:05:23,200
functionality but we also need a design

00:05:21,160 --> 00:05:26,440
for the updation it to design the

00:05:23,200 --> 00:05:28,690
component to pass one from another with

00:05:26,440 --> 00:05:31,270
the least change as possible that's why

00:05:28,690 --> 00:05:34,090
we design the mechanism with three parts

00:05:31,270 --> 00:05:35,980
the before the presidency after the

00:05:34,090 --> 00:05:38,590
before the synchronization of the

00:05:35,980 --> 00:05:40,810
replication before the execution and the

00:05:38,590 --> 00:05:42,670
after is of course the synchronization

00:05:40,810 --> 00:05:46,840
of the replication after the

00:05:42,670 --> 00:05:50,200
computations as you can see the

00:05:46,840 --> 00:05:52,240
difference between most of the mechanism

00:05:50,200 --> 00:05:53,919
as a before and after part and that will

00:05:52,240 --> 00:05:58,360
be the only component that will change

00:05:53,919 --> 00:06:00,419
when we try to adapt them so that's the

00:05:58,360 --> 00:06:04,680
end for the theory and I will start

00:06:00,419 --> 00:06:04,680
implementation of this mechanism on Ross

00:06:05,010 --> 00:06:10,570
so we start with a generic situation

00:06:07,780 --> 00:06:13,210
where only a client and a server which

00:06:10,570 --> 00:06:15,460
provides a generic service we don't care

00:06:13,210 --> 00:06:18,580
about the service and our point is to

00:06:15,460 --> 00:06:21,230
implement the safety mechanism between

00:06:18,580 --> 00:06:22,970
the systems as you can see with we don't

00:06:21,230 --> 00:06:26,300
turn to the clients we don't touch the

00:06:22,970 --> 00:06:28,370
server we only add few components to

00:06:26,300 --> 00:06:32,570
ensure that them probably is a

00:06:28,370 --> 00:06:34,370
dependability of the systems so next is

00:06:32,570 --> 00:06:37,700
a implementation of the primary backup

00:06:34,370 --> 00:06:42,230
as you will see it may seem a bit

00:06:37,700 --> 00:06:46,490
complicated but here you have here you

00:06:42,230 --> 00:06:49,190
have the syrup so you have the primary

00:06:46,490 --> 00:06:51,170
the back up to the server is replicated

00:06:49,190 --> 00:06:52,880
as you can see we have the failure

00:06:51,170 --> 00:06:57,410
safety mechanism the before the

00:06:52,880 --> 00:06:59,810
presidency after and the mechanism is

00:06:57,410 --> 00:07:01,640
really simple we have interfaces between

00:06:59,810 --> 00:07:03,860
the machines with a proxy on the

00:07:01,640 --> 00:07:06,560
protocol we have the mechanism itself

00:07:03,860 --> 00:07:10,190
with a before the presidency after and

00:07:06,560 --> 00:07:12,860
we have the crash detector nodes and a

00:07:10,190 --> 00:07:14,920
recovery node in case of crash so what's

00:07:12,860 --> 00:07:19,160
happened for example if the master crash

00:07:14,920 --> 00:07:21,830
the point is to ensure the service to

00:07:19,160 --> 00:07:25,760
another computing machine we only have

00:07:21,830 --> 00:07:27,680
to reactivate for example the topics so

00:07:25,760 --> 00:07:32,270
is a topic that communicate between the

00:07:27,680 --> 00:07:34,280
proxy and the protocol so that the so

00:07:32,270 --> 00:07:36,410
that the point with primary backup

00:07:34,280 --> 00:07:39,380
replication as you can see the only

00:07:36,410 --> 00:07:41,780
change that will have between the two

00:07:39,380 --> 00:07:44,660
mechanisms primary backup and the leader

00:07:41,780 --> 00:07:47,390
forever we only have to kill the before

00:07:44,660 --> 00:07:50,810
and the after of each replicas and to

00:07:47,390 --> 00:07:53,840
launch and remap the component for the

00:07:50,810 --> 00:07:56,030
leader follower mechanism the other

00:07:53,840 --> 00:08:00,200
implementation which is important is the

00:07:56,030 --> 00:08:01,790
time redundancy mechanism as you can see

00:08:00,200 --> 00:08:06,050
so we save the states of the server

00:08:01,790 --> 00:08:08,780
before the computation we compute it we

00:08:06,050 --> 00:08:10,790
store the answer we restore the state of

00:08:08,780 --> 00:08:12,770
the system computed a second time and we

00:08:10,790 --> 00:08:17,000
can pass the answer so that's the point

00:08:12,770 --> 00:08:20,630
to tolerate transition crash transition

00:08:17,000 --> 00:08:23,900
fault though the point is what happens

00:08:20,630 --> 00:08:27,040
if fault model is more complex the point

00:08:23,900 --> 00:08:30,320
is to design the interface between the

00:08:27,040 --> 00:08:32,840
Machine and the server to be the same

00:08:30,320 --> 00:08:34,240
what I mean is that we need to have a

00:08:32,840 --> 00:08:37,270
proceed and the protocol

00:08:34,240 --> 00:08:40,360
have the same input and output to do so

00:08:37,270 --> 00:08:43,750
you know to have an adaptation we only

00:08:40,360 --> 00:08:46,990
have to kill the proceed and to relaunch

00:08:43,750 --> 00:08:50,950
put a call before proceeding after to

00:08:46,990 --> 00:08:52,899
have the composition of two mechanism to

00:08:50,950 --> 00:08:56,080
do that we only have to stop the

00:08:52,899 --> 00:08:58,660
protocol kill the proceed relaunch to

00:08:56,080 --> 00:09:01,390
launch the mechanism for examples of

00:08:58,660 --> 00:09:04,600
time redundancy mechanism and to restart

00:09:01,390 --> 00:09:07,330
the see and to restart the protocol so

00:09:04,600 --> 00:09:09,279
here is a big composition of mechanism

00:09:07,330 --> 00:09:12,790
as you can see we have the primary

00:09:09,279 --> 00:09:14,320
backup and the composition with the time

00:09:12,790 --> 00:09:15,970
resonance is the only thing that changes

00:09:14,320 --> 00:09:18,850
that the Prima the proceed of the

00:09:15,970 --> 00:09:22,959
primary and the backup were killed and

00:09:18,850 --> 00:09:26,200
replaced by another mechanism so we do a

00:09:22,959 --> 00:09:28,839
bit of case study with a simple

00:09:26,200 --> 00:09:34,600
application to evaluate response times

00:09:28,839 --> 00:09:37,440
and if the system can be used for a

00:09:34,600 --> 00:09:41,920
real-time adapt a for real-time systems

00:09:37,440 --> 00:09:44,950
so the point is to so we have some

00:09:41,920 --> 00:09:46,839
numbers for example the initiation the

00:09:44,950 --> 00:09:49,779
initialization time is around 0-5

00:09:46,839 --> 00:09:51,130
seconds but it's not it's a big long but

00:09:49,779 --> 00:09:53,380
it's not really important for the

00:09:51,130 --> 00:09:56,110
initializations the most important part

00:09:53,380 --> 00:09:57,940
is that the execution only add 5 to 2 to

00:09:56,110 --> 00:10:01,060
5 milliseconds depending the mechanism

00:09:57,940 --> 00:10:03,820
to the application the recovery zone is

00:10:01,060 --> 00:10:06,700
your activation for the primary backup

00:10:03,820 --> 00:10:09,700
and the vida forever of the reactivation

00:10:06,700 --> 00:10:11,050
of two topics so the recovery time is

00:10:09,700 --> 00:10:13,959
around 1 millisecond which is really

00:10:11,050 --> 00:10:16,420
really fast but one of the problem is

00:10:13,959 --> 00:10:18,970
the adaptation in composition because it

00:10:16,420 --> 00:10:21,459
means the launch of new component which

00:10:18,970 --> 00:10:27,010
can take some times as long as the

00:10:21,459 --> 00:10:28,360
initialization so one last point is the

00:10:27,010 --> 00:10:30,339
roastmaster as a central point of

00:10:28,360 --> 00:10:32,620
failure as you know if the roastmaster

00:10:30,339 --> 00:10:35,100
crash there is no possible to relaunch

00:10:32,620 --> 00:10:38,050
the system to relaunch only the node

00:10:35,100 --> 00:10:39,790
because the roastmaster controls the

00:10:38,050 --> 00:10:41,260
system it controls the communication it

00:10:39,790 --> 00:10:42,120
has a control of the graph and control

00:10:41,260 --> 00:10:45,360
of the node

00:10:42,120 --> 00:10:47,340
if it crash you lose everything you only

00:10:45,360 --> 00:10:50,640
have to read understand node you have to

00:10:47,340 --> 00:10:54,030
reinitiate to reinitialize the system

00:10:50,640 --> 00:10:56,640
and it can be acceptable for critical

00:10:54,030 --> 00:11:00,360
embedded systems so there are two points

00:10:56,640 --> 00:11:03,330
of reflection to solve that one if to

00:11:00,360 --> 00:11:05,820
launch the roster in the roastmaster on

00:11:03,330 --> 00:11:11,630
reliable machine but as we know the

00:11:05,820 --> 00:11:14,850
machine can be reliable at hundreds 100%

00:11:11,630 --> 00:11:18,450
computing unit can crush even if it's

00:11:14,850 --> 00:11:22,890
early even if it's 90% there is a risk

00:11:18,450 --> 00:11:25,770
so we work with northern uses Johnson

00:11:22,890 --> 00:11:28,260
University of Massachusetts Boston to

00:11:25,770 --> 00:11:30,360
try a way to checkpoint with the state

00:11:28,260 --> 00:11:33,860
of the Masters and to relaunch it you

00:11:30,360 --> 00:11:37,380
know in order to keep the system alive

00:11:33,860 --> 00:11:38,940
so I did not design VM TCP which means

00:11:37,380 --> 00:11:41,340
distributed multi-threading

00:11:38,940 --> 00:11:43,320
checkpointing I invite you to check that

00:11:41,340 --> 00:11:46,830
it was developed by Jane Cooperman

00:11:43,320 --> 00:11:49,530
so I said her researcher at Boston

00:11:46,830 --> 00:11:51,020
University but I will try to explain to

00:11:49,530 --> 00:11:55,200
you how it works

00:11:51,020 --> 00:11:58,260
so first GM TCP only works with Linux

00:11:55,200 --> 00:12:02,310
kernel II don't need a lot of happy it's

00:11:58,260 --> 00:12:04,800
an open source software that Cabot that

00:12:02,310 --> 00:12:09,150
can be found in the on the net and so

00:12:04,800 --> 00:12:12,150
forth if I remember while and it worked

00:12:09,150 --> 00:12:16,290
as you have a DAC a DM TCP coordinator

00:12:12,150 --> 00:12:18,720
that will checkpoint the states of every

00:12:16,290 --> 00:12:22,530
process that was launched with DM TCP

00:12:18,720 --> 00:12:24,210
and restore it without any change so you

00:12:22,530 --> 00:12:27,780
will you will ask what the difference

00:12:24,210 --> 00:12:30,270
between the reloading of rus master and

00:12:27,780 --> 00:12:32,790
the gem tcp coordinators the point is

00:12:30,270 --> 00:12:35,100
that if the GI seen if the DM TCP

00:12:32,790 --> 00:12:36,870
coordinator crash it's not a problem it

00:12:35,100 --> 00:12:39,480
can be relaunch and can do the

00:12:36,870 --> 00:12:42,520
checkpoint as well as it with no ad as

00:12:39,480 --> 00:12:44,620
if does not crashed

00:12:42,520 --> 00:12:47,020
to do that so the process are launched

00:12:44,620 --> 00:12:51,580
with a coordinator the check point of

00:12:47,020 --> 00:12:53,890
the process is done without with keeping

00:12:51,580 --> 00:12:58,000
the state of it and its restart with a

00:12:53,890 --> 00:13:01,840
scrape that automatically created so we

00:12:58,000 --> 00:13:03,670
still are experimentation on GMT CP and

00:13:01,840 --> 00:13:06,300
its possibility with a roastmaster but

00:13:03,670 --> 00:13:08,650
the tests are very congruent and

00:13:06,300 --> 00:13:11,470
normally the mgcp should be able to

00:13:08,650 --> 00:13:14,580
checkpoint roastmaster and to really

00:13:11,470 --> 00:13:20,770
enjoy it without the loss of the system

00:13:14,580 --> 00:13:22,570
so first that adaptive for concerning

00:13:20,770 --> 00:13:25,330
the lesson learned adaptive filter

00:13:22,570 --> 00:13:29,470
errands so we need suppression of

00:13:25,330 --> 00:13:31,630
concern to keep the functionality of the

00:13:29,470 --> 00:13:34,450
system intact and the design validation

00:13:31,630 --> 00:13:37,350
to adapt the stem as easiest way as

00:13:34,450 --> 00:13:41,740
pollutant as easy as possible

00:13:37,350 --> 00:13:43,870
but and we also need for adaptation that

00:13:41,740 --> 00:13:45,850
do not can be start and stop but one of

00:13:43,870 --> 00:13:48,340
the problem with worse is that the not

00:13:45,850 --> 00:13:49,870
management is not easy you can't you

00:13:48,340 --> 00:13:52,000
don't have an appeal that's said to the

00:13:49,870 --> 00:13:54,970
that set to the node you stop working

00:13:52,000 --> 00:13:55,390
for no and you have to and no you start

00:13:54,970 --> 00:13:58,960
walking

00:13:55,390 --> 00:14:01,390
but because worse is launch of on Linux

00:13:58,960 --> 00:14:06,120
and UNIX process you can use for example

00:14:01,390 --> 00:14:09,400
user signal to compete to complete VIP

00:14:06,120 --> 00:14:11,230
one of the last thing is that not really

00:14:09,400 --> 00:14:14,230
it's real but is really hard with Ross

00:14:11,230 --> 00:14:16,420
is that there is no dynamic binding with

00:14:14,230 --> 00:14:19,420
Ross point one for example if you have

00:14:16,420 --> 00:14:21,880
to do a transition to save date you can

00:14:19,420 --> 00:14:24,940
trim up a topic or service that have a

00:14:21,880 --> 00:14:27,370
name you have to kill the node and

00:14:24,940 --> 00:14:32,170
relaunch it that what that's one of the

00:14:27,370 --> 00:14:36,910
problem of the of Ross and sappy but

00:14:32,170 --> 00:14:39,820
with other but with the UNIX UNIX call

00:14:36,910 --> 00:14:42,550
systems you can have some kind of

00:14:39,820 --> 00:14:46,300
dynamic binding but it's not as easy as

00:14:42,550 --> 00:14:48,160
it could be and it's not natural so to

00:14:46,300 --> 00:14:53,260
have a summary of the dynamic adaptive

00:14:48,160 --> 00:14:54,610
adaptation so we need any ice I know I

00:14:53,260 --> 00:14:55,910
said it from the start but we need

00:14:54,610 --> 00:14:59,210
separation of

00:14:55,910 --> 00:15:01,250
we need design for adaptations but we

00:14:59,210 --> 00:15:03,440
also need not management to stop the

00:15:01,250 --> 00:15:06,590
system during the adaptation of the

00:15:03,440 --> 00:15:08,630
composition of mechanism we need dynamic

00:15:06,590 --> 00:15:11,810
bedding in dynamic binding to do a

00:15:08,630 --> 00:15:14,480
transition to save States and we need a

00:15:11,810 --> 00:15:18,290
master check point in in case of the

00:15:14,480 --> 00:15:20,780
crash of the machine so in conclusions

00:15:18,290 --> 00:15:24,110
our experiment on roads was really

00:15:20,780 --> 00:15:27,590
interesting we do a lot of thing with it

00:15:24,110 --> 00:15:30,920
we we design and implement different

00:15:27,590 --> 00:15:35,600
mechanism we adapt them we compose them

00:15:30,920 --> 00:15:38,480
but there are still miss missing phasor

00:15:35,600 --> 00:15:41,870
in rows that we hope can be developed

00:15:38,480 --> 00:15:44,030
later right now so I'm presenting PhD

00:15:41,870 --> 00:15:46,880
thesis with a Renault the car

00:15:44,030 --> 00:15:49,280
manufacturer in order to adapt those

00:15:46,880 --> 00:15:56,050
mechanisms to different architecture and

00:15:49,280 --> 00:16:00,350
to design those mechanism for the next

00:15:56,050 --> 00:16:03,170
automotive driving help systems which we

00:16:00,350 --> 00:16:05,080
call others so I thank you for your

00:16:03,170 --> 00:16:08,200
attention and if you have any question

00:16:05,080 --> 00:16:08,200
thank you

00:16:13,490 --> 00:16:22,259
yes please hi have you looked at how

00:16:17,910 --> 00:16:24,959
your system might interact with arm or

00:16:22,259 --> 00:16:28,079
interfere or basically get in an

00:16:24,959 --> 00:16:32,040
argument with process management systems

00:16:28,079 --> 00:16:33,930
like system D like what like system D

00:16:32,040 --> 00:16:36,540
which is an entirely different way of

00:16:33,930 --> 00:16:40,230
managing you know is an entirely

00:16:36,540 --> 00:16:43,440
different way of managing processes and

00:16:40,230 --> 00:16:45,810
has functionality to essentially stop

00:16:43,440 --> 00:16:48,810
and start processes it doesn't like yeah

00:16:45,810 --> 00:16:54,630
we only tried to do it with UNIX called

00:16:48,810 --> 00:16:58,529
process okay we so we only try to do it

00:16:54,630 --> 00:17:02,250
with unique school systems and we but we

00:16:58,529 --> 00:17:06,240
try to do it with only using Ross apiece

00:17:02,250 --> 00:17:10,069
that was a point of work it was to do

00:17:06,240 --> 00:17:15,620
the most with Ross libraries and Ross

00:17:10,069 --> 00:17:17,939
calls in Ross management but we do not

00:17:15,620 --> 00:17:21,030
seek any further for the vinod

00:17:17,939 --> 00:17:24,240
management we did not try to use another

00:17:21,030 --> 00:17:26,789
system to to manage the node we only use

00:17:24,240 --> 00:17:29,450
a user signal to the top and control to

00:17:26,789 --> 00:17:33,390
node and we try to see if there are

00:17:29,450 --> 00:17:36,030
libraries or a appliques in Russ that

00:17:33,390 --> 00:17:38,280
can do that but we did not find them

00:17:36,030 --> 00:17:40,740
okay and you didn't encounter any like

00:17:38,280 --> 00:17:43,530
interference or things dying no no we're

00:17:40,740 --> 00:17:44,010
start all the way no if we stop the

00:17:43,530 --> 00:17:47,700
nodes

00:17:44,010 --> 00:17:51,780
it's a restart with the same behavior we

00:17:47,700 --> 00:17:53,789
do not have any loss in the system for

00:17:51,780 --> 00:17:56,070
them for example we don't have we do

00:17:53,789 --> 00:17:58,940
something we doesn't have any we don't

00:17:56,070 --> 00:18:02,400
have any loss with the messages with the

00:17:58,940 --> 00:18:04,710
behavior of a one node if you see a user

00:18:02,400 --> 00:18:08,010
signals who have the node management it

00:18:04,710 --> 00:18:09,929
start and in stops as naturally as it's

00:18:08,010 --> 00:18:13,440
possible there is no interference with

00:18:09,929 --> 00:18:16,520
the behavior of the systems okay hope I

00:18:13,440 --> 00:18:22,080
answer your question yeah yeah yeah

00:18:16,520 --> 00:18:24,330
mostly thank you thank you can you talk

00:18:22,080 --> 00:18:26,070
about the the resource overhead and

00:18:24,330 --> 00:18:26,500
using DM TCP like would you deploy that

00:18:26,070 --> 00:18:30,430
on

00:18:26,500 --> 00:18:33,580
system yeah it's a sweet Jean Cooperman

00:18:30,430 --> 00:18:37,320
from the northern Boston University he

00:18:33,580 --> 00:18:40,480
developed that it will to be used for

00:18:37,320 --> 00:18:44,230
every system every process that work on

00:18:40,480 --> 00:18:46,690
Linux it's I did not develop the MT TP

00:18:44,230 --> 00:18:48,850
and only work for in a logical

00:18:46,690 --> 00:18:52,750
checkpoint the roastmaster so I can I

00:18:48,850 --> 00:18:55,810
can't talk about the GMT CP precisely

00:18:52,750 --> 00:18:59,020
but there's a lot of documentation on

00:18:55,810 --> 00:19:02,020
its side on it on the web on the web you

00:18:59,020 --> 00:19:04,210
can download the MT CP and try it to

00:19:02,020 --> 00:19:06,700
launch and to kill and to restart

00:19:04,210 --> 00:19:10,030
processes to change out processes but

00:19:06,700 --> 00:19:12,640
the few experimentation that we do with

00:19:10,030 --> 00:19:15,280
gene Cooperman was really exciting and

00:19:12,640 --> 00:19:18,310
really and have a good result only have

00:19:15,280 --> 00:19:23,710
a few modification to support SoDo

00:19:18,310 --> 00:19:25,810
terminals and can to support ross but it

00:19:23,710 --> 00:19:27,910
can work really nicely with every

00:19:25,810 --> 00:19:32,020
process it can be used as plugging in

00:19:27,910 --> 00:19:35,440
the in every suppose proof process and

00:19:32,020 --> 00:19:37,360
it can be so it can be used with UNIX

00:19:35,440 --> 00:19:41,320
process and the process developed with

00:19:37,360 --> 00:19:45,480
C++ but as yeah as I say I only work on

00:19:41,320 --> 00:19:48,040
the adaptive torrents and to have a more

00:19:45,480 --> 00:19:52,320
precision on this work you will have to

00:19:48,040 --> 00:19:52,320

YouTube URL: https://www.youtube.com/watch?v=mZBV_Wd1k1s


