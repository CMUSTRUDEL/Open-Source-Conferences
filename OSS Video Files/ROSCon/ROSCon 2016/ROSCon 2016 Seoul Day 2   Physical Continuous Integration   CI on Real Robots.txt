Title: ROSCon 2016 Seoul Day 2   Physical Continuous Integration   CI on Real Robots
Publication date: 2016-10-20
Playlist: ROSCon 2016
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2016 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:03,990
oh I'm Alex Henning oh and today I'm

00:00:03,060 --> 00:00:05,580
going to talk to you about how we use

00:00:03,990 --> 00:00:07,230
physical continuous integration at fette

00:00:05,580 --> 00:00:11,580
robotics to ship robust and reliable

00:00:07,230 --> 00:00:13,590
robots to our customers so when i

00:00:11,580 --> 00:00:14,849
started at fette robotics a little over

00:00:13,590 --> 00:00:16,560
a year ago we were using a lot of

00:00:14,849 --> 00:00:17,970
existing best practices for software

00:00:16,560 --> 00:00:20,699
development we were using continuous

00:00:17,970 --> 00:00:23,100
integration for software with buildbot

00:00:20,699 --> 00:00:25,199
loss we were doing code reviews on

00:00:23,100 --> 00:00:27,570
github we were using lost lengths to

00:00:25,199 --> 00:00:29,130
check a code but it was still very time

00:00:27,570 --> 00:00:31,650
consuming it took a lot of manual effort

00:00:29,130 --> 00:00:33,870
to get a lease that we were happy with

00:00:31,650 --> 00:00:35,219
to ship to our customers and one of the

00:00:33,870 --> 00:00:36,809
reasons it was so time-consuming which

00:00:35,219 --> 00:00:39,270
we had to verify that the robots behaved

00:00:36,809 --> 00:00:42,090
appropriately in a realistic environment

00:00:39,270 --> 00:00:44,460
and if we found a problem was a slow

00:00:42,090 --> 00:00:46,710
feedback cycle to go back develop a fix

00:00:44,460 --> 00:00:48,960
go through the testing process and get a

00:00:46,710 --> 00:00:50,670
release and we found that a lot of the

00:00:48,960 --> 00:00:51,960
problems that would cause in the slow

00:00:50,670 --> 00:00:54,270
feedback cycle would you do the

00:00:51,960 --> 00:00:56,850
interactions between the software and

00:00:54,270 --> 00:00:58,920
the wheel world and we really wanted to

00:00:56,850 --> 00:01:01,980
be a quickly release of a bust of libel

00:00:58,920 --> 00:01:03,480
software for customized so we took what

00:01:01,980 --> 00:01:04,979
we were already doing with regular old

00:01:03,480 --> 00:01:07,380
software continuous integration and

00:01:04,979 --> 00:01:08,640
added real robots into the mix and set

00:01:07,380 --> 00:01:11,280
it in physical continuous integration

00:01:08,640 --> 00:01:15,960
where we tested every poll request on

00:01:11,280 --> 00:01:18,780
real robots and it test warehouse so at

00:01:15,960 --> 00:01:21,240
fette robotics we were testing that vet

00:01:18,780 --> 00:01:22,860
school a fleet management system gets

00:01:21,240 --> 00:01:24,750
robots so the light location at the

00:01:22,860 --> 00:01:27,479
right time and keeps them fully charged

00:01:24,750 --> 00:01:28,920
so that Pickers can place items on them

00:01:27,479 --> 00:01:31,650
and ship them send them to a

00:01:28,920 --> 00:01:34,500
consolidation area and we're also

00:01:31,650 --> 00:01:36,270
testing that of robots like fight can

00:01:34,500 --> 00:01:39,420
autonomously navigate safely and

00:01:36,270 --> 00:01:43,860
smoothly in a warehouse environment in a

00:01:39,420 --> 00:01:46,860
way that people are happy with so our

00:01:43,860 --> 00:01:49,380
test setup is a 7,500 square foot test

00:01:46,860 --> 00:01:51,689
warehouse that we have in San Jose the

00:01:49,380 --> 00:01:53,610
front two thirds are dedicated to longer

00:01:51,689 --> 00:01:55,710
time the least testing and the back

00:01:53,610 --> 00:01:57,750
one-third is dedicated to actually

00:01:55,710 --> 00:01:59,969
building pull requests from github and

00:01:57,750 --> 00:02:01,350
testing them on wheelwell BOTS we have

00:01:59,969 --> 00:02:04,259
over a dozen while blocking this

00:02:01,350 --> 00:02:05,880
facility and 16 ceiling mounted cameras

00:02:04,259 --> 00:02:08,099
that give us a view of what's going on

00:02:05,880 --> 00:02:09,869
in the warehouse at all times we also

00:02:08,099 --> 00:02:11,530
have a number of servers for recording

00:02:09,869 --> 00:02:13,450
bag files

00:02:11,530 --> 00:02:16,480
for recording video from all of the

00:02:13,450 --> 00:02:18,340
cameras in the warehouse and for running

00:02:16,480 --> 00:02:22,030
fetch court to communicate to all the

00:02:18,340 --> 00:02:23,230
robots in the warehouse so now we're

00:02:22,030 --> 00:02:24,790
going to go through the process of what

00:02:23,230 --> 00:02:27,610
happened when you want to test a change

00:02:24,790 --> 00:02:30,610
in a physical continuous integration

00:02:27,610 --> 00:02:31,959
setup and so at fette robotics we also

00:02:30,610 --> 00:02:33,489
want to make sure that the version of

00:02:31,959 --> 00:02:36,310
loss that was shipping to a customer's

00:02:33,489 --> 00:02:39,610
is robust and reliable with a software

00:02:36,310 --> 00:02:41,560
so we take a snapshot of the release

00:02:39,610 --> 00:02:43,360
debbie ends and we always test that

00:02:41,560 --> 00:02:45,760
before you release that snapshot to a

00:02:43,360 --> 00:02:47,950
customers and so a few months ago we

00:02:45,760 --> 00:02:49,870
pulled in the latest changes we did the

00:02:47,950 --> 00:02:51,940
regular local testing and everything

00:02:49,870 --> 00:02:53,410
seems to be working so we stabbed it up

00:02:51,940 --> 00:02:56,380
some physical continuous integration to

00:02:53,410 --> 00:02:59,410
10 code with the latest loss for a few

00:02:56,380 --> 00:03:00,790
days and after a few hours of testing we

00:02:59,410 --> 00:03:03,910
started getting some notifications that

00:03:00,790 --> 00:03:06,160
will watch were refusing to move so

00:03:03,910 --> 00:03:08,440
luckily for us a physical continues

00:03:06,160 --> 00:03:09,850
integration setup is always collecting a

00:03:08,440 --> 00:03:11,500
lot of data so it can actually dig in

00:03:09,850 --> 00:03:14,860
and figure out what's going on and

00:03:11,500 --> 00:03:16,780
looking to it and I've robots are always

00:03:14,860 --> 00:03:18,250
bagging whenever they're moving so we

00:03:16,780 --> 00:03:20,440
have access to any data that's being

00:03:18,250 --> 00:03:23,350
published on a lost topic they're

00:03:20,440 --> 00:03:26,019
logging what's going on the cameras are

00:03:23,350 --> 00:03:27,640
always being reported as video so we can

00:03:26,019 --> 00:03:30,070
go back after the fact and look at them

00:03:27,640 --> 00:03:31,480
and we have tools to actually sift

00:03:30,070 --> 00:03:33,070
through all this data and get

00:03:31,480 --> 00:03:35,200
development data so that we can actually

00:03:33,070 --> 00:03:38,200
find what we want to look at and begin

00:03:35,200 --> 00:03:40,540
so in this case when we pulled the logs

00:03:38,200 --> 00:03:42,400
from the robots that was talk we found a

00:03:40,540 --> 00:03:44,140
message like this where basically the

00:03:42,400 --> 00:03:46,600
global plan was in collision and the

00:03:44,140 --> 00:03:47,980
robot was be planning but we kept

00:03:46,600 --> 00:03:49,510
getting the same message over and over

00:03:47,980 --> 00:03:52,359
and normally you'd expect it to plan

00:03:49,510 --> 00:03:54,130
around an obstacle but in this case it

00:03:52,359 --> 00:03:56,380
wasn't so once we found this log message

00:03:54,130 --> 00:03:58,420
we pulled up the cameras and looked at

00:03:56,380 --> 00:04:00,160
the test warehouse to make sure that

00:03:58,420 --> 00:04:02,650
there were no obstacles that we didn't

00:04:00,160 --> 00:04:04,989
expect and at this point when we looked

00:04:02,650 --> 00:04:07,359
at the cameras the test environment was

00:04:04,989 --> 00:04:11,019
in a good state like we expected so

00:04:07,359 --> 00:04:12,340
we've hauled down the bag files for the

00:04:11,019 --> 00:04:15,459
robots that will get him to talk instead

00:04:12,340 --> 00:04:17,470
of playing them back and I've is before

00:04:15,459 --> 00:04:19,030
I go too much in detail what we found in

00:04:17,470 --> 00:04:20,680
the bag files I'm gonna give you a brief

00:04:19,030 --> 00:04:22,659
introduction for cost maps for those of

00:04:20,680 --> 00:04:23,910
you who aren't familiar so that you can

00:04:22,659 --> 00:04:26,880
understand what we're gonna look at

00:04:23,910 --> 00:04:29,370
so cough map 2d is part of the lost

00:04:26,880 --> 00:04:31,670
navigation stack and it's used to help

00:04:29,370 --> 00:04:34,590
plan collision-free paths and avoid

00:04:31,670 --> 00:04:36,450
crashing while following those paths the

00:04:34,590 --> 00:04:38,400
image you see here is what a cost map

00:04:36,450 --> 00:04:40,770
looks like if you visualize it in others

00:04:38,400 --> 00:04:43,260
and the yellow corresponds to an

00:04:40,770 --> 00:04:45,540
obstacle and obstacles can come from you

00:04:43,260 --> 00:04:48,060
the sensor data or maps usually combine

00:04:45,540 --> 00:04:50,460
both to actually look at to get the

00:04:48,060 --> 00:04:53,070
obstacles the teal corresponds to an

00:04:50,460 --> 00:04:54,540
inflated obstacle and that's useful

00:04:53,070 --> 00:04:56,760
collision checking if you have a secular

00:04:54,540 --> 00:04:58,350
a lot like a fight you inflate the

00:04:56,760 --> 00:04:59,580
obstacles by the radius of the robot and

00:04:58,350 --> 00:05:01,680
then you can do a fishing collision

00:04:59,580 --> 00:05:03,240
checking with a point model and this

00:05:01,680 --> 00:05:05,250
allows you to actually do fast election

00:05:03,240 --> 00:05:08,240
checking but you can use cost maps phone

00:05:05,250 --> 00:05:11,490
non-secular wats just a bit more slower

00:05:08,240 --> 00:05:13,140
and the red that goes to blue is the vet

00:05:11,490 --> 00:05:14,970
is the highest cost that's not actually

00:05:13,140 --> 00:05:16,980
in collision and it fades out to blue

00:05:14,970 --> 00:05:19,490
and eventually the clear that's show the

00:05:16,980 --> 00:05:21,780
bus Kuwait here that's free space and

00:05:19,490 --> 00:05:25,020
this is what you would expect a cost nap

00:05:21,780 --> 00:05:27,350
to look like if you were using cost maps

00:05:25,020 --> 00:05:30,720
in the past and when it was bug free and

00:05:27,350 --> 00:05:33,150
it's going from obstacle to high cost to

00:05:30,720 --> 00:05:35,400
low cost but when we started looking

00:05:33,150 --> 00:05:37,290
through the bag files we found lots of

00:05:35,400 --> 00:05:40,200
cough maps that looked something like

00:05:37,290 --> 00:05:42,240
this and you can see that the yellow

00:05:40,200 --> 00:05:44,910
obstacle go straight to flee space in

00:05:42,240 --> 00:05:47,250
some places and the other places where

00:05:44,910 --> 00:05:49,580
the cost doesn't go out smoothly and it

00:05:47,250 --> 00:05:51,840
just goes straight to free space and

00:05:49,580 --> 00:05:53,430
this is what was causing and when we

00:05:51,840 --> 00:05:55,290
start looking at the bag files this is

00:05:53,430 --> 00:05:58,169
what was causing the plans that were in

00:05:55,290 --> 00:05:59,700
collision is it wasn't inflating the

00:05:58,169 --> 00:06:01,410
inflation wasn't there so it was

00:05:59,700 --> 00:06:03,930
planning paths thinking oh this is flee

00:06:01,410 --> 00:06:06,240
space I can go here but in reality it

00:06:03,930 --> 00:06:08,040
was in collision luckily a local plan

00:06:06,240 --> 00:06:09,930
was smart enough to realize this so we

00:06:08,040 --> 00:06:13,140
didn't actually crash we just got stuck

00:06:09,930 --> 00:06:15,180
and Khepri planning and so as we watch

00:06:13,140 --> 00:06:16,800
these bag files we were able to see get

00:06:15,180 --> 00:06:19,800
an idea of what the robots were doing

00:06:16,800 --> 00:06:21,840
that caused this problem and once we

00:06:19,800 --> 00:06:24,710
were able to see how that was happening

00:06:21,840 --> 00:06:27,840
we could reproduce the bug in a

00:06:24,710 --> 00:06:29,850
repeatable manner in a office and

00:06:27,840 --> 00:06:32,250
actually look at what was happening so

00:06:29,850 --> 00:06:34,080
we could develop a fix and as we

00:06:32,250 --> 00:06:36,270
reproduce the bug and looked at the back

00:06:34,080 --> 00:06:37,760
house we were able to notice that it

00:06:36,270 --> 00:06:40,670
looked like there was an issue with

00:06:37,760 --> 00:06:43,340
the way that cost math was updating so

00:06:40,670 --> 00:06:45,650
as you move around the cost map is

00:06:43,340 --> 00:06:48,320
incrementally updating a rectangle of

00:06:45,650 --> 00:06:51,350
where the data has changed but it wasn't

00:06:48,320 --> 00:06:53,030
factoring in it wasn't acting an

00:06:51,350 --> 00:06:54,770
obstacle is right outside the rectangle

00:06:53,030 --> 00:06:57,410
that needed to be inflated back in and

00:06:54,770 --> 00:06:59,930
so we were able to develop a fixed based

00:06:57,410 --> 00:07:03,230
off of what we had found while looking

00:06:59,930 --> 00:07:06,110
at this bag data and once we had that

00:07:03,230 --> 00:07:08,780
fix we could verify it locally and test

00:07:06,110 --> 00:07:11,090
it using the reproducible test we had

00:07:08,780 --> 00:07:12,350
been doing and then we managed through

00:07:11,090 --> 00:07:14,510
the regular software continuous

00:07:12,350 --> 00:07:15,920
integration and a code review process to

00:07:14,510 --> 00:07:17,750
make sure everything was reasonable and

00:07:15,920 --> 00:07:20,450
so at this point we were getting pretty

00:07:17,750 --> 00:07:22,490
sure that we had fixed the bug but the

00:07:20,450 --> 00:07:24,230
bug had been introduced had also gone

00:07:22,490 --> 00:07:27,020
through this process so to really make

00:07:24,230 --> 00:07:28,640
sure that we had fixed it we started did

00:07:27,020 --> 00:07:30,860
physical continuous integration again

00:07:28,640 --> 00:07:33,410
and for this we need to try the new test

00:07:30,860 --> 00:07:35,210
so that we could actually test for the

00:07:33,410 --> 00:07:36,920
actual root cause and not just the

00:07:35,210 --> 00:07:38,510
planning problem so we wanted to

00:07:36,920 --> 00:07:40,430
actually detect that cost map for always

00:07:38,510 --> 00:07:42,950
being inflated and incrementally updated

00:07:40,430 --> 00:07:46,340
properly so we vote a test that did a

00:07:42,950 --> 00:07:47,870
full we inflation of the cost map and

00:07:46,340 --> 00:07:49,640
compared it to the incremental I updated

00:07:47,870 --> 00:07:52,130
one so that we could detect the problem

00:07:49,640 --> 00:07:54,170
automatically and catch the problem and

00:07:52,130 --> 00:07:55,610
avoid regressions in the future we

00:07:54,170 --> 00:07:58,130
tested this on the code with the bug to

00:07:55,610 --> 00:08:00,320
verify that it did in fact trigger when

00:07:58,130 --> 00:08:01,760
the bug was present and then we started

00:08:00,320 --> 00:08:03,680
one in continuous integration on a

00:08:01,760 --> 00:08:06,020
robot's for several days in the test

00:08:03,680 --> 00:08:08,270
warehouse with this one in continuously

00:08:06,020 --> 00:08:10,190
in the background to make sure that the

00:08:08,270 --> 00:08:12,980
problem was really fixed and that we

00:08:10,190 --> 00:08:14,660
would catch it in the future and at the

00:08:12,980 --> 00:08:16,910
end of a few days of testing the

00:08:14,660 --> 00:08:19,520
assaults were posted on github and that

00:08:16,910 --> 00:08:22,730
the phone was not detected at all duvall

00:08:19,520 --> 00:08:25,490
wat continue to move and it also the

00:08:22,730 --> 00:08:28,250
latest w's at that point also working so

00:08:25,490 --> 00:08:30,020
we since the problem seemed to be solved

00:08:28,250 --> 00:08:33,500
the past code review and all the tests

00:08:30,020 --> 00:08:35,630
passed we merged in did a release so

00:08:33,500 --> 00:08:37,220
that everyone could have a version of

00:08:35,630 --> 00:08:39,169
cost map that planned collision-free

00:08:37,220 --> 00:08:41,419
paths like it was supposed to without

00:08:39,169 --> 00:08:44,870
the bug that had been introduced

00:08:41,419 --> 00:08:47,170
accidentally and at this point we've

00:08:44,870 --> 00:08:49,880
kind of gone through the process of

00:08:47,170 --> 00:08:51,110
fixing a bug that physical continuous

00:08:49,880 --> 00:08:53,649
integration found

00:08:51,110 --> 00:08:58,399
before we that we didn't care for the

00:08:53,649 --> 00:09:00,050
previously existing automated testing so

00:08:58,399 --> 00:09:01,430
you may be wondering how can you

00:09:00,050 --> 00:09:02,959
actually take this and apply this to

00:09:01,430 --> 00:09:05,120
yellow of arts so that you can do

00:09:02,959 --> 00:09:06,560
physical continuous integration and make

00:09:05,120 --> 00:09:09,019
sure that EF software is working well

00:09:06,560 --> 00:09:11,300
and at fetch robotics we use a few

00:09:09,019 --> 00:09:12,769
different tools when we do this so we

00:09:11,300 --> 00:09:14,480
use ansible which is used for

00:09:12,769 --> 00:09:16,579
configuration with walkest raishin of

00:09:14,480 --> 00:09:18,560
many machines and this allows us to

00:09:16,579 --> 00:09:21,290
avoid manually having to set up all of

00:09:18,560 --> 00:09:23,269
the robots and servers in a test

00:09:21,290 --> 00:09:25,940
environment and which would be

00:09:23,269 --> 00:09:28,070
error-prone in time consuming we also

00:09:25,940 --> 00:09:30,380
use zoneminder which is some open source

00:09:28,070 --> 00:09:32,959
software for recording video from all 16

00:09:30,380 --> 00:09:35,450
cameras it detects motion so that you

00:09:32,959 --> 00:09:38,269
can know when things are moving and also

00:09:35,450 --> 00:09:39,980
only record video of motion allowing us

00:09:38,269 --> 00:09:42,140
to get the most out of a 18 k by 2

00:09:39,980 --> 00:09:43,940
storage and we can have two weeks of

00:09:42,140 --> 00:09:46,640
video of all the motion in our test

00:09:43,940 --> 00:09:49,070
warehouse in addition to those existing

00:09:46,640 --> 00:09:51,140
open source tools we have a bunch of

00:09:49,070 --> 00:09:54,350
custom software that we use that ties it

00:09:51,140 --> 00:09:56,089
all together so when a developer makes a

00:09:54,350 --> 00:09:57,680
pull request on github after it goes

00:09:56,089 --> 00:09:59,300
through the regular software continuous

00:09:57,680 --> 00:10:01,490
integration and the code reprocess they

00:09:59,300 --> 00:10:03,589
can trigger the physical continuous

00:10:01,490 --> 00:10:05,240
integration process and that will get

00:10:03,589 --> 00:10:08,240
queued up in one when the robots are

00:10:05,240 --> 00:10:10,490
available and once that test has long

00:10:08,240 --> 00:10:13,579
the assaults get posted back to github

00:10:10,490 --> 00:10:15,410
with any relevant information and it's

00:10:13,579 --> 00:10:16,790
constantly gathering data and so you saw

00:10:15,410 --> 00:10:18,740
a lot of the data we gather when we

00:10:16,790 --> 00:10:20,390
walked through this cough net bug so

00:10:18,740 --> 00:10:25,699
it's constantly gathering the log files

00:10:20,390 --> 00:10:27,350
the bad data the video and strong it in

00:10:25,699 --> 00:10:29,630
a way that we can actually query it with

00:10:27,350 --> 00:10:31,160
their tools later so we can find the

00:10:29,630 --> 00:10:34,279
data that corresponds to a specific

00:10:31,160 --> 00:10:36,079
robot at a specific time or we can get

00:10:34,279 --> 00:10:37,430
all the data for all the watch doing a

00:10:36,079 --> 00:10:39,640
time period to get an idea of what was

00:10:37,430 --> 00:10:43,760
going on in the warehouse at that time

00:10:39,640 --> 00:10:45,890
and we can also fetch cool has a concept

00:10:43,760 --> 00:10:47,570
of tasks well you can tell us to do

00:10:45,890 --> 00:10:50,480
specific things and we can grab all the

00:10:47,570 --> 00:10:57,620
data based off of a task and look at how

00:10:50,480 --> 00:11:01,220
that is related to what happened so so

00:10:57,620 --> 00:11:02,389
if you've implemented

00:11:01,220 --> 00:11:04,910
off the physician education in the past

00:11:02,389 --> 00:11:08,420
you may know that you usually use

00:11:04,910 --> 00:11:09,589
containers or VMs and if somebody does

00:11:08,420 --> 00:11:12,620
something like introduces a bug that

00:11:09,589 --> 00:11:15,170
does I'm data / you delete the entire

00:11:12,620 --> 00:11:17,269
file system life can go on you report a

00:11:15,170 --> 00:11:19,610
failure you throw away the VMO container

00:11:17,269 --> 00:11:21,370
and the next test can spin up in a clean

00:11:19,610 --> 00:11:24,709
environment and start from scratch

00:11:21,370 --> 00:11:25,970
without any unexpected buds but when

00:11:24,709 --> 00:11:27,470
you're wanting physical continuous

00:11:25,970 --> 00:11:28,610
integration you're on real robots that

00:11:27,470 --> 00:11:30,050
are in the real world and you're not

00:11:28,610 --> 00:11:33,829
going to take your test warehouse throw

00:11:30,050 --> 00:11:36,050
it away and get a new one so instead you

00:11:33,829 --> 00:11:37,550
need to deal with some problems that

00:11:36,050 --> 00:11:39,649
would prevent you from getting back to a

00:11:37,550 --> 00:11:41,750
known good state and so some of these

00:11:39,649 --> 00:11:43,339
problems that have a robot crashes then

00:11:41,750 --> 00:11:45,290
you may need somebody to go look at it

00:11:43,339 --> 00:11:47,089
and get it back into a good state well

00:11:45,290 --> 00:11:48,410
what can become delocalized in which

00:11:47,089 --> 00:11:50,689
case you'll need to use the camera

00:11:48,410 --> 00:11:52,910
system to we localize them so if they

00:11:50,689 --> 00:11:54,439
can continue navigating well watching

00:11:52,910 --> 00:11:56,660
one out of battery and then somebody

00:11:54,439 --> 00:11:57,949
needs to go plug them in wait them in

00:11:56,660 --> 00:12:00,050
the charge up so they can go back to

00:11:57,949 --> 00:12:01,639
testing and you can actually get a

00:12:00,050 --> 00:12:03,649
physical deadlock if you mostly robot

00:12:01,639 --> 00:12:05,360
planner has bugs we're 20 watt stare at

00:12:03,649 --> 00:12:07,250
each other waiting for the other one to

00:12:05,360 --> 00:12:09,589
move and neither moves because they're

00:12:07,250 --> 00:12:11,209
both learning the same code and so any

00:12:09,589 --> 00:12:13,309
of these problems can basically cause

00:12:11,209 --> 00:12:15,680
the testing to knock it back to

00:12:13,309 --> 00:12:17,420
consistent state and so in order to

00:12:15,680 --> 00:12:19,910
reduce problems of not getting back to a

00:12:17,420 --> 00:12:21,709
consistent state at fetch we always do

00:12:19,910 --> 00:12:23,540
code reviews and software continue

00:12:21,709 --> 00:12:25,279
situation before we start the physical

00:12:23,540 --> 00:12:27,860
continued integration so that you can

00:12:25,279 --> 00:12:30,740
catch problems using existing testing

00:12:27,860 --> 00:12:33,439
map testing setups like regression

00:12:30,740 --> 00:12:36,920
testing unit tests before it gets onto

00:12:33,439 --> 00:12:39,019
the wheel robot in addition if a problem

00:12:36,920 --> 00:12:41,240
does sit by and it's on the menu just

00:12:39,019 --> 00:12:43,699
wanting to these films you can detect it

00:12:41,240 --> 00:12:45,170
and terminate early for example if your

00:12:43,699 --> 00:12:46,699
battery gets below a threshold that you

00:12:45,170 --> 00:12:48,680
know your charge management should never

00:12:46,699 --> 00:12:50,990
get you let your battery get to you

00:12:48,680 --> 00:12:52,579
contaminate the test upload an evil

00:12:50,990 --> 00:12:54,889
event bags for the developer and tell

00:12:52,579 --> 00:12:56,839
them that the test failed and then you

00:12:54,889 --> 00:12:59,059
can load known good code onto the robots

00:12:56,839 --> 00:13:01,339
have the robot to go charge up to an

00:12:59,059 --> 00:13:03,290
acceptable level and start the next test

00:13:01,339 --> 00:13:05,449
now that you've avoided letting the

00:13:03,290 --> 00:13:07,250
robots DYFS and battery problems you

00:13:05,449 --> 00:13:09,620
could also that can detect if overlock

00:13:07,250 --> 00:13:11,480
crashes and when one robot crash is you

00:13:09,620 --> 00:13:13,459
report a failure and upload that failure

00:13:11,480 --> 00:13:13,970
instead of letting all you robots crash

00:13:13,459 --> 00:13:15,410
and

00:13:13,970 --> 00:13:16,699
that way you can have the other velox

00:13:15,410 --> 00:13:22,189
continue the physical continuous

00:13:16,699 --> 00:13:24,680
integration as you go on so anyone who's

00:13:22,189 --> 00:13:26,269
shipping robots should really consider

00:13:24,680 --> 00:13:28,069
integrating physical continuous

00:13:26,269 --> 00:13:30,110
integration to their workflow it's

00:13:28,069 --> 00:13:32,300
really we've been using it for the past

00:13:30,110 --> 00:13:35,000
seven months at fette robotics and it's

00:13:32,300 --> 00:13:37,250
helped us ship a bust and libel software

00:13:35,000 --> 00:13:39,230
a lot faster but just like regular

00:13:37,250 --> 00:13:41,509
testing it's not a silver bullet if

00:13:39,230 --> 00:13:43,550
you're not waiting tests to detect a

00:13:41,509 --> 00:13:44,959
problem you're not going to catch that

00:13:43,550 --> 00:13:46,550
file them and it can sit through so you

00:13:44,959 --> 00:13:48,949
need to actually think about how you

00:13:46,550 --> 00:13:51,170
implement it in what you're testing so

00:13:48,949 --> 00:13:54,110
that you're testing the bugs that you

00:13:51,170 --> 00:13:55,939
want to cats but if you're shipping

00:13:54,110 --> 00:13:58,459
robots you really should strongly

00:13:55,939 --> 00:14:16,220
consider using it so we have a few

00:13:58,459 --> 00:14:27,050
minutes for questions I think they don't

00:14:16,220 --> 00:14:30,319
spoken um I'm curious to know what your

00:14:27,050 --> 00:14:32,240
test cases are like it sounds like it

00:14:30,319 --> 00:14:36,620
would be sort of like a high level smoke

00:14:32,240 --> 00:14:38,480
test but I'm just wondering I what are

00:14:36,620 --> 00:14:40,639
the bugs that you've caught where you

00:14:38,480 --> 00:14:43,430
said oh we need a new test case to cover

00:14:40,639 --> 00:14:45,439
this and like how do you kind of like

00:14:43,430 --> 00:14:47,629
manage the sweet I guess and is it

00:14:45,439 --> 00:14:49,939
something where the developer ops into a

00:14:47,629 --> 00:14:51,110
particular test or is it it feels like

00:14:49,939 --> 00:14:52,819
it would be very time-consuming and

00:14:51,110 --> 00:14:54,949
resource consuming to run a huge suite

00:14:52,819 --> 00:14:56,990
on everything yeah it is more of an

00:14:54,949 --> 00:14:59,059
integration test than like a unit test

00:14:56,990 --> 00:15:01,069
if not we don't want out building a unit

00:14:59,059 --> 00:15:02,600
test you really put unit tests you

00:15:01,069 --> 00:15:04,939
should be doing that all in software and

00:15:02,600 --> 00:15:07,430
in fact for this cost map bug it really

00:15:04,939 --> 00:15:09,620
could be caught as a set of unit tests

00:15:07,430 --> 00:15:11,449
on cost maps they just want their at the

00:15:09,620 --> 00:15:13,399
time so you can basically want to catch

00:15:11,449 --> 00:15:15,050
the bug in the integration tests you can

00:15:13,399 --> 00:15:18,470
go look at what is the root cause and

00:15:15,050 --> 00:15:19,970
see can you do it not doing the physical

00:15:18,470 --> 00:15:21,829
continuous integration with me like do a

00:15:19,970 --> 00:15:24,139
regression test playing back bag file

00:15:21,829 --> 00:15:27,290
data to cost maps and seeing if the bug

00:15:24,139 --> 00:15:27,870
bcuz so in a lot of cases you really do

00:15:27,290 --> 00:15:29,910
want to

00:15:27,870 --> 00:15:31,500
pull the tests out of the physical

00:15:29,910 --> 00:15:34,020
continues integration if you can and do

00:15:31,500 --> 00:15:35,370
it as a regression or a unit test in

00:15:34,020 --> 00:15:37,020
this case it was just kind of an example

00:15:35,370 --> 00:15:38,310
that we found the problem and we

00:15:37,020 --> 00:15:41,130
verified it with physical continued

00:15:38,310 --> 00:15:48,320
integration in addition to a normal unit

00:15:41,130 --> 00:15:52,589
testing cool hi Alex I have a question

00:15:48,320 --> 00:15:55,950
when you test the code you know one way

00:15:52,589 --> 00:16:01,230
is to check the log file and another way

00:15:55,950 --> 00:16:03,720
is to use a debug tool like gdb and do

00:16:01,230 --> 00:16:06,660
as your experience which way is better

00:16:03,720 --> 00:16:08,460
and why well so this is like continuous

00:16:06,660 --> 00:16:10,950
integration you normally you don't gdb

00:16:08,460 --> 00:16:13,589
into a continuous integration test it's

00:16:10,950 --> 00:16:16,140
kind of a if you're debugging a problem

00:16:13,589 --> 00:16:17,190
when it when you're developing you're

00:16:16,140 --> 00:16:18,630
going to be running in your development

00:16:17,190 --> 00:16:20,970
environment and you could you d be n

00:16:18,630 --> 00:16:23,460
when you've wanting it in the contingent

00:16:20,970 --> 00:16:24,540
equation environment you don't the

00:16:23,460 --> 00:16:25,770
continuous integration environments

00:16:24,540 --> 00:16:28,320
going to continue on and stay with the

00:16:25,770 --> 00:16:30,930
next test and that spot and usually look

00:16:28,320 --> 00:16:32,550
at the logs and then in this case we

00:16:30,930 --> 00:16:35,160
grabbed some extra data because we have

00:16:32,550 --> 00:16:37,410
in the real world and text isn't always

00:16:35,160 --> 00:16:40,080
enough to describe what's going on but

00:16:37,410 --> 00:16:42,570
if you need a to g DB into something to

00:16:40,080 --> 00:16:44,430
debug an issue you probably want to fire

00:16:42,570 --> 00:16:45,750
it up on like development robot locally

00:16:44,430 --> 00:16:48,450
not try to run it through the physical

00:16:45,750 --> 00:16:52,470
continuous integration system and which

00:16:48,450 --> 00:16:55,279
way is used intensively used can you

00:16:52,470 --> 00:16:59,820
beat that which one is intensively used

00:16:55,279 --> 00:17:01,410
in the practice I mean we use both that

00:16:59,820 --> 00:17:04,800
fetch like the physical continuous

00:17:01,410 --> 00:17:06,959
integration is a is a integration test

00:17:04,800 --> 00:17:09,300
to make sure that everything was but if

00:17:06,959 --> 00:17:11,429
we find an issue then we go back to we

00:17:09,300 --> 00:17:13,920
use both the logs that it provides as in

00:17:11,429 --> 00:17:15,900
the example here and we go back and we

00:17:13,920 --> 00:17:18,000
produce it on a robot so that wouldn't

00:17:15,900 --> 00:17:25,290
pull up and use tools like gdb if we

00:17:18,000 --> 00:17:29,070
need to ok thank you hey there um so I'm

00:17:25,290 --> 00:17:31,679
curious how you manage the kind of size

00:17:29,070 --> 00:17:33,450
of your bag files so imagine you know

00:17:31,679 --> 00:17:35,450
with your say your cost maps if you had

00:17:33,450 --> 00:17:37,860
you know a couple hearts of you know

00:17:35,450 --> 00:17:39,390
uncompressed cost maps out all your

00:17:37,860 --> 00:17:41,220
robots I can go pretty big can you just

00:17:39,390 --> 00:17:44,010
talk about some of your approach

00:17:41,220 --> 00:17:47,490
to dealing with that yeah so we we have

00:17:44,010 --> 00:17:49,770
all our loss bags compressed we also do

00:17:47,490 --> 00:17:51,419
for some topics we publish a throttle

00:17:49,770 --> 00:17:54,120
dozen and we record the throttle buzz

00:17:51,419 --> 00:17:55,320
and if it's a fast update wait but the

00:17:54,120 --> 00:17:57,690
big thing we do is we just have lots of

00:17:55,320 --> 00:17:59,760
disk space because that way you have the

00:17:57,690 --> 00:18:02,280
data you need because otherwise like

00:17:59,760 --> 00:18:03,720
when you need data often you really need

00:18:02,280 --> 00:18:05,909
the data and it's a lot more effort to

00:18:03,720 --> 00:18:08,039
try to reproduce the problem then to

00:18:05,909 --> 00:18:10,020
just get a few extra discs and half the

00:18:08,039 --> 00:18:11,820
data you need about how much storage

00:18:10,020 --> 00:18:14,340
have you found you need for like a day's

00:18:11,820 --> 00:18:15,900
worth of one of your robots I don't

00:18:14,340 --> 00:18:17,460
member the number four days I know we

00:18:15,900 --> 00:18:19,020
the server we have with bag files

00:18:17,460 --> 00:18:22,320
actually comes to about a month's worth

00:18:19,020 --> 00:18:25,110
of bag files and it's not nearly as big

00:18:22,320 --> 00:18:27,299
as the one for the video so less than 18

00:18:25,110 --> 00:18:35,400
televised for a month all right thanks

00:18:27,299 --> 00:18:38,059
oh I have a to question okay what was

00:18:35,400 --> 00:18:41,150
the biggest benefit compared to

00:18:38,059 --> 00:18:45,539
continuous integration in simulation and

00:18:41,150 --> 00:18:46,799
I compared to fiscal integration yeah so

00:18:45,539 --> 00:18:48,510
I mean they're not really mutually

00:18:46,799 --> 00:18:50,549
exclusive you probably want both just

00:18:48,510 --> 00:18:52,230
like if you want the cost map bug we

00:18:50,549 --> 00:18:54,210
could fight as unit test once we found

00:18:52,230 --> 00:18:55,770
the issue the big benefit of physical

00:18:54,210 --> 00:18:58,140
continuous integration over simulation

00:18:55,770 --> 00:18:59,610
is that we get to test the closest thing

00:18:58,140 --> 00:19:01,919
we can to what we're shipping to our

00:18:59,610 --> 00:19:03,630
customers and the other things that the

00:19:01,919 --> 00:19:05,789
simulation doesn't cover right now like

00:19:03,630 --> 00:19:08,010
we heard earlier like Wi-Fi is a big

00:19:05,789 --> 00:19:09,750
problem and testing that your wife your

00:19:08,010 --> 00:19:11,850
robots handle life I disconnects and

00:19:09,750 --> 00:19:15,059
reconnects like now at least in gazebo

00:19:11,850 --> 00:19:17,250
is in is non-trivial but like if you can

00:19:15,059 --> 00:19:18,659
test something in simulation then you

00:19:17,250 --> 00:19:20,250
can add that to powder your regular

00:19:18,659 --> 00:19:22,470
stuff but a continuous integration in

00:19:20,250 --> 00:19:23,700
caps it sooner but you still probably a

00:19:22,470 --> 00:19:26,039
physical computer integration to make

00:19:23,700 --> 00:19:27,419
sure that there's not any anything

00:19:26,039 --> 00:19:32,030
that's not covered in simulation that

00:19:27,419 --> 00:19:32,030

YouTube URL: https://www.youtube.com/watch?v=JNV9CkARh_g


