Title: ROSCon 2016 Seoul Day 2   RTROS   A real time extension to the Robot Operating System
Publication date: 2016-10-20
Playlist: ROSCon 2016
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2016 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,060 --> 00:00:04,950
so hello my name is John Carson I'm from

00:00:03,179 --> 00:00:07,859
the real-time systems group at the

00:00:04,950 --> 00:00:10,349
magnets University in Hannover and today

00:00:07,859 --> 00:00:12,090
I would like to present real-time Rose a

00:00:10,349 --> 00:00:15,360
real-time extension to the robot

00:00:12,090 --> 00:00:17,730
operating system in its version 1.6 well

00:00:15,360 --> 00:00:22,680
our project started prior to being

00:00:17,730 --> 00:00:25,289
announced just a short and very very

00:00:22,680 --> 00:00:27,750
brief motivation why do we want to do

00:00:25,289 --> 00:00:30,060
real-time well a lot of robots work

00:00:27,750 --> 00:00:32,130
quite well without some especially if

00:00:30,060 --> 00:00:36,149
they get bigger in size or more complex

00:00:32,130 --> 00:00:38,750
or are operated in well unsecure or

00:00:36,149 --> 00:00:41,070
high-risk environments they need to

00:00:38,750 --> 00:00:44,850
deliver some sort of real-time

00:00:41,070 --> 00:00:47,309
guarantees in performance and that's

00:00:44,850 --> 00:00:49,350
what we would like to do was Ross so why

00:00:47,309 --> 00:00:52,110
do we choose Ross and not one one of the

00:00:49,350 --> 00:00:55,110
other open source real-time frameworks

00:00:52,110 --> 00:00:57,840
we believe that that Ross offers quite a

00:00:55,110 --> 00:00:59,879
unique usability and a lot of tools and

00:00:57,840 --> 00:01:02,160
what we have a lot of people who use

00:00:59,879 --> 00:01:04,019
Ross and who would like to stay close to

00:01:02,160 --> 00:01:05,580
Ross and not learn to work with a

00:01:04,019 --> 00:01:08,729
complete different ecosystem and

00:01:05,580 --> 00:01:11,820
framework I would like to give you a

00:01:08,729 --> 00:01:13,530
short introduction show you a rough

00:01:11,820 --> 00:01:19,280
architecture of what we've been building

00:01:13,530 --> 00:01:22,320
and using describe how we managed to

00:01:19,280 --> 00:01:24,630
well use publish/subscribe and service

00:01:22,320 --> 00:01:25,770
communication show a little bit about

00:01:24,630 --> 00:01:28,979
what we've been doing in real-time

00:01:25,770 --> 00:01:30,570
debugging I show some an example code

00:01:28,979 --> 00:01:33,350
and talk about some some current work

00:01:30,570 --> 00:01:36,360
which is actually ongoing at the moment

00:01:33,350 --> 00:01:37,619
first of all first of all what was the

00:01:36,360 --> 00:01:40,290
design goals for us

00:01:37,619 --> 00:01:42,329
as mentioned before usability was a hot

00:01:40,290 --> 00:01:44,610
topic for us we wanted to have a

00:01:42,329 --> 00:01:46,860
software which is really usable and

00:01:44,610 --> 00:01:49,229
which not that take that match extra

00:01:46,860 --> 00:01:52,500
configuration and possibly hide a lot of

00:01:49,229 --> 00:01:56,640
the extra work done in or necessary for

00:01:52,500 --> 00:01:58,770
for real time one of the hardly the the

00:01:56,640 --> 00:02:01,590
most important goal for us is we wanted

00:01:58,770 --> 00:02:03,270
to at least suffice or be able to

00:02:01,590 --> 00:02:06,119
deliver real time performance at best

00:02:03,270 --> 00:02:08,580
hard real time performance safety is an

00:02:06,119 --> 00:02:09,959
issue as well especially when using hard

00:02:08,580 --> 00:02:12,720
real-time systems which are often

00:02:09,959 --> 00:02:13,530
deployed in high risk or critical

00:02:12,720 --> 00:02:17,730
scenarios

00:02:13,530 --> 00:02:19,260
you need to deliver some level of safety

00:02:17,730 --> 00:02:23,220
the more the better

00:02:19,260 --> 00:02:25,740
still this led us to start to focus on a

00:02:23,220 --> 00:02:27,750
small core and only take parts of rods

00:02:25,740 --> 00:02:32,819
which we try to pour to real time and

00:02:27,750 --> 00:02:35,459
get up and working so what did we do we

00:02:32,819 --> 00:02:37,110
discussed forking the entire Ross stack

00:02:35,459 --> 00:02:39,810
and just trying to port it to Ross but

00:02:37,110 --> 00:02:42,270
since this is definitely too big we've

00:02:39,810 --> 00:02:44,010
started to take out parts and this parts

00:02:42,270 --> 00:02:47,070
being published Subscribe communication

00:02:44,010 --> 00:02:51,360
services and the other essential parts

00:02:47,070 --> 00:02:54,239
to be able to create a small system of

00:02:51,360 --> 00:02:57,930
real time Ross nodes on one PC as well

00:02:54,239 --> 00:03:00,480
so network has not been included yet we

00:02:57,930 --> 00:03:02,310
wanted to have Ross beside tests so we

00:03:00,480 --> 00:03:05,220
wanted to still make use of all the Ross

00:03:02,310 --> 00:03:07,019
tools and all the ecosystem and use as

00:03:05,220 --> 00:03:09,660
much from Ross as possible not only the

00:03:07,019 --> 00:03:11,670
API so our real-time Ross notes

00:03:09,660 --> 00:03:14,700
especially during initialization are

00:03:11,670 --> 00:03:17,880
using the Ross parameter server and all

00:03:14,700 --> 00:03:21,380
the other stuff we've all been used are

00:03:17,880 --> 00:03:24,600
using and are accustomed with for

00:03:21,380 --> 00:03:27,660
written Ross we're using a shared memory

00:03:24,600 --> 00:03:31,500
library which is open source and allows

00:03:27,660 --> 00:03:33,900
for real-time communication and our main

00:03:31,500 --> 00:03:38,070
development has been posed focused on

00:03:33,900 --> 00:03:41,400
Xena my in its version 2.6 but I'll come

00:03:38,070 --> 00:03:44,370
to that later when talking about

00:03:41,400 --> 00:03:46,140
real-time usually you want to have two

00:03:44,370 --> 00:03:48,630
things you have always time triggered

00:03:46,140 --> 00:03:50,190
behavior so always you look at cycles

00:03:48,630 --> 00:03:54,329
and the latency is in the

00:03:50,190 --> 00:04:00,410
and so I would like to just show you

00:03:54,329 --> 00:04:03,450
this for a little moment especially when

00:04:00,410 --> 00:04:05,370
comparing different real-time operating

00:04:03,450 --> 00:04:06,900
systems which are necessary like like

00:04:05,370 --> 00:04:09,209
for instance you know my since Ubuntu

00:04:06,900 --> 00:04:10,650
and the mainline Linux kernel does not

00:04:09,209 --> 00:04:13,200
offer a real-time performance out of the

00:04:10,650 --> 00:04:14,670
box it is necessary to patch the kernel

00:04:13,200 --> 00:04:16,799
and sometimes add some user libraries

00:04:14,670 --> 00:04:21,150
Xena might ask this preemptory is

00:04:16,799 --> 00:04:23,550
another example all are mainly compared

00:04:21,150 --> 00:04:26,010
by cyclic tests meaning your recycle you

00:04:23,550 --> 00:04:28,560
say like okay I want to have a node or

00:04:26,010 --> 00:04:31,530
running at a few Hertz maybe some

00:04:28,560 --> 00:04:33,480
kilohertz and you measure the difference

00:04:31,530 --> 00:04:36,120
between the scheduled time your threat

00:04:33,480 --> 00:04:37,890
should wake up again and the actual time

00:04:36,120 --> 00:04:40,080
it did and this is basically the system

00:04:37,890 --> 00:04:42,180
latency which is introduced and this is

00:04:40,080 --> 00:04:43,740
something even though you build on top

00:04:42,180 --> 00:04:45,690
of it you cannot get better than the

00:04:43,740 --> 00:04:48,570
system latency this is introduced in

00:04:45,690 --> 00:04:50,520
every step so on the right side you can

00:04:48,570 --> 00:04:52,700
see a plot this is basically a histogram

00:04:50,520 --> 00:04:55,830
on the vertical axis you can see the

00:04:52,700 --> 00:04:57,990
occurrences in a logarithmic scale on

00:04:55,830 --> 00:05:00,090
the horizontal axis the userspace

00:04:57,990 --> 00:05:01,500
latency in this case ross is running in

00:05:00,090 --> 00:05:04,230
userspace therefore this is what we're

00:05:01,500 --> 00:05:06,630
looking at in microseconds what you can

00:05:04,230 --> 00:05:08,940
see is that the vast majority of all

00:05:06,630 --> 00:05:11,550
occurrences is below 5 microseconds

00:05:08,940 --> 00:05:13,200
which is nice which is very nice but the

00:05:11,550 --> 00:05:15,990
more important part is that it is

00:05:13,200 --> 00:05:17,040
bounded so even though many many tests

00:05:15,990 --> 00:05:19,710
runs have being performed

00:05:17,040 --> 00:05:22,830
22 microseconds is the maximum latency

00:05:19,710 --> 00:05:24,240
expected or shown in this case so this

00:05:22,830 --> 00:05:26,010
is the actual behavior you want to see

00:05:24,240 --> 00:05:28,380
and we do not want to see this only a

00:05:26,010 --> 00:05:31,050
system latency but for Ross as well and

00:05:28,380 --> 00:05:33,210
this is why we started with benchmarks

00:05:31,050 --> 00:05:35,820
the first benchmark is the rate

00:05:33,210 --> 00:05:37,710
benchmark ross nodes are mostly

00:05:35,820 --> 00:05:40,830
controlled or time controlled by writes

00:05:37,710 --> 00:05:43,950
you can set a loop rate and well control

00:05:40,830 --> 00:05:46,050
how fast your threads will run again or

00:05:43,950 --> 00:05:50,640
use the spin behavior where basically

00:05:46,050 --> 00:05:52,770
ross does this for you so we just took a

00:05:50,640 --> 00:05:55,620
system on on the system we performed

00:05:52,770 --> 00:05:58,440
just the benchmark across we put in a

00:05:55,620 --> 00:06:00,900
rule a loop rate and we measured the

00:05:58,440 --> 00:06:02,910
difference between the actual time we

00:06:00,900 --> 00:06:05,700
would have liked the know to run and the

00:06:02,910 --> 00:06:06,990
time it actually ran because in

00:06:05,700 --> 00:06:09,600
real-time systems we're talking about

00:06:06,990 --> 00:06:11,610
worst-case scenarios so all these tests

00:06:09,600 --> 00:06:13,920
have been performed under stress system

00:06:11,610 --> 00:06:16,200
so we introduced a bunch of load for the

00:06:13,920 --> 00:06:19,170
cpu we do a lot of extensive computation

00:06:16,200 --> 00:06:21,870
we copy in memory and we copied from

00:06:19,170 --> 00:06:24,360
this to this and do as much as possible

00:06:21,870 --> 00:06:26,790
to come very close to a stress system

00:06:24,360 --> 00:06:28,620
and get a worst case scenario in this

00:06:26,790 --> 00:06:31,710
scenario again the exes are the same for

00:06:28,620 --> 00:06:35,430
all diagrams and we had two point seven

00:06:31,710 --> 00:06:36,270
milliseconds average latency and 21

00:06:35,430 --> 00:06:38,850
million

00:06:36,270 --> 00:06:41,490
next agency which is a pay but as you

00:06:38,850 --> 00:06:44,190
can see the plot looks a little bit more

00:06:41,490 --> 00:06:45,990
jittery and this is not the drew type of

00:06:44,190 --> 00:06:49,199
behavior we would really like so our

00:06:45,990 --> 00:06:52,349
goal was to try to improve this for

00:06:49,199 --> 00:06:54,349
real-time Ross um we were able to get

00:06:52,349 --> 00:06:57,960
measurements reading as you can see here

00:06:54,349 --> 00:07:03,449
in an average we had 0.6 0.6

00:06:57,960 --> 00:07:06,120
microseconds of latency and below 105 15

00:07:03,449 --> 00:07:07,789
microseconds in max latency on the

00:07:06,120 --> 00:07:10,979
system we performed this we had around

00:07:07,789 --> 00:07:12,300
100 microseconds of system latency so

00:07:10,979 --> 00:07:16,320
this is basically what we would expect

00:07:12,300 --> 00:07:18,349
to see and are therefore quite happy

00:07:16,320 --> 00:07:21,900
with the results

00:07:18,349 --> 00:07:23,520
besides being able to control a threat

00:07:21,900 --> 00:07:26,009
to run unreal we and the real-time

00:07:23,520 --> 00:07:28,740
constraints using publish and subscribe

00:07:26,009 --> 00:07:32,009
is one of the main ways to communicate

00:07:28,740 --> 00:07:34,560
and without this our approach would not

00:07:32,009 --> 00:07:36,300
differ from from the possibility to just

00:07:34,560 --> 00:07:38,039
install a real-time operating system and

00:07:36,300 --> 00:07:39,539
just run a thread and use real-time

00:07:38,039 --> 00:07:41,490
tools to interface with Ross

00:07:39,539 --> 00:07:44,370
so publish/subscribe communication is

00:07:41,490 --> 00:07:47,099
one of the key aspects we try to keep

00:07:44,370 --> 00:07:49,380
the API as close to us as possible so

00:07:47,099 --> 00:07:51,870
the the publish and the callback is very

00:07:49,380 --> 00:07:54,180
very close to the Ross AP AP I very

00:07:51,870 --> 00:07:56,849
close means there are some exceptions we

00:07:54,180 --> 00:07:58,560
need to make especially because all our

00:07:56,849 --> 00:08:00,449
memory all our variables need to be

00:07:58,560 --> 00:08:03,060
pre-allocated therefore we need a

00:08:00,449 --> 00:08:05,070
maximum message size ross allows us to

00:08:03,060 --> 00:08:07,259
just publish a lot of things which is

00:08:05,070 --> 00:08:10,229
nice which gives us a great flexibility

00:08:07,259 --> 00:08:12,360
but in a real-time system we need to

00:08:10,229 --> 00:08:14,430
know prior how how big the maximum

00:08:12,360 --> 00:08:17,120
message will be and this is one of the

00:08:14,430 --> 00:08:21,210
parameter parameters added at this point

00:08:17,120 --> 00:08:23,370
well as you can see after publishing the

00:08:21,210 --> 00:08:25,770
message gets serialized and transmitted

00:08:23,370 --> 00:08:29,520
through a shared memory and the other

00:08:25,770 --> 00:08:32,339
node then uses a pole which is well very

00:08:29,520 --> 00:08:34,110
similar to Ross one behavior after the

00:08:32,339 --> 00:08:38,789
deserialization the callback is called

00:08:34,110 --> 00:08:41,279
and executed for services we basically

00:08:38,789 --> 00:08:42,899
used us as well to communicate since we

00:08:41,279 --> 00:08:44,970
have already implemented it for publish

00:08:42,899 --> 00:08:47,370
and subscribe we only had to change a

00:08:44,970 --> 00:08:48,490
few things in Ross 1 most of the

00:08:47,370 --> 00:08:51,640
services are loosely

00:08:48,490 --> 00:08:54,550
toppled so as soon as you call a service

00:08:51,640 --> 00:08:56,800
it first asked if the service is already

00:08:54,550 --> 00:08:59,560
there if it's available that's why we

00:08:56,800 --> 00:09:01,240
always use wait for servers and things

00:08:59,560 --> 00:09:02,589
like that this is something we do not

00:09:01,240 --> 00:09:04,779
want to do in a real time behavior

00:09:02,589 --> 00:09:07,810
therefore for real time loss all

00:09:04,779 --> 00:09:09,940
services need to be initialized before

00:09:07,810 --> 00:09:12,520
running the main loop and starting the

00:09:09,940 --> 00:09:14,560
real time behavior and therefore we have

00:09:12,520 --> 00:09:16,300
a permanent coupling so the server and

00:09:14,560 --> 00:09:21,010
the clients are permanently coupled and

00:09:16,300 --> 00:09:22,570
the connection is always active for

00:09:21,010 --> 00:09:26,680
publish and subscribe again we perform

00:09:22,570 --> 00:09:29,440
some benchmarks again we started for for

00:09:26,680 --> 00:09:30,490
Ross 1x we're using indigo sorry I did

00:09:29,440 --> 00:09:34,089
not mention that before we were using

00:09:30,490 --> 00:09:37,810
indigo again a stress system and we came

00:09:34,089 --> 00:09:44,560
up with 210 microseconds average latency

00:09:37,810 --> 00:09:46,240
and 27 milliseconds in max latency the

00:09:44,560 --> 00:09:48,100
latency here was measured that we took a

00:09:46,240 --> 00:09:50,020
timestamp on the system right before

00:09:48,100 --> 00:09:54,570
sending the message and directly when

00:09:50,020 --> 00:09:57,310
the callback came back to compare what

00:09:54,570 --> 00:10:00,520
well time it took for the message to go

00:09:57,310 --> 00:10:02,020
we took basically the time message so we

00:10:00,520 --> 00:10:03,880
sent the time step over to the

00:10:02,020 --> 00:10:07,000
subscriber node so this is a relatively

00:10:03,880 --> 00:10:09,970
small message in this case for real-time

00:10:07,000 --> 00:10:12,250
rose we were able to receive an output

00:10:09,970 --> 00:10:15,610
as you can see here we had an average

00:10:12,250 --> 00:10:18,700
latency from around about 45

00:10:15,610 --> 00:10:20,649
microseconds and a maximum of 180

00:10:18,700 --> 00:10:22,570
microseconds again this is basically

00:10:20,649 --> 00:10:25,600
what we would expect since the polling

00:10:22,570 --> 00:10:28,839
behavior runs at roughly 10 kilohertz

00:10:25,600 --> 00:10:31,899
and ask if there are new messages so we

00:10:28,839 --> 00:10:34,810
will have relatively constant behavior

00:10:31,899 --> 00:10:36,480
between 0 and 100 microseconds so again

00:10:34,810 --> 00:10:39,640
we were very happy with the results and

00:10:36,480 --> 00:10:43,120
moved on to test service oh sorry we did

00:10:39,640 --> 00:10:44,860
not move on yet we again counted the

00:10:43,120 --> 00:10:47,770
messages and especially on a stress

00:10:44,860 --> 00:10:49,810
system we were able to burn out that

00:10:47,770 --> 00:10:53,110
Ross was not able to deliver all

00:10:49,810 --> 00:10:54,820
messages even though on one system I was

00:10:53,110 --> 00:10:57,010
personally surprised that there were no

00:10:54,820 --> 00:10:58,570
really high level warnings or arrows

00:10:57,010 --> 00:11:02,440
going on I was expecting something like

00:10:58,570 --> 00:11:04,540
that in this case but still I mean it's

00:11:02,440 --> 00:11:06,640
well above 99% of messages being

00:11:04,540 --> 00:11:08,470
delivered so in most cases it will not

00:11:06,640 --> 00:11:10,180
be a problem but especially when you

00:11:08,470 --> 00:11:12,730
come to real time it's not only

00:11:10,180 --> 00:11:15,100
important that when an answer comes this

00:11:12,730 --> 00:11:17,260
is beyond it well inside of the deadline

00:11:15,100 --> 00:11:21,550
the answer needs to come and this is

00:11:17,260 --> 00:11:23,800
very important for services again we

00:11:21,550 --> 00:11:26,500
perform benchmarks for us you can see

00:11:23,800 --> 00:11:28,030
the time it takes a lot longer than

00:11:26,500 --> 00:11:29,890
publish/subscribe this is due to the

00:11:28,030 --> 00:11:33,090
fact that the connection needs to be

00:11:29,890 --> 00:11:36,820
established priorly and we were around

00:11:33,090 --> 00:11:40,390
26 milliseconds of average latency and

00:11:36,820 --> 00:11:43,570
around 50 microseconds in the max

00:11:40,390 --> 00:11:46,150
maximum case for real-time roles the

00:11:43,570 --> 00:11:48,570
performance is very very near to what we

00:11:46,150 --> 00:11:51,160
expected or what we saw with

00:11:48,570 --> 00:11:53,470
publish/subscribe since we are aware

00:11:51,160 --> 00:11:55,210
that an answer or a request should come

00:11:53,470 --> 00:11:56,920
in the next time we do not have to Paul

00:11:55,210 --> 00:12:00,370
we can just wait for the answer to come

00:11:56,920 --> 00:12:04,120
and therefore basically eliminate the

00:12:00,370 --> 00:12:06,750
well maximum of 100 microseconds

00:12:04,120 --> 00:12:09,430
introduced through the polling behavior

00:12:06,750 --> 00:12:12,010
in both cases all messages or all

00:12:09,430 --> 00:12:15,070
requests came there this test was

00:12:12,010 --> 00:12:17,110
performed by taking a time stamp right

00:12:15,070 --> 00:12:21,760
before calling the service and directly

00:12:17,110 --> 00:12:22,840
after the service returned I would like

00:12:21,760 --> 00:12:24,700
to talk a little bit about real-time

00:12:22,840 --> 00:12:26,680
debugging because my experience was

00:12:24,700 --> 00:12:28,750
real-time is it's nice when it's working

00:12:26,680 --> 00:12:32,110
but the biggest problem is to get it

00:12:28,750 --> 00:12:35,410
there and to find out what's going on so

00:12:32,110 --> 00:12:37,570
we ported the Ross console to be real

00:12:35,410 --> 00:12:40,210
time safe through your able to do some

00:12:37,570 --> 00:12:42,550
real-time save and debugging one of the

00:12:40,210 --> 00:12:44,860
biggest problems is if you use real-time

00:12:42,550 --> 00:12:47,800
say--if version of print which basically

00:12:44,860 --> 00:12:49,900
means the print is not executed directly

00:12:47,800 --> 00:12:53,290
but taken to another thread then your

00:12:49,900 --> 00:12:56,200
logging is not exactly there where you

00:12:53,290 --> 00:12:57,970
would expect your program to be so when

00:12:56,200 --> 00:12:59,980
your program crashes it could be that

00:12:57,970 --> 00:13:02,140
it's trashed like a few hundred lines of

00:12:59,980 --> 00:13:06,070
code below the point where you would see

00:13:02,140 --> 00:13:09,810
your output to be this is basically why

00:13:06,070 --> 00:13:13,150
we added a few real-time related

00:13:09,810 --> 00:13:14,830
signal handlers which try to figure out

00:13:13,150 --> 00:13:16,180
when something went wrong and printed

00:13:14,830 --> 00:13:18,490
stacktrace through your

00:13:16,180 --> 00:13:20,710
be able to find out that watched my at

00:13:18,490 --> 00:13:23,470
what point this went wrong and this is

00:13:20,710 --> 00:13:27,850
usually and can be configured printed to

00:13:23,470 --> 00:13:29,890
the console as about to show some

00:13:27,850 --> 00:13:32,529
example code how does it look

00:13:29,890 --> 00:13:35,470
this is basically a Ross talker node

00:13:32,529 --> 00:13:37,230
which just includes the Ross header the

00:13:35,470 --> 00:13:40,000
the standard message time header

00:13:37,230 --> 00:13:42,580
initializes the node and after

00:13:40,000 --> 00:13:44,980
initializing well this one pre allocates

00:13:42,580 --> 00:13:50,850
the message data as well to be better

00:13:44,980 --> 00:13:53,910
compatible sir and in the main loop then

00:13:50,850 --> 00:13:56,860
just takes the timestamp and sends it

00:13:53,910 --> 00:13:59,649
this one runs with a thousand Hertz as

00:13:56,860 --> 00:14:01,480
well the real-time Ross node basically

00:13:59,649 --> 00:14:02,680
just switched the header so we need to

00:14:01,480 --> 00:14:05,529
include the real-time Ross header

00:14:02,680 --> 00:14:08,020
instead and we switched the namespace

00:14:05,529 --> 00:14:10,120
this is basically done because we would

00:14:08,020 --> 00:14:12,610
like the option for hybrid nodes to be

00:14:10,120 --> 00:14:15,070
either in real-time or non real-time we

00:14:12,610 --> 00:14:16,750
wanted to be able to use a lot of the

00:14:15,070 --> 00:14:18,940
Ross functionality during initialization

00:14:16,750 --> 00:14:21,070
or debugging phases where we're not in

00:14:18,940 --> 00:14:23,529
hard real-time therefore a namespace

00:14:21,070 --> 00:14:26,170
change has been included so that we can

00:14:23,529 --> 00:14:28,660
have hybrid systems or just by trying

00:14:26,170 --> 00:14:30,910
out real term Ross you do not break your

00:14:28,660 --> 00:14:36,610
existing Ross system so you can just try

00:14:30,910 --> 00:14:37,720
it out besides yeah otherwise Ross or RT

00:14:36,610 --> 00:14:40,540
Ross use this is the same message

00:14:37,720 --> 00:14:42,339
different message definition so you can

00:14:40,540 --> 00:14:46,240
include and use all the messages you

00:14:42,339 --> 00:14:47,560
currently have and yeah well we believes

00:14:46,240 --> 00:14:49,839
therefore the usability and the

00:14:47,560 --> 00:14:52,209
compatibility compatibility is quite

00:14:49,839 --> 00:14:55,750
high so it's easy to port an application

00:14:52,209 --> 00:14:58,060
or to use this approach to develop new

00:14:55,750 --> 00:15:01,000
ones according to the standard Ross

00:14:58,060 --> 00:15:02,410
documentation it's use so I would like

00:15:01,000 --> 00:15:05,470
to talk a little bit about the current

00:15:02,410 --> 00:15:07,230
work of course we are working on testing

00:15:05,470 --> 00:15:10,209
and improving the current state of work

00:15:07,230 --> 00:15:13,149
we're apparently or we started to set up

00:15:10,209 --> 00:15:15,880
a continuous integration testing system

00:15:13,149 --> 00:15:17,980
where we want to be able to test for

00:15:15,880 --> 00:15:20,470
real time constraints as well therefore

00:15:17,980 --> 00:15:22,480
we cannot use as much virtualization

00:15:20,470 --> 00:15:25,180
that we would like to use but we use

00:15:22,480 --> 00:15:27,400
dedicated systems with real-time

00:15:25,180 --> 00:15:28,930
operating system installed and just a

00:15:27,400 --> 00:15:31,710
trigger the jobs there

00:15:28,930 --> 00:15:36,040
currently we are testing for Xena my 3.0

00:15:31,710 --> 00:15:38,670
cinema 2.64 and preamp dirty I'm not

00:15:36,040 --> 00:15:41,200
entirely sure which version and we're

00:15:38,670 --> 00:15:45,000
possible this is possible to be extended

00:15:41,200 --> 00:15:48,430
in the future all our work or all our

00:15:45,000 --> 00:15:50,200
design on Xena my except the signal

00:15:48,430 --> 00:15:52,630
handling and mode switch tracking and

00:15:50,200 --> 00:15:55,780
some special stuff is based on the POSIX

00:15:52,630 --> 00:15:57,690
API so it should be exchangeable to to

00:15:55,780 --> 00:16:00,550
most real-time operating systems and

00:15:57,690 --> 00:16:03,580
well you could run it on a staff all -

00:16:00,550 --> 00:16:05,530
boom - as well without what real-time

00:16:03,580 --> 00:16:07,690
guarantees but just to debug it test it

00:16:05,530 --> 00:16:10,210
this is doable

00:16:07,690 --> 00:16:12,040
besides testing and improving currently

00:16:10,210 --> 00:16:16,000
there is an external evaluation going on

00:16:12,040 --> 00:16:18,580
so group outside of our research group

00:16:16,000 --> 00:16:21,040
is evaluating this and afterwards this

00:16:18,580 --> 00:16:22,690
is finished we were planning to

00:16:21,040 --> 00:16:26,170
completely open-source everything we've

00:16:22,690 --> 00:16:28,410
been doing so far I'm very positive to

00:16:26,170 --> 00:16:31,390
do this in the next few months so I'm

00:16:28,410 --> 00:16:35,200
hoping to be able to release this this

00:16:31,390 --> 00:16:37,720
year of course and we're working on

00:16:35,200 --> 00:16:39,670
basically two new features the current

00:16:37,720 --> 00:16:43,690
state of real-time Ross has been focused

00:16:39,670 --> 00:16:45,610
on single computers being able to span a

00:16:43,690 --> 00:16:47,650
real-time system over a few nodes but

00:16:45,610 --> 00:16:49,090
still on one system Network

00:16:47,650 --> 00:16:51,580
communication and time synchronization

00:16:49,090 --> 00:16:54,130
are currently ongoing topics which we

00:16:51,580 --> 00:16:57,280
are hoping to be able to include over

00:16:54,130 --> 00:17:00,820
the next well - years as soon as

00:16:57,280 --> 00:17:02,860
possible so to show you a little

00:17:00,820 --> 00:17:05,740
overview what is currently possible to

00:17:02,860 --> 00:17:07,300
do you can use publish and subscribe

00:17:05,740 --> 00:17:09,090
well not all publish and subscribe

00:17:07,300 --> 00:17:11,860
options but I believe the main ones

00:17:09,090 --> 00:17:14,050
server sister possible you have access

00:17:11,860 --> 00:17:16,540
to Ross time rate and all functions

00:17:14,050 --> 00:17:18,990
needed to control your your node

00:17:16,540 --> 00:17:21,730
we prompted the transform library which

00:17:18,990 --> 00:17:24,760
works quite well and you have access to

00:17:21,730 --> 00:17:27,910
the console so you're able to set up

00:17:24,760 --> 00:17:29,830
well a small system not distributed but

00:17:27,910 --> 00:17:31,500
based on a single system where is real

00:17:29,830 --> 00:17:32,650
time Ross and Ross nodes alike and

00:17:31,500 --> 00:17:33,850
communicates

00:17:32,650 --> 00:17:36,190
since both used the same message

00:17:33,850 --> 00:17:38,260
definitions it's not able to communicate

00:17:36,190 --> 00:17:41,290
directly but you can just relay the

00:17:38,260 --> 00:17:42,160
message very very easily what are the

00:17:41,290 --> 00:17:45,610
problems

00:17:42,160 --> 00:17:48,700
well one big problem drivers we are

00:17:45,610 --> 00:17:50,830
usually using a lot of hardware and we

00:17:48,700 --> 00:17:52,900
need all parts of our working system to

00:17:50,830 --> 00:17:54,520
be real time compatible and a lot of

00:17:52,900 --> 00:17:57,039
drivers are not and they're a closed

00:17:54,520 --> 00:17:59,320
source supporting them is it's hard for

00:17:57,039 --> 00:18:03,539
instance graphics drivers tend to

00:17:59,320 --> 00:18:05,679
introduce quite big amount of latency

00:18:03,539 --> 00:18:07,780
besides drivers the real time

00:18:05,679 --> 00:18:09,460
restrictions while this middleware are

00:18:07,780 --> 00:18:11,890
the the interface and the framework

00:18:09,460 --> 00:18:14,169
allows you to perform real time

00:18:11,890 --> 00:18:16,120
operations to some degree your user code

00:18:14,169 --> 00:18:17,169
the user code can definitely break it so

00:18:16,120 --> 00:18:19,299
there are a lot of things you're not

00:18:17,169 --> 00:18:21,820
allowed to do for instance you need to

00:18:19,299 --> 00:18:24,190
pre allocate all your your memory you're

00:18:21,820 --> 00:18:27,130
using and you need to refrain from using

00:18:24,190 --> 00:18:29,740
any unbounded methods for possibly

00:18:27,130 --> 00:18:31,120
optimization or something like that and

00:18:29,740 --> 00:18:33,580
sensors

00:18:31,120 --> 00:18:36,070
well while most of the robotic systems

00:18:33,580 --> 00:18:37,960
use a few sensors it's nice for them to

00:18:36,070 --> 00:18:40,809
be in real time as well otherwise the

00:18:37,960 --> 00:18:45,220
reaction to a sensor input would not be

00:18:40,809 --> 00:18:47,289
real time safe and currently well a lot

00:18:45,220 --> 00:18:49,510
of sensors use usb which is not very

00:18:47,289 --> 00:18:51,970
nice for real-time performance so the

00:18:49,510 --> 00:18:54,150
availability of real time saves sensors

00:18:51,970 --> 00:18:57,549
which are affordable I must say is

00:18:54,150 --> 00:18:59,110
limited so thank you for your time and I

00:18:57,549 --> 00:19:01,140
believe we have like one minute for

00:18:59,110 --> 00:19:01,140
questions

00:19:11,910 --> 00:19:18,790
yeah do you expose thread priority in

00:19:15,970 --> 00:19:21,310
the RT Ross interface where is it yeah

00:19:18,790 --> 00:19:23,680
so thread priority is like associated

00:19:21,310 --> 00:19:26,820
with publishers and subscribers or is it

00:19:23,680 --> 00:19:29,680
Nate the native like POSIX yeah

00:19:26,820 --> 00:19:32,440
basically for for cui there is an

00:19:29,680 --> 00:19:34,990
extended priority model which is exposed

00:19:32,440 --> 00:19:37,060
entirely you can you can use it it's on

00:19:34,990 --> 00:19:38,590
node basis so not for publish on

00:19:37,060 --> 00:19:42,150
subscribers we do not prioritize the

00:19:38,590 --> 00:19:44,530
communication only the nodes currently

00:19:42,150 --> 00:19:45,310
alright thank you for your presentation

00:19:44,530 --> 00:19:47,530
really interesting

00:19:45,310 --> 00:19:50,110
I was basically I'm toning are three

00:19:47,530 --> 00:19:51,550
things first if you use shared memory

00:19:50,110 --> 00:19:53,320
why do you still see your eyes or your

00:19:51,550 --> 00:19:55,270
messages because you could just exchange

00:19:53,320 --> 00:19:57,580
pointers essentially like not--let's for

00:19:55,270 --> 00:19:59,290
instance do or Oracle's can do if you if

00:19:57,580 --> 00:20:02,140
you share you know you put your notes in

00:19:59,290 --> 00:20:04,120
one process too can you say something

00:20:02,140 --> 00:20:06,400
about how much you have to change to get

00:20:04,120 --> 00:20:08,170
your timer so accurately just due to the

00:20:06,400 --> 00:20:09,760
fact that you use the POSIX library from

00:20:08,170 --> 00:20:12,220
Xena my to get your timers real-time

00:20:09,760 --> 00:20:14,260
safe and the third one I'll just write

00:20:12,220 --> 00:20:16,210
because otherwise you won't okay I start

00:20:14,260 --> 00:20:18,280
with the first one maybe rephrase or

00:20:16,210 --> 00:20:20,530
repeat the second one and did the first

00:20:18,280 --> 00:20:24,850
one basically we used up and especially

00:20:20,530 --> 00:20:26,860
for Strings and when you transmit arrays

00:20:24,850 --> 00:20:29,410
it's better to serialize them until the

00:20:26,860 --> 00:20:31,720
option was easier and the the latency

00:20:29,410 --> 00:20:33,880
introduced during civilization is at

00:20:31,720 --> 00:20:36,220
this point a solo and we're not

00:20:33,880 --> 00:20:37,630
optimizing to this high level yet that

00:20:36,220 --> 00:20:39,580
this has not been an issue yet

00:20:37,630 --> 00:20:41,200
this is definitely an idea to try to

00:20:39,580 --> 00:20:43,330
reduce the amount of serializing and

00:20:41,200 --> 00:20:45,280
deserializing but has not been a focus

00:20:43,330 --> 00:20:46,480
yet could you rephrase the second

00:20:45,280 --> 00:20:50,590
question because i did not really get

00:20:46,480 --> 00:20:52,180
that so you showed that that late ship

00:20:50,590 --> 00:20:54,160
lots of the the worst case execution

00:20:52,180 --> 00:20:57,130
time basically for your for your timers

00:20:54,160 --> 00:20:58,270
the rush rate grants work that you did

00:20:57,130 --> 00:20:59,260
and i was just wondering how much you

00:20:58,270 --> 00:21:00,910
had to change in the actual

00:20:59,260 --> 00:21:04,060
implementation to get down to that level

00:21:00,910 --> 00:21:05,770
of execution time in other than just

00:21:04,060 --> 00:21:08,380
changing things to do zina my postage

00:21:05,770 --> 00:21:09,820
library very very little actually for

00:21:08,380 --> 00:21:11,500
for the rate it was was very very

00:21:09,820 --> 00:21:13,570
straightforward most of the action or

00:21:11,500 --> 00:21:15,280
most of the problems arose with

00:21:13,570 --> 00:21:17,539
debugging and trying to to add

00:21:15,280 --> 00:21:19,580
functionality to be able to do

00:21:17,539 --> 00:21:21,649
things and to find out what's going on

00:21:19,580 --> 00:21:22,850
and what's going on wrong okay well and

00:21:21,649 --> 00:21:25,369
the third one was why did you not use

00:21:22,850 --> 00:21:27,440
TLS F for instance sorry what again

00:21:25,369 --> 00:21:28,909
well you're using a you said it yet to

00:21:27,440 --> 00:21:30,200
reallocate everything which is true

00:21:28,909 --> 00:21:32,960
because you can't do anything a memory

00:21:30,200 --> 00:21:34,960
allocation but if you use a real time

00:21:32,960 --> 00:21:36,919
safe than a memory allocation

00:21:34,960 --> 00:21:38,419
infrastructure basically you could avoid

00:21:36,919 --> 00:21:40,729
that so I'm wondering why you did not go

00:21:38,419 --> 00:21:42,080
that would has not been a focus yet we

00:21:40,729 --> 00:21:43,700
are definitely going to look into this

00:21:42,080 --> 00:21:46,749
in the future but currently we're

00:21:43,700 --> 00:21:46,749

YouTube URL: https://www.youtube.com/watch?v=adlUcW_vsZk


