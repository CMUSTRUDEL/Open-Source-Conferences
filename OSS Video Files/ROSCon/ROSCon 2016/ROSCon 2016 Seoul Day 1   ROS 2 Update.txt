Title: ROSCon 2016 Seoul Day 1   ROS 2 Update
Publication date: 2016-10-20
Playlist: ROSCon 2016
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2016 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,620 --> 00:00:07,020
so like your hood we're here to give you

00:00:03,899 --> 00:00:08,849
the rose to update I'm Deanna hood and

00:00:07,020 --> 00:00:10,800
I'm really worth it

00:00:08,849 --> 00:00:12,960
OSR f we have a QR code here and a

00:00:10,800 --> 00:00:14,549
Google short link there's some diagrams

00:00:12,960 --> 00:00:16,859
in the presentation so if you want to

00:00:14,549 --> 00:00:22,380
follow along potentially it might be

00:00:16,859 --> 00:00:23,939
useful so we'll get started um as we are

00:00:22,380 --> 00:00:26,189
aware not everyone in this room might

00:00:23,939 --> 00:00:29,550
have heard of the Rostov project before

00:00:26,189 --> 00:00:32,009
so we'll start off with an overview go

00:00:29,550 --> 00:00:34,079
into some high-level overview of the

00:00:32,009 --> 00:00:36,800
features that have changed in the last

00:00:34,079 --> 00:00:39,059
year and some implementation take

00:00:36,800 --> 00:00:42,149
implementation details or a few of them

00:00:39,059 --> 00:00:44,340
and our experience in the last year of

00:00:42,149 --> 00:00:46,200
working with real robots on Rus to the

00:00:44,340 --> 00:00:48,390
turtle boats specifically and the

00:00:46,200 --> 00:00:52,920
roadmap of what's headed in the future

00:00:48,390 --> 00:00:54,360
for the project so when talking about

00:00:52,920 --> 00:00:56,280
the motivation for us to it usually

00:00:54,360 --> 00:00:58,739
helps to start looking at Ross in

00:00:56,280 --> 00:01:01,379
general and we see roses made up as a

00:00:58,739 --> 00:01:03,059
bunch of different components namely the

00:01:01,379 --> 00:01:05,150
plumbing at the core of everything that

00:01:03,059 --> 00:01:07,890
allows you to pass different parts

00:01:05,150 --> 00:01:10,850
pieces rather of information between the

00:01:07,890 --> 00:01:13,470
parts of the system as well as tools for

00:01:10,850 --> 00:01:15,780
visualization capabilities for

00:01:13,470 --> 00:01:17,490
navigation for example and the ecosystem

00:01:15,780 --> 00:01:20,159
of thousands of packages that are

00:01:17,490 --> 00:01:22,500
available to you as a community that is

00:01:20,159 --> 00:01:26,490
what allows things like Ross Khan to be

00:01:22,500 --> 00:01:28,829
possible Ross has been used on thousands

00:01:26,490 --> 00:01:30,479
of different robots now and each of

00:01:28,829 --> 00:01:33,030
those robotics systems has a set of

00:01:30,479 --> 00:01:34,680
different characteristics and depending

00:01:33,030 --> 00:01:36,420
on those characteristics different

00:01:34,680 --> 00:01:39,540
systems will make pie make use of

00:01:36,420 --> 00:01:43,140
different parts of Rus so for example

00:01:39,540 --> 00:01:45,750
the pr2 systems using the pr2

00:01:43,140 --> 00:01:47,880
are typically characterized by having a

00:01:45,750 --> 00:01:50,009
research focus they've got lots of

00:01:47,880 --> 00:01:52,979
sensor data to process but also lots of

00:01:50,009 --> 00:01:55,200
computational power the PRT onboard has

00:01:52,979 --> 00:01:58,770
two high speed computers connected with

00:01:55,200 --> 00:02:02,399
a near ideal network connection um and

00:01:58,770 --> 00:02:05,820
as it was one of it was the first robot

00:02:02,399 --> 00:02:08,910
using Russ you see

00:02:05,820 --> 00:02:11,250
most of the tools that were developed

00:02:08,910 --> 00:02:13,860
early on and

00:02:11,250 --> 00:02:17,099
at the later sorry the early stage of

00:02:13,860 --> 00:02:20,550
Russ have this sort of system in mind

00:02:17,099 --> 00:02:24,900
where with this set of characteristics

00:02:20,550 --> 00:02:26,550
but of course over time in the last near

00:02:24,900 --> 00:02:27,780
decade there have been a lot of new use

00:02:26,550 --> 00:02:31,709
cases that have come up

00:02:27,780 --> 00:02:33,180
for example drone delivery start up eyes

00:02:31,709 --> 00:02:34,739
gonna have a lot of different

00:02:33,180 --> 00:02:37,319
characteristics for the robotic system

00:02:34,739 --> 00:02:39,900
you're gonna be more concerned with

00:02:37,319 --> 00:02:42,060
power consumption as you move towards

00:02:39,900 --> 00:02:44,190
production you've got smaller processes

00:02:42,060 --> 00:02:48,900
onboard drones coming in and out of

00:02:44,190 --> 00:02:50,730
contact with each other and as this is

00:02:48,900 --> 00:02:51,920
quite a large contrast from the system

00:02:50,730 --> 00:02:55,380
with the pr2

00:02:51,920 --> 00:02:58,110
then and even this system wasn't

00:02:55,380 --> 00:03:00,180
necessarily even around in 2007 if you

00:02:58,110 --> 00:03:02,190
think about it and so what you find is

00:03:00,180 --> 00:03:03,750
that some of the tools and the roads

00:03:02,190 --> 00:03:06,630
infrastructure start to break down a bit

00:03:03,750 --> 00:03:09,090
with these newer use cases for example

00:03:06,630 --> 00:03:10,650
Russ doesn't deal too well with the

00:03:09,090 --> 00:03:14,160
unreliable network connections between

00:03:10,650 --> 00:03:18,269
drones and the relatively large amount

00:03:14,160 --> 00:03:20,700
of computational resources on the small

00:03:18,269 --> 00:03:22,500
processes can be an issue so we know

00:03:20,700 --> 00:03:24,510
that there are areas where we can

00:03:22,500 --> 00:03:29,040
improve Russ to target some of these

00:03:24,510 --> 00:03:31,859
newer use cases and we have identified a

00:03:29,040 --> 00:03:34,230
few of those as the goals for Russ to

00:03:31,859 --> 00:03:37,049
some multi robot systems I spoke about

00:03:34,230 --> 00:03:39,630
but also allowing you to use the same

00:03:37,049 --> 00:03:42,930
code for prototypes as you use in

00:03:39,630 --> 00:03:44,910
production pushing rows to is far down

00:03:42,930 --> 00:03:48,410
onto the devices as possible so that it

00:03:44,910 --> 00:03:50,850
works best in or works better in these

00:03:48,410 --> 00:03:54,090
situations where you have lots of small

00:03:50,850 --> 00:03:56,579
computational units cooperating as well

00:03:54,090 --> 00:03:58,950
as better support for real-time systems

00:03:56,579 --> 00:04:02,959
and Windows as we know that these are

00:03:58,950 --> 00:04:05,390
important to a lot of our users so

00:04:02,959 --> 00:04:08,819
comparing with the diagram before then

00:04:05,390 --> 00:04:11,389
how Russ would compare with Russ to

00:04:08,819 --> 00:04:17,039
rather would compare with Russ one

00:04:11,389 --> 00:04:19,320
wherein Russ won the plumbing was all

00:04:17,039 --> 00:04:21,450
pretty much custom from top to bottom in

00:04:19,320 --> 00:04:24,220
Russ to what we've done instead is to

00:04:21,450 --> 00:04:26,170
reuse what we can from DDS and this

00:04:24,220 --> 00:04:28,140
is an industry standard that's then

00:04:26,170 --> 00:04:31,090
implemented by different vendors and

00:04:28,140 --> 00:04:34,510
it's been used in a lot of high risk

00:04:31,090 --> 00:04:37,900
high visibility scenarios like medical

00:04:34,510 --> 00:04:41,350
industry financial services space

00:04:37,900 --> 00:04:43,720
exploration and with that comes with a

00:04:41,350 --> 00:04:46,420
lot of credibility in terms of sort of

00:04:43,720 --> 00:04:48,160
production quality but in addition to

00:04:46,420 --> 00:04:50,590
that it has a lot of features that are

00:04:48,160 --> 00:04:53,530
just inherently applicable to these

00:04:50,590 --> 00:04:56,890
modern robotic systems so for example

00:04:53,530 --> 00:05:00,370
you've got masterless discovery and we

00:04:56,890 --> 00:05:02,410
know for example that the centralized

00:05:00,370 --> 00:05:04,810
discovery protocol in Ross one is a

00:05:02,410 --> 00:05:06,370
blocker for a lot of multi robot systems

00:05:04,810 --> 00:05:11,980
where this is something that is just

00:05:06,370 --> 00:05:13,920
inherent in DDS in order to use DDS we

00:05:11,980 --> 00:05:18,570
know us we've had to restructure kind of

00:05:13,920 --> 00:05:21,940
how the Ross how Rus is set up and so

00:05:18,570 --> 00:05:23,770
we're in Ross one your user code is

00:05:21,940 --> 00:05:25,600
going to tap into the Ross API and that

00:05:23,770 --> 00:05:28,690
will speak directly to the network in

00:05:25,600 --> 00:05:30,400
Ross to the Ross API acts as more of an

00:05:28,690 --> 00:05:32,380
abstraction layer and then the actual

00:05:30,400 --> 00:05:35,530
work of sending data to the network goes

00:05:32,380 --> 00:05:37,300
through a DDS implementation and this

00:05:35,530 --> 00:05:39,220
can be one of a few different supported

00:05:37,300 --> 00:05:41,140
implementations we'll go into more

00:05:39,220 --> 00:05:42,460
details about that in a minute but in

00:05:41,140 --> 00:05:44,740
general they all have the common

00:05:42,460 --> 00:05:47,580
functionality of masterless discovery

00:05:44,740 --> 00:05:50,860
for example and other features that

00:05:47,580 --> 00:05:53,770
allow you to have higher level of

00:05:50,860 --> 00:05:57,190
control over the specifications of the

00:05:53,770 --> 00:05:59,729
transport so if you are at Ross Con last

00:05:57,190 --> 00:06:03,040
year you might have seen one of the

00:05:59,729 --> 00:06:06,460
demos that we gave which was the quality

00:06:03,040 --> 00:06:08,800
of service demo that since we have this

00:06:06,460 --> 00:06:12,160
is a feature that is inherited DDS and

00:06:08,800 --> 00:06:15,280
then we've exposed to the Ross API that

00:06:12,160 --> 00:06:17,590
allows you to to have finer control over

00:06:15,280 --> 00:06:19,270
the the network settings so the not

00:06:17,590 --> 00:06:20,650
every packet has to be acknowledged and

00:06:19,270 --> 00:06:23,680
this sort of thing and you have quite a

00:06:20,650 --> 00:06:26,830
wide variety of settings that you can

00:06:23,680 --> 00:06:28,570
tweak and this is an example of

00:06:26,830 --> 00:06:31,419
something that comes out from using DDS

00:06:28,570 --> 00:06:32,770
underneath so if you haven't seen these

00:06:31,419 --> 00:06:34,810
demos I would encourage you to check

00:06:32,770 --> 00:06:36,510
them out they give a good overview of

00:06:34,810 --> 00:06:40,560
how

00:06:36,510 --> 00:06:44,610
this this date of russ to as it was a

00:06:40,560 --> 00:06:48,960
dress cotton last year for now we'll

00:06:44,610 --> 00:06:50,820
focus on what's new this year so there

00:06:48,960 --> 00:06:52,410
have been a lot of changes of course

00:06:50,820 --> 00:06:55,020
there gonna be more than will be able to

00:06:52,410 --> 00:06:57,750
speak about in this hope but to

00:06:55,020 --> 00:07:00,420
summarize some of the key user facing

00:06:57,750 --> 00:07:03,300
features i've presented on this slide i

00:07:00,420 --> 00:07:05,250
also noted the the alpha that they were

00:07:03,300 --> 00:07:06,960
released with so that if you're

00:07:05,250 --> 00:07:09,990
interested in the implementation details

00:07:06,960 --> 00:07:11,640
you can you know which time like period

00:07:09,990 --> 00:07:14,550
of time to go check out the different

00:07:11,640 --> 00:07:16,770
code changes but in general support for

00:07:14,550 --> 00:07:19,260
more DDS vendors programming languages

00:07:16,770 --> 00:07:22,490
and platforms so we'll go into more

00:07:19,260 --> 00:07:25,020
detail about the turtle but later but

00:07:22,490 --> 00:07:28,620
we've improved out arm support for

00:07:25,020 --> 00:07:30,780
example actually it was a community

00:07:28,620 --> 00:07:33,060
member that tried out rose to on the

00:07:30,780 --> 00:07:34,980
raspberry PI's for the first time we

00:07:33,060 --> 00:07:38,400
work with dragon board this sort of

00:07:34,980 --> 00:07:40,770
thing but moving these aside for a

00:07:38,400 --> 00:07:42,390
minute because in addition to the user

00:07:40,770 --> 00:07:44,310
facing features you also have a lot of

00:07:42,390 --> 00:07:48,630
changes that have happened kind of

00:07:44,310 --> 00:07:51,450
beneath the surface and these can these

00:07:48,630 --> 00:07:53,430
are often tightly coupled to the user

00:07:51,450 --> 00:07:56,400
facing feature but just to give an

00:07:53,430 --> 00:07:59,070
example of something that might seem

00:07:56,400 --> 00:08:01,860
like a straightforward feature is the

00:07:59,070 --> 00:08:03,510
functionality for a node to wait for a

00:08:01,860 --> 00:08:07,440
service to become available before it

00:08:03,510 --> 00:08:09,720
calls it as a client this underneath

00:08:07,440 --> 00:08:12,000
requires the whole infrastructure of

00:08:09,720 --> 00:08:14,100
providing notifications of when there

00:08:12,000 --> 00:08:16,410
are changes that happen in the Ross

00:08:14,100 --> 00:08:18,390
graph like nodes coming online or in

00:08:16,410 --> 00:08:20,010
this case a particular service coming

00:08:18,390 --> 00:08:23,340
available and making those notifications

00:08:20,010 --> 00:08:27,810
available to the nodes

00:08:23,340 --> 00:08:29,700
similarly the Python client library to

00:08:27,810 --> 00:08:31,410
make those changes required a lot of

00:08:29,700 --> 00:08:32,820
reshuffling underneath the surface set

00:08:31,410 --> 00:08:36,599
we'll go into more details about later

00:08:32,820 --> 00:08:39,000
for now we're gonna focus on adding five

00:08:36,599 --> 00:08:41,190
such PS as one of our supported

00:08:39,000 --> 00:08:43,310
middleware and work that was involved in

00:08:41,190 --> 00:08:43,310
that

00:08:44,990 --> 00:08:51,320
like I mentioned you can use a variety

00:08:48,770 --> 00:08:54,350
of supported DDS implementations with

00:08:51,320 --> 00:08:56,750
Russ to the reasons you might want to

00:08:54,350 --> 00:08:58,880
switch between them and it's kind of

00:08:56,750 --> 00:09:01,130
depend on the particular project that

00:08:58,880 --> 00:09:02,660
you're working on so for example you

00:09:01,130 --> 00:09:05,450
might find that a particular

00:09:02,660 --> 00:09:07,820
implementation has a license that works

00:09:05,450 --> 00:09:11,120
better for your case or works better on

00:09:07,820 --> 00:09:16,030
smaller processors is sort of fly it

00:09:11,120 --> 00:09:20,000
part of me is certified for space travel

00:09:16,030 --> 00:09:22,310
this sort of thing as well as diagnostic

00:09:20,000 --> 00:09:25,700
tools that the vendors will provide and

00:09:22,310 --> 00:09:28,490
what we allow you to do is that actually

00:09:25,700 --> 00:09:29,900
you can write your code and then switch

00:09:28,490 --> 00:09:32,030
between different supported vendors

00:09:29,900 --> 00:09:34,160
without having to recompile and part of

00:09:32,030 --> 00:09:36,710
how that's achieved is through this Ross

00:09:34,160 --> 00:09:38,240
middleware API the kind of acts as an

00:09:36,710 --> 00:09:41,540
abstraction for all of the different

00:09:38,240 --> 00:09:43,960
vendors that are underneath because this

00:09:41,540 --> 00:09:47,000
diagram is obviously a simplification

00:09:43,960 --> 00:09:49,100
and DDS as I mentioned is a

00:09:47,000 --> 00:09:50,720
specification that's then implemented by

00:09:49,100 --> 00:09:53,270
different vendors and so what you find

00:09:50,720 --> 00:09:57,589
is that there are variations on exactly

00:09:53,270 --> 00:09:59,630
how those implementations are done and

00:09:57,589 --> 00:10:02,330
part of what's done in the Ross

00:09:59,630 --> 00:10:04,220
middleware API is to absorb the

00:10:02,330 --> 00:10:06,200
differences in those implementations

00:10:04,220 --> 00:10:10,640
kind of smooth out the variations

00:10:06,200 --> 00:10:13,100
between the vendors so that up from code

00:10:10,640 --> 00:10:15,500
that's above that layer all of the

00:10:13,100 --> 00:10:20,690
vendors present kind of they're seen

00:10:15,500 --> 00:10:21,980
equally in the eyes of Ross and if you

00:10:20,690 --> 00:10:24,200
consider them what we're speaking about

00:10:21,980 --> 00:10:25,700
when we say that we added first SVS as

00:10:24,200 --> 00:10:27,560
one of the supported Ross middleware

00:10:25,700 --> 00:10:32,210
implementations what we're referring to

00:10:27,560 --> 00:10:35,300
is the work that goes into adding this

00:10:32,210 --> 00:10:37,370
sort of block in this adapter that

00:10:35,300 --> 00:10:39,080
allows then five sites appears to be

00:10:37,370 --> 00:10:43,040
used underneath and plugged into the

00:10:39,080 --> 00:10:46,220
system as one of the Ross middlewares so

00:10:43,040 --> 00:10:49,220
we have until recently been supporting

00:10:46,220 --> 00:10:51,710
for different DDS implementations of

00:10:49,220 --> 00:10:55,880
course as a lot of work that comes with

00:10:51,710 --> 00:10:56,529
maintaining multiple and so what we have

00:10:55,880 --> 00:11:00,670
done

00:10:56,529 --> 00:11:04,120
please cut that back - too far - yes

00:11:00,670 --> 00:11:07,930
being the default and then connect from

00:11:04,120 --> 00:11:10,300
RTI in addition to that because the two

00:11:07,930 --> 00:11:11,949
combined allow us to exercise all of the

00:11:10,300 --> 00:11:15,279
features of the API that we're looking

00:11:11,949 --> 00:11:19,839
to test our sound and from a design

00:11:15,279 --> 00:11:21,819
perspective if you might be wondering

00:11:19,839 --> 00:11:24,220
like what it is about fuss at CPS so

00:11:21,819 --> 00:11:26,579
we're interested in that would prompt us

00:11:24,220 --> 00:11:31,059
to add it and then make it our default

00:11:26,579 --> 00:11:34,269
so far SPS is open-source they recently

00:11:31,059 --> 00:11:38,290
changed their license to Apache 2.0 so

00:11:34,269 --> 00:11:40,629
free and permissive and even though it's

00:11:38,290 --> 00:11:42,009
not necessarily a fully fledged EDS

00:11:40,629 --> 00:11:44,499
implementation like the other vendors

00:11:42,009 --> 00:11:45,999
that we support it's more of a

00:11:44,499 --> 00:11:50,079
lightweight implementation of the core

00:11:45,999 --> 00:11:52,180
wire protocol and so where there were

00:11:50,079 --> 00:11:53,740
features that were missing in the

00:11:52,180 --> 00:11:57,160
implementation that we were making use

00:11:53,740 --> 00:11:58,839
of in russ to aricema the organization

00:11:57,160 --> 00:12:00,639
behind forced us to be us has been very

00:11:58,839 --> 00:12:04,319
helpful in in working with us to add

00:12:00,639 --> 00:12:07,569
those features so that from a

00:12:04,319 --> 00:12:10,180
perspective of the the user now they are

00:12:07,569 --> 00:12:12,459
all they all present the functionality

00:12:10,180 --> 00:12:18,029
that we need in a roast middleware

00:12:12,459 --> 00:12:20,740
implementation conveniently they also

00:12:18,029 --> 00:12:24,160
fast IDs can be integrated seamlessly

00:12:20,740 --> 00:12:27,459
into our tool chain so that we can we

00:12:24,160 --> 00:12:30,129
can package now from top to bottom a

00:12:27,459 --> 00:12:34,180
russ to system vendor included that is

00:12:30,129 --> 00:12:36,189
Apache 2.0 license so hopefully this

00:12:34,180 --> 00:12:38,470
gives you an idea of some of the

00:12:36,189 --> 00:12:40,750
background work that is behind maybe you

00:12:38,470 --> 00:12:42,370
just see like a one sentence change log

00:12:40,750 --> 00:12:44,139
that's like added support for five

00:12:42,370 --> 00:12:46,329
status as a middleweight implementation

00:12:44,139 --> 00:12:51,339
and this is to give you an idea of the

00:12:46,329 --> 00:12:53,740
work that is behind that moving on to

00:12:51,339 --> 00:12:55,240
the Python client library which is

00:12:53,740 --> 00:12:59,470
something that we know that people were

00:12:55,240 --> 00:13:03,189
looking forward to in Russ - like in

00:12:59,470 --> 00:13:04,480
Russ one you can use you can have nodes

00:13:03,189 --> 00:13:06,020
in rows - that are written in different

00:13:04,480 --> 00:13:08,240
programming languages

00:13:06,020 --> 00:13:11,060
and they're able to speak to each other

00:13:08,240 --> 00:13:13,610
and how they how each note is

00:13:11,060 --> 00:13:17,959
implemented is because sorry rather is

00:13:13,610 --> 00:13:20,779
through app I sent a Russ client library

00:13:17,959 --> 00:13:22,490
that is in the respective language and

00:13:20,779 --> 00:13:24,740
so these these client libraries are

00:13:22,490 --> 00:13:27,350
designed to be implemented in a way that

00:13:24,740 --> 00:13:30,230
is supposed to feel kind of natural to

00:13:27,350 --> 00:13:31,730
the respective language so pythonic in

00:13:30,230 --> 00:13:33,350
the case of Python and it shouldn't

00:13:31,730 --> 00:13:38,089
necessarily feel like you're being

00:13:33,350 --> 00:13:42,920
forced into a CE API and where they sit

00:13:38,089 --> 00:13:45,170
in the the Ross stack is between the

00:13:42,920 --> 00:13:47,060
user code at the top and the middleware

00:13:45,170 --> 00:13:48,649
interface at the bottom which which we

00:13:47,060 --> 00:13:50,720
mentioned is kind of what encapsulates

00:13:48,649 --> 00:13:54,470
the core functionality that's necessary

00:13:50,720 --> 00:13:58,850
in order to then build the rest of Russ

00:13:54,470 --> 00:14:03,230
on top the sorts of functionality that

00:13:58,850 --> 00:14:05,029
you'll find in client library are the

00:14:03,230 --> 00:14:06,589
things that sort of Russ is known for

00:14:05,029 --> 00:14:09,350
the things you think of when you think

00:14:06,589 --> 00:14:11,329
of for us mostly so that names can be

00:14:09,350 --> 00:14:13,450
put into different namespaces that they

00:14:11,329 --> 00:14:16,250
can have parameters associated with them

00:14:13,450 --> 00:14:19,490
you know the functionality that we think

00:14:16,250 --> 00:14:22,730
adds a lot of brings brings a lot of

00:14:19,490 --> 00:14:24,829
benefit to to Ross users by in addition

00:14:22,730 --> 00:14:26,690
to those features you'll find some

00:14:24,829 --> 00:14:28,120
things in the client library that maybe

00:14:26,690 --> 00:14:31,850
you wouldn't necessarily consider

00:14:28,120 --> 00:14:34,370
features as themselves so for example

00:14:31,850 --> 00:14:37,040
the threading model like what happens

00:14:34,370 --> 00:14:38,990
when you call spin and that that then

00:14:37,040 --> 00:14:41,660
has to go and start up different threads

00:14:38,990 --> 00:14:44,029
to actually run the code or if you want

00:14:41,660 --> 00:14:45,740
to bypass network communication if

00:14:44,029 --> 00:14:47,810
you're running nodes within the same

00:14:45,740 --> 00:14:50,329
program then inter-process communication

00:14:47,810 --> 00:14:51,829
is something that you'll be able to take

00:14:50,329 --> 00:14:53,779
advantage of but it's not necessarily

00:14:51,829 --> 00:14:56,600
seen as like a user facing feature it's

00:14:53,779 --> 00:14:59,480
more under the hood and when these last

00:14:56,600 --> 00:15:00,770
two in particular are parts of the

00:14:59,480 --> 00:15:02,990
client libraries that tend to be

00:15:00,770 --> 00:15:04,700
actually specific to the programming

00:15:02,990 --> 00:15:06,890
language that they're implemented in so

00:15:04,700 --> 00:15:08,060
for inter-process communication for

00:15:06,890 --> 00:15:11,029
example you're going to need to know

00:15:08,060 --> 00:15:13,220
about things higher-level concepts

00:15:11,029 --> 00:15:17,000
things like memory management and types

00:15:13,220 --> 00:15:17,520
and the threading model for example is

00:15:17,000 --> 00:15:20,040
going to be

00:15:17,520 --> 00:15:21,690
depending on different libraries

00:15:20,040 --> 00:15:26,610
depending on what language you're using

00:15:21,690 --> 00:15:28,560
and what the rest of those features are

00:15:26,610 --> 00:15:32,060
though are it's mostly more like

00:15:28,560 --> 00:15:34,050
behavior or logic and these things

00:15:32,060 --> 00:15:36,690
ideally should behave the same

00:15:34,050 --> 00:15:39,180
regardless of what language the client

00:15:36,690 --> 00:15:41,040
library is implemented in so there's a

00:15:39,180 --> 00:15:42,810
lot of opportunity there for the client

00:15:41,040 --> 00:15:45,360
libraries to share that core

00:15:42,810 --> 00:15:48,210
functionality so this is what we have

00:15:45,360 --> 00:15:50,310
done we've broken out the core

00:15:48,210 --> 00:15:51,900
functionality of the client library into

00:15:50,310 --> 00:15:53,700
the Ross client library and then the

00:15:51,900 --> 00:15:56,310
programming language specific client

00:15:53,700 --> 00:16:00,660
libraries build on top of that to fill

00:15:56,310 --> 00:16:03,660
in what's missing and by doing this we

00:16:00,660 --> 00:16:05,610
hope that the the client libraries of

00:16:03,660 --> 00:16:08,190
the different languages are smaller and

00:16:05,610 --> 00:16:10,050
easier to maintain but more importantly

00:16:08,190 --> 00:16:13,980
we find that they're more consistent and

00:16:10,050 --> 00:16:16,110
in Ross 1 in comparison you have the

00:16:13,980 --> 00:16:17,130
Python client library was Python top to

00:16:16,110 --> 00:16:19,800
bottom and it was a completely different

00:16:17,130 --> 00:16:21,600
implementation to C++ 1 which meant that

00:16:19,800 --> 00:16:23,400
if you ever found a bug in parameters

00:16:21,600 --> 00:16:26,100
you would have to go and fix it in

00:16:23,400 --> 00:16:27,930
multiple places whereas in this setup if

00:16:26,100 --> 00:16:30,270
you decide to change the behavior of

00:16:27,930 --> 00:16:31,800
console logging then you update that in

00:16:30,270 --> 00:16:34,200
one place and all of the client

00:16:31,800 --> 00:16:38,520
libraries will then be updated at the

00:16:34,200 --> 00:16:40,680
same time and this isn't just client

00:16:38,520 --> 00:16:43,820
libraries that we implement but any

00:16:40,680 --> 00:16:48,750
client libraries that are contributed by

00:16:43,820 --> 00:16:51,060
anyone that wants to tap into ICL so the

00:16:48,750 --> 00:16:52,920
c-sharp and java implementations have

00:16:51,060 --> 00:16:56,940
actually been contributed by community

00:16:52,920 --> 00:17:01,410
members and we have implemented the Ross

00:16:56,940 --> 00:17:02,940
client library our CL core in NC because

00:17:01,410 --> 00:17:05,360
that's one of the languages that's been

00:17:02,940 --> 00:17:08,190
typically the easiest for other

00:17:05,360 --> 00:17:11,940
programming languages to wrap with

00:17:08,190 --> 00:17:14,520
foreign function interface --is so to

00:17:11,940 --> 00:17:16,800
give you drill down more into the

00:17:14,520 --> 00:17:19,230
details about what this communication

00:17:16,800 --> 00:17:21,660
between client libraries using different

00:17:19,230 --> 00:17:23,610
languages looks like I'll pass over to

00:17:21,660 --> 00:17:25,339
William to run through an example oh

00:17:23,610 --> 00:17:28,530
thanks dear

00:17:25,339 --> 00:17:31,080
yeah so I'm gonna drill a little bit

00:17:28,530 --> 00:17:33,269
more into detail about how the

00:17:31,080 --> 00:17:35,460
stack works basically following a

00:17:33,269 --> 00:17:37,679
message as it goes from publish and it's

00:17:35,460 --> 00:17:39,630
received by a listener post and talker

00:17:37,679 --> 00:17:41,460
and received by listener so if you

00:17:39,630 --> 00:17:44,220
consider the really you know common

00:17:41,460 --> 00:17:46,019
example of a talker and a listener

00:17:44,220 --> 00:17:47,370
talking over chatter if you've ever done

00:17:46,019 --> 00:17:50,279
the Ross tutorials this probably looks

00:17:47,370 --> 00:17:52,649
somewhat familiar to you so if we take a

00:17:50,279 --> 00:17:55,140
look at the talker it's very familiar

00:17:52,649 --> 00:18:01,110
probably very similar to what you would

00:17:55,140 --> 00:18:04,529
see in Ross Ross one will we create a

00:18:01,110 --> 00:18:07,710
node and a publisher and then in a loop

00:18:04,529 --> 00:18:10,169
we're going to populate the data in a

00:18:07,710 --> 00:18:11,669
message and publish it and it'll say

00:18:10,169 --> 00:18:15,659
hello world and increment each time it

00:18:11,669 --> 00:18:17,340
publishes and so we're we're going to

00:18:15,659 --> 00:18:22,830
drill down is where you actually do the

00:18:17,340 --> 00:18:24,600
publish call and so at this point it it

00:18:22,830 --> 00:18:28,500
goes into the implementation of our CL

00:18:24,600 --> 00:18:30,899
PI which is actually written in C a lot

00:18:28,500 --> 00:18:32,700
of it is and this is what's called in

00:18:30,899 --> 00:18:34,200
python a python extension and a lot of

00:18:32,700 --> 00:18:36,440
programming languages have this concept

00:18:34,200 --> 00:18:38,909
of extending the language using c

00:18:36,440 --> 00:18:41,760
sometimes other languages like c++ but

00:18:38,909 --> 00:18:44,070
most commonly see and so there's a lot

00:18:41,760 --> 00:18:49,559
of stuff here the big things to see is

00:18:44,070 --> 00:18:51,779
that you know we're basically passing in

00:18:49,559 --> 00:18:54,000
the publisher object and the message the

00:18:51,779 --> 00:18:55,649
user wants to publish and then there's a

00:18:54,000 --> 00:18:57,750
step here where we convert it from the

00:18:55,649 --> 00:19:00,649
python message that the user was using

00:18:57,750 --> 00:19:03,299
and manipulating and we convert that to

00:19:00,649 --> 00:19:06,210
a message that the underlying middleware

00:19:03,299 --> 00:19:09,179
can digest and then finally we call our

00:19:06,210 --> 00:19:11,460
CL publish where we're now passing into

00:19:09,179 --> 00:19:14,010
the language in specific part of the

00:19:11,460 --> 00:19:16,440
system so up until this point we're in

00:19:14,010 --> 00:19:17,309
sort of python land and we'd be

00:19:16,440 --> 00:19:19,350
different depending on which language

00:19:17,309 --> 00:19:23,159
you're using but now we're passing into

00:19:19,350 --> 00:19:25,769
this common core piece of the of the

00:19:23,159 --> 00:19:26,880
system that Deana described before and

00:19:25,769 --> 00:19:28,860
so looking at this function it's

00:19:26,880 --> 00:19:32,460
actually relatively simple it it's

00:19:28,860 --> 00:19:34,500
essentially passing along the publisher

00:19:32,460 --> 00:19:36,570
object and the message the user wanted

00:19:34,500 --> 00:19:38,789
to publish and passing that along to the

00:19:36,570 --> 00:19:40,350
next interface and so I want to stop

00:19:38,789 --> 00:19:41,639
here for a second you might be asking

00:19:40,350 --> 00:19:42,779
yourself well it seems like we have a

00:19:41,639 --> 00:19:44,100
lot of redundant interfaces as you're

00:19:42,779 --> 00:19:45,450
passing through

00:19:44,100 --> 00:19:47,400
and for publisher it's it's a pretty

00:19:45,450 --> 00:19:49,200
straightforward thing it's a concept

00:19:47,400 --> 00:19:51,870
that exists at every layer of the system

00:19:49,200 --> 00:19:54,030
if you took a more complicated concept

00:19:51,870 --> 00:19:57,419
like parameters for example parameters

00:19:54,030 --> 00:19:59,400
might be represented in RCL pie and RCL

00:19:57,419 --> 00:20:01,230
but wouldn't necessarily be represented

00:19:59,400 --> 00:20:04,320
in an arm W it would be built on top of

00:20:01,230 --> 00:20:07,169
the other primitive middleware concepts

00:20:04,320 --> 00:20:09,780
like publish/subscribe or services and

00:20:07,169 --> 00:20:11,789
so the other reason to have this code

00:20:09,780 --> 00:20:13,350
here is that if we want us to do

00:20:11,789 --> 00:20:15,000
something like collect statistics while

00:20:13,350 --> 00:20:17,130
publishing like how much bandwidth we're

00:20:15,000 --> 00:20:18,390
using and how big how often the messages

00:20:17,130 --> 00:20:20,490
are being published and things like that

00:20:18,390 --> 00:20:22,080
this is an ideal place to do it because

00:20:20,490 --> 00:20:23,730
if it were higher up in the language

00:20:22,080 --> 00:20:25,080
you'd have to do that for every single

00:20:23,730 --> 00:20:26,460
language programming language you want

00:20:25,080 --> 00:20:28,710
an implement have you pushed it down

00:20:26,460 --> 00:20:30,870
then it would be have to be implement

00:20:28,710 --> 00:20:33,179
for every single DDS vendor you wanted

00:20:30,870 --> 00:20:35,010
to back the system and so that's where

00:20:33,179 --> 00:20:36,690
that's why the RCL is sort of the sweet

00:20:35,010 --> 00:20:38,820
spot for you want to push as much code

00:20:36,690 --> 00:20:40,650
there as possible and behavior to

00:20:38,820 --> 00:20:42,960
prevent from having to reproduce it in

00:20:40,650 --> 00:20:45,150
multiple places and increases the chance

00:20:42,960 --> 00:20:47,700
that that there's a bug in multiple

00:20:45,150 --> 00:20:49,940
places or or you have to update multiple

00:20:47,700 --> 00:20:52,799
places when you want to change something

00:20:49,940 --> 00:20:54,419
and so this arm W that we've been

00:20:52,799 --> 00:20:56,820
talking about it's essentially just a

00:20:54,419 --> 00:20:58,919
set of headers with which to find some

00:20:56,820 --> 00:21:00,929
functions and some types it's actually

00:20:58,919 --> 00:21:03,090
not the actual implementation and so

00:21:00,929 --> 00:21:04,530
here it's really simple it just takes a

00:21:03,090 --> 00:21:08,309
publisher and a message and returns a

00:21:04,530 --> 00:21:10,860
return code and it's in C and then under

00:21:08,309 --> 00:21:12,510
that there's a DDS implement sorry

00:21:10,860 --> 00:21:14,760
there's an arm W implementation is what

00:21:12,510 --> 00:21:16,200
we refer to it as and that is that

00:21:14,760 --> 00:21:18,480
adapter that Deanna was talking about

00:21:16,200 --> 00:21:20,549
which adapts the DDS vendor at the very

00:21:18,480 --> 00:21:22,110
bottom which actually does the work to

00:21:20,549 --> 00:21:24,270
this interface we've defined that's got

00:21:22,110 --> 00:21:27,000
this primitive you know minimal set of

00:21:24,270 --> 00:21:29,250
things in it and so in a particular case

00:21:27,000 --> 00:21:31,950
if you're using fast R TPS you would be

00:21:29,250 --> 00:21:34,289
using fast R TPS in those DDS vendor

00:21:31,950 --> 00:21:37,260
boxes and you'd be using our adapter for

00:21:34,289 --> 00:21:38,789
that which a person who helped us a

00:21:37,260 --> 00:21:41,370
great deal with and actually started

00:21:38,789 --> 00:21:43,919
which is the arm W fast RT PSC VP and

00:21:41,370 --> 00:21:45,780
that's the code that maps from our

00:21:43,919 --> 00:21:50,280
concepts to the underlying systems

00:21:45,780 --> 00:21:54,390
concepts and so taking a look at

00:21:50,280 --> 00:21:56,940
particularly the case of fast RT PS you

00:21:54,390 --> 00:21:57,190
have the implementation of this function

00:21:56,940 --> 00:22:00,430
that we

00:21:57,190 --> 00:22:01,450
to find in the interface and you can see

00:22:00,430 --> 00:22:07,030
here we're doing some stuff like

00:22:01,450 --> 00:22:08,830
creating a a serializer and and then

00:22:07,030 --> 00:22:10,360
we're using that serializer and the

00:22:08,830 --> 00:22:12,100
message the user gave us which is a Ross

00:22:10,360 --> 00:22:13,030
message just serialize it to the wire

00:22:12,100 --> 00:22:15,520
format

00:22:13,030 --> 00:22:18,850
it's a Marshall it and then finally we

00:22:15,520 --> 00:22:21,580
call the fast start EPS publish call

00:22:18,850 --> 00:22:23,590
this is a bit a lot of the details are

00:22:21,580 --> 00:22:25,740
hidden here because a lot of little

00:22:23,590 --> 00:22:27,850
moving pieces but essentially we're

00:22:25,740 --> 00:22:30,010
sterilizing it and then actually calling

00:22:27,850 --> 00:22:31,780
publish to send it to the wire and then

00:22:30,010 --> 00:22:35,350
of course our hello world message is now

00:22:31,780 --> 00:22:36,760
been sent over to the middle here and at

00:22:35,350 --> 00:22:38,650
this point I want to talk a little bit

00:22:36,760 --> 00:22:40,090
about the listener so it's always sort

00:22:38,650 --> 00:22:42,130
of hard to describe these situations

00:22:40,090 --> 00:22:45,550
because you've got two concurrent

00:22:42,130 --> 00:22:46,660
systems running but the whole time the

00:22:45,550 --> 00:22:48,970
talker was running we were also learning

00:22:46,660 --> 00:22:50,830
the listener and again this one so this

00:22:48,970 --> 00:22:52,840
is an example in C++ but again it should

00:22:50,830 --> 00:22:56,860
be relatively familiar if you've done

00:22:52,840 --> 00:22:59,310
the Ross cpp lost one tutorials we're

00:22:56,860 --> 00:23:01,330
doing things like creating a node

00:22:59,310 --> 00:23:04,180
creating a subscription on the chatter

00:23:01,330 --> 00:23:06,160
topic where we pass it a callback to get

00:23:04,180 --> 00:23:09,550
called when new data comes in and we're

00:23:06,160 --> 00:23:13,150
calling spin eventually and most of this

00:23:09,550 --> 00:23:15,460
work is broken sorry there's supposed to

00:23:13,150 --> 00:23:18,100
be an arrow a box surrounding spin that

00:23:15,460 --> 00:23:20,140
points to this this box most of the work

00:23:18,100 --> 00:23:21,190
is happening in this spin function so

00:23:20,140 --> 00:23:23,080
everything that happens up to that is

00:23:21,190 --> 00:23:24,640
just setting up and then you'll hear in

00:23:23,080 --> 00:23:26,800
your programs lesson most of its time in

00:23:24,640 --> 00:23:30,280
the spin function and so if we look at

00:23:26,800 --> 00:23:33,070
what that spin function does it

00:23:30,280 --> 00:23:36,790
basically sits and does a non-blocking

00:23:33,070 --> 00:23:38,490
we're sorry it does a non busy wait so

00:23:36,790 --> 00:23:40,510
it waits for data in an efficient way

00:23:38,490 --> 00:23:43,800
waits for something to happen in the

00:23:40,510 --> 00:23:46,180
system and so once we got our message

00:23:43,800 --> 00:23:48,340
from the publisher into the middle where

00:23:46,180 --> 00:23:52,780
there's an event that wakes up that

00:23:48,340 --> 00:23:55,090
waiting and so now now our spin function

00:23:52,780 --> 00:23:57,310
knows that data has been delivered and

00:23:55,090 --> 00:23:58,810
so it needs to get that data out of the

00:23:57,310 --> 00:24:01,120
middleware and give it to the users

00:23:58,810 --> 00:24:02,560
callback and so basically it checks to

00:24:01,120 --> 00:24:05,350
make sure that the subscription has data

00:24:02,560 --> 00:24:08,170
if it does then it calls this execute

00:24:05,350 --> 00:24:10,790
subscription function this executes

00:24:08,170 --> 00:24:13,760
subscription function

00:24:10,790 --> 00:24:15,380
is a bit it looks a bit complicated with

00:24:13,760 --> 00:24:16,940
all the names faces and template

00:24:15,380 --> 00:24:19,460
arguments and stuff but essentially

00:24:16,940 --> 00:24:20,660
what's happening here is that the system

00:24:19,460 --> 00:24:22,580
is already determined this subscription

00:24:20,660 --> 00:24:24,320
has data available on it and so it's

00:24:22,580 --> 00:24:28,580
creating a message to store the result

00:24:24,320 --> 00:24:31,820
in and it's calling the next layer the

00:24:28,580 --> 00:24:34,670
RCL layer it's calling take and this is

00:24:31,820 --> 00:24:36,050
the function you call when you know that

00:24:34,670 --> 00:24:37,910
the system has data available for you

00:24:36,050 --> 00:24:42,680
you can take it out of their their

00:24:37,910 --> 00:24:44,510
buffers and so so basically were passing

00:24:42,680 --> 00:24:47,020
this message to store the data in and

00:24:44,510 --> 00:24:50,450
the subscription to to the RCL level

00:24:47,020 --> 00:24:52,460
very similar to the publisher side of

00:24:50,450 --> 00:24:54,560
things and again we've just sorry we

00:24:52,460 --> 00:24:56,630
back up again we've just passed across

00:24:54,560 --> 00:24:58,370
the language specific barrier so now

00:24:56,630 --> 00:25:00,380
we've left c++ and we're going into this

00:24:58,370 --> 00:25:02,210
common core so if we were to look at a

00:25:00,380 --> 00:25:06,440
listener written in Python we would now

00:25:02,210 --> 00:25:09,260
be at the same place and so again just

00:25:06,440 --> 00:25:10,460
like in the RCL publish function on the

00:25:09,260 --> 00:25:12,380
other side this is a relatively simple

00:25:10,460 --> 00:25:15,950
function where we're passing directly

00:25:12,380 --> 00:25:17,690
down to arm W take but again it would

00:25:15,950 --> 00:25:20,090
also be an opportunity and this in this

00:25:17,690 --> 00:25:21,410
place to do things like collect

00:25:20,090 --> 00:25:23,120
statistics or if you want to do

00:25:21,410 --> 00:25:25,130
something like topic aliasing where

00:25:23,120 --> 00:25:26,300
you're you know you're telling it I'm

00:25:25,130 --> 00:25:28,010
publishing on this topic but also

00:25:26,300 --> 00:25:31,820
publish it to this other topic you might

00:25:28,010 --> 00:25:33,920
handle that kind of logic here and so

00:25:31,820 --> 00:25:36,770
here basically we're again we're passing

00:25:33,920 --> 00:25:41,000
the the subscription down and the

00:25:36,770 --> 00:25:42,950
message down and again the arm W

00:25:41,000 --> 00:25:45,020
interface is just a header it's just a

00:25:42,950 --> 00:25:47,000
definition the actual work is happening

00:25:45,020 --> 00:25:49,610
in this adapter code for a fast R TPS

00:25:47,000 --> 00:25:52,400
and here you can see that we're creating

00:25:49,610 --> 00:25:53,990
a buffer to store the data and

00:25:52,400 --> 00:25:55,520
temporarily and this is like the binary

00:25:53,990 --> 00:25:57,710
this is still serialized

00:25:55,520 --> 00:26:00,230
and so we take it from faster our TPS

00:25:57,710 --> 00:26:02,960
this is the this line here is the line

00:26:00,230 --> 00:26:05,600
where we actually take the data from

00:26:02,960 --> 00:26:07,760
from fast R TPS and then we check to

00:26:05,600 --> 00:26:09,830
make sure it was actually contains data

00:26:07,760 --> 00:26:14,150
and then if it does we D serialize it

00:26:09,830 --> 00:26:16,010
and set taken to true and at this point

00:26:14,150 --> 00:26:19,580
this is where we come back up the step

00:26:16,010 --> 00:26:20,960
stack so essentially we we've taken the

00:26:19,580 --> 00:26:23,360
data and deserialized it and then it

00:26:20,960 --> 00:26:24,530
returns back up this this what we just

00:26:23,360 --> 00:26:27,350
drilled down and eventually

00:26:24,530 --> 00:26:31,130
delivered to the users callback but you

00:26:27,350 --> 00:26:33,290
can see that you know the point the

00:26:31,130 --> 00:26:35,810
point to drive home here is that we're

00:26:33,290 --> 00:26:41,570
sharing a lot of code between the two

00:26:35,810 --> 00:26:42,890
languages and we're also trying to like

00:26:41,570 --> 00:26:44,390
Deanna said smooth out the differences

00:26:42,890 --> 00:26:48,320
between underlying vendors by having a

00:26:44,390 --> 00:26:52,760
really simple but well-defined interface

00:26:48,320 --> 00:26:54,710
in the rmw interface and last thing

00:26:52,760 --> 00:26:58,070
we're going to talk about is we did do

00:26:54,710 --> 00:26:59,870
some work since the last year just sort

00:26:58,070 --> 00:27:02,990
of for fun and to see where we were at

00:26:59,870 --> 00:27:04,040
and to you know to play with real robots

00:27:02,990 --> 00:27:05,630
once in a while because we don't get to

00:27:04,040 --> 00:27:09,230
do that as often as you like and we

00:27:05,630 --> 00:27:11,510
wanted to port some minimal viable demo

00:27:09,230 --> 00:27:15,110
of the turtle bot to running on Ross -

00:27:11,510 --> 00:27:17,660
and so what we defined is that is a

00:27:15,110 --> 00:27:19,730
kabuki driver which is the if you're not

00:27:17,660 --> 00:27:21,560
familiar with the turtle bot - it's the

00:27:19,730 --> 00:27:24,260
black disk robot that's at the very

00:27:21,560 --> 00:27:28,910
bottom of the stack it's made by eugen

00:27:24,260 --> 00:27:30,620
and we also needed a driver for a depth

00:27:28,910 --> 00:27:34,130
sensor in this case we were trying out

00:27:30,620 --> 00:27:37,340
the Orbach Astro driver or or back Astro

00:27:34,130 --> 00:27:39,410
camera and we needed a joystick driver

00:27:37,340 --> 00:27:40,730
to test out driving it around and we

00:27:39,410 --> 00:27:42,050
wanted to implement the follower node

00:27:40,730 --> 00:27:43,790
and again for those who are not familiar

00:27:42,050 --> 00:27:45,710
with the turtle bot demos the follower

00:27:43,790 --> 00:27:47,180
node is just a program that reads data

00:27:45,710 --> 00:27:48,920
from the sensor and then uses that data

00:27:47,180 --> 00:27:57,110
to try to follow you around with the

00:27:48,920 --> 00:27:58,490
turtle bot yeah so the way we we ended

00:27:57,110 --> 00:28:00,740
up doing this so this slide is basically

00:27:58,490 --> 00:28:01,940
how we ended up and then I'm gonna go

00:28:00,740 --> 00:28:04,370
into a little detail about other things

00:28:01,940 --> 00:28:06,410
that we tried for the Kabuki for the

00:28:04,370 --> 00:28:07,970
Kabuki driver it's actually a really

00:28:06,410 --> 00:28:10,550
modular set of software there's quite a

00:28:07,970 --> 00:28:13,940
lot of packages that are under the the

00:28:10,550 --> 00:28:16,340
kabuki driver and Ross one but it turns

00:28:13,940 --> 00:28:17,930
out that it was designed quite well and

00:28:16,340 --> 00:28:21,170
the vast majority of the code is not

00:28:17,930 --> 00:28:25,070
specific to Ross CPP the actual no

00:28:21,170 --> 00:28:27,500
network part of Ross one and so all we

00:28:25,070 --> 00:28:30,380
had to do is install the Debian packages

00:28:27,500 --> 00:28:31,730
for the dependencies of that like all

00:28:30,380 --> 00:28:32,990
the code that actually talks to the

00:28:31,730 --> 00:28:34,340
Kabuki and does all the hardware

00:28:32,990 --> 00:28:36,870
communication and stuff like that and

00:28:34,340 --> 00:28:41,490
then we wrote a very thin Ross to wrap

00:28:36,870 --> 00:28:44,190
on top of that for the Astra we ended up

00:28:41,490 --> 00:28:46,020
taking the Ross one driver

00:28:44,190 --> 00:28:47,309
it wasn't separated in the same way and

00:28:46,020 --> 00:28:49,170
I don't think it necessarily made sense

00:28:47,309 --> 00:28:51,180
for it to be separating the same way but

00:28:49,170 --> 00:28:52,980
for better or worse it wasn't and so we

00:28:51,180 --> 00:28:55,500
ended up forking that and porting it by

00:28:52,980 --> 00:28:57,120
hand or Ross two for the joystick driver

00:28:55,500 --> 00:28:59,160
that was really simple so we we just

00:28:57,120 --> 00:29:01,740
rode that one from scratch and for the

00:28:59,160 --> 00:29:04,680
follower demo follower node we also

00:29:01,740 --> 00:29:06,210
forked and ported that one and then any

00:29:04,680 --> 00:29:08,670
time we needed debugging or

00:29:06,210 --> 00:29:10,260
visualization we'd use the Ross flow and

00:29:08,670 --> 00:29:11,580
Ross to bridge which I won't go into

00:29:10,260 --> 00:29:13,200
much detail here we talked about in

00:29:11,580 --> 00:29:15,179
previous Ross con talks so if you're

00:29:13,200 --> 00:29:18,450
interested in that there's a demo on our

00:29:15,179 --> 00:29:20,130
tutorials and demos on our wiki and

00:29:18,450 --> 00:29:23,580
there's also a bunch of stuff about it

00:29:20,130 --> 00:29:25,290
in previous talks but I also wanted to

00:29:23,580 --> 00:29:28,200
talk so you can see here mostly what we

00:29:25,290 --> 00:29:29,670
did was just replace the Ross 1 code

00:29:28,200 --> 00:29:31,980
with Ross two code but we did try some

00:29:29,670 --> 00:29:33,630
other things and I think what really

00:29:31,980 --> 00:29:36,360
what came down to is that most of these

00:29:33,630 --> 00:29:38,400
examples were either really simple or

00:29:36,360 --> 00:29:40,590
trivial to convert so it wasn't worth

00:29:38,400 --> 00:29:42,780
like using some abstraction to do the

00:29:40,590 --> 00:29:44,370
conversion or they were very complicated

00:29:42,780 --> 00:29:46,920
and we didn't have time to make an

00:29:44,370 --> 00:29:48,330
abstraction that was good enough so one

00:29:46,920 --> 00:29:50,340
of the things we tried was a shim and we

00:29:48,330 --> 00:29:53,640
talked about this in the past and what I

00:29:50,340 --> 00:29:56,100
mean by a shim is the idea that you have

00:29:53,640 --> 00:30:00,900
some code that uses the Ross one API

00:29:56,100 --> 00:30:02,520
maybe in C++ for example and the shims

00:30:00,900 --> 00:30:04,770
purpose would be to present that same

00:30:02,520 --> 00:30:06,690
API to your code but be implemented by

00:30:04,770 --> 00:30:08,400
Ross - under the hood so ideally all

00:30:06,690 --> 00:30:10,200
you'd have to do is with some different

00:30:08,400 --> 00:30:13,140
build configurations recompile your code

00:30:10,200 --> 00:30:15,870
and it would just work with minimal to

00:30:13,140 --> 00:30:18,540
no changes we tried this and a lot of

00:30:15,870 --> 00:30:21,390
things worked it's there's a all of the

00:30:18,540 --> 00:30:23,730
stuff we did on it is on my colleague

00:30:21,390 --> 00:30:29,460
Morgan's github account which I've

00:30:23,730 --> 00:30:35,220
linked here and it worked for the simple

00:30:29,460 --> 00:30:36,750
cases but it also with with particular

00:30:35,220 --> 00:30:38,309
with the case of the Astro driver it

00:30:36,750 --> 00:30:40,860
used a lot of really advanced

00:30:38,309 --> 00:30:43,559
functionality in Ross one like custom

00:30:40,860 --> 00:30:46,260
serialization of message types made use

00:30:43,559 --> 00:30:48,179
of other parts of the system that were

00:30:46,260 --> 00:30:50,610
part of Ross one but not what you

00:30:48,179 --> 00:30:52,830
consider part of Ross CPP things like in

00:30:50,610 --> 00:30:55,650
transport and message filters and TF and

00:30:52,830 --> 00:30:56,790
stuff like that and so one of the

00:30:55,650 --> 00:30:59,880
problems we had was finding the right

00:30:56,790 --> 00:31:01,110
what I used the word strata which I

00:30:59,880 --> 00:31:03,600
tried to explain a little bit with this

00:31:01,110 --> 00:31:06,030
diagram find the right strata in which

00:31:03,600 --> 00:31:10,440
to put put the shim so you can imagine

00:31:06,030 --> 00:31:12,720
you could only shim the ross sea ppapi

00:31:10,440 --> 00:31:15,059
but then you have a choice of do you

00:31:12,720 --> 00:31:17,280
bring all of message filters in all of

00:31:15,059 --> 00:31:19,260
TF from ross one and put that on top or

00:31:17,280 --> 00:31:22,340
you know another option would be we have

00:31:19,260 --> 00:31:24,990
TF ported to ross - would you instead

00:31:22,340 --> 00:31:28,049
provide a shim for the TF api and use

00:31:24,990 --> 00:31:30,360
the ross - version of TF under it and so

00:31:28,049 --> 00:31:31,860
you have a little bit of a choice as

00:31:30,360 --> 00:31:34,020
where to draw this line and it wasn't

00:31:31,860 --> 00:31:34,919
clear to us where that line should go

00:31:34,020 --> 00:31:36,780
just yet

00:31:34,919 --> 00:31:37,860
but we have been been working on it and

00:31:36,780 --> 00:31:42,270
be interesting to see what other people

00:31:37,860 --> 00:31:43,890
thought about that and so ultimately the

00:31:42,270 --> 00:31:47,100
Astra driver needed so many features

00:31:43,890 --> 00:31:50,490
that it was we couldn't make a shim that

00:31:47,100 --> 00:31:52,500
was complete enough to really we just

00:31:50,490 --> 00:31:54,059
recompile with no changes it did work

00:31:52,500 --> 00:31:55,290
for some pretty simple things like the

00:31:54,059 --> 00:31:58,080
joystick driver probably would've works

00:31:55,290 --> 00:31:59,010
and stuff like that the other thing that

00:31:58,080 --> 00:32:01,350
I know there's been a lot of

00:31:59,010 --> 00:32:02,640
consternation about is we've made some

00:32:01,350 --> 00:32:04,710
changes to the build system in Ross -

00:32:02,640 --> 00:32:06,720
which are different from Ross one and so

00:32:04,710 --> 00:32:08,610
we're trying to find ways to minimize

00:32:06,720 --> 00:32:11,429
that change or to eliminate altogether

00:32:08,610 --> 00:32:14,100
if possible or at least give choice

00:32:11,429 --> 00:32:18,299
between the two if you're uninterested

00:32:14,100 --> 00:32:20,120
in the changes in the new one so I think

00:32:18,299 --> 00:32:22,140
this particularly came up when Brian was

00:32:20,120 --> 00:32:23,900
trying to convert the kabuki stack

00:32:22,140 --> 00:32:26,220
because I had lots of cackling packages

00:32:23,900 --> 00:32:27,929
in the end he ended up just using the

00:32:26,220 --> 00:32:29,429
cat can package 'iz as a dependency and

00:32:27,929 --> 00:32:31,669
building a very small thing on top of

00:32:29,429 --> 00:32:35,820
that that was Ross - but in the meantime

00:32:31,669 --> 00:32:37,080
he wrote quite a bunch of documentation

00:32:35,820 --> 00:32:38,820
about his thoughts about this on our

00:32:37,080 --> 00:32:41,460
wiki so if you're interested in that I

00:32:38,820 --> 00:32:43,230
recommend you have a look at it but just

00:32:41,460 --> 00:32:45,059
to summarize some of that we wanted to

00:32:43,230 --> 00:32:47,400
try find ways to make the two systems

00:32:45,059 --> 00:32:49,890
more similar ways that we might be able

00:32:47,400 --> 00:32:51,450
to change cat can to be more to have

00:32:49,890 --> 00:32:53,040
some of the features of mint or change a

00:32:51,450 --> 00:32:55,080
mint to be more like a cocoon where the

00:32:53,040 --> 00:32:59,700
changes we have exist or currently or

00:32:55,080 --> 00:33:01,530
may be unnecessary or only aesthetic we

00:32:59,700 --> 00:33:02,850
also wanted to make sure we can mix

00:33:01,530 --> 00:33:04,170
catkin in a mint and that's what I was

00:33:02,850 --> 00:33:05,040
talking about before

00:33:04,170 --> 00:33:07,560
and that's what we ended up doing

00:33:05,040 --> 00:33:09,840
actually for the Kabuki base because the

00:33:07,560 --> 00:33:11,790
all the packages that actually talked to

00:33:09,840 --> 00:33:13,980
the hardware of the Kabuki are in catkin

00:33:11,790 --> 00:33:15,720
and the thing that Brian wrote as the

00:33:13,980 --> 00:33:19,290
small Ross to rapid on top of that is

00:33:15,720 --> 00:33:20,430
using a mint and so unlike if people are

00:33:19,290 --> 00:33:21,420
familiar with the transition from

00:33:20,430 --> 00:33:23,490
Rossville to catkin

00:33:21,420 --> 00:33:25,020
there was this rule where Ross build

00:33:23,490 --> 00:33:26,730
could depend on catkin but not the other

00:33:25,020 --> 00:33:29,880
way around and that caused sort of like

00:33:26,730 --> 00:33:31,650
a forced migration in this case you

00:33:29,880 --> 00:33:33,480
shouldn't have any constraint like that

00:33:31,650 --> 00:33:35,010
it would be cat can can use a mint and

00:33:33,480 --> 00:33:38,220
can use calculus at the base of it

00:33:35,010 --> 00:33:39,870
they're both just see make and so it

00:33:38,220 --> 00:33:42,660
should be easier to mix and match them

00:33:39,870 --> 00:33:48,030
in the transition and then in the near

00:33:42,660 --> 00:33:50,910
term we also talked about our thoughts

00:33:48,030 --> 00:33:52,830
about this idea of a non-homogeneous

00:33:50,910 --> 00:33:57,510
workspace so already in Ross one you can

00:33:52,830 --> 00:33:59,640
have a build which has both cat cam

00:33:57,510 --> 00:34:02,370
packages and planes he make packages if

00:33:59,640 --> 00:34:03,990
you like and this would just be an

00:34:02,370 --> 00:34:05,640
extension to that where you have CAC and

00:34:03,990 --> 00:34:07,860
packages plane so you make packages and

00:34:05,640 --> 00:34:09,390
then maybe a mint packages or maybe pure

00:34:07,860 --> 00:34:11,340
Python packages which is something else

00:34:09,390 --> 00:34:12,780
we have in Ross too that doesn't have

00:34:11,340 --> 00:34:14,970
that we don't have right now in Ross one

00:34:12,780 --> 00:34:17,100
and then of course ideally we just have

00:34:14,970 --> 00:34:17,730
one build tool that works on both of

00:34:17,100 --> 00:34:20,210
them so you don't have to learn

00:34:17,730 --> 00:34:22,440
different tools for different systems

00:34:20,210 --> 00:34:24,720
there are some conceptual details we

00:34:22,440 --> 00:34:26,280
need to figure out but I think you know

00:34:24,720 --> 00:34:28,350
we're trying to think about them early

00:34:26,280 --> 00:34:30,720
and often and figure out ways to to deal

00:34:28,350 --> 00:34:32,669
with them for example some some people

00:34:30,720 --> 00:34:36,210
will be familiar with the fact that the

00:34:32,669 --> 00:34:38,640
cat can will always produce a setup file

00:34:36,210 --> 00:34:40,050
in your wherever you install your code

00:34:38,640 --> 00:34:41,280
to that's really convenient as a

00:34:40,050 --> 00:34:42,540
developer because you just source that

00:34:41,280 --> 00:34:44,190
and it set your environment up with the

00:34:42,540 --> 00:34:47,310
right path and library path and all that

00:34:44,190 --> 00:34:48,390
stuff but for things like packaging and

00:34:47,310 --> 00:34:51,690
stuff like that it's sort of a

00:34:48,390 --> 00:34:53,370
non-standard pattern in a mint it's

00:34:51,690 --> 00:34:55,200
completely optional every package

00:34:53,370 --> 00:34:57,090
installs its own setup file and its

00:34:55,200 --> 00:34:58,530
share folder so it's sort of insulated

00:34:57,090 --> 00:35:00,900
and isolated from the rest of your

00:34:58,530 --> 00:35:02,790
packages you've installed to the your

00:35:00,900 --> 00:35:06,540
installed destination which should also

00:35:02,790 --> 00:35:08,280
make it easier to to release it for

00:35:06,540 --> 00:35:09,540
debian for example if you installed a

00:35:08,280 --> 00:35:12,170
user they have rules against where you

00:35:09,540 --> 00:35:14,130
can put files and things like that and

00:35:12,170 --> 00:35:15,450
so one of the things we're thinking

00:35:14,130 --> 00:35:17,430
about is trying to figure out how to

00:35:15,450 --> 00:35:18,780
make it optional for catkin

00:35:17,430 --> 00:35:20,690
not make it inconvenient for people

00:35:18,780 --> 00:35:23,640
currently using it and stuff like that

00:35:20,690 --> 00:35:25,410
also the devel space so the devel space

00:35:23,640 --> 00:35:27,690
is something that was I think provides a

00:35:25,410 --> 00:35:30,000
good deal of utility for people first at

00:35:27,690 --> 00:35:32,309
least for some developers that want to

00:35:30,000 --> 00:35:37,470
have a really quick build compile

00:35:32,309 --> 00:35:39,900
compile test change cycle but

00:35:37,470 --> 00:35:41,970
unfortunately it has it adds a lot of

00:35:39,900 --> 00:35:43,440
complexity to khaki and I'd say almost

00:35:41,970 --> 00:35:44,760
half the code is dealing with the

00:35:43,440 --> 00:35:46,829
difference in develop a sand install

00:35:44,760 --> 00:35:48,329
space and so in a minute we wanted to

00:35:46,829 --> 00:35:50,640
try something different and this is a

00:35:48,329 --> 00:35:53,130
really this is a good reason in my mind

00:35:50,640 --> 00:35:54,750
too we had the freedom to change things

00:35:53,130 --> 00:35:55,140
as we saw fit to see what works and what

00:35:54,750 --> 00:35:57,359
doesn't

00:35:55,140 --> 00:35:59,400
we have what we call assembly install so

00:35:57,359 --> 00:36:00,809
basically it does the normal see make

00:35:59,400 --> 00:36:02,730
install step but rather than copying

00:36:00,809 --> 00:36:04,230
files at symlinks them and so you get

00:36:02,730 --> 00:36:07,109
sort of the benefit of the devel space

00:36:04,230 --> 00:36:08,760
without having this extra concept that's

00:36:07,109 --> 00:36:12,530
unfamiliar to other see make developers

00:36:08,760 --> 00:36:16,140
and most developers in general and so

00:36:12,530 --> 00:36:18,390
perhaps one option is to back port this

00:36:16,140 --> 00:36:20,190
symlink install feature to catkin

00:36:18,390 --> 00:36:22,530
you know but but it's an open question

00:36:20,190 --> 00:36:25,109
about how to deal with that discrepancy

00:36:22,530 --> 00:36:27,059
in the tools and stuff like that and of

00:36:25,109 --> 00:36:28,500
course avoiding documentation community

00:36:27,059 --> 00:36:31,589
and stuff like that and tutorials and

00:36:28,500 --> 00:36:33,599
knowing which to use when and what the

00:36:31,589 --> 00:36:34,950
ultimate goal of you know taking the

00:36:33,599 --> 00:36:36,390
things we found that work really well in

00:36:34,950 --> 00:36:38,130
a mint and try and make catkin more like

00:36:36,390 --> 00:36:40,170
a mint and vice versa and try to

00:36:38,130 --> 00:36:43,140
eventually ideally we'd eliminate any of

00:36:40,170 --> 00:36:44,369
the differences but what does have to

00:36:43,140 --> 00:36:45,930
see how that goes but we are looking

00:36:44,369 --> 00:36:48,180
into it I don't have any definitive

00:36:45,930 --> 00:36:50,250
conclusions like to tell you you know oh

00:36:48,180 --> 00:36:52,380
if you're gonna try Ross to and want to

00:36:50,250 --> 00:36:53,730
pour some beer offs one code the truth

00:36:52,380 --> 00:36:55,319
is there's a lot of different options it

00:36:53,730 --> 00:36:56,790
depends on the code you're converting

00:36:55,319 --> 00:36:58,680
how complex it is and what its

00:36:56,790 --> 00:37:00,960
dependencies are and what you'd prefer

00:36:58,680 --> 00:37:02,549
to have is the end result so we're still

00:37:00,960 --> 00:37:05,390
sort of exploring all the options and

00:37:02,549 --> 00:37:07,260
trying to support as many as we can

00:37:05,390 --> 00:37:09,720
finally I want to end with the road map

00:37:07,260 --> 00:37:11,549
so we've been telling everyone we're

00:37:09,720 --> 00:37:13,319
gonna have a beta 1 for Ross 2 at the

00:37:11,549 --> 00:37:15,930
end of the year and we're gonna try a

00:37:13,319 --> 00:37:19,260
hold of that like a try we are gonna

00:37:15,930 --> 00:37:21,650
holder that Brian get in trouble with

00:37:19,260 --> 00:37:24,030
Brian if I change it say anything else

00:37:21,650 --> 00:37:28,230
so what we'd like to have for the beta

00:37:24,030 --> 00:37:30,880
is an idea of composition which is if

00:37:28,230 --> 00:37:33,220
you're unfamiliar it's like how

00:37:30,880 --> 00:37:34,450
it's this idea that you can write an ode

00:37:33,220 --> 00:37:35,950
and you can either have in its own

00:37:34,450 --> 00:37:38,050
process or you can combine it with other

00:37:35,950 --> 00:37:40,120
nodes in a single process and that of

00:37:38,050 --> 00:37:43,540
you know that detail should be a runtime

00:37:40,120 --> 00:37:46,630
decision not a not a you know coding

00:37:43,540 --> 00:37:48,250
time decision we want to do some more

00:37:46,630 --> 00:37:49,900
benchmarking we want to improve the

00:37:48,250 --> 00:37:52,480
default behavior you know there's a lot

00:37:49,900 --> 00:37:55,240
of quirkiness still with with our

00:37:52,480 --> 00:37:56,590
default behavior in Ross to about you

00:37:55,240 --> 00:37:58,570
know default quality of service settings

00:37:56,590 --> 00:37:59,950
to default network configurations and

00:37:58,570 --> 00:38:02,950
things like that we want to improve

00:37:59,950 --> 00:38:04,480
those we want to sort of clean up and

00:38:02,950 --> 00:38:05,860
organize our design Docs we have a lot

00:38:04,480 --> 00:38:07,150
of stuff out there but some of it needs

00:38:05,860 --> 00:38:09,460
to be updated and organized

00:38:07,150 --> 00:38:12,010
of course tutorials and examples expand

00:38:09,460 --> 00:38:13,480
on the ones we have and really focus on

00:38:12,010 --> 00:38:16,180
people who want to learn how to use Ross

00:38:13,480 --> 00:38:17,980
to command-line tools we've been working

00:38:16,180 --> 00:38:20,920
on that a little bit and alpha 8 we have

00:38:17,980 --> 00:38:25,150
a very very simple but nonetheless

00:38:20,920 --> 00:38:27,700
exciting ability to Ross topic list and

00:38:25,150 --> 00:38:29,140
echo in Python using Python we finally

00:38:27,700 --> 00:38:30,220
got our Python API to the point where we

00:38:29,140 --> 00:38:32,500
can implement some of these these

00:38:30,220 --> 00:38:34,090
features and of course we want to

00:38:32,500 --> 00:38:36,730
improve the Ross one Ross to bridge by

00:38:34,090 --> 00:38:37,900
adding support for services there's some

00:38:36,730 --> 00:38:40,080
other things we'd really love to do but

00:38:37,900 --> 00:38:42,100
we're gonna see how much time we have

00:38:40,080 --> 00:38:44,440
console logging is one of them another

00:38:42,100 --> 00:38:45,610
one is a higher-level orchestration

00:38:44,440 --> 00:38:47,800
which is sort of related to composition

00:38:45,610 --> 00:38:50,080
but it's more like the functionality of

00:38:47,800 --> 00:38:52,390
Ross launch and then in addition to that

00:38:50,080 --> 00:38:54,160
the ability to verify the system you've

00:38:52,390 --> 00:38:55,510
described makes like it was like an open

00:38:54,160 --> 00:38:57,010
question always with Ross Lynch like I

00:38:55,510 --> 00:39:00,520
ran Ross launch is my system ready and

00:38:57,010 --> 00:39:01,870
you're like maybe you look at a leaf

00:39:00,520 --> 00:39:04,120
topic and hope for the best

00:39:01,870 --> 00:39:06,340
so we'd like to improve on that and some

00:39:04,120 --> 00:39:07,780
dynamic behavior like especially a multi

00:39:06,340 --> 00:39:12,220
robot systems the ability to change

00:39:07,780 --> 00:39:13,870
things at runtime as you know robots

00:39:12,220 --> 00:39:15,600
enter the system or you add a sensor

00:39:13,870 --> 00:39:18,100
dynamically things like that

00:39:15,600 --> 00:39:21,280
we also have some pointers here to some

00:39:18,100 --> 00:39:22,630
documentation to the Ross wiki we have

00:39:21,280 --> 00:39:25,090
some developer Docs that we're working

00:39:22,630 --> 00:39:26,980
on hopefully get a better generated

00:39:25,090 --> 00:39:28,270
polished looking developer Docs but

00:39:26,980 --> 00:39:31,600
we've been working on the content the

00:39:28,270 --> 00:39:34,120
very least and also we have the design

00:39:31,600 --> 00:39:35,680
Docs which we've had for a while now so

00:39:34,120 --> 00:39:39,420
you have a look at those and that will

00:39:35,680 --> 00:39:39,420
take questions for 50 seconds

00:39:53,089 --> 00:39:57,059
I'll make it quick

00:39:54,809 --> 00:39:59,849
so in terms of timeline you've talked

00:39:57,059 --> 00:40:01,170
about when a beta is coming out when do

00:39:59,849 --> 00:40:03,599
those of us who are sort of deploying

00:40:01,170 --> 00:40:08,760
production robots when should we start

00:40:03,599 --> 00:40:10,319
taking this seriously that came off a

00:40:08,760 --> 00:40:12,300
little more hostile than at 7:00 when

00:40:10,319 --> 00:40:14,520
could we start using it the answer is I

00:40:12,300 --> 00:40:16,290
don't know I mean you know for everyone

00:40:14,520 --> 00:40:17,369
out there that does software you know

00:40:16,290 --> 00:40:19,470
development which I'm sure is most

00:40:17,369 --> 00:40:21,930
people out here you know planning is

00:40:19,470 --> 00:40:25,170
very hard the system is also very large

00:40:21,930 --> 00:40:27,750
and our resources fluctuate over time so

00:40:25,170 --> 00:40:28,740
you know if we you know if we get a lot

00:40:27,750 --> 00:40:31,920
more people working on the project

00:40:28,740 --> 00:40:33,750
either at ORF or abroad then potentially

00:40:31,920 --> 00:40:35,309
pretty soon it's alright it's a hard

00:40:33,750 --> 00:40:36,930
thing to answer that's sort of we're

00:40:35,309 --> 00:40:38,430
working as far as we can and when the

00:40:36,930 --> 00:40:41,819
feature sets there that you need that

00:40:38,430 --> 00:40:46,619
maybe you consider doing it thank you

00:40:41,819 --> 00:40:48,809
yep hi guys good work thank you I have

00:40:46,619 --> 00:40:51,869
two two notes and the question one note

00:40:48,809 --> 00:40:54,089
is if you want to do the benchmarking we

00:40:51,869 --> 00:40:56,700
are doing evaluation already my name is

00:40:54,089 --> 00:40:59,099
Adam dubrovsky and my friend and me we

00:40:56,700 --> 00:41:01,609
did the evaluation of roster so we

00:40:59,099 --> 00:41:05,760
should talk in the coffee-break I guess

00:41:01,609 --> 00:41:08,809
so I would like to go to slide 22 for my

00:41:05,760 --> 00:41:12,210
question actually it's concerned with

00:41:08,809 --> 00:41:14,790
abstraction of the DDS because from my

00:41:12,210 --> 00:41:19,170
experience with law student with VDS I

00:41:14,790 --> 00:41:21,930
think it's it's not that easy because

00:41:19,170 --> 00:41:24,690
DDS provides quality of service which is

00:41:21,930 --> 00:41:28,140
the benefit of having it actually if you

00:41:24,690 --> 00:41:30,599
want to abstract DDS from so that the

00:41:28,140 --> 00:41:33,569
ross is agnostic to DDS you're going to

00:41:30,599 --> 00:41:35,579
lose that so as I see it right now rose

00:41:33,569 --> 00:41:39,540
to has like for quality of service

00:41:35,579 --> 00:41:41,040
selected and in my belief this is a very

00:41:39,540 --> 00:41:43,650
small subset of DDS

00:41:41,040 --> 00:41:45,630
so actually what what is your what are

00:41:43,650 --> 00:41:48,799
your plans concerning development at

00:41:45,630 --> 00:41:51,299
extending this available QoS settings

00:41:48,799 --> 00:41:52,380
yeah so let me just make sure the

00:41:51,299 --> 00:41:54,060
question right so base

00:41:52,380 --> 00:41:55,740
we've we've got this abstraction layer

00:41:54,060 --> 00:41:57,300
on top of DDS and part of the problem is

00:41:55,740 --> 00:41:58,980
as DDS has lots of features and we're

00:41:57,300 --> 00:42:00,960
only exposing a small set of them and

00:41:58,980 --> 00:42:03,030
the question is about our plans that's

00:42:00,960 --> 00:42:05,940
right yeah I'm going to extend this

00:42:03,030 --> 00:42:08,060
small set yeah so the first thing we

00:42:05,940 --> 00:42:09,900
wanted to do was try to extend it with

00:42:08,060 --> 00:42:11,640
we wanted to have enough features

00:42:09,900 --> 00:42:13,619
exposed to emulate what we hadn't lost

00:42:11,640 --> 00:42:16,440
one and then maybe just a little bit

00:42:13,619 --> 00:42:17,670
more we do want to include more of the

00:42:16,440 --> 00:42:19,830
quality of service features that are

00:42:17,670 --> 00:42:23,190
available in DDS we just want to find a

00:42:19,830 --> 00:42:24,390
way to do it that doesn't doesn't

00:42:23,190 --> 00:42:27,090
necessarily ties to one way of

00:42:24,390 --> 00:42:28,770
describing those or you know necessarily

00:42:27,090 --> 00:42:30,840
ties us to DDS as you said it's a very

00:42:28,770 --> 00:42:34,740
hard thing to do eventually we'll

00:42:30,840 --> 00:42:39,540
probably end up exposing many or most of

00:42:34,740 --> 00:42:41,640
them the other thing we have which sort

00:42:39,540 --> 00:42:43,320
of our judgment there has to be about

00:42:41,640 --> 00:42:45,630
which features do we think will be

00:42:43,320 --> 00:42:46,860
useful to the majority of users and

00:42:45,630 --> 00:42:49,500
which ones are sort of really niche

00:42:46,860 --> 00:42:50,940
features and one thing we'll have which

00:42:49,500 --> 00:42:52,440
was not in any of the diagrams here but

00:42:50,940 --> 00:42:54,990
is in the developer Doc's we have this

00:42:52,440 --> 00:42:57,240
idea of a package where you can give it

00:42:54,990 --> 00:42:59,070
a Ross thing like a publisher and you

00:42:57,240 --> 00:43:00,600
can get the underlying DDS thing back

00:42:59,070 --> 00:43:01,800
and you can do anything you want to it

00:43:00,600 --> 00:43:03,390
now you have to deal with in

00:43:01,800 --> 00:43:05,490
consequences that come with that but

00:43:03,390 --> 00:43:07,109
that's a way for us who people really

00:43:05,490 --> 00:43:10,710
need a particular feature can get access

00:43:07,109 --> 00:43:12,630
to it without exposing it to everyone or

00:43:10,710 --> 00:43:15,030
requiring it of every underlying DDS

00:43:12,630 --> 00:43:19,050
vendor so yeah but we should definitely

00:43:15,030 --> 00:43:22,230
talk be great to hear at you sex tn9

00:43:19,050 --> 00:43:25,230
William I have one question is there

00:43:22,230 --> 00:43:28,050
raspberry pie implementation on Russell

00:43:25,230 --> 00:43:32,640
and face art EPS is there detail any

00:43:28,050 --> 00:43:34,950
detail and the other is for digital 9ft

00:43:32,640 --> 00:43:38,609
compiled on Raspberry Pi 2 or you use

00:43:34,950 --> 00:43:40,200
course compile I think so the question

00:43:38,609 --> 00:43:42,990
is are there any details about using

00:43:40,200 --> 00:43:46,590
Ross to with fast RT PS on a Raspberry

00:43:42,990 --> 00:43:48,690
Pi yeah yeah I don't know if we've we've

00:43:46,590 --> 00:43:55,859
done open twice but have we done faster

00:43:48,690 --> 00:43:56,160
TPS yet yeah so as far as we know it

00:43:55,859 --> 00:43:57,390
works

00:43:56,160 --> 00:43:59,430
we just haven't documented it yet

00:43:57,390 --> 00:44:01,619
because as I said one of the things we

00:43:59,430 --> 00:44:02,790
did in the last year is you know worked

00:44:01,619 --> 00:44:04,050
with e pro sima to get some of the

00:44:02,790 --> 00:44:06,109
missing features we had so when we

00:44:04,050 --> 00:44:08,700
originally did the Raspberry Pi stuff

00:44:06,109 --> 00:44:10,410
you know fast 30 PS was missing one or

00:44:08,700 --> 00:44:11,940
two features so we we need to open

00:44:10,410 --> 00:44:13,560
splice at the time but I don't see any

00:44:11,940 --> 00:44:15,180
reason why I wouldn't work you had

00:44:13,560 --> 00:44:17,850
another question about compiling maybe

00:44:15,180 --> 00:44:20,070
or not because you comes out at night

00:44:17,850 --> 00:44:24,300
the Raspberry Pi it would take a long

00:44:20,070 --> 00:44:25,950
time yeah yeah yeah so we heard we've

00:44:24,300 --> 00:44:27,960
been trying to get we have a build farm

00:44:25,950 --> 00:44:29,430
to build binary packages and binary

00:44:27,960 --> 00:44:32,130
packages I mean like a tar file with

00:44:29,430 --> 00:44:33,510
everything in it which is pretty

00:44:32,130 --> 00:44:36,780
primitive but it does work pretty well

00:44:33,510 --> 00:44:38,190
and we have some experimental arm jobs

00:44:36,780 --> 00:44:39,510
for that so hopefully you won't have to

00:44:38,190 --> 00:44:41,640
compile it on the Raspberry Pi you can

00:44:39,510 --> 00:44:43,850
just download the binary but I don't

00:44:41,640 --> 00:44:47,210
think quite there yet pretty close so

00:44:43,850 --> 00:44:47,210
okay thank you

00:44:55,770 --> 00:44:57,830

YouTube URL: https://www.youtube.com/watch?v=y5oj4e5ScNg


