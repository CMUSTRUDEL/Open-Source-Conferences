Title: ROSCon 2018 Madrid Launch for ROS 2
Publication date: 2021-03-28
Playlist: ROSCon 2018
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2018 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:06,029
all right cool all right so my name is

00:00:03,060 --> 00:00:07,410
William I worked at open robotics for a

00:00:06,029 --> 00:00:08,849
while now I've been working on the

00:00:07,410 --> 00:00:10,260
launch system for Ross - and I'm gonna

00:00:08,849 --> 00:00:11,059
jump right into it because I only have

00:00:10,260 --> 00:00:15,179
ten minutes

00:00:11,059 --> 00:00:17,070
so obviously when migrating something

00:00:15,179 --> 00:00:18,750
from Ross one to Ross - we want to take

00:00:17,070 --> 00:00:20,250
the opportunity to think about how we

00:00:18,750 --> 00:00:23,609
could do it better what we can improve

00:00:20,250 --> 00:00:26,060
on using our previous experience there's

00:00:23,609 --> 00:00:28,769
just a couple of things here things like

00:00:26,060 --> 00:00:30,720
improving the ability to introspect the

00:00:28,769 --> 00:00:32,579
launch files both for like editing tools

00:00:30,720 --> 00:00:34,829
and also just when you have a really big

00:00:32,579 --> 00:00:37,730
complex launch file for understanding it

00:00:34,829 --> 00:00:41,100
easier we wanted to have more

00:00:37,730 --> 00:00:43,140
reactionary behavior capabilities in

00:00:41,100 --> 00:00:44,670
launch know if you're familiar with the

00:00:43,140 --> 00:00:49,350
Ross launch from Ross one you'll know

00:00:44,670 --> 00:00:52,739
about respawn and required which will

00:00:49,350 --> 00:00:54,149
you know do something when the program

00:00:52,739 --> 00:00:57,629
when you put those settings on it when

00:00:54,149 --> 00:00:59,010
those programs closed there's always

00:00:57,629 --> 00:01:00,989
been people talking about verification

00:00:59,010 --> 00:01:02,699
when I describe launch file and I say

00:01:00,989 --> 00:01:06,450
run how do I know it actually ran that

00:01:02,699 --> 00:01:08,850
thing and also people have lamented over

00:01:06,450 --> 00:01:12,890
the limitations of the markup language

00:01:08,850 --> 00:01:16,770
XML based files and they always ask for

00:01:12,890 --> 00:01:18,030
Python API and I'm not convinced that's

00:01:16,770 --> 00:01:19,350
the best thing for everyone to do all

00:01:18,030 --> 00:01:22,229
the time but we want to have a

00:01:19,350 --> 00:01:24,689
first-class version from the get-go

00:01:22,229 --> 00:01:25,350
there's a lot more stuff that I can't

00:01:24,689 --> 00:01:27,180
cover here

00:01:25,350 --> 00:01:28,829
but there's a pull request for the

00:01:27,180 --> 00:01:30,659
design doc which I if you're interested

00:01:28,829 --> 00:01:33,509
in where launch is going I'd recommend

00:01:30,659 --> 00:01:35,189
getting up to speed on that thing also

00:01:33,509 --> 00:01:38,040
there's some things we have to change

00:01:35,189 --> 00:01:42,210
about launch in Ross - because of the

00:01:38,040 --> 00:01:44,909
way that Ross 2 works so and a lot of

00:01:42,210 --> 00:01:47,520
things in Ross launch in rosslyn assume

00:01:44,909 --> 00:01:50,159
a single node per process which is no

00:01:47,520 --> 00:01:51,840
longer the case in Ross - and so we have

00:01:50,159 --> 00:01:53,430
to make some changes according to that

00:01:51,840 --> 00:01:55,380
we essentially need to know a Ross

00:01:53,430 --> 00:02:00,360
launch needs to know the mapping between

00:01:55,380 --> 00:02:01,950
nodes and processes I think is also

00:02:00,360 --> 00:02:03,390
mentioned before parameters are a bit

00:02:01,950 --> 00:02:05,880
different in Ross - we don't alonger

00:02:03,390 --> 00:02:08,220
have the notion of a

00:02:05,880 --> 00:02:10,200
parameter space we can still have a node

00:02:08,220 --> 00:02:11,700
that you can call the global parameter

00:02:10,200 --> 00:02:15,330
server that anybody can read and write

00:02:11,700 --> 00:02:17,340
to but we don't have a master that holds

00:02:15,330 --> 00:02:19,349
the parameters or anything like that so

00:02:17,340 --> 00:02:20,370
those are things we have to change so

00:02:19,349 --> 00:02:23,250
I'm going to jump directly into some

00:02:20,370 --> 00:02:24,989
examples but a disclaimer these examples

00:02:23,250 --> 00:02:26,790
are using the latest and greatest syntax

00:02:24,989 --> 00:02:28,709
which may not be available in bouncy or

00:02:26,790 --> 00:02:29,790
even on master yet but we're working on

00:02:28,709 --> 00:02:33,230
it I thought it was better to show

00:02:29,790 --> 00:02:41,430
what's going to be as opposed to what is

00:02:33,230 --> 00:02:44,250
so interesting so there's an example

00:02:41,430 --> 00:02:46,590
here this is the simplest example I

00:02:44,250 --> 00:02:49,590
could come up with this is simply runs a

00:02:46,590 --> 00:02:55,110
talker and a listener and you can see

00:02:49,590 --> 00:02:57,120
that it it's it's a Python interface

00:02:55,110 --> 00:02:59,489
there's this convention that if you have

00:02:57,120 --> 00:03:00,599
a file that ends and dot log pi that's

00:02:59,489 --> 00:03:02,880
not a strict requirement that's just a

00:03:00,599 --> 00:03:04,590
convention but if you also have in that

00:03:02,880 --> 00:03:06,569
file a function called generate launch

00:03:04,590 --> 00:03:09,090
description you can just do things like

00:03:06,569 --> 00:03:11,040
Ross to launch package name file name

00:03:09,090 --> 00:03:12,750
and so this is equivalent to what you

00:03:11,040 --> 00:03:13,190
would do if you had an XML file in the

00:03:12,750 --> 00:03:16,140
past

00:03:13,190 --> 00:03:18,510
you can also introspect it by doing - -

00:03:16,140 --> 00:03:21,540
print description but this is the

00:03:18,510 --> 00:03:26,250
absolute simplest version of a launch

00:03:21,540 --> 00:03:27,900
file hello okay and so what is actually

00:03:26,250 --> 00:03:29,280
gonna happen here it should be pretty

00:03:27,900 --> 00:03:30,269
obvious if you're familiar with launch

00:03:29,280 --> 00:03:31,799
it's gonna go out and find the

00:03:30,269 --> 00:03:35,190
executable for these two things and run

00:03:31,799 --> 00:03:37,650
them when you ask it to run will iterate

00:03:35,190 --> 00:03:39,359
on this slightly and will say we want to

00:03:37,650 --> 00:03:42,120
change the names of the nodes that we're

00:03:39,359 --> 00:03:44,040
running so in this case we're still

00:03:42,120 --> 00:03:45,630
finding the talker and listener but

00:03:44,040 --> 00:03:46,980
we're adding a node description and this

00:03:45,630 --> 00:03:48,600
is a bit about what I was talking about

00:03:46,980 --> 00:03:50,519
by needing to provide launch to

00:03:48,600 --> 00:03:52,200
understanding between processes and

00:03:50,519 --> 00:03:54,150
nodes so here we're saying we're running

00:03:52,200 --> 00:03:56,040
two processes and in each of them there

00:03:54,150 --> 00:03:57,810
is a node and I want to change the name

00:03:56,040 --> 00:03:59,639
of it so I'm gonna change the name to my

00:03:57,810 --> 00:04:01,709
talker and my listener and what that

00:03:59,639 --> 00:04:03,389
ends up doing is it runs those programs

00:04:01,709 --> 00:04:05,310
again but this time it passes arguments

00:04:03,389 --> 00:04:08,069
to them to effect the node name for the

00:04:05,310 --> 00:04:09,480
nodes within them so then you might ask

00:04:08,069 --> 00:04:11,400
yourself what happens when you have more

00:04:09,480 --> 00:04:14,850
than one node in the process so here's

00:04:11,400 --> 00:04:15,780
an example of a node or an executable

00:04:14,850 --> 00:04:18,299
that has more than one

00:04:15,780 --> 00:04:21,480
this particular example that I picked

00:04:18,299 --> 00:04:23,280
actually has four nodes in it but in

00:04:21,480 --> 00:04:24,870
this case we'll just want to it also has

00:04:23,280 --> 00:04:26,550
a talker and listener in it and but in

00:04:24,870 --> 00:04:28,530
this case we'll just want to change the

00:04:26,550 --> 00:04:30,600
name of the talker and the listener and

00:04:28,530 --> 00:04:34,169
so here we've got we're gonna run an

00:04:30,600 --> 00:04:35,790
executable and then we're going to tell

00:04:34,169 --> 00:04:37,380
it that there is a talker node that we

00:04:35,790 --> 00:04:38,790
want to change the name of and a

00:04:37,380 --> 00:04:41,070
listener node that we want to change the

00:04:38,790 --> 00:04:43,260
name of and what that ends up doing on

00:04:41,070 --> 00:04:45,450
the command line is calling the

00:04:43,260 --> 00:04:47,460
executable and then passing a very

00:04:45,450 --> 00:04:49,860
similar thing here but it needs to tell

00:04:47,460 --> 00:04:51,330
the executable which node it's talking

00:04:49,860 --> 00:04:53,450
about when it's passing these remapping

00:04:51,330 --> 00:04:56,730
arguments so we say for the listener

00:04:53,450 --> 00:04:58,890
this argument applies so that's that's

00:04:56,730 --> 00:05:00,510
an example of like a fundamental

00:04:58,890 --> 00:05:01,620
relationship between Ross launch and the

00:05:00,510 --> 00:05:06,180
things that's running that has changed

00:05:01,620 --> 00:05:06,690
in Ross too we have this new thing as

00:05:06,180 --> 00:05:09,060
well

00:05:06,690 --> 00:05:10,800
I was not really new but it's a new way

00:05:09,060 --> 00:05:13,530
of doing basically the equivalent of

00:05:10,800 --> 00:05:17,190
not--let's but instead you just create

00:05:13,530 --> 00:05:20,640
nodes and we can load them dynamically

00:05:17,190 --> 00:05:23,660
without any extra work so what happens

00:05:20,640 --> 00:05:27,030
here is we're running this boilerplate

00:05:23,660 --> 00:05:28,680
container process and then we're telling

00:05:27,030 --> 00:05:30,540
launch that we want to run in that

00:05:28,680 --> 00:05:32,760
process we want to run a talker and a

00:05:30,540 --> 00:05:35,070
listener and change some of the settings

00:05:32,760 --> 00:05:36,720
of it and what's going to happen is is

00:05:35,070 --> 00:05:39,840
that this executable is gonna run and

00:05:36,720 --> 00:05:42,300
then based on information given to it

00:05:39,840 --> 00:05:43,919
it's going to go out to the system and

00:05:42,300 --> 00:05:45,630
find where these nodes are usually in

00:05:43,919 --> 00:05:47,490
shared libraries and it's going to

00:05:45,630 --> 00:05:48,930
instantiate both of them in itself and

00:05:47,490 --> 00:05:50,669
then they're gonna share threads and

00:05:48,930 --> 00:05:51,720
other kinds of resources and stuff and

00:05:50,669 --> 00:05:55,020
communicate with each other more

00:05:51,720 --> 00:05:56,820
efficiently another thing that's been

00:05:55,020 --> 00:05:59,100
talked to touched on one of the previous

00:05:56,820 --> 00:06:01,110
talks as well is this idea of a life

00:05:59,100 --> 00:06:02,940
cycle talker and listener and I want to

00:06:01,110 --> 00:06:04,979
use this to illustrate the more

00:06:02,940 --> 00:06:07,560
event-driven nature of launch in this

00:06:04,979 --> 00:06:10,229
new reference implementation that I've

00:06:07,560 --> 00:06:14,729
been working on so we're gonna start out

00:06:10,229 --> 00:06:16,080
by defining a lifecycle node we do need

00:06:14,729 --> 00:06:18,120
to tell launch when a node is a

00:06:16,080 --> 00:06:20,910
lifecycle node and when it isn't so that

00:06:18,120 --> 00:06:22,440
it knows whether or not to expect to be

00:06:20,910 --> 00:06:23,910
able to introspect its state and stuff

00:06:22,440 --> 00:06:25,740
like that

00:06:23,910 --> 00:06:27,930
and then we're gonna say we're gonna run

00:06:25,740 --> 00:06:30,120
an executable that contains that that

00:06:27,930 --> 00:06:31,770
node we described and then where it gets

00:06:30,120 --> 00:06:32,849
interesting and I know there's a lot of

00:06:31,770 --> 00:06:34,470
text on the screen here but I'm gonna

00:06:32,849 --> 00:06:37,590
highlight some things and walk through

00:06:34,470 --> 00:06:38,849
it we can tell launch that we want to do

00:06:37,590 --> 00:06:41,610
something when there's a state

00:06:38,849 --> 00:06:43,280
transition that affects that talker node

00:06:41,610 --> 00:06:45,210
that we described before and

00:06:43,280 --> 00:06:48,000
specifically when it moves into the

00:06:45,210 --> 00:06:50,220
active State and so when that happens we

00:06:48,000 --> 00:06:51,900
want to do two things we want to log a

00:06:50,220 --> 00:06:54,360
nympho message and we want to execute

00:06:51,900 --> 00:06:55,919
another process so in this case we're

00:06:54,360 --> 00:06:58,169
gonna run talker and then we're going to

00:06:55,919 --> 00:07:00,150
wait for talker to get to a certain

00:06:58,169 --> 00:07:02,729
configuration state and then we're gonna

00:07:00,150 --> 00:07:05,280
run the listener which hitherto has been

00:07:02,729 --> 00:07:06,320
pretty difficult to do and launch so

00:07:05,280 --> 00:07:11,479
that's pretty exciting

00:07:06,320 --> 00:07:15,630
I feel like there's a slide missing

00:07:11,479 --> 00:07:16,500
interesting okay but there's a whole

00:07:15,630 --> 00:07:19,289
bunch of things I didn't have time to

00:07:16,500 --> 00:07:21,020
cover there's all the things you like

00:07:19,289 --> 00:07:23,690
about Ross launched from Ross one

00:07:21,020 --> 00:07:25,470
there's substitutions there's arguments

00:07:23,690 --> 00:07:28,110
you can include other launch

00:07:25,470 --> 00:07:30,750
descriptions you can have conditions for

00:07:28,110 --> 00:07:34,229
whether or not processes or groups of

00:07:30,750 --> 00:07:34,949
processes are executed there's a whole

00:07:34,229 --> 00:07:37,409
bunch of new stuff with the

00:07:34,949 --> 00:07:39,240
introspection again I have some links at

00:07:37,409 --> 00:07:41,340
the end if you want to look at those to

00:07:39,240 --> 00:07:42,509
get up to speed on those there's some

00:07:41,340 --> 00:07:44,550
things that are logged a lot of things

00:07:42,509 --> 00:07:46,020
are missing we still don't have a markup

00:07:44,550 --> 00:07:48,330
language representation right now you

00:07:46,020 --> 00:07:51,150
can only wrong right launch descriptions

00:07:48,330 --> 00:07:52,919
as Python files I still personally

00:07:51,150 --> 00:07:57,090
believe it's really important to have a

00:07:52,919 --> 00:07:58,680
static markup language option I even

00:07:57,090 --> 00:08:00,690
would go so far as say it might be the

00:07:58,680 --> 00:08:03,690
default thing people should use in the

00:08:00,690 --> 00:08:05,940
future but we can hopefully if I've done

00:08:03,690 --> 00:08:07,590
my job right build those on top of the

00:08:05,940 --> 00:08:09,930
existing Python API quite easily

00:08:07,590 --> 00:08:11,630
translating from these markup elements

00:08:09,930 --> 00:08:14,880
to the Python code should be pretty

00:08:11,630 --> 00:08:16,590
linear given a lot of thought to

00:08:14,880 --> 00:08:20,729
verification but there's a lot of tools

00:08:16,590 --> 00:08:24,419
that are missing there some of you may

00:08:20,729 --> 00:08:25,830
be familiar with Ross tests and we're

00:08:24,419 --> 00:08:27,389
missing an equivalent to that there's

00:08:25,830 --> 00:08:29,430
been some work done on already but it's

00:08:27,389 --> 00:08:30,780
still evolving and another big one

00:08:29,430 --> 00:08:32,219
that's missing is multi machine launch

00:08:30,780 --> 00:08:33,440
so if you're interested in this topic we

00:08:32,219 --> 00:08:36,289
could use some help

00:08:33,440 --> 00:08:38,870
to fill out these gaps and here's some

00:08:36,289 --> 00:08:56,630
pointers and questions and I almost ran

00:08:38,870 --> 00:08:59,930
out of time well what would it take to

00:08:56,630 --> 00:09:01,280
run Russ one notes using the new Ross

00:08:59,930 --> 00:09:02,930
two logic bring up is that something

00:09:01,280 --> 00:09:05,150
that's tractable at all yeah it's

00:09:02,930 --> 00:09:06,740
totally possible in fact something that

00:09:05,150 --> 00:09:09,650
Ross Lynch from Ross one didn't do very

00:09:06,740 --> 00:09:11,630
well or made it unnecessarily convoluted

00:09:09,650 --> 00:09:13,700
was that an launch there's actually

00:09:11,630 --> 00:09:15,140
launches split into two pieces there's a

00:09:13,700 --> 00:09:16,970
package called launch which has no

00:09:15,140 --> 00:09:18,710
dependency on any Ross thing and you can

00:09:16,970 --> 00:09:20,060
just run processes and then there's

00:09:18,710 --> 00:09:22,480
launch Ross which has all the raw

00:09:20,060 --> 00:09:25,730
specific stuff it would be very easy to

00:09:22,480 --> 00:09:26,840
create a Ross one extension to that in

00:09:25,730 --> 00:09:28,970
the same way we have the Ross two

00:09:26,840 --> 00:09:31,100
extension to that that you know looks up

00:09:28,970 --> 00:09:34,580
it really the only difference in rosslyn

00:09:31,100 --> 00:09:36,350
Ross two is how it translates arguments

00:09:34,580 --> 00:09:38,060
to launch and to command-line arguments

00:09:36,350 --> 00:09:40,400
and how to locate the executables and

00:09:38,060 --> 00:09:41,960
that's easily done in Python and so yeah

00:09:40,400 --> 00:09:44,870
I think it would be really easy to use

00:09:41,960 --> 00:09:46,610
this in Ross one and even the long the

00:09:44,870 --> 00:09:48,920
core piece doesn't have any dependency

00:09:46,610 --> 00:09:51,760
on Ross two stuff really just a Python

00:09:48,920 --> 00:09:51,760
package thanks

00:09:55,970 --> 00:10:00,479

YouTube URL: https://www.youtube.com/watch?v=3TLEW4pj440


