Title: ROSCon 2018 Madrid Planning to Plan New Flexible Navigation Interfaces
Publication date: 2021-03-28
Playlist: ROSCon 2018
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2018 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,000 --> 00:00:06,330
hola yeah I'm a tough a boob and we

00:00:03,240 --> 00:00:07,830
don't have to go through the core basics

00:00:06,330 --> 00:00:11,460
of navigation because that's already

00:00:07,830 --> 00:00:13,320
been done for me but I've spent a lot of

00:00:11,460 --> 00:00:15,120
time working on navigation over the last

00:00:13,320 --> 00:00:17,609
couple of years maintaining the Rosses

00:00:15,120 --> 00:00:19,529
navigation stack but that's not really

00:00:17,609 --> 00:00:27,960
what I wanted to do when I started off I

00:00:19,529 --> 00:00:29,939
actually start off in HR I who doesn't

00:00:27,960 --> 00:00:31,349
want to mirror displays at the moment so

00:00:29,939 --> 00:00:33,690
I actually started off in HR I was very

00:00:31,349 --> 00:00:35,880
much inspired by this paper that came

00:00:33,690 --> 00:00:39,510
out of Willow Garage towards the very

00:00:35,880 --> 00:00:44,040
beginning talking about the using

00:00:39,510 --> 00:00:47,039
animation principles to get to increase

00:00:44,040 --> 00:00:48,750
people's perception of the robots and so

00:00:47,039 --> 00:00:51,719
what they would do is they animated it

00:00:48,750 --> 00:00:53,219
to make it do a number of different

00:00:51,719 --> 00:00:54,930
things and I wanted to take what they

00:00:53,219 --> 00:00:57,149
had done and implement that using the

00:00:54,930 --> 00:00:58,829
Nasdaq so one of the things they did was

00:00:57,149 --> 00:01:02,070
have it look in the direction it was

00:00:58,829 --> 00:01:03,690
about to go but that required getting

00:01:02,070 --> 00:01:05,970
the global plan looking in that

00:01:03,690 --> 00:01:07,619
direction and then start driving but the

00:01:05,970 --> 00:01:10,020
way move based works is it would

00:01:07,619 --> 00:01:11,640
automatically get the global plan and

00:01:10,020 --> 00:01:13,170
pass it directly to the local planner

00:01:11,640 --> 00:01:15,689
and so there was no way to get it to

00:01:13,170 --> 00:01:17,970
look that way before moving and secondly

00:01:15,689 --> 00:01:20,189
they had it react to whether or not the

00:01:17,970 --> 00:01:23,100
robots succeeded in its navigation and

00:01:20,189 --> 00:01:25,650
that was tricky because if the you would

00:01:23,100 --> 00:01:27,090
need to know if the robot failed how it

00:01:25,650 --> 00:01:28,890
failed and when it failed and with the

00:01:27,090 --> 00:01:30,869
current navigation stack you can only

00:01:28,890 --> 00:01:33,240
get if it failed and not how it failed

00:01:30,869 --> 00:01:36,030
or when it failed in the context of the

00:01:33,240 --> 00:01:37,590
larger navigation action and finally for

00:01:36,030 --> 00:01:39,540
all this it wasn't as much a part of

00:01:37,590 --> 00:01:42,479
that paper but you also need to plan

00:01:39,540 --> 00:01:46,079
around people using different types of

00:01:42,479 --> 00:01:48,030
coughs map or a plan in a way that

00:01:46,079 --> 00:01:50,570
people were able to understand what it

00:01:48,030 --> 00:01:52,860
is the robot was doing and all these

00:01:50,570 --> 00:01:55,740
operations tend to be very difficult

00:01:52,860 --> 00:01:57,869
just because customizing the planners

00:01:55,740 --> 00:02:02,579
that are part of the navigation stack is

00:01:57,869 --> 00:02:04,920
tricky so my point with all of this is

00:02:02,579 --> 00:02:06,840
that the current navigation stack does

00:02:04,920 --> 00:02:09,440
really well getting you from point A to

00:02:06,840 --> 00:02:12,040
point B but there's a lot more to

00:02:09,440 --> 00:02:14,379
operating robots in this way

00:02:12,040 --> 00:02:17,200
and context is key you have to be able

00:02:14,379 --> 00:02:19,239
to customize your robots navigation

00:02:17,200 --> 00:02:21,579
behavior for the particular context that

00:02:19,239 --> 00:02:24,340
you're going to be operating in and that

00:02:21,579 --> 00:02:27,189
requires a lot of customization that the

00:02:24,340 --> 00:02:29,769
navigation stack is not ready to allow

00:02:27,189 --> 00:02:31,599
at this point and so what I'm going to

00:02:29,769 --> 00:02:34,540
be talking about today start off with

00:02:31,599 --> 00:02:37,810
just sort of the state of the navigation

00:02:34,540 --> 00:02:40,109
stack as it is talked about the new

00:02:37,810 --> 00:02:42,849
interfaces that I've designed for

00:02:40,109 --> 00:02:45,879
writing planners talk about a new global

00:02:42,849 --> 00:02:48,250
planner that I've written and locomotor

00:02:45,879 --> 00:02:49,870
which is our move based replacement that

00:02:48,250 --> 00:02:51,370
ties all the pieces together and then at

00:02:49,870 --> 00:02:55,989
the end I'm going to touch on Ross to

00:02:51,370 --> 00:02:57,459
briefly so I maintain the current

00:02:55,989 --> 00:02:59,019
navigation stack and so you might be

00:02:57,459 --> 00:03:02,739
asking why the fork would you want to

00:02:59,019 --> 00:03:04,299
make a new version of this code well in

00:03:02,739 --> 00:03:08,290
this slide you can see that the current

00:03:04,299 --> 00:03:10,450
number of navigation stack orcs is 734

00:03:08,290 --> 00:03:12,579
this is up a couple hundred from where

00:03:10,450 --> 00:03:14,769
when I presented a version of this slide

00:03:12,579 --> 00:03:18,669
last year it's actually up three since I

00:03:14,769 --> 00:03:20,260
made the screen shots and what this says

00:03:18,669 --> 00:03:21,940
to me is that there's a lot of good

00:03:20,260 --> 00:03:24,510
stuff in the navigation stack and

00:03:21,940 --> 00:03:27,639
there's a lot of stuff that people

00:03:24,510 --> 00:03:31,569
almost find working about it so that

00:03:27,639 --> 00:03:34,000
they'll instead of actually using it as

00:03:31,569 --> 00:03:36,370
is they'll take the code make their one

00:03:34,000 --> 00:03:39,280
small tweak and then use that and then

00:03:36,370 --> 00:03:41,349
their navigation works it's hard to swap

00:03:39,280 --> 00:03:42,549
out those single little components so

00:03:41,349 --> 00:03:45,099
it's much easier to just make a

00:03:42,549 --> 00:03:48,069
wholesale fork and then sometimes people

00:03:45,099 --> 00:03:49,810
will push those changes back upstream

00:03:48,069 --> 00:03:51,849
and that's great I've done that a number

00:03:49,810 --> 00:03:54,069
of times but the problem with that is

00:03:51,849 --> 00:03:55,989
that we end up with the 30 trillion

00:03:54,069 --> 00:04:00,159
parameters that are currently in the

00:03:55,989 --> 00:04:02,220
navigation stack and we're try it part

00:04:00,159 --> 00:04:04,799
of the problem is that you end up with a

00:04:02,220 --> 00:04:08,049
system that can be configured for

00:04:04,799 --> 00:04:10,120
anybody's purposes and that includes a

00:04:08,049 --> 00:04:14,290
lot of corner cases and it's difficult

00:04:10,120 --> 00:04:16,120
to replace small parts so you get a lot

00:04:14,290 --> 00:04:18,699
of corner cases makes it very hard to

00:04:16,120 --> 00:04:20,739
test and the other reason why I want to

00:04:18,699 --> 00:04:22,810
make something new is because I know

00:04:20,739 --> 00:04:23,380
that a lot of people rely on this

00:04:22,810 --> 00:04:26,440
navigation

00:04:23,380 --> 00:04:27,910
code not only the 734 people who have

00:04:26,440 --> 00:04:29,800
worked it here but a lot of

00:04:27,910 --> 00:04:32,560
organizations have worked it privately

00:04:29,800 --> 00:04:35,410
and breaking things here would cause

00:04:32,560 --> 00:04:39,100
trouble for them elsewhere so I don't

00:04:35,410 --> 00:04:41,380
want to break what's already there but I

00:04:39,100 --> 00:04:45,100
do have a number of problems with the

00:04:41,380 --> 00:04:47,620
navigation stack as it is so unlike the

00:04:45,100 --> 00:04:51,100
last talk the navigation stack really

00:04:47,620 --> 00:04:53,620
only affords for plain error navigation

00:04:51,100 --> 00:04:55,300
that is an X or Y and a theta

00:04:53,620 --> 00:04:57,610
it doesn't really care if it's off the

00:04:55,300 --> 00:05:00,370
ground or lying on its back that extra

00:04:57,610 --> 00:05:02,200
pose information is redundant and makes

00:05:00,370 --> 00:05:06,520
operating within the navigation stack

00:05:02,200 --> 00:05:09,100
more difficult the nav core interfaces

00:05:06,520 --> 00:05:11,260
have generally not been updated in

00:05:09,100 --> 00:05:12,670
almost a decade now and there are some

00:05:11,260 --> 00:05:16,810
serious limitations that I'll talk about

00:05:12,670 --> 00:05:18,340
later cost map 2d is great there was

00:05:16,810 --> 00:05:20,020
some great work done at Willow Garage a

00:05:18,340 --> 00:05:22,300
number of years ago by name guy named

00:05:20,020 --> 00:05:24,970
David Lew who put cost map layers into

00:05:22,300 --> 00:05:27,010
the cost map what that does force you to

00:05:24,970 --> 00:05:28,330
use cost map layers and sometimes you

00:05:27,010 --> 00:05:31,300
really just want to throw some values

00:05:28,330 --> 00:05:34,510
into a grid and so it adds a lot of

00:05:31,300 --> 00:05:37,540
overhead also cost map 2d and a lot of

00:05:34,510 --> 00:05:39,790
the related packages use occupancy grids

00:05:37,540 --> 00:05:43,240
which means that you end up which is

00:05:39,790 --> 00:05:45,490
fine except for most cost maps have 256

00:05:43,240 --> 00:05:47,590
unique values whereas occupancy grids

00:05:45,490 --> 00:05:50,290
really only allow you to transmit 0 to

00:05:47,590 --> 00:05:52,270
100 and that's problematic in a number

00:05:50,290 --> 00:05:55,600
of different places widely regarded as a

00:05:52,270 --> 00:05:57,670
bad idea as far as global planners go

00:05:55,600 --> 00:06:00,880
the standard that people use is nav

00:05:57,670 --> 00:06:03,100
offend which is great except for it's

00:06:00,880 --> 00:06:05,590
prematurely optimized in a couple of

00:06:03,100 --> 00:06:06,970
different ways it's there's a couple of

00:06:05,590 --> 00:06:09,220
magic numbers in there that took me

00:06:06,970 --> 00:06:11,860
forever to understand and it's hard to

00:06:09,220 --> 00:06:15,490
edit I tried to edit it once and I made

00:06:11,860 --> 00:06:17,770
a package called global planner which is

00:06:15,490 --> 00:06:18,990
a lot more modular but it has bugs and

00:06:17,770 --> 00:06:22,420
there's actually some simple navigation

00:06:18,990 --> 00:06:25,770
simple path planning examples that don't

00:06:22,420 --> 00:06:28,540
work in that planner so it's not great

00:06:25,770 --> 00:06:30,190
as far as local planners go I did talk

00:06:28,540 --> 00:06:32,729
mostly about this last year but they're

00:06:30,190 --> 00:06:35,650
difficult to debug and customize and

00:06:32,729 --> 00:06:38,740
move base move base is

00:06:35,650 --> 00:06:41,470
to all of the operation of the Ross

00:06:38,740 --> 00:06:44,290
navigation stack but for most purposes

00:06:41,470 --> 00:06:47,740
it is a black box where you put your

00:06:44,290 --> 00:06:49,510
goals in and hope for the best and the

00:06:47,740 --> 00:06:51,460
best that you can hope for is changing

00:06:49,510 --> 00:06:53,530
the list of static recovery behaviors

00:06:51,460 --> 00:06:56,530
but those same recovery behaviors will

00:06:53,530 --> 00:06:58,690
be run every time regardless of the

00:06:56,530 --> 00:07:02,169
method in which your robot fails

00:06:58,690 --> 00:07:05,949
planning and that results in not very

00:07:02,169 --> 00:07:07,690
intelligent contextualized behavior so

00:07:05,949 --> 00:07:10,960
in the work done presented today I had a

00:07:07,690 --> 00:07:12,880
couple of designing methodology where I

00:07:10,960 --> 00:07:14,979
really want to build reusable pieces

00:07:12,880 --> 00:07:17,320
it's all meant to be extensible I want

00:07:14,979 --> 00:07:19,630
people to be able to take pieces of what

00:07:17,320 --> 00:07:23,410
I've done and hack it apart just as I

00:07:19,630 --> 00:07:26,080
would and hopefully understands how each

00:07:23,410 --> 00:07:31,030
of the pieces operates meaning no black

00:07:26,080 --> 00:07:33,729
boxes chief among those reusable pieces

00:07:31,030 --> 00:07:35,650
is a data structure that occurs multiple

00:07:33,729 --> 00:07:38,919
times in the navigation stack which is

00:07:35,650 --> 00:07:40,900
which I'm calling nav grey a cost map is

00:07:38,919 --> 00:07:43,419
really this group based representation

00:07:40,900 --> 00:07:48,160
where we assign a value to each cell in

00:07:43,419 --> 00:07:49,630
a grid this is used in cosmos also used

00:07:48,160 --> 00:07:51,070
in the global planner in a couple of

00:07:49,630 --> 00:07:52,570
different places as well as the local

00:07:51,070 --> 00:07:54,639
planner for storing different types of

00:07:52,570 --> 00:07:56,260
information and so I've created a data

00:07:54,639 --> 00:07:58,570
structure here it meant to be reused

00:07:56,260 --> 00:08:00,490
where you declare what kind where the

00:07:58,570 --> 00:08:02,770
grid is based on one of these nav grid

00:08:00,490 --> 00:08:05,680
infos and then you can use it in a

00:08:02,770 --> 00:08:08,139
number of different contexts and so the

00:08:05,680 --> 00:08:09,699
data storage here is all abstracted so

00:08:08,139 --> 00:08:12,250
that you can have it be backed by a

00:08:09,699 --> 00:08:15,430
standard vector or any other type of

00:08:12,250 --> 00:08:17,979
data storage the typing is template

00:08:15,430 --> 00:08:19,470
based so you can stick in floats on sign

00:08:17,979 --> 00:08:21,789
chars classes whatever you'd like

00:08:19,470 --> 00:08:23,620
there's a whole library for coordinate

00:08:21,789 --> 00:08:25,000
translation from translating from world

00:08:23,620 --> 00:08:27,430
coordinates the grid coordinates and

00:08:25,000 --> 00:08:29,770
back there are new message types that

00:08:27,430 --> 00:08:33,070
don't suffer these setbacks of occupancy

00:08:29,770 --> 00:08:35,589
grid called navigate of cars and their

00:08:33,070 --> 00:08:39,339
related updates and finally this is

00:08:35,589 --> 00:08:41,440
inspired by the work of the grid map

00:08:39,339 --> 00:08:44,079
people there are also iterators that

00:08:41,440 --> 00:08:45,940
work on these that are easily reused for

00:08:44,079 --> 00:08:49,660
a number of different operations

00:08:45,940 --> 00:08:52,270
and so this actually forms the basis of

00:08:49,660 --> 00:08:54,520
one of the new cost map new plugins I

00:08:52,270 --> 00:08:56,800
made and so with these new interfaces

00:08:54,520 --> 00:08:58,240
its plugins all the way down when all

00:08:56,800 --> 00:09:00,550
you have is a hammer everything looks

00:08:58,240 --> 00:09:03,190
like now I love just adding plugins to

00:09:00,550 --> 00:09:06,490
wherever I can in the Nasdaq so not only

00:09:03,190 --> 00:09:09,880
were the planners already plugins I made

00:09:06,490 --> 00:09:11,920
it cost map layers also be plugins last

00:09:09,880 --> 00:09:13,570
I talked about dwb local planner which

00:09:11,920 --> 00:09:17,320
was based on plugins and now we have

00:09:13,570 --> 00:09:20,020
some more so now I've made the cost map

00:09:17,320 --> 00:09:22,200
itself a plugin and so as long as it

00:09:20,020 --> 00:09:27,550
here's to this interface you could use

00:09:22,200 --> 00:09:30,100
any type of cost map in the in these new

00:09:27,550 --> 00:09:32,680
interfaces so just a couple of quick

00:09:30,100 --> 00:09:34,720
points this is based on nav grid but it

00:09:32,680 --> 00:09:37,270
uses unsigned char much like the old

00:09:34,720 --> 00:09:39,520
cost maps did and that's for a number of

00:09:37,270 --> 00:09:42,760
reasons data storage concerns being one

00:09:39,520 --> 00:09:46,900
but also just having a limited number of

00:09:42,760 --> 00:09:49,060
unique values is also important it there

00:09:46,900 --> 00:09:52,050
are no required TFS the old cost maps

00:09:49,060 --> 00:09:53,800
required that certain transforms be

00:09:52,050 --> 00:09:55,810
present before that you could actually

00:09:53,800 --> 00:09:58,570
get them to initialize here that's not

00:09:55,810 --> 00:10:00,640
true and it makes testing much easier

00:09:58,570 --> 00:10:03,100
there is no built-in update thread so

00:10:00,640 --> 00:10:05,920
you can control how often the cost map

00:10:03,100 --> 00:10:08,380
updates and you can use any update

00:10:05,920 --> 00:10:10,360
algorithm underneath there for not

00:10:08,380 --> 00:10:12,940
forced to use the layered cost map and

00:10:10,360 --> 00:10:14,980
then I also added this option to track

00:10:12,940 --> 00:10:17,100
changes within the cost map so you can

00:10:14,980 --> 00:10:19,420
know how much has been updated

00:10:17,100 --> 00:10:21,760
furthermore all of this is compatible

00:10:19,420 --> 00:10:24,760
with the previous version of cost map 2d

00:10:21,760 --> 00:10:27,670
Ross so that you can still use new

00:10:24,760 --> 00:10:30,940
plugins the voxel layer and things like

00:10:27,670 --> 00:10:32,980
that within this interface so last year

00:10:30,940 --> 00:10:34,540
I talked about dwb local planner and all

00:10:32,980 --> 00:10:36,430
the different components which were

00:10:34,540 --> 00:10:37,270
plugins so that you could customize it

00:10:36,430 --> 00:10:39,400
to your own needs

00:10:37,270 --> 00:10:42,670
now with the new global planner

00:10:39,400 --> 00:10:45,430
interface that it's very similar in that

00:10:42,670 --> 00:10:48,430
it also uses this these nav 2d messages

00:10:45,430 --> 00:10:51,550
which eliminate all the 3d information

00:10:48,430 --> 00:10:53,140
that's provided but also instead of just

00:10:51,550 --> 00:10:55,480
returning a boolean for whether it

00:10:53,140 --> 00:10:57,910
succeeds or fails it throws exceptions

00:10:55,480 --> 00:10:58,550
so that it will so that you can get more

00:10:57,910 --> 00:11:01,279
contextual

00:10:58,550 --> 00:11:03,680
information about why it failed and so

00:11:01,279 --> 00:11:06,080
we have a new global planner which is

00:11:03,680 --> 00:11:07,940
called deluxe global planner that name

00:11:06,080 --> 00:11:10,940
was suggested by one of my colleagues at

00:11:07,940 --> 00:11:13,700
Lucas robotics and the two major plugins

00:11:10,940 --> 00:11:16,010
we have are the potential calculator

00:11:13,700 --> 00:11:18,079
which is where you put in your graph

00:11:16,010 --> 00:11:20,390
theory algorithm of choice so the ones

00:11:18,079 --> 00:11:22,579
we have right now are Dijkstra and a

00:11:20,390 --> 00:11:24,890
star and then you have the trace back

00:11:22,579 --> 00:11:26,180
that generates the actual path from the

00:11:24,890 --> 00:11:28,640
grid and there's a number of different

00:11:26,180 --> 00:11:31,459
ones that either adhere to the grid or

00:11:28,640 --> 00:11:33,709
have a nice gradient and so here's just

00:11:31,459 --> 00:11:36,980
some examples of what that those paths

00:11:33,709 --> 00:11:39,260
could look like here are the four

00:11:36,980 --> 00:11:41,180
neighbor base ones the eight neighbor

00:11:39,260 --> 00:11:43,250
based grid ones and then the gradient

00:11:41,180 --> 00:11:45,920
ones but the real ones that there's a

00:11:43,250 --> 00:11:47,600
lot of different instantiations of this

00:11:45,920 --> 00:11:50,060
that you can make depending on which

00:11:47,600 --> 00:11:52,100
plugins you use which a star heuristics

00:11:50,060 --> 00:11:56,180
you get but you can get something fairly

00:11:52,100 --> 00:11:57,980
close to the optimal here and so you

00:11:56,180 --> 00:11:59,839
might be asking why I feel confident

00:11:57,980 --> 00:12:01,910
releasing a new global player when the

00:11:59,839 --> 00:12:04,910
one that I previously made has some bugs

00:12:01,910 --> 00:12:07,250
in it I also made a class called global

00:12:04,910 --> 00:12:09,560
planner tests which is based on the nav

00:12:07,250 --> 00:12:14,300
core to global planner interface and

00:12:09,560 --> 00:12:16,310
will figure will run unit tests who run

00:12:14,300 --> 00:12:18,140
make global plans from every free sale

00:12:16,310 --> 00:12:21,350
to every other free sell in a number of

00:12:18,140 --> 00:12:22,790
given maps and run those as unit tests

00:12:21,350 --> 00:12:26,180
so that you can actually make sure that

00:12:22,790 --> 00:12:29,770
your global planner conforms all right

00:12:26,180 --> 00:12:32,480
but the key component here is that

00:12:29,770 --> 00:12:34,370
manages all this is move based and so as

00:12:32,480 --> 00:12:36,380
we talked about before there are four

00:12:34,370 --> 00:12:39,290
components the two planners in the to

00:12:36,380 --> 00:12:41,510
cost maps and really all move based does

00:12:39,290 --> 00:12:43,670
is it takes the global planner from the

00:12:41,510 --> 00:12:46,010
global plan from the global planner and

00:12:43,670 --> 00:12:46,820
delivers it to the local planner at

00:12:46,010 --> 00:12:49,070
least that's what's supposed to happen

00:12:46,820 --> 00:12:52,279
when everything's going right and the

00:12:49,070 --> 00:12:54,790
cup the complexity comes from trying to

00:12:52,279 --> 00:12:57,370
recover when the planning fails and

00:12:54,790 --> 00:13:01,370
that's when you get into the number of

00:12:57,370 --> 00:13:03,290
recovery behaviors one of the key

00:13:01,370 --> 00:13:05,540
limitations here is the fact that

00:13:03,290 --> 00:13:08,000
there's so many different threads in

00:13:05,540 --> 00:13:10,240
move base there's one for each of the

00:13:08,000 --> 00:13:12,459
cost maps to update and

00:13:10,240 --> 00:13:14,290
each of the planners is also run in a

00:13:12,459 --> 00:13:15,970
separate thread and that creates a lot

00:13:14,290 --> 00:13:18,339
of different problems that's talked

00:13:15,970 --> 00:13:21,100
about in INGOs talk last year where you

00:13:18,339 --> 00:13:22,510
can have robots not reacting to sensor

00:13:21,100 --> 00:13:25,200
data because of all the different

00:13:22,510 --> 00:13:27,670
threads and end up crashing into things

00:13:25,200 --> 00:13:30,190
so our replacement for this is called

00:13:27,670 --> 00:13:33,779
locomotor which is an extensible path

00:13:30,190 --> 00:13:37,000
planning coordination engine which

00:13:33,779 --> 00:13:39,130
allows you to define what exactly

00:13:37,000 --> 00:13:42,760
happens when your path planning succeeds

00:13:39,130 --> 00:13:44,140
or fails and it's built on the same nap

00:13:42,760 --> 00:13:46,480
core two interfaces that I talked about

00:13:44,140 --> 00:13:49,029
before and it leverages Ross callback

00:13:46,480 --> 00:13:52,540
use in order to be able to handle the

00:13:49,029 --> 00:13:54,820
different threading of the events so

00:13:52,540 --> 00:13:57,520
just as an example you start off with a

00:13:54,820 --> 00:14:00,220
request global plan that will put a new

00:13:57,520 --> 00:14:02,350
event on to the callback queue which

00:14:00,220 --> 00:14:05,110
runs make global plan and that event

00:14:02,350 --> 00:14:07,779
will trigger one of two other events

00:14:05,110 --> 00:14:11,050
either on new global plan or on global

00:14:07,779 --> 00:14:13,480
planning exception and you can extend

00:14:11,050 --> 00:14:15,190
these to define exactly what happens in

00:14:13,480 --> 00:14:18,190
each of those cases and there's similar

00:14:15,190 --> 00:14:21,279
events for the local planner as well as

00:14:18,190 --> 00:14:23,770
updating the cost maps and so an example

00:14:21,279 --> 00:14:25,570
of how this would work you can make a

00:14:23,770 --> 00:14:28,329
single threaded version of locomotor

00:14:25,570 --> 00:14:31,209
where you start off when you get a goal

00:14:28,329 --> 00:14:33,550
you say do a global cost map update and

00:14:31,209 --> 00:14:36,550
from there that will trigger a callback

00:14:33,550 --> 00:14:39,550
to the make global plan when that

00:14:36,550 --> 00:14:42,160
succeeds that will start a timer and the

00:14:39,550 --> 00:14:44,529
timer will trigger and cause a local

00:14:42,160 --> 00:14:46,779
cost map update followed by a local plan

00:14:44,529 --> 00:14:48,820
updates and then that will loop around

00:14:46,779 --> 00:14:51,310
and the timer will trigger again and

00:14:48,820 --> 00:14:54,940
you'll get your robot to drive along the

00:14:51,310 --> 00:14:56,920
path now this is and this is something

00:14:54,940 --> 00:14:59,380
the single thread version something that

00:14:56,920 --> 00:15:00,760
you can't do in move base but this is

00:14:59,380 --> 00:15:02,470
what happens when everything is working

00:15:00,760 --> 00:15:04,420
well and what you want to be able to do

00:15:02,470 --> 00:15:06,610
is control when things don't go well so

00:15:04,420 --> 00:15:09,850
how do you deal with failure so let's

00:15:06,610 --> 00:15:11,680
say your global planning fails it might

00:15:09,850 --> 00:15:13,630
cause different types of exceptions so

00:15:11,680 --> 00:15:16,750
it might cause an invalid start pose

00:15:13,630 --> 00:15:19,150
exception or an invalid goal pose or a

00:15:16,750 --> 00:15:21,290
number of other different exceptions and

00:15:19,150 --> 00:15:23,449
now you can

00:15:21,290 --> 00:15:25,670
that exception and cause different

00:15:23,449 --> 00:15:29,660
behaviors to happen depending on the

00:15:25,670 --> 00:15:31,850
type so if the in the start poses

00:15:29,660 --> 00:15:35,740
invalid maybe you want to clear the cost

00:15:31,850 --> 00:15:38,269
map and try again if the goal pose is

00:15:35,740 --> 00:15:40,250
causes a problem then maybe you want to

00:15:38,269 --> 00:15:43,579
choose a new goal and react in that way

00:15:40,250 --> 00:15:46,610
and so this is just an example you are

00:15:43,579 --> 00:15:48,740
allowed to extend this class and change

00:15:46,610 --> 00:15:52,579
these mappings to fit your particular

00:15:48,740 --> 00:15:54,680
context you can also get something with

00:15:52,579 --> 00:15:56,720
two threads so the previous example you

00:15:54,680 --> 00:15:59,300
could only get one global plan now we

00:15:56,720 --> 00:16:02,269
start a timer to make to make the global

00:15:59,300 --> 00:16:04,430
plans and when we get a global plan we

00:16:02,269 --> 00:16:07,930
not only trigger the local planner timer

00:16:04,430 --> 00:16:10,759
but we can also loop back and start

00:16:07,930 --> 00:16:12,709
planning again and that's all done on

00:16:10,759 --> 00:16:15,470
one callback queue and then on the other

00:16:12,709 --> 00:16:17,480
callback queue the timer starts and does

00:16:15,470 --> 00:16:21,009
the local cost map update and local

00:16:17,480 --> 00:16:23,630
planning and this way you get both the

00:16:21,009 --> 00:16:26,810
global plan and local plan updating

00:16:23,630 --> 00:16:28,819
continuously and you can take it further

00:16:26,810 --> 00:16:30,649
you can make four different timers for

00:16:28,819 --> 00:16:33,350
each of the different components this is

00:16:30,649 --> 00:16:35,300
much like what move base does where each

00:16:33,350 --> 00:16:38,410
of them runs on a different update cycle

00:16:35,300 --> 00:16:41,449
and in fact we made a replacement

00:16:38,410 --> 00:16:43,639
specifically for move base where you can

00:16:41,449 --> 00:16:45,920
drop it in called local move base that

00:16:43,639 --> 00:16:48,500
allows you to use your previous cost map

00:16:45,920 --> 00:16:50,959
so the same cost map to tear offs but

00:16:48,500 --> 00:16:53,690
then also load navcore recovery

00:16:50,959 --> 00:16:57,199
behaviors so that when for example your

00:16:53,690 --> 00:16:58,819
global plan fails you on any exception

00:16:57,199 --> 00:17:01,639
it will go through the static list of

00:16:58,819 --> 00:17:05,510
recovery behaviors just like move base

00:17:01,639 --> 00:17:07,939
would one of the other features is there

00:17:05,510 --> 00:17:09,919
is a plug-in MUX this bit isn't specific

00:17:07,939 --> 00:17:12,020
to navcore two but it allows you to load

00:17:09,919 --> 00:17:15,350
multiple different plug-in Lib plugins

00:17:12,020 --> 00:17:18,350
and switch between them either via C++

00:17:15,350 --> 00:17:20,360
method or Ross service and one thing

00:17:18,350 --> 00:17:23,540
that that enables is that when you get

00:17:20,360 --> 00:17:25,520
an exception you can choose to switch

00:17:23,540 --> 00:17:26,809
your planner so if your local plan fails

00:17:25,520 --> 00:17:29,250
maybe switch to a different local

00:17:26,809 --> 00:17:31,740
planner that you think could handle that

00:17:29,250 --> 00:17:35,700
and just to go back to the first example

00:17:31,740 --> 00:17:38,100
that I showed we also here I've extended

00:17:35,700 --> 00:17:40,530
this so that when the global plan is

00:17:38,100 --> 00:17:42,809
made then we stop look in the direction

00:17:40,530 --> 00:17:44,400
of the global plan and then we start the

00:17:42,809 --> 00:17:49,110
time so just as a way to customize

00:17:44,400 --> 00:17:50,640
what's going on so move base is also

00:17:49,110 --> 00:17:53,760
centered around this move based action

00:17:50,640 --> 00:17:56,520
which I find wholly useless for pretty

00:17:53,760 --> 00:17:58,200
much anything other than the core idea

00:17:56,520 --> 00:18:00,659
of starting the action and ending the

00:17:58,200 --> 00:18:02,490
action you provide it with a target pose

00:18:00,659 --> 00:18:04,710
and it occasionally will give you a base

00:18:02,490 --> 00:18:07,200
position update I have this new

00:18:04,710 --> 00:18:08,850
locomotor action which you give it a

00:18:07,200 --> 00:18:11,760
goal and you get much more robust

00:18:08,850 --> 00:18:13,590
information back you not forced to use

00:18:11,760 --> 00:18:16,740
this you can create your own actions as

00:18:13,590 --> 00:18:19,020
well and so while we're talking about

00:18:16,740 --> 00:18:20,580
the next generation of things we are

00:18:19,020 --> 00:18:23,309
currently working on a full tree

00:18:20,580 --> 00:18:25,220
implementation of the nav stack with the

00:18:23,309 --> 00:18:29,220
planners that I talked about as well as

00:18:25,220 --> 00:18:31,049
locomotor but also a new implementation

00:18:29,220 --> 00:18:33,390
of the layered cost map and cost map

00:18:31,049 --> 00:18:35,220
layers that conforms to that cost map

00:18:33,390 --> 00:18:37,320
interface that I talked about before as

00:18:35,220 --> 00:18:39,630
well as nav grid server and saver and

00:18:37,320 --> 00:18:41,700
things like that and our goal is to have

00:18:39,630 --> 00:18:44,370
a Ross 2 version of this out by the

00:18:41,700 --> 00:18:46,770
year's end this is work done in

00:18:44,370 --> 00:18:48,539
conjunction with Matt Hansen and his

00:18:46,770 --> 00:18:51,030
group at Intel who are currently

00:18:48,539 --> 00:18:55,440
spearheading the Ross to navigation

00:18:51,030 --> 00:18:56,890
efforts and with that I thank you very

00:18:55,440 --> 00:19:04,839
much

00:18:56,890 --> 00:19:09,739
[Applause]

00:19:04,839 --> 00:19:11,869
do we have any questions for David all

00:19:09,739 --> 00:19:15,079
right there's one coming down I give for

00:19:11,869 --> 00:19:18,559
the nice talk since you adapted many

00:19:15,079 --> 00:19:22,429
ideas from West Lex where would you say

00:19:18,559 --> 00:19:26,059
is the main difference and okay you only

00:19:22,429 --> 00:19:29,629
support 2d right this is this is right

00:19:26,059 --> 00:19:35,019
you only support 2d representations yes

00:19:29,629 --> 00:19:37,249
so one of the ideas of the some of other

00:19:35,019 --> 00:19:39,679
navigation implementations right now is

00:19:37,249 --> 00:19:43,489
to support full 3d be you know

00:19:39,679 --> 00:19:45,409
quadcopters what have you my approach is

00:19:43,489 --> 00:19:48,889
to do the one thing very well hopefully

00:19:45,409 --> 00:19:54,529
and run into just the 2.5 D XY data

00:19:48,889 --> 00:19:56,479
space as far as move based flex goes you

00:19:54,529 --> 00:19:58,279
know there's a lot of I think it's been

00:19:56,479 --> 00:20:00,259
a shame that everybody has been forced

00:19:58,279 --> 00:20:01,699
to use move base in the past and I think

00:20:00,259 --> 00:20:03,979
that the fact that you know there are

00:20:01,699 --> 00:20:05,509
multiple idea multiple implementations

00:20:03,979 --> 00:20:09,019
of how to run navigation out there is

00:20:05,509 --> 00:20:11,599
key but it's you know this is something

00:20:09,019 --> 00:20:13,129
that I've had percolating in different

00:20:11,599 --> 00:20:16,069
forms for a number of different years

00:20:13,129 --> 00:20:18,049
and I think having different ways to

00:20:16,069 --> 00:20:19,789
adapt running the global and local

00:20:18,049 --> 00:20:23,269
planner is gonna be very useful going

00:20:19,789 --> 00:20:24,859
forward and out there any plans to have

00:20:23,269 --> 00:20:29,149
it like

00:20:24,859 --> 00:20:31,959
stand up navigation spec for your robots

00:20:29,149 --> 00:20:35,299
in 3d navigating navigating in 3d

00:20:31,959 --> 00:20:37,099
personally no like that is not something

00:20:35,299 --> 00:20:40,009
that I'm working on it's not something

00:20:37,099 --> 00:20:43,459
that my company has robots capable of

00:20:40,009 --> 00:20:47,659
doing at this time I always take gifts

00:20:43,459 --> 00:20:49,669
of quadcopters but no so but no it is

00:20:47,659 --> 00:20:53,059
not something that I'm looking at right

00:20:49,669 --> 00:20:56,089
now okay thanks I'm bad enough existing

00:20:53,059 --> 00:20:57,370
dimensions all right thank you very much

00:20:56,089 --> 00:21:00,700
thank you

00:20:57,370 --> 00:21:00,700

YouTube URL: https://www.youtube.com/watch?v=R5jnDVo_Rnk


