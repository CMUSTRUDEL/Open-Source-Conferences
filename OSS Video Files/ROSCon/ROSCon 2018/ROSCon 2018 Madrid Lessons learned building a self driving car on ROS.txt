Title: ROSCon 2018 Madrid Lessons learned building a self driving car on ROS
Publication date: 2021-03-28
Playlist: ROSCon 2018
Description: 
	Unaltered video by Open Robotics from http://roscon.ros.org/2018 under the Attribution-NonCommercial-NoDerivs 3.0 Unported (CC BY-NC-ND 3.0) License https://creativecommons.org/licenses/by-nc-nd/3.0/
Captions: 
	00:00:00,530 --> 00:00:06,060
okay everybody my name is Nico I'm a

00:00:04,170 --> 00:00:08,400
software engineer at cruise automation

00:00:06,060 --> 00:00:11,460
where we're building self-driving cars

00:00:08,400 --> 00:00:12,990
in San Francisco this short talk is

00:00:11,460 --> 00:00:15,179
basically going to be about lessons that

00:00:12,990 --> 00:00:16,980
we learned using basically the Ross

00:00:15,179 --> 00:00:20,430
framework to actually build those

00:00:16,980 --> 00:00:23,100
self-driving cars just to get started we

00:00:20,430 --> 00:00:25,769
have a fleet of around scanning a bit of

00:00:23,100 --> 00:00:28,199
the text sorry guys we have a fleet of

00:00:25,769 --> 00:00:30,090
around 100 self-driving cars that drive

00:00:28,199 --> 00:00:33,239
around San Francisco of course with

00:00:30,090 --> 00:00:35,340
safety drivers and a team of 500

00:00:33,239 --> 00:00:38,520
software engineers that write the code

00:00:35,340 --> 00:00:40,379
for those cars more technically just to

00:00:38,520 --> 00:00:42,570
give you an idea of the complexity of

00:00:40,379 --> 00:00:45,480
the problem we have a sensor suite that

00:00:42,570 --> 00:00:48,090
has like around 10 cameras a bunch of

00:00:45,480 --> 00:00:50,280
liars radars of course I am you will

00:00:48,090 --> 00:00:52,949
sensors and all of these sensors

00:00:50,280 --> 00:00:55,770
together produce around one gigabytes

00:00:52,949 --> 00:00:58,289
per one gigabyte per second of data so I

00:00:55,770 --> 00:01:00,750
guess it gets pretty complex and it's

00:00:58,289 --> 00:01:02,609
actually amazing that the first get

00:01:00,750 --> 00:01:05,460
commit in the history of the project

00:01:02,609 --> 00:01:06,900
actually had already rose in it and it's

00:01:05,460 --> 00:01:08,729
amazing how far we have been able to

00:01:06,900 --> 00:01:12,150
scale it up both in terms of like

00:01:08,729 --> 00:01:15,509
software and in terms of people so today

00:01:12,150 --> 00:01:18,720
I basically everybody knows what Ross is

00:01:15,509 --> 00:01:20,400
good so today I'm gonna actually go in

00:01:18,720 --> 00:01:22,110
and like talk about sort of like the

00:01:20,400 --> 00:01:24,960
boundaries right what's actually hard to

00:01:22,110 --> 00:01:27,299
do and the areas where we had to push a

00:01:24,960 --> 00:01:29,430
bit over what's available and to

00:01:27,299 --> 00:01:31,500
basically achieve our goal so I'm gonna

00:01:29,430 --> 00:01:34,380
be talking about some problems around

00:01:31,500 --> 00:01:37,229
determinism and simulation then some

00:01:34,380 --> 00:01:39,240
stuff we constantly fight with on the

00:01:37,229 --> 00:01:42,439
core frame or side and then also some

00:01:39,240 --> 00:01:45,270
nice developer tooling that we'll build

00:01:42,439 --> 00:01:47,250
so let's get started with simulation

00:01:45,270 --> 00:01:48,869
simulation is important especially when

00:01:47,250 --> 00:01:51,210
you make mistakes in your software and

00:01:48,869 --> 00:01:53,909
they kill people which is not nice

00:01:51,210 --> 00:01:56,430
so of course testing on real cards it's

00:01:53,909 --> 00:01:58,680
complicated it is expensive we are a

00:01:56,430 --> 00:02:00,390
good process but still it takes like two

00:01:58,680 --> 00:02:02,729
humans to like drive a car around and

00:02:00,390 --> 00:02:05,399
collect data so you would think this is

00:02:02,729 --> 00:02:08,610
pretty easy right so we use respect we

00:02:05,399 --> 00:02:10,739
record all the data as we go and then we

00:02:08,610 --> 00:02:11,940
spin up a bunch of cloud machines we

00:02:10,739 --> 00:02:13,200
will use Ross

00:02:11,940 --> 00:02:16,860
like play and then we're on the

00:02:13,200 --> 00:02:19,320
simulations except this doesn't really

00:02:16,860 --> 00:02:22,410
work well for an expensive system right

00:02:19,320 --> 00:02:24,390
basically the only thing that Ross gives

00:02:22,410 --> 00:02:26,610
you in terms of simulations is the

00:02:24,390 --> 00:02:29,190
ability to playback the sensor data

00:02:26,610 --> 00:02:31,890
basically cutting out the drivers and

00:02:29,190 --> 00:02:34,470
like replaying the sensors optionally

00:02:31,890 --> 00:02:37,350
you can reproduce your clock as well

00:02:34,470 --> 00:02:40,650
using simulated clocks and supposedly

00:02:37,350 --> 00:02:42,690
that enables you to run the same robotic

00:02:40,650 --> 00:02:43,740
system without actually access to a

00:02:42,690 --> 00:02:46,230
robotic solar

00:02:43,740 --> 00:02:49,610
however there's like two big issues with

00:02:46,230 --> 00:02:51,840
that one is that on storage hardware

00:02:49,610 --> 00:02:54,930
which is very likely right you have a

00:02:51,840 --> 00:02:56,550
very expensive CPU on the car but you

00:02:54,930 --> 00:02:58,740
have a cheaper cloud machine to run your

00:02:56,550 --> 00:03:00,720
tests and simulation if you aren't slow

00:02:58,740 --> 00:03:02,700
at hardware you have to slow down the

00:03:00,720 --> 00:03:05,310
replay or you end up missing frames

00:03:02,700 --> 00:03:07,890
which sort of destroys the the point of

00:03:05,310 --> 00:03:10,590
simulation right and the second problem

00:03:07,890 --> 00:03:13,410
is that all of this data still goes

00:03:10,590 --> 00:03:16,080
through the same ross pub/sub mechanism

00:03:13,410 --> 00:03:19,050
right so you get all this weird timing

00:03:16,080 --> 00:03:22,020
and sampling effects and determinism

00:03:19,050 --> 00:03:25,170
goes out of the window determinism being

00:03:22,020 --> 00:03:27,120
defined as given the same inputs you get

00:03:25,170 --> 00:03:29,310
the same outputs which again is pretty

00:03:27,120 --> 00:03:34,950
important for for simulation as you can

00:03:29,310 --> 00:03:36,300
imagine so what did we do a cruise first

00:03:34,950 --> 00:03:37,770
we learned that like simulation is

00:03:36,300 --> 00:03:41,190
really important and it should be like a

00:03:37,770 --> 00:03:42,690
first class concept on any robotics

00:03:41,190 --> 00:03:45,060
framework basically because otherwise

00:03:42,690 --> 00:03:46,350
it's really hard to make progress so

00:03:45,060 --> 00:03:48,870
basically the goal would be to achieve

00:03:46,350 --> 00:03:50,790
deterministic lockstep simulation

00:03:48,870 --> 00:03:54,269
starting from recording data from

00:03:50,790 --> 00:03:56,630
respect data and we basically did it in

00:03:54,269 --> 00:03:59,610
sort of like three conceptual steps

00:03:56,630 --> 00:04:02,190
first we took out some flexibility in

00:03:59,610 --> 00:04:04,140
the pub/sub model which basically allow

00:04:02,190 --> 00:04:06,200
us to have like more information about

00:04:04,140 --> 00:04:09,150
what the computational graph looks like

00:04:06,200 --> 00:04:12,540
once you have that you can actually

00:04:09,150 --> 00:04:14,970
control deterministically control when

00:04:12,540 --> 00:04:17,459
computations takes place by controlling

00:04:14,970 --> 00:04:18,840
the data flow across the nodes and

00:04:17,459 --> 00:04:22,650
finally you build some sort of

00:04:18,840 --> 00:04:24,410
acknowledgment system so that no

00:04:22,650 --> 00:04:26,270
basically you know when like a

00:04:24,410 --> 00:04:28,490
what is done computing even a set of

00:04:26,270 --> 00:04:33,100
input data and there's like a big team

00:04:28,490 --> 00:04:33,100
working on it so it's definitely not no

00:04:33,250 --> 00:04:38,360
second part of the talk is going to be

00:04:35,570 --> 00:04:42,590
some stuff that we ran into on sort of

00:04:38,360 --> 00:04:45,230
core framework stuff the way you write

00:04:42,590 --> 00:04:46,970
code in in Ross is that you need you

00:04:45,230 --> 00:04:48,680
functionality so maybe you spin up and

00:04:46,970 --> 00:04:51,560
you know it eventually maybe you move

00:04:48,680 --> 00:04:53,330
into a node that if your system is

00:04:51,560 --> 00:04:57,380
actually loaded and we have like a lot

00:04:53,330 --> 00:04:59,360
of CPU cores your Linux OS then becomes

00:04:57,380 --> 00:05:01,730
very confusing confused because it has

00:04:59,360 --> 00:05:04,280
like thousands of threads to schedule

00:05:01,730 --> 00:05:07,610
but he only has like a few dozen CPU

00:05:04,280 --> 00:05:08,990
cores so which thread gets to run and of

00:05:07,610 --> 00:05:11,030
course you can do a lot of work on like

00:05:08,990 --> 00:05:13,400
kernel level scheduling and stuff like

00:05:11,030 --> 00:05:15,950
that but the cool problem remains that

00:05:13,400 --> 00:05:17,540
this adds like a lot of worst case

00:05:15,950 --> 00:05:21,640
latency to the system you got like

00:05:17,540 --> 00:05:24,410
latency spike spikes timing issues and

00:05:21,640 --> 00:05:26,600
we mostly work around it by basically

00:05:24,410 --> 00:05:29,240
pinning threads the course and like

00:05:26,600 --> 00:05:32,720
stuff like that but that's not really

00:05:29,240 --> 00:05:35,990
nice a second problem on the sort of

00:05:32,720 --> 00:05:38,300
like framework stuff is that Ross

00:05:35,990 --> 00:05:39,590
basically shuffles messages around but

00:05:38,300 --> 00:05:41,210
it doesn't really give you like a nice

00:05:39,590 --> 00:05:42,680
way to keep track of what those

00:05:41,210 --> 00:05:45,260
components are actually doing with the

00:05:42,680 --> 00:05:47,840
data so you can really track track how

00:05:45,260 --> 00:05:50,300
where your view time is spent and

00:05:47,840 --> 00:05:52,400
typically this shows up as some

00:05:50,300 --> 00:05:54,710
downstream come flow component is late

00:05:52,400 --> 00:05:58,370
and you don't really know where in the

00:05:54,710 --> 00:06:00,200
sort of like upstream stack the problem

00:05:58,370 --> 00:06:02,120
actually is so we build some tooling

00:06:00,200 --> 00:06:04,190
around the chrome trace viewer that

00:06:02,120 --> 00:06:06,200
basically allows you to visualize some

00:06:04,190 --> 00:06:09,140
sort of flame graphs throughout the

00:06:06,200 --> 00:06:12,290
system and we also basically extend it

00:06:09,140 --> 00:06:14,330
sort of the Ross CBP API so we can pass

00:06:12,290 --> 00:06:17,540
up contextual information that can

00:06:14,330 --> 00:06:20,810
collect runtime send the samples about

00:06:17,540 --> 00:06:22,250
the data and this is basically what it

00:06:20,810 --> 00:06:24,680
looks like and you can see basically

00:06:22,250 --> 00:06:26,630
different threads of execution there

00:06:24,680 --> 00:06:29,540
could be multiple cores and then like a

00:06:26,630 --> 00:06:31,790
flame graph of love basically where the

00:06:29,540 --> 00:06:32,830
CPU time is actually spent and some sort

00:06:31,790 --> 00:06:38,380
of like

00:06:32,830 --> 00:06:40,210
see management's the first the last sort

00:06:38,380 --> 00:06:42,010
of area I want to talk about is

00:06:40,210 --> 00:06:44,380
developer tooling basically when you

00:06:42,010 --> 00:06:47,620
have 500 engineers working on a problem

00:06:44,380 --> 00:06:49,150
like any sort of like little like

00:06:47,620 --> 00:06:52,090
problem that you have is basically lost

00:06:49,150 --> 00:06:53,800
waste wasted time and money right so we

00:06:52,090 --> 00:06:56,940
try to basically polish what's already

00:06:53,800 --> 00:06:59,530
available in the in the Ross community

00:06:56,940 --> 00:07:01,540
the first thing is about like Rosberg

00:06:59,530 --> 00:07:03,430
recording data of course you want to be

00:07:01,540 --> 00:07:04,360
you need a lot of data basically to

00:07:03,430 --> 00:07:07,420
develop these machine learning

00:07:04,360 --> 00:07:08,770
algorithms right and backs are good for

00:07:07,420 --> 00:07:11,230
logging that just stream that it are

00:07:08,770 --> 00:07:12,940
directly from ross cpp but the file

00:07:11,230 --> 00:07:15,250
format is not really good for like big

00:07:12,940 --> 00:07:17,710
data stuff and ross realization is

00:07:15,250 --> 00:07:19,420
really is really not nice when you

00:07:17,710 --> 00:07:20,560
develop a system over time because as

00:07:19,420 --> 00:07:23,410
soon as you changed the message

00:07:20,560 --> 00:07:24,790
definition you need to basically process

00:07:23,410 --> 00:07:27,250
all the data again because you cannot

00:07:24,790 --> 00:07:28,930
read it anymore and there's really no

00:07:27,250 --> 00:07:31,930
nice way around this we have to be like

00:07:28,930 --> 00:07:33,640
a lot of like data infrastructure to

00:07:31,930 --> 00:07:35,470
basically sort of work around this

00:07:33,640 --> 00:07:38,650
problem and allow us to do sort of like

00:07:35,470 --> 00:07:42,130
batch operations or like a ton of data

00:07:38,650 --> 00:07:44,650
that we collect over time a second point

00:07:42,130 --> 00:07:47,710
is that like the sort of ross ecosystem

00:07:44,650 --> 00:07:49,560
comes with like a lot of nice GUI tools

00:07:47,710 --> 00:07:52,180
like our QT arvid's

00:07:49,560 --> 00:07:54,040
they're very flexible but they need sort

00:07:52,180 --> 00:07:57,580
of like a Linux workstation running with

00:07:54,040 --> 00:08:00,670
Ross and there's so modeler that there's

00:07:57,580 --> 00:08:02,380
like a steep learning curve to them so

00:08:00,670 --> 00:08:04,630
what we did a cruise was creating sort

00:08:02,380 --> 00:08:07,090
of like a more monolithic but still

00:08:04,630 --> 00:08:09,370
customizable web interface for this so

00:08:07,090 --> 00:08:12,730
that you can basically just connect and

00:08:09,370 --> 00:08:14,560
stream data and finally a bit about the

00:08:12,730 --> 00:08:17,590
build system of course we have a lot of

00:08:14,560 --> 00:08:20,350
CPP code and C++ is really slow to

00:08:17,590 --> 00:08:21,820
compile on top of that catkin is really

00:08:20,350 --> 00:08:25,000
modular so it needs to do like a bunch

00:08:21,820 --> 00:08:27,340
of configuration every time accrues we

00:08:25,000 --> 00:08:29,740
switched over to basic basil which is

00:08:27,340 --> 00:08:30,520
basically the open-source version of the

00:08:29,740 --> 00:08:32,740
internal

00:08:30,520 --> 00:08:35,740
build system that Google use and that

00:08:32,740 --> 00:08:37,780
basically allowed us to build most or

00:08:35,740 --> 00:08:39,550
more most of our stuff from source

00:08:37,780 --> 00:08:41,890
avoiding like a lot of like weird link

00:08:39,550 --> 00:08:44,290
linker issues and stuff like that but

00:08:41,890 --> 00:08:45,279
still use the shared cache to spin up

00:08:44,290 --> 00:08:49,959
both our bills

00:08:45,279 --> 00:08:53,680
in NCI and basically the daily developer

00:08:49,959 --> 00:08:57,070
workflow I think I'm right on time so

00:08:53,680 --> 00:09:00,690
thanks a lot and we have any questions

00:08:57,070 --> 00:09:00,690
[Applause]

00:09:11,759 --> 00:09:18,309
yes sorry yes any plans to open through

00:09:15,879 --> 00:09:19,300
some of the web is yes there are plans

00:09:18,309 --> 00:09:20,499
underway to do it

00:09:19,300 --> 00:09:22,120
we just need to speed up some

00:09:20,499 --> 00:09:24,040
proprietary stuff as always but yeah

00:09:22,120 --> 00:09:25,240
it's nice works over WebSockets so you

00:09:24,040 --> 00:09:28,540
basically have some sort of web

00:09:25,240 --> 00:09:29,980
WebSocket component which is nice so you

00:09:28,540 --> 00:09:34,089
can do it over the Internet and you can

00:09:29,980 --> 00:09:36,579
be secured properly I have a question

00:09:34,089 --> 00:09:40,240
about the determinism layer simulation

00:09:36,579 --> 00:09:42,339
is is that also open source no this is

00:09:40,240 --> 00:09:43,870
so mixed up with like our own concerns

00:09:42,339 --> 00:09:46,839
that it's probably really hard to open

00:09:43,870 --> 00:09:49,379
source I have to say but probably some

00:09:46,839 --> 00:09:51,459
of the ideas can be reused I guess I

00:09:49,379 --> 00:09:52,990
mean of course I'm not speaking for the

00:09:51,459 --> 00:09:55,899
company that sort of my in my own

00:09:52,990 --> 00:09:58,259
opinion but I see it very hard all right

00:09:55,899 --> 00:09:58,259

YouTube URL: https://www.youtube.com/watch?v=dyLaHl08pAM


