Title: Advanced Spinnaker Pipelines: Unleashing the full power of SpEL - Mark Noe
Publication date: 2021-01-22
Playlist: Spinnaker Summit 2020
Description: 
	In this workshop, walk through the construction of advanced Spinnaker pipelines building in intelligence using the power of SpEL, Spring Expression Language. SpEL is “a powerful expression that supports querying and manipulating an object graph at runtime.” Put another way, SpEL is how you can make decisions and take specific actions dynamically from within a running pipeline. This workshop is led by Armory Solutions Architects who spend maybe a bit too much time making pipelines do flashy things.
Captions: 
	00:00:00,530 --> 00:00:03,629
[Music]

00:00:05,600 --> 00:00:08,240
good morning spinnaker summit and

00:00:06,799 --> 00:00:11,280
welcome to the advanced

00:00:08,240 --> 00:00:14,320
spinnaker pipelines

00:00:11,280 --> 00:00:15,679
workshop uh going over advanced pipeline

00:00:14,320 --> 00:00:17,279
patterns and uh

00:00:15,679 --> 00:00:19,520
how you can power them with uh spring

00:00:17,279 --> 00:00:21,359
expression language my name is mark noe

00:00:19,520 --> 00:00:22,720
and i'll be the solutions architect

00:00:21,359 --> 00:00:25,680
from armory who will be walking you

00:00:22,720 --> 00:00:25,680
through the presentation

00:00:28,560 --> 00:00:31,840
so to get started we'll give a little

00:00:29,760 --> 00:00:33,920
bit of background about myself right

00:00:31,840 --> 00:00:35,440
like i said my name is mark i've been a

00:00:33,920 --> 00:00:36,719
solutions architect at armory uh

00:00:35,440 --> 00:00:38,480
supporting enterprise uh

00:00:36,719 --> 00:00:39,840
customers implementing spinnaker for

00:00:38,480 --> 00:00:42,000
about a year now

00:00:39,840 --> 00:00:43,920
uh my background i have a bachelor's in

00:00:42,000 --> 00:00:45,360
oceanography so i didn't actually study

00:00:43,920 --> 00:00:47,920
computer science or anything

00:00:45,360 --> 00:00:50,079
close to it when i was in school uh

00:00:47,920 --> 00:00:51,680
served in the navy drove ships uh

00:00:50,079 --> 00:00:54,320
finished up my time in the navy working

00:00:51,680 --> 00:00:54,320
in the basement of the

00:00:55,039 --> 00:00:59,280
whole series of stories but over the

00:00:57,840 --> 00:01:01,280
past 10 years i've held a variety of

00:00:59,280 --> 00:01:03,920
roles in the software industry

00:01:01,280 --> 00:01:05,119
um starting out as a software specialist

00:01:03,920 --> 00:01:08,080
i became a trainer

00:01:05,119 --> 00:01:10,159
uh got into project management both kind

00:01:08,080 --> 00:01:11,840
of traditional

00:01:10,159 --> 00:01:14,320
waterfall project management and then

00:01:11,840 --> 00:01:16,320
over into agile um

00:01:14,320 --> 00:01:18,000
ended up then kind of continuing to work

00:01:16,320 --> 00:01:19,200
backwards in the process and got into

00:01:18,000 --> 00:01:20,640
full stack engineering

00:01:19,200 --> 00:01:22,560
became an engineering lead now i'm a

00:01:20,640 --> 00:01:26,159
solutions architect so

00:01:22,560 --> 00:01:27,439
variety of experiences um and uh really

00:01:26,159 --> 00:01:29,040
it's kind of put me in a good position

00:01:27,439 --> 00:01:30,720
to work with spinnaker

00:01:29,040 --> 00:01:31,920
uh with all the knowledge of kind of not

00:01:30,720 --> 00:01:33,680
only ears are going to leverage the

00:01:31,920 --> 00:01:34,799
capability but really the the business

00:01:33,680 --> 00:01:39,200
value that it brings

00:01:34,799 --> 00:01:40,880
to enterprises so as far as our workshop

00:01:39,200 --> 00:01:43,040
agenda goes

00:01:40,880 --> 00:01:44,640
we'll be working through a short slide

00:01:43,040 --> 00:01:45,200
deck just want to kind of level set on

00:01:44,640 --> 00:01:48,320
that

00:01:45,200 --> 00:01:50,479
this is not death by powerpoint um we'll

00:01:48,320 --> 00:01:51,759
go through pipeline expression basics uh

00:01:50,479 --> 00:01:53,920
two quick slides

00:01:51,759 --> 00:01:54,960
pulling those from armory's uh training

00:01:53,920 --> 00:01:57,119
that i built

00:01:54,960 --> 00:01:58,960
um really just a level set don't want to

00:01:57,119 --> 00:02:00,159
make any assumptions that everyone

00:01:58,960 --> 00:02:02,479
is just going to be able to read a

00:02:00,159 --> 00:02:05,280
pipeline expression

00:02:02,479 --> 00:02:06,000
then even though this is really about

00:02:05,280 --> 00:02:08,399
advanced

00:02:06,000 --> 00:02:09,840
spinnaker pipelines to really understand

00:02:08,399 --> 00:02:12,319
kind of what i'm going to show you later

00:02:09,840 --> 00:02:14,239
in the pipeline examples uh you can walk

00:02:12,319 --> 00:02:15,360
through a few slides that kind of go

00:02:14,239 --> 00:02:18,640
through some

00:02:15,360 --> 00:02:20,239
um you know lesser used uh capabilities

00:02:18,640 --> 00:02:20,560
inside of spring expression language

00:02:20,239 --> 00:02:22,879
that

00:02:20,560 --> 00:02:25,440
i leverage whenever i'm building complex

00:02:22,879 --> 00:02:25,440
pipelines

00:02:26,319 --> 00:02:29,040
so to start off we'll kind of go through

00:02:27,840 --> 00:02:30,879
a little bit of pipeline expression

00:02:29,040 --> 00:02:32,800
basics

00:02:30,879 --> 00:02:34,239
a pipeline expression you know as many

00:02:32,800 --> 00:02:35,120
of you may already know allows you to

00:02:34,239 --> 00:02:37,280
access the data

00:02:35,120 --> 00:02:38,400
generated during a pipeline's execution

00:02:37,280 --> 00:02:41,760
right it's using

00:02:38,400 --> 00:02:43,120
an expression syntax based on the spring

00:02:41,760 --> 00:02:46,560
expression language

00:02:43,120 --> 00:02:49,599
i think a lot of folks talk about

00:02:46,560 --> 00:02:51,280
the the query syntax the search syntax

00:02:49,599 --> 00:02:54,000
of spring expression language in

00:02:51,280 --> 00:02:54,319
spinnaker just a spell but really inside

00:02:54,000 --> 00:02:56,959
of

00:02:54,319 --> 00:02:57,840
uh spinnaker it's an implementation of

00:02:56,959 --> 00:02:59,280
spell

00:02:57,840 --> 00:03:00,959
that really gives the pipeline

00:02:59,280 --> 00:03:02,159
expressions capability so it's it's

00:03:00,959 --> 00:03:03,920
built on spell

00:03:02,159 --> 00:03:05,599
it's not a direct implementation of

00:03:03,920 --> 00:03:06,480
spell so not every feature of spell is

00:03:05,599 --> 00:03:08,879
available

00:03:06,480 --> 00:03:10,159
but most of them are um pipeline

00:03:08,879 --> 00:03:12,159
expressions can be used in most of the

00:03:10,159 --> 00:03:14,159
text fields of pipeline stage and if you

00:03:12,159 --> 00:03:15,120
don't see a pipeline text field you can

00:03:14,159 --> 00:03:19,840
usually uh

00:03:15,120 --> 00:03:19,840
just edit the pipeline json

00:03:20,080 --> 00:03:25,120
as as needed using the edit as json for

00:03:23,280 --> 00:03:27,360
the pipeline

00:03:25,120 --> 00:03:28,480
um pipeline expressions i mean the power

00:03:27,360 --> 00:03:30,720
becomes is that you can

00:03:28,480 --> 00:03:32,080
really evaluate the data as the

00:03:30,720 --> 00:03:33,920
pipeline's being executed

00:03:32,080 --> 00:03:35,680
to set dynamic variables to find

00:03:33,920 --> 00:03:36,959
arbitrary values and perform basic

00:03:35,680 --> 00:03:40,319
calculations

00:03:36,959 --> 00:03:40,319
and even leverage boolean

00:03:44,080 --> 00:03:47,680
your pipeline based on its own state you

00:03:46,560 --> 00:03:49,360
know to uh

00:03:47,680 --> 00:03:50,720
you know an outcome that you're looking

00:03:49,360 --> 00:03:52,879
to achieve

00:03:50,720 --> 00:03:54,159
uh key points of usage you know we see

00:03:52,879 --> 00:03:57,040
uh people

00:03:54,159 --> 00:04:01,680
uh accessing parameters uh defined

00:03:57,040 --> 00:04:03,920
within the pipeline

00:04:01,680 --> 00:04:06,799
a single point use case to maybe being

00:04:03,920 --> 00:04:08,640
able to use to deploy many applications

00:04:06,799 --> 00:04:10,239
using the evaluate variable stage to

00:04:08,640 --> 00:04:11,360
conditionally trigger or terminate

00:04:10,239 --> 00:04:13,280
pipeline branches

00:04:11,360 --> 00:04:14,879
and really the ability to even branch

00:04:13,280 --> 00:04:17,919
pipelines is powered by

00:04:14,879 --> 00:04:19,680
pipeline expressions turning on or off

00:04:17,919 --> 00:04:21,120
particular pipeline stages

00:04:19,680 --> 00:04:24,479
and then of course checking the status

00:04:21,120 --> 00:04:24,479
of a previous stage as well

00:04:24,960 --> 00:04:28,320
now the basics of a pipeline expression

00:04:26,800 --> 00:04:29,680
is that it's made up of a dollar sign

00:04:28,320 --> 00:04:31,199
followed by an opening and closing

00:04:29,680 --> 00:04:32,479
bracket that's what really tells

00:04:31,199 --> 00:04:33,840
spinnaker hey this is a

00:04:32,479 --> 00:04:36,479
this is an expression that needs to be

00:04:33,840 --> 00:04:37,759
evaluated evaluate it and then you know

00:04:36,479 --> 00:04:42,000
substitute in

00:04:37,759 --> 00:04:43,600
the uh result in into this place in uh

00:04:42,000 --> 00:04:45,440
whether it's the pipe whether it's the

00:04:43,600 --> 00:04:48,080
states stages configuration or

00:04:45,440 --> 00:04:50,160
into a kubernetes manifest if an

00:04:48,080 --> 00:04:52,400
expression can't be evaluated

00:04:50,160 --> 00:04:53,440
spinnaker simply returns the text of the

00:04:52,400 --> 00:04:58,240
if the expression

00:04:53,440 --> 00:05:00,320
fails it will fail your pipeline overall

00:04:58,240 --> 00:05:01,520
expressions cannot be nested within

00:05:00,320 --> 00:05:04,160
other expressions

00:05:01,520 --> 00:05:06,240
it's another point of confusion um it's

00:05:04,160 --> 00:05:08,000
uh not necessarily called out in all the

00:05:06,240 --> 00:05:11,440
documentation well but i have tested

00:05:08,000 --> 00:05:14,960
this multiple

00:05:11,440 --> 00:05:16,960
many times myself you can't put a

00:05:14,960 --> 00:05:18,400
you know dollar sign open close curly

00:05:16,960 --> 00:05:20,720
brace inside of another one

00:05:18,400 --> 00:05:22,160
and look for spinnaker to compile that

00:05:20,720 --> 00:05:24,000
for you

00:05:22,160 --> 00:05:25,840
uh like i said mentioned earlier you

00:05:24,000 --> 00:05:26,400
know you can use an expression any text

00:05:25,840 --> 00:05:28,400
field

00:05:26,400 --> 00:05:29,840
uh with the one exception being at the

00:05:28,400 --> 00:05:31,680
very beginning of a pipeline in the

00:05:29,840 --> 00:05:34,080
pipeline configuration

00:05:31,680 --> 00:05:36,880
uh and if a text field is not available

00:05:34,080 --> 00:05:39,199
just open up the edit as json feature

00:05:36,880 --> 00:05:41,440
and use the uh pipeline expression right

00:05:39,199 --> 00:05:43,440
there in the raw

00:05:41,440 --> 00:05:45,039
expressions on page with the exception

00:05:43,440 --> 00:05:46,080
of that pipeline configuration like i

00:05:45,039 --> 00:05:48,000
mentioned

00:05:46,080 --> 00:05:49,360
so as you can see over on the right you

00:05:48,000 --> 00:05:50,080
uh i've kind of laid out a little bit of

00:05:49,360 --> 00:05:52,240
an example

00:05:50,080 --> 00:05:53,840
right so you have a an execution context

00:05:52,240 --> 00:05:56,080
which is really just a json blob

00:05:53,840 --> 00:05:57,120
a bunch of information in it you might

00:05:56,080 --> 00:05:58,880
see the type

00:05:57,120 --> 00:06:00,960
which is going to be pipeline you see

00:05:58,880 --> 00:06:02,720
the id for

00:06:00,960 --> 00:06:04,560
that particular pipeline that's

00:06:02,720 --> 00:06:06,560
executing you'll see the application

00:06:04,560 --> 00:06:08,880
that's associated with it the name

00:06:06,560 --> 00:06:10,160
you know you'll see an array of uh

00:06:08,880 --> 00:06:12,240
stages

00:06:10,160 --> 00:06:14,080
uh an object with a bunch of information

00:06:12,240 --> 00:06:15,759
about what triggered it maybe a pipeline

00:06:14,080 --> 00:06:17,520
config id this is really truncated

00:06:15,759 --> 00:06:19,600
there's more information in there

00:06:17,520 --> 00:06:20,560
but for the purposes of this little

00:06:19,600 --> 00:06:22,319
example

00:06:20,560 --> 00:06:23,840
you know we'll look at that and say okay

00:06:22,319 --> 00:06:26,080
well maybe i want to return

00:06:23,840 --> 00:06:27,600
using spring expression language the

00:06:26,080 --> 00:06:29,840
name of this pipeline and i would do

00:06:27,600 --> 00:06:34,400
that by writing a dollar sign open

00:06:29,840 --> 00:06:36,800
open curly brace execution dot name

00:06:34,400 --> 00:06:38,560
and then you know close that out and the

00:06:36,800 --> 00:06:41,199
result of that expression would be

00:06:38,560 --> 00:06:42,400
basic pipeline right because you can see

00:06:41,199 --> 00:06:44,400
the overall top

00:06:42,400 --> 00:06:46,000
level of this object is referred to as

00:06:44,400 --> 00:06:48,880
the execution and then

00:06:46,000 --> 00:06:51,919
mapping down dot name gets you to name

00:06:48,880 --> 00:06:53,919
and then you get basic pipeline

00:06:51,919 --> 00:06:55,440
so now we've got a level set on geez

00:06:53,919 --> 00:06:57,520
what the heck is a pipeline expression

00:06:55,440 --> 00:07:01,199
for those of you who might be new

00:06:57,520 --> 00:07:03,280
um we'll get into some advanced features

00:07:01,199 --> 00:07:05,199
right so we'll talk about defining a

00:07:03,280 --> 00:07:08,560
pipeline variable as a map

00:07:05,199 --> 00:07:10,160
right uh the syntax for this would be

00:07:08,560 --> 00:07:11,759
you know setting a variable name and

00:07:10,160 --> 00:07:13,520
i've set this up to be a lot like the

00:07:11,759 --> 00:07:15,759
evaluate variable stage

00:07:13,520 --> 00:07:17,120
inside of spinnaker where you get an

00:07:15,759 --> 00:07:18,720
input field for the variable name and

00:07:17,120 --> 00:07:19,599
then an input field for the variable

00:07:18,720 --> 00:07:21,199
value

00:07:19,599 --> 00:07:23,120
so in this case i might want to say well

00:07:21,199 --> 00:07:25,759
really i want a map or an

00:07:23,120 --> 00:07:26,800
object that has a couple of key value

00:07:25,759 --> 00:07:29,919
pairs

00:07:26,800 --> 00:07:30,800
property 1 set at 100 property 2 set to

00:07:29,919 --> 00:07:32,240
true

00:07:30,800 --> 00:07:35,120
in order to do that you can see the

00:07:32,240 --> 00:07:38,160
syntax here right so my simple map

00:07:35,120 --> 00:07:39,120
would result when run in returning just

00:07:38,160 --> 00:07:41,680
that object

00:07:39,120 --> 00:07:43,199
right so it's a map or an object now the

00:07:41,680 --> 00:07:45,280
use case for doing this would be

00:07:43,199 --> 00:07:47,199
creating those predefined or hard-coded

00:07:45,280 --> 00:07:48,960
values within the pipeline

00:07:47,199 --> 00:07:51,199
for use with branching decisions and

00:07:48,960 --> 00:07:54,960
logic i've leveraged uh

00:07:51,199 --> 00:07:57,840
maps to kind of set strategies

00:07:54,960 --> 00:07:59,360
for traffic management whenever i'm

00:07:57,840 --> 00:08:01,840
using the

00:07:59,360 --> 00:08:02,960
canary annotation of the nginx ingress

00:08:01,840 --> 00:08:05,199
controller

00:08:02,960 --> 00:08:06,000
and so whenever i'm deploying to the dev

00:08:05,199 --> 00:08:08,639
environment

00:08:06,000 --> 00:08:09,840
i might say you know what let's just

00:08:08,639 --> 00:08:13,919
deploy it

00:08:09,840 --> 00:08:16,400
and move 50 of our traffic over um

00:08:13,919 --> 00:08:18,319
uh during the first you know part of the

00:08:16,400 --> 00:08:19,759
rollout you know basically strategy one

00:08:18,319 --> 00:08:22,080
would be let's shift 50

00:08:19,759 --> 00:08:22,800
of the traffic straight uh and then

00:08:22,080 --> 00:08:25,759
let's shift

00:08:22,800 --> 00:08:27,120
uh 100 of the traffic or strategy two

00:08:25,759 --> 00:08:29,280
would be really for

00:08:27,120 --> 00:08:30,800
you know production where i'm gonna go

00:08:29,280 --> 00:08:32,240
five percent of the traffic

00:08:30,800 --> 00:08:34,080
fifteen percent of the traffic

00:08:32,240 --> 00:08:35,440
twenty-five percent of the traffic fifty

00:08:34,080 --> 00:08:37,440
and then one hundred

00:08:35,440 --> 00:08:39,680
right and so rather than have to hard

00:08:37,440 --> 00:08:41,760
code that into every stage i

00:08:39,680 --> 00:08:43,120
set an evaluate variable stage

00:08:41,760 --> 00:08:45,040
pre-define

00:08:43,120 --> 00:08:48,519
the various strategies i might want to

00:08:45,040 --> 00:08:51,440
use and then based on the input of a

00:08:48,519 --> 00:08:52,640
pipeline parameter whenever i choose to

00:08:51,440 --> 00:08:55,200
run my

00:08:52,640 --> 00:08:59,120
pipeline i would select the strategy and

00:08:55,200 --> 00:08:59,120
then the pipeline takes care of the rest

00:08:59,760 --> 00:09:03,760
now you can also define a pipeline

00:09:01,200 --> 00:09:04,880
variable as a list right syntax is very

00:09:03,760 --> 00:09:06,880
similar to

00:09:04,880 --> 00:09:08,080
setting it as a map right so my simple

00:09:06,880 --> 00:09:10,959
list

00:09:08,080 --> 00:09:12,480
would be just uh the same syntax but

00:09:10,959 --> 00:09:13,120
instead of key value pairs i just have

00:09:12,480 --> 00:09:14,880
values

00:09:13,120 --> 00:09:16,560
right so i have value one by two value

00:09:14,880 --> 00:09:19,839
three

00:09:16,560 --> 00:09:20,959
the result of that uh is again an array

00:09:19,839 --> 00:09:23,839
or a list

00:09:20,959 --> 00:09:24,800
okay the use case is very similar here

00:09:23,839 --> 00:09:27,440
right you're just trying to set

00:09:24,800 --> 00:09:29,920
predefined or hard coded values

00:09:27,440 --> 00:09:31,200
uh kind of upstream at an evaluate

00:09:29,920 --> 00:09:34,080
variable stage you're going to use that

00:09:31,200 --> 00:09:36,640
for branching and decision logic

00:09:34,080 --> 00:09:38,720
one of the ways that i have used uh my

00:09:36,640 --> 00:09:42,959
sim you know like a list

00:09:38,720 --> 00:09:45,519
uh variable inside the expression

00:09:42,959 --> 00:09:47,360
or inside the pipeline is setting white

00:09:45,519 --> 00:09:49,519
lists and blacklists for

00:09:47,360 --> 00:09:52,240
you know kind of the next level of

00:09:49,519 --> 00:09:54,080
permission controls inside of a pipeline

00:09:52,240 --> 00:09:56,880
where spinnaker does provide our back

00:09:54,080 --> 00:09:58,800
with fiat at the application level

00:09:56,880 --> 00:10:00,480
where you can basically define what

00:09:58,800 --> 00:10:03,200
users can access the application and

00:10:00,480 --> 00:10:05,200
what users can execute pipelines

00:10:03,200 --> 00:10:07,120
if you use uh this approach where you

00:10:05,200 --> 00:10:10,880
can you can create a list

00:10:07,120 --> 00:10:14,000
of uh authorized users who can

00:10:10,880 --> 00:10:16,240
uh who are allowed

00:10:14,000 --> 00:10:18,160
to continue a particular branch of a

00:10:16,240 --> 00:10:20,160
pipeline so if you have a mono pipeline

00:10:18,160 --> 00:10:21,279
a monolith pipeline that deploys to all

00:10:20,160 --> 00:10:24,320
three

00:10:21,279 --> 00:10:29,200
um all three environments

00:10:24,320 --> 00:10:32,880
uh simultaneously you could uh instead

00:10:29,200 --> 00:10:36,160
you could add a preconditions check

00:10:32,880 --> 00:10:37,920
to the uh branch for production that

00:10:36,160 --> 00:10:41,279
basically says it has to be

00:10:37,920 --> 00:10:43,120
a user from this list that triggered the

00:10:41,279 --> 00:10:44,720
pipeline to even execute this part of

00:10:43,120 --> 00:10:46,000
the pipeline right so

00:10:44,720 --> 00:10:48,320
lists can be very valuable whenever

00:10:46,000 --> 00:10:51,680
you're trying to add a little bit of

00:10:48,320 --> 00:10:53,440
data validation on pipeline parameters

00:10:51,680 --> 00:10:54,880
or if you're trying to you know kind of

00:10:53,440 --> 00:10:57,839
create that next level

00:10:54,880 --> 00:10:57,839
enhancement to

00:10:58,480 --> 00:11:02,880
access controls inside the pipeline

00:11:00,480 --> 00:11:02,880
itself

00:11:03,440 --> 00:11:07,120
so the next feature that i tend to use

00:11:05,120 --> 00:11:08,480
uh quite a bit is checking if a value is

00:11:07,120 --> 00:11:09,360
contained in the list and this kind of

00:11:08,480 --> 00:11:15,360
gets to

00:11:09,360 --> 00:11:18,160
how i'm able to change

00:11:15,360 --> 00:11:19,040
execution context of every pipeline in

00:11:18,160 --> 00:11:21,600
the trigger

00:11:19,040 --> 00:11:23,519
element is the user that triggered it

00:11:21,600 --> 00:11:24,720
right so if i have a list of authorized

00:11:23,519 --> 00:11:27,360
users

00:11:24,720 --> 00:11:28,079
i can check the user in the trigger

00:11:27,360 --> 00:11:29,760
context

00:11:28,079 --> 00:11:32,320
and then make sure that that's in the

00:11:29,760 --> 00:11:34,399
list and if it is it gives me a true

00:11:32,320 --> 00:11:36,160
if it's not it gives me a false right so

00:11:34,399 --> 00:11:38,560
the syntax here would

00:11:36,160 --> 00:11:40,240
let's leverage that same simple list

00:11:38,560 --> 00:11:43,040
that i used before

00:11:40,240 --> 00:11:46,000
i would say my simple list dot contains

00:11:43,040 --> 00:11:48,079
and i'm looking for value number one

00:11:46,000 --> 00:11:49,120
the result would be a true now if i was

00:11:48,079 --> 00:11:51,600
looking for value

00:11:49,120 --> 00:11:53,279
four remember i only had value one value

00:11:51,600 --> 00:11:55,200
two value three

00:11:53,279 --> 00:11:57,360
this expression would actually return

00:11:55,200 --> 00:11:59,200
false right so that's how i can create

00:11:57,360 --> 00:12:01,200
those white lists and black lists that i

00:11:59,200 --> 00:12:02,720
can then use in the logic of my pipeline

00:12:01,200 --> 00:12:05,360
branches

00:12:02,720 --> 00:12:06,800
so like i said use cases would be

00:12:05,360 --> 00:12:08,480
implementing more robust pipeline

00:12:06,800 --> 00:12:10,240
parameter validation

00:12:08,480 --> 00:12:11,760
implementing finer grain white list and

00:12:10,240 --> 00:12:14,160
black men permissions and access

00:12:11,760 --> 00:12:16,560
controls within the pipeline itself

00:12:14,160 --> 00:12:18,560
and then setting a variable for use

00:12:16,560 --> 00:12:19,200
directly in a stage conditional on

00:12:18,560 --> 00:12:21,519
expression

00:12:19,200 --> 00:12:21,519
input

00:12:23,040 --> 00:12:26,160
now defining a pipeline variable as a

00:12:24,959 --> 00:12:29,760
result of a spell

00:12:26,160 --> 00:12:31,760
you know arithmetic so you can do math

00:12:29,760 --> 00:12:33,680
you can do pretty basic math you can do

00:12:31,760 --> 00:12:35,839
additions right

00:12:33,680 --> 00:12:37,440
i use this a lot whenever i'm looping

00:12:35,839 --> 00:12:40,240
pipelines or really

00:12:37,440 --> 00:12:40,240
looping's a bad

00:12:40,560 --> 00:12:46,639
word to use with it right it's really uh

00:12:43,920 --> 00:12:47,680
recursion of the same pipeline over and

00:12:46,639 --> 00:12:49,680
over and over again

00:12:47,680 --> 00:12:52,079
through a certain number of iterations

00:12:49,680 --> 00:12:52,560
right so in this case i might say my

00:12:52,079 --> 00:12:54,079
next

00:12:52,560 --> 00:12:56,320
you know my variable is the next

00:12:54,079 --> 00:12:58,160
iteration where

00:12:56,320 --> 00:12:59,920
it takes the iteration count that was

00:12:58,160 --> 00:13:02,639
passed into the pipeline

00:12:59,920 --> 00:13:03,680
converts it into an integer and then

00:13:02,639 --> 00:13:05,200
adds one

00:13:03,680 --> 00:13:08,399
right and there's kind of two different

00:13:05,200 --> 00:13:11,839
syntax the raw spell syntax would be

00:13:08,399 --> 00:13:14,240
you know new integer parameters dot

00:13:11,839 --> 00:13:16,000
iteration count plus one or you can use

00:13:14,240 --> 00:13:18,959
the helper function

00:13:16,000 --> 00:13:20,959
that is built into spinnaker itself

00:13:18,959 --> 00:13:24,320
where you can just say hashtag

00:13:20,959 --> 00:13:26,880
new or pound new int and then

00:13:24,320 --> 00:13:27,920
pass in the string it's important

00:13:26,880 --> 00:13:32,079
because all

00:13:27,920 --> 00:13:32,079
all values defined in

00:13:32,320 --> 00:13:36,240
whether through the evaluate variables

00:13:34,079 --> 00:13:38,000
or through the pipeline parameters

00:13:36,240 --> 00:13:39,600
actually get carried through the context

00:13:38,000 --> 00:13:41,040
as strings until you convert them into

00:13:39,600 --> 00:13:43,839
integers

00:13:41,040 --> 00:13:45,760
right so in this scenario the iteration

00:13:43,839 --> 00:13:47,680
count would be set to one

00:13:45,760 --> 00:13:49,279
and when i run this the result would be

00:13:47,680 --> 00:13:52,720
two and the result's actually an

00:13:49,279 --> 00:13:56,240
integer uh coming out of the

00:13:52,720 --> 00:13:57,839
math equation so use cases tracking the

00:13:56,240 --> 00:13:59,360
number of times a subordinate pipeline

00:13:57,839 --> 00:14:00,800
has been run during a self-looping

00:13:59,360 --> 00:14:02,560
iteration

00:14:00,800 --> 00:14:04,639
incremented a version number when

00:14:02,560 --> 00:14:08,079
manually versioning services or

00:14:04,639 --> 00:14:08,079
other kubernetes resources

00:14:09,040 --> 00:14:13,360
so another great feature is checking the

00:14:11,040 --> 00:14:14,880
length of a map or a list

00:14:13,360 --> 00:14:16,639
so the syntax for this would be a

00:14:14,880 --> 00:14:17,519
variable name the variable value set to

00:14:16,639 --> 00:14:20,399
my simple list

00:14:17,519 --> 00:14:20,800
size and the expression for that is

00:14:20,399 --> 00:14:23,519
again

00:14:20,800 --> 00:14:25,360
using that my simple list that had three

00:14:23,519 --> 00:14:26,399
values in it by one value two value

00:14:25,360 --> 00:14:28,880
three

00:14:26,399 --> 00:14:30,079
when i run that search or run that that

00:14:28,880 --> 00:14:32,880
expression the result

00:14:30,079 --> 00:14:35,040
would be a count of three and that is a

00:14:32,880 --> 00:14:36,959
type of an integer

00:14:35,040 --> 00:14:38,560
so the use cases here is really i use

00:14:36,959 --> 00:14:40,480
this a lot for determining if the

00:14:38,560 --> 00:14:44,160
previous stage has failed

00:14:40,480 --> 00:14:47,199
right and you could do that by combining

00:14:44,160 --> 00:14:48,399
not only the you know check of the

00:14:47,199 --> 00:14:51,600
length of the map

00:14:48,399 --> 00:14:54,040
but also with the map filter so a little

00:14:51,600 --> 00:14:56,800
more complex but i would be looking at

00:14:54,040 --> 00:15:00,079
execution.stages filtered

00:14:56,800 --> 00:15:03,600
down to any stages that have a status

00:15:00,079 --> 00:15:06,160
of failed underscore continue

00:15:03,600 --> 00:15:08,320
uh so in this in this scenario i would

00:15:06,160 --> 00:15:09,920
have pipelines that don't hard fail when

00:15:08,320 --> 00:15:10,959
a stage fails it actually fails

00:15:09,920 --> 00:15:14,079
continues so like

00:15:10,959 --> 00:15:16,160
ignore the failure continue on and then

00:15:14,079 --> 00:15:18,480
all subsequent stages would check and

00:15:16,160 --> 00:15:21,040
say is there any failures

00:15:18,480 --> 00:15:22,240
using that map filter check the size if

00:15:21,040 --> 00:15:24,480
it comes back zero

00:15:22,240 --> 00:15:26,480
i can run if it comes back greater than

00:15:24,480 --> 00:15:30,320
zero i'm not allowed to run

00:15:26,480 --> 00:15:30,320
i'm not gonna run mine i'm gonna move on

00:15:30,399 --> 00:15:34,160
and then all the subsequent stages would

00:15:32,160 --> 00:15:36,399
just um

00:15:34,160 --> 00:15:37,360
you know fail to execute and continue

00:15:36,399 --> 00:15:41,040
all the way till the end

00:15:37,360 --> 00:15:43,199
when i would hold it for a review

00:15:41,040 --> 00:15:44,160
so using regular expressions to match

00:15:43,199 --> 00:15:46,160
property value

00:15:44,160 --> 00:15:48,399
a little known feature but you can use

00:15:46,160 --> 00:15:50,000
regular expressions

00:15:48,399 --> 00:15:52,079
so in this case i'm sending a variable

00:15:50,000 --> 00:15:54,560
name of regex result

00:15:52,079 --> 00:15:56,240
and the variable value would be an

00:15:54,560 --> 00:15:59,839
expression where i'm looking for

00:15:56,240 --> 00:16:03,040
a property that matches uh

00:15:59,839 --> 00:16:06,000
failure or the the string f a i

00:16:03,040 --> 00:16:07,199
l um okay you got to be aware of

00:16:06,000 --> 00:16:08,800
whenever you're using the regular

00:16:07,199 --> 00:16:10,720
expression syntax as spell

00:16:08,800 --> 00:16:11,920
is that you have to match the entire

00:16:10,720 --> 00:16:15,120
string

00:16:11,920 --> 00:16:17,519
right so if you're looking to imagine a

00:16:15,120 --> 00:16:19,519
partial of the string that that would be

00:16:17,519 --> 00:16:22,079
contained inside of that

00:16:19,519 --> 00:16:24,000
context element you actually have to

00:16:22,079 --> 00:16:25,839
begin the expression with a period

00:16:24,000 --> 00:16:28,399
followed by an asterisk and end it with

00:16:25,839 --> 00:16:30,000
a period followed by an asterisk

00:16:28,399 --> 00:16:32,079
so the use case here would be

00:16:30,000 --> 00:16:34,160
determining if any previous stage failed

00:16:32,079 --> 00:16:36,079
regardless of the type of failure

00:16:34,160 --> 00:16:37,279
right so taking that same syntax from

00:16:36,079 --> 00:16:40,240
before where i was

00:16:37,279 --> 00:16:42,320
filtering the execution stages instead

00:16:40,240 --> 00:16:44,240
of looking for a strict match on failed

00:16:42,320 --> 00:16:46,000
undersoar continue

00:16:44,240 --> 00:16:47,360
i would be looking for a status that

00:16:46,000 --> 00:16:51,040
matches

00:16:47,360 --> 00:16:53,759
uh any string that contains fail

00:16:51,040 --> 00:16:56,880
uh followed by any characters afterwards

00:16:53,759 --> 00:16:56,880
right and then check the size

00:16:57,759 --> 00:17:01,680
so let's work through a few examples

00:17:00,240 --> 00:17:03,440
right and um

00:17:01,680 --> 00:17:06,000
each of these examples leverages an

00:17:03,440 --> 00:17:07,919
element of or several elements of what

00:17:06,000 --> 00:17:10,000
we just walked through

00:17:07,919 --> 00:17:11,120
so let me move over to my spinnaker and

00:17:10,000 --> 00:17:13,120
i've got

00:17:11,120 --> 00:17:14,480
really two examples but three pipelines

00:17:13,120 --> 00:17:16,880
to walk through

00:17:14,480 --> 00:17:19,199
we'll start with that first one about

00:17:16,880 --> 00:17:21,120
failing stages but not hard failing them

00:17:19,199 --> 00:17:23,520
and you know failing them and continuing

00:17:21,120 --> 00:17:25,039
them this really came out of a use case

00:17:23,520 --> 00:17:28,000
from one of our customers

00:17:25,039 --> 00:17:31,120
that was looking to prevent further

00:17:28,000 --> 00:17:33,760
pipeline executions

00:17:31,120 --> 00:17:34,640
if there was a failure on a previous

00:17:33,760 --> 00:17:37,440
execution

00:17:34,640 --> 00:17:39,280
right and so looking across uh pipeline

00:17:37,440 --> 00:17:40,400
executions and spinnaker's not really

00:17:39,280 --> 00:17:42,799
possible

00:17:40,400 --> 00:17:44,400
uh you can you know if a pipeline

00:17:42,799 --> 00:17:46,480
triggers another pipeline you can pass

00:17:44,400 --> 00:17:47,919
in that execution context but you're not

00:17:46,480 --> 00:17:49,679
actually searching

00:17:47,919 --> 00:17:51,440
two different execution contacts you're

00:17:49,679 --> 00:17:52,480
just searching the previous execution

00:17:51,440 --> 00:17:55,440
context

00:17:52,480 --> 00:17:56,080
inside the new pipelines context right

00:17:55,440 --> 00:17:58,160
so

00:17:56,080 --> 00:17:59,440
if you don't want to do that how do you

00:17:58,160 --> 00:18:01,600
make sure that

00:17:59,440 --> 00:18:04,320
no subsequent pipelines continue to

00:18:01,600 --> 00:18:07,360
proceed continue to execute

00:18:04,320 --> 00:18:07,919
if if the previous one failed well you

00:18:07,360 --> 00:18:11,039
do that

00:18:07,919 --> 00:18:11,679
by structuring a pipeline first and

00:18:11,039 --> 00:18:14,000
foremost

00:18:11,679 --> 00:18:16,080
using the execution option to disable

00:18:14,000 --> 00:18:17,919
concur pipeline executions

00:18:16,080 --> 00:18:19,200
so that makes sure that only one can run

00:18:17,919 --> 00:18:22,640
at a time

00:18:19,200 --> 00:18:24,559
so now that we can make it so that only

00:18:22,640 --> 00:18:26,799
one runs at a time

00:18:24,559 --> 00:18:28,400
how do we keep one running right so if

00:18:26,799 --> 00:18:30,960
we let a stage

00:18:28,400 --> 00:18:32,880
fail hard the pipeline will actually

00:18:30,960 --> 00:18:35,919
stop running and the next execution

00:18:32,880 --> 00:18:38,000
will run right um so we have to figure

00:18:35,919 --> 00:18:42,799
out some way to

00:18:38,000 --> 00:18:45,360
basically pause the execution um

00:18:42,799 --> 00:18:47,200
but not with human intervention right we

00:18:45,360 --> 00:18:48,640
don't want to put a manual judgment

00:18:47,200 --> 00:18:50,240
stage at the end of every one of these

00:18:48,640 --> 00:18:51,440
deployments and make somebody have to go

00:18:50,240 --> 00:18:53,200
in and look

00:18:51,440 --> 00:18:54,799
to make sure that that that stage

00:18:53,200 --> 00:18:56,799
completed

00:18:54,799 --> 00:18:59,440
move move through that kind of defeats

00:18:56,799 --> 00:19:01,679
the entire philosophy of spinnaker

00:18:59,440 --> 00:19:02,480
which is continuous automated you know

00:19:01,679 --> 00:19:06,160
deployment

00:19:02,480 --> 00:19:09,039
right so uh by using this

00:19:06,160 --> 00:19:10,080
uh this configuration point in the

00:19:09,039 --> 00:19:12,320
config

00:19:10,080 --> 00:19:14,400
i then have set up three develop

00:19:12,320 --> 00:19:15,120
deployment stages now for the purposes

00:19:14,400 --> 00:19:16,960
of

00:19:15,120 --> 00:19:18,960
uh demonstration i'm not actually going

00:19:16,960 --> 00:19:20,640
to deploy to kubernetes

00:19:18,960 --> 00:19:22,720
these while i've named them deployment

00:19:20,640 --> 00:19:24,160
stages they're actually wade stages

00:19:22,720 --> 00:19:25,679
right so we have a stage here that's

00:19:24,160 --> 00:19:26,799
going to hold for five seconds just to

00:19:25,679 --> 00:19:29,600
kind of show that

00:19:26,799 --> 00:19:30,640
spinnaker would be taking an action uh

00:19:29,600 --> 00:19:32,000
the next one

00:19:30,640 --> 00:19:34,080
it's not actually a weight it's a

00:19:32,000 --> 00:19:36,559
conditional right this is where uh

00:19:34,080 --> 00:19:37,679
based on my pipeline parameter i'm going

00:19:36,559 --> 00:19:39,440
to trick

00:19:37,679 --> 00:19:41,360
spinnaker into thinking that a failure

00:19:39,440 --> 00:19:44,320
occurred right

00:19:41,360 --> 00:19:45,120
and when the failure occurs what i want

00:19:44,320 --> 00:19:46,960
to have happen

00:19:45,120 --> 00:19:48,480
is i want deployment the subsequent

00:19:46,960 --> 00:19:49,039
stage of deployment three which is

00:19:48,480 --> 00:19:52,240
another way

00:19:49,039 --> 00:19:54,000
i want that to be skipped right and i

00:19:52,240 --> 00:19:55,280
want

00:19:54,000 --> 00:19:56,880
that to skip because there was a

00:19:55,280 --> 00:19:58,320
previous failure and then i want the

00:19:56,880 --> 00:20:00,880
pipeline to

00:19:58,320 --> 00:20:01,520
hold with a manual judgment for review

00:20:00,880 --> 00:20:03,200
when a

00:20:01,520 --> 00:20:05,120
manual judgment is waiting for review

00:20:03,200 --> 00:20:06,720
that pipeline is still running

00:20:05,120 --> 00:20:08,559
and when that pipeline's running it's

00:20:06,720 --> 00:20:11,919
preventing all the previous ones

00:20:08,559 --> 00:20:13,760
from executing right so

00:20:11,919 --> 00:20:15,520
with this pipeline containing a failure

00:20:13,760 --> 00:20:17,280
manual judgment kicks off but i

00:20:15,520 --> 00:20:18,880
only want it to kick off when there's a

00:20:17,280 --> 00:20:22,720
failure right

00:20:18,880 --> 00:20:25,039
so deployment two would only execute

00:20:22,720 --> 00:20:27,360
uh if uh my pipeline parameter that i

00:20:25,039 --> 00:20:29,440
pass in which is a force failure

00:20:27,360 --> 00:20:31,520
is true so really let's take a look at

00:20:29,440 --> 00:20:34,320
deployment number three

00:20:31,520 --> 00:20:35,039
it's only going to execute if the result

00:20:34,320 --> 00:20:38,480
of that

00:20:35,039 --> 00:20:41,600
uh you know map filter size judgment

00:20:38,480 --> 00:20:44,400
uh or expression comes back as zero

00:20:41,600 --> 00:20:46,240
so if that returns zero i can execute

00:20:44,400 --> 00:20:47,520
that's great we'll see that weight take

00:20:46,240 --> 00:20:49,440
place

00:20:47,520 --> 00:20:51,280
if that you know deployment to that

00:20:49,440 --> 00:20:54,080
force failure that little tricky

00:20:51,280 --> 00:20:55,280
tricking i'm doing uh comes back with a

00:20:54,080 --> 00:20:56,799
fail continue

00:20:55,280 --> 00:20:58,960
the size of that will be greater than

00:20:56,799 --> 00:21:01,360
zero deployment three will not

00:20:58,960 --> 00:21:02,960
kick off now when we go and look at the

00:21:01,360 --> 00:21:03,600
pipeline contains a failure manual

00:21:02,960 --> 00:21:07,280
judgment

00:21:03,600 --> 00:21:08,400
this only runs if we do have previous

00:21:07,280 --> 00:21:11,039
failures

00:21:08,400 --> 00:21:12,480
so the deployment stages are saying only

00:21:11,039 --> 00:21:14,640
run if there are no failures

00:21:12,480 --> 00:21:16,159
this manual judgment stage only runs if

00:21:14,640 --> 00:21:20,080
there are failures

00:21:16,159 --> 00:21:23,520
right now the issue here is

00:21:20,080 --> 00:21:27,039
i still want this pipeline to show

00:21:23,520 --> 00:21:29,200
has failed even if somebody says

00:21:27,039 --> 00:21:30,640
okay continue this manual judgment it's

00:21:29,200 --> 00:21:32,559
successful

00:21:30,640 --> 00:21:34,000
so i have a final stage here that

00:21:32,559 --> 00:21:37,760
basically says

00:21:34,000 --> 00:21:40,000
hey if there's any failure force fail

00:21:37,760 --> 00:21:42,880
right so when we run through this

00:21:40,000 --> 00:21:45,520
pipeline execution

00:21:42,880 --> 00:21:47,280
let me go ahead and expand this out

00:21:45,520 --> 00:21:48,799
we'll start this judgment and we'll see

00:21:47,280 --> 00:21:51,919
what it looks like whenever we

00:21:48,799 --> 00:21:53,679
don't force a failure i'm going to go

00:21:51,919 --> 00:21:55,039
ahead and run it

00:21:53,679 --> 00:21:58,960
we'll see deployment number one is

00:21:55,039 --> 00:22:00,480
running wait time of five seconds

00:21:58,960 --> 00:22:02,640
now that deployment number two that has

00:22:00,480 --> 00:22:04,400
no wait time it just ran

00:22:02,640 --> 00:22:06,480
now we're on deployment number three

00:22:04,400 --> 00:22:08,400
right it's doing its weight

00:22:06,480 --> 00:22:10,400
it's succeeded and you can see that the

00:22:08,400 --> 00:22:12,960
pipeline containing failures manual

00:22:10,400 --> 00:22:16,159
judgment hold didn't run

00:22:12,960 --> 00:22:17,840
right and now the force failure of a

00:22:16,159 --> 00:22:19,200
pipeline doesn't run either

00:22:17,840 --> 00:22:22,240
okay so let's see what happens whenever

00:22:19,200 --> 00:22:27,840
i try to run two pipelines

00:22:22,240 --> 00:22:27,840
so this one we will force a failure

00:22:28,320 --> 00:22:31,039
select true

00:22:32,640 --> 00:22:36,400
and then i'm going to run another one

00:22:34,480 --> 00:22:39,440
where i'm going to say

00:22:36,400 --> 00:22:40,240
force false so now because i have that

00:22:39,440 --> 00:22:43,360
that

00:22:40,240 --> 00:22:45,440
configuration point set that says you

00:22:43,360 --> 00:22:47,200
can't run concurrent pipelines this

00:22:45,440 --> 00:22:48,960
one's not started it's waiting on a

00:22:47,200 --> 00:22:51,120
running execution

00:22:48,960 --> 00:22:52,480
i have a failure i forced that failure

00:22:51,120 --> 00:22:54,720
deployment two failed

00:22:52,480 --> 00:22:56,559
in air quotes and so now i'm at that

00:22:54,720 --> 00:22:58,640
manual judgment that's holding it

00:22:56,559 --> 00:23:00,480
so it doesn't matter how many pipeline

00:22:58,640 --> 00:23:04,080
executions stack up

00:23:00,480 --> 00:23:05,679
they're going to wait until the ops team

00:23:04,080 --> 00:23:07,200
goes and investigates why the failure

00:23:05,679 --> 00:23:09,360
occurred

00:23:07,200 --> 00:23:10,880
clears out this whether continuing or

00:23:09,360 --> 00:23:13,919
stopping doesn't matter

00:23:10,880 --> 00:23:14,880
right and then the next execution would

00:23:13,919 --> 00:23:16,880
proceed

00:23:14,880 --> 00:23:18,240
okay so that's how you can use pipeline

00:23:16,880 --> 00:23:21,440
expressions

00:23:18,240 --> 00:23:22,720
to really do a um

00:23:21,440 --> 00:23:24,480
you know preventing of further

00:23:22,720 --> 00:23:27,200
deployments and holding a pipeline

00:23:24,480 --> 00:23:29,840
execution if any stage fails

00:23:27,200 --> 00:23:30,799
and i would say that uh after figuring

00:23:29,840 --> 00:23:32,799
out

00:23:30,799 --> 00:23:36,320
you know this model probably about half

00:23:32,799 --> 00:23:39,919
the pipelines i help customers uh

00:23:36,320 --> 00:23:42,080
design involve this kind of pass-through

00:23:39,919 --> 00:23:43,520
failure and you know conditional

00:23:42,080 --> 00:23:45,679
execution

00:23:43,520 --> 00:23:47,200
that way you can get to the end if there

00:23:45,679 --> 00:23:49,840
is a failure you could have

00:23:47,200 --> 00:23:51,520
a branch that actually cleans up the

00:23:49,840 --> 00:23:53,279
previous resources

00:23:51,520 --> 00:23:54,960
right so it's not just go and figure out

00:23:53,279 --> 00:23:55,760
what the problem was and acknowledge the

00:23:54,960 --> 00:23:57,440
issue

00:23:55,760 --> 00:23:58,960
but now built into the pipeline the

00:23:57,440 --> 00:24:02,159
ability to say

00:23:58,960 --> 00:24:04,240
acknowledge and run uh

00:24:02,159 --> 00:24:05,840
the cleanup at which point it would undo

00:24:04,240 --> 00:24:07,279
everything and then the next execution

00:24:05,840 --> 00:24:10,720
would start up

00:24:07,279 --> 00:24:12,000
so i'll go ahead and stop that and

00:24:10,720 --> 00:24:14,640
i'm going to go ahead and cancel this

00:24:12,000 --> 00:24:14,640
execution

00:24:17,120 --> 00:24:23,840
all right so let's talk about loops

00:24:20,400 --> 00:24:25,200
right and how you can use them or really

00:24:23,840 --> 00:24:28,320
pipeline recursion

00:24:25,200 --> 00:24:29,520
okay starts to get a little complex one

00:24:28,320 --> 00:24:32,799
of the challenges

00:24:29,520 --> 00:24:35,120
of spinnaker is really the way in which

00:24:32,799 --> 00:24:36,080
uh organizations learn how to use

00:24:35,120 --> 00:24:37,840
spinnaker

00:24:36,080 --> 00:24:39,520
if you look at a lot of the

00:24:37,840 --> 00:24:40,559
documentation that's out there you'll

00:24:39,520 --> 00:24:43,520
see

00:24:40,559 --> 00:24:44,320
uh pipeline examples that are one big

00:24:43,520 --> 00:24:46,559
pipeline

00:24:44,320 --> 00:24:48,559
right and so if you're going to deploy

00:24:46,559 --> 00:24:50,640
to multiple environments or you're going

00:24:48,559 --> 00:24:52,960
to deploy to multiple regions

00:24:50,640 --> 00:24:53,840
do everything within one single pipeline

00:24:52,960 --> 00:24:56,559
context

00:24:53,840 --> 00:24:58,080
right so now you have multiple branches

00:24:56,559 --> 00:25:00,640
and with multiple branches comes

00:24:58,080 --> 00:25:02,320
multiple increased risk of failure

00:25:00,640 --> 00:25:03,919
uh not just because of spinnaker i mean

00:25:02,320 --> 00:25:04,480
things could break and spinnaker but

00:25:03,919 --> 00:25:06,799
also

00:25:04,480 --> 00:25:08,000
you know you could have uh the big

00:25:06,799 --> 00:25:10,720
backhoe in the sky

00:25:08,000 --> 00:25:11,919
cut the uh the fiber cable to the region

00:25:10,720 --> 00:25:14,320
at which point

00:25:11,919 --> 00:25:15,840
you know it fails uh for a reason

00:25:14,320 --> 00:25:18,880
outside of spinnaker

00:25:15,840 --> 00:25:20,320
uh the best thing to do is break up

00:25:18,880 --> 00:25:21,679
your pipelines especially when they

00:25:20,320 --> 00:25:22,960
start to get large into multiple

00:25:21,679 --> 00:25:27,039
pipelines

00:25:22,960 --> 00:25:28,080
it helps uh with uh reusability it also

00:25:27,039 --> 00:25:30,720
helps with

00:25:28,080 --> 00:25:31,760
spinnaker itself because when you get up

00:25:30,720 --> 00:25:35,600
over

00:25:31,760 --> 00:25:36,159
45 stages the ui elements of deck that

00:25:35,600 --> 00:25:38,880
render

00:25:36,159 --> 00:25:39,279
the pipeline uh whenever you go and look

00:25:38,880 --> 00:25:40,799
at

00:25:39,279 --> 00:25:42,799
you know the pipeline itself that shows

00:25:40,799 --> 00:25:44,159
you the status where you see the

00:25:42,799 --> 00:25:46,000
execution details you can see the

00:25:44,159 --> 00:25:49,200
pipeline you get up over 45

00:25:46,000 --> 00:25:51,279
dec really struggles to show all of them

00:25:49,200 --> 00:25:53,039
right so i've seen customers with

00:25:51,279 --> 00:25:53,440
hundreds of stages and then they start

00:25:53,039 --> 00:25:56,559
to

00:25:53,440 --> 00:25:58,000
wonder why they can't really get in to

00:25:56,559 --> 00:26:01,279
edit them anymore right they have to

00:25:58,000 --> 00:26:02,799
actually go edit the uh the json instead

00:26:01,279 --> 00:26:04,720
best thing to do is break things up

00:26:02,799 --> 00:26:06,240
right when you break things up starts to

00:26:04,720 --> 00:26:08,159
open up the door for doing things like

00:26:06,240 --> 00:26:10,400
loose

00:26:08,159 --> 00:26:11,440
so here's a basic structure of how a

00:26:10,400 --> 00:26:14,240
loop works

00:26:11,440 --> 00:26:14,960
right in my configuration i've set a

00:26:14,240 --> 00:26:17,840
couple of

00:26:14,960 --> 00:26:19,840
pipeline parameters right i have a limit

00:26:17,840 --> 00:26:23,120
on the number of times i'm going to loop

00:26:19,840 --> 00:26:25,760
and then i have an iteration count right

00:26:23,120 --> 00:26:28,320
so the first time i call this loop i

00:26:25,760 --> 00:26:30,400
would be on iteration number one

00:26:28,320 --> 00:26:32,159
and maybe i have a limit of five right

00:26:30,400 --> 00:26:33,760
so i want to loop through this pipeline

00:26:32,159 --> 00:26:37,200
five times and run

00:26:33,760 --> 00:26:39,120
some set of stages right

00:26:37,200 --> 00:26:40,559
with those parameters set the first

00:26:39,120 --> 00:26:42,880
thing i tend to do in most of my

00:26:40,559 --> 00:26:45,039
pipelines is evaluate variables

00:26:42,880 --> 00:26:46,960
even though i can still access things

00:26:45,039 --> 00:26:49,360
directly as parameters

00:26:46,960 --> 00:26:50,320
the the more you the further you get

00:26:49,360 --> 00:26:52,400
into a pipeline

00:26:50,320 --> 00:26:54,320
the harder it is to keep track of what

00:26:52,400 --> 00:26:56,240
variable was set when

00:26:54,320 --> 00:26:57,440
and you run the risk of overwriting

00:26:56,240 --> 00:26:59,120
variables in the future

00:26:57,440 --> 00:27:01,039
right so if you know you need certain

00:26:59,120 --> 00:27:02,720
variables and they're coming in through

00:27:01,039 --> 00:27:04,080
parameters i always just evaluate

00:27:02,720 --> 00:27:05,520
variable stages

00:27:04,080 --> 00:27:07,279
at the very beginning get those

00:27:05,520 --> 00:27:08,000
variables evaluated then use them as you

00:27:07,279 --> 00:27:10,640
need to

00:27:08,000 --> 00:27:12,240
right so in this case what i really want

00:27:10,640 --> 00:27:13,200
to do is calculate what's my next

00:27:12,240 --> 00:27:15,760
iteration

00:27:13,200 --> 00:27:16,640
what's my current iteration and what's

00:27:15,760 --> 00:27:19,039
my limit

00:27:16,640 --> 00:27:20,480
right so in the previous in my test run

00:27:19,039 --> 00:27:23,600
i did before training

00:27:20,480 --> 00:27:25,440
i passed in two it knows that so the

00:27:23,600 --> 00:27:27,120
limit is two it knows that its current

00:27:25,440 --> 00:27:29,120
iteration is three and it knows that its

00:27:27,120 --> 00:27:32,000
next generation is four

00:27:29,120 --> 00:27:34,080
the last run i did it was on the final

00:27:32,000 --> 00:27:36,240
loop of the pipeline and so it knows hey

00:27:34,080 --> 00:27:39,440
i'm greater than 2 so i'm going to

00:27:36,240 --> 00:27:41,840
not continue looping so

00:27:39,440 --> 00:27:43,679
like i said now i'm going to evaluate is

00:27:41,840 --> 00:27:44,399
the current iteration less than or equal

00:27:43,679 --> 00:27:47,520
to the limit

00:27:44,399 --> 00:27:49,679
if it is i need to keep looping right

00:27:47,520 --> 00:27:50,960
and so here at this continue looping i

00:27:49,679 --> 00:27:52,880
have a manual judgment

00:27:50,960 --> 00:27:54,880
it's at this point in this pipeline that

00:27:52,880 --> 00:27:55,600
i would build in all the stages that i

00:27:54,880 --> 00:27:57,440
need to do

00:27:55,600 --> 00:27:59,679
multiple times over and over and over

00:27:57,440 --> 00:28:02,399
again maybe i need to deploy to

00:27:59,679 --> 00:28:03,840
three or four regions the deployment

00:28:02,399 --> 00:28:06,480
logic for each of those regions

00:28:03,840 --> 00:28:08,000
or for deploying to a region would be

00:28:06,480 --> 00:28:10,320
built in here

00:28:08,000 --> 00:28:12,000
and i would pass in a a pipeline

00:28:10,320 --> 00:28:13,679
parameter that actually defines what

00:28:12,000 --> 00:28:16,480
region i'm going to and that would get

00:28:13,679 --> 00:28:19,760
substituted into this logic

00:28:16,480 --> 00:28:21,679
now if we're on a iteration that is

00:28:19,760 --> 00:28:24,640
greater than the limit then hey

00:28:21,679 --> 00:28:26,399
i'm done right so the looping is

00:28:24,640 --> 00:28:29,760
complete i'm on a different branch

00:28:26,399 --> 00:28:32,080
right now for the basics of or the basis

00:28:29,760 --> 00:28:34,960
of control

00:28:32,080 --> 00:28:36,480
i have a manual judgment here just to

00:28:34,960 --> 00:28:38,159
kind of help display

00:28:36,480 --> 00:28:40,480
the functionality as well as we walk

00:28:38,159 --> 00:28:42,640
through the loops right

00:28:40,480 --> 00:28:44,240
now let's jump back down to the continue

00:28:42,640 --> 00:28:45,919
looping stage after i run all of my

00:28:44,240 --> 00:28:47,120
logic let's say i've got five stages

00:28:45,919 --> 00:28:49,440
here

00:28:47,120 --> 00:28:51,120
it knows i need to do more looping so

00:28:49,440 --> 00:28:53,600
run run the logic

00:28:51,120 --> 00:28:55,279
and then rerun the pipeline now there's

00:28:53,600 --> 00:28:59,039
a nuance here

00:28:55,279 --> 00:29:02,320
i can't actually select my pipeline

00:28:59,039 --> 00:29:05,440
using um

00:29:02,320 --> 00:29:08,799
i can't select my pipeline using

00:29:05,440 --> 00:29:11,919
the run as pipeline stage

00:29:08,799 --> 00:29:14,240
right so whenever i come up here i've

00:29:11,919 --> 00:29:18,080
got a stage name

00:29:14,240 --> 00:29:22,080
i've got let me add a stage here and say

00:29:18,080 --> 00:29:22,799
run pipeline so if i pick a pipeline

00:29:22,080 --> 00:29:24,960
stage is

00:29:22,799 --> 00:29:26,240
what i have down here under the rerun

00:29:24,960 --> 00:29:29,600
pipeline

00:29:26,240 --> 00:29:31,039
remove it get it back down so this is a

00:29:29,600 --> 00:29:33,200
run pipeline stage

00:29:31,039 --> 00:29:35,440
my only option is pipelines not the

00:29:33,200 --> 00:29:37,279
current pipeline but like i said earlier

00:29:35,440 --> 00:29:39,120
you can always edit the text field

00:29:37,279 --> 00:29:42,080
straight into json

00:29:39,120 --> 00:29:43,360
so whenever i come into edit stages json

00:29:42,080 --> 00:29:46,799
you'll see the pipeline

00:29:43,360 --> 00:29:49,760
id that needs to run so in order to run

00:29:46,799 --> 00:29:51,520
have a pipeline rerun itself you come up

00:29:49,760 --> 00:29:54,080
here to the browser

00:29:51,520 --> 00:29:55,679
you select your pipeline id you copy and

00:29:54,080 --> 00:29:57,600
paste it into here

00:29:55,679 --> 00:30:00,720
and then you can define your pipeline

00:29:57,600 --> 00:30:02,000
parameters either in the json

00:30:00,720 --> 00:30:03,919
well actually you'll have to do it in

00:30:02,000 --> 00:30:05,520
the pipe in the json because the ui

00:30:03,919 --> 00:30:08,080
won't actually render it

00:30:05,520 --> 00:30:09,360
right one of the keys is you want to

00:30:08,080 --> 00:30:10,960
wait for the results

00:30:09,360 --> 00:30:13,760
right so you want these things to kind

00:30:10,960 --> 00:30:17,120
of stack up as they're waiting for the

00:30:13,760 --> 00:30:20,000
the pipeline that it called to run

00:30:17,120 --> 00:30:22,880
uh runs and then as they complete it'll

00:30:20,000 --> 00:30:23,600
pass back up through uh the pipeline

00:30:22,880 --> 00:30:25,760
structure

00:30:23,600 --> 00:30:27,760
okay so that's what happens whenever it

00:30:25,760 --> 00:30:31,279
reruns it'll rerun itself

00:30:27,760 --> 00:30:34,399
it'll pass in the the next iteration

00:30:31,279 --> 00:30:35,600
it'll also pass in the limit right so

00:30:34,399 --> 00:30:37,919
now you've just got this

00:30:35,600 --> 00:30:39,600
recursion going that's going to run

00:30:37,919 --> 00:30:41,200
through until it hits its limit when it

00:30:39,600 --> 00:30:41,600
hits its limit it's going to basically

00:30:41,200 --> 00:30:44,960
say

00:30:41,600 --> 00:30:47,120
hey i'm done and pass back up when i

00:30:44,960 --> 00:30:49,440
say pass back up it's because you really

00:30:47,120 --> 00:30:52,640
have to have a master pipeline

00:30:49,440 --> 00:30:54,399
to run loops okay so when i look at this

00:30:52,640 --> 00:30:57,600
master pipeline it's pretty simple

00:30:54,399 --> 00:30:59,760
right i've got some query parameters

00:30:57,600 --> 00:31:01,120
i'm going to pass in my how many times i

00:30:59,760 --> 00:31:02,640
want to run my first loop

00:31:01,120 --> 00:31:04,159
i'm going to run in i'm going to pass in

00:31:02,640 --> 00:31:04,880
how many times i want to run my second

00:31:04,159 --> 00:31:09,200
loop

00:31:04,880 --> 00:31:11,600
okay now my first loop is going to run

00:31:09,200 --> 00:31:12,320
i'm going to you know run a pipeline and

00:31:11,600 --> 00:31:14,480
i'm going to pass

00:31:12,320 --> 00:31:16,080
in so you can see i'm calling using

00:31:14,480 --> 00:31:18,559
recursion to loop a pipeline

00:31:16,080 --> 00:31:20,000
the loop itself my iteration number

00:31:18,559 --> 00:31:21,519
which is always going to be one for the

00:31:20,000 --> 00:31:23,440
first time i start it

00:31:21,519 --> 00:31:26,880
and i'm going to pass in my limit which

00:31:23,440 --> 00:31:31,519
i'm calling the parameters.first loop

00:31:26,880 --> 00:31:33,039
parameter okay now for my second loop

00:31:31,519 --> 00:31:34,640
i'm passing in a one and i'm passing in

00:31:33,039 --> 00:31:38,080
my second parameter

00:31:34,640 --> 00:31:40,320
just like with the loops

00:31:38,080 --> 00:31:41,360
i'm actually wait uh i'm doing the same

00:31:40,320 --> 00:31:43,120
thing in the master

00:31:41,360 --> 00:31:44,840
where i'm waiting for the results to

00:31:43,120 --> 00:31:48,320
propagate back up

00:31:44,840 --> 00:31:48,960
okay so we have a couple of manual

00:31:48,320 --> 00:31:50,880
judgments

00:31:48,960 --> 00:31:52,640
built into the loops themselves and we

00:31:50,880 --> 00:31:55,760
have a manual judgment at the end

00:31:52,640 --> 00:31:58,399
to see if it's successful so let me go

00:31:55,760 --> 00:32:00,240
ahead and kick this off

00:31:58,399 --> 00:32:02,080
i'm going to start a manual execution of

00:32:00,240 --> 00:32:04,559
my master i'm going to go ahead and loop

00:32:02,080 --> 00:32:07,039
each of these pipelines twice

00:32:04,559 --> 00:32:08,399
so let's run it and now i'm going to

00:32:07,039 --> 00:32:11,919
change my view

00:32:08,399 --> 00:32:15,039
to none so you can see here

00:32:11,919 --> 00:32:16,480
down down here in the second listing you

00:32:15,039 --> 00:32:19,279
can see the master itself

00:32:16,480 --> 00:32:19,679
it's running right it initiated its

00:32:19,279 --> 00:32:22,080
first

00:32:19,679 --> 00:32:22,880
loop evaluate the variables knows it

00:32:22,080 --> 00:32:25,360
needs more

00:32:22,880 --> 00:32:26,799
looping the branch that is looping

00:32:25,360 --> 00:32:28,399
complete is not running

00:32:26,799 --> 00:32:30,000
right so it's grayed out and so i'm at

00:32:28,399 --> 00:32:32,480
my manual judgment let's continue my

00:32:30,000 --> 00:32:34,080
looping

00:32:32,480 --> 00:32:36,159
so it's going to go ahead and loop it

00:32:34,080 --> 00:32:39,679
starts re-running itself

00:32:36,159 --> 00:32:42,799
a new execution runs it knows it needs

00:32:39,679 --> 00:32:45,519
more looping because hey i'm on the i'm

00:32:42,799 --> 00:32:47,679
less than or equal to my limit so now

00:32:45,519 --> 00:32:49,600
i'm at that logic point so if i had five

00:32:47,679 --> 00:32:53,120
stages here they would run

00:32:49,600 --> 00:32:55,840
uh in a series or maybe in branches

00:32:53,120 --> 00:32:57,039
let's go ahead and continue looping but

00:32:55,840 --> 00:32:58,880
i want you to pay attention to what's

00:32:57,039 --> 00:33:02,000
kind of going on here

00:32:58,880 --> 00:33:04,080
we have a rerun of the pipeline

00:33:02,000 --> 00:33:05,600
waiting and we have a waiting and we

00:33:04,080 --> 00:33:06,799
have the master waiting so you can kind

00:33:05,600 --> 00:33:09,919
of see

00:33:06,799 --> 00:33:11,679
these things are taking place i'm not

00:33:09,919 --> 00:33:14,080
sure if i called it out but the loop

00:33:11,679 --> 00:33:16,799
itself would also need to allow

00:33:14,080 --> 00:33:18,799
uh concurrent execution so we didn't use

00:33:16,799 --> 00:33:20,240
the prevent concurrent executions

00:33:18,799 --> 00:33:23,600
pipeline parameter

00:33:20,240 --> 00:33:26,399
or execution config so now

00:33:23,600 --> 00:33:28,320
i called for two a third one runs the

00:33:26,399 --> 00:33:32,159
third one runs because

00:33:28,320 --> 00:33:34,000
i need a loop to resolve

00:33:32,159 --> 00:33:36,000
and so i need that branch for the you

00:33:34,000 --> 00:33:38,720
know no more looping needed to run

00:33:36,000 --> 00:33:39,919
so you can see here more looping needed

00:33:38,720 --> 00:33:42,880
doesn't run

00:33:39,919 --> 00:33:44,799
looping complete does holds for a manual

00:33:42,880 --> 00:33:47,840
judgment just for the purposes of

00:33:44,799 --> 00:33:50,159
display let's continue it

00:33:47,840 --> 00:33:52,880
now it knows hey i'm passing up some

00:33:50,159 --> 00:33:53,919
parameter variables and now you can see

00:33:52,880 --> 00:33:56,159
that one completed

00:33:53,919 --> 00:33:58,000
the one that called it is now going to

00:33:56,159 --> 00:33:59,360
complete right because it's getting the

00:33:58,000 --> 00:34:01,760
context

00:33:59,360 --> 00:34:03,600
it completed and now the next one is

00:34:01,760 --> 00:34:05,360
going to get it so it's kind of bubbling

00:34:03,600 --> 00:34:07,360
up through all the pipelines that

00:34:05,360 --> 00:34:09,679
called it all the way back up to the

00:34:07,360 --> 00:34:10,480
master and so the master is going to see

00:34:09,679 --> 00:34:12,079
that

00:34:10,480 --> 00:34:14,240
and now it's going to move to its second

00:34:12,079 --> 00:34:16,000
loop iteration and start the process

00:34:14,240 --> 00:34:18,960
over again

00:34:16,000 --> 00:34:21,040
so let's continue it re-running the

00:34:18,960 --> 00:34:24,480
pipeline

00:34:21,040 --> 00:34:25,839
let's continue again rerunning the

00:34:24,480 --> 00:34:27,760
pipeline

00:34:25,839 --> 00:34:29,839
well looping is complete because we set

00:34:27,760 --> 00:34:31,200
it to two it's on its third one knows

00:34:29,839 --> 00:34:32,879
hey i'm done

00:34:31,200 --> 00:34:36,720
let's complete it let's complete our

00:34:32,879 --> 00:34:36,720
pipeline it's going to pass up

00:34:36,800 --> 00:34:40,079
it's going to be received

00:34:41,200 --> 00:34:49,839
the next one's going to receive it

00:34:50,879 --> 00:34:54,079
and now the master is going to say hey

00:34:52,800 --> 00:34:55,359
i'm going to get notified that that

00:34:54,079 --> 00:34:56,720
second loop is done so i'm going to

00:34:55,359 --> 00:35:00,480
continue on

00:34:56,720 --> 00:35:02,800
were we successful yes we were

00:35:00,480 --> 00:35:04,079
and that is how you work through a

00:35:02,800 --> 00:35:07,520
looping recursion

00:35:04,079 --> 00:35:09,839
with a master pipeline structure

00:35:07,520 --> 00:35:12,560
each of those stages is using some

00:35:09,839 --> 00:35:14,560
element of

00:35:12,560 --> 00:35:16,400
the spring expression language that i

00:35:14,560 --> 00:35:19,920
called out in that presentation

00:35:16,400 --> 00:35:23,440
right now when i talk about

00:35:19,920 --> 00:35:26,160
executions kind of bubbling up through

00:35:23,440 --> 00:35:28,320
uh you know from pipeline to pipeline

00:35:26,160 --> 00:35:31,680
back up to that master

00:35:28,320 --> 00:35:36,960
you there's two ways there's kind of

00:35:31,680 --> 00:35:36,960
two outcomes of pipeline

00:35:43,520 --> 00:35:51,599
another pipeline when when pipeline a

00:35:47,359 --> 00:35:52,480
triggers pipeline b the entire execution

00:35:51,599 --> 00:35:55,680
context

00:35:52,480 --> 00:35:57,839
everything in the execution details

00:35:55,680 --> 00:35:59,119
from pipeline a gets passed into

00:35:57,839 --> 00:36:01,280
pipeline b

00:35:59,119 --> 00:36:03,200
inside of the trigger element of the

00:36:01,280 --> 00:36:05,040
execution context

00:36:03,200 --> 00:36:07,200
whenever a pipeline calls another

00:36:05,040 --> 00:36:08,880
pipeline waits for the results and it

00:36:07,200 --> 00:36:10,640
receives the results it doesn't get the

00:36:08,880 --> 00:36:13,680
entire context

00:36:10,640 --> 00:36:16,480
it gets the out details of the context

00:36:13,680 --> 00:36:17,760
so let's go ahead and walk through what

00:36:16,480 --> 00:36:19,040
that looks like

00:36:17,760 --> 00:36:21,440
i'm going to jump over to a little

00:36:19,040 --> 00:36:23,119
tester that i have a little build tester

00:36:21,440 --> 00:36:24,800
and let's come over here and pick our

00:36:23,119 --> 00:36:28,560
pipeline

00:36:24,800 --> 00:36:31,359
and pick the spell workshop pick our

00:36:28,560 --> 00:36:31,359
master loop

00:36:31,599 --> 00:36:37,280
and the one from four minutes ago

00:36:34,640 --> 00:36:40,000
so here's the whole pipeline execution

00:36:37,280 --> 00:36:40,800
context we know we ran three stages loop

00:36:40,000 --> 00:36:43,280
number one

00:36:40,800 --> 00:36:44,960
loop number two and then the final was i

00:36:43,280 --> 00:36:48,320
successful

00:36:44,960 --> 00:36:51,599
so if i expand this out and go to

00:36:48,320 --> 00:36:53,200
the outputs you'll see that all the

00:36:51,599 --> 00:36:55,760
parameters

00:36:53,200 --> 00:36:56,880
that were passed up to it from the last

00:36:55,760 --> 00:36:59,440
loop

00:36:56,880 --> 00:37:01,599
uh which bubbled up from the final the

00:36:59,440 --> 00:37:02,240
final run of the loop itself kind of

00:37:01,599 --> 00:37:05,119
come up

00:37:02,240 --> 00:37:07,200
so any variable you define using an

00:37:05,119 --> 00:37:08,960
evaluate variable stage in a pipeline

00:37:07,200 --> 00:37:11,280
that is run by another pipeline

00:37:08,960 --> 00:37:12,160
that waits on its results becomes

00:37:11,280 --> 00:37:15,440
accessible

00:37:12,160 --> 00:37:17,200
in the top level master pipelines stages

00:37:15,440 --> 00:37:20,320
outputs

00:37:17,200 --> 00:37:22,320
it also has a limited amount of

00:37:20,320 --> 00:37:23,760
contacts from that pipeline it has the

00:37:22,320 --> 00:37:27,440
pipeline id

00:37:23,760 --> 00:37:29,599
um the execution id it also give you the

00:37:27,440 --> 00:37:30,079
name of the execution the application

00:37:29,599 --> 00:37:32,800
and then

00:37:30,079 --> 00:37:34,640
whatever parameters were passed in right

00:37:32,800 --> 00:37:36,160
so that's all accessible in the context

00:37:34,640 --> 00:37:37,920
it's not the entire thing

00:37:36,160 --> 00:37:40,560
but if you were to get any artifacts out

00:37:37,920 --> 00:37:43,920
of that or any evaluated variables those

00:37:40,560 --> 00:37:43,920
all come up as outputs

00:37:45,119 --> 00:37:50,800
now why do i talk about loops when they

00:37:48,400 --> 00:37:54,720
talk about fail through um

00:37:50,800 --> 00:37:54,720
let's jump back over to the presentation

00:37:54,800 --> 00:37:59,040
it's really comp working demonstration

00:37:57,119 --> 00:38:00,240
of this but it's really difficult to see

00:37:59,040 --> 00:38:01,760
kind of what's going on

00:38:00,240 --> 00:38:04,800
especially when you you have to

00:38:01,760 --> 00:38:06,880
understand the the stages and kind of

00:38:04,800 --> 00:38:08,160
what's going on uh throughout the flow

00:38:06,880 --> 00:38:08,560
of the pipeline so i'll just sort of

00:38:08,160 --> 00:38:12,320
walk

00:38:08,560 --> 00:38:15,280
through uh the pattern in a presentation

00:38:12,320 --> 00:38:17,440
okay so this particular spinnaker

00:38:15,280 --> 00:38:19,760
pipeline pattern is a progressive blue

00:38:17,440 --> 00:38:21,839
green canary deployment

00:38:19,760 --> 00:38:24,480
where that canary gets promoted to

00:38:21,839 --> 00:38:27,599
production right in order to do this

00:38:24,480 --> 00:38:28,480
there's a couple of uh uh advanced

00:38:27,599 --> 00:38:30,800
features

00:38:28,480 --> 00:38:33,920
that i'm using uh not only a spinnaker

00:38:30,800 --> 00:38:36,320
but also of the nginx ingress controller

00:38:33,920 --> 00:38:38,400
so i'm using a deployment kubernetes

00:38:36,320 --> 00:38:41,760
object type

00:38:38,400 --> 00:38:44,560
which is not versioned by spinnaker

00:38:41,760 --> 00:38:47,200
i can tell spinnaker to version that

00:38:44,560 --> 00:38:49,280
deployment using an annotation

00:38:47,200 --> 00:38:50,240
uh a spinnaker orientation that is

00:38:49,280 --> 00:38:52,640
basically saying

00:38:50,240 --> 00:38:54,320
hey set the strategy for versioning to

00:38:52,640 --> 00:38:55,680
true right so now

00:38:54,320 --> 00:38:57,680
spinnaker is going to version every

00:38:55,680 --> 00:39:00,079
deployment and basically treat it a

00:38:57,680 --> 00:39:02,400
little bit like a rapid cassette with

00:39:00,079 --> 00:39:05,599
the nginx ingress controller

00:39:02,400 --> 00:39:07,040
i am controlling the traffic shift where

00:39:05,599 --> 00:39:11,440
i deploy

00:39:07,040 --> 00:39:14,800
two of the exact same ingress

00:39:11,440 --> 00:39:16,720
the kubernetes ingresses one that has a

00:39:14,800 --> 00:39:17,920
canary annotation on it and one that

00:39:16,720 --> 00:39:20,240
does not

00:39:17,920 --> 00:39:21,440
right and then like i talked about you

00:39:20,240 --> 00:39:23,359
can kind of define

00:39:21,440 --> 00:39:25,920
what your strategy is for the traffic

00:39:23,359 --> 00:39:29,839
shift i would then iterate over

00:39:25,920 --> 00:39:32,800
and using a loop to shift that traffic

00:39:29,839 --> 00:39:35,119
from the canary deployment over or from

00:39:32,800 --> 00:39:38,079
the production deployment to the canary

00:39:35,119 --> 00:39:39,040
and then i would go in and edit my uh

00:39:38,079 --> 00:39:41,680
canary

00:39:39,040 --> 00:39:43,119
ingress to make it production right so

00:39:41,680 --> 00:39:44,960
the pipeline itself

00:39:43,119 --> 00:39:46,320
in green you would see all the pipelines

00:39:44,960 --> 00:39:48,640
that would be getting used

00:39:46,320 --> 00:39:50,480
you'd have a top level pipeline which is

00:39:48,640 --> 00:39:52,240
really initiate that roll out to

00:39:50,480 --> 00:39:54,320
production

00:39:52,240 --> 00:39:57,200
which would have these stages and in

00:39:54,320 --> 00:40:01,520
green inside of that you would see

00:39:57,200 --> 00:40:03,839
subsequent like uh subordinate pipelines

00:40:01,520 --> 00:40:06,240
that have their own stages running in it

00:40:03,839 --> 00:40:09,520
uh that would then accomplish the entire

00:40:06,240 --> 00:40:12,160
concept of blue-green canary deployment

00:40:09,520 --> 00:40:13,440
with promotion of that carry canary to

00:40:12,160 --> 00:40:16,480
production

00:40:13,440 --> 00:40:18,400
so inside the the top level

00:40:16,480 --> 00:40:19,680
i would basically say is this an initial

00:40:18,400 --> 00:40:22,240
rollout or

00:40:19,680 --> 00:40:23,200
is it a follow-on rollout if it's an

00:40:22,240 --> 00:40:25,359
initial

00:40:23,200 --> 00:40:27,440
check that and you know what go ahead

00:40:25,359 --> 00:40:29,520
and just roll out the resources

00:40:27,440 --> 00:40:30,960
if it's a follow-on rollout now i want

00:40:29,520 --> 00:40:33,839
to do that blue-green deployment

00:40:30,960 --> 00:40:34,480
right so this won't run subsequently the

00:40:33,839 --> 00:40:36,560
second

00:40:34,480 --> 00:40:37,520
pipeline the actual complex pipeline

00:40:36,560 --> 00:40:39,680
would run

00:40:37,520 --> 00:40:41,599
our branch would run and so i'm going to

00:40:39,680 --> 00:40:43,520
run a roll out of the blue green canary

00:40:41,599 --> 00:40:45,040
resources themselves

00:40:43,520 --> 00:40:47,440
the master pipeline's going to wait on

00:40:45,040 --> 00:40:48,079
those results right i might throw a

00:40:47,440 --> 00:40:50,000
manual

00:40:48,079 --> 00:40:51,440
judgment here in just but i'm starting

00:40:50,000 --> 00:40:53,680
to

00:40:51,440 --> 00:40:54,960
use this pipeline and get comfortable

00:40:53,680 --> 00:40:57,280
with it but you don't need a

00:40:54,960 --> 00:40:58,319
you don't need a manual judgment there

00:40:57,280 --> 00:41:01,680
you can just let the

00:40:58,319 --> 00:41:03,359
canary traffic shift loop start i might

00:41:01,680 --> 00:41:05,599
you know for the purposes of what a

00:41:03,359 --> 00:41:06,880
canary really is which is you know that

00:41:05,599 --> 00:41:10,800
incremental shift

00:41:06,880 --> 00:41:12,640
that that you know human validation or

00:41:10,800 --> 00:41:14,640
machine validation if you're actually

00:41:12,640 --> 00:41:17,359
using canary metrics

00:41:14,640 --> 00:41:19,040
to determine should i continue the loop

00:41:17,359 --> 00:41:21,599
so whether i'm beginning that's gonna

00:41:19,040 --> 00:41:23,760
you know run some analysis and check it

00:41:21,599 --> 00:41:25,119
or i might have a manual judgment where

00:41:23,760 --> 00:41:27,040
a human is actually going to go look and

00:41:25,119 --> 00:41:30,640
say do i think everything's good

00:41:27,040 --> 00:41:32,560
i would put them for those two stages at

00:41:30,640 --> 00:41:34,079
the beginning of the canary loop

00:41:32,560 --> 00:41:36,160
so the canary loop would immediately

00:41:34,079 --> 00:41:38,240
start off run its

00:41:36,160 --> 00:41:39,760
its process to do the first iteration of

00:41:38,240 --> 00:41:41,920
the traffic shift

00:41:39,760 --> 00:41:43,599
he would see i need to do more traffic

00:41:41,920 --> 00:41:44,319
shifting so i'm going to call myself

00:41:43,599 --> 00:41:47,280
again

00:41:44,319 --> 00:41:49,200
right and i'm going to hold or i'm going

00:41:47,280 --> 00:41:51,040
to go ahead and run that canary metric

00:41:49,200 --> 00:41:52,880
at 10 percent and then it's going to say

00:41:51,040 --> 00:41:54,960
hey i know i'm not at 100 so let's keep

00:41:52,880 --> 00:41:58,000
on rolling so i might end up stacking

00:41:54,960 --> 00:41:59,119
two traffic shift loops or i might end

00:41:58,000 --> 00:42:00,720
up stacking 10.

00:41:59,119 --> 00:42:03,200
it all depends on the strategies i

00:42:00,720 --> 00:42:06,640
define as part of this app's rollout

00:42:03,200 --> 00:42:08,640
right once the canary are looping needed

00:42:06,640 --> 00:42:09,760
all of those pipelines are going to

00:42:08,640 --> 00:42:11,359
complete

00:42:09,760 --> 00:42:12,960
it's going to bubble all the way up to

00:42:11,359 --> 00:42:14,640
the master pipeline that was running

00:42:12,960 --> 00:42:16,960
that loop itself

00:42:14,640 --> 00:42:17,839
and then it's going to move forward

00:42:16,960 --> 00:42:19,440
right

00:42:17,839 --> 00:42:21,839
i might throw a manual judgment and

00:42:19,440 --> 00:42:23,680
condition check to basically say hey

00:42:21,839 --> 00:42:25,359
all traffic shifted do you want to clean

00:42:23,680 --> 00:42:27,040
up or

00:42:25,359 --> 00:42:28,880
after everything was shifted did all of

00:42:27,040 --> 00:42:31,359
a sudden a bunch of complaints come in

00:42:28,880 --> 00:42:33,359
about this app do i need to roll back

00:42:31,359 --> 00:42:36,000
and so using you know the spell

00:42:33,359 --> 00:42:37,920
expressions inside of this logic

00:42:36,000 --> 00:42:39,359
i can not only promote that canary to

00:42:37,920 --> 00:42:42,400
prod but i can

00:42:39,359 --> 00:42:42,880
also roll everything back and so passing

00:42:42,400 --> 00:42:46,079
in

00:42:42,880 --> 00:42:48,640
parameters i can uh have a

00:42:46,079 --> 00:42:49,200
rollback of the canary or a cleanup of

00:42:48,640 --> 00:42:52,000
the

00:42:49,200 --> 00:42:53,839
deployment pipeline that accepts

00:42:52,000 --> 00:42:56,000
parameters that just goes and cleans up

00:42:53,839 --> 00:42:57,119
the services by name or the deployments

00:42:56,000 --> 00:43:00,240
by name

00:42:57,119 --> 00:43:03,520
and it's not hard-coded specifically to

00:43:00,240 --> 00:43:04,480
that particular application and

00:43:03,520 --> 00:43:05,920
deployment

00:43:04,480 --> 00:43:07,760
which becomes important important when

00:43:05,920 --> 00:43:09,680
you're using that versioning strategy of

00:43:07,760 --> 00:43:10,800
spinnaker because the actual deployment

00:43:09,680 --> 00:43:13,839
name

00:43:10,800 --> 00:43:17,119
has a version number uh added in

00:43:13,839 --> 00:43:20,000
as a suffix to the name itself right so

00:43:17,119 --> 00:43:20,560
having those pipelines run with kind of

00:43:20,000 --> 00:43:22,880
a

00:43:20,560 --> 00:43:24,480
dynamic injection of the data using

00:43:22,880 --> 00:43:28,079
pipeline expressions

00:43:24,480 --> 00:43:30,960
is very very valuable but that's the end

00:43:28,079 --> 00:43:38,560
of the presentation in walkthroughs

00:43:30,960 --> 00:43:38,560

YouTube URL: https://www.youtube.com/watch?v=53gXmgrKtzs


