Title: Managed Delivery for Kubernetes: A Collaboration Story - Luis Pollo, Rob Hilton, Nima Kaviani
Publication date: 2021-01-12
Playlist: Spinnaker Summit 2020
Description: 
	Managed Delivery has come a long way since the 2019 Spinnaker Summit. We've added many features, along with stability, usability and extensibility improvements that make it easier to add support for new kinds of infrastructure resources. Through the Spinnaker-as-Code SIG, AWS and Netflix started a partnership to extend Managed Delivery support via plugins to enable management of Kubernetes resources and the deployment of Docker images into those resources as part of high-level delivery workflows, where a user defines the logical environments and promotion constraints, and Spinnaker takes care of the details. In this talk, we discuss our collaboration, the progress made so far, and exciting opportunities for the future of Kubernetes support in Managed Delivery.
Captions: 
	00:00:00,530 --> 00:00:03,629
[Music]

00:00:05,520 --> 00:00:09,120
hello everyone

00:00:06,640 --> 00:00:11,120
my name is luis polo and i'm a software

00:00:09,120 --> 00:00:13,120
engineer at netflix where i work

00:00:11,120 --> 00:00:14,960
in the managed delivery team which is

00:00:13,120 --> 00:00:16,080
part of our developer productivity

00:00:14,960 --> 00:00:18,640
organization

00:00:16,080 --> 00:00:21,039
i am super excited to be here today with

00:00:18,640 --> 00:00:21,279
my friends rob hilton and nima kaviani

00:00:21,039 --> 00:00:24,160
from

00:00:21,279 --> 00:00:26,160
aws to tell you the story of how we met

00:00:24,160 --> 00:00:27,039
in the spinnaker open source corner of

00:00:26,160 --> 00:00:29,279
the world

00:00:27,039 --> 00:00:30,880
and how that led to a pretty fun and

00:00:29,279 --> 00:00:33,200
productive collaboration that has

00:00:30,880 --> 00:00:34,960
produced some really interesting results

00:00:33,200 --> 00:00:36,640
i believe these will take kubernetes

00:00:34,960 --> 00:00:37,680
support and spinnaker to a whole new

00:00:36,640 --> 00:00:40,879
level

00:00:37,680 --> 00:00:42,320
so let's get started here's what we'll

00:00:40,879 --> 00:00:44,239
be covering today

00:00:42,320 --> 00:00:46,079
first i'll do a quick recap of managed

00:00:44,239 --> 00:00:47,840
delivery and how it has evolved over

00:00:46,079 --> 00:00:51,680
this past year since it was first

00:00:47,840 --> 00:00:53,440
introduced in the 2019 spinnaker summit

00:00:51,680 --> 00:00:55,039
next rob will tell you about the

00:00:53,440 --> 00:00:55,760
evolution of kubernetes support in

00:00:55,039 --> 00:00:57,360
spinnaker

00:00:55,760 --> 00:00:59,280
and where we saw an opportunity to

00:00:57,360 --> 00:01:01,520
improve it then

00:00:59,280 --> 00:01:03,039
nemo will talk about what we've built to

00:01:01,520 --> 00:01:04,559
integrate kubernetes into managed

00:01:03,039 --> 00:01:05,199
delivery and discuss some further

00:01:04,559 --> 00:01:08,240
opportunities

00:01:05,199 --> 00:01:08,240
we see in this space

00:01:09,040 --> 00:01:13,200
so let's do a quick recap of managed

00:01:10,799 --> 00:01:14,799
delivery by the way i highly encourage

00:01:13,200 --> 00:01:16,479
you to check out the talk from last

00:01:14,799 --> 00:01:19,200
year's summit by my colleagues

00:01:16,479 --> 00:01:19,920
emily burns and rob fletcher which goes

00:01:19,200 --> 00:01:22,240
into

00:01:19,920 --> 00:01:25,040
much more detail in this material but

00:01:22,240 --> 00:01:25,040
here is a summary

00:01:25,280 --> 00:01:29,520
spinnaker was launched in 2015 and

00:01:27,759 --> 00:01:31,360
revolutionized the way that developers

00:01:29,520 --> 00:01:32,320
and teams approached continuous delivery

00:01:31,360 --> 00:01:34,960
on netflix and

00:01:32,320 --> 00:01:36,720
many other companies the primary

00:01:34,960 --> 00:01:38,960
abstraction provided by spinnaker to

00:01:36,720 --> 00:01:39,280
model delivery workflows was pipelines

00:01:38,960 --> 00:01:41,360
as

00:01:39,280 --> 00:01:43,119
you're all familiar with in the

00:01:41,360 --> 00:01:45,520
beginning all was well and good

00:01:43,119 --> 00:01:46,640
we had a few apps with relatively simple

00:01:45,520 --> 00:01:49,840
delivery flows

00:01:46,640 --> 00:01:49,840
developers were happy

00:01:49,920 --> 00:01:54,000
fast forward to 2020 however and things

00:01:52,640 --> 00:01:55,680
look a little bit more like the right

00:01:54,000 --> 00:01:57,360
hand side of this picture

00:01:55,680 --> 00:01:59,600
teams have to manage a larger number of

00:01:57,360 --> 00:02:01,920
apps which are much more complex

00:01:59,600 --> 00:02:03,600
they end up with many unique pipelines

00:02:01,920 --> 00:02:05,520
or even if they're using pipeline

00:02:03,600 --> 00:02:06,079
templates they find that it's not easy

00:02:05,520 --> 00:02:08,959
to keep

00:02:06,079 --> 00:02:11,440
the similar pipelines up to date and if

00:02:08,959 --> 00:02:13,120
you're on a centralized team like i am

00:02:11,440 --> 00:02:14,640
and there is a new practice you want to

00:02:13,120 --> 00:02:16,640
promote you now have

00:02:14,640 --> 00:02:18,239
all these different places to upgrade it

00:02:16,640 --> 00:02:20,959
requires a massive effort and

00:02:18,239 --> 00:02:22,080
coordination in this state of the world

00:02:20,959 --> 00:02:24,640
developers are obviously

00:02:22,080 --> 00:02:25,760
not very happy and wonder why this is so

00:02:24,640 --> 00:02:27,760
complicated

00:02:25,760 --> 00:02:29,599
which leads us to a question we often

00:02:27,760 --> 00:02:31,440
find ourselves asking users

00:02:29,599 --> 00:02:33,280
when they reach out for support in our

00:02:31,440 --> 00:02:36,160
support channels on netflix but i'm sure

00:02:33,280 --> 00:02:39,360
this happens at other places as well

00:02:36,160 --> 00:02:39,360
what are you trying to do

00:02:40,319 --> 00:02:44,720
in other words what's your intent the

00:02:43,280 --> 00:02:46,720
answer might be something like

00:02:44,720 --> 00:02:49,120
i'm trying to deploy a debian package to

00:02:46,720 --> 00:02:51,040
my test environment

00:02:49,120 --> 00:02:54,400
or maybe something like i'm just trying

00:02:51,040 --> 00:02:56,560
to figure out why my pipeline is failing

00:02:54,400 --> 00:02:58,560
oh and by the way the person who created

00:02:56,560 --> 00:03:02,000
this pipeline has left the company and i

00:02:58,560 --> 00:03:04,159
have no idea how to change it

00:03:02,000 --> 00:03:06,080
but in the end what we find developers

00:03:04,159 --> 00:03:06,879
really want is simply for things to be

00:03:06,080 --> 00:03:08,480
easier

00:03:06,879 --> 00:03:10,159
they want to spend more time on their

00:03:08,480 --> 00:03:10,879
code creating business value for the

00:03:10,159 --> 00:03:13,040
company

00:03:10,879 --> 00:03:16,640
and less time worrying about the details

00:03:13,040 --> 00:03:18,720
of infrastructure and delivery

00:03:16,640 --> 00:03:20,319
when we ask them about the ideal

00:03:18,720 --> 00:03:22,400
experience they tell us

00:03:20,319 --> 00:03:24,239
things like i want to store my config

00:03:22,400 --> 00:03:27,120
code so i can use the same process i'm

00:03:24,239 --> 00:03:28,720
already familiar with like pull requests

00:03:27,120 --> 00:03:30,400
i want someone else to decide these

00:03:28,720 --> 00:03:32,640
basics on infrastructure

00:03:30,400 --> 00:03:34,400
and delivery and keep them up to date

00:03:32,640 --> 00:03:36,239
this includes things like standardized

00:03:34,400 --> 00:03:39,440
decisions on compute resources

00:03:36,239 --> 00:03:41,440
instance sizes security etc

00:03:39,440 --> 00:03:43,920
and i want to easily manage many similar

00:03:41,440 --> 00:03:43,920
configs

00:03:44,720 --> 00:03:49,760
based on this feedback we envisioned

00:03:46,879 --> 00:03:51,680
manage delivery

00:03:49,760 --> 00:03:53,519
with managed delivery you define your

00:03:51,680 --> 00:03:54,480
infrastructure and delivery requirements

00:03:53,519 --> 00:03:56,080
as code

00:03:54,480 --> 00:03:58,560
you tell us what the end stage should

00:03:56,080 --> 00:04:00,319
look like and we take care of the rest

00:03:58,560 --> 00:04:02,080
another way of saying this is that you

00:04:00,319 --> 00:04:03,120
can specify your infrastructure and

00:04:02,080 --> 00:04:06,319
delivery flows

00:04:03,120 --> 00:04:08,159
declaratively as opposed to imperatively

00:04:06,319 --> 00:04:10,879
as you did with manual tasks or

00:04:08,159 --> 00:04:12,799
pipelines in spinnaker before

00:04:10,879 --> 00:04:14,640
for central teams providing solutions to

00:04:12,799 --> 00:04:16,639
developers we want to provide a way to

00:04:14,640 --> 00:04:18,479
share configs's best practices

00:04:16,639 --> 00:04:20,079
so that people who are the experts in

00:04:18,479 --> 00:04:21,840
each area can make those decisions on

00:04:20,079 --> 00:04:23,840
the developers behalf

00:04:21,840 --> 00:04:25,680
we also want to provide tools for these

00:04:23,840 --> 00:04:28,400
teams to update these codified best

00:04:25,680 --> 00:04:30,240
practices and safely roll them out

00:04:28,400 --> 00:04:32,240
finally manage delivery was designed

00:04:30,240 --> 00:04:32,960
from the ground up with extensibility in

00:04:32,240 --> 00:04:35,040
mind

00:04:32,960 --> 00:04:36,560
we provide pluggable extension spots for

00:04:35,040 --> 00:04:39,280
others to inject opinions and

00:04:36,560 --> 00:04:39,280
functionality

00:04:41,040 --> 00:04:44,400
before we move to some more concrete

00:04:42,800 --> 00:04:44,880
examples of what this all looks like in

00:04:44,400 --> 00:04:46,560
practice

00:04:44,880 --> 00:04:49,120
here are some definitions to set the

00:04:46,560 --> 00:04:50,479
stage an artifact is just a version

00:04:49,120 --> 00:04:51,440
software package that you deploy

00:04:50,479 --> 00:04:53,280
somewhere

00:04:51,440 --> 00:04:55,520
a resource is a piece of infrastructure

00:04:53,280 --> 00:04:56,800
you may manage declaratively say an ec2

00:04:55,520 --> 00:04:58,880
cluster

00:04:56,800 --> 00:05:02,160
the spec is a user supply definition of

00:04:58,880 --> 00:05:03,680
this resource that specifies the details

00:05:02,160 --> 00:05:05,520
current state is the actual state of

00:05:03,680 --> 00:05:06,960
this resource in the cloud if it exists

00:05:05,520 --> 00:05:09,440
so in the cluster example

00:05:06,960 --> 00:05:10,080
let's say you have three instances that

00:05:09,440 --> 00:05:12,960
are m5

00:05:10,080 --> 00:05:14,720
large in aws the desired state is the

00:05:12,960 --> 00:05:15,360
state you like the resource to be in at

00:05:14,720 --> 00:05:16,960
all times

00:05:15,360 --> 00:05:18,880
so in the same example let's say you

00:05:16,960 --> 00:05:22,000
would like your clusters to always have

00:05:18,880 --> 00:05:23,680
five instances the environment is just a

00:05:22,000 --> 00:05:24,000
logical grouping of resources you're

00:05:23,680 --> 00:05:25,600
very

00:05:24,000 --> 00:05:27,440
very familiar with this concept already

00:05:25,600 --> 00:05:30,000
so test staging prod

00:05:27,440 --> 00:05:31,520
etc and then finally constraints are

00:05:30,000 --> 00:05:32,000
just gates to promote an artifact

00:05:31,520 --> 00:05:34,880
version

00:05:32,000 --> 00:05:34,880
into an environment

00:05:35,039 --> 00:05:39,039
okay with these definitions in mind

00:05:37,120 --> 00:05:41,199
here's an example of a declarative

00:05:39,039 --> 00:05:42,880
resource definition

00:05:41,199 --> 00:05:44,560
if you're familiar with kubernetes which

00:05:42,880 --> 00:05:45,840
i'm guessing you are since you are here

00:05:44,560 --> 00:05:47,600
in this talk

00:05:45,840 --> 00:05:50,080
this format should look very familiar to

00:05:47,600 --> 00:05:51,039
you every resource in managed delivery

00:05:50,080 --> 00:05:53,520
has a kind

00:05:51,039 --> 00:05:54,560
which is composed of a group a type and

00:05:53,520 --> 00:05:56,400
a version

00:05:54,560 --> 00:05:58,319
and a spec which is the actual body of

00:05:56,400 --> 00:05:59,680
the resource definition

00:05:58,319 --> 00:06:01,919
here we're looking at a sample

00:05:59,680 --> 00:06:03,520
definition for the music 2 cluster again

00:06:01,919 --> 00:06:05,520
so you can see some fields as you might

00:06:03,520 --> 00:06:06,080
expect like the launch configuration the

00:06:05,520 --> 00:06:07,600
account

00:06:06,080 --> 00:06:10,080
and the regions where the cluster will

00:06:07,600 --> 00:06:12,160
run out for the box

00:06:10,080 --> 00:06:13,840
if you get open source code from github

00:06:12,160 --> 00:06:15,039
manage delivery comes with support for

00:06:13,840 --> 00:06:17,280
ec2 clusters

00:06:15,039 --> 00:06:19,120
security groups and load balancers as

00:06:17,280 --> 00:06:20,000
well as titus clusters which run in

00:06:19,120 --> 00:06:22,319
netflix's own

00:06:20,000 --> 00:06:24,400
container orchestration system but you

00:06:22,319 --> 00:06:25,919
can extend manage delivery via plugins

00:06:24,400 --> 00:06:27,759
which is how we've added support for

00:06:25,919 --> 00:06:28,479
kubernetes as you'll learn more about

00:06:27,759 --> 00:06:32,240
from nema

00:06:28,479 --> 00:06:34,240
later declarative

00:06:32,240 --> 00:06:35,919
infrastructure sounds cool but here's

00:06:34,240 --> 00:06:37,840
where it gets really interesting

00:06:35,919 --> 00:06:39,919
once we wrap those definitions in what

00:06:37,840 --> 00:06:42,160
we call a delivery config

00:06:39,919 --> 00:06:44,160
a delivery config is the manifest file

00:06:42,160 --> 00:06:46,160
used in managed delivery to specify not

00:06:44,160 --> 00:06:47,520
just your infrastructure resources

00:06:46,160 --> 00:06:49,120
but where they live in logical

00:06:47,520 --> 00:06:50,639
environments and how your software

00:06:49,120 --> 00:06:51,680
artifacts should be deployed to those

00:06:50,639 --> 00:06:54,240
environments

00:06:51,680 --> 00:06:56,000
it's composed of these three main parts

00:06:54,240 --> 00:06:57,360
artifacts is where you specify how

00:06:56,000 --> 00:06:58,240
spinnaker will find your published

00:06:57,360 --> 00:07:00,160
artifacts

00:06:58,240 --> 00:07:01,360
in this example we have a debian package

00:07:00,160 --> 00:07:02,800
named keel demo

00:07:01,360 --> 00:07:04,560
which spinnaker will look up in the

00:07:02,800 --> 00:07:06,240
artifact registry

00:07:04,560 --> 00:07:08,160
we use some versioning conventions to

00:07:06,240 --> 00:07:10,639
sort artifacts and identify when a new

00:07:08,160 --> 00:07:12,800
one becomes available for deployment

00:07:10,639 --> 00:07:14,720
next we have environments this is where

00:07:12,800 --> 00:07:16,479
you map your infrastructure resources to

00:07:14,720 --> 00:07:18,560
logical environments like test staging

00:07:16,479 --> 00:07:20,400
or prod as i was just saying

00:07:18,560 --> 00:07:22,400
each environment can then declare one or

00:07:20,400 --> 00:07:23,680
more constraints for approval of new

00:07:22,400 --> 00:07:25,440
artifact versions

00:07:23,680 --> 00:07:27,440
in this example we have a depends on

00:07:25,440 --> 00:07:29,199
constraint which means that an artifact

00:07:27,440 --> 00:07:30,319
version will only be deployed to the

00:07:29,199 --> 00:07:32,240
broad environment

00:07:30,319 --> 00:07:34,080
if it has successfully been previously

00:07:32,240 --> 00:07:35,919
deployed to the test environment

00:07:34,080 --> 00:07:37,680
we support other artifact constraints as

00:07:35,919 --> 00:07:42,000
well such as manual approvals

00:07:37,680 --> 00:07:44,080
and deployment windows with more to come

00:07:42,000 --> 00:07:45,039
i wanted to touch briefly on how keel

00:07:44,080 --> 00:07:46,960
which is the

00:07:45,039 --> 00:07:48,319
spinnaker service that implements the

00:07:46,960 --> 00:07:50,479
bulk of managed delivery

00:07:48,319 --> 00:07:52,240
operates under the covers because this

00:07:50,479 --> 00:07:53,440
is another way in which kubernetes comes

00:07:52,240 --> 00:07:55,120
into the picture

00:07:53,440 --> 00:07:57,280
as we were heavily influenced by the

00:07:55,120 --> 00:07:59,599
kubernetes design on resolving drifts

00:07:57,280 --> 00:08:01,520
before desired state and current state

00:07:59,599 --> 00:08:03,360
in essence it's a pretty straightforward

00:08:01,520 --> 00:08:05,199
process we have a loop

00:08:03,360 --> 00:08:06,800
and for each resource that we know about

00:08:05,199 --> 00:08:08,240
keel will last the corresponding

00:08:06,800 --> 00:08:09,919
resource handler plugin

00:08:08,240 --> 00:08:11,520
for its current state and the desired

00:08:09,919 --> 00:08:13,360
state and then compare the two

00:08:11,520 --> 00:08:15,120
if there's a difference between desired

00:08:13,360 --> 00:08:16,720
and current kill will call the resource

00:08:15,120 --> 00:08:17,680
handler plug-in again to resolve the

00:08:16,720 --> 00:08:19,759
demo

00:08:17,680 --> 00:08:21,680
so in the example i mentioned earlier

00:08:19,759 --> 00:08:24,080
let's say you have an ec2 cluster

00:08:21,680 --> 00:08:25,919
that has three instances right now and

00:08:24,080 --> 00:08:26,960
you set your desired state to five

00:08:25,919 --> 00:08:28,639
instances so

00:08:26,960 --> 00:08:30,960
kill will detect that difference and

00:08:28,639 --> 00:08:34,240
will ask the resource handler to

00:08:30,960 --> 00:08:35,599
correct the difference once again i

00:08:34,240 --> 00:08:37,279
wanted to emphasize that resource

00:08:35,599 --> 00:08:40,080
handlers are plugins this means that you

00:08:37,279 --> 00:08:42,240
can write your own

00:08:40,080 --> 00:08:43,599
all right enough with the theory let's

00:08:42,240 --> 00:08:46,720
see what the current state of managed

00:08:43,599 --> 00:08:48,720
delivery looks like in action

00:08:46,720 --> 00:08:50,480
here's the brand new environments view

00:08:48,720 --> 00:08:52,240
here you can get an overview of all of

00:08:50,480 --> 00:08:54,080
your environments and artifact versions

00:08:52,240 --> 00:08:55,680
at a glance

00:08:54,080 --> 00:08:57,839
you can drill down into a specific

00:08:55,680 --> 00:08:59,760
artifact version by clicking on it

00:08:57,839 --> 00:09:01,360
when you do you can see exactly the

00:08:59,760 --> 00:09:03,200
state that version was in

00:09:01,360 --> 00:09:04,800
in the various environments for example

00:09:03,200 --> 00:09:07,120
here you can see keel itself

00:09:04,800 --> 00:09:09,519
managed by managed delivery yep we dog

00:09:07,120 --> 00:09:10,640
food and that the latest version that's

00:09:09,519 --> 00:09:12,320
at the top there

00:09:10,640 --> 00:09:14,399
is currently deployed in all three of

00:09:12,320 --> 00:09:15,120
our environments tests pre-staging and

00:09:14,399 --> 00:09:16,720
main

00:09:15,120 --> 00:09:18,240
we also have integration with the source

00:09:16,720 --> 00:09:20,160
control system so you can see

00:09:18,240 --> 00:09:22,399
details about the commit associated with

00:09:20,160 --> 00:09:22,959
artifacts on the top right hand corner

00:09:22,399 --> 00:09:24,640
there

00:09:22,959 --> 00:09:26,240
this is a first for spinnaker and it

00:09:24,640 --> 00:09:29,040
gives you great visibility we're really

00:09:26,240 --> 00:09:29,040
excited about this

00:09:29,279 --> 00:09:32,959
next i wanted to show you how a manual

00:09:31,360 --> 00:09:36,080
promotion artifact flow

00:09:32,959 --> 00:09:37,839
looks like as you can see in the ui

00:09:36,080 --> 00:09:39,839
here i specified a manual judgment

00:09:37,839 --> 00:09:41,760
constraint on the staging environment so

00:09:39,839 --> 00:09:43,360
the artifact will not be deployed there

00:09:41,760 --> 00:09:45,040
until i approve

00:09:43,360 --> 00:09:46,399
i can do that from the ui as you can see

00:09:45,040 --> 00:09:48,080
here by clicking that button

00:09:46,399 --> 00:09:50,320
button but a much cooler way of doing

00:09:48,080 --> 00:09:52,000
this is using slack

00:09:50,320 --> 00:09:54,000
here you can get a slack notification

00:09:52,000 --> 00:09:56,000
that has interactive buttons to approve

00:09:54,000 --> 00:09:57,760
or reject the artifact promotion

00:09:56,000 --> 00:09:59,440
if you're constantly on slack like we

00:09:57,760 --> 00:10:01,519
are especially now with covet

00:09:59,440 --> 00:10:03,120
and lockdowns this makes your life so

00:10:01,519 --> 00:10:07,279
much easier our users

00:10:03,120 --> 00:10:09,120
love this feature next up is spinning

00:10:07,279 --> 00:10:10,959
as the name indicates pinning allows you

00:10:09,120 --> 00:10:12,079
to pin a specific version of an artifact

00:10:10,959 --> 00:10:14,880
to an environment

00:10:12,079 --> 00:10:17,040
bypassing any promotion constraints this

00:10:14,880 --> 00:10:18,800
is another feature that our users love

00:10:17,040 --> 00:10:20,320
because it allows you to easily roll

00:10:18,800 --> 00:10:22,000
back in case of a problem

00:10:20,320 --> 00:10:23,760
or expedite a deployment if you're in

00:10:22,000 --> 00:10:25,680
the rush to get a hotfix out

00:10:23,760 --> 00:10:27,360
let's say you're in the middle of an

00:10:25,680 --> 00:10:28,720
incident and you can't wait for the

00:10:27,360 --> 00:10:29,760
artifact to go through the usual

00:10:28,720 --> 00:10:31,600
promotion flow

00:10:29,760 --> 00:10:32,959
from tests to staging and then prod you

00:10:31,600 --> 00:10:36,160
just need to get it out

00:10:32,959 --> 00:10:37,680
this is how you do it when you click

00:10:36,160 --> 00:10:39,279
that pin button spinnaker will

00:10:37,680 --> 00:10:40,399
immediately start deploying that version

00:10:39,279 --> 00:10:41,760
in that environment

00:10:40,399 --> 00:10:43,200
if you're familiar with the current

00:10:41,760 --> 00:10:43,920
experience of rolling things back in

00:10:43,200 --> 00:10:45,519
spinnaker

00:10:43,920 --> 00:10:47,200
you will understand how much better this

00:10:45,519 --> 00:10:47,760
experience is in terms of the ease of

00:10:47,200 --> 00:10:49,440
use

00:10:47,760 --> 00:10:52,640
and the visibility you get about what's

00:10:49,440 --> 00:10:54,160
going on it's just great

00:10:52,640 --> 00:10:55,760
and here you see the version deployed

00:10:54,160 --> 00:10:57,279
and the pin icon over the artifact

00:10:55,760 --> 00:11:00,560
version and environment on the left hand

00:10:57,279 --> 00:11:02,160
side which makes it easy to spot

00:11:00,560 --> 00:11:04,320
the last feature i wanted to show you is

00:11:02,160 --> 00:11:05,680
what we call marking a version as bad

00:11:04,320 --> 00:11:07,360
this allows you to make sure that a

00:11:05,680 --> 00:11:09,040
virgin will never ever be deployed in

00:11:07,360 --> 00:11:09,839
that environment again not even by

00:11:09,040 --> 00:11:12,720
accident

00:11:09,839 --> 00:11:14,000
so back to our fictitious example of the

00:11:12,720 --> 00:11:15,600
incident scenario

00:11:14,000 --> 00:11:16,640
imagine that you found a really bad bug

00:11:15,600 --> 00:11:17,360
in the version that's currently in

00:11:16,640 --> 00:11:18,720
production

00:11:17,360 --> 00:11:20,560
and then you're going to pin a different

00:11:18,720 --> 00:11:22,160
one to fix the problem well

00:11:20,560 --> 00:11:23,839
you want to make sure that even if you

00:11:22,160 --> 00:11:25,760
roll back in the future you never end up

00:11:23,839 --> 00:11:28,320
deploying that bad version by accident

00:11:25,760 --> 00:11:30,079
so this is how you do it

00:11:28,320 --> 00:11:32,959
once you mark it as badge this is what

00:11:30,079 --> 00:11:32,959
the ui looks like

00:11:33,839 --> 00:11:37,760
all right i hope that was exciting to

00:11:35,600 --> 00:11:39,200
see i know i get excited all over again

00:11:37,760 --> 00:11:41,440
every time i talk about this stuff

00:11:39,200 --> 00:11:42,959
because it's truly awesome

00:11:41,440 --> 00:11:45,040
the last thing i wanted to cover is

00:11:42,959 --> 00:11:46,640
extensibility as i mentioned earlier

00:11:45,040 --> 00:11:48,480
managed delivery was designed to be

00:11:46,640 --> 00:11:51,200
extensible from the ground up

00:11:48,480 --> 00:11:52,480
and it comes with a bunch of plugins or

00:11:51,200 --> 00:11:53,680
extension points

00:11:52,480 --> 00:11:55,680
here the extension points that we

00:11:53,680 --> 00:11:57,600
support today we have resource handlers

00:11:55,680 --> 00:12:00,959
which allow you to implement your own

00:11:57,600 --> 00:12:02,399
resource definitions we have resolvers

00:12:00,959 --> 00:12:04,079
which allow you to inject your own

00:12:02,399 --> 00:12:06,399
opinions or smart defaults

00:12:04,079 --> 00:12:08,560
into the resource packs constraint

00:12:06,399 --> 00:12:10,320
evaluators allow you to

00:12:08,560 --> 00:12:12,240
implement your own promotion constraints

00:12:10,320 --> 00:12:12,959
for artifacts and then artifact

00:12:12,240 --> 00:12:15,760
suppliers

00:12:12,959 --> 00:12:17,440
allow you to even build in new artifact

00:12:15,760 --> 00:12:19,440
types for spinnaker

00:12:17,440 --> 00:12:20,959
with ease the sky is truly the limit for

00:12:19,440 --> 00:12:22,639
all the new and cool ways in which you

00:12:20,959 --> 00:12:24,399
can extend manage delivery

00:12:22,639 --> 00:12:26,000
and to talk exactly about that i would

00:12:24,399 --> 00:12:27,680
now like to hand it over to my friend

00:12:26,000 --> 00:12:30,720
rob hilton from aws

00:12:27,680 --> 00:12:32,160
rob thanks luis

00:12:30,720 --> 00:12:33,680
as mentioned my name is rob hilton and

00:12:32,160 --> 00:12:35,040
i'm a principal solutions architect with

00:12:33,680 --> 00:12:36,160
aws

00:12:35,040 --> 00:12:38,320
now that we have some background on

00:12:36,160 --> 00:12:39,760
managed delivery i'd like to explore the

00:12:38,320 --> 00:12:41,360
relationship between spinnaker and

00:12:39,760 --> 00:12:43,120
kubernetes a bit

00:12:41,360 --> 00:12:44,800
to do that however i'd like to tell you

00:12:43,120 --> 00:12:47,360
a story about the way things were

00:12:44,800 --> 00:12:48,959
back in my day so gather round one and

00:12:47,360 --> 00:12:51,200
all and let rob take you on a journey

00:12:48,959 --> 00:12:52,880
into technology's past

00:12:51,200 --> 00:12:54,639
in the days of spinnaker your five to

00:12:52,880 --> 00:12:56,240
ten years ago the orchestration of

00:12:54,639 --> 00:12:57,279
infrastructure was a very sequential

00:12:56,240 --> 00:12:59,040
process

00:12:57,279 --> 00:13:00,720
in many ways it still is an

00:12:59,040 --> 00:13:02,320
all-too-common example is probably one

00:13:00,720 --> 00:13:04,639
that you're already familiar with

00:13:02,320 --> 00:13:05,360
and that's creating externally facing

00:13:04,639 --> 00:13:08,399
instances

00:13:05,360 --> 00:13:09,839
on aws ec2 assuming you've already

00:13:08,399 --> 00:13:10,480
created all the appropriate virtual

00:13:09,839 --> 00:13:13,040
networking

00:13:10,480 --> 00:13:14,720
it's a multi-step process first we

00:13:13,040 --> 00:13:17,040
create our security groups

00:13:14,720 --> 00:13:18,800
then we create our launch configurations

00:13:17,040 --> 00:13:20,160
and then auto scaling groups

00:13:18,800 --> 00:13:22,880
and we eventually create our load

00:13:20,160 --> 00:13:26,639
balancers another word for this process

00:13:22,880 --> 00:13:28,560
is imperative meaning that you tell aws

00:13:26,639 --> 00:13:30,720
how to create things and in what

00:13:28,560 --> 00:13:32,240
specific order

00:13:30,720 --> 00:13:34,000
it made sense for early deployment tool

00:13:32,240 --> 00:13:35,600
chains to simplify that process for

00:13:34,000 --> 00:13:36,880
developers and operators

00:13:35,600 --> 00:13:38,639
many application deployments look

00:13:36,880 --> 00:13:40,320
similar so why not allow for the

00:13:38,639 --> 00:13:41,839
opinionated automation

00:13:40,320 --> 00:13:43,600
of the creation and management of those

00:13:41,839 --> 00:13:45,360
assets

00:13:43,600 --> 00:13:47,519
early spinnaker providers did exactly

00:13:45,360 --> 00:13:49,199
that they were abstractions that enabled

00:13:47,519 --> 00:13:50,639
easy interfacing to nuanced

00:13:49,199 --> 00:13:54,240
infrastructure providers

00:13:50,639 --> 00:13:55,920
like aws ec2 as an example

00:13:54,240 --> 00:13:57,760
luis talked about the pipeline story

00:13:55,920 --> 00:14:00,560
earlier and as we learned then

00:13:57,760 --> 00:14:01,680
pipelines took things a step further

00:14:00,560 --> 00:14:02,079
they allowed you to start stringing

00:14:01,680 --> 00:14:03,920
together

00:14:02,079 --> 00:14:05,279
multiple providers and events and

00:14:03,920 --> 00:14:08,160
effectively say

00:14:05,279 --> 00:14:10,079
do these things in this order when

00:14:08,160 --> 00:14:14,639
triggered by that

00:14:10,079 --> 00:14:16,240
and the world was happy or so we thought

00:14:14,639 --> 00:14:18,079
over the last five-ish years with

00:14:16,240 --> 00:14:20,000
increased adoption of kubernetes

00:14:18,079 --> 00:14:22,160
those paradigms have changed in some

00:14:20,000 --> 00:14:23,600
interesting ways

00:14:22,160 --> 00:14:25,760
if you adopted kubernetes you were

00:14:23,600 --> 00:14:28,320
suddenly defining your infrastructure

00:14:25,760 --> 00:14:31,199
declaratively or in other words

00:14:28,320 --> 00:14:34,000
specifying your end state

00:14:31,199 --> 00:14:35,839
let's take a look at this example here

00:14:34,000 --> 00:14:38,079
we see some fairly simple flat yaml

00:14:35,839 --> 00:14:39,920
defined for kubernetes

00:14:38,079 --> 00:14:41,760
looks pretty clean looks pretty simple

00:14:39,920 --> 00:14:43,680
overall if we segment it down a little

00:14:41,760 --> 00:14:45,199
further however we can see two distinct

00:14:43,680 --> 00:14:47,440
bits of an application

00:14:45,199 --> 00:14:49,279
we see redis on the bottom and we see an

00:14:47,440 --> 00:14:50,639
application that's reliant on redis on

00:14:49,279 --> 00:14:53,040
top

00:14:50,639 --> 00:14:55,360
further segmentation shows services

00:14:53,040 --> 00:14:58,320
which effectively enable communication

00:14:55,360 --> 00:14:58,880
to those application bits if we think

00:14:58,320 --> 00:15:01,199
about

00:14:58,880 --> 00:15:02,079
the implication there we realize that

00:15:01,199 --> 00:15:04,639
the services

00:15:02,079 --> 00:15:05,760
the communication pieces are dependent

00:15:04,639 --> 00:15:07,839
on the application

00:15:05,760 --> 00:15:09,360
in order to function and if we segment

00:15:07,839 --> 00:15:11,680
it further we can see another

00:15:09,360 --> 00:15:12,480
implicit dependency that the application

00:15:11,680 --> 00:15:15,600
on top

00:15:12,480 --> 00:15:17,440
is dependent on redis on the bottom

00:15:15,600 --> 00:15:19,440
but with all of those underlying

00:15:17,440 --> 00:15:21,680
constraints and implicit references

00:15:19,440 --> 00:15:23,760
we don't have to specify any of those

00:15:21,680 --> 00:15:25,360
things we don't have to specify that we

00:15:23,760 --> 00:15:26,079
need our deployments before we need our

00:15:25,360 --> 00:15:28,720
services

00:15:26,079 --> 00:15:30,399
we specify our end state for all of it

00:15:28,720 --> 00:15:33,120
and kubernetes works through reaching

00:15:30,399 --> 00:15:35,759
that end state on its own

00:15:33,120 --> 00:15:37,600
and that's how kubernetes is declarative

00:15:35,759 --> 00:15:39,920
but that raises a question

00:15:37,600 --> 00:15:40,959
so how should we use a delivery tool

00:15:39,920 --> 00:15:42,800
like spinnaker

00:15:40,959 --> 00:15:45,199
and how should it handle kubernetes in

00:15:42,800 --> 00:15:46,720
this type of ecosystem

00:15:45,199 --> 00:15:48,800
in the first variation of the provider

00:15:46,720 --> 00:15:51,920
the strategy was fairly similar

00:15:48,800 --> 00:15:54,079
to other imperative providers like ec2

00:15:51,920 --> 00:15:55,199
simplify the interface provide a clean

00:15:54,079 --> 00:15:57,199
ui

00:15:55,199 --> 00:15:59,040
automate the consistent pieces and make

00:15:57,199 --> 00:16:01,920
things easier for developers

00:15:59,040 --> 00:16:03,440
and operators and this worked really

00:16:01,920 --> 00:16:05,519
really really well

00:16:03,440 --> 00:16:06,720
in most instances it provided a much

00:16:05,519 --> 00:16:08,480
cleaner operation

00:16:06,720 --> 00:16:10,959
of kubernetes for users who were

00:16:08,480 --> 00:16:13,440
unfamiliar with the admittedly complex

00:16:10,959 --> 00:16:15,120
syntax of the yaml manifests that

00:16:13,440 --> 00:16:18,880
kubernetes expects

00:16:15,120 --> 00:16:20,399
however there was a problem with this

00:16:18,880 --> 00:16:22,000
and that's the flexible nature of

00:16:20,399 --> 00:16:24,240
kubernetes manifests and the

00:16:22,000 --> 00:16:24,959
extensibility in things like api

00:16:24,240 --> 00:16:27,040
versions

00:16:24,959 --> 00:16:28,800
as well as custom resource definitions

00:16:27,040 --> 00:16:31,360
meant that spinnaker was either

00:16:28,800 --> 00:16:32,560
missing functionality at all times or

00:16:31,360 --> 00:16:35,199
playing catch-up

00:16:32,560 --> 00:16:36,720
with kubernetes fairly volatile api

00:16:35,199 --> 00:16:39,519
definitions

00:16:36,720 --> 00:16:41,199
additionally it also somewhat mitigated

00:16:39,519 --> 00:16:44,560
the elegance that comes along

00:16:41,199 --> 00:16:46,800
with declarative manifest definition so

00:16:44,560 --> 00:16:48,160
with that version 2 of the kubernetes

00:16:46,800 --> 00:16:50,160
provider was born

00:16:48,160 --> 00:16:52,880
and the second version fully adopted

00:16:50,160 --> 00:16:54,480
kubernetes declarative design paradigms

00:16:52,880 --> 00:16:56,480
you as a user pass in whatever

00:16:54,480 --> 00:16:59,680
kubernetes manifests that you want

00:16:56,480 --> 00:17:02,000
and spinnaker will deploy them we're

00:16:59,680 --> 00:17:03,839
still in a bit of an odd spot though

00:17:02,000 --> 00:17:05,280
and that's why the kubernetes is

00:17:03,839 --> 00:17:06,319
declarative and flexible

00:17:05,280 --> 00:17:09,280
it's also what i like to call

00:17:06,319 --> 00:17:10,480
declarative in isolation

00:17:09,280 --> 00:17:12,160
at the end of the day we have to

00:17:10,480 --> 00:17:13,360
remember that kubernetes is a container

00:17:12,160 --> 00:17:15,280
orchestrator

00:17:13,360 --> 00:17:17,199
and despite all appearances it's a

00:17:15,280 --> 00:17:19,760
fairly isolated one

00:17:17,199 --> 00:17:21,360
kubernetes manifests are cluster bound

00:17:19,760 --> 00:17:22,559
meaning that they apply only to a single

00:17:21,360 --> 00:17:24,959
cluster

00:17:22,559 --> 00:17:25,839
it falls to you or some kind of external

00:17:24,959 --> 00:17:27,760
tool chain

00:17:25,839 --> 00:17:28,960
to be able to replicate those manifests

00:17:27,760 --> 00:17:30,799
across clusters

00:17:28,960 --> 00:17:32,960
or to templatize them so they differ

00:17:30,799 --> 00:17:35,360
from one environment to the next

00:17:32,960 --> 00:17:37,120
additionally while kubernetes can

00:17:35,360 --> 00:17:37,600
interface with external services to

00:17:37,120 --> 00:17:39,919
enable

00:17:37,600 --> 00:17:41,280
extra functionality uh testing

00:17:39,919 --> 00:17:42,799
interfacing with other infrastructure

00:17:41,280 --> 00:17:44,160
providers for example

00:17:42,799 --> 00:17:46,000
those implementations are generally

00:17:44,160 --> 00:17:48,320
provided by third-party plug-ins that

00:17:46,000 --> 00:17:49,760
install themselves into kubernetes many

00:17:48,320 --> 00:17:51,600
of which aren't as mature

00:17:49,760 --> 00:17:53,840
or well-maintained as something like

00:17:51,600 --> 00:17:55,039
spinnaker which specializes in those

00:17:53,840 --> 00:17:56,880
kinds of flows

00:17:55,039 --> 00:17:59,120
so the question becomes where does that

00:17:56,880 --> 00:18:00,640
leave us

00:17:59,120 --> 00:18:02,400
our interface point with spinnaker is

00:18:00,640 --> 00:18:04,080
declarative yes

00:18:02,400 --> 00:18:06,000
but as louise showed you earlier

00:18:04,080 --> 00:18:07,600
spinnaker's pipelining tools are still

00:18:06,000 --> 00:18:10,320
inherently imperative

00:18:07,600 --> 00:18:12,080
as of right now relying on you to

00:18:10,320 --> 00:18:16,160
explicitly define the how

00:18:12,080 --> 00:18:21,360
and when in short declarative

00:18:16,160 --> 00:18:21,360
plus imperative confusion

00:18:21,919 --> 00:18:24,960
i can hear what you're thinking out

00:18:22,799 --> 00:18:27,120
there in the virtual ether though

00:18:24,960 --> 00:18:28,320
but wait isn't managed delivery

00:18:27,120 --> 00:18:31,280
declarative

00:18:28,320 --> 00:18:33,600
doesn't it have a similar api structure

00:18:31,280 --> 00:18:36,400
how insightful you are anthropomorphic

00:18:33,600 --> 00:18:38,160
slide and you are absolutely right

00:18:36,400 --> 00:18:39,760
in our conversations and collaborations

00:18:38,160 --> 00:18:41,520
with luis and the rest of the team about

00:18:39,760 --> 00:18:42,400
managed delivery and the problems it

00:18:41,520 --> 00:18:44,720
solves

00:18:42,400 --> 00:18:46,000
for delivery tool chains together we

00:18:44,720 --> 00:18:47,120
found a clear parallel with the

00:18:46,000 --> 00:18:49,520
kubernetes world

00:18:47,120 --> 00:18:51,360
and thus our collaboration story was

00:18:49,520 --> 00:18:53,520
born

00:18:51,360 --> 00:18:54,960
we have two major things that right now

00:18:53,520 --> 00:18:55,679
are separated that we can take into

00:18:54,960 --> 00:18:56,880
account

00:18:55,679 --> 00:18:59,200
we have our infrastructure

00:18:56,880 --> 00:19:00,480
configurations which can be kubernetes

00:18:59,200 --> 00:19:02,160
or otherwise

00:19:00,480 --> 00:19:04,480
and they're defined declaratively in a

00:19:02,160 --> 00:19:07,679
developer friendly language

00:19:04,480 --> 00:19:09,600
and we also have delivery configurations

00:19:07,679 --> 00:19:11,600
also defined declaratively and in a

00:19:09,600 --> 00:19:14,720
developer friendly language

00:19:11,600 --> 00:19:17,760
one thing defines what one thing defines

00:19:14,720 --> 00:19:19,919
how and our thought was that it would be

00:19:17,760 --> 00:19:23,360
awesome to take this

00:19:19,919 --> 00:19:24,320
and combine it with this and have a

00:19:23,360 --> 00:19:26,880
single config

00:19:24,320 --> 00:19:27,440
that defines our what and how together

00:19:26,880 --> 00:19:31,200
or

00:19:27,440 --> 00:19:32,320
our application and now to tell you more

00:19:31,200 --> 00:19:32,960
about how to help make this dream a

00:19:32,320 --> 00:19:34,640
reality

00:19:32,960 --> 00:19:37,520
here's my esteemed friend and colleague

00:19:34,640 --> 00:19:37,520
nema caviani

00:19:37,679 --> 00:19:41,600
all right thank you very much rob so in

00:19:40,000 --> 00:19:44,000
the rest of this presentation

00:19:41,600 --> 00:19:45,200
um i'm going to talk about how to deploy

00:19:44,000 --> 00:19:47,919
manage delivery and

00:19:45,200 --> 00:19:49,520
kill its corresponding microservice and

00:19:47,919 --> 00:19:50,720
then how to enable kubernetes support

00:19:49,520 --> 00:19:52,799
for it

00:19:50,720 --> 00:19:54,960
as louise mentioned you can create

00:19:52,799 --> 00:19:56,000
resolvers and resource handler plugins

00:19:54,960 --> 00:19:57,840
for kill

00:19:56,000 --> 00:19:59,120
and they allow you to implement your

00:19:57,840 --> 00:20:01,120
declarative resources

00:19:59,120 --> 00:20:02,400
and enforce your opinions when handling

00:20:01,120 --> 00:20:05,360
those resources

00:20:02,400 --> 00:20:07,360
so for kubernetes we developed a plugin

00:20:05,360 --> 00:20:08,000
that introduces kubernetes resources to

00:20:07,360 --> 00:20:09,840
kiel

00:20:08,000 --> 00:20:11,440
and enables you to then combine the

00:20:09,840 --> 00:20:13,200
declarative definition of

00:20:11,440 --> 00:20:15,120
both kubernetes resources and

00:20:13,200 --> 00:20:17,280
infrastructure resources

00:20:15,120 --> 00:20:18,720
all in one place and as part of your

00:20:17,280 --> 00:20:21,840
delivery config manifest

00:20:18,720 --> 00:20:24,880
and this is exactly what rob explained

00:20:21,840 --> 00:20:26,720
so the plugin as you see on the slide

00:20:24,880 --> 00:20:28,559
is accessible from the github link

00:20:26,720 --> 00:20:30,960
referenced on the slide and

00:20:28,559 --> 00:20:32,559
you can go play with it it's open source

00:20:30,960 --> 00:20:35,200
and you can also

00:20:32,559 --> 00:20:36,640
if you're adventurous enough you can you

00:20:35,200 --> 00:20:38,320
can go deploy

00:20:36,640 --> 00:20:40,159
um but before getting into the details

00:20:38,320 --> 00:20:41,600
of how it works let's start by looking

00:20:40,159 --> 00:20:43,280
into how you can

00:20:41,600 --> 00:20:45,760
have kiel deploy to your kubernetes

00:20:43,280 --> 00:20:49,120
cluster and configure it to work with

00:20:45,760 --> 00:20:51,760
other spinnaker services so

00:20:49,120 --> 00:20:52,720
in order to deploy keel you need to use

00:20:51,760 --> 00:20:54,880
cleat

00:20:52,720 --> 00:20:56,720
previously you had to use halyard to

00:20:54,880 --> 00:20:57,840
deploy spinach and i suppose most of you

00:20:56,720 --> 00:21:00,720
are familiar with

00:20:57,840 --> 00:21:02,640
how halyard works and is being

00:21:00,720 --> 00:21:04,320
developed as a replacement to halyard

00:21:02,640 --> 00:21:05,840
to create and manage spinnaker

00:21:04,320 --> 00:21:07,840
configuration files

00:21:05,840 --> 00:21:08,880
um it works in combination with

00:21:07,840 --> 00:21:10,799
customize which

00:21:08,880 --> 00:21:12,880
is for those of you who are not familiar

00:21:10,799 --> 00:21:13,679
with it a tool to customize kubernetes

00:21:12,880 --> 00:21:16,559
resources

00:21:13,679 --> 00:21:18,320
pretty obvious from the name right so

00:21:16,559 --> 00:21:20,240
the interesting point about cleat is

00:21:18,320 --> 00:21:22,080
that it uses the same configuration file

00:21:20,240 --> 00:21:23,760
that was previously used by halyard to

00:21:22,080 --> 00:21:26,480
deploy spinnaker

00:21:23,760 --> 00:21:28,000
 takes the hal config.yaml file as

00:21:26,480 --> 00:21:29,840
the input and then generates

00:21:28,000 --> 00:21:31,840
configuration files to be used with the

00:21:29,840 --> 00:21:33,360
spinnaker microservices

00:21:31,840 --> 00:21:35,520
so for us to be able to use click to

00:21:33,360 --> 00:21:38,000
deploy keel we first need to

00:21:35,520 --> 00:21:39,600
modify how config and add configurations

00:21:38,000 --> 00:21:41,520
for sql data store

00:21:39,600 --> 00:21:43,600
as well as configurations related to

00:21:41,520 --> 00:21:45,520
enabling manage delivery

00:21:43,600 --> 00:21:47,520
as you can see here it's part of the

00:21:45,520 --> 00:21:49,679
configuration you can also define

00:21:47,520 --> 00:21:51,280
what resource types and plugins you want

00:21:49,679 --> 00:21:52,080
to enable in your manage delivery

00:21:51,280 --> 00:21:54,480
deployment

00:21:52,080 --> 00:21:55,280
for example in this example that i'm

00:21:54,480 --> 00:21:59,679
showing here

00:21:55,280 --> 00:22:02,000
we have ec2 and kits resources enabled

00:21:59,679 --> 00:22:03,520
so once done then you run click generate

00:22:02,000 --> 00:22:05,280
on your health config file and give it a

00:22:03,520 --> 00:22:07,760
destination directory for you to

00:22:05,280 --> 00:22:10,159
copy the generated configuration files

00:22:07,760 --> 00:22:10,159
into

00:22:10,240 --> 00:22:13,760
okay so next step is to modify your

00:22:12,000 --> 00:22:15,520
kill.yaml configuration file that was

00:22:13,760 --> 00:22:17,840
generated in the previous step

00:22:15,520 --> 00:22:19,280
and add the reference to your kubernetes

00:22:17,840 --> 00:22:21,840
and keel plugin

00:22:19,280 --> 00:22:24,720
so that spinnaker can install the plugin

00:22:21,840 --> 00:22:26,480
as part of deploying keel

00:22:24,720 --> 00:22:28,480
with those configurations in place and

00:22:26,480 --> 00:22:30,000
you can also configure custom overlays

00:22:28,480 --> 00:22:32,559
for your spinnaker deployment

00:22:30,000 --> 00:22:34,400
and eventually run customize build in

00:22:32,559 --> 00:22:36,960
your configuration directory

00:22:34,400 --> 00:22:38,240
in order to generate the kubernetes

00:22:36,960 --> 00:22:40,320
resources

00:22:38,240 --> 00:22:41,360
you can then pass these resources to

00:22:40,320 --> 00:22:42,640
your coupe ctl

00:22:41,360 --> 00:22:46,559
and you will have your spinach

00:22:42,640 --> 00:22:47,919
microservices deployed to kubernetes

00:22:46,559 --> 00:22:49,679
all right so once you have your spinach

00:22:47,919 --> 00:22:51,919
deployed with managed delivery you can

00:22:49,679 --> 00:22:53,440
start using it for declarative delivery

00:22:51,919 --> 00:22:55,120
so the idea here is that you define

00:22:53,440 --> 00:22:56,880
manage delivery configurations as well

00:22:55,120 --> 00:22:59,919
as your kubernetes resources

00:22:56,880 --> 00:23:02,159
um in a delivery config manifest

00:22:59,919 --> 00:23:03,200
and push it to your git account and then

00:23:02,159 --> 00:23:05,520
configure

00:23:03,200 --> 00:23:06,559
git to notify spinnaker whenever you

00:23:05,520 --> 00:23:09,840
make changes

00:23:06,559 --> 00:23:11,919
to this configuration manifest

00:23:09,840 --> 00:23:13,760
once the notification comes to spinnaker

00:23:11,919 --> 00:23:15,520
igor the spinnaker microservice

00:23:13,760 --> 00:23:16,080
responsible for pulling artifacts from

00:23:15,520 --> 00:23:17,919
git

00:23:16,080 --> 00:23:20,559
pulls your git repo for the latest

00:23:17,919 --> 00:23:22,480
config passes the information to kill

00:23:20,559 --> 00:23:25,280
and then kill stores the new version of

00:23:22,480 --> 00:23:27,440
the delivery config in its data store

00:23:25,280 --> 00:23:29,120
and the delivery config stored in kills

00:23:27,440 --> 00:23:30,080
data store at that point it becomes the

00:23:29,120 --> 00:23:32,159
source of truth

00:23:30,080 --> 00:23:33,360
against your kubernetes cluster and keel

00:23:32,159 --> 00:23:36,400
tries to

00:23:33,360 --> 00:23:38,640
bring the set of your cluster to match

00:23:36,400 --> 00:23:42,400
what is stored in its data store

00:23:38,640 --> 00:23:44,480
so this is done by um periodically

00:23:42,400 --> 00:23:46,320
running these sync cycles where it

00:23:44,480 --> 00:23:47,440
actually takes the delivery config from

00:23:46,320 --> 00:23:49,360
its data store

00:23:47,440 --> 00:23:50,720
and contrasts it against resources in

00:23:49,360 --> 00:23:53,440
your kubernetes cluster

00:23:50,720 --> 00:23:55,600
and then checks if there is a difference

00:23:53,440 --> 00:23:57,520
if there is a difference in fact then

00:23:55,600 --> 00:23:59,039
this results in

00:23:57,520 --> 00:24:00,880
kill creating a task against the

00:23:59,039 --> 00:24:02,880
kubernetes cloud provider

00:24:00,880 --> 00:24:07,200
that will update the kubernetes cluster

00:24:02,880 --> 00:24:07,200
with the new version of the resource

00:24:07,360 --> 00:24:12,159
okay with that so let's see a demo of

00:24:10,080 --> 00:24:15,520
how things work

00:24:12,159 --> 00:24:18,240
okay so for the demo we're going to

00:24:15,520 --> 00:24:19,120
keep it short and sweet let's start by

00:24:18,240 --> 00:24:22,400
creating a

00:24:19,120 --> 00:24:24,799
pipeline call it md for manage delivery

00:24:22,400 --> 00:24:27,279
this is a spinnaker deployment that has

00:24:24,799 --> 00:24:29,919
managed to delivery enabled for it first

00:24:27,279 --> 00:24:32,000
thing we do for the pipeline we go

00:24:29,919 --> 00:24:34,080
to set up an automated trigger for it so

00:24:32,000 --> 00:24:36,400
that when changes from github come in it

00:24:34,080 --> 00:24:38,960
get picks up by spinnaker

00:24:36,400 --> 00:24:40,400
the type of the trigger is get the repo

00:24:38,960 --> 00:24:42,960
type is github

00:24:40,400 --> 00:24:44,799
and then for the user i just choose my

00:24:42,960 --> 00:24:46,720
username and the name of the project is

00:24:44,799 --> 00:24:48,640
going to be spin md test

00:24:46,720 --> 00:24:51,600
all right we have everything here we set

00:24:48,640 --> 00:24:53,200
it up next we move on to adding a new

00:24:51,600 --> 00:24:55,360
stage the new stage is going to be

00:24:53,200 --> 00:24:57,279
import delivery config and you get this

00:24:55,360 --> 00:24:58,400
stage if you have manage delivery

00:24:57,279 --> 00:25:00,640
enabled for your

00:24:58,400 --> 00:25:02,080
spinnaker deployment now under

00:25:00,640 --> 00:25:05,279
manifest-based path

00:25:02,080 --> 00:25:07,120
you we define summit.yaml

00:25:05,279 --> 00:25:08,559
and this is to refer to where we are

00:25:07,120 --> 00:25:10,080
going to store the manifest

00:25:08,559 --> 00:25:12,000
configurations

00:25:10,080 --> 00:25:15,520
so with that we have everything enabled

00:25:12,000 --> 00:25:17,600
for our manage delivery setup then we go

00:25:15,520 --> 00:25:18,559
to spin md test which is the repo we

00:25:17,600 --> 00:25:21,039
configured

00:25:18,559 --> 00:25:22,440
in our pipeline add a new file we call

00:25:21,039 --> 00:25:26,159
the new file

00:25:22,440 --> 00:25:28,480
summit.yaml and then for the

00:25:26,159 --> 00:25:31,200
manifest we have a very basic manifest

00:25:28,480 --> 00:25:35,279
that we copy over

00:25:31,200 --> 00:25:38,080
as you can see the manifest has

00:25:35,279 --> 00:25:40,240
the name of the manifest itself it has

00:25:38,080 --> 00:25:42,720
the application name nema ksbn which is

00:25:40,240 --> 00:25:45,440
similar to what we have for spinnaker

00:25:42,720 --> 00:25:46,880
then the environment is a test

00:25:45,440 --> 00:25:49,440
environment as you can see

00:25:46,880 --> 00:25:51,039
and it deploys to my kubernetes account

00:25:49,440 --> 00:25:53,919
that i've configured already

00:25:51,039 --> 00:25:56,640
so on the resources then we have two

00:25:53,919 --> 00:25:59,520
resources one is a community service

00:25:56,640 --> 00:26:00,960
and it actually deploys to my nema

00:25:59,520 --> 00:26:03,919
caspian application

00:26:00,960 --> 00:26:05,679
it refers to the hello world application

00:26:03,919 --> 00:26:06,640
which is a deployment a kubernetes

00:26:05,679 --> 00:26:09,440
deployment

00:26:06,640 --> 00:26:10,159
that deploys one instance of my

00:26:09,440 --> 00:26:14,159
container

00:26:10,159 --> 00:26:16,080
here hello kubernetes application so

00:26:14,159 --> 00:26:18,000
we have everything defined now at this

00:26:16,080 --> 00:26:20,000
point we can actually

00:26:18,000 --> 00:26:21,279
go and you see the name of the service

00:26:20,000 --> 00:26:22,799
and the name of the deployment are

00:26:21,279 --> 00:26:25,760
actually been summit

00:26:22,799 --> 00:26:27,200
so here i've also configured keel you

00:26:25,760 --> 00:26:29,760
see the logs on the right

00:26:27,200 --> 00:26:32,559
and i'm also watching for the pod

00:26:29,760 --> 00:26:34,640
creations in my kubernetes cluster

00:26:32,559 --> 00:26:36,080
so we go back and then at this point i

00:26:34,640 --> 00:26:39,679
think we have everything we can

00:26:36,080 --> 00:26:42,400
save the man the manifest

00:26:39,679 --> 00:26:43,919
once we save it you see that um actions

00:26:42,400 --> 00:26:47,200
coming in requests coming in

00:26:43,919 --> 00:26:50,400
and manage delivery is

00:26:47,200 --> 00:26:52,320
executed logs for keylog rolling

00:26:50,400 --> 00:26:54,559
and you see that a new deployment has

00:26:52,320 --> 00:26:56,880
got picked up so if you look at the

00:26:54,559 --> 00:26:58,720
left hand side you see that we actually

00:26:56,880 --> 00:26:59,600
have deployed one instance of this pin

00:26:58,720 --> 00:27:02,240
summit

00:26:59,600 --> 00:27:02,720
application that we configured earlier

00:27:02,240 --> 00:27:04,080
now

00:27:02,720 --> 00:27:06,159
in order to show that you can update

00:27:04,080 --> 00:27:10,080
your resources we can actually go back

00:27:06,159 --> 00:27:12,240
and modify the submit.yaml file and

00:27:10,080 --> 00:27:14,159
for example bump the number of replicas

00:27:12,240 --> 00:27:16,559
to 2 here

00:27:14,159 --> 00:27:17,440
once we commit changes you see that new

00:27:16,559 --> 00:27:19,520
changes come in

00:27:17,440 --> 00:27:21,279
and if i go to my manage delivery

00:27:19,520 --> 00:27:24,559
pipeline you see that there is an action

00:27:21,279 --> 00:27:26,880
logs are rolling and on the

00:27:24,559 --> 00:27:27,600
left if i refresh the screen you see

00:27:26,880 --> 00:27:29,520
that

00:27:27,600 --> 00:27:32,000
there is a new instance of the

00:27:29,520 --> 00:27:33,039
application that has got created so if i

00:27:32,000 --> 00:27:34,640
query again

00:27:33,039 --> 00:27:37,120
now there are two instances of spin

00:27:34,640 --> 00:27:39,200
summit the

00:27:37,120 --> 00:27:40,880
deployment that are running so if i look

00:27:39,200 --> 00:27:43,440
at the services

00:27:40,880 --> 00:27:45,279
instead of the pods then we see that

00:27:43,440 --> 00:27:46,480
there is the spin summit service that's

00:27:45,279 --> 00:27:49,120
also created

00:27:46,480 --> 00:27:50,399
and at this point if i click on the link

00:27:49,120 --> 00:27:53,200
that you see here

00:27:50,399 --> 00:27:55,200
it'll take me to the deploy instance of

00:27:53,200 --> 00:27:57,679
the application so if i actually

00:27:55,200 --> 00:27:59,360
look at it then i'll see that my hello

00:27:57,679 --> 00:27:59,679
world application is deployed and it's

00:27:59,360 --> 00:28:03,200
all

00:27:59,679 --> 00:28:06,000
managed through the keel deployment

00:28:03,200 --> 00:28:07,600
all right that was a very quick demo and

00:28:06,000 --> 00:28:08,159
i think we can go back to the rest of

00:28:07,600 --> 00:28:10,399
the talk

00:28:08,159 --> 00:28:11,200
so as for the future work we have some

00:28:10,399 --> 00:28:13,039
short term

00:28:11,200 --> 00:28:14,720
and some long term goals for the

00:28:13,039 --> 00:28:16,240
kubernetes skill plug

00:28:14,720 --> 00:28:17,840
we're working with the community to make

00:28:16,240 --> 00:28:20,640
q deployment

00:28:17,840 --> 00:28:22,480
um and also the enabling of managed

00:28:20,640 --> 00:28:24,799
delivery available to everyone

00:28:22,480 --> 00:28:26,559
using cleat we are very close to make

00:28:24,799 --> 00:28:28,720
that possible in fact and we're hoping

00:28:26,559 --> 00:28:30,960
that the next version of cleat

00:28:28,720 --> 00:28:33,679
is going to enable you to deploy

00:28:30,960 --> 00:28:35,520
manageability and kill as part of it

00:28:33,679 --> 00:28:36,720
we are also working on making the system

00:28:35,520 --> 00:28:38,880
more stable

00:28:36,720 --> 00:28:40,559
and the plug-in more robust to be used

00:28:38,880 --> 00:28:43,279
by the community so hopefully

00:28:40,559 --> 00:28:44,640
you can actually start using it for your

00:28:43,279 --> 00:28:47,679
spinnaker deployments

00:28:44,640 --> 00:28:49,440
against kubernetes clusters um

00:28:47,679 --> 00:28:51,039
other short-term plans that we have is

00:28:49,440 --> 00:28:53,279
that we are working on allowing support

00:28:51,039 --> 00:28:55,440
for customized and health resources

00:28:53,279 --> 00:28:56,720
as part of kids manage delivery support

00:28:55,440 --> 00:28:58,880
this basically means that

00:28:56,720 --> 00:28:59,840
rather than the vanilla kubernetes

00:28:58,880 --> 00:29:03,120
resources

00:28:59,840 --> 00:29:05,440
you will be able to also have resource

00:29:03,120 --> 00:29:06,960
customizations or help templates defined

00:29:05,440 --> 00:29:09,440
in your delivery

00:29:06,960 --> 00:29:10,080
manifest and rely on the kubernetes

00:29:09,440 --> 00:29:13,440
plugin

00:29:10,080 --> 00:29:15,200
to deploy those resources for you

00:29:13,440 --> 00:29:16,880
so for the long term goals between

00:29:15,200 --> 00:29:18,799
netflix and aws we are working on

00:29:16,880 --> 00:29:20,720
defining higher level app selections for

00:29:18,799 --> 00:29:23,600
your application and specification

00:29:20,720 --> 00:29:25,039
so that rather than defining um or

00:29:23,600 --> 00:29:27,039
having to define

00:29:25,039 --> 00:29:29,120
infrastructure resources and kubernetes

00:29:27,039 --> 00:29:31,360
resources you actually have these

00:29:29,120 --> 00:29:33,279
higher level constructs to define the

00:29:31,360 --> 00:29:35,279
specification of your applications

00:29:33,279 --> 00:29:38,080
and then keel will take those

00:29:35,279 --> 00:29:40,799
abstractions and converts them to

00:29:38,080 --> 00:29:42,640
the lower level um constructs for

00:29:40,799 --> 00:29:43,360
kubernetes or for the infrastructure in

00:29:42,640 --> 00:29:45,200
order to

00:29:43,360 --> 00:29:47,200
get your application up and running and

00:29:45,200 --> 00:29:49,200
hopefully by that we're planning to

00:29:47,200 --> 00:29:50,720
simplify the process of deploying

00:29:49,200 --> 00:29:53,600
applications even further

00:29:50,720 --> 00:29:54,480
when you use spinnaker all right with

00:29:53,600 --> 00:29:57,279
that

00:29:54,480 --> 00:30:06,640
i'd like to conclude and open it to

00:29:57,279 --> 00:30:06,640

YouTube URL: https://www.youtube.com/watch?v=BsgiJnRcH-s


