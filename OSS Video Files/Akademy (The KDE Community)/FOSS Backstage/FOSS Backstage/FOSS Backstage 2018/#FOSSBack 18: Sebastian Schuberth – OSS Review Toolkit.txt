Title: #FOSSBack 18: Sebastian Schuberth – OSS Review Toolkit
Publication date: 2018-06-27
Playlist: FOSS Backstage 2018
Description: 
	OSS Review Toolkit: Automating Open Source Compliance within CI/CD

In an ideal world, FOSS reviews are automated and done early and often so that FOSS issues -  technical, licenses or security can be caught and resolved expeditiously. The FOSS community currently does not have comprehensive open-sourced tooling for highly automated FOSS reviews for their projects, lacking which, FOSS project maintainers are unable to provide clearly defined metadata for their software and its dependencies. Lack of clarity in FOSS metadata makes compliance difficult and adversely affects project adoption and growth.

Projects built using package managers automatically download dependencies. Add to it, deployment using CI/CD and they now also expect quick turnarounds with FOSS reviews and compliance.

In this talk, I present a new tool called OSS Review Toolkit (ORT), that enables highly automated FOSS reviews within CI/CD. It does this by combining a new dependency analysis tool with existing FOSS dependency and scanning tools and with the new ClearlyDefined initiative, a platform to discover, curate and share FOSS component metadata.

Read more:
https://18.foss-backstage.de/session/oss-review-toolkit-automating-open-source-compliance-within-cicd

About Sebastian Schuberth:
https://18.foss-backstage.de/member/sebastian-schuberth

Website: https://www.foss-backstage.de/
Twitter: https://twitter.com/Fossbckstg
LinkedIn: https://www.linkedin.com/groups/8653059/
Captions: 
	                              yeah hello everybody thanks for                               attending this session about open source                               review toolkit well which is a fairly                               new project so which might explain that                               you haven't heard about it yet                               before we start maybe some fun facts                               about me so I'm working at a company                               called here technologies I'm located                               here in Berlin which is one of our                                biggest engineering sites I'm leading                                all engineering related open source                                efforts that we're doing in the company                                I'm still an active open source                                contributor myself to a variety of                                projects both privately and entering my                                work time and I have some background in                                mobile development and computer graphics                                my current favorite technologies if                                someone cares include quadlin as a                                language gradeless a build system and my                                all-time favorite is kid so I'm a total                                geek evangelist two of my hobbies                                include coding coding coding also in my                                spare time and off-road RC car racing                                and if you then think of cars like this                                then I have to disappoint you know my                                car actually looks like this so I'm                                really an engineer still at heart which                                also explains why this talk is going to                                be rather technical so I'm not going to                                talk so much about our internal                                processes and and governance in that                                sense but more about what the tool                                actually does why it does it this way                                and another way what our are the                                problems we are trying to solve what are                                our internal requirements towards the                                tool and finally of course the tool                                itself an overview over the different                                tools in the toolkit and also a bit                                about CI integration and the roadmap so                                what is the problem you're trying to                                solve well our company is not really                                affected with                                open-source governance in the sense that                                we don't sell consulting or products in                                that area so why do we even bother                                simply to scratch our own itch so we                                have the need to review our own products                                for license compliance and that includes                                identifying the transitive dependencies                                identify possible license                                incompatibilities between dependencies                                in the tree ensure that we follow                                license obligations like creating notice                                files in the end and all of this is of                                course not necessarily limited to to                                false dependencies right so the way we                                implement things is generic in the sense                                that as long as your metadata is fine it                                of course works also with commercial                                dependencies that you might have so if                                you manage to implement all of this                                properly you you get a bunch of side                                benefits which turn out to be yeah                                rather valuable first of all maybe some                                of you know for example the fort works                                technology radar of recommended                                technologies like what should you adopt                                what should you maybe not look into                                anymore and we basically by scanning all                                of the dependencies that we use in the                                company get a good overview of the tools                                languages and frameworks we're using                                also we're able to identify in quotes                                problematic components maybe there is                                real current packages that have broken                                bad metadata and we find out hey all of                                these broken bad packages come from the                                same maintainer maybe it's a good idea                                then to not use anything from that                                maintainer anymore also using all this                                data you yeah you're fairly easily able                                to report the current security                                vulnerabilities and to some extent                                gathering this data and analyzing your                                own source code for dependencies also                                enforces best engineering practices                                especially with respect to the build                                system and main                                dependencies oh come to that a bit later                                so what are our own requirements we have                                a bunch of maybe rather unique                                requirements                                one of our key requirements is we must                                not make any modifications to the                                projects or to the source code of the                                project we analyze we cannot go to our                                product teams and say hey look we need                                 to do this open source review or license                                 review on your product but before we can                                 do that you need to apply this plug-in                                 to your build system that doesn't work                                 so the only exception then is if the                                 build of the product depends on some                                 magic configuration settings like some                                 secret global configuration that you                                 have to apply in order to even build it                                 or query the build system for                                 dependencies that's something that we                                 consider a violation against best                                 engineering practices and this is                                 something we need to ask the team to fix                                 we need support for common package                                 managers so like maven for Java Gradle                                 SBT for Scala NPM and so on and we need                                 to be able to capture the metadata of                                 course but like the killer license it                                 said etcetera but just declaring or                                 sorry just relying on the captured                                 metadata and declared licenses is not                                 enough so aesthetically parsing the                                 package manager definition files like                                 package Jason and so on it's not enough                                 because in many cases you have things                                 like version ranges defined in there                                 unless you have a lock file so depending                                 on the time you actually build or                                 install the product you get different                                 dependencies maybe only in a minor                                 version but we have seen dependencies                                 that in turn change their transitive                                 dependencies in in a big way between                                 minor versions so not everybody adheres                                 to semantic versioning so what we need                                 is the real version that gets used by                                 the product including resolution of the                                 version version conflict resolution like                                 the build system would do it so really                                 the                                 the real thing we also need to know                                 where the source code is located in                                 order to scan the source code because we                                 must not rely on the declared license                                 maybe a project says hey I'm Apache but                                 then if you look at the dependencies you                                 see hey it's actually including a GPL                                 dependency doesn't well work together we                                 need to be able to fix a broken metadata                                 many open source projects don't really                                 care much about their metadata they                                 don't declare a license at all maybe                                 they have typos in the SPD X or a                                 license identifier something like this                                 they don't take their releases and get                                 we need a way to fix this on our side at                                 least and of course we need to support                                 all kinds of mixed projects multiple                                 package managers in the same tree and we                                 want some sort of support for what we                                 call unmanaged projects like for                                 languages that don't have a dedicated                                 package manager like plain C C++                                 projects embedded Linux stuff and so on                                 when it comes to the interchange formats                                 we want to rely on public standards like                                 SPD X also see me or upcoming standards                                 like about code data because not                                 everything that we want to document is                                 can be captured in SPD X we want to be                                 able to use our own scanner so we're not                                 intending to reinvent the wheel here the                                 toolkit is more the glue between                                 existing tools as far as we think they                                 can be used and for example you should                                 be free to use as a scanner for solid GE                                 or a scan code or Amazon recently                                 released a scanner was called Escalona                                 so we are just the wrapper around the                                 scanner and unifying the input and                                 output in that case that also avoids                                 vendor lock-in and then in order to                                 efficiently use the tool in CI we need                                 fast incremental scans by reusing                                 existing results and being able to                                 do Delta scans finally when it comes to                                 looking at the results we want something                                 that is taking the work off of our legal                                 department in the sense that we have a                                 rules engine that's how we call it to                                 apply license compliance rules there                                 those so our legal department should be                                 able to give us at least for the                                 majority of cases some rules computable                                 rules where we can say ok if this and                                 that or that block release or whatever                                 block the change to not go in taking                                 into account of course things like the                                 Scopes of a dependency so in maven speak                                 you might have a test dependency and                                 usually test code doesn't get shipped so                                 it's not delivered it's not distributed                                 so you probably don't care about it at                                 all also we would like to have multiple                                 result formats so we need some sort of                                 graphical representation of the                                 dependency tree to get a better overview                                 legal people of X also give them EXO and                                 also things like generating the notice                                 files is something that is covered by                                 the reporter tool that I'll talk about                                 so last but not least all of this should                                 be reasonably easy to setup in CI and                                 taking all of these requirements                                 together after some long running                                 evaluation we came to the conclusion                                 there is nothing on the market that we                                 could buy or use that fulfills all of                                 these needs so we came up with the open                                 source review toolkit or art for short                                 how we call it and like I said it's just                                 a suite of tools command-line tools in                                 this case that are supposed to be                                 plucked together in the way of working                                 you need them of course the tool itself                                 is open source it's on github already                                 it's Apache                                               it's written in kopplin who knows : by                                 the way as a language okay so it's a                                 fairly new language from a company                                 called JetBrains who are most famous for                                 their I DES I guess it's targeting the                                 JVM so it's fully compatible with the                                 Java world but you could also compile a                                 quarter into native code to some extent                                 if you wanted to from a software design                                 perspective the toolkit is composed of                                 libraries Java libraries and each of the                                 libraries has a small main entry point                                 so you could use it as a command line                                 tool and the tool is in fact in                                 production used by us for or since no                                 for six months yeah and then that's                                 correct                                 so exactly the version that you see on                                 github the master branch is in use by us                                 in production in-house we don't have an                                 internal fork we don't hide anything                                 that is exactly what we're using the                                 first piece in the toolkit is the so                                 called analyzer if you were following                                 one of the open chain talks or workshops                                 then this is the tool you would use in                                 the identification step that's how open                                 chain calls it as input the analyze it                                 just takes a local directory with source                                 code and optional curations there is                                 something I will talk more about in the                                 end and what it does is it gathers all                                 facts all data or metadata about                                 software dependencies and currently we                                 have eleven supported package managers                                 and the output is at your choice a                                 yellow JSON file with the dependency                                 tree so that's probably not very                                 readable from far behind but you will                                 get the slides anyway so this is in well                                 in all of you llamo is a good compromise                                 between being human and machine readable                                 and here you simply get stuff like what                                 is the name of the dependency what is                                 the version where                                 it come from how do versions map to                                 source code revisions and and this kind                                 of stuff                                 next in the toolkit is the downloader                                 the downloader is a tool you would                                 fairly yeah or probably never use on its                                 own it's implicitly used by the scanner                                 but I will anyway talk about it so the                                 input for the downloader is the output                                 of the analyzer that you just saw and                                 it's really a pretty much dump tool                                 right it's the only purpose is like the                                 name says it downloads it fetches the                                 source code but it wraps whatever                                 underlying VCS or other protocol you're                                 using so we're supporting good mercurial                                 subversion and so on and the output is                                 simply a local directory with source                                 code of course as this is more or less                                 just a generic download tool you could                                 also use it to download the source code                                 to be analyzed before running the                                 analyzer then there is the scanner this                                 is what you would use in the open chain                                 audit step the scanner like I said is                                 just a wrapper around whatever license /                                 copyright scanner you have configured it                                 to use so as input it can take the                                 analyzer file directly then it does the                                 download internally and it runs your                                 configured scanner so we have currently                                 four supported scanners but our scanner                                 of choice is the next schoo sorry the                                 scan code scanner from a company called                                 next B which is also open source at                                 github and written in Python output                                 again at your choice your choice JSON                                 file with the scan results and the scan                                 results and that's again probably not                                 very readable from far behind include                                 for example the name also of the scanner                                 the version and the way you have                                 configured the scanner so everything                                 that could take an influence on the scan                                 results is captured as part of this                                 result file and you can also have                                 results from multiple scanners in the                                 same result file                                 so you can easily compare different                                 results from different scanners for the                                 same piece of software the last tool in                                 the toolkit as it currently is is the                                 reporter tool the reporter tool takes as                                 input the scanner file and it generates                                 a custom report of visualization out of                                 it                                 so like Excel for legal review like                                 static HTML page for getting a quick                                 overview or the notice files that you                                 would need in case of redress rebooting                                 your software now coming to the                                 curations the curations are an optional                                 input to the analyzer and they augment                                 the packages original metadata so this                                 is how we fix broken metadata in                                 upstream open source projects this is                                 also again a simple mo file key value                                 pairs fixing up metadata entries and                                 this is something we are where we are                                 collaborating with the clearly-defined                                 initiative which is mainly run by                                 Microsoft and who aims to contribute                                 back fixes of for metadata to open                                 source projects so we are basically                                 serving as an input to clearly-defined                                 that's the aim that's the idea                                 continuous integration is more or less a                                 trivial topic in this case because the                                 toolkit is compromised of command line                                 tools and it's it's fairly easy to set                                 this up in Jenkins and in our case we're                                 using a Jenkins multi job and each job                                 runs a different command line tool from                                 the toolkit and basically the the llamó                                 input output files are just passed                                 between the jobs you can either trigger                                 the job based on code changes and the                                 product you want to analyze or of course                                 just run it on demand like you could                                 also do things like                                 before actually starting to use an                                 open-source library you run the scan on                                 demand on the library and give feedback                                 to the team and say yes this should be                                 fine to use there will be no bad                                 surprises in the end of your whatever                                 Sprint or shortly before the release                                 with us saying oh sorry you should have                                 asked us before this contains whatever                                 GPL you cannot use it and then the way                                 we use it is also by giving currently                                 some non-blocking feedback in the code                                 review tool we are using so you get some                                 label past not past warning problem                                 something like this so all of this that                                 you've seen so far is already there and                                 working and in production but there are                                 a bunch of more tools we are working on                                 to complete the toolkit the evaluator                                 will be the tool that is using this                                 rules engine to offload our legal                                 department and with with the easy cases                                 and give some early feedback before                                 legal people even look at the scan                                 results so this is our next big topic                                 and we hope that this will be a really                                 cool feature and legal will thank us for                                 not wasting their time any more the                                 advisor is our idea of the tool that                                 takes the analyzers output and reports                                 security vulnerabilities and then                                 finally there will be something like                                 what we currently call the document or                                 could also be part of the the reporter                                 maybe that is creating or documenting                                 the outcome of the whole review process                                 in sue including legal conclusions and                                 creating BOMs bill of materials in as                                 PDX format with some custom annotations                                 maybe because currently it's not                                 possible to capture everything in SPX                                 that we would like to include but we are                                 also working with the SPD ex tech                                 community to                                 maybe extend the specification or future                                 specifications to include some more                                 metadata that's about it about the tool                                 everything that I wanted to say in case                                 you want to reach out here is my email                                 address the the slides will be shared                                 later on our organization at github is                                 called here Maps so there's where you                                 can take a look at those as ruby toolkit                                 also links to clearly defined initiative                                 and the scan code scanner are included                                 ok thanks for listening any questions                                 [Applause]                                 thank you                                 so we've seen previously open chain and                                 water master there seems to be certain                                 overlap do you plan to merge these                                 projects to switch over or you just                                 invested only so much that you plan to                                 stay on your own solution now the idea                                 is well first of all yes you are right                                 there is some overlap especially between                                 quartermaster and the art toolkit the                                 funny thing is these two tools developed                                 roughly at the same time and we were                                 approaching almost the same problems                                 from two different angles so quarter                                 master is a tiny bit more tailored                                 towards analyzing C C++ projects and                                 projects that are built on Linux with                                 with make or C make and that kind of                                 stuff also quartermaster watches the                                 build process and and tries to find out                                 what goes into your binary so it rather                                 looks at the binary and to to find out                                 what exactly is being distributed                                 whereas our approach looks at the source                                 code mainly to get a complete picture                                 and then in the end we filter out                                 data findings based on scope or also                                 package and file levels to get to the                                 point where only relevant data is shown                                 that said we are in touch with the                                 quartermaster people and endo code and                                 we could for example envision quota                                 master being integrated into the or tool                                 to handle all these unmanaged projects                                 so it would be basically just in our                                 speak or in our view package manager if                                 you want to say so so we for everything                                 that we currently treat as unmanaged we                                 would use quota master                                 so that is the only way we could work                                 together so you actually don't plan to                                 switch over well it's well quarter                                 master doesn't solve the problems that                                 we have whereas our tool currently does                                 fairly well it has a few caps and we                                 could fill these gaps on our side maybe                                 by using quartermaster but we will for                                 sure not switch to using quartermaster                                 that's not feasible for us currently hi                                 if I understand correctly you're                                 starting from the packages from the                                 binaries in fact so you you exploring                                 what                                 Jemma's created or pip or whatever it's                                 alright yeah so what we call package                                 depends a bit on the language right so                                 in case of NPM it would be well yeah a                                 tarball containing the source code but                                 we are still capturing the real source                                 code location in terms of get URL and so                                 ok so my real question is how do you                                 assure yourself that what that package                                 is telling you is the truth well when it                                 comes to license data for example just                                 in general we did some work trying to                                 figure this                                 Providence question out a few years ago                                 and at that point we engage with say the                                 rubygems community and said can we help                                 ensure that the URL that you're saying                                 is in the package is really where it                                 came from                                 yeah and the members of the community                                 said Island we don't care about that                                 we're sure it's true yeah a good point                                 so let's take the example of our NPM                                 again what we do is only if we cannot                                 find the source code in a version                                 control system we fall back to scanning                                 the source code as it comes with a                                 package so basically we we ignore the                                 package content we we take the package                                 metadata and we verify it by going                                 actually to the source code URL                                 mentioned as part of the package                                 metadata and and then checking out the                                 source code and then scanning the source                                 code right                                 oh okay yeah yeah so we do some cross                                 checks too to avoid that so for example                                 again NPM taking as an example not in                                 the package.json file but in the                                 registry in the NPM registry there is                                 for some but not all packages to be fair                                 something called git head we do trust                                 the NPM registry yes                                 so well yeah NPM in that cases may be a                                 really bad example because I agree the                                 NPM registry and the way packages are                                 published there is completely broken                                 because you can have things like the                                 sha-                                                                commits because the developer developer                                 never pushed the commits to anywhere                                 right so we have cases like this but at                                 least we detect them because well if we                                 clone the repository and cannot check                                 out the commitment and we clearly know                                 something went wrong so and this is also                                 the case where then human labor is asked                                 to create curations and and creating                                 these creations is really a forensic                                 effort right so sometimes it's really                                 really hard to find out where does this                                 source code really come from and in some                                 cases we simply cannot tell sometimes it                                 just disappeared so where possible we do                                 some same cross checks when we run into                                 problems then we detect them in most                                 cases but sometimes there really is no                                 fix to the problem any more questions                                 you're lighting their licenses a second                                 time so if it just says I'm an MIT are                                 you comparing it with the original MIT                                 or Apache or if the developer made maybe                                 some changes                                 there's something inside so in that case                                 we trust the scanner that we are using                                 we are trusting scan code from next P to                                 correctly identify the license text and                                 match it to MIT for example so scan code                                 is really basically comparing the                                 paragraphs of the of the little oral                                 license text to MIT of course taking                                 into account some modifications and so                                 on so it's way more complicated than                                 just wrapping through files but yes so                                 in that case we trust the scanner but                                 this is why you can swap the scanner for                                 anything that you trust maybe more than                                 then we would do or the other way around                                 [Laughter]                                 so does that answer your question                                 okay does thanks okay                                 okay okay thank you                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=doGGU-ZPyQ0


