Title: #FOSSBack 18: Michael Kromer â€“ Community Guide to Contributing to Mature Software Products
Publication date: 2018-06-22
Playlist: FOSS Backstage 2018
Description: 
	Tim works for a small company. When he comes home from work in the evening he likes to code for an open source project. This project is not just any project, but part of a product used by thousands of users in professional environments like public sector companies.

Can you imagine the commit made by Tim from his family home ending up there? Yes of course! But for it to happen, some things do need to be done. Before being included in final releases and rolled out to customers, Tim's changes need to go through defined QA procedures.

In this talk, Michael Kromer from Kopano shows how communities and products work together and how Tim's commit makes it into the final release of a product: Kopano, used by thousands of users in large organizations as a replacement of Microsoft Exchange or Office365

This talk is presented by Kopano.

Website: https://www.foss-backstage.de/
Twitter: https://twitter.com/Fossbckstg
LinkedIn: https://www.linkedin.com/groups/8653059/
Captions: 
	                              yeah I'm Mike let's just start off I am                               a computer geek as it gets                               did a lot of coding in my past now I'm                               officially the vice president for                               technology and architecture with Capano                               I'll get back into that later but                               basically this talk is about throwing a                               little bit more light on the coding and                               contributing ecosystem and basically                                helping you also on understanding how                                things come together basically                                so to first start off no software                                project is like the other right there                                are so many software projects in the                                world specifically also in a free and                                open-source world not every project                                really works like the same so this is                                this is really important to know that                                there's also a vast difference between                                those various interest groups that exist                                in these ecosystems you as a person have                                slightly different motivations than                                maybe the community test work path soda                                okay so so you as a person have                                potentially different motivations                                different ideas of what you want to                                achieve of what you personally want to                                do with your code then the community in                                general has then the company may be                                backing the company or a customer which                                uses that product commercially or even                                an end customer who's really using that                                because it's a hosted service for                                example but all have one shared common                                goal and that is really to get stable                                working solid trusted software right you                                want to have your software doing the job                                that it's intended to do and you want to                                make sure that and that's one of the key                                parts of free and open-source software                                that the transparency also provides the                                trust in it there there are no backdoors                                in there that it's working we all don't                                like bugs really                                and obviously we want to have the                                service up and running so the thing is                                I'm going to take a few examples here                                and many of them I'm sure you know the                                Linux kernel is the largest and biggest                                open-source software project that exists                                in the world Iridium browser is a                                chromium fork focused on privacy Capano                                a communication and collaboration suite                                which protects your data at your premise                                on your premise and openSUSE and SUSE                                Linux Enterprise Server are basically                                two distributions with slightly                                different motivations one more the                                community side and one more the business                                side so to look at these different                                organizational structures you will see                                that the Linux kernel is is really                                demand oriented with the typical chain                                of trust in development otherwise it                                wouldn't scale and even with that it has                                certain issues with scaling but                                generally in the Linux kernel the saying                                is it's done when it's done and it's                                done when it's good so what is good                                basically everything I told before it                                must be stable it must be secure to the                                knowledge of the people involved at the                                time it's also one of the reasons why                                someone like lenez really gets angry at                                people                                if it breaks any API because it says no                                there is no need to break API yet then                                we have Iridium browser                                it's a project oriented thing basically                                the the this this is a specific project                                with the idea we want to take the good                                technology of chromium but we want to                                enable it with privacy because since we                                all know Google has the interest in your                                data it might be that you don't have the                                interest in sharing your data                                openSUSE is really an open community                                where they say hey we want to get the                                best software together and just provide                                it to about anybody who wants it and so                                les is basically yeah                                openSUSE with a real customer market                                demand people that demand support                                professional services things that a                                company traditionally needs you know                                it's it's hard to ask someone in the                                community at                                                         hey I have a problem here can you help                                me out so that's where you have                                 companies behind there where people get                                 salaries paid to to do their job                                 essentially and Capano is also it's a                                 community and a commercially backed                                 project we're actually there are many                                 projects within Capano                                 but this is this is an example of a                                 hybrid so as I outlined at the beginning                                 contributors always have the thing like                                 hey I provided you to patch why isn't                                 this showing up now I mean it's there it                                 works everything is cool just go for it                                 well the thing is is it's good that                                 things take some time because what I'm                                 about to show you is a little bit the                                 implications that even a one-liner can                                 have we were referring or I was                                 referring to major software products so                                 major must be defined right and when you                                 hit Google by the definition and saying                                 hi what is matron and it says fully                                 developed full grown so to bring that a                                 little bit on to software my personal                                 definition of major software is it's                                 it's wildly deployed really production                                 installations in at least tens of                                 thousands it runs on a variety of                                 platforms little onion big onion if it's                                 power if it's                                                       platform and also downstream like we are                                 like copÃ¡n also is it's included in                                 Debian for example Ubuntu and openSUSE                                 so in various platforms basically so                                 when you as a committer                                 want to commit code you should also and                                 this is a strong echo back in an                                 open-source community we do regularly                                 get contributions but they do not watch                                 actually it's they did it's amazing how                                 many people really send you contribution                                 centers actually like the third or                                 fourth iteration of the problem and                                 sometimes even you have identical patch                                 sets for it but they do                                 side issues which I will get back into                                 it so if you as a committer want to                                 commit to any software project in the                                 world and don't get an angry lineThe or                                 don't have people starting to ignore you                                 you should a little bit do your homework                                 and just check and github it's this                                 issue maybe already known in the Iridium                                 browser for example we had so many bugs                                 people complaining about h.                                        example well it's a pate patented codec                                 which is not integrated and there are                                 like five or six issues where we simply                                 say guys yes and this is not going to                                 happen because we're simply not going                                 with this is a this is an open-source                                 project and there's no funding for a                                 six-digit licensing of the h.                                          so that's why it's not going to happen                                 next to that is license when you commit                                 code you must agree to the terms there                                 was a talk this morning which was quite                                 nice from I don't know his name anymore                                 but he was from IBM which really brought                                 up what types of differences in specific                                 licenses you have so there are sometimes                                 code commits rules that you have to obey                                 there are sometimes licenses that you                                 have to obey sometimes contributor                                 agreements if you don't want to agree to                                 it well then let it be or in a different                                 thing a developer that you're                                 complaining about can I have this in a                                 different license it's probably not the                                 right guy to ask it's probably someone                                 else like a project leader and github or                                 whatever one of the next things is when                                 you create a pull request or service                                 request in OBS or whatever be                                 descriptive one-liners are nice and it's                                 like sometimes people have have the                                 intention of yeah it says everything but                                 the reality is be more descriptive and                                 it held really helps on the other side                                 of the aisle to understand what's going                                 on                                 adapt and follow the individual product                                 project coding style this is really a                                 very important one it's like when we                                 when you personally would write                                 something like right                                 sar so everyone has its own style right                                 and that's also encoding so based on                                 your coding capabilities you develop                                 your own style and it's unfortunate if                                 if you get rejected as a committer                                 because you're not following basic                                 guidelines that's why you always have                                 these project guidelines and there are                                 many different ones Linux kernel is                                 completely different to Python or to go                                 or to whatever so really if you want to                                 commit and that's a specific era a                                 specific space keep to it and also what                                 is the best way to get in touch so an                                 example of a project structure is                                 obviously the Linux kernel Linux kernel                                 is as I already mentioned it's                                 completely based on the trust principle                                 and so this is actually also a little                                 bit a system which most people think                                 that it's built up like a democracy but                                 it's absolutely not it's more like a                                 monarchy where the King has been voted                                 for basically and he's trusted life long                                 until he passes away or whatever let's                                 hope not not too soon but the thing is                                 it's merit-based it's a merit-based                                 system so obviously Luna's deserves most                                 credit for actually inventing this                                 project and other people like Andrew                                 Morton or Gregor Hartman they did a                                 great job in managing the next kernel in                                 managing branches stable wise I mean                                 Greg Hartmann was maintaining the stable                                 tree for ages so this is a system for                                 example which is actually quite unique                                 you won't find that too often based on                                 on this switching over to what we                                 actually do again complete it's a                                 complete collaboration stack it's very                                 modular so we have a lot of separate                                 repositories in various languages                                 ranging from C++ Python and so on you                                 should know that every commit that you                                 create is joined in a life cycle                                 so when you create a commit and that's                                 not exclusive to us that is in the most                                 major software prod                                 especially when there's a company behind                                 there that's the case so you have a                                 commit from the commit on you get into a                                 review from a review point on you have                                 your continuous integration QA going on                                 basically automated testing and from                                 automated testing this goes to real QA                                 and from real QA it can get into a                                 release                                 so let's look how it looks like so Fran                                 in the review part it's again in a major                                 software product it's merit-based so you                                 trust certain people based on their                                 experience in that product so good                                 software systems github being one of                                 them                                 we personally use the atlast of but                                 everything it's just a tool everything                                 is based on how you implement things and                                 how you implement the rules and for us                                 if you create a pull request you need at                                 least three succeeding reviews otherwise                                 the code is not going further down the                                 chain why is that I mean even I'm one of                                 the at least in a core project one of                                 the reviewers of the code and sometimes                                 even for us things slip through right we                                 didn't think to the end but the review                                 process already gives a lot of potential                                 in terms of eliminating obvious things                                 of thinking of hey have you been                                 thinking of this you're breaking a                                 complete different feature here                                 so think about that so this whole review                                 is a very important part if you don't do                                 reviews you don't do good code that's                                 the reality you can be the best coder in                                 the world but you always forget                                 something so it helps in to quality a                                 code quality it helps you identify                                 potential side-effects                                 it keeps also which is also nice for a                                 software project                                 it keeps the conversation going right is                                 your people you're talking to people                                 you're not talking to computers so it's                                 it's really good because you also can                                 only learn from that and therefore base                                 your future experience also on the input                                 that you get from other sides style                                 guidelines obviously so                                 especially in the beginning when you're                                 committing to a project you get into the                                 situation where I'm not certain maybe I                                 didn't understand certain aspects of the                                 of the coding guidelines because they                                 can be very long just look at the                                 asterisk guideline that's really                                 humongous and yeah once in a while we                                 all up and so it helps to do a                                 review next part is continuous                                 integration so I will give you some                                 numbers in the end but every commit at                                 least I can speak for Capano and for                                 some other software projects as well                                 every commit that you create just starts                                 off continuous integration checks so                                 automated test it our automated tests                                 are running with hopefully a good code                                 coverage also merge tests because                                 specifically when we're talking about a                                 large code base you have the issue that                                 things need to fit in together basically                                 also for a release generally sanity                                 checks linting and packaging for example                                 and also very important memory leak                                 checks so just that I experienced like                                 three years ago we had a heck a lot of                                 memory leaks because we simply didn't                                 check them intensively enough so for                                 example we had a high speed allocation                                 algorithm used from SGI turns out that                                 was leaking like I leave that word out                                 so from from code to quality code also                                 means that you check for all kinds of                                 regressions instabilities for example                                 and if you have any which is also type                                 of a regression regression of a                                 scalability or performance or                                 interoperability so you want to make                                 sure for example customers trust our                                 solution because they want to keep their                                 data safe right and they want to have                                 their data fast so the user experience                                 is very important but most of all they                                 want to make sure that their data is as                                 safe as it gets and when you introduce                                 new features when you introduce bug                                 fixes whatsoever things can change so                                 it's it's very important that you always                                 take in mind to have good code coverage                                 and here we are actually this is from                                 Coverity I don't know if you                                 if you know that solution but it helps                                 you identify weak spots in your code                                 basically it's a great product can only                                 recommend it so you can see that we're                                 actually far under the average defect                                 density of open-source software but                                 we've not always been that way and the                                 last check and this is something also                                 that's that Noah I mean I'm not talking                                 about artificial intelligence or                                 anything like that here now because                                 obviously that would be a vector that                                 can approach things like that but real                                 QA or as real testers are still                                 important because they know the software                                 they know where to look at they know                                 when certain things are in and they also                                 often know customers right because they                                 they are also in a group where they get                                 feedback from from other people and say                                 like hey why didn't we catch it last                                 time so it's it's really good that you                                 have QA personnel and place testers in                                 place which can you know do the extra                                 work even if you have a good code                                 coverage                                 you still need testers that can                                 professionally yea address yea address                                 things that that come along especially                                 with very large commits that come around                                 and obviously also documentation needs                                 to be updated as well going from QA to                                 release means what is about backwards                                 and compatibilities api ABI obviously we                                 never want to change api ABI as much but                                 when you introduce new features it can                                 be that you have to introduce the calls                                 no calls change can require changes in                                 existing calls and therefore can break                                 API or ABI is the ability at least maybe                                 not on a short-term but on the long term                                 and therefore this is something very                                 important that needs communication that                                 needs testing and especially when it                                 comes to behavioral changes this is                                 something that needs really to be                                 communicated out to the world this is an                                 example of the zet push project of the                                 checklist that we do with every even                                 minor release yeah so I promised you                                 some numbers so for Capano is                                 one commit that you create for six                                 platforms that is like CPU architecture                                 like                                                                     v                                                                     eight test groups behind there we're                                 talking about all kinds of unit tests                                 and then we have                                                         in total so that's all the kind of                                 distributions you can imagine from                                 Debian Ubuntu Sousa Red Hat you name it                                 and so one commit actually generates                                                                                                   numbers of just what one what this is                                 not true two repositories of us this                                 Capano corn campano dependency created                                 in just                                                                two thousand eight hundred thousand                                 tasks to be done to make sure that our                                 software has high standard and quality                                 yeah so this is basically it I think I                                 ran out of time anyway so if you have                                 questions just let me know                                 we have time for at least one question a                                 quick one if there's any all questions                                 asked                                 well you can get back to Mike think he's                                 at the Capano poof sometime spike if                                 there's one thank you very much
YouTube URL: https://www.youtube.com/watch?v=hgtkBCBu8cg


