Title: #FOSSBack 18: Paul Burt â€“ Leeches to lidocaine: bringing empiricism to software
Publication date: 2018-06-22
Playlist: FOSS Backstage 2018
Description: 
	As software creators, we often flirt with titles that contain words like scientist, engineer, and architect. Yet, despite the empirical sounding quality of those titles, our field is still filled with mysticism, and by-the-gut models for how we believe things work.

We can do better. The book Making Software opens the door to a reasoned, proven approach to validating these beliefs. To do that, we'll start with a look at the History of the medical field. We'll compare the similarity of early science based medicine to our current situation with computer science and software engineering. Over the course of this talk we'll explore topics like:

- 10x programmers: do they exist?
- Conway's Law: does software mirror team structure, and can we exploit that fact?
- Pair programming: is it worth it?
- The Cathedral and the Bazaar: is the organization of OSS significantly different than closed source?
- Measuring code quality: are there simple, statistically backed metrics for evaluating code quality?

We'll close the talk with a look at people and places who are continuing to do this important work. This talk is aimed at anyone who has worked in tech, and has ever been curious if any of our common ideals have been backed up by more than just a feeling.

Read more:
https://18.foss-backstage.de/session/leeches-lidocaine-bringing-empiricism-software

About Paul Burt:
https://18.foss-backstage.de/member/paul-burt

Website: https://www.foss-backstage.de/
Twitter: https://twitter.com/Fossbckstg
LinkedIn: https://www.linkedin.com/groups/8653059/
Captions: 
	                              hello Berlin good morning Faust                               backstage happy to be here talking to                               you about science today I hope you're                               excited about science as well if I've                               done my job by the end of the                               presentation you will be so we'll see                               how we do I should start this                               presentation by noting that I submitted                               this talk when core OS was core OS but                                now core OS is RedHat so I'm technically                                part of the Red Hat family and                                representing them but I figured I would                                keep my slide deck and core OS theme                                still you know for old times sake                                so my talk today is about the contrast                                between the early days of medicine and                                how we make software today you know in                                the old days at least as they tell it in                                the American tales of the West there                                were a lot of folks wandering around                                pulling teeth and putting leeches on                                people using some what sort of barbaric                                means of administering medicine but this                                is what they knew and a lot of what was                                taught to them was passed around by folk                                knowledge or just face-to-face people                                telling stories about what they think                                works sometimes it did work sometimes it                                didn't and eventually we got to today                                where medicine is highly science-based                                and I think there's an interesting                                parallel between that journey in the                                journey we're making with software today                                so I got interested in this originally                                because working at core OS with the                                smart folks there we make a number of                                open-source projects so I became                                interested in measuring our projects                                health trying to figure out if things                                were going well if they were going                                poorly how to kind of get early signals                                as to you know whether one or the other                                is happening and sort of figuring out                                what are the important measures to look                                for to figure those things out so I                                started writing Google bigquery's to you                                know piece some of that information                                together and like most people I started                                looking at                                a number of commits per week and source                                lines of code but you know as as you are                                probably aware those are unsatisfying                                metrics to work by as a developer you                                don't feel like those accurately capture                                all of the complexity that goes into                                making software so I thought there must                                be something better and indeed there was                                so just to fully draw this parallel out                                the world of medicine not so long ago                                went through a similar sort of process                                so it wasn't so long ago and say the                                                                                                      discovered that if doctors washed their                                hands they could greatly decrease the                                mortality rate of women giving birth                                what he noticed is that doctors who                                performed autopsies would then go and                                deliver children for women who were in                                labor and the women who had doctors do                                that versus the women who had midwives                                do that had starkly different outcomes                                and it turns out it's because the                                midwives never actually got the hands                                dirty with diseased bodies doing                                autopsies so he devised a little                                experiment and had some doctors wash the                                hands with chlorine after they did the                                work with cadavers and found this                                dramatically reduced the mortality rate                                for women giving birth despite the                                evidence it still took years for these                                findings to catch on and I found we're                                sort of in a similar place with software                                where we've done a lot of interesting                                research on things beyond just whether                                to use bubble sort or a quick sort um                                that stuff is very scientific in                                computer science but when it comes to                                the day to day operations of writing                                software actually making things we still                                rely on a lot of mysticism so you know                                we talk about things like                                    programmers and Conway's law and a lot                                of other of these things that are passed                                around similarly to leeches and pulling                                of the olden days we do it because we                                think they're right                                but that's all we have is we think                                they're right for the most part so I                                 started to think like has someone                                 actually tested this can someone tell me                                 whether this actually is right and it                                 turns out for more than a decade this                                 book has been out almost you know we're                                 about to you're shy I guess so                                 I guess my maths slightly off by two                                 maybe not off by one but yeah in any                                 event this this book I found really                                 enlightening it took a lot of actual                                 empirical studies about the the the                                 process of making software and talked                                 about them things like Conway's law the                                                                                                         what we're gonna dive into you next year                                 cool so this is sort of serendipitous                                 and that there are open source cupcakes                                 in the next room I believe so                                 I didn't plan this with this slide but                                 this is one of the the I think most fun                                 things I discovered doing this research                                 is I guess in Silicon Valley at least                                 people like to talk about the need to                                 hire the best developers you know when                                 you commit something to an API people                                 start consuming that API it sort of gets                                 stuck in that place and everybody has to                                 live with your poor decisions for                                 decades so it's paramount that you have                                 the best programmers you possibly can                                 and part of that mythology relies on a                                 study that was done comparing sort of                                 the spectrum of programming talent what                                 is the gap of skill between the best and                                 the absolute worst programmer well the                                 study that was originally done that most                                 people are citing but don't actually                                 realize was a study that was done a                                 college campus and it was done with                                 computers when they were still doing                                 programming through punch cards so                                 starkly different than how we write                                 software today and in this study they                                 were actually measuring people who had                                 basically almost no knowledge of                                 computers whatsoever so the equivalent                                 of a parent or a relative                                 who needs you to do everything including                                 log them into their email for them                                 and people who've been programming for                                 years so you know people who were doing                                 programming in a professional capacity                                 and in that study they found that there                                 was actually a                                                         the absolute worst and the absolute best                                 when it came to the output that they                                 were able to put out and the test there                                 this isn't too enlightening it turns out                                 in most cases you're not hiring people                                 to work with you and your team off the                                 street that are the equivalent of                                 someone who barely knows how to access                                 their email you're you're hiring people                                 who studied programming or have some                                 capacity for programming and in a                                      study they found that in most workplaces                                 where people are actually programming I                                 think it was across more than a hundred                                 developer or                                                           developers they they found that the gap                                 was more like a                                                         and the worst programmer in the office                                 and when you started to control for                                 things like the amount of domain                                 expertise and the amount of years on the                                 job that gap starts to rapidly shrink so                                 the idea that there's one programmer in                                 your team who's absolutely indispensable                                 and they know everything and you can't                                 live without them because they're a                                     programmer is sort of a mythology that I                                 think we need to let go as programmers                                 cool the next most interesting thing I                                 learned was about Conway's law so if                                 you're unfamiliar Conway's law is the                                 idea that code would reflect steam                                 structure so the canonical example for                                 Conway's law is if you have a team or                                 say you have four teams and you're                                 writing a compiler you'll get a four                                 pass compiler so the idea is that the                                 organization in your company is directly                                 reflected on your repository this gets                                 cited commonly but you know the question                                 is open has it been improved and the                                 answer is yes there was a                                               Cataldo I'm probably mispronouncing that                                 name but if you check the slides there's                                 there's links to this research who                                 looked at this and he found that                                 Conway's law is actually real and it's                                 really real it's real enough that they                                 found that organizational factors were a                                 better predictor of how the code turned                                 out then things like the actual code so                                 if you looked at cyclomatic complexity                                 or did code analysis using static                                 analysis type tools the organization a                                 team structure was actually better in                                 terms of figuring out how the code would                                 turn out architectural e than those                                 other things so I think that's quite                                 interesting                                 similarly there was another study that                                 happened in the same sort of time period                                 that kind of looked at the difference                                 between open source projects and closed                                 source projects so this is sort of the                                 idea of the cathedral and the bazaar the                                 the dream is that for most open source                                 projects they act like a bazaar where                                 programmers can come to your stall                                 converse with you drop something off you                                 give them something in return and then                                 they go to another stall and they're                                 sort of self-guided if you've actually                                 contributed to open source at least in                                 my experience this is not true and this                                 study that I read                                 in this book sort of compared the Linux                                 codebase to the Microsoft codebase for                                 Windows amongst a few other projects and                                 they found when they looked at a graph                                 of how the governance model of those                                 programs were set up Linux is actually                                 pretty hierarchical you have Lennis on                                 top                                 he has his lieutenants under him he                                 literally calls them lieutenants and                                 they each own certain areas of the                                 program and you may be aware that it's                                 actually relatively hard to do drive-by                                 commits and open source generally some                                 commits are helpful and you know                                 contributors are happy to take patches                                 but some commits are someone essentially                                 just backing a dump truck up to your                                 codebase dumping a bunch of code and                                 saying you maintain this for me now all                                 right I'm out peace and that's usually                                 not very friendly it's usually not the                                 sort of thing that people appreciate too                                 much usually when you're contributing to                                 code people tend to collaborate on teams                                 naturally and they tend to stick with                                 those teams if they are a good                                 contributor and this happens naturally                                 in open-source projects and projects                                 that are particularly good at this today                                 our projects like rust if you've ever                                 contributed to rust you know what I'm                                 talking about they have a lot of BOTS                                 and other things that introduce you to                                 people who have worked on similar areas                                 of the code that you've worked on kind                                 of guiding you through the process of                                 getting integrated with their sort of                                 norms and values and the the other thing                                 is kubernetes is also very good at this                                 kubernetes tends to orient itself around                                 sig groups special interest groups for                                 various areas of the codebase and you                                 can exploit Conway's law by just knowing                                 that people are gonna work better on                                 teams naturally so if you want good                                 contribution contribution model for your                                 projects find a way to integrate new                                 contributors into teams and that will                                 lead to happier longer-term                                 contributions to the work that you're                                 doing this is sort of my takeaway on                                 scientific as it is but if you were                                 around yesterday there was a talk on                                 empathy in software                                 and this is why that sort of stuff is so                                 important turns out software's made of                                 people is the way I like to think of                                 Conway's law which means all of the                                 messy ugly things we have to deal with                                 as people affect the code that we're                                 deploying so figuring out how to work                                 well in a team actually turns out to be                                 relatively important cool next question                                 does pair programming work so I'm going                                 to go a little bit faster through these                                 because it looks like I'm running a                                 little low on time but pair programming                                 is great when the problem is complex                                 errors in the code are costly and the                                 knowledge transfer lowers the bus factor                                 on your team so the bus factor is the                                 idea if someone gets hit by a bus                                 tomorrow you know your team can still                                 function they don't have everything                                 sitting inside their head that nobody                                 else knows a study of pair programming                                 found that pair programming is actually                                 best when different personalities pair                                 it's sort of interesting it's not                                 something you would think would be true                                 but when an extrovert and an introvert                                 pair together that tends to be the best                                 combination for doing pair programming                                 for whatever reason they're not really                                 sure                                 they found that pairing reduces                                 interruptions when you're coding which I                                 know we all suffer from and disliked by                                 the number of memes I see floating                                 around on Twitter and reddit so the                                 thought here is also that they don't                                 actually know why this is but they think                                 it's if someone sees a group of people                                 doing something they're much less likely                                 to interject and ask them to help them                                 or distract them they see they're busy                                 collaborating so they'll go along their                                 merry way unless it's truly important                                 and the final thing is pair programming                                 isn't something you can just do randomly                                 and have it work people have to actually                                 train to do pair programming correctly                                 together so you need at least                                          of training generally before you become                                 proficient and you start to see benefits                                 of pair programming                                 so some devs may be                                                    will just never pair well                                 at all that's fine pair programming                                 tends to work faster since its but since                                 it's two coders it ultimately ends up                                 costing you about                                                    hours and the ideal session is you know                                 four hours maximum if you go longer than                                 four hours in a day you're gonna get                                 diminishing returns on this cool so                                 who's who's ever tried to measure code                                 by source lines code or commits or churn                                 anything like that has anyone ever made                                 that yeah I I have I think we all have                                 when we first start looking into this                                 stuff and we all sort of immediately                                 realize that it's actually pretty                                 difficult to quantify the value of code                                 so there are some scientific measures                                 for doing this                                 there's mccabe's cyclomatic complexity                                 which I'll just jump through really                                 quickly there's hallstatt's                                 software science metrics it looks at                                 operators and determines complexity                                 based off of that and then there's                                 simpler measures there's things like                                 source lines of code and number of                                 functions so one study found when you                                 look at all of these together and how                                 they correlate in terms of telling you                                 things about the quality or the hygiene                                 of the code a value of one if you pair                                 these together means they are perfectly                                 correlated so if you look at source                                 lines of code in the top row here and                                 you go over to HL hang and H volume                                 basically those are the hallstatt                                 complexity metrics that are sort of the                                 intuitive way to measure complexity and                                 source lines of code has a                                            overlap with that in terms of                                 correlation telling you whether your                                 code is good or not which seems crazy to                                 me like I would never expect that result                                 but that's how science works so there is                                 some healthy skepticism you should have                                 here this study was done on C files so                                 this may not apply to your programming                                 language of choice science needs to do                                 more work to sort of figure that out and                                 they found for small files less than a                                 hundred lines of source code                                 this also tends to fall away as well                                 when you're you're measuring complexity                                 and likelihood of bugs in your code so                                 all of this research is pulled from this                                 wonderful book making software what                                 really works and why we believe it this                                 is a fantastic book I should just add                                 one caveat and that is that science is                                 never derived from a single study a                                 single study never proves anything it's                                 derived from the community opinions over                                 that are derived from multiple studies                                 and it's the community that is objective                                 and all of us because we are passionate                                 people are ultimately subjective no                                 matter how much we try these are                                 interesting resources that I'll just                                 sort of jump through time there's also                                 the chaos projects which is community                                 metrics that are being run through by                                 the Linux Foundation for measuring your                                 own software projects this is very early                                 so if this is something that interests                                 you this is a great group to get                                 involved with and I'll end by just                                 saying that it's a little more complex                                 than just adding more science to what                                 you're doing because science generally                                 has a limited view of the world there                                 are things that science understands and                                 things that science doesn't and if you                                 were to only act upon science you would                                 have a very limited range of action and                                 what you do day to day so it's good to                                 be scientifically minded but you have to                                 get work done nonetheless so if you say                                 this theory that we work from is broken                                 and incomplete and it's terrible your                                 boss may say yes it's broken and                                 incomplete and terrible get back to work                                 and that's fine                                 all the same I think it's relatively                                 important to raise those objective                                 objections and when other people raise                                 the objections to be supportive a                                 interesting example of this not                                 happening was when Einstein once                                 published a theory of general relativity                                 max plunk got an early review copy                                 because he was a huge advocate for                                 Einstein's first a kind of                                 groundbreaking paper and Max                                 Punk wrote back and said in the first                                 place you won't succeed and even if you                                 do no one will believe you which is wild                                 considering how impactful the theory of                                 general relativity ended up being so we                                 should all be a little bit supportive of                                 the crazy ideas our co-workers have it's                                 possible to be both supportive and                                 skeptical and that talk on empathy                                 yesterday I think had some good points                                 on how to do that and finally the                                 process of science this is an                                 unscientific thought but I like to                                 believe it's about being agitated about                                 the models that we build and use so you                                 look at all good science it ends up                                 getting overturned or proven wrong by                                 the generation that comes next so you                                 look at people like early psychologists                                 Erik Erikson and Carl Jung both studied                                 under Freud and both just totally tore                                 apart for its theories came up with                                 their own or way more accurate way more                                 well received that doesn't mean what                                 Freud did wasn't worthwhile it was just                                 an incomplete model and most science is                                 working from incomplete models but we                                 are able to progress because we get                                 agitated by those incomplete models so                                 if there's one recommendation for sort                                 of pushing our industry forward it's                                 that we should continue to agitate we                                 should remind ourselves when we're                                 working on knowledge that is not                                 scientific and incomplete and we should                                 remind those around us that that is                                 happening as well and maybe one day that                                 theory will get tested or someone will                                 do some reading like making software and                                 bring that into the office and bring                                 some science into your life so before I                                 end this I just wanted to say thank you                                 to my friend Diane Thompson who is a                                 scientist herself and conversations with                                 her helped me to formulate some of the                                 thoughts behind this talk and she's also                                 getting married this weekend in Sweden                                 so to Diane it's a you and Marcus I wish                                 you happiness and health                                 thank you                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=fIUtGkbOl8Y


