Title: Berlin Buzzwords 2017: Fokko Driesprong, Vincent Warmerdam - Balancing Heroes & Pokemon in Real Time
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	In this talk we will demonstrate a matchmaking system for online video games that needs to work in a streaming setting. In particular we will demonstrate a solution to the following problems; 

- How can you estimate the skill of a video game player in an online setting? Note that this needs to work for one vs. one player games as well as games with a team setting. 

- Given these skill estimations, how can you match them such that each player is always playing against a similar skill leven and doesn't need to wait very long. Note that this needs to work in a distributed session as well. 

To demonstrate an easy setting we will demonstrate how we are able to rank Pokemon in one vs. one matches. To demonstrate a harder setting we will streaming game logs from heroes of the storm into our algorithm to show how it works. The stack we use is Apache Flink together with ElasticSearch and Kibana. We intend to demonstrate a solution to this problem both on an engineering perspective as well as a machine learning perspective. 

Read more:
https://2017.berlinbuzzwords.de/17/session/balancing-heroes-and-pokemon-real-time-streaming-variant-trueskill-online-ranking

About Fokko Driesprong:
https://2017.berlinbuzzwords.de/users/fokko-driesprong

About Vincent Warmerdam:
https://2017.berlinbuzzwords.de/users/vincent-warmerdam

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              my name is Vincent and this is my dear                               colleague Foucault before we actually                               talk about the thing we want to talk                               about there's a couple of things we have                               to do for example we have to really make                               sure that you guys understand that we do                               not work for Blizzard you guys also have                               to understand that we do not work for                               Nintendo and you guys also have to                                understand that we do not work for                                Microsoft I used the words to scale in                                our title and to scale is a licensed                                algorithm and I'm not intent on finding                                out what that legally means so we don't                                work for Blizzard we don't work for a                                Nintendo we don't work for Microsoft I'm                                an algorithms guy Ã©poca was an                                engineering guy and we built a small                                hobby project together it is not                                something that really goes into                                production but we have some interesting                                lessons here and this project basically                                started as a mere nerd snack the main                                point I hope to get across to you today                                though is we're going to talk a bit                                about how machine learning is applied in                                sort of a lambda setting in kind of a                                streaming setting because why typically                                we have a machine learning algorithm                                like you see here I will call this some                                sort of function because most machine                                learning methods that have been trained                                can be seen as a lambda function and                                every time an event comes by we apply                                the machine learning function probably                                does predict some sort of tag and as                                these events come streaming in we apply                                the function and this is how usually                                things are brought to production and                                we're going to talk about today in                                particular is a situation where every                                point of data that the machine learning                                algorithm come gets will also allow the                                function to update so in the second                                situation the function changes for every                                single data point we see and this                                actually means that not only can we                                apply a machine learning function in                                streaming we can actually learn from it                                in streaming and because it's Berlin and                                you know flink people are here I don't                                think I have to explain to this group                                that streaming may actually be                                preferable because thinking about it if                                you can solve machine learning in a                                streaming setting that means you've also                                solved it in batch and we'll present a                                couple of general things where it's                                actually not too hard to apply this                                stuff so let's talk about an enterprise                                use case now this is our enterprise use                                case let's say we'll pretend that we're                                some sort of video game company and                                there's some queue if people really want                                to go and play these video games now                                there's a couple of things that                                immediately become a bit of a problem                                because you want these players to play                                against people that have the same skill                                if you are a super noob and the other                                guy that you're battling against is                                super awesome and great you're both                                going to have a bad time                                and we can only learn this from sort of                                a stream of mass outcomes so whatever we                                learn comes from events that say this                                player battled that player and this                                player was the winner and from this we                                have to get an impression for the skill                                is like such as we can maybe do some                                sort of matching and I hope that it's                                also kind of clear that will be                                definitely before a preferable if this                                works in some sort of a streaming                                setting and not so much in a batch                                setting preferably after every single                                game has been played the disbelief of                                the skill of both players will have been                                updated so let's talk about some                                thoughts that may allow us to think                                about a proper solution one thing you                                might want to do when you try to                                estimate the skill of the players you                                want to quantify that into a number so                                let's say a number between                                             that are very bad you would push towards                                a                                                                       super good you'd push to the                                         despair and a common flaw I guess that                                 you could say is that you really see                                 this as a single number as you want to                                 estimate it might actually be more                                 useful that instead of your state being                                 a single number that describes what the                                 skill of a user is you actually keep                                 track of the distribution of belief                                 instead the idea is for example the blue                                 player here that smack dab in the middle                                 might be a player that only played one                                 game in the entire lifetime that means                                 that we might have an estimation of                                 skill but there's a lot of noise around                                 it we're not super sure what the skill                                 this player is because they simply                                 haven't seen as many games of it yet                                 whereas for the green player in this                                 case because it's a very peak                                 distribution we're actually quite sure                                 that it is this skill of this one player                                 what I will argue is a keeping track of                                 the skill as a distribution will allow                                 us to do learning and streaming because                                 the idea is we'll just update to the                                 distribution instead of just updating                                 this one single number so let's actually                                 think about it this way and let's see                                 what happens if we have two players                                 @badlayouts against each other so here's                                 a distribution for player                                              distribution for player                                             distribution of skill for both players                                 separately what you could do is you can                                 say instead of having two separate                                 one-dimensional distributions of the                                 where the skill might be we can also                                 combine those you know very bluntly it's                                 like we can also say we have one                                 distribution that's two-dimensional this                                 is the belief of one player and where                                 the skill might be this is the belief                                 where the skill of both players might be                                 just like a                                                   throughout the idea that is if then a                                 game happens and one player one and the                                 other one lost you can basically say                                 whatever is on the raw so ever there's                                 probability mass where we just saw it                                 shouldn't be likely we just cut all the                                 probability mass away so for example we                                 have a diagonal line is player one wins                                 then this side should be more likely                                 than that side hence we can remove                                 probability mass here the same thing we                                 can do for player two and you know if                                 we're thinking about it and apply some                                 sort of nice little margin we can also                                 accommodate for draws because the draw                                 will basically say hey these players                                 might actually have the same skill the                                 idea behind this is that we first have a                                 prior then we measure the game outcome                                 we have some sort of two dimensional                                 likelihood and the only thing we then                                 need to do is map it back to a one                                 dimensional likelihood so what we hope                                 is that then something like this will                                 happen where if this player wins this                                 player skill is couch to the right which                                 is what we want                                 this one was couch to the left and vice                                 versa if the other player wins and I go                                 and again I hope it becomes fairly                                 obvious in this particular example we                                 couldn't do this if we just kept track                                 of one single number the fact that we                                 were keeping track of a distribution                                 allows us to be able to update the                                 distribution of skill now these are sort                                 of I hope that you agree very pretty                                 pictures but if you don't to turn this                                 into an algorithm you have to do some                                 prototyping if you go to my blog you'll                                 actually have an interactive version                                 where you could go ahead and play with                                 this but I figured let's just do this                                 very bluntly with a small R script and                                 what you see here is just some random                                 data so the distribution of skill that I                                 have is some sort of histogram I'll                                 pretend that if I've never seen a player                                 before that this is sort of the prior                                 that I might have of the player and                                 again this is all a simulation exercise                                 I'm not doing any math quite yet but I'm                                 just saying this is a distribution of                                 two players that I've just sampled if I                                 then remove all the mass here again I'm                                 keeping some sort of margin in mind and                                 then you automatically see that these                                 two distribution shift accordingly just                                 the way that I kind of want it is more                                 likely that this player is better than                                 that player and that map's back into                                 these single distributions so again to                                 put all the steps in perspective we                                 start up with these two priors we put                                 that into a two dimensional prior then                                 either this player wins or that player                                 wins we remove the mass accordingly and                                 then map it back into a one dimensional                                 distribution there's some normalizations                                 and stuff that I'm also doing but the                                 idea is it's an update of our                                 distribution some of the stuff you                                 actually get for free and again this is                                 not math I added in this is just what                                 happens if you simulate this you can                                 also simulate a situation where one of                                 the players is actually a bit better                                 than the other                                 for example this might be a player where                                 we've seen that we've seen played a                                 bunch of games and this is a player that                                 we haven't seen play a lot of games yet                                 this distributions been more pinky and                                 we think that this player should win                                 what then happens is in a situation                                 where this bad player just beat this                                 good player that gives us more                                 information the update from here to here                                 is larger and then in the previous                                 situation where this shift of the                                 distribution was smaller and if you                                 think about this in vs. also makes sense                                 if you are super new and you just beat                                 one of the best guys out there then                                 probably you are very good it's probably                                 not due the chance that you beat this                                 guy and that means that we can give a                                 bigger shift to the updater we're doing                                 conversely what you will also                                 automatically see is if I just if this                                 person lost from someone that's supposed                                 to be good                                 we don't really update the prior as much                                 simply because what we believed before                                 the match has been confirmed by the                                 match what you can then do if you prove                                 that this indeed works in simulation                                 settings you will then do another                                 simulation where you actually try to                                 simulate lots of different users and the                                 way that I did this I basically said                                 look there's a couple of users between                                 user                                                                  the worst player user                                                 player and I just have these people play                                 it out randomly and see if this                                 algorithm performs in sort of a real                                 life simulation example what you see on                                 the x-axis here is the actual skill of                                 the player and here is sort of the the                                 most likely area where I believe the                                 player to be and this I believe the                                 first two charts that you see are for                                                                                                                                                                                  peak of the distribution given the true                                 skill level and this is the histogram                                 that's supposed to be attached to every                                 single user here and one thing you see                                 which is what we kind of like is it                                 converges to the true distribution that                                 we're interested in what we can also see                                 is these distributions converge they                                 become more peaky there is more still a                                 little bit uncertainty for every player                                 here in terms of skill but we do get                                 this nice property that every game                                 that's being played we do get a nice                                 more spiky peak now of course okay I did                                 this on the simulated data set now let's                                 just see if I can apply to it                                 data set and is where the Pokemon come                                 that kind of comes in so the goal is we                                 we want all these Pokemon the battle out                                 to each other and let's pretend we're                                 interested in finding out what the best                                 pokemon is and what the worst pokemon is                                 and we're going to do is we're going to                                 be very scientific so we're going to                                 test this algorithm that I just proved                                 kind of works you know how do you do                                 that well there's this website it's                                 called poke API Co everyone knows this                                 website you can scrape the website but                                 nowadays actually easy to just go to                                 kaggle because you could do the scraping                                 and all the JSON parsing yourself or you                                 just download the data set from kaggle                                 well if this data set you can then go to                                 fan websites where you can actually get                                 the formula how the videogame of pokemon                                 science damage from one Pokemon to the                                 other again all this is sort of                                 arbitrary it's in the slides but the                                 main thing that I want to point out here                                 is I can actually simulate match                                 outcomes with a bit of assumptions in                                 this basically what I do is I calculate                                 the number of turns one pokemon with                                 outlast the other with basic attacks and                                 this feels like a genuinely ok-ish first                                 order approach to see if this eyewear                                 them works this is what we then get and                                 again I play this tons and tons and tons                                 of times and one of the things that I                                 kind of like is that the algorithm                                 automatically sort of homogeneously                                 distributed skill of all players is that                                 like all the players are on this side or                                 on that side the algorithm automatically                                 tries to map all the players between                                 zero and one and also in sort of a                                 linear way that it's spread out evenly                                 if you're then interested then what my                                 algorithm says is that magikarp is                                 indeed the worst pokemon out there and                                 that Mewtwo is actually one of the                                 Pokemon that's supposed to be better so                                 yeah scientific proof I guess I'm happy                                 to see that you guys may have to laugh                                 about this as well I I also thought this                                 research was hilarious anyway and we've                                 done Magikarp we've done Mewtwo there's                                 all this fun and we have a nice little                                 algorithm that kind of works but let's                                 take a step back and check what this                                 means because there is a general massed                                 everything I've just shown you designing                                 algorithms became a whole lot easier                                 when we admitted that we didn't want to                                 quantity that we didn't just want to                                 have like the maximum likelihood the                                 skill we actually wanted to quantify the                                 uncertainty as well this means that the                                 state we keep track of for player is a                                 distribution of State and not just the                                 mere statistic to put that in formula                                 basically what we're doing is we're just                                 applying Bayes rule                                 the idea behind Bayes rule is we have                                 some sort of parameter we want to                                 estimate based on the data that we see                                 in this case this is just a distribution                                 of the skill that we have                                 and what bays we will basically say is                                 that we have some sort of prior and then                                 basically we have an update probability                                 for every data point that we see in                                 situation before this update was the                                 cutting of the two-dimensional prior if                                 you write this out and let's say we take                                 a very simple example where there's only                                 a situation where we have three data                                 points we take this formula and we write                                 it out a pattern emerges because you can                                 basically say if I only saw the first                                 data point and I have to estimate the                                 skill for the data point of two this is                                 the prior before we see the second data                                 point we do the same thing for the                                 second data point and all of these                                 things together become the prior for the                                 third data point we can rewrite this                                 again and then what you get is this nice                                 little recursive relationship that                                 basically says we have some sort of                                 prior before a new data point gets in                                 and then when we see a new data point we                                 just make have to make sure that                                 probablistic aliy we have an update rule                                 that makes sense and this is a situation                                 where in this case the parameters here                                 are sort of static you can take an extra                                 step by saying look these parameters                                 might also be able to change over time                                 oh let's just do a bit of sloppy math                                 and say we sort of do this to the                                 exponent of alpha this the exponent of                                 beta we still through some sort of grid                                 search                                 but whatever algorithm that you have                                 that sort of fits this it's                                 automatically a streaming algorithm for                                 free and that's what makes Bayesian                                 machine learning so awesome in our                                 example of course we're still interested                                 in dealing with the histogram of skill                                 but anything that's Galan has kind of a                                 closed form solution and a thing for a                                 lot of these things so you can actually                                 do linear regression this way as well so                                 in fact this is a general rule and I                                 hope that I've just made clear we just                                 gave an example of exactly this we're                                 not done that we're not really done yet                                 though because obviously I promised the                                 second video game that we would do as                                 well and this is a video game that's                                 even more an enterprise situation who of                                 you has played this game yeah you guys                                 are liars this is an Internet so if this                                 is a hacker conference and I don't                                 believe the only three people play this                                 video game                                 this is heroes of the storm so if you've                                 played blizzard games alright people                                 have said that yeah yeah good people are                                 admitting so the idea is in the Pokemon                                 situation that we just had before it's                                 always in one for just one game                                 but in this situation things are a                                 little bit different because this was                                 the enterprise situation before but it                                 now changes because now people will say                                 hey I want to play a certain character                                 they then get into a queue and then have                                 to be matched up until a team and both                                 from sort of this sort of an engineering                                 as well as a machine learning                                 perspective this changes a few things                                 and actually makes a problem a whole lot                                 harder because we need to update player                                 skills after a team match that's                                 different than just being able to say I                                 have two players that need to be updated                                 we also need to assign players in a team                                 as well so we want to say these people                                 have the same skill there's some sort of                                 cueing system that ensures that whenever                                 our game is started you're playing with                                 the same skill we also need to worry                                 about character imbalance because you                                 can imagine if we have a team with all                                 assassins playing against a team of all                                 sort of healers the assassins will                                 pretty much always win so in a situation                                 where we're assigning a team we also                                 have to keep track of this we figured                                 though that in the end is not really                                 that complicated you just have to think                                 of the architecture beforehand so let's                                 say there's some sort of queue and we                                 had already some sort of player state so                                 for every player that's sort of entering                                 we have to map that to some sort of                                 skill and again this skill will be some                                 sort of distribution instead of a mere                                 statistic the skill we can sort of then                                 map into some queue where everyone that                                 has roughly the same skill falls in the                                 same queue if this queue then it has ten                                 players let's say that's enough to make                                 a team so your ristic wise we could say                                 okay these players are the same skill we                                 have to assign them into separate teams                                 but this game can go ahead and get                                 started after that some sort of battle                                 happens and that battle basically should                                 only really concern the update of the                                 player state and maybe do some stuff of                                 the logging this is a general pattern I                                 guess so let's discuss some of the                                 things in between that we need to be                                 sure of that we do correct we have to be                                 very sure that we map a scale to a queue                                 or to be very sure that we assign teams                                 to a after a queue I want to be very                                 sure that we update individual skill                                 after it's team fight appropriately now                                 the updating of a skill to a queue is                                 actually relatively easy you just take                                 the player skill you take whatever is                                 the most likely region and map that into                                 one of the buckets that we've defined                                 before beforehand we can say hey this                                 instance of our app has eight buckets or                                                                                                      parameter but it's relatively                                 straightforward to map a player skill                                 into such a bucket                                 even if there's uncertainty and spread                                 you just take the most likely one that's                                 a reasonable heuristic if you want to                                 assign teams so that's a little bit more                                 tricky this is the all Assassin's versus                                 old heater use case because what you                                 could do is you could take all the                                 characters that there exist in this game                                 and all the combinations that possibly                                 could exist it's you know it grows                                 indefinitely you get into a nasty spot                                 here so also here it'd be nice if you                                 just come up with a bit of an easy hack                                 turns out if you play the video game you                                 get a bit of domain knowledge because                                 let's say we have people that say this                                 player wants to play Diablo we know that                                 a certain character in this video game                                 also maps to a certain type of character                                 you can do this clustering yourself but                                 in this particular case we already knew                                 this so we know that they aval for                                 example is a tank it's a person who can                                 take a lot of damage Raynor is an                                 assassin that someone who could do a lot                                 of damage                                 murky is a specialist mercury destroys                                 all your towers so now he is a healer                                 the healer make sure you people your                                 characters don't die that means whenever                                 we get a queue of ten people let's say                                 we can first do a mapping that says is                                 the character and this is the type of                                 the character we can then sort on the                                 character type and if this is sorted we                                 can just do a heuristic that says okay                                 let's do the odd ones and even ones in                                 different teams and this gives us                                 somewhat of a guarantee that at least                                 every team has the same type of                                 character the say let me put it this way                                 the same consistency of types there will                                 still be differences but there will be                                 rather minimal                                 you will never get all the sensors all                                 healers this way there's just a                                 heuristic I'm not saying this is the                                 best one but this is one that's good                                 enough that would fit our streaming                                 situation the thing that actually                                 becomes more tricky is then to say we                                 know to map the skill into a bucket we                                 know how to map the cube bucket into a                                 team and from there on we can play a                                 video game the hard part is really how                                 do you have a team fight and then have                                 everything update the blunt approach                                 would be to say instead of so before we                                 had a two dimensional distribution of                                 two histograms we can all say if ten                                 people plays just a                                                distribution and you have to be very                                 consistent updating but then                                 mathematically you'll still be                                 equivalent the problem though is is                                 supposed to histograms for the skill is                                                                                                         of                                    basically your computer's going to say                                 no we also think we could also instead                                 say hey let's cheat a bit let's say we                                 say this is a player and this is the                                 team of opponents we can also just say                                 let's summarize that somehow a little                                 term that we could do is we can have                                 some                                 sort of data scientists apply heavy maps                                 for some sort of consistent update rule                                 downside of this you may need to find a                                 guy who has a sort of PhD in mass that's                                 mathematical complexity and that leads                                 to sort of some sort of maintenance risk                                 if you think about it so we figured                                 trying out heuristics might be the best                                 solution and you know just for the top                                 of the head you can come up with a few                                 the averaging is something I just                                 mentioned so let's say gold Dan is                                 battling this team you can say take all                                 these skills map them together some sort                                 of average and then pretend it's a one                                 versus one game again alternatively you                                 can also say instead of mapping it back                                 into the sort of an average skill you                                 can also remind yourself the q bucket                                 you were in and just say that sort of a                                 uniform skill level and just apply that                                 another thing you could even do is you                                 could say look at every one from this if                                 this team beat that team then we're at                                 least very sure all the players in this                                 team are better than the worst player                                 from that team and this team then loses                                 that we know all of these players are                                 worse than the best person from this                                 team I hope you understand is all these                                 things are yer istic so they're not                                 really giving us a guarantee but these                                 are things we could try out and we could                                 work with to deal with the numerical                                 complexity and all these things should                                 also still work in something of a                                 streaming framework this is kind of the                                 total architecture that were then left                                 with and all the solutions I just                                 mentioned how to go from a skill to a                                 sort of a cube bucket how to go from a                                 cube bucket to some sort of team                                 assignment and how to go from a team                                 assignment to how to update the priors                                 these are all things that still allow us                                 to do things in the streaming setting                                 you can even consider we we are able to                                 sort of play around because there's some                                 degrees of freedom we will now go more                                 to the realm of application which I will                                 gladly give to my colleague Foca Thank                                 You Vincent                                 this is working yeah perfect                                 so that was the data science loan let's                                 go to the to the engineering part                                 everything was written in a Jupiter                                 notebook for the prototype into testing                                 heuristics but I like writing but I love                                 Scala and also flink so that was a great                                 match so we decided to transform the                                 algorithm into flink so we have to think                                 of all the steps that are necessary to                                 build this architecture onto flink                                 the nice thing is about language you can                                 do all these these individual function                                 so for example a map a window and can                                 just test them individually so that's                                 you know so you have to add                                 to tell this individual part you can                                 test themselves you are sure that they                                 work properly when we won the algorithm                                 as you might have seen in the previous                                 slide notes a lot of hydrophobic                                 parameter that you can tune yeah we                                 started with some some basic parameters                                 from and prototyping that we before                                 before but we want to tune this this                                 parameter is also in the real                                 application on top of link yeah might                                 need some some great search first so but                                 it's not necessarily be a bad thing that                                 it has a lot of parama parametres                                 because we go also tune it to get like a                                 behavior that we like yeah and if you                                 can scale this now we can get more                                 people playing the game and this easier                                 with fling and then with all the                                 frameworks so let's talk fling let's see                                 how we did it so we wrote a function                                 that generates like random players                                 players they're applying for the cube                                 next we have we see them as Jason then                                 we be deserialize them so we get a case                                 object next step is to sample the skill                                 distribution so if you have like a skill                                 distribution of this player in the state                                 then we use that skill distribution                                 otherwise you just start with a with a                                 with effort skill distribution so with a                                 high uncertainty so the player will just                                 play against efforts players next step                                 is to do the window function so we get                                                                                                          length window so when they're                                            will go to the next part of the of the                                 pipeline and it will a simulated game                                 after that we have to split the game                                 again into individual users so we can do                                 this mapping from the average of the                                 team to an individual player and that's                                 also hashed to the curable state that we                                 leveraged from link so all the state is                                 stored in flink                                 in the description you might have read                                 that we also want to use select                                 elasticsearch for this but when I looked                                 at this link yeah we didn't need it and                                 I think it's very nice feature                                 so we read the menu state from flink so                                 all these states inside a fling the nice                                 thing is that is charted by key so at                                 the point that you get more players on                                 your system you can scale up the Kerbal                                 state apart and increase it parallelism                                 and it will also increase the capacity                                 and involves like like storage space but                                 also in computational power it allows us                                 if you say I want to have more more                                 State I want to divide the key space                                 into a smaller part so I can encompass                                 more players and fling takes care of                                 this it will redistribute the key space                                 according to and increase the number of                                 executors it allows you to snapshot the                                 whole system so you can take snapshots                                 and you can save the snapshot so if your                                 system crashes or whatever then you can                                 I want to launch an updated version of                                 the application you can use the snapshot                                 to start from again and the nice thing                                 is that it eliminates external                                 components so if you snaps your bit you                                 don't have to take care of like external                                 state that is there and you can just                                 have a nice exactly one semantics as as                                 fling provides them so this is the code                                 this is the stream that we have so first                                 we decode the player let me take the                                 player skill we sample it from the state                                 that's stored in the curable state of                                 EarthLink then we take the key of the                                 bucket so we have a notebook you see                                 she's also in games like if the bronze                                 League the silver league the gold League                                 and you can distribute the by bucket                                 then we wait for the appropriate number                                 of players then we determine the team so                                 it is the newer stick that Simpson                                 talked about dying and getting a                                 balanced team then we visualize the game                                 over here simulated of course we're not                                 Blizzard so we can not do it in real                                 life so we and we do he played a game                                 then we split this game again to date at                                 the player state he hatched by the                                 player ID so we do the key by                                 so we get to the appropriate                                 but whether in the state besides then we                                 fault the new state into the old state                                 so we take all stage we we make this                                 two-dimensional matrix and then we                                 negative are great the waiter and the                                 master is a according if the player lost                                 of one and then we updated state so yeah                                 there's a bit more computational                                 complexity part so we have to make this                                 matrix in memory let's do a small demo                                 let's see if it works                                 bit small but I will explain it what I                                 will do I will change the one of the                                 configurations right now I have it in                                   player mode and I will put it into                                   versus                                                                 new jar of it                                 it's a said yards or the epen design                                 there and then it's really small then I                                 run the new the new version in the                                 background so we because he was the                                 outcome of it later so but said start                                 running so we simulate the games                                 so let's get first to the notebook that                                 this is the one that used for debugging                                 all the statistics of the of the                                 computation that are done are being done                                 to the filesystem for us it's a nice                                 using a Jupiter notebook you can easily                                 debug the the game so we can see what's                                 going on with the new numericals this is                                 important otherwise you're just looking                                 at at the black box you don't know                                 what's going on if the if the                                 computation are being done correctly or                                 maybe there's a numeral numerical                                 imbalance so that's really important if                                 you look to this nice so if you look at                                 it for said for example at this graph on                                 the left hand side we see like the                                 really bad players and on the right hand                                 side we see like the really good players                                 the x-axis is the number of games played                                 so on the left is the first game and on                                 the right it's the it's the the                                          because we only take their first                                        first hundred sorry                                 and then we see like this distribution                                 that's in begin it's a bit blue and then                                 it converges to like the solid yellow                                 line and it means like the scalar the                                 skill of the player is converging into                                 the game so now we see also the the                                   versus                                                                  like the notebook then we can also see                                 like with                                                              worse and mainly this is the problem is                                 that if you have like a team of five                                 players for them are really good and one                                 is really bad then it's it averages out                                 and that's the problem with conversions                                 of course                                 so there's a bit more bit bigger if we                                 see it a bit better so we see like all                                 the players in a phone first one game it                                 converts really good you go to a to                                 first do we see some more jitter but                                 still we see like it works quite well                                 and if you don't go to the five versus                                 five then it really starts to have a lot                                 of noise in there                                 so this is most probably because like                                 too bad players get into a keen with                                 good players or not sort of liked it a                                 workflow so this is one of the lessons                                 learned that we that we had during this                                 exercise                                 so using Jupiter notebook we can do like                                 aggregations you can do nice bloating                                 you can summarize data it's really nice                                 way to have to debug the the numerical                                 system first you want to use elastic                                 search in Cabana because it's also the                                 or store for the external state but                                 using the fling stairs shared state it's                                 not necessary anymore                                 and without visualisation is really hard                                 to debug this this thing especially when                                 you're in a distributed environment yeah                                 also we had one other book so if you can                                 imagine if the dispute gets really                                 really sharp then it can happen that one                                 of the buckets they go to                                               limit so we have to add some smoothing                                 parameter because of one of the book is                                 goes to zero it means that is moss is                                 getting away but because it's zero and                                 if you multiply by zero to always get                                 there also you need to add some some                                 smoothing there so this is a smoothing                                 parameter that we tried and if you take                                 a really small one you see everything                                 reverses ok if you make it a bit bigger                                 and it has a bigger problem with with                                 converging and if you make it too big                                 then just unfortunate it's been able to                                 estimate the skill of the player so this                                 is something that you might want to try                                 out before moving into into flink and                                 just do some simulation inside of                                 Jupiter                                 so yeah discerned this tuning of the how                                 what I just said like if you                                 multitudinous parametres just really                                 nice to do it interpreter instead of on                                 flank otherwise you're just looking at                                 this is a bit of black hole and also                                 another problem that we had and we first                                 thought it was like a numerical problem                                 but it turned out it was part of the way                                 of link                                                               simulator and we didn't trouble it so it                                 was like pushing out tons of users and                                 the mapping of the skill is not that                                 hard so it would go further on and the                                 Birkett mapping is also computationally                                 not really complex team assignor is also                                 yes simple heuristics but after the game                                 has been played you want to make this                                 two-dimensional matrix and that is                                 really a computational intensive so what                                 we had is for one game for one player                                 that was playing a game it would also go                                 into the queue again and then would                                 sample like an old state and this is                                 something that you in real life never                                 would encounter because yeah if you're                                 one player you only play one game at a                                 time he will not do games in parallel                                 otherwise maybe if you're really good                                 you can do that but most people just                                 play one game at a time so the same                                 player was multiple times inside of the                                 of the of the pipeline and that caused                                 some problems because then a display was                                 sampling all state and state was updated                                 with all state so it was a problem we                                 saw a we solve it by adding some                                 throttling to the to the source function                                 yeah civilization I cannot stress enough                                 it's really important to debug this and                                 also if you have like that many                                 hyperparameters or heuristics you really                                 want to make sure that they work well                                 otherwise you will be maybe looking at                                 the wrong problem and what helps for us                                 is just starting first one first one and                                 make NIC making that problem more                                 complex in steps they add a final result                                 yeah B I think it will work I do a                                                                                                           tuning and also because it's just                                 simulating we don't we're going to have                                 a real data it's a bit of a it's a bit                                 of a trying out and also what's really                                 important is they are not served them                                 many algorithmic people in the room but                                 it's also a bit of a scheduling problem                                 so you have a player able to sample the                                 skill of it and get him to play as soon                                 as possible what's also a bit of a soft                                 side in here like an unperfect game you                                 want to have like if you play this game                                 you want to equally lose and win because                                 then you are playing a nice game                                 otherwise if you win away it's not fun                                 and I'm saying if you lose always it's                                 always you get a bit bored of the game                                 and then you just uninstall it but you                                 also don't want to wait very long until                                 we have like yeah really nicely matched                                 a set of of people who you can play with                                 so this is a bit of a software trade-off                                 that you want to take into account our                                 conclusion to recap a bit yeah the                                 numerix it's a if you have for example                                 some two distributions who are really                                 applied you get the strange results                                 because of the way of how we normalize I                                 really like the distributor status link                                 it really helps you to have everything                                 in within to one place and it's a works                                 very well with updating and really                                 elegant of following the the new state                                 into the                                 into this whole state so you always have                                 like a big memory footprint and it's                                 quite nice and that last one that we                                 won't say if you want to do some beijing                                 stuff or no merit complex stuff first                                 make sure that it works into a simple                                 setting so again if you implement it on                                 the top of a distributed system it is a                                 that you sure that it works at properly                                 and you also can unit test against like                                 the stuff that you developed in the in                                 the prototype that's it thank you for                                 listening hope you enjoyed it thank you                                 we have time for questions I'll start it                                 this way so why have you not already                                 done this on real data like oh so the                                 just like with the Pokemon I would first                                 want to simulate and test that the                                 algorithm works right and then I can                                 apply it to Pokemon I already downloaded                                 so there's this guy who has a website                                 called hot slogs and you can sort of                                 apply that on some of the game logs of                                 actual data the focus main interest in                                 this hobby project was applying the some                                 of the flink internals and sort of doing                                 more stuff with that my main hobby                                 project sort of goal here was more to                                 see if you can have a machine learning                                 model the updates point by point and I                                 do think the use case that we have here                                 in terms for video games you kind of                                 like a very nice use case where you can                                 demonstrate that this idea of actually                                 having a machine learning model learn                                 data point per data point but that                                 generally could work so that was more                                 our interest if this out so we still                                 through some ID parameter tweaking after                                 that you just take the log file string                                 through it and then you could say this                                 player might be better than that player                                 but you didn't actually do it on the                                 data yet so we haven't done that yet                                 mainly because we we didn't foresee that                                 our team assignment heuristics would                                 actually cause so much surgery okay                                 there is also a solution for that which                                 is probably what we're going to iterate                                 on probably this Friday but yeah that's                                 the main reason in a hijack this one                                 more question                                 do you have any idea what the matching                                 algorithms are at the moment in Blizzard                                 or for overwatch or so I have talked at                                 like conferences like very gently to                                 some of these game developer people the                                 so I have not met a Blizzard person                                 that's because I live in Europe but I                                 have to talk to some more of the mobile                                 game developer peoples and they the main                                 thing in the end if you want to do like                                 the super simple way like we're using a                                 lot of master machine learning if you're                                 just like an engineering company you can                                 also consider what fifa does like hey                                 just have these leagues and if you win a                                 lot within a league you move up one and                                 with a bunch of heuristics that might                                  just go ahead and work and if that                                  already works then why change the                                  winning team so that's more the practice                                  that I hear of again my interest was the                                  Bayesian updating so when running your                                  simulations or even interpreting your                                  result data would it be possible to                                  distinguish between layer skill and                                  character balance for example given that                                  our heroes of the storm it's somewhat of                                  a rock paper scissor so the way we sort                                  of solve that is by using the Aristocats                                  says let just make sure there's as many                                  assassins roughly in each game as many                                  tanks and as many healers and obviously                                  that doesn't necessarily hold always now                                  there's also streaming way to hear that                                  but that wouldn't fit this talk the idea                                  would be you can't so we can't take all                                  combinations of possible characters                                  across each team and that we could                                  probably calculate a score for that but                                  just way too many combinations we'd have                                  to consider what alternatively you could                                  do is you could say hey let's take two                                  players from this team two players from                                  that team and calculate the probability                                  that cinereous and Raynor versus another                                  murder in any other what the probability                                  is of one team winning versus the other                                  do that for all characters yet still                                  iterate quite a bit but that's stuff you                                  can handle in memory so that will be a                                  better EurAsEC                                  but it was not as easy to implement and                                  I think the main issue we have is more                                  with how do we summarize a team                                  statistic okay and then the the main use                                  case would be matchmaking instead of                                  balancing the character for example well                                  it's a bit of both right and it's kind                                  of this slide it is up to you I guess to                                  figure out if it's more important that                                  games are balanced or if people should                                  wait in line longer my my former boss                                  that                                  was reviewing the slides he was actually                                  saying that we were doing stuff kind of                                  crazily because obviously the waiting                                  time is the only thing that matters                                  however I actually feel that the game                                  bounds actually the thing is going to                                  get you to stop playing the game instead                                  so it depends on what you feel is more                                  important but this is something you do                                  by high parameter tuning looking at the                                  plots and I personally feel that the                                  only way to properly do this is not with                                  Cubana you need to make your own custom                                  plots the downside of this Bayesian sort                                  of rhetoric is that you do get into this                                  numerical territory it can get nasty                                  cool other questions you can also ask us                                  anything near the food yes that'll be                                  fine cool thanks for listening I guess                                  thank you fo yeah thank you                                  [Applause]
YouTube URL: https://www.youtube.com/watch?v=1--5mIYyB9s


