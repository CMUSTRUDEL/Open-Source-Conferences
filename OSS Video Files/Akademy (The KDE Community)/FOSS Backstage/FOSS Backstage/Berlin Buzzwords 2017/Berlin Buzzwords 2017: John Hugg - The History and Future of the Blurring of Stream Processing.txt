Title: Berlin Buzzwords 2017: John Hugg - The History and Future of the Blurring of Stream Processing
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	John Hugg talking about "The History and Future of the Blurring of Stream Processing & OLTP".

There has been so much noise surrounding advances in analytical systems lately that Online Transaction Processing (OLTP) problems may seem a bit overshadowed. Big data, streaming analytics, machine learning, and even deep learning have all changed the way businesses are run and problems are solved. Meanwhile, problems that require low latency, high write throughput and some consistency guarantees haven’t gone away.

Two of the biggest "new" ideas for operational workloads are:
1) Command Query Responsibility Segregation suggests splitting operations into parallel streams of queries and modifications.
2) System like Samza and Kafka Streams propose flipping the persistence mechanism around, using logs to store events and maintaining materializations on top of the logs. This idea is best introduced here.

While these approaches blur the line between stream processing and traditional operational databases, the fuzziness is coming to even the most stodgy systems. We now speak of "events" more than "transactions", even if the transaction hasn’t gone away. Systems are becoming more parallel and more and more asynchronous.

This talk will do something a little weird: compare streaming systems like Kafka, Flink, DataFlow, and Kinesis with traditional databases, like Postgres and Oracle, or newfangled databases like Cloud Spanner, HBase, MySQL Galera Cluster, or VoltDB. It’s going to be fun.

Read more:
https://2017.berlinbuzzwords.de/17/session/history-and-future-blurring-stream-processing-oltp

About John Hugg:
https://2017.berlinbuzzwords.de/users/john-hugg

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              thanks everybody so I'm John hug and I'm                               from bowl TV I'm going to try and                               squeeze a lot of content into                                          here so there's a lot of things I'm                               going to kind of gloss over but if you                               want to reach out to me later I'm here                               at the conference for us the conference                               you can email me reach me offline                               I love to go down rat holes and talk in                                depth about some of the stuff I love it                                when people tell me I'm wrong because                                that's how I learned so I'm going to                                start off with an example                                operational app and this is my                                Beetlejuice app the minimum viable                                product for the Beetlejuice app is I've                                got some Alexa serious device in my                                house it's a microphone that's always                                listening to me because it's not creepy                                it sends discernable words to my servers                                and if it hears the word Beetlejuice                                three times it plays sound clips for the                                movie that's sort of the idea of the                                movie is you call Beetlejuice by saying                                its name three times pretty classic                                horror movie trope so we're going to                                build that as an app and this is an                                operational app and we're talking about                                stream processing oil PTP in the context                                of these operational apps it's a little                                bit different than like a word count or                                something like that because there's                                there's an action I need to do something                                I need to do something in response I                                need to send a message back and play a                                sound clip and that's immediate so that                                separates out some stream processing                                apps that may not look like a low TV                                apps so the first thing everyone should                                do is just use Postgres right this is                                advice that people started giving in                                response to all of the no sequels stream                                processing there's a hundred different                                data processing frameworks and this is                                often a really good idea if you don't                                know where to start just use Postgres or                                my sequel or some other technology                                that's been beat on for twenty years and                                there's an incredible wealth of                                knowledge and tooling around it is not a                                bad idea so but how does this look so                                I've got some dumbest client they do one                                of these microphones in my bathroom and                                I send audio to some rich client logic                                in my data center there's a little bit                                of contrast lost here there's a box                                around this but and the rich client                                logic is going to do some speech-to-text                                any time it sees the word beetlejuice                                it's going to add a record into Postgres                                it's going to count how many times have                                I said Beetlejuice maybe it's three it's                                going to record that it's going to take                                an                                action reset the count and then it's                                going to send a message back to my                                speaker to play some clip from the movie                                so there's a presumably some table that                                you guys can all imagine this is what it                                looks like it's a fairly straightforward                                very traditional way of solving this                                problem if I'm looking at it from a                                streaming perspective let's just say                                what if I wanted to build this app with                                storm now you shouldn't use storm for                                new apps this is my opinion it's really                                there's so many better options than                                storm I'm picking storm because there's                                nothing really tricky to it it's kind of                                exemplars a stream processing framework                                you could insert many different kinds of                                things for storm in this example and you                                probably should again I'm losing                                contrast on the projector but that's a                                nice spark logo over there so so storm                                looks a lot like the Postgres app except                                some of the nice things I don't have                                that rich you that rich user code                                running somewhere else in my data center                                I can move that code into the processing                                framework but what I what I have also is                                I probably got a bunch of different                                storms running together but really I've                                got audio sent here storm might emit to                                play a sound once in a while if it says                                I've got three and I've got counts for                                my users maybe they're partitioned                                across all the storm nodes so the big                                difference when you're looking at                                 architectures when things are hunky-dory                                 when everything is working well then                                 really there are a lot of different                                 architectures that could work a lot of                                 different fun things you could try but                                 building for when the unexpected happens                                 is where maybe the different choices you                                 make can really be either inexpensive or                                 expensive                                 so when Postgres what are the different                                 ways this app can fail certainly                                 Postgres can go down and that's that's                                 either software or hardware my app is                                 going to become unavailable but I could                                 also have problems like I could lose a                                 network message right it's a really                                 common problem that happens that people                                 don't necessarily account for where                                 maybe I said Beetlejuice three times and                                 it sent a message back to play us down                                 but that message got lost and it resets                                 account and now I have to say                                 Beetlejuice                                                          that's another way that this kind of                                 thing can fail in storm it's not really                                 that different                                 certainly a storm note can fail and I'm                                 going to lose                                 I'm going to lose maybe some Beetlejuice                                 counts humming there I might have to say                                 Beetlejuice                                                          message that goes back to the the                                 microphone on the speaker I could have                                 to say Beetlejuice                                                     of storm and some of these things that                                 are distributed this is goes for                                 streaming or databases is that I can                                 probably fail over to another storm note                                 so the general availability my app                                 doesn't go down just because a node                                 failed some other things that are                                 important to think about that I'm going                                 to kind of gloss over because I don't                                 have                                                                    item Potence with at least ones delivery                                 that is I can have my clients send the                                 thing over and over until it's confirmed                                 to get exactly once processing that                                 helps me get that exactly I want to                                 count Beetlejuice three times and then                                 other things you can think it's side                                 effects ruin everything what's a side                                 effect so playing the sound on a speaker                                 is not a transaction it's not something                                 I have control over if the speaker wire                                 is cut and I tell it to play a sound and                                 it thinks to play a sound but it didn't                                 that's not anything I have control over                                 so I consider that a side effect and                                 good examples these are when you send an                                 SMS message or you make a RESTful API                                 call if those things fail it's very hard                                 you basically have to pick I want to                                 guarantee someone sees this maybe                                 they'll see it more than once or I want                                 to make sure that not someone no one                                 ever sees this twice which means maybe                                 they won't see it but with side effects                                 I don't have control I can just sort of                                 build it as robustly as I can so can I                                 just sprinkle some Kafka on this and                                 make these problems go away                                 so in the Postgres example and it looks                                 similar for the storm example and this                                 is you know more and more common I can                                 put Kafka here in terms of how this                                 helps failure it does get me some some                                 better back pressure it gets me a little                                 bit some some robustness for failure in                                 some ways but it doesn't fundamentally                                 change things it doesn't fundamentally                                 change how I handle side effect it                                 doesn't fundamentally change what                                 happens when Postgres goes down for an                                 extended period of time the reasons I                                 want to do this are largely not related                                 to failure or things there's a lot of                                 good reasons I've got a slide coming up                                 on why you would do this but one of the                                 things is if I look at this operational                                 app again this is not some bulk                                 analytics app streaming and databases                                 have a lot in common right if I want to                                 ensure delivery the original source                                 has to be prepared to send it more than                                 once whether I do streaming or databases                                 that's true if I want to get exactly one                                 semantics I have to build an idempotent                                 operations it could be a little sub talk                                 there but that that's true in both cases                                 I can't guarantee that a side-effect                                 happens exactly one so do your best and                                 that systems that are flexible safe and                                 accurate are really really hard to do                                 doesn't matter what you put you what                                 architecture you choose these things are                                 hard that's why we get paid well so what                                 makes a hard app obviously scale                                 complexity these are things that                                 everyone sort of jumps to immediately                                 velocity requirements changes is                                 something that you know if you've done                                 product management that's something that                                 can make an app hard some of the things                                 that really matter for an operational                                 app precision right if I want to do                                 something exactly three times that's                                 much much harder than about three times                                 and how important exactly three times is                                 to my app how much I'm willing to                                 engineer to make sure that it's exactly                                 three can make the app either not that                                 hard or really hard chaining precise                                 conditions in action so when something                                 happens three times do something else                                 that makes things hard and                                 non-commutative math so if you have math                                 like addition and things that's great                                 aggregation some of those things but if                                 you have math that doesn't commute where                                 if the ops come in different orders you                                 get a different result that can be                                 tricky side effects as I mentioned and                                 then partial control is a really common                                 one I run into when I'm helping our                                 customers where they don't control all                                 of their app maybe there's two different                                 groups that are working maybe it's an                                 OEM and a cut and their customer but                                 that makes absolute harder so why today                                 in                                                                       other for your operational app right                                 streaming and logging and I've got a                                 little cocktail logo up there because                                 sort of defines the logging space in a                                 lot of ways these days though there's                                 more options than copy up Acosta's nice                                 one of the my favorite things is you can                                 easily tea that is you can split two                                 identical streams into your production                                 and your development production and your                                 pre-production or even a/b testing data                                 right you can you can take the stream                                 and run it in a bunch of different ways                                 and that makes developing the next                                 version of your app a whole lot easier I                                 often get really much simpler clients                                 when I've got streaming and logging                                 because I move more of that processing                                 into the system itself I don't have a                                 separate standalone client it's often                                 easier to understand performance                                 characteristics I've got more of a                                 queuing                                                                 a well what's the contention and                                 shared-memory mess inside Postgres by                                 replaying a log stream later I can do                                 back testing like what did this have                                 worked better in that situation oh no                                 this is I've got some bad data here can                                 I roll back to right before that                                 happened that's really nice although you                                 need truncating snapshots which is a                                 whole nother rathole you can sometimes                                 make multi data center stuff easier                                 sometimes replicating a log is easier                                 than replicating mutating State in like                                 a Postgres or my sequel horizontal                                 scalability and fault-tolerance can be                                 easier although there are a lot of                                 databases now that also do that kind of                                 stuff so why would you use a database                                 and these are also definitely subsets                                 right there's a lot of reasons these are                                 just some of the ones that came to my                                 mind when you're using a stream you have                                 to figure out some way to truncate the                                 stream or you have to keep the stream                                 forever                                 right so a lot of times that's like a                                 per app kind of snapshot and that's one                                 of the complexities that trips up a lot                                 of people databases you can query off                                 the bat right if you've got your                                 operational app you can build in                                 periodic reporting period of queries you                                 have to be careful if that doesn't                                 impact your operational workloads but if                                 it's something that you're doing                                 routinely you can build that into your                                 capacity planning and you can do a lot                                 of really cool stuff that that is hard                                 to do with streaming especially in                                 development when you can just write                                 sequel queries or whatever the database                                 uses to understand what's going on and                                 then you've got this great database                                 stuff that we've built up over the years                                 like secondary indexes materialized                                 views constraints joins foreign keys and                                 depending on the system some of them                                 have more or less of that stuff but you                                 get a lot of really mature tooling                                 around databases and one of the nice                                 things about them is that you typically                                 they're more appropriate for apps that                                 require lower latency because a lot more                                 of these used like an RPC model where I                                 make a call and then get a response more                                 directly if I have things where I need                                 to make decisions in milliseconds these                                 are often a better fit caveats to                                 everything but those are sort of my                                 summary slides on those                                 so why can't I just use a streaming                                 system and a DB together and you can and                                 lots of people do depending on your app                                 your problem what you're trying to do a                                 lot of people have a lot of success with                                 this                                 there is the big catch with this is that                                 more integration points means there's                                 more ways that things can fail and the                                 integration point between say storm and                                 Cassandra or storm and Redis is one of                                 the more tricky things to get right than                                 a lot of other systems and same thing if                                 you're going to use you know storm and                                 Postgres or Kostka clients and Postgres                                 or whatever you're going to use that                                 integration point is tricky but you                                 should want this right like you should                                 want the benefits of both all the things                                 I put on those little slide on those                                 last two slides I want all of that in my                                 operational apps I don't want to have to                                 choose so we get in a little bit of the                                 blurring parts here ad database notes to                                 streaming systems all right this is one                                 way we can do sort of the blurring so if                                 I've got this storm app this sort of                                 glue code as I mentioned between the                                 state and the user code storm totally                                 punts on this a lot of other streaming                                 systems have much better support for how                                 you manage this kind of state but few of                                 them are really databases right they                                 don't have all the features I had on the                                 other slide they have things like                                 aggregation support and they're really                                 good counters I'm doing them a                                 disservice by saying that but they're                                 not they're not Postgres they're not                                 amateur sequel relational database or                                 even amateur and a different data model                                 database so one of the interesting                                 products that's out now that's sort of a                                 new product last year or so is this                                 Kafka streams thing from the confluent                                 people and there's a bunch of confluent                                 people here so you can ask them                                 questions I'm sure they know more about                                 this than I do but you can take your                                 client logic into a Kafka log and the                                 Kafka streams library it's a library you                                 put your client that manages how this                                 log gets turned into tabular database II                                 kind of data according to your user code                                 and so it basically makes that glue code                                 between data and streaming much much                                 much much less fragile and then you can                                 emit into a Kafka log or two                                 Kafka logs into downstreams consumers                                 and it's really I think taking streaming                                 systems and moving them into how we add                                 data business to that in a safer way                                 it's really early days for this product                                 there's a lot of things it doesn't do                                 yet there's a lot of other systems like                                 I said that have ways of integrating                                 state with streams maybe I don't think                                 any of them are as ambitious as this                                 project but you know come talk to me                                 tell me I'm wrong so this is sort of                                 what I'm interested in make a database                                 that's a lot more streaming how do we                                 get the benefits of the database if we                                 have a benefits of stream processing                                 when we're building a database so one of                                 the things we can do is we can put                                 processing in the database I've got a                                 rich client logic and a lot of RPC calls                                 if I put my user logic in stored                                 procedures then I've got a lot fewer our                                 PC calls I've got some per client logic                                 all right everyone says yeah but stored                                 procedures are miserable and that is                                 well deserved                                 so some of the things we can do to make                                 this better beyond sort of Postgres or                                 Oracle or whatever store procedures                                 you've been forced to suffer through we                                 need better tools for managing user code                                 in the database we need better tools for                                 debugging user code in the database                                 right when printf is even doesn't even                                 work that well we need better monitoring                                 and transparency for user code running                                 in the database what is my code doing                                 how long does it take and I sample it                                 these are the kinds of things that that                                 we can get a little bit of in stream                                 processing some systems are better than                                 others we can put this in a database                                 it's just a technical challenge it's not                                 because there's some fundamental reason                                 we can't the other thing we can do is                                 you got Postgres and they've got to                                 write a head log and this has been                                 standard in the industry for a bazillion                                 years right I can take that right ahead                                 log put it in front and I can create an                                 opera or a logical log which looks a                                 little bit like sticking Kafka in front                                 of Postgres and in fact I could build                                 this with Kafka and Postgres and glue                                 code but there's no reason I can't                                 integrate this into my database I can                                 make this a part of my perfect database                                 right and so this lets me do a lot of                                 the things like teeing going to a point                                 in time there's replicating between data                                 centers using a logical a priori log                                 there's a lot of benefits there's some                                 trade-offs and downsides and if you want                                 to know about those come talk to me                                 the the post yari log which I probably                                 can't pronounce it's sort of the same                                 idea                                 I want my database to be able to admit                                 events I don't want to have to query my                                 database and say hey does anything                                 change I want in my stored procedure                                 logic to be able to say hey this event                                 happened you said Beetlejuice three                                 times push an event out into my log and                                 if I've got this a posterior log a                                 downstream consumer one of the things I                                 can do is if I don't want to I can                                 de-emphasize sort of the RPC responses                                 and I can actually consume the event                                 from the client logic so I can use this                                 in a more streaming kind of way where                                 I've got the priority log and the                                 posterior log everything moving through                                 but I've got a database in the middle                                 obviously I can horizontally partition                                 the database a lot of databases do this                                 now I'm not going to go in a lot of                                 depth about this but you sort of pick a                                 partition key but when you do this you                                 want to throw out the the bathwater and                                 keep the baby right so I've got now a                                 whole bunch of databases but I need to                                 present as a single managed entity I                                 want global stats I want global reads                                 without extra work I want it to be a                                 database even though it's got all this                                 other stuff in it and and this is                                 something that I've learned a lot                                 working at both TB excuse me working at                                 vole TV is I want RPC why do I want that                                 this RPC model where a client can call                                 the database and get an immediate                                 response because we work with a lot of                                 apps where latency matters and that                                 ability to to respond directly from the                                 stored procedure says accept this call                                 this transaction is fraudulent here's                                 what to show the user on the next page                                 allows us to build these real-time                                 operational apps that are really cool ah                                 so where is this going                                 I'll say here this is sort of where I                                 plug what I'm doing we're building a lot                                 of this at full TV this is a lot of the                                 ideas that sort of things that we are                                 inspired by that we want to make a                                 better product so we've got a                                 horizontally partition database that                                 acts as a single system                                 we've got per partitioned ordered input                                 and output right all based on an opera                                 or a logical log just like we showed in                                 the last couple slides we have                                 debuggable Java stored procedures you                                 could fire up IntelliJ or Eclipse and                                 step through your code we've got all                                 kinds                                 stats about how long things are taking                                 you can use third-party libraries we                                 have the ability to emit events from                                 those stored procedures that get put                                 into a a posteriori log so then you can                                 consume them from some downstream system                                 and we've got all the database stuff I                                 won't say all we don't do as much as                                 Postgres but we've got a lot of the                                 database stuff that people wants like                                 secondary indexes ranking indexes views                                 when doing functions transactions all                                 that kind of stuff that you want out of                                 a database but my conclusion here is                                 I'll say we're working a lot of this                                 stuff at volts I know                                 confluence working on this there's ten                                 other companies that are working on                                 stuff sort of merging these kinds of                                 things none of these systems volt                                 included is going to solve every problem                                 it's going to be mature enough a lot of                                 this is not it's not that we can't it's                                 that we haven't yet so I think there's a                                 lot of opportunity I've got like my                                 prospector here there's a lot of                                 opportunity to build systems that don't                                 have to compromise for operations we're                                 engineers there's always trade-offs                                 we're always making compromises but we                                 can get a lot of the benefits of stream                                 processing databases in a more                                 integrated way we're really good at a                                 lot of these things log stream State                                 individually but but better integration                                 is a really valuable thing for for                                 operations and I've got a whole separate                                 talk that explains why operations is                                 different than a lot of the analytics                                 and batch processing where the the UNIX                                 philosophy of get one small tools that                                 do things well and put them together                                 turns out to be something of a nightmare                                 for operations you really want the                                 smaller number of tools to monitor as                                 you can                                 so go out you know if bolt works for you                                 if Kafka streams work for you if link                                 and beam and all these cool things that                                 are out there works that's great                                 make them better build new things I                                 think that this is where we're going so                                 that's it thank you very much you could                                 reach out to me I'm here next two days                                 thanks guys                                 thank you for the talk are there any                                 questions                                 all questions oh thanks - it's a super                                 interesting talk um so you you could                                 obviously see that this is coming from a                                 database adding more more streaming                                 stuff that's where I'm coming from I try                                 to see both perspectives like but yes                                 yeah so I'm coming from the side I'm one                                 of the things people that comes on the                                 side of building the stream processor                                 and making it more data they see oh yeah                                 yeah and I found this comparison                                 fascinating ways that they up a priori                                 log and then the processing and then the                                 a posteriori whatever how to pronounce                                 log yeah I can't say that word event so                                 that the interesting thing that we kind                                 of observed is the the logic that in                                 that case post crews would maintain if                                 you really you know everything goes to                                 that lock you have partition ordering                                 everything and so on is you basically                                 throw out most of the hard transactional                                 logic right because you have you have                                 per partition ordered you you kind of                                 have a partition single right or model                                 almost yeah thing like that and so on so                                 how much of that actually really remains                                 because if if you actually simplify that                                 transactional model to too much of that                                 and then you know yet the ability to                                 look and some into something like that                                 that's kind of what we how we built                                 fling link today I would say it's almost                                 that model actually and that that's                                 question number one and let me get back                                 the mic and come okay no matter I think                                 that um I think that it really depends                                 on the app that you're targeting and and                                 also certainly on the mindset of the                                 person who or the team that's looking at                                 solutions for these kinds of things we                                 see a lot of people who are really big                                 into transactions because some of the                                 things they're mixing is a lot of                                 different access to the same system not                                 everything comes in the front door                                 through like a Kafka ingestion into                                 Volpe B there's a mix of maybe I've got                                 one client that's pushing an event                                 stream through from from                                 telecommunications but I've got other                                 clients that are pushing monitoring                                 streams                                 I've got other clients that are that are                                 making updating black lifts tables and                                 things and having that transactional                                 model of I can say that this is time T                                 whatever                                 and that before this here all the events                                 that came in and after all the events                                 that came in but it's not necessarily                                 like everything gets shoved through a                                 pipeline you know in our system I think                                 that in some in you'd certainly I think                                 it's interesting to think about in terms                                 of a if you do shove everything's run to                                 where can you get rid of a lot of the                                 transaction stuff I think in many                                 situations yes it's a satisfying answer                                 yeah that's one of the places where I                                 think we're interested in going more and                                 and you know I say we're not for                                 everybody in terms of building systems                                 that chain one piece of logic after                                 another that's something that we'd like                                 to get a lot better at and it's not                                 where we've started we might have time                                 for one short question if not you can                                 catch John after this talk                                 just a question on the kind of                                 partitioning that you need to use in a                                 database like this like yeah I                                 understand read transactions is easy                                 because it doesn't really matter whether                                 they come to different partitions but                                 doesn't performance tank if you do write                                 transactions across partitions and                                 doesn't it or where do you see that I                                 mean we began and working through doing                                 a synchronous there that we fire out the                                 thing on Kafka and then re partitioning                                 and saying like let's make it an even                                 potent operation and we lose the                                 transactional thing then but where do                                 you see both DB going with sauce                                 partition transaction so we certainly                                 most of the transactions that we run                                 partition usually that the whatever                                 customer user is doing they've got some                                 big operation that partitions pretty                                 well but they do often want to mix that                                 with global writes and that's one of the                                 things that separates both from some of                                 these systems is we can do transactional                                 global rights and a lot of times we see                                 that is I want to transactionally update                                 a lookup table everywhere at the same                                 logical time across the whole system                                 people want to occasionally there are                                 things where there are less common                                 operations but require transactional                                 changes the one that we don't do a lot                                 of but people you know the canonical                                 example is like a debit credit                                 transaction but we do have a lot of like                                 you know read everywhere for where                                 there's like an open seat or something                                 and then book the seat in one place                                 would be sort of a global transaction                                 even if it only writes in one place                                 there are some other cases where you                                 want to re partition data so you need a                                 transaction that touches two partitions                                 and that's something that having that                                 functionality helps with but there's a                                 lot of research on how to make that                                 faster and how to do that without being                                 less invasive                                 we're trailing a lot of that because                                 we're trying to build a production                                 system but it's something that is going                                 to get easier and easier I think thank                                 you thank you for the talk and if you                                 want to if you have more questions can                                 catch John after the you know in the                                 breaks so yeah thank you                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=GoJYZRKY5io


