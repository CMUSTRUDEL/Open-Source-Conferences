Title: Berlin Buzzwords 2017: Maxim Zaks - Why are we using JSON? #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	When I setup my iPhone to use HTTP proxy and pick on the traffic, I see lot's of JSON going cross the wire. In fact most of the traffic I intercept is encoded as JSON. I should not be surprised, JSON became a standard for data serialisation. But is it a good standard? In my talk I want to challenge your perception of JSON and outline the penalties we willing to accept while using JSON.

Read more:
https://2017.berlinbuzzwords.de/17/session/why-are-we-using-json

About Maxim Zaks:
https://2017.berlinbuzzwords.de/users/maxim-zaks

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              all right thank you                               less technical talk of the conference I                               know you guys are exhausted but I would                               need a little bit more attention from                               you just for next                                                      like to start with three questions first                               question raise your hand please if you                               know Jason okay all of you good then                               please raise your hand if you know math                                not scientific math just math simple                                math you know it's just like okay then                                third question in the next slide I will                                show you a J'son file which contains my                                name and my birthday and I would like                                you after I count to free to tell me how                                old I am                                okay make sense good so three two one                                nobody okay let me help you now three                                two one                                                                                                      name is Maxime Zak's I'm a recovering                                game developer and I would like to talk                                to you about Jason and why are we using                                Jason like those are the three buzz                                words which I will kind of talk about in                                my session its size efficiency and                                random value axis so this is a quite                                cheesy joke right so kind of like I                                showed you like a binary and expected                                that you can actually see and understand                                it but for me drive one point                                human-readable                                is a lie because what makes Jason human                                readable is the text editor and that's                                the thing every developer has a text                                editor every machine has a text editor                                so if we encode something in a textual                                representation then it's kind of human                                readable because we have the tools to                                make it human readable and writeable                                but in reality for the machine this is                                how it looks like this is the whole                                representation and this is completely                                non human readable and if you think                                about it also this text here not really                                human readable if human really readable                                because it is a very simple example but                                as you can see this one is not formatted                                this JSON is minified so if I will                                present you an example which is more a                                real-life example like for example here                                this is a result from word if you calm                                if I will ask for                                                      as you can see here scrolling wise is                                huge and this is not human readable                                anymore the funny fact is even Veloz to                                do code couldn't do a semantic                                highlighting here it just gave up even                                though it's understood it's J'son so to                                make this actually human readable we                                have to format it now it's much nicer                                right it's named birthday year month day                                everything is human readable we can                                actually understand it quite well but                                this means we just bloated up the binary                                representation we added lots of noise                                just to make it human readable but this                                is as well why we use JSON right because                                it's human readable in a way so here we                                are kind of in a clinch with ourselves                                so basically if we if you look at this                                with minified jason is                                                 formatted jason is                                                      real-life example this is in kilobytes                                so I have here hundred and thirteen                                kilobytes and the formatted would be                                almost hundred and eighty kilobytes so                                                                                                        it would be really human readable now                                generally raise your hand if you can if                                you make sure that what                                data that communicates from your servers                                to server a server to client is always                                minified how do you ensure that there is                                no way to ensure it well only way how                                you could ensure it is to say like ok up                                to a certain size of the payload we                                won't accept it because I can send you                                this small object which contains name                                and birthday in gigabytes of data I will                                just fill it up with just basically                                empty space and it will be still a valid                                JSON your parser will parse it it will                                take forever but still it will parse it                                so can we do better and normally if you                                think about it like what is the worst                                thing that we try to communicate with                                this JSON this basically this date and                                the name date is                                                         characters so                                                          see actually I didn't even introduce any                                 delimiter here because I know if the                                 dates are represented you can always                                 represent a dating for eight characters                                 therefore I know                                                     date and then everything there will give                                 a name so there is no need to actually                                 kind of introduce a coma or empty space                                 and so on and so forth and in this case                                 you see like okay for me to JSON                                    minifides                                                                is a huge difference right now can we do                                 better what do you think yes                                 and actually what we can do is just to                                 say like okay                                                         will represent as text as four                                 characters but in reality as it is a                                 number we can represent it as an end                                 with two bytes and therefore we can go                                 to                                                                   which is interesting                                 now custom binary civilization ain't                                 nobody has time for that                                 right so it's kind of like nobody does                                 it like the only people I know like I                                 haven't been to all the industries in                                 computer science or maybe I missing                                 something but one of those industries                                 which still kind of used custom binary                                 civilization is gaming industry and only                                 if it's like real time with a massive                                 multiplayer thinks then you need to have                                 your packages really small and you need                                 to use UDP and so on and so forth all                                 the other people don't really use this                                 kind of stuff because they don't have to                                 because they are there are lots of                                 problems which you can't get into if you                                 use custom salinization                                 stuff but if you google or go to                                 Wikipedia and just search for                                 Civilization formats you don't have to                                 be able to read this I just wanted to                                 feel like Wikipedia has like over                                    different formats listed which make                                 serialization possible JSON is also                                 there but it's only one of over                                    formats and but also a disclaimer I                                 looked through the list and in some                                 cases where information is not that                                 accurate but at least you have a big                                 list of everything that you can find and                                 try to realize what kind of things could                                 fit your needs                                 actually so I have a different talk on                                 where I explain in details how those two                                 binary civilization works so if you'd                                 like to follow up this is the link but                                 here I just wanted to show that raise                                 your hand please if you know flatbuffers                                 okay just for people ready here hand if                                 you know protobuf much more people sure                                 anyone knows gopher                                 nobody knows covered so so just                                 basically like those are three                                 civilization formats and comfor is based                                 on protolith is just simplified and                                 there were a few edges cut it so it's                                 not as powerful as protobuf but it's                                 much faster and wrote about in                                 civilization this relation if you are                                 interesting just google for it and you                                 will find it or contact me but what I                                 wanted to show is basically that if you                                 do it in a binary format you can get                                 close to what we saw with a custom                                 representation and the good part is in                                 this format we will keep the structure                                 all these formats are a schema based and                                 you define the schema so you tell that                                 you have a name you have a birthday                                 which is its own type and these types                                 have a year month and day so it's not                                 really custom or so proven to break                                 rules really easily but it still gives                                 you the possibility to reduce the size                                 dramatically I mean now let's talk about                                 performance Jason is a text-based format                                 and to be honest I don't have problem                                 with Jason I like Jason Jason has a                                 representation is in my opinion pretty                                 good I really like it                                 specifically compared to a XML or                                 whatever but the problem is basically                                 text-based format right so text-based                                 format would be very efficient if we                                 have something like this so we have a                                 person here which types text into a                                 computer this computer will just send                                 the text without understanding it to                                 another computer this computer will just                                 display the text to another person this                                 person reads it replies to it and then                                 it goes back without the computers need                                 need to actually understand what's                                 inside there is just blobs moving blobs                                 perfectly fine                                 but in reality we have this situation                                 like a previous situation I think in the                                 beginning of the internet it kind of was                                 like this so people set on a terminal                                 just punched in some text and just send                                 it and some other actually read this now                                 we have services talking to each other                                 right no humans but what we actually do                                 is still the application has its state                                 encoded in                                                             forth                                 so what we make it do to please                                 transform it to human readable we will                                 send this human readable over the                                 Internet to another computer it will be                                 still human readable this computer                                 doesn't know how to read with human                                 readable so it has to parse it and then                                 it will actually get into again                                       ones format which it can understand I                                 don't know about you guys but if I see                                 this I feel like this I actually just                                 want to kick myself because it just                                 doesn't make any sense                                 in a way and well I'm exaggerating a                                 little bit right because if you think                                 about it you can have different                                 platforms but binary on this side is can                                 be different on this sides because you                                 have different programming languages and                                 so on and so forth but this is what the                                 binary sedation formats are for they are                                 here to make a platform independent                                 binary representation which can be                                 easily read by machines from machine to                                 machine server service to service and                                 what we actually just can do is this we                                 can just say like ok and let's put a                                 binary boundary here and to say when the                                 service is talk to each other when the                                 machines talk to each other it's in                                 binary - binary if I as a human and                                 generally I see the point of human                                 readability and even right ability in                                 the beginning it's even more important                                 because I want to try out stuff                                 I want to do something and it's much                                 easier for me to write it in a way which                                 I can just use the text editor for then                                 to try to do it in binary right but then                                 at some point I'm done debugging and                                 most of the binary realization formats                                 as well have a possibility to transform                                 JSON into this binary / script and from                                 binary into JSON again so we have still                                 this way if we need to read this if we                                 need to write there is a way but we were                                 not enforcing the text format on two                                 machines like to perform at that that                                 they actually can't read to them to say                                 like read this parse vez create this and                                 if you don't do this it actually pays                                 off quite a lot so as I said I'm a                                 recovering game developer and in my last                                 gaming project I we had a problem with                                 JSON so we had a way for context start                                 up where it took like                                                 for for switching context on the backend                                 because most of the time was spent on                                 parsing JSON when we switch from JSON to                                 flatbuffers we went to two milliseconds                                 so it was like                                                         we didn't measure just for parsing we                                 actually measured like bringing it up                                 for context removing the context                                 switching from context to context i                                 ported flatbuffers to swift and also                                 flag flex buffers and this is what my                                 micro benchmarks shows if you do like                                 comparing jason's civilizations                                 digitization to thread buffers and flex                                 buffers so here we see that for example                                 decoding here it's                                                    almost                                                                 it in flatbuffers                                 it's                                                                   the funny thing is I can actually bring                                 this number to four milliseconds if I                                 remove some safety checks if I would use                                 a C implementation of flatbuffers I                                 would go to to making this                                           anyway okay one more less thing zero                                 cost random value access this is a                                 genuinely bad word and if you hear zero                                 zero cost this can't be right because                                 there is no zero cost anyways but what                                 it means in cases of binary situation is                                 basically that there are a few binary                                 formats I know only this free                                 flatbuffers lag buffers and captain                                 proton which let you get values out of a                                 binary without creating any kind of                                 representation you basically kind of                                 have something like jumping in the                                 memory so get a few are doing some                                 dereferencing and then you can read the                                 value out because the format's are                                 already designed in a way that it's                                 memory aligned and basically everything                                 is reference based so this lets me do                                 following so I saw it on this conference                                 there is lots of talks about search and                                 I have also a search example made with                                 sled buffers where I have a data set                                 with all city names it's more than three                                 million entries which is roughly                                     megabytes s CSV I transform it to                                 flatbuffers and then I can do offline                                 search on my iPhone for country name and                                 city name and this I can also do either                                 if I load everything directly into                                 memory                                 or directly from file because what data                                 is laid out already in the way that you                                 can just seek inside of a file and read                                 only portions of the data not all over                                                                                                       can give the memory reader as you can                                 see I have three million cities and I                                 can scroll throughout any problem I will                                 now search for cities in Germany so                                 there are like                                                           the speed of a query now I will search                                 for the lens again the query speed is                                 actually quite good right there was one                                 point where it was like two milliseconds                                 of four milliseconds or something like                                 this everything else is actually beyond                                 one millisecond and here I do the same                                 directly from file again slower like                                    milliseconds in worst case scenario but                                 still very very fast and I'm able to do                                 it because the format already represents                                 the data in this zero cost random access                                 way all right                                 so general look out so please don't use                                 JSON just because it's convenient or                                 because everyone know everyone else uses                                 it and so on and so forth                                 please consider your use case there I                                 use cases where it's totally fine to use                                 JSON or even performant to use JSON I                                 don't know maybe but what I normally see                                 is basically it becomes like one thing                                 it's all I can represent the stuff and                                 isn't great let's represent it in JSON                                 human readable is the manner of tooling                                 as I showed in the beginning of a                                 presentation text representation we                                 already have all the to link we need if                                 it's a little bit different then yeah                                 that can be a tool or you would need to                                 write it or something like this but                                 still it's very                                 easy if it's machine-readable it's you                                 just need to have a tool which will make                                 it human readable and normally it's not                                 that hard to do these kind of things                                 imagine how much more responses our                                 service could deliver if it took                                       less time to process a request because                                 literally if you think about it for web                                 servers most of the time what endpoint                                 do they get requests the payload is JSON                                 they parse them they identify what to do                                 and then they start doing this and this                                 is the main load which we have on our                                 servers anyway if we could reduce this                                 this is what we also did why we switch                                 from JSON to flatbuffers in my previous                                 project because the back-end developers                                 told we would like to have hundred users                                 per second per core if you wait                                    milliseconds on parsing JSON we are                                 already at                                                              doing nothing yeah and I'm actually open                                 for questions                                 all right listings Maxime                                 [Music]                                 there's one in the center yeah all right                                 yeah so thank you for the talk very cool                                 have you used baby other ones like April                                 and prief another binary protocols and                                 you can have any tips about it for sure                                 ones have trade-offs between the others                                 but maybe you have more more examples                                 and tips well yeah so so again I have a                                 very deep understanding of web buffers                                 and select buffers because i ported them                                 right I looked into Colfer and a little                                 bit of a proto bus because I was                                 interested because I saw there is a                                 github repository which have a benchmark                                 for different civilization formats on                                 GBM and their code was the fastest even                                 faster than Fred buffers in decoding                                 which then I went through the test and                                 actually test does something wrong                                 because they didn't consider this random                                 access because basically what we did                                 they already kind of got a binary and                                 still mapped                                 everything from this representation into                                 a Java object graph which you don't have                                 to do anymore in flatbuffers and in                                 captain proto as well rift for example                                 by Facebook and also brought about by                                 Google                                 they are generally designed for machine                                 to machine communication so for RPC                                 sending messages therefore what they                                 trying to do is to actually do bit                                 packing flatbuffers is on contrary                                 design to store data and be able to read                                 this data so for example it also was                                 done by Google in the game developer                                 initiative and what you do there is you                                 would like to store game state for                                 example and then you would like to be                                 very efficiently read data out of it                                 this is why it's supports this zero zero                                 cost random access values right so this                                 is the trade of which you have to think                                 about and see and like if you are only                                 about sending messages to each other                                 then I would look into a plot above                                 frist there were a few more form                                 displaying right but for example also in                                 this gif example as you saw I only asked                                 for                                                                     hundred and cents                                                 response because it has everything and                                 there is actually nice to have this like                                 zero cost random access because then I                                 will just be able to just randomly                                 access with write URLs which I need and                                 I'm done I don't have to create objects                                 of a whole payload and so on and so                                 forth make sense okay so I like the                                 topic because it's like it addresses the                                 more of a fundamental level of the                                 question why did we transfer the text                                 o'er machine to machine communication                                 and my question is more towards kind of                                 discussion kind of topic not very                                 specific like a question directed to you                                 specifically but when basically when I                                 was digging into the same question my                                 machine to machine communication use                                 text the I found answer basically an                                 HTTP so HTTP was basically designed to                                 have a hypertext Transfer Protocol right                                 so it because of TechSoup                                 when HTTP came into existence it                                 basically was person will request the                                 document to some computer and it way he                                 will get the like website over there                                 that's why a equals design and now                                 when I see the things are evolving                                 towards protobuf and machine to machine                                 communication and everything is binary                                 and so like my kind of question kind of                                 thing                                 like they think it's probably the time                                 when basically when machine to machine                                 communication is increasing it's time to                                 move away from HTTP and have some kind                                 of other kind of protocol which is                                 machine to machine protocol and text                                 Transfer Protocol is for text basically                                 just one is for text because it's like                                 getting transferred as text and it was                                 for text in the beginning of that yeah                                 so and you can see for example HTTP                                      more of a binary protocol than a text                                 protocol they already moving with HTTP                                   into more binary space you also can see                                 for example G RPC from Google which is                                 like Google or PC stopped you is also                                 more binary and it lets you the payload                                 can be binary they don't care this is                                 actually funny because if you think                                 about it even with HTTP with the                                 standard web stuff HTML is text right                                 how many things in this text is actual                                 text which humans will read and how many                                 things in this text is actually for                                 machines to read write for example CSS                                 why isn't CSS pre-compile to binary and                                 send over because it no human will read                                 CSS right but it's still in test because                                 it's easier just to just basically like                                 send it over the only thing which we do                                 is minifying stuff and sometimes                                 gzipping stuff right and there but it's                                 kind of like in my opinion is basically                                 the patch one of wound where we say                                 actually it shouldn't be text in the                                 first place when we wouldn't need to                                 encode it in the first place because                                 encoding again it goes again efficiency                                 [Music]                                 yeah for exam                                 all right let's whip up okay I think to                                 speak again cigarette                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=qF44UetsLsQ


