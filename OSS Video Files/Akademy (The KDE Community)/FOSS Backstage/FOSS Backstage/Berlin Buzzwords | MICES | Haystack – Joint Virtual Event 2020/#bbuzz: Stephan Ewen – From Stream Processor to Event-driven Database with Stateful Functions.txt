Title: #bbuzz: Stephan Ewen – From Stream Processor to Event-driven Database with Stateful Functions
Publication date: 2020-07-02
Playlist: Berlin Buzzwords | MICES | Haystack – Joint Virtual Event 2020
Description: 
	More: https://berlinbuzzwords.de/session/stream-processor-event-driven-database-stateful-functions

Orchestration frameworks like Kubernetes have made dealing with stateless applications very easy. But for stateful applications, we are still clinging to the ancient wisdom that state shall be someone else's problem: just put it in a database! Because of that, we are still struggling with the same issues of data consistency and complex failure semantics as decades ago. Developing stateful applications in a scalable and resilient way is still hard, especially when they span multiple (mirco)services.

Stream Processors, like Apache Flink, have solved similar problems in the area of event-processing. By rethinking the relationship between state, messaging, and computation, stream processing applications are out-of-the-box scalable and consistent.
 
Is it possible to bring some of these ideas to the space of general-purpose applications and (micro) services?

The Apache Flink project has recently added a new subproject called "Stateful Functions" (https://statefun.io/) that tries to achieve exactly that. In Stateful Functions, the Flink effectively becomes an event-driven database that works together with containerized event-driven functions to form a new building block for scalable and consistent applications. In this talk, we present the Stateful Functions project. We show how its small change in responsibilities between database and applications goes surprisingly far in solving the problem of consistency and failure semantics for applications, and additionally makes it blend in very with current serverless technologies, like AWS Lambda, knative, etc.
Captions: 
	                              foreign hey everyone welcome back                               um up next we have stefan ewen and he's                               going to talk about uh stream processing                               and event driven databases with stateful                               functions                               again bring your questions to the studio                               channel on slack                               and we'll ask them at the very end of                               the session stefan                                thanks josh                                hello everyone this is uh i'm stephen                                i'm very happy to be here again at                                berlin buzzwords in the                                like in the virtual edition um this year                                um yeah i'll be talking about um about                                stateful functions and about                                yeah it's work we're doing in the um                                apache fling project it's a it's                                a way how we think about the evolution                                of um stream processing                                towards to it's something that you know                                we we started calling um an event-driven                                database and                                yeah i'm excited to be here today tell                                the story                                so before before jumping in just uh one                                slide with uh                                maybe background about um myself and the                                company i work for                                um we're um with america where the                                um company formerly known as data                                artisans                                um we're founded by the by the original                                creators of                                um of apache flink and that's what we're                                doing still                                day-to-day most of the time developing                                um open source stream processing                                technology in the apache flink project                                um we're also offering an enterprise                                stream processing platform                                and um yeah the company started as data                                artisans                                it's now called verica that's because a                                little more than half a year ago it was                                actually abide                                acquired by the alibaba group so it's                                part of the alibaba group ecosystem                                right now and                                um yeah we rebranded as as part of that                                okay jumping into the um jumping into                                the                                the main the main talk here um                                the the original title is is a bit of a                                mouthful like uh                                stream processors and event driven                                databases or from stream processor to                                event driven database with stateful                                functions um i thought                                maybe another title like i could have                                picked that was                                a bit a bit shorter but might also                                describe pretty well what we're trying                                to do here is                                um the quest for stateful serverless                                so stateful serverless what is that                                supposed to be so serverless is is this                                big trend happening                                and and computing these days right i                                mean some people associate it with                                things like amazon lambda but it's                                really this much broader                                trend to yeah to not be thinking about                                physical                                um instances of hardware and software                                and so on and                                um serverless has made a pretty good                                headway when it comes to                                um to to be able to handle um stateless                                applications but                                handling stateful applications in a                                serverless way is still                                so somewhat of a s still a challenge and                                um yeah part of what we've been doing in                                the stateful functions project is trying                                to look an answer for how to how to                                simplify this                                and um i think i'm going to open this                                talk with a bit of a                                of a daring thesis so um                                the like the hypothesis of this stable                                function project is                                that stream processors are going to be                                in the future                                to event-driven serverless application                                what the                                the database is the sql databases or the                                key value stores are to the crud                                application um today and                                 um yeah i hope i can back up this thesis                                 and                                 get to get uh get the audience very                                 excited about um                                 what that means and why why this is                                 actually really interesting um avenue to                                 pursue                                 and and the way we're building we're                                 building applications                                 so let's actually dive in let's let's                                 dive in into building                                 stateful applications in the serverless                                 era so how do we how do we start with                                 that                                 um let's actually start with just                                 building applications in this                                 and the serverless era and actually                                 ignore stateful just for a second                                 so the um the the core building block                                 that                                 um that that that comes up again and                                 again in pretty much                                 um all modern infrastructure is this                                 this unit of often of an event-driven                                 function and that                                 that can be you know it can be a                                 function that is deployed as an                                 event-driven function and k-native it                                 can be in can be the interface with                                 which you program                                 aws lambda or any of the other                                 serverless function compute yeah                                 platforms on on any of the other cloud                                 providers but it's also                                 it's also a very a very common pattern                                 outside of out                                 outside of those ecosystems this event                                 driven function is the core of of                                 my stream processing technology be that                                 in flink and kafka                                 it's also what um what is in some sense                                 the unit of                                 um of actor programming and actor is                                 is also in some in some sense in event                                 driven functions so                                 taking this as a starting point seems                                 like a pretty good idea                                 um when when starting to work on                                 on on something like you know stateful                                 stateful serverless                                 um event-driven applications                                 and there's there's some really nice                                 properties like in it's in its                                 simplicity it                                 it gives us the ability to be really                                 highly                                 elastic um scale out um scale in scale                                 to zero really fast                                 and and this characteristic is also what                                 i think defined a lot of the success of                                 um                                 of this abstraction                                 so this is i think so far                                 this has been um in in the industry a                                 pretty big success story                                 when it comes to building stateless                                 applications                                 however if we're trying to to build                                 state full applications i think we're                                 losing                                 a lot of the of the niceness that um                                 that we                                 that we have in in this technology so                                 building stateful applications means now                                 we're pulling in something like                                 a database and that's easily where                                 where things start to um i want to say                                 fall apart but with the let's say the                                 smoothness                                 of our serverless application                                 development                                 um yeah stops and where things become                                 become rough edgy                                 so all of a sudden you know we have to                                 really worry about                                 how do we actually talk to the database                                 like what what kind of protocol do we                                 employ to                                 to guarantee state consistency um and                                 it's                                 it's not it doesn't just stop with um                                 saying sure i'm gonna use the database                                 that supports transactions and so on we                                 still have to worry about                                 um about the different different                                 instances                                 looking at stale information or trying                                 to aggregate different                                 different data from different snapshots                                 and so on                                 we see very often that while the well                                 the stateless part                                 is is infinitely scalable infinitely                                 i mean as much as your club rider is                                 willing to provide                                 very often the bottleneck isn't isn't                                 actually in the                                 in the stateless part itself in the                                 lambda functions the bottleneck starts                                 to become the                                 the um access to data in the database                                 so you're you're making a request takes                                 a while to um                                 to process and respond and while you're                                 you're scaling out the                                 the functions to be able to handle more                                 of these requests at the same time it                                 doesn't really help the application                                 because the bottleneck isn't                                 isn't the function itself it's actually                                 the database                                 it can actually make things even worse                                 so if                                 um if you're actually scaling the                                 stateless part too much because you see                                 that a lot of the functions are starting                                 to take a long time to execute just                                 because they're waiting for the database                                 to process the requests                                 you're starting you're scaling this out                                 more and more you're hammering the                                 database with even more requests and all                                 of a sudden you start to see like                                 um request limiting or you see you see                                 failures due to denied                                 connections and so on and um well well                                 all of this is                                 is in some sense solvable with the right                                 tricks and techniques it's it's just                                 something where                                 the whole serverless experience is                                 starting to to fall apart it's                                 something where you know state is just                                 inherently not serverless in this                                 in this situation that's something you                                 have to explicitly worry about you have                                 to manage you have to                                 think about there being a physical                                 database with limited                                 amount of connections with supported                                 request rates and so on                                 so this is really part of the problem                                 we're looking to solve here                                 another another part where um                                 that's that's partly related to the                                 stateful serverless                                 space but in general also a big                                 limitation of the of the ecosystem of                                 um yeah of serverless applications is                                 how do we actually compose more complex                                 applications so                                 how do we go from the point of having                                 individual functions that                                 do one task to having you know more                                 complex applications that                                 in the general in the general case                                 message each other or rpc each other to                                 you know to                                 aggregate different information um to                                 compose a final                                 response to the original request and                                 there are solutions like workflows of                                 serverless functions but                                 all of these are like very special case                                 don't really                                 don't really form much of a general                                 solution yet                                 so so much for for the for the problem                                 space um                                 what i'd like to introduce now is the is                                 the work we've been doing in the in the                                 state for functions project and                                 um like try to explain how we're how                                 we're looking to address some of these                                 um                                 some of these issues that we see in                                 applications there and um                                 once i've you know once i've motivated                                 this there's a there's a demo to it's                                 the end                                 um showing how you can can do a simple                                 stateful serverless machine learning                                 classifier system                                 based on that so the the core of                                 of the of the stateful functions project                                 is i guess you                                 you will have guessed it from the name                                 is the idea of building applications                                 actually                                 not with stateless functions but with                                 stateful functions                                 so um like this this picture is somehow                                 the                                 like the the bird's eye view of um of a                                 stateful function application                                 um in the core it consists of a lot of                                 functions that                                 that treats data as as um yes                                 almost as local variables like a                                 property you would                                 you'd find in you know having having                                 just persistent local local variables in                                 a regular java program not not something                                 that is you know a proxy towards a                                 database and so on but really just                                 constant time access to um to local                                 state                                 um that that gets rid of a lot of the of                                 the problems of actually                                 uh dealing with state um                                 there are multiple instances of these of                                 these functions you can think of them                                 like in the same way as you have in an                                 actor programming you would have                                 multiple instances of these of these                                 actors                                 and they they basically invoke each                                 other they send each other messages                                 um take the responses and and process                                 them                                 and the um the second part that is                                 really                                 um a big deal that we um that we paid                                 attention to here is trying to                                 trying to get a lot of the common                                 problems of this interaction out of the                                 way so                                 assuming that if you have one function                                 that that message is another and is                                 expecting a response from that function                                 you can actually                                 assume that this reliably happens                                 exactly once um                                 you you can probably already see like in                                 the terminology and also in the kind of                                 guarantees we're going to give here this                                 is                                 this is clearly coming a little bit from                                 the direction of data stream processing                                 which is                                 um what we're working on um in the                                 apache flink project pretty much                                 most of the time so yeah these these                                 guarantees that that stateful function                                 is here is trying to give you is in a                                 very are very similar guarantees to what                                 our modern stream processors do want to                                 give you                                 namely consistent local state and the                                 ability for for functions to talk with                                 each other with exactly one's guarantees                                 that means                                 a message that you send is guaranteed to                                 arrive and it's going to                                 to arrive once if something happens on                                 the way                                 the whole system will consistently undo                                 certain changes both on the receiver and                                 on the                                 sender side to be able to to retry it                                 without duplicating any effects                                 the whole thing is actually built to to                                 work without                                 without having to manage a database in                                 the background                                 so um state management that happens uh                                 in the function doesn't actually in the                                 in the background actually propagate to                                 a database but it's                                 asynchronously snapshotted to um                                 to smart storage something like s                                        hdfs or                                 other other mass distributed file                                 systems                                 and yeah the the way you actually                                 program this um                                 in the newest version um we support both                                 java and python                                 is is very much i think i would say akin                                 to a very                                 to a very lightweight actor programming                                 api um                                 this is this is a simple example in um                                 in yeah that takes a message um                                 looks a little bit at you know what is                                 what is the type of the message how                                 should i react to it is it a                                 um is it a vector that i should uh                                 compute a classification for or is it                                 a feedback with which i should update my                                 model and then                                 you can actually you know if you look at                                 the code below it's not a                                              example but it gives you a rough idea                                 in how you just access state from the                                 local context um                                 do some actions and send out a result                                 message                                 this is kind of from the the api                                 perspective the the core                                 of um of the idea behind you know                                 building                                 building applications with stateful                                 functions and um                                 i hope we kind of i hope it kind of                                 explains how at least from the you know                                 from the programming abstraction this                                 kind of                                 helps you to get rid of thinking about a                                 database in the background because                                 you're thinking just about functions                                 with the local variables of state                                 and you don't have to worry about the                                 composition of functions in                                 in in ways that are um you know we have                                 to worry about fall tolerance                                 and and failover because it it gives you                                 the this kind of stream processing like                                 exactly once                                 guarantees across the communication of a                                 lot of functions                                 um for those of you that have actually                                 followed the stream processing and                                 apache flink space a bit they                                 they will probably recognize that this                                 is very reminiscent of a lot of stuff                                 that is happening here so what's really                                 the                                 the main difference um there's a lot of                                 difference in how it works in the                                 in the background um which i'll i come                                 to in a bit but also from the                                 from the programming abstractions                                 perspective there are differences                                 um such as um                                 the um yeah the the topology and stream                                 processing                                 is is usually a directed exactly graph                                 that you predefine                                 so um if you if you build a stream                                 processing application                                 usually start with um some data sources                                 and then you say okay i'm going to apply                                 maybe a filter transformation here in                                 map transformation and then i'm feeding                                 this into the left side of a join then                                 there's another stream i'm feeding it to                                 the right side of a join and then i'm                                 applying and let's say aggregation by a                                 certain by a certain                                 grouping here so as the last step                                 um in in contrast to that the idea of um                                 of stateful functions is really to be                                 to be much more low level and flexible                                 as um                                 as you as you kind of need it for a lot                                 of applications so you're not defining                                 your your data flow a priori you you're                                 basically just deploying functions and                                 they can dynamically at runtime decide                                 who they talk to that just                                 send message to a logical address and                                 they await a response from there                                 um they can communicate in patterns that                                 include                                 like cyclic messaging which you cannot                                 do in stream processing and they have a                                 very                                 dynamic nature in in how they um how                                 they are created and how they occupy                                 resources                                 with the stream processing more has like                                 fixed pipelines that you know they can                                 be scaled in and out but at any point in                                 time they actually have a                                 certain fixed set of resources                                 um as such the the idea behind several                                 functions actually much closer to                                 something that i think has been often                                 called virtual stateful actors                                 but with very high consistency                                 guarantees like consistent local state                                 and                                 exactly once messaging guarantees so if                                 you're coming from this space if you're                                 um if you're for example an aka                                 programmer or so you can think of safer                                 functions as                                 a version that um that makes an                                 opinionated choice in how                                 how these certain configurations should                                 be chosen for example you don't have                                 you don't have um a super um                                 flexible system of like supervision and                                 um deciding what you do if you know if                                 an exception                                 um happens or so but but rather the                                 system makes an opinionated choice to                                 say okay we're we're opting completely                                 here for                                 um for strong consistency guarantees                                 and we're for example um                                 not not remaining available under under                                 a uh under network partition so while                                 you know with                                 with actor systems like like aka they                                 give you this very flexible primitives                                 with                                 heartbeating and and watching and                                 supervision you can for example also                                 build                                 ap systems and so on stanford functions                                 is really an opinionated choice towards                                 a cp system                                 that is um in that way actually making                                 the apis quite a bit simpler                                 so from the api perspective um that is                                 uh pretty much it one one big part that                                 um                                 that this is the question now how do we                                 actually handle handle state the                                 serverless way because we kind of                                 touched only on yeah sure we don't want                                 to have this                                 we don't want to have a database in the                                 background we don't want to um yeah                                 be forced to um to deal with connections                                 and so we just want to pretend that we                                 have persistent local state and then                                 there's some                                 snapshots in the background so i admit                                 there was a bit hand-wavy in the first                                 and                                 first part but it was i was so on                                 purpose just to focus on the um                                 on the aspect of like what what is the                                 api towards the user what abstraction                                 can can the user um expect here                                 in the second part i'd i'd like to dive                                 a bit into how does actually this um                                 how does it actually work underneath the                                 hood how do how does the system give                                 these                                 um consistency guarantees and still                                 actually maintain                                 the this nice serverless elasticity                                 without sacrificing anything on the                                 stateful side                                 so if you if you look at the at the                                 literature for this there's actually                                 quite a bit of                                 work and also research on the area and                                 how do you actually add consistent state                                 to serverless systems and                                 there are quite a few approaches that                                 that center around around something like                                 this where you have                                 um you have your compute layer um                                 basically                                 something like aws lambda just very fast                                 elastically scalable                                 stateless functions and then you have a                                 layer that is                                 responsible for basically presenting the                                 state to that layer there's databases in                                 the background but this middle layer                                 kind of through crashing and proxying                                 is trying to abstract that away from you                                 that's actually explicitly not what                                 we've been trying to do here it's it's a                                 possible approach but it                                 um it is something that we we took a bit                                 of a look at initially and                                 um it's it's very complicated um in the                                 end to do it                                 um correctly and efficiently and there's                                 actually a there's a slight trick i                                 think you can do to                                 um to to still gain um a lot of the                                 benefits                                 but um yeah with with uh with                                 with much um with a much simpler                                 approach in the end                                 and to to kind of motivate that maybe um                                 let's                                 let's let's do a quick like um a thought                                 experiment on                                 um on challenges and approaches to to um                                 to consistency in in these distributed                                 applications                                 so let's assume here we have um we have                                 three different                                 different applications like you know                                 types of functions that                                 talk to some some database dynamodb                                 cassandra h based elastic or so on the                                 background                                 um and yeah these                                 let's let's assume they form um                                 something like a microservice each and                                 um an interaction with the application                                 it starts um with the api gateway                                 and one of the functions and then these                                 functions also have to talk to other                                 functions too                                 to in the end do their work to you know                                 request data from other services update                                 data and other services                                 okay um the the first um                                 first thing that happens is that there                                 is a request to the first service                                 it looks at the um at the database it um                                 updates uh something and then it sends a                                 message to the second service                                 which in turn also updates something in                                 the database                                 now let's assume in this case here we                                 have a                                 we have a failure and we didn't get a                                 response from the second service back to                                 the to the first service so the second                                 function actually didn't didn't tell the                                 first function okay you know                                 everything everything went through now                                 we're in a bit of a tricky situation                                 because we don't quite know did it go                                 through it did not go through do i have                                 to                                 like retry it or will it really result                                 in a duplicate um                                 did it actually go go through and not                                 just miss the acknowledgement or                                 or yeah just it's it's this general                                 problem um                                 to general's problem that that is hard                                 to solve in distributed systems and                                 there's                                 there's lots of work in in applications                                 and protocols and so on try to work                                 around it but it                                 it's it's always an issue you have to                                 worry about in in one or the other                                 way now one thing we can try and do is                                 we can just try to reverse a little bit                                 the the role between the application and                                 um the database here so let's assume                                 just for a second that                                 you know instead of the api get we're                                 actually talking to lambda here and                                 um sending sending the request there and                                 then lambda talking to the database                                 it would actually first send it to the                                 database and then the database would                                 um you know like record it associate it                                 probably with                                 um some some entity that that it belongs                                 to let's say user id or so                                 and then from there call call a function                                 get the request back and then talk to uh                                 send it back to the database for the end                                 for the next service which in turn would                                 also                                 you know invoke invoke the function if                                 we actually have the problem now that we                                 that we see a failure in that in the                                 transmission we're in a much easier                                 um place actually um or in a much better                                 place to solve this problem because on                                 on the on the database layer we're                                 handling both the state                                 now and the messaging and once we do                                 that                                 there we can actually employ a lot of                                 like very very known proven protocols in                                 a very generic way to actually make sure                                 that                                 the updates to to state and and                                 messaging that this happens in                                 like in an atomic way that does not                                 cause loss or duplicates                                 and we sort of have a way to make                                 all our um all our invocations to                                 to lambda functions pretty much yeah                                 stateless item quite important um                                 so if we actually have to call this                                 function again it actually doesn't                                 matter because that function does no                                 longer make a decision about sending a                                 message or about triggering an update                                 all these decisions are now just                                 generically made down inside the                                 database system                                 so in some sense what what we're what                                 we're                                 what we really need to employ this trick                                 is is kind of yeah this inversion about                                 application applications and data                                 interact so                                 rather than having an application that                                 takes a request talks to the database                                 and gives a response                                 we actually have something like i                                 actually see it on the slide already                                 something like a stream processor that                                 takes this stream of requests                                 and then calls our applications and and                                 gives a stream of responses                                 and if we do this the right way then we                                 can yeah we can                                 just keep using applications um in the                                 building them the exact same way as                                 before and we just                                 swap the database with the stream                                 processor and we can pretty much                                 can pretty much go and um we've gained                                 a very a very nice way of building                                 stateful                                 um therefore systems here                                 um it also means that we're we're really                                 switching a little bit the the roles of                                 of who is actually in charge of you know                                 driving the entire application and the                                 in the classical sense it's the                                 application that                                 it retrieves the request and it's in                                 charge of you know                                 making response requests and responses                                 to the database and the database pretty                                 much reacts to those                                 on the right-hand side we have the                                 stream processor deciding when it's the                                 right                                 when it's the right moment to actually                                 invoke the application with a certain                                 piece of piece of computation that we                                 need to do                                 so applying this may be true to                                 something like                                 something like the aws stack if you're                                 familiar with this it would actually                                 mean that instead of                                 um let's say we're we're building an                                 application that that                                 processes data from um from kinesis                                 which is a like a                                 streaming message queue here um rather                                 than then building it in                                 in the way that you would find it on on                                 the amazon block here like define your                                 lambda functions to consume data from                                 kinesis and then work                                 around dynamodb it actually would                                 actually say like the first consumer                                 for of these events is actually the                                 stream processor and then the stream                                 processor talks through the api gateway                                 to the lambda functions                                 and it's it's actually worth noting that                                 we kind of solved two of the most cited                                 problems of of the whole                                 um the whole serverless space with that                                 like                                 consistent scalable state and messaging                                 and composition                                 um for the sake of time because we                                 started a little late i'm i'm going to                                 skip over the                                 um over the recap of apache flink here                                 just mentioning really quick apache                                 flink is this stream processing system                                 that                                 that working on it's kind of the                                 umbrella project of of stateful                                 functions                                 and the um in its core it's really an                                 engine that                                 that pushes streams through operations                                 and in the background                                 um takes uh consistent asynchronous                                 snapshots of the streaming pipeline in                                 order to recover them and it has these                                 interesting properties of being able to                                 give you exactly once guarantees for                                 your state and your messaging                                 without actually needing a ton of                                 coordination overhead                                 um if you haven't actually looked at                                 that apache flink at all so far i                                 cannot hardly recommend it take it take                                 a look it's a really interesting project                                 i might be a biased person but                                 i i do honestly believe that                                 so back to back to stateful functions                                 itself so as i mentioned this this is                                 built                                 on on stream processing technology in                                 this case specifically on apache flink                                 if you actually deploy um if you                                 actually                                 use it in production what you like what                                 you actually see is that in the core                                 you deploy you deploy a yeah                                 a cluster of flink with stateful                                 functions pretty much like you would                                 otherwise deploy a database                                 and you basically um you basically                                 register modules ingress modules or so                                 that say okay here are the events                                 that that you just that you consume that                                 you um that you react to and then you                                 can actually register                                 certain modules or functions that may                                 result on um as                                 a separate um kubernetes deployments or                                 um may result behind an api gateway um                                 if if you're talking about you know                                 serverless functions to to actually                                 um execute execute the logic                                 and um yeah let me actually quickly                                 quickly show you what um                                 what this looks like if you actually use                                 it                                 in for real application                                 so the the use case that i've picked is                                 actually a um                                 it's actually a machine learning                                 application um which is taking                                 a stream of user events and                                 is outputting um like a fraud risk score                                 for that                                 so the the way that this application                                 works is that every event first runs                                 through a set of statistical um                                 statistical functions that collect                                 certain aggregates like what is the time                                 since you know                                 that user did another transaction what                                 is the what is the                                 the number of times they have used it                                 for this sort of um for this sort of                                 uh yeah product or how many times have                                 they used it in that country and so on                                 so think of it as yeah as different                                 aggregates of                                 such of such features and then we pass                                 it actually through a classifier module                                 so the classifier                                 is is a as a python simple python                                 machine learning                                 um algorithm um which which uses                                 five different we actually uses uh five                                 different algorithms here                                 um to that represent different ways of                                 of classifying the fraud and the idea                                 here is it it depends on what kind of                                 persona                                 the user is which model actually gives                                 the the most accurate                                 um accurate prediction whether this is a                                 fraud or not                                 so some somebody who is you know mainly                                 an online shopper mainly an offline shop                                 or somebody that travels a lot travels                                 travels little um it's actually um it's                                 quite a popular model to have this um to                                 have this multiple different models and                                 then try to to pick the one that is most                                 accurate for the user                                 and an approach to do this is this                                 multi-armed bandit or                                 or k bandits where you or you're                                 emulating these um you know like this                                 bandit slot machines and you're actually                                 saying the one that gives me the highest                                 reward                                 that's that's the the one that decides                                 for for the model that i pick                                 so this is also a stateful thing because                                 we need to remember how many times did                                 we pick                                 um individual individual models and what                                 was the what was the accuracy what was                                 the reward we got in the end for this                                 model                                 um if we implement this and this um in                                 the state for functions approach what we                                 what we have to do on the                                 let's say on the on the flink side on                                 the event-driven database side is we                                 have to register an ingress model                                 for um for the different type of                                 requests that come in                                 in this case it's it's requests um                                 here the type url is a demo sparse                                 vector that is                                 a vector that we want to get classified                                 and then prediction feedback                                 which is you know once we know it was it                                 actually a fraud or not                                 in hindsight feedback to the model and                                 then on the right hand side this is                                 basically all it takes in order to say                                 let's let's define let's register a                                 function model                                 a function module to be invoked here                                 and then this is the same the same code                                 i showed earlier                                 this is pretty much what it looks like                                 to implement such a function it's pretty                                 it's pretty compact code in the end                                 so let's actually um let's actually take                                 two minutes and just see how                                 how this looks like if we run this i                                 have to quickly                                 see how do we do this with the                                 presentation here                                 okay does this work                                 okay i just hit play it's a pre-recorded                                 demo for                                 um for the sake of being easy to                                 broadcast here                                 okay um so                                 the the application that we're seeing                                 here is outputting our is visualizing on                                 the right-hand side                                 um our our average fraud score and we                                 can we can probably see that something                                 is                                 something's off here a little bit                                 because you know                                              transaction being fraudulent                                 they will probably misclassifying                                 something here so over time of this demo                                 we want to repair this                                 let's look quickly at um at what what we                                 have here                                 running and this is really an absolute                                 standard                                 kubernetes deployment as you would                                 actually deploy you know                                 let's say a database on kubernetes and                                 an application now the interesting part                                 is                                 because flink works with this                                 asynchronous snapshots and the                                 background to something                                 like in this case we're running this on                                 google cloud so google cloud storage we                                 actually don't even need stateful sets                                 here so we're                                 actually running state less processes                                 here for the master and the worker                                 and then a few the um you see                                 they're called python workers here in                                 the in the entry um                                 for for the actual um for the actual                                 functions so                                 and we can we can actually you know now                                 um scale these these stateless workers                                 in the in the exact same way as we would                                 scale any other any other application                                 if we would run this for example on on                                 aws we would actually see that                                 you know it would actually scale                                 automatically depend depending on the                                 request rate or we could just add in                                 this kubernetes example here in auto                                 scaling group                                 to scale it for us and this demo we                                 scale it manually though                                 another thing that we can can pretty                                 easily do here is just                                 swap the the container image for the                                 functions in order to for example apply                                 a new version of the software that has                                 that has a patch                                 that that fixes the the classification                                 for example we can see that                                 i don't know cannot see this well here                                 because this screen                                 is cut off at the bottom                                 ah now we can see it better yeah and um                                 so this repairs um this repairs our                                 deployment what is interesting to see                                 here is that                                 in in the course of this entire um                                 deployment we actually did not get any                                 any disruption of the                                 of the system and we didn't actually                                 have to do anything in our code to worry                                  about                                  okay how do we deal with certain old                                  versions of the code running certain new                                  versions of the code running how do we                                  deal with um                                  yeah how do we deal with concurrent                                  access to                                  to certain entries and so on so all of                                  this is pretty much                                  solved by the system out of the box                                  all right and with that i'm                                  pretty much at the end of this talk um                                  yeah the um that's it that's what we're                                  um that                                  what we're currently developing see it's                                  in a nutshell let's say it's really in a                                  system that that tries to to give you                                  this                                  the stateful serverless programming                                  abstraction                                  akin to you know stateful actors um                                  working with a stream processor in the                                  background                                  and yeah it's an it's a fairly new                                  project it's open                                  for contribution if if you're um if                                  you're interested                                  um in it and with that out                                  like to conclude the talk thank you very                                  much                                  so just imagine a virtual room full of                                  people clapping                                  and they're out there clapping so thank                                  you for your talk uh                                  we don't have any questions in the slack                                  channel right now                                  uh i would remind people to join the                                  breakout                                  group great breakout room in jitsi uh                                  which you will be in                                  after this um i have one really quick                                  question because we're really out of                                  time                                  what do you think are the ideal use                                  cases so compared to compared to                                  what you showed and what other people                                  might use what do you find is like the                                  real                                  yeah um let me try and give a very short                                  answer to this there's                                  there's a lot to it i think actually                                  something like i showed in this demo                                  like distributed um like doing                                  distributed feature vectors                                  um for for machine learning classifiers                                  is actually very a very good fit                                  for this type of applications another                                  one is actually um                                  like maintaining distributed um                                  statistics and aggregates for                                  um for iot or so use cases where you                                  have lots of decentralized sensors and                                  what you want to keep is                                  an overview of you know what are the                                  individual um                                  what is happening in certain areas in                                  certain regions and                                  you have for example the sensors have                                  spiky load so you're really interested                                  in this                                  um very elastic system um we've actually                                  played around with                                  a bunch of use cases we've actually even                                  like prototyped a small                                  um like gaming backline for for a                                  browser game and this and so on so                                  there's there's tons of stuff you can do                                  yeah                                  um i think we're only beginning to                                  really understand                                  what you can do with this i would say in                                  the long run the goal of this project is                                  try to make                                  pretty much everything that that you                                  currently set up your own web server                                  style application for make it possible                                  to build something like that on this                                  abstraction all right but there's a way                                  to go                                  look forward to it all right thanks                                  again                                  you
YouTube URL: https://www.youtube.com/watch?v=K2vgV5afUl4


