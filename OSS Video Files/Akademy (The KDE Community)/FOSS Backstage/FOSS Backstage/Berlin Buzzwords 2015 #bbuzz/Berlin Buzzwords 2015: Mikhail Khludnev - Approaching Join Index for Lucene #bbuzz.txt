Title: Berlin Buzzwords 2015: Mikhail Khludnev - Approaching Join Index for Lucene #bbuzz
Publication date: 2015-06-03
Playlist: Berlin Buzzwords 2015 #bbuzz
Description: 
	Lucene works great with independent text documents, but real life problems often require to handle relations between documents. Aside of several workarounds, like term encodings, field collapsing or term positions, we have two mainstream approaches to handle document relations: join and block-join. Both have their downsides. Join lacks performance, while block-join makes is really expensive to handle index updates, since it requires to wipe a whole block of related documents.

This session presents an attempt to apply join index, borrowed from RDBMS world, for addressing drawbacks of the both join approaches currently present in Lucene. We will look into the idea per se, possible implementation approaches, and review the benchmarking results.     

Read more:
https://2015.berlinbuzzwords.de/session/approaching-join-index-lucene

About Mikhail Khludnev:
https://2015.berlinbuzzwords.de/users/mikhail-khludnev

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              thank you hi guys how are you do you                               like coffee and Kate ok my name is                               Victor food if I'm want to talk about                               joints in racine about different giant                               of limitation in racine I work in                               company does it work some hell I work in                               company group great dynamics our                               customers are American retailers our                               headquarter in Silicon Valley we used to                                provide in different engineering                                services for taylors we we do back-end                                development now we do data analytics for                                internet advertisement and I've work in                                team which delivers a search button for                                e-commerce for searching in product                                catalogs for customers I'm a principal                                engineer I spoke in last Lucy in                                conferences I made several little                                contribution into solar code base for                                example I contributed the blog showing                                very parser and update flow for solar                                but it was just the prototype and if you                                full solar gira you know that movie was                                really upset by the ad hoc the way which                                solar handles blow join so I'm really                                regret about it my favorite contribution                                most enjoying was an attempt to fix                                threats in data import tumblr have you                                heard about dating box handler in solar                                so you know there was sitting to enable                                multi threading but it's a little bit                                unstable and when my fix was committed                                there and branch three dot x committee                                has decided to completely remove threats                                from dating porch under                                right after I fix all concurrency back                                during the long debug session you know                                I'm not sure how it depended is my                                contribution at all nobody told me they                                just dropped it so this is an advantage                                section session that's why I expect that                                you are aware of how we see in searches                                how it applies updates by staking                                segments one on each other what is doc                                wireless and why do you need to care                                about joints at all because it might be                                sort of specification you know that many                                people use the scene solar elastic and                                doesn't and don't care about joints but                                I care and I suppose that you share my                                concerns about joints so here's the plan                                for today I want to discuss existing                                implementation of joint queries in the                                scene and propose some d you d-                                      leucine is pretty good and reliable and                                efficient in essential searching                                filtering and it's also pretty strong in                                analytics features it starts from facets                                and now leucine and solar her have have                                implementation for distributed pivot                                facets for heat maps it's pretty strong                                in analytics it makes them pretty                                powerful tool set but there is the still                                have a weakness it's a robust join so                                they still lack of universal always                                efficient to an algorithm we have few of                                them but we easily can face an edge case                                where some particular joint where it                                doesn't work well and usually join looks                                like this                                that's what we have in relational                                databases we have the two entity types                                and we have relations somehow declared                                between two entity types for example x                                equal keys so one product that is equal                                to another product lady before we look                                into particular implementation I like to                                look onto this problem and to join                                operation in general so let's depict one                                entity types by squares and second                                entity ties by triangles so it's our two                                entity types in the index or in database                                whatever then we declare some predicate                                which actually define the relation and                                this definition which can be read by                                primary key is equal to Frankie in fact                                it defines the third set the set of                                relation couples so we can draw it by                                this by grouping the triangle and square                                right and get this this is this little                                house so our relation is a set of                                relation tuples looks like this that's                                what we will work with in this talk                                let's also limit our discussion of                                explanation by the typical keys is one                                too many relation we can call one entity                                types as parent and second entity types                                as children and limit the relation to                                one too many case so every parent can                                 have several children but not vice versa                                 and it allows us to grope in the                                 relational tuples into these multi-story                                 buildings so it's like relational groups                                 and just grow groped relation top                                 so now we are ready to execute generic                                 joint operation usually it looks like                                 this we have children site query or                                 predicate which select some certain                                 children and and entities so while                                 executing joint operations we need to                                 loop through them and somehow obtained                                 the relation tuples belongs to the                                 children entities and through the                                 relation tuples we can navigate to                                 associated parents like this and it                                 seems like joint operations is our that                                 only thing which we need to do we just                                 calculated associated parents from                                 children that in fact in general form of                                 joint we somehow sometimes can have                                 second filter which is applied to parent                                 site of joint operations it looks like                                 this and the we also need to intersect                                 the set of associated parents with these                                 predicates with this parent filter and                                 here you can spot the opportunity for                                 optimization so you see if the parent                                 filter is highly selective if it passed                                 only few parents there is no much sense                                 to calculate all associated parents                                 right in this case you can employ this                                 fact and start to execute joint                                 operation into the opposite direction                                 looks like this we can start from                                 looping our few parents and just the                                 navigate through relation tuples to the                                 associated children and check their for                                 intersection with the Gideon children                                 filter I think that enough in the for                                 this level of generality so I want to                                 summarize that joint operation is the                                 intersection of three sets sets                                 of parents sets of children and join                                 relation where sets of parents and                                 children we we are provided in queer                                 time so every time we get the new subset                                 of children and parents and join                                 relation is more static it's defined by                                 data so our data forms the joint                                 relation set and then one note about                                 joined relation set that some algorithm                                 might not even build these tuples this                                 relation tuples some implementation for                                 example like nested loops join calculate                                 this relation tuples like dynamically                                 during nested loop well like this and                                 depending on the particular business                                 problem we might need to output                                 different size of joint operations some                                 sometimes we need to return only parents                                 sometimes Vinatieri to all the children                                 or even sometimes we need to return both                                 of them grouped together but                                 nevertheless it's up to us to choose                                 proper direction for enumeration so                                 considering the particular selectivity                                 particular set cardinality we can loop                                 through children or through parents it's                                 up to us we can mind the computational                                 efficiency here so now it's time to look                                 at the first implementation it's a query                                 time joint which is implemented in class                                 join you it you uses doc values the                                 special data type where we need to store                                 our IDs so the parent IDs is stored in                                 the queries column so what it does it                                 loop through children which is                                 which are called to sign                                                sight of join it obtain the value of                                 parent AZ for every children and drop                                 them into accumulator in this set of                                 terms so that's what it does it just                                 scanned children and collect parent IDs                                 and the second stage of joint operation                                 is searching for the accused parent IDs                                 it's done like regular turn queries so                                 in fact the query time join execute term                                 varies from the scene parent IDs many                                 times so the more results you have the                                 more operation you do and there is one                                 problem with it that Lucy interim                                 dictionary is not built for doing                                 frequent thermal cups it's a little bit                                 expensive operation and it's a the main                                 problem is query time Jen so we discuss                                 it a little bit later once again now we                                 obtain parent documents and we can                                 intersect them with the parent predicate                                 here's the second implementation which                                 is blog join block join is a quite                                 clever idea it utilizes the fact that                                 we've seen models document these                                 document numbers so it assigns numbers                                 to the document and it allows a certain                                 type of nature relation between                                 documents so in the scene internally                                 token documents are not just identified                                 they assigned numbers so we can employ                                 this relation between numbers we can say                                 which documents comes after another and                                 what actually block joined us                                 Howard openings are numbered so we can                                 just in the exam in blocks or in groups                                 and just put every parent right after                                 their children and do seem provide                                 special API for them and what it does is                                 just assign internal numbers guy                                 consequently on children and the parent                                 goes right after them looks like this                                 then in query time we can obtain obtain                                 this information about parents in just                                 in form of simple bit set and it allows                                 us to navigate from month navigate from                                 children to parents looks like this we                                 loop through children documents and this                                 simple bit set scanning we can navigate                                 to the parent belongs to these children                                 that's what it can and continue to find                                 all associated parents but in fact it                                 does more efficient thing the scene has                                 out written which is called Li leapfrog                                 four intersecting queries for executing                                 contraction query and it's done in                                 really efficient way so what it can done                                 here instead of looping all parents by                                 the same direction lucene can realize                                 that the many associated parents are                                 really redundant and we need don't need                                 to obtain them and it can advance                                 children side of joint operation over                                 unnecessary parents right so this                                 algorithm is already in the scene it's                                 called leapfrog so our the most                                 selective side of joint operations start                                 to lead Joe an operation avoiding                                 unnecessary step it's really performance                                 breakthrough so                                 listen does it advances children side of                                 joy and liberation and now it can                                 continue to do this from the first                                 children of the parent which matches the                                 given parent filter something like that                                 okay let's summarize let's break down                                 the comparative performance of these joy                                 and implementation searching by query                                 time join is slow and the question is                                 why it's so slow there are two reasons                                 there isn't not number one because it it                                 in cold expensive operation of Durham                                 look up many times so it's not what Lucy                                 interim dictionary was created for and                                 the second problem is that it always                                 looped through all children and then                                 search for parents then even you supply                                 highly selective parent filter it can                                 not any help speed up the joint                                 operation these are two issues with the                                 current Joyner to query time Jen and                                 blog join which is indexed and during is                                 pretty fast right because it doesn't                                 heat any expensive data structure it                                 doesn't hit any expensive operation it's                                 just pretty lightweight and always it                                 utilizes the leapfrog algorithm to                                 execute joint operation in the most                                 efficient way and more than that you                                 don't need to care about selectivity of                                 the filtering stents tenant statements                                 the scene does it for you automatically                                 and it's it's perfect there is some cost                                 of in index inside the most often                                 question about join what do I need to do                                 if I need to update some entities in                                 joint operation so in case of paratime                                 join you need to bother about it at all                                 there is                                 zero indexed and burden right he just                                 cost you nothing and in blog Joe and                                 there is an issue right because you need                                 to establish it you need to keep this                                 constraint of blocked index you cannot                                 just reindex single children right in to                                 reindex roadblock and it might seem snot                                 as a big deal at all because leucine is                                 quite performant in index time and for                                 example we can say that there is no                                 difference in rain indexing performance                                 between single document and between we                                 indexing damn talking it it's really                                 hard to evidence the difference between                                 cost of these really reindex in but in                                 some edge cases for example if you have                                 really huge blocks it might be a big                                 problem so as as I said you always need                                 to enlarge the scope of index update and                                 for example if your blog has really huge                                 for example thousand document then                                 instead of updating let's say a thousand                                 of children you need to reindex all                                 their block and you might end up with                                 updated millions of documents it might                                 be sensible costs and the second problem                                 is it that from just system design it is                                 not convenient property at all what we                                 have usually we have separate system                                 which runs some sort of business process                                 react to events and search engine and                                 business process just want to tell our                                 indexing part just please reindex one                                 document I have some changes and with                                 the blog draw and design search engines                                 needs somehow realize what is the source                                 data for nearby documents right it                                 usually need to call the document                                 storage for the                                 natan sibling documents and in some                                 architectures is not what we can afford                                 I have one more concerned about blog Joe                                 and regarding query time but I just I                                 feel it a little bit subtle concerned so                                 I want to skip it for now let's discuss                                 it somewhere later so blog John is                                 perfectly in query time so and then I                                 tried to find the algorithm to develop                                 the tailgate which will be somewhere in                                 the middle because it's not possible to                                 be faster than block join right that's                                 what I try to pursue in my research and                                 the idea was to provide Joe an index in                                 in the scene the idea is straightforward                                 I will want to use a same doc values                                 column but I wish to put not external                                 IDs in this column but i want to put                                 document numbers in it now I don't need                                 to run the expensive step of resolving                                 the external IDs to talk numbers so I                                 just need to put them in to put the talk                                 numbers of the associated parents in doc                                 values column but there is problems                                 because it's not even it's not possible                                 english seen api right now i cannot                                 supply document numbers as a source date                                 of my documents that's why I find the                                 workaround I apply updates in two stages                                 so first I index the source data and                                 then i apply join index to this column                                 by updatable de cuales so i can reindex                                 whoa column its recent feature in lucene                                 and if I if I able to do that and put a                                 document numbers of the associated                                 parents in doc values now the joint is                                 pretty straightforward I need to loop                                 through children documents and just                                 collect parent document numbers then I                                 have to sort it now it's mandatory step                                 because recently out of order collecting                                 was prohibited in in the scene so but                                 now nevertheless is the process of joint                                 operations is quite simple with these                                 index then we just sort associated                                 parent IDs and intersect with parent                                 filter but more than that here is an                                 opportunity if you use binary the                                 queries we can put a whole list of                                 associated children in the cell of                                 binary the quarians column and now we                                 have an opportunity to start during                                 operation on opposite way on more                                 efficient way if we have highly                                 selective filter like this then we need                                 to just loop through few parents and                                 check the associated children for                                 intersection with the given children                                 fielder and Rob parents into result if                                 it if they intersect okay I spoke about                                 this prototype at odeon and recently I                                 found quite interesting JIRA it's about                                 reporting global ordinal query time                                 joint from elasticsearch to loosen it is                                 pretty interesting it's a shame shame                                 shame on me that I didn't know about it                                 so let's look into it it's pretty                                 interesting thing it's called global                                 original query time join so it works                                 almost like we're time join but it uses                                 sorted dog values do you know what the                                 feature in sorted Dok levels why it's                                 necessary did know about them so they                                 was developed for providing sourcing by                                 field value for                                 example if you need to sort your                                 document by some product name for                                 example in this case instead of sorting                                 by strings because comparing strings is                                 expensive operation during index time                                 for every such column leucine builds                                 separate index where it collect all                                 values from this column data placate                                 them sort them and assign ordinal                                 numbers and then it's tour these numbers                                 in the column and right now if we need                                 to sort by this column we can compare                                 numbers and sort by numbers which is                                 quite cheaper than comparing strings so                                 and these query utilizes this pretty                                 cool structure what it does it loops                                 children and obtain the associated                                 ordinal numbers of parent keys something                                 like this and it also drops them into                                 accumulator but in case of ordinals                                 accumulator is pretty straightforward                                 it's just a bit set it's much more                                 compact and efficient data structure and                                 it is second stage it loops through                                 parents and does the same thing it's                                 obtained the original number of the                                 parent key and check the beat set for                                 intersection let's go it recognizes that                                 any of the children has the same value                                 of the parent key so and now let's                                 compare all the implementation here's a                                 URL to loosen fork where I put my                                 implementation of joining the xquery and                                 where I extended the lucene benchmark                                 model to benchmark join algorithms                                 these are not great hardness but it                                 warps and does well what we need so I'm                                 able to run pretty fast benchmarks for                                 all these queries so what we see here                                 blog joe and outperforms query time join                                 and it's what we expect but it worse to                                 mention that benchmark is not really                                 representative what I evidence at                                 practice that blog joe and outperforms                                 quilt and join at orders of magnitude so                                 it's way faster it's more faster than                                 several times might be further in ten                                 times and even more now nevertheless it                                 these being small benchmarks show us                                 something which is related to the                                 practice now you can see that join index                                 perform pretty well it performs better                                 than join with you and here it seems                                 like joint index faster than global                                 ordinals query it's not correct is not                                 true because I had to apply updates for                                 join index in quite rarely so all these                                 three queries from leucine ping bed                                 bench market by frequent updates by two                                 times per second and I have to apply                                 updates to join index in much lower rate                                 because of the problem with updates                                 which I will discuss later so what we                                 see that join index is a perspective                                 idea but there is a big problem visit so                                 right now I cannot apply updates                                 incremental II but we also see that                                 global orginals it Cooper it's a great                                 and performant query time join and I                                 quite recommend it to use instead of                                 plain old query time join ok here is                                 comparison chart during index fast and                                 global original query also fast but                                 lockjaw and faster anyway because blog                                 Joanne can join in boss direction a so                                 it joins in most efficient way and it it                                 joins themselves you don't need to                                 choose the efficient wave for                                 enumeration ok global orginals has                                 almost zero cost for update and there is                                 a big problem with applying updates on                                 joint index the reason is that just for                                 simplicity just make simple prototype I                                 fully recalculate the full column of joy                                 and index every time you apply any                                 update so I didn't reach the initial aim                                 and somewhere in the middle of the way                                 but it's proved the general idea and                                 they still consider it this perspective                                 and here are revised plan I plan to work                                 in in in incremental join index update i                                 think it's possible that will allow us                                 to join in both direction to execute                                 join operation in the most efficient way                                 which is not possible in a global                                 original join so far and i need need                                 need to upscale the benchmark to                                 highlight the hardest the thickest of                                 kinds of every implementation so current                                 pinch mark is too small to represent any                                 real challenges for queries                                 the soul for from me for today we lookin                                 to join implementations we've lookin to                                 joint problem in general I give you an                                 example of how we can use updateable dog                                 values but it's not the proper way to                                 use them but they recommend them for                                 using in your application it's pretty in                                 interesting feature and there wasn't                                 some ideas for speeding up query time                                 join if you struggle with it performance                                 but now they're all legacy and absolute                                 they don't have much sense now I can                                 recommend to use global ordinals join if                                 you need fast query time join here are a                                 few references if you won't go deeper in                                 these and all these problems and here is                                 a shortcut to access the slides if you                                 wish so now I'm open for questions we                                 have some time left k you are welcome                                 why that's the questions and thank the                                 speaker thank you thanks for your time                                 you
YouTube URL: https://www.youtube.com/watch?v=z1RqZsjhIMM


