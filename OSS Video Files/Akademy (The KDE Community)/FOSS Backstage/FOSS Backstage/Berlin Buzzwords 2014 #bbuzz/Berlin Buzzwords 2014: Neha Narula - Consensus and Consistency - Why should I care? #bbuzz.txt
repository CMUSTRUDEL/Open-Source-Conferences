Title: Berlin Buzzwords 2014: Neha Narula - Consensus and Consistency - Why should I care? #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	We've all heard about the infamous CAP theorem, and how it's impossible to "beat". But what does that really mean? Should we throw down our keyboards and give up on running a distributed system?

This talk will discuss consensus protocols, the actual definitions of every letter in that acronym, and what real issues come up when it comes to running a performant, correct, distributed system. If you've ever wondered why Paxos has to be so complicated or what "partition tolerance" really means this talk is for you.

Read more:
https://2014.berlinbuzzwords.de/session/consensus-and-consistency-why-should-i-care

About Neha Narula:
https://2014.berlinbuzzwords.de/user/324/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              okay hi hello everyone so my name is                               Neha narula and I'm a PhD student at MIT                               and I'm here to talk about consensus and                               consistency so first a little bit about                               me in former life I was a software                               engineer at Google and I worked on a                               bunch of different products there                               including a shopping website which we                               launched in Germany that was fun frugal                                um and a storage system for large binary                                objects and then for the past six years                                I've been a PhD student at MIT and while                                a bit at MIT have been working on                                systems and more specifically been                                focused on systems which make various                                consistency trade-offs so specifically I                                worked on a distributed query executor                                so for sequel databases I worked on a                                cache which stores precomputed data and                                most recently I've been working on a                                concurrency control mechanism for                                multi-core databases so what this talk                                is going to be about it's going to be                                about consistency okay and specifically                                why we need it so I'm going to try to                                make an argument to you the consistency                                is important and that we shouldn't just                                throw it out the window I'm going to                                talk briefly about the different types                                of consistency and then get into the                                problem of consensus which is                                distributed consistency finally speak a                                bit about the cap theorem and what it                                actually means and then finally give a                                little bit of a few thoughts on how I                                think we should actually deal with all                                this and what we should do going forward                                so okay consistency well the way that I                                like to think about it is when you're                                building your application how bad can                                things get and that is your answer to                                what kind of consistency you're willing                                to deal with um so here's a very classic                                example this is a comments on an unnamed                                social network and what has happened                                here is this guy posted a comment and                                it's somehow appeared four times it                                turned into many comments and so there's                                many different reasons why this could                                have happened maybe an application web                                server didn't get a reply saying the                                comment had been received successfully                                and so it kept trying over and over                                again maybe for some reason this guy's                                request went to one data center and then                                failed and then went to another data                                center and then                                another one and this is how they got                                reconciled together you know this is a                                reconciliation technique issue just                                merge all of the rights um and then you                                know the point here though is that                                what's happening is the datastore is                                happily taking each of these as a new                                comment and that is not what the                                application intended but this is pretty                                innocuous right I mean you know who                                cares if I don't get the message that my                                mom liked my status on facebook this is                                not the end of the world these are                                social networks right but what about                                more critical applications on the web                                for example let's say we had a                                completely decentralized currency where                                there's no way to undo transfers um in                                situations of fraud as an example so                                remember how in the news recently have                                you guys heard about how a lot of                                Bitcoin exchanges have been going under                                is that is that something you guys know                                about right um you know lots of times                                because they suffer some sort of attack                                some kind of hacker hacking attack and                                they someone transfers out a large                                amount of Bitcoin into their own                                personal wallets well I've been looking                                into this a little bit and I found an                                interesting example you know usually                                these are described as security attacks                                like the security on the website wasn't                                good enough but here's what happened in                                at least one case and this is with an                                exchange called polini X and this is a                                quote from an ARS technica article and                                the quote says the hacker discovered                                that multiple simultaneous withdrawals                                are processed essentially at the same                                time and that the system software                                doesn't check quickly enough for a                                 negative balance so this is not a                                 security problem to me this is a very                                 classic transaction problem this what                                 you want here is you want to be able to                                 do the check and the decrement                                 atomically you want them to happen                                 together and for whatever reason I don't                                 know the details of this implementation                                 that wasn't happening but we know how to                                 build systems that do this this is not                                 an unsolved problem and that's the point                                 of consistency consistency guarantees                                 help us reason about our code and avoid                                 subtle bugs um so the word consistency                                 unfortunately has come to mean so many                                 different things in computer science I                                 think it's one of the most misused words                                 ever so there's the sea in acid so                                 consistent acid stands for atomic                                 consistent isolation and durable and it                                 describes transactions in a database                                 these are the four properties that                                 transaction should preserve and when you                                 see the sea and acid that's actually a                                 very specific type of consistency what                                 that means is that once a transaction                                 completes the database should be in a                                 consistent state and that is dependent                                 upon whatever the application developer                                 decides the consistent state is like as                                 an example maybe some key value should                                 never go below zero and so if a database                                 is consistent and you write your                                 transactions correctly as a developer                                 then that means that at the end of every                                 transaction the guarantee will be                                 maintained that a balance never went                                 below zero but it that's like a very                                 specific type of consistency that                                 involves application constraints then                                 there's consistency as in the cap                                 theorem ok so this stands for                                 consistency availability and partition                                 tolerance and this is consistency in the                                 case of multiple servers so the previous                                 one we can talk about consistency in the                                 case of one server too so in one server                                 we can totally screw things up and not                                 have consistency so the cap theorem                                 really addresses really relies in the                                 definition of consistency that applies                                 to many servers and what it means is                                 that what it's essentially saying at a                                 high level is to maintain consistency                                 you may have to halt perhaps                                 indefinitely instead of just going ahead                                 and processing or reading the right                                 we'll get we'll get more into this later                                 um and then finally there's many                                 different types of consistency with                                 varying guarantees and really what all                                 of them are trying to describe are an                                 execution of reads and writes and what                                 is valid to be returned so if you issue                                 some reads and writes to a system what                                 are valid results so um you know a lot                                 of people think the mechanisms to                                 enforce consistency are too strong and                                 that it's not worth building it into our                                 systems but actually you know there's a                                 mechanism at work enforcing consistency                                 on every single reading right of every                                 single computer and that is cache                                 coherence so cache coherence is provided                                 by our hardware and the idea is that our                                 hardware is automatically keeping                                 individual processors l                                               date and keeping them consistent as                                 they've read and write from central                                 memory and as we move into the age of                                 multi-core these caches become more and                                 more important it becomes very important                                 that processors can access caches                                 locally and read and write data locally                                 because memory accessing memory can be                                 hundreds of thousands of times more                                 expensive um has anyone here ever tried                                 to program a system without cache                                 coherence yeah I think it would be a                                 nightmare I think it would be absolutely                                 horrible um the fact that our Hardware                                 provides this for us lets us reason                                 about our program and pretend like it's                                 running on a single processor and that's                                 really important so the type of                                 consistency that cache coherence tries                                 to provide is sequential consistency so                                 you might see this term around and                                 actually cache coherence doesn't provide                                 this but what's that's like a whole                                 nother talk so let's just go with this                                 for the moment and what sequential                                 consistency means is that the result of                                 any execution of reads and writes is as                                 though they happened in some order so                                 there's some ordering to the reads and                                 writes like someone wrote x equals                                       someone read that x equals one and one                                 key thing here with sequential consensus                                 consistency is that order doesn't have                                 to match time and we'll see what that                                 means in a bit but order does have to                                 match what each processor sees and so                                 that means that if multiple processors                                 are reading and writing the same                                 location in memory and interleaving                                 their reads and writes sequential                                 consistency says that the processor                                 should see the reads and writes in the                                 same order and so here's an example okay                                 so here we have four processors p                                  through p                                                                a                                                                       X ok and so what's happening here is                                 that p one's writing x equals a p                                     writing x equals bp                                                     p for reads bna as well so okay based on                                 what i said is this sequentially                                 consistent what do you guys think                                 how many people think it is how many                                 people think it isn't oh okay Wow okay                                 so actually this is sequentially                                 consistent um and I find this incredibly                                 confusing as well and the reason it's                                 sequentially consistent is because we                                 are allowed to reorder things if we want                                 to with sequential consistency as long                                 as it matches what each process sees and                                 it still makes sense with the values                                 returned and so what we can do here is                                 we can basically pretend like p                                  actually wrote a later and p                                           be first and the reason we can do that                                 is because p                                                          issuing these rights off into the ether                                 you know they have no idea when they're                                 right happened they don't do a read to                                 actually see that they're right you know                                 happened at this point in time at that                                 point in time and so under sequential                                 consistency we're allowed to reorder                                 this and then all of a sudden this                                 execution makes sense right be read be                                 right a read a um so I I find this                                 extremely confusing and yet that's the                                 form of consistency most of us operate                                 under actually most of our machines most                                 of our systems they don't even provide                                 that but um but there's this better form                                 called external consistency and                                 basically this says that results match                                 time and so what this means is that you                                 can imagine as though you had an                                 external observer looking at your system                                 from the outside and if an external                                 observer reads in your system and sees                                 that the value of a variable is                                 something that has to be preserved and                                 so in this example we can see that it's                                 not externally consistent and the reason                                 for that is that it makes little                                 external observer could come along and                                 notice that hey that right to be                                 actually happened after the right to a                                 in terms of time that is how it happened                                 and so then when this happens the                                 external observer will note that like                                 nothing makes sense well why does it                                 look as though the right to be happened                                 before the right day and so this                                 execution is not externally consistent                                 even though it is sequentially                                 consistent so I've been talking about                                 everything in terms of multiple                                 processors on a single machine right now                                 but when we move this into the                                 distributed setting things get even                                 crazier so instead of shared memory all                                 we have is communication we have                                 replication but we don't have hardware                                 cache coherence to help keep replicas                                 up-to-date                                 and time kind of becomes the fights                                 fuzzy concept and so because of this and                                 because it's so much harder to deal with                                 consistency in this context people have                                 introduced the idea of eventual                                 consistency the sky from amazon amazon                                 CTO werner vogels has written about this                                 extensively and the idea here is that if                                 no new updates are made to an object                                 eventually all accesses will return the                                 last updated value and the thing here is                                 that actually time like I said it's a                                 fuzzy concept in a distributed system so                                 who knows what last even means um and                                 also this is what always gets me about                                 the definition of eventual consistency                                 when do we stop writing to things like                                 when do we just freeze and let the                                 system coalesce I don't think that                                 actually really ever happens in real                                 systems so eventual consistency is like                                 it's a very fuzzy concept um and so when                                 we actually want chunker consistency                                 guarantees in a distributed system we                                 turn to the problem of consensus and                                 consensus is the idea of everyone                                 agreeing on the same value and so the                                 most famous consensus algorithm                                 obviously is paxos ah how many people                                 have heard of paxos ok great ok so                                 really quickly going to go through this                                 invented by Leslie Lamport he recently                                 won the Turing award and park for this                                 algorithm which is amazing I mean the                                 idea is that you know someone proposes a                                 value and sends it to the other servers                                 in the system they receive it and if the                                 unique number included with that value                                 is higher than anything they see and                                 they say okay and then the guy few years                                 from majority says okay well everyone                                 then accept this value and they say okay                                 and then this guy knows that the value                                 has been decided all based on majorities                                 so pretty simple algorithm two phases                                 make sense um the idea what Paxos is                                 that we can handle conflict so if two                                 proposals happen at the same time given                                 the fact that we're dealing with                                 majorities here only one proposal can                                 win only one proposal will have a higher                                 number and it will talk to a majority of                                 servers and it can end that keeps us                                 from deciding to different values for                                 the same at the same time and this is                                 the paxos algorithm so we can see here                                 it's actually not that complicated so                                 this is from the distributed systems                                 class at MIT the students have to                                 implement paxus in a lab and this is the                                 entirety of the pseudocode this is what                                 they do it fits                                 one slide um but unfortunately one                                 instance of agreement is not really                                 enough in our distributed systems today                                 what we really want is this global log                                 primitive and that means that each                                 operation is seen as a read or write in                                 the log everyone agrees on the log and                                 the ordering of the log and then                                 everyone applies those operations in                                 order and so that's we can get external                                 consistency doing this because instead                                 of using time to order our operations                                 we're actually running a round of                                 agreement for everything that's                                 happening in the system in order to                                 agree on the order in which things                                 happen in addition to Paxos there's a                                 couple of other algorithms that do this                                 Zab by zookeeper and view stamped                                 replication and so so like I said this                                 is externally consistent an outside                                 observer can look at the log and see                                 exactly what the values are for the                                 entire system and so what does this have                                 to do with a cap theorem well paxus lets                                 us guarantee correctness with a                                 functioning majority but it does not                                 guarantee liveness and liveness is the                                 idea that things will progress that the                                 system will make progress and so okay                                 here's the cap theorem the cap theorem                                 was born of Erik Brewers pudsey talk in                                                                                                   availability and partition tolerance                                 choose to the idea here is that                                 partition tolerance is a failure model                                 okay and really what this theorem is                                 saying is you make a choice can you                                 process reads or writes during a                                 partition or not do you want to go ahead                                 and process them and possibly get things                                 into an inconsistent State where'd you                                 rather stop and wait and this is based                                 on actually based on a paper written in                                                                                                    called the impossibility of distribute                                 consensus with one faulty process and                                 what this paper saying it's a                                 distributed algorithms paper is that                                 under an asynchronous model we can't                                 tell the difference between a message                                 being delayed and a machine failing that                                 is the core of the cap algorithm or the                                 cap theorem right there that right there                                 it's this idea that you can't tell if a                                 machine just taking a really long time                                 or if it actually failed and and so what                                 this means is that if one machine fails                                 at exactly the wrong time                                 if another machines fails exactly the                                 wrong time and this continues to happen                                 then then we'll never reach consensus                                 and so it's an impossibility result you                                 know it doesn't mean that this it's                                 impossible to reach consensus ever it                                 means that um you know I mean it means                                 something else and so so you know we                                 hear about the cap thermal you think it                                 means we just can't have it all you know                                 we can't have correct data and                                 availability and partition tolerance um                                 well so here's an analogy that I really                                 like so have any of you ever play candy                                 crush okay so I haven't actually played                                 it but I played a lot of other tiling                                 games um and it turns out that this                                 class of games is np-hard did you know                                 that so theoretically this class of                                 games is unsolvable given all the time                                 in the universe we're not able to solve                                 these games yet do we play these games                                 do we enjoy them yes do we even                                 sometimes beat them um and so what this                                 means for the cap theorem is that it is                                 impossible to one hundred percent of the                                 time decide everything on the internet                                 if we can't rely on synchronous                                 messaging but we can one hundred percent                                 of the time decide everything if                                 partitions heal which means that we know                                 the upper bound on message delays and we                                 it's not actually asynchronous messaging                                 it's synchronous messaging um I think                                 this is a really key idea that's often                                 ignored and when you talk about the cap                                 theorem is that if we know about on                                 message delays we're actually the result                                 actually doesn't hold um yeah and so we                                 can still play candy crush um and and                                 and so I think the real question which                                 we should be talking about and running                                 out of time is that we should really be                                 looking at consistency versus                                 performance not consistency versus                                 availability how do we reduce the number                                 of messages you know Paxos had a ton of                                 messages how do we reduce that number                                 while still producing a correct ordering                                 and handling failures in making progress                                 um and so one example of of where they                                 actually went in the other direction                                 from you know no sequel and went back to                                 sort of consistent systems is with                                 Google spanner the giant distributed                                 database and they said we believe it's                                 better to have application programmers                                 deal with performance problems do the                                 overuse of transactions rather than                                 coding around the lack of transactions                                 so consistency is really important it's                                 it's it's vital for us to reason about                                 our code um and so in summary we should                                 be thinking about how to build fast                                 systems that preserve consistency and                                 then the slides will be available                                 there's a little bit of further reading                                 and that's it and I might have a minute                                 or two for questions Thanks yeah                                 questions ok so I really liked that last                                 statement but I mean Google was kind of                                 in a unique position to go that way                                 right they had a lot of money that I                                 could throw on the data centers at these                                 really high precision clocks to everyone                                 and so on so what do you do unless                                 you're in the same position or would you                                 say you are encouraging amazon and have                                 a host status send us to add these                                 clocks as well and often it now I to                                 people I understand what you sub for                                 people who don't know spanner uses                                 atomic clocks so they bound the amounts                                 that clocks can drift and that lets them                                 do a lot of really cool tricks and the                                 answer is yeah we don't all have a Tom                                 o'clock so you're right but there are                                 still other tricks that we can play so                                 there's a ton of optimizations on paxos                                 people are still doing research in this                                 area to reduce the number of messages                                 within a data center it might be more                                 reasonable to talk about bounded clocks                                 instead of across datacenters I guess                                 spanner might might not be the answer                                 for everyone but i think it's evidence                                 that we should be going in this                                 direction whole questions if not thank                                 you very much thank you
YouTube URL: https://www.youtube.com/watch?v=JAqnDwXGnSk


