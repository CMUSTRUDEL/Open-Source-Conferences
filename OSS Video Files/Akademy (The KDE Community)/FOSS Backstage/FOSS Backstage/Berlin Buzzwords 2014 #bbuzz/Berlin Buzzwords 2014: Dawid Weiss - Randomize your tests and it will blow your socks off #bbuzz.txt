Title: Berlin Buzzwords 2014: Dawid Weiss - Randomize your tests and it will blow your socks off #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	Apache Lucene, Solr and ElasticSearch all utilize the concept of randomized tests. These tests have helped in locating and fixing a number of bugs -- and not just in these projects, but also in third party libraries and JVMs the tests were executed on. 

In this talk I would like to explain what test randomization is about and what kind of tools Lucene, Solr and ElasticSearch use for randomized testing. The ambitious goal is to make you, dear listener, leave the talk with hands burning to implement these ideas in your own projects.

Read more:
https://2014.berlinbuzzwords.de/session/randomize-your-tests-and-it-will-blow-your-socks

About Dawid Weiss 
https://2014.berlinbuzzwords.de/user/277/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              alright so we will start a little bit                               out of time good afternoon my name is                               David vice I work for carrot search and                               let me quickly quickly introduce myself                               so I like coding I like cycling I like                               baking cheesecake but most of all I like                               just to chill which seems to be a family                               feature because my son somehow inherited                               it we're doomed man anyway uh today I'd                                like to tell you a little bit about the                                testing paradigm found in lucene                                elasticsearch and solar which is based                                on randomizing tests randomizing how                                they execute so this talk is actually                                going to be shorter than my planned I                                thought it would last like                                           and I only got                                                      fast forward a little bit some of the                                slides later on but basically I'd like                                to tell you a little bit about what                                randomized testing is and how we use it                                in the scene what the foundations are so                                the introduction as a historical node                                which leads me to the conclusion of the                                introduction which is you know it's                                really serious about those                                           anyway so the unit tests like I said                                before uh you know they have they serve                                three purposes they increase the                                confidence in implementations so if you                                wrote the unit test you ran your                                software it passes it diffuses your                                confidence in your tests in your                                implementation obviously there is a                                correlation obviously well we think                                there is a correlation between the                                number of unit tests and the reliability                                in the software and most of all it                                provides insurance against future                                changes so if you change something in                                your code and you have lots of unit                                tests covering a lot of you know code                                execution paths you can kind of rely on                                future changes if something interview to                                change changes either you change it or                                somebody else changes it and those tests                                still pass you can be confident that the                                software is still okay but there's there                                is a big problem namely unit tests                                relying on assumptions you by writing                                unit tests you                                typically embed your own assumptions                                about the world and the software and                                this really doesn't match with the real                                world offers so for instance if I give                                you this snippet of code and watch this                                the hardware zoom ah if I show you this                                snippet of code can you tell me can you                                see it in the back all right can you                                tell me if this can ever had failed like                                what what's the catch here okay the                                catch is this function this this one                                math apps like the absolute value of a                                number of an integer what's the catch                                the catch is math apps can actually                                return a negative number which many                                people wouldn't think possible right but                                if you pass it min value there is no                                positive counterpart of min value within                                the inter Ainge so it just returns the                                min value so apps is not returning a                                positive number it returns the negative                                number and this example can actually                                fail with an array index out of bounds                                exception which you know is like what                                but it can happen so generalizing this a                                bit what you think about your code                                depicted here with this blue rectangle                                and what do you think about your                                assertions depicted here with the red                                you know lines and circles these are far                                off from what the real world is actually                                like I mean the test still passes it                                just does things that you wouldn't think                                are at actually happening or it doesn't                                do things that you think it should be                                doing so just to you know just to make a                                parallel to the real world you you ride                                a car and you listen to song listen to                                this song and radio and you have this                                heavenly you know female voice and you                                have this perceptual image of this girl                                sing in it but then it turns out it's                                the Eurovision Eurovision winner of                                Conchita forest which you know amazingly                                it's just it's like an improbable event                                you know but it all goes well with                                Murphy's Law I mean you know if if there                                is if there's an improbable chance of                                 something happening it will eventually                                 happen and it will eventually happen in                                 your code at the wrong moment                                 so we will try to kind of face this                                 problem and provide an answer for it                                 with randomized testing what is                                 randomized testing first of all it is                                 not a priority i'm shifting because                                 people are afraid of departing from what                                 they know so they know unit tests they                                 are afraid of departing from those                                 familar et zone they are you know                                 comfortable in their own of in their                                 domain of unit tests and they don't want                                 to try anything else it's not a paradigm                                 shift there are still unit tests there                                 are just a slightly different ones and                                 and another thing randomized test in                                 randomized testing it's not mutation                                 based so there is no uncontrolled                                 changes introduced to your software you                                 are in full control over what that                                 randomized test would like will actually                                 be doing the only thing changing is that                                 there is a seed of randomness and there                                 is some you know random choices of                                 components of data but you still are in                                 control over what's being randomized                                 which is contrary to the pie test for                                 instance if you know the package pie                                 test it's not what pie test is doing so                                 what is randomizing randomized testing                                 about what's the main points of it well                                 there are three first ideally we would                                 like our tests to run a different                                 execution path on every execution so                                 every execution will run a different set                                 of you know code paths through your                                 program this is done by either                                 substituting components of runtime or                                 substituting data diversifying data fed                                 to the program how it's done I'll show                                 you in a bit the next thing is each run                                 has to be deterministic so it's                                 randomized but it's not random it's                                 pseudo randomness you know if you start                                 from the same initial seed of this                                 randomness every single execution is                                 repeatable should be repeatable you know                                 in an ideal case and then the third                                 point is since this it's essentially a                                 stochastic process so every single                                 execution will be different and you just                                 need a lot of samples over the search                                 so you need to run those builds                                 continuously over and over on a build                                 server it's not just on commit run the                                 test it's over and over again because it                                 increases your coverage it increases the                                 you know the coverage of the search                                 space of those randomized parameters                                 that you're going to put in your code a                                 valid question would be why not just                                 test everything like all the                                 combinations of you know inputs all the                                 combinations of components and the                                 answer is it's typically just not                                 possible I mean there's just so many of                                 them that you know the search space is                                 so large that the taste that the test                                 would take forever to execute so we're                                 going to sample from this space and run                                 those tests at a fraction of the cost                                 and still kind of ensure that they work                                 maybe not on the first run maybe not in                                 the second but eventually you know the                                 worst thing conchita wurst will happen I                                 mean something will happen so um now                                 let's get down to the bottom of it what                                 can we randomize at the unit test level                                 and how can we assert what can we you                                 know what type of assertions can we add                                 to our code that somehow verify whether                                 to test actually execute it in the right                                 way if the inputs are randomized so if                                 the inputs are changing how do we add                                 assertions that are verifying that                                 something went right or wrong let's                                 first handle the first part so the most                                 obvious thing that we can randomize is                                 our input data iteration counts and                                 arguments if you have a component that                                 accepts a string don't feed it just esky                                 I characters you know don't feed it just                                 ABC feed it a random Unicode sequence of                                 characters that is valid but not obvious                                 if you have a component that has in the                                 contract that the methods can be called                                 an arbitrary order to call it in                                 arbitrary order you know randomize the                                 the sequence of method calls and let it                                 run I mean you know don't hardcode just                                 one particular sequence let it run                                 randomly if you if you have other our                                 game                                 is that are possibly constrained but                                 from a range of values randomize them                                 run the tests here we have some examples                                 from leucine for instance the iteration                                 counts ah you know we picked them at                                 random if there is something that runs                                 that can run many times we pick at                                 random the number of times that it you                                 know is invoked with and run it the same                                 thing goes with the parameters you know                                 we picked somehow we pick random strings                                 somehow we pick simple strings somehow                                 we pick sometimes we pick longer strings                                 it all it's all within the constraints                                 and within contracts of a given                                 component but tries to search the whole                                 space of possible possibilities the next                                 thing you can randomize is software                                 components an interface is a prime                                 example of this if you have an interface                                 there should be multiple implementations                                 of that interface do substitute those                                 implementations at test time so that a                                 test written for an interface is not                                 just running against this one particular                                 implementation but it's being fed with                                 different configuration of you know                                 implementations of those interfaces with                                 one interface this is pretty obvious but                                 if you have multiple interfaces in your                                 program and multiple implementations in                                 your program again the search space the                                 number of different configurations goes                                 sky-high and then you the only thing you                                 can do is actually probe those random                                 configurations of components lastly the                                 environment you know this is this is the                                 most obvious thing to randomize                                 randomized locale randomize the time                                 zone the JVM itself you know sometimes                                 the JVM is the source of a bug that you                                 don't know if the operating system if                                 you're running on Windows it will behave                                 differently from other operating systems                                 anywhere in the world so our exceptional                                 triggers you can also add some like                                 bonus things like IO like cause random                                 i/o problems or network problems but                                 these are far advanced for this talk so                                 I'm not gonna dealt there now how to                                 assert on those randomized you know                                 puts what how do we build assertions                                 there are a few ways to handle that                                 first if you have a component if you                                 have a piece of software and you have a                                 number of different implementations                                 again either a naive implementation or a                                 previous version of a component that is                                 not optimized feet the same input to                                 both of these and compared the outputs                                 you don't know you don't need to know                                 what these outputs are they just need to                                 be identical you know if you have a                                 sorting algorithm feed it with the                                 sequence of integers it should be sorted                                 in the output the next thing you can do                                 is sanity checks so what this boils down                                 to is basically throw some and your                                 software and wait for it to hit the fan                                 basically that's what it is you know you                                 randomize the input throw it at your                                 program and wait for an insertion to                                 happen if it happens correct the bug if                                 it doesn't happen fine you know nothing                                 nothing wasted and lastly you can do                                 nothing and this is the you know the                                 stronger version is the previous one                                 which is you don't assert on anything                                 you just wait for an unchecked exception                                 for a JVM crash which happens a lot in                                 the scene if you're tracking the build                                 logs it's surprising how the world                                 actually spins with all the JVM bugs                                 that we discover notoriously all right                                 so that was the theory now the practice                                 if you take a look at the scene there                                 are a number of quality assurance                                 components some of them divided between                                 the static checks and the runtime checks                                 static checks over we'll be talking                                 about so I'll skip these and runtime                                 checks are we have a number of rules in                                 lucene test case that are really                                 interesting if you're if you haven't                                 seen a really complex your unit system                                 lucene test case is the class to take a                                 look at there are rules for detecting                                 static memory leaks stray threads                                 temporary file cleanups it starts with                                 such a lots of interesting things there                                 I just don't have the time to cover them                                 all the one I would like to focus on is                                 randomized runner which is r.j. unit run                                 therefore running tests so it's                                 essentially something that runs takes                                 your J unit tests and runs them what                                 were the goals for this                                  first of all compatibility so if                                 you know j unit you can run those                                 randomized tests there's nothing special                                 about it the only thing you need to do                                 is to add one annotation the second                                 thing is it provides some helpers that                                 you know help you to organize this work                                 with randomized testing first of all it                                 picks the random seed the initial random                                 seed for every test and the second thing                                 is it provides you with that seat                                 otherwise you wouldn't know how to                                 repeat a test in case of a failure there                                 is also other things that are part of                                 the package that I won't be going into                                 because it's a                                                       you're interested catch me somewhere and                                 I'll gladly explain them to you so an                                 example an example we have two classes                                 here I know if you can see them can you                                 okay we have two classes here are six                                 Tests that the what makes it run with                                 the randomized runner is the annotation                                 on top it's the standard j unit                                 annotation run with provided with the                                 randomized runner class that runs those                                 tests in that randomized environment and                                 what even this does is you know if you                                 run it in eclipse three times every                                 single time you run it you notice that                                 the order of tests the order of test                                 methods changes so if you compare the                                 first one to the second one to the third                                 one every execution is different and                                 what it depends on is it depends on this                                 master seed that was picked by the                                 framework at the beginning of the                                 execution of the test so this master                                 seed here is different from this one is                                 different from this one and what                                 important is if you pick the same master                                 seed over and over the execution the                                 order of those methods will remain the                                 same so it's predictable it's                                 pseudonymous it's not you know random                                 it's pseudo-random but you get you you                                 get the control over which starting see                                 that starts from okay so you would                                 probably want to utilize this this                                 randomness somehow since you're                                 you're about to write a random test this                                 is how it's done it can be done in a                                 number of ways you know with those                                 utility methods so you don't have to                                 know anything about the internals or you                                 can explicitly call for the randomized                                 context which is the context that                                 provides you with those random                                 generators random number generators and                                 then you get a random and then you just                                 use that random you know you just pick                                 whatever values or whatever inputs you                                 want for your program and run your                                 program with those values here we have                                 an example that asserts true on a random                                 variable what should this test do well                                 it should Tet it should fail on every                                 other run right so if we run it in                                 eclipse chances are it will run                                 successfully but from time to time it                                 will fail and now comes an important                                 part of the framework because if a test                                 fails you need to know what the master                                 seed was otherwise you won't be able to                                 repeat the same sequence of operations                                 and what's cool about it is that any                                 exception thrown from a unit test with                                 the randomized runner you know running                                 above it will have this synthetic stack                                 trace entry that contains the seed which                                 is here so all you need to know is this                                 seed and then repeat the test and it                                 should predictably run in the same way                                 and it should be able to figure out what                                 was wrong if your test never ends which                                 means you know it hung somewhere it's                                 froze somewhere you can still get the                                 seed because you can ping it and you can                                 dump all the stack traces and one of the                                 threads will have the seed in its name                                 so we can still get the seed even though                                 what is it safe haven                                                   you so uh alright so now once you've hit                                 a failure you have to face the ball I                                 mean you have to face the bout and                                 sometimes the bug or the boo will turn                                 your world upside down ah but you do                                 have a chance of reproducing it right                                 you know the master seed all you need to                                 do is fix the master seat either with an                                 annotation on top of a class                                 or bypassing assistant property with the                                 seed embedded in it you can also repeat                                 the framework allows you to repeat a                                 unit test a number of times so if you                                 run this ah take a look at the slide                                 it's the repetition of that single test                                                                                                    starting from the one you've provided so                                 this this seed is identical to what                                 we've provided in the annotation every                                 other one is different they are split                                 between the static context and instance                                 context i'm not going to go there but                                 every other execution is different and                                 you can see that you know pretty much                                 fifty percent of the test failed this is                                 a good information because it means that                                 your test is failing sometimes and it's                                 running sometimes you know it's it's                                 randomly failing now if we fix both both                                 of those seeds the instance level and                                 the master seed and rerunning again see                                 the seeds are all constant and now the                                 test is always failing and this is again                                 an important information because it                                 means that your test is failing                                 predictably for that particular seed if                                 it if there were some successes here                                 that would mean you're screwed because                                 your test is not really relying on the                                 source of randomness from the framework                                 it's also relying on some other                                 information that is outside which means                                 you know it's pretty it's really random                                 it's unpredictable so what are the                                 downsides of randomizing tests are there                                 are a number first sometimes it's really                                 hard to achieve or participate                                 especially with tests that rely on                                 multiple threads that are you know have                                 race conditions that are time-based or                                 something like that for these it's going                                 to be difficult second there may be some                                 incompatible random component                                 configurations which you'll have to                                 ignore and this happens tutorial in the                                 scene like some component configurations                                 just last forever or doesn't work at all                                 and we just assumption ignore them so we                                 ignore them at runtime and finally those                                 randomized tests are pretty hairy like                                 you know you try to debug something that                                 looks like this and                                 is a random input for a test like a                                 parameter or something try to debug it                                 it's just sometimes it's you know it's                                 difficult to take to somehow capture the                                 sanity in this randomized chaos that is                                 randomized test another example is the                                 JVM bug if you hit a JVM bag which again                                 we really do reproducing that is a                                 nightmare because the you know the                                 assortment of components and the data                                 involved is random you didn't write it                                 it just generated itself and this is                                 like an in like in line tree from a                                 method that notoriously fails for us and                                 nobody knows how to fix it nobody not us                                 not JVM developers you know I rebooted                                 myself a few times that's what it was                                 all right so to sum it up I hope those                                                                                                         and that you're interested in this topic                                 and that you'll take a look at those                                 randomized tests either in lucini                                 elasticsearch or somewhere else they                                 allow you to explore the complex                                 boundary conditions found the software                                 and they're really really neat I mean                                 they found bugs that you know nobody                                 else thought were possible what are the                                 downsides the failures once you hit them                                 there are sometimes really difficult to                                 debug or reproduce and the ugly parts                                 are within the framework itself so blame                                 me because I wrote most of it ah there                                 are some problems with repeating with                                 the different master seed and most of                                 all some people just hate it I mean you                                 know you get something that every every                                 time you run it is running differently                                 and some people don't like this kind of                                 uncomfortable feeling that every test                                 run is I don't know sorting methods in a                                 different order or something like that                                 so it's not for everyone but if you're                                 keen on trying please do let me know how                                 it went thanks Fabian                                 now he's going to say we don't have time                                 for questions he's gonna not going to                                 say anything ok ah great thank you very                                 much for your talk again as you might                                 know of course we don't have time for                                 questions I'm sorry but as David already                                 said if you have any questions just grab                                 them outside today are you here tomorrow                                 I'm here tomorrow and all day today so                                 you have a lot of time just get him                                 Thanks thank you very much
YouTube URL: https://www.youtube.com/watch?v=-uVE_w8flIU


