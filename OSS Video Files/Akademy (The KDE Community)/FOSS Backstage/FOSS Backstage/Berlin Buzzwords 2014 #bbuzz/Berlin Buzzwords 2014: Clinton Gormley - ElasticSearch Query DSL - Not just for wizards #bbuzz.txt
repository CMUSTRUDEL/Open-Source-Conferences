Title: Berlin Buzzwords 2014: Clinton Gormley - ElasticSearch Query DSL - Not just for wizards #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	The ElasticSearch Query DSL is a rich, flexible, powerful query language for full text and structured search, but with power comes complexity. Which of the 40 available queries should you use? What's a filter and when should you use it? How do you combine multiple filters, or multiple queries or queries with filters?

To most users, "relevance", and how it is affected by different queries, is a black box. Multi-field queries in particular can be difficult to get right if you don't understand how they work. 

In this talk, I will explain the Query DSL from the ground up: how filters and queries use the inverted index to find matching documents, how the relevance score is calculated, how to combine the filter/query building blocks into complex statements. And finally, I will talk about the pitfalls of multi-field queries and how to avoid them.

Read more: 
https://2014.berlinbuzzwords.de/session/elasticsearch-query-dsl-not-just-wizards

About Clinton Gormley:
https://2014.berlinbuzzwords.de/user/285/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              I all so we begin my name is Clinton                               Gormley I work at elastic                               and I've been involved with elastic                               search for is that me or I back been                               involved with elastic search for four                               years now since the first release and                               I'm currently writing the definitive                               guide with O'Reilly and my colleague                               Zack tongue which is aimed to be                                released in November but you can see it                                online and read it online for free at                                elasticsearch orgs slash guide I'm                                guessing that most of you have heard of                                elastic search which is why are you here                                how many people are using it in                                production okay a fair number                                so this slide probably doesn't it isn't                                really necessary for most of you but                                I'll go through it for those who may not                                know elastic search is a real-time                                distributed search and analytics engine                                so it does search which is what Lusine                                does but it handles full text and                                structured values like numbers dates to                                your locations etc as well it can                                perform analytics on those values it                                does this all in real time and it's                                distributed so can scale are                                horizontally and support a huge amount                                of data and the search part requires                                three chunks of functionality the                                mapping which is really how you define                                your fields is this an integer is it a                                date is it a geolocation is it a string                                if it's a string is an exact value                                string like a status code or something                                or is it a full text string if it's a                                full text string you want to analyze it                                before you index it to make it more                                searchable and then once you've got                                these two bits in place you use the                                query DSL to actually query the data                                that's in there the mapping and analysis                                parts are talks on their own right they                                are there can be very complex and but                                we're gonna start with some sort of very                                simple analysis and we're gonna focus on                                just the query DSL                                the query DSL it's how you query                                elasticsearch it's it's flexible it's                                powerful you can really express complex                                sets of logic and relevance calculations                                and but it's a bit of a black box people                                tend to copy and paste bits together                                throw it in into one big chunk of Jason                                and hope that it works not many people                                understand how it works and this is what                                the talk is about there are actually two                                types of clauses in the query DSL                                they're queries and they're filters and                                they're very similar but they differ in                                a few aspects the first is the answer                                that they provide so if it feels it just                                gives you a yes/no answer does this                                thing match or doesn't it is the price                                                                                                      ten and a hundred or isn't it queries on                                the other hand look at relevance how                                relevant is this document for this query                                string all right it's a much more subtle                                on server it's going to give back to you                                it's not                                                              be any floating-point number in the                                positive range filters you tend to use                                for exact values so you know numbers                                dates and so on but for Strings                                where we're status equals active would                                be a typical example of where you use a                                filter while queries are ready for full                                text looking for the quick brown fox in                                the body of an email or something like                                that because of the simple nature of the                                result of a filter it's easy to cache so                                not only does it not have to calculate                                the relevant score it can be represented                                very in a very small amount of space                                so filters can be cached making them                                really fast queries on the other hand                                can't be cached and the result is that                                filters are typically faster and queries                                are slower so what you want to do is to                                filter out everything that you can at                                the beginning and then just run the                                queries on the documents that remain in                                your set the next bit we look at is some                                syntax because you need to plug these                                filters inquiries into something and                                we've got the Search API here                                and the API takes a query parameter so                                 into this spot we can fill in any query                                 for instance we can look for search in                                 the title field and if you don't know                                 this query match all just matches all                                 documents equally and in fact if you                                 don't specify a query that's why you're                                 getting by default filters on the other                                 hand can't be passed directly to this                                 query they need to be you need to sort                                 of switch into filter context and                                 there's a special query exactly for that                                 called the filtered query and it takes a                                 query and filtered parameter so we can                                 move our search in the title field                                 clause into the query field and we can                                 say we're going to filter on documents                                 where the status field is active if you                                 just want the filter well you could use                                 a match old query there and in fact you                                 could just leave it out altogether okay                                 so this gives you the sort of structure                                 for where to plug these queries and                                 clauses and obviously this already takes                                 up a fair bit of space on the screen so                                 I'm not going to repeat this all the                                 time and but what you wanting to do is                                 either fill in Aquarion filter here or                                 at the top level a query here you'll see                                 this in action the next thing to think                                 about is how your data is indexed so                                 let's say we've got these two documents                                 quick brown rabbits brown rabbits are                                 commonly seen keeping pets healthy my                                 quick brown fox eats rabbits on a                                 regular basis now I'm sure we've all                                 done this where we put this into an SQL                                 database and run a query like this just                                 give me everything you know wild card                                 brown white cough Fox that's slow and                                 inflexible it's really not going to give                                 you decent results and instead what we                                 want to do is to take these string                                 values and pass them through some                                 analysis process and like I said                                 analysis can be quite complex but the                                 basis is fairly simple essentially we                                 want to take all of these words divide                                 them up into separate words and then                                 normalize those words normalization can                                 mean lots of things but typically lower                                 case                                 thing is a good example of that so this                                 just becomes a list of quick brown                                 rabbits brown rabbits calmly scene and                                 the cat of the capital letters have been                                 lower kissed then we build a sorted list                                 of unique terms that occur across across                                 all of our documents and we mark where                                 they occur all right so now if we want                                 to do the query for brown fox all we                                 have to do is look up brown in the terms                                 of it in this sorted terms list Fox in                                 the sorted terms list and we've got a                                 result so there                                 document                                                              matches both terms sorry I can't read                                 document                                                               matches both terms and we've got an                                 answer and this structure is called an                                 inverted index and it's not just for                                 text it can equally be used for dates                                 numbers boolean as geolocations geo                                 shapes pretty much any data type of data                                 can be represented in an inverted index                                 so that's how it's stored and we're                                 going to start now looking at the types                                 of questions that you want to ask of                                 your data and we'll start with the                                 simple stuff the structured queries that                                 you'll be used to from SQL things like                                 where field equals value now looking at                                 here you can see that the the content                                 field in document                                                    lots of values so where field is value                                 actually is where field contains value                                 all right and for that we use something                                 called a term filter this is what it                                 looks like if specify the type of filter                                 the field and the exact value that we're                                 looking for just to plug it in into the                                 context we've got our search request the                                 query parameter we need to use the                                 filtered query we have to fit in the                                 filter and a query we just want to                                 filter so this is a match all and we                                 plug our filter in here all right so I'm                                 not gonna repeat the rest of this on                                 later examples but you can see how to                                 play                                 how does this actually work well we go                                 to the inverted index for the title                                 field and we look up the value in this                                 sorted list we find Brown that gives us                                 document                                                               with a no and we've got our answer so                                 the this term filter ends up with a                                 result that is represented as a bit set                                 one bit for every document and that bit                                 set looks like that document one has is                                 true document two is false the nice                                 thing about this is it's really small                                 you can represent lots and lots of                                 documents in a very small amount of                                 space so we can cache it                                 and here we cache it as title Brown and                                 we've done the next time we run this                                 filter it is going to reuse the cached                                 value and these are smart caches you                                 don't have to think about expiring then                                 you don't as soon as you index something                                 new there are the caches are updated and                                 ok so then another common SQL form where                                 filled in value and for that it's the                                 terms filter which looks a lot like the                                 term filter basically it takes an array                                 instead of a single value and here we                                 find pets and quick we've got one                                 matching what one match in each document                                 gives us a bit set of                                               again we can cache it so these are very                                 simple tools but they form the building                                 blocks of the more complicated things we                                 come to later on similarly we've got                                 ranges which uses the range filter you                                 specify a range content and then the                                 comparators so greater than greater than                                 equal to less than less than equal to                                 you make there can be unbounded so you                                 can just leave out the less than or                                 whatever it is you want to do and here                                 we're looking for everything from A to M                                 so the way this works as it goes to this                                 terms list and it basically scans                                 through the list looking for everything                                 that fits into that range and counts up                                 the matching docks over here again gives                                 us a bit set which we can cache and this                                 funny syntax here is a sort of loose                                 in syntax we're a square bracket means                                 inclusive and a curly brackets exclusive                                 doesn't matter and we can run ranges on                                 date fields as well the when you index                                 in a numeric or date field it adds a                                 bunch of extra terms to make range as                                 much more efficient than they are in the                                 sort of standard string case because                                 this is usually where ranges are used on                                 numbers and dates not on strings and you                                 can even use date maths so we could say                                 everything from now - one hour but now                                 has a millisecond resolution okay so                                 it's very unlikely we are ever going to                                 reuse this clause again so using now                                 like that means this filter is not going                                 to be cached however we can round it off                                 to the nearest hour in which case                                 there's a good chance we will use it                                 again and that it is cached some other                                 structures where field is not now what                                 really means where field has any term                                 and that's the exists filter looks like                                 that and the opposite where field has no                                 term uses the missing filter those are                                 kind of the individual parts now we want                                 to combine them with boolean logic                                 alright and for that we use the bull                                 filter which looks like this                                 you've got must should and must not each                                 of these take a number of filters and                                 the must basically maps to and should to                                 or and must not to not so here we could                                 say that our document must have rabbits                                 in the title field should have either                                 quick in the content or quick in the                                 title field and must not have Fox in the                                 content field now what if we wanted to                                 say it must have quick and rabbits in                                 the title field or the content field                                 well the nice thing is that we can nest                                 these bulls so when I said that must                                 should and must not can take air any                                 filters they can also take other bull                                 filters                                 so this is how you end up building a                                 fairly complex sort of logic tree so we                                 reorganize it and in the mass clause we                                 have two bulls and here we've got should                                 have rabbits in the title content field                                 and should have Creek in the title                                 content field okay so from here you can                                 see how you can express exactly the                                 logic that you need what's important to                                 note about the bull filter is that this                                 part is not cached these internal                                 clauses are cached and of course each of                                 these internal clauses just produces a                                 bit set as a result so what the bull                                 filter will do is combine the results of                                 all of these using bit set logic and                                 that's pretty much what it looks like                                 the bit said from that clause all the                                 bits set from that and that and not that                                 so you don't have it you don't end up                                 caching this whole complicated structure                                 but each of these parts which are the                                 more expensive parts because they                                 actually have to go to disk and look                                 things up are cached and can be reused                                 wherever they appear in the query so                                 title rabbits just because it happens to                                 be so deep in this in the structure here                                 it doesn't mean that it's limited to                                 being used in that structure if it                                 appears somewhere completely different                                 it will still be reused                                 so to recap boolean results yes or no it                                 either matches or it doesn't use for                                 exact values it's cashable faster than                                 queries usually and you want to filter                                 first and then query so now we move on                                 to queries which are the more                                 interesting thing and if somebody's                                 coming from a relational database                                 background it's it's the kind of magical                                 part of how something like elasticsearch                                 works the question is how relevant is                                 the term that we're looking for and the                                 building block for Jones for this                                 question is the term query which is                                 pretty much like the term filter plus                                 relevance                                 now you actually probably won't use the                                 term query very often yourself it's it's                                 a bit of a sort of low-level query yeah                                 we'll come to the match query later on                                 which is the query that you will use a                                 lot but understanding how this works                                 will help you to understand how the                                 match query works so it looks just like                                 the turn filter term title Brown and                                 here we plug it in of course it's a                                 query not a filter so we plug in it in                                 at the query level and and when we get                                 our results back we have this score as                                 part of it                                 the score represents how relevant this                                 document is and and                                 the absolute value is not important what                                 is important is the relative value                                 between two documents so your results                                 are being sorted by relevance so they're                                 being sorted by score the documents near                                 the top have got a higher score the                                 documents in the bottom have got a lower                                 score so we need to understand where                                 this relevant score comes from and                                 really the three factors that are                                 important how common is the word we're                                 looking for in this document more common                                 it is the more often that word appears                                 within the document the more important                                 it's going to be but then you also have                                 to look at how common the word is in the                                 whole index so words like that and must                                 are very common and so they have little                                 importance if you had obsequious Ness                                 that's going to appear very seldom and                                 is so is going to be a really important                                 term to look for and then finally we've                                 got the question of how long the                                 document is we're actually talking about                                 fields rather than documents okay but so                                 how long is this field if you've got a                                 title field that's a short thing and if                                 a word appears in that short title field                                 it's likely to be more important than if                                 the same word appears in the long body                                 of an email and the official word or                                 terms for these factors as known in the                                 Lucene similarity algorithm is term                                 frequency inverse document frequency and                                 the field length norm                                 and you'll hear these mentioned a lot in                                 elasticsearch and leucine and and that's                                 basically it the term query looks at the                                 term finds the matching documents and                                 then calculates the relevant score using                                 the algorithm that we've explained so                                 now let's look at how you combine these                                 to add some logic to it we've got the                                 bull query which looks a lot like the                                 bull filter but is different master must                                 not are pretty much the same but should                                 is not quite the same and you've got                                 this extra parameter called minimum                                 should match which is can be a bit                                 tricky to understand and it's probably                                 easier by example if you have no must                                 queries so we're saying it should match                                 either quick or brown or rabbits in this                                 case at least one of these values has to                                 match for a document to be considered a                                 match in other words the minimum should                                 match parameter defaults to                                           case                                 however if you have a must clause then                                 these should clauses are optional none                                 of them have to match and so minimum                                 should match a zero so if none of these                                 clauses have to match what's the point                                 of having them well the answer lies in                                 the results you get from these things                                 the bull filter just says yes or no so                                 it makes sense for the should clauses to                                 always count but the bull query gives                                 you a score and as we said that score is                                 much more subtle so it's not just a                                 question of whether it matched it's a                                 question of how well it matched the                                 score from a bull query is calculated by                                 taking the score of every matching query                                 times the number of matching queries                                 divided by the number of queries so                                 these should clauses count all right                                 they the more matching should clauses                                 you have the higher the relevance of                                 that document so while they're not                                 required to match they are very useful                                 to push the more relevant documents up                                 to the top of the list                                 they give you a better relevant score                                 the minimum should match parameter can                                 also be used to trim the long tail of                                 low-quality results so this will match                                 at quick or brown or rabbits in the                                 title field but it's going to match                                 brown hag handbags quick wins which                                 documents which are really pretty                                 irrelevant to the users search if they                                 have looked for quick brown rabbits so                                 we could say we want all of the values                                 to match or we could say we want                                        the words of the the user searched on to                                 match of course                                                    doesn't really work out but the book                                 query is smart enough to round things                                 down so it really this means two out of                                 these three values must match for a                                 document to be considered a match and so                                 you you trim out the all those documents                                 that only match one term here now we                                 move on to the query that you are going                                 to use a lot and that is the match query                                 and the match query is a high level                                 query that understands the field mapping                                 and the analysis chain okay we'll                                 explain how this works so the match                                 query first is going to take the query                                 string the user passes in pass it                                 through an analyzer like we did when we                                 index the document and then it's going                                 to rewrite the query into the sort of                                 low-level queries that are actually                                 going to execute it so if we start with                                 the one word query match title quick if                                 we'd use the term clause here this                                 wouldn't have found anything because the                                 exact value quicken capsules with an                                 exclamation mark doesn't exist in the                                 inverted index but if we analyze that                                 value we end up with a single term quick                                 and that does exist in the index so now                                 this match query gets rewritten as a                                 single term query and you know how that                                 works already looks up calculates the                                 relevant score multi-word queries do a                                 similar sort of thing so we start off                                 with quick fox analyzed that and it                                 gives us two two                                 queries quick in the title field Vox in                                 the title field and then we need to                                 combine these schools so just wraps them                                 in a boolean and it'll add these two                                 schools together and the documents that                                 I've got both of them will appear higher                                 up the list documents with one lower                                 down the list so it's very simple how it                                 gets rewritten and perhaps you want to                                 say that all of the words must match                                 here our title Creek Fox needs to change                                 a bit is to take an extra parameter and                                 we add operator and and all that does is                                 change they should in this bull query                                 into the must that's the only effect it                                 has similarly if we want to trim the                                 long tail we can specify a minimum                                 should match and we're it still assured                                 it but now the minimum should match                                 parameters filled in there so it with                                 that you can understand why you get the                                 results you do the match query is no                                 longer just this magic box it does a                                 bunch of other stuff as well for                                 instance it'll handle fuzzy queries for                                 you the fuzzy queries use the Levenstein                                 at a distance what that means is how                                 many changes do you need to make to one                                 word to convert it into another so for                                 instance here we can insert a letter to                                 make brown brown we could change delete                                 a letter foxes to fox we can substitute                                 one letter for another and we can                                 transpose to you letters switch them                                 switch their order each one of these                                 steps is an edit distance of one and in                                 this case we've got an edit distance of                                 two an edit distance of two happens to                                 be the maximum that                                 Lusine allows but you can see how many                                 changes you can make to a word with just                                 a distance of two it can match something                                 that is quite far from the original if                                 we were to specify an edit distance of                                 two was something like bran a short word                                 like that we could change it into some                                 completely different word with                                 absolutely no relation to the original                                 so rather than having to specify one or                                 two we can use the author parameter in a                                 and it'll calculate the appropriate edit                                 distance based upon the length of the of                                 the word to up to a maximum of two so                                 quick Ron Fox will match the data in a                                 in our index we can also use phrase of                                 proximity queries where we're saying not                                 only want to match all of these words I                                 want to match them in this order all                                 right so no words in between anything                                 like that so here we can use the match                                 phrase query or it also works as the                                 match query type phrase quick brown fox                                 in that order exists in our index and so                                 it's going to match if we want to be                                 less concerned about order or perhaps                                 allow a few words to appear in between                                 you can specify a slot parameter which                                 gives it's bit like an edit distance for                                 position it allows things to be a little                                 more flexible and of course you can take                                 these the standard match query fuzzy and                                 phrase query and combine them together                                 so we're going to require that at least                                                                                                          in are in our index by using a minimum                                 should match clause here and that just                                 looks like what we had before                                 it's a query with the words we're after                                 and minimum should match                                             want to expand the range a bit and                                 perhaps match them on words that are                                 misspelled so in one of the should                                 clauses will use fuzzy matching and with                                 fuzzy Auto and then if the they have ten                                 minutes that's possible if if they have                                 the exact phrase that the user typed in                                 then we want to boost those up to the                                 top so we can add a proximity clause in                                 here and anything that matches that this                                 query is going to be bumped up to the                                 top and that's a reasonable way of                                 combining queries now we come to the                                 hard bit and that's multi field queries                                 and you often see things like this on on                                 websites called advanced search and                                 actually this is really                                 easy to do because the users telling you                                 what feels the state has in so you can                                 just use a simple bull query here this                                 is not so easy you the user expects you                                 to figure out what fields this data is                                 in and we could start off by say using a                                 boolean here quick brown fox on the                                 title and content fields and but                                 actually this quick brown fox in in the                                 second document which is the better                                 match is being beaten because both                                 fields here match brown alright so two                                 matches are better than one and we're                                 getting results in the wrong order the                                 bull query is not the only way to                                 combine queries we've also got the disc                                 max query and the logic is slightly                                 different it takes all of the documents                                 which match any query and then uses the                                 best matching query to prove you produce                                 the score so now if we change this to a                                 dis max query the quick brown fox is the                                 best matching clause and so this                                 document moves up to the top there's                                 another parameter that this Mac takes                                 called the tiebreaker and we matched                                 Brown here but currently we're                                 discounting it completely because we're                                 just looking for the best matching field                                 but by specifying its high breaker we                                 can still take these secondary matches                                 into account and all it does is takes                                 the best matching query and adds on the                                 tiebreaker times the scores from the                                 lesser matching queries we have a melty                                 match query which is like the match                                 query on multiple fields and it helps to                                 reduce the amount of writing you have to                                 do so here's our dis max query and it                                 can be re-written as a multi match query                                 like this we specify the query the                                 fields to run on and if you like the                                 tiebreaker and they're actually three                                 main types of multi match query this                                 type the default is called best fields                                 so                                 on the best fields out there and give me                                 the score from that and so the best                                 fields type is best when you're looking                                 for a whole concept in a single field                                 and you don't know what field that is in                                 so we're looking for quick quick brown                                 fox those words together in a single                                 field make more sense than those same                                 words scattered across several fields                                 and and like we said it gets rewritten                                 as a dis max query but quite often we                                 have a single title fee or something                                 like a title field which we want to                                 analyze in different ways for different                                 purposes and we can do this using                                 subfields here so perhaps we want to                                 stem it reduce all of the words to their                                 root forms so that instead of matching                                 just jumps we can match jumps jumped                                 jumping jump and and perhaps we want to                                 run it through edge engrams to use it                                 for autocomplete as well so search is                                 the type we can match on that just to                                 give you an example of what these                                 analyzers produce the title field using                                 the standard analyzer pretty much just                                 breaks things up by words removes                                 punctuation title drops dimmed changes                                 jumped there to jump and be also                                 complete with edged engrams                                 basically gives you all the parts of the                                 words anchored to the beginning so you                                 can see how if somebody types brown fox                                 J we can match from brown muck natural                                 fox and match and yeah and it's a likely                                 to be a good result to actually use that                                 query we specified the fields in the                                 multi match query but in here we use                                 type most fields so we've got the same                                 text in every field just analyzed in                                 different ways so the more matching                                 fields the more fields that match the                                 better                                 oh the slide agrees with me                                 and and so instead of using a dis max                                 here it gets wrapped up in the bull                                 query that we saw initially there's one                                 last case which is when your data is                                 scattered across several fields and more                                 than one field needs to match in order                                 for a match to be valid and so here we                                 got first named Reginald middle name                                 Kenneth last name Dwight and the                                 temptation here is to think well we want                                 to match on all of these fields and                                 count all of those matches so perhaps we                                 should use the most fields match but                                 this is wrong and I explain why the                                 problem is that at most fields and best                                 fields and for that matter our birth                                 field centric so the most fields query                                 gets rewritten into something like this                                 and it'll match anything that's got                                 first name Reginald                                 middle name Reginald and last name                                 Reginald as a good match so it's                                 completely ignored two of our terms and                                 next problem is that we can't apply                                 something like operator and or minimum                                 should match if we apply the and                                 operator it applies just to their field                                 so it would only define documents that                                 had Reginald Kenneth and Weiss in the                                 first name field all the middle all the                                 last name field that's not gonna happen                                 doesn't work next problem is term                                 frequencies first name as Dwight is                                 common dwight di eisenhower last name                                 Dwight is uncommon and what do we know                                 about uncommon words they have more                                 weight so an uncommon last name may have                                 more value than the common first name                                 that the user is actually searching for                                 we have two solutions available to us                                 the first is an index time solution and                                 that's basically to index everything                                 into a single full name field we can                                 still keep them separate but we can                                 index them into the full name field as                                 well                                 so we've got the first middle and last                                 names here we're going to add a full                                 name field and                                 P these values when we index from first                                 middle and last into the full name field                                 as well                                 this becomes simple it's just a single                                 field query so we've got all of the                                 power of the minimum should match I'm                                 sorry of the match query ax our disposal                                 of course we don't always think about                                 these things before we index so we have                                 a query time solution as well and it's a                                 term centric query so instead of looking                                 at fields first we change it around and                                 we consider each term individually so we                                 want to find Reginald in the first                                 middle last fields Kenneth in the first                                 middle last and Dwight in the first                                 middle and last that solves the problem                                 of NIM should match and making sure you                                 hit as many of different terms as                                 possible but it still doesn't solve the                                 term frequencies problem because first                                 name Dwight is going to score a lot less                                 than last name Dwight and two versions                                 ago in elasticsearch we released a new                                 type of multi match query and it uses                                 blending so what it does is look up it                                 looks up Reginald in the first middle                                 and last fields and calculates a blended                                 frequency score for those fields and                                 this makes our matching much more                                 accurate and this type is called cross                                 fields so it's used to query multiple                                 fields as if they were one single field                                 and everything looks the same as it did                                 before except we specify cross fields                                 here we can use minimum should match                                 quite happily and the the only thing                                 that you have to be aware of here is                                 that the first middle and last names                                 must use the same analyzer                                 you can't come have different analysis                                 processes in these fields they have to                                 produce a single analyzer for this to                                 work well                                 so to recap best fields when you have a                                 whole concept in one field most fields                                 same text in several fields with                                 different analysis chains and cross                                 fields when you're trying to treat                                 multiple fields as a single                                 field if you can understand these                                 building blocks even though the many                                 more queries out there the rest is just                                 details this gives you a solid                                 foundation to understanding how to use                                 the the other things out there thank you                                 very much and thank you to elasticsearch                                 we have time for questions                                 one minute make it fast                                 those elastic serves have some kind of                                 built-in capability to provide it with                                 multiple queries and then do a full back                                 if the first one doesn't match then use                                 the second one no it doesn't it doesn't                                 have that kind of fall back and but what                                 if you combine several queries say in a                                 boolean should in should clauses then                                 the ones that match best are going to be                                 pushed to the top if nothing matches the                                 best Clause then you're still going to                                 have these low quality clauses available                                 and so those documents will rise to the                                 top because there's nothing about them                                 yeah exactly is the idea being for                                 example in in product search in product                                 search very often you want to if you                                 have a number of high precision matches                                 you want to show those and nothing else                                 you could you'd have to run those four                                 queries yeah which you could do at the                                 same time using lot n search thank you                                 so the question is what other types of                                 analyzers do you have the answer is a                                 lot yes Germans they're they're about                                    something languages supported out the                                 box there are the plugins that support                                 other languages the you know Unicode                                 supporting things there's engrams edging                                 grands a patterns regex there's lots of                                 things                                 do we support German compound words                                 there is the compound words token filter                                 it's how well it works depends on how                                 good your dictionary is and it's it's                                 also quite heavy so I frankly I think                                 it's the filter that needs for your                                 writing                                 it means rewriting in Lucene but yes                                 that exists and or an alternate approach                                 would be to use an Engram approach I am                                 very sorry we are running out of time                                 I'll be around your goodness                                 thanks Clinton for your talk thank you                                 very much and maybe you'll find him                                 outside to ask him more questions
YouTube URL: https://www.youtube.com/watch?v=bZGSHm-XE1A


