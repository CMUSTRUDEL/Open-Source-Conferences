Title: Berlin Buzzwords 2014: Peter Karich - How Graphs and Java make GraphHopper efficient and fast #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	GraphHopper is an Open Source road routing engine which imports OpenStreetMap data to find the best path from A to B e.g. for a car from Moscow to Madrid.

In this talk I'll explain how we made GraphHopper fast even for long distance paths on commodity servers with world wide data from OpenStreetMap. In contrast GraphHopper still handles indoor graphs efficiently and works on mobile devices such as Android or Raspberry Pi. For this it was necessary to tune the system and do research for fast road routing on graphs.

I'll give a brief overview of the system and talk about the problems we faced with Java when using lots of data while trying to offer a usable API. Then I'll describe our simple but flexible storage solution, which can be used to store graphs, lists and more. In the second part of the talk I'll talk about reducing execution time via memory tuning and will show some possible optimizations we use in our Java code. At the end a short demo is planned.

Read more:
https://2014.berlinbuzzwords.de/session/how-graphs-and-java-make-graphhopper-efficient-and-fast

About Peter Karich:
https://2014.berlinbuzzwords.de/user/158/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              hello welcome to my talk I'm Peter and I                               would like to talk about a graph                               and well change slightly the title to                               fit the session at scale how an integer                               re or an area of integer Aires helped                               graph upscaling so first bit                               introduction and the components of an                               online map or of map in general or in                               your car navigation system is a some                                drawing component some geocoding and the                                routine component so and graph upper is                                all about routing it finds the best path                                between coordinates we have an online                                kind of a demonstration to show the                                capabilities of graph upper it's now a                                fully featured Maps application and we                                are using geocoding a forge a recording                                of a photon which is powered by a                                elastic search and maybe there are some                                guys here who have interests in in this                                project called photon but today I would                                like to speak about graph upper which is                                only about routing and here you see some                                typical maps application on left hand                                some address search and without                                suggestions and and then you have some                                tiles and and this tiny line is the                                important part its graph opera and the                                instructions on the left side also                                that's what graph a breeze and also                                graph upper and adept what graphical                                looks like and graph upper is an open                                source and fast wrote routing library                                and server so you can not only embed                                this into your products and but you can                                also use it as a black box routing                                server service it is completely written                                in Java it runs on the server on desktop                                on                                and read through normal Java a JVM and                                but there are also some experiments with                                with a JVM in the browser browser so we                                can run it offline in the browser which                                listen it's kind of a weird but a nice a                                use case would be for example hybrid                                routing we can offload the service and                                do the routing on the client if there's                                no internet connection or whatever else                                so it's not just an experiment it's also                                kind of yeah kind of an interesting use                                case and we also have not yet published                                poured off of graph above for iOS so we                                can run it offline on iOS spritz even                                pretty fast there and well we have a                                really memory efficient and data                                structures in build and and all the                                graphs are or the api's we we offer are                                mostly easy to use or we're trying as                                hard as possible to make them easy to                                use yeah and also the low-level API is                                built to be flexible so you can just                                grab one part and use it in your                                products for a completely different use                                case over their belts or replace the                                storage with your own storage system and                                something like this it handles                                OpenStreetMap data by default it is                                business friendly as it is apache                                license and we are for consulting and                                support for these it has many many unit                                and integration tests and also                                performance and and load tests so you're                                on the set aside if you hack and change                                something in graph over and you cannot                                only do this you cannot only replace                                component of graph above I can also                                answer that this mostly works as you can                                run                                unit tests for those components just an                                overview what you can do it you can do                                it use it for outer routing or for                                distance matrix calculations so it's you                                have lots of points you want know all                                the distances between all the points                                it's quite interesting for logistics or                                or ride sharing or something like this                                or taxi companies it can be even useful                                simulation or games think about a                                Scotland Yard as simulated game or in                                for virtual reality kind of games and so                                on how many of you have used a graph                                databases okay not that much um how many                                of you have experienced in NJ                                        and like spatial okay also and march i                                would give you a bit of introduction and                                in an introduction of how we map real                                world into some some data structure so                                we are using graphs for this and we are                                mapping the Junction's two notes and the                                 connections between two junctions are                                 our streets and called edges and the                                 nodes and edges have properties like                                 coordinates or names and and so on and                                 well now we need to find and now the the                                 work for graph hopper is to find the                                 best way from the road graph from A to B                                 from one Junction to another and from                                 one point to another point is a bit more                                 complex but for the sake of simplicity I                                 expect to be it a junction                                 and another question is why we are doing                                 this in Java and I was asked this a bit                                 lot and so I normally are answer with                                 why not at last at my first torque and                                 this is my second talk and and and i                                 answered why not but or yeah i answered                                 with i'm stupid and lazy or even with                                 and beach pay too many people would have                                 contributed and well today we'll learn                                 the truth it's all about tooling and and                                 also my stupidity so as c++ compiling is                                 really really slow and even if you                                 execute job comply compiler through                                 maven you're faster and yes you can                                 optimize this for c++ but at the end                                 javis java compiler is really faster and                                 also job was a lot easier for me to run                                 tests deployed back in profile and the                                 combination so you can debug and                                 production or profile in production with                                 really no overhead in performance or in                                 in usability and i tried to set up a                                 similar tooling for c++ and and also d                                 and for two weeks but i did not really                                 find an open source ide or open source                                 tools which gave me the same power and                                 same quality i needed so yeah i'm lazy                                 and well in                                                           because these are really young language                                 and but it's also an excellent language                                 but that tooling was really not that                                 good and two years ago so i gave up and                                 you are often here or i was asked oh                                 yeah but I was slow and and you know all                                 the funny jokes about Java but slow                                 compared to what and and graphic finds                                 best roof                                 through the entire Europe data in under                                                                                                         calculation it's even a lot less so Java                                 is not really slow and i get i will do a                                 bit risky thing i will do a                                 demonstration on the internet and and                                 show you what i mean so we have                                 graphical maps you know this and we are                                 in the house this club called thin                                 friends with mm i think this was yeah                                 and we want to go to Marseille and we                                 have the route and you can even                                 calculate this for for for bikes and you                                 will see the elevation data right here                                 and yeah one funny thing is you can you                                 can drag and zoom and see the hill there                                 now what I really want to show you is or                                 what I want to do to to give a a bit of                                 feeling that graph upper is not really                                 slow and it's enter in Java um yeah and                                 and a new feature for example was in the                                 last release that we now can i bought                                 hills for for bikes and and for others                                 as well which is interesting for                                 electronic cars and so on so it's quite                                 a short demonstration but i hope you got                                 what i mean so now the question is or                                 another yes another question was is java                                 and memory hog or isn't java a memory                                 hog and and yes it is compared to c c++                                 and so on and the main reason is that we                                 have no                                 no error reference less classes in Java                                 which is really pain and and now I would                                 like to show you what structs are so in                                 C++ and C I think you can store a point                                 which consists of latitude longitude add                                 in an area just really compact in this                                 form where the point is really where the                                 first porn comes before the second and                                 so I'm so it's really am compact and in                                 Java you have to always reference to                                 some some some kind of memory elsewhere                                 which is not really cash friendly and                                 has the problem of this this area which                                 which consists only of the reference                                 which is waste of memory and and the                                 problem is now why Java does not have                                 these things is that it was introduced                                 copy semantics in Java and for example                                 if you would have would would add a                                 point in another area then you have a                                 kind of problem you think they are the                                 same but you copy them you have you                                 would have to copy them if you would use                                 the C++ structs like thing and in Java                                   we will help fully see some some kind of                                 they are called well you types and you                                 can read more about this from John rose                                 in his in one blog post one month ago                                 until then we do two things and                                 grasshopper to a what wasting memory the                                 first thing is we scale with an area of                                 by door integer Aires and the second is                                 to make all of this easy usable and for                                 the                                                               flyweight pattern and                                 to introduce you why we are using some                                 thing like an integer re I will yeah I                                 will start with how would you implement                                 a simple in memory storage key belly                                 storage in Java you will just you just                                 need the hash map with a string as key                                 and an object as well you there they're                                 quite some problems you have waste                                 memory because you are storing the key                                 for example for a list you do not need                                 to store the integer value right you                                 just just an index so here you're                                 wasting or sometimes it's necessary to                                 waste but you're you're kind of wasting                                 memory for this and also you need the                                 object reference which I explained in                                 the previous slide because you are                                 allocating a big array and then you have                                 the area full of references pointing to                                 the object additionally resizing of a                                 hashmap requires rehashing and the                                 coastal reallocation of the underlying                                 data structure of the hash map and still                                 this hash map is limited to two billion                                 objects and some ideas as I said you can                                 use a list to while storing the key and                                 also your dressing and then you can use                                 the byte array and D or n serialization                                 to to store an object there and avoid                                 the costly object references                                 additionally you can use an area of bite                                 Ares to append segments of byte array                                 hour or as segment is a byte array and                                 you append this area to to avoid Rico                                 sleep reallocations for resizing so                                 instead of here you have a big Arry and                                 now you need to increase the size then                                 you would need another really big Arry                                 and think in terms of millions and that                                 or                                 billions or whatever and and then you                                 would have to copy this and instead of                                 this ghostly at em and memory wasting                                 operation you're just appending one                                 megabyte and then using the soul                                 structure for your list and this also                                 allows for more than                                                    objects we have an interface called data                                 access for this which solves all the                                 problems additionally we can use arrays                                 of byte buffers and to do this thing of                                 heap or to do this on with a memory map                                 technique so we can use it for offline                                 navigation on mobile devices of course                                 there are problems that this data access                                 is like a really large array and then                                 the and the excess is more complex than                                 with a hash lab and so it's not really                                 what what probably what you should do                                 when you want to scale because there are                                 lots of generic solutions for you it was                                 a nice project called map DB which                                 provides convenient access to a map                                 interface and they're a bunch of other                                 projects you can check out if you want                                 to use some kind of large array or large                                 data structures put in for java or of a                                 flaw of heap data structures and so on                                 and the technique i described and there                                 the errors of integer Ares or errors of                                 binaries or whatever it's it's used in                                 nearly all know SQL databases written in                                 java ya like like you seen HBase and and                                 so on I think and yeah we use a                                 flyweight pattern to yet reverse the                                 graph which Awards creation of new                                 objects due tues DZ realization now we                                 we need to fetch an object and create an                                 object from the bite area from the                                 integer array and and create objects and                                 and because we want to avoid this we are                                 just reusing the objects and and apply                                 the flyweight pattern like this crap                                 here so we we are setting some the graph                                 Explorer to some node and then we are                                 iterating over all neighbors of those of                                 this node and then we can then we have                                 access to all the properties of the heir                                 of the specific edge yeah I will skip                                 this this is more important do your own                                 benchmarks so what don't trust me or                                 anyone on the web do your own benchmarks                                 and do them correctly not like me as                                 Alex a she believed in                                                  on my blog the technique described in                                 this post is ultimately ultimately                                 broking it also contradicts with the                                 best practices of measuring the job                                 performance so too wide learning by                                 shame and pain you should really try to                                 understand how you measure correctly and                                 there are tools like jmh or use                                 profilers and so on and should you                                 really make use of them yes this is I                                 have to skip sorry because I would like                                 to thank you I think we have now some                                 time for questions ok any questions                                 unfortunately we don't have that much                                 time for questions but I'm just going to                                 say it look like you skipped over the                                 bit that I was really interested in                                 which was the actual algorithm for                                 finding the paths in the massive network                                 of nodes and edges that you've created                                 in these data structures you just like                                 really                                 quickly explain the algorithm maybe well                                 we are using a kind of Dykstra and and                                 this is modified it sits there are some                                 speed up at techniques for wrote graphs                                 like we are using contraction                                 hierarchies it's some it introduces some                                 additional edges and on query tyne it                                 can then ignore some some unimportant                                 notes and so it avoids traversing all                                 the notes and so it's a really boost for                                 especially large queries so we can                                 really scale not only for cities or                                 countries but also for continental sighs                                 okay any more questions otherwise you                                 can always obviously talk just on the                                 side as well okay thank you very much                                 thanks
YouTube URL: https://www.youtube.com/watch?v=hfZJBRfYMxs


