Title: Berlin Buzzwords 2014: Andreas Neumann - Transactions and Abstractions for Apache HBase #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	When Apache Hadoop was first introduced to the Open Source, it was focused on implementing Google's Map/Reduce, a framework for batch processing of very large files in a distributed system. Built for running on large cluster of commodity hardware, Hadoop also included a cluster resource manager to divide the capacity of the cluster between the various Map/Reduce jobs that can run at a given time.  

A Hadoop cluster, however, is not always fully utilized, and idle resources would best be used for other compute-intensive tasks like real-time stream processing, message passing, or graph algorithms. Unfortunately, the cluster resource manager was specialized in Map/Reduce execution and did not allow other types of workloads.  

This situation changes with Apache Hadoop 2.0 and its resource manager, YARN, which is decoupled from the Map/Reduce execution engine. It allows running arbitrary workloads on a cluster, as long as they are built against YARN's application manager interface: YARN manages the cluster's resources as a set of "containers". Each application can obtain containers from YARN and is then free to use them for any type of computation. Hence different types of distributed applications can share a single cluster. This allows for more innovation, agility, and better hardware utilization. 

Read more:
https://2014.berlinbuzzwords.de/session/harnessing-power-yarn-apache-twill

About Andreas Neumann:
https://2014.berlinbuzzwords.de/user/279/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              hello when the word no sequel became                               popular a few years ago it was a synonym                               for scalable efficient and most of all                               cheap distributed storage how could it                               be cheap how could it be cheaper than                               conventional relational databases by                               giving up asset guarantees of sequel                               transactions hence the word no sequel in                               the meantime we found out that                                transactions are an invaluable tool for                                developers they make our life so much                                easier when we try to build reliable                                data applications and as a consequence                                we are seeing a re-emergence of                                transactions in the no sequel world and                                nowadays the word no sequel doesn't mean                                no sequel anymore it means not only                                sequel I am andreas Norman I work for                                continuity and I will show you how we                                implemented transactions over one of                                these no sequel databases namely HBase                                I'm going to start with a quick                                motivation why do we need this I will                                show you how we implemented it and then                                I'll quickly do some abstractions future                                and if there's time for questions                                without eating into your lunch time i'll                                be happy to do that ok who are we my                                company is continuity it's this little                                little dark blue rectangle down here and                                what we do is we provide simple access                                to powerful technology what does that                                mean we have built an application server                                for big data it's called the continuity                                reactor and that makes it much easier to                                build big data applications then if you                                program directly over Hadoop and HBase                                what do you do in a big data application                                you do mainly for things you collect                                data you process it you want to store                                the results of the processing and you                                want to make it available for querying                                here in this talk I'm going to focus on                                one particular type of processing which                                is real time stream processing what is                                real time stream processing here we                                operate over real time streams of events                                and a stream processor typically                                consists of a bunch of agents servers or                                computers and each of these processes                                has an input queue that it reads events                                from and then it does some processing it                                may store some data it may read some                                data and then it emits new events on its                                output queues for the downstream                                processing of other other agents so it                                looks pretty much like that in in in the                                reactor a real time processing system is                                called the flow and every individual                                agent there is called the flow that and                                it's a very simple programming                                abstraction now this HP is table down                                here that might be shared with other                                stream processing applications so we                                might have another flow let that also                                writes to that table and this is all                                great until to flow let's try to write                                to the same cell at the same time and                                what do we get well we can we can flip a                                coin right we don't know who wins which                                which ride will prevail we're definitely                                going to lose one of the rights and what                                happens now is maybe this guy loses so                                his his right doesn't go through cuz                                gets overwritten by this one but he has                                admitted his output to it is output                                queues so now it's in an inconsistent                                State we have an event that looks like                                it's been processed but the effect of                                processing isn't there right and so now                                we can't rely on the behavior of our                                application anymore what's the solution                                many years ago decades ago that's what                                transactions were invented for in                                relational databases transactions                                protect us from that and our idea was                                that if we think about what if Lola does                                it it's fairly simple read an input                                event do some processing store some data                                amid some output event and so we                                implemented a way of doing transactions                                that encapsulate what we see in blue                                here in the transaction and we                                implemented that over HBase just a quick                                reminder who knows what acid means okay                                it's written there so what does it give                                us it gives us atomicity whatever we do                                in the transaction becomes visible at                                once we never see partial rights gives                                 us consistency once it's written it's                                 not going to change we're never going to                                 see something like flickering we're not                                 it gives us isolation isolation means                                 we're never going to see rights that                                 haven't been committed all right so this                                 is also called dirty reads and they can                                 be a pain when you write applications                                 and they give us durability once we've                                 written something it's guaranteed that                                 we will never lose it okay now this is                                 what we wanted to implement over HBase                                 what is H place who knows what H places                                 Oh everybody then I can skip this thread                                 can skip this but very quick quickly                                 it's a distributed columnar store it has                                 named tables so you can have many tables                                 and each table is essentially a mapping                                 from rocky column key and timestamp                                 that's a composite key to a value and                                 how does it achieve its massive scale it                                 partitions that key space into regions                                 and each region is served autonomously                                 by a regent server and these region                                 servers don't talk to each other and                                 that's why all the operations are                                 self-contained and that's why they are                                 very efficient now thinking about acid                                 what does HBase give us does it give us                                 any of the acid properties it does give                                 us durability it writes everything to                                 HDFS we know data is durable there it                                 also does give us consistency but does                                 it give us atomicity does it give us                                 isolation no it doesn't it gives us a                                 little bit of that so an operation on a                                 single cell of the table is performed in                                 an atomic way that's what HBase gives us                                 it even allows us if we stay within the                                 bounds of one region                                 it allows us to perform a batch of                                 operations within that regions region as                                 a as an atomic operation an atomic veg                                 so that's good unfortunately as a client                                 I don't know what the regions are so I                                 don't I don't even know whether my                                 rights remains within one region or not                                 so it doesn't really help me a lot what                                 doesn't it what it what it doesn't give                                 us is atomicity across regions atomicity                                 across multiple tables or atomicity                                 across multiple RPC calls multiple                                 distinct operations we don't get that                                 from HBase but in a real time stream                                 processing environment we need that so                                 we implemented it how did we implement                                 it so we're using a transaction style                                 that was first introduced under the name                                 of Omid om ID and I don't even remember                                 what it means and it has a flavor of                                 isolation that's called snapshot                                 isolation more precisely it uses multi                                 version concurrency control to implement                                 the isolation so we've seen that in                                 HBase every cell has multiple values                                 right the key space is row by column by                                 time stem so we can use that timestamp                                 we can hijack that we take that away                                 from the application you don't get                                 control over the timestamp anymore in                                 exchange we give you transactions and                                 now we generate transaction IDs that are                                 timestamps and they'll be monotonically                                 increasing and we use that transaction                                 ideas the timestamp for all the rights                                 that happen in the transaction and now                                 the nice thing is that we know a                                 transaction that's not committed all its                                 rights have the same time stem and HBase                                 allows us to exclude using a filter to                                 exclude a particular version from reads                                 and so we can very easily implement                                 isolation in order to implement                                 consistency                                 to prevent multiple multiple clients                                 from overriding each other's values we                                 do not do locking like databases to                                 right they lock somebody else locks you                                 end up with a deadlock that's not what                                 we want so we use optimistic concurrency                                 control and why can we do that we know                                 that two different transactions will use                                 a different time stamp which means their                                 rights will not conflict HBase will                                 allow these rights to happen                                 concurrently now when a transaction gets                                 committed we need to check whether this                                 transaction had a conflict with another                                 transaction that happened at the same                                 time another transaction that was                                 overlapping in time and in that case we                                 have to roll back the transaction that's                                 what's known as optimistic concurrency                                 control right so this is a right that                                 would have been blocked by a lock if we                                 were in a relational database right and                                 this is a right that we let happen                                 because we don't want anybody to wait in                                 our distributed system all right so at                                 the time of commits we need to detect                                 that that happened and whoever comes                                 later with his commit will be rolled                                 back what's the advantage of this the                                 advantage is we don't need to lock                                 locking has a cost because when I lock a                                 row of a table anybody else who wants to                                 use that row will have to wait all right                                 then what what does that do in the end a                                 lot of my processes in my cluster aren't                                 going to be idle waiting for a lock and                                 I'm going to I'm not going to get good                                 utilization of my cluster so avoiding                                 the cost of locking is good we also by                                 avoiding locking we also avoid that                                 locks deadlox can never happen now of                                 course there's a cost there's a cost of                                 conflict detection and in the case that                                 there's a conflict there is a cost of                                 rollback this cost is higher than in a                                 traditional database now why did we                                 choose                                 optimistic concurrency control anyway we                                 chose it because if conflicts are rare                                 if they don't happen often then                                 optimistic concurrency control costs                                 almost nothing the price is almost                                 nothing and if you think about how you                                 write a distributed application you're                                 going to partition the work into buckets                                 and you're going to send that two                                 different processes and if you do that                                 partitioning in a smart way you can you                                 can do it in a way that you never get                                 conflicts because you partition your key                                 space and you partition your work in                                 that same way all right so in in our                                 case this was the optimal choice now how                                 does it work in practice so we have the                                 HBase database here it consists of many                                 many regions servers and we have a                                 client who wants to use HBase all rights                                 now in order to get transactions the                                 client needs to communicate with a                                 transaction manager I'm going to go into                                 more detail about transaction manager                                 but this is an extra agent that's now                                 running in your cluster and it manages                                 maintains the state of all currently                                 ongoing transactions once it has                                 obtained the transaction from the                                 transaction manager it can use that to                                 write to hbase so we have an extra                                 variable in the game here the                                 transaction manager in order to avoid                                 that if it crashes system becomes                                 inconsistent or we would lose all states                                 we have two of those and they do a                                 leader election using zookeeper that's                                 pretty much standard nowadays but let's                                 take a closer look at how a transaction                                 actually happens so the lifecycle of a                                 transaction is client wants to start a                                 transaction so it makes a call to the                                 transaction manager transaction manager                                 returns a transaction ID and remembers                                 in its own memory this transaction is                                 now in progress the client now does all                                 its work it can do that autonomously it                                 doesn't need to talk to the transaction                                 manager anymore when it's done                                 it talks to transaction manager again                                 says I want to commit here are the                                 changes that I've made the keys that                                 I've written two and the transaction                                 manager now because it knows about all                                 other transactions can find out whether                                 there's another transaction that has                                 written to the same key and if so it's                                 going to say you have a conflict if not                                 it's going to say oh okay all right if                                 it's okay the transaction is complete we                                 can simply forget about it it's now                                 visible in HBase but if it's not okay                                 now we've made some rights to hbase                                 right but our transaction has to roll                                 back that responsibilities on the client                                 side the client now needs to roll back                                 its changes and we can do that each                                 place has a way to undo or rights by                                 simply issuing a delete for that                                 particular version that's written now it                                 may happen that that goes through fine                                 Oh fine everything that happened in this                                 transaction has disappeared has been                                 deleted so we can forget about this                                 transaction there's no more trace of it                                 but it may happen that the rollback                                 failed a region server is down a call                                 times out who knows what happens maybe                                 the client crashes before it can enroll                                 back in that case the transaction gets                                 invalidated and so this happens if the                                 client doesn't crash but it encounters                                 an error it can tell the transaction                                 manager I could not roll back sonal                                 transaction manager invalidates that                                 transaction and it remembers that it                                 needs to remember that because there are                                 some rights and HBase that are not valid                                 nobody is allowed to read them ever in                                 the future so we have to exclude them                                 from future rocks in future reads and                                 transaction manager is responsible for                                 that it could happen that the client                                 crashed in that case transaction manager                                 will eventually time out the transaction                                 and when it turns out it becomes invalid                                 to yes the state of transaction manager                                 is in memory oh yes okay so the question                                 was where's the state of transaction                                 manager transaction manager keeps it                                 state in memory but it also maintains                                 right ahead log on HDFS so that in case                                 of a crash we can recover and its rights                                 periodic snapshots so that the recovery                                 doesn't take long in case of crash very                                 similar to hbase itself yes yes yeah                                 we'll get there next slide hazard so                                 what does it transaction is a dua I                                 already talked about this on the                                 important part here is what is the                                 transaction a transaction consists of                                 three things one is the right pointer                                 the right pointer is the version the                                 time stamp that the rights of this                                 transaction have to happen with right                                 the client needs to know that the second                                 one is a read pointer the read pointer                                 is it's like a high water mark for the                                 client that it uses as an upper bound                                 for for its read time stamps anything                                 that is above must be a transaction that                                 we started later and so for isolation I                                 don't want to read that so I'm going to                                 exclude that some reeds and then the                                 third part is we have some transactions                                 that are currently in progress they have                                 a smaller transaction ID because they                                 started earlier but they haven't been                                 committed yet and so because we don't                                 want dirty reads we have to exclude                                 those two and the other ones that we                                 have to execute other invalid ones right                                 so that's the third part here and here                                 is also one problem the execute list                                 over time can become large if we have a                                 lot of invalid transactions because they                                 will never be cleaned up the clients                                 have crashed so let me skip to that what                                 we have for that is a coprocessor in                                 HBase we call that the data janitor this                                 is a coprocessor that sits in every                                 region server and it it knows the                                 transaction state because it                                 communicates with the transaction                                 manager and every time HBase does a does                                 a mem store flush or a compaction it                                 hooks into that and it removes all those                                 invalids rights that nobody is ever                                 going to read any                                 and once that has happened we can remove                                 those invalid transaction IDs from the                                 invalid list and then it shrinks again                                 it looks like I'm out of time so I'm                                 going to skip this little section that i                                 have about abstractions I'm only going                                 to say                                                          implement transactions data set or the                                 storage engine only needs to implement                                 for interfaces and none of these                                 interfaces say anything about HBase and                                 in fact we have implemented this for                                 other data stores we've done it over a                                 level DB over hyper sequel in memory and                                 there's many others that could do this                                 so what this gives us is we can now                                 suddenly do transactions that span                                 multiple different storage engines and                                 that's quite powerful I'm going to skip                                 this just going to tell you what's the                                 future sir the transaction manager                                 obviously is a bottleneck right there's                                 a single transaction manager that needs                                 to manage all the transactions in the                                 system we've been able to do about                                                                                                     cluster that's not going to be enough so                                 what we're going to have to do is                                 partition the key space have distributed                                 transactions with multiple transaction                                 managers who will then over some                                 consensus protocol do distributed                                 transactions I don't want to go into                                 detail right now we want to integrate                                 this with other transactional stores                                 like existing relational databases maybe                                 Cassandra we've seen cassandra has some                                 form of optimistic concurrency control                                 who saw the last talked and finally                                 we're going to open source this it's                                 going to happen this summer I can't                                 promise exactly when we have been at the                                 at the last HBase meet up in San                                 Francisco and discussed it with the                                 community there are two or three                                 competing approaches right now and we we                                 don't know yet what the outcome is going                                 to be but I think you're going to see it                                 this summer and it's going to be awesome                                 oh this I shouldn't say this we're                                 hiring of course                                 but actually I wanted to take questions                                 oops and yeah so there's something this                                 actually said questions but we have a                                 display display problem it's gone all                                 right so um questions please                                 so you said you were going to open                                 sources this summer are you planning on                                 putting it in HBase proper on Apache or                                 are you going to continue to maintain                                 this on the side or what's what's the                                 goal there ideally we can contribute                                 this to Apache yes in HBase itself                                 there's currently three competing                                 approaches to do this and each one has                                 its pros and cons right so it may be                                 that none of them will actually become                                 part of edge place and each of them will                                 be separate projects sitting on top of                                 HBase it's in the outcome isn't clear                                 yet in the worst case we're going to                                 open sources on github see whether we                                 can build a community and if the                                 community has traction we're going to go                                 into Apache with it how do you know                                 whether you can safely clean up versions                                 of the data with old timestamps                                 especially in this data janitor you                                 mentioned how do you know if their                                 transactions are definitely dead how do                                 I know so the transaction manager knows                                 the states of every ongoing transaction                                 if the transaction is properly                                 terminated either by doing a commit or                                 rollback then we know that all the                                 rights that have this timestamp have                                 been deleted or they're valid right so                                 then we can forget about this it only                                 happens for transactions that time out                                 whether we're the rollback doesn't                                 happen properly the transaction manager                                 knows about these transactions all right                                 so these are the ones that we can delete                                 now there's another another issue                                 related to like version clean up because                                 we only need to keep one version that is                                 visible to all transactions and how do                                 we know what is the what is the                                 low-water mark of all ongoing                                 transactions that might need to be                                 visible right so transaction manager at                                 any given time knows all the ongoing                                 transactions and they're read pointer                                 right so if you take the minimum of that                                 read pointer you know                                 that anything below that can be can be                                 removed yeah the clients need to talk to                                 the transaction manager in order to                                 ensure that they don't read partially                                 committed or part or partially committed                                 transaction here how they do that I do                                 they so is it mandatory that all clients                                 use the transaction manager here is a                                 lot of whether they using the                                 transactions yeah it's not so this is                                 one of the nice things that I skipped                                 here so we have this abstraction that's                                 called transaction aware where is this                                 here so a data that can implement these                                 four methods alright and then the system                                 is going to call that right at the end                                 of the transaction is going to call                                 commit at the start of the transaction                                 it's it's the the transaction itself                                 will be communicated to the storage                                 engine or to the client that that makes                                 the call and it says here's your read                                 point or here's your right pointer here                                 your excludes but it's up to the client                                 to decide whether it actually wants to                                 exclude those versions ok so if another                                 line if another client that isn't using                                 transactions wants to read the data how                                 does it guarantee that it doesn't start                                 reading right from other clients that                                 are in a transaction before they've                                 committed you can't guarantee that if if                                 a client ignores the excludes in a                                 transaction then it's going to see dirty                                 dirty rights but that's the choice of                                 that client all right you could say I                                 want more performance and I don't care                                 so I have a good example for this right                                 so take the stream of all tweets they                                 have embedded URLs and these URLs are                                 tiny urls so when you get when you get                                 the fire host you have this this tiny                                 URL and you don't know where it's                                 actually pointing to you want to resolve                                 that to the actual URL and that's an                                 expensive call right so one of your                                 floats is going to make an HTTP call to                                 get that redirect and find out what the                                 actual URL is and then store                                 hbase now this is a case where dirty                                 reads are totally fine because if that                                 if that fetch is successful whether the                                 transaction that writes it gets rolled                                 back or not that's redirect is valid we                                 know that this is valid and so we can                                 afford to do dirty reads all right and                                 in that case this is also an example                                 where the data set implementation can                                 choose not to do the roll by even though                                 the transaction gets rolled back i leave                                 my right there because it's still useful                                 for others ok thanks thank you very much
YouTube URL: https://www.youtube.com/watch?v=KIWrc7lQ18s


