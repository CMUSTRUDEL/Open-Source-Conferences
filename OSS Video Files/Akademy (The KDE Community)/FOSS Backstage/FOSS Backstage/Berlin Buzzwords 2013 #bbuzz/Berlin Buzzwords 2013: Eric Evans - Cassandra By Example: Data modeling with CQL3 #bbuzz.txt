Title: Berlin Buzzwords 2013: Eric Evans - Cassandra By Example: Data modeling with CQL3 #bbuzz
Publication date: 2013-06-19
Playlist: Berlin Buzzwords 2013 #bbuzz
Description: 
	Apache Cassandra is an increasingly popular choice of data store. Its write-optimized storage and shared-nothing distribution make it attractive for large, high-throughput data sets, or where availability and fault-tolerance are a concern. However, in spite of recent strides in usability, and rapidly maturing high-level interfaces, data modeling continues to be a source of confusion for many.

With the release of Cassandra 1.2 comes the 3rd iteration of the Cassandra Query Language, or CQL. CQL3 introduces improved support for wide rows through a novel use of compound columns; Per-row, normalized structures can now be stored, and efficiently queried using an SQL-like query syntax that should be second-nature to most developers.

This talk will take you step-by-step through a simple, open-source demo application modeled for Cassandra using CQL3, and provide the background needed to understand the model and query access.

Read more:
https://2013.berlinbuzzwords.de/sessions/cassandra-example-data-modeling-cql3

About
https://2013.berlinbuzzwords.de/users/jericevans

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              okay thanks everyone for coming                               hopefully you got an                               on that last break or that I won't put                               you to sleep if you didn't this is                               Cassandra by example data modeling with                               cql three if you haven't heard the cql                               is how many people were in sylvanian                               stock in the last session okay so there                               were there was more overlap than I was                                expecting when I talked to Sylvia so                                hopefully I won't bore you but there's                                also some different materials so cql is                                is a query language for Cassandra I'm                                gonna I'm gonna need Sylvain in here on                                thanks to I'm going to need to talk to                                him because it's actually I think a                                little bit more SQL than he's giving his                                giving it credit we used to call it an                                alternative query interface but it is                                really getting a lot of traction it                                seems to be where all the mind shares at                                I think I think you know it's destined                                to be the de facto why i kind of                                consider it that way and it's been out                                for three major releases now which is in                                you know in dog years is a long time                                cassandra moves really fast and i've                                done entire talks on the justification                                for why why i think this is a good idea                                i won't get into that much detail here                                i'll just stick with with the fact that                                this is by far the most approachable way                                to code for Cassandra to write an                                application against Cassandra the old                                way the only way at one point was the                                thrift RPC and this is what the code                                would look like in Java to write a                                single row with one column in thrift RPC                                now I know this slide is unreadable                                probably even from the front row                                actually if you're sitting in front of                                the IDE it's pretty unreadable I didn't                                contrive it to be this for both it                                really is that verbose and worse hear me                                now all right yeah so I won't go through                                this but just suffice it to say it's                                it's pretty bad it doesn't mentally map                                well to to the way you know your data is                                modeled it's just not a very good way of                                doing it by comparison this would do the                                exact same thing with cql and most                                people who've gotten to this stage in                                the game have already done some                                something you know with SQL at some                                point in their career and even if you                                didn't it just pretty much reads in                                English what you should what it's going                                to be doing so this is much easier to do                                it's much easier for the next person                                that comes along behind you to reason                                what what it's what's the intent and                                it's just the easiest way to do it so do                                this not this okay so before we get                                started though I want to take a little                                detour into partitioning and it feels                                like this is the wrong talk to be                                talking about Cassandra's architecture                                but there are aspects of Cassandras                                architecture that influence how you have                                to model your data and understanding                                that will well I think make it easier so                                for those that sat in in sylvania stock                                I apologize for any repetition here but                                cassandra is a content addressable                                system so if you can imagine the data                                and cassandra have stored as rows and                                rows are identified by a key and you can                                think of the key is the primary key that                                is that is a good analogy it's the first                                level of indexing and you look up rose                                and cassandra by that key so if you can                                imagine taking a namespace of all the                                keys in your key space you know and                                mapping them under a ring or a clock                                face you know in sorted order ascending                                and wrapping around from the highest to                                the lowest you could then divide or                                partition that that ring up and give                                each partition to a note in your cluster                                then it's a simple matter of taking that                                key and finding where it sorts on that                                in that namespace and taking the you                                know the next the closest node to it you                                know working working around the ring so                                then your Row the row that you must look                                up by key is pinned to a machine there's                                replication and whatnot so it's pin to                                multiple machines but where it lives in                                the cluster where it's placed is a                                 function of the the data itself so this                                 is this is to tell you that your unit of                                 access is the row a row is what you can                                 you know query quickly and easily arose                                 which you can update                                 you know atomically in a performant                                 fashion isolated you want your queries                                 and as much as it's possible you want                                 your queries to be something that can be                                 answered from within a single row so all                                 this is a fancy way of saying you have                                 to denormalize you have to denormalize                                 so that you can you know put more of                                 your data within this unit of access the                                 row and that's kind of the reason for                                 the for the specificity in this talk                                 that it's a cql three because cql three                                 comes with some abstractions some new                                 abstractions that make make that much                                 easier so the way I'm going to do this                                 is we have this application that we                                 floated around for a while it's it's a                                 real app it's a really simple clone of                                 Twitter just because Twitter something                                 everybody understands and you know it's                                 it's easy easy to think about I'm not                                 going to step through any code examples                                 per se i'm just-just cqo queries because                                 that's a painful thing to do but you can                                 download this app it's a real app and                                 even if pythons not your thing all of                                 the file all of the stuff that accesses                                 the database is in the top level file                                 called cast a pie and pythons pretty                                 readable so you could pick through it                                 pretty pretty easily if you wanted to                                 it's not a it shouldn't be taken                                 verbatim as an example of how anybody                                 thinks that the application should be                                 written for Cassandra or or anything                                 really it it makes some assumptions                                 about you know we favor simplicity / /                                 correctness I guess is the best way to                                 say it and there's also some obvious                                 mistakes and some obvious things missing                                 because it is used as a tool for                                 learning so that gives things to talk                                 about and things for people to do with                                 it if you if you pull down twiss andhra                                 and you fired up the embedded web server                                 and pointed your browser at the root URL                                 this is what you would see which is                                 pretty much what you'd see if you went                                 to Twitter and you weren't logged in you                                 you see the tweets from everyone a                                 stream in sorted time time sorted order                                 descending the newest tweet at the top                                 you have a you have a way of logging                                 well creating account and logging in                                 it's kind of doubled up in the same form                                 and once you're logged in your view of                                 the tweets the stream changes to those                                 of the people you follow and of course                                 you obviously get a way to tweet                                 yourself because you need to follow                                 people to see the tweets of those you                                 follow there's there's an interface here                                 that you can find people to follow and                                 follow them and finally if you see a                                 user's nick it's something you know it's                                 a hyperlink you can click on and that                                 will take you to a display of all of                                 their tweets specific specifically that                                 person streets again sorted temporarily                                 descending and so these are the                                 functions I'm going to go through the                                 pages i'm going to go through how you                                 would you know build a schema and                                 construct the queries to produce these                                 sorts of results so we'll start by                                 signing up a user you've got this form                                 with a username and you know password                                 field you can enter twice for comparison                                 we're going to store the username and                                 the password so we need a table for that                                 this table has two attributes one for                                 the username one for the password the                                 primary key is the username so that is                                 our row key which is appropriate because                                 we're going to want to look up the                                 password for a user so there will always                                 be a you know user where user username                                 equals some user predicate inserting                                 into that that table is you know just                                 you know perfectly valid SQL should look                                 truly quite familiar the semantics of an                                 insert though are identical to an update                                 so this will succeed even if you have an                                 existing user so obviously if there was                                 another user called meg and we didn't                                 check first we would we would override                                 it this statement wouldn't fail if there                                 was an existing user                                 so you would definitely want to do that                                 we include both of them because it's                                 really hard to say what the element of                                 least surprise would be if one were                                 missing or if you took something else                                 entirely but I think it's good and you                                 can just use it to communicate the                                 intent so if you're if it's your intent                                 to insert a new row using sir if it's                                 your intent to update an existing row                                 use update and then that'll kind of make                                 the code a little bit more readable I                                 think something you've got a user sign                                 that user in like I said we all we need                                 to do is select the password from the                                 users table where the username equals                                 meg and then we can verify that the                                 password she gave is correct and lock                                 her in so you know make has an account                                 and she's logged in she'll need to have                                 she'll need to follow some people she'll                                 need to add some friends in order to be                                 able to have a timeline populated with                                 the tweets she's interested in so for                                 this will create a table called                                 following which has two attributes the                                 username which in this case you know                                 we're when we're looking for megs Meg's                                 a list of people she follows will do you                                 know a query where username equals Meg                                 so this is our this is our row key and                                 we have an additional attribute followed                                 which is whoever it is that she's she is                                 following and so this is what's this is                                 what's new in cql three or this is a new                                 feature this sort of clustered primary                                 key is grouping to create the primary                                 key so the very first element whenever                                 you see this is the roki the sour our                                 predicate you know we'll have to include                                 a where username equals something this                                 is where we're going to look up the row                                 by adding the followed on here what                                 we're doing is making that a mini to one                                 relationship many followed to the one                                 username inserting into a row like this                                 is would be just like inserting into a                                 table wherever user name is Meg in this                                 insert statement under the covers with                                 in Cassandra that's all going to be put                                 into one row but every time we insert                                 with a different followed attribute                                 it's going to add that additional                                 additional followed and if we query                                 select followed from following where                                 user name is Meg we get back a nice you                                 know tabular result set that includes                                 all of the all of the users whom Meg                                 follows so it's kind of like we're                                 encoding the the table within the road                                 and so that's why I say that you must                                 normalize but the but this this feature                                 new and c ql three new with release of                                 cassandra                                                              that making that easier making that more                                 natural thing to do so now we have a                                 list of the people whom meg follows but                                 for every person Meg follows we need to                                 know we're at some point we're going to                                 need to know the inverse of that meg                                 followed Stewie so at some point we're                                 going to need to know who's following                                 Stewie and so we need the inverse of                                 that relationship so for that will                                 create another table which other than                                 the name of the table and the name of                                 the apt you know the additional                                 attribute is identical to the first but                                 this one's meant to track that inverse                                 relationship so it works the same way we                                 can do an insert here that says you know                                 where user name is Stewie meg is someone                                 who follows Stewie and then if you know                                 we do we do the the query select                                 followers from following where username                                 equals Stewie then we get a list of the                                 people who's who's following Stewie what                                 this means is is that every time someone                                 creates one of these relate these friend                                 relationships whenever someone follows                                 someone else we need to insert that into                                 both of those tables so that we have                                 both sides of that picture and that's                                 the way that's done in cassandra is with                                 a batch mutation the syntax of which                                 looks like this so every followed every                                 every time a following relationship is                                 created that's what we're going to do                                 we're going to we're going to insert                                 into both tables the one for the for the                                 person who's following and the followi                                 but for Meg to see any tweets from the                                 from the people she's followed they're                                 going to have to create a create a tweet                                 first                                 so if you can imagine Stewie types in a                                 tweet and mashes post then we can we can                                 track through how we store these tweets                                 and here's where we're going to see you                                 know much much of this denormalization                                 and if you come from an SQL background                                 this might be the part where your                                 stomach target starts to turn a bit so                                 just fair warning okay so the first                                 thing we'll need is will need sort of                                 discrete tweet store because people                                 share tweets and so you need a way of                                 you know effectively permalink back to                                 that tweet so create a table called                                 tweets and we'll give it a unique ID for                                 the primary key that'll be the row key                                 to look up key is that print is that I d                                 uu IDs feature rather prominently in                                 Cassandra because you know we need                                 something that's globally unique and you                                 know something like a monotony                                 increasing integer would require                                 coordination and this is a distributed                                 database so we have a tweet ID which is                                 a uuid we have a username in the body so                                 that when we queried this out we'll have                                 everything we need and then obviously                                 inserting into that is you know                                 again look very familiar it's just                                 standard SQL but this table is going to                                 fall far short of all of the things that                                 we need if you remember we need a way of                                 producing a page that shows all of the                                 tweets from a from a user sorted                                 temporarily descending we need one that                                 shows the tweets of all of the people we                                 follow again time descending and since                                 we're going to want to page through                                 these meaning we also need a way of you                                 know querying bye-bye it using a time                                 predicate you know we need to say where                                 date is greater than X and less than y                                 so that tweets table is not not nearly                                 enough so let's first look at that at                                 the simpler one the tweets for a                                 specific user so we'll do that by                                 creating a table called user line with                                 three attributes the username which                                 you'll see from the primary key                                 definition out here                                 again is the is the roki so we're going                                 to be looking up this user line for a                                 user and we'll give that get it give it                                 a tweet ID as well this one's a time                                 uuid and then we'll store the body of                                 the tweet as well so that when we query                                 this out we we've got it all there so                                 the previous table just used a uuid this                                 one uses a time uuid so that begs the                                 question what is the time EU ID and/or                                 why are we using that here a type                                        or time you ID is is a uuid adjust it's                                 just the first version or first                                 iteration of that standard and it was                                 kind of abandoned in favor of other                                 forms of uuid because it kind of exposes                                 you know the machine it was created on                                 and and obviously the time it was                                 created on because the first                                            that uuid are our time stamp it's kind                                 of a weird time stamp its                                                units from like a                                                       it is a time stamp and because it's the                                 first                                                                  they have a higher you know they have a                                 relatively high resolution so what that                                 lets us do is we can do a select on this                                 this call at this table we've created of                                 the of the tweet ID in the body and                                 you'll see in this projection we're                                 applying a date of function on the tweet                                 ID so that the results we get back are                                 actually you know like a timestamp you                                 know we'll have Cassandra extract the                                 date for us so return the date for us                                 instead of the uuid we select that from                                 the user line where the user name is                                 Stewie because we're interested in his                                 the list of tweets he's created and then                                 we can use predicates on the time you ID                                 that our date based this min time you ID                                 function is simply because like I said                                 the the time of you ID has sub second                                 resolution and we've given a timestamp                                 that is in seconds so this just says you                                 pick the floor the lowest possible time                                 uuid for that timestamp and finally                                 we're going to order it by the tweet ID                                 that time you ID descending                                 so that we get them in Reverse sorted                                 order and limited to                                                   what we show on page and the result from                                 a query like like that would look                                 something like this which should be                                 sufficient at least in the minimal sense                                 to create that page the page with all                                 the stories tweets ok so we also need                                 the timeline which is all of the tweets                                 that a user is interested in all the                                 ones from the the people he follows or                                 she follows so for this will create                                 another table that looks almost like the                                 last one with the exception of this                                 additional attribute called posted by                                 which is simply because we're going the                                 username in this case is the person                                 who's who's tweets who are going to                                 display these tweets for and since                                 they're from a variety of different                                 authors presumably we need a way of                                 identifying the author as well what                                 we're doing in all of these cases is                                 we're sort of pre computing a                                 materialized view for the thing we want                                 to look at and in this case where we're                                 looking at some at a stream of tweets                                 from a variety of different authors so                                 we need to add that additional attribute                                 but it's otherwise identical so you know                                 the query to extract the data is also                                 almost identical with the exception of                                 you know we're putting this additional                                 attribute in the projection so that we                                 get it out as in the results as well but                                 that means much like the the following                                 follower table for every tweet we're                                 going to have to insert this into                                 multiple tables we're going to have to                                 insert it into the tweets table so that                                 we can do a discreet look up based on                                 the tweet ID since a time you ID is a                                 uuid I should point out that we're we're                                 creating time you IDs and using a time                                 you ID type in these in these user line                                 and timeline tables we can also use that                                 same you ID for the tweets to each table                                 you would want to do that so that you                                 could link from the the timelines back                                 to the                                 to the discrete one we would need to                                 install it into that discreet tweets                                 table we will also need to in to store                                 it into the user line for that user the                                 one who is creating it and then for                                 every follower that user had remember I                                 said at some point we're going to want                                 to know who's following Stewie for every                                 user who follow Stewie we will also need                                 to store it into their timeline into                                 their materialized view of the tweets                                 they're interested in and again this is                                 something you probably want to to wrap                                 in a batch mutation so that it so that                                 it's atomic you know this is this is all                                 data that's meant to correspond with                                 each other so you want it to be                                 consistent and that is pretty much it I                                 mean that's pretty much what I wanted to                                 show that you need to think of your                                 queries you know from reverse you need                                 to think of what the results you you you                                 want to get back which should look like                                 and store that as opposed to you know                                 the normalized data you know the                                 normalized representation of that you                                 know I put up here don't forget G spaces                                 the cheapest sort of variable in the in                                 the scaling equation which is true but                                 to be fair there are many reasons why                                 you don't want to duplicate and that                                 that's that's probably the least of them                                 this you know this is something that you                                 know this is a trade-off that we're                                 forced to make for this kind of                                 decentralization distribution so get                                 used to it if you need you know if you                                 need this kind of scale creating these                                 sorts of one to many relationships you                                 know inside you know within a single row                                 is going to mean that the number of                                 columns in that row you know could go                                 could become quite large the row could                                 become quite wide but that's that's                                 pretty okay too because the the upper                                 bound on the number of columns you can                                 store in a row is quite high it's about                                 about two billion there may be reasons                                 why you don't want to go quite that high                                 but and you know of course you don't                                 want that the number of them to grow                                 unbounded which is you know in this                                 naive to a Sandra sample application                                 would be a problem eventually somebody                                 would                                 we'd enough for example to blow a row                                 but you can still go quite wide that's                                 not really a problem and if you know if                                 you want to play around with a sample                                 app but you don't like Python and your                                 app java I do have a link here to                                    this this that's written in java and                                 that's pretty much it so if anyone has                                 questions i think we probably have more                                 than enough time to take them and with a                                 bit faster than i thought i would know                                 ok thank you to the speaker is there                                 you
YouTube URL: https://www.youtube.com/watch?v=D7sEasl5px8


