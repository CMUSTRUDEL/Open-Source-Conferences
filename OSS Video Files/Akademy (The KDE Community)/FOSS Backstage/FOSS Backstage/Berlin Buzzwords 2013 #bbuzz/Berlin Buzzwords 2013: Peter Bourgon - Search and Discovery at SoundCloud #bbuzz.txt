Title: Berlin Buzzwords 2013: Peter Bourgon - Search and Discovery at SoundCloud #bbuzz
Publication date: 2013-06-19
Playlist: Berlin Buzzwords 2013 #bbuzz
Description: 
	A short talk describing the evolution of the search and discovery infrastructure at SoundCloud. A description of some of the problems we encountered in the original, organically-developed search architecture, and how they were solved via the greenfield development of a new architecture based on ElasticSearch. 

A description of how we perform relevance ranking for search results, and how we can extend that ranking for other product features. An overview of SoundCloud's Service-Oriented Architecture approach to building complex systems.

Read more:
https://2013.berlinbuzzwords.de/sessions/search-and-discovery-soundcloud

About
https://2013.berlinbuzzwords.de/users/peterbourgon

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              ok so i guess i can begin i'll begin                               everybody i'm peter that's me hi I'm                               from SoundCloud and I'm going to be                               talking to you today in a rather short                                                                                             discovery at soundcloud so this is going                               to be kind of like a vendor you're sorry                               like a use case presentation what does                               that mean so here's the outline first                                I'm going to talk a bit about our search                                product how it evolved from the early                                days to where it is today I'm going to                                talk about the components of that search                                product including specifically how we do                                relevance ranking and at the end I'm                                going to talk a bit about our service                                oriented architecture and why I think                                it's good okay so starting the evolution                                of search how many of you guys work in                                companies like a small startup that                                ships a product that's pretty vague                                anybody hands like shipping a product so                                at soundcloud we started with like many                                other startups we had a single product                                vision and the product started as what's                                known as a monorail app so this means it                                was written in Ruby on Rails and it's                                kind of shift as a blog to a bunch of                                servers and that's how we serve our                                product to the web and when you build a                                monorail app it kind of I guess looks                                like this so here's your monitor lap and                                it's just kind of like one process and                                everything's fine right and it's                                actually not a bad way of building a                                product because you can iterate really                                quickly on features and there's not a                                lot of resistance you don't have to                                think about a lot of things so this is                                cool we had a product for a long time                                and one day we decided we needed a                                search feature as you do so how does                                that look when you need to add a new                                feature to a monorail app it kind of                                just goes like this right so you just                                stick a search controller on the side                                and there you go you have it cool day                                one roll out a search feature pretty                                quickly works pretty well so over time                                you start connecting some things to                                search you wire up some features and it                                kind of works okay right like there's                                not a lot of complexity to                                but as time goes on things start                                happening right for us at least search                                was a solar backed by a solar                                infrastructure and what ended up                                happening was after a few features after                                a few bug fixes we found that we were                                getting a lot of couplings so we would                                get solar grammar directly in our app                                code we would directly mutate master                                engine states in places where it                                shouldn't be and I think if you work for                                a small company or indeed any company                                that ships a product this is kind of                                like a common refrain like things got to                                get done so this is kind of what happens                                so depending on your ability to deal                                with that this can be easier or harder                                but for us after a while I got really                                bad we lost our ability to iterate                                quickly we lost our ability to roll out                                new features and critically we lost our                                ability to maintain our infrastructure                                so when something bad happens we                                couldn't jump in and fix it efficiently                                so when this continues for a long time                                of course you end up basically with this                                right we call it a big bowl of mud right                                so like everything's just kind of stuck                                together and yeah nobody wants to work                                in an environment like this although I                                can imagine does this look familiar to                                anybody any self but yeah right things                                kind of inevitably on this way so we                                juggle these issues for about a year                                actually and finally we decided enough                                we need like a proper first class search                                part of our products and we asked                                ourselves how are we going to do that so                                how do we fix this problem we did a                                survey and basically we landed on                                elasticsearch we decided we were going                                to do greenfield development so build                                this new search product up from scratch                                which was pretty nice we're going to do                                a parallel dark lunch so build it in                                parallel and then put it out there use                                 internally for a while rural traffic /                                 micro traffic slowly and then as the                                 need arose we were going to scale it out                                 horizontally and vertically so that was                                 kind of the plan the question is why did                                 we choose elasticsearch a lot of reasons                                 actually first and foremost with that                                 there was a good API it was coherent                                 it was reasonably documented and this                                 actually goes for a lot right if you                                 ever download a piece of software and                                 within a few minutes you're able to like                                 boot up a little mini cluster in this                                 case on your laptop and you can like                                 play around with it and it's behaving                                 like you expect it to this is like                                 giving you confidence right and                                 elasticsearch gave us confidence in this                                 way it provided a clear path for growth                                 and by that I mean both horizontally in                                 terms of scale and vertically in terms                                 of high availability a lot of products                                 on the market i guess in the search                                 space claim this but we saw that elastic                                 search kind of had it so this was really                                 nice for us elasticsearch came with a                                 lot of batteries included by that i mean                                 features that we knew we wanted and                                 features that we already had and had to                                 implement so things like faceting or                                 stuff like this it's all there cool and                                 kind of last but not least elasticsearch                                 is working like we kind of expected it                                 would so there's this concept of                                 principle of least surprised where like                                 if you walk into a room and here the                                 lights which you don't expect the                                 garbage disposer to turn on right you                                 expect the kind of the lights to turn on                                 has anybody worked with a piece of                                 software that violates the principle of                                 least surprise before it's like a really                                 terrible thing right like you lose all                                 your confidence in your ability to                                 develop it and maintain it you just                                 start fighting it and when that happens                                 your productivity goes into the floor                                 and it's just not not a good experience                                 for anybody but elasticsearch is nice                                 that it doesn't have this property when                                 I when I submit something to the JSON                                 interface for example it kind of does                                 what I intuitively expect it should                                 that's for indexing that's for searching                                 that's kind of for everything so this is                                 cool and it's also basically true for                                 failure modes which is a big deal when                                 the cluster dies in a particular way                                 elasticsearch does what you expected                                 ought to do in that yeah in that                                 situation so this is why elasticsearch                                 so now I want to talk a bit about our                                 components as we built them and of                                 course maybe the most important would be                                 a relevance ranking so how many people                                 are familiar with page rank from I guess                                 Google way back in the day okay about                                 half so very quickly this is kind of how                                 PageRank works you can imagine                                 and the internet is these four pages                                 there are incoming links to see and no                                 incoming links to a and from that you                                 can kind of deduce that C is a more                                 important page than a this is all                                 represented in a matrix and then you run                                 some calculations and at the end of the                                 day c gets a higher page rank than any                                 of the other pages okay this is fine                                 this is cool you have pages and you have                                 a single type of incoming edge which is                                 like a hyperlink but we can extend this                                 model and indeed we did in the                                 SoundCloud universe but it's a little                                 bit too simple we have here only pages                                 and incoming links in soundcloud we have                                 different business domain objects and                                 different kind of edges in our social                                 graph it's not really a social graph but                                 that kind of looks like this and we call                                 it disco rank for discovery rank so you                                 can imagine uh this is meant to be a                                 person this I think is a set I don't                                 know what that is that's he's made that                                 anyway so okay a person creates a sound                                 a sound can be part of a set a person                                 can create a set and favorite a sound                                 you can imagine like all the things you                                 can do in any sort of rich business                                 domain landscape so we we model all that                                 in our in our social graph and we apply                                 the same sort of PageRank rules to it                                 and from that you can derive a disco                                 rank for all the entities in that graph                                 and they can be treated in aggregate so                                 it's like a universal disco rank or they                                 can be treated individually and from                                 that you can deduce a kind of importance                                 or relevant score for each of the each                                 of the entities ok so what does that                                 give you we do all these calculations                                 offline because it's pretty heavy I                                 think it takes not sure how long Delta                                 is like maybe half an hour or something                                 like this and to do it from scratch at                                 several hours we serialize the output of                                 that so we see realize that big matrix                                 with all the values into a compact array                                 and it's loaded into elasticsearch in                                 what's known as a custom score or module                                 so we actually load it into the elastic                                 search instance in memory this is                                 another one of those like batteries                                 included things that's that's really                                 nice                                 was good for us to extend then when a                                 query time we do kind of like a hybrid                                 two-phase thing so a two-phase query is                                 you go to elasticsearch you get all the                                 documents back and then as a totally                                 separate step you would like re rank                                 them from another data source we're able                                 to do this entirely within the elastic                                 search query but internally it's doing                                 its tf-idf look up and it's getting all                                 the all the matching documents on a text                                 spaces and then it's applying this                                 ranking internally so that's kind of why                                 it's hybrid so that's how it works at                                 the query time and then in order to keep                                 it fresh we recalculate and reload this                                 serialized array every I don't know a                                 couple hours something like this and                                 that's okay things aren't changing that                                 rapidly so that's what disco rank is in                                 like the base form but it turns out you                                 can use this type of relevance ranking                                 to do other product features which is                                 pretty neat for example if you add a                                 time component to the edges you can kind                                 of weight things according to how recent                                 they happens and from that you can                                 derive kind of like a hotness score so                                 if a lot of people favorite a track all                                 at once then that becomes more relevant                                 and then over time if no one else                                 favorites that it becomes less relevant                                 so that's how we do hotness in some                                 areas of the product similarly you can                                 combine the rankings of user entities                                 with some other elements with their                                 behavior from other parts of the site                                 and from that derive a trust score so                                 how spammy a user is for example very                                 spammy users will have a lot of outbound                                 edges and perhaps no inbound edges                                 something like this so disco rank is                                 like kind of a platform to do a lot of                                 other really neat things on the product                                 okay so that's like one component of the                                 search infrastructure but there are                                 other ones what's the bigger picture you                                 can probably wire up a search component                                 into your product in a lot of ways but                                 at the in the base case it probably is                                 going to look like this right you're                                 going to have your cluster and for us                                 it's a separate piece of infrastructure                                 because we already had the master                                 authoritative source of all of our                                 records we're going to index events into                                 it index records into it                                 and then later on query out of it so the                                 question is first of all how do you                                 index into it okay so here's kind of                                 what our indexing infrastructure looks                                 like we have luckily this rabbitmq                                 message broker so everything that                                 happens on the site when you upload a                                 track when you like somebody when you                                 change your user details things like                                 this a message is materialized on to the                                 broker we listen for the things which                                 are relevant to the search                                 infrastructure and when we hear them we                                 send a signal to this little red box                                 here which is the search indexer it's                                 converting that signal into a                                 materialized view which is all the stuff                                 that we care about searching so signal                                 materialized view and then we use the                                 elastic search api to index into the                                 cluster so this is pretty fast actually                                 from the time you click save on your                                 user record to the time it becomes                                 searchable on the other end of that                                 cloud is usually around two or three                                 seconds and pretty good so that little                                 red box is our indexing application it                                 is a single purpose application which is                                 stateless and I denpa tins originally it                                 was written in a very naive way in the                                 go language if that's relevant to                                 anybody and then over time we've                                 iterated iterated iterated to get it to                                 the point where we're doing sub micro                                 second per document queer index times so                                 that's kind of the development                                 philosophy from that we can do an entire                                 catalog and about last I checked it was                                 like                                                                   so that's all it soundcloud in to                                 elasticsearch in about                                                 ok so there's indexing right side on the                                 other side is read unfortunately this                                 diagram isn't very interesting there's                                 just a box there so this is how we                                 search you can you can imagine that this                                 is a basically just a query grammar                                 translator like a DSL translator it's                                 going from the elastic search domain up                                 here so like record field this sort of                                 thing and on the other side is the                                 SoundCloud grammar so                                 created in the last month BPM whatever                                 it's very simple very declarative again                                 single purpose application stateless and                                 I'd impotence it just does this dsl                                 translation and it's built around a                                 elastic search library which we wrote                                 for this purpose and which is open                                 source okay so there's kind of the big                                 picture of the basic search pipeline                                 there are some other products that are                                 built on top of elastic search for                                 example we have this explore tab if you                                 go to SoundCloud there's an explorer tab                                 up there that is also in the back end a                                 single purpose application which is                                 stateless and I dumped it in I put                                 stateless in quotes because what it does                                 is on a regular interval make kind of                                 complex queries into our into our                                 elasticsearch cluster which are keyed in                                 our predefined for each of the things we                                 want to expose and though the results of                                 those queries are cached so we can serve                                 very quickly these kind of cash buckets                                 of content and we can refresh them about                                 every five or ten minutes or something                                 like this and this is totally fine right                                 things aren't changing really that                                 rapidly and from that sore very quickly                                 results so again we're talking                                 nanoseconds or micro seconds to get                                 stuff out of this so that's our that's                                 our kind of basic search infrastructure                                 and maybe one thing you noticed about                                 all these things are these first two                                 lines were basically the same on all of                                 them and it turns out that's on purpose                                 and it's a really good thing because we                                 have what i call a service-oriented                                 architecture I guess for a lot of people                                 this means different things you ask                                    developer as you get like                                              responses but at soundcloud this is what                                 i mean by service-oriented architecture                                 we have our own internal platform it's                                 called bazooka and it's you can envision                                 it like kind of internal Heroku or                                 something like this it follows these                                 semantics where you're committing and                                 pushing to a remote repository that is                                 your build step and then after that you                                 have the ability to scale that revision                                 of your service up into however many                                 instances you want                                 we treat our API layer is sort of a                                 firewall so the bazooka platform the                                 bazooka orchestration service is kind of                                 a free-for-all and if we want to allow                                 authenticated connections in or                                 something like this allow internet                                 traffic in we always route it through                                 this API layer that makes things a lot                                 easier for us and everything which is                                 deployed on bazooka everything in our                                 service oriented architecture abides                                 these                                                                   of                                                                                                                                                cool and if you're not doing this you                                 should be okay this is my evangelism                                 part let me talk a little bit about what                                 a                                                                      factors I will only talk about five of                                 them because I'm pushed for time I guess                                 so you should write software this way                                 your application you're                                               should come from a single code base                                 which usually means repository if your                                 application comes from multiple                                 repositories then it is indeed separate                                 applications or some kind of                                 communicating network of applications                                 okay so that's like the concept of                                 application you should store your config                                 in your environment this means not                                 shipping configuration files along with                                 your application it allows you to very                                 easily have separate environment staging                                 development production and it allows you                                 to transition very cleanly between them                                 you should treat backing services as                                 resources so this is critical especially                                 in distributed environments you can't                                 kind of abstract the network away I'll                                 get more into that in a little bit later                                 but the point is if you have a my sequel                                 database if you have another service                                 that you're talking to these things you                                 need to understand them in terms of in                                 the context of they can fail right that                                 connection can die and you need to deal                                 with that as a first order thing you                                 can't ignore that every tool factor app                                 is stateless kind of stateless that                                 means when you start it up it should                                 start up very quickly it shouldn't rely                                 on having a certain amount of neighbors                                 that it can communicate with you should                                 be able to start as many instances of                                 these things as you want                                 and it your overall application your                                 overall system should function the same                                 way basically and                                                        achieve horizontal scaling so scaling                                 for load with a process model rather                                 than with let's say a thread model or                                 anything else like them that said your                                 processes should still be concurrent you                                 probably shouldn't be locked into a                                 single threaded sort of event loop you                                 can do this but if you're following                                 Heroku at all you notice they got into                                 some trouble a couple months ago because                                 they their their routing infrastructure                                 didn't take into account that many                                 applications don't aren't concurrent                                 they aren't see                                                      avoid that classic problem altogether                                 it's better to be congruent ok so these                                 are some things about toll factor apps                                 if you're interested at all please go to                                 tool factors on that it's really good                                 stuff that's all I'll say about that ok                                 but why why do we what do we do this                                 right if we have this monorail app back                                 in the day why are we transitioning to                                 this sort of service oriented                                 architecture approach probably the                                 biggest reason is simply velocity if                                 every application is written in this way                                 it's kind of always serving like a                                 single business use case a single a                                 single set of rules that are usually                                 very tightly related so if you're every                                 application you write is like this                                 independent thing which is having a                                 single purpose then there's very little                                 you have to like learn when you're                                 coming into this code base and like                                 maybe you want to maintain it or                                 refactor it you don't have to consider a                                 lot of different things you only have to                                 consider the core problem that it's                                 solving which is like very obvious and                                 like simple when you hear it but it goes                                 a really long way if there's less to                                 learn and to change when you have to do                                 this stuff you can basically work as if                                 you're always refactoring so every time                                 you need to change a service or an                                 application because of the new business                                 rule or because of a new constraint or                                 something like that you can and indeed                                 should say well is it better if I just                                 rewrite this from scratch and the cost                                 of doing that if you're writing the                                 service oriented architecture services                                 is                                 very low for example the indexer I                                 rewrote from scratch probably like five                                 times before it got to where it is in                                 the course of five months and I guess at                                 a lot of companies you can't achieve                                 that kind of your services are too big                                 to achieve that kind of iteration loop                                 so SOA gives you velocity and that way                                 and velocity of course gives you                                 developer happiness which really can't                                 be understated I don't know about you                                 but if I am happy I am way more                                 productive like order magnitude more                                 productive if I can like understand what                                 it is my services are doing without                                 having to guess about like that black                                 box or this thing that I didn't write                                 that's been there for two years I can do                                 a lot more and the company gets a lot                                 more value out of my salary so this is                                 really cool another component of                                 happiness is that all of my services                                 abide like contracts right so they have                                 to only satisfy these business rules and                                 it's totally up to me how they do that                                 so we're at soundcloud totally polyglot                                 we have people writing apps enclosure                                 haskell go Ruby a lot more languages                                 that I can't bring the minds and this is                                 fine right as long as I satisfy their                                 contracts totally cool that's also good                                 for developer happiness and also                                 important on a technical level is that                                 distributed systems are complex and you                                 can't truly cannot just say well the                                 network is just like a function call and                                 if it fails yeah this means your system                                 will crash in a way that you can't                                 recover from you have to think about the                                 network as a first order thing whenever                                 you go from one computer to more than                                 one and when you think in terms of                                 service oriented architecture this sort                                 of thinking happens naturally and this                                 is really important for writing reliable                                 software systems okay here's my SOA                                 evangelism so at soundcloud                                 elasticsearch core esso infrastructure                                 that is our search and discovery                                 experience and i am done thank you very                                 much                                 you
YouTube URL: https://www.youtube.com/watch?v=qI584upmYTY


