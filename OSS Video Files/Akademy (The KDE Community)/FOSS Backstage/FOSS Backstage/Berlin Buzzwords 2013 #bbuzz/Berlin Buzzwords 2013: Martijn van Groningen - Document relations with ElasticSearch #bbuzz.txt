Title: Berlin Buzzwords 2013: Martijn van Groningen - Document relations with ElasticSearch #bbuzz
Publication date: 2013-06-19
Playlist: Berlin Buzzwords 2013 #bbuzz
Description: 
	Lucene based search engines like ElasticSearch are document based and the usual way of modelling your data is to de-normalise / flatten your data. Other then just de-normalising and flatting your data ElasticSearch does provide other ways of modelling your data. In this session we will dive into the document relation features ElasticSearch has to offer and how you can use these features in combination with ElasticSearch's analytical capabilities, structured and unstructured search.

Read more:
https://2013.berlinbuzzwords.de/sessions/document-relations-elasticsearch

About Martijn van Groningen:
https://2013.berlinbuzzwords.de/users/martijnvg

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              my name is Martin Claudia and we're                               going to talk about documents in a                               document based storage I work for                               elastic source as an engineer to Ellis                               exert itself I'm also a lucinka meter                               first I want to talk about why you would                               like why why you want to use document                               relations in in in a secure table or                               maybe in any other document a storage                                and when to use it and then I will go                                into the support and search has the                                parent-child and nested support we will                                take a look at this example data graph                                that shows relations between items your                                data set doesn't matter what that can be                                people following other people doesn't                                really matter this is just a concept and                                I want to explain and yeah if you would                                index them as separate documents and you                                would like to have like some time for                                joining mechanism between it and you                                started to rent on one machine it will                                all work out pretty well so it's                                documentation exercise document and some                                in memory join happens which makes it                                really fast I see a client that makes a                                query and an internal local joint                                happens and as long as everything's on                                the machines will be fast but at some                                point it doesn't fit when the data keeps                                growing it doesn't fit all in on on one                                machine so what you do you want to add a                                machine to your small cluster so but how                                are you going to go into the fight the                                data set a approach would be to split                                everything in two and you will do a                                single request to its particular                                particular machine and it will try to                                make a joint but in order to make a                                joint it cannot be a local join anymore                                it needs to be a global joint that goes                                most likely across the network to the                                other machine and tries to come up what                                matches with what with what                                and as you can see this won't scale well                                because for a single request                                you have many soup requests so don't do                                it like like this and another approach                                would be to use to normalize that's what                                we do in document based solutions right                                document based engines do you normalize                                your your data set and and I try to                                visualize here as one row Pleasant row                                which is a represented or normalized                                document so instead of having a lot of                                small document chief Baker documents                                some of them are are small some of them                                are pretty large depending on how much                                data it need to include and retime                                midwives doing queries this works out                                fine request as fast there's no joint                                happening because everything is already                                joined basically during indexing in                                query is executed it goes to the other                                machine aggregates which sort of both                                about about soup request normal rates it                                and sent it back as result however reads                                are really fast indexing is a different                                story because you need to when you index                                you need to most likely maybe have a                                gets data from different sources maybe                                have a and complex cycle joint if you                                get your data from an SQL and make make                                those those de-normalized structures                                also what you end up with is a lot of                                duplicate data so it would be nice if                                there is something that could minimize                                the amount of denormalized information                                and so if we could take a look at the                                data set again most likely in another                                person in lot of cases not always data                                is kind of the relations are kind of                                isolated the don't spend across the                                whole whole data set and if you have                                these groups of objects of items and                                group them together you can basically                                group the related items together in a                                partition and this partition you                                associate with a node so in this case we                                have two partitions where the web based                                on this u data is being indexed to a                                particular site of the petitioner two                                particular nodes you do n at query time                                you do one query and both nodes will do                                a local join without needing to go to                                cross the boundaries of of the system of                                the machine this kind of join is is                                maintainable it's it's it skills because                                if you can partition your data set and                                 and also the relations with it you can                                 grow to many machines in a cluster and                                 this is basically also in less words we                                 work with a query time join but this                                 something to remember is that you always                                 will need to do normalize but how far do                                 you need to do normalize                                 let's that's the question and you know                                 you need to find the right side of the                                 you know what what do you want to keep                                 what do you want to join a query time                                 and what you want to join at index time                                 basically so dealing with relationships                                 either pay the price you know up front                                 during indexing all the research time                                 and with document relation we try to                                 give find a mini middle ground for                                 example one one join to reduce the                                 amount of duplicated data you would                                 otherwise have if you would do normalize                                 everything I say one maybe two or few                                 joints but not tens of joints of course                                 but it's it's not a database it's just                                 it's in East yet it's a little bit                                 system it needs to be you know in skill                                 also one one one side nodes that many                                 too many relations it's really hard to                                 support in the civilian environment                                 because those kind of relations                                 typically span across a large part of                                 your data set and you cannot really                                 partition it so the only way to overcome                                 this is basically denormalized so                                 parent shell it's the the career time                                 join in in elasticsearch so let's go                                 into this so with with parent child                                 support unless X hurts                                 you basically index parent and child as                                 separate documents and there are also                                 separate types in elasticsearch in an                                 index you can have more than one type                                 it's like a you can compare it maybe                                 with a bit with a table and sequel and                                 you can make joints between them                                 a parent can points can be pointed by                                 multiple children and it she'll a child                                 can only pair into one parents also a                                 parent can also be a child of another                                 parent so you can create a kind of a                                 hierarchy if you if you want to parent                                 documents and child documents they are                                 index into the same chart in Alaska like                                 in the same partition and the ID of the                                 parent is used as routing value to route                                 it to the to the right chart so                                 everything is local like I mentioned                                 with local join and because we there's                                 also an in-memory data structure that                                 efficiently allows lookup lookups for if                                 this is parent document or it is a child                                 document and look up if it is like a                                 connection between twin twins and each                                 other makes it a really fast join and                                 this is the data structure which is a                                 memory and we have received a heavily                                 reduced the size of it in                                            because the date search it needs to be                                 loaded in memory and you can basically                                 load it before query starts starts ruin                                 basically via a warmer API the warmer                                 API is of the ability to warm up indexes                                 they specify queries that run during                                 opening of an index basically                                 so how do you use it the above air above                                 is an example of how to create an index                                 this is how you create an index in                                 elasticsearch Houston rest endpoints and                                 what creating in this case we're                                 creating a products index and we have a                                 we also associate and mapping with the                                 index creation so we create a mapping                                 for the type offer and we say here type                                 offer points to type product then an                                 index in time which is the second                                 snippet you just an index if you not                                 familiar with with at the index                                 requesting one so this is an index                                 request you entered into a into an index                                 and into a type and you provide an ID                                 but in this case we also provide a                                 parent ID so that this offer which is a                                 child it will be routed into the same                                 sugar where its parent is and as as the                                 request body is basically the document                                 itself so we only have three fields here                                 so just simple example the parent                                 document doesn't need to exist at the                                 time of indexing child documents when                                 you want to query this when you want                                 yeah at query time you need to decide                                 the join basically and you express to                                 join the query time join as a query in                                 elastic search that has child query you                                 define from what Oh actually to what am                                 I going to join so you define the child                                 type the has parent it returns parent                                 hits based on matches or hits inside the                                 the child documents so in this case we                                 defined the query has child we pointed                                 to offer and we specify the query that                                 runs on the offer type documents in this                                 case we it's a range query and we only                                 interested in in offers with a price                                 lower than or equal than                                            result of this is all product documents                                 that have associated offer                                 with this particular requirement                                 optionally you can also define a score                                 mode and that defines how the parent                                 hits are sorted back to view so how are                                 the child documents how are the scores                                 from the query being pushed into the                                 parent here that's being returned so it                                 allows you to influence how to do the                                 relevancy basically based on this hit                                 this is basically it what I want to tell                                 about Parent Child that means it's short                                 I don't have that much time what I want                                 to mention is that this also has parent                                 pair and has parent query which does the                                 opposite of what the child has child                                 query does so it returns a child                                 documents based on matches in a parent                                 document okay let's go into into nested                                 objects in a lot of cases you                                 denormalize I don't even need a parent                                 child I mean parent-child you would only                                 want to if some part of the your data                                 you want it to be you know you want to                                 separately update it or sometimes like                                 with offers and products or of offers                                 they change more often and products and                                 that's why it makes sense to do                                 something at query time to prevent heavy                                 re-adding or indexing of data but a lot                                 of times there you have kind of a modem                                 a model or like like movies and actors                                 books in chapter I mean when you write a                                 book you don't I mean a book on a book                                 once a book is written chapters don't                                 read reappear or are editing to it                                 usually and it's it's kind of a static                                 relationship so we can do is do                                 normalize and this nested objects                                 support allows us to denormalize a in a                                 smart way so let's take an example let's                                 go let's take example of books and                                 chapters here with a book or a JSON                                 document represent a book with the title                                 less absurd                                 written Wireless by Clinton Gormley and                                 he is actually writing a book                                 no pressure content though and I hope I                                 hope it will be released in                                             have some properties but we also have                                 Chapter data and you see here it's                                 really Donora lized                                 to know as much you can do normalize                                 every chapter has down title field on                                 summary field on number of pages field                                 and I would say that is way too verbose                                 you can do it smarter because we index                                 in a skewed data as Jason and in Jason                                 you can use to find objects nested                                 objects and you can create objects in                                 objects and objects if you want to in                                 this in this case we have the chapters                                 field which is an array containing                                 objects and now it's denormalized in an                                 much nicer way because there's only one                                 title field on your own summary field                                 and by default a massive search each                                 each field is also at the same time                                 anywhere the index so you can query it                                 in this case we don't have we don't have                                 that many fields then we had with the                                 previous approach the question is how                                 does this get indexed under the hood as                                 a chooses the scene so it's being                                 translated into a loss in document which                                 has no dimension of higher piece or                                 nested fields or something like this so                                 this is what happens                                 the original duration is basically                                 flattened without the structure of inner                                 of the inner objects so and in some                                 cases this might not even be a problem                                 for you but if you want to have queries                                 or queries to give me all our books that                                 have chapters let's start with with the                                 title introduction but have and have a                                 number of pages lower than                                            when you cannot answer this question but                                 because the connection between those                                 nested objects is lost                                 two of Comus problematic shirts you can                                 use the nested fuel type like the                                 products create products index we                                 created a net products index in this                                 case we created books index and we                                 associate a mapping book with the                                 properties chapter which is of type                                 nested and nested triggers some special                                 way of indexing documents into loosing                                 called block indexing but way it's also                                 possible to have multiple levels of                                 nested fuel types just like with the                                 with with the with the child type you                                 can also have kind of hierarchy in this                                 case so block indexing what is this                                 block indexing basically translate the                                 elastic you documented JSON documents                                 into multiple loosing documents so when                                 we indexed each chapter is an is an                                 unlined document that's added just                                 before the root document or the main                                 document and they always remain in the                                 same in the in the same order and they                                 are never taken apart from each other                                 and as you can imagine this allows you                                 to have a smart of only it's a really                                 kind of an efficient join you can do if                                 you know the prague that everything is                                 proximate it's really close to each                                 other you can do a smart joint and that                                 is also what in actually seen happens                                 and what alex search uses so if you want                                 if you have tension type and you want to                                 use this specific way of indexing you                                 need to wrap your query in a in a nested                                 query to point out of what level to join                                 is you obviously you can specify                                 multiple levels so you need to tell in                                 at query time what about level would you                                 like to have to join for example we can                                 have a book with a chapter and when has                                 a page a page level information                                 you need to tell what what level do you                                 want to set the join let's do this with                                 a pot option and there is a score modes                                 option you slide with with the S child                                 and has stls parent there's a score mode                                 and this is defined how those individual                                 inline documents how the score is pushed                                 to the main document this query it                                 returns the complete document it does                                 not return individual nested hits                                 because for you as a user for less alert                                 as far as you're concerned it's just one                                 document and we this next type is only                                 there to have specific way of querying                                 the data inside this this nested objects                                 structure okay why is this is this joint                                 so fast it's an interesting thing thing                                 to explain and I made something about it                                 I mean I try to visualize it but I think                                 so in order to understand this you first                                 need to know that something know about                                 bottom scene in the scene listen                                 documents so there's nested documents                                 and is main document they all get like                                 an integer ID associated with it but use                                 internally into loosing to reference to                                 particular documents for you as a user                                 it's not of your concern because you use                                 the last exercise the application ID to                                 get the get data but in the scene we                                 assign integers to documents and they're                                 a monotonic meaning they start from a                                 low value to high value this kind of                                 identifier can easily be represented                                 into a bit set because it's and it will                                 sports the instruction so in our case                                 our example the root documents the main                                 the book the real book documents they                                 are marked into a into a bed set and the                                 cross it just tells you what the marked                                 documents are the one when the nested                                 inner query runs it goes                                 in a particular order over the documents                                 because everything is next to together                                 it goes basically from left to right                                 over the documents so when a child hit                                 is matched because there's a bit set at                                 the Finch if effectively easily can tell                                 okay what is my next parent so to what                                 document do I need to push the score to                                 can really easily and efficiently being                                 done in inside this nested query yes                                 what happens so not not all nested hits                                 for match some of them sometimes they                                 don't match at all so then the main                                 document doesn't match in the case and                                 when you saw when you smile one document                                 match it with there's nothing really to                                 integrate but if multiple nested objects                                 match scores get aggregated so depending                                 on your score Modi's which is either                                 average sum or max that depends on how                                 this score get aggregated and push                                 through the parent document okay this is                                 the nested objects support I have five                                 minutes left for questions and if we                                 don't have any meaning if we have time                                 left after this I have to exercise that                                 way I can show about sorting sorting in                                 parent and child documents how to do                                 real short sorting and how to use the                                 nested sorting which is a relative new                                 feature that has been added in                                          first questions if there are any
YouTube URL: https://www.youtube.com/watch?v=MXbsJsFfpV4


