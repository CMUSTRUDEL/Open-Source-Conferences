Title: Berlin Buzzwords 2016: Flavio Junqueira - Towards consensus on distributed consensus #bbuzz
Publication date: 2016-06-11
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	Over the years, we have built many data-analytics systems using components like Apache ZooKeeper, etcd, Consul, or homebrewed implementations of Raft. These components are used in a number of systems to perform what we call distributed coordination: master election, group membership, configuration metadata, locks, barriers, etc. Like many other systems we have seen abused, these components are often used in scenarios where they are convenient, but not strictly necessary. This observation begs the question of where it is necessary to use a distributed consensus primitive.

To understand when it is necessary to rely on a consensus primitive, we need to step back and understand precisely what such a consensus primitive provides and its association to all the problems that we have been using it for. There are many fundamental results in the academic literature that can be used here to explain the need to use a consensus primitive: the relationship between state-machine replication and atomic broadcast, the equivalence between atomic broadcast and consensus, and the equivalence between consensus and leader election. 

Even further, there is the famous Herlihy consensus hierarchy showing the strength of asynchronous shared memory primitives based on their equivalence to consensus. This hierarchy shows that some useful primitives (e.g., distributed registers) do not need consensus, showing that for many problems we come across when building distributed systems, it is possible to rely on weaker, possibly simpler solutions. Some other primitives, like compare-and-swap, are equivalent to consensus.

Read more:
https://2016.berlinbuzzwords.de/session/towards-consensus-distributed-consensus

About Flavio Junqueira:
https://2016.berlinbuzzwords.de/users/flavio-junqueira

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              alright that's loud hello everybody so                               thanks for attending my talk I'm pretty                               happy to be here it's actually my first                               time at Berlin buzzwords some thanks                               organization for having me I'm also                               pretty excited to see that the consensus                               is to an interesting topic good to see                               so many people in the in the room when                               the main thing that triggered me to                                propose the stock put this all these                                thoughts on disappeared consensus                                together its many discussions I have                                been having with people or hearing or                                blog posts and people write                                presentations around when consensus                                needs to implement that when consensus                                need to be part of your system                                coordination systems and stuff like that                                and so in this presentation I won't be I                                won't be giving a lot of new stuff quite                                the other way around some of the results                                will be discussing our fairly odd but                                it's it's a way of putting together up                                my thoughts and in my angle on the                                problem and hopefully that will spark                                some interest in future conversations                                about about of this and help us build                                better systems in the future so a bit                                about myself first sight I would say                                that my quarry area of expertise is this                                a bit of computing not only building                                systems but I spent quite a lot of time                                looking algorithms reasoning and and                                deriving algorithms I currently work for                                confident I'm an infrastructure engineer                                and I work in the kafka core team if you                                have been following more or less what                                has been going on with Kafka there is a                                traditional messaging layer of Kafka but                                there are the things that are popping up                                like connect and streams and so on so we                                have various teams working on those                                things if I am see you in the                                traditional core Kafka team I've also                                i've also been volved with open source                                for for some time now in particular with                                a SF projects Apache zookeeper Apache                                bookkeeper Joe projects that i have i                                have helped you to create an open source                                and more recently because                                of my affiliation to confident I've been                                also contributing to two Apache Kafka                                and and I'm not evolving with a SF is                                Apache Incubator helping projects to go                                through the budget process until they                                actually graduate and become a top level                                project and before conference which is a                                pre recent fat past I was a researcher                                initially was with Yahoo research and                                later I joined microsoft research and                                then side to endeavor into a beaut                                development position which is where I am                                right now but let's move on and talk                                about the actual content of the stock so                                distributed systems there are multiple                                ways one can can model this video system                                or reason about this submitted system                                here's one angle collection process this                                process they exchanged messages in order                                to execute some protocol they are                                executing a job processing data whatever                                you like right so they have a goal to                                have a setup process they need to                                satisfy at the properties in need to                                satisfy and the executors protocol for                                that a slightly higher level view that                                we often have when we have a server that                                is exposing a set of objects with a                                given API is to look at a distributed                                system as servers that give me the                                subjects and calls that I make against                                those objects through our pcs in that                                case the network is fairly transparent                                to those to those process they don't                                they don't see the actual messages but                                they're still there let's see what's                                going on underneath and in this stock as                                the title implies I'll be focusing on                                one particular problem which is                                disability consensus which at a very                                very high level very informally means                                agreement across a set of process and                                the reason why consensus is important is                                that there are many problems that we                                cannot that we cannot solve                                fundamentally without it if you some of                                the problems I will talk about if you                                don't you need consensus somewhere if if                                you need to solve them it doesn't mean                                 that you need consensus in every single                                 distributed system you do                                 that's definitely not the case but it's                                 important to draw to draw the line and                                 decide when it's needed when it's not                                 needed and if it's not needed just find                                 some other way of doing it the good news                                 is that often when we need consensus or                                 in the way we have been at using it it's                                 it's not in the critical path of your                                 application so if you have the frequent                                 operations outside that consents is not                                 going to be in the critical path of                                 those operations even though it might be                                 present in your system to the problem                                 this will be the consensus so I have                                 again a collection of of proxies you can                                 call them nodes of servers whatever you                                 like i'll be calling them process each                                 of those processes proposes an initial                                 value sighs you know I i think that the                                 decision value of consensus should be                                 one or two or zero whatever you like and                                 after running a protocol that solves                                 consensus I want this process to agree                                 on a value as I want all of them are                                 these the ones that haven't the heaven                                 crashed to pick and decide the same                                 value and once they do it they cannot                                 they cannot change their mind it has to                                 be done only once and as I said in my                                 story crashes so we interested in                                 scenarios in which crashes can happen if                                 you know a bit about this dis cope there                                 is really there is a whole body of work                                 considering faults there are not crush                                 their Byzantine like process that i go                                 out of the way become militias and grew                                 up data's and different messages to                                 different process but we are not be                                 considering those here we have enough on                                 our plate to discuss but i want to make                                 a word that this happens and it's out                                 there I be more graphically I if I have                                 this three process p                                                   my initial values are colors each one of                                 those processes they they pick a color                                 to be their initial value what I want to                                 happen is that after running a protocol                                 they eventually pick one                                 and only one and in this case that big                                 black just for the sake of example okay                                 um but what is what is the protocol that                                 I could actually use charandas and I                                 must want you there for the next few                                 slides I'll try to give some insight of                                 how this protocols work as I want I want                                 us to be on the same page and on how                                 things are supposed to work in practice                                 but by no means I'm trying to teach you                                 one concrete algorithms and now that the                                 features and all that the details of                                 such an algorithm so this is just to                                 give you an intuition of how this works                                 so one way is a pic a leader so let's                                 say that I I pick beat you to be the                                 leader a big be too because I decided                                 black in the previous slide and then                                 leader is going to ask the other process                                 if they have accepted any any value and                                 accepting here is a step towards                                 deciding upon a value so enough process                                 need to this except the value before a                                 decision arises so believe it s those                                 process they just started so they                                 haven't accepted anything so they tell                                 the the leader that I haven't accepted                                 anything the leader tells em okay grades                                 so accept my value except black so they                                 will go and accept black and and they                                 would tell another that I have accepted                                 black everyone knows that enough process                                 have accepted black and they go and                                 decide black that's that's awesome                                 however this is not entirely safe for                                 the following reason say um because                                 again i want to be fought aren't say                                 that um i had picked a different leader                                 previously as i had picked p                                            leader before B                                                        lingering there it's two things is the                                 leader everyone else thinks is scratched                                 by it's it's it's still there and                                 concurrently with beat you it issues the                                 same the same                                 the same message by asking p                                            valley has accepted and let's say that                                 the communication between you mp                                   is completed the labia now Pichu is                                 unaware of p                                                           its protocol it tells p                                                be one accepts black why not picture                                 things is the leader so pitch you must                                 be right now p                                                           in response to Pichu but now it is data                                 that the message from p                                                  that he has accepted hasn't arrived and                                 so picchu thinks that it has enough                                 process it has a majority that has                                 accepted black so he thinks okay great                                 this started Black in the meanwhile p                                  sends an accept green to p                                               no way to say well you know why should i                                 not accept this value be three things                                 it's the leader so you must be right so                                 let's take that value to an exit screen                                 now both process p                                                       messages for green they end up deciding                                 green which is a violation of agreement                                 right with something I don't want                                 because those those we got into the                                 situation that beat you decided black                                 and the end the other to decide agree to                                 get around this problem what we have to                                 do is it's not standard technology but I                                 like to think of a fencing here so we                                 use impacts us terms the ballot number                                 to do the following when I send that                                 what value have accepted message I sends                                 a value with it asset value a ballot                                 number with it and when p                                               passage it promises that it's not going                                 to process any other message with us                                 with a lower ballot number and in that                                 case the message from p                                                  fail so if be three tries to tell you                                 want to exaggerate it's going to fail                                 because the belt number of b                                            like                                 as we proceed with the protocol with                                 black eventually tells be one that it                                 has accepted black be one of the sides                                 black we are good okay so that's that                                 was some exciting product all that we                                 can use to to reach to get consensus                                 initial values be kind of value and                                 decided now one of the reasons why                                 consensus is hard is that because there                                 is this well known impossibility result                                 behind it the impossibility result                                 essentially says that if I'm in a system                                 where things can get arbitrarily low                                 messages and the end process then I can                                 get into trouble and let's go into a bit                                 more into a chance and what is what is                                 the underlying problem so consensus                                 tells us that we want all process that I                                 sue up that they don't crash to agree on                                 the same value we want the decision that                                 it should be some value proposed by a                                 process because we don't want to get a                                 bogus protocol they just decides upon                                 the same thing always in cheney and                                 deciding just speaking the same value                                 always and we wanted to decide                                 eventually which turns out to be the                                 core of the problem this disturbin a                                 shin condition essentially forces                                 process to eventually decide something                                 and if they don't have enough                                 information they wind up choosing the                                 wrong value so let's see let's see the                                 intuition behind this and this time i'm                                 going to use just to process for this                                 okay so b                                                         initial color as an initial value and                                 let's say that I let's say I do have a                                 tube process consensus prodigal now I                                 can have the following problem say that                                 I have an execution in which p                                           but picchu crashes right in the                                 beginning it doesn't send a single                                 message out in that case p                                         choice other than big blow so it decides                                 blue if I pick the symmetric execution                                 in which p                                  p                                                                   Pichu has no choice other than picking                                 grain now if I pick a third execution in                                 which the message between the two are                                 arbitrarily slow and um they cannot                                 distinguish so p                                                     this execution from the first in the                                 previous slide mp                                                     pee tube cannot distinguish between this                                 one and and chew in the previous slide                                 then they wind up deciding upon                                 different values so if i have this                                 arbitrarily delay communication between                                 the two because the processors all                                 because the network exploitation then                                 bottom line is that i cannot i cannot                                 make the right call so clearly this                                 result even though it's important we                                 need to be aware of it it's not it                                 doesn't prevent us from from running                                 this in practice from having systems                                 that use consensus and they're running                                 production successfully the reason why                                 that doesn't stop us is because there is                                 a solution in for practice for partially                                 synchronous systems so if our system is                                 asynchronous at times meaning that a no                                 messages get loss or I have some my                                 email where it goes haywire it goes bad                                 for some time or my process get                                 overloaded whatever then I have ops                                 people who come in fix things right and                                 then it eventually stabilizes then I can                                 get I can make enough progress to get                                 consensus to work and in fact given the                                 previous inside I gave on the on a                                 consensus protocol finally we collect                                 the sable leader then I'll be able to                                 make progress with it another important                                 point is is that if you have played with                                 systems like zookeeper etcd you up or                                 just raft for that matter you we all say                                 that you need to have +                                                  is the number of tolerated crashes and                                 that's also fundamental results and the                                 argument is very similar to the one I                                 just gave you for for for the                                 impossibility if I have less than                                        for a few                                 to have plus                                                             situation that I just described and                                 again this assumes all Byzantine                                 behavior um okay great so that was                                 perhaps a bit too abstract so let's go                                 into something a bit more practical and                                 what is the connection between consensus                                 and our world so let me talk now be a                                 bit about state machine replication and                                 atomic broadcast it turns out that that                                 replication is an important application                                 of disability consensus and that's                                 through this technique we call we we we                                 call state machine replication where we                                 essentially we split the the building                                 such a replicated machine into                                 agreements just broadcasting massive                                 requests to the replicas and executing                                 that those requests so being be a bit                                 more specific so if i have a surveyor                                 i'm going to replicate that server we                                 have some logic right execute the                                 commands that a client sees you against                                 that server and some state that i use to                                 execute the commands that logic and                                 state is captured as a deterministic                                 state machine and so what I do is I just                                 replicated across and across the                                 replicas that I that I need and I make                                 sure that they all execute the same                                 sequence of commands it has to be the                                 same sequence because if I miss a                                 commander can get a replica in a bad                                 state so I don't want that also has to                                 be the same order because if i reordered                                 I also can get inconsistencies so I                                 don't want to do that in the end we end                                 up with an architecture diagram that                                 looks like this so we have this atomic                                 broadcast layer that takes the comments                                 from the clients up the sides upon the                                 commands are going to be delivered and                                 the order and their guarantees                                 consistency across across my replicas                                 one example that I personally familiar                                 with is zookeeper and that would look                                 like no mapping to that previous                                 architecture that's what zookeeper looks                                 like                                 so that atomic broadcast would be what                                 we call sub and inside the servers we                                 have the logic of the commands that the                                 clients can issue against the servers                                 and this state would be the data tree of                                 c-notes we have in a in in zookeeper but                                 fine I i started with consensus and then                                 I went into replication and I said that                                 I need a Tommy broadcast upcoming                                 broadcast has something to do with                                 agreement but what is what is the                                 connection there it turns out that                                 atomic broadcast and consensus are                                 equivalent problems they are not the                                 same problem right often a so people use                                 interchangeably consensus systems with                                 systems that actually implement atomic                                 broadcast which is not entirely wrong                                 because again there are equivalent                                 problems but then retrieve them from an                                 algorithms point of view so if we look                                 at consensus that the calls that I have                                 our proposed on the side whereas in an                                 atomic broadcast I have sent them                                 deliver and for consensus we say that we                                 decide upon one single value out of the                                 values that have been that have been                                 proposed and I eventually decide and for                                 atomic broadcast we are interested in                                 delivering the same sequence of of                                 messages and in the same order so why                                 are they equivalent well it's not it's                                 not that hard to see so if I give you a                                 consensus implementation I can implement                                 a Tony broadcast by just instantiating                                 by just insulin shading that consensus                                 box right and so and so each consensus                                 instance is going to give me a position                                 in the sequence of delivered messages                                 and you get a message delivered I                                 propose that message to the consensus                                 instance and so that those decided                                 messages at the bottom give me the                                 sequence of messages broadcast that my                                 replicas are going to execute if I'm                                 implementing a replicated service now um                                 if I if you give me an atomic broadcast                                 implementation then I can implement                                 consensus by just broadcasting my value                                 as a message and the process                                 deliver those messages and just pick the                                 first in that case everyone is                                 guaranteed to pick the same value and                                 and I have consensus okay that sounds                                 good but if I if I am to build a                                 replicated system should I you know so                                 what should i do should I just go and                                 implement everything that I just                                 discussed in plumbing my own atomic                                 broadcast layer you know take care of                                 this atomic broadcasts algorithm take                                 care of every configuration so on maybe                                 it's it's not necessarily a bad idea                                 it's difficult people have said is                                 difficult but I think it's difficult                                 based on my zookeeper experience but                                 it's not impossible you know we can do                                 it and if you do it you have to well you                                 end up picking one of those those                                 protocols that already exists or                                 possibly invent your own if if if it's                                 needed but then you end up having to                                 deal with in a corn-based replication                                 typically you use majority and such you                                 have to deal with your own                                 reconfiguration of your replica set and                                 in the case of sub if you end up because                                 AB you would look you look like this and                                 again I'm not going through the details                                 of the protocol but you would need                                 something like this in your system to                                 make sure that every time there is a                                 crash or every time there is a leader                                 crash you you have you go through this                                 phase where you're you're restoring the                                 operational system making sure that a                                 majority has committed state so that you                                 can start in a safe state so that end                                 part of the broadcast part is                                 essentially what i have discussed in the                                 in the beginning of the talk so an                                 alternative to that which doesn't                                 completely get rid of of the                                 complexities of implementing a                                 replicated system is to use a                                 configuration master like with the                                 vertical axis work by Lamport and others                                 and this is actually what at what                                 systems like Kafka and bookkeeper use so                                 let's let's discuss a bit those examples                                 it might have been in one of the of the                                 kafka talks during buzz words but let me                                 let me say a few words again about Kafka                                 so that we are on the same page so Kafka                                 implements a messaging layer so Kafka's                                 emasculate implemented as as a                                 disability replicator log it exposes                                 abstraction of topics where producers                                 produce messages to those topics and                                 consumers consume from those topics a                                 topic can be partitioned in in the                                 partition of a topic we have we                                 associated a replica set with that                                 partition we have a distinguished                                 replica that we call leader it's not a                                 fixed replica so you can change                                 dynamically according to failures or                                 sports suspicions and such and in the                                 other our fall is in your Kafka cluster                                 each one of those roles are going to be                                 mapped to a server so some servers are                                 going to be leaders or some partitions                                 some flowers are going to be some sort                                 of i can be false or for other                                 partitions that we distribute the load                                 across the kafka cluster like that so                                 let's say for example that I decide that                                 my partition needs to have needs to have                                 six replicas and I'm picking an uneven                                 number here a can of on purpose so in                                 Kafka um we have this notion of of is                                 ours I have the leader and I need a                                 minimum set of requests on a minimum set                                 of acknowledgements that I need to                                 receive before I declare a message                                 successfully produced and so we can say                                 that for example the ISR initially is is                                 the whole set because everyone is on the                                 same set on the same page synced up and                                 and so on but the is are obviously can                                 change over time so i can start again                                 with every                                                         decide that now the three bottom                                 followers are not catching up and so I                                 kicked them out                                 of the ISR and so I shrink the ISR and                                 later on at me decide to expand that's                                 the forward Sketchup so I can I have                                 this dynamic Sava of shrinking Anna and                                 expanding as needed and that dynamics of                                 that development of is ours use                                 zookeeper to store the composition of of                                 the ISR right so in the beginning I had                                 one two three four five six when the                                 bottom three crash then I and I and I                                 kicked them out of the ISR I update the                                 zookeepers say to be one two three and                                 later when expanded I i added i added                                 that the new followers so i can go like                                 that but now given that i can have a                                 nice art that is as small as three                                 replicas can I have a split brain                                 scenario here can I have a split                                 pensionary here so the answer is you                                 can't because what we do is we read the                                 ISR and we make sure that the new is our                                 needs to intersect with the previous                                 ayahs are so you read from zookeepers                                 say oh I have no element from the                                 previous are so I cannot I cannot become                                 a nice are so those three bottom                                 followers are not going to become a                                 parallel I sorry we are not going to                                 have a split brain perhaps later they                                 will catch up Anna and and will be                                 joined the ISR but there is a tricky                                 case here right I can have this other                                 scenario that looks a lot more like more                                 likely to be a split brain scenario so                                 everyone now was part of the previous                                 ayahs are right one two three four five                                 six they were all part of the previous                                 ayahs are and if they just declared this                                 helps to be part of the SR um they                                 legitimately in under under dense                                 constraints they legitimately can can do                                 it right and we couldn't have a split                                 brain scenario the trouble is we                                 actually don't we do a bit more than                                 that you cannot simply write to                                 zookeeper you need to write your                                 zookeeper using versions right so the                                 versions prevents that concurrent access                                 from producing to two independent is                                 ours and the use of versions in                                 zookeepers is our implementation of                                 compound swap and so give me a bit more                                 detail if both of them decide that the                                 to declare themselves is the new is are                                 they would do with the same version and                                 so that will double collection zookeeper                                 zookeeper except only one and so only                                 one of them is going to succeed as                                 becoming the new is our and so if the                                 bottom three try again they won't be                                 able to because they want to they want                                 overlap with the previous ayah which is                                 not one two three the best they can do                                 is actually you know sync up and and                                 ketchup and rejoin that there is our and                                 so you get this to work we need not only                                 a total order of changes right an                                 agreement on the order of changes today                                 as our but I in addition to that I need                                 this ability of preventing rights that                                 are being produced out of stale reads                                 and we use the versions for that the                                 second example which is about apache                                 bookkeepers not very different um but                                 let's just go over it quickly just to                                 see a bit of that the nuances we have                                 with with bookkeeper compared to a jew                                 Kafka simple keeper we have we have this                                 notion of lighters Ledger's you can                                 think you can think of like this as log                                 segments we have this notion of ensemble                                 which is the set of servers that are                                 bookies that are serving a given ledger                                 we don't have a leader among the bookies                                 instead we have with swim a single                                 clients a single writer and that rightly                                 responsible for making the changes to to                                 the bookie composition so in the                                 beginning the client is going to go to                                 zoo keeper and right you know my ledger                                 starting from zero is compel you know                                 comprises b                                                            three crashes and really play I replace                                 it with four then that same client is                                 going to go to zoo keeper and right                                 three now comprises b                                                 have a single writer if I have a single                                 writer than in Prince why I wouldn't                                 need to use versions because there will                                 be no no conflict no concurrent access                                 however there is one special case which                                 is when we need to close the light so we                                 require you to close these Ledger's                                    safely to guarantee that I upon read see                                 what you read a consistent state and you                                 can have a second writer that comes just                                 to close the ledger because it first                                 won't crushes then you might not be able                                 to close it and you would be open                                 indefinitely and you don't want that now                                 when this second client comes to close                                 the ledger you can end up in trouble if                                 you again don't use the versions in zoo                                 keeper so it is again all about                                 concurrent access doing updates over                                 your replica set in in zookeeper but the                                 advantage again between Kafka and and                                 bookkeeper is the fact that if i use                                 this scheme of updating the ledges in                                 zookeeper or in some coordination system                                 in using these versions i'm able to have                                 a more flexible replication scheme so                                 now comes the connection with with                                 consensus it turns out that compound                                 swap is consensus number n in the                                 inherently his hierarchy if you don't                                 know what what that is it's perfectly                                 fine the one sentence about this is that                                 being consensus number n means that with                                 that with that operation or with that                                 object with a chaos object you can solve                                 consensus wait free consensus                                       process so essentially what this is                                 saying is that if you want to use that                                 comp and swap consensus must be present                                 somewhere in your system in particularly                                 that implementation of of comparing swap                                 um but clearly as I mentioned the                                 beginning Constance is not needed                                 everywhere it's not that we're damned                                 than we we're not going to have any                                 system without consensus consensus there                                 are there are objects that this shared                                 objects that's not require consensus and                                 one key example is readwrite registers                                 as if I have anything that has a                                 read/write interface that we have                                 consensus number one which means that                                 you cannot reach consensus at all with                                 that object and in some sense it's great                                 if that's your requirement then you                                 don't need you don't need to worry about                                 about an implementation of consensus or                                 coordination and such and one clean                                 instantiation of that is a key value                                 store right where my reads are just                                 getting the data for a key my rights are                                 setting the data for key or deleting a                                 key but then you can come back to me and                                 say well um what if I want to implement                                 a highly available give that a store and                                 I you know I replicate it and I use                                 atomic broadcast to solve it right am I                                 you know am I not using a strong                                 primitive to implement this and so does                                 it mean that I have all of a sudden                                 exposing consensus even though I have                                 this key value store interface it turns                                 out that it you want right the fact that                                 you have the underlying atomic                                 broadcaster it's not going to give you                                 stronger guarantees all you're doing                                 there is exposing a weaker primitive and                                 one way I'm saying that is if you if you                                 take zookeeper and eliminate some of its                                 operations like create excess get                                 children eliminate the conditional stuff                                 essentially making it a key value store                                 so if i do that why doesn't why doesn't                                 sue keeper key value store solve                                 consensus here's one way of of observing                                 this if you if you watch implement                                 consensus with zookeeper what you would                                 typically do is create a hazy node so                                 the first client to create that c-note                                 will put the value that the season                                 you into that sea note but now with this                                 version of zookeeper that I'm proposing                                 here I don't have that a bit of creating                                 anymore I can just get and set so what                                 kinds can do is they can go to zoo                                 keeper they check if there is any value                                 that has been written I so Clank one                                 goes to zookeeper and says you know this                                 / consensus that any of that it has been                                 written already the zookeepers going to                                 say no and kind chu is going to do the                                 same so keep is going to say no no                                 Valley has been written and now they                                 both are going to write and the                                 zookeepers not going to stop them from                                 writing different values all right so                                 fine one is going to write zero client                                 choose going to write one and when Klein                                 one receives a confirmation that has                                 been written he may think okay so now it                                 has been decided now it has been decided                                 but then it has a problem that i have                                 just nation and you may think okay so                                 what if climb one reads again it's not                                 going to help because i can get that                                 last message at the bottom from flying                                 to and just push it as far out as I want                                 and so client one can keep reading and                                 keep reading see if something is going                                 to change and still I will be able to                                 write a different value so that gives us                                 some intuition of why if I have such an                                 API that is weaker won't be able to give                                 me this consensus a solution to                                 consensus all right so to wrap up this                                 is a quick diagram trying to be quick                                 for the flow trying to illustrate the                                 concepts that we have seen here the car                                 concept I've talked about is this                                 ability consensus it's it's it's key for                                 implementing it's actually equivalent to                                 Atami broadcast which is key for                                 implementing replicated state machines                                 and that's what you need to do if you                                 are implementing one of those now I have                                 also talked about a different way of                                 dealing with consensus which is by using                                 a configuration master i talked about                                 you examples Kafka and and bookkeeper in                                 both cases winded up needing                                 compare-and-swap which is consensus                                 number and so it used to have consensus                                 in your system if you are                                 if you are doing that however I also                                 made the argument that not everything                                 needs consensus which is great and so if                                 you're trying to decide whether                                 consensus needed needed at all in your                                 system you need to essentially go and                                 and determine if for example you would                                 be satisfied with a read writing                                 interface and in that case we know from                                 our theory that's consensus that one                                 won't be needed all right and so that's                                 everything I had to say I hope you have                                 learned something and I am ready to take                                 questions if you are if you have any                                 otherwise I can also take questions                                 offline thank you alright two things la                                 do we have we have time for two three                                 questions other questions in the                                 audience there's one hi and if the                                 consensus isn't part of the critical                                 path what does that have for                                 consequences on when a network petition                                 happened and or a crash happens on the                                 processing of the messages sure so if                                 you if you sure that's that's a that's a                                 good question so the question is                                 consensus not in the critical path and                                 so what happens to my critical path when                                 I do need to issue a consensus a                                 consensus operation to reconfigure my                                 replica said maybe you're writing that                                 if you do if sometimes you may have to                                 stop right to reconfigure your system                                 stop briefly right but assuming that                                 your system is operating normally for                                 example if you have a real leader                                 follower kind of configuration as we                                 have in Kafka and there is no leader                                 change then there is no there is no                                 operation going to a to your                                 configuration master you see need the                                 replication race and Kafka for example                                 is soo propagating the the messages from                                 the leader                                                              more questions                                 all right if not let's think the speaker                                 again thank you thanks love you
YouTube URL: https://www.youtube.com/watch?v=6WbtCMbV3wM


