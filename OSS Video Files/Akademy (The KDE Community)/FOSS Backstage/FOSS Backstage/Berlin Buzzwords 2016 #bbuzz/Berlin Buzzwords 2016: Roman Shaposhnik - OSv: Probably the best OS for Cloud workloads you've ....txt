Title: Berlin Buzzwords 2016: Roman Shaposhnik - OSv: Probably the best OS for Cloud workloads you've ...
Publication date: 2016-06-12
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	Roman Shaposhnik talking about "OSv: Probably the best OS for Cloud workloads you've never heard of"

With Docker Inc. buying Unikernel Systems and sparking renewed interest in unikernel technology, 2016 is shaping to be an undeniably year of unikernels. OSv is the revolutionary new open source technology that combines the power of virtualization and micro-services architecture. This combination allows unmodified applications deployed in a virtualized environment to outperform bare-metal deployments. 

Yes. You've heard it right: for the first time ever we can stop asking the question of how much performance would I lose if I virtualize. OSv lets you ask a different question: how much would my application gain in performance if I virtualize it. This talk will start by looking into the architecture of OSv and the kind of optimizations it makes possible for native, unmodified applications. 

We will then focus on JVM-specific optimizations and specifically on speedups available to big data and NoSQL projects when they are deployed on OSv. We will also cover a companion project Seastar that is now being used as a base for a hight performant replacement for Apache Cassandra, beating the Apache implementation on most of the benchmarks.

Read more:
https://2016.berlinbuzzwords.de/session/osv-probably-best-os-cloud-workloads-youve-never-heard

About
https://2016.berlinbuzzwords.de/users/roman-shaposhnik

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              thanks thanks for coming can you hear me                               all right is it not too loud okay good                               so I actually started tinkering with the                               sort of this osv project that I'm going                               to talk about in about three years ago                               and I used to give this presentation you                               know from time to time but a beginning                               of this year something happened so                               basically good friend of mine Brian                                Coentrao you know reacted this way to                                the purchase of you know the                                microcurrent also sort of unit colonel                                group you know by docker company and you                                know his idea was that you know the unit                                kernels which osv is an example of is an                                absolutely bad idea he even you know                                wrote this blog post that I actually                                highly recommend to everyone because it                                actually touches upon some really                                interesting issues in how and what unit                                kernels are trying to do with the                                application you know deployment in the                                cloud but I think sort of the frame of                                reference that Brian is coming to is                                slightly different from maybe actually a                                lot different to the frame of reference                                that I will be trying to sort of                                perceive in my presentation because to                                him the application deployment in the                                cloud is basically old school it's kind                                of like how we used to build                                applications where you know sort of                                developers were really aware of the                                underlying operating system and what I                                will be talking about is something that                                happened only recently so my frame of                                reference is basically                                platform-as-a-service and i will be                                using one of the examples you know                                there's a few available sort of Cloud                                Foundry is a good one because it's you                                know pretty widely adopted by the                                industry i work at pivotal so obviously                                you know I have to give at least a                                couple of slides you know to Cloud                                Foundry but in general Cloud Foundry                                basically gives you a really different                                model of how developers interact with                                the sort of underlying platform and you                                know like I said sort of different                                companies are investing and you know                                most of the companies from this slide                                not just in sort of the companies                                supporting Cloud Foundry organization                                but they actually practitioners or cloud                                foundry so they have internal                                development teams essentially using the                                platform to basically develop and deploy                                applications you know day in and day out                                so how do they do this not seriously how                                do they do this so basically the                                application is sort of sliced into                                chunks that then gets pushed into the                                platform that's it done like there are                                no containers there are no doctor files                                there is nothing it's very similar you                                know conceptually to how sort of j                                     application developer would interact                                with the you know application server                                where you know all you have to know is a                                developer is that you have to produce a                                war file and the rest you don't even                                know about it like you know whether your                                application server is deployed on unix o                                windows or maybe AIX you have no idea                                and you don't need to worry about any of                                them so Cloud Foundry is sort of the                                same you know similar approach and it                                works extremely well but it works                                extremely well for sort of a certain                                class of applications if you have your                                traditional j                                                           actually a little bit out of luck you                                kind of have to refactor and re-engineer                                your application to be following sort of                                these principles so those types of                                applications are known as                                          applications and I won't go through all                                of the principles but for those of you                                interested I mean                                                 factor that lab gives a really good                                overview of what it means to be a                                   factor application I mean most of this                                stuff is basically self-explanatory you                                know you basically have to have                                configuration that is separate from the                                applications you know you have to have                                pork binding that is outside of the                                application so you basically have to                                 kind of communicate to the platform how                                 your application needs to behave but                                 most important of all your application                                 has to be stateless which means that                                 your application basically has no                                 identity or parts of your application                                 have no identity % that identity may be                                 stored someplace else so your                                 application may you know talk to the                                 database or some kind of a persistent                                 store outside of the application but the                                 platform doesn't know anything about                                 sort of what mean what it means to sort                                 of hold a certain state and what will                                 allows the platform to do it basically                                 allows the platform to manipulate your                                 applications and all sorts of ways you                                 know scaling it up scaling it down you                                 know doing sort of roll out without                                 worrying about you know how to persist                                 that states that may be unique to this                                 chunk of application that you is you                                 know being manipulated so in practice                                 you know this sort of looks like this                                 you typically have sort of a man this is                                 looks awesome Wow                                 hmm I guess yeah this is pretty bad so                                 basically you know you have essentially                                 a manifest three application which                                 essentially is a gamma file that                                 explains a few things about the                                 application itself you know what sort of                                 chunks of the database the application                                 has to interact with you know what ports                                 it expects you know what sort of                                 configuration variables it expects you                                 know the ya know file you know typically                                 again you know hopefully maybe we can                                 get at least a glimpse of it or maybe                                 not ah right this is this is not going                                 well you know what let me try something                                 else let me quickly try something else                                 yeah okay so let me let me see if you                                 know maybe I'm pretty sure it's a laptop                                 issue or you know sort of you know the                                 issue with the buh buh buh buh buh okay                                 view full screen this is just okay okay                                 this is actually better in a way well                                 maybe not this is i I just I haven't                                 seen anything like that but basically so                                 where I so this is you know sit now this                                 is this is annoying this is now she's                                 showing up yeah um huh                                 nope does anybody have a different                                 laptop                                 oh yeah I've got it here do you get up                                 boo oh you've got it anybody can peel                                 yeah windows is fine I have a PDF scarce                                 oh yes ah nope                                 whoo they said you know we so this is oh                                 man this is this is not going as I                                 planned okay so let me try something                                 else again so if you can try to find a                                 laptop that would be appreciated well                                 for now                                 oh yeah I've got it already here mm-hmm                                 so do you ever use me yeah thank you                                 guys                                 mmm                                 sure are you gonna try all the laptop                                 yeah yeah yeah yeah                                 yeah well we have to display it first                                 yeah first one okay which one it's yeah                                 you can I there's this one so on that                                 side that's will display across here                                 okay so then we need we need this one                                 and then this one yeah they have like a                                 really convoluted oh I don't actually                                 yeah I have him I'd like I haven't seen                                 this this one ever in my life yep so                                 what's ya okay                                 oh okay yeah that's German system                                 settings systems preferences yeah yeah                                 yep not here not yet yeah yeah so when                                 it's far yeah and just make it mirror if                                 only understood German yeah it's still                                 flickering but I think it's better it's                                 way better than it used to be so yeah                                 can you go fullscreen awesome ah ok                                 thank you yep all right so I will try to                                 talk real fast because you know we kind                                 of lost a little bit of time but the                                 good news is you can actually see it so                                 this is how the manifest file looks like                                 and basically what the developer has to                                 do is just this right you know CF push                                 and then using that manifest file what                                 the system does is essentially it builds                                 you know whole bunch of images and those                                 images are known as droplets so those                                 images are essentially the application                                 source code something that is known as                                 build pack basically all the sort of                                 prerequisites for that source code and                                 then a filesystem stack is kind of like                                 Colonel and all these bits and pieces                                 that blue you know everything together                                 so then for example once you deploy your                                 application and you want to scale it you                                 know to a different number of instances                                 you can actually do it automatically but                                 you can do it manually as well and all                                 the system needs to do is to basically                                 sort of copy those droplets on two                                 different you know sort of containers                                 and off you go so the idea here is that                                 the anatomy of the droplet is basically                                 some of the microservices code you know                                 sort of again that's the piece of your                                 application some kind of a virtual                                 machine you know most of the time it's                                 typically java virtual machine but if                                 you think about it you know go runtime                                 could also be considered as a virtual                                 machine then there is some stuff and you                                 know obviously there has to be hardware                                 you know for all of it to be executed on                                 so how we doing it today with Cloud                                 Foundry so most of it is basically done                                 through essentially run see images so we                                 don't actually use I                                 we can run on docker but we can also                                 just use run see images and we kind of                                 put you know the sort of minimum version                                 of a minimal version of ubuntu as a base                                 image and put sort of the build pack and                                 application code on top of them so a                                 better way and I think you know that's                                 what this presentation is about then                                 again that's why I think you know Brian                                 was a little bit off in his comments is                                 that if we can reduce the amount of the                                 operating system that we put into each                                 of those containers you know we win                                 because the image becomes much smaller                                 and especially on the sort of already                                 virtualized environments like you know                                 public cloud and you know some of the                                 OpenStack deployments we avoid sort of                                 this double you know virtualization you                                 know sort of we avoid virtual machines                                 you know em containers within the                                 virtual machines so basically this is                                 the taxonomy of you know everything that                                 you're sort of container platform could                                 support so you know this image was you                                 know done by Graham dumbleton and I                                 really like it because you know                                 basically you have the container image                                 and there is nothing wrong with it you                                 know you can still use it but the unique                                 kernel-based container image is much                                 smaller and thus much easier to manage                                 and scale and that thing on the right is                                 java runtime which is big either way you                                 look at it so what is a unit colonel so                                 unique kernel as a concept but actually                                 around for quite some time but it got                                 kind of sort of into the public view i                                 would say in                                                         paper was published and the whole notion                                 of a library operating system was                                 introduced so basically we all expect                                 our operating system to beacon you know                                 sort of a kernel and then I call bunch                                 of user code so what these guys for the                                 first time proposed is that why don't we                                 put all of the operating system kernel                                 and the application itself in the same                                 sort of image and run everything within                                 the essential ring                                                     know there's a few things that we cannot                                 really do you know we cannot for example                                 have multiple processes you know sort of                                 switching because you know that's sort                                 of one image running within the you know                                 one sort of address space and this                                 executable because it really becomes an                                 executable this executable can only be                                 sort of run on                                 of some kind of virtualization system so                                 it's qmo you know virtualbox vmware is                                 an public cloud you name it so how do we                                 build it that question was actually                                 answered by anti Conte through a                                 different sort of work that he was doing                                 within that bsd system and his work was                                 focused on any Colonels so what he was                                 trying to do with the net bsd is to                                 basically kind of ria factor it into a                                 set of components that can be leveraged                                 you know in all different contexts right                                 because if you think about it inside of                                 your kernel implementation you basically                                 have things like let's say tcp/ip stack                                 now that piece of code could actually be                                 useful stand alone as it is and there is                                 absolutely no reason for it not to be                                 able to sort of turn into a library and                                 you know linked let's say a custom                                 tcp/ip stack into an application that's                                 running even user space mode so what and                                 he was doing he was basically                                 refactoring the build of the net bsd to                                 make net bsd essential a much more                                 granular and be able to expert those                                 useful bits and pieces you know to other                                 use cases so that's actually what i see                                 when i talk about him because you know                                 in a way for those of you who are                                 familiar with futurama you know aunty is                                 basically back le docteur of net bsd you                                 kind of like just you know cut net bsd                                 into a whole bunch of organs and you                                 know you can actually still run their                                 bsd that way you know you can kind of                                 like put it back together and that would                                 be a sort of an operating system or you                                 can basically use it in all sorts of                                 different places as well so Judy curls                                 either way you build it either through                                 any kernel or a specialized kernel is                                 basically a couple of implementations                                 that you can get today and you know you                                 can start playing with it so the                                 granddaddy of them all you know that's                                 the implementation from which the                                      paper you know got a sort of published                                 is in mirage eos it is sort of a Zen                                 based you know thing that was actually                                 developed you know by a group of people                                 in cambridge you know around sort of a                                 camel so everything that you do has to                                 be a no camel but if you sort of                                 subscribe to that notion you actually                                 give a pretty decent amount of                                 optimizations you know that you can pull                                 off so again a good example would be so                                 suppose your application doesn't need                                 let's say UDP you know don't need to say                                 you know send UDP packets right these                                 compiler can analyze you know the                                 dependency chain and basically figure                                 out that the colonel doesn't need to                                 have that part of the sort of tcp/ip                                 stack and just like a static linker                                 wouldn't link an object file that you                                 don't need it wouldn't actually link you                                 know the poor portion of the tcp/ip                                 stack that deals with UDP so stuff like                                 that but again you have to basically a                                 kind of you know jump into o camel and                                 certain people like it you know I don't                                 really have an opinion one way or the                                 other so then there is Clive again it's                                 a research project out of university of                                 madrid so they're trying to do a eunuch                                 kernel based on a go operating system so                                 you know there is some lineage you know                                 going back to plan                                                   like the same research group that did                                 plan B it's a very nice system because                                 at least it sort of deals with the                                 language that everybody is familiar with                                 but it's still pretty research in nature                                 so like I said Rahm Colonels is sort of                                 anti Conte's way of doing sort of you                                 the kernels and then osv is what we will                                 be talking today about but before I                                 actually start talking about osv because                                 you have this you know great collection                                 of technology that provides you                                 capabilities of doing unique kernels a                                 way to essentially manage it emerged and                                 this is the project of unique it's                                 basically think of it as a GCC toolchain                                 you know for different kind of unique                                 URLs right so basically this project                                 allows you to essentially focus your on                                 your application instead of on focusing                                 on sort of the differences between                                 different unique kernels and how to run                                 them so you get a decent sort of command                                 line utility to basically play with all                                 of them at once and today it supports                                 osv and Trump but they actually building                                 a lot of you know support into unique                                 and actually really like it for two                                 reasons first of all it has a docker API                                 so a docker client can actually                                 manipulate unique Colonel thinking that                                 it's talking to the doctor demon and                                 second of all this project is actually                                 what we're prototyping as a back-end for                                 cloud foundry so that sort of                                 introduction that I've done around you                                 know how cloud foundry scales the                                 applications unique is likely to be the                                 implementation that we will prototype it                                 around so take a look at it now let's                                 focus on osv because that's you know the                                 subject of today's talk and that's                                 actually to me the most interesting of                                 the unique kernels out there so what is                                 OS V so V is                                 the colonel focusing on POSIX                                 functionality so the idea behind osv is                                 that you should be able to take anything                                 that is a POSIX application completely                                 unmodified and essentially link it with                                 the library that hv gives you and turn                                 the whole image into essentially an                                 application that will be like i said                                 running inside of the same address space                                 you know enduring zero but any kind of                                 POSIX system call that you do would                                 still be supported it runs on top of kvm                                 Zen VirtualBox vmware so basically full                                 gamut and it's pretty fast you know it's                                 unicron's go but it's not as small as                                 something like Oh camo because again                                 POSIX is actually pretty big standard                                 you know you have to provide a lot of                                 functionality to be POSIX compliant so                                 we see manifesto you know very quickly                                 they have an explicit goal of running                                 existing Linux applications so the only                                 thing and I will talk about it you know                                 a little bit later the only thing you                                 have to do to an existing Linux                                 application is if you have a bill that                                 produces you know a dot out you know                                 kind of sort of elf executable you need                                 to modify that bill to start producing                                 shared object you know with the special                                 entry point so that the dynamic linker                                 that is running inside OS we can sort of                                 you know dynamically load it and start                                 executing it but that's literally the                                 only change that you have to make so                                 they're trying to make boot time                                 comparable to the execution time so                                 basically they're explicit ball is it                                 should take osv unique colonel to boot                                 the application you know the same amount                                 of time that it takes the real operating                                 system to actually execute the very same                                 application and they are trying to stay                                 open so the group that is doing it was                                 actually the same group that did kvm                                 implementation in Linux so they used to                                 be really focused on Louis V they still                                 pretty focused on ASV but i think you                                 know they are now shifting their focus                                 so if you guys are liking what i'm                                 talking about today you know jump on the                                 github and you know help sort of with                                 voice v development because the focuses                                 shifting a little bit again it's not                                 that the project is being dropped it's                                 just you know that we need more sort of                                 volunteers to help OHV go along so                                 what's inside so you know let's just                                 talk about you know how it's all                                 implemented so like I said you know it's                                 basically an image right you know it's                                 the same image that let's say you're                                 sort of fool you know virtualization                                 build with                                 produced when you're producing vmdk or                                 any kind of your disc image to be                                 basically booted on one of those                                 virtualization solutions so inside of                                 that image you basically have C++ kernel                                 code you know written from scratch so                                 that's the difference between sort of an                                 any colonel approach because in the end                                 colonel approach that kernel code would                                 be taken from neb bsd so that's sort of                                 how they do it in the oil swiss case you                                 know they wrote the kernel code from                                 scratch it's c++ c plus plus                                         actually pretty clean sort of nice C++                                 so again if you like you know C++ you                                 know that's one of the nicer projects                                 you know to get to get to go ad so then                                 there's basically a dynamic linker that                                 links you know a whole bunch of shared                                 object remember how I told you that the                                 only sort of change that you have to                                 make to your existing application is to                                 turn it into a shared object so                                 basically there is a shared object for                                 you know things like lib JVM if you're                                 running a java application and then                                 there is a whole bunch of modules that                                 implement you know typical functionality                                 of the operating system like being able                                 for example to talk to a file system                                 what's interesting about osv is that                                 they decided to take a filesystem are                                 you know from open ZFS project actually                                 by the way of you know net bsd but still                                 so it's a full-fledged EFS                                 implementation wish again nowadays that                                 ubuntu a shipping ZFS it's not sort of                                 that super cool but it used to be that                                 you can actually do a lot of cool things                                 with ZFS like you know snapshot                                 rollbacks sort of within this unique                                 oral approach which again to me is you                                 know really really cool and then there                                 is a bunch of kernel threads and a bunch                                 of user friends but again the point is                                 all of them are running in the same user                                 space right what does it mean it means                                 that if you have a pointer arithmetic                                 you know bug in your user code that can                                 totally crash your colonel why it's not                                 a problem because the colonel does not                                 multiplex between different processes so                                 speaking of which a couple of things                                 that ways we absolutely cannot do so it                                 is not a hundred percent replacement for                                 linux kernel for obvious reasons so for                                 example for king is not allowed because                                 again the whole idea of working is to                                 basically create a copy of the you know                                 address space an essential started                                 process with this sort of existing copy                                 of the address space but started in a                                 separate sort of every space so that the                                 mediations the                                 the child does you know are not visible                                 to the parent so that is absolutely not                                 allowed because we're still running in                                 the same address space you know we're                                 running everything in there so there's                                 no process isolation there is no sort of                                 process isolation not even just between                                 processes but we between a process and a                                 kernel again your process can crash the                                 kernel which by the way means that the                                 best things that are sort of voice v                                 native things that don't allow you to do                                 memory manipulation from the user code                                 so things like Java ago I actually a                                 really good fit for AC you can still run                                 your C and C++ applications but like I                                 said you know anything that would result                                 a lake or a dump in a traditional                                 operating system would result in the                                 whole image crashing here again in this                                 approach where you kind of sort of blast                                 these droplets on the cloud platform                                 that is not a problem because in that                                 approach you know your container or your                                 unique kernel or the you know process                                 running on the traditional UNIX is                                 basically doing one thing and one thing                                 only so in a way a core dump is                                 indistinguishable from the whole thing                                 crashing because there is nothing else                                 that is essential running within the                                 same sort of container operating system                                 or you know whatever it is that you're                                 running and obviously you know this has                                 the least amount of drivers because                                 basically the only thing that it                                 understands its central of virtualized                                 drivers right so the Vorta yo is the                                 only driver that this Unicron Oh                                 understands again not a problem with the                                 anti-countess approach because his idea                                 is you know if you want a driver it is                                 available in the net Bhd's source code                                 base so once you run sort of linking the                                 any colonel together you can totally                                 just lift the driver and you know start                                 using it ah it is actually pretty well                                 suited for applications that are network                                 intensive it is not you know that's much                                 sort of suited for the applications that                                 are compute intensive and for obvious                                 reasons you know basically if all you do                                 is compute you know any amount of                                 virtualization without will only hurt                                 you the real question is like why does                                 it actually helped with the network so                                 let me go through some of the point here                                 so in a traditional Linux kernel two                                 problems exist first of all the tea                                 PAP stag has to explicitly allow for                                 multiplexing between different processes                                 essentially different clients on the                                 system nothing like that is needed in                                 the Oasis implementation because again                                 remember there is only one process and                                 only one every space also because they                                 could implement it from scratch what                                 they did they essentially took the idea                                 that van jacobson sort of proposed as                                 net channels and i think you know it                                 kind of sort of got rejected in its                                 entirety by the Linux community because                                 it would just require too much                                 modifications of the Linux kernel but                                 the oils V guys you know could actually                                 implement it and what it does it                                 essentially allows them to run extremely                                 quickly through the code that is                                 typically part of the colonel you know                                 tcp/ip stack code what it means is and                                 you know that actually was a surprising                                 result of one of the profiling what it                                 means is that because the code path is                                 sho short the data that arrived on                                 unique doesn't actually leave the I cash                                 by the time the application thread gets                                 to see that data so what typically                                 happens in a traditional operating                                 system kernel is that by the time the                                 application sees the data the data has                                 already yellow sort of got evicted from                                 I care for also the reason just because                                 you know the code path is so long                                 through the kernel right here it doesn't                                 happen and that's one of the reasons                                 that the i/o intensive applications                                 actually running much faster and I see                                 so memory management is also interesting                                 on is V so again in a traditional sort                                 of operating system you basically have                                 an OS image and then you have different                                 processes and then you have sort of like                                 something like JVM you know sort of                                 manipulating memory in its own right of                                 course in osv we don't have the other                                 process so the picture gets I'm                                 simplified so we have just one process                                 memory which is actually                                 indistinguishable from the OS memory and                                 we have something like JVM but a trick                                 that the osv guys are pulling is                                 actually kind of interesting so they                                 decided to flip the relationship between                                 the operating system and the client code                                 so instead of trying to guess how much                                 memory do you give to JVM you give all                                 of the memory to JVM and then you                                 essentially allocate a dummy a peck                                 object that the operating system can use                                 for its own needs why and how well                                 because it's all in the same address                                 days so basically from the standpoint of                                 the JVM this is just a byte array that                                 exists and it has a reference that                                 cannot really be garbage collected ever                                 from the operating system standpoint                                 it's a chunk of memory that it can use                                 for its own needs so basically again it                                 completely flips the relationship                                 between sort of how much memory is                                 allocated to the application versus how                                 much memory is allocated to the                                 operating system kernel another thing                                 that is actually pretty cool is because                                 everything is running in ring                                          the CPU capabilities that are typically                                 occupied by a real operating system                                 kernel like let's say mm you are now                                 available to the application code what                                 it allows them to do is for example it                                 allows them to do optimizations on the                                 garbage collection side because again                                 you know if you think about how garbage                                 collection works in Java is basically                                 you know we have object one you know                                 keeping a reference on object to now if                                 that reference breaks how could it                                 possibly happen well you know the                                 pointer that was pointing from you know                                 object one to object to God nullified so                                 that is a memory access and if we have                                 an MMU capability available to us in the                                 application we can actually track that                                 memory access the same way that the                                 operating system is tracking access for                                 paging so essentially we can basically a                                 trap inside of an MMU based on the                                 memory access and thus essentially keep                                 it bit vector of everything that ever                                 got updated so that the garbage                                 collector doesn't have to guess which                                 object got updated and which ones didn't                                 so again helps a really sort of a big                                 time with garbage collection pauses all                                 of what I'm talking about is still very                                 much your research right you know it's                                 kind of like cool capabilities that are                                 possible now we haven't really sort of                                 try to run it you know to the full                                 possible extent essentially kind of like                                 just stressing them right but what's                                 available and at first what is possible                                 is kind of cool in its own right so by                                 the way how how am i doing on time is I                                 can do five minutes left okay awesome so                                 I mean yeah apologize for speaking in                                 all really quickly but I'm actually sort                                 of kind of almost done you know trying                                 to impress you with our three so hopeful                                 you know I've done enough of it so that                                 you guys at least check out the code                                 base and you know check out the examples                                 the real question is we actually seen it                                 before so I used to work for sun                                 microsystems you know way back when sort                                 of I didn't quite catch you know the                                 time when Java got invented but you know                                 I was reasonably close to it and son                                 actually had a number of projects where                                 we try to run Java on bare metal right                                 you know we try to actually come up with                                 the CPU that would try to run Java there                                 was a company still is you know called                                 Azul that is sort of trying to do that                                 and nothing really stuck right you know                                 we don't really have Java native CPUs                                 Java is still very much of an                                 application you know software thing so                                 why should it work this time I think you                                 know back when Sun was doing it we                                 actually didn't have a couple of things                                 so first of all um we actually didn't                                 have you know as well developed                                 hardware-assisted virtualization as we                                 have today and what I mean by that is                                 all of these sort of CPU capabilities                                 that intel has pushed into the just you                                 know run-of-the-mill you know intel                                 chips that are now available and                                 essentially making io especially you                                 know efficient in virtualized                                 environments we didn't have elastic                                 infrastructure obviously you know back                                 then something like cloud was not really                                 you know available and to me the                                 ultimate sort of point that i think will                                 make a difference this time is we didn't                                 have something like a platform as a                                 service component that would actually                                 completely hide all of that complexity                                 of how the application gets linked into                                 an executable image away from the                                 application developer and we really need                                 this piece of technology and you know                                 why because what I'm talking about it's                                 just this tiny portion inside of what a                                 typical platform as a service you know                                 software component does right so all I'm                                 talking about today is how this stuff                                 gets linked and how it runs but the                                 platform is the service actually takes                                 care of a lot of other developer needs                                 routing you know log collection tracing                                 and all of the capabilities that                                 essentially Brian took an issue with                                 when he was talking about unicorns                                 because his idea is that unique kernels                                 if you view them as a replacement for                                 traditional applications are essentially                                 completely unobservable and very                                 difficult to debug and I actually                                 absolutely agree                                 that if you are trying to just run it as                                 a replacement to your traditional sort                                 of application you know life cycle it's                                 not a particularly good idea but if                                 you're already embracing                                 platform-as-a-service then you are                                 giving up on those capabilities anyway                                 because in a platform of a service it's                                 the platform itself that makes you                                 observe the application that makes you                                 see the logs that are coming from the                                 application because in a platform as a                                 service the application has been                                 essentially sliced and diced in bits and                                 pieces that only platform knows about                                 and you have to query the platform there                                 is no way you can ssh in one of those                                 droplets that i was showing you so in a                                 way if we're running platform as a                                 service then all of the unique ronal                                 capabilities can be used as optimization                                 techniques for making our applications                                 run faster so with that I will just                                 spend you know two minutes essentially                                 kind of sort of telling you about my                                 yellow pipe dream vision of a                                 next-generation data center to me it's                                 basically a commodity Iraq provision                                 hardware I mean that's kind of given you                                 know that's how most of the data centers                                 are built today just enough way s you                                 know basically an operating system that                                 runs on the hardware and is just a                                 simple glorified device driver for all                                 of the hardware that it needs to manage                                 plus a capability that gives me some                                 kind of virtualization could be Samm                                 could be kvm I don't care so my                                 operating system is something like                                 Korres or smart ways you know that's                                 sort of the Solaris you know equivalent                                 of core OS and just enough functionality                                 to essentially boot this new                                 next-generation format that i would like                                 to call dr plus plus because if you                                 think about what daughter or you know a                                 sort of run sea container really is it's                                 a different sort of executable format                                 and just like elf what's kinda a nice                                 way to standardize all of the different                                 executable formats on unix is we're now                                 sort of having this format that can be                                 used and all sorts of virtualized                                 environments and then of course on top                                 of that you actually have to have                                 something like platform as a service so                                 Cloud Foundry is a good example but                                 there's a couple of other in there in                                 the running and that is I think the                                 vision of a next-generation datacenter                                 and why does it matter I think you know                                 because if we go that way then we can                                 finally kill DevOps because the                                 division of labor between the                                 development and IT will be very clear                                 the development developed something that                                 the platform can manage and the IT                                 basically wrecks and you know stacks and                                 you know cables and there's really                                 nothing in between because the platform                                 itself is capable of essentially giving                                 such an incredible amount of                                 observability insight into your                                 application that you don't have to have                                 a third team telling you how your                                 application behaving introduction or in                                 testing snowflakes in this type of data                                 center will not exist because again the                                 platform will not allow for a snowflake                                 you know how screwed up most of the                                 doctor files are today developers don't                                 actually have to deal with docker files                                 in this type of environment so I you                                 know I hear that they are already                                 clapping in the other room so I guess                                 with that I will just open it up for                                 questions so thank you so much for                                 listening thank you so much do we have                                 questions all right maybe I didn't hear                                 about everything but when you say you                                 run the JVM you have a single core                                 everything right no it's a it's actually                                 capable capable of multi-core as well                                 all right because that's what I went in                                 good but by the garbage collector how it                                 works if it's not so this particular                                 implementation is essentially a set of                                 patches on top of OpenJDK that make it                                 possible like it's you know it's a                                 pretty involved set of patches so you                                 cannot really take so with osv because                                 all you need is a shared object you do                                 have an option of taking liebe liebe JVM                                 do so from let's say an oracle you know                                 jdk like that's totally an option and                                 you can do that but then you won't be                                 sort of experiencing all of these                                 optimization techniques that i talked                                 about you would still for example get                                 the benefit of a much shorter code path                                 through the tcp/ip stack so those guys                                 you know did some measurements of                                 Cassandra and Cassandra benefits quite a                                 bit even on this talk oracle JVM but for                                 the kind of optimizations that i was                                 talking about sort of the                                 garbage collection and the memory                                 ballooning you actually have to get the                                 OpenJDK you know with a set of patches                                 yea i meant more of a when the garbage                                 the garbage collection is running in                                 multi cpu mode Oh in multi CPU more                                 that's AMS or write that feature is                                 actually available only on the single                                 core so again in general osv is                                 multi-core aware but this particular                                 feature is only on the single core yeah                                 thank you for the overview I only see                                 one issue if you can manipulate                                 something running in in a ring                                        the java virtual machines and everything                                 is open so you can manipulate every trap                                 every low-level thing from from java and                                 this is only allowing you running really                                 friendly applications you cannot run                                 from code because otherwise you get a                                 major security well open doors yeah I I                                 think we're having different frame of                                 references right you know when you know                                 if you're if you're on ring                                              everything you can replace every trap in                                 the operating system so and if you have                                 memory manipulated from the Java Virtual                                 Machine which is a good issue for a                                 performance from the point of view of                                 the Java Virtual Machine you can                                 manipulate anything on the auditor you                                 can replace traps in the operating                                 system and this is only for your own                                 code not multi-tenant nothing I would                                 back nothing yeah you're absolutely                                 correct if just random code is allowed                                 into this image that because how the                                 platform is doing it the platform is                                 actually taking the source code and                                 everything else is done by the platform                                 so all of the bits all of the binary                                 bits that I essentially getting into the                                 droplet are the binary bits that only                                 platform can put into a droplet again no                                 more docker files like it's not a docker                                 file approach where a developer is                                 trying to tell the system how to build                                 the image the only thing that developer                                 is supplying is the source code for the                                 application itself and again even like                                 that source code can have bugs                                 oh sure obviously but if you are talking                                 about sort of exploits it is only if the                                 developer puts those exploits in the                                 code on purpose then that becomes a                                 problem but that is a problem anyway so                                 if a developer is basically sort of                                 putting exploits inside of a talker                                 container you're in trouble anyway                                 because deb dr. container can you know                                 open network connections that you know                                 would send you know random traffic and                                 do all sorts of your weird things even                                 though within the docker container                                 itself I mean there is nothing but the                                 user code Thank You Ramon listen                                 gentlemen will you please give a round                                 of applause to yourself to for helping                                 them yes I'm thank you for helping it                                 and comment
YouTube URL: https://www.youtube.com/watch?v=bsFARLr8is8


