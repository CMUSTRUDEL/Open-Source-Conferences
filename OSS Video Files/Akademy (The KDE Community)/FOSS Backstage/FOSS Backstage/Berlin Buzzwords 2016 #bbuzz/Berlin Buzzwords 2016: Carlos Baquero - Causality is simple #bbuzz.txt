Title: Berlin Buzzwords 2016: Carlos Baquero - Causality is simple #bbuzz
Publication date: 2016-06-13
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	Causality is an essential component of how we make sense of the physical world, and of our relations to other humans. If I put a cup on the table, and look back at it, I expect it to be there. I also expect to get a reply to my postcards, after I send them, and not before.  

These days hardly any service can claim not to have some form of distributed algorithm at its core. In a distributed scenario, if we are not careful, it is very easy to break the causal sense of things. In a key-value store my writes can be directed to a replica, and my subsequent reads served from an outdated one --- my cup might not be there when I look back. Message dissemination middleware might not always provide the ordering I expect --- I might receive some replies, before their leading questions. 

Luckily, most of these problems were already there 30 years ago, although in a much smaller scale, and lots of techniques have been developed to keep track of causality and make sense of the complex interactions in modern systems. However developers often look at techniques such as as replica synchronization with version vectors, or causal broadcasting algorithms, as black boxes; or as complex sets of rules that have to be followed and not questioned. 

This talk will focus on bringing back the intuition on causality, and show that keeping in mind some simple concepts, allows to understand how version vectors and vector clocks work, and were they differ, and how to use more sophisticated mechanisms to handle millions of concurrent clients in modern distributed data stores.

Read more:
https://2016.berlinbuzzwords.de/session/causality-simple

About Carlos Baquero:
https://2016.berlinbuzzwords.de/users/carlos-baquero

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	                              so let's start this talk thank you for                               attending so I'm I'm a researcher and I                               teach distributed systems mainly in Ming                               University and we do research in the                               context of this lab that has lab the                               high assurance software lab and so my                               proposal is to to try to explain you                               that causality is simple and I've chosen                               this title but when I was doing the                                slides and looking at the content I had                                to do a little rewrite okay so it's                                going to be moderately simple but I'll                                try to make it as intuitive as possible                                cut that's the overall goal of the talk                                so let's let's start with that and why                                should we care about causality nowadays                                basically we should care because it's                                very hard nowadays to program and not be                                programming in the context of this UT                                System ok so what used to be a                                playground for academic researchers that                                were doing very nice algorithms and                                using nice math to impress each other                                now some of these things are really used                                nowadays and when they are not used some                                anomalies occur in the systems that we                                run okay so it's important to to try to                                work with them or at least use the                                libraries that implement these churches                                and know when we need to use them so                                let's let's get into that some of the                                anomalies that you might have                                experienced have some examples you're so                                suppose you didn't well your sound of                                the son of your telephone is probably                                off but you can feel a buzz so you get a                                notification from Twitter that there is                                a new interesting tweet that you should                                go and check and you could go and check                                it but it's not there yet so something                                strange happened what happened here is                                that we had two different notification                                channels one did a notification that                                something was available but it's still                                not cached locally on your or your local                                content provider for the application so                                you get a Miss when you go and fetch the                                tweet that you are interested in so this                                is something                                that could be prevented if there was a                                causal delivery precondition between the                                two the two events another example which                                is a classic one is that you want to                                post say somesome picture of you in                                vacations when you were supposed to be                                working or something like that so you                                remove your boss from from the list of                                people that are going to see pictures in                                that group then you post to the group                                but then he sees opposing so what                                happened is that there is a relation                                between the two events that was not                                enforced by the system and he was                                allowed to see the picture before the                                removal got into effect in the system                                and he was removed on another area if                                you systems based on last writer winds                                like Cassandra other types of anomalies                                also can happen so this used to happen I                                don't know if this has been fixed                                nowadays but the following think will                                happen that you you you could write into                                it or into an object in in Cassandra and                                if you if your clock was far ahead of                                all the other clocks that are using it                                you you actually actually writing that                                with the way the doom stone and this                                means that other users will be able to                                read what you have written and when they                                try to write back like a response they                                will not be able to do it because their                                time is behind the time of the time                                stamp that was used for the first                                writing so there's lots of problems with                                using clocks and other sort of the                                consistencies like for instance II did                                some tweet was favorited three times but                                only two are over there okay and so now                                you could think can't we use time steps                                to fix it or simply use a spanner and                                solve these issues well I'm going to                                spend some slides here trying to show                                you about some of the limitations of                                real time so even if we were able to                                have a perfect coordinated time                                everywhere we will still miss some                                information so the problem with time is                                that there is no no and I'm referencing                                these to a very nice article by Justin                                 she that appears in a CM q                                 last year that talks about these kind of                                 problems so basically we ever now now                                 that because we are in the same room and                                 we might have more or less the same time                                 reference but this thing doesn't                                 translate to what is happening in in in                                 other locations in general so for                                 instance when everyone knows these that                                 when we are looking at different events                                 like if I think this is a Crab Nebula we                                 are we are actually looking at the past                                 so the more distance something is the                                 more into the past we are looking and                                 this is quite obvious in astronomy but                                 this thing also happens in our rule so                                 if i if I'm receiving a message that is                                 coming from Australia there is a some                                 milliseconds of delay in in relation to                                 the time when that event occurred and                                 actually light speed is the speed of                                 causality ok so we need to discuss out                                 to track the relations between events                                 even in the real world so basically time                                 is is inherently local so I that can be                                 very useful if I have a wall clock that                                 is close to me and if this wall clock is                                 growing monotonically I can use this                                 wall clock to do useful things and I                                 might even not try to use some                                 approximation of time I can do very                                 useful things just by having a counter                                 that starts at one and then I keep                                 incrementing it as I need another                                 reference to time but what will be                                 tricky will be trying to use information                                 from wall clocks at very different                                 locations ok because will have different                                 delays and it's really hard to relate                                 the events that occur in multiple                                 locations in terms of what would be real                                 time a final thing about time because                                 before i get into the causality tracking                                 is that in order to track time we                                 typically we need memory we need to have                                 memory of what happened if you look at                                 this image on the left and now this is                                 before and this is after you noticed a                                 transition                                 but if you actually look at the same                                 thing and you consider that one before                                 you see the same transition and they are                                 the same image so the this is showing                                 that some events in the world inherently                                 they don't have any notion of time so if                                 we look at the two pictures we have no                                 idea of knowing which came before the                                 other we only know that the smoke is                                 flowing in the given direction at this                                 scale because we have this persistent                                 memory in our eyes and brain of what we                                 have seen before and this is what we                                 need to do also in distributed systems                                 because we have many states that I                                 indistinguishable so in order to relight                                 them we need to have some notion of                                 memory so we need to basically memorize                                 events so the overall motivation is that                                 time is complicated it's not a straight                                 timeline what we are looking really                                 looking at in disputed systems is that a                                 web of causes and effects that we need                                 to be aware of in order to make sensible                                 decisions so I'm going to cite the piper                                 from the                                                              westland port which is a physicists and                                 that recently won a maturing award and                                 he basically realized it or translated                                 these notions from physics into                                 distributed systems and introduces the                                 notion of causality to the field of                                 disputed systems in the late seventies                                 so in order to introduce it i prepared a                                 simple social interaction example to                                 explain it a little bit and then we'll                                 get into the time diagrams that some of                                 you will be familiar with so in this                                 social interaction Alice decides to to                                 have dinner and then she tells that to                                 Bob and Bob agrees to have dinner but                                 meanwhile there is a third party which                                 is Chris that he's bored here is nothing                                 to do and finally he hears about the                                 dinner plans and he asked to join so                                 this is a social interaction and now                                 let's see it in the space-time diagram                                 so in order to to track these things we                                 are going to assign unique event event                                 is identifier to each action so when                                 alice is asking if someone is interested                                 for dinner we tag that thing with the a                                  so to do that and we often call this                                 finger dot this unique track what we                                 need is a location name here it is Alice                                 and I'm just using the a letter and we                                 have a monotonic counter so a counter                                 that is always growing that we can use                                 in a single location to distinguish                                 different events so I'm using                                           and we do these things in the several                                 locations so now we can talk about                                 events and the arrows show message                                 passing passing the arrows between                                 locations I also included a timeline so                                 this is what will be a global time if                                 such thing existed so a global view of                                 the system so one thing we can see here                                 is that there are events that are                                 actually concurrent so the fact that                                 alice is wanting to have dinner is                                 unrelated to the fact that chris is                                 bored so this means that Alice didn't                                 influence the set of crease in the event                                 C                                                                       not cost Alice to want to have dinner                                 but if we look at fee at this thing and                                 a real time if we think that real time                                 is a solution what we will see is more                                 relations that actually exists so in                                 real time Alice wanting dinner was                                 before in real time then Chris being                                 bored so it might look at it cooled of                                 interest but what we actually know from                                 what information went through the system                                 is that these two things are not related                                 so actually causality brings us more                                 information about what's happening that                                 what is brought by real time so how are                                 we going to track these we cannot be                                 drawing arrows all the time in the                                 system and so we could go and check the                                 vector clock entry in wikipedia and you                                 get all these nice formulas over there                                 that you'll tell you all to use vector                                 clocks but this is a little bit                                 complicated and magic so now there's                                 lots of people need to use these tools                                 and they'd just go the check the rules                                 and the rules kind of work or the user                                 library but these always looks a little                                 bit kind of                                 magic so I will try to give you some                                 intuition of how these rules are like                                 that and where do they come from and to                                 that end we'll start with something                                 simple simpler call it causal victories                                 which was a concept introduced it in                                                                                                        show you what these things are so the                                 basic intuition is again that we are                                 collecting memories of the events that                                 we have seen in the past and we do that                                 by colette simply by collecting a set of                                 events and if we collect if we have                                 unique event tags dots and if we collect                                 set of events we can use that inclusion                                 to explain causalities so if I know                                 something about an event I must seen all                                 the events that is registered neck with                                 it if I don't know if me and another                                 entity if we don't know each other                                 Easter e then we are congruent and if                                 our in stories are the same we are the                                 same so let's put these into the social                                 interaction that we had there and here                                 we are no longer we are doing two things                                 we are assigning the events and we are                                 collecting the set of events and now we                                 can use this information to see what is                                 happening in the graph so if we look at                                 the first reception of a message in                                 oadby we are receiving the message a                                     the set of events are coming with a                                 message we receive it when we were at                                 the site B                                                               we do is that we merge the two sets and                                 after merging the two sets we know our                                 past but since we have to register                                 receive event then we need to create a                                 new tag to be to tag and union that so                                 this is what's happening in in this flow                                 over here so i hope that everyone is                                 getting this this interaction here we                                 are just collecting sets of things and                                 comparing sets of things and this is                                 where we do the causalities checking so                                 we just see for set inclusion so if we                                 have set inclusion then we have an event                                 that                                 was a predecessor of another event but                                 we still well checking set inclusion                                 dragon I'm going to show you a little                                 trick is a more or less complex                                 operation because you have to compare                                 the two sets so we can do a little trick                                 if we take note of the last event that                                 this thing is getting out of position                                 okay it's okay so if we keep track of                                 the last event that we have over there                                 we can do it much more simpler we simply                                 see if the last event is present in them                                 in the same okay and this will give us                                 the the same information because if we                                 have the last event we must have all the                                 other events that come with it it should                                 be better now okay okay so basically                                 what we we did is that we use this                                 property that which we have the last                                 event then we must have all the other                                 events so we don't have to test the                                 whole set and these are these there is                                 another property over here is that if we                                 have a given event in the history side                                 if we have C                                                          means that we need to have c                                            actually these histories here have a lot                                 of redundancy and this is why these                                 things are not used in in practice so                                 how can we do better than this well we                                 can use vector clocks which were the                                 structures that I as shown in the                                 wikipedia entry so actually plugs were                                 created concurrently in                                            research by fitch and matter and they                                 are used in many subsystems nowadays for                                 instance to do group communication to                                 take a snapshot of a system there are                                 really basic building blocks so how do                                 we get from Castle histories to vector                                 clocks hoping that you got intuition                                 into causal histories so we have all                                 these events over there and we are going                                 just to take note of the last event from                                 each location so from location a we are                                 only interested                                 on the number two on location beyond                                 number three and on location see also on                                 number three so we have this map from                                 location to a natural counter and we                                 could use this is actually what is used                                 if the system is dynamic and we have                                 many places that are not necessarily                                 consecutive but if we can if you have                                 the the lack of having places that are                                 consecutive just like a B and C then we                                 can simply put this thing into a vector                                 we just making place it the location                                 names so this is what the vector clock                                 looks like so it's only a compression of                                 a causal history so now if we put this                                 thing back into the grid diagram we have                                 this interaction here and I'm going to                                 to show how we can read the interaction                                 so when we are receiving a message again                                 this is the recipient ought not be what                                 we are receiving is a vector                                            need to merge it with a vector that we                                 had                                                                     maximum for each of the coordinates and                                 the result of that is what we are going                                 to use to increment the counter                                 associated to not be so we do an                                 increment on be in the end and we get                                 the end result which is                                                the basic mechanics to do the causality                                 check before we did checking of                                 inclusion between causal histories now                                 what we do is we need to point wise core                                 coordinate wise check if each coordinate                                 as the corresponding value in the other                                 coordinate is greater or equal than it                                 so i have assigned it some calls to make                                 it easier so we basically to check these                                 two we need to check to with                                           and                                                                      the cases then there is a causality link                                 between the two so can we make it faster                                 that trick so this trick is not very                                 well known so this is a new thing more                                 or less we can again do it do the trick                                 that we did before with the last event                                 but this time we need to put it in bold                                 over there that to win both means that                                 that was the last event from replica a                                 and we just need to test                                 if it is known on the unload beam so                                 it's not very easy to call old stuff and                                 arrows in a programming language so we                                 need another way to encode this thing so                                 we can do this little trick where                                     will now be decoupled we can decouple                                 the last event and store it outside so                                 now what we have is the causal past of                                 it folks over event I to now we have the                                 castle part of it which is                                          compressed and we store the event itself                                 outside and we call that thing a dot and                                 we do the same thing over there for that                                 vector so we could do these things for                                 each vector as long as we do it when we                                 are producing it and now I'll do a check                                 well we just go there we pick the dot                                 and we see if the dot is known on the                                 other vector or the index is not only                                 the corresponding position in the other                                 vector so what was a linear operation in                                 the in the number of elements in the                                 vector now it's a probably constant time                                 operation so up till now we have been                                 registering all the events that are                                 occurring okay so we are registering                                 internal events send events receive                                 events etc but for some systems it's not                                 important to track all the events so we                                 might be interested in very practical                                 systems we are typically interested in                                 only tracking events that changed item                                 so vector clocks can be used for for                                 instance for causal causal the ordered                                 message dissemination but we are going                                 to track only some events in order to                                 get into another notion which is a                                 version vector and in this case went                                 rested on on on change events so these                                 are applications in file system                                 databases and version control and I                                 think that probably everyone knows about                                 this motivating example so in the in the                                 dynamo Piper that describes that the                                 amazon shopping cart system what they                                 are doing is that they are tracking the                                 events that change the shopping basket                                 that is being managed so every every                                 time given user is or                                 boxee doing operations on his behalf are                                 doing operations to the to the shopping                                 cart the what is written is target with                                 a with a vector so we are taking keeping                                 track of all the right operations but we                                 are not worrying about sending messages                                 etc so what does it look like so to                                 understand it we need to get back into                                 the castle history so now we have this                                 distinction between the events we are                                 interested in which we are marking with                                 a dot and we put a dot because those are                                 the events where we need to put a unique                                 tag and the other events that are that                                 we don't need tracking so poor that one                                 those ones we use an empty just an empty                                 circle so in that case in this case here                                 we have to write events one at node a                                 and another at node B but then when we                                 send a message at that point we are just                                 propagating information so what are we                                 talking about you we could be talking                                 about a document and share it editing so                                 these kind of things need to be using in                                 things plus other technology in things                                 lines such as Google Docs so we can be                                 editing a document and note a is writing                                 a given line and note B is writing an                                 alternative line another line and when                                 we propagate information we need to                                 merge these into a single document so we                                 need to realize that these things are                                 concurrent and this is really easy to                                 realize because one is not included in                                 the other and neither happens vice versa                                 so they are concurrent and when you                                 receive concurrent things we typically                                 need to ask the user for reconciliation                                 okay so this is what happens in a                                 version control system when you have a                                 marsh conflict we ask the users to do                                 something and since the user is is doing                                 something the the decision or what we                                 write back needs to be tagged it with                                 with a new event because two different                                 users can do different reconciliation                                 decisions so we need to tie that so this                                 is what happens over there in that case                                 we had concurrency and we also the last                                 interaction over there is just that we                                 are sending information to a note see                                 that was in an empty side states or with                                 a blank page                                 in that case it's very easy to see that                                 this information at no be over rights                                 the information on node C so we can                                 simply overwrite over there after doing                                 the test so when we do the causality                                 test here we can either there is                                 congruence and we need user intervention                                 or some copies outdated and we simply                                 overwrite it we can do another trick                                 that actually happens in some databases                                 and that is again think about the vinyl                                 case this also happens in the react                                 database sometimes we we don't want to                                 do the reconciliation when we are                                 handling the rights because it may take                                 some time and we want to give a fast                                 response to the right so we might want                                 to have two copies at the database when                                 we have congruent white and this is what                                 happens here we we will have two copies                                 of the state one is characterized by                                 this causal v                                                     alternative one note that as the other                                 alternative line is by causal beetle and                                 we can defer so we have two siblings                                 over there two states and we can refer                                 differ the reconciliation of the states                                 to let advice for instance these things                                 sometimes I've done at the ridge ways in                                 such as in react and at that point we                                 typically have to register a new event                                 to mark the reconciliation and the rest                                 of the run is just the same thing so                                 that was intuition with causal histories                                 can we do the same thing in a compact                                 way yes we can we can do it with the                                 version vectors that interestingly they                                 were invented before vector clocks so                                 this is a paper from                                                     visionary Piper so I recommend everyone                                 to read it even regarding things like                                 gap etc so this is the the run when we                                 look with version vectors as you see we                                 only increment values when we have those                                 bullets there                                 and we are just passing out information                                 in the system so in the end we have a                                                                                                          just overwrite information over there so                                 I think this one should be clear by now                                 giving done in the previous slides and                                 sorry I'm missing one slide here okay we                                 can also do the same trick in the guise                                 of motion vectors we if we store the                                 last version outside so I'm coming to                                 the end of the of the talk in the last                                                                                                        mechanisms being developed some of them                                 are useful some of them are not so                                 useful there are libraries for some of                                 them but all of them can be translated                                 into this simple notion of a causal                                 history where you have the events that                                 you are interested so basically                                 causality is important because time as                                 limitations so it might look that the                                 fact that you are ordering everything is                                 the the best scenario but actually by                                 ordering everything you are losing                                 information so you actually have more                                 information if you store the partial                                 order the causal relationships then if                                 you try to order everything because what                                 is happening now in Australia is not                                 influencing what we are doing here the                                 other thing is that to track causality                                 we need to memorize event and up the                                 memorized events under the simplest way                                 is just to collect sets of events so                                 that was the basic building mechanism                                 however these things although they are                                 very simple in coatings of causality and                                 they give you all the information that                                 you need they are very they are highly                                 inefficient so we cannot use typically                                 caused all these trees in practice                                 unless we were dealing with the system                                 where very very few events are those                                 that are of interest so if we have                                 enough events we cannot use those things                                 in products practice so we need to use                                 particle mechanisms                                 and these practical mechanisms include                                 vector clocks version vectors dotted                                 version vectors and what they are doing                                 is simply doing an efficient encoding of                                 causal mysteries they are not adding                                 extra stuff they are just efficient                                 encoding so most of the causal                                 mechanisms are like that and when we                                 look at the rules for comparing vector                                 clocks what we are seeing is that just                                 the set inclusion being mapped into the                                 representation that the given mechanism                                 is using nothing more than that so by                                 take away the photo on this talk is that                                 when you are faced with a with a needs                                 either to design a new mechanism or to                                 understand what kind of causality                                 tracking you need to use in your system                                 you should try to think out that thing                                 tracks back to a simple causal history I                                 understand the problem in terms of                                 causal histories and anything else is                                 just a coding strategy so most of the                                 content here for those interested is                                 also in an article that came in ACM cute                                 is this one is freely available there's                                 also a version that came in                                 communications of ACM in April about                                 this so you can follow through on this                                 information and these are my contacts                                 okay so thank you I'm open for for                                 questions                                 any question thanks a lot okay oh                                 there's a question wait time for lunch                                 since there aren't any other questions                                 right now this one is more philosophical                                 but during the talk which I found very                                 interesting I found it hard to get my                                 head around you using the word causality                                 and maybe you can share an intuition                                 about that to me it seems like saying                                 your entire history is the cause of                                 what's happening now is not informative                                 enough in a way so how do you pick the                                 things that are really the cause okay so                                 so you are you are right so we are                                 actually talking about something more                                 precise with cheese potential causality                                 so not necessarily causality so you are                                 potentially influenced by everything                                 that happened before you and that you                                 are aware of so this is the the baseline                                 of what you can do but we know that we                                 are not influenced by everything that                                 happening in our lives we are just                                 influenced by the events that we                                 memorize that happen before us so                                 actually in some systems you can try to                                 restrict the events that that you                                 register as potential causes to what we                                 are doing there's a paper called bolt on                                 cause a consistency that that explores a                                 little bit of this okay but in the end                                 if you can encode all this information                                 just in a version vector that is                                 something that has interesting                                 scalability properties if you don't have                                 lots of notes then that might not really                                 be a problem but otherwise you are                                 correct so if you can have more semantic                                 information in your system that tells                                 you exactly which events you need to                                 track you you can do better you can even                                 track less events and we that have more                                 information because you are only                                 considering the relevant event to what                                 you are doing                                 could you please make some practical                                 examples of this because well for me                                 this sounds really interesting but I am                                 striving to imagine how how these can be                                 applied well in my day to day                                 engineering job okay so I'm going to use                                 an example that I don't more or less                                 which is from the right database so from                                 bio so they do kind of an implementation                                 of dynamo with something so most things                                 in common some variations so it is a no                                 sequel database with a get put interface                                 and they want to be always available and                                 they don't they want they typically in                                 the mode that I'm concerned with data                                 onto coordination so users can go and                                 fetch an object to a get then do some                                 change to the object and then put                                 something back so what happens if                                   users get the same object and do                                 concurrent changes you have two options                                 well we have more more than two options                                 but you can use something like last                                 fighter wins where a user puts puts the                                 information there and when the second                                 user comes it will overwrite information                                 but this is actually not correct because                                 the update that wasn't by the first user                                 is as important as the updated that was                                 done by the second one it just got                                 unlucky with the timing so databases                                 that use last I to win when these things                                 occur they are losing information and                                 this information can be important so                                 what they do mean in react is that when                                 these things happen they start to                                 siblings so they recognize the fact that                                 that was a concurrent interaction with                                 the system so you have two copies of the                                 data and they need to somehow know that                                 they are siblings and they can use                                 version vectors for that and now they                                 are using a more complex thing which are                                 is dotted version vectors to track that                                 because of scalability concerns and what                                 you have when we have two siblings now                                 the next user that is going to read the                                 database will get these two copies and                                 the application layer has a chance to do                                 the reconciliation of the cop                                 and then right back so these things can                                 be used in this context to don't lose                                 any update and twin the reconciliation                                 at application level can be hard but you                                 can also use another technology that I'm                                 working with which is a conflict-free                                 replication replicated data type square                                 you can try to remove the burden of the                                 reconciliation from the application and                                 just use libraries that know how to                                 reconcile set reconcile sequences                                 counters etc so this is one of the                                 practical uses off of these kind of                                 techniques oh thank thanks a lot
YouTube URL: https://www.youtube.com/watch?v=paHhOD5zI0w


