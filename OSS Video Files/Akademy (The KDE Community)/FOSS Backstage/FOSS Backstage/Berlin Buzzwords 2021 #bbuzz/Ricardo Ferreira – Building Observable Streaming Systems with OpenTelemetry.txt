Title: Ricardo Ferreira – Building Observable Streaming Systems with OpenTelemetry
Publication date: 2021-06-25
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	Building streaming systems is a popular way for developers to implement applications that react to data changes and process events as they happen. It is an exciting new world that technologies like Apache Pulsar made available for anyone to use. But all this goodness doesn’t come for free. One of the challenges of this type of architecture is that its distributed nature makes it hard and sometimes even impossible to identify the root cause of problems quickly.  

That is why distributed tracing technologies are so important. By gluing together disparate services into a single and cohesive transaction, developers can provide to the operations team a way to pragmatically observe the system and to quickly identify the root cause of problems such as slowness and unavailability. This talk will explain how to implement distributed tracing in Pulsar applications using OpenTelemetry—an observability framework for cloud-native software. A demo will be used to clarify the concepts.

Speaker:
Ricardo Ferreira – https://2021.berlinbuzzwords.de/member/ricardo-ferreira

More: https://2021.berlinbuzzwords.de/session/building-observable-streaming-systems-opentelemetry
Captions: 
	                              thanks everybody that is                               with us today and i'm looking forward                               that everybody is enjoying this                               amazing conference which is berlin                               buzzwords um                               i'm pretty sure that uh there are a lot                               of content that                               uh this year the conference is providing                               for the t attendees and                                the objective here is always to not only                                to provide but also to share                                ideas so um feel free to                                after this presentation to uh reach out                                and i'm more than available for                                answering any questions you might have                                regarding the subject or                                anything that has to do with technology                                right                                so for those of you that don't know me                                uh my name is oh                                for those of you that don't know me my                                name is ricardo ferreira and uh i'm                                working as a developer advocate in this                                company that pretty sure that you might                                have heard of                                which is elastic right so in elastic i'm                                part of the community                                and um for elastic i used to work for                                other software vendors as well such as                                confluent                                oracle and red hat and uh if you want to                                reach out                                to discuss anything like i mentioned                                before uh                                you can send me an email i brought here                                my both my                                email from elastic and my personal one                                and if you happen to use twitter                                i'm also on twitter available so feel                                free to reach out and i will be                                on the conversation right next the uh                                the presentation                                as well right so uh                                if you read the description of the                                session                                right uh the main purpose of this                                presentation is to                                show you how can you use first of all                                open telemetry apis to                                stitch together services that somehow                                communicate                                using apache pulsar or i would say                                we're going to use apache pusher as an                                example here but                                what i'm going to show here today cannot                                can be applied for anything right so                                and when i was thinking about how i'm                                going to actually deliver this                                presentation i thought all right                                i'm going to talk about apis but it                                makes no sense                                to use slides to explain apis right                                because apis these the building block                                the developer used to build applications                                so                                why not show an application for them                                right so                                and this is what i've basically done                                here so what i'm gonna do today                                i brought this um let's call                                minimalistic                                application right where i'm going to                                um okay                                i'm going to explain what i'm going to                                do step by step right so the application                                right now is up and running                                i'm going to give you an overview about                                what the application does but                                essentially tldr                                it is a simple api right that i've                                constructed using                                java and spring boot right and the                                purpose of this api is to provide                                estimates                                so for example you want to estimate how                                much is the cost of a                                given car brand such as a nissan or                                toyota or a ferrari right                                and then what this api does is to query                                those like skull estimates into                                a database which is employment using                                radis right so                                typical microservice that you would see                                everywhere                                right um and uh                                what we what we are going to do here                                today is to make                                this application that is currently not                                only accessing reddit but also is                                 publishing a message into apache pulsar                                 right so the first step we're going to                                 do is to make this                                 let's call transaction lag observable                                 right so everybody in the upside that is                                 currently monitoring this whole                                 transaction can see this operation                                 because currently                                 this is not being shown right i'm going                                 to show what is the current state of the                                 architecture                                 as well as any downstream consumers that                                 are                                 pulling messages out of pulsar this one                                 specifically i have written in using go                                 right                                 so that microservice over there pulls                                 messages from pulsar                                 to do some analytics like counting the                                 number of times                                 uh an estimate was given to toyota for                                 example                                 right a very simple estimate but the                                 focus is more like                                 not how to do it but what is the                                 plumbing that is behind it                                 but the key thing here is that this                                 whole interaction over here the                                 publishing part as well as the                                 consumption part                                 is not being shown right and you might                                 be asking about right                                 why not being shown here and everything                                 else it is being shown because                                 uh the open telemetry framework in sdk                                 and setup apis allows you to expose                                 pretty much                                 everything that you currently have in                                 your applications right                                 but there are some gotchas right for                                 example uh if you're dealing with uh                                 in this case over here if you are                                 dealing with something that is                                 inherently synchronous like a                                 spring boot or microservices reading in                                 any programming language you are dealing                                 with a protocol called http which is                                 synchronous right so                                 you can kind of auto magically                                 instrument design                                 this api but the same doesn't happen if                                 you are using                                 non-blocking asynchronous technologies                                 such as for example apache pulsar and                                 that could apply for anything that                                 happens to have to behave the same way                                 like you name it uh wrapped mq activemq                                 apache kafka or                                 any other messaging technology where all                                 the                                 transactions spread over multiple                                 threads right                                 uh there's not a single thread that                                 provides the continuation of the                                 transaction so                                 we got to come up with the strategies                                 using open telemetry to                                 make sure although it doesn't behave                                 like this                                 but it looks like it is the same                                 transaction and this is what we are                                 going to do here today                                 right so um let me start sharing like i                                 mentioned before um                                 it's not a very good idea to explain                                 apis using slides so                                 probably this is going to be the only                                 set of slides that you're going to see                                 here today                                 um let me show the current state of what                                 i have here                                 all right so i'm gonna pull here my                                 postman                                 which is the ui that i used to send some                                 requests to this api that i've got                                 here right so you can see how it works                                 um but first of all let me                                 ask you this what if if i increase the                                 font size to                                 this is everybody able to see my screen                                 you can actually                                 put this on a chat so i can see                                 um maybe max not sure if you're                                 following me there but                                 can you see that this font size over                                 here is good for everybody to see what's                                 going on                                 i'm gonna while you are answering this                                 i'm gonna issue a request here                                 and oh the microservice is not running                                 so that's good                                 can i i got a connection refusal here                                 which means that the microservice is not                                 currently running which is good                                 so this is the proof that it is                                 everything alive                                 right okay so what i'm gonna do is to                                 start up my micro services right so i                                 have two scripts here                                 one of them is uh let me increase the                                 font size over here                                 this is the spring boot application that                                 i mentioned before so basically i'm                                 going to force a maven build in this                                 microservice application and here's the                                 interesting part                                 i'm going to download from the open                                 telemeter project the java agent right                                 so if you're a java developer and you                                 want to instrument automatically all                                 your microservices                                 applications all you got to do is to use                                 this java agent along with your                                 application right                                 obviously you have to provide how your                                 let's call telemetry data is going to be                                 sent to the backend system so                                 this is what i'm doing here i am                                 exporting these variables                                 and this endpoint over here is pointing                                 to my elastic apm                                 which is my observability platform that                                 i'm going to use here today for                                 demonstration purposes right so with                                 that said                                 i'm going to start my uh                                 brand estimator right and                                 meanwhile i'm going to actually start as                                 well my                                 analytics layer which as i mentioned                                 before is a go application so this is a                                 script                                 let me show you again so since this is                                 written in go                                 basically what i'm doing is exporting                                 some environment variables and then i'm                                 running                                 the single go file over here right which                                 is going to generate                                 a native application and probably in the                                 temporary folder if i remember correctly                                 and then it's going to be executed right                                 so both of them                                 now are executed now let's issue                                 one more time the request to make an                                 estimate for this app so i'm going to                                 click send right                                 and now since the microservice is up and                                 running you can send here this is the                                 brand and this is the price so                                 right as expected right and if you look                                 to the analytics leader there's a cow                                 here for the brand nissan so                                 the whole architecture is the end-to-end                                 architecture is                                 working but here's the problem here is                                 the gotcha                                 right if we look to the observability                                 platform                                 right now right and this is the                                 observability platform which is the                                 elastic atm if we go to                                 the apm tab and i'm going to increase a                                 little bit                                 this inside so everybody can see it                                 right so you're going to see that here                                 on the apm there is this microservice                                 called brand estimator                                 that if we look to the service map                                 you're going to see that oh                                 all the interactions that the                                 microservices does has been                                 automatically discovered so yeah                                 the microservice is written in java and                                 access radis database                                 but more importantly if we click on this                                 microservice                                 you're going to see that there are some                                 transactions right                                 that has been executed in the last i                                 think this is                                                          check yep                                 actually let me decrease this for the                                 last five minutes so we can have a more                                 focused uh observability right                                 and then in the last five minutes we've                                 had                                 this invocation right here that if we                                 scroll down                                 we're gonna see that this is the                                 breakdown of the transaction                                 everything that you were looking here                                 right it was automatically discovered by                                 that                                 agent that we've downloaded from the                                 open telemetry that's the beauty if                                 you're a java developer that's the                                 beauty of                                 building applications in java that are                                 automatically instrument because                                 in the java world open telemetry provide                                 this agent so                                 it discovered for example that this is a                                 spring boot application it discovered                                 they interacted with the radius database                                 as you can see here                                 over here so everything was discovered                                 automatic except                                 for this invocation to this method                                 called                                 feed analytics that i actually                                 create i actually made this happen uh                                 let me show you the code here of the                                 controller so let me so                                 this is the endpoint that's invoked when                                 you call the api and                                 if let me increase the phone signs over                                 here one more time                                 and if we see here we're gonna see that                                 as i                                 fulfill that request i'm actually call                                 this method called feed analytics which                                 in turn                                 basically sends a message to pusar right                                 however                                 how i made this available in the                                 observability platform because i've used                                 this annotation called                                 act with spam so this is how why this                                 feed analytics annotation here ended up                                 being shown here on the observable                                 platform but what matters is that                                 as you can see here the where is the                                 part where                                 the application is sending a message to                                 pulsar it's not being shown                                 and that's the problem right this is                                 what we are going to fix right now                                 because                                 we we have to make this interaction that                                 is fundamentally part of the transaction                                 right                                 it's part of the architecture we have to                                 make this interaction                                 observable visible to the operators so                                 let's see                                 how we can actually fix this right so                                 what we're going to do                                 right i'm going to show here the what i                                 call in the                                 spring boot world right the pulsar                                 configuration right the pulsar                                 configuration                                 is the beam that is being used for                                 instantiate the producer that                                 is going to be injected and all the                                 other beans on my spring boot                                 application that can                                 interact with pulsars so specifically i                                 am creating here and the spools are                                 client right so this is a beam                                 right and then from that client i'm                                 creating a producer right and as you can                                 see here                                 this producer is uh using json as schema                                 right and basically it's connecting to                                 this topic called estimates                                 and then i'm creating but uh if you are                                 working with pulsar and you want to                                 bring instrumentation                                 and open telemetry to the pulsar                                 applications the best thing you can do                                 is actually use interceptors so                                 i'm going to uncomment this right so                                 this is a java class that i've already                                 created it's empty right now we're gonna                                 fill                                 uh together but if you create an                                 interceptor                                 in uh from pulsar right you can simply                                 as you create your producer and                                 consumers                                 you can simply call the method dot                                 intercept and then provide an instance                                 of your intercept it's that simple right                                 so now that we've seen                                 how we can hook up into the our producer                                 and consumers                                 let's check into this interceptor right                                 now so an interceptor as you can see                                 here is essentially a class that                                 implements producer interceptor oh                                 right very simple and then there are                                 pretty much                                 four methods that you have callback                                 methods that you have to implement like                                 the one that checks if the uh                                 instrumentation                                 applies or not to a given message in our                                 case it's gonna be always true right                                 the actual instrumentation that's gonna                                 happen before the message is sent                                 to pulsar and if you wanna hook up some                                 specifically                                 uh like all right i'm gonna do something                                 in their exact moment that i receive an                                 acknowledgement from pulsar so i can use                                 this callback over here and if i spin up                                 resources in my java class                                 i can use the callback close to you know                                 close those resources right                                 so uh the first thing we got to do here                                 is um let me open up                                 my                                 kit here first thing we got to do is to                                 come up with a tracer right so i'm going                                 to put here a tracer                                 right so let me show here one more time                                 uh                                 why we are so easily being able to                                 create a tracer here using the open                                 telemetry sdk because                                 again you are instrumenting using the                                 agent so the agent behind scenes is                                 kind of a making the tracer available                                 for you automatically all you got to do                                 is to retrieve it right and you give a                                 unique name for it so that's what we are                                 doing here right and then as i mentioned                                 before we have to                                 feel the before send um method so                                 this method we are going to use                                 this approach over here right i'm gonna                                 before returning the message to the                                 caller                                 we are going to do this let me show you                                 here                                 how this implementation works oops                                 i think if you do this you are going to                                 be able to see so pretty much what we                                 are doing here is right                                 we are creating a spam here's the tracer                                 for the tracer you create a span right                                 so for those of you that know open                                 telemetry this is how the api works                                 and then there are some annotations that                                 you can use to specify if this is a                                 producer                                 a consumer or things like that and then                                 everything in the open telemetry order                                 is                                 boils down into the concept of context                                 right you have to                                 be aware that everything you do you have                                 to put it back into a context or you                                 have to extract from the context                                 right so because the context is the                                 entity that is propagated over all the                                 layers and services of your architecture                                 right                                 so you have to build up a context right                                 and here we are retrieving the current                                 context                                 context sorry and then we are                                 inserting this new span that we've                                 created over here and then we are                                 decorating this                                 span with some labels or annotations                                 that uh just to make it                                 like a visible for the operating                                 operators to better understand what's                                 going on behind the scenes right                                 and then like i mentioned before                                 everything is about the context so you                                 have to come up with a way to                                 give him the message from pulsar right                                 put that context into the message                                 because think about it                                 right uh how a producer fundamentally                                 communicates with a consumer right                                 uh it's not about it's not with the                                 broker the message                                 acts as we call as the carrier because                                 it's going to                                 carry the context from one point to                                 another right so                                 what we need to do here is to store                                 this context into the message which is                                 going to be                                 act as our carrier so that's why i                                 created this method called                                 store context on message so what we're                                 going to do here                                 i'm going to save it and then let me                                 explain the code                                 so pretty much what we are doing here                                 the message is the carrier right so                                 here's the context here's the carrier                                 i have to provide a way using the open                                 telemetry sdk                                 to set that information right because                                 again uh you can use this approach here                                 this technique that i'm showing you for                                 pretty much virtually any technology so                                 you have to come up with your                                 implementation in our case here                                 to a seller that knows                                 how to put data into a                                 message and message is the building                                 block from pulsar but                                 if we're dealing with uh let's say                                 records for an apache kafka                                 that would be the same approach and                                 that's the beauty of what i'm showing                                 here today because you can use the same                                 approach over here                                 to come up with any strategy right for                                 any technology that is asynchronous and                                 non-blocking                                 so pretty much what i'm doing here is to                                 come up with this callback                                 implementation called                                 set that teaches how to set the message                                 sorry the context into the message right                                 with that change in place right                                 i'm going to pause my microservice one                                 more time                                 and i'm going to simply execute it again                                 so                                 because we've made some changes right we                                 with let's recap we created the                                 interceptor                                 and then we curl the interceptor to                                 create a span                                 decorate the span and put the span into                                 a context and save this context into the                                 message so now                                 the message has been carrying this                                 context over                                 the poster broker and whenever any                                 consumers downstream speaks up that                                 message                                 guess what they're going to be able to                                 continue the transaction                                 so that's the magic that we're going to                                 build here so the microsoft is up and                                 running                                 good so what we are going to do here                                 right now                                 is come up with a new invocation let's                                 change the the brand right now                                 um instead of nissan let's                                 i don't know let's make an estimate for                                 a ferrari for example so yeah ferrari is                                 a little bit more expensive than a                                 nissan so                                 but the estimate has been given good a                                 new transaction has been executed                                 now let's see in our observability                                 platform right                                 uh that's too big yeah                                 let's see in our observability platform                                 in the last five minutes what's going on                                 so yep we have a new transaction that                                 happens                                 so let's see what's the difference in                                 this new version of the transaction                                 if we look at here right now you're                                 gonna see yeah everything else that was                                 being shown before                                 is being shown here again however and                                 that's the trick                                 here it here is the we call in the open                                 telemetry work we call this a span                                 right there is a new span a child span                                 that happened on behalf of this method                                 over here field analytics                                 right there was the trigger for that                                 span if we click here on that new                                 span and check the metadata this is the                                 decoration or the information that we've                                 put                                 into the message right which is pretty                                 cool right                                 um okay um i'm gonna see here that the                                 zoom is a little slow so                                 i'm gonna zoom up a little bit more                                 right sorry thanks for the heads up                                 and uh so as you can see here we have                                 everything ready for                                 the decoration so let's do the                                 consumption part right now                                 because again the microservices that                                 actually pull the message out of pulsar                                 is written and go so we have to do                                 provide the same process and go                                 so we can see everything up and running                                 right so let's do this right now                                 so the first thing i'm going to do is                                 actually to pause my microservice and go                                 right so we're done with the java part                                 let's now check                                 the analytics and go the code here                                 is pretty much done the only thing we                                 have to do                                 is create a tracer so in the go ward                                 it it looks like almost the same with a                                 few differences so                                 first you have to come up with a tracer                                 so this is part one                                 and then you have to uh fundamentally                                 create a span that is going to                                 where's the span here we go                                 yep we have to come up with a span                                 that's going to                                 demark that part of the transaction so                                 after we consume the message we are                                 going to                                 let me zoom up again so after we consume                                 the message from pulsar we're going to                                 create a span                                 right so but here's the interesting part                                 first of all we have to                                 use that span so right after we                                 acknowledge the consumption of the                                 message                                 we can simply receive the span dot                                 end right so right now we are the                                 marking the end of the transaction                                 good but more importantly we have to                                 come up with a way just like we had to                                 come up with a way to                                 put the context into the message now                                 have to extract it                                 right so uh how we are going to extract                                 this                                 in the goal word so we have this some                                 functionalities in the go api that                                 allows us to do this so                                 i'm going to show you right here let me                                 zoom in and then i can continue                                 so if you call this package open                                 telemetry and get the text map                                 propagator and call the function shrek                                 you can provide your current context and                                 then                                 just like we build a remember that in                                 java word we created a                                 setter right now we have to come up with                                 a gather                                 right an implementation of a callback                                 that teaches the open telemetry sdk                                 how to get data from the carrier and                                 this                                 in this case the carrier is the actual                                 message so                                 let's see the implementation of this                                 getter right so um let me copy here                                 i'm going to put here right in the end                                 of my                                 code and let me zoom up one more time so                                 you can see it                                 right so what is a care what is a gather                                 and go right so basically i create a                                 stretch right here                                 that takes a message as a parameter and                                 a constructor                                 and then those are the callbacks that                                 i've created from that                                 strict right so there's three of them                                 that have to implement right                                 uh you don't have to provide                                 implementation for all of them but uh                                 at least in our case years the key is                                 fundamental right so it you have to                                 teach how to                                 retrieve given a key how to retrieve the                                 message from the key                                 and also the set and also the keys right                                 so now that we have                                 right now that we have our goal link                                 working as expected                                 let's execute our analytics layer                                 one more time because we've made the                                 changes right uh                                 we are we have probably about six                                 minutes to the end so it's we're on time                                 which is good um                                 okay all right good good good good                                 and let's make another invocation                                 to the microservice right it can be a                                 ferrari no problem                                 i'm going to call an estimate for a                                 ferrari one more time                                 it works as expected right because it                                 should                                 presumably but now let's take a look on                                 the observability platform and see                                 what's what's different this time right                                 so let's refresh                                 to see the transaction so the here's the                                 new transaction that happened in the                                 last five minutes                                 after the chains in both the java and go                                 length work microservice                                 and now if we look this transaction that                                 was for the ferrari the whole                                 transaction took                                                                                                         can see that                                 voila right now by the time the                                 feed analytics method executes on the                                 java microserver side                                 it sends the message to pulsar and then                                 uh i'm terrible in math but probably                                 like a less than                                                        microsecond microseconds after                                 the consumer which is written and going                                 post a message from pulsar                                 and continues the transaction and as you                                 can see here                                 all of this both the producer and the                                 consumer                                 happens on the context                                 of the microservice and this is the                                 beauty of you making the                                 the whole transaction now observable                                 because an operator                                 thinks mike an operator can now see that                                 okay now it makes sense right now now i                                 can see the whole transaction and then i                                 can see that                                 by the time i call the feed analytics                                 and the java microservice                                 it sends a message to pulsar what's                                 topic so the operator can click here and                                 see the topic which is the topic                                 estimates right and then you can also                                 see that oh                                 there's a consumer here that receives                                 from the estimate and if you click here                                 on metadata                                 it's going to say oh this is a topic                                 this is from pulsar and this is a topic                                 called the estimate right                                 uh we could also decorate with a bunch                                 of more information but                                 i choose to be a little minimalist here                                 right uh                                 so before we continue let me do this                                 right i'm going to provide to my dear                                 friend mike here that's helped me on the                                 backstage                                 a url of my of the github repository                                 that has the whole code already                                 implemented for you                                 all you got to do is to clone the apple                                 docker compose up yeah you have to start                                 docker sorry about that but                                 you have to docker compose up and then                                 everything we all been running so you                                 can study the code                                 with more like uh because here i'm i'm                                 doing things a little bit fast because                                 we are time constrained                                 right but you can study the code right                                 and mikey                                 if you could or uh provide this link for                                 the uh my friends that are                                 are watching this session please and                                 then                                 before we actually finish right since                                 we've                                 we have probably three minutes left i                                 would like to show you something really                                 really interesting uh okay                                 which is there is something that you can                                 also do with open telemetry and                                 i'm gonna do this on the microservice                                 written in                                 bo which is matrix pretty awesome so                                 what i'm gonna do is to                                 use the api for an open telemetry to                                 actually come up with metric                                 so i'm going to create pretty quick here                                 because we are                                 almost running out of time uh                                 where are my tracer here first after the                                 tracer you have to come up with a metric                                 and then you have to use the metric                                 i'm gonna copy the code and then i'll                                 explain later                                 all right let me put it here the code                                 first and then                                 we can simply see the code so yeah let                                 me zoom in and then show you what i've                                 done here                                 so just like you create a mat you create                                 a tracer you can also create a meter                                 and then from the meter you create how                                 many metrics you wanted so here i'm                                 creating a counter                                 that is an integer right and the name of                                 this counter is custom.metric.brand.com                                 right and then what i'm doing here in                                 the code is                                 after i actually consume the message i                                 am                                 adding a plus one into that counter                                 right so pretty much that's what i'm                                 doing here on this code                                 it's in the code that is on the github                                 so                                 uh i'm going to execute this                                 microservice one more time so and we're                                 gonna i'm gonna execute the                                 estimate call probably three times so we                                 can see the counter going on                                 um here is where my postman here we go                                 so here on pulse man i'm going to call                                 this api                                 one two three times right                                 so presumably if everything is working                                 i have to have a new metric on my                                 observability platform                                 with a given name that the current count                                 is three                                 right so let's check if this is true                                 right                                 uh all right so let me jump into my                                 discover on kibana                                 and um let me just minimize                                 a tiny bit of the ui so i can see                                 everything so yeah i have a                                 let me filter to see all the documents                                 so i have three documents over here let                                 me show an example of this document that                                 is currently                                 indexed on elasticsearch so as you can                                 see here                                 the current count is three and then i                                 have a ferrari brand                                 right and since we have everything here                                 up and running                                 right we can do things like this in                                 kibana let me show real quick                                 because we are probably running out of                                 time ricardo                                 so there's a still called lens that we                                 can use it let me create real quick here                                 on cabana                                 so i'm not here i'm going to use a time                                 stamp                                 in uh one minute thank you thanks                                 and then i'm going to create calculate                                 the maximum                                 of that and then i'm going to                                 group by group by where's the group by                                 group by by the name of the brand right                                 so here we go                                 i have a ferrari which is currently                                 count is three                                 so that's the proof that now we can have                                 stateful counters using the open                                 telemetry api so                                 we have to wrap it up i'm sorry for                                 rushing things up i don't like to do                                 this to be honest but                                 i have to be respectful both with the                                 conferences my dear                                 friend max that's helping me on the                                 backstage and the other speakers that                                 are probably waiting for this conference                                 for the session to be done so thank you                                 very much                                 you
YouTube URL: https://www.youtube.com/watch?v=XpEQTqaawyk


