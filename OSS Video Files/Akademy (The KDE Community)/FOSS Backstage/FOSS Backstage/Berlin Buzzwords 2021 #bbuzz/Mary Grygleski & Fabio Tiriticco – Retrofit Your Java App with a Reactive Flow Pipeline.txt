Title: Mary Grygleski & Fabio Tiriticco – Retrofit Your Java App with a Reactive Flow Pipeline
Publication date: 2021-06-25
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	This presentation will be a lively discussion with hands-on coding to illustrate how to construct a reactive, event-driven data flow pipeline. We will use multiple library implementations of the Reactive Streams specification, such as Akka Streams, Eclipse Vert.x and RxJava. The sample use case will mimic a real-life example of data being collected from multiple distributed sources, which will then be fed to a legacy processor as «wrapped» by a reactive microservice. The resulting data will flow to a «sink» to be prepared for further processing. We will highlight the strength of the Reactive Streams in controlling backpressure during processing.

Speaker:
Mary Grygleski – https://2021.berlinbuzzwords.de/member/mary-grygleski
Fabio Tiriticco – https://2021.berlinbuzzwords.de/member/fabio-tiriticco

More: https://2021.berlinbuzzwords.de/session/retrofit-your-java-app-reactive-flow-pipeline
Captions: 
	                              hello                               welcome to our talk uh talked                               today by myself mary grogleski and fabio                               teretico                               today is an interesting emerging topic                               presentation                               called retrofit your legacy java app                               with a reactive flow pipeline we'll take                               a look at how                                reactive can be applied to transforming                                an old traditional legacy java app                                and this is our agenda for today we'll                                have a quick introduction                                and then we'll go into talking a bit to                                about                                a bit of history as kind of give setting                                up the stage as to                                why we have this talk discussing from                                the                                perspective from an enterprise                                jvm applications point of view and then                                we also explore into a bit of the                                complex                                problems in today's world that's                                evolving                                that's becoming more and more                                complicated needing more and more data                                everything is just come in bulk we have                                so much to sort through                                so what would be a good approach is                                that what we're proposing here which is                                the fourth section is about                                some solutions that we can be using                                using uh and it's basically leveraging                                on the reactive                                approach and then fabio will then take                                us into an in-depth                                uh look into an experiment that we have                                done                                and mostly merits to                                fabio who spent a significant amount of                                time working through some of the                                inner things and so that will be                                fabio area he will spend more time with                                you on that                                and then after that we will come                                together and give                                a conclusion to this whole experiment                                um on the reactive java ex                                kind of experience that we have so all                                right so let's begin                                a quick introduction i'll just give my                                since i'm talking let me                                introduce myself i'm mary grigoleski                                that's my twitter handle                                and i'm a senior developer advocate at                                ibm                                in the java open source and cloud space                                i'm also by night president of the                                chicago java users group as well                                as well as a few other user groups um                                in the chicago area so now um                                to you fabio yes uh hi everybody                                um and thanks for having us um my name                                is fabio tiritiko                                and twitter handle is stikofab it's a                                lot easier to pronounce than my                                family name and i am based in amsterdam                                where i work as a software engineer now                                currently actually in an                                engineering manager position and i am                                the founder of this community reactive                                amsterdam                                um so yes the topics of today's talk                                are really really dear to my heart                                thank you man so with that without                                further ado                                i'm going to start so why right and i                                i've been speaking at a lot of                                conferences and so                                has uh fabio with a deeper experience                                in reactive too and i'm sure you know                                fabio too                                like myself we've constantly been asked                                by our audience as to                                well how can reactive be of use                                in today's world so one aspect that we                                have been                                exploring into is really uh looking into                                enterprise jvm applications these are                                applications that are                                powering the the world's you know                                huge um uh kind of back-end                                applications uh in production in big                                financial                                places in insurance company in                                um manufacturing places and you name it                                that they are                                there so they their mission is                                 actually very important uh for the                                 company                                 they do a lot of things on for example                                 very typical ones it's like                                 e-commerce systems that essentially you                                 have you                                 have customers trying to shop for                                 something catalog                                 and then uh then you order to order                                 as we all know it's not a simple thing                                 and uh                                 and then of course with this order and                                 with today's world we are not just                                 paying by cash                                 and we are also doing credit card or now                                 um even more like you know                                 kind of uh what cashless uh payment or                                 what cardless payment i'm sorry and so                                 all these                                 things they are very complicated and                                 require a lot of security                                 and all these things and as you can see                                 is this is really complicated                                 and but the traditional way of doing                                 things is that before                                 um hardware it's been able to get caught                                 up                                 um when we're having single cpu or                                 having like parallel processing of                                 multiple cpus but essentially                                 kind of you know like a single thread                                 handling                                 per cpu type of scenario                                 applications were developed in a very                                 monolithic fashion                                 so everything too we could be processing                                 is all in the same jvm                                 if it's taking java and they are all                                 like                                 doing things within the jvm um let's say                                 order entry                                 and if you have an order you need to                                 talk to                                 send your order over to your credit card                                 verify                                 audio transaction they will actually                                 essentially hold up a thread and you                                 just like have to sit there and wait                                 and that type of it's just an example of                                 some of these monolithic                                 applications in their runtime the the                                 effect of how it                                 affects the whole system is just not                                 designed to be very                                 scalable not very flexible at all                                 and not only that you know on the the                                 design side                                 um we run into that problem in runtime                                 but the thing is too is that we also                                 rely                                 on a huge operation teams to help us                                 too with the building part not not only                                 building                                 in the testing phase too we will be like                                 having                                 um you know a different uh                                 development version of your                                 code or have your qa running a separate                                 version and then you have certifying all                                 that before you go into production                                 then so overall too the maintenance of                                 such application is                                 is very high and it's also not very                                 flexible                                 it almost seems like the world must stop                                 if you need to upgrade any part of your                                 system and that's                                 kind of like the whole kind of issue                                 with it                                 and of course too the data aspect too                                 you know it's kind of like                                 um hard for it to be                                 kind of like go through different states                                 uh without being                                 easily able to get updated the state                                 changes between these                                 these different parts so such and so                                 let's go on                                 and of course too not to mention uh the                                 fact is that uh                                 there's also the concurrency aspect of                                 processing that                                 that present itself a lot of challenges                                 so those are kind of like some of the                                 traditional enterprise                                 applications uh that that uh we can kind                                 of think of using                                 a reactive approach to solve                                 then we talk about the solutions uh that                                 that                                 that uh we're proposing is to use this                                 reactive approach                                 is that um in today's world and of                                 course                                 its microservices have has already been                                 uh popular and                                 you know since i'd say in the                                            of time frame                                 and so those are solutions of uh using                                 this reactive approach                                 and actually microservices itself too is                                 is kind of perfect for um                                 letting the reactive or be adopted by                                 the reactive                                 way they kind of both are kind of work                                 together very well                                 a reactive system itself is by nature uh                                 not tightly coupled to um so                                 microservices is like a perfect kind of                                 architectural                                 uh approach that reactive systems can                                 use                                 oh actually i should also add two is a                                 also the                                 serverless aspect too it deals with the                                 deployment part two and and                                 in the serverless cloud native world too                                 it's also very suited for this reactive                                 approach um                                 and uh and of course too uh with                                 microservices everything kind of broken                                 out and not                                 no longer like you know all together                                 then you can essentially uh                                 do your upgrading without one part can                                 be down while                                 other parts are still running so that                                 kind of uh is is very                                 very uh conducive uh for the reactive                                 approach and of course too                                 there's also the traditional operations                                 part is no longer                                 you know the the case we're kind of                                 using modern uh devops and                                 infrastructure                                 to uh for the deployment building                                 continuous integration                                 and deployment part um                                 and now too if you think of uh reactive                                  it's basically enable                                 uh concurrency without us the developer                                 still having to worry about the                                 mechanics of                                 threading concern because all the                                 threadings are now being handled by the                                 libraries                                 by the reactive framework or libraries                                 or toolkits                                 so that developers can then focus on                                 actually the business                                 operational side now the thing is with                                 you using reactive approach is basically                                 we're proposing                                 is to build and transform some                                 legacy applications where identify                                 identifying parts of it and allowing the                                 data to be flowing through different                                 pipelines                                 and that's the area that                                 fabio will be demonstrating for us is to                                 uh a case in which we're building using                                 different implementation of a reactive                                 pipeline and different implementation                                 different reactive libraries to                                 implement this pipeline                                 and uh so yeah so i will pass the baton                                 over to                                 fabio to talk about this                                 particular use case yes                                 uh thank you very much uh mary                                 what we are going to look at is this                                 this hypothetical situation where um                                 we're talking about some data pipeline                                 and there's going to be some processing                                 happening the first                                 legacy processor will                                 read consume data from the first kafka                                 topic                                 and then the second processor will do                                 some additional processing on it                                 after it has received the output of the                                 first processor                                 and finally the second kafka topic will                                 be where                                 our process data will end up and what's                                 important                                 is in this entire pipeline                                 we are using concepts coming from                                 the reactive strings idea where                                 you know reactive streams is a standard                                 that has been part of the jdk                                 since jdk                                             and and one of the most important                                 uh consequences and benefits of this of                                 using this this standard                                 is uh is is back pressure so                                 what we'll see is that uh the the entire                                 process only                                 does actual something if there is demand                                 from downstream so in this concrete                                 example                                 let's say if the legacy processor number                                 two                                 doesn't have enough capacity to process                                 all the potential incoming data                                 uh the the first processor legacy                                 processor number one                                 will be reacting to this situation                                 by simply stop sending data and                                 are waiting for legacy processor to be                                 ready to process more                                 more information and this is crucial in                                 large systems where many many pieces                                 interact with one another                                 as uh you know fast producers might                                 well you know uh boggle down                                 uh slow consumers and so in order to                                 avoid                                 this sort of overflowing situation                                 uh we have these pipelines that employ                                 uh back pressure all the way up to the                                 source                                 of the data and now let's                                 go look at some code and some demo                                 uh here we are you should be seeing my                                 screen now and                                 uh what you are seeing now is in fact                                 the github repository with the code for                                 the demo that you're about to see                                 and as you can see there is uh these                                 two legacy processor one and legacy                                 processor two                                 are our uh projects um                                 and then there's two other folders one                                 is about infra                                 it's a simple docker compose file that                                 will spin up our                                 you know kafka infrastructure and                                 sources producer                                 is a project that will simply uh                                 put some some random data on kafka so                                 the first legacy processor has something                                 to consume now let's see this in action                                 um here we are uh there's                                 our infra directory                                 let's pin up our infrastructure                                 this is going to start our entire                                 kafka backend                                 yeah there it is now we have a run kafka                                 cluster on my                                 local machine and so let me start the                                 sources provider which will start                                 push data into our                                 kafka topic this is going to be just                                 let's see there it is one record per                                 second containing just                                 that specific timestamp as you can see                                 and                                 this guy is just going to keep producing                                 as                                 as we go so                                 let's uh first look a little bit                                 at the code before we started                                 what you are seeing now on screen is                                 a the first the implementation the                                 actual starting point                                 of the first legacy processor                                 it's in scala and it uses                                 a reactive stream implementation called                                 akka strips                                 aka streams is based on akka                                 a product from lightbend an open source                                 product from lightman                                 and the idea of aka streams is                                 uh to that implements in the the                                 reactive stream specification                                 so um there are a lot of different                                 connectors that we can use                                 in part of akka strings in particular                                 here we are going to use the connector                                 that allows us to connect                                 to a kafka topic and consume events from                                 it                                 at the see this this this little snippet                                 here                                 this is the entire thing the whole thing                                 that we                                 really need to look at what this                                 processor is going to do is going to                                 okay after instantiating some                                 configuration setting like                                 which topic we are going to submit to to                                 listen to                                 here we are creating our stream which                                 starts                                 considering our kafka topic as a source                                 of items and then for each item that                                 comes in                                 we are first simulating some processing                                 in this case we are just extracting the                                 string value                                 and then a little uh a little                                 step here to ex convert the string into                                 bytes                                 and then we are going to put this data                                 into i                                 into a r socket sync now                                 a little introduction to our socket is                                 necessary here                                 our socket is a protocol                                 alternative to http so                                 at the same level in you know it's an                                 application level protocol                                 um basically built                                 with the reactive stream concepts in                                 mind                                 so there are solutions that uh                                 leverage the reactive streams idea into                                 http                                 making it a back pressure enabled                                 transmission of data across services but                                 our socket is born with it                                 and this is this is all you need to know                                 uh really for now but our socket is                                 really in uh                                 an interesting uh project in fact our                                 socket stems from                                 reactive socket that that that's what it                                 was called in the beginning                                 and um you know it's it's above tcp                                 so it really it makes a good candidate                                 for two                                 into inter communication between two                                 services                                 and in this case uh this legacy                                 processor one what we have done                                 is let's say this process item function                                 method here represents a                                 legacy                                 type of processing maybe we are dealing                                 with                                 indeed some legacy logic that we have                                 and we don't want to change them all we                                 want to do is                                 wrap it inside a stream                                 and then the data that comes out of it                                 we are going to offer to this                                 r socket sync it's uh                                 uh we are going to look at the                                 implementation of this                                 a little bit later if we look for a                                 second                                 at the second legacy processor which                                 you are seeing on my screen um                                 this is a java application which again                                 um it                                 will create a kafka producer                                 in this case because the output is                                 producing data onto a                                 second kafka topic and then this                                 code that you see here is about                                 let's say this block here                                 is about creating a r socket receiver                                 so once the first legacy processor finds                                 a valid connection to the to the                                 receiver                                 it will start pushing data through                                 and what happens with the data that we                                 receive                                 is is right here is this bit                                 um for each item that we receive from                                 the                                 first legacy processor we are going to                                 extract                                 its string content and                                 simulate some work this is again                                 simulation of some legacy processing                                 logic this processing actually is maybe                                 a little interesting                                 to look at it's just down here                                 it will basically make our machine                                 and our thread slipped for a random                                 number of seconds                                 we'll see uh later why are random                                 and and after we are done processing                                 we are going to publish the data                                 onto a second kafka topic                                 what's interesting oops what's                                 interesting to notice here                                 is that when only                                 at the moment when we return                                 from this method once the execution of                                 this logic highlighted now as completed                                 this is going to be the signal                                 to the first legacy processor that we                                 are ready                                 to receive more data and this                                 syntax here flux dot empty                                 you are probably familiar with it if you                                 have used the                                 project reactor or                                 spring boot spring boot esque                                 applications you are probably familiar                                 with this logic                                 um and and this is all i want to say for                                 the moment about this legacy processor                                 um let's try and give these                                 two guys a spin in this window here so                                 let me first                                 start let me just check that                                 yes our our sources producer is                                 still producing data on kafka so let's                                 spin up our                                 first legacy processor                                 now this processor has started                                 and it's trying to connect to a r socket                                 receiver but at the moment there's none                                 running                                 so what's interesting already to notice                                 is that because there is no                                 server running then this entire stream                                 is not consuming anything because this                                 particular component                                 is not asking for anything to consume so                                 by going all the way back to the source                                 we are not consuming anything from kafka                                 this consumption will start when we                                 trigger the second                                 legacy processor what we                                 should see if the demo gods help us                                 is that this the first                                 legacy processor will connect to the                                 listener                                 and start consuming events from kafka                                 there it is                                 so here what you could see is                                 the when an item is received on the                                 second processor                                 then there is this random delay so you                                 see two seconds                                 uh three seconds and                                 the first processor is only reading                                 messages from kafka                                 as there is availability from the second                                 processor                                 and so you see that they really go hand                                 in hand                                 the entire thing is is                                 protected in this sense we are only                                 consuming data when there is                                 some need for it                                 um and i just want to                                 this this concludes our demo i just want                                 to spend one more minute                                 for those of you familiar with the akka                                 streams is an incredibly powerful                                 ecosystem incredibly rich there are                                 kafka connectors http connectors or                                 connectors um to connect to basically                                 most                                 of your uh potential technology                                 underneath                                 in a reactive way but interestingly                                 enough                                 there isn't an official connector for                                 our socket                                 so what i have done um i have                                 created these two r socket sync and                                 sources                                 um get an inspiration there is a blog                                 post                                 actually on the liteman website which i                                 used as a                                 inspiration and and then built on top of                                 that                                 this code you see here is a are is the                                 our socket sync that we are using                                 and the idea is um                                 this is the uh area where we create                                 the uh the connection to the                                 our socket receiver and then                                 um what i want you to look at                                 is basically two things                                 this method here that we have                                 overwritten                                 on push lets us                                 write the logic of when we should                                 retrieve items                                 from the stream and when we should                                 get then the next one                                 so in this case this grub                                 is a is the signal to grab                                 an item from upstream                                 and then only                                 uh so we are grabbing some payload here                                 here this is the line where we are                                 sending the payload                                 further and then only when there is a                                 request                                 we are asking for                                 a new item that will be triggered from                                 above um                                 and the the code is online so you can                                 look at it                                 um this is all for our little demo                                 and now i would like to share with you a                                 couple of                                 conclusions about this experience from                                 building these pipelines so the good                                 things and the bad things i found                                 well first of all i have some experience                                 with reactive streams                                 already but if you haven't been exposed                                 to them to this kind of                                 standard it really is incredible it it                                 enables you to work with different                                 technologies                                 uh not only on the jbm you could                                 have a reactive stream uh implementation                                 in python                                 for instance why not and and and still                                 keep this streaming semantics                                 of back pressure all the way through the                                 pipeline                                 but something that is not great is that                                 different                                 implementations as you can see are not                                 yet very easy to get to work together                                 in the same process our socket is a                                 great technology                                 but unfortunately documentation is very                                 limited                                 i asked some things online and i got                                 help                                 from the helpful contributors uh                                 but mostly pointing to the examples                                 online which are                                 certainly useful but then again limited                                 and you have to do a lot of work to                                 figure things out as you go                                 um i use i also didn't like very much                                 that the java implementation relies on                                 project reactor                                 um because uh you might simply not want                                 that                                 you might want to use a different                                 implementation and                                 if you are in the spring sort of world                                 this is perfect it is absolutely perfect                                 for you it will                                 just mix seamlessly with spring boot in                                 fact there's                                 books written about it but if you don't                                 particularly like project reactor you're                                 still stuck with it                                 so it's you know just a dependency                                 in fact my conclusion is that in fact                                 while not built for this streaming                                 purpose                                 if you mix http with the                                 with some underlying streaming semantics                                 and there are some projects that have                                 done that like http                                 well this solution might be a more                                 efficient                                 and faster way for you to modernize your                                 legacy application                                 and um this is                                 uh all for me and maybe we can                                 have some share some conclusion together                                 with mary at this point                                 sure yeah thank you fabio it's a great                                 uh demo and and very clearly                                 explains thank you so yeah and um                                 yeah we're kind of looking at this whole                                 pipeline and we're wondering yeah this                                 is like a                                 sample uh implementation                                 could we actually have uh other                                 implementations i think as you mentioned                                 about right we could actually write                                 maybe the legacy processor too could be                                 like in python                                 in even javascript maybe node.js for                                 sure                                 please so i think it basically we're                                 trying to illustrate this set with the                                 reactive streams uh                                 kind of approach it's it's actually uh                                 make your application a lot more uh                                 module so to speak like modularize uh if                                 you're writing microservices you can                                 actually have the legacy processor as                                 one microservice                                 and the other legacy processor is                                 another one and so you can see that they                                 all connect                                 with each other through messaging and in                                 this case we                                 as fabio has illustrated will be in our                                 socket                                 and you can plug different things in                                 plug-and-play so it                                 it's actually a very flexible approach                                 and that's what we                                 also like about our reactive and it's                                 because of that capability that kind of                                 enables us to do things                                 more efficiently too indeed yeah yeah                                 exactly so yeah yeah and then also maybe                                 one                                 last kind of conclusion is that well how                                 about like project loom                                 that's kind of scheduled now for java                                    i believe and                                 that's right there's still a couple more                                 versions before                                 it will be released but we wonder right                                 with virtual                                 threads uh carrier threads too right and                                 we wonder how you know how it would be                                 and there i've also like heard about                                 people talking about oh                                 project looms coming out reactive is                                 gonna be dead and                                 but i really i don't think so right i                                 mean how can                                 i mean reactive so to speak we're                                 handling                                 uh the problem domain on a different                                 level on a more abstract                                 level but uh the virtual threads are a                                 bit more of the                                 lower level dealing with more of the uh                                 towards more of the primitive                                 kind of more threading kind of um                                 that that direction so then it's more                                 like they                                 they both should be complementing each                                 other is what i'm doing exactly                                 i fully agree i think um project loom                                 is definitely going to be a very very                                 powerful uh                                 addition to the jbm um in my personal uh                                 opinion i think is going to be very                                 useful for                                 low-level uh logic so maybe if you are a                                 library maintainer                                 or uh well maybe if you're the                                 maintainer of one of these reactive                                 library                                 yourself this is going to be really                                 really useful                                 but for a lot of users you know simple                                 simple users of these libraries                                 i think we will still prefer to                                 operate at a higher level than you know                                 going back to uh                                 creating and speeding up threads                                 ourselves even if they're virtual                                 we'll see we'll see how it plays out                                 but yeah certainly something to                                 definitely keep keep an eye on                                 yeah very true yeah wonderful yeah it's                                 been a great uh                                 conversation too in our presentation                                 hope everybody enjoys it and                                 uh yeah these are a couple of links to                                 lots of things we've mentioned the first                                 one is                                 the sample code that i've shown you                                 our socket quarkus docker lots of                                 technologies that we mentioned                                 and i believe this is uh offer from us                                 so                                 thank you very much these are our uh                                 contacts and our and our links that's                                 right                                 yeah thank you all for attending our                                 talk                                 thank you mary and fabio uh there's                                 there's a question                                 um how are errors managed between                                 the r socket producer and receiver uh                                 acknowledgement for instance                                 um what's happening if do some                                 processing fails and                                 flux.empty is not reached in the second                                 legacy system                                 yeah so um hi everybody i hope you can                                 see me and hear me                                 uh no problem thanks for attending our                                 talk                                 um and yes very good question what                                 happens there                                 um i think um if if you hang that thing                                 forever                                 uh because of some reason and that flux                                 that empty line is never triggered and                                 the entire chain will simply hang                                 forever                                 so it is really up to you to make sure                                 that eventually                                 you have a time out or uh your your                                 resilient in that sense                                 um i would imagine that if the                                 if the entire process crashes um                                 then the the other side uh                                 wouldn't get a reply to that so probably                                 there needs to be some time at that                                 time out there as well but yeah this is                                 i think                                 it's really about your business logic                                 you
YouTube URL: https://www.youtube.com/watch?v=KRIJ0LXFnDA


