Title: The Many Shades of reference_wrapper - Zhihao Yuan - CppCon 2020
Publication date: 2020-09-27
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/the_many_shades_of_reference_wrapper/the_many_shades_of_reference_wrapper__zhihao_yuan__cppcon_2020.pdf
---
You may have heard of std::reference_wrapper's role in make_tuple, but this is not today's topic. The role that reference_wrapper plays is larger than unwrapping references in C++ standard library API. It is the language's response to the need for references with rebinding semantics, which may explain why such a small utility is still receiving love and polishes in C++20.
To put it in the other way, every reference in Python is rebindable -- with garbage collection, of course. But the semantics in common implies that reference_wrapper may be very useful. This talk will go through these use cases, see how reference_wrapper's design carefully enables them through details. The talk will also compare reference_wrapper with other facilities in the language and the standard library to give you hints about how to choose from the reference-like types.

---
Zhihao Yuan is an HPC Engineer at SimpleRose Inc. He participated in standardizing designated initializers and improved narrowing conversions in C++20. After giving a talk on CppCon to advocate NOT to program any macros, he dived into a project where the number of identifiers that are macros exceeds the number of identifiers that are not. His favorite game series on PS4 is Utawarerumono.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,320 --> 00:00:15,599
hello everyone

00:00:11,519 --> 00:00:19,199
welcome to the talk um i am drew

00:00:15,599 --> 00:00:21,680
an hpc engineer from simple resiliency

00:00:19,199 --> 00:00:22,800
simpleroc is a startup that produces

00:00:21,680 --> 00:00:26,000
linear programming and

00:00:22,800 --> 00:00:27,840
mixed integer programming servers

00:00:26,000 --> 00:00:29,519
but we won't be talking about matrices

00:00:27,840 --> 00:00:33,120
this time today's topic

00:00:29,519 --> 00:00:34,320
is about a less known utility in a

00:00:33,120 --> 00:00:38,160
standard library

00:00:34,320 --> 00:00:39,600
called reference wrapper so

00:00:38,160 --> 00:00:42,840
let's start with thinking about this

00:00:39,600 --> 00:00:44,719
question how would you switch between

00:00:42,840 --> 00:00:48,160
objects

00:00:44,719 --> 00:00:49,840
if you're using python because in python

00:00:48,160 --> 00:00:52,800
every variable is just some

00:00:49,840 --> 00:00:53,199
reference that points to the object by

00:00:52,800 --> 00:00:55,600
saying

00:00:53,199 --> 00:00:56,399
switch between objects you can just

00:00:55,600 --> 00:01:01,120
assign

00:00:56,399 --> 00:01:01,120
different objects to the same variable

00:01:01,199 --> 00:01:07,760
can we do the same thing with c plus

00:01:03,520 --> 00:01:07,760
plus using c plus plus references

00:01:08,960 --> 00:01:14,080
seems not because to suppress first

00:01:12,159 --> 00:01:18,320
reference

00:01:14,080 --> 00:01:22,640
once it is bound to an object

00:01:18,320 --> 00:01:22,640
it cannot bind to a different object

00:01:22,960 --> 00:01:27,280
cipher flux reference can only be bound

00:01:25,040 --> 00:01:30,400
once

00:01:27,280 --> 00:01:32,880
this does not mean however you cannot

00:01:30,400 --> 00:01:36,079
conditionally bind different objects

00:01:32,880 --> 00:01:37,600
to a surplus reference if your control

00:01:36,079 --> 00:01:39,439
flow allows you can do something like

00:01:37,600 --> 00:01:41,439
this

00:01:39,439 --> 00:01:43,680
but in the most general case we need

00:01:41,439 --> 00:01:47,680
some other thoughts

00:01:43,680 --> 00:01:51,439
so you know reference

00:01:47,680 --> 00:01:53,759
is just a pointer with different syntax

00:01:51,439 --> 00:01:56,240
roughly pretty much everything reference

00:01:53,759 --> 00:01:59,439
can do can be done with pointers

00:01:56,240 --> 00:02:03,040
so why don't we try

00:01:59,439 --> 00:02:05,759
pointers it works

00:02:03,040 --> 00:02:07,200
gives you the rise matrix but hey it's

00:02:05,759 --> 00:02:10,080
more than c plus plus

00:02:07,200 --> 00:02:12,479
no more draw pointers let's make it

00:02:10,080 --> 00:02:12,479
smart

00:02:12,480 --> 00:02:19,840
then we ended up with this i saw that

00:02:16,560 --> 00:02:21,760
in song production code

00:02:19,840 --> 00:02:23,440
i can't say that it doesn't work he

00:02:21,760 --> 00:02:26,480
works and it's modern

00:02:23,440 --> 00:02:26,480
but you know

00:02:28,080 --> 00:02:31,760
so let's look back a little bit

00:02:32,400 --> 00:02:38,879
when talking about reference assignments

00:02:35,120 --> 00:02:38,879
what what do we really mean

00:02:38,959 --> 00:02:43,360
in python every time you see an

00:02:41,760 --> 00:02:46,560
assignment operator

00:02:43,360 --> 00:02:50,319
it binds some project some object

00:02:46,560 --> 00:02:52,400
to the variable but the thing

00:02:50,319 --> 00:02:55,200
is getting a little bit inconsistent in

00:02:52,400 --> 00:02:55,200
c plus first

00:02:55,280 --> 00:02:59,440
to a separate path reference

00:02:58,239 --> 00:03:02,640
initialization

00:02:59,440 --> 00:03:05,440
binds the object to the reference

00:03:02,640 --> 00:03:06,959
but assignment assigns to the bounded

00:03:05,440 --> 00:03:11,280
object

00:03:06,959 --> 00:03:11,280
this behavior is called assign through

00:03:11,440 --> 00:03:18,640
now think about this what if we have

00:03:15,480 --> 00:03:21,519
initialization and assignment both

00:03:18,640 --> 00:03:21,519
binding object

00:03:21,680 --> 00:03:26,239
so initialization binds the object to

00:03:24,080 --> 00:03:28,879
the reference

00:03:26,239 --> 00:03:32,159
and assignment rebinds a different

00:03:28,879 --> 00:03:35,200
object to reference

00:03:32,159 --> 00:03:38,159
just like python for java without

00:03:35,200 --> 00:03:41,760
garbage collection of course

00:03:38,159 --> 00:03:45,519
with this semantics we offer

00:03:41,760 --> 00:03:48,319
student reference wrapper if we rewrite

00:03:45,519 --> 00:03:50,879
the previous previous example

00:03:48,319 --> 00:03:51,760
that didn't work by replacing the

00:03:50,879 --> 00:03:55,200
autograph

00:03:51,760 --> 00:04:00,000
with reference wrapper the example works

00:03:55,200 --> 00:04:02,720
and has a right semantics

00:04:00,000 --> 00:04:05,280
so reference wrapper models refinable

00:04:02,720 --> 00:04:05,280
references

00:04:07,840 --> 00:04:12,959
however it is a standard library utility

00:04:11,439 --> 00:04:15,920
it's not something built into the

00:04:12,959 --> 00:04:19,680
language but

00:04:15,920 --> 00:04:21,600
we put lots of thoughts in making it

00:04:19,680 --> 00:04:24,800
closely matches language air value

00:04:21,600 --> 00:04:24,800
references semantics

00:04:25,680 --> 00:04:31,680
sorry behavior for example

00:04:29,360 --> 00:04:34,160
reference wrapper may refer to const

00:04:31,680 --> 00:04:34,160
objects

00:04:34,320 --> 00:04:38,720
and it does not bind to r-value

00:04:36,160 --> 00:04:38,720
expressions

00:04:39,199 --> 00:04:44,080
declaring a reference wrapper t does not

00:04:41,600 --> 00:04:46,240
order ust

00:04:44,080 --> 00:04:47,600
this essentially means that t may be an

00:04:46,240 --> 00:04:51,199
incomplete type

00:04:47,600 --> 00:04:51,199
but i will explain this more later

00:04:51,440 --> 00:04:55,040
let's start with the first bullet

00:04:55,520 --> 00:04:58,800
so in order to produce a reference

00:04:57,919 --> 00:05:03,120
wrapper that

00:04:58,800 --> 00:05:05,360
refers to some const qualified air value

00:05:03,120 --> 00:05:07,199
we can rely on class template argument

00:05:05,360 --> 00:05:10,639
deduction

00:05:07,199 --> 00:05:12,720
in this example if you

00:05:10,639 --> 00:05:13,840
initialize the reference wrapper from a

00:05:12,720 --> 00:05:16,400
constant value

00:05:13,840 --> 00:05:17,520
the type of the reference wrapper is

00:05:16,400 --> 00:05:21,039
deduced to

00:05:17,520 --> 00:05:21,039
reference wrapper in the const

00:05:21,680 --> 00:05:26,479
now if the expression to initialize

00:05:24,240 --> 00:05:27,039
reference wrapper is not a const value

00:05:26,479 --> 00:05:30,639
value

00:05:27,039 --> 00:05:33,440
what what if it is non-const

00:05:30,639 --> 00:05:34,240
well we can turn it into a constant one

00:05:33,440 --> 00:05:38,160
by using

00:05:34,240 --> 00:05:42,639
student's const this mod

00:05:38,160 --> 00:05:42,639
utility is introduced in c plus 20.

00:05:43,759 --> 00:05:47,039
next bullet reference wrapper only binds

00:05:46,720 --> 00:05:51,120
to

00:05:47,039 --> 00:05:53,919
error value so

00:05:51,120 --> 00:05:54,960
if you recall what does the user define

00:05:53,919 --> 00:05:59,120
literal operator

00:05:54,960 --> 00:06:00,800
s does it creates a temporary object of

00:05:59,120 --> 00:06:03,600
stood string

00:06:00,800 --> 00:06:05,600
which is a pr value because reference

00:06:03,600 --> 00:06:08,160
wrapper only binds to air value this

00:06:05,600 --> 00:06:09,919
doesn't compile

00:06:08,160 --> 00:06:13,120
the language value reference doesn't

00:06:09,919 --> 00:06:13,120
compile in this case either

00:06:14,080 --> 00:06:17,440
how about reference wrapper t const that

00:06:16,960 --> 00:06:20,800
that

00:06:17,440 --> 00:06:23,520
binds to r values

00:06:20,800 --> 00:06:26,400
no because otherwise you'll be getting a

00:06:23,520 --> 00:06:26,400
dangling reference

00:06:26,639 --> 00:06:31,680
but this time its behavior slightly

00:06:29,120 --> 00:06:34,639
diverges from

00:06:31,680 --> 00:06:35,680
what language air value reference has

00:06:34,639 --> 00:06:37,840
because to language

00:06:35,680 --> 00:06:39,199
value references there is something

00:06:37,840 --> 00:06:42,240
called lifetime

00:06:39,199 --> 00:06:45,680
extension this is introduced

00:06:42,240 --> 00:06:48,319
before we have in r value references

00:06:45,680 --> 00:06:49,840
so from some point of view is trickier

00:06:48,319 --> 00:06:51,360
than necessary

00:06:49,840 --> 00:06:53,840
reference wrapper didn't copy this

00:06:51,360 --> 00:06:53,840
behavior

00:06:55,039 --> 00:07:00,080
reference weapon may refer to an

00:06:57,199 --> 00:07:00,080
incomplete type

00:07:00,319 --> 00:07:04,000
so when we're talking about incomplete

00:07:01,919 --> 00:07:07,280
type we mean something like this

00:07:04,000 --> 00:07:10,319
a user-defined type that only has a

00:07:07,280 --> 00:07:12,960
declaration whereas definition is hidden

00:07:10,319 --> 00:07:16,720
in some other translation units

00:07:12,960 --> 00:07:19,199
but given this a user will be able to

00:07:16,720 --> 00:07:20,639
form a language value reference to the

00:07:19,199 --> 00:07:24,160
type

00:07:20,639 --> 00:07:27,759
and use that in a parameter list

00:07:24,160 --> 00:07:29,520
when declaring a function

00:07:27,759 --> 00:07:32,639
you can do the same thing with reference

00:07:29,520 --> 00:07:32,639
wrapper as well

00:07:33,280 --> 00:07:40,240
this guarantee is provided

00:07:36,639 --> 00:07:42,400
in c plus plus 20 but as far as i know

00:07:40,240 --> 00:07:43,759
all standard library implementations

00:07:42,400 --> 00:07:46,800
guarantees these thing's

00:07:43,759 --> 00:07:46,800
surprise for 17.

00:07:49,520 --> 00:07:58,639
reference wrapper is not only rebindable

00:07:54,000 --> 00:08:02,560
it is also it also does assign through

00:07:58,639 --> 00:08:06,160
so if we bring back the previous example

00:08:02,560 --> 00:08:09,360
you'll notice that this line compiles

00:08:06,160 --> 00:08:14,400
while we are changing autograph to

00:08:09,360 --> 00:08:16,960
reference wrapper this is because

00:08:14,400 --> 00:08:18,879
reference vapor t is convertible to t

00:08:16,960 --> 00:08:21,599
ref

00:08:18,879 --> 00:08:22,400
this conversion can give you direct

00:08:21,599 --> 00:08:26,879
access

00:08:22,400 --> 00:08:28,720
to the bounded object

00:08:26,879 --> 00:08:31,919
but you don't have to rely on this

00:08:28,720 --> 00:08:34,080
conversion to get that access

00:08:31,919 --> 00:08:35,120
you can also reach the boundary object

00:08:34,080 --> 00:08:40,320
using the dot

00:08:35,120 --> 00:08:44,000
get number function right here

00:08:40,320 --> 00:08:47,040
with this we are able to

00:08:44,000 --> 00:08:50,480
combine re-binding and assign through

00:08:47,040 --> 00:08:52,160
in the same program when you want to

00:08:50,480 --> 00:08:55,279
refine that object

00:08:52,160 --> 00:08:56,160
to a reference wrapper you use reference

00:08:55,279 --> 00:08:59,839
wrappers or

00:08:56,160 --> 00:09:01,200
assignment operator if you want to

00:08:59,839 --> 00:09:04,240
assign

00:09:01,200 --> 00:09:05,279
to the bounded object you can use the

00:09:04,240 --> 00:09:07,760
dot get member

00:09:05,279 --> 00:09:10,560
function to reach the bounded object and

00:09:07,760 --> 00:09:13,519
use that object's own

00:09:10,560 --> 00:09:13,519
assignment operator

00:09:13,920 --> 00:09:17,440
so what's the use of this

00:09:17,519 --> 00:09:24,080
let's talk about linked list here's a

00:09:20,720 --> 00:09:27,519
very simple link list where it's node

00:09:24,080 --> 00:09:30,720
it just has a next pointer and

00:09:27,519 --> 00:09:31,440
a string value and the main body of the

00:09:30,720 --> 00:09:34,320
linked list

00:09:31,440 --> 00:09:36,320
is consists of a head pointer that

00:09:34,320 --> 00:09:39,440
points to the first node

00:09:36,320 --> 00:09:41,680
the question here is how do we implement

00:09:39,440 --> 00:09:44,399
a remove function

00:09:41,680 --> 00:09:45,040
notice that the remove function here

00:09:44,399 --> 00:09:48,320
should

00:09:45,040 --> 00:09:50,320
remove every node where its

00:09:48,320 --> 00:09:51,519
string value compares equal to the

00:09:50,320 --> 00:09:55,600
string passed to

00:09:51,519 --> 00:09:55,600
into the remove sound function

00:09:57,680 --> 00:10:06,320
before we jump into these algorithms

00:10:00,720 --> 00:10:09,920
i want to introduce a tiny little trick

00:10:06,320 --> 00:10:12,640
so um we need to drop

00:10:09,920 --> 00:10:15,519
nodes from linked list which means we

00:10:12,640 --> 00:10:15,519
will need to delete

00:10:16,399 --> 00:10:23,440
but assuming that a node is created

00:10:20,079 --> 00:10:23,440
using the new operator

00:10:24,320 --> 00:10:28,399
but the delete operator also destructs

00:10:26,800 --> 00:10:32,079
the node

00:10:28,399 --> 00:10:33,920
which means

00:10:32,079 --> 00:10:35,760
after the destructor being called you

00:10:33,920 --> 00:10:39,279
can no longer reach the next

00:10:35,760 --> 00:10:41,760
member of a destructive object

00:10:39,279 --> 00:10:42,880
through a pointer that used to point to

00:10:41,760 --> 00:10:46,640
it

00:10:42,880 --> 00:10:50,240
so this code doesn't work

00:10:46,640 --> 00:10:54,240
what works this works

00:10:50,240 --> 00:10:57,440
we can save the pointer skip the node

00:10:54,240 --> 00:11:01,200
and then delete the current node

00:10:57,440 --> 00:11:04,880
using the saved pointer

00:11:01,200 --> 00:11:07,600
with the help of stan library utilities

00:11:04,880 --> 00:11:08,560
we can replace these three lines with

00:11:07,600 --> 00:11:13,360
just

00:11:08,560 --> 00:11:17,200
one line stood exchange

00:11:13,360 --> 00:11:22,240
what it does is that it is essentially

00:11:17,200 --> 00:11:22,240
similar to a assignment but

00:11:22,640 --> 00:11:27,040
after he assigns the right hand side to

00:11:25,760 --> 00:11:30,240
the left hand side

00:11:27,040 --> 00:11:33,600
it returns the previous value of the

00:11:30,240 --> 00:11:37,519
left hand side which allows us to call

00:11:33,600 --> 00:11:37,519
delete operator on it

00:11:37,920 --> 00:11:42,079
this small utility is introduced in c

00:11:40,720 --> 00:11:45,040
plus plus 14.

00:11:42,079 --> 00:11:45,040
i hope you enjoy it

00:11:45,760 --> 00:11:53,200
so now let's talk about some algorithms

00:11:49,760 --> 00:11:53,200
okay it's a very simple one

00:11:53,279 --> 00:12:01,120
we need to drop nodes we can do so

00:11:57,279 --> 00:12:04,399
by changing the previous nodes

00:12:01,120 --> 00:12:09,279
next member so

00:12:04,399 --> 00:12:12,399
in the loop we keep our current node

00:12:09,279 --> 00:12:13,440
starting with starting with latin it

00:12:12,399 --> 00:12:16,800
points to

00:12:13,440 --> 00:12:17,519
the head first node and then we always

00:12:16,800 --> 00:12:21,120
keep

00:12:17,519 --> 00:12:23,440
the previous node as last when

00:12:21,120 --> 00:12:25,040
the current node is head there's no last

00:12:23,440 --> 00:12:29,120
note so

00:12:25,040 --> 00:12:32,240
the last is non-putter in that case

00:12:29,120 --> 00:12:35,360
and in the body of the loop we

00:12:32,240 --> 00:12:36,399
try finding match if we find a match if

00:12:35,360 --> 00:12:40,240
there is a

00:12:36,399 --> 00:12:41,440
previous node we skip the current node

00:12:40,240 --> 00:12:44,480
using previous node

00:12:41,440 --> 00:12:48,639
if there's no previous node we

00:12:44,480 --> 00:12:48,639
are able to directly modifying head

00:12:49,680 --> 00:12:54,639
after done that we delete the current

00:12:52,480 --> 00:12:58,480
node

00:12:54,639 --> 00:13:01,519
continue if we don't find the match

00:12:58,480 --> 00:13:02,399
we assign the current node to the

00:13:01,519 --> 00:13:05,200
previous node

00:13:02,399 --> 00:13:07,519
to save it and move forward to the next

00:13:05,200 --> 00:13:07,519
note

00:13:08,000 --> 00:13:12,959
so this is a rather knife algorithm

00:13:13,680 --> 00:13:18,399
is there anything we can do to simplify

00:13:15,519 --> 00:13:23,040
it using the things

00:13:18,399 --> 00:13:23,040
learned today here are some thoughts

00:13:24,160 --> 00:13:28,240
we will directly modify head

00:13:30,320 --> 00:13:37,440
as if we have an air value reference

00:13:34,079 --> 00:13:37,440
that points to the head

00:13:38,160 --> 00:13:40,480
right

00:13:42,000 --> 00:13:46,079
can we form a reference to pointer for

00:13:44,720 --> 00:13:48,560
each current node

00:13:46,079 --> 00:13:50,959
so that we can directly modify every

00:13:48,560 --> 00:13:56,320
current node

00:13:50,959 --> 00:13:56,320
in the same way modifying head

00:13:57,120 --> 00:14:04,480
and yes we can do so

00:14:00,399 --> 00:14:08,959
by rebinding the reference to head

00:14:04,480 --> 00:14:08,959
to every other node so

00:14:09,600 --> 00:14:14,079
we start with binding a reference

00:14:11,680 --> 00:14:14,079
wrapper

00:14:14,480 --> 00:14:17,920
starts with binding the head to a

00:14:16,639 --> 00:14:21,279
reference wrapper

00:14:17,920 --> 00:14:24,959
and while we are going um

00:14:21,279 --> 00:14:27,839
iterating if we found a match

00:14:24,959 --> 00:14:28,800
we can perform relinking by replacing

00:14:27,839 --> 00:14:32,639
the current node

00:14:28,800 --> 00:14:33,839
with the next node when we don't have a

00:14:32,639 --> 00:14:36,160
match

00:14:33,839 --> 00:14:38,959
we continue iterating by rebinding the

00:14:36,160 --> 00:14:42,839
reference to the next node

00:14:38,959 --> 00:14:45,839
so that's the entire algorithm for

00:14:42,839 --> 00:14:45,839
remove

00:14:47,440 --> 00:14:55,199
you can compare this algorithm

00:14:52,320 --> 00:14:58,800
with this one that is written using

00:14:55,199 --> 00:15:01,199
pointer to pointers

00:14:58,800 --> 00:15:03,600
even has a name called two-star

00:15:01,199 --> 00:15:07,040
programming

00:15:03,600 --> 00:15:08,800
and linus even says

00:15:07,040 --> 00:15:12,000
this kind of code is written by people

00:15:08,800 --> 00:15:12,000
who understand pointers

00:15:12,480 --> 00:15:16,000
i would recommend these experts stop

00:15:14,959 --> 00:15:19,600
drawing lines

00:15:16,000 --> 00:15:20,320
behind themselves you may understand

00:15:19,600 --> 00:15:24,839
pointers

00:15:20,320 --> 00:15:26,240
but you don't understand a bindable

00:15:24,839 --> 00:15:31,759
reference

00:15:26,240 --> 00:15:31,759
to me pointers have very mixed semantics

00:15:32,480 --> 00:15:36,399
the following material are stolen from

00:15:34,480 --> 00:15:39,040
what he brought

00:15:36,399 --> 00:15:40,399
if you come to cpbcom but you know don't

00:15:39,040 --> 00:15:44,240
know who him is

00:15:40,399 --> 00:15:44,240
please look up his video on youtube

00:15:45,519 --> 00:15:52,480
so what it says a pointer value

00:15:49,279 --> 00:15:54,399
is a value of a pointer variable just

00:15:52,480 --> 00:15:57,440
like all variables values

00:15:54,399 --> 00:15:59,839
a pointer value is a r value

00:15:57,440 --> 00:16:01,279
what what does this mean here is that a

00:15:59,839 --> 00:16:04,800
point value is something like

00:16:01,279 --> 00:16:08,720
0x 0 0 1

00:16:04,800 --> 00:16:11,040
that's a r value but unlike r values of

00:16:08,720 --> 00:16:12,160
other types a pointer value can be

00:16:11,040 --> 00:16:16,079
treated as an

00:16:12,160 --> 00:16:16,079
l value if you dereference it

00:16:16,399 --> 00:16:21,600
a point t is a variable whose l value

00:16:19,279 --> 00:16:23,199
corresponds to the r value of some

00:16:21,600 --> 00:16:24,880
pointer variable

00:16:23,199 --> 00:16:27,759
a point is what you get if you

00:16:24,880 --> 00:16:27,759
dereference it

00:16:28,240 --> 00:16:34,880
given these backgrounds a pointer value

00:16:31,680 --> 00:16:36,480
is simultaneously an air value from the

00:16:34,880 --> 00:16:38,639
point is perspective

00:16:36,480 --> 00:16:41,680
and then r value from the point of

00:16:38,639 --> 00:16:41,680
variables perspective

00:16:42,880 --> 00:16:46,560
which means the so-called two-star

00:16:45,440 --> 00:16:49,920
programming

00:16:46,560 --> 00:16:53,920
made use of this semantics while

00:16:49,920 --> 00:16:53,920
reference wrapper made an explicit

00:16:55,519 --> 00:17:00,079
let's give this idea a little more

00:16:57,839 --> 00:17:04,559
practice

00:17:00,079 --> 00:17:06,640
still it's a linked list this time

00:17:04,559 --> 00:17:08,160
how do we implement a function that

00:17:06,640 --> 00:17:11,520
reads from file

00:17:08,160 --> 00:17:19,120
one line panel per node note that we'll

00:17:11,520 --> 00:17:22,959
be using stool get line to do this

00:17:19,120 --> 00:17:26,240
and here's the answer same as before

00:17:22,959 --> 00:17:29,919
we start with binding head

00:17:26,240 --> 00:17:33,200
to a reference wrapper and

00:17:29,919 --> 00:17:34,400
rebind that in each iteration the only

00:17:33,200 --> 00:17:37,440
difference is that

00:17:34,400 --> 00:17:40,799
this time we are able to

00:17:37,440 --> 00:17:40,799
form a new node

00:17:40,880 --> 00:17:48,160
for each line we read and assign that

00:17:44,400 --> 00:17:50,640
node directly to the current node we are

00:17:48,160 --> 00:17:50,640
visiting

00:17:52,640 --> 00:18:02,799
so far is there any questions let me see

00:18:00,400 --> 00:18:02,799
when they

00:18:04,160 --> 00:18:10,080
why there's no why there's no stool

00:18:07,679 --> 00:18:14,240
not non-pointer in my case it will be a

00:18:10,080 --> 00:18:17,200
good substitution for reference wrapper

00:18:14,240 --> 00:18:17,760
um i think the pointer still has

00:18:17,200 --> 00:18:21,039
pointers

00:18:17,760 --> 00:18:24,000
matrix right it's it's still

00:18:21,039 --> 00:18:26,480
simultaneously an l value and r value so

00:18:24,000 --> 00:18:26,480
that's still

00:18:26,840 --> 00:18:33,600
different

00:18:29,120 --> 00:18:33,600
okay let's go back to the talk

00:18:35,520 --> 00:18:38,160
last topic

00:18:40,160 --> 00:18:47,039
you probably have seen code like this

00:18:43,440 --> 00:18:48,559
function pointers we start with creating

00:18:47,039 --> 00:18:51,200
function pointers from

00:18:48,559 --> 00:18:53,600
some function and in some condition we

00:18:51,200 --> 00:18:56,240
can assign the function point

00:18:53,600 --> 00:18:56,640
uh as i different function pointer to

00:18:56,240 --> 00:18:58,000
sorry

00:18:56,640 --> 00:19:00,720
assign a different function to the

00:18:58,000 --> 00:19:04,080
function pointer and then

00:19:00,720 --> 00:19:06,400
achieve the effect of calling

00:19:04,080 --> 00:19:07,760
functions conditionally by calling the

00:19:06,400 --> 00:19:11,039
function point

00:19:07,760 --> 00:19:14,160
function pointer

00:19:11,039 --> 00:19:18,080
so if you think about this example

00:19:14,160 --> 00:19:21,360
function pointers it is essentially

00:19:18,080 --> 00:19:25,200
a refinable reference in the language

00:19:21,360 --> 00:19:26,640
because first is usage models after

00:19:25,200 --> 00:19:29,039
references

00:19:26,640 --> 00:19:29,840
you don't need to reference a function

00:19:29,039 --> 00:19:32,320
pointer

00:19:29,840 --> 00:19:34,880
in order to call it you can just call it

00:19:32,320 --> 00:19:38,320
using the ordinary function call syntax

00:19:34,880 --> 00:19:40,880
and this syntax is shared by reference

00:19:38,320 --> 00:19:40,880
to function

00:19:41,039 --> 00:19:46,480
not only that it is rebindable using a

00:19:44,320 --> 00:19:48,720
simple assignment

00:19:46,480 --> 00:19:52,960
so we have a reminder referencing

00:19:48,720 --> 00:19:56,720
language already

00:19:52,960 --> 00:20:00,799
so going back to this program

00:19:56,720 --> 00:20:02,720
if we replace auto with reference

00:20:00,799 --> 00:20:07,520
wrapper

00:20:02,720 --> 00:20:11,200
you'll find that the program still works

00:20:07,520 --> 00:20:14,640
because we provide the core operator

00:20:11,200 --> 00:20:14,640
to reference wrapper

00:20:14,799 --> 00:20:19,280
reference wrapper works as a function

00:20:16,640 --> 00:20:23,280
pointer as well

00:20:19,280 --> 00:20:25,280
only better because again

00:20:23,280 --> 00:20:28,320
we made it closely matches function

00:20:25,280 --> 00:20:28,320
pointers capability

00:20:29,440 --> 00:20:32,960
and reference wrapper extends the scope

00:20:31,440 --> 00:20:38,400
of pointy to

00:20:32,960 --> 00:20:38,400
corporal objects not only functions

00:20:39,120 --> 00:20:42,480
and it's not normal

00:20:42,720 --> 00:20:49,120
so what do i mean by saying it closely

00:20:46,159 --> 00:20:52,400
matches function pointer's capability

00:20:49,120 --> 00:20:55,520
i'll give you some examples

00:20:52,400 --> 00:20:58,400
first reference wrapper works in

00:20:55,520 --> 00:20:58,400
constexpr

00:20:59,120 --> 00:21:02,799
you can use that in a constant export

00:21:01,440 --> 00:21:05,120
function

00:21:02,799 --> 00:21:06,400
binds a reference wrapper to a contact

00:21:05,120 --> 00:21:09,039
square function

00:21:06,400 --> 00:21:11,120
and finally you can even call it in a

00:21:09,039 --> 00:21:16,240
call context per context

00:21:11,120 --> 00:21:19,679
just like function pointers this

00:21:16,240 --> 00:21:22,720
is um this guarantee is given

00:21:19,679 --> 00:21:25,280
in cbrs 20. if your

00:21:22,720 --> 00:21:28,640
stand library vendor has implemented

00:21:25,280 --> 00:21:28,640
you're working to contribute

00:21:29,600 --> 00:21:34,880
not only that reference wrapper's

00:21:33,120 --> 00:21:36,640
core operator is also properly

00:21:34,880 --> 00:21:39,919
constrained to make it

00:21:36,640 --> 00:21:40,880
behave like function pointers so if you

00:21:39,919 --> 00:21:43,039
have

00:21:40,880 --> 00:21:46,240
some original function and a reference

00:21:43,039 --> 00:21:46,240
wrapper to that function

00:21:46,400 --> 00:21:49,280
if your test

00:21:50,480 --> 00:21:56,720
is invokable of the

00:21:53,520 --> 00:22:00,640
original function given using

00:21:56,720 --> 00:22:03,360
a set of argument types

00:22:00,640 --> 00:22:04,720
if the symbol if is invokable answers

00:22:03,360 --> 00:22:06,480
yes

00:22:04,720 --> 00:22:08,240
it's reference rep to the original

00:22:06,480 --> 00:22:11,280
function its reference wrapper

00:22:08,240 --> 00:22:13,840
also answers yes if

00:22:11,280 --> 00:22:14,480
uh is invokable answers no reference

00:22:13,840 --> 00:22:17,520
wrapper

00:22:14,480 --> 00:22:17,520
answers no as well

00:22:19,360 --> 00:22:26,000
so callable objects do you mean

00:22:22,799 --> 00:22:30,240
pointer to members well yes

00:22:26,000 --> 00:22:32,320
and no reference wrapper can bind to

00:22:30,240 --> 00:22:34,000
air value appointed members and call

00:22:32,320 --> 00:22:35,360
them with the ordinary function called

00:22:34,000 --> 00:22:37,919
syntax

00:22:35,360 --> 00:22:38,720
but if you recall what pointer to

00:22:37,919 --> 00:22:42,080
members are

00:22:38,720 --> 00:22:44,960
they are usually pr values

00:22:42,080 --> 00:22:47,039
the point the problem here is that when

00:22:44,960 --> 00:22:50,080
we are seeing

00:22:47,039 --> 00:22:52,400
reference wrapper models after reference

00:22:50,080 --> 00:22:56,880
to functions

00:22:52,400 --> 00:23:00,320
we mean that it can points to functions

00:22:56,880 --> 00:23:02,159
but to pointer to members you can't

00:23:00,320 --> 00:23:02,640
really form a reference to member

00:23:02,159 --> 00:23:05,919
because

00:23:02,640 --> 00:23:07,039
pointer to member has no pointy there's

00:23:05,919 --> 00:23:09,840
no such

00:23:07,039 --> 00:23:12,480
entity in language called member that

00:23:09,840 --> 00:23:17,360
that you points to

00:23:12,480 --> 00:23:20,880
so it works but probably not in the way

00:23:17,360 --> 00:23:23,840
you're looking for stood memphis

00:23:20,880 --> 00:23:23,840
is probably what you're looking for

00:23:25,280 --> 00:23:30,480
but it does works well with user-defined

00:23:28,320 --> 00:23:34,159
core objects

00:23:30,480 --> 00:23:37,039
so if you have two cardboard objects of

00:23:34,159 --> 00:23:39,200
the same type

00:23:37,039 --> 00:23:40,240
you can switch between using reference

00:23:39,200 --> 00:23:44,559
wrapper

00:23:40,240 --> 00:23:48,400
just fine but this does not mean however

00:23:44,559 --> 00:23:48,400
reference wrapper can do everything

00:23:48,559 --> 00:23:53,520
if your cardboard objects are of

00:23:50,960 --> 00:23:55,200
different types

00:23:53,520 --> 00:23:57,120
you won't be able to switch between them

00:23:55,200 --> 00:23:59,760
using reference wrapper because

00:23:57,120 --> 00:24:05,760
reference wrapper does not erase the

00:23:59,760 --> 00:24:08,559
point is type

00:24:05,760 --> 00:24:10,640
we can ask stu fung stood function to

00:24:08,559 --> 00:24:14,720
erase the types though

00:24:10,640 --> 00:24:14,720
so this is the extremely

00:24:14,960 --> 00:24:18,080
rarely used feature the background is

00:24:17,600 --> 00:24:21,600
that

00:24:18,080 --> 00:24:24,640
stool function starts with

00:24:21,600 --> 00:24:25,760
value semantics but if you assign

00:24:24,640 --> 00:24:28,640
reference wrapper

00:24:25,760 --> 00:24:31,600
to something to stool function it

00:24:28,640 --> 00:24:36,640
behaves as if it has

00:24:31,600 --> 00:24:36,640
semantics but

00:24:37,840 --> 00:24:40,960
let's look back what we're looking for

00:24:39,919 --> 00:24:44,559
here

00:24:40,960 --> 00:24:47,600
all we need is just a

00:24:44,559 --> 00:24:51,600
rebindable reference to functions

00:24:47,600 --> 00:24:53,919
and it should be a type erasure right

00:24:51,600 --> 00:24:54,640
why don't we just provide it a type

00:24:53,919 --> 00:24:58,240
erased

00:24:54,640 --> 00:25:01,600
rebindable reference to functions stood

00:24:58,240 --> 00:25:06,000
function ref we are going to

00:25:01,600 --> 00:25:06,000
have it in cpr 23.

00:25:07,760 --> 00:25:12,799
so to summarize what can replace

00:25:10,880 --> 00:25:15,840
function pointers

00:25:12,799 --> 00:25:19,520
today we learned reference wrapper

00:25:15,840 --> 00:25:22,559
that is non non uh stood function

00:25:19,520 --> 00:25:25,200
uh function ref is normal

00:25:22,559 --> 00:25:26,159
as of today although i don't know why

00:25:25,200 --> 00:25:29,760
stool function

00:25:26,159 --> 00:25:32,240
is normal

00:25:29,760 --> 00:25:34,320
reference wrapper has reference matrix

00:25:32,240 --> 00:25:38,240
so that's function ref

00:25:34,320 --> 00:25:40,799
stool function has value semantics

00:25:38,240 --> 00:25:42,559
reference wrapper does not erase the

00:25:40,799 --> 00:25:45,600
point is type

00:25:42,559 --> 00:25:47,760
function ref and stool function perform

00:25:45,600 --> 00:25:50,880
type

00:25:47,760 --> 00:25:52,799
type erase but

00:25:50,880 --> 00:25:54,400
reference wrapper is the smartest

00:25:52,799 --> 00:25:59,600
smallest of the r3

00:25:54,400 --> 00:25:59,600
its size is a larger say pointer size

00:25:59,760 --> 00:26:06,400
function ref is at least two exercise as

00:26:02,880 --> 00:26:06,400
two function is only larger

00:26:08,159 --> 00:26:12,400
here's a summary of what we learned

00:26:10,000 --> 00:26:12,400
today

00:26:12,720 --> 00:26:16,880
reference wrapper is a refinable

00:26:14,400 --> 00:26:16,880
reference

00:26:17,919 --> 00:26:21,760
it makes reference binding and design

00:26:20,000 --> 00:26:24,960
through explicit

00:26:21,760 --> 00:26:28,159
this even allows you to mix these

00:26:24,960 --> 00:26:30,480
semantics in the same program

00:26:28,159 --> 00:26:33,279
and reference wrapper is a better

00:26:30,480 --> 00:26:33,279
function pointer

00:26:35,279 --> 00:26:45,120
question time let me see

00:26:40,720 --> 00:26:47,520
when they how does performance of

00:26:45,120 --> 00:26:50,000
reference wrapper compare to a raw

00:26:47,520 --> 00:26:50,000
reference

00:26:50,080 --> 00:26:57,279
i think roughly the same

00:26:54,159 --> 00:27:00,159
because reference wrapper just has a

00:26:57,279 --> 00:27:00,159
pointer inside

00:27:02,480 --> 00:27:12,000
how do i

00:27:07,679 --> 00:27:12,000
why there's oh that i answered this

00:27:18,840 --> 00:27:23,039
question

00:27:20,000 --> 00:27:26,640
okay um do you have uh

00:27:23,039 --> 00:27:30,880
more questions if not

00:27:26,640 --> 00:27:33,120
i have a um ask me anything session

00:27:30,880 --> 00:27:35,039
right after this session in the in this

00:27:33,120 --> 00:27:38,799
room

00:27:35,039 --> 00:27:38,799
you're welcome to join and ask me more

00:27:46,840 --> 00:27:49,840
questions

00:27:57,919 --> 00:28:00,000

YouTube URL: https://www.youtube.com/watch?v=EKJMZCL00Ak


