Title: Just-in-Time Compilation: The Next Big Thing? - Ben Deane & Kris Jusiak - CppCon 2020
Publication date: 2020-09-29
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/justintime_compilation_the_next_big_thing/justintime_compilation_the_next_big_thing__ben_deane_kris_jusiak__cppcon_2020.pdf
---
JITting code is a feature of many languages but has not yet landed in C++. However, there has been some work to integrate JITting into Clang by Hal Finkel. Having a JIT compiler offers flexibility at runtime without sacrificing compile-time performance, and can take advantage of late optimizations that maybe even better than those available at compile-time.

C++ is still in the early stages of exploring JIT capabilities. In this talk, we'll expand the boundaries and the possibilities of JITting in C++ by combining C++20 features with the clang-jit compiler work introduced in P1609. We'll show some use cases we find non-obvious and exciting and that may change the future of compile-time programming by blurring the boundary between compile-time and runtime.

---
Ben was in the game industry for 23 years, at companies like EA and Blizzard. For the last couple of years he's been working in the finance industry at Quantlab. He's always looking for useful new techniques in C++, and he geeks out on algorithms, APIs, types and functional programming.

Kris is a Senior Software Engineer passionate about programming and has worked in different industries over the years including telecommunications, games and most recently finance for Quantlab Financial, LLC. He has an interest in modern C++ development with a focus on performance and quality. He is an open-source enthusiast with multiple open-source libraries where he uses template meta-programming techniques to support the C++ rule - "Don't pay for what you don't use" whilst trying to be as declarative as possible with a help of domain-specific languages. Kris is also a keen advocate of extreme programming techniques, Test/Behavior Driven Development and truly believes that 'the only way to go fast is to go well!'.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,840 --> 00:00:12,480
hello everyone

00:00:10,719 --> 00:00:15,120
thank you for coming to our talk just in

00:00:12,480 --> 00:00:17,199
time compilation the next big thing

00:00:15,120 --> 00:00:19,439
my co-presenter and colleague is chris

00:00:17,199 --> 00:00:21,199
giusek he's the author of several

00:00:19,439 --> 00:00:22,560
libraries with boost in the name that on

00:00:21,199 --> 00:00:24,720
quite in boost

00:00:22,560 --> 00:00:27,279
boost di for dependency injection boost

00:00:24,720 --> 00:00:30,640
sml for high performance state machines

00:00:27,279 --> 00:00:33,840
and most recently boost ut or micro test

00:00:30,640 --> 00:00:36,640
a single single header c plus 20

00:00:33,840 --> 00:00:36,640
testing framework

00:00:37,440 --> 00:00:43,440
and this is bending

00:00:40,800 --> 00:00:44,320
bending is a great speaker and albert

00:00:43,440 --> 00:00:46,480
wizard

00:00:44,320 --> 00:00:49,360
a functional programming advocate one of

00:00:46,480 --> 00:00:52,640
the very few who actually understand

00:00:49,360 --> 00:00:53,039
monoids and monads and the meaning of

00:00:52,640 --> 00:00:55,600
them

00:00:53,039 --> 00:00:59,039
and now where to find them as well he

00:00:55,600 --> 00:01:00,879
has been working on games as well so if

00:00:59,039 --> 00:01:02,640
you like playing online games

00:01:00,879 --> 00:01:04,320
and you've probably heard of battlenet

00:01:02,640 --> 00:01:07,760
so that's the contribution

00:01:04,320 --> 00:01:10,000
thanks to to ben and i've been

00:01:07,760 --> 00:01:11,119
privileged to work with him at quan club

00:01:10,000 --> 00:01:13,360
for a few

00:01:11,119 --> 00:01:15,119
past years and really enjoy that and you

00:01:13,360 --> 00:01:16,479
definitely you believe

00:01:15,119 --> 00:01:18,400
you better believe me that you don't

00:01:16,479 --> 00:01:19,119
want to miss his talk which is at half

00:01:18,400 --> 00:01:22,479
one

00:01:19,119 --> 00:01:25,119
about constructing algorithms

00:01:22,479 --> 00:01:26,799
all right thanks chris um but this talks

00:01:25,119 --> 00:01:28,720
about just in time compilation if you

00:01:26,799 --> 00:01:30,640
saw jf's talk the other day

00:01:28,720 --> 00:01:31,759
uh it's a very sort of complementary

00:01:30,640 --> 00:01:33,439
talk jf

00:01:31,759 --> 00:01:36,079
did a great talk going into the history

00:01:33,439 --> 00:01:37,840
of of jit uh chris and i are gonna talk

00:01:36,079 --> 00:01:41,119
more about the practicalities

00:01:37,840 --> 00:01:42,560
of jitting in c plus plus particularly

00:01:41,119 --> 00:01:44,000
based on the work that hal finkel

00:01:42,560 --> 00:01:45,360
introduced which we'll talk about as we

00:01:44,000 --> 00:01:47,600
go along

00:01:45,360 --> 00:01:49,119
so we are going to cover some motivation

00:01:47,600 --> 00:01:50,640
for jitting we're going to look at some

00:01:49,119 --> 00:01:53,119
existing solutions in c

00:01:50,640 --> 00:01:54,000
plus and other languages then we're

00:01:53,119 --> 00:01:56,240
going to sort of take a deep

00:01:54,000 --> 00:01:59,200
dive into how it works based on this

00:01:56,240 --> 00:02:01,439
paper piece 1609

00:01:59,200 --> 00:02:02,399
uh then we're going to riff on some

00:02:01,439 --> 00:02:05,360
examples

00:02:02,399 --> 00:02:07,040
show some examples of uh things that

00:02:05,360 --> 00:02:08,000
work today based on this work and things

00:02:07,040 --> 00:02:11,440
that might work

00:02:08,000 --> 00:02:13,440
beyond c plus plus 20.

00:02:11,440 --> 00:02:15,360
and then we'll summarize and take a take

00:02:13,440 --> 00:02:18,160
a glimpse into the future as we think it

00:02:15,360 --> 00:02:18,160
might turn out

00:02:18,560 --> 00:02:25,200
so why would you want to jit something

00:02:22,239 --> 00:02:26,640
um well jitting is just in time

00:02:25,200 --> 00:02:27,599
compilation as this thing from ahead of

00:02:26,640 --> 00:02:29,760
time compilation

00:02:27,599 --> 00:02:31,200
ahead of time is what we normally think

00:02:29,760 --> 00:02:33,680
of when we think of

00:02:31,200 --> 00:02:34,319
compilation uh but when we jit it's as

00:02:33,680 --> 00:02:36,959
if we

00:02:34,319 --> 00:02:38,000
ship the compiler inside the application

00:02:36,959 --> 00:02:41,040
or library

00:02:38,000 --> 00:02:44,239
so that we can compile just in time

00:02:41,040 --> 00:02:44,239
and at the point of need

00:02:44,480 --> 00:02:48,720
so yes we're basically building an

00:02:46,959 --> 00:02:50,480
application or a library which contains

00:02:48,720 --> 00:02:53,200
within it uh

00:02:50,480 --> 00:02:54,239
clang in this case but a compiler that

00:02:53,200 --> 00:02:56,560
can do jitting

00:02:54,239 --> 00:02:58,319
not just when we as developers sit down

00:02:56,560 --> 00:02:59,200
to write the code but when our users run

00:02:58,319 --> 00:03:02,080
the code

00:02:59,200 --> 00:03:05,840
at install time at deployment time or

00:03:02,080 --> 00:03:08,879
just before runtime

00:03:05,840 --> 00:03:09,440
so there are some benefits and drawbacks

00:03:08,879 --> 00:03:12,159
of

00:03:09,440 --> 00:03:13,120
compilation sometimes ahead of time is

00:03:12,159 --> 00:03:16,800
not possible

00:03:13,120 --> 00:03:18,400
if i if i have things that i don't know

00:03:16,800 --> 00:03:19,920
out of time sometimes it's just not

00:03:18,400 --> 00:03:22,239
desirable because i can achieve better

00:03:19,920 --> 00:03:24,159
performance with just in time

00:03:22,239 --> 00:03:25,920
i can get perth benefits i can get

00:03:24,159 --> 00:03:27,519
productivity benefits

00:03:25,920 --> 00:03:29,920
and i can just get different workflows

00:03:27,519 --> 00:03:32,319
and use cases

00:03:29,920 --> 00:03:33,200
so if the source is perhaps provided by

00:03:32,319 --> 00:03:35,280
a client

00:03:33,200 --> 00:03:36,720
or by a colleague who's using my library

00:03:35,280 --> 00:03:37,519
application so an internal client in

00:03:36,720 --> 00:03:38,799
that sense

00:03:37,519 --> 00:03:40,879
or backed by a tool that's also

00:03:38,799 --> 00:03:42,239
generating code obviously

00:03:40,879 --> 00:03:43,920
if i don't know it at a time i can't

00:03:42,239 --> 00:03:45,360
compile it

00:03:43,920 --> 00:03:47,280
if i don't have the parameters to

00:03:45,360 --> 00:03:49,200
constrain the code yet

00:03:47,280 --> 00:03:50,480
i can't tailor the code to them ahead of

00:03:49,200 --> 00:03:52,000
time compilation

00:03:50,480 --> 00:03:53,599
so maybe these arguments are only

00:03:52,000 --> 00:03:55,920
available at runtime

00:03:53,599 --> 00:03:56,720
and if if i compile everything ahead of

00:03:55,920 --> 00:03:58,879
time

00:03:56,720 --> 00:04:00,480
it might lock me into an api whereas if

00:03:58,879 --> 00:04:02,000
i delay compilation

00:04:00,480 --> 00:04:03,599
to just at the point of knee just at

00:04:02,000 --> 00:04:06,159
runtime with jit

00:04:03,599 --> 00:04:09,680
i move to more an api level boundary

00:04:06,159 --> 00:04:09,680
rather than api level boundary

00:04:10,640 --> 00:04:14,319
sometimes this can give performance

00:04:11,840 --> 00:04:15,599
benefits so if i'm compiling for just

00:04:14,319 --> 00:04:17,040
one target

00:04:15,599 --> 00:04:18,639
maybe i can achieve the best performance

00:04:17,040 --> 00:04:19,919
but many of us are not doing that

00:04:18,639 --> 00:04:21,919
any of us are should bring to multiple

00:04:19,919 --> 00:04:23,680
architectures and maybe maintaining

00:04:21,919 --> 00:04:25,759
multiple distributions of the binary for

00:04:23,680 --> 00:04:27,120
that reason uh if we can reduce the

00:04:25,759 --> 00:04:29,280
amount of binary maintenance we do

00:04:27,120 --> 00:04:31,120
that's probably good

00:04:29,280 --> 00:04:33,120
and in order to get the best possible

00:04:31,120 --> 00:04:34,560
optimization i need the best possible

00:04:33,120 --> 00:04:37,600
information about all of the code not

00:04:34,560 --> 00:04:39,120
just what i know ahead of time

00:04:37,600 --> 00:04:41,120
sometimes it's more productive for me as

00:04:39,120 --> 00:04:42,880
a programmer so compilation time is

00:04:41,120 --> 00:04:44,560
always something we want to minimize

00:04:42,880 --> 00:04:46,639
but gsang allows us to make a new

00:04:44,560 --> 00:04:47,199
trade-off we're trying to minimize total

00:04:46,639 --> 00:04:49,520
time

00:04:47,199 --> 00:04:50,960
and in the case where you're compiling

00:04:49,520 --> 00:04:52,639
something and running it and it might

00:04:50,960 --> 00:04:54,000
take a long time to run and you want to

00:04:52,639 --> 00:04:56,720
compile

00:04:54,000 --> 00:04:58,479
for the best possible fit to that run

00:04:56,720 --> 00:04:59,680
jitting allows you to trade that total

00:04:58,479 --> 00:05:02,960
time and sometimes it's

00:04:59,680 --> 00:05:05,120
actually less expensive in time

00:05:02,960 --> 00:05:06,800
to jit something and then run it than to

00:05:05,120 --> 00:05:08,880
compile something and then

00:05:06,800 --> 00:05:10,479
ahead of time and then run it so we get

00:05:08,880 --> 00:05:12,320
that minimization of the total time

00:05:10,479 --> 00:05:15,680
rather than just the compilation time

00:05:12,320 --> 00:05:17,840
versus the user time um

00:05:15,680 --> 00:05:19,120
and choosing allows us to just compile

00:05:17,840 --> 00:05:21,280
what's needed

00:05:19,120 --> 00:05:22,880
uh and further achieve better

00:05:21,280 --> 00:05:24,160
productivity for that reason

00:05:22,880 --> 00:05:26,240
because we don't have to deal with all

00:05:24,160 --> 00:05:29,360
use cases if we can tailor the code

00:05:26,240 --> 00:05:31,520
at runtime um

00:05:29,360 --> 00:05:33,039
and then besides that it just allows

00:05:31,520 --> 00:05:35,120
different use cases

00:05:33,039 --> 00:05:36,880
uh many many of the things we'll be

00:05:35,120 --> 00:05:39,039
exploring talk to exactly those use

00:05:36,880 --> 00:05:41,600
cases

00:05:39,039 --> 00:05:43,600
so it's just the tip of the iceberg

00:05:41,600 --> 00:05:45,680
really i liken this to

00:05:43,600 --> 00:05:47,039
uh it's sort of a change a sea change in

00:05:45,680 --> 00:05:48,160
development like adopting version

00:05:47,039 --> 00:05:49,440
control was

00:05:48,160 --> 00:05:52,000
and what you're going to see in this

00:05:49,440 --> 00:05:54,400
talk is frankly the stuff we've thought

00:05:52,000 --> 00:05:56,720
of so far but i'm sure there's much more

00:05:54,400 --> 00:05:56,720
to go

00:05:57,120 --> 00:06:00,479
so i'll hand over to chris and he can

00:05:58,800 --> 00:06:02,880
take you through some of the existing

00:06:00,479 --> 00:06:02,880
solutions

00:06:04,880 --> 00:06:09,039
okay thank you brian so if you attended

00:06:07,600 --> 00:06:11,199
uh jf talk

00:06:09,039 --> 00:06:12,560
you probably know that g10 is nothing

00:06:11,199 --> 00:06:14,319
new and

00:06:12,560 --> 00:06:16,960
because of that there are already a lot

00:06:14,319 --> 00:06:19,039
of solutions which we will cover

00:06:16,960 --> 00:06:20,240
if you haven't attended the jf talk you

00:06:19,039 --> 00:06:22,400
definitely

00:06:20,240 --> 00:06:23,759
should it's not just in time for the

00:06:22,400 --> 00:06:24,880
time being but you should definitely

00:06:23,759 --> 00:06:27,680
show and go

00:06:24,880 --> 00:06:28,319
to watch it so what about the existing

00:06:27,680 --> 00:06:30,000
solution c

00:06:28,319 --> 00:06:31,440
plus plus is not new either so there are

00:06:30,000 --> 00:06:33,120
a lot of solutions

00:06:31,440 --> 00:06:35,520
which already exist in c plus plus for

00:06:33,120 --> 00:06:35,919
gtin we'll take a look into a few of

00:06:35,520 --> 00:06:39,039
them

00:06:35,919 --> 00:06:39,520
and we'll focus on one which will dig in

00:06:39,039 --> 00:06:42,160
into

00:06:39,520 --> 00:06:44,240
way more so there's a cling which we'll

00:06:42,160 --> 00:06:45,199
cover in a second so i won't be covering

00:06:44,240 --> 00:06:47,759
right now

00:06:45,199 --> 00:06:48,960
the runtime compiled c plus plus and

00:06:47,759 --> 00:06:51,759
easy jeet

00:06:48,960 --> 00:06:52,880
which are leveraging generated code as

00:06:51,759 --> 00:06:54,960
well as

00:06:52,880 --> 00:06:56,639
hot reloading of the shared libraries

00:06:54,960 --> 00:06:59,199
and compiling it

00:06:56,639 --> 00:06:59,919
under the hood with the gcc or clan

00:06:59,199 --> 00:07:02,160
compiler

00:06:59,919 --> 00:07:03,599
we won't be covering those the one which

00:07:02,160 --> 00:07:08,479
we'll cover here the most

00:07:03,599 --> 00:07:12,880
is the clang jit version of uh

00:07:08,479 --> 00:07:14,560
of clan which is the p1609

00:07:12,880 --> 00:07:17,120
version one with our custom

00:07:14,560 --> 00:07:19,280
modifications to it

00:07:17,120 --> 00:07:21,199
which we'll take a look into into more

00:07:19,280 --> 00:07:23,440
details there also

00:07:21,199 --> 00:07:25,280
solutions which are more compile time as

00:07:23,440 --> 00:07:27,599
well which is

00:07:25,280 --> 00:07:29,199
the mixing is one of them which will

00:07:27,599 --> 00:07:31,039
briefly take a look

00:07:29,199 --> 00:07:32,960
and maybe in the future we'll see how

00:07:31,039 --> 00:07:35,840
that works

00:07:32,960 --> 00:07:36,560
but but yeah there are the resolutions

00:07:35,840 --> 00:07:39,520
as well you

00:07:36,560 --> 00:07:39,520
won't cover here

00:07:39,599 --> 00:07:42,880
so what the difference between cling and

00:07:41,120 --> 00:07:44,160
clang jit because that's

00:07:42,880 --> 00:07:46,960
something which is important to

00:07:44,160 --> 00:07:48,960
understand because they are

00:07:46,960 --> 00:07:50,000
quite popular playing especially clink

00:07:48,960 --> 00:07:54,240
is used

00:07:50,000 --> 00:07:58,080
as a primary as a evil prince loop

00:07:54,240 --> 00:08:01,520
or rebel environment which means that

00:07:58,080 --> 00:08:04,000
it's based for for

00:08:01,520 --> 00:08:04,720
interaction of the user so user can you

00:08:04,000 --> 00:08:08,479
know

00:08:04,720 --> 00:08:10,879
add includes or evil expressions

00:08:08,479 --> 00:08:12,240
and do things like that it was primarily

00:08:10,879 --> 00:08:15,039
built for the

00:08:12,240 --> 00:08:15,919
researchers at cern physicists on the

00:08:15,039 --> 00:08:18,960
other hand

00:08:15,919 --> 00:08:20,960
clank jit is a language extension

00:08:18,960 --> 00:08:22,639
attribute

00:08:20,960 --> 00:08:24,000
which is totally a different approach

00:08:22,639 --> 00:08:27,840
it's not ripple

00:08:24,000 --> 00:08:27,840
it's just an extension

00:08:28,720 --> 00:08:32,560
playing always compiles the whole

00:08:30,160 --> 00:08:35,200
program it's not about you know

00:08:32,560 --> 00:08:36,240
compilation time improvements that much

00:08:35,200 --> 00:08:38,479
as

00:08:36,240 --> 00:08:39,440
trying to be able to have the quicker

00:08:38,479 --> 00:08:41,839
feedback

00:08:39,440 --> 00:08:43,760
for the researchers and then being able

00:08:41,839 --> 00:08:46,480
to leverage the

00:08:43,760 --> 00:08:48,000
out of the box performance uh provided

00:08:46,480 --> 00:08:51,279
by

00:08:48,000 --> 00:08:53,519
by c plus plus on the other hand gtin

00:08:51,279 --> 00:08:55,680
with the clang jit allows of compilation

00:08:53,519 --> 00:08:58,720
of specific united functions which

00:08:55,680 --> 00:09:00,560
attribute and because of that we get a

00:08:58,720 --> 00:09:02,640
really fast compilation times because we

00:09:00,560 --> 00:09:06,560
can leverage the

00:09:02,640 --> 00:09:09,279
normalization of of templated functions

00:09:06,560 --> 00:09:09,839
which are mark with the client and gd

00:09:09,279 --> 00:09:12,560
attribute

00:09:09,839 --> 00:09:13,440
so that gives us much faster compilation

00:09:12,560 --> 00:09:16,640
times

00:09:13,440 --> 00:09:19,839
as we go along clink is

00:09:16,640 --> 00:09:21,600
usually not very well optimized

00:09:19,839 --> 00:09:23,279
and that's not the main focus on it it's

00:09:21,600 --> 00:09:24,720
just the faster iterations on the other

00:09:23,279 --> 00:09:27,519
hand clank jade

00:09:24,720 --> 00:09:28,560
is all about the performance it's marks

00:09:27,519 --> 00:09:30,240
optimizations

00:09:28,560 --> 00:09:32,480
not even possible that build time

00:09:30,240 --> 00:09:37,519
because we can leverage the

00:09:32,480 --> 00:09:39,360
runtime data and promote it from the

00:09:37,519 --> 00:09:41,040
you know from the run time to the

00:09:39,360 --> 00:09:41,600
compile time which we'll take a look in

00:09:41,040 --> 00:09:44,880
the second

00:09:41,600 --> 00:09:45,360
in in a second so as i mentioned before

00:09:44,880 --> 00:09:48,640
this

00:09:45,360 --> 00:09:51,760
this really exciting and

00:09:48,640 --> 00:09:52,480
uh and different approach in in d which

00:09:51,760 --> 00:09:54,959
you can

00:09:52,480 --> 00:09:56,399
actually compile the jit at at compile

00:09:54,959 --> 00:09:57,920
time

00:09:56,399 --> 00:09:59,519
it's similar to what we will be

00:09:57,920 --> 00:10:01,600
discussing here therefore we will

00:09:59,519 --> 00:10:05,200
mention it because it's based on strings

00:10:01,600 --> 00:10:06,720
which we'll take a look have drawbacks

00:10:05,200 --> 00:10:08,800
and a lot of benefits

00:10:06,720 --> 00:10:10,079
but you can see here that in d that's

00:10:08,800 --> 00:10:13,200
the language by the way

00:10:10,079 --> 00:10:13,920
we have a again general generate track

00:10:13,200 --> 00:10:16,720
function

00:10:13,920 --> 00:10:17,600
which takes the name and then and and

00:10:16,720 --> 00:10:20,959
some member and

00:10:17,600 --> 00:10:24,399
inject a fragment into the into the code

00:10:20,959 --> 00:10:26,880
by by calling a mixing so you can

00:10:24,399 --> 00:10:27,600
think of it like cheating at compile

00:10:26,880 --> 00:10:30,640
time

00:10:27,600 --> 00:10:33,440
extract into your program so

00:10:30,640 --> 00:10:35,360
if you if you run this uh this function

00:10:33,440 --> 00:10:38,079
with the full end bar it will produce

00:10:35,360 --> 00:10:40,320
a structure with the member bar which is

00:10:38,079 --> 00:10:43,040
super exciting because you can

00:10:40,320 --> 00:10:44,160
extend your c plus plus program as you

00:10:43,040 --> 00:10:45,920
go

00:10:44,160 --> 00:10:47,920
but that's not what we'll be talking

00:10:45,920 --> 00:10:51,200
about here

00:10:47,920 --> 00:10:54,560
uh we'll be talking about

00:10:51,200 --> 00:10:57,600
gtin actually at runtime so

00:10:54,560 --> 00:11:00,640
let's take a look uh how it works

00:10:57,600 --> 00:11:02,240
without further ado let's begin so

00:11:00,640 --> 00:11:04,399
just a reminder again that we'll be

00:11:02,240 --> 00:11:07,120
talking about p1609

00:11:04,399 --> 00:11:09,040
and especially about the version one

00:11:07,120 --> 00:11:10,880
because the paper has changed we also

00:11:09,040 --> 00:11:13,040
have the modifications to it

00:11:10,880 --> 00:11:15,200
which are not open source yet but they

00:11:13,040 --> 00:11:17,760
will be in the future

00:11:15,200 --> 00:11:19,120
so you can imagine a jit function which

00:11:17,760 --> 00:11:22,640
just take

00:11:19,120 --> 00:11:25,519
a template type t and press the

00:11:22,640 --> 00:11:27,120
and will print the type id of it we'll

00:11:25,519 --> 00:11:29,200
expect something

00:11:27,120 --> 00:11:30,480
as mangled name here because thunder

00:11:29,200 --> 00:11:33,360
doesn't specify what

00:11:30,480 --> 00:11:36,320
the name would be like but let's take a

00:11:33,360 --> 00:11:37,839
look when we call it with end

00:11:36,320 --> 00:11:40,399
when we call it with type and we'll just

00:11:37,839 --> 00:11:44,160
get i which is the mango 9 for an end

00:11:40,399 --> 00:11:48,240
nothing special here right uh there is

00:11:44,160 --> 00:11:49,920
we all done that since c plus plus 98.

00:11:48,240 --> 00:11:52,240
what about if you add the clankjit

00:11:49,920 --> 00:11:53,920
attribute as a follow-up

00:11:52,240 --> 00:11:55,680
and we'll have to compile with the

00:11:53,920 --> 00:11:58,720
we'll take a look into that just

00:11:55,680 --> 00:12:01,680
a reminder about that

00:11:58,720 --> 00:12:02,399
and let's pass it let's pass instead of

00:12:01,680 --> 00:12:06,320
the type

00:12:02,399 --> 00:12:06,320
kind of a type string which is a

00:12:06,399 --> 00:12:10,079
a string so let me just pause here for a

00:12:09,600 --> 00:12:12,399
second

00:12:10,079 --> 00:12:14,560
you just for you to understand it's like

00:12:12,399 --> 00:12:17,680
we actually passing a string here

00:12:14,560 --> 00:12:18,800
it's not a type and what will happen is

00:12:17,680 --> 00:12:21,680
that

00:12:18,800 --> 00:12:23,120
this end as a string will be converted

00:12:21,680 --> 00:12:25,600
by the clank g

00:12:23,120 --> 00:12:26,720
machinery under the hood into the type

00:12:25,600 --> 00:12:29,519
so the class t

00:12:26,720 --> 00:12:31,200
here the type t will still be end and

00:12:29,519 --> 00:12:31,680
what we will print it will be the type

00:12:31,200 --> 00:12:34,959
id

00:12:31,680 --> 00:12:36,720
of an end which would be an i so

00:12:34,959 --> 00:12:38,399
yeah that's what the mind blowing or the

00:12:36,720 --> 00:12:41,440
clan g fact that

00:12:38,399 --> 00:12:43,120
the run time here maybe on this specific

00:12:41,440 --> 00:12:46,399
example it's not really runtime yet

00:12:43,120 --> 00:12:49,680
might be a an end at compile time but

00:12:46,399 --> 00:12:51,360
it will produce an end as well from a

00:12:49,680 --> 00:12:53,120
string

00:12:51,360 --> 00:12:55,600
and it also what is important the body

00:12:53,120 --> 00:12:57,600
of the function here the c out

00:12:55,600 --> 00:12:59,440
won't be compiled or won't be even

00:12:57,600 --> 00:13:01,120
touched until the runtime point of

00:12:59,440 --> 00:13:03,200
instantiation which is kind of

00:13:01,120 --> 00:13:04,720
a bit different concept than usual it's

00:13:03,200 --> 00:13:05,760
like if you don't call it you don't pay

00:13:04,720 --> 00:13:07,440
for it so

00:13:05,760 --> 00:13:08,959
it won't be even parsed or anything like

00:13:07,440 --> 00:13:10,240
that it will be passed at runtime when

00:13:08,959 --> 00:13:12,560
you actually call it

00:13:10,240 --> 00:13:15,680
and all the flags for the compilation

00:13:12,560 --> 00:13:19,200
will be passed from the

00:13:15,680 --> 00:13:20,639
uh from the host compilation so and they

00:13:19,200 --> 00:13:22,800
also might be overwritten by

00:13:20,639 --> 00:13:25,519
your own flags so that would be exciting

00:13:22,800 --> 00:13:28,959
that we see into that in the future

00:13:25,519 --> 00:13:30,639
so i hope that makes sense so let's take

00:13:28,959 --> 00:13:33,519
a look into

00:13:30,639 --> 00:13:34,720
uh something else let's go with this

00:13:33,519 --> 00:13:37,680
example a bit further

00:13:34,720 --> 00:13:38,639
let's say we have a hello world cpp file

00:13:37,680 --> 00:13:42,639
in which

00:13:38,639 --> 00:13:45,519
we actually will get the first argument

00:13:42,639 --> 00:13:45,920
of the command line imagine that we have

00:13:45,519 --> 00:13:49,440
an

00:13:45,920 --> 00:13:52,800
arc b of 1 being passed to g

00:13:49,440 --> 00:13:56,560
angle brackets how exciting is that

00:13:52,800 --> 00:14:00,000
what will what will happen when will

00:13:56,560 --> 00:14:03,040
cheat will cheat when we will compile it

00:14:00,000 --> 00:14:08,560
aot style with six

00:14:03,040 --> 00:14:08,560
flags uh and cxx flags nfgfgt

00:14:08,959 --> 00:14:12,480
well you will notice that the hello

00:14:10,240 --> 00:14:16,079
world will have 75 megabytes

00:14:12,480 --> 00:14:18,160
well that's a bit oh

00:14:16,079 --> 00:14:19,199
that's quite a love for domain right

00:14:18,160 --> 00:14:21,440
with the jit function

00:14:19,199 --> 00:14:22,399
well the reason being is the fact that

00:14:21,440 --> 00:14:24,480
the compiler

00:14:22,399 --> 00:14:26,079
the clan compiler will be included as

00:14:24,480 --> 00:14:29,360
well as the pre-compiled module

00:14:26,079 --> 00:14:31,199
of the host

00:14:29,360 --> 00:14:32,399
things so if you imagine that you have

00:14:31,199 --> 00:14:35,839
something

00:14:32,399 --> 00:14:36,880
different or you have uh includes and

00:14:35,839 --> 00:14:39,199
anything

00:14:36,880 --> 00:14:41,120
be before the main that will be part of

00:14:39,199 --> 00:14:43,279
the pre-compiled module

00:14:41,120 --> 00:14:45,120
and the compiler sorry and the compiler

00:14:43,279 --> 00:14:47,279
will be included as well

00:14:45,120 --> 00:14:48,880
so what will happen if you call it let's

00:14:47,279 --> 00:14:51,360
call it with hello world end and

00:14:48,880 --> 00:14:52,160
notice here end has been passed from the

00:14:51,360 --> 00:14:55,519
command line

00:14:52,160 --> 00:14:58,160
as a string it will produce an i

00:14:55,519 --> 00:14:59,519
which is an end double will produce the

00:14:58,160 --> 00:15:02,959
d

00:14:59,519 --> 00:15:05,680
as expected the top of the lambda that

00:15:02,959 --> 00:15:08,560
will be a c plus plus 20 feature

00:15:05,680 --> 00:15:09,440
will produce yeah dollar underscore zero

00:15:08,560 --> 00:15:11,440
it clang

00:15:09,440 --> 00:15:12,959
that the mongol name of the unique

00:15:11,440 --> 00:15:15,839
version of the lambda

00:15:12,959 --> 00:15:17,519
which will explore way more so stay

00:15:15,839 --> 00:15:18,880
tuned

00:15:17,519 --> 00:15:20,720
what about if you pass something which

00:15:18,880 --> 00:15:21,839
we won't compile well we'll get the

00:15:20,720 --> 00:15:23,680
compilation error

00:15:21,839 --> 00:15:25,040
and we'll take a look how to handle

00:15:23,680 --> 00:15:27,839
errors as well but

00:15:25,040 --> 00:15:31,040
this error will actually come from the

00:15:27,839 --> 00:15:31,040
clan compiler itself

00:15:32,720 --> 00:15:36,160
so as pointed out before we can pass the

00:15:35,040 --> 00:15:37,839
lamp test here

00:15:36,160 --> 00:15:39,440
so what about if we actually run the

00:15:37,839 --> 00:15:43,600
lambda

00:15:39,440 --> 00:15:46,800
that will give us a ability to pass

00:15:43,600 --> 00:15:48,320
basically arbitrary code and do magic

00:15:46,800 --> 00:15:50,800
things with that with it

00:15:48,320 --> 00:15:52,639
so here we'll pass a lambda which just

00:15:50,800 --> 00:15:55,920
prints hello world from jit

00:15:52,639 --> 00:15:58,720
and that will be printed with that

00:15:55,920 --> 00:15:58,720
simple function

00:16:00,240 --> 00:16:03,440
we can also leverage the non-type

00:16:02,000 --> 00:16:05,920
template parameters as well

00:16:03,440 --> 00:16:07,600
to just simplify the code a bit but it

00:16:05,920 --> 00:16:09,600
will produce the same thing

00:16:07,600 --> 00:16:11,759
so you can see how exciting is that we

00:16:09,600 --> 00:16:16,000
can actually leverage the

00:16:11,759 --> 00:16:16,000
c plus plus to make a

00:16:16,240 --> 00:16:19,360
c plus modern c plus plus with lambdas

00:16:18,720 --> 00:16:22,079
to

00:16:19,360 --> 00:16:23,040
run basically arbitrary code notice here

00:16:22,079 --> 00:16:25,920
that the

00:16:23,040 --> 00:16:27,279
we cannot do the includes here so

00:16:25,920 --> 00:16:30,720
everything

00:16:27,279 --> 00:16:34,839
like they put the csto

00:16:30,720 --> 00:16:36,160
will have to be included from the host

00:16:34,839 --> 00:16:38,320
site

00:16:36,160 --> 00:16:40,480
so hunting and elders as we pointed out

00:16:38,320 --> 00:16:42,800
before if you pass something which won't

00:16:40,480 --> 00:16:46,000
compile what will happen

00:16:42,800 --> 00:16:48,240
well in this implementation of

00:16:46,000 --> 00:16:49,440
eric langjit we we can just get the

00:16:48,240 --> 00:16:55,360
compilation error

00:16:49,440 --> 00:16:57,199
exception so if you did an anode type

00:16:55,360 --> 00:16:59,279
you'll get a nanotype was not declared

00:16:57,199 --> 00:17:00,240
in this scope because diagnostics will

00:16:59,279 --> 00:17:02,240
be passed

00:17:00,240 --> 00:17:05,839
through the compilation error and will

00:17:02,240 --> 00:17:05,839
be just printed as an exception

00:17:06,959 --> 00:17:10,540
so that's our break for the questions if

00:17:10,000 --> 00:17:13,680
you have

00:17:10,540 --> 00:17:13,680
[Music]

00:17:16,839 --> 00:17:22,640
any

00:17:19,120 --> 00:17:24,640
i so at this point

00:17:22,640 --> 00:17:28,079
if there are no questions it means

00:17:24,640 --> 00:17:29,600
everyone understands exactly how

00:17:28,079 --> 00:17:31,280
how the underlying technology works

00:17:29,600 --> 00:17:34,400
basically well i will take it

00:17:31,280 --> 00:17:38,480
so let's move on

00:17:34,400 --> 00:17:40,400
might be it's either scary or or good

00:17:38,480 --> 00:17:42,240
let's assume it's good and let's move on

00:17:40,400 --> 00:17:46,400
that will give us more time to

00:17:42,240 --> 00:17:48,400
to go through the examples so

00:17:46,400 --> 00:17:50,559
having that in mind we can implement

00:17:48,400 --> 00:17:53,280
some utilities on top of

00:17:50,559 --> 00:17:53,919
this basic gtn function which we had

00:17:53,280 --> 00:17:56,240
already

00:17:53,919 --> 00:17:57,760
so let's take a look into jit compiles

00:17:56,240 --> 00:18:00,880
you can imagine a

00:17:57,760 --> 00:18:02,480
function in which you pass something

00:18:00,880 --> 00:18:05,039
string like

00:18:02,480 --> 00:18:06,640
in that case an expression and you will

00:18:05,039 --> 00:18:08,640
return

00:18:06,640 --> 00:18:11,280
some form of expected let's say std

00:18:08,640 --> 00:18:14,240
expected of some sort

00:18:11,280 --> 00:18:15,520
which will return a compilation error in

00:18:14,240 --> 00:18:20,080
case

00:18:15,520 --> 00:18:22,480
if the compilation and be successful

00:18:20,080 --> 00:18:23,520
so in that case we already know how to

00:18:22,480 --> 00:18:26,480
do it we have

00:18:23,520 --> 00:18:27,039
a try we have a catch of the compilation

00:18:26,480 --> 00:18:30,080
error

00:18:27,039 --> 00:18:32,480
we'll just propagate it to expect it and

00:18:30,080 --> 00:18:34,400
notice here which is really important

00:18:32,480 --> 00:18:35,760
is the fact that the expression which

00:18:34,400 --> 00:18:39,440
was passed as a

00:18:35,760 --> 00:18:39,760
string like thing is being propagated to

00:18:39,440 --> 00:18:42,960
the

00:18:39,760 --> 00:18:44,400
angle bracket digit so we go from run

00:18:42,960 --> 00:18:47,360
time to compile time

00:18:44,400 --> 00:18:49,520
we did it we did that expression if that

00:18:47,360 --> 00:18:52,720
expression doesn't compile

00:18:49,520 --> 00:18:56,640
then we'll just get a

00:18:52,720 --> 00:18:59,760
false so

00:18:56,640 --> 00:19:03,679
imagine that jit compiles

00:18:59,760 --> 00:19:06,400
of the lambda works as expected

00:19:03,679 --> 00:19:07,520
if you pass something which doesn't

00:19:06,400 --> 00:19:10,640
compile

00:19:07,520 --> 00:19:15,200
that will just fail and and we'll just

00:19:10,640 --> 00:19:20,080
fail the asset so we moved it from

00:19:15,200 --> 00:19:22,160
aot to g time and go back to the

00:19:20,080 --> 00:19:24,720
aot time in a sense with the asset as

00:19:22,160 --> 00:19:28,080
well which is the runtime

00:19:24,720 --> 00:19:30,160
but what about if you go further imagine

00:19:28,080 --> 00:19:31,840
that we'll introduce this jit assert

00:19:30,160 --> 00:19:34,640
which will

00:19:31,840 --> 00:19:36,160
where we will pass the expression which

00:19:34,640 --> 00:19:38,000
will try to execute

00:19:36,160 --> 00:19:39,520
and notice here that we'll do the static

00:19:38,000 --> 00:19:42,160
asset in the jitland

00:19:39,520 --> 00:19:42,720
so we move from the run time to compile

00:19:42,160 --> 00:19:46,160
time

00:19:42,720 --> 00:19:49,120
and in this compariton world

00:19:46,160 --> 00:19:49,600
which is the compiled jitland world in a

00:19:49,120 --> 00:19:51,600
sense

00:19:49,600 --> 00:19:53,600
we can do the static asset which is

00:19:51,600 --> 00:19:55,919
super exciting because then

00:19:53,600 --> 00:19:57,280
we can leverage all the performance out

00:19:55,919 --> 00:20:01,760
of it

00:19:57,280 --> 00:20:04,000
so if you pass this expression

00:20:01,760 --> 00:20:04,960
that will you know won't trigger the

00:20:04,000 --> 00:20:08,000
static assert

00:20:04,960 --> 00:20:08,480
as expected and this one on the other

00:20:08,000 --> 00:20:13,360
side

00:20:08,480 --> 00:20:16,559
it will so you can see that

00:20:13,360 --> 00:20:18,320
that's quite powerful way of dealing

00:20:16,559 --> 00:20:20,000
with the compilation things

00:20:18,320 --> 00:20:21,760
yet another thing which we can discuss

00:20:20,000 --> 00:20:24,880
is the fact that

00:20:21,760 --> 00:20:25,679
you know as we as we mentioned with the

00:20:24,880 --> 00:20:28,480
kling

00:20:25,679 --> 00:20:29,840
purple kind of thing you can imagine

00:20:28,480 --> 00:20:31,600
that the meta type which is

00:20:29,840 --> 00:20:33,360
the string here you can imagine the

00:20:31,600 --> 00:20:36,559
future that would be an abstract tree

00:20:33,360 --> 00:20:40,080
instead and you can read about it in

00:20:36,559 --> 00:20:42,480
android saturn the

00:20:40,080 --> 00:20:44,400
proposal about the reflection and the

00:20:42,480 --> 00:20:46,799
linux stuff

00:20:44,400 --> 00:20:47,600
at compile time so let's imagine a

00:20:46,799 --> 00:20:51,760
vector of

00:20:47,600 --> 00:20:56,559
this of this string

00:20:51,760 --> 00:20:56,559
and we'll just push back end and double

00:20:57,120 --> 00:21:04,880
which are you know types but

00:21:00,720 --> 00:21:08,720
in the string line and we'll have some

00:21:04,880 --> 00:21:12,000
join function uh which

00:21:08,720 --> 00:21:15,120
you can imagine which will just join

00:21:12,000 --> 00:21:16,400
the first and last input iterators with

00:21:15,120 --> 00:21:19,840
the f function

00:21:16,400 --> 00:21:21,679
and add the separator at the end

00:21:19,840 --> 00:21:23,200
and what is important here is the fact

00:21:21,679 --> 00:21:27,039
that we can leverage the

00:21:23,200 --> 00:21:30,480
runtime to compile time by just using

00:21:27,039 --> 00:21:32,559
c plus plus manipulation of the

00:21:30,480 --> 00:21:34,640
of the meta which is the string in that

00:21:32,559 --> 00:21:36,880
case and maybe ast in the future which

00:21:34,640 --> 00:21:40,320
means that we can leverage all the

00:21:36,880 --> 00:21:43,360
c plus plus algorithms and as you know

00:21:40,320 --> 00:21:45,679
ben is a algorithm here so

00:21:43,360 --> 00:21:46,640
we can do everything we want with c plus

00:21:45,679 --> 00:21:48,880
plus

00:21:46,640 --> 00:21:49,760
normal c plus plus we can use ranges and

00:21:48,880 --> 00:21:52,640
just produce

00:21:49,760 --> 00:21:54,240
a string version of something and then

00:21:52,640 --> 00:21:55,039
by cheating moving to the compile

00:21:54,240 --> 00:21:58,159
timeland

00:21:55,039 --> 00:21:58,799
with it as this example just to produce

00:21:58,159 --> 00:22:01,360
a tuple

00:21:58,799 --> 00:22:02,640
out of the vector and then do the things

00:22:01,360 --> 00:22:04,480
at compile time

00:22:02,640 --> 00:22:06,000
in the gtlan which is super exciting

00:22:04,480 --> 00:22:09,280
however the strings

00:22:06,000 --> 00:22:12,720
has also negatives and you probably

00:22:09,280 --> 00:22:16,960
have heard of sql injection

00:22:12,720 --> 00:22:20,640
sql injection is a popular attack

00:22:16,960 --> 00:22:24,240
in which you leverage

00:22:20,640 --> 00:22:24,559
the security bridge in which users do

00:22:24,240 --> 00:22:26,880
not

00:22:24,559 --> 00:22:28,000
protect themselves from having a proper

00:22:26,880 --> 00:22:31,120
text for names

00:22:28,000 --> 00:22:33,760
for example so if you pass the name

00:22:31,120 --> 00:22:34,640
and you end the quote and after that you

00:22:33,760 --> 00:22:37,919
do r

00:22:34,640 --> 00:22:38,559
through and the comment you can imagine

00:22:37,919 --> 00:22:41,280
that

00:22:38,559 --> 00:22:42,080
the sql query which will be propagated

00:22:41,280 --> 00:22:44,720
from

00:22:42,080 --> 00:22:45,919
the form will look something like that

00:22:44,720 --> 00:22:49,280
where the name

00:22:45,919 --> 00:22:51,840
will be empty or true and after that

00:22:49,280 --> 00:22:54,080
we'll just

00:22:51,840 --> 00:22:55,440
leverage the comment and that would be a

00:22:54,080 --> 00:22:59,039
valid sql

00:22:55,440 --> 00:23:01,760
which will always allow us to to log in

00:22:59,039 --> 00:23:04,159
well that's exciting right what about

00:23:01,760 --> 00:23:06,400
cvp injection have you heard of that

00:23:04,159 --> 00:23:08,320
that's a concept which actually may

00:23:06,400 --> 00:23:10,799
happen with gtin if you're not careful

00:23:08,320 --> 00:23:11,360
so imagine that case you have a main you

00:23:10,799 --> 00:23:14,880
did a

00:23:11,360 --> 00:23:16,720
c out and get the user from the

00:23:14,880 --> 00:23:18,799
environment variable

00:23:16,720 --> 00:23:21,679
well normal use case right you can you

00:23:18,799 --> 00:23:24,480
can imagine something like that

00:23:21,679 --> 00:23:25,840
what if you pass john well we'll get the

00:23:24,480 --> 00:23:29,679
turn

00:23:25,840 --> 00:23:34,559
what if we'll actually end the quote

00:23:29,679 --> 00:23:36,640
do the system remove the whole file

00:23:34,559 --> 00:23:37,919
uh remove your everything you have on

00:23:36,640 --> 00:23:40,320
your desk and after the

00:23:37,919 --> 00:23:42,080
end the quote well that will be a valid

00:23:40,320 --> 00:23:44,400
c plus plus which is important because

00:23:42,080 --> 00:23:46,480
this code has to compile

00:23:44,400 --> 00:23:48,240
and what will produce it will actually

00:23:46,480 --> 00:23:50,320
print nothing

00:23:48,240 --> 00:23:51,440
then it will remove everything you have

00:23:50,320 --> 00:23:54,080
on the desk

00:23:51,440 --> 00:23:54,880
and after that we'll just have this

00:23:54,080 --> 00:23:58,080
quote

00:23:54,880 --> 00:24:00,880
which will do nothing just to compile it

00:23:58,080 --> 00:24:02,799
so yeah strings have benefits but also

00:24:00,880 --> 00:24:03,679
they have negatives you can also imagine

00:24:02,799 --> 00:24:06,159
that

00:24:03,679 --> 00:24:08,320
being a part of the compilation time if

00:24:06,159 --> 00:24:12,000
you have embed stuff

00:24:08,320 --> 00:24:13,760
you can get crazy here so yeah there are

00:24:12,000 --> 00:24:15,919
worries which you can cons which you

00:24:13,760 --> 00:24:19,760
have to consider with cpp

00:24:15,919 --> 00:24:22,960
as well and if you want to

00:24:19,760 --> 00:24:23,840
dig into more details please take a look

00:24:22,960 --> 00:24:26,880
into

00:24:23,840 --> 00:24:33,679
last year how think i'll talk about

00:24:26,880 --> 00:24:35,440
how it works in details

00:24:33,679 --> 00:24:37,679
so i think perhaps at this point we can

00:24:35,440 --> 00:24:41,520
address a few questions

00:24:37,679 --> 00:24:44,080
uh that that were that people um put in

00:24:41,520 --> 00:24:46,080
uh the first question is what's the

00:24:44,080 --> 00:24:48,960
runtime overhead

00:24:46,080 --> 00:24:50,400
so this is the way i've been thinking

00:24:48,960 --> 00:24:50,720
about this at least in the use cases we

00:24:50,400 --> 00:24:53,600
have

00:24:50,720 --> 00:24:55,200
is as a uh there is some i mean the

00:24:53,600 --> 00:24:56,000
runtime overhead is the overhead of

00:24:55,200 --> 00:24:58,320
compiling c

00:24:56,000 --> 00:24:59,120
plus plus at runtime and so there is as

00:24:58,320 --> 00:25:01,919
you would expect

00:24:59,120 --> 00:25:03,600
some overhead this isn't this isn't yet

00:25:01,919 --> 00:25:05,440
an invisible technology that

00:25:03,600 --> 00:25:06,640
can just take code and move it into

00:25:05,440 --> 00:25:10,080
magical jit land

00:25:06,640 --> 00:25:12,720
seamlessly but rather

00:25:10,080 --> 00:25:14,880
i'm thinking of it as a installation

00:25:12,720 --> 00:25:17,200
time or deployment time or configuration

00:25:14,880 --> 00:25:19,039
time step which your users can apply

00:25:17,200 --> 00:25:20,559
or which you know your internal users or

00:25:19,039 --> 00:25:23,120
yourself can apply

00:25:20,559 --> 00:25:23,760
um so there's some runtime overhead for

00:25:23,120 --> 00:25:26,480
sure

00:25:23,760 --> 00:25:28,480
uh but you know you've got a way that

00:25:26,480 --> 00:25:30,400
again the total

00:25:28,480 --> 00:25:32,720
the total cost of compilation plus

00:25:30,400 --> 00:25:34,640
runtime

00:25:32,720 --> 00:25:36,720
uh the another question can you jit

00:25:34,640 --> 00:25:39,840
within legit

00:25:36,720 --> 00:25:42,559
uh chris i don't think that sure

00:25:39,840 --> 00:25:43,360
so yes potentially you could do that

00:25:42,559 --> 00:25:44,960
however

00:25:43,360 --> 00:25:48,240
the current implementation doesn't allow

00:25:44,960 --> 00:25:49,600
you to do that but you can go meta here

00:25:48,240 --> 00:25:53,120
as you can imagine there's nothing

00:25:49,600 --> 00:25:56,320
stopping from doing us you can jit

00:25:53,120 --> 00:25:58,240
even a different type of code like you

00:25:56,320 --> 00:25:59,919
can get python and after that

00:25:58,240 --> 00:26:01,840
c plus plus if you really want but

00:25:59,919 --> 00:26:03,440
proposal itself doesn't allow that at

00:26:01,840 --> 00:26:05,120
the moment

00:26:03,440 --> 00:26:06,720
and the follow-up is do you have access

00:26:05,120 --> 00:26:07,679
to the global variables yes you have

00:26:06,720 --> 00:26:12,480
access to

00:26:07,679 --> 00:26:12,480
everything in the host as well

00:26:13,120 --> 00:26:16,159
right everything that the the host

00:26:14,799 --> 00:26:17,919
program the ahead of time compiled

00:26:16,159 --> 00:26:20,080
program exposes

00:26:17,919 --> 00:26:22,840
types variables you have access to in

00:26:20,080 --> 00:26:24,320
the jitted code in the environment as

00:26:22,840 --> 00:26:26,320
jitted

00:26:24,320 --> 00:26:28,000
and then the last question we had was is

00:26:26,320 --> 00:26:30,400
it possible to sandbox legit

00:26:28,000 --> 00:26:31,279
so chris showed some sql injection like

00:26:30,400 --> 00:26:33,840
attack

00:26:31,279 --> 00:26:34,960
uh we'll talk a bit more about that uh

00:26:33,840 --> 00:26:36,400
later on

00:26:34,960 --> 00:26:39,279
um i think there are some things we can

00:26:36,400 --> 00:26:41,039
do but you know ultimately you're asking

00:26:39,279 --> 00:26:42,320
if you're shipping this to users and

00:26:41,039 --> 00:26:44,159
with internal users

00:26:42,320 --> 00:26:45,919
you can expect not to attack but if

00:26:44,159 --> 00:26:47,039
you're shipping this to users ultimately

00:26:45,919 --> 00:26:49,919
you are

00:26:47,039 --> 00:26:51,760
allowing them to run c plus plus

00:26:49,919 --> 00:26:54,080
alongside yours and so

00:26:51,760 --> 00:26:55,760
i think any kind of mitigation is

00:26:54,080 --> 00:26:58,080
difficult at the source language level

00:26:55,760 --> 00:26:58,080
at least

00:27:00,240 --> 00:27:04,080
uh we had another question just come in

00:27:02,320 --> 00:27:05,200
how big were the c plus plus programs

00:27:04,080 --> 00:27:06,960
we've tried while working on this

00:27:05,200 --> 00:27:10,799
functionality

00:27:06,960 --> 00:27:13,039
uh fair we've we've tried

00:27:10,799 --> 00:27:14,080
injecting some pretty meaty stuff and

00:27:13,039 --> 00:27:16,240
we'll come to that

00:27:14,080 --> 00:27:18,799
again in a little while as we get more

00:27:16,240 --> 00:27:24,640
into the examples

00:27:18,799 --> 00:27:24,640
so let's move on uh another example here

00:27:25,200 --> 00:27:29,600
so we talked about cling using the jit

00:27:27,760 --> 00:27:31,840
technology it's fairly easy to set up a

00:27:29,600 --> 00:27:33,120
driver program to use c cloud plus as a

00:27:31,840 --> 00:27:35,760
scripting language

00:27:33,120 --> 00:27:37,279
and it looks something like this so here

00:27:35,760 --> 00:27:39,360
we have a function

00:27:37,279 --> 00:27:41,760
which will just take the contents of a

00:27:39,360 --> 00:27:45,679
file

00:27:41,760 --> 00:27:47,919
um let's pass in argv1

00:27:45,679 --> 00:27:49,440
we ignore the first line of the file

00:27:47,919 --> 00:27:50,640
because that's going to be the hashbang

00:27:49,440 --> 00:27:52,960
line

00:27:50,640 --> 00:27:54,720
and we return the string of the rest of

00:27:52,960 --> 00:27:56,880
the file

00:27:54,720 --> 00:27:58,320
and then we take that file contents

00:27:56,880 --> 00:28:01,279
minus the hashbang line

00:27:58,320 --> 00:28:03,279
and we put them in a lambda and we just

00:28:01,279 --> 00:28:06,080
it and execute it

00:28:03,279 --> 00:28:07,760
and that means that whatever you put in

00:28:06,080 --> 00:28:10,240
this file here's a

00:28:07,760 --> 00:28:12,080
notional scripted file and the first

00:28:10,240 --> 00:28:14,840
line is a hash bang which tells it to

00:28:12,080 --> 00:28:17,200
use our c plus plus jit program to run

00:28:14,840 --> 00:28:17,600
it and then we run it on the command

00:28:17,200 --> 00:28:21,440
line

00:28:17,600 --> 00:28:23,919
and it says hello world so

00:28:21,440 --> 00:28:25,279
there we have a sort of very simple c

00:28:23,919 --> 00:28:29,200
plus a scripting language

00:28:25,279 --> 00:28:30,559
using jit of course as chris said

00:28:29,200 --> 00:28:32,960
we still have the issue of what to do

00:28:30,559 --> 00:28:34,720
about includes here the file contents go

00:28:32,960 --> 00:28:36,799
inside a lambda so we can't actually put

00:28:34,720 --> 00:28:39,039
a hash include in our script

00:28:36,799 --> 00:28:40,799
and so maybe modules come to the rescue

00:28:39,039 --> 00:28:42,399
maybe we import the whole of the stl as

00:28:40,799 --> 00:28:44,240
one module

00:28:42,399 --> 00:28:45,520
pre-compiled headers can be can be used

00:28:44,240 --> 00:28:48,240
for a similar effect

00:28:45,520 --> 00:28:49,600
uh but there is fundamentally a sort of

00:28:48,240 --> 00:28:52,480
an issue of what to do about

00:28:49,600 --> 00:28:53,039
uh includes which we'll perhaps get to

00:28:52,480 --> 00:28:55,360
later

00:28:53,039 --> 00:28:55,360
as well

00:28:56,159 --> 00:29:00,240
another thing we can do is mix compile

00:28:58,720 --> 00:29:02,320
time and run time

00:29:00,240 --> 00:29:03,440
uh so we've seen some of this already

00:29:02,320 --> 00:29:05,919
but here's a

00:29:03,440 --> 00:29:06,880
a another example here we have a sort

00:29:05,919 --> 00:29:09,279
function

00:29:06,880 --> 00:29:10,840
and it does it takes some template

00:29:09,279 --> 00:29:12,000
parameters some non-type template

00:29:10,840 --> 00:29:14,640
parameters

00:29:12,000 --> 00:29:15,440
and some runtime parameters and notice

00:29:14,640 --> 00:29:18,000
this we're not

00:29:15,440 --> 00:29:18,559
jitting this yet this is just a function

00:29:18,000 --> 00:29:20,640
which

00:29:18,559 --> 00:29:22,000
uh puts all of its parameters to all of

00:29:20,640 --> 00:29:24,000
its arguments together

00:29:22,000 --> 00:29:26,399
uh to run to both the compile time and

00:29:24,000 --> 00:29:29,440
the runtime sorts them and then

00:29:26,399 --> 00:29:30,880
makes them into an into a string which

00:29:29,440 --> 00:29:31,919
is going to be the array of sorted

00:29:30,880 --> 00:29:33,360
values

00:29:31,919 --> 00:29:36,880
and again we're using the join function

00:29:33,360 --> 00:29:36,880
we we talked about earlier

00:29:37,120 --> 00:29:41,039
so now this kind of thing shows how we

00:29:40,000 --> 00:29:43,840
can

00:29:41,039 --> 00:29:45,440
uh have some the way i think about this

00:29:43,840 --> 00:29:46,320
is you've got some configuration which

00:29:45,440 --> 00:29:49,039
is baked in

00:29:46,320 --> 00:29:49,520
at ahead of time and some configuration

00:29:49,039 --> 00:29:52,399
which

00:29:49,520 --> 00:29:54,240
is provided at this configuration time

00:29:52,399 --> 00:29:56,640
at this deploy time

00:29:54,240 --> 00:29:57,679
by your users and so you can mix it

00:29:56,640 --> 00:29:59,760
together

00:29:57,679 --> 00:30:01,360
and do arbitrary things with it in this

00:29:59,760 --> 00:30:04,640
case the example is

00:30:01,360 --> 00:30:06,480
sorting it note that the sort function

00:30:04,640 --> 00:30:09,120
as chris said earlier is just plain c

00:30:06,480 --> 00:30:12,960
plus plus it's not constant explorer all

00:30:09,120 --> 00:30:12,960
of c plus plus is available to use

00:30:15,600 --> 00:30:20,399
and then here is

00:30:18,640 --> 00:30:22,720
another jit use case i think chris is

00:30:20,399 --> 00:30:25,919
going to explain

00:30:22,720 --> 00:30:28,720
okay thank you ben so let's

00:30:25,919 --> 00:30:29,760
try to move on to maybe some more real

00:30:28,720 --> 00:30:32,399
world example

00:30:29,760 --> 00:30:33,760
how jit can be used to leverage the

00:30:32,399 --> 00:30:35,600
performance

00:30:33,760 --> 00:30:37,200
and user feedback as well because both

00:30:35,600 --> 00:30:39,600
of them are really important and

00:30:37,200 --> 00:30:40,880
both of them can be leveraged by using

00:30:39,600 --> 00:30:43,440
jit

00:30:40,880 --> 00:30:45,600
so you can imagine a function and the

00:30:43,440 --> 00:30:49,120
whole loop

00:30:45,600 --> 00:30:52,080
of it being something like that

00:30:49,120 --> 00:30:52,559
so when we why why is we have the input

00:30:52,080 --> 00:30:53,840
and

00:30:52,559 --> 00:30:56,000
and the input may come from different

00:30:53,840 --> 00:30:56,640
sources let's say if you have the repo

00:30:56,000 --> 00:30:58,720
kind of

00:30:56,640 --> 00:30:59,760
input from the user so you can imagine a

00:30:58,720 --> 00:31:02,159
researcher

00:30:59,760 --> 00:31:03,120
physicist trying to you know like a

00:31:02,159 --> 00:31:06,720
cling

00:31:03,120 --> 00:31:10,960
that adds something to the program

00:31:06,720 --> 00:31:14,080
whilst was you know working on it

00:31:10,960 --> 00:31:17,760
or using an external data which may come

00:31:14,080 --> 00:31:20,240
from a file tcp udp socket

00:31:17,760 --> 00:31:21,600
you know without the ui or without any

00:31:20,240 --> 00:31:24,960
input from the user

00:31:21,600 --> 00:31:27,919
so as long as we will have this input

00:31:24,960 --> 00:31:30,080
we'll process it and we'll do an

00:31:27,919 --> 00:31:33,760
additional step here which will be

00:31:30,080 --> 00:31:35,840
just to collect that data in order to

00:31:33,760 --> 00:31:37,200
leverage it in the further future

00:31:35,840 --> 00:31:40,480
processing

00:31:37,200 --> 00:31:43,600
so that's just additional step

00:31:40,480 --> 00:31:44,720
and then in case if you have an explicit

00:31:43,600 --> 00:31:46,960
trigger from the user

00:31:44,720 --> 00:31:47,919
that would be the rebel case or the

00:31:46,960 --> 00:31:49,919
collected data

00:31:47,919 --> 00:31:51,679
provides some kind of benefit and you

00:31:49,919 --> 00:31:52,480
can you know argue here what the benefit

00:31:51,679 --> 00:31:55,600
is you can use

00:31:52,480 --> 00:31:59,360
ai i guess or anything like that

00:31:55,600 --> 00:32:02,080
to verify where when to to actually

00:31:59,360 --> 00:32:03,120
the data which you get at runtime gives

00:32:02,080 --> 00:32:06,320
you any benefit

00:32:03,120 --> 00:32:08,000
so that you can leverage it and promote

00:32:06,320 --> 00:32:10,640
the runtime data

00:32:08,000 --> 00:32:12,159
to the compile-time data and that's the

00:32:10,640 --> 00:32:13,360
that's the main thing which is about

00:32:12,159 --> 00:32:15,760
gten so you have the

00:32:13,360 --> 00:32:17,600
runtime data which you collected for

00:32:15,760 --> 00:32:20,320
example the values and everything

00:32:17,600 --> 00:32:21,120
from from from the user and after that

00:32:20,320 --> 00:32:24,320
you cheat

00:32:21,120 --> 00:32:25,600
and you jit you you see the the the

00:32:24,320 --> 00:32:29,600
strings here

00:32:25,600 --> 00:32:32,000
being promoted to the types

00:32:29,600 --> 00:32:33,039
and this way we can leverage the

00:32:32,000 --> 00:32:35,200
performance

00:32:33,039 --> 00:32:36,080
of of gtm because we'll be in the jit

00:32:35,200 --> 00:32:37,919
land which

00:32:36,080 --> 00:32:39,519
will have types and will be the

00:32:37,919 --> 00:32:41,519
compile-time version of it

00:32:39,519 --> 00:32:43,519
optionally which is a super exciting

00:32:41,519 --> 00:32:46,640
feature in my opinion is the fact that

00:32:43,519 --> 00:32:48,240
since we did something we have the ir

00:32:46,640 --> 00:32:51,519
in intermediate representation the

00:32:48,240 --> 00:32:54,000
binary basically assembly everything

00:32:51,519 --> 00:32:56,320
already there it's in the clan compiler

00:32:54,000 --> 00:32:58,240
which is part of our application

00:32:56,320 --> 00:32:59,519
so we can actually just save it for free

00:32:58,240 --> 00:33:02,960
there's nothing

00:32:59,519 --> 00:33:04,480
uh which we have to do in order to

00:33:02,960 --> 00:33:07,200
not to save it for example if you want

00:33:04,480 --> 00:33:09,600
it so that will allow us to produce a

00:33:07,200 --> 00:33:10,399
very optimized binaries which can be

00:33:09,600 --> 00:33:13,840
leveraged

00:33:10,399 --> 00:33:16,159
in the future without all these loops so

00:33:13,840 --> 00:33:17,440
so imagine that you know the researchers

00:33:16,159 --> 00:33:19,039
have finished some

00:33:17,440 --> 00:33:20,720
experiments and they just want to save a

00:33:19,039 --> 00:33:23,679
binary and release that one

00:33:20,720 --> 00:33:24,159
or you find out with the eye that oh my

00:33:23,679 --> 00:33:26,640
gosh

00:33:24,159 --> 00:33:28,159
that's that's the thing let me just

00:33:26,640 --> 00:33:31,200
produce a binary for that

00:33:28,159 --> 00:33:34,640
so that they can use it later

00:33:31,200 --> 00:33:37,279
so let's move on to

00:33:34,640 --> 00:33:38,080
show how we can actually do that with

00:33:37,279 --> 00:33:41,120
the

00:33:38,080 --> 00:33:43,360
few examples of

00:33:41,120 --> 00:33:44,880
of dispatching compile time dispatching

00:33:43,360 --> 00:33:46,320
and runtime dispatching

00:33:44,880 --> 00:33:48,320
it's very often the case that we want to

00:33:46,320 --> 00:33:50,240
dispatch something and uh

00:33:48,320 --> 00:33:51,600
and the message flow is then you know

00:33:50,240 --> 00:33:52,080
most of the applications kind of

00:33:51,600 --> 00:33:54,320
leverage

00:33:52,080 --> 00:33:55,840
that part so i feel like that would be a

00:33:54,320 --> 00:33:58,799
good example to

00:33:55,840 --> 00:34:00,640
to show so let's imagine that we have a

00:33:58,799 --> 00:34:03,200
handlers which

00:34:00,640 --> 00:34:03,760
are called and full and bar and just

00:34:03,200 --> 00:34:06,799
print

00:34:03,760 --> 00:34:07,120
full and bar based on the event if

00:34:06,799 --> 00:34:09,359
they're

00:34:07,120 --> 00:34:10,320
on call and then we have three different

00:34:09,359 --> 00:34:14,320
types of events

00:34:10,320 --> 00:34:14,320
e1 e2 and then e3

00:34:14,800 --> 00:34:18,240
and that's the exciting part we have the

00:34:16,399 --> 00:34:21,839
mappings which can be extended at

00:34:18,240 --> 00:34:24,960
runtime but let's start with another map

00:34:21,839 --> 00:34:28,800
which is also a runtime version of it

00:34:24,960 --> 00:34:31,760
we have e1 which is the handler and foo

00:34:28,800 --> 00:34:33,599
which is the event and we'll go to the

00:34:31,760 --> 00:34:36,320
full which will be the handler and

00:34:33,599 --> 00:34:37,919
at the same for the a2 and bar and after

00:34:36,320 --> 00:34:41,040
that you can imagine you can insert

00:34:37,919 --> 00:34:43,040
new things using repo kind of thing or

00:34:41,040 --> 00:34:44,800
when the data comes and you decided to

00:34:43,040 --> 00:34:46,639
do things

00:34:44,800 --> 00:34:49,440
and collect that data you can extend

00:34:46,639 --> 00:34:53,919
that map

00:34:49,440 --> 00:34:56,720
so if we have this mapping

00:34:53,919 --> 00:34:57,920
we can create a dispatcher and we can

00:34:56,720 --> 00:34:59,280
actually create a compile time

00:34:57,920 --> 00:35:02,640
dispatcher here

00:34:59,280 --> 00:35:06,160
if you're familiar with both mp11

00:35:02,640 --> 00:35:07,920
you'll be probably happy to see that

00:35:06,160 --> 00:35:09,359
if you're not i really encourage you

00:35:07,920 --> 00:35:12,160
because it's a great library

00:35:09,359 --> 00:35:13,280
and it gives us a lot of performance out

00:35:12,160 --> 00:35:16,480
of the box

00:35:13,280 --> 00:35:16,960
so you can imagine here that we produce

00:35:16,480 --> 00:35:19,520
a

00:35:16,960 --> 00:35:21,119
compiler map here from the runtime map

00:35:19,520 --> 00:35:22,160
so we had another map which is the

00:35:21,119 --> 00:35:24,800
mappings

00:35:22,160 --> 00:35:26,400
we leverage this join function again we

00:35:24,800 --> 00:35:29,520
get the event at the handler

00:35:26,400 --> 00:35:30,160
and produce a list type list kind of

00:35:29,520 --> 00:35:34,400
thing of

00:35:30,160 --> 00:35:34,400
pairs of event and a handler

00:35:34,720 --> 00:35:38,160
and after that i noticed that that

00:35:36,720 --> 00:35:40,320
wasn't a

00:35:38,160 --> 00:35:41,520
adjective function it was just just a

00:35:40,320 --> 00:35:43,359
normal function

00:35:41,520 --> 00:35:44,960
produced into those strings as band

00:35:43,359 --> 00:35:46,800
pointed out before

00:35:44,960 --> 00:35:48,240
and after that we have a dispatch which

00:35:46,800 --> 00:35:50,240
is a clanged it function

00:35:48,240 --> 00:35:52,079
so the dispatcher will come from that

00:35:50,240 --> 00:35:53,359
string and an event will come from the

00:35:52,079 --> 00:35:55,440
host

00:35:53,359 --> 00:35:56,560
and all we do here will just map find it

00:35:55,440 --> 00:35:58,640
just

00:35:56,560 --> 00:36:01,200
which will return a handler for a given

00:35:58,640 --> 00:36:03,599
event or void otherwise

00:36:01,200 --> 00:36:06,000
and then just call on with given an

00:36:03,599 --> 00:36:06,000
event

00:36:07,119 --> 00:36:10,800
i hope that makes sense so what will

00:36:08,960 --> 00:36:13,440
happen when we call dispatch

00:36:10,800 --> 00:36:15,359
so make this pattern will produce this

00:36:13,440 --> 00:36:18,000
compile-time mapping

00:36:15,359 --> 00:36:20,720
and then the e1 which would be the event

00:36:18,000 --> 00:36:23,119
which will try to find the mapping for

00:36:20,720 --> 00:36:25,200
if we call it with e1 our mapping will

00:36:23,119 --> 00:36:27,680
say that's full

00:36:25,200 --> 00:36:28,960
and we'll print and we'll call on on the

00:36:27,680 --> 00:36:32,720
handler

00:36:28,960 --> 00:36:34,960
which will print the foo and will be the

00:36:32,720 --> 00:36:36,320
assembly that's the you know performance

00:36:34,960 --> 00:36:39,359
part of it

00:36:36,320 --> 00:36:42,640
it will actually be just the move

00:36:39,359 --> 00:36:44,800
to the move full into the

00:36:42,640 --> 00:36:45,760
register and call the push function

00:36:44,800 --> 00:36:47,760
that's all

00:36:45,760 --> 00:36:49,680
as always which has to be done so it's

00:36:47,760 --> 00:36:52,560
like super efficient

00:36:49,680 --> 00:36:54,960
uh well can't be moderate cannot be even

00:36:52,560 --> 00:36:58,400
more efficient right

00:36:54,960 --> 00:37:02,160
what about e2 it will call the bar

00:36:58,400 --> 00:37:02,720
as expected so so so that's a way of

00:37:02,160 --> 00:37:05,680
getting

00:37:02,720 --> 00:37:07,280
compile time dispatch using the runtime

00:37:05,680 --> 00:37:09,839
information from the gten

00:37:07,280 --> 00:37:10,400
when you're ready for it what about if

00:37:09,839 --> 00:37:14,800
you call

00:37:10,400 --> 00:37:17,680
e3 well this map fine

00:37:14,800 --> 00:37:18,480
won't be able to call to call it uh to

00:37:17,680 --> 00:37:20,720
find it

00:37:18,480 --> 00:37:23,599
and the four would return a void and

00:37:20,720 --> 00:37:27,599
we'll get this runtime compilation error

00:37:23,599 --> 00:37:29,359
so like just in time a compilation error

00:37:27,599 --> 00:37:31,200
because it has no members so that's

00:37:29,359 --> 00:37:32,000
where you have to be careful about as

00:37:31,200 --> 00:37:34,720
well

00:37:32,000 --> 00:37:36,079
which you can get the compilation errors

00:37:34,720 --> 00:37:39,760
actually at runtime

00:37:36,079 --> 00:37:39,760
not ahead of time

00:37:39,920 --> 00:37:43,200
you can also call it with unknown event

00:37:42,320 --> 00:37:44,800
and

00:37:43,200 --> 00:37:46,720
that will be a compilation error that

00:37:44,800 --> 00:37:48,880
won't be a runtime compilation error in

00:37:46,720 --> 00:37:51,359
essence

00:37:48,880 --> 00:37:53,520
because the e4 is not known from the

00:37:51,359 --> 00:37:55,599
host

00:37:53,520 --> 00:37:57,119
so okay but compile time this part is

00:37:55,599 --> 00:38:00,240
not always possible sometimes

00:37:57,119 --> 00:38:01,920
the input data is totally

00:38:00,240 --> 00:38:03,680
runtime you can imagine the socket you

00:38:01,920 --> 00:38:06,240
don't know what it is you do have just

00:38:03,680 --> 00:38:09,040
some definition of the protocol you need

00:38:06,240 --> 00:38:11,280
to parse it or whatever

00:38:09,040 --> 00:38:12,720
so let's try to make that happen with

00:38:11,280 --> 00:38:15,760
the runtime dispatch

00:38:12,720 --> 00:38:17,040
so for the simplification we won't use

00:38:15,760 --> 00:38:20,480
type trade or anything like that

00:38:17,040 --> 00:38:22,880
let's say we have just events with ids

00:38:20,480 --> 00:38:25,760
and this runtime ids will be

00:38:22,880 --> 00:38:28,160
corresponding to those events

00:38:25,760 --> 00:38:29,760
then we'll just make this patcher as

00:38:28,160 --> 00:38:33,520
before

00:38:29,760 --> 00:38:35,200
but instead of boost producing the type

00:38:33,520 --> 00:38:37,520
list we'll just produce a

00:38:35,200 --> 00:38:38,800
switch we can actually generate the

00:38:37,520 --> 00:38:41,440
switch statement

00:38:38,800 --> 00:38:41,920
within the lambda which will take the an

00:38:41,440 --> 00:38:44,400
id

00:38:41,920 --> 00:38:45,040
runtime id and in default case we'll

00:38:44,400 --> 00:38:47,200
answer it

00:38:45,040 --> 00:38:49,359
and in other cases we'll just do the

00:38:47,200 --> 00:38:52,880
case on the id

00:38:49,359 --> 00:38:54,320
and call the handler on you see the

00:38:52,880 --> 00:38:58,400
string manipulation here

00:38:54,320 --> 00:39:01,280
just to produce the switch code

00:38:58,400 --> 00:39:02,320
correctly but the final result will be

00:39:01,280 --> 00:39:05,040
that the case

00:39:02,320 --> 00:39:06,480
of the handler which are provided by the

00:39:05,040 --> 00:39:08,640
mapping which are there

00:39:06,480 --> 00:39:11,520
another map and we'll call it with the

00:39:08,640 --> 00:39:14,320
event and it will just break

00:39:11,520 --> 00:39:16,000
what is also kind of interesting is the

00:39:14,320 --> 00:39:17,839
fact that we can leverage

00:39:16,000 --> 00:39:19,760
like c plus plus 1 attributes here like

00:39:17,839 --> 00:39:22,560
likely unlikely

00:39:19,760 --> 00:39:24,079
based on runtime data so that will be

00:39:22,560 --> 00:39:26,240
that might be exciting to

00:39:24,079 --> 00:39:28,160
you know kind of the pgo profile guided

00:39:26,240 --> 00:39:31,359
optimization and runtime and

00:39:28,160 --> 00:39:34,560
will leverage those attributes to

00:39:31,359 --> 00:39:37,359
to speed up things on top of that so i

00:39:34,560 --> 00:39:39,040
hope that makes sense

00:39:37,359 --> 00:39:41,520
so what about if you have this dispatch

00:39:39,040 --> 00:39:44,079
function which will

00:39:41,520 --> 00:39:46,720
take the lambda and we'll call it with

00:39:44,079 --> 00:39:49,119
the runtime id so notice here that the

00:39:46,720 --> 00:39:50,240
id is being passed from the this from

00:39:49,119 --> 00:39:54,000
from the outside as an

00:39:50,240 --> 00:39:55,920
end if we call it with 1 we'll get full

00:39:54,000 --> 00:39:58,640
if we call it with that two we'll get

00:39:55,920 --> 00:40:00,240
bar as as before as expected

00:39:58,640 --> 00:40:04,079
if we call it with zero we'll get the

00:40:00,240 --> 00:40:06,800
assertion that's the default case

00:40:04,079 --> 00:40:08,480
nothing is special it works as expected

00:40:06,800 --> 00:40:12,319
produce the switch case at

00:40:08,480 --> 00:40:16,319
g time so moving on

00:40:12,319 --> 00:40:19,520
so that was kind of exciting we moved to

00:40:16,319 --> 00:40:21,200
g time and com you know leverage the

00:40:19,520 --> 00:40:25,280
runtime information to make it

00:40:21,200 --> 00:40:26,720
much faster i mentioned that before that

00:40:25,280 --> 00:40:29,119
what is super exciting is the fact that

00:40:26,720 --> 00:40:32,079
we already have all this uh

00:40:29,119 --> 00:40:33,359
compiled function in the memory so we

00:40:32,079 --> 00:40:37,200
can actually leverage it

00:40:33,359 --> 00:40:40,000
and save it so let's imagine that

00:40:37,200 --> 00:40:41,040
the g attribute for our dispatch

00:40:40,000 --> 00:40:44,480
function

00:40:41,040 --> 00:40:47,040
will have these additional flags

00:40:44,480 --> 00:40:48,640
because we would like to for example

00:40:47,040 --> 00:40:52,319
make it as fast as possible

00:40:48,640 --> 00:40:54,720
we'll do all three or nine

00:40:52,319 --> 00:40:55,760
if you listen to the to the keynote we

00:40:54,720 --> 00:40:59,119
then debug

00:40:55,760 --> 00:41:02,000
and and we'll just try to produce the

00:40:59,119 --> 00:41:02,560
intermediate representation uh which is

00:41:02,000 --> 00:41:04,880
ir

00:41:02,560 --> 00:41:08,160
here because we're using clang so it

00:41:04,880 --> 00:41:10,480
will be in the clunk terms

00:41:08,160 --> 00:41:11,440
by default the flags will be propagated

00:41:10,480 --> 00:41:14,319
from the host so

00:41:11,440 --> 00:41:15,119
maybe host wasn't built with that and

00:41:14,319 --> 00:41:17,040
debug

00:41:15,119 --> 00:41:18,800
because we didn't we didn't get an

00:41:17,040 --> 00:41:21,440
asterisk here

00:41:18,800 --> 00:41:22,319
and the dispatch function will takes an

00:41:21,440 --> 00:41:25,040
id

00:41:22,319 --> 00:41:26,000
and notice here that the mangled version

00:41:25,040 --> 00:41:28,240
of that function

00:41:26,000 --> 00:41:30,319
won't take any templates so the clang

00:41:28,240 --> 00:41:31,440
jit will remove the template part of it

00:41:30,319 --> 00:41:35,359
because it will be

00:41:31,440 --> 00:41:38,319
moved from the template to the ir

00:41:35,359 --> 00:41:39,040
so everything will be inlined in the ir

00:41:38,319 --> 00:41:41,920
so we don't

00:41:39,040 --> 00:41:42,800
need the the types for the templates

00:41:41,920 --> 00:41:45,920
anymore

00:41:42,800 --> 00:41:48,640
and therefore we can we can easily

00:41:45,920 --> 00:41:51,520
just remove them from the mango name and

00:41:48,640 --> 00:41:55,359
just call the dispatch

00:41:51,520 --> 00:41:58,720
so if you dispatch with the mappings

00:41:55,359 --> 00:42:00,400
and one that will produce full as before

00:41:58,720 --> 00:42:02,720
but it also

00:42:00,400 --> 00:42:04,000
will produce this intermediate

00:42:02,720 --> 00:42:06,480
representation file

00:42:04,000 --> 00:42:07,520
on the disk we can also take the point

00:42:06,480 --> 00:42:10,319
of that function

00:42:07,520 --> 00:42:12,240
and that will produce the ir information

00:42:10,319 --> 00:42:17,119
without

00:42:12,240 --> 00:42:20,160
really dealing with the with running it

00:42:17,119 --> 00:42:23,599
so imagine we have a main function

00:42:20,160 --> 00:42:24,160
which just you know kind of extended

00:42:23,599 --> 00:42:27,280
function

00:42:24,160 --> 00:42:29,920
and just a simple

00:42:27,280 --> 00:42:30,319
dispatch with the end as i pointed out

00:42:29,920 --> 00:42:32,480
the

00:42:30,319 --> 00:42:34,000
just a second ago we don't need to pass

00:42:32,480 --> 00:42:36,240
the templates anymore because the

00:42:34,000 --> 00:42:40,000
mangled name was removed by the

00:42:36,240 --> 00:42:44,800
clank jit attribute when we saved it

00:42:40,000 --> 00:42:48,079
so it's just avoid dispatch and end

00:42:44,800 --> 00:42:51,359
and then we can leverage the

00:42:48,079 --> 00:42:54,319
command line argument to illustrate that

00:42:51,359 --> 00:42:55,680
we can take the runtime value of the

00:42:54,319 --> 00:42:57,359
first argument

00:42:55,680 --> 00:42:58,880
so you can imagine that our loop that

00:42:57,359 --> 00:43:01,920
would be somewhere

00:42:58,880 --> 00:43:01,920
where we were gtin

00:43:02,480 --> 00:43:09,119
then we will use llvm static compiler

00:43:05,680 --> 00:43:11,680
to produce a binary out of

00:43:09,119 --> 00:43:13,119
this ir which takes basically no no no

00:43:11,680 --> 00:43:15,680
time

00:43:13,119 --> 00:43:17,040
it's a very simple one-to-one

00:43:15,680 --> 00:43:20,560
translation

00:43:17,040 --> 00:43:21,200
and then we'll compile it you with our

00:43:20,560 --> 00:43:23,200
main

00:43:21,200 --> 00:43:24,839
and notice here that we don't have to

00:43:23,200 --> 00:43:27,760
pass the jit flag

00:43:24,839 --> 00:43:29,440
anymore that will produce

00:43:27,760 --> 00:43:32,480
the optimized version of that binary

00:43:29,440 --> 00:43:34,160
which will be just one megabyte

00:43:32,480 --> 00:43:36,640
because there is no compiler included

00:43:34,160 --> 00:43:39,200
into it and you can find this

00:43:36,640 --> 00:43:41,680
dispatch symbol in the list of symbols

00:43:39,200 --> 00:43:44,400
from the object files as well

00:43:41,680 --> 00:43:46,000
so what will happen if this pad 1 will

00:43:44,400 --> 00:43:49,280
get full

00:43:46,000 --> 00:43:51,680
if he dispatch 2 will get bar

00:43:49,280 --> 00:43:53,440
if he dispatch 0 nothing will happen

00:43:51,680 --> 00:43:55,839
because that was

00:43:53,440 --> 00:43:56,880
an assertion and a session was removed

00:43:55,839 --> 00:44:00,870
by the

00:43:56,880 --> 00:44:02,079
nd bug staff and the produced

00:44:00,870 --> 00:44:05,359
[Music]

00:44:02,079 --> 00:44:08,240
assembly will be very optimized switch

00:44:05,359 --> 00:44:10,960
case basically with a few jumps and few

00:44:08,240 --> 00:44:10,960
comparisons

00:44:11,119 --> 00:44:14,480
as switch would do so there is nothing

00:44:13,280 --> 00:44:17,760
related to the

00:44:14,480 --> 00:44:21,359
unordered map or anything which host

00:44:17,760 --> 00:44:24,319
had and it wasn't really used by the

00:44:21,359 --> 00:44:25,520
fact when we cheat after the cheating in

00:44:24,319 --> 00:44:27,440
the jitterland so

00:44:25,520 --> 00:44:28,640
so in a sense let me rephrase that

00:44:27,440 --> 00:44:30,960
everything is

00:44:28,640 --> 00:44:32,000
here in the main it's just a part of the

00:44:30,960 --> 00:44:34,720
cheated function

00:44:32,000 --> 00:44:36,079
and everything was required by the

00:44:34,720 --> 00:44:40,040
jitland in a sense

00:44:36,079 --> 00:44:41,599
nothing else so i hope that makes sense

00:44:40,040 --> 00:44:43,920
[Music]

00:44:41,599 --> 00:44:46,880
and i hope that's exciting for you as

00:44:43,920 --> 00:44:46,880
much as for us

00:44:47,839 --> 00:44:51,520
so we have a few more questions someone

00:44:50,400 --> 00:44:53,280
said

00:44:51,520 --> 00:44:54,960
because of the complexity of c plus plus

00:44:53,280 --> 00:44:56,720
that we see in the compiler side do you

00:44:54,960 --> 00:44:59,119
think is a better idea to jit some

00:44:56,720 --> 00:45:01,440
simpler language

00:44:59,119 --> 00:45:02,319
uh presumably meaning a language with an

00:45:01,440 --> 00:45:05,839
llvm

00:45:02,319 --> 00:45:08,160
back-end i'm not not quite sure how that

00:45:05,839 --> 00:45:09,599
would work

00:45:08,160 --> 00:45:11,839
potentially you could do that you

00:45:09,599 --> 00:45:19,839
potentially you could uh the

00:45:11,839 --> 00:45:19,839
python at all you you could do that

00:45:21,359 --> 00:45:28,000
um does this allow for something like

00:45:24,400 --> 00:45:30,400
lazy constant initialization

00:45:28,000 --> 00:45:32,160
i would believe that uh yes i think so i

00:45:30,400 --> 00:45:36,000
think that's a good description of what

00:45:32,160 --> 00:45:39,839
gta is actually doing it because it is a

00:45:36,000 --> 00:45:43,839
constant lazy by default in a sense

00:45:39,839 --> 00:45:43,839
if you look at it like that

00:45:44,319 --> 00:45:49,040
yeah someone says does jitting a

00:45:47,119 --> 00:45:51,520
function on the host side make it easier

00:45:49,040 --> 00:45:54,400
to reverse engineer it

00:45:51,520 --> 00:45:55,680
uh i don't think it makes it easier or

00:45:54,400 --> 00:45:57,680
harder because the

00:45:55,680 --> 00:46:00,400
it's basically the same compiler on the

00:45:57,680 --> 00:46:02,400
whole side as on the jit side

00:46:00,400 --> 00:46:03,760
yes i agree would you say that same

00:46:02,400 --> 00:46:05,520
thing chris

00:46:03,760 --> 00:46:07,359
it's it's basically identical it's c

00:46:05,520 --> 00:46:08,319
plus plus being compiled with the same

00:46:07,359 --> 00:46:10,160
compiler

00:46:08,319 --> 00:46:11,520
maybe different flags so yeah you can

00:46:10,160 --> 00:46:14,240
imagine of crazy

00:46:11,520 --> 00:46:15,920
examples when you get a function with

00:46:14,240 --> 00:46:17,760
different flags and after that

00:46:15,920 --> 00:46:19,200
they never function with different flags

00:46:17,760 --> 00:46:20,960
uh try to

00:46:19,200 --> 00:46:22,800
use that together and they are like

00:46:20,960 --> 00:46:24,000
totally meta crazy examples which you

00:46:22,800 --> 00:46:29,839
can think of

00:46:24,000 --> 00:46:29,839
which you will not get into

00:46:30,800 --> 00:46:33,920
uh someone else says is there a way to

00:46:32,480 --> 00:46:35,520
indicate when you're done with all jit

00:46:33,920 --> 00:46:38,079
so that any overhead might be removed

00:46:35,520 --> 00:46:41,520
from the executable at that time

00:46:38,079 --> 00:46:44,000
well it's more a case really that um

00:46:41,520 --> 00:46:45,520
you you can produce a jitted executable

00:46:44,000 --> 00:46:47,760
with as chris showed

00:46:45,520 --> 00:46:48,800
which no longer has the compiler inside

00:46:47,760 --> 00:46:51,599
it

00:46:48,800 --> 00:46:53,119
uh while if you still want to jit you

00:46:51,599 --> 00:46:54,000
still fundamentally need the compiler

00:46:53,119 --> 00:46:55,760
but this

00:46:54,000 --> 00:46:57,280
this production of a jitted executable

00:46:55,760 --> 00:46:59,040
is kind of this

00:46:57,280 --> 00:47:00,319
it's not it's not really runtime it's

00:46:59,040 --> 00:47:02,640
not really compile time it's more

00:47:00,319 --> 00:47:03,440
configuration time or deployment time as

00:47:02,640 --> 00:47:06,640
i've been

00:47:03,440 --> 00:47:07,920
as i've mentioned right for me right and

00:47:06,640 --> 00:47:09,119
and the beauty of it is the fact that

00:47:07,920 --> 00:47:11,280
you can

00:47:09,119 --> 00:47:13,440
move promote things from runtime to go

00:47:11,280 --> 00:47:14,880
down as much as you want so it might be

00:47:13,440 --> 00:47:16,880
fully compile time if you know

00:47:14,880 --> 00:47:19,359
everything ahead of time

00:47:16,880 --> 00:47:20,240
for the jit time or you can just compile

00:47:19,359 --> 00:47:21,680
like 50

00:47:20,240 --> 00:47:24,000
of it and everything else would be

00:47:21,680 --> 00:47:27,359
runtime so you have all the

00:47:24,000 --> 00:47:29,119
uh all the pyro here right

00:47:27,359 --> 00:47:30,559
uh i think we're going to push on and

00:47:29,119 --> 00:47:32,960
we'll take other questions at the end

00:47:30,559 --> 00:47:32,960
perhaps

00:47:33,280 --> 00:47:39,359
so um i want to talk a bit about

00:47:37,119 --> 00:47:41,440
jitting and do things interplay with

00:47:39,359 --> 00:47:44,480
concepts because this is where i think

00:47:41,440 --> 00:47:45,280
it really shines so here we have a

00:47:44,480 --> 00:47:46,640
concept

00:47:45,280 --> 00:47:49,040
i mean it's not a particularly good

00:47:46,640 --> 00:47:51,839
concept it's for exposition only

00:47:49,040 --> 00:47:53,599
but this is saying uh it's a concept on

00:47:51,839 --> 00:47:55,040
an i o type and it's saying you are a

00:47:53,599 --> 00:47:56,800
readable i o

00:47:55,040 --> 00:47:58,640
if you have an i o dot read if you have

00:47:56,800 --> 00:48:01,119
a read function which takes a

00:47:58,640 --> 00:48:02,160
a by character buffer a a byte pointer

00:48:01,119 --> 00:48:05,760
buffer

00:48:02,160 --> 00:48:08,319
and a size t size and you return

00:48:05,760 --> 00:48:09,680
a size t and stood same as is one of the

00:48:08,319 --> 00:48:12,800
standard concepts with c

00:48:09,680 --> 00:48:15,119
plus 20. so given that concept on a

00:48:12,800 --> 00:48:17,200
on an i o type here is a type that

00:48:15,119 --> 00:48:19,200
fulfills that concept

00:48:17,200 --> 00:48:21,280
and here is a type that does not fulfill

00:48:19,200 --> 00:48:25,040
the concept

00:48:21,280 --> 00:48:29,119
so okay that's just concept 101

00:48:25,040 --> 00:48:31,599
um how does jit play into this well

00:48:29,119 --> 00:48:34,240
we can use jit to check the concept at

00:48:31,599 --> 00:48:35,760
the point where we load the user code

00:48:34,240 --> 00:48:37,359
and the nice thing here is it doesn't

00:48:35,760 --> 00:48:40,960
have to incur the full cost

00:48:37,359 --> 00:48:42,480
of optimized compilation we can just

00:48:40,960 --> 00:48:44,880
at the point where the user gives us

00:48:42,480 --> 00:48:46,240
their code or the when i say the user of

00:48:44,880 --> 00:48:47,760
course is usually the

00:48:46,240 --> 00:48:49,280
colleague at the point where the

00:48:47,760 --> 00:48:50,720
colleague tries to load the code into

00:48:49,280 --> 00:48:54,240
the jitting system

00:48:50,720 --> 00:48:56,400
they get a nice error message uh and uh

00:48:54,240 --> 00:48:57,839
and that's good so there's a

00:48:56,400 --> 00:49:00,640
concept-shaped hole

00:48:57,839 --> 00:49:01,839
in our library and you've you're trying

00:49:00,640 --> 00:49:03,359
to jit something which fills that

00:49:01,839 --> 00:49:06,079
concept shape hole

00:49:03,359 --> 00:49:07,839
that's the idea here um of course the

00:49:06,079 --> 00:49:09,599
question remains

00:49:07,839 --> 00:49:12,800
how do we produce this well-formed

00:49:09,599 --> 00:49:15,280
string i gladly put on the slide here

00:49:12,800 --> 00:49:16,400
this string of and it contains the

00:49:15,280 --> 00:49:18,079
structure names

00:49:16,400 --> 00:49:20,079
of my readable i o but that structure

00:49:18,079 --> 00:49:21,920
name is something that's inside

00:49:20,079 --> 00:49:24,000
a string of c plus plus source code

00:49:21,920 --> 00:49:26,079
which the user's given us

00:49:24,000 --> 00:49:27,760
uh so we don't want to be parsing out

00:49:26,079 --> 00:49:29,599
structure names and things like that

00:49:27,760 --> 00:49:33,359
so we somehow have to figure that out if

00:49:29,599 --> 00:49:36,079
the user code is passed to us at runtime

00:49:33,359 --> 00:49:37,760
so one way to do that is as we've seen

00:49:36,079 --> 00:49:41,200
to wrap it inside a lambda

00:49:37,760 --> 00:49:43,119
now we could require that our users

00:49:41,200 --> 00:49:44,559
wrap all their structures that the types

00:49:43,119 --> 00:49:45,680
are going to pass in inside lambda in

00:49:44,559 --> 00:49:47,520
this way

00:49:45,680 --> 00:49:49,040
and they know the name so that's fine

00:49:47,520 --> 00:49:50,480
and we'll declare type it and we'll get

00:49:49,040 --> 00:49:52,720
the type of the thing out

00:49:50,480 --> 00:49:54,960
and this works it's sort of onerous on

00:49:52,720 --> 00:49:58,000
our users what we want them to write

00:49:54,960 --> 00:49:59,200
is this where they just give us a type

00:49:58,000 --> 00:50:01,359
as they would normally give it and they

00:49:59,200 --> 00:50:01,920
don't have to deal with the noise of the

00:50:01,359 --> 00:50:04,640
lambda

00:50:01,920 --> 00:50:04,640
and the decal type

00:50:05,359 --> 00:50:11,040
now what we can do to make that easier

00:50:09,359 --> 00:50:14,720
perhaps

00:50:11,040 --> 00:50:17,040
is allow them to do that and then

00:50:14,720 --> 00:50:18,880
create a lambda which will basically do

00:50:17,040 --> 00:50:21,920
as if they had done that

00:50:18,880 --> 00:50:24,800
um so what we're doing here is creating

00:50:21,920 --> 00:50:29,280
a string of a lambda

00:50:24,800 --> 00:50:32,800
and the uh the lambda is going to return

00:50:29,280 --> 00:50:36,000
the decal type of a lambda

00:50:32,800 --> 00:50:36,000
uh immediately invoked

00:50:36,319 --> 00:50:40,559
and inside that lambda all we're going

00:50:38,720 --> 00:50:41,839
to do is a using declaration for the

00:50:40,559 --> 00:50:44,960
type that was passed in

00:50:41,839 --> 00:50:47,040
and then return that type and one of the

00:50:44,960 --> 00:50:49,200
assumptions here is that we can

00:50:47,040 --> 00:50:50,800
default construct it maybe there are

00:50:49,200 --> 00:50:53,520
ways that we could get around that com

00:50:50,800 --> 00:50:54,000
that assumption but for the point of the

00:50:53,520 --> 00:50:56,400
purposes

00:50:54,000 --> 00:50:57,760
of this talk we're gonna assume to full

00:50:56,400 --> 00:51:00,559
construction

00:50:57,760 --> 00:51:01,680
um so so this is a bit nicer for users

00:51:00,559 --> 00:51:03,280
it does

00:51:01,680 --> 00:51:04,960
still have some limitations on what they

00:51:03,280 --> 00:51:08,000
can do as we saw before

00:51:04,960 --> 00:51:10,160
includes are an issue

00:51:08,000 --> 00:51:12,559
because ultimately all of what the user

00:51:10,160 --> 00:51:14,960
writes is going inside the lambda

00:51:12,559 --> 00:51:16,480
so there are a couple of limitations one

00:51:14,960 --> 00:51:17,760
is included we mentioned and we can sort

00:51:16,480 --> 00:51:19,280
of get around that with modules or

00:51:17,760 --> 00:51:20,720
pre-compiled headers or making the host

00:51:19,280 --> 00:51:24,720
environment available

00:51:20,720 --> 00:51:26,880
it fits in with an idea of um

00:51:24,720 --> 00:51:28,160
you know users can jit stuff that fits

00:51:26,880 --> 00:51:29,920
in with our concepts

00:51:28,160 --> 00:51:31,359
but they can't necessarily bring stuff

00:51:29,920 --> 00:51:34,319
stuff in from outside

00:51:31,359 --> 00:51:34,800
that might be that might be good um or

00:51:34,319 --> 00:51:36,000
in the case

00:51:34,800 --> 00:51:37,599
we want them to include a third-party

00:51:36,000 --> 00:51:39,680
library we could allow them to to

00:51:37,599 --> 00:51:41,680
control the the linking flags or the

00:51:39,680 --> 00:51:44,720
compilation flags and introduce their

00:51:41,680 --> 00:51:46,400
own modules or pre-compiled headers

00:51:44,720 --> 00:51:47,920
there's another limitation here though

00:51:46,400 --> 00:51:51,040
which is that

00:51:47,920 --> 00:51:52,240
our users can't write templates inside

00:51:51,040 --> 00:51:53,920
their types

00:51:52,240 --> 00:51:54,960
because it's going to be inside the

00:51:53,920 --> 00:51:55,760
lambda which means it's going to be a

00:51:54,960 --> 00:51:58,160
local class

00:51:55,760 --> 00:51:59,839
inside a function and currently

00:51:58,160 --> 00:52:01,760
templates cannot be declared inside of

00:51:59,839 --> 00:52:04,400
local classes

00:52:01,760 --> 00:52:06,000
of course they can really because we can

00:52:04,400 --> 00:52:10,160
have generic lambdas which

00:52:06,000 --> 00:52:11,520
are templates inside local classes um

00:52:10,160 --> 00:52:14,319
and this is a kind of workaround for

00:52:11,520 --> 00:52:15,839
that uh it slightly complicates the

00:52:14,319 --> 00:52:18,559
user code and the calling code but it is

00:52:15,839 --> 00:52:22,000
a workaround that that works today

00:52:18,559 --> 00:52:22,480
but there's uh there's some there's some

00:52:22,000 --> 00:52:23,920
uh

00:52:22,480 --> 00:52:26,000
further workarounds in future that we

00:52:23,920 --> 00:52:27,599
might leverage so we mentioned frequent

00:52:26,000 --> 00:52:30,079
headers are modules which might

00:52:27,599 --> 00:52:31,119
come into play if users want to include

00:52:30,079 --> 00:52:34,079
stuff

00:52:31,119 --> 00:52:36,240
we've got the future possibility maybe

00:52:34,079 --> 00:52:39,440
the far future possibility of

00:52:36,240 --> 00:52:44,400
ast snippet injections using the meta or

00:52:39,440 --> 00:52:46,160
the various meta proposals that exist

00:52:44,400 --> 00:52:47,680
in the nearer future i think we've got a

00:52:46,160 --> 00:52:48,800
better chance for templates and local

00:52:47,680 --> 00:52:51,280
classes

00:52:48,800 --> 00:52:51,839
especially since we do have them already

00:52:51,280 --> 00:52:54,079
with

00:52:51,839 --> 00:52:56,240
generic lambdas so there should be

00:52:54,079 --> 00:52:57,040
relatively little implementation problem

00:52:56,240 --> 00:52:58,839
with that

00:52:57,040 --> 00:53:00,079
in fact there are two papers which i

00:52:58,839 --> 00:53:02,400
believe

00:53:00,079 --> 00:53:03,440
have been seen by the the standards body

00:53:02,400 --> 00:53:06,000
and now

00:53:03,440 --> 00:53:06,720
perhaps have been merged into one uh

00:53:06,000 --> 00:53:08,800
that both

00:53:06,720 --> 00:53:12,079
that both proposed this idea allowing

00:53:08,800 --> 00:53:12,079
templates and local classes

00:53:13,440 --> 00:53:19,839
so you know to me the the

00:53:16,640 --> 00:53:20,960
the 20-year game programmer my head just

00:53:19,839 --> 00:53:24,079
thinks of

00:53:20,960 --> 00:53:27,200
jitting as a concept for modding things

00:53:24,079 --> 00:53:28,480
um normally you would ship your program

00:53:27,200 --> 00:53:29,599
and if you're going to allow users to

00:53:28,480 --> 00:53:31,440
mod it you'd embed some kind of

00:53:29,599 --> 00:53:35,040
scripting language in there like lua

00:53:31,440 --> 00:53:36,400
or python maybe um but if you have if

00:53:35,040 --> 00:53:37,440
you're shipping a jit enabled

00:53:36,400 --> 00:53:40,240
application

00:53:37,440 --> 00:53:41,040
then you get this modding in c plus plus

00:53:40,240 --> 00:53:43,040
at

00:53:41,040 --> 00:53:45,040
as i say at configuration timer install

00:53:43,040 --> 00:53:48,880
time

00:53:45,040 --> 00:53:52,400
um versioning becomes i think easier

00:53:48,880 --> 00:53:54,720
because you don't have a

00:53:52,400 --> 00:53:55,599
you don't have any explicit versioning

00:53:54,720 --> 00:53:57,280
system you

00:53:55,599 --> 00:53:58,640
you have an implicit versioning system

00:53:57,280 --> 00:54:00,160
which is to say

00:53:58,640 --> 00:54:02,640
here's the concepts i want you to

00:54:00,160 --> 00:54:04,319
fulfill here's what you must do in order

00:54:02,640 --> 00:54:07,599
to compile if you compile

00:54:04,319 --> 00:54:09,599
you are the correct version um you don't

00:54:07,599 --> 00:54:10,800
have to manually version things so much

00:54:09,599 --> 00:54:14,400
you don't have to deal with

00:54:10,800 --> 00:54:18,240
api issues and dll versioning

00:54:14,400 --> 00:54:20,640
if that's your plugin architecture and

00:54:18,240 --> 00:54:21,440
someone earlier asked about sandboxing

00:54:20,640 --> 00:54:23,839
like i say

00:54:21,440 --> 00:54:26,800
ultimately if we're asking users to run

00:54:23,839 --> 00:54:29,440
stuff on their machines

00:54:26,800 --> 00:54:30,880
sort of non-hardware based sandboxing or

00:54:29,440 --> 00:54:32,319
you know non-hardware supported

00:54:30,880 --> 00:54:33,280
sandboxing is very difficult at the

00:54:32,319 --> 00:54:34,400
language level

00:54:33,280 --> 00:54:37,040
but we can do a certain amount of

00:54:34,400 --> 00:54:39,119
sandboxing with the type system

00:54:37,040 --> 00:54:40,480
so you know here's one idea i had for

00:54:39,119 --> 00:54:42,319
doing that we'll have we'll have a

00:54:40,480 --> 00:54:45,359
privilege level tag

00:54:42,319 --> 00:54:46,720
um and whenever we jit something what

00:54:45,359 --> 00:54:47,520
we'll do is take the user code and we'll

00:54:46,720 --> 00:54:51,119
wrap it

00:54:47,520 --> 00:54:52,079
inside a very sort of very thin wrapper

00:54:51,119 --> 00:54:53,839
class

00:54:52,079 --> 00:54:55,680
which is just going to tag it with this

00:54:53,839 --> 00:55:00,000
privilege level

00:54:55,680 --> 00:55:02,480
maybe in this way and then

00:55:00,000 --> 00:55:04,240
we will have appropriate constraint

00:55:02,480 --> 00:55:05,440
functions so that they can't be called

00:55:04,240 --> 00:55:08,079
with the user types

00:55:05,440 --> 00:55:09,599
now this speaks to us calling things

00:55:08,079 --> 00:55:12,400
sort of accidentally

00:55:09,599 --> 00:55:14,079
we can also use the type system more to

00:55:12,400 --> 00:55:17,280
dependency inject

00:55:14,079 --> 00:55:18,960
apis which the users are allowed to use

00:55:17,280 --> 00:55:20,319
and sort of wall off the rest of the

00:55:18,960 --> 00:55:22,400
stuff you know

00:55:20,319 --> 00:55:23,760
ultimately as i say this is c plus plus

00:55:22,400 --> 00:55:26,240
you can always

00:55:23,760 --> 00:55:28,480
sort of you can always try to you know

00:55:26,240 --> 00:55:29,359
take a pointer to something and cast it

00:55:28,480 --> 00:55:31,920
and then call it

00:55:29,359 --> 00:55:32,480
so there's no complete protection here

00:55:31,920 --> 00:55:36,079
but

00:55:32,480 --> 00:55:38,079
there is at least sort of

00:55:36,079 --> 00:55:39,680
lightweight fences that we can put up

00:55:38,079 --> 00:55:40,400
and make it easy for people to do the

00:55:39,680 --> 00:55:42,640
right thing and

00:55:40,400 --> 00:55:44,000
make it easy to to use without without

00:55:42,640 --> 00:55:46,400
trying to break it

00:55:44,000 --> 00:55:47,680
the goal is to provide a nice api and

00:55:46,400 --> 00:55:49,520
jit time errors

00:55:47,680 --> 00:55:50,960
rather than complete protection this is

00:55:49,520 --> 00:55:52,000
you wouldn't be shipping a jit

00:55:50,960 --> 00:55:54,240
application

00:55:52,000 --> 00:55:56,640
if you needed a locked down application

00:55:54,240 --> 00:55:56,640
basically

00:55:57,040 --> 00:56:00,559
so of course once you've thought about

00:55:58,799 --> 00:56:01,520
users in this way

00:56:00,559 --> 00:56:03,040
why wouldn't you just think about

00:56:01,520 --> 00:56:04,319
yourself in this way you know do you

00:56:03,040 --> 00:56:05,920
think breaks down the walls of the

00:56:04,319 --> 00:56:06,799
compiler and linker for you for your

00:56:05,920 --> 00:56:08,559
project team

00:56:06,799 --> 00:56:10,480
for your if you're providing a library

00:56:08,559 --> 00:56:13,280
for your application team

00:56:10,480 --> 00:56:13,760
um and you get all these benefits you

00:56:13,280 --> 00:56:15,680
get

00:56:13,760 --> 00:56:17,920
incremental compilation on a running

00:56:15,680 --> 00:56:19,839
system you get the ability to patch

00:56:17,920 --> 00:56:22,720
things with source code

00:56:19,839 --> 00:56:24,319
uh if if you need to do that on a

00:56:22,720 --> 00:56:25,760
endpoint machine

00:56:24,319 --> 00:56:27,359
and you get this programming with

00:56:25,760 --> 00:56:30,319
concepts like i say but

00:56:27,359 --> 00:56:31,680
you build in concept shape holes of

00:56:30,319 --> 00:56:33,920
types in your system

00:56:31,680 --> 00:56:35,520
and you allow people to just inject

00:56:33,920 --> 00:56:36,960
things that fulfill those concepts

00:56:35,520 --> 00:56:38,799
you don't have to think ahead of time

00:56:36,960 --> 00:56:40,880
about all the weird and wonderful

00:56:38,799 --> 00:56:42,240
i o types that they might want to use

00:56:40,880 --> 00:56:44,240
you provide

00:56:42,240 --> 00:56:45,520
an i o concept that can read and write

00:56:44,240 --> 00:56:47,760
maybe and then

00:56:45,520 --> 00:56:48,559
if they've got some weird i o hardware

00:56:47,760 --> 00:56:51,680
that they can

00:56:48,559 --> 00:56:53,280
support they get to jit a type that

00:56:51,680 --> 00:56:58,160
fulfills that concept

00:56:53,280 --> 00:56:59,599
hey presto their io is supported

00:56:58,160 --> 00:57:01,520
so we're pretty much at the end of the

00:56:59,599 --> 00:57:03,040
talk um

00:57:01,520 --> 00:57:05,359
i'll leave it to chris to summarize a

00:57:03,040 --> 00:57:05,359
little bit

00:57:06,799 --> 00:57:11,200
thank you ben so let's just quickly

00:57:10,000 --> 00:57:14,400
summarize what we've

00:57:11,200 --> 00:57:16,720
been discussing here and what gtin

00:57:14,400 --> 00:57:18,960
allowed us and what we can actually do

00:57:16,720 --> 00:57:22,079
in about in the future

00:57:18,960 --> 00:57:23,839
so we just explored the clan jit

00:57:22,079 --> 00:57:25,839
version of it so we won't be talking

00:57:23,839 --> 00:57:27,359
about gtn in general if it goes to the

00:57:25,839 --> 00:57:30,559
cause of benefits

00:57:27,359 --> 00:57:33,440
but there are definitely benefits of

00:57:30,559 --> 00:57:35,680
end cost of using that functionality

00:57:33,440 --> 00:57:37,599
using the cliented proposal

00:57:35,680 --> 00:57:38,720
so the first benefit is the fact that we

00:57:37,599 --> 00:57:40,480
can

00:57:38,720 --> 00:57:41,920
you know improve the runtime performance

00:57:40,480 --> 00:57:43,839
because

00:57:41,920 --> 00:57:45,280
optimization based on runtime data and

00:57:43,839 --> 00:57:46,400
available hardware are something which

00:57:45,280 --> 00:57:49,040
we cannot do

00:57:46,400 --> 00:57:49,839
ahead of time but we can do it at the

00:57:49,040 --> 00:57:52,160
jit time

00:57:49,839 --> 00:57:53,440
very often and that's a huge benefit

00:57:52,160 --> 00:57:56,079
which will

00:57:53,440 --> 00:57:58,720
you know allow ai and other things to to

00:57:56,079 --> 00:58:01,440
make things happen at runtime

00:57:58,720 --> 00:58:02,079
the the negative as we pointed out is

00:58:01,440 --> 00:58:04,799
the

00:58:02,079 --> 00:58:07,200
string version of it means that we have

00:58:04,799 --> 00:58:11,119
the security concerns and

00:58:07,200 --> 00:58:13,839
some other issues with it uh potentially

00:58:11,119 --> 00:58:14,960
comparative performance is yet another

00:58:13,839 --> 00:58:17,599
super cool

00:58:14,960 --> 00:58:19,359
thing about the client g version in

00:58:17,599 --> 00:58:19,920
comparison to for example cling because

00:58:19,359 --> 00:58:22,240
we have

00:58:19,920 --> 00:58:24,000
all these benefits from memorization of

00:58:22,240 --> 00:58:28,319
the templated functions

00:58:24,000 --> 00:58:31,599
so that's pretty cool and that sped up

00:58:28,319 --> 00:58:33,920
the compilation of cheated

00:58:31,599 --> 00:58:35,760
classes by far in comparison to

00:58:33,920 --> 00:58:37,440
generating code and try to compile it

00:58:35,760 --> 00:58:40,640
with the compiler under the hood

00:58:37,440 --> 00:58:45,040
because we can skip a lot of phases

00:58:40,640 --> 00:58:48,079
and it's already memorized in in most of

00:58:45,040 --> 00:58:49,599
of the cases either way it doesn't we

00:58:48,079 --> 00:58:51,520
don't support compile time injection

00:58:49,599 --> 00:58:54,640
though so it means that we cannot

00:58:51,520 --> 00:58:57,520
do the mixing part of it with the d

00:58:54,640 --> 00:58:59,200
that'll be awesome if we could do that

00:58:57,520 --> 00:59:01,200
and having direct access to the host

00:58:59,200 --> 00:59:02,880
is a huge benefit because we can access

00:59:01,200 --> 00:59:04,400
everything from the host

00:59:02,880 --> 00:59:06,240
and that always benefit because we can

00:59:04,400 --> 00:59:09,680
pre-compile stuff

00:59:06,240 --> 00:59:11,280
ahead of time and you know again we can

00:59:09,680 --> 00:59:14,240
leverage steel algorithms

00:59:11,280 --> 00:59:15,520
for the meta programming with types

00:59:14,240 --> 00:59:18,480
which is super cool and

00:59:15,520 --> 00:59:19,599
allows us just to you know sort the

00:59:18,480 --> 00:59:22,880
strings instead of

00:59:19,599 --> 00:59:24,480
trying to compare them certain types

00:59:22,880 --> 00:59:26,880
so what about quickly just about the

00:59:24,480 --> 00:59:27,680
future in the future you can imagine

00:59:26,880 --> 00:59:30,000
that

00:59:27,680 --> 00:59:31,599
this attribute won't be part of the

00:59:30,000 --> 00:59:32,400
that's at least what the proposal tried

00:59:31,599 --> 00:59:34,559
to say

00:59:32,400 --> 00:59:35,839
uh with the future revisions that the

00:59:34,559 --> 00:59:38,000
attribute won't be

00:59:35,839 --> 00:59:38,960
the pi won't be part of the function it

00:59:38,000 --> 00:59:41,760
will be just

00:59:38,960 --> 00:59:43,359
at the kali side so that will be the

00:59:41,760 --> 00:59:44,960
runtime version we can also have a

00:59:43,359 --> 00:59:47,520
context per version which will be

00:59:44,960 --> 00:59:49,359
either runtime or combine time or we can

00:59:47,520 --> 00:59:52,720
have cos eval version which will be

00:59:49,359 --> 00:59:54,480
just the compile-time version as well as

00:59:52,720 --> 00:59:56,559
you know we can always pass the types in

00:59:54,480 --> 00:59:57,920
all cases so you can imagine that the

00:59:56,559 --> 01:00:01,520
future

00:59:57,920 --> 01:00:04,640
may bring us similar interface but

01:00:01,520 --> 01:00:06,960
much harder much nicer

01:00:04,640 --> 01:00:08,799
much more powerful integration of the

01:00:06,960 --> 01:00:13,040
compile time

01:00:08,799 --> 01:00:14,799
and the string solution that kind of

01:00:13,040 --> 01:00:16,240
maybe brings it to the reflection

01:00:14,799 --> 01:00:18,960
proposal when

01:00:16,240 --> 01:00:19,760
the ast note might be leveraged and here

01:00:18,960 --> 01:00:21,599
to reify

01:00:19,760 --> 01:00:22,799
it's from haskell and i have to thank

01:00:21,599 --> 01:00:26,160
you ben for that

01:00:22,799 --> 01:00:28,559
term to understand your term

01:00:26,160 --> 01:00:29,760
and andrew satan also is using it right

01:00:28,559 --> 01:00:32,000
now probably heard

01:00:29,760 --> 01:00:33,920
ben talking about it it sometimes is

01:00:32,000 --> 01:00:35,119
taking something that is abstract and

01:00:33,920 --> 01:00:36,960
regard

01:00:35,119 --> 01:00:39,200
is it doesn't matter so it's like

01:00:36,960 --> 01:00:42,000
something abstract moved to the

01:00:39,200 --> 01:00:43,839
uh real world in a sense so you can see

01:00:42,000 --> 01:00:46,000
here that we produce a meta type

01:00:43,839 --> 01:00:47,280
integral constant out of the runtime

01:00:46,000 --> 01:00:51,040
value and

01:00:47,280 --> 01:00:53,040
make it you know concrete

01:00:51,040 --> 01:00:54,559
as a type and after that we'll be able

01:00:53,040 --> 01:00:57,599
to just

01:00:54,559 --> 01:00:59,760
call it at compildem so you can read

01:00:57,599 --> 01:01:01,440
about it in android saturn compiler meta

01:00:59,760 --> 01:01:06,400
programming

01:01:01,440 --> 01:01:10,240
and that will be it i guess

01:01:06,400 --> 01:01:13,040
i'll let ben finish

01:01:10,240 --> 01:01:14,000
all right thanks thank you everyone

01:01:13,040 --> 01:01:15,839
thanks chris

01:01:14,000 --> 01:01:17,680
we do have a few questions left over

01:01:15,839 --> 01:01:19,440
we're right at time but

01:01:17,680 --> 01:01:21,040
we can take a couple of questions the

01:01:19,440 --> 01:01:22,880
top question is

01:01:21,040 --> 01:01:24,559
this all seems very similar to email in

01:01:22,880 --> 01:01:26,559
javascript that's something largely

01:01:24,559 --> 01:01:28,960
discouraged in modern js how is this

01:01:26,559 --> 01:01:31,040
different slash more useful

01:01:28,960 --> 01:01:32,640
well i think the simple answer for me is

01:01:31,040 --> 01:01:34,400
javascript is dynamically typed and

01:01:32,640 --> 01:01:37,920
doesn't have concepts

01:01:34,400 --> 01:01:38,319
um it's fundamentally different like

01:01:37,920 --> 01:01:41,920
you're

01:01:38,319 --> 01:01:45,200
you're it's not you're not necessarily

01:01:41,920 --> 01:01:46,480
allowing free reign you're saying you've

01:01:45,200 --> 01:01:46,880
got to produce something which is this

01:01:46,480 --> 01:01:50,559
shape

01:01:46,880 --> 01:01:53,040
and which fulfills this concept um

01:01:50,559 --> 01:01:55,280
and i think i think that part of it is

01:01:53,040 --> 01:01:58,640
is really great

01:01:55,280 --> 01:02:00,480
uh and on top of that

01:01:58,640 --> 01:02:02,079
and i guess on top of that we have all

01:02:00,480 --> 01:02:05,200
these benefits from

01:02:02,079 --> 01:02:08,720
runtime data being available for you

01:02:05,200 --> 01:02:09,520
to produce much you know to promote it

01:02:08,720 --> 01:02:12,559
compile time

01:02:09,520 --> 01:02:14,160
and has been pointed out type save

01:02:12,559 --> 01:02:16,640
compile time version of it

01:02:14,160 --> 01:02:18,960
so i think that both of that gives us

01:02:16,640 --> 01:02:22,079
the the leverage of

01:02:18,960 --> 01:02:23,039
being much more capable gta environment

01:02:22,079 --> 01:02:25,680
than the

01:02:23,039 --> 01:02:25,680
js is

01:02:26,559 --> 01:02:30,640
so another question was do the proposals

01:02:28,480 --> 01:02:32,160
for reflection and code injection

01:02:30,640 --> 01:02:34,640
reduce or eliminate the need for

01:02:32,160 --> 01:02:37,440
compile-time jit

01:02:34,640 --> 01:02:38,559
um they they can speak to some of the

01:02:37,440 --> 01:02:40,480
same things

01:02:38,559 --> 01:02:43,440
i think in a sense compile time jit is a

01:02:40,480 --> 01:02:45,920
super set even of reflection because

01:02:43,440 --> 01:02:46,480
if you have the ability to fully compile

01:02:45,920 --> 01:02:49,599
something

01:02:46,480 --> 01:02:51,760
in a running program you you have

01:02:49,599 --> 01:02:53,440
reflection you you can

01:02:51,760 --> 01:02:55,440
you know you can take code and

01:02:53,440 --> 01:02:56,720
manipulate it as strings or manipulate

01:02:55,440 --> 01:02:59,359
it as meta objects

01:02:56,720 --> 01:03:01,359
you know so they do play together there

01:02:59,359 --> 01:03:04,240
um

01:03:01,359 --> 01:03:05,280
i i i think jit is strictly more

01:03:04,240 --> 01:03:07,280
powerful

01:03:05,280 --> 01:03:09,200
when when viewed in the right way there

01:03:07,280 --> 01:03:10,880
with when given the right access to the

01:03:09,200 --> 01:03:17,839
kind of tools that reflection is going

01:03:10,880 --> 01:03:17,839
to going to allow us to have

01:03:19,920 --> 01:03:24,160
so we should probably just wrap up there

01:03:22,480 --> 01:03:26,160
then

01:03:24,160 --> 01:03:27,359
i think thanks everyone uh there is a

01:03:26,160 --> 01:03:29,440
sig jit

01:03:27,359 --> 01:03:31,839
channel in the slack where you can ask

01:03:29,440 --> 01:03:33,280
more questions if you need to

01:03:31,839 --> 01:03:45,839
thanks for coming to the talk and have a

01:03:33,280 --> 01:03:45,839
great rest of conference thank you

01:03:55,440 --> 01:03:57,520

YouTube URL: https://www.youtube.com/watch?v=I3ov8HcdVKw


