Title: No Touchy! A Case Study of Software Architecture with Immutable Objects - Borislav Stanimirov
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Our mission at ViewRay's is to conquer cancer by reenvisioning radiation therapy

Part of this is a piece of software which supports many workflows involving communication with various external agents such as an MRI scanner, a radiotherapy linear accelerator, a database, and, of course, the human operator. This software was started from scratch at the beginning of 2019 and is developed primarily in C++17.

This talk covers the multi-threaded and multi-process architecture of the software. It focuses on one of its elements: immutable objects. This is a pattern which started with functional programming. It was popularized by Haskell and it's hugely popular in web development — the React-Redux stack, for example — but it is not that popular in C++ software development. We will talk about how we ended up sticking with immutable objects, how they helped (and sometimes hindered) our development, what we invented in order to make them practical in C++, and problems and solutions we encountered along the way.

---
Borislav has been a C++ programmer for more than 17 years. The majority of his career has been in video games and in the past two years he's been working on software for medical devices. He has worked on C++ software for all kinds of platforms: desktops, mobile devices, servers, and embedded. His main interests are software architecture and design, and programming languages.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,280 --> 00:00:13,840
hi

00:00:10,080 --> 00:00:15,759
and welcome i'm boris love

00:00:13,840 --> 00:00:17,440
and you can find these slides over here

00:00:15,759 --> 00:00:21,279
that's is dot gd slash

00:00:17,440 --> 00:00:23,680
immutable a bit about myself

00:00:21,279 --> 00:00:26,000
i do mostly c plus plus stuff though i

00:00:23,680 --> 00:00:27,279
dabble in many other languages

00:00:26,000 --> 00:00:30,160
most of my career has been in game

00:00:27,279 --> 00:00:33,920
programming but since 2019 uh

00:00:30,160 --> 00:00:36,399
i work at a medical medical

00:00:33,920 --> 00:00:37,200
hardware company writing software so

00:00:36,399 --> 00:00:39,520
this talk is

00:00:37,200 --> 00:00:41,440
about this basically i do a lot of open

00:00:39,520 --> 00:00:44,879
source and you can find me on github

00:00:41,440 --> 00:00:47,840
slash ibob and

00:00:44,879 --> 00:00:48,160
now i'm going to do an inspirational i

00:00:47,840 --> 00:00:51,520
guess

00:00:48,160 --> 00:00:54,480
demo of our software it's live

00:00:51,520 --> 00:00:55,840
so i got it running over here and

00:00:54,480 --> 00:00:58,399
basically

00:00:55,840 --> 00:01:00,000
viewray does create installations for

00:00:58,399 --> 00:01:01,840
cancer treatment

00:01:00,000 --> 00:01:03,760
so here we have some patients and

00:01:01,840 --> 00:01:06,479
they're diagnosed with cancer

00:01:03,760 --> 00:01:07,680
i select one of them and i initiate

00:01:06,479 --> 00:01:09,680
treatment

00:01:07,680 --> 00:01:11,119
there's been a plan already done for

00:01:09,680 --> 00:01:14,320
that patient right now what you're

00:01:11,119 --> 00:01:16,880
seeing is the mri scan being taken

00:01:14,320 --> 00:01:18,000
so okay uh here we have an mri scan and

00:01:16,880 --> 00:01:20,080
we can compare

00:01:18,000 --> 00:01:21,439
the planning scan with the current scan

00:01:20,080 --> 00:01:23,759
right here

00:01:21,439 --> 00:01:25,840
uh right here you can see that certain

00:01:23,759 --> 00:01:27,520
tasks are being done in the background

00:01:25,840 --> 00:01:30,479
and we can see their progress and

00:01:27,520 --> 00:01:30,880
let's say that we're uh we're okay with

00:01:30,479 --> 00:01:33,920
this

00:01:30,880 --> 00:01:35,439
uh current patient's patient position so

00:01:33,920 --> 00:01:37,840
we approve the position

00:01:35,439 --> 00:01:39,520
we'll we're waiting for for the

00:01:37,840 --> 00:01:40,479
basically for the anatomical structures

00:01:39,520 --> 00:01:43,040
to be identified

00:01:40,479 --> 00:01:44,320
inside of the patients right now and

00:01:43,040 --> 00:01:47,680
it's done

00:01:44,320 --> 00:01:50,159
so right here you can see it's a 3d scan

00:01:47,680 --> 00:01:52,000
so you can you can see the anatomical

00:01:50,159 --> 00:01:52,560
structures and the volume is streaming

00:01:52,000 --> 00:01:55,439
right now

00:01:52,560 --> 00:01:57,280
and it's not that fast because of these

00:01:55,439 --> 00:01:58,240
really slow background processes over

00:01:57,280 --> 00:02:00,880
here

00:01:58,240 --> 00:02:02,240
so um those are anatomical structures

00:02:00,880 --> 00:02:03,840
inside of the patient which the software

00:02:02,240 --> 00:02:06,479
has identified and one of them

00:02:03,840 --> 00:02:08,800
uh is the so-called ptv so there's a

00:02:06,479 --> 00:02:11,840
tumor basically that's where we

00:02:08,800 --> 00:02:12,959
what we aim to eradicate so we can prove

00:02:11,840 --> 00:02:16,080
this thing right here

00:02:12,959 --> 00:02:18,560
we can also say use these tools to

00:02:16,080 --> 00:02:20,239
tweak and adjust the the anatomical

00:02:18,560 --> 00:02:22,800
structures in the patient

00:02:20,239 --> 00:02:24,480
but let's say we approve okay so we're

00:02:22,800 --> 00:02:24,879
waiting for a full optimization right

00:02:24,480 --> 00:02:28,160
now

00:02:24,879 --> 00:02:30,560
uh i'm sorry if the stream lags a bit uh

00:02:28,160 --> 00:02:30,560
i guess

00:02:31,599 --> 00:02:40,720
why is it taking so long

00:02:37,120 --> 00:02:40,720
did we encounter a bug

00:02:45,920 --> 00:02:52,239
okay notes uh sorry so basically the

00:02:49,280 --> 00:02:53,920
target hardware for this is like 64 cpu

00:02:52,239 --> 00:02:57,040
computers and

00:02:53,920 --> 00:02:58,560
running the with i know the mother of

00:02:57,040 --> 00:03:00,319
all processors i guess and

00:02:58,560 --> 00:03:02,959
i'm currently running this on my laptop

00:03:00,319 --> 00:03:04,319
so it's not as fast as i hoped it would

00:03:02,959 --> 00:03:06,800
be uh

00:03:04,319 --> 00:03:08,159
or at least i guess the stream is taking

00:03:06,800 --> 00:03:09,840
some of my cpu time

00:03:08,159 --> 00:03:11,200
so we're waiting for full optimization

00:03:09,840 --> 00:03:14,159
basically right now the

00:03:11,200 --> 00:03:15,440
the software is trying to uh predict

00:03:14,159 --> 00:03:18,319
what kind of uh

00:03:15,440 --> 00:03:18,959
those will be distributed uh inside of

00:03:18,319 --> 00:03:20,800
the patient

00:03:18,959 --> 00:03:22,319
after we finish the the treatment the

00:03:20,800 --> 00:03:25,120
actual treatment delivery

00:03:22,319 --> 00:03:26,000
with the with the linear accelerator

00:03:25,120 --> 00:03:28,879
beam

00:03:26,000 --> 00:03:30,640
um he's trying to to decide uh how the

00:03:28,879 --> 00:03:32,159
dose will be distributed and trying to

00:03:30,640 --> 00:03:35,200
find the best

00:03:32,159 --> 00:03:37,760
positions for the beams themselves

00:03:35,200 --> 00:03:38,480
so it's basically the plan and during

00:03:37,760 --> 00:03:40,239
planning

00:03:38,480 --> 00:03:42,159
the operator has decided some beam

00:03:40,239 --> 00:03:43,920
positions now the the software is trying

00:03:42,159 --> 00:03:46,560
to optimize them basically

00:03:43,920 --> 00:03:47,200
uh in such a way that the those

00:03:46,560 --> 00:03:49,120
delivered

00:03:47,200 --> 00:03:51,280
the maximum delivered those is in the

00:03:49,120 --> 00:03:53,439
tumor and uh

00:03:51,280 --> 00:03:55,040
certain critical anatomical structures

00:03:53,439 --> 00:03:56,720
inside of the patient are not being

00:03:55,040 --> 00:03:59,120
affected by this

00:03:56,720 --> 00:04:00,000
okay so we get the predicted dose so if

00:03:59,120 --> 00:04:01,680
we proceed with this

00:04:00,000 --> 00:04:03,439
treatment the software predicts that

00:04:01,680 --> 00:04:04,239
those will be roughly distributed like

00:04:03,439 --> 00:04:06,640
this

00:04:04,239 --> 00:04:07,280
so as you can see the tumor receives the

00:04:06,640 --> 00:04:11,040
biggest

00:04:07,280 --> 00:04:13,599
the highest amount of those so um

00:04:11,040 --> 00:04:15,920
we're waiting for the qa qa is basically

00:04:13,599 --> 00:04:18,639
made making sure that everything is okay

00:04:15,920 --> 00:04:20,320
we can see here there's the the

00:04:18,639 --> 00:04:21,840
distribution of the dolls inside of

00:04:20,320 --> 00:04:24,400
different anatomical structures and here

00:04:21,840 --> 00:04:24,400
we have some

00:04:24,960 --> 00:04:29,840
constraints for example the tumor should

00:04:27,360 --> 00:04:33,199
receive those more than

00:04:29,840 --> 00:04:34,960
47 gray certain anatomical structures

00:04:33,199 --> 00:04:38,240
like kidneys or livers should receive

00:04:34,960 --> 00:04:39,600
those less than whatever gray and we're

00:04:38,240 --> 00:04:42,320
trying basically to

00:04:39,600 --> 00:04:43,680
to work and follow these constraints and

00:04:42,320 --> 00:04:46,560
this is the the

00:04:43,680 --> 00:04:47,759
adapted plan and typically uh

00:04:46,560 --> 00:04:51,360
conventional treatment

00:04:47,759 --> 00:04:52,479
ends here so we decide what how we're

00:04:51,360 --> 00:04:54,720
going to read the patent

00:04:52,479 --> 00:04:56,240
patient and then we start shooting

00:04:54,720 --> 00:04:58,800
basically but of course if

00:04:56,240 --> 00:05:00,320
if a tumor is in the torso of a patient

00:04:58,800 --> 00:05:01,600
there's lots of movement of organs

00:05:00,320 --> 00:05:02,400
inside of there there's breathing

00:05:01,600 --> 00:05:05,440
there's gas

00:05:02,400 --> 00:05:08,639
there's all kinds of stuff going on so

00:05:05,440 --> 00:05:10,880
typically conventional treatment

00:05:08,639 --> 00:05:12,240
has negative side effects and though

00:05:10,880 --> 00:05:15,840
these are caused by

00:05:12,240 --> 00:05:18,639
the beam actually hitting organs which

00:05:15,840 --> 00:05:20,320
are not supposed to receive a big big

00:05:18,639 --> 00:05:24,320
dose

00:05:20,320 --> 00:05:29,680
uh in our way our innovative

00:05:24,320 --> 00:05:29,680
what now that was disappointing

00:05:30,080 --> 00:05:35,759
i'm sorry about that that's the the

00:05:33,440 --> 00:05:36,800
i guess the what you get with live demos

00:05:35,759 --> 00:05:39,759
so in

00:05:36,800 --> 00:05:41,600
in our installation we we scan uh the

00:05:39,759 --> 00:05:44,720
patient while treating so basically we

00:05:41,600 --> 00:05:47,440
receive a live video feed with the mri

00:05:44,720 --> 00:05:49,360
inside of the patient which sadly i

00:05:47,440 --> 00:05:50,639
couldn't show you right now and i don't

00:05:49,360 --> 00:05:53,039
know what and i'm not going to

00:05:50,639 --> 00:05:55,120
troubleshoot it right now i apologize

00:05:53,039 --> 00:05:56,880
but we receive a live video feed video

00:05:55,120 --> 00:05:58,720
in a way thanks to the mri

00:05:56,880 --> 00:06:01,360
from inside of the patient and when the

00:05:58,720 --> 00:06:04,080
beam uh is not

00:06:01,360 --> 00:06:06,560
when the beam doesn't uh hit the tumor

00:06:04,080 --> 00:06:08,880
or the beam hits an organ that's

00:06:06,560 --> 00:06:09,600
deemed too dangerous to hit we just

00:06:08,880 --> 00:06:12,080
temporarily

00:06:09,600 --> 00:06:13,919
shut off the beam and that's how we get

00:06:12,080 --> 00:06:14,479
the minimal amount of side effects we we

00:06:13,919 --> 00:06:17,199
adapt

00:06:14,479 --> 00:06:19,520
well well the the actual treatment

00:06:17,199 --> 00:06:22,560
delivery is going on

00:06:19,520 --> 00:06:25,199
so what did you just see

00:06:22,560 --> 00:06:26,000
uh so you saw software which was started

00:06:25,199 --> 00:06:28,479
from scratch

00:06:26,000 --> 00:06:30,240
in 2019 and it aims to replace the

00:06:28,479 --> 00:06:31,199
current existing software the current

00:06:30,240 --> 00:06:33,680
existing software

00:06:31,199 --> 00:06:34,240
uh it's not buggy i guess it doesn't

00:06:33,680 --> 00:06:37,039
have any

00:06:34,240 --> 00:06:37,600
bugs but it's actually really slow and

00:06:37,039 --> 00:06:40,639
it has

00:06:37,600 --> 00:06:43,120
uh i guess spaghetti called issues and

00:06:40,639 --> 00:06:44,560
it's really hard to to to add new

00:06:43,120 --> 00:06:47,199
features to it

00:06:44,560 --> 00:06:48,080
uh what you saw was gui that runs inside

00:06:47,199 --> 00:06:49,919
of the browser

00:06:48,080 --> 00:06:51,440
so i'm this is a browser that you're

00:06:49,919 --> 00:06:53,120
looking at right now and you just saw

00:06:51,440 --> 00:06:54,560
another tab of it

00:06:53,120 --> 00:06:56,800
but the back end is written in equals

00:06:54,560 --> 00:06:58,880
plus 17.

00:06:56,800 --> 00:07:00,319
so a bird's-eye view of the architecture

00:06:58,880 --> 00:07:01,759
as i said a browser current which

00:07:00,319 --> 00:07:02,800
connect client which connects to an

00:07:01,759 --> 00:07:04,960
application server

00:07:02,800 --> 00:07:06,560
and this application server has multiple

00:07:04,960 --> 00:07:08,880
services and workers

00:07:06,560 --> 00:07:10,000
uh service is some kind of a process

00:07:08,880 --> 00:07:12,000
which runs

00:07:10,000 --> 00:07:13,039
for i guess the entire lifetime of the

00:07:12,000 --> 00:07:14,319
server itself

00:07:13,039 --> 00:07:16,160
and in order to communicate with the

00:07:14,319 --> 00:07:17,520
service you create a session to a

00:07:16,160 --> 00:07:19,039
service and then communicate with this

00:07:17,520 --> 00:07:20,400
session and you can destroy the session

00:07:19,039 --> 00:07:21,520
then you stop communicating with this

00:07:20,400 --> 00:07:23,440
service

00:07:21,520 --> 00:07:25,039
an example of this is say the treatment

00:07:23,440 --> 00:07:26,800
service that you just observed there's

00:07:25,039 --> 00:07:27,680
an mri service which connects to the

00:07:26,800 --> 00:07:29,759
actual mri

00:07:27,680 --> 00:07:32,240
we have i said data service which

00:07:29,759 --> 00:07:34,720
connects to the database and provides

00:07:32,240 --> 00:07:36,240
allows us to to get and store different

00:07:34,720 --> 00:07:40,000
objects

00:07:36,240 --> 00:07:41,360
and also we have workers a worker is

00:07:40,000 --> 00:07:43,360
something that has a short life it

00:07:41,360 --> 00:07:44,960
calculates something and then ceases to

00:07:43,360 --> 00:07:48,960
exist

00:07:44,960 --> 00:07:48,960
for example the different

00:07:49,440 --> 00:07:52,800
anatomical structure simplification

00:07:51,039 --> 00:07:56,560
algorithms that you saw are

00:07:52,800 --> 00:07:56,879
workers we calculated those if the demo

00:07:56,560 --> 00:07:58,879
had

00:07:56,879 --> 00:08:00,800
worked you would have seen like live

00:07:58,879 --> 00:08:03,759
dose calculation as the

00:08:00,800 --> 00:08:05,360
as the treatment is going on let's go a

00:08:03,759 --> 00:08:07,599
bit deeper

00:08:05,360 --> 00:08:08,879
so the ui service for example it has

00:08:07,599 --> 00:08:10,639
sessions for clients it supports

00:08:08,879 --> 00:08:12,240
multiple sessions as we support multiple

00:08:10,639 --> 00:08:14,080
clients so multiple people can connect

00:08:12,240 --> 00:08:14,720
from their browsers to the same server

00:08:14,080 --> 00:08:17,520
and

00:08:14,720 --> 00:08:18,879
participate in the treatment in some way

00:08:17,520 --> 00:08:20,960
it's basically

00:08:18,879 --> 00:08:22,960
builds type erased ui objects from the

00:08:20,960 --> 00:08:24,479
application state

00:08:22,960 --> 00:08:26,160
there's a module to the ui service

00:08:24,479 --> 00:08:28,240
called the websocket server

00:08:26,160 --> 00:08:29,280
uh and it's a layer for browser

00:08:28,240 --> 00:08:31,199
basically it

00:08:29,280 --> 00:08:32,800
translates the title raised ui objects

00:08:31,199 --> 00:08:35,680
to json

00:08:32,800 --> 00:08:37,599
and receives commands from the browser

00:08:35,680 --> 00:08:40,159
through json again

00:08:37,599 --> 00:08:40,959
but that's we theoretically we could

00:08:40,159 --> 00:08:44,720
create another

00:08:40,959 --> 00:08:47,200
uh module which uh builds cute

00:08:44,720 --> 00:08:48,399
objects from from the ui objects and we

00:08:47,200 --> 00:08:51,680
can have acute

00:08:48,399 --> 00:08:53,120
we we don't right now but it's possible

00:08:51,680 --> 00:08:54,640
the treatment service that you just

00:08:53,120 --> 00:08:56,720
observed so you create a treatment

00:08:54,640 --> 00:08:58,640
session and only a single session can

00:08:56,720 --> 00:09:00,000
ever uh exist in the server because have

00:08:58,640 --> 00:09:03,120
we have a single mri

00:09:00,000 --> 00:09:04,720
and a single uh radiotherapy equipment

00:09:03,120 --> 00:09:06,240
instant source radiotherapy equipment i

00:09:04,720 --> 00:09:08,000
guess so um

00:09:06,240 --> 00:09:09,519
it has a state which represents the

00:09:08,000 --> 00:09:11,440
treatment in progress uh

00:09:09,519 --> 00:09:13,120
it fetches imaging data from the mri

00:09:11,440 --> 00:09:15,760
surveys the issues start and stop

00:09:13,120 --> 00:09:17,839
the radiotherapy surveys uh it gathers

00:09:15,760 --> 00:09:19,519
information about delivered those

00:09:17,839 --> 00:09:22,080
something that you sadly again didn't

00:09:19,519 --> 00:09:23,200
see but at the end it saves treatment

00:09:22,080 --> 00:09:26,000
data to the database

00:09:23,200 --> 00:09:28,959
and that's basically what it does so

00:09:26,000 --> 00:09:28,959
let's go a bit deeper

00:09:29,519 --> 00:09:33,200
these services they work with objects

00:09:32,399 --> 00:09:35,360
and

00:09:33,200 --> 00:09:37,600
let's see an object for example this is

00:09:35,360 --> 00:09:39,680
a simple bare bones object

00:09:37,600 --> 00:09:42,640
it has some data and you can get and set

00:09:39,680 --> 00:09:44,560
the the appropriate data

00:09:42,640 --> 00:09:45,760
but i mentioned multiple threads and

00:09:44,560 --> 00:09:47,680
multiple processes

00:09:45,760 --> 00:09:49,440
so if we just use this subject we'll get

00:09:47,680 --> 00:09:51,200
races so

00:09:49,440 --> 00:09:53,040
a native approach would be to basically

00:09:51,200 --> 00:09:55,200
add a mutex to the object but of course

00:09:53,040 --> 00:09:56,560
uh that's a bad idea because readers and

00:09:55,200 --> 00:09:58,800
everything will have to wait on each

00:09:56,560 --> 00:10:01,440
other so the readers especially so

00:09:58,800 --> 00:10:02,079
if we just use our objects built like

00:10:01,440 --> 00:10:03,440
this

00:10:02,079 --> 00:10:06,079
we will essentially be building a single

00:10:03,440 --> 00:10:08,000
thread application we don't want that

00:10:06,079 --> 00:10:09,120
so this equals plus 17 of course and we

00:10:08,000 --> 00:10:11,200
have shared mutexes

00:10:09,120 --> 00:10:12,640
so we can have a read lock and read and

00:10:11,200 --> 00:10:14,800
lock and write and

00:10:12,640 --> 00:10:16,160
use the shared locks of the new text to

00:10:14,800 --> 00:10:16,560
build a launch object that looks like

00:10:16,160 --> 00:10:19,200
this

00:10:16,560 --> 00:10:21,279
okay let's try to work with this um we

00:10:19,200 --> 00:10:24,000
can make it more robust of course by

00:10:21,279 --> 00:10:24,959
making the reading read locks const

00:10:24,000 --> 00:10:28,000
because they don't

00:10:24,959 --> 00:10:31,120
change the object presumably we can

00:10:28,000 --> 00:10:33,279
have also calling read and lock and

00:10:31,120 --> 00:10:35,279
unlock manually is of course

00:10:33,279 --> 00:10:36,640
not very robust so we can create some

00:10:35,279 --> 00:10:40,959
kind of external

00:10:36,640 --> 00:10:40,959
uh read lock objects in this typical

00:10:41,279 --> 00:10:44,480
typical scoped interface so basically

00:10:43,680 --> 00:10:45,839
you lock

00:10:44,480 --> 00:10:48,079
in the constructor and unlocking the

00:10:45,839 --> 00:10:51,680
destructor and that's the right lock so

00:10:48,079 --> 00:10:54,800
really really simple so um

00:10:51,680 --> 00:10:57,440
in the regular mutex example

00:10:54,800 --> 00:10:58,959
i said that readers have to wait on each

00:10:57,440 --> 00:11:00,480
other and you might assume that the

00:10:58,959 --> 00:11:01,600
problem here is that writers will have

00:11:00,480 --> 00:11:03,519
to wait on each other but

00:11:01,600 --> 00:11:05,760
that's actually what we want we don't

00:11:03,519 --> 00:11:08,399
want to write at the same time

00:11:05,760 --> 00:11:09,680
uh the thing is that writers will have

00:11:08,399 --> 00:11:12,399
to wait on readers

00:11:09,680 --> 00:11:13,279
and um for example in our anatomical

00:11:12,399 --> 00:11:16,720
structures

00:11:13,279 --> 00:11:17,680
we contouring algorithms they write the

00:11:16,720 --> 00:11:20,480
algorithms that

00:11:17,680 --> 00:11:22,560
identify those structures they write

00:11:20,480 --> 00:11:26,480
those calculations for example it reads

00:11:22,560 --> 00:11:28,959
the ui also reads at the same time and

00:11:26,480 --> 00:11:30,320
certain algorithms may also read from

00:11:28,959 --> 00:11:32,880
the anatomical structures

00:11:30,320 --> 00:11:34,480
we don't necessarily need to identify an

00:11:32,880 --> 00:11:37,600
anatomical structure with an organ

00:11:34,480 --> 00:11:42,160
we can create like a a boundary

00:11:37,600 --> 00:11:44,720
uh say a five millimeter boundary um

00:11:42,160 --> 00:11:46,240
next to like like around the organ or

00:11:44,720 --> 00:11:49,920
something like this

00:11:46,240 --> 00:11:52,480
so we determined that we don't want

00:11:49,920 --> 00:11:53,680
uh readers to wait on writers and the

00:11:52,480 --> 00:11:56,240
typical solution

00:11:53,680 --> 00:11:57,760
to the writer's wait on readers sorry

00:11:56,240 --> 00:11:58,320
and the typical solution to this is of

00:11:57,760 --> 00:12:01,600
course

00:11:58,320 --> 00:12:03,200
this and this is a cow and yeah copy on

00:12:01,600 --> 00:12:05,040
right

00:12:03,200 --> 00:12:06,800
basically a lot of languages implement

00:12:05,040 --> 00:12:08,560
copy and write at language level for

00:12:06,800 --> 00:12:11,600
example swift and many others

00:12:08,560 --> 00:12:14,399
do something like this you have

00:12:11,600 --> 00:12:14,959
your data it's a shared pointer uh you

00:12:14,399 --> 00:12:19,519
can

00:12:14,959 --> 00:12:22,639
always at any moment just get uh read

00:12:19,519 --> 00:12:22,959
read the data as it is and when you want

00:12:22,639 --> 00:12:24,800
to

00:12:22,959 --> 00:12:26,000
to write on the data you receive a

00:12:24,800 --> 00:12:28,639
mutable reference

00:12:26,000 --> 00:12:31,360
and in this case we check whether there

00:12:28,639 --> 00:12:34,560
are any other references to this object

00:12:31,360 --> 00:12:36,399
object around and if the if they're not

00:12:34,560 --> 00:12:38,079
we can just return the actual object but

00:12:36,399 --> 00:12:41,360
if they are we we perform

00:12:38,079 --> 00:12:42,800
we perform a copy on right so that's

00:12:41,360 --> 00:12:44,720
that's an object copy here

00:12:42,800 --> 00:12:45,920
so let's rewrite our object in the same

00:12:44,720 --> 00:12:48,160
way that's

00:12:45,920 --> 00:12:50,160
basically the exact same thing called

00:12:48,160 --> 00:12:52,079
object wrapper

00:12:50,160 --> 00:12:53,279
but the problem here is how do we refer

00:12:52,079 --> 00:12:55,680
to objects

00:12:53,279 --> 00:12:56,320
so let's look at this example we have an

00:12:55,680 --> 00:12:59,600
object

00:12:56,320 --> 00:13:03,040
we have a blue thread which

00:12:59,600 --> 00:13:04,320
basically has a loop which reads the

00:13:03,040 --> 00:13:06,560
object continuously

00:13:04,320 --> 00:13:09,279
and then we want to write to change

00:13:06,560 --> 00:13:12,399
something inside of the object

00:13:09,279 --> 00:13:14,240
um yeah that's it

00:13:12,399 --> 00:13:15,680
but the problem is that after this line

00:13:14,240 --> 00:13:17,600
so after we change something in the

00:13:15,680 --> 00:13:18,480
object and presumably performs a copy on

00:13:17,600 --> 00:13:21,920
write

00:13:18,480 --> 00:13:22,480
then the object is lost to the gui

00:13:21,920 --> 00:13:25,600
thread

00:13:22,480 --> 00:13:26,079
so it it only has the read only copy so

00:13:25,600 --> 00:13:29,920
it

00:13:26,079 --> 00:13:32,959
will never be able to get the the actual

00:13:29,920 --> 00:13:35,600
write object it has a copy of the of the

00:13:32,959 --> 00:13:37,920
read only object

00:13:35,600 --> 00:13:39,199
so to work with this we can create

00:13:37,920 --> 00:13:41,120
something called object handle

00:13:39,199 --> 00:13:42,959
an object handle can be a shared pointer

00:13:41,120 --> 00:13:45,120
to an object wrapper why not so we have

00:13:42,959 --> 00:13:48,480
a sharepoint result of sharepoint but

00:13:45,120 --> 00:13:49,680
i guess it's fine uh now when we have

00:13:48,480 --> 00:13:52,720
handles we have

00:13:49,680 --> 00:13:55,440
a tiny change to the code itself uh

00:13:52,720 --> 00:13:57,040
the object is now a pointer so we can uh

00:13:55,440 --> 00:13:59,199
we must execute an arrow

00:13:57,040 --> 00:14:00,480
but then the object is always the same

00:13:59,199 --> 00:14:03,279
but uh-oh

00:14:00,480 --> 00:14:05,040
during this line uh we presumably change

00:14:03,279 --> 00:14:07,040
the shared pointer so we we

00:14:05,040 --> 00:14:08,240
replace the shared pointer with another

00:14:07,040 --> 00:14:10,079
one and here

00:14:08,240 --> 00:14:12,079
we read from the shared pointer so we

00:14:10,079 --> 00:14:14,000
read on the we have we have a race on

00:14:12,079 --> 00:14:16,240
the share pointer itself

00:14:14,000 --> 00:14:18,639
so to work with this uh luckily shared

00:14:16,240 --> 00:14:20,480
pointers have atomic stores and loads

00:14:18,639 --> 00:14:22,800
so to work with this we just can use

00:14:20,480 --> 00:14:24,720
those atomic loads on the reads

00:14:22,800 --> 00:14:26,160
in atomic store when we're copying on

00:14:24,720 --> 00:14:29,440
writing

00:14:26,160 --> 00:14:32,480
so that's a tiny change to our code then

00:14:29,440 --> 00:14:34,160
but oh during this line we race on the

00:14:32,480 --> 00:14:37,360
data of the object itself

00:14:34,160 --> 00:14:39,040
of course after all if we decide

00:14:37,360 --> 00:14:41,040
not to copy and write the object at this

00:14:39,040 --> 00:14:41,839
point and start changing it and the very

00:14:41,040 --> 00:14:44,000
next moment

00:14:41,839 --> 00:14:46,639
the gui thread starts reading from the

00:14:44,000 --> 00:14:51,199
object to erase on the object's data

00:14:46,639 --> 00:14:58,079
so what can we do we can

00:14:51,199 --> 00:15:00,800
we can create write locks so um

00:14:58,079 --> 00:15:00,800
happened here

00:15:02,800 --> 00:15:05,040
uh

00:15:08,399 --> 00:15:11,440
i'm sorry i i think i have the wrong

00:15:10,560 --> 00:15:16,560
slides here

00:15:11,440 --> 00:15:16,560
oh my god this is a disaster so

00:15:24,839 --> 00:15:28,720
what

00:15:27,199 --> 00:15:30,240
okay so we can bring back locks

00:15:28,720 --> 00:15:33,600
basically yeah and you can we can

00:15:30,240 --> 00:15:34,399
um we can have read locks and write logs

00:15:33,600 --> 00:15:36,880
to our object

00:15:34,399 --> 00:15:38,880
uh if you erase on the data itself and

00:15:36,880 --> 00:15:40,720
now we can right lock the object here

00:15:38,880 --> 00:15:42,240
and we can read lock the object right

00:15:40,720 --> 00:15:45,440
here in order not to to

00:15:42,240 --> 00:15:48,000
allow basically the okay so yeah

00:15:45,440 --> 00:15:49,360
the solution here is to always copy and

00:15:48,000 --> 00:15:51,680
write i'm sorry about it

00:15:49,360 --> 00:15:53,279
so uh to always copy and write so when

00:15:51,680 --> 00:15:54,639
we always copy and write we have no

00:15:53,279 --> 00:15:57,040
problems we have no

00:15:54,639 --> 00:15:57,680
no databases when we always copy and

00:15:57,040 --> 00:16:00,639
write

00:15:57,680 --> 00:16:02,160
the with well when we always copy and

00:16:00,639 --> 00:16:04,720
write we don't need the read lock

00:16:02,160 --> 00:16:06,079
we do need the right lock but when we

00:16:04,720 --> 00:16:08,480
always copy and write

00:16:06,079 --> 00:16:09,360
uh when we change something we don't

00:16:08,480 --> 00:16:11,279
care what the

00:16:09,360 --> 00:16:12,639
readers currently have they will

00:16:11,279 --> 00:16:15,600
continue using their

00:16:12,639 --> 00:16:16,800
old outdated copy in a way and they'll

00:16:15,600 --> 00:16:19,920
um

00:16:16,800 --> 00:16:20,480
and thus they'll um they'll continue

00:16:19,920 --> 00:16:21,759
reading the

00:16:20,480 --> 00:16:24,079
oral coping when they're finished with

00:16:21,759 --> 00:16:24,959
it it will expire and the memory will be

00:16:24,079 --> 00:16:26,639
released

00:16:24,959 --> 00:16:27,839
and the next change will again copy and

00:16:26,639 --> 00:16:28,639
write and copy and write and copy

00:16:27,839 --> 00:16:31,920
writing

00:16:28,639 --> 00:16:35,279
we may deem this okay because if we're

00:16:31,920 --> 00:16:36,160
okay with copy on writing like copying

00:16:35,279 --> 00:16:38,000
objects

00:16:36,160 --> 00:16:39,680
occasionally then we might as well be

00:16:38,000 --> 00:16:43,040
okay in copying objects

00:16:39,680 --> 00:16:45,279
always why not and this can totally work

00:16:43,040 --> 00:16:46,079
right if we promised right from a single

00:16:45,279 --> 00:16:47,360
thread

00:16:46,079 --> 00:16:49,440
so what if we want to write from

00:16:47,360 --> 00:16:51,600
multiple threads

00:16:49,440 --> 00:16:53,920
we can kind of think about making the

00:16:51,600 --> 00:16:57,680
right objects thread safe but

00:16:53,920 --> 00:16:59,759
in this case we will lose the idea like

00:16:57,680 --> 00:17:01,120
writers won't have to wait on each other

00:16:59,759 --> 00:17:04,240
and then there will be

00:17:01,120 --> 00:17:06,959
no notion of the correct object with the

00:17:04,240 --> 00:17:07,679
the real object so this is an

00:17:06,959 --> 00:17:09,360
appropriate

00:17:07,679 --> 00:17:11,199
place basically to to bring up the

00:17:09,360 --> 00:17:14,240
heavier artillery and

00:17:11,199 --> 00:17:16,160
add an axis mutex so

00:17:14,240 --> 00:17:18,079
we can add a mutex and then we can right

00:17:16,160 --> 00:17:20,160
lock when we write log

00:17:18,079 --> 00:17:21,199
we log the mutex and we write unlock we

00:17:20,160 --> 00:17:23,520
unlock the mutex and

00:17:21,199 --> 00:17:24,240
writes are synchronized and they happen

00:17:23,520 --> 00:17:27,839
in

00:17:24,240 --> 00:17:30,880
a certain order and this is basically

00:17:27,839 --> 00:17:33,440
uh what we call immutable objects why

00:17:30,880 --> 00:17:34,880
immutable you can think of it as you do

00:17:33,440 --> 00:17:37,120
of string view

00:17:34,880 --> 00:17:38,799
uh you don't change the object itself

00:17:37,120 --> 00:17:41,600
you replace the object and

00:17:38,799 --> 00:17:42,799
you the the original object remains as

00:17:41,600 --> 00:17:44,559
it is

00:17:42,799 --> 00:17:46,000
in this case you replace it with a copy

00:17:44,559 --> 00:17:49,919
like string view has certain

00:17:46,000 --> 00:17:52,640
operations like uh the replays or um

00:17:49,919 --> 00:17:53,200
um append or stuff like this which will

00:17:52,640 --> 00:17:55,679
return

00:17:53,200 --> 00:17:57,919
another not replace but like uh not

00:17:55,679 --> 00:17:59,440
replace string view is immutable so uh

00:17:57,919 --> 00:18:01,120
it doesn't change the actual data but

00:17:59,440 --> 00:18:04,240
say get a substring view

00:18:01,120 --> 00:18:06,559
for this so what if we do want the

00:18:04,240 --> 00:18:08,799
optional copy and right then

00:18:06,559 --> 00:18:10,480
and uh i do have slides for this but i'm

00:18:08,799 --> 00:18:14,720
not going to present them in

00:18:10,480 --> 00:18:17,039
the interest of time i guess so um

00:18:14,720 --> 00:18:18,320
let's decide that we we are not willing

00:18:17,039 --> 00:18:21,120
to pay the price

00:18:18,320 --> 00:18:22,799
which we we we will if we have an

00:18:21,120 --> 00:18:25,200
optional copy and write we will

00:18:22,799 --> 00:18:27,280
decide to live with always copy on the

00:18:25,200 --> 00:18:31,600
right part

00:18:27,280 --> 00:18:31,600
so um oops

00:18:32,640 --> 00:18:37,200
let's improve the terminology right now

00:18:35,600 --> 00:18:37,919
we call this read but read is too

00:18:37,200 --> 00:18:40,000
generic

00:18:37,919 --> 00:18:43,280
uh i mentioned that when we always copy

00:18:40,000 --> 00:18:45,120
and write the moment that we get a read

00:18:43,280 --> 00:18:46,480
or like a read lock of the object i

00:18:45,120 --> 00:18:47,840
guess even though read lock is not

00:18:46,480 --> 00:18:49,840
needed but the moment we

00:18:47,840 --> 00:18:51,039
call read for the object we receive a

00:18:49,840 --> 00:18:53,760
copy which

00:18:51,039 --> 00:18:54,160
in the very next moment can be outdated

00:18:53,760 --> 00:18:57,200
so

00:18:54,160 --> 00:18:58,400
the touch expresses this uh this

00:18:57,200 --> 00:19:01,360
functionality much better

00:18:58,400 --> 00:19:03,120
like detach means that when you get a

00:19:01,360 --> 00:19:03,600
detached version that's not the object

00:19:03,120 --> 00:19:07,280
anymore

00:19:03,600 --> 00:19:09,200
it's not a handle you don't uh

00:19:07,280 --> 00:19:11,280
it will always remain the same it will

00:19:09,200 --> 00:19:12,799
always remain the same and immutable

00:19:11,280 --> 00:19:14,400
if you make changes to the original

00:19:12,799 --> 00:19:16,400
objects your detached version will

00:19:14,400 --> 00:19:18,640
always remain the same

00:19:16,400 --> 00:19:20,160
and write lock is also i guess too

00:19:18,640 --> 00:19:22,720
generic so

00:19:20,160 --> 00:19:24,240
we can rename it with with i don't know

00:19:22,720 --> 00:19:26,080
begin and end transactions so

00:19:24,240 --> 00:19:28,080
that's basically what we're doing we are

00:19:26,080 --> 00:19:30,799
creating thanks to the mutex

00:19:28,080 --> 00:19:32,640
an atomic transaction on the object when

00:19:30,799 --> 00:19:34,799
we when we do this

00:19:32,640 --> 00:19:35,760
uh and we can rename the mutex of course

00:19:34,799 --> 00:19:38,240
and uh

00:19:35,760 --> 00:19:39,360
while we're at it why not add an

00:19:38,240 --> 00:19:41,679
optional

00:19:39,360 --> 00:19:43,600
way to to store the transaction so if we

00:19:41,679 --> 00:19:44,320
can decide to cancel the transaction in

00:19:43,600 --> 00:19:46,720
this case

00:19:44,320 --> 00:19:49,280
we we just won't touch the object

00:19:46,720 --> 00:19:49,280
whatsoever

00:19:49,360 --> 00:19:54,960
so our immutable object so far we have

00:19:52,480 --> 00:19:55,679
atomic transactions which are

00:19:54,960 --> 00:19:58,880
synchronized

00:19:55,679 --> 00:19:59,440
rights for many threads we always copy

00:19:58,880 --> 00:20:01,840
and write

00:19:59,440 --> 00:20:03,919
when we do a transaction but we have the

00:20:01,840 --> 00:20:04,720
fastest possible lockless reads by

00:20:03,919 --> 00:20:07,280
detaching

00:20:04,720 --> 00:20:09,200
when you detach from an object you get

00:20:07,280 --> 00:20:09,440
your data and you work with it and then

00:20:09,200 --> 00:20:12,480
you

00:20:09,440 --> 00:20:13,919
throw it away and that's that um and

00:20:12,480 --> 00:20:15,840
yeah the test object is possibly

00:20:13,919 --> 00:20:17,679
outdated you cannot rely that once you

00:20:15,840 --> 00:20:22,240
detach an object it will be

00:20:17,679 --> 00:20:24,320
the current state of affairs basically

00:20:22,240 --> 00:20:25,840
but um every reference to the attached

00:20:24,320 --> 00:20:28,880
object is safe and valid

00:20:25,840 --> 00:20:31,039
and immutable forever and yeah

00:20:28,880 --> 00:20:33,520
what we did basically can be called a

00:20:31,039 --> 00:20:36,240
glorified shared pointer wrapper

00:20:33,520 --> 00:20:38,559
but as we'll see it kind of leads us to

00:20:36,240 --> 00:20:41,280
a different way of thinking

00:20:38,559 --> 00:20:43,039
and indeed when we first started working

00:20:41,280 --> 00:20:44,000
on our objects we didn't think much of

00:20:43,039 --> 00:20:46,480
it

00:20:44,000 --> 00:20:47,280
it took us roughly a year and a half to

00:20:46,480 --> 00:20:50,080
to get

00:20:47,280 --> 00:20:50,640
to i know to our object's current state

00:20:50,080 --> 00:20:52,880
so

00:20:50,640 --> 00:20:54,480
of planning and designing and tweaking

00:20:52,880 --> 00:20:56,080
things and hopefully for

00:20:54,480 --> 00:20:57,760
less than a year i'll be able to explain

00:20:56,080 --> 00:21:00,880
what we do but

00:20:57,760 --> 00:21:01,440
um we were like okay that's a nice nice

00:21:00,880 --> 00:21:03,679
thing but

00:21:01,440 --> 00:21:05,280
we we started pursuing the the slides

00:21:03,679 --> 00:21:08,320
that i didn't present the

00:21:05,280 --> 00:21:11,760
optional copy and writes but

00:21:08,320 --> 00:21:14,799
um this is this is basically

00:21:11,760 --> 00:21:17,840
a lot like react js because our

00:21:14,799 --> 00:21:18,640
uh used graphical user interface is in

00:21:17,840 --> 00:21:21,120
the browser

00:21:18,640 --> 00:21:23,039
we did have a lot of a lot to do with

00:21:21,120 --> 00:21:26,640
react.js and

00:21:23,039 --> 00:21:30,320
many other um actual browser

00:21:26,640 --> 00:21:32,559
front-end frameworks are similar

00:21:30,320 --> 00:21:33,360
but we started thinking okay well this

00:21:32,559 --> 00:21:36,880
is a lot like

00:21:33,360 --> 00:21:38,320
react.js and what is react.js basically

00:21:36,880 --> 00:21:39,280
i'm going to do the shortest and

00:21:38,320 --> 00:21:41,440
possibly most

00:21:39,280 --> 00:21:44,000
useless presentation of what react.js

00:21:41,440 --> 00:21:46,400
does uh it's basically a gui library for

00:21:44,000 --> 00:21:49,520
single page applications

00:21:46,400 --> 00:21:50,080
you take a state like kind of a plain

00:21:49,520 --> 00:21:53,360
old

00:21:50,080 --> 00:21:55,200
javascript object the pojo uh you

00:21:53,360 --> 00:21:57,360
and based on the state you create the

00:21:55,200 --> 00:21:59,840
dom the elements and

00:21:57,360 --> 00:22:00,400
the elements which comprise your web

00:21:59,840 --> 00:22:02,799
page

00:22:00,400 --> 00:22:04,159
and that's it as i said the most useless

00:22:02,799 --> 00:22:06,799
presentation isn't it

00:22:04,159 --> 00:22:07,280
but let's see an example so let's see an

00:22:06,799 --> 00:22:09,679
example

00:22:07,280 --> 00:22:11,360
without one of our states of course our

00:22:09,679 --> 00:22:14,000
installation doesn't necessarily

00:22:11,360 --> 00:22:15,600
need to be used for treatment it has an

00:22:14,000 --> 00:22:17,280
mri attached to it so you can

00:22:15,600 --> 00:22:18,640
use it for plain old imaging like a

00:22:17,280 --> 00:22:21,039
regular mri

00:22:18,640 --> 00:22:22,880
so let's try to envision what this state

00:22:21,039 --> 00:22:24,640
might look like in javascript

00:22:22,880 --> 00:22:26,080
so we have an imaging state we have a

00:22:24,640 --> 00:22:28,480
patient we have an image

00:22:26,080 --> 00:22:29,679
with some data like named nodes size and

00:22:28,480 --> 00:22:32,880
buffer with the actual

00:22:29,679 --> 00:22:34,799
uh voxels of the the image and we have

00:22:32,880 --> 00:22:36,960
the table position which we can move so

00:22:34,799 --> 00:22:40,080
we can adjust the patient in the

00:22:36,960 --> 00:22:43,360
best possible position so

00:22:40,080 --> 00:22:44,640
um and to build gui we call we call the

00:22:43,360 --> 00:22:47,039
build gui function

00:22:44,640 --> 00:22:48,000
and that's it it will produce the

00:22:47,039 --> 00:22:50,480
appropriate

00:22:48,000 --> 00:22:51,280
dom the appropriate web page for this

00:22:50,480 --> 00:22:53,360
state

00:22:51,280 --> 00:22:55,679
and it doesn't need anything more it

00:22:53,360 --> 00:22:57,760
only needs the state

00:22:55,679 --> 00:22:59,679
so if we want to change the state we can

00:22:57,760 --> 00:23:00,080
have javascript function like this so we

00:22:59,679 --> 00:23:02,720
can

00:23:00,080 --> 00:23:03,840
return an object which only addresses

00:23:02,720 --> 00:23:06,000
certain elements

00:23:03,840 --> 00:23:07,840
of the actual state and thanks to

00:23:06,000 --> 00:23:10,480
javascript reflection

00:23:07,840 --> 00:23:11,840
this will be appropriately spliced onto

00:23:10,480 --> 00:23:14,080
the state

00:23:11,840 --> 00:23:15,600
so these are two simple examples like

00:23:14,080 --> 00:23:18,480
set image name to some cool

00:23:15,600 --> 00:23:19,120
image and shift the table to some to

00:23:18,480 --> 00:23:20,799
some minor

00:23:19,120 --> 00:23:23,039
relative position based on the previous

00:23:20,799 --> 00:23:23,039
one

00:23:23,679 --> 00:23:27,440
so how do we splice objects onto the

00:23:25,679 --> 00:23:28,080
state let's see the set image name

00:23:27,440 --> 00:23:30,159
function

00:23:28,080 --> 00:23:31,919
uh it has an image a name okay and

00:23:30,159 --> 00:23:34,480
thanks to reflection we can

00:23:31,919 --> 00:23:36,159
find that this address is image then

00:23:34,480 --> 00:23:39,840
name and only change

00:23:36,159 --> 00:23:43,840
the name so javascript objects are a lot

00:23:39,840 --> 00:23:44,640
like uh shared pointers for most intents

00:23:43,840 --> 00:23:47,200
and purposes

00:23:44,640 --> 00:23:47,760
they are shared pointers so a javascript

00:23:47,200 --> 00:23:49,520
object

00:23:47,760 --> 00:23:51,360
if you compare them it will compare

00:23:49,520 --> 00:23:53,120
their addresses if you create a new

00:23:51,360 --> 00:23:53,360
object that's basically a new instance

00:23:53,120 --> 00:23:56,159
of

00:23:53,360 --> 00:23:56,640
set shared pointer and they're mutable

00:23:56,159 --> 00:24:00,080
too

00:23:56,640 --> 00:24:01,760
so we can do this with no problem we can

00:24:00,080 --> 00:24:05,679
find the name and we can change it to

00:24:01,760 --> 00:24:08,799
cool image but what happens then

00:24:05,679 --> 00:24:09,679
for example let's have the old state be

00:24:08,799 --> 00:24:11,919
something

00:24:09,679 --> 00:24:13,679
we can splice the set image name

00:24:11,919 --> 00:24:16,559
function onto the current state

00:24:13,679 --> 00:24:18,240
and then we can assert that the all

00:24:16,559 --> 00:24:18,799
state is different from the current

00:24:18,240 --> 00:24:21,840
state but

00:24:18,799 --> 00:24:24,799
oh we only changed the name as

00:24:21,840 --> 00:24:27,120
john bon jovi said we only change the

00:24:24,799 --> 00:24:30,640
name so the state the actual root

00:24:27,120 --> 00:24:31,760
object is different so instead what

00:24:30,640 --> 00:24:34,880
react does

00:24:31,760 --> 00:24:37,919
is it changes every object

00:24:34,880 --> 00:24:39,360
performing shallow copy on writes so if

00:24:37,919 --> 00:24:41,440
we change the state we create a new

00:24:39,360 --> 00:24:44,080
state we copy everything

00:24:41,440 --> 00:24:44,799
uh from it but only the addresses so it

00:24:44,080 --> 00:24:46,240
will receive

00:24:44,799 --> 00:24:48,000
in the initial copy we'll see the same

00:24:46,240 --> 00:24:48,559
patient same same table then we change

00:24:48,000 --> 00:24:49,919
the image

00:24:48,559 --> 00:24:52,159
the patient and the table remain the

00:24:49,919 --> 00:24:53,600
same so if we compare the all states

00:24:52,159 --> 00:24:54,720
patients within with the new stage

00:24:53,600 --> 00:24:56,720
patients it will be the same

00:24:54,720 --> 00:24:58,080
but if we compare the whole state and

00:24:56,720 --> 00:24:59,440
the new state they'll be different if we

00:24:58,080 --> 00:25:01,200
compare the image and the name

00:24:59,440 --> 00:25:03,200
they'll be different and everything's

00:25:01,200 --> 00:25:08,000
fine right now

00:25:03,200 --> 00:25:10,000
so how does this help

00:25:08,000 --> 00:25:11,200
for example it does help with building

00:25:10,000 --> 00:25:13,840
gui we can

00:25:11,200 --> 00:25:15,600
memoize certain elements of the state

00:25:13,840 --> 00:25:17,440
and if for example the state hasn't

00:25:15,600 --> 00:25:20,240
changed we can return nodes so

00:25:17,440 --> 00:25:21,919
make no changes here if the image hasn't

00:25:20,240 --> 00:25:22,559
changed we can return also make no

00:25:21,919 --> 00:25:24,559
changes here

00:25:22,559 --> 00:25:25,760
otherwise we can return some kind of a

00:25:24,559 --> 00:25:28,480
dom object

00:25:25,760 --> 00:25:29,360
at this point and this is the

00:25:28,480 --> 00:25:33,039
optimization

00:25:29,360 --> 00:25:33,440
isn't it and then we we said something

00:25:33,039 --> 00:25:36,640
like

00:25:33,440 --> 00:25:38,080
um react style react.js style state and

00:25:36,640 --> 00:25:41,120
c

00:25:38,080 --> 00:25:42,240
that would be pretty cool and then of

00:25:41,120 --> 00:25:44,320
course many

00:25:42,240 --> 00:25:45,760
many people at this point would ask but

00:25:44,320 --> 00:25:48,559
but why like

00:25:45,760 --> 00:25:49,440
why would it be cool the thing is that

00:25:48,559 --> 00:25:51,679
imagine this

00:25:49,440 --> 00:25:52,640
um in simplesplus we can build a gui

00:25:51,679 --> 00:25:56,320
like this

00:25:52,640 --> 00:25:59,279
we get the state we build gui it works

00:25:56,320 --> 00:26:00,240
but also we can run workers uh we can

00:25:59,279 --> 00:26:02,240
get the state

00:26:00,240 --> 00:26:04,080
we can run the bladder worker and

00:26:02,240 --> 00:26:06,080
imagine these start different threads

00:26:04,080 --> 00:26:07,840
and it will start finding the the

00:26:06,080 --> 00:26:08,640
bladder of the patient find the femurs

00:26:07,840 --> 00:26:10,640
of the patient

00:26:08,640 --> 00:26:11,679
he can calculate the electron density

00:26:10,640 --> 00:26:15,039
for example

00:26:11,679 --> 00:26:16,159
um and those threads will work and

00:26:15,039 --> 00:26:17,919
they'll be fine

00:26:16,159 --> 00:26:19,840
uh even if we change if we make changes

00:26:17,919 --> 00:26:21,440
to the state itself even if we make

00:26:19,840 --> 00:26:22,880
changes to the image they'll continue

00:26:21,440 --> 00:26:23,440
working with an outdated version of the

00:26:22,880 --> 00:26:25,120
image but

00:26:23,440 --> 00:26:28,559
they we wouldn't need to synchronize

00:26:25,120 --> 00:26:30,559
them at every possible point

00:26:28,559 --> 00:26:32,320
um and also and when we do is pretty

00:26:30,559 --> 00:26:32,880
easy for example if we create an undo

00:26:32,320 --> 00:26:35,919
action

00:26:32,880 --> 00:26:37,360
and we uh set the the ladder from for

00:26:35,919 --> 00:26:39,760
the same direction to the current one

00:26:37,360 --> 00:26:40,559
then we apply the manual user id to the

00:26:39,760 --> 00:26:43,120
bladder

00:26:40,559 --> 00:26:43,919
and then we can set the current state of

00:26:43,120 --> 00:26:45,360
the of

00:26:43,919 --> 00:26:47,120
the current version of the bladder to

00:26:45,360 --> 00:26:48,000
the interaction that's pretty easy and

00:26:47,120 --> 00:26:49,679
it's it's

00:26:48,000 --> 00:26:52,240
it comes naturally basically to create

00:26:49,679 --> 00:26:55,200
and doing video actions with this

00:26:52,240 --> 00:26:57,520
but there's one thing that that's much

00:26:55,200 --> 00:26:59,919
more important than all these

00:26:57,520 --> 00:27:02,080
and that's integration testing by unit

00:26:59,919 --> 00:27:05,440
testing and what do i mean by that

00:27:02,080 --> 00:27:07,039
so here's the thought if we magically

00:27:05,440 --> 00:27:09,279
create our objects and we

00:27:07,039 --> 00:27:11,279
have uh build the build grid function in

00:27:09,279 --> 00:27:14,480
c plus plus

00:27:11,279 --> 00:27:16,559
what if we do that we can

00:27:14,480 --> 00:27:18,799
get some pretty predefined state some

00:27:16,559 --> 00:27:21,279
something hard coded in our application

00:27:18,799 --> 00:27:22,320
we can call bill guin then we can assert

00:27:21,279 --> 00:27:25,440
that the

00:27:22,320 --> 00:27:26,480
gui that we have currently after calling

00:27:25,440 --> 00:27:29,440
build gui

00:27:26,480 --> 00:27:30,080
is the one that we expected that's a

00:27:29,440 --> 00:27:33,520
nice

00:27:30,080 --> 00:27:35,360
test that's really nice actually that's

00:27:33,520 --> 00:27:37,360
the best way to test something a unit

00:27:35,360 --> 00:27:40,399
test in this case

00:27:37,360 --> 00:27:41,440
what if what if it has some predefined

00:27:40,399 --> 00:27:43,679
state

00:27:41,440 --> 00:27:44,880
what if you run i know a treatment

00:27:43,679 --> 00:27:47,120
function of sorts

00:27:44,880 --> 00:27:48,000
which receives another function receive

00:27:47,120 --> 00:27:51,360
new image from

00:27:48,000 --> 00:27:54,399
mri with this image and then apply

00:27:51,360 --> 00:27:57,120
this action in some way to the state

00:27:54,399 --> 00:27:58,960
then we can assert that the deep compare

00:27:57,120 --> 00:28:02,240
of the current state

00:27:58,960 --> 00:28:03,039
is the same between and the expected

00:28:02,240 --> 00:28:06,240
state

00:28:03,039 --> 00:28:08,320
is the written as one so i didn't

00:28:06,240 --> 00:28:11,600
express myself really clearly here but

00:28:08,320 --> 00:28:13,919
you get a picture we can we can test

00:28:11,600 --> 00:28:16,399
that the treatment with the action

00:28:13,919 --> 00:28:18,399
receive new image from mri works okay

00:28:16,399 --> 00:28:20,559
and this is big ben bang integration

00:28:18,399 --> 00:28:22,880
testing so we have the entire treatment

00:28:20,559 --> 00:28:24,240
logic inside of the treatment function

00:28:22,880 --> 00:28:25,919
and we test it

00:28:24,240 --> 00:28:27,520
and that's big bang integration testing

00:28:25,919 --> 00:28:30,320
when you have the entire thing and you

00:28:27,520 --> 00:28:32,000
test it as it is is typically frowned

00:28:30,320 --> 00:28:34,000
upon so uh people prefer

00:28:32,000 --> 00:28:35,039
for example uh bottom-up integration

00:28:34,000 --> 00:28:36,720
testing and

00:28:35,039 --> 00:28:39,200
bottom-up integration testing will be to

00:28:36,720 --> 00:28:41,039
test a certain sub-module of the

00:28:39,200 --> 00:28:42,399
of the treatment and treatment we have

00:28:41,039 --> 00:28:44,240
imaging uh

00:28:42,399 --> 00:28:45,760
if you remember the first part of the

00:28:44,240 --> 00:28:46,960
treatment we started with taking an

00:28:45,760 --> 00:28:48,559
image from the patient

00:28:46,960 --> 00:28:50,640
so we can test the imaging with the

00:28:48,559 --> 00:28:51,360
exact same receive new image from mri

00:28:50,640 --> 00:28:54,720
function

00:28:51,360 --> 00:28:56,960
and deep compare the imaging state

00:28:54,720 --> 00:28:58,240
people also like top-down integration

00:28:56,960 --> 00:29:01,360
testing

00:28:58,240 --> 00:29:03,039
so if we i know create the imaging

00:29:01,360 --> 00:29:04,320
function which is a mock we create a

00:29:03,039 --> 00:29:06,159
mock of the imaging function that

00:29:04,320 --> 00:29:07,760
instead of connecting to the mri it just

00:29:06,159 --> 00:29:11,120
loads some kind of image

00:29:07,760 --> 00:29:14,000
and then adds it to the state

00:29:11,120 --> 00:29:15,760
then we can mock certain elements and

00:29:14,000 --> 00:29:18,000
just test treatment with

00:29:15,760 --> 00:29:19,279
uh its sub modules mocked in a way this

00:29:18,000 --> 00:29:22,559
is pseudocode

00:29:19,279 --> 00:29:25,760
don't be too harsh on it but

00:29:22,559 --> 00:29:26,399
basically all uh forms of integration

00:29:25,760 --> 00:29:29,440
testing

00:29:26,399 --> 00:29:31,679
are possible and what's what what

00:29:29,440 --> 00:29:32,880
do i how can i express myself more

00:29:31,679 --> 00:29:35,200
clearly here

00:29:32,880 --> 00:29:35,919
the thing is that if the application

00:29:35,200 --> 00:29:39,279
state

00:29:35,919 --> 00:29:40,159
is in a single object then everything

00:29:39,279 --> 00:29:44,320
the application

00:29:40,159 --> 00:29:47,679
does can be expressed as a pure function

00:29:44,320 --> 00:29:49,039
and uh like like this one pure function

00:29:47,679 --> 00:29:50,640
do something with the state and return

00:29:49,039 --> 00:29:52,399
the new version of the state

00:29:50,640 --> 00:29:53,679
and pure functions we know how to test

00:29:52,399 --> 00:29:56,000
pure functions

00:29:53,679 --> 00:29:56,799
are unit tested you don't need

00:29:56,000 --> 00:29:58,960
complicated

00:29:56,799 --> 00:30:01,200
integration testing scripts you don't

00:29:58,960 --> 00:30:01,200
need

00:30:01,360 --> 00:30:05,360
complicated setups we can test pure

00:30:04,399 --> 00:30:07,679
functions

00:30:05,360 --> 00:30:08,880
it would be really great to have pure

00:30:07,679 --> 00:30:10,799
functions

00:30:08,880 --> 00:30:12,480
to have the entire logic of the

00:30:10,799 --> 00:30:14,240
application inside of pure functions

00:30:12,480 --> 00:30:16,320
that's what for example haskell

00:30:14,240 --> 00:30:19,120
programmers love

00:30:16,320 --> 00:30:20,240
you can you you can integration test by

00:30:19,120 --> 00:30:23,360
unit testing

00:30:20,240 --> 00:30:26,080
but moreover um since

00:30:23,360 --> 00:30:28,000
all modules are pure functions then

00:30:26,080 --> 00:30:29,600
mocks are trivial as you see as you saw

00:30:28,000 --> 00:30:32,000
you just can we write

00:30:29,600 --> 00:30:33,120
a complicated function that does

00:30:32,000 --> 00:30:34,799
complicated stuff

00:30:33,120 --> 00:30:36,559
on the state itself you can rewrite it

00:30:34,799 --> 00:30:39,120
with some kind of hardcoded

00:30:36,559 --> 00:30:39,679
value and if the entire state is an

00:30:39,120 --> 00:30:42,480
object

00:30:39,679 --> 00:30:42,960
it's a single object then fuzzing if

00:30:42,480 --> 00:30:45,600
well

00:30:42,960 --> 00:30:47,919
easy is perhaps an overstatement but

00:30:45,600 --> 00:30:50,559
fuzzing like creating random values

00:30:47,919 --> 00:30:51,039
random valid values is least feasible we

00:30:50,559 --> 00:30:53,200
have an

00:30:51,039 --> 00:30:54,480
idea of how to approach fuzzing in this

00:30:53,200 --> 00:30:58,080
state

00:30:54,480 --> 00:30:59,840
and since it's a single object and we

00:30:58,080 --> 00:31:01,039
can serialize objects and we can save

00:30:59,840 --> 00:31:02,799
them and load them

00:31:01,039 --> 00:31:05,200
for example if we crash and we have

00:31:02,799 --> 00:31:06,960
somehow stored our latest state

00:31:05,200 --> 00:31:09,360
we can resume from the crashes if

00:31:06,960 --> 00:31:11,360
nothing happens we can store

00:31:09,360 --> 00:31:13,039
continuously certain versions of the

00:31:11,360 --> 00:31:14,559
state not every version of the state and

00:31:13,039 --> 00:31:16,640
at least certain ones

00:31:14,559 --> 00:31:18,000
and then we can have some kind of

00:31:16,640 --> 00:31:20,960
jumping time debugging

00:31:18,000 --> 00:31:22,880
like we can just load this tape uh oh i

00:31:20,960 --> 00:31:24,080
have a bug right now okay so what's the

00:31:22,880 --> 00:31:25,840
previous version of the state let's

00:31:24,080 --> 00:31:27,039
rerun it let's see let's find the bug

00:31:25,840 --> 00:31:29,919
here

00:31:27,039 --> 00:31:30,240
so if if we weren't sold at this point

00:31:29,919 --> 00:31:33,760
then

00:31:30,240 --> 00:31:35,919
we were at least intrigued anyway back

00:31:33,760 --> 00:31:38,000
to the objects

00:31:35,919 --> 00:31:39,200
so this glorified shared point of

00:31:38,000 --> 00:31:41,279
wrapper

00:31:39,200 --> 00:31:42,640
how does it compare it with rgs so we

00:31:41,279 --> 00:31:45,120
have shallow compares of course

00:31:42,640 --> 00:31:46,559
shared pointers are compared by address

00:31:45,120 --> 00:31:47,600
and note that this is not string view

00:31:46,559 --> 00:31:49,760
and your string viewer

00:31:47,600 --> 00:31:52,159
is compared by data by the contents by

00:31:49,760 --> 00:31:55,200
the what the string view points at

00:31:52,159 --> 00:31:57,519
um and we copy and write on every change

00:31:55,200 --> 00:31:58,320
change much like react does the splicing

00:31:57,519 --> 00:32:02,880
like changes

00:31:58,320 --> 00:32:05,039
every node of the state tree

00:32:02,880 --> 00:32:06,720
and detached references are safe and

00:32:05,039 --> 00:32:09,840
valid forever much like

00:32:06,720 --> 00:32:11,519
reacts objects so let's try to build the

00:32:09,840 --> 00:32:14,640
states in simple plus

00:32:11,519 --> 00:32:16,640
but first some i know minor changes to

00:32:14,640 --> 00:32:18,559
the object i guess

00:32:16,640 --> 00:32:20,880
first of all we now know what the object

00:32:18,559 --> 00:32:23,679
holds and the the answer is

00:32:20,880 --> 00:32:24,480
something so of course it's template and

00:32:23,679 --> 00:32:26,720
we don't need

00:32:24,480 --> 00:32:28,320
this wrapper part of the name right now

00:32:26,720 --> 00:32:30,720
okay it's template okay so we can just

00:32:28,320 --> 00:32:33,200
call it object

00:32:30,720 --> 00:32:34,799
and uh the thing that is inside of the

00:32:33,200 --> 00:32:38,080
object we can just call data

00:32:34,799 --> 00:32:40,480
and uh we can call the transaction

00:32:38,080 --> 00:32:42,000
the thing transaction data so i don't

00:32:40,480 --> 00:32:45,360
minor changes

00:32:42,000 --> 00:32:47,120
um and again um the what used to be

00:32:45,360 --> 00:32:50,640
write log before we now call

00:32:47,120 --> 00:32:52,080
transaction um and we can make use of

00:32:50,640 --> 00:32:54,840
the fact that we can

00:32:52,080 --> 00:32:56,559
optionally store and uh or cancel

00:32:54,840 --> 00:32:58,559
transactions and just

00:32:56,559 --> 00:32:59,919
if there are no exceptions don't store

00:32:58,559 --> 00:33:00,559
the transaction so if we throw an

00:32:59,919 --> 00:33:02,880
exception

00:33:00,559 --> 00:33:04,399
uh the transaction is cancelled while

00:33:02,880 --> 00:33:06,480
doing the transaction itself

00:33:04,399 --> 00:33:08,080
that is so let's build a state it's

00:33:06,480 --> 00:33:10,320
equal plus

00:33:08,080 --> 00:33:12,080
we have the same patient data with

00:33:10,320 --> 00:33:14,000
orientation and weight of the patient we

00:33:12,080 --> 00:33:16,159
have image data with all the jazz we

00:33:14,000 --> 00:33:19,279
have table data and everything

00:33:16,159 --> 00:33:21,200
um and we can just create an object from

00:33:19,279 --> 00:33:23,039
this image extent can't we

00:33:21,200 --> 00:33:24,480
this is a terrible idea though because

00:33:23,039 --> 00:33:24,960
when we do copy and write we copy

00:33:24,480 --> 00:33:28,559
everything

00:33:24,960 --> 00:33:30,159
we copy the the huge image buffer we

00:33:28,559 --> 00:33:32,320
have copy strings we copy

00:33:30,159 --> 00:33:33,760
even if we change the the progress of

00:33:32,320 --> 00:33:35,760
the table movement

00:33:33,760 --> 00:33:37,120
we need to copy the whole image buffer

00:33:35,760 --> 00:33:39,600
which is tens of megabytes

00:33:37,120 --> 00:33:40,559
okay not a good idea so let's are more

00:33:39,600 --> 00:33:42,559
objects per heads

00:33:40,559 --> 00:33:44,559
but again if we change the progress of

00:33:42,559 --> 00:33:46,000
the image in this case an image is an

00:33:44,559 --> 00:33:47,279
object right now if we change the table

00:33:46,000 --> 00:33:49,039
we won't change the image

00:33:47,279 --> 00:33:50,559
it will perform a shallow copy and write

00:33:49,039 --> 00:33:52,559
but the buffer is still copied

00:33:50,559 --> 00:33:54,080
if we change only progress or the name

00:33:52,559 --> 00:33:56,320
so that's not a good idea so

00:33:54,080 --> 00:33:57,840
let's make everything an object i guess

00:33:56,320 --> 00:34:00,480
but the float

00:33:57,840 --> 00:34:01,840
is not it's not why would we make an

00:34:00,480 --> 00:34:04,960
object out on the floor

00:34:01,840 --> 00:34:08,079
why would we carry the

00:34:04,960 --> 00:34:08,560
whole uh shebang of the sharepoint as

00:34:08,079 --> 00:34:11,839
far as

00:34:08,560 --> 00:34:13,520
mirror float so some objects is i guess

00:34:11,839 --> 00:34:14,480
the answer and here we come across one

00:34:13,520 --> 00:34:17,520
of the first

00:34:14,480 --> 00:34:20,720
issues with with this pattern i guess

00:34:17,520 --> 00:34:21,200
it's hard it's hard to to to to come up

00:34:20,720 --> 00:34:24,879
with

00:34:21,200 --> 00:34:28,399
uh with a good structure

00:34:24,879 --> 00:34:30,639
of the state it's it's actually

00:34:28,399 --> 00:34:31,440
the most hardest thing to do uh in this

00:34:30,639 --> 00:34:33,280
case

00:34:31,440 --> 00:34:35,280
but okay let's say we're we're happy

00:34:33,280 --> 00:34:36,960
with this

00:34:35,280 --> 00:34:38,560
let's try working with it so in

00:34:36,960 --> 00:34:39,200
javascript we have the set image name

00:34:38,560 --> 00:34:42,240
function

00:34:39,200 --> 00:34:43,440
and we set it with image and name with

00:34:42,240 --> 00:34:45,919
some cool image

00:34:43,440 --> 00:34:47,679
and what do we do now we have

00:34:45,919 --> 00:34:48,720
transaction of transaction of

00:34:47,679 --> 00:34:50,159
transaction

00:34:48,720 --> 00:34:52,639
transaction of the name of the image of

00:34:50,159 --> 00:34:54,079
the state okay equals cool image

00:34:52,639 --> 00:34:56,079
and that's a lot of transactions so it's

00:34:54,079 --> 00:34:59,119
not really nice to write

00:34:56,079 --> 00:35:01,440
okay but we can live with this um

00:34:59,119 --> 00:35:02,800
but each transaction if you remember uh

00:35:01,440 --> 00:35:06,320
does a mutex lock

00:35:02,800 --> 00:35:07,520
so that's three uh as i said recursive

00:35:06,320 --> 00:35:10,560
mutex locks

00:35:07,520 --> 00:35:13,760
which is again not necessarily terrible

00:35:10,560 --> 00:35:15,119
it's it's in any case it's very

00:35:13,760 --> 00:35:18,400
dangerous to have

00:35:15,119 --> 00:35:18,400
deadlocks in this case like

00:35:18,960 --> 00:35:22,720
it's not forbidden to make transactions

00:35:20,960 --> 00:35:24,320
out of order in this case so we can

00:35:22,720 --> 00:35:25,760
detach something make transactions and

00:35:24,320 --> 00:35:26,800
then we detach something else make

00:35:25,760 --> 00:35:28,960
another transaction

00:35:26,800 --> 00:35:31,119
it's dangerous but that's not the worst

00:35:28,960 --> 00:35:33,359
part the worst part

00:35:31,119 --> 00:35:34,800
if we have an image and that's a lot of

00:35:33,359 --> 00:35:36,800
the patches here i see

00:35:34,800 --> 00:35:38,880
but uh we can perform a transaction on

00:35:36,800 --> 00:35:40,320
this image on the image's name i guess

00:35:38,880 --> 00:35:41,359
in the transaction the images name and

00:35:40,320 --> 00:35:43,040
say

00:35:41,359 --> 00:35:45,040
set it to something different and let's

00:35:43,040 --> 00:35:47,520
assume that the previous value of the

00:35:45,040 --> 00:35:49,520
name wasn't something different

00:35:47,520 --> 00:35:51,040
and now we can get the image from the

00:35:49,520 --> 00:35:54,400
state again

00:35:51,040 --> 00:35:57,119
and when we compare the values

00:35:54,400 --> 00:35:57,760
oops both are something different that's

00:35:57,119 --> 00:35:59,920
because

00:35:57,760 --> 00:36:02,079
this is this is really thread safe this

00:35:59,920 --> 00:36:04,800
is it won't crash or anything

00:36:02,079 --> 00:36:05,440
but the thing is that when you in this

00:36:04,800 --> 00:36:08,480
in a way

00:36:05,440 --> 00:36:11,040
every um object is an object handle

00:36:08,480 --> 00:36:12,160
so when you perform a transaction the

00:36:11,040 --> 00:36:14,079
owner of the object

00:36:12,160 --> 00:36:15,520
continues to to store reference to the

00:36:14,079 --> 00:36:18,640
object handle itself

00:36:15,520 --> 00:36:21,680
so it's an object handle's promise

00:36:18,640 --> 00:36:23,359
was that uh it is the real object when

00:36:21,680 --> 00:36:24,880
you detach from it it gets you the

00:36:23,359 --> 00:36:25,599
current contemporary version of the

00:36:24,880 --> 00:36:27,760
object

00:36:25,599 --> 00:36:29,520
so we broke the detach promise actually

00:36:27,760 --> 00:36:30,400
this in this case the touch doesn't mean

00:36:29,520 --> 00:36:31,920
detach

00:36:30,400 --> 00:36:35,200
and that's not the way of react yes and

00:36:31,920 --> 00:36:38,079
that's not something that we want

00:36:35,200 --> 00:36:38,720
so i did say the root object word in

00:36:38,079 --> 00:36:41,440
this case

00:36:38,720 --> 00:36:42,400
let's make our object root object and

00:36:41,440 --> 00:36:45,520
split it

00:36:42,400 --> 00:36:48,240
um let's make the other parts

00:36:45,520 --> 00:36:49,760
of an object nodes and the node is

00:36:48,240 --> 00:36:52,079
something different now

00:36:49,760 --> 00:36:53,359
the node has some i don't know ways to

00:36:52,079 --> 00:36:56,720
to get the data

00:36:53,359 --> 00:36:59,359
like const access to the data

00:36:56,720 --> 00:37:00,160
and it has non-const access to the data

00:36:59,359 --> 00:37:02,079
and when you

00:37:00,160 --> 00:37:03,520
do non-const access to a data when you

00:37:02,079 --> 00:37:06,480
want the data as a mutable

00:37:03,520 --> 00:37:07,280
preference you copy and write and the

00:37:06,480 --> 00:37:09,280
copy on the right

00:37:07,280 --> 00:37:11,520
is uh really simple and there is no need

00:37:09,280 --> 00:37:14,720
for uh atomic stores in uh

00:37:11,520 --> 00:37:17,920
here because it's always inside of the

00:37:14,720 --> 00:37:20,480
locked mutex of the parent object

00:37:17,920 --> 00:37:24,400
um and we can have i know a nice way to

00:37:20,480 --> 00:37:24,400
get the the the actual data inside

00:37:24,560 --> 00:37:30,880
and it has a shared pointer if we want

00:37:27,760 --> 00:37:35,359
so now our imaging state is

00:37:30,880 --> 00:37:35,359
a root object which is composed of nodes

00:37:35,440 --> 00:37:40,079
and um now to set the image name we have

00:37:38,400 --> 00:37:41,520
this kind of code which is much nicer

00:37:40,079 --> 00:37:43,920
than transaction of transaction

00:37:41,520 --> 00:37:46,560
transaction we used to have before

00:37:43,920 --> 00:37:48,560
uh and it will appropriately perform a

00:37:46,560 --> 00:37:49,599
shallow copy and write on state image

00:37:48,560 --> 00:37:52,640
and name and

00:37:49,599 --> 00:37:56,079
all the other nodes will remain uh

00:37:52,640 --> 00:37:59,119
the same the same addresses

00:37:56,079 --> 00:38:00,960
so um let's make a test we can

00:37:59,119 --> 00:38:02,560
have the exact same transaction as

00:38:00,960 --> 00:38:03,839
before we can

00:38:02,560 --> 00:38:06,000
check that the state is different the

00:38:03,839 --> 00:38:06,640
image is different the image name is

00:38:06,000 --> 00:38:09,359
different

00:38:06,640 --> 00:38:10,320
and since this node this is an address

00:38:09,359 --> 00:38:12,400
comparison

00:38:10,320 --> 00:38:15,760
and we can even compare the actual

00:38:12,400 --> 00:38:17,839
values inside and it's it's different

00:38:15,760 --> 00:38:19,280
and this is direct yes way but there are

00:38:17,839 --> 00:38:20,720
some problems with it for example we

00:38:19,280 --> 00:38:23,119
have this

00:38:20,720 --> 00:38:24,880
we perform a transaction for the image

00:38:23,119 --> 00:38:28,640
and we set it to some cool name

00:38:24,880 --> 00:38:32,320
like this before the thing is that uh

00:38:28,640 --> 00:38:32,880
the operator asterisk of name of the

00:38:32,320 --> 00:38:34,880
node

00:38:32,880 --> 00:38:36,000
name will perform a copy and write so we

00:38:34,880 --> 00:38:38,400
copy the old name

00:38:36,000 --> 00:38:39,200
into a new value only to replace it with

00:38:38,400 --> 00:38:42,400
cool name

00:38:39,200 --> 00:38:43,680
that's not nice and also if we have a

00:38:42,400 --> 00:38:45,520
transaction which changes

00:38:43,680 --> 00:38:47,280
multiple elements of the state for

00:38:45,520 --> 00:38:50,880
example like this

00:38:47,280 --> 00:38:51,440
then the non-const arrow operator of

00:38:50,880 --> 00:38:54,160
image

00:38:51,440 --> 00:38:56,880
will perform a copy on right so we have

00:38:54,160 --> 00:38:59,760
two copy and writes for the image

00:38:56,880 --> 00:39:01,520
and also if we have a transaction which

00:38:59,760 --> 00:39:03,920
does something conditionally

00:39:01,520 --> 00:39:05,200
if we test if the buffer is empty and we

00:39:03,920 --> 00:39:07,839
can set the name to the image

00:39:05,200 --> 00:39:09,440
to empty then if we if we don't send the

00:39:07,839 --> 00:39:12,000
image to empty and just

00:39:09,440 --> 00:39:14,240
like the if is false we do a copy and

00:39:12,000 --> 00:39:18,240
write even if we change nothing like the

00:39:14,240 --> 00:39:19,920
non-cost overload of the operator uh

00:39:18,240 --> 00:39:21,599
our operator will perform the copy and

00:39:19,920 --> 00:39:24,800
write anyway

00:39:21,599 --> 00:39:26,320
and here is a library that we use

00:39:24,800 --> 00:39:28,400
that i've written and i've open source

00:39:26,320 --> 00:39:31,359
it you can find it at github

00:39:28,400 --> 00:39:33,359
ibob cusco and it basically deals with

00:39:31,359 --> 00:39:34,960
those problems and i have slides

00:39:33,359 --> 00:39:37,280
for how we deal with those problems but

00:39:34,960 --> 00:39:40,640
i again i will skip them

00:39:37,280 --> 00:39:40,640
and just go on

00:39:41,200 --> 00:39:47,320
so um thanks to cusco

00:39:44,480 --> 00:39:48,480
when we have this this transaction it

00:39:47,320 --> 00:39:51,599
overloads

00:39:48,480 --> 00:39:53,599
the assignment operator so it won't copy

00:39:51,599 --> 00:39:56,880
and write if you assign

00:39:53,599 --> 00:39:58,160
it uses some clever tricks with copy

00:39:56,880 --> 00:40:01,440
constructors

00:39:58,160 --> 00:40:03,119
so it it basically knows when an object

00:40:01,440 --> 00:40:03,920
is already copy and write it inside of a

00:40:03,119 --> 00:40:06,400
transaction

00:40:03,920 --> 00:40:07,920
so uh image will only get copyrighted

00:40:06,400 --> 00:40:11,839
once in this case

00:40:07,920 --> 00:40:14,240
and it introduces this dot r

00:40:11,839 --> 00:40:16,160
it's not very nice i know but uh this is

00:40:14,240 --> 00:40:17,680
basically a way to to have a const

00:40:16,160 --> 00:40:18,720
reference to the data inside without

00:40:17,680 --> 00:40:20,640
doing copy and write

00:40:18,720 --> 00:40:21,839
so when you want to only read from that

00:40:20,640 --> 00:40:24,640
you use this

00:40:21,839 --> 00:40:26,240
and there are no copies here and there

00:40:24,640 --> 00:40:28,880
are more problems though

00:40:26,240 --> 00:40:30,480
um so if you want to memorize study nmrs

00:40:28,880 --> 00:40:32,319
is basically a collection of images

00:40:30,480 --> 00:40:34,480
you would take a patient you take a

00:40:32,319 --> 00:40:36,400
bunch of scans from the mri and then

00:40:34,480 --> 00:40:38,319
that's never i study

00:40:36,400 --> 00:40:39,839
and when we want to add another image

00:40:38,319 --> 00:40:41,440
when we when we change the state

00:40:39,839 --> 00:40:43,359
at this point when we change the mri

00:40:41,440 --> 00:40:45,520
study element of the state

00:40:43,359 --> 00:40:47,280
uh at any point we need to copy the

00:40:45,520 --> 00:40:49,200
vector on every change

00:40:47,280 --> 00:40:50,640
humongous images and everything so we

00:40:49,200 --> 00:40:53,359
don't want that of course so

00:40:50,640 --> 00:40:53,760
let's say we make the vector a node but

00:40:53,359 --> 00:40:55,760
now

00:40:53,760 --> 00:40:57,839
uh when we add or remove or change the

00:40:55,760 --> 00:40:59,040
image is inside then the images will be

00:40:57,839 --> 00:41:00,720
copied so of course

00:40:59,040 --> 00:41:02,400
we know the answer let's make the images

00:41:00,720 --> 00:41:05,119
nodes and

00:41:02,400 --> 00:41:08,319
what we get here we have the transaction

00:41:05,119 --> 00:41:09,920
so we we add a new image

00:41:08,319 --> 00:41:12,319
first we copy the state and that's

00:41:09,920 --> 00:41:14,160
something we expected that's fine we we

00:41:12,319 --> 00:41:17,119
expect to copy the state in this case

00:41:14,160 --> 00:41:18,800
we copy images which is i guess we need

00:41:17,119 --> 00:41:20,400
all the images in order to add the new

00:41:18,800 --> 00:41:22,800
one to them so that's

00:41:20,400 --> 00:41:24,560
fine i guess but the thing is that in

00:41:22,800 --> 00:41:26,720
place back needs to reallocate in this

00:41:24,560 --> 00:41:29,200
particular case

00:41:26,720 --> 00:41:30,319
uh okay so it needs to allocate that

00:41:29,200 --> 00:41:32,720
something that

00:41:30,319 --> 00:41:34,560
is bound to happen at some point but

00:41:32,720 --> 00:41:36,240
when it reallocates what does it do it

00:41:34,560 --> 00:41:38,160
copies the images

00:41:36,240 --> 00:41:39,599
and this is something that we don't want

00:41:38,160 --> 00:41:41,680
to live with

00:41:39,599 --> 00:41:44,160
and to avoid this basically you need to

00:41:41,680 --> 00:41:47,599
create custom container wrappers

00:41:44,160 --> 00:41:48,079
to to help you there was a simple 2017

00:41:47,599 --> 00:41:52,079
talk

00:41:48,079 --> 00:41:54,079
like um i forget the exact title like

00:41:52,079 --> 00:41:55,680
next level immutable objects or

00:41:54,079 --> 00:41:58,960
something um

00:41:55,680 --> 00:42:00,960
and they dealt with with how to create

00:41:58,960 --> 00:42:02,000
stream view style immutable objects out

00:42:00,960 --> 00:42:03,760
of vectors and

00:42:02,000 --> 00:42:06,800
everything else and basically you need

00:42:03,760 --> 00:42:09,520
to re-implement it using shared pointers

00:42:06,800 --> 00:42:10,480
um for example we can implement in place

00:42:09,520 --> 00:42:13,040
back and this is a really

00:42:10,480 --> 00:42:14,160
even stupid implementation i know but we

00:42:13,040 --> 00:42:16,079
can just

00:42:14,160 --> 00:42:17,839
reserve that we can create an empty

00:42:16,079 --> 00:42:18,640
vector we can reserve the appropriate

00:42:17,839 --> 00:42:21,280
size

00:42:18,640 --> 00:42:22,960
and we can then assign the old vector

00:42:21,280 --> 00:42:24,079
but know that it won't reallocate when

00:42:22,960 --> 00:42:25,760
we place that

00:42:24,079 --> 00:42:28,160
and of course you can play with this we

00:42:25,760 --> 00:42:30,000
can you can reserve more than you need

00:42:28,160 --> 00:42:32,079
like vector actually does when you

00:42:30,000 --> 00:42:34,720
resize it doesn't necessarily

00:42:32,079 --> 00:42:35,599
allocate plus one element to the ones

00:42:34,720 --> 00:42:38,319
that you have

00:42:35,599 --> 00:42:39,920
and um you need to do this for uh every

00:42:38,319 --> 00:42:41,200
other container that you use inside of a

00:42:39,920 --> 00:42:42,800
state

00:42:41,200 --> 00:42:44,720
in our case this was really simple

00:42:42,800 --> 00:42:46,319
because we only use vectors inside of

00:42:44,720 --> 00:42:48,000
the state and strings of course but we

00:42:46,319 --> 00:42:49,680
never do any kinds of fancy string

00:42:48,000 --> 00:42:52,960
operations so we actually

00:42:49,680 --> 00:42:56,400
use plain old stud strings in state um

00:42:52,960 --> 00:42:58,640
and we only have like vector

00:42:56,400 --> 00:43:00,960
that special specialized vector request

00:42:58,640 --> 00:43:04,400
for this

00:43:00,960 --> 00:43:06,160
but that's a lot of allocations so um

00:43:04,400 --> 00:43:08,880
imagine this transaction we set the

00:43:06,160 --> 00:43:10,079
progress value to something and we do it

00:43:08,880 --> 00:43:12,160
like many many

00:43:10,079 --> 00:43:13,440
multiple times per second and each time

00:43:12,160 --> 00:43:15,760
we do this we

00:43:13,440 --> 00:43:16,640
make an allocation for the state imaging

00:43:15,760 --> 00:43:20,000
the images

00:43:16,640 --> 00:43:22,000
the progress the value and whatnot

00:43:20,000 --> 00:43:23,200
and so far in our case we haven't done

00:43:22,000 --> 00:43:26,560
anything about it we

00:43:23,200 --> 00:43:29,200
we live with the with the locations um

00:43:26,560 --> 00:43:30,720
we could you can mitigate it by making a

00:43:29,200 --> 00:43:33,440
better state structure

00:43:30,720 --> 00:43:34,880
and something really hard as i said uh

00:43:33,440 --> 00:43:36,400
we're thinking about using custom

00:43:34,880 --> 00:43:38,079
allocators we're even thinking about

00:43:36,400 --> 00:43:39,599
implementing shared pointer um and

00:43:38,079 --> 00:43:41,440
that's probably something that we'll end

00:43:39,599 --> 00:43:43,200
up doing because for example we

00:43:41,440 --> 00:43:45,520
haven't yet found a use case for weak

00:43:43,200 --> 00:43:47,119
pointers and if we if you don't need

00:43:45,520 --> 00:43:48,560
we we pointers you can create something

00:43:47,119 --> 00:43:48,960
like you need through the shared pointer

00:43:48,560 --> 00:43:52,000
and

00:43:48,960 --> 00:43:54,079
because we have nodes they uh

00:43:52,000 --> 00:43:55,119
like we we control the actual data

00:43:54,079 --> 00:43:58,319
inside we can

00:43:55,119 --> 00:44:00,400
uh basically create an intrusive uh

00:43:58,319 --> 00:44:01,920
style shared pointer which has the

00:44:00,400 --> 00:44:03,839
shared block

00:44:01,920 --> 00:44:05,520
closer to the to the actual sharepoint

00:44:03,839 --> 00:44:08,560
and not with the sync with another

00:44:05,520 --> 00:44:09,040
hop through the shared data um so anyway

00:44:08,560 --> 00:44:10,400
um

00:44:09,040 --> 00:44:12,640
we're still gathering information about

00:44:10,400 --> 00:44:15,040
this we we currently we use

00:44:12,640 --> 00:44:16,400
plain old shared pointers in uh plain

00:44:15,040 --> 00:44:18,400
old location

00:44:16,400 --> 00:44:19,680
but that's also a lot of copying here

00:44:18,400 --> 00:44:23,200
isn't it like

00:44:19,680 --> 00:44:25,440
um imagine the function said image voxel

00:44:23,200 --> 00:44:26,480
as i said an image an mri is kind of the

00:44:25,440 --> 00:44:28,240
patient uh

00:44:26,480 --> 00:44:29,599
is a 3d image which can be tens of

00:44:28,240 --> 00:44:32,960
megabytes big

00:44:29,599 --> 00:44:34,800
um do we want to copy tens of megabytes

00:44:32,960 --> 00:44:36,800
of the image just to set a single voxel

00:44:34,800 --> 00:44:38,319
and the answer is probably no

00:44:36,800 --> 00:44:41,200
and this is a real limitation of the

00:44:38,319 --> 00:44:46,160
current implementation of this pattern

00:44:41,200 --> 00:44:48,560
i can say we just don't do that we don't

00:44:46,160 --> 00:44:49,680
have set image voxel functionality in

00:44:48,560 --> 00:44:52,400
our codes

00:44:49,680 --> 00:44:54,079
we we could do i know a mutable

00:44:52,400 --> 00:44:57,359
placeholder inside of the state

00:44:54,079 --> 00:44:58,880
which uses conventional locks

00:44:57,359 --> 00:45:00,560
an immutable placeholder which uses

00:44:58,880 --> 00:45:01,359
conventional locks to an actual mutable

00:45:00,560 --> 00:45:03,680
object

00:45:01,359 --> 00:45:05,760
actually mutable object somewhere else

00:45:03,680 --> 00:45:08,000
and we actually do use this

00:45:05,760 --> 00:45:09,680
when we do manual contouring when the

00:45:08,000 --> 00:45:13,119
user manually

00:45:09,680 --> 00:45:14,560
tweaks the anatomical structure inside

00:45:13,119 --> 00:45:16,720
of the patient we actually have

00:45:14,560 --> 00:45:18,160
immutable placeholders in the state

00:45:16,720 --> 00:45:20,880
which communicate

00:45:18,160 --> 00:45:21,200
with mutable objects in the background

00:45:20,880 --> 00:45:22,640
and

00:45:21,200 --> 00:45:24,000
that's not nice that that's one of the

00:45:22,640 --> 00:45:24,560
parts of the code that we don't really

00:45:24,000 --> 00:45:26,480
like but

00:45:24,560 --> 00:45:27,920
uh otherwise there will be a lot of

00:45:26,480 --> 00:45:31,119
copying so that's

00:45:27,920 --> 00:45:32,319
that's a real limitation and if for

00:45:31,119 --> 00:45:33,680
example if you're considering using

00:45:32,319 --> 00:45:34,079
immutable objects and this is everything

00:45:33,680 --> 00:45:36,319
you do

00:45:34,079 --> 00:45:37,760
like changing huge humongous objects

00:45:36,319 --> 00:45:40,160
that that's probably not the right

00:45:37,760 --> 00:45:42,160
pattern for you

00:45:40,160 --> 00:45:43,680
uh what about reuse i mentioned reviews

00:45:42,160 --> 00:45:45,119
uh so um

00:45:43,680 --> 00:45:46,960
for example we have the really nice

00:45:45,119 --> 00:45:49,760
function should take scan which

00:45:46,960 --> 00:45:51,119
checks if the scan of the the state is

00:45:49,760 --> 00:45:54,319
empty and the

00:45:51,119 --> 00:45:56,480
the user requested the manual retake and

00:45:54,319 --> 00:45:57,920
um

00:45:56,480 --> 00:45:59,599
returns whether we should retake the

00:45:57,920 --> 00:46:00,000
scan and we want to use it on our

00:45:59,599 --> 00:46:01,920
imaging

00:46:00,000 --> 00:46:03,680
which is okay nice it works with imaging

00:46:01,920 --> 00:46:05,440
uh out of the box

00:46:03,680 --> 00:46:07,200
went to use it with treatment which also

00:46:05,440 --> 00:46:09,680
has imaging inside and it's called

00:46:07,200 --> 00:46:12,400
imaging and say we have a diagnosis

00:46:09,680 --> 00:46:13,119
workflow which also has imaging inside

00:46:12,400 --> 00:46:15,200
but

00:46:13,119 --> 00:46:16,400
it's named phase one because someone

00:46:15,200 --> 00:46:18,400
decided that the

00:46:16,400 --> 00:46:20,480
best name for imaging inside of

00:46:18,400 --> 00:46:22,800
diagnosis

00:46:20,480 --> 00:46:25,040
so how can we use should take scan in

00:46:22,800 --> 00:46:26,480
this case and what we have implemented

00:46:25,040 --> 00:46:29,359
here is queries

00:46:26,480 --> 00:46:31,200
so a query it's i'm not going to get

00:46:29,359 --> 00:46:34,000
into how we implemented queries you

00:46:31,200 --> 00:46:36,160
you can i guess infer it by how we use

00:46:34,000 --> 00:46:39,280
them a query is something that

00:46:36,160 --> 00:46:40,240
takes a named functionality and works

00:46:39,280 --> 00:46:42,560
with it in in

00:46:40,240 --> 00:46:44,160
with the state so basically a query get

00:46:42,560 --> 00:46:45,200
imaging from the state and it knows how

00:46:44,160 --> 00:46:47,520
to get the

00:46:45,200 --> 00:46:48,400
imaging from different states uh we can

00:46:47,520 --> 00:46:51,359
chain queries

00:46:48,400 --> 00:46:53,119
so for example if the image can be in

00:46:51,359 --> 00:46:56,720
different places here we can have

00:46:53,119 --> 00:46:59,200
get imaging with get image uh i guess

00:46:56,720 --> 00:47:00,240
uh and um the nice thing about queries

00:46:59,200 --> 00:47:02,400
is their templates

00:47:00,240 --> 00:47:04,720
they can work with mutable states too so

00:47:02,400 --> 00:47:06,640
we can we use the same queries if we're

00:47:04,720 --> 00:47:07,920
changing the state as it is so it

00:47:06,640 --> 00:47:10,720
doesn't necessarily

00:47:07,920 --> 00:47:12,480
is they're not necessarily read only

00:47:10,720 --> 00:47:14,720
those queries

00:47:12,480 --> 00:47:16,800
so uh currently we have react.js objects

00:47:14,720 --> 00:47:19,359
react.js style objects in c plus plus

00:47:16,800 --> 00:47:21,440
um they're immutable objects based on

00:47:19,359 --> 00:47:23,760
ref counted pointers

00:47:21,440 --> 00:47:25,280
they make shallow copies appropriately

00:47:23,760 --> 00:47:27,119
they make shallow compares

00:47:25,280 --> 00:47:29,520
appropriately they allow for shallow

00:47:27,119 --> 00:47:32,000
compares appropriately

00:47:29,520 --> 00:47:32,880
and they basically are states composed

00:47:32,000 --> 00:47:35,839
of nodes

00:47:32,880 --> 00:47:37,680
they're trees composed of nodes and we

00:47:35,839 --> 00:47:38,000
have special nodes for containers vector

00:47:37,680 --> 00:47:41,440
in our

00:47:38,000 --> 00:47:43,520
case we allow queries and as i said

00:47:41,440 --> 00:47:45,680
it's not necessarily the the best

00:47:43,520 --> 00:47:49,119
approach for every situation

00:47:45,680 --> 00:47:50,160
but with integration testing by unit

00:47:49,119 --> 00:47:52,960
testing it has

00:47:50,160 --> 00:47:54,960
much potential i think and at the end of

00:47:52,960 --> 00:47:56,559
part one but thanks to the fact that i

00:47:54,960 --> 00:47:58,640
skipped some slides

00:47:56,559 --> 00:48:00,400
i can continue with part two and the

00:47:58,640 --> 00:48:02,160
thing is how we use how we actually make

00:48:00,400 --> 00:48:06,240
use of these objects

00:48:02,160 --> 00:48:08,480
and um we have actions so um

00:48:06,240 --> 00:48:09,599
basically since we're implementing react

00:48:08,480 --> 00:48:11,599
we could also

00:48:09,599 --> 00:48:13,599
we implement redux and redux is a really

00:48:11,599 --> 00:48:16,000
simple library which works with

00:48:13,599 --> 00:48:16,880
many different types of types of web

00:48:16,000 --> 00:48:19,040
frameworks

00:48:16,880 --> 00:48:20,000
and it's a way to it's an immutable

00:48:19,040 --> 00:48:22,559
state library which

00:48:20,000 --> 00:48:23,040
helps you add an action to the state uh

00:48:22,559 --> 00:48:25,040
i won't

00:48:23,040 --> 00:48:26,720
go into too much details but an action

00:48:25,040 --> 00:48:27,280
basically is something that changes the

00:48:26,720 --> 00:48:29,839
state

00:48:27,280 --> 00:48:31,920
for example set the name of scan and in

00:48:29,839 --> 00:48:34,319
the mri study of the patient

00:48:31,920 --> 00:48:36,559
receive a new delivery frame which has a

00:48:34,319 --> 00:48:39,040
lot of stuff in it like an image

00:48:36,559 --> 00:48:40,319
a dose for the current frame the

00:48:39,040 --> 00:48:41,760
confidence that we're doing the right

00:48:40,319 --> 00:48:42,400
thing that we're hitting the tumor with

00:48:41,760 --> 00:48:44,079
the beam

00:48:42,400 --> 00:48:45,839
and we're not hitting different organs

00:48:44,079 --> 00:48:46,640
so that's a lot of data for a single

00:48:45,839 --> 00:48:48,640
action but

00:48:46,640 --> 00:48:51,280
and of course it can be set the entire

00:48:48,640 --> 00:48:54,319
state to this particular thing

00:48:51,280 --> 00:48:57,760
um and um let's see

00:48:54,319 --> 00:49:00,079
the example of action this is set name

00:48:57,760 --> 00:49:03,359
of scan so it totally has data

00:49:00,079 --> 00:49:05,599
it queries the mutable query here

00:49:03,359 --> 00:49:06,559
so we try to get imaging from the state

00:49:05,599 --> 00:49:08,720
if we can

00:49:06,559 --> 00:49:10,160
set the name of the scan for example

00:49:08,720 --> 00:49:11,760
that's some kind of a check that we're

00:49:10,160 --> 00:49:14,400
making we do it

00:49:11,760 --> 00:49:15,520
otherwise we throw an exception and the

00:49:14,400 --> 00:49:18,960
this way the

00:49:15,520 --> 00:49:21,200
transaction will be canceled so

00:49:18,960 --> 00:49:22,400
basically all actions are applied with a

00:49:21,200 --> 00:49:24,480
function like this

00:49:22,400 --> 00:49:26,480
uh it creates a transaction runs the

00:49:24,480 --> 00:49:29,680
action catches the exception and

00:49:26,480 --> 00:49:33,040
um we i don't have time to get into

00:49:29,680 --> 00:49:34,960
our error reporting so uh

00:49:33,040 --> 00:49:36,559
here we either notify the user for

00:49:34,960 --> 00:49:38,160
example it's a user action that their

00:49:36,559 --> 00:49:39,680
action isn't valid or we can

00:49:38,160 --> 00:49:41,520
potentially add a fatal error to the

00:49:39,680 --> 00:49:44,240
state long story

00:49:41,520 --> 00:49:46,319
so um can a valid action lead to an

00:49:44,240 --> 00:49:48,079
invalid state invariant

00:49:46,319 --> 00:49:49,920
that's a good question what if we want

00:49:48,079 --> 00:49:52,400
to enforce unique names what we

00:49:49,920 --> 00:49:54,079
want to enforce that every image inside

00:49:52,400 --> 00:49:56,160
of the state has a unique name

00:49:54,079 --> 00:49:57,359
we could do it like this like we could

00:49:56,160 --> 00:49:59,760
set the can

00:49:57,359 --> 00:50:01,599
set name of scan function take the name

00:49:59,760 --> 00:50:02,720
and it will return false if it's a

00:50:01,599 --> 00:50:04,960
duplicate name

00:50:02,720 --> 00:50:06,559
but the problem with this is that there

00:50:04,960 --> 00:50:07,119
is no way to check the validity of the

00:50:06,559 --> 00:50:09,839
state

00:50:07,119 --> 00:50:11,440
unless we call this function so if we

00:50:09,839 --> 00:50:13,359
have the set entire state function

00:50:11,440 --> 00:50:15,440
we wouldn't be able to check if all the

00:50:13,359 --> 00:50:17,599
names are valid

00:50:15,440 --> 00:50:19,599
so what we do here is we have state

00:50:17,599 --> 00:50:20,640
guards a state guard is basically a

00:50:19,599 --> 00:50:23,040
function which

00:50:20,640 --> 00:50:24,960
checks if something is valid inside of

00:50:23,040 --> 00:50:28,240
the state and throws an exception

00:50:24,960 --> 00:50:31,520
an exception if it isn't we can say have

00:50:28,240 --> 00:50:33,839
uh like

00:50:31,520 --> 00:50:35,599
overarching state guards which uh take

00:50:33,839 --> 00:50:37,760
care of a lot of other like coal

00:50:35,599 --> 00:50:40,400
smaller state guards at this point and

00:50:37,760 --> 00:50:41,680
any one of those can throw an exception

00:50:40,400 --> 00:50:44,480
we can check that if the imaging is

00:50:41,680 --> 00:50:46,559
valid with all the images our images are

00:50:44,480 --> 00:50:49,200
valid all images are the same size and

00:50:46,559 --> 00:50:49,200
stuff like that

00:50:49,280 --> 00:50:52,720
so this leads us to an app basically an

00:50:51,760 --> 00:50:54,800
app

00:50:52,720 --> 00:50:55,760
what we call an app is something that

00:50:54,800 --> 00:50:58,079
has a state

00:50:55,760 --> 00:50:59,440
and a bunch of state guards with it we

00:50:58,079 --> 00:51:01,119
can create it like this

00:50:59,440 --> 00:51:02,559
if we want to compose with some kind of

00:51:01,119 --> 00:51:04,559
type erase state guards

00:51:02,559 --> 00:51:06,559
or we can create a concrete application

00:51:04,559 --> 00:51:07,280
like this like a treatment application

00:51:06,559 --> 00:51:09,680
which

00:51:07,280 --> 00:51:12,000
checks the patient damaging the delivery

00:51:09,680 --> 00:51:14,880
and every other

00:51:12,000 --> 00:51:15,440
thing inside of the patient so what we

00:51:14,880 --> 00:51:18,079
do

00:51:15,440 --> 00:51:19,680
in this case is apply action it takes an

00:51:18,079 --> 00:51:21,119
application of state anymore we do a

00:51:19,680 --> 00:51:22,960
transaction in the state and then run

00:51:21,119 --> 00:51:26,000
all the guards

00:51:22,960 --> 00:51:29,200
and that's a lot of guard calls

00:51:26,000 --> 00:51:32,400
because um imagine

00:51:29,200 --> 00:51:34,480
the the example with with the

00:51:32,400 --> 00:51:35,680
the progress so multiple times per

00:51:34,480 --> 00:51:37,520
second we

00:51:35,680 --> 00:51:38,960
set something and then we run like a

00:51:37,520 --> 00:51:40,800
humongous amount of guards

00:51:38,960 --> 00:51:42,800
well like humongous probably in the

00:51:40,800 --> 00:51:45,440
hundreds and that that's

00:51:42,800 --> 00:51:46,160
then a lot of guards like they reuse

00:51:45,440 --> 00:51:49,680
like certain

00:51:46,160 --> 00:51:53,040
guards can be reused like certain

00:51:49,680 --> 00:51:55,760
master guards can call the same uh

00:51:53,040 --> 00:51:58,240
guards inside so we'll be checking the

00:51:55,760 --> 00:52:01,520
same thing over and over again

00:51:58,240 --> 00:52:03,760
and uh what we do now is we

00:52:01,520 --> 00:52:05,520
we skip the guards being functioned so

00:52:03,760 --> 00:52:09,200
the guards are actually objects

00:52:05,520 --> 00:52:12,079
which have uh like they memoize

00:52:09,200 --> 00:52:12,559
what thing they last validated and if

00:52:12,079 --> 00:52:14,400
the

00:52:12,559 --> 00:52:15,359
the thing they left validated is the

00:52:14,400 --> 00:52:16,559
same thing that they're trying to

00:52:15,359 --> 00:52:19,280
validate right now they just

00:52:16,559 --> 00:52:20,160
return and assume everything is okay and

00:52:19,280 --> 00:52:22,000
that's

00:52:20,160 --> 00:52:24,079
not nice of course because guards are

00:52:22,000 --> 00:52:27,200
now not pure functions anymore

00:52:24,079 --> 00:52:28,559
uh they're almost pure functions but of

00:52:27,200 --> 00:52:31,119
course they're objects which

00:52:28,559 --> 00:52:32,000
have their own state so they need to be

00:52:31,119 --> 00:52:33,839
managed it's not

00:52:32,000 --> 00:52:36,480
as simple as calling a function in this

00:52:33,839 --> 00:52:38,079
case we do have rnd for this

00:52:36,480 --> 00:52:40,160
and we we're seeing some promising

00:52:38,079 --> 00:52:42,400
results if you're trying to memorize

00:52:40,160 --> 00:52:43,760
the the the guards and even queries on

00:52:42,400 --> 00:52:46,720
the state itself so one

00:52:43,760 --> 00:52:47,760
once you run a query or check a guard

00:52:46,720 --> 00:52:49,359
the the result of it

00:52:47,760 --> 00:52:51,359
can be stored in the state itself and

00:52:49,359 --> 00:52:53,599
then running the same thing will

00:52:51,359 --> 00:52:54,480
return in the fastest possible fashion

00:52:53,599 --> 00:52:56,319
but

00:52:54,480 --> 00:52:59,359
again that's something that we currently

00:52:56,319 --> 00:53:02,079
don't have we're working on it

00:52:59,359 --> 00:53:03,040
we also have pop sub so uh that's that's

00:53:02,079 --> 00:53:04,720
really simple

00:53:03,040 --> 00:53:06,400
not too much detail basically when you

00:53:04,720 --> 00:53:08,880
end the transaction uh

00:53:06,400 --> 00:53:09,520
you have some kind of a new data that

00:53:08,880 --> 00:53:11,680
the

00:53:09,520 --> 00:53:12,880
the data that's been created by this

00:53:11,680 --> 00:53:15,680
transaction

00:53:12,880 --> 00:53:16,480
and uh when you store it into the into

00:53:15,680 --> 00:53:19,359
the actual

00:53:16,480 --> 00:53:20,400
object itself you can also uh give it to

00:53:19,359 --> 00:53:22,720
this new data

00:53:20,400 --> 00:53:25,119
and if we have new data uh you can

00:53:22,720 --> 00:53:27,040
notify all the subscribers to our object

00:53:25,119 --> 00:53:29,200
that's really simple the thing is the

00:53:27,040 --> 00:53:30,160
key part here is that we notify for each

00:53:29,200 --> 00:53:32,800
state change

00:53:30,160 --> 00:53:34,160
but not well locked so presumably even

00:53:32,800 --> 00:53:36,000
though we don't have a certain

00:53:34,160 --> 00:53:37,200
single example of this presumably you

00:53:36,000 --> 00:53:40,000
can you can

00:53:37,200 --> 00:53:41,839
uh create a transaction in one of your

00:53:40,000 --> 00:53:42,559
notification functions and notification

00:53:41,839 --> 00:53:45,359
handlers

00:53:42,559 --> 00:53:47,200
for the state change uh let's see a

00:53:45,359 --> 00:53:51,520
small example of building

00:53:47,200 --> 00:53:53,440
we of of how the ui might work so um

00:53:51,520 --> 00:53:55,359
we subscribe to the treatment state with

00:53:53,440 --> 00:53:57,520
the ui thread and we wake up

00:53:55,359 --> 00:53:58,400
when we when we create a change and we

00:53:57,520 --> 00:54:00,079
there's nothing

00:53:58,400 --> 00:54:02,160
more to do actually because when we run

00:54:00,079 --> 00:54:04,079
the ui thread we we wait

00:54:02,160 --> 00:54:05,520
until we're woken up and then we build

00:54:04,079 --> 00:54:07,280
the gui and we're

00:54:05,520 --> 00:54:08,880
absolutely fine if we skip states

00:54:07,280 --> 00:54:12,160
because uh

00:54:08,880 --> 00:54:13,920
if we skip states then uh the user is

00:54:12,160 --> 00:54:15,760
probably not meant to see them things

00:54:13,920 --> 00:54:17,599
happen so quickly for example if

00:54:15,760 --> 00:54:19,040
the progress gets updated five times and

00:54:17,599 --> 00:54:22,000
user sees only

00:54:19,040 --> 00:54:22,640
the first and the fifth it's fine so

00:54:22,000 --> 00:54:26,160
when

00:54:22,640 --> 00:54:26,720
the user runs a command like set image

00:54:26,160 --> 00:54:28,720
name

00:54:26,720 --> 00:54:30,559
we know what to do like we push an

00:54:28,720 --> 00:54:31,920
action to the treatment session

00:54:30,559 --> 00:54:33,599
when the user runs a command like

00:54:31,920 --> 00:54:35,920
calculate the bladder here

00:54:33,599 --> 00:54:37,359
what do we do then we don't have the

00:54:35,920 --> 00:54:40,640
bladder at this point

00:54:37,359 --> 00:54:42,720
we could synchronously call the

00:54:40,640 --> 00:54:44,400
bladder calculation function here but

00:54:42,720 --> 00:54:47,119
that's not what we want to do

00:54:44,400 --> 00:54:48,000
we have fancy workers that we want to

00:54:47,119 --> 00:54:50,640
use here right

00:54:48,000 --> 00:54:51,119
we want to start our calculation and

00:54:50,640 --> 00:54:52,559
that's

00:54:51,119 --> 00:54:54,799
when we get into the really

00:54:52,559 --> 00:54:57,680
multi-threaded stuff

00:54:54,799 --> 00:54:59,520
the thing is that um let's imagine the

00:54:57,680 --> 00:55:00,240
user the actual operator the human

00:54:59,520 --> 00:55:03,440
operator

00:55:00,240 --> 00:55:06,559
of the machine is uh is a simplest plus

00:55:03,440 --> 00:55:09,760
process then

00:55:06,559 --> 00:55:13,359
uh what does this process do it has its

00:55:09,760 --> 00:55:14,640
own state its brain state it's the the

00:55:13,359 --> 00:55:17,280
the state of the brain

00:55:14,640 --> 00:55:18,079
of the human operator and based on the

00:55:17,280 --> 00:55:20,000
brain state

00:55:18,079 --> 00:55:22,160
and the observed application state

00:55:20,000 --> 00:55:24,319
through their eyes on their screen

00:55:22,160 --> 00:55:26,160
they make a decision to to set the name

00:55:24,319 --> 00:55:29,200
i don't like this name right now i want

00:55:26,160 --> 00:55:31,200
to set another name for this image

00:55:29,200 --> 00:55:32,319
they run some kind of a function to make

00:55:31,200 --> 00:55:35,920
this decision

00:55:32,319 --> 00:55:38,480
and if the decision is to make an action

00:55:35,920 --> 00:55:39,119
we push the action to the application so

00:55:38,480 --> 00:55:41,440
that's

00:55:39,119 --> 00:55:42,400
the top that we really liked and

00:55:41,440 --> 00:55:46,319
basically

00:55:42,400 --> 00:55:47,760
that's the the way services communicate

00:55:46,319 --> 00:55:50,160
with us

00:55:47,760 --> 00:55:52,319
we this is a way to translate

00:55:50,160 --> 00:55:53,920
declarative code which is the state the

00:55:52,319 --> 00:55:55,680
brain state and observed application

00:55:53,920 --> 00:55:56,720
state to imperative code like run this

00:55:55,680 --> 00:55:59,440
section

00:55:56,720 --> 00:56:00,720
so a small example for this will be like

00:55:59,440 --> 00:56:03,440
the bladder observer

00:56:00,720 --> 00:56:04,880
that's something too too narrow to

00:56:03,440 --> 00:56:06,799
actually exist in our code but

00:56:04,880 --> 00:56:08,559
let's say we could create something like

00:56:06,799 --> 00:56:10,880
this if we have a currently running

00:56:08,559 --> 00:56:14,240
bladder calculation

00:56:10,880 --> 00:56:15,280
but also the image of the state is not

00:56:14,240 --> 00:56:18,160
the same image

00:56:15,280 --> 00:56:19,920
that we were running this calculation on

00:56:18,160 --> 00:56:22,960
then we aboard the calculation

00:56:19,920 --> 00:56:24,079
else we're doing what's correct so we

00:56:22,960 --> 00:56:27,599
return

00:56:24,079 --> 00:56:29,440
so if the bladder uh if the

00:56:27,599 --> 00:56:31,040
if the bladder in the state if there is

00:56:29,440 --> 00:56:32,079
no blend of state we start the

00:56:31,040 --> 00:56:35,119
calculation

00:56:32,079 --> 00:56:36,880
if the user requested the manual uh

00:56:35,119 --> 00:56:39,200
bladder recalculation we run the

00:56:36,880 --> 00:56:40,880
calculation and that's it

00:56:39,200 --> 00:56:42,799
and that that so basically we would

00:56:40,880 --> 00:56:44,880
implement this function by creating

00:56:42,799 --> 00:56:45,839
by setting the manual calculation

00:56:44,880 --> 00:56:48,880
requested

00:56:45,839 --> 00:56:51,040
element of the state the action uh would

00:56:48,880 --> 00:56:52,559
change this element of the state so

00:56:51,040 --> 00:56:53,760
basically this means that our workers

00:56:52,559 --> 00:56:57,200
are managed

00:56:53,760 --> 00:56:59,920
it's not simply running a stool thread

00:56:57,200 --> 00:57:02,319
workers can and should be named they can

00:56:59,920 --> 00:57:05,040
be found they can be started and aborted

00:57:02,319 --> 00:57:06,319
they have their own state basically and

00:57:05,040 --> 00:57:08,240
there is a

00:57:06,319 --> 00:57:09,680
state which represents all workers

00:57:08,240 --> 00:57:11,839
currently running

00:57:09,680 --> 00:57:13,359
that's not necessarily were all workers

00:57:11,839 --> 00:57:14,400
in the application itself it could be

00:57:13,359 --> 00:57:17,760
all workers for

00:57:14,400 --> 00:57:19,760
certain uh service like we don't mix the

00:57:17,760 --> 00:57:20,240
workers for the mri with the workers for

00:57:19,760 --> 00:57:22,640
the

00:57:20,240 --> 00:57:25,359
auto contouring for for the identifying

00:57:22,640 --> 00:57:28,640
anatomical structure inside the patient

00:57:25,359 --> 00:57:30,640
so um here uh

00:57:28,640 --> 00:57:32,160
we can we can think of what to do with

00:57:30,640 --> 00:57:33,839
their result and we

00:57:32,160 --> 00:57:35,280
know that we shouldn't just push an

00:57:33,839 --> 00:57:37,280
action and a board

00:57:35,280 --> 00:57:39,119
uh because if we just push an action and

00:57:37,280 --> 00:57:42,240
then abort in the next

00:57:39,119 --> 00:57:44,319
uh possible moment

00:57:42,240 --> 00:57:45,680
uh we will rerun the same thing so

00:57:44,319 --> 00:57:48,079
basically how we collect

00:57:45,680 --> 00:57:49,760
the thing from the worker is when the

00:57:48,079 --> 00:57:52,319
action for the worker job done

00:57:49,760 --> 00:57:53,280
comes here like said bladder we check

00:57:52,319 --> 00:57:55,680
the worker

00:57:53,280 --> 00:57:57,839
if it has some result and only now is

00:57:55,680 --> 00:58:00,640
the bladder work completed

00:57:57,839 --> 00:58:01,920
um that's basically about state

00:58:00,640 --> 00:58:04,799
observers there they

00:58:01,920 --> 00:58:06,319
run in many they can they run after

00:58:04,799 --> 00:58:07,680
every state change and then potentially

00:58:06,319 --> 00:58:09,119
be running many threads and that's the

00:58:07,680 --> 00:58:11,119
way how services communicate through

00:58:09,119 --> 00:58:13,119
state observers

00:58:11,119 --> 00:58:14,400
i have some really short example of

00:58:13,119 --> 00:58:16,319
tests here but uh

00:58:14,400 --> 00:58:18,640
in the interest i'm going to skip them

00:58:16,319 --> 00:58:22,240
we can talk them over later if you want

00:58:18,640 --> 00:58:24,480
um and so basically a conclusion

00:58:22,240 --> 00:58:26,079
uh programming with immutable objects is

00:58:24,480 --> 00:58:28,720
not a solution for every problem

00:58:26,079 --> 00:58:30,480
uh we found that programming and design

00:58:28,720 --> 00:58:32,319
and especially designing of the states

00:58:30,480 --> 00:58:34,000
themselves is really hard

00:58:32,319 --> 00:58:35,760
and it can be overly verbals like you

00:58:34,000 --> 00:58:37,359
write everything over and over again but

00:58:35,760 --> 00:58:40,559
that's not necessarily bad

00:58:37,359 --> 00:58:42,960
like being overly verbose is basically

00:58:40,559 --> 00:58:44,079
writing your specs in plain english in

00:58:42,960 --> 00:58:46,319
code

00:58:44,079 --> 00:58:47,440
the performance is not great granted

00:58:46,319 --> 00:58:49,920
it's not terrible either

00:58:47,440 --> 00:58:50,559
but if performance is absolutely

00:58:49,920 --> 00:58:52,160
critical

00:58:50,559 --> 00:58:53,599
for for the state changes that that's

00:58:52,160 --> 00:58:55,520
probably not the way to go

00:58:53,599 --> 00:58:57,280
and we're working on improving it but

00:58:55,520 --> 00:58:58,640
the thing is it has awesome testing and

00:58:57,280 --> 00:59:00,400
debugging power

00:58:58,640 --> 00:59:01,920
and in fact from all the pieces of

00:59:00,400 --> 00:59:04,480
software that i've worked in my life

00:59:01,920 --> 00:59:08,160
this is the one that's uh i'm

00:59:04,480 --> 00:59:10,079
most certain that the the business logic

00:59:08,160 --> 00:59:11,760
is doing the what it's supposed to do

00:59:10,079 --> 00:59:12,960
like it's business logic is following

00:59:11,760 --> 00:59:15,440
the specs

00:59:12,960 --> 00:59:15,440
so thank you

00:59:16,400 --> 00:59:21,119
i'm sorry there is not a lot of time for

00:59:18,400 --> 00:59:21,119
questions left

00:59:22,400 --> 00:59:27,520
yes i've seen uh i've seen other

00:59:25,760 --> 00:59:29,359
immutable objects library but uh for

00:59:27,520 --> 00:59:32,480
example there's a question

00:59:29,359 --> 00:59:32,480
if i've seen uh

00:59:35,040 --> 00:59:39,040
so imr is is an immutable object in the

00:59:38,319 --> 00:59:41,359
sense of

00:59:39,040 --> 00:59:43,760
uh its library formula objects in the

00:59:41,359 --> 00:59:47,119
sense of

00:59:43,760 --> 00:59:49,359
string view you or or a vector

00:59:47,119 --> 00:59:51,040
or the the thing that the example i made

00:59:49,359 --> 00:59:53,839
with the swift object

00:59:51,040 --> 00:59:54,240
so basically you have an object and you

00:59:53,839 --> 00:59:56,400
don't

00:59:54,240 --> 00:59:57,839
change it but you only have functions on

00:59:56,400 --> 01:00:00,160
it which return

00:59:57,839 --> 01:00:01,359
a copy of the object with the changes

01:00:00,160 --> 01:00:04,640
requested

01:00:01,359 --> 01:00:05,839
so uh it's not necessarily the same

01:00:04,640 --> 01:00:08,880
thing

01:00:05,839 --> 01:00:11,280
uh here the key part here is

01:00:08,880 --> 01:00:12,000
having shallow copy and writes and

01:00:11,280 --> 01:00:15,359
shallow

01:00:12,000 --> 01:00:16,960
compares via shared pointers something

01:00:15,359 --> 01:00:17,680
that's really similar to a shared

01:00:16,960 --> 01:00:20,400
pointer

01:00:17,680 --> 01:00:22,079
it's not uh it's not like it's not

01:00:20,400 --> 01:00:22,880
strictly an immutable object library

01:00:22,079 --> 01:00:24,960
it's not like

01:00:22,880 --> 01:00:29,839
in the sense of haskell's immutable

01:00:24,960 --> 01:00:29,839
objects i guess

01:00:30,960 --> 01:00:36,319
uh yeah well uh when the question is

01:00:34,400 --> 01:00:38,640
what problems do we face when a thread

01:00:36,319 --> 01:00:41,200
produces an outdated result

01:00:38,640 --> 01:00:42,880
uh we throw it away yeah typically this

01:00:41,200 --> 01:00:44,960
will lead to an exception like outdated

01:00:42,880 --> 01:00:47,920
results so we will throw it away

01:00:44,960 --> 01:00:48,400
uh we won't try to merge it and in this

01:00:47,920 --> 01:00:51,680
case

01:00:48,400 --> 01:00:54,000
we we will hope that whatever triggered

01:00:51,680 --> 01:00:55,119
this calculation which is now outdated

01:00:54,000 --> 01:00:57,359
will be triggered

01:00:55,119 --> 01:00:58,559
will be run again and trigger a new

01:00:57,359 --> 01:01:00,319
calculation so

01:00:58,559 --> 01:01:02,160
for example if there's a state observer

01:01:00,319 --> 01:01:04,319
with watches which watches the

01:01:02,160 --> 01:01:07,040
the image and if there is a new image it

01:01:04,319 --> 01:01:09,599
runs the auto contouring calculation

01:01:07,040 --> 01:01:10,240
so in in this case uh if if there's a

01:01:09,599 --> 01:01:12,160
new image

01:01:10,240 --> 01:01:13,520
we might eventually end up receiving

01:01:12,160 --> 01:01:14,160
outdated containers we'll throw them

01:01:13,520 --> 01:01:16,640
away but

01:01:14,160 --> 01:01:18,559
the we know that the observer has

01:01:16,640 --> 01:01:23,040
actually run for the new image and

01:01:18,559 --> 01:01:25,119
uh new uh auto generated

01:01:23,040 --> 01:01:27,119
anatomical structures are on their way

01:01:25,119 --> 01:01:31,440
so that that's what basically what we do

01:01:27,119 --> 01:01:32,960
when we receive outdated data um

01:01:31,440 --> 01:01:34,240
since everything is shared pointer do we

01:01:32,960 --> 01:01:35,760
see a negative impact on cash

01:01:34,240 --> 01:01:38,079
friendliness of course it's

01:01:35,760 --> 01:01:39,920
cash friendliest for this particular

01:01:38,079 --> 01:01:42,160
data structure is terrible

01:01:39,920 --> 01:01:43,040
even if in our wildest optimization

01:01:42,160 --> 01:01:46,400
dreams

01:01:43,040 --> 01:01:48,559
with the custom-made

01:01:46,400 --> 01:01:49,760
allocators the cash friendliness will be

01:01:48,559 --> 01:01:51,599
terrible but

01:01:49,760 --> 01:01:54,240
this is something that's relatively low

01:01:51,599 --> 01:01:54,960
velocity so state changes typically in

01:01:54,240 --> 01:01:58,720
our case

01:01:54,960 --> 01:02:02,160
happen some tens two to

01:01:58,720 --> 01:02:05,119
ten up to ten

01:02:02,160 --> 01:02:06,880
times per second so the thing is that we

01:02:05,119 --> 01:02:10,480
maintain a robust

01:02:06,880 --> 01:02:12,319
and uh reusable and then serializable

01:02:10,480 --> 01:02:13,839
state which describes what the current

01:02:12,319 --> 01:02:16,160
situation implication is

01:02:13,839 --> 01:02:17,680
when we calculate structures we don't

01:02:16,160 --> 01:02:20,960
work with state there

01:02:17,680 --> 01:02:24,079
we you have a old uh vector

01:02:20,960 --> 01:02:26,880
which has uh really cache friendly

01:02:24,079 --> 01:02:28,880
image voxels inside of it and algorithms

01:02:26,880 --> 01:02:30,960
from it they start different threads

01:02:28,880 --> 01:02:32,559
but the thing is the result they produce

01:02:30,960 --> 01:02:36,240
is then applied to the state

01:02:32,559 --> 01:02:38,240
so when we do need uh high performance

01:02:36,240 --> 01:02:41,280
we we can get high performance

01:02:38,240 --> 01:02:45,039
in the workers but

01:02:41,280 --> 01:02:48,160
as i said managing massaging the state

01:02:45,039 --> 01:02:49,119
is not very performant but again if

01:02:48,160 --> 01:02:51,680
we're talking about

01:02:49,119 --> 01:02:52,799
tens of operations tens of state changes

01:02:51,680 --> 01:02:55,119
per second

01:02:52,799 --> 01:02:55,839
then it's absolutely workable and their

01:02:55,119 --> 01:02:57,920
business

01:02:55,839 --> 01:03:00,839
the the security that you get with

01:02:57,920 --> 01:03:02,160
writing this code is

01:03:00,839 --> 01:03:04,960
great

01:03:02,160 --> 01:03:06,160
uh how the well react.js is is an

01:03:04,960 --> 01:03:08,960
inspiration of sorts

01:03:06,160 --> 01:03:10,240
we're we're the react.js the question is

01:03:08,960 --> 01:03:11,680
how does react.js

01:03:10,240 --> 01:03:13,680
compare to our library react.js is

01:03:11,680 --> 01:03:15,599
single threaded so

01:03:13,680 --> 01:03:17,599
most of the problems that we are dealing

01:03:15,599 --> 01:03:19,920
with are trivial there

01:03:17,599 --> 01:03:20,880
uh when you have state observers they

01:03:19,920 --> 01:03:23,359
don't need to

01:03:20,880 --> 01:03:24,799
launch some kind of uh application they

01:03:23,359 --> 01:03:27,440
can run their actions right

01:03:24,799 --> 01:03:29,039
then and there yeah that it does have

01:03:27,440 --> 01:03:32,160
asynchronous operations but

01:03:29,039 --> 01:03:32,559
of course um we were not writing react

01:03:32,160 --> 01:03:34,799
yes

01:03:32,559 --> 01:03:35,599
regest was an inspiration basically for

01:03:34,799 --> 01:03:38,640
for the

01:03:35,599 --> 01:03:41,920
motto for the

01:03:38,640 --> 01:03:45,839
thought integration threat testing by

01:03:41,920 --> 01:03:45,839
unit testing

01:03:47,039 --> 01:03:50,799
in my experience design with mutability

01:03:48,880 --> 01:03:52,400
in mind usually emphasizes safety

01:03:50,799 --> 01:03:54,000
what has been your experience regarding

01:03:52,400 --> 01:03:56,880
program correctness and safety

01:03:54,000 --> 01:03:57,280
yeah i already mentioned this i think

01:03:56,880 --> 01:04:00,480
that

01:03:57,280 --> 01:04:03,599
this is the the most safe

01:04:00,480 --> 01:04:04,480
and correct uh software that i've ever

01:04:03,599 --> 01:04:07,839
worked on

01:04:04,480 --> 01:04:10,400
uh it's over liverpool's that's true

01:04:07,839 --> 01:04:12,640
but all of the verbosity and all of the

01:04:10,400 --> 01:04:15,520
data being in the same place

01:04:12,640 --> 01:04:15,920
basically helps you it's not hard to to

01:04:15,520 --> 01:04:17,599
write

01:04:15,920 --> 01:04:19,039
code with the state it's hard to design

01:04:17,599 --> 01:04:22,880
a good and and

01:04:19,039 --> 01:04:25,839
and not overly wasteful

01:04:22,880 --> 01:04:26,799
state object but once you have it

01:04:25,839 --> 01:04:30,240
basically you

01:04:26,799 --> 01:04:33,200
write specs uh it's in almost

01:04:30,240 --> 01:04:34,000
plain english you you write you write

01:04:33,200 --> 01:04:36,079
your codes

01:04:34,000 --> 01:04:37,599
following the specs of the application

01:04:36,079 --> 01:04:40,720
in in

01:04:37,599 --> 01:04:41,839
in the most readable way possible with

01:04:40,720 --> 01:04:45,359
pure function or

01:04:41,839 --> 01:04:49,200
semi-pure functions uh in in the case of

01:04:45,359 --> 01:04:49,200
state guards

01:04:50,000 --> 01:04:53,440
so it was the last question and with

01:04:52,640 --> 01:04:56,559
that

01:04:53,440 --> 01:05:09,839
i thank you and sorry for all the

01:04:56,559 --> 01:05:09,839
mishaps that we've had

01:05:18,079 --> 01:05:20,160

YouTube URL: https://www.youtube.com/watch?v=ZSrIZW2Hzhk


