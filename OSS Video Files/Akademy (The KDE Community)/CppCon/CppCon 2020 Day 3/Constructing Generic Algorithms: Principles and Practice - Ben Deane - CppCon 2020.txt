Title: Constructing Generic Algorithms: Principles and Practice - Ben Deane - CppCon 2020
Publication date: 2020-09-28
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/constructing_generic_algorithms/constructing_generic_algorithms__ben_deane__cppcon_2020.pdf
---
"You have all these algorithms at your disposal. *Learn them.*"
-- Sean Parent, GoingNative 2013.

Great advice, and the algorithms can do a lot. But they can't do everything, and the fixed set in the standard was never meant to be the last word in every problem. Sometimes we do need to write our own solutions. What are the best practices for that?

This talk examines how to build our own algorithms. We'll start with a raw loop that solves a nontrivial problem, and turn it into a generic algorithm capable of supporting a wide variety of use cases without loss of expressivity or efficiency.

Along the way we'll consider algorithmic patterns, how to structure the
interface, how the types interact, iterator category concerns, testing, and
more. We'll look at how ranges and concepts help us to refine and focus things.

We'll also see where the existing algorithms fall short, and take a look at some non-obvious use cases, including some minor modifications or wrappings that give us extra flexibility.

---
Ben Deane
Quantlab
Denver, CO

Ben was in the game industry for 23 years, at companies like EA and Blizzard. For the last couple of years he's been working in the finance industry at Quantlab. He's always looking for useful new techniques in C++, and he geeks out on algorithms, APIs, types and functional programming.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,519 --> 00:00:11,920
hello

00:00:10,240 --> 00:00:14,320
and welcome to my talk about

00:00:11,920 --> 00:00:16,640
constructing generic algorithms

00:00:14,320 --> 00:00:18,960
uh if indeed you are out there which i

00:00:16,640 --> 00:00:21,840
assume you are

00:00:18,960 --> 00:00:23,519
uh we're going to talk a bit about um

00:00:21,840 --> 00:00:24,960
why we should construct algorithms and

00:00:23,519 --> 00:00:27,439
then we're going to do a case study

00:00:24,960 --> 00:00:28,640
of a non-trivial algorithm which isn't

00:00:27,439 --> 00:00:30,480
in the standard

00:00:28,640 --> 00:00:32,399
and we're going to sort of iterate on it

00:00:30,480 --> 00:00:33,280
and see how to take it from a piece of

00:00:32,399 --> 00:00:35,600
code that just

00:00:33,280 --> 00:00:37,360
exists you know today in a function

00:00:35,600 --> 00:00:39,760
somewhere that isn't at all generic

00:00:37,360 --> 00:00:40,719
and make it into a properly generic

00:00:39,760 --> 00:00:43,680
algorithm that's

00:00:40,719 --> 00:00:44,719
worthy of something like the stl then

00:00:43,680 --> 00:00:46,640
we're going to talk a bit about

00:00:44,719 --> 00:00:48,160
principles for algorithm design based

00:00:46,640 --> 00:00:50,160
off of that and

00:00:48,160 --> 00:00:51,520
along the way we'll point out a few

00:00:50,160 --> 00:00:53,120
places in the standard where things

00:00:51,520 --> 00:00:56,399
aren't maybe quite how they should be

00:00:53,120 --> 00:00:59,120
right now but of course

00:00:56,399 --> 00:01:00,879
before we start i have to say if you

00:00:59,120 --> 00:01:02,320
want to understand the stl

00:01:00,879 --> 00:01:03,920
you need to understand the algorithms

00:01:02,320 --> 00:01:06,240
because they are the soul of the stl the

00:01:03,920 --> 00:01:09,439
stl is really not about containers

00:01:06,240 --> 00:01:13,840
it's about algorithms for me

00:01:09,439 --> 00:01:15,439
um and i'm worried about ranges

00:01:13,840 --> 00:01:16,479
everyone says stl algorithms are not

00:01:15,439 --> 00:01:18,479
composable you might have heard this

00:01:16,479 --> 00:01:21,280
even at this conference

00:01:18,479 --> 00:01:22,880
i don't say this this is ranges don't

00:01:21,280 --> 00:01:24,840
give us composability they give us

00:01:22,880 --> 00:01:26,799
laziness they don't actually change the

00:01:24,840 --> 00:01:27,759
fundamentals of what it means to write

00:01:26,799 --> 00:01:30,400
an algorithm

00:01:27,759 --> 00:01:32,640
and what we have to think about but more

00:01:30,400 --> 00:01:35,439
on this later

00:01:32,640 --> 00:01:37,360
yes in fact the stl algorithms are a

00:01:35,439 --> 00:01:39,280
study incomposability

00:01:37,360 --> 00:01:41,840
they're all designed to support stable

00:01:39,280 --> 00:01:43,360
sort which in the mid 90s an institute

00:01:41,840 --> 00:01:46,240
stable sort

00:01:43,360 --> 00:01:47,759
was was pretty a pretty amazing thing

00:01:46,240 --> 00:01:48,799
because it had been a research problem

00:01:47,759 --> 00:01:52,399
in knuth

00:01:48,799 --> 00:01:53,680
um and so as has been said before the

00:01:52,399 --> 00:01:55,600
algorithms fit the other light puzzle

00:01:53,680 --> 00:01:58,159
pieces

00:01:55,600 --> 00:01:59,280
so why would we write more well the

00:01:58,159 --> 00:02:00,719
standard set

00:01:59,280 --> 00:02:02,560
is great and we should definitely know

00:02:00,719 --> 00:02:04,320
them but it was never designed to be

00:02:02,560 --> 00:02:05,680
complete and there are many many

00:02:04,320 --> 00:02:07,360
algorithms out there

00:02:05,680 --> 00:02:09,280
many choices i've made some choices for

00:02:07,360 --> 00:02:10,319
this talk it's at least partly

00:02:09,280 --> 00:02:12,400
subjective

00:02:10,319 --> 00:02:14,000
but um i hope that by the time we finish

00:02:12,400 --> 00:02:14,959
with this talk you'll have a good

00:02:14,000 --> 00:02:16,879
grounding in

00:02:14,959 --> 00:02:18,000
the kinds of things that you need to

00:02:16,879 --> 00:02:21,440
think about

00:02:18,000 --> 00:02:22,720
in formulating an algorithm and in a way

00:02:21,440 --> 00:02:24,879
the fact that it's objective is the

00:02:22,720 --> 00:02:26,640
point there isn't just one way to solve

00:02:24,879 --> 00:02:28,080
a problem we get to formulate an

00:02:26,640 --> 00:02:30,000
algorithm

00:02:28,080 --> 00:02:31,920
under our own choices and still stay

00:02:30,000 --> 00:02:36,000
true to the spirit of

00:02:31,920 --> 00:02:39,280
uh the stl algorithms so let's go ahead

00:02:36,000 --> 00:02:40,000
as luck would have it last year's cppcon

00:02:39,280 --> 00:02:42,879
provided

00:02:40,000 --> 00:02:44,400
a good problem so on the board someone

00:02:42,879 --> 00:02:47,120
wrote this

00:02:44,400 --> 00:02:48,720
given an array of unique 64-bit integers

00:02:47,120 --> 00:02:50,720
in a random order

00:02:48,720 --> 00:02:52,239
create a practical algorithm which

00:02:50,720 --> 00:02:53,120
returns an integer which is not in the

00:02:52,239 --> 00:02:56,400
array

00:02:53,120 --> 00:02:58,879
in linear time okay so

00:02:56,400 --> 00:03:00,720
here's the problem um and this problem

00:02:58,879 --> 00:03:01,440
could crop up in several circumstances

00:03:00,720 --> 00:03:03,440
like

00:03:01,440 --> 00:03:05,360
giving out tickets or scheduling or

00:03:03,440 --> 00:03:06,640
maybe some other cases

00:03:05,360 --> 00:03:08,400
there are many ways to solve this

00:03:06,640 --> 00:03:10,239
problem it's not a very difficult

00:03:08,400 --> 00:03:12,800
problem to solve but it's not trivial

00:03:10,239 --> 00:03:13,760
and it's about the right size for a talk

00:03:12,800 --> 00:03:15,680
so

00:03:13,760 --> 00:03:17,599
let's think about it the first thing we

00:03:15,680 --> 00:03:18,879
do when we think about a problem is

00:03:17,599 --> 00:03:20,959
what are the constraints let's

00:03:18,879 --> 00:03:23,840
understand them so

00:03:20,959 --> 00:03:25,280
it says 64-bit integers and even if we

00:03:23,840 --> 00:03:26,480
don't start out that way we'd like this

00:03:25,280 --> 00:03:28,319
to be generic

00:03:26,480 --> 00:03:29,920
so we can imagine not just 64-bit

00:03:28,319 --> 00:03:32,400
integers but maybe

00:03:29,920 --> 00:03:33,200
chars right so it's quite possible that

00:03:32,400 --> 00:03:35,360
the space

00:03:33,200 --> 00:03:37,120
could be at least the overlap part of

00:03:35,360 --> 00:03:39,280
the space could be full

00:03:37,120 --> 00:03:41,200
so we can't just sort of do largest plus

00:03:39,280 --> 00:03:44,000
one or something like that

00:03:41,200 --> 00:03:44,879
um we have we're told we have unique

00:03:44,000 --> 00:03:46,319
elements

00:03:44,879 --> 00:03:49,360
and we told they're in a random order

00:03:46,319 --> 00:03:50,560
which says to me that we're free to

00:03:49,360 --> 00:03:52,640
change that order because if we get

00:03:50,560 --> 00:03:54,480
things in a random order then

00:03:52,640 --> 00:03:56,000
we are we are free to sort of permute

00:03:54,480 --> 00:03:59,200
them and

00:03:56,000 --> 00:04:01,519
it says a practical algorithm

00:03:59,200 --> 00:04:03,360
which says two major things for

00:04:01,519 --> 00:04:06,319
practical are suggested to me

00:04:03,360 --> 00:04:06,799
one it should be no more than linear

00:04:06,319 --> 00:04:08,879
time

00:04:06,799 --> 00:04:10,879
and two we'd really like to do it in

00:04:08,879 --> 00:04:12,720
place these are always the

00:04:10,879 --> 00:04:16,079
the constraints that we sort of like to

00:04:12,720 --> 00:04:17,280
stay with in algorithm land

00:04:16,079 --> 00:04:19,840
now there are various suggested

00:04:17,280 --> 00:04:20,959
solutions to this problem at cppcon last

00:04:19,840 --> 00:04:23,440
year

00:04:20,959 --> 00:04:24,479
one of them was in fact a very popular

00:04:23,440 --> 00:04:29,440
one was

00:04:24,479 --> 00:04:30,639
radix sort which is okay but it wasn't

00:04:29,440 --> 00:04:32,960
it didn't seem very

00:04:30,639 --> 00:04:34,400
general to me some people suggested bit

00:04:32,960 --> 00:04:37,280
twiddling which seemed even less

00:04:34,400 --> 00:04:38,479
general and sort of limiting to integral

00:04:37,280 --> 00:04:41,600
types from the get-go

00:04:38,479 --> 00:04:42,000
and like i say i'd like to start out i'd

00:04:41,600 --> 00:04:43,680
like to

00:04:42,000 --> 00:04:46,400
end up generic even if we don't start

00:04:43,680 --> 00:04:49,520
out totally generic

00:04:46,400 --> 00:04:50,639
so the first observation to make here is

00:04:49,520 --> 00:04:52,400
that

00:04:50,639 --> 00:04:54,000
if these if these integers if these

00:04:52,400 --> 00:04:55,759
things were sorted

00:04:54,000 --> 00:04:57,040
we'd already be done with a standard

00:04:55,759 --> 00:05:00,479
algorithm

00:04:57,040 --> 00:05:03,600
um we'd just run adjacent find

00:05:00,479 --> 00:05:05,759
or equivalently mismatch uh this is

00:05:03,600 --> 00:05:06,800
this and this works fine for a sorted

00:05:05,759 --> 00:05:09,199
range

00:05:06,800 --> 00:05:11,120
we'd be done this is just the first

00:05:09,199 --> 00:05:13,600
attempt the solution works

00:05:11,120 --> 00:05:14,479
it is linear but of course sorting isn't

00:05:13,600 --> 00:05:17,039
linear

00:05:14,479 --> 00:05:18,639
so that's a fairly large constraint to

00:05:17,039 --> 00:05:20,639
have to throw out

00:05:18,639 --> 00:05:22,160
um it's usually a good idea though to

00:05:20,639 --> 00:05:26,080
start out by solving

00:05:22,160 --> 00:05:27,600
a simpler problem uh seeing how you can

00:05:26,080 --> 00:05:29,199
either take away constraints or

00:05:27,600 --> 00:05:32,400
sometimes add constraints

00:05:29,199 --> 00:05:33,759
um sometimes it's easier to solve more

00:05:32,400 --> 00:05:35,759
specific problems sometimes it's easier

00:05:33,759 --> 00:05:37,440
to solve more general problem

00:05:35,759 --> 00:05:38,960
in either way if you solve a simpler

00:05:37,440 --> 00:05:40,479
problem it often gets you some part of

00:05:38,960 --> 00:05:43,759
the way to solving

00:05:40,479 --> 00:05:43,759
uh the the bigger problem

00:05:43,919 --> 00:05:49,680
so quicker side by adjacent find um

00:05:47,520 --> 00:05:50,560
somebody tweeted this made of mistake

00:05:49,680 --> 00:05:52,880
tweeted this

00:05:50,560 --> 00:05:54,560
a few months ago i think in may it

00:05:52,880 --> 00:05:57,680
happened on on twitter

00:05:54,560 --> 00:06:00,639
and of course the solution in c plus

00:05:57,680 --> 00:06:02,400
is precisely adjacent find find two

00:06:00,639 --> 00:06:04,880
repeated elements

00:06:02,400 --> 00:06:06,160
and just a note about this a lot of

00:06:04,880 --> 00:06:08,000
people tweeted

00:06:06,160 --> 00:06:10,560
solutions to this and a lot of my

00:06:08,000 --> 00:06:12,000
twitter stream is made up of uh

00:06:10,560 --> 00:06:14,240
somewhat functional programmers so

00:06:12,000 --> 00:06:15,520
people tweeted answers in functional

00:06:14,240 --> 00:06:17,759
languages

00:06:15,520 --> 00:06:19,039
and i have to say that what c plus plus

00:06:17,759 --> 00:06:22,080
lacks in beauty

00:06:19,039 --> 00:06:23,919
it makes up for in robustness because

00:06:22,080 --> 00:06:25,120
many of the other solutions did not

00:06:23,919 --> 00:06:27,120
support for example

00:06:25,120 --> 00:06:28,720
empty collections and that's something

00:06:27,120 --> 00:06:29,840
that standard algorithms give us out of

00:06:28,720 --> 00:06:32,960
the box

00:06:29,840 --> 00:06:32,960
so i'm happy about that

00:06:33,280 --> 00:06:36,479
uh thinking about adjacent find and

00:06:34,880 --> 00:06:38,639
mismatch

00:06:36,479 --> 00:06:40,080
it's a very common pattern zipping a

00:06:38,639 --> 00:06:41,919
range with itself

00:06:40,080 --> 00:06:44,080
often shifted in some way in the case of

00:06:41,919 --> 00:06:47,520
adjacent fine shifted by one

00:06:44,080 --> 00:06:48,720
uh mismatch is equivalent comparing two

00:06:47,520 --> 00:06:50,000
ranges

00:06:48,720 --> 00:06:52,000
in that case it would be the range in

00:06:50,000 --> 00:06:53,360
its tail um

00:06:52,000 --> 00:06:54,639
when we zip a range with itself though

00:06:53,360 --> 00:06:56,240
we do have to be a little careful about

00:06:54,639 --> 00:06:57,840
iterator category

00:06:56,240 --> 00:07:00,000
and that's the fundamental difference

00:06:57,840 --> 00:07:01,840
between adjacent find and mismatch

00:07:00,000 --> 00:07:03,360
mismatch works on input iterators and

00:07:01,840 --> 00:07:04,319
the json fine requires the forward

00:07:03,360 --> 00:07:06,880
iterator

00:07:04,319 --> 00:07:08,479
because you're going to be looking at

00:07:06,880 --> 00:07:09,360
things and then returning things in the

00:07:08,479 --> 00:07:13,120
past so

00:07:09,360 --> 00:07:14,800
they must be invalid um and in c5 plus

00:07:13,120 --> 00:07:17,360
20 we have

00:07:14,800 --> 00:07:20,400
more things we have a string and string

00:07:17,360 --> 00:07:23,039
view getting starts with and ends with

00:07:20,400 --> 00:07:25,199
and algorithmically they are exactly the

00:07:23,039 --> 00:07:26,400
same as mismatch

00:07:25,199 --> 00:07:28,400
they're just presented as member

00:07:26,400 --> 00:07:29,680
functions so

00:07:28,400 --> 00:07:32,080
this is an important pattern in

00:07:29,680 --> 00:07:33,520
algorithms

00:07:32,080 --> 00:07:35,280
this is an important pattern you know

00:07:33,520 --> 00:07:39,120
shifted not just by one but shifted by

00:07:35,280 --> 00:07:42,560
n um and we don't get this in c plus

00:07:39,120 --> 00:07:44,720
20 yet in range v3 there is view sliding

00:07:42,560 --> 00:07:46,800
which does something like this

00:07:44,720 --> 00:07:48,720
and but of course we can always zip

00:07:46,800 --> 00:07:49,680
things with the binary version of

00:07:48,720 --> 00:07:54,240
transform it's like

00:07:49,680 --> 00:07:55,840
zip with a binary function

00:07:54,240 --> 00:07:57,360
but in terms of standardization this is

00:07:55,840 --> 00:07:58,639
still a pattern of algorithm that we're

00:07:57,360 --> 00:08:02,000
sort of working on in c

00:07:58,639 --> 00:08:05,840
plus plus anyway

00:08:02,000 --> 00:08:07,759
back to the problem so

00:08:05,840 --> 00:08:09,360
we need a new approach if we were like

00:08:07,759 --> 00:08:10,319
as like i said if if we can throw away

00:08:09,360 --> 00:08:13,440
the sorted

00:08:10,319 --> 00:08:16,240
thing we we're done but um

00:08:13,440 --> 00:08:18,639
we can't do that so how do we get a new

00:08:16,240 --> 00:08:18,639
approach

00:08:19,599 --> 00:08:26,400
um in answer to tim i didn't author any

00:08:23,199 --> 00:08:29,039
question on the board

00:08:26,400 --> 00:08:30,879
uh oh yes i didn't author the question

00:08:29,039 --> 00:08:32,640
on the super plus nine on the cpcon

00:08:30,879 --> 00:08:34,640
2019 board there was someone else it

00:08:32,640 --> 00:08:38,159
just happened to be serendipitous

00:08:34,640 --> 00:08:40,240
but that's the problem we're attacking

00:08:38,159 --> 00:08:41,440
uh and we need a new approach so how do

00:08:40,240 --> 00:08:44,800
we get one

00:08:41,440 --> 00:08:46,800
well we're not in grade school anymore

00:08:44,800 --> 00:08:48,000
we're allowed to build on the work of

00:08:46,800 --> 00:08:49,120
our friends our colleagues our

00:08:48,000 --> 00:08:50,800
predecessors

00:08:49,120 --> 00:08:52,880
there are thousands of algorithms out

00:08:50,800 --> 00:08:54,240
there the main thing you need to know is

00:08:52,880 --> 00:08:56,560
how to look for them

00:08:54,240 --> 00:08:58,480
um and this is really what it means

00:08:56,560 --> 00:09:00,160
being good at algorithms it doesn't mean

00:08:58,480 --> 00:09:02,240
coming up with optimal solutions out of

00:09:00,160 --> 00:09:04,000
thin air it means

00:09:02,240 --> 00:09:05,920
knowing the landscape of human knowledge

00:09:04,000 --> 00:09:07,760
it means recognizing problems

00:09:05,920 --> 00:09:08,959
this is what algorithm intuition is

00:09:07,760 --> 00:09:11,040
recognizing problems

00:09:08,959 --> 00:09:14,399
and and knowing what to look for because

00:09:11,040 --> 00:09:16,640
you know that the solution exists

00:09:14,399 --> 00:09:18,480
so with that in mind we're going to

00:09:16,640 --> 00:09:20,080
stand on the shoulders of giants

00:09:18,480 --> 00:09:22,000
and we're going to try the following

00:09:20,080 --> 00:09:24,160
approach now i'll go through

00:09:22,000 --> 00:09:25,680
this carefully so that everyone follows

00:09:24,160 --> 00:09:26,880
so the approach is basically going to be

00:09:25,680 --> 00:09:29,920
divide and conquer

00:09:26,880 --> 00:09:30,640
we've got this unsorted array let's say

00:09:29,920 --> 00:09:34,560
array

00:09:30,640 --> 00:09:34,560
of of integral types let's say

00:09:35,200 --> 00:09:39,680
and for each element in that array

00:09:38,160 --> 00:09:41,519
there's going to be

00:09:39,680 --> 00:09:42,720
a value there and it's going to have a

00:09:41,519 --> 00:09:45,920
position

00:09:42,720 --> 00:09:48,720
right and what we can do

00:09:45,920 --> 00:09:50,480
is uh pick the middle part pick the

00:09:48,720 --> 00:09:51,920
middle of that array

00:09:50,480 --> 00:09:53,839
and we can assume that there's only one

00:09:51,920 --> 00:09:55,360
gap that we're looking for the lowest

00:09:53,839 --> 00:09:57,279
we're looking for the lowest gap the

00:09:55,360 --> 00:10:00,640
minimum gap at the

00:09:57,279 --> 00:10:03,680
the smallest number gap

00:10:00,640 --> 00:10:04,320
so if we pick the halfway point p which

00:10:03,680 --> 00:10:07,440
we can

00:10:04,320 --> 00:10:08,000
easily do given the beginning end and we

00:10:07,440 --> 00:10:11,040
look at

00:10:08,000 --> 00:10:13,040
and and and we look at what's in

00:10:11,040 --> 00:10:14,320
that now so this slide is assuming

00:10:13,040 --> 00:10:16,560
they're still sorted but

00:10:14,320 --> 00:10:18,160
that's we'll get to that in a sec if we

00:10:16,560 --> 00:10:19,360
look at the halfway point p and what's

00:10:18,160 --> 00:10:22,240
in that gap

00:10:19,360 --> 00:10:24,240
we know that if it's greater than p

00:10:22,240 --> 00:10:27,360
there must be a gap in the bottom half

00:10:24,240 --> 00:10:30,720
and so we can recurse on the bottom half

00:10:27,360 --> 00:10:32,560
uh we know that if it's equal to p

00:10:30,720 --> 00:10:35,040
there's no gap in the bottom half so we

00:10:32,560 --> 00:10:37,120
must recurse on the top half

00:10:35,040 --> 00:10:39,519
uh and we know that when we get down to

00:10:37,120 --> 00:10:42,560
a sequence of size one

00:10:39,519 --> 00:10:43,120
the answer is going to be um the value

00:10:42,560 --> 00:10:45,600
at

00:10:43,120 --> 00:10:48,480
in our sequence the next value from the

00:10:45,600 --> 00:10:52,399
one that's in our sequence

00:10:48,480 --> 00:10:54,160
all right uh at this point i'll pause

00:10:52,399 --> 00:11:01,839
just to just to see if anyone has

00:10:54,160 --> 00:11:01,839
questions about the algorithm itself

00:11:04,000 --> 00:11:07,360
so again we're going to we're going to

00:11:05,360 --> 00:11:09,600
take the middle element we're going to

00:11:07,360 --> 00:11:11,279
see the value at that position

00:11:09,600 --> 00:11:14,399
and according to whether it's greater

00:11:11,279 --> 00:11:15,600
than the element or no

00:11:14,399 --> 00:11:17,440
we're going to recurse either on the

00:11:15,600 --> 00:11:19,440
bottom half or the top half i think a

00:11:17,440 --> 00:11:21,600
sufficient delay has now gone by that

00:11:19,440 --> 00:11:23,440
everyone i consume is understanding the

00:11:21,600 --> 00:11:26,720
algorithm

00:11:23,440 --> 00:11:29,760
okay so here's the first cut

00:11:26,720 --> 00:11:31,519
and this is very like like this is just

00:11:29,760 --> 00:11:34,240
where we're starting

00:11:31,519 --> 00:11:35,040
so we're just dealing with pointers to

00:11:34,240 --> 00:11:37,519
unsigned

00:11:35,040 --> 00:11:39,120
there's a first and last and we're

00:11:37,519 --> 00:11:40,560
calling out the b and this is recursive

00:11:39,120 --> 00:11:42,800
so we're calling out the base case

00:11:40,560 --> 00:11:44,160
if we're down to one element we're going

00:11:42,800 --> 00:11:46,959
to return

00:11:44,160 --> 00:11:49,279
what's there plus one again we're

00:11:46,959 --> 00:11:50,880
assuming they're integers at the moment

00:11:49,279 --> 00:11:52,880
and then our recursive step is going to

00:11:50,880 --> 00:11:56,079
say okay give me the middle position

00:11:52,880 --> 00:11:59,440
m um and then see if what's

00:11:56,079 --> 00:12:02,000
at that position is equal to what

00:11:59,440 --> 00:12:03,600
what should be at that position right

00:12:02,000 --> 00:12:05,360
and and if it is

00:12:03,600 --> 00:12:07,839
then we know that the bottom half is

00:12:05,360 --> 00:12:08,399
full so we recurse on the top half doing

00:12:07,839 --> 00:12:12,000
first plus

00:12:08,399 --> 00:12:14,639
m for the new first and if it's not full

00:12:12,000 --> 00:12:15,839
we will recurse on the bottom half doing

00:12:14,639 --> 00:12:20,480
uh setting the end

00:12:15,839 --> 00:12:23,920
setting the last to first plus n cool

00:12:20,480 --> 00:12:25,360
now this doesn't assume the sequence is

00:12:23,920 --> 00:12:28,000
sorted yet

00:12:25,360 --> 00:12:28,880
so what are we going to do about that

00:12:28,000 --> 00:12:34,079
what we're going to do

00:12:28,880 --> 00:12:36,320
is partition the sequence such that

00:12:34,079 --> 00:12:38,720
uh such that it's not sorted but such

00:12:36,320 --> 00:12:40,639
that everything less than m

00:12:38,720 --> 00:12:42,160
is on the left and everything greater

00:12:40,639 --> 00:12:44,800
than m or equal to m

00:12:42,160 --> 00:12:45,519
is on the right um we know that

00:12:44,800 --> 00:12:48,399
partition

00:12:45,519 --> 00:12:53,200
is linear in time and it will return the

00:12:48,399 --> 00:12:55,920
partition point

00:12:53,200 --> 00:12:56,399
so so at this point this is what we're

00:12:55,920 --> 00:12:58,880
going to do

00:12:56,399 --> 00:13:00,320
to to tackle that sortedness uh

00:12:58,880 --> 00:13:03,440
constraint

00:13:00,320 --> 00:13:05,040
and if we partition uh so

00:13:03,440 --> 00:13:07,120
let me go to the next slide and i'll

00:13:05,040 --> 00:13:08,639
show you the code it's basically the

00:13:07,120 --> 00:13:12,639
same algorithm except

00:13:08,639 --> 00:13:14,800
before we recurse we partition

00:13:12,639 --> 00:13:15,839
and so we get the partition point and

00:13:14,800 --> 00:13:20,560
say

00:13:15,839 --> 00:13:22,639
is it halfway and if it is

00:13:20,560 --> 00:13:23,839
we're going to recurse you know we're

00:13:22,639 --> 00:13:27,360
going to recurse either on the bottom or

00:13:23,839 --> 00:13:27,360
on the top quintile whether it's halfway

00:13:27,920 --> 00:13:32,639
so just a quick note about uh

00:13:31,200 --> 00:13:34,720
convincing people that this is still a

00:13:32,639 --> 00:13:36,800
linear algorithm right

00:13:34,720 --> 00:13:38,079
we're going to partition and that is

00:13:36,800 --> 00:13:40,800
linear order n

00:13:38,079 --> 00:13:41,199
we're going to then recurse on half

00:13:40,800 --> 00:13:42,639
right

00:13:41,199 --> 00:13:44,160
so we're going to get and we know that

00:13:42,639 --> 00:13:44,959
we're never recursing on more than half

00:13:44,160 --> 00:13:47,279
because

00:13:44,959 --> 00:13:48,720
we'll always recurse on at most half if

00:13:47,279 --> 00:13:51,440
it's if it's

00:13:48,720 --> 00:13:52,720
full minus one or the smaller side right

00:13:51,440 --> 00:13:55,839
so we're gonna get order n

00:13:52,720 --> 00:13:56,399
plus n over two plus n over four so the

00:13:55,839 --> 00:13:58,160
infinite

00:13:56,399 --> 00:14:00,639
sum of that is two n which is still

00:13:58,160 --> 00:14:03,760
linear this is a linear time

00:14:00,639 --> 00:14:06,639
uh algorithm

00:14:03,760 --> 00:14:07,440
so this is a fair algorithm we've got

00:14:06,639 --> 00:14:09,040
linear time

00:14:07,440 --> 00:14:11,519
we're doing it in place there's no extra

00:14:09,040 --> 00:14:13,600
memory here i think we can fairly call

00:14:11,519 --> 00:14:16,639
it practical

00:14:13,600 --> 00:14:17,680
so having got a decent algorithm this is

00:14:16,639 --> 00:14:19,760
where we start to

00:14:17,680 --> 00:14:22,079
beef it up we start to make it more

00:14:19,760 --> 00:14:23,279
robust we start to make it more generic

00:14:22,079 --> 00:14:26,000
but we've got to fundamentally get a

00:14:23,279 --> 00:14:26,320
good start so the first thing we want to

00:14:26,000 --> 00:14:29,040
do

00:14:26,320 --> 00:14:31,040
is test things right we've got an

00:14:29,040 --> 00:14:33,199
algorithm that works

00:14:31,040 --> 00:14:34,959
we've got to write some test cases so

00:14:33,199 --> 00:14:36,000
good algorithms support zero length

00:14:34,959 --> 00:14:38,160
sequences

00:14:36,000 --> 00:14:39,279
they support even length and odd length

00:14:38,160 --> 00:14:40,880
sequences

00:14:39,279 --> 00:14:42,399
you know this is kind of our bread and

00:14:40,880 --> 00:14:45,199
butter cases

00:14:42,399 --> 00:14:46,160
um maybe there's no gap in the sequence

00:14:45,199 --> 00:14:48,079
in which case we should

00:14:46,160 --> 00:14:49,600
we should return like the maximum plus

00:14:48,079 --> 00:14:52,160
one probably

00:14:49,600 --> 00:14:52,959
uh maybe there's a sequence that starts

00:14:52,160 --> 00:14:55,279
non-zero

00:14:52,959 --> 00:14:57,440
in which case we want to return probably

00:14:55,279 --> 00:15:00,320
zero for the first missing element

00:14:57,440 --> 00:15:01,519
we'll come to some choices about that um

00:15:00,320 --> 00:15:03,760
maybe there's a gap more than one in

00:15:01,519 --> 00:15:05,839
which case we want to return the minimum

00:15:03,760 --> 00:15:07,600
missing element so all of these test

00:15:05,839 --> 00:15:10,720
cases

00:15:07,600 --> 00:15:12,240
we can write and at this point once

00:15:10,720 --> 00:15:13,279
we've got it basically working we should

00:15:12,240 --> 00:15:14,880
write them

00:15:13,279 --> 00:15:16,800
um and in particular testing things like

00:15:14,880 --> 00:15:18,560
off by one arrows with even an odd

00:15:16,800 --> 00:15:20,720
and empty ranges they're good the good

00:15:18,560 --> 00:15:24,079
things to start with

00:15:20,720 --> 00:15:25,519
so having written those test cases um

00:15:24,079 --> 00:15:27,199
an important thing to do next is to

00:15:25,519 --> 00:15:28,880
remove the recursion because algorithms

00:15:27,199 --> 00:15:32,320
are usually simpler to think of

00:15:28,880 --> 00:15:34,000
in recursive uh formulation

00:15:32,320 --> 00:15:36,240
but what we want to end up with is

00:15:34,000 --> 00:15:39,360
probably a non-recursive

00:15:36,240 --> 00:15:42,560
algorithm this original function

00:15:39,360 --> 00:15:44,639
is recursive as you can see um happily

00:15:42,560 --> 00:15:46,560
it's tail recursive which means that

00:15:44,639 --> 00:15:48,639
the last thing it does is make a call to

00:15:46,560 --> 00:15:50,800
itself and after that it doesn't need to

00:15:48,639 --> 00:15:52,079
um take that value and add it to

00:15:50,800 --> 00:15:55,360
something or anything so

00:15:52,079 --> 00:15:58,160
it's passing along the value

00:15:55,360 --> 00:15:59,680
uh down the chord stack so that by the

00:15:58,160 --> 00:16:01,120
time we're done recursive

00:15:59,680 --> 00:16:02,320
we've got the value at the bottom of the

00:16:01,120 --> 00:16:03,759
call stack as it were so we're tail

00:16:02,320 --> 00:16:06,880
recursive

00:16:03,759 --> 00:16:08,639
um that would normally be the first

00:16:06,880 --> 00:16:09,839
change if you have a non-tail recursive

00:16:08,639 --> 00:16:11,040
algorithm to make it into a tail

00:16:09,839 --> 00:16:13,199
recursive algorithm

00:16:11,040 --> 00:16:14,639
by pass along passing along some

00:16:13,199 --> 00:16:15,759
accumulated value

00:16:14,639 --> 00:16:17,279
such that when you get down to the

00:16:15,759 --> 00:16:18,639
bottom of the recursion you've

00:16:17,279 --> 00:16:19,199
immediately got the value and you don't

00:16:18,639 --> 00:16:21,920
have to

00:16:19,199 --> 00:16:23,040
come back up the stack and do more

00:16:21,920 --> 00:16:24,560
things to it

00:16:23,040 --> 00:16:26,560
so that's the first step happily here

00:16:24,560 --> 00:16:28,480
it's the case anyway

00:16:26,560 --> 00:16:30,480
the next thing we do is take the base

00:16:28,480 --> 00:16:30,880
case usually and make it into a while

00:16:30,480 --> 00:16:34,240
loop

00:16:30,880 --> 00:16:35,440
and return after it and it's usually

00:16:34,240 --> 00:16:38,160
going to be

00:16:35,440 --> 00:16:41,519
while last not equal to first you know

00:16:38,160 --> 00:16:43,600
that's a very common pattern

00:16:41,519 --> 00:16:45,440
because we're going to step first in

00:16:43,600 --> 00:16:46,160
whatever way until the algorithm is done

00:16:45,440 --> 00:16:47,360
and there's no

00:16:46,160 --> 00:16:51,279
and there's an empty range left

00:16:47,360 --> 00:16:54,639
basically and then we return the value

00:16:51,279 --> 00:16:56,880
and then once we're there

00:16:54,639 --> 00:16:57,759
we change our return statements so

00:16:56,880 --> 00:17:01,199
before we had

00:16:57,759 --> 00:17:03,040
the recursive calls still in here um

00:17:01,199 --> 00:17:05,039
once we've done that we can change those

00:17:03,040 --> 00:17:08,240
return find missing elements to simply

00:17:05,039 --> 00:17:08,959
updating the variables in place so

00:17:08,240 --> 00:17:11,280
rather than

00:17:08,959 --> 00:17:12,640
returning the recursive call we're going

00:17:11,280 --> 00:17:15,679
to

00:17:12,640 --> 00:17:18,959
update first and value

00:17:15,679 --> 00:17:22,319
in the in the uh in the

00:17:18,959 --> 00:17:25,120
top half case and update the

00:17:22,319 --> 00:17:27,120
the end the last for the bottom half

00:17:25,120 --> 00:17:29,120
case

00:17:27,120 --> 00:17:30,320
and so in those three steps we've

00:17:29,120 --> 00:17:32,880
replaced we've

00:17:30,320 --> 00:17:34,000
we've done that replacement we've turned

00:17:32,880 --> 00:17:37,440
a recursive

00:17:34,000 --> 00:17:40,080
uh function into an iterative function

00:17:37,440 --> 00:17:40,960
so first of all we didn't need to do

00:17:40,080 --> 00:17:43,600
this for our

00:17:40,960 --> 00:17:44,960
for our thing but um this is usually the

00:17:43,600 --> 00:17:46,799
first step you add an accumulator

00:17:44,960 --> 00:17:49,120
variable to the signature

00:17:46,799 --> 00:17:52,000
return it in the base case and that's

00:17:49,120 --> 00:17:54,400
that turns you into tail recursive

00:17:52,000 --> 00:17:55,039
uh secondly convert the base case

00:17:54,400 --> 00:17:57,919
condition

00:17:55,039 --> 00:17:59,679
into a loop that's typically while first

00:17:57,919 --> 00:18:01,360
not equal to last loop

00:17:59,679 --> 00:18:04,559
and then you return the accumulator

00:18:01,360 --> 00:18:04,559
value after the loop

00:18:05,280 --> 00:18:08,799
and replace recursive calls with

00:18:07,039 --> 00:18:10,400
variable updates in there so instead of

00:18:08,799 --> 00:18:12,799
rebinding them on the recursive call you

00:18:10,400 --> 00:18:16,799
assign them

00:18:12,799 --> 00:18:18,400
okay couple of questions showing up um

00:18:16,799 --> 00:18:19,919
yeah people asked about the sortedness

00:18:18,400 --> 00:18:21,440
they're happy now i think that we're not

00:18:19,919 --> 00:18:22,720
requiring sort of since we introduced a

00:18:21,440 --> 00:18:24,320
partition

00:18:22,720 --> 00:18:26,640
question what is the order of magnitude

00:18:24,320 --> 00:18:29,200
of n in the problem

00:18:26,640 --> 00:18:30,799
uh we're not yet concerned with that

00:18:29,200 --> 00:18:33,840
we're that's not really

00:18:30,799 --> 00:18:35,919
um a concern here it

00:18:33,840 --> 00:18:37,360
i mean i think we can say let's say

00:18:35,919 --> 00:18:40,080
human scale

00:18:37,360 --> 00:18:40,880
um we're not dealing with billions of n

00:18:40,080 --> 00:18:42,720
uh

00:18:40,880 --> 00:18:44,080
and we might not be dealing with one or

00:18:42,720 --> 00:18:46,400
two n you know so

00:18:44,080 --> 00:18:48,480
so this algorithm i'm not going to get

00:18:46,400 --> 00:18:49,840
to um the sort of adaptive

00:18:48,480 --> 00:18:51,840
algorithm stuff where you deal

00:18:49,840 --> 00:18:54,559
differently with very small numbers

00:18:51,840 --> 00:18:56,160
or very large numbers uh this is going

00:18:54,559 --> 00:18:57,919
to be more of a talk about

00:18:56,160 --> 00:18:59,600
how to genericize the algorithm for

00:18:57,919 --> 00:19:01,280
human scale n

00:18:59,600 --> 00:19:03,919
but there certainly are steps you could

00:19:01,280 --> 00:19:07,440
do uh that go beyond this talk

00:19:03,919 --> 00:19:07,440
with adaptive algorithms

00:19:08,400 --> 00:19:12,080
okay so here we are this is where we are

00:19:10,720 --> 00:19:13,600
right now

00:19:12,080 --> 00:19:14,880
um we've got our while loop in there

00:19:13,600 --> 00:19:16,240
we've got our partition in the middle

00:19:14,880 --> 00:19:19,280
and we've got our

00:19:16,240 --> 00:19:20,559
iterative recursion but perhaps this is

00:19:19,280 --> 00:19:21,360
the moment you've been waiting for

00:19:20,559 --> 00:19:23,840
because

00:19:21,360 --> 00:19:26,240
it's still not very generic what's the

00:19:23,840 --> 00:19:29,280
obvious way to make it generic

00:19:26,240 --> 00:19:29,280
add in templates

00:19:30,000 --> 00:19:34,720
so exactly the same algorithm all i've

00:19:32,480 --> 00:19:38,240
done is turn those unsigned pointers

00:19:34,720 --> 00:19:40,880
into iterators

00:19:38,240 --> 00:19:42,640
um we know it's going to take some sort

00:19:40,880 --> 00:19:44,720
of iterator pair first and last

00:19:42,640 --> 00:19:46,799
and the result is going to be something

00:19:44,720 --> 00:19:48,559
of the value type that those iterators

00:19:46,799 --> 00:19:51,760
point to typically

00:19:48,559 --> 00:19:52,240
so the next question to ask here is what

00:19:51,760 --> 00:19:54,640
sort of

00:19:52,240 --> 00:19:56,160
iterator do we need what's the category

00:19:54,640 --> 00:19:58,880
of iterator

00:19:56,160 --> 00:19:58,880
that we're using

00:19:59,520 --> 00:20:04,640
so quick refresher on iterator

00:20:02,799 --> 00:20:05,120
categories which are now concepts in c

00:20:04,640 --> 00:20:08,480
plus

00:20:05,120 --> 00:20:13,520
20. um at the le

00:20:08,480 --> 00:20:13,520
so mostly when we write algorithms

00:20:13,760 --> 00:20:18,960
uh the the the we're using either input

00:20:17,520 --> 00:20:22,080
or forward iterators or

00:20:18,960 --> 00:20:23,440
output iterators sort of special beast

00:20:22,080 --> 00:20:25,760
input just means you can run over a

00:20:23,440 --> 00:20:28,400
sequence once forward means you can

00:20:25,760 --> 00:20:30,320
you can run over a sequence and sort of

00:20:28,400 --> 00:20:33,280
look in the past but you can only

00:20:30,320 --> 00:20:35,679
increment bi-directional means you can

00:20:33,280 --> 00:20:37,120
increment or decrement the iterator

00:20:35,679 --> 00:20:38,799
and random access means you can jump

00:20:37,120 --> 00:20:40,960
around obviously

00:20:38,799 --> 00:20:42,480
and in 20 we got also contiguous

00:20:40,960 --> 00:20:44,240
iterator i don't think this is used in

00:20:42,480 --> 00:20:48,159
any algorithms yet but it is part of

00:20:44,240 --> 00:20:49,520
concepts for ranges

00:20:48,159 --> 00:20:51,280
so there's a question if it's human

00:20:49,520 --> 00:20:52,960
scale the fastest algorithm is generate

00:20:51,280 --> 00:20:54,720
a random 64-bit number

00:20:52,960 --> 00:20:56,720
and do a linear search for it until no

00:20:54,720 --> 00:20:59,840
collision

00:20:56,720 --> 00:21:01,600
potentially but a number isn't

00:20:59,840 --> 00:21:04,799
necessarily generic

00:21:01,600 --> 00:21:07,840
what kind of number like that so

00:21:04,799 --> 00:21:10,000
so yes maybe

00:21:07,840 --> 00:21:10,880
um but we're going to get to uses for

00:21:10,000 --> 00:21:17,360
this algorithm

00:21:10,880 --> 00:21:21,120
which go beyond integers um

00:21:17,360 --> 00:21:23,360
so these are the iterated concepts um

00:21:21,120 --> 00:21:24,240
so you look at your algorithm and how do

00:21:23,360 --> 00:21:26,799
you decide

00:21:24,240 --> 00:21:28,720
what kind of iterative concept you need

00:21:26,799 --> 00:21:31,360
well the first thing you say is

00:21:28,720 --> 00:21:32,400
am i using any standard algorithms that

00:21:31,360 --> 00:21:35,679
require

00:21:32,400 --> 00:21:37,280
a certain iterator um and if so

00:21:35,679 --> 00:21:39,120
then i'm going to also require that

00:21:37,280 --> 00:21:40,240
iterator now in our case we're using

00:21:39,120 --> 00:21:43,440
partition

00:21:40,240 --> 00:21:46,720
so partition requires a

00:21:43,440 --> 00:21:47,600
forward iterator i believe so we're

00:21:46,720 --> 00:21:50,400
going to require

00:21:47,600 --> 00:21:51,840
a forward iterator and this also informs

00:21:50,400 --> 00:21:53,840
your complexity guarantees because if

00:21:51,840 --> 00:21:55,919
you're using a standard algorithm

00:21:53,840 --> 00:21:57,120
um it might have different complexities

00:21:55,919 --> 00:22:00,000
depending on which it's

00:21:57,120 --> 00:22:01,600
iterator category you provide for

00:22:00,000 --> 00:22:02,799
instance with partition if you give it a

00:22:01,600 --> 00:22:06,080
forward iterator

00:22:02,799 --> 00:22:08,480
it's going to do at most n swaps

00:22:06,080 --> 00:22:11,360
if you provide a bi-directional iterator

00:22:08,480 --> 00:22:13,120
it can do its job with n over two swaps

00:22:11,360 --> 00:22:14,880
which is good so the stronger the

00:22:13,120 --> 00:22:17,760
iterator you can provide

00:22:14,880 --> 00:22:18,880
the better performance you get but if

00:22:17,760 --> 00:22:22,240
you can support

00:22:18,880 --> 00:22:26,159
lower weaker iterator categories

00:22:22,240 --> 00:22:29,679
then at least you get functionality

00:22:26,159 --> 00:22:30,720
um now aside from that we have to answer

00:22:29,679 --> 00:22:32,799
the questions

00:22:30,720 --> 00:22:34,159
do i look at an element after moving

00:22:32,799 --> 00:22:35,919
past it if that's the case

00:22:34,159 --> 00:22:38,880
i will need at least a forward iterator

00:22:35,919 --> 00:22:41,760
because an input iterator can't do that

00:22:38,880 --> 00:22:44,000
uh slightly more tricky to spot

00:22:41,760 --> 00:22:45,360
sometimes is do i return an element

00:22:44,000 --> 00:22:46,799
after moving past it so it's

00:22:45,360 --> 00:22:48,000
it's usually fairly easy to see if

00:22:46,799 --> 00:22:48,799
you're looking at an element after

00:22:48,000 --> 00:22:51,280
moving past it

00:22:48,799 --> 00:22:52,640
it's it's not so obvious sometimes if

00:22:51,280 --> 00:22:53,760
you return that element after moving

00:22:52,640 --> 00:22:55,039
past it

00:22:53,760 --> 00:22:56,320
that also would require a forward

00:22:55,039 --> 00:22:57,600
iterator because there's no point

00:22:56,320 --> 00:23:00,559
returning something which the caller is

00:22:57,600 --> 00:23:00,559
not going to be able to use

00:23:00,960 --> 00:23:04,080
um of course if you need to decrement

00:23:02,880 --> 00:23:06,080
the iterator

00:23:04,080 --> 00:23:07,679
you need a bi-directional iterator but

00:23:06,080 --> 00:23:09,600
there's an interesting case here where

00:23:07,679 --> 00:23:12,720
you might just be looking at

00:23:09,600 --> 00:23:13,840
like the last you can sort of cache the

00:23:12,720 --> 00:23:15,520
point where you're looking maybe if

00:23:13,840 --> 00:23:18,559
you're looking just one behind

00:23:15,520 --> 00:23:20,799
um there could be there could be you

00:23:18,559 --> 00:23:22,799
know things you can do there

00:23:20,799 --> 00:23:25,039
uh and if you actually need to increment

00:23:22,799 --> 00:23:26,640
decrement by more than one

00:23:25,039 --> 00:23:29,200
to jump around you might need random

00:23:26,640 --> 00:23:30,400
access but again you can do this in

00:23:29,200 --> 00:23:32,880
linear time

00:23:30,400 --> 00:23:34,799
with a bad eye or a forward iterator

00:23:32,880 --> 00:23:37,520
perhaps

00:23:34,799 --> 00:23:38,000
it's just a question of you know what

00:23:37,520 --> 00:23:42,000
you

00:23:38,000 --> 00:23:45,919
what you want to support versus the

00:23:42,000 --> 00:23:45,919
the performance that you want

00:23:46,559 --> 00:23:50,000
okay so what sort of iterated here's our

00:23:48,720 --> 00:23:52,320
function again

00:23:50,000 --> 00:23:53,679
uh what sort of iterator do we need well

00:23:52,320 --> 00:23:55,360
we know that partition requires a

00:23:53,679 --> 00:23:58,960
forward iterator

00:23:55,360 --> 00:24:02,000
um and so we will need at least

00:23:58,960 --> 00:24:03,200
a forward iterator

00:24:02,000 --> 00:24:05,120
and so here's what our function

00:24:03,200 --> 00:24:08,480
signature looks like in

00:24:05,120 --> 00:24:09,360
in 20 and prior to 20 we don't get to

00:24:08,480 --> 00:24:12,000
use the

00:24:09,360 --> 00:24:12,960
the concepts yet but it's very similar

00:24:12,000 --> 00:24:19,840
in either case

00:24:12,960 --> 00:24:19,840
we're using a forward iterator

00:24:29,039 --> 00:24:33,360
so we can't do general iterator

00:24:32,559 --> 00:24:35,919
arithmetic

00:24:33,360 --> 00:24:37,520
on forward iterators and in our function

00:24:35,919 --> 00:24:40,240
right now

00:24:37,520 --> 00:24:42,720
on that line on the fourth line down

00:24:40,240 --> 00:24:46,240
we're taking away first from last

00:24:42,720 --> 00:24:49,279
and a few lines later we're adding half

00:24:46,240 --> 00:24:51,200
to first so we're going to need to fix

00:24:49,279 --> 00:24:54,960
up these places because those operations

00:24:51,200 --> 00:24:54,960
are not supported by a ford iterator

00:24:55,360 --> 00:24:58,720
however the standard library gives us

00:24:57,200 --> 00:25:01,039
these handy functions that we can use to

00:24:58,720 --> 00:25:02,960
manipulate iterators

00:25:01,039 --> 00:25:04,720
and these are also implemented to work

00:25:02,960 --> 00:25:06,559
as efficiently as possible

00:25:04,720 --> 00:25:09,279
on each iterator category that they can

00:25:06,559 --> 00:25:10,880
take and so by using them we're going to

00:25:09,279 --> 00:25:11,840
get the right deficiency the best

00:25:10,880 --> 00:25:13,919
efficiency

00:25:11,840 --> 00:25:16,000
for any particular algorithm for any

00:25:13,919 --> 00:25:17,039
particular iterator that's passed into

00:25:16,000 --> 00:25:18,480
our algorithm

00:25:17,039 --> 00:25:20,720
so even though our algorithm takes a

00:25:18,480 --> 00:25:22,400
forward iterator we've got to remember

00:25:20,720 --> 00:25:25,440
that a random access iterator is a

00:25:22,400 --> 00:25:28,159
forward iterator these things are like a

00:25:25,440 --> 00:25:29,360
hierarchy so if you have a random access

00:25:28,159 --> 00:25:32,159
iterator

00:25:29,360 --> 00:25:33,919
and you pass it and you stood next on it

00:25:32,159 --> 00:25:35,840
you're going to get

00:25:33,919 --> 00:25:36,960
a a jump to the right place rather than

00:25:35,840 --> 00:25:39,919
a linear add

00:25:36,960 --> 00:25:39,919
ad increment

00:25:40,799 --> 00:25:44,480
so in this way we can do pointer

00:25:42,159 --> 00:25:47,600
arithmetic without

00:25:44,480 --> 00:25:50,240
losing support for forward iterators

00:25:47,600 --> 00:25:51,039
um and so we'll relax that line there

00:25:50,240 --> 00:25:53,360
we'll go from

00:25:51,039 --> 00:25:54,880
the actual arithmetic to just saying

00:25:53,360 --> 00:25:57,440
let's find the distance

00:25:54,880 --> 00:25:58,720
and we'll relax that line there saying

00:25:57,440 --> 00:26:01,760
instead of adding

00:25:58,720 --> 00:26:01,760
we'll do stood next

00:26:01,840 --> 00:26:06,640
and now so what we've gained here is

00:26:03,679 --> 00:26:10,159
that we've we support forward iterators

00:26:06,640 --> 00:26:14,320
without losing uh the complexity

00:26:10,159 --> 00:26:17,360
um without losing the runtime efficiency

00:26:14,320 --> 00:26:18,000
for stronger iterators so if we can

00:26:17,360 --> 00:26:20,159
support

00:26:18,000 --> 00:26:23,039
a weaker iterator it makes our algorithm

00:26:20,159 --> 00:26:26,000
algorithm more useful

00:26:23,039 --> 00:26:26,720
so what was previously only usable with

00:26:26,000 --> 00:26:29,520
you know

00:26:26,720 --> 00:26:30,400
random access iterator containers is now

00:26:29,520 --> 00:26:33,440
useful with

00:26:30,400 --> 00:26:37,200
containers that provide bi-directional

00:26:33,440 --> 00:26:37,200
iterators and or forward iterators

00:26:37,600 --> 00:26:43,840
now there's a choice to make here

00:26:40,720 --> 00:26:44,559
we might this if we decide that we don't

00:26:43,840 --> 00:26:47,440
want

00:26:44,559 --> 00:26:48,720
to um provide the algorithm for weaker

00:26:47,440 --> 00:26:50,400
containers because it means a

00:26:48,720 --> 00:26:52,799
significant performance change

00:26:50,400 --> 00:26:54,320
that could be a pitfall that's our

00:26:52,799 --> 00:26:56,000
choice but the important thing is

00:26:54,320 --> 00:26:57,919
it's a human decision now it's a

00:26:56,000 --> 00:27:00,080
business decision it's not a technical

00:26:57,919 --> 00:27:02,960
limitation

00:27:00,080 --> 00:27:04,880
right so we might still decide not to

00:27:02,960 --> 00:27:05,520
support the thing for forward iterators

00:27:04,880 --> 00:27:06,799
because

00:27:05,520 --> 00:27:07,840
someone at the call site isn't going to

00:27:06,799 --> 00:27:11,039
know and they're going to fall off a

00:27:07,840 --> 00:27:13,919
performance cliff or something like that

00:27:11,039 --> 00:27:14,240
that is now not a technical decision but

00:27:13,919 --> 00:27:18,400
a

00:27:14,240 --> 00:27:18,400
business decision which is what you want

00:27:19,120 --> 00:27:22,640
okay do please ask questions as we go

00:27:21,520 --> 00:27:26,320
i'll try to ask them

00:27:22,640 --> 00:27:27,039
as as we go and tim uh the volunteer

00:27:26,320 --> 00:27:30,480
will

00:27:27,039 --> 00:27:33,039
hand them to me thank you okay

00:27:30,480 --> 00:27:34,159
so there are a few places in the

00:27:33,039 --> 00:27:38,720
standard

00:27:34,159 --> 00:27:41,840
that the iterator categories don't quite

00:27:38,720 --> 00:27:44,880
match up to what we know is possible

00:27:41,840 --> 00:27:47,360
partition is an example of this

00:27:44,880 --> 00:27:47,919
when when alex steppen off and mainly

00:27:47,360 --> 00:27:50,000
wrote

00:27:47,919 --> 00:27:53,120
wrote the stl back in the early to mid

00:27:50,000 --> 00:27:56,320
90s in the sgi implementation

00:27:53,120 --> 00:27:59,520
um partition takes a forward iterator

00:27:56,320 --> 00:28:00,320
uh when it was standardized in 1998

00:27:59,520 --> 00:28:02,159
it was standardized with a

00:28:00,320 --> 00:28:03,919
bi-directional iterator and we did fix

00:28:02,159 --> 00:28:06,880
this in c blood plus 11

00:28:03,919 --> 00:28:08,480
and it now takes a forward iterator

00:28:06,880 --> 00:28:10,880
stable partition still

00:28:08,480 --> 00:28:12,399
requires a bidirectional iterator even

00:28:10,880 --> 00:28:14,880
though we know how to do it

00:28:12,399 --> 00:28:16,000
with a forward iterator the standard

00:28:14,880 --> 00:28:19,600
hasn't yet

00:28:16,000 --> 00:28:22,799
had that proposed so so there we go

00:28:19,600 --> 00:28:26,399
there's a bit of a mismatch there

00:28:22,799 --> 00:28:27,279
um in place merge is another uh standard

00:28:26,399 --> 00:28:29,200
algorithm

00:28:27,279 --> 00:28:31,279
that is currently specified to take a

00:28:29,200 --> 00:28:33,360
bidirectional iterator

00:28:31,279 --> 00:28:35,279
and it's perfectly doable with the

00:28:33,360 --> 00:28:36,799
forward iterator

00:28:35,279 --> 00:28:38,320
and this is one of those algorithms that

00:28:36,799 --> 00:28:41,279
has a better time complexity

00:28:38,320 --> 00:28:41,919
if allocation is allowed it's it's

00:28:41,279 --> 00:28:44,960
efficient

00:28:41,919 --> 00:28:46,880
it's most efficient if it can allocate

00:28:44,960 --> 00:28:50,480
a size of at least the smaller of the

00:28:46,880 --> 00:28:50,480
two halves that you're merging together

00:28:51,919 --> 00:28:57,120
so this this idea of using the right

00:28:55,200 --> 00:28:59,840
iterator category and in particular

00:28:57,120 --> 00:29:02,880
using stood next does the distance

00:28:59,840 --> 00:29:05,600
is an important step and it's a specific

00:29:02,880 --> 00:29:07,440
a specific form of strength reduction so

00:29:05,600 --> 00:29:10,799
strength reduction

00:29:07,440 --> 00:29:13,120
is using a weaker

00:29:10,799 --> 00:29:14,880
operation to achieve the same effect as

00:29:13,120 --> 00:29:16,240
a complicated more complicated or

00:29:14,880 --> 00:29:17,520
stronger oppressed in some sense

00:29:16,240 --> 00:29:19,120
stronger operation

00:29:17,520 --> 00:29:20,640
it's something your compiler does all

00:29:19,120 --> 00:29:22,720
the time when it optimizes

00:29:20,640 --> 00:29:23,760
it's things like replace and multiply

00:29:22,720 --> 00:29:26,799
with a with

00:29:23,760 --> 00:29:28,960
equivalent shifts or replace a division

00:29:26,799 --> 00:29:30,880
by a constant with a multiplication by a

00:29:28,960 --> 00:29:31,919
huge number and and that strange

00:29:30,880 --> 00:29:33,840
operation that you

00:29:31,919 --> 00:29:35,520
you'll know if you've ever looked at um

00:29:33,840 --> 00:29:38,559
disassembly for gcc

00:29:35,520 --> 00:29:39,919
that does that for example

00:29:38,559 --> 00:29:42,960
so this is something compiler does all

00:29:39,919 --> 00:29:45,760
the time but as as humans as algorithms

00:29:42,960 --> 00:29:47,279
it behooves us to to to do this to our

00:29:45,760 --> 00:29:49,200
algorithms

00:29:47,279 --> 00:29:51,039
not not even so much to achieve

00:29:49,200 --> 00:29:53,520
optimization but to see the structure

00:29:51,039 --> 00:29:55,840
and the limitations of our algorithms

00:29:53,520 --> 00:29:57,120
so here are the operations here are some

00:29:55,840 --> 00:29:57,919
operations that we need to consider

00:29:57,120 --> 00:30:01,039
carefully

00:29:57,919 --> 00:30:01,039
when we make an algorithm

00:30:01,200 --> 00:30:05,600
decrement we saw uh maybe we can buffer

00:30:04,240 --> 00:30:06,960
the previous iterator instead of

00:30:05,600 --> 00:30:09,520
decrementing

00:30:06,960 --> 00:30:11,200
um addition as a general thing

00:30:09,520 --> 00:30:14,880
separately from incrementing

00:30:11,200 --> 00:30:17,520
their different operations um

00:30:14,880 --> 00:30:18,880
post-fix and prefix increments these

00:30:17,520 --> 00:30:20,000
might be important for non-trivial

00:30:18,880 --> 00:30:21,200
iterators they usually

00:30:20,000 --> 00:30:23,039
usually compile down to the same thing

00:30:21,200 --> 00:30:24,720
when it comes to integers

00:30:23,039 --> 00:30:26,320
but when you when you say non-trivial

00:30:24,720 --> 00:30:28,240
iterators you know maybe the compiler

00:30:26,320 --> 00:30:30,240
isn't allowed to align that copy or

00:30:28,240 --> 00:30:33,520
optimize that away

00:30:30,240 --> 00:30:34,320
um there are equality and ordering

00:30:33,520 --> 00:30:36,159
requirements

00:30:34,320 --> 00:30:37,840
on our types in fact we'll come much

00:30:36,159 --> 00:30:39,600
more to this there are in general

00:30:37,840 --> 00:30:41,200
requirements on the types that come into

00:30:39,600 --> 00:30:43,200
our algorithms that we need to carefully

00:30:41,200 --> 00:30:47,039
consider

00:30:43,200 --> 00:30:49,919
another operation that's important is

00:30:47,039 --> 00:30:52,720
halving and doubling distinct from

00:30:49,919 --> 00:30:54,960
generalized multiplication or division

00:30:52,720 --> 00:30:56,240
um because for a long time now computers

00:30:54,960 --> 00:30:57,760
have been able to halve and double

00:30:56,240 --> 00:31:00,880
things very very quickly

00:30:57,760 --> 00:31:02,240
compared to how they can uh multiply

00:31:00,880 --> 00:31:03,120
them in general or divide them in

00:31:02,240 --> 00:31:04,480
general

00:31:03,120 --> 00:31:07,600
in fact there's a famous story about

00:31:04,480 --> 00:31:08,240
this um the most famous algorithm of

00:31:07,600 --> 00:31:10,799
them all

00:31:08,240 --> 00:31:14,559
the euclid's greatest common divisor you

00:31:10,799 --> 00:31:17,440
know it stood for two thousand odd years

00:31:14,559 --> 00:31:20,000
and um and then there was a there was an

00:31:17,440 --> 00:31:23,360
israeli researcher called joseph stein

00:31:20,000 --> 00:31:26,480
in 1967 who was working on hardware

00:31:23,360 --> 00:31:27,760
uh that he couldn't you know necessity

00:31:26,480 --> 00:31:28,880
was the mother of invention here and he

00:31:27,760 --> 00:31:30,080
had to come up with an alternative

00:31:28,880 --> 00:31:33,200
formulation to

00:31:30,080 --> 00:31:36,559
the classical gcd algorithm um

00:31:33,200 --> 00:31:38,480
and is based on his his algorithm is

00:31:36,559 --> 00:31:41,120
based on halving and doubling

00:31:38,480 --> 00:31:43,039
and and he came up with a formulation of

00:31:41,120 --> 00:31:44,640
greatest common divisor which was

00:31:43,039 --> 00:31:46,080
you know potentially more efficient than

00:31:44,640 --> 00:31:46,399
the classically known one we just did

00:31:46,080 --> 00:31:49,919
for

00:31:46,399 --> 00:31:51,120
2000 years and it's this this idea of

00:31:49,919 --> 00:31:52,799
that halving and doubling

00:31:51,120 --> 00:31:54,159
is a should be considered a separate

00:31:52,799 --> 00:31:56,880
operation from generic

00:31:54,159 --> 00:31:56,880
multiplication

00:31:57,519 --> 00:32:01,279
there's a question would it be

00:31:58,799 --> 00:32:05,120
recommended to relax even more with adl

00:32:01,279 --> 00:32:05,760
with using idiom for customization

00:32:05,120 --> 00:32:10,159
points for

00:32:05,760 --> 00:32:14,799
next and so on uh

00:32:10,159 --> 00:32:17,200
not if i understand the question

00:32:14,799 --> 00:32:18,559
i'm gonna say it's outside the scope of

00:32:17,200 --> 00:32:22,080
this talk

00:32:18,559 --> 00:32:22,559
maybe maybe um i don't want to get too

00:32:22,080 --> 00:32:26,000
deep

00:32:22,559 --> 00:32:28,000
into library fundamentals and

00:32:26,000 --> 00:32:29,840
and and and that kind of thing this talk

00:32:28,000 --> 00:32:32,640
is more focused on

00:32:29,840 --> 00:32:33,360
you know how to how to craft the

00:32:32,640 --> 00:32:35,200
algorithm

00:32:33,360 --> 00:32:36,799
um the customization point the end of

00:32:35,200 --> 00:32:38,000
the day you could

00:32:36,799 --> 00:32:42,000
you could choose a few different ways to

00:32:38,000 --> 00:32:45,440
do it perhaps yes

00:32:42,000 --> 00:32:46,960
uh the last operation here

00:32:45,440 --> 00:32:48,640
is something that you know we would have

00:32:46,960 --> 00:32:49,039
we would have said if i was giving this

00:32:48,640 --> 00:32:51,519
talk

00:32:49,039 --> 00:32:52,640
20 25 years ago i would have said you

00:32:51,519 --> 00:32:54,880
know

00:32:52,640 --> 00:32:56,320
generic multiplication and division we

00:32:54,880 --> 00:32:58,720
should manually strength reduce those

00:32:56,320 --> 00:33:01,120
but i think these days the compilers do

00:32:58,720 --> 00:33:01,760
a fantastic job at that and generally we

00:33:01,120 --> 00:33:04,000
should write

00:33:01,760 --> 00:33:05,440
our readable code and not go to the

00:33:04,000 --> 00:33:07,840
level of of

00:33:05,440 --> 00:33:08,640
obfuscating those operations in the

00:33:07,840 --> 00:33:10,559
algorithm

00:33:08,640 --> 00:33:13,760
because at some point the compiler can

00:33:10,559 --> 00:33:13,760
be relied on to do that stuff

00:33:14,320 --> 00:33:17,360
so let's talk more about the

00:33:15,840 --> 00:33:20,159
requirements on types because

00:33:17,360 --> 00:33:20,799
eric niebler did make this observation

00:33:20,159 --> 00:33:23,840
it's a very

00:33:20,799 --> 00:33:25,279
true observation concepts are

00:33:23,840 --> 00:33:26,799
constraints on types but you don't find

00:33:25,279 --> 00:33:29,120
them by looking at types

00:33:26,799 --> 00:33:31,039
you find them by studying algorithms and

00:33:29,120 --> 00:33:33,519
seeing what the algorithm requires of

00:33:31,039 --> 00:33:36,080
the types

00:33:33,519 --> 00:33:37,440
so here's our code as it stands after

00:33:36,080 --> 00:33:38,960
strength reduction

00:33:37,440 --> 00:33:40,320
we've got our fourth iterator coming in

00:33:38,960 --> 00:33:42,640
we've got us the distance to the next

00:33:40,320 --> 00:33:45,679
this is exactly what you saw

00:33:42,640 --> 00:33:48,000
oh a dozen slides ago how many um

00:33:45,679 --> 00:33:50,240
so this algorithm is coming along now

00:33:48,000 --> 00:33:52,480
there is a lurking issue

00:33:50,240 --> 00:33:55,279
um no one's putting the question about

00:33:52,480 --> 00:33:58,320
it yet so i will just tell you

00:33:55,279 --> 00:34:01,919
um if we compile this

00:33:58,320 --> 00:34:01,919
with w conversion

00:34:02,480 --> 00:34:07,039
the issue is that the thing returned by

00:34:04,799 --> 00:34:09,760
stood distance here

00:34:07,039 --> 00:34:10,960
is a signed type and we said at the top

00:34:09,760 --> 00:34:14,560
of the talk

00:34:10,960 --> 00:34:16,159
that we were using unsigned and so

00:34:14,560 --> 00:34:18,839
on that line where we compute the

00:34:16,159 --> 00:34:22,639
distance and assign it to an unsigned

00:34:18,839 --> 00:34:26,000
quality we get

00:34:22,639 --> 00:34:29,200
we get a compiler warning basically

00:34:26,000 --> 00:34:30,320
um so we can get around that just by

00:34:29,200 --> 00:34:32,560
putting in a static cast

00:34:30,320 --> 00:34:35,440
for now it seems okay does it add any

00:34:32,560 --> 00:34:37,679
assumptions to our algorithm

00:34:35,440 --> 00:34:39,200
not really don't think so yet we'll go

00:34:37,679 --> 00:34:41,839
with it for now

00:34:39,200 --> 00:34:42,480
um but you know maybe there's another

00:34:41,839 --> 00:34:43,599
problem

00:34:42,480 --> 00:34:45,280
here that you're seeing which you're

00:34:43,599 --> 00:34:46,000
practically shouting at the monitor to

00:34:45,280 --> 00:34:48,240
me

00:34:46,000 --> 00:34:49,919
and i know several people have been

00:34:48,240 --> 00:34:52,159
shouting at the monitor i'm sure

00:34:49,919 --> 00:34:53,839
and that is that where's ben where's the

00:34:52,159 --> 00:34:56,720
const where's the const expert

00:34:53,839 --> 00:34:57,760
all right so we put in constant

00:34:56,720 --> 00:34:58,720
everywhere putting contacts for

00:34:57,760 --> 00:35:02,720
everywhere

00:34:58,720 --> 00:35:05,839
that's there you go jason um

00:35:02,720 --> 00:35:06,320
that's done fairly fairly easy to do

00:35:05,839 --> 00:35:08,560
that

00:35:06,320 --> 00:35:10,000
right but you know and and you think

00:35:08,560 --> 00:35:10,800
that's trevilla maybe you'd start out

00:35:10,000 --> 00:35:12,560
there

00:35:10,800 --> 00:35:14,320
but it's important to consider kind of

00:35:12,560 --> 00:35:15,359
every every little thing that we do to

00:35:14,320 --> 00:35:18,560
change this code up

00:35:15,359 --> 00:35:18,560
to polish it up

00:35:18,960 --> 00:35:27,040
okay pretty good um

00:35:22,720 --> 00:35:29,440
now this value that we are passing in

00:35:27,040 --> 00:35:31,119
and we're passing along in our sort of

00:35:29,440 --> 00:35:32,240
putative recursive calls for the

00:35:31,119 --> 00:35:34,800
algorithm

00:35:32,240 --> 00:35:35,280
presumably most of the time it starts at

00:35:34,800 --> 00:35:37,200
zero

00:35:35,280 --> 00:35:38,960
like the common use case maybe for our

00:35:37,200 --> 00:35:40,160
algorithm here is going to be

00:35:38,960 --> 00:35:41,599
you want to find the gap and you're just

00:35:40,160 --> 00:35:43,119
going to assume that everything starts

00:35:41,599 --> 00:35:45,599
at zero

00:35:43,119 --> 00:35:46,480
so maybe we should add a default

00:35:45,599 --> 00:35:48,160
argument for

00:35:46,480 --> 00:35:49,680
for easier call sites just to ease the

00:35:48,160 --> 00:35:52,400
interface a little bit

00:35:49,680 --> 00:35:54,800
um the full construction here of you

00:35:52,400 --> 00:35:56,640
know value construction is going to be

00:35:54,800 --> 00:35:59,839
kind of analog to zero for whatever type

00:35:56,640 --> 00:35:59,839
we pass in presumably

00:36:00,320 --> 00:36:03,680
now you don't always want to provide

00:36:01,839 --> 00:36:05,680
default arguments and in general default

00:36:03,680 --> 00:36:07,359
arguments aren't really as good as

00:36:05,680 --> 00:36:08,880
function overloads we'll come to talk

00:36:07,359 --> 00:36:10,839
about that in a little while

00:36:08,880 --> 00:36:13,040
but i think at this point it's

00:36:10,839 --> 00:36:16,640
reasonable

00:36:13,040 --> 00:36:18,720
so we have a reasonable algorithm

00:36:16,640 --> 00:36:20,240
let's think about the preconditions and

00:36:18,720 --> 00:36:20,560
post conditions here and let's document

00:36:20,240 --> 00:36:24,079
them

00:36:20,560 --> 00:36:26,400
even if we don't have contracts yet so

00:36:24,079 --> 00:36:28,960
the preconditions are that our range

00:36:26,400 --> 00:36:31,119
doesn't conta there is actually a gap

00:36:28,960 --> 00:36:32,400
okay or there is in some sense the gap

00:36:31,119 --> 00:36:35,760
might be at the end

00:36:32,400 --> 00:36:37,839
but there is a gap in ts um

00:36:35,760 --> 00:36:39,200
a precondition which is actually i think

00:36:37,839 --> 00:36:41,599
still

00:36:39,200 --> 00:36:43,440
like really difficult to or maybe

00:36:41,599 --> 00:36:43,920
impossible to to say in the contracts

00:36:43,440 --> 00:36:47,599
even

00:36:43,920 --> 00:36:47,599
is that last is reachable from first

00:36:47,920 --> 00:36:51,680
it shouldn't contain duplicate values

00:36:53,200 --> 00:36:57,839
maybe value should not overflow if it's

00:36:55,280 --> 00:37:01,520
signed that that might be a precondition

00:36:57,839 --> 00:37:02,720
uh perhaps or just a a condition on the

00:37:01,520 --> 00:37:05,280
function

00:37:02,720 --> 00:37:06,240
uh often we would choose to deal with

00:37:05,280 --> 00:37:09,119
conditions like that

00:37:06,240 --> 00:37:10,240
being ub as just just that's a condition

00:37:09,119 --> 00:37:12,880
that the caller has to

00:37:10,240 --> 00:37:14,320
deal with right it's too onerous for us

00:37:12,880 --> 00:37:15,680
to deal with that sort of thing in an

00:37:14,320 --> 00:37:17,920
algorithm perhaps

00:37:15,680 --> 00:37:20,880
um and the post condition is that we've

00:37:17,920 --> 00:37:20,880
permuted the elements

00:37:21,280 --> 00:37:25,040
we also of course has to think about a

00:37:22,800 --> 00:37:27,119
better name

00:37:25,040 --> 00:37:28,560
now i'm in the position where i can't

00:37:27,119 --> 00:37:30,960
interact fully with you

00:37:28,560 --> 00:37:32,079
um but up till now we've been going

00:37:30,960 --> 00:37:34,079
along and i don't know if you've

00:37:32,079 --> 00:37:35,520
well i won't go back but it's been find

00:37:34,079 --> 00:37:37,119
missing element i just put that in there

00:37:35,520 --> 00:37:38,400
and none of you said anything about it

00:37:37,119 --> 00:37:41,359
because i can't hear you say anything

00:37:38,400 --> 00:37:45,359
but but nobody said anything about it

00:37:41,359 --> 00:37:48,079
um but let's think about the name um

00:37:45,359 --> 00:37:49,760
it's a bit verbose it's not completely

00:37:48,079 --> 00:37:52,079
descriptive because we actually we find

00:37:49,760 --> 00:37:55,359
the smallest missing element

00:37:52,079 --> 00:37:59,200
um when there isn't just one uh

00:37:55,359 --> 00:38:00,880
we also you know the find functions

00:37:59,200 --> 00:38:02,400
arthur pointed arthur dwyer pointed this

00:38:00,880 --> 00:38:03,680
out to me that the find functions in the

00:38:02,400 --> 00:38:05,599
standard library generally return

00:38:03,680 --> 00:38:08,400
iterators and we're returning

00:38:05,599 --> 00:38:09,839
a value not an iterator so maybe it's

00:38:08,400 --> 00:38:13,200
preferential to say

00:38:09,839 --> 00:38:13,920
rather than find x uh return that some

00:38:13,200 --> 00:38:16,400
kind of min

00:38:13,920 --> 00:38:18,000
because min returns a value although min

00:38:16,400 --> 00:38:20,480
element returns a

00:38:18,000 --> 00:38:21,839
an iterator so you know reasonable

00:38:20,480 --> 00:38:24,079
people can differ

00:38:21,839 --> 00:38:24,960
but i've had suggested um find first

00:38:24,079 --> 00:38:28,400
vacancy

00:38:24,960 --> 00:38:32,240
find a vacancy um i used to say min

00:38:28,400 --> 00:38:34,640
unused um i'm going with min absent

00:38:32,240 --> 00:38:35,280
for this cut of the talk um that's the

00:38:34,640 --> 00:38:38,320
one i

00:38:35,280 --> 00:38:39,440
like best at the moment

00:38:38,320 --> 00:38:42,880
so that's the one that's going to be on

00:38:39,440 --> 00:38:46,240
the slides so um

00:38:42,880 --> 00:38:47,839
this is our final version is it

00:38:46,240 --> 00:38:49,440
at this point we've talked a lot about

00:38:47,839 --> 00:38:50,800
how to mold the algorithm and how to

00:38:49,440 --> 00:38:52,079
make it generic without losing

00:38:50,800 --> 00:38:54,800
efficiency for the

00:38:52,079 --> 00:38:56,560
iterated categories and such but now we

00:38:54,800 --> 00:38:57,920
come to the actual important topic of

00:38:56,560 --> 00:38:59,119
really figuring out the type

00:38:57,920 --> 00:39:01,280
requirements

00:38:59,119 --> 00:39:03,599
and to do that we need to test with more

00:39:01,280 --> 00:39:07,599
types

00:39:03,599 --> 00:39:11,119
so i mentioned moving beyond integers

00:39:07,599 --> 00:39:12,560
i commonly want to find a gap in

00:39:11,119 --> 00:39:14,400
things that i've scheduled and to do

00:39:12,560 --> 00:39:17,440
that i might need to find

00:39:14,400 --> 00:39:19,359
a a chrono duration uh

00:39:17,440 --> 00:39:21,040
gap i'd really like to work for this

00:39:19,359 --> 00:39:24,160
case

00:39:21,040 --> 00:39:25,200
but what's the problem here the compiler

00:39:24,160 --> 00:39:28,160
says it can't

00:39:25,200 --> 00:39:28,960
it can't call next when i give it first

00:39:28,160 --> 00:39:30,560
and half so

00:39:28,960 --> 00:39:32,320
something wrong with i know first is an

00:39:30,560 --> 00:39:34,880
iterator and that's fine something is

00:39:32,320 --> 00:39:37,680
wrong with half

00:39:34,880 --> 00:39:39,440
it's not the right type why is it not

00:39:37,680 --> 00:39:41,359
the right type because

00:39:39,440 --> 00:39:42,560
what we've got a duration m is going to

00:39:41,359 --> 00:39:46,800
be a duration

00:39:42,560 --> 00:39:49,599
we know that values are duration half is

00:39:46,800 --> 00:39:50,560
assigned type half is a distance type so

00:39:49,599 --> 00:39:52,480
this is where like

00:39:50,560 --> 00:39:53,599
just we move beyond the ins considering

00:39:52,480 --> 00:39:55,599
just the ins kind of

00:39:53,599 --> 00:39:58,560
made us think a certain way and here's

00:39:55,599 --> 00:39:58,560
where we move beyond that

00:39:58,640 --> 00:40:02,000
what we need is to make that distance

00:40:00,720 --> 00:40:05,760
type into

00:40:02,000 --> 00:40:07,920
acronym duration so we need

00:40:05,760 --> 00:40:10,079
um whatever we pass in the t at this

00:40:07,920 --> 00:40:10,640
point it must be constructable from the

00:40:10,079 --> 00:40:12,960
integer

00:40:10,640 --> 00:40:14,000
integral type so we'll take the static

00:40:12,960 --> 00:40:17,520
cast off that

00:40:14,000 --> 00:40:18,880
call to heart off that half declaration

00:40:17,520 --> 00:40:22,319
and we'll move it on to the point we're

00:40:18,880 --> 00:40:22,319
actually making the t again

00:40:22,960 --> 00:40:26,319
and this is okay yeah this works with

00:40:24,880 --> 00:40:28,079
chrono durations now we're passing the

00:40:26,319 --> 00:40:29,680
right thing to next because half

00:40:28,079 --> 00:40:31,119
is now the distance type with next

00:40:29,680 --> 00:40:34,319
requires

00:40:31,119 --> 00:40:36,319
we're doing the minimum conversions

00:40:34,319 --> 00:40:38,400
uh but this kind of told us about a

00:40:36,319 --> 00:40:40,319
crucial requirement for our algorithm

00:40:38,400 --> 00:40:41,680
there is in some sense a correspondence

00:40:40,319 --> 00:40:44,800
between integers

00:40:41,680 --> 00:40:46,480
between the values we pass in and

00:40:44,800 --> 00:40:47,839
the integers doesn't mean say that the

00:40:46,480 --> 00:40:49,680
values are integers

00:40:47,839 --> 00:40:50,960
but there is a correspondence there but

00:40:49,680 --> 00:40:52,800
you know there is some sense

00:40:50,960 --> 00:40:54,079
there's a there's a mapping between the

00:40:52,800 --> 00:40:56,880
countable integers

00:40:54,079 --> 00:40:56,880
and our values

00:40:57,520 --> 00:41:03,680
well once we tried it with um durations

00:41:01,119 --> 00:41:04,560
i'd also like to try it with time points

00:41:03,680 --> 00:41:06,880
um

00:41:04,560 --> 00:41:08,319
so you know i might want to pass in the

00:41:06,880 --> 00:41:13,440
vector of time points

00:41:08,319 --> 00:41:16,240
and find and find the uh

00:41:13,440 --> 00:41:18,560
find the missing time point here and

00:41:16,240 --> 00:41:21,599
when i do this

00:41:18,560 --> 00:41:23,839
it says now oh no i can't static cast

00:41:21,599 --> 00:41:25,280
along to a time point i can cast a

00:41:23,839 --> 00:41:26,880
duration i know that but

00:41:25,280 --> 00:41:28,640
a time point is not constructable from

00:41:26,880 --> 00:41:31,599
just uh an

00:41:28,640 --> 00:41:32,800
integral type so clearly we didn't quite

00:41:31,599 --> 00:41:36,079
think

00:41:32,800 --> 00:41:39,760
enough about that um there is a question

00:41:36,079 --> 00:41:43,200
isn't ordering a precondition also

00:41:39,760 --> 00:41:45,200
uh that the types are orderable

00:41:43,200 --> 00:41:47,599
yes if that's what you mean to say of

00:41:45,200 --> 00:41:51,040
course they can be in any order but

00:41:47,599 --> 00:41:51,040
the fact is they must be orderable

00:41:51,599 --> 00:41:54,240
okay so it works with durations it

00:41:53,119 --> 00:41:56,240
doesn't yet work with time points why

00:41:54,240 --> 00:41:59,040
doesn't it work with time points

00:41:56,240 --> 00:42:01,040
well this brings us to the notion of a

00:41:59,040 --> 00:42:04,480
fine space types

00:42:01,040 --> 00:42:07,520
and um bjorn fowler and

00:42:04,480 --> 00:42:09,680
uh adi shavit have a great

00:42:07,520 --> 00:42:10,800
uh talk about this that you can look up

00:42:09,680 --> 00:42:13,599
at your leisure

00:42:10,800 --> 00:42:15,200
the idea is that sometimes we have for

00:42:13,599 --> 00:42:16,640
instance in the case of chrono a time

00:42:15,200 --> 00:42:18,400
point and a duration

00:42:16,640 --> 00:42:20,000
and these types although they're

00:42:18,400 --> 00:42:20,960
representationally the same they

00:42:20,000 --> 00:42:23,040
represent

00:42:20,960 --> 00:42:24,720
a point and a difference they're

00:42:23,040 --> 00:42:27,280
different types and together they form

00:42:24,720 --> 00:42:28,560
this a fine space

00:42:27,280 --> 00:42:31,359
and there are a couple examples in the

00:42:28,560 --> 00:42:34,160
standard and it's fairly common perhaps

00:42:31,359 --> 00:42:34,480
that the point type is unsigned while

00:42:34,160 --> 00:42:37,119
the

00:42:34,480 --> 00:42:38,720
distance type the vector type is signed

00:42:37,119 --> 00:42:41,520
um

00:42:38,720 --> 00:42:43,200
and so we need to think about the type

00:42:41,520 --> 00:42:45,760
of the difference

00:42:43,200 --> 00:42:47,760
is a separate type from the type of the

00:42:45,760 --> 00:42:52,079
value

00:42:47,760 --> 00:42:52,079
we need to account for this subtraction

00:42:52,240 --> 00:42:56,160
when you subtract two values you don't

00:42:54,319 --> 00:42:56,560
always get the same type that the value

00:42:56,160 --> 00:42:59,200
is

00:42:56,560 --> 00:43:00,880
you might get a difference type and so

00:42:59,200 --> 00:43:04,480
here we're using diff t

00:43:00,880 --> 00:43:07,040
to represent that and then

00:43:04,480 --> 00:43:07,839
similarly when we add a value when we

00:43:07,040 --> 00:43:10,480
add a point

00:43:07,839 --> 00:43:12,640
and a and a vector type and in the a

00:43:10,480 --> 00:43:15,359
fine space we had a point and vector

00:43:12,640 --> 00:43:16,480
we can do that to get a point right and

00:43:15,359 --> 00:43:17,839
that's what we're doing

00:43:16,480 --> 00:43:19,200
on that line where we static cast the

00:43:17,839 --> 00:43:21,839
half to dif t now which is the

00:43:19,200 --> 00:43:21,839
difference type

00:43:22,800 --> 00:43:26,560
so here's in some sense a more final

00:43:25,839 --> 00:43:28,800
version

00:43:26,560 --> 00:43:30,560
this is pretty good at this point of

00:43:28,800 --> 00:43:30,960
course you can go on you can iterate you

00:43:30,560 --> 00:43:32,640
can

00:43:30,960 --> 00:43:34,160
always add more you can make this

00:43:32,640 --> 00:43:36,720
adaptive some point that you

00:43:34,160 --> 00:43:38,400
you know i'm not going that far in this

00:43:36,720 --> 00:43:40,480
talk because i only have an hour

00:43:38,400 --> 00:43:42,560
but they're important further things you

00:43:40,480 --> 00:43:44,000
can do here

00:43:42,560 --> 00:43:46,560
but you know in terms of making this

00:43:44,000 --> 00:43:48,960
generic a lot of the things that we've

00:43:46,560 --> 00:43:52,720
had to think about go into any algorithm

00:43:48,960 --> 00:43:55,440
and making it generic so

00:43:52,720 --> 00:43:56,640
what we need to do now is document our

00:43:55,440 --> 00:43:58,400
behavior

00:43:56,640 --> 00:44:00,480
in particular we should document the

00:43:58,400 --> 00:44:02,400
type requirements that we've discovered

00:44:00,480 --> 00:44:04,319
uh we should document the return value

00:44:02,400 --> 00:44:06,720
of course we should document the

00:44:04,319 --> 00:44:08,319
complexity guarantees and how they vary

00:44:06,720 --> 00:44:10,560
by iterator category

00:44:08,319 --> 00:44:12,960
how many swaps we're doing how many

00:44:10,560 --> 00:44:15,760
copies constructions conversions that

00:44:12,960 --> 00:44:17,280
kind of thing how many comparisons

00:44:15,760 --> 00:44:20,480
for all of the standard algorithms you

00:44:17,280 --> 00:44:20,480
find this information on

00:44:20,839 --> 00:44:25,440
cppreference.com

00:44:22,000 --> 00:44:26,079
and lastly uh or at least lastly in this

00:44:25,440 --> 00:44:27,359
list

00:44:26,079 --> 00:44:29,119
the exception behavior might be an

00:44:27,359 --> 00:44:31,920
important thing to

00:44:29,119 --> 00:44:31,920
to document

00:44:32,400 --> 00:44:36,319
so at this point someone usually asks a

00:44:34,400 --> 00:44:39,200
question because they've seen

00:44:36,319 --> 00:44:40,800
this and this strikes them as an old

00:44:39,200 --> 00:44:43,599
style algorithm you know it's using

00:44:40,800 --> 00:44:45,680
iterated pairs why isn't it using ranges

00:44:43,599 --> 00:44:47,359
um here's where we get to talking about

00:44:45,680 --> 00:44:48,880
that so

00:44:47,359 --> 00:44:50,960
ranges are great and important an

00:44:48,880 --> 00:44:52,880
important part of cpr plus 20.

00:44:50,960 --> 00:44:54,480
they don't give us many extra algorithms

00:44:52,880 --> 00:44:56,640
yet and they to me they don't

00:44:54,480 --> 00:44:59,680
fundamentally change

00:44:56,640 --> 00:45:03,119
the process of making algorithms

00:44:59,680 --> 00:45:04,640
what they give us is laziness great

00:45:03,119 --> 00:45:05,920
and they give actually give us a whole

00:45:04,640 --> 00:45:07,760
lot of because they move a lot of

00:45:05,920 --> 00:45:09,520
algorithms into range views

00:45:07,760 --> 00:45:11,119
they sort of give us algorithms in the

00:45:09,520 --> 00:45:12,880
iterators

00:45:11,119 --> 00:45:14,560
so and and that's what people mean

00:45:12,880 --> 00:45:15,839
really when they say they're composable

00:45:14,560 --> 00:45:18,240
they mean these algorithms in the

00:45:15,839 --> 00:45:20,960
iterators they don't like

00:45:18,240 --> 00:45:21,839
it's not any different for stable sort

00:45:20,960 --> 00:45:25,440
and and

00:45:21,839 --> 00:45:26,960
algorithms which we still have to um

00:45:25,440 --> 00:45:29,040
you know we still have to actually move

00:45:26,960 --> 00:45:30,160
things around and and we're not able to

00:45:29,040 --> 00:45:31,599
put them in views

00:45:30,160 --> 00:45:33,440
the real composability comes in the

00:45:31,599 --> 00:45:35,119
views um

00:45:33,440 --> 00:45:37,040
and and we get all of these things

00:45:35,119 --> 00:45:39,599
embedded in

00:45:37,040 --> 00:45:41,119
range views we get projection functions

00:45:39,599 --> 00:45:42,720
everywhere it's like we get a unary

00:45:41,119 --> 00:45:45,920
transform everywhere

00:45:42,720 --> 00:45:47,359
we get things like reverse copy find

00:45:45,920 --> 00:45:50,319
remove

00:45:47,359 --> 00:45:51,599
um all your basic algorithms and we get

00:45:50,319 --> 00:45:53,760
all the iterator runes

00:45:51,599 --> 00:45:56,160
as jonathan bakara called them in his

00:45:53,760 --> 00:45:58,400
105 algorithms talk

00:45:56,160 --> 00:46:00,240
uh sort of baked into and composable in

00:45:58,400 --> 00:46:03,760
the iterators so if you want a

00:46:00,240 --> 00:46:05,760
counted reverse move sliding iterator

00:46:03,760 --> 00:46:07,200
you can have one in in at least

00:46:05,760 --> 00:46:09,680
eventually in standard

00:46:07,200 --> 00:46:09,680
ranges

00:46:10,319 --> 00:46:13,520
so that's a smaller side about ranges

00:46:12,240 --> 00:46:16,319
they they're great

00:46:13,520 --> 00:46:20,319
but they don't fundamentally change the

00:46:16,319 --> 00:46:20,319
concerns of writing an algorithm for me

00:46:20,560 --> 00:46:24,640
um something else you might want to do

00:46:22,000 --> 00:46:28,160
with our algorithm is to uh

00:46:24,640 --> 00:46:30,640
provide overloads we saw that uh

00:46:28,160 --> 00:46:31,920
we saw that we we gave it a default

00:46:30,640 --> 00:46:33,520
argument

00:46:31,920 --> 00:46:35,040
um we might want to provide a

00:46:33,520 --> 00:46:36,400
range-based algorithm

00:46:35,040 --> 00:46:38,720
we might want to change the predicate on

00:46:36,400 --> 00:46:41,280
our algorithm for this algorithm

00:46:38,720 --> 00:46:42,800
uh i think you could like run it either

00:46:41,280 --> 00:46:44,640
way around from min or max

00:46:42,800 --> 00:46:47,200
but i don't think a generalized

00:46:44,640 --> 00:46:50,240
predicate would have to tie in with

00:46:47,200 --> 00:46:52,400
um with how we how we define uh where

00:46:50,240 --> 00:46:56,000
the things are so with the order ability

00:46:52,400 --> 00:46:59,839
so i'm not sure yet how to make that

00:46:56,000 --> 00:46:59,839
work in general terms for this algorithm

00:47:00,400 --> 00:47:04,079
now when i first gave this talk i gave

00:47:02,560 --> 00:47:05,680
it in this in this style and then

00:47:04,079 --> 00:47:07,119
and then i realized that i mean absent

00:47:05,680 --> 00:47:08,480
we've implemented with partition but we

00:47:07,119 --> 00:47:09,760
can also implement it with min element

00:47:08,480 --> 00:47:11,280
so instead of

00:47:09,760 --> 00:47:12,800
instead of partitioning a thing around

00:47:11,280 --> 00:47:14,079
the value and then finding out where

00:47:12,800 --> 00:47:16,800
that is

00:47:14,079 --> 00:47:17,599
flip it on this head and say let's pin

00:47:16,800 --> 00:47:19,040
where that is

00:47:17,599 --> 00:47:21,760
and find out the value that's what end

00:47:19,040 --> 00:47:24,000
element does rather than partition

00:47:21,760 --> 00:47:24,800
and so i coded this up and i put it on

00:47:24,000 --> 00:47:28,079
quickbench

00:47:24,800 --> 00:47:31,839
and it was about 25 30

00:47:28,079 --> 00:47:33,280
slower but it was useful to look at

00:47:31,839 --> 00:47:35,200
right and here it is with envelopment

00:47:33,280 --> 00:47:38,800
it's basically the same

00:47:35,200 --> 00:47:41,680
um the useful line here is where we say

00:47:38,800 --> 00:47:43,440
inside that if init is star mid plus

00:47:41,680 --> 00:47:46,559
statically's difficulty of one

00:47:43,440 --> 00:47:51,119
right that tells me something about

00:47:46,559 --> 00:47:52,640
about t's or about dfts um

00:47:51,119 --> 00:47:53,520
it sort of elucidates the requirement on

00:47:52,640 --> 00:47:54,880
the input you have to be able to

00:47:53,520 --> 00:47:56,319
construct it from a one

00:47:54,880 --> 00:47:58,160
right what i said about there being a

00:47:56,319 --> 00:48:00,720
correspondence between integers

00:47:58,160 --> 00:48:01,520
and values that's called out right there

00:48:00,720 --> 00:48:03,359
in the code

00:48:01,520 --> 00:48:04,880
so these different formulations can tell

00:48:03,359 --> 00:48:07,839
you things about

00:48:04,880 --> 00:48:07,839
the algorithms

00:48:08,559 --> 00:48:13,839
uh there is a question i think

00:48:11,760 --> 00:48:15,599
i can't answer it now because i need to

00:48:13,839 --> 00:48:18,559
push on but i will answer your question

00:48:15,599 --> 00:48:18,559
at the end victor thank you

00:48:19,040 --> 00:48:22,240
so now we are done with that case study

00:48:21,839 --> 00:48:25,599
uh

00:48:22,240 --> 00:48:28,880
now i want to talk as an epilogue about

00:48:25,599 --> 00:48:29,920
um the generalities of building

00:48:28,880 --> 00:48:33,280
algorithms

00:48:29,920 --> 00:48:34,480
um let's talk about arguments first so

00:48:33,280 --> 00:48:36,640
there's an important question what order

00:48:34,480 --> 00:48:38,559
should we use for the parameters

00:48:36,640 --> 00:48:40,480
um and this actually determines a lot of

00:48:38,559 --> 00:48:44,160
things about functions including

00:48:40,480 --> 00:48:45,599
sometimes their names so option one is

00:48:44,160 --> 00:48:47,200
do as the standard does and you're never

00:48:45,599 --> 00:48:49,440
really going to get in trouble for this

00:48:47,200 --> 00:48:51,040
so in general where we have an execution

00:48:49,440 --> 00:48:53,280
policy it would come first

00:48:51,040 --> 00:48:55,040
then we take our input iterator pair or

00:48:53,280 --> 00:48:58,000
iterate the count

00:48:55,040 --> 00:49:00,000
um then we do any other input iterators

00:48:58,000 --> 00:49:02,000
then some output iterators

00:49:00,000 --> 00:49:03,760
then any initialization value for

00:49:02,000 --> 00:49:05,520
instance would accumulate or with our

00:49:03,760 --> 00:49:08,079
with our algorithm here

00:49:05,520 --> 00:49:08,640
um then some kind of predicate and

00:49:08,079 --> 00:49:10,160
finally

00:49:08,640 --> 00:49:12,559
maybe a projection or transformation

00:49:10,160 --> 00:49:12,559
function

00:49:12,800 --> 00:49:15,920
um and there are examples in the

00:49:14,240 --> 00:49:17,359
standard um

00:49:15,920 --> 00:49:19,040
that have all of these and if you look

00:49:17,359 --> 00:49:20,960
at the most of the most of the

00:49:19,040 --> 00:49:23,520
algorithms do follow this

00:49:20,960 --> 00:49:25,200
uh the transform reduce style algorithms

00:49:23,520 --> 00:49:28,000
annoyingly take the reduction operation

00:49:25,200 --> 00:49:30,000
before the transform operation but

00:49:28,000 --> 00:49:31,599
um but most algorithms understand the

00:49:30,000 --> 00:49:35,200
follow this pattern

00:49:31,599 --> 00:49:36,720
another option is order the arguments

00:49:35,200 --> 00:49:38,319
according to the partial application you

00:49:36,720 --> 00:49:40,480
wish to see in the world

00:49:38,319 --> 00:49:42,000
so this can mean putting arguments that

00:49:40,480 --> 00:49:45,440
um

00:49:42,000 --> 00:49:47,040
that vary frequently at the end

00:49:45,440 --> 00:49:48,960
so that you can bind front the first

00:49:47,040 --> 00:49:50,480
ones um

00:49:48,960 --> 00:49:52,559
although to flip it on his head it could

00:49:50,480 --> 00:49:55,040
mean putting arguments that changed

00:49:52,559 --> 00:49:55,839
uh least at the end because you can

00:49:55,040 --> 00:49:58,960
default them

00:49:55,839 --> 00:50:00,240
maybe there are choices sometimes you

00:49:58,960 --> 00:50:01,119
get the audio imposed on you by the

00:50:00,240 --> 00:50:03,680
language because

00:50:01,119 --> 00:50:04,800
if you're using defaults either in the

00:50:03,680 --> 00:50:07,920
template types

00:50:04,800 --> 00:50:11,200
or in the template arguments or in the

00:50:07,920 --> 00:50:14,400
runtime parameters you have to do

00:50:11,200 --> 00:50:14,400
certain things to default them

00:50:14,559 --> 00:50:17,599
um there aren't any variety algorithms

00:50:16,559 --> 00:50:18,960
yet but

00:50:17,599 --> 00:50:22,240
you know we can imagine what their

00:50:18,960 --> 00:50:23,839
function signatures might look like

00:50:22,240 --> 00:50:25,440
so i said it informs naming this is

00:50:23,839 --> 00:50:26,000
especially true with binary functions i

00:50:25,440 --> 00:50:27,760
find because

00:50:26,000 --> 00:50:30,400
i like to imagine binary functions as

00:50:27,760 --> 00:50:32,400
being infix

00:50:30,400 --> 00:50:33,920
so if you put the arguments the first

00:50:32,400 --> 00:50:35,040
way around here

00:50:33,920 --> 00:50:36,880
the right name for the function is

00:50:35,040 --> 00:50:37,920
starts with because the string s starts

00:50:36,880 --> 00:50:39,359
with the prefix

00:50:37,920 --> 00:50:41,200
but if you flip them around and you

00:50:39,359 --> 00:50:42,400
might have good reasons for doing that

00:50:41,200 --> 00:50:44,640
then the name of the function would

00:50:42,400 --> 00:50:46,720
become to me is prefix of

00:50:44,640 --> 00:50:48,400
because if it were infix we'd be saying

00:50:46,720 --> 00:50:50,720
prefix is prefix of

00:50:48,400 --> 00:50:50,720
yes

00:50:52,160 --> 00:50:56,880
so there is uh there are four

00:50:55,440 --> 00:50:59,520
algorithmic principles

00:50:56,880 --> 00:51:01,200
listed in in the work of alex stepanov

00:50:59,520 --> 00:51:02,480
and i just like to highlight them by way

00:51:01,200 --> 00:51:04,559
of epilogue

00:51:02,480 --> 00:51:05,760
the first one is the law of useful

00:51:04,559 --> 00:51:08,240
return

00:51:05,760 --> 00:51:09,599
and that is that when you're inside your

00:51:08,240 --> 00:51:11,440
algorithm if you're computing something

00:51:09,599 --> 00:51:14,160
which is useful to the caller

00:51:11,440 --> 00:51:14,960
return it right it might not be the

00:51:14,160 --> 00:51:18,319
thing that

00:51:14,960 --> 00:51:20,319
you are computing sort of as the name of

00:51:18,319 --> 00:51:21,760
your function as your primary job

00:51:20,319 --> 00:51:24,640
but if it's going to be useful if it's

00:51:21,760 --> 00:51:26,720
going to be difficult for the caller

00:51:24,640 --> 00:51:28,319
maybe the caller can't actually compute

00:51:26,720 --> 00:51:30,720
it themselves or maybe

00:51:28,319 --> 00:51:32,480
it's going to be difficult for them to

00:51:30,720 --> 00:51:34,160
compute it or takes extra time

00:51:32,480 --> 00:51:36,400
you should return it all of the

00:51:34,160 --> 00:51:39,599
potentially useful information

00:51:36,400 --> 00:51:43,599
a good example of this is rotate

00:51:39,599 --> 00:51:46,720
in cpr plus 98 return void in c plus 11

00:51:43,599 --> 00:51:49,599
it returns the iterator where

00:51:46,720 --> 00:51:51,200
the first ended up and this is so so

00:51:49,599 --> 00:51:52,000
useful you know this is a potentially

00:51:51,200 --> 00:51:54,160
useful thing

00:51:52,000 --> 00:51:56,000
a very useful thing it computed it

00:51:54,160 --> 00:51:57,680
returns it now and because of that it's

00:51:56,000 --> 00:52:00,960
much more useful as a building block

00:51:57,680 --> 00:52:03,280
algorithm unfortunately there are some

00:52:00,960 --> 00:52:05,599
areas where the standard is deficient

00:52:03,280 --> 00:52:07,119
copy n and in general n algorithms they

00:52:05,599 --> 00:52:09,359
need extra special care

00:52:07,119 --> 00:52:11,280
with the law of useful return because

00:52:09,359 --> 00:52:11,680
copy n returns an output iterator but

00:52:11,280 --> 00:52:14,800
you're

00:52:11,680 --> 00:52:18,319
passing it an input iterator

00:52:14,800 --> 00:52:20,000
so where does that input iterator end up

00:52:18,319 --> 00:52:21,359
it doesn't return it you have no way to

00:52:20,000 --> 00:52:22,400
recover it if it's truly an input

00:52:21,359 --> 00:52:24,880
iterator

00:52:22,400 --> 00:52:26,720
this is kind of unfortunate the good

00:52:24,880 --> 00:52:32,880
news is this is fixed

00:52:26,720 --> 00:52:35,359
with ranges which returns both iterators

00:52:32,880 --> 00:52:37,200
and this is yeah take care with iterate

00:52:35,359 --> 00:52:39,200
account versions of algorithms

00:52:37,200 --> 00:52:40,880
so return all the potentially useful

00:52:39,200 --> 00:52:43,839
information you compute

00:52:40,880 --> 00:52:44,800
doesn't mean do extra work does mean pay

00:52:43,839 --> 00:52:46,400
attention to

00:52:44,800 --> 00:52:47,599
in particular the non-ranked random

00:52:46,400 --> 00:52:48,800
access iterators which are going to

00:52:47,599 --> 00:52:50,240
require linear time

00:52:48,800 --> 00:52:52,559
for the caller to recover where you got

00:52:50,240 --> 00:52:54,800
to and just be on the lookout for free

00:52:52,559 --> 00:52:56,800
stuff

00:52:54,800 --> 00:52:58,559
the second law is separating types and

00:52:56,800 --> 00:53:00,559
this is where it can actually help to

00:52:58,559 --> 00:53:02,319
physically print the code and take a

00:53:00,559 --> 00:53:04,640
highlighter to it

00:53:02,319 --> 00:53:06,720
and then discover which variables

00:53:04,640 --> 00:53:09,359
interact with other variables

00:53:06,720 --> 00:53:10,800
um and what operations they use and and

00:53:09,359 --> 00:53:13,440
we we saw some of this

00:53:10,800 --> 00:53:14,160
when we did um you know when we when we

00:53:13,440 --> 00:53:15,839
looked at

00:53:14,160 --> 00:53:17,520
separating the types separating the a

00:53:15,839 --> 00:53:21,280
fine space type don't

00:53:17,520 --> 00:53:22,400
assume that one type is the same as

00:53:21,280 --> 00:53:22,960
another type when they're different

00:53:22,400 --> 00:53:25,200
variables

00:53:22,960 --> 00:53:26,079
try varying them and see where you go

00:53:25,200 --> 00:53:29,119
and

00:53:26,079 --> 00:53:32,559
there's a famous sort of uh

00:53:29,119 --> 00:53:34,160
example of this or or sort of uh

00:53:32,559 --> 00:53:35,920
so this lecture part five past one and

00:53:34,160 --> 00:53:36,800
two is the extended version of sean

00:53:35,920 --> 00:53:39,839
parent's famous

00:53:36,800 --> 00:53:42,559
uh lecture from going native 2013

00:53:39,839 --> 00:53:44,000
from whence we get no raw loops uh he

00:53:42,559 --> 00:53:46,800
describes

00:53:44,000 --> 00:53:47,680
where by looking at stable partition he

00:53:46,800 --> 00:53:50,960
discovered

00:53:47,680 --> 00:53:53,280
that it only moves the element after

00:53:50,960 --> 00:53:54,559
testing it with the predicate and

00:53:53,280 --> 00:53:56,880
therefore that means that the

00:53:54,559 --> 00:53:58,480
the the predicate information can be

00:53:56,880 --> 00:53:58,880
kept an entirely separate data structure

00:53:58,480 --> 00:54:01,839
you could

00:53:58,880 --> 00:54:03,760
you can store your your selection

00:54:01,839 --> 00:54:06,160
information i think it was in his case

00:54:03,760 --> 00:54:06,800
um separately from what's actually being

00:54:06,160 --> 00:54:08,240
selected

00:54:06,800 --> 00:54:09,760
because this stuff gets moved around and

00:54:08,240 --> 00:54:10,000
the selection information is just used

00:54:09,760 --> 00:54:12,160
in

00:54:10,000 --> 00:54:14,160
testing the predicate before it gets

00:54:12,160 --> 00:54:17,599
moved so it's gonna

00:54:14,160 --> 00:54:17,599
you know give you that freedom

00:54:18,160 --> 00:54:22,400
so don't assume two types are the same

00:54:19,760 --> 00:54:24,960
when they may be different

00:54:22,400 --> 00:54:26,640
the third is the law of completeness and

00:54:24,960 --> 00:54:28,559
this is the one where we get to say well

00:54:26,640 --> 00:54:30,960
let's provide the range operation

00:54:28,559 --> 00:54:32,319
and let's provide the user predicate and

00:54:30,960 --> 00:54:34,800
let's deal with all of the different

00:54:32,319 --> 00:54:36,720
stringish types that we have

00:54:34,800 --> 00:54:38,880
and we've seen this this sort of design

00:54:36,720 --> 00:54:41,520
space exploration often comes out of the

00:54:38,880 --> 00:54:43,119
separating types that we do

00:54:41,520 --> 00:54:45,680
this is another case where the standard

00:54:43,119 --> 00:54:48,640
does fairly poorly

00:54:45,680 --> 00:54:50,160
um it doesn't have very many underscore

00:54:48,640 --> 00:54:53,280
n variants

00:54:50,160 --> 00:54:54,720
um but you know that i've had use for

00:54:53,280 --> 00:54:56,480
things like accumulate and which are

00:54:54,720 --> 00:54:58,799
fairly easy to code up

00:54:56,480 --> 00:55:00,000
you know in this style um but the

00:54:58,799 --> 00:55:01,359
standard isn't isn't there

00:55:00,000 --> 00:55:03,280
on many of this stuff with ranges we

00:55:01,359 --> 00:55:07,119
will get all of those

00:55:03,280 --> 00:55:08,400
iterators perhaps so it might get better

00:55:07,119 --> 00:55:10,000
here's another example from the standard

00:55:08,400 --> 00:55:11,440
set symmetric difference could really do

00:55:10,000 --> 00:55:12,559
with another output iterate or even

00:55:11,440 --> 00:55:14,079
another two

00:55:12,559 --> 00:55:15,760
because commonly what i would use set

00:55:14,079 --> 00:55:17,520
symmetric difference for would be

00:55:15,760 --> 00:55:19,119
i've got a before set i've got an after

00:55:17,520 --> 00:55:21,200
set i want to know

00:55:19,119 --> 00:55:23,920
what got deleted what got added and what

00:55:21,200 --> 00:55:23,920
stayed the same

00:55:24,319 --> 00:55:29,119
um and so you know the only algorithm

00:55:27,520 --> 00:55:30,799
that has more than one output iterator

00:55:29,119 --> 00:55:31,440
in the standard right now is partition

00:55:30,799 --> 00:55:33,040
copy

00:55:31,440 --> 00:55:37,680
but set symmetric difference could well

00:55:33,040 --> 00:55:39,440
do with a couple more variations

00:55:37,680 --> 00:55:40,880
transform exclusive scan is another

00:55:39,440 --> 00:55:42,960
example where

00:55:40,880 --> 00:55:44,400
for some reason transform exclusive scan

00:55:42,960 --> 00:55:46,000
or inclusive scan

00:55:44,400 --> 00:55:47,680
they don't have the binary range

00:55:46,000 --> 00:55:48,400
versions they only have the unreal range

00:55:47,680 --> 00:55:49,760
versions

00:55:48,400 --> 00:55:51,440
despite the fact that transform and

00:55:49,760 --> 00:55:55,119
transform reduce both have the binary

00:55:51,440 --> 00:55:57,599
versions so try to provide all the

00:55:55,119 --> 00:56:00,079
complete things

00:55:57,599 --> 00:56:01,040
the final law and the the most difficult

00:56:00,079 --> 00:56:02,960
one really

00:56:01,040 --> 00:56:05,200
is the law of interface refinement which

00:56:02,960 --> 00:56:06,880
is to say

00:56:05,200 --> 00:56:08,319
we don't really know what the right

00:56:06,880 --> 00:56:11,599
formulation of interface is

00:56:08,319 --> 00:56:14,240
until we've had experience sometimes

00:56:11,599 --> 00:56:15,280
extensive experience meaning maybe a

00:56:14,240 --> 00:56:18,400
decade

00:56:15,280 --> 00:56:20,000
of use literally something

00:56:18,400 --> 00:56:22,319
takes years to refine and the famous

00:56:20,000 --> 00:56:25,680
example of this in the standard is max

00:56:22,319 --> 00:56:27,280
right so when min uh

00:56:25,680 --> 00:56:29,520
when the two elements are equal min

00:56:27,280 --> 00:56:32,559
returns the first element

00:56:29,520 --> 00:56:34,240
and so does max and

00:56:32,559 --> 00:56:35,680
you know that's an arbitrary choice that

00:56:34,240 --> 00:56:36,319
alex stepnoff had to make back in the

00:56:35,680 --> 00:56:38,160
day

00:56:36,319 --> 00:56:40,480
and with hindsight with a decade and

00:56:38,160 --> 00:56:42,799
more of hindsight it's become clear that

00:56:40,480 --> 00:56:44,160
this wasn't the best choice because it

00:56:42,799 --> 00:56:46,079
doesn't become clear

00:56:44,160 --> 00:56:48,720
until we start using min and max

00:56:46,079 --> 00:56:51,599
actually to build up algorithms

00:56:48,720 --> 00:56:53,440
like stable sort and to take to think

00:56:51,599 --> 00:56:56,640
about things like stability

00:56:53,440 --> 00:56:57,920
of comparisons the better choice of max

00:56:56,640 --> 00:56:59,520
would have been to return the second one

00:56:57,920 --> 00:57:02,000
in the case when they're equal

00:56:59,520 --> 00:57:02,559
and this kind of thing doesn't doesn't

00:57:02,000 --> 00:57:05,040
come up

00:57:02,559 --> 00:57:06,400
uh you know from the get-go you actually

00:57:05,040 --> 00:57:08,880
need experience and this is a really

00:57:06,400 --> 00:57:08,880
hard thing

00:57:08,960 --> 00:57:12,319
um rotate is another example of that

00:57:11,119 --> 00:57:15,040
right we saw it in

00:57:12,319 --> 00:57:15,839
the useful return it's another example

00:57:15,040 --> 00:57:19,040
of refinement

00:57:15,839 --> 00:57:19,040
coming years later

00:57:19,680 --> 00:57:23,680
so the four algorithmic principles

00:57:22,160 --> 00:57:26,480
useful return

00:57:23,680 --> 00:57:27,920
separate your types offer completeness

00:57:26,480 --> 00:57:30,079
to the callers

00:57:27,920 --> 00:57:31,359
and do what you can to refine the

00:57:30,079 --> 00:57:34,319
interface again

00:57:31,359 --> 00:57:36,000
it requires time but you're not done

00:57:34,319 --> 00:57:36,799
after you release the first version i

00:57:36,000 --> 00:57:40,799
think is

00:57:36,799 --> 00:57:43,280
is what we can say about that

00:57:40,799 --> 00:57:44,960
so we started out why would we do this

00:57:43,280 --> 00:57:46,559
again we started out with necessity you

00:57:44,960 --> 00:57:48,799
know the standard set of algorithms

00:57:46,559 --> 00:57:49,599
isn't complete uh it was never designed

00:57:48,799 --> 00:57:52,000
to be complete

00:57:49,599 --> 00:57:53,839
it was you know it was designed to be a

00:57:52,000 --> 00:57:55,359
model for building our own algorithms in

00:57:53,839 --> 00:57:58,640
a generic way

00:57:55,359 --> 00:58:02,000
and we have this advice no raw loops so

00:57:58,640 --> 00:58:03,520
what we learned along the way is that

00:58:02,000 --> 00:58:05,440
actually examining the algorithms and

00:58:03,520 --> 00:58:08,480
building them gives us insights

00:58:05,440 --> 00:58:11,520
into the nature of the problem uh

00:58:08,480 --> 00:58:12,480
it allows us to generalize maybe to

00:58:11,520 --> 00:58:14,319
specialize

00:58:12,480 --> 00:58:16,079
and this is what algorithmic intuition

00:58:14,319 --> 00:58:18,000
is it's seeing how one problem is like

00:58:16,079 --> 00:58:19,839
another and to do that a great thing to

00:58:18,000 --> 00:58:21,119
do is to try and build the algorithms to

00:58:19,839 --> 00:58:23,839
solve the problem and see how they can

00:58:21,119 --> 00:58:23,839
vary

00:58:24,319 --> 00:58:28,000
it shows us the constraints on our data

00:58:26,799 --> 00:58:30,079
how it really interacts

00:58:28,000 --> 00:58:31,920
it can allow us to reformulate things

00:58:30,079 --> 00:58:34,880
and it can allow us to identify

00:58:31,920 --> 00:58:36,000
efficiencies in the end all of

00:58:34,880 --> 00:58:37,920
programming

00:58:36,000 --> 00:58:39,040
is applying algorithms to data

00:58:37,920 --> 00:58:40,559
structures

00:58:39,040 --> 00:58:42,559
until you get a data structure you can

00:58:40,559 --> 00:58:43,839
print out or display to a human in some

00:58:42,559 --> 00:58:46,160
way

00:58:43,839 --> 00:58:47,920
um algorithms plus data structures

00:58:46,160 --> 00:58:51,839
equals programs

00:58:47,920 --> 00:58:51,839
as nicolas viet i think once said

00:58:52,880 --> 00:58:58,160
so um again what to expect from ranges

00:58:56,640 --> 00:59:00,160
is that it's going to expand

00:58:58,160 --> 00:59:02,079
that completeness section it's going to

00:59:00,160 --> 00:59:03,119
expand the variations that we can easily

00:59:02,079 --> 00:59:06,079
use

00:59:03,119 --> 00:59:07,839
but that's not a reason not to write to

00:59:06,079 --> 00:59:12,160
continue writing variations

00:59:07,839 --> 00:59:14,480
and continue exploring new algorithms so

00:59:12,160 --> 00:59:16,160
i'd like to wish you happy coding i'd

00:59:14,480 --> 00:59:18,400
like to

00:59:16,160 --> 00:59:20,400
tell you to to study the algorithms and

00:59:18,400 --> 00:59:22,960
write your own and have fun with it

00:59:20,400 --> 00:59:26,000
um thank you very much and i will um

00:59:22,960 --> 00:59:26,000
answer a few questions

00:59:26,400 --> 00:59:30,079
so the question why is it bad that max

00:59:28,160 --> 00:59:33,280
returns the first argument

00:59:30,079 --> 00:59:35,200
so this has to do with um what happens

00:59:33,280 --> 00:59:36,960
when you use min and max to build higher

00:59:35,200 --> 00:59:38,720
order algorithms and you can see the

00:59:36,960 --> 00:59:41,440
stability of sorting

00:59:38,720 --> 00:59:43,520
um i think it's stability in particular

00:59:41,440 --> 00:59:47,680
um

00:59:43,520 --> 00:59:49,920
min if you're comparing x and y

00:59:47,680 --> 00:59:52,079
min should return in some mostly the

00:59:49,920 --> 00:59:53,760
thing on the left if they're equal

00:59:52,079 --> 00:59:56,000
and max should return the thing on the

00:59:53,760 --> 00:59:56,559
right when they're equal in order to be

00:59:56,000 --> 00:59:58,400
stable

00:59:56,559 --> 01:00:00,319
and it's and and it's that kind of thing

00:59:58,400 --> 01:00:02,480
that there's really not obvious

01:00:00,319 --> 01:00:04,240
when you first write minimax like i say

01:00:02,480 --> 01:00:07,359
you just make an arbitrary choice

01:00:04,240 --> 01:00:10,480
it only becomes apparent years later

01:00:07,359 --> 01:00:10,480
that there was a better choice

01:00:10,720 --> 01:00:16,559
um i will absolutely make the slides

01:00:12,400 --> 01:00:16,559
available to the person asking that yes

01:00:16,720 --> 01:00:20,640
someone asks is it justifiable to use a

01:00:18,720 --> 01:00:23,440
raw loop instead of an algorithm if the

01:00:20,640 --> 01:00:27,440
raw loop is clearer

01:00:23,440 --> 01:00:31,599
okay the definition of a raw loop

01:00:27,440 --> 01:00:34,799
is a loop that does more than just

01:00:31,599 --> 01:00:37,839
its job so by definition

01:00:34,799 --> 01:00:39,920
a rule loop is never clearer because it

01:00:37,839 --> 01:00:43,760
does more than one thing

01:00:39,920 --> 01:00:46,640
um in addition raw loops tend to

01:00:43,760 --> 01:00:48,960
accumulate craft over time they don't

01:00:46,640 --> 01:00:54,480
have names

01:00:48,960 --> 01:00:54,480
and um they are frequently

01:00:54,799 --> 01:00:58,720
there is frequently not an efficiency

01:00:56,400 --> 01:01:01,520
argument to be made for raw loops either

01:00:58,720 --> 01:01:03,280
so i would nearly always prefer a well

01:01:01,520 --> 01:01:10,079
named function

01:01:03,280 --> 01:01:12,960
that is going to do one job

01:01:10,079 --> 01:01:14,319
one more leftover question um can i talk

01:01:12,960 --> 01:01:17,440
about the requirements on

01:01:14,319 --> 01:01:18,960
t regular is it regular

01:01:17,440 --> 01:01:20,960
are there operations required on t do

01:01:18,960 --> 01:01:22,960
they need to form a monoid i think in

01:01:20,960 --> 01:01:25,839
this case

01:01:22,960 --> 01:01:26,240
um there is no monoidal requirement from

01:01:25,839 --> 01:01:29,520
the

01:01:26,240 --> 01:01:31,119
from the min absent algorithm i think um

01:01:29,520 --> 01:01:33,280
there certainly are monoids to be found

01:01:31,119 --> 01:01:36,960
in there i expect

01:01:33,280 --> 01:01:38,400
um and

01:01:36,960 --> 01:01:40,160
some of the requirements we talked about

01:01:38,400 --> 01:01:43,599
t needs to be constructable from

01:01:40,160 --> 01:01:46,240
from an integral type um

01:01:43,599 --> 01:01:47,520
there are probably some there are no

01:01:46,240 --> 01:01:49,359
swaps in there but

01:01:47,520 --> 01:01:52,079
yes we could look at that algorithm and

01:01:49,359 --> 01:01:55,200
see how t is constructed how it's

01:01:52,079 --> 01:01:58,480
copied movability is usually

01:01:55,200 --> 01:02:02,160
usually um required um

01:01:58,480 --> 01:02:04,079
yeah regular is good um

01:02:02,160 --> 01:02:05,359
sometimes semi-regular which is to say

01:02:04,079 --> 01:02:08,559
regular um

01:02:05,359 --> 01:02:11,520
up to but not including the the ordering

01:02:08,559 --> 01:02:12,079
constraint so equality is is needed but

01:02:11,520 --> 01:02:16,960
but

01:02:12,079 --> 01:02:16,960
ordering is not uh that's fairly common

01:02:17,520 --> 01:02:22,480
um these are all things to think about

01:02:20,799 --> 01:02:25,280
as type requirements when you when you

01:02:22,480 --> 01:02:25,280
build algorithms

01:02:27,359 --> 01:02:31,280
and i think with that i'm not seeing any

01:02:29,359 --> 01:02:33,119
more questions so

01:02:31,280 --> 01:02:35,839
happy coding and thank you for coming to

01:02:33,119 --> 01:02:35,839
the talk

01:02:54,559 --> 01:02:56,640

YouTube URL: https://www.youtube.com/watch?v=InMh3JxbiTs


