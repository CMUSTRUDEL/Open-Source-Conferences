Title: A Relaxed Guide to memory_order_relaxed - Paul E. McKenney & Hans Boehm - CppCon 2020
Publication date: 2020-09-30
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/a_relaxed_guide_to_memory_order_relaxed/a_relaxed_guide_to_memory_order_relaxed__paul_e_mckenney___cppcon_2020.pdf
---
The out-of-thin-air (OOTA) and read-from-untaken-branch (RFUB) properties of the specification of memory_order_relaxed have resulted in considerable consternation over the years. Although there are no known instances of full-blown OOTA behavior, and no known RFUB-induced failures of production code, the theoretical possibility of these properties severely complicates automated analysis of large C and C++ code bases. Thus far, attempts to eliminate OOTA and RFUB properties from the memory model have resulted in otherwise needless added overheads on weakly ordered systems on the one hand or excessive implementation complexity on the other. However, memory_order_relaxed never was intended to be used in arbitrary code, but rather as a part of deliberate application of specific concurrency designs. This talk provides an initial catalog of patterns underlying such designs.

---
Paul E. McKenney has been coding for almost four decades, more than half of that on parallel hardware, where his work has earned him a reputation among some as a flaming heretic. Paul maintains the RCU implementation within the Linux kernel, where the variety of workloads present highly entertaining performance, scalability, real-time response, and energy-efficiency challenges. Paul was previously an IBM Distinguished Engineer at the IBM Linux Technology Center. Prior to that, he worked on the DYNIX/ptx kernel at Sequent, and prior to that on packet-radio and Internet protocols (but long before it was polite to mention Internet at cocktail parties), system administration, business applications, and real-time systems. His hobbies include what passes for running at his age along with the usual house-wife-and-kids habit.

Hans is a software engineer at Google, where he has been since March 2014. He now works mostly on concurrent programming issues, both generally, and focussed on Android. Hans is an ACM Fellow, and a past Chair of ACM SIGPLAN (2001-2003). Until late 2017 he chaired the ISO C++ Concurrency Study Group (WG21/SG1), where he continues to actively participate.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:11,920 --> 00:00:15,759
uh

00:00:12,400 --> 00:00:16,160
so we got uh atomic operation c plus

00:00:15,759 --> 00:00:17,440
plus

00:00:16,160 --> 00:00:19,680
these are sequentially consistent by

00:00:17,440 --> 00:00:21,920
default

00:00:19,680 --> 00:00:23,439
and uh what that means is if you declare

00:00:21,920 --> 00:00:24,880
an atomic object and you load it or

00:00:23,439 --> 00:00:26,800
store it to it you get full interleaving

00:00:24,880 --> 00:00:27,519
semantics across all the atomic objects

00:00:26,800 --> 00:00:28,720
you have

00:00:27,519 --> 00:00:31,679
yeah about that but that's only if the

00:00:28,720 --> 00:00:32,960
default is used this is expensive

00:00:31,679 --> 00:00:35,280
and this is especially the case on

00:00:32,960 --> 00:00:38,879
weekly order architectures in many cases

00:00:35,280 --> 00:00:40,960
you don't need this interleaving somatic

00:00:38,879 --> 00:00:42,879
and this is allowed you can avoid that

00:00:40,960 --> 00:00:44,559
by using memory or im values

00:00:42,879 --> 00:00:45,120
particularly memory order relax which is

00:00:44,559 --> 00:00:48,000
what we're

00:00:45,120 --> 00:00:48,000
dealing with today

00:00:48,160 --> 00:00:52,480
and memory relax is wonderful from a

00:00:50,800 --> 00:00:54,160
number of viewpoints i mean if you give

00:00:52,480 --> 00:00:57,680
a memory order relaxed

00:00:54,160 --> 00:00:59,440
load you get a load a load instruction

00:00:57,680 --> 00:01:01,280
and if you do a memory order relax store

00:00:59,440 --> 00:01:03,120
you get a store instruction

00:01:01,280 --> 00:01:04,320
this is just wonderful you have control

00:01:03,120 --> 00:01:06,400
you have great efficiency and

00:01:04,320 --> 00:01:08,320
scalability assuming of course

00:01:06,400 --> 00:01:10,320
that your objects are of such a size

00:01:08,320 --> 00:01:12,720
that the hardware can accommodate this

00:01:10,320 --> 00:01:14,320
just below just the star's manic

00:01:12,720 --> 00:01:16,080
unfortunately uh there are some

00:01:14,320 --> 00:01:17,680
complications you see

00:01:16,080 --> 00:01:18,720
we we don't just have hardware to deal

00:01:17,680 --> 00:01:20,400
with we got these things called

00:01:18,720 --> 00:01:22,640
compilers

00:01:20,400 --> 00:01:24,400
and uh the compilers uh introduce some

00:01:22,640 --> 00:01:26,000
interesting things out of thin air and

00:01:24,400 --> 00:01:26,400
read from untaken branch now hans will

00:01:26,000 --> 00:01:28,159
be

00:01:26,400 --> 00:01:30,000
describing these in more detail in later

00:01:28,159 --> 00:01:31,439
slides i'm just going to give a quick

00:01:30,000 --> 00:01:32,880
overview of a history of the problem

00:01:31,439 --> 00:01:36,479
right here

00:01:32,880 --> 00:01:39,119
um small is somewhat sarcastic

00:01:36,479 --> 00:01:40,880
with ota you can get arbitrary behavior

00:01:39,119 --> 00:01:43,600
almost in many cases

00:01:40,880 --> 00:01:45,119
in theory and java has a similar problem

00:01:43,600 --> 00:01:46,079
they've been attacking for more than 20

00:01:45,119 --> 00:01:48,159
years

00:01:46,079 --> 00:01:49,360
without really getting a solution

00:01:48,159 --> 00:01:51,040
nevertheless

00:01:49,360 --> 00:01:52,479
in the last few years we have had some

00:01:51,040 --> 00:01:54,000
progress

00:01:52,479 --> 00:01:55,840
first off we now have ways of

00:01:54,000 --> 00:01:59,360
classifying what that ota

00:01:55,840 --> 00:02:03,600
is versus just simple reordering before

00:01:59,360 --> 00:02:05,119
these two advances we didn't even have

00:02:03,600 --> 00:02:07,439
any kind of agreed on definition of

00:02:05,119 --> 00:02:09,520
exactly what oota was and wasn't

00:02:07,439 --> 00:02:11,599
aside from a set of litmus tests on both

00:02:09,520 --> 00:02:14,480
sides

00:02:11,599 --> 00:02:16,239
unfortunately the first uh thing was a

00:02:14,480 --> 00:02:18,400
paper that a bunch of guys myself did

00:02:16,239 --> 00:02:19,599
a c plus working paper we did some years

00:02:18,400 --> 00:02:20,959
back

00:02:19,599 --> 00:02:22,879
it's not even an algorithm it's a

00:02:20,959 --> 00:02:23,680
decision procedure you have to have a

00:02:22,879 --> 00:02:26,879
human being

00:02:23,680 --> 00:02:28,959
and a with a human being execute it

00:02:26,879 --> 00:02:30,800
uh you have to have personal creativity

00:02:28,959 --> 00:02:32,080
to get the right answer

00:02:30,800 --> 00:02:33,599
uh more lately there have been some

00:02:32,080 --> 00:02:34,080
academic groups that produce some very

00:02:33,599 --> 00:02:36,319
good

00:02:34,080 --> 00:02:38,239
they're actually our algorithms but they

00:02:36,319 --> 00:02:41,599
aren't things you can put in a compiler

00:02:38,239 --> 00:02:43,200
at least not yet so personally

00:02:41,599 --> 00:02:44,640
i expect that we will get to something

00:02:43,200 --> 00:02:46,400
we can put in a compiler

00:02:44,640 --> 00:02:48,800
sooner rather than later but if you look

00:02:46,400 --> 00:02:49,599
at the history we've got probably a few

00:02:48,800 --> 00:02:51,920
years

00:02:49,599 --> 00:02:53,519
maybe even five of them before we get

00:02:51,920 --> 00:02:54,879
the statement of a solution

00:02:53,519 --> 00:02:56,319
then we've got another couple of years

00:02:54,879 --> 00:02:57,360
getting the standard another few years

00:02:56,319 --> 00:02:59,920
to get it propagating through the

00:02:57,360 --> 00:02:59,920
compilers

00:03:00,000 --> 00:03:03,920
so we have to deal with for some time

00:03:02,239 --> 00:03:05,360
now we do have one pragmatic solution

00:03:03,920 --> 00:03:06,159
that hans came up with among other

00:03:05,360 --> 00:03:09,200
people and they

00:03:06,159 --> 00:03:10,640
got a formal variant but what happens

00:03:09,200 --> 00:03:12,640
there is you get

00:03:10,640 --> 00:03:14,800
otherwise unnecessary overhead on weekly

00:03:12,640 --> 00:03:17,440
order algorithms such as arm

00:03:14,800 --> 00:03:18,720
now uh hans did provide a refined

00:03:17,440 --> 00:03:21,360
proposal

00:03:18,720 --> 00:03:22,480
that adds a memory order load store

00:03:21,360 --> 00:03:24,799
memory num

00:03:22,480 --> 00:03:26,239
that avoids it where you don't you know

00:03:24,799 --> 00:03:28,239
so you can still use memory or delax

00:03:26,239 --> 00:03:32,239
relaxed where you need it

00:03:28,239 --> 00:03:34,319
um but in any case uh

00:03:32,239 --> 00:03:35,360
we've got a problem and at this point

00:03:34,319 --> 00:03:36,560
what i'm going to do is go to the next

00:03:35,360 --> 00:03:38,560
slide and let hans

00:03:36,560 --> 00:03:39,599
take over and tell you exactly what ota

00:03:38,560 --> 00:03:43,280
and our fob is

00:03:39,599 --> 00:03:46,000
go ahead yeah i'll go ahead and describe

00:03:43,280 --> 00:03:47,760
what what the out of thin air problem is

00:03:46,000 --> 00:03:49,680
it's easiest to describe this by

00:03:47,760 --> 00:03:51,680
contrasting a bunch of different kinds

00:03:49,680 --> 00:03:52,879
of examples so i'll start with an

00:03:51,680 --> 00:03:56,480
example

00:03:52,879 --> 00:03:58,879
uh with the questionable outcome

00:03:56,480 --> 00:04:00,480
in fact is intended to be allowed and we

00:03:58,879 --> 00:04:02,640
must allow it

00:04:00,480 --> 00:04:04,239
then i'll describe some out of thin air

00:04:02,640 --> 00:04:06,000
examples

00:04:04,239 --> 00:04:08,000
where we really don't expect the

00:04:06,000 --> 00:04:09,120
questionable outcomes described in those

00:04:08,000 --> 00:04:10,959
slides to occur

00:04:09,120 --> 00:04:12,159
but we don't really know how to prevent

00:04:10,959 --> 00:04:15,200
that from in

00:04:12,159 --> 00:04:17,759
by phrasing the specification correctly

00:04:15,200 --> 00:04:19,680
and finally i'll look at a more modern

00:04:17,759 --> 00:04:21,759
variant of this that's sort of in

00:04:19,680 --> 00:04:24,080
between the two and points out exactly

00:04:21,759 --> 00:04:25,680
why this is difficult and why we might

00:04:24,080 --> 00:04:30,479
have trouble distinguishing between

00:04:25,680 --> 00:04:30,479
those two let's go on

00:04:34,080 --> 00:04:37,520
the actual c plus syntax in this area

00:04:37,199 --> 00:04:39,600
was

00:04:37,520 --> 00:04:42,320
designed on the assumption that the

00:04:39,600 --> 00:04:42,800
memory order relaxed atomics are very

00:04:42,320 --> 00:04:44,880
rare

00:04:42,800 --> 00:04:47,040
and should be highlighted so it has a

00:04:44,880 --> 00:04:49,440
rather verbose syntax unfortunately that

00:04:47,040 --> 00:04:51,600
doesn't play well with slide where like

00:04:49,440 --> 00:04:52,960
like this that tries to look at

00:04:51,600 --> 00:04:54,800
different litmus tests so we'll

00:04:52,960 --> 00:04:56,000
introduce some shorthand notation here

00:04:54,800 --> 00:04:58,720
which isn't quite c plus

00:04:56,000 --> 00:05:01,039
plus in general when we use variables

00:04:58,720 --> 00:05:02,880
like x and y

00:05:01,039 --> 00:05:04,479
those will denote potentially shared

00:05:02,880 --> 00:05:08,000
memory locations

00:05:04,479 --> 00:05:11,759
global variables of the like

00:05:08,000 --> 00:05:13,120
r1 and r2 two will will denote locals

00:05:11,759 --> 00:05:14,960
you can think of those as being

00:05:13,120 --> 00:05:17,680
registers essentially but they're in

00:05:14,960 --> 00:05:20,080
in c plus terminology their address not

00:05:17,680 --> 00:05:22,720
taken local variables

00:05:20,080 --> 00:05:24,479
and we'll generally assume unless we

00:05:22,720 --> 00:05:25,440
state otherwise that all shared

00:05:24,479 --> 00:05:29,280
locations

00:05:25,440 --> 00:05:31,120
are initialized to zero null or false

00:05:29,280 --> 00:05:32,880
implicitly sometimes we'll make that

00:05:31,120 --> 00:05:35,280
explicit

00:05:32,880 --> 00:05:36,240
and we'll abbreviate the actual c plus

00:05:35,280 --> 00:05:38,800
plus syntax

00:05:36,240 --> 00:05:40,960
appreciably so rather than saying load

00:05:38,800 --> 00:05:43,199
of memory order relaxed

00:05:40,960 --> 00:05:45,199
will usually put a relaxed suffix

00:05:43,199 --> 00:05:47,759
somewhere in the vicinity to indicate

00:05:45,199 --> 00:05:49,840
that the the memory operation that's

00:05:47,759 --> 00:05:51,360
involved in that statement is intended

00:05:49,840 --> 00:05:53,360
to be relaxed

00:05:51,360 --> 00:05:55,919
and you're intended to fill in the full

00:05:53,360 --> 00:05:57,919
syntax here using the std colon colon

00:05:55,919 --> 00:06:00,800
memory autorelax

00:05:57,919 --> 00:06:00,800
okay next one

00:06:01,600 --> 00:06:07,199
so this is the basic example that

00:06:04,000 --> 00:06:10,479
actually has to be allowed

00:06:07,199 --> 00:06:13,680
so what we have here is a simple program

00:06:10,479 --> 00:06:17,680
operating on two atomics and two threads

00:06:13,680 --> 00:06:20,880
that one basically copies x to y

00:06:17,680 --> 00:06:23,199
by loading x into r1 and then storing

00:06:20,880 --> 00:06:26,880
the result back into y

00:06:23,199 --> 00:06:30,960
and thread 2 loads y

00:06:26,880 --> 00:06:34,080
but then they just store 42 to x

00:06:30,960 --> 00:06:36,319
both x and y are initially zero

00:06:34,080 --> 00:06:36,319
and

00:06:37,199 --> 00:06:41,440
we would expect that if this were just

00:06:39,360 --> 00:06:43,440
executed with sequentially consistent

00:06:41,440 --> 00:06:46,840
semantics

00:06:43,440 --> 00:06:48,400
then in fact both r1 and r2 should be

00:06:46,840 --> 00:06:52,160
zero

00:06:48,400 --> 00:06:53,280
uh well or at least one of our one and r

00:06:52,160 --> 00:06:56,639
two should be zero

00:06:53,280 --> 00:06:59,520
since uh in particular in

00:06:56,639 --> 00:07:00,840
particular all two should be zero uh

00:06:59,520 --> 00:07:04,800
however

00:07:00,840 --> 00:07:07,919
in can we have the next slide

00:07:04,800 --> 00:07:07,919
actually sorry one back

00:07:08,720 --> 00:07:12,800
however in reality we have to expect the

00:07:11,280 --> 00:07:15,840
case here where r1

00:07:12,800 --> 00:07:16,800
and r2 are both 42 because we said that

00:07:15,840 --> 00:07:19,039
these were relaxed

00:07:16,800 --> 00:07:21,360
operations so it's entirely acceptable

00:07:19,039 --> 00:07:25,039
for the compiler to reorder these

00:07:21,360 --> 00:07:29,039
and to initially store 42 into x

00:07:25,039 --> 00:07:31,599
in thread 2 and then load y from r2

00:07:29,039 --> 00:07:32,720
and if thread one just executes in

00:07:31,599 --> 00:07:36,240
between

00:07:32,720 --> 00:07:38,319
the store 42 into x and the load from y

00:07:36,240 --> 00:07:39,919
then we have precisely the we have an

00:07:38,319 --> 00:07:42,960
outcome in which r1 equals

00:07:39,919 --> 00:07:46,479
r2 equals 42 and

00:07:42,960 --> 00:07:49,280
that's entirely reasonable and expected

00:07:46,479 --> 00:07:51,039
can we go on to the next slide no thanks

00:07:49,280 --> 00:07:53,599
on the other hand

00:07:51,039 --> 00:07:54,319
um here we have a slightly different

00:07:53,599 --> 00:07:58,319
example

00:07:54,319 --> 00:08:02,479
with r42 is not explicitly stalled and

00:07:58,319 --> 00:08:05,599
the only zeros involved in the program

00:08:02,479 --> 00:08:07,120
but if we see the same pattern of reads

00:08:05,599 --> 00:08:10,560
as in the last slide

00:08:07,120 --> 00:08:13,199
where each thread sees the initially in

00:08:10,560 --> 00:08:13,599
its load sees the stall of the other

00:08:13,199 --> 00:08:15,919
thread

00:08:13,599 --> 00:08:18,240
even though it happens later we get a we

00:08:15,919 --> 00:08:20,160
can get a very weird outcome

00:08:18,240 --> 00:08:22,000
so the outcome that we're concerned

00:08:20,160 --> 00:08:24,720
about here and this is the canonical

00:08:22,000 --> 00:08:28,000
example for an out of thin air execution

00:08:24,720 --> 00:08:29,759
is one in which the value of 42 here

00:08:28,000 --> 00:08:32,320
doesn't appear in the program but we

00:08:29,759 --> 00:08:35,360
suddenly get some value like 42

00:08:32,320 --> 00:08:37,279
appearing in the output

00:08:35,360 --> 00:08:38,839
so in this particular case we have a

00:08:37,279 --> 00:08:42,800
situation where y

00:08:38,839 --> 00:08:46,320
leads where y appears to be 42

00:08:42,800 --> 00:08:50,480
then that two stores that to x

00:08:46,320 --> 00:08:51,200
then um that one reads the 42 that's

00:08:50,480 --> 00:08:54,480
stored by

00:08:51,200 --> 00:08:57,920
third two and that one

00:08:54,480 --> 00:08:59,519
again stores the value of 42 back

00:08:57,920 --> 00:09:01,519
let's go on to the next slide here to

00:08:59,519 --> 00:09:02,800
discuss exactly how this kind of thing

00:09:01,519 --> 00:09:04,720
might happen

00:09:02,800 --> 00:09:06,800
uh so the kind of execution we're

00:09:04,720 --> 00:09:08,320
talking about here is one

00:09:06,800 --> 00:09:11,040
in which say the hardware or the

00:09:08,320 --> 00:09:13,120
compiler guesses somehow that x and y

00:09:11,040 --> 00:09:16,399
are initially 42.

00:09:13,120 --> 00:09:19,200
and so when we initially

00:09:16,399 --> 00:09:20,560
read r1 and r2 in thread one and alt

00:09:19,200 --> 00:09:24,800
that one and two

00:09:20,560 --> 00:09:27,519
they both guessed the value as 42.

00:09:24,800 --> 00:09:29,040
they then stole 42 back to the other

00:09:27,519 --> 00:09:31,440
variable

00:09:29,040 --> 00:09:33,920
and since we guessed initially that x

00:09:31,440 --> 00:09:35,279
and y were 42 the compiled code now has

00:09:33,920 --> 00:09:38,080
to verify that that guess

00:09:35,279 --> 00:09:39,040
actually was correct and undo this if it

00:09:38,080 --> 00:09:41,279
was not

00:09:39,040 --> 00:09:42,959
so at the end we just checked that in

00:09:41,279 --> 00:09:46,160
fact the loads were okay

00:09:42,959 --> 00:09:49,279
and x and y were in fact 42 but since we

00:09:46,160 --> 00:09:51,279
just stalled 42 into x and y

00:09:49,279 --> 00:09:52,399
we can confirm that our speculation is

00:09:51,279 --> 00:09:55,680
correct

00:09:52,399 --> 00:09:59,040
and we're now we're now okay

00:09:55,680 --> 00:10:00,800
and this corresponds again informally in

00:09:59,040 --> 00:10:04,240
the c plus plus memory model this

00:10:00,800 --> 00:10:06,240
corresponds to the case where each load

00:10:04,240 --> 00:10:08,480
sees the stall that's produced by the

00:10:06,240 --> 00:10:10,720
other thread the concurrent

00:10:08,480 --> 00:10:12,320
concurrent racing stall produced by the

00:10:10,720 --> 00:10:15,839
other thread

00:10:12,320 --> 00:10:17,680
and normally

00:10:15,839 --> 00:10:19,120
well aside from some things we'll talk

00:10:17,680 --> 00:10:22,000
about here this is

00:10:19,120 --> 00:10:22,880
this is very hard to prohibit and it's

00:10:22,000 --> 00:10:24,959
not

00:10:22,880 --> 00:10:27,040
it's not usually prohibited directly by

00:10:24,959 --> 00:10:33,440
the formal aspects of the c plus plus

00:10:27,040 --> 00:10:35,360
memory model and next slide

00:10:33,440 --> 00:10:36,880
there's another variant of such out of

00:10:35,360 --> 00:10:40,399
thin air results that are

00:10:36,880 --> 00:10:42,399
that's even more disconcerting really uh

00:10:40,399 --> 00:10:44,320
and that's the the following one that's

00:10:42,399 --> 00:10:46,640
the one in which the stalls

00:10:44,320 --> 00:10:47,760
are not actually even present in the

00:10:46,640 --> 00:10:50,399
program

00:10:47,760 --> 00:10:51,839
but what happens instead is we

00:10:50,399 --> 00:10:54,560
speculatively

00:10:51,839 --> 00:10:57,519
read some value at the beginning of the

00:10:54,560 --> 00:10:59,760
thread using a relaxed memory operation

00:10:57,519 --> 00:11:01,440
and we speculate some value which is in

00:10:59,760 --> 00:11:03,680
fact not valid

00:11:01,440 --> 00:11:05,200
so what happens as a result is the next

00:11:03,680 --> 00:11:07,440
statement

00:11:05,200 --> 00:11:09,120
generates in the words of the standard

00:11:07,440 --> 00:11:12,480
undefined behavior

00:11:09,120 --> 00:11:15,760
but that undefined behavior can include

00:11:12,480 --> 00:11:16,480
storing something to the other uh to the

00:11:15,760 --> 00:11:18,959
other

00:11:16,480 --> 00:11:20,480
atomic variable which is being read by

00:11:18,959 --> 00:11:23,600
the other thread

00:11:20,480 --> 00:11:23,920
so in in thread one here when we see a

00:11:23,600 --> 00:11:28,320
sub

00:11:23,920 --> 00:11:30,959
r1 is equal to 42 if r1 happens to be

00:11:28,320 --> 00:11:34,720
exactly the right bogus value

00:11:30,959 --> 00:11:37,839
we may actually end up storing back to y

00:11:34,720 --> 00:11:40,480
uh so as a result of that with this kind

00:11:37,839 --> 00:11:41,120
of behavior we can again get r1 equals

00:11:40,480 --> 00:11:45,279
r2

00:11:41,120 --> 00:11:49,120
equals 42 um even though

00:11:45,279 --> 00:11:50,880
this uh that's completely nonsensical

00:11:49,120 --> 00:11:52,639
since we're reading from x and y

00:11:50,880 --> 00:11:55,360
which should have nothing to do with a

00:11:52,639 --> 00:11:56,000
and b but formally this has to do with

00:11:55,360 --> 00:11:59,600
the uh

00:11:56,000 --> 00:12:03,279
with the way undefined behavior works

00:11:59,600 --> 00:12:03,920
um and it also has to do with the fact

00:12:03,279 --> 00:12:06,399
that

00:12:03,920 --> 00:12:07,760
again we have this funny kind of pattern

00:12:06,399 --> 00:12:10,800
where with a load

00:12:07,760 --> 00:12:12,800
and each thread sees the store sees the

00:12:10,800 --> 00:12:14,720
concurrent store from the other thread

00:12:12,800 --> 00:12:15,920
only in this case the concurrent store

00:12:14,720 --> 00:12:19,360
isn't actually there

00:12:15,920 --> 00:12:22,000
it's part of the undefined behavior

00:12:19,360 --> 00:12:22,000
can we go on

00:12:22,959 --> 00:12:27,440
and uh this is sort of a more detailed

00:12:26,000 --> 00:12:30,000
example here of

00:12:27,440 --> 00:12:32,240
exactly how this would work i already

00:12:30,000 --> 00:12:34,480
discussed this in the last slide

00:12:32,240 --> 00:12:35,279
again it's the out of bounds accesses

00:12:34,480 --> 00:12:38,480
here

00:12:35,279 --> 00:12:41,519
that right to the other atomic variable

00:12:38,480 --> 00:12:45,360
can we go to the next slide

00:12:41,519 --> 00:12:47,839
um outlawing out of thin air here is

00:12:45,360 --> 00:12:50,160
and as paul already said is actually a

00:12:47,839 --> 00:12:53,360
very long-standing problem

00:12:50,160 --> 00:12:55,519
uh it's it's very difficult to define

00:12:53,360 --> 00:12:57,440
this in the specification

00:12:55,519 --> 00:12:59,839
uh until recently we thought this was

00:12:57,440 --> 00:13:01,440
really purely sort of a specification

00:12:59,839 --> 00:13:02,959
problem and in some sense we just needed

00:13:01,440 --> 00:13:04,720
the right words

00:13:02,959 --> 00:13:06,480
it's actually a little more than that as

00:13:04,720 --> 00:13:09,519
we'll go into here

00:13:06,480 --> 00:13:12,079
uh as paul mentioned java c and

00:13:09,519 --> 00:13:13,200
the c11 and c plus plus 11 tied and

00:13:12,079 --> 00:13:17,040
failed

00:13:13,200 --> 00:13:19,920
um is the way it turns out uh

00:13:17,040 --> 00:13:22,480
c c 11 and c plus plus 11 actually so

00:13:19,920 --> 00:13:24,399
had an attempted solution to this

00:13:22,480 --> 00:13:25,680
which ended up being even worse than the

00:13:24,399 --> 00:13:28,320
problem

00:13:25,680 --> 00:13:30,560
uh and this is a problem that continues

00:13:28,320 --> 00:13:31,519
to be investigated by many people here

00:13:30,560 --> 00:13:35,680
including the

00:13:31,519 --> 00:13:39,360
the the wg21 concurrency group

00:13:35,680 --> 00:13:41,279
uh next slide so what we actually have

00:13:39,360 --> 00:13:43,440
since we fixed the bogus attempt to

00:13:41,279 --> 00:13:45,839
address this issue in c plus

00:13:43,440 --> 00:13:46,639
11 is we have some wording in the

00:13:45,839 --> 00:13:49,920
standard

00:13:46,639 --> 00:13:51,680
which is embarrassingly hand wavy and

00:13:49,920 --> 00:13:53,360
which nobody actually believed was

00:13:51,680 --> 00:13:54,160
sufficient even when we put it in the

00:13:53,360 --> 00:13:55,839
standard

00:13:54,160 --> 00:13:58,160
it just recognized the problem

00:13:55,839 --> 00:14:01,760
essentially it just says implementations

00:13:58,160 --> 00:14:04,000
should ensure that no out of thin air

00:14:01,760 --> 00:14:05,360
values are computed that circulately

00:14:04,000 --> 00:14:10,639
depend on their

00:14:05,360 --> 00:14:10,639
their own computation um

00:14:13,600 --> 00:14:17,040
we knew from the beginning that this was

00:14:16,160 --> 00:14:21,120
really

00:14:17,040 --> 00:14:21,120
way too imprecise

00:14:23,279 --> 00:14:26,720
but we left it in embarrassment and all

00:14:26,160 --> 00:14:28,839
anyway

00:14:26,720 --> 00:14:30,399
because we didn't know of a better

00:14:28,839 --> 00:14:32,480
solution

00:14:30,399 --> 00:14:36,320
since this is sort of a hand-wavy

00:14:32,480 --> 00:14:36,320
restriction in the current

00:14:37,279 --> 00:14:41,519
in the current version here actually let

00:14:40,639 --> 00:14:43,519
me try it

00:14:41,519 --> 00:14:45,120
i'm being told that there's an echo here

00:14:43,519 --> 00:14:48,320
let me just quickly

00:14:45,120 --> 00:14:59,839
see if i can

00:14:48,320 --> 00:14:59,839
figure out the source of this

00:15:00,079 --> 00:15:04,399
uh unfortunately not okay let me just

00:15:02,800 --> 00:15:06,800
continue here

00:15:04,399 --> 00:15:06,800
um

00:15:07,519 --> 00:15:13,600
so in order to deal with the presence of

00:15:11,440 --> 00:15:15,680
this uh

00:15:13,600 --> 00:15:16,880
this vague specification well actually

00:15:15,680 --> 00:15:19,600
for the purposes of this

00:15:16,880 --> 00:15:20,880
talk introduce the notion of c plus plus

00:15:19,600 --> 00:15:25,519
00:15:20,880 --> 00:15:27,920
um which is which is just defined to be

00:15:25,519 --> 00:15:30,079
which will define to be c plus plus 20

00:15:27,920 --> 00:15:32,160
without this hand waving statement

00:15:30,079 --> 00:15:34,000
so when we talk with talk about whether

00:15:32,160 --> 00:15:37,440
something is correct

00:15:34,000 --> 00:15:39,440
in uh in strict c plus plus 20

00:15:37,440 --> 00:15:40,480
we mean that it's actually strictly

00:15:39,440 --> 00:15:42,959
correct by the

00:15:40,480 --> 00:15:44,160
precise part of the c plus plus 20

00:15:42,959 --> 00:15:48,079
standards

00:15:44,160 --> 00:15:50,399
and we'll discuss that in some cases

00:15:48,079 --> 00:15:51,279
that's actually that's actually more

00:15:50,399 --> 00:15:54,000
restrictive

00:15:51,279 --> 00:15:55,600
than than we need to be perhaps on the

00:15:54,000 --> 00:15:57,440
other hand it's what we can

00:15:55,600 --> 00:15:59,600
what we can define precisely and it's

00:15:57,440 --> 00:16:03,040
what we can reason about precisely

00:15:59,600 --> 00:16:03,040
can we go on to the next slide

00:16:03,440 --> 00:16:09,519
um so i promise you another kind of

00:16:07,120 --> 00:16:11,360
example which i'll only outline here

00:16:09,519 --> 00:16:15,519
briefly because going through this is

00:16:11,360 --> 00:16:18,959
uh is fairly complicated and lengthy

00:16:15,519 --> 00:16:21,440
that illustrates that these

00:16:18,959 --> 00:16:22,480
that in fact this is more than a purely

00:16:21,440 --> 00:16:25,120
specification

00:16:22,480 --> 00:16:26,480
problem in that there are in fact cases

00:16:25,120 --> 00:16:28,800
that are sort of in the middle where

00:16:26,480 --> 00:16:30,880
it's unclear what's out of thin it

00:16:28,800 --> 00:16:32,320
then what's it out of thin air result

00:16:30,880 --> 00:16:34,560
and what's not

00:16:32,320 --> 00:16:37,360
so the example here that i have on this

00:16:34,560 --> 00:16:40,560
slide is very similar to this canonical

00:16:37,360 --> 00:16:43,040
out of thin air example in which

00:16:40,560 --> 00:16:44,240
we one third copies x to y and the other

00:16:43,040 --> 00:16:48,079
one copies y to

00:16:44,240 --> 00:16:50,079
x and so what i did here is i

00:16:48,079 --> 00:16:52,079
you see that code in blue here in fact

00:16:50,079 --> 00:16:53,199
and what i did is i added the code in

00:16:52,079 --> 00:16:55,839
green

00:16:53,199 --> 00:16:56,480
uh which augments that a little bit so i

00:16:55,839 --> 00:16:59,519
assigned

00:16:56,480 --> 00:17:01,519
to assign 42 here you can think of

00:16:59,519 --> 00:17:04,799
a local it's not touched by anything

00:17:01,519 --> 00:17:07,520
else um

00:17:04,799 --> 00:17:10,400
i introduced that variable and then i

00:17:07,520 --> 00:17:12,880
introduced some other code in green here

00:17:10,400 --> 00:17:15,360
which in the interesting execution here

00:17:12,880 --> 00:17:17,199
i can show is not executed

00:17:15,360 --> 00:17:18,720
so it shouldn't actually matter and it

00:17:17,199 --> 00:17:20,160
shouldn't affect the semantics of the

00:17:18,720 --> 00:17:22,000
program at all

00:17:20,160 --> 00:17:24,079
since we know it doesn't actually

00:17:22,000 --> 00:17:24,640
execute but nonetheless with this

00:17:24,079 --> 00:17:27,919
additional

00:17:24,640 --> 00:17:30,160
unexecuted code in there in fact i can

00:17:27,919 --> 00:17:32,400
get the out of thin air result and i can

00:17:30,160 --> 00:17:34,400
get it in existing implementations in

00:17:32,400 --> 00:17:37,280
fact

00:17:34,400 --> 00:17:38,320
so as you can see here what i do is i

00:17:37,280 --> 00:17:43,360
just

00:17:38,320 --> 00:17:45,760
uh check if i don't see r2 equal to 42

00:17:43,360 --> 00:17:47,039
and then i assign r2 equals 42

00:17:45,760 --> 00:17:48,960
afterwards

00:17:47,039 --> 00:17:51,200
and i keep track of the fact that i took

00:17:48,960 --> 00:17:54,559
this branch in the if

00:17:51,200 --> 00:17:56,480
and then assign it back and it turns out

00:17:54,559 --> 00:17:58,640
this has the effect of

00:17:56,480 --> 00:18:00,640
convincing the compiler that r2 is

00:17:58,640 --> 00:18:02,640
always going to be 42

00:18:00,640 --> 00:18:05,039
which convinces the compiler that it's

00:18:02,640 --> 00:18:07,840
okay to reorder this again

00:18:05,039 --> 00:18:09,280
uh but if that happens i can get this

00:18:07,840 --> 00:18:12,960
execution in which

00:18:09,280 --> 00:18:14,799
x equals y and r1 and up x y and r1 and

00:18:12,960 --> 00:18:17,919
r2 are all 42

00:18:14,799 --> 00:18:19,760
but assign 42 is false so the only code

00:18:17,919 --> 00:18:21,200
i changed here was code that didn't

00:18:19,760 --> 00:18:24,240
execute

00:18:21,200 --> 00:18:25,360
um and the the details for this example

00:18:24,240 --> 00:18:28,559
you can find in

00:18:25,360 --> 00:18:31,760
in that in that code

00:18:28,559 --> 00:18:31,760
uh let's go on

00:18:32,400 --> 00:18:39,600
back to you paul this time skillfully

00:18:35,919 --> 00:18:41,440
unmuting myself uh for a change

00:18:39,600 --> 00:18:42,960
so this is a repeat of my last slide

00:18:41,440 --> 00:18:46,320
we've got the history

00:18:42,960 --> 00:18:48,480
and uh based on what hans has told you

00:18:46,320 --> 00:18:50,799
an excellent question is in the meantime

00:18:48,480 --> 00:18:53,039
you know before we get all the

00:18:50,799 --> 00:18:53,919
all this defined before we figure out

00:18:53,039 --> 00:18:58,080
formally what

00:18:53,919 --> 00:18:58,080
out of thin air and our phob the r

00:18:58,160 --> 00:19:02,640
where can you use memory or to relax

00:19:00,160 --> 00:19:02,640
safely

00:19:03,280 --> 00:19:05,919
and uh

00:19:06,480 --> 00:19:09,440
what we're saying and this is the point

00:19:07,760 --> 00:19:10,000
of the paper and this presentation in

00:19:09,440 --> 00:19:12,559
the meantime

00:19:10,000 --> 00:19:14,240
you use known good patterns okay in

00:19:12,559 --> 00:19:14,960
other words if you go off and randomly

00:19:14,240 --> 00:19:17,760
generate

00:19:14,960 --> 00:19:18,480
code that uses memory order relaxed i'm

00:19:17,760 --> 00:19:19,679
sorry but

00:19:18,480 --> 00:19:22,720
for the moment you'll probably get what

00:19:19,679 --> 00:19:24,240
you deserve maybe oota maybe rf unlikely

00:19:22,720 --> 00:19:26,000
oota there are many implementations to

00:19:24,240 --> 00:19:29,440
do that as far as we know

00:19:26,000 --> 00:19:31,039
uh and yeah the fact is that this is

00:19:29,440 --> 00:19:32,559
true of the other membrane values

00:19:31,039 --> 00:19:34,400
but it's just that there are fewer

00:19:32,559 --> 00:19:36,559
counter-intuitive pitfalls

00:19:34,400 --> 00:19:38,400
with those other with acquire release

00:19:36,559 --> 00:19:41,520
and and uh sequential assistance

00:19:38,400 --> 00:19:42,559
and so on so again

00:19:41,520 --> 00:19:44,559
if you're going to use memory order

00:19:42,559 --> 00:19:46,080
relaxed you should use it in the context

00:19:44,559 --> 00:19:48,000
of known good patterns

00:19:46,080 --> 00:19:50,080
and the link is to the working paper

00:19:48,000 --> 00:19:53,120
that hans and i presented on this topic

00:19:50,080 --> 00:19:55,520
uh last february

00:19:53,120 --> 00:19:56,799
okay so uh one question is when is it

00:19:55,520 --> 00:19:59,200
fully safe and here

00:19:56,799 --> 00:20:01,039
we mean fully safe within strict c plus

00:19:59,200 --> 00:20:03,280
plus 20 that han's defined where we

00:20:01,039 --> 00:20:04,960
where we exclude the weasel worded

00:20:03,280 --> 00:20:08,640
exclusion

00:20:04,960 --> 00:20:10,720
and the advantage of staying within this

00:20:08,640 --> 00:20:12,559
bounds is that as sean said we can we

00:20:10,720 --> 00:20:15,360
can reason precisely about it

00:20:12,559 --> 00:20:17,039
and uh we know that unexecuted code

00:20:15,360 --> 00:20:19,679
isn't going to cause us these funny

00:20:17,039 --> 00:20:21,039
reads from untaken branches and we're

00:20:19,679 --> 00:20:21,360
going to present some things hans and i

00:20:21,039 --> 00:20:22,320
will

00:20:21,360 --> 00:20:24,400
through the next rest of this

00:20:22,320 --> 00:20:25,919
presentation some of them are going to

00:20:24,400 --> 00:20:28,480
be fully safe

00:20:25,919 --> 00:20:29,679
others which are important are safe and

00:20:28,480 --> 00:20:32,400
are used heavily

00:20:29,679 --> 00:20:35,840
still require the weasel words and we'll

00:20:32,400 --> 00:20:35,840
distinguish between those for you

00:20:37,039 --> 00:20:41,440
okay so let's look at some simple use

00:20:39,280 --> 00:20:44,000
cases first

00:20:41,440 --> 00:20:44,880
and uh one example is atomic counters

00:20:44,000 --> 00:20:48,159
and these

00:20:44,880 --> 00:20:49,039
you update while you're running and

00:20:48,159 --> 00:20:52,080
these might be

00:20:49,039 --> 00:20:52,640
atomic atomic increments relaxed atomic

00:20:52,080 --> 00:20:54,080
increments

00:20:52,640 --> 00:20:55,440
so counting events or something like

00:20:54,080 --> 00:20:56,960
that perhaps they're per thread

00:20:55,440 --> 00:21:00,720
variables

00:20:56,960 --> 00:21:02,159
uh local storage for local storage

00:21:00,720 --> 00:21:03,840
that is incremented only by the thread

00:21:02,159 --> 00:21:06,880
that uses it

00:21:03,840 --> 00:21:07,360
and uh you only have these things

00:21:06,880 --> 00:21:09,840
happening

00:21:07,360 --> 00:21:12,480
on in the in each counter nobody's

00:21:09,840 --> 00:21:14,960
looking at anybody else's counters until

00:21:12,480 --> 00:21:16,000
we get to the end of the program all

00:21:14,960 --> 00:21:17,679
threads with the main thread

00:21:16,000 --> 00:21:19,520
have terminated and now we're going to

00:21:17,679 --> 00:21:22,000
read them out and print them

00:21:19,520 --> 00:21:23,120
in this case we don't have racing stores

00:21:22,000 --> 00:21:25,919
and we can't get the

00:21:23,120 --> 00:21:26,799
canonical oota pattern so this use case

00:21:25,919 --> 00:21:29,120
is safe

00:21:26,799 --> 00:21:30,720
even in strict c plus plus without the

00:21:29,120 --> 00:21:33,440
uh without the

00:21:30,720 --> 00:21:33,440
funny advice

00:21:33,919 --> 00:21:37,919
another category is where the order is

00:21:35,760 --> 00:21:41,200
provided by atomic threat fence

00:21:37,919 --> 00:21:42,799
all right so rather than say a memory

00:21:41,200 --> 00:21:44,480
order release store and then a memory

00:21:42,799 --> 00:21:46,080
order require load or whichever

00:21:44,480 --> 00:21:48,000
we have an atomic thread fence of a

00:21:46,080 --> 00:21:49,039
choir atomic thread fence released in

00:21:48,000 --> 00:21:51,679
the proper places

00:21:49,039 --> 00:21:52,400
in that case those atomic thread fence

00:21:51,679 --> 00:21:54,960
calls

00:21:52,400 --> 00:21:56,320
prevent the canonical ota pattern from

00:21:54,960 --> 00:21:57,919
forming

00:21:56,320 --> 00:21:59,440
and finally this one may sound kind of

00:21:57,919 --> 00:22:01,200
useless but it's

00:21:59,440 --> 00:22:04,559
used surprisingly often and that's where

00:22:01,200 --> 00:22:06,000
there is only one shared object

00:22:04,559 --> 00:22:08,720
for example we might have some

00:22:06,000 --> 00:22:11,200
independent algorithms running within a

00:22:08,720 --> 00:22:12,000
within a given multi-threaded process

00:22:11,200 --> 00:22:14,159
and they might

00:22:12,000 --> 00:22:16,000
just have one variable they share saying

00:22:14,159 --> 00:22:17,679
it's time to stop right now

00:22:16,000 --> 00:22:19,039
perhaps an emergency stop type of

00:22:17,679 --> 00:22:21,760
indication

00:22:19,039 --> 00:22:23,440
and in that case we only have one shared

00:22:21,760 --> 00:22:25,440
object

00:22:23,440 --> 00:22:27,280
because the canonical pattern requires

00:22:25,440 --> 00:22:28,480
two shared objects we can't possibly

00:22:27,280 --> 00:22:30,880
have out of thin air

00:22:28,480 --> 00:22:32,320
executions or read from untaken branch

00:22:30,880 --> 00:22:35,919
executions

00:22:32,320 --> 00:22:39,120
so those are a few simple cases

00:22:35,919 --> 00:22:40,960
going ahead here another one

00:22:39,120 --> 00:22:43,039
this is a little more tricky so we're

00:22:40,960 --> 00:22:43,360
going to spend a little bit more time on

00:22:43,039 --> 00:22:46,480
it

00:22:43,360 --> 00:22:49,039
and this is unidirectional data flow

00:22:46,480 --> 00:22:50,320
and the idea is that the data is flowing

00:22:49,039 --> 00:22:53,120
through the program from thread to

00:22:50,320 --> 00:22:54,960
thread in only one direction

00:22:53,120 --> 00:22:56,559
now at first glance it's like great this

00:22:54,960 --> 00:22:58,000
is safe there's no cycles but

00:22:56,559 --> 00:23:00,400
uh there are some tricks and we'll go

00:22:58,000 --> 00:23:02,080
through them now you have to be careful

00:23:00,400 --> 00:23:04,240
the general approach is thread one is

00:23:02,080 --> 00:23:07,039
reading external states we have this get

00:23:04,240 --> 00:23:08,559
external state function that has sensors

00:23:07,039 --> 00:23:09,280
one and two this reading it puts them

00:23:08,559 --> 00:23:12,559
into some

00:23:09,280 --> 00:23:14,400
local variables s1 and s2 and uh

00:23:12,559 --> 00:23:15,840
it needs to take that state and do some

00:23:14,400 --> 00:23:17,360
kind of reduction on it maybe convert it

00:23:15,840 --> 00:23:18,720
to standard units

00:23:17,360 --> 00:23:20,559
based on some calibration that's been

00:23:18,720 --> 00:23:22,720
done in the past so we have reduced

00:23:20,559 --> 00:23:23,760
state one and reduced state to do that

00:23:22,720 --> 00:23:25,840
and we're going to talk about the

00:23:23,760 --> 00:23:26,960
properties that those two functions have

00:23:25,840 --> 00:23:29,919
to provide

00:23:26,960 --> 00:23:31,679
uh in a moment thread two meanwhile

00:23:29,919 --> 00:23:33,440
asynchronous is picking up the most

00:23:31,679 --> 00:23:34,799
recent measurements

00:23:33,440 --> 00:23:36,640
they might be measurements from two

00:23:34,799 --> 00:23:38,000
different loops and that's okay they're

00:23:36,640 --> 00:23:39,520
just measurements they happen at some

00:23:38,000 --> 00:23:41,120
time there's delay from the outside

00:23:39,520 --> 00:23:42,559
world through the sensor hardware and

00:23:41,120 --> 00:23:43,679
through drivers and whatever we finally

00:23:42,559 --> 00:23:47,440
get the stuff

00:23:43,679 --> 00:23:47,440
so it's it's

00:23:48,320 --> 00:23:51,360
strangely ordered anyway just due to the

00:23:50,240 --> 00:23:53,440
laws of physics

00:23:51,360 --> 00:23:54,559
so a little more ordering is not a

00:23:53,440 --> 00:23:55,840
problem but what we're going to do is

00:23:54,559 --> 00:23:56,320
we're going to take those two values we

00:23:55,840 --> 00:23:57,919
read

00:23:56,320 --> 00:23:59,919
and we're going to compute a control

00:23:57,919 --> 00:24:01,760
action and that's what the ctl

00:23:59,919 --> 00:24:03,679
function is so all three of the

00:24:01,760 --> 00:24:05,760
functions reduce state 1 reduce state 2

00:24:03,679 --> 00:24:07,440
and compute ctl

00:24:05,760 --> 00:24:08,799
all have to be coded carefully you've

00:24:07,440 --> 00:24:11,919
got that little pure function

00:24:08,799 --> 00:24:12,799
thing we'll talk about that now what

00:24:11,919 --> 00:24:14,159
that means

00:24:12,799 --> 00:24:16,799
these have to be pure functions they

00:24:14,159 --> 00:24:19,600
can't go around changing

00:24:16,799 --> 00:24:20,400
shared variables obviously but they also

00:24:19,600 --> 00:24:22,000
have to be

00:24:20,400 --> 00:24:24,000
pure and complete in the sense that no

00:24:22,000 --> 00:24:25,120
matter what bit pattern comes into their

00:24:24,000 --> 00:24:27,039
arguments

00:24:25,120 --> 00:24:28,159
they have to produce a definite value

00:24:27,039 --> 00:24:31,120
that does not

00:24:28,159 --> 00:24:32,720
cannot possibly introduce undefined

00:24:31,120 --> 00:24:35,600
behavior

00:24:32,720 --> 00:24:37,279
all right no divide by zeros no stores

00:24:35,600 --> 00:24:38,000
off of the ends arrays nothing like that

00:24:37,279 --> 00:24:39,520
it has to be

00:24:38,000 --> 00:24:41,520
written very carefully to avoid any

00:24:39,520 --> 00:24:42,559
possible any trace of a possibility of

00:24:41,520 --> 00:24:45,279
unknown behavior

00:24:42,559 --> 00:24:47,279
has to be a pure function and then once

00:24:45,279 --> 00:24:49,200
we computed this thing very carefully

00:24:47,279 --> 00:24:50,720
from the sensor inputs and thread one

00:24:49,200 --> 00:24:51,039
through the reduced state reduction and

00:24:50,720 --> 00:24:52,720
then

00:24:51,039 --> 00:24:54,320
across shared memory to thread two

00:24:52,720 --> 00:24:56,240
competing control action

00:24:54,320 --> 00:24:57,679
we use extra the stat external control

00:24:56,240 --> 00:25:00,159
function to

00:24:57,679 --> 00:25:01,919
update the external state to provide

00:25:00,159 --> 00:25:04,880
whatever control is needed

00:25:01,919 --> 00:25:05,840
um okay um there are some other examples

00:25:04,880 --> 00:25:08,960
of pipelines

00:25:05,840 --> 00:25:10,640
uh but again uh for the computations of

00:25:08,960 --> 00:25:12,720
these values you have to be very careful

00:25:10,640 --> 00:25:15,840
because if you have undefined behavior

00:25:12,720 --> 00:25:15,840
uh fun things can happen

00:25:16,720 --> 00:25:21,039
okay at this point i'm going to hand it

00:25:19,360 --> 00:25:23,760
back to hans who's going to talk about

00:25:21,039 --> 00:25:26,159
more about what makes these idioms safe

00:25:23,760 --> 00:25:30,880
and unsafe

00:25:26,159 --> 00:25:33,919
um right so what makes something unsafe

00:25:30,880 --> 00:25:36,400
um usually what makes uh

00:25:33,919 --> 00:25:37,919
what makes idioms unsafe or what we

00:25:36,400 --> 00:25:41,360
already illustrated here

00:25:37,919 --> 00:25:41,919
is that uh we load an atomic value with

00:25:41,360 --> 00:25:44,159
a

00:25:41,919 --> 00:25:46,080
relaxed load and then we rely on that

00:25:44,159 --> 00:25:49,039
value for correctness

00:25:46,080 --> 00:25:51,200
um either to determine the values

00:25:49,039 --> 00:25:53,039
thought into another atomic so as

00:25:51,200 --> 00:25:55,279
in the simple example where we just copy

00:25:53,039 --> 00:25:58,080
one atomic variable to the other

00:25:55,279 --> 00:25:58,400
or we rely on the value on the value we

00:25:58,080 --> 00:26:01,520
get

00:25:58,400 --> 00:26:04,240
to avoid disastrous misbehavior and uh

00:26:01,520 --> 00:26:06,559
paul also just touched on that uh

00:26:04,240 --> 00:26:06,960
usually we get into the second situation

00:26:06,559 --> 00:26:09,840
by

00:26:06,960 --> 00:26:12,720
potentially allowing undefined behavior

00:26:09,840 --> 00:26:15,279
as a result of a misspeculated value

00:26:12,720 --> 00:26:15,279
next slide

00:26:16,480 --> 00:26:25,840
um we do we do have

00:26:19,840 --> 00:26:28,720
a question i'm sorry um

00:26:25,840 --> 00:26:30,400
i saw that actually let's postpone that

00:26:28,720 --> 00:26:32,080
question to the end i think because

00:26:30,400 --> 00:26:33,600
we'll have a bunch of examples in the

00:26:32,080 --> 00:26:35,919
talk here which i think

00:26:33,600 --> 00:26:36,960
it will largely answer that question but

00:26:35,919 --> 00:26:40,640
yes thank you

00:26:36,960 --> 00:26:42,640
um so this actually turns out to be

00:26:40,640 --> 00:26:45,760
surprisingly common

00:26:42,640 --> 00:26:48,000
uh mostly due to relaxed loads that can

00:26:45,760 --> 00:26:49,039
lead to undefined behavior if they need

00:26:48,000 --> 00:26:52,559
a bad value

00:26:49,039 --> 00:26:54,159
and generally people

00:26:52,559 --> 00:26:56,159
don't think of them as potentially

00:26:54,159 --> 00:26:57,279
loading a bad value and arguably in

00:26:56,159 --> 00:26:59,840
practice they can't

00:26:57,279 --> 00:27:01,520
there's a lot of code that actually uses

00:26:59,840 --> 00:27:02,720
this pattern and practice and it works

00:27:01,520 --> 00:27:05,360
just fine

00:27:02,720 --> 00:27:06,240
on the other hand it's not correct they

00:27:05,360 --> 00:27:08,640
call in

00:27:06,240 --> 00:27:10,640
c plus plus 20. and as a result it's

00:27:08,640 --> 00:27:11,840
very difficult to reason about and we

00:27:10,640 --> 00:27:13,840
certainly don't know how to prove

00:27:11,840 --> 00:27:18,240
theorems about it

00:27:13,840 --> 00:27:20,640
next slide so in general the

00:27:18,240 --> 00:27:22,159
the problematic idioms all have this

00:27:20,640 --> 00:27:25,360
pattern

00:27:22,159 --> 00:27:27,039
we end up doing a relaxed load from an

00:27:25,360 --> 00:27:29,840
atomic variable

00:27:27,039 --> 00:27:30,559
and then if we end up getting a bad

00:27:29,840 --> 00:27:33,520
value

00:27:30,559 --> 00:27:34,159
we end up exhibiting bad behavior and

00:27:33,520 --> 00:27:36,399
the problem

00:27:34,159 --> 00:27:38,000
is if we combine two of these together

00:27:36,399 --> 00:27:41,120
in two different threads

00:27:38,000 --> 00:27:45,600
we again get the can get this funny

00:27:41,120 --> 00:27:48,559
um cross reading behavior where

00:27:45,600 --> 00:27:49,760
we're reading we're reading the relaxed

00:27:48,559 --> 00:27:52,240
atomic value

00:27:49,760 --> 00:27:54,480
from something that was produced by the

00:27:52,240 --> 00:27:56,799
bad behavior and the other third

00:27:54,480 --> 00:27:58,720
and thus again if we somehow managed to

00:27:56,799 --> 00:28:00,960
misspeculate

00:27:58,720 --> 00:28:03,840
the bad behavior can end up producing

00:28:00,960 --> 00:28:06,880
the exactly the value that we had and we

00:28:03,840 --> 00:28:08,720
can subsequently confirm the speculation

00:28:06,880 --> 00:28:10,480
convincing ourselves that the result is

00:28:08,720 --> 00:28:13,840
potentially correct

00:28:10,480 --> 00:28:15,679
uh something which doesn't happen and

00:28:13,840 --> 00:28:17,360
which doesn't generally happen in real

00:28:15,679 --> 00:28:19,919
life except in the

00:28:17,360 --> 00:28:21,679
sort of read from unexecuted branch kind

00:28:19,919 --> 00:28:23,840
of sense

00:28:21,679 --> 00:28:25,679
but it's very difficult to preclude in

00:28:23,840 --> 00:28:27,120
the specification and very difficult to

00:28:25,679 --> 00:28:31,360
reason about

00:28:27,120 --> 00:28:31,760
next slide so this is the first slide

00:28:31,360 --> 00:28:34,559
that

00:28:31,760 --> 00:28:36,799
kind of answers uh the the question

00:28:34,559 --> 00:28:39,120
about what's this actually good for

00:28:36,799 --> 00:28:40,799
so this is actually an idiom that's used

00:28:39,120 --> 00:28:42,720
in practice but that we don't really

00:28:40,799 --> 00:28:45,840
know how to reason about

00:28:42,720 --> 00:28:49,520
um so what we're doing here is we're

00:28:45,840 --> 00:28:51,360
lazily initializing the atomic values x

00:28:49,520 --> 00:28:55,600
and y

00:28:51,360 --> 00:28:57,440
uh we're doing this by reading x

00:28:55,600 --> 00:28:59,520
checking whether it has some special

00:28:57,440 --> 00:29:02,000
value that indicates it hasn't yet been

00:28:59,520 --> 00:29:04,960
initialized here i use zero

00:29:02,000 --> 00:29:06,640
and then if it has been um if it hasn't

00:29:04,960 --> 00:29:09,440
been initialized

00:29:06,640 --> 00:29:09,760
it will initialize it by just computing

00:29:09,440 --> 00:29:13,039
just

00:29:09,760 --> 00:29:14,960
evaluating some pure function which is

00:29:13,039 --> 00:29:15,760
guaranteed to always produce the same

00:29:14,960 --> 00:29:17,679
result

00:29:15,760 --> 00:29:19,039
so it doesn't matter if i evaluate it

00:29:17,679 --> 00:29:21,360
more than once

00:29:19,039 --> 00:29:23,760
and using that as the result as the

00:29:21,360 --> 00:29:25,679
value of x and assigning the result back

00:29:23,760 --> 00:29:28,000
to x

00:29:25,679 --> 00:29:30,240
in general for this sort of lazy

00:29:28,000 --> 00:29:32,000
initialization we need stronger memory

00:29:30,240 --> 00:29:34,399
ordering and we need to be more careful

00:29:32,000 --> 00:29:36,799
but this is a really special case

00:29:34,399 --> 00:29:38,640
in which we're initializing a simple

00:29:36,799 --> 00:29:40,720
scalar value

00:29:38,640 --> 00:29:42,399
in an item potent way so that if

00:29:40,720 --> 00:29:44,000
multiple fits decide they have to

00:29:42,399 --> 00:29:46,720
initialize this

00:29:44,000 --> 00:29:48,320
uh and they all do it it actually works

00:29:46,720 --> 00:29:49,120
correctly and the code has been written

00:29:48,320 --> 00:29:52,559
carefully

00:29:49,120 --> 00:29:55,200
to make that work um

00:29:52,559 --> 00:29:56,320
so in general this should be correct but

00:29:55,200 --> 00:29:59,840
the problem again

00:29:56,320 --> 00:30:03,200
is if we then test the value of r1

00:29:59,840 --> 00:30:04,399
and use it in a way so that if r1 is bad

00:30:03,200 --> 00:30:07,039
we actually introduce

00:30:04,399 --> 00:30:08,080
undefined behavior which i've done which

00:30:07,039 --> 00:30:11,039
i've indicated

00:30:08,080 --> 00:30:12,640
here by actually doing something

00:30:11,039 --> 00:30:16,159
concretely bad

00:30:12,640 --> 00:30:18,080
which is assigning assigning a random

00:30:16,159 --> 00:30:19,360
value to a random location

00:30:18,080 --> 00:30:22,159
which is something that we believe

00:30:19,360 --> 00:30:24,720
undefined behavior can do

00:30:22,159 --> 00:30:25,679
then i again can get into this situation

00:30:24,720 --> 00:30:28,799
where

00:30:25,679 --> 00:30:31,919
if i have two threads each performing

00:30:28,799 --> 00:30:33,760
one of these lazy initializations

00:30:31,919 --> 00:30:35,039
and each potentially encountering

00:30:33,760 --> 00:30:36,559
undefined behavior

00:30:35,039 --> 00:30:38,159
they're not even touching the same

00:30:36,559 --> 00:30:40,720
shared variable here

00:30:38,159 --> 00:30:42,080
but they can implicitly touch the the

00:30:40,720 --> 00:30:45,520
other shared variable

00:30:42,080 --> 00:30:47,600
by undefined behavior that stores to the

00:30:45,520 --> 00:30:48,559
lazily initialized variable in the other

00:30:47,600 --> 00:30:51,520
thread

00:30:48,559 --> 00:30:53,760
so as a result of that i can get the

00:30:51,520 --> 00:30:54,960
same bad pattern here and again this is

00:30:53,760 --> 00:30:57,440
the first of several

00:30:54,960 --> 00:30:59,200
of a couple of examples that i actually

00:30:57,440 --> 00:31:00,480
used in practice but that we don't we

00:30:59,200 --> 00:31:02,159
don't know how to reason about

00:31:00,480 --> 00:31:04,080
and we would really like to be able to

00:31:02,159 --> 00:31:07,519
do that and

00:31:04,080 --> 00:31:11,679
next slide okay the next

00:31:07,519 --> 00:31:13,360
example is one uh that i believe is also

00:31:11,679 --> 00:31:16,559
used in practice quite a bit

00:31:13,360 --> 00:31:20,159
and this is implementing a reentry mutex

00:31:16,559 --> 00:31:22,080
a mutex that you can you can acquire

00:31:20,159 --> 00:31:23,760
repeatedly in the same thread

00:31:22,080 --> 00:31:27,600
without that law deadlocking with

00:31:23,760 --> 00:31:30,159
yourself on top of an existing mutex

00:31:27,600 --> 00:31:32,559
so the implementation strategy here is

00:31:30,159 --> 00:31:35,600
that we have a simple um

00:31:32,559 --> 00:31:38,559
a plane existing mutex uh

00:31:35,600 --> 00:31:40,880
which we acquired at the outer level and

00:31:38,559 --> 00:31:42,960
then if we acquire this mutex try to

00:31:40,880 --> 00:31:45,600
acquire this mutex again

00:31:42,960 --> 00:31:47,200
we'll carefully avoid locking this again

00:31:45,600 --> 00:31:49,279
and just keep track of how many times

00:31:47,200 --> 00:31:51,919
we've acquired the mutex

00:31:49,279 --> 00:31:53,840
in order to do this in addition to the

00:31:51,919 --> 00:31:55,519
the mutex itself

00:31:53,840 --> 00:31:58,240
we have to keep track of the owner of

00:31:55,519 --> 00:32:00,880
the mutex in an atomic

00:31:58,240 --> 00:32:02,000
and we keep track of the count the

00:32:00,880 --> 00:32:03,840
number of times

00:32:02,000 --> 00:32:06,000
the the mutex is held it's actually a

00:32:03,840 --> 00:32:07,760
number of times minus one that the the

00:32:06,000 --> 00:32:11,120
mutex is held

00:32:07,760 --> 00:32:14,640
uh in the latter is is held in a simple

00:32:11,120 --> 00:32:18,000
integer which is protected by the mutex

00:32:14,640 --> 00:32:20,080
the the owner field is scattered in kind

00:32:18,000 --> 00:32:25,279
of a complicated way

00:32:20,080 --> 00:32:27,279
in that it's we can modify it

00:32:25,279 --> 00:32:29,679
we modify it only while holding the

00:32:27,279 --> 00:32:31,120
mutex but we can read it without holding

00:32:29,679 --> 00:32:34,799
the mutex

00:32:31,120 --> 00:32:38,320
and and we guarantee that it's only

00:32:34,799 --> 00:32:42,159
the um the honor field is

00:32:38,320 --> 00:32:45,840
only changed to a particular

00:32:42,159 --> 00:32:49,039
thread red id and away from that fed id

00:32:45,840 --> 00:32:52,159
by that fed so no other that can change

00:32:49,039 --> 00:32:55,600
it can change the value to or away from

00:32:52,159 --> 00:32:58,240
uh from my that id

00:32:55,600 --> 00:32:58,240
next slide

00:32:59,200 --> 00:33:03,360
so the way the acquisition of such a

00:33:01,760 --> 00:33:06,559
lock works

00:33:03,360 --> 00:33:08,960
um is is basically

00:33:06,559 --> 00:33:11,120
as i've indicated here so if i try to

00:33:08,960 --> 00:33:14,240
acquire a lock i first have to get my

00:33:11,120 --> 00:33:17,360
my thread id i then check

00:33:14,240 --> 00:33:20,000
um is is the owner me

00:33:17,360 --> 00:33:21,919
do i already own the lock and that's

00:33:20,000 --> 00:33:23,519
safe to do without holding the lock

00:33:21,919 --> 00:33:27,360
because no other thread can

00:33:23,519 --> 00:33:30,399
invalidate the truth of that test

00:33:27,360 --> 00:33:31,679
another thread is able to change the

00:33:30,399 --> 00:33:35,279
owner but not

00:33:31,679 --> 00:33:37,120
to me or away from me if i already own

00:33:35,279 --> 00:33:38,399
the lock i just increment the count

00:33:37,120 --> 00:33:40,000
otherwise i do something more

00:33:38,399 --> 00:33:41,279
complicated i actually acquired the

00:33:40,000 --> 00:33:45,840
mutex

00:33:41,279 --> 00:33:48,559
and then i i saw the owner field

00:33:45,840 --> 00:33:48,559
next slide

00:33:49,440 --> 00:33:53,039
so this has the same sort of problem

00:33:51,360 --> 00:33:55,760
fundamentally although this is more

00:33:53,039 --> 00:33:59,679
subtle in this case

00:33:55,760 --> 00:34:03,760
the problem here is that if

00:33:59,679 --> 00:34:06,799
again if i test whether the owner is me

00:34:03,760 --> 00:34:08,960
i'm doing a relaxed load i which

00:34:06,799 --> 00:34:11,280
i sort of abbreviated the relaxed load

00:34:08,960 --> 00:34:13,200
and the test into one statement here

00:34:11,280 --> 00:34:15,040
i do a relaxed load of owner and check

00:34:13,200 --> 00:34:18,839
whether it's me

00:34:15,040 --> 00:34:21,679
if somehow i end up

00:34:18,839 --> 00:34:23,359
misspeculating uh

00:34:21,679 --> 00:34:25,119
so what i've indicated here in the

00:34:23,359 --> 00:34:28,079
particular execution

00:34:25,119 --> 00:34:28,480
uh thread one i'm in a case with that

00:34:28,079 --> 00:34:31,440
one

00:34:28,480 --> 00:34:32,960
already holds the lock and does nothing

00:34:31,440 --> 00:34:35,919
nothing special

00:34:32,960 --> 00:34:36,560
if that two is or misspeculates that

00:34:35,919 --> 00:34:39,919
it's

00:34:36,560 --> 00:34:43,200
that the owner field is actually me

00:34:39,919 --> 00:34:46,960
um what will happen is

00:34:43,200 --> 00:34:50,159
so both of them end up

00:34:46,960 --> 00:34:52,639
end up incrementing the count uh i've

00:34:50,159 --> 00:34:54,560
indicated in the critical section here

00:34:52,639 --> 00:34:56,639
as a result of this i will end up with

00:34:54,560 --> 00:34:57,520
the with two threads in the critical

00:34:56,639 --> 00:35:00,079
section

00:34:57,520 --> 00:35:00,720
i've made very explicit here that that

00:35:00,079 --> 00:35:02,480
results

00:35:00,720 --> 00:35:04,480
results in effectively undefined

00:35:02,480 --> 00:35:05,280
behavior in most cases i've done this

00:35:04,480 --> 00:35:07,839
here

00:35:05,280 --> 00:35:09,920
by incrementing some variable x which is

00:35:07,839 --> 00:35:12,240
protected by the mutex

00:35:09,920 --> 00:35:13,440
and then if i see that more more than

00:35:12,240 --> 00:35:15,760
one thread is in there

00:35:13,440 --> 00:35:16,640
i do something bad i start a random

00:35:15,760 --> 00:35:18,160
location

00:35:16,640 --> 00:35:20,160
sort of reflecting the potential

00:35:18,160 --> 00:35:22,400
undefined behavior here

00:35:20,160 --> 00:35:23,280
so if i get two threads in this critical

00:35:22,400 --> 00:35:26,240
section

00:35:23,280 --> 00:35:28,240
what can actually happen here is that

00:35:26,240 --> 00:35:31,440
the

00:35:28,240 --> 00:35:33,680
thread one will end up doing a random

00:35:31,440 --> 00:35:36,000
assignment a random location

00:35:33,680 --> 00:35:36,800
which can end up assigning to the owner

00:35:36,000 --> 00:35:38,960
field

00:35:36,800 --> 00:35:39,839
which will end up satisfying the

00:35:38,960 --> 00:35:42,400
speculation

00:35:39,839 --> 00:35:44,480
in thread two thus convincing fed too

00:35:42,400 --> 00:35:47,280
that its speculation was correct and it

00:35:44,480 --> 00:35:49,119
was okay to just go ahead and execute

00:35:47,280 --> 00:35:50,800
so again this is a more complicated

00:35:49,119 --> 00:35:54,079
example in which

00:35:50,800 --> 00:35:54,480
i have the same kinds of issue kinds of

00:35:54,079 --> 00:35:57,119
issue

00:35:54,480 --> 00:35:57,760
essentially i have a relaxed load i test

00:35:57,119 --> 00:36:00,320
it

00:35:57,760 --> 00:36:02,240
i act on that and i get bad behavior as

00:36:00,320 --> 00:36:03,599
a result which ends up satisfying

00:36:02,240 --> 00:36:06,160
speculation

00:36:03,599 --> 00:36:08,000
so in slick c plus plus 20 without the

00:36:06,160 --> 00:36:12,720
out of thin air restriction

00:36:08,000 --> 00:36:15,040
i again can get this this bad execution

00:36:12,720 --> 00:36:15,040
um

00:36:15,760 --> 00:36:21,280
okay uh there's a there's another

00:36:19,359 --> 00:36:23,599
question here

00:36:21,280 --> 00:36:24,960
uh so why should i mess with such

00:36:23,599 --> 00:36:27,280
difficult code

00:36:24,960 --> 00:36:28,720
it's very difficult to test how can i

00:36:27,280 --> 00:36:32,079
test this code

00:36:28,720 --> 00:36:34,480
and this is kind of our problem uh

00:36:32,079 --> 00:36:36,320
this is indeed difficult to test well a

00:36:34,480 --> 00:36:37,599
lot of concurrent code is difficult to

00:36:36,320 --> 00:36:39,680
test

00:36:37,599 --> 00:36:41,359
you may want to avoid this kind of code

00:36:39,680 --> 00:36:43,520
on the other hand there are a number of

00:36:41,359 --> 00:36:44,480
cases where we actually rely on it

00:36:43,520 --> 00:36:47,599
inherently i

00:36:44,480 --> 00:36:47,839
i think the the next slide actually i

00:36:47,599 --> 00:36:50,160
mean

00:36:47,839 --> 00:36:52,160
has an example of where we pretty much

00:36:50,160 --> 00:36:54,560
have to rely on that today

00:36:52,160 --> 00:36:55,920
and empirically such code works and it

00:36:54,560 --> 00:36:58,640
speeds up

00:36:55,920 --> 00:36:59,680
uh its potentially speeds up programs

00:36:58,640 --> 00:37:01,839
significantly

00:36:59,680 --> 00:37:03,839
since the use of memory order relaxed

00:37:01,839 --> 00:37:06,240
may avoid fences

00:37:03,839 --> 00:37:08,000
on the critical path and it this may be

00:37:06,240 --> 00:37:09,680
a huge performance increase

00:37:08,000 --> 00:37:11,839
whether or not you want to use this is

00:37:09,680 --> 00:37:13,520
up to you paul will talk more about

00:37:11,839 --> 00:37:16,560
examples where in fact

00:37:13,520 --> 00:37:22,160
it's uh memory order relaxed

00:37:16,560 --> 00:37:25,359
is perfectly safe to use next

00:37:22,160 --> 00:37:28,079
uh so other important uh

00:37:25,359 --> 00:37:29,440
example other important code examples

00:37:28,079 --> 00:37:32,880
that are not

00:37:29,440 --> 00:37:35,440
safe in c plus plus 20

00:37:32,880 --> 00:37:38,079
the one that i've dealt with in the past

00:37:35,440 --> 00:37:41,520
is if we want to implement a concurrent

00:37:38,079 --> 00:37:44,640
garbage collector for example for java

00:37:41,520 --> 00:37:47,520
very often it's the case that

00:37:44,640 --> 00:37:49,280
well it's typically the case that since

00:37:47,520 --> 00:37:53,359
the concurrent garbage collector

00:37:49,280 --> 00:37:54,720
needs to needs to read pointer values

00:37:53,359 --> 00:37:56,640
that are being

00:37:54,720 --> 00:37:59,680
that are being changed by the client

00:37:56,640 --> 00:38:02,000
code and i need to make sure that

00:37:59,680 --> 00:38:03,839
those concurrent accesses are safe so

00:38:02,000 --> 00:38:05,839
the pointer values in the heap there

00:38:03,839 --> 00:38:08,640
essentially need to be treated as

00:38:05,839 --> 00:38:09,599
as atomic accesses and i need to make

00:38:08,640 --> 00:38:12,480
those relaxed

00:38:09,599 --> 00:38:13,920
because otherwise my java code runs way

00:38:12,480 --> 00:38:16,720
too slowly

00:38:13,920 --> 00:38:19,040
because i end up in inserting basically

00:38:16,720 --> 00:38:22,079
ordering constraints offenses all over

00:38:19,040 --> 00:38:24,240
in the java client code so this is one

00:38:22,079 --> 00:38:26,160
example where i where i don't think

00:38:24,240 --> 00:38:28,079
there's actually a way out of this kind

00:38:26,160 --> 00:38:30,839
of code

00:38:28,079 --> 00:38:33,040
another interesting example is sort of

00:38:30,839 --> 00:38:36,000
is what's called

00:38:33,040 --> 00:38:36,800
chaotic relaxation uh numerical

00:38:36,000 --> 00:38:39,280
algorithms

00:38:36,800 --> 00:38:40,800
that basically rely on just reading the

00:38:39,280 --> 00:38:44,240
most recent value

00:38:40,800 --> 00:38:45,359
in a the most recent floating point

00:38:44,240 --> 00:38:48,240
value

00:38:45,359 --> 00:38:50,079
and in a particular location without any

00:38:48,240 --> 00:38:51,599
sort of synchronization between them

00:38:50,079 --> 00:38:53,520
sometimes you can

00:38:51,599 --> 00:38:55,520
you can show from a numerical analysis

00:38:53,520 --> 00:38:59,280
perspective that's fine

00:38:55,520 --> 00:39:00,960
on the other hand again as a result of

00:38:59,280 --> 00:39:04,000
with the absence of an out of thin air

00:39:00,960 --> 00:39:07,040
prohibition we can get scenarios

00:39:04,000 --> 00:39:09,040
in which basically we end up getting

00:39:07,040 --> 00:39:11,040
an end result somewhere more or less

00:39:09,040 --> 00:39:14,079
randomly through speculation and then

00:39:11,040 --> 00:39:15,520
that ends up propagating everywhere so

00:39:14,079 --> 00:39:17,359
there are these theoretical

00:39:15,520 --> 00:39:19,200
scenarios here in which that doesn't

00:39:17,359 --> 00:39:22,400
work

00:39:19,200 --> 00:39:22,400
um next slide

00:39:22,560 --> 00:39:28,240
okay um no one question we have

00:39:25,920 --> 00:39:30,400
not used rancher mutex's examples in

00:39:28,240 --> 00:39:33,359
user space or kernel space

00:39:30,400 --> 00:39:34,560
um the case where you use this uh is in

00:39:33,359 --> 00:39:36,800
cases where you have

00:39:34,560 --> 00:39:38,480
where you want to be able to have a

00:39:36,800 --> 00:39:39,040
piece of common code that does some

00:39:38,480 --> 00:39:40,960
operation

00:39:39,040 --> 00:39:42,079
requiring the lock and you want to be

00:39:40,960 --> 00:39:43,760
able to call it

00:39:42,079 --> 00:39:45,440
uh whether or not you already hold that

00:39:43,760 --> 00:39:48,320
lock um

00:39:45,440 --> 00:39:50,240
and that's a pattern that happens fairly

00:39:48,320 --> 00:39:50,640
often both in kernel and user space it's

00:39:50,240 --> 00:39:53,599
not

00:39:50,640 --> 00:39:54,720
um not dominant um it's not a huge

00:39:53,599 --> 00:39:57,680
fashion but it does

00:39:54,720 --> 00:39:58,480
but does happen and we also have a

00:39:57,680 --> 00:40:00,000
repeat of

00:39:58,480 --> 00:40:03,599
why should i mess up with difficult code

00:40:00,000 --> 00:40:03,599
how can i test that code

00:40:04,400 --> 00:40:09,440
it's uh concurrency isn't necessarily

00:40:07,520 --> 00:40:12,800
easy

00:40:09,440 --> 00:40:15,920
and uh the

00:40:12,800 --> 00:40:17,440
other point is uh what we're saying here

00:40:15,920 --> 00:40:20,400
is that you need to use

00:40:17,440 --> 00:40:20,960
known good patterns if you choose to

00:40:20,400 --> 00:40:23,520
just hack

00:40:20,960 --> 00:40:25,680
code together concurrent code together

00:40:23,520 --> 00:40:28,319
you're going to have problems

00:40:25,680 --> 00:40:29,599
and even sequential consistency will not

00:40:28,319 --> 00:40:31,680
save you

00:40:29,599 --> 00:40:33,280
okay so if you're if you're doing

00:40:31,680 --> 00:40:37,359
concurrency unless you're following

00:40:33,280 --> 00:40:39,599
known good well-tested guidelines

00:40:37,359 --> 00:40:41,040
yes it will be very difficult uh that's

00:40:39,599 --> 00:40:43,200
something that hans and i have done

00:40:41,040 --> 00:40:45,200
successfully for a very long time

00:40:43,200 --> 00:40:46,560
but i'll speak for myself i know that

00:40:45,200 --> 00:40:46,960
i've messed it up occasionally and had

00:40:46,560 --> 00:40:50,319
to

00:40:46,960 --> 00:40:52,800
work hard to fix it um

00:40:50,319 --> 00:40:54,480
why would we do this uh because in some

00:40:52,800 --> 00:40:55,200
cases it gives you huge performance

00:40:54,480 --> 00:40:56,640
increases

00:40:55,200 --> 00:40:58,960
there are cases in the linux kernel

00:40:56,640 --> 00:41:00,960
where uh this kind of code has gotten

00:40:58,960 --> 00:41:03,040
multiple orders of magnitude speed up

00:41:00,960 --> 00:41:06,480
on something so i mean it's that's not

00:41:03,040 --> 00:41:08,720
something you for that kind of speed up

00:41:06,480 --> 00:41:10,960
i'm willing to invest some serious time

00:41:08,720 --> 00:41:14,160
and effort and some serious validation

00:41:10,960 --> 00:41:16,480
in fact my current employer and i

00:41:14,160 --> 00:41:17,920
would guess hans employer as well for

00:41:16,480 --> 00:41:18,400
certain sort of things would be willing

00:41:17,920 --> 00:41:20,319
to

00:41:18,400 --> 00:41:22,240
pay a huge amount to get even one

00:41:20,319 --> 00:41:24,160
percent improvement

00:41:22,240 --> 00:41:26,160
uh given the number of machines that

00:41:24,160 --> 00:41:26,880
both hans's employer my employers are

00:41:26,160 --> 00:41:30,720
rumored to

00:41:26,880 --> 00:41:34,720
have operating so

00:41:30,720 --> 00:41:36,319
yeah don't use it if you don't need it

00:41:34,720 --> 00:41:38,240
you've got that point exactly right if

00:41:36,319 --> 00:41:39,760
you can keep it simple if you can just

00:41:38,240 --> 00:41:40,880
write single threaded code if that works

00:41:39,760 --> 00:41:44,000
for you

00:41:40,880 --> 00:41:46,000
use single threaded code be happy if you

00:41:44,000 --> 00:41:47,599
can use pure locking

00:41:46,000 --> 00:41:49,680
and not have to doing this fancy stuff

00:41:47,599 --> 00:41:51,200
do that be happy get your job done get

00:41:49,680 --> 00:41:55,359
on with life

00:41:51,200 --> 00:41:57,280
but there are times when you have to

00:41:55,359 --> 00:42:00,480
go beyond that and uh double check

00:41:57,280 --> 00:42:04,400
locking is one example of this

00:42:00,480 --> 00:42:06,319
so what we're doing here is uh

00:42:04,400 --> 00:42:08,079
uh and this is a case where this is safe

00:42:06,319 --> 00:42:09,599
even in strict c plus plus

00:42:08,079 --> 00:42:11,599
and if something's used really heavily

00:42:09,599 --> 00:42:14,319
and it's provably safe

00:42:11,599 --> 00:42:15,200
so uh we've got this x in it we load it

00:42:14,319 --> 00:42:18,319
and we use the memory

00:42:15,200 --> 00:42:21,440
to require we do a lock guard

00:42:18,319 --> 00:42:23,280
to uh do mutual exclusion and then we

00:42:21,440 --> 00:42:27,119
repeat the load with a relaxed

00:42:23,280 --> 00:42:30,720
okay and then we initialize it and then

00:42:27,119 --> 00:42:30,720
we store the initialized value

00:42:31,440 --> 00:42:37,119
so this

00:42:35,280 --> 00:42:38,800
is safe and it's fairly easy to prove

00:42:37,119 --> 00:42:41,359
it's safe we have an acquire

00:42:38,800 --> 00:42:42,160
so the stuff that happens after that

00:42:41,359 --> 00:42:45,200
load can't

00:42:42,160 --> 00:42:46,720
reorder then we acquire lock once we

00:42:45,200 --> 00:42:49,920
acquire that lock

00:42:46,720 --> 00:42:52,079
uh the only stores to anything in x or

00:42:49,920 --> 00:42:53,920
related to x

00:42:52,079 --> 00:42:56,000
are with that lock held so there can't

00:42:53,920 --> 00:42:57,920
be any bracing accesses

00:42:56,000 --> 00:42:59,599
and then once we release the lock the

00:42:57,920 --> 00:43:02,000
other people will come in see that

00:42:59,599 --> 00:43:03,280
accident load is accident is already in

00:43:02,000 --> 00:43:05,200
thing and they'll go by and do their

00:43:03,280 --> 00:43:08,480
business and life will be fine

00:43:05,200 --> 00:43:11,920
and that will avoid uh the the uh

00:43:08,480 --> 00:43:12,640
possible confusion undefined behavior

00:43:11,920 --> 00:43:14,800
that would occur

00:43:12,640 --> 00:43:16,560
if we let them run concurrently now this

00:43:14,800 --> 00:43:17,119
is a this is the more complicated

00:43:16,560 --> 00:43:18,960
example

00:43:17,119 --> 00:43:20,880
a version of the example hans gave

00:43:18,960 --> 00:43:22,640
earlier all right

00:43:20,880 --> 00:43:24,839
um where he had a single value and

00:43:22,640 --> 00:43:26,400
therefore didn't have to be quite as

00:43:24,839 --> 00:43:30,480
careful

00:43:26,400 --> 00:43:33,200
okay and and uh why bother with this

00:43:30,480 --> 00:43:35,359
well this lockguard mutex that's a

00:43:33,200 --> 00:43:37,760
global lock

00:43:35,359 --> 00:43:39,520
if in theory you know ignoring

00:43:37,760 --> 00:43:42,640
performance and scalability

00:43:39,520 --> 00:43:43,599
you could just acquire the lock and get

00:43:42,640 --> 00:43:44,800
the value out

00:43:43,599 --> 00:43:47,359
and that would work just great

00:43:44,800 --> 00:43:48,960
theoretically but you tried that on a c

00:43:47,359 --> 00:43:50,319
machine with 100 cpus where you're doing

00:43:48,960 --> 00:43:51,359
it and you'll find that you are getting

00:43:50,319 --> 00:43:52,839
much less

00:43:51,359 --> 00:43:55,040
throughput than you get out of a single

00:43:52,839 --> 00:43:57,040
cpu

00:43:55,040 --> 00:43:58,480
so if you have a case where you have

00:43:57,040 --> 00:43:59,359
something that needs to be initialized

00:43:58,480 --> 00:44:01,040
once

00:43:59,359 --> 00:44:02,960
and is used really heavily by each of a

00:44:01,040 --> 00:44:04,319
number of cpus by the way 100 is an

00:44:02,960 --> 00:44:05,200
exaggeration you could have problems

00:44:04,319 --> 00:44:08,400
with this on

00:44:05,200 --> 00:44:09,680
16 cpus um now

00:44:08,400 --> 00:44:12,000
we've seen problems with this back in

00:44:09,680 --> 00:44:15,040
the day on 16 cpus

00:44:12,000 --> 00:44:16,480
uh and this small incremental amount of

00:44:15,040 --> 00:44:21,040
complexity

00:44:16,480 --> 00:44:24,560
allows very simple code to just work

00:44:21,040 --> 00:44:25,040
um on very large systems very scalably

00:44:24,560 --> 00:44:28,319
and very

00:44:25,040 --> 00:44:31,040
very quickly let's take a look at a

00:44:28,319 --> 00:44:31,920
and this is one where uh hans mentioned

00:44:31,040 --> 00:44:32,880
i'd be talking once where you didn't

00:44:31,920 --> 00:44:35,680
have any choice

00:44:32,880 --> 00:44:37,359
this one you have a choice in theory but

00:44:35,680 --> 00:44:38,720
in practice on large machines you don't

00:44:37,359 --> 00:44:40,800
have a choice you you won't get

00:44:38,720 --> 00:44:43,359
performance and scalability you need

00:44:40,800 --> 00:44:44,880
the next example is one where even in

00:44:43,359 --> 00:44:48,480
theory you don't have a choice

00:44:44,880 --> 00:44:50,400
right a common group of algorithms

00:44:48,480 --> 00:44:52,400
use compare and swap compared exchange

00:44:50,400 --> 00:44:53,839
in this case

00:44:52,400 --> 00:44:55,760
and what's going to happen here is we're

00:44:53,839 --> 00:44:58,160
going to load a value from memory

00:44:55,760 --> 00:44:59,440
and we can use a relaxed load and the

00:44:58,160 --> 00:45:03,040
reason we can use a relaxed

00:44:59,440 --> 00:45:05,760
load is that

00:45:03,040 --> 00:45:07,599
we can uh that the compare exchange is

00:45:05,760 --> 00:45:10,960
going to check for us

00:45:07,599 --> 00:45:12,400
if we get a bad value then

00:45:10,960 --> 00:45:14,960
it's going to say well we don't have

00:45:12,400 --> 00:45:18,560
that uh that that does not match

00:45:14,960 --> 00:45:21,200
and then we can uh we can go about our

00:45:18,560 --> 00:45:23,119
business it'll fail we'll try again

00:45:21,200 --> 00:45:24,960
we have another question is memory order

00:45:23,119 --> 00:45:26,960
uh release necessary for the stores in

00:45:24,960 --> 00:45:29,200
the tech scope lock

00:45:26,960 --> 00:45:29,200
um

00:45:30,000 --> 00:45:33,599
and uh let's take let's go back and take

00:45:32,079 --> 00:45:35,280
a look here

00:45:33,599 --> 00:45:36,640
uh in fact there is a memory or store

00:45:35,280 --> 00:45:38,800
release if you look there

00:45:36,640 --> 00:45:40,960
uh x in its store is released and the

00:45:38,800 --> 00:45:43,599
reason for that is so that it will pair

00:45:40,960 --> 00:45:45,680
with the choir loads that are done later

00:45:43,599 --> 00:45:46,960
or at the same time

00:45:45,680 --> 00:45:48,240
if they're done at the same time they'll

00:45:46,960 --> 00:45:49,119
acquire the lock that'll straighten

00:45:48,240 --> 00:45:51,280
things out

00:45:49,119 --> 00:45:53,359
if somebody happens just at the time

00:45:51,280 --> 00:45:55,200
that that niche store

00:45:53,359 --> 00:45:56,800
completes it'll be a release they'll do

00:45:55,200 --> 00:45:58,319
a choir those will pair

00:45:56,800 --> 00:46:00,720
and their later accesses will be

00:45:58,319 --> 00:46:01,280
guaranteed to see the initialization of

00:46:00,720 --> 00:46:03,280
x

00:46:01,280 --> 00:46:04,640
is that does that answer the question

00:46:03,280 --> 00:46:07,200
well if not uh we'll

00:46:04,640 --> 00:46:08,400
we'll we'll come back to it so yes you

00:46:07,200 --> 00:46:10,079
do need a release

00:46:08,400 --> 00:46:12,839
you only need the one and it only needs

00:46:10,079 --> 00:46:14,960
to be on x in it not on

00:46:12,839 --> 00:46:18,240
x okay

00:46:14,960 --> 00:46:19,040
so uh back on the comparison swap uh we

00:46:18,240 --> 00:46:21,119
have a load

00:46:19,040 --> 00:46:23,040
um we might have the speculation you

00:46:21,119 --> 00:46:24,800
know the the compiler might be crazy and

00:46:23,040 --> 00:46:26,640
decided wants to speculate and guess

00:46:24,800 --> 00:46:28,640
some weird value

00:46:26,640 --> 00:46:30,000
if that happens if that weird value is

00:46:28,640 --> 00:46:32,640
not one that ever appears

00:46:30,000 --> 00:46:33,920
um then the comparison week is

00:46:32,640 --> 00:46:35,839
guaranteed to fail

00:46:33,920 --> 00:46:37,280
we'll go and reload and hopefully it

00:46:35,839 --> 00:46:40,319
will be smart enough to

00:46:37,280 --> 00:46:42,480
uh get a real value this time if it if

00:46:40,319 --> 00:46:43,920
it repeatedly speculates bogus values

00:46:42,480 --> 00:46:45,920
i will have file a bug against the

00:46:43,920 --> 00:46:48,319
compiler version

00:46:45,920 --> 00:46:49,760
to hopefully get it straightened out so

00:46:48,319 --> 00:46:51,599
this is a case again

00:46:49,760 --> 00:46:54,000
where if you want to do certain

00:46:51,599 --> 00:46:57,760
concurrent algorithms you have no choice

00:46:54,000 --> 00:46:59,920
but to rely but but to use patterns

00:46:57,760 --> 00:47:01,680
the taller it relax you could use a

00:46:59,920 --> 00:47:04,000
choir if you wanted to for that load

00:47:01,680 --> 00:47:04,880
uh but that would give you extra

00:47:04,000 --> 00:47:07,359
overhead

00:47:04,880 --> 00:47:11,440
on many systems and in some cases that

00:47:07,359 --> 00:47:14,800
overhead is unacceptable

00:47:11,440 --> 00:47:18,160
okay um moving ahead

00:47:14,800 --> 00:47:19,440
um uh we're a little behind so i'm not

00:47:18,160 --> 00:47:20,000
going to go to details of this i want to

00:47:19,440 --> 00:47:22,880
allow

00:47:20,000 --> 00:47:23,839
time for more questions this is a table

00:47:22,880 --> 00:47:26,720
copied from

00:47:23,839 --> 00:47:28,240
a updated version of this working paper

00:47:26,720 --> 00:47:29,200
which i'd hoped to have submitted

00:47:28,240 --> 00:47:31,680
yesterday but uh

00:47:29,200 --> 00:47:33,280
life got in the way and uh what we have

00:47:31,680 --> 00:47:34,800
is we have a bunch of categories we've

00:47:33,280 --> 00:47:36,559
covered some examples in each in a

00:47:34,800 --> 00:47:39,119
number of these categories

00:47:36,559 --> 00:47:40,960
okay and uh some of the categories are

00:47:39,119 --> 00:47:42,640
strict c plus plus safe that's the last

00:47:40,960 --> 00:47:45,760
column if it's got a capital y

00:47:42,640 --> 00:47:47,599
there that category as far as we know um

00:47:45,760 --> 00:47:50,720
is safe and analyzable in strict c

00:47:47,599 --> 00:47:52,240
plus plus um without the weasel wording

00:47:50,720 --> 00:47:54,079
and life is good if you can restrict

00:47:52,240 --> 00:47:56,640
yourself to that group

00:47:54,079 --> 00:47:58,079
do so your things will be easier your

00:47:56,640 --> 00:48:00,319
life will be better

00:47:58,079 --> 00:48:02,800
uh however as we've seen there are cases

00:48:00,319 --> 00:48:06,720
where we enter mutex we may need it

00:48:02,800 --> 00:48:09,440
to make it possible to make yeah you can

00:48:06,720 --> 00:48:09,760
uh if you don't supply a ranger mutex

00:48:09,440 --> 00:48:12,880
the

00:48:09,760 --> 00:48:15,040
your developers will invent one by hand

00:48:12,880 --> 00:48:16,400
and uh thus make all the mistakes that

00:48:15,040 --> 00:48:18,000
you can make so

00:48:16,400 --> 00:48:19,599
put in your primitive wrap it up have

00:48:18,000 --> 00:48:22,240
somebody do it who can do it

00:48:19,599 --> 00:48:24,160
test the bejesus out of it and release

00:48:22,240 --> 00:48:26,160
it so people can use it

00:48:24,160 --> 00:48:27,359
uh hans talked about the lacy scalar

00:48:26,160 --> 00:48:29,680
initialization

00:48:27,359 --> 00:48:31,280
uh we've also seen use of chaotic

00:48:29,680 --> 00:48:32,800
relaxation and garbage collection is an

00:48:31,280 --> 00:48:35,119
important algorithm that

00:48:32,800 --> 00:48:36,960
that is needed and one where relax

00:48:35,119 --> 00:48:40,240
accesses are important for

00:48:36,960 --> 00:48:43,119
performance reasons with that

00:48:40,240 --> 00:48:43,680
uh summary um as some of the questions

00:48:43,119 --> 00:48:46,240
have hinted

00:48:43,680 --> 00:48:46,880
i mean you guys weren't just blowing

00:48:46,240 --> 00:48:48,720
smoke

00:48:46,880 --> 00:48:50,400
using them or to relax this right here

00:48:48,720 --> 00:48:51,760
can be tricky because we don't yet know

00:48:50,400 --> 00:48:52,720
an efficient way to formally define the

00:48:51,760 --> 00:48:54,400
boundaries of

00:48:52,720 --> 00:48:56,960
out of thin air and read from untaken

00:48:54,400 --> 00:48:58,720
branch there are important use cases

00:48:56,960 --> 00:49:00,079
that are necessary in some cases that

00:48:58,720 --> 00:49:02,319
work in practice

00:49:00,079 --> 00:49:04,800
but we still don't have uh precise

00:49:02,319 --> 00:49:08,079
correctness arguments supporting them

00:49:04,800 --> 00:49:10,000
what we're doing as a stop gap uh uh for

00:49:08,079 --> 00:49:12,240
part of this is we're defining as 60

00:49:10,000 --> 00:49:14,880
plus plus 20 which allows us to

00:49:12,240 --> 00:49:16,160
precisely reason about some of them some

00:49:14,880 --> 00:49:17,760
of the important ones which is a good

00:49:16,160 --> 00:49:21,119
step forward

00:49:17,760 --> 00:49:23,680
um however uh and

00:49:21,119 --> 00:49:24,960
and there's many common relaxed usage

00:49:23,680 --> 00:49:25,920
patterns that are philosophically

00:49:24,960 --> 00:49:29,200
correct in strict c

00:49:25,920 --> 00:49:30,960
plus plus 20. um even better news i

00:49:29,200 --> 00:49:32,319
suppose or additional good news is that

00:49:30,960 --> 00:49:34,160
a lot of the other ones where we don't

00:49:32,319 --> 00:49:36,160
have a precise correctness argument

00:49:34,160 --> 00:49:37,200
uh seem to work in practice and we have

00:49:36,160 --> 00:49:39,119
good reason looking at the

00:49:37,200 --> 00:49:40,559
implementations to argue

00:49:39,119 --> 00:49:42,160
outside of the scope of the standard

00:49:40,559 --> 00:49:44,880
unfortunately that they

00:49:42,160 --> 00:49:46,400
do in fact work but we'd like to be able

00:49:44,880 --> 00:49:48,160
to bring that

00:49:46,400 --> 00:49:49,920
level of reasoning into the standard so

00:49:48,160 --> 00:49:53,119
we don't have to go inspect

00:49:49,920 --> 00:49:56,079
huge numbers of implementations

00:49:53,119 --> 00:49:56,720
so with that um if you have more

00:49:56,079 --> 00:49:59,280
questions

00:49:56,720 --> 00:50:00,000
and hans made a list of references here

00:49:59,280 --> 00:50:01,599
uh

00:50:00,000 --> 00:50:03,760
for if people want to dig deeper into

00:50:01,599 --> 00:50:03,760
this

00:50:04,160 --> 00:50:08,240
do you have more questions actually let

00:50:07,200 --> 00:50:10,240
me answer a

00:50:08,240 --> 00:50:11,920
question that wasn't asked that may have

00:50:10,240 --> 00:50:12,720
been implicit in some of the ones that

00:50:11,920 --> 00:50:14,880
were

00:50:12,720 --> 00:50:16,800
which is i think one of the motivations

00:50:14,880 --> 00:50:18,640
here is that there's potentially a huge

00:50:16,800 --> 00:50:21,200
cost difference between

00:50:18,640 --> 00:50:22,720
memory order relaxed and memory order

00:50:21,200 --> 00:50:25,920
sequentially consistent

00:50:22,720 --> 00:50:26,400
or even the acquire release ones so it's

00:50:25,920 --> 00:50:28,319
um

00:50:26,400 --> 00:50:29,920
it's not uncommon on an architecture

00:50:28,319 --> 00:50:33,119
like arm for that to be

00:50:29,920 --> 00:50:35,119
uh a couple of orders of mag one to two

00:50:33,119 --> 00:50:39,040
orders of magnitude let's say

00:50:35,119 --> 00:50:41,200
at least in the cash hit case yeah

00:50:39,040 --> 00:50:43,359
what han says is that i agree i've seen

00:50:41,200 --> 00:50:45,520
that as well if you have a fast path

00:50:43,359 --> 00:50:47,200
and uh you've made things so it works

00:50:45,520 --> 00:50:48,640
really fast that extra memory barrier

00:50:47,200 --> 00:50:49,520
can or that extra acquired load

00:50:48,640 --> 00:50:52,559
destruction

00:50:49,520 --> 00:50:54,720
can hurt you really badly uh we got

00:50:52,559 --> 00:50:56,240
another question that has my name on it

00:50:54,720 --> 00:50:57,599
looks like how's memory order consume

00:50:56,240 --> 00:50:59,839
doing

00:50:57,599 --> 00:51:01,760
uh well not well i guess is the uh

00:50:59,839 --> 00:51:03,760
shortest honest answer

00:51:01,760 --> 00:51:04,880
we do have some work going on we had a

00:51:03,760 --> 00:51:06,480
session in the

00:51:04,880 --> 00:51:08,960
linux plumbus conference a couple weeks

00:51:06,480 --> 00:51:12,559
ago where we looked at ways of uh

00:51:08,960 --> 00:51:17,280
of making this fit in better there's

00:51:12,559 --> 00:51:17,280
memory or consume is not the only uh

00:51:17,359 --> 00:51:21,359
use of dependencies by the linux kernel

00:51:19,520 --> 00:51:23,359
that needs some help

00:51:21,359 --> 00:51:25,040
right now we still use volatile accesses

00:51:23,359 --> 00:51:26,160
to make that work and also some very

00:51:25,040 --> 00:51:29,520
heavy duty

00:51:26,160 --> 00:51:31,440
coding restrictions if you're using uh

00:51:29,520 --> 00:51:32,480
rcd reference which is what i'd like to

00:51:31,440 --> 00:51:33,119
be able to implement with my writer

00:51:32,480 --> 00:51:35,440
consume

00:51:33,119 --> 00:51:36,960
but i can't because it just gets

00:51:35,440 --> 00:51:38,400
promoted to memory require and all the

00:51:36,960 --> 00:51:40,640
implementations

00:51:38,400 --> 00:51:42,400
uh that throws a memory barrier in there

00:51:40,640 --> 00:51:44,000
on some implementations and that uh

00:51:42,400 --> 00:51:45,440
that we can't live with on some

00:51:44,000 --> 00:51:47,440
architectures

00:51:45,440 --> 00:51:48,839
oh so we still use the volatile loads

00:51:47,440 --> 00:51:51,119
for that and we still use coding

00:51:48,839 --> 00:51:53,119
restrictions

00:51:51,119 --> 00:51:54,720
uh oh and i guess the next question is a

00:51:53,119 --> 00:51:56,319
follow-on there um

00:51:54,720 --> 00:51:58,079
there's a couple of different uh things

00:51:56,319 --> 00:51:59,359
that have been looked at a couple

00:51:58,079 --> 00:52:02,480
different directions

00:51:59,359 --> 00:52:03,359
one uh some people at apple uh jeff

00:52:02,480 --> 00:52:04,960
bastian uh

00:52:03,359 --> 00:52:06,720
and tim northfield if i got his name

00:52:04,960 --> 00:52:08,240
right where they keep

00:52:06,720 --> 00:52:09,680
a and this showed up as a working paper

00:52:08,240 --> 00:52:11,599
which i unfortunately don't remember the

00:52:09,680 --> 00:52:13,440
number of at the moment

00:52:11,599 --> 00:52:15,520
um where what they do is they keep an

00:52:13,440 --> 00:52:19,280
extra quantity going with the pointer

00:52:15,520 --> 00:52:21,599
that uh tracks the dependency and they

00:52:19,280 --> 00:52:23,040
carefully isolate that extra dependency

00:52:21,599 --> 00:52:24,240
from the compiler and then combine it

00:52:23,040 --> 00:52:25,520
with the pointer before each to

00:52:24,240 --> 00:52:27,599
reference

00:52:25,520 --> 00:52:28,960
and thus prevent the dependency from

00:52:27,599 --> 00:52:31,200
being lost no matter what you do to the

00:52:28,960 --> 00:52:34,240
pointer in the meantime

00:52:31,200 --> 00:52:36,880
um that is a very cute trick uh

00:52:34,240 --> 00:52:38,640
some uh people object to the pointers

00:52:36,880 --> 00:52:40,720
growing in size

00:52:38,640 --> 00:52:42,400
uh so another approach was done by a

00:52:40,720 --> 00:52:43,280
google summer of prototype i should say

00:52:42,400 --> 00:52:45,119
by a google com

00:52:43,280 --> 00:52:46,720
summer of code person myself actual

00:52:45,119 --> 00:52:49,680
guard uh he was a

00:52:46,720 --> 00:52:50,960
student at iat mumbai real bright guy

00:52:49,680 --> 00:52:54,079
what he did was he took

00:52:50,960 --> 00:52:55,920
the volatile implementation gcc and and

00:52:54,079 --> 00:52:57,440
replicated into a marking on the

00:52:55,920 --> 00:53:00,480
pointers that needed to be

00:52:57,440 --> 00:53:01,440
that needed to preserve dependencies and

00:53:00,480 --> 00:53:03,440
uh

00:53:01,440 --> 00:53:05,920
that uh got some discussion on the gcc

00:53:03,440 --> 00:53:07,520
list thus far we haven't gotten a way of

00:53:05,920 --> 00:53:09,920
taking it forward farther

00:53:07,520 --> 00:53:11,599
but hopefully we can get to a point

00:53:09,920 --> 00:53:13,839
where we can uh

00:53:11,599 --> 00:53:15,359
have a way of telling the compiler this

00:53:13,839 --> 00:53:16,400
variable carries a dependency please

00:53:15,359 --> 00:53:19,119
don't break it

00:53:16,400 --> 00:53:20,319
uh and we also have an an increasing

00:53:19,119 --> 00:53:22,480
number of places in the lynch terminal

00:53:20,319 --> 00:53:24,319
that depend on control dependencies

00:53:22,480 --> 00:53:25,839
which are at this point we don't even

00:53:24,319 --> 00:53:27,680
have an agreed upon

00:53:25,839 --> 00:53:29,680
way of specifying what the how the

00:53:27,680 --> 00:53:34,559
control dependency works

00:53:29,680 --> 00:53:36,800
uh so that's an even greater challenge

00:53:34,559 --> 00:53:38,960
okay there's one more question to which

00:53:36,800 --> 00:53:42,079
the answer is basically yes

00:53:38,960 --> 00:53:43,920
so the um the

00:53:42,079 --> 00:53:45,839
question is if i don't use memory or

00:53:43,920 --> 00:53:46,800
relax do i have to worry about any of

00:53:45,839 --> 00:53:49,920
this

00:53:46,800 --> 00:53:52,079
uh or rather will i be safe from

00:53:49,920 --> 00:53:54,240
the sort of out of thin air issue and

00:53:52,079 --> 00:53:56,880
the end as long as you also don't use

00:53:54,240 --> 00:53:58,960
memory or i consume which you probably

00:53:56,880 --> 00:54:00,160
don't then the answer is yes with memory

00:53:58,960 --> 00:54:02,240
order consume things

00:54:00,160 --> 00:54:03,520
again get complicated well except with

00:54:02,240 --> 00:54:05,040
current implementation it's perfectly

00:54:03,520 --> 00:54:06,720
safe because it's useless right because

00:54:05,040 --> 00:54:10,240
it turns into a choir

00:54:06,720 --> 00:54:12,079
sorry this is true yeah

00:54:10,240 --> 00:54:13,599
with current implementations it's true

00:54:12,079 --> 00:54:15,440
it's it's fine yeah

00:54:13,599 --> 00:54:17,680
another proviso i'll add to hanzas which

00:54:15,440 --> 00:54:19,200
is he's normally giving to me so i'm i

00:54:17,680 --> 00:54:20,960
just turn about fair play

00:54:19,200 --> 00:54:22,400
this is assuming that you avoid

00:54:20,960 --> 00:54:24,480
undefined behavior

00:54:22,400 --> 00:54:26,480
um if you don't use memory order relax

00:54:24,480 --> 00:54:28,000
but you do use normal loads and stores

00:54:26,480 --> 00:54:29,680
normally language loads and stores on

00:54:28,000 --> 00:54:32,559
non-atomic variables

00:54:29,680 --> 00:54:35,200
that are shared then you know sorry all

00:54:32,559 --> 00:54:36,799
bets are off

00:54:35,200 --> 00:54:39,440
so you the other restriction you need in

00:54:36,799 --> 00:54:42,880
there is that all of your

00:54:39,440 --> 00:54:42,880
shared variables are atomics

00:54:43,359 --> 00:54:46,640
the example with the while loop with

00:54:45,119 --> 00:54:48,720
compare exchange they were running on

00:54:46,640 --> 00:54:50,640
several cores how does memory barriers

00:54:48,720 --> 00:54:53,839
rewrite barriers i've seen this kernel

00:54:50,640 --> 00:54:58,240
compare and performance

00:54:53,839 --> 00:55:01,760
um see i'm going to read this again

00:54:58,240 --> 00:55:03,520
the the example with the while loop

00:55:01,760 --> 00:55:05,440
with compare exchange say you're running

00:55:03,520 --> 00:55:07,040
on several cores how does memory

00:55:05,440 --> 00:55:08,720
barriers

00:55:07,040 --> 00:55:10,400
uh read write barriers i've seen this

00:55:08,720 --> 00:55:12,480
kernel code

00:55:10,400 --> 00:55:14,640
compare and performance so there's a

00:55:12,480 --> 00:55:17,760
couple things you might be asking

00:55:14,640 --> 00:55:20,400
uh one of them you might be asking is

00:55:17,760 --> 00:55:21,760
gee if i'm taking the cash miss overhead

00:55:20,400 --> 00:55:22,480
i normally take with the compare

00:55:21,760 --> 00:55:24,880
exchange

00:55:22,480 --> 00:55:26,160
and i can even notice the memory barrier

00:55:24,880 --> 00:55:27,200
overhead

00:55:26,160 --> 00:55:30,240
and that's going to depend on the

00:55:27,200 --> 00:55:31,760
hardware but in many cases yeah

00:55:30,240 --> 00:55:33,680
if you're taking a cash miss on each and

00:55:31,760 --> 00:55:34,960
every operation yeah life will be hard

00:55:33,680 --> 00:55:36,079
on the other hand

00:55:34,960 --> 00:55:37,920
if you've been careful and you've

00:55:36,079 --> 00:55:39,359
designed your algorithm to have good

00:55:37,920 --> 00:55:40,640
cash locality

00:55:39,359 --> 00:55:42,400
so you're doing something where you have

00:55:40,640 --> 00:55:44,079
a quantity that's normally accessed by

00:55:42,400 --> 00:55:45,359
one thread but might be accessed at any

00:55:44,079 --> 00:55:48,559
time the other ones just rarely

00:55:45,359 --> 00:55:51,040
is then you will have a cash hit

00:55:48,559 --> 00:55:52,880
most of the time and then that memory

00:55:51,040 --> 00:55:54,880
barrier is noticeable

00:55:52,880 --> 00:55:57,520
and so in that case uh you would want to

00:55:54,880 --> 00:55:57,520
use relaxed

00:55:58,160 --> 00:56:02,480
uh yeah would you like to take the next

00:56:00,799 --> 00:56:05,760
question hans about chaotic or

00:56:02,480 --> 00:56:06,960
i will try i suspect neither of us is

00:56:05,760 --> 00:56:08,880
really an expert here

00:56:06,960 --> 00:56:10,640
if i remember right the original chaotic

00:56:08,880 --> 00:56:12,880
relaxation papers didn't talk

00:56:10,640 --> 00:56:14,720
specifically about memory ordering

00:56:12,880 --> 00:56:16,000
is relaxed absolutely needed for

00:56:14,720 --> 00:56:20,000
performance i think any

00:56:16,000 --> 00:56:23,359
fire and forget plus equals could work

00:56:20,000 --> 00:56:26,480
my understanding based on

00:56:23,359 --> 00:56:30,880
talking to some some colleagues who work

00:56:26,480 --> 00:56:33,839
closer to this area is that

00:56:30,880 --> 00:56:35,119
basically you generally can't afford the

00:56:33,839 --> 00:56:36,880
uh

00:56:35,119 --> 00:56:39,040
the memory any additional memory

00:56:36,880 --> 00:56:41,040
barriers and a lot of this code

00:56:39,040 --> 00:56:42,559
so in order to avoid the memory barriers

00:56:41,040 --> 00:56:45,920
people tend to use memory or

00:56:42,559 --> 00:56:48,559
relax rather than something stronger

00:56:45,920 --> 00:56:51,119
or in fact in many cases they cheat and

00:56:48,559 --> 00:56:53,440
use not use non-atomic operations which

00:56:51,119 --> 00:56:55,680
is strongly discouraged because it can

00:56:53,440 --> 00:56:58,720
just lead to incorrect results

00:56:55,680 --> 00:57:00,480
so i i don't have personal experience as

00:56:58,720 --> 00:57:02,319
to how bad this would get if you use

00:57:00,480 --> 00:57:03,920
stronger memory ordering there rather

00:57:02,319 --> 00:57:06,160
than memory order relaxed

00:57:03,920 --> 00:57:08,000
but my impression from talking to people

00:57:06,160 --> 00:57:11,920
is it's not acceptable

00:57:08,000 --> 00:57:13,839
and then to augment hansa's point about

00:57:11,920 --> 00:57:14,480
people using non-atomics for shared

00:57:13,839 --> 00:57:17,440
variables

00:57:14,480 --> 00:57:18,079
uh i i have to fight this battle all the

00:57:17,440 --> 00:57:20,240
time

00:57:18,079 --> 00:57:21,839
in a number of projects who or you have

00:57:20,240 --> 00:57:24,240
people that just want to be able to say

00:57:21,839 --> 00:57:25,599
a equals one for a shared variable and

00:57:24,240 --> 00:57:27,359
and believe it'll work

00:57:25,599 --> 00:57:30,480
which it does a surprising fraction of

00:57:27,359 --> 00:57:32,720
the time anyway we are past time

00:57:30,480 --> 00:57:34,079
uh hans and i do have some extra time uh

00:57:32,720 --> 00:57:34,960
if you'd like to continue asking

00:57:34,079 --> 00:57:37,119
questions

00:57:34,960 --> 00:57:38,640
uh including the one that just showed up

00:57:37,119 --> 00:57:41,359
a couple just showed up

00:57:38,640 --> 00:57:42,319
um we will i'll copy and paste those

00:57:41,359 --> 00:57:45,599
we're going to go to

00:57:42,319 --> 00:57:48,640
floor nine of uh

00:57:45,599 --> 00:57:49,119
the remo for this hans and i will be

00:57:48,640 --> 00:57:51,359
there

00:57:49,119 --> 00:57:53,040
if you join us there we can continue

00:57:51,359 --> 00:57:55,359
talking over the chat

00:57:53,040 --> 00:57:56,480
um and potentially we'll be able to talk

00:57:55,359 --> 00:58:01,200
to everybody but

00:57:56,480 --> 00:58:03,280
i'm not gonna count on that uh given uh

00:58:01,200 --> 00:58:04,640
my uh ineptness with video conferencing

00:58:03,280 --> 00:58:07,680
if nothing else

00:58:04,640 --> 00:58:08,960
so again uh floor nine of the remo ons

00:58:07,680 --> 00:58:11,920
and i'll join there

00:58:08,960 --> 00:58:12,720
and there'll be a general chat uh

00:58:11,920 --> 00:58:14,640
channel

00:58:12,720 --> 00:58:16,000
and we'll answer questions on that or

00:58:14,640 --> 00:58:17,599
any other way you can get them to us

00:58:16,000 --> 00:58:19,520
that we can see at the moment and i'm

00:58:17,599 --> 00:58:21,359
gonna copy and paste these last two

00:58:19,520 --> 00:58:23,440
which might already be there but

00:58:21,359 --> 00:58:24,559
who knows any case for the rest of you

00:58:23,440 --> 00:58:25,200
thank you very much for your time and

00:58:24,559 --> 00:58:27,839
attention

00:58:25,200 --> 00:58:28,960
and uh good to good to chat about this

00:58:27,839 --> 00:58:37,839
with you

00:58:28,960 --> 00:58:37,839
thank you very much

00:58:51,359 --> 00:58:53,440

YouTube URL: https://www.youtube.com/watch?v=cWkUqK71DZ0


