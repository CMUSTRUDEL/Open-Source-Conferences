Title: CppCon 2014: Lightning Talks - Martin Troxler "Return Values Take A Closure Walk"
Publication date: 2020-10-27
Playlist: CppCon 2014 Lightning Talks
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Programming in C++ since the early 90'. | Responsible: | - Development of realtime controller systems running on RT Linux for industrial manufacturing machines. | Recent hot topics: | - ReSTful server framework in C++ | - (Unit) testing of new and legacy C++ code
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,810 --> 00:00:08,530
Martin Troxler is next and that he wants

00:00:04,210 --> 00:00:09,790
you to take a closure walk and in my

00:00:08,530 --> 00:00:12,250
corner of the universe which is pretty

00:00:09,790 --> 00:00:15,430
Microsoft focus we have stl who is stl

00:00:12,250 --> 00:00:17,140
and mt as you can tell does mostly

00:00:15,430 --> 00:00:19,449
multi-threaded problems in real time

00:00:17,140 --> 00:00:21,869
systems for industrial manufacturing

00:00:19,449 --> 00:00:21,869
machines

00:00:32,230 --> 00:00:39,590
ok

00:00:34,910 --> 00:00:43,000
now I'm talking about how you can pass

00:00:39,590 --> 00:00:48,680
return values of the stack without

00:00:43,000 --> 00:00:53,930
effectively know their type now why

00:00:48,680 --> 00:00:59,269
would you use such a thing if you write

00:00:53,930 --> 00:01:01,760
a kind of wrapper function we saw this

00:00:59,269 --> 00:01:08,860
pattern for example yesterday on the

00:01:01,760 --> 00:01:13,250
legacy talk very was used to to try

00:01:08,860 --> 00:01:15,770
except to catch exceptions before they

00:01:13,250 --> 00:01:19,190
were thrown out into code that cannot

00:01:15,770 --> 00:01:25,039
work with the exceptions so you

00:01:19,190 --> 00:01:27,649
basically call a function within a try

00:01:25,039 --> 00:01:31,180
block call you make a scoped context it

00:01:27,649 --> 00:01:40,910
could be a something like a mutex or

00:01:31,180 --> 00:01:45,830
even a very complex database access why

00:01:40,910 --> 00:01:50,569
did I not choose to make it this call

00:01:45,830 --> 00:01:53,149
within function as a template because it

00:01:50,569 --> 00:01:57,759
would be faster at a complete type of

00:01:53,149 --> 00:02:02,470
the the given function would be usable

00:01:57,759 --> 00:02:06,729
but the reason is that we want to

00:02:02,470 --> 00:02:10,280
decouple the implementation of this

00:02:06,729 --> 00:02:12,860
curve is in function that is also the

00:02:10,280 --> 00:02:20,650
reason that I have to use a stative

00:02:12,860 --> 00:02:24,440
function to reach the concrete type now

00:02:20,650 --> 00:02:27,700
22 count to the real problem if you want

00:02:24,440 --> 00:02:33,200
to call a function that returns a value

00:02:27,700 --> 00:02:38,930
how would you achieve to pass that value

00:02:33,200 --> 00:02:43,989
up to the stack so we can disco is in

00:02:38,930 --> 00:02:43,989
function and use that a result value

00:02:44,870 --> 00:02:52,070
the simple solution would be to simply

00:02:47,940 --> 00:02:57,030
define the same return type but it's a

00:02:52,070 --> 00:03:04,200
stupid solution and makes not much sense

00:02:57,030 --> 00:03:06,890
now the first step is to declare to

00:03:04,200 --> 00:03:11,130
return mimic a template function and

00:03:06,890 --> 00:03:14,430
declare the return type to be the same

00:03:11,130 --> 00:03:19,350
as part of the given function you can

00:03:14,430 --> 00:03:24,090
use a data type and call the function

00:03:19,350 --> 00:03:26,730
but it's not not really an call just the

00:03:24,090 --> 00:03:28,560
type deduction mechanism introduces the

00:03:26,730 --> 00:03:31,740
type of the return value of this

00:03:28,560 --> 00:03:34,260
function it even doesn't matter how many

00:03:31,740 --> 00:03:36,240
parameter day this function with Islam

00:03:34,260 --> 00:03:42,660
de these colleagues callable expression

00:03:36,240 --> 00:03:47,580
has another step is to separate the

00:03:42,660 --> 00:03:50,690
implementation into an concrete function

00:03:47,580 --> 00:03:55,140
but this version does not compile

00:03:50,690 --> 00:04:00,690
because a call within impul requires a

00:03:55,140 --> 00:04:04,590
void function the next step is to

00:04:00,690 --> 00:04:08,630
declare a result and local variable that

00:04:04,590 --> 00:04:08,630
has the same type as the return type

00:04:09,350 --> 00:04:18,590
then we define a wrapper function a

00:04:14,700 --> 00:04:25,890
lambda expression that captures this

00:04:18,590 --> 00:04:28,410
result variable by reference in this

00:04:25,890 --> 00:04:31,130
wrapper function we call this original

00:04:28,410 --> 00:04:38,010
given function and store it in this

00:04:31,130 --> 00:04:43,440
captured result variable next step is to

00:04:38,010 --> 00:04:47,220
actually call the wrapper function it is

00:04:43,440 --> 00:04:51,360
now possible cost the return type of the

00:04:47,220 --> 00:04:54,639
wrapper is the same as test was expected

00:04:51,360 --> 00:04:59,159
this from a call with an input

00:04:54,639 --> 00:05:05,590
and at the end you return the result Lee

00:04:59,159 --> 00:05:10,300
we have saved previously the nice thing

00:05:05,590 --> 00:05:14,620
is that this a C++ move constructors we

00:05:10,300 --> 00:05:22,719
actually do don't do any copying of

00:05:14,620 --> 00:05:28,229
values just twice move you can put

00:05:22,719 --> 00:05:28,229
everything within a interface class and

00:05:29,789 --> 00:05:37,779
go now where this solution is not

00:05:34,360 --> 00:05:44,319
perfect because what happens if you want

00:05:37,779 --> 00:05:46,270
to call a function that returns void the

00:05:44,319 --> 00:05:50,740
compiler would give us to follow me

00:05:46,270 --> 00:05:53,379
mirrors cost result type is void we

00:05:50,740 --> 00:05:57,520
cannot a treat the return type is void

00:05:53,379 --> 00:05:59,789
we cannot declare a variable of this

00:05:57,520 --> 00:05:59,789
type

00:06:02,540 --> 00:06:10,950
what is a bit of simple metaprogramming

00:06:05,700 --> 00:06:15,410
we can switch between two versions if

00:06:10,950 --> 00:06:18,480
it's the return type void we choose the

00:06:15,410 --> 00:06:21,210
upper version with the widget which does

00:06:18,480 --> 00:06:24,420
doesn't return anything and if history

00:06:21,210 --> 00:06:31,710
it's another type than we return the

00:06:24,420 --> 00:06:38,330
result now there was there is another

00:06:31,710 --> 00:06:41,820
problem if you want to if the

00:06:38,330 --> 00:06:43,980
implementation itself can fail for

00:06:41,820 --> 00:06:48,020
example is a open connection this might

00:06:43,980 --> 00:06:54,600
fail and you want to return this

00:06:48,020 --> 00:06:58,290
information back to the caller so you

00:06:54,600 --> 00:07:02,340
can one variant to solve this problem is

00:06:58,290 --> 00:07:10,590
to choose a to use a boost optional on

00:07:02,340 --> 00:07:16,050
to wrap the result type within me if you

00:07:10,590 --> 00:07:23,010
read the implementation had a failure we

00:07:16,050 --> 00:07:26,250
return boost on and the original color

00:07:23,010 --> 00:07:30,150
has to check the result value if it was

00:07:26,250 --> 00:07:36,090
none if it was ok then it has to lift

00:07:30,150 --> 00:07:40,010
the reference to the actual value well

00:07:36,090 --> 00:07:40,010
that's it thank you

00:07:42,680 --> 00:07:44,740

YouTube URL: https://www.youtube.com/watch?v=05e-C7qMWVg


