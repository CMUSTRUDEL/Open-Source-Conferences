Title: CppCon 2014: Lightning Talks - Jonathan Caves "The New Old Thing, of Fun with Lambdas"
Publication date: 2020-10-27
Playlist: CppCon 2014 Lightning Talks
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Jonathan Caves, C++ compiler developer
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,040
we have Jonathan caves next John's going

00:00:03,090 --> 00:00:07,529
to talk about generic lambis because in

00:00:05,040 --> 00:00:10,110
C++ you can never escape from the past

00:00:07,529 --> 00:00:12,530
and he knows this full well because he

00:00:10,110 --> 00:00:19,170
works on the visual c++ compiler team

00:00:12,530 --> 00:00:23,160
give your dongle their surface team

00:00:19,170 --> 00:00:26,490
surface here this is 15 minutes there we

00:00:23,160 --> 00:00:28,529
go the title this is taken from sorry

00:00:26,490 --> 00:00:30,750
Ike wonder I wasn't more wonder the

00:00:28,529 --> 00:00:33,420
title of this is taken from a Raymond

00:00:30,750 --> 00:00:35,880
chance blog the old new new thing I just

00:00:33,420 --> 00:00:39,600
changed it around a bit and also from a

00:00:35,880 --> 00:00:43,170
blog I find on online which was titled

00:00:39,600 --> 00:00:46,489
fun la Villa lambdas I'll spent most of

00:00:43,170 --> 00:00:51,210
the last year working with both generic

00:00:46,489 --> 00:00:55,620
lambdas and very otic generic lambdas

00:00:51,210 --> 00:00:58,230
and once I have it work hard working I

00:00:55,620 --> 00:01:02,010
was looking for fun examples of people

00:00:58,230 --> 00:01:03,780
doing stuff with this and when I went

00:01:02,010 --> 00:01:06,990
out onto the web I find a guy called

00:01:03,780 --> 00:01:10,049
soup sumanth tambay who's died in the

00:01:06,990 --> 00:01:15,350
Bay Area had written this three-piece

00:01:10,049 --> 00:01:17,460
blog post called fun with lambdas and I

00:01:15,350 --> 00:01:19,530
looked looked looked at it and thought

00:01:17,460 --> 00:01:25,830
oh wow that's fun I wonder we can

00:01:19,530 --> 00:01:27,780
compile that that is the code it's scary

00:01:25,830 --> 00:01:31,729
for first first thing in the morning but

00:01:27,780 --> 00:01:34,759
what it's doing is it's a nested generic

00:01:31,729 --> 00:01:38,280
lambda called list which returns a

00:01:34,759 --> 00:01:41,310
generic lambda another jury gland are

00:01:38,280 --> 00:01:43,860
called map which when you apply it to a

00:01:41,310 --> 00:01:46,829
list who's over the elements of the list

00:01:43,860 --> 00:01:50,450
and applies a function to each element

00:01:46,829 --> 00:01:52,530
of the list and then a simple generic

00:01:50,450 --> 00:01:54,720
lambda called print which prints out

00:01:52,530 --> 00:01:57,119
about a value so you put them together

00:01:54,720 --> 00:02:00,750
at the ball at the bottom and you create

00:01:57,119 --> 00:02:03,060
a list you apply map to to the list and

00:02:00,750 --> 00:02:07,799
map or flour applies print to each of

00:02:03,060 --> 00:02:10,229
the the the the elements of the list and

00:02:07,799 --> 00:02:12,380
I was very happy that when I compile

00:02:10,229 --> 00:02:15,380
that it showed one bug and the fix

00:02:12,380 --> 00:02:22,270
fix that and the gap old ran so it's

00:02:15,380 --> 00:02:26,840
nice so I assume at in his blog posted

00:02:22,270 --> 00:02:28,670
that he tried example with clang and as

00:02:26,840 --> 00:02:34,490
you'd expect from seeing the code the

00:02:28,670 --> 00:02:38,770
output is 1 2 3 4 he tried him of GG a

00:02:34,490 --> 00:02:42,370
jeep GCC and he got four three two one

00:02:38,770 --> 00:02:47,990
now as we all know there are no bugs in

00:02:42,370 --> 00:02:51,830
flying it's obvious that GG GCC is the

00:02:47,990 --> 00:02:55,820
one with the bug and that's what he said

00:02:51,830 --> 00:02:59,690
in his blog and his deduction was the

00:02:55,820 --> 00:03:02,990
bug is in the order that the pack

00:02:59,690 --> 00:03:06,260
expansion is stored inside the lambda we

00:03:02,990 --> 00:03:08,290
go back to the example here where you

00:03:06,260 --> 00:03:11,630
can see the pack expansion the inner

00:03:08,290 --> 00:03:13,850
lambda expands the pack and also

00:03:11,630 --> 00:03:15,470
captures bye-bye that x value which

00:03:13,850 --> 00:03:20,090
means that the expanded form is captured

00:03:15,470 --> 00:03:24,560
by x x value and he assumed that g GCC

00:03:20,090 --> 00:03:27,530
was switching the order there so we

00:03:24,560 --> 00:03:30,590
compiled it and ran it and i got four

00:03:27,530 --> 00:03:32,450
three two one so there's two compilers

00:03:30,590 --> 00:03:37,160
are agreeing and one compilers not

00:03:32,450 --> 00:03:39,350
agreeing so where's the bug now except

00:03:37,160 --> 00:03:41,600
if you target armed with our compact

00:03:39,350 --> 00:03:44,930
compact that come up the compiler and do

00:03:41,600 --> 00:03:46,430
that case you get one two three four at

00:03:44,930 --> 00:03:50,870
this point i was ready to phone up the

00:03:46,430 --> 00:03:52,490
if the John John Spicer ddg it just

00:03:50,870 --> 00:03:59,320
asked about John what's the right answer

00:03:52,490 --> 00:03:59,320
this can you have a casting vote please

00:04:00,310 --> 00:04:06,350
so yeah what is the correct output what

00:04:04,220 --> 00:04:09,200
is the bug what is going on here because

00:04:06,350 --> 00:04:13,459
this is a very simple piece of code it's

00:04:09,200 --> 00:04:16,520
very clean it's very nice but compilers

00:04:13,459 --> 00:04:20,120
cannot agree and what the output should

00:04:16,520 --> 00:04:22,400
should be if you look at it closely the

00:04:20,120 --> 00:04:24,620
issues with this line here where you

00:04:22,400 --> 00:04:26,210
take the list and you apply funk to the

00:04:24,620 --> 00:04:28,520
elements we

00:04:26,210 --> 00:04:30,470
because this is functional you end up

00:04:28,520 --> 00:04:33,919
returning a list but you fly funk to the

00:04:30,470 --> 00:04:36,530
elements inside their compartment come

00:04:33,919 --> 00:04:38,780
come come compiler if you expand the

00:04:36,530 --> 00:04:42,080
pack you end up with that liner of the

00:04:38,780 --> 00:04:43,880
print and I've out of the numbers are so

00:04:42,080 --> 00:04:46,729
just you can see that we always it print

00:04:43,880 --> 00:04:49,639
ZZZ Z 1 which is one print to print

00:04:46,729 --> 00:04:53,169
three print print print print for it

00:04:49,639 --> 00:04:56,810
looks clean it looks clear what's wrong

00:04:53,169 --> 00:04:59,840
the new old thing we are right back in

00:04:56,810 --> 00:05:03,680
see the original sees that is that

00:04:59,840 --> 00:05:06,380
standard the order of a valuation of the

00:05:03,680 --> 00:05:09,110
postfix expression and the arguments to

00:05:06,380 --> 00:05:11,990
a function call is not specified a

00:05:09,110 --> 00:05:16,750
compiler is free to execute this code in

00:05:11,990 --> 00:05:20,870
any order it thinks is best I'm given

00:05:16,750 --> 00:05:23,800
x86 architecture the way the all

00:05:20,870 --> 00:05:26,930
compilers refer to do it is to go left

00:05:23,800 --> 00:05:28,970
22 left to right because that way so do

00:05:26,930 --> 00:05:31,430
the last one first and then do the first

00:05:28,970 --> 00:05:33,050
one last that saves you a couple of

00:05:31,430 --> 00:05:35,180
instruction instrum instruct

00:05:33,050 --> 00:05:39,949
instructions because you evaluate push

00:05:35,180 --> 00:05:43,940
evaluate push evaluate push Cole it's

00:05:39,949 --> 00:05:49,550
faster but it ends up getting the result

00:05:43,940 --> 00:05:53,030
wrong well not wrong unspecified but you

00:05:49,550 --> 00:05:55,820
try persuading your user that printing

00:05:53,030 --> 00:05:59,990
the result for four three two one is

00:05:55,820 --> 00:06:05,570
correct and they will probably stop you

00:05:59,990 --> 00:06:08,960
using your product this happens

00:06:05,570 --> 00:06:10,820
elsewhere and C C++ in these cases are

00:06:08,960 --> 00:06:13,550
probably a bit waste the first case is

00:06:10,820 --> 00:06:16,460
probably very very well well well known

00:06:13,550 --> 00:06:19,969
you know you're using I twice within

00:06:16,460 --> 00:06:23,810
within the Express expression what is

00:06:19,969 --> 00:06:27,830
the resulting value is it in is v-0 and

00:06:23,810 --> 00:06:32,060
initialized to 1 or the v1 is

00:06:27,830 --> 00:06:37,300
initialized to 1 if you don't you don't

00:06:32,060 --> 00:06:39,500
don't know the next one is a bit rarer I

00:06:37,300 --> 00:06:42,410
don't know many people who have

00:06:39,500 --> 00:06:44,990
complained about about this but if you

00:06:42,410 --> 00:06:47,540
start using lambdas if f1 actually

00:06:44,990 --> 00:06:50,480
happens to be a lambda you do see see

00:06:47,540 --> 00:06:55,250
see this in the problem is that to the

00:06:50,480 --> 00:06:57,500
back end the optimizer the f1 expression

00:06:55,250 --> 00:07:00,290
on on the left of the arrow is just

00:06:57,500 --> 00:07:02,390
really the first argh argh argument to

00:07:00,290 --> 00:07:04,010
the function it does moves it across and

00:07:02,390 --> 00:07:06,650
preferred sitting on to the head of the

00:07:04,010 --> 00:07:10,730
argument so again it does f2 first and

00:07:06,650 --> 00:07:14,180
then F 1 this is bitten me in the last

00:07:10,730 --> 00:07:17,750
few months imagine f 1 is a function

00:07:14,180 --> 00:07:21,890
which says go get me the current lambda

00:07:17,750 --> 00:07:26,150
your work you're working with ok the

00:07:21,890 --> 00:07:28,669
function MMF says go and please walk the

00:07:26,150 --> 00:07:33,169
body of the lambda looking for any

00:07:28,669 --> 00:07:35,150
implicit captures ok f2 i knows what

00:07:33,169 --> 00:07:38,090
goes off and gathers up the bot the body

00:07:35,150 --> 00:07:40,220
the body has a nested lambda in it it

00:07:38,090 --> 00:07:43,850
updates the stack the vector of lambda

00:07:40,220 --> 00:07:46,010
proset assessors and then call us ff1

00:07:43,850 --> 00:07:49,520
which gets the nested lambda not the one

00:07:46,010 --> 00:07:52,460
in the RV via the outside so you end up

00:07:49,520 --> 00:07:55,220
writing ya know what you doing is like

00:07:52,460 --> 00:07:57,320
like like like like this is you always

00:07:55,220 --> 00:07:59,090
end up writing more code and spread

00:07:57,320 --> 00:08:01,160
things they say things right but

00:07:59,090 --> 00:08:04,250
remember the example the beginning by

00:08:01,160 --> 00:08:07,430
just fly back to it if you start messing

00:08:04,250 --> 00:08:10,040
with this you lose a lot of the

00:08:07,430 --> 00:08:14,630
cleanliness of the code it ends up being

00:08:10,040 --> 00:08:16,250
come much more complicated you'll fit

00:08:14,630 --> 00:08:17,870
over this you're treadle of that you are

00:08:16,250 --> 00:08:22,040
the Sun something here so maybe sub

00:08:17,870 --> 00:08:24,860
template metaprogramming and a couple of

00:08:22,040 --> 00:08:28,700
days you have stuff i stood stood still

00:08:24,860 --> 00:08:31,340
stood still pair which is my example of

00:08:28,700 --> 00:08:34,159
you know how hard can i how much code

00:08:31,340 --> 00:08:37,060
can you need to store two things you

00:08:34,159 --> 00:08:37,060
know really

00:08:37,430 --> 00:08:44,640
so can we fix this is there a solution

00:08:42,180 --> 00:08:47,580
and the solution solution is you fix the

00:08:44,640 --> 00:08:52,050
order of about Val valuation we say C

00:08:47,580 --> 00:08:53,850
and C++ until now have been wrong we are

00:08:52,050 --> 00:09:00,480
going to say compilers must do it and

00:08:53,850 --> 00:09:03,750
left to right order there's possible but

00:09:00,480 --> 00:09:08,780
there are M implications this the code

00:09:03,750 --> 00:09:12,450
unless you're on x86 will be slightly

00:09:08,780 --> 00:09:15,960
slow slower I think most applications

00:09:12,450 --> 00:09:17,250
wouldn't notice you know given the miter

00:09:15,960 --> 00:09:19,770
time it takes to go and get something

00:09:17,250 --> 00:09:22,050
from Maine Maine men and that memory an

00:09:19,770 --> 00:09:25,500
extra push is not going to cause you

00:09:22,050 --> 00:09:30,290
much trouble but for some apps this may

00:09:25,500 --> 00:09:33,120
be too too too much it also will change

00:09:30,290 --> 00:09:35,520
behavior maybe there are people who are

00:09:33,120 --> 00:09:39,630
very happy fat the code prints prints

00:09:35,520 --> 00:09:41,370
out for four three two one that that's

00:09:39,630 --> 00:09:43,230
what what they want now they're going to

00:09:41,370 --> 00:09:45,630
get the reverse behavior people know

00:09:43,230 --> 00:09:48,560
that people have lived we've lived this

00:09:45,630 --> 00:09:56,630
have adapted their code to it on a

00:09:48,560 --> 00:09:59,040
perfectly huh happy herb as Sutter is

00:09:56,630 --> 00:10:02,700
pushing for the committee to fix this

00:09:59,040 --> 00:10:05,700
for c z+ us at 17 he feels this has been

00:10:02,700 --> 00:10:10,260
a wart which has been around for too too

00:10:05,700 --> 00:10:12,720
long but the worry is that it is going

00:10:10,260 --> 00:10:18,870
to cause trouble so have a sure hands

00:10:12,720 --> 00:10:23,610
who thinks we should fix this who thinks

00:10:18,870 --> 00:10:29,970
we shouldn't okay fifty-fifty that is

00:10:23,610 --> 00:10:33,810
going to be a really fun meeting so

00:10:29,970 --> 00:10:37,930
that's the I'm done well and here's some

00:10:33,810 --> 00:10:39,990
time time time back okay I've got

00:10:37,930 --> 00:10:39,990

YouTube URL: https://www.youtube.com/watch?v=Pr9g1nqTz_A


