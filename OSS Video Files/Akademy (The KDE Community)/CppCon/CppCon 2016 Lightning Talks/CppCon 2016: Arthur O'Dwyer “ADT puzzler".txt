Title: CppCon 2016: Arthur O'Dwyer “ADT puzzler"
Publication date: 2016-10-07
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,460 --> 00:00:04,020
All right, so, by the way, I'm Arthur O'Dwyer —

00:00:04,200 --> 00:00:05,720
Hello.

00:00:06,720 --> 00:00:13,280
— and I organize a meet-up in the San Francisco area, particularly in San Francisco itself;

00:00:13,280 --> 00:00:18,120
so if you're in that area and you're not already aware of it, I guess come talk to me...

00:00:18,120 --> 00:00:20,460
or come join us on October 3.

00:00:21,620 --> 00:00:25,480
These are the intermission slides for my template talk ("Template Normal Programming", CppCon 2016).

00:00:25,620 --> 00:00:30,800
Just a quick little puzzler here. Audience participation encouraged.

00:00:31,300 --> 00:00:36,240
I'm going to show a little bit of code here, and I'm going to ask: does this compile?

00:00:36,420 --> 00:00:39,100
And then you're going to say yes or no!

00:00:39,100 --> 00:00:40,840
Does this compile?

00:00:41,460 --> 00:00:43,440
Yeah, okay cool. That's fine. Okay

00:00:44,260 --> 00:00:47,720
So let's make this a little more complicated. Let's make `f` a template.

00:00:48,220 --> 00:00:53,180
Someone, play compiler here. What does this do?

00:00:54,480 --> 00:00:57,760
"Doesn't compile." Why not?

00:00:58,920 --> 00:01:04,760
"Can't deduce template parameter `I`." Awesome. All right. Some people have used the compiler before. All right.

00:01:05,740 --> 00:01:10,160
All right, let's do that. Does that work?

00:01:10,960 --> 00:01:14,340
I heard a "yes". I heard a loud "no".

00:01:14,380 --> 00:01:17,120
[AUDIENCE, INDISTINCTLY]

00:01:17,620 --> 00:01:23,140
"If you have an explicit specialization..." okay, that's interesting... Anyone else?

00:01:24,300 --> 00:01:27,440
Yeah, "`f` was not declared in this scope"!

00:01:27,520 --> 00:01:32,020
Interesting. Why don't we get ADL in this case?

00:01:32,020 --> 00:01:34,020
[AUDIENCE, INDISTINCTLY]

00:01:34,600 --> 00:01:38,980
"Because you need to specify the template argu–" I did specify the template argument! It's zero.

00:01:48,780 --> 00:01:56,800
"Same problem as std::get"? std::get doesn't exactly hit– well, okay. It's you can't— you have to leave the std nam— okay.

00:01:56,800 --> 00:02:00,300
Suppose I rewrite it like this. Does that help?

00:02:01,960 --> 00:02:03,880
[SCATTERED LAUGHTER]

00:02:05,040 --> 00:02:08,540
It is the same thing; all I did was add two spaces.

00:02:08,700 --> 00:02:12,540
But yes. Yes, `f` is not declared in this scope...

00:02:12,660 --> 00:02:17,800
because at this point we don't even know that `f` is the name of an overload set.

00:02:17,800 --> 00:02:21,280
`f` is just a THING that we're comparing to zero.

00:02:23,720 --> 00:02:29,580
And for a template name to be explicitly qualified by template arguments the name must be known to refer to a template.

00:02:29,820 --> 00:02:35,100
Otherwise we're not actually giving it template arguments; we're just saying a less-than sign.

00:02:36,360 --> 00:02:41,920
So what we have in here is, `f < 0`... and the compiler says okay, well, what is `f`?

00:02:41,920 --> 00:02:44,720
Well, I don't know what `f` is. There IS no `f` in scope.

00:02:45,980 --> 00:02:48,720
So it's not a function call.

00:02:49,400 --> 00:02:55,340
Now we can make it one! We just stick this other definition in here. `template<class> void f()`.

00:02:55,340 --> 00:03:00,560
in fact we didn't even need it to be a function. It could be a class at this point. As long as it was a template.

00:03:00,860 --> 00:03:06,080
Just to let the compiler know, "Hey. `f`, in this scope, is a TEMPLATE."

00:03:06,480 --> 00:03:09,799
And then it parses just fine, and ADL kicks in, and we get the right `f`.

00:03:09,800 --> 00:03:15,840
And it doesn't even matter that this `f` right here, you know, that this takes a `class` when the real `f` needs an `int`, like, that's all fine.

00:03:16,300 --> 00:03:19,500
`f` is a template, and we can go look it up, and we're happy.

00:03:19,500 --> 00:03:20,580
[QUESTION FROM AUDIENCE, INDISTINCTLY]

00:03:20,580 --> 00:03:26,540
Yes. `f` has to be a template. If it's a function it's not gonna work.

00:03:30,260 --> 00:03:36,720
"What happens you put the `template` keyword before it?" As of C++17, as far as I know, syntax error.

00:03:37,260 --> 00:03:41,780
Similarly if you have a typename that the compiler doesn't know is a typename, and you stick `typename` in front of it, syntax error.

00:03:41,780 --> 00:03:45,880
You can only use those in dependent contexts, such as in the body of a template.

00:03:45,880 --> 00:03:49,620
If you try to use it in normal code, like this code, to just say "I know what I'm doing"...

00:03:50,040 --> 00:03:53,180
The compiler doesn't CARE if you know what you're doing.

00:03:53,180 --> 00:03:55,180
[LAUGHTER]

00:03:56,220 --> 00:03:58,540
And that's it. That's all I got. Thank you.

00:03:58,540 --> 00:04:02,500

YouTube URL: https://www.youtube.com/watch?v=lIJziqkSaBk


