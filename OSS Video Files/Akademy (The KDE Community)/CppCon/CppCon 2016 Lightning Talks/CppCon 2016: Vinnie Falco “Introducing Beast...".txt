Title: CppCon 2016: Vinnie Falco “Introducing Beast..."
Publication date: 2016-10-07
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,470
so I have good news and bad news the

00:00:02,280 --> 00:00:07,980
good news is this is the last talk the

00:00:04,470 --> 00:00:09,599
bad news is it's a long one so my name

00:00:07,980 --> 00:00:11,550
is Vinnie Falco I work at Ripple

00:00:09,599 --> 00:00:14,940
I have the pleasure and honor of working

00:00:11,550 --> 00:00:17,490
with Howard Hinnant Scott sure

00:00:14,940 --> 00:00:19,770
Thursday morning's keynote speaker David

00:00:17,490 --> 00:00:22,260
Schwartz who's chief cryptographer and

00:00:19,770 --> 00:00:25,949
I'm gonna talk to you about a library

00:00:22,260 --> 00:00:29,670
I've developed called beast so beast is

00:00:25,949 --> 00:00:31,769
a header only C++ 11 or later library

00:00:29,670 --> 00:00:34,829
that offers HTTP and WebSocket

00:00:31,769 --> 00:00:37,590
implementations using boost SEO so boost

00:00:34,829 --> 00:00:40,260
is a requirement is a dependency it

00:00:37,590 --> 00:00:42,600
tries to emulate boost at SEO in every

00:00:40,260 --> 00:00:45,510
way all of the interfaces resemble SEO

00:00:42,600 --> 00:00:47,399
the documentation resembles a Zeo it's

00:00:45,510 --> 00:00:49,980
got a lot of the same features it's in

00:00:47,399 --> 00:00:51,360
the boost incubator and as soon as I get

00:00:49,980 --> 00:00:54,059
home I'm going to submit it for a boost

00:00:51,360 --> 00:00:56,190
review there's documentation tests and

00:00:54,059 --> 00:00:59,879
sample code including a fully functional

00:00:56,190 --> 00:01:01,739
web server and WebSocket server and the

00:00:59,879 --> 00:01:03,480
good news is its production ready code

00:01:01,739 --> 00:01:05,460
it's running on ripple production

00:01:03,480 --> 00:01:07,049
servers there's a few other third

00:01:05,460 --> 00:01:09,659
parties in the wild that are shipping

00:01:07,049 --> 00:01:11,549
products using beast so I think it's

00:01:09,659 --> 00:01:14,520
very robust I haven't heard any bug

00:01:11,549 --> 00:01:17,850
reports yet surely they'll be coming

00:01:14,520 --> 00:01:19,350
soon so that you might have seen this

00:01:17,850 --> 00:01:20,970
brochure that I've been handing out that

00:01:19,350 --> 00:01:23,280
has information about beast including

00:01:20,970 --> 00:01:25,259
the link there's a box full of brochures

00:01:23,280 --> 00:01:31,460
please feel free to grab one on your way

00:01:25,259 --> 00:01:34,380
out okay so so why do we need HTTP and

00:01:31,460 --> 00:01:36,329
WebSockets well here we have an HTTP

00:01:34,380 --> 00:01:37,560
request in JavaScript this is built into

00:01:36,329 --> 00:01:40,350
the language you can see it looks very

00:01:37,560 --> 00:01:45,090
nice and here's the equivalent request

00:01:40,350 --> 00:01:46,740
in C++ so it's been long enough we need

00:01:45,090 --> 00:01:48,470
this thing it's a little bit

00:01:46,740 --> 00:01:51,600
embarrassing that we don't have it yet

00:01:48,470 --> 00:01:53,520
so I'm gonna give I'm gonna give the

00:01:51,600 --> 00:01:54,869
talk broken up into two parts I'm going

00:01:53,520 --> 00:01:56,700
to talk about WebSocket then we're going

00:01:54,869 --> 00:01:58,740
to talk about HTTP and I'm going to show

00:01:56,700 --> 00:02:03,000
you very tiny example programs

00:01:58,740 --> 00:02:05,040
so for WebSocket beast establishes the

00:02:03,000 --> 00:02:07,200
session for you it lets you send and

00:02:05,040 --> 00:02:09,149
receive WebSocket messages and you can

00:02:07,200 --> 00:02:11,160
use it to build clients or servers or

00:02:09,149 --> 00:02:12,530
the interfaces are symmetric and it

00:02:11,160 --> 00:02:13,700
offers both synchronous and asynchronous

00:02:12,530 --> 00:02:14,959
interface

00:02:13,700 --> 00:02:17,060
now I don't recommend that you build

00:02:14,959 --> 00:02:19,489
production servers with the synchronous

00:02:17,060 --> 00:02:22,069
api's but they're there for completeness

00:02:19,489 --> 00:02:23,690
and for you know writing test programs

00:02:22,069 --> 00:02:25,640
or getting up and running quickly the

00:02:23,690 --> 00:02:27,650
performance is competitive its

00:02:25,640 --> 00:02:30,280
production ready passes the autobahn

00:02:27,650 --> 00:02:32,510
test suite so I'm gonna show you an

00:02:30,280 --> 00:02:35,120
WebSocket echo example it's gonna

00:02:32,510 --> 00:02:36,709
connect to a remote server handshake and

00:02:35,120 --> 00:02:40,130
send a message and then receive and

00:02:36,709 --> 00:02:41,330
print the the response the first thing

00:02:40,130 --> 00:02:44,540
we need to do is connect to the remote

00:02:41,330 --> 00:02:47,510
host now in this sample code the boost

00:02:44,540 --> 00:02:49,220
ezio symbols are purple so the what we

00:02:47,510 --> 00:02:51,290
need to do is establish our socket

00:02:49,220 --> 00:02:52,640
connection so there's no beast code here

00:02:51,290 --> 00:02:55,430
yet this is what you're familiar with

00:02:52,640 --> 00:02:57,739
boost a Co we are resolving a DNS name

00:02:55,430 --> 00:02:59,390
and then we're connecting to it using

00:02:57,739 --> 00:03:01,190
boost as you know when this code is done

00:02:59,390 --> 00:03:02,599
running we're gonna have a socket that's

00:03:01,190 --> 00:03:04,549
connected and then it's going to be

00:03:02,599 --> 00:03:07,220
ready to roll so now that we have our

00:03:04,549 --> 00:03:09,170
connected socket we create the Beast web

00:03:07,220 --> 00:03:12,019
socket stream which is a wrapper around

00:03:09,170 --> 00:03:13,880
the socket the template argument tells

00:03:12,019 --> 00:03:16,310
you the type of what it's wrapping in

00:03:13,880 --> 00:03:19,040
this case it's an on owning reference to

00:03:16,310 --> 00:03:21,560
a socket that could just as easily be an

00:03:19,040 --> 00:03:23,420
SSL stream or an owning reference or

00:03:21,560 --> 00:03:25,970
even your own user-defined type which

00:03:23,420 --> 00:03:29,780
meets the requirements of sync or a sync

00:03:25,970 --> 00:03:31,730
stream so we declare our variable now we

00:03:29,780 --> 00:03:34,670
perform a WebSocket handshake which

00:03:31,730 --> 00:03:37,250
consists of an HTTP request and response

00:03:34,670 --> 00:03:40,190
sequence it's the HTTP upgrade message

00:03:37,250 --> 00:03:42,440
beast handles that for you in the call

00:03:40,190 --> 00:03:45,109
you tell it the hosts which becomes the

00:03:42,440 --> 00:03:47,540
host field in the HTTP headers and then

00:03:45,109 --> 00:03:50,359
slash is the URI that could be your you

00:03:47,540 --> 00:03:50,900
know whatever your CGI /bin or whatever

00:03:50,359 --> 00:03:53,959
you're using

00:03:50,900 --> 00:03:56,329
so we handshake and now we write our

00:03:53,959 --> 00:03:58,609
message so we're using a Zio's buffer

00:03:56,329 --> 00:04:01,880
function which creates a constant buffer

00:03:58,609 --> 00:04:03,889
sequence from a string beasts write

00:04:01,880 --> 00:04:05,810
function takes any constant buffer

00:04:03,889 --> 00:04:07,280
sequence that meets the requirements so

00:04:05,810 --> 00:04:09,590
you can use all the things that you're

00:04:07,280 --> 00:04:11,180
familiar with from ezio so we sent our

00:04:09,590 --> 00:04:13,459
message now we want to receive a message

00:04:11,180 --> 00:04:14,959
and print it out so we declare a stream

00:04:13,459 --> 00:04:18,470
buff to hold the contents of the message

00:04:14,959 --> 00:04:21,169
and and then a local variable of type

00:04:18,470 --> 00:04:23,060
opcode which is an enum that tells you

00:04:21,169 --> 00:04:24,560
if your receive the message is binary or

00:04:23,060 --> 00:04:26,880
text that's part of the WebSocket

00:04:24,560 --> 00:04:29,220
protocol so we call read when that

00:04:26,880 --> 00:04:31,250
turns now we know if it's binary or text

00:04:29,220 --> 00:04:33,600
and we have the data in our stream buff

00:04:31,250 --> 00:04:36,060
so now we want to write that to standard

00:04:33,600 --> 00:04:37,950
out to string is a beast utility

00:04:36,060 --> 00:04:40,470
function that converts a constant buffer

00:04:37,950 --> 00:04:42,900
sequence into a standard string so beast

00:04:40,470 --> 00:04:45,270
comes with not only HTTP and WebSocket

00:04:42,900 --> 00:04:49,710
but a really handy collection of utility

00:04:45,270 --> 00:04:51,090
functions such as - string - it's beyond

00:04:49,710 --> 00:04:52,620
the scope of this talk for me to go over

00:04:51,090 --> 00:04:54,750
all the utility functions but they're in

00:04:52,620 --> 00:04:57,570
there and they're in the docs so we got

00:04:54,750 --> 00:04:59,340
our message and now we need to close the

00:04:57,570 --> 00:05:01,590
WebSocket connection so this is a

00:04:59,340 --> 00:05:03,090
protocol level closed in WebSocket the

00:05:01,590 --> 00:05:06,210
connection is considered closed when

00:05:03,090 --> 00:05:08,220
both sides send a close frame this is

00:05:06,210 --> 00:05:10,020
doing that and beast' handles that for

00:05:08,220 --> 00:05:12,480
you it manages the negotiation of those

00:05:10,020 --> 00:05:14,430
messages you can tell it the code which

00:05:12,480 --> 00:05:16,350
could be normal or an error or whatever

00:05:14,430 --> 00:05:19,830
you want to tell the other side and and

00:05:16,350 --> 00:05:21,900
then it closes the socket for you okay

00:05:19,830 --> 00:05:24,350
so you saw the synchronous interfaces

00:05:21,900 --> 00:05:26,670
that use exceptions but there's also

00:05:24,350 --> 00:05:29,610
interfaces that use error codes just

00:05:26,670 --> 00:05:32,010
like SEO and of course of the full suite

00:05:29,610 --> 00:05:34,260
of asynchronous interfaces just like SEO

00:05:32,010 --> 00:05:36,990
here we have an example that uses a

00:05:34,260 --> 00:05:39,840
completion handler that takes the error

00:05:36,990 --> 00:05:41,750
code which is just like SEO or you could

00:05:39,840 --> 00:05:43,980
use a covert een stack full or stackless

00:05:41,750 --> 00:05:45,780
standard futures or even your own

00:05:43,980 --> 00:05:48,390
user-defined types as long as they meet

00:05:45,780 --> 00:05:50,880
the requirements so this API is ready

00:05:48,390 --> 00:05:52,650
for the networking specification I've

00:05:50,880 --> 00:05:54,330
worked with Chris on making sure that

00:05:52,650 --> 00:05:59,280
this is going to be right and it's gonna

00:05:54,330 --> 00:06:01,230
be great okay so HTTP requests and

00:05:59,280 --> 00:06:04,080
responses are used in the WebSocket

00:06:01,230 --> 00:06:06,420
handshake so the library also exposes

00:06:04,080 --> 00:06:08,130
those HTTP implementations to you so

00:06:06,420 --> 00:06:10,770
that you can take advantage of it and do

00:06:08,130 --> 00:06:13,050
HTTP in your own C++ programs so now I'm

00:06:10,770 --> 00:06:16,740
going to show you a very short HTTP

00:06:13,050 --> 00:06:18,720
example the scope of the libraries HTTP

00:06:16,740 --> 00:06:21,540
support is to provide a universal

00:06:18,720 --> 00:06:22,980
message container so that means it

00:06:21,540 --> 00:06:25,260
offers a container that can store

00:06:22,980 --> 00:06:27,780
complete HTTP message including the

00:06:25,260 --> 00:06:30,270
headers the request or response specific

00:06:27,780 --> 00:06:32,250
fields and also the message body the

00:06:30,270 --> 00:06:34,020
container is usually copyable and

00:06:32,250 --> 00:06:37,140
moveable and and it has everything that

00:06:34,020 --> 00:06:40,110
it needs so so there's actually two

00:06:37,140 --> 00:06:41,129
protocols for HTTP now there is the HTTP

00:06:40,110 --> 00:06:44,969
one which

00:06:41,129 --> 00:06:47,129
1.0 and 1.1 and HTTP to the current

00:06:44,969 --> 00:06:50,669
implementation in beast serializes and

00:06:47,129 --> 00:06:52,919
DC realises HTTP 1 messages only there

00:06:50,669 --> 00:06:53,429
are future plans to do 2.0 it's not in

00:06:52,919 --> 00:06:56,249
there yet

00:06:53,429 --> 00:06:58,229
like the WebSocket you can build clients

00:06:56,249 --> 00:06:59,839
or servers the interfaces are symmetric

00:06:58,229 --> 00:07:02,999
there are synchronous and asynchronous

00:06:59,839 --> 00:07:06,389
interfaces that work with any stream

00:07:02,999 --> 00:07:08,729
concept like the IP TCP socket or SSL

00:07:06,389 --> 00:07:10,379
stream the performance is ready for

00:07:08,729 --> 00:07:12,989
production we have servers that are

00:07:10,379 --> 00:07:14,519
using it it's great now one thing about

00:07:12,989 --> 00:07:17,369
this library is that it's not really

00:07:14,519 --> 00:07:20,099
targeted towards end-users it's targeted

00:07:17,369 --> 00:07:20,999
towards library developers now what does

00:07:20,099 --> 00:07:22,979
that mean that means that these

00:07:20,999 --> 00:07:25,110
interfaces are low level it's not a

00:07:22,979 --> 00:07:26,759
replacement for curl there are things

00:07:25,110 --> 00:07:29,219
that it doesn't do like it won't decode

00:07:26,759 --> 00:07:31,259
your your mime types or you know figure

00:07:29,219 --> 00:07:34,110
out your multi-part message body but it

00:07:31,259 --> 00:07:36,809
provides a foundation upon which the C++

00:07:34,110 --> 00:07:38,909
community can build all of the HTTP

00:07:36,809 --> 00:07:42,959
tools and implementations that other

00:07:38,909 --> 00:07:45,539
languages have so I'm gonna show you an

00:07:42,959 --> 00:07:47,069
example of doing an HTTP request in

00:07:45,539 --> 00:07:49,169
response we're gonna connect to the

00:07:47,069 --> 00:07:51,240
remote host we're gonna build a get

00:07:49,169 --> 00:07:53,419
request and send it out and then we're

00:07:51,240 --> 00:07:56,819
gonna receive the response and print it

00:07:53,419 --> 00:07:59,369
okay first step just like before we need

00:07:56,819 --> 00:08:01,379
to create create our socket and connect

00:07:59,369 --> 00:08:02,039
to the remote host so we use boost as EO

00:08:01,379 --> 00:08:04,829
to do that

00:08:02,039 --> 00:08:06,749
there's no beast involved yet just like

00:08:04,829 --> 00:08:08,189
before this code is gonna run we're

00:08:06,749 --> 00:08:09,509
gonna have our socket that's going to be

00:08:08,189 --> 00:08:11,999
nicely connected and then we're going to

00:08:09,509 --> 00:08:13,949
be ready to rock and roll so we want to

00:08:11,999 --> 00:08:17,159
send a request we declare the message

00:08:13,949 --> 00:08:19,889
container so here we're declaring HTTP 1

00:08:17,159 --> 00:08:22,019
container that is a request and the

00:08:19,889 --> 00:08:24,449
template argument tells you the type of

00:08:22,019 --> 00:08:26,819
the message body in this case there's no

00:08:24,449 --> 00:08:29,009
message body so we say empty body which

00:08:26,819 --> 00:08:32,099
is a special beast type that means hey

00:08:29,009 --> 00:08:34,500
there's no body now we fill the fields

00:08:32,099 --> 00:08:36,389
out the method is a string it can be any

00:08:34,500 --> 00:08:38,310
string that you want hopefully the other

00:08:36,389 --> 00:08:41,219
end will know what that is if it's get

00:08:38,310 --> 00:08:43,380
you're gonna have a lot of success the

00:08:41,219 --> 00:08:45,480
URL is another just a plain string

00:08:43,380 --> 00:08:46,970
there's nothing fancy with the URLs you

00:08:45,480 --> 00:08:51,569
just provide the string and that's it

00:08:46,970 --> 00:08:53,910
version of 11 means HTTP 1.1 it's very

00:08:51,569 --> 00:08:54,720
simple not there's no over-engineering

00:08:53,910 --> 00:08:57,269
here

00:08:54,720 --> 00:08:59,519
the user-agent is a required header 41.1

00:08:57,269 --> 00:09:01,439
so we have to insert it okay so now we

00:08:59,519 --> 00:09:03,600
have a complete get request and we want

00:09:01,439 --> 00:09:06,029
to send it how do we send it well we

00:09:03,600 --> 00:09:07,800
call right just like that there's our

00:09:06,029 --> 00:09:09,810
socket now you can see there's a

00:09:07,800 --> 00:09:11,220
function called prepare that's an

00:09:09,810 --> 00:09:13,560
optional function that you can call

00:09:11,220 --> 00:09:15,329
prepares a beast function that fills in

00:09:13,560 --> 00:09:16,649
some information for you it does a

00:09:15,329 --> 00:09:18,389
little bit of work for you like it'll

00:09:16,649 --> 00:09:20,910
set the content length in this case to

00:09:18,389 --> 00:09:22,529
zero it'll set connection keep alive or

00:09:20,910 --> 00:09:24,420
connection closed according to your

00:09:22,529 --> 00:09:26,129
preferences this is a little some

00:09:24,420 --> 00:09:27,629
overloads that do things for you you

00:09:26,129 --> 00:09:29,730
don't have to use it if you want

00:09:27,629 --> 00:09:31,709
complete control over the HTTP message

00:09:29,730 --> 00:09:33,720
you can have it again this is the

00:09:31,709 --> 00:09:36,329
low-level library so it's designed to

00:09:33,720 --> 00:09:37,860
let you do anything that you want so we

00:09:36,329 --> 00:09:40,860
sent our request now we want to receive

00:09:37,860 --> 00:09:42,449
the response so we declare an object of

00:09:40,860 --> 00:09:44,970
type response this is going to be an

00:09:42,449 --> 00:09:47,519
HTTP 1 response the template argument

00:09:44,970 --> 00:09:49,709
tells us that the body is going to be

00:09:47,519 --> 00:09:51,360
represented by a standard string which

00:09:49,709 --> 00:09:53,250
is everyone knows how to use those it's

00:09:51,360 --> 00:09:55,379
easy to print it's easy to understand so

00:09:53,250 --> 00:09:59,309
that's what we're gonna do and now we

00:09:55,379 --> 00:10:01,050
call read on the socket so after that

00:09:59,309 --> 00:10:02,939
call returns we're gonna have a nice

00:10:01,050 --> 00:10:04,290
response that's all filled in it's all

00:10:02,939 --> 00:10:06,809
gonna be great now due to the way that

00:10:04,290 --> 00:10:09,629
the parser works the implementation of

00:10:06,809 --> 00:10:11,279
read can read pass the message and start

00:10:09,629 --> 00:10:13,379
reading some of the next message for

00:10:11,279 --> 00:10:15,720
performance reasons any of those extra

00:10:13,379 --> 00:10:17,309
bytes that it had to read they're going

00:10:15,720 --> 00:10:20,519
to be in the stream buffer and you reuse

00:10:17,309 --> 00:10:23,399
them on the next call it all works so

00:10:20,519 --> 00:10:25,829
beast message containers are streamable

00:10:23,399 --> 00:10:28,649
to any standard Oh stream and it uses

00:10:25,829 --> 00:10:30,480
the same D serialization algorithm

00:10:28,649 --> 00:10:32,250
that it uses to write to the socket so

00:10:30,480 --> 00:10:33,600
now you can see what they look like you

00:10:32,250 --> 00:10:36,029
know and standard out it's great it's

00:10:33,600 --> 00:10:38,490
useful for debugging ok

00:10:36,029 --> 00:10:40,410
just like WebSocket you have

00:10:38,490 --> 00:10:41,970
asynchronous interfaces for all the

00:10:40,410 --> 00:10:43,589
functions they look just like SEO

00:10:41,970 --> 00:10:45,600
functions they have the same limitations

00:10:43,589 --> 00:10:47,730
and the same performance characteristics

00:10:45,600 --> 00:10:50,519
here we have an example of doing a read

00:10:47,730 --> 00:10:53,189
with the completion Handler that

00:10:50,519 --> 00:10:55,019
completion token could be a co-routine

00:10:53,189 --> 00:10:56,819
stack full or stackless a standard

00:10:55,019 --> 00:10:59,879
future or your own user-defined type

00:10:56,819 --> 00:11:01,529
that meets the requirements now there's

00:10:59,879 --> 00:11:03,059
a lot of advanced features that I'm not

00:11:01,529 --> 00:11:05,250
really able to cover right now for

00:11:03,059 --> 00:11:07,019
example user-defined customizations of

00:11:05,250 --> 00:11:08,130
the message body where you can define

00:11:07,019 --> 00:11:10,110
not only your own type

00:11:08,130 --> 00:11:13,410
container but also the algorithms used

00:11:10,110 --> 00:11:16,050
to send and receive that body for

00:11:13,410 --> 00:11:18,810
example you can have an HTTP message

00:11:16,050 --> 00:11:21,090
whose body is incremental data that's

00:11:18,810 --> 00:11:23,070
generated from a KO routine for example

00:11:21,090 --> 00:11:24,570
a long-running database query you can

00:11:23,070 --> 00:11:26,430
have that streaming out and it can be

00:11:24,570 --> 00:11:26,880
either push or pull depending on how you

00:11:26,430 --> 00:11:28,830
write it

00:11:26,880 --> 00:11:31,500
you can have a read-only message body

00:11:28,830 --> 00:11:33,300
such as serving a file from the hard

00:11:31,500 --> 00:11:36,090
drive which is one of the examples that

00:11:33,300 --> 00:11:38,210
beast comes with that web server has an

00:11:36,090 --> 00:11:42,720
example of a message with the file body

00:11:38,210 --> 00:11:45,180
so any HTTP library has to have a parser

00:11:42,720 --> 00:11:47,430
if it's gonna deserialize requests and

00:11:45,180 --> 00:11:49,380
responses and beast is no different it's

00:11:47,430 --> 00:11:51,750
got a parser that's header only it's

00:11:49,380 --> 00:11:53,970
modeled after the node.js parser which

00:11:51,750 --> 00:11:56,700
is pretty cool pretty fast a lot of

00:11:53,970 --> 00:11:59,160
people use it this parser is stateless

00:11:56,700 --> 00:12:01,530
it doesn't allocate any memory and it's

00:11:59,160 --> 00:12:04,620
totally self-contained so if you were to

00:12:01,530 --> 00:12:06,870
get beast's parser and reuse it in your

00:12:04,620 --> 00:12:09,650
own project without the rest of it I

00:12:06,870 --> 00:12:13,290
won't be offended and it'll work for you

00:12:09,650 --> 00:12:16,020
so in summary I would like to think that

00:12:13,290 --> 00:12:19,950
if the author of boost SEO was to write

00:12:16,020 --> 00:12:21,840
on HTTP or WebSocket library he would

00:12:19,950 --> 00:12:26,040
write something whose interfaces looked

00:12:21,840 --> 00:12:27,540
very much like this I have a couple of

00:12:26,040 --> 00:12:30,540
extra minutes so I will just quickly

00:12:27,540 --> 00:12:32,850
show you the performance of the parser

00:12:30,540 --> 00:12:35,160
so everything in beast was designed to

00:12:32,850 --> 00:12:38,400
be sensitive to performance it competes

00:12:35,160 --> 00:12:39,960
very favorably this is what the message

00:12:38,400 --> 00:12:42,210
container looks like you can see it's

00:12:39,960 --> 00:12:43,950
very simple there's the headers and then

00:12:42,210 --> 00:12:46,320
there's the body and there's a little

00:12:43,950 --> 00:12:48,900
bit more but for exposition I've left

00:12:46,320 --> 00:12:53,220
that stuff out you can check it out in

00:12:48,900 --> 00:12:55,260
the repository so there's a box of

00:12:53,220 --> 00:12:56,730
brochures if you after if you want to

00:12:55,260 --> 00:12:58,260
talk to me or if you want to step up and

00:12:56,730 --> 00:13:00,720
grab a brochure so you can get the URL

00:12:58,260 --> 00:13:03,750
or you can see that sample code help

00:13:00,720 --> 00:13:05,430
yourself to it and I appreciate the

00:13:03,750 --> 00:13:07,860
great job that the organizers have done

00:13:05,430 --> 00:13:11,120
and giving me the opportunity to present

00:13:07,860 --> 00:13:11,120

YouTube URL: https://www.youtube.com/watch?v=uJZgRcvPFwI


