Title: CppCon 2016: Jon Kalb “unsigned: A Guideline for Better Code"
Publication date: 2016-10-08
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,020 --> 00:00:05,700
This is half of a Lightning Talk duel between James McNellis and I.

00:00:05,720 --> 00:00:10,260
He was commenting on Twitter about signed, unsigned,

00:00:10,260 --> 00:00:15,660
and I took a contrary position. I said: "Let's fight this out in Lightning Talks at CppCon".

00:00:15,660 --> 00:00:20,560
So you're going to see mine tonight. I'm not sure when James has scheduled his.

00:00:20,560 --> 00:00:25,170
We will find that out in the future. The question is "What does this code do?"

00:00:25,170 --> 00:00:30,280
Because we are pressed for time, I'm going to tell you that it's going to compare a signed and an unsigned integer.

00:00:30,280 --> 00:00:38,300
We have some questions, the first is "Is this going to compile?" Yeah, it compiles. Is it perhaps undefined behavior?

00:00:38,300 --> 00:00:46,480
No, it's not undefined behavior. But the question is "What is it going to do? What is it going to print?"

00:00:46,500 --> 00:00:50,480
It's going to print else: "a is not less than b".

00:00:50,480 --> 00:00:51,700
See? This is the thing.

00:00:51,700 --> 00:00:56,140
I think even James McNellis would understand that negative one is less than one.

00:00:56,160 --> 00:01:02,380
The question is: Is this what you expected?

00:01:02,380 --> 00:01:06,600
Now... We all know that C++ programmers are an amazingly good-looking group

00:01:06,600 --> 00:01:09,700
but more than that they're in the top half of the intelligence pool.

00:01:09,720 --> 00:01:13,340
And you are all at CppCon. So, you're even higher up.

00:01:13,340 --> 00:01:18,140
You probably did expect this, but that's not the question we have to answer.

00:01:18,180 --> 00:01:24,040
The question is "What will other programmers expect?", "What will your coworkers expect?",

00:01:24,040 --> 00:01:29,480
or any random sample of the 4.4 million C++ programmers on the planet.

00:01:29,480 --> 00:01:31,700
What are they going to expect? And the problem is

00:01:31,700 --> 00:01:37,180
that most of them are going to be surprised by the unsigned integer promotion rules.

00:01:37,440 --> 00:01:44,080
What kind of advice can we give them? What's the guideline that's going to help?

00:01:44,180 --> 00:01:47,320
Well, we could give them a guideline like that but

00:01:47,380 --> 00:01:51,120
I'm not really gonna go along with that. So we're not gonna do that.

00:01:51,120 --> 00:01:56,640
We could do that. That's not really that much better. Is it?

00:01:56,640 --> 00:02:04,660
OK. I believe strongly in the power of positive thinking. But I don't think

00:02:04,760 --> 00:02:09,700
we're going to be able to write non-trivial applications that never use negative numbers.

00:02:09,760 --> 00:02:13,820
So how about "Don't do math on unsigned types"?

00:02:13,880 --> 00:02:20,640
This was actually advice that I got from an acknowledged C++ expert, when I was asking about this issue

00:02:20,640 --> 00:02:26,520
and what he thought about it. And this is what he said, (this was a private conversation) and he said:

00:02:26,520 --> 00:02:30,000
"It's an unsigned type, you don't do math on it".

00:02:30,020 --> 00:02:37,500
Or we could say: "Don't mix signed and unsigned", because that's the real issue here, right?

00:02:37,500 --> 00:02:39,580
It's the promotion rules. But the problem is

00:02:39,580 --> 00:02:45,340
if you have them in the same application they're going to get mixed. So the question is "Can you have an application

00:02:45,340 --> 00:02:51,100
entirely made up of unsigned types?", I think that's back to the same rule of not using negative numbers.

00:02:51,100 --> 00:02:55,440
Here's my guideline. Here's my recommendation to you, and that is

00:02:55,440 --> 00:02:57,940
"Don't use unsigned for quantities".

00:02:57,940 --> 00:03:02,600
What does that mean? Does that mean "Don't use unsigned"? I mean, aren't integers quantities?

00:03:02,600 --> 00:03:04,980
It doesn't really mean that. Treat it like this:

00:03:04,980 --> 00:03:09,760
Unsigned means it's a bit mask, right? So that means what?

00:03:09,760 --> 00:03:15,120
That means low-level hardware operations. That means bitwise logical operations.

00:03:15,120 --> 00:03:20,700
That means you could use them for character sets because the bits represents a character, right?

00:03:20,780 --> 00:03:25,260
Maybe we have a data structure that's made of bits like a bitmap or a big int.

00:03:25,260 --> 00:03:30,480
Those are all perfectly good reasons to use your bit mask object or your unsigned.

00:03:30,480 --> 00:03:36,760
But don't use things where you're going to compare magnitudes or where you're going to perform mathematical operations.

00:03:36,760 --> 00:03:41,600
Because these things are going to have unexpected promotion rules.

00:03:41,600 --> 00:03:51,100
I'm hearing all... Of course, people are going to be argumentative, and there's a James McNellis in every audience.

00:03:51,100 --> 00:03:59,100
So people are gonna say "Wait a minute. This is so descriptive, it helps me to communicate about my ...".

00:04:14,480 --> 00:04:20,140
So people will say: "This is an excellent way of documenting my API".

00:04:20,140 --> 00:04:25,120
And I would say: "No. Documentation is a good way to communicate something about your API".

00:04:25,140 --> 00:04:31,060
Using things like unsigned types to communicate that it would be a bug if it were negative,

00:04:31,060 --> 00:04:35,900
is in fact hiding those bugs. If your code actually returned a negative number

00:04:35,900 --> 00:04:41,320
because of a bug in your code and it got cast to an unsigned you would not see that bug.

00:04:41,320 --> 00:04:44,900
You would be hiding the bug rather than revealing the bug, which is what we would like to see.

00:04:44,900 --> 00:04:50,840
So what about this? Using unsigned types gives me a greater range of positive values.

00:04:50,840 --> 00:04:53,780
I just don't buy it. If you need that extra bit

00:04:53,780 --> 00:04:57,740
you're almost certainly going to eventually overrun that extra bit. A sneeze puts you overrun.

00:04:57,740 --> 00:05:00,520
We don't want that. Just use a larger data type.

00:05:00,520 --> 00:05:04,780
What about this? The Standard Library used unsigned types.

00:05:04,820 --> 00:05:12,340
(size_t is required to be unsigned) all over the place. And that's true, you got me. It does.

00:05:12,340 --> 00:05:16,220
Because they had to have a way that, when you return malloc

00:05:16,220 --> 00:05:22,560
you might want to malloc half the size of your address space in a single call. Because that's the kind of thing we do all the time.

00:05:22,560 --> 00:05:27,460
So the standard requires that size_t be on site. That's an ugly wart.

00:05:27,460 --> 00:05:29,820
We may fix it in... you know... std2,

00:05:29,820 --> 00:05:36,240
but that's not the point, the point is that if you can't program in a language with ugly warts

00:05:36,240 --> 00:05:41,440
maybe C++ isn't the language you should be programming in.

00:05:41,440 --> 00:05:44,340
So here're my recommendations:

00:05:44,420 --> 00:05:49,000
* Select the types for the operations they support not the range of values.

00:05:49,100 --> 00:05:53,260
* Don't use unsigned types in your API this hides bugs.

00:05:53,260 --> 00:05:54,200
and

00:05:54,260 --> 00:05:57,240
* Don't use unsigneds for quantities.

00:05:57,640 --> 00:05:59,820
Don't use unsigned for quantities.

00:06:00,140 --> 00:06:02,900
Thank you very much.

00:06:03,700 --> 00:06:07,200

YouTube URL: https://www.youtube.com/watch?v=wvtFGa6XJDU


