Title: Debuggability - Abel Mathew [ CppCon 2016 ]
Publication date: 2016-10-07
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,030 --> 00:00:06,779
so a common discussion I have with

00:00:02,280 --> 00:00:09,599
people is GCC versus Sealink but the way

00:00:06,779 --> 00:00:12,980
they kind of compare compilers typically

00:00:09,599 --> 00:00:15,870
ends up being with a couple of criteria

00:00:12,980 --> 00:00:17,190
performance warning or error messages

00:00:15,870 --> 00:00:20,279
and that's kind of where the

00:00:17,190 --> 00:00:22,529
conversation stops but what I do in my

00:00:20,279 --> 00:00:24,480
day job is actually look at debuggers

00:00:22,529 --> 00:00:26,580
and I look at them a lot and look at

00:00:24,480 --> 00:00:28,980
their output but whether it's on Linux

00:00:26,580 --> 00:00:30,689
systems and dwarf information and the

00:00:28,980 --> 00:00:34,320
debug ability of binaries that produce

00:00:30,689 --> 00:00:37,020
and so about a year ago I asked myself I

00:00:34,320 --> 00:00:39,059
wonder what the debug ability difference

00:00:37,020 --> 00:00:41,309
is between binaries produced by GCC

00:00:39,059 --> 00:00:43,710
versus C lank and it's actually it was

00:00:41,309 --> 00:00:45,090
pretty interesting a year ago but before

00:00:43,710 --> 00:00:46,680
we go into that you know what are some

00:00:45,090 --> 00:00:48,000
other ways we can actually compare

00:00:46,680 --> 00:00:50,190
compilers you know there's correctness

00:00:48,000 --> 00:00:52,379
which is obviously very very important

00:00:50,190 --> 00:00:54,390
but not a lot of us do we kind of just

00:00:52,379 --> 00:00:56,460
trust our compilers whether they're

00:00:54,390 --> 00:00:59,340
compliant and whether or not they give

00:00:56,460 --> 00:01:01,140
us good compilation time so what is

00:00:59,340 --> 00:01:02,399
debug ability I don't really have a good

00:01:01,140 --> 00:01:04,500
definition so I pulled this off of

00:01:02,399 --> 00:01:11,130
Wikipedia the extent to which something

00:01:04,500 --> 00:01:12,900
can be debugged not sure so the way I

00:01:11,130 --> 00:01:14,970
think of it is if I've got this thing

00:01:12,900 --> 00:01:17,670
running in production and I have a core

00:01:14,970 --> 00:01:20,610
dump or something of that nature if I

00:01:17,670 --> 00:01:22,380
pull it up into gdb how well can ID bug

00:01:20,610 --> 00:01:25,320
it and the problem is is that compilers

00:01:22,380 --> 00:01:27,119
especially with heavy optimization can

00:01:25,320 --> 00:01:30,150
really screw us over if we're trying to

00:01:27,119 --> 00:01:33,030
actually view this information so a

00:01:30,150 --> 00:01:34,829
symbolic debugger which gdb is will map

00:01:33,030 --> 00:01:36,240
the state of registers in memory back to

00:01:34,829 --> 00:01:39,299
a back trace of variables and type

00:01:36,240 --> 00:01:41,189
information it does that with a very

00:01:39,299 --> 00:01:42,780
convoluted process if anyone's ever

00:01:41,189 --> 00:01:45,540
looked at the door specification it's

00:01:42,780 --> 00:01:47,729
like 200 pages long and there's that I

00:01:45,540 --> 00:01:50,100
know there's tons of information as to

00:01:47,729 --> 00:01:52,140
why that is but it's turing-complete

00:01:50,100 --> 00:01:55,140
it's really complicated it can really

00:01:52,140 --> 00:01:57,990
really be a pain in the ass if you're

00:01:55,140 --> 00:02:00,210
especially if you work with debuggers so

00:01:57,990 --> 00:02:01,530
this is what I settled on it's not

00:02:00,210 --> 00:02:04,079
really good it's not really scientific

00:02:01,530 --> 00:02:06,869
but basically I said any debugger if I

00:02:04,079 --> 00:02:09,300
swap the back trace how many local

00:02:06,869 --> 00:02:12,060
variables can actually resolve based on

00:02:09,300 --> 00:02:14,900
the compiler that I used so did this oh

00:02:12,060 --> 00:02:14,900
nice

00:02:20,040 --> 00:02:31,150
okay so I'm gonna go over five minutes

00:02:22,420 --> 00:02:33,040
so basically si Lang sucked it so this

00:02:31,150 --> 00:02:34,030
is about a year ago I looked at the

00:02:33,040 --> 00:02:35,800
dwarf information

00:02:34,030 --> 00:02:37,690
it was either outputting trash or wasn't

00:02:35,800 --> 00:02:39,430
outputting anything at all and this is

00:02:37,690 --> 00:02:42,340
for different optimization levels Oh -

00:02:39,430 --> 00:02:45,130
Oh zero so even non optimized builds

00:02:42,340 --> 00:02:47,140
looked at this with a toy C++

00:02:45,130 --> 00:02:49,390
application today comparing a more

00:02:47,140 --> 00:02:50,800
recent version so si Lang 3.9 The

00:02:49,390 --> 00:02:53,470
Situation's a little bit better but

00:02:50,800 --> 00:02:55,330
still not up to par with GCC so for all

00:02:53,470 --> 00:02:57,310
you guys that really love si Lang and

00:02:55,330 --> 00:02:59,170
love to use it it's great I think it

00:02:57,310 --> 00:03:00,550
gives me great information and great

00:02:59,170 --> 00:03:02,920
warning messages when I'm actually doing

00:03:00,550 --> 00:03:04,420
development but make sure you consider

00:03:02,920 --> 00:03:07,560
the kind of debug information you get

00:03:04,420 --> 00:03:07,560

YouTube URL: https://www.youtube.com/watch?v=EjwN7Gf8JIs


