Title: CppCon 2016: Atila Neves “Using C++14 to mock C functions"
Publication date: 2016-10-08
Playlist: CppCon 2016 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,080
all right cool so that's my name my

00:00:02,310 --> 00:00:05,819
contact details and I'll be telling you

00:00:04,080 --> 00:00:07,890
how you can mark C functions from C

00:00:05,819 --> 00:00:09,540
poses 14 for testing now why would we

00:00:07,890 --> 00:00:11,340
want to do this well first of us some of

00:00:09,540 --> 00:00:13,259
us have to maintain like a CC code basis

00:00:11,340 --> 00:00:14,639
sucks to be us but what you gonna do not

00:00:13,259 --> 00:00:15,179
testings not an option at least not for

00:00:14,639 --> 00:00:16,619
me

00:00:15,179 --> 00:00:18,240
legacy code is usually not written with

00:00:16,619 --> 00:00:19,170
testability in mind which means the side

00:00:18,240 --> 00:00:21,000
effects everywhere

00:00:19,170 --> 00:00:22,140
modern sequel sauce I think everybody

00:00:21,000 --> 00:00:23,970
here is gonna agree with me is a lot

00:00:22,140 --> 00:00:25,890
better than C so how can we write our

00:00:23,970 --> 00:00:28,859
tests in C++ a test and legacy C goes

00:00:25,890 --> 00:00:30,689
over there now there's a library to

00:00:28,859 --> 00:00:32,340
Kamakshi function CPU tests but I don't

00:00:30,689 --> 00:00:34,110
really like it too much because they

00:00:32,340 --> 00:00:35,489
have design constraints that I don't I

00:00:34,110 --> 00:00:37,140
use a singleton which is a global

00:00:35,489 --> 00:00:38,910
variable although that entails

00:00:37,140 --> 00:00:40,230
it requires linking multiple binary cuz

00:00:38,910 --> 00:00:41,760
it uses the linker to actually link to

00:00:40,230 --> 00:00:43,170
different implementations that means you

00:00:41,760 --> 00:00:44,579
have a bunch of tiny little unit tests

00:00:43,170 --> 00:00:46,710
by and race running all of them as a

00:00:44,579 --> 00:00:48,719
pain the interface is string we typed

00:00:46,710 --> 00:00:50,250
you basically put a string in a hash

00:00:48,719 --> 00:00:51,449
table somewhere saying I expect this to

00:00:50,250 --> 00:00:53,520
be called and then somebody else on the

00:00:51,449 --> 00:00:54,840
other side has to say actually this was

00:00:53,520 --> 00:00:56,730
called and puts the string in there and

00:00:54,840 --> 00:00:58,079
you actually manually have to implement

00:00:56,730 --> 00:00:59,670
the mark which kind of defeats the

00:00:58,079 --> 00:01:01,829
purpose and I thought I could do better

00:00:59,670 --> 00:01:03,000
with macros and template madness so I

00:01:01,829 --> 00:01:04,860
called it pre mark is uses the

00:01:03,000 --> 00:01:07,650
preprocessor to mark stuff instead and

00:01:04,860 --> 00:01:09,210
it's up there and gear alright so what

00:01:07,650 --> 00:01:10,619
is it imagine you have a production

00:01:09,210 --> 00:01:12,960
function called foo in a file called foo

00:01:10,619 --> 00:01:14,010
dot C now this function is calling sand

00:01:12,960 --> 00:01:15,780
and you don't want to do that because

00:01:14,010 --> 00:01:17,250
side-effects and where you're testing

00:01:15,780 --> 00:01:19,740
your bad because you want determinism

00:01:17,250 --> 00:01:21,479
and all the good stuff so contrived

00:01:19,740 --> 00:01:23,070
example but lightning talk it just calls

00:01:21,479 --> 00:01:25,049
sands which returns the same thing send

00:01:23,070 --> 00:01:26,520
does passes the file descriptor doesn't

00:01:25,049 --> 00:01:29,400
actually really do anything because it's

00:01:26,520 --> 00:01:30,540
no etc now in your test file you're

00:01:29,400 --> 00:01:32,490
gonna have a block there the blocks

00:01:30,540 --> 00:01:34,259
there on purpose because of rei i and

00:01:32,490 --> 00:01:36,600
that's because if you use the replace

00:01:34,259 --> 00:01:38,640
macro from my library you can say

00:01:36,600 --> 00:01:40,950
replace sand and then replace it with

00:01:38,640 --> 00:01:42,570
this lambda until the end of scope but

00:01:40,950 --> 00:01:44,009
only until then now this has good

00:01:42,570 --> 00:01:45,570
benefits because you don't something any

00:01:44,009 --> 00:01:46,740
other unit tests to come afterwards that

00:01:45,570 --> 00:01:49,110
might not care if you send packets or

00:01:46,740 --> 00:01:51,149
not or actually do so only replace the

00:01:49,110 --> 00:01:53,640
implementation until then so if i

00:01:51,149 --> 00:01:54,840
replace and with the altered or because

00:01:53,640 --> 00:01:57,030
i'm lazy don't care where you passing me

00:01:54,840 --> 00:01:58,680
in return seven i can assert like if i

00:01:57,030 --> 00:01:59,700
call foo was zero I get back the number

00:01:58,680 --> 00:02:01,020
seven because all it's doing is

00:01:59,700 --> 00:02:03,780
returning the return volley from said

00:02:01,020 --> 00:02:05,969
now the block ends I call foo zero again

00:02:03,780 --> 00:02:08,160
now returns -1 why because it's calling

00:02:05,969 --> 00:02:09,599
San Francisco kit and zero isn't a valid

00:02:08,160 --> 00:02:12,000
file descriptor so you have to go look

00:02:09,599 --> 00:02:13,290
at Erin or the other thing you can do

00:02:12,000 --> 00:02:14,040
with this if you don't want to pass in a

00:02:13,290 --> 00:02:15,269
lambda is

00:02:14,040 --> 00:02:17,939
actually mark it with programmability

00:02:15,269 --> 00:02:19,829
mind so you go Auto M equals Mach the

00:02:17,939 --> 00:02:21,870
macro sent as a function you want to

00:02:19,829 --> 00:02:23,280
mock out you set the return value to

00:02:21,870 --> 00:02:24,629
five if I call food with three I get

00:02:23,280 --> 00:02:26,790
five back because that's what return

00:02:24,629 --> 00:02:28,920
volley was I can also certainly expect

00:02:26,790 --> 00:02:30,510
called with values and then three and

00:02:28,920 --> 00:02:32,250
then the other stuff you saw and the

00:02:30,510 --> 00:02:33,750
slide just there because I passed three

00:02:32,250 --> 00:02:35,430
to it yeah I can also do this for

00:02:33,750 --> 00:02:37,230
multiple return values and then I can

00:02:35,430 --> 00:02:38,670
expect called with values there should

00:02:37,230 --> 00:02:40,620
be a two in expect called there actually

00:02:38,670 --> 00:02:42,030
so I expect to call twice with values

00:02:40,620 --> 00:02:43,799
and now I have to pass tuples so I can

00:02:42,030 --> 00:02:45,359
have multiple parameter lists the past

00:02:43,799 --> 00:02:46,980
of this thing now all of this is type

00:02:45,359 --> 00:02:48,810
safe right I can't pass in the wrong

00:02:46,980 --> 00:02:49,889
number of arguments and I can't pass in

00:02:48,810 --> 00:02:54,569
the wrong types either that won't

00:02:49,889 --> 00:02:55,950
compile how do I do this well first you

00:02:54,569 --> 00:02:57,299
need to actually include the header file

00:02:55,950 --> 00:02:59,159
because this is a header only library

00:02:57,299 --> 00:03:00,269
and what you need to do for every

00:02:59,159 --> 00:03:02,159
function that you want to be able to

00:03:00,269 --> 00:03:04,379
mark is three different things one you

00:03:02,159 --> 00:03:07,049
need to use this macro deckle mark on

00:03:04,379 --> 00:03:08,459
send I'm including so socket to actually

00:03:07,049 --> 00:03:11,069
know what send is that's not a string

00:03:08,459 --> 00:03:12,629
that's a symbol and then you need to

00:03:11,069 --> 00:03:14,400
actually implement this needs runtime

00:03:12,629 --> 00:03:15,720
support obviously but you don't need to

00:03:14,400 --> 00:03:17,700
write the code because I have a macro to

00:03:15,720 --> 00:03:19,560
do it for you so you include the

00:03:17,700 --> 00:03:21,120
previous header you have now you use

00:03:19,560 --> 00:03:23,190
this different macro called implement

00:03:21,120 --> 00:03:25,229
default with the send function in there

00:03:23,190 --> 00:03:28,349
and then you have to compile your

00:03:25,229 --> 00:03:30,389
production code with either - G switch

00:03:28,349 --> 00:03:32,489
every single instance of Santa you T

00:03:30,389 --> 00:03:34,680
underscore sent or you can put that in a

00:03:32,489 --> 00:03:36,510
header file then - include that so you

00:03:34,680 --> 00:03:37,799
can so you have you need some build

00:03:36,510 --> 00:03:38,849
system support for this but this is

00:03:37,799 --> 00:03:40,290
literally all you have to do and

00:03:38,849 --> 00:03:43,049
everything I just showed you just works

00:03:40,290 --> 00:03:44,819
now notice also what's not here I'm not

00:03:43,049 --> 00:03:46,739
telling the system or the framework in

00:03:44,819 --> 00:03:48,599
this case anything about sin I'm not

00:03:46,739 --> 00:03:50,370
there's no return type anywhere there's

00:03:48,599 --> 00:03:52,440
no argument list the only thing I can

00:03:50,370 --> 00:03:54,510
get rid of is that 4 and that 4 is the

00:03:52,440 --> 00:03:56,400
number of parameters that sin takes and

00:03:54,510 --> 00:03:58,049
I'd literally can't see any other way of

00:03:56,400 --> 00:03:58,919
doing this but you do this your

00:03:58,049 --> 00:04:00,989
functions are marked

00:03:58,919 --> 00:04:03,979
everything's nice and the worlds

00:04:00,989 --> 00:04:03,979

YouTube URL: https://www.youtube.com/watch?v=Nk3A0SiqJ8k


