Title: CppCon 2018: Tsung-Wei Huang “Fast Parallel Programming using Modern C++”
Publication date: 2018-11-11
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,350
all right good evenin everybody thank

00:00:02,610 --> 00:00:07,259
you for thank you so much for being here

00:00:04,350 --> 00:00:09,690
and today I'm going to talk about fast

00:00:07,259 --> 00:00:12,059
parallel programming you see modern C++

00:00:09,690 --> 00:00:13,830
and I'm going to show you a very cool

00:00:12,059 --> 00:00:15,839
open source project called CTP task flow

00:00:13,830 --> 00:00:17,550
and it's an open source project out how

00:00:15,839 --> 00:00:21,570
to make a parallel programming easier to

00:00:17,550 --> 00:00:24,420
handle and I believe everyone over here

00:00:21,570 --> 00:00:26,430
agrees parallel programming is a super

00:00:24,420 --> 00:00:27,720
important skill and you should have to

00:00:26,430 --> 00:00:30,269
know that right

00:00:27,720 --> 00:00:31,920
and it's all about how to maximize the

00:00:30,269 --> 00:00:34,320
performance of your software and

00:00:31,920 --> 00:00:36,030
hardware so you can skill up your

00:00:34,320 --> 00:00:39,629
program of course a different number of

00:00:36,030 --> 00:00:41,940
CPUs and at the same time so the real

00:00:39,629 --> 00:00:44,550
programming is none of them it's not a

00:00:41,940 --> 00:00:46,710
very trivial task to do and the main

00:00:44,550 --> 00:00:49,230
reason to this is the TAS dependency

00:00:46,710 --> 00:00:52,079
some TAS has to finish peoples and other

00:00:49,230 --> 00:00:54,449
tasks and some TAS has to finish after

00:00:52,079 --> 00:00:57,090
some other tasks and because of this

00:00:54,449 --> 00:00:59,460
dependency we always have to worry about

00:00:57,090 --> 00:01:02,100
be very careful about the race condition

00:00:59,460 --> 00:01:04,769
when we create multiple tasks to help us

00:01:02,100 --> 00:01:07,290
do multiple things at the same time then

00:01:04,769 --> 00:01:09,299
we use lock to protect the session of

00:01:07,290 --> 00:01:11,010
the closer to the only one track then

00:01:09,299 --> 00:01:13,049
assess a particular region at the same

00:01:11,010 --> 00:01:15,570
time and this also give rise to the

00:01:13,049 --> 00:01:17,070
issue of track contention multiple

00:01:15,570 --> 00:01:19,470
threads are waiting for the lock owner

00:01:17,070 --> 00:01:21,540
to reduce the resource of the lab while

00:01:19,470 --> 00:01:24,140
they are not actually doing anything but

00:01:21,540 --> 00:01:27,299
taking really a lot of recipie resources

00:01:24,140 --> 00:01:29,610
and if something goes wrong we move to

00:01:27,299 --> 00:01:32,130
the most painful state which is

00:01:29,610 --> 00:01:35,900
debugging and we all agree debugging a

00:01:32,130 --> 00:01:35,900
parallel program is extremely painful

00:01:36,200 --> 00:01:42,180
with that being say people try really

00:01:39,119 --> 00:01:43,950
hard to jaco a lot of time that has

00:01:42,180 --> 00:01:46,229
dependency when writing a parallel

00:01:43,950 --> 00:01:47,970
program for example suppose we are

00:01:46,229 --> 00:01:49,680
running in a Kitchen Bouquet we will

00:01:47,970 --> 00:01:52,439
have two line cooks working on the meat

00:01:49,680 --> 00:01:53,880
and garnish one chef working on the

00:01:52,439 --> 00:01:56,880
plate in putting together mint and

00:01:53,880 --> 00:01:58,649
garnish together to the place and two

00:01:56,880 --> 00:02:00,930
waiters stew in the service and

00:01:58,649 --> 00:02:04,619
delivering food to two hungry diners and

00:02:00,930 --> 00:02:06,780
like you can see we have five tasks +4

00:02:04,619 --> 00:02:09,860
dependencies and we can now start

00:02:06,780 --> 00:02:12,569
plating until mid and garnish or finish

00:02:09,860 --> 00:02:13,920
similarly we cannot serve food until

00:02:12,569 --> 00:02:17,220
plating finishes

00:02:13,920 --> 00:02:19,440
well in terms of a C++ scope we usually

00:02:17,220 --> 00:02:23,220
clarify class to represent our kitchen

00:02:19,440 --> 00:02:27,030
pre-k cook one cook - chef waiter one

00:02:23,220 --> 00:02:29,670
away - - and then we will create three

00:02:27,030 --> 00:02:32,700
variables so initialized to false to

00:02:29,670 --> 00:02:36,930
represent the state of the you know the

00:02:32,700 --> 00:02:38,670
readiness of these dishes then when cook

00:02:36,930 --> 00:02:39,570
one finish the garnish he will map the

00:02:38,670 --> 00:02:42,930
variable to chew

00:02:39,570 --> 00:02:46,980
similarly when cook to finish the mid he

00:02:42,930 --> 00:02:50,100
will mock the variable to chew when chef

00:02:46,980 --> 00:02:52,890
and he can not when chef start his task

00:02:50,100 --> 00:02:53,910
he can now he has to spin wait on these

00:02:52,890 --> 00:02:56,940
two variables

00:02:53,910 --> 00:02:57,959
until that become true before they came

00:02:56,940 --> 00:03:00,720
before he can move to the next

00:02:57,959 --> 00:03:02,550
instruction and similarly for waiter one

00:03:00,720 --> 00:03:05,360
and waited two they have to spin wait on

00:03:02,550 --> 00:03:07,230
this variable and when they become true

00:03:05,360 --> 00:03:10,260
before he get moved to the next

00:03:07,230 --> 00:03:12,270
instruction well this is a solution but

00:03:10,260 --> 00:03:14,670
everything is very pretty much

00:03:12,270 --> 00:03:16,500
hard-coded and we explicitly create

00:03:14,670 --> 00:03:18,570
trash - Lisa

00:03:16,500 --> 00:03:20,310
atomic variables to do this a manual

00:03:18,570 --> 00:03:21,989
lock in control and this is just turns

00:03:20,310 --> 00:03:23,850
out to be very nasty and we don't like

00:03:21,989 --> 00:03:28,620
this this code doesn't skill out very

00:03:23,850 --> 00:03:30,330
well so we come up with a better

00:03:28,620 --> 00:03:32,489
solution in the open source project

00:03:30,330 --> 00:03:35,130
cause it if it has flow in the National

00:03:32,489 --> 00:03:37,320
City Beautiful City C++ header on the

00:03:35,130 --> 00:03:39,540
library to help you quickly peel

00:03:37,320 --> 00:03:41,700
parallel program with past dependencies

00:03:39,540 --> 00:03:43,410
and this is how it looks with sleep it

00:03:41,700 --> 00:03:45,660
has flow to the previous example so

00:03:43,410 --> 00:03:49,200
first we will create a test flow object

00:03:45,660 --> 00:03:50,820
to represent the location flow and then

00:03:49,200 --> 00:03:53,850
we were grateful I'll create a fight

00:03:50,820 --> 00:03:56,040
task for cook one cook two chef waiter

00:03:53,850 --> 00:03:59,100
one waiter - and then we will use the

00:03:56,040 --> 00:04:01,950
matter proceed in some a couple sit over

00:03:59,100 --> 00:04:04,709
here to represent which tasks has to run

00:04:01,950 --> 00:04:07,350
before which task and which tile has to

00:04:04,709 --> 00:04:09,180
run after other tasks and once we

00:04:07,350 --> 00:04:11,850
specify this precedence between

00:04:09,180 --> 00:04:14,730
different tasks then we can use this wet

00:04:11,850 --> 00:04:16,200
formatter to dispatch the task and the

00:04:14,730 --> 00:04:18,150
task flow option will automatically

00:04:16,200 --> 00:04:19,590
handle all these typical concurrency

00:04:18,150 --> 00:04:22,109
control for you you don't really need to

00:04:19,590 --> 00:04:24,510
worry about those trial management and

00:04:22,109 --> 00:04:26,880
block control by yourself which turns

00:04:24,510 --> 00:04:29,440
out to be very tedious

00:04:26,880 --> 00:04:31,270
we also support animate asking and this

00:04:29,440 --> 00:04:34,240
is a very powerful feature of the

00:04:31,270 --> 00:04:35,890
library and this is a way for you to

00:04:34,240 --> 00:04:37,390
create the test defensing test

00:04:35,890 --> 00:04:39,910
dependency crack at the wrong time

00:04:37,390 --> 00:04:41,560
and particularly very useful for many

00:04:39,910 --> 00:04:43,780
application where you cannot decide that

00:04:41,560 --> 00:04:48,550
past dependency graph before running the

00:04:43,780 --> 00:04:50,380
program so feel free to check out our

00:04:48,550 --> 00:04:52,740
github and give it a try

00:04:50,380 --> 00:04:58,610
thank you

00:04:52,740 --> 00:04:58,610

YouTube URL: https://www.youtube.com/watch?v=ho9bqIJkvkc


