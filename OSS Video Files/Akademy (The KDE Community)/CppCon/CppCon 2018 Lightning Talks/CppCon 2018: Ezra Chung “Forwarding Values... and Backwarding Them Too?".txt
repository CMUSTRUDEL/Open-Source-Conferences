Title: CppCon 2018: Ezra Chung “Forwarding Values... and Backwarding Them Too?"
Publication date: 2018-11-10
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,879
so hi I'm Ezra I'm go by eros ATP on the

00:00:03,540 --> 00:00:07,230
slack team I'm graduating this December

00:00:05,879 --> 00:00:09,780
thank you for the introduction

00:00:07,230 --> 00:00:11,370
so this talk will assume you are

00:00:09,780 --> 00:00:12,870
familiar with value categories and type

00:00:11,370 --> 00:00:14,160
deduction if you need a quick refresher

00:00:12,870 --> 00:00:18,449
please refer to the links in your own

00:00:14,160 --> 00:00:19,710
time so so I'm sure everyone here is

00:00:18,449 --> 00:00:20,910
familiar with the forwarding problem we

00:00:19,710 --> 00:00:23,039
have some target function which

00:00:20,910 --> 00:00:25,890
overloads based on 2l value or R value

00:00:23,039 --> 00:00:27,720
arguments too so that we can control

00:00:25,890 --> 00:00:30,090
behavior based on expected lifetime or

00:00:27,720 --> 00:00:32,399
ownership semantics of our argument but

00:00:30,090 --> 00:00:33,870
how do we preserve the value category of

00:00:32,399 --> 00:00:37,079
our argument through an intermediate

00:00:33,870 --> 00:00:38,969
function we use fording values and stood

00:00:37,079 --> 00:00:41,219
forward as a reminder stood forward as a

00:00:38,969 --> 00:00:43,829
conditional cast to an R value if the

00:00:41,219 --> 00:00:45,780
type T provided is not an L value

00:00:43,829 --> 00:00:47,219
reference this works nicely with how for

00:00:45,780 --> 00:00:49,890
doing references work there are many

00:00:47,219 --> 00:00:51,840
talks on this so I'll be moving on what

00:00:49,890 --> 00:00:54,090
I was concerned with is the back waiting

00:00:51,840 --> 00:00:56,070
problem how do we do the reverse suppose

00:00:54,090 --> 00:00:58,980
our source is deep in the function call

00:00:56,070 --> 00:01:01,079
stack and we want to forward or backward

00:00:58,980 --> 00:01:03,780
the value up the call stack to the

00:01:01,079 --> 00:01:06,030
target at a call site so why would you

00:01:03,780 --> 00:01:07,590
want to do this because visitor patterns

00:01:06,030 --> 00:01:09,840
I love the visitor patterns I love using

00:01:07,590 --> 00:01:12,060
lamp expressions and I want to have the

00:01:09,840 --> 00:01:14,280
ability to customize what the result of

00:01:12,060 --> 00:01:15,659
the calling the visitor is suppose I

00:01:14,280 --> 00:01:17,820
have a resource manager type that

00:01:15,659 --> 00:01:20,030
manages some resource and it provides a

00:01:17,820 --> 00:01:22,740
visitor interface where I can pass a

00:01:20,030 --> 00:01:26,210
visitor that is invoked and the result

00:01:22,740 --> 00:01:30,000
from the visitors invocation is returned

00:01:26,210 --> 00:01:32,670
so a lot of people start and stop with

00:01:30,000 --> 00:01:35,400
Auto this is more or less the semantics

00:01:32,670 --> 00:01:37,320
of house to visit on variants work but

00:01:35,400 --> 00:01:38,970
I'm not satisfied with this because it

00:01:37,320 --> 00:01:40,950
eats up our references there's no way to

00:01:38,970 --> 00:01:44,130
return a reference to something there's

00:01:40,950 --> 00:01:46,409
no way to express ownership semantics in

00:01:44,130 --> 00:01:48,659
the result from our from the results of

00:01:46,409 --> 00:01:51,149
mice to visit function on line 17 and 18

00:01:48,659 --> 00:01:52,680
it's always rude it's always a copy and

00:01:51,149 --> 00:01:55,079
I don't want to do copies I want to

00:01:52,680 --> 00:01:57,780
return a reference sometimes so many

00:01:55,079 --> 00:02:01,740
people might think Otto ref ref is a

00:01:57,780 --> 00:02:03,390
good place to look I declare the type of

00:02:01,740 --> 00:02:06,060
the intermediate results variable on

00:02:03,390 --> 00:02:10,590
line 4 as Auto ref ref I stood for word

00:02:06,060 --> 00:02:12,510
the result and deduce the return type of

00:02:10,590 --> 00:02:13,500
status as an auto reference as well if

00:02:12,510 --> 00:02:15,900
this concerns you

00:02:13,500 --> 00:02:19,290
your intention is good because dangling

00:02:15,900 --> 00:02:20,520
reference is when and unlike when unlike

00:02:19,290 --> 00:02:22,110
the forming problem where we only have

00:02:20,520 --> 00:02:24,480
to care about L value or our value of

00:02:22,110 --> 00:02:25,230
our argument when we're going up call

00:02:24,480 --> 00:02:28,140
stacks we have to worry about

00:02:25,230 --> 00:02:29,490
temporaries and so this notion does not

00:02:28,140 --> 00:02:32,310
work in the PR value case when we're

00:02:29,490 --> 00:02:34,800
returning copy so how do we handle all

00:02:32,310 --> 00:02:37,140
three valley categories l value x value

00:02:34,800 --> 00:02:39,720
and PR value separately the solution is

00:02:37,140 --> 00:02:41,520
deckle type specifically deckle types

00:02:39,720 --> 00:02:43,290
ability to deduce what the value

00:02:41,520 --> 00:02:46,680
category of an expression is if it's an

00:02:43,290 --> 00:02:49,290
L value it returns a t L by reference to

00:02:46,680 --> 00:02:51,239
t if it's an X value it returns an R

00:02:49,290 --> 00:02:54,540
value reference to t if it's a PR value

00:02:51,239 --> 00:02:56,940
expression it just returns t so with the

00:02:54,540 --> 00:03:01,440
help of difficulty auto to simplify our

00:02:56,940 --> 00:03:03,420
syntax we have our solution capture the

00:03:01,440 --> 00:03:05,489
result with Deco type auto return the

00:03:03,420 --> 00:03:08,340
result declared a return type as the

00:03:05,489 --> 00:03:10,620
type auto as well not so the resulting

00:03:08,340 --> 00:03:13,190
type of our visit function will be the

00:03:10,620 --> 00:03:16,470
exact same return type as our visitor

00:03:13,190 --> 00:03:18,690
unless you're on GCC because vehicle

00:03:16,470 --> 00:03:21,780
type auto has issues with deducing the

00:03:18,690 --> 00:03:24,840
value categories of the initialisation

00:03:21,780 --> 00:03:26,430
expression but other compilers complain

00:03:24,840 --> 00:03:29,310
they say you cannot bind an R value

00:03:26,430 --> 00:03:31,530
reference to the type value because the

00:03:29,310 --> 00:03:32,519
expression is an L value so this is

00:03:31,530 --> 00:03:35,160
actually the same problem as the

00:03:32,519 --> 00:03:37,170
forwarding problem the result in line 5

00:03:35,160 --> 00:03:42,180
is an L value we want it to be an R

00:03:37,170 --> 00:03:44,910
value in the case of an X value yes but

00:03:42,180 --> 00:03:46,200
how do we do that conditionally we

00:03:44,910 --> 00:03:47,489
cannot use the stood forward because

00:03:46,200 --> 00:03:49,380
stood forward always returns a reference

00:03:47,489 --> 00:03:51,540
so we'll have the reference we have the

00:03:49,380 --> 00:03:53,400
dangling issue all over again the

00:03:51,540 --> 00:03:54,060
solution again is the co type but for a

00:03:53,400 --> 00:03:55,799
different reason

00:03:54,060 --> 00:03:59,850
dekel type is used to inspect a declared

00:03:55,799 --> 00:04:02,820
type of certain eight expressions so the

00:03:59,850 --> 00:04:06,200
true true solution is to cast it to deco

00:04:02,820 --> 00:04:06,200
type result result

00:04:06,709 --> 00:04:11,550
so now we have perfect forwarding up the

00:04:09,930 --> 00:04:13,709
function call stack to where I want to

00:04:11,550 --> 00:04:15,030
use it so in conclusion when your

00:04:13,709 --> 00:04:16,530
forwarding primer type is forwarding

00:04:15,030 --> 00:04:18,530
references and you used it forward for

00:04:16,530 --> 00:04:22,109
conditional casting to our values and

00:04:18,530 --> 00:04:23,520
there's that commonly used of macro but

00:04:22,109 --> 00:04:25,020
when you're back wording the return

00:04:23,520 --> 00:04:27,030
types repeat echo type auto return

00:04:25,020 --> 00:04:28,650
operand should have a cast to declare

00:04:27,030 --> 00:04:30,600
type e where e is the thing you want to

00:04:28,650 --> 00:04:32,430
return and if you want some nice

00:04:30,600 --> 00:04:34,620
symmetry you can define your backward

00:04:32,430 --> 00:04:36,240
function as almost identical to the

00:04:34,620 --> 00:04:38,640
forward macro but without your double

00:04:36,240 --> 00:04:42,759
rest thank you very much

00:04:38,640 --> 00:04:42,759

YouTube URL: https://www.youtube.com/watch?v=hwT8K3-NH1w


