Title: CppCon 2018: Chuck Wilcox “Zero-Overhead Compiler Pessimization”
Publication date: 2018-11-11
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,370
okay my name is Chuck will Cox I work at

00:00:03,060 --> 00:00:08,040
MathWorks I'm the boss and secrets Plus

00:00:05,370 --> 00:00:10,559
meetup organizer and today I'm going to

00:00:08,040 --> 00:00:14,040
present about zero overhead compiler

00:00:10,559 --> 00:00:16,500
pessimism I can think of at least three

00:00:14,040 --> 00:00:20,010
cases where you would want to do this

00:00:16,500 --> 00:00:21,660
the first one is atomic operations where

00:00:20,010 --> 00:00:23,100
you're telling the compiler not to do

00:00:21,660 --> 00:00:24,269
certain optimizations that would

00:00:23,100 --> 00:00:27,689
interfere with inter process

00:00:24,269 --> 00:00:29,849
communication and anyone who's used the

00:00:27,689 --> 00:00:31,230
standard atomic library this is

00:00:29,849 --> 00:00:34,980
effectively what you're telling the

00:00:31,230 --> 00:00:38,250
compiler to partially do the other case

00:00:34,980 --> 00:00:40,140
is the new attribute likely and unlikely

00:00:38,250 --> 00:00:42,270
on branches you're actually telling the

00:00:40,140 --> 00:00:45,000
compiler to do something that it thinks

00:00:42,270 --> 00:00:46,050
is against its understanding of what's

00:00:45,000 --> 00:00:49,440
the best thing for the system

00:00:46,050 --> 00:00:51,629
performance but I'm not here to talk

00:00:49,440 --> 00:00:57,059
about either of those two today I'm here

00:00:51,629 --> 00:00:59,789
to talk about benchmarking usually when

00:00:57,059 --> 00:01:02,340
you're doing micro benchmarks the

00:00:59,789 --> 00:01:03,809
compiler can kind of do tricks on you to

00:01:02,340 --> 00:01:09,450
make you think you're measuring

00:01:03,809 --> 00:01:11,460
something you're not specifically when

00:01:09,450 --> 00:01:13,110
we write micro benchmarks we write a

00:01:11,460 --> 00:01:14,640
little snippet of code that really

00:01:13,110 --> 00:01:17,549
doesn't affect the rest of the state of

00:01:14,640 --> 00:01:20,369
the program and therefore the optimizer

00:01:17,549 --> 00:01:21,990
when it goes through it says hey it's

00:01:20,369 --> 00:01:23,750
not changing anything I'm just gonna get

00:01:21,990 --> 00:01:25,650
rid of the whole thing

00:01:23,750 --> 00:01:27,689
additionally if it's not doing

00:01:25,650 --> 00:01:29,070
side-effects in the abstract state

00:01:27,689 --> 00:01:31,170
machine sense of the word it's not

00:01:29,070 --> 00:01:36,689
interacting with file system or other

00:01:31,170 --> 00:01:38,970
things it can say there's no effect so

00:01:36,689 --> 00:01:43,220
most of the micro benchmark frameworks

00:01:38,970 --> 00:01:45,540
out there have different ways to inject

00:01:43,220 --> 00:01:47,909
calls entry code to make it look like

00:01:45,540 --> 00:01:50,460
you're doing a read or write and that

00:01:47,909 --> 00:01:53,850
the compiler is not going to be able to

00:01:50,460 --> 00:01:57,450
get rid of rid of on you so these are a

00:01:53,850 --> 00:02:06,210
couple from Google Facebook and cell

00:01:57,450 --> 00:02:09,320
arrow but let's see if we can take a

00:02:06,210 --> 00:02:09,320
look at what's really going on

00:02:14,100 --> 00:02:19,630
go

00:02:15,930 --> 00:02:28,000
all right down to 90 seconds awesome

00:02:19,630 --> 00:02:31,720
all right all right so you go to a

00:02:28,000 --> 00:02:35,650
compiler Explorer and we try to write

00:02:31,720 --> 00:02:40,030
the world's simplest benchmarking

00:02:35,650 --> 00:02:42,100
program we have an int we get the clock

00:02:40,030 --> 00:02:45,489
time we increment it we get the clock

00:02:42,100 --> 00:02:47,980
time we subtract the two and return and

00:02:45,489 --> 00:02:51,250
if you look at the assembly we have the

00:02:47,980 --> 00:02:53,530
zero initial value here's the add one

00:02:51,250 --> 00:02:56,920
and the rest of the math is just stack

00:02:53,530 --> 00:02:59,170
operations but for those who might have

00:02:56,920 --> 00:03:00,820
been paying attention it wasn't actually

00:02:59,170 --> 00:03:03,280
optimizing and when you turn the

00:03:00,820 --> 00:03:05,800
optimizer on all the code went away

00:03:03,280 --> 00:03:13,890
except for your two calls to the clock

00:03:05,800 --> 00:03:13,890
time that is not what we wanted so I

00:03:14,370 --> 00:03:20,220
don't have a lot of time to explain

00:03:17,079 --> 00:03:20,220
these but

00:03:31,189 --> 00:03:39,030
all right so if we put in a fake call to

00:03:36,359 --> 00:03:42,450
read after we're done timing you'll

00:03:39,030 --> 00:03:44,310
notice that one magically appears in a

00:03:42,450 --> 00:03:47,459
register but we don't actually have the

00:03:44,310 --> 00:03:58,889
increment so we have to add yet another

00:03:47,459 --> 00:04:01,909
call and now we actually get the ad to

00:03:58,889 --> 00:04:11,989
show up in between the two calls to time

00:04:01,909 --> 00:04:11,989
so first one okay

00:04:12,299 --> 00:04:17,430
anyway the moral is this is actually

00:04:15,359 --> 00:04:20,459
hard to do correctly and if you're ever

00:04:17,430 --> 00:04:22,440
doing benchmarking these are some of the

00:04:20,459 --> 00:04:23,320
issues you're gonna run into thank you

00:04:22,440 --> 00:04:29,380
very much

00:04:23,320 --> 00:04:29,380

YouTube URL: https://www.youtube.com/watch?v=AmmTNBUuqPA


