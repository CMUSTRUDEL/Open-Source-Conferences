Title: CppCon 2018: Nir Friedman “Wise Enum: A C++ Smart Enum For All Your Reflective Enum Needs”
Publication date: 2018-11-10
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,620
hey everyone so this talks on why Xena

00:00:02,429 --> 00:00:07,020
it's a small library that I wrote it's

00:00:04,620 --> 00:00:09,660
almost embarrassingly short by lines of

00:00:07,020 --> 00:00:12,389
code so I know what already you're all

00:00:09,660 --> 00:00:14,309
thinking really another one

00:00:12,389 --> 00:00:17,070
a wise enum library or smart enum

00:00:14,309 --> 00:00:18,690
library this is like the C++ equivalent

00:00:17,070 --> 00:00:21,779
of a to-do app right there's like four

00:00:18,690 --> 00:00:23,640
million of them on the App Store but

00:00:21,779 --> 00:00:25,050
probably kind of like to do options a

00:00:23,640 --> 00:00:27,090
lot of issues with them if you just

00:00:25,050 --> 00:00:29,160
actually if you google search for smart

00:00:27,090 --> 00:00:31,289
enum the first like eight hits are

00:00:29,160 --> 00:00:33,660
random gist's and Stack Overflow

00:00:31,289 --> 00:00:36,030
questions it's not exactly a library you

00:00:33,660 --> 00:00:38,690
would actually want to use until you

00:00:36,030 --> 00:00:41,010
finally come to like a real library so

00:00:38,690 --> 00:00:45,660
it's kind of it's not really a solve

00:00:41,010 --> 00:00:47,280
problem so what is the problem so we

00:00:45,660 --> 00:00:49,050
have an enum we'd like to be able to

00:00:47,280 --> 00:00:50,789
turn into a string we'd like to turn

00:00:49,050 --> 00:00:52,530
strings back into our enums

00:00:50,789 --> 00:00:54,750
we'd like to iterate over them and know

00:00:52,530 --> 00:01:00,629
how many there are that's basically it

00:00:54,750 --> 00:01:02,010
right very useful and not you know not

00:01:00,629 --> 00:01:04,199
that easy to find a library that does

00:01:02,010 --> 00:01:05,729
all that properly and a lot of the

00:01:04,199 --> 00:01:08,760
libraries you'll find have all kinds of

00:01:05,729 --> 00:01:11,220
issues some of them use X macros some of

00:01:08,760 --> 00:01:14,159
them assume that all the enums are like

00:01:11,220 --> 00:01:16,320
the values go from 0 on to like all

00:01:14,159 --> 00:01:17,880
kinds of different problems a lot of

00:01:16,320 --> 00:01:20,240
them don't declare enums they declare

00:01:17,880 --> 00:01:22,740
classes that try to behave like you know

00:01:20,240 --> 00:01:24,509
so we don't have reflection so obviously

00:01:22,740 --> 00:01:26,580
the solution is not going to be pretty

00:01:24,509 --> 00:01:29,100
no matter what so if you take stock of

00:01:26,580 --> 00:01:30,960
your options you know if you manually

00:01:29,100 --> 00:01:32,670
generate code that's bug prone

00:01:30,960 --> 00:01:34,920
if you automatically generate code

00:01:32,670 --> 00:01:38,549
that's in your build system so we'll

00:01:34,920 --> 00:01:40,200
just use macros also ugly so here's what

00:01:38,549 --> 00:01:42,570
the API looks like you're declaring an

00:01:40,200 --> 00:01:45,509
enum you're explicitly setting one of

00:01:42,570 --> 00:01:49,820
the values looks pretty you know

00:01:45,509 --> 00:01:52,829
whatever here's how you would iterate so

00:01:49,820 --> 00:01:55,500
wise enum : : range you throw in the

00:01:52,829 --> 00:02:00,540
name of your enumerator also pretty

00:01:55,500 --> 00:02:02,399
straightforward converting again you

00:02:00,540 --> 00:02:04,259
have two strings you throw it in a

00:02:02,399 --> 00:02:06,390
string comes out if you have a string

00:02:04,259 --> 00:02:08,190
you throw the string in and what comes

00:02:06,390 --> 00:02:11,160
out is actually an optional because if

00:02:08,190 --> 00:02:13,110
no enum has the right string then you'll

00:02:11,160 --> 00:02:14,670
get an empty optional and

00:02:13,110 --> 00:02:16,050
so there's no if you don't use

00:02:14,670 --> 00:02:18,300
exceptions for example you don't have to

00:02:16,050 --> 00:02:20,340
worry if you're doing metaprogramming

00:02:18,300 --> 00:02:22,740
like if you have a logger you might want

00:02:20,340 --> 00:02:25,020
to have the logger log Y Z num

00:02:22,740 --> 00:02:26,970
differently because you know exactly how

00:02:25,020 --> 00:02:29,190
to log it right because you have all the

00:02:26,970 --> 00:02:32,610
strings so you have a type trait so

00:02:29,190 --> 00:02:34,920
supports that no problem so I'll give a

00:02:32,610 --> 00:02:36,210
very sort of quick explanation of how it

00:02:34,920 --> 00:02:38,310
works there's a lot of different

00:02:36,210 --> 00:02:42,150
approaches you could use most of them

00:02:38,310 --> 00:02:44,220
have kind of issues here's the approach

00:02:42,150 --> 00:02:47,040
here so when you do this macro what

00:02:44,220 --> 00:02:48,660
comes out first of all an actual enum

00:02:47,040 --> 00:02:51,510
comes out and like I said a lot of

00:02:48,660 --> 00:02:53,820
libraries don't actually declare enum

00:02:51,510 --> 00:02:55,620
the second thing that happens is it

00:02:53,820 --> 00:02:58,500
throws in a couple of detail functions

00:02:55,620 --> 00:03:01,890
and the detail functions function

00:02:58,500 --> 00:03:04,260
basically takes this tag type and the

00:03:01,890 --> 00:03:07,050
tag types templated on the enum so it's

00:03:04,260 --> 00:03:08,490
found by a DL it's all pretty

00:03:07,050 --> 00:03:11,550
straightforward there's nothing like

00:03:08,490 --> 00:03:15,530
very complicated here but it does work I

00:03:11,550 --> 00:03:18,150
mean so there's that working is good

00:03:15,530 --> 00:03:20,190
okay so now I'm gonna tell you why it's

00:03:18,150 --> 00:03:22,709
good I think so

00:03:20,190 --> 00:03:25,290
first it supports eleven fourteen and

00:03:22,709 --> 00:03:26,970
seventeen and it support each one of

00:03:25,290 --> 00:03:29,010
these idiomatically so for instance if

00:03:26,970 --> 00:03:30,660
you're using fourteen you got template

00:03:29,010 --> 00:03:33,209
variables you don't have to do the nasty

00:03:30,660 --> 00:03:35,430
colon colon value if you're using

00:03:33,209 --> 00:03:39,000
seventeen it works with string view and

00:03:35,430 --> 00:03:40,860
it works with stood optional I already

00:03:39,000 --> 00:03:43,590
talked before about declaring an actual

00:03:40,860 --> 00:03:45,930
enum it supports as far as I know all

00:03:43,590 --> 00:03:48,300
the functionality so you saw already in

00:03:45,930 --> 00:03:50,850
a slide that I gave an explicit value to

00:03:48,300 --> 00:03:53,100
one enumerator you can also explicitly

00:03:50,850 --> 00:03:55,980
declare the storage you could Reeve it

00:03:53,100 --> 00:03:59,280
implicit it works at namespace scope it

00:03:55,980 --> 00:04:00,390
works at class scope pretty much any of

00:03:59,280 --> 00:04:05,130
the things you want to do enum enum

00:04:00,390 --> 00:04:06,810
class obviously you can also adapt a

00:04:05,130 --> 00:04:08,700
third-party enums this is like an

00:04:06,810 --> 00:04:10,340
important feature but one that's kind of

00:04:08,700 --> 00:04:12,540
omitted

00:04:10,340 --> 00:04:14,610
everything's const expert if you do it

00:04:12,540 --> 00:04:18,000
with fourteen or later so absolutely

00:04:14,610 --> 00:04:19,830
everything and also important is that if

00:04:18,000 --> 00:04:21,660
you do the two string conversion for

00:04:19,830 --> 00:04:24,240
example it actually uses a switch case a

00:04:21,660 --> 00:04:26,580
lot of libraries they do all kinds of

00:04:24,240 --> 00:04:28,319
not so nice workarounds either linear

00:04:26,580 --> 00:04:30,539
search which is totally unnecessary

00:04:28,319 --> 00:04:35,729
because you can usually get really good

00:04:30,539 --> 00:04:38,720
assembly from switch-case yeah that's

00:04:35,729 --> 00:04:42,599
pretty much it all right

00:04:38,720 --> 00:04:42,599

YouTube URL: https://www.youtube.com/watch?v=GCkhcT2oxCA


