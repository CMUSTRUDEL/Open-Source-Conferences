Title: CppCon 2018: CJ Johnson “Constexpr and operator overloading: Why everything is terrible”
Publication date: 2018-11-11
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,020
I'm CJ I work in Google New York City

00:00:02,700 --> 00:00:08,580
I'm a software engineer on abseil and

00:00:06,020 --> 00:00:10,260
right there this is AIT that's my little

00:00:08,580 --> 00:00:12,780
team's tagline it's everything is

00:00:10,260 --> 00:00:15,170
terrible and hopefully I can share a

00:00:12,780 --> 00:00:18,750
little bit about why that is

00:00:15,170 --> 00:00:21,330
so background information here we have

00:00:18,750 --> 00:00:23,430
an you know super pared down example

00:00:21,330 --> 00:00:25,260
implementation of optional found in the

00:00:23,430 --> 00:00:30,210
CID namespace also found in the abseil

00:00:25,260 --> 00:00:32,759
namespace in 11 so basically it's a

00:00:30,210 --> 00:00:35,070
backcourt of the the stood version but

00:00:32,759 --> 00:00:36,390
influenced in 11 for users that do not

00:00:35,070 --> 00:00:38,489
are not able upgrade yet like a lot of

00:00:36,390 --> 00:00:40,910
things in the absol library I'd like to

00:00:38,489 --> 00:00:43,649
talk about these particular parts of the

00:00:40,910 --> 00:00:44,910
X one particular part of the API here

00:00:43,649 --> 00:00:46,590
and also the underlying implementation

00:00:44,910 --> 00:00:53,660
that we use and abseil up to this point

00:00:46,590 --> 00:00:57,329
so the fun part let's zoom in on the

00:00:53,660 --> 00:01:01,260
operator arrow does anyone notice

00:00:57,329 --> 00:01:06,000
anything about that implementation yeah

00:01:01,260 --> 00:01:10,740
yeah how about that scary up all right

00:01:06,000 --> 00:01:14,670
so this is invalid this is incorrect

00:01:10,740 --> 00:01:18,150
in the case where T is overloaded we're

00:01:14,670 --> 00:01:25,009
sorry T's operator ref is overloaded so

00:01:18,150 --> 00:01:28,049
what do we do yes stood address of

00:01:25,009 --> 00:01:30,390
except that I didn't tell you if this

00:01:28,049 --> 00:01:31,890
has a Const expert overload and sort of

00:01:30,390 --> 00:01:36,570
dressup is not defined that way in

00:01:31,890 --> 00:01:37,890
eleven so this won't compile ah well

00:01:36,570 --> 00:01:39,900
what I haven't talked about yet is the

00:01:37,890 --> 00:01:42,479
underlying data structure is T is a

00:01:39,900 --> 00:01:44,689
value and we are Union a unioning it

00:01:42,479 --> 00:01:47,189
with dummy value it's just a tag type

00:01:44,689 --> 00:01:48,750
and the reason being we need to directly

00:01:47,189 --> 00:01:51,270
construct T because there's like an

00:01:48,750 --> 00:01:52,500
emplacement based constructor so we

00:01:51,270 --> 00:01:56,850
can't just have like an alliance storage

00:01:52,500 --> 00:01:58,619
for example okay so can we cast our way

00:01:56,850 --> 00:02:01,020
out of this problem since we have that

00:01:58,619 --> 00:02:03,899
dummy well obviously reinterpret cast

00:02:01,020 --> 00:02:07,500
works it's pretty common right not in

00:02:03,899 --> 00:02:09,000
context per sorry no good well okay well

00:02:07,500 --> 00:02:11,760
what does work in context where is

00:02:09,000 --> 00:02:13,990
static cast obviously right so this does

00:02:11,760 --> 00:02:16,070
at least get us

00:02:13,990 --> 00:02:17,240
so we're taking the address of dummy and

00:02:16,070 --> 00:02:19,880
we're casting the void and that does

00:02:17,240 --> 00:02:25,880
work but casting from void is broken

00:02:19,880 --> 00:02:28,760
sorry no no dice all right now can be

00:02:25,880 --> 00:02:30,830
sidestepped the issue this is hands-down

00:02:28,760 --> 00:02:33,140
one of my most favorites like aha

00:02:30,830 --> 00:02:37,250
moments because I almost solve this

00:02:33,140 --> 00:02:40,220
problem almost so what if we actually at

00:02:37,250 --> 00:02:42,800
a length one array of the template type

00:02:40,220 --> 00:02:45,500
that we stored and then we simply decay

00:02:42,800 --> 00:02:48,070
that to a pointer this does work this

00:02:45,500 --> 00:02:50,420
does actually satisfy our requirements

00:02:48,070 --> 00:02:51,320
unfortunately that does not satisfy the

00:02:50,420 --> 00:02:53,060
requirement of like the other

00:02:51,320 --> 00:02:54,620
constructor I talked about earlier where

00:02:53,060 --> 00:02:56,300
we need to directly construct into the

00:02:54,620 --> 00:02:57,200
TE like isn't emplacement back or is

00:02:56,300 --> 00:02:58,760
there an in placement type of a

00:02:57,200 --> 00:03:00,230
conductor and so we cannot do that

00:02:58,760 --> 00:03:02,180
because arrays require a default

00:03:00,230 --> 00:03:04,250
construction so that's not valid either

00:03:02,180 --> 00:03:06,950
unfortunately although I kind of wanted

00:03:04,250 --> 00:03:09,140
to push this anyway because it's just so

00:03:06,950 --> 00:03:13,730
beautiful all right so what did we

00:03:09,140 --> 00:03:16,580
settle on sadly to say we we did end up

00:03:13,730 --> 00:03:18,320
going back to the dress of and dropping

00:03:16,580 --> 00:03:20,510
support for context / temporarily while

00:03:18,320 --> 00:03:22,310
we're in 11 sorry about that

00:03:20,510 --> 00:03:24,950
but these are the trade-offs engineers

00:03:22,310 --> 00:03:26,390
make everything is terrible thank you

00:03:24,950 --> 00:03:33,120
for listening

00:03:26,390 --> 00:03:33,120

YouTube URL: https://www.youtube.com/watch?v=a8-VaKuK594


