Title: CppCon 2018: Jon Kalb “Copy Elision”
Publication date: 2018-11-12
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:06,089
so I want to share something I do in my

00:00:02,520 --> 00:00:08,519
other job which is training I'm going to

00:00:06,089 --> 00:00:10,170
show you slides based on some we're

00:00:08,519 --> 00:00:12,750
quite Dave Abraham's he showed me this

00:00:10,170 --> 00:00:15,000
what I'm about to show you on copy

00:00:12,750 --> 00:00:17,400
lesion and return value optimisation pan

00:00:15,000 --> 00:00:18,630
it totally opened my eyes about that cuz

00:00:17,400 --> 00:00:20,490
I knew what those were

00:00:18,630 --> 00:00:22,260
and but I was always a little dubious

00:00:20,490 --> 00:00:24,300
like how do I know the compiler can

00:00:22,260 --> 00:00:25,800
really do that I was yeah okay people

00:00:24,300 --> 00:00:28,380
talk about it and I just didn't believe

00:00:25,800 --> 00:00:29,789
it I mean so he he showed how it works

00:00:28,380 --> 00:00:32,070
which I'm about to show you in a minute

00:00:29,789 --> 00:00:32,940
and I was like astound it's like that

00:00:32,070 --> 00:00:36,300
makes so much sense

00:00:32,940 --> 00:00:37,890
I now now I get it and so I'm gonna show

00:00:36,300 --> 00:00:40,350
it to you and I hope you appreciate it

00:00:37,890 --> 00:00:42,540
but the day wasn't that wasn't it happy

00:00:40,350 --> 00:00:44,700
I said these are just amazingly said no

00:00:42,540 --> 00:00:48,090
they're not really right so what is it

00:00:44,700 --> 00:00:49,620
great that's a great I learned something

00:00:48,090 --> 00:00:51,539
from this that I will remember forever

00:00:49,620 --> 00:00:52,770
and he said well yeah but technically

00:00:51,539 --> 00:00:54,930
they're not correct because of this and

00:00:52,770 --> 00:00:56,879
this so I said well fine I fixed them so

00:00:54,930 --> 00:00:58,590
this is my fixed version but all the

00:00:56,879 --> 00:01:01,140
credit goes today the real workers yeah

00:00:58,590 --> 00:01:03,750
it's really inspiration so copy illusion

00:01:01,140 --> 00:01:05,580
is based on the fact that the compiler

00:01:03,750 --> 00:01:06,869
is allowed to follow the as if rule

00:01:05,580 --> 00:01:09,689
which is the compiler is allowed to

00:01:06,869 --> 00:01:12,020
generate any code that has the the same

00:01:09,689 --> 00:01:14,100
effect as the code you told it correct

00:01:12,020 --> 00:01:16,830
probably put things different or do all

00:01:14,100 --> 00:01:18,180
sorts of things but there's an addition

00:01:16,830 --> 00:01:21,630
in the standard the standard actually

00:01:18,180 --> 00:01:23,220
says that if if the compiler is told to

00:01:21,630 --> 00:01:24,840
copy something but the copy is not

00:01:23,220 --> 00:01:26,159
really necessary because the original

00:01:24,840 --> 00:01:28,470
isn't going to be used again the

00:01:26,159 --> 00:01:30,240
compiler is allowed to he lied that copy

00:01:28,470 --> 00:01:31,799
and you can tell if they've done that if

00:01:30,240 --> 00:01:34,170
your copy constructor has side effects

00:01:31,799 --> 00:01:35,460
and the standard specifically says that

00:01:34,170 --> 00:01:37,650
your stye defects won't happen the

00:01:35,460 --> 00:01:39,270
compiler is allowed to elide those but

00:01:37,650 --> 00:01:40,829
we not going to show you how and why

00:01:39,270 --> 00:01:43,229
this happens first thing I want to ask

00:01:40,829 --> 00:01:47,490
you though is this this function f how

00:01:43,229 --> 00:01:49,439
many parameters does it take okay

00:01:47,490 --> 00:01:51,360
so some people here are C++ programmers

00:01:49,439 --> 00:01:52,860
and they're all saying zero and some

00:01:51,360 --> 00:01:56,790
people are assembly language programmers

00:01:52,860 --> 00:01:58,680
and they're all saying one does evil

00:01:56,790 --> 00:02:01,229
pose programs saying none but assembly

00:01:58,680 --> 00:02:05,369
language programs say one why what is

00:02:01,229 --> 00:02:06,810
the return value we at the low level

00:02:05,369 --> 00:02:09,720
when we have a return value we have to

00:02:06,810 --> 00:02:12,720
tell the generated code where to put the

00:02:09,720 --> 00:02:13,890
return value so so that's the function

00:02:12,720 --> 00:02:16,010
is passing that address

00:02:13,890 --> 00:02:18,360
all right so this is what's going on our

00:02:16,010 --> 00:02:22,050
function G is going to call our function

00:02:18,360 --> 00:02:24,000
f in order to populate a local so here's

00:02:22,050 --> 00:02:25,980
our stack frame for G no parameters

00:02:24,000 --> 00:02:28,290
passed in but it but it has a local tax

00:02:25,980 --> 00:02:29,970
now we're going to call F and when we

00:02:28,290 --> 00:02:32,040
call F we're gonna have to create the

00:02:29,970 --> 00:02:36,030
stack frame for F which has a parameter

00:02:32,040 --> 00:02:37,110
what's the parameter uh what's the

00:02:36,030 --> 00:02:41,550
address of the return oat which in this

00:02:37,110 --> 00:02:44,760
case is the address of X right okay now

00:02:41,550 --> 00:02:47,550
we execute F and so we create our a

00:02:44,760 --> 00:02:49,140
value and our B value and now we do the

00:02:47,550 --> 00:02:51,330
return and of course the return is going

00:02:49,140 --> 00:02:53,760
to copy a into the address where it's

00:02:51,330 --> 00:02:56,550
copied does everybody see how that

00:02:53,760 --> 00:03:00,180
happens that makes sense and this is how

00:02:56,550 --> 00:03:02,930
your code is written if your compiler

00:03:00,180 --> 00:03:05,640
engineer is a complete and total

00:03:02,930 --> 00:03:07,230
but your compiler engineer is not a

00:03:05,640 --> 00:03:10,860
complete and total what's the

00:03:07,230 --> 00:03:12,360
problem with this you have created

00:03:10,860 --> 00:03:13,920
something only to turn around and copy

00:03:12,360 --> 00:03:15,480
it so that's not how this is actually

00:03:13,920 --> 00:03:17,489
going to work how is this actually gonna

00:03:15,480 --> 00:03:20,070
work what's going to happen is this when

00:03:17,489 --> 00:03:21,690
we call F we're gonna create for the

00:03:20,070 --> 00:03:24,450
separate from F which isn't going to

00:03:21,690 --> 00:03:26,910
have any place for a why because we're

00:03:24,450 --> 00:03:28,890
going to create a where it's eventually

00:03:26,910 --> 00:03:34,650
supposed to be copied to but we're going

00:03:28,890 --> 00:03:37,890
to elide the copy right so this is this

00:03:34,650 --> 00:03:39,810
is the return value optimization so in

00:03:37,890 --> 00:03:42,750
this situation here G can we use the

00:03:39,810 --> 00:03:44,070
return value optimization here no why

00:03:42,750 --> 00:03:45,390
because the whole point of the return

00:03:44,070 --> 00:03:48,420
value optimization is that the compiler

00:03:45,390 --> 00:03:49,500
creates the object to be returned in the

00:03:48,420 --> 00:03:52,019
place where it's going to be returned

00:03:49,500 --> 00:03:54,090
the compiler can only do that if it

00:03:52,019 --> 00:03:56,760
knows which object will be returned and

00:03:54,090 --> 00:03:58,170
at compile time it can't know which

00:03:56,760 --> 00:04:01,920
object is going to be returned only at

00:03:58,170 --> 00:04:03,360
runtime can it know that so this is

00:04:01,920 --> 00:04:05,630
another situation just slightly

00:04:03,360 --> 00:04:07,799
different okay so this can also work on

00:04:05,630 --> 00:04:11,010
parameters passed in so in this case

00:04:07,799 --> 00:04:13,260
we're passing in a temporary to F and so

00:04:11,010 --> 00:04:16,019
when we create the temporary there and

00:04:13,260 --> 00:04:18,419
then we call call F and pass it into the

00:04:16,019 --> 00:04:20,519
stack for F and again this is how your

00:04:18,419 --> 00:04:22,260
code to be written if your compiler

00:04:20,519 --> 00:04:24,450
engineer is a which is not or

00:04:22,260 --> 00:04:26,760
she's not excuse me

00:04:24,450 --> 00:04:27,810
so this is how it actually works we are

00:04:26,760 --> 00:04:29,880
going to create

00:04:27,810 --> 00:04:31,889
our temporary in the place where we

00:04:29,880 --> 00:04:33,750
would have copied it the compiler has to

00:04:31,889 --> 00:04:36,300
create a temporary does it here now of

00:04:33,750 --> 00:04:37,200
course as you notice this would not work

00:04:36,300 --> 00:04:39,900
with an l-value

00:04:37,200 --> 00:04:41,100
this works only for tempers but in the

00:04:39,900 --> 00:04:43,380
case of temporaries we can actually

00:04:41,100 --> 00:04:47,250
completely avoid the copy by simply

00:04:43,380 --> 00:04:49,230
doing this in place I hope that gives

00:04:47,250 --> 00:04:50,760
you some idea about how this copy

00:04:49,230 --> 00:04:52,440
illusion is actually implemented at the

00:04:50,760 --> 00:04:54,360
low level and I will say that for me

00:04:52,440 --> 00:04:55,770
personally understanding that made all

00:04:54,360 --> 00:04:57,660
the difference in understanding our vo

00:04:55,770 --> 00:05:02,999
and population thank you very much

00:04:57,660 --> 00:05:02,999

YouTube URL: https://www.youtube.com/watch?v=IZbL-RGr_mk


