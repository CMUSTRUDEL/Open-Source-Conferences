Title: CppCon 2018: Arthur O'Dwyer “Trivially Relocatable”
Publication date: 2018-11-10
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,390
Hello. I'm going to talk about "trivially relocatable." It's the thing on my badge.

00:00:04,390 --> 00:00:09,030
This is a little bit of a talk that I gave in Aspen... and I highly advise you all to go watch that talk... https://youtu.be/MWBfmmg8-Yo

00:00:09,520 --> 00:00:12,820
So you can all just get up and go right now. https://youtu.be/MWBfmmg8-Yo

00:00:13,140 --> 00:00:17,180
But let me talk about what this "trivially relocatable" thing is.

00:00:17,500 --> 00:00:20,940
Consider what happens when we resize a `std::vector`, for example.

00:00:20,940 --> 00:00:27,860
This is my usual test case here. I have a vector; it's got a size and a capacity and a pointer to some heap-allocated memory...

00:00:27,860 --> 00:00:32,120
...and it's got these four `T` objects, A, B, C, and D.

00:00:32,120 --> 00:00:35,580
Let's say we try to `push_back` something onto this vector.

00:00:35,580 --> 00:00:42,340
Well, we don't have any room in the vector. No capacity left. So we're going to allocate some more heap space...

00:00:42,360 --> 00:00:48,080
and we're going to construct— we're going to construct `E` first. Doesn't matter why. In Aspen I tell you why.

00:00:48,080 --> 00:00:56,700
And then we're going to have to get the objects ABCD somehow from where they are into this new space of memory, right?

00:00:56,700 --> 00:01:02,420
We're going to have to somehow relocate them — I'll tell you about that word in a little bit —

00:01:02,420 --> 00:01:06,560
— from where they are, to this new place. And then we have to get rid of the originals.

00:01:06,560 --> 00:01:09,480
So, basically, when I say "relocate," what I mean is:

00:01:09,480 --> 00:01:14,000
We're going to call the move constructor, and then we're going to call the destructor. And we're going to do that four times in a row.

00:01:14,000 --> 00:01:19,980
Now, when `std::vector` does it, it actually calls "move, move, move, move; destroy, destroy, destroy, destroy."

00:01:20,520 --> 00:01:25,080
Whereas it might actually be more cache-efficient to call "move, destroy, move, destroy, move, destroy, move, destroy."

00:01:25,080 --> 00:01:29,780
By the way, I should say that in this case I'm assuming that the move-constructor is `noexcept`.

00:01:29,780 --> 00:01:33,840
If your move-constructor is NOT `noexcept`, your program is bad and you should feel bad.

00:01:33,840 --> 00:01:38,920
This is the only case I care about. But of course we can detect that [`std::is_nothrow_move_constructible`] already with type traits, right?

00:01:40,200 --> 00:01:43,200
So! Let's look at some codegen.

00:01:43,200 --> 00:01:47,780
We go to Godbolt— and here I've got GCC trunk and Clang trunk right next to each other on Godbolt.

00:01:47,780 --> 00:01:52,640
And you can play along at home with the URL in the upper corner there, if you feel like it. https://godbolt.org/z/wxVF4C

00:01:52,640 --> 00:01:55,660
And that way you won't be voting against me on the thing. It'll be great.

00:01:56,920 --> 00:01:58,600
So the red arrow—

00:01:58,600 --> 00:02:01,360
—every slide needs, you know, arrows and circles and things—

00:02:01,360 --> 00:02:05,720
—so the arrow is pointing at the code, the one-liner, that we're compiling here.

00:02:05,720 --> 00:02:10,920
We have a `vector<int*>`. And `int*` is actually trivially copyable.

00:02:10,920 --> 00:02:13,620
And we can detect that with type traits.

00:02:13,620 --> 00:02:20,900
We can detect that when we make copies, or when we move, or when we destroy, there's no side effects at all. It's just like a memcpy.

00:02:20,900 --> 00:02:27,720
And the compiler and the library, together, cooperate and are smart enough to turn that into a memcpy.

00:02:27,720 --> 00:02:31,400
We see here in the left-hand box:, `call memcpy`. And on the other side: `callq memcpy`.

00:02:31,400 --> 00:02:39,700
And I have no idea why it's `call memcpy` in one case and `callq memcpy` in the other case. If anyone can explain how this possibly turns into different mnemonics...

00:02:40,560 --> 00:02:43,160
But anyway, the point is that it's calling `memcpy` in both cases.

00:02:43,160 --> 00:02:48,560
And this is very short. 48 lines of assembly to do the `reserve` on the one side. 43 lines on the other side.

00:02:48,560 --> 00:02:55,300
Now the problem comes when we look at a non-trivially-copyable type. For example, `shared_ptr<int>`.

00:02:55,300 --> 00:02:59,780
Here I have a `vector<shared_ptr<int>>` and I'm doing the exact same `reserve`. https://godbolt.org/z/qVeOnc

00:02:59,780 --> 00:03:07,320
Now, `shared_ptr` is also twice as big. But the important thing here is that it is non-trivial to copy, and it's non-trivial to move.

00:03:07,320 --> 00:03:12,320
It's ALMOST trivial to move. You just take the pointers from this side, and put them on this side—

00:03:12,320 --> 00:03:18,960
—But then you have to go back and you have to null out the others, to keep the reference counts the same.

00:03:18,960 --> 00:03:23,620
And then you have to — that's non-trivial, so you have to do that in a loop — so there's a loop —

00:03:23,620 --> 00:03:29,220
And we look at what GCC is doing here, and it's calling some `_SP_counted_base` thing inside its loop,

00:03:29,220 --> 00:03:33,380
And on the other side I see pthreads is getting involved. And this is just crazy!

00:03:34,920 --> 00:03:36,820
And of course it's much longer.

00:03:36,820 --> 00:03:40,300
So that's what happens when we relocate non-trivial types.

00:03:40,300 --> 00:03:46,440
But in theory we could do it the same way, right?

00:03:47,260 --> 00:03:53,300
We could have a compiler — and it could be available on Godbolt today — https://p1144.godbolt.org/z/-TBVP6

00:03:53,300 --> 00:04:00,800
And you could go to that link and and see it for yourself. If— you know, theoretically— you could do that. https://p1144.godbolt.org/z/-TBVP6

00:04:00,800 --> 00:04:09,160
...where we can actually tell that moving a `shared_ptr` from here to here, and then destroying the original, is actually a trivial operation.

00:04:09,160 --> 00:04:12,520
That we can do it with a memcpy as long as we remember to drop the original on the floor. Right?

00:04:12,520 --> 00:04:18,280
In principle, we can implement the relocation of ABCD here, even when they're shared_ptrs,

00:04:18,280 --> 00:04:26,660
by just memcpying everything and then just conveniently omitting to destroy the originals. We'll just drop them on the floor.

00:04:26,660 --> 00:04:31,340
So now we have not incremented the reference count, but we also have not decremented the reference count.

00:04:31,340 --> 00:04:34,760
So it remains where it was, and we're happy.

00:04:34,760 --> 00:04:40,220
And again, this operation of calling the move-constructor and the destructor together in pairs is called relocation—

00:04:40,220 --> 00:04:42,360
—says me—

00:04:42,360 --> 00:04:50,680
—and when a type (such as `shared_ptr`) has a relocation operation which is TRIVIAL, which is equivalent to memcpy, we call it "trivially relocatable."

00:04:50,680 --> 00:04:53,080
–Says me.

00:04:54,640 --> 00:05:02,480
In Aspen, I gave some benchmark results for what this does to the performance characteristics of things like `vector::reserve`.

00:05:02,480 --> 00:05:05,900
Here I have a benchmark that I wrote up using Google Benchmark. https://github.com/google/benchmark

00:05:05,900 --> 00:05:08,480
I highly recommend Google Benchmark. It's great.

00:05:09,860 --> 00:05:17,040
And it— what is it doing here?— It's timing the call to `vector::reserve` right here.

00:05:17,040 --> 00:05:21,340
And we see that it's doing... uh...

00:05:21,340 --> 00:05:29,080
I just noticed. This is notifying me of the vote count that I'm getting? This is highly distracting.

00:05:29,080 --> 00:05:29,980
Keep it up, though.

00:05:29,980 --> 00:05:33,640
Um. Uh... so, uh...

00:05:33,640 --> 00:05:37,620
[DISTRACTED BY VOTE COUNTER] Oh my god. Let me...

00:05:37,620 --> 00:05:41,580
[COVERS VOTE COUNTER WITH HAND] All right.

00:05:41,580 --> 00:05:52,080
So in Aspen I covered a sort of preliminary version of this. This was before it was available on Godbolt. And I gave a whole bunch of different benchmarks. This is the benchmark for `vector::reserve`.

00:05:52,080 --> 00:06:00,000
And it does a single `reserve` — or some number of `reserve`s, I don't know — but the point is, it got three times faster.

00:06:00,000 --> 00:06:02,940
That's the take-home point, right?

00:06:03,700 --> 00:06:13,100
By getting to skip the "move and destroy in a loop" for `unique_ptr`, and just using a memcpy instead, you get three times faster. On `vector::reserve`.

00:06:13,100 --> 00:06:21,980
Now, this is great if you're doing a whole lot of `vector::reserve` all over the place, but most of us, you know, we do that ONCE, right? That's the part that you put OUTSIDE the loop.

00:06:21,980 --> 00:06:29,580
So I decided that if I got more time — which apparently I did, I guess? — I was going to talk about more applications of it.

00:06:29,580 --> 00:06:31,960
But first I guess I just tell you how you can play with it.

00:06:31,960 --> 00:06:35,480
So I had showed you that Godbolt way back here, right?

00:06:35,480 --> 00:06:39,980
Sorry. "Compiler Explorer."

00:06:39,980 --> 00:06:45,220
I'll give you like a minute to just look at that URL. https://p1144.godbolt.org/z/-TBVP6

00:06:45,220 --> 00:06:51,300
Or if you look at the thing in the red box, right? It's "clang (experimental P1144)."

00:06:51,300 --> 00:06:56,220
So if you go there you can play with the compiler extension that I've got.

00:06:56,220 --> 00:06:59,960
It adds one new attribute, which you can use — very rarely.

00:06:59,960 --> 00:07:03,800
This is used in the library. Normal user code will not generally use this attribute.

00:07:03,800 --> 00:07:10,460
This is a way of opting in and saying, for things like shared_ptr and unique_ptr, "I promise that I am in fact trivially relocatable."

00:07:10,460 --> 00:07:15,920
And then there's this type trait, `std::is_trivially_relocatable`, that you can use.

00:07:15,920 --> 00:07:20,680
That the library uses to detect when a class has this property.

00:07:20,680 --> 00:07:28,460
Much more often it just happens automatically — the same way trivial copyability works, the same way trivial destructibility works.

00:07:28,460 --> 00:07:32,420
It's inherited in the obvious way when you follow the Rule of Zero.

00:07:32,420 --> 00:07:39,640
So as long as you don't provide a non-trivial — sorry, non-DEFAULTED move-constructor — or non-defaulted destructor,

00:07:39,640 --> 00:07:44,960
and as long as all your members and base classes and so on are trivially relocatable,

00:07:44,960 --> 00:07:47,160
you yourself will be trivially relocatable.

00:07:47,160 --> 00:07:50,940
And you can play around with that on Compiler Explorer.

00:07:50,940 --> 00:07:57,960
So for more information, you can go there [P1144R0], there [https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable], or there [https://youtu.be/8u5Qi4FgTP8]

00:07:59,040 --> 00:08:05,320

YouTube URL: https://www.youtube.com/watch?v=xxta6LEn9Hk


