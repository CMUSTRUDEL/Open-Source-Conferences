Title: Feedback on practical use of C++17 std::recursive_directory_iterator - Noel Tchidjo [ CppCon 2018 ]
Publication date: 2018-11-10
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,300 --> 00:00:03,720
Hi everybody, I'm Noel I am a software engineer at Murex.

00:00:04,080 --> 00:00:07,820
And I would like to talk about our investigation.

00:00:07,820 --> 00:00:16,400
On how we can improve std::recursive_directory_iterator of C++17.

00:00:16,740 --> 00:00:26,500
So, from time-to-time we develop tools who refactor code. When we have specific complex refactoring to perform.

00:00:26,500 --> 00:00:35,800
And last time, we end up, I think, that it was taking too much time, just to list the file we had interest of.

00:00:36,340 --> 00:00:42,640
Typical, usage is in for-loops if you use a recursive directory iterator.

00:00:42,840 --> 00:00:50,580
For each entry, you retrieve the extension. And you just check that the extension correct form to what you interest of.

00:00:51,820 --> 00:00:59,280
So, we ask ourself the question about: What will be the resulting code expressiveness?

00:00:59,460 --> 00:01:02,000
And also, the time performance.

00:01:02,160 --> 00:01:05,620
If we add a lambda to recursive directory iterator.

00:01:05,620 --> 00:01:12,560
And also a parameter to have the type of entry we have interest of.

00:01:12,740 --> 00:01:16,680
The resulting code usage will be like this:

00:01:16,680 --> 00:01:23,300
So that there is no if-statement any more on the forms.

00:01:23,560 --> 00:01:26,400
We also ask our self the question about:

00:01:26,440 --> 00:01:32,040
If instead of adding a lambda we use a regex. And also with it the type of entry.

00:01:32,280 --> 00:01:36,600
The usage will look like this.

00:01:36,960 --> 00:01:39,100
So, in order to perform test.

00:01:39,280 --> 00:01:49,080
We have implemented this two api change proposals on GCC and clang. Patches are available on GitHub.

00:01:49,880 --> 00:01:56,700
So we have run a directory traversal program of several open source projects.

00:01:56,700 --> 00:02:00,180
And here we want just to share a few results.

00:02:00,260 --> 00:02:04,820
So, on Unix platform when running over Gecko.

00:02:04,820 --> 00:02:09,600
We have, the regex version is 25% faster then the current version.

00:02:09,620 --> 00:02:14,760
And the lambda version is 55% faster then the current version.

00:02:15,060 --> 00:02:20,840
Another result on Windows platform. Again running over Gecko file set.

00:02:20,880 --> 00:02:26,200
We have the regex version 46% slower then the current version.

00:02:26,280 --> 00:02:29,700
And the lambda version at 10% faster.

00:02:29,720 --> 00:02:37,360
So here the regex version was slower. It was due to std::regex_match implementation of Visual Studio.

00:02:38,320 --> 00:02:44,440
So, what about advantages and drawbacks. For example for the regex version?

00:02:44,480 --> 00:02:46,060
Well, advantages:

00:02:46,060 --> 00:02:52,720
We have better code expressiveness, compared to the current version, [and] compared to lambda version.

00:02:52,720 --> 00:02:55,980
Entries provided by the iterator already fit our need.

00:02:55,980 --> 00:02:59,360
And is also easy to implement on compilers.

00:02:59,720 --> 00:03:03,180
For drawbacks: The time performance are unstable.

00:03:03,180 --> 00:03:10,620
On Unix it was faster then the current version when type of file where heterogeneous.

00:03:10,920 --> 00:03:15,820
And there was no difference when files set were homogeneous.

00:03:15,820 --> 00:03:20,560
On Windows it was slower. The regex version was slower then the current version.

00:03:20,560 --> 00:03:26,940
Also the regex version introduced a dependency between <filesystem> and <regex>.

00:03:26,940 --> 00:03:35,220
Our disappointment was also to be not able to directly pas a filter to Windows system call.

00:03:35,340 --> 00:03:42,100
Because when you create a regex you cannot retrieve back the regular expression that you used to create the regex.

00:03:42,620 --> 00:03:46,080
For the lambda version advantages was:

00:03:46,605 --> 00:03:49,755
Better code expressiveness compared to the current version.

00:03:49,760 --> 00:03:55,860
And time performance are stable, and better then regex version, and current version.

00:03:55,860 --> 00:04:00,300
And that is true, whatever the platform it's on. On Windows ...

00:04:00,300 --> 00:04:02,280
And whatever the compiler.

00:04:02,280 --> 00:04:08,800
And whatever again the open source project. When we run the directory traversal program

00:04:08,940 --> 00:04:12,620
And is also easy to implement in compilers.

00:04:12,780 --> 00:04:15,560

YouTube URL: https://www.youtube.com/watch?v=aRb5uK-LMiE


