Title: C++20 STL Features: One Year of Development on GitHub - Stephan T. Lavavej - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020 Day 2
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/cpp20_stl_features_1_year_of_development_on_github/cpp20_stl_features_1_year_of_development_on_github__stephan_t_lavavej__cppcon_2020.pdf
---

At CppCon 2019, Microsoft open-sourced its implementation of the C++ Standard Library. In the year since then, we've worked with many contributors on GitHub, adding dozens of C++20 features. In this talk, we'll explore some of these C++20 features and how you can use them in your code (even if you don't use our implementation). We'll also take a tour of microsoft/STL development on GitHub and our intensive code review process.

Examples of C++20 features we'll explore: span which makes working with contiguous sequences easier, constexpr algorithms which make it possible to verify that lookup tables are sorted at compile time (or just sort them at compile time!), erase_if() which finally supersedes the "erase-remove idiom", integer comparison functions which make it easier to write correct code without worrying about the Usual Arithmetic Conversions, and make_shared() for arrays which extends the classic "single allocation" optimization.

We're using GitHub issues and pull requests for all development, and we're recording a detailed Changelog in a GitHub wiki page. If you want to follow our progress, this talk will explain how to find what we're working on and what remains to be done. This talk will also show how we use a GitHub project to track PRs as they go through multiple stages of review. (The span PR accumulated almost 700 comments before being merged!) If you're interested in contributing, whether it's a small improvement or an entire feature, seeing this process should help.

---
Stephan T. Lavavej
Microsoft
Principal Software Engineer
Redmond, WA
Stephan T. Lavavej is a Principal Software Engineer at Microsoft, maintaining Visual C++'s implementation of the C++ Standard Library since 2007. He also designed a couple of C++14 features: make_unique and the transparent operator functors. He likes his initials (which people can actually spell) and cats (although he doesn't own any).
---

Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,519 --> 00:00:13,120
hi everyone

00:00:10,480 --> 00:00:14,719
my name is stephan t lowaid and i work

00:00:13,120 --> 00:00:16,400
on the visual sipless libraries team

00:00:14,719 --> 00:00:18,160
maintaining our standard template

00:00:16,400 --> 00:00:20,240
library implementation

00:00:18,160 --> 00:00:21,680
and today i'd like to talk about uh what

00:00:20,240 --> 00:00:24,720
we've done

00:00:21,680 --> 00:00:27,359
and where we're going from here so

00:00:24,720 --> 00:00:28,000
as we get started you can add your

00:00:27,359 --> 00:00:30,640
questions

00:00:28,000 --> 00:00:32,079
in the chat and i'll answer them at the

00:00:30,640 --> 00:00:34,000
end um

00:00:32,079 --> 00:00:35,520
fireball will take care of collecting

00:00:34,000 --> 00:00:38,000
all of that um so

00:00:35,520 --> 00:00:39,760
this uh presentation is structured in

00:00:38,000 --> 00:00:40,960
three parts uh first we're gonna have a

00:00:39,760 --> 00:00:42,559
very quick overview

00:00:40,960 --> 00:00:44,160
of what's happened in the last year

00:00:42,559 --> 00:00:47,840
since the last cp con

00:00:44,160 --> 00:00:48,399
then part one will be covering about

00:00:47,840 --> 00:00:51,680
five

00:00:48,399 --> 00:00:55,039
cs plus 20 stl features so this part

00:00:51,680 --> 00:00:56,960
is entirely standard even if you use

00:00:55,039 --> 00:00:58,640
another implementation

00:00:56,960 --> 00:01:00,000
all of this uh will apply to you and

00:00:58,640 --> 00:01:02,000
you'll be able to use it um

00:01:00,000 --> 00:01:03,920
in your production code as soon as you

00:01:02,000 --> 00:01:06,960
can uh

00:01:03,920 --> 00:01:08,479
you uh gain access to a version of your

00:01:06,960 --> 00:01:10,400
compiler and library that support all

00:01:08,479 --> 00:01:10,720
these features uh there's one part where

00:01:10,400 --> 00:01:12,560
i

00:01:10,720 --> 00:01:14,080
talk about something that is specific to

00:01:12,560 --> 00:01:15,759
our implementation but otherwise

00:01:14,080 --> 00:01:18,400
everything else is standard

00:01:15,759 --> 00:01:20,000
and then in part two um i'll be talking

00:01:18,400 --> 00:01:22,320
about um how we

00:01:20,000 --> 00:01:23,360
have developed all these features with

00:01:22,320 --> 00:01:26,400
our contributors

00:01:23,360 --> 00:01:29,600
on github and this is uh so you can

00:01:26,400 --> 00:01:31,280
uh follow our progress um and keep track

00:01:29,600 --> 00:01:32,640
of okay you know is this equals plus 20

00:01:31,280 --> 00:01:34,799
feature available yet or

00:01:32,640 --> 00:01:35,920
going forward is the sql 23 feature

00:01:34,799 --> 00:01:38,240
available yet

00:01:35,920 --> 00:01:40,720
um to understand our organization and

00:01:38,240 --> 00:01:43,280
our development process

00:01:40,720 --> 00:01:43,920
so what has happened in the last year

00:01:43,280 --> 00:01:47,759
well at

00:01:43,920 --> 00:01:50,000
cpcon 2019 we had a major announcement

00:01:47,759 --> 00:01:51,280
that we were open sourcing our still

00:01:50,000 --> 00:01:53,680
implementation

00:01:51,280 --> 00:01:54,960
so now all of the three major stls are

00:01:53,680 --> 00:01:57,759
open source

00:01:54,960 --> 00:02:00,159
and ours is what went from proprietary

00:01:57,759 --> 00:02:02,719
to open source which is very unusual

00:02:00,159 --> 00:02:04,799
we are licensed under the apache license

00:02:02,719 --> 00:02:07,439
2o with lvm exception

00:02:04,799 --> 00:02:08,720
which is the same license that clangs

00:02:07,439 --> 00:02:11,840
lipsis plus uses

00:02:08,720 --> 00:02:13,360
we chose that for compatibility

00:02:11,840 --> 00:02:15,440
deliberately

00:02:13,360 --> 00:02:17,920
and in the last year we've implemented

00:02:15,440 --> 00:02:20,319
about 50 um cs plus 20

00:02:17,920 --> 00:02:21,440
papers slash features it varies

00:02:20,319 --> 00:02:22,800
depending on how you count

00:02:21,440 --> 00:02:25,040
whether something is a top-level feature

00:02:22,800 --> 00:02:27,760
or not i think it's about 50.

00:02:25,040 --> 00:02:29,840
and the majority of these are from

00:02:27,760 --> 00:02:31,519
external contributors on github

00:02:29,840 --> 00:02:32,959
and they've just been doing absolutely

00:02:31,519 --> 00:02:36,000
amazing work

00:02:32,959 --> 00:02:38,800
really high quality in many cases

00:02:36,000 --> 00:02:41,120
they've been able to do things that were

00:02:38,800 --> 00:02:43,040
beyond our domain expertise

00:02:41,120 --> 00:02:44,560
particularly sql swiss 20 has been

00:02:43,040 --> 00:02:48,000
adding more and more

00:02:44,560 --> 00:02:49,680
features that are highly domain specific

00:02:48,000 --> 00:02:51,360
whether in multi-threading or math

00:02:49,680 --> 00:02:54,720
things like that

00:02:51,360 --> 00:02:56,720
and we have the stl maintainer team has

00:02:54,720 --> 00:02:59,760
extensively reviewed and tested these

00:02:56,720 --> 00:03:02,959
um so from the perspective of a user

00:02:59,760 --> 00:03:04,319
of msvc nothing has changed they're

00:03:02,959 --> 00:03:05,280
still getting features faster than

00:03:04,319 --> 00:03:07,440
before

00:03:05,280 --> 00:03:08,640
at the usual level of quality high level

00:03:07,440 --> 00:03:10,239
quality

00:03:08,640 --> 00:03:12,319
and the fact that it's open source is

00:03:10,239 --> 00:03:15,200
just an implementation detail

00:03:12,319 --> 00:03:15,920
so in the last year we've released since

00:03:15,200 --> 00:03:18,959
we release

00:03:15,920 --> 00:03:22,159
vs updates about quarterly we have had

00:03:18,959 --> 00:03:23,840
three full releases ready for production

00:03:22,159 --> 00:03:25,680
and just at the beginning of this

00:03:23,840 --> 00:03:28,200
conference cpcon 2020

00:03:25,680 --> 00:03:30,959
we released preview three of the vs

00:03:28,200 --> 00:03:32,480
2019-16-8 update

00:03:30,959 --> 00:03:34,000
which will be available for production

00:03:32,480 --> 00:03:35,280
use in the the near future so it's

00:03:34,000 --> 00:03:36,560
really like four updates that have

00:03:35,280 --> 00:03:39,360
contained um

00:03:36,560 --> 00:03:41,200
uh changes uh from github um so we're

00:03:39,360 --> 00:03:42,480
still migrating um our development

00:03:41,200 --> 00:03:44,640
process to github

00:03:42,480 --> 00:03:45,840
um for example the build system right

00:03:44,640 --> 00:03:48,560
now on github

00:03:45,840 --> 00:03:50,480
is a new uh build system written from

00:03:48,560 --> 00:03:51,440
scratch using cmake and ninja which is

00:03:50,480 --> 00:03:53,280
awesome

00:03:51,440 --> 00:03:55,200
and currently we build just one flavor

00:03:53,280 --> 00:03:56,159
which is native desktop we still need to

00:03:55,200 --> 00:03:59,200
port

00:03:56,159 --> 00:04:01,920
like clr one core spectre builds all

00:03:59,200 --> 00:04:04,080
these other different flavors of the stl

00:04:01,920 --> 00:04:05,360
we've migrated about 99 of our test

00:04:04,080 --> 00:04:07,120
suite to github

00:04:05,360 --> 00:04:08,720
but we still have a few lingering tests

00:04:07,120 --> 00:04:11,439
that we need to migrate over

00:04:08,720 --> 00:04:13,040
and enabling test coverage of things

00:04:11,439 --> 00:04:15,920
like clr

00:04:13,040 --> 00:04:16,720
and we've been uh porting over uh bugs

00:04:15,920 --> 00:04:18,160
um and other

00:04:16,720 --> 00:04:20,079
to-do enhancement issues from our

00:04:18,160 --> 00:04:21,440
internal databases with the help of our

00:04:20,079 --> 00:04:24,080
contributors

00:04:21,440 --> 00:04:24,800
so our goal and this is just a goal it's

00:04:24,080 --> 00:04:27,199
not a promise

00:04:24,800 --> 00:04:28,320
is that we want to complete the cs plus

00:04:27,199 --> 00:04:30,720
20 still features

00:04:28,320 --> 00:04:32,240
in calendar year 2020. uh we can't

00:04:30,720 --> 00:04:33,440
promise this because there's only a few

00:04:32,240 --> 00:04:34,800
months remaining in the year and we've

00:04:33,440 --> 00:04:36,720
got a number of large features to work

00:04:34,800 --> 00:04:40,320
through but we're working really hard

00:04:36,720 --> 00:04:42,960
um we've got about 23 features

00:04:40,320 --> 00:04:44,160
left to do so that'll be our focus for

00:04:42,960 --> 00:04:46,479
the rest of the year

00:04:44,160 --> 00:04:47,520
um and here is a quick preview of a

00:04:46,479 --> 00:04:48,800
graph i'll be

00:04:47,520 --> 00:04:51,040
talking more about our status chart

00:04:48,800 --> 00:04:52,240
later um but this graph the dark purple

00:04:51,040 --> 00:04:54,800
line um

00:04:52,240 --> 00:04:56,400
is the number of cs plus 20 features uh

00:04:54,800 --> 00:04:57,759
remaining to be implemented it's gone up

00:04:56,400 --> 00:04:59,440
every time the committee has voted in

00:04:57,759 --> 00:05:02,720
features it goes down when

00:04:59,440 --> 00:05:04,960
whenever we commit a feature um and the

00:05:02,720 --> 00:05:06,800
uh little hover highlight there um is

00:05:04,960 --> 00:05:08,240
the date where we announced last year

00:05:06,800 --> 00:05:10,320
that the s2 was being open source so at

00:05:08,240 --> 00:05:12,479
that time we had 60

00:05:10,320 --> 00:05:13,919
top level features to implement and that

00:05:12,479 --> 00:05:16,160
has gone down to 23

00:05:13,919 --> 00:05:17,440
and once it hits zero we can declare

00:05:16,160 --> 00:05:20,800
success

00:05:17,440 --> 00:05:23,759
so um out of you know all these features

00:05:20,800 --> 00:05:24,960
um which ones uh will we be talking

00:05:23,759 --> 00:05:26,560
about today

00:05:24,960 --> 00:05:28,160
i'd like to start off with one of the

00:05:26,560 --> 00:05:29,600
simpler ones

00:05:28,160 --> 00:05:31,919
and for each of these features i'm going

00:05:29,600 --> 00:05:34,240
to present a fully worked example

00:05:31,919 --> 00:05:34,960
a little snippet not just a snippet of

00:05:34,240 --> 00:05:36,720
code but

00:05:34,960 --> 00:05:38,160
a small program that can just be

00:05:36,720 --> 00:05:40,160
directly compiled under

00:05:38,160 --> 00:05:41,680
stood serious latest or cs 20 whatever

00:05:40,160 --> 00:05:43,759
your compiler option is

00:05:41,680 --> 00:05:44,800
um so what could be the simplest thing

00:05:43,759 --> 00:05:46,160
in the world will

00:05:44,800 --> 00:05:48,160
we could look at well what about like

00:05:46,160 --> 00:05:49,360
comparing integers integers are simple

00:05:48,160 --> 00:05:50,960
right they're not even like floating

00:05:49,360 --> 00:05:54,639
points how hard could it be

00:05:50,960 --> 00:05:56,479
um so here is a program uh to save space

00:05:54,639 --> 00:05:58,160
on the slide i've minimized by making

00:05:56,479 --> 00:06:00,560
the font really small the boilerplate

00:05:58,160 --> 00:06:02,240
like include in it main

00:06:00,560 --> 00:06:03,759
but you can compile this and see what it

00:06:02,240 --> 00:06:06,880
uh prints out

00:06:03,759 --> 00:06:07,680
so if i have a short whose value is

00:06:06,880 --> 00:06:10,080
negative one

00:06:07,680 --> 00:06:12,080
and if i have an int an unsigned end

00:06:10,080 --> 00:06:14,400
whose value is 1729

00:06:12,080 --> 00:06:16,240
and i try to compare them with less than

00:06:14,400 --> 00:06:19,280
what do i get like negative one is

00:06:16,240 --> 00:06:21,199
certainly less than 1729

00:06:19,280 --> 00:06:22,800
well the the fact that i'm asking this

00:06:21,199 --> 00:06:24,720
question that i've highlighted this in

00:06:22,800 --> 00:06:26,639
ominous red and the slide is titled

00:06:24,720 --> 00:06:27,280
usual arithmetic conversions which if

00:06:26,639 --> 00:06:30,319
you know what they

00:06:27,280 --> 00:06:31,919
that those are that's highly ominous um

00:06:30,319 --> 00:06:33,360
this will probably lead you to think

00:06:31,919 --> 00:06:34,639
something's unexpected well

00:06:33,360 --> 00:06:36,080
if you try to compile this the first

00:06:34,639 --> 00:06:36,880
thing that it prints is a compiler

00:06:36,080 --> 00:06:39,199
warning

00:06:36,880 --> 00:06:40,720
um it'll say whoa unsigned you know

00:06:39,199 --> 00:06:42,479
assigned to mismatch or if you're using

00:06:40,720 --> 00:06:43,680
clang it'll say comparison of integers

00:06:42,479 --> 00:06:45,680
of different signs

00:06:43,680 --> 00:06:47,280
um and these warnings are considered

00:06:45,680 --> 00:06:48,240
sufficiently dire that they'll be on at

00:06:47,280 --> 00:06:50,560
you know

00:06:48,240 --> 00:06:52,639
pretty normal levels of warning um so

00:06:50,560 --> 00:06:54,960
this is an indication that something is

00:06:52,639 --> 00:06:57,039
weird is going to happen and indeed this

00:06:54,960 --> 00:06:59,919
is going to print false

00:06:57,039 --> 00:07:02,560
that's weird why is negative 1 not less

00:06:59,919 --> 00:07:05,120
than 1729 well

00:07:02,560 --> 00:07:06,080
the cs plus standards rules which are

00:07:05,120 --> 00:07:08,560
inherited from c

00:07:06,080 --> 00:07:10,479
here say that when you compare integers

00:07:08,560 --> 00:07:12,960
of different types

00:07:10,479 --> 00:07:13,759
there are these conversions that happen

00:07:12,960 --> 00:07:15,440
and they're

00:07:13,759 --> 00:07:17,039
usual as far as the standard is

00:07:15,440 --> 00:07:18,960
concerned although they can definitely

00:07:17,039 --> 00:07:21,039
do decidedly unusual things

00:07:18,960 --> 00:07:22,560
um in this case the standard looks these

00:07:21,039 --> 00:07:24,560
and it says

00:07:22,560 --> 00:07:26,000
you know that short it's really tiny why

00:07:24,560 --> 00:07:28,000
don't we widen it why don't we make it

00:07:26,000 --> 00:07:29,919
the same type as the unsigned end

00:07:28,000 --> 00:07:31,919
so you get that negative one as a short

00:07:29,919 --> 00:07:34,560
converted to unsigned

00:07:31,919 --> 00:07:35,919
int and that is going to obey modular

00:07:34,560 --> 00:07:39,120
arithmetic you're going to get the value

00:07:35,919 --> 00:07:42,240
of you know 2 to the 32 minus 1

00:07:39,120 --> 00:07:42,800
and 4 billion is not less than 1729 so

00:07:42,240 --> 00:07:46,560
that's why

00:07:42,800 --> 00:07:49,680
fault is being printed there so this is

00:07:46,560 --> 00:07:51,199
definitely undesirable because

00:07:49,680 --> 00:07:52,720
if you're working with like a short you

00:07:51,199 --> 00:07:54,080
probably don't want it to convert to an

00:07:52,720 --> 00:07:55,039
unsigned int whenever you compare with

00:07:54,080 --> 00:07:57,599
an unsigned end

00:07:55,039 --> 00:07:59,199
you just want a small type because you

00:07:57,599 --> 00:08:00,800
know to save space or whatever

00:07:59,199 --> 00:08:02,479
um so you can you can write the correct

00:08:00,800 --> 00:08:04,080
code here um but you have to insert some

00:08:02,479 --> 00:08:05,840
cast you have to think about the usual

00:08:04,080 --> 00:08:08,960
arithmetic conversions which

00:08:05,840 --> 00:08:10,960
uh most programmers you know can't uh

00:08:08,960 --> 00:08:12,160
name um in detail because the rules are

00:08:10,960 --> 00:08:15,280
complicated

00:08:12,160 --> 00:08:16,800
so cs 20 makes this a lot easier

00:08:15,280 --> 00:08:18,400
there is a feature called integer

00:08:16,800 --> 00:08:20,879
comparison functions and

00:08:18,400 --> 00:08:22,319
in the slide deck when you can view the

00:08:20,879 --> 00:08:25,039
slides they are

00:08:22,319 --> 00:08:26,639
all hyperlinks here our pro request 621

00:08:25,039 --> 00:08:28,960
was implemented by our contributor

00:08:26,639 --> 00:08:30,400
neargy and the integer comparison

00:08:28,960 --> 00:08:31,520
functions are provided in the header

00:08:30,400 --> 00:08:33,039
utility

00:08:31,520 --> 00:08:34,800
so instead of using operator or less

00:08:33,039 --> 00:08:37,440
than um if you call stood

00:08:34,800 --> 00:08:39,519
complex and pass it to short and this

00:08:37,440 --> 00:08:40,399
unsigned end it returns the mathematical

00:08:39,519 --> 00:08:42,399
answer

00:08:40,399 --> 00:08:43,519
because negative 1 is indeed less than

00:08:42,399 --> 00:08:46,640
00:08:43,519 --> 00:08:48,560
so this is templated and we'll do

00:08:46,640 --> 00:08:50,240
the comparisons and conversions

00:08:48,560 --> 00:08:51,920
necessary to get

00:08:50,240 --> 00:08:53,920
the answer that you would expect so

00:08:51,920 --> 00:08:54,640
you'll get true there and it will all

00:08:53,920 --> 00:08:57,600
you know

00:08:54,640 --> 00:08:59,040
be in lined away um in optimized mode

00:08:57,600 --> 00:09:00,720
because it's a relatively simple

00:08:59,040 --> 00:09:03,440
function it's just there's a lot of

00:09:00,720 --> 00:09:04,560
template corner cases to handle um so

00:09:03,440 --> 00:09:06,720
you've got the full set

00:09:04,560 --> 00:09:09,040
of comparisons that you would expect

00:09:06,720 --> 00:09:12,000
equal not equal less than and so forth

00:09:09,040 --> 00:09:12,480
in the utility header and an additional

00:09:12,000 --> 00:09:14,160
one

00:09:12,480 --> 00:09:16,959
called in range that will tell you

00:09:14,160 --> 00:09:19,279
whether a value of an input type

00:09:16,959 --> 00:09:20,320
um can be expressed within the limits of

00:09:19,279 --> 00:09:23,440
a sp

00:09:20,320 --> 00:09:24,959
explicitly specified type um so that

00:09:23,440 --> 00:09:26,959
one's implemented with an interesting

00:09:24,959 --> 00:09:28,240
hybrid of compile time and runtime logic

00:09:26,959 --> 00:09:30,399
there's a bonus slide at the end of the

00:09:28,240 --> 00:09:31,200
presentation when you view the slides

00:09:30,399 --> 00:09:33,200
that will

00:09:31,200 --> 00:09:34,959
quote our implementation and show you

00:09:33,200 --> 00:09:37,519
what that looks like

00:09:34,959 --> 00:09:38,320
so all of those functions are constexpr

00:09:37,519 --> 00:09:40,560
but that's not

00:09:38,320 --> 00:09:41,920
definitely not the only context for

00:09:40,560 --> 00:09:45,040
stuff that's been added to css

00:09:41,920 --> 00:09:47,200
20. um in fact um making things const

00:09:45,040 --> 00:09:49,519
expert has been an increasing theme

00:09:47,200 --> 00:09:50,959
um in cs plus since constexpr was added

00:09:49,519 --> 00:09:53,120
in cs 11.

00:09:50,959 --> 00:09:54,080
so when const expert was originally

00:09:53,120 --> 00:09:58,080
added to cs

00:09:54,080 --> 00:10:00,959
11 it had very um strong restrictions

00:09:58,080 --> 00:10:03,200
you could only have like a single line

00:10:00,959 --> 00:10:05,360
return statement so if you wanted to do

00:10:03,200 --> 00:10:07,519
any branching you had to express it as a

00:10:05,360 --> 00:10:09,200
conditional ternary operator which was

00:10:07,519 --> 00:10:12,160
excruciatingly terrible

00:10:09,200 --> 00:10:12,720
um and in the following standards 14 17

00:10:12,160 --> 00:10:14,880
00:10:12,720 --> 00:10:16,800
um const expert has been repeatedly

00:10:14,880 --> 00:10:19,440
extended and strengthened both in the

00:10:16,800 --> 00:10:22,720
core language and the standard library

00:10:19,440 --> 00:10:24,399
to the point where now it has almost all

00:10:22,720 --> 00:10:24,880
of the power of ordinary programming

00:10:24,399 --> 00:10:26,800
there's

00:10:24,880 --> 00:10:29,040
still some things you can't do you can't

00:10:26,800 --> 00:10:31,120
reinterpret cast

00:10:29,040 --> 00:10:32,560
but a lot of the previous restrictions

00:10:31,120 --> 00:10:34,399
have gone away

00:10:32,560 --> 00:10:35,680
and the library has been steadily adding

00:10:34,399 --> 00:10:37,600
concepts to things

00:10:35,680 --> 00:10:39,440
so here i tried to gather up all of the

00:10:37,600 --> 00:10:41,440
papers that we've implemented

00:10:39,440 --> 00:10:43,040
that have had something to do primarily

00:10:41,440 --> 00:10:44,320
with constexpr but this is not an

00:10:43,040 --> 00:10:46,640
exhaustive list like those integer

00:10:44,320 --> 00:10:47,920
comparison functions are constexpr

00:10:46,640 --> 00:10:49,360
but they don't have a const expert in

00:10:47,920 --> 00:10:50,959
the title so they don't appear in this

00:10:49,360 --> 00:10:52,800
list

00:10:50,959 --> 00:10:54,160
and you can think of constexpr as

00:10:52,800 --> 00:10:56,240
enabling

00:10:54,160 --> 00:10:58,560
programming that shifted the compile

00:10:56,240 --> 00:11:01,120
time without having to express it

00:10:58,560 --> 00:11:02,720
as okay i need a static data member of a

00:11:01,120 --> 00:11:04,240
template and then i need to grab its

00:11:02,720 --> 00:11:05,360
double calling value that was always

00:11:04,240 --> 00:11:08,240
possible even in cs

00:11:05,360 --> 00:11:09,920
98 but it was really difficult um you

00:11:08,240 --> 00:11:10,560
really only saw that sort of programming

00:11:09,920 --> 00:11:12,800
in

00:11:10,560 --> 00:11:13,839
very template heavy libraries like boost

00:11:12,800 --> 00:11:15,440
in the stl

00:11:13,839 --> 00:11:17,680
now it's a lot easier you just write

00:11:15,440 --> 00:11:18,560
constexpr you obey a certain set of

00:11:17,680 --> 00:11:19,680
rules

00:11:18,560 --> 00:11:21,600
and now you can get compilation

00:11:19,680 --> 00:11:23,519
programming so

00:11:21,600 --> 00:11:24,800
here i've listed some of the papers

00:11:23,519 --> 00:11:27,440
we've implemented

00:11:24,800 --> 00:11:28,720
there were two papers that constexprized

00:11:27,440 --> 00:11:30,640
the algorithm header

00:11:28,720 --> 00:11:33,040
and another one context for numeric

00:11:30,640 --> 00:11:37,519
algorithms also implemented by niergy

00:11:33,040 --> 00:11:39,360
that applied constexpr to accumulate

00:11:37,519 --> 00:11:40,640
and adjacent difference and all the

00:11:39,360 --> 00:11:42,560
other algorithms that

00:11:40,640 --> 00:11:44,160
are hiding in the numeric header but

00:11:42,560 --> 00:11:47,200
there's even more um

00:11:44,160 --> 00:11:49,519
there's been more complex applied to

00:11:47,200 --> 00:11:51,519
more context for apply to complex that

00:11:49,519 --> 00:11:53,519
needed cost expert bitcasts all these

00:11:51,519 --> 00:11:55,519
pieces are fitting together

00:11:53,519 --> 00:11:57,600
a very important feature is is constant

00:11:55,519 --> 00:11:58,560
evaluated which is really a compiler

00:11:57,600 --> 00:12:00,160
feature

00:11:58,560 --> 00:12:02,560
for msvc that was implemented by our

00:12:00,160 --> 00:12:04,639
compilative jennifer yao

00:12:02,560 --> 00:12:06,720
and with a very small library wrapper on

00:12:04,639 --> 00:12:09,680
top and that allows

00:12:06,720 --> 00:12:10,079
a constexpr function to sense whether

00:12:09,680 --> 00:12:13,200
it's

00:12:10,079 --> 00:12:14,320
actually being invoked for compile-time

00:12:13,200 --> 00:12:16,480
evaluation

00:12:14,320 --> 00:12:17,600
or if it's just being called um at

00:12:16,480 --> 00:12:19,040
runtime

00:12:17,600 --> 00:12:22,160
that's what the standard refers to is

00:12:19,040 --> 00:12:24,399
manifestly constant evaluated or not

00:12:22,160 --> 00:12:26,000
and so that is actually responsible for

00:12:24,399 --> 00:12:27,760
a lot of the context for stuff that

00:12:26,000 --> 00:12:28,320
we're doing whenever we want to do a

00:12:27,760 --> 00:12:30,399
cool

00:12:28,320 --> 00:12:31,760
optimization at runtime by calling

00:12:30,399 --> 00:12:34,639
memset or memcomp

00:12:31,760 --> 00:12:36,480
um is constant evaluated lets us combine

00:12:34,639 --> 00:12:38,480
that runtime optimization

00:12:36,480 --> 00:12:40,079
with a fallback for compile time

00:12:38,480 --> 00:12:43,279
programming where we cannot call

00:12:40,079 --> 00:12:44,480
um uh see runtime functions like memsaid

00:12:43,279 --> 00:12:46,240
and memcomp

00:12:44,480 --> 00:12:48,720
there's even more context for coming in

00:12:46,240 --> 00:12:49,839
the future uh my co-worker mia's working

00:12:48,720 --> 00:12:52,480
on that

00:12:49,839 --> 00:12:54,399
we've got some library supports that

00:12:52,480 --> 00:12:56,480
will power the context for string and

00:12:54,399 --> 00:12:58,079
constexpr vector features

00:12:56,480 --> 00:13:01,200
so there i've linked the github issues

00:12:58,079 --> 00:13:04,639
that are tracking that work

00:13:01,200 --> 00:13:06,800
so i mentioned that constexpr has been

00:13:04,639 --> 00:13:09,200
steadily increasing in power

00:13:06,800 --> 00:13:10,399
but it might seem strange and irrelevant

00:13:09,200 --> 00:13:12,480
to you if you're not

00:13:10,399 --> 00:13:14,320
primarily a template meta programmer and

00:13:12,480 --> 00:13:16,399
you've been working at compile time

00:13:14,320 --> 00:13:17,680
for years already if you just write code

00:13:16,399 --> 00:13:19,680
that executes at runtime

00:13:17,680 --> 00:13:21,600
you might be wondering well why would i

00:13:19,680 --> 00:13:23,360
ever use constexpr why do i need to run

00:13:21,600 --> 00:13:24,959
code on my machine um

00:13:23,360 --> 00:13:27,600
you know i don't care about any of those

00:13:24,959 --> 00:13:28,560
features but you probably have used

00:13:27,600 --> 00:13:33,279
lookup tables

00:13:28,560 --> 00:13:36,160
at some point they're very common and

00:13:33,279 --> 00:13:37,680
spur especially with the new algorithms

00:13:36,160 --> 00:13:39,519
that have been added in css20 is

00:13:37,680 --> 00:13:41,360
directly relevant to this

00:13:39,519 --> 00:13:42,880
so if you have a lookup table you can

00:13:41,360 --> 00:13:44,560
express that in lots of ways the one of

00:13:42,880 --> 00:13:45,839
the simplest ways in cs plus is just to

00:13:44,560 --> 00:13:47,279
say i'm going to have a stood map i'm

00:13:45,839 --> 00:13:49,440
going to insert some key value pairs

00:13:47,279 --> 00:13:50,720
then i can just look them up by key

00:13:49,440 --> 00:13:52,320
but if you think about what that's doing

00:13:50,720 --> 00:13:55,120
at runtime that's going to be allocating

00:13:52,320 --> 00:13:57,279
memory for each individual node

00:13:55,120 --> 00:13:58,959
and then lookups are going to be

00:13:57,279 --> 00:14:00,160
logarithmic time they're going to hop

00:13:58,959 --> 00:14:04,160
through

00:14:00,160 --> 00:14:06,880
the pointers in this balanced tree

00:14:04,160 --> 00:14:08,160
and that is not necessarily the most

00:14:06,880 --> 00:14:10,000
efficient thing and yeah you could use a

00:14:08,160 --> 00:14:11,120
hash table unordered map or another data

00:14:10,000 --> 00:14:12,639
structure like that but you're still

00:14:11,120 --> 00:14:14,959
allocating nodes

00:14:12,639 --> 00:14:16,720
um and it's going to consume a lot of

00:14:14,959 --> 00:14:18,000
space even if it is relatively efficient

00:14:16,720 --> 00:14:21,199
in time

00:14:18,000 --> 00:14:23,440
so if you simply have

00:14:21,199 --> 00:14:25,360
an array whether a built in array or

00:14:23,440 --> 00:14:28,320
stood array of pairs

00:14:25,360 --> 00:14:29,600
of keys and values that is as efficient

00:14:28,320 --> 00:14:30,320
as you can possibly get you can't do

00:14:29,600 --> 00:14:32,000
better

00:14:30,320 --> 00:14:33,760
in locality than just having all your

00:14:32,000 --> 00:14:35,360
elements be contiguous

00:14:33,760 --> 00:14:36,800
and if the array is sorted it can be

00:14:35,360 --> 00:14:38,320
very time efficient because you can just

00:14:36,800 --> 00:14:40,000
use one of the stl's binary search

00:14:38,320 --> 00:14:42,320
algorithms to find what you want

00:14:40,000 --> 00:14:44,720
it'll be logarithmic time like all

00:14:42,320 --> 00:14:47,360
binary searches so a hash table may

00:14:44,720 --> 00:14:49,279
beat it in some cases but due to the

00:14:47,360 --> 00:14:52,639
compactness of the array the array is

00:14:49,279 --> 00:14:54,399
very um very efficient and now you can

00:14:52,639 --> 00:14:57,040
use constexpr algorithms

00:14:54,399 --> 00:14:58,160
to make this easier to maintain so if

00:14:57,040 --> 00:15:00,480
you have a sorted array

00:14:58,160 --> 00:15:02,160
if you during maintenance have a

00:15:00,480 --> 00:15:03,600
programmer maybe not you maybe somebody

00:15:02,160 --> 00:15:06,320
else come in and add

00:15:03,600 --> 00:15:07,760
uh enter add an entry um that is not in

00:15:06,320 --> 00:15:09,440
sorted order well you've just broken

00:15:07,760 --> 00:15:12,560
your invariant and that's bad

00:15:09,440 --> 00:15:15,920
um but now um instead of having

00:15:12,560 --> 00:15:18,079
like uh a runtime check in like your

00:15:15,920 --> 00:15:19,120
you know debug build uh that checks that

00:15:18,079 --> 00:15:21,199
the array is sorted

00:15:19,120 --> 00:15:22,880
now you can just say static assert is

00:15:21,199 --> 00:15:25,839
sorted my array

00:15:22,880 --> 00:15:27,120
um and if it is if the invariant is

00:15:25,839 --> 00:15:29,120
broken during maintenance

00:15:27,120 --> 00:15:30,240
your program will fail to compile which

00:15:29,120 --> 00:15:31,519
is great you'll never

00:15:30,240 --> 00:15:33,360
potentially ship that bug to your

00:15:31,519 --> 00:15:35,040
customers and if you write

00:15:33,360 --> 00:15:36,480
a little more elaborate code you can

00:15:35,040 --> 00:15:38,399
even make it so that

00:15:36,480 --> 00:15:39,600
you can add entries in any old order you

00:15:38,399 --> 00:15:42,720
want

00:15:39,600 --> 00:15:44,160
and you can get a context for sort um

00:15:42,720 --> 00:15:45,839
provided by the standard library to

00:15:44,160 --> 00:15:47,279
actually just sort your array as you

00:15:45,839 --> 00:15:48,880
build your program you don't need a

00:15:47,279 --> 00:15:50,639
separate step you don't need to run a

00:15:48,880 --> 00:15:52,160
script or something and generate a

00:15:50,639 --> 00:15:53,680
you know a header that's picked up by

00:15:52,160 --> 00:15:54,480
the rest of your build constexpr can

00:15:53,680 --> 00:15:56,800
just do that

00:15:54,480 --> 00:15:59,360
as you compile your program and then it

00:15:56,800 --> 00:16:03,040
all vanishes as far as runtime

00:15:59,360 --> 00:16:05,199
um is concerned so let's look at an

00:16:03,040 --> 00:16:07,600
example here this is uh derived from one

00:16:05,199 --> 00:16:11,920
of our tools um in the repo

00:16:07,600 --> 00:16:11,920
that scans our files and looks for

00:16:12,160 --> 00:16:15,360
things like trailing white space overly

00:16:13,920 --> 00:16:16,880
long lines

00:16:15,360 --> 00:16:18,800
and will trigger a check in our

00:16:16,880 --> 00:16:21,839
continuous integration system

00:16:18,800 --> 00:16:23,040
but we want to skip files like dlls exes

00:16:21,839 --> 00:16:26,399
object files

00:16:23,040 --> 00:16:27,040
that are just binary um so the way that

00:16:26,399 --> 00:16:29,360
we do this

00:16:27,040 --> 00:16:31,040
is we have a static constexpr array of

00:16:29,360 --> 00:16:33,440
string views

00:16:31,040 --> 00:16:35,839
and string views have context for

00:16:33,440 --> 00:16:39,600
constructors that can be compared

00:16:35,839 --> 00:16:41,440
at compile time um unlike

00:16:39,600 --> 00:16:43,600
you know stood strings before the

00:16:41,440 --> 00:16:45,920
constexpr string feature

00:16:43,600 --> 00:16:47,759
so here i'm also using class template

00:16:45,920 --> 00:16:49,440
argument deduction to avoid having to

00:16:47,759 --> 00:16:51,040
say how many string views there are in

00:16:49,440 --> 00:16:53,279
this stood array

00:16:51,040 --> 00:16:54,720
um i've got my list of skipped

00:16:53,279 --> 00:16:57,360
extensions there which i have

00:16:54,720 --> 00:16:59,600
ensured at you know as i programmed this

00:16:57,360 --> 00:17:01,440
that i put them in sorted order

00:16:59,600 --> 00:17:02,880
but i want to make sure that as this is

00:17:01,440 --> 00:17:05,280
maintained in the future

00:17:02,880 --> 00:17:07,600
that invariant is preserved so i can

00:17:05,280 --> 00:17:09,120
simply say static assert is sorted

00:17:07,600 --> 00:17:12,000
and give it that skipped extensions

00:17:09,120 --> 00:17:14,160
array and if that succeeds

00:17:12,000 --> 00:17:15,600
then there's no code executed at runtime

00:17:14,160 --> 00:17:16,319
to verify that it's sorted it all

00:17:15,600 --> 00:17:19,439
happens

00:17:16,319 --> 00:17:21,520
at build time now here um just for

00:17:19,439 --> 00:17:22,559
clarity and to show off another feature

00:17:21,520 --> 00:17:25,280
um i'm using

00:17:22,559 --> 00:17:26,079
ranges is sorted which is also available

00:17:25,280 --> 00:17:29,600
um

00:17:26,079 --> 00:17:32,080
in constexpr compile time

00:17:29,600 --> 00:17:33,520
that's implemented by my co-worker casey

00:17:32,080 --> 00:17:35,919
who's been adding a whole bunch of

00:17:33,520 --> 00:17:35,919
ranges

00:17:36,640 --> 00:17:40,480
algorithms and views and adapters to the

00:17:38,960 --> 00:17:43,280
library

00:17:40,480 --> 00:17:44,240
but the original classic stood as sorted

00:17:43,280 --> 00:17:46,320
is also

00:17:44,240 --> 00:17:48,559
const expert you just have to pass it

00:17:46,320 --> 00:17:51,039
separate begin and end iterators

00:17:48,559 --> 00:17:51,600
so after i've verified that the array is

00:17:51,039 --> 00:17:53,679
sorted

00:17:51,600 --> 00:17:56,080
then i can use an ordinary runtime

00:17:53,679 --> 00:17:57,679
binary search to see whether a specific

00:17:56,080 --> 00:17:59,200
extension is in the array here i just

00:17:57,679 --> 00:18:00,320
want a yes or no answer so i can use

00:17:59,200 --> 00:18:03,120
stood binary search

00:18:00,320 --> 00:18:05,200
or ranges binary search here instead of

00:18:03,120 --> 00:18:06,720
lower bound or equal range which i would

00:18:05,200 --> 00:18:10,400
need to find

00:18:06,720 --> 00:18:12,559
an element and see what it contains

00:18:10,400 --> 00:18:15,039
so this is a hybrid of compile time and

00:18:12,559 --> 00:18:16,799
runtime programming as well

00:18:15,039 --> 00:18:17,919
okay so let's switch gears a little and

00:18:16,799 --> 00:18:18,720
let's talk about what if you have a

00:18:17,919 --> 00:18:20,480
container

00:18:18,720 --> 00:18:22,400
and you have elements in it that you

00:18:20,480 --> 00:18:24,240
don't want anymore

00:18:22,400 --> 00:18:25,520
this can happen for lots of reasons

00:18:24,240 --> 00:18:28,160
maybe you're

00:18:25,520 --> 00:18:30,080
building up you know a list and then the

00:18:28,160 --> 00:18:33,360
user decides that they want to

00:18:30,080 --> 00:18:33,919
erase you know elements from it maybe

00:18:33,360 --> 00:18:35,840
you

00:18:33,919 --> 00:18:36,960
programming a game and you've got

00:18:35,840 --> 00:18:40,160
enemies in

00:18:36,960 --> 00:18:43,280
a list or a vector and their hit points

00:18:40,160 --> 00:18:45,679
fall to zero and they need to be removed

00:18:43,280 --> 00:18:47,120
any any case where you need to call

00:18:45,679 --> 00:18:48,880
undesired elements

00:18:47,120 --> 00:18:50,640
um how do you get rid of them from a

00:18:48,880 --> 00:18:53,760
container well

00:18:50,640 --> 00:18:56,080
in previous standards this was actually

00:18:53,760 --> 00:18:58,799
a surprisingly tricky problem

00:18:56,080 --> 00:19:00,559
and it the answer before cs 20 actually

00:18:58,799 --> 00:19:01,919
depended on the specific container you

00:19:00,559 --> 00:19:04,480
were working with

00:19:01,919 --> 00:19:06,160
so if you had a vector-like container

00:19:04,480 --> 00:19:10,080
and here vector-like means

00:19:06,160 --> 00:19:13,120
vector deck or string you needed to use

00:19:10,080 --> 00:19:14,880
the erase remove idiom that books like

00:19:13,120 --> 00:19:17,520
scott meyer's effective stl have been

00:19:14,880 --> 00:19:19,840
talking about for decades

00:19:17,520 --> 00:19:20,799
and that's a very strange bit of code

00:19:19,840 --> 00:19:22,480
that you would never

00:19:20,799 --> 00:19:25,280
guess would be needed if you weren't

00:19:22,480 --> 00:19:27,120
specifically told about it

00:19:25,280 --> 00:19:29,120
but if you have a list like container

00:19:27,120 --> 00:19:31,039
and here i'm referring to stood list

00:19:29,120 --> 00:19:32,799
and stood forward list there are

00:19:31,039 --> 00:19:34,880
actually member functions called

00:19:32,799 --> 00:19:36,400
strangely remove and remove if that will

00:19:34,880 --> 00:19:39,120
erase elements

00:19:36,400 --> 00:19:40,320
and um for forward list that's very

00:19:39,120 --> 00:19:42,000
important because it turns out to be

00:19:40,320 --> 00:19:44,240
really obnoxious to write by hand for

00:19:42,000 --> 00:19:46,000
stood list that's an interesting case

00:19:44,240 --> 00:19:48,080
because although you can use the erase

00:19:46,000 --> 00:19:49,919
remove idiom with a stood list

00:19:48,080 --> 00:19:51,919
the remove and remove if member

00:19:49,919 --> 00:19:53,600
functions will just directly unlink

00:19:51,919 --> 00:19:55,520
nodes which can be more efficient and

00:19:53,600 --> 00:19:58,080
require less from the elements

00:19:55,520 --> 00:19:58,799
and if you have an associative container

00:19:58,080 --> 00:20:01,039
whether

00:19:58,799 --> 00:20:03,360
ordered or unordered so this is the map

00:20:01,039 --> 00:20:05,280
multi-map set multi-set unordered map

00:20:03,360 --> 00:20:07,120
and so forth family

00:20:05,280 --> 00:20:08,559
you don't get either of those approaches

00:20:07,120 --> 00:20:09,520
you can't erase or move because you

00:20:08,559 --> 00:20:11,679
can't assign

00:20:09,520 --> 00:20:14,240
keys in such a container and there are

00:20:11,679 --> 00:20:15,679
no remove and remove if number functions

00:20:14,240 --> 00:20:19,039
instead you have to write a handwritten

00:20:15,679 --> 00:20:20,960
loop that iterates over every element

00:20:19,039 --> 00:20:22,720
in the container and then uses the erase

00:20:20,960 --> 00:20:26,400
itermember function

00:20:22,720 --> 00:20:29,120
to snip out nodes that you don't want

00:20:26,400 --> 00:20:30,799
but this is incredibly hazardous so here

00:20:29,120 --> 00:20:32,559
i have a list of all the ways that it

00:20:30,799 --> 00:20:35,600
can go wrong

00:20:32,559 --> 00:20:36,240
the first is if you just call the remove

00:20:35,600 --> 00:20:38,960
if

00:20:36,240 --> 00:20:39,520
um non-member function and then don't do

00:20:38,960 --> 00:20:41,360
anything

00:20:39,520 --> 00:20:43,200
with the return value that's a bug

00:20:41,360 --> 00:20:43,760
because remove if despite the name does

00:20:43,200 --> 00:20:46,960
not

00:20:43,760 --> 00:20:48,240
remove elements as a user would you know

00:20:46,960 --> 00:20:50,000
ordinarily expect

00:20:48,240 --> 00:20:51,760
instead it compactifies the good

00:20:50,000 --> 00:20:53,679
elements the beginning of the range

00:20:51,760 --> 00:20:55,520
and leaves the end of the range as

00:20:53,679 --> 00:20:57,120
unspecified garbage

00:20:55,520 --> 00:20:59,200
nowadays it's typically moved from

00:20:57,120 --> 00:21:02,880
garbage and you need to call

00:20:59,200 --> 00:21:04,559
the erase member function to get rid of

00:21:02,880 --> 00:21:06,640
that garbage at the end of the container

00:21:04,559 --> 00:21:07,360
because the non-member algorithm cannot

00:21:06,640 --> 00:21:10,080
affect

00:21:07,360 --> 00:21:12,240
the size of the container so this used

00:21:10,080 --> 00:21:13,679
to be a silent bug now we'll at least

00:21:12,240 --> 00:21:14,960
catch it thanks to the no discard

00:21:13,679 --> 00:21:18,400
feature that we've applied

00:21:14,960 --> 00:21:20,400
to over 3000 functions in the stl

00:21:18,400 --> 00:21:22,159
but it's still possible to get wrong so

00:21:20,400 --> 00:21:24,080
the second bullet point there

00:21:22,159 --> 00:21:25,840
um shows you can still write a race

00:21:24,080 --> 00:21:28,799
remove and get it wrong if you write via

00:21:25,840 --> 00:21:31,440
race remove if v begin vn pred

00:21:28,799 --> 00:21:33,120
then that's actually a bug and it's a

00:21:31,440 --> 00:21:34,240
very subtle bug because if you look at

00:21:33,120 --> 00:21:36,960
that call

00:21:34,240 --> 00:21:38,640
you're calling the single iterator form

00:21:36,960 --> 00:21:41,280
of via rakes and that will

00:21:38,640 --> 00:21:42,080
erase a single element from the sequence

00:21:41,280 --> 00:21:44,320
and then

00:21:42,080 --> 00:21:46,400
shift the remaining elements backwards

00:21:44,320 --> 00:21:48,320
to fill the hole that's left

00:21:46,400 --> 00:21:50,880
that is not what you want you want to

00:21:48,320 --> 00:21:51,840
call the two iterator form of container

00:21:50,880 --> 00:21:54,240
erase

00:21:51,840 --> 00:21:54,880
to erase a range of elements beginning

00:21:54,240 --> 00:21:57,360
where

00:21:54,880 --> 00:21:59,120
the remove if returns an iterator all

00:21:57,360 --> 00:22:01,280
the way to the end of your vector so

00:21:59,120 --> 00:22:03,919
you actually need a comma v end at the

00:22:01,280 --> 00:22:05,760
end there to get that correct and this

00:22:03,919 --> 00:22:07,760
is very scary because if you forget to

00:22:05,760 --> 00:22:10,880
say comma v dot end

00:22:07,760 --> 00:22:12,000
it will compile and it will run and some

00:22:10,880 --> 00:22:14,000
of the time it will

00:22:12,000 --> 00:22:16,000
actually work um because if you remove a

00:22:14,000 --> 00:22:18,240
single element it you know ends up doing

00:22:16,000 --> 00:22:19,200
you know the correct thing um but if you

00:22:18,240 --> 00:22:20,880
yeah end up

00:22:19,200 --> 00:22:22,720
trying to remove multiple elements then

00:22:20,880 --> 00:22:25,919
you've you know corrupted your

00:22:22,720 --> 00:22:27,039
um your state um it's possible to get it

00:22:25,919 --> 00:22:30,640
right but slow

00:22:27,039 --> 00:22:32,640
um so i've seen people write the

00:22:30,640 --> 00:22:34,480
loop to erase individual elements but if

00:22:32,640 --> 00:22:35,760
you apply that to a vector every time

00:22:34,480 --> 00:22:37,520
you erase one element

00:22:35,760 --> 00:22:39,200
you've got to shift back uh the

00:22:37,520 --> 00:22:40,320
remaining elements and that is classic

00:22:39,200 --> 00:22:41,280
quadratic time

00:22:40,320 --> 00:22:42,640
and that's the sort of thing that'll

00:22:41,280 --> 00:22:44,240
seem fine when you test it with 10

00:22:42,640 --> 00:22:46,400
elements and it's going to fall over in

00:22:44,240 --> 00:22:48,480
production when you've got 10 000.

00:22:46,400 --> 00:22:49,919
um so many other ways to get it wrong if

00:22:48,480 --> 00:22:51,840
you've got the handwritten loop working

00:22:49,919 --> 00:22:53,440
in a map container i've seen people

00:22:51,840 --> 00:22:55,360
invalidate the iterator that they're

00:22:53,440 --> 00:22:56,000
standing on before hopping to the next

00:22:55,360 --> 00:22:58,559
one

00:22:56,000 --> 00:22:59,679
or if you get your increase your timing

00:22:58,559 --> 00:23:01,679
of increments wrong

00:22:59,679 --> 00:23:03,120
you can skip elements and that's very

00:23:01,679 --> 00:23:04,400
pernicious because

00:23:03,120 --> 00:23:05,840
sometimes you'll be skipping elements

00:23:04,400 --> 00:23:07,600
that you wanted to keep anyways but if

00:23:05,840 --> 00:23:09,200
you skip an element you wanted to remove

00:23:07,600 --> 00:23:11,440
uh-oh you've you know corrupted your

00:23:09,200 --> 00:23:12,720
state um and you've you know left

00:23:11,440 --> 00:23:13,440
elements that you really wanted to get

00:23:12,720 --> 00:23:15,600
rid of

00:23:13,440 --> 00:23:16,480
um so this is problematic why is

00:23:15,600 --> 00:23:19,679
something that is so

00:23:16,480 --> 00:23:21,360
should be so easy so difficult in cs

00:23:19,679 --> 00:23:23,039
20 there's a feature uniform container

00:23:21,360 --> 00:23:24,720
erasure um that i had originally

00:23:23,039 --> 00:23:25,520
proposed for the library fundamentalsts

00:23:24,720 --> 00:23:27,679
and then

00:23:25,520 --> 00:23:28,799
was later moved into the standard

00:23:27,679 --> 00:23:30,640
library um

00:23:28,799 --> 00:23:32,240
the this took the form of a pair of

00:23:30,640 --> 00:23:34,720
papers that were implemented by

00:23:32,240 --> 00:23:37,200
our contributor superwig um so here i've

00:23:34,720 --> 00:23:37,840
got an example um if i have a vector

00:23:37,200 --> 00:23:40,320
string

00:23:37,840 --> 00:23:41,440
um and just fill it with you know the

00:23:40,320 --> 00:23:45,039
names of some animals

00:23:41,440 --> 00:23:48,080
um then i decide okay i don't want um

00:23:45,039 --> 00:23:50,640
any animals whose length

00:23:48,080 --> 00:23:52,159
is greater than three characters um so i

00:23:50,640 --> 00:23:52,880
can express that in the form of a

00:23:52,159 --> 00:23:54,799
function

00:23:52,880 --> 00:23:56,000
a lambda here i've got a lambda called

00:23:54,799 --> 00:23:58,960
pred um

00:23:56,000 --> 00:24:00,080
all i need to do is call stood erase if

00:23:58,960 --> 00:24:02,080
and give it my vector

00:24:00,080 --> 00:24:03,840
and give it my predicate um and it will

00:24:02,080 --> 00:24:04,880
erase all the elements that satisfy that

00:24:03,840 --> 00:24:07,600
predicate

00:24:04,880 --> 00:24:09,120
so here bear and lion are length four

00:24:07,600 --> 00:24:10,320
greater than three those will be erased

00:24:09,120 --> 00:24:13,440
and i'll be left with just

00:24:10,320 --> 00:24:14,640
dog cat ox dog there i can also say okay

00:24:13,440 --> 00:24:17,760
i've got a specific

00:24:14,640 --> 00:24:19,279
a specific value i want to get rid of

00:24:17,760 --> 00:24:20,640
so instead of giving a predicate i can

00:24:19,279 --> 00:24:23,360
just give it a value i can just say

00:24:20,640 --> 00:24:25,279
erase all occurrences of dog

00:24:23,360 --> 00:24:26,400
and here it doesn't need to be the same

00:24:25,279 --> 00:24:28,799
type as the

00:24:26,400 --> 00:24:30,240
elements of my container here i have a

00:24:28,799 --> 00:24:33,120
vector stood string

00:24:30,240 --> 00:24:34,000
but i can give it a a classic uh c

00:24:33,120 --> 00:24:35,520
string uh

00:24:34,000 --> 00:24:37,760
in this case it will be an array that

00:24:35,520 --> 00:24:39,600
decays the consecutive star

00:24:37,760 --> 00:24:41,919
and i can erase anything that's

00:24:39,600 --> 00:24:44,159
comparable to my elements with equality

00:24:41,919 --> 00:24:45,840
so if i erase the dogs then i'm going to

00:24:44,159 --> 00:24:47,039
be left with just two elements cat and

00:24:45,840 --> 00:24:50,400
ox that have

00:24:47,039 --> 00:24:53,279
survived those two erasures so this is

00:24:50,400 --> 00:24:54,960
simple um and it is uniform it works

00:24:53,279 --> 00:24:56,559
with all of the containers

00:24:54,960 --> 00:24:58,480
there's one twist with the associative

00:24:56,559 --> 00:25:00,400
containers where only a race if is

00:24:58,480 --> 00:25:02,640
provided to avoid confusion

00:25:00,400 --> 00:25:05,279
there's a bonus slide explaining that

00:25:02,640 --> 00:25:06,960
but in no case is it going to

00:25:05,279 --> 00:25:08,559
you know compile and then accidentally

00:25:06,960 --> 00:25:11,600
do quadratic behavior

00:25:08,559 --> 00:25:14,080
or compile but not erase all the

00:25:11,600 --> 00:25:16,240
elements you want

00:25:14,080 --> 00:25:18,000
so that's the uniform container erasure

00:25:16,240 --> 00:25:20,320
feature in cs 20.

00:25:18,000 --> 00:25:22,320
now let's switch gears entirely let's

00:25:20,320 --> 00:25:24,559
talk about multi-threading

00:25:22,320 --> 00:25:25,520
so multi-threading has been a recurring

00:25:24,559 --> 00:25:28,480
theme of

00:25:25,520 --> 00:25:29,520
cs plus in cs 11 and beyond um and i

00:25:28,480 --> 00:25:31,200
hear in

00:25:29,520 --> 00:25:33,279
later standards we'll be getting even

00:25:31,200 --> 00:25:34,640
more multi-threading like executors and

00:25:33,279 --> 00:25:36,080
things like that

00:25:34,640 --> 00:25:40,080
so one of the things that was added in

00:25:36,080 --> 00:25:43,360
cs 20 is called atomic ref

00:25:40,080 --> 00:25:45,039
and if you've heard of atomic then this

00:25:43,360 --> 00:25:46,720
atomic ref might seem

00:25:45,039 --> 00:25:48,640
uh you know strange like why do we need

00:25:46,720 --> 00:25:50,400
yet another atomic type

00:25:48,640 --> 00:25:52,240
and it actually ends up being similar

00:25:50,400 --> 00:25:54,880
but different to stood atomic

00:25:52,240 --> 00:25:56,400
so the way that i think of it is stood

00:25:54,880 --> 00:25:59,279
atomic bundles together

00:25:56,400 --> 00:26:00,880
two things um a stereotype a stood

00:25:59,279 --> 00:26:03,279
atomic of t

00:26:00,880 --> 00:26:04,320
provides both storage for that t

00:26:03,279 --> 00:26:07,120
somewhere within its

00:26:04,320 --> 00:26:08,000
um representation and it controls atomic

00:26:07,120 --> 00:26:10,720
access

00:26:08,000 --> 00:26:12,320
so you have to say dot low dot store dot

00:26:10,720 --> 00:26:14,080
compare exchange week

00:26:12,320 --> 00:26:16,320
um or use the couple of implicit

00:26:14,080 --> 00:26:19,520
conversions for assignments and uh

00:26:16,320 --> 00:26:21,200
loading you know storing um and

00:26:19,520 --> 00:26:23,360
it's not going to let you directly

00:26:21,200 --> 00:26:26,000
manipulate that t

00:26:23,360 --> 00:26:27,440
atomic ref is different it separates

00:26:26,000 --> 00:26:30,000
this by saying okay

00:26:27,440 --> 00:26:31,440
i will control the atomic access but i

00:26:30,000 --> 00:26:33,279
don't own the t the t

00:26:31,440 --> 00:26:35,039
is somewhere external and i'm just a

00:26:33,279 --> 00:26:36,720
reference to it

00:26:35,039 --> 00:26:38,320
this is kind of like reference wrapper

00:26:36,720 --> 00:26:39,840
that stores a pointer but otherwise

00:26:38,320 --> 00:26:42,799
behaves like a reference

00:26:39,840 --> 00:26:45,279
atomic ref essentially stores a pointer

00:26:42,799 --> 00:26:47,039
but otherwise behaves like an atomic

00:26:45,279 --> 00:26:49,679
so the paper that proposed the feature

00:26:47,039 --> 00:26:51,279
p19r8 explains a couple scenarios

00:26:49,679 --> 00:26:52,960
and my co-worker bill o'neil explained

00:26:51,279 --> 00:26:54,000
another one to me um those are listed

00:26:52,960 --> 00:26:55,600
here

00:26:54,000 --> 00:26:57,279
so the reasons why you might want to use

00:26:55,600 --> 00:27:00,720
this imagine that you have a program

00:26:57,279 --> 00:27:03,120
with a couple parts that occur

00:27:00,720 --> 00:27:04,000
separately in time so at first your

00:27:03,120 --> 00:27:05,919
program

00:27:04,000 --> 00:27:08,559
operates on some data structure in a

00:27:05,919 --> 00:27:10,400
single threaded way a common

00:27:08,559 --> 00:27:11,679
theme is like i got to initialize it or

00:27:10,400 --> 00:27:12,880
i'm going to load it from disk or

00:27:11,679 --> 00:27:14,799
something

00:27:12,880 --> 00:27:16,159
and then later you have another part of

00:27:14,799 --> 00:27:18,960
the program that operates on it in a

00:27:16,159 --> 00:27:21,919
multi-threaded highly concurrent way

00:27:18,960 --> 00:27:24,000
so if you make the whole thing atomic

00:27:21,919 --> 00:27:24,960
you would be paying unnecessary costs uh

00:27:24,000 --> 00:27:27,840
you know atomic

00:27:24,960 --> 00:27:29,919
uh increments atomic or interlocked

00:27:27,840 --> 00:27:32,000
exchanges or whatever your platform has

00:27:29,919 --> 00:27:34,240
um that are typically more expensive

00:27:32,000 --> 00:27:35,360
than plain old you know single threaded

00:27:34,240 --> 00:27:36,960
operations

00:27:35,360 --> 00:27:38,559
having to pay that during the single

00:27:36,960 --> 00:27:40,480
threaded phaser code

00:27:38,559 --> 00:27:42,240
where you don't get parallelism so you

00:27:40,480 --> 00:27:43,760
really care about performance um that is

00:27:42,240 --> 00:27:45,679
undesirable

00:27:43,760 --> 00:27:47,120
and yet that's a cost that stood atomic

00:27:45,679 --> 00:27:49,679
would have forced you to pay

00:27:47,120 --> 00:27:50,960
with atomic ref you can say okay i am

00:27:49,679 --> 00:27:54,159
going to

00:27:50,960 --> 00:27:55,520
use ordinary plain old t objects during

00:27:54,159 --> 00:27:56,799
the single threaded part of my program

00:27:55,520 --> 00:27:58,240
and then when it comes time to do

00:27:56,799 --> 00:27:59,600
multi-threaded things i'm going to

00:27:58,240 --> 00:28:02,159
construct atomic graphs

00:27:59,600 --> 00:28:03,279
and use them for the atomic axis

00:28:02,159 --> 00:28:06,559
somewhat similarly

00:28:03,279 --> 00:28:08,000
the paper p19r8 um talks about programs

00:28:06,559 --> 00:28:09,279
that have non-conflicting and

00:28:08,000 --> 00:28:12,720
conflicting

00:28:09,279 --> 00:28:15,039
uh parts so if you imagine

00:28:12,720 --> 00:28:17,120
like you've got a large array in memory

00:28:15,039 --> 00:28:17,919
you can have parallel access to its

00:28:17,120 --> 00:28:21,520
elements

00:28:17,919 --> 00:28:22,399
um without any sort of atomic access or

00:28:21,520 --> 00:28:25,200
mutexes

00:28:22,399 --> 00:28:25,760
as long as each axis is is to a distinct

00:28:25,200 --> 00:28:28,240
element

00:28:25,760 --> 00:28:29,520
as in that case the axis is

00:28:28,240 --> 00:28:31,840
non-conflicting

00:28:29,520 --> 00:28:32,880
so even if you have you know a million

00:28:31,840 --> 00:28:33,919
elements in memory

00:28:32,880 --> 00:28:35,279
and you've got you know a thousand

00:28:33,919 --> 00:28:36,320
threads or whatever working on it as

00:28:35,279 --> 00:28:38,480
long as they don't work on the same

00:28:36,320 --> 00:28:40,799
element simultaneously you're okay

00:28:38,480 --> 00:28:42,480
um and later on if you have part of your

00:28:40,799 --> 00:28:43,919
program that does need multiple threads

00:28:42,480 --> 00:28:45,840
you're modifying a single element at

00:28:43,919 --> 00:28:47,600
that point you want atomicity

00:28:45,840 --> 00:28:49,200
so that's another scenario for tomograph

00:28:47,600 --> 00:28:50,399
and then the third one

00:28:49,200 --> 00:28:52,640
is if you're working with a data

00:28:50,399 --> 00:28:53,520
structure that you can't invasively

00:28:52,640 --> 00:28:55,919
modify

00:28:53,520 --> 00:28:56,880
like a c struct from external library

00:28:55,919 --> 00:28:59,279
code

00:28:56,880 --> 00:29:01,360
and yet sometimes you want to update its

00:28:59,279 --> 00:29:03,279
members atomically that's a use case for

00:29:01,360 --> 00:29:04,799
atomic ref

00:29:03,279 --> 00:29:06,880
but aside from that distinction of you

00:29:04,799 --> 00:29:08,640
know what do they store

00:29:06,880 --> 00:29:10,960
they really have extremely similar

00:29:08,640 --> 00:29:12,559
interfaces aside from initialization

00:29:10,960 --> 00:29:14,159
so it still provides all the advantages

00:29:12,559 --> 00:29:16,799
of stood atomic it's going to ramp

00:29:14,159 --> 00:29:18,799
up whatever special intrinsics or

00:29:16,799 --> 00:29:21,760
compiler magic is necessary

00:29:18,799 --> 00:29:22,399
um to provide these atomic operations

00:29:21,760 --> 00:29:23,840
and

00:29:22,399 --> 00:29:25,679
all the new features that atomic has

00:29:23,840 --> 00:29:27,039
recently gained i'm like wait notify

00:29:25,679 --> 00:29:28,880
notify all

00:29:27,039 --> 00:29:30,399
those are supported equally by atomic

00:29:28,880 --> 00:29:32,559
atomic rev

00:29:30,399 --> 00:29:34,080
so this feature was implemented over the

00:29:32,559 --> 00:29:36,080
course of several months um by our

00:29:34,080 --> 00:29:37,279
contributor alex kutenyev it was quite a

00:29:36,080 --> 00:29:39,039
large pr

00:29:37,279 --> 00:29:40,640
so i encourage you to check it out see

00:29:39,039 --> 00:29:42,799
what what's involved in uh

00:29:40,640 --> 00:29:43,679
implementing this feature so this is one

00:29:42,799 --> 00:29:46,240
of those features that's

00:29:43,679 --> 00:29:48,480
really hard to present in like a single

00:29:46,240 --> 00:29:49,919
slide

00:29:48,480 --> 00:29:52,000
usually you would see it in the context

00:29:49,919 --> 00:29:53,200
of a much larger program that's doing

00:29:52,000 --> 00:29:55,600
interesting work

00:29:53,200 --> 00:29:57,440
in a multi-threaded way in this case i

00:29:55,600 --> 00:30:00,159
managed to condense it down to a

00:29:57,440 --> 00:30:01,279
single page of code but it is extremely

00:30:00,159 --> 00:30:03,039
artificial and

00:30:01,279 --> 00:30:06,159
almost completely unrealistic it does

00:30:03,039 --> 00:30:09,279
capture what i wanted to show though

00:30:06,159 --> 00:30:10,880
so here um i start off with an

00:30:09,279 --> 00:30:12,799
int and i'm going to initialize it to

00:30:10,880 --> 00:30:14,720
some arbitrary value 500.

00:30:12,799 --> 00:30:16,320
then the next line shows that this is

00:30:14,720 --> 00:30:18,240
just an int so i can use

00:30:16,320 --> 00:30:21,039
ordinary operations on it i can

00:30:18,240 --> 00:30:23,440
increment it by another 500

00:30:21,039 --> 00:30:24,960
so that sort of turquoise line um that's

00:30:23,440 --> 00:30:27,120
just an ordinary read

00:30:24,960 --> 00:30:28,240
and write did that end so now its value

00:30:27,120 --> 00:30:31,200
is a thousand

00:30:28,240 --> 00:30:33,520
so that in this artificial example is

00:30:31,200 --> 00:30:37,039
the single threaded part of my program

00:30:33,520 --> 00:30:39,440
and then i decide okay i need to start

00:30:37,039 --> 00:30:40,799
doing concurrent modification of this

00:30:39,440 --> 00:30:42,799
because i'm going to do some you know

00:30:40,799 --> 00:30:45,120
really complicated logic

00:30:42,799 --> 00:30:47,440
so here i can i begin a new scope and

00:30:45,120 --> 00:30:49,039
then i um construct an atomic ref also

00:30:47,440 --> 00:30:50,000
using class template arbor deduction

00:30:49,039 --> 00:30:52,799
this is really an atomic

00:30:50,000 --> 00:30:53,440
ref of int i'm going to call it atom and

00:30:52,799 --> 00:30:56,399
so now

00:30:53,440 --> 00:30:58,480
this is going to control all access to i

00:30:56,399 --> 00:31:00,080
and i should not directly modify i

00:30:58,480 --> 00:31:01,039
at this point the standard says hey

00:31:00,080 --> 00:31:02,240
everything needs to go through the

00:31:01,039 --> 00:31:03,919
atomic ref now

00:31:02,240 --> 00:31:05,919
so i can spin up a couple of threads

00:31:03,919 --> 00:31:06,559
that are going to compare exchange this

00:31:05,919 --> 00:31:08,320
value

00:31:06,559 --> 00:31:10,240
and they're going to try to increment it

00:31:08,320 --> 00:31:12,000
um in this case by 10 a bunch of times

00:31:10,240 --> 00:31:14,720
and by one a bunch of other times

00:31:12,000 --> 00:31:16,000
um and then i'm going to wait for those

00:31:14,720 --> 00:31:18,960
threads to join

00:31:16,000 --> 00:31:21,200
um and destroy the atomic ref so that

00:31:18,960 --> 00:31:21,919
concludes the multi-threaded part of my

00:31:21,200 --> 00:31:23,840
program

00:31:21,919 --> 00:31:25,200
and now i can go back to using ordinary

00:31:23,840 --> 00:31:26,720
reads and writes in this case

00:31:25,200 --> 00:31:28,799
i'm just going to have an ordinary read

00:31:26,720 --> 00:31:30,480
i'm going to print out the value of i

00:31:28,799 --> 00:31:31,760
and at this point i've arranged for

00:31:30,480 --> 00:31:33,039
there to be enough you know increments

00:31:31,760 --> 00:31:36,320
by 10 and one

00:31:33,039 --> 00:31:38,159
that it's now the value 1729 so

00:31:36,320 --> 00:31:39,440
this sort of this shows how atomic ref

00:31:38,159 --> 00:31:41,200
can be used um

00:31:39,440 --> 00:31:43,440
but you have to sort of imagine it being

00:31:41,200 --> 00:31:45,519
used in a larger program

00:31:43,440 --> 00:31:47,279
um so i've heard that this is one of the

00:31:45,519 --> 00:31:50,720
most requested features

00:31:47,279 --> 00:31:52,640
for multi-threaded atomic programming

00:31:50,720 --> 00:31:54,640
so hopefully that will be useful in your

00:31:52,640 --> 00:31:55,600
coding so the last feature i want to

00:31:54,640 --> 00:31:59,840
talk about today

00:31:55,600 --> 00:32:03,440
is stood span this is a feature that was

00:31:59,840 --> 00:32:05,519
proposed by microsoft it grew out of our

00:32:03,440 --> 00:32:08,320
guideline support library and now is

00:32:05,519 --> 00:32:11,360
available in standard form

00:32:08,320 --> 00:32:13,600
so you've probably heard about span but

00:32:11,360 --> 00:32:15,360
you may not know how to think about it

00:32:13,600 --> 00:32:15,600
or what scenarios you would want to use

00:32:15,360 --> 00:32:17,840
it

00:32:15,600 --> 00:32:19,360
uh that's you know common when some new

00:32:17,840 --> 00:32:19,840
features released it's like okay i've

00:32:19,360 --> 00:32:22,000
you know

00:32:19,840 --> 00:32:22,880
lived all the way up to cs17 without

00:32:22,000 --> 00:32:25,679
this feature what is

00:32:22,880 --> 00:32:26,480
spam doing for me so the way that i like

00:32:25,679 --> 00:32:29,039
to think about

00:32:26,480 --> 00:32:29,760
span is that it's like a pointer-length

00:32:29,039 --> 00:32:33,360
pair

00:32:29,760 --> 00:32:36,000
but better so if you have a span of

00:32:33,360 --> 00:32:37,039
int that says i don't own these ants

00:32:36,000 --> 00:32:38,480
these ants live

00:32:37,039 --> 00:32:40,399
somewhere else they could be in a

00:32:38,480 --> 00:32:43,360
built-in array a vector

00:32:40,399 --> 00:32:45,279
anything that's contiguous and i'm

00:32:43,360 --> 00:32:48,240
simply going to view them

00:32:45,279 --> 00:32:50,640
this is much like a string view um in cs

00:32:48,240 --> 00:32:52,720
17 except that span works with arbitrary

00:32:50,640 --> 00:32:56,080
elements not just character types

00:32:52,720 --> 00:32:57,840
and span can be used to modify through

00:32:56,080 --> 00:32:59,200
to the elements where string view

00:32:57,840 --> 00:33:02,399
insists on being

00:32:59,200 --> 00:33:04,880
read only so

00:33:02,399 --> 00:33:07,039
why would you want to use a stood span

00:33:04,880 --> 00:33:10,000
the reason is because of all the library

00:33:07,039 --> 00:33:11,200
machinery that we've added to it um you

00:33:10,000 --> 00:33:12,159
know library machinery can be

00:33:11,200 --> 00:33:14,080
complicated

00:33:12,159 --> 00:33:17,120
but it's good complexity when it

00:33:14,080 --> 00:33:20,640
prevents you from writing incorrect code

00:33:17,120 --> 00:33:23,360
so span has a lot of attention paid

00:33:20,640 --> 00:33:24,000
to its implicit construction so you can

00:33:23,360 --> 00:33:26,640
construct it

00:33:24,000 --> 00:33:28,399
from contiguous things continuous ranges

00:33:26,640 --> 00:33:31,440
like arrays and vectors

00:33:28,399 --> 00:33:32,720
but you cannot construct it from things

00:33:31,440 --> 00:33:34,399
that aren't contiguous we'll see an

00:33:32,720 --> 00:33:37,360
example of that later

00:33:34,399 --> 00:33:38,240
and because span is a type in the type

00:33:37,360 --> 00:33:40,480
system

00:33:38,240 --> 00:33:41,679
it's declaring up front that you don't

00:33:40,480 --> 00:33:43,679
own whatever

00:33:41,679 --> 00:33:45,200
is being accessed just says i just want

00:33:43,679 --> 00:33:45,840
to view it maybe i want to modify the

00:33:45,200 --> 00:33:47,440
elements

00:33:45,840 --> 00:33:49,120
but i don't control its lifetime so i'm

00:33:47,440 --> 00:33:50,320
not going to try to delete some pointer

00:33:49,120 --> 00:33:51,600
that's given to me i'm not going to try

00:33:50,320 --> 00:33:53,679
to free it

00:33:51,600 --> 00:33:54,960
and it also avoids all the other hazards

00:33:53,679 --> 00:33:56,399
of pointers

00:33:54,960 --> 00:33:57,840
like you can't accidentally add

00:33:56,399 --> 00:33:59,200
something to a span the way that you can

00:33:57,840 --> 00:34:01,519
accidentally add something to a pointer

00:33:59,200 --> 00:34:04,080
and adjust it through point arithmetic

00:34:01,519 --> 00:34:06,559
and span also prevents other things that

00:34:04,080 --> 00:34:08,960
pointers would happily allow to compile

00:34:06,559 --> 00:34:09,679
span allows you to add consonants in its

00:34:08,960 --> 00:34:12,720
conversion

00:34:09,679 --> 00:34:15,119
but it does not allow you to modify

00:34:12,720 --> 00:34:16,079
or traverse inheritance hierarchies so

00:34:15,119 --> 00:34:19,200
if you have a

00:34:16,079 --> 00:34:19,520
derived star you can implicitly convert

00:34:19,200 --> 00:34:22,079
that

00:34:19,520 --> 00:34:23,119
up to a base star that's how inheritance

00:34:22,079 --> 00:34:25,919
works

00:34:23,119 --> 00:34:27,119
but if you have a pointer to an array of

00:34:25,919 --> 00:34:28,879
derived objects

00:34:27,119 --> 00:34:30,720
you do not want to convert that to a

00:34:28,879 --> 00:34:32,800
pointer to

00:34:30,720 --> 00:34:34,480
base and treat that as an array of base

00:34:32,800 --> 00:34:37,119
objects that would be bad

00:34:34,480 --> 00:34:37,760
um yet plain old pointers in the type

00:34:37,119 --> 00:34:40,240
system

00:34:37,760 --> 00:34:41,760
do that span does not it detects whoa

00:34:40,240 --> 00:34:43,520
i'm only willing to add const here i'm

00:34:41,760 --> 00:34:45,200
not willing to do drive to base

00:34:43,520 --> 00:34:46,639
um that needs an interesting bit of meta

00:34:45,200 --> 00:34:49,119
programming and we've handled that

00:34:46,639 --> 00:34:51,040
in spam the other thing that confuses

00:34:49,119 --> 00:34:53,520
people about span

00:34:51,040 --> 00:34:54,720
is that it has shallow const now it is

00:34:53,520 --> 00:34:57,599
true that

00:34:54,720 --> 00:34:58,400
other types in the stl obey deep cons

00:34:57,599 --> 00:35:00,079
but span

00:34:58,400 --> 00:35:01,680
is like a pointer length there and

00:35:00,079 --> 00:35:03,520
pointers are shallow cons

00:35:01,680 --> 00:35:05,040
so depending on where you put the const

00:35:03,520 --> 00:35:07,200
in the span that controls

00:35:05,040 --> 00:35:08,800
can i modify the elements can i modify

00:35:07,200 --> 00:35:10,800
the span itself

00:35:08,800 --> 00:35:12,400
in this respect span is very much like

00:35:10,800 --> 00:35:13,839
shared putter and unique putter which

00:35:12,400 --> 00:35:15,839
are also shallow const

00:35:13,839 --> 00:35:17,839
except that it has none of the ownership

00:35:15,839 --> 00:35:19,839
semantics of those types

00:35:17,839 --> 00:35:20,880
so the one implementation specific node

00:35:19,839 --> 00:35:23,119
i wanted to mention

00:35:20,880 --> 00:35:24,240
is that our implementation of stood span

00:35:23,119 --> 00:35:26,720
performs bounds

00:35:24,240 --> 00:35:28,480
checks in debug mode only much like our

00:35:26,720 --> 00:35:31,760
stood vector

00:35:28,480 --> 00:35:33,520
so in release mode you get uh maximum

00:35:31,760 --> 00:35:35,040
performance we're not going to perform

00:35:33,520 --> 00:35:37,119
any bounce checking

00:35:35,040 --> 00:35:38,240
um in span and release mode but this is

00:35:37,119 --> 00:35:39,680
a different philosophy than the

00:35:38,240 --> 00:35:41,440
guideline support library

00:35:39,680 --> 00:35:43,520
if you use gslspan which is still

00:35:41,440 --> 00:35:44,800
supported and in fact is being updated

00:35:43,520 --> 00:35:46,800
to follow the new cs

00:35:44,800 --> 00:35:48,400
20 standard interface that always

00:35:46,800 --> 00:35:49,520
performs balance checking which is

00:35:48,400 --> 00:35:52,800
better for security

00:35:49,520 --> 00:35:55,040
but comes at a performance cost

00:35:52,800 --> 00:35:56,079
so let's take a look at um spam being

00:35:55,040 --> 00:35:58,320
used i had talked about

00:35:56,079 --> 00:36:00,320
its construction um so span was

00:35:58,320 --> 00:36:02,880
implemented over a few pr's as the

00:36:00,320 --> 00:36:05,760
committee continued to patch the

00:36:02,880 --> 00:36:08,320
proposal um by our contributor misco um

00:36:05,760 --> 00:36:11,680
who is attending cp con

00:36:08,320 --> 00:36:14,400
and here if i've got some function um

00:36:11,680 --> 00:36:15,599
i to maybe print out a bunch of ins i

00:36:14,400 --> 00:36:18,320
can call that function print

00:36:15,599 --> 00:36:19,280
and i'm just going to take a span of ins

00:36:18,320 --> 00:36:20,560
and here i'm

00:36:19,280 --> 00:36:22,640
i want to say okay i'm not going to

00:36:20,560 --> 00:36:24,400
modify the ins themselves

00:36:22,640 --> 00:36:25,760
and for the duration of this function

00:36:24,400 --> 00:36:27,200
i'm not interested in reassigning the

00:36:25,760 --> 00:36:28,079
span so i can have a con span of

00:36:27,200 --> 00:36:30,240
constant

00:36:28,079 --> 00:36:32,000
apply constant on both levels and note

00:36:30,240 --> 00:36:32,640
that this function is not a template

00:36:32,000 --> 00:36:34,720
it's just an

00:36:32,640 --> 00:36:36,960
ordinary you know non-template function

00:36:34,720 --> 00:36:39,839
that happens to take a span of int

00:36:36,960 --> 00:36:41,040
but it's not itself generalized on what

00:36:39,839 --> 00:36:43,680
it's operating on

00:36:41,040 --> 00:36:44,480
and yet i can call i can call function

00:36:43,680 --> 00:36:46,079
print

00:36:44,480 --> 00:36:48,079
and give it either a built in array of

00:36:46,079 --> 00:36:50,160
ins i can give it a stood array i can

00:36:48,079 --> 00:36:52,079
give it a stood vector

00:36:50,160 --> 00:36:53,839
and this is performing a limited form of

00:36:52,079 --> 00:36:55,040
type erasure no dynamic memory

00:36:53,839 --> 00:36:55,920
allocation or anything like that it's

00:36:55,040 --> 00:36:58,640
just saying

00:36:55,920 --> 00:37:00,480
okay i need to construct a span and i'm

00:36:58,640 --> 00:37:02,000
being called with a built-in array stood

00:37:00,480 --> 00:37:04,240
erased vector i'm going to

00:37:02,000 --> 00:37:06,079
invoke the implicit constructor and that

00:37:04,240 --> 00:37:07,680
constructor itself is templated but it's

00:37:06,079 --> 00:37:10,400
just going to extract a pointer

00:37:07,680 --> 00:37:11,599
and a length and then ignore the rest of

00:37:10,400 --> 00:37:12,720
the type information because we don't

00:37:11,599 --> 00:37:14,960
need it anymore

00:37:12,720 --> 00:37:16,800
um and so this will print one two three

00:37:14,960 --> 00:37:19,359
four five six seven eight nine

00:37:16,800 --> 00:37:22,320
but if i try to call this function print

00:37:19,359 --> 00:37:23,920
taking a const span of constant and if i

00:37:22,320 --> 00:37:25,200
try to give it something like a stood a

00:37:23,920 --> 00:37:27,119
deck of int

00:37:25,200 --> 00:37:29,200
this will not compile and i'm going to

00:37:27,119 --> 00:37:31,760
get a desirable compiler error

00:37:29,200 --> 00:37:32,800
in this case clang will say you know

00:37:31,760 --> 00:37:35,280
this is not viable

00:37:32,800 --> 00:37:37,359
no known conversion from this stood deck

00:37:35,280 --> 00:37:38,320
that you gave me to the const span of

00:37:37,359 --> 00:37:41,280
constant

00:37:38,320 --> 00:37:41,599
um that the function print wants um this

00:37:41,280 --> 00:37:44,079
is

00:37:41,599 --> 00:37:45,440
kling's way of saying the constructor

00:37:44,079 --> 00:37:46,800
has chosen not to participate in

00:37:45,440 --> 00:37:48,800
overload resolution

00:37:46,800 --> 00:37:50,240
um and so this is this is very

00:37:48,800 --> 00:37:51,920
interesting it may not may not seem that

00:37:50,240 --> 00:37:55,520
way until you think about

00:37:51,920 --> 00:37:59,040
what's happening um in the library

00:37:55,520 --> 00:38:02,960
so in cs plus 98 all the way through cs

00:37:59,040 --> 00:38:04,079
17 um random access iterators were the

00:38:02,960 --> 00:38:06,800
strongest possible

00:38:04,079 --> 00:38:08,400
iterators they have the most power

00:38:06,800 --> 00:38:09,560
pointers are random accelerators but

00:38:08,400 --> 00:38:12,000
they're also

00:38:09,560 --> 00:38:13,839
non-contiguous um random access

00:38:12,000 --> 00:38:15,599
iterators like stoddeck i chose that

00:38:13,839 --> 00:38:17,520
specifically as an example

00:38:15,599 --> 00:38:18,640
stood deck if you've ever heard about

00:38:17,520 --> 00:38:20,400
its representation

00:38:18,640 --> 00:38:21,920
it provides random access but through a

00:38:20,400 --> 00:38:24,880
complicated representation

00:38:21,920 --> 00:38:26,880
that's a bunch of uh chunks of elements

00:38:24,880 --> 00:38:29,760
that provide some level of locality and

00:38:26,880 --> 00:38:31,599
yet are referenced by a map of pointers

00:38:29,760 --> 00:38:32,960
to those chunks and that map is really

00:38:31,599 --> 00:38:34,079
just like a vector of pointers it's not

00:38:32,960 --> 00:38:37,119
like a stood map

00:38:34,079 --> 00:38:38,640
um in most implementations so deck

00:38:37,119 --> 00:38:41,520
provides random access but the elements

00:38:38,640 --> 00:38:43,520
are not completely stored contiguously

00:38:41,520 --> 00:38:45,440
so that means that although you can give

00:38:43,520 --> 00:38:47,599
deck iterators to algorithms that want

00:38:45,440 --> 00:38:50,079
random access iterators like stood sort

00:38:47,599 --> 00:38:51,040
you cannot use um deck iterators

00:38:50,079 --> 00:38:54,079
anywhere where

00:38:51,040 --> 00:38:56,560
contiguity is required and so

00:38:54,079 --> 00:38:58,079
span cares about this fortunately cs

00:38:56,560 --> 00:39:00,160
plus 20 ranges

00:38:58,079 --> 00:39:03,280
now provide a contiguous iterator

00:39:00,160 --> 00:39:06,720
concept and contiguous range concept

00:39:03,280 --> 00:39:10,079
and now span and other types can

00:39:06,720 --> 00:39:13,280
use this to allow vectors

00:39:10,079 --> 00:39:15,040
arrays built-in arrays and prohibit

00:39:13,280 --> 00:39:16,560
things that aren't quite strong enough

00:39:15,040 --> 00:39:18,320
like dec um

00:39:16,560 --> 00:39:21,040
and this is in a completely extensible

00:39:18,320 --> 00:39:22,640
way so if you have a custom container

00:39:21,040 --> 00:39:25,040
whether your own code or a third-party

00:39:22,640 --> 00:39:26,560
library that satisfies the contiguous

00:39:25,040 --> 00:39:28,320
range concept you can give it to a stood

00:39:26,560 --> 00:39:29,200
span span doesn't need to know anything

00:39:28,320 --> 00:39:30,800
about

00:39:29,200 --> 00:39:32,880
that container as long as it supports

00:39:30,800 --> 00:39:34,000
the necessary interface dot data and dot

00:39:32,880 --> 00:39:35,280
size

00:39:34,000 --> 00:39:37,440
uh more i think non-member data

00:39:35,280 --> 00:39:39,200
non-member size and there are so many

00:39:37,440 --> 00:39:40,640
more features that we have

00:39:39,200 --> 00:39:42,800
added over the past year i couldn't

00:39:40,640 --> 00:39:44,640
possibly talk about them all

00:39:42,800 --> 00:39:45,839
but i do have a brief list of and this

00:39:44,640 --> 00:39:48,160
is certainly not

00:39:45,839 --> 00:39:49,920
exhaustive all the features we've added

00:39:48,160 --> 00:39:52,079
we've got more atomic things we've got

00:39:49,920 --> 00:39:55,520
atomic smart pointers that

00:39:52,079 --> 00:39:56,720
replace functions individual functions

00:39:55,520 --> 00:39:59,280
that are quite horrible for

00:39:56,720 --> 00:40:00,640
correctness um these types atomic

00:39:59,280 --> 00:40:01,760
sharepoint or atomic weak porter are

00:40:00,640 --> 00:40:03,200
type safe

00:40:01,760 --> 00:40:05,280
that was implemented by our contributor

00:40:03,200 --> 00:40:06,480
adam busier we've got a whole header

00:40:05,280 --> 00:40:08,000
called bit

00:40:06,480 --> 00:40:10,880
that provides sort of three categories

00:40:08,000 --> 00:40:11,920
of functions a constexpr compatible

00:40:10,880 --> 00:40:13,920
bitcast

00:40:11,920 --> 00:40:15,440
you can rotate bits count how many bits

00:40:13,920 --> 00:40:17,200
are set um

00:40:15,440 --> 00:40:18,800
do things like is this a power of two

00:40:17,200 --> 00:40:20,160
get me the ceiling power of two the

00:40:18,800 --> 00:40:22,640
floor power of two

00:40:20,160 --> 00:40:23,760
um this was implemented over several prs

00:40:22,640 --> 00:40:25,760
buyer contr

00:40:23,760 --> 00:40:26,960
my co-worker charlie and then enhanced

00:40:25,760 --> 00:40:29,920
by our contributors

00:40:26,960 --> 00:40:31,680
um fixing uh issues with uh the

00:40:29,920 --> 00:40:34,400
intrinsics that we were calling

00:40:31,680 --> 00:40:36,079
um we have a makeshift for race which is

00:40:34,400 --> 00:40:37,119
a collaboration between our contributor

00:40:36,079 --> 00:40:39,359
adam boucilr

00:40:37,119 --> 00:40:40,720
and our intern gianni who provided the

00:40:39,359 --> 00:40:43,359
testing and this

00:40:40,720 --> 00:40:44,240
implements the optimization of

00:40:43,359 --> 00:40:46,480
allocating

00:40:44,240 --> 00:40:48,480
in this case an array with the shared

00:40:46,480 --> 00:40:50,400
pointer reference count control block

00:40:48,480 --> 00:40:52,240
that otherwise cannot be implemented by

00:40:50,400 --> 00:40:55,359
ordinary user code

00:40:52,240 --> 00:40:58,079
there's another feature midpoint and

00:40:55,359 --> 00:40:59,520
linear interpolation and this was a

00:40:58,079 --> 00:41:02,319
another collaborative effort it was

00:40:59,520 --> 00:41:04,319
started by our former intern paulo

00:41:02,319 --> 00:41:05,760
and my co-worker billy and then it was

00:41:04,319 --> 00:41:06,800
completed by our contributor statement

00:41:05,760 --> 00:41:08,560
or reply

00:41:06,800 --> 00:41:10,319
there were a whole bunch of edge cases

00:41:08,560 --> 00:41:11,760
involving infinities and nands that were

00:41:10,319 --> 00:41:13,520
very tricky to deal with and statement

00:41:11,760 --> 00:41:15,520
of reply

00:41:13,520 --> 00:41:17,119
was able to comprehensively analyze

00:41:15,520 --> 00:41:20,560
those cases

00:41:17,119 --> 00:41:21,440
so if you need functions like that in

00:41:20,560 --> 00:41:23,280
your programming

00:41:21,440 --> 00:41:24,880
and you care about correctness even in

00:41:23,280 --> 00:41:26,800
extreme edge cases those are now

00:41:24,880 --> 00:41:29,200
available in css 20.

00:41:26,800 --> 00:41:29,920
and also in the the sort of mathematical

00:41:29,200 --> 00:41:32,880
domain

00:41:29,920 --> 00:41:35,119
if you just want constants like pi or e

00:41:32,880 --> 00:41:38,319
now there are um

00:41:35,119 --> 00:41:39,760
variable templates um that express that

00:41:38,319 --> 00:41:40,880
in the student numbers namespace the

00:41:39,760 --> 00:41:42,079
numbers header was added by a

00:41:40,880 --> 00:41:43,839
contributor super wig

00:41:42,079 --> 00:41:45,760
and it provides not just those but also

00:41:43,839 --> 00:41:46,560
things like uh i think inverse square

00:41:45,760 --> 00:41:49,680
root of two

00:41:46,560 --> 00:41:51,200
uh square to 3 things like that

00:41:49,680 --> 00:41:53,119
there's a full list of the features

00:41:51,200 --> 00:41:56,560
we've implemented

00:41:53,119 --> 00:41:59,200
on our change log so let's

00:41:56,560 --> 00:42:00,160
now talk about how we've implemented

00:41:59,200 --> 00:42:03,680
these features

00:42:00,160 --> 00:42:05,920
on github i mentioned that we are

00:42:03,680 --> 00:42:07,520
a proprietary library that has switched

00:42:05,920 --> 00:42:10,000
to using github

00:42:07,520 --> 00:42:11,760
for all of our development and so that

00:42:10,000 --> 00:42:13,119
means not just the code but also our

00:42:11,760 --> 00:42:15,280
issue tracking

00:42:13,119 --> 00:42:17,280
our pull requests our status tracking

00:42:15,280 --> 00:42:20,720
we're migrating it all to github

00:42:17,280 --> 00:42:23,280
um so the code we used a linear history

00:42:20,720 --> 00:42:26,640
model we enforce that all commits to the

00:42:23,280 --> 00:42:28,319
default branch are squashes so we intend

00:42:26,640 --> 00:42:30,400
for it to be very easy

00:42:28,319 --> 00:42:32,000
to follow our history is just a single

00:42:30,400 --> 00:42:33,520
linear chain of commits

00:42:32,000 --> 00:42:35,520
we are working in a couple of feature

00:42:33,520 --> 00:42:36,880
branches for large features but we

00:42:35,520 --> 00:42:40,800
intend for those to be

00:42:36,880 --> 00:42:43,040
relatively short-lived once we finish

00:42:40,800 --> 00:42:44,000
features like spaceship and format we'll

00:42:43,040 --> 00:42:46,079
merge them squash

00:42:44,000 --> 00:42:47,440
them into the default branch and then

00:42:46,079 --> 00:42:48,100
those feature branches will go away

00:42:47,440 --> 00:42:49,599
it'll just be

00:42:48,100 --> 00:42:52,640
[Music]

00:42:49,599 --> 00:42:54,640
used to create the initial prs and

00:42:52,640 --> 00:42:56,319
for the issue tracking we're not just

00:42:54,640 --> 00:42:57,520
using that for bugs

00:42:56,319 --> 00:42:58,880
one of the important things we're doing

00:42:57,520 --> 00:43:00,560
is we're also using it to track the

00:42:58,880 --> 00:43:03,680
features that we're implementing

00:43:00,560 --> 00:43:05,040
we have labels cxx20 for every top level

00:43:03,680 --> 00:43:07,280
feature we're working on

00:43:05,040 --> 00:43:08,880
and lwg for every library working group

00:43:07,280 --> 00:43:10,480
issue resolution

00:43:08,880 --> 00:43:12,720
which are bug fixes applied to the

00:43:10,480 --> 00:43:14,400
standard in addition to labels for bug

00:43:12,720 --> 00:43:15,359
performance issue throughput issue

00:43:14,400 --> 00:43:17,599
documentation

00:43:15,359 --> 00:43:18,960
so forth and all these issues get

00:43:17,599 --> 00:43:22,079
resolved through pull requests

00:43:18,960 --> 00:43:24,480
i'll show you how that is done in a bit

00:43:22,079 --> 00:43:26,400
we've got the beginnings of testing with

00:43:24,480 --> 00:43:29,440
continuous integration so we're using

00:43:26,400 --> 00:43:31,359
azure pipelines to spin up uh azure

00:43:29,440 --> 00:43:34,160
virtual machine scale sets that

00:43:31,359 --> 00:43:35,280
have their vms that have visual studio

00:43:34,160 --> 00:43:38,000
installed and clang

00:43:35,280 --> 00:43:40,640
and python they run our test suite that

00:43:38,000 --> 00:43:43,680
was developed by my co-worker curtis

00:43:40,640 --> 00:43:45,440
and then they also ensure that

00:43:43,680 --> 00:43:48,240
code in our repo is formatted with

00:43:45,440 --> 00:43:51,680
claimed format we started using this

00:43:48,240 --> 00:43:52,480
back in vs 2019-16-0 and now we have

00:43:51,680 --> 00:43:54,560
automated

00:43:52,480 --> 00:43:56,480
detection that all files follow this and

00:43:54,560 --> 00:43:59,040
this is a massive time saver

00:43:56,480 --> 00:44:00,240
we love clang format because it frees us

00:43:59,040 --> 00:44:01,839
from having to worry about okay where

00:44:00,240 --> 00:44:03,359
exactly did we put the brace is all the

00:44:01,839 --> 00:44:06,000
indentation right

00:44:03,359 --> 00:44:06,960
we have the rules um written down in our

00:44:06,000 --> 00:44:09,040
repo

00:44:06,960 --> 00:44:10,560
and enforced by the tool which is a huge

00:44:09,040 --> 00:44:12,800
time saver for both development

00:44:10,560 --> 00:44:13,920
and review we're using github's other

00:44:12,800 --> 00:44:17,040
features like

00:44:13,920 --> 00:44:19,359
projects this was actually encouraged

00:44:17,040 --> 00:44:21,040
by our contributor misco we started

00:44:19,359 --> 00:44:21,520
using a project for code review i'll

00:44:21,040 --> 00:44:24,160
show you

00:44:21,520 --> 00:44:25,760
how that works in addition to tracking

00:44:24,160 --> 00:44:28,319
cs plus 20 features

00:44:25,760 --> 00:44:29,839
and the the feature branches that we're

00:44:28,319 --> 00:44:31,200
working on we have projects with those

00:44:29,839 --> 00:44:33,040
as well

00:44:31,200 --> 00:44:34,560
we're using github's wiki to be able to

00:44:33,040 --> 00:44:36,640
present an stl

00:44:34,560 --> 00:44:38,400
change log that's continuously updated

00:44:36,640 --> 00:44:40,480
every time we merge a pr

00:44:38,400 --> 00:44:42,079
we now go update that change log this is

00:44:40,480 --> 00:44:44,000
a vast advancement

00:44:42,079 --> 00:44:45,520
over our previous mechanism of whenever

00:44:44,000 --> 00:44:47,119
we commit something

00:44:45,520 --> 00:44:48,640
one the developers will send a mail to

00:44:47,119 --> 00:44:51,200
themselves then later on

00:44:48,640 --> 00:44:51,839
when release happens we'll go through

00:44:51,200 --> 00:44:53,599
that

00:44:51,839 --> 00:44:55,359
mail and write up all the features that

00:44:53,599 --> 00:44:57,839
we've accumulated

00:44:55,359 --> 00:44:58,720
and we've even started sharing our

00:44:57,839 --> 00:45:01,680
status chart

00:44:58,720 --> 00:45:03,200
which i shared a screenshot of earlier

00:45:01,680 --> 00:45:05,119
this is now available through github

00:45:03,200 --> 00:45:08,400
pages and we can just query

00:45:05,119 --> 00:45:10,800
github's issue database

00:45:08,400 --> 00:45:11,839
whenever we want programmatically using

00:45:10,800 --> 00:45:13,440
graphql

00:45:11,839 --> 00:45:15,119
and generate that highly detailed status

00:45:13,440 --> 00:45:17,280
chart to understand okay

00:45:15,119 --> 00:45:19,599
what progress are we making on features

00:45:17,280 --> 00:45:21,280
how much we're emerging prs

00:45:19,599 --> 00:45:23,839
our pr is accumulating and that we need

00:45:21,280 --> 00:45:26,160
to start reviewing

00:45:23,839 --> 00:45:27,440
so the code i've got the url to the repo

00:45:26,160 --> 00:45:29,440
there

00:45:27,440 --> 00:45:30,960
often when you see a directory listing

00:45:29,440 --> 00:45:33,520
you don't know where to start

00:45:30,960 --> 00:45:34,880
so i encourage you to look at still inc

00:45:33,520 --> 00:45:36,960
and that's where all the headers are

00:45:34,880 --> 00:45:39,680
like vector

00:45:36,960 --> 00:45:40,560
carecom ranges that's where all the fun

00:45:39,680 --> 00:45:42,800
happens but

00:45:40,560 --> 00:45:44,079
you can also look at stl source

00:45:42,800 --> 00:45:45,359
oftentimes sources where people

00:45:44,079 --> 00:45:46,240
initially go why wouldn't i want to look

00:45:45,359 --> 00:45:47,760
at the sources

00:45:46,240 --> 00:45:49,839
in this case it's our separately

00:45:47,760 --> 00:45:52,160
compiled sources um

00:45:49,839 --> 00:45:53,119
which are things like um iostreams file

00:45:52,160 --> 00:45:54,880
system and

00:45:53,119 --> 00:45:56,720
threading it's actually a small portion

00:45:54,880 --> 00:45:57,920
of the stl

00:45:56,720 --> 00:45:59,599
and it tends to be a little more

00:45:57,920 --> 00:46:01,520
complicated because we have to work with

00:45:59,599 --> 00:46:04,240
like you know the platform api and care

00:46:01,520 --> 00:46:06,000
about gll exporting things like that

00:46:04,240 --> 00:46:07,599
our build system is powered with cmake

00:46:06,000 --> 00:46:08,160
and ninja we're writing this from

00:46:07,599 --> 00:46:10,720
scratch

00:46:08,160 --> 00:46:12,319
um and replacing our existing ms build

00:46:10,720 --> 00:46:13,599
power build system that nobody really

00:46:12,319 --> 00:46:15,760
understands

00:46:13,599 --> 00:46:17,280
cmake ninja is wonderful it's so fast

00:46:15,760 --> 00:46:20,000
easy to extend

00:46:17,280 --> 00:46:21,119
and we use vc package as a sub module to

00:46:20,000 --> 00:46:22,800
build boost man

00:46:21,119 --> 00:46:24,400
because we use that to implement the

00:46:22,800 --> 00:46:26,480
special math feature

00:46:24,400 --> 00:46:28,880
we've got our test suite in there our

00:46:26,480 --> 00:46:29,760
own test suite is called unimaginatively

00:46:28,880 --> 00:46:31,440
tested

00:46:29,760 --> 00:46:33,280
uh we've got a libsyx directory

00:46:31,440 --> 00:46:35,119
containing some support files for

00:46:33,280 --> 00:46:37,200
libsys pluses test suite then we've got

00:46:35,119 --> 00:46:39,359
a legacy test suite as well

00:46:37,200 --> 00:46:41,119
um and i talked about the history and

00:46:39,359 --> 00:46:42,880
the feature branches

00:46:41,119 --> 00:46:44,160
so the issues um i had mentioned the

00:46:42,880 --> 00:46:45,599
various labels that we're using here

00:46:44,160 --> 00:46:47,599
i've got examples of some

00:46:45,599 --> 00:46:48,640
issues that are interesting to look at

00:46:47,599 --> 00:46:51,040
we file one

00:46:48,640 --> 00:46:52,240
issue for every remaining feature to be

00:46:51,040 --> 00:46:56,079
implemented

00:46:52,240 --> 00:46:57,920
and these exist as of um cpcon 2019

00:46:56,079 --> 00:46:59,119
all the work that was outstanding back

00:46:57,920 --> 00:47:01,200
then we did not go

00:46:59,119 --> 00:47:02,960
even further back and retroactively file

00:47:01,200 --> 00:47:04,640
features for stuff we had already done

00:47:02,960 --> 00:47:05,040
that would have been unnecessary work

00:47:04,640 --> 00:47:06,160
but

00:47:05,040 --> 00:47:07,920
for all the features that were

00:47:06,160 --> 00:47:09,760
outstanding as of one year ago there's

00:47:07,920 --> 00:47:12,160
an issue tracking that

00:47:09,760 --> 00:47:14,000
so is open label cxx20 will show you all

00:47:12,160 --> 00:47:17,119
of our remaining work

00:47:14,000 --> 00:47:18,640
and we group together papers um

00:47:17,119 --> 00:47:20,880
in the standard they add new features

00:47:18,640 --> 00:47:22,000
followed by any papers that have patched

00:47:20,880 --> 00:47:23,839
those features because they don't

00:47:22,000 --> 00:47:25,119
represent net new work

00:47:23,839 --> 00:47:27,200
they just represent things that we have

00:47:25,119 --> 00:47:30,319
to remember as we implement the feature

00:47:27,200 --> 00:47:31,520
i had mentioned our lwg and other bugs

00:47:30,319 --> 00:47:32,960
that we're tracking

00:47:31,520 --> 00:47:34,559
reporting those from all the various

00:47:32,960 --> 00:47:36,800
other sources that we have accumulated

00:47:34,559 --> 00:47:39,119
bugs but we still support people filing

00:47:36,800 --> 00:47:41,280
bugs through developer community or the

00:47:39,119 --> 00:47:42,800
ides report a problem

00:47:41,280 --> 00:47:45,040
it's just that github will now become

00:47:42,800 --> 00:47:47,280
the central place to view

00:47:45,040 --> 00:47:48,640
all issues that have been reported

00:47:47,280 --> 00:47:50,000
against the stl

00:47:48,640 --> 00:47:52,319
and we've got a label v-necks that

00:47:50,000 --> 00:47:54,160
tracks our upcoming project to

00:47:52,319 --> 00:47:56,240
overhaul the stl and break binary

00:47:54,160 --> 00:47:58,000
compatibility

00:47:56,240 --> 00:48:00,079
so here's an example of one of those

00:47:58,000 --> 00:48:01,359
cx620 issues this tracks the context per

00:48:00,079 --> 00:48:02,800
string feature that mia is working on

00:48:01,359 --> 00:48:04,800
that i mentioned

00:48:02,800 --> 00:48:06,240
so these issues tend to be relatively

00:48:04,800 --> 00:48:09,119
minimal we will

00:48:06,240 --> 00:48:11,119
link to the paper so you can just click

00:48:09,119 --> 00:48:11,760
on that that will take you to the wg 21

00:48:11,119 --> 00:48:13,920
website

00:48:11,760 --> 00:48:16,559
we'll mention if it's controlled or if

00:48:13,920 --> 00:48:18,480
it's tracked by feature test macro

00:48:16,559 --> 00:48:19,680
if there are any patch papers or lwg

00:48:18,480 --> 00:48:21,680
issues that affect it

00:48:19,680 --> 00:48:23,520
and then we can just mention this issue

00:48:21,680 --> 00:48:25,680
whenever a pr comes up or if other

00:48:23,520 --> 00:48:27,520
issues depend on it

00:48:25,680 --> 00:48:28,960
and track it in our various projects or

00:48:27,520 --> 00:48:32,160
milestones

00:48:28,960 --> 00:48:33,200
so this is trying to present our status

00:48:32,160 --> 00:48:35,920
in a very legible

00:48:33,200 --> 00:48:36,640
understandable manner so the pull

00:48:35,920 --> 00:48:38,880
requests

00:48:36,640 --> 00:48:40,640
that are the flip side of issues here

00:48:38,880 --> 00:48:41,920
i've got a few examples of interesting

00:48:40,640 --> 00:48:44,800
pull requests we've got

00:48:41,920 --> 00:48:47,599
the changelog entry fixed to 43 year old

00:48:44,800 --> 00:48:49,760
bug by implementing a 40 year old fix

00:48:47,599 --> 00:48:52,000
that was very fun because it involved a

00:48:49,760 --> 00:48:54,880
incorrect paper that donald knuth

00:48:52,000 --> 00:48:57,040
co-authored so this pull request is an

00:48:54,880 --> 00:48:58,720
interesting example of a comprehensive

00:48:57,040 --> 00:49:01,839
explanation of the bug

00:48:58,720 --> 00:49:03,599
what went into the fix abi concerns how

00:49:01,839 --> 00:49:04,480
to test it we've got a randomized test

00:49:03,599 --> 00:49:06,319
in there

00:49:04,480 --> 00:49:07,760
and this was a wonderful example of

00:49:06,319 --> 00:49:10,000
working in the open on github because

00:49:07,760 --> 00:49:13,440
when we filed this issue

00:49:10,000 --> 00:49:15,839
others provided our contributors

00:49:13,440 --> 00:49:17,200
provided more information they linked to

00:49:15,839 --> 00:49:18,400
papers in the cs literature that we

00:49:17,200 --> 00:49:21,599
hadn't heard of

00:49:18,400 --> 00:49:22,880
that provide other algorithms that we

00:49:21,599 --> 00:49:24,480
can use to improve performance in the

00:49:22,880 --> 00:49:26,480
future

00:49:24,480 --> 00:49:28,480
i've linked the span pr which is

00:49:26,480 --> 00:49:30,000
currently the the longest

00:49:28,480 --> 00:49:33,040
pr in terms of the number of comments we

00:49:30,000 --> 00:49:35,280
accumulated this one

00:49:33,040 --> 00:49:37,440
started uh it was contributed by misco

00:49:35,280 --> 00:49:41,200
before we had our test suite online

00:49:37,440 --> 00:49:42,880
so we also had to add tests to the pr

00:49:41,200 --> 00:49:44,559
and then deal with all the papers that

00:49:42,880 --> 00:49:46,240
patched it

00:49:44,559 --> 00:49:48,160
so that's a very lengthy very

00:49:46,240 --> 00:49:50,000
interesting pr to follow and then a more

00:49:48,160 --> 00:49:51,599
recent one

00:49:50,000 --> 00:49:53,440
statement of reply had fixed

00:49:51,599 --> 00:49:54,160
long-standing issues in our o-stream

00:49:53,440 --> 00:49:56,800
floating-point

00:49:54,160 --> 00:49:59,119
printing and this was an interesting

00:49:56,800 --> 00:50:02,720
example because to fix it we had to

00:49:59,119 --> 00:50:06,079
avoid breaking abi and

00:50:02,720 --> 00:50:07,359
it was wonderful to get this pr because

00:50:06,079 --> 00:50:08,960
we

00:50:07,359 --> 00:50:10,800
had we didn't know how to fix it

00:50:08,960 --> 00:50:11,359
immediately without preserving api

00:50:10,800 --> 00:50:14,160
statement

00:50:11,359 --> 00:50:16,240
same reply figured out how to do that so

00:50:14,160 --> 00:50:18,000
uh each of these prs is a collaboration

00:50:16,240 --> 00:50:19,280
between our contributors and the stl

00:50:18,000 --> 00:50:20,880
maintainer team

00:50:19,280 --> 00:50:23,359
we've got a policy that two maintainers

00:50:20,880 --> 00:50:26,160
need to review and sign off on every pr

00:50:23,359 --> 00:50:27,359
this keeps code at are always ready to

00:50:26,160 --> 00:50:28,800
ship level of quality

00:50:27,359 --> 00:50:30,800
and ensures that the maintainers

00:50:28,800 --> 00:50:33,839
understand what's happening in the repo

00:50:30,800 --> 00:50:34,319
so we can write further features in that

00:50:33,839 --> 00:50:36,960
area

00:50:34,319 --> 00:50:38,240
and understand what's going on when bugs

00:50:36,960 --> 00:50:41,920
appear

00:50:38,240 --> 00:50:43,040
so when we review code we're our library

00:50:41,920 --> 00:50:45,760
is a little bit different

00:50:43,040 --> 00:50:47,280
from other code bases um we're

00:50:45,760 --> 00:50:48,880
controlled by the standard so the

00:50:47,280 --> 00:50:51,839
standard does the design work

00:50:48,880 --> 00:50:53,440
for us um it specifies the preconditions

00:50:51,839 --> 00:50:54,079
of what users are allowed to give us

00:50:53,440 --> 00:50:56,720
both

00:50:54,079 --> 00:50:58,640
in values and in types and it has very

00:50:56,720 --> 00:50:59,839
well specified post conditions of okay

00:50:58,640 --> 00:51:02,240
you know the state of the program needs

00:50:59,839 --> 00:51:04,720
to be exactly this when you're done

00:51:02,240 --> 00:51:05,599
and the requirements that we have to

00:51:04,720 --> 00:51:07,680
meet are very

00:51:05,599 --> 00:51:08,880
strict and this is not just because okay

00:51:07,680 --> 00:51:09,839
you know the standard's strict it's

00:51:08,880 --> 00:51:12,400
because

00:51:09,839 --> 00:51:13,760
we have to deal with all of the users

00:51:12,400 --> 00:51:15,200
the standard library

00:51:13,760 --> 00:51:17,680
and our correctness and performance

00:51:15,200 --> 00:51:20,079
requirements are essentially the maximum

00:51:17,680 --> 00:51:21,280
of any of our users so we're not quite

00:51:20,079 --> 00:51:24,480
you know space shuttle

00:51:21,280 --> 00:51:25,760
levels of correctness requirement um but

00:51:24,480 --> 00:51:28,319
it's pretty stringent

00:51:25,760 --> 00:51:29,920
um and um the standard library has been

00:51:28,319 --> 00:51:31,119
around for decades it will be around for

00:51:29,920 --> 00:51:33,760
decades um so

00:51:31,119 --> 00:51:35,520
it is a perpetual code base and it needs

00:51:33,760 --> 00:51:36,640
to be constantly evolving with all the

00:51:35,520 --> 00:51:37,440
changes to the standard that are

00:51:36,640 --> 00:51:40,400
happening

00:51:37,440 --> 00:51:41,680
so by intensively reviewing the code we

00:51:40,400 --> 00:51:44,319
can avoid

00:51:41,680 --> 00:51:46,480
adding new bugs to new features and we

00:51:44,319 --> 00:51:49,599
can avoid requesting existing features

00:51:46,480 --> 00:51:51,040
and that way we can stay focused on

00:51:49,599 --> 00:51:53,599
moving the code base forward rather than

00:51:51,040 --> 00:51:55,280
having to go fix up a bunch of things

00:51:53,599 --> 00:51:56,559
and this intensive review also ensures

00:51:55,280 --> 00:51:57,680
that the code base remains highly

00:51:56,559 --> 00:51:59,520
consistent

00:51:57,680 --> 00:52:01,119
if you look at our code it mostly looks

00:51:59,520 --> 00:52:01,599
like it was written by a single person

00:52:01,119 --> 00:52:03,920
and this

00:52:01,599 --> 00:52:05,599
has a lot of benefits it means that as

00:52:03,920 --> 00:52:07,839
you write a new feature you can look at

00:52:05,599 --> 00:52:09,359
existing features for president

00:52:07,839 --> 00:52:11,040
and follow what they're doing now you

00:52:09,359 --> 00:52:12,079
never want to mindlessly copy paste

00:52:11,040 --> 00:52:15,040
something

00:52:12,079 --> 00:52:15,839
but if you follow its precedent with

00:52:15,040 --> 00:52:18,000
your eyes open

00:52:15,839 --> 00:52:19,599
you can end up writing code that

00:52:18,000 --> 00:52:21,520
correctly handles unusual cases like

00:52:19,599 --> 00:52:23,760
okay what if i've got a container

00:52:21,520 --> 00:52:26,720
that sets the propagate on container

00:52:23,760 --> 00:52:26,720
copy assignment

00:52:26,800 --> 00:52:31,040
type trait to true do i correctly handle

00:52:29,359 --> 00:52:32,400
that and if you follow existing code in

00:52:31,040 --> 00:52:32,800
vector or any of the other containers

00:52:32,400 --> 00:52:35,440
that all

00:52:32,800 --> 00:52:36,880
looks generally the same your new code

00:52:35,440 --> 00:52:38,400
will end up doing the right thing

00:52:36,880 --> 00:52:40,079
and if you have to do something unusual

00:52:38,400 --> 00:52:42,079
it will stand out during code of views

00:52:40,079 --> 00:52:43,280
oh okay this is tricky

00:52:42,079 --> 00:52:45,440
i need something that's a little bit

00:52:43,280 --> 00:52:48,720
different than the usual so

00:52:45,440 --> 00:52:50,480
this is what the code review flow looks

00:52:48,720 --> 00:52:52,720
like on github we've got a series of

00:52:50,480 --> 00:52:54,640
columns where prs migrate from

00:52:52,720 --> 00:52:56,240
work in progress to initial review to

00:52:54,640 --> 00:52:57,920
final review to ready to merge as it

00:52:56,240 --> 00:53:00,960
gets reviewed

00:52:57,920 --> 00:53:04,240
or sent back for rework

00:53:00,960 --> 00:53:06,240
by requesting changes um and here's a

00:53:04,240 --> 00:53:09,119
screenshot of that status chart

00:53:06,240 --> 00:53:10,480
this shows our we've got three graphs in

00:53:09,119 --> 00:53:12,160
there this is the third one

00:53:10,480 --> 00:53:14,000
this shows the number of prs merged per

00:53:12,160 --> 00:53:16,319
month since we went to open source and

00:53:14,000 --> 00:53:18,160
so the pace has been increasing

00:53:16,319 --> 00:53:20,720
in the month of august we managed to

00:53:18,160 --> 00:53:22,319
merge over 70 prs

00:53:20,720 --> 00:53:24,160
in a single month and hopefully that

00:53:22,319 --> 00:53:25,839
will continue increasing

00:53:24,160 --> 00:53:28,240
although it will be a little bit lower

00:53:25,839 --> 00:53:30,160
due to cpcon this year

00:53:28,240 --> 00:53:31,760
so that is the end of one year of

00:53:30,160 --> 00:53:32,400
development on github we're starting our

00:53:31,760 --> 00:53:33,599
second year

00:53:32,400 --> 00:53:36,720
this will be the year that we finished

00:53:33,599 --> 00:53:39,040
cs 20 hopefully this calendar year

00:53:36,720 --> 00:53:40,720
and we are looking forward to working

00:53:39,040 --> 00:53:41,839
with the community so here i've got a

00:53:40,720 --> 00:53:43,599
list of links

00:53:41,839 --> 00:53:45,839
links to our repository to the changelog

00:53:43,599 --> 00:53:47,599
i mentioned to the status chart you can

00:53:45,839 --> 00:53:48,000
reach all this from the the repository

00:53:47,599 --> 00:53:50,079
itself

00:53:48,000 --> 00:53:51,920
and a link to the current working paper

00:53:50,079 --> 00:53:54,800
for cs plus 20

00:53:51,920 --> 00:53:55,680
that's available on the w21 website so

00:53:54,800 --> 00:53:57,920
i've got about

00:53:55,680 --> 00:53:59,760
six minutes to answer questions uh let

00:53:57,920 --> 00:54:02,880
us see

00:53:59,760 --> 00:54:05,280
what is in the q a

00:54:02,880 --> 00:54:07,280
and if you have more questions um our

00:54:05,280 --> 00:54:09,280
github discussions tab is open and we've

00:54:07,280 --> 00:54:10,800
set up a discord server um look at the

00:54:09,280 --> 00:54:12,960
readme and the repo that has linked

00:54:10,800 --> 00:54:16,400
there okay

00:54:12,960 --> 00:54:18,480
uh so first question um

00:54:16,400 --> 00:54:19,520
why isn't constexpr implicitly added by

00:54:18,480 --> 00:54:21,680
the compiler to any function when

00:54:19,520 --> 00:54:23,119
suitable is there a downside to it that

00:54:21,680 --> 00:54:26,800
is an excellent question

00:54:23,119 --> 00:54:28,800
um so the um the reason

00:54:26,800 --> 00:54:30,880
that constexar is not implicitly added

00:54:28,800 --> 00:54:32,079
is because it is not just i can use this

00:54:30,880 --> 00:54:36,319
at compile time

00:54:32,079 --> 00:54:38,720
um it is a uh it's a guarantee

00:54:36,319 --> 00:54:40,559
that i will never do anything to this

00:54:38,720 --> 00:54:41,599
function that will prevent it from being

00:54:40,559 --> 00:54:44,400
eligible

00:54:41,599 --> 00:54:45,280
for const expert i will never add things

00:54:44,400 --> 00:54:48,400
like runtime

00:54:45,280 --> 00:54:52,480
logging or network request um

00:54:48,400 --> 00:54:54,079
or a reinterpret cast so constexpr

00:54:52,480 --> 00:54:55,680
being automatically applied would be

00:54:54,079 --> 00:54:57,040
undesirable um

00:54:55,680 --> 00:54:59,119
you're when you mark something constant

00:54:57,040 --> 00:55:00,720
spur it is going to be a

00:54:59,119 --> 00:55:02,400
hopefully permanent guarantee because if

00:55:00,720 --> 00:55:03,839
you mark some things context for people

00:55:02,400 --> 00:55:04,400
depend on it and then you remove const

00:55:03,839 --> 00:55:05,680
expert

00:55:04,400 --> 00:55:07,680
now you've just broken their code to

00:55:05,680 --> 00:55:08,559
compile time and they may need to

00:55:07,680 --> 00:55:10,400
extensively

00:55:08,559 --> 00:55:13,119
rework their code so that's why it has

00:55:10,400 --> 00:55:16,240
to be explicitly written

00:55:13,119 --> 00:55:17,599
um okay next question is a race if

00:55:16,240 --> 00:55:19,680
similar in complexity to calling

00:55:17,599 --> 00:55:21,760
removeth then a race

00:55:19,680 --> 00:55:23,680
it is in fact it is implemented for the

00:55:21,760 --> 00:55:26,640
vector-like containers as

00:55:23,680 --> 00:55:28,640
um remove if followed by a race that's

00:55:26,640 --> 00:55:30,720
mandated as if by the standard and in

00:55:28,640 --> 00:55:33,680
fact that's what implementations will do

00:55:30,720 --> 00:55:34,160
um so the arrays of functions are all

00:55:33,680 --> 00:55:35,760
linear

00:55:34,160 --> 00:55:37,839
time regardless of whether they choose

00:55:35,760 --> 00:55:38,240
the erase or move idiom the remove and

00:55:37,839 --> 00:55:40,760
remove

00:55:38,240 --> 00:55:42,000
if member functions or the handwritten

00:55:40,760 --> 00:55:46,480
[Music]

00:55:42,000 --> 00:55:48,000
erase interloop they're all linear time

00:55:46,480 --> 00:55:49,680
next question what's the next big cs

00:55:48,000 --> 00:55:50,559
plus thing microsoft is going to open

00:55:49,680 --> 00:55:53,280
source i

00:55:50,559 --> 00:55:54,640
cannot talk about uh future plans with

00:55:53,280 --> 00:55:56,480
any sort of specificity

00:55:54,640 --> 00:55:58,880
um we are looking at open sourcing the

00:55:56,480 --> 00:56:00,720
vc runtime and vc startup libraries that

00:55:58,880 --> 00:56:02,960
are directly underneath the stl

00:56:00,720 --> 00:56:04,960
um no promises no guarantees yet but

00:56:02,960 --> 00:56:08,319
that is something we're looking at

00:56:04,960 --> 00:56:09,839
um next question what is the motivation

00:56:08,319 --> 00:56:10,480
for people contributing to your github

00:56:09,839 --> 00:56:12,160
project

00:56:10,480 --> 00:56:14,640
is there any incentive to do so are

00:56:12,160 --> 00:56:15,839
these people just lovely enthusiasts

00:56:14,640 --> 00:56:18,559
i believe that they're lovely

00:56:15,839 --> 00:56:20,160
enthusiasts um i suppose the incentive

00:56:18,559 --> 00:56:21,920
is that you get to see your workshipped

00:56:20,160 --> 00:56:22,880
to you know over a million user

00:56:21,920 --> 00:56:26,640
programmers

00:56:22,880 --> 00:56:28,720
um and make sepalsplus a better place um

00:56:26,640 --> 00:56:30,960
i can't comment on the other motivations

00:56:28,720 --> 00:56:32,319
of our contributors but i imagine that

00:56:30,960 --> 00:56:34,160
that's the case

00:56:32,319 --> 00:56:36,079
um let's see next question does the

00:56:34,160 --> 00:56:37,359
array have to be static for ranges is

00:56:36,079 --> 00:56:40,720
sorted to work

00:56:37,359 --> 00:56:43,359
it needs to be um so

00:56:40,720 --> 00:56:44,559
if you're going to use the const expert

00:56:43,359 --> 00:56:47,040
is sorted

00:56:44,559 --> 00:56:48,000
the array needs to be constexpr but it

00:56:47,040 --> 00:56:51,200
does not need to be

00:56:48,000 --> 00:56:55,119
static constexpr so it's okay to have a

00:56:51,200 --> 00:56:57,680
function local constexpr array and then

00:56:55,119 --> 00:56:59,599
use static search is sorted or static

00:56:57,680 --> 00:57:02,559
certain ranges is sorted

00:56:59,599 --> 00:57:04,400
um okay next question what were the

00:57:02,559 --> 00:57:07,599
downsides of moving to open source

00:57:04,400 --> 00:57:11,040
um so it's a one-time

00:57:07,599 --> 00:57:13,040
time cost to get everything polished up

00:57:11,040 --> 00:57:14,480
to physically move things to github get

00:57:13,040 --> 00:57:18,960
the repo set up

00:57:14,480 --> 00:57:20,640
um and there's an ongoing cost to

00:57:18,960 --> 00:57:22,400
replicate changes between the github

00:57:20,640 --> 00:57:23,520
repo which is where we're doing

00:57:22,400 --> 00:57:25,359
development and the

00:57:23,520 --> 00:57:26,960
msvc internal git repo which is where

00:57:25,359 --> 00:57:28,799
the product is physically built and then

00:57:26,960 --> 00:57:31,440
added to the vs installer

00:57:28,799 --> 00:57:34,079
um and then there's the ongoing time

00:57:31,440 --> 00:57:36,240
commitment of needing to review prs

00:57:34,079 --> 00:57:37,839
which initially was a big change for us

00:57:36,240 --> 00:57:38,799
and now we've got it coming up pretty

00:57:37,839 --> 00:57:40,240
smoothly

00:57:38,799 --> 00:57:41,119
so i'd say those are the downsides and

00:57:40,240 --> 00:57:42,400
those are definitely things we

00:57:41,119 --> 00:57:44,799
absolutely expected

00:57:42,400 --> 00:57:47,520
going in aside from that it has been

00:57:44,799 --> 00:57:49,280
remarkably great

00:57:47,520 --> 00:57:50,559
next question is constexpr available on

00:57:49,280 --> 00:57:52,720
parallel algorithms

00:57:50,559 --> 00:57:54,400
no none of the parallel algorithms

00:57:52,720 --> 00:57:55,520
taking execution policies are marked as

00:57:54,400 --> 00:57:58,400
constexpr

00:57:55,520 --> 00:57:59,040
in cpls plus 20. um that may change in

00:57:58,400 --> 00:58:01,870
the future

00:57:59,040 --> 00:58:03,040
um i don't know exactly when um

00:58:01,870 --> 00:58:04,960
[Music]

00:58:03,040 --> 00:58:06,400
i would imagine that the implementation

00:58:04,960 --> 00:58:07,680
should be like oh okay you can

00:58:06,400 --> 00:58:09,200
call you know parallel algorithm

00:58:07,680 --> 00:58:10,799
constexpr and then it'll just you know

00:58:09,200 --> 00:58:12,079
do something serial

00:58:10,799 --> 00:58:14,240
at compile time because you can't tell

00:58:12,079 --> 00:58:16,559
the difference um but i don't know if

00:58:14,240 --> 00:58:19,839
the committee is planning on doing that

00:58:16,559 --> 00:58:21,440
um certainly not there's no concrete

00:58:19,839 --> 00:58:23,280
proposal yet

00:58:21,440 --> 00:58:24,960
next type why is passing by value faster

00:58:23,280 --> 00:58:26,480
for small types like span when do we

00:58:24,960 --> 00:58:27,839
decide if type is not small enough

00:58:26,480 --> 00:58:28,880
excellent observation i did pass the

00:58:27,839 --> 00:58:30,640
span by value

00:58:28,880 --> 00:58:32,160
um that's because it's just a pointer

00:58:30,640 --> 00:58:33,119
length pair and the idea was okay the

00:58:32,160 --> 00:58:34,799
compiler should be able to handle that

00:58:33,119 --> 00:58:35,839
efficiently hopefully pass in registers

00:58:34,799 --> 00:58:38,880
or something

00:58:35,839 --> 00:58:42,079
generally our criteria is if you are

00:58:38,880 --> 00:58:44,319
the size of a built-in type like an int

00:58:42,079 --> 00:58:45,359
or you know pointer size type or up to

00:58:44,319 --> 00:58:47,119
two of them

00:58:45,359 --> 00:58:48,319
that's and you know plain old data so

00:58:47,119 --> 00:58:49,680
you're not going to do any dynamic

00:58:48,319 --> 00:58:52,799
allocations

00:58:49,680 --> 00:58:54,400
that's small enough to pass by value

00:58:52,799 --> 00:58:56,240
but if you're larger than that like

00:58:54,400 --> 00:58:57,760
three pointers large or if you have any

00:58:56,240 --> 00:58:59,440
sort of complicated logic in your

00:58:57,760 --> 00:59:00,880
copying assignment

00:58:59,440 --> 00:59:02,799
then you should probably be passed by

00:59:00,880 --> 00:59:04,160
reference span is one of the few library

00:59:02,799 --> 00:59:05,680
types that i would i would pass by value

00:59:04,160 --> 00:59:08,720
there also i would pass like maybe a

00:59:05,680 --> 00:59:10,319
pair indent but that's about it um and

00:59:08,720 --> 00:59:12,079
final question thoughts on the new code

00:59:10,319 --> 00:59:13,839
development dynamic after open sourcing

00:59:12,079 --> 00:59:14,400
so yeah we are building a new dynamic

00:59:13,839 --> 00:59:16,319
here

00:59:14,400 --> 00:59:17,599
um where we're collaborating with

00:59:16,319 --> 00:59:19,680
developers

00:59:17,599 --> 00:59:21,119
and trying to plan things out i might

00:59:19,680 --> 00:59:23,680
say the the biggest challenge

00:59:21,119 --> 00:59:26,160
is scheduling things because right now

00:59:23,680 --> 00:59:27,440
we have a finite capacity to digest pr

00:59:26,160 --> 00:59:29,200
so we're prioritizing cs

00:59:27,440 --> 00:59:30,960
20 features but we don't want to

00:59:29,200 --> 00:59:32,079
completely shut ourselves off from bugs

00:59:30,960 --> 00:59:34,000
and enhancements and

00:59:32,079 --> 00:59:35,920
other things like that so i'd say

00:59:34,000 --> 00:59:36,799
communicating our plans without over

00:59:35,920 --> 00:59:39,119
promising

00:59:36,799 --> 00:59:40,079
um that is uh one of the things we'll be

00:59:39,119 --> 00:59:43,119
working on

00:59:40,079 --> 00:59:43,599
in the next year so that's our time

00:59:43,119 --> 00:59:45,520
limit

00:59:43,599 --> 00:59:48,319
if you have further questions feel free

00:59:45,520 --> 00:59:50,880
to submit them on our discussions tab

00:59:48,319 --> 00:59:52,400
discord server or send me an email also

00:59:50,880 --> 00:59:55,040
we'll be here at the conference so drop

00:59:52,400 --> 00:59:55,040
by our booth

00:59:58,839 --> 01:00:01,839
thanks

01:00:13,839 --> 01:00:15,920

YouTube URL: https://www.youtube.com/watch?v=8kjRx8vo6y4


