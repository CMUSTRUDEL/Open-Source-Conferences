Title: Modern Software Needs Embedded Modern C++ Programming - Michael Wong - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020 Day 2
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
As the chair of SG14 Embedded, I like to give an update of what we have done for embedded. But this talk is much more than that. It will describe our group's collective experience in what is Embedded which has come from Automotive, games, Medical, Finance and many others. The definition is surprisingly wide and covers hard- and soft-real time, wide span of seriousness, hardware, replication, response time, and supported software. For that matter, who are the Embedded programmers? I will tie this back to the two pillars of C++: a direct map to hardware and zero overhead. I will argue why we should use C++, some of the bad reasons for note using C++, and identify 2 of the biggest problems people have complained about moving to C++. Understanding that Embedded compilers may not be up to the latest standard, we plan to separate Modern C++ into 3 Ages so that we can have people to change their code with varying levels of Embedded C++ compiler support. Finally, I will show some examples of how to change from C to C++ as one of the most common case in the Embedded community. I will show some of the common c++ features for each of several cases which includes Adopting to C++ in one shot, and gradual adoption for various sizes of systems. These are some of the common cases when people need to convert to C++ from some other language in the Embedded domain. We hope this overview and deep dive at the same time will give people a better appreciation and realistic perspective of what it takes to move to Modern C++ for Embedded systems.
---
Michael Wong
DE, Codeplay
wongmichael.com/about
---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,080 --> 00:00:14,559
hi everybody

00:00:11,759 --> 00:00:16,640
my name is michael wong and i'm a

00:00:14,559 --> 00:00:18,560
distinguished engineer at codeplay

00:00:16,640 --> 00:00:20,160
and today i would like to talk about

00:00:18,560 --> 00:00:24,160
modern embedded software

00:00:20,160 --> 00:00:24,160
needing modern c plus plus programming

00:00:24,400 --> 00:00:29,119
so just a slide that summarizes what my

00:00:26,640 --> 00:00:31,439
company does and the products that we

00:00:29,119 --> 00:00:32,960
we offer one other thing that about me

00:00:31,439 --> 00:00:36,320
something about me

00:00:32,960 --> 00:00:38,160
um i am a

00:00:36,320 --> 00:00:39,840
distinguished engineer at coldplay i

00:00:38,160 --> 00:00:40,879
chair the sickle heterogeneous

00:00:39,840 --> 00:00:42,559
programming language

00:00:40,879 --> 00:00:44,640
as well as the c plus plus directions

00:00:42,559 --> 00:00:47,039
group um

00:00:44,640 --> 00:00:48,320
in my career i switch from high

00:00:47,039 --> 00:00:50,320
performance computing

00:00:48,320 --> 00:00:51,680
to working now with embedded systems

00:00:50,320 --> 00:00:52,320
through my company that provides

00:00:51,680 --> 00:00:54,640
services

00:00:52,320 --> 00:00:56,239
uh for programming embedded systems and

00:00:54,640 --> 00:00:57,840
but so in a way i kind of but

00:00:56,239 --> 00:00:59,680
but in so doing i've also switched to

00:00:57,840 --> 00:01:00,640
machine learning and covering ai that's

00:00:59,680 --> 00:01:04,080
why i'm sharing

00:01:00,640 --> 00:01:05,600
sharing sg19 and sg14 and but in so

00:01:04,080 --> 00:01:07,520
doing i feel like i really

00:01:05,600 --> 00:01:09,600
come full circle because there's some

00:01:07,520 --> 00:01:11,200
aspects of embedded uh programming that

00:01:09,600 --> 00:01:12,799
is completely high performance computing

00:01:11,200 --> 00:01:13,439
these days because of the machine

00:01:12,799 --> 00:01:15,439
learning

00:01:13,439 --> 00:01:17,280
that's done there and because we do a

00:01:15,439 --> 00:01:18,560
lot of things with autonomous vehicles

00:01:17,280 --> 00:01:21,280
self-driving cars

00:01:18,560 --> 00:01:22,960
making them safe so that's why i'm

00:01:21,280 --> 00:01:24,240
trying to collect some of the experience

00:01:22,960 --> 00:01:27,360
that i have from working

00:01:24,240 --> 00:01:29,920
in this somewhat this this field for me

00:01:27,360 --> 00:01:31,280
as well as my years in the past of

00:01:29,920 --> 00:01:32,880
chairing sg14

00:01:31,280 --> 00:01:34,560
benefiting from some of the many of the

00:01:32,880 --> 00:01:36,159
people that's been involved so as a

00:01:34,560 --> 00:01:36,880
result i want to say that many of the

00:01:36,159 --> 00:01:40,320
slides

00:01:36,880 --> 00:01:41,119
um comes from probably unconsciously

00:01:40,320 --> 00:01:42,479
consciously

00:01:41,119 --> 00:01:44,399
watching some of the talks that have

00:01:42,479 --> 00:01:46,479
happened and listening to them through

00:01:44,399 --> 00:01:48,320
sg14 and within my company

00:01:46,479 --> 00:01:49,680
so i even lifted this disclaimer and

00:01:48,320 --> 00:01:51,920
acknowledgement from them

00:01:49,680 --> 00:01:53,360
from one of them i don't remember who um

00:01:51,920 --> 00:01:55,040
but however i would want to make sure

00:01:53,360 --> 00:01:56,799
that any credits for any errors

00:01:55,040 --> 00:01:59,439
are all mine they're all mine you can't

00:01:56,799 --> 00:02:00,159
have them so just the usual disclaimers

00:01:59,439 --> 00:02:01,520
that there's

00:02:00,159 --> 00:02:03,600
we're going to refer to some company

00:02:01,520 --> 00:02:05,360
products and things like that and they

00:02:03,600 --> 00:02:08,720
all have their own marks and that they

00:02:05,360 --> 00:02:11,599
should refer to them so

00:02:08,720 --> 00:02:13,280
let's start so this is my three-act play

00:02:11,599 --> 00:02:15,599
so what is embedded

00:02:13,280 --> 00:02:16,480
how to change from c to c plus plus and

00:02:15,599 --> 00:02:18,640
y

00:02:16,480 --> 00:02:19,840
and modern embedded c plus plus

00:02:18,640 --> 00:02:22,319
programming and as

00:02:19,840 --> 00:02:23,680
and i'm going to summarize what sg14 has

00:02:22,319 --> 00:02:26,800
contributed to c

00:02:23,680 --> 00:02:28,720
plus and where it's going

00:02:26,800 --> 00:02:30,560
so let's start with the first one what

00:02:28,720 --> 00:02:33,680
is embedded

00:02:30,560 --> 00:02:35,040
so this actually is not a good picture

00:02:33,680 --> 00:02:36,800
for what is embedded there are many

00:02:35,040 --> 00:02:37,440
pictures that come afterwards i've been

00:02:36,800 --> 00:02:39,840
told that

00:02:37,440 --> 00:02:41,280
in any talks it never hurts to have

00:02:39,840 --> 00:02:43,519
pictures of cats in there

00:02:41,280 --> 00:02:44,959
so this is just me trying to sleep with

00:02:43,519 --> 00:02:46,480
my cat

00:02:44,959 --> 00:02:48,080
so it has nothing to do with embedded

00:02:46,480 --> 00:02:51,360
but this does

00:02:48,080 --> 00:02:52,800
so what is an embedded system so

00:02:51,360 --> 00:02:54,640
people have always struggled with the

00:02:52,800 --> 00:02:56,560
definition of an embedded system and i'm

00:02:54,640 --> 00:02:59,360
not gonna claim that i can do any better

00:02:56,560 --> 00:03:01,280
all i can say is that it's a wide range

00:02:59,360 --> 00:03:02,080
of things and nobody really knows what

00:03:01,280 --> 00:03:04,560
it is

00:03:02,080 --> 00:03:06,239
it goes from the small to the large the

00:03:04,560 --> 00:03:07,280
field to the many and i'm gonna go

00:03:06,239 --> 00:03:08,959
through some of that

00:03:07,280 --> 00:03:10,480
just to see if it hits some of you and

00:03:08,959 --> 00:03:12,400
your nerve points

00:03:10,480 --> 00:03:13,840
so an embedded system is pretty much

00:03:12,400 --> 00:03:16,159
nearly any computing

00:03:13,840 --> 00:03:17,599
computer other than a desktop laptop or

00:03:16,159 --> 00:03:19,920
mainframe computer

00:03:17,599 --> 00:03:20,800
and there is a definition and it says

00:03:19,920 --> 00:03:22,400
that that

00:03:20,800 --> 00:03:24,159
it's a combination of hardware and

00:03:22,400 --> 00:03:26,799
software which together

00:03:24,159 --> 00:03:28,480
uh form a component of a larger machine

00:03:26,799 --> 00:03:30,319
um it's a combination so

00:03:28,480 --> 00:03:31,840
so an example of an embedded system is a

00:03:30,319 --> 00:03:32,720
microprocessor that controls an

00:03:31,840 --> 00:03:34,959
automobile

00:03:32,720 --> 00:03:34,959
engine

00:03:35,760 --> 00:03:39,360
and this embedded system might be

00:03:38,159 --> 00:03:41,440
designed to run

00:03:39,360 --> 00:03:43,440
on its own without human intervention

00:03:41,440 --> 00:03:45,519
and may be required to respond to events

00:03:43,440 --> 00:03:49,360
in real time

00:03:45,519 --> 00:03:51,360
so computers use so we we do know that

00:03:49,360 --> 00:03:54,239
it is definitely a computer that uses

00:03:51,360 --> 00:03:55,519
part of a larger system and here um and

00:03:54,239 --> 00:03:57,439
the thing is they don't often

00:03:55,519 --> 00:03:58,879
look like a computer they look like

00:03:57,439 --> 00:04:02,319
physical devices

00:03:58,879 --> 00:04:04,239
and often reliability is a key

00:04:02,319 --> 00:04:06,480
it's critical critical as in if the

00:04:04,239 --> 00:04:09,200
system fails someone might die

00:04:06,480 --> 00:04:10,560
so and the other thing is that resources

00:04:09,200 --> 00:04:12,400
might be limited

00:04:10,560 --> 00:04:13,599
so in other words it's basically any

00:04:12,400 --> 00:04:14,959
sort of device which includes a

00:04:13,599 --> 00:04:16,959
programmable computer

00:04:14,959 --> 00:04:18,639
but itself is not intended to be a

00:04:16,959 --> 00:04:20,880
general purpose computer

00:04:18,639 --> 00:04:22,639
and how many do we use well the average

00:04:20,880 --> 00:04:25,440
middle class home

00:04:22,639 --> 00:04:26,800
has roughly 40 to 50 embedded processors

00:04:25,440 --> 00:04:29,440
in it

00:04:26,800 --> 00:04:30,160
okay um that's in the microwave it's in

00:04:29,440 --> 00:04:32,160
the washer

00:04:30,160 --> 00:04:33,199
hair dryer coffee maker remote control

00:04:32,160 --> 00:04:35,919
humidifier

00:04:33,199 --> 00:04:36,479
heater toys etc if you have a car for

00:04:35,919 --> 00:04:39,280
instance

00:04:36,479 --> 00:04:40,080
it probably has about 60 embedded

00:04:39,280 --> 00:04:42,320
processors

00:04:40,080 --> 00:04:44,000
in there in the brakes in the steering

00:04:42,320 --> 00:04:46,479
in the windows and the locks

00:04:44,000 --> 00:04:47,280
ignition dashboard display transmission

00:04:46,479 --> 00:04:49,280
mirrors

00:04:47,280 --> 00:04:50,560
even the mirror might have it um

00:04:49,280 --> 00:04:52,000
personal computers

00:04:50,560 --> 00:04:53,840
if you think they're not embedded

00:04:52,000 --> 00:04:56,160
devices you might be wrong

00:04:53,840 --> 00:04:57,680
they might have over 10 embedded

00:04:56,160 --> 00:04:59,199
processor in there in the graphics

00:04:57,680 --> 00:05:02,080
accelerator in the mouse

00:04:59,199 --> 00:05:04,160
in the keyboard in hard drive cd-rom bus

00:05:02,080 --> 00:05:08,240
network interface

00:05:04,160 --> 00:05:10,080
okay so

00:05:08,240 --> 00:05:12,000
it is many things and often it's

00:05:10,080 --> 00:05:13,600
purpose-built

00:05:12,000 --> 00:05:15,360
and there are many people who think it's

00:05:13,600 --> 00:05:17,120
one thing but it's definitely not it's a

00:05:15,360 --> 00:05:18,720
wide spectrum and i know enough to say i

00:05:17,120 --> 00:05:20,479
don't know what it is and then i occupy

00:05:18,720 --> 00:05:23,360
a very small part of that

00:05:20,479 --> 00:05:24,000
computing systems uh embedded within

00:05:23,360 --> 00:05:25,919
it's basically

00:05:24,000 --> 00:05:27,759
the the computing systems embedded

00:05:25,919 --> 00:05:28,960
within electronic devices it's really

00:05:27,759 --> 00:05:31,120
hard to define

00:05:28,960 --> 00:05:33,120
nearly any computer systems other than a

00:05:31,120 --> 00:05:35,280
desktop and their billions of these

00:05:33,120 --> 00:05:36,080
units produced yearly versus millions of

00:05:35,280 --> 00:05:38,000
desktops

00:05:36,080 --> 00:05:40,320
maybe 50 per household and per

00:05:38,000 --> 00:05:42,400
automobile

00:05:40,320 --> 00:05:43,680
and they they spent a wide range of

00:05:42,400 --> 00:05:47,199
seriousness from

00:05:43,680 --> 00:05:49,120
fun peel fun like a little raspberry pie

00:05:47,199 --> 00:05:50,880
to deadly serious systems that is

00:05:49,120 --> 00:05:53,840
controlling nuclear reactors

00:05:50,880 --> 00:05:53,840
or to all vehicles

00:05:55,120 --> 00:05:58,400
they might span a wide range of response

00:05:57,199 --> 00:06:00,560
times

00:05:58,400 --> 00:06:02,639
from microseconds to milliseconds to

00:06:00,560 --> 00:06:03,600
seconds and this is touch on the idea

00:06:02,639 --> 00:06:05,440
that hard real

00:06:03,600 --> 00:06:07,120
that you have this thing about some of

00:06:05,440 --> 00:06:08,880
them might be hard real time

00:06:07,120 --> 00:06:11,120
that are designed to meet all design

00:06:08,880 --> 00:06:13,440
deadlines and i missed a lot

00:06:11,120 --> 00:06:15,280
a missed deadline is a design flaw they

00:06:13,440 --> 00:06:17,039
might be firm real time which is

00:06:15,280 --> 00:06:18,880
designed to meet all the deadlines but

00:06:17,039 --> 00:06:21,039
occasionally they might miss deadlines

00:06:18,880 --> 00:06:22,080
and is allowed that's allowed so system

00:06:21,039 --> 00:06:23,199
is designed to meet basically all

00:06:22,080 --> 00:06:24,880
deadlines but occasionally

00:06:23,199 --> 00:06:26,479
a miss is okay and sometimes they're

00:06:24,880 --> 00:06:28,160
statistically quantified

00:06:26,479 --> 00:06:30,160
examples of that are like multimedia

00:06:28,160 --> 00:06:31,759
systems multimedia system

00:06:30,160 --> 00:06:33,600
hardware design for average case

00:06:31,759 --> 00:06:36,080
performance

00:06:33,600 --> 00:06:37,680
then there's soft real time that's

00:06:36,080 --> 00:06:38,400
designed to meet as many deadlines as

00:06:37,680 --> 00:06:41,120
possible

00:06:38,400 --> 00:06:41,840
the system is designed uh to so such

00:06:41,120 --> 00:06:43,840
that

00:06:41,840 --> 00:06:45,440
it uses the best effort to come to

00:06:43,840 --> 00:06:47,360
complete within the specified

00:06:45,440 --> 00:06:48,960
specified time but it might be late for

00:06:47,360 --> 00:06:52,000
example a network switch

00:06:48,960 --> 00:06:54,720
or router okay and these are some of the

00:06:52,000 --> 00:06:56,880
things that we have to deal with

00:06:54,720 --> 00:06:58,080
other things is that they might there

00:06:56,880 --> 00:06:59,840
are plenty of

00:06:58,080 --> 00:07:01,599
other things as critical is that

00:06:59,840 --> 00:07:03,280
predictability might be key

00:07:01,599 --> 00:07:06,560
correctness is even more important than

00:07:03,280 --> 00:07:06,560
usual okay

00:07:08,000 --> 00:07:11,919
they also span a wide span of

00:07:10,319 --> 00:07:13,919
replications

00:07:11,919 --> 00:07:16,240
from single ones like maybe a nuclear

00:07:13,919 --> 00:07:17,520
reactor to millions of toys that might

00:07:16,240 --> 00:07:19,520
be in production

00:07:17,520 --> 00:07:21,759
and these are different ways that they

00:07:19,520 --> 00:07:24,720
could be they could be

00:07:21,759 --> 00:07:24,720
they could be produced

00:07:25,360 --> 00:07:30,880
they span a wide range of hardware also

00:07:28,400 --> 00:07:31,520
from one kilobyte to one gig megabytes

00:07:30,880 --> 00:07:35,599
or one

00:07:31,520 --> 00:07:37,120
gigabytes eight bits um 8051 pic avr

00:07:35,599 --> 00:07:38,319
where there's no full c plus plus

00:07:37,120 --> 00:07:42,240
standard that can work in them

00:07:38,319 --> 00:07:45,759
16 bits um msb 430

00:07:42,240 --> 00:07:48,879
pick or 32-bit from arms mips 10 silica

00:07:45,759 --> 00:07:50,960
intel or even 64-bits so

00:07:48,879 --> 00:07:52,960
in the 64-bit the types of embedded

00:07:50,960 --> 00:07:56,080
processors for computational

00:07:52,960 --> 00:07:58,319
micros like 32-64-bits beta pass

00:07:56,080 --> 00:07:59,759
they might be cpu or workspace of the

00:07:58,319 --> 00:08:01,840
cpu of the workstation

00:07:59,759 --> 00:08:04,319
pcs or high-end portable devices like

00:08:01,840 --> 00:08:06,800
pdas that is using x86

00:08:04,319 --> 00:08:08,639
pa risk power pc spot they might be

00:08:06,800 --> 00:08:11,280
embedded general purpose micros

00:08:08,639 --> 00:08:12,800
that are 32-bit designed for a wide

00:08:11,280 --> 00:08:14,080
range of embedded applications they're

00:08:12,800 --> 00:08:16,240
often scaled down

00:08:14,080 --> 00:08:18,639
uh versions of computation micros these

00:08:16,240 --> 00:08:21,120
are available from on power pc mips

00:08:18,639 --> 00:08:22,800
x86 68 000 they might be

00:08:21,120 --> 00:08:26,160
microcontrollers that are 4

00:08:22,800 --> 00:08:28,160
8 or 16 bit data paths

00:08:26,160 --> 00:08:30,560
with integrated processing unit memory

00:08:28,160 --> 00:08:32,880
io buses and peripherals they're often

00:08:30,560 --> 00:08:34,800
low-cost high-volume devices

00:08:32,880 --> 00:08:36,159
they might also be domain-specific

00:08:34,800 --> 00:08:39,760
processors

00:08:36,159 --> 00:08:42,080
with varying different data paths

00:08:39,760 --> 00:08:43,839
designed for particular domain uh with

00:08:42,080 --> 00:08:45,920
digital signal processors

00:08:43,839 --> 00:08:47,839
uh multimedia processes graphics

00:08:45,920 --> 00:08:48,560
processors network processors security

00:08:47,839 --> 00:08:50,640
processors

00:08:48,560 --> 00:08:52,160
and these days they might be ai or

00:08:50,640 --> 00:08:54,160
machine learning processors

00:08:52,160 --> 00:08:55,760
or tensor processing units which is the

00:08:54,160 --> 00:08:59,519
kind of things that um

00:08:55,760 --> 00:08:59,519
that my company programs for

00:09:02,399 --> 00:09:06,000
so they definitely span a wide range of

00:09:04,640 --> 00:09:08,560
supported software

00:09:06,000 --> 00:09:10,320
from bare metal which is just a library

00:09:08,560 --> 00:09:13,600
but there's no supported os

00:09:10,320 --> 00:09:15,440
no separate os to interpreters that

00:09:13,600 --> 00:09:17,920
all that have maybe a real-time

00:09:15,440 --> 00:09:22,320
operating system to desktop os as there

00:09:17,920 --> 00:09:24,640
are linux or windows

00:09:22,320 --> 00:09:26,560
so in general i separate them into two

00:09:24,640 --> 00:09:28,000
general domains they're the megabytes

00:09:26,560 --> 00:09:30,399
the gigabyte gigahertz

00:09:28,000 --> 00:09:31,200
multi-core memory with memory latency

00:09:30,399 --> 00:09:32,560
caches

00:09:31,200 --> 00:09:34,800
these are good for high frequency

00:09:32,560 --> 00:09:37,519
trading gaming simulations

00:09:34,800 --> 00:09:38,000
large embedded systems to the small

00:09:37,519 --> 00:09:39,600
bytes

00:09:38,000 --> 00:09:41,920
kilobytes mega they're running at

00:09:39,600 --> 00:09:44,080
megahertz interrupts hardware

00:09:41,920 --> 00:09:45,760
these are like the hardware peripherals

00:09:44,080 --> 00:09:47,360
and they're in that space battery

00:09:45,760 --> 00:09:51,839
lifetime is an issue

00:09:47,360 --> 00:09:51,839
so in the small embedded systems

00:09:52,720 --> 00:09:58,320
so some embedded characteristics um

00:09:56,240 --> 00:09:59,839
definitely they have problem they

00:09:58,320 --> 00:10:01,360
probably

00:09:59,839 --> 00:10:03,920
have application specific

00:10:01,360 --> 00:10:06,079
functionalities they specialize for one

00:10:03,920 --> 00:10:07,360
or one class of applications

00:10:06,079 --> 00:10:09,120
they might be deadlock they might be

00:10:07,360 --> 00:10:10,720
deadline constrained um

00:10:09,120 --> 00:10:13,040
in that the system have to perform its

00:10:10,720 --> 00:10:15,440
functions within a specific time period

00:10:13,040 --> 00:10:16,800
to achieve a successful result they

00:10:15,440 --> 00:10:18,800
might be resource challenged

00:10:16,800 --> 00:10:20,399
in that the system typically are

00:10:18,800 --> 00:10:22,000
configured with a modest set of

00:10:20,399 --> 00:10:23,279
resources to meet the performance

00:10:22,000 --> 00:10:25,360
objectives

00:10:23,279 --> 00:10:26,959
uh they might be power efficient or need

00:10:25,360 --> 00:10:28,480
to be power efficient and that many

00:10:26,959 --> 00:10:30,560
systems are battery powered

00:10:28,480 --> 00:10:31,519
and may have the conserve power to

00:10:30,560 --> 00:10:34,560
maximize

00:10:31,519 --> 00:10:36,800
and use the the the usable life of the

00:10:34,560 --> 00:10:38,240
of the of the system they might have

00:10:36,800 --> 00:10:40,640
form factors where

00:10:38,240 --> 00:10:42,560
many systems are lightweight and low

00:10:40,640 --> 00:10:43,519
volume to be used as components in whole

00:10:42,560 --> 00:10:44,800
systems

00:10:43,519 --> 00:10:46,240
they might they have to be

00:10:44,800 --> 00:10:47,440
manufacturable they have to have

00:10:46,240 --> 00:10:49,040
manufacturable

00:10:47,440 --> 00:10:51,279
qualities like they might be usually

00:10:49,040 --> 00:10:53,440
small and inexpensive to manufacture

00:10:51,279 --> 00:10:56,000
based on the size and low complexity of

00:10:53,440 --> 00:10:56,000
the hardware

00:10:57,279 --> 00:11:01,360
in terms of design as we work closely

00:11:00,240 --> 00:11:03,279
with some of the design

00:11:01,360 --> 00:11:04,560
before they hand it to us to program

00:11:03,279 --> 00:11:05,920
them we notice that

00:11:04,560 --> 00:11:08,079
they are certainly concerned with things

00:11:05,920 --> 00:11:10,000
like unit cost which is the monetary

00:11:08,079 --> 00:11:10,640
cost of manufacturing each copy of the

00:11:10,000 --> 00:11:15,040
system

00:11:10,640 --> 00:11:17,040
they might be um um concerned with nre

00:11:15,040 --> 00:11:19,040
or non-recoverable engineering costs

00:11:17,040 --> 00:11:21,760
this is the monetary cost monetary cost

00:11:19,040 --> 00:11:24,320
of manufacturing each copy of the system

00:11:21,760 --> 00:11:26,000
okay this is the one-time monetary cost

00:11:24,320 --> 00:11:28,000
of the design of the system

00:11:26,000 --> 00:11:29,519
okay they might be concerned the size

00:11:28,000 --> 00:11:30,399
the physical space required by the

00:11:29,519 --> 00:11:32,959
system

00:11:30,399 --> 00:11:34,720
the performance the execution time or

00:11:32,959 --> 00:11:39,120
throughput of the system

00:11:34,720 --> 00:11:41,120
they might be interested in the

00:11:39,120 --> 00:11:42,800
the the power the amount of power that's

00:11:41,120 --> 00:11:44,320
being consumed

00:11:42,800 --> 00:11:45,839
they might be concerned with flexibility

00:11:44,320 --> 00:11:47,519
the ability to basically change the

00:11:45,839 --> 00:11:48,160
functionality system without incurring

00:11:47,519 --> 00:11:51,200
heavy

00:11:48,160 --> 00:11:52,480
uh nre costs um they might be concerned

00:11:51,200 --> 00:11:54,320
with time to prototype

00:11:52,480 --> 00:11:56,480
the time it needed to build a work

00:11:54,320 --> 00:11:58,480
working version of this of the system

00:11:56,480 --> 00:12:00,240
they might be considered time to market

00:11:58,480 --> 00:12:01,440
the time that's required to develop

00:12:00,240 --> 00:12:03,120
system to the point that it can be

00:12:01,440 --> 00:12:03,839
released and so to customers so they

00:12:03,120 --> 00:12:05,760
don't miss

00:12:03,839 --> 00:12:07,680
a peak point in the market when it's

00:12:05,760 --> 00:12:09,760
needed in terms of they also would be

00:12:07,680 --> 00:12:12,560
concerned with maintainability ability

00:12:09,760 --> 00:12:14,720
the ability to modify the system after

00:12:12,560 --> 00:12:15,920
its initial its final initial release

00:12:14,720 --> 00:12:17,600
and then furthermore they might be

00:12:15,920 --> 00:12:19,200
certainly concerned about the

00:12:17,600 --> 00:12:21,360
correctness the safety

00:12:19,200 --> 00:12:23,120
so in terms of dependability they might

00:12:21,360 --> 00:12:24,000
be interested in reliability that is the

00:12:23,120 --> 00:12:26,240
probability

00:12:24,000 --> 00:12:27,279
of a system working correctly provided

00:12:26,240 --> 00:12:29,440
it worked at time t

00:12:27,279 --> 00:12:31,600
equals zero they might be interested in

00:12:29,440 --> 00:12:32,720
maintainability that is the probability

00:12:31,600 --> 00:12:36,000
of a system

00:12:32,720 --> 00:12:37,680
working correctly certain time units

00:12:36,000 --> 00:12:39,600
after an error occurred

00:12:37,680 --> 00:12:41,680
and then availability the probability

00:12:39,600 --> 00:12:44,160
the system working at time t

00:12:41,680 --> 00:12:45,200
safety and security in communications

00:12:44,160 --> 00:12:46,880
basically critical

00:12:45,200 --> 00:12:48,480
applications have to operate correctly

00:12:46,880 --> 00:12:49,200
at all times like airplane flight

00:12:48,480 --> 00:12:51,519
control

00:12:49,200 --> 00:12:55,519
control computers and this would include

00:12:51,519 --> 00:12:55,519
both hardware and software aspects

00:12:56,560 --> 00:13:00,079
so who are the embedded programmers they

00:12:58,800 --> 00:13:01,600
certainly come from the domain of

00:13:00,079 --> 00:13:04,560
professional programmers

00:13:01,600 --> 00:13:06,399
or engineers that would know programming

00:13:04,560 --> 00:13:08,959
training and everything in between

00:13:06,399 --> 00:13:11,519
there's definitely a trade-off okay in

00:13:08,959 --> 00:13:13,760
that the expertise they need expertise

00:13:11,519 --> 00:13:15,920
with both software and hardware

00:13:13,760 --> 00:13:17,680
that's is is basically needed in both

00:13:15,920 --> 00:13:19,920
the optimizing the design

00:13:17,680 --> 00:13:21,200
and the optimizing the soft the

00:13:19,920 --> 00:13:23,760
subsequent programming

00:13:21,200 --> 00:13:25,600
so designer of of this has to be

00:13:23,760 --> 00:13:27,120
comfortable with various technologies in

00:13:25,600 --> 00:13:29,760
order to choose the best

00:13:27,120 --> 00:13:30,320
for a given application and constrains

00:13:29,760 --> 00:13:35,360
the

00:13:30,320 --> 00:13:38,720
and constraints

00:13:35,360 --> 00:13:40,639
so complexity is increasing um the code

00:13:38,720 --> 00:13:42,880
component of the system is increasing

00:13:40,639 --> 00:13:44,480
the complexity of the code is increasing

00:13:42,880 --> 00:13:46,480
and you need change

00:13:44,480 --> 00:13:48,560
the needs change over time and that's

00:13:46,480 --> 00:13:50,240
increasing we need all the help we can

00:13:48,560 --> 00:13:52,320
get and we all need to get better at

00:13:50,240 --> 00:13:56,399
handling code complexity

00:13:52,320 --> 00:13:57,920
it's harder to typically i've found that

00:13:56,399 --> 00:14:00,000
systems are becoming because systems are

00:13:57,920 --> 00:14:01,519
becoming more complex it's harder to

00:14:00,000 --> 00:14:04,079
think about total design

00:14:01,519 --> 00:14:06,000
and it's harder to fix bugs um it's

00:14:04,079 --> 00:14:06,880
harder to maintain the system over time

00:14:06,000 --> 00:14:09,199
so therefore

00:14:06,880 --> 00:14:10,320
the traditional development process has

00:14:09,199 --> 00:14:12,079
to change

00:14:10,320 --> 00:14:13,600
the traditional departure development

00:14:12,079 --> 00:14:14,560
process in a better program seems to be

00:14:13,600 --> 00:14:16,800
that you almost

00:14:14,560 --> 00:14:19,040
you would restart everything and that's

00:14:16,800 --> 00:14:22,240
not necessarily the best way to do it

00:14:19,040 --> 00:14:23,120
and that's kind of the the the the point

00:14:22,240 --> 00:14:25,040
of this talk

00:14:23,120 --> 00:14:26,959
is that switching from that mentality to

00:14:25,040 --> 00:14:30,000
c plus from c to c plus plus

00:14:26,959 --> 00:14:31,040
where you would use a a more designed

00:14:30,000 --> 00:14:33,360
life cycle

00:14:31,040 --> 00:14:34,320
and over overall view of the design

00:14:33,360 --> 00:14:38,160
before you get down

00:14:34,320 --> 00:14:40,880
into coding okay

00:14:38,160 --> 00:14:42,639
so let's talk about c plus plus c plus

00:14:40,880 --> 00:14:44,639
is a multi-paradigm language

00:14:42,639 --> 00:14:46,480
and there's no excuse basically to add

00:14:44,639 --> 00:14:48,320
any to add incompatible parts

00:14:46,480 --> 00:14:50,079
some of this is from our slides from the

00:14:48,320 --> 00:14:52,560
c plus directions group

00:14:50,079 --> 00:14:53,360
that i'm part of and so today we

00:14:52,560 --> 00:14:55,120
definitely

00:14:53,360 --> 00:14:56,399
combine aspects of object-oriented

00:14:55,120 --> 00:14:57,680
programming with generic

00:14:56,399 --> 00:15:00,000
and functional and imperative

00:14:57,680 --> 00:15:00,320
programming but trying to still provide

00:15:00,000 --> 00:15:03,519
a

00:15:00,320 --> 00:15:06,240
coherent style of use

00:15:03,519 --> 00:15:07,760
we definitely rest on dupe two pillars a

00:15:06,240 --> 00:15:09,760
direct map to hardware

00:15:07,760 --> 00:15:12,959
and zero overhead abstraction in

00:15:09,760 --> 00:15:14,480
production code

00:15:12,959 --> 00:15:16,000
and we don't want to fall under the trap

00:15:14,480 --> 00:15:17,440
of abandoning this pass

00:15:16,000 --> 00:15:20,000
which can seriously jeopardize

00:15:17,440 --> 00:15:22,160
compatibility and

00:15:20,000 --> 00:15:24,320
we don't want to stop addressing new

00:15:22,160 --> 00:15:24,880
challenges like higher level concurrency

00:15:24,320 --> 00:15:26,720
models

00:15:24,880 --> 00:15:28,480
and if we fail developer is going to

00:15:26,720 --> 00:15:31,199
switch to some other framework to gain

00:15:28,480 --> 00:15:33,279
better performance

00:15:31,199 --> 00:15:35,759
we want to strengthen our two pillars of

00:15:33,279 --> 00:15:38,560
supporting modern hardware

00:15:35,759 --> 00:15:40,079
as well as more expressive simpler and

00:15:38,560 --> 00:15:43,279
safer abstraction mechanisms

00:15:40,079 --> 00:15:43,279
without adding overhead

00:15:44,959 --> 00:15:49,839
and this has been a rule within c

00:15:48,639 --> 00:15:51,680
plus plus and that we don't want to

00:15:49,839 --> 00:15:54,079
leave room for a language below c

00:15:51,680 --> 00:15:55,120
plus we want and to do that we want to

00:15:54,079 --> 00:15:58,240
have more

00:15:55,120 --> 00:16:00,320
useful abstractions um so that

00:15:58,240 --> 00:16:01,680
in principle the c plus plus standard

00:16:00,320 --> 00:16:03,680
library can be implemented

00:16:01,680 --> 00:16:05,279
in c plus plus plus a few intrinsic

00:16:03,680 --> 00:16:08,720
operations for accessing

00:16:05,279 --> 00:16:11,120
the low-level machine facilities

00:16:08,720 --> 00:16:12,079
we want to have no memory corruptions

00:16:11,120 --> 00:16:14,160
and no leaks

00:16:12,079 --> 00:16:16,639
because c plus plus it relies critically

00:16:14,160 --> 00:16:19,040
on static type safety for expressiveness

00:16:16,639 --> 00:16:23,839
performance and safety so the ideal is

00:16:19,040 --> 00:16:23,839
complete type safety and resource safety

00:16:23,920 --> 00:16:28,160
in terms of domains um c plus plus is

00:16:26,160 --> 00:16:29,600
now used in more domains than ever we

00:16:28,160 --> 00:16:30,639
don't specifically recommend any

00:16:29,600 --> 00:16:33,440
specific domain

00:16:30,639 --> 00:16:35,199
as every domain is important to somebody

00:16:33,440 --> 00:16:36,720
in the larger c plus plus community

00:16:35,199 --> 00:16:38,480
even if their domain isn't well

00:16:36,720 --> 00:16:39,199
represented in the in the in the

00:16:38,480 --> 00:16:40,800
committee

00:16:39,199 --> 00:16:42,880
but we do intend to broaden our support

00:16:40,800 --> 00:16:46,000
for domains that are well represented

00:16:42,880 --> 00:16:47,440
and even non-traditional ones um so here

00:16:46,000 --> 00:16:49,120
we list the fields like

00:16:47,440 --> 00:16:50,720
domains of safety and securities

00:16:49,120 --> 00:16:54,160
simplifying c plus plus

00:16:50,720 --> 00:16:56,639
interoperability demanding applications

00:16:54,160 --> 00:17:00,560
embedded systems and alternatives for

00:16:56,639 --> 00:17:00,560
error-prone and unsafe variants

00:17:01,360 --> 00:17:05,679
so one of the things that i've noticed

00:17:03,839 --> 00:17:07,839
is that the constraints on the embedded

00:17:05,679 --> 00:17:08,880
code differ and this is in discussions

00:17:07,839 --> 00:17:10,240
with bianna

00:17:08,880 --> 00:17:12,160
in that different kinds of system

00:17:10,240 --> 00:17:14,480
require different styles of usage

00:17:12,160 --> 00:17:15,439
so big big systems might use the full

00:17:14,480 --> 00:17:17,360
language

00:17:15,439 --> 00:17:18,880
big systems with real-time constraints

00:17:17,360 --> 00:17:20,400
might be able to use the full language

00:17:18,880 --> 00:17:22,000
except on the critical path

00:17:20,400 --> 00:17:23,439
so that you can use the predictable

00:17:22,000 --> 00:17:25,839
subset of c plus plus

00:17:23,439 --> 00:17:26,799
on the critical path like avoiding the

00:17:25,839 --> 00:17:29,280
free store

00:17:26,799 --> 00:17:30,880
dynamically such things as dynamic

00:17:29,280 --> 00:17:32,880
memory of the heat

00:17:30,880 --> 00:17:34,559
small safety critical systems might use

00:17:32,880 --> 00:17:37,360
a print also use a predictable

00:17:34,559 --> 00:17:39,120
subset of the c plus plus tiny systems

00:17:37,360 --> 00:17:39,520
that are eight bit might use a subset of

00:17:39,120 --> 00:17:41,840
c

00:17:39,520 --> 00:17:44,160
plus but preserving the zero overhead

00:17:41,840 --> 00:17:46,240
and small four bit systems

00:17:44,160 --> 00:17:48,080
they might not have a c plus compiler so

00:17:46,240 --> 00:17:50,400
they might actually have to stay in c

00:17:48,080 --> 00:17:52,559
or assembler but in most cases you want

00:17:50,400 --> 00:17:56,080
to optimize memory usage because

00:17:52,559 --> 00:17:57,600
space is time here so that completes the

00:17:56,080 --> 00:17:59,280
first act the second act i want to talk

00:17:57,600 --> 00:17:59,679
about how to change for those of you

00:17:59,280 --> 00:18:02,240
guys

00:17:59,679 --> 00:18:03,039
a kind of a practical handbook on how to

00:18:02,240 --> 00:18:06,320
change from c

00:18:03,039 --> 00:18:06,320
and c plus plus and y

00:18:07,039 --> 00:18:11,120
so there are some good reasons to stick

00:18:08,960 --> 00:18:12,880
with c um

00:18:11,120 --> 00:18:14,400
i'm not totally i'm not bashing c

00:18:12,880 --> 00:18:16,080
because i want to look at i want to try

00:18:14,400 --> 00:18:17,039
to give a reasonable comparison what

00:18:16,080 --> 00:18:18,799
they have

00:18:17,039 --> 00:18:20,559
you might have no c plus plus compiler

00:18:18,799 --> 00:18:22,400
available and there's very

00:18:20,559 --> 00:18:23,919
in this is probably the case in very

00:18:22,400 --> 00:18:26,960
very small systems

00:18:23,919 --> 00:18:28,880
um but even those are beginning to

00:18:26,960 --> 00:18:30,880
come with c plus plus compilers you know

00:18:28,880 --> 00:18:33,000
if you have an arm five

00:18:30,880 --> 00:18:34,160
a c but not c plus once but on six in

00:18:33,000 --> 00:18:36,640
00:18:34,160 --> 00:18:38,720
is clang based and fully c plus plus 14

00:18:36,640 --> 00:18:41,840
and we'll update the c plus about 17

00:18:38,720 --> 00:18:42,400
and enable things like lto gcc obviously

00:18:41,840 --> 00:18:44,799
targets

00:18:42,400 --> 00:18:46,559
many embedded devices um if you have

00:18:44,799 --> 00:18:49,200
something like an 8-bit less than

00:18:46,559 --> 00:18:50,559
1k controllers that might be the case

00:18:49,200 --> 00:18:51,360
that you can't have a c-plus plus

00:18:50,559 --> 00:18:53,919
compiler

00:18:51,360 --> 00:18:56,880
so basically very small no os real-time

00:18:53,919 --> 00:18:58,880
programs without communications

00:18:56,880 --> 00:19:01,600
you might be the case that c is required

00:18:58,880 --> 00:19:04,240
or mandated by older standard customers

00:19:01,600 --> 00:19:05,840
law or safety or standards or insurance

00:19:04,240 --> 00:19:06,880
so so that's something like classic

00:19:05,840 --> 00:19:09,919
autosar

00:19:06,880 --> 00:19:12,400
has to follow c but i noted that even

00:19:09,919 --> 00:19:14,880
auto saw especially the

00:19:12,400 --> 00:19:16,960
adaptive auto saw which is fitted for

00:19:14,880 --> 00:19:17,200
parallelism is now switching to support

00:19:16,960 --> 00:19:19,679
c

00:19:17,200 --> 00:19:21,679
plus plus you might have an r an

00:19:19,679 --> 00:19:23,280
infineon rx that has a lock step

00:19:21,679 --> 00:19:26,160
multi-core processor

00:19:23,280 --> 00:19:28,080
for safety critical system but even even

00:19:26,160 --> 00:19:30,080
think even their think and ask for

00:19:28,080 --> 00:19:31,280
modern certified compilers there and you

00:19:30,080 --> 00:19:33,120
might have it

00:19:31,280 --> 00:19:34,400
you might really need variable length

00:19:33,120 --> 00:19:37,440
array who needs that

00:19:34,400 --> 00:19:38,000
and if you do well only c99 has it and

00:19:37,440 --> 00:19:40,799
that's

00:19:38,000 --> 00:19:41,440
now actually optional in later c it is

00:19:40,799 --> 00:19:44,640
not in c

00:19:41,440 --> 00:19:44,960
plus plus you might also so i would say

00:19:44,640 --> 00:19:47,760
that

00:19:44,960 --> 00:19:49,520
as a result almost all new chips now

00:19:47,760 --> 00:19:51,440
benefits from c plus plus

00:19:49,520 --> 00:19:53,200
any of the on-base 32-bit

00:19:51,440 --> 00:19:53,679
microcontrollers any of the embedded

00:19:53,200 --> 00:19:58,960
linux

00:19:53,679 --> 00:19:58,960
autos even the arduino is c plus plus

00:20:00,799 --> 00:20:04,080
there might be temporary reasons that

00:20:02,640 --> 00:20:06,960
you might need to

00:20:04,080 --> 00:20:07,919
stick to using c um you might have no

00:20:06,960 --> 00:20:09,840
guidelines

00:20:07,919 --> 00:20:11,039
and you need to you have no training or

00:20:09,840 --> 00:20:13,760
education c

00:20:11,039 --> 00:20:15,520
plus that's why you're here you you you

00:20:13,760 --> 00:20:17,120
there's lots of internet video on c

00:20:15,520 --> 00:20:19,520
spots much of all of this conference

00:20:17,120 --> 00:20:21,200
goes on are freely available

00:20:19,520 --> 00:20:23,200
on youtube you're coming to this

00:20:21,200 --> 00:20:25,039
conference you might use mizra c

00:20:23,200 --> 00:20:26,480
plus or you might use c plus plus core

00:20:25,039 --> 00:20:28,480
guidelines

00:20:26,480 --> 00:20:29,520
you your staff might have no c plus plus

00:20:28,480 --> 00:20:31,520
programmers

00:20:29,520 --> 00:20:33,280
which might be a surprise because many

00:20:31,520 --> 00:20:35,760
graduates these days

00:20:33,280 --> 00:20:37,440
want to program in c plus so again get

00:20:35,760 --> 00:20:38,159
training from many of the trainers that

00:20:37,440 --> 00:20:39,679
are available

00:20:38,159 --> 00:20:41,760
here at this conference and

00:20:39,679 --> 00:20:42,400
internationally you might have a very

00:20:41,760 --> 00:20:44,480
large c

00:20:42,400 --> 00:20:45,600
code base and you want to really stay

00:20:44,480 --> 00:20:48,159
with that

00:20:45,600 --> 00:20:50,640
and you would in that case you might

00:20:48,159 --> 00:20:53,520
have to start with compiling your c to c

00:20:50,640 --> 00:20:55,679
plus plus code in most cases you just

00:20:53,520 --> 00:20:57,679
have to change dot c to dot cpu b

00:20:55,679 --> 00:20:59,280
turn on the c plus bus mode and you'll

00:20:57,679 --> 00:21:00,320
probably get lots of errors with voice

00:20:59,280 --> 00:21:01,440
start conversions

00:21:00,320 --> 00:21:02,640
then you're going to have to look at

00:21:01,440 --> 00:21:06,480
each and every one of these and

00:21:02,640 --> 00:21:06,480
basically change them to their real type

00:21:08,400 --> 00:21:12,400
so many previous speakers to me have

00:21:10,960 --> 00:21:14,480
talked about uh

00:21:12,400 --> 00:21:16,080
some of the myths about why not uc plus

00:21:14,480 --> 00:21:17,679
plus and why not argue with people

00:21:16,080 --> 00:21:20,240
i specifically researched refer you to

00:21:17,679 --> 00:21:23,280
dansak's keynote couple of years ago

00:21:20,240 --> 00:21:25,840
the myth comes fast and furious

00:21:23,280 --> 00:21:27,679
in that there's people would say that c

00:21:25,840 --> 00:21:29,679
plus is complex and large

00:21:27,679 --> 00:21:31,440
um but i would argue that as i said in

00:21:29,679 --> 00:21:32,960
the fireside chat earlier you don't have

00:21:31,440 --> 00:21:33,760
to learn all the c plus plus to be

00:21:32,960 --> 00:21:37,520
productive

00:21:33,760 --> 00:21:39,520
and i think sg14 40 our uh 20

00:21:37,520 --> 00:21:40,559
our education group is going to try to

00:21:39,520 --> 00:21:43,200
show some

00:21:40,559 --> 00:21:44,000
some reasonable path through that um i

00:21:43,200 --> 00:21:45,440
myself don't know

00:21:44,000 --> 00:21:47,280
all the c plus either i don't think

00:21:45,440 --> 00:21:47,919
anyone does or they say they are they're

00:21:47,280 --> 00:21:50,880
probably

00:21:47,919 --> 00:21:51,360
lying it is a large language and it's

00:21:50,880 --> 00:21:53,120
it's not

00:21:51,360 --> 00:21:54,880
easy to keep up even for us committee

00:21:53,120 --> 00:21:56,720
members but we do the best we can and

00:21:54,880 --> 00:21:59,200
i'm still productive with c plus plus

00:21:56,720 --> 00:22:01,679
without knowing every detail

00:21:59,200 --> 00:22:03,039
um c plus plus makes code execution less

00:22:01,679 --> 00:22:05,440
predictable debug

00:22:03,039 --> 00:22:07,440
so that's kind of like what in most

00:22:05,440 --> 00:22:09,120
electrical engineers hire to do embedded

00:22:07,440 --> 00:22:12,559
programming will say because they love c

00:22:09,120 --> 00:22:13,919
style and they think in assembler almost

00:22:12,559 --> 00:22:16,240
immediately when they're writing c

00:22:13,919 --> 00:22:18,080
when they're writing c code and vendors

00:22:16,240 --> 00:22:19,520
as a result tap into that thinking and

00:22:18,080 --> 00:22:22,080
they love selling them

00:22:19,520 --> 00:22:23,360
debuggers and generators computer

00:22:22,080 --> 00:22:25,280
scientists however like c

00:22:23,360 --> 00:22:26,559
plus plus in general and loves to build

00:22:25,280 --> 00:22:29,200
and use abstraction

00:22:26,559 --> 00:22:31,280
so that they can get into that the right

00:22:29,200 --> 00:22:32,799
review test cycle

00:22:31,280 --> 00:22:35,200
you might say that c plus plus is

00:22:32,799 --> 00:22:37,440
changing too fast yes that is the case

00:22:35,200 --> 00:22:39,200
it's changing every three years and yes

00:22:37,440 --> 00:22:41,039
we're adding lots of features that is

00:22:39,200 --> 00:22:42,880
further helping

00:22:41,039 --> 00:22:44,640
as a result that's helping embed it and

00:22:42,880 --> 00:22:47,520
safety critical while c

00:22:44,640 --> 00:22:49,200
is not changing um at last i heard

00:22:47,520 --> 00:22:51,679
they're still on a kind of a 10-year

00:22:49,200 --> 00:22:51,679
cadence

00:22:53,679 --> 00:22:57,520
so some bad reasons about why not use c

00:22:56,480 --> 00:22:59,840
plus plus

00:22:57,520 --> 00:23:00,880
um some people might say that we worry

00:22:59,840 --> 00:23:04,320
that we can change

00:23:00,880 --> 00:23:06,960
back to c um the idea there

00:23:04,320 --> 00:23:08,159
is that you could do it gradually and

00:23:06,960 --> 00:23:08,720
i'm going to show you some of that those

00:23:08,159 --> 00:23:10,640
steps

00:23:08,720 --> 00:23:12,240
and don't go all the way to what i call

00:23:10,640 --> 00:23:13,200
the third age which is like meta

00:23:12,240 --> 00:23:17,520
programming

00:23:13,200 --> 00:23:17,520
if you go gradually you

00:23:20,320 --> 00:23:23,600
there for a moment okay we're back so

00:23:22,480 --> 00:23:27,760
you might worry that c

00:23:23,600 --> 00:23:31,200
plus is slower and hello world

00:23:27,760 --> 00:23:33,760
let's see if i can get back my screen

00:23:31,200 --> 00:23:36,000
okay so you might worry that c plus is

00:23:33,760 --> 00:23:38,799
solar hello world is a bad example in my

00:23:36,000 --> 00:23:40,080
in my view um in the embedded world in

00:23:38,799 --> 00:23:42,320
the in the embedded world

00:23:40,080 --> 00:23:44,720
um i don't really see too many cases of

00:23:42,320 --> 00:23:47,200
print f and stood out

00:23:44,720 --> 00:23:48,559
being a fair comparison they're probably

00:23:47,200 --> 00:23:51,840
not that relevant

00:23:48,559 --> 00:23:53,039
okay um so c plus produces large

00:23:51,840 --> 00:23:55,679
executables

00:23:53,039 --> 00:23:57,520
um that's another bad reason i think in

00:23:55,679 --> 00:23:59,279
terms of arguing why you won't use c

00:23:57,520 --> 00:24:00,880
plus you have to use your tool chain

00:23:59,279 --> 00:24:02,400
properly in that case

00:24:00,880 --> 00:24:04,320
you might say that you don't have the

00:24:02,400 --> 00:24:08,000
right people the c

00:24:04,320 --> 00:24:10,080
style electrical engineers or c plus

00:24:08,000 --> 00:24:12,320
computer scientists are both not quite

00:24:10,080 --> 00:24:12,320
right

00:24:16,080 --> 00:24:20,640
okay i know that my video has

00:24:18,000 --> 00:24:20,640
disappeared

00:24:27,600 --> 00:24:37,520
it's gonna come back excellent all right

00:24:33,360 --> 00:24:39,440
next so

00:24:37,520 --> 00:24:41,919
there's a poll that was done a couple of

00:24:39,440 --> 00:24:44,320
years ago um

00:24:41,919 --> 00:24:45,679
by patricia asked about one for c plus

00:24:44,320 --> 00:24:47,919
plus and one for c

00:24:45,679 --> 00:24:48,799
and they ask what is the most common bug

00:24:47,919 --> 00:24:52,080
that you see

00:24:48,799 --> 00:24:53,919
in production others um so for

00:24:52,080 --> 00:24:55,200
c the biggest bugs that people mention

00:24:53,919 --> 00:24:57,039
are memory leaks

00:24:55,200 --> 00:24:58,840
that because it's not in c plus plus

00:24:57,039 --> 00:25:02,000
anymore um because of

00:24:58,840 --> 00:25:02,480
raii and memory leaks essentially is not

00:25:02,000 --> 00:25:04,480
in c

00:25:02,480 --> 00:25:07,360
plus anymore because we have things like

00:25:04,480 --> 00:25:10,000
raii smart pointers and raw pointers

00:25:07,360 --> 00:25:11,600
and which are non-owning references the

00:25:10,000 --> 00:25:12,640
second one they pick is no point to

00:25:11,600 --> 00:25:15,039
dereference

00:25:12,640 --> 00:25:16,240
the third and fourth is use after free

00:25:15,039 --> 00:25:17,360
and double free

00:25:16,240 --> 00:25:18,960
i bet you're wondering what are the

00:25:17,360 --> 00:25:19,600
biggest problems in c plus plus that

00:25:18,960 --> 00:25:22,000
they think

00:25:19,600 --> 00:25:23,120
from this poll the biggest problem in c

00:25:22,000 --> 00:25:25,360
plus plus they claim

00:25:23,120 --> 00:25:27,279
they are no point to do references which

00:25:25,360 --> 00:25:30,000
are now i would claim today

00:25:27,279 --> 00:25:30,640
100 avoidable in terms of unique

00:25:30,000 --> 00:25:33,919
pointers

00:25:30,640 --> 00:25:37,279
containers values references checks and

00:25:33,919 --> 00:25:40,159
you might use the gsl not null or misra

00:25:37,279 --> 00:25:42,080
um as long as you just use no plain

00:25:40,159 --> 00:25:44,320
pointers or c array

00:25:42,080 --> 00:25:45,679
you should be able to get around this in

00:25:44,320 --> 00:25:46,559
terms of memory leaks which was the

00:25:45,679 --> 00:25:50,080
second problem

00:25:46,559 --> 00:25:51,840
think about using raii okay and

00:25:50,080 --> 00:25:53,200
use it they also mentioned use after

00:25:51,840 --> 00:25:55,440
free and double free

00:25:53,200 --> 00:25:56,880
and finally dangling is something that

00:25:55,440 --> 00:25:58,960
still remains a problem

00:25:56,880 --> 00:25:59,919
that is in c plus and we are still

00:25:58,960 --> 00:26:03,600
definitely working on

00:25:59,919 --> 00:26:05,520
it so

00:26:03,600 --> 00:26:07,200
what do people think and what seek what

00:26:05,520 --> 00:26:09,279
do people think what c

00:26:07,200 --> 00:26:11,440
plus is there are many things i kind of

00:26:09,279 --> 00:26:13,279
like to separate out into three ages

00:26:11,440 --> 00:26:14,640
for embedded programmers so that when

00:26:13,279 --> 00:26:16,720
they want to progressively

00:26:14,640 --> 00:26:19,360
uh move into c plus plus they might

00:26:16,720 --> 00:26:21,360
choose to go slowly rather than go

00:26:19,360 --> 00:26:22,799
whole hog into something like the third

00:26:21,360 --> 00:26:23,679
age where we're talking about meta

00:26:22,799 --> 00:26:25,360
programming

00:26:23,679 --> 00:26:27,279
in the first stage it's mostly

00:26:25,360 --> 00:26:28,400
object-oriented style programming

00:26:27,279 --> 00:26:30,400
and that's kind of the things that

00:26:28,400 --> 00:26:32,480
you'll see putting things in containers

00:26:30,400 --> 00:26:34,000
and capsuling their safety

00:26:32,480 --> 00:26:35,520
dan had a great talk yesterday that

00:26:34,000 --> 00:26:38,880
talks about how to build that

00:26:35,520 --> 00:26:39,360
into a memory map and but and then after

00:26:38,880 --> 00:26:42,080
that

00:26:39,360 --> 00:26:43,679
you might or might not move directly

00:26:42,080 --> 00:26:45,440
into the second age where we have things

00:26:43,679 --> 00:26:48,559
like template meta programming

00:26:45,440 --> 00:26:49,520
and these days most of the advice after

00:26:48,559 --> 00:26:51,120
this i'm gonna show

00:26:49,520 --> 00:26:53,120
is that you probably should skip that

00:26:51,120 --> 00:26:56,000
and go directly to the third age

00:26:53,120 --> 00:26:57,760
so today the modern c plus with second

00:26:56,000 --> 00:26:59,919
and third age there's deterministic

00:26:57,760 --> 00:27:03,440
object lifetimes there's scope

00:26:59,919 --> 00:27:05,679
there is templates for variables

00:27:03,440 --> 00:27:07,200
constants there's standard libraries

00:27:05,679 --> 00:27:08,320
there are compile time programming and

00:27:07,200 --> 00:27:10,480
flexibility

00:27:08,320 --> 00:27:12,159
there's type safety at compile time we

00:27:10,480 --> 00:27:15,760
have constexpr and constant

00:27:12,159 --> 00:27:17,039
eval coming and sg7 is rapidly pushing

00:27:15,760 --> 00:27:17,679
more of the envelopes of meta

00:27:17,039 --> 00:27:19,760
programming

00:27:17,679 --> 00:27:20,799
where programming doesn't look like it's

00:27:19,760 --> 00:27:22,799
a template

00:27:20,799 --> 00:27:25,200
there's there are no no angle brackets

00:27:22,799 --> 00:27:27,120
in sight and sg-14 is working with

00:27:25,200 --> 00:27:27,600
embedded and load latency to improve

00:27:27,120 --> 00:27:30,559
that

00:27:27,600 --> 00:27:33,279
as well as potentially adding safety to

00:27:30,559 --> 00:27:33,279
sg12

00:27:33,600 --> 00:27:38,240
so comparing c and c plus plus the way i

00:27:35,679 --> 00:27:40,000
think about the difference is that in c

00:27:38,240 --> 00:27:41,760
the programmer takes and has full

00:27:40,000 --> 00:27:43,760
responsibility

00:27:41,760 --> 00:27:45,120
it has a limited type system and the

00:27:43,760 --> 00:27:47,360
conventions rule

00:27:45,120 --> 00:27:48,480
so it has basically called simple code

00:27:47,360 --> 00:27:50,640
generations

00:27:48,480 --> 00:27:52,000
it has single global scope except in

00:27:50,640 --> 00:27:53,520
local variables

00:27:52,000 --> 00:27:55,600
it might have arbitrary memory

00:27:53,520 --> 00:27:57,919
interpretations through casting

00:27:55,600 --> 00:28:00,720
it might have undefined behaviors for

00:27:57,919 --> 00:28:02,960
optimizing capabilities

00:28:00,720 --> 00:28:05,039
for c plus plus i would say that the

00:28:02,960 --> 00:28:05,919
compiler generally can guarantee tight

00:28:05,039 --> 00:28:07,520
correctness

00:28:05,919 --> 00:28:10,080
and can give you efficient code

00:28:07,520 --> 00:28:11,679
generation and optimizations

00:28:10,080 --> 00:28:13,279
it could have it has a very effective

00:28:11,679 --> 00:28:14,720
standard library though some of that you

00:28:13,279 --> 00:28:15,200
might not be able to use i'll talk about

00:28:14,720 --> 00:28:17,279
that

00:28:15,200 --> 00:28:19,600
it's a multi-paradigm language but it

00:28:17,279 --> 00:28:19,919
does inherit holes from c compatibility

00:28:19,600 --> 00:28:22,320
which

00:28:19,919 --> 00:28:25,919
iso c plus plus is trying to erase by

00:28:22,320 --> 00:28:25,919
substituting with safer features

00:28:28,080 --> 00:28:32,399
so it's a bit of it's definitely a

00:28:29,919 --> 00:28:35,200
change in thinking for the most part

00:28:32,399 --> 00:28:36,640
c and c plus plus use static data types

00:28:35,200 --> 00:28:39,120
so that is the case where

00:28:36,640 --> 00:28:40,320
an object's declaration determines its

00:28:39,120 --> 00:28:43,679
static type

00:28:40,320 --> 00:28:45,600
so here in end n is a signed integer

00:28:43,679 --> 00:28:46,720
a double d d is a double position

00:28:45,600 --> 00:28:49,360
floating point

00:28:46,720 --> 00:28:49,760
char star p p is a pointer to character

00:28:49,360 --> 00:28:51,279
so an

00:28:49,760 --> 00:28:53,039
object's static type and an object

00:28:51,279 --> 00:28:55,200
static type doesn't change

00:28:53,039 --> 00:28:56,559
during program execution it doesn't

00:28:55,200 --> 00:28:57,120
matter what you try to store into the

00:28:56,559 --> 00:29:02,080
object

00:28:57,120 --> 00:29:03,840
the type won't change this is important

00:29:02,080 --> 00:29:05,120
in terms of thinking about what's a data

00:29:03,840 --> 00:29:07,679
type

00:29:05,120 --> 00:29:09,760
in c plus plus unlike c a data type is a

00:29:07,679 --> 00:29:12,000
bundle of compile time properties

00:29:09,760 --> 00:29:13,520
that includes the size and alignment a

00:29:12,000 --> 00:29:17,600
set of valid values

00:29:13,520 --> 00:29:19,679
and then a set of permitted operations

00:29:17,600 --> 00:29:22,080
so in the data type like on a typical

00:29:19,679 --> 00:29:24,799
32-bit processor a type in has

00:29:22,080 --> 00:29:26,559
size and alignment of four bytes it has

00:29:24,799 --> 00:29:28,480
a value from this very small negative

00:29:26,559 --> 00:29:30,720
number to this very large negative

00:29:28,480 --> 00:29:33,360
large positive number inclusive and in

00:29:30,720 --> 00:29:35,760
the intervals it only picks the integers

00:29:33,360 --> 00:29:37,360
in terms of operation this is the this

00:29:35,760 --> 00:29:40,159
is one of the key point

00:29:37,360 --> 00:29:42,080
it allows these these particular unary

00:29:40,159 --> 00:29:46,320
and binary operations

00:29:42,080 --> 00:29:49,360
so what's so special about that well

00:29:46,320 --> 00:29:50,960
it's about more about what it can't do a

00:29:49,360 --> 00:29:53,760
data type can do

00:29:50,960 --> 00:29:54,320
is what's what's important here here an

00:29:53,760 --> 00:29:56,240
integer

00:29:54,320 --> 00:29:58,559
cannot do indirections like it's a

00:29:56,240 --> 00:29:59,120
pointer it can't do member selection it

00:29:58,559 --> 00:30:01,440
can't do

00:29:59,120 --> 00:30:02,320
calls like like a function and this is a

00:30:01,440 --> 00:30:04,720
huge

00:30:02,320 --> 00:30:06,640
difference between c and c plus plus c

00:30:04,720 --> 00:30:08,640
plus is going to reject at compile

00:30:06,640 --> 00:30:12,799
compile time all these questionable

00:30:08,640 --> 00:30:12,799
operations that c is going to accept

00:30:15,039 --> 00:30:18,880
so to summarize in c you the programmer

00:30:18,399 --> 00:30:21,039
takes

00:30:18,880 --> 00:30:22,640
and has full responsibility there's just

00:30:21,039 --> 00:30:23,600
no runtime checks provided by the

00:30:22,640 --> 00:30:25,600
compiler

00:30:23,600 --> 00:30:27,520
um so you can have no dangling point of

00:30:25,600 --> 00:30:29,919
references out of bound array

00:30:27,520 --> 00:30:31,600
arithmetic overflow errors it is your

00:30:29,919 --> 00:30:32,720
responsibility to acquire and release

00:30:31,600 --> 00:30:35,360
resources

00:30:32,720 --> 00:30:36,000
and check for errors doing so so doing

00:30:35,360 --> 00:30:39,360
things like

00:30:36,000 --> 00:30:41,679
malloc um open create sockets

00:30:39,360 --> 00:30:43,120
or fork and the compiler basically

00:30:41,679 --> 00:30:44,720
trusts your typecast

00:30:43,120 --> 00:30:47,279
and so i understand why the

00:30:44,720 --> 00:30:50,480
attractiveness to see yes this gives you

00:30:47,279 --> 00:30:52,399
with great power but it obviously

00:30:50,480 --> 00:30:53,679
um puts a great deal of responsibility

00:30:52,399 --> 00:30:56,399
on you

00:30:53,679 --> 00:30:56,960
in c the conventions rule so your

00:30:56,399 --> 00:30:59,440
strings

00:30:56,960 --> 00:31:00,399
it's always these uh non-terminated byte

00:30:59,440 --> 00:31:03,600
strings that's

00:31:00,399 --> 00:31:04,320
um you literals are basically char rays

00:31:03,600 --> 00:31:06,000
um

00:31:04,320 --> 00:31:07,679
string x-axis functions have

00:31:06,000 --> 00:31:10,880
inconsistent conventions

00:31:07,679 --> 00:31:13,120
like string and copy and string n cats

00:31:10,880 --> 00:31:14,080
the caller might need to free allocated

00:31:13,120 --> 00:31:16,480
memory

00:31:14,080 --> 00:31:18,640
okay and the caller definitely need to

00:31:16,480 --> 00:31:21,360
provide large enough buffer

00:31:18,640 --> 00:31:22,080
like get s or s print f and the

00:31:21,360 --> 00:31:23,760
functions

00:31:22,080 --> 00:31:27,120
might have global state like static

00:31:23,760 --> 00:31:27,120
variables like string toke

00:31:28,000 --> 00:31:32,399
c also has a limited type system it has

00:31:30,559 --> 00:31:34,240
implicit numeric conversions

00:31:32,399 --> 00:31:35,519
um that are intricate rules for integral

00:31:34,240 --> 00:31:36,960
promotions

00:31:35,519 --> 00:31:38,720
that are silent truncations and

00:31:36,960 --> 00:31:40,559
expansions um they might have

00:31:38,720 --> 00:31:43,840
undetectable

00:31:40,559 --> 00:31:44,799
overflow and elum types are just casts

00:31:43,840 --> 00:31:46,960
and ins

00:31:44,799 --> 00:31:47,919
and there's also array to point to decay

00:31:46,960 --> 00:31:49,840
in c's

00:31:47,919 --> 00:31:51,120
finally there's type pruning and casts

00:31:49,840 --> 00:31:53,279
are almost unlimited

00:31:51,120 --> 00:31:54,880
a type depth doesn't define a new type

00:31:53,279 --> 00:31:56,320
but struct and array definitions

00:31:54,880 --> 00:31:58,399
construct new types

00:31:56,320 --> 00:32:00,799
and voice star is a generic parameter

00:31:58,399 --> 00:32:02,159
type now i know there are questions

00:32:00,799 --> 00:32:05,600
and i'm going to address the questions

00:32:02,159 --> 00:32:05,600
at the end of the talk thank you

00:32:07,440 --> 00:32:10,720
so the problems i see as a language for

00:32:09,600 --> 00:32:13,440
larger systems

00:32:10,720 --> 00:32:14,640
is that it gets even worse in terms of

00:32:13,440 --> 00:32:17,519
the limited scoping

00:32:14,640 --> 00:32:18,399
there's one level of global scopes of

00:32:17,519 --> 00:32:20,480
global names

00:32:18,399 --> 00:32:21,600
and you use macros for generosity so

00:32:20,480 --> 00:32:24,480
there's no overloads

00:32:21,600 --> 00:32:26,480
no namespace pollution reuse limitation

00:32:24,480 --> 00:32:27,600
and pretty strange naming conventions in

00:32:26,480 --> 00:32:29,760
my opinion

00:32:27,600 --> 00:32:31,440
there are many undefined implementation

00:32:29,760 --> 00:32:32,640
behaviors often that are not well

00:32:31,440 --> 00:32:36,399
understood

00:32:32,640 --> 00:32:37,919
um pointers are essentially required

00:32:36,399 --> 00:32:39,519
everywhere and cannot easily be

00:32:37,919 --> 00:32:43,840
distinguished in terms of validity

00:32:39,519 --> 00:32:43,840
ownership and lifetime

00:32:46,720 --> 00:32:50,640
so why use c plus plus and instead of c

00:32:49,679 --> 00:32:52,880
well

00:32:50,640 --> 00:32:55,039
in c plus by contrast it has a

00:32:52,880 --> 00:32:56,240
deterministic object like lifetime no

00:32:55,039 --> 00:33:00,320
more resource leaks

00:32:56,240 --> 00:33:03,120
since c plus 11 introduced um

00:33:00,320 --> 00:33:03,919
transfer of ownership semantics aka move

00:33:03,120 --> 00:33:07,440
semantics

00:33:03,919 --> 00:33:08,799
and unique pointer there's strong user

00:33:07,440 --> 00:33:11,440
defined types like

00:33:08,799 --> 00:33:12,799
that are distinguished and encapsulates

00:33:11,440 --> 00:33:14,960
like so that you can have no one

00:33:12,799 --> 00:33:17,039
unwanted conversions or narrowing

00:33:14,960 --> 00:33:19,120
distinguishing parameters to avoid long

00:33:17,039 --> 00:33:21,120
calls and enables overloading and

00:33:19,120 --> 00:33:22,960
template argument deductions

00:33:21,120 --> 00:33:24,960
in the standard library you have there's

00:33:22,960 --> 00:33:26,399
no more need to debug handwritten loops

00:33:24,960 --> 00:33:28,159
you should use algorithms

00:33:26,399 --> 00:33:30,399
there's no more need to manage memory

00:33:28,159 --> 00:33:32,320
using containers like student

00:33:30,399 --> 00:33:34,399
vector of t or stitch string though

00:33:32,320 --> 00:33:35,679
standard like we do have a caveat which

00:33:34,399 --> 00:33:36,880
i will mention later on

00:33:35,679 --> 00:33:38,960
in terms of the fact that they do use

00:33:36,880 --> 00:33:41,120
the heat and in embedded programming

00:33:38,960 --> 00:33:43,519
they prohibit the use of the heap

00:33:41,120 --> 00:33:45,519
so there's more efficient programming

00:33:43,519 --> 00:33:49,200
less explicit and more efficient code

00:33:45,519 --> 00:33:49,200
which are better optimizable

00:33:50,159 --> 00:33:53,279
more details about why you see plus plus

00:33:51,919 --> 00:33:54,960
instead of c you can instead

00:33:53,279 --> 00:33:56,720
there's encapsulation of dirty system

00:33:54,960 --> 00:33:59,120
details like parameterization

00:33:56,720 --> 00:34:01,039
of system dependencies there's a strict

00:33:59,120 --> 00:34:02,080
type system for compile time safety i

00:34:01,039 --> 00:34:04,000
talked about that

00:34:02,080 --> 00:34:06,240
there's no need for plane pointers or

00:34:04,000 --> 00:34:07,760
rays or explicit memory management

00:34:06,240 --> 00:34:09,760
and this reasonably efficient code

00:34:07,760 --> 00:34:11,040
generation especially through templates

00:34:09,760 --> 00:34:12,079
and things like return value

00:34:11,040 --> 00:34:13,839
optimization

00:34:12,079 --> 00:34:15,760
and there's no overhead with the return

00:34:13,839 --> 00:34:17,440
by value

00:34:15,760 --> 00:34:19,760
so let's take a look at modern c plus

00:34:17,440 --> 00:34:22,079
plus embedded c plus plus programming is

00:34:19,760 --> 00:34:23,599
and sg14 in the remaining time that we

00:34:22,079 --> 00:34:26,879
have

00:34:23,599 --> 00:34:28,320
so how do you change a c code base to c

00:34:26,879 --> 00:34:30,079
plus plus well there are two

00:34:28,320 --> 00:34:32,240
pretty much two ways that i've observed

00:34:30,079 --> 00:34:34,079
um and have helped people with

00:34:32,240 --> 00:34:36,159
um there's one that's switching in one

00:34:34,079 --> 00:34:37,839
shot and then there's also gradual

00:34:36,159 --> 00:34:39,040
adoptions which i'll walk through some

00:34:37,839 --> 00:34:40,560
of the steps

00:34:39,040 --> 00:34:42,159
so let's say you want to switch in one

00:34:40,560 --> 00:34:43,599
shot um so

00:34:42,159 --> 00:34:45,040
if you do that they're hard to see plus

00:34:43,599 --> 00:34:46,960
plus features you probably might want to

00:34:45,040 --> 00:34:49,359
avoid things like rtti

00:34:46,960 --> 00:34:51,760
usually heap exceptions standard

00:34:49,359 --> 00:34:53,760
containers except unique array and

00:34:51,760 --> 00:34:55,119
unique pointer and standard array and

00:34:53,760 --> 00:34:56,560
floating point let me talk about what

00:34:55,119 --> 00:34:59,520
you want which these might mean

00:34:56,560 --> 00:34:59,520
okay so

00:35:00,000 --> 00:35:03,520
so there are a lot there's things in the

00:35:01,839 --> 00:35:05,599
c-plus plus library that you have to be

00:35:03,520 --> 00:35:06,480
aware of like extra space allocated on

00:35:05,599 --> 00:35:08,400
the heap

00:35:06,480 --> 00:35:10,640
um the integer calculations are done

00:35:08,400 --> 00:35:11,920
using int floating point calculations

00:35:10,640 --> 00:35:13,920
are done in double

00:35:11,920 --> 00:35:15,280
their special situations are reported by

00:35:13,920 --> 00:35:18,560
exceptions and

00:35:15,280 --> 00:35:21,200
caching determines speed so

00:35:18,560 --> 00:35:24,960
avoid linked lists so all that matters

00:35:21,200 --> 00:35:26,320
is basically amortized complexity

00:35:24,960 --> 00:35:28,800
the problem with the heap let me talk

00:35:26,320 --> 00:35:30,480
about that the heap is flexible for the

00:35:28,800 --> 00:35:32,000
amount of data at the cost of under

00:35:30,480 --> 00:35:34,560
predictability and runtime

00:35:32,000 --> 00:35:35,520
and fragmentation due to the maximum

00:35:34,560 --> 00:35:37,520
memory available

00:35:35,520 --> 00:35:39,680
and heat and small miss small embedded

00:35:37,520 --> 00:35:41,920
systems don't match well

00:35:39,680 --> 00:35:44,000
they do generally do a rigidly

00:35:41,920 --> 00:35:46,400
prescribed task with fixed data they

00:35:44,000 --> 00:35:49,040
might need to meet real-time constraints

00:35:46,400 --> 00:35:49,760
and it has to be met always and not just

00:35:49,040 --> 00:35:51,440
sometimes

00:35:49,760 --> 00:35:53,040
so in that case it's probably better to

00:35:51,440 --> 00:35:56,839
use global allocations

00:35:53,040 --> 00:35:58,320
or fixed size pool or fixed size

00:35:56,839 --> 00:35:59,520
container

00:35:58,320 --> 00:36:01,520
the problem with the photo floating

00:35:59,520 --> 00:36:02,480
point i mentioned this is useful when a

00:36:01,520 --> 00:36:04,240
wide

00:36:02,480 --> 00:36:06,079
dynamic range is needed but small

00:36:04,240 --> 00:36:06,560
embedded applications often have very

00:36:06,079 --> 00:36:08,800
small

00:36:06,560 --> 00:36:10,320
well-known ranges like small micro

00:36:08,800 --> 00:36:12,000
controllers often don't have floating

00:36:10,320 --> 00:36:14,560
point units just a software floating

00:36:12,000 --> 00:36:15,760
point which resides in the rom and is

00:36:14,560 --> 00:36:17,440
painfully slow

00:36:15,760 --> 00:36:19,359
this is not true for large and better

00:36:17,440 --> 00:36:21,280
systems so this rule is not necessarily

00:36:19,359 --> 00:36:22,720
the case for all embedded systems in

00:36:21,280 --> 00:36:23,520
these cases it's better to use a

00:36:22,720 --> 00:36:25,520
template

00:36:23,520 --> 00:36:27,599
with a default parameter of double which

00:36:25,520 --> 00:36:30,079
can be used if there is a floating point

00:36:27,599 --> 00:36:30,079
hardware

00:36:31,520 --> 00:36:36,640
the problem with exceptions

00:36:34,720 --> 00:36:39,040
well exception is basically used to

00:36:36,640 --> 00:36:42,720
handle local problems that requires a

00:36:39,040 --> 00:36:46,960
global response and often uses the heap

00:36:42,720 --> 00:36:48,320
making it slow in the non-happy path

00:36:46,960 --> 00:36:50,560
and predictable you're wondering what

00:36:48,320 --> 00:36:52,160
the non-happy path is

00:36:50,560 --> 00:36:54,000
happy path is when there is no

00:36:52,160 --> 00:36:55,520
exceptions and the the code run all the

00:36:54,000 --> 00:36:57,520
way through the non-happy path

00:36:55,520 --> 00:36:59,839
is when some and there's when there's an

00:36:57,520 --> 00:37:01,440
exception so small embedded systems have

00:36:59,839 --> 00:37:03,839
originally defined tasks with no

00:37:01,440 --> 00:37:06,960
exceptions just different situations

00:37:03,839 --> 00:37:08,560
and no heap in these cases you're better

00:37:06,960 --> 00:37:11,520
off to not use exceptions

00:37:08,560 --> 00:37:12,720
until its implementation uses the stack

00:37:11,520 --> 00:37:15,280
instead of the heap

00:37:12,720 --> 00:37:16,000
this is an sg14 project where we notice

00:37:15,280 --> 00:37:18,079
that there's

00:37:16,000 --> 00:37:19,680
nothing in the standard that stops you

00:37:18,079 --> 00:37:22,400
from implementing exceptions

00:37:19,680 --> 00:37:23,440
from by using the stack a stacked base

00:37:22,400 --> 00:37:25,280
exception

00:37:23,440 --> 00:37:26,480
it's just that traditionally we have

00:37:25,280 --> 00:37:28,800
always implemented

00:37:26,480 --> 00:37:32,240
exceptions on the heap which generates

00:37:28,800 --> 00:37:35,520
dynamic memory allocations as well as

00:37:32,240 --> 00:37:36,000
multiple large table generations which

00:37:35,520 --> 00:37:38,560
causes

00:37:36,000 --> 00:37:40,640
the non-determinism so we're trying to

00:37:38,560 --> 00:37:43,680
fix we're trying to improve that

00:37:40,640 --> 00:37:45,440
basically i want to conclude that c plus

00:37:43,680 --> 00:37:46,880
needs both error code and exceptions

00:37:45,440 --> 00:37:49,359
there are places where you need error

00:37:46,880 --> 00:37:52,880
codes and there's no shame in using them

00:37:49,359 --> 00:37:54,480
okay um there are places for exceptions

00:37:52,880 --> 00:37:56,079
that you can't get away from like

00:37:54,480 --> 00:37:58,560
constructive failures

00:37:56,079 --> 00:38:00,240
like um like operator failure like

00:37:58,560 --> 00:38:02,000
operator failures like callbacks

00:38:00,240 --> 00:38:03,520
there's the only way to report error

00:38:02,000 --> 00:38:04,880
through those is through exceptions

00:38:03,520 --> 00:38:06,720
but there are many other places where

00:38:04,880 --> 00:38:08,400
error code is useful for

00:38:06,720 --> 00:38:10,480
what you have a space restrictions like

00:38:08,400 --> 00:38:11,200
small systems where exceptions can

00:38:10,480 --> 00:38:12,640
support

00:38:11,200 --> 00:38:14,800
uh support can crowd out the

00:38:12,640 --> 00:38:16,000
functionality where you or you have a

00:38:14,800 --> 00:38:18,320
hard real-time system

00:38:16,000 --> 00:38:19,200
and we don't have tools that you know um

00:38:18,320 --> 00:38:23,359
so

00:38:19,200 --> 00:38:25,200
exceptions um can cause non-determinism

00:38:23,359 --> 00:38:27,440
so the gradual the next strategy i want

00:38:25,200 --> 00:38:29,280
to talk about is the gradual adoption

00:38:27,440 --> 00:38:30,720
strategy which is what most people

00:38:29,280 --> 00:38:32,720
should think about

00:38:30,720 --> 00:38:34,400
because c is mostly just a subset of c

00:38:32,720 --> 00:38:35,280
plus plus with a few exceptions you can

00:38:34,400 --> 00:38:38,079
find what the

00:38:35,280 --> 00:38:38,640
compatibility is i think in wikipedia as

00:38:38,079 --> 00:38:41,520
well as

00:38:38,640 --> 00:38:42,320
iso cpp.org you can compile your c

00:38:41,520 --> 00:38:44,160
source with c

00:38:42,320 --> 00:38:46,000
plus plus as i mentioned before change

00:38:44,160 --> 00:38:48,079
your dot c to dot cpp

00:38:46,000 --> 00:38:49,760
resolve issues with linker naming due to

00:38:48,079 --> 00:38:51,440
the name angling of c plus plus

00:38:49,760 --> 00:38:52,960
watch out for voice start conversion

00:38:51,440 --> 00:38:55,200
errors and change them to the actual

00:38:52,960 --> 00:38:55,200
type

00:38:56,320 --> 00:39:00,240
start going walking through these

00:38:58,720 --> 00:39:02,320
different impact

00:39:00,240 --> 00:39:03,280
strategies so there's a low impact

00:39:02,320 --> 00:39:05,280
strategy that

00:39:03,280 --> 00:39:06,800
that won't disturb the c culture it's

00:39:05,280 --> 00:39:09,760
basically almost c like c

00:39:06,800 --> 00:39:11,119
plus plus there's a medium impact

00:39:09,760 --> 00:39:13,119
strategy that

00:39:11,119 --> 00:39:15,520
you might expect some resistance in your

00:39:13,119 --> 00:39:17,680
crowd and then there's the first age the

00:39:15,520 --> 00:39:19,680
object oriented and stl that's

00:39:17,680 --> 00:39:21,839
starting into modern c plus plus that's

00:39:19,680 --> 00:39:23,599
familiar to c plus plus programmers

00:39:21,839 --> 00:39:25,359
then there's a second age with template

00:39:23,599 --> 00:39:27,680
meta programming that is even more

00:39:25,359 --> 00:39:29,680
modern c plus plus but you need experts

00:39:27,680 --> 00:39:32,560
on hand and i will admit that

00:39:29,680 --> 00:39:34,800
that that without those experts you're

00:39:32,560 --> 00:39:36,960
likely going to go somewhere else

00:39:34,800 --> 00:39:38,640
and then finally skipping past that is

00:39:36,960 --> 00:39:39,599
the third age meta programming using

00:39:38,640 --> 00:39:42,240
constexpr

00:39:39,599 --> 00:39:43,839
and no angle brackets sight so let me

00:39:42,240 --> 00:39:44,720
walk through at least a few of these i

00:39:43,839 --> 00:39:46,000
don't think i'm going to have time to

00:39:44,720 --> 00:39:47,680
walk through all of them because these

00:39:46,000 --> 00:39:48,720
are separate talks in themselves

00:39:47,680 --> 00:39:50,640
and there are other talks that will

00:39:48,720 --> 00:39:51,839
cover those much more nicely so let's

00:39:50,640 --> 00:39:54,320
start with low impact c

00:39:51,839 --> 00:39:55,040
plus features you can use these low

00:39:54,320 --> 00:39:57,680
impact c

00:39:55,040 --> 00:39:58,640
plus features i think without any

00:39:57,680 --> 00:40:01,200
serious

00:39:58,640 --> 00:40:02,720
degradation degradations these are like

00:40:01,200 --> 00:40:03,680
assertions with static asserts and

00:40:02,720 --> 00:40:06,000
titrates

00:40:03,680 --> 00:40:06,960
use c plus plus bull not your own

00:40:06,000 --> 00:40:10,000
boolean

00:40:06,960 --> 00:40:11,760
use brace in it to prevent narrowing use

00:40:10,000 --> 00:40:13,839
unit do unit programming you would

00:40:11,760 --> 00:40:14,480
either user define literals or something

00:40:13,839 --> 00:40:17,359
else

00:40:14,480 --> 00:40:17,839
or templates be fast with generalized

00:40:17,359 --> 00:40:20,400
parts

00:40:17,839 --> 00:40:21,839
use unique pointer that's in that is

00:40:20,400 --> 00:40:24,720
explicit ownerships use

00:40:21,839 --> 00:40:27,040
arrays that is slim and fast use move

00:40:24,720 --> 00:40:29,040
semantics that's a cheap way of moving

00:40:27,040 --> 00:40:30,960
moving perfect forwarding that preserves

00:40:29,040 --> 00:40:34,240
l values and r values

00:40:30,960 --> 00:40:36,560
use default and delete it use the

00:40:34,240 --> 00:40:37,520
no discard angle square bracket

00:40:36,560 --> 00:40:40,400
attributes

00:40:37,520 --> 00:40:41,040
use cons correctness use binary literals

00:40:40,400 --> 00:40:44,480
use

00:40:41,040 --> 00:40:45,599
the quote the separator in literals use

00:40:44,480 --> 00:40:48,400
namespace

00:40:45,599 --> 00:40:49,359
use enum class use by reference

00:40:48,400 --> 00:40:51,760
parameters

00:40:49,359 --> 00:40:54,000
you can re-evaluate a compile time with

00:40:51,760 --> 00:40:55,680
cons expert instead of macros

00:40:54,000 --> 00:40:59,040
use if context where you notice that

00:40:55,680 --> 00:41:01,200
these features span c plus plus 11 14 17

00:40:59,040 --> 00:41:02,160
and into 20. so there are lots of

00:41:01,200 --> 00:41:05,040
features in

00:41:02,160 --> 00:41:06,240
c plus they can use as a low impact way

00:41:05,040 --> 00:41:07,359
um

00:41:06,240 --> 00:41:08,720
i'm just going to go through some of

00:41:07,359 --> 00:41:10,240
these i'm not going to go through all of

00:41:08,720 --> 00:41:10,960
these we probably don't have time for

00:41:10,240 --> 00:41:14,079
all of that

00:41:10,960 --> 00:41:17,359
but yeah bracing it prevents narrowing

00:41:14,079 --> 00:41:20,880
um here we have a double and you can say

00:41:17,359 --> 00:41:24,000
in a is a sign at this this double

00:41:20,880 --> 00:41:26,160
um and that's okay okay

00:41:24,000 --> 00:41:28,400
um you might use the function

00:41:26,160 --> 00:41:30,480
initialization syntax but if you use

00:41:28,400 --> 00:41:32,240
um brace initialization that's an error

00:41:30,480 --> 00:41:36,160
that's non-compliant right away

00:41:32,240 --> 00:41:38,560
that's a good thing for us okay

00:41:36,160 --> 00:41:40,720
you might use static assert um and type

00:41:38,560 --> 00:41:42,560
trades type trays basically perform at

00:41:40,720 --> 00:41:44,480
compile time type information type

00:41:42,560 --> 00:41:46,079
comparison and type modification

00:41:44,480 --> 00:41:47,920
i saw really good talk yesterday by

00:41:46,079 --> 00:41:49,040
jordy about titrates i thought it was

00:41:47,920 --> 00:41:51,839
really nice

00:41:49,040 --> 00:41:54,160
you can use static assert to validate

00:41:51,839 --> 00:41:56,400
the expressions at compile time

00:41:54,160 --> 00:41:58,720
okay and some examples on the right that

00:41:56,400 --> 00:42:00,560
shows that

00:41:58,720 --> 00:42:02,079
you can use user defined literal i'm

00:42:00,560 --> 00:42:03,920
really proud of this feature because i i

00:42:02,079 --> 00:42:06,160
kind of created it myself among

00:42:03,920 --> 00:42:08,000
with many other peoples to help um with

00:42:06,160 --> 00:42:08,960
this i'm just demonstrating here that

00:42:08,000 --> 00:42:11,040
you can use a

00:42:08,960 --> 00:42:12,880
using a syntax with a built-in literal

00:42:11,040 --> 00:42:14,960
with an underscore and a suffix

00:42:12,880 --> 00:42:16,480
and that allows you to create things

00:42:14,960 --> 00:42:17,920
like actually that should be a binary

00:42:16,480 --> 00:42:18,960
literal one zero one zero one so

00:42:17,920 --> 00:42:20,640
underscore b

00:42:18,960 --> 00:42:23,839
um you can create a floating point

00:42:20,640 --> 00:42:25,920
literal that is like 123.45

00:42:23,839 --> 00:42:26,960
underscore kilometer and this will be

00:42:25,920 --> 00:42:30,319
tight checked because

00:42:26,960 --> 00:42:32,400
these have specific um literal types

00:42:30,319 --> 00:42:34,480
you can create a string literal you can

00:42:32,400 --> 00:42:38,800
also create a character literal

00:42:34,480 --> 00:42:39,599
okay you can generally you can generate

00:42:38,800 --> 00:42:42,240
fast

00:42:39,599 --> 00:42:44,079
generalized parts today which are very

00:42:42,240 --> 00:42:44,880
similar to what c has these has to be

00:42:44,079 --> 00:42:46,400
trivial

00:42:44,880 --> 00:42:48,720
they have to have standard layout

00:42:46,400 --> 00:42:50,319
members have standard layout they have

00:42:48,720 --> 00:42:52,160
to have members and base classes that

00:42:50,319 --> 00:42:54,400
are not also three parts

00:42:52,160 --> 00:42:56,560
so they offer fast manipulation like a

00:42:54,400 --> 00:42:57,440
c-struct a rays of parts can be copied

00:42:56,560 --> 00:43:00,800
by block

00:42:57,440 --> 00:43:02,880
and they can be statically initialized

00:43:00,800 --> 00:43:04,560
which takes away some of the worst

00:43:02,880 --> 00:43:05,760
problems that comes with dynamic

00:43:04,560 --> 00:43:09,040
initializations

00:43:05,760 --> 00:43:10,400
in the original types you can you can

00:43:09,040 --> 00:43:12,400
have heterogeneous

00:43:10,400 --> 00:43:14,319
you can access fast and slim standard

00:43:12,400 --> 00:43:16,160
arrays using heterogeneous or sorry

00:43:14,319 --> 00:43:18,480
homogeneous containers of fixed

00:43:16,160 --> 00:43:20,000
fixed length um that's combines the

00:43:18,480 --> 00:43:20,800
performance of a c array with the

00:43:20,000 --> 00:43:22,640
interface of a c

00:43:20,800 --> 00:43:24,400
plus plus vector with no heap

00:43:22,640 --> 00:43:26,800
allocations now the problem with arrays

00:43:24,400 --> 00:43:28,079
is not really a standard c-plus plus

00:43:26,800 --> 00:43:29,680
container type and has some

00:43:28,079 --> 00:43:30,160
characteristic that makes it not quite

00:43:29,680 --> 00:43:32,240
like that

00:43:30,160 --> 00:43:33,520
but if you're doing uh interface with c

00:43:32,240 --> 00:43:35,280
it probably doesn't matter

00:43:33,520 --> 00:43:36,640
today we're beginning to show to come up

00:43:35,280 --> 00:43:38,560
with things that are that are much

00:43:36,640 --> 00:43:39,440
better that behaves like a standard

00:43:38,560 --> 00:43:41,520
container type

00:43:39,440 --> 00:43:43,440
they're called spans and and

00:43:41,520 --> 00:43:45,280
multi-dimensional spans coming that will

00:43:43,440 --> 00:43:47,119
help in this particular direction as

00:43:45,280 --> 00:43:48,880
well

00:43:47,119 --> 00:43:51,040
you can use move semantics for cheap

00:43:48,880 --> 00:43:52,319
moving cheap moving instead of expensive

00:43:51,040 --> 00:43:54,319
copying

00:43:52,319 --> 00:43:56,240
so that you can improve your performance

00:43:54,319 --> 00:43:58,640
there's no memory allocation or the

00:43:56,240 --> 00:44:00,240
allocation it's like a pointer swizzle

00:43:58,640 --> 00:44:02,720
so it's very predictable

00:44:00,240 --> 00:44:03,920
you can implement safe move only types

00:44:02,720 --> 00:44:07,200
with unique pointers

00:44:03,920 --> 00:44:08,480
files locks and tasks

00:44:07,200 --> 00:44:10,160
i'm going through these fairly fast

00:44:08,480 --> 00:44:11,760
because i know that you can certainly

00:44:10,160 --> 00:44:13,839
learn a lot more about these if you're

00:44:11,760 --> 00:44:15,839
interested using it for your project

00:44:13,839 --> 00:44:18,160
um through many of the the resources

00:44:15,839 --> 00:44:18,720
talks like and or just looking at cpp

00:44:18,160 --> 00:44:20,640
reference

00:44:18,720 --> 00:44:22,160
so that you know that these can be used

00:44:20,640 --> 00:44:24,560
without without

00:44:22,160 --> 00:44:26,079
degradations you can preserve l value

00:44:24,560 --> 00:44:28,319
with perfect forwarding

00:44:26,079 --> 00:44:29,920
um so you know you can basically pass

00:44:28,319 --> 00:44:31,839
the arguments while preserving the l

00:44:29,920 --> 00:44:32,480
value-ness or the r-value-ness of the

00:44:31,839 --> 00:44:34,000
arguments

00:44:32,480 --> 00:44:36,400
and the use cases for these are things

00:44:34,000 --> 00:44:39,520
like factory functions or constructors

00:44:36,400 --> 00:44:40,240
you can chain a set of move semantics

00:44:39,520 --> 00:44:43,440
forwarding

00:44:40,240 --> 00:44:43,440
of move only types

00:44:43,520 --> 00:44:47,200
you can certainly also enable explicit

00:44:45,520 --> 00:44:49,119
ownership with standard you would

00:44:47,200 --> 00:44:50,640
stand standard unique pointer which

00:44:49,119 --> 00:44:52,240
gives you explicit ownership

00:44:50,640 --> 00:44:54,560
these are only movable type and they

00:44:52,240 --> 00:44:56,720
support arrays so you can create

00:44:54,560 --> 00:44:58,160
and forget them they're minimal space

00:44:56,720 --> 00:45:00,000
and time overhead

00:44:58,160 --> 00:45:03,280
and so then they support special

00:45:00,000 --> 00:45:03,280
allocation strategies

00:45:03,440 --> 00:45:08,480
you can do use cons correctness very

00:45:05,760 --> 00:45:11,680
quickly at cons is basically read-only

00:45:08,480 --> 00:45:12,800
so in c a b c d string is a non-cons

00:45:11,680 --> 00:45:15,760
char pointer

00:45:12,800 --> 00:45:16,319
whereas in c plus plus um is going to

00:45:15,760 --> 00:45:18,800
cause an

00:45:16,319 --> 00:45:21,200
error while in c that is going to be

00:45:18,800 --> 00:45:21,200
okay

00:45:21,599 --> 00:45:26,319
you can use binary literals this makes

00:45:24,319 --> 00:45:28,800
code a lot more readable

00:45:26,319 --> 00:45:30,880
okay and the base you choose convey a

00:45:28,800 --> 00:45:33,359
lot of information about the value so

00:45:30,880 --> 00:45:34,480
something like zero b one zero one one i

00:45:33,359 --> 00:45:36,160
know you could have done it

00:45:34,480 --> 00:45:37,839
do you know earlier i showed that you

00:45:36,160 --> 00:45:39,599
can use underscore b but the committee

00:45:37,839 --> 00:45:42,720
decided to go with a standard

00:45:39,599 --> 00:45:44,000
uh way of of identifying binary literals

00:45:42,720 --> 00:45:46,079
so by putting a zero b

00:45:44,000 --> 00:45:48,079
prefix on it just like we do with zero

00:45:46,079 --> 00:45:49,680
xlb that's a hex value

00:45:48,079 --> 00:45:52,160
but not a quantity it's not for

00:45:49,680 --> 00:45:55,040
calculation whereas 11 is just a

00:45:52,160 --> 00:45:56,880
quantity of 11.

00:45:55,040 --> 00:45:58,839
you can do cons oops this is a

00:45:56,880 --> 00:46:00,720
duplicated slide unless i've gone

00:45:58,839 --> 00:46:02,880
backwards

00:46:00,720 --> 00:46:04,240
okay you can use digit separators in

00:46:02,880 --> 00:46:05,920
literals so

00:46:04,240 --> 00:46:07,440
numbers are hard to read with a large

00:46:05,920 --> 00:46:08,960
number of digits and you might think

00:46:07,440 --> 00:46:12,319
that you can separate them

00:46:08,960 --> 00:46:14,000
by using the multiplication but we don't

00:46:12,319 --> 00:46:16,720
know if this is going to be evaluated

00:46:14,000 --> 00:46:19,520
as a constant expression so why not use

00:46:16,720 --> 00:46:21,359
one apostrophe zero zero zero like this

00:46:19,520 --> 00:46:22,880
i know that this is not the usual digit

00:46:21,359 --> 00:46:23,520
separator comma that you could have

00:46:22,880 --> 00:46:25,760
wanted

00:46:23,520 --> 00:46:27,520
but we found out during the um the

00:46:25,760 --> 00:46:28,079
design of this that comma cannot be

00:46:27,520 --> 00:46:30,160
placed

00:46:28,079 --> 00:46:31,200
in a way that makes it large readable

00:46:30,160 --> 00:46:33,280
makes it readable by

00:46:31,200 --> 00:46:34,800
mo by compilers and as it turns out

00:46:33,280 --> 00:46:36,640
actually a posture

00:46:34,800 --> 00:46:38,480
apostrophe we found out was act is

00:46:36,640 --> 00:46:39,520
actually used as a digits separated in

00:46:38,480 --> 00:46:41,599
some countries

00:46:39,520 --> 00:46:42,880
i can't remember which one right now you

00:46:41,599 --> 00:46:44,640
can use namespace

00:46:42,880 --> 00:46:46,160
in c style you might use something that

00:46:44,640 --> 00:46:47,520
is like a namespace but because you

00:46:46,160 --> 00:46:49,119
don't have namespace you have to you're

00:46:47,520 --> 00:46:50,480
forced to write something like my lib

00:46:49,119 --> 00:46:52,319
underscore myfunk

00:46:50,480 --> 00:46:53,920
whereas in c plus plus object oriented

00:46:52,319 --> 00:46:55,359
style you would use it as a class so

00:46:53,920 --> 00:46:57,520
that my lip colon called

00:46:55,359 --> 00:46:59,119
my fung but the best i think it's just

00:46:57,520 --> 00:47:01,040
using the name space my lip

00:46:59,119 --> 00:47:02,560
and then calling my fung within that

00:47:01,040 --> 00:47:05,359
name space

00:47:02,560 --> 00:47:06,000
you can do things like enum classes um

00:47:05,359 --> 00:47:08,319
so here

00:47:06,000 --> 00:47:10,079
it's not type saved you have a color but

00:47:08,319 --> 00:47:12,160
that's an enum that has black white

00:47:10,079 --> 00:47:13,280
and red and a chest color and then when

00:47:12,160 --> 00:47:15,520
you want to paint

00:47:13,280 --> 00:47:16,800
by calling the white side you don't

00:47:15,520 --> 00:47:18,880
really know

00:47:16,800 --> 00:47:19,920
there's no error here whereas in a type

00:47:18,880 --> 00:47:22,800
save environment

00:47:19,920 --> 00:47:23,520
you will actually have to say that did

00:47:22,800 --> 00:47:25,599
you just call

00:47:23,520 --> 00:47:27,520
generic white it's a compile error but

00:47:25,599 --> 00:47:28,319
if you call something like chess colon

00:47:27,520 --> 00:47:30,400
colon white

00:47:28,319 --> 00:47:32,079
with a paint we know that's an error but

00:47:30,400 --> 00:47:32,480
whereas if you call color colon colon

00:47:32,079 --> 00:47:36,240
white

00:47:32,480 --> 00:47:39,440
that's okay you can call by reference

00:47:36,240 --> 00:47:41,839
um in the left it's not entirely clear

00:47:39,440 --> 00:47:44,000
whether the star or the plus plus takes

00:47:41,839 --> 00:47:45,520
precedence and binds more tightly to p

00:47:44,000 --> 00:47:47,359
is it the pointer that's being

00:47:45,520 --> 00:47:50,400
incremented or is it is

00:47:47,359 --> 00:47:52,240
is it the value that's incremented the

00:47:50,400 --> 00:47:54,079
thing that's pointed to by the pointer

00:47:52,240 --> 00:47:55,359
on the right it's much clearer using

00:47:54,079 --> 00:47:57,520
reference parameters

00:47:55,359 --> 00:47:59,280
i because the the reference is now

00:47:57,520 --> 00:48:00,400
hidden i know for a fact that it's going

00:47:59,280 --> 00:48:03,680
to be the value

00:48:00,400 --> 00:48:03,680
that's going to be incremented

00:48:03,920 --> 00:48:08,240
so learn to love khan's expert um these

00:48:06,480 --> 00:48:09,680
can be evaluated at compile time they

00:48:08,240 --> 00:48:11,599
can be stored in rom

00:48:09,680 --> 00:48:14,240
like variables functions or user defined

00:48:11,599 --> 00:48:17,440
types most microcontrollers are 4

00:48:14,240 --> 00:48:19,839
to 16 times more flash than ram so flash

00:48:17,440 --> 00:48:21,920
values can't be accidentally overwritten

00:48:19,839 --> 00:48:24,000
they can put everything in flash

00:48:21,920 --> 00:48:26,079
and there's no runtime calculation and

00:48:24,000 --> 00:48:27,520
no floating code point code linkedin

00:48:26,079 --> 00:48:30,559
that's one of the key problems that

00:48:27,520 --> 00:48:30,559
other people might find

00:48:30,720 --> 00:48:34,160
so skipping past that let's go to

00:48:32,240 --> 00:48:36,240
general adoption the

00:48:34,160 --> 00:48:38,240
medium impact features are things like

00:48:36,240 --> 00:48:40,800
using shared ownerships with

00:48:38,240 --> 00:48:42,880
sharepoint overloading default function

00:48:40,800 --> 00:48:44,960
arguments or transparent data types or

00:48:42,880 --> 00:48:46,240
abstract data types for privates

00:48:44,960 --> 00:48:48,319
i'm not going to go through all of these

00:48:46,240 --> 00:48:48,960
but let's talk about pointer the shared

00:48:48,319 --> 00:48:50,640
ownership

00:48:48,960 --> 00:48:52,720
it's for shared ownership it has a

00:48:50,640 --> 00:48:54,960
reference counter and a handle to

00:48:52,720 --> 00:48:56,880
to to the resource it manages the

00:48:54,960 --> 00:48:58,880
reference counter and the resource

00:48:56,880 --> 00:49:00,640
and it and in managing the and this

00:48:58,880 --> 00:49:01,520
helps you to manage overhead in time and

00:49:00,640 --> 00:49:04,079
space

00:49:01,520 --> 00:49:06,640
it saves in memory okay you do have to

00:49:04,079 --> 00:49:09,760
deal with any cycles

00:49:06,640 --> 00:49:11,200
overloading is in c you would deal with

00:49:09,760 --> 00:49:12,160
it as a something like you would have

00:49:11,200 --> 00:49:14,160
different functions

00:49:12,160 --> 00:49:16,400
uh for integer double and strain words

00:49:14,160 --> 00:49:18,319
and c plus plus it's the same function

00:49:16,400 --> 00:49:20,079
that would be past different types and

00:49:18,319 --> 00:49:22,319
that would decide the overloading

00:49:20,079 --> 00:49:24,079
um through overloading there's default

00:49:22,319 --> 00:49:25,440
parameters i'm going to skip past this i

00:49:24,079 --> 00:49:26,640
think most people know what default

00:49:25,440 --> 00:49:28,960
parameter is

00:49:26,640 --> 00:49:30,480
there's transparent data types so here

00:49:28,960 --> 00:49:33,040
what happens is that we notice

00:49:30,480 --> 00:49:34,240
many errors in moving from embedded c

00:49:33,040 --> 00:49:36,480
code to c plus plus

00:49:34,240 --> 00:49:37,599
that they have similar types parameters

00:49:36,480 --> 00:49:40,400
very close by

00:49:37,599 --> 00:49:42,319
so that you have x and y integers here

00:49:40,400 --> 00:49:44,880
and it's very easy to transpose those

00:49:42,319 --> 00:49:46,640
when you're calling a function okay

00:49:44,880 --> 00:49:48,960
it's better in that case to use a struct

00:49:46,640 --> 00:49:49,920
that encapsulates those very nearby

00:49:48,960 --> 00:49:53,119
parameters

00:49:49,920 --> 00:49:56,559
so that you can call um lock

00:49:53,119 --> 00:49:57,119
which um and then incrementing x and y

00:49:56,559 --> 00:49:59,200
by one

00:49:57,119 --> 00:50:00,480
by one for both of them and that makes

00:49:59,200 --> 00:50:04,640
it a lot easier

00:50:00,480 --> 00:50:06,720
to be clear from transposition errors

00:50:04,640 --> 00:50:08,720
you can use abstract data types that

00:50:06,720 --> 00:50:11,760
enables type rich programming i talked

00:50:08,720 --> 00:50:14,000
about that using user defined literals

00:50:11,760 --> 00:50:15,119
so that you know what kind of units that

00:50:14,000 --> 00:50:17,119
you're doing

00:50:15,119 --> 00:50:19,680
so in modern c plus plus you basically

00:50:17,119 --> 00:50:21,040
use head towards object oriented and stl

00:50:19,680 --> 00:50:22,800
that's the next step

00:50:21,040 --> 00:50:25,280
and you can for that you can use class

00:50:22,800 --> 00:50:27,520
versus structs they have very little

00:50:25,280 --> 00:50:29,280
uh difference in terms of cost you can

00:50:27,520 --> 00:50:31,839
use decorators or adapters

00:50:29,280 --> 00:50:32,880
you can use full colon as a way to walk

00:50:31,839 --> 00:50:35,599
through ranges

00:50:32,880 --> 00:50:37,119
you can use autos and destructors now

00:50:35,599 --> 00:50:38,880
one question people always ask is how

00:50:37,119 --> 00:50:41,760
much of the scl can embedded

00:50:38,880 --> 00:50:43,200
systems use unfortunately this is where

00:50:41,760 --> 00:50:46,000
some of the bad news comes

00:50:43,200 --> 00:50:47,280
stl is mostly not usable it's because of

00:50:46,000 --> 00:50:49,280
the heap allocation

00:50:47,280 --> 00:50:50,720
and exception handling in that space

00:50:49,280 --> 00:50:52,720
unless you can prove that it has

00:50:50,720 --> 00:50:55,760
deterministic

00:50:52,720 --> 00:50:58,319
worst case execution time uh results

00:50:55,760 --> 00:51:00,319
um with the only with the exception the

00:50:58,319 --> 00:51:03,599
unique pointer has no overhead

00:51:00,319 --> 00:51:05,440
um and you can also but you can also

00:51:03,599 --> 00:51:06,079
implement by hand things like fixed size

00:51:05,440 --> 00:51:08,319
arrays

00:51:06,079 --> 00:51:10,800
max size vectors or flat map some of

00:51:08,319 --> 00:51:11,520
that is coming through sg14 as well as

00:51:10,800 --> 00:51:13,200
other groups

00:51:11,520 --> 00:51:15,280
so that we can have more of these kinds

00:51:13,200 --> 00:51:16,880
of things that have no heap overhead

00:51:15,280 --> 00:51:18,880
or something like boost intrusive

00:51:16,880 --> 00:51:20,839
container that has a metadata

00:51:18,880 --> 00:51:23,200
as part of the element type and no

00:51:20,839 --> 00:51:25,920
overhead

00:51:23,200 --> 00:51:28,480
so the guidance is find the answer as

00:51:25,920 --> 00:51:31,520
much at compile time as possible

00:51:28,480 --> 00:51:33,520
and write type rich code use resource

00:51:31,520 --> 00:51:35,920
management and raii

00:51:33,520 --> 00:51:36,880
in ordinary code you can use most of c

00:51:35,920 --> 00:51:39,040
plus features

00:51:36,880 --> 00:51:41,680
and be able to use both error code and

00:51:39,040 --> 00:51:41,680
exceptions

00:51:42,079 --> 00:51:46,559
there are some testimonials um different

00:51:44,559 --> 00:51:47,680
companies have been able to move deeply

00:51:46,559 --> 00:51:50,559
into modern c

00:51:47,680 --> 00:51:50,960
plus like sonova in switzerland move

00:51:50,559 --> 00:51:54,160
from c

00:51:50,960 --> 00:51:55,680
to c plus plus 14. auto intern my good

00:51:54,160 --> 00:51:58,160
friend odin in germany

00:51:55,680 --> 00:51:59,839
he is well into the second and the third

00:51:58,160 --> 00:52:01,359
age of modern c plus buzz

00:51:59,839 --> 00:52:02,960
building embedded controllers using

00:52:01,359 --> 00:52:05,280
template meta programming

00:52:02,960 --> 00:52:06,240
using a library an open library called

00:52:05,280 --> 00:52:08,640
voisir

00:52:06,240 --> 00:52:09,920
kapernikov and the ball group have all

00:52:08,640 --> 00:52:12,640
made similar jumps

00:52:09,920 --> 00:52:13,839
that battle with large code bases so in

00:52:12,640 --> 00:52:15,920
the future of embedded

00:52:13,839 --> 00:52:17,920
engineering is that you want to try to

00:52:15,920 --> 00:52:19,359
understand and see

00:52:17,920 --> 00:52:20,319
you might do something like you just try

00:52:19,359 --> 00:52:22,000
to understand the problem and you

00:52:20,319 --> 00:52:23,760
quickly program some solution and then

00:52:22,000 --> 00:52:25,839
you debug debug

00:52:23,760 --> 00:52:26,960
in c plus plus you want to try to

00:52:25,839 --> 00:52:29,119
understand the problem

00:52:26,960 --> 00:52:30,079
and code the understanding in an

00:52:29,119 --> 00:52:31,760
automated task

00:52:30,079 --> 00:52:33,359
and then the write the code implementing

00:52:31,760 --> 00:52:35,680
a test one at a time

00:52:33,359 --> 00:52:37,440
and then improve the code architecture

00:52:35,680 --> 00:52:39,680
test and understanding until you reach a

00:52:37,440 --> 00:52:42,319
solution

00:52:39,680 --> 00:52:43,920
this is with modern c plus plus for

00:52:42,319 --> 00:52:44,880
embedded you should be able to use

00:52:43,920 --> 00:52:47,200
things like

00:52:44,880 --> 00:52:48,319
encapsulation naming parameters some

00:52:47,200 --> 00:52:50,480
algorithm

00:52:48,319 --> 00:52:52,000
some scope-based resource managements

00:52:50,480 --> 00:52:54,720
like with raii

00:52:52,000 --> 00:52:55,680
with array and string view if they if

00:52:54,720 --> 00:52:58,640
you have the heap

00:52:55,680 --> 00:53:00,000
or unique pointer if you don't compile

00:52:58,640 --> 00:53:02,240
time parameterization

00:53:00,000 --> 00:53:04,800
instead of macros and using values and

00:53:02,240 --> 00:53:07,520
references or optional or smart pointers

00:53:04,800 --> 00:53:09,440
instead of using a pure pointer so

00:53:07,520 --> 00:53:10,960
what's still missing for embedded well

00:53:09,440 --> 00:53:13,119
we need good concrete guidelines for

00:53:10,960 --> 00:53:15,520
small systems it's used

00:53:13,119 --> 00:53:16,319
and not just avoid malloc and exceptions

00:53:15,520 --> 00:53:19,520
we need good

00:53:16,319 --> 00:53:22,079
semi-standard libraries um that is

00:53:19,520 --> 00:53:23,040
less heap dependent pool stacks standard

00:53:22,079 --> 00:53:25,200
containers

00:53:23,040 --> 00:53:27,200
we need to understand that standard full

00:53:25,200 --> 00:53:28,559
c plus is usually good enough

00:53:27,200 --> 00:53:30,400
when you have anything that looks like

00:53:28,559 --> 00:53:32,079
an ordinary computer whereas with

00:53:30,400 --> 00:53:33,200
something like example like pc or

00:53:32,079 --> 00:53:34,720
raspberry pi

00:53:33,200 --> 00:53:37,119
we need to have more people from

00:53:34,720 --> 00:53:39,599
embedded help with sg14

00:53:37,119 --> 00:53:40,800
and here i want to show what sg14 is

00:53:39,599 --> 00:53:42,720
about sg14

00:53:40,800 --> 00:53:44,559
is about embedded which has number

00:53:42,720 --> 00:53:48,720
chairs in there with ben craig

00:53:44,559 --> 00:53:50,559
wooten odin wooter and john mcfarland we

00:53:48,720 --> 00:53:52,559
also have other domains like finance

00:53:50,559 --> 00:53:55,920
trading with stefan

00:53:52,559 --> 00:53:56,720
carl neal matus clay we have covered

00:53:55,920 --> 00:53:59,680
games that's the

00:53:56,720 --> 00:54:00,319
original inception mandate with renee

00:53:59,680 --> 00:54:02,960
guy

00:54:00,319 --> 00:54:04,000
paul and patrice we also cover linear

00:54:02,960 --> 00:54:07,040
algebra with bob

00:54:04,000 --> 00:54:08,839
mark and guy davidson okay so some of

00:54:07,040 --> 00:54:11,599
the features that we are working

00:54:08,839 --> 00:54:13,040
on oh i'm sorry this is a bit of an eye

00:54:11,599 --> 00:54:15,040
test

00:54:13,040 --> 00:54:16,319
we have actually injected on two

00:54:15,040 --> 00:54:18,800
features into

00:54:16,319 --> 00:54:21,200
one in c plus plus 17 called memory

00:54:18,800 --> 00:54:24,640
management facility by brittany freeman

00:54:21,200 --> 00:54:26,079
and in c plus 20 on likely and unlikely

00:54:24,640 --> 00:54:28,640
by clay trita

00:54:26,079 --> 00:54:29,839
and unlikely and lately essentially is

00:54:28,640 --> 00:54:31,599
the ability to say

00:54:29,839 --> 00:54:32,960
you know in a in an if-then-else

00:54:31,599 --> 00:54:33,520
statement or maybe even a switch

00:54:32,960 --> 00:54:35,280
statement

00:54:33,520 --> 00:54:37,040
you can say which branch is more

00:54:35,280 --> 00:54:38,400
frequent so that you can have more so

00:54:37,040 --> 00:54:40,720
that you can have the compiler

00:54:38,400 --> 00:54:41,839
organize code in a way that allows you

00:54:40,720 --> 00:54:44,799
to access them

00:54:41,839 --> 00:54:46,559
um better we also right now uh working

00:54:44,799 --> 00:54:49,280
on some long pole items like

00:54:46,559 --> 00:54:50,160
like uh enabling affinity that proposal

00:54:49,280 --> 00:54:51,839
is slowly working

00:54:50,160 --> 00:54:53,280
its way through sg1 and it's actually

00:54:51,839 --> 00:54:55,280
looking really good

00:54:53,280 --> 00:54:56,559
we've been working on system topology

00:54:55,280 --> 00:54:58,640
discovery to enable

00:54:56,559 --> 00:55:00,880
more ability to understand what your

00:54:58,640 --> 00:55:02,480
hardware cache and system looks like

00:55:00,880 --> 00:55:03,920
we've been working ben craig in

00:55:02,480 --> 00:55:05,839
particular i want to call out for

00:55:03,920 --> 00:55:07,520
him been working on improving the

00:55:05,839 --> 00:55:10,240
specification for freestanding

00:55:07,520 --> 00:55:10,640
the freestanding section of c plus plus

00:55:10,240 --> 00:55:13,599
um

00:55:10,640 --> 00:55:15,599
has been somewhat been outdated by the

00:55:13,599 --> 00:55:16,799
fact that it's mostly still based on c

00:55:15,599 --> 00:55:19,200
from a long time ago and

00:55:16,799 --> 00:55:21,440
untouched by too many people so we're

00:55:19,200 --> 00:55:23,680
hoping that this enables more legitimate

00:55:21,440 --> 00:55:24,799
official usage of the standard libraries

00:55:23,680 --> 00:55:26,480
and the language

00:55:24,799 --> 00:55:28,720
we're working on linear algebra adding

00:55:26,480 --> 00:55:32,160
things like blas okay

00:55:28,720 --> 00:55:34,640
and things that are ideal for

00:55:32,160 --> 00:55:36,319
machine learning working on executors

00:55:34,640 --> 00:55:37,839
with other groups with sg1

00:55:36,319 --> 00:55:39,839
working we were working on things like

00:55:37,839 --> 00:55:43,200
intrusive pointers um

00:55:39,839 --> 00:55:45,359
deterministic exceptions um as well as

00:55:43,200 --> 00:55:46,799
exception that's based at a stack base

00:55:45,359 --> 00:55:49,520
instead of heap phase

00:55:46,799 --> 00:55:50,160
um two um two two i'm really excited

00:55:49,520 --> 00:55:53,200
about

00:55:50,160 --> 00:55:54,559
um is colony by matthew bentley as well

00:55:53,200 --> 00:55:57,200
as ring buffer by

00:55:54,559 --> 00:55:58,160
uh ingra levy matthew butler and guy

00:55:57,200 --> 00:56:00,160
davidson

00:55:58,160 --> 00:56:01,839
um this flat map that's being worked on

00:56:00,160 --> 00:56:03,440
by zach lane

00:56:01,839 --> 00:56:04,880
renee is working on something called

00:56:03,440 --> 00:56:06,799
members layout control

00:56:04,880 --> 00:56:09,040
and there are other ones that's coming

00:56:06,799 --> 00:56:12,640
as well having to do

00:56:09,040 --> 00:56:16,160
with uh yes debug

00:56:12,640 --> 00:56:17,839
debugs exception handling measurements

00:56:16,160 --> 00:56:19,280
okay so i'm just going to skip past some

00:56:17,839 --> 00:56:20,160
of that because the rest is mostly about

00:56:19,280 --> 00:56:22,640
sg19

00:56:20,160 --> 00:56:23,839
so what's next for sg14 it was created

00:56:22,640 --> 00:56:25,760
in 2015

00:56:23,839 --> 00:56:27,200
uh we used the proto outreach group and

00:56:25,760 --> 00:56:30,000
it seems to have succeeded

00:56:27,200 --> 00:56:31,680
we added features in c plus 17 and 20.

00:56:30,000 --> 00:56:33,599
they're more coming in 23.

00:56:31,680 --> 00:56:35,680
we have renewed focus for each domain

00:56:33,599 --> 00:56:36,480
and increased interest now in security

00:56:35,680 --> 00:56:38,799
and safety

00:56:36,480 --> 00:56:40,720
currently partially handled by sg12

00:56:38,799 --> 00:56:42,799
please join us for games embedded

00:56:40,720 --> 00:56:44,079
finance linear algebra that spreadsheet

00:56:42,799 --> 00:56:47,200
is accessed through this google

00:56:44,079 --> 00:56:50,079
link okay and i think

00:56:47,200 --> 00:56:51,680
that is it so we have only about uh two

00:56:50,079 --> 00:56:53,359
minutes left so i'm going to endeavor to

00:56:51,680 --> 00:56:55,119
try to answer the first

00:56:53,359 --> 00:56:56,880
a few of these questions and i'm going

00:56:55,119 --> 00:56:58,960
to capture the rest of these questions

00:56:56,880 --> 00:57:00,559
and so that can handle so i can add to

00:56:58,960 --> 00:57:02,000
the answer answer them later so whatever

00:57:00,559 --> 00:57:03,520
handling techniques you use in c plus

00:57:02,000 --> 00:57:06,000
plus for embedded systems

00:57:03,520 --> 00:57:07,599
we use both error handling techniques

00:57:06,000 --> 00:57:09,040
using system error there is actually a

00:57:07,599 --> 00:57:12,079
for official system error

00:57:09,040 --> 00:57:14,079
not erno that's in c

00:57:12,079 --> 00:57:15,680
since there's since c plus plus 11. look

00:57:14,079 --> 00:57:18,720
it up it's there

00:57:15,680 --> 00:57:20,799
and we also have been working on um in

00:57:18,720 --> 00:57:22,799
some cases you do use exception handling

00:57:20,799 --> 00:57:24,400
if you can determine that it has low

00:57:22,799 --> 00:57:25,760
exception costs but right now there's

00:57:24,400 --> 00:57:26,160
much debate and that's why we have a

00:57:25,760 --> 00:57:28,240
work

00:57:26,160 --> 00:57:30,319
group measuring the effects of exception

00:57:28,240 --> 00:57:31,119
handling and figuring out a way to give

00:57:30,319 --> 00:57:33,520
guidance

00:57:31,119 --> 00:57:35,359
it is a big topic it's a big topic not

00:57:33,520 --> 00:57:35,760
just here but in concurrency as well too

00:57:35,359 --> 00:57:37,359
so

00:57:35,760 --> 00:57:39,280
we do want to make sure that we have

00:57:37,359 --> 00:57:41,200
something i'm very excited about this

00:57:39,280 --> 00:57:42,480
new project where we're looking at how c

00:57:41,200 --> 00:57:43,119
plus plus exception handling can be

00:57:42,480 --> 00:57:45,200
implemented

00:57:43,119 --> 00:57:46,160
implemented as stack base which by the

00:57:45,200 --> 00:57:47,839
way is kind of what

00:57:46,160 --> 00:57:49,200
deterministic exception is kind of all

00:57:47,839 --> 00:57:51,920
about as well too

00:57:49,200 --> 00:57:52,400
um so these are promising features that

00:57:51,920 --> 00:57:54,559
i think

00:57:52,400 --> 00:57:56,000
that will work for embedded systems

00:57:54,559 --> 00:57:58,160
second question

00:57:56,000 --> 00:58:00,880
is the c plus memory model we now have

00:57:58,160 --> 00:58:03,920
well suited for the embedded field

00:58:00,880 --> 00:58:05,839
very good question um some of it

00:58:03,920 --> 00:58:07,359
yes i would know um the embedded system

00:58:05,839 --> 00:58:10,319
sometimes might have accelerators

00:58:07,359 --> 00:58:10,640
graphics gpu units that memory model is

00:58:10,319 --> 00:58:12,880
not

00:58:10,640 --> 00:58:14,079
enshrined in the c plus plus memory

00:58:12,880 --> 00:58:15,920
model right now because c clusters

00:58:14,079 --> 00:58:17,680
doesn't know about accelerators but in

00:58:15,920 --> 00:58:18,880
reality we know that dsps and

00:58:17,680 --> 00:58:22,160
accelerators and

00:58:18,880 --> 00:58:22,880
machine learning ai processors exists in

00:58:22,160 --> 00:58:25,839
the world

00:58:22,880 --> 00:58:26,319
so what happens there is that um there

00:58:25,839 --> 00:58:28,960
are

00:58:26,319 --> 00:58:29,520
other models that are being adapted that

00:58:28,960 --> 00:58:31,839
can

00:58:29,520 --> 00:58:32,960
in the wing that are adapted uh vulcan

00:58:31,839 --> 00:58:35,760
and opencl just

00:58:32,960 --> 00:58:36,880
recently built a beautiful gpu type of

00:58:35,760 --> 00:58:39,920
programming model

00:58:36,880 --> 00:58:42,160
memory model that is ready to go in

00:58:39,920 --> 00:58:43,760
and we have to work look closely at that

00:58:42,160 --> 00:58:44,400
when we're ready to accept some of these

00:58:43,760 --> 00:58:45,920
models

00:58:44,400 --> 00:58:48,160
now i know we're almost running out of

00:58:45,920 --> 00:58:48,160
time

00:58:49,280 --> 00:58:52,880
so i think that i'm gonna have to stop

00:58:51,440 --> 00:58:54,160
here i'm gonna capture the rest of these

00:58:52,880 --> 00:58:56,400
great questions

00:58:54,160 --> 00:58:57,440
and use it to put it in either another

00:58:56,400 --> 00:59:00,720
talk i'll do it in

00:58:57,440 --> 00:59:02,640
sg14 um if you guys want to um

00:59:00,720 --> 00:59:04,000
join sg14 i would just say that it's an

00:59:02,640 --> 00:59:07,040
outreach group you don't have to

00:59:04,000 --> 00:59:10,000
be um you don't have to be a iso

00:59:07,040 --> 00:59:12,079
or a national body member to join go to

00:59:10,000 --> 00:59:14,240
iso cpp.org go to form

00:59:12,079 --> 00:59:15,599
find out how to join sg14 and come on

00:59:14,240 --> 00:59:17,040
our future calls and we'll definitely

00:59:15,599 --> 00:59:18,480
discuss some of these issues

00:59:17,040 --> 00:59:20,720
and i'm gonna hold these questions in

00:59:18,480 --> 00:59:21,200
bed because we have a fireside chat i

00:59:20,720 --> 00:59:22,799
believe

00:59:21,200 --> 00:59:24,480
this afternoon where i'm gonna be part

00:59:22,799 --> 00:59:26,319
of where you're gonna ask some of the

00:59:24,480 --> 00:59:27,440
limitations about discuss some of the

00:59:26,319 --> 00:59:29,839
issues with embedded

00:59:27,440 --> 00:59:30,799
so we can definitely uh reuse this and

00:59:29,839 --> 00:59:33,440
if we keep these

00:59:30,799 --> 00:59:35,760
questions here we can definitely reuse

00:59:33,440 --> 00:59:38,880
them for this afternoon

00:59:35,760 --> 00:59:41,280
okay thank you sorry this is a bit of a

00:59:38,880 --> 00:59:43,040
you know fast talk but i hope that i

00:59:41,280 --> 00:59:43,839
conveyed enough information to help you

00:59:43,040 --> 00:59:45,839
guys

00:59:43,839 --> 00:59:47,440
move your projects from c to c plus plus

00:59:45,839 --> 01:00:01,839
in embedded programming

00:59:47,440 --> 01:00:01,839
okay thanks cheers bye-bye

01:00:09,359 --> 01:00:11,440

YouTube URL: https://www.youtube.com/watch?v=885TI3jnB7g


