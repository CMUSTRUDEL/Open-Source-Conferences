Title: CppCon 2017: Victor Zverovich “A modern formatting library for C++”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Come learn about the intricacies of C++ formatting, from stdio to iostream to the new standard proposal P0645R0: Text Formatting. The new proposal combines variadic templates with a Python-like format string syntax and is designed for performance, extensibility, and safety. It is based on the popular fmt library that has been successfully used in numerous projects in such diverse areas as gaming, mathematical optimization, autonomous vehicles, databases, logging libraries and more.
— 
Victor Zverovich: Facebook, Software Engineer

Victor Zverovich is a software engineer at Facebook working on reactive systems. Before joining Facebook in 2016, he was working for several years on modeling systems for mathematical optimization. He is an active contributor to open-source projects and an author of a popular formatting library for C++ called fmt (previously cppformat).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,200
my name is Victor Suraj and I'm a

00:00:01,920 --> 00:00:06,240
software engineer at Facebook I'll be

00:00:04,200 --> 00:00:08,849
talking today about a modern formatting

00:00:06,240 --> 00:00:10,320
library for C++ and it has nothing

00:00:08,849 --> 00:00:13,139
whatsoever to do with my work at

00:00:10,320 --> 00:00:17,910
Facebook in fact I started this project

00:00:13,139 --> 00:00:22,760
long before I joined the Facebook and I

00:00:17,910 --> 00:00:26,010
worked on it in my spare time mostly

00:00:22,760 --> 00:00:29,220
first a bit of wisdom from one of the

00:00:26,010 --> 00:00:31,619
reviewers of my CV pecan submission so

00:00:29,220 --> 00:00:33,809
formatting is something everybody uses

00:00:31,619 --> 00:00:36,750
but nobody has put much efforts to

00:00:33,809 --> 00:00:38,969
effort to learn and I hope very much

00:00:36,750 --> 00:00:45,899
that you'll learn something from this

00:00:38,969 --> 00:00:47,879
talk so here's a brief high-level

00:00:45,899 --> 00:00:51,660
overview of what formatting facilities

00:00:47,879 --> 00:00:54,629
we have in C++ obviously we have two

00:00:51,660 --> 00:00:56,520
standard solutions stdio and the i/o

00:00:54,629 --> 00:00:59,579
streams and we have a bunch of

00:00:56,520 --> 00:01:03,329
formatting libraries like booster format

00:00:59,579 --> 00:01:07,590
and fast format arguably two most

00:01:03,329 --> 00:01:09,630
well-known libraries and I also included

00:01:07,590 --> 00:01:13,290
foley format it's not a separate library

00:01:09,630 --> 00:01:16,020
but a part of Facebook foley which

00:01:13,290 --> 00:01:18,299
provides formatting facilities i

00:01:16,020 --> 00:01:21,119
included here because it's very relevant

00:01:18,299 --> 00:01:22,740
to what he'll be talking about and there

00:01:21,119 --> 00:01:25,229
are millions of other ways of doing

00:01:22,740 --> 00:01:28,729
formatting pretty much every large code

00:01:25,229 --> 00:01:30,960
base has there one has their own safe

00:01:28,729 --> 00:01:36,270
printf replacement for various

00:01:30,960 --> 00:01:39,780
definitions of safe and I'll go in

00:01:36,270 --> 00:01:42,659
roughly chronological order studying

00:01:39,780 --> 00:01:46,530
from the past stdio which we inherited

00:01:42,659 --> 00:01:49,430
from this this C standard library and

00:01:46,530 --> 00:01:53,509
[Music]

00:01:49,430 --> 00:01:57,930
here's a like a warm-up trivial example

00:01:53,509 --> 00:02:00,119
and also to calibrate the audience and

00:01:57,930 --> 00:02:03,600
see how many of you are slipping or

00:02:00,119 --> 00:02:08,280
checking emails and how many of you are

00:02:03,600 --> 00:02:11,539
awake so who thinks that this is there

00:02:08,280 --> 00:02:11,539
is an error in this slide

00:02:12,650 --> 00:02:22,410
in the codn't yeah this is correct who'd

00:02:19,680 --> 00:02:29,700
think that this is okay this is this

00:02:22,410 --> 00:02:34,350
coat is fine okay want us put some

00:02:29,700 --> 00:02:36,960
things that it's fine yeah so obviously

00:02:34,350 --> 00:02:39,660
there is a mismatch between the argument

00:02:36,960 --> 00:02:42,030
type and the format specifier which is

00:02:39,660 --> 00:02:45,900
percent s which assumes that the

00:02:42,030 --> 00:02:48,870
argument should be AC string or L

00:02:45,900 --> 00:02:52,560
terminated string and good compilers

00:02:48,870 --> 00:02:55,890
like GCC or clang will warn you

00:02:52,560 --> 00:02:59,250
eagerly and give lots of useful details

00:02:55,890 --> 00:03:03,390
they even say which format specifier you

00:02:59,250 --> 00:03:06,240
can use instead and this is great but

00:03:03,390 --> 00:03:09,060
unfortunately it only works for literal

00:03:06,240 --> 00:03:13,530
format strings and in reality they can

00:03:09,060 --> 00:03:19,590
be dynamic they can come from the

00:03:13,530 --> 00:03:24,270
especially due to localization so

00:03:19,590 --> 00:03:26,160
another problem is memory safety let's

00:03:24,270 --> 00:03:30,260
assume that you want to format an

00:03:26,160 --> 00:03:32,970
integer and you went to great lengths to

00:03:30,260 --> 00:03:36,560
compute exactly how many characters you

00:03:32,970 --> 00:03:42,150
think you need to allocate for a buffer

00:03:36,560 --> 00:03:47,100
so you even added one for terminated

00:03:42,150 --> 00:03:49,770
thing now character and this is the

00:03:47,100 --> 00:03:54,330
common source of errors of course and

00:03:49,770 --> 00:03:58,620
you allocated the vector of the of this

00:03:54,330 --> 00:04:01,280
size and you passed this buffer to s

00:03:58,620 --> 00:04:05,820
printf together with the format string

00:04:01,280 --> 00:04:09,150
and an argument where X is the same as

00:04:05,820 --> 00:04:13,310
before it's an integer and you stored

00:04:09,150 --> 00:04:19,970
the return value in the result variable

00:04:13,310 --> 00:04:19,970
so who thinks that this code is correct

00:04:20,919 --> 00:04:29,409
good but things that it's incorrect okay

00:04:25,169 --> 00:04:33,039
yeah this is incorrect and if you if we

00:04:29,409 --> 00:04:35,699
want to check and print the result plus

00:04:33,039 --> 00:04:38,319
one for null Terminator and the size

00:04:35,699 --> 00:04:42,069
most of the time it will kind of work

00:04:38,319 --> 00:04:47,080
but for over a billion of integers if

00:04:42,069 --> 00:04:50,830
you used a little bit platform you'll

00:04:47,080 --> 00:04:53,650
get output 12:11 which means that you

00:04:50,830 --> 00:04:56,860
have a buffer overflow and they

00:04:53,650 --> 00:05:01,120
obviously it will happen for integers

00:04:56,860 --> 00:05:04,389
less or equal to minus 1 billion because

00:05:01,120 --> 00:05:07,870
we didn't take into account the minus

00:05:04,389 --> 00:05:10,029
sign and a solution is to use a sent

00:05:07,870 --> 00:05:14,379
printf but unfortunately it cannot grow

00:05:10,029 --> 00:05:17,139
buffer dynamically so you other need to

00:05:14,379 --> 00:05:22,749
pre-compute the size or overestimate the

00:05:17,139 --> 00:05:25,539
size which is suboptimal and did you

00:05:22,749 --> 00:05:30,009
notice another error on the previous

00:05:25,539 --> 00:05:33,969
slide note the writing pause the end of

00:05:30,009 --> 00:05:37,240
the buffer but something else so to kind

00:05:33,969 --> 00:05:39,009
of remind you here we computed size we

00:05:37,240 --> 00:05:41,800
return the results so did you see any

00:05:39,009 --> 00:05:46,080
errors any more errors in this simple

00:05:41,800 --> 00:05:50,319
line of code yes exactly

00:05:46,080 --> 00:05:52,389
so the size T and compiler again gives

00:05:50,319 --> 00:05:55,930
you this nice warning message except

00:05:52,389 --> 00:05:58,210
that in this case it's incorrect so the

00:05:55,930 --> 00:06:03,270
correct specifier for size T is not

00:05:58,210 --> 00:06:09,550
Poisson tell you but to send Z you so

00:06:03,270 --> 00:06:14,949
yeah and then you can get errors like

00:06:09,550 --> 00:06:19,599
this which is an actual screenshot from

00:06:14,949 --> 00:06:25,469
a bug report to a game called Cataclysm

00:06:19,599 --> 00:06:29,620
if I read the ASCII art phone correctly

00:06:25,469 --> 00:06:31,629
where you can see lots of Z use which I

00:06:29,620 --> 00:06:34,580
don't think are intentional there and

00:06:31,629 --> 00:06:38,870
this was pretty recent this is

00:06:34,580 --> 00:06:42,180
opened in 2016 this Margaret word and

00:06:38,870 --> 00:06:44,790
the problem was that they used Visual

00:06:42,180 --> 00:06:52,260
Studio which didn't support % zu until

00:06:44,790 --> 00:06:56,460
like version 2015 I believe and we have

00:06:52,260 --> 00:07:00,180
the whole zoo of macros for fixed sized

00:06:56,460 --> 00:07:04,500
integer types that define different

00:07:00,180 --> 00:07:09,990
format specifiers this table I took from

00:07:04,500 --> 00:07:12,360
CDP reference calm and the worst thing

00:07:09,990 --> 00:07:14,490
about this macorís is that to use them

00:07:12,360 --> 00:07:17,490
you have to break the string insert the

00:07:14,490 --> 00:07:20,640
macro and then continue your string

00:07:17,490 --> 00:07:22,980
which is horrible I don't even know how

00:07:20,640 --> 00:07:30,270
would you use that with the non-literal

00:07:22,980 --> 00:07:32,700
string so why do we need to pass type

00:07:30,270 --> 00:07:36,960
information manually if the compiler

00:07:32,700 --> 00:07:39,540
knows the types so the answer is of

00:07:36,960 --> 00:07:41,370
course var arts which are so old they

00:07:39,540 --> 00:07:49,080
have been featured on the History

00:07:41,370 --> 00:07:51,570
Channel so for a long time I believe

00:07:49,080 --> 00:07:56,880
that ver arts must be super fast at sea

00:07:51,570 --> 00:08:00,300
right it's the best but then I looked at

00:07:56,880 --> 00:08:03,840
the actual generated assembly code and

00:08:00,300 --> 00:08:06,690
did some benchmark so what I found out

00:08:03,840 --> 00:08:08,720
that some platforms at least maybe in

00:08:06,690 --> 00:08:11,340
all platforms they are not inlinable

00:08:08,720 --> 00:08:13,560
well functions that use verbs are not

00:08:11,340 --> 00:08:16,530
invulnerable and also they produce a

00:08:13,560 --> 00:08:20,910
bunch of code to store the registers on

00:08:16,530 --> 00:08:25,940
stack this seems insignificant

00:08:20,910 --> 00:08:28,980
so we can measure what's the impact so

00:08:25,940 --> 00:08:31,380
it's just a few percent not very

00:08:28,980 --> 00:08:32,940
important but annoying and also if you

00:08:31,380 --> 00:08:36,920
optimize the underline and printf

00:08:32,940 --> 00:08:39,300
implementation which can be done and I

00:08:36,920 --> 00:08:41,940
have an alternative implementation which

00:08:39,300 --> 00:08:45,890
is somewhat faster than it this

00:08:41,940 --> 00:08:45,890
difference will be more profound

00:08:47,250 --> 00:08:59,680
so a more serious problem is a lack of

00:08:55,209 --> 00:09:02,740
random access so if you use positional

00:08:59,680 --> 00:09:07,720
arguments you need to set up extra

00:09:02,740 --> 00:09:11,860
arrays and printf does a bunch of other

00:09:07,720 --> 00:09:14,620
stuff so on my platform which is a mock

00:09:11,860 --> 00:09:17,380
us with clang if you use positional

00:09:14,620 --> 00:09:22,260
arguments with aspirins half it can be

00:09:17,380 --> 00:09:24,370
almost two times slower which is crazy

00:09:22,260 --> 00:09:27,579
what can we learn from it

00:09:24,370 --> 00:09:30,510
so we can learn that for words it is a

00:09:27,579 --> 00:09:34,540
poor choice for more than formatting API

00:09:30,510 --> 00:09:36,220
because of many old type management they

00:09:34,540 --> 00:09:38,649
don't play well with positional

00:09:36,220 --> 00:09:42,399
arguments due to lack of random access

00:09:38,649 --> 00:09:45,339
and the we have suboptimal code

00:09:42,399 --> 00:09:47,190
generation and the code the functions

00:09:45,339 --> 00:09:50,050
are non inlinable

00:09:47,190 --> 00:09:54,520
so we can do much better with very attic

00:09:50,050 --> 00:09:58,990
templates so now the question why even

00:09:54,520 --> 00:10:02,500
bother about verax's ancient stuff the

00:09:58,990 --> 00:10:06,339
reason is that I so many times people

00:10:02,500 --> 00:10:08,649
write safe printf replacement on top of

00:10:06,339 --> 00:10:12,570
s printf so they so some of the issues

00:10:08,649 --> 00:10:16,329
but not all of them and often add extra

00:10:12,570 --> 00:10:18,850
layer of overhead by performing these

00:10:16,329 --> 00:10:21,670
type checks so I think it's better to

00:10:18,850 --> 00:10:29,380
you go and kind of start from scratch

00:10:21,670 --> 00:10:37,170
and use very attic templates kind of in

00:10:29,380 --> 00:10:40,449
the first place and finally in this

00:10:37,170 --> 00:10:44,709
historical section I'd like to talk a

00:10:40,449 --> 00:10:49,269
bit about extensibility there is no

00:10:44,709 --> 00:10:51,279
standard way to extend printf by

00:10:49,269 --> 00:10:55,270
extending I mean supporting formatting

00:10:51,279 --> 00:10:56,780
of your own types but there is a new

00:10:55,270 --> 00:11:00,290
extension

00:10:56,780 --> 00:11:04,100
and as you might imagine it's pretty

00:11:00,290 --> 00:11:06,620
horrible so to use it you need to

00:11:04,100 --> 00:11:10,160
register two functions one that actually

00:11:06,620 --> 00:11:15,050
does formatting here it's called print

00:11:10,160 --> 00:11:18,530
widget and it's it does an unsafe cost

00:11:15,050 --> 00:11:21,350
there and it's supposed to format the

00:11:18,530 --> 00:11:25,430
object that you passed in and the other

00:11:21,350 --> 00:11:27,830
is kind of type checking function

00:11:25,430 --> 00:11:29,450
although the only thing that it does you

00:11:27,830 --> 00:11:31,670
just said that the argument should be

00:11:29,450 --> 00:11:40,310
some kind of a pointer which is not very

00:11:31,670 --> 00:11:42,860
type safe so and moreover in if I

00:11:40,310 --> 00:11:47,860
remember correctly they recommend only

00:11:42,860 --> 00:11:47,860
using uppercase letters when registering

00:11:48,850 --> 00:11:54,980
handlers for new types so if you ever

00:11:52,160 --> 00:11:59,590
want to support formatting more than 26

00:11:54,980 --> 00:11:59,590
types in your program you're out of luck

00:12:00,820 --> 00:12:07,580
this brings us to the present or i/o

00:12:03,650 --> 00:12:13,550
streams which is the standard C++ way of

00:12:07,580 --> 00:12:15,980
doing formatting and IO and while it

00:12:13,550 --> 00:12:20,000
solves lots of problems with the printf

00:12:15,980 --> 00:12:26,510
that we saw earlier it has the problems

00:12:20,000 --> 00:12:29,750
of its own one of the most obvious thing

00:12:26,510 --> 00:12:34,310
is what Matthew Wilson the authors of

00:12:29,750 --> 00:12:38,630
fast format called Chevron hell which i

00:12:34,310 --> 00:12:41,360
think is a very good description so here

00:12:38,630 --> 00:12:45,170
we have two snippets of code that do

00:12:41,360 --> 00:12:50,810
pretty much the same formatting so one

00:12:45,170 --> 00:12:56,960
uses printf and other uses a stream so

00:12:50,810 --> 00:13:01,490
who profess the printf version okay who

00:12:56,960 --> 00:13:05,510
profess the airstreams version everyone

00:13:01,490 --> 00:13:08,570
a few hands there but the majority seems

00:13:05,510 --> 00:13:10,460
to prefer printf so if we put aside all

00:13:08,570 --> 00:13:13,580
the issues with it the

00:13:10,460 --> 00:13:17,390
obviously the code is much more compact

00:13:13,580 --> 00:13:21,260
and readable and finally suppose +11

00:13:17,390 --> 00:13:26,980
gave in to format specifiers for time

00:13:21,260 --> 00:13:26,980
and it reduced the STD put time function

00:13:27,640 --> 00:13:33,410
there are some differences in this two

00:13:31,220 --> 00:13:41,779
pieces of code which I will talk about

00:13:33,410 --> 00:13:44,630
later so another issue that we have with

00:13:41,779 --> 00:13:48,200
the ice trains is problems with

00:13:44,630 --> 00:13:51,560
translations so if we use printf we have

00:13:48,200 --> 00:13:54,440
the whole message with arguments

00:13:51,560 --> 00:13:58,370
available for translation but in our

00:13:54,440 --> 00:14:00,830
streams by design parts of message are

00:13:58,370 --> 00:14:05,000
interleaved with formatting arguments

00:14:00,830 --> 00:14:08,060
and the thing is in general translation

00:14:05,000 --> 00:14:11,720
of the formatted message is not equal to

00:14:08,060 --> 00:14:16,610
the concatenation of translated parts at

00:14:11,720 --> 00:14:17,870
least in many languages it doesn't mean

00:14:16,610 --> 00:14:20,390
that the formatting library should

00:14:17,870 --> 00:14:22,279
provide translation facilities but it

00:14:20,390 --> 00:14:27,260
should be possible to build them on top

00:14:22,279 --> 00:14:29,170
of the provided API other problems

00:14:27,260 --> 00:14:32,390
related to this is reloading of

00:14:29,170 --> 00:14:40,580
arguments and access to arguments for

00:14:32,390 --> 00:14:45,500
pluralization so now let's take a look

00:14:40,580 --> 00:14:49,580
at i/o manipulators so the first one we

00:14:45,500 --> 00:14:52,880
just print out some integer in

00:14:49,580 --> 00:14:57,529
hexadecimal and then we try to print

00:14:52,880 --> 00:15:00,500
something else so what do you think the

00:14:57,529 --> 00:15:06,829
second one will print out who thinks it

00:15:00,500 --> 00:15:12,290
will print out 42 no good what do you

00:15:06,829 --> 00:15:17,380
think it will print out yes exactly so

00:15:12,290 --> 00:15:20,959
that it will print out to a obviously

00:15:17,380 --> 00:15:23,140
because we didn't switch back to decimal

00:15:20,959 --> 00:15:23,140
and

00:15:23,430 --> 00:15:32,610
some flags are sticky some are not so go

00:15:28,140 --> 00:15:39,990
figure and the solution to this problem

00:15:32,610 --> 00:15:44,010
is to use boost IO iOS flag saver but

00:15:39,990 --> 00:15:47,430
it's a bit annoying so I think that

00:15:44,010 --> 00:15:49,290
ideally from adding functions when you

00:15:47,430 --> 00:15:51,150
call them they shouldn't produce any

00:15:49,290 --> 00:16:00,480
side effects other than the output

00:15:51,150 --> 00:16:03,930
itself and here in this example we are

00:16:00,480 --> 00:16:05,940
trying to write a little bit of JSON and

00:16:03,930 --> 00:16:08,510
we can do it manually like in this

00:16:05,940 --> 00:16:13,820
trivial example we can use one of the

00:16:08,510 --> 00:16:16,860
tons of JSON serialization libraries and

00:16:13,820 --> 00:16:23,580
which underneath can do an equivalent of

00:16:16,860 --> 00:16:28,620
this code so what do you think this will

00:16:23,580 --> 00:16:36,740
print out - it would be like curly

00:16:28,620 --> 00:16:40,320
braces value and within them value : 4.2

00:16:36,740 --> 00:16:45,630
who thinks it will be kind of expected

00:16:40,320 --> 00:16:51,870
result no they're they're all tricky

00:16:45,630 --> 00:16:56,370
questions right so the answer is it

00:16:51,870 --> 00:17:00,750
depends because we are using work house

00:16:56,370 --> 00:17:04,110
and most of the time well as they say it

00:17:00,750 --> 00:17:07,230
works on my machine it works fine it

00:17:04,110 --> 00:17:11,089
will print value go on 42 which is a

00:17:07,230 --> 00:17:13,770
perfect JSON as far as I understand

00:17:11,089 --> 00:17:16,770
until someone says the global look how

00:17:13,770 --> 00:17:20,130
to something like Russian utf-8 or other

00:17:16,770 --> 00:17:22,650
weird thing then you get a instead of

00:17:20,130 --> 00:17:25,530
your nice decimal points you get a

00:17:22,650 --> 00:17:28,050
decimal comma or I don't know decimal

00:17:25,530 --> 00:17:35,940
and percent whatever the local decides

00:17:28,050 --> 00:17:38,550
to choose for decimal separator so

00:17:35,940 --> 00:17:40,980
you can argue it won't happen to me I'm

00:17:38,550 --> 00:17:45,990
a responsible developer I'm setting my

00:17:40,980 --> 00:17:47,640
locale to see but in fact it can happen

00:17:45,990 --> 00:17:50,190
to you if specially if you are

00:17:47,640 --> 00:17:51,780
developing a library and you have you

00:17:50,190 --> 00:17:55,590
don't want to mess up with the global

00:17:51,780 --> 00:17:58,260
state and it happened to me personally

00:17:55,590 --> 00:18:05,450
this is a bug report it was a very

00:17:58,260 --> 00:18:09,240
helpful title and accepted exception so

00:18:05,450 --> 00:18:11,850
this happened because the user had any

00:18:09,240 --> 00:18:14,730
italian locale and I was not careful

00:18:11,850 --> 00:18:18,270
enough to make sure that our food is

00:18:14,730 --> 00:18:23,370
local independent and the format I was

00:18:18,270 --> 00:18:31,500
writing to didn't really allow decimal

00:18:23,370 --> 00:18:34,020
comas I would argue that the only reason

00:18:31,500 --> 00:18:36,450
for the output to be like how dependent

00:18:34,020 --> 00:18:39,030
if it's displayed to the actual user if

00:18:36,450 --> 00:18:41,910
you're writing to JSON or XML or

00:18:39,030 --> 00:18:45,270
anything else there are strict rules

00:18:41,910 --> 00:18:47,280
that you must adhere and the output

00:18:45,270 --> 00:18:49,050
should be a local independent and maybe

00:18:47,280 --> 00:18:50,880
this should be the default behavior on

00:18:49,050 --> 00:18:56,580
or at the very least you should have

00:18:50,880 --> 00:18:59,450
control over it and I should stress that

00:18:56,580 --> 00:19:03,750
this issue is not specific to extremes

00:18:59,450 --> 00:19:06,570
in fact this bug report you know was

00:19:03,750 --> 00:19:08,850
open to projects where I didn't use our

00:19:06,570 --> 00:19:14,340
streams but it's a kind of a common

00:19:08,850 --> 00:19:17,850
problem and yet another kind of worms

00:19:14,340 --> 00:19:20,400
called threads let's say you want to

00:19:17,850 --> 00:19:22,520
print some something from multiple

00:19:20,400 --> 00:19:25,560
threads in this case we are printing

00:19:22,520 --> 00:19:29,910
printing some simple greeting messages

00:19:25,560 --> 00:19:35,190
from two threads and then then we join

00:19:29,910 --> 00:19:39,480
them so again who thinks that it will

00:19:35,190 --> 00:19:42,230
print something obvious like hello Joe

00:19:39,480 --> 00:19:42,230
hello Jim

00:19:43,530 --> 00:19:52,110
who thinks it's an undefined behavior oh

00:19:47,960 --> 00:19:53,610
I think that's a good answer reasonable

00:19:52,110 --> 00:19:57,120
answer by default if you see a

00:19:53,610 --> 00:19:58,860
reasonably big chunk of C++ code the

00:19:57,120 --> 00:20:02,130
defaults kind of assumption should be

00:19:58,860 --> 00:20:06,120
this is an undefined behavior this is

00:20:02,130 --> 00:20:07,710
like a rule of thumb but I don't think

00:20:06,120 --> 00:20:10,980
the reason undefined behavior and unless

00:20:07,710 --> 00:20:15,270
I made some stupid mistake which isn't

00:20:10,980 --> 00:20:17,850
how it possible but the ants again it

00:20:15,270 --> 00:20:20,940
depends and one of the better outputs

00:20:17,850 --> 00:20:22,530
that I've chosen out of by running

00:20:20,940 --> 00:20:25,590
multiple times and then selecting the

00:20:22,530 --> 00:20:28,080
one that I liked was hello hello Joe Jim

00:20:25,590 --> 00:20:31,650
and the reason why I like this

00:20:28,080 --> 00:20:34,110
particular output is that when I was a

00:20:31,650 --> 00:20:37,260
kid I liked to read the Robert

00:20:34,110 --> 00:20:40,230
Heinlein's orphans in the sky

00:20:37,260 --> 00:20:48,090
we had a two-headed character called Joe

00:20:40,230 --> 00:20:50,160
Jim Gregory so note that in case of see

00:20:48,090 --> 00:20:54,260
out there is synchronization there but

00:20:50,160 --> 00:20:57,110
not on the level of messages but rather

00:20:54,260 --> 00:20:59,490
individual arguments that you output

00:20:57,110 --> 00:21:03,300
which is a bit of a regression compared

00:20:59,490 --> 00:21:13,790
to POSIX printf where you could have a

00:21:03,300 --> 00:21:17,400
perfect output so now a bit of

00:21:13,790 --> 00:21:19,350
alternative history what would happen if

00:21:17,400 --> 00:21:23,220
for many libraries became mainstream and

00:21:19,350 --> 00:21:25,680
took over the world well not really this

00:21:23,220 --> 00:21:30,230
is just an overview of some of the major

00:21:25,680 --> 00:21:32,160
formatting libraries and some of the

00:21:30,230 --> 00:21:40,350
limitations of them which may explain

00:21:32,160 --> 00:21:42,990
why they've never taken off so boost

00:21:40,350 --> 00:21:48,600
format is probably the most well known

00:21:42,990 --> 00:21:55,770
and widely used formatting library it's

00:21:48,600 --> 00:21:57,370
suppose it supports two syntaxes or its

00:21:55,770 --> 00:22:00,430
format strings a pre

00:21:57,370 --> 00:22:04,270
tough syntax which you can see in the

00:22:00,430 --> 00:22:06,370
example below and simplified syntax

00:22:04,270 --> 00:22:08,440
where with positional positional

00:22:06,370 --> 00:22:13,980
arguments where you can omit type

00:22:08,440 --> 00:22:17,520
specifiers and the syntax is very

00:22:13,980 --> 00:22:19,980
expressive but somewhat complicated

00:22:17,520 --> 00:22:23,200
because you can do everything in

00:22:19,980 --> 00:22:30,360
multiple different ways here you have

00:22:23,200 --> 00:22:33,910
four examples that do the same and

00:22:30,360 --> 00:22:36,010
although it's supports printf syntax

00:22:33,910 --> 00:22:37,690
it's not fully compatible so it's not a

00:22:36,010 --> 00:22:44,530
drop-in replacement which kind of

00:22:37,690 --> 00:22:48,160
undermines the reason to go this way in

00:22:44,530 --> 00:22:50,410
the first place but the main problem

00:22:48,160 --> 00:22:55,000
with boost format is illustrated on this

00:22:50,410 --> 00:22:58,840
slide the the performance code bloat and

00:22:55,000 --> 00:23:03,370
compile times are all very disappointing

00:22:58,840 --> 00:23:05,550
compared to printf and not only printf

00:23:03,370 --> 00:23:09,840
I'll show later more benchmarks

00:23:05,550 --> 00:23:09,840
comparing to other formatting libraries

00:23:10,410 --> 00:23:18,210
now this is the actual photo of me in

00:23:13,240 --> 00:23:21,309
2012 when I've ran the benchmark and I

00:23:18,210 --> 00:23:24,990
realized I can't use this library and I

00:23:21,309 --> 00:23:24,990
have to come up with something else

00:23:25,710 --> 00:23:33,550
another well-known library is fast

00:23:29,740 --> 00:23:36,280
format unlike boost

00:23:33,550 --> 00:23:39,370
I like boost format it is reportedly

00:23:36,280 --> 00:23:43,750
fast it even has its in its name which

00:23:39,370 --> 00:23:48,580
must be true then but I've never

00:23:43,750 --> 00:23:51,490
verified it were the reasons listed here

00:23:48,580 --> 00:23:54,970
but this is a quote from the author of

00:23:51,490 --> 00:23:58,140
the library so the kind of features that

00:23:54,970 --> 00:24:03,220
cannot be accommodated within the design

00:23:58,140 --> 00:24:05,530
leading zeros or other padding octal

00:24:03,220 --> 00:24:08,590
hexadecimal encoding runtime with

00:24:05,530 --> 00:24:15,070
alignment which seems very restrictive

00:24:08,590 --> 00:24:16,060
and makes one scratch one's head so how

00:24:15,070 --> 00:24:19,180
is it possible

00:24:16,060 --> 00:24:22,990
fortunately the author came up with a

00:24:19,180 --> 00:24:25,300
solution with the same article so the

00:24:22,990 --> 00:24:28,870
way you work around this limitation is

00:24:25,300 --> 00:24:31,380
by wrapping arguments together with kind

00:24:28,870 --> 00:24:36,880
of firm as specifiers represented in

00:24:31,380 --> 00:24:38,830
code so to speak and pass this wrapper

00:24:36,880 --> 00:24:41,680
object instead of the actual argument

00:24:38,830 --> 00:24:43,780
but now I fail to see how is it better

00:24:41,680 --> 00:24:49,110
than our streams it's even more verbose

00:24:43,780 --> 00:24:49,110
now it has some advantages for example

00:24:49,380 --> 00:24:59,860
it's non sticky flags but and also we

00:24:55,450 --> 00:25:05,500
have atomicity but otherwise it doesn't

00:24:59,860 --> 00:25:07,360
look very appealing so having looked at

00:25:05,500 --> 00:25:11,830
all the current solutions and

00:25:07,360 --> 00:25:17,860
limitations let's take a look at the

00:25:11,830 --> 00:25:21,940
proposed future or the p0 645 our

00:25:17,860 --> 00:25:23,860
revision number standard proposal text

00:25:21,940 --> 00:25:26,380
formatting which is based on the FMT

00:25:23,860 --> 00:25:29,640
library I've been working on the last

00:25:26,380 --> 00:25:29,640
few years and

00:25:30,120 --> 00:25:37,679
the motivation for this proposal is to

00:25:34,110 --> 00:25:40,529
have an alternative to the printf family

00:25:37,679 --> 00:25:44,370
function particularly as printf which is

00:25:40,529 --> 00:25:46,440
safe extensible and fast also it should

00:25:44,370 --> 00:25:48,809
be interoperable with our streams we

00:25:46,440 --> 00:25:53,520
don't want to get rid of i/o streams at

00:25:48,809 --> 00:25:59,340
all we'd like to have small code size

00:25:53,520 --> 00:26:02,100
and reasonable compile times have some

00:25:59,340 --> 00:26:07,679
local control and have some expressive

00:26:02,100 --> 00:26:08,909
syntax for our format strings so as I

00:26:07,679 --> 00:26:12,360
said this is not an ice-cream

00:26:08,909 --> 00:26:15,120
replacement so if you invest it in it's

00:26:12,360 --> 00:26:17,520
a two featuring i/o streams you won't

00:26:15,120 --> 00:26:20,970
need to get rid of it or camouflage it

00:26:17,520 --> 00:26:25,559
with flowers or butterflies so it was

00:26:20,970 --> 00:26:30,659
good so let me show you a few examples

00:26:25,559 --> 00:26:34,220
that introduce the syntax so they format

00:26:30,659 --> 00:26:39,450
string use the brace delimited

00:26:34,220 --> 00:26:47,690
replacement field like in this example I

00:26:39,450 --> 00:26:51,899
think it's pretty self describing also

00:26:47,690 --> 00:26:54,299
you can use positional arguments within

00:26:51,899 --> 00:26:56,159
the braces you can refer to arguments

00:26:54,299 --> 00:27:01,700
with their indices starting from zero

00:26:56,159 --> 00:27:03,390
and you can use format specifiers

00:27:01,700 --> 00:27:08,820
similar to print halves

00:27:03,390 --> 00:27:13,950
after the colon like in the example at

00:27:08,820 --> 00:27:18,409
the bottom of course you can have with

00:27:13,950 --> 00:27:21,750
either specified in the format string

00:27:18,409 --> 00:27:29,179
were dynamically you can refer to an

00:27:21,750 --> 00:27:32,730
argument that gives the output width and

00:27:29,179 --> 00:27:34,799
similarly you can have precision

00:27:32,730 --> 00:27:37,860
specified in the format string or

00:27:34,799 --> 00:27:43,950
dynamically the way you do it is is

00:27:37,860 --> 00:27:46,500
after the point you specify the width

00:27:43,950 --> 00:27:52,559
I deliberately were referring to an

00:27:46,500 --> 00:27:54,570
argument also you can use three types of

00:27:52,559 --> 00:27:56,850
alignments in fact there are four times

00:27:54,570 --> 00:28:01,250
alignments but the fourth numeric

00:27:56,850 --> 00:28:04,049
alignment is complicated so well I won't

00:28:01,250 --> 00:28:06,059
talk about it in this talk in the

00:28:04,049 --> 00:28:08,100
interest of time so we have left right

00:28:06,059 --> 00:28:10,049
and center alignment which is an

00:28:08,100 --> 00:28:15,330
improvement compared to printf we

00:28:10,049 --> 00:28:17,370
doesn't have central island I've never

00:28:15,330 --> 00:28:21,240
used central island myself but I've

00:28:17,370 --> 00:28:24,720
heard it can be useful sometimes and you

00:28:21,240 --> 00:28:28,580
can have fuel and alignment which is

00:28:24,720 --> 00:28:36,090
even more cool you can do some kind of

00:28:28,580 --> 00:28:39,450
ASCII art or you might find the syntax

00:28:36,090 --> 00:28:46,880
familiar because it's largely based on

00:28:39,450 --> 00:28:50,279
Python particularly Python STR format

00:28:46,880 --> 00:28:54,330
because they also have the cent

00:28:50,279 --> 00:28:57,299
formatting similar to printf it is more

00:28:54,330 --> 00:29:00,779
expressive than printf in particularly

00:28:57,299 --> 00:29:03,149
you have feelings Center alignment but

00:29:00,779 --> 00:29:07,370
from a specifiers are similar to print

00:29:03,149 --> 00:29:10,440
halves and almost everything that you

00:29:07,370 --> 00:29:13,200
can write after percent in printf you

00:29:10,440 --> 00:29:17,059
can write after colon in this format

00:29:13,200 --> 00:29:24,450
syntax which simplifies migration and

00:29:17,059 --> 00:29:28,440
makes it easier to learn but at the same

00:29:24,450 --> 00:29:29,940
time the type is optional because we use

00:29:28,440 --> 00:29:37,620
very attic templates we know the types

00:29:29,940 --> 00:29:40,549
you don't need to repeat yourself what

00:29:37,620 --> 00:29:40,549
do you mean by conflict

00:29:43,130 --> 00:29:51,560
if you say s and a float it will throw

00:29:45,200 --> 00:29:54,830
an exception the syntax is so simple

00:29:51,560 --> 00:29:59,480
that it fits on a single slide even part

00:29:54,830 --> 00:30:02,150
of the slide so I won't go into too much

00:29:59,480 --> 00:30:06,170
details there's fill alignment I think

00:30:02,150 --> 00:30:10,270
you got the idea from the examples it's

00:30:06,170 --> 00:30:15,380
very easy to parse like boost format the

00:30:10,270 --> 00:30:18,980
it's very consistent as simple

00:30:15,380 --> 00:30:21,860
it also supports named arguments in

00:30:18,980 --> 00:30:24,320
addition to positional arguments this is

00:30:21,860 --> 00:30:31,610
not included in the status proposal to

00:30:24,320 --> 00:30:36,380
make it reasonably compact but it can be

00:30:31,610 --> 00:30:41,020
added later so the way you use named

00:30:36,380 --> 00:30:45,140
arguments is inside the curly braces you

00:30:41,020 --> 00:30:47,390
give the name and then in the arguments

00:30:45,140 --> 00:30:51,560
you wrap your arguments together with

00:30:47,390 --> 00:30:54,980
the name in the arc function and also

00:30:51,560 --> 00:31:02,390
someone implemented user-defined literal

00:30:54,980 --> 00:31:04,910
version of it which I won't show but you

00:31:02,390 --> 00:31:08,000
can find the examples on the in the

00:31:04,910 --> 00:31:11,180
documentation and in the paper not in

00:31:08,000 --> 00:31:13,550
the paper sorry so why do we need with

00:31:11,180 --> 00:31:17,660
the new syntax why not just use printf

00:31:13,550 --> 00:31:20,600
so the reason is that we'd like to avoid

00:31:17,660 --> 00:31:26,960
all the legacy stuff all this horrible

00:31:20,600 --> 00:31:29,810
macros and things like ll and PR I you

00:31:26,960 --> 00:31:33,740
64 which is not even correct here

00:31:29,810 --> 00:31:36,860
because this is a sign integer so

00:31:33,740 --> 00:31:39,520
instead we just want to write curly

00:31:36,860 --> 00:31:42,110
braces and let the compiler figure out

00:31:39,520 --> 00:31:44,960
unless we want to customize our

00:31:42,110 --> 00:31:46,820
formatting then we use colon and say how

00:31:44,960 --> 00:31:51,560
we want our nice arguments to be

00:31:46,820 --> 00:31:54,950
formatted so we want the specifiers to

00:31:51,560 --> 00:31:55,549
be semantical to convey formatting

00:31:54,950 --> 00:31:57,889
information

00:31:55,549 --> 00:32:02,179
no type information for example D means

00:31:57,889 --> 00:32:05,869
decimal formatting no decimal int if you

00:32:02,179 --> 00:32:07,850
see the subtle difference and also

00:32:05,869 --> 00:32:12,200
something that I called bring your own

00:32:07,850 --> 00:32:16,360
grammar so you as a user can extend

00:32:12,200 --> 00:32:23,529
format string grammar for your own types

00:32:16,360 --> 00:32:28,929
and I show how to do this in this slide

00:32:23,529 --> 00:32:33,320
so The Replacements field consists of

00:32:28,929 --> 00:32:36,470
curly brackets the argument ID which can

00:32:33,320 --> 00:32:39,109
be an index or a name followed by colon

00:32:36,470 --> 00:32:44,029
and format spec and for mass spec is

00:32:39,109 --> 00:32:48,019
well defined for standard types

00:32:44,029 --> 00:32:51,649
well built-in types but for user-defined

00:32:48,019 --> 00:32:55,970
types you can interpret it however you

00:32:51,649 --> 00:32:58,519
like and write your own parser the way

00:32:55,970 --> 00:33:03,399
you do it well the way you used to do it

00:32:58,519 --> 00:33:07,429
because the extension API is changing

00:33:03,399 --> 00:33:11,210
was to provide it format value function

00:33:07,429 --> 00:33:14,210
which took a buffer where you wrote you

00:33:11,210 --> 00:33:16,489
your output the arguments in this case

00:33:14,210 --> 00:33:21,919
you just pass the time

00:33:16,489 --> 00:33:24,889
TMS object and a context the context

00:33:21,919 --> 00:33:26,720
provides access to the portion of the

00:33:24,889 --> 00:33:29,239
format string being parsed and other

00:33:26,720 --> 00:33:32,149
arguments why you need other arguments

00:33:29,239 --> 00:33:38,269
for things like dynamic with dynamic

00:33:32,149 --> 00:33:42,109
precision so but if it sounds too

00:33:38,269 --> 00:33:45,649
complicated then you don't have to do

00:33:42,109 --> 00:33:50,090
this you can just implement overloaded

00:33:45,649 --> 00:33:54,289
operator less less word insertion

00:33:50,090 --> 00:33:59,539
operator taking Ostrom and your object

00:33:54,289 --> 00:34:05,179
of your tab week standard iostream way

00:33:59,539 --> 00:34:09,999
of implementing formatting of your types

00:34:05,179 --> 00:34:09,999
and it will fall back to this separator

00:34:11,429 --> 00:34:19,899
so why this particular syndics it has

00:34:16,030 --> 00:34:22,450
been proven to work to Python design do

00:34:19,899 --> 00:34:25,179
this many language went to great lengths

00:34:22,450 --> 00:34:27,760
to implement it and test its in

00:34:25,179 --> 00:34:30,780
production and it worked out very well

00:34:27,760 --> 00:34:34,470
they wanted to deprecate old percent

00:34:30,780 --> 00:34:38,110
princess like formatting they didn't but

00:34:34,470 --> 00:34:42,090
for computability reasons but they are

00:34:38,110 --> 00:34:44,380
in a more difficult state because

00:34:42,090 --> 00:34:49,060
percent formatting in python is less

00:34:44,380 --> 00:34:51,669
broken than printf in c and c++ it's

00:34:49,060 --> 00:34:55,080
just a little bit broken so there are

00:34:51,669 --> 00:34:57,460
fewer reasons to migrate to the new

00:34:55,080 --> 00:35:00,160
there were fewer reasons to migrate to

00:34:57,460 --> 00:35:02,680
this new syntax and still it was very

00:35:00,160 --> 00:35:08,290
popular it was so popular that other

00:35:02,680 --> 00:35:11,650
languages like rust adopted it and there

00:35:08,290 --> 00:35:14,850
are several popular C++ implementation

00:35:11,650 --> 00:35:22,510
the FMT library I'm talking about and

00:35:14,850 --> 00:35:26,140
fully format and the API is fully

00:35:22,510 --> 00:35:29,260
typesafe no verax nonsense just faradic

00:35:26,140 --> 00:35:33,550
templates so we have the format function

00:35:29,260 --> 00:35:37,150
which is the main API function which

00:35:33,550 --> 00:35:40,600
takes a format string and arbitrary

00:35:37,150 --> 00:35:43,540
arguments and returns an STD string if

00:35:40,600 --> 00:35:45,220
you want to be efficient you want you

00:35:43,540 --> 00:35:49,000
don't want to allocate a steady string

00:35:45,220 --> 00:35:50,620
maybe you want to write to a buffer

00:35:49,000 --> 00:35:53,590
allocated on stack

00:35:50,620 --> 00:35:57,880
something then you can use the format to

00:35:53,590 --> 00:36:03,010
function which takes a buffer and again

00:35:57,880 --> 00:36:05,860
a format string and arguments so the

00:36:03,010 --> 00:36:08,230
memory management is automatic which

00:36:05,860 --> 00:36:10,060
prevents the whole range of errors so

00:36:08,230 --> 00:36:13,840
the buffer concept represents a

00:36:10,060 --> 00:36:18,550
contiguous memory buffer memory range

00:36:13,840 --> 00:36:21,400
with efficient access with only one call

00:36:18,550 --> 00:36:23,380
a virtual function call if you need to

00:36:21,400 --> 00:36:27,229
grow

00:36:23,380 --> 00:36:32,269
it can have limited capacity and report

00:36:27,229 --> 00:36:35,119
an errand growth were we can grow

00:36:32,269 --> 00:36:41,709
dynamically and it has also an

00:36:35,119 --> 00:36:46,039
Associated local so here's an simplified

00:36:41,709 --> 00:36:51,380
version of the buffer class so we have

00:36:46,039 --> 00:36:54,410
size capacity resize access to data this

00:36:51,380 --> 00:36:58,699
is very simplified just to give an idea

00:36:54,410 --> 00:37:02,420
and the only two virtual functions one

00:36:58,699 --> 00:37:05,420
when you hit the capacity you called

00:37:02,420 --> 00:37:08,089
grow and now the reallocate were for an

00:37:05,420 --> 00:37:10,569
error and also a virtual function to get

00:37:08,089 --> 00:37:10,569
do a call

00:37:10,660 --> 00:37:17,660
so now let's go a little bit deeper and

00:37:15,559 --> 00:37:20,390
take a look at the format function how

00:37:17,660 --> 00:37:24,890
it is implemented and if you look at it

00:37:20,390 --> 00:37:28,549
it's just forwards to V format which is

00:37:24,890 --> 00:37:33,829
very similar to printf V printf in some

00:37:28,549 --> 00:37:35,449
sense so so Fermat calls V format with

00:37:33,829 --> 00:37:40,369
the same format string and it wraps

00:37:35,449 --> 00:37:45,009
arguments you know object called arc

00:37:40,369 --> 00:37:48,049
store which represents a an array of

00:37:45,009 --> 00:37:50,779
references or copies with the argument

00:37:48,049 --> 00:37:55,849
is civil of reference to you arguments

00:37:50,779 --> 00:38:00,799
and to build this Ark store we call make

00:37:55,849 --> 00:38:03,979
arcs function and the V format function

00:38:00,799 --> 00:38:08,329
takes not arcs store but the kind of

00:38:03,979 --> 00:38:16,130
view of this object which is similar to

00:38:08,329 --> 00:38:19,939
say array view and notice that we format

00:38:16,130 --> 00:38:27,549
is not parameterised on the types which

00:38:19,939 --> 00:38:30,829
might be surprising and why is it so so

00:38:27,549 --> 00:38:32,959
this slide shows the kind of

00:38:30,829 --> 00:38:35,760
implementation details but I think it's

00:38:32,959 --> 00:38:38,100
so interesting

00:38:35,760 --> 00:38:40,680
if we have small number of arguments we

00:38:38,100 --> 00:38:44,609
can take all the types together and pack

00:38:40,680 --> 00:38:49,770
them in a single integer and store a

00:38:44,609 --> 00:38:56,520
pointer and have a pointer to an array

00:38:49,770 --> 00:38:59,670
of pointers or copies of arguments so so

00:38:56,520 --> 00:39:05,820
arguments store can be sort of as a as

00:38:59,670 --> 00:39:09,060
an array of variants and on the left is

00:39:05,820 --> 00:39:12,240
kind of compact representation of it and

00:39:09,060 --> 00:39:15,650
on the right is expanded representation

00:39:12,240 --> 00:39:20,040
if the number of arguments is big and

00:39:15,650 --> 00:39:23,900
they don't fit all the types don't fit

00:39:20,040 --> 00:39:28,880
in one integer so why do this

00:39:23,900 --> 00:39:35,460
it helps greatly with compile times and

00:39:28,880 --> 00:39:39,630
code bloat it makes the perfunctory code

00:39:35,460 --> 00:39:43,290
very small comparable to printf so when

00:39:39,630 --> 00:39:46,050
you call printf you often have an

00:39:43,290 --> 00:39:49,410
integer past represented the number of

00:39:46,050 --> 00:39:51,390
arguments passed anyway so here we have

00:39:49,410 --> 00:39:57,980
the integer representing all your

00:39:51,390 --> 00:40:00,240
argument types so you have similar

00:39:57,980 --> 00:40:03,359
binary code printf is a little bit

00:40:00,240 --> 00:40:11,359
better because VAR arcs pass more stuff

00:40:03,359 --> 00:40:13,710
in registers so another thing is that

00:40:11,359 --> 00:40:17,270
this kind of type erasure

00:40:13,710 --> 00:40:20,550
method prevents code blow so instead of

00:40:17,270 --> 00:40:23,960
instantiating instantiating all your

00:40:20,550 --> 00:40:25,910
formatting code on all combinations of

00:40:23,960 --> 00:40:32,490
arguments you have just one

00:40:25,910 --> 00:40:34,100
instantiation so why do we need all this

00:40:32,490 --> 00:40:36,960
stuff

00:40:34,100 --> 00:40:40,020
let's benchmark and see whether it

00:40:36,960 --> 00:40:43,470
really helps we're just hand waving so I

00:40:40,020 --> 00:40:46,859
wrote this little benchmark which might

00:40:43,470 --> 00:40:47,810
be a little bit cryptic but let me guide

00:40:46,859 --> 00:40:52,250
you through it

00:40:47,810 --> 00:40:56,270
so what it does it calls the format

00:40:52,250 --> 00:40:59,840
function for 125 combinations different

00:40:56,270 --> 00:41:04,160
combinations of argument types so this

00:40:59,840 --> 00:41:09,380
Jen arts functions function at the top

00:41:04,160 --> 00:41:11,660
just calls F with five arbitrary objects

00:41:09,380 --> 00:41:14,890
the only thing they just need to be of

00:41:11,660 --> 00:41:17,750
different types and then we combine them

00:41:14,890 --> 00:41:20,740
between all possible combinations so 5

00:41:17,750 --> 00:41:25,880
to the power of 3 we have 125

00:41:20,740 --> 00:41:28,400
combinations and now what do we compare

00:41:25,880 --> 00:41:30,040
it against we can measure our

00:41:28,400 --> 00:41:33,770
implementation the FMT

00:41:30,040 --> 00:41:36,370
library but I don't want to go and we

00:41:33,770 --> 00:41:39,040
implement everything passing the

00:41:36,370 --> 00:41:42,250
parameter rising everything in templates

00:41:39,040 --> 00:41:44,570
moreover I can do it inefficiently

00:41:42,250 --> 00:41:48,590
intentionally to show how good my method

00:41:44,570 --> 00:41:49,300
is fortunately a fully format comes to

00:41:48,590 --> 00:41:53,900
the rescue

00:41:49,300 --> 00:41:57,130
they they did exactly that they passed

00:41:53,900 --> 00:42:00,770
all the arguments throughout the

00:41:57,130 --> 00:42:05,770
formatting code and that's what we are

00:42:00,770 --> 00:42:10,310
going to compare against so this is

00:42:05,770 --> 00:42:14,330
optimized clang build with and debug

00:42:10,310 --> 00:42:17,990
everything is linked dynamically and as

00:42:14,330 --> 00:42:21,460
you can see there is a tremendous

00:42:17,990 --> 00:42:25,540
improvement both in compile time and

00:42:21,460 --> 00:42:32,210
binary sighs so the compile time is

00:42:25,540 --> 00:42:35,450
roughly 6 or something times better

00:42:32,210 --> 00:42:40,340
compared to fully when we apply this

00:42:35,450 --> 00:42:43,310
type of technique and the binary code

00:42:40,340 --> 00:42:47,510
size is by the order of magnitude better

00:42:43,310 --> 00:42:49,430
and this is just formatting code so I

00:42:47,510 --> 00:42:53,300
don't know about you but I don't want

00:42:49,430 --> 00:42:57,050
100 calls to formatting function to take

00:42:53,300 --> 00:43:00,980
one megabyte of space so what we can

00:42:57,050 --> 00:43:01,809
learn about that I think the lesson is

00:43:00,980 --> 00:43:03,930
use very

00:43:01,809 --> 00:43:06,279
examples judiciously don't pass them

00:43:03,930 --> 00:43:12,239
unnecessary and necessarily throughout

00:43:06,279 --> 00:43:15,459
all of your code so a few more

00:43:12,239 --> 00:43:18,189
benchmarks so this one is interesting

00:43:15,459 --> 00:43:20,920
this tries to be realistic

00:43:18,189 --> 00:43:23,439
I like the previous one which I which

00:43:20,920 --> 00:43:28,859
tried to fit on the slide so there are

00:43:23,439 --> 00:43:31,359
100 translation units with five calls to

00:43:28,859 --> 00:43:35,049
formatting functions per translation

00:43:31,359 --> 00:43:40,420
unit and no other code this is optimized

00:43:35,049 --> 00:43:45,809
build and as you can see boost format

00:43:40,420 --> 00:43:48,279
goes through the roof the FMT library

00:43:45,809 --> 00:43:52,239
which is the basis of the status

00:43:48,279 --> 00:43:54,939
proposal is a little bit worse than

00:43:52,239 --> 00:43:57,549
print half it used to be better before I

00:43:54,939 --> 00:44:01,509
switch to string view because now we

00:43:57,549 --> 00:44:03,999
have to pass an extra size argument

00:44:01,509 --> 00:44:05,589
compared to previous when we just passed

00:44:03,999 --> 00:44:06,130
a null-terminated string there is a

00:44:05,589 --> 00:44:08,289
trade-off

00:44:06,130 --> 00:44:10,299
now the API is more convenient because

00:44:08,289 --> 00:44:14,489
you don't have to pass a null terminated

00:44:10,299 --> 00:44:16,689
string but you pay a little bit for it

00:44:14,489 --> 00:44:21,549
but I think the price to pay is very

00:44:16,689 --> 00:44:24,339
little and if it only matters if you

00:44:21,549 --> 00:44:30,630
operate in a very resource constrained

00:44:24,339 --> 00:44:34,989
environment and in this case you can

00:44:30,630 --> 00:44:41,529
obviously provide overloads taking null

00:44:34,989 --> 00:44:43,839
terminated strings so one thing to

00:44:41,529 --> 00:44:48,130
mention is the Foley format doesn't

00:44:43,839 --> 00:44:51,189
perform that bad here because there are

00:44:48,130 --> 00:44:53,499
fewer combinations of types so all these

00:44:51,189 --> 00:44:56,439
there are only 5 different combinations

00:44:53,499 --> 00:45:02,559
of types in this benchmark and like 125

00:44:56,439 --> 00:45:04,799
but it's still quite big difference here

00:45:02,559 --> 00:45:07,340
is a benchmark showing compile-time

00:45:04,799 --> 00:45:10,160
performance

00:45:07,340 --> 00:45:17,330
unfortunately with compile-time we there

00:45:10,160 --> 00:45:21,350
is that much we can do so printf beats

00:45:17,330 --> 00:45:25,190
everyone obviously I think we can get to

00:45:21,350 --> 00:45:26,930
the level of fire streams in fact it

00:45:25,190 --> 00:45:29,630
used to be on the level of i/o streams

00:45:26,930 --> 00:45:36,650
until some recently regression and I

00:45:29,630 --> 00:45:39,470
think we can bring it back down but it

00:45:36,650 --> 00:45:47,270
still performs significantly better than

00:45:39,470 --> 00:45:50,180
other formatting libraries and a lot of

00:45:47,270 --> 00:45:53,390
efforts have been put into optimizing

00:45:50,180 --> 00:45:57,010
compile times particularly by the

00:45:53,390 --> 00:45:59,840
Moldovan who has done great research and

00:45:57,010 --> 00:46:04,190
investigated different ways of

00:45:59,840 --> 00:46:07,160
optimizing compile times and even put

00:46:04,190 --> 00:46:11,410
out put together these graphs of compile

00:46:07,160 --> 00:46:18,350
times like over the number of arguments

00:46:11,410 --> 00:46:20,600
this is on clang and the way it was

00:46:18,350 --> 00:46:22,910
optimized is by replacing a template

00:46:20,600 --> 00:46:26,770
recursion with the verdict array

00:46:22,910 --> 00:46:31,720
initialization instantly it didn't give

00:46:26,770 --> 00:46:36,290
such a big improvement GCC and clang

00:46:31,720 --> 00:46:40,100
also it's more noticeable if you use

00:46:36,290 --> 00:46:49,180
very large number of arguments like 10

00:46:40,100 --> 00:46:53,000
or 12 now more kind of traditional

00:46:49,180 --> 00:46:58,460
benchmark runtime performance as you can

00:46:53,000 --> 00:47:02,930
see fmtb forms maybe within 10 something

00:46:58,460 --> 00:47:04,670
percent compared to printf and better

00:47:02,930 --> 00:47:06,980
than our streams and other formatting

00:47:04,670 --> 00:47:09,590
libraries I streams before for some

00:47:06,980 --> 00:47:12,230
reason particularly bad on this platform

00:47:09,590 --> 00:47:15,050
which is Mac OS with lying on the Linux

00:47:12,230 --> 00:47:16,549
two dishes GCC the difference was not

00:47:15,050 --> 00:47:23,359
that profound

00:47:16,549 --> 00:47:25,339
and one thing to mention is that there

00:47:23,359 --> 00:47:29,890
is nothing in the design of the library

00:47:25,339 --> 00:47:32,869
that makes it impossible to bid printf

00:47:29,890 --> 00:47:36,979
in fact this particular benchmark is

00:47:32,869 --> 00:47:39,679
largely dominated by formatting a

00:47:36,979 --> 00:47:42,380
floating-point numbers and for

00:47:39,679 --> 00:47:45,829
floating-point fmt currently falls back

00:47:42,380 --> 00:47:47,749
to s printf so it cannot be better than

00:47:45,829 --> 00:47:50,719
printf but for integer formatting I

00:47:47,749 --> 00:47:53,299
showed in some other benchmarks that was

00:47:50,719 --> 00:48:01,279
possible to beat printf even with

00:47:53,299 --> 00:48:02,660
allocation of string so and you can of

00:48:01,279 --> 00:48:05,329
course write your own formatting

00:48:02,660 --> 00:48:08,890
functions similar to format let's say

00:48:05,329 --> 00:48:13,429
you want to write a function that takes

00:48:08,890 --> 00:48:16,339
an error code and a format string and

00:48:13,429 --> 00:48:21,140
some arguments and writes the leads to a

00:48:16,339 --> 00:48:22,789
log so you can apply either make it very

00:48:21,140 --> 00:48:24,709
attic if you don't care about compile

00:48:22,789 --> 00:48:28,910
times or anything or you can apply the

00:48:24,709 --> 00:48:33,859
same technique to your own code and get

00:48:28,910 --> 00:48:37,249
the same benefits so work-in-progress

00:48:33,859 --> 00:48:39,079
is separation of parsing and formatting

00:48:37,249 --> 00:48:40,670
in the extension API so instead of

00:48:39,079 --> 00:48:42,529
format value function that I showed

00:48:40,670 --> 00:48:45,890
before that does everything parsing and

00:48:42,529 --> 00:48:48,499
formatting we want to be able to

00:48:45,890 --> 00:48:50,239
specialize this formatter object have a

00:48:48,499 --> 00:48:52,429
separate function that does parsing

00:48:50,239 --> 00:48:56,839
separate functions it does formatting

00:48:52,429 --> 00:49:00,049
and between these two you can store the

00:48:56,839 --> 00:49:03,349
states in the object itself and you can

00:49:00,049 --> 00:49:05,509
reuse standard format as you can for

00:49:03,349 --> 00:49:09,650
example inherit here for matter from

00:49:05,509 --> 00:49:13,059
formatter int and use this a and get the

00:49:09,650 --> 00:49:16,279
same parse method and only lets say

00:49:13,059 --> 00:49:19,429
provide the format method for example if

00:49:16,279 --> 00:49:22,539
your object is just some kind of wrapper

00:49:19,429 --> 00:49:22,539
around round int

00:49:22,580 --> 00:49:27,410
other things I'm looking into is

00:49:25,080 --> 00:49:30,840
compile-time from s string checks and

00:49:27,410 --> 00:49:34,170
range based interface so let's take a

00:49:30,840 --> 00:49:37,080
look at the new extension API here's a

00:49:34,170 --> 00:49:41,580
little example let's say you want to

00:49:37,080 --> 00:49:46,320
format a vector of some objects of

00:49:41,580 --> 00:49:49,620
arbitrary type so you so you specialize

00:49:46,320 --> 00:49:53,900
the formatter struct and inherited from

00:49:49,620 --> 00:49:56,910
the format of T and you don't need to

00:49:53,900 --> 00:50:03,410
provide the parse method let's say you

00:49:56,910 --> 00:50:10,230
just want to reuse the versing for the

00:50:03,410 --> 00:50:17,970
of the from a string for the for the

00:50:10,230 --> 00:50:23,010
vector from the formatter of T so you

00:50:17,970 --> 00:50:25,710
only provide the format method and the

00:50:23,010 --> 00:50:30,570
way you implement it you just try to

00:50:25,710 --> 00:50:36,240
buffer a brace delimited comma separated

00:50:30,570 --> 00:50:39,090
list of values and you just delegate all

00:50:36,240 --> 00:50:41,490
the work to the formatter of T it is

00:50:39,090 --> 00:50:46,350
very simple it fits on the slide and it

00:50:41,490 --> 00:50:50,670
can be used as shown below of course if

00:50:46,350 --> 00:50:53,220
you want more advanced features you can

00:50:50,670 --> 00:50:56,070
have a different syntax you can

00:50:53,220 --> 00:50:58,980
implement your parse method and I don't

00:50:56,070 --> 00:51:03,990
know customize separator instead of

00:50:58,980 --> 00:51:09,660
hard-coding comma here but that's up to

00:51:03,990 --> 00:51:13,100
you so the migration will we ever be

00:51:09,660 --> 00:51:16,830
able to migrate from feed off I think

00:51:13,100 --> 00:51:18,870
that it might be possible here some of

00:51:16,830 --> 00:51:20,700
the ideas so there is an easy mapping

00:51:18,870 --> 00:51:23,250
between the printer from this menu

00:51:20,700 --> 00:51:25,950
language and we can come up with a

00:51:23,250 --> 00:51:27,800
compatibility library which with printf

00:51:25,950 --> 00:51:30,060
like semantics

00:51:27,800 --> 00:51:33,150
particularly that returns error codes

00:51:30,060 --> 00:51:35,720
and in other ways it's similar to printf

00:51:33,150 --> 00:51:35,720
and maybe even

00:51:37,410 --> 00:51:42,760
well we won't make a drop-in replacement

00:51:40,360 --> 00:51:45,790
probably but we can have a tool like

00:51:42,760 --> 00:51:48,310
clunky a tidy which goes over your

00:51:45,790 --> 00:51:54,190
codebase and transform literal strings

00:51:48,310 --> 00:51:58,090
into this new format so so with this

00:51:54,190 --> 00:52:00,340
proposal I went to the Toronto Standards

00:51:58,090 --> 00:52:06,310
Committee meeting and presented and my

00:52:00,340 --> 00:52:08,500
main goal was to get an kind of initial

00:52:06,310 --> 00:52:10,180
feedback and understand whether people

00:52:08,500 --> 00:52:14,020
want this and this standard should I

00:52:10,180 --> 00:52:17,320
work on this or go on with my life but

00:52:14,020 --> 00:52:20,110
unfortunately for my life it was fairly

00:52:17,320 --> 00:52:25,950
well received and I've been encouraged

00:52:20,110 --> 00:52:30,190
to continue and working on a revision of

00:52:25,950 --> 00:52:33,460
the proposal so a little bit about the

00:52:30,190 --> 00:52:40,510
library itself so you can find it on

00:52:33,460 --> 00:52:43,150
github FMT weeb / fmt there is also a

00:52:40,510 --> 00:52:47,260
website fmt dotnet with the

00:52:43,150 --> 00:52:50,560
documentation there have been many

00:52:47,260 --> 00:52:58,150
contributors which I'm very grateful to

00:52:50,560 --> 00:53:00,250
and some people took time and packaged

00:52:58,150 --> 00:53:03,670
the library for all major Linux

00:53:00,250 --> 00:53:08,500
distributions for homebrew and you get

00:53:03,670 --> 00:53:11,020
and you can find the implementation of

00:53:08,500 --> 00:53:20,110
the standard proposal in a separate

00:53:11,020 --> 00:53:24,910
branch called sdd a bit of history more

00:53:20,110 --> 00:53:26,680
history so we started in 2012 and the

00:53:24,910 --> 00:53:31,150
lead originally the library was called

00:53:26,680 --> 00:53:33,970
cpp format it was inspired by formatting

00:53:31,150 --> 00:53:35,980
facilities and clang that's kind of

00:53:33,970 --> 00:53:38,230
surprising I don't even remember what

00:53:35,980 --> 00:53:40,480
the facilities where I just remember

00:53:38,230 --> 00:53:42,220
this fact and back then the library

00:53:40,480 --> 00:53:44,730
looked completely different it didn't

00:53:42,220 --> 00:53:48,049
use very attic templates it used weird

00:53:44,730 --> 00:53:54,619
operator overloading it

00:53:48,049 --> 00:53:57,259
I until I figured out how to emulate

00:53:54,619 --> 00:54:00,849
heretic templates with varrick macros

00:53:57,259 --> 00:54:06,769
for compatibility this tip was passed 98

00:54:00,849 --> 00:54:11,089
so since around mid 2016 main focus was

00:54:06,769 --> 00:54:15,769
on the standard proposal and that's why

00:54:11,089 --> 00:54:18,619
you don't see very many commits or

00:54:15,769 --> 00:54:21,199
activity in the timeline because this

00:54:18,619 --> 00:54:28,369
shows the master branch and all the work

00:54:21,199 --> 00:54:32,239
is done in the STD branch and there's

00:54:28,369 --> 00:54:35,599
been a lot of projects using fmt here's

00:54:32,239 --> 00:54:39,049
a small selection one in particular that

00:54:35,599 --> 00:54:42,469
I want to draw your attention at is SPD

00:54:39,049 --> 00:54:47,119
lock which is a great logging library so

00:54:42,469 --> 00:54:51,289
many people don't feel don't even

00:54:47,119 --> 00:54:53,929
realize that they they use fmt they get

00:54:51,289 --> 00:54:59,539
it through SPD log which is fine by me

00:54:53,929 --> 00:55:02,599
because I get fewer bug report know with

00:54:59,539 --> 00:55:05,410
all the bug reports and up and fmt the

00:55:02,599 --> 00:55:11,150
author of SPD walk is very thorough

00:55:05,410 --> 00:55:14,859
so so thank you for the attention and if

00:55:11,150 --> 00:55:14,859
you have any questions feel free to ask

00:55:19,730 --> 00:55:29,270
[Applause]

00:55:25,850 --> 00:55:33,890
yeah I have a question yes about

00:55:29,270 --> 00:55:38,970
formatting the floating-point numbers

00:55:33,890 --> 00:55:42,840
isn't there like another way to do that

00:55:38,970 --> 00:55:45,180
without going to s printf like a

00:55:42,840 --> 00:55:46,980
standalone library I'm not an expert I

00:55:45,180 --> 00:55:49,110
think I saw something that's not going

00:55:46,980 --> 00:55:52,770
through see later yes so the question is

00:55:49,110 --> 00:55:54,510
whether there is another way to do

00:55:52,770 --> 00:55:58,140
formatting or floating-point numbers

00:55:54,510 --> 00:56:01,020
without going through Sprint F so yes

00:55:58,140 --> 00:56:03,720
for example we can implement grease ooh

00:56:01,020 --> 00:56:07,650
algorithm or use a double conversion

00:56:03,720 --> 00:56:09,660
library which does this and not rely on

00:56:07,650 --> 00:56:15,000
as print effort that's actually one of

00:56:09,660 --> 00:56:17,640
the items on my to-do list maybe I'll do

00:56:15,000 --> 00:56:18,710
it sometime another question I was I was

00:56:17,640 --> 00:56:21,630
just looking through the github

00:56:18,710 --> 00:56:24,660
interpretation for you know common

00:56:21,630 --> 00:56:26,160
compile time bottlenecks and you're not

00:56:24,660 --> 00:56:28,260
doing a lot of template metaprogramming

00:56:26,160 --> 00:56:34,440
do you have them do you know what what's

00:56:28,260 --> 00:56:36,450
taking a long time in compiled time so

00:56:34,440 --> 00:56:43,340
the question is do I know what's taking

00:56:36,450 --> 00:56:48,750
a long time in a long compile time I

00:56:43,340 --> 00:56:51,270
haven't looked at it recently so last

00:56:48,750 --> 00:56:54,450
time we looked at it there was a problem

00:56:51,270 --> 00:56:58,700
when we used the recursive kind of

00:56:54,450 --> 00:57:02,820
template stuff right now I'm not sure

00:56:58,700 --> 00:57:05,790
what exactly contributing to compile

00:57:02,820 --> 00:57:12,150
times would appreciate if anyone knows a

00:57:05,790 --> 00:57:15,660
good way to debug a kind of perf compile

00:57:12,150 --> 00:57:20,030
times I think is a clean extension but

00:57:15,660 --> 00:57:20,030
yeah yeah it would be interesting

00:57:36,130 --> 00:57:42,260
so if I understood you a question if

00:57:39,799 --> 00:57:45,849
there is a glaring extension to check

00:57:42,260 --> 00:57:45,849
fermez strings at compile time

00:57:48,760 --> 00:58:00,680
so unfortunately as far as I know it

00:57:51,530 --> 00:58:03,559
only works for printf syntax there's a

00:58:00,680 --> 00:58:06,799
clone extension that specifies using

00:58:03,559 --> 00:58:08,359
your own function no I didn't know about

00:58:06,799 --> 00:58:12,460
that so it would be interesting to look

00:58:08,359 --> 00:58:12,460
into it yeah thanks for them you know I

00:58:12,880 --> 00:58:17,960
was wondering can you hear me yes I was

00:58:16,339 --> 00:58:20,210
wondering if there's any kind of

00:58:17,960 --> 00:58:23,030
improvement that you could make when the

00:58:20,210 --> 00:58:26,059
format string is a constant pressure so

00:58:23,030 --> 00:58:28,700
that more of the kind of parsing of the

00:58:26,059 --> 00:58:31,609
format string happens at compile time as

00:58:28,700 --> 00:58:34,549
opposed to run time and taken to its

00:58:31,609 --> 00:58:37,460
logical conclusion if you say hello

00:58:34,549 --> 00:58:39,079
string and the string is world that

00:58:37,460 --> 00:58:41,589
could just compile down to hello world

00:58:39,079 --> 00:58:45,890
and do nothing at runtime

00:58:41,589 --> 00:58:50,799
yes and in theory so the question is

00:58:45,890 --> 00:58:53,839
other any optimization we can do for

00:58:50,799 --> 00:58:57,470
compile constructs for Strings and

00:58:53,839 --> 00:58:59,809
arguments for example if we have both

00:58:57,470 --> 00:59:03,770
the format string if you have everything

00:58:59,809 --> 00:59:09,049
Const expert to do formatting at compile

00:59:03,770 --> 00:59:12,920
time basically so right now I'm only

00:59:09,049 --> 00:59:16,190
looking at compile time checking of

00:59:12,920 --> 00:59:20,750
format strings but in theory I think it

00:59:16,190 --> 00:59:22,460
should be possible to do parsing and at

00:59:20,750 --> 00:59:26,890
least construction of the format object

00:59:22,460 --> 00:59:30,170
at compile time and maybe even

00:59:26,890 --> 00:59:31,450
formatting itself but there's still a

00:59:30,170 --> 00:59:34,450
lot of work to do

00:59:31,450 --> 00:59:34,450
Thanks

00:59:48,200 --> 00:59:52,370
it's pretty tricky because once you pass

01:00:11,690 --> 01:00:18,540
so if I understood correctly the

01:00:14,670 --> 01:00:23,730
question is how do I plan to handle the

01:00:18,540 --> 01:00:25,350
constant exper format string right yeah

01:00:23,730 --> 01:00:28,380
checking it at compile time that's

01:00:25,350 --> 01:00:35,280
actually a big problem and I'm not sure

01:00:28,380 --> 01:00:37,950
yet how to do it so I would appreciate

01:00:35,280 --> 01:00:40,590
someone who has experienced with the

01:00:37,950 --> 01:00:42,270
cost expert and compilers if they have

01:00:40,590 --> 01:00:44,940
any ideas how to do it let me know

01:00:42,270 --> 01:00:46,760
unfortunately we've run out of time so

01:00:44,940 --> 01:00:50,980
if you have any questions feel free to

01:00:46,760 --> 01:00:56,019
find me and ask everything Thanks

01:00:50,980 --> 01:00:56,019

YouTube URL: https://www.youtube.com/watch?v=ptba_AqFYCM


