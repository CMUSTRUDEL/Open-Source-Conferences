Title: CppCon 2017: Barbara Geller & Ansel Sermersheim “Unicode Strings: Why the Implementation Matters”
Publication date: 2017-10-08
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We will provide a brief overview including an explanation of what Unicode is, string terminology, and how Unicode supports non US languages. 

We will cover the pros and cons of various String formats and encodings including UTF-8, UTF-16, UCS-4, etc. A time line of Unicode development will be shown and how other languages have handled string processing over the last twenty years. 

We will provide a brief overview of where strings are used, what can go wrong with strings, why string encoding is important, and how the CsString library solves a major problem with string handling. 

We will explain how the CsString library has changed our CopperSpice Gui libraries and improved string processing in DoxyPress. 

No prior knowledge of Unicode, CopperSpice, or DoxyPress is required.
— 
Barbara Geller: CopperSpice, Co Founder

I am an independent consultant with over twenty-five years of experience as a programmer and software developer. I have worked with numerous smaller companies developing in-house applications. I have also designed and developed Windows applications for several vertical markets including medical billing, transportation, and construction.

My degree is in Electrical Engineering from Cal Poly Pomona with additional studies in Computer Science.

I am a Co-founder of CopperSpice, a C++ library derived from the existing Qt framework. I designed the Diamond Editor, a cross-platform programmers editor using the CopperSpice libraries. I have programmed in C++, Qt, Visual Objects, Clipper, PHP, and Java.


Ansel Sermersheim: CopperSpice, Co Founder

I have been working as a programmer for nearly twenty years. My degree is in Computer Science from Cal Poly San Luis  Obispo. I have transitioned to independent consulting and I am currently working on a project for RealtyShares in San Francisco. 

Co-founder of CopperSpice, a C++ GUI library.
Co-founder of DoxyPress, a C++ application for generating documentation. 
Developer of the open source libraries: libGuarded, CsSignal and CsString. 

I have programmed in C++, C, Lisp, Java, and Perl, with extensive knowledge in TCP/IP and mutilthreaded design. I am an  avid follower of the C++ standard. Speaker at CppCon 2015, CppNow 2016, CppNow 2017, and several ACCU Bay Area meetings.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,310 --> 00:00:07,490
all right welcome thank you so much for

00:00:04,520 --> 00:00:09,710
coming I'm Barbara this is Ansel and

00:00:07,490 --> 00:00:13,700
we're here today to talk about Unicode

00:00:09,710 --> 00:00:16,100
and strings for those of you that aren't

00:00:13,700 --> 00:00:19,640
familiar with our work Ansel and I are

00:00:16,100 --> 00:00:22,850
the cofounders of copper spice which is

00:00:19,640 --> 00:00:26,000
a GUI framework we're also the founders

00:00:22,850 --> 00:00:28,310
of doxy press which is a documenting

00:00:26,000 --> 00:00:30,880
program we'll talk a teeny bit about

00:00:28,310 --> 00:00:34,670
those at the end and let you know how to

00:00:30,880 --> 00:00:38,570
obtain source code and binaries and we

00:00:34,670 --> 00:00:40,880
also have a few other libraries the

00:00:38,570 --> 00:00:44,210
point today is to introduce the CS

00:00:40,880 --> 00:00:48,079
string library if you are writing a

00:00:44,210 --> 00:00:51,200
program and you use strings if you have

00:00:48,079 --> 00:00:53,930
input that takes strings if you have

00:00:51,200 --> 00:00:56,030
output that takes strings and especially

00:00:53,930 --> 00:00:58,730
if you're not dealing just in the United

00:00:56,030 --> 00:01:02,510
States with ascii and latin won you need

00:00:58,730 --> 00:01:08,930
to understand strings and why stds

00:01:02,510 --> 00:01:10,880
string doesn't really handle strings so

00:01:08,930 --> 00:01:13,490
as we go through and talk about the

00:01:10,880 --> 00:01:15,320
Unicode aware string library we've

00:01:13,490 --> 00:01:17,900
developed we want to start by

00:01:15,320 --> 00:01:20,750
establishing some definitions and some

00:01:17,900 --> 00:01:22,310
terminology that belongs to Unicode so

00:01:20,750 --> 00:01:28,940
that we're all on the same page as we go

00:01:22,310 --> 00:01:30,500
through this so the first piece of

00:01:28,940 --> 00:01:33,170
terminology that you need to really

00:01:30,500 --> 00:01:35,479
understand to understand strings

00:01:33,170 --> 00:01:37,220
effectively is the idea of a character

00:01:35,479 --> 00:01:40,250
set and this is nothing more than a

00:01:37,220 --> 00:01:43,130
collection of symbols importantly it

00:01:40,250 --> 00:01:45,380
does not include any values this is just

00:01:43,130 --> 00:01:48,229
a list of symbols that someone might use

00:01:45,380 --> 00:01:52,100
to represent things in strings or any

00:01:48,229 --> 00:01:53,750
text so for example we're all here in

00:01:52,100 --> 00:01:55,490
this room are familiar with the Latin

00:01:53,750 --> 00:01:57,290
character set because it's what all the

00:01:55,490 --> 00:01:59,960
signs in this building are written in

00:01:57,290 --> 00:02:02,030
there's other character sets like Greek

00:01:59,960 --> 00:02:02,900
used in the Greek language there many

00:02:02,030 --> 00:02:08,329
all over the world

00:02:02,900 --> 00:02:11,379
a character encoding is the values

00:02:08,329 --> 00:02:14,120
associated with a character set

00:02:11,379 --> 00:02:16,489
unfortunately the character encoding has

00:02:14,120 --> 00:02:18,799
which actually doesn't make sense it

00:02:16,489 --> 00:02:20,659
should be really called a character map

00:02:18,799 --> 00:02:23,290
and that's what we're gonna refer to it

00:02:20,659 --> 00:02:25,370
as unfortunately the Unicode consortium

00:02:23,290 --> 00:02:26,989
decided this was called a character

00:02:25,370 --> 00:02:30,230
encoding which conflicts with another

00:02:26,989 --> 00:02:33,590
term will define so refer to this as a

00:02:30,230 --> 00:02:40,159
character map because it Maps symbols to

00:02:33,590 --> 00:02:41,930
values when you combine a character set

00:02:40,159 --> 00:02:43,870
and a character map you get what's

00:02:41,930 --> 00:02:48,319
referred to as a coded character set

00:02:43,870 --> 00:02:51,379
this is a defined set of symbols and the

00:02:48,319 --> 00:02:53,090
values associated with them and one of

00:02:51,379 --> 00:02:54,620
the most common ones that nearly every

00:02:53,090 --> 00:02:57,769
programmer will be familiar with is

00:02:54,620 --> 00:02:59,329
ASCII it's a coded character set there

00:02:57,769 --> 00:03:01,870
are many others that have been used

00:02:59,329 --> 00:03:05,269
throughout various computing endeavors

00:03:01,870 --> 00:03:07,970
things like iso 8859-1 which is very

00:03:05,269 --> 00:03:10,690
common on the windows platform or ones

00:03:07,970 --> 00:03:14,120
like KO i8r which is common in russia

00:03:10,690 --> 00:03:19,940
there are literally thousands of coded

00:03:14,120 --> 00:03:22,400
character sets in use a code point is

00:03:19,940 --> 00:03:24,859
the term we're going to introduce and is

00:03:22,400 --> 00:03:27,290
the way you should talk about characters

00:03:24,859 --> 00:03:29,569
in a string we're not talking about just

00:03:27,290 --> 00:03:31,910
the symbol we're not talking about a

00:03:29,569 --> 00:03:34,970
particular letter we're talking about a

00:03:31,910 --> 00:03:37,639
code point and the reason we need to

00:03:34,970 --> 00:03:42,079
talk about a code point is it is the

00:03:37,639 --> 00:03:45,049
atomic unit it's 32 bits once you start

00:03:42,079 --> 00:03:47,120
encoding that may take up more space or

00:03:45,049 --> 00:03:50,750
less space depending on what encoding

00:03:47,120 --> 00:03:53,090
you're using but a code point is the key

00:03:50,750 --> 00:03:54,859
term that we're going to talk about as

00:03:53,090 --> 00:03:59,650
we start talking about the library and

00:03:54,859 --> 00:04:02,180
how to move code point by code point

00:03:59,650 --> 00:04:04,579
it's important to note that code points

00:04:02,180 --> 00:04:09,109
require 32 bits to represent accurately

00:04:04,579 --> 00:04:12,379
at this current point in time there are

00:04:09,109 --> 00:04:14,329
only 21 bits of that value used but

00:04:12,379 --> 00:04:16,639
there is room for expansion if you're

00:04:14,329 --> 00:04:19,070
not allowing for the fact that all 32

00:04:16,639 --> 00:04:22,810
bits may be useful you will have issues

00:04:19,070 --> 00:04:22,810
down the road and forward compatibility

00:04:23,080 --> 00:04:27,530
another term that's used when you start

00:04:26,060 --> 00:04:30,430
looking at how to represent

00:04:27,530 --> 00:04:33,590
strings in some concrete way is a

00:04:30,430 --> 00:04:35,150
storage unit also called a code unit in

00:04:33,590 --> 00:04:38,090
the standard although we think storage

00:04:35,150 --> 00:04:41,000
unit is a bit more descriptive and this

00:04:38,090 --> 00:04:44,120
is the atomic unit of storage that is

00:04:41,000 --> 00:04:47,660
used to represent the strings in your

00:04:44,120 --> 00:04:50,660
program so in utf-8 which is one of the

00:04:47,660 --> 00:04:53,660
more common encoding a storage unit is 8

00:04:50,660 --> 00:04:55,730
bits and every character is represented

00:04:53,660 --> 00:05:01,540
by some multiple of these storage units

00:04:55,730 --> 00:05:04,010
in utf-16 a storage unit is 16 bits

00:05:01,540 --> 00:05:07,970
another term which is very important is

00:05:04,010 --> 00:05:09,890
the basic multilingual plane and you can

00:05:07,970 --> 00:05:12,440
look at the basic multilingual plane as

00:05:09,890 --> 00:05:15,110
sort of the beginning of the Unicode

00:05:12,440 --> 00:05:17,840
standard it's the first 64,000 symbols

00:05:15,110 --> 00:05:20,180
and these are exactly the set of

00:05:17,840 --> 00:05:24,320
characters which fit into two bytes in

00:05:20,180 --> 00:05:26,180
the utf-16 encoding it contains most

00:05:24,320 --> 00:05:28,430
characters you would encounter on a

00:05:26,180 --> 00:05:34,700
regular basis plus a lot of mathematical

00:05:28,430 --> 00:05:38,180
symbols ASCII is commonly referred to as

00:05:34,700 --> 00:05:42,350
eight bits but it's not it is a seven

00:05:38,180 --> 00:05:46,130
bit character set and it's only seven

00:05:42,350 --> 00:05:48,830
bits and this is something that people

00:05:46,130 --> 00:05:51,410
want to believe it's Latin one that goes

00:05:48,830 --> 00:05:53,660
into eight bits but when you're talking

00:05:51,410 --> 00:05:56,630
about ASCII and ask it was really the

00:05:53,660 --> 00:06:00,130
beginning of setting up a character set

00:05:56,630 --> 00:06:03,350
and we're going to find that the first

00:06:00,130 --> 00:06:05,180
128 characters in ASCII appears the

00:06:03,350 --> 00:06:07,880
beginning of Latin 1 and the beginning

00:06:05,180 --> 00:06:10,280
of Unicode and this is where most people

00:06:07,880 --> 00:06:12,950
in the United States and working in

00:06:10,280 --> 00:06:15,950
English find that that's all that exists

00:06:12,950 --> 00:06:19,460
which isn't true the sets built the

00:06:15,950 --> 00:06:21,050
characters go much further so if you

00:06:19,460 --> 00:06:24,530
ever find yourself saying well that's

00:06:21,050 --> 00:06:27,200
just 8-bit ASCII stop that's not true

00:06:24,530 --> 00:06:30,860
ASCII is 7 bit if it involves 8 bits

00:06:27,200 --> 00:06:33,979
it's some other character set for

00:06:30,860 --> 00:06:37,370
example it might be Latin 1 otherwise

00:06:33,979 --> 00:06:38,479
known as iso 8859-1 very common in many

00:06:37,370 --> 00:06:39,090
parts of the world

00:06:38,479 --> 00:06:41,790
it's an

00:06:39,090 --> 00:06:44,820
bit coded character set it includes

00:06:41,790 --> 00:06:47,639
ascii as the first half of the code

00:06:44,820 --> 00:06:51,440
points but it adds additional ones to

00:06:47,639 --> 00:06:54,480
support non-english still latin scripts

00:06:51,440 --> 00:06:57,389
it's a superset of ascii so many people

00:06:54,480 --> 00:07:00,180
use the terms interchangeably and this

00:06:57,389 --> 00:07:02,070
is just one of a large number of other

00:07:00,180 --> 00:07:03,780
coded character sets that support

00:07:02,070 --> 00:07:06,600
various languages throughout europe and

00:07:03,780 --> 00:07:09,930
many other places there's actually Latin

00:07:06,600 --> 00:07:12,840
two three four there are other Latin

00:07:09,930 --> 00:07:16,320
sets so you can't just say Latin Latin

00:07:12,840 --> 00:07:17,940
one is a specific character set but you

00:07:16,320 --> 00:07:21,419
will find most of the other character

00:07:17,940 --> 00:07:23,760
sets in European languages so Latin one

00:07:21,419 --> 00:07:26,820
works great if all you want to do is

00:07:23,760 --> 00:07:29,669
represent a select handful of European

00:07:26,820 --> 00:07:31,830
languages and oh and you don't ever need

00:07:29,669 --> 00:07:33,389
to use the Euro sign because it was

00:07:31,830 --> 00:07:36,300
introduced after Latin one was

00:07:33,389 --> 00:07:39,960
standardized so there's various places

00:07:36,300 --> 00:07:41,639
where Latin one simply won't suffice so

00:07:39,960 --> 00:07:44,910
we need to move into a more general

00:07:41,639 --> 00:07:47,910
description of symbols and code points

00:07:44,910 --> 00:07:50,700
the reason why we started with the

00:07:47,910 --> 00:07:53,789
letter A the Latin capital letter A is

00:07:50,700 --> 00:07:56,370
everybody knows this is 41 what can get

00:07:53,789 --> 00:07:59,460
confusing is what the values are when we

00:07:56,370 --> 00:08:03,110
start encoding but as an example since

00:07:59,460 --> 00:08:07,650
it's 41 when it's encoded in utf-8 or

00:08:03,110 --> 00:08:10,020
it's encoded in utf-8 41 but it's

00:08:07,650 --> 00:08:15,030
actually not true in utf-8

00:08:10,020 --> 00:08:17,280
it's 41 in utf-16 it's 0 0 41 because of

00:08:15,030 --> 00:08:20,280
the number of bytes and this one becomes

00:08:17,280 --> 00:08:23,550
very very easy to see what becomes a

00:08:20,280 --> 00:08:26,340
little more complicated is if we move

00:08:23,550 --> 00:08:30,030
two letters that are outside this range

00:08:26,340 --> 00:08:33,180
and we need more bytes for encoding so

00:08:30,030 --> 00:08:35,700
for example there is a symbol in the

00:08:33,180 --> 00:08:37,950
symbol area of Unicode called the right

00:08:35,700 --> 00:08:39,270
words arrow with corner downwards it

00:08:37,950 --> 00:08:42,240
looks like this and you'll note that

00:08:39,270 --> 00:08:44,159
every unicode symbol is uniquely

00:08:42,240 --> 00:08:47,160
identified by three things that go in

00:08:44,159 --> 00:08:48,959
concert the shape of the symbol or it

00:08:47,160 --> 00:08:52,800
might be a non printing symbol in some

00:08:48,959 --> 00:08:54,870
cases its name this is in the Unicode

00:08:52,800 --> 00:08:56,730
standards specifically named rightwards

00:08:54,870 --> 00:08:59,790
era with corner downwards that is a

00:08:56,730 --> 00:09:05,160
defined name and it's code point or code

00:08:59,790 --> 00:09:07,800
position that's the U + 2 1 B 4 and that

00:09:05,160 --> 00:09:11,670
is a value that is not in any encoding

00:09:07,800 --> 00:09:14,060
that is the raw value that is specified

00:09:11,670 --> 00:09:17,279
in the unicode table for this code point

00:09:14,060 --> 00:09:19,740
when you're encoding in utf-8 as you can

00:09:17,279 --> 00:09:21,120
see it's going to take 3 bytes so again

00:09:19,740 --> 00:09:24,649
this is where it becomes really obvious

00:09:21,120 --> 00:09:28,170
in a value like this because 2 1 B 4

00:09:24,649 --> 00:09:31,560
that is just an assigned value by the

00:09:28,170 --> 00:09:35,970
Unicode consortium once it's encoded in

00:09:31,560 --> 00:09:39,269
utf-8 we're at 3 bytes and utf-16 it is

00:09:35,970 --> 00:09:43,500
2 bytes what's really important to

00:09:39,269 --> 00:09:44,370
notice this is one code point not 2 not

00:09:43,500 --> 00:09:48,899
00:09:44,370 --> 00:09:52,920
so we every single code point has how

00:09:48,899 --> 00:09:54,870
much storage it takes and these are

00:09:52,920 --> 00:09:56,730
variable number of storage because they

00:09:54,870 --> 00:09:58,709
are different amounts but it's really

00:09:56,730 --> 00:10:03,120
important to remember this is one code

00:09:58,709 --> 00:10:06,149
point so if you correctly interpret the

00:10:03,120 --> 00:10:08,160
first string here as utf-8 and the

00:10:06,149 --> 00:10:10,350
second string is utf-16 they are

00:10:08,160 --> 00:10:13,620
equivalent they contain exactly the same

00:10:10,350 --> 00:10:16,470
data one code point its value is to 1b

00:10:13,620 --> 00:10:21,570
for their just represented differently

00:10:16,470 --> 00:10:24,240
in memory now as I mentioned if we step

00:10:21,570 --> 00:10:26,640
outside the basic multilingual plane we

00:10:24,240 --> 00:10:28,250
get to some more obscure characters so

00:10:26,640 --> 00:10:31,860
in this case we have an eighth note

00:10:28,250 --> 00:10:34,260
musical symbol eighth note and you can

00:10:31,860 --> 00:10:40,500
tell it's outside the BMP because it's

00:10:34,260 --> 00:10:43,470
unicode value of u plus 1 D 1 6 0 has 5

00:10:40,500 --> 00:10:46,709
digits in it so therefore it exceeds 16

00:10:43,470 --> 00:10:50,790
bits it's outside the first 64 K the

00:10:46,709 --> 00:10:54,240
sits outside the BMP in order to

00:10:50,790 --> 00:10:57,290
represent this symbol in utf-8 we use

00:10:54,240 --> 00:11:01,020
for storage units with these values and

00:10:57,290 --> 00:11:02,070
there is a representation in utf-16 as

00:11:01,020 --> 00:11:05,760
well

00:11:02,070 --> 00:11:07,680
it uses two 16-bit storage units and

00:11:05,760 --> 00:11:11,040
each one of these storage units is

00:11:07,680 --> 00:11:12,480
what's referred to as a surrogate this

00:11:11,040 --> 00:11:15,900
is a feature that was added to the

00:11:12,480 --> 00:11:19,830
standard when code points grew from 16

00:11:15,900 --> 00:11:24,150
bits to 21 it would be ambiguous in

00:11:19,830 --> 00:11:27,000
utf-16 if these values were ever legal

00:11:24,150 --> 00:11:32,780
code points so essentially in the

00:11:27,000 --> 00:11:38,460
Unicode table this range from d800 to

00:11:32,780 --> 00:11:41,010
d.c sorry dfff were reserved they will

00:11:38,460 --> 00:11:45,630
never be assigned to any valid code

00:11:41,010 --> 00:11:47,370
point so when a utf-16 decoder sees a

00:11:45,630 --> 00:11:49,260
value in this range it knows that this

00:11:47,370 --> 00:11:52,050
is a surrogate it needs to be combined

00:11:49,260 --> 00:11:54,270
with the following surrogate to form a

00:11:52,050 --> 00:11:56,820
complete code point the same thing

00:11:54,270 --> 00:11:59,610
happens that these are not valid in

00:11:56,820 --> 00:12:04,350
utf-8 one of the differences between

00:11:59,610 --> 00:12:07,470
utf-8 and utf-16 is in 16 we have the

00:12:04,350 --> 00:12:10,680
surrogate pairs in utf-8 they are

00:12:07,470 --> 00:12:12,570
multibyte so to know that there is a

00:12:10,680 --> 00:12:15,630
surrogate you would go to the Unicode

00:12:12,570 --> 00:12:19,410
table in utf-16 and there's that range

00:12:15,630 --> 00:12:23,460
in utf-8 as by looking at the high bits

00:12:19,410 --> 00:12:26,100
you can see that we need more bytes to

00:12:23,460 --> 00:12:30,480
generate an actual code point that

00:12:26,100 --> 00:12:33,540
actually makes utf-8 easier to decode

00:12:30,480 --> 00:12:37,170
and encode and understand than utf-16

00:12:33,540 --> 00:12:40,410
and an unfortunate accident of the

00:12:37,170 --> 00:12:43,620
existence of utf-16 is that since it's

00:12:40,410 --> 00:12:45,840
unable to represent certain values in

00:12:43,620 --> 00:12:49,110
the space of code points we must reserve

00:12:45,840 --> 00:12:51,510
those for use by all implementations so

00:12:49,110 --> 00:12:53,250
they're not available in utf-8 even

00:12:51,510 --> 00:12:55,410
though they could be represented in

00:12:53,250 --> 00:12:58,230
utf-8 because they would not be

00:12:55,410 --> 00:13:00,800
representable in utf-16 and they must be

00:12:58,230 --> 00:13:00,800
harmonized

00:13:02,900 --> 00:13:07,800
Unicode code points are 32 bits this

00:13:06,450 --> 00:13:11,310
isn't negotiable

00:13:07,800 --> 00:13:13,230
it is part of Unicode so it does become

00:13:11,310 --> 00:13:17,370
the question of why are we using utf-8

00:13:13,230 --> 00:13:19,770
and utf-16 why aren't we using utf-32

00:13:17,370 --> 00:13:23,430
and we're going to talk about that and

00:13:19,770 --> 00:13:28,520
why 32 becomes wasteful and 8 is

00:13:23,430 --> 00:13:28,520
becoming the optimized way for encoding

00:13:29,990 --> 00:13:37,380
so I've alluded to utf-8 in several

00:13:33,930 --> 00:13:39,240
points previously utf-8 is a variable

00:13:37,380 --> 00:13:41,940
length encoding it's capable of

00:13:39,240 --> 00:13:45,720
representing every code point in the

00:13:41,940 --> 00:13:48,570
Unicode standard in a sequence of 8-bit

00:13:45,720 --> 00:13:52,380
storage units and it has a lot of very

00:13:48,570 --> 00:13:56,580
nice properties for one thing it's if

00:13:52,380 --> 00:13:59,430
you are working with ASCII text then the

00:13:56,580 --> 00:14:02,100
encoding is the identity encoding so

00:13:59,430 --> 00:14:05,340
ASCII text is unchanged when you encode

00:14:02,100 --> 00:14:09,210
it as utf-8 also whenever you have a

00:14:05,340 --> 00:14:11,280
multi byte character in utf-8 its values

00:14:09,210 --> 00:14:15,120
always have the high bit set so they can

00:14:11,280 --> 00:14:17,670
never be confused for any ASCII value so

00:14:15,120 --> 00:14:20,580
utf-8 encoded text for the most part

00:14:17,670 --> 00:14:25,160
will pass unchanged through legacy

00:14:20,580 --> 00:14:27,840
programs that expect 8-bit encoding 'z

00:14:25,160 --> 00:14:29,340
another very important property is the

00:14:27,840 --> 00:14:31,890
fact that since we're dealing with

00:14:29,340 --> 00:14:34,430
individual bytes here we don't have to

00:14:31,890 --> 00:14:39,060
worry about the platform endianness of

00:14:34,430 --> 00:14:41,760
strings it's very helpful in order to do

00:14:39,060 --> 00:14:43,920
utf-8 encoding you need to be able to

00:14:41,760 --> 00:14:46,620
determine how many bytes it's going to

00:14:43,920 --> 00:14:50,580
take to encode a particular code point

00:14:46,620 --> 00:14:54,630
in memory and this process is simpler

00:14:50,580 --> 00:14:56,160
than it is in utf-16 for some cases we

00:14:54,630 --> 00:14:58,560
do have some code we're going to show

00:14:56,160 --> 00:14:59,970
you when we go over the library that's

00:14:58,560 --> 00:15:03,300
going to show the difference of how you

00:14:59,970 --> 00:15:06,630
do an encoding for utf-8 versus utf-16

00:15:03,300 --> 00:15:11,420
and the math and the code itself is just

00:15:06,630 --> 00:15:11,420
easier and less error-prone in utf-8

00:15:11,790 --> 00:15:18,399
utf-16 is also a variable length

00:15:15,040 --> 00:15:21,069
encoding this is some of the differences

00:15:18,399 --> 00:15:23,769
if you've looked at the Unicode standard

00:15:21,069 --> 00:15:28,029
and you've seen that some languages use

00:15:23,769 --> 00:15:29,970
UCS and there are encoding x' we're

00:15:28,029 --> 00:15:33,730
going to talk about very briefly that

00:15:29,970 --> 00:15:37,420
preceded utf-8 and utf-16 so you have to

00:15:33,730 --> 00:15:41,259
ask is it encoding a fixed length or is

00:15:37,420 --> 00:15:43,889
it variable and utf-8 and utf-16 are

00:15:41,259 --> 00:15:47,860
variable as we've shown that it can be

00:15:43,889 --> 00:15:51,699
one two or three bytes or you prove up

00:15:47,860 --> 00:15:54,250
to four in utf-8 there was a time that

00:15:51,699 --> 00:15:58,389
utf-8 went up to five and six but that

00:15:54,250 --> 00:16:02,529
was disallowed in 2003 by the Unicode

00:15:58,389 --> 00:16:05,079
consortium the real downside to utf-16

00:16:02,529 --> 00:16:05,800
is that it gives you a false sense of

00:16:05,079 --> 00:16:08,620
security

00:16:05,800 --> 00:16:11,829
the problem with utf-16 is that it's

00:16:08,620 --> 00:16:15,759
both too wide for things like ASCII and

00:16:11,829 --> 00:16:18,310
Latin so you waist up to 50% of your

00:16:15,759 --> 00:16:21,339
storage space for Strings that don't

00:16:18,310 --> 00:16:23,529
need multibyte characters and it's too

00:16:21,339 --> 00:16:24,670
narrow to contain the entire Unicode set

00:16:23,529 --> 00:16:26,170
so you have to deal with all the

00:16:24,670 --> 00:16:32,290
complexities of a variable length

00:16:26,170 --> 00:16:34,000
encoding anyway some of this started

00:16:32,290 --> 00:16:36,490
early on when people were trying to

00:16:34,000 --> 00:16:38,709
choose what encoding they wanted to use

00:16:36,490 --> 00:16:42,160
and Microsoft kind of set the standard

00:16:38,709 --> 00:16:46,089
way back when and they did choose UCS -

00:16:42,160 --> 00:16:50,290
UCS - being a fixed width and a

00:16:46,089 --> 00:16:52,630
predecessor to utf-16 other languages

00:16:50,290 --> 00:16:55,059
followed suit and it really seemed like

00:16:52,630 --> 00:16:59,889
a good idea everybody was like well this

00:16:55,059 --> 00:17:05,110
is the way to go we use utf-16 and in

00:16:59,889 --> 00:17:07,150
some ways now looking back it's like we

00:17:05,110 --> 00:17:09,610
didn't really think this through and in

00:17:07,150 --> 00:17:11,620
fact the Unicode consortium felt the

00:17:09,610 --> 00:17:14,980
same way that we didn't think it through

00:17:11,620 --> 00:17:18,280
and now what now we're partway through

00:17:14,980 --> 00:17:21,939
everyone is using utf-16 what do we do

00:17:18,280 --> 00:17:24,850
and at a certain point they discovered

00:17:21,939 --> 00:17:26,640
that all of these symbols used

00:17:24,850 --> 00:17:29,140
in all of the world's writing systems

00:17:26,640 --> 00:17:32,410
throughout all of space and time are not

00:17:29,140 --> 00:17:34,510
going to fit in 16bits so they had to

00:17:32,410 --> 00:17:36,429
grow the code point size and this

00:17:34,510 --> 00:17:40,929
removed a lot of the advantages to a

00:17:36,429 --> 00:17:43,179
16-bit encoding so most languages and

00:17:40,929 --> 00:17:45,370
operating systems that have come more

00:17:43,179 --> 00:17:47,370
recently to support Unicode have used

00:17:45,370 --> 00:17:49,690
utf-8 both for backwards compatibility

00:17:47,370 --> 00:17:53,620
reasons and also for the quality of

00:17:49,690 --> 00:17:55,929
implementation it allows Jolan

00:17:53,620 --> 00:17:58,570
software is a blog that if you're not

00:17:55,929 --> 00:18:00,820
familiar with his work you should google

00:17:58,570 --> 00:18:04,299
him and take a look at his work this is

00:18:00,820 --> 00:18:06,850
a quote that he put down in 2003 it's

00:18:04,299 --> 00:18:09,789
really valuable because if you don't

00:18:06,850 --> 00:18:13,090
know the encoding you can't interpret

00:18:09,789 --> 00:18:17,049
the text he ran into this a lot with

00:18:13,090 --> 00:18:19,960
email and email was set up to be encoded

00:18:17,049 --> 00:18:22,570
and some were using one encoding some

00:18:19,960 --> 00:18:25,840
another there's a gentleman who actually

00:18:22,570 --> 00:18:29,500
did a commentary on this particular blog

00:18:25,840 --> 00:18:31,630
and he looked at some text and he said

00:18:29,500 --> 00:18:33,909
well I'm gonna just guess cuz I'm sure I

00:18:31,630 --> 00:18:36,610
can guess the encoding and at one point

00:18:33,909 --> 00:18:39,100
he decided it looks like a DNA sequence

00:18:36,610 --> 00:18:41,110
and that's where he went with it and

00:18:39,100 --> 00:18:44,140
then he kept trying different encodings

00:18:41,110 --> 00:18:46,960
and nothing nothing actually fully

00:18:44,140 --> 00:18:50,049
encoded it and then somebody told them

00:18:46,960 --> 00:18:52,539
it was kanji and when you look at the

00:18:50,049 --> 00:18:55,990
tech the numbers and then you look at

00:18:52,539 --> 00:18:58,900
kanji they're not similar at all so it

00:18:55,990 --> 00:19:01,600
really turned out you cannot guess so

00:18:58,900 --> 00:19:03,970
again if you're writing any software or

00:19:01,600 --> 00:19:07,450
dealing with strings in any way you need

00:19:03,970 --> 00:19:09,850
to decide on an encoding and you need to

00:19:07,450 --> 00:19:12,429
either inform your users or have it set

00:19:09,850 --> 00:19:14,049
up some way in your software or the

00:19:12,429 --> 00:19:17,110
library that you're using that it

00:19:14,049 --> 00:19:20,380
understands the encoding so the most

00:19:17,110 --> 00:19:24,280
fundamental takeaway from this talk is

00:19:20,380 --> 00:19:26,500
that if you have what you think of as a

00:19:24,280 --> 00:19:28,690
string and you don't know what encoding

00:19:26,500 --> 00:19:30,970
it is you don't actually have a string

00:19:28,690 --> 00:19:34,600
you have a sequence of integers which

00:19:30,970 --> 00:19:36,940
are without meaning it is but the utmost

00:19:34,600 --> 00:19:38,210
importance to know what encoding every

00:19:36,940 --> 00:19:42,340
single string in your program

00:19:38,210 --> 00:19:42,340
or you cannot understand what it means

00:19:42,430 --> 00:19:48,500
so let's look back at the history of how

00:19:44,900 --> 00:19:51,110
we got into this state the original

00:19:48,500 --> 00:19:53,870
version of Unicode came out in 1991 and

00:19:51,110 --> 00:19:57,410
the major encoding that was used was UCS

00:19:53,870 --> 00:19:58,790
- was 16 bits per storage unit fixed

00:19:57,410 --> 00:20:00,140
width encoding because again they

00:19:58,790 --> 00:20:04,100
thought that was all the characters we

00:20:00,140 --> 00:20:07,580
would ever need something happened in

00:20:04,100 --> 00:20:09,980
1992 and actually reading the history of

00:20:07,580 --> 00:20:14,200
this is quite fascinating ken Thompson

00:20:09,980 --> 00:20:17,690
and Rob Pike designed utf-8 on a napkin

00:20:14,200 --> 00:20:20,660
they were contacted by a particular

00:20:17,690 --> 00:20:23,030
group open X open Excel was asking for a

00:20:20,660 --> 00:20:25,220
better standard to encode characters and

00:20:23,030 --> 00:20:28,490
it's a very interesting story Rob is

00:20:25,220 --> 00:20:31,370
actually published and he used to work

00:20:28,490 --> 00:20:33,530
on a project where he had them pull up

00:20:31,370 --> 00:20:36,170
the old server so he could prove the

00:20:33,530 --> 00:20:38,260
emails of a gazillion years ago that

00:20:36,170 --> 00:20:42,080
this is actually the way it happened and

00:20:38,260 --> 00:20:45,770
they developed this and they got utf-8

00:20:42,080 --> 00:20:48,680
working in plan 9 which those of you

00:20:45,770 --> 00:20:50,450
Linux people are familiar with plan 9

00:20:48,680 --> 00:20:55,390
that didn't quite go where they wanted

00:20:50,450 --> 00:20:55,390
but it did do utf-8 in about three days

00:20:55,510 --> 00:20:59,840
unfortunately it took a long time for

00:20:57,620 --> 00:21:03,290
people to realize that utf-8 was going

00:20:59,840 --> 00:21:06,380
to be a good idea so in 1982 as they

00:21:03,290 --> 00:21:08,360
were developing utf-8 other companies

00:21:06,380 --> 00:21:13,310
started adopting ucs-2 it seemed like

00:21:08,360 --> 00:21:15,800
the way to go in 93 was when the Unicode

00:21:13,310 --> 00:21:17,660
consortium realized they'd hit the 64k

00:21:15,800 --> 00:21:19,190
wall they were going to have problems

00:21:17,660 --> 00:21:21,230
they had to expand the code point so

00:21:19,190 --> 00:21:23,750
they released a new encoding unit a

00:21:21,230 --> 00:21:26,000
coding system called UCS for this is a

00:21:23,750 --> 00:21:28,730
four byte fixed width encoding and

00:21:26,000 --> 00:21:30,890
everybody said my god four bytes for

00:21:28,730 --> 00:21:32,480
every single character there's no way we

00:21:30,890 --> 00:21:35,110
can do that that's wasting way too much

00:21:32,480 --> 00:21:38,120
memory so nobody used it

00:21:35,110 --> 00:21:41,180
utf-8 was widely publicized that years

00:21:38,120 --> 00:21:44,150
introduced in U sticks but it wasn't

00:21:41,180 --> 00:21:46,430
until 1996 that it was adopted and this

00:21:44,150 --> 00:21:48,950
is actually amazing to me to realize it

00:21:46,430 --> 00:21:51,140
was 1996 that utf-8 and

00:21:48,950 --> 00:21:54,170
they did come out with utf-16 the same

00:21:51,140 --> 00:21:55,940
here but then companies still didn't

00:21:54,170 --> 00:21:58,070
make the change and we're talking about

00:21:55,940 --> 00:22:00,350
Microsoft and Java and a lot of other

00:21:58,070 --> 00:22:02,390
companies they they didn't make the

00:22:00,350 --> 00:22:04,160
change and it was available because they

00:22:02,390 --> 00:22:06,230
didn't understand the power which

00:22:04,160 --> 00:22:13,940
unfortunately means changing over later

00:22:06,230 --> 00:22:16,790
becomes more difficult the key other key

00:22:13,940 --> 00:22:21,400
thing to notice here is that Google has

00:22:16,790 --> 00:22:23,540
done some studies on the availability of

00:22:21,400 --> 00:22:26,600
utf-8 and they've released some

00:22:23,540 --> 00:22:30,650
statistics in 2012 it's been estimated

00:22:26,600 --> 00:22:34,160
that 50% of the internet now uses utf-8

00:22:30,650 --> 00:22:38,240
as of September of this year it's 90%

00:22:34,160 --> 00:22:42,410
and that's email XML HTML so the

00:22:38,240 --> 00:22:45,920
internet is going utf-8 so if you have

00:22:42,410 --> 00:22:48,680
any connection to any sort of network

00:22:45,920 --> 00:22:51,350
server in your code you need to be able

00:22:48,680 --> 00:22:53,990
to handle at least utf-8 and the great

00:22:51,350 --> 00:22:55,730
thing about utf-8 is almost every

00:22:53,990 --> 00:22:58,820
network server supports it at this point

00:22:55,730 --> 00:23:00,710
so it's the only non ASCII encoding you

00:22:58,820 --> 00:23:02,510
need to support you don't need to worry

00:23:00,710 --> 00:23:07,270
about any of the legacy character sets

00:23:02,510 --> 00:23:07,270
you just deal with utf-8 and you're done

00:23:08,200 --> 00:23:13,100
and this year we have actually released

00:23:11,090 --> 00:23:14,540
CS string and the reason why we did it

00:23:13,100 --> 00:23:17,720
we're going to show you an example in a

00:23:14,540 --> 00:23:19,910
few minutes here of how mangled data can

00:23:17,720 --> 00:23:24,080
actually get if you're not following

00:23:19,910 --> 00:23:26,930
your own rules of using utf-8 and we

00:23:24,080 --> 00:23:30,260
have released CS string it is a BSD

00:23:26,930 --> 00:23:33,770
licensed library and it is standalone

00:23:30,260 --> 00:23:36,620
you can use it in your C++ applications

00:23:33,770 --> 00:23:40,250
we've also incorporated it in our copper

00:23:36,620 --> 00:23:43,970
spice GUI framework under cue string 8

00:23:40,250 --> 00:23:45,950
we are developing that class so if you

00:23:43,970 --> 00:23:48,290
are a copper spice user you'll be able

00:23:45,950 --> 00:23:50,830
to use utf-8 directly in the GUI

00:23:48,290 --> 00:23:50,830
environment

00:23:51,670 --> 00:23:55,630
let's step back for a second and talk

00:23:53,440 --> 00:23:57,430
about how some of the other libraries

00:23:55,630 --> 00:23:59,170
that are out there handle strings to

00:23:57,430 --> 00:24:00,940
sort of form the rationale for why we

00:23:59,170 --> 00:24:05,740
decided that yet another string library

00:24:00,940 --> 00:24:07,600
would be of value a large part of what

00:24:05,740 --> 00:24:09,790
we've done in the copper spice project

00:24:07,600 --> 00:24:11,920
is look at places to improve the

00:24:09,790 --> 00:24:15,100
existing code that we were working from

00:24:11,920 --> 00:24:17,740
and we discovered challenges along the

00:24:15,100 --> 00:24:19,240
way in many different parts and once we

00:24:17,740 --> 00:24:22,360
got to a certain point we realized that

00:24:19,240 --> 00:24:24,490
the string handling was really subpar so

00:24:22,360 --> 00:24:28,060
we decided to look at it in more detail

00:24:24,490 --> 00:24:29,860
and we realized that in our other

00:24:28,060 --> 00:24:33,190
projects we were also running into

00:24:29,860 --> 00:24:35,860
trouble with Unicode string handling we

00:24:33,190 --> 00:24:38,490
thought there's a theme here this isn't

00:24:35,860 --> 00:24:40,630
just unique to a large framework library

00:24:38,490 --> 00:24:43,480
everyone needs to work with strings

00:24:40,630 --> 00:24:47,980
everyone needs a functional way to work

00:24:43,480 --> 00:24:50,200
with strings that actually works then we

00:24:47,980 --> 00:24:52,120
said okay well what is out there

00:24:50,200 --> 00:24:54,550
well the first place to look is the

00:24:52,120 --> 00:24:57,700
standard so we have stds string does

00:24:54,550 --> 00:25:00,310
that give us any help no none whatsoever

00:24:57,700 --> 00:25:03,220
there's STD string which might as well

00:25:00,310 --> 00:25:05,290
have been called STD vector care for all

00:25:03,220 --> 00:25:08,020
the help it gives you for Strings I mean

00:25:05,290 --> 00:25:09,820
yes there's some string operations like

00:25:08,020 --> 00:25:11,320
substring but it really doesn't

00:25:09,820 --> 00:25:13,060
understand text it has no way of

00:25:11,320 --> 00:25:16,170
representing and coding at all it just

00:25:13,060 --> 00:25:19,960
deals with a sequence of 8-bit bytes

00:25:16,170 --> 00:25:22,540
there's STD W string which might be 16

00:25:19,960 --> 00:25:24,430
bits or it might be 32 bits depending

00:25:22,540 --> 00:25:27,070
upon your platform there's some

00:25:24,430 --> 00:25:29,620
interesting behavior there that's

00:25:27,070 --> 00:25:30,910
implementation defined and it really

00:25:29,620 --> 00:25:32,500
doesn't help you that much because it

00:25:30,910 --> 00:25:36,880
still doesn't give you a way to specify

00:25:32,500 --> 00:25:39,720
the encoding we need unicode strings not

00:25:36,880 --> 00:25:39,720
STD string

00:25:41,539 --> 00:25:46,759
we looked at other libraries as I said

00:25:43,669 --> 00:25:48,979
STD string has no encoding what is

00:25:46,759 --> 00:25:51,649
Microsoft do with MFC while they support

00:25:48,979 --> 00:25:56,529
they started on ucs-2 and they move to

00:25:51,649 --> 00:26:00,470
supporting utf-16 mostly cue string is

00:25:56,529 --> 00:26:01,340
houston in cute is well it started out

00:26:00,470 --> 00:26:04,999
as ucs-2

00:26:01,340 --> 00:26:07,159
they have migrated to utf-16 there's a

00:26:04,999 --> 00:26:09,830
few issues though with queue strain and

00:26:07,159 --> 00:26:13,609
that has to do when there are surrogates

00:26:09,830 --> 00:26:17,359
and the problem is if you're using cute

00:26:13,609 --> 00:26:19,399
and it's in this encoding cute it sounds

00:26:17,359 --> 00:26:21,019
doesn't always deal with the surrogates

00:26:19,399 --> 00:26:24,739
and you have to glue them back together

00:26:21,019 --> 00:26:27,559
in your code and this is a very common

00:26:24,739 --> 00:26:30,109
behavior in libraries that started with

00:26:27,559 --> 00:26:32,779
you cs2 and then we're extended to

00:26:30,109 --> 00:26:34,549
support utf-16 they leave a lot up to

00:26:32,779 --> 00:26:37,820
the programmer and it's easy to get

00:26:34,549 --> 00:26:39,259
things wrong and a great example of this

00:26:37,820 --> 00:26:42,049
I'll take a moment to pick on c-sharp

00:26:39,259 --> 00:26:43,789
here every one of these libraries has

00:26:42,049 --> 00:26:47,419
similar issues but it's one of the most

00:26:43,789 --> 00:26:50,269
demonstrative ones in c-sharp there is a

00:26:47,419 --> 00:26:53,239
text field element in the GUI library

00:26:50,269 --> 00:26:55,249
and you can specify the length that you

00:26:53,239 --> 00:26:58,129
want a user to be able to type in in

00:26:55,249 --> 00:27:00,950
characters but it's not really

00:26:58,129 --> 00:27:02,989
characters it's storage units so if use

00:27:00,950 --> 00:27:04,789
for example take a text field and say

00:27:02,989 --> 00:27:08,539
I'd like the user to be able to type in

00:27:04,789 --> 00:27:10,039
ten characters and I type in nine

00:27:08,539 --> 00:27:12,259
characters that are in the basic

00:27:10,039 --> 00:27:14,629
multilingual plane those each take one

00:27:12,259 --> 00:27:16,039
storage unit to encode and then at the

00:27:14,629 --> 00:27:19,849
end of the string they type in a

00:27:16,039 --> 00:27:23,059
character outside the BMP it will insert

00:27:19,849 --> 00:27:25,539
the hi surrogate fail to insert the low

00:27:23,059 --> 00:27:28,970
surrogate because there's no room for it

00:27:25,539 --> 00:27:31,999
try to report the error to the user and

00:27:28,970 --> 00:27:34,879
in the process of displaying the string

00:27:31,999 --> 00:27:37,309
attempt to render an invalid utf-16

00:27:34,879 --> 00:27:41,389
string to the display and it crashes

00:27:37,309 --> 00:27:44,629
the.net runtime this is an example of

00:27:41,389 --> 00:27:46,159
just how badly things can go wrong when

00:27:44,629 --> 00:27:49,220
you have a library that claims to

00:27:46,159 --> 00:27:51,649
support utf-16 but doesn't take care of

00:27:49,220 --> 00:27:53,720
all the corner cases and since nearly

00:27:51,649 --> 00:27:54,809
every character that's used in common

00:27:53,720 --> 00:27:57,299
usage is

00:27:54,809 --> 00:28:00,960
inside the BMP these bugs can lurk for

00:27:57,299 --> 00:28:02,700
years until someone hits exactly the

00:28:00,960 --> 00:28:04,889
right corner case and discovers it and

00:28:02,700 --> 00:28:07,950
crashes your program or breaks your

00:28:04,889 --> 00:28:10,740
security system or what have you this is

00:28:07,950 --> 00:28:15,509
incredibly dangerous so there must be a

00:28:10,740 --> 00:28:19,259
better way so as we were working on

00:28:15,509 --> 00:28:22,289
Doxey press which is a documentary and

00:28:19,259 --> 00:28:24,509
our main focus of enhancing doxy press

00:28:22,289 --> 00:28:27,779
which is a fork of doxygen if you're

00:28:24,509 --> 00:28:33,779
familiar with that we wanted to be able

00:28:27,779 --> 00:28:37,139
to parse c++ and we actually use clang

00:28:33,779 --> 00:28:39,360
as a front-end for parsing not a Lex

00:28:37,139 --> 00:28:41,149
parser or anything like that so we can

00:28:39,360 --> 00:28:43,049
truly leverage what's already out there

00:28:41,149 --> 00:28:45,480
parsing isn't something we need to

00:28:43,049 --> 00:28:48,809
reinvent we need to take the output and

00:28:45,480 --> 00:28:52,769
feed it back in ironically we found

00:28:48,809 --> 00:28:55,769
problems the original versions dealing

00:28:52,769 --> 00:29:00,419
with doxy press use things like QC

00:28:55,769 --> 00:29:03,659
strings and these were way back in the

00:29:00,419 --> 00:29:07,740
late you know like 1999 like a long time

00:29:03,659 --> 00:29:10,740
ago and these weren't actually handling

00:29:07,740 --> 00:29:12,179
strings the way we think of them they

00:29:10,740 --> 00:29:15,210
were basically giving you the same

00:29:12,179 --> 00:29:18,090
amount of support for strings as STV

00:29:15,210 --> 00:29:20,929
string does which is to say none they

00:29:18,090 --> 00:29:23,580
just treat it as a bag of characters so

00:29:20,929 --> 00:29:25,710
we went through and refactored all of

00:29:23,580 --> 00:29:27,899
this code to use the cue string class

00:29:25,710 --> 00:29:33,090
from copper spice which is utf-16

00:29:27,899 --> 00:29:35,580
and we figured that this would make a

00:29:33,090 --> 00:29:41,700
great improvement in the ability of doxy

00:29:35,580 --> 00:29:44,299
press to handle non ASCII characters so

00:29:41,700 --> 00:29:48,389
what we have here is a problem we found

00:29:44,299 --> 00:29:50,759
the cue string text here this text is

00:29:48,389 --> 00:29:53,220
just text in English that's going to be

00:29:50,759 --> 00:29:56,999
displayed on a particular page some HTML

00:29:53,220 --> 00:29:58,769
output and this is the code it was being

00:29:56,999 --> 00:30:00,840
run through we'll come back and take a

00:29:58,769 --> 00:30:03,770
look at this code in a second but

00:30:00,840 --> 00:30:06,460
basically m1 is calling m2 and then it's

00:30:03,770 --> 00:30:09,080
renting out but then we decided hey

00:30:06,460 --> 00:30:11,390
we're international we should actually

00:30:09,080 --> 00:30:15,710
test in some other languages not just

00:30:11,390 --> 00:30:19,100
English so we translated the string into

00:30:15,710 --> 00:30:20,300
some other languages and I think that's

00:30:19,100 --> 00:30:22,670
pretty good German if we have any

00:30:20,300 --> 00:30:24,440
Russian speakers we've been told this

00:30:22,670 --> 00:30:27,110
may not be exactly what the English

00:30:24,440 --> 00:30:29,870
would say but it's close enough that

00:30:27,110 --> 00:30:31,430
that's kind of the interpretation I can

00:30:29,870 --> 00:30:34,310
at least tell that looks like Russian

00:30:31,430 --> 00:30:36,050
and looks like German pencil speaks a

00:30:34,310 --> 00:30:38,960
little bit of German so when I was

00:30:36,050 --> 00:30:41,300
testing this and this is real-world case

00:30:38,960 --> 00:30:45,560
I asked him to come over and look at it

00:30:41,300 --> 00:30:47,450
and say is this really German well I

00:30:45,560 --> 00:30:50,930
looked at it and what I was actually

00:30:47,450 --> 00:30:53,750
looking at was this that's not exactly

00:30:50,930 --> 00:30:55,460
German and just so that you know we did

00:30:53,750 --> 00:30:58,550
not put carriage returns into this

00:30:55,460 --> 00:31:01,340
Russian this is exactly what came out in

00:30:58,550 --> 00:31:04,340
in doxy press as we were running it

00:31:01,340 --> 00:31:07,760
through we got this out which is sort of

00:31:04,340 --> 00:31:10,310
telling us we had a utf-8 utf-16 problem

00:31:07,760 --> 00:31:12,890
because we're not using utf-8 we were

00:31:10,310 --> 00:31:16,100
using hue string and here we are working

00:31:12,890 --> 00:31:18,770
with a utf-16 compliant string library

00:31:16,100 --> 00:31:20,720
and we got garbage out the other end

00:31:18,770 --> 00:31:25,180
what happened we have been told by some

00:31:20,720 --> 00:31:31,340
friends from Ukraine that is not Russian

00:31:25,180 --> 00:31:34,370
no way so what was going on let's take a

00:31:31,340 --> 00:31:38,000
look at the code the problem here is

00:31:34,370 --> 00:31:41,540
that we have a string as I mentioned cue

00:31:38,000 --> 00:31:43,640
string is in utf-16 we're calling a

00:31:41,540 --> 00:31:46,160
legacy piece of code that once a Const

00:31:43,640 --> 00:31:47,930
characters start so we take this string

00:31:46,160 --> 00:31:50,500
and we convert it to utf-8 because

00:31:47,930 --> 00:31:53,450
that's a great encoding to use you can

00:31:50,500 --> 00:31:56,150
represent every unicode character in an

00:31:53,450 --> 00:31:57,980
8-bit string so any function that takes

00:31:56,150 --> 00:32:03,380
a Const character star can receive this

00:31:57,980 --> 00:32:06,530
so we call M one is fine M one contain M

00:32:03,380 --> 00:32:11,020
one is passed data which points to a

00:32:06,530 --> 00:32:14,120
utf-8 encoded string then M one calls m2

00:32:11,020 --> 00:32:17,299
there is an implicit constructor for cue

00:32:14,120 --> 00:32:20,989
string it receives this data

00:32:17,299 --> 00:32:25,039
it assumes the data is in Latin 1 it's

00:32:20,989 --> 00:32:27,289
not and there's no way to tell it so not

00:32:25,039 --> 00:32:29,629
not in queue string and again this also

00:32:27,289 --> 00:32:31,549
happens in many other languages we're

00:32:29,629 --> 00:32:34,159
just using this as an example to show

00:32:31,549 --> 00:32:37,610
you that code like this just doesn't

00:32:34,159 --> 00:32:39,889
work unless you know the encoding so

00:32:37,610 --> 00:32:41,960
when we interpret this string as Latin

00:32:39,889 --> 00:32:45,139
one we get garbage out the other side

00:32:41,960 --> 00:32:48,049
this is an example of how insidious it

00:32:45,139 --> 00:32:50,149
is to have a string in your program that

00:32:48,049 --> 00:32:53,450
does not contain encoding information

00:32:50,149 --> 00:32:55,909
along with it as I said every string

00:32:53,450 --> 00:32:58,639
must be tagged with its encoding or you

00:32:55,909 --> 00:33:00,859
can't interpret it correctly if you have

00:32:58,639 --> 00:33:03,830
code that deals if you have any code in

00:33:00,859 --> 00:33:05,869
your program anywhere which does not

00:33:03,830 --> 00:33:08,179
know what encoding the data is it's

00:33:05,869 --> 00:33:10,279
working with you we'll have problems of

00:33:08,179 --> 00:33:12,619
this form so we need something that

00:33:10,279 --> 00:33:20,749
always guarantees it knows what encoding

00:33:12,619 --> 00:33:23,090
it is see a string to the rescue so what

00:33:20,749 --> 00:33:26,029
are we going to retain as we're building

00:33:23,090 --> 00:33:28,999
this library and what do we need to

00:33:26,029 --> 00:33:33,379
change we did start by looking at two

00:33:28,999 --> 00:33:35,720
string an STD string and we realized

00:33:33,379 --> 00:33:37,429
that 8-bit storage is a good thing for

00:33:35,720 --> 00:33:40,340
one thing that it covers the vast

00:33:37,429 --> 00:33:43,340
majority of text use cases in a more

00:33:40,340 --> 00:33:45,889
efficient way than 16-bit also

00:33:43,340 --> 00:33:47,840
importantly as I mentioned it guarantees

00:33:45,889 --> 00:33:49,659
that if you have issues with multibyte

00:33:47,840 --> 00:33:52,789
encoding you'll find them quickly

00:33:49,659 --> 00:33:57,070
because nearly every non-english

00:33:52,789 --> 00:33:59,989
character will exercise those code paths

00:33:57,070 --> 00:34:02,359
but what needs to change well we need to

00:33:59,989 --> 00:34:04,700
support encoding we need every string in

00:34:02,359 --> 00:34:07,669
the program to be tagged with its

00:34:04,700 --> 00:34:10,000
encoding and we really want to deal with

00:34:07,669 --> 00:34:13,609
Unicode because at this point in

00:34:10,000 --> 00:34:15,980
computer science there all of the other

00:34:13,609 --> 00:34:19,760
encoding czar basically historical

00:34:15,980 --> 00:34:21,770
artifacts and we wanted an ability for

00:34:19,760 --> 00:34:23,329
people to add new encoding formats as

00:34:21,770 --> 00:34:24,649
different things become available

00:34:23,329 --> 00:34:27,020
without having to change the

00:34:24,649 --> 00:34:29,330
implementation of the string class so

00:34:27,020 --> 00:34:32,210
our idea was to write a library

00:34:29,330 --> 00:34:36,230
where the iterators the class the basic

00:34:32,210 --> 00:34:38,990
string was all set and that we have one

00:34:36,230 --> 00:34:41,600
class where the encoding exists and

00:34:38,990 --> 00:34:46,280
that's all you need to modify and change

00:34:41,600 --> 00:34:50,410
and enhance to add a new encoding but we

00:34:46,280 --> 00:34:53,390
needed to define what comprised the

00:34:50,410 --> 00:34:56,690
basic and we're calling that CS basic

00:34:53,390 --> 00:34:58,820
string it does allow defining your own

00:34:56,690 --> 00:35:01,460
allocators we actually don't spend much

00:34:58,820 --> 00:35:03,860
time going over that if you need to set

00:35:01,460 --> 00:35:05,390
up your own allocator the library will

00:35:03,860 --> 00:35:10,160
take an alligator that you can pass to

00:35:05,390 --> 00:35:12,560
it what's important about using CS basic

00:35:10,160 --> 00:35:14,870
string is the fact that regardless of

00:35:12,560 --> 00:35:18,770
the encoding that the string is stored

00:35:14,870 --> 00:35:21,230
in the user always sees a CS basic

00:35:18,770 --> 00:35:23,300
string as a sequence of 32-bit code

00:35:21,230 --> 00:35:25,910
points you don't need to deal with the

00:35:23,300 --> 00:35:29,840
complexity of utf-8 multi byte sequences

00:35:25,910 --> 00:35:32,020
or utf-16 surrogate pairs or any other

00:35:29,840 --> 00:35:33,980
variable length encoding in any

00:35:32,020 --> 00:35:36,500
representation that you might be using

00:35:33,980 --> 00:35:42,050
and it supports conversion between these

00:35:36,500 --> 00:35:44,150
existing and codings as well so this is

00:35:42,050 --> 00:35:47,120
what it would look like we have just

00:35:44,150 --> 00:35:49,220
head up some musings so that you can

00:35:47,120 --> 00:35:51,050
type it easier this is part of the

00:35:49,220 --> 00:35:54,380
library currently the library does

00:35:51,050 --> 00:35:55,670
support utf-8 and utf-16 and we're going

00:35:54,380 --> 00:35:59,270
to show you how easy it is to add

00:35:55,670 --> 00:36:03,710
another encoding but first we had to say

00:35:59,270 --> 00:36:05,990
wait a minute what is a strength and

00:36:03,710 --> 00:36:08,930
these were some of the ideas we came up

00:36:05,990 --> 00:36:12,170
with of what a string is which is why

00:36:08,930 --> 00:36:14,720
this topic became so interesting to us

00:36:12,170 --> 00:36:17,540
and it actually becomes very complicated

00:36:14,720 --> 00:36:20,540
because all of these do satisfy the

00:36:17,540 --> 00:36:23,840
definition of what a string is but how

00:36:20,540 --> 00:36:25,400
do you handle each one of them and it's

00:36:23,840 --> 00:36:28,040
really important to understand the

00:36:25,400 --> 00:36:30,340
distinction between a few of these that

00:36:28,040 --> 00:36:35,870
we'll start looking at here

00:36:30,340 --> 00:36:38,350
so what datatypes do you see in these

00:36:35,870 --> 00:36:38,350
examples

00:36:39,040 --> 00:36:45,200
because many novice C or C++ programmers

00:36:43,880 --> 00:36:49,130
will look at that and go oh I see a

00:36:45,200 --> 00:36:53,120
bunch of strings but as we all know data

00:36:49,130 --> 00:36:56,030
types are quite distinct and can be

00:36:53,120 --> 00:36:58,580
complex what anybody care to guess what

00:36:56,030 --> 00:37:21,260
data types exist on the first line of

00:36:58,580 --> 00:37:24,860
code in here very well set yes it's very

00:37:21,260 --> 00:37:28,090
good very well ABC is also referred to

00:37:24,860 --> 00:37:30,380
as a string literal but most people

00:37:28,090 --> 00:37:32,270
aren't really sure they're like they

00:37:30,380 --> 00:37:34,670
just read it as it can't scare star

00:37:32,270 --> 00:37:38,660
mm-hmm so let's break these down piece

00:37:34,670 --> 00:37:41,240
by piece so for our purposes we're going

00:37:38,660 --> 00:37:43,550
to call a const character star a c style

00:37:41,240 --> 00:37:45,430
string many people have used that

00:37:43,550 --> 00:37:48,490
definition it's a little easier to hear

00:37:45,430 --> 00:37:50,990
it's initialized with a string literal a

00:37:48,490 --> 00:37:52,910
string literal being an expression has

00:37:50,990 --> 00:37:55,250
to have a datatype because the string

00:37:52,910 --> 00:37:58,030
literal is the expression itself it's

00:37:55,250 --> 00:38:01,430
data type is array of four characters as

00:37:58,030 --> 00:38:04,430
as you noted there's also a Const in

00:38:01,430 --> 00:38:06,920
there and a reference but the important

00:38:04,430 --> 00:38:12,350
meat of the definition is that it's an

00:38:06,920 --> 00:38:15,710
array of characters char type when on

00:38:12,350 --> 00:38:18,620
the second line when we assign STR one

00:38:15,710 --> 00:38:20,660
to a CS string this is unsafe because we

00:38:18,620 --> 00:38:22,520
don't know what encoding it's it we have

00:38:20,660 --> 00:38:25,670
no way of knowing this is a Const

00:38:22,520 --> 00:38:27,890
character star C style string variable

00:38:25,670 --> 00:38:31,910
that came in from who knows where this

00:38:27,890 --> 00:38:34,880
is not safe on the other hand in example

00:38:31,910 --> 00:38:37,700
two we have a CS string that's being

00:38:34,880 --> 00:38:40,150
initialized with a string literal these

00:38:37,700 --> 00:38:43,100
are not the same

00:38:40,150 --> 00:38:44,720
and the reason it's important these are

00:38:43,100 --> 00:38:46,490
not the same is because we want to be

00:38:44,720 --> 00:38:48,800
able to tell the difference between

00:38:46,490 --> 00:38:50,390
these two cases because if you're

00:38:48,800 --> 00:38:52,790
initializing a string with a string

00:38:50,390 --> 00:38:55,520
literal we know what encoding your

00:38:52,790 --> 00:38:58,100
string is in we can safely convert it to

00:38:55,520 --> 00:39:00,380
a CS string this yields a lot of API

00:38:58,100 --> 00:39:02,870
benefits if we don't know what encoding

00:39:00,380 --> 00:39:04,400
your string is in this is unsafe and we

00:39:02,870 --> 00:39:06,670
need to make this explicit or give you

00:39:04,400 --> 00:39:08,900
other ways to disallow it in your code

00:39:06,670 --> 00:39:10,850
and it turns out that it's actually

00:39:08,900 --> 00:39:12,800
fairly easy to tell the difference

00:39:10,850 --> 00:39:15,740
between these two cases in a string

00:39:12,800 --> 00:39:18,620
library so we have separate constructors

00:39:15,740 --> 00:39:19,760
in CS basic string one of them which

00:39:18,620 --> 00:39:22,850
takes a string literal

00:39:19,760 --> 00:39:25,550
which if you work through the datatype

00:39:22,850 --> 00:39:28,310
manipulation needs to be a constructor

00:39:25,550 --> 00:39:33,290
that takes a reference to an array of

00:39:28,310 --> 00:39:35,120
any size of Const character and then we

00:39:33,290 --> 00:39:36,320
have another one which allows passing in

00:39:35,120 --> 00:39:38,630
pointers but this can be either

00:39:36,320 --> 00:39:42,410
deprecated or disabled depending upon

00:39:38,630 --> 00:39:46,160
your needs in your application well why

00:39:42,410 --> 00:39:49,040
do we do this because we had an API

00:39:46,160 --> 00:39:51,590
requirement for CS string string

00:39:49,040 --> 00:39:54,680
literals are really important for API

00:39:51,590 --> 00:39:56,240
quality if you can't use string literals

00:39:54,680 --> 00:39:58,190
in your code when you're manipulating

00:39:56,240 --> 00:40:00,110
strings it becomes very difficult to

00:39:58,190 --> 00:40:03,200
read because you have constructor calls

00:40:00,110 --> 00:40:12,530
or conversions littering anything that

00:40:03,200 --> 00:40:15,620
works with strings okay so we're on

00:40:12,530 --> 00:40:19,580
sample code yes and another type of

00:40:15,620 --> 00:40:21,380
string literal so there are many types

00:40:19,580 --> 00:40:28,210
of string literal that we're added in

00:40:21,380 --> 00:40:31,820
C++ 11 do you this is not as well known

00:40:28,210 --> 00:40:34,280
but you can specify a string literal so

00:40:31,820 --> 00:40:37,820
you can specify the coding it was added

00:40:34,280 --> 00:40:41,720
in C++ 11 the syntax may not be gorgeous

00:40:37,820 --> 00:40:45,830
but at least it works please note that

00:40:41,720 --> 00:40:48,740
UTF 13 or 32 is not supported we're not

00:40:45,830 --> 00:40:50,980
quite sure why but they did not or they

00:40:48,740 --> 00:40:53,770
supported that when the unsupported

00:40:50,980 --> 00:40:56,410
we have not which one of my own you

00:40:53,770 --> 00:40:58,780
supported yes currently supported ones

00:40:56,410 --> 00:41:01,390
that are not supported the annoying one

00:40:58,780 --> 00:41:05,640
is caught scare yeah

00:41:01,390 --> 00:41:10,420
why wasn't that kind of scare 8 T

00:41:05,640 --> 00:41:12,849
Richard this is a Harry this is a

00:41:10,420 --> 00:41:15,430
terrible feature in the standard because

00:41:12,849 --> 00:41:17,650
it means that as a library implementer

00:41:15,430 --> 00:41:20,170
you can't tell the difference between a

00:41:17,650 --> 00:41:23,500
string literal which is in the compilers

00:41:20,170 --> 00:41:26,770
runtime encoding and a utf-8 string

00:41:23,500 --> 00:41:29,710
literal which is in utf-8 this is really

00:41:26,770 --> 00:41:32,980
unfortunate so we can easily support

00:41:29,710 --> 00:41:37,210
string literals of the utf-16 and utf-32

00:41:32,980 --> 00:41:40,839
type but it's ambiguous on the utf-8

00:41:37,210 --> 00:41:42,819
type we actually have a define in the

00:41:40,839 --> 00:41:45,549
library that you can turn on and off

00:41:42,819 --> 00:41:52,329
depending on how restrictive you want to

00:41:45,549 --> 00:41:55,660
make it so if you do happen to try to

00:41:52,329 --> 00:41:58,480
pass a string literal containing a

00:41:55,660 --> 00:42:01,299
multibyte character without specifying a

00:41:58,480 --> 00:42:03,160
Unicode encoding you will get a warning

00:42:01,299 --> 00:42:05,020
from your compiler and this is because

00:42:03,160 --> 00:42:09,579
the behavior is implementation defined

00:42:05,020 --> 00:42:12,880
here and the behavior on the compiler

00:42:09,579 --> 00:42:15,579
that we use most often GCC is in most

00:42:12,880 --> 00:42:18,640
cases to encode this string literal in

00:42:15,579 --> 00:42:21,069
utf-8 which then when the string is

00:42:18,640 --> 00:42:23,230
parsed in a different encoding creates

00:42:21,069 --> 00:42:24,790
some issues so this is something to

00:42:23,230 --> 00:42:27,430
avoid you should make sure that you have

00:42:24,790 --> 00:42:29,319
this warning turned on if you suppress

00:42:27,430 --> 00:42:35,109
warnings you probably don't want to

00:42:29,319 --> 00:42:39,910
suppress this one so the design of the

00:42:35,109 --> 00:42:42,390
library CS basic string it really

00:42:39,910 --> 00:42:44,740
encompasses everything we need to do

00:42:42,390 --> 00:42:49,119
it's pretty much a drop-in replacement

00:42:44,740 --> 00:42:51,670
for SC D string we have written all the

00:42:49,119 --> 00:42:56,609
methods find there's a lot of find

00:42:51,670 --> 00:43:01,059
methods we have added numerous ones and

00:42:56,609 --> 00:43:03,970
everything in CS basic string again it

00:43:01,059 --> 00:43:04,930
calls the encoding so nothing needs to

00:43:03,970 --> 00:43:07,540
change in

00:43:04,930 --> 00:43:09,760
the basic string class it does

00:43:07,540 --> 00:43:14,160
everything you would want it to do we

00:43:09,760 --> 00:43:17,230
have also started to add find fast and

00:43:14,160 --> 00:43:19,599
we are adding that in various places to

00:43:17,230 --> 00:43:22,300
do things that return an iterator not an

00:43:19,599 --> 00:43:25,480
index and this has become very powerful

00:43:22,300 --> 00:43:27,339
for us in copper spice when we want

00:43:25,480 --> 00:43:29,589
actually to deal with iterators and not

00:43:27,339 --> 00:43:31,900
indexes if you start breaking down the

00:43:29,589 --> 00:43:34,869
code and really looking at what it takes

00:43:31,900 --> 00:43:36,339
to do all the methods in STD string

00:43:34,869 --> 00:43:39,099
you'll find that everything is index

00:43:36,339 --> 00:43:41,079
based but again it is really nice to

00:43:39,099 --> 00:43:43,329
have iterators it's easier to work with

00:43:41,079 --> 00:43:45,220
it's actually easier to you're not

00:43:43,329 --> 00:43:50,290
dealing with off-by-one errors as much

00:43:45,220 --> 00:43:52,960
which we're notorious at finding so

00:43:50,290 --> 00:43:55,210
inside a CS basic strain we have a

00:43:52,960 --> 00:43:57,369
vector that contains the raw data in

00:43:55,210 --> 00:44:00,490
this case we'll be looking at utf-8 so

00:43:57,369 --> 00:44:02,230
it contains a utf-8 encoded string so we

00:44:00,490 --> 00:44:05,500
have a private data member called M

00:44:02,230 --> 00:44:07,359
string that is this vector and the

00:44:05,500 --> 00:44:09,240
beginning and the end of this our vector

00:44:07,359 --> 00:44:11,410
iterators well we don't want to expose

00:44:09,240 --> 00:44:13,690
the vector because we don't want to

00:44:11,410 --> 00:44:16,839
expose the raw underlying stream of

00:44:13,690 --> 00:44:18,369
bytes these are private so we want to

00:44:16,839 --> 00:44:20,410
give you a way to access the data

00:44:18,369 --> 00:44:22,690
without having to deal with the

00:44:20,410 --> 00:44:27,160
complexities of encoding so how do we do

00:44:22,690 --> 00:44:30,250
this we want to actually be able to walk

00:44:27,160 --> 00:44:32,049
code point by code point so what we did

00:44:30,250 --> 00:44:34,480
is we drew a graph here because like we

00:44:32,049 --> 00:44:37,720
said internally we're dealing with STD

00:44:34,480 --> 00:44:40,059
vector but outside as a user we're

00:44:37,720 --> 00:44:41,770
dealing with the cs string the reason

00:44:40,059 --> 00:44:44,680
why this slide becomes very powerful is

00:44:41,770 --> 00:44:49,540
you can see the right words downwards

00:44:44,680 --> 00:44:52,359
arrow is 3 bytes so if you're looking at

00:44:49,540 --> 00:44:54,730
it in a vector and you were walking the

00:44:52,359 --> 00:44:57,250
string length would look like it had

00:44:54,730 --> 00:45:01,079
three bytes for that but it's one code

00:44:57,250 --> 00:45:04,119
point and when you're walking the string

00:45:01,079 --> 00:45:06,309
externally or in an application you want

00:45:04,119 --> 00:45:08,609
to be able to walk code point by code

00:45:06,309 --> 00:45:08,609
point

00:45:09,800 --> 00:45:16,970
so here's the encoding this is all it

00:45:12,920 --> 00:45:19,730
takes for us to add utf-8 16 you want

00:45:16,970 --> 00:45:22,250
some other encoding this is all you

00:45:19,730 --> 00:45:24,410
would have to write this is the class

00:45:22,250 --> 00:45:26,960
for utf-8 we'll show a little bit of the

00:45:24,410 --> 00:45:29,720
implementation but it's using and a

00:45:26,960 --> 00:45:31,730
couple methods that's it that's all it

00:45:29,720 --> 00:45:34,730
takes you define these there's a new

00:45:31,730 --> 00:45:38,240
encoding in the library so we distilled

00:45:34,730 --> 00:45:40,550
the functionality that a string needs in

00:45:38,240 --> 00:45:42,710
order to work with an encoding down to

00:45:40,550 --> 00:45:47,330
this very simple API so it's very easy

00:45:42,710 --> 00:45:49,940
to implement new encodings and so here's

00:45:47,330 --> 00:45:52,490
an example of what the insert method

00:45:49,940 --> 00:45:54,590
looks like in utf-8 and if anybody here

00:45:52,490 --> 00:45:56,420
has actually worked with a utf-8

00:45:54,590 --> 00:45:58,610
encoding this code will probably look

00:45:56,420 --> 00:46:01,250
fairly similar it's just a bunch of

00:45:58,610 --> 00:46:03,080
straightforward boilerplate of doing

00:46:01,250 --> 00:46:05,360
some bit shifts and manipulating things

00:46:03,080 --> 00:46:08,960
into the right arrangement for storage

00:46:05,360 --> 00:46:11,930
in the utf-8 format this was actually

00:46:08,960 --> 00:46:13,250
very easy to test because we either put

00:46:11,930 --> 00:46:18,230
in the right characters and got it out

00:46:13,250 --> 00:46:20,830
or we didn't and the second half simply

00:46:18,230 --> 00:46:24,200
deals with the three byte and four byte

00:46:20,830 --> 00:46:28,310
utf-8 encoding z' again nothing terribly

00:46:24,200 --> 00:46:30,260
complex or high-tech here once you test

00:46:28,310 --> 00:46:35,300
the off by one arrows errors and they're

00:46:30,260 --> 00:46:38,060
fixed the encoding just works so when we

00:46:35,300 --> 00:46:41,600
ran through some of the testing Ansel

00:46:38,060 --> 00:46:44,210
wrote some not so human readable not so

00:46:41,600 --> 00:46:47,060
pretty testing and did about 1200 tests

00:46:44,210 --> 00:46:50,030
I wrote a little bit more human readable

00:46:47,060 --> 00:46:52,310
stuff that tests about 85 different

00:46:50,030 --> 00:46:54,230
outputs one of the great things is he

00:46:52,310 --> 00:46:57,140
tested everything that he could test

00:46:54,230 --> 00:46:58,610
against STDs string so that gave us a

00:46:57,140 --> 00:47:03,140
lot of confidence in the work we were

00:46:58,610 --> 00:47:05,570
doing mm-hmm and as an example of some

00:47:03,140 --> 00:47:08,060
of the testing we can do things like

00:47:05,570 --> 00:47:10,340
this where we can manipulate multibyte

00:47:08,060 --> 00:47:12,410
characters easily without having to deal

00:47:10,340 --> 00:47:15,650
with the complexities of how they're

00:47:12,410 --> 00:47:18,650
encoded in the string so we can just

00:47:15,650 --> 00:47:21,290
append a character outside the basic

00:47:18,650 --> 00:47:23,060
multilingual plane and it just works the

00:47:21,290 --> 00:47:24,950
test here that we're showing these

00:47:23,060 --> 00:47:27,470
unit-tests here they are part of the

00:47:24,950 --> 00:47:30,380
source code so if you go to our forum or

00:47:27,470 --> 00:47:34,010
our github these are actually included

00:47:30,380 --> 00:47:36,620
so you can take a look at them here's

00:47:34,010 --> 00:47:40,010
another example of a test which ought to

00:47:36,620 --> 00:47:41,900
be really easy every string library on

00:47:40,010 --> 00:47:45,290
the planet ought to be able to do this

00:47:41,900 --> 00:47:47,060
innately try this in your favorite

00:47:45,290 --> 00:47:48,830
language that claims to support Unicode

00:47:47,060 --> 00:47:51,110
strings and see how much work it is to

00:47:48,830 --> 00:47:53,660
actually get the right output just walk

00:47:51,110 --> 00:47:57,590
through a string in Reverse and print

00:47:53,660 --> 00:47:59,210
each symbol it is surprising how much

00:47:57,590 --> 00:48:01,970
code this takes if you have a library

00:47:59,210 --> 00:48:03,740
that does not give you the support for

00:48:01,970 --> 00:48:11,870
putting back together code points from

00:48:03,740 --> 00:48:14,330
the representation and then again just

00:48:11,870 --> 00:48:15,890
simply erasing the first character from

00:48:14,330 --> 00:48:18,200
the string and repeatedly printing it

00:48:15,890 --> 00:48:20,870
give this a try in your favorite library

00:48:18,200 --> 00:48:23,000
you will be surprised at how badly it

00:48:20,870 --> 00:48:26,260
will come out and if you're in c-sharp

00:48:23,000 --> 00:48:26,260
you will probably crash the runtime

00:48:28,750 --> 00:48:33,320
here's another test that we did and the

00:48:32,090 --> 00:48:34,760
only thing we're trying to point out is

00:48:33,320 --> 00:48:36,920
the storage versus the code point

00:48:34,760 --> 00:48:38,360
because when we show that graph we show

00:48:36,920 --> 00:48:41,840
that if you were walking the vector

00:48:38,360 --> 00:48:43,880
there would be a larger size so we did

00:48:41,840 --> 00:48:45,410
include that method in the library if

00:48:43,880 --> 00:48:48,470
you wanted to see how long it would be

00:48:45,410 --> 00:48:50,660
in terms of the size of the internal

00:48:48,470 --> 00:48:52,820
representation and the vector and by the

00:48:50,660 --> 00:48:56,000
way we are looking at changing the

00:48:52,820 --> 00:49:03,770
vector to be a small vector for

00:48:56,000 --> 00:49:05,930
optimization so we're in the process

00:49:03,770 --> 00:49:07,670
currently of taking the CS string

00:49:05,930 --> 00:49:09,980
library and integrating it back into

00:49:07,670 --> 00:49:12,290
copper spice and we're going to gain

00:49:09,980 --> 00:49:14,690
several benefits by doing this first and

00:49:12,290 --> 00:49:17,060
foremost that it will gain support for

00:49:14,690 --> 00:49:21,080
utf-8 strings which are much more

00:49:17,060 --> 00:49:25,400
efficient and and better designed we

00:49:21,080 --> 00:49:29,540
have about 75% of the Q string methods

00:49:25,400 --> 00:49:31,400
working in Q string eight it was very

00:49:29,540 --> 00:49:33,470
interesting like implementing things

00:49:31,400 --> 00:49:35,640
like to be able to normalize an upper

00:49:33,470 --> 00:49:38,070
and lower case when we were reading

00:49:35,640 --> 00:49:41,850
the existing code of various libraries

00:49:38,070 --> 00:49:44,790
of what it takes using our library our

00:49:41,850 --> 00:49:47,400
CS string library the code size went way

00:49:44,790 --> 00:49:49,980
down we didn't have to ask is this a

00:49:47,400 --> 00:49:52,170
high surrogate is this multibyte because

00:49:49,980 --> 00:49:55,170
we were just walking code points so our

00:49:52,170 --> 00:50:01,620
code got much smaller and much easier to

00:49:55,170 --> 00:50:03,570
read and easier to test we even got to

00:50:01,620 --> 00:50:05,010
resolve an issue that was actually

00:50:03,570 --> 00:50:09,210
broken in

00:50:05,010 --> 00:50:12,690
Doxey press and this is because you can

00:50:09,210 --> 00:50:15,420
do parsing with using the Lex parser and

00:50:12,690 --> 00:50:18,000
not using clang and the Lex parser

00:50:15,420 --> 00:50:19,740
turned out to be broken which was quite

00:50:18,000 --> 00:50:21,600
interesting as we were trying to display

00:50:19,740 --> 00:50:23,940
some documentation during our own

00:50:21,600 --> 00:50:27,180
testing and we couldn't figure out why

00:50:23,940 --> 00:50:29,420
utf-8 and utf-16 were broken and then we

00:50:27,180 --> 00:50:33,000
realized the parsing was broken so

00:50:29,420 --> 00:50:35,700
earlier when I said utf-8 is designed to

00:50:33,000 --> 00:50:38,130
pass unchanged and undamaged through

00:50:35,700 --> 00:50:41,340
most legacy code the key word there is

00:50:38,130 --> 00:50:44,550
most not all legacy code deals well with

00:50:41,340 --> 00:50:46,710
characters outside the zero zero through

00:50:44,550 --> 00:50:48,870
seven F of ASCII and this turned out to

00:50:46,710 --> 00:50:50,460
be one such case so examine your parsers

00:50:48,870 --> 00:50:53,310
carefully for what they do when they

00:50:50,460 --> 00:50:55,350
encounter non ASCII characters make sure

00:50:53,310 --> 00:50:57,270
it does something same and we did

00:50:55,350 --> 00:50:58,770
correct this in the Lex parser but if

00:50:57,270 --> 00:51:03,750
you're going to use the oxi press use

00:50:58,770 --> 00:51:05,880
clang for the parsing so this is sort of

00:51:03,750 --> 00:51:08,190
why we did everything we're working on

00:51:05,880 --> 00:51:11,310
copper spice we're working on doxy press

00:51:08,190 --> 00:51:13,980
and we needed ways to handle strings so

00:51:11,310 --> 00:51:16,680
this is kind of just an overview of how

00:51:13,980 --> 00:51:19,230
everything comes together for us as we

00:51:16,680 --> 00:51:22,680
are integrating everything back into cue

00:51:19,230 --> 00:51:25,080
string eight and as we do this in copper

00:51:22,680 --> 00:51:28,650
spice we're going to be able to add some

00:51:25,080 --> 00:51:32,010
using statements and and then do aq

00:51:28,650 --> 00:51:34,050
string and a utf-16 and have everything

00:51:32,010 --> 00:51:35,820
there based on our library we're also

00:51:34,050 --> 00:51:37,470
going to be able to remove some of the

00:51:35,820 --> 00:51:40,590
wrapper classes and some of the

00:51:37,470 --> 00:51:42,810
complexity internally we have already

00:51:40,590 --> 00:51:46,140
done some studies and we're expecting to

00:51:42,810 --> 00:51:49,380
see the internals of doxy press in many

00:51:46,140 --> 00:51:52,470
places shrink by 50% because so much

00:51:49,380 --> 00:52:00,090
of our internal strings are asking in

00:51:52,470 --> 00:52:02,550
Latin one so basically just to let you

00:52:00,090 --> 00:52:04,670
know like I said we released a we

00:52:02,550 --> 00:52:07,560
released this library earlier this year

00:52:04,670 --> 00:52:10,140
Ansel's released a lip guarded library

00:52:07,560 --> 00:52:13,590
on that is going to be presented

00:52:10,140 --> 00:52:17,610
tomorrow and we also have a signal slot

00:52:13,590 --> 00:52:19,590
library for delivery of signal slots

00:52:17,610 --> 00:52:22,650
that are based on methods and not

00:52:19,590 --> 00:52:25,770
classes so we have these three separate

00:52:22,650 --> 00:52:31,200
bsd libraries and we have copper spice

00:52:25,770 --> 00:52:32,880
and we have doxy press we also are

00:52:31,200 --> 00:52:34,680
thinking of some other things we want to

00:52:32,880 --> 00:52:36,450
do but we're trying to keep the number

00:52:34,680 --> 00:52:39,020
of projects we're doing down to just

00:52:36,450 --> 00:52:43,230
this because we think we have enough

00:52:39,020 --> 00:52:45,810
we're on github we have a website that

00:52:43,230 --> 00:52:48,810
has a form that you can download any of

00:52:45,810 --> 00:52:52,680
our source everything is open source

00:52:48,810 --> 00:52:55,860
everything we can BSD we do we also

00:52:52,680 --> 00:52:58,500
started a YouTube channel about two

00:52:55,860 --> 00:53:01,920
months ago and we crossed over to 400

00:52:58,500 --> 00:53:04,170
subscribers and hopefully will be much

00:53:01,920 --> 00:53:06,540
higher by the end of this conference our

00:53:04,170 --> 00:53:10,820
YouTube videos are on YouTube / copper

00:53:06,540 --> 00:53:15,600
spice our aim on these videos is to show

00:53:10,820 --> 00:53:18,300
copper spice doxy press and C++ we just

00:53:15,600 --> 00:53:20,790
did three videos that go through data

00:53:18,300 --> 00:53:22,620
types and value semantics and in these

00:53:20,790 --> 00:53:24,540
videos we take it from the beginning of

00:53:22,620 --> 00:53:27,050
what is the data type all the way

00:53:24,540 --> 00:53:30,750
through value semantics and pointers and

00:53:27,050 --> 00:53:32,850
references and on these videos we really

00:53:30,750 --> 00:53:37,830
explain why you can't call a reference

00:53:32,850 --> 00:53:40,050
just a reference so all of these things

00:53:37,830 --> 00:53:42,780
are available we're here all week to

00:53:40,050 --> 00:53:45,570
talk about all the products that we have

00:53:42,780 --> 00:53:48,870
and we would love to have contributors

00:53:45,570 --> 00:53:50,100
on the work that we're doing we do have

00:53:48,870 --> 00:53:52,260
a couple people that have been doing

00:53:50,100 --> 00:53:54,960
some extensive testing on the string

00:53:52,260 --> 00:53:57,330
library and one of the gentleman who is

00:53:54,960 --> 00:53:59,670
here at the conference he says the more

00:53:57,330 --> 00:54:02,670
he is using our library the more he

00:53:59,670 --> 00:54:06,200
realizes std string is broken

00:54:02,670 --> 00:54:16,380
and insufficient for the work he's doing

00:54:06,200 --> 00:54:18,300
so are there any questions yes oh we

00:54:16,380 --> 00:54:19,260
actually have a microphone excellent

00:54:18,300 --> 00:54:24,630
thank you I don't have to repeat the

00:54:19,260 --> 00:54:27,150
question so I'm a rust programmer yes

00:54:24,630 --> 00:54:30,660
and we obviously have a utf-8 string

00:54:27,150 --> 00:54:32,310
library in the standard library I don't

00:54:30,660 --> 00:54:35,490
know why that's obvious but we do okay

00:54:32,310 --> 00:54:37,170
uh it's pretty good and one of the

00:54:35,490 --> 00:54:39,300
things that was wearing me when I was

00:54:37,170 --> 00:54:41,270
watching your presentation was you have

00:54:39,300 --> 00:54:45,330
this kind of thing where you have

00:54:41,270 --> 00:54:46,680
indices and what worries me about that

00:54:45,330 --> 00:54:50,580
is when you have Graff games that are

00:54:46,680 --> 00:54:52,500
multiple code points so people kind of

00:54:50,580 --> 00:54:55,170
start it's the same issue you have with

00:54:52,500 --> 00:54:57,450
utf-16 right as people start to think

00:54:55,170 --> 00:55:00,630
you know one code point is one

00:54:57,450 --> 00:55:03,690
displayable character but if you're

00:55:00,630 --> 00:55:07,050
doing that like reverse iterator example

00:55:03,690 --> 00:55:11,010
mm-hmm unless you actually like pay

00:55:07,050 --> 00:55:13,500
attention to like NF KC and everything

00:55:11,010 --> 00:55:15,900
you're gonna have an issue where you'll

00:55:13,500 --> 00:55:18,570
print and eat and then you'll print the

00:55:15,900 --> 00:55:22,140
thing that goes on top of the the access

00:55:18,570 --> 00:55:23,880
yeah the accent yes so yeah to respond

00:55:22,140 --> 00:55:25,560
to that question about graphemes and

00:55:23,880 --> 00:55:29,940
graafian clusters and yeah and stuff

00:55:25,560 --> 00:55:34,500
like that that's version two for one

00:55:29,940 --> 00:55:36,420
thing the the design basis for CS string

00:55:34,500 --> 00:55:39,150
was let's design a container that is

00:55:36,420 --> 00:55:42,000
capable of representing unicode strings

00:55:39,150 --> 00:55:45,930
without mangling them adding the ability

00:55:42,000 --> 00:55:48,990
to process graphene by grapheme is in my

00:55:45,930 --> 00:55:50,940
vision a layer above that because the

00:55:48,990 --> 00:55:53,160
code point is the atomic unit of text

00:55:50,940 --> 00:55:56,610
and so that will probably be a

00:55:53,160 --> 00:55:58,770
translation layer that is built atop CS

00:55:56,610 --> 00:56:03,210
string right they still give you a

00:55:58,770 --> 00:56:06,960
graphene-based iterator we does Ross

00:56:03,210 --> 00:56:10,770
does is it has like iterators four code

00:56:06,960 --> 00:56:12,090
points and it has it everybody's bytes

00:56:10,770 --> 00:56:14,970
as well

00:56:12,090 --> 00:56:16,860
and but it doesn't let you index into a

00:56:14,970 --> 00:56:19,680
string which is something that I think

00:56:16,860 --> 00:56:23,040
is a good thing because it forces people

00:56:19,680 --> 00:56:25,770
to think what and forces people like in

00:56:23,040 --> 00:56:27,930
my compiler I have to use a Unicode

00:56:25,770 --> 00:56:30,720
library in order to deal with that kind

00:56:27,930 --> 00:56:32,850
of stuff so so with respect to not

00:56:30,720 --> 00:56:38,280
having the ability to index into a

00:56:32,850 --> 00:56:39,390
Unicode string I see that when you're

00:56:38,280 --> 00:56:41,820
starting from a clean sheet of paper

00:56:39,390 --> 00:56:44,640
that makes a lot of sense and our goal

00:56:41,820 --> 00:56:47,430
was also to be sort of a gateway drug to

00:56:44,640 --> 00:56:50,520
be a less harmful version of STD

00:56:47,430 --> 00:56:53,490
strength and people expect some sort of

00:56:50,520 --> 00:56:55,440
index based semantics you you may not

00:56:53,490 --> 00:56:57,060
get exactly a hundred percent

00:56:55,440 --> 00:56:59,400
correctness if you have very complex

00:56:57,060 --> 00:57:01,830
combining characters but at least you

00:56:59,400 --> 00:57:03,840
won't generate invalid Unicode to the

00:57:01,830 --> 00:57:07,860
level that in a library that allows you

00:57:03,840 --> 00:57:11,550
to put just a bare high surrogate in a

00:57:07,860 --> 00:57:13,490
string will do doing with copper spice

00:57:11,550 --> 00:57:16,950
is we've written normalization

00:57:13,490 --> 00:57:18,720
composition decomposition so we're kind

00:57:16,950 --> 00:57:19,950
of spending some of our effort you know

00:57:18,720 --> 00:57:22,560
what does it take to upper and lower

00:57:19,950 --> 00:57:24,450
case what does it take to compare so

00:57:22,560 --> 00:57:26,610
we've done a lot of this in copper spice

00:57:24,450 --> 00:57:29,280
not with the idea of just leaving it

00:57:26,610 --> 00:57:32,010
there but the idea of once we figure out

00:57:29,280 --> 00:57:33,870
exactly the best ways how to do that

00:57:32,010 --> 00:57:36,180
like you're saying I have a layer two of

00:57:33,870 --> 00:57:38,190
the library you didn't want to add we

00:57:36,180 --> 00:57:40,740
didn't want to do it wrong yeah yeah and

00:57:38,190 --> 00:57:42,480
and so it's really like you know right

00:57:40,740 --> 00:57:44,640
now you would have to decompose the

00:57:42,480 --> 00:57:48,120
string but we've learned a lot about

00:57:44,640 --> 00:57:50,370
strings just writing this decompose in

00:57:48,120 --> 00:57:52,890
cue string eight so we can understand

00:57:50,370 --> 00:57:54,360
what does it take and when you start

00:57:52,890 --> 00:57:56,460
getting into the accents and the

00:57:54,360 --> 00:57:58,920
graphene's and just a language because

00:57:56,460 --> 00:58:01,980
we do mostly tend in programming and

00:57:58,920 --> 00:58:05,220
when we couldn't communicate it became

00:58:01,980 --> 00:58:08,130
complicated so yeah we are we're nowhere

00:58:05,220 --> 00:58:10,770
near done with what we're doing but part

00:58:08,130 --> 00:58:14,340
of this is to find other people who want

00:58:10,770 --> 00:58:16,560
to contribute add more encoding and to

00:58:14,340 --> 00:58:18,840
find out what's missing yeah but right

00:58:16,560 --> 00:58:22,890
now is a drop-in replacement we think

00:58:18,840 --> 00:58:24,660
we've we've covered most of that we've

00:58:22,890 --> 00:58:25,880
improved on the current situation a

00:58:24,660 --> 00:58:27,070
choice plus but

00:58:25,880 --> 00:58:29,060
thank you very much for your feedback

00:58:27,070 --> 00:58:32,630
yeah helps us know that we're actually

00:58:29,060 --> 00:58:37,160
going in a good direction I think any

00:58:32,630 --> 00:58:39,440
other questions okay well we appreciate

00:58:37,160 --> 00:58:42,680
it if you think of questions we're here

00:58:39,440 --> 00:58:44,360
all week and we're online and thank you

00:58:42,680 --> 00:58:51,719
so much for coming

00:58:44,360 --> 00:58:51,719

YouTube URL: https://www.youtube.com/watch?v=ysh2B6ZgNXk


