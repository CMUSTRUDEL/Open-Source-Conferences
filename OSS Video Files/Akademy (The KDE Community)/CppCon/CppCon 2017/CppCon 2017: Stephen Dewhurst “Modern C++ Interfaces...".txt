Title: CppCon 2017: Stephen Dewhurst “Modern C++ Interfaces..."
Publication date: 2017-10-05
Playlist: CppCon 2017
Description: 
	“Modern C++ Interfaces: Complexity, Emergent Simplicity, SFINAE, and Second Order Properties of Types"

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We examine how the increasing complexity of language features related to interfaces in modern C++ has somewhat surprisingly produced increasing simplicity in the interfaces themselves. 

One of the major reasons for this emergent simplicity is common use of “substitution failure is not an error” or SFINAE in interface design. Appropriate use of SFINAE allows the production of “do what I mean” or DWIM interfaces that allow experienced designers to embed their judgement in interfaces.

Most of the presentation will consist in examination of practical examples of SFINAE in interface design and development of a simple toolkit that automates construction of compile time template predicates. Abstract syntax trees are evaluated at compile time to enforce complex constraints on types in the SFINAE context.
— 
Stephen Dewhurst:  Semantics Consulting, Inc., President

Steve Dewhurst is the co-founder and president of Semantics Consulting, Inc. Steve is the author of numerous technical articles on C++ programming techniques and compiler design, is the author of the critically acclaimed books C++ Common Knowledge and C++ Gotchas, and is the co-author of Programming in C++. He is a frequent speaker at industry conferences, where his presentations are consistently among the most popular and highest rated. He is also a member of the advisory board for The C++ Source, was programming track chair for the Embedded Systems Conference (ESC), and was a visiting scientist at the Software Engineering Institute (SEI) at Carnegie Mellon University. Steve has mentored and consulted with C++ projects ranging in size from 1 to over 100 developers, in areas ranging from compiler design to embedded telecommunications to ecommerce to derivative securities trading. As a Member of Technical Staff in the UNIX Development Laboratory at AT&T Bell Laboratories, Steve worked with Bjarne Stroustrup, the designer and first implementer of C++, on the first public release of the language and cfront C++ compiler, then served as the lead designer and implementer of the first non-cfront C++ compiler. As a compiler architect at Glockenspiel, Ltd., he designed and implemented a second C++ compiler. Steve was a contributing editor for The C/C++ User's Journal, a principal lecturer at The C++ Seminar, has served as a principal on the ANSI/ISO C++ standardization committee, was the C++ training series adviser for Technology Exchange Company (Addison-Wesley), was a member of the editorial board of and columnist for C++ Report, co-founder and member of the editorial board of The C++ Journal, and a Visiting Professor of Computer Science at Jackson State University. He has also written C, COBOL, and Pascal compilers, was a principal on the ANSI/IEEE Pascal Standardization Committee, and a reviewer for ACM Computing Reviews. Semantics Consulting, Inc. is located in the small New England town of Carver, Massachusetts. Like all small New England towns, Carver has a tradition of citizen involvement, and over the years Steve has been astonished to find himself harvesting cranberries, coaching the high school wrestling team, and serving on the town water commission, finance committee, and website committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,629
I get this talk a while back almost two

00:00:02,730 --> 00:00:10,620
years ago in a very small venue and the

00:00:06,629 --> 00:00:12,090
reaction to it was stunned surprise but

00:00:10,620 --> 00:00:14,190
as for F what be earnest said this

00:00:12,090 --> 00:00:18,600
morning in his keynote I think this is

00:00:14,190 --> 00:00:19,980
all accepted practice at this point so

00:00:18,600 --> 00:00:22,170
I'm not expecting to say anything too

00:00:19,980 --> 00:00:24,119
surprising to you but I do want to

00:00:22,170 --> 00:00:32,600
emphasize a few points about our modern

00:00:24,119 --> 00:00:36,600
C++ so there has been a progression in

00:00:32,600 --> 00:00:39,120
the way we treat our interfaces policy

00:00:36,600 --> 00:00:43,230
based design was very popular when early

00:00:39,120 --> 00:00:45,329
2000s and that was a design technique

00:00:43,230 --> 00:00:49,230
that basically took well understood

00:00:45,329 --> 00:00:52,079
engineering problems and identified

00:00:49,230 --> 00:00:57,030
certain decision points in a design and

00:00:52,079 --> 00:00:59,280
then we reified those decision points

00:00:57,030 --> 00:01:00,899
I'll of reification it's a term from

00:00:59,280 --> 00:01:02,520
sociology that means take something

00:01:00,899 --> 00:01:04,650
that's insubstantial give it a name give

00:01:02,520 --> 00:01:07,170
it operations so you can reason about it

00:01:04,650 --> 00:01:10,229
in a very concrete way so when we were

00:01:07,170 --> 00:01:11,460
doing a well-understood design we'd read

00:01:10,229 --> 00:01:14,909
certain points and we make a decision

00:01:11,460 --> 00:01:18,270
how do I represent this data how do I

00:01:14,909 --> 00:01:20,790
respond to this event and rather than

00:01:18,270 --> 00:01:23,340
make the decision we indicate that there

00:01:20,790 --> 00:01:25,979
was a decision to be made and defer the

00:01:23,340 --> 00:01:29,100
actual decision to the user of the

00:01:25,979 --> 00:01:30,570
component so they can produce customized

00:01:29,100 --> 00:01:33,479
components in a fairly straightforward

00:01:30,570 --> 00:01:38,130
way depending on the context in which

00:01:33,479 --> 00:01:41,549
they're used and if you remember Andrej

00:01:38,130 --> 00:01:43,079
Alexander excuse modern C++ design which

00:01:41,549 --> 00:01:44,720
did a lot of policy based design he

00:01:43,079 --> 00:01:48,659
focused on design patterns which

00:01:44,720 --> 00:01:49,920
basically are well understood

00:01:48,659 --> 00:01:51,659
engineering techniques that were

00:01:49,920 --> 00:01:53,310
customized according to the context of

00:01:51,659 --> 00:01:56,040
their application and so policy based

00:01:53,310 --> 00:01:59,700
design was a good fit for that but there

00:01:56,040 --> 00:02:03,000
was one problem with it it required an

00:01:59,700 --> 00:02:05,399
expert user to use it correctly so we

00:02:03,000 --> 00:02:07,500
try to finesse that by having default

00:02:05,399 --> 00:02:09,929
design decisions that could be taken by

00:02:07,500 --> 00:02:11,900
a less experienced user but things are

00:02:09,929 --> 00:02:14,600
getting more complex have you know

00:02:11,900 --> 00:02:17,040
remember the code you wrote 40 years ago

00:02:14,600 --> 00:02:19,680
No

00:02:17,040 --> 00:02:22,160
so what we'd like to do now is we tend

00:02:19,680 --> 00:02:24,410
to move our experience into our code

00:02:22,160 --> 00:02:27,120
instead of putting it in the interface

00:02:24,410 --> 00:02:29,280
so we want to simplify the interfaces

00:02:27,120 --> 00:02:32,310
but still have experienced adaptable

00:02:29,280 --> 00:02:36,140
code and so we try to do an embedding of

00:02:32,310 --> 00:02:38,310
our knowledge into the code and lately

00:02:36,140 --> 00:02:41,100
at least probably at least before we

00:02:38,310 --> 00:02:44,820
have concepts and even after concepts we

00:02:41,100 --> 00:02:47,900
use SPN a best based techniques to make

00:02:44,820 --> 00:02:53,610
our interfaces smarter or more natural

00:02:47,900 --> 00:02:55,830
so this increased complexity well how do

00:02:53,610 --> 00:02:59,819
we deal with complexity in C++ or in any

00:02:55,830 --> 00:03:03,420
complex linguistic situation convention

00:02:59,819 --> 00:03:06,180
an idiom the more complex the language

00:03:03,420 --> 00:03:08,430
the more idioms there are because idioms

00:03:06,180 --> 00:03:09,930
tend to simplify they're like lower

00:03:08,430 --> 00:03:12,480
level design patterns they tell you how

00:03:09,930 --> 00:03:15,120
to create higher-level structures with

00:03:12,480 --> 00:03:17,640
lower-level components so you can raise

00:03:15,120 --> 00:03:19,260
the level of discourse speak design and

00:03:17,640 --> 00:03:22,049
communicate at a higher level and

00:03:19,260 --> 00:03:24,540
thereby simplify your designs so idiom

00:03:22,049 --> 00:03:26,100
is very important and part of that is

00:03:24,540 --> 00:03:31,769
actually creating interfaces that

00:03:26,100 --> 00:03:33,810
express your intent very well and one of

00:03:31,769 --> 00:03:35,820
the nice things about modern C++ is we

00:03:33,810 --> 00:03:40,560
have a lot of features that make this

00:03:35,820 --> 00:03:47,180
easy to do so here is something that is

00:03:40,560 --> 00:03:47,180
no longer a divisive statement I hope

00:03:47,209 --> 00:03:54,810
C++ is now so complex that has become

00:03:51,180 --> 00:03:56,760
easier to use because we've hit a level

00:03:54,810 --> 00:03:59,070
of complexity where we have to use

00:03:56,760 --> 00:04:00,750
convention we have to use idiom we have

00:03:59,070 --> 00:04:04,440
to use techniques to simplify our

00:04:00,750 --> 00:04:06,540
interfaces and as a result it's easy to

00:04:04,440 --> 00:04:09,840
program in C++ now it's a lot easier

00:04:06,540 --> 00:04:12,780
than it was in 1998 to write a correct

00:04:09,840 --> 00:04:14,850
easy to use interface we could have put

00:04:12,780 --> 00:04:17,280
scott Meyers out of business if we'd

00:04:14,850 --> 00:04:23,310
done this some years ago that's a joke

00:04:17,280 --> 00:04:24,070
guys okay so we look at convention idiom

00:04:23,310 --> 00:04:26,980
embedding your

00:04:24,070 --> 00:04:28,480
appearance in your code and do what I

00:04:26,980 --> 00:04:30,460
mean interfaces and these are things

00:04:28,480 --> 00:04:31,870
we're doing all the time now but this is

00:04:30,460 --> 00:04:36,370
how we started out we started out by

00:04:31,870 --> 00:04:38,680
threatening people which is that works

00:04:36,370 --> 00:04:40,870
in some situations but not universally

00:04:38,680 --> 00:04:42,790
because this programmers would you're

00:04:40,870 --> 00:04:44,590
you're already a C++ programmer so you

00:04:42,790 --> 00:04:46,030
must be fearless from the get-go so

00:04:44,590 --> 00:04:48,730
nobody's going to intimidate you with a

00:04:46,030 --> 00:04:50,290
comment it's not even gonna read the

00:04:48,730 --> 00:04:54,130
comment which is kind of the problem

00:04:50,290 --> 00:04:56,940
here's a simple simple function that

00:04:54,130 --> 00:05:00,510
takes an array and makes a copy of it

00:04:56,940 --> 00:05:03,550
but it does a mem copy to make the copy

00:05:00,510 --> 00:05:05,080
so of course everybody knows everybody

00:05:03,550 --> 00:05:06,640
knows you go to somebody on the street

00:05:05,080 --> 00:05:11,770
and say would you mem copy a string

00:05:06,640 --> 00:05:12,910
they'd say no they probably would

00:05:11,770 --> 00:05:17,710
because they probably wouldn't be mem

00:05:12,910 --> 00:05:18,910
copying a string but this comments not

00:05:17,710 --> 00:05:20,560
really helping us very much because

00:05:18,910 --> 00:05:24,400
somebody somewhere is gonna do something

00:05:20,560 --> 00:05:27,910
so we decided to become totalitarian

00:05:24,400 --> 00:05:30,340
we've given up direct threats and we're

00:05:27,910 --> 00:05:33,070
just preventing people from thinking in

00:05:30,340 --> 00:05:36,220
the wrong way so we'll insert a

00:05:33,070 --> 00:05:40,840
constraint and this is something we

00:05:36,220 --> 00:05:43,630
could do in for decades it's much easier

00:05:40,840 --> 00:05:46,060
and nicer to do it now a modern C++ but

00:05:43,630 --> 00:05:48,100
it's it's something achievable a long

00:05:46,060 --> 00:05:50,500
time ago it just became fashionable more

00:05:48,100 --> 00:05:55,810
recently again in response to increase

00:05:50,500 --> 00:05:57,100
complexity for instance how could that

00:05:55,810 --> 00:06:09,100
how would this feel would somebody

00:05:57,100 --> 00:06:11,500
actually pass an array of non memk2 - 10

00:06:09,100 --> 00:06:14,200
they wouldn't so how do how do we get a

00:06:11,500 --> 00:06:17,110
bug here's an observation for many years

00:06:14,200 --> 00:06:21,100
in the trenches most good bugs are team

00:06:17,110 --> 00:06:22,360
efforts it requires cooperation from a

00:06:21,100 --> 00:06:25,150
number of people to produce a really

00:06:22,360 --> 00:06:27,520
good bug so one bug here is hoping the

00:06:25,150 --> 00:06:30,280
comment is enough to dissuade people

00:06:27,520 --> 00:06:30,970
from sending something that's not in

00:06:30,280 --> 00:06:34,240
them copyable

00:06:30,970 --> 00:06:35,470
and so that's fine the original the

00:06:34,240 --> 00:06:37,420
original user of this function might

00:06:35,470 --> 00:06:40,120
pass an array of structs

00:06:37,420 --> 00:06:43,720
that contain things like integers and

00:06:40,120 --> 00:06:44,560
doubles and arrays of characters which

00:06:43,720 --> 00:06:46,090
are mem copyable

00:06:44,560 --> 00:06:49,900
we could just mem copy those things not

00:06:46,090 --> 00:06:54,130
worry about it and then I don't mean to

00:06:49,900 --> 00:06:56,860
offend anybody all right I do what

00:06:54,130 --> 00:06:59,250
happens around mid-may every year your

00:06:56,860 --> 00:07:06,430
code starts to break right

00:06:59,250 --> 00:07:08,140
why summer interns now I will say that

00:07:06,430 --> 00:07:09,400
when I say summer intern that's actually

00:07:08,140 --> 00:07:12,010
what's known as an ideal type in

00:07:09,400 --> 00:07:13,870
sociology it's a it's a role that you

00:07:12,010 --> 00:07:15,340
take on in certain social situations at

00:07:13,870 --> 00:07:18,100
work so we're all summer interns on a

00:07:15,340 --> 00:07:19,480
bad day and so sometime around mid-may

00:07:18,100 --> 00:07:22,270
or if you're behaving like a summer

00:07:19,480 --> 00:07:24,040
intern somebody who doesn't even know

00:07:22,270 --> 00:07:25,540
about this code it's gonna modify that

00:07:24,040 --> 00:07:26,910
struct and replace that array of

00:07:25,540 --> 00:07:29,860
characters with a string

00:07:26,910 --> 00:07:32,290
what's going to happen now the codes

00:07:29,860 --> 00:07:34,030
still going to work why because the

00:07:32,290 --> 00:07:35,860
string has the small string optimization

00:07:34,030 --> 00:07:39,250
it stores a string is an array of

00:07:35,860 --> 00:07:41,920
characters unless it gets long when do

00:07:39,250 --> 00:07:44,830
you encounter a long string in the

00:07:41,920 --> 00:07:46,570
demonstration that's being broadcast to

00:07:44,830 --> 00:07:48,010
everyone on the planet so you know a

00:07:46,570 --> 00:07:50,700
broken code you just don't know it yet

00:07:48,010 --> 00:07:54,190
so a bug like that is a real team effort

00:07:50,700 --> 00:07:56,710
so by doing this simply by doing this we

00:07:54,190 --> 00:08:00,010
are really improving the safety of our

00:07:56,710 --> 00:08:02,440
code we're able to after selecting this

00:08:00,010 --> 00:08:05,110
function have a constraint on it this is

00:08:02,440 --> 00:08:07,150
not a concept this is acting after the

00:08:05,110 --> 00:08:09,160
fact and that's fine a lot of times

00:08:07,150 --> 00:08:10,930
that's what we want to do so we can make

00:08:09,160 --> 00:08:13,240
sure that whatever we're passing here is

00:08:10,930 --> 00:08:15,100
indeed trivially copyable that's not

00:08:13,240 --> 00:08:20,470
really good enough what we'd really like

00:08:15,100 --> 00:08:22,000
to do is make our code experienced we

00:08:20,470 --> 00:08:24,990
want to take all of our knowledge and

00:08:22,000 --> 00:08:31,420
experience and embed it in our code

00:08:24,990 --> 00:08:32,860
making ourselves redundant so what are

00:08:31,420 --> 00:08:34,870
we doing now this is really really

00:08:32,860 --> 00:08:37,030
simple we're just gonna say well you

00:08:34,870 --> 00:08:39,550
know based on my experience if something

00:08:37,030 --> 00:08:42,100
is trivially copyable i can do a mem

00:08:39,550 --> 00:08:44,650
copy otherwise if it does if it has a no

00:08:42,100 --> 00:08:48,640
throw copy constructor I can do this

00:08:44,650 --> 00:08:51,220
beautiful placement new you have to love

00:08:48,640 --> 00:08:53,740
this statement and just call

00:08:51,220 --> 00:08:55,660
the copy constructor 40 and successively

00:08:53,740 --> 00:08:57,819
initialize previously uninitialized

00:08:55,660 --> 00:09:00,959
memory not worrying about exceptions and

00:08:57,819 --> 00:09:03,189
then of course what's the third case

00:09:00,959 --> 00:09:05,980
well what if the copy constructor could

00:09:03,189 --> 00:09:09,189
throw an exception so we'd have to take

00:09:05,980 --> 00:09:10,449
care of that and at this point someone

00:09:09,189 --> 00:09:11,949
should say well isn't there a standard

00:09:10,449 --> 00:09:14,230
library function for this the answers

00:09:11,949 --> 00:09:17,290
yes but who's gonna write that standard

00:09:14,230 --> 00:09:21,490
library function so this code actually

00:09:17,290 --> 00:09:23,290
adjusts itself depending on properties

00:09:21,490 --> 00:09:25,360
of the type that is passed to it and

00:09:23,290 --> 00:09:27,990
that's nice and it works very well

00:09:25,360 --> 00:09:31,540
provided that all of this code is

00:09:27,990 --> 00:09:33,459
mutually compatible in other words if

00:09:31,540 --> 00:09:35,709
this compiles correctly this must also

00:09:33,459 --> 00:09:45,209
compile correctly and that's not always

00:09:35,709 --> 00:09:47,680
the case so I can't remember whether I

00:09:45,209 --> 00:09:50,230
remove the slide or not but in modern

00:09:47,680 --> 00:09:51,879
C++ oh look there it is I thought it

00:09:50,230 --> 00:09:55,540
looked familiar we can use a constant

00:09:51,879 --> 00:09:57,519
expert if instead so this is now a

00:09:55,540 --> 00:09:59,019
compile time constant this is a template

00:09:57,519 --> 00:10:02,079
and undergoes two-phase translation

00:09:59,019 --> 00:10:04,540
first phase is parsed and non-dependent

00:10:02,079 --> 00:10:07,029
names are bound second phase we complete

00:10:04,540 --> 00:10:09,339
the translation knowing what type T is

00:10:07,029 --> 00:10:12,100
the nice thing about the context / if is

00:10:09,339 --> 00:10:15,790
it will not engage in the second phase

00:10:12,100 --> 00:10:17,230
of translation in a in a path it's not

00:10:15,790 --> 00:10:19,149
going to be taken by this compile time

00:10:17,230 --> 00:10:20,860
if so the nice thing about that is you

00:10:19,149 --> 00:10:24,250
can actually have mutually incompatible

00:10:20,860 --> 00:10:26,920
code in the same function and still get

00:10:24,250 --> 00:10:29,189
a correct translation now this is

00:10:26,920 --> 00:10:32,439
something we could do by having a

00:10:29,189 --> 00:10:35,230
function forward do a compile time

00:10:32,439 --> 00:10:37,269
algorithm selection but this is much

00:10:35,230 --> 00:10:40,059
much easier to write and it's actually

00:10:37,269 --> 00:10:42,069
clear a non-expert somebody who hasn't

00:10:40,059 --> 00:10:43,899
been programming a c++ for 30 years can

00:10:42,069 --> 00:10:47,829
see what's going on here it can kind of

00:10:43,899 --> 00:10:49,269
guess what's happening that's nice so

00:10:47,829 --> 00:10:53,100
we're embedding our judgment in our code

00:10:49,269 --> 00:10:53,100
and the more we can do that the better

00:10:54,480 --> 00:10:58,779
okay and so the the interface is

00:10:56,949 --> 00:11:00,309
certainly simplified we have a single

00:10:58,779 --> 00:11:02,829
function that copies an array and the

00:11:00,309 --> 00:11:04,370
function itself asks relevant questions

00:11:02,829 --> 00:11:05,960
of its types at compile time

00:11:04,370 --> 00:11:09,260
and chooses the correct implementation

00:11:05,960 --> 00:11:12,260
based on our judgment and that's good so

00:11:09,260 --> 00:11:16,510
what is causing our interfaces to be

00:11:12,260 --> 00:11:19,610
potentially more complex

00:11:16,510 --> 00:11:20,330
well those initializer list things

00:11:19,610 --> 00:11:25,390
showed up

00:11:20,330 --> 00:11:25,390
I like initializer lists but they're

00:11:26,080 --> 00:11:32,810
privileged there whenever you match a

00:11:30,410 --> 00:11:35,210
function you you know initializer list

00:11:32,810 --> 00:11:37,040
wants to come in and first and if you

00:11:35,210 --> 00:11:41,029
looked at the how many people like to

00:11:37,040 --> 00:11:46,370
read the standard before going to bed am

00:11:41,029 --> 00:11:49,220
I the only one Oh paisan so if you look

00:11:46,370 --> 00:11:51,710
at the overloading section there's a new

00:11:49,220 --> 00:11:53,839
paragraph if it's initializer list call

00:11:51,710 --> 00:11:56,360
it basically is what it says so

00:11:53,839 --> 00:11:58,550
initializer lists can actually if you

00:11:56,360 --> 00:11:59,810
modify your your interface to take an

00:11:58,550 --> 00:12:00,950
initializer list all of a sudden

00:11:59,810 --> 00:12:02,900
existing code starts behaving

00:12:00,950 --> 00:12:06,200
differently so that's a very frightening

00:12:02,900 --> 00:12:07,640
thing things that were formally calling

00:12:06,200 --> 00:12:09,400
some other constructor will now cause a

00:12:07,640 --> 00:12:11,510
call initializer list constructor

00:12:09,400 --> 00:12:12,680
universal references or forwarding

00:12:11,510 --> 00:12:16,250
references or whatever they're called

00:12:12,680 --> 00:12:17,630
these days are really greedy and if you

00:12:16,250 --> 00:12:21,050
try to overload with universal

00:12:17,630 --> 00:12:22,900
references things become nuanced if

00:12:21,050 --> 00:12:26,150
you're feeling in a good mood or

00:12:22,900 --> 00:12:28,790
disastrous otherwise backward

00:12:26,150 --> 00:12:30,260
compatibility the the longer we have the

00:12:28,790 --> 00:12:32,779
more backward we have the harder it is

00:12:30,260 --> 00:12:34,610
to be backward compatible so we're

00:12:32,779 --> 00:12:36,830
writing code sorry we're writing

00:12:34,610 --> 00:12:38,420
language extensions and compilers that

00:12:36,830 --> 00:12:41,540
have to deal with code that's thirty

00:12:38,420 --> 00:12:44,209
years old and that's a rough thing to do

00:12:41,540 --> 00:12:45,980
especially have you noticed that not

00:12:44,209 --> 00:12:48,470
everybody reads the standard every night

00:12:45,980 --> 00:12:54,140
before bed and sometimes does do things

00:12:48,470 --> 00:12:57,140
that are not well defined behavior there

00:12:54,140 --> 00:13:00,700
the the history of C++ code is littered

00:12:57,140 --> 00:13:04,310
with entire projects that depended on

00:13:00,700 --> 00:13:06,380
undefined behavior and are now breaking

00:13:04,310 --> 00:13:07,580
because you know that they shouldn't

00:13:06,380 --> 00:13:08,690
have worked in the first place or the

00:13:07,580 --> 00:13:12,680
word guaranteed to work in the first

00:13:08,690 --> 00:13:14,510
place and overloading function templates

00:13:12,680 --> 00:13:19,150
are increasingly that there are more and

00:13:14,510 --> 00:13:21,980
more rules there's some really

00:13:19,150 --> 00:13:23,780
fine-grain rules for deciding when one

00:13:21,980 --> 00:13:25,970
function when one overloaded function

00:13:23,780 --> 00:13:30,430
has chosen over another particularly in

00:13:25,970 --> 00:13:33,980
the presence of reference collapsing I

00:13:30,430 --> 00:13:35,750
don't want it's illegal to actually talk

00:13:33,980 --> 00:13:40,550
about reference collapsing in the state

00:13:35,750 --> 00:13:44,330
so so this increased complexity is not

00:13:40,550 --> 00:13:46,550
in itself an advantage but the presence

00:13:44,330 --> 00:13:48,590
of the complexity has actually forced us

00:13:46,550 --> 00:13:51,710
to become better programmers and better

00:13:48,590 --> 00:13:53,810
designers to depend more on convention

00:13:51,710 --> 00:13:59,270
and to pay even more attention to our

00:13:53,810 --> 00:14:03,380
interfaces what is what have we gotten

00:13:59,270 --> 00:14:04,730
to help us with this well a lot of

00:14:03,380 --> 00:14:07,100
people may not realize that design

00:14:04,730 --> 00:14:09,950
patterns actually was an architectural

00:14:07,100 --> 00:14:11,450
discipline felon and Christopher

00:14:09,950 --> 00:14:13,040
Alexander and his colleagues developed

00:14:11,450 --> 00:14:15,050
design patterns in the context of

00:14:13,040 --> 00:14:16,900
architecture to build houses and so on

00:14:15,050 --> 00:14:18,680
and they looked at traditional

00:14:16,900 --> 00:14:21,590
architectures like New England

00:14:18,680 --> 00:14:23,750
farmhouses and Maryland telescope houses

00:14:21,590 --> 00:14:25,190
and things like that and they discerned

00:14:23,750 --> 00:14:28,040
that they were generated from the small

00:14:25,190 --> 00:14:30,200
set of patterns and the patterns were

00:14:28,040 --> 00:14:31,370
customized depending on the context in

00:14:30,200 --> 00:14:34,780
which the building was going to be built

00:14:31,370 --> 00:14:37,550
and so on exactly what we do with our

00:14:34,780 --> 00:14:40,190
architectural patterns in in software

00:14:37,550 --> 00:14:42,560
design and there's one pattern I really

00:14:40,190 --> 00:14:44,060
like some of them are really important

00:14:42,560 --> 00:14:45,650
how do you organize your town so there

00:14:44,060 --> 00:14:48,800
are fewer traffic fatalities that's a

00:14:45,650 --> 00:14:50,000
good one t-shaped intersections just

00:14:48,800 --> 00:14:56,210
remember that next time you design in

00:14:50,000 --> 00:14:58,190
town and but some of them are very C

00:14:56,210 --> 00:15:01,250
minor but they aren't and one of my

00:14:58,190 --> 00:15:03,890
favorite is waist-high shelf this is an

00:15:01,250 --> 00:15:06,710
actual pattern so you're coming home

00:15:03,890 --> 00:15:08,660
with your groceries you unlock the door

00:15:06,710 --> 00:15:10,820
with your teeth where you leave the door

00:15:08,660 --> 00:15:12,920
unlocked whatever you know depending on

00:15:10,820 --> 00:15:14,210
how brave you are you kick the door open

00:15:12,920 --> 00:15:18,350
and then you're in with your groceries

00:15:14,210 --> 00:15:20,990
what do you do the counter is not waste

00:15:18,350 --> 00:15:22,070
time yeah you want to have you wanna

00:15:20,990 --> 00:15:24,770
have a counter or something like that a

00:15:22,070 --> 00:15:26,930
temporary place to put things when you

00:15:24,770 --> 00:15:30,170
come in the door what happens if you

00:15:26,930 --> 00:15:30,960
don't Israel can you still achieve your

00:15:30,170 --> 00:15:32,760
goal of getting

00:15:30,960 --> 00:15:34,260
groceries eventually where they're

00:15:32,760 --> 00:15:35,670
supposed to go yeah but it's a whole lot

00:15:34,260 --> 00:15:39,540
harder you'll drop everything you'll

00:15:35,670 --> 00:15:42,740
step on your eggs whatever and so little

00:15:39,540 --> 00:15:45,029
tiny conveniences like that are

00:15:42,740 --> 00:15:46,380
important and they're not important just

00:15:45,029 --> 00:15:47,850
in and of themselves it's nice to have

00:15:46,380 --> 00:15:49,709
that waste of high shelf but there are

00:15:47,850 --> 00:15:51,360
other patterns as well one of my other

00:15:49,709 --> 00:15:53,640
favorite patterns is the Zen view

00:15:51,360 --> 00:15:54,750
pattern when you enter a room from a

00:15:53,640 --> 00:15:56,520
certain position in the room there

00:15:54,750 --> 00:15:58,589
should be a view on something that

00:15:56,520 --> 00:16:00,510
stills your mind and makes you calm and

00:15:58,589 --> 00:16:03,270
so so you come in who look out the

00:16:00,510 --> 00:16:06,480
window and there is a tree that you like

00:16:03,270 --> 00:16:07,800
or your neighbor's window or something

00:16:06,480 --> 00:16:11,730
you know whatever whatever you would

00:16:07,800 --> 00:16:12,839
even see and and together they actually

00:16:11,730 --> 00:16:14,130
leverage off of each other these

00:16:12,839 --> 00:16:16,410
patterns anybody who's used design

00:16:14,130 --> 00:16:19,050
patterns in design know that patterns

00:16:16,410 --> 00:16:21,690
leveraged off of each other and to a

00:16:19,050 --> 00:16:26,100
very great extent and it's amazing it's

00:16:21,690 --> 00:16:28,260
remarkable how much a small amount of

00:16:26,100 --> 00:16:30,660
code that's designed with with nested

00:16:28,260 --> 00:16:32,810
patterns can accomplish

00:16:30,660 --> 00:16:35,190
it's almost speaking theoretically I

00:16:32,810 --> 00:16:36,779
hope I'm allowed to do that it's almost

00:16:35,190 --> 00:16:38,850
as if a lot of the complexities removed

00:16:36,779 --> 00:16:40,440
from the code to the ether of the design

00:16:38,850 --> 00:16:42,779
space so you have less code to write

00:16:40,440 --> 00:16:44,790
well anyway the same same thing happens

00:16:42,779 --> 00:16:46,500
here waist high shelf combines with Zen

00:16:44,790 --> 00:16:49,410
view to give you a much better

00:16:46,500 --> 00:16:51,180
experience and you probably makes you

00:16:49,410 --> 00:16:52,920
more efficient and relaxed whatever for

00:16:51,180 --> 00:16:54,930
the rest of the day and the same thing

00:16:52,920 --> 00:16:59,670
for a lot of these things going from C++

00:16:54,930 --> 00:17:02,970
11 to C++ 14 C++ 14 was advertised as

00:16:59,670 --> 00:17:05,069
minor improvements there is nothing

00:17:02,970 --> 00:17:09,329
minor about return type deduction that

00:17:05,069 --> 00:17:12,329
makes your life so much easier just look

00:17:09,329 --> 00:17:15,179
at corresponding C++ 11 equals 14 code

00:17:12,329 --> 00:17:17,910
without return type deduction but then

00:17:15,179 --> 00:17:20,400
you throw in a C++ 17 thing it seems

00:17:17,910 --> 00:17:21,480
minor it doesn't give us anything we

00:17:20,400 --> 00:17:25,319
couldn't do before

00:17:21,480 --> 00:17:27,480
like const expert if I could have coded

00:17:25,319 --> 00:17:30,000
around that but when you combine

00:17:27,480 --> 00:17:32,190
return type deduction with Const expert

00:17:30,000 --> 00:17:34,500
if what did you get you got functions

00:17:32,190 --> 00:17:36,720
that can do calculations and decide what

00:17:34,500 --> 00:17:39,150
value they return to paste depending on

00:17:36,720 --> 00:17:41,610
their arguments it's great it gives you

00:17:39,150 --> 00:17:43,720
a ton of flexibility so these little

00:17:41,610 --> 00:17:46,030
things really helped const expert

00:17:43,720 --> 00:17:48,880
type traits especially those that

00:17:46,030 --> 00:17:54,270
require participation by the compiler

00:17:48,880 --> 00:17:56,500
and so on okay so just to our topic I

00:17:54,270 --> 00:18:00,450
will say that a lot of people pronounce

00:17:56,500 --> 00:18:03,070
this term Steen a it's pronounced SP na

00:18:00,450 --> 00:18:06,760
why because that's the way I pronounce

00:18:03,070 --> 00:18:08,440
it it's also it sounds more like Latin

00:18:06,760 --> 00:18:09,730
it sounds like you're educated if you

00:18:08,440 --> 00:18:12,160
say spin a it sounds like you're

00:18:09,730 --> 00:18:13,570
spitting or something anyway

00:18:12,160 --> 00:18:14,650
substitution failure is not an error

00:18:13,570 --> 00:18:16,510
really simple right

00:18:14,650 --> 00:18:18,790
we couldn't have overloaded function

00:18:16,510 --> 00:18:20,620
templates without it the compiler tries

00:18:18,790 --> 00:18:22,330
to do template argument deduction but if

00:18:20,620 --> 00:18:24,460
it fails as it will on the second F

00:18:22,330 --> 00:18:29,320
there that's okay as long as there is a

00:18:24,460 --> 00:18:31,210
successful substitution and so it's kind

00:18:29,320 --> 00:18:34,120
of a pre-processing of overload

00:18:31,210 --> 00:18:37,660
resolution in this case so that's nice

00:18:34,120 --> 00:18:39,430
what can we do with this well we'll see

00:18:37,660 --> 00:18:42,520
I just want to point out another big

00:18:39,430 --> 00:18:45,700
change seemingly minor is where you can

00:18:42,520 --> 00:18:48,850
apply the SPN a technique to basically

00:18:45,700 --> 00:18:50,530
take a function out of contention in C++

00:18:48,850 --> 00:18:52,570
so three the return type in the argument

00:18:50,530 --> 00:18:54,220
type so really all you had going by the

00:18:52,570 --> 00:18:55,840
time you got into the function by the

00:18:54,220 --> 00:18:58,180
time the function was chosen all you

00:18:55,840 --> 00:18:59,920
could do is constraint checking you

00:18:58,180 --> 00:19:02,140
couldn't say okay I'll take this out of

00:18:59,920 --> 00:19:08,560
contention so maybe some other function

00:19:02,140 --> 00:19:11,410
will match you couldn't have easily use

00:19:08,560 --> 00:19:16,030
it up here in the template parameter

00:19:11,410 --> 00:19:19,120
list but now it's from C++ 11 on we can

00:19:16,030 --> 00:19:21,610
we can have default template parameters

00:19:19,120 --> 00:19:23,260
so what's the big deal

00:19:21,610 --> 00:19:25,240
well has anybody ever looked at an

00:19:23,260 --> 00:19:27,640
application of SVA on a return type of a

00:19:25,240 --> 00:19:31,600
function and come away gladdened by the

00:19:27,640 --> 00:19:34,390
syntax no and syntax is important I mean

00:19:31,600 --> 00:19:35,860
semantics is essential but how do you

00:19:34,390 --> 00:19:40,330
get to the semantics you have to pass

00:19:35,860 --> 00:19:42,190
through the syntax and template

00:19:40,330 --> 00:19:44,800
programming the C++ has always been

00:19:42,190 --> 00:19:45,820
simple but the cement of this syntax has

00:19:44,800 --> 00:19:48,430
always been horrendous

00:19:45,820 --> 00:19:52,930
so simplifying that syntax is

00:19:48,430 --> 00:19:54,520
extraordinarily important who who are

00:19:52,930 --> 00:19:56,530
you writing your code for not for the

00:19:54,520 --> 00:19:58,480
machine right not for the compiler you

00:19:56,530 --> 00:20:00,550
writing it for your colleagues and as

00:19:58,480 --> 00:20:02,560
you know you are smarter than all of

00:20:00,550 --> 00:20:04,330
your colleagues so you can't expect them

00:20:02,560 --> 00:20:11,200
to be able to read your code without

00:20:04,330 --> 00:20:18,670
help all right so syntax is a major

00:20:11,200 --> 00:20:21,460
problem so this is an example of the use

00:20:18,670 --> 00:20:23,740
of SV na that's probably unsurprising at

00:20:21,460 --> 00:20:25,840
least at this point here I want to munge

00:20:23,740 --> 00:20:27,790
a shape and for reasons unknown I've

00:20:25,840 --> 00:20:30,310
decided not to use a virtual function

00:20:27,790 --> 00:20:33,520
and simply pass a shape based class I

00:20:30,310 --> 00:20:35,950
want to have a compile-time polymorphism

00:20:33,520 --> 00:20:37,620
with shapes I don't know what caused me

00:20:35,950 --> 00:20:39,880
to do this

00:20:37,620 --> 00:20:42,340
bad childhood or something I don't know

00:20:39,880 --> 00:20:44,320
but the thing is I want to make sure

00:20:42,340 --> 00:20:47,080
that T is indeed a shape when I call

00:20:44,320 --> 00:20:49,300
this function so how do I do that well I

00:20:47,080 --> 00:20:51,040
could call the function and then once

00:20:49,300 --> 00:20:52,810
I'm inside the function say hey it's T

00:20:51,040 --> 00:20:54,550
is shape and if not I'll get a compile

00:20:52,810 --> 00:20:57,700
time error I can do a static assertion

00:20:54,550 --> 00:20:59,710
or I can just say well maybe there's

00:20:57,700 --> 00:21:02,230
some other munch ape that will be happy

00:20:59,710 --> 00:21:04,090
so that I could match so I'm gonna have

00:21:02,230 --> 00:21:06,940
a constraint here I'm gonna use the

00:21:04,090 --> 00:21:08,320
enable if to actually ask if this T is a

00:21:06,940 --> 00:21:10,810
shape or something derived from the

00:21:08,320 --> 00:21:12,370
shape if I'm unable to deduce the type

00:21:10,810 --> 00:21:14,080
here then this will be taken out of

00:21:12,370 --> 00:21:16,600
contention and perhaps some other

00:21:14,080 --> 00:21:18,840
function will be matched so this is a

00:21:16,600 --> 00:21:21,160
terrific technique and it gives you the

00:21:18,840 --> 00:21:23,680
apparent ability to overload on

00:21:21,160 --> 00:21:25,540
arbitrary properties of types you can

00:21:23,680 --> 00:21:27,910
effectively overload on how big types

00:21:25,540 --> 00:21:31,270
are whether types have certain nested

00:21:27,910 --> 00:21:33,850
type names whether types have no throw

00:21:31,270 --> 00:21:37,270
copy operations and so on or any

00:21:33,850 --> 00:21:39,100
combination of that I said

00:21:37,270 --> 00:21:42,160
extraordinarily flexible basically

00:21:39,100 --> 00:21:46,540
anything you can say about a type you

00:21:42,160 --> 00:21:50,080
can turn into a constraint on a function

00:21:46,540 --> 00:21:51,520
a no and also on a class template and

00:21:50,080 --> 00:21:53,890
also on a class template specialization

00:21:51,520 --> 00:21:57,460
you can use this technique in a variety

00:21:53,890 --> 00:21:59,770
of different places so the only problem

00:21:57,460 --> 00:22:01,300
is if you only want this function to

00:21:59,770 --> 00:22:03,520
match for shapes that are bigger than

00:22:01,300 --> 00:22:09,290
six bytes and have a nested type name

00:22:03,520 --> 00:22:11,200
called oops and smell nice or whatever

00:22:09,290 --> 00:22:12,860
the syntax is going to be terrible right

00:22:11,200 --> 00:22:14,810
nobody's gonna understand what you're

00:22:12,860 --> 00:22:16,250
doing so usually what we're gonna do is

00:22:14,810 --> 00:22:18,610
use another one of these waist-high

00:22:16,250 --> 00:22:22,280
shelves that has been provided for us

00:22:18,610 --> 00:22:25,280
this template type def and we're gonna

00:22:22,280 --> 00:22:27,020
have a using and we'll define is shape

00:22:25,280 --> 00:22:28,940
to be that whole mess we just saw before

00:22:27,020 --> 00:22:32,270
now we never have to write this again

00:22:28,940 --> 00:22:37,790
now we can write code that even a Java

00:22:32,270 --> 00:22:40,220
programmer would understand I apologize

00:22:37,790 --> 00:22:43,520
the Java programmer comment I had a very

00:22:40,220 --> 00:22:46,310
bad incident in the mid-90s I don't want

00:22:43,520 --> 00:22:48,350
to talk about it emotionally children

00:22:46,310 --> 00:22:53,450
did not get Christmas presents one year

00:22:48,350 --> 00:22:56,930
because of Java it's true they are now

00:22:53,450 --> 00:22:59,740
populating our prisons not the children

00:22:56,930 --> 00:23:06,170
not the Java programmers

00:22:59,740 --> 00:23:08,810
although here's another code smell I

00:23:06,170 --> 00:23:11,300
love the term code smell it's actually a

00:23:08,810 --> 00:23:13,250
technical term so here we have a range

00:23:11,300 --> 00:23:17,000
initialization we have a heap type some

00:23:13,250 --> 00:23:18,740
sort of STL like container and we have a

00:23:17,000 --> 00:23:21,020
range initialization so when we

00:23:18,740 --> 00:23:23,690
initialize a heap with a a half open

00:23:21,020 --> 00:23:26,990
interval defined by two iterators we

00:23:23,690 --> 00:23:28,700
want to use this range in it but we also

00:23:26,990 --> 00:23:30,650
have another two argument constructor

00:23:28,700 --> 00:23:33,320
here but they don't look anything alike

00:23:30,650 --> 00:23:41,480
do they shouldn't cause a problem

00:23:33,320 --> 00:23:42,770
oh you've you've had a bad life too so

00:23:41,480 --> 00:23:44,690
here's what we ever we have a heap of

00:23:42,770 --> 00:23:46,700
integers and we want it for reasons

00:23:44,690 --> 00:23:50,300
unknown want to initialize that heap of

00:23:46,700 --> 00:23:53,480
integers with five zeros which

00:23:50,300 --> 00:23:57,530
constructor gets called not the one you

00:23:53,480 --> 00:24:01,010
meant because these are two integers

00:23:57,530 --> 00:24:02,450
they have the same type this constructor

00:24:01,010 --> 00:24:04,610
had takes two things into different

00:24:02,450 --> 00:24:09,080
types it takes a size T and basically an

00:24:04,610 --> 00:24:09,950
int but so this is a better match so I'm

00:24:09,080 --> 00:24:12,710
going to try to do arrange

00:24:09,950 --> 00:24:14,480
initialization with integers fortunately

00:24:12,710 --> 00:24:18,230
it won't compile but you can contrive

00:24:14,480 --> 00:24:19,760
situations where this does compile ouch

00:24:18,230 --> 00:24:21,350
especially this is the kind of thing

00:24:19,760 --> 00:24:22,559
that actually happens with initializer

00:24:21,350 --> 00:24:24,419
lists if you add

00:24:22,559 --> 00:24:27,749
them after the fact then all of sudden

00:24:24,419 --> 00:24:30,960
constructors behave differently it's a

00:24:27,749 --> 00:24:33,299
very I am predicting death and

00:24:30,960 --> 00:24:36,210
destruction from that unless you use SP

00:24:33,299 --> 00:24:39,269
na so the thing is your intention was

00:24:36,210 --> 00:24:44,269
that that constructor be called only for

00:24:39,269 --> 00:24:44,269
iterators specifically input iterators

00:24:45,470 --> 00:24:52,019
so what do we do well of course we this

00:24:49,110 --> 00:24:54,929
is a solve problem we just used the C++

00:24:52,019 --> 00:24:57,149
98 iterator traits specialize it with

00:24:54,929 --> 00:24:58,860
iterator get the category remind the

00:24:57,149 --> 00:25:00,210
compiler that it's a type name and see

00:24:58,860 --> 00:25:02,460
if it's the same as the random access

00:25:00,210 --> 00:25:04,740
iterator tag now I used random access

00:25:02,460 --> 00:25:06,960
iterator tag here because the actual

00:25:04,740 --> 00:25:10,830
question they want to know is is it an

00:25:06,960 --> 00:25:15,289
input iterator well when is something an

00:25:10,830 --> 00:25:18,119
input iterator what tag does it have

00:25:15,289 --> 00:25:20,610
input iterator bi-directional iterator

00:25:18,119 --> 00:25:23,909
or random access iterator so the actual

00:25:20,610 --> 00:25:25,110
constraint is a little bit wordy it's

00:25:23,909 --> 00:25:27,179
not something you'd like to stick in the

00:25:25,110 --> 00:25:29,429
middle of a class because it would be

00:25:27,179 --> 00:25:31,769
longer than the rest of the class so of

00:25:29,429 --> 00:25:33,389
course we want to simplify the syntax so

00:25:31,769 --> 00:25:36,029
the first thing everybody should do as

00:25:33,389 --> 00:25:39,299
soon as you get a C++ 11 compiler and

00:25:36,029 --> 00:25:45,350
there are people who don't have them we

00:25:39,299 --> 00:25:48,059
should have a drive or something too so

00:25:45,350 --> 00:25:49,649
we can define category as a

00:25:48,059 --> 00:25:52,169
simplification of getting the iterator

00:25:49,649 --> 00:25:54,240
category and then we can define things

00:25:52,169 --> 00:25:56,279
like is exactly random access is the

00:25:54,240 --> 00:25:58,919
category random access iterator tag and

00:25:56,279 --> 00:26:00,389
continue in this fashion until we have

00:25:58,919 --> 00:26:02,490
something like is it an input iterator

00:26:00,389 --> 00:26:06,149
well it is if it's exactly an input

00:26:02,490 --> 00:26:11,159
iterator or is a forward iterator so

00:26:06,149 --> 00:26:13,860
this is the constraint we want and this

00:26:11,159 --> 00:26:17,279
is this is true things just something I

00:26:13,860 --> 00:26:18,840
wrote because I got tired of writing the

00:26:17,279 --> 00:26:23,070
same thing over and over again it's not

00:26:18,840 --> 00:26:24,720
standard and a final syntactic cleanup

00:26:23,070 --> 00:26:27,690
we're going to use an able if but we're

00:26:24,720 --> 00:26:28,919
going to simplify it this is now no

00:26:27,690 --> 00:26:30,960
longer as simple true or false

00:26:28,919 --> 00:26:32,909
constraint this is a an exists or

00:26:30,960 --> 00:26:34,370
doesn't exist constraint which is what

00:26:32,909 --> 00:26:36,740
we want for an SVN a check

00:26:34,370 --> 00:26:39,110
so with that in place week again right

00:26:36,740 --> 00:26:41,929
code that says precisely what we need is

00:26:39,110 --> 00:26:44,809
this what I meant I meant only call this

00:26:41,929 --> 00:26:47,059
constructor if n is this an STL

00:26:44,809 --> 00:26:50,029
compliant input iterator and that was

00:26:47,059 --> 00:26:51,919
the what I wanted to convey and now

00:26:50,029 --> 00:26:55,789
that's what my interface is saying as

00:26:51,919 --> 00:26:57,890
well let's just do one more example and

00:26:55,789 --> 00:27:01,789
here's something if scott Meyers were

00:26:57,890 --> 00:27:03,860
here he would just fulminate looking at

00:27:01,789 --> 00:27:07,210
this code he says like 26 times in his

00:27:03,860 --> 00:27:09,799
new book which is it's a good book I

00:27:07,210 --> 00:27:13,039
can't believe I said that in public but

00:27:09,799 --> 00:27:15,260
it's good it's an excellent book that

00:27:13,039 --> 00:27:20,929
was not a slight against Scott it's a

00:27:15,260 --> 00:27:22,580
slight against my book sales he writes

00:27:20,929 --> 00:27:28,940
books that's yes the problem nobody

00:27:22,580 --> 00:27:32,029
knows my wife bought a coffee we're

00:27:28,940 --> 00:27:34,130
overloading with a forwarding reference

00:27:32,029 --> 00:27:36,409
I like to you I like the turn Universal

00:27:34,130 --> 00:27:39,010
reference which is Scott's term because

00:27:36,409 --> 00:27:43,779
in this case that's the problem this

00:27:39,010 --> 00:27:47,570
reference can accept anything at all so

00:27:43,779 --> 00:27:48,740
my intent what what were we thinking why

00:27:47,570 --> 00:27:50,210
didn't we listen to Scott

00:27:48,740 --> 00:27:52,010
well you shouldn't listen to Scott

00:27:50,210 --> 00:27:53,500
completely you should listen to Scott

00:27:52,010 --> 00:27:55,820
for danger points and then maybe

00:27:53,500 --> 00:28:01,100
circumvent his advice some way or

00:27:55,820 --> 00:28:03,200
another so here our intent was well I

00:28:01,100 --> 00:28:05,809
have an X that's been specialized with T

00:28:03,200 --> 00:28:08,570
so this is not a universal reference

00:28:05,809 --> 00:28:11,240
this is just an R value T and here's an

00:28:08,570 --> 00:28:13,850
L value T and what we probably meant was

00:28:11,240 --> 00:28:17,149
well if it's not a t then we'd like to

00:28:13,850 --> 00:28:20,080
handle that operation this way make

00:28:17,149 --> 00:28:22,549
sense that's probably what we intended

00:28:20,080 --> 00:28:25,580
but not everybody has a copy of Scott's

00:28:22,549 --> 00:28:27,440
book if they did they would simply say

00:28:25,580 --> 00:28:29,600
okay willing to call this operation

00:28:27,440 --> 00:28:33,710
- instead of operation we use a

00:28:29,600 --> 00:28:36,230
different name but the trouble is I'm

00:28:33,710 --> 00:28:37,909
sorry if this kid I'm gonna ask you to

00:28:36,230 --> 00:28:41,679
believe me that this is gonna cause all

00:28:37,909 --> 00:28:44,779
kinda say believe me in public like that

00:28:41,679 --> 00:28:47,399
it won't happen again

00:28:44,779 --> 00:28:52,909
if I mentioned that my wife is a

00:28:47,399 --> 00:28:59,539
politician it's okay

00:28:52,909 --> 00:28:59,539
believe me okay

00:29:01,070 --> 00:29:09,899
yeah the trouble is this greedy

00:29:05,509 --> 00:29:11,340
operation will sometimes cease arguments

00:29:09,899 --> 00:29:13,979
that were intended for this in

00:29:11,340 --> 00:29:17,489
particular if I were to pass an l-value

00:29:13,979 --> 00:29:20,460
tea that is not constant which function

00:29:17,489 --> 00:29:24,330
is it going to match it's gonna match

00:29:20,460 --> 00:29:27,359
the universal reference very surprising

00:29:24,330 --> 00:29:31,499
you don't want to surprise programmers

00:29:27,359 --> 00:29:33,479
they're not happy with surprises okay so

00:29:31,499 --> 00:29:35,190
what were we thinking well what we're

00:29:33,479 --> 00:29:38,609
thinking is what we only meant to call

00:29:35,190 --> 00:29:40,499
that if the S is not similar to T well

00:29:38,609 --> 00:29:42,149
let's define similar similar is the same

00:29:40,499 --> 00:29:44,340
if you decay two types and if at the

00:29:42,149 --> 00:29:46,019
same time so decay is a wonderful thing

00:29:44,340 --> 00:29:48,119
from type traits it's basically says

00:29:46,019 --> 00:29:48,749
what is the essential nature of this

00:29:48,119 --> 00:29:51,149
type

00:29:48,749 --> 00:29:53,599
it sounds very deep but basically it

00:29:51,149 --> 00:29:56,210
strips off references and unnecessary

00:29:53,599 --> 00:29:58,679
qualifiers like constant volatile and

00:29:56,210 --> 00:30:00,210
turns arrays and two pointers and

00:29:58,679 --> 00:30:03,389
functions two pointers and then

00:30:00,210 --> 00:30:05,070
basically strips the object down to its

00:30:03,389 --> 00:30:07,409
essentials what you get if you were to

00:30:05,070 --> 00:30:12,359
pass it by value and then we'll define

00:30:07,409 --> 00:30:14,369
not similar if to be if s and T these

00:30:12,359 --> 00:30:15,659
two arguments are not similar in other

00:30:14,369 --> 00:30:17,729
words when I decay them if you're a

00:30:15,659 --> 00:30:19,739
different type and with that in place I

00:30:17,729 --> 00:30:22,259
can actually state my intent I only want

00:30:19,739 --> 00:30:25,769
to call this function if s is not

00:30:22,259 --> 00:30:28,619
similar to T and I've stated my intent

00:30:25,769 --> 00:30:30,570
clearly and now I have a do what I mean

00:30:28,619 --> 00:30:32,460
interface now this is not necessarily

00:30:30,570 --> 00:30:34,229
the ideal solution the ideal solution is

00:30:32,460 --> 00:30:36,330
to call this operation something else

00:30:34,229 --> 00:30:37,950
but there are cases where you have this

00:30:36,330 --> 00:30:41,279
kind of overloading that you'd really

00:30:37,950 --> 00:30:42,950
like to work as always syntax is a

00:30:41,279 --> 00:30:46,019
problem

00:30:42,950 --> 00:30:48,239
what about self-identification here's

00:30:46,019 --> 00:30:51,450
one thing that I really like about the

00:30:48,239 --> 00:30:53,970
new STL transparent function objects

00:30:51,450 --> 00:30:55,769
isn't that a great name I have no idea

00:30:53,970 --> 00:30:57,380
where that comes from there are certain

00:30:55,769 --> 00:31:00,330
things in the standard you just wonder

00:30:57,380 --> 00:31:02,730
what they were thinking I mean logically

00:31:00,330 --> 00:31:05,760
sound stuff but they call function

00:31:02,730 --> 00:31:09,140
objects transparent and since 1998

00:31:05,760 --> 00:31:12,330
standard there's been a section 3.2

00:31:09,140 --> 00:31:14,550
correct where there are two just random

00:31:12,330 --> 00:31:19,800
character strings one is studebaker the

00:31:14,550 --> 00:31:21,990
other is vivisectionist I've never had a

00:31:19,800 --> 00:31:25,710
satisfying explanation as to why those

00:31:21,990 --> 00:31:30,570
two identifiers were chosen and it's

00:31:25,710 --> 00:31:34,230
probably not pretty maybe a summer job

00:31:30,570 --> 00:31:35,850
somebody has so the point is that some

00:31:34,230 --> 00:31:39,300
function objects can identify themselves

00:31:35,850 --> 00:31:41,820
as transparent meaning that they can

00:31:39,300 --> 00:31:43,650
pretty much compare or be operated on

00:31:41,820 --> 00:31:46,350
anything so here's a less that can

00:31:43,650 --> 00:31:48,300
compare anything to anything provided as

00:31:46,350 --> 00:31:50,010
an appropriate less than operation and

00:31:48,300 --> 00:31:51,210
this turns out to be really handy we

00:31:50,010 --> 00:31:55,680
don't have time to go over the all the

00:31:51,210 --> 00:31:57,390
details but it basically makes all those

00:31:55,680 --> 00:32:00,180
tricky things you've been doing the

00:31:57,390 --> 00:32:02,100
vector four over the years apply to

00:32:00,180 --> 00:32:05,190
things like sets and maps and other

00:32:02,100 --> 00:32:08,060
containers you want to be clever with

00:32:05,190 --> 00:32:10,410
but the point is this function object is

00:32:08,060 --> 00:32:12,570
advertising that it is has that

00:32:10,410 --> 00:32:15,450
capability this is an advertisement

00:32:12,570 --> 00:32:17,220
I am a transparent function object why

00:32:15,450 --> 00:32:19,500
transfer I would call it is flexible or

00:32:17,220 --> 00:32:22,020
something but it's transparent and the

00:32:19,500 --> 00:32:25,140
nice thing is that set now will alter

00:32:22,020 --> 00:32:27,390
its interface based on the properties of

00:32:25,140 --> 00:32:29,820
the comparator that you give it if that

00:32:27,390 --> 00:32:33,690
comparator is transparent you get a

00:32:29,820 --> 00:32:37,710
whole new lower bound function that lets

00:32:33,690 --> 00:32:40,950
you do a lower bound binary search not

00:32:37,710 --> 00:32:42,960
with the key type but maybe something

00:32:40,950 --> 00:32:44,730
that's like a key maybe if you have if

00:32:42,960 --> 00:32:46,710
the key type of your set is a structure

00:32:44,730 --> 00:32:48,290
that contains 500 data members but

00:32:46,710 --> 00:32:51,390
you're only sorting it on the first one

00:32:48,290 --> 00:32:52,860
you can do a lower bound with that first

00:32:51,390 --> 00:32:55,860
the data member provide it you can

00:32:52,860 --> 00:32:58,020
compare that to the entire set so

00:32:55,860 --> 00:32:59,940
basically here we have a cooperation

00:32:58,020 --> 00:33:01,530
between two types we have a function

00:32:59,940 --> 00:33:04,140
objects is volunteering that is

00:33:01,530 --> 00:33:06,170
transparent we have an interface that is

00:33:04,140 --> 00:33:08,460
willing to talk with such an object in

00:33:06,170 --> 00:33:10,620
augmentis interface depending on whether

00:33:08,460 --> 00:33:11,250
that object is present or not I think

00:33:10,620 --> 00:33:15,030
that's

00:33:11,250 --> 00:33:17,030
wonderful these are I call them

00:33:15,030 --> 00:33:19,560
distributed organic interfaces and

00:33:17,030 --> 00:33:23,340
thankfully that acronym doesn't spell

00:33:19,560 --> 00:33:25,260
anything unpleasant so again now we have

00:33:23,340 --> 00:33:26,790
these interfaces in this ecosystem and

00:33:25,260 --> 00:33:28,920
they're talking to each other

00:33:26,790 --> 00:33:31,170
transparent function jobs are talking to

00:33:28,920 --> 00:33:32,700
containers containers are asking

00:33:31,170 --> 00:33:37,440
questions of their function objects and

00:33:32,700 --> 00:33:42,600
doing what you mean if they were able to

00:33:37,440 --> 00:33:44,610
to cooperate here's another example I do

00:33:42,600 --> 00:33:49,380
a lot of work at dance acts he you may

00:33:44,610 --> 00:33:50,550
know C++ expert and he he obsesses about

00:33:49,380 --> 00:33:52,680
a new malotte

00:33:50,550 --> 00:33:54,150
I wouldn't say obsessed but he he does a

00:33:52,680 --> 00:33:55,530
lot of hardware level programming and

00:33:54,150 --> 00:33:58,260
they're always the news all over the

00:33:55,530 --> 00:33:59,850
place misbehaving and he wants to tame

00:33:58,260 --> 00:34:02,430
them and so he came up with the idea of

00:33:59,850 --> 00:34:04,230
an a new him container that behaves like

00:34:02,430 --> 00:34:06,060
an STL container and you can do things

00:34:04,230 --> 00:34:08,669
like iterate through it and so on it

00:34:06,060 --> 00:34:11,580
compile time iterations and all kinds of

00:34:08,669 --> 00:34:14,520
clever things that hardware people like

00:34:11,580 --> 00:34:17,129
to do and how does it work well

00:34:14,520 --> 00:34:18,540
obviously not every scoped Noom is going

00:34:17,129 --> 00:34:21,540
to be in the new container so it's

00:34:18,540 --> 00:34:23,639
self-identifies and we can that we can

00:34:21,540 --> 00:34:26,610
ask a given container you know are you

00:34:23,639 --> 00:34:29,070
in a new container and then we have a

00:34:26,610 --> 00:34:31,740
lot of ways of dealing with that so a

00:34:29,070 --> 00:34:34,290
given a gnome can simply by stating I am

00:34:31,740 --> 00:34:38,190
in the new container leverage all of

00:34:34,290 --> 00:34:43,320
this other capability okay so types are

00:34:38,190 --> 00:34:45,300
talking to each other but of course one

00:34:43,320 --> 00:34:47,159
of the things we do is you know our

00:34:45,300 --> 00:34:50,669
lives are complex so our code is complex

00:34:47,159 --> 00:34:52,710
is we end up composing questions about

00:34:50,669 --> 00:34:54,480
our types we don't want to know if just

00:34:52,710 --> 00:35:00,480
as something is transparent we won't

00:34:54,480 --> 00:35:02,299
know if it's transparent and very

00:35:00,480 --> 00:35:03,920
transparent

00:35:02,299 --> 00:35:06,410
in other words we want to compose things

00:35:03,920 --> 00:35:08,630
together so here we have a predicate

00:35:06,410 --> 00:35:12,650
don't you love very attic templates

00:35:08,630 --> 00:35:14,509
admit it you guys you're among friends

00:35:12,650 --> 00:35:18,739
you can talk about it now

00:35:14,509 --> 00:35:22,430
so here the predicate is well the this

00:35:18,739 --> 00:35:24,319
template parameter is a parameter pack

00:35:22,430 --> 00:35:26,390
of templates that can take one or more

00:35:24,319 --> 00:35:28,099
sorry zero or more type name arguments I

00:35:26,390 --> 00:35:31,039
should have had type name comma type

00:35:28,099 --> 00:35:35,059
name dot but that wouldn't fit and we

00:35:31,039 --> 00:35:39,410
want to compose them together so this is

00:35:35,059 --> 00:35:41,210
easy to do so I want to do things like

00:35:39,410 --> 00:35:43,400
this I want to compose is class as

00:35:41,210 --> 00:35:45,170
transparent is big I just made that one

00:35:43,400 --> 00:35:47,869
up and that's the meaning of happiness

00:35:45,170 --> 00:35:49,940
actually for a type and then I can

00:35:47,869 --> 00:35:53,569
insert that a given type is happy and if

00:35:49,940 --> 00:35:57,769
it's not you know we can we can have a

00:35:53,569 --> 00:36:01,700
compile-time here and so on we can also

00:35:57,769 --> 00:36:04,039
generate a similar enable if an SDN a

00:36:01,700 --> 00:36:09,259
requirement and only call functions with

00:36:04,039 --> 00:36:12,980
happy types okay most of these slides

00:36:09,259 --> 00:36:15,289
are written after midnight how do we

00:36:12,980 --> 00:36:19,900
implement this in the interest of time I

00:36:15,289 --> 00:36:22,999
won't I won't go into great detail but

00:36:19,900 --> 00:36:25,279
we can use their first rest this is how

00:36:22,999 --> 00:36:27,680
we've been doing recursive template

00:36:25,279 --> 00:36:29,690
specialization basically we process the

00:36:27,680 --> 00:36:31,220
first element and recursively process

00:36:29,690 --> 00:36:33,380
the rest of the elements until we run

00:36:31,220 --> 00:36:36,440
out of elements so that's nice a nice

00:36:33,380 --> 00:36:38,299
recursive way of handling things that's

00:36:36,440 --> 00:36:40,670
way we dealt with type lists but now we

00:36:38,299 --> 00:36:44,380
can do things like have a Const expert

00:36:40,670 --> 00:36:47,690
function to do this evaluation for us or

00:36:44,380 --> 00:36:50,619
this is my favorite one you can use

00:36:47,690 --> 00:36:52,609
variable templates with fold expressions

00:36:50,619 --> 00:36:56,599
this is the hot off the presses

00:36:52,609 --> 00:36:58,940
technique C++ 17 now variable templates

00:36:56,599 --> 00:37:01,309
to see flows 14 fold expressions our

00:36:58,940 --> 00:37:03,319
sequence was 17 but look how little code

00:37:01,309 --> 00:37:05,089
I have to write these days if this is

00:37:03,319 --> 00:37:08,450
not a waist high self I don't know it is

00:37:05,089 --> 00:37:10,099
this is you're coming home and falling

00:37:08,450 --> 00:37:11,539
in the bags break and everything falls

00:37:10,099 --> 00:37:15,080
in the floor but you still get things

00:37:11,539 --> 00:37:17,690
done this is you have one shelf

00:37:15,080 --> 00:37:19,490
big enough for one bag this is a waste

00:37:17,690 --> 00:37:21,710
high shelf this is gonna make your life

00:37:19,490 --> 00:37:23,900
easier and not only that but it's very

00:37:21,710 --> 00:37:26,830
easy to work with these variable

00:37:23,900 --> 00:37:29,150
templates so I can create another

00:37:26,830 --> 00:37:32,930
variable template that's a composition

00:37:29,150 --> 00:37:36,320
and I say satisfies my needs consists of

00:37:32,930 --> 00:37:38,930
well if T is signed and is a pod but is

00:37:36,320 --> 00:37:40,700
not polymorphic and is not an array than

00:37:38,930 --> 00:37:42,950
that satisfied for my needs that's very

00:37:40,700 --> 00:37:50,510
easy to compose and now I can write

00:37:42,950 --> 00:37:53,240
something that actually makes sense but

00:37:50,510 --> 00:37:54,730
that's not good enough never satisfied

00:37:53,240 --> 00:37:58,990
right I want to be able to write

00:37:54,730 --> 00:38:03,620
arbitrarily complex predicates that

00:37:58,990 --> 00:38:09,140
anyone can read all right any C++

00:38:03,620 --> 00:38:12,080
programmer can read so we're gonna you

00:38:09,140 --> 00:38:13,250
know I I was quite smitten by type lists

00:38:12,080 --> 00:38:14,930
I don't know about you but when I saw

00:38:13,250 --> 00:38:16,670
typeless I thought they're very clever

00:38:14,930 --> 00:38:18,410
and lots of fun and I spent a lot of

00:38:16,670 --> 00:38:23,030
time doing that instead of making living

00:38:18,410 --> 00:38:25,880
so on what I'd like to do instead is to

00:38:23,030 --> 00:38:27,590
have trees but I don't want to have

00:38:25,880 --> 00:38:29,870
trees of types I don't have trees of

00:38:27,590 --> 00:38:34,130
templates so I want to create template

00:38:29,870 --> 00:38:38,620
trees and it turns out with modern C++

00:38:34,130 --> 00:38:42,020
this is trivially easy to do so the idea

00:38:38,620 --> 00:38:47,000
is I want to create template trees that

00:38:42,020 --> 00:38:48,110
represent a complex constraint so I want

00:38:47,000 --> 00:38:50,420
to be able to write something as simple

00:38:48,110 --> 00:38:54,490
as this at Fred 1 Fred two and fred 3

00:38:50,420 --> 00:38:57,110
our templates that are used as

00:38:54,490 --> 00:38:58,580
predicates / types I want to be able to

00:38:57,110 --> 00:39:02,330
combine them together in a very

00:38:58,580 --> 00:39:04,760
reasonable simple way I want to create

00:39:02,330 --> 00:39:07,720
an abstract syntax tree and evaluate it

00:39:04,760 --> 00:39:10,250
but this has to happen at compile time

00:39:07,720 --> 00:39:17,030
has to be free if it's not free I'm not

00:39:10,250 --> 00:39:19,480
interested so let's just do this quickly

00:39:17,030 --> 00:39:24,410
the codes available on my website with a

00:39:19,480 --> 00:39:26,410
accompanying verbiage I'm gonna have a

00:39:24,410 --> 00:39:29,470
base plot sorry

00:39:26,410 --> 00:39:31,630
this is a touch this is a tight

00:39:29,470 --> 00:39:37,569
predicate this is the base class for

00:39:31,630 --> 00:39:39,119
every ast node and we're going to do

00:39:37,569 --> 00:39:42,460
something like this here's my and

00:39:39,119 --> 00:39:44,470
structure this is a literal type because

00:39:42,460 --> 00:39:48,359
notice the context for a constructor and

00:39:44,470 --> 00:39:52,390
the context Berryville all the all the

00:39:48,359 --> 00:39:56,020
compiler written members or context per

00:39:52,390 --> 00:39:58,780
and trivial and what this does is it

00:39:56,020 --> 00:40:01,839
simply remembers the types of p1 and p2

00:39:58,780 --> 00:40:04,869
and then when you call eval you get a

00:40:01,839 --> 00:40:09,099
compile time result that tells you

00:40:04,869 --> 00:40:15,910
whether p1 is true and p2 is true you

00:40:09,099 --> 00:40:19,049
can do the same thing for or and of

00:40:15,910 --> 00:40:21,700
course we don't want to actually write

00:40:19,049 --> 00:40:23,230
function call style notation so we're

00:40:21,700 --> 00:40:26,410
going to overload operators I'm gonna

00:40:23,230 --> 00:40:28,299
overload the and operator people ask me

00:40:26,410 --> 00:40:30,690
why why didn't you say overload and and

00:40:28,299 --> 00:40:34,180
and or or is anybody thinking that I

00:40:30,690 --> 00:40:36,160
know you were because I like exclusive

00:40:34,180 --> 00:40:38,289
or it's my favorite operator and there

00:40:36,160 --> 00:40:40,119
is no exclusive or exclusive or operator

00:40:38,289 --> 00:40:43,960
so I decided to use the bitwise

00:40:40,119 --> 00:40:48,039
operators for this alright it it's says

00:40:43,960 --> 00:40:50,289
something about my personality ok so the

00:40:48,039 --> 00:40:54,700
idea is we are going to now have a

00:40:50,289 --> 00:40:59,740
compile time way to easily construct a

00:40:54,700 --> 00:41:01,180
tree of templates and then the nice

00:40:59,740 --> 00:41:03,130
thing about the context for functions

00:41:01,180 --> 00:41:05,079
that they're terrific for computing

00:41:03,130 --> 00:41:08,049
values that you can then use in runtime

00:41:05,079 --> 00:41:10,000
code but the nice thing is they're also

00:41:08,049 --> 00:41:13,119
good at computing types with no

00:41:10,000 --> 00:41:15,430
guaranteed artifacts littering your code

00:41:13,119 --> 00:41:17,470
and actually occupying space or whatever

00:41:15,430 --> 00:41:21,010
they're a purely compile time phenomenon

00:41:17,470 --> 00:41:23,109
if they're called properly and so I'm

00:41:21,010 --> 00:41:26,529
using these functions to compute types

00:41:23,109 --> 00:41:30,789
instead of values and very often or we

00:41:26,529 --> 00:41:33,099
think in the opposite way here's a our

00:41:30,789 --> 00:41:34,750
unary operator not which is fairly

00:41:33,099 --> 00:41:36,160
simple and straightforward alright so

00:41:34,750 --> 00:41:39,910
the point is we can create these syntax

00:41:36,160 --> 00:41:42,430
trees and we have an ID type

00:41:39,910 --> 00:41:44,289
well which is a predicate and we

00:41:42,430 --> 00:41:47,740
initialize it in this case it's a

00:41:44,289 --> 00:41:51,069
somewhat limited initialization it takes

00:41:47,740 --> 00:41:54,039
a single type name argument and I'm I'm

00:41:51,069 --> 00:41:55,450
omitting some examples it not all not

00:41:54,039 --> 00:41:57,010
all interesting predicates some types

00:41:55,450 --> 00:41:59,890
are unary they're interesting binary

00:41:57,010 --> 00:42:02,349
predicate as well in an area predicates

00:41:59,890 --> 00:42:04,059
and it's very easy to create binders

00:42:02,349 --> 00:42:07,180
where you can actually bind predicates

00:42:04,059 --> 00:42:09,450
to produce single arguments predicates

00:42:07,180 --> 00:42:15,640
from two argument predicates and so on

00:42:09,450 --> 00:42:17,140
okay and you can also take the effort if

00:42:15,640 --> 00:42:21,670
you want to translate the type trace

00:42:17,140 --> 00:42:23,410
library so you have available is pod for

00:42:21,670 --> 00:42:25,390
instance for a standard is pod and so on

00:42:23,410 --> 00:42:27,970
this makes it convenient with this in

00:42:25,390 --> 00:42:30,369
place we can do things like this I can

00:42:27,970 --> 00:42:33,880
define my needs it makes no sense

00:42:30,369 --> 00:42:37,089
whatsoever but my needs are I need my

00:42:33,880 --> 00:42:40,900
types to be classes and either pods or

00:42:37,089 --> 00:42:42,549
not polymorphic exclusive or is shaped I

00:42:40,900 --> 00:42:44,079
don't even know what that means but the

00:42:42,549 --> 00:42:45,670
point is I was able to write it easily

00:42:44,079 --> 00:42:46,869
and presumably it means something

00:42:45,670 --> 00:42:51,970
because those are my needs your needs

00:42:46,869 --> 00:42:53,410
are different your needs are worse so we

00:42:51,970 --> 00:42:59,589
each have needs and their heart to

00:42:53,410 --> 00:43:03,910
satisfy is this describing anybody

00:42:59,589 --> 00:43:05,109
else's relationships and we haven't eat

00:43:03,910 --> 00:43:07,539
we want to be able to evaluate them

00:43:05,109 --> 00:43:09,339
obviously I can evaluate my needs by

00:43:07,539 --> 00:43:11,920
calling the eval function with some type

00:43:09,339 --> 00:43:15,190
this will produce a compile time result

00:43:11,920 --> 00:43:17,020
for me which is nice but a little

00:43:15,190 --> 00:43:19,299
syntactic sugar is a good idea so I'm

00:43:17,020 --> 00:43:22,359
going to provide a constraint function

00:43:19,299 --> 00:43:25,480
that produces a compile time result and

00:43:22,359 --> 00:43:27,910
I'll have an SVA constraint as well so

00:43:25,480 --> 00:43:30,339
this guarantees a true or a false result

00:43:27,910 --> 00:43:32,890
very good for static assertions this one

00:43:30,339 --> 00:43:36,880
will give me a void or not which is

00:43:32,890 --> 00:43:39,130
great for SVA the most common

00:43:36,880 --> 00:43:41,559
manifestation of Sdn a and with that in

00:43:39,130 --> 00:43:45,279
place I can actually specify my needs I

00:43:41,559 --> 00:43:47,500
can see if T is constrained to my needs

00:43:45,279 --> 00:43:49,390
and if not I can complain and I can do a

00:43:47,500 --> 00:43:51,940
complex

00:43:49,390 --> 00:43:54,390
SBN a exclusion of a function that

00:43:51,940 --> 00:43:56,470
doesn't meet both of our needs

00:43:54,390 --> 00:43:59,170
however those knees are defined so

00:43:56,470 --> 00:44:01,740
armored this is arbitrary complexity and

00:43:59,170 --> 00:44:04,660
it's fairly straightforward

00:44:01,740 --> 00:44:06,789
again this is not giving us any

00:44:04,660 --> 00:44:10,210
additional capability but it's making it

00:44:06,789 --> 00:44:11,589
likely that a we can easily and

00:44:10,210 --> 00:44:12,910
efficiently write these complex

00:44:11,589 --> 00:44:15,700
constraints and be that people can

00:44:12,910 --> 00:44:17,200
actually understand our code which is

00:44:15,700 --> 00:44:21,760
always a plus the trouble is this

00:44:17,200 --> 00:44:25,480
doesn't work oh well because I wasn't

00:44:21,760 --> 00:44:27,789
careful I overloaded ampersand but you

00:44:25,480 --> 00:44:30,490
know other people are doing this too and

00:44:27,789 --> 00:44:32,289
this could actually interfere with other

00:44:30,490 --> 00:44:34,960
people's code I might capture by

00:44:32,289 --> 00:44:37,210
accident somebody else's intended use of

00:44:34,960 --> 00:44:40,260
ampersand but I know how to fix that

00:44:37,210 --> 00:44:42,609
right because that's not what I meant I

00:44:40,260 --> 00:44:43,359
meant this is to be used only if

00:44:42,609 --> 00:44:47,440
everything

00:44:43,359 --> 00:44:49,690
if both p1 and p2 were derived from e so

00:44:47,440 --> 00:44:52,779
now here's my constraint I've called in

00:44:49,690 --> 00:44:54,730
SV a to save my SP na toolkit and now

00:44:52,779 --> 00:44:58,299
this toolkit will not have not affect

00:44:54,730 --> 00:45:00,730
anybody else's code presumably unless

00:44:58,299 --> 00:45:07,140
they also have a a base class in the

00:45:00,730 --> 00:45:07,140
same namespace so that's good

00:45:10,140 --> 00:45:17,799
so in short almost in conclusion our

00:45:15,700 --> 00:45:22,119
designs are getting more and more

00:45:17,799 --> 00:45:23,950
complex but paradoxically just having

00:45:22,119 --> 00:45:26,380
been programming in C++ for so many

00:45:23,950 --> 00:45:28,390
years I've noticed that I don't think

00:45:26,380 --> 00:45:30,089
I'm getting any smarter at least that's

00:45:28,390 --> 00:45:33,819
not the consensus of people I talk to

00:45:30,089 --> 00:45:35,890
but my code is getting easier to write

00:45:33,819 --> 00:45:38,890
and I'm writing much more complex code

00:45:35,890 --> 00:45:42,480
and it's often correct really quickly

00:45:38,890 --> 00:45:46,029
and one of the reasons is I'm using I'm

00:45:42,480 --> 00:45:49,750
embedding my knowledge in the code such

00:45:46,029 --> 00:45:54,460
as it is I'm connecting constraints

00:45:49,750 --> 00:45:57,789
statically whenever I can I am using

00:45:54,460 --> 00:46:00,970
higher-level interfaces do what I mean

00:45:57,789 --> 00:46:04,700
interfaces and shamelessly using s been

00:46:00,970 --> 00:46:06,800
a to eliminate functions I'm not into

00:46:04,700 --> 00:46:08,960
I I lie in wait

00:46:06,800 --> 00:46:10,340
searching for convention whenever I can

00:46:08,960 --> 00:46:11,990
find it and if I can find something

00:46:10,340 --> 00:46:15,170
conventional even if it's unpleasant I

00:46:11,990 --> 00:46:16,520
will use it and as a result my code is

00:46:15,170 --> 00:46:20,780
becoming simpler

00:46:16,520 --> 00:46:24,470
we've always in C++ because syphilis is

00:46:20,780 --> 00:46:27,290
a significantly complex language relied

00:46:24,470 --> 00:46:31,760
on convention and when I teach beginning

00:46:27,290 --> 00:46:35,810
C++ students I like to get the example

00:46:31,760 --> 00:46:37,340
of the making new friends idiom making

00:46:35,810 --> 00:46:39,050
new friends idiom is the one you use

00:46:37,340 --> 00:46:40,910
when you have a class template with

00:46:39,050 --> 00:46:42,290
overloaded binary operators and you want

00:46:40,910 --> 00:46:46,340
to get a user defined to version on the

00:46:42,290 --> 00:46:47,900
Left argument all right it comes up how

00:46:46,340 --> 00:46:50,420
do you do that how do you fix it how do

00:46:47,900 --> 00:46:52,610
you solve that problem it's a complex

00:46:50,420 --> 00:46:55,460
thing it involves argument dependent

00:46:52,610 --> 00:46:58,550
lookup and friends and two-phase

00:46:55,460 --> 00:46:59,860
translation and messages from Jupiter

00:46:58,550 --> 00:47:02,360
you know things like that

00:46:59,860 --> 00:47:05,900
but once you know the making new friends

00:47:02,360 --> 00:47:08,090
idiom you say oh this again and it's

00:47:05,900 --> 00:47:10,400
done and not only that but once you

00:47:08,090 --> 00:47:11,900
solve it you can document it how do you

00:47:10,400 --> 00:47:16,580
document the use of a making new friends

00:47:11,900 --> 00:47:17,960
idiom / / making new friends idiom and

00:47:16,580 --> 00:47:18,950
stunt you just say it's making your

00:47:17,960 --> 00:47:22,490
friends idioms they don't know what the

00:47:18,950 --> 00:47:25,310
idiom is well you know they can hire me

00:47:22,490 --> 00:47:28,640
to teach them the course or something so

00:47:25,310 --> 00:47:30,380
the point is that my thesis I think is

00:47:28,640 --> 00:47:34,850
correct and I'm getting very little

00:47:30,380 --> 00:47:36,980
argument about this recently C++ is

00:47:34,850 --> 00:47:41,440
getting easier to use it's getting

00:47:36,980 --> 00:47:44,870
easier to teach it's more complex but

00:47:41,440 --> 00:47:47,780
the complexity has been controlled by

00:47:44,870 --> 00:47:49,760
C++ itself it's almost as if it's an

00:47:47,780 --> 00:47:51,620
emergent property of the complexity of

00:47:49,760 --> 00:47:55,040
the language and until we reached that

00:47:51,620 --> 00:47:58,130
level it was not quite so easy and

00:47:55,040 --> 00:48:00,320
straightforward to use but we are I

00:47:58,130 --> 00:48:04,310
don't know how you feel but I've been

00:48:00,320 --> 00:48:07,100
very energized ever since just before

00:48:04,310 --> 00:48:08,750
C++ 11 has improved there was a long

00:48:07,100 --> 00:48:11,120
period of years in there where I was

00:48:08,750 --> 00:48:13,520
kind of slogging through my C++ doing

00:48:11,120 --> 00:48:15,200
the best I could but now it's a very

00:48:13,520 --> 00:48:16,260
exciting time we're gonna be doing some

00:48:15,200 --> 00:48:18,780
very very

00:48:16,260 --> 00:48:23,250
interesting and useful things with C++

00:48:18,780 --> 00:48:26,190
and I am very happy that this is my

00:48:23,250 --> 00:48:28,619
native language when I program and it's

00:48:26,190 --> 00:48:31,109
been useful in so many different

00:48:28,619 --> 00:48:32,760
contexts from writing code to bare metal

00:48:31,109 --> 00:48:35,190
hardware to trading derivative

00:48:32,760 --> 00:48:37,619
securities to writing compilers the same

00:48:35,190 --> 00:48:40,740
language sometimes with different

00:48:37,619 --> 00:48:43,440
subsets has been absolutely satisfactory

00:48:40,740 --> 00:48:46,710
and I couldn't be more pleased with all

00:48:43,440 --> 00:48:57,030
these new language features so thank you

00:48:46,710 --> 00:49:07,270
[Applause]

00:48:57,030 --> 00:49:09,220
no threats from the audience yes the

00:49:07,270 --> 00:49:10,540
code is available it's really short it's

00:49:09,220 --> 00:49:12,130
as soon as you see the first three lines

00:49:10,540 --> 00:49:13,000
we'll say oh I know that you can read it

00:49:12,130 --> 00:49:16,180
yourself

00:49:13,000 --> 00:49:19,240
Steve Dewhurst calm it's on my once

00:49:16,180 --> 00:49:21,460
weekly column once weekly spelled WEA K

00:49:19,240 --> 00:49:26,230
because I updated about once every two

00:49:21,460 --> 00:49:29,320
years you'll see there there's an

00:49:26,230 --> 00:49:31,120
article I think I call it template trees

00:49:29,320 --> 00:49:33,160
or something there's a little paper

00:49:31,120 --> 00:49:34,780
about it and then there's some code the

00:49:33,160 --> 00:49:35,950
version I think I wrote it I wrote it

00:49:34,780 --> 00:49:38,080
some time ago it probably needs some

00:49:35,950 --> 00:49:41,740
upgrading I think it's in C++ C love

00:49:38,080 --> 00:49:43,780
then I might have done 14 I'm not sure

00:49:41,740 --> 00:49:44,890
but yeah you can probably find ways to

00:49:43,780 --> 00:50:06,700
improve it with some of the nice new

00:49:44,890 --> 00:50:16,590
features in 17 it points you to a

00:50:06,700 --> 00:50:19,000
neighborhood oh yeah that that's hard

00:50:16,590 --> 00:50:20,320
yeah so yeah this is always the problem

00:50:19,000 --> 00:50:22,660
especially when you're teaching a new

00:50:20,320 --> 00:50:24,520
student someone who's used to a less

00:50:22,660 --> 00:50:26,140
complex language they'll be using a

00:50:24,520 --> 00:50:27,610
template and they'll get an error in the

00:50:26,140 --> 00:50:30,280
middle of the standard library somewhere

00:50:27,610 --> 00:50:32,380
and that's a problem so what do we do

00:50:30,280 --> 00:50:34,060
well concepts but aside from that I mean

00:50:32,380 --> 00:50:37,630
concepts are gonna solve you know

00:50:34,060 --> 00:50:39,520
disease and things like that but in the

00:50:37,630 --> 00:50:41,680
meantime I'm a big fan of using static

00:50:39,520 --> 00:50:43,150
assertions and it seems like you're

00:50:41,680 --> 00:50:44,770
making the problem worse if you have a

00:50:43,150 --> 00:50:46,870
static assertion that various points in

00:50:44,770 --> 00:50:49,180
your code you're saying well I'm already

00:50:46,870 --> 00:50:50,890
getting 26 pages of error messages why

00:50:49,180 --> 00:50:52,990
would I want another error message

00:50:50,890 --> 00:50:54,940
answer it's the only way she'll

00:50:52,990 --> 00:51:00,100
recognize and so if you use static

00:50:54,940 --> 00:51:02,490
assert liberally in your code when I say

00:51:00,100 --> 00:51:04,980
liberally it's not a political statement

00:51:02,490 --> 00:51:07,420
when you use it liberally in your code

00:51:04,980 --> 00:51:08,589
it does really help because

00:51:07,420 --> 00:51:11,260
you'll find this needle in the haystack

00:51:08,589 --> 00:51:14,500
and that's the best practical advice I

00:51:11,260 --> 00:51:16,329
have right now we all know how to debug

00:51:14,500 --> 00:51:18,280
really bad template problems the usual

00:51:16,329 --> 00:51:20,049
thing you do is you know clear your mind

00:51:18,280 --> 00:51:21,520
take the lotus position put your hands

00:51:20,049 --> 00:51:23,859
over the keyboard and hope the answer

00:51:21,520 --> 00:51:26,829
comes to last resort is to actually read

00:51:23,859 --> 00:51:29,109
the error message but if you do read the

00:51:26,829 --> 00:51:30,700
error message it's nice to see one of

00:51:29,109 --> 00:51:33,220
your own messages in there somewhere

00:51:30,700 --> 00:51:35,020
that that will help it saved me a lot of

00:51:33,220 --> 00:51:37,990
time but again the nice thing about

00:51:35,020 --> 00:51:41,170
concepts when they are widely available

00:51:37,990 --> 00:51:43,000
is that they'll catch that error early

00:51:41,170 --> 00:51:46,390
in many cases but we're still gonna

00:51:43,000 --> 00:51:49,960
always have the what is Vander wardens

00:51:46,390 --> 00:51:53,650
Jitsu does call it the error novel that

00:51:49,960 --> 00:51:57,210
you get from templates yeah but that's

00:51:53,650 --> 00:51:57,210
why we have job security right now

00:52:00,569 --> 00:52:03,569
mister

00:52:13,720 --> 00:52:16,880
[Music]

00:52:58,070 --> 00:53:05,099
but yeah that's a very good point and

00:53:01,470 --> 00:53:07,470
the only negative side effect of having

00:53:05,099 --> 00:53:09,270
all these great new features is we don't

00:53:07,470 --> 00:53:11,970
know what's conventional yet

00:53:09,270 --> 00:53:14,369
I just gave a 2-day template programming

00:53:11,970 --> 00:53:17,609
tutorial and I say and here's how you do

00:53:14,369 --> 00:53:19,530
this here's another way here's the third

00:53:17,609 --> 00:53:21,240
way there's a there are five or six ways

00:53:19,530 --> 00:53:23,460
to do everything and we don't know

00:53:21,240 --> 00:53:25,680
what's conventional yet so we don't know

00:53:23,460 --> 00:53:28,980
what we're deviating from when we do

00:53:25,680 --> 00:53:30,210
something differently so I suspect that

00:53:28,980 --> 00:53:32,790
is something that will be cured over

00:53:30,210 --> 00:53:34,770
time the question often arises will

00:53:32,790 --> 00:53:37,050
where the idioms come from we create the

00:53:34,770 --> 00:53:38,970
idioms we create them actually fade

00:53:37,050 --> 00:53:41,670
Ordos he creates all of them then they

00:53:38,970 --> 00:53:44,010
spread throughout the universe know that

00:53:41,670 --> 00:53:46,170
but it's very Darwinian a successful

00:53:44,010 --> 00:53:48,089
idiom that solves problems that

00:53:46,170 --> 00:53:51,020
facilitates communication that makes

00:53:48,089 --> 00:53:53,400
code understandable and simple is shared

00:53:51,020 --> 00:53:56,220
the same way the design patterns are and

00:53:53,400 --> 00:53:58,200
eventually they it takes over and then

00:53:56,220 --> 00:54:01,050
the nice thing about idioms of course is

00:53:58,200 --> 00:54:04,589
they modify over time they they adapt

00:54:01,050 --> 00:54:05,579
themselves I've always thought that you

00:54:04,589 --> 00:54:07,349
know if you think back at various

00:54:05,579 --> 00:54:10,170
languages that were very popular and

00:54:07,349 --> 00:54:14,220
very useful and very well designed in a

00:54:10,170 --> 00:54:15,869
given time eventually died away and it's

00:54:14,220 --> 00:54:18,270
not that the language got worse is get

00:54:15,869 --> 00:54:19,050
the problems changed the problems that

00:54:18,270 --> 00:54:23,490
have solved change

00:54:19,050 --> 00:54:24,690
I think C++ I I would like to talk to

00:54:23,490 --> 00:54:27,420
Bjorn about this I don't know it was

00:54:24,690 --> 00:54:30,030
intentional it possibly was but C++

00:54:27,420 --> 00:54:33,720
language is a substrate we don't really

00:54:30,030 --> 00:54:36,750
program in C++ we program in C++ idioms

00:54:33,720 --> 00:54:40,800
the language evolves very slowly but

00:54:36,750 --> 00:54:44,099
it's a very rich collection of features

00:54:40,800 --> 00:54:46,349
that we combine and make idioms and in

00:54:44,099 --> 00:54:48,660
use at that higher level and I think

00:54:46,349 --> 00:54:51,480
that is what ultimately makes C++ ease

00:54:48,660 --> 00:54:54,240
year to use than some more simple

00:54:51,480 --> 00:54:58,260
language we all speak a natural language

00:54:54,240 --> 00:55:01,260
more or less correctly although I've

00:54:58,260 --> 00:55:03,809
been criticized on that and natural

00:55:01,260 --> 00:55:05,670
languages are infinitely more complex

00:55:03,809 --> 00:55:07,650
than even a language like C++ but none

00:55:05,670 --> 00:55:10,559
of us has any problem with it and part

00:55:07,650 --> 00:55:12,059
of that has to do with idiom part of it

00:55:10,559 --> 00:55:15,720
has to do with knowing the structure

00:55:12,059 --> 00:55:19,589
that overlays these atoms that are words

00:55:15,720 --> 00:55:21,240
and what not enough theory but I think I

00:55:19,589 --> 00:55:28,079
think a particular problem is going to

00:55:21,240 --> 00:55:29,750
be less severe as we decide what is good

00:55:28,079 --> 00:55:33,049
practice with the new features that

00:55:29,750 --> 00:55:33,049
could take years

00:55:35,119 --> 00:56:01,260
yes yeah I'd like to see that my

00:55:59,670 --> 00:56:02,970
experience is it doesn't reduce the size

00:56:01,260 --> 00:56:13,410
that adds to it but at least some of its

00:56:02,970 --> 00:56:16,160
readable okay there is a piano here if

00:56:13,410 --> 00:56:16,160
anybody wants to

00:56:16,210 --> 00:56:21,040
I was told to announce that I should

00:56:19,089 --> 00:56:25,420
have announced it at the beginning it

00:56:21,040 --> 00:56:30,739
was just tuned okay thanks for coming

00:56:25,420 --> 00:56:30,739

YouTube URL: https://www.youtube.com/watch?v=PFdWqa68LmA


