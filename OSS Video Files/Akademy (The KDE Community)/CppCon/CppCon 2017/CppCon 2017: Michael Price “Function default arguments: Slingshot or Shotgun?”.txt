Title: CppCon 2017: Michael Price “Function default arguments: Slingshot or Shotgun?”
Publication date: 2017-10-12
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
On the surface, function parameter default arguments seem like a very simple feature of the C++ language. This session explores how (not) true that is. If you like the dark corners of C++, you will come away with a new appreciation for this innocent looking syntactic sugar. Otherwise, you will have at least informed yourself on how not to blow your foot off with what looks like a slingshot.
— 
Michael Price: Synopsys, Inc., Senior Software Engineer

Michael Price has developed and taught C++ for more than a decade and has been an active participant in WG21 since 2014, allocating most of his committee-time to EWG and the Reflection Study Group. He professes interest in making C++ "safer" to use through language and library design, automation, testing, and education. His past work includes enterprise-grade screen sharing applications, ABI-safe C++ component design, network protocol design, software development utilities, large-scale build and test automation, C/C++ compiler front-end development for static analysis tools, and a smidge of management experience.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,269 --> 00:00:06,509
so hi I'm Michael price the talk here is

00:00:04,589 --> 00:00:11,010
on function default arguments slingshot

00:00:06,509 --> 00:00:13,049
or shotgun currently I'm an employee at

00:00:11,010 --> 00:00:15,450
synopsis working on the static analysis

00:00:13,049 --> 00:00:18,210
engine where I do a lot of compiler

00:00:15,450 --> 00:00:21,210
front-end work and some some work that

00:00:18,210 --> 00:00:23,250
we had recently done sort of required a

00:00:21,210 --> 00:00:25,789
more stringent look at default arguments

00:00:23,250 --> 00:00:28,109
and sort of inspired to this talk so

00:00:25,789 --> 00:00:33,270
hopefully I'll get to mention that later

00:00:28,109 --> 00:00:35,070
on the slides but we'll see so who all

00:00:33,270 --> 00:00:36,840
here thinks they know what function

00:00:35,070 --> 00:00:38,600
default arguments or default function

00:00:36,840 --> 00:00:42,000
arguments are just raise your hand

00:00:38,600 --> 00:00:43,680
everybody thinks they know okay so how

00:00:42,000 --> 00:00:45,629
many people here think that you know you

00:00:43,680 --> 00:00:49,940
know most everything that there is to

00:00:45,629 --> 00:00:53,370
know about them okay we got we a couple

00:00:49,940 --> 00:00:53,699
okay yeah yeah okay well let's get

00:00:53,370 --> 00:00:57,480
started

00:00:53,699 --> 00:01:00,780
so the basics so a function default

00:00:57,480 --> 00:01:02,969
argument are expressions that are

00:01:00,780 --> 00:01:04,350
evaluated when there are fewer provided

00:01:02,969 --> 00:01:05,610
arguments to a function call than the

00:01:04,350 --> 00:01:07,650
number of parameters the best light in

00:01:05,610 --> 00:01:10,200
the function definition okay so all that

00:01:07,650 --> 00:01:12,390
works you have you have a declaration or

00:01:10,200 --> 00:01:16,290
definition of a function right and it's

00:01:12,390 --> 00:01:18,270
got four parameters right you have a

00:01:16,290 --> 00:01:22,229
call site for that function that only

00:01:18,270 --> 00:01:23,970
provides three arguments right normally

00:01:22,229 --> 00:01:25,920
this would be a compilation error right

00:01:23,970 --> 00:01:27,960
you didn't provide enough enough

00:01:25,920 --> 00:01:30,840
arguments to satisfy the the signature

00:01:27,960 --> 00:01:32,520
for this function but if the definition

00:01:30,840 --> 00:01:35,610
declaration of the function has

00:01:32,520 --> 00:01:39,470
specified default arguments then you can

00:01:35,610 --> 00:01:43,530
leave off arguments at the at the end of

00:01:39,470 --> 00:01:46,470
your call right and you know it's it's

00:01:43,530 --> 00:01:49,229
pretty common most languages these days

00:01:46,470 --> 00:01:51,869
have some form of this and it looks like

00:01:49,229 --> 00:01:55,890
a pretty basic and simple language

00:01:51,869 --> 00:01:59,399
feature right what can go wrong so some

00:01:55,890 --> 00:02:02,009
terminology so function default argument

00:01:59,399 --> 00:02:03,479
or is it default function argument so

00:02:02,009 --> 00:02:04,920
when I first came up with the title I

00:02:03,479 --> 00:02:07,469
you know I thought about this and I said

00:02:04,920 --> 00:02:09,030
it on function default argument as I was

00:02:07,469 --> 00:02:10,770
I was actually writing you know

00:02:09,030 --> 00:02:13,260
preparing all the material I decided

00:02:10,770 --> 00:02:16,230
yeah you know default function are

00:02:13,260 --> 00:02:18,510
it actually makes more sense so you know

00:02:16,230 --> 00:02:20,569
the term default argument appears in the

00:02:18,510 --> 00:02:24,060
working paper for the standard a lot

00:02:20,569 --> 00:02:25,920
right you know so there's a whole

00:02:24,060 --> 00:02:29,040
section that you know sort of dedicated

00:02:25,920 --> 00:02:33,150
to default arguments that's listed there

00:02:29,040 --> 00:02:36,120
and in some places in the standard they

00:02:33,150 --> 00:02:39,000
actually use the term default template

00:02:36,120 --> 00:02:41,879
argument they don't really use the term

00:02:39,000 --> 00:02:43,859
default function argument though so

00:02:41,879 --> 00:02:46,049
default template arguments are a lot

00:02:43,859 --> 00:02:47,549
like default function arguments it's

00:02:46,049 --> 00:02:49,920
just they're provided for template

00:02:47,549 --> 00:02:54,349
parameters type and non type parameters

00:02:49,920 --> 00:02:58,170
right you can say type name you know T

00:02:54,349 --> 00:03:00,060
equals int right to say that if you

00:02:58,170 --> 00:03:02,180
don't provide this type parameter we're

00:03:00,060 --> 00:03:04,290
just going to submit to an editor and so

00:03:02,180 --> 00:03:05,970
you kind of have to when you're looking

00:03:04,290 --> 00:03:07,620
at the standard you kind of have to put

00:03:05,970 --> 00:03:09,060
it when you see default argument you

00:03:07,620 --> 00:03:10,319
have to put in the context of what

00:03:09,060 --> 00:03:13,079
they're talking about so sort of

00:03:10,319 --> 00:03:14,970
understand what it is so I'm going to

00:03:13,079 --> 00:03:18,299
call them default function arguments are

00:03:14,970 --> 00:03:22,919
just DFAS from here on out through the

00:03:18,299 --> 00:03:23,579
rest of the presentation so a simple

00:03:22,919 --> 00:03:28,680
example

00:03:23,579 --> 00:03:31,590
I'll let you grok this for a second okay

00:03:28,680 --> 00:03:34,980
so you know it's pretty simple we have a

00:03:31,590 --> 00:03:36,810
function called F n that takes a string

00:03:34,980 --> 00:03:39,389
and returns us and returns a string we

00:03:36,810 --> 00:03:42,120
just return any game and we've provided

00:03:39,389 --> 00:03:45,959
a default function argument of the

00:03:42,120 --> 00:03:48,959
string foo right so then in our main

00:03:45,959 --> 00:03:51,690
function here we can assert that if you

00:03:48,959 --> 00:03:54,540
pass in a string to F 2 FN you just get

00:03:51,690 --> 00:03:56,699
that string back if you don't pass any

00:03:54,540 --> 00:04:01,079
string in you should get the default

00:03:56,699 --> 00:04:04,980
back which is foo right simple easy ace

00:04:01,079 --> 00:04:07,409
kick now this is sort of like the the

00:04:04,980 --> 00:04:09,510
first sort of entry level you know you

00:04:07,409 --> 00:04:12,120
this is obvious right this shouldn't

00:04:09,510 --> 00:04:13,889
confuse anybody now you can have a

00:04:12,120 --> 00:04:15,959
default function argument in lots of

00:04:13,889 --> 00:04:18,329
different cases though you can put them

00:04:15,959 --> 00:04:20,699
on member functions you can put them on

00:04:18,329 --> 00:04:22,990
parameters and the lambda you know the

00:04:20,699 --> 00:04:26,080
signature for a lambda right but

00:04:22,990 --> 00:04:29,590
there you can put them in temp function

00:04:26,080 --> 00:04:31,690
templates so on so on most the time if

00:04:29,590 --> 00:04:33,340
you're doing something simple well the

00:04:31,690 --> 00:04:38,919
syntax that you think should work is

00:04:33,340 --> 00:04:41,800
what's gonna work okay but there are

00:04:38,919 --> 00:04:44,949
some restrictions so do you thought

00:04:41,800 --> 00:04:49,030
function arguments cannot do all of

00:04:44,949 --> 00:04:50,830
these things so you can't put them in

00:04:49,030 --> 00:04:53,919
function like operator functions like

00:04:50,830 --> 00:04:56,020
operator plus you can't put a default

00:04:53,919 --> 00:04:57,190
parameter on the type or on the on the

00:04:56,020 --> 00:05:00,069
parameter our default argument of the

00:04:57,190 --> 00:05:03,130
parameter there unless it's operator

00:05:00,069 --> 00:05:04,780
call parens right because that makes

00:05:03,130 --> 00:05:09,310
sense yeah that's it's a print you're

00:05:04,780 --> 00:05:12,849
calling it so you can't collide with

00:05:09,310 --> 00:05:16,710
things you know they can't print friend

00:05:12,849 --> 00:05:19,360
declarations except with some exceptions

00:05:16,710 --> 00:05:21,250
you know there's an interesting thing

00:05:19,360 --> 00:05:23,650
that got at you so concepts is being

00:05:21,250 --> 00:05:26,590
added in right to the language trying to

00:05:23,650 --> 00:05:27,909
get it add it into the language and is

00:05:26,590 --> 00:05:30,479
they introduced a thing called requires

00:05:27,909 --> 00:05:34,479
expressions which can actually sort of

00:05:30,479 --> 00:05:36,969
introduce a signature for you just for

00:05:34,479 --> 00:05:38,080
type checking you can't put them there

00:05:36,969 --> 00:05:39,250
because it doesn't make any sense

00:05:38,080 --> 00:05:40,630
because you're never going to invoke

00:05:39,250 --> 00:05:44,409
that thing it's just for doing the type

00:05:40,630 --> 00:05:48,180
checking it can't show up in defaulted

00:05:44,409 --> 00:05:51,819
member functions user-defined literals

00:05:48,180 --> 00:05:54,069
there are other things like it can't be

00:05:51,819 --> 00:05:56,319
provided for the size T parameter of if

00:05:54,069 --> 00:05:58,479
you have a custom new function you can't

00:05:56,319 --> 00:06:01,060
say I don't know if you don't say what

00:05:58,479 --> 00:06:03,550
size I'm going to say oh 10 right they

00:06:01,060 --> 00:06:04,569
won't let you do that there are other

00:06:03,550 --> 00:06:06,039
things that makes sense right

00:06:04,569 --> 00:06:07,900
you can't before parameter pack because

00:06:06,039 --> 00:06:12,130
that's the other feature that lets you

00:06:07,900 --> 00:06:13,479
sort of throw extra things in right and

00:06:12,130 --> 00:06:15,580
one that kind of gets some people is

00:06:13,479 --> 00:06:18,400
that you can't use it to deduce a

00:06:15,580 --> 00:06:21,840
template type of parameter right so in

00:06:18,400 --> 00:06:29,190
function templates you can say you know

00:06:21,840 --> 00:06:32,860
template type name T void FN t I equal 1

00:06:29,190 --> 00:06:34,220
right if you call that F in with no

00:06:32,860 --> 00:06:35,720
parameters it won't let

00:06:34,220 --> 00:06:37,190
you do that because it can't figure out

00:06:35,720 --> 00:06:39,560
what the T is even though you have a

00:06:37,190 --> 00:06:44,000
default argument right it's just like no

00:06:39,560 --> 00:06:46,610
I'm not going to let you do that okay so

00:06:44,000 --> 00:06:48,200
there are even more restrictions so that

00:06:46,610 --> 00:06:50,150
was things that default items you can't

00:06:48,200 --> 00:06:52,310
do themselves right

00:06:50,150 --> 00:06:54,680
these are restrictions on what you can

00:06:52,310 --> 00:06:55,940
put in a default argument because

00:06:54,680 --> 00:06:59,570
remember default arguments are

00:06:55,940 --> 00:07:01,760
expressions right just about any

00:06:59,570 --> 00:07:04,040
expression you can come up with in the

00:07:01,760 --> 00:07:07,090
language you could form can be used as a

00:07:04,040 --> 00:07:11,150
default argument except for these cases

00:07:07,090 --> 00:07:13,850
right so you can have a lambda as the

00:07:11,150 --> 00:07:16,580
default argument but only if it doesn't

00:07:13,850 --> 00:07:19,820
capture anything you can actually have

00:07:16,580 --> 00:07:21,590
the capture specifier but as long as it

00:07:19,820 --> 00:07:23,420
doesn't capture anything then you're

00:07:21,590 --> 00:07:26,810
good if that if it captures something it

00:07:23,420 --> 00:07:29,330
the compiler will complain you can't put

00:07:26,810 --> 00:07:32,660
this keyword in there various reasons

00:07:29,330 --> 00:07:34,760
for that in that last bullet point

00:07:32,660 --> 00:07:38,210
previously declared parameter names

00:07:34,760 --> 00:07:41,419
unless in an unavailing context so if I

00:07:38,210 --> 00:07:45,530
my signature if I said in a comma

00:07:41,419 --> 00:07:47,120
it's B equal a right to be just like

00:07:45,530 --> 00:07:48,919
yeah yeah just give me whatever the

00:07:47,120 --> 00:07:50,450
first parameter is I want that same

00:07:48,919 --> 00:07:55,190
thing if you didn't give it to me

00:07:50,450 --> 00:07:57,050
explicitly that's not allowed right even

00:07:55,190 --> 00:08:00,290
if there's another a somewhere in scope

00:07:57,050 --> 00:08:02,360
that's visible globally it will find the

00:08:00,290 --> 00:08:04,370
a in the signature but it will not let

00:08:02,360 --> 00:08:05,720
you do that in order to get the one

00:08:04,370 --> 00:08:07,850
that's out of scope you have to put the

00:08:05,720 --> 00:08:12,800
scope operator and give it a more

00:08:07,850 --> 00:08:14,330
qualified name okay just as like there

00:08:12,800 --> 00:08:16,100
will be time for questions later so I

00:08:14,330 --> 00:08:18,470
know that's a lot of stuff to process

00:08:16,100 --> 00:08:21,410
who here likes well here likes lots of

00:08:18,470 --> 00:08:24,770
pictures in their presentations okay

00:08:21,410 --> 00:08:26,750
sorry I'm not gonna have any of this who

00:08:24,770 --> 00:08:29,090
here likes code examples in the

00:08:26,750 --> 00:08:31,640
presentations good I've got lots of

00:08:29,090 --> 00:08:34,640
those okay who here likes live demos

00:08:31,640 --> 00:08:38,150
during their presentation okay if we go

00:08:34,640 --> 00:08:43,160
fast I might be able to do that so okay

00:08:38,150 --> 00:08:45,140
so before we get into more examples you

00:08:43,160 --> 00:08:47,750
know so the whole premise of the the

00:08:45,140 --> 00:08:50,720
talk is sling shot or shotgun right

00:08:47,750 --> 00:08:52,220
whose murder with foot gun like C++ is a

00:08:50,720 --> 00:08:54,339
foot gun it's like putting a guy here

00:08:52,220 --> 00:08:57,230
foot and waiting for it to go off

00:08:54,339 --> 00:08:59,720
so then inspired that that subtitle of

00:08:57,230 --> 00:09:01,699
this right so you know a shotgun like a

00:08:59,720 --> 00:09:03,350
head spreads it could be really damaging

00:09:01,699 --> 00:09:04,720
and harmful right you don't want to

00:09:03,350 --> 00:09:07,610
shoot your foot with a shotgun a

00:09:04,720 --> 00:09:10,790
slingshot like well a slingshot can hurt

00:09:07,610 --> 00:09:12,620
right I can be very dangerous but

00:09:10,790 --> 00:09:14,329
usually it's a little more finer you

00:09:12,620 --> 00:09:17,029
know precision right it's not it's not a

00:09:14,329 --> 00:09:19,430
shotgun so we got to decide you know

00:09:17,029 --> 00:09:23,569
what is I'm gonna say it's mostly a

00:09:19,430 --> 00:09:26,870
shotgun if you use it carefully it can

00:09:23,569 --> 00:09:29,689
be a slingshot but okay so advice don't

00:09:26,870 --> 00:09:32,000
don't use them okay unless it unless

00:09:29,689 --> 00:09:33,350
it's that simple case that we saw right

00:09:32,000 --> 00:09:38,420
there just don't

00:09:33,350 --> 00:09:41,810
if you tempted don't do it okay there's

00:09:38,420 --> 00:09:44,990
a caveat there are some really cool uses

00:09:41,810 --> 00:09:48,019
for default are function arguments yeah

00:09:44,990 --> 00:09:50,569
maybe maybe you could use those probably

00:09:48,019 --> 00:09:53,050
not but if we get to it I'd like to show

00:09:50,569 --> 00:09:55,850
some of those but again we gotta go fast

00:09:53,050 --> 00:09:57,860
all right so if I said don't use these

00:09:55,850 --> 00:10:00,800
things the first thing you're gonna say

00:09:57,860 --> 00:10:03,470
is but I but I want to any I want to

00:10:00,800 --> 00:10:08,480
write what can I do instead so there's

00:10:03,470 --> 00:10:10,610
an alternative so in C++ we have

00:10:08,480 --> 00:10:13,579
function overloading right an overloaded

00:10:10,610 --> 00:10:16,879
function can take you know multiple sets

00:10:13,579 --> 00:10:20,180
of parameters right and you can use this

00:10:16,879 --> 00:10:21,980
delegation method right so on lines one

00:10:20,180 --> 00:10:25,519
and two we have you know sort of the

00:10:21,980 --> 00:10:28,069
default arguments version right if you

00:10:25,519 --> 00:10:29,870
provide no parameters or no arguments to

00:10:28,069 --> 00:10:35,449
that you're going to get back the string

00:10:29,870 --> 00:10:38,689
fubar right then we have a one that uses

00:10:35,449 --> 00:10:40,850
overloading and delegation right so you

00:10:38,689 --> 00:10:43,100
know if you don't provide anything we're

00:10:40,850 --> 00:10:46,399
gonna call the one argument form with

00:10:43,100 --> 00:10:49,699
foo okay and then that's going to sort

00:10:46,399 --> 00:10:51,290
of insert the second default bar and

00:10:49,699 --> 00:10:55,040
then delegate up to the one that takes

00:10:51,290 --> 00:10:57,980
both parameters right that's a it's a

00:10:55,040 --> 00:10:59,809
lot more a lot more typing it's a little

00:10:57,980 --> 00:11:01,440
safer for various reasons you can see

00:10:59,809 --> 00:11:03,600
the assertions here I've got it

00:11:01,440 --> 00:11:06,420
I've made their equivalent right there

00:11:03,600 --> 00:11:11,960
right regardless of which technique you

00:11:06,420 --> 00:11:15,570
pick they're the same but it turns out

00:11:11,960 --> 00:11:21,620
that that's not exactly true they are

00:11:15,570 --> 00:11:24,390
not perfectly equivalent things for one

00:11:21,620 --> 00:11:25,590
you know you've got multiple functions

00:11:24,390 --> 00:11:27,690
which means multiple symbols in your

00:11:25,590 --> 00:11:28,980
symbol table right whereas with the

00:11:27,690 --> 00:11:32,640
default argument form there's only one

00:11:28,980 --> 00:11:34,790
symbol right that could affect things

00:11:32,640 --> 00:11:37,260
like if you're in an extern c block

00:11:34,790 --> 00:11:39,600
which you know says no you can't do

00:11:37,260 --> 00:11:41,130
overloading there right so if you're in

00:11:39,600 --> 00:11:42,720
that you can't do this you have to you

00:11:41,130 --> 00:11:47,150
want this you have to use the delegate

00:11:42,720 --> 00:11:49,440
the defaults so here's a more devious

00:11:47,150 --> 00:11:54,720
example of why they're not equivalent

00:11:49,440 --> 00:11:58,110
though so if you look at lines 6 through

00:11:54,720 --> 00:11:59,910
13 those are basically the same as the

00:11:58,110 --> 00:12:02,010
previous slide that we saw with code

00:11:59,910 --> 00:12:05,100
except that the default arguments aren't

00:12:02,010 --> 00:12:08,250
literals now it's a call to a function

00:12:05,100 --> 00:12:11,850
calls next okay and if you look up at

00:12:08,250 --> 00:12:14,760
line for the next function is basically

00:12:11,850 --> 00:12:16,920
indexing into some global array right

00:12:14,760 --> 00:12:18,150
and then it's it's actually keeping

00:12:16,920 --> 00:12:23,070
track of where your eyes like an

00:12:18,150 --> 00:12:27,780
iterator right okay so what what's so

00:12:23,070 --> 00:12:30,450
bad about this so on line 17 you can see

00:12:27,780 --> 00:12:32,690
we call defaults with no parameters and

00:12:30,450 --> 00:12:36,030
we get bar-food

00:12:32,690 --> 00:12:39,150
if you remember previously in the

00:12:36,030 --> 00:12:43,530
previous example you know we got the

00:12:39,150 --> 00:12:47,970
first argument and second argument right

00:12:43,530 --> 00:12:49,830
and you know you'd think that you know

00:12:47,970 --> 00:12:51,390
we're gonna index into this array so why

00:12:49,830 --> 00:13:00,120
aren't we getting fubar does anyone want

00:12:51,390 --> 00:13:03,540
to offer a suggestion right so the next

00:13:00,120 --> 00:13:06,690
these these expressions that are then

00:13:03,540 --> 00:13:09,839
the next function call whenever you make

00:13:06,690 --> 00:13:11,790
that function call it doesn't that

00:13:09,839 --> 00:13:13,500
there's the the order in which those

00:13:11,790 --> 00:13:15,270
functions are called are under best fide

00:13:13,500 --> 00:13:19,260
so in this particular case

00:13:15,270 --> 00:13:22,580
the second default argument gets called

00:13:19,260 --> 00:13:25,980
first and it gets the value foo and then

00:13:22,580 --> 00:13:29,160
the first argument gets called you know

00:13:25,980 --> 00:13:32,700
invoke and it gets bar or sorry it gets

00:13:29,160 --> 00:13:35,940
to know it gets bar so you get bar foo

00:13:32,700 --> 00:13:38,550
it's like okay that's unfortunate but if

00:13:35,940 --> 00:13:41,760
you see the delegation method because

00:13:38,550 --> 00:13:43,709
we've now sort of are delegating the the

00:13:41,760 --> 00:13:46,920
evaluation of those expressions in a

00:13:43,709 --> 00:13:49,440
more ordered way we get kind of what you

00:13:46,920 --> 00:13:54,060
would expect right fubar

00:13:49,440 --> 00:13:57,390
ah but it turns out you can still call

00:13:54,060 --> 00:13:59,850
delegate with the with those expressions

00:13:57,390 --> 00:14:01,770
you know directly and when you do that

00:13:59,850 --> 00:14:05,040
you still get the old you know that the

00:14:01,770 --> 00:14:09,810
unev al you ated order problem right you

00:14:05,040 --> 00:14:12,660
get bar food right so this is why like

00:14:09,810 --> 00:14:15,480
when I say use delegation and

00:14:12,660 --> 00:14:16,920
overloading instead if you try this if

00:14:15,480 --> 00:14:19,500
you have default arguments in your code

00:14:16,920 --> 00:14:21,329
you try to go replace them you got to be

00:14:19,500 --> 00:14:22,950
careful you may have some problems this

00:14:21,329 --> 00:14:25,980
is where testing will come in very handy

00:14:22,950 --> 00:14:27,660
right everybody's tests in their code

00:14:25,980 --> 00:14:31,800
right who doesn't have tests I'm going

00:14:27,660 --> 00:14:35,100
to Shane you okay good nobody nobody

00:14:31,800 --> 00:14:37,140
gets shamed today then okay there's

00:14:35,100 --> 00:14:39,779
another problem so say you're going to

00:14:37,140 --> 00:14:41,610
go do this well how would you go about

00:14:39,779 --> 00:14:43,800
doing it you would start replacing these

00:14:41,610 --> 00:14:45,870
things right well while you're in that

00:14:43,800 --> 00:14:47,550
intermediate state where you have some

00:14:45,870 --> 00:14:48,390
that are default arguments and some that

00:14:47,550 --> 00:14:51,750
are overloads

00:14:48,390 --> 00:14:54,120
you can create situations where it's

00:14:51,750 --> 00:14:56,790
ambiguous then right

00:14:54,120 --> 00:14:59,540
so here we have two functions or

00:14:56,790 --> 00:15:02,130
overloaded the low overload set of FN

00:14:59,540 --> 00:15:04,680
one takes a string in an INT and one

00:15:02,130 --> 00:15:06,930
takes a string in a bowl okay

00:15:04,680 --> 00:15:10,529
the the second parameters on each of

00:15:06,930 --> 00:15:12,990
them have defaults right so in our main

00:15:10,529 --> 00:15:15,990
function on line 13 I can call it

00:15:12,990 --> 00:15:17,550
normally with two arguments on 14 I can

00:15:15,990 --> 00:15:19,860
call it normally with two arguments and

00:15:17,550 --> 00:15:21,720
get what I expect but if I try to call

00:15:19,860 --> 00:15:24,029
it with one argument now it has to

00:15:21,720 --> 00:15:26,850
decide which one of these is the right

00:15:24,029 --> 00:15:28,649
one well since both of them could be

00:15:26,850 --> 00:15:30,600
called with a single argument

00:15:28,649 --> 00:15:31,829
now we have an ambiguity problem this

00:15:30,600 --> 00:15:34,860
will luckily this will just fail to

00:15:31,829 --> 00:15:37,800
compile instead of like picking one at

00:15:34,860 --> 00:15:40,769
random or something right so that may

00:15:37,800 --> 00:15:41,879
make it harder to transition if you're

00:15:40,769 --> 00:15:42,899
trying to get rid of these and go

00:15:41,879 --> 00:15:44,670
towards the delegation

00:15:42,899 --> 00:15:49,170
it's just something you'd have to deal

00:15:44,670 --> 00:15:50,730
with okay so so that was all the basics

00:15:49,170 --> 00:15:52,920
everybody feel like they have a good

00:15:50,730 --> 00:16:04,740
idea a good understanding of the basics

00:15:52,920 --> 00:16:07,860
of how this works great so names in a

00:16:04,740 --> 00:16:12,329
default argument are bounded declaration

00:16:07,860 --> 00:16:16,679
but evaluated at use okay should be a

00:16:12,329 --> 00:16:20,490
code example okay line 1 we have a

00:16:16,679 --> 00:16:25,079
global be food we have a namespace in on

00:16:20,490 --> 00:16:27,749
line 3 we say string function with a

00:16:25,079 --> 00:16:30,029
parameter string s equal B and we're

00:16:27,749 --> 00:16:31,829
just going to return s then the next

00:16:30,029 --> 00:16:34,759
line inside the date same namespace we

00:16:31,829 --> 00:16:38,189
have another stream called B that's bar

00:16:34,759 --> 00:16:42,059
now down in our main function when I

00:16:38,189 --> 00:16:44,370
call the namespace in function with no

00:16:42,059 --> 00:16:46,470
parameters it's going to go okay I need

00:16:44,370 --> 00:16:50,069
to get the default argument right need

00:16:46,470 --> 00:16:54,290
to fill that in it's gonna pick the one

00:16:50,069 --> 00:16:58,889
on line one not the one on line five

00:16:54,290 --> 00:17:01,879
right because whenever you scan the line

00:16:58,889 --> 00:17:04,829
four and find that default argument of B

00:17:01,879 --> 00:17:07,319
he's gonna go okay well let's find a B

00:17:04,829 --> 00:17:10,649
head do I know Abby he will not have

00:17:07,319 --> 00:17:13,260
seen the B that's on line five yet so

00:17:10,649 --> 00:17:16,740
he's going to bind that name to the

00:17:13,260 --> 00:17:19,439
global be right but he's not going to

00:17:16,740 --> 00:17:20,970
evaluate yet so then whenever you

00:17:19,439 --> 00:17:23,159
actually call it and it's required he

00:17:20,970 --> 00:17:23,669
goes ah okay that default argument okay

00:17:23,159 --> 00:17:25,500
I got it

00:17:23,669 --> 00:17:27,929
that's that global B you told me about

00:17:25,500 --> 00:17:31,649
earlier and so he's gonna use that can

00:17:27,929 --> 00:17:34,559
you get through now if you if you just

00:17:31,649 --> 00:17:36,779
say B right there - you'll get through

00:17:34,559 --> 00:17:38,789
right because it's gonna find the global

00:17:36,779 --> 00:17:40,260
but you could you could provide

00:17:38,789 --> 00:17:42,990
explicitly the

00:17:40,260 --> 00:17:44,730
space in when and get bar so here's

00:17:42,990 --> 00:17:47,550
here's a little bit of a trick though

00:17:44,730 --> 00:17:49,980
like I said it's bound at that time when

00:17:47,550 --> 00:17:53,790
it sees it a declaration that it's not

00:17:49,980 --> 00:17:58,260
evaluate it until you use it so now on

00:17:53,790 --> 00:18:02,790
line 13 I change the value of the global

00:17:58,260 --> 00:18:05,340
beat to foo bar Baz now when I call the

00:18:02,790 --> 00:18:07,680
function with no parameters no argument

00:18:05,340 --> 00:18:12,090
it's going to get the global B which is

00:18:07,680 --> 00:18:13,770
now a foo bar Baz okay so you have to be

00:18:12,090 --> 00:18:19,020
careful about what it's picking right

00:18:13,770 --> 00:18:20,610
you could get unexpected results or you

00:18:19,020 --> 00:18:26,100
could get expected results if you know

00:18:20,610 --> 00:18:28,110
what it's doing okay so that's one step

00:18:26,100 --> 00:18:30,600
of complication it gets it gets more

00:18:28,110 --> 00:18:31,980
complex so default function arguments

00:18:30,600 --> 00:18:34,290
can be provided across multiple

00:18:31,980 --> 00:18:35,520
declarations of the same function so how

00:18:34,290 --> 00:18:38,760
do you know if you have two declarations

00:18:35,520 --> 00:18:41,100
of a function how can you tell that

00:18:38,760 --> 00:18:44,220
there that they that they're declaring

00:18:41,100 --> 00:18:46,230
the same thing there's a rule there are

00:18:44,220 --> 00:18:49,680
rules that state what is equipped like

00:18:46,230 --> 00:18:53,520
how functions are equivalent right and

00:18:49,680 --> 00:18:54,750
the default arguments do not play into

00:18:53,520 --> 00:18:58,530
the rules about whether something is

00:18:54,750 --> 00:19:00,630
equivalent or not right it's all about

00:18:58,530 --> 00:19:01,470
the signature it's not a thief

00:19:00,630 --> 00:19:04,470
autographs are not a part of the

00:19:01,470 --> 00:19:08,700
signature of the function okay so line 1

00:19:04,470 --> 00:19:12,900
we have a function that returns Auto

00:19:08,700 --> 00:19:15,330
which is going to be a string and takes

00:19:12,900 --> 00:19:16,890
a string it takes a bull we provide a

00:19:15,330 --> 00:19:20,340
default argument for the second

00:19:16,890 --> 00:19:23,520
parameter B it's Maitri we can have

00:19:20,340 --> 00:19:26,220
another declaration after that that now

00:19:23,520 --> 00:19:30,600
provides a new default argument for the

00:19:26,220 --> 00:19:32,160
first parameter leaving off the default

00:19:30,600 --> 00:19:36,180
argument for the second parameter this

00:19:32,160 --> 00:19:38,280
is line 6 okay a lot of people when they

00:19:36,180 --> 00:19:41,810
see line 6 they're gonna go that won't

00:19:38,280 --> 00:19:45,150
compile no that can't be right because

00:19:41,810 --> 00:19:46,530
we know that you have to provide default

00:19:45,150 --> 00:19:48,660
arguments for everything to the right of

00:19:46,530 --> 00:19:51,570
you right like if you're gonna say one

00:19:48,660 --> 00:19:53,310
for argue it for parameter 1 parameter 2

00:19:51,570 --> 00:19:54,119
has to have a default and clearly on

00:19:53,310 --> 00:19:59,059
line 6

00:19:54,119 --> 00:20:02,189
no default there but they're additive

00:19:59,059 --> 00:20:04,799
right so the set of default arguments is

00:20:02,189 --> 00:20:07,679
a union of the default arguments

00:20:04,799 --> 00:20:11,249
provided in all those declarations so

00:20:07,679 --> 00:20:12,779
now on line 10 when I assert when I call

00:20:11,249 --> 00:20:15,649
my function with no parameters

00:20:12,779 --> 00:20:19,349
I'm gonna get foo for the string and

00:20:15,649 --> 00:20:19,769
true for B so I'm gonna get foo back out

00:20:19,349 --> 00:20:22,529
of it

00:20:19,769 --> 00:20:23,669
okay and it's just like if I had

00:20:22,529 --> 00:20:28,469
declared it all in one a single

00:20:23,669 --> 00:20:32,099
declaration right so please no one ever

00:20:28,469 --> 00:20:33,629
do this but if someone's looking at code

00:20:32,099 --> 00:20:35,039
like doing a review or something or

00:20:33,629 --> 00:20:35,999
something has gone wrong that's that's

00:20:35,039 --> 00:20:37,469
the worst case something has gone wrong

00:20:35,999 --> 00:20:39,629
now you have to figure out what it was

00:20:37,469 --> 00:20:43,259
someone sees that they're immediately

00:20:39,629 --> 00:20:44,519
gonna say get blame hey and they're

00:20:43,259 --> 00:20:46,949
gonna take they're gonna get you on the

00:20:44,519 --> 00:20:53,299
I am and complain you know yeah let you

00:20:46,949 --> 00:20:56,669
go okay all right so a little bit of

00:20:53,299 --> 00:20:58,699
formal ish language so restrictions on

00:20:56,669 --> 00:21:01,919
them across multiple declarations

00:20:58,699 --> 00:21:04,799
so given a function f for each parameter

00:21:01,919 --> 00:21:08,149
in that function f there may be only a

00:21:04,799 --> 00:21:13,019
single declaration that provides a

00:21:08,149 --> 00:21:15,569
default argument okay so you can't say

00:21:13,019 --> 00:21:17,489
there's a default argument for parameter

00:21:15,569 --> 00:21:20,719
two here and it's another default

00:21:17,489 --> 00:21:23,729
argument for parameter two later on a

00:21:20,719 --> 00:21:24,989
parameter P that has a default argument

00:21:23,729 --> 00:21:27,269
and a declaration for function f is

00:21:24,989 --> 00:21:29,189
allowed only if there are visible

00:21:27,269 --> 00:21:33,089
default arguments for all following

00:21:29,189 --> 00:21:35,189
parameters of function f visible is that

00:21:33,089 --> 00:21:38,699
word visible is italicized for a reason

00:21:35,189 --> 00:21:42,479
now it gets you in a minute for function

00:21:38,699 --> 00:21:45,389
f called within a scope s the effective

00:21:42,479 --> 00:21:49,589
DFAS for f or the union of all visible

00:21:45,389 --> 00:21:51,269
DFAS at the call site okay so whenever

00:21:49,589 --> 00:21:54,269
you make the call and you say oh I need

00:21:51,269 --> 00:21:56,369
to I need to get the default argument he

00:21:54,269 --> 00:21:59,339
looks at all the declarations for that

00:21:56,369 --> 00:22:00,869
function and he makes a union of all the

00:21:59,339 --> 00:22:04,019
ones of all the default argument that

00:22:00,869 --> 00:22:05,789
were visible and that's what he uses but

00:22:04,019 --> 00:22:08,010
there's this big blank here right I

00:22:05,789 --> 00:22:12,480
wonder what that's about

00:22:08,010 --> 00:22:15,450
so this is weird

00:22:12,480 --> 00:22:17,850
the first declaration in a scope hides

00:22:15,450 --> 00:22:20,460
any of the previously provided default

00:22:17,850 --> 00:22:22,830
arguments for that function this is very

00:22:20,460 --> 00:22:25,230
counterintuitive because we think well

00:22:22,830 --> 00:22:27,150
you're declaring this it should like add

00:22:25,230 --> 00:22:28,440
even though you're in a net just because

00:22:27,150 --> 00:22:30,210
you're in a nested scope doesn't mean

00:22:28,440 --> 00:22:32,610
like you should throw away everything

00:22:30,210 --> 00:22:36,360
you knew so now there's an extra third

00:22:32,610 --> 00:22:39,210
bullet point within scope s the first

00:22:36,360 --> 00:22:41,159
declaration for function f hides any

00:22:39,210 --> 00:22:43,500
previous visible default function

00:22:41,159 --> 00:22:45,840
argument if within scope s it's only

00:22:43,500 --> 00:22:48,900
active within that scope there's an

00:22:45,840 --> 00:22:49,590
example that that will clarify this in

00:22:48,900 --> 00:22:53,490
just a second

00:22:49,590 --> 00:22:55,350
probably terrify you too so okay I'll

00:22:53,490 --> 00:23:03,000
let you look at this for just a second

00:22:55,350 --> 00:23:04,500
okay line one we have a function takes

00:23:03,000 --> 00:23:07,260
two parameters string in a bull they

00:23:04,500 --> 00:23:08,929
both have defaults it you know does the

00:23:07,260 --> 00:23:11,760
same thing that the previous slide did

00:23:08,929 --> 00:23:13,830
so in main you know we can assert we

00:23:11,760 --> 00:23:16,470
call function and yep it's foo that's

00:23:13,830 --> 00:23:20,659
what we expect but we're going to enter

00:23:16,470 --> 00:23:24,960
a new scope lock in lines 10 through 14

00:23:20,659 --> 00:23:28,380
okay so we're now in a nested scope we

00:23:24,960 --> 00:23:30,150
declare that function again but this

00:23:28,380 --> 00:23:33,659
time we don't give it any default

00:23:30,150 --> 00:23:36,510
arguments on the declaration whatever we

00:23:33,659 --> 00:23:38,280
do that within this scope those previous

00:23:36,510 --> 00:23:42,270
default arguments that were visible

00:23:38,280 --> 00:23:43,860
there they're not there anymore right so

00:23:42,270 --> 00:23:45,510
now if I try to call function with no

00:23:43,860 --> 00:23:47,400
parameters the compartments and I don't

00:23:45,510 --> 00:23:49,080
know what you're talking about I see a

00:23:47,400 --> 00:23:51,870
function that takes a string in a bull

00:23:49,080 --> 00:23:53,580
you need to give me more stuff I can't

00:23:51,870 --> 00:23:54,840
even I can't even just provide one right

00:23:53,580 --> 00:23:57,659
it's not like it hides some of them it

00:23:54,840 --> 00:24:01,140
hides all of them okay so then we have

00:23:57,659 --> 00:24:05,309
another scope block 16 through 22 this

00:24:01,140 --> 00:24:09,240
one I provide two declarations and I

00:24:05,309 --> 00:24:10,590
sort of give it new defaults right so

00:24:09,240 --> 00:24:12,720
now I'm going to say the new defaults

00:24:10,590 --> 00:24:15,600
are going to be Baz and false and I do

00:24:12,720 --> 00:24:19,320
it in two different declarations now I

00:24:15,600 --> 00:24:20,550
can call function with no parameters but

00:24:19,320 --> 00:24:22,680
now since the

00:24:20,550 --> 00:24:24,180
second perimeters false it's going to

00:24:22,680 --> 00:24:26,940
return an empty string it doesn't care

00:24:24,180 --> 00:24:29,340
what the first parameter was right if I

00:24:26,940 --> 00:24:33,290
if I on line 17 if I said bull equal

00:24:29,340 --> 00:24:38,880
true then it would have returned bass

00:24:33,290 --> 00:24:41,210
right so you know just the fact of

00:24:38,880 --> 00:24:44,370
declaring Rida clarity a function

00:24:41,210 --> 00:24:45,900
because only yeah I'm good I'm declaring

00:24:44,370 --> 00:24:47,940
just the function I need out of this

00:24:45,900 --> 00:24:49,170
header file you know you know I'm being

00:24:47,940 --> 00:24:51,240
a good citizen

00:24:49,170 --> 00:24:55,310
you could you could lose the ability to

00:24:51,240 --> 00:24:55,310
call without D with default arguments

00:24:55,730 --> 00:24:59,960
okay

00:24:57,080 --> 00:25:03,240
of course it gets more complicated too

00:24:59,960 --> 00:25:07,650
so using declarations that's a way to

00:25:03,240 --> 00:25:09,420
pull names into a scope right it can

00:25:07,650 --> 00:25:12,270
cause more surprises there actually core

00:25:09,420 --> 00:25:13,650
issues in the standard and the standard

00:25:12,270 --> 00:25:18,990
committee approach for these some of

00:25:13,650 --> 00:25:21,450
these things so namespace n has a

00:25:18,990 --> 00:25:23,550
function that just can cats two strings

00:25:21,450 --> 00:25:28,160
together the second string is defaulted

00:25:23,550 --> 00:25:32,310
of bar okay so then I say using in : FN

00:25:28,160 --> 00:25:34,020
right so at that point the function in :

00:25:32,310 --> 00:25:38,520
: FN is available in the global

00:25:34,020 --> 00:25:39,990
namespace just by the name FN okay the

00:25:38,520 --> 00:25:42,630
the thing to know there is that the

00:25:39,990 --> 00:25:44,670
using declaration only pulls into the

00:25:42,630 --> 00:25:46,410
scope you're in the functions the

00:25:44,670 --> 00:25:50,070
signatures that are like the overloads

00:25:46,410 --> 00:25:52,310
that are visible at that point okay so

00:25:50,070 --> 00:25:54,330
if we declare more f ends somewhere

00:25:52,310 --> 00:25:59,220
they're not going to be available in the

00:25:54,330 --> 00:26:01,860
global namespace okay ah but whenever we

00:25:59,220 --> 00:26:03,780
evaluate the default arguments he still

00:26:01,860 --> 00:26:07,140
looks at all of the visible default

00:26:03,780 --> 00:26:10,500
arguments for that function so namespace

00:26:07,140 --> 00:26:14,340
and on line nine right because of the

00:26:10,500 --> 00:26:17,340
using declaration the the declaration on

00:26:14,340 --> 00:26:19,860
line 11 which is equivalent to the one

00:26:17,340 --> 00:26:22,260
on line two because same name same

00:26:19,860 --> 00:26:27,230
return type saying parameters parameter

00:26:22,260 --> 00:26:32,880
types sort of adds into the visible DFAS

00:26:27,230 --> 00:26:33,740
right so now that function has you know

00:26:32,880 --> 00:26:37,610
two

00:26:33,740 --> 00:26:39,620
default arguments foo and bar but then

00:26:37,610 --> 00:26:41,690
we declare some overloads some actual

00:26:39,620 --> 00:26:44,390
real honest-to-god overloads of this

00:26:41,690 --> 00:26:46,850
thing including one that takes no

00:26:44,390 --> 00:26:49,309
parameters right I'm taking no

00:26:46,850 --> 00:26:51,230
parameters and I have another version of

00:26:49,309 --> 00:26:53,720
it they can also take no parameters

00:26:51,230 --> 00:26:55,490
quite causing the default arguments so

00:26:53,720 --> 00:26:57,890
now you know we're in our main function

00:26:55,490 --> 00:27:02,690
I call in the middle just to verify yeah

00:26:57,890 --> 00:27:04,490
yep yep if I if I call it normally you

00:27:02,690 --> 00:27:08,000
know without at that point then yep

00:27:04,490 --> 00:27:11,900
we're good but now if I on line 19 when

00:27:08,000 --> 00:27:16,100
I call in with no parameters it's not

00:27:11,900 --> 00:27:18,230
going to see the F n that's on line 13

00:27:16,100 --> 00:27:20,150
that takes no parameters which is

00:27:18,230 --> 00:27:23,270
probably the one you would expect it to

00:27:20,150 --> 00:27:25,460
find instead it's going to find the

00:27:23,270 --> 00:27:27,950
other declaration that's on line 2 and

00:27:25,460 --> 00:27:30,230
11 and it's going to call that one

00:27:27,950 --> 00:27:32,000
instead because only that overload was

00:27:30,230 --> 00:27:36,170
made visible they by the using

00:27:32,000 --> 00:27:39,140
declaration on line 5 you would not

00:27:36,170 --> 00:27:41,150
expect this behavior anyone that says oh

00:27:39,140 --> 00:27:45,290
yeah I intended to do that like they're

00:27:41,150 --> 00:27:48,080
lying right so and another thing to

00:27:45,290 --> 00:27:49,460
think here that okay well say a using

00:27:48,080 --> 00:27:50,990
declaration is one of those common

00:27:49,460 --> 00:27:52,520
things right like oh yeah use a deck

00:27:50,990 --> 00:27:54,410
with using declaration instead of a

00:27:52,520 --> 00:27:56,480
using directive which pulls a whole

00:27:54,410 --> 00:27:57,740
namespace in or you want to be good you

00:27:56,480 --> 00:27:59,900
don't want to pull everything into your

00:27:57,740 --> 00:28:04,160
scope using directive doesn't have this

00:27:59,900 --> 00:28:06,260
problem right so you can end up someone

00:28:04,160 --> 00:28:08,410
somewhere in a header file you include

00:28:06,260 --> 00:28:11,540
those are using declaration somewhere

00:28:08,410 --> 00:28:18,950
all of a sudden you've got weird

00:28:11,540 --> 00:28:20,150
behavior you weren't expecting okay you

00:28:18,950 --> 00:28:22,670
know it just keeps getting worse

00:28:20,150 --> 00:28:24,650
so at Frost honestly that's probably the

00:28:22,670 --> 00:28:29,929
worst example right that's that's the

00:28:24,650 --> 00:28:32,980
ones just like so let's move on to sort

00:28:29,929 --> 00:28:36,170
of like member functions of classes so

00:28:32,980 --> 00:28:39,309
default arguments on base member

00:28:36,170 --> 00:28:43,070
functions are visible in your type right

00:28:39,309 --> 00:28:47,550
so you know base has one of these things

00:28:43,070 --> 00:28:49,710
derived is derived from base when I call

00:28:47,550 --> 00:28:52,260
you know I make it drive the when I call

00:28:49,710 --> 00:28:54,240
its member function FN he's gonna go k

00:28:52,260 --> 00:28:56,430
FN I need to find an FN he's gonna look

00:28:54,240 --> 00:28:58,740
and derive no there's no FN there he's

00:28:56,430 --> 00:29:00,600
gonna look in basing I FN is in the base

00:28:58,740 --> 00:29:02,220
I can do that and then you know you

00:29:00,600 --> 00:29:04,320
didn't give me any parameters or didn't

00:29:02,220 --> 00:29:06,210
give me arguments ok well that's okay I

00:29:04,320 --> 00:29:08,160
think I can I can invoke this with that

00:29:06,210 --> 00:29:11,580
default art and it works as you would

00:29:08,160 --> 00:29:13,560
expect there's this other bit of Cooley

00:29:11,580 --> 00:29:15,330
arity that I've put here for the purpose

00:29:13,560 --> 00:29:18,110
of illustration for later slides but

00:29:15,330 --> 00:29:21,240
line 12 who's familiar with that syntax

00:29:18,110 --> 00:29:23,700
yeah it's it's an unusual thing you can

00:29:21,240 --> 00:29:26,340
always as long as the accessibility of

00:29:23,700 --> 00:29:28,470
the thing up in the base is accessible

00:29:26,340 --> 00:29:29,900
to you you can always like no no really

00:29:28,470 --> 00:29:34,680
give me give me the thing in the base

00:29:29,900 --> 00:29:38,340
right by using that syntax okay

00:29:34,680 --> 00:29:40,380
so I said they're visible right that is

00:29:38,340 --> 00:29:42,990
unless you hide them with your own

00:29:40,380 --> 00:29:44,490
member function declarations so in this

00:29:42,990 --> 00:29:49,320
case it's it's basically the same thing

00:29:44,490 --> 00:29:51,000
but now derived has his own FN right

00:29:49,320 --> 00:29:54,060
that's a different signature it's a

00:29:51,000 --> 00:29:57,930
different function right now whenever I

00:29:54,060 --> 00:29:59,610
called EF in its gonna look into R I for

00:29:57,930 --> 00:30:03,450
an FN it's going I found one

00:29:59,610 --> 00:30:05,190
okay can we put the parameters in okay

00:30:03,450 --> 00:30:08,370
you didn't give me any arguments but he

00:30:05,190 --> 00:30:09,750
expects one sorry I give up I'm you

00:30:08,370 --> 00:30:13,080
didn't give me enough arguments you

00:30:09,750 --> 00:30:15,450
won't compile okay you can still use the

00:30:13,080 --> 00:30:16,980
base trick to call through to the base

00:30:15,450 --> 00:30:20,240
and get that basis function and call

00:30:16,980 --> 00:30:24,480
that move no arguments that's good and

00:30:20,240 --> 00:30:27,090
lines eight line 18 like this has

00:30:24,480 --> 00:30:28,970
nothing to do with default arguments but

00:30:27,090 --> 00:30:34,020
this is something that is disturbing

00:30:28,970 --> 00:30:36,750
right so if I saw this I called DS FN

00:30:34,020 --> 00:30:39,980
with a string okay

00:30:36,750 --> 00:30:41,160
well these FN takes a bool not a string

00:30:39,980 --> 00:30:43,140
right

00:30:41,160 --> 00:30:46,650
I would I would hope maybe it would not

00:30:43,140 --> 00:30:48,360
compile right and if it did compile I

00:30:46,650 --> 00:30:50,460
would think okay fine you compiled

00:30:48,360 --> 00:30:54,510
you're gonna call the base one that has

00:30:50,460 --> 00:30:56,190
a string right nope instead there's an

00:30:54,510 --> 00:30:58,890
implicit conversion from string literal

00:30:56,190 --> 00:31:01,310
to bulls this is what lets you say

00:30:58,890 --> 00:31:05,820
standard string s equal false

00:31:01,310 --> 00:31:07,200
you know and vice versa so yeah it's not

00:31:05,820 --> 00:31:09,120
related but it's a terrible thing

00:31:07,200 --> 00:31:10,530
and you would get really confused if you

00:31:09,120 --> 00:31:15,720
had this situation going and you had to

00:31:10,530 --> 00:31:18,030
be bug that okay that's fine

00:31:15,720 --> 00:31:20,250
but you know you can actually unhide

00:31:18,030 --> 00:31:25,380
them now with using declarations in your

00:31:20,250 --> 00:31:27,780
in your in your classes okay so this

00:31:25,380 --> 00:31:28,890
time we're gonna have two derived types

00:31:27,780 --> 00:31:31,800
okay

00:31:28,890 --> 00:31:33,900
d1 is basically you know basically

00:31:31,800 --> 00:31:35,550
equivalent to what we had seen drive in

00:31:33,900 --> 00:31:37,470
the previous slide you've got an

00:31:35,550 --> 00:31:39,540
overload so now that hides the one in

00:31:37,470 --> 00:31:40,890
the base but they say now I really want

00:31:39,540 --> 00:31:42,870
the ones that are the overloads that are

00:31:40,890 --> 00:31:45,420
in the base I want those available here

00:31:42,870 --> 00:31:49,500
to me too so you say using base FN great

00:31:45,420 --> 00:31:52,290
now I can use those for the second

00:31:49,500 --> 00:31:55,140
derived type I'm gonna say using bases

00:31:52,290 --> 00:31:57,840
if FN first that's gonna pull all the

00:31:55,140 --> 00:32:01,980
ones from base in but then I'm gonna say

00:31:57,840 --> 00:32:06,870
Auto FN string s equal bar now when I do

00:32:01,980 --> 00:32:08,670
that that declaration now hides the one

00:32:06,870 --> 00:32:12,000
that was in the base because it's the

00:32:08,670 --> 00:32:13,830
same signature right so the using

00:32:12,000 --> 00:32:15,870
declaration is really saying yeah bring

00:32:13,830 --> 00:32:17,400
all those things in unless I say that

00:32:15,870 --> 00:32:19,080
I'm gonna have my own version of that

00:32:17,400 --> 00:32:21,960
exact function with its own you know

00:32:19,080 --> 00:32:26,610
that's the exact signature okay

00:32:21,960 --> 00:32:29,790
so base B you know I call the function I

00:32:26,610 --> 00:32:31,800
get food that's what I would expect D so

00:32:29,790 --> 00:32:33,990
I get D one I call its function

00:32:31,800 --> 00:32:36,780
I expect it to call the basis function

00:32:33,990 --> 00:32:39,210
right with its argument so I get food D

00:32:36,780 --> 00:32:43,830
2 so I call the function with no

00:32:39,210 --> 00:32:46,110
arguments it picks D twos copy of F n

00:32:43,830 --> 00:32:48,570
which has a default argument bar and it

00:32:46,110 --> 00:32:52,140
adds some bangs to it right so I get bar

00:32:48,570 --> 00:32:53,820
dangling back ah but remember that trick

00:32:52,140 --> 00:32:56,160
I can always get back to the basis

00:32:53,820 --> 00:32:58,230
function right by using the little piece

00:32:56,160 --> 00:33:02,240
the the call through the base trick

00:32:58,230 --> 00:33:02,240
right and I get through there

00:33:10,070 --> 00:33:21,530
I don't think so but I would want to

00:33:16,370 --> 00:33:23,630
experiment but the fact that it the fact

00:33:21,530 --> 00:33:25,250
that it is in different order

00:33:23,630 --> 00:33:26,090
HP think that I probably did it the

00:33:25,250 --> 00:33:29,750
other way and there may have been a

00:33:26,090 --> 00:33:30,950
problem with it and so it was a while

00:33:29,750 --> 00:33:34,220
ago when I wrote

00:33:30,950 --> 00:33:36,080
okay so default function makes

00:33:34,220 --> 00:33:38,180
overwritten virtual member functions so

00:33:36,080 --> 00:33:40,130
I mean we remember their functions just

00:33:38,180 --> 00:33:42,650
like anybody else so so why not we can

00:33:40,130 --> 00:33:44,600
do that right well it turns out there

00:33:42,650 --> 00:33:46,970
are yet more problems doing it this way

00:33:44,600 --> 00:33:51,320
and this is actually a more well-known

00:33:46,970 --> 00:33:53,110
problem so now my function here is a

00:33:51,320 --> 00:33:57,860
virtual and I'm gonna overwrite it

00:33:53,110 --> 00:33:59,660
alright so string s equals foo but my

00:33:57,860 --> 00:34:03,680
override doesn't provide a default

00:33:59,660 --> 00:34:06,440
argument right so now when I call the

00:34:03,680 --> 00:34:09,110
function from my base from a base type i

00:34:06,440 --> 00:34:14,570
get what i expect food we returned s

00:34:09,110 --> 00:34:17,419
right but if i try to call it with no

00:34:14,570 --> 00:34:20,720
arguments from my derived i get what we

00:34:17,419 --> 00:34:22,520
had seen before right derives FN doesn't

00:34:20,720 --> 00:34:25,159
have you can't call it with no

00:34:22,520 --> 00:34:28,040
parameters right yeah so that doesn't

00:34:25,159 --> 00:34:33,669
compile okay well how do we make it

00:34:28,040 --> 00:34:33,669
compile yeah what can we do about this

00:34:34,990 --> 00:34:43,550
so you can use what's called the non

00:34:39,409 --> 00:34:44,780
virtual interface technique or method at

00:34:43,550 --> 00:34:46,850
some point sometimes it's being called

00:34:44,780 --> 00:34:48,980
the template method pattern I think

00:34:46,850 --> 00:34:53,419
maybe some of her herbs early stuff with

00:34:48,980 --> 00:34:55,340
W called it that but the basic idea is

00:34:53,419 --> 00:34:57,580
that the interface that consumers of

00:34:55,340 --> 00:35:01,130
this are going to use is not a virtual

00:34:57,580 --> 00:35:04,700
right it's it's a member of the base no

00:35:01,130 --> 00:35:07,490
not virtual and instead it delegates to

00:35:04,700 --> 00:35:11,420
a private virtual function that you can

00:35:07,490 --> 00:35:15,860
override in any derived types right so

00:35:11,420 --> 00:35:18,260
now when we use this pattern we just say

00:35:15,860 --> 00:35:19,250
okay don't really call do F in which is

00:35:18,260 --> 00:35:24,290
virtual it will do

00:35:19,250 --> 00:35:25,940
dynamic dispatch and then we'll get the

00:35:24,290 --> 00:35:29,180
right you know implementation of the

00:35:25,940 --> 00:35:33,349
function right and so now when I called

00:35:29,180 --> 00:35:35,119
EF n he goes DF n okay is there an F in

00:35:33,349 --> 00:35:37,700
inside derived though there's not okay

00:35:35,119 --> 00:35:39,320
looking the base he finds it right he

00:35:37,700 --> 00:35:41,420
said oh there's a department there I can

00:35:39,320 --> 00:35:44,690
actually do this call and he gives you

00:35:41,420 --> 00:35:45,230
foo but with the implementation of bang

00:35:44,690 --> 00:35:46,730
bang bang

00:35:45,230 --> 00:35:51,680
you know add bang bang to the end of it

00:35:46,730 --> 00:35:55,400
oh great perfect that works this is what

00:35:51,680 --> 00:35:58,030
we wanted right oh but what happens if

00:35:55,400 --> 00:36:00,320
that means if we actually do want a

00:35:58,030 --> 00:36:03,800
default argument for that for that

00:36:00,320 --> 00:36:05,859
overriding function right okay it's

00:36:03,800 --> 00:36:08,240
reasonable you you might want to do this

00:36:05,859 --> 00:36:11,470
so so we do that right so now the

00:36:08,240 --> 00:36:13,880
derived has a default argument of a bar

00:36:11,470 --> 00:36:15,650
right so you know maybe if you're

00:36:13,880 --> 00:36:19,940
calling it from derived or can we expect

00:36:15,650 --> 00:36:22,190
bar a bang bang bang right and that's

00:36:19,940 --> 00:36:25,550
what you get you know base B right you

00:36:22,190 --> 00:36:31,780
know you called D F F n you get bar bang

00:36:25,550 --> 00:36:34,310
bang bang but if you invoke this from

00:36:31,780 --> 00:36:36,080
the base so you know you can get a

00:36:34,310 --> 00:36:39,380
reference to the base from that from

00:36:36,080 --> 00:36:42,950
that D object right if you call it from

00:36:39,380 --> 00:36:47,720
that static type you're going to get

00:36:42,950 --> 00:36:52,849
bases default argument and derives in

00:36:47,720 --> 00:36:58,250
Toulon tation okay it may be that you

00:36:52,849 --> 00:37:00,530
want to do that maybe right but you know

00:36:58,250 --> 00:37:02,570
if if if I'm looking at either one of

00:37:00,530 --> 00:37:04,730
these function definitions just alone

00:37:02,570 --> 00:37:06,680
keep in mind you this is a contrived

00:37:04,730 --> 00:37:08,690
example most time these things can be

00:37:06,680 --> 00:37:10,550
separated by different files and you

00:37:08,690 --> 00:37:11,690
know hundreds and hundreds of lines of

00:37:10,550 --> 00:37:14,089
code right you're not gonna be able to

00:37:11,690 --> 00:37:14,990
see them together in the same context so

00:37:14,089 --> 00:37:17,630
look at if I'm looking at either

00:37:14,990 --> 00:37:19,720
function alone here like how do I get

00:37:17,630 --> 00:37:23,030
through bang bang bang I mean it says

00:37:19,720 --> 00:37:29,570
bar bang bang bang as you concatenate

00:37:23,030 --> 00:37:32,690
those alright so that's a problem so how

00:37:29,570 --> 00:37:33,010
might we fix that I want I want bar bang

00:37:32,690 --> 00:37:38,530
bang

00:37:33,010 --> 00:37:41,170
for that last what can we do well the

00:37:38,530 --> 00:37:43,500
problem is that the default arguments

00:37:41,170 --> 00:37:45,580
are determined from the stack type

00:37:43,500 --> 00:37:47,830
whereas the implementation that gets

00:37:45,580 --> 00:37:50,170
picked is because of dynamic dispatch

00:37:47,830 --> 00:37:52,060
right you dynamically figure out which

00:37:50,170 --> 00:37:53,680
implementation you use so if you want

00:37:52,060 --> 00:37:56,050
the default argument to also be

00:37:53,680 --> 00:37:59,230
dynamically determined well guess what

00:37:56,050 --> 00:38:02,650
you have to call a virtual function for

00:37:59,230 --> 00:38:04,390
the default argument right so and in

00:38:02,650 --> 00:38:05,560
this particular case we've just said

00:38:04,390 --> 00:38:07,570
we're gonna make it

00:38:05,560 --> 00:38:13,450
delegated as well instead of using

00:38:07,570 --> 00:38:15,580
default arguments so in fact you have to

00:38:13,450 --> 00:38:18,610
do that because if you put the is that

00:38:15,580 --> 00:38:20,020
right yeah I think you have to do that

00:38:18,610 --> 00:38:23,460
because if you provided the default

00:38:20,020 --> 00:38:25,870
argument if you said if you call this

00:38:23,460 --> 00:38:28,450
this virtual method as a part of the

00:38:25,870 --> 00:38:31,120
default argument your your type is still

00:38:28,450 --> 00:38:32,260
your base right it's so he's gonna get

00:38:31,120 --> 00:38:34,930
the wrong one so you have to use

00:38:32,260 --> 00:38:37,870
delegation to fix this now you know this

00:38:34,930 --> 00:38:40,420
is a lot more code to make that work and

00:38:37,870 --> 00:38:43,360
now imagine if you had multiple

00:38:40,420 --> 00:38:44,590
parameters with defaults provided this

00:38:43,360 --> 00:38:51,640
would get out of hand

00:38:44,590 --> 00:38:54,720
very very quickly right okay yeah so I

00:38:51,640 --> 00:38:58,000
mean is that that better I don't know

00:38:54,720 --> 00:39:02,880
probably not yeah it's it's much more

00:38:58,000 --> 00:39:05,620
complicated so take it for what it is

00:39:02,880 --> 00:39:08,440
all right so this so far we've avoided

00:39:05,620 --> 00:39:09,610
talking about templates all right so now

00:39:08,440 --> 00:39:11,040
we're gonna we're gonna talk some about

00:39:09,610 --> 00:39:14,260
tickles

00:39:11,040 --> 00:39:19,170
so default arguments for function

00:39:14,260 --> 00:39:21,640
templates add some extra complexity

00:39:19,170 --> 00:39:24,310
there's a section in the standard about

00:39:21,640 --> 00:39:26,470
about templates that talks specifically

00:39:24,310 --> 00:39:28,240
about this and there are certain rules

00:39:26,470 --> 00:39:30,910
and they and they give it a label a name

00:39:28,240 --> 00:39:32,500
default argument instantiation okay so

00:39:30,910 --> 00:39:36,010
that's that's the thing we're gonna talk

00:39:32,500 --> 00:39:37,870
about right now so this is a summary you

00:39:36,010 --> 00:39:41,020
can you can find the actual paragraph in

00:39:37,870 --> 00:39:43,330
the standard up there for function

00:39:41,020 --> 00:39:46,510
template and presumably a member

00:39:43,330 --> 00:39:47,130
function of any class templates default

00:39:46,510 --> 00:39:48,960
arguments are

00:39:47,130 --> 00:39:50,370
always completely parsed until the

00:39:48,960 --> 00:39:54,240
template has been called in a way that

00:39:50,370 --> 00:39:57,380
requires the default argument right so

00:39:54,240 --> 00:40:00,750
it may not parse the full expression

00:39:57,380 --> 00:40:04,050
completely until you've instantiate it

00:40:00,750 --> 00:40:05,760
the template and have required the

00:40:04,050 --> 00:40:07,980
default argument I mean you've called

00:40:05,760 --> 00:40:10,710
that function that function template

00:40:07,980 --> 00:40:14,010
with with no arguments or you have to

00:40:10,710 --> 00:40:16,890
substitute them in right so this this

00:40:14,010 --> 00:40:23,910
sounds an awful lot like two-phase like

00:40:16,890 --> 00:40:26,730
two-phase lookup problems right okay so

00:40:23,910 --> 00:40:29,370
we've got a template on lines 1 2 & 3 a

00:40:26,730 --> 00:40:34,050
function template it's default argument

00:40:29,370 --> 00:40:37,740
is a get function that takes T so that's

00:40:34,050 --> 00:40:40,560
it that's a dependent expression right

00:40:37,740 --> 00:40:43,260
it depends on the type the the value of

00:40:40,560 --> 00:40:46,860
the templates parameter right so that

00:40:43,260 --> 00:40:48,180
means whenever compiler parses this he

00:40:46,860 --> 00:40:49,740
can't actually make a final

00:40:48,180 --> 00:40:52,620
determination of whether or not that's

00:40:49,740 --> 00:40:54,000
valid without knowing what the type is

00:40:52,620 --> 00:40:56,910
that's what it means to be dependent

00:40:54,000 --> 00:40:59,100
okay so you know he just returns

00:40:56,910 --> 00:41:01,350
whatever it was so later on we have a

00:40:59,100 --> 00:41:04,410
class a we have a function called get

00:41:01,350 --> 00:41:07,680
finally caught return and it just

00:41:04,410 --> 00:41:09,930
returns 42 so now on line 11 we

00:41:07,680 --> 00:41:13,020
instantiate that function template with

00:41:09,930 --> 00:41:16,170
type a so there we go okay we got a type

00:41:13,020 --> 00:41:19,520
A in theory we could we could now verify

00:41:16,170 --> 00:41:24,930
that that get function is valid right

00:41:19,520 --> 00:41:27,750
but it doesn't necessarily do it until

00:41:24,930 --> 00:41:32,490
we actually invoke that parameter and we

00:41:27,750 --> 00:41:34,800
need it right so that that works now if

00:41:32,490 --> 00:41:37,530
I call FN of a with like an actual

00:41:34,800 --> 00:41:39,350
integer presumably it doesn't have to

00:41:37,530 --> 00:41:41,600
worry about whether get is valid or not

00:41:39,350 --> 00:41:48,180
it could be it could still be a bad

00:41:41,600 --> 00:41:50,460
substitution okay so we talked about

00:41:48,180 --> 00:41:52,350
that was that was a dependent type you

00:41:50,460 --> 00:41:56,930
know independent expression what if it's

00:41:52,350 --> 00:42:00,180
not dependent so this time I'm gonna say

00:41:56,930 --> 00:42:00,349
I'm gonna do weird stuff right I'm going

00:42:00,180 --> 00:42:03,769
to

00:42:00,349 --> 00:42:06,829
a caste the integer 42 to goal right

00:42:03,769 --> 00:42:10,210
something nonsensical right and and then

00:42:06,829 --> 00:42:13,640
assign that to an integer sure why not

00:42:10,210 --> 00:42:16,160
so the key here is that that caste the

00:42:13,640 --> 00:42:18,289
bool is using C++ Elevens uniform

00:42:16,160 --> 00:42:21,769
initialization syntax that prevents

00:42:18,289 --> 00:42:24,650
narrowing conversions right so if I put

00:42:21,769 --> 00:42:27,829
if I just said inside like main int n

00:42:24,650 --> 00:42:29,960
equal bull 40 you know curly 42 the

00:42:27,829 --> 00:42:33,319
compiler we got nope not gonna let you

00:42:29,960 --> 00:42:36,499
do that right but now remember that's

00:42:33,319 --> 00:42:38,180
not a dependent expression right so the

00:42:36,499 --> 00:42:40,220
compiler should be able to like fully

00:42:38,180 --> 00:42:42,739
parse that and determine that it's a bad

00:42:40,220 --> 00:42:46,700
thing when it sees the the template

00:42:42,739 --> 00:42:49,460
declaration right well so I did some

00:42:46,700 --> 00:42:51,200
experiments on this immense to be seeing

00:42:49,460 --> 00:42:51,859
claims that yeah no we're not gonna let

00:42:51,200 --> 00:42:55,190
you do that

00:42:51,859 --> 00:42:57,470
but GCC's like yeah sure bring it on

00:42:55,190 --> 00:42:58,819
you know I mean you know chances are

00:42:57,470 --> 00:43:00,049
you're using this thing or prettiest of

00:42:58,819 --> 00:43:06,109
all you know I guess we'll just keep

00:43:00,049 --> 00:43:08,119
going so if I even in stick so I online

00:43:06,109 --> 00:43:10,069
nine I've instantiate at the template

00:43:08,119 --> 00:43:13,069
now but I've not used the default

00:43:10,069 --> 00:43:15,710
argument okay again GCC has an

00:43:13,069 --> 00:43:16,940
opportunity to go hey you print there

00:43:15,710 --> 00:43:19,400
was a d4 give me that it's not good

00:43:16,940 --> 00:43:23,569
right but he does it just like yeah sure

00:43:19,400 --> 00:43:25,759
why not still it's only when you

00:43:23,569 --> 00:43:27,680
actually instantiate the template and

00:43:25,759 --> 00:43:31,430
call it such it needs the default

00:43:27,680 --> 00:43:34,039
argument that it says no no can't do

00:43:31,430 --> 00:43:37,039
that that's not that's not good so I

00:43:34,039 --> 00:43:40,359
asked the I asked the the core language

00:43:37,039 --> 00:43:41,599
group and the committee so like is this

00:43:40,359 --> 00:43:43,700
ill-formed

00:43:41,599 --> 00:43:45,739
like what's what's the story years they

00:43:43,700 --> 00:43:49,099
have different you know diverging

00:43:45,739 --> 00:43:50,660
implementations here in the story the

00:43:49,099 --> 00:43:53,779
answer that came back was that it's

00:43:50,660 --> 00:43:56,539
ill-formed this is ill-formed line two

00:43:53,779 --> 00:43:59,200
is ill-formed but it's no diagnostic

00:43:56,539 --> 00:43:59,200
required

00:44:01,280 --> 00:44:05,640
you could you could argue like okay no

00:44:03,750 --> 00:44:07,410
diagnosis required should that should it

00:44:05,640 --> 00:44:11,220
work like should it like actually build

00:44:07,410 --> 00:44:13,500
and run like do nominally what you might

00:44:11,220 --> 00:44:15,180
expect if you don't invoke it that way

00:44:13,500 --> 00:44:21,270
I guess it's a theoretical question

00:44:15,180 --> 00:44:23,730
right okay there's one other variant of

00:44:21,270 --> 00:44:28,049
this so what if what if the default rate

00:44:23,730 --> 00:44:29,819
is dependent but it's actually invalid

00:44:28,049 --> 00:44:31,589
once you want you to determine the

00:44:29,819 --> 00:44:35,510
dependency like you substitute a type in

00:44:31,589 --> 00:44:38,039
and now it's invalid right so this time

00:44:35,510 --> 00:44:40,799
you know I'm actually doing this task

00:44:38,039 --> 00:44:45,089
with the type that was given to me right

00:44:40,799 --> 00:44:47,069
on line two right so if I give it an int

00:44:45,089 --> 00:44:49,890
it should be like sure peachie good

00:44:47,069 --> 00:44:51,809
there if I give it a bool like was in

00:44:49,890 --> 00:44:55,170
the previous example what's gonna happen

00:44:51,809 --> 00:44:56,940
right so you know yeah oh when they

00:44:55,170 --> 00:44:59,099
declare it when just the declaration

00:44:56,940 --> 00:45:03,289
all of them are yeah sure that's that's

00:44:59,099 --> 00:45:06,000
sure that can work then on line nine I

00:45:03,289 --> 00:45:09,119
instantiate the template but I don't use

00:45:06,000 --> 00:45:11,549
the default argument okay they're all

00:45:09,119 --> 00:45:13,500
they're all still yeah let's let's do it

00:45:11,549 --> 00:45:15,930
it makes sense right you didn't use this

00:45:13,500 --> 00:45:17,819
in an invalid way it's only whenever you

00:45:15,930 --> 00:45:19,200
invoke it you would saturate it and need

00:45:17,819 --> 00:45:21,240
the default argument they're all fine

00:45:19,200 --> 00:45:23,460
like yeah that's what and for what it's

00:45:21,240 --> 00:45:25,230
worth this is good like this is the

00:45:23,460 --> 00:45:27,329
behavior I would expect right

00:45:25,230 --> 00:45:33,539
yeah actually did what I thought it was

00:45:27,329 --> 00:45:36,059
gonna do okay so all those examples of

00:45:33,539 --> 00:45:38,369
everything that can go wrong I'll repeat

00:45:36,059 --> 00:45:40,619
myself from the beginning don't do these

00:45:38,369 --> 00:45:44,069
things so just just ignore just don't

00:45:40,619 --> 00:45:45,660
use default arguments right so then if

00:45:44,069 --> 00:45:48,779
you take that advice but what are you

00:45:45,660 --> 00:45:49,920
gonna do about it right like how what do

00:45:48,779 --> 00:45:55,380
we do okay

00:45:49,920 --> 00:45:57,059
well you got some options you can have

00:45:55,380 --> 00:45:58,680
coding guidelines you know like add

00:45:57,059 --> 00:46:00,480
don't use these things right

00:45:58,680 --> 00:46:03,329
people pay whoever has coding guidelines

00:46:00,480 --> 00:46:04,839
in here in your industry okay you should

00:46:03,329 --> 00:46:07,599
have them if you don't

00:46:04,839 --> 00:46:09,460
right there they're important you can

00:46:07,599 --> 00:46:11,019
use code review right you get a senior

00:46:09,460 --> 00:46:12,339
engineer to look at every junior

00:46:11,019 --> 00:46:15,069
engineers to make sure they're not doing

00:46:12,339 --> 00:46:17,650
this you can do static analysis tools

00:46:15,069 --> 00:46:20,410
diagnosis tools for most of these things

00:46:17,650 --> 00:46:22,390
static houses tools can detect or it can

00:46:20,410 --> 00:46:24,849
certainly detect hey you provided a

00:46:22,390 --> 00:46:27,609
default argument in this signature don't

00:46:24,849 --> 00:46:30,910
do that right that might be overkill

00:46:27,609 --> 00:46:32,859
alright but if your rules for your

00:46:30,910 --> 00:46:34,839
industry or your professions they don't

00:46:32,859 --> 00:46:36,969
do that then you could conceivably do

00:46:34,839 --> 00:46:39,869
that and then unit testing

00:46:36,969 --> 00:46:46,989
all right that's why you can avoid a

00:46:39,869 --> 00:46:49,539
weird unexpected behavior okay so it's

00:46:46,989 --> 00:46:50,799
946 we have about 14 minutes left I

00:46:49,539 --> 00:46:52,299
don't want to go over time because

00:46:50,799 --> 00:46:55,630
there's no more talking there's another

00:46:52,299 --> 00:46:57,849
talk at right after this I can take

00:46:55,630 --> 00:46:59,469
questions the more questions I take the

00:46:57,849 --> 00:47:02,680
less of the really cool stuff we get to

00:46:59,469 --> 00:47:04,210
see though so anybody want they if you

00:47:02,680 --> 00:47:05,559
have a question just go up to the mic or

00:47:04,210 --> 00:47:09,849
just it's a small room you can yell it

00:47:05,559 --> 00:47:14,499
now I'll repeat it what it is everybody

00:47:09,849 --> 00:47:16,690
wants to see the cool stuff okay okay so

00:47:14,499 --> 00:47:18,190
I said it was caveat like oh maybe the

00:47:16,690 --> 00:47:20,739
cool stuff maybe we should use it for

00:47:18,190 --> 00:47:22,809
these things I'm still not convinced

00:47:20,739 --> 00:47:26,890
myself that these are worth it but they

00:47:22,809 --> 00:47:30,640
are pretty neat okay so who knows about

00:47:26,890 --> 00:47:35,469
the the library ts did you have a

00:47:30,640 --> 00:47:36,999
question okay so the library ts so the

00:47:35,469 --> 00:47:37,749
library fundamentals - yes so there's

00:47:36,999 --> 00:47:39,729
version one

00:47:37,749 --> 00:47:43,509
there's version two presumably they'll

00:47:39,729 --> 00:47:46,539
be version three so this is a type

00:47:43,509 --> 00:47:48,640
that's added to the version two of the

00:47:46,539 --> 00:47:50,229
library fundamentals ts just from the

00:47:48,640 --> 00:47:58,210
names they may want to guess what it's

00:47:50,229 --> 00:47:59,950
supposed to do mm-hm nobody yeah file

00:47:58,210 --> 00:48:01,989
and line number right it gives you that

00:47:59,950 --> 00:48:04,079
information but you say but we already

00:48:01,989 --> 00:48:07,239
have that with the file in line macro

00:48:04,079 --> 00:48:10,599
macros right well this gives us an

00:48:07,239 --> 00:48:12,460
actual full type with your functions and

00:48:10,599 --> 00:48:13,509
things we can pass it around as a unit

00:48:12,460 --> 00:48:17,140
and things like that

00:48:13,509 --> 00:48:18,490
as far as I know there are no existing

00:48:17,140 --> 00:48:21,580
full implementations

00:48:18,490 --> 00:48:25,150
this in any of the shipping libraries

00:48:21,580 --> 00:48:27,040
standard libraries so this code of all

00:48:25,150 --> 00:48:30,820
of the other code I should say all of

00:48:27,040 --> 00:48:33,250
the other code is available at this sort

00:48:30,820 --> 00:48:35,530
of relative path to the github link that

00:48:33,250 --> 00:48:37,030
I posted on the first slide if you need

00:48:35,530 --> 00:48:39,100
that later you can find me and I'll give

00:48:37,030 --> 00:48:43,600
it to you this is the one that doesn't

00:48:39,100 --> 00:48:45,460
actually compile yet right so with this

00:48:43,600 --> 00:48:48,369
you could say something like I'm gonna

00:48:45,460 --> 00:48:53,380
define my own custom assertion function

00:48:48,369 --> 00:48:55,930
right and this uses the trick that the

00:48:53,380 --> 00:48:58,000
default argument is evaluated in the

00:48:55,930 --> 00:49:01,840
context of where the function is called

00:48:58,000 --> 00:49:04,540
and it needs it right so the the usage

00:49:01,840 --> 00:49:08,320
of it on line 24 you say my cert faults

00:49:04,540 --> 00:49:14,020
I did this on purpose right whenever you

00:49:08,320 --> 00:49:16,240
call that the source location argument

00:49:14,020 --> 00:49:20,020
that's going to get passed in is local

00:49:16,240 --> 00:49:25,510
current okay that's evaluated in the

00:49:20,020 --> 00:49:28,840
context of this file line 24 right so

00:49:25,510 --> 00:49:30,520
the the column number and line and

00:49:28,840 --> 00:49:34,060
function name are all going to be

00:49:30,520 --> 00:49:35,980
relative to the main function on line 24

00:49:34,060 --> 00:49:38,410
so you're going to get that information

00:49:35,980 --> 00:49:39,940
about oh yeah I asserted on this in this

00:49:38,410 --> 00:49:43,750
file on this line it was this column

00:49:39,940 --> 00:49:46,119
right so they might you know like

00:49:43,750 --> 00:49:47,859
anybody here worked on like unit testing

00:49:46,119 --> 00:49:52,210
frameworks or things like that that have

00:49:47,859 --> 00:49:54,520
assertion macros yeah so that's that's

00:49:52,210 --> 00:49:57,609
really the the big motivation for this

00:49:54,520 --> 00:49:59,590
is to eliminate those macros right you

00:49:57,609 --> 00:50:03,340
can have real honest-to-god functions

00:49:59,590 --> 00:50:05,140
that do your assertions right we'll see

00:50:03,340 --> 00:50:06,820
if people actually start using this once

00:50:05,140 --> 00:50:12,369
it gets an implemented in a library a

00:50:06,820 --> 00:50:13,869
shipping library okay so some people

00:50:12,369 --> 00:50:15,430
earlier said that they attended the

00:50:13,869 --> 00:50:17,980
context for all the things talking

00:50:15,430 --> 00:50:19,900
yesterday can I get hands again whoo-hoo

00:50:17,980 --> 00:50:23,170
all attended that a few more people

00:50:19,900 --> 00:50:28,060
trickled in afterwards so they talked

00:50:23,170 --> 00:50:30,369
some about a problem right that was

00:50:28,060 --> 00:50:31,099
really really prevalent when c+ 11th

00:50:30,369 --> 00:50:33,079
first ship

00:50:31,099 --> 00:50:36,079
that if you have a function that's

00:50:33,079 --> 00:50:38,450
marked this context / there's no

00:50:36,079 --> 00:50:41,210
guarantee that it will be actually

00:50:38,450 --> 00:50:42,680
evaluated it from Python but there were

00:50:41,210 --> 00:50:45,140
restrictions on the things that you

00:50:42,680 --> 00:50:50,059
could put in there and that led to a lot

00:50:45,140 --> 00:50:52,849
of recursive functions right that's the

00:50:50,059 --> 00:50:54,890
only way to do it in C++ 11 for context

00:50:52,849 --> 00:50:57,069
/ functions but if that function got

00:50:54,890 --> 00:51:00,279
called at runtime

00:50:57,069 --> 00:51:03,289
it may not be the ideal implementation

00:51:00,279 --> 00:51:06,859
for for for that function right it may

00:51:03,289 --> 00:51:09,650
be costly to have all that recursion c

00:51:06,859 --> 00:51:11,720
plus 14 made it a little easier you can

00:51:09,650 --> 00:51:14,900
use more general programming structures

00:51:11,720 --> 00:51:16,849
in a context per function but there's

00:51:14,900 --> 00:51:19,430
still this problem of in a concept for

00:51:16,849 --> 00:51:22,009
function and I want to write code that

00:51:19,430 --> 00:51:25,729
is cognizant of the fact that it's being

00:51:22,009 --> 00:51:28,099
called in a context burg context right

00:51:25,729 --> 00:51:30,470
and they explicitly called this out as a

00:51:28,099 --> 00:51:32,390
problem in the presentation there are

00:51:30,470 --> 00:51:35,809
some there are some standard proposals

00:51:32,390 --> 00:51:37,880
to make that more a part of the language

00:51:35,809 --> 00:51:40,039
so you could tie into that otherwise you

00:51:37,880 --> 00:51:43,190
have to do C matrix and other stuff to

00:51:40,039 --> 00:51:45,410
do it so here's an implementation that

00:51:43,190 --> 00:51:49,460
uses default function arguments it's a

00:51:45,410 --> 00:51:52,219
hack I'll admit it but again it uses the

00:51:49,460 --> 00:51:54,529
fact that something is evaluated at the

00:51:52,219 --> 00:51:56,390
call site which is where the context is

00:51:54,529 --> 00:51:58,999
about we're being called in a constant

00:51:56,390 --> 00:52:03,469
expression right so focus real quick on

00:51:58,999 --> 00:52:06,619
lines 12 through 19 okay so I can call

00:52:03,469 --> 00:52:09,739
function for function FN with a

00:52:06,619 --> 00:52:15,489
parameter for and I can't put that in a

00:52:09,739 --> 00:52:18,200
static assert cuz function with four oh

00:52:15,489 --> 00:52:19,969
yeah I'll get that but that's that's a

00:52:18,200 --> 00:52:21,829
runtime behavior so I can do a runtime

00:52:19,969 --> 00:52:25,279
of search right that's the right

00:52:21,829 --> 00:52:27,619
behavior the way I've structured this is

00:52:25,279 --> 00:52:31,309
you can actually explicitly say no no no

00:52:27,619 --> 00:52:34,069
give me the compile time behavior please

00:52:31,309 --> 00:52:36,319
so if you want the compile time behavior

00:52:34,069 --> 00:52:39,499
and you're in a context burg context you

00:52:36,319 --> 00:52:42,710
can just say no tag compile time right

00:52:39,499 --> 00:52:44,920
so now let's look at the implementation

00:52:42,710 --> 00:52:48,160
of FN so it's a context

00:52:44,920 --> 00:52:50,980
function and it takes a second argument

00:52:48,160 --> 00:52:52,500
which is a tag the default argument

00:52:50,980 --> 00:52:56,950
there is this function called run time

00:52:52,500 --> 00:53:00,310
run time if you look at that is a

00:52:56,950 --> 00:53:02,200
function that is not context per right

00:53:00,310 --> 00:53:06,130
so it can only be evaluated at run time

00:53:02,200 --> 00:53:06,760
which means if I call FN with only one

00:53:06,130 --> 00:53:08,950
parameter

00:53:06,760 --> 00:53:12,970
the second parameter can only be used at

00:53:08,950 --> 00:53:15,700
run time right so that's why I line 14

00:53:12,970 --> 00:53:19,320
fails to compile he's like nope you call

00:53:15,700 --> 00:53:21,850
run time which can't be used here right

00:53:19,320 --> 00:53:24,760
the other thing to note about it is that

00:53:21,850 --> 00:53:27,610
in a context for function you can write

00:53:24,760 --> 00:53:28,600
code that is not context for you know

00:53:27,610 --> 00:53:30,280
you can't call it

00:53:28,600 --> 00:53:33,010
you can't evaluate it in a context for

00:53:30,280 --> 00:53:35,110
context but you can write it as long as

00:53:33,010 --> 00:53:36,730
it doesn't get you know evaluated

00:53:35,110 --> 00:53:42,370
whenever you're doing the context for

00:53:36,730 --> 00:53:44,260
stuff then it's fine right so I have

00:53:42,370 --> 00:53:46,840
identity which is another runtime

00:53:44,260 --> 00:53:49,810
function I so I say if you have been

00:53:46,840 --> 00:53:51,460
told this is runtime behavior just call

00:53:49,810 --> 00:53:54,490
the runtime thing otherwise do the

00:53:51,460 --> 00:53:56,410
compile time thing right so in this time

00:53:54,490 --> 00:53:58,690
what we're doing here really is instead

00:53:56,410 --> 00:53:59,920
of magically determining the context of

00:53:58,690 --> 00:54:02,740
where we're being evaluated we're

00:53:59,920 --> 00:54:04,990
explicitly passing that in right I want

00:54:02,740 --> 00:54:07,750
the compile time behavior please write

00:54:04,990 --> 00:54:09,400
so it's not quite the same but you can

00:54:07,750 --> 00:54:11,800
you know you can emulate this and you

00:54:09,400 --> 00:54:13,570
can get different algorithms you know

00:54:11,800 --> 00:54:15,490
based on whether or not your runtime or

00:54:13,570 --> 00:54:17,260
compiled file you just have to be a

00:54:15,490 --> 00:54:22,450
little bit more explicit about hey I

00:54:17,260 --> 00:54:28,530
mean compile time okay we've got six

00:54:22,450 --> 00:54:28,530
minutes okay so virtual dispatch

00:54:30,480 --> 00:54:34,420
sometimes you might want to say yeah

00:54:33,190 --> 00:54:36,610
yeah yeah this this is the right

00:54:34,420 --> 00:54:38,980
function but I really want to know who

00:54:36,610 --> 00:54:41,460
it what like what type it was that that

00:54:38,980 --> 00:54:47,380
was the source of the call that

00:54:41,460 --> 00:54:50,260
dispatched to me right this is terrible

00:54:47,380 --> 00:54:53,290
but there are reasons you conceivably do

00:54:50,260 --> 00:54:55,480
this it's a little bit small text

00:54:53,290 --> 00:54:58,400
because it's more lines

00:54:55,480 --> 00:54:59,870
but the idea is that all of the types

00:54:58,400 --> 00:55:03,380
that you know about you can provide a

00:54:59,870 --> 00:55:07,250
static context per value and ID make

00:55:03,380 --> 00:55:10,250
them unique right and you can provide

00:55:07,250 --> 00:55:11,450
like a name you know it depends on what

00:55:10,250 --> 00:55:12,740
you're trying to impact you're actually

00:55:11,450 --> 00:55:18,640
trying to implant what you would provide

00:55:12,740 --> 00:55:21,680
there and so what I'm doing here in my

00:55:18,640 --> 00:55:23,210
in my over to the the base is pure

00:55:21,680 --> 00:55:24,140
virtual there's no implementation there

00:55:23,210 --> 00:55:26,650
right

00:55:24,140 --> 00:55:32,300
but in my implemented override I'm

00:55:26,650 --> 00:55:34,250
looking up the name for the ID that I

00:55:32,300 --> 00:55:37,580
was originally called with and the trick

00:55:34,250 --> 00:55:42,200
here is that remember the the default

00:55:37,580 --> 00:55:44,410
argument is evaluated based on what the

00:55:42,200 --> 00:55:48,460
static type was that that made the call

00:55:44,410 --> 00:55:50,960
right so it gets the idea of that type

00:55:48,460 --> 00:55:53,120
right since I've registered these things

00:55:50,960 --> 00:55:55,700
up with some map or something I can now

00:55:53,120 --> 00:55:58,760
look up to see oh it was that type right

00:55:55,700 --> 00:56:03,620
so yeah this works so if I if I created

00:55:58,760 --> 00:56:05,960
derived D and I call F n e printing it's

00:56:03,620 --> 00:56:08,450
derived right yeah yeah derived was the

00:56:05,960 --> 00:56:11,240
type that that called this but if I if I

00:56:08,450 --> 00:56:15,020
get a reference to the base right and I

00:56:11,240 --> 00:56:17,510
now I call the FN from that object from

00:56:15,020 --> 00:56:18,410
that reference I get base because he

00:56:17,510 --> 00:56:20,000
says oh yeah

00:56:18,410 --> 00:56:22,340
the default argument was determined by

00:56:20,000 --> 00:56:23,770
the base by the static type and then I

00:56:22,340 --> 00:56:26,330
can look that up in the implementation

00:56:23,770 --> 00:56:28,130
ok there are all sorts of terrible

00:56:26,330 --> 00:56:30,770
terrible things you could do with this

00:56:28,130 --> 00:56:33,320
trick this is this is probably the one

00:56:30,770 --> 00:56:36,980
that I'm the least certain like if this

00:56:33,320 --> 00:56:38,600
is a good or a bad thing I was thinking

00:56:36,980 --> 00:56:42,050
last night there are ways you could use

00:56:38,600 --> 00:56:45,020
this to solve the virtual problem and

00:56:42,050 --> 00:56:47,990
you have multiple defaults you might be

00:56:45,020 --> 00:56:50,030
able to actually hook in and say no no

00:56:47,990 --> 00:56:51,710
here's all the defaults for the

00:56:50,030 --> 00:56:56,180
different types that might call this

00:56:51,710 --> 00:56:59,180
thing crazy stuff okay we got four

00:56:56,180 --> 00:57:02,750
minutes nominally that's the end of the

00:56:59,180 --> 00:57:08,720
presentation now III did say that if we

00:57:02,750 --> 00:57:09,210
went fast I could do a demo so questions

00:57:08,720 --> 00:57:14,490
or

00:57:09,210 --> 00:57:15,030
real quick demo demo okay let's see if

00:57:14,490 --> 00:57:18,960
it works

00:57:15,030 --> 00:57:21,480
doing live demos are terrible but okay

00:57:18,960 --> 00:57:24,060
so you remember that compile time versus

00:57:21,480 --> 00:57:26,940
run time example right so you might

00:57:24,060 --> 00:57:29,190
think well okay that what would I use

00:57:26,940 --> 00:57:31,950
that for right great

00:57:29,190 --> 00:57:35,250
great you can do that so I came up with

00:57:31,950 --> 00:57:51,540
an idea to use it to provide sort of

00:57:35,250 --> 00:57:53,280
Mach values right so okay so I'm gonna

00:57:51,540 --> 00:57:55,740
have a class this is this is my tag

00:57:53,280 --> 00:57:58,650
class mock that's my tag compile time

00:57:55,740 --> 00:58:00,840
run time right I've got my run time

00:57:58,650 --> 00:58:03,510
function this is no don't do mocking it

00:58:00,840 --> 00:58:06,510
just returns that now I've got this this

00:58:03,510 --> 00:58:09,120
this type file data and he's gonna he's

00:58:06,510 --> 00:58:12,240
gonna keep this mock state thing as a

00:58:09,120 --> 00:58:15,420
member and he's gonna take that in as a

00:58:12,240 --> 00:58:18,660
as an argument on his constructor right

00:58:15,420 --> 00:58:21,180
and the default is gonna be no mock give

00:58:18,660 --> 00:58:24,380
me the real runtime behavior for this

00:58:21,180 --> 00:58:26,820
thing normally right he stores it away

00:58:24,380 --> 00:58:28,880
so then I've got a contact for function

00:58:26,820 --> 00:58:31,800
this is hey give me some numbers right

00:58:28,880 --> 00:58:33,120
and just said normally what it would do

00:58:31,800 --> 00:58:35,460
is it would go it goes and reads from a

00:58:33,120 --> 00:58:37,200
file you know something we run time

00:58:35,460 --> 00:58:40,950
requires runtime behavior right

00:58:37,200 --> 00:58:43,050
ah but if I've said no no no I want I

00:58:40,950 --> 00:58:45,810
want mocked values please don't go do

00:58:43,050 --> 00:58:48,260
that runtime stuff you could you could

00:58:45,810 --> 00:58:51,810
implement your mock behavior right there

00:58:48,260 --> 00:58:54,270
right and then else you know I'm gonna

00:58:51,810 --> 00:58:57,660
go delegate a read and read is gonna go

00:58:54,270 --> 00:59:00,360
to a file and go do the reading right so

00:58:57,660 --> 00:59:02,370
there's delegate read you know so it

00:59:00,360 --> 00:59:03,810
just goes and reads in from this file

00:59:02,370 --> 00:59:09,890
these numbers and put them in the array

00:59:03,810 --> 00:59:09,890
and then there you go okay so

00:59:10,410 --> 00:59:16,830
so the first block 46 to 52 I stand my

00:59:14,130 --> 00:59:19,230
file data with with no parameters so I'm

00:59:16,830 --> 00:59:22,080
especially selecting the runtime real

00:59:19,230 --> 00:59:27,030
behavior right I say get numbers and I

00:59:22,080 --> 00:59:29,220
get those numbers for 54 through 60 I

00:59:27,030 --> 00:59:31,740
say no no give me the mock behavior and

00:59:29,220 --> 00:59:34,170
then you know it's the same function

00:59:31,740 --> 00:59:38,310
call but I get different numbers at and

00:59:34,170 --> 00:59:41,220
I can stack a certain time right because

00:59:38,310 --> 00:59:42,570
the numbers thing is a con cetera so the

00:59:41,220 --> 00:59:45,000
things is just gonna work or he thinks

00:59:42,570 --> 00:59:47,130
is you know just not not really gonna

00:59:45,000 --> 00:59:49,340
work I wouldn't show if it wasn't gonna

00:59:47,130 --> 00:59:51,630
work right session is over

00:59:49,340 --> 00:59:55,770
all right I'm gonna show that I got I

00:59:51,630 --> 00:59:57,900
got one minute for my clock so I have

00:59:55,770 --> 01:00:01,770
this little script that compiles and

00:59:57,900 --> 01:00:07,410
runs things what did I do wrong

01:00:01,770 --> 01:00:10,020
oh I didn't give it a name so it

01:00:07,410 --> 01:00:13,620
compiles it it runs it and all the

01:00:10,020 --> 01:00:15,480
assertions pass right so that's into my

01:00:13,620 --> 01:00:18,000
session if you want to ask me questions

01:00:15,480 --> 01:00:20,910
about anything I would say concrete over

01:00:18,000 --> 01:00:23,070
there we can do it sort of offline and

01:00:20,910 --> 01:00:26,060
thanks for taking my session have fun at

01:00:23,070 --> 01:00:26,060

YouTube URL: https://www.youtube.com/watch?v=NeJ85q1qddQ


