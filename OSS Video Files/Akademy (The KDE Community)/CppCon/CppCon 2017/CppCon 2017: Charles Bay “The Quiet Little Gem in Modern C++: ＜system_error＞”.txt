Title: CppCon 2017: Charles Bay “The Quiet Little Gem in Modern C++: ＜system_error＞”
Publication date: 2017-10-04
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Amongst the loud fanfare of C++11 arrived this quiet little gem of ＜system_error＞, with std::error_code and std::error_condition born from the heart of boost::asio. With Committee input they evolved for inclusion into the C++11 Standard, providing consistent and extensible ways for applications to expose platform-specific error-codes, platform-independent error-conditions, and rely upon an open-ended design that permits future extensibility for message reporting; and even internationalization of logs and user-facing events and conditions. 

More than half a decade later, we most unhappily find that the motivation and intended use model for std::error_code and std::error_condition are still not well understood; even in circles eagerly embracing features and idioms encouraged by the latest C++ Standard revisions. This may be somewhat expected, as all things “error” tend to permeate system-wide design-decisions and influence the processing metaphor; how algorithms compose conditional success-or-failure branching; and create consistency challenges across APIs (both internally, and for interoperation with third-party libraries). 

We discuss the features and design of ＜system_error＞ and its intended use; make recommendations regarding API design; and propose possible extension mechanisms for module-specific concerns, instance-specific messages (with embedded value-reporting), and internationalization. 
— 
Charles Bay: F5 Networks Inc.

Software developer with 25+ years experience in large-scale and distributed systems in performance-sensitive environments including real-time processing, performance visualization, embedded systems, time-sensitive processing of large data sets, hardware status-and-control, and instrument/process/sub-assembly monitoring.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,359
welcome thank you for coming today we're

00:00:03,540 --> 00:00:09,750
talking about System Error it showed up

00:00:06,359 --> 00:00:12,360
in the c++ 2011 it's in our standard

00:00:09,750 --> 00:00:13,799
libraries increasingly so and a lot of

00:00:12,360 --> 00:00:15,360
people are not using it but you're gonna

00:00:13,799 --> 00:00:18,150
see more of it so today we're going to

00:00:15,360 --> 00:00:21,180
talk about that the takeaway is really

00:00:18,150 --> 00:00:22,859
easy using numeration z' you don't have

00:00:21,180 --> 00:00:24,269
to but you should using numeration s--

00:00:22,859 --> 00:00:25,730
and if you do you're good if your users

00:00:24,269 --> 00:00:27,630
you're done you can leave the talks over

00:00:25,730 --> 00:00:30,119
library authors are going to implement

00:00:27,630 --> 00:00:31,470
with the design that's presented we're

00:00:30,119 --> 00:00:33,510
going to talk about the rationalization

00:00:31,470 --> 00:00:36,239
of that design so a little feedback

00:00:33,510 --> 00:00:37,850
you're ready okay okay so here's the

00:00:36,239 --> 00:00:40,469
talk here so we're going to cover

00:00:37,850 --> 00:00:42,390
introduction what is message there's a

00:00:40,469 --> 00:00:44,010
lot of conflating of error codes and

00:00:42,390 --> 00:00:45,960
messages we'll briefly go through that

00:00:44,010 --> 00:00:49,739
we'll talk about system error that

00:00:45,960 --> 00:00:51,030
showed up in C++ 2011 it's being used

00:00:49,739 --> 00:00:53,370
increasingly so with the new libraries

00:00:51,030 --> 00:00:55,110
dropping like in 2017 file system and

00:00:53,370 --> 00:00:56,840
networking TS and then some

00:00:55,110 --> 00:00:58,829
recommendations on this review but

00:00:56,840 --> 00:01:00,510
there's diminishing returns the

00:00:58,829 --> 00:01:01,649
important stuffs up front so if we don't

00:01:00,510 --> 00:01:03,090
get through all of it because there's a

00:01:01,649 --> 00:01:06,570
lot to talk about that swine

00:01:03,090 --> 00:01:09,240
so the disclaimer is these are error

00:01:06,570 --> 00:01:10,950
messages so there is a meme alert I put

00:01:09,240 --> 00:01:12,180
little pictures in the upper corner so

00:01:10,950 --> 00:01:14,070
you wouldn't be bored because

00:01:12,180 --> 00:01:16,409
error messages are annoying nobody likes

00:01:14,070 --> 00:01:17,790
them so this is so you won't be bored

00:01:16,409 --> 00:01:19,229
you have you look at the bunny or

00:01:17,790 --> 00:01:24,509
something while we're talking about the

00:01:19,229 --> 00:01:26,460
boring stuff okay so what we're not

00:01:24,509 --> 00:01:29,549
going to talk about what system err does

00:01:26,460 --> 00:01:31,320
not address their holy wars hacker wars

00:01:29,549 --> 00:01:32,610
there are message wars most of our

00:01:31,320 --> 00:01:35,130
systems especially as the code base is

00:01:32,610 --> 00:01:37,860
evolved there's one two three four

00:01:35,130 --> 00:01:40,530
messaging subsystems in their routing

00:01:37,860 --> 00:01:42,420
this happened I want to do conditional

00:01:40,530 --> 00:01:43,020
branch processing on this scenario that

00:01:42,420 --> 00:01:44,729
occurred

00:01:43,020 --> 00:01:46,439
I somehow forward that back up through

00:01:44,729 --> 00:01:50,280
my API so that the caller can deal with

00:01:46,439 --> 00:01:52,649
it the caller may be echoing to the disk

00:01:50,280 --> 00:01:54,299
maybe pop in a box to the user may be

00:01:52,649 --> 00:01:55,710
writing to a file may be sending

00:01:54,299 --> 00:01:56,939
something to another process maybe

00:01:55,710 --> 00:01:58,950
shutting down

00:01:56,939 --> 00:02:00,570
the core of the reactor doesn't there's

00:01:58,950 --> 00:02:02,549
conditional processing that may occur

00:02:00,570 --> 00:02:04,770
based on that so these messages are

00:02:02,549 --> 00:02:06,960
event notification mechanisms that we

00:02:04,770 --> 00:02:08,910
use to forward back to the user it's a

00:02:06,960 --> 00:02:11,220
way for the implementer to communicate

00:02:08,910 --> 00:02:13,290
with the caller and there's a lot of

00:02:11,220 --> 00:02:15,000
contention on how you do that the

00:02:13,290 --> 00:02:17,970
contention is largely based on how do

00:02:15,000 --> 00:02:20,550
you phrase algorithms compose larger

00:02:17,970 --> 00:02:23,280
systems and do this branch conditional

00:02:20,550 --> 00:02:25,230
processing the error code is just an

00:02:23,280 --> 00:02:27,360
email that's how you should visualize it

00:02:25,230 --> 00:02:30,840
it's a really powerful emiram it's a

00:02:27,360 --> 00:02:32,190
little bit better than him so this is

00:02:30,840 --> 00:02:35,130
some of the stuff that you would ideally

00:02:32,190 --> 00:02:37,290
deal with in composing and phrasing

00:02:35,130 --> 00:02:39,180
higher order algorithms conditional

00:02:37,290 --> 00:02:41,040
branch processing based on a scenario an

00:02:39,180 --> 00:02:45,120
event a circumstance something happened

00:02:41,040 --> 00:02:46,680
and different different code bases

00:02:45,120 --> 00:02:48,360
different environments you have

00:02:46,680 --> 00:02:50,370
different house rules for how people

00:02:48,360 --> 00:02:51,510
want to address these things generally

00:02:50,370 --> 00:02:53,040
we're not going to talk about this today

00:02:51,510 --> 00:02:54,810
we're just talking about a soupery noon

00:02:53,040 --> 00:02:57,150
which is error code and clarity

00:02:54,810 --> 00:02:58,860
constraints correctness you know there's

00:02:57,150 --> 00:03:00,750
a lot of personal taste in how you're

00:02:58,860 --> 00:03:03,299
going to use these things so there's

00:03:00,750 --> 00:03:04,859
minimal infrastructure for API

00:03:03,299 --> 00:03:06,090
implication you're gonna have an error

00:03:04,859 --> 00:03:10,440
code you're gonna pass it around that's

00:03:06,090 --> 00:03:12,299
it so Wars we have a lot of Wars

00:03:10,440 --> 00:03:14,370
there's misunderstanding and conflating

00:03:12,299 --> 00:03:16,470
messages it's this is a really

00:03:14,370 --> 00:03:20,340
overloaded term it's like static is a

00:03:16,470 --> 00:03:22,500
really overloaded thought messages on

00:03:20,340 --> 00:03:24,989
the misunderstanding we're gonna

00:03:22,500 --> 00:03:27,569
conflate stuff I'm gonna give you the

00:03:24,989 --> 00:03:28,980
result of a scenario a message code an

00:03:27,569 --> 00:03:30,660
error code and you're gonna make a

00:03:28,980 --> 00:03:33,930
decision into conditional stuff

00:03:30,660 --> 00:03:35,700
as a result and conflating the branch

00:03:33,930 --> 00:03:38,069
processing and what that error code

00:03:35,700 --> 00:03:39,870
represents is kind of an issue so how we

00:03:38,069 --> 00:03:41,310
compose and how we handle that's

00:03:39,870 --> 00:03:42,480
generally the applicable thing and the

00:03:41,310 --> 00:03:44,310
house rules are going to decide how to

00:03:42,480 --> 00:03:47,040
freeze up larger and larger scale so

00:03:44,310 --> 00:03:49,650
kind of moving on messages errors

00:03:47,040 --> 00:03:51,630
exceptions we have several ways of

00:03:49,650 --> 00:03:54,319
communicating with the caller about

00:03:51,630 --> 00:03:57,630
propagating up the results of a scenario

00:03:54,319 --> 00:04:00,090
so the message it is going to provide

00:03:57,630 --> 00:04:01,650
visibility right we've got there was a

00:04:00,090 --> 00:04:03,510
state change in the system better tell

00:04:01,650 --> 00:04:06,989
somebody and something

00:04:03,510 --> 00:04:08,909
better tell somebody there is this

00:04:06,989 --> 00:04:10,079
failure scenario idea a lot of time

00:04:08,909 --> 00:04:11,340
error code you're thinking there was a

00:04:10,079 --> 00:04:13,049
failure scenario and I got to do

00:04:11,340 --> 00:04:15,780
something in particular to deal with

00:04:13,049 --> 00:04:18,060
that failure well that's a negative test

00:04:15,780 --> 00:04:20,130
sometimes a lot of times most the time

00:04:18,060 --> 00:04:22,229
negative information a negative result

00:04:20,130 --> 00:04:24,419
is actionable so we're gonna propagate

00:04:22,229 --> 00:04:26,400
and inform the caller hey sorry this was

00:04:24,419 --> 00:04:29,210
good that was not good you know you may

00:04:26,400 --> 00:04:32,340
want to do some extra stuff and then

00:04:29,210 --> 00:04:34,500
there is this exception idea and this is

00:04:32,340 --> 00:04:35,760
the you're not you're not returning from

00:04:34,500 --> 00:04:37,440
functions you're not making forward

00:04:35,760 --> 00:04:39,030
progress this is a stack unwind right

00:04:37,440 --> 00:04:41,160
you're going backwards you're under

00:04:39,030 --> 00:04:42,539
winding you're destructing and you're

00:04:41,160 --> 00:04:45,870
gonna hopefully catch it at some point

00:04:42,539 --> 00:04:47,820
and reset so these are going to be the

00:04:45,870 --> 00:04:50,970
ways we're gonna start handling errors

00:04:47,820 --> 00:04:52,350
versus exceptions and and kind of key to

00:04:50,970 --> 00:04:53,639
our mind because error code is about

00:04:52,350 --> 00:04:55,110
composing and phrasing higher-order

00:04:53,639 --> 00:04:57,150
algorithms based on actionable

00:04:55,110 --> 00:04:58,860
information from the communication of

00:04:57,150 --> 00:05:00,660
the implementer I know what's going on

00:04:58,860 --> 00:05:04,590
and I'm telling you the caller here's

00:05:00,660 --> 00:05:06,930
what happened how can foo finish finish

00:05:04,590 --> 00:05:09,930
the results of foo who did something and

00:05:06,930 --> 00:05:11,130
it finishes so well looking complete

00:05:09,930 --> 00:05:13,080
that would be good

00:05:11,130 --> 00:05:14,910
foo executed and there was a return

00:05:13,080 --> 00:05:17,880
maybe return was void maybe with some

00:05:14,910 --> 00:05:20,570
object who knows but success or failure

00:05:17,880 --> 00:05:24,090
presumes the function actually completed

00:05:20,570 --> 00:05:25,770
well it doesn't have to complete you can

00:05:24,090 --> 00:05:27,510
throw an exception right that's a stack

00:05:25,770 --> 00:05:29,460
on one you're gonna go backwards or you

00:05:27,510 --> 00:05:30,840
can just terminate you know so terminate

00:05:29,460 --> 00:05:33,360
or exit or something you just use just

00:05:30,840 --> 00:05:35,160
abort well well now we've got this

00:05:33,360 --> 00:05:36,979
suspend thing coming along right we're

00:05:35,160 --> 00:05:38,370
gonna start playing with with

00:05:36,979 --> 00:05:41,370
co-routines

00:05:38,370 --> 00:05:43,860
and resumable things because it's going

00:05:41,370 --> 00:05:45,870
to be an interesting way to also start

00:05:43,860 --> 00:05:47,520
composing higher-order algorithms and of

00:05:45,870 --> 00:05:48,120
course we still have to communicate back

00:05:47,520 --> 00:05:49,650
to the caller

00:05:48,120 --> 00:05:51,570
things are good things were not good

00:05:49,650 --> 00:05:52,919
here's your conditional here's your

00:05:51,570 --> 00:05:55,860
information from which you can do your

00:05:52,919 --> 00:05:58,020
conditional branch logic so we are a

00:05:55,860 --> 00:05:59,639
very rich environment more so than most

00:05:58,020 --> 00:06:02,550
languages because of our ability to

00:05:59,639 --> 00:06:03,330
compose error code is just a super inu

00:06:02,550 --> 00:06:07,520
that's it

00:06:03,330 --> 00:06:10,500
so operation complete success or failure

00:06:07,520 --> 00:06:12,090
suspends we've got that and then it does

00:06:10,500 --> 00:06:13,770
not complete this is summary what we

00:06:12,090 --> 00:06:15,419
just saw before and all of those are

00:06:13,770 --> 00:06:15,900
legitimate ways for a function to finish

00:06:15,419 --> 00:06:17,280
and for

00:06:15,900 --> 00:06:18,780
to communicate back to the caller in

00:06:17,280 --> 00:06:20,820
error code or some sort of information

00:06:18,780 --> 00:06:22,229
about we're good we're not good this

00:06:20,820 --> 00:06:25,830
happened go ahead and conditionally

00:06:22,229 --> 00:06:27,449
branch so error message you know it's

00:06:25,830 --> 00:06:29,220
air code a lot of times there's an

00:06:27,449 --> 00:06:30,690
Associated message with that the

00:06:29,220 --> 00:06:32,940
caller's gonna do something based on

00:06:30,690 --> 00:06:34,530
that and this is one of the things you

00:06:32,940 --> 00:06:36,180
can do if you don't want to use error

00:06:34,530 --> 00:06:38,460
code this is done a lot it's

00:06:36,180 --> 00:06:40,560
surprisingly useful we're gonna call a

00:06:38,460 --> 00:06:41,639
function it's gonna return a string well

00:06:40,560 --> 00:06:43,259
what's in the string I don't know

00:06:41,639 --> 00:06:44,430
there's stuff in the string you want to

00:06:43,259 --> 00:06:46,800
know what happened you parse the string

00:06:44,430 --> 00:06:49,169
maybe if there's like the word error

00:06:46,800 --> 00:06:50,880
maybe it was an error and that's a very

00:06:49,169 --> 00:06:52,770
open-ended design so a lot of the higher

00:06:50,880 --> 00:06:54,300
order languages will do that it guys

00:06:52,770 --> 00:06:56,400
that are unplanned will do that it

00:06:54,300 --> 00:06:58,139
allows me to not establish enumerated

00:06:56,400 --> 00:06:59,910
results up front I can just kind of wing

00:06:58,139 --> 00:07:01,830
it as I go and add stuff now it's not

00:06:59,910 --> 00:07:03,750
particularly well documented but if you

00:07:01,830 --> 00:07:05,970
follow conventions like the word error

00:07:03,750 --> 00:07:07,440
means something bad and somebody does a

00:07:05,970 --> 00:07:08,820
reg X on the screen and see the word

00:07:07,440 --> 00:07:09,960
here and they know that tener this

00:07:08,820 --> 00:07:12,389
actually works pretty well there's

00:07:09,960 --> 00:07:14,310
surprisingly useful even though there's

00:07:12,389 --> 00:07:16,650
no type safety here at all and it's hard

00:07:14,310 --> 00:07:19,440
to document it's hard to maintain but

00:07:16,650 --> 00:07:21,090
it's surprisingly useful how big systems

00:07:19,440 --> 00:07:23,490
are built based on just returning a

00:07:21,090 --> 00:07:25,410
string no enumerating state no enumerate

00:07:23,490 --> 00:07:27,180
branch condition processing but you pick

00:07:25,410 --> 00:07:29,130
up a live you see some strings you start

00:07:27,180 --> 00:07:32,070
handling and it tends to work it tends

00:07:29,130 --> 00:07:33,510
to scale at some level so those are

00:07:32,070 --> 00:07:35,639
examples that you could use if you don't

00:07:33,510 --> 00:07:39,300
use their code that's fine so we'll go

00:07:35,639 --> 00:07:41,070
down messaging and logging logging is a

00:07:39,300 --> 00:07:41,880
big issue and aerco does not help you

00:07:41,070 --> 00:07:43,770
with that at all

00:07:41,880 --> 00:07:45,599
there are frameworks there are many

00:07:43,770 --> 00:07:47,400
frameworks there's syslog there's a lot

00:07:45,599 --> 00:07:49,650
of in-house develop stuff and most

00:07:47,400 --> 00:07:52,169
systems of size most code bases of size

00:07:49,650 --> 00:07:53,970
there's several e these in their several

00:07:52,169 --> 00:07:55,260
messaging and logging systems it just

00:07:53,970 --> 00:07:56,970
tends to work that way because the

00:07:55,260 --> 00:07:59,430
constraints of the latency of the

00:07:56,970 --> 00:08:01,110
notification or the the path by which

00:07:59,430 --> 00:08:04,289
you route information back to the

00:08:01,110 --> 00:08:05,820
interested party so I know a lot of

00:08:04,289 --> 00:08:07,260
people don't like error codes and

00:08:05,820 --> 00:08:09,990
messages because they're frustrating and

00:08:07,260 --> 00:08:11,550
annoying and well we all kind of admit

00:08:09,990 --> 00:08:12,810
we need logging though because we have

00:08:11,550 --> 00:08:14,370
to suffer the systems that aren't

00:08:12,810 --> 00:08:16,320
behaving properly and figure out what

00:08:14,370 --> 00:08:18,479
happened what's going on so this is kind

00:08:16,320 --> 00:08:20,430
of the scale we're working at so logging

00:08:18,479 --> 00:08:22,530
is necessary and kind of do that you

00:08:20,430 --> 00:08:25,620
know bigball their logging is helpful

00:08:22,530 --> 00:08:27,210
logging is disallowed and there are very

00:08:25,620 --> 00:08:29,190
few systems where logging is this loud

00:08:27,210 --> 00:08:31,110
they exist they mostly exist

00:08:29,190 --> 00:08:32,460
you know 10 20 years ago because not

00:08:31,110 --> 00:08:35,159
even your vacuum cleaner there's a full

00:08:32,460 --> 00:08:37,409
tcpi stack in it you can talk to it but

00:08:35,159 --> 00:08:39,659
there are a few systems where you can't

00:08:37,409 --> 00:08:41,039
do disel do logging at all but the scale

00:08:39,659 --> 00:08:44,039
we've seen this scale before the scale

00:08:41,039 --> 00:08:46,350
is this there's a son logging as helpful

00:08:44,039 --> 00:08:49,350
as Earth and the hundred thousand dollar

00:08:46,350 --> 00:08:52,860
tool bag dropped by an astronaut back in

00:08:49,350 --> 00:08:54,990
2008 that's that's the very end case

00:08:52,860 --> 00:08:57,990
we're logging is really not allowed or

00:08:54,990 --> 00:08:59,130
not possible or not not going to solve

00:08:57,990 --> 00:09:00,960
what you need on the system

00:08:59,130 --> 00:09:02,130
so definition of terms we'll go through

00:09:00,960 --> 00:09:04,320
this really quickly because it is

00:09:02,130 --> 00:09:06,330
intuitive here you know this stuff so

00:09:04,320 --> 00:09:08,460
there are message frameworks there are

00:09:06,330 --> 00:09:11,700
tracing frameworks there's there's a lot

00:09:08,460 --> 00:09:14,550
of overloading of the use of terms in

00:09:11,700 --> 00:09:16,500
this messaging space so you know you've

00:09:14,550 --> 00:09:18,750
got that messaging across object

00:09:16,500 --> 00:09:20,700
boundaries like you know the old small

00:09:18,750 --> 00:09:23,730
talk thing and you've gotten messaging

00:09:20,700 --> 00:09:26,130
across CPUs and we have so many ways to

00:09:23,730 --> 00:09:27,720
talk about messaging and system error is

00:09:26,130 --> 00:09:30,240
just any numeration it's just a way for

00:09:27,720 --> 00:09:31,730
the implementer to say look I have these

00:09:30,240 --> 00:09:34,320
scenarios and I've communicated

00:09:31,730 --> 00:09:35,520
discreetly the scenario to the user so

00:09:34,320 --> 00:09:37,860
the user can do conditional processing

00:09:35,520 --> 00:09:40,260
initial handling based on this very

00:09:37,860 --> 00:09:43,080
specific scenario that I encountered

00:09:40,260 --> 00:09:45,030
when running your request so this is

00:09:43,080 --> 00:09:47,010
just kind of arm waving stuff and that

00:09:45,030 --> 00:09:48,510
has nothing to do with system error so

00:09:47,010 --> 00:09:49,770
here's more system error messaging

00:09:48,510 --> 00:09:51,210
framework and whether or not you're

00:09:49,770 --> 00:09:53,340
using syslog whether or not you pop up

00:09:51,210 --> 00:09:56,280
dialog boxes has nothing to do with

00:09:53,340 --> 00:09:57,660
system error we're going to merely talk

00:09:56,280 --> 00:09:59,340
about a soup rhenium that can pass

00:09:57,660 --> 00:10:02,250
around through our code that's about it

00:09:59,340 --> 00:10:03,390
and it's up to somebody else to decide

00:10:02,250 --> 00:10:06,870
whether or not to pull in your own

00:10:03,390 --> 00:10:09,390
framework so you can do branch logic on

00:10:06,870 --> 00:10:11,100
it you can do very discreet handling of

00:10:09,390 --> 00:10:13,080
specific scenarios you can have

00:10:11,100 --> 00:10:15,270
information payloads in there but

00:10:13,080 --> 00:10:17,160
generally you'll have to add that on top

00:10:15,270 --> 00:10:19,500
but the framework itself is something

00:10:17,160 --> 00:10:21,450
you bring external system error okay it

00:10:19,500 --> 00:10:23,010
is a mechanism what is it system error

00:10:21,450 --> 00:10:24,270
it's a little header really a little

00:10:23,010 --> 00:10:26,250
header there's a class in there called

00:10:24,270 --> 00:10:29,880
system error so you know okay well the

00:10:26,250 --> 00:10:32,490
system error class you will see and that

00:10:29,880 --> 00:10:34,230
mechanism will have an enum payload that

00:10:32,490 --> 00:10:35,460
you're gonna receive and test against

00:10:34,230 --> 00:10:37,080
that's it if you're a library

00:10:35,460 --> 00:10:39,150
implementer you're gonna define the

00:10:37,080 --> 00:10:41,130
streets set you'll you'll populate this

00:10:39,150 --> 00:10:42,180
error thing that you give back to the

00:10:41,130 --> 00:10:44,430
users

00:10:42,180 --> 00:10:47,750
it's a single event message definition

00:10:44,430 --> 00:10:51,240
or incidence and go down

00:10:47,750 --> 00:10:52,050
that's terms for today event I'm just

00:10:51,240 --> 00:10:53,370
gonna kind of skip through this

00:10:52,050 --> 00:10:56,070
essentially bring your own flame

00:10:53,370 --> 00:10:58,760
framework system error isn't that it's

00:10:56,070 --> 00:11:00,839
an Inu that's it if there's nothing else

00:10:58,760 --> 00:11:02,550
there's gonna be a lot of stuff in the

00:11:00,839 --> 00:11:03,750
slides especially at the end that that

00:11:02,550 --> 00:11:05,430
you know you take the slides and play

00:11:03,750 --> 00:11:07,230
with them and review them but the

00:11:05,430 --> 00:11:09,960
diminishing returns is up front

00:11:07,230 --> 00:11:11,460
it's an Inu think of it as an enum we're

00:11:09,960 --> 00:11:13,350
passing around in populating a news

00:11:11,460 --> 00:11:15,779
library developers there's some tricks

00:11:13,350 --> 00:11:17,010
on implementing the super Inu but users

00:11:15,779 --> 00:11:20,160
don't have to know anything more than

00:11:17,010 --> 00:11:22,230
using a new this is why system air did

00:11:20,160 --> 00:11:24,570
not even try to take on the framework

00:11:22,230 --> 00:11:26,910
thing it's hard to build a message

00:11:24,570 --> 00:11:28,589
framework so you know in this case we've

00:11:26,910 --> 00:11:30,570
got a lot of quadrants generally real

00:11:28,589 --> 00:11:32,730
we're talking about what is the volume

00:11:30,570 --> 00:11:35,160
of information produced and what are my

00:11:32,730 --> 00:11:36,870
requirements on being able to handle

00:11:35,160 --> 00:11:39,060
that at what latency so the speed and

00:11:36,870 --> 00:11:41,160
volume kind of thing and and there's

00:11:39,060 --> 00:11:42,930
kind of a scattered need across the

00:11:41,160 --> 00:11:44,940
universe of where you might be in

00:11:42,930 --> 00:11:47,010
handling certain types of messages in a

00:11:44,940 --> 00:11:48,690
lot of cases of course you don't have

00:11:47,010 --> 00:11:51,330
the same requirements for all error

00:11:48,690 --> 00:11:53,550
paths some stuff is the hot path and you

00:11:51,330 --> 00:11:55,380
have specific requirements some stuff is

00:11:53,550 --> 00:11:57,630
in user time you don't care you've got

00:11:55,380 --> 00:11:59,190
all the time in the world so you might

00:11:57,630 --> 00:12:00,839
end up with multiple frameworks and we

00:11:59,190 --> 00:12:02,880
do most of our systems have multiple

00:12:00,839 --> 00:12:04,290
frameworks because that's a hard problem

00:12:02,880 --> 00:12:06,330
system error does not help you with that

00:12:04,290 --> 00:12:08,310
at all it's an enum so this is an

00:12:06,330 --> 00:12:10,170
example of contrasting in one product

00:12:08,310 --> 00:12:11,550
and network appliance perhaps the data

00:12:10,170 --> 00:12:14,220
plane from the control plane their

00:12:11,550 --> 00:12:16,709
different requirements for latency and

00:12:14,220 --> 00:12:19,050
volume of information and the framework

00:12:16,709 --> 00:12:20,880
has to deal with this system error does

00:12:19,050 --> 00:12:22,860
not do this you bring that yourself

00:12:20,880 --> 00:12:25,290
it's just Amer is any new so well

00:12:22,860 --> 00:12:27,240
getting specifically to what it is but

00:12:25,290 --> 00:12:29,100
this is what we have a lot of people are

00:12:27,240 --> 00:12:32,100
familiar with now but let's just just go

00:12:29,100 --> 00:12:33,209
through an example what if what if I

00:12:32,100 --> 00:12:36,000
want to say well you know there's

00:12:33,209 --> 00:12:38,190
there's this there's this concept of a

00:12:36,000 --> 00:12:40,440
message that I want to do a message

00:12:38,190 --> 00:12:41,820
definition so somewhere out there you

00:12:40,440 --> 00:12:44,700
know you can put it maybe in a header

00:12:41,820 --> 00:12:46,170
and call it 6l and and you maybe you can

00:12:44,700 --> 00:12:47,880
put some kind of definition in an

00:12:46,170 --> 00:12:50,160
implementation file somewhere else and

00:12:47,880 --> 00:12:52,829
you wanted to find what a segmentation

00:12:50,160 --> 00:12:54,089
fault message would look like it might

00:12:52,829 --> 00:12:55,589
look something like this now

00:12:54,089 --> 00:12:57,059
this is this is a little bit hard to

00:12:55,589 --> 00:12:58,829
read that's not the point the point is

00:12:57,059 --> 00:13:00,449
somebody defined that message ahead of

00:12:58,829 --> 00:13:02,610
time they said look this is a scenario

00:13:00,449 --> 00:13:04,800
that may occur I'm defining that and and

00:13:02,610 --> 00:13:08,370
this happens to be some code that you

00:13:04,800 --> 00:13:10,649
may see there is the point at which the

00:13:08,370 --> 00:13:12,899
notification occurs the event happened

00:13:10,649 --> 00:13:14,550
so up above we just defined it hey this

00:13:12,899 --> 00:13:17,370
may occur it's scenario I handled in my

00:13:14,550 --> 00:13:20,459
code but the event notifications the

00:13:17,370 --> 00:13:22,620
idea that I actually encountered that

00:13:20,459 --> 00:13:25,350
scenario I encountered that condition

00:13:22,620 --> 00:13:26,970
this message could be created and handed

00:13:25,350 --> 00:13:28,949
back to someone to handle this

00:13:26,970 --> 00:13:31,439
particular case the message echoed this

00:13:28,949 --> 00:13:33,209
system out or you know standard out or

00:13:31,439 --> 00:13:34,769
standard error or wherever it came in

00:13:33,209 --> 00:13:36,959
from the console and you'll notice that

00:13:34,769 --> 00:13:39,899
the string down below signification

00:13:36,959 --> 00:13:41,850
fault is suspiciously similar to that

00:13:39,899 --> 00:13:43,829
string up above that was defined in that

00:13:41,850 --> 00:13:45,839
implementation file so somebody had to

00:13:43,829 --> 00:13:47,819
find these things some had a priori

00:13:45,839 --> 00:13:49,410
knowledge of this cannot listen Aereo

00:13:47,819 --> 00:13:54,569
this condition is something that may

00:13:49,410 --> 00:13:57,269
occur so we can do various tooling to

00:13:54,569 --> 00:13:59,220
maybe decorate this thing up so in a lot

00:13:57,269 --> 00:14:02,189
of cases in this case we have running

00:13:59,220 --> 00:14:05,309
with what is it bell ground okay so you

00:14:02,189 --> 00:14:07,230
might have instance specific timestamps

00:14:05,309 --> 00:14:10,019
or key value pairs if you're doing

00:14:07,230 --> 00:14:12,779
structured logging or instance specific

00:14:10,019 --> 00:14:14,429
additional context additional state that

00:14:12,779 --> 00:14:15,929
kind of carries along with that message

00:14:14,429 --> 00:14:17,819
there might be useful to the caller to

00:14:15,929 --> 00:14:19,499
the user eventually so that's that's

00:14:17,819 --> 00:14:21,959
ultimately what's going on living there

00:14:19,499 --> 00:14:25,740
system error basically is about defining

00:14:21,959 --> 00:14:27,839
a super enum and this additional context

00:14:25,740 --> 00:14:29,759
may carry with it in a real world event

00:14:27,839 --> 00:14:31,350
notification scenario to help with

00:14:29,759 --> 00:14:33,269
conditional context and branch

00:14:31,350 --> 00:14:36,089
processing and logic for the caller but

00:14:33,269 --> 00:14:38,249
this is the contrast between I defined a

00:14:36,089 --> 00:14:40,439
message that may someday occur the

00:14:38,249 --> 00:14:43,559
message actually occurred system era

00:14:40,439 --> 00:14:47,129
that's what it does it does this okay so

00:14:43,559 --> 00:14:48,809
for today you know event notification

00:14:47,129 --> 00:14:50,670
it's kind of like system error is an

00:14:48,809 --> 00:14:53,550
event hey look there you go maybe it was

00:14:50,670 --> 00:14:56,759
good maybe it was bad it has no judgment

00:14:53,550 --> 00:14:58,800
on you or or the implementer system

00:14:56,759 --> 00:15:01,230
errors just this neutral payload saying

00:14:58,800 --> 00:15:03,299
back the scenario occurred so your

00:15:01,230 --> 00:15:05,819
framework go bring that yourself but the

00:15:03,299 --> 00:15:06,360
idea of event notification the idea of

00:15:05,819 --> 00:15:08,190
giving you

00:15:06,360 --> 00:15:09,990
an instance that you may choose to log

00:15:08,190 --> 00:15:12,450
or carry forward or pass on some other

00:15:09,990 --> 00:15:13,800
process system airs kind of built so

00:15:12,450 --> 00:15:18,000
that you can carry it through your api's

00:15:13,800 --> 00:15:21,600
okay so air codes and messages what are

00:15:18,000 --> 00:15:23,459
they okay a message that's you know

00:15:21,600 --> 00:15:24,899
segmentation fault it's it's typically

00:15:23,459 --> 00:15:26,940
human readable doesn't have to be it

00:15:24,899 --> 00:15:28,730
could be a machine interface and it's

00:15:26,940 --> 00:15:31,890
going to be some kind of a descriptive

00:15:28,730 --> 00:15:34,740
string maybe there's instance specific

00:15:31,890 --> 00:15:37,800
State tied to it that sort of a carrier

00:15:34,740 --> 00:15:39,690
saying this occurred tied to this

00:15:37,800 --> 00:15:41,279
enumerated value it's enumerated

00:15:39,690 --> 00:15:43,200
discrete scenario that we had a prior

00:15:41,279 --> 00:15:44,370
knowledge of establishing and then we

00:15:43,200 --> 00:15:45,540
forward it back to the user and they

00:15:44,370 --> 00:15:47,640
were expecting it because they read a

00:15:45,540 --> 00:15:50,250
documentation saying this function may

00:15:47,640 --> 00:15:52,140
cause these immune errors to be returned

00:15:50,250 --> 00:15:55,050
to you and then you would say oh no I

00:15:52,140 --> 00:15:56,550
knew I need to handle them so system

00:15:55,050 --> 00:15:59,250
error that's it that's that's what it

00:15:56,550 --> 00:16:00,570
does so a message is a notification of a

00:15:59,250 --> 00:16:04,740
condition or state change that's

00:16:00,570 --> 00:16:06,029
typically why we're messaging and you

00:16:04,740 --> 00:16:08,370
know what's what's a little interesting

00:16:06,029 --> 00:16:10,050
is message identifier this kind of one

00:16:08,370 --> 00:16:11,730
of those holy war things and you know

00:16:10,050 --> 00:16:13,410
some some of the tools are really good

00:16:11,730 --> 00:16:15,839
about you know they'll they'll have a

00:16:13,410 --> 00:16:19,050
unique identifier for every possible

00:16:15,839 --> 00:16:21,060
message and some won't do that and if

00:16:19,050 --> 00:16:22,500
you have a unique identifier well that's

00:16:21,060 --> 00:16:24,000
good because you can you know type it

00:16:22,500 --> 00:16:25,800
into a web search and find out what's

00:16:24,000 --> 00:16:27,930
going on if you don't have that the

00:16:25,800 --> 00:16:29,910
whole message implicitly becomes the

00:16:27,930 --> 00:16:31,500
identifier and it's surprisingly useful

00:16:29,910 --> 00:16:33,269
that you can do it like that you can

00:16:31,500 --> 00:16:35,430
have a message identifier which is the

00:16:33,269 --> 00:16:37,740
whole message string here's a message

00:16:35,430 --> 00:16:39,630
string so I want the output to be that

00:16:37,740 --> 00:16:42,209
that err comma value must be between one

00:16:39,630 --> 00:16:44,339
and twenty that's what I want the

00:16:42,209 --> 00:16:47,760
message to be well there are lot of ways

00:16:44,339 --> 00:16:49,500
that I can type code to get that now now

00:16:47,760 --> 00:16:51,360
the first byte you know first

00:16:49,500 --> 00:16:52,500
approximation I'll just hard code every

00:16:51,360 --> 00:16:55,079
time and then BOOM

00:16:52,500 --> 00:16:57,720
that's my message how hard is that well

00:16:55,079 --> 00:16:59,579
I don't have to do that because you know

00:16:57,720 --> 00:17:02,010
if I have like a min/max

00:16:59,579 --> 00:17:03,149
bound thing you know if sometimes you

00:17:02,010 --> 00:17:04,679
don't want to hard code that you would

00:17:03,149 --> 00:17:06,390
like that to be more conditional or

00:17:04,679 --> 00:17:09,480
situational so I'd like a more reusable

00:17:06,390 --> 00:17:12,089
message I'm gonna lift out some you know

00:17:09,480 --> 00:17:13,949
local context for min Max and I'm gonna

00:17:12,089 --> 00:17:16,890
serialize out this so we're gonna

00:17:13,949 --> 00:17:19,620
assemble the string on the fly well okay

00:17:16,890 --> 00:17:21,870
well printf will do that

00:17:19,620 --> 00:17:24,510
so I could now pull the string out fully

00:17:21,870 --> 00:17:26,550
and instead of having the B stream

00:17:24,510 --> 00:17:28,620
serialization which when you have big

00:17:26,550 --> 00:17:31,740
messages the stream serialization gets

00:17:28,620 --> 00:17:34,440
really unwieldy which is why Python went

00:17:31,740 --> 00:17:35,040
to the next one oh well actually one

00:17:34,440 --> 00:17:37,740
after that

00:17:35,040 --> 00:17:39,510
from printf to F printf we're changing

00:17:37,740 --> 00:17:41,610
our target this is where the user is

00:17:39,510 --> 00:17:43,050
making a decision on destination now the

00:17:41,610 --> 00:17:45,600
other ones the decision was sort of

00:17:43,050 --> 00:17:47,309
implied on destination now the user is

00:17:45,600 --> 00:17:49,230
deciding or the implementer the guy

00:17:47,309 --> 00:17:51,030
writing this algorithm is deciding the

00:17:49,230 --> 00:17:52,230
destination so we're talking about what

00:17:51,030 --> 00:17:54,720
kind of power are we giving the

00:17:52,230 --> 00:17:57,570
implementer in employing this message

00:17:54,720 --> 00:18:00,320
and then this is kind of the Python II

00:17:57,570 --> 00:18:03,120
thing where they're lifting out these

00:18:00,320 --> 00:18:04,950
formatting strings and then we'll have

00:18:03,120 --> 00:18:06,360
the context like min Max or other

00:18:04,950 --> 00:18:07,710
conditional information that we might

00:18:06,360 --> 00:18:09,270
want to drop in there

00:18:07,710 --> 00:18:10,710
I mean you build higher order things

00:18:09,270 --> 00:18:13,710
with structured logging and other stuff

00:18:10,710 --> 00:18:16,260
so this is all giving us ultimately that

00:18:13,710 --> 00:18:17,850
same output string here's another one

00:18:16,260 --> 00:18:20,940
now now this is interesting these last

00:18:17,850 --> 00:18:22,410
couple so so the other message is we

00:18:20,940 --> 00:18:24,570
were sort of implying these are your

00:18:22,410 --> 00:18:27,120
strings going out and now we're starting

00:18:24,570 --> 00:18:28,770
to establish categories or classes of

00:18:27,120 --> 00:18:30,450
errors right there's that there's a

00:18:28,770 --> 00:18:32,280
whole family of errors there's a whole

00:18:30,450 --> 00:18:34,170
family of warnings or a whole family of

00:18:32,280 --> 00:18:36,120
the informational things or maybe debug

00:18:34,170 --> 00:18:37,620
things or verbose things or trace things

00:18:36,120 --> 00:18:39,990
you can have as many categories as you

00:18:37,620 --> 00:18:42,030
want we're starting to apply categorical

00:18:39,990 --> 00:18:44,790
information through this string so

00:18:42,030 --> 00:18:46,530
that's interesting because now we're

00:18:44,790 --> 00:18:48,600
giving the author of this code the

00:18:46,530 --> 00:18:50,520
ability to say well look you can find

00:18:48,600 --> 00:18:52,559
min and Max and you can define the

00:18:50,520 --> 00:18:53,820
format string and maybe you can define

00:18:52,559 --> 00:18:54,960
the destination or maybe you can define

00:18:53,820 --> 00:18:56,370
the category and I'll pick the

00:18:54,960 --> 00:18:57,870
destination in the library or in the

00:18:56,370 --> 00:19:00,059
framework system error is not the

00:18:57,870 --> 00:19:02,130
framework but these are the attributes

00:19:00,059 --> 00:19:04,260
that we want to start applying to this

00:19:02,130 --> 00:19:06,150
thing where well that happened what

00:19:04,260 --> 00:19:08,550
happened config didn't load what

00:19:06,150 --> 00:19:10,260
happened the user file name was bogus it

00:19:08,550 --> 00:19:12,720
wasn't on disk it was the wrong format

00:19:10,260 --> 00:19:16,110
there there's a scenario and we're

00:19:12,720 --> 00:19:18,030
starting to add context external to what

00:19:16,110 --> 00:19:19,679
that thing means and the contents it's

00:19:18,030 --> 00:19:23,220
not the same across cookies sometimes it

00:19:19,679 --> 00:19:24,870
is sometimes it's not so and then here's

00:19:23,220 --> 00:19:27,330
another one now this last one is

00:19:24,870 --> 00:19:29,820
interesting because what we've done is

00:19:27,330 --> 00:19:32,470
we've removed from the programmer the

00:19:29,820 --> 00:19:35,440
ability to make bad

00:19:32,470 --> 00:19:37,809
spelling mistakes now there is this

00:19:35,440 --> 00:19:40,780
enumeration now in this like this error

00:19:37,809 --> 00:19:42,850
valid of range thing so I'll let you and

00:19:40,780 --> 00:19:45,340
your context to establish min max bounds

00:19:42,850 --> 00:19:46,960
I'll let you pet Nino but you don't

00:19:45,340 --> 00:19:48,549
finding and you're just picking the m

00:19:46,960 --> 00:19:51,039
and you know what you can't insert

00:19:48,549 --> 00:19:52,539
profane words and error messages is that

00:19:51,039 --> 00:19:53,980
have you never grep your code for

00:19:52,539 --> 00:19:55,480
profane words that might show up in

00:19:53,980 --> 00:19:56,770
front of the user apparently there are

00:19:55,480 --> 00:19:59,620
bases that will do that there are

00:19:56,770 --> 00:20:02,110
stories many so this bottom one that

00:19:59,620 --> 00:20:06,120
looks a lot like what system error is

00:20:02,110 --> 00:20:09,940
gonna do it's gonna be like this okay so

00:20:06,120 --> 00:20:11,980
we want to empower the developer well a

00:20:09,940 --> 00:20:13,659
lot of times we don't want to empower

00:20:11,980 --> 00:20:14,260
the developer the developer doesn't want

00:20:13,659 --> 00:20:17,799
to form

00:20:14,260 --> 00:20:19,809
well phrase well spelled expressions of

00:20:17,799 --> 00:20:22,000
tax that go in front of the users eyes

00:20:19,809 --> 00:20:24,700
sometimes yes well we don't have to so

00:20:22,000 --> 00:20:26,799
in these top examples here we are giving

00:20:24,700 --> 00:20:29,110
you the first one infinite power type

00:20:26,799 --> 00:20:30,970
whatever you want go nuts and and you

00:20:29,110 --> 00:20:32,980
know hopefully there's a review you know

00:20:30,970 --> 00:20:35,080
by other developers but the top one you

00:20:32,980 --> 00:20:37,000
have infinite power and as we go down

00:20:35,080 --> 00:20:38,679
we're going to start changing the power

00:20:37,000 --> 00:20:40,900
you have to pick your destination or

00:20:38,679 --> 00:20:42,010
pick your error category or it's kind of

00:20:40,900 --> 00:20:43,600
your other stuff but this is kind of

00:20:42,010 --> 00:20:45,940
some things really to do you know you

00:20:43,600 --> 00:20:48,309
can pick your level yeah well for you

00:20:45,940 --> 00:20:49,720
opening that file was a warning look I

00:20:48,309 --> 00:20:51,610
was looking for defaults I didn't find

00:20:49,720 --> 00:20:53,169
it for me it's an error if I don't have

00:20:51,610 --> 00:20:55,929
the if I don't have a configuration I

00:20:53,169 --> 00:20:58,990
can't I can't boot the hardware so it's

00:20:55,929 --> 00:21:01,270
possible the attribute of the category

00:20:58,990 --> 00:21:04,179
the classification of errors that's tied

00:21:01,270 --> 00:21:05,890
to the circumstance or it's tied to the

00:21:04,179 --> 00:21:08,169
message could be either one a lot of

00:21:05,890 --> 00:21:11,700
times a lot of times you'll go one way

00:21:08,169 --> 00:21:14,650
in one theory in one way or the other so

00:21:11,700 --> 00:21:18,520
those are overrides these are kind of

00:21:14,650 --> 00:21:20,470
some of the examples and the key point

00:21:18,520 --> 00:21:23,559
on the bottom one is look at what the

00:21:20,470 --> 00:21:25,690
developer is allowed to do the developer

00:21:23,559 --> 00:21:28,299
is not allowed to misspelled words is

00:21:25,690 --> 00:21:30,760
not allowed to define a badly phrased

00:21:28,299 --> 00:21:33,610
confusing ambiguous statement somebody

00:21:30,760 --> 00:21:35,620
had to do that but the person handling

00:21:33,610 --> 00:21:38,100
this scenario and the code is not all

00:21:35,620 --> 00:21:40,570
they're allowed to do is in this case is

00:21:38,100 --> 00:21:42,250
establishment max and pick any name and

00:21:40,570 --> 00:21:43,450
if you picked the wrong one well you

00:21:42,250 --> 00:21:45,520
know ideally there would be a check for

00:21:43,450 --> 00:21:47,860
that but you actually have to pick an

00:21:45,520 --> 00:21:49,900
won't compile right we're picking up an

00:21:47,860 --> 00:21:52,600
enumerated value from somewhere Italy

00:21:49,900 --> 00:21:53,950
Italy the compiled or not so this is a

00:21:52,600 --> 00:21:57,430
maintenance point and we've given the

00:21:53,950 --> 00:21:59,110
developer minimal minimal ability to

00:21:57,430 --> 00:22:00,100
override with this kind of thing and

00:21:59,110 --> 00:22:01,570
whether or not you want to break out the

00:22:00,100 --> 00:22:03,400
classification the category of error or

00:22:01,570 --> 00:22:05,230
not that would be a personal choice

00:22:03,400 --> 00:22:07,110
system we're done care system error is

00:22:05,230 --> 00:22:10,600
gonna give you the bottom one

00:22:07,110 --> 00:22:13,000
okay so invoking a message something

00:22:10,600 --> 00:22:15,400
happened I want to tell someone okay

00:22:13,000 --> 00:22:18,460
identify and provide field values now

00:22:15,400 --> 00:22:20,080
system error is it stands is not really

00:22:18,460 --> 00:22:22,750
good at giving you payload instance

00:22:20,080 --> 00:22:24,220
specific state this happened I couldn't

00:22:22,750 --> 00:22:26,050
open the file well what file well I

00:22:24,220 --> 00:22:27,250
don't know that's that's not system

00:22:26,050 --> 00:22:30,520
mayor's job in its current incarnation

00:22:27,250 --> 00:22:32,320
so people typically put a hash or key

00:22:30,520 --> 00:22:34,240
value set or something like on that and

00:22:32,320 --> 00:22:35,950
that there's a whole world of structured

00:22:34,240 --> 00:22:37,330
logging to deal with State and stuff

00:22:35,950 --> 00:22:39,160
there's some libraries like the new

00:22:37,330 --> 00:22:41,800
Stockholm library that are specifically

00:22:39,160 --> 00:22:43,810
addressing stuff like that but we are

00:22:41,800 --> 00:22:46,870
identifying messages and we're invoking

00:22:43,810 --> 00:22:48,910
them it'd be nice to be able to override

00:22:46,870 --> 00:22:51,640
destinations or override warning or

00:22:48,910 --> 00:22:54,490
error level or you know maybe kind of

00:22:51,640 --> 00:22:56,980
make other fiddly changes but it's

00:22:54,490 --> 00:22:58,780
sometimes dangerous to do all that local

00:22:56,980 --> 00:23:00,040
overriding so these are going to be

00:22:58,780 --> 00:23:01,930
house rules and your messaging framework

00:23:00,040 --> 00:23:04,240
to decide how much power you want to

00:23:01,930 --> 00:23:06,460
give the developer but by default out of

00:23:04,240 --> 00:23:08,560
the gate any new any new you should use

00:23:06,460 --> 00:23:10,630
them you don't have to but you should so

00:23:08,560 --> 00:23:11,440
samaritans of require it life is easier

00:23:10,630 --> 00:23:13,720
for using games

00:23:11,440 --> 00:23:15,970
okay so making it easy you're not gonna

00:23:13,720 --> 00:23:19,390
get better than this this is the least

00:23:15,970 --> 00:23:22,810
code you will ever ever ever type name a

00:23:19,390 --> 00:23:25,240
way for a developer to say this happened

00:23:22,810 --> 00:23:26,470
you deal with it not my problem you know

00:23:25,240 --> 00:23:29,760
I'm just telling you couldn't open the

00:23:26,470 --> 00:23:32,860
file or discus full or whatever it is

00:23:29,760 --> 00:23:34,690
saying my log with any Nana is the best

00:23:32,860 --> 00:23:36,490
you're gonna do there's nothing else now

00:23:34,690 --> 00:23:39,010
maybe it's going to be my log with a

00:23:36,490 --> 00:23:40,270
name and some local context like I'm in

00:23:39,010 --> 00:23:42,190
max values or some other information

00:23:40,270 --> 00:23:44,170
that's the best you're gonna do

00:23:42,190 --> 00:23:46,810
there's no way to reduce this further

00:23:44,170 --> 00:23:49,300
through implementable code but but that

00:23:46,810 --> 00:23:52,000
presumes that assumes that expects that

00:23:49,300 --> 00:23:54,700
demands somebody somewhere out there

00:23:52,000 --> 00:23:56,800
made any numeration say these are the

00:23:54,700 --> 00:24:00,580
discrete states that may occur and

00:23:56,800 --> 00:24:02,410
then you can use them and it you

00:24:00,580 --> 00:24:05,350
probably you don't have to but you

00:24:02,410 --> 00:24:07,870
probably want sort of some sort of text

00:24:05,350 --> 00:24:10,930
some sort of user viewable review of

00:24:07,870 --> 00:24:12,460
what what what is that you mean what is

00:24:10,930 --> 00:24:14,680
the thing what is the message that

00:24:12,460 --> 00:24:16,930
actually goes to the log file or goes to

00:24:14,680 --> 00:24:19,840
the users eyeballs well so so these

00:24:16,930 --> 00:24:22,060
missing Noom and this table of strings

00:24:19,840 --> 00:24:24,000
it's gonna have to be defined somewhere

00:24:22,060 --> 00:24:27,820
and system error that's what it does

00:24:24,000 --> 00:24:29,740
it's it's it's just a design you could

00:24:27,820 --> 00:24:31,360
come up with other designs this is a

00:24:29,740 --> 00:24:33,310
simple one and it's using a little bit

00:24:31,360 --> 00:24:34,690
of type traits but it just resumed you

00:24:33,310 --> 00:24:36,430
know idioms your names are really

00:24:34,690 --> 00:24:38,440
powerful because when you have any new

00:24:36,430 --> 00:24:40,450
especially with C++ 11 we have strong

00:24:38,440 --> 00:24:42,550
names you're in strong unions but strong

00:24:40,450 --> 00:24:44,620
unions are an example of how from

00:24:42,550 --> 00:24:46,870
Romania I know the type and from the

00:24:44,620 --> 00:24:48,790
type I have all these traits tied to the

00:24:46,870 --> 00:24:50,680
type and now with the magic of meta

00:24:48,790 --> 00:24:52,090
programming in go nuts you can associate

00:24:50,680 --> 00:24:54,070
all kinds of things with other things in

00:24:52,090 --> 00:24:56,380
system error is basically doing it what

00:24:54,070 --> 00:24:57,760
is it well it's not your logging

00:24:56,380 --> 00:24:58,600
framework you know you go and bring that

00:24:57,760 --> 00:25:01,180
yourself

00:24:58,600 --> 00:25:04,150
system error it's two things it is an

00:25:01,180 --> 00:25:06,760
adapter you can take whatever super

00:25:04,150 --> 00:25:09,070
weird stupid thing you have and you can

00:25:06,760 --> 00:25:10,810
shove it into a system error object and

00:25:09,070 --> 00:25:13,660
then pass that thing around by value

00:25:10,810 --> 00:25:15,400
safe slicing so by value passed around

00:25:13,660 --> 00:25:17,650
somewhere it's an adapter

00:25:15,400 --> 00:25:22,270
it'll unify across your air subsystems

00:25:17,650 --> 00:25:24,250
that's what it does it's also a design

00:25:22,270 --> 00:25:25,720
and implementation mechanism where this

00:25:24,250 --> 00:25:27,340
thing this thing called standard air

00:25:25,720 --> 00:25:29,620
category you're gonna derive from it to

00:25:27,340 --> 00:25:31,660
put your names in there it's it's a it's

00:25:29,620 --> 00:25:33,970
a decision made by the Committee on how

00:25:31,660 --> 00:25:35,050
this will occur how the implementation

00:25:33,970 --> 00:25:36,880
will occur you'll hook into the

00:25:35,050 --> 00:25:39,730
framework set three names and you're

00:25:36,880 --> 00:25:41,260
good to go but in theory all your API is

00:25:39,730 --> 00:25:44,080
can be passing around stood error code

00:25:41,260 --> 00:25:45,790
and all your errors are propagated

00:25:44,080 --> 00:25:47,800
across third party binaries you start

00:25:45,790 --> 00:25:51,160
loading other systems they're giving you

00:25:47,800 --> 00:25:53,320
error codes you're a system you're

00:25:51,160 --> 00:25:54,760
giving other people error codes and it's

00:25:53,320 --> 00:25:57,040
a common interchange mechanism that's

00:25:54,760 --> 00:26:00,580
what it is and that's why the file

00:25:57,040 --> 00:26:02,200
system TS the networking TS and you know

00:26:00,580 --> 00:26:03,640
some of the other libraries coming in

00:26:02,200 --> 00:26:04,750
from supposed eleven that's why it's

00:26:03,640 --> 00:26:06,190
doing stood Erica

00:26:04,750 --> 00:26:08,530
prior to this we didn't really have a

00:26:06,190 --> 00:26:09,920
way to pass errors around in a in a

00:26:08,530 --> 00:26:12,380
standard way that's that

00:26:09,920 --> 00:26:15,640
what this is doing ok so what's in the

00:26:12,380 --> 00:26:18,140
box it's not a big box it's a little box

00:26:15,640 --> 00:26:21,380
open up the system error header it's not

00:26:18,140 --> 00:26:23,420
a big header ok well if you're a user

00:26:21,380 --> 00:26:25,280
you kind of don't need to know any of

00:26:23,420 --> 00:26:27,710
this stuff it doesn't matter what are

00:26:25,280 --> 00:26:30,080
you doing I've seen hymns I test again

00:26:27,710 --> 00:26:32,510
see names I'm the user I know nothing

00:26:30,080 --> 00:26:34,100
cool that's it you should not have to

00:26:32,510 --> 00:26:35,360
know anything if you're a library

00:26:34,100 --> 00:26:37,310
developer if you're authoring or

00:26:35,360 --> 00:26:39,440
creating these things this is the stuff

00:26:37,310 --> 00:26:41,060
you can't have to know and of it you

00:26:39,440 --> 00:26:42,860
really only care about a couple things

00:26:41,060 --> 00:26:44,780
there's this thing called error code is

00:26:42,860 --> 00:26:46,190
it you're gonna receive it so you'll

00:26:44,780 --> 00:26:47,420
have to be able to decompose or compare

00:26:46,190 --> 00:26:50,810
it with something you'll compare it with

00:26:47,420 --> 00:26:53,150
any new you're done err category that's

00:26:50,810 --> 00:26:54,620
for the library authors the implementers

00:26:53,150 --> 00:26:57,080
that are trying to establish the finite

00:26:54,620 --> 00:26:58,640
bounded set of a priori scenarios that

00:26:57,080 --> 00:27:00,350
may occur that you want to communicate

00:26:58,640 --> 00:27:02,090
back to the caller these are the gnomes

00:27:00,350 --> 00:27:03,530
I may give you and and maybe there's

00:27:02,090 --> 00:27:06,020
some documentation associated when new

00:27:03,530 --> 00:27:08,180
users will be happy because oo you're

00:27:06,020 --> 00:27:10,520
seeing there are five ways you're gonna

00:27:08,180 --> 00:27:12,650
tell me you were upset yes there are

00:27:10,520 --> 00:27:14,950
five wins here are the five ways handled

00:27:12,650 --> 00:27:17,840
five ways we're all good

00:27:14,950 --> 00:27:19,700
ere categories for library authors to

00:27:17,840 --> 00:27:22,040
implement this so we'll go into that

00:27:19,700 --> 00:27:24,320
very very briefly because it's not a lot

00:27:22,040 --> 00:27:27,050
to know and then there's some other junk

00:27:24,320 --> 00:27:28,700
in there and and you don't care it's

00:27:27,050 --> 00:27:29,810
just gonna work it's basically gonna be

00:27:28,700 --> 00:27:32,420
obvious you don't have to know those

00:27:29,810 --> 00:27:33,950
details and there is a confusing thing

00:27:32,420 --> 00:27:37,070
that's going out of the community of is

00:27:33,950 --> 00:27:40,610
it an error code or is it an error

00:27:37,070 --> 00:27:42,950
condition and for the most part you

00:27:40,610 --> 00:27:45,410
don't need to you don't need to get

00:27:42,950 --> 00:27:47,480
involved in that confusion error codes

00:27:45,410 --> 00:27:49,040
are in your api's error codes are

00:27:47,480 --> 00:27:51,710
received from other api's you'll be

00:27:49,040 --> 00:27:53,210
using error codes the library author may

00:27:51,710 --> 00:27:55,700
have to make some decisions whether it's

00:27:53,210 --> 00:27:58,840
coder condition well you have this now

00:27:55,700 --> 00:28:01,790
it came in C++ 11 its standard in C++ 11

00:27:58,840 --> 00:28:03,860
so but so if you're on a 98 or no three

00:28:01,790 --> 00:28:07,400
compiler you didn't have this oh but

00:28:03,860 --> 00:28:10,190
wait you do error code it predates C++

00:28:07,400 --> 00:28:12,200
11 it was its founding boost it's ready

00:28:10,190 --> 00:28:14,090
to go ready to rock if you're 98 hero 3

00:28:12,200 --> 00:28:16,640
just pull it in from boost oh you know

00:28:14,090 --> 00:28:18,320
what audios got fully implemented that's

00:28:16,640 --> 00:28:20,390
kind of this is the basis of the

00:28:18,320 --> 00:28:21,830
networking ts so the system error stuff

00:28:20,390 --> 00:28:23,360
kind of came out of the audio networking

00:28:21,830 --> 00:28:24,710
ts stuff so

00:28:23,360 --> 00:28:26,570
there's a full implementation there to

00:28:24,710 --> 00:28:28,160
pull the boost implementation it's fully

00:28:26,570 --> 00:28:30,710
ready to go pull the audio amplification

00:28:28,160 --> 00:28:32,270
is fully ready to go if you're on 9800 3

00:28:30,710 --> 00:28:34,670
but if you're on 11 and Beyond here you

00:28:32,270 --> 00:28:36,590
have it so so everybody in the room we

00:28:34,670 --> 00:28:39,260
all have this stuff we all have it right

00:28:36,590 --> 00:28:42,470
now depending on you know which library

00:28:39,260 --> 00:28:46,580
you want to pull to get it okay so so

00:28:42,470 --> 00:28:49,160
this is all we really care about I have

00:28:46,580 --> 00:28:51,110
any new with my finite discrete a priori

00:28:49,160 --> 00:28:52,070
established scenarios that I may want to

00:28:51,110 --> 00:28:55,460
communication with a caller this

00:28:52,070 --> 00:28:58,760
happened and I probably have some kind

00:28:55,460 --> 00:29:04,340
of string or or descriptive association

00:28:58,760 --> 00:29:07,610
to that email somehow magically this has

00:29:04,340 --> 00:29:09,620
to get tied to the invocation so my log

00:29:07,610 --> 00:29:11,090
and then I put any new him in there my

00:29:09,620 --> 00:29:14,300
log and I put any new maybe some

00:29:11,090 --> 00:29:16,640
additional context in there and the top

00:29:14,300 --> 00:29:19,250
you're gonna use error category to

00:29:16,640 --> 00:29:22,160
implement the top and the bottom users

00:29:19,250 --> 00:29:23,480
are going to receive error codes you as

00:29:22,160 --> 00:29:25,430
an implementer you're going to be

00:29:23,480 --> 00:29:27,110
populating an error code to go back and

00:29:25,430 --> 00:29:31,280
it's not hard err code equals the Seenu

00:29:27,110 --> 00:29:35,330
you're done it's like not hard okay how

00:29:31,280 --> 00:29:37,190
does it work well I want to write this

00:29:35,330 --> 00:29:38,480
code on top because you're not gonna get

00:29:37,190 --> 00:29:39,980
better than that you're not gonna have

00:29:38,480 --> 00:29:42,220
less typing than that you're not gonna

00:29:39,980 --> 00:29:45,110
get better type safety than that I

00:29:42,220 --> 00:29:46,400
somehow want that associated with the

00:29:45,110 --> 00:29:47,690
implementation on the bottom which is

00:29:46,400 --> 00:29:52,970
going to be defining an air category

00:29:47,690 --> 00:29:56,180
system air does that so this is a

00:29:52,970 --> 00:30:02,120
pattern it's a pattern we see a lot it

00:29:56,180 --> 00:30:03,110
is whoops up you know I'm even call it

00:30:02,120 --> 00:30:04,370
something else I'm calling you the

00:30:03,110 --> 00:30:08,120
handle in context pattern this pattern

00:30:04,370 --> 00:30:11,600
is so used that I'm going to take a

00:30:08,120 --> 00:30:14,450
moment to beat a dead horse and say how

00:30:11,600 --> 00:30:16,550
much it is used already in your code and

00:30:14,450 --> 00:30:19,000
system error is using the same pattern

00:30:16,550 --> 00:30:24,140
you're already using in your code so

00:30:19,000 --> 00:30:26,780
it's magic so as an example this is the

00:30:24,140 --> 00:30:28,820
same pattern and don't answer yet the

00:30:26,780 --> 00:30:30,470
question what is T zero let's look real

00:30:28,820 --> 00:30:33,680
quick okay there's a worker in another

00:30:30,470 --> 00:30:35,540
worker and okay int main void okay I am

00:30:33,680 --> 00:30:36,020
a threat I'm the main thread I'm going I

00:30:35,540 --> 00:30:37,610
am

00:30:36,020 --> 00:30:39,470
threat oh you know I want to make

00:30:37,610 --> 00:30:41,000
another threat let's call it t0 no no I

00:30:39,470 --> 00:30:43,190
want another threat let's call it t1 I

00:30:41,000 --> 00:30:47,180
want a million threats go make a million

00:30:43,190 --> 00:30:51,260
threats go nuts well what is t0 really

00:30:47,180 --> 00:30:52,670
what is t10 it's not a thread and you

00:30:51,260 --> 00:30:56,450
know what I give you a hint next one

00:30:52,670 --> 00:30:58,700
hint it's not a thread how do we know

00:30:56,450 --> 00:31:00,290
it's not a thread before you answer that

00:30:58,700 --> 00:31:02,150
you know it's always good to say well

00:31:00,290 --> 00:31:04,790
you know how big is it

00:31:02,150 --> 00:31:08,330
and will you just do a size of it and

00:31:04,790 --> 00:31:10,130
well it's little it's not big at all but

00:31:08,330 --> 00:31:11,900
we'll wait a minute I know threads they

00:31:10,130 --> 00:31:13,790
like like have a name and a control

00:31:11,900 --> 00:31:15,710
block and thread-local storage and

00:31:13,790 --> 00:31:18,830
thread status and there's a lot of stuff

00:31:15,710 --> 00:31:20,810
in a thread how can t0 be like so little

00:31:18,830 --> 00:31:22,730
like sizes of a pointer or something and

00:31:20,810 --> 00:31:26,870
and that's because it's not a threat

00:31:22,730 --> 00:31:29,030
what is it it's a handle it's a handle

00:31:26,870 --> 00:31:31,130
to an implementation to fine thread

00:31:29,030 --> 00:31:34,010
there is a thread somewhere somebody

00:31:31,130 --> 00:31:36,950
implemented it it's a handle it's a

00:31:34,010 --> 00:31:38,930
handle and so we have this light and

00:31:36,950 --> 00:31:41,750
fluffy lightweight thing called a t0

00:31:38,930 --> 00:31:44,180
which is not very big and it is a handle

00:31:41,750 --> 00:31:45,950
to an implementation specific our C++

00:31:44,180 --> 00:31:48,320
right you stick our implementation

00:31:45,950 --> 00:31:49,670
defined thing over in that Lib that

00:31:48,320 --> 00:31:51,710
we're not having to load till runtime

00:31:49,670 --> 00:31:53,530
and all our code still works we're gonna

00:31:51,710 --> 00:31:56,690
have to recompile it's kind of cool

00:31:53,530 --> 00:31:59,180
so what pattern is this and that's the

00:31:56,690 --> 00:32:01,310
that's the pattern this is the handle in

00:31:59,180 --> 00:32:03,260
context pattern and so we're gonna we're

00:32:01,310 --> 00:32:04,850
gonna go through a couple examples but

00:32:03,260 --> 00:32:08,950
this is really the key question where's

00:32:04,850 --> 00:32:11,510
the context okay so so I had a handle

00:32:08,950 --> 00:32:13,070
where's the context so next slide okay

00:32:11,510 --> 00:32:14,990
well if this is the handle and context

00:32:13,070 --> 00:32:16,900
of t0 is a handle to an implementation

00:32:14,990 --> 00:32:21,310
to find thread that's somewhere else

00:32:16,900 --> 00:32:24,440
where's the context you went to a shot

00:32:21,310 --> 00:32:29,480
it exists it better exists or we're

00:32:24,440 --> 00:32:32,360
screwed in this case the context is the

00:32:29,480 --> 00:32:36,020
entire process this is the wimpy way to

00:32:32,360 --> 00:32:38,690
go you cheated you always have the

00:32:36,020 --> 00:32:41,060
current process you can always go to the

00:32:38,690 --> 00:32:44,170
current process level Global's and state

00:32:41,060 --> 00:32:45,680
and start interrogating and doing stuff

00:32:44,170 --> 00:32:48,110
the thread

00:32:45,680 --> 00:32:50,270
is assuming there is a context around it

00:32:48,110 --> 00:32:51,740
and somewhere in that context somebody's

00:32:50,270 --> 00:32:53,180
saying I want to create threads but as

00:32:51,740 --> 00:32:54,830
these things are created they're

00:32:53,180 --> 00:32:57,230
uniquely coordinated amongst each other

00:32:54,830 --> 00:32:59,570
so there's no thread 1 3 to thread 3 oh

00:32:57,230 --> 00:33:01,640
I have four thread three's no there's

00:32:59,570 --> 00:33:04,490
only one thread three somebody is

00:33:01,640 --> 00:33:06,950
brokering and handling the unique naming

00:33:04,490 --> 00:33:08,990
of all these threads the context is

00:33:06,950 --> 00:33:11,120
doing a really important job handling

00:33:08,990 --> 00:33:13,130
resource allocation of oversubscription

00:33:11,120 --> 00:33:15,860
or the hardware's already taken by

00:33:13,130 --> 00:33:17,960
somebody or the context does a very

00:33:15,860 --> 00:33:19,430
important thing but that's invisible to

00:33:17,960 --> 00:33:21,080
us we're just creating handles and

00:33:19,430 --> 00:33:25,310
magically the context popped into

00:33:21,080 --> 00:33:27,050
existence and so the context exists it

00:33:25,310 --> 00:33:28,820
may be a singleton maybe process

00:33:27,050 --> 00:33:30,560
specific there may be more than one

00:33:28,820 --> 00:33:32,870
context in the case threads there's only

00:33:30,560 --> 00:33:36,530
one current process so there's only one

00:33:32,870 --> 00:33:37,940
global context for threads a handle is

00:33:36,530 --> 00:33:39,200
constructed within a context you may

00:33:37,940 --> 00:33:41,210
have more than one context or some

00:33:39,200 --> 00:33:43,100
designs but the handle only makes sense

00:33:41,210 --> 00:33:45,290
within the context for which that handle

00:33:43,100 --> 00:33:48,110
exists and you can have dead handles

00:33:45,290 --> 00:33:50,030
maybe with no context but the handles

00:33:48,110 --> 00:33:52,580
meaningless outside its parent context

00:33:50,030 --> 00:33:55,430
the system maintains design invariants

00:33:52,580 --> 00:33:57,760
through the context the context is doing

00:33:55,430 --> 00:34:00,770
the heavy lifting the handle is not

00:33:57,760 --> 00:34:02,930
doing the heavy lifting so design

00:34:00,770 --> 00:34:04,340
invariance we have a lot of them and and

00:34:02,930 --> 00:34:06,770
this is the power of our systems but

00:34:04,340 --> 00:34:08,540
other things like you know rewrite

00:34:06,770 --> 00:34:10,700
coordination or allocating of scarce

00:34:08,540 --> 00:34:13,040
resources or you know other other stuff

00:34:10,700 --> 00:34:14,660
there's stuff that you would want to

00:34:13,040 --> 00:34:15,920
ultimately handle always through the

00:34:14,660 --> 00:34:16,910
context and never through the handles

00:34:15,920 --> 00:34:17,710
because those are just lightweight

00:34:16,910 --> 00:34:20,750
little things

00:34:17,710 --> 00:34:22,370
okay so here's Alexandre skews

00:34:20,750 --> 00:34:24,050
allocators they gave a talk at a couple

00:34:22,370 --> 00:34:25,670
of years ago funny story in the upper

00:34:24,050 --> 00:34:27,440
right hand corner they did successfully

00:34:25,670 --> 00:34:31,940
surgically reattached his hand so that

00:34:27,440 --> 00:34:34,850
was you know good my allocator equals he

00:34:31,940 --> 00:34:36,110
so I guess you proposed these composable

00:34:34,850 --> 00:34:38,480
allocators where you could establish

00:34:36,110 --> 00:34:40,340
policies for for strategies for how you

00:34:38,480 --> 00:34:42,530
want to allocate blocks and how it would

00:34:40,340 --> 00:34:44,030
handle that but you created an allocator

00:34:42,530 --> 00:34:46,400
and then you would allocate little

00:34:44,030 --> 00:34:47,780
things from it you'd play with them and

00:34:46,400 --> 00:34:49,610
then when you're done with them you

00:34:47,780 --> 00:34:51,620
would give them back and they would you

00:34:49,610 --> 00:34:53,660
know be cleared up they'd be freed well

00:34:51,620 --> 00:34:56,240
well this is the handling context right

00:34:53,660 --> 00:34:57,710
so I've got a handle to a memory thing

00:34:56,240 --> 00:34:59,030
that I allocated

00:34:57,710 --> 00:35:00,530
and then when I'm done with it when I

00:34:59,030 --> 00:35:02,660
want to retire it when I want to get rid

00:35:00,530 --> 00:35:04,790
of it I'd return it back to the context

00:35:02,660 --> 00:35:06,920
and you know it'll coalesce or not or

00:35:04,790 --> 00:35:09,290
you know however however you establish

00:35:06,920 --> 00:35:12,080
your composable allocation strategy this

00:35:09,290 --> 00:35:13,760
I this is a good example because this is

00:35:12,080 --> 00:35:15,920
an example where the context is in your

00:35:13,760 --> 00:35:17,300
face you know you are managing the

00:35:15,920 --> 00:35:19,010
context you're ain't managing the

00:35:17,300 --> 00:35:20,570
handles and there is this association

00:35:19,010 --> 00:35:20,990
that handle outside the context makes no

00:35:20,570 --> 00:35:23,900
sense

00:35:20,990 --> 00:35:25,760
so in this case you you're you're

00:35:23,900 --> 00:35:29,210
charged with holding those associations

00:35:25,760 --> 00:35:31,400
together okay so so why do we do this

00:35:29,210 --> 00:35:33,950
pattern it's done a lot we do this

00:35:31,400 --> 00:35:37,160
pattern because it is it is really

00:35:33,950 --> 00:35:39,140
really fast that's ultimately it I want

00:35:37,160 --> 00:35:41,089
to do centralized control of design and

00:35:39,140 --> 00:35:43,460
variance for something you know you know

00:35:41,089 --> 00:35:44,900
threads or hardware or memory or I mean

00:35:43,460 --> 00:35:48,230
we always are dealing with scarce

00:35:44,900 --> 00:35:50,869
resources so I I would like to reuse

00:35:48,230 --> 00:35:53,000
things I would like to coordinate things

00:35:50,869 --> 00:35:54,320
I would like to control things but I

00:35:53,000 --> 00:35:56,810
want to make it easy so we do value

00:35:54,320 --> 00:35:59,240
semantic handles being passed around but

00:35:56,810 --> 00:36:02,510
the context is established in this this

00:35:59,240 --> 00:36:03,950
sort of hidden place and so these are

00:36:02,510 --> 00:36:05,780
these are kind of example domains

00:36:03,950 --> 00:36:07,099
you know network file threat there are a

00:36:05,780 --> 00:36:09,109
lot of places where this pattern is

00:36:07,099 --> 00:36:11,180
really really popular and almost always

00:36:09,109 --> 00:36:13,609
it tends to be amortization of a scarce

00:36:11,180 --> 00:36:16,400
resource but that's that's always a good

00:36:13,609 --> 00:36:18,560
way to drop to this pattern and well you

00:36:16,400 --> 00:36:20,000
know error messages anytime your string

00:36:18,560 --> 00:36:21,440
manipulation that's expensive that's

00:36:20,000 --> 00:36:23,210
very expensive it will impact your

00:36:21,440 --> 00:36:25,330
Layton sees amortization of scarce

00:36:23,210 --> 00:36:28,460
resources tends to be interesting

00:36:25,330 --> 00:36:29,990
okay so shared pointer is actually the

00:36:28,460 --> 00:36:32,660
handle and context pattern you know

00:36:29,990 --> 00:36:34,940
whatever you want to call it so so we

00:36:32,660 --> 00:36:36,740
have this owning pointer called shared

00:36:34,940 --> 00:36:39,800
and we have this non owning pointer

00:36:36,740 --> 00:36:42,980
called week and they're both referencing

00:36:39,800 --> 00:36:45,050
objects and and somehow they're both

00:36:42,980 --> 00:36:48,920
sharing the same cut the control block

00:36:45,050 --> 00:36:51,589
the linked count the object itself that

00:36:48,920 --> 00:36:54,170
they're referring to all that context

00:36:51,589 --> 00:36:56,119
these handles are sharing and and

00:36:54,170 --> 00:36:58,040
magically just works well well yeah

00:36:56,119 --> 00:36:59,359
because the whole point of this context

00:36:58,040 --> 00:37:01,130
pattern is the context will establish

00:36:59,359 --> 00:37:03,140
invariants that are controlled and

00:37:01,130 --> 00:37:05,839
handles are just lightweight ways to

00:37:03,140 --> 00:37:07,790
reference through the controller so this

00:37:05,839 --> 00:37:09,030
handle of context we've got owning and

00:37:07,790 --> 00:37:10,970
non owning

00:37:09,030 --> 00:37:14,280
we can kind of see the control block

00:37:10,970 --> 00:37:16,980
exists we're aware of it but many many

00:37:14,280 --> 00:37:19,740
contexts exist because many many objects

00:37:16,980 --> 00:37:21,450
maybe this is so popular so powerful you

00:37:19,740 --> 00:37:23,070
can really drive a semi tractor-trailer

00:37:21,450 --> 00:37:25,530
through it you do a lot of mischief with

00:37:23,070 --> 00:37:27,660
this pattern but we're already familiar

00:37:25,530 --> 00:37:30,300
with it we're beating a dead horse it's

00:37:27,660 --> 00:37:32,910
light and fast it's controllable you

00:37:30,300 --> 00:37:34,020
know this is this is I'll leave this the

00:37:32,910 --> 00:37:35,460
slides but I want to get to the code

00:37:34,020 --> 00:37:37,440
because you know that's that's more

00:37:35,460 --> 00:37:38,850
interesting just library developers are

00:37:37,440 --> 00:37:40,890
gonna have to be aware of a couple of

00:37:38,850 --> 00:37:42,270
things users know nothing they receive a

00:37:40,890 --> 00:37:42,570
stat error code they test against seen

00:37:42,270 --> 00:37:44,220
him

00:37:42,570 --> 00:37:45,870
okay the message category this is what a

00:37:44,220 --> 00:37:48,120
library developer cares about users do

00:37:45,870 --> 00:37:51,660
not care users do not care users do not

00:37:48,120 --> 00:37:53,970
care an aggregation of messages hey

00:37:51,660 --> 00:37:56,910
there's this domain of all these

00:37:53,970 --> 00:37:59,040
enumerated values this is my category my

00:37:56,910 --> 00:38:01,080
domain I think domain would have been a

00:37:59,040 --> 00:38:02,940
better word it's error category you'll

00:38:01,080 --> 00:38:04,830
do you'll derive from stood heir

00:38:02,940 --> 00:38:06,540
category and you'll put your names in

00:38:04,830 --> 00:38:07,860
there and your Associated strings will

00:38:06,540 --> 00:38:09,540
be with there that's it that's all we're

00:38:07,860 --> 00:38:12,990
gonna do this is not hard there's like

00:38:09,540 --> 00:38:13,850
five 15 minutes work so you might have a

00:38:12,990 --> 00:38:17,040
lot of domains

00:38:13,850 --> 00:38:18,810
well usually get out and Bach C++ eleven

00:38:17,040 --> 00:38:20,310
there's there's more dropping since

00:38:18,810 --> 00:38:22,320
equals plus seventeen came a few days

00:38:20,310 --> 00:38:25,380
ago but these are the common ones now

00:38:22,320 --> 00:38:27,930
now look here means they stood we've got

00:38:25,380 --> 00:38:30,650
this air-sea thing that's your POSIX

00:38:27,930 --> 00:38:34,620
errors right these are commonly

00:38:30,650 --> 00:38:36,900
understood scenarios that make her and

00:38:34,620 --> 00:38:38,970
they're there they're ready to go you

00:38:36,900 --> 00:38:40,620
can catch an error code and test it

00:38:38,970 --> 00:38:42,450
against any one of those and if it

00:38:40,620 --> 00:38:44,400
equates to that if it's equivalent to

00:38:42,450 --> 00:38:45,750
that that's what happened so you can

00:38:44,400 --> 00:38:47,730
just use this now you don't define your

00:38:45,750 --> 00:38:49,470
own these are ready to go but you know

00:38:47,730 --> 00:38:51,780
some domains they wanted to find their

00:38:49,470 --> 00:38:54,270
own errors and that's what error code

00:38:51,780 --> 00:38:56,400
does have as many domains as you want go

00:38:54,270 --> 00:38:57,990
nuts you'll probably end up defining

00:38:56,400 --> 00:39:00,240
your own domains for your own domain

00:38:57,990 --> 00:39:02,310
specific issues and you're just gonna

00:39:00,240 --> 00:39:04,080
make any new stop slap it in your

00:39:02,310 --> 00:39:08,340
namespace but these are right they're

00:39:04,080 --> 00:39:09,420
out of the box okay so I'm gonna skip

00:39:08,340 --> 00:39:11,370
through because you're not actually

00:39:09,420 --> 00:39:13,320
gonna write code like this but there is

00:39:11,370 --> 00:39:14,520
a global process singleton kind of like

00:39:13,320 --> 00:39:16,260
you have one dealing with your thread

00:39:14,520 --> 00:39:19,109
allocation and coordination there's a

00:39:16,260 --> 00:39:21,450
global process kind of thing

00:39:19,109 --> 00:39:23,700
that is establishing your singleton for

00:39:21,450 --> 00:39:26,069
your category so these these are single

00:39:23,700 --> 00:39:28,349
tins that exist in the standard you link

00:39:26,069 --> 00:39:30,509
your run these are there right now each

00:39:28,349 --> 00:39:32,700
of those categories have names it's a

00:39:30,509 --> 00:39:35,160
process singleton it has a name it

00:39:32,700 --> 00:39:37,789
represents a category or domain of stuff

00:39:35,160 --> 00:39:40,650
that may be interesting as enumerated

00:39:37,789 --> 00:39:41,849
concept okay Errin number we're dealing

00:39:40,650 --> 00:39:43,140
with this a lot and this is kind of the

00:39:41,849 --> 00:39:45,839
old way we used to do it and see you

00:39:43,140 --> 00:39:47,099
don't have to do any new but it's a good

00:39:45,839 --> 00:39:49,680
idea to do any name because you get type

00:39:47,099 --> 00:39:51,359
safety but a lot of code is C and C is

00:39:49,680 --> 00:39:52,680
doing this error number thing and that

00:39:51,359 --> 00:39:54,690
that's kind of like the you know

00:39:52,680 --> 00:39:56,849
thread-local global that gets set when

00:39:54,690 --> 00:39:59,219
something goes wrong so it's set to zero

00:39:56,849 --> 00:40:00,959
it process setup and you know people can

00:39:59,219 --> 00:40:03,239
overwrite that value so when you call a

00:40:00,959 --> 00:40:05,430
function and something bad happen like

00:40:03,239 --> 00:40:07,380
like here you know open the file and you

00:40:05,430 --> 00:40:09,180
get the file descriptor back and if the

00:40:07,380 --> 00:40:11,729
file descriptor is less than zero well

00:40:09,180 --> 00:40:14,219
something bad happen well what happened

00:40:11,729 --> 00:40:16,349
well well I don't know well let's go

00:40:14,219 --> 00:40:19,079
check the global called error number and

00:40:16,349 --> 00:40:21,209
and we'll test it now now there's even

00:40:19,079 --> 00:40:23,339
this little formatting thing stood ster

00:40:21,209 --> 00:40:24,839
error and it's not thread safe but it'll

00:40:23,339 --> 00:40:27,209
give you a little descriptive string

00:40:24,839 --> 00:40:31,559
saying what happened so that global is

00:40:27,209 --> 00:40:33,959
set associated with a lot of system kind

00:40:31,559 --> 00:40:35,969
of calls where there's no air path

00:40:33,959 --> 00:40:38,130
there's no error code being returned to

00:40:35,969 --> 00:40:39,869
you so you go to the global yourself so

00:40:38,130 --> 00:40:41,999
it's kind of a hidden context that keeps

00:40:39,869 --> 00:40:43,440
getting overwritten as your thread makes

00:40:41,999 --> 00:40:44,880
progress so if you want to know what the

00:40:43,440 --> 00:40:46,589
error was you better hit it quick

00:40:44,880 --> 00:40:49,589
because it'll be overwritten by the next

00:40:46,589 --> 00:40:52,109
error so get last error is a similar

00:40:49,589 --> 00:40:53,699
thing that Windows is using error code

00:40:52,109 --> 00:40:55,019
is generally a better design for this

00:40:53,699 --> 00:40:58,829
the API is are going to be more thread

00:40:55,019 --> 00:40:59,880
safe but also depending on your view of

00:40:58,829 --> 00:41:02,699
the world

00:40:59,880 --> 00:41:04,199
Linux torille installer olds doesn't

00:41:02,699 --> 00:41:05,910
like the error number he thinks a squad

00:41:04,199 --> 00:41:07,199
design that's interesting but error

00:41:05,910 --> 00:41:09,690
codes better way to do the same thing

00:41:07,199 --> 00:41:11,519
okay here's Osseo obvious is look I'm

00:41:09,690 --> 00:41:12,989
writing this networking kind of stuff

00:41:11,519 --> 00:41:14,400
and you know I got my own class of

00:41:12,989 --> 00:41:16,859
problems here everybody's got their own

00:41:14,400 --> 00:41:18,930
class of problems so Azio chose to break

00:41:16,859 --> 00:41:21,900
out four different categories of errors

00:41:18,930 --> 00:41:24,180
there they are and it's not hard and you

00:41:21,900 --> 00:41:25,739
start to find your little enum and then

00:41:24,180 --> 00:41:27,660
you're gonna get your categories so sue

00:41:25,739 --> 00:41:28,829
with the Union and that's it when you

00:41:27,660 --> 00:41:29,359
write one you're gonna do the same thing

00:41:28,829 --> 00:41:31,279
to find your

00:41:29,359 --> 00:41:33,589
and get your categories listed with you

00:41:31,279 --> 00:41:37,460
new this is the number one most

00:41:33,589 --> 00:41:40,069
confusing thing about system error and I

00:41:37,460 --> 00:41:42,529
urge you to not be confused by saying

00:41:40,069 --> 00:41:45,859
use error code don't use error condition

00:41:42,529 --> 00:41:47,869
you can't go wrong if you want to use

00:41:45,859 --> 00:41:49,190
error condition you can and then you

00:41:47,869 --> 00:41:51,109
know you can explain to people why you

00:41:49,190 --> 00:41:52,460
did it but it takes more time to explain

00:41:51,109 --> 00:41:54,289
than actually do it will explain why

00:41:52,460 --> 00:41:56,420
they're different and this is part of

00:41:54,289 --> 00:41:58,549
the design it's interesting but our

00:41:56,420 --> 00:42:01,339
api's will pass that error code our

00:41:58,549 --> 00:42:02,869
api's will not pass stood air condition

00:42:01,339 --> 00:42:06,019
even if you want to use to their

00:42:02,869 --> 00:42:08,029
condition your api's will not pass that

00:42:06,019 --> 00:42:10,749
air condition they will pass stood error

00:42:08,029 --> 00:42:13,579
code error code error code

00:42:10,749 --> 00:42:18,819
platform-specific behaviors inconsistent

00:42:13,579 --> 00:42:22,730
across platforms by definition this

00:42:18,819 --> 00:42:24,799
contrast between that which is specific

00:42:22,730 --> 00:42:27,829
to this platform or which is applicable

00:42:24,799 --> 00:42:31,849
in a consistent way across platforms

00:42:27,829 --> 00:42:35,450
that is the difference between error

00:42:31,849 --> 00:42:38,239
code and air condition now developers

00:42:35,450 --> 00:42:39,559
may get confused but we we all respect

00:42:38,239 --> 00:42:41,359
it this is a scenario we sometimes

00:42:39,559 --> 00:42:44,989
effing deal with some of our stuff is

00:42:41,359 --> 00:42:47,809
platform specific so I'll just skip over

00:42:44,989 --> 00:42:51,470
this but message IDs missus code missus

00:42:47,809 --> 00:42:52,999
values well you review the slides later

00:42:51,470 --> 00:42:54,470
this isn't helpful I really need to get

00:42:52,999 --> 00:42:57,079
to the contrast in between code and

00:42:54,470 --> 00:42:59,119
condition the reason they came into

00:42:57,079 --> 00:43:00,529
existence and this is C++ this is not

00:42:59,119 --> 00:43:01,849
other languages so the language is

00:43:00,529 --> 00:43:04,759
understand this thing called error code

00:43:01,849 --> 00:43:06,410
the idea of it we have one in the

00:43:04,759 --> 00:43:10,999
library called error codes to their code

00:43:06,410 --> 00:43:13,759
but what does not work what the reason

00:43:10,999 --> 00:43:15,920
we have this design is if you say

00:43:13,759 --> 00:43:17,869
there's this one class of errors that we

00:43:15,920 --> 00:43:19,730
all trust we all believe a committee

00:43:17,869 --> 00:43:22,279
made them so they must be smart so I'll

00:43:19,730 --> 00:43:24,529
just use them we'll map our context into

00:43:22,279 --> 00:43:26,480
the standard ones and everybody'll just

00:43:24,529 --> 00:43:29,480
use the standard ones that does not work

00:43:26,480 --> 00:43:30,499
that presumes there's a standard one but

00:43:29,480 --> 00:43:33,289
in reality there's always

00:43:30,499 --> 00:43:35,029
domain-specific it's supposed to work by

00:43:33,289 --> 00:43:38,509
having a common denominator that we all

00:43:35,029 --> 00:43:39,829
accept the reality is that common

00:43:38,509 --> 00:43:42,460
denominator doesn't exist

00:43:39,829 --> 00:43:44,770
that's intractable it's not scalable so

00:43:42,460 --> 00:43:47,560
we have a design where we allow mapping

00:43:44,770 --> 00:43:49,839
of my domain to your domain comparison

00:43:47,560 --> 00:43:52,080
equivalence of my domain to your domain

00:43:49,839 --> 00:43:55,200
that's what error code is doing so a

00:43:52,080 --> 00:43:57,910
universal Seenu that everybody uses

00:43:55,200 --> 00:43:59,560
that's not what the POSIX errors are

00:43:57,910 --> 00:44:01,690
those are just common scenarios that

00:43:59,560 --> 00:44:04,180
that sometimes happen but that's not the

00:44:01,690 --> 00:44:06,820
universal set there is no universal he

00:44:04,180 --> 00:44:10,170
knew that's the design of Sudhir mapping

00:44:06,820 --> 00:44:13,300
across seems easy that's what it does so

00:44:10,170 --> 00:44:14,619
this standard one the implied mechanics

00:44:13,300 --> 00:44:16,270
is there already Maps the standard one

00:44:14,619 --> 00:44:17,530
and all air scenarios all are

00:44:16,270 --> 00:44:20,200
conditional branching is based on

00:44:17,530 --> 00:44:21,790
standard errors does not work that's why

00:44:20,200 --> 00:44:24,040
this designs there you interview the

00:44:21,790 --> 00:44:25,599
slides eight later but it's lossy

00:44:24,040 --> 00:44:28,060
introduces ambiguities and it can't

00:44:25,599 --> 00:44:31,630
scale because there is no common domain

00:44:28,060 --> 00:44:33,310
it does not work what we do is you have

00:44:31,630 --> 00:44:35,020
a domain I have a domain lots of domains

00:44:33,310 --> 00:44:36,820
mapping across domains that's easy and

00:44:35,020 --> 00:44:38,560
that's what Eriko does so we're gonna

00:44:36,820 --> 00:44:40,420
map domain specific to standard and this

00:44:38,560 --> 00:44:42,220
is kind of the same thing this is more

00:44:40,420 --> 00:44:43,390
detail with what we just said but I have

00:44:42,220 --> 00:44:46,030
to zip on because I want C code

00:44:43,390 --> 00:44:47,890
domain-specific errors must exist they

00:44:46,030 --> 00:44:50,320
always must exist all of our code is

00:44:47,890 --> 00:44:53,380
domain-specific it's it turns out there

00:44:50,320 --> 00:44:55,720
a lot of domains who knew translating is

00:44:53,380 --> 00:44:58,270
lossy that's hard the design of error

00:44:55,720 --> 00:45:00,369
code is to say I do not want to do a

00:44:58,270 --> 00:45:02,980
lossy operation until at the point of

00:45:00,369 --> 00:45:05,410
use that's this design and that's why

00:45:02,980 --> 00:45:07,270
all your api's will pass error codes

00:45:05,410 --> 00:45:09,520
error codes are a non lossy

00:45:07,270 --> 00:45:11,680
platform-specific this happened with

00:45:09,520 --> 00:45:13,030
your network controller and then you

00:45:11,680 --> 00:45:14,800
propagate it up and if you want to loss

00:45:13,030 --> 00:45:16,030
of conversion at the point of test to go

00:45:14,800 --> 00:45:18,540
to the log file that's fine

00:45:16,030 --> 00:45:20,560
that's up to you that's the point is so

00:45:18,540 --> 00:45:23,260
many message codes from many domains

00:45:20,560 --> 00:45:25,869
mapping them across different domains

00:45:23,260 --> 00:45:27,400
even across third-party libraries that

00:45:25,869 --> 00:45:29,680
you have no knowledge of its system load

00:45:27,400 --> 00:45:32,320
that's totally fine error code is built

00:45:29,680 --> 00:45:35,349
to do that we want to preserve context

00:45:32,320 --> 00:45:39,640
and we want to map and manipulate across

00:45:35,349 --> 00:45:41,830
domains now this is surprisingly hard

00:45:39,640 --> 00:45:43,390
how many domains exist and how do I want

00:45:41,830 --> 00:45:45,280
to translate all the weird things that

00:45:43,390 --> 00:45:48,060
may happen with that particular hardware

00:45:45,280 --> 00:45:50,260
device up to something that my generic

00:45:48,060 --> 00:45:53,500
library can present to the user in an

00:45:50,260 --> 00:45:55,960
understandable way that mapping that

00:45:53,500 --> 00:45:58,150
mapping is work that's design work

00:45:55,960 --> 00:46:01,240
that's not sister Mary's fault that the

00:45:58,150 --> 00:46:03,100
design work has to occur so the we're

00:46:01,240 --> 00:46:05,560
gonna call that cross-domain semantic

00:46:03,100 --> 00:46:08,950
mapping cross domain semantic mapping is

00:46:05,560 --> 00:46:11,980
hard and that's the heavy lifting this

00:46:08,950 --> 00:46:14,770
is done ultimately through static type

00:46:11,980 --> 00:46:17,710
checking of instance specific capacities

00:46:14,770 --> 00:46:19,480
through api's code and condition always

00:46:17,710 --> 00:46:21,280
there error code always error code never

00:46:19,480 --> 00:46:23,470
air-conditioned three api's and will

00:46:21,280 --> 00:46:24,670
test against any NIMH and if the names a

00:46:23,470 --> 00:46:28,120
code or condition you won't know it

00:46:24,670 --> 00:46:29,590
won't care okay so what is it's a little

00:46:28,120 --> 00:46:32,380
thing it's sixteen bytes

00:46:29,590 --> 00:46:35,020
it's suspiciously similar to 8-bit or

00:46:32,380 --> 00:46:37,350
eight bytes for account and eight bytes

00:46:35,020 --> 00:46:40,180
for a pointer it kind of looks like that

00:46:37,350 --> 00:46:41,950
there's sort of this associated state

00:46:40,180 --> 00:46:43,960
with an error instance you get an error

00:46:41,950 --> 00:46:44,890
code you test it against um so it's all

00:46:43,960 --> 00:46:46,270
you're gonna do if you want the string

00:46:44,890 --> 00:46:47,980
ask for the string out of it it'll give

00:46:46,270 --> 00:46:49,510
it to you the string is not actually in

00:46:47,980 --> 00:46:50,950
that little instances in the area

00:46:49,510 --> 00:46:53,530
categories in the context of student

00:46:50,950 --> 00:46:57,670
from you so the domain and ID is the

00:46:53,530 --> 00:47:00,640
error code the air this is the API of

00:46:57,670 --> 00:47:04,090
error code it looks a lot like the API

00:47:00,640 --> 00:47:05,530
for error condition what can you do well

00:47:04,090 --> 00:47:08,620
you can get the integer out of it which

00:47:05,530 --> 00:47:11,200
is visiting noon ultimately you can get

00:47:08,620 --> 00:47:14,050
the string message out of it and you can

00:47:11,200 --> 00:47:16,150
clear it you can test it for India State

00:47:14,050 --> 00:47:17,830
or not that's the operator bool and you

00:47:16,150 --> 00:47:18,940
can get its parent category probably

00:47:17,830 --> 00:47:20,290
don't care about that unless you're a

00:47:18,940 --> 00:47:22,630
library author you may care about that

00:47:20,290 --> 00:47:24,070
users don't care about any of this users

00:47:22,630 --> 00:47:25,540
will test against an enum that's it

00:47:24,070 --> 00:47:27,190
that's all they'll do with library

00:47:25,540 --> 00:47:28,930
author this is the state that you have

00:47:27,190 --> 00:47:30,580
and ultimately it's a lightweight handle

00:47:28,930 --> 00:47:34,000
into the air category actually giving

00:47:30,580 --> 00:47:35,950
you the string state so you're gonna

00:47:34,000 --> 00:47:37,780
take the category derive your own

00:47:35,950 --> 00:47:39,640
process level singleton it doesn't

00:47:37,780 --> 00:47:42,280
actually have to be that but out of the

00:47:39,640 --> 00:47:43,810
box it's easiest to do that and you're

00:47:42,280 --> 00:47:47,170
gonna stick your names and strings

00:47:43,810 --> 00:47:48,820
inside your category that's derived so

00:47:47,170 --> 00:47:50,980
this is kind of the same thing we

00:47:48,820 --> 00:47:53,380
already have a few categories given to

00:47:50,980 --> 00:47:54,940
us you can have as many categories as

00:47:53,380 --> 00:47:56,770
you want they're all going to derive

00:47:54,940 --> 00:47:59,860
from air category

00:47:56,770 --> 00:48:01,360
so here's code this is normal I'll

00:47:59,860 --> 00:48:02,980
create an error code and I'll pass

00:48:01,360 --> 00:48:06,130
internal function to be populated on the

00:48:02,980 --> 00:48:07,860
left or I'll just call a function which

00:48:06,130 --> 00:48:09,090
returns one by value on the right

00:48:07,860 --> 00:48:11,130
totally

00:48:09,090 --> 00:48:13,530
both those patterns or widespread uses

00:48:11,130 --> 00:48:15,330
this would be typical so Eriko

00:48:13,530 --> 00:48:17,460
lightweight value semantics instances

00:48:15,330 --> 00:48:18,540
handled something but it's basically got

00:48:17,460 --> 00:48:19,950
any new min there you're gonna test

00:48:18,540 --> 00:48:21,450
against in some kind of you know this

00:48:19,950 --> 00:48:23,310
case we're doing an implicit conversion

00:48:21,450 --> 00:48:24,900
we're using that operator rule so hey

00:48:23,310 --> 00:48:27,060
hey you see if you have something in you

00:48:24,900 --> 00:48:29,130
know it could be all kinds of stuff okay

00:48:27,060 --> 00:48:30,930
you know maybe you think yeah I totally

00:48:29,130 --> 00:48:33,240
started that asynchronous process just

00:48:30,930 --> 00:48:34,230
fine that's not actually an error it's

00:48:33,240 --> 00:48:36,780
just saying whether or not there's

00:48:34,230 --> 00:48:38,700
payload in there now I find it's

00:48:36,780 --> 00:48:40,200
interesting to test against the the bull

00:48:38,700 --> 00:48:42,090
but a lot of times you actually want to

00:48:40,200 --> 00:48:44,100
test its greatly against any ham that's

00:48:42,090 --> 00:48:45,420
gonna be the next slide so there's just

00:48:44,100 --> 00:48:48,030
a value semantics lightweight little

00:48:45,420 --> 00:48:51,060
thing they're little they're fast this

00:48:48,030 --> 00:48:53,040
is why this slide is all users have to

00:48:51,060 --> 00:48:55,620
know you forget everything else blah

00:48:53,040 --> 00:48:58,170
blah blah stuff this slide is the slide

00:48:55,620 --> 00:49:01,980
this is all you need to know you will

00:48:58,170 --> 00:49:03,660
create one you will maybe get it

00:49:01,980 --> 00:49:05,280
populated through a function or populate

00:49:03,660 --> 00:49:07,620
yourself who knows and then you're gonna

00:49:05,280 --> 00:49:09,030
test against any name that's it and as

00:49:07,620 --> 00:49:11,280
long as the library author did their job

00:49:09,030 --> 00:49:14,280
that'll work and and it's not a hard job

00:49:11,280 --> 00:49:16,470
to do will sit through that but what's

00:49:14,280 --> 00:49:19,260
interesting here is not every error is

00:49:16,470 --> 00:49:21,510
an error this has informed context back

00:49:19,260 --> 00:49:23,340
to the caller that something something

00:49:21,510 --> 00:49:25,350
was populated because yeah I hit a

00:49:23,340 --> 00:49:28,320
decision point I have information for

00:49:25,350 --> 00:49:30,240
you I failed to create that directory I

00:49:28,320 --> 00:49:33,300
am so sorry I failed to create the

00:49:30,240 --> 00:49:35,850
directory why because the directory was

00:49:33,300 --> 00:49:38,100
already there well I just want the

00:49:35,850 --> 00:49:39,930
directory to be there this is not really

00:49:38,100 --> 00:49:43,110
an error you know I'm fine I just wanted

00:49:39,930 --> 00:49:45,450
to be there so in this case here we have

00:49:43,110 --> 00:49:48,090
an optimistic scenario where you know as

00:49:45,450 --> 00:49:50,190
long as you created it or the error was

00:49:48,090 --> 00:49:51,690
it was already there okay well then I

00:49:50,190 --> 00:49:53,760
can continue on this is conditional

00:49:51,690 --> 00:49:55,530
branch logic based on communication from

00:49:53,760 --> 00:49:58,230
the caller but all we're doing that to

00:49:55,530 --> 00:50:00,270
ECW equals some enum or you could have

00:49:58,230 --> 00:50:02,370
said EC is assign the value of semi-new

00:50:00,270 --> 00:50:05,670
and that's it that's all we're gonna do

00:50:02,370 --> 00:50:07,500
so there are standard air category stuff

00:50:05,670 --> 00:50:09,300
all out-of-the-box ready to go there in

00:50:07,500 --> 00:50:10,380
the standard the error codes historic

00:50:09,300 --> 00:50:14,310
I'm going to skip through this the

00:50:10,380 --> 00:50:16,710
condition this is a domain context thing

00:50:14,310 --> 00:50:18,330
and the slides are free they're going to

00:50:16,710 --> 00:50:19,560
be online so you know you can read them

00:50:18,330 --> 00:50:21,720
at your peril but we're running out of

00:50:19,560 --> 00:50:23,610
time we're gonna map across through

00:50:21,720 --> 00:50:29,160
stuff but ultimately what I'm trying to

00:50:23,610 --> 00:50:31,020
get to is the simple way to this is this

00:50:29,160 --> 00:50:33,240
is me being cute this says you see names

00:50:31,020 --> 00:50:36,150
there's all that slide said library

00:50:33,240 --> 00:50:39,390
author this is not hard you're going to

00:50:36,150 --> 00:50:41,430
make any man by defining in write a

00:50:39,390 --> 00:50:42,930
switch and some lightweight template

00:50:41,430 --> 00:50:44,850
metaprogramming which you can copy/paste

00:50:42,930 --> 00:50:47,220
is 15 minutes jump this was the library

00:50:44,850 --> 00:50:49,170
author does so most people are not

00:50:47,220 --> 00:50:51,960
library authors they don't care

00:50:49,170 --> 00:50:53,160
so the standard uses strong names Accio

00:50:51,960 --> 00:50:54,480
is using weaking names because they're

00:50:53,160 --> 00:50:56,400
trying to be you know backwards

00:50:54,480 --> 00:50:58,440
compatible low three you know use

00:50:56,400 --> 00:51:01,440
whatever you want but you know pull

00:50:58,440 --> 00:51:04,380
those work your enum is a placeholder

00:51:01,440 --> 00:51:05,910
for air condition constants and and

00:51:04,380 --> 00:51:07,920
you're just going to test against it if

00:51:05,910 --> 00:51:12,270
this error code that I received from

00:51:07,920 --> 00:51:14,790
somebody is that scenario and the

00:51:12,270 --> 00:51:18,690
library author is going to define the

00:51:14,790 --> 00:51:22,140
new overload some decision about I'm a

00:51:18,690 --> 00:51:24,600
code or a condition almost always well

00:51:22,140 --> 00:51:26,490
the guidelines here is little arm wavy

00:51:24,600 --> 00:51:28,410
but if you're doing platform specific

00:51:26,490 --> 00:51:30,360
stuff with your hardware specific

00:51:28,410 --> 00:51:32,430
controller it's an error code otherwise

00:51:30,360 --> 00:51:36,270
it's near condition when in doubt just

00:51:32,430 --> 00:51:37,800
use your code derive from air category

00:51:36,270 --> 00:51:41,700
and you got a couple overrides

00:51:37,800 --> 00:51:43,500
so given URI Noom what string would you

00:51:41,700 --> 00:51:46,110
like to return that's it that's not hard

00:51:43,500 --> 00:51:47,580
to do it's often done in a switch giving

00:51:46,110 --> 00:51:50,760
uranium what string would you like to

00:51:47,580 --> 00:51:52,890
return that string happens to become its

00:51:50,760 --> 00:51:54,900
it's passed by value we're returning a

00:51:52,890 --> 00:51:57,570
whole value string back so if you wanted

00:51:54,900 --> 00:51:58,890
to do a locale specific translation or

00:51:57,570 --> 00:52:00,810
if you want to pull other context from

00:51:58,890 --> 00:52:04,650
the environment put timestamps in there

00:52:00,810 --> 00:52:07,020
the API is conducive to that you can

00:52:04,650 --> 00:52:10,580
access it so this library authors step

00:52:07,020 --> 00:52:13,050
for we're gonna get our singleton and

00:52:10,580 --> 00:52:14,610
now you can just get it it's just sort

00:52:13,050 --> 00:52:16,470
of an identity thing or the address of

00:52:14,610 --> 00:52:18,360
it exists in the same process define the

00:52:16,470 --> 00:52:21,420
factory functions these are well known

00:52:18,360 --> 00:52:23,970
and this is not hard you just get

00:52:21,420 --> 00:52:26,010
anything that can be converted to an int

00:52:23,970 --> 00:52:28,170
and a pointer to hood or a reference to

00:52:26,010 --> 00:52:30,690
the domain that goes into error code so

00:52:28,170 --> 00:52:32,370
see errors go in information for other

00:52:30,690 --> 00:52:33,160
processes going as long as you convert

00:52:32,370 --> 00:52:35,500
it to an ant and

00:52:33,160 --> 00:52:37,930
references to an error an air category

00:52:35,500 --> 00:52:41,500
you've got an error code so make one

00:52:37,930 --> 00:52:43,630
make the other there's some overriding

00:52:41,500 --> 00:52:45,250
of equivalence and getting of default

00:52:43,630 --> 00:52:46,930
stuff this is what the library author

00:52:45,250 --> 00:52:49,030
can do this is optional you don't have

00:52:46,930 --> 00:52:50,440
to do this but this is where the author

00:52:49,030 --> 00:52:52,480
can say look I got a lot of

00:52:50,440 --> 00:52:54,250
domain-specific he names but you know

00:52:52,480 --> 00:52:56,170
what a lot of these kind of map to the

00:52:54,250 --> 00:52:57,970
posix see names you know the standard he

00:52:56,170 --> 00:53:00,460
names so this is your opportunity to

00:52:57,970 --> 00:53:02,740
kind of map your emails to the POSIX

00:53:00,460 --> 00:53:04,690
memes now you can test your failure

00:53:02,740 --> 00:53:06,069
scenarios with the POSIX ones you know

00:53:04,690 --> 00:53:07,780
back and forth that that's if the

00:53:06,069 --> 00:53:09,789
library often wants to do that this is

00:53:07,780 --> 00:53:11,680
cross domain semantic mapping this is

00:53:09,789 --> 00:53:13,150
design activity you know you have to

00:53:11,680 --> 00:53:14,799
define your names you have to that's

00:53:13,150 --> 00:53:16,780
lying there mapping if there is any

00:53:14,799 --> 00:53:18,309
mapping to these other domains that's

00:53:16,780 --> 00:53:21,160
the heavy lifting that's the hard job

00:53:18,309 --> 00:53:23,500
and this is just the easiest library

00:53:21,160 --> 00:53:26,260
that's standard to give you that and

00:53:23,500 --> 00:53:28,599
that's it this library author seven

00:53:26,260 --> 00:53:30,700
steps one of which is profit the one

00:53:28,599 --> 00:53:32,049
prior six is optional so there's really

00:53:30,700 --> 00:53:32,740
only a few steps it's only 15 minutes

00:53:32,049 --> 00:53:36,420
make one

00:53:32,740 --> 00:53:38,740
welcome user oh so library author

00:53:36,420 --> 00:53:40,660
anything that can be converted to an int

00:53:38,740 --> 00:53:43,119
and a reference to a domain is an air

00:53:40,660 --> 00:53:44,859
cut anything so you can make error codes

00:53:43,119 --> 00:53:47,230
with an int and a reference to an air

00:53:44,859 --> 00:53:48,940
category that's really really simple and

00:53:47,230 --> 00:53:51,279
there's a lot of mischief you can do

00:53:48,940 --> 00:53:52,150
with it so users users you just need to

00:53:51,279 --> 00:53:56,230
know Eames

00:53:52,150 --> 00:53:58,539
that's it I can read and see the news

00:53:56,230 --> 00:54:00,640
that bite me hand it to me so you can

00:53:58,539 --> 00:54:02,859
put them in your code and write in there

00:54:00,640 --> 00:54:03,849
that's it that's all users should know

00:54:02,859 --> 00:54:10,869
they shouldn't know any of this stuff

00:54:03,849 --> 00:54:12,819
they should use e-news and this is kinda

00:54:10,869 --> 00:54:14,740
this is kind of how and why it works

00:54:12,819 --> 00:54:16,720
this is the type traits template

00:54:14,740 --> 00:54:19,480
metaprogramming design feature that is

00:54:16,720 --> 00:54:21,460
error code so i have any new and given

00:54:19,480 --> 00:54:24,099
any new i know what it's type is it's

00:54:21,460 --> 00:54:25,960
type is whatever enum type it is well

00:54:24,099 --> 00:54:28,779
that type can have traits associated

00:54:25,960 --> 00:54:30,099
with it and that's the mapping that's

00:54:28,779 --> 00:54:31,900
why it works

00:54:30,099 --> 00:54:34,900
given any name I already know the

00:54:31,900 --> 00:54:37,029
category the the attribute for this you

00:54:34,900 --> 00:54:39,220
know is it belongs to that category

00:54:37,029 --> 00:54:41,619
there that domain there so that's why we

00:54:39,220 --> 00:54:43,390
just use a names in our code so this is

00:54:41,619 --> 00:54:45,040
your template meta guy that's that's

00:54:43,390 --> 00:54:47,560
that's really why it works and

00:54:45,040 --> 00:54:51,790
is this day and age really simplement

00:54:47,560 --> 00:54:54,220
program so users the zip you're gonna

00:54:51,790 --> 00:54:56,230
you're gonna get one populate it you're

00:54:54,220 --> 00:55:00,460
gonna test any new that's it that's all

00:54:56,230 --> 00:55:03,010
users should be doing nothing else they

00:55:00,460 --> 00:55:05,260
can populate them you can users can just

00:55:03,010 --> 00:55:06,700
populate air coats too if you have any

00:55:05,260 --> 00:55:08,950
name just throw it in the air cut and

00:55:06,700 --> 00:55:10,900
hand it back to somebody or return it so

00:55:08,950 --> 00:55:14,380
you can return them and populate by

00:55:10,900 --> 00:55:16,120
value or you can throw and there's our

00:55:14,380 --> 00:55:18,400
explicit conversion but that's it this

00:55:16,120 --> 00:55:21,520
is this is this is all the code we would

00:55:18,400 --> 00:55:24,310
write and so now there's there's more

00:55:21,520 --> 00:55:26,170
stuff associated with it you're gonna

00:55:24,310 --> 00:55:28,840
want to test explicitly you're not gonna

00:55:26,170 --> 00:55:30,370
want to put them in a switch and mapping

00:55:28,840 --> 00:55:32,350
across domains this is the library

00:55:30,370 --> 00:55:34,630
developer thing and I'm just gonna kind

00:55:32,350 --> 00:55:36,490
of go through this very quickly but the

00:55:34,630 --> 00:55:38,110
original context is to preserve err code

00:55:36,490 --> 00:55:40,570
is a non velocity platform specific

00:55:38,110 --> 00:55:42,790
payload of what specifically occurred in

00:55:40,570 --> 00:55:44,860
non lotzie way that propagates across

00:55:42,790 --> 00:55:46,240
all the api's you have into a

00:55:44,860 --> 00:55:48,280
third-party library and all the way down

00:55:46,240 --> 00:55:50,470
for somebody to handle and if they want

00:55:48,280 --> 00:55:52,180
to test it at that point of use as an

00:55:50,470 --> 00:55:54,120
air condition or something that's at

00:55:52,180 --> 00:55:56,890
point of use that's number two but

00:55:54,120 --> 00:55:58,600
mapping across domains is the library

00:55:56,890 --> 00:56:00,700
authors job that's that's basically what

00:55:58,600 --> 00:56:02,650
we do that's the design it's a simple

00:56:00,700 --> 00:56:05,950
design it's the handling context design

00:56:02,650 --> 00:56:07,690
and we're already using it so the

00:56:05,950 --> 00:56:09,970
library authors they really have the

00:56:07,690 --> 00:56:11,680
hard job what are your domains in in

00:56:09,970 --> 00:56:13,770
defining Eames form that at least serves

00:56:11,680 --> 00:56:16,180
as documentation and do that mapping

00:56:13,770 --> 00:56:17,590
users they use your names they don't

00:56:16,180 --> 00:56:19,510
have to know anything they shouldn't

00:56:17,590 --> 00:56:21,760
know anything and you can define an

00:56:19,510 --> 00:56:23,110
error code in like ten minutes users you

00:56:21,760 --> 00:56:25,360
know zero minutes they just have unions

00:56:23,110 --> 00:56:27,490
they just use them so many domains are

00:56:25,360 --> 00:56:30,550
interesting domains overlap mapping

00:56:27,490 --> 00:56:32,920
across domains is this design the air

00:56:30,550 --> 00:56:36,040
code is a type erased platform-specific

00:56:32,920 --> 00:56:37,840
payload the type of rager is because

00:56:36,040 --> 00:56:40,180
it's referencing an air category which

00:56:37,840 --> 00:56:41,770
is an abstract base class that's the

00:56:40,180 --> 00:56:45,490
type of ratio that allows your code of

00:56:41,770 --> 00:56:46,660
work so this is equivalence as oh I'll

00:56:45,490 --> 00:56:48,550
just I'll just say here real quick

00:56:46,660 --> 00:56:49,510
there's there's more and I'm not too

00:56:48,550 --> 00:56:50,980
worried about it because there's some

00:56:49,510 --> 00:56:52,030
really good blog post by Chris Cole Hoff

00:56:50,980 --> 00:56:53,440
and others online that I'm going to

00:56:52,030 --> 00:56:55,330
point you through in a second but this

00:56:53,440 --> 00:56:57,300
comparing of air code and condition is

00:56:55,330 --> 00:56:58,800
an equivalence comparison and

00:56:57,300 --> 00:57:00,600
and that's part of the design that's the

00:56:58,800 --> 00:57:03,930
aesthetic type check and compilers doing

00:57:00,600 --> 00:57:06,450
I can map any errors any names I want

00:57:03,930 --> 00:57:08,100
from any domain into an error code and I

00:57:06,450 --> 00:57:11,010
can compare that against any other

00:57:08,100 --> 00:57:13,020
domain and it'll just work as long as

00:57:11,010 --> 00:57:14,310
the library author did that that inu

00:57:13,020 --> 00:57:16,400
mapping we're good to go

00:57:14,310 --> 00:57:18,750
and so here would be an example of it I

00:57:16,400 --> 00:57:20,550
have a lot of things that may actually

00:57:18,750 --> 00:57:22,200
have occurred but you know I'm gonna

00:57:20,550 --> 00:57:24,660
raise it to a higher order and say

00:57:22,200 --> 00:57:25,620
there's this kind of domain where I just

00:57:24,660 --> 00:57:27,960
want to know is that low system

00:57:25,620 --> 00:57:30,150
resources and if any of those errors

00:57:27,960 --> 00:57:32,520
occurred that equivalence the low root

00:57:30,150 --> 00:57:35,580
system resources will return true this

00:57:32,520 --> 00:57:38,700
is really powerful this is a multi-state

00:57:35,580 --> 00:57:40,470
many-to-many state reduction opportunity

00:57:38,700 --> 00:57:42,600
and this is up to the library author to

00:57:40,470 --> 00:57:45,000
design that so this is you know

00:57:42,600 --> 00:57:46,980
overloading equivalents and this is a

00:57:45,000 --> 00:57:48,570
platform specific mapping I'm not gonna

00:57:46,980 --> 00:57:50,010
do it because you can do the you can do

00:57:48,570 --> 00:57:52,020
the slides online they're examples blog

00:57:50,010 --> 00:57:53,730
posts I'm doing this but you can do your

00:57:52,020 --> 00:57:54,720
cross domain mapping in a platform

00:57:53,730 --> 00:57:56,790
specific way

00:57:54,720 --> 00:57:58,590
that's this slide the link in the corner

00:57:56,790 --> 00:58:01,260
is Crisco Hoffs blog talks about this

00:57:58,590 --> 00:58:04,560
and here's a platform independent way to

00:58:01,260 --> 00:58:06,180
across cross domain mapping so these are

00:58:04,560 --> 00:58:08,580
common ways to do platform specific

00:58:06,180 --> 00:58:12,150
domain mapping and platform independent

00:58:08,580 --> 00:58:15,510
domain mapping across across our domain

00:58:12,150 --> 00:58:18,840
boundaries so review ere category or

00:58:15,510 --> 00:58:20,070
code or condition users don't need to

00:58:18,840 --> 00:58:21,930
know any of these they're gonna receive

00:58:20,070 --> 00:58:23,400
error codes always api's will use your

00:58:21,930 --> 00:58:24,710
codes that's all users need to know

00:58:23,400 --> 00:58:28,410
they'll test against rooms that's it

00:58:24,710 --> 00:58:32,190
library authors may care about I derive

00:58:28,410 --> 00:58:34,170
from category I populate error codes but

00:58:32,190 --> 00:58:35,940
I provide users air-conditioned

00:58:34,170 --> 00:58:37,920
enumerations that's what a library

00:58:35,940 --> 00:58:39,930
author would care if you want to throw

00:58:37,920 --> 00:58:42,180
one no problem that's system error

00:58:39,930 --> 00:58:43,800
you just you just throw it during a

00:58:42,180 --> 00:58:45,870
stood error code will give you the

00:58:43,800 --> 00:58:47,460
system air you can catch later and the

00:58:45,870 --> 00:58:50,130
air see POSIX stuff is ready to go out

00:58:47,460 --> 00:58:51,870
of the box so for review users all

00:58:50,130 --> 00:58:53,730
you're gonna do is test against you NIMS

00:58:51,870 --> 00:58:55,680
it can't be context where I think that

00:58:53,730 --> 00:58:57,900
can be fixed but as it stands now it's

00:58:55,680 --> 00:59:00,950
not a context per thing because the way

00:58:57,900 --> 00:59:03,330
it's implemented with with air category

00:59:00,950 --> 00:59:05,730
for library authors this is all you're

00:59:03,330 --> 00:59:08,100
gonna do you know you're just gonna pick

00:59:05,730 --> 00:59:08,980
a my coder condition just just pick code

00:59:08,100 --> 00:59:10,960
it doesn't matter

00:59:08,980 --> 00:59:12,850
pick condition who cares and then drive

00:59:10,960 --> 00:59:14,890
your domain access your domain and and

00:59:12,850 --> 00:59:16,750
that goes back to the academic thing of

00:59:14,890 --> 00:59:18,970
are you platform specific or platform

00:59:16,750 --> 00:59:20,410
independent is that distinction but but

00:59:18,970 --> 00:59:22,390
this is it this is like you know ten

00:59:20,410 --> 00:59:24,730
minutes and then you got a no domain and

00:59:22,390 --> 00:59:26,530
the cross domain mapping is free you can

00:59:24,730 --> 00:59:29,560
type your aces so here's the blog post

00:59:26,530 --> 00:59:30,790
plus stuff like Chris API design and you

00:59:29,560 --> 00:59:32,770
know this is basically stuff you're

00:59:30,790 --> 00:59:34,570
going to know already but the power of

00:59:32,770 --> 00:59:35,830
medium it's not just that it's noon to

00:59:34,570 --> 00:59:38,890
give you compile time type safety which

00:59:35,830 --> 00:59:41,530
is way cool it's documentation these are

00:59:38,890 --> 00:59:43,210
the discrete things and and now I've

00:59:41,530 --> 00:59:45,940
told users what the discrete things are

00:59:43,210 --> 00:59:48,490
as documentation really valuable but

00:59:45,940 --> 00:59:52,060
your api's will use error code they will

00:59:48,490 --> 00:59:54,730
not pass air condition always prefer

00:59:52,060 --> 00:59:56,050
error code you can serialize to error

00:59:54,730 --> 00:59:58,359
code you cannot see realize their

00:59:56,050 --> 01:00:00,190
condition it gets upset if you try to

00:59:58,359 --> 01:00:02,410
serialize their condition just don't use

01:00:00,190 --> 01:00:06,130
their condition just use their code your

01:00:02,410 --> 01:00:08,590
code did your air code so API should use

01:00:06,130 --> 01:00:12,070
our codes you will number one don't use

01:00:08,590 --> 01:00:14,800
their condition not hard so api's air

01:00:12,070 --> 01:00:18,070
code wait don't forget your api should

01:00:14,800 --> 01:00:19,600
use air code not air condition this is

01:00:18,070 --> 01:00:21,880
an example of why you would want to use

01:00:19,600 --> 01:00:24,369
air condition it's kind of academically

01:00:21,880 --> 01:00:26,260
interesting but it's it's not practical

01:00:24,369 --> 01:00:27,790
the code you're gonna write you're

01:00:26,260 --> 01:00:29,980
probably not gonna return you're gonna

01:00:27,790 --> 01:00:32,140
return my value you know these are

01:00:29,980 --> 01:00:33,760
lightweight handles their little so

01:00:32,140 --> 01:00:35,950
you're gonna pass them to be populated

01:00:33,760 --> 01:00:39,480
or return them by value you can throw if

01:00:35,950 --> 01:00:42,640
you want and call back same thing now

01:00:39,480 --> 01:00:45,100
Accio tends to pass by reference

01:00:42,640 --> 01:00:47,290
you know when they're read-only and you

01:00:45,100 --> 01:00:49,540
know other people doing by value there's

01:00:47,290 --> 01:00:50,890
there's a debate on that and you know

01:00:49,540 --> 01:00:52,690
there's all kinds of opportunities for

01:00:50,890 --> 01:00:56,590
putting them inside stat optionals and

01:00:52,690 --> 01:00:58,570
other things so we're done but using

01:00:56,590 --> 01:01:00,580
neumes says that air code and

01:00:58,570 --> 01:01:03,190
conditioned air code don't use air

01:01:00,580 --> 01:01:06,340
condition category defines the devayne a

01:01:03,190 --> 01:01:09,160
domain the domain is your games and each

01:01:06,340 --> 01:01:10,690
module each subsystem many domains are

01:01:09,160 --> 01:01:12,850
probably gonna be what you end up you'd

01:01:10,690 --> 01:01:16,060
have one big one if you want but we tend

01:01:12,850 --> 01:01:17,920
to break out many and system category

01:01:16,060 --> 01:01:19,710
it's ready to go right now you know all

01:01:17,920 --> 01:01:21,359
the POSIX stuff just use

01:01:19,710 --> 01:01:23,220
pass them return and populate them test

01:01:21,359 --> 01:01:24,869
against them they work we kind of know

01:01:23,220 --> 01:01:26,970
what they are it's it's not the

01:01:24,869 --> 01:01:28,740
universal domain it's a it's a domain

01:01:26,970 --> 01:01:32,670
that is establishing common scenarios

01:01:28,740 --> 01:01:37,380
that we can all share and this is kind

01:01:32,670 --> 01:01:39,599
of the e-news are doing our sin

01:01:37,380 --> 01:01:41,190
template metaprogramming type promotion

01:01:39,599 --> 01:01:44,040
to get the association of the magic

01:01:41,190 --> 01:01:45,630
cross domain semantic mapping stuff so

01:01:44,040 --> 01:01:48,270
that's it as a user you're just using

01:01:45,630 --> 01:01:49,770
Eames strong names wiki names any names

01:01:48,270 --> 01:01:52,320
you don't have to use you names using

01:01:49,770 --> 01:01:54,900
names it's just easier so converting

01:01:52,320 --> 01:01:56,609
names to stereo code and then so I

01:01:54,900 --> 01:01:57,960
really am done don't write bad messages

01:01:56,609 --> 01:01:59,910
do write good messages it's kind of like

01:01:57,960 --> 01:02:03,240
public service stuff content consumer

01:01:59,910 --> 01:02:05,400
this is what a message looks like where

01:02:03,240 --> 01:02:07,140
it came from what occurred how system

01:02:05,400 --> 01:02:08,550
responded with the user should do that's

01:02:07,140 --> 01:02:10,349
what a message should look like

01:02:08,550 --> 01:02:12,150
I mean these are good messages but you

01:02:10,349 --> 01:02:14,250
know talk about that so I'm done

01:02:12,150 --> 01:02:15,690
so thinking these people if there's a

01:02:14,250 --> 01:02:20,430
lot of offline kind of discussion on

01:02:15,690 --> 01:02:25,140
stuff and what are you thoughts oh wait

01:02:20,430 --> 01:02:27,060
should you use air code yes okay and

01:02:25,140 --> 01:02:28,980
nobody needs to know anything beyond

01:02:27,060 --> 01:02:32,730
enums really except the library author

01:02:28,980 --> 01:02:33,960
does ten minutes of copy-paste and then

01:02:32,730 --> 01:02:35,609
now you've got a big exam that just

01:02:33,960 --> 01:02:37,349
keeps growing and that's it this is like

01:02:35,609 --> 01:02:39,839
brain guide the easiest best you're ever

01:02:37,349 --> 01:02:42,240
gonna get for establishing common error

01:02:39,839 --> 01:02:43,680
interchange so prior to this we didn't

01:02:42,240 --> 01:02:47,280
have a way interchange now we have

01:02:43,680 --> 01:02:48,780
stable API ABI is api's and bi so you

01:02:47,280 --> 01:02:51,000
don't even have to recompile you can

01:02:48,780 --> 01:02:53,640
dynamically load in modules that have

01:02:51,000 --> 01:02:55,320
their own domains not even make compile

01:02:53,640 --> 01:02:57,510
it's just a runtime load and everything

01:02:55,320 --> 01:03:00,150
works because the type erasure is

01:02:57,510 --> 01:03:01,770
through severe category so you can write

01:03:00,150 --> 01:03:03,270
your own and what they were writing part

01:03:01,770 --> 01:03:04,920
of this was basically this that's why

01:03:03,270 --> 01:03:08,810
the standardizing so pretty

01:03:04,920 --> 01:03:11,640
straightforward any anybody using it now

01:03:08,810 --> 01:03:12,960
their code yeah it's it's in the file

01:03:11,640 --> 01:03:15,270
system networking - yes

01:03:12,960 --> 01:03:16,800
so okay there's a few I know we're kind

01:03:15,270 --> 01:03:20,359
of tired time so anybody have any

01:03:16,800 --> 01:03:20,359
questions or comments

01:03:30,869 --> 01:03:41,289
yes yeah there's a debate on that I'm in

01:03:38,950 --> 01:03:44,470
the camp where the boolean state is not

01:03:41,289 --> 01:03:46,029
helpful so a zero value a default

01:03:44,470 --> 01:03:48,880
constructed or one that was explicitly

01:03:46,029 --> 01:03:51,010
cleared that'll have the value 0 so if

01:03:48,880 --> 01:03:53,470
boolean tests it'll return false I don't

01:03:51,010 --> 01:03:55,869
have any state it's ambiguous as to

01:03:53,470 --> 01:03:57,490
whether or not I called a function who

01:03:55,869 --> 01:03:59,680
said everything was good and they

01:03:57,490 --> 01:04:02,740
populated it with something that's not 0

01:03:59,680 --> 01:04:04,510
but I started the asynchronous process I

01:04:02,740 --> 01:04:06,519
successfully closed that handle whatever

01:04:04,510 --> 01:04:08,769
it is because an error doesn't mean an

01:04:06,519 --> 01:04:10,809
error it just means this scenario is

01:04:08,769 --> 01:04:14,740
information to the user so I would

01:04:10,809 --> 01:04:16,510
recommend you can do the if test EC if

01:04:14,740 --> 01:04:19,299
you want to then decide whether or not

01:04:16,510 --> 01:04:21,010
you want to Streatley run them but that

01:04:19,299 --> 01:04:22,930
that's all it would tell you it won't

01:04:21,010 --> 01:04:24,099
tell you whether it's good or bad it

01:04:22,930 --> 01:04:27,279
just tells you whether or not there's

01:04:24,099 --> 01:04:32,140
payload in there so I tend to not use

01:04:27,279 --> 01:04:33,670
the if boolean test but but if that's a

01:04:32,140 --> 01:04:34,779
point of debate it is relatively new

01:04:33,670 --> 01:04:38,309
we're still kind of working on the

01:04:34,779 --> 01:04:38,309
paradigm for composition

01:04:41,700 --> 01:04:49,440
as usual as usual it's an awesome talk

01:04:47,010 --> 01:04:51,630
and I love the pictures so there's only

01:04:49,440 --> 01:04:54,210
one fundamental question I have to ask

01:04:51,630 --> 01:04:56,880
if what you're trying to do is present

01:04:54,210 --> 01:04:59,610
something to people so they understand

01:04:56,880 --> 01:05:01,710
what's going on and if they can map on

01:04:59,610 --> 01:05:04,950
to the message that they get what's

01:05:01,710 --> 01:05:08,360
actually going on in the code this is

01:05:04,950 --> 01:05:12,030
great the problem is that I see is that

01:05:08,360 --> 01:05:17,820
you can have a fixed number of error

01:05:12,030 --> 01:05:19,710
codes because those codes at the bottom

01:05:17,820 --> 01:05:21,450
of the system that say here's my slowly

01:05:19,710 --> 01:05:29,610
growing set of enumerated error codes

01:05:21,450 --> 01:05:31,020
yeah the system gets larger and larger

01:05:29,610 --> 01:05:32,670
and larger and of course these error

01:05:31,020 --> 01:05:34,890
codes are compiled into everything and

01:05:32,670 --> 01:05:37,530
then one fine day you go you know what

01:05:34,890 --> 01:05:39,690
that's not quite the right message it's

01:05:37,530 --> 01:05:41,640
almost right you know what I don't want

01:05:39,690 --> 01:05:44,030
to recompile the world we use that one

01:05:41,640 --> 01:05:46,290
mm-hmm and then things start to go south

01:05:44,030 --> 01:05:48,750
and then eventually you say you know

01:05:46,290 --> 01:05:50,370
what I'm just gonna say error because I

01:05:48,750 --> 01:05:51,540
don't have a code for that and I'm just

01:05:50,370 --> 01:05:52,620
gonna use that and that's when things

01:05:51,540 --> 01:05:55,290
have gone way too far

01:05:52,620 --> 01:05:57,090
so the thing that I'm wrestling with is

01:05:55,290 --> 01:05:59,370
I like all of those I think that's great

01:05:57,090 --> 01:06:01,410
it does what what you want it to do but

01:05:59,370 --> 01:06:04,110
the tension is when you're dealing with

01:06:01,410 --> 01:06:07,380
a function there are typically two or

01:06:04,110 --> 01:06:08,940
three or four maybe five ways that you

01:06:07,380 --> 01:06:09,870
can respond to the different kinds of

01:06:08,940 --> 01:06:12,150
things that could go wrong it either

01:06:09,870 --> 01:06:14,850
worked or didn't work and it didn't work

01:06:12,150 --> 01:06:17,970
there are five different things but

01:06:14,850 --> 01:06:20,700
naming them and saying this is a read

01:06:17,970 --> 01:06:23,790
error right here whatever has to be

01:06:20,700 --> 01:06:25,500
filtered through every humans brain and

01:06:23,790 --> 01:06:27,900
come out the other side and I mean thank

01:06:25,500 --> 01:06:29,820
you that if we apply that test to

01:06:27,900 --> 01:06:31,650
everybody in this room it will not be

01:06:29,820 --> 01:06:34,350
the same a new that comes out every time

01:06:31,650 --> 01:06:37,830
right and that is my biggest concern and

01:06:34,350 --> 01:06:41,490
to end that go long premises at the

01:06:37,830 --> 01:06:44,130
other side of the point when you have an

01:06:41,490 --> 01:06:46,710
individual function somewhere in the

01:06:44,130 --> 01:06:49,080
documentation it has to say here are the

01:06:46,710 --> 01:06:49,740
four flow of control points and I am

01:06:49,080 --> 01:06:52,530
going to

01:06:49,740 --> 01:06:55,470
as the function not this name which is a

01:06:52,530 --> 01:06:58,500
pure mnemonic on to this branch right

01:06:55,470 --> 01:07:02,330
the person will take yes and my question

01:06:58,500 --> 01:07:02,330
is how do you result what I just said

01:07:05,270 --> 01:07:10,710
yeah I think that's a an excellent

01:07:08,010 --> 01:07:13,619
observation and if I can kind of

01:07:10,710 --> 01:07:17,460
summarize your summary and and see if it

01:07:13,619 --> 01:07:19,830
Maps there is a problem with air cook

01:07:17,460 --> 01:07:21,960
curation you know the curating of

01:07:19,830 --> 01:07:23,640
ever-growing piles of stuff is like the

01:07:21,960 --> 01:07:25,920
curating of ever-growing piles of stuff

01:07:23,640 --> 01:07:28,380
in a museum you have to manage them and

01:07:25,920 --> 01:07:30,930
redefine them and reclass them and and

01:07:28,380 --> 01:07:33,180
that's a maintenance point it it gets

01:07:30,930 --> 01:07:34,350
too big and it becomes unwieldy and then

01:07:33,180 --> 01:07:37,050
people just pick what they think is

01:07:34,350 --> 01:07:38,910
closest that's problematic the air code

01:07:37,050 --> 01:07:40,260
design is encouraging you to create new

01:07:38,910 --> 01:07:42,810
domains when you have these new

01:07:40,260 --> 01:07:44,160
localized reasoned context things and it

01:07:42,810 --> 01:07:46,200
handles the cross domain semantic

01:07:44,160 --> 01:07:49,440
mapping but your other point which is an

01:07:46,200 --> 01:07:51,840
excellent point is you called me and I'm

01:07:49,440 --> 01:07:53,310
telling you this is what I saw and for

01:07:51,840 --> 01:07:55,920
me my function there's only four things

01:07:53,310 --> 01:07:58,290
and it's one of these four and if you

01:07:55,920 --> 01:08:00,150
are very discretely representing in the

01:07:58,290 --> 01:08:02,040
documentation of the function here's how

01:08:00,150 --> 01:08:04,590
I communicate to the caller which of the

01:08:02,040 --> 01:08:06,720
four it is you could have had a domain

01:08:04,590 --> 01:08:08,820
in air category with those four things

01:08:06,720 --> 01:08:11,100
but cheating after you could you just do

01:08:08,820 --> 01:08:13,980
an aunt or something else and that's

01:08:11,100 --> 01:08:16,470
discrete that makes curation easier

01:08:13,980 --> 01:08:17,250
because your curation is only for that

01:08:16,470 --> 01:08:21,930
function

01:08:17,250 --> 01:08:25,640
but the interoperability it is now not

01:08:21,930 --> 01:08:28,770
comparable to a POSIX error code or

01:08:25,640 --> 01:08:30,270
Accio or other domain stuff so if you

01:08:28,770 --> 01:08:32,220
have an error scenario that basically

01:08:30,270 --> 01:08:35,160
saying disk is full and you've defined

01:08:32,220 --> 01:08:37,500
your own local disk is full you didn't

01:08:35,160 --> 01:08:40,080
do the mapping to the standard version

01:08:37,500 --> 01:08:42,720
of disk is full if that mapping was

01:08:40,080 --> 01:08:45,600
important error code is useful if it's

01:08:42,720 --> 01:09:02,170
not that local reasoning I think is

01:08:45,600 --> 01:09:04,239
easier to maintain right

01:09:02,170 --> 01:09:07,509
doesn't matter because nothing Maps on

01:09:04,239 --> 01:09:08,770
this right yeah and then the user if

01:09:07,509 --> 01:09:10,779
they want to do the mapping they can

01:09:08,770 --> 01:09:14,049
take that discrete well-understood thing

01:09:10,779 --> 01:09:16,029
and they can map it themselves and yes

01:09:14,049 --> 01:09:17,710
so I think that's an excellent

01:09:16,029 --> 01:09:20,890
observation because what is not on here

01:09:17,710 --> 01:09:23,290
 gonna go but error code curation

01:09:20,890 --> 01:09:25,000
is its own world and that's a big

01:09:23,290 --> 01:09:27,339
discipline like all code maintenance is

01:09:25,000 --> 01:09:28,900
so this doesn't solve that just just

01:09:27,339 --> 01:09:31,630
gives you an easy way to make a new

01:09:28,900 --> 01:10:16,060
domain that happens to be mapable

01:09:31,630 --> 01:10:18,219
to other domains yeah they're two

01:10:16,060 --> 01:10:20,590
answers the first one is it handles are

01:10:18,219 --> 01:10:22,660
great if you have a thousand domains

01:10:20,590 --> 01:10:24,250
they're all type race to air code

01:10:22,660 --> 01:10:25,929
they're all handled perfectly they're

01:10:24,250 --> 01:10:28,210
all dynamically loaded and they all

01:10:25,929 --> 01:10:30,540
interact interoperate just fine so on

01:10:28,210 --> 01:10:35,500
the mechanical stable API a bi-level

01:10:30,540 --> 01:10:37,449
you're good what's not good is I'm

01:10:35,500 --> 01:10:40,090
writing a domain and I don't know all

01:10:37,449 --> 01:10:41,770
the other domains that may exist and the

01:10:40,090 --> 01:10:43,239
cheaters approach which is a pretty good

01:10:41,770 --> 01:10:46,750
approach and don't knock the cheaters

01:10:43,239 --> 01:10:49,870
approach is I I can basically map my

01:10:46,750 --> 01:10:51,070
stuff to the POSIX ones because those

01:10:49,870 --> 01:10:54,520
are kind of understood

01:10:51,070 --> 01:10:56,230
it's lossy but once I do that mapping I

01:10:54,520 --> 01:10:59,650
know everybody else knows what the POSIX

01:10:56,230 --> 01:11:02,860
ones are so as long as the domain author

01:10:59,650 --> 01:11:05,590
does that mapping you can kind of be

01:11:02,860 --> 01:11:08,260
blissfully ignorant of the other domains

01:11:05,590 --> 01:11:11,469
out there and what'll tend to happen is

01:11:08,260 --> 01:11:13,870
some domains will organically grow azio

01:11:11,469 --> 01:11:15,550
is a networking TS kind of problem they

01:11:13,870 --> 01:11:17,739
have networking domain kind of

01:11:15,550 --> 01:11:19,719
codes in a much richer level or

01:11:17,739 --> 01:11:21,790
different level than the POSIX ones so

01:11:19,719 --> 01:11:23,650
mapping to the POSIX well if I'm

01:11:21,790 --> 01:11:25,480
actually writing another network II kind

01:11:23,650 --> 01:11:28,300
of thing it could be I'm better off

01:11:25,480 --> 01:11:30,579
mapping sort of the the Azio organ

01:11:28,300 --> 01:11:32,710
organically understood ones and that

01:11:30,579 --> 01:11:35,400
that's a gateway into other domain

01:11:32,710 --> 01:11:38,110
mapping and the the goal would be

01:11:35,400 --> 01:11:42,400
equivalence just works as long as every

01:11:38,110 --> 01:11:44,469
author maps to something that's relevant

01:11:42,400 --> 01:11:46,900
like I'm mapping to networking or a

01:11:44,469 --> 01:11:50,139
mapping to POSIX or a mapping to you

01:11:46,900 --> 01:11:53,320
know my industries pile of kind of

01:11:50,139 --> 01:11:54,969
commonly seen errors that's that's the

01:11:53,320 --> 01:11:56,320
localized reasoning that the library

01:11:54,969 --> 01:11:57,000
author is supposed to be able to rely

01:11:56,320 --> 01:11:59,349
upon

01:11:57,000 --> 01:12:00,790
you're not gonna map to a thousand

01:11:59,349 --> 01:12:03,159
domains that's insane you can't it's not

01:12:00,790 --> 01:12:05,980
possible but you should probably map

01:12:03,159 --> 01:12:08,619
organically to some common interchange

01:12:05,980 --> 01:12:10,329
II ones which is all the positives one

01:12:08,619 --> 01:12:11,920
is it's sort of a interchanging it's not

01:12:10,329 --> 01:12:22,230
the standard one it's a common

01:12:11,920 --> 01:12:22,230
interchange e1o

01:12:23,050 --> 01:12:26,920
it'll be big compiler dependent but it's

01:12:25,480 --> 01:12:28,900
going to be static data if you want to

01:12:26,920 --> 01:12:30,940
the minimum it's all static data and

01:12:28,900 --> 01:12:32,619
it's your string table and whatever the

01:12:30,940 --> 01:12:43,179
representation is for the Union which is

01:12:32,619 --> 01:12:45,400
probably nothing oh the air category is

01:12:43,179 --> 01:12:47,020
a singleton the the static linker will

01:12:45,400 --> 01:13:06,849
establish its placement in memory in

01:12:47,020 --> 01:13:08,290
some one and only one place yes that's a

01:13:06,849 --> 01:13:11,170
really good observation and that's the

01:13:08,290 --> 01:13:13,389
trick of unions so so you can locally

01:13:11,170 --> 01:13:15,880
just say I have a bunch of domains and

01:13:13,389 --> 01:13:17,800
you establish the mapping but in the

01:13:15,880 --> 01:13:20,530
hierarchy approach the trick with the

01:13:17,800 --> 01:13:21,849
Enuma is this section of enums is kind

01:13:20,530 --> 01:13:23,349
of mapped to that other name that's

01:13:21,849 --> 01:13:25,540
already defined and you're kind of

01:13:23,349 --> 01:13:26,730
establishing an inheritance hierarchy of

01:13:25,540 --> 01:13:30,720
enumerated State

01:13:26,730 --> 01:13:38,100
so because it's Justi NIMS it lends well

01:13:30,720 --> 01:13:42,050
to e Nimish inheritance yes anything

01:13:38,100 --> 01:13:42,050

YouTube URL: https://www.youtube.com/watch?v=hNaLf8lYLDo


