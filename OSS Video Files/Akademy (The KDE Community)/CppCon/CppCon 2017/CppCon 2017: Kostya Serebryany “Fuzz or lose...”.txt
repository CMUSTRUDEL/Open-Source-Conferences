Title: CppCon 2017: Kostya Serebryany “Fuzz or lose...”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	Fuzz or lose: why and how to make fuzzing a standard practice for C++

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Fuzzing is a family of testing techniques in which test inputs are generated semi-randomly. The memory unsafety of C++ has made fuzzing a popular tool among security researchers. Fuzzing also helps with stability, performance, and equivalence testing; and it’s a great addition to everyone’s CI. 

Our team has launched OSS-Fuzz, the Google's continuous fuzzing service for open source software, and a similar service for our internal C++ developers. Over 1000 C++ APIs are being fuzzed automatically 24/7, and thousands of bugs have been found and fixed. 

Now we want to share this experience with the wider C++ community and make fuzzing a part of everyone’s toolbox, alongside unit tests. We will demonstrate how you can fuzz your C++ library with minimal effort, discuss fuzzing of highly structured inputs, and speculate on potential fuzzing-related improvements to C++. 
— 
Kostya Serebryany: Google, Software Engineer

Websiteresearch.google.com/pubs/KonstantinSerebryany.html
Konstantin (Kostya) Serebryany is a Software Engineer at Google. His team develops and deploys dynamic testing tools, such as AddressSanitizer and ThreadSanitizer. Prior to joining Google in 2007, Konstantin spent 4 years at Elbrus/MCST working for Sun compiler lab and then 3 years at Intel Compiler Lab. Konstantin holds a PhD from mesi.ru and a Master from msu.ru.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,670
good afternoon and thank you for coming

00:00:02,370 --> 00:00:09,300
for the last afternoon session I

00:00:05,670 --> 00:00:10,950
appreciate that you're tired but I hope

00:00:09,300 --> 00:00:13,259
to wake you up a little bit

00:00:10,950 --> 00:00:16,949
my name is cuesta I work at Google and

00:00:13,259 --> 00:00:19,890
I'm going to talk about fashion today so

00:00:16,949 --> 00:00:23,820
I hope to explain you why we should be

00:00:19,890 --> 00:00:25,920
doing phasing we'll have several case

00:00:23,820 --> 00:00:28,410
studies related to fashion I will

00:00:25,920 --> 00:00:30,920
discuss continues and automated fashion

00:00:28,410 --> 00:00:34,350
which is a kind of magic

00:00:30,920 --> 00:00:36,840
and I will cover some of the challenges

00:00:34,350 --> 00:00:39,180
we face with adoption of the physique I

00:00:36,840 --> 00:00:41,340
will not cover any deep technical

00:00:39,180 --> 00:00:44,340
details today this is just half an hour

00:00:41,340 --> 00:00:47,309
talk but your questions after the talk

00:00:44,340 --> 00:00:52,500
about any kind of detail are very

00:00:47,309 --> 00:00:55,550
welcome so what is fuzzy let's first

00:00:52,500 --> 00:01:00,359
discuss what is testing in most cases

00:00:55,550 --> 00:01:03,570
testing your API means that you feed a

00:01:00,359 --> 00:01:07,409
fixed number of fixed inputs into your

00:01:03,570 --> 00:01:10,229
API and observe the behavior on the

00:01:07,409 --> 00:01:13,680
contrary fuzzing is a process where you

00:01:10,229 --> 00:01:17,960
are feeding an infinite amount of

00:01:13,680 --> 00:01:21,000
generated inputs into your API that's

00:01:17,960 --> 00:01:23,220
that's it and there are lots of

00:01:21,000 --> 00:01:26,369
different strategies for doing the

00:01:23,220 --> 00:01:29,040
fuzzing or in other ways for generating

00:01:26,369 --> 00:01:32,310
the test inputs automatically for your

00:01:29,040 --> 00:01:34,950
API I'm mostly working on so-called

00:01:32,310 --> 00:01:37,320
coverage guided fuzzing but this is all

00:01:34,950 --> 00:01:41,549
irrelevant for the today's talk today's

00:01:37,320 --> 00:01:44,939
talk covers fuzzy in general so why

00:01:41,549 --> 00:01:50,220
would you pass C++ code and please wake

00:01:44,939 --> 00:01:53,070
up so one of the reasons why you want to

00:01:50,220 --> 00:01:57,869
pass your C++ code is that because

00:01:53,070 --> 00:02:01,610
hackers love C and C++ the problem with

00:01:57,869 --> 00:02:04,530
this is that the hackers love C++ and C

00:02:01,610 --> 00:02:08,340
for different reasons not for the same

00:02:04,530 --> 00:02:12,860
reasons as you love C++ this animated

00:02:08,340 --> 00:02:15,830
gif shows you how fuzzy can find

00:02:12,860 --> 00:02:17,650
heartbleed bug in five seconds and for

00:02:15,830 --> 00:02:20,450
those of you of you who don't remember

00:02:17,650 --> 00:02:22,760
heartbleed is a bug that shocked the

00:02:20,450 --> 00:02:25,340
industry the internet about three years

00:02:22,760 --> 00:02:29,510
ago and I've presented this thing at

00:02:25,340 --> 00:02:34,790
cific on two years ago so did I hear any

00:02:29,510 --> 00:02:40,910
boo in the audience did I really say c /

00:02:34,790 --> 00:02:44,660
c++ on a c++ conference boo anyone yes I

00:02:40,910 --> 00:02:47,060
did say c / c++ because suppose pass

00:02:44,660 --> 00:02:50,240
unfortunately inherited a bunch of

00:02:47,060 --> 00:02:53,390
problems from the c language the the

00:02:50,240 --> 00:02:55,400
major one in my in my view is the set of

00:02:53,390 --> 00:02:58,280
memory safety bugs such as buffer

00:02:55,400 --> 00:03:02,660
overflows use of the fries uses

00:02:58,280 --> 00:03:04,730
financialized memory and so on every

00:03:02,660 --> 00:03:11,080
time I say something like this suppose

00:03:04,730 --> 00:03:15,350
was inherited blah blah blah I hear I

00:03:11,080 --> 00:03:17,420
hear that come on mother in C++ doesn't

00:03:15,350 --> 00:03:20,989
have those things I've heard this when

00:03:17,420 --> 00:03:25,910
C++ 11 appeared on C++ 14 appeared and I

00:03:20,989 --> 00:03:29,269
keep hearing now so I have a few things

00:03:25,910 --> 00:03:34,690
to say about modern C++ but let me say

00:03:29,269 --> 00:03:38,630
just one thing so this is a modern C++

00:03:34,690 --> 00:03:41,750
the class called STD string view has

00:03:38,630 --> 00:03:43,850
just appeared in C++ 17 who can spot the

00:03:41,750 --> 00:03:48,049
bug in this code snippet raise your hand

00:03:43,850 --> 00:03:50,269
okay so quite a few of you can spot the

00:03:48,049 --> 00:03:56,360
bug but quite a few of you cannot or are

00:03:50,269 --> 00:03:59,180
sleeping anyone else okay so that's a he

00:03:56,360 --> 00:04:03,709
buffer overflow we're creating a

00:03:59,180 --> 00:04:06,980
temporary object which is a result of

00:04:03,709 --> 00:04:09,019
concatenating two 3s two strings we take

00:04:06,980 --> 00:04:10,910
the reference to the temporary object in

00:04:09,019 --> 00:04:13,820
a string view then the object is

00:04:10,910 --> 00:04:15,549
destroyed and then we use the reference

00:04:13,820 --> 00:04:18,380
to the destroyed object oops

00:04:15,549 --> 00:04:22,099
any kind of sane memory error detection

00:04:18,380 --> 00:04:23,990
tool for C++ will report this bug if you

00:04:22,099 --> 00:04:24,430
execute this code while testing with

00:04:23,990 --> 00:04:28,389
this

00:04:24,430 --> 00:04:32,740
memory safety - please get a little bit

00:04:28,389 --> 00:04:36,460
more sophisticated if you just remove a

00:04:32,740 --> 00:04:38,199
few characters from this example if

00:04:36,460 --> 00:04:41,169
instead of using hello

00:04:38,199 --> 00:04:43,780
but many O's you use hello with just a

00:04:41,169 --> 00:04:47,350
few O's it will become a different bug

00:04:43,780 --> 00:04:50,229
at least as it is implemented in lip C++

00:04:47,350 --> 00:04:53,020
because this is now a short string

00:04:50,229 --> 00:04:54,729
optimization no heap memories involved

00:04:53,020 --> 00:04:59,169
this is still a bug but slightly

00:04:54,729 --> 00:05:02,620
different so modern C++ you said let's

00:04:59,169 --> 00:05:06,610
fast some really modern C++ I don't have

00:05:02,620 --> 00:05:09,789
anything written lips in C++ 17 because

00:05:06,610 --> 00:05:12,850
the standard is two days old but they

00:05:09,789 --> 00:05:15,100
have something written in proper C++ 11

00:05:12,850 --> 00:05:18,570
this is a relatively small library

00:05:15,100 --> 00:05:22,840
called wolf 2 which handles web fonts I

00:05:18,570 --> 00:05:27,820
would say that 50% of you have both - in

00:05:22,840 --> 00:05:31,000
your pocket in your phone so it is a C++

00:05:27,820 --> 00:05:34,120
11 library the team follows a strict

00:05:31,000 --> 00:05:37,690
coding style was it was possible the

00:05:34,120 --> 00:05:39,820
team uses code review the team has unit

00:05:37,690 --> 00:05:42,280
tests the unit tests are running on

00:05:39,820 --> 00:05:44,800
continuous integration the code uses a

00:05:42,280 --> 00:05:48,460
steel containers iterators namespaces

00:05:44,800 --> 00:05:51,220
and they even bells and whistles it

00:05:48,460 --> 00:05:53,740
didn't help when we started fighting

00:05:51,220 --> 00:05:57,280
this code who almost immediately found a

00:05:53,740 --> 00:06:00,729
buffer overflow which is a right of 12

00:05:57,280 --> 00:06:02,530
kilobytes outside of the buffer and just

00:06:00,729 --> 00:06:05,420
imagine this thing is running on your

00:06:02,530 --> 00:06:08,370
mobile phone and this

00:06:05,420 --> 00:06:11,730
processing data that you received from

00:06:08,370 --> 00:06:16,770
internet from untrusted sources so you

00:06:11,730 --> 00:06:21,420
probably care about fuzzy I agree okay

00:06:16,770 --> 00:06:25,140
so you're not good and now let me show

00:06:21,420 --> 00:06:27,930
you how much effort did we spend to find

00:06:25,140 --> 00:06:31,200
those memory issues involved this was

00:06:27,930 --> 00:06:33,390
not the only memory she removed so this

00:06:31,200 --> 00:06:36,840
snippet of code and we call it the fuzz

00:06:33,390 --> 00:06:39,930
target it is a single function that

00:06:36,840 --> 00:06:43,980
consumes an array of bytes and that uses

00:06:39,930 --> 00:06:47,490
this array of bytes to feed them into

00:06:43,980 --> 00:06:49,890
the API you want to fast I want to

00:06:47,490 --> 00:06:54,000
emphasize this is all the effort

00:06:49,890 --> 00:06:58,560
required to fuzz that library and to

00:06:54,000 --> 00:07:02,250
find bugs in it and we found it with

00:06:58,560 --> 00:07:05,160
leap buzzer you can find it with many

00:07:02,250 --> 00:07:08,040
other fuzzy engines the same way let me

00:07:05,160 --> 00:07:11,370
just show you how easy it is to do

00:07:08,040 --> 00:07:14,160
things with me buzzer so suppose you

00:07:11,370 --> 00:07:18,170
have this first target in a separate

00:07:14,160 --> 00:07:21,540
file fast dot C C this is fast dot C C

00:07:18,170 --> 00:07:25,470
and you have all other files of your

00:07:21,540 --> 00:07:29,010
library of your API somewhere else all

00:07:25,470 --> 00:07:32,160
you need to do is get fresh clean this

00:07:29,010 --> 00:07:34,260
is all pretty new development compile

00:07:32,160 --> 00:07:37,770
all your code including the first target

00:07:34,260 --> 00:07:39,840
with a couple special switches EPS init

00:07:37,770 --> 00:07:43,370
eyes address gives your memory safety

00:07:39,840 --> 00:07:45,630
checking and buzzer gives you

00:07:43,370 --> 00:07:48,690
instrumentation required for coverage

00:07:45,630 --> 00:07:52,440
guided phasing and it also adds some

00:07:48,690 --> 00:07:55,080
library at link time then you want to

00:07:52,440 --> 00:08:00,230
create a directory where you will put

00:07:55,080 --> 00:08:04,250
some samples for the inputs of your API

00:08:00,230 --> 00:08:08,120
and then you just run the resulting

00:08:04,250 --> 00:08:11,430
binary on this directory this is it so I

00:08:08,120 --> 00:08:14,550
hope I convinced you that fuzzing is

00:08:11,430 --> 00:08:16,770
pretty simple a few words about the

00:08:14,550 --> 00:08:18,360
concept of first target as we understand

00:08:16,770 --> 00:08:21,870
it so again a faster

00:08:18,360 --> 00:08:24,030
in our current definition is air

00:08:21,870 --> 00:08:26,719
function with a fixed signature that

00:08:24,030 --> 00:08:29,189
consumes an array of bytes and then that

00:08:26,719 --> 00:08:34,589
inside that function you use the array

00:08:29,189 --> 00:08:38,719
of bytes with your API in whatever way

00:08:34,589 --> 00:08:42,719
you want to the first target should be

00:08:38,719 --> 00:08:45,029
tolerable to any kind of data and any

00:08:42,719 --> 00:08:46,890
kind of crash or abort or assertion

00:08:45,029 --> 00:08:49,649
failure or timeout or out of memory

00:08:46,890 --> 00:08:51,570
should be considered the bug if not I

00:08:49,649 --> 00:08:55,529
would say that your code is not really

00:08:51,570 --> 00:08:59,310
an API this first target should be

00:08:55,529 --> 00:09:01,500
single process it should be ideally

00:08:59,310 --> 00:09:04,310
deterministic if you need randomness get

00:09:01,500 --> 00:09:06,630
the random bits from the input

00:09:04,310 --> 00:09:08,790
preferably it should not modify global

00:09:06,630 --> 00:09:11,310
state although we can tolerate this and

00:09:08,790 --> 00:09:13,800
the smaller the target is the more

00:09:11,310 --> 00:09:16,440
efficient will be the phasing although

00:09:13,800 --> 00:09:22,050
we can fast arbitrary large targets if

00:09:16,440 --> 00:09:25,430
we have enough CPU power so far we

00:09:22,050 --> 00:09:28,529
discussed mostly memory safety bugs but

00:09:25,430 --> 00:09:31,440
stability and security of an application

00:09:28,529 --> 00:09:36,149
not necessarily plus plus application is

00:09:31,440 --> 00:09:38,699
much more than just memory safety let me

00:09:36,149 --> 00:09:42,930
give you another example which I hope is

00:09:38,699 --> 00:09:44,730
suitable for C++ conference eight months

00:09:42,930 --> 00:09:47,010
ago my colleague nutiva Cook has

00:09:44,730 --> 00:09:51,959
submitted a single ticket against boost

00:09:47,010 --> 00:09:55,800
reg X library and this is literally the

00:09:51,959 --> 00:09:59,100
ticket so in just half an hour

00:09:55,800 --> 00:10:01,070
Dimitri found memory safety issues of

00:09:59,100 --> 00:10:04,920
different kinds assertion failures

00:10:01,070 --> 00:10:06,949
segmentation faults infinite loops bunch

00:10:04,920 --> 00:10:11,430
of leaks and so on

00:10:06,949 --> 00:10:13,079
and this is the effort he needed to

00:10:11,430 --> 00:10:15,360
spend to fast

00:10:13,079 --> 00:10:17,540
boost reg expand find those couple

00:10:15,360 --> 00:10:21,290
doesn't libraries again these are just

00:10:17,540 --> 00:10:23,820
half a dozen lines that have no

00:10:21,290 --> 00:10:26,910
complicated logic in them all you do is

00:10:23,820 --> 00:10:27,730
you take the data provided by the

00:10:26,910 --> 00:10:30,910
thousand

00:10:27,730 --> 00:10:35,709
and you feed it into your API and this

00:10:30,910 --> 00:10:38,139
is what you get those many bugs I'm very

00:10:35,709 --> 00:10:41,649
grateful to the boost developers for

00:10:38,139 --> 00:10:44,860
fixing all of those bugs very promptly

00:10:41,649 --> 00:10:47,529
this this is great like not all of not

00:10:44,860 --> 00:10:50,920
all of the developers who get reports

00:10:47,529 --> 00:10:53,589
from us fix the bugs boost did but the

00:10:50,920 --> 00:10:55,839
problem was that continuous fighting was

00:10:53,589 --> 00:10:57,699
never set up and I want to emphasize

00:10:55,839 --> 00:11:00,519
that continuous fighting is much

00:10:57,699 --> 00:11:02,380
stronger than just fuzzy for reasons I

00:11:00,519 --> 00:11:05,829
hope you understand the these are the

00:11:02,380 --> 00:11:10,870
same reasons why testing is not enough

00:11:05,829 --> 00:11:14,170
and continuous testing is much better so

00:11:10,870 --> 00:11:15,880
I have Kevin boost regards to the

00:11:14,170 --> 00:11:18,269
continuous phase insurance which I'm

00:11:15,880 --> 00:11:20,889
going to talk about on next slide

00:11:18,269 --> 00:11:22,959
and that happens happened last Thursday

00:11:20,889 --> 00:11:25,779
evening because I was preparing my

00:11:22,959 --> 00:11:31,120
slides and I realized that something is

00:11:25,779 --> 00:11:34,000
missing on these slides yes on Saturday

00:11:31,120 --> 00:11:37,360
5 bugs appeared on the continuous phase

00:11:34,000 --> 00:11:40,329
in service in boost and Sun daily last

00:11:37,360 --> 00:11:42,040
night two more popped up and one of them

00:11:40,329 --> 00:11:47,560
was actually memory safety bargain boost

00:11:42,040 --> 00:11:49,600
stack buffer overflow if anyone here is

00:11:47,560 --> 00:11:53,649
from boost I will try to catch you

00:11:49,600 --> 00:12:00,160
tomorrow at the boost dinner so that we

00:11:53,649 --> 00:12:02,079
can fast morale boost so a few words

00:12:00,160 --> 00:12:04,000
about the continuous fighting service

00:12:02,079 --> 00:12:07,389
I've mentioned the service is called

00:12:04,000 --> 00:12:09,790
OSS fast we have launched it December

00:12:07,389 --> 00:12:12,610
last year which is and the project is a

00:12:09,790 --> 00:12:15,550
collaboration between quite a few teams

00:12:12,610 --> 00:12:18,300
at Google the project provides

00:12:15,550 --> 00:12:21,990
continuous and automated fuzzy of

00:12:18,300 --> 00:12:25,839
open-source projects on Google hardware

00:12:21,990 --> 00:12:28,779
it uses two different fuzzing engines

00:12:25,839 --> 00:12:32,050
right now Lib phaser and FL more fuzzing

00:12:28,779 --> 00:12:35,070
engines are in pipeline and the service

00:12:32,050 --> 00:12:38,040
also uses the sanitizers agent I am

00:12:35,070 --> 00:12:42,839
and you bacin to actually find bugs at

00:12:38,040 --> 00:12:44,690
runtime this project is available to

00:12:42,839 --> 00:12:50,220
what we'll call important open source

00:12:44,690 --> 00:12:54,509
projects and we don't it's provided for

00:12:50,220 --> 00:12:56,759
free we haven't built this thing from

00:12:54,509 --> 00:12:58,980
stretch instead we reuse the same

00:12:56,759 --> 00:13:00,990
infrastructure that were using for the

00:12:58,980 --> 00:13:05,459
last two years to fast the components of

00:13:00,990 --> 00:13:08,730
the chromium browser and this slide

00:13:05,459 --> 00:13:11,029
shows some of our trophies so in less

00:13:08,730 --> 00:13:14,519
than a year the service have reported

00:13:11,029 --> 00:13:18,540
2,000 bugs to more than 60 different

00:13:14,519 --> 00:13:21,300
open source projects and this is the

00:13:18,540 --> 00:13:24,029
slide from a months ago now the numbers

00:13:21,300 --> 00:13:27,839
I even better as you can see it there is

00:13:24,029 --> 00:13:29,790
a usual set of suspects memory safety

00:13:27,839 --> 00:13:32,040
bugs buffer overflows and use of the

00:13:29,790 --> 00:13:33,779
free but there is lots of other types of

00:13:32,040 --> 00:13:37,500
Bart's like out of memories timeouts

00:13:33,779 --> 00:13:39,300
leaks the largest sections the largest

00:13:37,500 --> 00:13:41,639
section comes comes from the tool called

00:13:39,300 --> 00:13:43,920
ibis an undefined behavior sanitizer

00:13:41,639 --> 00:13:48,029
these are basically signed integer

00:13:43,920 --> 00:13:52,370
overflows and shifts by large numbers

00:13:48,029 --> 00:13:52,370
like you're shifting left by 1000

00:13:54,199 --> 00:13:59,430
someone at this conference have already

00:13:56,730 --> 00:14:01,050
asked me so what if I don't have an open

00:13:59,430 --> 00:14:04,199
source project what if my project is

00:14:01,050 --> 00:14:06,930
closed source in the current form the

00:14:04,199 --> 00:14:10,709
service is only provided for the open

00:14:06,930 --> 00:14:13,470
source projects and we also don't accept

00:14:10,709 --> 00:14:16,889
toy projects the the project has to be

00:14:13,470 --> 00:14:19,529
significant but all the tools used by

00:14:16,889 --> 00:14:23,130
the service are open sourced and most of

00:14:19,529 --> 00:14:25,500
them are part of the clan LVM tool chain

00:14:23,130 --> 00:14:27,779
they're fully supported on Linux on mark

00:14:25,500 --> 00:14:31,110
and I want to thank you I want to thank

00:14:27,779 --> 00:14:34,170
the Apple developers for helping me to

00:14:31,110 --> 00:14:36,930
port these tools to mark on Windows they

00:14:34,170 --> 00:14:39,350
kind of work but you're my mileage may

00:14:36,930 --> 00:14:42,180
vary but if you are on a Windows

00:14:39,350 --> 00:14:46,350
ecosystem there is a service provided by

00:14:42,180 --> 00:14:48,980
Microsoft take a look at that one so

00:14:46,350 --> 00:14:48,980
back to five

00:14:49,490 --> 00:14:57,600
the examples have shown so far OpenSSL

00:14:53,399 --> 00:15:02,339
web fonts and booster gets those

00:14:57,600 --> 00:15:04,379
consumed pretty simple data formats to

00:15:02,339 --> 00:15:07,939
some extent these are bags of bytes not

00:15:04,379 --> 00:15:11,579
just bags of bytes but not very complex

00:15:07,939 --> 00:15:15,269
and not every api written in c++

00:15:11,579 --> 00:15:19,889
consumes simple data type so in many

00:15:15,269 --> 00:15:21,920
cases fuzzing complex data types is very

00:15:19,889 --> 00:15:24,959
inefficient because the fuzzer

00:15:21,920 --> 00:15:29,490
creates invalid inputs very frequently

00:15:24,959 --> 00:15:31,829
and nothing interesting happens so let's

00:15:29,490 --> 00:15:34,230
do another case study let's first

00:15:31,829 --> 00:15:36,959
something that consumes a very very very

00:15:34,230 --> 00:15:39,889
complicated input do you know anything

00:15:36,959 --> 00:15:44,610
that is more complicated than C++ I

00:15:39,889 --> 00:15:46,699
don't so if we can pass a C++ compiler I

00:15:44,610 --> 00:15:51,569
am pretty sure we can pass everything

00:15:46,699 --> 00:15:55,459
let's take a look so a compiler is

00:15:51,569 --> 00:15:58,379
typically a series of building blocks

00:15:55,459 --> 00:16:01,050
and roughly speaking it consists of a

00:15:58,379 --> 00:16:05,129
lexer a parser and optimizer and code

00:16:01,050 --> 00:16:08,819
generator so we first started passing

00:16:05,129 --> 00:16:13,889
clamp as a saying that consumes a bag of

00:16:08,819 --> 00:16:16,170
bytes and we found an enormous amount of

00:16:13,889 --> 00:16:19,230
interesting things for example if you

00:16:16,170 --> 00:16:21,870
put if you give the compiler these 4

00:16:19,230 --> 00:16:25,230
bytes it will do a hit buffer overflow

00:16:21,870 --> 00:16:27,930
somewhere and there are quite a few of

00:16:25,230 --> 00:16:28,860
those i've i've shown only the ones that

00:16:27,930 --> 00:16:31,079
fit on the slide

00:16:28,860 --> 00:16:33,959
so what use of the freeze we've got

00:16:31,079 --> 00:16:38,000
infinite cpu and ram consumption and all

00:16:33,959 --> 00:16:41,910
of those don't really look like c++ code

00:16:38,000 --> 00:16:45,089
would agree well the first one maybe but

00:16:41,910 --> 00:16:49,089
the second and third one maybe this is

00:16:45,089 --> 00:16:54,519
sequence plus 1220

00:16:49,089 --> 00:16:57,039
but not C++ 70 so this this was annoying

00:16:54,519 --> 00:16:59,409
because yes we were finding bugs of the

00:16:57,039 --> 00:17:01,719
compiler but we were not going anywhere

00:16:59,409 --> 00:17:06,069
deep in the compiler we wanted to get

00:17:01,719 --> 00:17:08,289
into the code Jam so we started fuzzing

00:17:06,069 --> 00:17:11,620
the sequence pause compiler in a

00:17:08,289 --> 00:17:14,620
structure aware manner such that we know

00:17:11,620 --> 00:17:17,829
that while facing C++ or a subset of C++

00:17:14,620 --> 00:17:19,870
and this is what we're good so we have

00:17:17,829 --> 00:17:21,600
implemented the toy prototype for

00:17:19,870 --> 00:17:24,639
fuzzing

00:17:21,600 --> 00:17:28,059
where we know that we fuzz that the

00:17:24,639 --> 00:17:31,659
input is a C++ and now this input that

00:17:28,059 --> 00:17:34,929
triggers an infinite loop and in LLVM it

00:17:31,659 --> 00:17:38,110
actually looks like C++ or actually it's

00:17:34,929 --> 00:17:40,899
a subset of C but this is my toy

00:17:38,110 --> 00:17:44,169
prototype and all of the bugs were found

00:17:40,899 --> 00:17:47,860
this way and for the view they trigger

00:17:44,169 --> 00:17:49,990
something inside the deepest levels of

00:17:47,860 --> 00:17:55,330
the compiler namely optimizer and code

00:17:49,990 --> 00:17:57,999
generator so how do we do this we need

00:17:55,330 --> 00:18:01,090
to provide a little bit of help to the

00:17:57,999 --> 00:18:04,330
phaser by implementing what we call a

00:18:01,090 --> 00:18:07,090
custom mutated so most of the

00:18:04,330 --> 00:18:09,669
fascinations typically mutate the the

00:18:07,090 --> 00:18:12,220
data they consume in some trivial way

00:18:09,669 --> 00:18:14,230
like like byte we've been a bit flippy

00:18:12,220 --> 00:18:16,360
and instead we need to provide a

00:18:14,230 --> 00:18:19,840
function that takes the bag of bytes

00:18:16,360 --> 00:18:22,659
parses it into abstract syntax tree or

00:18:19,840 --> 00:18:25,419
some of the structure implements one

00:18:22,659 --> 00:18:27,460
single mutation on that tree and feeds

00:18:25,419 --> 00:18:29,889
it back to the target that we want

00:18:27,460 --> 00:18:32,769
faster and we also have a support

00:18:29,889 --> 00:18:35,019
library that does all of the all of the

00:18:32,769 --> 00:18:37,289
above on the proto buffers a proto

00:18:35,019 --> 00:18:40,269
buffer is a is a library that provides

00:18:37,289 --> 00:18:44,019
HT serialization deserialization and

00:18:40,269 --> 00:18:48,549
when unhooked this library into clonk so

00:18:44,019 --> 00:18:50,710
that we can fuzz c++ not proto buffers

00:18:48,549 --> 00:18:53,590
I won't go into more details now but

00:18:50,710 --> 00:18:57,780
this was really simple and all of this

00:18:53,590 --> 00:19:00,580
code is an l vm trent now so you can

00:18:57,780 --> 00:19:04,690
by the way fuzzing also finds logical

00:19:00,580 --> 00:19:06,910
bugs this is mostly important for things

00:19:04,690 --> 00:19:11,140
like cryptography compression rendering

00:19:06,910 --> 00:19:13,300
of any kinds and it is very easy when

00:19:11,140 --> 00:19:15,580
you have two implementations of the same

00:19:13,300 --> 00:19:17,770
thing suppose you have a reference

00:19:15,580 --> 00:19:19,630
implementation of some codec or crypto

00:19:17,770 --> 00:19:21,280
primitive and an optimizer

00:19:19,630 --> 00:19:24,400
implementation and you want to verify

00:19:21,280 --> 00:19:26,770
that on every inputs they produce the

00:19:24,400 --> 00:19:28,990
same result all we need to do is to

00:19:26,770 --> 00:19:31,780
implement the first target that would

00:19:28,990 --> 00:19:35,410
call both versions of the provided input

00:19:31,780 --> 00:19:35,860
and verify that the that the output is

00:19:35,410 --> 00:19:38,380
correct

00:19:35,860 --> 00:19:41,320
we have found quite a few boards this

00:19:38,380 --> 00:19:45,550
way in cryptographic code and here is

00:19:41,320 --> 00:19:50,130
one example so raise your hand if you

00:19:45,550 --> 00:19:52,300
think that fuzzing is useful thank you

00:19:50,130 --> 00:19:59,650
now raise your hand if you think it's

00:19:52,300 --> 00:20:01,060
simple come on okay so I haven't I

00:19:59,650 --> 00:20:04,390
haven't convinced you that this is

00:20:01,060 --> 00:20:07,390
simple but even if it were simple simple

00:20:04,390 --> 00:20:11,050
plus useful is not necessary widely used

00:20:07,390 --> 00:20:14,380
and this is my pain point I want fuzzing

00:20:11,050 --> 00:20:18,070
to be widely used because it helps get

00:20:14,380 --> 00:20:20,620
rid of bugs and at Google we have

00:20:18,070 --> 00:20:22,390
reached quite good adoption of fuzzing

00:20:20,620 --> 00:20:25,090
not good enough we're still working in

00:20:22,390 --> 00:20:28,480
it but we have several thousands of fast

00:20:25,090 --> 00:20:30,340
targets across our server-side code and

00:20:28,480 --> 00:20:32,590
chromium and open-source projects

00:20:30,340 --> 00:20:37,780
developed by Google and this number is

00:20:32,590 --> 00:20:39,460
growing we were healed this because

00:20:37,780 --> 00:20:42,160
there are several things about Google

00:20:39,460 --> 00:20:43,480
infrastructure that the critical here

00:20:42,160 --> 00:20:45,880
first of all will control the build

00:20:43,480 --> 00:20:50,260
system and so building all those things

00:20:45,880 --> 00:20:52,360
is trivial it's one flag we have built

00:20:50,260 --> 00:20:55,330
automated bug finding automated

00:20:52,360 --> 00:20:57,820
reporting automated tracking we have

00:20:55,330 --> 00:21:00,520
held several events facets facet ons

00:20:57,820 --> 00:21:02,800
fuzzing weeks etc most importantly we

00:21:00,520 --> 00:21:05,590
advertised fuzzy on our toilets

00:21:02,800 --> 00:21:07,750
worldwide three times and I'm not

00:21:05,590 --> 00:21:10,990
kidding

00:21:07,750 --> 00:21:16,610
what about adoption outside of Google

00:21:10,990 --> 00:21:21,799
here it varies between the teams I just

00:21:16,610 --> 00:21:24,350
heard from one of the large C++ company

00:21:21,799 --> 00:21:26,509
here on CB pick on the day I using lip

00:21:24,350 --> 00:21:27,769
color thank you guys but I want everyone

00:21:26,509 --> 00:21:32,899
here to usually buzzer if it's

00:21:27,769 --> 00:21:36,169
applicable to your code I started my

00:21:32,899 --> 00:21:39,980
career as a C++ developer 19 years ago

00:21:36,169 --> 00:21:43,610
and one of my first manager told me no

00:21:39,980 --> 00:21:45,710
question tests of students students have

00:21:43,610 --> 00:21:47,179
plenty of time for tests when serious

00:21:45,710 --> 00:21:49,639
developers we're developing the

00:21:47,179 --> 00:21:53,929
production thing I don't have time for

00:21:49,639 --> 00:21:56,750
tests it was before Ken Berg declared

00:21:53,929 --> 00:21:59,779
his test driven development and even now

00:21:56,750 --> 00:22:03,049
I see many many projects and products

00:21:59,779 --> 00:22:05,120
that don't really use tests however this

00:22:03,049 --> 00:22:07,879
has changed dramatically how many of you

00:22:05,120 --> 00:22:10,909
actually write tests for C++ code yeah

00:22:07,879 --> 00:22:12,500
if I have asked this 15 years ago most

00:22:10,909 --> 00:22:16,070
of the audience wouldn't raise their

00:22:12,500 --> 00:22:18,169
hand but we need to go further testing

00:22:16,070 --> 00:22:22,370
is not enough in our experience testing

00:22:18,169 --> 00:22:24,679
finds roughly 10% of the bugs and nine

00:22:22,370 --> 00:22:26,929
and eighty more percent of the bugs are

00:22:24,679 --> 00:22:30,830
found by fuzzing and then the remaining

00:22:26,929 --> 00:22:33,919
10% also not found by fashion testing

00:22:30,830 --> 00:22:36,529
they found in production by users so I

00:22:33,919 --> 00:22:39,320
want to proclaim fast driven development

00:22:36,529 --> 00:22:45,470
this is where all your tests I

00:22:39,320 --> 00:22:47,659
essentially fast targets and the

00:22:45,470 --> 00:22:49,820
continuous integration system does

00:22:47,659 --> 00:22:52,789
continuous fashion and by the way this

00:22:49,820 --> 00:22:54,169
is not specific to C++ in any way the

00:22:52,789 --> 00:22:57,139
people in the rust community already

00:22:54,169 --> 00:22:58,730
doing it very successfully and despite

00:22:57,139 --> 00:23:01,639
the fact that Trust is a memory safe

00:22:58,730 --> 00:23:03,919
language they do find lots of

00:23:01,639 --> 00:23:09,019
interesting bugs and most of them are

00:23:03,919 --> 00:23:11,750
not memory safety issues when it might

00:23:09,019 --> 00:23:13,799
make raising simpler to make it more

00:23:11,750 --> 00:23:16,470
widely adopted

00:23:13,799 --> 00:23:19,049
and we'll probably have to change the

00:23:16,470 --> 00:23:20,940
language the IDS the compiler is the

00:23:19,049 --> 00:23:23,909
build system and whatever it takes to

00:23:20,940 --> 00:23:28,679
make it super easy we need to make

00:23:23,909 --> 00:23:32,879
fuzzing as easy as putting one word in

00:23:28,679 --> 00:23:36,119
one place in your program and here is my

00:23:32,879 --> 00:23:38,220
proposal that is not tested and not

00:23:36,119 --> 00:23:40,769
implemented but I want something like

00:23:38,220 --> 00:23:43,710
this to happen suppose somewhere in your

00:23:40,769 --> 00:23:49,289
application you have an API function

00:23:43,710 --> 00:23:51,509
that consumes data we want to slap an

00:23:49,289 --> 00:23:53,970
attribute on that function and have it

00:23:51,509 --> 00:23:58,889
fast automatically by the build system

00:23:53,970 --> 00:24:01,889
ID CI or whatever we have now data

00:23:58,889 --> 00:24:05,100
incises not really C++ you would

00:24:01,889 --> 00:24:08,340
probably agree and so we may want

00:24:05,100 --> 00:24:10,440
something more C++ may be allow strings

00:24:08,340 --> 00:24:13,980
as parameters or maybe a lot of vectors

00:24:10,440 --> 00:24:16,499
of simple types as parameters or may be

00:24:13,980 --> 00:24:18,090
allow any kind of types but for any kind

00:24:16,499 --> 00:24:20,429
of types it becomes a little bit tricky

00:24:18,090 --> 00:24:23,359
because the fuzzer actually needs to

00:24:20,429 --> 00:24:26,789
know how to serialize and deserialize

00:24:23,359 --> 00:24:29,519
this data and optionally how to mutate

00:24:26,789 --> 00:24:34,340
this data and then will have to provide

00:24:29,519 --> 00:24:34,340
more stuff there

00:24:34,730 --> 00:24:39,350
now I've mostly talked about memory

00:24:37,350 --> 00:24:42,570
safety and fuzzing

00:24:39,350 --> 00:24:45,059
unfortunately C++ memory safety is more

00:24:42,570 --> 00:24:47,309
than fuzzy you will never solve all the

00:24:45,059 --> 00:24:49,499
memory safety bugs in your application

00:24:47,309 --> 00:24:49,799
with phazon so we need to do something

00:24:49,499 --> 00:24:53,489
else

00:24:49,799 --> 00:24:56,460
and I can see two most important areas

00:24:53,489 --> 00:24:58,529
other than puzzle first of all we do

00:24:56,460 --> 00:25:01,529
need to have support from hardware

00:24:58,529 --> 00:25:04,919
vendors and I call this idea

00:25:01,529 --> 00:25:08,039
hardware-assisted memory safety good

00:25:04,919 --> 00:25:10,440
news is that one vendor has implemented

00:25:08,039 --> 00:25:13,320
and shipped hardware with very useful

00:25:10,440 --> 00:25:16,859
memory safety feature unfortunately I

00:25:13,320 --> 00:25:21,029
guess almost nobody here uses spark does

00:25:16,859 --> 00:25:22,769
anyone yes ok so if you are using spark

00:25:21,029 --> 00:25:25,010
you have a very very useful memory

00:25:22,769 --> 00:25:28,429
safety feature but I don't have spark

00:25:25,010 --> 00:25:30,169
and all other vendors have tried to

00:25:28,429 --> 00:25:34,190
implement something useful for memory

00:25:30,169 --> 00:25:35,990
safety and failed so far so we as a

00:25:34,190 --> 00:25:39,770
suppose post community need to put

00:25:35,990 --> 00:25:43,250
pressure on hardware vendors here and

00:25:39,770 --> 00:25:46,160
the second the second large area of

00:25:43,250 --> 00:25:49,100
improvement we need to have something

00:25:46,160 --> 00:25:53,179
that would be aesthetically verifiable

00:25:49,100 --> 00:25:55,610
subset of C++ that would provide some

00:25:53,179 --> 00:25:58,640
guarantees of memory safety I don't know

00:25:55,610 --> 00:26:01,490
if this is C++ core guidelines that we

00:25:58,640 --> 00:26:02,299
are in a talk this morning or if this is

00:26:01,490 --> 00:26:04,640
something else

00:26:02,299 --> 00:26:06,500
but we have to come up with it of course

00:26:04,640 --> 00:26:08,960
it will help only newly developed code

00:26:06,500 --> 00:26:12,850
for the old code will have to do fuzzy

00:26:08,960 --> 00:26:17,240
hardware systems and bells and whistles

00:26:12,850 --> 00:26:20,240
so to summarize my talk today fast in

00:26:17,240 --> 00:26:22,610
C++ code is very useful because it

00:26:20,240 --> 00:26:24,980
prevents bugs and your grid will be and

00:26:22,610 --> 00:26:28,250
it's also simple I hope you will agree

00:26:24,980 --> 00:26:31,040
once you try but also must make it even

00:26:28,250 --> 00:26:33,770
more simple and who - must make it

00:26:31,040 --> 00:26:37,510
widely adopted otherwise it won't be

00:26:33,770 --> 00:26:40,640
useful for for the entire C++ community

00:26:37,510 --> 00:26:43,960
this is all of my talk and if you have

00:26:40,640 --> 00:26:43,960
questions please use the mic

00:26:44,020 --> 00:26:53,660
[Applause]

00:27:19,370 --> 00:27:25,260
can we simplify the case is generated by

00:27:22,440 --> 00:27:28,470
by by fashion yes most of the fuzzing

00:27:25,260 --> 00:27:31,230
engines provide some way to minimize the

00:27:28,470 --> 00:27:34,590
the test input and both lip buzzer and

00:27:31,230 --> 00:27:38,390
AFL have some such switches the examples

00:27:34,590 --> 00:27:40,919
for the for the naive clonk

00:27:38,390 --> 00:27:43,350
fuzzing are minimized you cannot you

00:27:40,919 --> 00:27:46,230
cannot remove any bite from them and the

00:27:43,350 --> 00:27:48,929
examples for structure where present for

00:27:46,230 --> 00:27:51,410
tanka also minimized like the tools are

00:27:48,929 --> 00:27:56,610
not able to remove anything from them

00:27:51,410 --> 00:27:58,740
while keeping the bug are you guys

00:27:56,610 --> 00:28:01,770
fuzzing the chromium in better train

00:27:58,740 --> 00:28:03,809
mode as well as chrome itself or do we

00:28:01,770 --> 00:28:06,179
fuss the chromium embedded framework I

00:28:03,809 --> 00:28:08,130
frankly don't know my team provides the

00:28:06,179 --> 00:28:11,490
tools and the service and the chromium

00:28:08,130 --> 00:28:13,910
team buzzes their own code so I don't

00:28:11,490 --> 00:28:16,410
know the answer I know that chromium

00:28:13,910 --> 00:28:19,350
project has several hundred to four

00:28:16,410 --> 00:28:30,000
targets across the code knees okay

00:28:19,350 --> 00:28:31,980
thanks just just so that I verify that

00:28:30,000 --> 00:28:34,290
actually understand this your whole

00:28:31,980 --> 00:28:37,260
argument here is about generating the

00:28:34,290 --> 00:28:40,530
testator exercise the functions as far

00:28:37,260 --> 00:28:42,870
as detecting the actual problems the the

00:28:40,530 --> 00:28:48,059
dereference of null pointers and

00:28:42,870 --> 00:28:50,730
overflows is that all handled by the by

00:28:48,059 --> 00:28:53,429
the analyzers that go with the compiler

00:28:50,730 --> 00:28:56,910
or does your setup also include things

00:28:53,429 --> 00:28:58,320
that handle that detection thanks for

00:28:56,910 --> 00:29:03,290
the question so the question is who

00:28:58,320 --> 00:29:03,290
actually finds the bugs the

00:29:03,899 --> 00:29:09,639
the phasing provides inputs that trigger

00:29:07,450 --> 00:29:11,350
interest in parts of code and hopefully

00:29:09,639 --> 00:29:15,220
triggers the bugs but we need to somehow

00:29:11,350 --> 00:29:17,380
detect them in ulcer in all setting we

00:29:15,220 --> 00:29:20,529
use the sanitizers tool tools like

00:29:17,380 --> 00:29:22,840
address sanitizer HM memory sanitizer UB

00:29:20,529 --> 00:29:25,659
Sam these are the dynamic bug detection

00:29:22,840 --> 00:29:27,730
tools that work together with fuzzing

00:29:25,659 --> 00:29:29,259
tools in the same process you can use

00:29:27,730 --> 00:29:31,269
other tools available on your platform

00:29:29,259 --> 00:29:36,269
like Microsoft will probably use a

00:29:31,269 --> 00:29:36,269
verifier or Paige heap or other things

00:29:56,759 --> 00:30:02,889
how does fuzzyness ult's compared to

00:30:00,279 --> 00:30:04,809
static analysis results so fuzzing

00:30:02,889 --> 00:30:08,230
results so much better because was

00:30:04,809 --> 00:30:10,120
fastened you can have a reproducer that

00:30:08,230 --> 00:30:13,029
triggers the back you can rerun it you

00:30:10,120 --> 00:30:14,980
can replay you can collect the trace

00:30:13,029 --> 00:30:17,409
from the bugging you can step-by-step it

00:30:14,980 --> 00:30:19,269
this is what static analysis tools

00:30:17,409 --> 00:30:22,629
either don't provide at all or providing

00:30:19,269 --> 00:30:25,000
less usable way so in this sense fuzzing

00:30:22,629 --> 00:30:30,190
is superior to static analysis I believe

00:30:25,000 --> 00:30:32,139
so we're out of time thanks all for

00:30:30,190 --> 00:30:33,350
attention but I'm here if you have any

00:30:32,139 --> 00:30:38,200
questions

00:30:33,350 --> 00:30:38,200

YouTube URL: https://www.youtube.com/watch?v=k-Cv8Q3zWNQ


