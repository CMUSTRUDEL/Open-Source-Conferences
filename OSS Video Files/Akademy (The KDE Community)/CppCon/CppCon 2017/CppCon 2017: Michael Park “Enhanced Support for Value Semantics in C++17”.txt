Title: CppCon 2017: Michael Park “Enhanced Support for Value Semantics in C++17”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Value semantics has been promoted in the C++ community for a long time, for reasons such as referential transparency, avoidance of memory management issues, and even efficiency in some cases. Move semantics in C++11 was a big step in language-level support for value semantics. In this talk, we’ll cover steps taken in C++17 for enhanced library-support for value semantics. Specifically, we’ll focus on `std::optional`, `std::variant`, and `std::any`. 

We’ll discuss what they are, their motivating use cases, and most importantly, identify existing patterns that can be improved by replacing it with one of these utilities. We’ll also cover some of the details such as: `std::monostate`, `std::variant`’s `valueless_by_exception` state, subtle difference in behavior between `std::optional＜T＞` and `std::variant＜std::monostate, T＞`, etc. 

The goal of the talk is to inform you of new library features in C++17, and to convince you of their usefulness and ultimately to add them to your toolbox.
— 
Michael Park: Mesosphere, Software Engineer

I’m a committer for the Apache Mesos project, and work as a Distributed Systems Engineer at Mesosphere. Within the realm of computer science, I’m very much intrigued by language design, compiler construction, and distributed systems. I’m also an active member of the ISO C++ Standards Committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:04,890
okay thank you everyone for coming this

00:00:02,730 --> 00:00:07,740
is in hand support force value semantics

00:00:04,890 --> 00:00:11,700
in C++ 17 my name is Michael Park

00:00:07,740 --> 00:00:13,679
perhaps better known as M Park I'm a

00:00:11,700 --> 00:00:15,299
software engineer at mesosphere where

00:00:13,679 --> 00:00:17,070
we're trying to figure out what it would

00:00:15,299 --> 00:00:20,760
look like to have an operating system in

00:00:17,070 --> 00:00:23,160
the data center outside of work I'm a

00:00:20,760 --> 00:00:26,939
member of the stairs suppose a Standards

00:00:23,160 --> 00:00:29,099
Committee and I am also the author of

00:00:26,939 --> 00:00:32,940
the standard variant implementation in

00:00:29,099 --> 00:00:34,980
Lib C++ so this is the agenda that I

00:00:32,940 --> 00:00:37,320
have for us today we're going to cover

00:00:34,980 --> 00:00:39,809
the basics of what it means to value

00:00:37,320 --> 00:00:41,640
semantics for some of us who may not be

00:00:39,809 --> 00:00:43,950
familiar with the idea we're going to

00:00:41,640 --> 00:00:45,719
cover three new library types that were

00:00:43,950 --> 00:00:47,969
introduced in sequence or 17 which are

00:00:45,719 --> 00:00:50,039
optional variants and any in that order

00:00:47,969 --> 00:00:53,100
then I'll just go through a little

00:00:50,039 --> 00:00:57,059
summary of what I think how they relate

00:00:53,100 --> 00:00:58,920
to each other and things like that so

00:00:57,059 --> 00:01:00,090
values and ethics before we get into

00:00:58,920 --> 00:01:02,430
value semantics I want to first talk

00:01:00,090 --> 00:01:05,519
about distinction between values and

00:01:02,430 --> 00:01:07,080
objects so it's important to note that

00:01:05,519 --> 00:01:10,049
when I say objects I'm talking about

00:01:07,080 --> 00:01:11,869
objects in a sense of in the C++ object

00:01:10,049 --> 00:01:16,380
model sense as opposed to the

00:01:11,869 --> 00:01:18,950
object-oriented sense so a value is an

00:01:16,380 --> 00:01:21,509
abstract entity most typically

00:01:18,950 --> 00:01:24,240
representing a mathematical entity so

00:01:21,509 --> 00:01:30,390
things like integers and matrices right

00:01:24,240 --> 00:01:31,650
we have and they don't they're there

00:01:30,390 --> 00:01:34,229
they're abstract and so they don't

00:01:31,650 --> 00:01:37,439
actually exist at a specific location or

00:01:34,229 --> 00:01:41,670
time they just exist as an idea as a

00:01:37,439 --> 00:01:45,180
concept on the other hand an object is a

00:01:41,670 --> 00:01:48,450
concrete entity and and they're and they

00:01:45,180 --> 00:01:51,750
and they exist to represent a value they

00:01:48,450 --> 00:01:54,450
are concrete in memory they're made up

00:01:51,750 --> 00:01:56,520
of a sequence of bits and a type to for

00:01:54,450 --> 00:01:59,969
us to figure out what those bits mean

00:01:56,520 --> 00:02:03,710
and they come in out they come in and

00:01:59,969 --> 00:02:08,610
out of existence as time as time flows

00:02:03,710 --> 00:02:10,679
and so naturally values don't have an

00:02:08,610 --> 00:02:13,290
identity in memory whereas concrete

00:02:10,679 --> 00:02:15,000
objects such as sorry objects

00:02:13,290 --> 00:02:17,280
which are concrete have an address in

00:02:15,000 --> 00:02:18,900
memory and we can identify them and with

00:02:17,280 --> 00:02:22,260
this with this address is how we

00:02:18,900 --> 00:02:24,299
identify objects so we actually have

00:02:22,260 --> 00:02:29,269
formal ways of describing this in C++

00:02:24,299 --> 00:02:32,670
through value categories so values as I

00:02:29,269 --> 00:02:35,159
defined it just now is categorized as PR

00:02:32,670 --> 00:02:38,040
values whereas objects are categorized

00:02:35,159 --> 00:02:40,019
as GL values I'm not going on going to

00:02:38,040 --> 00:02:41,640
details as to how the valley categories

00:02:40,019 --> 00:02:45,150
categories work and what the conditions

00:02:41,640 --> 00:02:47,190
are but if you go to nicole malukas talk

00:02:45,150 --> 00:02:49,500
on Thursday she's planning to talk about

00:02:47,190 --> 00:02:53,129
object models in detail so she'll cover

00:02:49,500 --> 00:02:54,659
that there so for us let's just take a

00:02:53,129 --> 00:02:56,909
look take a look at an example and

00:02:54,659 --> 00:02:59,310
figure out what I'm talking about if you

00:02:56,909 --> 00:03:01,829
put your c-plus hats back on on the Left

00:02:59,310 --> 00:03:03,599
we have 42 for which we can take a value

00:03:01,829 --> 00:03:05,159
which you get your check which you can

00:03:03,599 --> 00:03:07,590
take an address right because it's a

00:03:05,159 --> 00:03:09,299
value they don't have an address on the

00:03:07,590 --> 00:03:11,430
other hand on the right we have index

00:03:09,299 --> 00:03:13,650
equals 42 where we actually store that

00:03:11,430 --> 00:03:15,269
value in a concrete entity called an

00:03:13,650 --> 00:03:23,040
object and we can actually take an

00:03:15,269 --> 00:03:25,169
address of that and refer to it so what

00:03:23,040 --> 00:03:27,419
is value some ethics value semantics as

00:03:25,169 --> 00:03:29,400
a whole is really a programming model in

00:03:27,419 --> 00:03:31,349
which we want to focus more on values

00:03:29,400 --> 00:03:34,919
and operate on values as opposed to

00:03:31,349 --> 00:03:37,620
objects we and in order to enable such a

00:03:34,919 --> 00:03:39,569
model a systematic approach to dealing

00:03:37,620 --> 00:03:40,799
with the deal with these pesky objects

00:03:39,569 --> 00:03:46,019
which come in come in and out of

00:03:40,799 --> 00:03:48,150
existence is necessary so these are two

00:03:46,019 --> 00:03:50,069
strategies of managing objects that we

00:03:48,150 --> 00:03:52,319
really care about at least for this talk

00:03:50,069 --> 00:03:54,569
the first one is deep copy semantics and

00:03:52,319 --> 00:03:56,459
the second is automatic lifetimes so

00:03:54,569 --> 00:03:58,829
let's take we that's like vector as an

00:03:56,459 --> 00:04:02,010
example since that's everyone start with

00:03:58,829 --> 00:04:04,949
type right when you copy a vector you

00:04:02,010 --> 00:04:07,079
get an entirely separate copy right you

00:04:04,949 --> 00:04:09,030
get every one of your elements copy it

00:04:07,079 --> 00:04:11,430
into a new new new vector and if you

00:04:09,030 --> 00:04:12,959
modify the old elements old vector your

00:04:11,430 --> 00:04:15,690
new elements aren't change don't get

00:04:12,959 --> 00:04:18,180
affected and it effectively severs the

00:04:15,690 --> 00:04:20,849
relationship between your new object and

00:04:18,180 --> 00:04:22,830
your old old vector object and that's

00:04:20,849 --> 00:04:24,780
what allows us to actually perform local

00:04:22,830 --> 00:04:25,660
reasoning with your new with the state

00:04:24,780 --> 00:04:27,460
of the new new

00:04:25,660 --> 00:04:29,020
that was created because you don't care

00:04:27,460 --> 00:04:32,200
what happens to the old object once you

00:04:29,020 --> 00:04:33,640
copied it automatic lifetimes also known

00:04:32,200 --> 00:04:35,860
as resource acquisition is

00:04:33,640 --> 00:04:37,930
initialization is the technique where we

00:04:35,860 --> 00:04:42,790
we achieve this by binding the lifetime

00:04:37,930 --> 00:04:45,400
of the the array that's stored on the

00:04:42,790 --> 00:04:47,740
heap and the lifetime of the vector

00:04:45,400 --> 00:04:50,590
object itself and on the stack which is

00:04:47,740 --> 00:04:52,300
managed automatically and so we can have

00:04:50,590 --> 00:04:53,920
the heat get managed by the lifetime of

00:04:52,300 --> 00:05:02,320
the stack and we can bind those to bind

00:04:53,920 --> 00:05:05,290
those alike life lifetimes together so

00:05:02,320 --> 00:05:07,270
some benefits why do we even care so

00:05:05,290 --> 00:05:10,000
first thing is that value semantics is

00:05:07,270 --> 00:05:12,040
the default mode in C++ right it's been

00:05:10,000 --> 00:05:13,960
promoted for a long time and we have a

00:05:12,040 --> 00:05:15,610
lot as a community we have a lot of

00:05:13,960 --> 00:05:17,440
experience with it the fact that the

00:05:15,610 --> 00:05:18,940
compiler tries so hard to generate

00:05:17,440 --> 00:05:21,310
special memory functions for you is

00:05:18,940 --> 00:05:25,900
indicative of how bad may see puss-puss

00:05:21,310 --> 00:05:27,430
want you to use value semantics and we

00:05:25,900 --> 00:05:28,930
don't get a lot of defaults right in

00:05:27,430 --> 00:05:32,260
Siebel sauce but I think this one is the

00:05:28,930 --> 00:05:34,840
big one that we got right and without

00:05:32,260 --> 00:05:37,090
value semantics try to read an academic

00:05:34,840 --> 00:05:38,730
paper which typically is written in some

00:05:37,090 --> 00:05:41,800
form of mathematical notation and

00:05:38,730 --> 00:05:43,540
transforming that to a program without

00:05:41,800 --> 00:05:45,130
values of ethics is typically very

00:05:43,540 --> 00:05:46,630
difficult and it's very difficult not

00:05:45,130 --> 00:05:49,480
because the algorithm is particularly

00:05:46,630 --> 00:05:51,190
complex but you have so much more to

00:05:49,480 --> 00:05:53,230
worry about that algorithm now right you

00:05:51,190 --> 00:05:54,940
have objects that you have to deal with

00:05:53,230 --> 00:05:56,980
in terms of like how to deal with their

00:05:54,940 --> 00:05:59,980
memory lifetimes and memory management

00:05:56,980 --> 00:06:01,480
all that stuff it's not it's it's it's a

00:05:59,980 --> 00:06:05,140
lot of burden that isn't really actually

00:06:01,480 --> 00:06:06,820
related to the problem statement and so

00:06:05,140 --> 00:06:08,169
what that means is getting value

00:06:06,820 --> 00:06:09,419
semantics and getting closer to

00:06:08,169 --> 00:06:12,400
mathematical notation actually

00:06:09,419 --> 00:06:14,110
facilitates us in reaping the benefits

00:06:12,400 --> 00:06:15,910
of the existing work that that's

00:06:14,110 --> 00:06:20,919
happened in mathematics and computer

00:06:15,910 --> 00:06:23,640
science the next thing is referential

00:06:20,919 --> 00:06:25,690
transparency so we really get this from

00:06:23,640 --> 00:06:28,240
performing deep copy semantics right

00:06:25,690 --> 00:06:31,440
when we copy a vector we get a new copy

00:06:28,240 --> 00:06:34,060
and we can manage to not perform

00:06:31,440 --> 00:06:36,580
non-local reasoning all over your

00:06:34,060 --> 00:06:38,380
codebase and performing all non-local

00:06:36,580 --> 00:06:39,700
reasoning is I think one of the hardest

00:06:38,380 --> 00:06:42,970
things to do

00:06:39,700 --> 00:06:44,800
in programming and so the copy semantics

00:06:42,970 --> 00:06:47,020
actually helps us increase opportunities

00:06:44,800 --> 00:06:50,770
for non-local reasoning in our programs

00:06:47,020 --> 00:06:53,320
and we also avoid pesky issues like

00:06:50,770 --> 00:06:56,890
manual manual memory management like we

00:06:53,320 --> 00:06:58,480
see it vector and all three of the types

00:06:56,890 --> 00:07:00,220
that we'll see today bring value

00:06:58,480 --> 00:07:01,840
semantics to constructs that you are if

00:07:00,220 --> 00:07:07,210
you already know about in the language

00:07:01,840 --> 00:07:08,740
today so this brings us to optional as I

00:07:07,210 --> 00:07:10,690
mentioned optional was added to the

00:07:08,740 --> 00:07:13,120
standard library in Seema so 17 the

00:07:10,690 --> 00:07:15,280
design is largely based on boost

00:07:13,120 --> 00:07:20,680
optional which was introduced in 2003

00:07:15,280 --> 00:07:22,870
and boost version 1 1 1.30 so the

00:07:20,680 --> 00:07:24,310
conceptual model for an optional is that

00:07:22,870 --> 00:07:27,790
it represents the notion of an optional

00:07:24,310 --> 00:07:29,440
object put another way we can also say

00:07:27,790 --> 00:07:32,410
that it models the discriminated union

00:07:29,440 --> 00:07:34,690
of tea and null opti the lop tea is the

00:07:32,410 --> 00:07:36,970
tag type that in the case that the the

00:07:34,690 --> 00:07:38,500
optional does not hold the value and so

00:07:36,970 --> 00:07:41,410
by discriminate the Union I mean that

00:07:38,500 --> 00:07:45,070
you can hold either a tea or a no op tea

00:07:41,410 --> 00:07:46,600
but not books another way I like to

00:07:45,070 --> 00:07:49,300
think about it is that this is actually

00:07:46,600 --> 00:07:51,790
a pointer to tea wrapped up into a value

00:07:49,300 --> 00:07:55,870
type right so if we if we if we think

00:07:51,790 --> 00:07:58,479
about how this looks and as a as a list

00:07:55,870 --> 00:08:01,690
rated by this diagram I've declared some

00:07:58,479 --> 00:08:03,729
pointer P to type some random type T it

00:08:01,690 --> 00:08:05,470
points to nothing at the moment and then

00:08:03,729 --> 00:08:09,430
we can create a new instance of T and

00:08:05,470 --> 00:08:12,550
assign it to P and P points at T and

00:08:09,430 --> 00:08:14,680
this is what we have now if we move it

00:08:12,550 --> 00:08:16,419
over to optional what we see is that

00:08:14,680 --> 00:08:18,820
when we declare an optional now this

00:08:16,419 --> 00:08:21,690
thing needs the whole is required to

00:08:18,820 --> 00:08:25,690
hold the value in place so the optional

00:08:21,690 --> 00:08:28,390
needs to be as as big as at least as big

00:08:25,690 --> 00:08:30,850
as the largest in this case it has to be

00:08:28,390 --> 00:08:33,700
at least big as T so it's going to be

00:08:30,850 --> 00:08:35,530
it's going to increase in size namely as

00:08:33,700 --> 00:08:41,200
big as T and then we're going to store

00:08:35,530 --> 00:08:44,040
the T inside the optional very clear ok

00:08:41,200 --> 00:08:47,620
so here's a quick overview of the API

00:08:44,040 --> 00:08:50,709
I've got optional string X here which

00:08:47,620 --> 00:08:53,140
gets assigned to string hello the first

00:08:50,709 --> 00:08:55,120
the first assert is going to use the

00:08:53,140 --> 00:08:56,589
the implicit conversion to bull to test

00:08:55,120 --> 00:08:59,260
for whether the optional holds a value

00:08:56,589 --> 00:09:01,870
or not the second half ii assert is

00:08:59,260 --> 00:09:04,029
using the operator star to perform

00:09:01,870 --> 00:09:06,490
unchecked access into the into the

00:09:04,029 --> 00:09:07,990
optional so we're going to get the

00:09:06,490 --> 00:09:09,880
string out of the optional and test for

00:09:07,990 --> 00:09:13,209
test that we have the value Attucks that

00:09:09,880 --> 00:09:15,760
we expected there's a second set of ap

00:09:13,209 --> 00:09:17,490
is the default constructor for optional

00:09:15,760 --> 00:09:20,200
will default construct into the

00:09:17,490 --> 00:09:21,730
disengage state where where this engaged

00:09:20,200 --> 00:09:26,410
means the optional does not hold the

00:09:21,730 --> 00:09:28,390
value and we can use any and we can use

00:09:26,410 --> 00:09:30,610
the has value function which performs

00:09:28,390 --> 00:09:31,899
exactly the same operation as the

00:09:30,610 --> 00:09:36,730
implicit conversion to pool

00:09:31,899 --> 00:09:38,709
and the value or function is used to use

00:09:36,730 --> 00:09:40,120
to provide a default value if the

00:09:38,709 --> 00:09:41,769
optional happens to not have a value

00:09:40,120 --> 00:09:43,990
then give me this give me back this

00:09:41,769 --> 00:09:46,690
default value one thing to note here is

00:09:43,990 --> 00:09:48,760
that the value or will actually copy or

00:09:46,690 --> 00:09:50,980
move the value out of the optional right

00:09:48,760 --> 00:09:53,380
so typically if you go to access to

00:09:50,980 --> 00:09:55,180
access an excessive element sorry a

00:09:53,380 --> 00:09:57,339
value inside an object it's not an

00:09:55,180 --> 00:09:59,110
optional it's going to get you back a

00:09:57,339 --> 00:10:02,310
reference to that up to that value

00:09:59,110 --> 00:10:07,839
whereas value or will actually give you

00:10:02,310 --> 00:10:09,910
not a reference but about you okay all

00:10:07,839 --> 00:10:12,279
right and the value function is checked

00:10:09,910 --> 00:10:14,350
access and so what that means is if the

00:10:12,279 --> 00:10:15,670
optional doesn't happen to actually

00:10:14,350 --> 00:10:18,160
store a value that it's going to throw

00:10:15,670 --> 00:10:21,779
an exception specifically it's going to

00:10:18,160 --> 00:10:25,149
throw the bad optional access exception

00:10:21,779 --> 00:10:26,860
and as we met as I mentioned optional

00:10:25,149 --> 00:10:27,670
has value semantics as well as

00:10:26,860 --> 00:10:30,519
everything else we're going to talk

00:10:27,670 --> 00:10:32,470
about today so if you assign X into y

00:10:30,519 --> 00:10:35,589
then we're going to performing a deep

00:10:32,470 --> 00:10:36,760
copy assignment and y know law holds a

00:10:35,589 --> 00:10:38,769
value that and it's going to hold the

00:10:36,760 --> 00:10:41,620
same values X and the comparison will

00:10:38,769 --> 00:10:43,420
also be deep as well and most

00:10:41,620 --> 00:10:45,190
importantly automatic lifetime we talked

00:10:43,420 --> 00:10:50,380
about and optional knows how to

00:10:45,190 --> 00:10:51,790
construct the string properly so I want

00:10:50,380 --> 00:10:54,399
to talk about some new spaces where you

00:10:51,790 --> 00:10:57,550
can actually replace some existing

00:10:54,399 --> 00:10:58,930
practices with optional and the three

00:10:57,550 --> 00:11:00,970
use cases that I want to cover our

00:10:58,930 --> 00:11:05,140
optional return values function

00:11:00,970 --> 00:11:07,100
parameters and data members so first

00:11:05,140 --> 00:11:11,150
let's talk about magic values

00:11:07,100 --> 00:11:13,760
a magic value is a valid value of type T

00:11:11,150 --> 00:11:18,200
that is used to indicate the absence of

00:11:13,760 --> 00:11:22,490
value T ah the absence of a valid value

00:11:18,200 --> 00:11:25,400
of type T so that should sound weird and

00:11:22,490 --> 00:11:27,740
should be concerning but we actually

00:11:25,400 --> 00:11:29,300
have this all over we see this all over

00:11:27,740 --> 00:11:31,310
the place right we have some of the

00:11:29,300 --> 00:11:33,230
examples are we use negative 1 we use

00:11:31,310 --> 00:11:35,150
string and pause we use an empty string

00:11:33,230 --> 00:11:37,810
we also use the end of the reader for

00:11:35,150 --> 00:11:49,670
some things that aren't necessarily

00:11:37,810 --> 00:11:53,000
range related sorry oh yes right yeah

00:11:49,670 --> 00:11:55,870
yeah the comma was that the the nan the

00:11:53,000 --> 00:11:58,310
nan value for double is also another

00:11:55,870 --> 00:12:02,210
special value and we'll talk about that

00:11:58,310 --> 00:12:04,070
one later so some of the problems it's

00:12:02,210 --> 00:12:06,140
really easy to miss and the reason why

00:12:04,070 --> 00:12:08,750
it's easy to miss is because it doesn't

00:12:06,140 --> 00:12:10,250
show up in the API right when you see a

00:12:08,750 --> 00:12:12,710
function that takes an int and returns

00:12:10,250 --> 00:12:14,300
an int it's really difficult to tell

00:12:12,710 --> 00:12:18,950
that that intz that you're getting back

00:12:14,300 --> 00:12:20,060
might not actually be an int right and

00:12:18,950 --> 00:12:23,210
if you're lucky maybe it'll be in the

00:12:20,060 --> 00:12:25,610
documentation but people are bad at

00:12:23,210 --> 00:12:29,030
writing and reading documentation so I'm

00:12:25,610 --> 00:12:31,340
not all that hopeful about that and

00:12:29,030 --> 00:12:35,660
secondly we don't always have a value

00:12:31,340 --> 00:12:39,230
that we can steal right we if if the

00:12:35,660 --> 00:12:41,090
function T if the function f takes if

00:12:39,230 --> 00:12:44,930
the function f is return value let's say

00:12:41,090 --> 00:12:48,080
is an int and all of the values of int

00:12:44,930 --> 00:12:51,950
are valid return result of that function

00:12:48,080 --> 00:12:55,010
then which value do you steal we don't

00:12:51,950 --> 00:12:56,750
always have this option and we have an

00:12:55,010 --> 00:12:59,240
example of this right we have stirred 2l

00:12:56,750 --> 00:13:02,080
which is a function that tries to

00:12:59,240 --> 00:13:04,880
convert a string into into a long and

00:13:02,080 --> 00:13:07,700
every value of long is a valid result of

00:13:04,880 --> 00:13:09,950
32 l and so it returns zero for

00:13:07,700 --> 00:13:12,920
variations of the string zero with

00:13:09,950 --> 00:13:14,800
spaces in it or whatever as well as

00:13:12,920 --> 00:13:17,240
situations where you can't actually

00:13:14,800 --> 00:13:20,510
convert convert the string into it

00:13:17,240 --> 00:13:21,890
string into a long and

00:13:20,510 --> 00:13:23,570
yeah it's that's the value in Aaron Oh

00:13:21,890 --> 00:13:25,580
to communicate the error and the user is

00:13:23,570 --> 00:13:27,710
required to know about this and this is

00:13:25,580 --> 00:13:31,180
even more subtle than knowing about the

00:13:27,710 --> 00:13:31,180
magic value and trying to check for it

00:13:32,560 --> 00:13:38,060
okay so this is an example this is

00:13:36,020 --> 00:13:40,580
actually my favorite example of where

00:13:38,060 --> 00:13:42,680
this becomes a problem so in this code I

00:13:40,580 --> 00:13:44,930
have a for call where we're going to

00:13:42,680 --> 00:13:46,880
fork it the process that we're in and as

00:13:44,930 --> 00:13:48,830
you probably know it's we got back a

00:13:46,880 --> 00:13:51,110
paid and we can test for the value of

00:13:48,830 --> 00:13:52,880
the pit to say if it's zero then I'm the

00:13:51,110 --> 00:13:55,670
child process and if it's a positive

00:13:52,880 --> 00:13:58,120
number that I'm the parent process now

00:13:55,670 --> 00:14:01,070
for can fail

00:13:58,120 --> 00:14:04,070
so when fork fails fork will return

00:14:01,070 --> 00:14:07,430
negative one as most unique functions on

00:14:04,070 --> 00:14:10,130
your next functions do so we have

00:14:07,430 --> 00:14:11,750
negative one we check for zero and we

00:14:10,130 --> 00:14:13,700
got into this else and where you think

00:14:11,750 --> 00:14:16,490
we're a parent except we failed actually

00:14:13,700 --> 00:14:18,230
but we're gonna we're gonna we're gonna

00:14:16,490 --> 00:14:21,260
proceed and try to kill the child

00:14:18,230 --> 00:14:23,270
process which we failed so so pit is

00:14:21,260 --> 00:14:25,460
actually negative one in this case so

00:14:23,270 --> 00:14:32,930
what happens when you call kill negative

00:14:25,460 --> 00:14:34,210
one does anyone know kill yourself no

00:14:32,930 --> 00:14:40,250
that'll be better

00:14:34,210 --> 00:14:42,890
kill all if pit equals negative one then

00:14:40,250 --> 00:14:44,270
cig is sent to every process for which

00:14:42,890 --> 00:14:46,610
the calling process has permission to

00:14:44,270 --> 00:14:52,190
send signals except for process one in

00:14:46,610 --> 00:14:54,620
it but see below see below what I I mean

00:14:52,190 --> 00:14:57,080
this is what's below right we killed

00:14:54,620 --> 00:15:01,760
every process and our cut in our in our

00:14:57,080 --> 00:15:03,950
machine so what happened well we got a

00:15:01,760 --> 00:15:06,950
negative one back from fork which meant

00:15:03,950 --> 00:15:09,920
that it failed and then we propagated

00:15:06,950 --> 00:15:11,930
that value accidentally through the kill

00:15:09,920 --> 00:15:13,880
function and the kill function said Oh

00:15:11,930 --> 00:15:16,160
negative one oh yeah that means

00:15:13,880 --> 00:15:18,320
everything so there's just completely

00:15:16,160 --> 00:15:20,510
different interpretation of negative one

00:15:18,320 --> 00:15:23,570
by what Fork meant and what kill meant

00:15:20,510 --> 00:15:26,120
right it's kind of weird that kill would

00:15:23,570 --> 00:15:29,560
even take a negative one and say rather

00:15:26,120 --> 00:15:32,560
than meaning nothing it means everything

00:15:29,560 --> 00:15:32,560
okay

00:15:32,630 --> 00:15:37,130
if I cover here alright so there yeah so

00:15:35,780 --> 00:15:39,380
the accidental propagation of magic

00:15:37,130 --> 00:15:40,790
values is what's so dangerous here so

00:15:39,380 --> 00:15:43,520
let's talk about optional return values

00:15:40,790 --> 00:15:45,320
so here I have a parse function that's

00:15:43,520 --> 00:15:49,060
going to take a string view suppose for

00:15:45,320 --> 00:15:51,890
17 fancy stuff we're gonna take the

00:15:49,060 --> 00:15:54,200
result type explicitly and we're going

00:15:51,890 --> 00:15:57,350
to attempt to parse this string into a t

00:15:54,200 --> 00:15:59,360
and that's what that's what this

00:15:57,350 --> 00:16:02,000
function wants to do so okay what

00:15:59,360 --> 00:16:04,130
happens if this we cannot parse parse

00:16:02,000 --> 00:16:06,170
the string into a T the current solution

00:16:04,130 --> 00:16:08,420
is that at least I know about that I'll

00:16:06,170 --> 00:16:11,810
elaborate here is that one is obviously

00:16:08,420 --> 00:16:13,550
to throw this throw an exception to we

00:16:11,810 --> 00:16:17,180
could return a smart pointer or a dumb

00:16:13,550 --> 00:16:19,550
pointer whatever some point R - t we can

00:16:17,180 --> 00:16:21,590
return a pair of T comma bool or the

00:16:19,550 --> 00:16:22,630
bool indicates whether the T is valid or

00:16:21,590 --> 00:16:25,220
not

00:16:22,630 --> 00:16:27,920
we could return a bool and take a T ref

00:16:25,220 --> 00:16:29,630
as the out parameter and there are

00:16:27,920 --> 00:16:32,150
drawbacks to all of these approaches

00:16:29,630 --> 00:16:33,800
that I'll iterate through quickly so

00:16:32,150 --> 00:16:35,180
throwing an exception doesn't really fit

00:16:33,800 --> 00:16:38,120
well if we don't really consider it an

00:16:35,180 --> 00:16:39,950
error right let's say we are let's say I

00:16:38,120 --> 00:16:41,900
want to try three different types of

00:16:39,950 --> 00:16:43,070
parses and if it fails it's not it's not

00:16:41,900 --> 00:16:45,050
a big deal I'll just move on to the next

00:16:43,070 --> 00:16:47,000
one getting through that through an

00:16:45,050 --> 00:16:49,940
exception is essentially using exception

00:16:47,000 --> 00:16:53,810
exceptions for control flow and we frown

00:16:49,940 --> 00:16:55,670
upon that number two if we return a

00:16:53,810 --> 00:16:57,710
pointer then immediately we lose value

00:16:55,670 --> 00:17:01,010
semantics and we accidentally also pay

00:16:57,710 --> 00:17:03,530
for heap allocation parity bool this was

00:17:01,010 --> 00:17:05,480
interesting the T always has to be

00:17:03,530 --> 00:17:07,040
constructed which means that oftentimes

00:17:05,480 --> 00:17:08,689
we end up adding default constructors

00:17:07,040 --> 00:17:12,560
the types that we didn't really want to

00:17:08,689 --> 00:17:14,540
so the other so so that's that's one

00:17:12,560 --> 00:17:16,490
thing that we don't want but the other

00:17:14,540 --> 00:17:18,350
thing is that the interpretation of what

00:17:16,490 --> 00:17:20,930
pair tee-ball means is actually

00:17:18,350 --> 00:17:24,410
ambiguous right so what I said is that

00:17:20,930 --> 00:17:26,420
parity bool if bool is set then T is a

00:17:24,410 --> 00:17:28,790
valid value and we can use it if bool is

00:17:26,420 --> 00:17:30,650
false then it's an invalid value and we

00:17:28,790 --> 00:17:33,340
can't use it well

00:17:30,650 --> 00:17:36,320
map insert returns a pair iterator pool

00:17:33,340 --> 00:17:38,120
well what does it mean if those it mean

00:17:36,320 --> 00:17:40,520
that when the bool is false that the

00:17:38,120 --> 00:17:42,050
iterator is invalid or the the the

00:17:40,520 --> 00:17:44,900
object that the iterator is pointing to

00:17:42,050 --> 00:17:45,590
is invalid no if the if the Bou is false

00:17:44,900 --> 00:17:48,590
coming out

00:17:45,590 --> 00:17:50,150
Spencer it just means that it wasn't the

00:17:48,590 --> 00:17:51,470
object that you put that you try to

00:17:50,150 --> 00:17:54,350
insert that I'm pointing out right now

00:17:51,470 --> 00:17:56,570
so it's always a valid iterator iterator

00:17:54,350 --> 00:18:00,200
right the interpretation of what parable

00:17:56,570 --> 00:18:03,380
means is ambiguous and the last one this

00:18:00,200 --> 00:18:05,600
one's maybe the most obvious one it

00:18:03,380 --> 00:18:07,520
still needs to be people constructed or

00:18:05,600 --> 00:18:12,500
constructed into something and at least

00:18:07,520 --> 00:18:15,250
a very awkward API so what happens if we

00:18:12,500 --> 00:18:18,770
introduce optional T as the return value

00:18:15,250 --> 00:18:21,409
well we don't have exceptions we

00:18:18,770 --> 00:18:23,149
maintain value semantics my value

00:18:21,409 --> 00:18:25,279
semantics I mean when it when we copy we

00:18:23,149 --> 00:18:28,010
copy the whole value and it manages

00:18:25,279 --> 00:18:29,059
lifetime we don't get any politician

00:18:28,010 --> 00:18:31,429
because optional is not allowed to

00:18:29,059 --> 00:18:35,179
perform a tape allocation T is only

00:18:31,429 --> 00:18:37,820
constructed if needed and then take this

00:18:35,179 --> 00:18:42,529
clear and we get a clearer API cleaner

00:18:37,820 --> 00:18:45,110
API and I say cleaner because I can't

00:18:42,529 --> 00:18:47,210
really call it a clean API and the main

00:18:45,110 --> 00:18:50,450
reason for that is because trying to

00:18:47,210 --> 00:18:52,399
propagate the optional returns through a

00:18:50,450 --> 00:18:54,440
for loop through lambdas through

00:18:52,399 --> 00:18:57,860
different function calls is very manual

00:18:54,440 --> 00:18:59,809
and explicit which oftentimes explicit

00:18:57,860 --> 00:19:04,789
is good but for veracity is another

00:18:59,809 --> 00:19:06,620
concern optional function parameter so

00:19:04,789 --> 00:19:11,809
if you have a function parameter that

00:19:06,620 --> 00:19:13,460
has that but that takes a type by value

00:19:11,809 --> 00:19:16,460
so in this case we have some function f

00:19:13,460 --> 00:19:18,169
taking a light object by value and we

00:19:16,460 --> 00:19:20,840
can transform that to take an optional

00:19:18,169 --> 00:19:22,700
light and this will take an OP in the

00:19:20,840 --> 00:19:24,770
existing optional it will also take an

00:19:22,700 --> 00:19:26,840
instance of light and it will just

00:19:24,770 --> 00:19:30,590
convert it and within function f you can

00:19:26,840 --> 00:19:32,240
handle both logic it's kind of nice but

00:19:30,590 --> 00:19:35,149
what happens is if we have some heavy

00:19:32,240 --> 00:19:37,549
object and we're using constant ref in

00:19:35,149 --> 00:19:39,620
the function parameter because we want

00:19:37,549 --> 00:19:40,789
to avoid copying because the thing is

00:19:39,620 --> 00:19:45,320
heavy

00:19:40,789 --> 00:19:47,090
I've seen this code a lot and I'm not

00:19:45,320 --> 00:19:49,250
sure that everyone understands the

00:19:47,090 --> 00:19:51,260
implication of it so if we just

00:19:49,250 --> 00:19:53,059
transform the heavy there into optional

00:19:51,260 --> 00:19:56,929
heavy where the cost ref is on the

00:19:53,059 --> 00:19:58,840
outside what happens if we pass an

00:19:56,929 --> 00:20:02,300
instance of heavy directly

00:19:58,840 --> 00:20:04,400
well we're going to perform implicit

00:20:02,300 --> 00:20:06,830
conversion from heavy to optional heavy

00:20:04,400 --> 00:20:08,330
and then we're going to bind to the

00:20:06,830 --> 00:20:11,570
temporary optional heavy that was

00:20:08,330 --> 00:20:13,580
constructed and and the heavy needs to

00:20:11,570 --> 00:20:16,490
and the optional heavy actually needs to

00:20:13,580 --> 00:20:19,130
store the value internally and so we're

00:20:16,490 --> 00:20:24,170
actually going to incur a copy or at

00:20:19,130 --> 00:20:26,510
best a move in in this case so this can

00:20:24,170 --> 00:20:29,110
actually be a copy so watch out for that

00:20:26,510 --> 00:20:32,060
if you're making transformations

00:20:29,110 --> 00:20:34,220
optional data member I have some person

00:20:32,060 --> 00:20:36,500
class here first name last name or

00:20:34,220 --> 00:20:38,980
mandatory and some people don't have

00:20:36,500 --> 00:20:43,100
middle names I don't have a middle name

00:20:38,980 --> 00:20:46,190
and I've also been lying to guys my real

00:20:43,100 --> 00:20:49,070
name is not actually Michael my real

00:20:46,190 --> 00:20:53,990
name is actually Chan young and that's

00:20:49,070 --> 00:20:55,610
my Korean name that's my legal name so I

00:20:53,990 --> 00:20:58,520
need to submit some forms to register

00:20:55,610 --> 00:21:00,980
for a new name I don't middle name or

00:20:58,520 --> 00:21:02,510
whatever and once that process is okay

00:21:00,980 --> 00:21:07,130
fine that I can actually get the name

00:21:02,510 --> 00:21:08,110
Michael that's my middle name show you a

00:21:07,130 --> 00:21:10,460
few more things

00:21:08,110 --> 00:21:13,310
relational operators we haven't talked

00:21:10,460 --> 00:21:14,870
about them much at all but they're

00:21:13,310 --> 00:21:19,190
important because there are some

00:21:14,870 --> 00:21:20,750
subtleties here so no op T as I

00:21:19,190 --> 00:21:23,120
mentioned is the tag type that

00:21:20,750 --> 00:21:25,340
represents the empty state empty state

00:21:23,120 --> 00:21:29,450
of an optional and it compares less than

00:21:25,340 --> 00:21:32,080
any T and that's not sorry

00:21:29,450 --> 00:21:36,440
so the nullity being less than anything

00:21:32,080 --> 00:21:38,390
makes optional by default total

00:21:36,440 --> 00:21:39,980
orderable right and so what that means

00:21:38,390 --> 00:21:41,660
is that you can practically what that

00:21:39,980 --> 00:21:44,450
means is that you can pass optionals

00:21:41,660 --> 00:21:46,880
into a map for example and then operate

00:21:44,450 --> 00:21:51,050
on them as if they were T's and have no

00:21:46,880 --> 00:21:52,610
op t as just another value all the

00:21:51,050 --> 00:21:54,710
operators compared engaged in this of

00:21:52,610 --> 00:21:57,500
the optional then defer to corresponding

00:21:54,710 --> 00:21:59,480
operator T so what this means is that

00:21:57,500 --> 00:22:01,310
you can't just define operator equally

00:21:59,480 --> 00:22:02,960
CO and operator less than and try to get

00:22:01,310 --> 00:22:04,550
away with it because a lot of other

00:22:02,960 --> 00:22:07,370
types will actually do the inverse for

00:22:04,550 --> 00:22:10,940
you right whereas optional T if you

00:22:07,370 --> 00:22:12,440
perform a greater operator greater than

00:22:10,940 --> 00:22:14,630
then it's going to actually in

00:22:12,440 --> 00:22:16,700
operator greater than on your tea so if

00:22:14,630 --> 00:22:18,590
you're gonna use optional tea for some

00:22:16,700 --> 00:22:20,270
tea you have to define all the world

00:22:18,590 --> 00:22:25,450
relation operators if you want to use

00:22:20,270 --> 00:22:27,950
them and mixed comparisons are allowed

00:22:25,450 --> 00:22:31,160
optional tea about optional you are

00:22:27,950 --> 00:22:34,130
allowed you can compare also optional

00:22:31,160 --> 00:22:39,710
tea - optional optional tea to some

00:22:34,130 --> 00:22:41,570
value you and the optional tea a new

00:22:39,710 --> 00:22:44,450
comparison the last one there that I

00:22:41,570 --> 00:22:46,460
showed is actually really dangerous and

00:22:44,450 --> 00:22:48,950
we'll see an example of that the only

00:22:46,460 --> 00:22:51,050
benefit that I know of that comes from

00:22:48,950 --> 00:22:52,630
the optional tea to you comparison is

00:22:51,050 --> 00:22:54,980
when you're doing heterogeneous

00:22:52,630 --> 00:22:57,020
heterogeneous lookup for on associative

00:22:54,980 --> 00:22:59,360
containers so if you have an optional

00:22:57,020 --> 00:23:02,090
tea inside of a map and you want to just

00:22:59,360 --> 00:23:04,580
look up by using a tea without having to

00:23:02,090 --> 00:23:06,770
construct an optional tea then like we

00:23:04,580 --> 00:23:09,380
saw in the function parameter example

00:23:06,770 --> 00:23:10,880
for you for instance then you can use

00:23:09,380 --> 00:23:12,410
this up then you can use this comparison

00:23:10,880 --> 00:23:18,020
operator to actually perform that

00:23:12,410 --> 00:23:20,840
comparison but it's it's a it's a

00:23:18,020 --> 00:23:22,670
questionable use case I think so I

00:23:20,840 --> 00:23:24,200
talked about relational operators being

00:23:22,670 --> 00:23:40,750
there in order to allow storing in

00:23:24,200 --> 00:23:40,750
containers so yeah yes

00:23:41,590 --> 00:23:50,799
it is right but there's a oh oh so sir

00:23:48,039 --> 00:23:52,419
the question was I had an example where

00:23:50,799 --> 00:23:55,120
I had an optional string compare

00:23:52,419 --> 00:23:56,679
comparing to a constant R star and is

00:23:55,120 --> 00:23:59,559
that safe because that's clearly a

00:23:56,679 --> 00:24:01,360
optional T to you comparison and the

00:23:59,559 --> 00:24:03,429
answer is that it that in that

00:24:01,360 --> 00:24:04,600
particular example it is safe and it

00:24:03,429 --> 00:24:06,210
will go through an example where it's

00:24:04,600 --> 00:24:09,490
not safe

00:24:06,210 --> 00:24:12,840
so storing containers so what I want to

00:24:09,490 --> 00:24:15,340
do here is vote on ice cream flavors and

00:24:12,840 --> 00:24:17,470
this is the flavors that are available

00:24:15,340 --> 00:24:21,429
at my favorite coffee

00:24:17,470 --> 00:24:23,200
sorry ice cream shop assuming I live in

00:24:21,429 --> 00:24:29,049
several Scott they're pretty elaborate

00:24:23,200 --> 00:24:30,970
flavors but some people don't like ice

00:24:29,049 --> 00:24:32,740
cream ok so then they don't have a

00:24:30,970 --> 00:24:34,990
favorite ice cream flavor I don't

00:24:32,740 --> 00:24:36,820
understand it but fine we'll make an

00:24:34,990 --> 00:24:40,240
optional optional ice cream flavor for

00:24:36,820 --> 00:24:41,980
them and we want to take the votes let's

00:24:40,240 --> 00:24:44,250
say that we're stored in a vector of

00:24:41,980 --> 00:24:47,980
optional optional ice cream flavor and

00:24:44,250 --> 00:24:49,480
we want to collate that into a map and

00:24:47,980 --> 00:24:51,700
we can just do we can just iterate

00:24:49,480 --> 00:24:54,250
through the boats and insert it into a

00:24:51,700 --> 00:24:56,230
map and increment and this works because

00:24:54,250 --> 00:24:59,980
you can week it you can compare optional

00:24:56,230 --> 00:25:03,539
optional to each other and map we'll

00:24:59,980 --> 00:25:03,539
just use that operator and it'll be fine

00:25:03,960 --> 00:25:07,590
okay so this is the example where it's

00:25:06,460 --> 00:25:10,899
not safe

00:25:07,590 --> 00:25:12,789
so optional izing I'm by optional izing

00:25:10,899 --> 00:25:15,850
I'm talking about transforming a tea

00:25:12,789 --> 00:25:17,140
into an optional tea I thought I made up

00:25:15,850 --> 00:25:19,690
made-up this word but merriam-webster

00:25:17,140 --> 00:25:22,510
says it's actually a word so okay so

00:25:19,690 --> 00:25:24,250
this example I have a car instance and I

00:25:22,510 --> 00:25:26,850
have some max speed and that's like

00:25:24,250 --> 00:25:29,830
kilometers per hour because Canadian

00:25:26,850 --> 00:25:32,230
it's going to have a get speed function

00:25:29,830 --> 00:25:33,279
which will return the current speed in

00:25:32,230 --> 00:25:34,450
kilometers per hour

00:25:33,279 --> 00:25:36,669
and we have some function that

00:25:34,450 --> 00:25:38,289
determines whether whether whether we

00:25:36,669 --> 00:25:40,750
can accelerate or not and imagine this

00:25:38,289 --> 00:25:43,450
is some self-driving car that determines

00:25:40,750 --> 00:25:45,130
whether it can speed up or not right so

00:25:43,450 --> 00:25:48,730
we can say get speed less than max speed

00:25:45,130 --> 00:25:50,500
should be trivially correct now the

00:25:48,730 --> 00:25:52,659
speedometer might be broken

00:25:50,500 --> 00:25:54,370
what do we do we can't just stop all

00:25:52,659 --> 00:25:55,150
operations just because the speedometer

00:25:54,370 --> 00:25:58,780
is broken maybe

00:25:55,150 --> 00:26:00,970
don't speed up right and so let's say we

00:25:58,780 --> 00:26:02,500
make that be an optional and we return

00:26:00,970 --> 00:26:05,500
an all opt if the speedometer is

00:26:02,500 --> 00:26:07,059
non-functional and let's say that we

00:26:05,500 --> 00:26:10,800
don't know about this use of can't

00:26:07,059 --> 00:26:13,660
accelerate now we're going to invoke the

00:26:10,800 --> 00:26:18,760
the behavior where we have optional T

00:26:13,660 --> 00:26:24,940
less than u and because now opt compares

00:26:18,760 --> 00:26:27,550
less than everything will say yeah you

00:26:24,940 --> 00:26:29,500
can accelerate if your if your

00:26:27,550 --> 00:26:34,320
speedometer is broken you can't

00:26:29,500 --> 00:26:38,020
accelerate this is this is not good

00:26:34,320 --> 00:26:39,490
so my recommendation here is that when

00:26:38,020 --> 00:26:41,020
you're when you're having when you're

00:26:39,490 --> 00:26:46,980
making the transformation from T to

00:26:41,020 --> 00:26:49,750
optional T either introduce an

00:26:46,980 --> 00:26:51,610
intermediate type which tries to delete

00:26:49,750 --> 00:26:53,110
the relationship or the relational

00:26:51,610 --> 00:26:54,730
operators so that you can catch these

00:26:53,110 --> 00:26:58,660
catch the instances of these and make

00:26:54,730 --> 00:27:00,850
sure that they're correct or be really

00:26:58,660 --> 00:27:02,470
careful but at least but at least I

00:27:00,850 --> 00:27:03,640
wanted to I wanted you to be aware of

00:27:02,470 --> 00:27:07,150
this problem so that you can look out

00:27:03,640 --> 00:27:08,740
for them if you run into them and here's

00:27:07,150 --> 00:27:10,090
a summary of the Delta from boost

00:27:08,740 --> 00:27:13,120
optional for those of you who may be

00:27:10,090 --> 00:27:16,710
really familiar with boost optional most

00:27:13,120 --> 00:27:19,660
of them are just my incremental

00:27:16,710 --> 00:27:21,340
incremental improvements the the one

00:27:19,660 --> 00:27:23,790
that I find is the most important is

00:27:21,340 --> 00:27:25,900
probably the forwarding constructor

00:27:23,790 --> 00:27:27,760
boost optional doesn't have a foreign

00:27:25,900 --> 00:27:30,760
constructor and what that means is my

00:27:27,760 --> 00:27:33,610
example of saying optional string x

00:27:30,760 --> 00:27:34,330
equals string literal doesn't work and

00:27:33,610 --> 00:27:37,270
boost

00:27:34,330 --> 00:27:39,450
whereas in suppose 217 not example will

00:27:37,270 --> 00:27:41,710
work because Wilfork perfect for the

00:27:39,450 --> 00:27:45,160
string literal on to the string

00:27:41,710 --> 00:27:47,080
constructor not going to go through all

00:27:45,160 --> 00:27:50,040
of these but this brings us to variance

00:27:47,080 --> 00:27:54,600
and let's see where am I

00:27:50,040 --> 00:27:57,150
okay so the conceptual model for variant

00:27:54,600 --> 00:27:58,500
is that it's a typesafe Union another

00:27:57,150 --> 00:28:00,090
way to look at it is that it's a

00:27:58,500 --> 00:28:04,860
discriminated union of the types that

00:28:00,090 --> 00:28:07,350
was given and another way to look at it

00:28:04,860 --> 00:28:09,750
that I like to look at it is that it's a

00:28:07,350 --> 00:28:11,730
abstract base class wrapped up into a

00:28:09,750 --> 00:28:14,280
value type and I'll show what that what

00:28:11,730 --> 00:28:16,650
I mean by illustration here so again we

00:28:14,280 --> 00:28:20,330
have some shape s and we aside we

00:28:16,650 --> 00:28:23,100
construct a circle and assign to it and

00:28:20,330 --> 00:28:24,900
on the very inside similar to optional

00:28:23,100 --> 00:28:27,150
it's going to store the value in place

00:28:24,900 --> 00:28:29,510
so the variant is going to be at least

00:28:27,150 --> 00:28:32,430
as big as the largest alternative and

00:28:29,510 --> 00:28:34,890
then when we and then we're gonna we're

00:28:32,430 --> 00:28:39,540
going to store the circle inside the

00:28:34,890 --> 00:28:42,420
variant quick overview of the API

00:28:39,540 --> 00:28:44,900
I have variant in string assigning a

00:28:42,420 --> 00:28:47,670
string string literal that's going to

00:28:44,900 --> 00:28:50,010
initialize the string alternative you

00:28:47,670 --> 00:28:51,660
have a holds alternative function which

00:28:50,010 --> 00:28:53,490
tells you whether the variant is holding

00:28:51,660 --> 00:28:56,910
the type that you that you ask that you

00:28:53,490 --> 00:28:58,320
ask the get function is a check gate

00:28:56,910 --> 00:29:00,630
function which allows which gives you

00:28:58,320 --> 00:29:05,900
access into the value that the Burien is

00:29:00,630 --> 00:29:09,000
holding variant default constructor I

00:29:05,900 --> 00:29:12,780
don't to get too deep into it but very

00:29:09,000 --> 00:29:14,100
default constructor is enabled if the

00:29:12,780 --> 00:29:18,150
first alternative is default

00:29:14,100 --> 00:29:20,010
constructible so in this case when I

00:29:18,150 --> 00:29:21,870
default constructor variant we're going

00:29:20,010 --> 00:29:25,080
to initialize the int and default

00:29:21,870 --> 00:29:27,360
constructor to zero we have the index

00:29:25,080 --> 00:29:30,090
function to check which which

00:29:27,360 --> 00:29:31,680
alternative is currently active now

00:29:30,090 --> 00:29:34,290
particularly useful unless you're

00:29:31,680 --> 00:29:36,510
writing some kind of generic program and

00:29:34,290 --> 00:29:38,550
a get if function which is which is

00:29:36,510 --> 00:29:41,100
another checked access except that gives

00:29:38,550 --> 00:29:41,820
you a pointer failure as opposed to

00:29:41,100 --> 00:29:44,520
throwing an exception

00:29:41,820 --> 00:29:47,310
so the read exception the get function

00:29:44,520 --> 00:29:49,500
is a checked checked' access access sir

00:29:47,310 --> 00:29:55,470
that will throw an exception upon

00:29:49,500 --> 00:29:59,570
failure and again value semantics they

00:29:55,470 --> 00:30:01,430
struck their called correctly use cases

00:29:59,570 --> 00:30:04,580
these are the three make three cases

00:30:01,430 --> 00:30:08,210
that I want to cover we have Union like

00:30:04,580 --> 00:30:12,470
class flat closed class hierarchy closed

00:30:08,210 --> 00:30:13,970
in quotes and visitor pattern so this is

00:30:12,470 --> 00:30:16,400
what a union union like class might look

00:30:13,970 --> 00:30:20,270
like we're going to implement a animal

00:30:16,400 --> 00:30:22,850
hierarchy it's a generic example so that

00:30:20,270 --> 00:30:24,980
you can relate to it perhaps easier so

00:30:22,850 --> 00:30:27,560
we have cat dog horse and we're going to

00:30:24,980 --> 00:30:30,920
create an animal hierarchy a flat

00:30:27,560 --> 00:30:33,260
hierarchy and we're going to use a union

00:30:30,920 --> 00:30:36,110
to store the values and use an enum to

00:30:33,260 --> 00:30:37,490
figure out keep the discriminator and we

00:30:36,110 --> 00:30:39,500
could then we can just destroy the

00:30:37,490 --> 00:30:42,560
objects correctly construct correctly

00:30:39,500 --> 00:30:44,020
etc and with that in place we can

00:30:42,560 --> 00:30:46,220
implement this get sound function

00:30:44,020 --> 00:30:48,100
completely outside of the class class

00:30:46,220 --> 00:30:51,710
definition right we can have we can

00:30:48,100 --> 00:30:53,660
switch on the animal kind and then look

00:30:51,710 --> 00:30:55,240
into the values and do whatever we want

00:30:53,660 --> 00:30:58,750
with it

00:30:55,240 --> 00:31:01,190
to implement this get sound function now

00:30:58,750 --> 00:31:03,470
this code this is this is missing a lot

00:31:01,190 --> 00:31:06,020
of code right this only supports

00:31:03,470 --> 00:31:08,570
construction and destruction we don't

00:31:06,020 --> 00:31:10,340
support copy we don't support move we

00:31:08,570 --> 00:31:13,160
don't support accessors assignment

00:31:10,340 --> 00:31:16,880
visitation etc so after we add all of

00:31:13,160 --> 00:31:19,730
that we would get value semantics we

00:31:16,880 --> 00:31:21,920
were able to add not add new algorithms

00:31:19,730 --> 00:31:23,810
not intrusively with that whatever what

00:31:21,920 --> 00:31:24,830
I mean by that is the animal class

00:31:23,810 --> 00:31:26,810
doesn't have to change

00:31:24,830 --> 00:31:29,090
but it's error-prone due to the manual

00:31:26,810 --> 00:31:31,970
pairing of enum and the value we have to

00:31:29,090 --> 00:31:34,400
get the enum and the access into the

00:31:31,970 --> 00:31:38,690
value matched up perfectly otherwise we

00:31:34,400 --> 00:31:42,230
have a bug this is probably of example

00:31:38,690 --> 00:31:44,210
perhaps more familiar to people this we

00:31:42,230 --> 00:31:47,270
have abstract base class called animal

00:31:44,210 --> 00:31:49,190
and we have three classes dining area

00:31:47,270 --> 00:31:52,840
from it cat vomit horse we're going to

00:31:49,190 --> 00:31:52,840
implement the virtual function yet sound

00:31:53,050 --> 00:31:58,460
so immediately well we lost value

00:31:56,000 --> 00:32:01,250
semantics because we can't be passing

00:31:58,460 --> 00:32:04,880
around in here entirely like this

00:32:01,250 --> 00:32:07,190
without a pointer we incur amic

00:32:04,880 --> 00:32:09,800
allocation where we have to manage the

00:32:07,190 --> 00:32:11,360
memory yeah we can use unique Peter at a

00:32:09,800 --> 00:32:13,250
unit pointer and shared pointer for that

00:32:11,360 --> 00:32:16,340
now but it's still some

00:32:13,250 --> 00:32:18,320
you have to manage somehow a dual

00:32:16,340 --> 00:32:19,820
citizenship is difficult and by dual

00:32:18,320 --> 00:32:22,460
citizenship I just mean membership in

00:32:19,820 --> 00:32:26,120
multiple hierarchies and that leads to

00:32:22,460 --> 00:32:27,650
multiple inheritance and yeah not a lot

00:32:26,120 --> 00:32:31,610
of people like both the Harrisons be

00:32:27,650 --> 00:32:34,610
included and it's intrusive to add new

00:32:31,610 --> 00:32:36,920
algorithms so add a single algorithm we

00:32:34,610 --> 00:32:39,470
have to actually go to every subclass of

00:32:36,920 --> 00:32:40,850
animal and add a separate function when

00:32:39,470 --> 00:32:42,620
you're trying to reason about the get

00:32:40,850 --> 00:32:45,410
sound function you might you might have

00:32:42,620 --> 00:32:47,720
to open up 15 separate files and jump

00:32:45,410 --> 00:32:49,400
across them to see oh is the get sound

00:32:47,720 --> 00:32:51,770
thing doing its thing are doing the

00:32:49,400 --> 00:32:53,600
correct thing so it's grouped by type as

00:32:51,770 --> 00:32:55,100
opposed to algorithms and sometimes we

00:32:53,600 --> 00:32:58,520
want them grouped by algorithms so that

00:32:55,100 --> 00:32:59,870
it's easier to see what's going on so if

00:32:58,520 --> 00:33:02,900
you want to talk if you if you want to

00:32:59,870 --> 00:33:05,300
learn more about why classic

00:33:02,900 --> 00:33:08,750
polymorphism is not great Luigi has a

00:33:05,300 --> 00:33:15,230
talk on Thursday that you can go and

00:33:08,750 --> 00:33:17,660
check out visitor pattern so visitor

00:33:15,230 --> 00:33:19,550
pattern existed for a long time a lot of

00:33:17,660 --> 00:33:21,200
people have used it in the past and this

00:33:19,550 --> 00:33:23,840
is kind of the ceremony of how to set it

00:33:21,200 --> 00:33:26,570
up right we forward Eclair the final

00:33:23,840 --> 00:33:28,760
class is we declare the abstract visitor

00:33:26,570 --> 00:33:31,430
then all the final classes except in

00:33:28,760 --> 00:33:34,550
define they're accept functions where

00:33:31,430 --> 00:33:36,530
they pass pass along themselves so that

00:33:34,550 --> 00:33:40,010
we can figure out what the final type is

00:33:36,530 --> 00:33:42,020
and then the usage of it of using with

00:33:40,010 --> 00:33:44,150
get sound would look like this where we

00:33:42,020 --> 00:33:46,880
define a get sound visitor which

00:33:44,150 --> 00:33:48,470
inherits from the base visitor and that

00:33:46,880 --> 00:33:49,850
we can't actually return the result

00:33:48,470 --> 00:33:52,790
directly because the visitor can't

00:33:49,850 --> 00:33:55,070
return return results directly so we

00:33:52,790 --> 00:33:57,500
have to have this intermediate result

00:33:55,070 --> 00:34:03,290
thing that we propagate the result out

00:33:57,500 --> 00:34:05,660
to it works it allows us to so yeah we

00:34:03,290 --> 00:34:08,090
got back the ability to add new

00:34:05,660 --> 00:34:09,770
algorithms non-intrusive li and that's

00:34:08,090 --> 00:34:11,419
more or less all we get with it it's a

00:34:09,770 --> 00:34:14,210
lot of boilerplate right the ceremony

00:34:11,419 --> 00:34:15,530
was a lot and then it's it's also

00:34:14,210 --> 00:34:19,460
inefficient because we have to do two

00:34:15,530 --> 00:34:23,990
jumps so here's what it looks like with

00:34:19,460 --> 00:34:26,790
variant we have a cat dog horse variant

00:34:23,990 --> 00:34:30,120
cat dog horse

00:34:26,790 --> 00:34:33,540
we're done we implement the gut sound

00:34:30,120 --> 00:34:35,340
function we use the visit function which

00:34:33,540 --> 00:34:37,290
is which allows you which allows us to

00:34:35,340 --> 00:34:42,389
write essentially the same code as what

00:34:37,290 --> 00:34:44,010
we were writing for visitors so what do

00:34:42,389 --> 00:34:45,480
we just do well we got back value

00:34:44,010 --> 00:34:47,610
semantics because variant has value

00:34:45,480 --> 00:34:48,120
semantics it's going to store cat dog or

00:34:47,610 --> 00:34:50,850
horse

00:34:48,120 --> 00:34:53,669
fully in its in within it within its

00:34:50,850 --> 00:34:57,420
object you can add new algorithms not

00:34:53,669 --> 00:34:58,710
intrusive Li as we just saw no manual

00:34:57,420 --> 00:35:02,100
pairing of the discriminator and the

00:34:58,710 --> 00:35:03,650
value dual citizenship is easy if you

00:35:02,100 --> 00:35:06,570
want horse to be part of a

00:35:03,650 --> 00:35:08,820
transportation hierarchy toss it in

00:35:06,570 --> 00:35:10,560
there and it's it's just a horse there's

00:35:08,820 --> 00:35:15,120
no association with either of the

00:35:10,560 --> 00:35:17,100
hierarchies it just exists one - maybe

00:35:15,120 --> 00:35:19,620
there's a code bloat I haven't actually

00:35:17,100 --> 00:35:25,200
seen this in practice but having poor

00:35:19,620 --> 00:35:26,490
pluses seemed overly optimistic alright

00:35:25,200 --> 00:35:27,780
a few more things and it's not all

00:35:26,490 --> 00:35:31,500
pretty right because we're gonna talk

00:35:27,780 --> 00:35:34,140
about fabulous by exception now so by

00:35:31,500 --> 00:35:35,880
list by exception state happens if an

00:35:34,140 --> 00:35:38,400
exception is thrown during a type

00:35:35,880 --> 00:35:42,990
changing operation so if I have a

00:35:38,400 --> 00:35:46,050
variant tu and I'm in the T State and I

00:35:42,990 --> 00:35:48,150
try to assign a you and we're going so

00:35:46,050 --> 00:35:51,060
we're gonna we're gonna do is destroy

00:35:48,150 --> 00:35:54,780
the T try to construct the U in place if

00:35:51,060 --> 00:36:00,650
that throws well we have nothing now

00:35:54,780 --> 00:36:03,420
what do we do so there were probably I

00:36:00,650 --> 00:36:06,960
want to say probably around 2000 emails

00:36:03,420 --> 00:36:09,060
sent around in the internal mailing list

00:36:06,960 --> 00:36:11,790
in the Standards Committee as well as a

00:36:09,060 --> 00:36:15,600
public forum that I started the fire on

00:36:11,790 --> 00:36:17,340
accidentally to discuss what to do here

00:36:15,600 --> 00:36:21,690
there were there were options like

00:36:17,340 --> 00:36:24,600
double buffering they're always always

00:36:21,690 --> 00:36:30,930
always making a variant BM theable and

00:36:24,600 --> 00:36:33,660
what we got is a rarely empty variant so

00:36:30,930 --> 00:36:35,790
if not all if all of your types are no

00:36:33,660 --> 00:36:38,310
except moveable then you can't get into

00:36:35,790 --> 00:36:41,270
another strike session state how many

00:36:38,310 --> 00:36:41,270
people think this is true

00:36:41,990 --> 00:36:49,460
how many people wish this was true not a

00:36:47,310 --> 00:36:51,960
lot of people okay so this is not true

00:36:49,460 --> 00:36:54,810
any variant can actually get into an

00:36:51,960 --> 00:36:57,180
exception state and this is quite

00:36:54,810 --> 00:36:59,760
unfortunate I think so we have some

00:36:57,180 --> 00:37:01,890
nasty struct that implements about

00:36:59,760 --> 00:37:04,020
implicit operator to int we have a

00:37:01,890 --> 00:37:05,849
variant int float which we think is

00:37:04,020 --> 00:37:08,640
innocent neither of them can throw

00:37:05,849 --> 00:37:11,280
during construction except we can write

00:37:08,640 --> 00:37:13,109
we can have this nasty object when we

00:37:11,280 --> 00:37:16,880
try to in place it's going to throw

00:37:13,109 --> 00:37:22,740
during an attempt to construct an INT

00:37:16,880 --> 00:37:25,170
sad okay well so in what situations that

00:37:22,740 --> 00:37:26,550
we actually have to deal with this well

00:37:25,170 --> 00:37:28,320
you already had an exception thrown

00:37:26,550 --> 00:37:30,210
right you're gonna you're gonna you

00:37:28,320 --> 00:37:32,250
would have had to catch some exception

00:37:30,210 --> 00:37:34,109
and then you would have to proceed to

00:37:32,250 --> 00:37:36,480
ignore that exception and leave the

00:37:34,109 --> 00:37:38,040
variant in a valid exception state in

00:37:36,480 --> 00:37:41,310
order for it to have left at the catch

00:37:38,040 --> 00:37:43,230
Clause so my recommendation is don't let

00:37:41,310 --> 00:37:45,780
I like to be paralyzed by exception

00:37:43,230 --> 00:37:47,040
state leave the catch clauses so if it

00:37:45,780 --> 00:37:49,589
ever were to happen

00:37:47,040 --> 00:37:51,660
keep it inside the catch Clause we set

00:37:49,589 --> 00:37:54,180
it to at least restart it through some

00:37:51,660 --> 00:37:57,960
dummy state or whatever but don't let it

00:37:54,180 --> 00:38:01,020
propagate and let's not be checking for

00:37:57,960 --> 00:38:03,570
values by exception everywhere right not

00:38:01,020 --> 00:38:05,310
every function needs to check for values

00:38:03,570 --> 00:38:08,550
by exception at the top of its top of

00:38:05,310 --> 00:38:10,010
its definition and my argument for this

00:38:08,550 --> 00:38:12,990
is pretty simple

00:38:10,010 --> 00:38:15,990
when you get a reference to an int in a

00:38:12,990 --> 00:38:20,040
function right can you check whether

00:38:15,990 --> 00:38:21,839
that thing is in uninitialized no

00:38:20,040 --> 00:38:23,070
there's not even a way to do that but if

00:38:21,839 --> 00:38:25,740
you were to use it it would be undefined

00:38:23,070 --> 00:38:27,450
behavior so there are some cases where

00:38:25,740 --> 00:38:29,369
we don't even allow you to check for the

00:38:27,450 --> 00:38:31,470
check for what the state of the object

00:38:29,369 --> 00:38:33,150
you got is another example that came up

00:38:31,470 --> 00:38:37,440
earlier was that man is a magic value

00:38:33,150 --> 00:38:38,820
and if you get a double in inside every

00:38:37,440 --> 00:38:42,900
function that takes a double do you

00:38:38,820 --> 00:38:44,250
check for them if you check for an and

00:38:42,900 --> 00:38:47,550
if your type of person who checks for

00:38:44,250 --> 00:38:50,099
then and every function alright yeah go

00:38:47,550 --> 00:38:51,839
for it use check for values by exception

00:38:50,099 --> 00:38:54,329
everywhere but if there's a type of

00:38:51,839 --> 00:38:57,119
person like me who kind of

00:38:54,329 --> 00:38:58,709
trust others and assume that doubles

00:38:57,119 --> 00:39:01,079
probably aren't going to be Nan's all

00:38:58,709 --> 00:39:02,429
over the place then we really don't need

00:39:01,079 --> 00:39:03,179
to be checking for values by exception

00:39:02,429 --> 00:39:08,009
all over the place

00:39:03,179 --> 00:39:10,349
for variant either let's cover a few

00:39:08,009 --> 00:39:11,609
more things mono state is similar to

00:39:10,349 --> 00:39:14,519
boost blank if you're familiar with that

00:39:11,609 --> 00:39:16,079
as the first type it makes any barrier

00:39:14,519 --> 00:39:17,429
people constructible because variant

00:39:16,079 --> 00:39:19,739
will try to default constructor first

00:39:17,429 --> 00:39:22,410
out first type and mono state is

00:39:19,739 --> 00:39:24,059
constructal constructible so if you need

00:39:22,410 --> 00:39:25,859
your variant to be default constructible

00:39:24,059 --> 00:39:27,150
when you don't have anything else when

00:39:25,859 --> 00:39:28,949
none of your types are difficult our

00:39:27,150 --> 00:39:31,979
table tops mono state in there and it'll

00:39:28,949 --> 00:39:33,809
become default constructible it's a unit

00:39:31,979 --> 00:39:36,839
type to add an empty state to a variant

00:39:33,809 --> 00:39:39,390
so it allows you to so variant is

00:39:36,839 --> 00:39:42,390
supposed to be a distributing Union that

00:39:39,390 --> 00:39:45,150
holds exactly one value of the given

00:39:42,390 --> 00:39:47,009
types right and in this case we want to

00:39:45,150 --> 00:39:49,589
actually explicitly add an empty state

00:39:47,009 --> 00:39:51,089
because we have some situation where it

00:39:49,589 --> 00:39:54,660
could be empty any makes sense for it

00:39:51,089 --> 00:39:56,160
for for our case and the existence of

00:39:54,660 --> 00:39:58,170
mono state doesn't change any behavior

00:39:56,160 --> 00:40:00,239
favorite for variant so it's not going

00:39:58,170 --> 00:40:01,949
to say oh you have a you have a mono

00:40:00,239 --> 00:40:04,199
state so when I throw an exception I'll

00:40:01,949 --> 00:40:05,640
try to see if I can construct that mono

00:40:04,199 --> 00:40:07,979
state instead to give you some more

00:40:05,640 --> 00:40:09,900
deterministic behavior there's no

00:40:07,979 --> 00:40:11,849
special casing for mono state whatsoever

00:40:09,900 --> 00:40:13,199
mono state just exist outside of variant

00:40:11,849 --> 00:40:16,589
well it happens to live in the variant

00:40:13,199 --> 00:40:19,859
header for not a great reason I think

00:40:16,589 --> 00:40:24,119
but it it has no association with the

00:40:19,859 --> 00:40:25,559
variant class itself the forwarding

00:40:24,119 --> 00:40:27,959
constructor I think is also interesting

00:40:25,559 --> 00:40:30,449
that I should tell you about so in this

00:40:27,959 --> 00:40:33,299
case we have some variant t0 t1 t2 I

00:40:30,449 --> 00:40:35,759
don't know what t1 T 0 T 1 T 2 are they

00:40:33,299 --> 00:40:37,559
can be cost qualified they can't be

00:40:35,759 --> 00:40:39,719
references but they can be cost

00:40:37,559 --> 00:40:40,890
qualified for example so I have some Fuu

00:40:39,719 --> 00:40:43,170
and I want to initialize it with the

00:40:40,890 --> 00:40:45,869
result of Fuu I don't even know what the

00:40:43,170 --> 00:40:48,509
result of Fuu is so which alternative is

00:40:45,869 --> 00:40:49,739
chosen there must be some sequence of

00:40:48,509 --> 00:40:52,739
steps we take to figure out which

00:40:49,739 --> 00:40:55,949
alternative is chosen right so this is

00:40:52,739 --> 00:40:58,049
what we do we have some ID ID class here

00:40:55,949 --> 00:41:00,359
which just saves the type and not

00:40:58,049 --> 00:41:03,239
construct or construct anything we're

00:41:00,359 --> 00:41:06,660
going to have this fun class which is

00:41:03,239 --> 00:41:10,650
the opera has awkward overloads

00:41:06,660 --> 00:41:13,620
for t0 t1 and t2 and we're going to

00:41:10,650 --> 00:41:17,460
attempt to call this function with the

00:41:13,620 --> 00:41:20,610
result of Fuu and whatever comes out is

00:41:17,460 --> 00:41:23,580
the winner so when you have variant t0

00:41:20,610 --> 00:41:26,220
t1 t2 and you're wondering how do I

00:41:23,580 --> 00:41:28,290
initialize which one of these gets wins

00:41:26,220 --> 00:41:30,630
through what algorithm it's overload

00:41:28,290 --> 00:41:33,030
resolution so put the possum all

00:41:30,630 --> 00:41:35,610
linearly vertically in a little

00:41:33,030 --> 00:41:38,190
resolution and figure out well that's a

00:41:35,610 --> 00:41:41,150
whole whole different set of steps you

00:41:38,190 --> 00:41:45,630
need to study but at least it's

00:41:41,150 --> 00:41:48,510
leveraging one another ok so let's take

00:41:45,630 --> 00:41:51,630
a concrete example we have string we

00:41:48,510 --> 00:41:54,750
have a pool we try to initialize it with

00:41:51,630 --> 00:41:57,810
a string literal ABC what's the result

00:41:54,750 --> 00:41:59,820
here we're performing overload

00:41:57,810 --> 00:42:02,040
resolution with string and bool as

00:41:59,820 --> 00:42:06,690
candidates and we're trying to invoke it

00:42:02,040 --> 00:42:13,560
with a constant our cost our array which

00:42:06,690 --> 00:42:18,240
one wins bool yep so here's Eric's

00:42:13,560 --> 00:42:20,040
opinion about that variant string bool

00:42:18,240 --> 00:42:25,460
and though the start of the second

00:42:20,040 --> 00:42:30,150
alternative yeah okay I agree

00:42:25,460 --> 00:42:32,460
here's the Delta from boost variant the

00:42:30,150 --> 00:42:33,690
important parts here that are that are

00:42:32,460 --> 00:42:36,810
that are bolded or dynamic allocation

00:42:33,690 --> 00:42:38,190
during type changing operation and value

00:42:36,810 --> 00:42:40,260
of slow exception which are essentially

00:42:38,190 --> 00:42:42,630
tied together but I thought it would be

00:42:40,260 --> 00:42:45,300
worth pointing out reference type

00:42:42,630 --> 00:42:50,150
support is not in the standard version

00:42:45,300 --> 00:42:50,150
whereas boost supports reference types

00:42:50,810 --> 00:42:55,110
and some other ones I don't think

00:42:54,150 --> 00:43:03,630
otherwise they're all that important

00:42:55,110 --> 00:43:07,170
actually excuse me ok so shameless plug

00:43:03,630 --> 00:43:10,140
here if you want to use variant and you

00:43:07,170 --> 00:43:13,020
don't have C++ 17 let's say you're back

00:43:10,140 --> 00:43:15,330
in c plus 11 and park very end is a

00:43:13,020 --> 00:43:17,970
library that i've written to make very

00:43:15,330 --> 00:43:19,500
more available for people so this is

00:43:17,970 --> 00:43:22,590
suppose 17 variant

00:43:19,500 --> 00:43:28,290
standard conforming backported to CBS 11

00:43:22,590 --> 00:43:30,740
and 14 so feel free to reach for that if

00:43:28,290 --> 00:43:36,000
you don't have access to suppose for 17

00:43:30,740 --> 00:43:38,490
last type of the day we have any so the

00:43:36,000 --> 00:43:42,360
conceptual model for any is that it's a

00:43:38,490 --> 00:43:43,800
type safe void star I don't actually

00:43:42,360 --> 00:43:47,880
have good really good use cases Friday

00:43:43,800 --> 00:43:49,560
but I'll show one and another look way

00:43:47,880 --> 00:43:52,410
to look at it is that it's a void star

00:43:49,560 --> 00:43:54,150
wrapped up into a value type so again

00:43:52,410 --> 00:43:56,880
another illustration we have some point

00:43:54,150 --> 00:44:00,480
of B to void pointing a nothing we can

00:43:56,880 --> 00:44:04,580
point anything and on the any side we're

00:44:00,480 --> 00:44:08,610
going to actually have the same picture

00:44:04,580 --> 00:44:12,270
so any doesn't hold the value in place

00:44:08,610 --> 00:44:14,490
because well how how big should it be it

00:44:12,270 --> 00:44:16,950
should be able to hold anything so it

00:44:14,490 --> 00:44:19,590
actually holds a pointer it's allowed to

00:44:16,950 --> 00:44:21,990
do small small object optimization but

00:44:19,590 --> 00:44:23,250
in general it's going to create sorry

00:44:21,990 --> 00:44:24,630
it's going to perform a dynamic

00:44:23,250 --> 00:44:28,500
allocation to be able to hold anything

00:44:24,630 --> 00:44:32,040
that it needs to okay well so what's the

00:44:28,500 --> 00:44:34,080
point that well the point is that any

00:44:32,040 --> 00:44:36,960
keeps track of the type that it's

00:44:34,080 --> 00:44:38,880
actually storing so if you pass around a

00:44:36,960 --> 00:44:40,770
void star and you cast it to whatever

00:44:38,880 --> 00:44:42,060
you need it to be you have no idea

00:44:40,770 --> 00:44:43,860
whether that's defined behavior or not

00:44:42,060 --> 00:44:46,370
and void star has no idea what it's

00:44:43,860 --> 00:44:48,480
pointing at whereas any will actually

00:44:46,370 --> 00:44:51,120
keep track of the type that it's holding

00:44:48,480 --> 00:44:53,490
and when you go to access your value out

00:44:51,120 --> 00:44:55,470
of the out of the any if you get the

00:44:53,490 --> 00:44:59,430
wrong one it will elicit it give you an

00:44:55,470 --> 00:45:01,320
error and as the other two types we have

00:44:59,430 --> 00:45:04,130
values of ethics so if you wanted to

00:45:01,320 --> 00:45:07,590
pass around arbitrary data through

00:45:04,130 --> 00:45:09,630
binary boundaries and you wanted to have

00:45:07,590 --> 00:45:12,380
value semantics and not have to manage

00:45:09,630 --> 00:45:18,540
memory then you could use any for that

00:45:12,380 --> 00:45:20,580
so here's an overview of the API we can

00:45:18,540 --> 00:45:22,740
have any ex notice that this is no

00:45:20,580 --> 00:45:25,140
longer a string literal because if it

00:45:22,740 --> 00:45:28,320
was a string literal then any will decay

00:45:25,140 --> 00:45:30,690
that into a into a pointer and the store

00:45:28,320 --> 00:45:32,530
the pointer instead so I've got the

00:45:30,690 --> 00:45:38,350
string lippisch the

00:45:32,530 --> 00:45:41,050
yeah well-well string literal these the

00:45:38,350 --> 00:45:43,810
s suffix which constructs a temporary

00:45:41,050 --> 00:45:45,370
string out of a string literal will

00:45:43,810 --> 00:45:48,670
allow us to actually store the instance

00:45:45,370 --> 00:45:50,950
of stewed string inside of an any any

00:45:48,670 --> 00:45:54,160
has it has value function similar to

00:45:50,950 --> 00:45:57,520
optional but it doesn't have an implicit

00:45:54,160 --> 00:46:00,070
conversion conversion to bool you can

00:45:57,520 --> 00:46:02,530
use any cast to get the value out of the

00:46:00,070 --> 00:46:05,080
any in this case we're getting the

00:46:02,530 --> 00:46:07,890
string the reference the string and then

00:46:05,080 --> 00:46:11,020
we can compare for the expected value

00:46:07,890 --> 00:46:14,890
any is default constructible it will

00:46:11,020 --> 00:46:17,200
hold nothing the type function will

00:46:14,890 --> 00:46:19,030
return type idea void if it holds

00:46:17,200 --> 00:46:20,740
nothing and if it's holding something

00:46:19,030 --> 00:46:24,760
that it's going to return type info of

00:46:20,740 --> 00:46:27,700
the type that it's holding and there are

00:46:24,760 --> 00:46:29,470
two forms of any cast this form of any

00:46:27,700 --> 00:46:32,320
cast that I'm showing here is the

00:46:29,470 --> 00:46:35,140
pointer version and it works similar to

00:46:32,320 --> 00:46:36,580
dynamic cast so in dynamic cast if you

00:46:35,140 --> 00:46:38,530
give it a reference and you get a

00:46:36,580 --> 00:46:40,630
reference back if it fails throws an

00:46:38,530 --> 00:46:42,460
exception if you give it a pointer you

00:46:40,630 --> 00:46:45,700
get a pointer back if that fails you get

00:46:42,460 --> 00:46:47,590
an opener null pointer so those

00:46:45,700 --> 00:46:50,080
semantics are similar except any cast

00:46:47,590 --> 00:46:52,450
doesn't say give me in pointer

00:46:50,080 --> 00:46:54,250
it says int and they're gonna in the

00:46:52,450 --> 00:46:56,440
quarterback this is not our dynamic a

00:46:54,250 --> 00:46:57,790
cast dynamic cast behaves you don't ask

00:46:56,440 --> 00:47:00,640
that I make has to give you an int and

00:46:57,790 --> 00:47:03,430
it gives you an int star back right so

00:47:00,640 --> 00:47:06,010
that's a minor minor quirk I think that

00:47:03,430 --> 00:47:09,430
you should be aware of any cast is

00:47:06,010 --> 00:47:10,420
checked as I mentioned so in the Y case

00:47:09,430 --> 00:47:12,460
I'm not holding anything

00:47:10,420 --> 00:47:16,620
trying to get an InTown can't do that

00:47:12,460 --> 00:47:19,750
will throw in any bad any cast exception

00:47:16,620 --> 00:47:21,760
again illustrating value semantics where

00:47:19,750 --> 00:47:26,650
the string actually gets still copied

00:47:21,760 --> 00:47:32,230
over deeply and any doesn't provide any

00:47:26,650 --> 00:47:34,900
relational operators and as always our

00:47:32,230 --> 00:47:38,320
Mike lifetime destroys the string

00:47:34,900 --> 00:47:42,220
correctly yeah use cases I don't have

00:47:38,320 --> 00:47:44,880
one and I categorize it like this if and

00:47:42,220 --> 00:47:46,180
when you in a template can't work and

00:47:44,880 --> 00:47:48,910
you

00:47:46,180 --> 00:47:50,890
is a variant so what do I mean by that

00:47:48,910 --> 00:47:53,830
where can't work where could you not use

00:47:50,890 --> 00:47:56,170
a template getting through the virtual

00:47:53,830 --> 00:47:59,620
function right a virtual function can't

00:47:56,170 --> 00:48:01,870
be made template and so so you can't

00:47:59,620 --> 00:48:05,110
just pass arbitrary data through a

00:48:01,870 --> 00:48:07,450
virtual function and let's say variant

00:48:05,110 --> 00:48:11,230
isn't enough because it's actually truly

00:48:07,450 --> 00:48:14,920
open to whatever about whatever type of

00:48:11,230 --> 00:48:17,080
value or the hold so in this case we

00:48:14,920 --> 00:48:19,420
have some consumer class and a virtual

00:48:17,080 --> 00:48:21,820
notify function and we could use any to

00:48:19,420 --> 00:48:27,180
pass arbitrary data through the virtual

00:48:21,820 --> 00:48:31,210
function this is a delta from boost any

00:48:27,180 --> 00:48:35,350
not much boost any sorry and still any

00:48:31,210 --> 00:48:37,440
is mostly boost any kept intact there

00:48:35,350 --> 00:48:39,940
weren't there weren't much that happened

00:48:37,440 --> 00:48:42,520
between those there and honestly I think

00:48:39,940 --> 00:48:46,210
it's because not a lot of people use it

00:48:42,520 --> 00:48:51,520
and need it so here are some minor

00:48:46,210 --> 00:48:55,090
differences that I found so here's the

00:48:51,520 --> 00:48:57,040
summary of what we saw these types that

00:48:55,090 --> 00:48:58,540
I introduced today well that we

00:48:57,040 --> 00:49:01,150
introduced today that we introduced in

00:48:58,540 --> 00:49:02,740
episode 17 have value semantics and I

00:49:01,150 --> 00:49:05,470
mentioned that these are the

00:49:02,740 --> 00:49:10,000
corresponding reference semantics that

00:49:05,470 --> 00:49:12,010
exist in the language today and the

00:49:10,000 --> 00:49:16,450
number of possible states of each of

00:49:12,010 --> 00:49:18,250
these types look like that so optional T

00:49:16,450 --> 00:49:20,470
the number of states in which that

00:49:18,250 --> 00:49:22,600
optional T can be in is the number of

00:49:20,470 --> 00:49:25,990
states in which the T can be in plus the

00:49:22,600 --> 00:49:28,600
no op state so plus 1 the variant T's if

00:49:25,990 --> 00:49:31,090
you have variant tu the number of states

00:49:28,600 --> 00:49:33,100
that you can be in is the sum of the

00:49:31,090 --> 00:49:36,640
number of states in T and the plus the

00:49:33,100 --> 00:49:38,620
number of states and you so this is that

00:49:36,640 --> 00:49:42,820
described in sequel so 17 fold

00:49:38,620 --> 00:49:45,160
expressions because why not and any the

00:49:42,820 --> 00:49:46,680
number of states is infinite you can

00:49:45,160 --> 00:49:49,510
literally hold anything so I have

00:49:46,680 --> 00:49:53,020
there's no bonus to the number of states

00:49:49,510 --> 00:49:56,040
of an any so this is my summary of how I

00:49:53,020 --> 00:49:59,140
think these three things are related

00:49:56,040 --> 00:49:59,890
I'll point out again that an optional

00:49:59,140 --> 00:50:04,019
option

00:49:59,890 --> 00:50:07,180
and any can be empty whereas variant

00:50:04,019 --> 00:50:09,579
can't be empty but it can be valueless

00:50:07,180 --> 00:50:12,940
by exception state and this is the last

00:50:09,579 --> 00:50:14,470
thing I'll say which is the empty state

00:50:12,940 --> 00:50:16,000
and the valleys are valueless by

00:50:14,470 --> 00:50:18,579
exception state is really different in

00:50:16,000 --> 00:50:21,609
that you don't for example when you

00:50:18,579 --> 00:50:23,650
visit a very visitor variant if your

00:50:21,609 --> 00:50:25,029
variant has an empty state you need to

00:50:23,650 --> 00:50:27,579
handle that empty state and your and

00:50:25,029 --> 00:50:30,519
your visitor whereas the value despite

00:50:27,579 --> 00:50:33,010
exception state is not a is not a state

00:50:30,519 --> 00:50:35,230
that you actually add it doesn't appear

00:50:33,010 --> 00:50:37,690
as a case and your visitor because it's

00:50:35,230 --> 00:50:39,930
an invalid variant right as opposed to

00:50:37,690 --> 00:50:42,250
an empty state which is actually a valid

00:50:39,930 --> 00:50:46,359
perfectly valid state that you actually

00:50:42,250 --> 00:50:48,609
are benefiting from so that's everything

00:50:46,359 --> 00:50:51,010
that I had today

00:50:48,609 --> 00:50:52,630
oh one more okay so order of reference

00:50:51,010 --> 00:50:54,039
when you're choosing which one of these

00:50:52,630 --> 00:50:55,690
do you think you should reach for I

00:50:54,039 --> 00:50:58,569
think you should go for start from

00:50:55,690 --> 00:50:59,380
optional see if that'll work if it

00:50:58,569 --> 00:51:01,960
doesn't work you have too many

00:50:59,380 --> 00:51:04,869
alternatives to try to use a variant if

00:51:01,960 --> 00:51:07,259
that fails then using any so I think

00:51:04,869 --> 00:51:11,700
that should be the older preference here

00:51:07,259 --> 00:51:16,119
okay so that's everything I had any

00:51:11,700 --> 00:51:16,779
questions I think we have ten minutes

00:51:16,119 --> 00:51:19,710
left

00:51:16,779 --> 00:51:19,710
perfect

00:51:24,089 --> 00:51:32,569
do I just like conduct this myself okay

00:51:27,749 --> 00:51:35,699
on your own or so for a variant of tu T

00:51:32,569 --> 00:51:37,890
the forwarding constructor does it just

00:51:35,699 --> 00:51:40,349
before your constructor that was the

00:51:37,890 --> 00:51:41,400
Ford constructor does it simply as

00:51:40,349 --> 00:51:44,579
you're trying to figure out with the

00:51:41,400 --> 00:51:47,609
algorithm which to construct which right

00:51:44,579 --> 00:51:51,719
I D of T right is it the in the first

00:51:47,609 --> 00:51:54,420
index of T that you end up with no so if

00:51:51,719 --> 00:51:55,709
you have duplicates and you have and you

00:51:54,420 --> 00:51:57,180
try to Ford because the forward

00:51:55,709 --> 00:51:58,729
constructor is actually the same so the

00:51:57,180 --> 00:52:01,979
question is if you have duplicate types

00:51:58,729 --> 00:52:03,799
for example if you have variant tu T and

00:52:01,979 --> 00:52:06,059
then you try to use the for constructor

00:52:03,799 --> 00:52:08,309
let's say you try to initialize the T

00:52:06,059 --> 00:52:10,979
initialize the variant tu t with an

00:52:08,309 --> 00:52:13,890
instance of T what happens what happens

00:52:10,979 --> 00:52:16,799
is it doesn't compile it doesn't just

00:52:13,890 --> 00:52:17,339
magically initialize the first one or

00:52:16,799 --> 00:52:22,319
anything like that

00:52:17,339 --> 00:52:25,499
great thank you all right so I see that

00:52:22,319 --> 00:52:28,519
the standard vocabulary types as opposed

00:52:25,499 --> 00:52:31,319
to boost don't support references as

00:52:28,519 --> 00:52:32,880
parameter I know that you know

00:52:31,319 --> 00:52:34,619
technically it will never store a

00:52:32,880 --> 00:52:37,920
reference since a reference as well as a

00:52:34,619 --> 00:52:39,539
destructible object yep but is the

00:52:37,920 --> 00:52:42,150
solution right now is this in the

00:52:39,539 --> 00:52:44,689
standard to use explicitly a reference

00:52:42,150 --> 00:52:47,999
wrapper or a similar type if we want

00:52:44,689 --> 00:52:52,319
reference Ament --ax yeah so the

00:52:47,999 --> 00:52:56,369
question is why is or the vocabulary

00:52:52,319 --> 00:52:57,989
types these I think referred to qualify

00:52:56,369 --> 00:52:59,219
as vocabulary types don't seem to

00:52:57,989 --> 00:53:01,589
support reference reference types

00:52:59,219 --> 00:53:03,449
references directly is the

00:53:01,589 --> 00:53:06,390
recommendation to use reference wrapper

00:53:03,449 --> 00:53:08,630
for when you need references and the

00:53:06,390 --> 00:53:11,789
answer is yeah but it's not good enough

00:53:08,630 --> 00:53:16,349
at least in my opinion but the answer is

00:53:11,789 --> 00:53:17,999
consistent throughout the library right

00:53:16,349 --> 00:53:20,429
so this is one of the questions that I

00:53:17,999 --> 00:53:23,819
had when we first considered references

00:53:20,429 --> 00:53:26,369
in optional optional invariants why is

00:53:23,819 --> 00:53:28,049
it good enough for us to say well if you

00:53:26,369 --> 00:53:30,059
have a vector and you want the

00:53:28,049 --> 00:53:32,130
references in there and use reference

00:53:30,059 --> 00:53:34,109
wrapper but for optional invariant it's

00:53:32,130 --> 00:53:37,680
not enough right so I think it should

00:53:34,109 --> 00:53:39,089
still be consistent but the part

00:53:37,680 --> 00:53:41,250
the part where I say reference rapper is

00:53:39,089 --> 00:53:43,290
not good enough is that if you for

00:53:41,250 --> 00:53:45,780
example have a function a function

00:53:43,290 --> 00:53:48,809
parameter and you want to say optional

00:53:45,780 --> 00:53:50,280
reference wrapper int right because

00:53:48,809 --> 00:53:52,500
reference wrapper deletes the R value

00:53:50,280 --> 00:53:55,920
reference constructor I can't actually

00:53:52,500 --> 00:53:59,660
pass temporary ends to that right this

00:53:55,920 --> 00:53:59,660
is not what you expect from a regular

00:53:59,839 --> 00:54:06,089
constant well cost t ref signature you

00:54:04,680 --> 00:54:09,839
should be able to pass our value our

00:54:06,089 --> 00:54:12,359
values to that as well so I think yes

00:54:09,839 --> 00:54:14,369
that's the recommendation but I don't

00:54:12,359 --> 00:54:17,970
think it's sufficient all right examine

00:54:14,369 --> 00:54:20,040
sir you question yeah okay then

00:54:17,970 --> 00:54:21,770
hey Michael hi this might be an

00:54:20,040 --> 00:54:24,780
implementation question but is there any

00:54:21,770 --> 00:54:29,160
size overhead of an optional t over at e

00:54:24,780 --> 00:54:31,200
ne ne sais overhead any size overhead to

00:54:29,160 --> 00:54:34,200
these other penalty how much bigger than

00:54:31,200 --> 00:54:37,290
the t is an optional t so from the

00:54:34,200 --> 00:54:39,809
implementations that I'm so sorry the

00:54:37,290 --> 00:54:41,960
question is how much size overhead is

00:54:39,809 --> 00:54:44,280
there for an optional T compared to a T

00:54:41,960 --> 00:54:47,400
from the implementations I've seen it's

00:54:44,280 --> 00:54:49,530
generally just a bull which with

00:54:47,400 --> 00:54:53,760
alignment might be a big bigger than

00:54:49,530 --> 00:54:58,010
just a bite so yeah there is size

00:54:53,760 --> 00:55:01,740
overhead and there is some ideas to

00:54:58,010 --> 00:55:03,839
figure out how to steal one of these

00:55:01,740 --> 00:55:05,490
values so that we don't get that size

00:55:03,839 --> 00:55:09,270
overhead but still provide optional

00:55:05,490 --> 00:55:11,339
optional like API but yeah optional as

00:55:09,270 --> 00:55:14,369
it stands today it does have a typically

00:55:11,339 --> 00:55:15,869
just a bool overhead it was pushing that

00:55:14,369 --> 00:55:18,869
the magic value problem is now the

00:55:15,869 --> 00:55:20,520
implementers problem is that essentially

00:55:18,869 --> 00:55:22,530
except well except the user has to tell

00:55:20,520 --> 00:55:25,920
us which magic value they want they want

00:55:22,530 --> 00:55:28,530
us to use right so because we can't just

00:55:25,920 --> 00:55:29,910
yes it might be a valid value for them

00:55:28,530 --> 00:55:31,980
so they have to tell us which one to use

00:55:29,910 --> 00:55:37,170
but aside from that I think the API

00:55:31,980 --> 00:55:42,119
could stay similar yeah I don't hi

00:55:37,170 --> 00:55:45,299
Michael hi I just wanted to say as to

00:55:42,119 --> 00:55:47,730
like the optional ref thing yep y'all

00:55:45,299 --> 00:55:50,130
should come to my talk on Thursday cuz I

00:55:47,730 --> 00:55:51,599
will talk about that okay cool so

00:55:50,130 --> 00:55:54,959
there's a talk

00:55:51,599 --> 00:55:56,190
on Thursday what's your name so there's

00:55:54,959 --> 00:55:58,589
a talk on Thursday they call that I

00:55:56,190 --> 00:56:00,660
mentioned yeah so yeah she'll be talking

00:55:58,589 --> 00:56:02,160
about optional object locks times and

00:56:00,660 --> 00:56:15,809
stuff like that and optional references

00:56:02,160 --> 00:56:17,400
as well yeah cool why it makes sense why

00:56:15,809 --> 00:56:22,589
the suppose committee should support it

00:56:17,400 --> 00:56:24,029
and what was the last part how you have

00:56:22,589 --> 00:56:25,469
to think about references in order to

00:56:24,029 --> 00:56:30,959
support it okay

00:56:25,469 --> 00:56:33,299
see you Thursday hello hi my question is

00:56:30,959 --> 00:56:38,640
you mentioned there is an invalid state

00:56:33,299 --> 00:56:40,469
- the invalid state the empty state so

00:56:38,640 --> 00:56:43,499
to say although very enter or optional

00:56:40,469 --> 00:56:45,049
the variant very okay yeah the empty

00:56:43,499 --> 00:56:47,969
state or the value of our session state

00:56:45,049 --> 00:56:49,650
excuse me the empty state or the

00:56:47,969 --> 00:56:52,579
valueless by exception state yes the

00:56:49,650 --> 00:56:55,680
valueless okay yeah what happens if you

00:56:52,579 --> 00:56:57,539
visit try to visit it parts in that

00:56:55,680 --> 00:56:59,609
state yeah so if you try to visit a

00:56:57,539 --> 00:57:02,729
values by exception state it will throw

00:56:59,609 --> 00:57:05,789
a bad variant access exception okay so

00:57:02,729 --> 00:57:08,400
it's another X you have exception to

00:57:05,789 --> 00:57:10,019
begin with and then if you try to visit

00:57:08,400 --> 00:57:11,549
it right so yeah so you have an

00:57:10,019 --> 00:57:13,199
exception so you had an exception that

00:57:11,549 --> 00:57:15,420
there was thrown you got into the value

00:57:13,199 --> 00:57:17,880
of so excited state and then we escaped

00:57:15,420 --> 00:57:20,640
the catch clause or maybe within the

00:57:17,880 --> 00:57:22,289
catch clause we try to visit it if it's

00:57:20,640 --> 00:57:25,380
a valley and and then it'll throw

00:57:22,289 --> 00:57:30,029
another exception out of that okay thank

00:57:25,380 --> 00:57:32,660
you yeah hello I what is the state if I

00:57:30,029 --> 00:57:35,160
that regarding the double buffering

00:57:32,660 --> 00:57:37,199
problem for optional do we have the same

00:57:35,160 --> 00:57:40,469
problem there or what happens if I

00:57:37,199 --> 00:57:43,170
assign sorry value and everybody throw

00:57:40,469 --> 00:57:46,920
an exception when we assign the new

00:57:43,170 --> 00:57:47,999
value sorry double buffering for

00:57:46,920 --> 00:57:50,789
optional the user

00:57:47,999 --> 00:57:54,509
yeah so I mean what what's happening if

00:57:50,789 --> 00:57:57,119
if my optional I assign a value and and

00:57:54,509 --> 00:58:00,359
this assignment throws an exception oh

00:57:57,119 --> 00:58:01,559
oh I see I see yeah so yeah so this is

00:58:00,359 --> 00:58:02,150
actually this was actually part of my

00:58:01,559 --> 00:58:03,890
abstract

00:58:02,150 --> 00:58:06,170
I didn't actually talk cover in the talk

00:58:03,890 --> 00:58:09,799
the subtle difference between optional T

00:58:06,170 --> 00:58:14,720
and variant null up T well various null

00:58:09,799 --> 00:58:18,380
opt and T if the optional is in the T

00:58:14,720 --> 00:58:20,210
state and we try to initial assign into

00:58:18,380 --> 00:58:22,700
it we don't have this problem in

00:58:20,210 --> 00:58:26,119
optional because our our alternatives

00:58:22,700 --> 00:58:27,859
are only T and not T so whereas a

00:58:26,119 --> 00:58:30,319
variant would actually go into an empty

00:58:27,859 --> 00:58:33,140
state if we were storing a T and we try

00:58:30,319 --> 00:58:35,119
to assign a empty state and we throw

00:58:33,140 --> 00:58:36,650
we're going to an empty values by

00:58:35,119 --> 00:58:43,789
exception state an optional would

00:58:36,650 --> 00:58:45,890
actually stay in the T State yeah

00:58:43,789 --> 00:58:47,690
Michael okay so since values by

00:58:45,890 --> 00:58:49,339
exception is clearly a state that's

00:58:47,690 --> 00:58:52,869
known to the object is there a reason

00:58:49,339 --> 00:58:55,760
that a type like mono state type but a

00:58:52,869 --> 00:58:58,369
value list by exception type wasn't just

00:58:55,760 --> 00:59:01,309
decided to be held by the variant and

00:58:58,369 --> 00:59:02,480
used but I'm sure there was reasoning

00:59:01,309 --> 00:59:04,549
behind that do you know what the reason

00:59:02,480 --> 00:59:07,460
he was like why not construct the

00:59:04,549 --> 00:59:12,829
variant on failure with some type that

00:59:07,460 --> 00:59:14,569
represents a valueless type right so the

00:59:12,829 --> 00:59:17,089
question is why doesn't the Barrett

00:59:14,569 --> 00:59:19,760
inherently have a value spike values by

00:59:17,089 --> 00:59:22,190
value list by exception state and I

00:59:19,760 --> 00:59:24,890
think what happens if you do that is

00:59:22,190 --> 00:59:30,710
that a variant implicitly has an empty

00:59:24,890 --> 00:59:32,690
state correct right and so it becomes a

00:59:30,710 --> 00:59:35,270
valid state of the variant and it's

00:59:32,690 --> 00:59:36,559
embedded into the variant now and yeah

00:59:35,270 --> 00:59:39,140
it's a it's a type that you have to

00:59:36,559 --> 00:59:40,339
cover when you visit it for example we

00:59:39,140 --> 00:59:42,710
have to cover the exception when you

00:59:40,339 --> 00:59:44,480
visit you have to cover an exception

00:59:42,710 --> 00:59:48,920
when you visit you have to cover an

00:59:44,480 --> 00:59:50,480
exception what you have to know you

00:59:48,920 --> 00:59:52,279
can't desecrate you can't write an

00:59:50,480 --> 00:59:55,910
overload that takes the exception all

00:59:52,279 --> 00:59:58,099
right that's my point actually I think I

00:59:55,910 --> 01:00:00,170
think I'm out of time and so we can talk

00:59:58,099 --> 01:00:02,779
offline okay that's okay

01:00:00,170 --> 01:00:03,580
yes all right great okay cool thanks

01:00:02,779 --> 01:00:07,929
everyone for coming

01:00:03,580 --> 01:00:07,929

YouTube URL: https://www.youtube.com/watch?v=LmiDF2YheAM


