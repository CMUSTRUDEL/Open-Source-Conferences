Title: CppCon 2017: Titus Winters “C++ as a "Live at Head" Language”
Publication date: 2017-09-28
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Engineering is programming integrated over time. That is to say, as much as it can be difficult to get your code to build and run correctly, it is manifestly harder to keep it working in the face of changing assumptions and requirements. This is true no matter the scale, from a small program to a shared library. Only two solutions have been shown to be theoretically sound: never change or provide no compatibility guarantees. What if there were a third option? What if we took the question of maintenance out of the realm of theory and moved it to practice? This talk discusses the approach we've used at Google and how that intersects with other languages, package management, API and ABI compatibility, and a host of other software engineering practices. The particulars of C++ as a language and an ecosystem make it well positioned for a different approach: Live at Head.
— 
Titus Winters: Google, C++ Codebase Cultivator, NYC

Titus Winters has spent the past 6 years working on Google's core C++ libraries. He's particularly interested in issues of large scale software engineer and codebase maintenance: how do we keep a codebase of over 100M lines of code consistent and flexible for the next decade? Along the way he has helped Google teams pioneer techniques to perform automated code transformations on a massive scale, and helps maintain the Google C++ Style Guide.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,850
good morning everyone really

00:00:03,360 --> 00:00:10,349
oh come on call you you have to a little

00:00:05,850 --> 00:00:12,990
better good morning everyone okay so I

00:00:10,349 --> 00:00:14,370
am super excited to be up here number

00:00:12,990 --> 00:00:17,369
one reason why I'm super sad to be up

00:00:14,370 --> 00:00:19,350
here I do not have to present up here

00:00:17,369 --> 00:00:21,240
and that's actually the real reason I'm

00:00:19,350 --> 00:00:23,250
super excited be up here is because I'm

00:00:21,240 --> 00:00:26,880
really excited to introduce your next

00:00:23,250 --> 00:00:28,439
speaker titus winters and I have a small

00:00:26,880 --> 00:00:31,590
story to tell to give you an idea of how

00:00:28,439 --> 00:00:33,750
I got to know titus professionally you

00:00:31,590 --> 00:00:36,510
see you know my team and I like we built

00:00:33,750 --> 00:00:38,460
a bunch of C++ tools amazing C++ tools

00:00:36,510 --> 00:00:41,790
miraculous we were sure they were gonna

00:00:38,460 --> 00:00:44,579
change the landscape of C++ they

00:00:41,790 --> 00:00:46,649
couldn't be beat it was wonderful but we

00:00:44,579 --> 00:00:47,670
made this like critical mistake we

00:00:46,649 --> 00:00:51,180
forgot something

00:00:47,670 --> 00:00:53,730
tools do not have impact I know

00:00:51,180 --> 00:00:55,350
everyone's like wait what tools don't

00:00:53,730 --> 00:00:58,920
have impact they don't they really don't

00:00:55,350 --> 00:01:02,100
the tools can't change the world people

00:00:58,920 --> 00:01:05,460
use tools to have impact and to change

00:01:02,100 --> 00:01:07,860
the world and Titus and his team used

00:01:05,460 --> 00:01:11,369
our tools to change the world of C++ at

00:01:07,860 --> 00:01:13,350
Google and he turned to our C++ code

00:01:11,369 --> 00:01:14,580
base from something that was falling

00:01:13,350 --> 00:01:15,810
down around us and that we didn't know

00:01:14,580 --> 00:01:18,060
what to do with into something

00:01:15,810 --> 00:01:19,790
sustainable and maintainable for years

00:01:18,060 --> 00:01:22,680
and years to come for decades to come

00:01:19,790 --> 00:01:25,380
he turned our developer ecosystem and

00:01:22,680 --> 00:01:28,950
our developers from some kind of den of

00:01:25,380 --> 00:01:31,590
confusion and frustration and inks into

00:01:28,950 --> 00:01:34,079
actually like a productive and happy and

00:01:31,590 --> 00:01:37,020
and empowered and informed community

00:01:34,079 --> 00:01:38,400
right and and that's why I'm really

00:01:37,020 --> 00:01:40,439
excited to be up here and introducing

00:01:38,400 --> 00:01:43,140
him however I'm supposed to be up here

00:01:40,439 --> 00:01:46,409
telling you why you should be excited to

00:01:43,140 --> 00:01:47,759
listen to Titus and I can't do that so

00:01:46,409 --> 00:01:51,750
instead I'm gonna ask you all a question

00:01:47,759 --> 00:01:53,250
why are you here no I'm dead serious why

00:01:51,750 --> 00:01:54,149
are you here and you should be asking

00:01:53,250 --> 00:01:56,939
yourself every day

00:01:54,149 --> 00:01:57,719
everything you do why am I here and why

00:01:56,939 --> 00:02:00,119
am I doing this

00:01:57,719 --> 00:02:01,409
I suspect a bunch of people here how

00:02:00,119 --> 00:02:04,040
many folks here are here to learn

00:02:01,409 --> 00:02:07,920
something in some way or another right

00:02:04,040 --> 00:02:10,990
right to grow to improve right

00:02:07,920 --> 00:02:13,360
incrementally year-over-year I hope

00:02:10,990 --> 00:02:15,850
right in conversations in the hallways

00:02:13,360 --> 00:02:20,560
with new ideas and revisiting old ideas

00:02:15,850 --> 00:02:23,080
listening to great talks but to learn we

00:02:20,560 --> 00:02:24,870
need a teacher and garner reminded us

00:02:23,080 --> 00:02:28,570
yesterday of the importance of teachers

00:02:24,870 --> 00:02:30,340
and so it's my pleasure to introduce the

00:02:28,570 --> 00:02:34,840
person who taught Google to write better

00:02:30,340 --> 00:02:35,860
C++ and to write C++ better the finest

00:02:34,840 --> 00:02:38,140
teacher that I've had the pleasure of

00:02:35,860 --> 00:02:51,070
working with it Google dr. Titus winners

00:02:38,140 --> 00:02:54,160
to teach us about living it head all

00:02:51,070 --> 00:02:57,000
right so C++ as I live at head language

00:02:54,160 --> 00:03:01,320
we certainly know some of those words

00:02:57,000 --> 00:03:04,690
this is a deep and esoteric in some

00:03:01,320 --> 00:03:06,940
moments sort of topic but in order to

00:03:04,690 --> 00:03:08,980
get into that we need to sort of set the

00:03:06,940 --> 00:03:12,210
stage when you to motivate it we need to

00:03:08,980 --> 00:03:14,920
start with the story and getting here

00:03:12,210 --> 00:03:16,150
required moving through Google and

00:03:14,920 --> 00:03:18,730
working with the Google codebase and

00:03:16,150 --> 00:03:22,080
much of this story is sort of a history

00:03:18,730 --> 00:03:24,760
of Google's C++ code and portability

00:03:22,080 --> 00:03:27,220
historically Google has had pretty

00:03:24,760 --> 00:03:28,660
limited portability requirements for

00:03:27,220 --> 00:03:30,640
many years we controlled our tool chain

00:03:28,660 --> 00:03:32,860
and production environment handler

00:03:30,640 --> 00:03:35,500
controlled it very well there were some

00:03:32,860 --> 00:03:37,900
projects that had some projects had

00:03:35,500 --> 00:03:40,060
unusual portability requirements things

00:03:37,900 --> 00:03:43,510
like building Google Earth for Windows

00:03:40,060 --> 00:03:45,250
but it was an extreme minority and our

00:03:43,510 --> 00:03:47,860
focus on it was sort of largely an

00:03:45,250 --> 00:03:50,110
afterthought such an overwhelming

00:03:47,860 --> 00:03:52,360
majority of our code had completely

00:03:50,110 --> 00:03:54,130
controlled constraints that it just

00:03:52,360 --> 00:03:56,320
wasn't worth focusing on other things

00:03:54,130 --> 00:03:57,760
and you can sort of see the sinner

00:03:56,320 --> 00:04:01,360
interactions with some of our open

00:03:57,760 --> 00:04:03,190
source projects early on we built cold

00:04:01,360 --> 00:04:05,170
things and we wanted to share them they

00:04:03,190 --> 00:04:06,670
just put out things like G flags and

00:04:05,170 --> 00:04:09,550
logging and Google tests and all of

00:04:06,670 --> 00:04:11,650
these things but then as our control

00:04:09,550 --> 00:04:12,940
over our build and production

00:04:11,650 --> 00:04:15,580
environment got better and better it

00:04:12,940 --> 00:04:18,160
sort of stopped making organizational

00:04:15,580 --> 00:04:20,560
sense for us to spend a ton of effort

00:04:18,160 --> 00:04:23,530
providing those libraries for platforms

00:04:20,560 --> 00:04:24,880
that we never touched it was very

00:04:23,530 --> 00:04:27,190
outside of our needs

00:04:24,880 --> 00:04:31,720
so our interactions over time over a

00:04:27,190 --> 00:04:34,540
decade sort of dwindled and that started

00:04:31,720 --> 00:04:38,500
changing on the upswing a little while

00:04:34,540 --> 00:04:41,530
back mobile shockingly has different

00:04:38,500 --> 00:04:43,750
needs than production our open source

00:04:41,530 --> 00:04:46,390
projects that support cloud have

00:04:43,750 --> 00:04:48,040
different needs still and we sort of

00:04:46,390 --> 00:04:50,560
managed to put blinders on and muddle

00:04:48,040 --> 00:04:52,480
through regardless for a while but

00:04:50,560 --> 00:04:54,250
eventually it did become clear

00:04:52,480 --> 00:04:56,770
throughout the organization that we

00:04:54,250 --> 00:04:59,350
needed a different approach the era of

00:04:56,770 --> 00:05:01,480
Google's codebase doesn't need to be

00:04:59,350 --> 00:05:04,780
like everyone else had come to a close

00:05:01,480 --> 00:05:09,130
and it took us it took us a while but we

00:05:04,780 --> 00:05:12,340
did realize that on the other hand that

00:05:09,130 --> 00:05:14,500
era gave us amazing experiences and

00:05:12,340 --> 00:05:16,740
powers things that we've spoken about

00:05:14,500 --> 00:05:19,360
previously talks that I've given

00:05:16,740 --> 00:05:23,050
colleagues from former teams hyerim

00:05:19,360 --> 00:05:24,910
right while we only had a single

00:05:23,050 --> 00:05:27,370
platform that we cared about it was

00:05:24,910 --> 00:05:30,220
easier to do things like write tests and

00:05:27,370 --> 00:05:31,720
impose rules like our Beyonce rule if

00:05:30,220 --> 00:05:35,170
you liked it you should have put a test

00:05:31,720 --> 00:05:39,340
on it this is the type of rule that

00:05:35,170 --> 00:05:43,870
allows janitors and tool makers and

00:05:39,340 --> 00:05:46,270
compiler team to make changes to the

00:05:43,870 --> 00:05:50,250
infrastructure that literally everything

00:05:46,270 --> 00:05:53,530
in our code base uses with confidence

00:05:50,250 --> 00:05:56,740
right if your team actually wanted your

00:05:53,530 --> 00:06:00,940
code to not break you needed a test said

00:05:56,740 --> 00:06:05,230
for us to validate against this

00:06:00,940 --> 00:06:08,710
monoculture made things possible now we

00:06:05,230 --> 00:06:11,260
make changes at scale millions of edits

00:06:08,710 --> 00:06:13,420
are not just possible but actually

00:06:11,260 --> 00:06:15,550
pretty straightforward

00:06:13,420 --> 00:06:17,110
my team next quarter will almost

00:06:15,550 --> 00:06:20,080
certainly make a million edits to our

00:06:17,110 --> 00:06:22,870
code base I be surprised if we doesn't

00:06:20,080 --> 00:06:25,060
get to that number we've evolved to the

00:06:22,870 --> 00:06:25,840
place where anything that needs to be

00:06:25,060 --> 00:06:29,710
changed

00:06:25,840 --> 00:06:33,850
can be changed we are sustainable that

00:06:29,710 --> 00:06:35,770
is very powerful so when a couple years

00:06:33,850 --> 00:06:37,180
back when our leaders started taking

00:06:35,770 --> 00:06:38,230
other platforms and code portability

00:06:37,180 --> 00:06:41,380
seriously

00:06:38,230 --> 00:06:43,240
I really wanted to ensure that we didn't

00:06:41,380 --> 00:06:45,790
lose that property that sustainability

00:06:43,240 --> 00:06:48,130
when they started talking about funding

00:06:45,790 --> 00:06:49,420
efforts to improve code sharing I made

00:06:48,130 --> 00:06:53,050
sure to get involved in those directions

00:06:49,420 --> 00:06:55,810
early I shared what I knew and what I

00:06:53,050 --> 00:06:58,150
wanted to ensure and as a result I got

00:06:55,810 --> 00:07:00,130
tapped sort of broadly to make code

00:06:58,150 --> 00:07:02,800
sharing between our code base and the

00:07:00,130 --> 00:07:06,810
rest of the world more feasible this

00:07:02,800 --> 00:07:09,610
talk is really about two things one

00:07:06,810 --> 00:07:11,860
Google is open sourcing a bunch of C++

00:07:09,610 --> 00:07:13,510
common libraries these are the bits and

00:07:11,860 --> 00:07:17,800
pieces that underpin literally

00:07:13,510 --> 00:07:20,290
everything we do and I want to do this

00:07:17,800 --> 00:07:23,110
in a way that doesn't impact our ability

00:07:20,290 --> 00:07:26,560
to make changes but that is also good

00:07:23,110 --> 00:07:29,380
for users and that is a difficult

00:07:26,560 --> 00:07:32,230
balance there's not a lot of great

00:07:29,380 --> 00:07:33,130
examples for how to pull that off yet so

00:07:32,230 --> 00:07:35,770
this is what I'm going to try to

00:07:33,130 --> 00:07:37,210
motivate the discussions that have

00:07:35,770 --> 00:07:39,070
happened comparing our internal

00:07:37,210 --> 00:07:41,380
development strategy and how the rest of

00:07:39,070 --> 00:07:43,540
the world works have been illuminating

00:07:41,380 --> 00:07:45,790
to really explain things and to make

00:07:43,540 --> 00:07:48,130
this worthy of a plenary talk this is a

00:07:45,790 --> 00:07:50,230
big stage and a big audience I want to

00:07:48,130 --> 00:07:53,530
step way back and look at some sort of

00:07:50,230 --> 00:07:55,420
core software engineering practices at

00:07:53,530 --> 00:07:56,680
first software engineering is these are

00:07:55,420 --> 00:07:59,230
the things that we do when we work on a

00:07:56,680 --> 00:08:00,610
project why we do it I want to be a

00:07:59,230 --> 00:08:02,350
little bit like the kid that asked why

00:08:00,610 --> 00:08:05,470
over and over to get to some more

00:08:02,350 --> 00:08:07,720
abstract stuff get us to take a look for

00:08:05,470 --> 00:08:09,940
a while at a sort of basic software

00:08:07,720 --> 00:08:11,860
engineering practices or when I'm being

00:08:09,940 --> 00:08:15,190
snarky software engineering orthodoxy

00:08:11,860 --> 00:08:17,590
and get you to evaluate why you do the

00:08:15,190 --> 00:08:19,390
things that you are doing but first we

00:08:17,590 --> 00:08:20,830
can't really look at those practices of

00:08:19,390 --> 00:08:22,990
software engineering without some

00:08:20,830 --> 00:08:25,330
working definition of what is software

00:08:22,990 --> 00:08:27,220
engineering we all know what programming

00:08:25,330 --> 00:08:30,550
is what is the difference between these

00:08:27,220 --> 00:08:35,620
two things why do we have two words for

00:08:30,550 --> 00:08:38,669
these concepts software engineering to

00:08:35,620 --> 00:08:42,220
me is programming integrated over time

00:08:38,669 --> 00:08:44,620
I'll put this another way a programming

00:08:42,220 --> 00:08:47,920
task is oh hey I got my thing to work

00:08:44,620 --> 00:08:50,830
and congratulations programming is hard

00:08:47,920 --> 00:08:51,970
and a lot of the time the right answer

00:08:50,830 --> 00:08:54,399
to a problem

00:08:51,970 --> 00:08:56,319
I'm going to go write a program solve

00:08:54,399 --> 00:08:57,129
that problem and be done all right

00:08:56,319 --> 00:08:59,759
that's great

00:08:57,129 --> 00:09:02,439
no no judgment right totally fine

00:08:59,759 --> 00:09:04,750
engineering on the other hand is what

00:09:02,439 --> 00:09:07,839
happens when things need to live for

00:09:04,750 --> 00:09:10,629
longer and the influence of time starts

00:09:07,839 --> 00:09:13,180
creeping in the library that you used

00:09:10,629 --> 00:09:14,620
has a new version the operating system

00:09:13,180 --> 00:09:16,899
you developed for has been deprecated

00:09:14,620 --> 00:09:19,240
the language you wrote in has been

00:09:16,899 --> 00:09:20,709
revised and you need to update the

00:09:19,240 --> 00:09:23,139
requirements have changed and you need

00:09:20,709 --> 00:09:24,610
to add new features other developers are

00:09:23,139 --> 00:09:26,230
working on it you're moving to a new

00:09:24,610 --> 00:09:31,649
team you're moving to a new computer

00:09:26,230 --> 00:09:35,439
your hard drive died time happens things

00:09:31,649 --> 00:09:38,370
change how you handle that and how you

00:09:35,439 --> 00:09:41,829
keep your programming working is

00:09:38,370 --> 00:09:44,379
engineering it may bleed into the

00:09:41,829 --> 00:09:46,089
programming itself as you plan for a

00:09:44,379 --> 00:09:48,819
change within the structure of the code

00:09:46,089 --> 00:09:51,430
or it may be entirely layered on top

00:09:48,819 --> 00:09:53,230
when you're quick one-off hack becomes

00:09:51,430 --> 00:09:59,050
enshrined as a critical feature of your

00:09:53,230 --> 00:10:00,809
team's toolset build tools dan the first

00:09:59,050 --> 00:10:03,100
time I can remember having this thought

00:10:00,809 --> 00:10:04,839
programming is engine engineering as

00:10:03,100 --> 00:10:07,750
programming integrated over time it's

00:10:04,839 --> 00:10:10,209
still relevant this is optional vs.

00:10:07,750 --> 00:10:11,680
required in protobufs people at the

00:10:10,209 --> 00:10:14,079
company for longer than I am smarter

00:10:11,680 --> 00:10:14,879
than I started saying required fields

00:10:14,079 --> 00:10:18,639
are harmful

00:10:14,879 --> 00:10:20,559
let's ask why protobuf if you remember

00:10:18,639 --> 00:10:22,509
is the message format sort of like JSON

00:10:20,559 --> 00:10:24,790
that we at Google build all of our RPC

00:10:22,509 --> 00:10:26,860
services out of in the early days you

00:10:24,790 --> 00:10:28,540
define a message maybe like this the

00:10:26,860 --> 00:10:32,110
name of this type is request it has a

00:10:28,540 --> 00:10:34,569
single field query ID that field is

00:10:32,110 --> 00:10:36,129
required it's a 64-bit integer the name

00:10:34,569 --> 00:10:38,110
of the field isn't present in its wire

00:10:36,129 --> 00:10:42,279
encoding just the ID number of the field

00:10:38,110 --> 00:10:45,339
17 if a process is sent a request that

00:10:42,279 --> 00:10:49,300
doesn't have a 64-bit integer in ID 17

00:10:45,339 --> 00:10:51,430
it will fail to parse the request just

00:10:49,300 --> 00:10:54,009
dies before it's even made it up the

00:10:51,430 --> 00:10:55,860
stack to the RPC level and logically

00:10:54,009 --> 00:10:57,670
that makes sense you can't process

00:10:55,860 --> 00:10:59,709
without the request

00:10:57,670 --> 00:11:01,720
well you can't process the request

00:10:59,709 --> 00:11:03,639
without this ID why would you think you

00:11:01,720 --> 00:11:05,230
could seems perfectly reasonable to make

00:11:03,639 --> 00:11:08,930
this required

00:11:05,230 --> 00:11:10,160
but what happens when time creeps in we

00:11:08,930 --> 00:11:12,830
changed the service to have a different

00:11:10,160 --> 00:11:15,650
option but if you provide the raw string

00:11:12,830 --> 00:11:17,120
instead of a pre computed query ID in

00:11:15,650 --> 00:11:18,800
that case we aren't sure which one of

00:11:17,120 --> 00:11:20,390
these will be present and so maybe we

00:11:18,800 --> 00:11:22,400
make both the IDU and the string

00:11:20,390 --> 00:11:25,130
optional and we do the validation at a

00:11:22,400 --> 00:11:27,050
higher level what's that look like when

00:11:25,130 --> 00:11:30,460
we deploy we have some front end that is

00:11:27,050 --> 00:11:32,720
sending requests the backend server

00:11:30,460 --> 00:11:34,700
uncocking leaf we deploy the front end

00:11:32,720 --> 00:11:36,770
first we'll start sending maybe request

00:11:34,700 --> 00:11:39,710
ID or maybe sending request string and

00:11:36,770 --> 00:11:41,690
the server remember is somewhere back in

00:11:39,710 --> 00:11:43,910
time it is still running with the old

00:11:41,690 --> 00:11:45,860
definition all right in the server's

00:11:43,910 --> 00:11:49,730
view of things the ID is still required

00:11:45,860 --> 00:11:52,340
and so if the server is configured so

00:11:49,730 --> 00:11:54,110
that that garbage request is an

00:11:52,340 --> 00:11:57,110
assertion failure or just silently

00:11:54,110 --> 00:11:59,000
ignored things go sideways none of this

00:11:57,110 --> 00:12:01,010
is surprising all right we update the

00:11:59,000 --> 00:12:02,720
server first this is very in line with

00:12:01,010 --> 00:12:05,240
everything that everyone knows about

00:12:02,720 --> 00:12:06,890
writing protocols you need to be strict

00:12:05,240 --> 00:12:08,390
in what you emit and liberal in what you

00:12:06,890 --> 00:12:11,390
accept so clearly we have to update the

00:12:08,390 --> 00:12:14,000
backend first no shock make sure we're

00:12:11,390 --> 00:12:14,840
capable of accepting any definition but

00:12:14,000 --> 00:12:16,640
what about rollouts

00:12:14,840 --> 00:12:18,290
what if there are multiple servers but

00:12:16,640 --> 00:12:20,900
if we don't upgrade all the servers at

00:12:18,290 --> 00:12:22,780
once that does seem safest after all we

00:12:20,900 --> 00:12:24,740
know the previous version was working

00:12:22,780 --> 00:12:26,960
updating all the servers to the new

00:12:24,740 --> 00:12:28,370
version at once might be catastrophic so

00:12:26,960 --> 00:12:29,780
we do some of them and then the front

00:12:28,370 --> 00:12:30,860
end and if the front end doesn't know

00:12:29,780 --> 00:12:32,090
the difference between which ones

00:12:30,860 --> 00:12:33,520
support the new thing and which ones

00:12:32,090 --> 00:12:34,670
don't and we're back to the same problem

00:12:33,520 --> 00:12:36,410
all right

00:12:34,670 --> 00:12:38,740
this only gets worse when you start

00:12:36,410 --> 00:12:41,900
having complex networks of servers I

00:12:38,740 --> 00:12:43,460
could not possibly draw the graph of

00:12:41,900 --> 00:12:46,610
server interconnects in google

00:12:43,460 --> 00:12:48,530
production all right you do not want to

00:12:46,610 --> 00:12:50,390
get into a situation where every service

00:12:48,530 --> 00:12:51,980
in the fleet has to be restarted all at

00:12:50,390 --> 00:12:54,740
once in order to handle handle a

00:12:51,980 --> 00:12:57,110
protocol update and so we could of

00:12:54,740 --> 00:12:59,630
course fix this by adding version fields

00:12:57,110 --> 00:13:02,120
to every message definition but that in

00:12:59,630 --> 00:13:05,540
and of itself is still adding time to

00:13:02,120 --> 00:13:08,270
the protocol all of this complexity is

00:13:05,540 --> 00:13:10,910
fundamentally a different flavor then I

00:13:08,270 --> 00:13:13,970
got it working it is fundamentally a

00:13:10,910 --> 00:13:16,610
different flavor than programming it is

00:13:13,970 --> 00:13:19,139
completely unnecessary in some content

00:13:16,610 --> 00:13:20,970
if you know that your program our

00:13:19,139 --> 00:13:22,290
service is only needs to work for a

00:13:20,970 --> 00:13:24,240
limited time right I need to get it

00:13:22,290 --> 00:13:25,980
today I need it to last flew to the demo

00:13:24,240 --> 00:13:27,959
I need the next round of funding we

00:13:25,980 --> 00:13:30,029
don't need to plan for the future then

00:13:27,959 --> 00:13:30,600
you don't plan for the future that's

00:13:30,029 --> 00:13:33,930
fine

00:13:30,600 --> 00:13:35,939
right context matters but when you

00:13:33,930 --> 00:13:39,779
aren't certain when you have to be

00:13:35,939 --> 00:13:42,029
prepared and that preparedness is what I

00:13:39,779 --> 00:13:44,579
look at as software engineering it is

00:13:42,029 --> 00:13:46,589
the impact of time on a programming

00:13:44,579 --> 00:13:48,749
system and the point of this whole

00:13:46,589 --> 00:13:51,959
anecdote is that something that makes

00:13:48,749 --> 00:13:54,059
sense on the face of it required fields

00:13:51,959 --> 00:13:55,769
turns out to be a horrible idea when you

00:13:54,059 --> 00:13:58,259
start thinking about change over time

00:13:55,769 --> 00:14:01,379
and I would argue that there are many

00:13:58,259 --> 00:14:04,170
things that we do that make perfect

00:14:01,379 --> 00:14:05,970
sense in a limited domain in a

00:14:04,170 --> 00:14:07,319
programming domain but do not

00:14:05,970 --> 00:14:09,240
necessarily make sense when we are

00:14:07,319 --> 00:14:14,100
thinking about it as engineering and

00:14:09,240 --> 00:14:16,050
change over time at the core I think

00:14:14,100 --> 00:14:17,490
everything that we think of when we talk

00:14:16,050 --> 00:14:19,910
about software engineering tools and

00:14:17,490 --> 00:14:22,379
technology is about resilience to time

00:14:19,910 --> 00:14:24,660
version control is about being able to

00:14:22,379 --> 00:14:26,300
go back in time coordinate with your

00:14:24,660 --> 00:14:28,680
colleagues over time

00:14:26,300 --> 00:14:30,389
see I continuous integration is about

00:14:28,680 --> 00:14:32,759
making sure that recent changes haven't

00:14:30,389 --> 00:14:34,649
broken the system unit tests are very

00:14:32,759 --> 00:14:36,990
similar this is make sure the feature

00:14:34,649 --> 00:14:41,059
that you wrote hasn't been broken by the

00:14:36,990 --> 00:14:43,139
idiot down the hall or you in the future

00:14:41,059 --> 00:14:45,569
refactoring tools are how you update

00:14:43,139 --> 00:14:47,939
from an old wake to a new web design

00:14:45,569 --> 00:14:49,709
patterns give you some ability to plan

00:14:47,939 --> 00:14:51,649
for future changes without knowing

00:14:49,709 --> 00:14:53,579
exactly what those changes will be

00:14:51,649 --> 00:14:54,930
dependency management is how we deal

00:14:53,579 --> 00:14:57,660
with the fact that the libraries we

00:14:54,930 --> 00:14:58,949
depend upon may change and that last is

00:14:57,660 --> 00:15:00,959
really crucial in what I'm going to talk

00:14:58,949 --> 00:15:02,189
about for a while here let's talk about

00:15:00,959 --> 00:15:03,600
dependency management and the

00:15:02,189 --> 00:15:07,589
fundamental problem in dependency

00:15:03,600 --> 00:15:09,360
management diamon dependencies diamon

00:15:07,589 --> 00:15:11,189
dependencies are the bane of package

00:15:09,360 --> 00:15:13,019
management content management dependency

00:15:11,189 --> 00:15:15,509
management any sort of management and

00:15:13,019 --> 00:15:17,040
they arise commonly in cases where

00:15:15,509 --> 00:15:21,540
multiple libraries depend on a

00:15:17,040 --> 00:15:24,860
lower-level library here we have live a

00:15:21,540 --> 00:15:27,750
and live B they both depend on Lib util

00:15:24,860 --> 00:15:29,700
as soon as versions change there's now

00:15:27,750 --> 00:15:31,710
two green boxes for liberty

00:15:29,700 --> 00:15:35,070
if everyone in your infrastructure

00:15:31,710 --> 00:15:37,980
doesn't upgrade at the same time then we

00:15:35,070 --> 00:15:41,250
have version skew Lib B depends on V to

00:15:37,980 --> 00:15:43,560
live a depends on v1 this is even now

00:15:41,250 --> 00:15:46,230
still fine in theory until some

00:15:43,560 --> 00:15:47,700
additional package maybe yours chooses

00:15:46,230 --> 00:15:50,940
to depend on both of the mid-level

00:15:47,700 --> 00:15:54,050
libraries now we have a problem

00:15:50,940 --> 00:15:57,390
you are the pink box in some situations

00:15:54,050 --> 00:15:59,910
for some languages we can make this work

00:15:57,390 --> 00:16:03,000
by compiling in both versions of Lib

00:15:59,910 --> 00:16:04,230
util so long as there are not types from

00:16:03,000 --> 00:16:06,390
the beaut ill that passed through both

00:16:04,230 --> 00:16:08,760
of them into user code and so long as

00:16:06,390 --> 00:16:10,980
their it's not global initialization and

00:16:08,760 --> 00:16:12,900
live util and a little long host of

00:16:10,980 --> 00:16:14,760
other things but in general for many

00:16:12,900 --> 00:16:17,040
languages and for many situations this

00:16:14,760 --> 00:16:19,170
just results in failed builds or maybe

00:16:17,040 --> 00:16:22,050
in some cases worse failed runtime

00:16:19,170 --> 00:16:24,240
problems there is a standard mechanism

00:16:22,050 --> 00:16:26,790
that we use for identifying this problem

00:16:24,240 --> 00:16:28,380
and it is so ubiquitous it's even worked

00:16:26,790 --> 00:16:30,840
its way into this diagram when

00:16:28,380 --> 00:16:33,000
discussing two incompatible versions of

00:16:30,840 --> 00:16:35,580
Libya till my instinct is to describe

00:16:33,000 --> 00:16:39,450
these as versions one and version 2 not

00:16:35,580 --> 00:16:42,000
1 and 1.0 one not apple and orange not a

00:16:39,450 --> 00:16:44,700
and B clearly I describe these as one

00:16:42,000 --> 00:16:47,580
and two this is what was intuitive to

00:16:44,700 --> 00:16:49,380
you as well I'll guess we've come to

00:16:47,580 --> 00:16:50,990
take it for granted that version numbers

00:16:49,380 --> 00:16:53,940
are what identifies their release and

00:16:50,990 --> 00:16:56,130
changes in major version indicates some

00:16:53,940 --> 00:16:58,260
level of incompatibility you changed a

00:16:56,130 --> 00:17:00,000
thing this is what we call semantic

00:16:58,260 --> 00:17:02,510
versioning and it is the standard answer

00:17:00,000 --> 00:17:04,830
for versioning and dependency management

00:17:02,510 --> 00:17:06,740
semantic versioning just so that we're

00:17:04,830 --> 00:17:09,210
all on the same page generally gives us

00:17:06,740 --> 00:17:13,320
version numbers of the form X dot y dot

00:17:09,210 --> 00:17:15,030
Z 1 dot 3.17 for instance the smaller

00:17:13,320 --> 00:17:17,070
the the rightmost number is the patch

00:17:15,030 --> 00:17:20,100
number these are things that shouldn't

00:17:17,070 --> 00:17:23,340
affect anything just a bug fix the minor

00:17:20,100 --> 00:17:26,100
number the three is a minor additional

00:17:23,340 --> 00:17:28,110
release we've added some new api's

00:17:26,100 --> 00:17:30,150
things that weren't present in the old

00:17:28,110 --> 00:17:32,520
thing but nothing has changed no one

00:17:30,150 --> 00:17:34,830
will be broken and the major number bump

00:17:32,520 --> 00:17:38,070
is reserved for I made a change to an

00:17:34,830 --> 00:17:40,140
existing API your code won't build so

00:17:38,070 --> 00:17:41,809
when you express dependence on a

00:17:40,140 --> 00:17:44,239
particular version

00:17:41,809 --> 00:17:48,679
of one of your underlying libraries live

00:17:44,239 --> 00:17:52,820
util you say I depend on 1.3 or better

00:17:48,679 --> 00:17:56,450
and 1.3 or better means could be 1.4

00:17:52,820 --> 00:17:59,809
could be 1.5 can't be 2.0 because in

00:17:56,450 --> 00:18:04,159
that 1 to 2 switch you made a breaking

00:17:59,809 --> 00:18:05,419
change scare quotes implicit in the

00:18:04,159 --> 00:18:06,679
system is that you can tell the

00:18:05,419 --> 00:18:08,299
difference ahead of time between a

00:18:06,679 --> 00:18:11,299
change that breaks someone and a change

00:18:08,299 --> 00:18:13,399
that doesn't and it's actually sort of

00:18:11,299 --> 00:18:14,989
worse than this using an incompatible

00:18:13,399 --> 00:18:17,929
major version doesn't mean that things

00:18:14,989 --> 00:18:20,210
won't work it just means things might

00:18:17,929 --> 00:18:21,830
not work it is entirely possible that

00:18:20,210 --> 00:18:23,389
the major version got bumped because of

00:18:21,830 --> 00:18:26,089
API changes that you don't actually care

00:18:23,389 --> 00:18:28,249
about that is imagine that live a

00:18:26,089 --> 00:18:32,419
doesn't depend on everything in Lib util

00:18:28,249 --> 00:18:34,909
only one part of it changes unrelated to

00:18:32,419 --> 00:18:37,849
AP is in Lybia till may not affect live

00:18:34,909 --> 00:18:40,369
a in any meaningful way and yet an

00:18:37,849 --> 00:18:43,700
assembler sense we've revved lib util to

00:18:40,369 --> 00:18:47,839
v2 and a new major version because there

00:18:43,700 --> 00:18:50,299
was a incompatible API change so in some

00:18:47,839 --> 00:18:52,279
instances semver is over constraining

00:18:50,299 --> 00:18:53,779
which if you've ever had trouble

00:18:52,279 --> 00:18:56,570
installing something because of version

00:18:53,779 --> 00:18:58,969
incompatibilities is not a pleasant

00:18:56,570 --> 00:19:01,700
thought I think it has been a week since

00:18:58,969 --> 00:19:03,679
I had that annoyance and I would give

00:19:01,700 --> 00:19:06,049
you better than even odds that if we

00:19:03,679 --> 00:19:07,879
just made it shut up and turned off all

00:19:06,049 --> 00:19:12,049
of the version checking it would

00:19:07,879 --> 00:19:13,580
probably work very annoying but assuming

00:19:12,049 --> 00:19:15,229
that you can identify what breaks your

00:19:13,580 --> 00:19:17,989
users and assuming that you're ok with

00:19:15,229 --> 00:19:19,190
that slight over conservativism this

00:19:17,989 --> 00:19:20,960
does give us a standard way of

00:19:19,190 --> 00:19:21,940
identifying things that will work

00:19:20,960 --> 00:19:25,159
together

00:19:21,940 --> 00:19:27,529
note what semver doesn't say this is not

00:19:25,159 --> 00:19:30,769
providing any form of proof that your

00:19:27,529 --> 00:19:32,869
dependencies can work out it is just

00:19:30,769 --> 00:19:34,249
saying that if there is a set of

00:19:32,869 --> 00:19:37,039
versions for your dependencies that

00:19:34,249 --> 00:19:40,669
satisfies all stated constraints you can

00:19:37,039 --> 00:19:42,379
in theory find it and of course each

00:19:40,669 --> 00:19:45,169
version of all of your dependencies

00:19:42,379 --> 00:19:46,999
comes with its own requirements and it

00:19:45,169 --> 00:19:48,889
is especially too important to note that

00:19:46,999 --> 00:19:52,129
any dependency tree you see that fits on

00:19:48,889 --> 00:19:54,750
a slide is wildly simplified and the

00:19:52,129 --> 00:19:56,760
popular dependencies are very popular

00:19:54,750 --> 00:20:01,920
and that diamonds form at many levels

00:19:56,760 --> 00:20:04,920
and scales and as your dependency graph

00:20:01,920 --> 00:20:07,710
grows it grows quadratically that is how

00:20:04,920 --> 00:20:09,810
graphs grow only a linear faction of

00:20:07,710 --> 00:20:12,600
your dependency graph is under your

00:20:09,810 --> 00:20:14,340
control you are the pink box you get to

00:20:12,600 --> 00:20:16,950
pick the things that are directly

00:20:14,340 --> 00:20:18,810
dependent upon by you you do not

00:20:16,950 --> 00:20:20,550
necessarily have control over the

00:20:18,810 --> 00:20:25,470
dependencies of everything else in your

00:20:20,550 --> 00:20:27,720
graph do the math the chances it's ember

00:20:25,470 --> 00:20:28,950
and its potential slight over

00:20:27,720 --> 00:20:31,110
constraining leaves you with an

00:20:28,950 --> 00:20:34,020
unsatisfiable dependency tree grows

00:20:31,110 --> 00:20:35,670
quadratically we are doing better and

00:20:34,020 --> 00:20:38,310
better at in the open source world of

00:20:35,670 --> 00:20:43,010
making things shareable and we are

00:20:38,310 --> 00:20:45,630
heading to disaster why do we use semver

00:20:43,010 --> 00:20:48,570
it is a compromised position between

00:20:45,630 --> 00:20:51,420
nothing ever changes and there is no

00:20:48,570 --> 00:20:54,840
stability promise there is nothing about

00:20:51,420 --> 00:20:57,780
this that is necessary nor is it in any

00:20:54,840 --> 00:21:00,210
way sufficient as your dependency graph

00:20:57,780 --> 00:21:03,300
expands dependence on semver is

00:21:00,210 --> 00:21:05,820
equivalent to I sure hope that major

00:21:03,300 --> 00:21:07,830
version bumps in my graph happens

00:21:05,820 --> 00:21:12,200
efficiently and frequently that this all

00:21:07,830 --> 00:21:12,200
works out it's a hope and a prayer

00:21:13,850 --> 00:21:18,300
what's the difference between a patch

00:21:15,990 --> 00:21:21,120
release in a major version it gets worse

00:21:18,300 --> 00:21:22,980
that is what guarantee are you giving

00:21:21,120 --> 00:21:24,810
when you bump from one three seventeen

00:21:22,980 --> 00:21:30,000
to one three eighteen that you aren't

00:21:24,810 --> 00:21:32,190
giving when you go to 200 that is put in

00:21:30,000 --> 00:21:35,370
another way what constitutes a breaking

00:21:32,190 --> 00:21:37,470
change and because I've done quite a bit

00:21:35,370 --> 00:21:39,930
to change and update Google's codebase

00:21:37,470 --> 00:21:45,690
over the years I can answer this quite

00:21:39,930 --> 00:21:49,290
confidently almost everything breaking

00:21:45,690 --> 00:21:52,950
change this is not binary it is shades

00:21:49,290 --> 00:21:53,700
of grey almost certainly fine or boy we

00:21:52,950 --> 00:21:55,530
sure hope so

00:21:53,700 --> 00:21:57,480
adding whitespace are changing line

00:21:55,530 --> 00:22:00,300
numbers clearly this should be fine

00:21:57,480 --> 00:22:03,140
right in any language that has even the

00:22:00,300 --> 00:22:06,120
most primitive reflection properties C++

00:22:03,140 --> 00:22:07,530
say extract get me the current file name

00:22:06,120 --> 00:22:09,780
and line number in this

00:22:07,530 --> 00:22:11,130
while it is theoretically possible for

00:22:09,780 --> 00:22:13,470
production code to depend on those

00:22:11,130 --> 00:22:17,510
properties this is the stupidest

00:22:13,470 --> 00:22:17,510
factorial implementation of all time

00:22:18,830 --> 00:22:25,800
slide code is by its nature ridiculous

00:22:23,090 --> 00:22:28,830
but you can certainly imagine that

00:22:25,800 --> 00:22:31,260
spread over ten thousand lines of actual

00:22:28,830 --> 00:22:34,310
production code something that reduces

00:22:31,260 --> 00:22:36,510
to this could in theory exist and

00:22:34,310 --> 00:22:39,720
practically speaking if you saw my talk

00:22:36,510 --> 00:22:41,790
on tests a couple years ago because log

00:22:39,720 --> 00:22:43,890
statements tend to include file name and

00:22:41,790 --> 00:22:47,040
line number brittle and poorly designed

00:22:43,890 --> 00:22:49,980
tests regularly do depend on file name

00:22:47,040 --> 00:22:53,520
and line number we shouldn't care but we

00:22:49,980 --> 00:22:55,080
also should not pretend that this does

00:22:53,520 --> 00:22:58,110
not have the potential to break

00:22:55,080 --> 00:23:00,630
something on the more extreme end

00:22:58,110 --> 00:23:02,130
removing a public API this is clearly a

00:23:00,630 --> 00:23:03,720
breaking change everyone would agree

00:23:02,130 --> 00:23:05,490
with this this is the type of thing that

00:23:03,720 --> 00:23:07,850
everyone knows recognizes a break this

00:23:05,490 --> 00:23:10,350
is not contentious but at the same time

00:23:07,850 --> 00:23:12,420
if you've had an API that's better in

00:23:10,350 --> 00:23:15,660
every way for five years for ten years

00:23:12,420 --> 00:23:17,910
for twenty years do we really have to

00:23:15,660 --> 00:23:20,220
continue supporting the old thing what

00:23:17,910 --> 00:23:22,680
if you go talk to Chandler and you're

00:23:20,220 --> 00:23:24,750
like hey Chandler can we just have a

00:23:22,680 --> 00:23:27,900
tool that updates everyone from the old

00:23:24,750 --> 00:23:32,700
thing to the new thing just provably can

00:23:27,900 --> 00:23:35,160
we delete the old busted API then even

00:23:32,700 --> 00:23:39,200
the delete a thing that is clearly a

00:23:35,160 --> 00:23:42,510
breaking change isn't entirely

00:23:39,200 --> 00:23:44,520
impossible what about things in the

00:23:42,510 --> 00:23:47,700
middle how about adding an overload it's

00:23:44,520 --> 00:23:49,980
just a breaking change Oh in C++ this is

00:23:47,700 --> 00:23:52,260
a breaking change if someone is taking

00:23:49,980 --> 00:23:54,660
the address of your function any

00:23:52,260 --> 00:23:56,490
function pointers this is almost

00:23:54,660 --> 00:23:58,230
certainly going to be a break right you

00:23:56,490 --> 00:24:01,830
have changed the functions you've made

00:23:58,230 --> 00:24:03,810
it ambiguous which function you wanted

00:24:01,830 --> 00:24:07,590
out of that overload set build brick

00:24:03,810 --> 00:24:09,090
alright we'll hit more on this later so

00:24:07,590 --> 00:24:11,610
is that a breaking change adding an

00:24:09,090 --> 00:24:13,290
overload what about changing the number

00:24:11,610 --> 00:24:15,090
or alignment of members in an object

00:24:13,290 --> 00:24:18,420
someone could be depending on that

00:24:15,090 --> 00:24:20,100
obviously or runtime efficiency what

00:24:18,420 --> 00:24:21,389
about cases where runtime efficiency

00:24:20,100 --> 00:24:23,539
gets better for almost

00:24:21,389 --> 00:24:25,919
all callers but some of them regress

00:24:23,539 --> 00:24:29,009
coming up with a definition for breaking

00:24:25,919 --> 00:24:31,169
change is hard no matter what we do in a

00:24:29,009 --> 00:24:33,539
Hiram's law sense someone could be

00:24:31,169 --> 00:24:36,539
result relying on every observable and

00:24:33,539 --> 00:24:39,659
as the number of users of your API goes

00:24:36,539 --> 00:24:42,779
up the odds of someone relying on every

00:24:39,659 --> 00:24:45,839
observable behavior of your API goes to

00:24:42,779 --> 00:24:47,369
certainty I'm going to include a slide

00:24:45,839 --> 00:24:48,869
on this whenever possible until everyone

00:24:47,369 --> 00:24:50,009
else is quoting it as far as I'm

00:24:48,869 --> 00:24:51,450
concerned this is one of the great

00:24:50,009 --> 00:24:51,959
practical constraints in software

00:24:51,450 --> 00:24:54,239
engineering

00:24:51,959 --> 00:24:57,379
Hiram's law comm basically it's just

00:24:54,239 --> 00:25:04,649
that quote but we miss you Hiram and

00:24:57,379 --> 00:25:07,139
there is of course an xkcd for this here

00:25:04,649 --> 00:25:08,609
a clever user is relying on a bug in

00:25:07,139 --> 00:25:09,719
their keyboard drivers to configure

00:25:08,609 --> 00:25:13,320
their Emacs workflow and then

00:25:09,719 --> 00:25:15,509
complaining about the bug fix so

00:25:13,320 --> 00:25:17,309
semantic versioning this is the thing

00:25:15,509 --> 00:25:20,609
that we all use to avoid having

00:25:17,309 --> 00:25:21,929
dependency problems this is based on the

00:25:20,609 --> 00:25:23,639
idea that we can tell the difference

00:25:21,929 --> 00:25:25,679
between a change that breaks our users

00:25:23,639 --> 00:25:27,959
and one that doesn't even though Hiram's

00:25:25,679 --> 00:25:30,089
law tells us better or if we're being

00:25:27,959 --> 00:25:33,690
charitable it tells us about changes in

00:25:30,089 --> 00:25:38,070
API and assumes that non API changes

00:25:33,690 --> 00:25:39,769
don't matter semver identifies correctly

00:25:38,070 --> 00:25:42,419
when the versions that we have installed

00:25:39,769 --> 00:25:43,799
theoretically don't work together it is

00:25:42,419 --> 00:25:46,169
possible that in practice that they do

00:25:43,799 --> 00:25:48,889
if the API that caused the major version

00:25:46,169 --> 00:25:52,589
bump is unused or any host of other

00:25:48,889 --> 00:25:54,899
scenarios I could draw a comparison here

00:25:52,589 --> 00:25:58,169
to supporting C++ language versions as

00:25:54,899 --> 00:26:00,959
it turns out C++ 11 support was not a

00:25:58,169 --> 00:26:02,909
binary thing we might still disagree a

00:26:00,959 --> 00:26:05,429
little bit on whether any given compiler

00:26:02,909 --> 00:26:08,639
really implements it expressing your

00:26:05,429 --> 00:26:11,700
requirement as requires C++ 11 turns out

00:26:08,639 --> 00:26:13,499
to not be entirely useful collapsing

00:26:11,700 --> 00:26:14,899
things that are complicated down into a

00:26:13,499 --> 00:26:17,279
single dimension for support

00:26:14,899 --> 00:26:19,320
theoretically satisfying makes great

00:26:17,279 --> 00:26:22,259
graphs on whiteboards but it is not very

00:26:19,320 --> 00:26:24,779
useful practically the semver

00:26:22,259 --> 00:26:27,509
constraints do not promise solutions

00:26:24,779 --> 00:26:30,169
they merely promise if you are able to

00:26:27,509 --> 00:26:33,179
obey these constraints things will work

00:26:30,169 --> 00:26:34,250
the likelihood of over constraint or

00:26:33,179 --> 00:26:36,020
leads

00:26:34,250 --> 00:26:38,330
- unsolvable constraint problems and

00:26:36,020 --> 00:26:40,370
this grows quadratically it's the

00:26:38,330 --> 00:26:41,480
frequency of major number bumps goes up

00:26:40,370 --> 00:26:44,630
in your dependency graph you are

00:26:41,480 --> 00:26:46,040
increasingly likely to be stuck but when

00:26:44,630 --> 00:26:47,600
it works we don't have to worry about

00:26:46,040 --> 00:26:50,000
Diamond dependencies so that's great

00:26:47,600 --> 00:26:52,250
those are important because those are

00:26:50,000 --> 00:26:55,040
hard and let's look at really why these

00:26:52,250 --> 00:26:56,270
are hard not what we currently do to

00:26:55,040 --> 00:26:58,190
work around it

00:26:56,270 --> 00:27:00,290
Diamond dependency think about you as

00:26:58,190 --> 00:27:02,300
the pink graph here you are not an

00:27:00,290 --> 00:27:05,570
expert in the code that has to change

00:27:02,300 --> 00:27:07,190
Lib a the code that did change Lib util

00:27:05,570 --> 00:27:09,830
like why did they change this thing I

00:27:07,190 --> 00:27:11,570
don't know and whether or not any change

00:27:09,830 --> 00:27:15,320
that you happened to make to live a to

00:27:11,570 --> 00:27:18,560
fix this works it's a whole lot of no

00:27:15,320 --> 00:27:20,420
idea dog there are three things I've

00:27:18,560 --> 00:27:21,530
seen that make this work in theory that

00:27:20,420 --> 00:27:24,170
avoid the diamond dependency issue

00:27:21,530 --> 00:27:24,710
nothing ever changes over time good luck

00:27:24,170 --> 00:27:26,480
with that

00:27:24,710 --> 00:27:29,330
add a level of abstraction we're just

00:27:26,480 --> 00:27:33,110
gonna draw a bigger box that doesn't

00:27:29,330 --> 00:27:36,110
really scale or the group making the

00:27:33,110 --> 00:27:39,560
change needs to update everyone the mono

00:27:36,110 --> 00:27:44,840
repo approach or make it trivially easy

00:27:39,560 --> 00:27:47,210
to do the update even by a novice when

00:27:44,840 --> 00:27:49,370
you phrase it this way we have so

00:27:47,210 --> 00:27:50,540
completely solved this problem in the

00:27:49,370 --> 00:27:53,210
last five or ten years

00:27:50,540 --> 00:27:55,460
we just haven't stepped back after why

00:27:53,210 --> 00:27:59,030
look at why we do the things we do and

00:27:55,460 --> 00:27:59,990
consider the full impact let's look at

00:27:59,030 --> 00:28:01,790
some of the technical and conceptual

00:27:59,990 --> 00:28:03,440
changes in the last few years and come

00:28:01,790 --> 00:28:07,360
back to the idea of what would it take

00:28:03,440 --> 00:28:10,490
to make upgrades easy for a non-expert

00:28:07,360 --> 00:28:13,340
what happened recently unit tests are on

00:28:10,490 --> 00:28:15,530
the rise this is the search result for

00:28:13,340 --> 00:28:17,390
the google engrams book viewer this is

00:28:15,530 --> 00:28:19,940
the frequency of determine unit to test

00:28:17,390 --> 00:28:22,310
it in the google books data I really

00:28:19,940 --> 00:28:24,230
wish it went past 2007 because I'm 90%

00:28:22,310 --> 00:28:32,540
sure that that craft just keeps growing

00:28:24,230 --> 00:28:34,370
up unit tests right that would actually

00:28:32,540 --> 00:28:36,650
just cover how to verify the change

00:28:34,370 --> 00:28:40,070
right if Lib util or rather if Lib a

00:28:36,650 --> 00:28:43,130
just has a nice reasonable easy to run

00:28:40,070 --> 00:28:44,330
runs everywhere unit testing sweet right

00:28:43,130 --> 00:28:46,280
you could make whatever change you want

00:28:44,330 --> 00:28:48,020
to live util and see if it still work

00:28:46,280 --> 00:28:50,330
right because keep in mind

00:28:48,020 --> 00:28:52,280
the changes that we're talking about are

00:28:50,330 --> 00:28:54,620
not intended to be behavioral or

00:28:52,280 --> 00:28:57,050
semantic changes largely we're talking

00:28:54,620 --> 00:28:59,059
about fix up the api's so that the

00:28:57,050 --> 00:29:01,220
existing invariants are still holding

00:28:59,059 --> 00:29:02,690
right existing unit tests shouldn't have

00:29:01,220 --> 00:29:04,340
to be updated in general simmering

00:29:02,690 --> 00:29:06,230
they're good unit tests go see that

00:29:04,340 --> 00:29:08,780
other talk I mentioned that covers

00:29:06,230 --> 00:29:13,070
verify the change how about where and

00:29:08,780 --> 00:29:16,130
how to change as it turns out we've

00:29:13,070 --> 00:29:20,150
talked about this at this conference we

00:29:16,130 --> 00:29:23,570
have published papers on this we have a

00:29:20,150 --> 00:29:25,700
tool that is specifically designed to be

00:29:23,570 --> 00:29:27,800
an extensible platform for identifying

00:29:25,700 --> 00:29:33,410
and converting an old bad pattern into

00:29:27,800 --> 00:29:36,230
something better so that kind of covers

00:29:33,410 --> 00:29:39,730
the rest of those bullets right upgrades

00:29:36,230 --> 00:29:42,200
are easy if we your library vendors

00:29:39,730 --> 00:29:45,050
promise not to break you without

00:29:42,200 --> 00:29:47,090
providing a tool for the upgrade the

00:29:45,050 --> 00:29:49,100
tool will identify the places that are

00:29:47,090 --> 00:29:51,170
affected by the break and perform the

00:29:49,100 --> 00:29:52,970
upgrade automatically assuming that

00:29:51,170 --> 00:29:54,650
we're all writing well behaved code and

00:29:52,970 --> 00:29:57,679
being good engineers and providing unit

00:29:54,650 --> 00:29:59,510
tests in that world a complete novice

00:29:57,679 --> 00:30:03,890
can do the upgrade for a project they

00:29:59,510 --> 00:30:08,000
don't work in keep it locally submit the

00:30:03,890 --> 00:30:10,130
patch upstream whatever it will not be a

00:30:08,000 --> 00:30:11,390
silver bullet going back to Fred Brooks

00:30:10,130 --> 00:30:14,090
and the mythical man-month essays

00:30:11,390 --> 00:30:16,820
tooling is not going to get us double

00:30:14,090 --> 00:30:18,380
performance double productivity we

00:30:16,820 --> 00:30:20,270
aren't going to magically make these

00:30:18,380 --> 00:30:21,800
gains we can't just wave the magic

00:30:20,270 --> 00:30:22,520
tooling wand and make all of the

00:30:21,800 --> 00:30:24,650
problems go away

00:30:22,520 --> 00:30:27,110
these two will solve one particular

00:30:24,650 --> 00:30:28,460
class of things extraordinarily well but

00:30:27,110 --> 00:30:30,590
they are often constrained by

00:30:28,460 --> 00:30:35,990
practicalities like the code you wrote

00:30:30,590 --> 00:30:38,720
is insane the deal is going to be this

00:30:35,990 --> 00:30:40,670
if your code is well behaved the tools

00:30:38,720 --> 00:30:43,010
should be able to enable the types of

00:30:40,670 --> 00:30:45,200
refactoring and changes that we have

00:30:43,010 --> 00:30:48,290
collectively been most afraid of the

00:30:45,200 --> 00:30:51,110
major version bump changes tools are

00:30:48,290 --> 00:30:53,840
great for doing non-atomic API

00:30:51,110 --> 00:30:55,670
migrations you introduce the new API you

00:30:53,840 --> 00:30:58,010
provide the tool wait for people to

00:30:55,670 --> 00:31:01,020
apply the tool then if necessary and

00:30:58,010 --> 00:31:04,080
practical you remove the old API

00:31:01,020 --> 00:31:06,570
with these tools and policies I claim

00:31:04,080 --> 00:31:09,540
that this is enough to solve diamond

00:31:06,570 --> 00:31:11,970
dependencies no API breaks without tools

00:31:09,540 --> 00:31:14,550
users are well behaved unit tests

00:31:11,970 --> 00:31:16,740
everywhere for source distribution if

00:31:14,550 --> 00:31:18,030
you are dealing in binary compatibility

00:31:16,740 --> 00:31:22,500
and things like that you are often to

00:31:18,030 --> 00:31:24,929
hold every world and I good luck but the

00:31:22,500 --> 00:31:29,120
sad reality is almost anything you can

00:31:24,929 --> 00:31:31,650
do will break someone's build so

00:31:29,120 --> 00:31:34,260
projects that intend to actually work

00:31:31,650 --> 00:31:35,790
over time should be clear about what

00:31:34,260 --> 00:31:38,309
they promise and what they require from

00:31:35,790 --> 00:31:40,020
you in exchange I am trying to get the

00:31:38,309 --> 00:31:40,650
standard to be better about that stay

00:31:40,020 --> 00:31:42,420
tuned

00:31:40,650 --> 00:31:43,620
no one can actually speak for the whole

00:31:42,420 --> 00:31:47,370
committee there's a hundred people there

00:31:43,620 --> 00:31:48,600
but I do believe there's rough consensus

00:31:47,370 --> 00:31:51,840
that we the committee will put out

00:31:48,600 --> 00:31:54,690
something more robust soon right now

00:31:51,840 --> 00:31:56,580
very few people in this room know what

00:31:54,690 --> 00:31:58,740
the standard actually says about

00:31:56,580 --> 00:32:01,350
reserving behavior for future changes

00:31:58,740 --> 00:32:03,240
and the standard itself does not say

00:32:01,350 --> 00:32:05,940
nearly as much as the committee relies

00:32:03,240 --> 00:32:07,800
upon so the details in the next couple

00:32:05,940 --> 00:32:09,390
slides may change before the committee

00:32:07,800 --> 00:32:10,800
actually commits to something but

00:32:09,390 --> 00:32:13,650
roughly I imagine that it'll be

00:32:10,800 --> 00:32:15,420
something like this rule number one we

00:32:13,650 --> 00:32:18,240
reserve the right to add things to

00:32:15,420 --> 00:32:20,670
namespace stood you don't get to add

00:32:18,240 --> 00:32:22,590
things to stood this shouldn't be

00:32:20,670 --> 00:32:24,360
surprising the standard library is going

00:32:22,590 --> 00:32:26,070
to expand over time and we need to not

00:32:24,360 --> 00:32:29,880
be worrying about whether it's safe to

00:32:26,070 --> 00:32:32,460
add things just do it of course step

00:32:29,880 --> 00:32:35,309
back this is a prime example of an

00:32:32,460 --> 00:32:38,820
engineering rule not a programming rule

00:32:35,309 --> 00:32:40,620
if you know for sure that you will never

00:32:38,820 --> 00:32:42,120
have to upgrade compilers or standard

00:32:40,620 --> 00:32:43,650
libraries no one else is ever gonna use

00:32:42,120 --> 00:32:45,270
your code you're never gonna share it

00:32:43,650 --> 00:32:47,670
it's never gonna get off that hard drive

00:32:45,270 --> 00:32:50,880
you can have whatever you want to stood

00:32:47,670 --> 00:32:53,940
your builds gonna work it's fine it's

00:32:50,880 --> 00:32:55,410
not a good idea but this is an

00:32:53,940 --> 00:32:58,140
engineering rule not a programming rule

00:32:55,410 --> 00:33:00,690
and it's gonna break if you do that and

00:32:58,140 --> 00:33:02,760
you ever try to share that or upgrade

00:33:00,690 --> 00:33:05,960
that and we're all gonna laugh at you if

00:33:02,760 --> 00:33:08,550
you complain about having done that but

00:33:05,960 --> 00:33:10,140
there are of course some things instead

00:33:08,550 --> 00:33:11,730
you are allowed to do for your own types

00:33:10,140 --> 00:33:14,100
you're allowed to specialize to the hash

00:33:11,730 --> 00:33:16,320
of T it does have to be your

00:33:14,100 --> 00:33:18,860
type specifying a hash for some

00:33:16,320 --> 00:33:21,150
unhackable stood type still forbidden

00:33:18,860 --> 00:33:22,950
specifying the hash or really anything

00:33:21,150 --> 00:33:25,080
else for a type that you got from

00:33:22,950 --> 00:33:27,150
someone else's library is in general

00:33:25,080 --> 00:33:29,970
just bad form you are preventing them

00:33:27,150 --> 00:33:32,970
from doing the same operation

00:33:29,970 --> 00:33:36,270
it makes library maintenance just

00:33:32,970 --> 00:33:40,020
nightmarish don't define things for

00:33:36,270 --> 00:33:42,210
api's you don't own forward declarations

00:33:40,020 --> 00:33:44,070
in the standards case are a particularly

00:33:42,210 --> 00:33:47,039
subtle and annoying subset if don't add

00:33:44,070 --> 00:33:49,350
things to stood you shouldn't forward

00:33:47,039 --> 00:33:52,200
declare things you shouldn't add things

00:33:49,350 --> 00:33:55,169
your forward declaration assumes that

00:33:52,200 --> 00:33:57,780
the details of that name instead never

00:33:55,169 --> 00:34:01,049
change and it is not your right to

00:33:57,780 --> 00:34:03,179
enforce exactly the details of those

00:34:01,049 --> 00:34:05,789
names if it's not promised by the

00:34:03,179 --> 00:34:08,609
standard right in an engineering system

00:34:05,789 --> 00:34:11,250
you can't add that constraint that's

00:34:08,609 --> 00:34:13,080
reserved for us so let me say that again

00:34:11,250 --> 00:34:15,510
you are not allowed to forward declare

00:34:13,080 --> 00:34:17,220
things you do not own at least not if

00:34:15,510 --> 00:34:20,190
you want your bill to not break under

00:34:17,220 --> 00:34:21,690
API maintenance I pulled this out of

00:34:20,190 --> 00:34:25,500
boost code from a couple months ago

00:34:21,690 --> 00:34:27,629
here's an example don't do this if the

00:34:25,500 --> 00:34:29,790
standard if the committee decides to add

00:34:27,629 --> 00:34:32,909
an additional template to unordered set

00:34:29,790 --> 00:34:35,010
with a default parameter so all code

00:34:32,909 --> 00:34:37,470
that its building currently it continues

00:34:35,010 --> 00:34:39,500
to build this four parameter forward

00:34:37,470 --> 00:34:41,490
declaration is now a build break

00:34:39,500 --> 00:34:44,820
congratulations you have saved your user

00:34:41,490 --> 00:34:52,740
a pound include in exchange for a build

00:34:44,820 --> 00:34:54,720
break not a good choice also I believe

00:34:52,740 --> 00:34:57,270
that the standard is going to come to

00:34:54,720 --> 00:35:00,060
something along the lines of assume the

00:34:57,270 --> 00:35:01,680
call only interface this is going to be

00:35:00,060 --> 00:35:03,180
bits like don't take the address of

00:35:01,680 --> 00:35:05,730
functions don't depend on meta

00:35:03,180 --> 00:35:07,170
programming or introspection taking the

00:35:05,730 --> 00:35:09,300
address of a free function in namespace

00:35:07,170 --> 00:35:12,030
stood will be a build break if and when

00:35:09,300 --> 00:35:14,250
we add an overload for that so you know

00:35:12,030 --> 00:35:16,170
if we decide to put an allocator in the

00:35:14,250 --> 00:35:18,450
free function for stood a line that'll

00:35:16,170 --> 00:35:21,480
break your build someday amusingly

00:35:18,450 --> 00:35:23,490
according to Howard the standard doesn't

00:35:21,480 --> 00:35:25,440
currently forbid this you are not

00:35:23,490 --> 00:35:27,450
allowed to take the address of member

00:35:25,440 --> 00:35:30,270
functions in stood so you can't take the

00:35:27,450 --> 00:35:32,010
address of student string size but there

00:35:30,270 --> 00:35:33,869
is nothing in the standard as far as we

00:35:32,010 --> 00:35:36,569
can tell that technically forbids you

00:35:33,869 --> 00:35:38,520
for doing this for free functions that

00:35:36,569 --> 00:35:40,619
said I'm pretty sure I speak for the

00:35:38,520 --> 00:35:42,210
Committee on this one we super don't

00:35:40,619 --> 00:35:45,410
care if your build breaks because you

00:35:42,210 --> 00:35:45,410
did this and we added an overload

00:35:45,650 --> 00:35:49,560
there's another important class of usage

00:35:48,000 --> 00:35:52,609
that the standard doesn't promise is

00:35:49,560 --> 00:35:57,510
stable over time metaprogramming

00:35:52,609 --> 00:36:03,690
this is a stunningly stupid is even take

00:35:57,510 --> 00:36:05,910
a look it does the obvious thing in

00:36:03,690 --> 00:36:08,849
eleven and fourteen and becomes super

00:36:05,910 --> 00:36:11,550
wrong in seventeen the type of stood

00:36:08,849 --> 00:36:13,920
vector in place back changed to return a

00:36:11,550 --> 00:36:15,300
reference to that new element obviously

00:36:13,920 --> 00:36:18,780
no one is actually going to write this

00:36:15,300 --> 00:36:20,369
this is merely slide code but you can

00:36:18,780 --> 00:36:23,040
imagine over ten thousand lines of code

00:36:20,369 --> 00:36:24,869
building bad dependencies on meta

00:36:23,040 --> 00:36:27,420
properties of things out of the standard

00:36:24,869 --> 00:36:29,339
a huge number of the properties of the

00:36:27,420 --> 00:36:31,950
standard library are detectable at

00:36:29,339 --> 00:36:33,569
compile time and the vast majority of

00:36:31,950 --> 00:36:36,569
those are subject to change from version

00:36:33,569 --> 00:36:39,240
to version write this code correctly

00:36:36,569 --> 00:36:41,760
implements is even in C++ eleven and

00:36:39,240 --> 00:36:44,099
fourteen and becomes completely wrong in

00:36:41,760 --> 00:36:50,640
seventeen because we changed the type of

00:36:44,099 --> 00:36:52,349
in place back don't do that so that's

00:36:50,640 --> 00:36:54,210
kind of an example of this compatibility

00:36:52,349 --> 00:36:56,400
promise that I think needs to become

00:36:54,210 --> 00:36:58,349
more clear for all of the libraries that

00:36:56,400 --> 00:36:59,970
you're depending on if it is being

00:36:58,349 --> 00:37:02,250
maintained like at a professional level

00:36:59,970 --> 00:37:05,280
they need to tell you what they promise

00:37:02,250 --> 00:37:07,230
what they ask from you in exchange if

00:37:05,280 --> 00:37:09,290
we're talking about engineering projects

00:37:07,230 --> 00:37:11,760
and compatibility over time everything

00:37:09,290 --> 00:37:14,460
here needs to be understood as a two-way

00:37:11,760 --> 00:37:16,530
street the underlying library be it the

00:37:14,460 --> 00:37:18,359
standard or boost or anything else needs

00:37:16,530 --> 00:37:21,300
to be clear about what compatibility it

00:37:18,359 --> 00:37:23,190
promises and what it doesn't it is not

00:37:21,300 --> 00:37:25,800
theoretically satisfying but those

00:37:23,190 --> 00:37:28,040
promises are far more complex than the

00:37:25,800 --> 00:37:31,290
simplistic semver compatibility story

00:37:28,040 --> 00:37:33,030
semver has lured us in with the idea

00:37:31,290 --> 00:37:35,490
that we can collapse compatibility down

00:37:33,030 --> 00:37:37,940
into one concept brushing aside the fact

00:37:35,490 --> 00:37:40,940
that it both oversimplifies and over

00:37:37,940 --> 00:37:42,859
strains it also importantly brushes

00:37:40,940 --> 00:37:44,960
aside the fact that without real

00:37:42,859 --> 00:37:47,690
compatibility promises and discussions

00:37:44,960 --> 00:37:50,450
and without tooling to ensure that users

00:37:47,690 --> 00:37:52,849
of a library are well behaved even a

00:37:50,450 --> 00:37:57,170
patch release in December a world can

00:37:52,849 --> 00:37:59,030
break things arbitrarily over the years

00:37:57,170 --> 00:38:02,089
we've gone from nothing ever changes

00:37:59,030 --> 00:38:04,339
like early POSIX - nothing changes in a

00:38:02,089 --> 00:38:06,200
fashion that might break things both of

00:38:04,339 --> 00:38:08,869
which can work but are sort of annoying

00:38:06,200 --> 00:38:10,970
and stagnating Computer Engineering is

00:38:08,869 --> 00:38:12,829
it software engineering is coming up on

00:38:10,970 --> 00:38:15,920
maybe 50 years depending on where you

00:38:12,829 --> 00:38:18,740
you know draw the starting point and

00:38:15,920 --> 00:38:21,220
it's gonna go for a while more the idea

00:38:18,740 --> 00:38:25,849
of something staying completely static

00:38:21,220 --> 00:38:28,490
indefinitely seems like a bad gamble an

00:38:25,849 --> 00:38:30,920
attempt to rebel against no breaking

00:38:28,490 --> 00:38:33,050
changes we've glossed over the fact that

00:38:30,920 --> 00:38:35,240
we haven't really defined what is and is

00:38:33,050 --> 00:38:37,819
not a breaking change we focus intensely

00:38:35,240 --> 00:38:39,740
on API breaks and closed our eyes to

00:38:37,819 --> 00:38:42,170
everything else pretending that semver

00:38:39,740 --> 00:38:44,660
solves things but as our dependency

00:38:42,170 --> 00:38:48,099
graph grows quadratically the odds of

00:38:44,660 --> 00:38:51,230
this becoming unsatisfiable grow as well

00:38:48,099 --> 00:38:53,780
so what if there was a world that worked

00:38:51,230 --> 00:38:55,640
differently there is that third option

00:38:53,780 --> 00:38:58,460
for avoiding diamond dependencies after

00:38:55,640 --> 00:38:59,500
all make it always easy to update even

00:38:58,460 --> 00:39:01,700
for a non-expert

00:38:59,500 --> 00:39:03,560
anyone that's lived in a mono repo has

00:39:01,700 --> 00:39:05,089
already experienced this anyone that's

00:39:03,560 --> 00:39:07,460
worked at Google in the last five years

00:39:05,089 --> 00:39:10,010
has seen this in action the burden is on

00:39:07,460 --> 00:39:12,230
the people making API changes to update

00:39:10,010 --> 00:39:15,829
their users we've spoken at length about

00:39:12,230 --> 00:39:18,050
how we make this work it also puts the

00:39:15,829 --> 00:39:21,079
burden on the people making the change

00:39:18,050 --> 00:39:24,079
to deploy the change which is a much

00:39:21,079 --> 00:39:26,630
better scaling property so go back to

00:39:24,079 --> 00:39:29,240
the start of the talk I need to make

00:39:26,630 --> 00:39:31,579
code inside and outside Google API

00:39:29,240 --> 00:39:33,500
compatible that is my mission we've had

00:39:31,579 --> 00:39:36,440
years of experience with the upgrades

00:39:33,500 --> 00:39:38,359
are easy variety of the things and as a

00:39:36,440 --> 00:39:40,760
result of as a result of our policies

00:39:38,359 --> 00:39:44,390
and our mono repo and now I would like

00:39:40,760 --> 00:39:46,700
to offer that to you so today we're

00:39:44,390 --> 00:39:49,450
introducing abseil don't go to the

00:39:46,700 --> 00:39:49,450
website I'm still talking

00:39:50,130 --> 00:39:55,330
we're releasing common libraries with an

00:39:53,470 --> 00:39:56,110
engineering focus we want this to work

00:39:55,330 --> 00:39:58,120
overtime

00:39:56,110 --> 00:40:00,400
just like the required fields example

00:39:58,120 --> 00:40:02,140
some of what we ask may not entirely

00:40:00,400 --> 00:40:04,720
make sense at first or it may seem

00:40:02,140 --> 00:40:06,970
arbitrary and weird but I promise you

00:40:04,720 --> 00:40:09,490
over time this will be the right answer

00:40:06,970 --> 00:40:11,280
or we'll figure out how to change it to

00:40:09,490 --> 00:40:13,270
be the right answer

00:40:11,280 --> 00:40:16,120
these are the libraries that are used

00:40:13,270 --> 00:40:18,610
internally at Google we released soft

00:40:16,120 --> 00:40:20,890
launch yesterday I have a quarter of a

00:40:18,610 --> 00:40:26,080
billion lines of C++ code that depend on

00:40:20,890 --> 00:40:29,220
this I have twelve thousand active

00:40:26,080 --> 00:40:31,150
developers depending on this day to day

00:40:29,220 --> 00:40:33,670
these are the libraries that are used

00:40:31,150 --> 00:40:35,710
they're about to be used by other Google

00:40:33,670 --> 00:40:37,810
open source projects protobuf G RPC

00:40:35,710 --> 00:40:39,190
tensorflow this is a big part of why

00:40:37,810 --> 00:40:41,770
we're doing this right now actually

00:40:39,190 --> 00:40:43,390
things in this codebase tend to get

00:40:41,770 --> 00:40:47,680
written against the same set of api's

00:40:43,390 --> 00:40:50,050
and when we open-source them we don't

00:40:47,680 --> 00:40:52,150
have a nice canonical supported set of

00:40:50,050 --> 00:40:53,890
those api's to work with for the open

00:40:52,150 --> 00:40:55,900
source releases so every one of those

00:40:53,890 --> 00:40:57,730
projects every one of those teams spends

00:40:55,900 --> 00:40:59,440
a bunch of effort like hacking their way

00:40:57,730 --> 00:41:02,590
back out of the codebase we're just

00:40:59,440 --> 00:41:03,970
gonna fix that problem at the root we've

00:41:02,590 --> 00:41:05,380
spoken for years about the internal

00:41:03,970 --> 00:41:07,840
processes and our ability to do

00:41:05,380 --> 00:41:11,490
large-scale refactoring I don't want to

00:41:07,840 --> 00:41:13,900
lose that ability to change is important

00:41:11,490 --> 00:41:15,910
I've spoken about what it takes to be

00:41:13,900 --> 00:41:17,950
sustainable and I'm very proud of having

00:41:15,910 --> 00:41:20,830
gotten Google's codebase to that point

00:41:17,950 --> 00:41:23,050
ability to react to change isn't a big

00:41:20,830 --> 00:41:26,350
part of that but we also don't want to

00:41:23,050 --> 00:41:28,240
break you the open-source users we have

00:41:26,350 --> 00:41:31,570
to be responsible and provide easy

00:41:28,240 --> 00:41:32,830
upgrade paths all of that plus what I've

00:41:31,570 --> 00:41:35,590
already talked about for the last 40

00:41:32,830 --> 00:41:37,870
minutes if you are well-behaved we won't

00:41:35,590 --> 00:41:40,300
break you if we have to make an API

00:41:37,870 --> 00:41:42,930
change hopefully it's rare but we'll

00:41:40,300 --> 00:41:45,820
ship a tool to just do the update I

00:41:42,930 --> 00:41:48,340
don't believe in semver and I further

00:41:45,820 --> 00:41:50,470
also don't believe in pre compiling this

00:41:48,340 --> 00:41:53,230
I want you to build from source and

00:41:50,470 --> 00:41:55,960
build from head I want you to live it

00:41:53,230 --> 00:41:59,020
head if the libraries you depend on are

00:41:55,960 --> 00:42:01,030
being updated smoothly with the policies

00:41:59,020 --> 00:42:02,140
like what I've described and your code

00:42:01,030 --> 00:42:04,359
is well-behaved

00:42:02,140 --> 00:42:06,640
there is no benefit to pinning to a

00:42:04,359 --> 00:42:08,200
particular version syncing to the

00:42:06,640 --> 00:42:10,539
current version of your upstream depths

00:42:08,200 --> 00:42:12,789
should be no different than syncing with

00:42:10,539 --> 00:42:15,519
the rest of your codebase hmm

00:42:12,789 --> 00:42:17,289
in practice until we work out better

00:42:15,519 --> 00:42:20,079
mechanisms to ensure that all of your

00:42:17,289 --> 00:42:22,029
code is well behaved is gonna be a

00:42:20,079 --> 00:42:24,819
little tricky at first but it's a

00:42:22,029 --> 00:42:26,500
concept it's not a technology the more

00:42:24,819 --> 00:42:28,269
that you can keep your depths up-to-date

00:42:26,500 --> 00:42:30,519
the less exposure you have to

00:42:28,269 --> 00:42:33,630
unsatisfiable debt problems the happier

00:42:30,519 --> 00:42:36,279
you'll be plus you get all the new stuff

00:42:33,630 --> 00:42:38,140
we're gonna ship some example scripts

00:42:36,279 --> 00:42:39,700
for basil and github that make it easy

00:42:38,140 --> 00:42:41,799
to sync from upstream when you want to

00:42:39,700 --> 00:42:43,029
if you're a larger organization with

00:42:41,799 --> 00:42:46,059
security policies and the like that

00:42:43,029 --> 00:42:48,430
clearly won't apply but this is a

00:42:46,059 --> 00:42:50,650
concept not a technology get in the

00:42:48,430 --> 00:42:52,059
habit of syncing regularly if something

00:42:50,650 --> 00:42:54,460
goes wrong when a daily or weekly

00:42:52,059 --> 00:42:56,529
upgrade is going check your code against

00:42:54,460 --> 00:42:58,119
our compatibility guidelines maybe we

00:42:56,529 --> 00:42:59,650
did something wrong maybe there are

00:42:58,119 --> 00:43:02,140
things we haven't called out or maybe

00:42:59,650 --> 00:43:04,599
your code is just being silly the more

00:43:02,140 --> 00:43:07,930
aggressively that we shake those out the

00:43:04,599 --> 00:43:10,180
easier all upgrades become it was a lot

00:43:07,930 --> 00:43:12,009
a lot harder to do these sort of

00:43:10,180 --> 00:43:14,680
upgrades that we do internally five

00:43:12,009 --> 00:43:18,369
years ago we've shaken the tree and now

00:43:14,680 --> 00:43:20,680
it's nice and smooth in the end remember

00:43:18,369 --> 00:43:22,960
what I'm doing here is bringing the

00:43:20,680 --> 00:43:24,849
api's and the user experience that

00:43:22,960 --> 00:43:26,890
Googlers have lived with for years I am

00:43:24,849 --> 00:43:28,960
NOT saying it's perfect or the ultimate

00:43:26,890 --> 00:43:30,880
answer but this is what this project

00:43:28,960 --> 00:43:33,430
needs in order to still have a chance of

00:43:30,880 --> 00:43:39,579
maintaining velocity for those quarter

00:43:33,430 --> 00:43:41,680
of a billion lines of code let me go

00:43:39,579 --> 00:43:43,359
into some detail on what you can't do

00:43:41,680 --> 00:43:45,490
with abseil code and still qualify as

00:43:43,359 --> 00:43:47,259
well-behaved although remember this is

00:43:45,490 --> 00:43:49,930
of course an engineering restriction not

00:43:47,259 --> 00:43:51,940
a programming one if all you need is a

00:43:49,930 --> 00:43:54,279
moment in time go ahead and hack away

00:43:51,940 --> 00:43:57,849
just don't come to us if it doesn't work

00:43:54,279 --> 00:43:59,349
when you try to do an upgrade we reserve

00:43:57,849 --> 00:44:02,829
the right to add things to namespace

00:43:59,349 --> 00:44:04,779
absol everything on this list has the

00:44:02,829 --> 00:44:07,660
potential to break existing code just

00:44:04,779 --> 00:44:09,220
because we added a new symbol we will

00:44:07,660 --> 00:44:12,039
eventually get better static analysis

00:44:09,220 --> 00:44:14,559
linters client ID checks etc updated

00:44:12,039 --> 00:44:15,310
public to catch as much of this as is

00:44:14,559 --> 00:44:18,250
practical

00:44:15,310 --> 00:44:20,080
but I guarantee you everything on this

00:44:18,250 --> 00:44:22,210
list is the thing that you could trigger

00:44:20,080 --> 00:44:25,720
a build break with when I make an

00:44:22,210 --> 00:44:26,920
internal change or when I add a new name

00:44:25,720 --> 00:44:29,590
we also reserve the right to change

00:44:26,920 --> 00:44:32,140
implementation details the ABI will not

00:44:29,590 --> 00:44:33,880
be stable do not you know rely on

00:44:32,140 --> 00:44:36,100
I built this six months ago and now I'm

00:44:33,880 --> 00:44:38,170
trying to link against a version of it

00:44:36,100 --> 00:44:40,810
from now and like no we changed things

00:44:38,170 --> 00:44:43,330
all the time don't do that don't depend

00:44:40,810 --> 00:44:45,580
on internals any namespace with internal

00:44:43,330 --> 00:44:47,470
in it is not for you and you file name

00:44:45,580 --> 00:44:49,780
with internal in it is also not for you

00:44:47,470 --> 00:44:51,340
please stay away from those I know that

00:44:49,780 --> 00:44:53,470
everyone's like oh underscore underscore

00:44:51,340 --> 00:44:55,630
in the standard means that's reserved

00:44:53,470 --> 00:44:59,380
for internals but I can do it just this

00:44:55,630 --> 00:45:01,300
one time no you can't don't define

00:44:59,380 --> 00:45:05,470
private-public not even once it's not

00:45:01,300 --> 00:45:07,930
funny don't do that our include graph

00:45:05,470 --> 00:45:11,680
will change please include things

00:45:07,930 --> 00:45:14,050
includes are not bad on the topic

00:45:11,680 --> 00:45:17,080
specifically of a bi and internals not

00:45:14,050 --> 00:45:18,730
being stable I really like go see Matt

00:45:17,080 --> 00:45:20,410
kulakundis his talk Wednesday afternoon

00:45:18,730 --> 00:45:22,780
for why we find those things so

00:45:20,410 --> 00:45:25,750
important if we were constrained by any

00:45:22,780 --> 00:45:28,110
of this than our recent work on changing

00:45:25,750 --> 00:45:33,880
hash tables would have been impossible

00:45:28,110 --> 00:45:37,300
improvement requires change duh so what

00:45:33,880 --> 00:45:39,580
is AB sale this is a library zero config

00:45:37,300 --> 00:45:43,360
it is a bunch of utility code it is the

00:45:39,580 --> 00:45:45,700
low level nuts and bolts of C++ as we

00:45:43,360 --> 00:45:48,190
write it it is spring routines

00:45:45,700 --> 00:45:49,900
it is debugging an analysis one of the

00:45:48,190 --> 00:45:54,370
things I'm really really excited about

00:45:49,900 --> 00:45:56,500
is it will include guidance internally

00:45:54,370 --> 00:45:58,810
for the C++ library teams probably meant

00:45:56,500 --> 00:46:00,940
five years now we started publishing a

00:45:58,810 --> 00:46:04,210
tip of the week series which is sort of

00:46:00,940 --> 00:46:06,820
a longer form essay about something

00:46:04,210 --> 00:46:09,640
that's been coming up these are largely

00:46:06,820 --> 00:46:12,720
compatible with the core guidelines just

00:46:09,640 --> 00:46:15,190
in a sort of longer form discussion I'm

00:46:12,720 --> 00:46:18,040
I've been trying for years to have a

00:46:15,190 --> 00:46:20,020
smooth venue for shipping all of that

00:46:18,040 --> 00:46:22,270
and now I finally have a mandate to do

00:46:20,020 --> 00:46:25,270
it so that's nice

00:46:22,270 --> 00:46:27,280
we have C++ 11 compatible versions of

00:46:25,270 --> 00:46:28,630
standard types that we are pre adopting

00:46:27,280 --> 00:46:31,080
so if you really

00:46:28,630 --> 00:46:34,000
stuff out of 17 but you're stuck on 11

00:46:31,080 --> 00:46:36,220
maybe you want to give it a shot and in

00:46:34,000 --> 00:46:37,930
a couple cases we have alternative

00:46:36,220 --> 00:46:39,970
designs and priorities to the standard

00:46:37,930 --> 00:46:41,980
but the general goal for everything is

00:46:39,970 --> 00:46:44,770
support five years back when possible

00:46:41,980 --> 00:46:47,530
let's look at what that means five-year

00:46:44,770 --> 00:46:49,870
compatibility and zero config means we

00:46:47,530 --> 00:46:51,940
are going to assume the standard but

00:46:49,870 --> 00:46:56,620
work around it if needed here is an

00:46:51,940 --> 00:46:58,570
example the thread-local keyword for C++

00:46:56,620 --> 00:46:59,920
11 it's been implemented by all of our

00:46:58,570 --> 00:47:02,970
compilers everything that we care about

00:46:59,920 --> 00:47:06,940
it's works fine but for some reason in

00:47:02,970 --> 00:47:10,990
Apple Xcode up until xcode 8 it was

00:47:06,940 --> 00:47:13,090
disabled so we have tagged in here

00:47:10,990 --> 00:47:14,740
Apple for build version 8 we detect that

00:47:13,090 --> 00:47:15,190
scenario and everywhere that we are

00:47:14,740 --> 00:47:18,600
using

00:47:15,190 --> 00:47:22,480
thread-local we have to work around it

00:47:18,600 --> 00:47:25,930
the other half of this is five years

00:47:22,480 --> 00:47:28,240
after xcode 8 and the fix has been

00:47:25,930 --> 00:47:30,970
released we're going to delete this and

00:47:28,240 --> 00:47:33,010
all of those hacky workarounds right you

00:47:30,970 --> 00:47:36,400
get 5 years where you are planning for

00:47:33,010 --> 00:47:39,370
the future abseil is a bunch of utility

00:47:36,400 --> 00:47:41,710
code string routines I'm really amused

00:47:39,370 --> 00:47:42,790
in the aftermath of Darkness talk we

00:47:41,710 --> 00:47:46,450
were talking about we'd really like

00:47:42,790 --> 00:47:49,350
something like a Python split like give

00:47:46,450 --> 00:47:52,690
me 45 minutes and I'll ship this for you

00:47:49,350 --> 00:47:55,210
so we have ster split it takes string

00:47:52,690 --> 00:47:57,580
--is-- things and a variety of delimiter

00:47:55,210 --> 00:48:01,150
z' in the simple case and it returns you

00:47:57,580 --> 00:48:02,800
a vector of string or does it it

00:48:01,150 --> 00:48:04,720
actually also returns you a vector of

00:48:02,800 --> 00:48:08,320
string view or a list of string view or

00:48:04,720 --> 00:48:10,230
a your container of whatever it does a

00:48:08,320 --> 00:48:15,430
fair amount of nice magic to give you a

00:48:10,230 --> 00:48:17,980
very powerful expressive basic concept

00:48:15,430 --> 00:48:20,620
I just want to split a string and do it

00:48:17,980 --> 00:48:23,680
in a configurable customizable very C++

00:48:20,620 --> 00:48:24,460
you sort of way you can also go the

00:48:23,680 --> 00:48:28,630
other direction

00:48:24,460 --> 00:48:29,980
joining strings a little less magic one

00:48:28,630 --> 00:48:31,900
of my absolute favorite things

00:48:29,980 --> 00:48:34,150
stir cat this is a very attic

00:48:31,900 --> 00:48:35,950
unformatted just converted to string and

00:48:34,150 --> 00:48:39,520
concatenate it and it is blazingly

00:48:35,950 --> 00:48:42,010
ridiculously fast I've had a number of

00:48:39,520 --> 00:48:43,300
Googlers say you know

00:48:42,010 --> 00:48:45,010
if you don't release anything else

00:48:43,300 --> 00:48:49,630
through abseil but you released your cat

00:48:45,010 --> 00:48:51,850
project is still a success is a really

00:48:49,630 --> 00:48:55,380
simple way of life improvement for it I

00:48:51,850 --> 00:48:55,380
just need a string just give me a string

00:48:55,560 --> 00:49:00,790
this is debugging facilities we have

00:48:58,090 --> 00:49:02,530
leak checking ap is the API is always

00:49:00,790 --> 00:49:06,370
there and if you happen to build your

00:49:02,530 --> 00:49:08,200
code with leak sanitizer enabled then

00:49:06,370 --> 00:49:12,040
the API is implemented by leak sanitizer

00:49:08,200 --> 00:49:14,020
if not maybe you feel like implementing

00:49:12,040 --> 00:49:16,600
leak checking with some other thing

00:49:14,020 --> 00:49:18,970
that's fine same API will be there and

00:49:16,600 --> 00:49:21,070
your code will always build regardless

00:49:18,970 --> 00:49:23,500
what platform you're on we have stack

00:49:21,070 --> 00:49:25,450
traces on supported platforms of course

00:49:23,500 --> 00:49:28,450
get back the function pointers for your

00:49:25,450 --> 00:49:29,890
function stack on even more limited ly

00:49:28,450 --> 00:49:31,420
supported platforms we're working on

00:49:29,890 --> 00:49:33,610
symbolizing those so that you get the

00:49:31,420 --> 00:49:35,500
names of those functions we have nice

00:49:33,610 --> 00:49:36,250
built-in ties to address sanitizer your

00:49:35,500 --> 00:49:37,720
thread sanitizer

00:49:36,250 --> 00:49:40,600
you can tell what tools we use

00:49:37,720 --> 00:49:44,770
internally and the static thread

00:49:40,600 --> 00:49:48,220
annotations I really like those we are

00:49:44,770 --> 00:49:50,260
pre adopting C++ 17 types in C++ 11 so

00:49:48,220 --> 00:49:52,780
you have string view optional any and

00:49:50,260 --> 00:49:54,520
soon variant turns out it is hard to

00:49:52,780 --> 00:49:58,480
write variant so that it works on all

00:49:54,520 --> 00:50:02,260
compilers in C++ 11 we'll get there

00:49:58,480 --> 00:50:04,900
promise there but wait you may say types

00:50:02,260 --> 00:50:07,420
are expensive you have heard Titus speak

00:50:04,900 --> 00:50:07,960
in other forums and he says types are

00:50:07,420 --> 00:50:10,780
expensive

00:50:07,960 --> 00:50:13,590
so consider in a C++ 14 code base you

00:50:10,780 --> 00:50:17,020
wrote something absolute optional foo

00:50:13,590 --> 00:50:20,290
returned by maybe foo now you want to

00:50:17,020 --> 00:50:21,970
update to a C++ 17 world and you don't

00:50:20,290 --> 00:50:23,680
want to spell absolution only you want

00:50:21,970 --> 00:50:25,630
to spell stood optional right we're in

00:50:23,680 --> 00:50:28,660
17 we should use the standard clearly

00:50:25,630 --> 00:50:30,250
you should use the standard so you have

00:50:28,660 --> 00:50:33,820
to go track down every place that that

00:50:30,250 --> 00:50:35,890
is called and update those things in the

00:50:33,820 --> 00:50:37,150
same change that's kind of annoying and

00:50:35,890 --> 00:50:40,960
then you have to track down everywhere

00:50:37,150 --> 00:50:43,300
that F goes so you have to update every

00:50:40,960 --> 00:50:45,100
function that it passes into and you can

00:50:43,300 --> 00:50:48,490
see like in theory this might get

00:50:45,100 --> 00:50:52,060
actually kind of messy and difficult it

00:50:48,490 --> 00:50:53,620
turns out no we planned for this we

00:50:52,060 --> 00:50:55,880
check at Build time

00:50:53,620 --> 00:50:59,240
are you building in C++ 17 mode

00:50:55,880 --> 00:51:02,390
you have stood optional if so Absalom

00:50:59,240 --> 00:51:04,869
tional disappears it is just an alias

00:51:02,390 --> 00:51:07,789
first it optional they are never the

00:51:04,869 --> 00:51:11,359
they're never separate types they are at

00:51:07,789 --> 00:51:14,240
most separate spellings in any build for

00:51:11,359 --> 00:51:16,819
abseil you should have one of stood

00:51:14,240 --> 00:51:21,829
optional and absol optional and string

00:51:16,819 --> 00:51:23,990
view and any etc this means when you use

00:51:21,829 --> 00:51:27,079
the new standard the pre adopted types

00:51:23,990 --> 00:51:29,299
just melt away and you don't have any

00:51:27,079 --> 00:51:31,910
restriction on how you update those

00:51:29,299 --> 00:51:34,339
spellings both spellings are the same

00:51:31,910 --> 00:51:35,869
type so you're gonna just update one

00:51:34,339 --> 00:51:38,750
file at a time as you feel like doing it

00:51:35,869 --> 00:51:41,240
or you can leave it for later per the

00:51:38,750 --> 00:51:43,069
five-year policy five years after the

00:51:41,240 --> 00:51:46,519
relevant standard is available five

00:51:43,069 --> 00:51:48,710
years after C++ 17 we will ship a client

00:51:46,519 --> 00:51:50,720
ID check that updates the spelling

00:51:48,710 --> 00:51:52,160
everywhere from absol optional just

00:51:50,720 --> 00:51:54,710
stood optional because we assume that

00:51:52,160 --> 00:51:58,670
you have 17 and then we will delete our

00:51:54,710 --> 00:52:00,740
version however this is important this

00:51:58,670 --> 00:52:03,920
is part of why we can't have you relying

00:52:00,740 --> 00:52:05,509
an argument dependent look up on ADL ADL

00:52:03,920 --> 00:52:07,700
is one of those surprising bits of the

00:52:05,509 --> 00:52:10,849
language when you call an unqualified

00:52:07,700 --> 00:52:12,920
function the overload set is formed by

00:52:10,849 --> 00:52:14,990
looking in the associated namespaces for

00:52:12,920 --> 00:52:17,809
the arguments of that function and this

00:52:14,990 --> 00:52:21,049
means this code works fine in eleven

00:52:17,809 --> 00:52:25,309
inset and 14 I have an abyssal string

00:52:21,049 --> 00:52:27,799
view and I can call unqualified stir cat

00:52:25,309 --> 00:52:29,990
and it will say oh one of my arguments

00:52:27,799 --> 00:52:32,630
is from namespace abyssal I will look in

00:52:29,990 --> 00:52:36,799
namespace abyssal oh there's an abyssal

00:52:32,630 --> 00:52:39,170
stir cat done my build succeeds this

00:52:36,799 --> 00:52:42,589
code obviously breaks when you update to

00:52:39,170 --> 00:52:45,109
17 because absol stops being The

00:52:42,589 --> 00:52:48,769
Associated namespace of that type it's

00:52:45,109 --> 00:52:50,990
stood string view and 17 so if you write

00:52:48,769 --> 00:52:53,769
your code to depend on things like ADL

00:52:50,990 --> 00:52:56,660
you will break over time don't do that

00:52:53,769 --> 00:52:59,539
we will try to ship static analysis to

00:52:56,660 --> 00:53:02,079
prevent you from doing that so don't

00:52:59,539 --> 00:53:02,079
rely on a deal

00:53:02,730 --> 00:53:07,140
like I said we're shipping the guidance

00:53:04,830 --> 00:53:10,890
tip of the week series there's about 130

00:53:07,140 --> 00:53:13,710
of these I checked very recently these

00:53:10,890 --> 00:53:18,720
are cited about 25,000 times a month

00:53:13,710 --> 00:53:19,920
internally so it's a little important we

00:53:18,720 --> 00:53:23,760
cite them by number

00:53:19,920 --> 00:53:26,520
traditionally in code review so I know

00:53:23,760 --> 00:53:30,350
the numbers of probably 15 or 20 of them

00:53:26,520 --> 00:53:33,000
just off the top of my head if I see you

00:53:30,350 --> 00:53:34,980
doing something that indicates maybe you

00:53:33,000 --> 00:53:37,860
don't understand how return values and

00:53:34,980 --> 00:53:40,740
copies work in C++ I'm going to cite tip

00:53:37,860 --> 00:53:42,300
of the week 77 and this is just kind of

00:53:40,740 --> 00:53:44,400
a shorthand for it you need to go read

00:53:42,300 --> 00:53:47,340
that go read through that report back

00:53:44,400 --> 00:53:49,020
figure out what you've done wrong etc so

00:53:47,340 --> 00:53:52,680
we're going to ship the same ones with

00:53:49,020 --> 00:53:54,480
the same number not all of them still

00:53:52,680 --> 00:53:55,980
matter in the public some of them don't

00:53:54,480 --> 00:53:58,590
even matter internally so there will be

00:53:55,980 --> 00:54:01,020
holes in the numbering system I hope you

00:53:58,590 --> 00:54:04,170
can all get over that I don't want to

00:54:01,020 --> 00:54:05,370
learn another set of numbers this is

00:54:04,170 --> 00:54:06,690
largely compatible with the core

00:54:05,370 --> 00:54:08,550
guidelines and in a couple places where

00:54:06,690 --> 00:54:11,250
we find that it's not quite in line I

00:54:08,550 --> 00:54:13,920
really look forward to working out under

00:54:11,250 --> 00:54:18,240
what circumstances is that guidance the

00:54:13,920 --> 00:54:20,760
correct guidance or just fixing ours and

00:54:18,240 --> 00:54:22,200
then there's standards alternatives how

00:54:20,760 --> 00:54:26,160
to alienate my friends on the committee

00:54:22,200 --> 00:54:28,470
I promise it's not actually that bad so

00:54:26,160 --> 00:54:30,390
the standard design priorities for the

00:54:28,470 --> 00:54:32,040
standard you do not pay for what you do

00:54:30,390 --> 00:54:34,800
not use I think this has been mentioned

00:54:32,040 --> 00:54:39,810
5 times and talks that I've been to so

00:54:34,800 --> 00:54:41,010
far this conference and further honestly

00:54:39,810 --> 00:54:44,910
I'm not sure the committee agrees on a

00:54:41,010 --> 00:54:46,830
whole lot more than that but as far as

00:54:44,910 --> 00:54:48,630
it goes this is a really important

00:54:46,830 --> 00:54:50,520
guiding principle for the standard and

00:54:48,630 --> 00:54:52,980
it is a big big part of why the standard

00:54:50,520 --> 00:54:56,460
works this is a very good thing this is

00:54:52,980 --> 00:54:58,650
the right thing a side effect of that is

00:54:56,460 --> 00:55:00,600
for any problem space that the standard

00:54:58,650 --> 00:55:02,970
is solving if there is runtime overhead

00:55:00,600 --> 00:55:05,640
for some design or feature on a

00:55:02,970 --> 00:55:07,410
reasonable platform or workload we the

00:55:05,640 --> 00:55:09,890
committee will find an option to avoid

00:55:07,410 --> 00:55:12,330
it we will design a different solution

00:55:09,890 --> 00:55:15,530
so let's look at the example stood

00:55:12,330 --> 00:55:17,060
chrono chrono needs to work just

00:55:15,530 --> 00:55:20,570
as well if you are in high-frequency

00:55:17,060 --> 00:55:23,390
trading where the CPU costs of time

00:55:20,570 --> 00:55:26,780
operations on nanoseconds actually start

00:55:23,390 --> 00:55:28,700
to dominate the discussion chrono should

00:55:26,780 --> 00:55:30,650
also work on an embedded microcontroller

00:55:28,700 --> 00:55:33,260
that has sixteen second or 16-bit

00:55:30,650 --> 00:55:35,630
one-second ticks clearly the

00:55:33,260 --> 00:55:38,390
microcontroller cannot afford the

00:55:35,630 --> 00:55:40,130
precision and requirements of the high

00:55:38,390 --> 00:55:43,730
frequency traders nor would the

00:55:40,130 --> 00:55:46,970
microcontroller system even remotely

00:55:43,730 --> 00:55:50,770
suffice for the traders and so they C++

00:55:46,970 --> 00:55:54,440
solution is of course we add a template

00:55:50,770 --> 00:55:56,030
our compromises class templates by

00:55:54,440 --> 00:55:57,980
default the representation for a

00:55:56,030 --> 00:56:00,110
duration and time point is a signed

00:55:57,980 --> 00:56:01,970
integer this leads directly to things

00:56:00,110 --> 00:56:04,100
like by default you can't express an

00:56:01,970 --> 00:56:05,300
infinite duration and there is undefined

00:56:04,100 --> 00:56:08,180
behavior on overflows

00:56:05,300 --> 00:56:11,690
that is what signed integers do and this

00:56:08,180 --> 00:56:13,340
makes perfect complete sense in a world

00:56:11,690 --> 00:56:15,380
where you cannot afford any additional

00:56:13,340 --> 00:56:18,040
expense or the safety checks don't

00:56:15,380 --> 00:56:20,630
matter but this is clearly not the only

00:56:18,040 --> 00:56:22,670
sensible set of design priorities or

00:56:20,630 --> 00:56:24,770
design constraints what if we wanted

00:56:22,670 --> 00:56:27,230
something other than don't pay for what

00:56:24,770 --> 00:56:30,020
you don't use what if we prioritize

00:56:27,230 --> 00:56:34,040
safety clarity ease of use and still

00:56:30,020 --> 00:56:36,740
didn't want to write in Java so we're

00:56:34,040 --> 00:56:39,290
shipping time and duration these are

00:56:36,740 --> 00:56:41,360
classes not templates they happen to be

00:56:39,290 --> 00:56:43,520
I think 96 bits right now but the

00:56:41,360 --> 00:56:45,680
representation could change

00:56:43,520 --> 00:56:47,510
they have saturating arithmetic they

00:56:45,680 --> 00:56:50,540
have infinite future infinite duration

00:56:47,510 --> 00:56:54,740
if you do math on an infinite it stays

00:56:50,540 --> 00:56:57,380
infinite it's never undefined and asking

00:56:54,740 --> 00:56:58,790
for what time is it now is usual but the

00:56:57,380 --> 00:57:02,270
last time I ran a benchmark on this it

00:56:58,790 --> 00:57:08,210
was twice as fast we've optimized

00:57:02,270 --> 00:57:10,190
because we run a lot of stuff we also

00:57:08,210 --> 00:57:13,760
have slight design differences for mutex

00:57:10,190 --> 00:57:17,210
are mutex has a little bit more stuff

00:57:13,760 --> 00:57:20,150
built into it it has reader/writer locks

00:57:17,210 --> 00:57:23,900
so the standard supports mutex and

00:57:20,150 --> 00:57:25,310
shared mutex once you have built your

00:57:23,900 --> 00:57:27,170
whole system and you discover that you

00:57:25,310 --> 00:57:28,740
have contention on that mutex and that

00:57:27,170 --> 00:57:31,380
you would be well-served

00:57:28,740 --> 00:57:33,510
changing it to a read lock instead of an

00:57:31,380 --> 00:57:36,600
exclusive lock then you have to go

00:57:33,510 --> 00:57:39,720
thread shared mutex through all of those

00:57:36,600 --> 00:57:42,930
api's to make sure that you can take a

00:57:39,720 --> 00:57:45,270
shared lock for us it's just one type

00:57:42,930 --> 00:57:49,320
there is a little bit of overhead on

00:57:45,270 --> 00:57:52,560
that but it does make the ability to use

00:57:49,320 --> 00:57:55,470
that feature much more readily available

00:57:52,560 --> 00:57:57,210
you don't have to do API impacting

00:57:55,470 --> 00:57:58,619
refactorings you just have to go find

00:57:57,210 --> 00:58:02,630
the places where you're only grabbing it

00:57:58,619 --> 00:58:05,010
for read change it to a read lock in

00:58:02,630 --> 00:58:07,290
debug mode we have deadlock detection

00:58:05,010 --> 00:58:08,580
built in this is theoretical deadlock

00:58:07,290 --> 00:58:10,410
detection not practical deadlock

00:58:08,580 --> 00:58:13,260
detection it's not oh hey you seem to be

00:58:10,410 --> 00:58:16,260
hung it's we are doing the graph theory

00:58:13,260 --> 00:58:19,560
to identify what order you're mutexes

00:58:16,260 --> 00:58:22,560
are taken in by any given thread and if

00:58:19,560 --> 00:58:24,420
one thread grabs a and then B and the

00:58:22,560 --> 00:58:27,300
other thread grabs B and then a in

00:58:24,420 --> 00:58:30,180
theory over time some time you're gonna

00:58:27,300 --> 00:58:32,940
deadlock we just notify you of that in

00:58:30,180 --> 00:58:36,270
debug mode and it also has a slightly

00:58:32,940 --> 00:58:37,980
harder to misuse API notice if you're

00:58:36,270 --> 00:58:40,560
using the standard mutex you have to

00:58:37,980 --> 00:58:42,720
have a separate condition variable so

00:58:40,560 --> 00:58:45,410
lock is a mutex cv is a condition

00:58:42,720 --> 00:58:47,850
variable and you specifically have to

00:58:45,410 --> 00:58:52,140
trigger something on the condition

00:58:47,850 --> 00:58:55,430
variable to say hey done absolute x note

00:58:52,140 --> 00:58:58,680
the major differences in that finish

00:58:55,430 --> 00:59:02,369
absol mutex when you unlock the mutex

00:58:58,680 --> 00:59:04,020
says is anyone waiting can I check any

00:59:02,369 --> 00:59:06,780
of these conditions and then it goes and

00:59:04,020 --> 00:59:08,310
evaluates the condition you can't it's

00:59:06,780 --> 00:59:15,480
harder to misuse because you can't

00:59:08,310 --> 00:59:18,590
forget to signal which is kind of nice a

00:59:15,480 --> 00:59:22,080
build input there are very very few

00:59:18,590 --> 00:59:22,800
flags to the build for abseil we try to

00:59:22,080 --> 00:59:25,560
intuit

00:59:22,800 --> 00:59:27,660
everything from compiler inputs things

00:59:25,560 --> 00:59:28,800
of things that are provided by your tool

00:59:27,660 --> 00:59:32,820
chain not things that your user

00:59:28,800 --> 00:59:35,490
specified one that we do have is absolu

00:59:32,820 --> 00:59:37,650
cater know through the standard go back

00:59:35,490 --> 00:59:40,320
wants to be applicable everywhere but

00:59:37,650 --> 00:59:41,800
has also very hesitant to allow the

00:59:40,320 --> 00:59:44,080
possibility of build mode

00:59:41,800 --> 00:59:47,830
at the standards level I'm gonna be

00:59:44,080 --> 00:59:50,350
pragmatic in some cases the result isn't

00:59:47,830 --> 00:59:52,960
entirely satisfying so many platforms

00:59:50,350 --> 00:59:55,180
don't have throwing allocation failure

00:59:52,960 --> 00:59:57,460
if you allocate there's no memory

00:59:55,180 --> 00:59:58,900
available your process crashes or the

00:59:57,460 --> 01:00:01,120
operating system in killer starts

00:59:58,900 --> 01:00:02,770
killing off something else however

01:00:01,120 --> 01:00:05,050
because the standard allows for the

01:00:02,770 --> 01:00:08,620
possibility that all allocation is an

01:00:05,050 --> 01:00:10,900
exception any type that may allocate

01:00:08,620 --> 01:00:14,110
during move construction can't be no

01:00:10,900 --> 01:00:18,160
except vectors of all of those types are

01:00:14,110 --> 01:00:21,640
slower to resize using a vector of a

01:00:18,160 --> 01:00:23,890
type on a platform where you aren't

01:00:21,640 --> 01:00:26,070
actually going to throw every time that

01:00:23,890 --> 01:00:28,450
you resize that vector you are paying

01:00:26,070 --> 01:00:30,850
abseil recognizes that this is annoying

01:00:28,450 --> 01:00:33,340
and provides build system hooks so you

01:00:30,850 --> 01:00:35,920
can define centrally does my default

01:00:33,340 --> 01:00:38,200
allocator throat and guidance for how

01:00:35,920 --> 01:00:41,200
you can tag your own move constructors

01:00:38,200 --> 01:00:43,390
accordingly then if you build on an on

01:00:41,200 --> 01:00:45,820
throwing platform vectors of those types

01:00:43,390 --> 01:00:48,010
just work better and on throwing

01:00:45,820 --> 01:00:49,960
platforms it's all still good and

01:00:48,010 --> 01:00:52,300
compatible and correct we aren't saying

01:00:49,960 --> 01:00:54,130
that you can't work on a platform the

01:00:52,300 --> 01:00:56,350
throws we're just saying that many of

01:00:54,130 --> 01:00:58,750
you aren't on one and maybe you should

01:00:56,350 --> 01:01:02,830
have a more effective efficient vector

01:00:58,750 --> 01:01:05,380
resize we are not competing with the

01:01:02,830 --> 01:01:08,110
standard standard is still much bigger

01:01:05,380 --> 01:01:09,460
these aren't better designs these are

01:01:08,110 --> 01:01:10,810
designs resulting from different

01:01:09,460 --> 01:01:13,210
priorities and different engineering

01:01:10,810 --> 01:01:15,220
legacies you should decide which set of

01:01:13,210 --> 01:01:17,290
priorities works for you and standard is

01:01:15,220 --> 01:01:20,290
still unquestionably the right thing for

01:01:17,290 --> 01:01:22,300
interoperability that's a brief

01:01:20,290 --> 01:01:24,460
introduction for apps now before we wrap

01:01:22,300 --> 01:01:26,740
up let's circle back around and get kind

01:01:24,460 --> 01:01:28,930
of the big picture with abseil as an

01:01:26,740 --> 01:01:31,540
example let's consider what makes c++

01:01:28,930 --> 01:01:34,990
particularly well-suited or not for live

01:01:31,540 --> 01:01:37,240
at head title of the talk after all we

01:01:34,990 --> 01:01:40,360
have some challenges we don't have

01:01:37,240 --> 01:01:43,600
standard build flags or build modes the

01:01:40,360 --> 01:01:45,070
one definition rule makes pre building

01:01:43,600 --> 01:01:47,770
anything with potentially different

01:01:45,070 --> 01:01:50,500
build configuration very dangerous very

01:01:47,770 --> 01:01:52,210
bad taken together these mean that

01:01:50,500 --> 01:01:55,000
source distribution is pretty common

01:01:52,210 --> 01:01:55,630
and while these technical challenges in

01:01:55,000 --> 01:01:57,670
general

01:01:55,630 --> 01:01:59,950
every challenge is an opportunity and

01:01:57,670 --> 01:02:02,619
the result of source distribution being

01:01:59,950 --> 01:02:05,170
as technically necessary as it is in C++

01:02:02,619 --> 01:02:09,609
means that live at head is may be more

01:02:05,170 --> 01:02:11,200
useful necessary and impactful I also

01:02:09,609 --> 01:02:13,569
think it's the case that C++ is a

01:02:11,200 --> 01:02:15,400
particularly challenging language maybe

01:02:13,569 --> 01:02:17,440
it is because I am so steeped in it

01:02:15,400 --> 01:02:20,140
but to me it feels like other languages

01:02:17,440 --> 01:02:22,599
provide fewer surprising mechanisms for

01:02:20,140 --> 01:02:24,849
a change to break a remote user like if

01:02:22,599 --> 01:02:27,069
we were doing abseil in Java we wouldn't

01:02:24,849 --> 01:02:29,650
have rules like don't depend on ADL or

01:02:27,069 --> 01:02:31,450
don't use the global namespace I'm not

01:02:29,650 --> 01:02:34,210
sure there's Java equivalents that have

01:02:31,450 --> 01:02:36,400
the same language level subtlety maybe

01:02:34,210 --> 01:02:37,960
they do maybe I'm just not up enough in

01:02:36,400 --> 01:02:40,690
Java to know where all of this the

01:02:37,960 --> 01:02:44,920
pitfalls lie but by reputation I do

01:02:40,690 --> 01:02:47,410
suspect that we're special here this all

01:02:44,920 --> 01:02:49,839
means that we have to be a little bit

01:02:47,410 --> 01:02:53,109
more clear about what we require from

01:02:49,839 --> 01:02:54,579
users also on the downside the lack of a

01:02:53,109 --> 01:02:55,900
standard build system does make all of

01:02:54,579 --> 01:02:59,799
this more challenging than it would be

01:02:55,900 --> 01:03:02,109
otherwise the upside we don't have a

01:02:59,799 --> 01:03:04,119
standard package manager something like

01:03:02,109 --> 01:03:07,479
a live at head world is not gonna fly

01:03:04,119 --> 01:03:09,940
nearly as well in Python where the

01:03:07,479 --> 01:03:11,799
community has completely formed around

01:03:09,940 --> 01:03:15,640
this is the way that we do dependencies

01:03:11,799 --> 01:03:17,799
in package management we do have good

01:03:15,640 --> 01:03:20,559
and consistent unit tests according to a

01:03:17,799 --> 01:03:22,239
recent Stack Overflow survey for C++ if

01:03:20,559 --> 01:03:24,400
you take Google test and boost test that

01:03:22,239 --> 01:03:28,450
covers about 75% of unit test framework

01:03:24,400 --> 01:03:31,930
usage which is nice because it means you

01:03:28,450 --> 01:03:34,180
the non-expert can run the tests for a

01:03:31,930 --> 01:03:35,589
thing that broke without having to know

01:03:34,180 --> 01:03:37,269
a whole lot about how do I even run

01:03:35,589 --> 01:03:41,440
these tests there's only a couple

01:03:37,269 --> 01:03:43,839
options and of course in order to make

01:03:41,440 --> 01:03:45,279
tooling work we need good tooling the

01:03:43,839 --> 01:03:46,960
things that we do these days on a pretty

01:03:45,279 --> 01:03:50,019
regular basis would have been waved off

01:03:46,960 --> 01:03:51,460
as clearly impossible ten years ago it

01:03:50,019 --> 01:03:53,140
is still not perfect we're missing

01:03:51,460 --> 01:03:55,960
off-the-shelf support for some common

01:03:53,140 --> 01:03:57,190
patterns but it's all incremental things

01:03:55,960 --> 01:03:59,890
that are missing not the core

01:03:57,190 --> 01:04:01,839
revolutionary tech it's like we've

01:03:59,890 --> 01:04:03,670
invented cold fusion we just haven't

01:04:01,839 --> 01:04:06,880
quite figured out how to rig it up to

01:04:03,670 --> 01:04:08,400
the power grid or maybe we've got cold

01:04:06,880 --> 01:04:10,630
fusion but it needs a slightly different

01:04:08,400 --> 01:04:12,640
distribution network and so we need to

01:04:10,630 --> 01:04:16,049
build that out and demonstrate demand at

01:04:12,640 --> 01:04:19,059
the same time and so the call to action

01:04:16,049 --> 01:04:21,729
concretely what does it take to push us

01:04:19,059 --> 01:04:25,469
as an industry and a community from

01:04:21,729 --> 01:04:28,150
where we are to a live at head world I

01:04:25,469 --> 01:04:30,759
need you to consider engineering versus

01:04:28,150 --> 01:04:33,009
programming when you're doing a thing

01:04:30,759 --> 01:04:34,869
does that thing what is the lifespan of

01:04:33,009 --> 01:04:36,670
that thing does that need to live

01:04:34,869 --> 01:04:40,059
indefinitely or does that need to live

01:04:36,670 --> 01:04:41,799
until Thursday you need to be aware that

01:04:40,059 --> 01:04:44,170
there's a difference between those and

01:04:41,799 --> 01:04:46,650
you need to behave differently I said in

01:04:44,170 --> 01:04:48,700
a talk over the summer

01:04:46,650 --> 01:04:51,099
computer programming right now is one of

01:04:48,700 --> 01:04:54,009
the only domains I know of where there's

01:04:51,099 --> 01:04:56,650
something like a four order of magnitude

01:04:54,009 --> 01:04:58,450
difference between how short something

01:04:56,650 --> 01:05:01,059
might live and how long something might

01:04:58,450 --> 01:05:02,349
live right it is entirely possible that

01:05:01,059 --> 01:05:04,749
you write a thing and you are done with

01:05:02,349 --> 01:05:06,309
it the first time it runs and it is

01:05:04,749 --> 01:05:10,390
entirely possible that you write a thing

01:05:06,309 --> 01:05:13,479
and it lives for 50 years it is insanity

01:05:10,390 --> 01:05:15,460
for us to believe that the same rules

01:05:13,479 --> 01:05:16,979
and guidance and principles apply on

01:05:15,460 --> 01:05:20,579
both ends of that spectrum

01:05:16,979 --> 01:05:23,680
please be aware of what you are doing

01:05:20,579 --> 01:05:25,390
understand your dependencies what does

01:05:23,680 --> 01:05:30,479
the standard provide what does the

01:05:25,390 --> 01:05:34,420
standard ask of you behave accordingly

01:05:30,479 --> 01:05:35,950
right well behaved code did this I need

01:05:34,420 --> 01:05:37,960
a better term for this I really sort of

01:05:35,950 --> 01:05:40,739
wanted it to be up to code but that was

01:05:37,960 --> 01:05:40,739
confusing

01:05:40,769 --> 01:05:46,479
use the up-to-date versions of things

01:05:43,109 --> 01:05:50,319
alright don't pin to some six month old

01:05:46,479 --> 01:05:55,390
dependency if you don't need to apply

01:05:50,319 --> 01:05:57,670
tools when provided write tests if you

01:05:55,390 --> 01:06:00,249
can do all of this if we can change the

01:05:57,670 --> 01:06:03,700
way we conceptualize change especially

01:06:00,249 --> 01:06:05,559
this ridiculous idea of breaking changes

01:06:03,700 --> 01:06:07,960
if we can understand the engineering

01:06:05,559 --> 01:06:09,940
quality of libraries that we depend on

01:06:07,960 --> 01:06:12,609
rather than just the programming

01:06:09,940 --> 01:06:16,839
sufficiency we can find a far better

01:06:12,609 --> 01:06:19,269
world as users if you help us by living

01:06:16,839 --> 01:06:20,580
it head when you can cooperating with us

01:06:19,269 --> 01:06:23,630
as we figure this out

01:06:20,580 --> 01:06:26,880
we'll help lead you to a better world as

01:06:23,630 --> 01:06:29,940
library authors if you follow these same

01:06:26,880 --> 01:06:32,400
ideals tell your users what to expect

01:06:29,940 --> 01:06:34,830
make change carefully and make it easy

01:06:32,400 --> 01:06:36,810
to work with will help lead you to a

01:06:34,830 --> 01:06:39,030
better world where you can make the

01:06:36,810 --> 01:06:41,790
changes you desire without harming your

01:06:39,030 --> 01:06:44,640
users it is going to be a bumpy road to

01:06:41,790 --> 01:06:47,250
get there change is not easy but I have

01:06:44,640 --> 01:06:49,980
been saying for years it is important

01:06:47,250 --> 01:06:52,170
that it is possible that is true for

01:06:49,980 --> 01:06:54,180
code and that is true for communities

01:06:52,170 --> 01:06:57,030
and I hope it can be true for this one

01:06:54,180 --> 01:06:59,970
and of course abseil is no different

01:06:57,030 --> 01:07:02,460
will change - there will be a whole

01:06:59,970 --> 01:07:04,890
bunch of more stuff that comes this is

01:07:02,460 --> 01:07:09,660
just the initial drop my plans go out

01:07:04,890 --> 01:07:11,970
probably at least three years while you

01:07:09,660 --> 01:07:14,700
are still here I really recommend sort

01:07:11,970 --> 01:07:16,650
of spiritual follow-up talks Matt Kula

01:07:14,700 --> 01:07:18,360
khandhas I mentioned earlier is talking

01:07:16,650 --> 01:07:20,910
about Google and hash tables on

01:07:18,360 --> 01:07:23,880
Wednesday from my team John Cohen is

01:07:20,910 --> 01:07:26,130
talking about what it takes to move to

01:07:23,880 --> 01:07:29,130
rename a type we've learned a little bit

01:07:26,130 --> 01:07:31,470
about that in the last year Gennady

01:07:29,130 --> 01:07:34,350
Rosenthal will talk about a bi issues

01:07:31,470 --> 01:07:36,030
and part of why it is so important that

01:07:34,350 --> 01:07:38,190
you not depend on a precompiled

01:07:36,030 --> 01:07:40,910
representation of this code and also

01:07:38,190 --> 01:07:44,640
today I will give a hands-on with abseil

01:07:40,910 --> 01:07:47,040
assuming I'm still conscious which

01:07:44,640 --> 01:07:50,220
should answer some of your additional

01:07:47,040 --> 01:07:52,260
questions here I cannot even remotely

01:07:50,220 --> 01:07:54,330
claim the lion's share of the

01:07:52,260 --> 01:07:57,000
responsibility for this this is the work

01:07:54,330 --> 01:08:00,080
of many fine people thank you all so

01:07:57,000 --> 01:08:00,080
very much

01:08:05,890 --> 01:08:12,940
and volunteers not quite on my team some

01:08:10,030 --> 01:08:14,800
former team and for those of you from my

01:08:12,940 --> 01:08:16,720
team that are watching this remotely I

01:08:14,800 --> 01:08:19,030
recognize that you have more important

01:08:16,720 --> 01:08:25,780
things going on thank you for bringing

01:08:19,030 --> 01:08:27,400
up the next generation of AB sailors and

01:08:25,780 --> 01:08:33,970
with that I will turn it over to the

01:08:27,400 --> 01:08:36,910
audience for questions it's well-known

01:08:33,970 --> 01:08:40,600
that Google code base does not support

01:08:36,910 --> 01:08:46,770
to use exceptions how well does episode

01:08:40,600 --> 01:08:50,590
play with exceptions it is aspirational

01:08:46,770 --> 01:08:53,350
so by that I specifically mean I'm not

01:08:50,590 --> 01:08:57,070
aware of any glaring places that it's a

01:08:53,350 --> 01:09:00,070
problem if you can identify oh this

01:08:57,070 --> 01:09:01,450
obviously needs to be exception safe and

01:09:00,070 --> 01:09:05,800
currently isn't we will definitely

01:09:01,450 --> 01:09:08,070
accept that patch I a low-level library

01:09:05,800 --> 01:09:13,180
needs to be supportive of all comers

01:09:08,070 --> 01:09:16,720
that said there are places not all

01:09:13,180 --> 01:09:21,820
exceptions are smart if you decide that

01:09:16,720 --> 01:09:23,590
your hash function laughs at you

01:09:21,820 --> 01:09:27,400
there are some things that just are

01:09:23,590 --> 01:09:29,680
completely preposterous and not a good

01:09:27,400 --> 01:09:31,540
design like exceptions should not work

01:09:29,680 --> 01:09:33,310
everywhere they should work in sensible

01:09:31,540 --> 01:09:35,080
places and we'll try to make that work

01:09:33,310 --> 01:09:37,390
but it's going to be sort of a balancing

01:09:35,080 --> 01:09:38,890
act because yeah it's not our area of

01:09:37,390 --> 01:09:44,740
expertise so we'll have to learn from

01:09:38,890 --> 01:09:47,530
you okay thank you for the great talk my

01:09:44,740 --> 01:09:52,060
question is about compatibility and new

01:09:47,530 --> 01:09:55,180
features so unified code syntax also

01:09:52,060 --> 01:09:58,710
known as in different languages as

01:09:55,180 --> 01:10:01,990
extension methods what kind of concerns

01:09:58,710 --> 01:10:05,620
do you think there are on implementing

01:10:01,990 --> 01:10:08,920
them or how could the standard move

01:10:05,620 --> 01:10:12,370
forward to actually have something like

01:10:08,920 --> 01:10:17,800
extension methods so my concern with

01:10:12,370 --> 01:10:19,790
unified syntax initially is specifically

01:10:17,800 --> 01:10:24,920
I don't want you

01:10:19,790 --> 01:10:28,520
extending my types because if I then

01:10:24,920 --> 01:10:30,890
need to add that same API I'm

01:10:28,520 --> 01:10:33,170
constrained by what you did or I'm

01:10:30,890 --> 01:10:35,660
breaking your code or it's a semantic

01:10:33,170 --> 01:10:39,070
change right I would be perfectly

01:10:35,660 --> 01:10:41,510
accepting of unified syntax not as

01:10:39,070 --> 01:10:44,690
arbitrary user gets to arbitrarily

01:10:41,510 --> 01:10:47,870
extend my library I would be perfectly

01:10:44,690 --> 01:10:51,350
happy with unified syntax as you can

01:10:47,870 --> 01:10:53,710
have extension points within the same

01:10:51,350 --> 01:10:57,950
module boundary things like that right

01:10:53,710 --> 01:11:02,810
but I need control over how you use my

01:10:57,950 --> 01:11:04,040
library and the initial proposals for

01:11:02,810 --> 01:11:15,590
unified syntax

01:11:04,040 --> 01:11:17,540
I was concerned okay thank you yeah hi

01:11:15,590 --> 01:11:20,510
you talked about the kinds of guarantees

01:11:17,540 --> 01:11:22,280
that the abseil makes and what you think

01:11:20,510 --> 01:11:25,940
the standard will make and you mentioned

01:11:22,280 --> 01:11:30,650
the notion of a call only interface yes

01:11:25,940 --> 01:11:32,390
so I mean it's quite common in C++ if

01:11:30,650 --> 01:11:34,490
you write you know generic code to have

01:11:32,390 --> 01:11:37,250
to you know check these sort of things

01:11:34,490 --> 01:11:39,320
so basically things like if you wanted

01:11:37,250 --> 01:11:41,420
to check is constructible as opposed to

01:11:39,320 --> 01:11:44,210
actually constructing something that

01:11:41,420 --> 01:11:46,550
wouldn't be covered so basically if

01:11:44,210 --> 01:11:47,570
you're you know an application developer

01:11:46,550 --> 01:11:49,580
but you have to write some piece of

01:11:47,570 --> 01:11:52,460
generic code for your company for your

01:11:49,580 --> 01:11:55,220
use case you have no guarantees at all

01:11:52,460 --> 01:11:58,610
from the standard or from abseil true I

01:11:55,220 --> 01:12:01,250
mean at that point it just sort of makes

01:11:58,610 --> 01:12:03,530
it tempting why why depend on on abseil

01:12:01,250 --> 01:12:05,660
if your generic code doesn't have any

01:12:03,530 --> 01:12:07,490
guarantees just keep writing your own

01:12:05,660 --> 01:12:09,980
generic code all the way down there is

01:12:07,490 --> 01:12:13,550
the question if true and if you want

01:12:09,980 --> 01:12:16,250
control like you it's on you to control

01:12:13,550 --> 01:12:18,170
it but that said there's a difference

01:12:16,250 --> 01:12:20,630
between no guarantee and it's not gonna

01:12:18,170 --> 01:12:22,460
work right if you are checking if it's

01:12:20,630 --> 01:12:25,280
constructible in order to construct it

01:12:22,460 --> 01:12:27,200
and then you construct it that's that's

01:12:25,280 --> 01:12:29,090
one thing if you are checking if it's

01:12:27,200 --> 01:12:30,980
constructible and then you go do a

01:12:29,090 --> 01:12:33,050
computation or some random other thing

01:12:30,980 --> 01:12:35,180
right that's a

01:12:33,050 --> 01:12:41,420
different that's a horse of a different

01:12:35,180 --> 01:12:44,110
color and the issue becomes it is easy

01:12:41,420 --> 01:12:47,060
for us as far easier for us to specify

01:12:44,110 --> 01:12:49,610
there's no guarantees if you if you

01:12:47,060 --> 01:12:54,380
depend on these sort of meta properties

01:12:49,610 --> 01:12:57,680
of things because listing off the things

01:12:54,380 --> 01:12:59,570
that you could potentially use the

01:12:57,680 --> 01:13:02,960
existing behavior for in a way that's

01:12:59,570 --> 01:13:04,850
likely to be fine in the future I don't

01:13:02,960 --> 01:13:08,120
know how to come up with that list right

01:13:04,850 --> 01:13:11,780
and when in doubt like a big part of why

01:13:08,120 --> 01:13:13,910
today is a big deal is I don't get to

01:13:11,780 --> 01:13:16,010
live in my little hobbit hole of

01:13:13,910 --> 01:13:17,570
internal Google anymore like I have to

01:13:16,010 --> 01:13:21,710
participate with the rest of the world

01:13:17,570 --> 01:13:26,300
so if you have like hey I would like to

01:13:21,710 --> 01:13:27,800
depend on this you could ask hey we'll

01:13:26,300 --> 01:13:29,900
send us an email like we'll have a

01:13:27,800 --> 01:13:32,120
discussion be like no you're completely

01:13:29,900 --> 01:13:33,710
insane or yeah I can't actually imagine

01:13:32,120 --> 01:13:37,550
how in practice that's gonna be a

01:13:33,710 --> 01:13:42,350
problem you're fine right but for things

01:13:37,550 --> 01:13:44,780
as complicated as programming it's

01:13:42,350 --> 01:13:47,660
awfully reductive to try to just narrow

01:13:44,780 --> 01:13:49,940
it all down to something that can be

01:13:47,660 --> 01:13:53,390
pithily written in a list all right

01:13:49,940 --> 01:13:53,920
in practice asking is a really good

01:13:53,390 --> 01:13:59,450
answer

01:13:53,920 --> 01:14:03,290
thank you yeah hi as far as I know

01:13:59,450 --> 01:14:07,130
Google has a very large pudding base on

01:14:03,290 --> 01:14:11,330
some of your slides I saw two main like

01:14:07,130 --> 01:14:16,370
plank Emma do you really tutorial quote

01:14:11,330 --> 01:14:19,850
at MapReduce and run clunk at MapReduce

01:14:16,370 --> 01:14:22,940
to make refactoring so the code base is

01:14:19,850 --> 01:14:26,600
I mentioned about 250 million lines of

01:14:22,940 --> 01:14:29,960
Google author and C++ code it is big yes

01:14:26,600 --> 01:14:32,060
the original refactoring tools that

01:14:29,960 --> 01:14:35,360
Chandler initially cobbled together to

01:14:32,060 --> 01:14:37,460
give my team these were mapreduces the

01:14:35,360 --> 01:14:38,690
code base itself is not stored in a

01:14:37,460 --> 01:14:42,580
MapReduce I don't think that's quite

01:14:38,690 --> 01:14:46,460
what you meant but you do basically

01:14:42,580 --> 01:14:48,260
parallel build and run the tool over

01:14:46,460 --> 01:14:51,020
translation unit separately and then

01:14:48,260 --> 01:14:52,460
reduce it down into like to get rid of

01:14:51,020 --> 01:14:54,469
the dupes and headers and things like

01:14:52,460 --> 01:14:56,690
that so you can generate a set of edits

01:14:54,469 --> 01:14:58,550
across the codebase clang amar is not

01:14:56,690 --> 01:15:02,030
going to be what we rely on because the

01:14:58,550 --> 01:15:04,190
MapReduce infrastructure two things one

01:15:02,030 --> 01:15:05,780
the MapReduce infrastructure isn't quite

01:15:04,190 --> 01:15:08,540
the right thing for the rest of the

01:15:05,780 --> 01:15:11,900
world and two largely we wind up doing

01:15:08,540 --> 01:15:15,650
that because our code base is freaking

01:15:11,900 --> 01:15:17,750
bananas huge for most people a clanked

01:15:15,650 --> 01:15:25,010
ID check and run it overnight on your

01:15:17,750 --> 01:15:28,000
code base should be fine since first of

01:15:25,010 --> 01:15:30,890
all thank you for a great talk and about

01:15:28,000 --> 01:15:33,140
Emin author of a third library and I'm

01:15:30,890 --> 01:15:37,670
interested in how to make the upgrades

01:15:33,140 --> 01:15:40,370
easy as you said specifically what do

01:15:37,670 --> 01:15:43,070
you suggest should be in the tools like

01:15:40,370 --> 01:15:45,260
should I provide tools for my users to

01:15:43,070 --> 01:15:51,230
upgrade quickly and how should they work

01:15:45,260 --> 01:15:54,830
or like so is the question how do they

01:15:51,230 --> 01:15:56,810
upgrade like what what version of the

01:15:54,830 --> 01:15:59,000
library is checked in or how do they

01:15:56,810 --> 01:16:02,810
upgrade their usage of the library to an

01:15:59,000 --> 01:16:05,330
incompatible API and the first one what

01:16:02,810 --> 01:16:07,010
do you suggest should be in the tools to

01:16:05,330 --> 01:16:10,040
make it I don't think it's your

01:16:07,010 --> 01:16:12,890
responsibility to provide tools for your

01:16:10,040 --> 01:16:16,370
user changing their version the user

01:16:12,890 --> 01:16:17,600
should know that you are providing

01:16:16,370 --> 01:16:20,870
something that will be stable and

01:16:17,600 --> 01:16:25,460
accurate and over time and should just

01:16:20,870 --> 01:16:26,630
upgrade aggressively live it head so

01:16:25,460 --> 01:16:30,770
what is the purpose of the tools

01:16:26,630 --> 01:16:33,739
actually the tools are for when changes

01:16:30,770 --> 01:16:35,660
to the user's code are necessary in

01:16:33,739 --> 01:16:39,080
order to react to a changing

01:16:35,660 --> 01:16:41,330
implementation or API when they do that

01:16:39,080 --> 01:16:42,800
update mm-hmm right their build will

01:16:41,330 --> 01:16:45,050
break or their their code will not

01:16:42,800 --> 01:16:47,230
execute correctly as a result of some

01:16:45,050 --> 01:16:51,350
change in their underlying dependency

01:16:47,230 --> 01:16:55,190
tool to execute fix their code base move

01:16:51,350 --> 01:16:56,510
on I see yeah and the point is we have a

01:16:55,190 --> 01:16:58,040
quarter of a billion lines of code

01:16:56,510 --> 01:16:58,970
already depending on this when we make a

01:16:58,040 --> 01:17:04,130
change

01:16:58,970 --> 01:17:08,600
have to automate it shocked right okay

01:17:04,130 --> 01:17:13,460
thank you very much do I see both snake

01:17:08,600 --> 01:17:16,250
Kazon Pascal cave in your public API yes

01:17:13,460 --> 01:17:17,930
so we snake case when we are

01:17:16,250 --> 01:17:20,780
specifically trying to match something

01:17:17,930 --> 01:17:24,020
out of the standard and we Pascal case

01:17:20,780 --> 01:17:25,760
or camel case because that's how the

01:17:24,020 --> 01:17:26,120
vast majority of our code is written all

01:17:25,760 --> 01:17:31,370
right

01:17:26,120 --> 01:17:39,220
well already ruined no no it's okay it

01:17:31,370 --> 01:17:41,930
was just a joke thank you yeah we have

01:17:39,220 --> 01:17:45,650
initiative at my company that is quite

01:17:41,930 --> 01:17:50,540
similar to this library where we do

01:17:45,650 --> 01:17:55,550
implement like future standards and some

01:17:50,540 --> 01:17:58,970
proposals more general tools that could

01:17:55,550 --> 01:18:01,610
be used all parts of organization we're

01:17:58,970 --> 01:18:05,330
actually the three people who made most

01:18:01,610 --> 01:18:07,550
of that library or here today but I had

01:18:05,330 --> 01:18:12,020
one more technical question regarding

01:18:07,550 --> 01:18:17,120
your ADL yes requirement do you rely on

01:18:12,020 --> 01:18:20,750
ADL internally in your library generally

01:18:17,120 --> 01:18:22,520
not um there may be a couple places that

01:18:20,750 --> 01:18:25,520
snuck through but I believe that we have

01:18:22,520 --> 01:18:27,470
explicitly qualified everything not

01:18:25,520 --> 01:18:30,640
fully qualified but everything is tagged

01:18:27,470 --> 01:18:32,810
absol partly because we want the

01:18:30,640 --> 01:18:34,700
implementation and usage and testing of

01:18:32,810 --> 01:18:37,040
our code to look like how the user is

01:18:34,700 --> 01:18:44,240
gonna use it so that we know more fully

01:18:37,040 --> 01:18:46,940
like does that look right you gave an

01:18:44,240 --> 01:18:50,450
example of for example pre Xcode eight

01:18:46,940 --> 01:18:52,910
walk around with your outlines in a

01:18:50,450 --> 01:18:56,000
library and you said that you have five

01:18:52,910 --> 01:18:57,830
years role for after which you remove it

01:18:56,000 --> 01:18:59,500
I wonder how are you going to maintain

01:18:57,830 --> 01:19:01,820
it because it should be enormous a

01:18:59,500 --> 01:19:04,100
number of places in the library where

01:19:01,820 --> 01:19:05,690
you have some kind of stuff and it

01:19:04,100 --> 01:19:08,090
should be just like human readable and

01:19:05,690 --> 01:19:10,100
then when you come over it you feel free

01:19:08,090 --> 01:19:12,619
to delete it or you have some automated

01:19:10,100 --> 01:19:14,869
tooling around hey like

01:19:12,619 --> 01:19:16,460
the date has passed and this code is

01:19:14,869 --> 01:19:18,800
automatically eliminated

01:19:16,460 --> 01:19:21,020
there's not enough of those that

01:19:18,800 --> 01:19:24,110
automation is going to ever pay off like

01:19:21,020 --> 01:19:26,420
I think there's probably I don't know 20

01:19:24,110 --> 01:19:27,260
or 30 sort of workarounds that we've got

01:19:26,420 --> 01:19:30,619
in there right now

01:19:27,260 --> 01:19:35,090
for those sorts of random odd little

01:19:30,619 --> 01:19:36,800
technical glitches and spending any

01:19:35,090 --> 01:19:39,199
significant time on automation to work

01:19:36,800 --> 01:19:41,440
around 20 or 30 things it's probably not

01:19:39,199 --> 01:19:44,510
worth it like it's much easier to just

01:19:41,440 --> 01:19:46,219
have a reminder set for five years from

01:19:44,510 --> 01:19:49,040
now and have it pop up in your inbox and

01:19:46,219 --> 01:19:56,630
be like oh hey I get delete 100 lines of

01:19:49,040 --> 01:19:59,239
funky code today cool thank you um so I

01:19:56,630 --> 01:20:02,420
was curious about the ADL thing like a

01:19:59,239 --> 01:20:04,010
lot of operator overloading uses ADL and

01:20:02,420 --> 01:20:07,550
I think you like kind of covered it in

01:20:04,010 --> 01:20:10,909
the talk but like I want to be able to

01:20:07,550 --> 01:20:17,659
like outlet you see out on a string view

01:20:10,909 --> 01:20:20,840
and like that uses ADL so like how do

01:20:17,659 --> 01:20:24,199
you expect to solve that like you I just

01:20:20,840 --> 01:20:27,770
want to see out you don't need to use a

01:20:24,199 --> 01:20:31,190
DL for like function indications

01:20:27,770 --> 01:20:34,219
everything's gonna work fine in the

01:20:31,190 --> 01:20:38,150
normal expected fashion I see out its

01:20:34,219 --> 01:20:42,110
kind of work just fine it is really just

01:20:38,150 --> 01:20:45,199
unqualified calls especially into absol

01:20:42,110 --> 01:20:47,030
where things become a problem so the so

01:20:45,199 --> 01:20:49,010
it's not like don't use ADL it's like

01:20:47,030 --> 01:20:50,780
don't use ADL for function call or don't

01:20:49,010 --> 01:20:52,580
rely on ADL for function calls don't

01:20:50,780 --> 01:20:55,190
rely on a do when you're just being lazy

01:20:52,580 --> 01:20:58,639
if it's an API that specifically isn't

01:20:55,190 --> 01:21:01,849
like necessitates a deal like IO streams

01:20:58,639 --> 01:21:05,480
then yeah like that's sensible like okay

01:21:01,849 --> 01:21:07,520
cool yeah yeah hi yeah I got two

01:21:05,480 --> 01:21:10,489
question number one is Windows a

01:21:07,520 --> 01:21:12,739
supporter platform for you yep all the

01:21:10,489 --> 01:21:13,469
way including stacktrace and stuff nope

01:21:12,739 --> 01:21:19,320
okay

01:21:13,469 --> 01:21:21,150
I will will try it is not our area of

01:21:19,320 --> 01:21:23,309
expertise like one of the things that I

01:21:21,150 --> 01:21:25,469
really like about all of this this is

01:21:23,309 --> 01:21:27,900
the stuff that's running in production

01:21:25,469 --> 01:21:30,630
right this is this is battle tested but

01:21:27,900 --> 01:21:33,360
much like you know any given army in a

01:21:30,630 --> 01:21:34,440
battle right is battle-hardened against

01:21:33,360 --> 01:21:37,199
the things that they've experienced

01:21:34,440 --> 01:21:40,010
right like the Crusaders battle-hardened

01:21:37,199 --> 01:21:44,550
won't matter when the Martians show up

01:21:40,010 --> 01:21:46,380
right so that there are gonna be things

01:21:44,550 --> 01:21:51,030
that surprised us when we branch out

01:21:46,380 --> 01:21:53,909
into deeper and more lasting ties onto

01:21:51,030 --> 01:21:56,099
other platforms and we'll try to work

01:21:53,909 --> 01:21:58,949
around it okay and the second question

01:21:56,099 --> 01:22:01,229
is and now you advocate providing tools

01:21:58,949 --> 01:22:03,510
for library vendors so that they can

01:22:01,229 --> 01:22:05,519
upgrade the users does that mean that

01:22:03,510 --> 01:22:07,409
every one of us has to provide like a

01:22:05,519 --> 01:22:12,539
clank plug-in or something or do you see

01:22:07,409 --> 01:22:17,670
that's working I think the the tooling

01:22:12,539 --> 01:22:21,659
story is evolving for us like our bread

01:22:17,670 --> 01:22:25,650
and butter is client ID plugins I really

01:22:21,659 --> 01:22:28,079
hope that this Spurs more innovation in

01:22:25,650 --> 01:22:29,969
having other platforms that do that I

01:22:28,079 --> 01:22:32,249
recognize that there are going to be

01:22:29,969 --> 01:22:33,659
some windows code bases that still just

01:22:32,249 --> 01:22:36,659
can't build with clang for whatever

01:22:33,659 --> 01:22:39,690
reason and we're gonna have to negotiate

01:22:36,659 --> 01:22:42,329
all of that but a big part of all of

01:22:39,690 --> 01:22:47,130
this is a lot of what we're currently

01:22:42,329 --> 01:22:49,949
doing is in theory one thing and in

01:22:47,130 --> 01:22:53,460
practice the world is a very different

01:22:49,949 --> 01:22:55,949
place and so I'm just gonna try to push

01:22:53,460 --> 01:22:57,869
it all down into let's just be practical

01:22:55,949 --> 01:23:01,019
let's just do these things in practice

01:22:57,869 --> 01:23:03,749
and see how it works and if it's

01:23:01,019 --> 01:23:06,749
insufficient then we'll know where to

01:23:03,749 --> 01:23:10,530
invest more resources going forward okay

01:23:06,749 --> 01:23:12,389
thank you yeah okay so we really would

01:23:10,530 --> 01:23:14,699
hate and we do not pin ourselves to a

01:23:12,389 --> 01:23:16,739
particular version of a library and

01:23:14,699 --> 01:23:20,760
rebuild from sources well it's great but

01:23:16,739 --> 01:23:26,280
what about build times by a mother or by

01:23:20,760 --> 01:23:26,910
another CPU you use a AWS like I don't

01:23:26,280 --> 01:23:29,450
know like

01:23:26,910 --> 01:23:32,400
this is also a place where our

01:23:29,450 --> 01:23:35,580
priorities are going to change are going

01:23:32,400 --> 01:23:39,990
to show through right our experiences we

01:23:35,580 --> 01:23:42,660
have a really massive build farm and I

01:23:39,990 --> 01:23:44,910
don't care about you adding an extra

01:23:42,660 --> 01:23:47,190
include and I know that that's not

01:23:44,910 --> 01:23:49,350
everyone's experience it may turn out

01:23:47,190 --> 01:23:52,130
that that makes it in palatable but

01:23:49,350 --> 01:23:54,690
practically speaking build times are an

01:23:52,130 --> 01:23:55,920
annoyance that is also a solved

01:23:54,690 --> 01:23:59,850
technical problem and there's one of

01:23:55,920 --> 01:24:03,390
resources maintenance of a library and

01:23:59,850 --> 01:24:05,400
an ecosystem is not a solved technical

01:24:03,390 --> 01:24:08,760
problem and we need to claw back some of

01:24:05,400 --> 01:24:12,720
that in order to solve it or have a

01:24:08,760 --> 01:24:15,420
prayer of solving it so we'll see that

01:24:12,720 --> 01:24:19,500
said I can build everything on abseil on

01:24:15,420 --> 01:24:20,970
a laptop in you know 30 seconds so so

01:24:19,500 --> 01:24:23,130
effectively us saying that build times

01:24:20,970 --> 01:24:26,250
is not on the top list of your

01:24:23,130 --> 01:24:28,440
priorities no build times is a

01:24:26,250 --> 01:24:29,850
programming problem I'm trying to plan

01:24:28,440 --> 01:24:32,600
for how does this work for the next 10

01:24:29,850 --> 01:24:40,050
years that's an engineering problem

01:24:32,600 --> 01:24:43,020
sorry okay thanks I got a quite similar

01:24:40,050 --> 01:24:44,940
question even if we can resolve the the

01:24:43,020 --> 01:24:46,770
build time problem because I don't know

01:24:44,940 --> 01:24:49,440
we get some infrastructure that has also

01:24:46,770 --> 01:24:51,690
modules there's still the issue of

01:24:49,440 --> 01:24:55,350
software that we release like you know

01:24:51,690 --> 01:24:56,820
not daily but every free month for six

01:24:55,350 --> 01:24:58,500
months and that we have to support for

01:24:56,820 --> 01:25:02,370
five years or even ten years

01:24:58,500 --> 01:25:04,860
can we still live ahead with that maybe

01:25:02,370 --> 01:25:06,720
it's gonna be very like dependent on

01:25:04,860 --> 01:25:09,570
exactly what promises you're making in

01:25:06,720 --> 01:25:12,450
that code it's gonna be dependent on are

01:25:09,570 --> 01:25:13,770
you exporting abseil types through your

01:25:12,450 --> 01:25:18,480
api's because that's a whole different

01:25:13,770 --> 01:25:20,310
world like i there's not a single simple

01:25:18,480 --> 01:25:21,450
answer because fundamentally all of

01:25:20,310 --> 01:25:28,290
these things are really really

01:25:21,450 --> 01:25:31,740
complicated right I say often software

01:25:28,290 --> 01:25:34,860
engineering is the solving the hardest

01:25:31,740 --> 01:25:36,900
current solvable problems right because

01:25:34,860 --> 01:25:38,880
everything else is easy it's already

01:25:36,900 --> 01:25:40,239
been solved and everything that isn't

01:25:38,880 --> 01:25:42,159
quite solvable is

01:25:40,239 --> 01:25:43,449
the other end of the cliff alright so

01:25:42,159 --> 01:25:45,550
everything that we're doing here is

01:25:43,449 --> 01:25:48,249
solving the stuff on that ragged edge

01:25:45,550 --> 01:25:49,929
and we're trying to build better and

01:25:48,249 --> 01:25:52,630
better infrastructure for leaning

01:25:49,929 --> 01:25:55,869
further out the cliff it's not gonna be

01:25:52,630 --> 01:25:58,090
easy there's not a off-the-shelf all

01:25:55,869 --> 01:25:59,860
right but what about I don't know I have

01:25:58,090 --> 01:26:03,789
a bug that I have to fix in a rebuild

01:25:59,860 --> 01:26:06,039
for us five-year old version if you do

01:26:03,789 --> 01:26:08,860
not provide versioning how do I you know

01:26:06,039 --> 01:26:12,249
get you all your stuff and we build a

01:26:08,860 --> 01:26:14,469
roofing from five years ago you should

01:26:12,249 --> 01:26:15,940
in that instance probably pinned to a

01:26:14,469 --> 01:26:17,619
five year old version for your

01:26:15,940 --> 01:26:21,159
five-year-old maintenance thing and

01:26:17,619 --> 01:26:22,570
practically speaking I recognized that

01:26:21,159 --> 01:26:24,369
not everyone is going to be able to pull

01:26:22,570 --> 01:26:27,219
off the whole live it head thing one of

01:26:24,369 --> 01:26:30,360
the things as protobuf and gr pc and etc

01:26:27,219 --> 01:26:33,070
starts depending on us rather than have

01:26:30,360 --> 01:26:35,800
willy-nilly releases of that growing

01:26:33,070 --> 01:26:38,349
dependency chain what i'm gonna do as a

01:26:35,800 --> 01:26:40,329
you know practical nod is every six

01:26:38,349 --> 01:26:42,280
months or so will just tag whatever is

01:26:40,329 --> 01:26:43,659
currently there and say will support

01:26:42,280 --> 01:26:46,329
this for a couple years if anything

01:26:43,659 --> 01:26:48,699
important comes up i don't recommend

01:26:46,329 --> 01:26:52,119
that it doesn't scale but practically

01:26:48,699 --> 01:26:54,429
speaking it's this is a big ship it's

01:26:52,119 --> 01:26:55,719
gonna take a while to steer it yeah i'm

01:26:54,429 --> 01:26:58,840
on bold with death thank you

01:26:55,719 --> 01:27:02,769
yeah and i think we got one more time Oh

01:26:58,840 --> 01:27:05,019
Eric for anyone else that wasn't mine I

01:27:02,769 --> 01:27:07,809
will do a bunch of questions in this

01:27:05,019 --> 01:27:09,849
afternoon session so please take a look

01:27:07,809 --> 01:27:12,340
at the library and come with questions

01:27:09,849 --> 01:27:13,989
and we'll talk then but Eric so first

01:27:12,340 --> 01:27:17,260
congratulations on releasing abseil

01:27:13,989 --> 01:27:18,909
thank you so package managers I think I

01:27:17,260 --> 01:27:21,429
heard you say that you think the lack of

01:27:18,909 --> 01:27:24,699
package managers is actually a boon to

01:27:21,429 --> 01:27:26,260
the live at head philosophy I tend to be

01:27:24,699 --> 01:27:28,090
of the opposite opinion that the lack of

01:27:26,260 --> 01:27:31,780
package management is one of the things

01:27:28,090 --> 01:27:33,969
that hold C++ back so did I hear you

01:27:31,780 --> 01:27:37,059
correctly and do you see the lack of

01:27:33,969 --> 01:27:40,030
package management as a good thing or

01:27:37,059 --> 01:27:43,929
would it be possible to have package

01:27:40,030 --> 01:27:46,179
managers that work in the livid head yes

01:27:43,929 --> 01:27:48,130
I believe there would be like there's

01:27:46,179 --> 01:27:50,440
definitely in theory package management

01:27:48,130 --> 01:27:53,190
systems that work better for livet head

01:27:50,440 --> 01:27:56,970
right if we just do a thing that is

01:27:53,190 --> 01:27:58,890
hey here's some ver again for C++ code

01:27:56,970 --> 01:28:01,140
and if you use this tool chain here's

01:27:58,890 --> 01:28:03,800
pre compiled code and otherwise I guess

01:28:01,140 --> 01:28:06,750
maybe we have source distribution and

01:28:03,800 --> 01:28:08,730
maybe we have compatible build systems

01:28:06,750 --> 01:28:10,050
and I don't know what else lis that's

01:28:08,730 --> 01:28:12,540
not gonna solve anything that's just

01:28:10,050 --> 01:28:16,920
gonna lead us more down this path that I

01:28:12,540 --> 01:28:19,440
don't think works and I think there is a

01:28:16,920 --> 01:28:21,840
solution where like we make it clear

01:28:19,440 --> 01:28:23,970
where does the code live we make it

01:28:21,840 --> 01:28:27,720
clear how to pull it and make it clear

01:28:23,970 --> 01:28:29,220
like what is current and that would be

01:28:27,720 --> 01:28:32,040
great I think that would be a much

01:28:29,220 --> 01:28:33,990
better world so it's not all it's not

01:28:32,040 --> 01:28:36,840
all package management is inherently bad

01:28:33,990 --> 01:28:43,970
it's just the most likely scenarios seem

01:28:36,840 --> 01:28:43,970
like bad ones Thanks yeah thank you all

01:28:49,430 --> 01:28:53,820
bash films can shoot your event with

01:28:51,750 --> 01:28:55,860
multiple cameras linked to presentation

01:28:53,820 --> 01:28:58,470
slides add titles and edit your event

01:28:55,860 --> 01:29:00,480
live for a full broadcast experience how

01:28:58,470 --> 01:29:02,990
is this even working so this is actually

01:29:00,480 --> 01:29:06,660
a more interesting program to you know

01:29:02,990 --> 01:29:08,880
look at it a lot of ways so let's

01:29:06,660 --> 01:29:11,580
profile it give a little bit of time to

01:29:08,880 --> 01:29:14,250
do a profile for us I'll see exactly

01:29:11,580 --> 01:29:16,020
what it is that's making this faster or

01:29:14,250 --> 01:29:18,000
slower based on the different inputs we

01:29:16,020 --> 01:29:19,580
really gain a lot of insight by actually

01:29:18,000 --> 01:29:22,560
looking at the profile like this I

01:29:19,580 --> 01:29:24,270
worked at Sesame Street I got brought on

01:29:22,560 --> 01:29:26,700
to be a writers assistant on a show

01:29:24,270 --> 01:29:28,650
called Sesame Street English which was

01:29:26,700 --> 01:29:31,110
to teach English to kids in China and

01:29:28,650 --> 01:29:33,000
Japan it seems very simple the shows

01:29:31,110 --> 01:29:35,070
that they put together but it's it's

01:29:33,000 --> 01:29:37,590
actually really hard to design a show

01:29:35,070 --> 01:29:41,100
that is not only for young kids but also

01:29:37,590 --> 01:29:42,630
the parents confession like this is

01:29:41,100 --> 01:29:44,520
therapeutic I hope you all get something

01:29:42,630 --> 01:29:47,040
out of this but if you don't the therapy

01:29:44,520 --> 01:29:50,620
will been good for me so thank you

01:29:47,040 --> 01:29:52,780
seven years ago I was working I wasn't

01:29:50,620 --> 01:29:54,520
working through those but my previous

01:29:52,780 --> 01:29:56,560
employer which was large multinational

01:29:54,520 --> 01:29:59,110
investment bank I had what was up to

01:29:56,560 --> 01:30:02,410
that point the worst day of my career

01:29:59,110 --> 01:30:04,360
and then came the anger anger at

01:30:02,410 --> 01:30:07,180
ourselves because we knew we were

01:30:04,360 --> 01:30:10,450
responsible for America's first space

01:30:07,180 --> 01:30:12,280
disaster we wrote two more words into

01:30:10,450 --> 01:30:14,410
our vocabularies mission controllers

01:30:12,280 --> 01:30:15,730
tough and competent tough meeting we

01:30:14,410 --> 01:30:17,500
will never again shirk from our

01:30:15,730 --> 01:30:19,150
responsibilities because we are forever

01:30:17,500 --> 01:30:21,190
accountable for what we do

01:30:19,150 --> 01:30:23,500
competent will never again take anything

01:30:21,190 --> 01:30:25,239
for granted we will never stop learning

01:30:23,500 --> 01:30:27,670
from now and the teams and Mission

01:30:25,239 --> 01:30:30,820
Control will be perfect because as a

01:30:27,670 --> 01:30:35,410
team that must never fail one other

01:30:30,820 --> 01:30:37,960
thing we're all in a very fortunate

01:30:35,410 --> 01:30:40,960
position we've been very lucky in our

01:30:37,960 --> 01:30:43,469
lives and so forth and I think is part

01:30:40,960 --> 01:30:51,250
of the mission it's also good sometimes

01:30:43,469 --> 01:30:54,130
take that portion and get back to make

01:30:51,250 --> 01:30:56,110
sure that you take the platform to use

01:30:54,130 --> 01:30:59,200
it towards worthy causes

01:30:56,110 --> 01:31:01,000
that's good karma that's good stuff in

01:30:59,200 --> 01:31:02,620
the universe we understand that your

01:31:01,000 --> 01:31:05,200
event will have needs that are specific

01:31:02,620 --> 01:31:06,700
to your organization please email or

01:31:05,200 --> 01:31:08,710
call us directly to discuss your

01:31:06,700 --> 01:31:10,600
particular event we look forward to

01:31:08,710 --> 01:31:12,030
discussing your goals and helping make

01:31:10,600 --> 01:31:15,080
your event a success

01:31:12,030 --> 01:31:15,080

YouTube URL: https://www.youtube.com/watch?v=tISy7EJQPzI


