Title: CppCon 2017: Charles Bailey “Enough x86 Assembly to Be Dangerous”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
This tutorial is an introduction to x86 assembly language aimed at C++ programmers of all levels who are interested in what the compiler does with their source code. 

C++ is a programming language that cares about performance. As with any technology, a deep understanding of C++ is helped by knowledge of the layer below, and this means knowledge of assembly language. Knowing what the compiler does with your source code and the limitations under which it operates can inform how you design and write your C++. 

We learn how to generate, inspect and interpret the assembly language for your C++ functions and programs. We take a short tour of common assembly instructions and constructs, and discover why extreme caution should be exercised if we are trying to infer performance characteristics from a simple inspection of assembly code. 

Starting with a simple `operator+` for a user-defined class, we take a look at how interface and implementation choices affect the generated assembly code and observe the effect of copy elisions and related optimizations that compilers commonly perform. 
— 
Charles Bailey: Bloomberg LP, Software Engineer

Charles Bailey is a software developer at Bloomberg LP. He works in Developer Experience Engineering London, where he consults and advises on all aspects of software development. His previous experience in software development has included roles in many areas, including business intelligence, data warehousing, defence, radar and financial derivatives. In addition to C++, Charles has a keen interest in source control in general and Git in particular. He can be found answering questions on both subjects on Stack Overflow and in person.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:04,950
let's get started so my name is Charles

00:00:02,280 --> 00:00:09,090
Bailey I work for Bloomberg in London in

00:00:04,950 --> 00:00:10,530
developer experience so if developers

00:00:09,090 --> 00:00:13,410
have an experience they don't like

00:00:10,530 --> 00:00:17,160
sometimes they come to me today I'm

00:00:13,410 --> 00:00:20,699
going to talk about x86 assembler and my

00:00:17,160 --> 00:00:23,279
first disclaimer is I don't write any as

00:00:20,699 --> 00:00:26,060
part of my job which is a great for

00:00:23,279 --> 00:00:26,060
pretty much everyone

00:00:26,150 --> 00:00:31,320
so yeah unfortunate didn't have very

00:00:29,640 --> 00:00:34,170
much time and I'm going to get onto some

00:00:31,320 --> 00:00:36,200
code as soon as I can so so really with

00:00:34,170 --> 00:00:39,180
this short time it's not really about

00:00:36,200 --> 00:00:43,160
enough x86 assembly to be dangerous but

00:00:39,180 --> 00:00:47,360
enough 86 assembler to be very dangerous

00:00:43,160 --> 00:00:52,980
okay how did I get into assembler well a

00:00:47,360 --> 00:00:55,920
while ago I had an ARM based computer so

00:00:52,980 --> 00:01:00,629
don't if anybody else has used a cone

00:00:55,920 --> 00:01:02,940
Archimedes know right okay so the Acorn

00:01:00,629 --> 00:01:06,150
Archimedes have had four megabytes of

00:01:02,940 --> 00:01:09,570
RAM on to processor or Lisa version that

00:01:06,150 --> 00:01:12,840
I did had and it would had a great basic

00:01:09,570 --> 00:01:15,360
interpreter it was very fast and I had a

00:01:12,840 --> 00:01:18,270
lot of fun as a kid developing for it

00:01:15,360 --> 00:01:21,180
and one of the things I wrote was a maze

00:01:18,270 --> 00:01:23,640
game so you think of 3d graphics these

00:01:21,180 --> 00:01:24,299
days really amazing textures everything

00:01:23,640 --> 00:01:27,320
none of that

00:01:24,299 --> 00:01:30,869
absolutely none of that it was basically

00:01:27,320 --> 00:01:33,990
90-degree corners step you know one unit

00:01:30,869 --> 00:01:35,670
at a time and render a big corridor and

00:01:33,990 --> 00:01:37,619
what I was finding is that my basic

00:01:35,670 --> 00:01:40,020
program was really cool but I had to

00:01:37,619 --> 00:01:41,610
learn about sort of her this cool mode

00:01:40,020 --> 00:01:45,000
shifting technique where you could draw

00:01:41,610 --> 00:01:46,740
on a screen that wasn't visible yet and

00:01:45,000 --> 00:01:47,970
then switch because it was so slow it

00:01:46,740 --> 00:01:52,009
looked a bit funny if you were drawing

00:01:47,970 --> 00:01:52,009
it I actually had a please wait sign I

00:01:52,939 --> 00:01:57,110
also had a subscription to a magazine

00:01:54,840 --> 00:02:01,439
which had lots of interesting stuff and

00:01:57,110 --> 00:02:04,530
some of the stuff was how to write arm

00:02:01,439 --> 00:02:06,450
assembly code and the basic that came

00:02:04,530 --> 00:02:09,720
with the Archimedes actually had an

00:02:06,450 --> 00:02:12,660
assembler with it so I kind of learned

00:02:09,720 --> 00:02:13,440
that and I I didn't rewrite my whole

00:02:12,660 --> 00:02:15,900
program in this

00:02:13,440 --> 00:02:19,500
but I did take that core loop that was

00:02:15,900 --> 00:02:22,590
taking a long time and I translated that

00:02:19,500 --> 00:02:24,360
or transcoded or rewrote it in December

00:02:22,590 --> 00:02:25,140
and the speed increase was just

00:02:24,360 --> 00:02:27,480
phenomenal

00:02:25,140 --> 00:02:29,940
I couldn't believe it so so I was pretty

00:02:27,480 --> 00:02:32,790
hooked there about I hadn't really heard

00:02:29,940 --> 00:02:35,700
of C at this time all C++ but one of

00:02:32,790 --> 00:02:38,730
magazines came with a review of acorns C

00:02:35,700 --> 00:02:40,440
C++ development environment it took me

00:02:38,730 --> 00:02:42,150
about three reads of the article before

00:02:40,440 --> 00:02:44,250
I worked out what a nerve this thing

00:02:42,150 --> 00:02:46,140
Moore's and what a different programming

00:02:44,250 --> 00:02:47,850
language could actually mean but it cost

00:02:46,140 --> 00:02:50,040
hundreds of pounds it's just like

00:02:47,850 --> 00:02:52,800
phenomenal I mean as a kid it's kind of

00:02:50,040 --> 00:02:54,870
like you know I don't understand why you

00:02:52,800 --> 00:02:57,470
buy something and then have to learn a

00:02:54,870 --> 00:03:00,420
new thing to do stuff I can already do

00:02:57,470 --> 00:03:02,040
Sonia so what about history of me and

00:03:00,420 --> 00:03:03,720
assembly language and one thing that's

00:03:02,040 --> 00:03:08,220
really cool it's like arm assembly is

00:03:03,720 --> 00:03:12,570
now back in again cool so why might

00:03:08,220 --> 00:03:13,830
assembly language be dangerous well even

00:03:12,570 --> 00:03:15,600
if you don't think about writing it a

00:03:13,830 --> 00:03:18,750
lot of people kind of a look at

00:03:15,600 --> 00:03:21,600
assembler and kind of scratch their

00:03:18,750 --> 00:03:23,280
heads and and try and interpret

00:03:21,600 --> 00:03:25,080
something from it

00:03:23,280 --> 00:03:27,690
and one of the things to it tonight is

00:03:25,080 --> 00:03:29,190
that assembly language is actually a bit

00:03:27,690 --> 00:03:29,820
further away from object code than you

00:03:29,190 --> 00:03:32,430
might think

00:03:29,820 --> 00:03:35,940
so it's quite easy to write some

00:03:32,430 --> 00:03:38,670
assembler an assumed that the assembler

00:03:35,940 --> 00:03:40,590
just as a mechanical translation and but

00:03:38,670 --> 00:03:42,630
that's not quite true there's quite a

00:03:40,590 --> 00:03:45,360
lot of intelligence still in assemblers

00:03:42,630 --> 00:03:48,209
so if you write to morph

00:03:45,360 --> 00:03:54,530
for example say meaning what mob does in

00:03:48,209 --> 00:04:01,140
most assembly languages yeah sorry and I

00:03:54,530 --> 00:04:04,380
see I it doesn't move it copies this is

00:04:01,140 --> 00:04:06,209
a C++ CV pecan right and we can't tell

00:04:04,380 --> 00:04:09,540
the difference in copy and move so yeah

00:04:06,209 --> 00:04:12,959
but it's just a data copying instruction

00:04:09,540 --> 00:04:16,350
they're actually about 14 major Op codes

00:04:12,959 --> 00:04:17,400
in intel x86 depending on the size of

00:04:16,350 --> 00:04:18,630
the register you are moving where they

00:04:17,400 --> 00:04:24,990
were moving it from memory to memory

00:04:18,630 --> 00:04:28,860
between registers you've got

00:04:24,990 --> 00:04:32,250
MECs instructions sse sse2 three three

00:04:28,860 --> 00:04:35,130
plus or whatever no three eat this at

00:04:32,250 --> 00:04:39,599
the front so there's a whole lot of

00:04:35,130 --> 00:04:41,160
stuff that goes on and so some of those

00:04:39,599 --> 00:04:42,360
have different extensions that means

00:04:41,160 --> 00:04:43,620
something some of them don't and just

00:04:42,360 --> 00:04:45,139
depending the operands the assembler is

00:04:43,620 --> 00:04:46,949
doing kind of quite a lot there

00:04:45,139 --> 00:04:49,050
similarly if you've got a jump

00:04:46,949 --> 00:04:50,460
instructions jumps royce who are kind of

00:04:49,050 --> 00:04:52,169
relative if you're jumping a really

00:04:50,460 --> 00:04:53,880
short distance it can be quite a short

00:04:52,169 --> 00:04:55,470
instruction just a couple of bytes if

00:04:53,880 --> 00:04:57,870
you're jumping a bit further away i

00:04:55,470 --> 00:05:00,720
could be more bytes and the thing is

00:04:57,870 --> 00:05:02,550
it's like the size of your code is now

00:05:00,720 --> 00:05:05,069
depending on on what the assemblers

00:05:02,550 --> 00:05:06,419
chosen for these different things so if

00:05:05,069 --> 00:05:07,919
it's managed to choose some quite short

00:05:06,419 --> 00:05:10,020
instructions and suddenly a jump that

00:05:07,919 --> 00:05:11,880
might have not quite fitted in the

00:05:10,020 --> 00:05:13,680
shortest profitable jump might suddenly

00:05:11,880 --> 00:05:15,960
now fit so so do assemblers need to take

00:05:13,680 --> 00:05:17,699
the second part some of them do so it's

00:05:15,960 --> 00:05:19,770
actually kind of firm it's quite a bit

00:05:17,699 --> 00:05:23,960
of difference between assembly language

00:05:19,770 --> 00:05:26,460
and object code so the next myth is that

00:05:23,960 --> 00:05:28,770
chip manufacturers kind of like hard

00:05:26,460 --> 00:05:32,719
code they're silicone to execute object

00:05:28,770 --> 00:05:36,270
code and and that's just not true so

00:05:32,719 --> 00:05:39,180
it's just mind boggling the complexity

00:05:36,270 --> 00:05:40,800
of like a modern way not even desktop

00:05:39,180 --> 00:05:43,949
even though the modern processes in your

00:05:40,800 --> 00:05:45,900
phone if they're just mind-boggling

00:05:43,949 --> 00:05:48,150
complex and and you can tell that this

00:05:45,900 --> 00:05:50,460
this can't be true because intel

00:05:48,150 --> 00:05:53,659
released micro code updates which chain

00:05:50,460 --> 00:05:57,690
which affect the way that the CPUs

00:05:53,659 --> 00:05:59,219
execute object code so sometimes they

00:05:57,690 --> 00:06:03,180
fix the format's issues sometimes they

00:05:59,219 --> 00:06:06,719
fix genuine bugs fantastically complex

00:06:03,180 --> 00:06:08,330
machines so so really when it comes to

00:06:06,719 --> 00:06:12,120
assembly code you can't kind of like

00:06:08,330 --> 00:06:13,949
look at it and say oh i can see you know

00:06:12,120 --> 00:06:15,419
it's two instructions it's going to be

00:06:13,949 --> 00:06:18,539
pretty performant and there's no

00:06:15,419 --> 00:06:23,370
substitute for measuring still okay what

00:06:18,539 --> 00:06:25,590
about writing assembly code it's like

00:06:23,370 --> 00:06:27,060
there are so many pitfalls it's untrue

00:06:25,590 --> 00:06:29,639
every time I kind of look at some

00:06:27,060 --> 00:06:30,960
compiler generated assembler I normally

00:06:29,639 --> 00:06:32,789
see something that I don't quite

00:06:30,960 --> 00:06:34,830
understand if I do the research I see

00:06:32,789 --> 00:06:36,690
yet another pitfall and these pitfalls

00:06:34,830 --> 00:06:38,970
can be you know performance pitfalls you

00:06:36,690 --> 00:06:40,260
know if you do this it's not as before

00:06:38,970 --> 00:06:43,140
there's another way of doing it which is

00:06:40,260 --> 00:06:44,400
less obvious or you sometimes you

00:06:43,140 --> 00:06:46,710
actually hits you know revisions of

00:06:44,400 --> 00:06:49,410
processes that have have bugs so you

00:06:46,710 --> 00:06:52,530
know if you use a some situations you

00:06:49,410 --> 00:06:55,590
use a single bite kind of return there's

00:06:52,530 --> 00:06:56,790
you know some some pipeline issues that

00:06:55,590 --> 00:06:59,160
mean that that can be missed you can

00:06:56,790 --> 00:07:00,690
actually get kind of bad code so you end

00:06:59,160 --> 00:07:02,070
up having to use like a longer thing

00:07:00,690 --> 00:07:07,920
than is strictly necessary and that can

00:07:02,070 --> 00:07:11,580
seem quite odd so it's so complex that

00:07:07,920 --> 00:07:16,830
the summary is don't but it is quite fun

00:07:11,580 --> 00:07:19,320
to do anyway so I I once was doing a

00:07:16,830 --> 00:07:22,320
challenge against friend and we were

00:07:19,320 --> 00:07:25,200
doing a poker hand evaluation heaters

00:07:22,320 --> 00:07:28,290
and stuff in C and I have a looked

00:07:25,200 --> 00:07:30,360
through all of the SSE instructions I

00:07:28,290 --> 00:07:31,800
could find and I found some really cool

00:07:30,360 --> 00:07:33,930
instructions you can doing parallel ads

00:07:31,800 --> 00:07:36,000
and all's and things and I came up with

00:07:33,930 --> 00:07:37,650
sort of really cool ways to determine

00:07:36,000 --> 00:07:40,230
whether you had you know four of a kind

00:07:37,650 --> 00:07:41,670
or if you had a straight because you can

00:07:40,230 --> 00:07:43,200
collect shift everything across and like

00:07:41,670 --> 00:07:45,090
hand it down and see if you still got

00:07:43,200 --> 00:07:46,500
some nonzero stuff so you can actually

00:07:45,090 --> 00:07:48,030
kind of like design really cool

00:07:46,500 --> 00:07:50,070
algorithms just basically from some of

00:07:48,030 --> 00:07:51,900
these kind of quite a obscure and cool

00:07:50,070 --> 00:07:54,540
op codes the sort of thing that's

00:07:51,900 --> 00:07:56,340
actually kind of difficult to do in C++

00:07:54,540 --> 00:08:02,250
even if you know there are intrinsic sit

00:07:56,340 --> 00:08:03,300
around it's kind of tricky so if you

00:08:02,250 --> 00:08:04,620
shouldn't write it and you've got to be

00:08:03,300 --> 00:08:07,770
careful with reading it and it's not

00:08:04,620 --> 00:08:09,810
substitution for you know actually

00:08:07,770 --> 00:08:12,870
measuring performance why would you want

00:08:09,810 --> 00:08:15,320
to learn assembly language well the

00:08:12,870 --> 00:08:17,490
keynote this morning is kind of like

00:08:15,320 --> 00:08:19,110
Beyonc said it's sort of better than the

00:08:17,490 --> 00:08:20,580
the AI code it's kind of like you should

00:08:19,110 --> 00:08:22,919
really care about what happens in the

00:08:20,580 --> 00:08:24,960
next level down because without some

00:08:22,919 --> 00:08:26,640
understanding of the things that you say

00:08:24,960 --> 00:08:29,520
that the belayer you're working on a

00:08:26,640 --> 00:08:31,890
built on you're not going to have as

00:08:29,520 --> 00:08:36,000
deep understanding of how things work

00:08:31,890 --> 00:08:40,050
what makes things better you can also

00:08:36,000 --> 00:08:44,660
learn about some of the trade-offs that

00:08:40,050 --> 00:08:48,000
happen under the hood based on the code

00:08:44,660 --> 00:08:49,680
that you write so if you if you choose a

00:08:48,000 --> 00:08:51,870
different way of doing something how

00:08:49,680 --> 00:08:52,140
does that affect the performance you

00:08:51,870 --> 00:08:53,930
have

00:08:52,140 --> 00:08:57,720
very careful looking at assembler code

00:08:53,930 --> 00:08:59,670
but in general if you write some C++

00:08:57,720 --> 00:09:01,770
that causes something some code not to

00:08:59,670 --> 00:09:04,320
be generated or not to be executed it's

00:09:01,770 --> 00:09:06,840
generally faster you had to be a little

00:09:04,320 --> 00:09:09,510
bit careful I wrote some assembly once

00:09:06,840 --> 00:09:11,610
and I was removed a totally redundant

00:09:09,510 --> 00:09:14,040
destruction and the performance went

00:09:11,610 --> 00:09:16,050
down I was stuck on that for quite some

00:09:14,040 --> 00:09:19,320
time turned out what I've done is I

00:09:16,050 --> 00:09:21,630
failed to put some data later on in the

00:09:19,320 --> 00:09:22,830
program in in a different section so it

00:09:21,630 --> 00:09:25,680
was actually just straight in the code

00:09:22,830 --> 00:09:27,690
section and in the original version it

00:09:25,680 --> 00:09:30,150
just happened to be aligned so it was a

00:09:27,690 --> 00:09:32,340
really fast load I removed a couple of

00:09:30,150 --> 00:09:34,590
bytes of instructions and suddenly my

00:09:32,340 --> 00:09:36,270
code was misaligned my date who is

00:09:34,590 --> 00:09:39,600
misaligned and the whole thing performed

00:09:36,270 --> 00:09:42,870
worse so it's another another pitfall to

00:09:39,600 --> 00:09:44,400
avoid good thing about about writing

00:09:42,870 --> 00:09:46,080
assembly language you always never have

00:09:44,400 --> 00:09:47,550
to worry about line length so if you've

00:09:46,080 --> 00:09:49,560
in a company which you know 80

00:09:47,550 --> 00:09:51,330
characters assembly it's never gonna

00:09:49,560 --> 00:09:53,580
worry you you never need to feel guilty

00:09:51,330 --> 00:09:55,560
about it using a go-to in fact the go-to

00:09:53,580 --> 00:09:57,090
is so ubiquitous that in arm assembly

00:09:55,560 --> 00:09:58,620
language the OP code is a single

00:09:57,090 --> 00:10:05,400
character it's just the letter B for

00:09:58,620 --> 00:10:08,660
Bloomberg I have a tip branch but mostly

00:10:05,400 --> 00:10:16,500
it's fun oh yeah I I do codes it's fun

00:10:08,660 --> 00:10:17,940
even C++ but cool annoyingly the clock

00:10:16,500 --> 00:10:22,380
on my presenters way I haven't started

00:10:17,940 --> 00:10:23,750
burps pretty soon in order to get on

00:10:22,380 --> 00:10:26,760
code I'm just going to do enough

00:10:23,750 --> 00:10:29,310
architecture to get by and what I mean

00:10:26,760 --> 00:10:33,690
by architecture is just a model of the

00:10:29,310 --> 00:10:35,310
computer as it pertains to the to your

00:10:33,690 --> 00:10:37,350
program at your assembly program that

00:10:35,310 --> 00:10:38,610
you're writing sorry the assembly code

00:10:37,350 --> 00:10:40,110
that you're looking at we're not writing

00:10:38,610 --> 00:10:42,510
assembly code I recommend it against

00:10:40,110 --> 00:10:45,600
their have mic okay so I'm just going to

00:10:42,510 --> 00:10:49,070
talk about three things registers your

00:10:45,600 --> 00:10:54,600
virtual address space and stack so

00:10:49,070 --> 00:10:56,850
registers are very fast memory locations

00:10:54,600 --> 00:10:58,920
and they're the things that can be sort

00:10:56,850 --> 00:11:05,070
of directly manipulate manipulated by

00:10:58,920 --> 00:11:06,060
the CPU there's you can't point to a

00:11:05,070 --> 00:11:08,340
place on silicon

00:11:06,060 --> 00:11:09,960
where they are in these modern CPU

00:11:08,340 --> 00:11:12,120
architectures they do cunning stuff like

00:11:09,960 --> 00:11:13,740
register renaming so some move

00:11:12,120 --> 00:11:17,580
instructions don't actually do anything

00:11:13,740 --> 00:11:19,880
but in in the assembly code you can

00:11:17,580 --> 00:11:21,930
think the register is just a really fast

00:11:19,880 --> 00:11:24,750
location to temporarily store stuff

00:11:21,930 --> 00:11:26,370
there tie to a particular CPU core so if

00:11:24,750 --> 00:11:28,920
you're in a multi-core environment the

00:11:26,370 --> 00:11:30,870
registers are local you can't view

00:11:28,920 --> 00:11:33,660
another CPUs registers they can't be

00:11:30,870 --> 00:11:36,210
interfered with that's kind of part of

00:11:33,660 --> 00:11:42,960
what makes them fast as compared to a

00:11:36,210 --> 00:11:44,310
memory location I'm going to talk 32-bit

00:11:42,960 --> 00:11:47,510
assembler because I'm kind of short on

00:11:44,310 --> 00:11:49,980
time it's simpler there are basically

00:11:47,510 --> 00:11:56,010
eight so-called general-purpose

00:11:49,980 --> 00:11:58,380
registers on the x86 on the 64-bit you

00:11:56,010 --> 00:11:59,760
get all of these but prefixed with an R

00:11:58,380 --> 00:12:01,200
and they're twice as wide and you get

00:11:59,760 --> 00:12:07,530
another eight as well which are

00:12:01,200 --> 00:12:09,540
massively named R 8 through 15 I believe

00:12:07,530 --> 00:12:11,460
yes

00:12:09,540 --> 00:12:14,730
they call general-purpose registers for

00:12:11,460 --> 00:12:17,400
that so that's not really true because

00:12:14,730 --> 00:12:21,900
many of them have special purposes so

00:12:17,400 --> 00:12:24,360
the most obvious one is ESP which is

00:12:21,900 --> 00:12:27,960
extrasensory because no the stack

00:12:24,360 --> 00:12:30,360
pointer you've got to keep that as the

00:12:27,960 --> 00:12:31,920
stack pointer you could just assign it

00:12:30,360 --> 00:12:33,600
another value but that's probably a bad

00:12:31,920 --> 00:12:35,700
idea because there are some instructions

00:12:33,600 --> 00:12:39,360
that implicitly use the set point that

00:12:35,700 --> 00:12:41,880
particularly push and pop and then

00:12:39,360 --> 00:12:43,620
various other variations on push and pop

00:12:41,880 --> 00:12:49,530
if you're going to MMX registers or

00:12:43,620 --> 00:12:51,840
other places EBP the base pointer it's

00:12:49,530 --> 00:12:53,250
used in functions as a record of what

00:12:51,840 --> 00:12:55,200
the stack pointer is when you got into a

00:12:53,250 --> 00:12:56,460
function so you can think of the range

00:12:55,200 --> 00:12:58,500
between the base point from the stack

00:12:56,460 --> 00:13:02,490
pointer as kind of local variables kind

00:12:58,500 --> 00:13:03,330
of it's not quite that strict EAX is

00:13:02,490 --> 00:13:06,890
very important

00:13:03,330 --> 00:13:11,700
that's the used as a return value for

00:13:06,890 --> 00:13:14,160
short return values so in some things

00:13:11,700 --> 00:13:16,890
and then various other ones have got

00:13:14,160 --> 00:13:19,240
kind of specialties like ECX as kind of

00:13:16,890 --> 00:13:21,339
loop constructions that sometimes use it

00:13:19,240 --> 00:13:24,790
some calling conventions use EC X's of

00:13:21,339 --> 00:13:28,199
this pointer but yeah ESP EBP and EAX

00:13:24,790 --> 00:13:30,160
are the kind of most special-purpose

00:13:28,199 --> 00:13:32,439
specification anyway

00:13:30,160 --> 00:13:33,850
and then there are the true set special

00:13:32,439 --> 00:13:36,249
purpose registers there are kind of two

00:13:33,850 --> 00:13:39,339
obvious ones there's the instruction

00:13:36,249 --> 00:13:42,040
pointer which is prefixed with EE or are

00:13:39,339 --> 00:13:45,220
depending on how how within 32 or 64-bit

00:13:42,040 --> 00:13:47,499
mode in arm it's known as PC the program

00:13:45,220 --> 00:13:50,619
counter it's all the same thing you

00:13:47,499 --> 00:13:54,189
can't generally write and read from the

00:13:50,619 --> 00:13:56,170
program counter directly you said you

00:13:54,189 --> 00:14:00,029
use kind of like different instructions

00:13:56,170 --> 00:14:04,329
so if you call a function use a call

00:14:00,029 --> 00:14:07,649
that will cause the instruction pointer

00:14:04,329 --> 00:14:10,209
to to jump to the location that you're

00:14:07,649 --> 00:14:13,809
calling and execution will continue from

00:14:10,209 --> 00:14:16,809
there you can then actually examine the

00:14:13,809 --> 00:14:18,040
stack because when you call or a turn

00:14:16,809 --> 00:14:20,860
address will be put on the stack so you

00:14:18,040 --> 00:14:22,480
can tell what the instruction point of

00:14:20,860 --> 00:14:26,679
what value it had before the call as

00:14:22,480 --> 00:14:30,149
well and then there's Flags registers

00:14:26,679 --> 00:14:30,149
and the flags registers are really about

00:14:31,019 --> 00:14:38,410
the kind of most use conditional stuff

00:14:34,509 --> 00:14:40,509
so flags tend to get set on arithmetic

00:14:38,410 --> 00:14:42,459
and logical operations like and add

00:14:40,509 --> 00:14:44,679
subtract and you can get things like the

00:14:42,459 --> 00:14:47,139
carry flag and the zero flag and then

00:14:44,679 --> 00:14:49,089
you can test them subsequently so there

00:14:47,139 --> 00:14:50,679
are the most popular conditional

00:14:49,089 --> 00:14:52,029
instruction or the jump instructions

00:14:50,679 --> 00:14:54,730
there's a whole lot of jump instructions

00:14:52,029 --> 00:14:59,589
it can be conditional on flags so you

00:14:54,730 --> 00:15:01,720
can test whether some values less than

00:14:59,589 --> 00:15:03,579
another and and and jump to a particular

00:15:01,720 --> 00:15:08,860
location if it is just carry on

00:15:03,579 --> 00:15:11,519
executing if it isn't virtual address

00:15:08,860 --> 00:15:11,519
space so

00:15:14,259 --> 00:15:19,039
pretty much everything that isn't Canova

00:15:17,359 --> 00:15:20,479
registers you read and write from is is

00:15:19,039 --> 00:15:25,119
something in your virtual distress based

00:15:20,479 --> 00:15:27,109
and these days we have a luxury of flat

00:15:25,119 --> 00:15:28,849
memory models and we don't we don't

00:15:27,109 --> 00:15:31,579
segment things up a bit

00:15:28,849 --> 00:15:32,809
so all of your code it tends to get an

00:15:31,579 --> 00:15:34,699
address in your dress space somewhere

00:15:32,809 --> 00:15:37,639
and then other stuff too so dynamically

00:15:34,699 --> 00:15:39,679
out so your code is mapped in from your

00:15:37,639 --> 00:15:42,289
executable so you can static data as

00:15:39,679 --> 00:15:43,879
well then when you dynamically allocate

00:15:42,289 --> 00:15:46,759
stuff that also goes into your address

00:15:43,879 --> 00:15:48,349
space somewhere and then finally the

00:15:46,759 --> 00:15:50,449
stack also lives somewhere in your

00:15:48,349 --> 00:15:54,529
virtual address space and you can just

00:15:50,449 --> 00:15:56,569
read and read and write locations from

00:15:54,529 --> 00:16:01,609
your virtual address space as you see

00:15:56,569 --> 00:16:04,119
fit generally stuff that's mapped in

00:16:01,609 --> 00:16:06,979
from executables can be kind of mapped

00:16:04,119 --> 00:16:08,629
around the address space somewhere stuff

00:16:06,979 --> 00:16:10,399
that's going to been pretty allocated it

00:16:08,629 --> 00:16:12,589
tends to get kind of like map from low

00:16:10,399 --> 00:16:15,439
addresses kind of upwards a bit and the

00:16:12,589 --> 00:16:19,009
stack tends to kind of be a like a high

00:16:15,439 --> 00:16:20,619
address thing and there's lots of kind

00:16:19,009 --> 00:16:24,409
of Headroom to allow the stack to grow

00:16:20,619 --> 00:16:25,729
so talk about stack now as well there

00:16:24,409 --> 00:16:26,929
can be multiple stacks in a program

00:16:25,729 --> 00:16:32,139
because it's specific to a thread of

00:16:26,929 --> 00:16:34,579
execution no double click there

00:16:32,139 --> 00:16:37,459
so you've you've probably kind of looked

00:16:34,579 --> 00:16:38,899
at a call stack in the debugger or at

00:16:37,459 --> 00:16:40,459
least watched some poor luckless

00:16:38,899 --> 00:16:43,939
colleague look at a call stack in the

00:16:40,459 --> 00:16:48,019
debugger and it's kind of you know just

00:16:43,939 --> 00:16:51,679
it's function calls in x86 as with many

00:16:48,019 --> 00:16:53,029
architectures the stack is actually a

00:16:51,679 --> 00:16:54,739
kind of combination so it contains

00:16:53,029 --> 00:16:57,049
return addresses so it contains the call

00:16:54,739 --> 00:16:59,169
stack it also contains parameters that

00:16:57,049 --> 00:17:02,329
get passed into functions and it also

00:16:59,169 --> 00:17:03,709
contains local data so if you kind of

00:17:02,329 --> 00:17:05,990
create some local variables there

00:17:03,709 --> 00:17:07,970
they're also kind of on the stack and

00:17:05,990 --> 00:17:11,120
the really confusing thing about the

00:17:07,970 --> 00:17:13,189
sack in in the Intel world and actually

00:17:11,120 --> 00:17:15,379
to be honest quite a lot of most

00:17:13,189 --> 00:17:18,289
architectures perhaps even is that it

00:17:15,379 --> 00:17:20,299
grows downwards so you push something

00:17:18,289 --> 00:17:22,399
onto the stack and that becomes the top

00:17:20,299 --> 00:17:24,049
of the stack but that will actually have

00:17:22,399 --> 00:17:27,920
a lower address and things that were

00:17:24,049 --> 00:17:30,740
pushed further further ago in time so

00:17:27,920 --> 00:17:32,990
top of the stack low address bottom of

00:17:30,740 --> 00:17:34,880
the tack high address it's confusing and

00:17:32,990 --> 00:17:36,290
irritating okay cool

00:17:34,880 --> 00:17:38,810
I know what you're saying you're just

00:17:36,290 --> 00:17:41,330
desperate to see some assembly code so I

00:17:38,810 --> 00:17:44,000
came out perfect so how do you do this

00:17:41,330 --> 00:17:47,810
actually use heard of the god bolt cut

00:17:44,000 --> 00:17:49,580
compare Explorer so yeah cool that's a

00:17:47,810 --> 00:17:51,800
really great way to look at this and of

00:17:49,580 --> 00:17:53,810
course Matt Goebbels here doing a talk I

00:17:51,800 --> 00:17:56,840
think it's on Friday so that should be

00:17:53,810 --> 00:17:59,270
good but I was on an airplane not so

00:17:56,840 --> 00:18:02,360
long ago with without any network access

00:17:59,270 --> 00:18:04,070
so here alternative way of doing it so

00:18:02,360 --> 00:18:06,290
I'm mainly do this sort of stuff on

00:18:04,070 --> 00:18:08,210
Linux object dump you can give it the

00:18:06,290 --> 00:18:10,400
minus D to disassemble and if you give

00:18:08,210 --> 00:18:13,370
it the minus M Intel flag it gives you

00:18:10,400 --> 00:18:16,070
the Intel syntax there are two kind of

00:18:13,370 --> 00:18:17,390
common syntax is for x86 I always try

00:18:16,070 --> 00:18:21,500
and go for the Intel because it matches

00:18:17,390 --> 00:18:23,660
Intel's documentation you can tell your

00:18:21,500 --> 00:18:25,550
compiler to generate assembler and

00:18:23,660 --> 00:18:27,230
instead of generating objects so the -

00:18:25,550 --> 00:18:29,870
capital S and again you can give it a

00:18:27,230 --> 00:18:31,580
not to give you a TMT syntax which is

00:18:29,870 --> 00:18:33,860
the other one and if you're in a

00:18:31,580 --> 00:18:35,390
debugger so in gdb you can just type

00:18:33,860 --> 00:18:39,350
disassemble it will disassemble the

00:18:35,390 --> 00:18:41,240
current function if you're on Windows so

00:18:39,350 --> 00:18:43,490
I was playing around on my Windows

00:18:41,240 --> 00:18:45,350
machine and you have Visual Studio it's

00:18:43,490 --> 00:18:47,480
even easy just kind of open the

00:18:45,350 --> 00:18:49,190
disassembly work window once that window

00:18:47,480 --> 00:18:51,710
has focused you'll step in and step out

00:18:49,190 --> 00:18:53,600
happens at the assembly instruction

00:18:51,710 --> 00:18:56,990
level it's really cool pretty easy to

00:18:53,600 --> 00:18:58,700
use so here's a simple example

00:18:56,990 --> 00:18:59,930
here's a function that adds two numbers

00:18:58,700 --> 00:19:03,440
together

00:18:59,930 --> 00:19:06,680
I gave it a basic g plus plus invocation

00:19:03,440 --> 00:19:10,670
to this when you generate assembler

00:19:06,680 --> 00:19:13,270
tends to be a whole lot of noise very

00:19:10,670 --> 00:19:16,520
important noise for handling things like

00:19:13,270 --> 00:19:19,250
exceptions and and position independent

00:19:16,520 --> 00:19:20,630
code well to be honest on 64-bit stuff a

00:19:19,250 --> 00:19:22,400
position in division code you get for

00:19:20,630 --> 00:19:24,950
free but on 32-bit there's some

00:19:22,400 --> 00:19:26,660
collateral over that so if you post past

00:19:24,950 --> 00:19:31,370
these short options you get some nice

00:19:26,660 --> 00:19:35,270
simple assembler cool that's actually

00:19:31,370 --> 00:19:39,410
kind of pretty readable so the first two

00:19:35,270 --> 00:19:41,660
instructions they're standard kind of

00:19:39,410 --> 00:19:46,220
Prolog for maintaining your stack

00:19:41,660 --> 00:19:48,410
so generally what happens is every

00:19:46,220 --> 00:19:49,610
function records the stack at beginning

00:19:48,410 --> 00:19:55,670
of its function in the base pointer

00:19:49,610 --> 00:19:59,060
that's EBP and then when when it calls

00:19:55,670 --> 00:20:01,550
the next function the call will store

00:19:59,060 --> 00:20:03,530
the return address so the address of the

00:20:01,550 --> 00:20:08,810
instruction following the call on the

00:20:03,530 --> 00:20:11,240
stack so what these two instructions do

00:20:08,810 --> 00:20:15,800
is is set up what's called a new stack

00:20:11,240 --> 00:20:18,260
frame we saving what the base pointer

00:20:15,800 --> 00:20:20,210
from the previous function and then

00:20:18,260 --> 00:20:24,950
we're recording the value of the stack

00:20:20,210 --> 00:20:29,590
pointer in our base pointer okay time

00:20:24,950 --> 00:20:33,580
for a diagram so on entry to a function

00:20:29,590 --> 00:20:36,620
this is roughly what things look like so

00:20:33,580 --> 00:20:38,210
my function is executing and the top of

00:20:36,620 --> 00:20:40,400
the stack is going to the return address

00:20:38,210 --> 00:20:43,790
I'm going to go back into the base

00:20:40,400 --> 00:20:46,610
pointer is the previous function stack

00:20:43,790 --> 00:20:48,140
pointer after it saved the the base

00:20:46,610 --> 00:20:50,360
point of the function that called it so

00:20:48,140 --> 00:20:52,190
you can see the little loop back that's

00:20:50,360 --> 00:20:54,170
a base pointer pointing to a previous

00:20:52,190 --> 00:20:55,580
function space pointer and what those

00:20:54,170 --> 00:20:58,400
two functions I showed on the previous

00:20:55,580 --> 00:21:01,460
slide are going to do is format loopback

00:20:58,400 --> 00:21:03,440
so that the the steps are going to push

00:21:01,460 --> 00:21:07,940
the base pointer so the stack pointer

00:21:03,440 --> 00:21:09,890
will move down one and then the into

00:21:07,940 --> 00:21:12,440
that new location we're going to store

00:21:09,890 --> 00:21:15,230
the value in EBP which will then kind of

00:21:12,440 --> 00:21:18,470
effectively point back to where the EBP

00:21:15,230 --> 00:21:20,120
pointer is at the moment so you can see

00:21:18,470 --> 00:21:22,910
that the stack is containing different

00:21:20,120 --> 00:21:24,650
sorts of pointers so you've got the

00:21:22,910 --> 00:21:27,020
point of the return addresses that point

00:21:24,650 --> 00:21:28,670
into a area of code of executable code

00:21:27,020 --> 00:21:31,430
and they've got the kind of a base

00:21:28,670 --> 00:21:33,350
pointer chain that points back towards

00:21:31,430 --> 00:21:35,480
base pointers of previous functions and

00:21:33,350 --> 00:21:38,680
this is what kind of gives you the

00:21:35,480 --> 00:21:43,430
ability to walk a call stack normally

00:21:38,680 --> 00:21:45,380
now I'd like to say things are not this

00:21:43,430 --> 00:21:47,840
simple but this is actually takes a bit

00:21:45,380 --> 00:21:51,770
of getting one's head round anyway it

00:21:47,840 --> 00:21:55,110
turns out that debug information so

00:21:51,770 --> 00:21:58,290
modern debug information is so rich

00:21:55,110 --> 00:22:01,650
that you don't always need to store a

00:21:58,290 --> 00:22:03,540
base pointer so you don't see you can

00:22:01,650 --> 00:22:05,929
get from debug information your call

00:22:03,540 --> 00:22:08,790
stat so some compilers will just like

00:22:05,929 --> 00:22:11,850
omit this it's jumping around but

00:22:08,790 --> 00:22:13,860
because I'm using - 0 no optimizations

00:22:11,850 --> 00:22:16,890
we've still got this so first two

00:22:13,860 --> 00:22:18,870
instructions are about setting up the

00:22:16,890 --> 00:22:20,700
frame pointer and then the bottom teeth

00:22:18,870 --> 00:22:25,080
functions are essentially just undoing

00:22:20,700 --> 00:22:27,150
that so I've pushed saved the previous

00:22:25,080 --> 00:22:29,220
functions base pointer and at the end I

00:22:27,150 --> 00:22:30,419
pop it off the stack back into the base

00:22:29,220 --> 00:22:32,760
pointer and then I return to my

00:22:30,419 --> 00:22:35,549
colleague and then the rest of the year

00:22:32,760 --> 00:22:39,630
of those three instructions are the meat

00:22:35,549 --> 00:22:42,390
of it and all it's doing is its so again

00:22:39,630 --> 00:22:43,860
the stack contains data one of the

00:22:42,390 --> 00:22:45,270
things that gets happens before I get

00:22:43,860 --> 00:22:47,880
called as the parameters from you get

00:22:45,270 --> 00:22:50,309
pushed onto the stack so EB b + 8 + EP +

00:22:47,880 --> 00:22:53,100
12 or the two parameters they get moved

00:22:50,309 --> 00:22:56,370
into two registers EDX and e^x so it's

00:22:53,100 --> 00:22:58,230
moving from struction in Intel's syntax

00:22:56,370 --> 00:23:00,240
the destination is the first parameter

00:22:58,230 --> 00:23:02,610
so I'm moving the parameters into EDX

00:23:00,240 --> 00:23:05,640
and the next parameter into EAX the add

00:23:02,610 --> 00:23:08,309
instruction is like a + equals it as edx

00:23:05,640 --> 00:23:11,010
on to EI x + EI x as i mentioned earlier

00:23:08,309 --> 00:23:12,660
is used for the return value for short

00:23:11,010 --> 00:23:15,000
things so there it is it's in the right

00:23:12,660 --> 00:23:18,059
place and so when I returned to my

00:23:15,000 --> 00:23:26,340
caller that answer is an EI s the

00:23:18,059 --> 00:23:28,679
correct place cool cool excellent so C +

00:23:26,340 --> 00:23:30,840
first is a CPP con so finally I get to

00:23:28,679 --> 00:23:32,990
do just a little bit of C plus first

00:23:30,840 --> 00:23:35,850
I've got a demonstration class here I

00:23:32,990 --> 00:23:38,070
believe that Nick Odysseus is doing his

00:23:35,850 --> 00:23:40,890
the nightmare of move semantics for

00:23:38,070 --> 00:23:44,040
trivial classes so go to his talk to

00:23:40,890 --> 00:23:45,960
find out why all of this is a bad idea

00:23:44,040 --> 00:23:48,600
but one of the things that I kind of

00:23:45,960 --> 00:23:51,120
like looked at before is like often

00:23:48,600 --> 00:23:53,220
we're taught to implement operator + in

00:23:51,120 --> 00:23:55,080
terms of operator + equals because you

00:23:53,220 --> 00:23:56,370
can reuse code and make things simpler

00:23:55,080 --> 00:23:59,730
but how should we do this

00:23:56,370 --> 00:24:03,679
so here are two possible candidates does

00:23:59,730 --> 00:24:07,350
anybody want to vote for the top one and

00:24:03,679 --> 00:24:10,100
who wants to vote for the bottom one no

00:24:07,350 --> 00:24:15,030
you're all on the fence

00:24:10,100 --> 00:24:18,920
okay so it turns out that the top one I

00:24:15,030 --> 00:24:21,600
can fit the code on a single slide I've

00:24:18,920 --> 00:24:23,160
D mangled some a couple of things so you

00:24:21,600 --> 00:24:24,810
can see that there's a copy constructor

00:24:23,160 --> 00:24:27,030
that's unsurprising because you look I

00:24:24,810 --> 00:24:29,490
create a temporary I then do a plus

00:24:27,030 --> 00:24:30,930
equals and I return it that's cool so

00:24:29,490 --> 00:24:33,870
I've got a copy constructor and I've got

00:24:30,930 --> 00:24:36,090
an invocation of plus equals so

00:24:33,870 --> 00:24:38,100
candidate two is interesting because it

00:24:36,090 --> 00:24:40,680
does pretty much the same thing but

00:24:38,100 --> 00:24:42,600
afterwards it has more stuff it has

00:24:40,680 --> 00:24:44,820
another copy constructor and a

00:24:42,600 --> 00:24:53,370
destructor it creates next with empty

00:24:44,820 --> 00:24:56,130
does anybody know why that is so I mean

00:24:53,370 --> 00:24:59,430
I'm so why does that not happen in the

00:24:56,130 --> 00:25:07,980
second example yeah do you know why I

00:24:59,430 --> 00:25:09,120
mean why it doesn't yeah so it turns a

00:25:07,980 --> 00:25:11,670
name value but you can still have a

00:25:09,120 --> 00:25:21,960
return value optimization even without a

00:25:11,670 --> 00:25:26,040
name yes yes so I mean the key thing is

00:25:21,960 --> 00:25:30,300
is that the operator plus equals returns

00:25:26,040 --> 00:25:33,750
a reference now by convention that

00:25:30,300 --> 00:25:35,460
reference is to the to the this that's

00:25:33,750 --> 00:25:37,410
passed in but there's no way for the

00:25:35,460 --> 00:25:40,290
compiler to know that so it has to

00:25:37,410 --> 00:25:42,570
create another temporary which is kind

00:25:40,290 --> 00:25:47,780
of kind of annoying because the bottom

00:25:42,570 --> 00:25:47,780
one looks neater at least I think I

00:25:48,920 --> 00:25:53,670
could go through and this line by line

00:25:52,290 --> 00:25:57,090
but that's probably not going to be

00:25:53,670 --> 00:26:02,000
helpful so there's a few minutes for

00:25:57,090 --> 00:26:07,590
questions yes

00:26:02,000 --> 00:26:09,620
Jonah use them or I can repeat the

00:26:07,590 --> 00:26:09,620
question

00:26:24,409 --> 00:26:30,899
okay so so when looking at God bolt

00:26:29,000 --> 00:26:36,059
you're saying that you're seeing a lot

00:26:30,899 --> 00:26:37,830
of suffixes on the on the mini mnemonics

00:26:36,059 --> 00:26:40,130
got it's horrible word I've managed to

00:26:37,830 --> 00:26:42,720
avoid it all along so so that so they're

00:26:40,130 --> 00:26:45,179
the thing like Marv is a mini Manik

00:26:42,720 --> 00:26:47,730
which gets turned into like object code

00:26:45,179 --> 00:26:48,809
op codes so it depends on the syntax

00:26:47,730 --> 00:26:52,730
you've been looking at so if you're

00:26:48,809 --> 00:26:57,029
looking at AT&T syntax the suffix is

00:26:52,730 --> 00:27:00,990
generally a way of saying what size of

00:26:57,029 --> 00:27:03,929
opera and you're looking at so L is kind

00:27:00,990 --> 00:27:06,029
of long anyway it's four bytes W would

00:27:03,929 --> 00:27:09,330
be just the two bytes and Q is a quad

00:27:06,029 --> 00:27:12,929
words so 64 byte length however you have

00:27:09,330 --> 00:27:16,980
to be slightly careful because if you

00:27:12,929 --> 00:27:19,320
look at the Intel reference manual the

00:27:16,980 --> 00:27:22,289
mnemonics have variable lengths so

00:27:19,320 --> 00:27:27,510
there's mouth but there is also I

00:27:22,289 --> 00:27:29,340
believe more of cues actually there's a

00:27:27,510 --> 00:27:32,429
more it's got an extra letter which is

00:27:29,340 --> 00:27:34,260
an SSE valve and it isn't just a suffix

00:27:32,429 --> 00:27:37,789
one and this is an another great reason

00:27:34,260 --> 00:27:39,779
for avoiding AT&T syntax is because

00:27:37,789 --> 00:27:41,309
telling what's the suffix and what's

00:27:39,779 --> 00:27:42,720
part of the mnemonic and then looking at

00:27:41,309 --> 00:27:58,740
the right thing in the documentation is

00:27:42,720 --> 00:28:05,510
kind of hard yes Oh

00:27:58,740 --> 00:28:05,510
slide 1 slide 2 oh this one

00:28:20,650 --> 00:28:27,440
so the commentators second ones not

00:28:23,210 --> 00:28:29,570
available for return value optimization

00:28:27,440 --> 00:28:32,120
yeah and the reason is is because it's a

00:28:29,570 --> 00:28:33,740
reference that's coming in so it's it's

00:28:32,120 --> 00:28:50,860
an L well it's effective it's an L value

00:28:33,740 --> 00:28:50,860
so it needs to be copied yeah that's

00:28:55,510 --> 00:29:01,310
probably not although then I'd be quite

00:28:58,760 --> 00:29:05,240
a mystic it's in the same file and yeah

00:29:01,310 --> 00:29:07,220
maybe yeah

00:29:05,240 --> 00:29:09,680
I had another demonstration didn't have

00:29:07,220 --> 00:29:12,590
quite time for in in and I was having a

00:29:09,680 --> 00:29:13,910
look at if you have a instead of a const

00:29:12,590 --> 00:29:15,620
reference you've had in our value

00:29:13,910 --> 00:29:17,960
reference because you overloaded because

00:29:15,620 --> 00:29:19,520
you wanted to be able to add something

00:29:17,960 --> 00:29:21,020
that's temporary on the left did

00:29:19,520 --> 00:29:22,730
something similar here and interesting i

00:29:21,020 --> 00:29:24,260
got the difference is that one could be

00:29:22,730 --> 00:29:26,000
copied and one could be moved in this

00:29:24,260 --> 00:29:28,550
sort of similar manner she thinks it's

00:29:26,000 --> 00:29:30,200
yeah it's very complex and nico just

00:29:28,550 --> 00:29:50,510
suitors is much better expert than me of

00:29:30,200 --> 00:29:52,850
that sort of stuff so the observation is

00:29:50,510 --> 00:29:55,370
if you take the first parameter by value

00:29:52,850 --> 00:29:57,950
in your operator plus then you know

00:29:55,370 --> 00:30:01,150
you've got more room for optimization so

00:29:57,950 --> 00:30:01,150
the answer is maybe

00:30:09,270 --> 00:30:13,080
yeah it kind of depends if you've got

00:30:11,640 --> 00:30:14,640
some if you if you're if you're adding

00:30:13,080 --> 00:30:19,140
something that's genuinely on our value

00:30:14,640 --> 00:30:22,770
then maybe but on the other hand if

00:30:19,140 --> 00:30:25,290
you're adding something if you've got

00:30:22,770 --> 00:30:27,210
something that's an L value anyway so

00:30:25,290 --> 00:30:28,980
you've got a local variable already for

00:30:27,210 --> 00:30:32,670
some other reason then you're just

00:30:28,980 --> 00:30:35,340
moving a copy from inside to outside so

00:30:32,670 --> 00:30:38,610
and if you do move that copy outside

00:30:35,340 --> 00:30:42,480
then you can't you don't get the the r

00:30:38,610 --> 00:30:44,880
vo the NR vo in the top one so it varies

00:30:42,480 --> 00:30:46,110
so thank you very much that's a that's

00:30:44,880 --> 00:30:48,060
all we've got time for but you can kind

00:30:46,110 --> 00:30:51,690
of like hassle me afterwards and do then

00:30:48,060 --> 00:30:52,610
see I'll stand just downstairs from here

00:30:51,690 --> 00:31:00,350
thank you

00:30:52,610 --> 00:31:00,350

YouTube URL: https://www.youtube.com/watch?v=IfUPkUAEwrk


