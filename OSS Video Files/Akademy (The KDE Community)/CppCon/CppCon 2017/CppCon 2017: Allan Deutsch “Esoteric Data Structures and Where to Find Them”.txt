Title: CppCon 2017: Allan Deutsch “Esoteric Data Structures and Where to Find Them”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
We already have array, vector, and unordered_map, what other data structures could we possibly need? 

As it turns out, there are a lot of them and they come from all areas of software! Curious to learn the latest method of representing a pathfinding search space in detailed 3D environments? Does efficiently detecting if a website could be malicious sound like an interesting problem to you? Perhaps understanding how AAA games store and track their entities so efficiently is more your speed? 

All these things and more can be yours in exchange for just one hour of your time! Using that hour we will delve into some of the unique challenges faced by C++ developers in a variety of domains, and learn the inner workings of the creative solutions devised to solve them.
— 
Allan Deutsch: DigiPen Institute of Technology, Student

Allan Deutsch is a BSCS student at DigiPen Institute of Technology. 
He has a passion for performance, an interest perfectly paired to C++ and game development. Allan completed a software engineering internship at Microsoft in 2016 and will be returning as a program manager intern in 2017 working with the Xbox Advanced Technology Group. He is currently working on proposals to the C++ Standards Committee for more efficient data structures, as well as the accompanying reference implementations. In his free time, Allan enjoys sailing, SCUBA diving, lifting weights, and organizing events.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,270
alright it looks like for the most part

00:00:01,589 --> 00:00:05,640
people have made it into the room so I'm

00:00:03,270 --> 00:00:07,170
gonna go ahead and get started I'm Alan

00:00:05,640 --> 00:00:09,360
Deutsch and I'm here to tell you guys

00:00:07,170 --> 00:00:12,480
about esoteric data structures and where

00:00:09,360 --> 00:00:14,340
to find them I hope you enjoy so you

00:00:12,480 --> 00:00:16,230
might be wondering who I am I'm a

00:00:14,340 --> 00:00:17,880
student at DigiPen Institute of

00:00:16,230 --> 00:00:20,400
Technology it's a small school in

00:00:17,880 --> 00:00:22,890
Redmond we make video games I'm studying

00:00:20,400 --> 00:00:24,779
for a computer science degree and I've

00:00:22,890 --> 00:00:26,849
interned as a software engineer at

00:00:24,779 --> 00:00:30,269
Microsoft Studios global publishing team

00:00:26,849 --> 00:00:32,910
and as a program manager within Xbox in

00:00:30,269 --> 00:00:34,710
the advanced technology group and I'll

00:00:32,910 --> 00:00:37,530
be returning once I graduate as a

00:00:34,710 --> 00:00:38,760
full-time employee there so the first

00:00:37,530 --> 00:00:41,610
data structure that we're going to talk

00:00:38,760 --> 00:00:43,680
about is slot map slot map is an

00:00:41,610 --> 00:00:45,629
unordered container which means that

00:00:43,680 --> 00:00:47,399
your data regardless of the order you

00:00:45,629 --> 00:00:50,370
put it in may not be in the same order

00:00:47,399 --> 00:00:51,600
later on and it's associative so when

00:00:50,370 --> 00:00:55,469
you insert something you're going to get

00:00:51,600 --> 00:00:57,000
a key to find it later it stores all of

00:00:55,469 --> 00:00:58,800
the elements that you've inserted into

00:00:57,000 --> 00:01:00,420
it and contiguous memory so there's no

00:00:58,800 --> 00:01:02,820
gaps which gives it great performance

00:01:00,420 --> 00:01:05,549
for iteration and all of its operations

00:01:02,820 --> 00:01:07,619
are very consistent and I'm currently

00:01:05,549 --> 00:01:10,110
proposing it for standardization through

00:01:07,619 --> 00:01:13,380
SG 14 and it's in library Ellucian

00:01:10,110 --> 00:01:15,119
working group now so the red asterisk is

00:01:13,380 --> 00:01:16,680
because the committee may change the

00:01:15,119 --> 00:01:18,240
name so if you're watching this video in

00:01:16,680 --> 00:01:19,619
like five years and you're thinking wow

00:01:18,240 --> 00:01:21,000
there's something just like this in the

00:01:19,619 --> 00:01:24,450
standard but with a totally different

00:01:21,000 --> 00:01:26,549
name that's probably why that's so the

00:01:24,450 --> 00:01:27,930
problems being solved by a slot map or

00:01:26,549 --> 00:01:31,079
that you have some items that need

00:01:27,930 --> 00:01:33,030
unique identifiers and you have to have

00:01:31,079 --> 00:01:36,479
consistent performance so this is

00:01:33,030 --> 00:01:38,430
specifically from games we have a very

00:01:36,479 --> 00:01:40,950
tight time schedule and it needs to be

00:01:38,430 --> 00:01:43,290
consistent for a pleasant user

00:01:40,950 --> 00:01:45,000
experience and so making sure that we

00:01:43,290 --> 00:01:48,000
don't have amortized costs that could

00:01:45,000 --> 00:01:49,950
spike unexpectedly is desirable and we

00:01:48,000 --> 00:01:51,540
also get to reuse memory so that we

00:01:49,950 --> 00:01:54,060
don't have to do lots of allocations and

00:01:51,540 --> 00:01:56,159
deallocations another nice feature of

00:01:54,060 --> 00:01:58,259
slot maps is that they avoid ABA like

00:01:56,159 --> 00:01:59,640
problems which is where you have some

00:01:58,259 --> 00:02:01,829
data that you've put in and you have a

00:01:59,640 --> 00:02:03,240
key for it and then later on somewhere

00:02:01,829 --> 00:02:05,880
else in the code that element gets

00:02:03,240 --> 00:02:07,619
deleted something else gets put in with

00:02:05,880 --> 00:02:10,379
the same key and then you have the key

00:02:07,619 --> 00:02:12,599
from before trying to access it slot map

00:02:10,379 --> 00:02:13,830
uses a generation counter mechanic to

00:02:12,599 --> 00:02:15,450
avoid that problem

00:02:13,830 --> 00:02:20,580
so that new keys get that get handed out

00:02:15,450 --> 00:02:22,800
will not incorrectly get old data so it

00:02:20,580 --> 00:02:25,200
can be found in game engines it's also

00:02:22,800 --> 00:02:26,640
very similar to a pool allocator so if

00:02:25,200 --> 00:02:28,230
at some point you're a bit confused

00:02:26,640 --> 00:02:29,820
about what it is just think of it as a

00:02:28,230 --> 00:02:32,670
pool alligator with something resembling

00:02:29,820 --> 00:02:34,830
a map interface and then in the future

00:02:32,670 --> 00:02:36,810
once it's standardised I expect to see

00:02:34,830 --> 00:02:38,220
it in browsers compilers and more as

00:02:36,810 --> 00:02:40,890
those are some of the interest groups

00:02:38,220 --> 00:02:44,370
that have shown that they're interested

00:02:40,890 --> 00:02:46,170
in having it so the guarantees of a slot

00:02:44,370 --> 00:02:49,410
map are that it has true constant time

00:02:46,170 --> 00:02:52,080
lookup erase and insert operations so

00:02:49,410 --> 00:02:53,790
rather than being amortized these will

00:02:52,080 --> 00:02:55,650
always be a fixed cost there's no

00:02:53,790 --> 00:02:57,480
hashing or anything going on that could

00:02:55,650 --> 00:03:00,660
change it with the one exception that

00:02:57,480 --> 00:03:04,200
insert will be Oh n when it needs to

00:03:00,660 --> 00:03:06,870
reallocate and grow so insert calls will

00:03:04,200 --> 00:03:08,459
return a unique key to the user which

00:03:06,870 --> 00:03:10,590
they can then use to access their data

00:03:08,459 --> 00:03:11,459
in constant time and it's a fixed set of

00:03:10,590 --> 00:03:13,260
operations

00:03:11,459 --> 00:03:16,470
there's no hashing or anything so again

00:03:13,260 --> 00:03:18,360
very consistent performance and the keys

00:03:16,470 --> 00:03:20,940
to erase values won't work until an

00:03:18,360 --> 00:03:22,620
overflow occurs that's on the generation

00:03:20,940 --> 00:03:24,420
counter so if it wraps around from

00:03:22,620 --> 00:03:27,959
whatever your max value is back to zero

00:03:24,420 --> 00:03:29,550
then you could have a be a problems so

00:03:27,959 --> 00:03:31,920
one of the common alternatives to this

00:03:29,550 --> 00:03:33,840
is using a hash map but the lookup costs

00:03:31,920 --> 00:03:36,720
are inconsistent in those due to both

00:03:33,840 --> 00:03:38,220
hashing and probing and the hashing has

00:03:36,720 --> 00:03:41,790
a high overhead which is also

00:03:38,220 --> 00:03:44,070
undesirable and in many cases you might

00:03:41,790 --> 00:03:46,170
not care what the unique key is just

00:03:44,070 --> 00:03:48,330
that it's unique whereas in a hash map

00:03:46,170 --> 00:03:48,989
you have to create your key a slot map

00:03:48,330 --> 00:03:52,290
you don't

00:03:48,989 --> 00:03:54,660
it gives it to you this hash map is also

00:03:52,290 --> 00:03:58,230
prone to ABA problems and at least in

00:03:54,660 --> 00:04:00,930
the STL for us C++ users here it's not

00:03:58,230 --> 00:04:02,190
contiguous so a lot of undesirable

00:04:00,930 --> 00:04:04,400
characteristics for the types of

00:04:02,190 --> 00:04:06,930
problems that have slot map solves

00:04:04,400 --> 00:04:09,090
another alternative would be using an

00:04:06,930 --> 00:04:12,690
array or a vector you can use the

00:04:09,090 --> 00:04:14,700
indices kind of like keys and since it's

00:04:12,690 --> 00:04:16,410
all packed together it's gonna use a bit

00:04:14,700 --> 00:04:17,940
less in memory than a slot map because

00:04:16,410 --> 00:04:20,040
it doesn't have some of the overhead to

00:04:17,940 --> 00:04:21,299
make the guarantees but the downside is

00:04:20,040 --> 00:04:23,100
that when you want to remove something

00:04:21,299 --> 00:04:24,750
from it that's going to either

00:04:23,100 --> 00:04:26,160
invalidate everything after it or at

00:04:24,750 --> 00:04:27,240
least the last element that might need

00:04:26,160 --> 00:04:29,400
to be shifted

00:04:27,240 --> 00:04:32,250
spot and arrays are also prone to the

00:04:29,400 --> 00:04:36,750
ABA problem so the way that a slot map

00:04:32,250 --> 00:04:38,160
works is you have an array of data right

00:04:36,750 --> 00:04:39,479
so that's pretty straightforward

00:04:38,160 --> 00:04:41,099
you're gonna keep all of your elements

00:04:39,479 --> 00:04:43,440
stored there and as you can see they're

00:04:41,099 --> 00:04:46,080
packed towards the front and contiguous

00:04:43,440 --> 00:04:49,259
memory and where the real magic happens

00:04:46,080 --> 00:04:52,410
is in a slots array so that's this guy

00:04:49,259 --> 00:04:54,870
it'll have these two values in each slot

00:04:52,410 --> 00:04:56,789
and one of them is an index and that

00:04:54,870 --> 00:04:58,710
index will go into the data array and

00:04:56,789 --> 00:05:01,340
the other value is a generation counter

00:04:58,710 --> 00:05:04,080
and that's how we solve the ABA problem

00:05:01,340 --> 00:05:06,630
so as you can see all these indices

00:05:04,080 --> 00:05:09,960
correspond to some data that's being

00:05:06,630 --> 00:05:12,569
stored it also uses a free list

00:05:09,960 --> 00:05:14,639
mechanism in order to have oh one

00:05:12,569 --> 00:05:19,380
inserts that way it's able to find a

00:05:14,639 --> 00:05:21,240
free slot in constant time and you'll

00:05:19,380 --> 00:05:23,069
note that the free list head has an

00:05:21,240 --> 00:05:24,900
index in it that index is set to the

00:05:23,069 --> 00:05:28,590
next element in the free list so it's

00:05:24,900 --> 00:05:30,509
able to store it all in place so the way

00:05:28,590 --> 00:05:32,969
that insert works is we have some

00:05:30,509 --> 00:05:35,330
element that we want to insert that'll

00:05:32,969 --> 00:05:37,889
go in the next empty slot available and

00:05:35,330 --> 00:05:40,680
so we're gonna put our data there and

00:05:37,889 --> 00:05:42,449
then moving forward we have to pop

00:05:40,680 --> 00:05:44,039
something off the free list head that's

00:05:42,449 --> 00:05:46,919
going to be the slot that corresponds to

00:05:44,039 --> 00:05:49,380
our newly inserted data and we generate

00:05:46,919 --> 00:05:51,300
a key that points to that slot we have

00:05:49,380 --> 00:05:54,330
to match the generation to make sure

00:05:51,300 --> 00:05:56,849
that when we look later we'll not have

00:05:54,330 --> 00:05:59,069
those ABA issues and then we update it

00:05:56,849 --> 00:06:00,990
to point to our data and we can then

00:05:59,069 --> 00:06:03,270
return our key to the user and the key

00:06:00,990 --> 00:06:04,740
will point to the slot not the data

00:06:03,270 --> 00:06:08,759
itself so there is that layer of

00:06:04,740 --> 00:06:11,130
indirection there to erase something you

00:06:08,759 --> 00:06:13,139
give a key to the slot map and it'll

00:06:11,130 --> 00:06:14,400
have an index in a generation so the

00:06:13,139 --> 00:06:16,979
first thing we're going to do is check

00:06:14,400 --> 00:06:18,900
the generation in our case here the

00:06:16,979 --> 00:06:21,120
generations match and so we can go ahead

00:06:18,900 --> 00:06:24,030
and proceed so we're going to increment

00:06:21,120 --> 00:06:25,800
the generation to make sure that we

00:06:24,030 --> 00:06:26,400
don't have any issues with ABA going

00:06:25,800 --> 00:06:29,190
forward

00:06:26,400 --> 00:06:30,719
right off the bat then we can find the

00:06:29,190 --> 00:06:32,699
element that it's pointing to and go

00:06:30,719 --> 00:06:34,050
ahead and destruct it and then once

00:06:32,699 --> 00:06:38,339
that's destructed we're going to move

00:06:34,050 --> 00:06:40,980
the last element into its slot then we

00:06:38,339 --> 00:06:43,260
need to find the entry

00:06:40,980 --> 00:06:45,330
in the slots table that corresponds to

00:06:43,260 --> 00:06:47,510
that and update it to point at the new

00:06:45,330 --> 00:06:50,460
address that the moved element is in

00:06:47,510 --> 00:06:54,510
then we need to go to our free list tail

00:06:50,460 --> 00:06:57,720
and what we're gonna do is add the newly

00:06:54,510 --> 00:07:00,330
vacated slot entry and set the index of

00:06:57,720 --> 00:07:03,330
both of them to point at the vacated

00:07:00,330 --> 00:07:05,700
slot so what this does is it adds it to

00:07:03,330 --> 00:07:07,530
the free list and the last element will

00:07:05,700 --> 00:07:11,400
point to itself so that it can detect

00:07:07,530 --> 00:07:13,350
that it's at the end finally we set the

00:07:11,400 --> 00:07:16,380
free list tail to point to that newly

00:07:13,350 --> 00:07:18,480
freed slot and we're done so some of the

00:07:16,380 --> 00:07:20,400
trade offs of the slot map are that the

00:07:18,480 --> 00:07:22,560
dynamic sizing can cause memory usage

00:07:20,400 --> 00:07:24,420
spikes especially in games this can be a

00:07:22,560 --> 00:07:26,610
problem where you know you have space

00:07:24,420 --> 00:07:28,680
for a thousand elements and then you

00:07:26,610 --> 00:07:31,050
want to go and grow it and typically

00:07:28,680 --> 00:07:33,360
that's going to be a 1.5 X or 2x growth

00:07:31,050 --> 00:07:35,160
and so you not only need the memory from

00:07:33,360 --> 00:07:37,320
before but also the new memory which is

00:07:35,160 --> 00:07:39,120
a big jump whereas something like a hash

00:07:37,320 --> 00:07:40,380
map that's node based you wouldn't have

00:07:39,120 --> 00:07:42,660
this sort of issue since you can

00:07:40,380 --> 00:07:44,430
allocate just the node you need so at

00:07:42,660 --> 00:07:47,070
those times it can spike in memory usage

00:07:44,430 --> 00:07:49,530
but it's otherwise quite consistent also

00:07:47,070 --> 00:07:51,210
due to the dense storage the addresses

00:07:49,530 --> 00:07:52,740
of the elements are unstable so the

00:07:51,210 --> 00:07:56,160
lookups are a bit slower than just using

00:07:52,740 --> 00:07:57,810
a raw pointer it also uses additional

00:07:56,160 --> 00:07:59,760
memory to make some of its performance

00:07:57,810 --> 00:08:02,730
guarantees which may be undesirable in

00:07:59,760 --> 00:08:05,130
some circumstances so one of the common

00:08:02,730 --> 00:08:07,140
variations is not using the index table

00:08:05,130 --> 00:08:09,090
you're able to save a bit of memory by

00:08:07,140 --> 00:08:10,950
that and have stable indices and

00:08:09,090 --> 00:08:13,170
pointers the way that it works is you

00:08:10,950 --> 00:08:16,680
just store the slot data right next to

00:08:13,170 --> 00:08:18,060
the data itself and so by doing that you

00:08:16,680 --> 00:08:20,550
don't have the indirection in memory

00:08:18,060 --> 00:08:23,340
either so it trades faster lookup times

00:08:20,550 --> 00:08:25,740
for worse iteration performance and also

00:08:23,340 --> 00:08:27,330
it has the downside that the elements

00:08:25,740 --> 00:08:30,650
aren't densely stored which is what

00:08:27,330 --> 00:08:33,390
causes the worst iteration performance

00:08:30,650 --> 00:08:36,150
another variation is using a fixed size

00:08:33,390 --> 00:08:38,070
array so this one will have constant

00:08:36,150 --> 00:08:40,400
time insert in all cases since it does

00:08:38,070 --> 00:08:43,080
never grow and crashing is constant time

00:08:40,400 --> 00:08:44,880
but the generations increase roughly

00:08:43,080 --> 00:08:47,070
uniformly as well since they're all

00:08:44,880 --> 00:08:49,280
allocated from the start and there's no

00:08:47,070 --> 00:08:51,330
memory usage spikes

00:08:49,280 --> 00:08:53,370
unfortunately dynamic sizing is

00:08:51,330 --> 00:08:54,800
typically something that we want to have

00:08:53,370 --> 00:08:57,739
and so this variation

00:08:54,800 --> 00:08:59,569
isn't usually what we'd want and some of

00:08:57,739 --> 00:09:02,959
the edge cases can cause the generation

00:08:59,569 --> 00:09:05,420
to overflow quickly another one is using

00:09:02,959 --> 00:09:07,249
block allocations similar to a deck so

00:09:05,420 --> 00:09:09,829
that one also has the oh one insertion

00:09:07,249 --> 00:09:11,600
and the allocation memory usage spikes

00:09:09,829 --> 00:09:13,819
are a bit smaller than using a vector

00:09:11,600 --> 00:09:16,339
like backing and the iteration

00:09:13,819 --> 00:09:21,679
performance can be tuned to get pretty

00:09:16,339 --> 00:09:24,709
close to just having a fixed single

00:09:21,679 --> 00:09:26,600
block of memory but the elements aren't

00:09:24,709 --> 00:09:28,699
stored fully contiguously because of the

00:09:26,600 --> 00:09:30,679
gaps in memory and the cache misses

00:09:28,699 --> 00:09:32,509
scale inversely with the block size so

00:09:30,679 --> 00:09:34,610
the smaller your jumps in memory usage

00:09:32,509 --> 00:09:37,069
the worse the Casper formation is and

00:09:34,610 --> 00:09:38,660
the lookup has an additional indirection

00:09:37,069 --> 00:09:41,720
since it also has to find the correct

00:09:38,660 --> 00:09:43,639
block so the way that it works is the

00:09:41,720 --> 00:09:45,470
keys are some sort of decomposable pair

00:09:43,639 --> 00:09:47,959
of integers at least in the current

00:09:45,470 --> 00:09:49,339
state of the proposal so the first is

00:09:47,959 --> 00:09:51,679
the index and the second is the

00:09:49,339 --> 00:09:54,439
generation and the index from the index

00:09:51,679 --> 00:09:56,269
array is used when the generation

00:09:54,439 --> 00:10:00,619
counters have been detected to match and

00:09:56,269 --> 00:10:03,189
then the keys can be tuned a bit by the

00:10:00,619 --> 00:10:05,420
user as a specified template parameter

00:10:03,189 --> 00:10:07,160
so the next data structure that we're

00:10:05,420 --> 00:10:09,199
going to talk about today is a bloom

00:10:07,160 --> 00:10:11,480
filter bloom filters are really

00:10:09,199 --> 00:10:14,079
interesting hashing based structure they

00:10:11,480 --> 00:10:17,119
use up a fixed amount of memory and

00:10:14,079 --> 00:10:19,249
rather than hashing the element and

00:10:17,119 --> 00:10:21,439
storing both the element and some sort

00:10:19,249 --> 00:10:23,420
of key that's used to find it using a

00:10:21,439 --> 00:10:25,369
hash it's a probabilistic data structure

00:10:23,420 --> 00:10:28,279
which means that it doesn't always

00:10:25,369 --> 00:10:30,709
guarantee correctness but it uses a lot

00:10:28,279 --> 00:10:32,569
less memory and gets pretty close and

00:10:30,709 --> 00:10:35,360
you can tune your error percentage with

00:10:32,569 --> 00:10:37,429
these so the probabilistic part is that

00:10:35,360 --> 00:10:39,470
sometimes it'll say an element is in the

00:10:37,429 --> 00:10:41,540
set when it really isn't but it doesn't

00:10:39,470 --> 00:10:43,369
actually contain any of the elements

00:10:41,540 --> 00:10:45,439
it's just a bunch of bits so it only

00:10:43,369 --> 00:10:47,600
supports find in insert operations you

00:10:45,439 --> 00:10:49,549
can't remove things from it and the only

00:10:47,600 --> 00:10:52,249
options that you can get from a find are

00:10:49,549 --> 00:10:53,779
that it's definitely not there or if it

00:10:52,249 --> 00:10:55,790
says that it is there it could be

00:10:53,779 --> 00:10:57,589
incorrect and the data is actually not

00:10:55,790 --> 00:10:58,869
and so that's where the probabilistic

00:10:57,589 --> 00:11:01,489
part comes in

00:10:58,869 --> 00:11:02,990
so the problem being solved is typically

00:11:01,489 --> 00:11:05,149
when you want to check a set for the

00:11:02,990 --> 00:11:06,499
membership of an element so you have

00:11:05,149 --> 00:11:07,590
some data and you want to see if it's in

00:11:06,499 --> 00:11:10,860
your set

00:11:07,590 --> 00:11:13,340
and bloom filters are very efficient

00:11:10,860 --> 00:11:15,840
with memory they use far less than any

00:11:13,340 --> 00:11:17,720
sort of set representation you would

00:11:15,840 --> 00:11:19,830
have that actually stores the elements

00:11:17,720 --> 00:11:23,280
it's like several orders of magnitude

00:11:19,830 --> 00:11:25,620
better and the trade-off here is that

00:11:23,280 --> 00:11:27,900
you have to be ok with it probably being

00:11:25,620 --> 00:11:29,780
right and not always being able to

00:11:27,900 --> 00:11:32,640
guarantee that it's correct

00:11:29,780 --> 00:11:34,830
so the guarantees that it does make are

00:11:32,640 --> 00:11:37,860
that it'll have constant time for both

00:11:34,830 --> 00:11:40,050
insert and lookup operations and it's

00:11:37,860 --> 00:11:42,120
memory usage is constant and none of the

00:11:40,050 --> 00:11:43,950
actual elements are stored and that's

00:11:42,120 --> 00:11:45,330
kind of an interesting property that the

00:11:43,950 --> 00:11:47,460
elements aren't stored because it means

00:11:45,330 --> 00:11:48,990
they can't be reconstructed and it's

00:11:47,460 --> 00:11:51,180
privacy friendly so if you want to keep

00:11:48,990 --> 00:11:53,340
track of some user data without actually

00:11:51,180 --> 00:11:56,520
having the user data this is a cool way

00:11:53,340 --> 00:11:58,560
to do it so the most common alternative

00:11:56,520 --> 00:12:00,360
would be something like a hash set where

00:11:58,560 --> 00:12:01,890
there's only one hash per lookup which

00:12:00,360 --> 00:12:03,900
is typically going to be better than a

00:12:01,890 --> 00:12:05,670
bloom filter but it's going to use more

00:12:03,900 --> 00:12:07,650
memory since it has to store all of the

00:12:05,670 --> 00:12:09,270
elements and they're generally not

00:12:07,650 --> 00:12:12,570
contiguous since they're typically

00:12:09,270 --> 00:12:14,850
implemented as a red-black tree and it

00:12:12,570 --> 00:12:16,980
also contains the elements themselves in

00:12:14,850 --> 00:12:18,750
a hash set which in some cases could be

00:12:16,980 --> 00:12:21,660
quite desirable and others it might not

00:12:18,750 --> 00:12:23,700
such as the privacy cases so the places

00:12:21,660 --> 00:12:26,940
you can find a hash or sorry a bloom

00:12:23,700 --> 00:12:29,880
filter are in things like website safety

00:12:26,940 --> 00:12:31,800
email contact lists newsfeed pruning

00:12:29,880 --> 00:12:34,380
type-ahead search for looking for your

00:12:31,800 --> 00:12:37,200
friends on like Facebook and even as an

00:12:34,380 --> 00:12:39,510
early out for expensive queries so the

00:12:37,200 --> 00:12:41,390
way that some of these work is that say

00:12:39,510 --> 00:12:44,240
for example with the early-out example

00:12:41,390 --> 00:12:46,770
you would have a bloom filter

00:12:44,240 --> 00:12:49,230
representing your files that you have on

00:12:46,770 --> 00:12:51,810
disk perhaps and before doing the

00:12:49,230 --> 00:12:54,510
expensive file i/o operation to read

00:12:51,810 --> 00:12:56,400
from disk what you can do is query the

00:12:54,510 --> 00:12:58,980
bloom filter to see if the element is

00:12:56,400 --> 00:13:00,840
there and if it says no you can be 100%

00:12:58,980 --> 00:13:02,970
certain that the element really isn't on

00:13:00,840 --> 00:13:04,410
disk and if it says yes there's a pretty

00:13:02,970 --> 00:13:05,700
good chance that it is there and then

00:13:04,410 --> 00:13:09,210
you can go ahead and take that more

00:13:05,700 --> 00:13:10,830
expensive file i/o operation so the way

00:13:09,210 --> 00:13:12,840
that a bloom filter works under the hood

00:13:10,830 --> 00:13:14,550
let's start with this storage it's

00:13:12,840 --> 00:13:15,810
actually a bit array and as I've said

00:13:14,550 --> 00:13:17,850
before it doesn't have the actual

00:13:15,810 --> 00:13:20,780
elements so that looks something like

00:13:17,850 --> 00:13:24,290
this we have our bits 0 through

00:13:20,780 --> 00:13:25,670
23 for a total of 24 bits and these are

00:13:24,290 --> 00:13:27,260
going to get set by various hash

00:13:25,670 --> 00:13:29,720
functions whenever you insert an element

00:13:27,260 --> 00:13:32,540
and the way the hashing works is that

00:13:29,720 --> 00:13:34,880
you'll have K hash functions and K is

00:13:32,540 --> 00:13:37,820
some user specified amount based on the

00:13:34,880 --> 00:13:39,740
margin of error you want and then each

00:13:37,820 --> 00:13:41,630
hash will set one bit

00:13:39,740 --> 00:13:44,150
based on whatever element you're

00:13:41,630 --> 00:13:45,770
inserting and so for these you prefer

00:13:44,150 --> 00:13:47,690
speed over security for your hash

00:13:45,770 --> 00:13:49,970
functions since you're not storing your

00:13:47,690 --> 00:13:53,000
data anyway it's not that important that

00:13:49,970 --> 00:13:55,160
they be cryptographically secure so the

00:13:53,000 --> 00:13:57,080
hashing we have our two little hash

00:13:55,160 --> 00:14:00,220
functions here too I chose to give them

00:13:57,080 --> 00:14:04,430
cute names like F and V 1 a and member 3

00:14:00,220 --> 00:14:06,110
so to insert something say Auto it goes

00:14:04,430 --> 00:14:08,270
through those hash functions and you get

00:14:06,110 --> 00:14:09,800
some sort of value out and then you find

00:14:08,270 --> 00:14:13,070
the bits that correspond to those values

00:14:09,800 --> 00:14:15,410
so at those indexes and you go ahead and

00:14:13,070 --> 00:14:17,360
set them to 1 and so I have this little

00:14:15,410 --> 00:14:19,430
set on the right side here it's not a

00:14:17,360 --> 00:14:20,870
real set but we're just going to keep it

00:14:19,430 --> 00:14:23,510
there to keep track of the elements

00:14:20,870 --> 00:14:25,040
we've added for later so let's add a

00:14:23,510 --> 00:14:30,010
couple more elements we can put in a

00:14:25,040 --> 00:14:34,250
struct as a string template class and

00:14:30,010 --> 00:14:35,780
Const expert and so the way that lookups

00:14:34,250 --> 00:14:37,670
work is that they're similar to insert

00:14:35,780 --> 00:14:39,560
you also take it and run it through the

00:14:37,670 --> 00:14:42,350
hash functions but rather than setting

00:14:39,560 --> 00:14:43,850
bits you check that the bits are set so

00:14:42,350 --> 00:14:45,320
let's say we want to look up Const

00:14:43,850 --> 00:14:48,320
expert which is one that's in there we

00:14:45,320 --> 00:14:50,300
got our bits and we check them and both

00:14:48,320 --> 00:14:52,550
of them were set to 1 so they're found

00:14:50,300 --> 00:14:54,230
and that means that it was probably in

00:14:52,550 --> 00:14:55,910
the bloom filter it was probably

00:14:54,230 --> 00:14:58,820
inserted at some time but again we're

00:14:55,910 --> 00:15:01,400
not 100% sure but in this case it

00:14:58,820 --> 00:15:03,500
happens to be true another one would be

00:15:01,400 --> 00:15:06,380
var so we can look that up and we get a

00:15:03,500 --> 00:15:08,089
couple of bits and we check them and one

00:15:06,380 --> 00:15:10,010
of them set but the other is set to zero

00:15:08,089 --> 00:15:11,240
so we know for sure that that elements

00:15:10,010 --> 00:15:12,770
not in there because if it had been

00:15:11,240 --> 00:15:16,610
inserted both of those bits would have

00:15:12,770 --> 00:15:18,920
been set to one so another example is

00:15:16,610 --> 00:15:20,570
hello and so this one will point to a

00:15:18,920 --> 00:15:22,490
couple of bits that were both set to 1

00:15:20,570 --> 00:15:24,860
but as you can see in our little example

00:15:22,490 --> 00:15:27,140
set on the right it was never actually

00:15:24,860 --> 00:15:28,970
inserted so this is the case where you

00:15:27,140 --> 00:15:30,230
have to watch out for and be okay with

00:15:28,970 --> 00:15:33,580
if you're going to use a bloom filter

00:15:30,230 --> 00:15:35,870
because it can be incorrect

00:15:33,580 --> 00:15:37,940
so that's where the probabilistic part

00:15:35,870 --> 00:15:39,950
comes in the false positives can happen

00:15:37,940 --> 00:15:42,260
but false negatives don't and the amount

00:15:39,950 --> 00:15:45,500
of these can be tuned so let's look at

00:15:42,260 --> 00:15:48,500
how that works if we have a number of

00:15:45,500 --> 00:15:53,120
hash functions K then we can set that

00:15:48,500 --> 00:15:55,690
based on the negative log to of P where

00:15:53,120 --> 00:15:57,590
P is the desired false probability rate

00:15:55,690 --> 00:15:59,420
the other thing that you might want to

00:15:57,590 --> 00:16:01,340
tune is the number of bits or otherwise

00:15:59,420 --> 00:16:04,460
the memory footprint of your bloom

00:16:01,340 --> 00:16:06,470
filter so in this case M will represent

00:16:04,460 --> 00:16:10,160
the number of bits and as the number of

00:16:06,470 --> 00:16:13,730
elements inserted and P is again your

00:16:10,160 --> 00:16:15,350
desired false probability rate so that's

00:16:13,730 --> 00:16:18,230
the equation for figuring out how many

00:16:15,350 --> 00:16:19,670
bits you want as a small disclosure I'm

00:16:18,230 --> 00:16:22,640
not really a math guy and I just kind of

00:16:19,670 --> 00:16:27,620
took the math from Wikipedia but it's

00:16:22,640 --> 00:16:29,210
probably right so the takeaways from a

00:16:27,620 --> 00:16:31,520
bloom filter or that if you're willing

00:16:29,210 --> 00:16:34,640
to accept some error you can save a lot

00:16:31,520 --> 00:16:37,670
of memory it's also able to store data

00:16:34,640 --> 00:16:39,650
without actually storing the data which

00:16:37,670 --> 00:16:41,510
is a kind of cool way to think of a data

00:16:39,650 --> 00:16:45,080
structure and not something I've seen in

00:16:41,510 --> 00:16:47,030
many other places so the next adventure

00:16:45,080 --> 00:16:49,100
we want to go on is navigation matches

00:16:47,030 --> 00:16:51,980
and it's a bit of an adventure because

00:16:49,100 --> 00:16:53,840
they represent how you find things they

00:16:51,980 --> 00:16:56,080
work well with a-star search algorithms

00:16:53,840 --> 00:16:59,720
as a representation of the search space

00:16:56,080 --> 00:17:02,450
so a navigation mesh is a graph and it

00:16:59,720 --> 00:17:03,920
works for 2d or 3d and in general it'll

00:17:02,450 --> 00:17:05,540
produce fewer nodes than other

00:17:03,920 --> 00:17:08,630
representations of a two or three

00:17:05,540 --> 00:17:10,069
dimensional traversable search space so

00:17:08,630 --> 00:17:11,600
the problem being solved is that you

00:17:10,069 --> 00:17:13,160
have some search space you want to

00:17:11,600 --> 00:17:14,900
represent and you need to know which

00:17:13,160 --> 00:17:17,089
areas of it can be traversed and which

00:17:14,900 --> 00:17:18,980
can't and probably want a path find

00:17:17,089 --> 00:17:21,920
around it typically in like a game or

00:17:18,980 --> 00:17:23,839
something so some of the other

00:17:21,920 --> 00:17:26,510
representations we might have for this

00:17:23,839 --> 00:17:29,000
are a grid right we can look at a grid

00:17:26,510 --> 00:17:31,430
with some example map here and you can

00:17:29,000 --> 00:17:34,370
see that there's a lot of nodes and also

00:17:31,430 --> 00:17:37,040
the edges are quite jagged so it doesn't

00:17:34,370 --> 00:17:39,350
really smoothly fit the walls and so if

00:17:37,040 --> 00:17:41,300
we want a path find from that little

00:17:39,350 --> 00:17:42,740
nook in the bottom left on the right

00:17:41,300 --> 00:17:44,280
side of the map to the Nook in the

00:17:42,740 --> 00:17:47,490
bottom right corner on the left

00:17:44,280 --> 00:17:50,130
of the map like so the path takes 17

00:17:47,490 --> 00:17:53,490
nodes and there's 370 total nodes

00:17:50,130 --> 00:17:55,380
required to represent this map so that's

00:17:53,490 --> 00:17:57,900
not great and we can probably do a

00:17:55,380 --> 00:18:00,150
little bit better so if we look at a hex

00:17:57,900 --> 00:18:02,520
grid representation there's also a lot

00:18:00,150 --> 00:18:04,260
of nodes and it doesn't handle the walls

00:18:02,520 --> 00:18:06,870
in corners very well but at least this

00:18:04,260 --> 00:18:08,940
one it has equidistant nodes so even if

00:18:06,870 --> 00:18:10,830
you're moving diagonally or whatever the

00:18:08,940 --> 00:18:13,680
cost for moving from one node to the

00:18:10,830 --> 00:18:15,870
next is equal but it also has some

00:18:13,680 --> 00:18:18,540
issues with you know not perfectly

00:18:15,870 --> 00:18:21,210
representing the search space so if we

00:18:18,540 --> 00:18:23,010
run that same search again we can find

00:18:21,210 --> 00:18:25,260
that 9 nodes are used which is a lot

00:18:23,010 --> 00:18:29,040
better than before and 85 total nodes is

00:18:25,260 --> 00:18:30,390
also quite a bit better but I still

00:18:29,040 --> 00:18:33,510
think that we can do better so let's

00:18:30,390 --> 00:18:35,460
look at what an AB mesh can do this is a

00:18:33,510 --> 00:18:38,340
triangle based nav mesh so all of the

00:18:35,460 --> 00:18:39,900
nodes in this graph are triangles and as

00:18:38,340 --> 00:18:41,730
you can see it uses a lot less nodes

00:18:39,900 --> 00:18:43,920
than any of the previous representations

00:18:41,730 --> 00:18:45,870
it smoothly handles the walls and

00:18:43,920 --> 00:18:47,730
corners and it's a pretty tight

00:18:45,870 --> 00:18:49,140
representation of the search space but

00:18:47,730 --> 00:18:51,540
there are some oddities like those

00:18:49,140 --> 00:18:55,350
little skewed triangles that are really

00:18:51,540 --> 00:18:57,360
thin and don't do a lot so our path this

00:18:55,350 --> 00:18:59,610
time is 7 nodes which is only a couple

00:18:57,360 --> 00:19:01,470
less than before but that's also one of

00:18:59,610 --> 00:19:04,380
the worst cases for this particular Maps

00:19:01,470 --> 00:19:06,450
triangle representation and the 16 total

00:19:04,380 --> 00:19:08,400
nodes is a lot better so in your worst

00:19:06,450 --> 00:19:09,510
case search you're gonna come out a lot

00:19:08,400 --> 00:19:12,920
further ahead than you would have

00:19:09,510 --> 00:19:16,040
otherwise finally we can look at a

00:19:12,920 --> 00:19:19,230
triangle and quad based nav mesh

00:19:16,040 --> 00:19:22,200
representation so in this there's very

00:19:19,230 --> 00:19:24,150
few nodes the walls and corners are all

00:19:22,200 --> 00:19:27,120
smoothly handled it's got a pretty clean

00:19:24,150 --> 00:19:29,640
layout it tightly represents the search

00:19:27,120 --> 00:19:31,740
space and as an added bonus all of that

00:19:29,640 --> 00:19:34,500
expensive triangle math is mostly

00:19:31,740 --> 00:19:38,550
avoided with just one triangle on this

00:19:34,500 --> 00:19:41,400
representation so our search example

00:19:38,550 --> 00:19:43,410
here we only have to cross three nodes

00:19:41,400 --> 00:19:45,690
to get from start to finish that's a

00:19:43,410 --> 00:19:47,970
huge improvement from our start as well

00:19:45,690 --> 00:19:50,130
as the 9 total nodes so for this

00:19:47,970 --> 00:19:51,960
particular example it was one order of

00:19:50,130 --> 00:19:54,270
magnitude better for the search from the

00:19:51,960 --> 00:19:56,040
original grid representation and 2

00:19:54,270 --> 00:19:58,039
orders of magnitude better for the total

00:19:56,040 --> 00:20:01,739
search space representation

00:19:58,039 --> 00:20:03,690
so that's a big improvement so the big

00:20:01,739 --> 00:20:07,079
takeaways from a navigation mesh are

00:20:03,690 --> 00:20:09,299
that it represents the data in the way

00:20:07,079 --> 00:20:11,159
that it exists better and so that's

00:20:09,299 --> 00:20:13,950
something that we can keep in mind as we

00:20:11,159 --> 00:20:15,389
build solutions to our own problems just

00:20:13,950 --> 00:20:17,309
because there might be a common

00:20:15,389 --> 00:20:18,779
representation for similar problems

00:20:17,309 --> 00:20:21,419
doesn't necessarily mean it's the best

00:20:18,779 --> 00:20:23,209
way to do it and in this case we're able

00:20:21,419 --> 00:20:25,289
to make each node store a lot more data

00:20:23,209 --> 00:20:27,989
rather than having to have each

00:20:25,289 --> 00:20:29,729
individual grid cell connected with all

00:20:27,989 --> 00:20:31,409
those edges were able to make much

00:20:29,729 --> 00:20:33,359
larger ones that cover a big swath of

00:20:31,409 --> 00:20:37,440
area that's easily traversable with no

00:20:33,359 --> 00:20:39,299
obstacles between it I'd also like to

00:20:37,440 --> 00:20:41,399
talk about hash pointers either another

00:20:39,299 --> 00:20:43,440
really cool data structure so they're

00:20:41,399 --> 00:20:46,289
from the name you might have guessed a

00:20:43,440 --> 00:20:48,989
pointer but what they also do is store a

00:20:46,289 --> 00:20:50,549
hash of what they're pointing at and so

00:20:48,989 --> 00:20:52,979
because of this you're able to verify

00:20:50,549 --> 00:20:55,469
the data is the same state that it was

00:20:52,979 --> 00:20:57,089
in when you first put it there or got

00:20:55,469 --> 00:21:00,149
your pointer to it and it's pretty

00:20:57,089 --> 00:21:03,239
tamper resistant the problem being

00:21:00,149 --> 00:21:05,129
solved by a hash pointer is that you

00:21:03,239 --> 00:21:07,769
need to locate your data and you want to

00:21:05,129 --> 00:21:10,320
verify that it hasn't been changed since

00:21:07,769 --> 00:21:12,299
you got your pointer to it so this is a

00:21:10,320 --> 00:21:14,579
really useful tool and it's found in a

00:21:12,299 --> 00:21:16,289
few places mainly in blockchain and

00:21:14,579 --> 00:21:17,969
Merkle trees which are the two data

00:21:16,289 --> 00:21:19,679
structures that are derived from it and

00:21:17,969 --> 00:21:21,450
both of those are common in

00:21:19,679 --> 00:21:25,229
cryptocurrencies which has become quite

00:21:21,450 --> 00:21:26,759
popular these days the way that it works

00:21:25,229 --> 00:21:28,739
is you'll have the pointer to the data

00:21:26,759 --> 00:21:30,299
and the hash of the data as you can see

00:21:28,739 --> 00:21:34,019
in this example here pretty

00:21:30,299 --> 00:21:37,200
straightforward so for a blockchain one

00:21:34,019 --> 00:21:40,019
of the first derivatives we have the

00:21:37,200 --> 00:21:42,450
hash pointer as well as some data that

00:21:40,019 --> 00:21:44,339
makes up that block and each of these

00:21:42,450 --> 00:21:46,289
blocks has a hash pointer to the

00:21:44,339 --> 00:21:47,849
previous block and so using this

00:21:46,289 --> 00:21:53,219
technique you can make something like a

00:21:47,849 --> 00:21:56,789
secure log or cryptocurrency which logs

00:21:53,219 --> 00:21:58,739
the transactions so the way that tamper

00:21:56,789 --> 00:22:00,539
detection works is you know say you have

00:21:58,739 --> 00:22:02,820
some case where a black hat wants money

00:22:00,539 --> 00:22:04,499
and they want to go alter the blockchain

00:22:02,820 --> 00:22:06,359
to give themself more money in a

00:22:04,499 --> 00:22:08,969
transaction that never actually happened

00:22:06,359 --> 00:22:11,260
and so you know ideally they would just

00:22:08,969 --> 00:22:12,790
go in and change history to

00:22:11,260 --> 00:22:15,120
that transaction and all of a sudden

00:22:12,790 --> 00:22:18,370
they're really rich sounds great right

00:22:15,120 --> 00:22:22,000
not for everybody else so the way that

00:22:18,370 --> 00:22:23,890
we can figure out how this is solved is

00:22:22,000 --> 00:22:25,360
actually just diving in and seeing what

00:22:23,890 --> 00:22:29,590
it looks like if someone were to try to

00:22:25,360 --> 00:22:30,760
modify a value in a blockchain so the

00:22:29,590 --> 00:22:33,130
first thing that we're gonna do is

00:22:30,760 --> 00:22:34,540
assume that this data has been modified

00:22:33,130 --> 00:22:37,830
in some way so we're gonna represent

00:22:34,540 --> 00:22:40,270
that with red so seems straightforward

00:22:37,830 --> 00:22:42,580
and any other data structure this would

00:22:40,270 --> 00:22:46,000
probably be a problem but not with block

00:22:42,580 --> 00:22:48,160
chains and hash pointers the hash for

00:22:46,000 --> 00:22:50,590
the next block has now been invalidated

00:22:48,160 --> 00:22:52,480
since the date has changed and so that

00:22:50,590 --> 00:22:53,760
means that we can detect that the data

00:22:52,480 --> 00:22:57,220
was tampered with

00:22:53,760 --> 00:23:00,340
so that works and it only took one block

00:22:57,220 --> 00:23:03,160
to do so but let's say we have a really

00:23:00,340 --> 00:23:05,500
really persistent hacker here and they

00:23:03,160 --> 00:23:07,570
want to tamper with the hash - so let's

00:23:05,500 --> 00:23:09,220
see what happens when they do that they

00:23:07,570 --> 00:23:11,740
go in and they tamper with the hash and

00:23:09,220 --> 00:23:15,250
now our hash pointer is valid again but

00:23:11,740 --> 00:23:18,820
oh wait it's all better right they've

00:23:15,250 --> 00:23:21,070
got their money but not so fast

00:23:18,820 --> 00:23:23,320
there's the hash of the next block and

00:23:21,070 --> 00:23:25,450
so that one has now been invalidated

00:23:23,320 --> 00:23:28,870
because those hash pointers are stored

00:23:25,450 --> 00:23:30,490
within the the blocks themselves and so

00:23:28,870 --> 00:23:32,650
the hash for the next item down the

00:23:30,490 --> 00:23:36,460
chain includes the hash for the previous

00:23:32,650 --> 00:23:39,130
one so in order to fix this they'd have

00:23:36,460 --> 00:23:41,500
to change the next hash as well so let's

00:23:39,130 --> 00:23:43,240
say they do that and they run into the

00:23:41,500 --> 00:23:46,120
same problem again with the newest item

00:23:43,240 --> 00:23:48,010
on the blockchain again the hash has

00:23:46,120 --> 00:23:49,690
been invalid and it will no longer be an

00:23:48,010 --> 00:23:53,230
accurate representation of the previous

00:23:49,690 --> 00:23:55,330
block so with block chains tampering is

00:23:53,230 --> 00:23:57,640
really hard and every downstream block

00:23:55,330 --> 00:24:00,730
must be modified in order to have a

00:23:57,640 --> 00:24:03,340
successful attack the downside of this

00:24:00,730 --> 00:24:05,110
is that detecting these attacks is an Oh

00:24:03,340 --> 00:24:07,450
an operation you have to go through all

00:24:05,110 --> 00:24:10,720
of the entries in the block chain after

00:24:07,450 --> 00:24:12,370
it in order to detect it correctly on so

00:24:10,720 --> 00:24:14,830
there's another approach which is a

00:24:12,370 --> 00:24:16,720
miracle tree this is a tree based data

00:24:14,830 --> 00:24:19,360
structure made by Ralph Merkle that also

00:24:16,720 --> 00:24:21,460
is based on hash pointers and in this

00:24:19,360 --> 00:24:25,410
one only the leaves hold data all of the

00:24:21,460 --> 00:24:28,300
nodes up the tree simply contain hash

00:24:25,410 --> 00:24:30,910
so this is roughly what a miracle tree

00:24:28,300 --> 00:24:33,490
would look like at the top you have a

00:24:30,910 --> 00:24:35,260
couple of hash pointers for the left and

00:24:33,490 --> 00:24:37,150
right side and then each of those will

00:24:35,260 --> 00:24:41,140
also have hash pointers and then down at

00:24:37,150 --> 00:24:44,530
the bottom you have just the data and so

00:24:41,140 --> 00:24:46,420
to detect tampers and a miracle tree you

00:24:44,530 --> 00:24:48,160
have to traverse to the element from the

00:24:46,420 --> 00:24:50,290
start of the tree which is ol log n

00:24:48,160 --> 00:24:52,750
since it's a tree so that's a bit better

00:24:50,290 --> 00:24:54,520
as far as tamper detection goes and it's

00:24:52,750 --> 00:24:57,010
easier to detect that your data has been

00:24:54,520 --> 00:24:58,690
modified but if you're a hacker and you

00:24:57,010 --> 00:25:00,490
want to go in and modify the data and

00:24:58,690 --> 00:25:02,500
not get caught you only have to modify

00:25:00,490 --> 00:25:04,510
the things up the tree from whatever

00:25:02,500 --> 00:25:07,560
you're attacking rather than having to

00:25:04,510 --> 00:25:11,350
modify every single block in the chain

00:25:07,560 --> 00:25:13,090
so the takeaways from hash pointer are

00:25:11,350 --> 00:25:15,940
that tamper detection gets really easy

00:25:13,090 --> 00:25:17,860
if you use them because now a hacker has

00:25:15,940 --> 00:25:20,740
to do all of this work changing all of

00:25:17,860 --> 00:25:22,600
the data all over this structure whereas

00:25:20,740 --> 00:25:25,540
you just have to follow it and see that

00:25:22,600 --> 00:25:28,600
all of the hashes work still it also

00:25:25,540 --> 00:25:30,430
means that the hashes can be used for

00:25:28,600 --> 00:25:31,780
more than just finding data but you can

00:25:30,430 --> 00:25:33,880
actually use them to make sure your data

00:25:31,780 --> 00:25:36,250
is unchanged as well and so this can

00:25:33,880 --> 00:25:39,430
have practical applications and all

00:25:36,250 --> 00:25:41,800
sorts of other domains as well so that

00:25:39,430 --> 00:25:43,060
concludes the containers that I'm here

00:25:41,800 --> 00:25:45,310
to talk to you about so if you have

00:25:43,060 --> 00:25:48,190
questions or comments please step up to

00:25:45,310 --> 00:25:55,890
the mics yes

00:25:48,190 --> 00:25:59,890
[Applause]

00:25:55,890 --> 00:26:08,770
mm-hmm can you step up to a mic so they

00:25:59,890 --> 00:26:11,650
get it on the video Thanks hi so about

00:26:08,770 --> 00:26:14,830
the navigation mesh can you please

00:26:11,650 --> 00:26:17,800
explain a bit more about when it's

00:26:14,830 --> 00:26:21,820
useful and how it's how it works because

00:26:17,800 --> 00:26:24,280
I yeah so it's a graph representation

00:26:21,820 --> 00:26:25,810
just like a grid would be or any other

00:26:24,280 --> 00:26:28,780
graph that you might be used to with

00:26:25,810 --> 00:26:30,640
nodes and edges and it's used typically

00:26:28,780 --> 00:26:31,720
in games for two-dimensional and

00:26:30,640 --> 00:26:33,850
three-dimensional search based

00:26:31,720 --> 00:26:35,830
representation for path finding problems

00:26:33,850 --> 00:26:37,870
so you have a character that wants to go

00:26:35,830 --> 00:26:39,670
from point A to point B and there's only

00:26:37,870 --> 00:26:41,770
certain areas of the map that they can

00:26:39,670 --> 00:26:44,500
walk on and those areas are connected in

00:26:41,770 --> 00:26:46,000
some ways the navigation mesh represents

00:26:44,500 --> 00:26:48,610
those and you're going to typically use

00:26:46,000 --> 00:26:54,100
an a-star search to get from point A to

00:26:48,610 --> 00:26:55,600
point B okay okay I don't really

00:26:54,100 --> 00:27:00,880
understand the actual implementation

00:26:55,600 --> 00:27:04,450
though like the other other data

00:27:00,880 --> 00:27:13,900
structures you mentioned so it's a what

00:27:04,450 --> 00:27:18,430
specifically do you mean we can talk

00:27:13,900 --> 00:27:21,880
after so for the bloom filters is there

00:27:18,430 --> 00:27:23,980
a concept of delete and if so how does

00:27:21,880 --> 00:27:27,880
no bloom filters don't support delete

00:27:23,980 --> 00:27:31,330
but there are some other derived types

00:27:27,880 --> 00:27:35,340
of data structures that use a similar

00:27:31,330 --> 00:27:39,280
technique and some of them do okay oh

00:27:35,340 --> 00:27:40,870
and today just keep another structure on

00:27:39,280 --> 00:27:43,210
top of that that yeah typically they're

00:27:40,870 --> 00:27:44,860
gonna use more memory and that's how

00:27:43,210 --> 00:27:47,680
they're able to do it like for example a

00:27:44,860 --> 00:27:50,110
countenance sketch will have multiple

00:27:47,680 --> 00:27:52,330
arrays of the bits rather than just a

00:27:50,110 --> 00:27:57,870
single one and each hash gets its own

00:27:52,330 --> 00:27:57,870
array thank you yep

00:27:58,170 --> 00:28:03,380
it's there a well-known algorithm for

00:28:00,390 --> 00:28:06,990
the navigation mesh for decomposing the

00:28:03,380 --> 00:28:10,020
the unblocked polygon into rectangles

00:28:06,990 --> 00:28:12,620
and triangles so this is the graph yes

00:28:10,020 --> 00:28:15,860
so the most commonly used approach is

00:28:12,620 --> 00:28:18,600
through a software package called recast

00:28:15,860 --> 00:28:21,330
it's open source available on github

00:28:18,600 --> 00:28:24,540
it's used by both unity and unreal

00:28:21,330 --> 00:28:27,230
engines and so typically anyone going

00:28:24,540 --> 00:28:29,910
with a navigation mesh would use that I

00:28:27,230 --> 00:28:32,370
don't know all of the details of how the

00:28:29,910 --> 00:28:33,660
nav measures are constructed by it but I

00:28:32,370 --> 00:28:38,840
know one approaches something like a

00:28:33,660 --> 00:28:42,450
flood fill you're welcome

00:28:38,840 --> 00:28:44,490
this is just a comment about hash

00:28:42,450 --> 00:28:48,450
pointer is possibly a more commonly

00:28:44,490 --> 00:28:53,490
known example is good revisions what get

00:28:48,450 --> 00:28:56,160
revisions themselves each revision is a

00:28:53,490 --> 00:28:59,010
hash of its entire log all the way back

00:28:56,160 --> 00:29:01,350
to the very initial commit that created

00:28:59,010 --> 00:29:07,470
the repository so it's pretty much on

00:29:01,350 --> 00:29:10,830
the same idea yeah so on the navigation

00:29:07,470 --> 00:29:12,240
map map it seems that your area just

00:29:10,830 --> 00:29:16,350
gets bigger and bigger so you don't

00:29:12,240 --> 00:29:19,590
really have a detail on the path I don't

00:29:16,350 --> 00:29:23,220
understand in terms of the trade-offs

00:29:19,590 --> 00:29:26,100
knowing what kind of path how much path

00:29:23,220 --> 00:29:28,260
do you need to know so the way that the

00:29:26,100 --> 00:29:31,050
navigation mesh works is each node will

00:29:28,260 --> 00:29:33,150
only represent traversable terrain and

00:29:31,050 --> 00:29:34,890
so you don't actually have to represent

00:29:33,150 --> 00:29:37,610
terrain that can't be traversed because

00:29:34,890 --> 00:29:41,220
there simply won't be a node for it okay

00:29:37,610 --> 00:29:45,110
so it's all a matter of the application

00:29:41,220 --> 00:29:47,520
how much how much area in each node

00:29:45,110 --> 00:29:49,440
correct yeah and then you just go

00:29:47,520 --> 00:29:50,940
between the edges of the nodes to find

00:29:49,440 --> 00:29:54,770
where you can go from your current

00:29:50,940 --> 00:29:54,770
position okay thanks yep

00:29:57,410 --> 00:30:01,320
looks like there's no more questions

00:29:59,790 --> 00:30:05,910
thank you all for coming

00:30:01,320 --> 00:30:05,910

YouTube URL: https://www.youtube.com/watch?v=-8UZhDjgeZU


