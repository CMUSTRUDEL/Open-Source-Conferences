Title: CppCon 2017: Alisdair Meredith “An allocator model for std2”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
C++17 reserves the namespace std2 (and others) for future iterations of the standard library that may not be 100% compatible in design with the current namespace std. This session will suggest a much simpler allocator model that might be useful for that new library.

What is an allocator model, and why should we care? There are a variety of experiments and benchmarks around now demonstrating the benefits that a well-chosen allocator can bring to performance-sensitive code. We would like to bring those benefits to any new standard library, but without the complexity that plagues the specification of allocators in the current standard library. An allocator model is a set of rules for writing and supplying allocators to typed and objects, and the set of rules those types should follow when using a custom allocator. Following the principle that you should not pay for what you do not use, we will look into creating a model with minimal impact on code and complexity on users — in fact we will demonstrate (in theory) a model that will typically involve writing no code for users to support custom allocators in their type, and a runtime cost that can be entirely eliminated in programs that never choose a custom allocator! 

This presentation is a thought experiment in a possible future direction, and still a year or so away from becoming a proposal for standardization — in particular it will rely on creating a new language feature that we should demonstrate in a practical compiler. It offers a vision of a possible future for the language, and some of the problems that we would like to solve.
— 
Alisdair Meredith: Bloomberg LP, Senior Software Developer

Alisdair Meredith is a software developer at BloombergLP in New York, and the C++ Standard Committee Library Working Group chair.

He has been an active member of the C++ committee for just over a decade, and by a lucky co-incidence his first meeting was the kick-off meeting for the project that would become C++11, and also fixed the contents of the original library TR.

He is currently working on the BDE project, BloombergLP's open source libraries that offer a foundation for C++ development, including a standard library implementation supporting the polymorphic allocator model proposed for standardization.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,380 --> 00:00:05,250
okay quick introduction for those of you

00:00:02,639 --> 00:00:09,030
who don't know me I'm Alistair Meredith

00:00:05,250 --> 00:00:10,139
I work at Bloomberg my thing me playing

00:00:09,030 --> 00:00:14,179
with recently have now got a Twitter

00:00:10,139 --> 00:00:16,289
handle hours tomorrow a Twitter but well

00:00:14,179 --> 00:00:19,320
generally I tweet just around about the

00:00:16,289 --> 00:00:20,460
ISO standard meetings so give a quick

00:00:19,320 --> 00:00:23,160
update as to what's been happening at

00:00:20,460 --> 00:00:25,140
that week so the other my other sin is I

00:00:23,160 --> 00:00:27,840
like to attend ISO standard meeting

00:00:25,140 --> 00:00:30,599
which is where this presentation is

00:00:27,840 --> 00:00:31,769
going to go I'm going to suggest how

00:00:30,599 --> 00:00:34,020
expect to achieve leader there is no

00:00:31,769 --> 00:00:35,969
endorsement for another Bloomberg or the

00:00:34,020 --> 00:00:37,890
ISO process of this yet but this is

00:00:35,969 --> 00:00:40,079
something I hope to be forking over the

00:00:37,890 --> 00:00:41,850
next 12 months the idea of a new

00:00:40,079 --> 00:00:46,739
allocator model for the new standard

00:00:41,850 --> 00:00:49,079
library so we'll start with the simple

00:00:46,739 --> 00:00:50,250
question of what is an allocator let's

00:00:49,079 --> 00:00:55,289
be sure we at least know what we think

00:00:50,250 --> 00:00:56,969
I'm talking about an allocator I've got

00:00:55,289 --> 00:01:00,719
I can look down here and see well

00:00:56,969 --> 00:01:03,780
clearly it's a service that grants

00:01:00,719 --> 00:01:05,549
exclusive use of a region of memory to

00:01:03,780 --> 00:01:08,729
the clients that are going to need to

00:01:05,549 --> 00:01:11,610
use memory that's my basic notion that

00:01:08,729 --> 00:01:13,530
what in allocator has to do it's got a

00:01:11,610 --> 00:01:15,540
second side if it got nice well-behaved

00:01:13,530 --> 00:01:17,070
clients they might want to tell the

00:01:15,540 --> 00:01:20,369
allocator when they're finished using

00:01:17,070 --> 00:01:24,030
that memory so it can reuse that region

00:01:20,369 --> 00:01:27,860
now somewhere else so that's my basic

00:01:24,030 --> 00:01:27,860
model of what an allocator isn't does

00:01:28,759 --> 00:01:37,200
why do we want allocators and the

00:01:34,939 --> 00:01:39,689
fundamental question here is is the new

00:01:37,200 --> 00:01:42,350
operator not good enough can we get by

00:01:39,689 --> 00:01:44,790
just making the new operator better and

00:01:42,350 --> 00:01:46,860
don't get me wrong we all want better

00:01:44,790 --> 00:01:48,720
new operators that's not a reason to

00:01:46,860 --> 00:01:52,439
stop investing in research and making

00:01:48,720 --> 00:01:56,360
this better so the fundamental reason I

00:01:52,439 --> 00:01:59,189
believe allocators is performance

00:01:56,360 --> 00:02:02,100
shortly followed by performance and then

00:01:59,189 --> 00:02:04,469
more performance this from talking to

00:02:02,100 --> 00:02:06,149
folks who've actually tried working in

00:02:04,469 --> 00:02:08,610
if the main seems to be the key driving

00:02:06,149 --> 00:02:10,590
factor it's actually not what I tend to

00:02:08,610 --> 00:02:11,940
use them for so much at work and I tend

00:02:10,590 --> 00:02:13,540
to use my fourth option here

00:02:11,940 --> 00:02:17,240
instrumentation ëifí

00:02:13,540 --> 00:02:19,310
being able to enrich the information you

00:02:17,240 --> 00:02:21,950
have with an allocated query its usage

00:02:19,310 --> 00:02:23,960
it has been very beneficial for us but

00:02:21,950 --> 00:02:26,630
I'm an outlier performance is the main

00:02:23,960 --> 00:02:30,620
reason this whole talk was created in

00:02:26,630 --> 00:02:31,730
the first place and final note on things

00:02:30,620 --> 00:02:35,330
people want sometimes want to use

00:02:31,730 --> 00:02:37,190
allocators for is a special memory

00:02:35,330 --> 00:02:41,960
access I've got to fly them out of that

00:02:37,190 --> 00:02:44,240
just coming up shortly so when it comes

00:02:41,960 --> 00:02:47,270
to performance I'm not going to say too

00:02:44,240 --> 00:02:48,770
much about that now here's hopefully

00:02:47,270 --> 00:02:52,730
tomorrow at 2 o'clock

00:02:48,770 --> 00:02:54,530
in room 403 John Lake us is giving a

00:02:52,730 --> 00:02:57,110
talk all about the measurements we've

00:02:54,530 --> 00:02:58,970
done benchmarking to try to determine

00:02:57,110 --> 00:03:01,250
the benefits we can get from different

00:02:58,970 --> 00:03:03,290
allocated strategies whether they're you

00:03:01,250 --> 00:03:05,030
about how useful they are whether we can

00:03:03,290 --> 00:03:09,230
measure it and we think we have some

00:03:05,030 --> 00:03:11,600
good results to show there but my quick

00:03:09,230 --> 00:03:14,690
takeaway from that with sifting through

00:03:11,600 --> 00:03:16,820
what winds and reams of data is when we

00:03:14,690 --> 00:03:19,280
benchmark the performance of the

00:03:16,820 --> 00:03:21,709
allocator just doing allocation type

00:03:19,280 --> 00:03:24,170
behavior where we have a well kills an

00:03:21,709 --> 00:03:27,230
alligator we can typically get a three

00:03:24,170 --> 00:03:30,380
to five factor increase on throughput on

00:03:27,230 --> 00:03:32,209
the alligator and if you start finding

00:03:30,380 --> 00:03:33,560
out you know that the extreme cut out

00:03:32,209 --> 00:03:37,580
wires we can certainly get orders of

00:03:33,560 --> 00:03:39,770
magnitude the interesting thing that

00:03:37,580 --> 00:03:41,780
came out of this research though was

00:03:39,770 --> 00:03:43,070
that again if you're in the previous

00:03:41,780 --> 00:03:46,100
talk you'll have heard some some about

00:03:43,070 --> 00:03:48,040
this is that better memory locality that

00:03:46,100 --> 00:03:50,690
you get more well kills an alligator

00:03:48,040 --> 00:03:53,840
buys you significantly more performance

00:03:50,690 --> 00:03:56,050
after the allocation so this is the real

00:03:53,840 --> 00:04:00,470
performance that we're trying to achieve

00:03:56,050 --> 00:04:02,150
by allocating memory locally so it's

00:04:00,470 --> 00:04:04,030
friendly for cache lines in future

00:04:02,150 --> 00:04:07,010
access and use throughout the system

00:04:04,030 --> 00:04:09,920
you're going to get generally a faster

00:04:07,010 --> 00:04:11,510
program so we on your hot path and the

00:04:09,920 --> 00:04:14,900
other the performance intensive parts of

00:04:11,510 --> 00:04:17,060
your code and this is where the notion

00:04:14,900 --> 00:04:18,980
of memory pools comes in but different

00:04:17,060 --> 00:04:21,710
structures will allocate from different

00:04:18,980 --> 00:04:25,680
pools so each pool will keep the data

00:04:21,710 --> 00:04:27,449
local for a specific container graph

00:04:25,680 --> 00:04:30,210
overwhelming data strictly or whatever

00:04:27,449 --> 00:04:32,280
you've got having a separate pool for

00:04:30,210 --> 00:04:33,720
each data structure at least the ones

00:04:32,280 --> 00:04:36,210
you care about for your performance

00:04:33,720 --> 00:04:38,430
critical code can make your risk

00:04:36,210 --> 00:04:41,330
substantial improvement on the runtime

00:04:38,430 --> 00:04:41,330
of your application

00:04:43,320 --> 00:04:47,729
another observation when you've got

00:04:45,360 --> 00:04:50,430
long-running processes memory

00:04:47,729 --> 00:04:51,900
fragmentation over the whole address

00:04:50,430 --> 00:04:54,090
space can become a concern if you're

00:04:51,900 --> 00:04:57,419
trying to run this process for months

00:04:54,090 --> 00:05:00,360
weeks years whatever and if you can

00:04:57,419 --> 00:05:02,330
allocate memory locally off the current

00:05:00,360 --> 00:05:07,100
stack frame if you've got small

00:05:02,330 --> 00:05:10,650
allocations this can substantially again

00:05:07,100 --> 00:05:13,289
reduce the eventual drag on the system

00:05:10,650 --> 00:05:15,930
as a whole so that's another place where

00:05:13,289 --> 00:05:17,580
we can gain performance and indeed gain

00:05:15,930 --> 00:05:20,250
reliability over a long-running

00:05:17,580 --> 00:05:32,190
evolution of that of long long-running

00:05:20,250 --> 00:05:35,370
server processes key issue I hate to

00:05:32,190 --> 00:05:36,720
harp on this but again I just started to

00:05:35,370 --> 00:05:38,130
talk where we spend an awful the time

00:05:36,720 --> 00:05:39,690
talking about you know the benefits so

00:05:38,130 --> 00:05:41,340
you know getting good cache locality so

00:05:39,690 --> 00:05:43,770
I feel redundant having just say a line

00:05:41,340 --> 00:05:47,130
or two about it here but the more you

00:05:43,770 --> 00:05:50,070
can take advantage of well-aligned

00:05:47,130 --> 00:05:52,470
memory with the right pages to shoot

00:05:50,070 --> 00:05:53,430
through your l1 l2 caches the more

00:05:52,470 --> 00:05:56,669
performance you're going to get out of

00:05:53,430 --> 00:05:59,520
your process and to do that you really

00:05:56,669 --> 00:06:02,070
want to be able to give the allocation

00:05:59,520 --> 00:06:03,659
system some hints to say this memory I

00:06:02,070 --> 00:06:05,220
want to keep collected over here and

00:06:03,659 --> 00:06:07,949
this memory over here so they're in

00:06:05,220 --> 00:06:11,449
distinct regions and you can't get that

00:06:07,949 --> 00:06:13,949
from the simple hints to operate on you

00:06:11,449 --> 00:06:16,229
as two main strategies we've been using

00:06:13,949 --> 00:06:17,520
it effectively referencing on those

00:06:16,229 --> 00:06:20,400
previous slides and John will be talking

00:06:17,520 --> 00:06:22,979
about tomorrow one we try and allocate

00:06:20,400 --> 00:06:24,330
off the thread stack that keeps that's

00:06:22,979 --> 00:06:25,919
as local as memory can get because

00:06:24,330 --> 00:06:27,210
that's where your instruction processes

00:06:25,919 --> 00:06:31,050
everything is going through it's where

00:06:27,210 --> 00:06:32,460
all your local data is and you're not

00:06:31,050 --> 00:06:34,500
having to do additional management the

00:06:32,460 --> 00:06:38,659
the stack just takes care of itself

00:06:34,500 --> 00:06:38,659
essentially with a compiler

00:06:41,830 --> 00:06:50,199
the other thing that is very beneficial

00:06:44,360 --> 00:06:52,430
is as I said managing pools when we I

00:06:50,199 --> 00:06:54,349
should provide an extra slide in here

00:06:52,430 --> 00:06:56,479
about the active alligators we use the

00:06:54,349 --> 00:06:57,979
notion of our stack allocation is we're

00:06:56,479 --> 00:07:01,159
going to allocate to but provide a

00:06:57,979 --> 00:07:02,360
precise buffer on the stack and at some

00:07:01,159 --> 00:07:03,620
point you might exceed that buffer in

00:07:02,360 --> 00:07:06,050
which case we'll go and grab a bit more

00:07:03,620 --> 00:07:08,259
from dynamic memory we've got a buffer

00:07:06,050 --> 00:07:10,789
that we treat as one can take one long

00:07:08,259 --> 00:07:12,139
region of memory that is very keep to

00:07:10,789 --> 00:07:13,970
allocate from all we're going to do is

00:07:12,139 --> 00:07:16,580
move the stack pointer through it and we

00:07:13,970 --> 00:07:17,900
never give that memory back this is very

00:07:16,580 --> 00:07:19,610
good for certain kinds of data

00:07:17,900 --> 00:07:22,190
structures and this as I say the stack

00:07:19,610 --> 00:07:25,099
base problem notion of some curve works

00:07:22,190 --> 00:07:26,930
very well the problem is if you start

00:07:25,099 --> 00:07:28,280
turning memory you're handing back to

00:07:26,930 --> 00:07:31,190
the allocator and reusing it that

00:07:28,280 --> 00:07:32,870
quickly will exhaust what it can do so

00:07:31,190 --> 00:07:37,789
the other notion is you have a pool that

00:07:32,870 --> 00:07:40,039
wall when you got all managers some

00:07:37,789 --> 00:07:41,509
allocations in there so when you can the

00:07:40,039 --> 00:07:42,319
memory back to the pooling you request a

00:07:41,509 --> 00:07:43,909
similar buffer

00:07:42,319 --> 00:07:45,440
somewhere I'm out so I'm inserting in

00:07:43,909 --> 00:07:48,949
the erasing frequently from a single

00:07:45,440 --> 00:07:50,690
container that memory gets reused much

00:07:48,949 --> 00:07:52,219
more frequently and then again this is

00:07:50,690 --> 00:07:55,099
where you want separate pools for the

00:07:52,219 --> 00:07:56,990
separate data structures and you can

00:07:55,099 --> 00:07:58,340
layer one of these on top of the other

00:07:56,990 --> 00:08:00,469
which there means my problem I was

00:07:58,340 --> 00:08:02,539
saying with the very efficient stack

00:08:00,469 --> 00:08:03,889
allocation where we just move the stack

00:08:02,539 --> 00:08:06,400
pointer all the way through and we never

00:08:03,889 --> 00:08:09,590
reclaim the memory if you put a pool

00:08:06,400 --> 00:08:11,120
allocation in front of that that will

00:08:09,590 --> 00:08:13,759
mitigate the fact that you've now got

00:08:11,120 --> 00:08:16,310
something that is managing that bit of

00:08:13,759 --> 00:08:19,520
memory you've grabbed my bad I should

00:08:16,310 --> 00:08:20,990
put an extra slide or two in there so

00:08:19,520 --> 00:08:23,479
but the fundamental question is why do

00:08:20,990 --> 00:08:26,900
we want allocators and is the new

00:08:23,479 --> 00:08:28,400
operator not good enough and the

00:08:26,900 --> 00:08:30,349
observation is most of the time when you

00:08:28,400 --> 00:08:32,419
operate it actually is pretty good in it

00:08:30,349 --> 00:08:34,820
pretty good it's good enough but when

00:08:32,419 --> 00:08:36,349
you get to this essential critical parts

00:08:34,820 --> 00:08:38,899
of your system the parts where

00:08:36,349 --> 00:08:41,479
performance really matters and you as

00:08:38,899 --> 00:08:43,039
the application developer have much more

00:08:41,479 --> 00:08:45,410
information about the context and the

00:08:43,039 --> 00:08:47,209
way you're using the memory you can make

00:08:45,410 --> 00:08:49,699
a real difference here and when you want

00:08:47,209 --> 00:08:50,760
to plug something in operating you

00:08:49,699 --> 00:08:52,890
doesn't give you

00:08:50,760 --> 00:08:54,480
you the knobs and whistles that you need

00:08:52,890 --> 00:08:57,390
in order to control that make that

00:08:54,480 --> 00:09:03,150
facility so that's where we want to use

00:08:57,390 --> 00:09:05,040
allocators I said an extra-extra

00:09:03,150 --> 00:09:07,230
facility we have once you have the

00:09:05,040 --> 00:09:08,880
ability to plug in allocators is you can

00:09:07,230 --> 00:09:12,600
do extra utilitarian things with them

00:09:08,880 --> 00:09:14,930
you can have them to support debugging

00:09:12,600 --> 00:09:17,220
you can log your memory allocations

00:09:14,930 --> 00:09:20,700
which is on the way to us being a

00:09:17,220 --> 00:09:22,140
profiling system and the key when I use

00:09:20,700 --> 00:09:24,510
them is for test drivers so I can

00:09:22,140 --> 00:09:26,760
confirm that when I'm testing my code in

00:09:24,510 --> 00:09:28,860
unit tests that the memory allocation

00:09:26,760 --> 00:09:30,720
behavior is actually allocating the way

00:09:28,860 --> 00:09:33,000
I expect and I don't have an expected

00:09:30,720 --> 00:09:34,770
leaks that will freeze I'm suddenly

00:09:33,000 --> 00:09:37,380
allocating more memory than I expected

00:09:34,770 --> 00:09:39,060
why did that happen I'm having it an

00:09:37,380 --> 00:09:41,010
alligator that's instrumented the test

00:09:39,060 --> 00:09:43,350
drivers is very helpful in maintaining

00:09:41,010 --> 00:09:47,210
the quality of your code and getting the

00:09:43,350 --> 00:09:47,210
behavior you you believe you're getting

00:09:48,680 --> 00:09:55,500
the final corner we have the notion of

00:09:50,880 --> 00:09:57,810
special memory shared memory is probably

00:09:55,500 --> 00:09:59,070
a common example of this where you might

00:09:57,810 --> 00:10:00,330
have some memory of trying to share

00:09:59,070 --> 00:10:03,870
between processes so we need to access

00:10:00,330 --> 00:10:06,660
it in a special way some hardware

00:10:03,870 --> 00:10:08,070
systems have memory with special access

00:10:06,660 --> 00:10:09,600
routines so you have to access in

00:10:08,070 --> 00:10:11,490
different ways numerous systems maybe

00:10:09,600 --> 00:10:13,440
and not your life getting access to the

00:10:11,490 --> 00:10:16,260
VM on video cards these days this isn't

00:10:13,440 --> 00:10:18,450
my area of expertise but I'm assured

00:10:16,260 --> 00:10:19,440
that these systems certainly exist and

00:10:18,450 --> 00:10:21,270
hopefully some of you folks out here

00:10:19,440 --> 00:10:21,510
more experienced them with them than I

00:10:21,270 --> 00:10:23,610
do

00:10:21,510 --> 00:10:29,090
but that's another aspect that people

00:10:23,610 --> 00:10:33,180
look to for allocators so with that

00:10:29,090 --> 00:10:39,300
that's right dying of thirst here it's a

00:10:33,180 --> 00:10:41,490
long day already I would take a quick

00:10:39,300 --> 00:10:46,590
look at the brief history of allocators

00:10:41,490 --> 00:10:47,820
in the C++ standard so let's go back to

00:10:46,590 --> 00:10:49,500
C++ 98

00:10:47,820 --> 00:10:52,020
why did we add alligators to the

00:10:49,500 --> 00:10:54,450
original standard and the answer was

00:10:52,020 --> 00:10:57,720
simple it was near and far pointers back

00:10:54,450 --> 00:10:59,190
to those funny accesses again and that

00:10:57,720 --> 00:11:02,820
was essentially the only reason we had

00:10:59,190 --> 00:11:04,540
to add alligators to C++ 98 but why did

00:11:02,820 --> 00:11:08,140
we do it in the mechanism we did

00:11:04,540 --> 00:11:09,730
he was a speculative notion that if we

00:11:08,140 --> 00:11:11,020
have to customize it for this now we're

00:11:09,730 --> 00:11:13,300
going to what to customize it for more

00:11:11,020 --> 00:11:15,070
things in the future so let's put in the

00:11:13,300 --> 00:11:17,800
facility with a customization point that

00:11:15,070 --> 00:11:20,970
we can then experiment with and start to

00:11:17,800 --> 00:11:20,970
be more interesting useful things with

00:11:21,330 --> 00:11:27,040
so the basic notion I broke teach my

00:11:25,540 --> 00:11:28,330
grandmother to suck eggs here who's

00:11:27,040 --> 00:11:29,950
actually played around with allocators

00:11:28,330 --> 00:11:33,730
and the C++ standard contains some

00:11:29,950 --> 00:11:37,660
things before so I'm seeing a bear half

00:11:33,730 --> 00:11:39,670
the audience so basic model is if you

00:11:37,660 --> 00:11:41,650
have a standard container the template

00:11:39,670 --> 00:11:44,320
parameters have at the end the idea that

00:11:41,650 --> 00:11:45,520
you can say this container works with a

00:11:44,320 --> 00:11:46,900
different kind of alligator than the

00:11:45,520 --> 00:11:51,250
standard allocator that I'm going to

00:11:46,900 --> 00:11:53,440
supply the model that we came up with is

00:11:51,250 --> 00:11:55,990
that alligators are allocating memory

00:11:53,440 --> 00:11:58,180
for objects so the alligator that you

00:11:55,990 --> 00:12:00,190
plug into your container is also going

00:11:58,180 --> 00:12:01,660
to be a template that's parameterised on

00:12:00,190 --> 00:12:04,330
the kind of object which it's going to

00:12:01,660 --> 00:12:06,820
allocate for so for a vector allocates

00:12:04,330 --> 00:12:08,560
int and a vector event and a vector a

00:12:06,820 --> 00:12:09,910
float they're going to have two

00:12:08,560 --> 00:12:11,740
different alligators because one knows

00:12:09,910 --> 00:12:13,960
how to allocate per inch and one knows

00:12:11,740 --> 00:12:15,220
how to allocate super flows even if they

00:12:13,960 --> 00:12:16,570
happen to be the same size returning

00:12:15,220 --> 00:12:18,010
exactly the same amount of memory

00:12:16,570 --> 00:12:21,580
they're different alligator types doing

00:12:18,010 --> 00:12:23,440
different things which means the each

00:12:21,580 --> 00:12:24,730
alligator and each container with these

00:12:23,440 --> 00:12:27,490
different alligator being plugged into

00:12:24,730 --> 00:12:30,280
the nail is a new type in your type

00:12:27,490 --> 00:12:32,110
vocabulary and vocabulary is an

00:12:30,280 --> 00:12:34,720
important issue when it comes to API

00:12:32,110 --> 00:12:36,640
design because if I want to have easy

00:12:34,720 --> 00:12:39,250
inter operation of my code across a

00:12:36,640 --> 00:12:41,650
system I need to be passing common well

00:12:39,250 --> 00:12:43,330
understood types and if every time I

00:12:41,650 --> 00:12:46,300
want to do something subtly different

00:12:43,330 --> 00:12:50,620
with my allocation strategy I create a

00:12:46,300 --> 00:12:52,210
new type is that you type a reasonable

00:12:50,620 --> 00:12:54,130
type to have in the interface do I need

00:12:52,210 --> 00:12:55,570
to do translation now between my time so

00:12:54,130 --> 00:13:01,320
it might mean copying the data around

00:12:55,570 --> 00:13:04,480
again so just for the sake of vocabulary

00:13:01,320 --> 00:13:07,390
having allocators as template parameters

00:13:04,480 --> 00:13:09,970
on our containers could be a bit of a

00:13:07,390 --> 00:13:11,770
problem but it's also bought as a bunch

00:13:09,970 --> 00:13:13,060
of other advantages as well so let's not

00:13:11,770 --> 00:13:15,220
yeah throw the baby out with the

00:13:13,060 --> 00:13:18,020
bathwater straight away we'll do only

00:13:15,220 --> 00:13:20,870
about another 20 slides

00:13:18,020 --> 00:13:23,510
the other thing we got with C++ 98 was

00:13:20,870 --> 00:13:24,950
because the whole notion of allocator

00:13:23,510 --> 00:13:27,560
was a bit speculative in you

00:13:24,950 --> 00:13:30,560
we gave implementations freedom to

00:13:27,560 --> 00:13:32,270
ignore a couple of properties that you

00:13:30,560 --> 00:13:36,980
would get from plugging in an alligator

00:13:32,270 --> 00:13:39,560
when you create your objects and the

00:13:36,980 --> 00:13:41,000
first thing we didn't c++ c 11 as we

00:13:39,560 --> 00:13:42,980
started trying to tackle the notion of

00:13:41,000 --> 00:13:45,560
how well can alligators be used in

00:13:42,980 --> 00:13:48,529
practice we remove those weasel words so

00:13:45,560 --> 00:13:49,790
the notion that back in c plus 98 you

00:13:48,529 --> 00:13:51,380
might have heard that alligators are

00:13:49,790 --> 00:13:53,510
useless because you can't do anything

00:13:51,380 --> 00:13:56,660
with them certainly seems to be true in

00:13:53,510 --> 00:13:59,600
c++ c 11 the kids little bits of wording

00:13:56,660 --> 00:14:01,580
that told vendors I can make simplifying

00:13:59,600 --> 00:14:03,050
assumptions but ignore the vast majority

00:14:01,580 --> 00:14:07,070
of what your alligators going to do

00:14:03,050 --> 00:14:08,870
those have gone away and in order to

00:14:07,070 --> 00:14:10,250
make life a little easier for looking

00:14:08,870 --> 00:14:11,750
the concern

00:14:10,250 --> 00:14:14,000
the container vendors the people

00:14:11,750 --> 00:14:15,890
implementing their data structures we

00:14:14,000 --> 00:14:18,800
provided the alligator traits facility

00:14:15,890 --> 00:14:20,870
which does all the clever work to try to

00:14:18,800 --> 00:14:22,959
figure out sensible defaults and routine

00:14:20,870 --> 00:14:25,450
behavior if you don't have an alligator

00:14:22,959 --> 00:14:28,070
that provides everything so that

00:14:25,450 --> 00:14:30,620
alligator developers focus on just what

00:14:28,070 --> 00:14:32,329
their alligator does contain the folks

00:14:30,620 --> 00:14:34,279
say I'm going to access the services of

00:14:32,329 --> 00:14:36,860
the alligator now through this alligator

00:14:34,279 --> 00:14:39,950
traits rather than going directly to the

00:14:36,860 --> 00:14:41,300
alligator and we threw in an extra

00:14:39,950 --> 00:14:43,730
alligator in addition to standard

00:14:41,300 --> 00:14:48,860
alligator standard scoped allocate or

00:14:43,730 --> 00:14:50,360
adapter which basically is a any package

00:14:48,860 --> 00:14:51,770
for supporting nesting of different

00:14:50,360 --> 00:14:55,640
alligators at different levels of your

00:14:51,770 --> 00:14:57,230
system so that if I have a can if I just

00:14:55,640 --> 00:15:00,279
have one at one allocation by scoped

00:14:57,230 --> 00:15:03,110
okay it would mean that my content

00:15:00,279 --> 00:15:05,329
elements will use the same it's the

00:15:03,110 --> 00:15:07,640
container itself and I'm doing something

00:15:05,329 --> 00:15:16,550
funny with my microphone I'm jumping in

00:15:07,640 --> 00:15:19,220
and out here so just a quick recap on

00:15:16,550 --> 00:15:22,760
the weasel words that we struck going

00:15:19,220 --> 00:15:24,740
way back to C++ 98 there was an

00:15:22,760 --> 00:15:27,920
assumption that all instances of a given

00:15:24,740 --> 00:15:30,140
alligator object would always the same

00:15:27,920 --> 00:15:31,379
they were always interoperable and the

00:15:30,140 --> 00:15:34,379
translation there is

00:15:31,379 --> 00:15:37,079
but you're allocated objects prior to

00:15:34,379 --> 00:15:39,269
C++ eleven could not reliably have state

00:15:37,079 --> 00:15:41,939
and if you're allocated object doesn't

00:15:39,269 --> 00:15:43,349
have state it's really hard to do a lot

00:15:41,939 --> 00:15:45,509
of the interesting things we want to do

00:15:43,349 --> 00:15:49,499
to make allocation more useful and

00:15:45,509 --> 00:15:51,559
powerful and in particularly you're not

00:15:49,499 --> 00:15:53,789
allowed to have a pointer to another

00:15:51,559 --> 00:15:57,989
mechanism that's looking after a lot of

00:15:53,789 --> 00:15:59,639
that allocation for you the other part

00:15:57,989 --> 00:16:01,849
of the weasel words which we've got a

00:15:59,639 --> 00:16:04,499
bunch of type deaths that you have in a

00:16:01,849 --> 00:16:06,989
allocator let's say this is the kind of

00:16:04,499 --> 00:16:09,329
pointer I use this is the other hat how

00:16:06,989 --> 00:16:11,609
you measure the size of allocations and

00:16:09,329 --> 00:16:13,049
so forth and the implementation is

00:16:11,609 --> 00:16:16,470
alright to simply assume that these are

00:16:13,049 --> 00:16:18,479
always wrong us and that means that you

00:16:16,470 --> 00:16:20,729
can't have alligators returning fancy

00:16:18,479 --> 00:16:22,679
pointers you know c-plus our smart

00:16:20,729 --> 00:16:25,470
pointer type things that allow you to

00:16:22,679 --> 00:16:28,499
incur those special rules for allocating

00:16:25,470 --> 00:16:30,209
speckle at a special memory regions and

00:16:28,499 --> 00:16:32,429
making sure I've got pointers that do

00:16:30,209 --> 00:16:33,809
all the appropriate wrapping to get into

00:16:32,429 --> 00:16:36,539
that special memory region the time

00:16:33,809 --> 00:16:38,549
trying to do clever things with so by

00:16:36,539 --> 00:16:41,399
striking those it's a weasel word c++ c

00:16:38,549 --> 00:16:42,689
11 alligators now can support the models

00:16:41,399 --> 00:16:45,629
to do all the things that we were

00:16:42,689 --> 00:16:46,709
talking about and want to do quick

00:16:45,629 --> 00:16:51,209
walkthrough of what allocated trace

00:16:46,709 --> 00:16:53,609
looks like you have it's a class

00:16:51,209 --> 00:16:55,529
template parametrize that says on the

00:16:53,609 --> 00:16:57,809
allocates that you supply to it and your

00:16:55,529 --> 00:16:59,759
alligator has to have a nested value

00:16:57,809 --> 00:17:02,879
type because this is still model on the

00:16:59,759 --> 00:17:05,759
c++ 98 model alligators allocate for

00:17:02,879 --> 00:17:07,259
objects so the alligator that I plug

00:17:05,759 --> 00:17:09,360
into alligator tricks is going to be a

00:17:07,259 --> 00:17:10,620
class template and it's going to say I

00:17:09,360 --> 00:17:12,389
don't know how to allocate for this kind

00:17:10,620 --> 00:17:14,129
of object and then we have a bunch of

00:17:12,389 --> 00:17:15,569
other type deaths that are really useful

00:17:14,129 --> 00:17:17,879
but when you're dealing with allocations

00:17:15,569 --> 00:17:21,089
to say you know what kind of pointer or

00:17:17,879 --> 00:17:25,139
point concept to the allocated net

00:17:21,089 --> 00:17:27,029
object I'm going to get pointers to void

00:17:25,139 --> 00:17:29,850
bill just the general access into that

00:17:27,029 --> 00:17:31,409
memory buffer and the if the allocated

00:17:29,850 --> 00:17:33,000
provides the east allocate the traits

00:17:31,409 --> 00:17:35,159
picks them up and otherwise it will

00:17:33,000 --> 00:17:38,159
compute a good default for you so that

00:17:35,159 --> 00:17:39,960
people don't have to worry about my new

00:17:38,159 --> 00:17:42,960
CI for their alligator that they're not

00:17:39,960 --> 00:17:45,120
dealing with likewise we need to be able

00:17:42,960 --> 00:17:46,590
to rebind a now because alligators

00:17:45,120 --> 00:17:48,960
have to be class templates we can rebind

00:17:46,590 --> 00:17:51,030
from I've got an alligator for int and

00:17:48,960 --> 00:17:53,430
then I want to store it in a list so I

00:17:51,030 --> 00:17:54,840
need to have a node that holds an in so

00:17:53,430 --> 00:17:56,340
we need to allocate something different

00:17:54,840 --> 00:17:59,070
than the alligator the user gave me I

00:17:56,340 --> 00:18:00,540
can rebind and have an allocated for the

00:17:59,070 --> 00:18:02,490
kind of thing I want to allocate for

00:18:00,540 --> 00:18:05,640
they're from the same family all through

00:18:02,490 --> 00:18:08,220
the allocated rates and finally things

00:18:05,640 --> 00:18:10,170
got interesting warehouse rate when you

00:18:08,220 --> 00:18:12,930
go to actually perform your allocation

00:18:10,170 --> 00:18:14,670
now you're going to use these static

00:18:12,930 --> 00:18:16,830
member functions of the alligator traits

00:18:14,670 --> 00:18:19,650
template rather than access the

00:18:16,830 --> 00:18:21,360
alligator directly itself so you'll see

00:18:19,650 --> 00:18:23,400
this is a utility class where all the

00:18:21,360 --> 00:18:25,050
member functions are static there's no

00:18:23,400 --> 00:18:27,090
intention that you will ever instantiate

00:18:25,050 --> 00:18:30,059
an objective or create an object of this

00:18:27,090 --> 00:18:31,559
type and the first argument to every one

00:18:30,059 --> 00:18:34,790
of these functions you will notice is

00:18:31,559 --> 00:18:37,559
the alligator that you're trying to use

00:18:34,790 --> 00:18:39,030
but this allows the traits class to

00:18:37,559 --> 00:18:44,910
synthesize the operations that the

00:18:39,030 --> 00:18:47,070
alligator might be lacking and the thing

00:18:44,910 --> 00:18:49,290
I'll just call our theme passing as I

00:18:47,070 --> 00:18:51,809
always do the allocate and deallocate

00:18:49,290 --> 00:18:54,270
functions work in whatever kind of going

00:18:51,809 --> 00:18:56,040
to type your alligator has as the

00:18:54,270 --> 00:18:58,440
construct and destroy methods which are

00:18:56,040 --> 00:18:59,880
customization points to say now I'm

00:18:58,440 --> 00:19:02,550
constructing something that might want

00:18:59,880 --> 00:19:04,770
to know about the alligator I used those

00:19:02,550 --> 00:19:06,630
actually just traffic in the address of

00:19:04,770 --> 00:19:08,280
the object I'm creating and for

00:19:06,630 --> 00:19:09,840
convenience they're templates so I don't

00:19:08,280 --> 00:19:11,490
need to keep rebuilding these as I'm

00:19:09,840 --> 00:19:13,760
trying to construct three or four

00:19:11,490 --> 00:19:16,230
different things with the same alligator

00:19:13,760 --> 00:19:18,030
so access to all got it to be aware of

00:19:16,230 --> 00:19:19,590
that doesn't catch people out until they

00:19:18,030 --> 00:19:21,090
start using smart pointers for the first

00:19:19,590 --> 00:19:22,470
time and then someone you're secure

00:19:21,090 --> 00:19:25,980
these api's are certainly different than

00:19:22,470 --> 00:19:29,240
they thought they were and then we come

00:19:25,980 --> 00:19:32,160
to the joys of alligator propagation

00:19:29,240 --> 00:19:34,320
which I've got a few slides coming up

00:19:32,160 --> 00:19:36,929
shortly so I'll jump over the hosts but

00:19:34,320 --> 00:19:38,280
those are another aspect that you all

00:19:36,929 --> 00:19:39,960
finding the traits that turned out to

00:19:38,280 --> 00:19:43,800
have a big impact on how we use these

00:19:39,960 --> 00:19:46,320
things so progress in C++ 98 we now

00:19:43,800 --> 00:19:46,950
support a wide variety of alligator

00:19:46,320 --> 00:19:50,700
models

00:19:46,950 --> 00:19:51,990
here's back your spot we've got four

00:19:50,700 --> 00:19:54,240
different traits here for propagation

00:19:51,990 --> 00:19:55,710
most of those are boolean so that's a

00:19:54,240 --> 00:19:57,630
binary choice so that's at least you

00:19:55,710 --> 00:19:58,320
know 16 different alligator models

00:19:57,630 --> 00:20:00,149
depending on how he

00:19:58,320 --> 00:20:01,409
plug things in there regardless of what

00:20:00,149 --> 00:20:03,269
we're doing with those because these

00:20:01,409 --> 00:20:05,580
kinds of allocators will all behave very

00:20:03,269 --> 00:20:08,070
differently as well see so we've

00:20:05,580 --> 00:20:09,570
actually supported a wider much more

00:20:08,070 --> 00:20:12,139
than just a new alligator model we've

00:20:09,570 --> 00:20:15,120
supported a facility that supports I

00:20:12,139 --> 00:20:18,679
won't say every imaginable allocate the

00:20:15,120 --> 00:20:21,029
more more than I care to think about

00:20:18,679 --> 00:20:23,669
but the interoperability of vocabulary

00:20:21,029 --> 00:20:25,649
types remains an issue because the

00:20:23,669 --> 00:20:27,870
alligator is still tied to the type of

00:20:25,649 --> 00:20:29,639
object its allocating the data

00:20:27,870 --> 00:20:31,230
structures that consume these alligators

00:20:29,639 --> 00:20:35,250
are still templated on the alligator

00:20:31,230 --> 00:20:38,100
type as I'm plugging into the container

00:20:35,250 --> 00:20:39,750
the data structure because we couldn't

00:20:38,100 --> 00:20:42,929
change that this is just an enhancement

00:20:39,750 --> 00:20:45,419
of the existing standard library and if

00:20:42,929 --> 00:20:47,370
we make a change of this model we're

00:20:45,419 --> 00:20:50,399
instantly giving up compatibility with

00:20:47,370 --> 00:20:55,860
that library and we can't do that while

00:20:50,399 --> 00:20:58,200
maintaining that same library skipping

00:20:55,860 --> 00:21:00,000
over C++ 14 I didn't don't remember much

00:20:58,200 --> 00:21:01,860
happening with alligators in 14 apart

00:21:00,000 --> 00:21:03,870
might be some cleanup of the wording how

00:21:01,860 --> 00:21:05,220
do we improve alligators in 17 just to

00:21:03,870 --> 00:21:08,220
bring us up to date with where we are

00:21:05,220 --> 00:21:10,110
today I'm sorry it's been so long gone

00:21:08,220 --> 00:21:11,970
laboring the history but it's good to

00:21:10,110 --> 00:21:14,220
know what we're trying to change before

00:21:11,970 --> 00:21:16,399
we start or what problems we have before

00:21:14,220 --> 00:21:18,779
we try to stop trying to solve them

00:21:16,399 --> 00:21:22,470
we've got a new trait is always equal to

00:21:18,779 --> 00:21:24,389
say that these two alligators to any two

00:21:22,470 --> 00:21:26,610
object of this alligator type are always

00:21:24,389 --> 00:21:28,049
interoperable so I don't need to

00:21:26,610 --> 00:21:29,789
actually take a look at the state of

00:21:28,049 --> 00:21:32,850
those alligators to see come

00:21:29,789 --> 00:21:35,519
interoperate 1 allocate and 1 D allocate

00:21:32,850 --> 00:21:37,669
the same same region of memory and this

00:21:35,519 --> 00:21:40,940
is very useful when it comes to

00:21:37,669 --> 00:21:43,559
providing no exception specifications

00:21:40,940 --> 00:21:45,120
because if I know that the two

00:21:43,559 --> 00:21:47,639
allocations are always the same I can

00:21:45,120 --> 00:21:49,259
start making better no throwing

00:21:47,639 --> 00:21:52,620
assumptions about move semantics in a

00:21:49,259 --> 00:21:54,779
few other places so this new trait ends

00:21:52,620 --> 00:21:56,190
up appearing in quite a few that

00:21:54,779 --> 00:21:57,629
exception specification is related to

00:21:56,190 --> 00:22:01,759
swap some moves throughout the standard

00:21:57,629 --> 00:22:04,610
library we also added another facility

00:22:01,759 --> 00:22:08,370
called polymorphic memory resources

00:22:04,610 --> 00:22:09,809
which again will be ok I don't think

00:22:08,370 --> 00:22:11,879
this is too much of John's talk tomorrow

00:22:09,809 --> 00:22:12,740
this is the inspiration for John's

00:22:11,879 --> 00:22:15,240
talking this tour

00:22:12,740 --> 00:22:17,910
but the notion of a polymorphic memory

00:22:15,240 --> 00:22:19,680
resource is we provide the new model for

00:22:17,910 --> 00:22:24,180
allocators that rather than allocating

00:22:19,680 --> 00:22:28,320
objects just allocate memory we then

00:22:24,180 --> 00:22:31,340
wrap up in a c++ 98 style allocator that

00:22:28,320 --> 00:22:34,920
knows how to allocate objects out using

00:22:31,340 --> 00:22:36,600
this memory resource but the notion now

00:22:34,920 --> 00:22:39,840
is we have memory resources that are

00:22:36,600 --> 00:22:44,760
just about managing memory and we wrap

00:22:39,840 --> 00:22:46,740
them in a c++ 98 style allocator and in

00:22:44,760 --> 00:22:49,470
addition to that we have PMR containers

00:22:46,740 --> 00:22:51,090
which is PMR short for polymorphic

00:22:49,470 --> 00:22:54,780
memory resource just trips off the

00:22:51,090 --> 00:22:56,820
tongue is a namespace with in STD and

00:22:54,780 --> 00:22:58,380
then within there we have an alias

00:22:56,820 --> 00:23:00,210
template that every span the container

00:22:58,380 --> 00:23:01,410
that just says rather than using

00:23:00,210 --> 00:23:03,090
standard alligator

00:23:01,410 --> 00:23:07,290
I'll use the alligator that wraps the

00:23:03,090 --> 00:23:09,210
PMR resources instead because we don't

00:23:07,290 --> 00:23:10,860
need to do any other work it's just by

00:23:09,210 --> 00:23:12,420
plugging in a different alligator policy

00:23:10,860 --> 00:23:13,980
all the work for doing allocations

00:23:12,420 --> 00:23:16,410
correctly is already implemented in the

00:23:13,980 --> 00:23:19,200
standard containers so this is not a

00:23:16,410 --> 00:23:20,400
whole new set of separately implemented

00:23:19,200 --> 00:23:22,350
containers doing lots of different

00:23:20,400 --> 00:23:23,790
interesting things it's just an alias

00:23:22,350 --> 00:23:26,610
template says yeah I'm plugging in a

00:23:23,790 --> 00:23:28,110
different allocator so the alias the

00:23:26,610 --> 00:23:30,120
peermark containers have one fewer

00:23:28,110 --> 00:23:33,720
template parameters because the allocate

00:23:30,120 --> 00:23:36,900
is already picked for you and the final

00:23:33,720 --> 00:23:38,340
tweak we did for c++ 17 not that

00:23:36,900 --> 00:23:40,290
relevant for this talk but i'm trying to

00:23:38,340 --> 00:23:42,270
be complete is we now require that when

00:23:40,290 --> 00:23:45,060
you had used those fancy pointers for

00:23:42,270 --> 00:23:47,100
special memory regions the pointers they

00:23:45,060 --> 00:23:49,410
return have to be contiguous iterators

00:23:47,100 --> 00:23:51,030
we used to have the notion that perhaps

00:23:49,410 --> 00:23:52,590
some hyper secure system you might want

00:23:51,030 --> 00:23:55,190
to actually have a security cookie or

00:23:52,590 --> 00:23:57,660
something between each allocation and

00:23:55,190 --> 00:23:59,430
therefore when you implement the point

00:23:57,660 --> 00:24:01,380
of semantics your operator + + would

00:23:59,430 --> 00:24:03,480
have to know how to skip over those

00:24:01,380 --> 00:24:05,340
little cookies but people doing address

00:24:03,480 --> 00:24:06,780
arithmetic on the allocated objects are

00:24:05,340 --> 00:24:07,830
now going to get the wrong answers you

00:24:06,780 --> 00:24:10,560
have to do everything through the

00:24:07,830 --> 00:24:14,940
pointer type but we were prying those to

00:24:10,560 --> 00:24:16,590
be those fancy pointers to always be a

00:24:14,940 --> 00:24:18,420
contiguous iterator you can now do

00:24:16,590 --> 00:24:20,670
pointer arithmetic safely with the

00:24:18,420 --> 00:24:24,110
objects in your containers where you've

00:24:20,670 --> 00:24:24,110
got contiguous guarantees

00:24:25,470 --> 00:24:38,070
so how does the polymorphic memories or

00:24:28,960 --> 00:24:41,350
system work turn tick we have a basic

00:24:38,070 --> 00:24:44,739
abstract base class standard PMR memory

00:24:41,350 --> 00:24:47,019
resource that provides a basic interface

00:24:44,739 --> 00:24:49,960
for allocating and deallocating memory

00:24:47,019 --> 00:24:53,440
I've got on the slide to come clients

00:24:49,960 --> 00:24:55,539
are going to store pointers to that base

00:24:53,440 --> 00:24:58,119
class and we're going to use them with

00:24:55,539 --> 00:25:00,730
traditional vtable style C++ programming

00:24:58,119 --> 00:25:02,230
we've got a pointer to this thing is the

00:25:00,730 --> 00:25:03,999
service that's providing me memory and

00:25:02,230 --> 00:25:07,450
now clients can plug in their

00:25:03,999 --> 00:25:10,289
implementation of that interface and at

00:25:07,450 --> 00:25:12,940
different times I can plug in different

00:25:10,289 --> 00:25:14,109
allocators without changing the type of

00:25:12,940 --> 00:25:18,090
the object I'm dealing with I'm just

00:25:14,109 --> 00:25:20,019
picking the strategy at runtime now and

00:25:18,090 --> 00:25:22,419
going back to when I was talking about

00:25:20,019 --> 00:25:25,330
those propagation traits the key issue

00:25:22,419 --> 00:25:28,269
is that the resource pointer never

00:25:25,330 --> 00:25:30,340
propagates and for folks who haven't

00:25:28,269 --> 00:25:32,289
dealt with stateful allocators and we

00:25:30,340 --> 00:25:34,539
spend a couple slides now talking about

00:25:32,289 --> 00:25:36,879
why allocation prop why the propagation

00:25:34,539 --> 00:25:43,059
property matters and can be surprising

00:25:36,879 --> 00:25:50,889
to people the final issue we have with

00:25:43,059 --> 00:25:54,249
the PMR model is that we guarantee when

00:25:50,889 --> 00:25:56,200
I have a container using polymorphic

00:25:54,249 --> 00:25:57,759
memory resources so I've got a vector if

00:25:56,200 --> 00:26:00,070
I have a vector of strings

00:25:57,759 --> 00:26:02,139
I want to guarantee that the strings are

00:26:00,070 --> 00:26:06,039
all using the same allocator as the

00:26:02,139 --> 00:26:08,470
vector I we don't support the idea that

00:26:06,039 --> 00:26:09,639
I've got a vector of strings in each

00:26:08,470 --> 00:26:11,409
string is going to have a different

00:26:09,639 --> 00:26:14,049
allocator the whole notion of being able

00:26:11,409 --> 00:26:15,850
to rely on memory being in the pool is

00:26:14,049 --> 00:26:17,859
that all the elements in the container

00:26:15,850 --> 00:26:22,389
have to have their memory coming out of

00:26:17,859 --> 00:26:23,590
that same pool so we the work is the

00:26:22,389 --> 00:26:25,809
allocator is going to say when I

00:26:23,590 --> 00:26:27,460
construct elements in my container this

00:26:25,809 --> 00:26:29,679
is what the construct method for is

00:26:27,460 --> 00:26:32,379
therefore in allocate of traits I'm

00:26:29,679 --> 00:26:33,669
going to make sure i propagate propagate

00:26:32,379 --> 00:26:34,480
is the tip what I want to use but it

00:26:33,669 --> 00:26:36,100
means something different in the

00:26:34,480 --> 00:26:37,059
standard I'm going to pass that

00:26:36,100 --> 00:26:40,590
alligator down

00:26:37,059 --> 00:26:42,940
to the element when I construct it so

00:26:40,590 --> 00:26:44,440
this is the basic memory resource

00:26:42,940 --> 00:26:47,919
interface which looks a little small on

00:26:44,440 --> 00:26:49,269
this slide I'm afraid basically you see

00:26:47,919 --> 00:26:52,269
it's got a virtual destructor

00:26:49,269 --> 00:26:54,490
it's got public member functions that

00:26:52,269 --> 00:26:57,429
are not virtual allocate and deallocate

00:26:54,490 --> 00:26:59,889
and they take a number of bytes you want

00:26:57,429 --> 00:27:01,570
to allocate and an alignment and the

00:26:59,889 --> 00:27:04,320
alignment will default to Maxell line if

00:27:01,570 --> 00:27:07,450
you don't supply it and then we have

00:27:04,320 --> 00:27:10,749
protected virtual pure pure virtual

00:27:07,450 --> 00:27:12,730
functions but again the do allocate and

00:27:10,749 --> 00:27:16,360
deallocate that the memory resource is

00:27:12,730 --> 00:27:18,340
going to implement and the idea here is

00:27:16,360 --> 00:27:19,690
with the public number function they can

00:27:18,340 --> 00:27:21,159
have a defaulted argument so I've

00:27:19,690 --> 00:27:23,919
effectively got two functions for the

00:27:21,159 --> 00:27:24,580
price of one but when I am implementing

00:27:23,919 --> 00:27:26,320
allocator

00:27:24,580 --> 00:27:27,580
I don't want to be implementing two

00:27:26,320 --> 00:27:30,190
different virtual functions so the

00:27:27,580 --> 00:27:31,570
function we call always takes that we

00:27:30,190 --> 00:27:34,629
dispatched to internally will always

00:27:31,570 --> 00:27:39,940
take the alignment even if I choose to

00:27:34,629 --> 00:27:42,429
ignore it these methods of virtual these

00:27:39,940 --> 00:27:44,080
are the allocate and deallocate at a key

00:27:42,429 --> 00:27:47,740
member functions that clients of the

00:27:44,080 --> 00:27:50,710
allocator are going to use the do you

00:27:47,740 --> 00:27:53,139
allocate do deallocate using this idiom

00:27:50,710 --> 00:27:55,299
as i said so we can not worry about

00:27:53,139 --> 00:27:57,279
funky funky notes with default arguments

00:27:55,299 --> 00:27:59,019
on virtual function calls of what the

00:27:57,279 --> 00:28:02,860
memory resource implementers are going

00:27:59,019 --> 00:28:05,139
to implement and our choice of

00:28:02,860 --> 00:28:07,269
vocabulary types for how do I refer to

00:28:05,139 --> 00:28:08,830
memory is a void star we have the object

00:28:07,269 --> 00:28:11,740
to be void star could have been car star

00:28:08,830 --> 00:28:13,509
in it came either 17 you could even have

00:28:11,740 --> 00:28:16,600
in byte star if by it haven't landed so

00:28:13,509 --> 00:28:17,590
late but void star on balance turned out

00:28:16,600 --> 00:28:21,490
to be the right answer as we're

00:28:17,590 --> 00:28:25,179
developing this proposal and which

00:28:21,490 --> 00:28:28,230
skipper do is it is equal popper now so

00:28:25,179 --> 00:28:31,809
idiom and usage of PMR

00:28:28,230 --> 00:28:34,480
the notion of my memory resource is it's

00:28:31,809 --> 00:28:36,549
going to be an object like any other but

00:28:34,480 --> 00:28:38,409
it owns and manages a region of memory

00:28:36,549 --> 00:28:40,240
and I'm going to create it locally in my

00:28:38,409 --> 00:28:44,649
function on the stack just like any

00:28:40,240 --> 00:28:47,139
other variable and now once I've got

00:28:44,649 --> 00:28:49,330
that object the lifetime of objects

00:28:47,139 --> 00:28:50,770
below it can happily use that memory

00:28:49,330 --> 00:28:52,480
because as long as they destroy

00:28:50,770 --> 00:28:56,050
by the usual rules of the C++ language

00:28:52,480 --> 00:28:57,460
before the memories or subject itself is

00:28:56,050 --> 00:28:59,680
destroyed I know I'm not going to have

00:28:57,460 --> 00:29:03,400
any funny pointers and references to

00:28:59,680 --> 00:29:05,440
memory I don't down so the basic model

00:29:03,400 --> 00:29:08,260
is in your function you're going to

00:29:05,440 --> 00:29:11,260
create on the stack your your memory

00:29:08,260 --> 00:29:13,660
resource object which that slide I was

00:29:11,260 --> 00:29:16,270
missing earlier about the on the stack

00:29:13,660 --> 00:29:19,380
or in the managed pool those are the

00:29:16,270 --> 00:29:19,380
kinds of things we're talking about here

00:29:20,370 --> 00:29:25,720
and then I will allocate out of those

00:29:23,830 --> 00:29:27,100
for now I'll pass those memories or

00:29:25,720 --> 00:29:31,750
sister the containers I want to be

00:29:27,100 --> 00:29:32,950
managing Donna tried going through this

00:29:31,750 --> 00:29:34,680
too quickly I don't have enough

00:29:32,950 --> 00:29:36,760
informative slides unfortunately I'm

00:29:34,680 --> 00:29:38,410
first time I'm giving this talking I'm

00:29:36,760 --> 00:29:41,260
realizing I'm afraid in front of you

00:29:38,410 --> 00:29:42,850
what I'm missing we've also got three

00:29:41,260 --> 00:29:44,350
other notions of special kinds of

00:29:42,850 --> 00:29:46,150
alligators or terms were used for the

00:29:44,350 --> 00:29:48,040
alig alkanes all these memory resources

00:29:46,150 --> 00:29:49,390
I keep pulling on the term allocator

00:29:48,040 --> 00:29:51,450
because that's what we've been calling

00:29:49,390 --> 00:29:55,150
it in Bloomberg / last decade or so

00:29:51,450 --> 00:29:56,860
overlooked but the default alligator is

00:29:55,150 --> 00:29:59,410
we have a system-wide default to say if

00:29:56,860 --> 00:30:02,590
I don't request a specific allocated for

00:29:59,410 --> 00:30:03,940
this object use the same default that

00:30:02,590 --> 00:30:05,050
the rest of the system is going to use

00:30:03,940 --> 00:30:07,000
and by default that's going to be

00:30:05,050 --> 00:30:09,100
operating new but we have the ability to

00:30:07,000 --> 00:30:10,440
customize that globally across the

00:30:09,100 --> 00:30:13,080
system as a whole

00:30:10,440 --> 00:30:16,570
the notion of the object allocator

00:30:13,080 --> 00:30:19,390
matters in the context of I now have an

00:30:16,570 --> 00:30:21,940
object that's managing memory I'm owning

00:30:19,390 --> 00:30:23,890
and managing a data structure the object

00:30:21,940 --> 00:30:25,990
allocator is the allocator i'm going to

00:30:23,890 --> 00:30:27,880
use to allocate nodes allocate buffers

00:30:25,990 --> 00:30:31,770
things that are going to persist beyond

00:30:27,880 --> 00:30:34,630
a member function call and the idiom is

00:30:31,770 --> 00:30:36,820
if someone invokes a member function and

00:30:34,630 --> 00:30:39,160
I have to ask the question which

00:30:36,820 --> 00:30:41,830
allocated should I use I've got the

00:30:39,160 --> 00:30:43,450
default allocator or I've got the object

00:30:41,830 --> 00:30:45,880
allocated because I know which allocated

00:30:43,450 --> 00:30:47,470
my objects using and I'm just creating a

00:30:45,880 --> 00:30:50,560
string object that it's going to be used

00:30:47,470 --> 00:30:53,400
within this function and go away always

00:30:50,560 --> 00:30:56,080
use the default allocator for those

00:30:53,400 --> 00:30:59,080
temporary file objects allocations that

00:30:56,080 --> 00:31:00,820
do not exceed the function call because

00:30:59,080 --> 00:31:02,860
those are not part of the persistent

00:31:00,820 --> 00:31:04,010
storage of your container and they're

00:31:02,860 --> 00:31:06,470
not expected

00:31:04,010 --> 00:31:08,420
to be part of that memory results when

00:31:06,470 --> 00:31:09,740
people compute their expected size of

00:31:08,420 --> 00:31:11,150
that continually matter memory it's

00:31:09,740 --> 00:31:13,160
going to consume they're not looking for

00:31:11,150 --> 00:31:16,360
these funny transient allocations

00:31:13,160 --> 00:31:18,290
that's occur with their member functions

00:31:16,360 --> 00:31:19,550
whereas if I'm going to allocate

00:31:18,290 --> 00:31:21,020
something that's part of that data

00:31:19,550 --> 00:31:23,750
structure it's going to persist beyond

00:31:21,020 --> 00:31:25,940
the function call clearly that should

00:31:23,750 --> 00:31:28,730
come out of or be allocated using the

00:31:25,940 --> 00:31:31,340
object allocator and then you get the

00:31:28,730 --> 00:31:33,440
fun things like okay I'm going to do my

00:31:31,340 --> 00:31:35,120
working with to create this object on

00:31:33,440 --> 00:31:37,010
the stack but then I'm going to transfer

00:31:35,120 --> 00:31:39,680
it into the data structure when I'm done

00:31:37,010 --> 00:31:41,900
in that case the intent is that the

00:31:39,680 --> 00:31:44,300
object is for a persistent allocation so

00:31:41,900 --> 00:31:46,880
you use the object allocator even if we

00:31:44,300 --> 00:31:52,250
end up throwing in that memory then gets

00:31:46,880 --> 00:31:53,660
reclaimed and final notion is we have

00:31:52,250 --> 00:31:55,400
something we call the global allocator

00:31:53,660 --> 00:31:57,710
this is not part of the standard PMR

00:31:55,400 --> 00:32:00,200
process but the notion is still good if

00:31:57,710 --> 00:32:02,480
I have an object of static storage

00:32:00,200 --> 00:32:05,180
curation or thread-local storage

00:32:02,480 --> 00:32:08,720
iteration its destructor might happen

00:32:05,180 --> 00:32:11,600
after main has concluded and if I've

00:32:08,720 --> 00:32:13,640
installed a system-wide default

00:32:11,600 --> 00:32:15,920
allocator that's probably been installed

00:32:13,640 --> 00:32:18,620
somewhere in main so I want to have

00:32:15,920 --> 00:32:20,300
allocations for global persistence you

00:32:18,620 --> 00:32:23,150
know static storage generation objects

00:32:20,300 --> 00:32:25,870
that might persist beyond the

00:32:23,150 --> 00:32:28,930
registration the default allocator

00:32:25,870 --> 00:32:31,580
each would then have its own local

00:32:28,930 --> 00:32:34,910
allocated list for that object or we

00:32:31,580 --> 00:32:37,820
have a global system that again runs for

00:32:34,910 --> 00:32:39,590
the duration of the process the other

00:32:37,820 --> 00:32:42,860
key thing though that comes out of the

00:32:39,590 --> 00:32:48,260
PMR system is we no longer have support

00:32:42,860 --> 00:32:50,000
for fancy pointers if I jump back about

00:32:48,260 --> 00:32:53,840
your functions without virtual functions

00:32:50,000 --> 00:32:57,560
here and they return void star and they

00:32:53,840 --> 00:32:58,880
work with void stars and there because

00:32:57,560 --> 00:33:02,870
they revert your function that's a

00:32:58,880 --> 00:33:04,910
signature I'm bound to I cannot plug in

00:33:02,870 --> 00:33:07,970
a different fancy pointer and try and

00:33:04,910 --> 00:33:09,860
override this member function because

00:33:07,970 --> 00:33:13,250
it's the wrong signature

00:33:09,860 --> 00:33:14,990
so as part of choosing this ability to

00:33:13,250 --> 00:33:17,899
plug in our allocators at run time

00:33:14,990 --> 00:33:24,710
rather than compile time we give up the

00:33:17,899 --> 00:33:29,510
flexibility of the fancy pointer that's

00:33:24,710 --> 00:33:31,039
our trade off between extent we do get

00:33:29,510 --> 00:33:33,110
for instance we still want to work with

00:33:31,039 --> 00:33:35,210
shared memory at Bloomberg and we do

00:33:33,110 --> 00:33:36,710
this by simply ensuring that memory

00:33:35,210 --> 00:33:38,510
segments always login to the same

00:33:36,710 --> 00:33:42,010
address in the address space of all the

00:33:38,510 --> 00:33:44,269
different running processes it's a bit

00:33:42,010 --> 00:33:45,889
there's weight tricks it means that you

00:33:44,269 --> 00:33:49,309
can do to make this work so you can

00:33:45,889 --> 00:33:50,690
ameliorate some of this but for instance

00:33:49,309 --> 00:33:52,669
I think herbs that I had an interesting

00:33:50,690 --> 00:33:54,529
talk about using fancy pointers for

00:33:52,669 --> 00:33:56,690
garbage collection last year and that

00:33:54,529 --> 00:33:58,639
might run into an issue here so this is

00:33:56,690 --> 00:34:00,110
still something that I don't have the

00:33:58,639 --> 00:34:02,480
Silver Bullet that solves all the

00:34:00,110 --> 00:34:04,130
problems of all the array of allocated

00:34:02,480 --> 00:34:06,580
models that I was missing we could build

00:34:04,130 --> 00:34:08,929
but it's a very specific solution for

00:34:06,580 --> 00:34:11,510
trying to ensure we can have the maximum

00:34:08,929 --> 00:34:13,540
flexibility that we can support at run

00:34:11,510 --> 00:34:13,540
time

00:34:13,570 --> 00:34:17,839
the key thing is it solves a vocabulary

00:34:15,830 --> 00:34:19,879
problem so these things are very good

00:34:17,839 --> 00:34:22,010
for the kinds of objects you want to be

00:34:19,879 --> 00:34:23,929
passing through api's you don't have an

00:34:22,010 --> 00:34:27,099
interoperability problem when different

00:34:23,929 --> 00:34:29,030
objects are using different alligators I

00:34:27,099 --> 00:34:33,200
say we've given up the support for the

00:34:29,030 --> 00:34:36,560
fancy pointers there's an implied cost

00:34:33,200 --> 00:34:39,080
here though that every object now that

00:34:36,560 --> 00:34:42,639
manages memory is storing an extra

00:34:39,080 --> 00:34:45,619
pointer to the allocator

00:34:42,639 --> 00:34:47,119
this is not a cost that was paid with

00:34:45,619 --> 00:34:48,409
the traditional standard allocations it

00:34:47,119 --> 00:34:50,510
just dropped everything down to standard

00:34:48,409 --> 00:34:52,460
new or any allocator model whether you

00:34:50,510 --> 00:34:56,750
allocate the type itself was just an

00:34:52,460 --> 00:34:59,300
empty type john will talk about this

00:34:56,750 --> 00:35:01,250
somewhat tomorrow again the other cost

00:34:59,300 --> 00:35:03,170
is now that our memory allocations are a

00:35:01,250 --> 00:35:06,490
dynamic dispatch rather than a straight

00:35:03,170 --> 00:35:08,500
function call John will have

00:35:06,490 --> 00:35:10,640
measurements tomorrow that show

00:35:08,500 --> 00:35:14,540
typically these costs turn out to be

00:35:10,640 --> 00:35:15,920
negligible but they were concerned that

00:35:14,540 --> 00:35:17,780
some people when they're down measuring

00:35:15,920 --> 00:35:20,960
it the the nanosecond level might have

00:35:17,780 --> 00:35:22,780
some of these concerns the goal is that

00:35:20,960 --> 00:35:26,170
we gain enough elsewhere

00:35:22,780 --> 00:35:27,910
it swamps any potential cost of the

00:35:26,170 --> 00:35:32,470
dynamic dispatch when you're not using

00:35:27,910 --> 00:35:33,610
the facility deal abruptly I say

00:35:32,470 --> 00:35:37,660
Bloomberg we've been using this facility

00:35:33,610 --> 00:35:39,190
for over a decade now not explicitly the

00:35:37,660 --> 00:35:40,780
PMR that's in the standard but

00:35:39,190 --> 00:35:43,000
essentially the progenitor that became

00:35:40,780 --> 00:35:45,520
that it's mostly the same without the

00:35:43,000 --> 00:35:49,000
support for alignment that's a little

00:35:45,520 --> 00:35:50,980
bit more subtle our experience is that

00:35:49,000 --> 00:35:52,720
the PM our allocators have been a big

00:35:50,980 --> 00:35:54,580
win on performance especially in

00:35:52,720 --> 00:35:57,010
performance critical codes where people

00:35:54,580 --> 00:36:00,700
are invested in making me up its use of

00:35:57,010 --> 00:36:01,750
facility I found there's certainly other

00:36:00,700 --> 00:36:03,430
folks around the company but especially

00:36:01,750 --> 00:36:04,900
me I found the instrumentation helpful

00:36:03,430 --> 00:36:06,670
when getting our test drivers much more

00:36:04,900 --> 00:36:08,380
reliable it's fantastic the ability to

00:36:06,670 --> 00:36:09,490
be able to instrument and profile and do

00:36:08,380 --> 00:36:11,530
interesting things with the

00:36:09,490 --> 00:36:13,840
instrumentation but performance is the

00:36:11,530 --> 00:36:15,580
real key everyone's using this for and

00:36:13,840 --> 00:36:16,780
despite all these great things that

00:36:15,580 --> 00:36:19,390
we're saying allocators are wonderful

00:36:16,780 --> 00:36:20,800
the user still bridle at the complexity

00:36:19,390 --> 00:36:25,150
that comes with trying to plug

00:36:20,800 --> 00:36:26,380
alligators into the C++ 98 model this

00:36:25,150 --> 00:36:28,840
thing where I'm on time I've got 20

00:36:26,380 --> 00:36:32,770
minutes to go Am I and what's my slide

00:36:28,840 --> 00:36:33,940
number yeah this would be behind so

00:36:32,770 --> 00:36:35,680
first time I'm given these I'm never

00:36:33,940 --> 00:36:36,940
very good at pacing myself and then race

00:36:35,680 --> 00:36:41,920
through all the interesting stuff at the

00:36:36,940 --> 00:36:44,010
end so complexity of C++ 17-hour caters

00:36:41,920 --> 00:36:46,330
is a problem

00:36:44,010 --> 00:36:49,180
why does complexity matter complex

00:36:46,330 --> 00:36:51,130
facilities frequently are simply not

00:36:49,180 --> 00:36:53,290
used they're intimidating they're more

00:36:51,130 --> 00:36:56,170
work than people want to run into good

00:36:53,290 --> 00:36:58,330
example C++ 98 we had a very powerful io

00:36:56,170 --> 00:37:00,610
streams facility and I know very few

00:36:58,330 --> 00:37:01,990
people that do anything other than use

00:37:00,610 --> 00:37:04,300
the straight i/o streams that come out

00:37:01,990 --> 00:37:05,650
of the ISO standard in fact they often

00:37:04,300 --> 00:37:09,160
don't use them as templates they just

00:37:05,650 --> 00:37:12,730
use the type def serve standard stream

00:37:09,160 --> 00:37:16,720
and a lot of you insertion operates as

00:37:12,730 --> 00:37:17,890
matt said again the slow adoption of use

00:37:16,720 --> 00:37:19,740
of allocators from the standard library

00:37:17,890 --> 00:37:21,820
facility has been there for a long time

00:37:19,740 --> 00:37:24,520
it's only real in the last four or five

00:37:21,820 --> 00:37:26,500
years we're starting to see users

00:37:24,520 --> 00:37:28,210
experimenting and using this facility a

00:37:26,500 --> 00:37:29,830
bit more certainly allocator traits in

00:37:28,210 --> 00:37:33,300
c++ c eleven made it a lot more

00:37:29,830 --> 00:37:33,300
interesting to experiment in this space

00:37:33,450 --> 00:37:38,230
but even if we've got this Pacifica that

00:37:36,550 --> 00:37:39,850
we're not using that complexity we still

00:37:38,230 --> 00:37:41,830
paying the price for it it's an

00:37:39,850 --> 00:37:42,760
intimidating thing to learn implement

00:37:41,830 --> 00:37:45,880
just have to pay the cost of

00:37:42,760 --> 00:37:47,890
implementing these things and the

00:37:45,880 --> 00:37:49,480
complex facility is more expensive to

00:37:47,890 --> 00:37:51,310
compile what are you paying a runtime

00:37:49,480 --> 00:37:53,230
cost most of that complexity is there

00:37:51,310 --> 00:37:58,830
actually to eliminate runtime costs but

00:37:53,230 --> 00:38:02,470
the net complexity is itself a problem

00:37:58,830 --> 00:38:05,830
one of the biggest concerns that I have

00:38:02,470 --> 00:38:07,060
hid when or perceived notions of

00:38:05,830 --> 00:38:09,280
complexity when we're dealing with the

00:38:07,060 --> 00:38:10,840
98 alik supercilious your wife and our

00:38:09,280 --> 00:38:12,790
caters get the right but right standard

00:38:10,840 --> 00:38:15,970
version is the notion of allocated

00:38:12,790 --> 00:38:18,520
propagation because this is where the

00:38:15,970 --> 00:38:19,810
PMR model and the preceding model in the

00:38:18,520 --> 00:38:21,150
standard where you have a stateless

00:38:19,810 --> 00:38:23,770
allocator

00:38:21,150 --> 00:38:28,360
start showing interesting divergences in

00:38:23,770 --> 00:38:29,800
people's intuition so certainly you're

00:38:28,360 --> 00:38:31,360
going to provide an alligator at the

00:38:29,800 --> 00:38:33,490
time you construct an object to have now

00:38:31,360 --> 00:38:37,560
said this object is allocating using

00:38:33,490 --> 00:38:39,520
this strategy and I now assign another

00:38:37,560 --> 00:38:42,460
so I've got a string I assign another

00:38:39,520 --> 00:38:46,240
string to it and the string I assign has

00:38:42,460 --> 00:38:48,280
a different allocator in it you are

00:38:46,240 --> 00:38:49,750
replace the alligator my string said it

00:38:48,280 --> 00:38:52,390
was using and says this is how I manage

00:38:49,750 --> 00:38:54,430
my memory because I'm now being assigned

00:38:52,390 --> 00:38:56,920
the stake of this other string that says

00:38:54,430 --> 00:38:59,140
no this is how I allocate memory which

00:38:56,920 --> 00:39:02,170
allocator should be used for the purpose

00:38:59,140 --> 00:39:05,470
of the assignment and this is where we

00:39:02,170 --> 00:39:08,200
have those multiple propagation traits

00:39:05,470 --> 00:39:10,660
in this c++ c 11 allocate the traits

00:39:08,200 --> 00:39:12,250
template saying well different people

00:39:10,660 --> 00:39:13,770
have come up with different answers they

00:39:12,250 --> 00:39:16,690
want to do different things

00:39:13,770 --> 00:39:18,040
in fact we gave them multiple dimensions

00:39:16,690 --> 00:39:20,560
to do different things we now got this

00:39:18,040 --> 00:39:23,010
dizzying complexity of the ways that we

00:39:20,560 --> 00:39:23,010
can do these things

00:39:27,550 --> 00:39:32,690
looking for a point I thought I got on

00:39:30,290 --> 00:39:33,980
that's why I need to walk through my

00:39:32,690 --> 00:39:37,100
slides more frequently before I give

00:39:33,980 --> 00:39:40,750
them I think not getting a bold

00:39:37,100 --> 00:39:40,750
confident portrayal today I'm afraid

00:39:42,640 --> 00:39:48,140
so in terms of the PMR model and the

00:39:45,560 --> 00:39:51,320
model I'm going to propose you do not

00:39:48,140 --> 00:39:53,270
rebind allocators on assignment on swap

00:39:51,320 --> 00:39:55,790
on any other operation the notion is

00:39:53,270 --> 00:39:57,830
when I construct an object I'm going to

00:39:55,790 --> 00:40:00,670
say I know how this alyc this object but

00:39:57,830 --> 00:40:03,230
in his lifetime expects to manage memory

00:40:00,670 --> 00:40:05,510
so I'm giving it an allocator it's fixed

00:40:03,230 --> 00:40:06,920
for life and the reason this matters is

00:40:05,510 --> 00:40:09,020
because I'm also going to make the

00:40:06,920 --> 00:40:10,550
assumption that all the elements that I

00:40:09,020 --> 00:40:12,710
allocate are going to use this same

00:40:10,550 --> 00:40:14,900
allocator so if I have a vector of

00:40:12,710 --> 00:40:16,490
strings I expect all my strings to be

00:40:14,900 --> 00:40:18,130
using the same pool that I was given if

00:40:16,490 --> 00:40:20,120
that's what the allocator does

00:40:18,130 --> 00:40:22,070
everything's using the same allocator

00:40:20,120 --> 00:40:23,630
somebody assigns to one of those strings

00:40:22,070 --> 00:40:26,060
is my data member and the allocator

00:40:23,630 --> 00:40:28,040
swaps out underneath me I've broken an

00:40:26,060 --> 00:40:31,670
invariant that I assumed when I designed

00:40:28,040 --> 00:40:33,280
the whole data structure so that's one

00:40:31,670 --> 00:40:50,750
fundamental reason why we do not want

00:40:33,280 --> 00:40:52,550
allocators to be reassigned Pablo Pablo

00:40:50,750 --> 00:40:53,990
points out he's going to go into more

00:40:52,550 --> 00:40:57,470
detail about the problems I'm talking

00:40:53,990 --> 00:41:07,460
about on Friday it's specifically about

00:40:57,470 --> 00:41:09,470
the the propagation yeah so and what's

00:41:07,460 --> 00:41:11,270
to deal with the the complexity that PMR

00:41:09,470 --> 00:41:15,130
you might hate but implementing in

00:41:11,270 --> 00:41:15,130
certainly it helps solve very quickly

00:41:22,030 --> 00:41:26,480
almost to point out that the use of PMR

00:41:24,620 --> 00:41:27,980
simplifies rather than complicates the

00:41:26,480 --> 00:41:32,360
use of allocators and yes that's the

00:41:27,980 --> 00:41:34,040
point I want to get to but when people

00:41:32,360 --> 00:41:36,110
hit a like allocate the propagation for

00:41:34,040 --> 00:41:37,730
the first time it's a roadblock and it

00:41:36,110 --> 00:41:39,620
stumbles people

00:41:37,730 --> 00:41:41,870
because when you have a stateless

00:41:39,620 --> 00:41:43,400
alligator like standard alligator does

00:41:41,870 --> 00:41:45,380
it propagate or not it doesn't matter

00:41:43,400 --> 00:41:47,810
because you're going to get the same

00:41:45,380 --> 00:41:50,420
execution regardless because there's no

00:41:47,810 --> 00:41:53,210
stake in the alligator and there's a

00:41:50,420 --> 00:41:56,030
consequence of some consequences follow

00:41:53,210 --> 00:42:01,160
from alligators not propagating that

00:41:56,030 --> 00:42:04,940
I'll defer to Pablo's talk on Friday but

00:42:01,160 --> 00:42:06,440
as I say the the trait skippers control

00:42:04,940 --> 00:42:09,470
over the up the propagation strategies

00:42:06,440 --> 00:42:11,300
and the default in the sequence Percy

00:42:09,470 --> 00:42:13,370
Levin allocated a trace is at least the

00:42:11,300 --> 00:42:16,630
alligators don't propagate which is the

00:42:13,370 --> 00:42:18,800
default we're going to want to the pmrs

00:42:16,630 --> 00:42:22,040
the other reason that propagation

00:42:18,800 --> 00:42:24,080
matters is when I imbue my container

00:42:22,040 --> 00:42:25,490
with an alligator remember the model I

00:42:24,080 --> 00:42:27,560
gave you at the start I'm going to have

00:42:25,490 --> 00:42:29,330
a memory resource and then I'm going to

00:42:27,560 --> 00:42:31,010
have a container using that resource and

00:42:29,330 --> 00:42:33,410
the elements of that container use that

00:42:31,010 --> 00:42:34,790
resource the reason I know that I'm not

00:42:33,410 --> 00:42:36,800
going to have to worry about memory

00:42:34,790 --> 00:42:39,590
being used outside the lifetime of that

00:42:36,800 --> 00:42:41,510
resource is we've got the guarantee that

00:42:39,590 --> 00:42:43,850
that whole data structure lives in that

00:42:41,510 --> 00:42:46,250
resource if someone starts being able to

00:42:43,850 --> 00:42:48,290
move that memory in those elements in

00:42:46,250 --> 00:42:50,270
and out of that memory by changing the

00:42:48,290 --> 00:42:53,030
alligators it becomes very hard to

00:42:50,270 --> 00:42:55,490
reason about the lifetime of the

00:42:53,030 --> 00:42:58,130
allocated memory of the managed memory

00:42:55,490 --> 00:42:59,660
that's managed by the resource so we

00:42:58,130 --> 00:43:01,610
really don't want people swapping our

00:42:59,660 --> 00:43:08,000
allocators when subjects have been

00:43:01,610 --> 00:43:09,980
created underneath us so the big problem

00:43:08,000 --> 00:43:12,110
problem to put we got with a complexity

00:43:09,980 --> 00:43:14,780
of the propagation model that's in 11 is

00:43:12,110 --> 00:43:16,190
it's it's too versatile I think leads to

00:43:14,780 --> 00:43:17,690
strange things that what does it mean if

00:43:16,190 --> 00:43:20,570
I can allocate a propagates on move

00:43:17,690 --> 00:43:22,880
assignment but not swap or vice versa

00:43:20,570 --> 00:43:25,190
and writing test drivers for these

00:43:22,880 --> 00:43:26,510
things is horrible implementing the

00:43:25,190 --> 00:43:31,100
thing that passes the test driver is

00:43:26,510 --> 00:43:34,880
worse the syntactic overhead of dealing

00:43:31,100 --> 00:43:37,910
with a lot of this is relatively high if

00:43:34,880 --> 00:43:39,470
you're now using C++ 11 alligators using

00:43:37,910 --> 00:43:41,480
the allocated traits facility all your

00:43:39,470 --> 00:43:43,310
Mamet management of memory now has to go

00:43:41,480 --> 00:43:45,350
through allocated traits and we've now

00:43:43,310 --> 00:43:47,180
got this very expert friendly facility

00:43:45,350 --> 00:43:50,860
we want to move away from expert

00:43:47,180 --> 00:43:50,860
friendly that's but I'm trying to get to

00:43:50,940 --> 00:43:55,300
because we don't want people to worry

00:43:53,830 --> 00:43:56,680
about allocates unless they're using

00:43:55,300 --> 00:43:58,540
them you end up with a default that

00:43:56,680 --> 00:43:59,950
we've got a constructor if I don't give

00:43:58,540 --> 00:44:02,950
you an alligator that just says use this

00:43:59,950 --> 00:44:04,359
isn't default and then one that does use

00:44:02,950 --> 00:44:05,920
now okay to that I can supply

00:44:04,359 --> 00:44:07,330
so we're potentially doubling the number

00:44:05,920 --> 00:44:09,220
of our constructors now because every

00:44:07,330 --> 00:44:12,070
constructor has to have an alligator

00:44:09,220 --> 00:44:14,800
aware version but you might be able to

00:44:12,070 --> 00:44:17,530
handle with use a default argument but

00:44:14,800 --> 00:44:19,300
if we do that we now need to have a

00:44:17,530 --> 00:44:21,010
default argument at the end of every

00:44:19,300 --> 00:44:23,020
constructor so that if I've got a

00:44:21,010 --> 00:44:25,599
constructor that has four or five

00:44:23,020 --> 00:44:28,300
default arguments such as an unordered

00:44:25,599 --> 00:44:31,420
map I now need variance with an

00:44:28,300 --> 00:44:33,460
alligator at the end of each list which

00:44:31,420 --> 00:44:35,950
produce lots of constructor spammers we

00:44:33,460 --> 00:44:38,080
saw in them an orders map for example in

00:44:35,950 --> 00:44:42,400
C++ C 11 it has eight constructors in

00:44:38,080 --> 00:44:44,410
C++ 17 it has 15 constructors all to

00:44:42,400 --> 00:44:45,760
solve the same problem it was just

00:44:44,410 --> 00:44:47,140
dealing with those default arguments

00:44:45,760 --> 00:44:52,390
we've now got a few constructors that

00:44:47,140 --> 00:44:53,920
delegate other constructors and part of

00:44:52,390 --> 00:44:55,740
the way we solve this is we just want a

00:44:53,920 --> 00:44:57,910
different way of passing constructed

00:44:55,740 --> 00:45:00,520
allocators sorry so we've now got a

00:44:57,910 --> 00:45:02,200
convention where we pass allocator arc t

00:45:00,520 --> 00:45:04,359
and the allocator is the first two

00:45:02,200 --> 00:45:05,619
arguments that's great for all new code

00:45:04,359 --> 00:45:07,330
going forward they can have as many

00:45:05,619 --> 00:45:09,339
default arguments after this as I like

00:45:07,330 --> 00:45:11,080
but unfortunately we're baked into an

00:45:09,339 --> 00:45:13,720
interface in the standard where already

00:45:11,080 --> 00:45:16,630
we had allocated passing as the last not

00:45:13,720 --> 00:45:18,609
this encoded first argument so now we've

00:45:16,630 --> 00:45:21,520
got two ways of passing allocators that

00:45:18,609 --> 00:45:26,980
code has to be aware of which is not

00:45:21,520 --> 00:45:30,580
great let me end up with generic wrapper

00:45:26,980 --> 00:45:32,680
types like pair and tuple because they

00:45:30,580 --> 00:45:34,690
don't know the element they you're

00:45:32,680 --> 00:45:36,369
constructing I might need to pass

00:45:34,690 --> 00:45:38,589
allocators through to the elements of

00:45:36,369 --> 00:45:41,080
the pair even though the pair itself

00:45:38,589 --> 00:45:42,970
doesn't allocate so now we have

00:45:41,080 --> 00:45:45,880
allocated support in things like pair

00:45:42,970 --> 00:45:47,260
and topple because we have to be able to

00:45:45,880 --> 00:45:50,320
pass the error cases down through the

00:45:47,260 --> 00:45:52,589
library maybe even that's not good

00:45:50,320 --> 00:45:55,980
enough because unfortunately hit things

00:45:52,589 --> 00:45:59,740
I'm sorry next slide

00:45:55,980 --> 00:46:01,390
I'm gonna skip that one with other

00:45:59,740 --> 00:46:03,220
problem cases like standard array and

00:46:01,390 --> 00:46:05,350
other aggregates where because they

00:46:03,220 --> 00:46:06,880
don't have constructors I don't have the

00:46:05,350 --> 00:46:08,740
ability to give them an allocate or even

00:46:06,880 --> 00:46:11,580
if I want to the same is true for a

00:46:08,740 --> 00:46:14,350
native erase or an array of strings and

00:46:11,580 --> 00:46:16,990
that problem goes down the wellbore so

00:46:14,350 --> 00:46:19,480
I've got a vector of array of strings I

00:46:16,990 --> 00:46:22,480
can pass my vector it's a locator that

00:46:19,480 --> 00:46:24,820
can't pass down to the erase the array

00:46:22,480 --> 00:46:28,030
can't pass it down to the strings in the

00:46:24,820 --> 00:46:32,680
vector so there's these holes that we

00:46:28,030 --> 00:46:34,780
really want to try to fill and again

00:46:32,680 --> 00:46:36,310
there was a problem with type you're

00:46:34,780 --> 00:46:38,020
racing allocators in type of racing

00:46:36,310 --> 00:46:40,930
objects like function and any am going

00:46:38,020 --> 00:46:42,190
i've run too slow i'm gonna run past I'm

00:46:40,930 --> 00:46:43,180
really running out of time I've not got

00:46:42,190 --> 00:46:51,340
that my talk yeah I've got ten minutes

00:46:43,180 --> 00:46:52,960
to go so let's get to my proposal so he

00:46:51,340 --> 00:46:54,760
plan to be here ten minutes ago it was

00:46:52,960 --> 00:46:56,560
heavy on the introductions he knew a

00:46:54,760 --> 00:46:58,830
problem we were trying to solve but I've

00:46:56,560 --> 00:47:01,120
got half the time I wanted to solve it

00:46:58,830 --> 00:47:03,780
again it's my personal bitching for STD

00:47:01,120 --> 00:47:06,520
to the way we solve a lot of this

00:47:03,780 --> 00:47:09,520
complexity problem is we agree on a

00:47:06,520 --> 00:47:11,800
single allocator model so we no longer

00:47:09,520 --> 00:47:14,440
have alligator traits to try to solve

00:47:11,800 --> 00:47:17,560
all of this mess but you have a single

00:47:14,440 --> 00:47:20,170
well-defined way to do this and that

00:47:17,560 --> 00:47:23,590
promotes all-out vocabulary for the into

00:47:20,170 --> 00:47:24,760
operation of api's the anti are going

00:47:23,590 --> 00:47:26,380
with a single model of course is you

00:47:24,760 --> 00:47:28,150
want to have less customizability and

00:47:26,380 --> 00:47:30,430
flexibility so we picked the most

00:47:28,150 --> 00:47:33,970
flexible model we know which is the PMR

00:47:30,430 --> 00:47:35,940
system and the key thing is we keep

00:47:33,970 --> 00:47:38,770
alligators out of the type system which

00:47:35,940 --> 00:47:39,510
greatly simplifies things and gives us a

00:47:38,770 --> 00:47:43,450
vocabulary

00:47:39,510 --> 00:47:44,680
notan we want to keep alligator spam out

00:47:43,450 --> 00:47:46,480
of the interface none of those

00:47:44,680 --> 00:47:48,040
constructors every we're all taking our

00:47:46,480 --> 00:47:50,100
caters we need to find a different way

00:47:48,040 --> 00:47:52,810
to get the alligators into the objects

00:47:50,100 --> 00:47:54,790
we're going to bake in the notion that

00:47:52,810 --> 00:47:56,200
if i've got a data structure the whole

00:47:54,790 --> 00:47:59,020
data structure will always use the same

00:47:56,200 --> 00:48:02,050
alligator that's going to be built into

00:47:59,020 --> 00:48:04,150
this model it's a built in assumption if

00:48:02,050 --> 00:48:06,610
a.type does manage memory it will always

00:48:04,150 --> 00:48:09,220
do so using this alligator system so I

00:48:06,610 --> 00:48:10,900
know it's plugging it in

00:48:09,220 --> 00:48:13,780
one end of the system it will be used

00:48:10,900 --> 00:48:15,910
all the way through and we're going to

00:48:13,780 --> 00:48:18,160
introduce the notion of allocator or

00:48:15,910 --> 00:48:22,870
where types that are known in a special

00:48:18,160 --> 00:48:24,310
way to the type system so in the process

00:48:22,870 --> 00:48:28,540
I'm going to come up with a type B's

00:48:24,310 --> 00:48:30,040
explicitly allocator aware if we mark it

00:48:28,540 --> 00:48:32,020
in a way that says this type is

00:48:30,040 --> 00:48:33,130
allocator aware and that's going to mean

00:48:32,020 --> 00:48:35,680
something special what we're going to

00:48:33,130 --> 00:48:39,580
talk about quickly and the type is

00:48:35,680 --> 00:48:41,740
implicitly allocator aware if it derives

00:48:39,580 --> 00:48:43,990
from an alligator aware class kind of

00:48:41,740 --> 00:48:45,310
like you know I've got a vtable I'm if

00:48:43,990 --> 00:48:48,750
my base class is polymorphic and

00:48:45,310 --> 00:48:51,460
polymorphic but unlike regular quite

00:48:48,750 --> 00:48:54,340
virtual functions also if I have a data

00:48:51,460 --> 00:48:55,690
member that's allocator aware I'm going

00:48:54,340 --> 00:48:57,970
to pick up this funny out alligator

00:48:55,690 --> 00:49:04,390
aware tag so it's a viral one but

00:48:57,970 --> 00:49:06,310
members as well as bases why do we make

00:49:04,390 --> 00:49:07,900
it why is it important we have this

00:49:06,310 --> 00:49:10,120
property for members as well as bases

00:49:07,900 --> 00:49:12,130
well for generic coded on what they have

00:49:10,120 --> 00:49:14,620
to condition we derive from something if

00:49:12,130 --> 00:49:16,300
I tried implementing it through some

00:49:14,620 --> 00:49:18,220
kind of base type base class type

00:49:16,300 --> 00:49:20,230
mechanism but fundamentally for

00:49:18,220 --> 00:49:24,490
aggregates we know we can't solve this

00:49:20,230 --> 00:49:25,810
problem if I have to introduce a

00:49:24,490 --> 00:49:27,670
facility that means my type is no longer

00:49:25,810 --> 00:49:31,570
in aggregate I can't solve negative

00:49:27,670 --> 00:49:33,910
arrays at all this way so the notion is

00:49:31,570 --> 00:49:36,310
we're going to store this PMR pointer

00:49:33,910 --> 00:49:37,810
somewhere somehow and it's going to

00:49:36,310 --> 00:49:42,460
implicitly find its way through the

00:49:37,810 --> 00:49:45,040
system so when allocator aware class

00:49:42,460 --> 00:49:47,470
will use this PMR allocator i supply or

00:49:45,040 --> 00:49:52,240
some variation of PML whatever works for

00:49:47,470 --> 00:49:54,640
the model to manage the memory there'll

00:49:52,240 --> 00:49:56,260
be a consistent API across the system

00:49:54,640 --> 00:49:57,970
that says if I'm given an object I can

00:49:56,260 --> 00:50:03,130
query and say what allocated do you have

00:49:57,970 --> 00:50:04,540
or do you use alligators at all and this

00:50:03,130 --> 00:50:06,010
alligator is assumed never to change

00:50:04,540 --> 00:50:09,670
during the lifetime of the object the

00:50:06,010 --> 00:50:11,050
non propagation trait queering matters

00:50:09,670 --> 00:50:12,490
because when there comes to things like

00:50:11,050 --> 00:50:14,350
move and swap knowing if I've got the

00:50:12,490 --> 00:50:16,150
same alligator at both sides turns out

00:50:14,350 --> 00:50:18,039
to be a big deal

00:50:16,150 --> 00:50:21,220
and there's a few other things but I

00:50:18,039 --> 00:50:26,529
want to jump through the notion of

00:50:21,220 --> 00:50:27,490
implementing allocator awareness yeah

00:50:26,529 --> 00:50:30,400
all there I thought that was going

00:50:27,490 --> 00:50:31,599
through them in implementation details

00:50:30,400 --> 00:50:33,309
before quite described everything I

00:50:31,599 --> 00:50:35,890
wanted to get but we're going to stash

00:50:33,309 --> 00:50:39,089
away an allocate a pointer or a memory

00:50:35,890 --> 00:50:41,140
resource pointer kind of like a V table

00:50:39,089 --> 00:50:44,109
and it's going to be consistent all the

00:50:41,140 --> 00:50:45,910
way through our hierarchy as we start

00:50:44,109 --> 00:50:47,829
allocating creating new objects as I

00:50:45,910 --> 00:50:49,569
passed down to my members my members

00:50:47,829 --> 00:50:53,109
will all have again pick up that same

00:50:49,569 --> 00:50:56,380
allocator we've had to customize this

00:50:53,109 --> 00:50:58,390
API to say implicitly the system knows

00:50:56,380 --> 00:50:59,799
how to store this pointer away but if

00:50:58,390 --> 00:51:02,349
I'm implementing something like standard

00:50:59,799 --> 00:51:05,200
optional I know that when the optional

00:51:02,349 --> 00:51:06,849
is holding an object that object has an

00:51:05,200 --> 00:51:09,369
alligator so I don't need to store a

00:51:06,849 --> 00:51:11,980
copy but when the allocate when the

00:51:09,369 --> 00:51:14,650
empty obviously what object is empty I

00:51:11,980 --> 00:51:17,020
need to retain a copy of that pointer

00:51:14,650 --> 00:51:19,390
but I know that if the object I was

00:51:17,020 --> 00:51:21,130
storing was alligator aware it's at

00:51:19,390 --> 00:51:24,279
least as big as that pointer so I can

00:51:21,130 --> 00:51:25,960
reuse that same region of storage so I'm

00:51:24,279 --> 00:51:27,670
going to want to have to take control of

00:51:25,960 --> 00:51:29,799
this mechanism and say where that

00:51:27,670 --> 00:51:31,329
pointer is stored and it might even be

00:51:29,799 --> 00:51:34,510
changing where it's stored at runtime

00:51:31,329 --> 00:51:37,390
and where I find it for some of these

00:51:34,510 --> 00:51:42,029
use cases so that's the ability we need

00:51:37,390 --> 00:51:45,670
to have within the facility itself and

00:51:42,029 --> 00:51:47,950
if allocator awareness is implicit well

00:51:45,670 --> 00:51:50,920
that means that something either my

00:51:47,950 --> 00:51:52,180
basis of my members already has allocate

00:51:50,920 --> 00:51:53,980
or awareness built-in so I'm not going

00:51:52,180 --> 00:51:55,900
to store an extra copy of that point of

00:51:53,980 --> 00:51:57,220
it the implicit system knows and I just

00:51:55,900 --> 00:51:59,589
keep going down the cane till I find

00:51:57,220 --> 00:52:01,510
that pointer so we can at least push all

00:51:59,589 --> 00:52:04,450
the allocated pointers out to the Leafs

00:52:01,510 --> 00:52:06,369
of the data structure so we don't get to

00:52:04,450 --> 00:52:09,250
lose all the duplicate pointers but we

00:52:06,369 --> 00:52:15,039
can implicitly reduce some portion of

00:52:09,250 --> 00:52:18,010
them so the notion of implicit awareness

00:52:15,039 --> 00:52:20,529
is if I have an alligator aware type or

00:52:18,010 --> 00:52:22,569
if I have a type it's built active

00:52:20,529 --> 00:52:24,740
alligator aware types itself will always

00:52:22,569 --> 00:52:29,390
be allocated aware

00:52:24,740 --> 00:52:31,190
yeah the key issue was allocator

00:52:29,390 --> 00:52:34,070
injection which unfortunately have got a

00:52:31,190 --> 00:52:36,710
very small point sight point size on

00:52:34,070 --> 00:52:40,040
this the idea is when I now construct my

00:52:36,710 --> 00:52:42,680
allocator aware object I want to be able

00:52:40,040 --> 00:52:45,050
to supply its allocator not as a

00:52:42,680 --> 00:52:46,850
parameter to the constructor but I'm

00:52:45,050 --> 00:52:49,340
going to have a separate mechanism to

00:52:46,850 --> 00:52:52,460
say as I run the constructor

00:52:49,340 --> 00:52:55,610
here's the allocator to use so for

00:52:52,460 --> 00:52:58,460
allocator aware typed all constructors

00:52:55,610 --> 00:53:00,920
have a hidden additional allocator

00:52:58,460 --> 00:53:04,220
argument that the system just knows how

00:53:00,920 --> 00:53:06,080
to pass down through so at this point I

00:53:04,220 --> 00:53:08,480
have taken allocator out of all my

00:53:06,080 --> 00:53:10,310
constructors they no longer appear in

00:53:08,480 --> 00:53:13,400
the interface of the code that

00:53:10,310 --> 00:53:16,040
implements these things the system knows

00:53:13,400 --> 00:53:18,680
how to pass them down through so I have

00:53:16,040 --> 00:53:20,330
no code to write to pass the allocator

00:53:18,680 --> 00:53:22,390
in my member initializer list through

00:53:20,330 --> 00:53:26,320
the rest of the system

00:53:22,390 --> 00:53:29,470
so ultimately all the coding complexity

00:53:26,320 --> 00:53:33,640
perceived in the system goes away

00:53:29,470 --> 00:53:36,320
because the syntax is there is no syntax

00:53:33,640 --> 00:53:38,090
other than those few places where I

00:53:36,320 --> 00:53:43,340
actually have to directly interact with

00:53:38,090 --> 00:53:45,500
the allocator itself so this is kind of

00:53:43,340 --> 00:53:46,940
my mental model I'm not saying this is

00:53:45,500 --> 00:53:48,650
what the facility should look like but

00:53:46,940 --> 00:53:52,070
this is the notion of how we might be

00:53:48,650 --> 00:53:54,380
able to use this so when C postures 20

00:53:52,070 --> 00:53:57,770
we already have concept great got

00:53:54,380 --> 00:54:00,830
template movable-type pass vector that

00:53:57,770 --> 00:54:02,690
says I inject allocate this yes what I'm

00:54:00,830 --> 00:54:06,080
explicitly stating in this case that

00:54:02,690 --> 00:54:08,030
vector is alligator aware then we'll

00:54:06,080 --> 00:54:08,540
have an alias called not aware for tuple

00:54:08,030 --> 00:54:10,970
event

00:54:08,540 --> 00:54:12,650
well tuple doesn't need allocators enter

00:54:10,970 --> 00:54:16,220
so an alligator aware sort of tuple

00:54:12,650 --> 00:54:19,460
event is not allocator aware whereas a

00:54:16,220 --> 00:54:22,520
tuple of int and vector event vector is

00:54:19,460 --> 00:54:26,660
now allocator aware so I've associated

00:54:22,520 --> 00:54:28,040
with the tuple vector of some of the

00:54:26,660 --> 00:54:29,810
vector in it that this type will be

00:54:28,040 --> 00:54:32,330
alligator aware and now it's

00:54:29,810 --> 00:54:36,290
constructors have this extra alligator

00:54:32,330 --> 00:54:38,180
pointer hidden behind the system for the

00:54:36,290 --> 00:54:38,750
implementer of vector of support is just

00:54:38,180 --> 00:54:40,670
going to

00:54:38,750 --> 00:54:42,950
happen by magic they don't have to

00:54:40,670 --> 00:54:45,950
interact with this because this

00:54:42,950 --> 00:54:48,710
implicitly falls out of the system so we

00:54:45,950 --> 00:54:50,270
have my local allocator from stack same

00:54:48,710 --> 00:54:54,920
basically I'm going to try a locator off

00:54:50,270 --> 00:54:56,750
some stack resources vector of int data

00:54:54,920 --> 00:54:58,280
one two three I've not given it an

00:54:56,750 --> 00:54:59,900
alligator it just uses the default

00:54:58,280 --> 00:55:02,390
allocator which will typically the

00:54:59,900 --> 00:55:04,820
operator knew we're going to have

00:55:02,390 --> 00:55:07,640
another syntax to say when I construct

00:55:04,820 --> 00:55:09,230
this object I mean again using the

00:55:07,640 --> 00:55:12,080
attribute syntax hopefully we can find

00:55:09,230 --> 00:55:15,680
something neater but it seems to work I

00:55:12,080 --> 00:55:17,450
can inject from stack and from stack

00:55:15,680 --> 00:55:19,730
ease and allocators we've said we inject

00:55:17,450 --> 00:55:21,530
at the allocated facility so he says ok

00:55:19,730 --> 00:55:25,190
whenever I call those construct whenever

00:55:21,530 --> 00:55:27,650
I call a constructor and now pressing in

00:55:25,190 --> 00:55:30,740
the from stack allocator I've set that's

00:55:27,650 --> 00:55:32,540
what it will be so the implicit extra

00:55:30,740 --> 00:55:35,210
argument to these constructors now knows

00:55:32,540 --> 00:55:36,680
to pick up the from stack pointer and

00:55:35,210 --> 00:55:38,360
pass it down through its membrane you

00:55:36,680 --> 00:55:43,160
can whitelist all its bases and members

00:55:38,360 --> 00:55:45,620
all the way and obviously we want to be

00:55:43,160 --> 00:55:48,350
able to do allocations with new and

00:55:45,620 --> 00:55:52,310
delete so when I do a new we can see

00:55:48,350 --> 00:55:55,610
that the bottom example new inject from

00:55:52,310 --> 00:55:58,370
stack I put it on the new call so that

00:55:55,610 --> 00:56:00,530
sense performs the allocation using that

00:55:58,370 --> 00:56:03,230
memory resource and passes that memory

00:56:00,530 --> 00:56:04,760
resource through the implicit system I

00:56:03,230 --> 00:56:06,110
was talking about as the additional

00:56:04,760 --> 00:56:10,070
constructor argument all the way down

00:56:06,110 --> 00:56:11,990
through the cane so a lot of this

00:56:10,070 --> 00:56:13,670
implicit argument passing means the

00:56:11,990 --> 00:56:15,230
complexity is all hidden from the users

00:56:13,670 --> 00:56:17,330
there really is not much more to it

00:56:15,230 --> 00:56:23,450
syntactically when even implementing

00:56:17,330 --> 00:56:26,380
these containers on this so your

00:56:23,450 --> 00:56:29,090
containers use the allocators internally

00:56:26,380 --> 00:56:30,470
so when your container has to do an

00:56:29,090 --> 00:56:33,020
allocation it's going to have to go to

00:56:30,470 --> 00:56:34,580
retrieve this perform the allocations

00:56:33,020 --> 00:56:38,720
but the vast majority of your types

00:56:34,580 --> 00:56:41,060
especially modern C++ we learn not to

00:56:38,720 --> 00:56:42,530
write new and delete because these

00:56:41,060 --> 00:56:44,450
things are all wrapped by objects that

00:56:42,530 --> 00:56:47,270
are already managing that memory for us

00:56:44,450 --> 00:56:48,380
and that gets put way down the system

00:56:47,270 --> 00:56:50,770
most of it comes out the standard

00:56:48,380 --> 00:56:50,770
library

00:56:51,570 --> 00:56:55,990
come on

00:56:53,170 --> 00:57:03,850
I have to figure out which of these to

00:56:55,990 --> 00:57:06,250
jump through quickly well my my sliding

00:57:03,850 --> 00:57:10,470
numbers I think I'm about over actually

00:57:06,250 --> 00:57:13,110
so sorry that's pace myself badly today

00:57:10,470 --> 00:57:17,300
we're done

00:57:13,110 --> 00:57:17,300

YouTube URL: https://www.youtube.com/watch?v=oCi_QZ6K_qk


