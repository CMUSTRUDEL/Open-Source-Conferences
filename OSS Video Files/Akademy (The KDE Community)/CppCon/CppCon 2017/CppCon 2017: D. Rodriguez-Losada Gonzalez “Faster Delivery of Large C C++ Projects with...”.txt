Title: CppCon 2017: D. Rodriguez-Losada Gonzalez “Faster Delivery of Large C C++ Projects with...”
Publication date: 2017-10-09
Playlist: CppCon 2017
Description: 
	Faster Delivery of Large C/C++ Projects with Conan Package Manager and Efficient Continuous Integration

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Dependency information together with the smart management of binaries and binary compatibility of Conan package manager can be used to implement a modularized, fast and efficient Continuous Integration (CI) process for large C and C++ projects. This CI system knows what needs to be rebuilt, what can be built in parallel, and how to transparently manage build dependencies as testing frameworks or toolchains (such as cross-compilation to Android).

This talk will present a CI system, implemented for Jenkins (but which could be implemented in other CI systems too), that using the dependency graph provided by the package manager, is able to trigger dependent packages' build jobs, and only those transitively affected by the change, in the correct build order. Furthermore, the build jobs are arranged in concurrency levels, by the degree/ordering in the graph, but also for different configurations, so optimal build parallelism can be achieved. Also such dependent packages can define custom rules to decide to build themselves or not, depending on configuration or versioning criteria. Everything will be fully demonstrated in practical examples.

We will also present advanced CI techniques, such as how to create packages for tools, like testing frameworks, to lately inject them as build-requirements to other libraries. Moreover, the process can also automate the installation and transparent usage of complete toolchains, like cross compiling C/C++ to Android with the Android NDK toolchain, to achieve a process that is convenient for developers and highly repeatable.
— 
Diego Rodriguez-Losada Gonzalez: JFrog, SW Engineer

Diego's passions are robotics and SW engineering and development. He has developed many years in C and C++ in the Industrial, Robotics and AI fields. Diego was also a University (tenure track) professor and robotics researcher for 8 years, till 2012, when he quit academia to try to build a C/C++ dependency manager and co-founded a startup.. Since then he mostly develops in Python. Diego is a conan.io C/C++ package manager co-creator and maintainer, now working at JFrog as senior SW engineer and C/C++ advocate.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:06,089
so good afternoon thanks very much for

00:00:02,820 --> 00:00:07,799
coming to this insanity of talk about

00:00:06,089 --> 00:00:10,740
DevOps if you thought of all the

00:00:07,799 --> 00:00:14,250
templates were difficult try to prepare

00:00:10,740 --> 00:00:17,850
a talk about DevOps with live demos so

00:00:14,250 --> 00:00:21,570
this is totally undefined behavior I if

00:00:17,850 --> 00:00:25,650
everything works by chance so I'm do I'm

00:00:21,570 --> 00:00:29,369
one of the : creators to wear with with

00:00:25,650 --> 00:00:32,880
my mic Oliver and that we have presently

00:00:29,369 --> 00:00:34,950
joined April so I'm going to talk first

00:00:32,880 --> 00:00:37,710
about the challenges that we face when

00:00:34,950 --> 00:00:40,469
we want to do continued integration with

00:00:37,710 --> 00:00:43,829
ten c++ projects and then i will start

00:00:40,469 --> 00:00:46,050
from the easiest things to the more

00:00:43,829 --> 00:00:48,120
complex problems that we can face and i

00:00:46,050 --> 00:00:50,820
will try to provide like a complete

00:00:48,120 --> 00:00:55,860
solution to the problem that we want to

00:00:50,820 --> 00:00:58,410
solve so the first thing is the c and

00:00:55,860 --> 00:01:00,449
c++ projects because for me it's

00:00:58,410 --> 00:01:02,190
basically the the same regarding in

00:01:00,449 --> 00:01:04,320
continuous integration and they are

00:01:02,190 --> 00:01:07,500
typically very large and otherwise we

00:01:04,320 --> 00:01:10,200
won't we won't be here so one thing with

00:01:07,500 --> 00:01:12,840
large projects is that typically we want

00:01:10,200 --> 00:01:15,030
to manage the binaries so we don't want

00:01:12,840 --> 00:01:18,030
to be building again and again from

00:01:15,030 --> 00:01:19,650
sources so we have to master battery

00:01:18,030 --> 00:01:22,590
where we have to store them somewhere

00:01:19,650 --> 00:01:23,759
and use them there will our developers

00:01:22,590 --> 00:01:27,479
but also our continuous integration

00:01:23,759 --> 00:01:29,820
systems and this is polymeric because we

00:01:27,479 --> 00:01:31,710
have the binary incompatibility so if we

00:01:29,820 --> 00:01:34,170
build a binary with a certain compiler

00:01:31,710 --> 00:01:36,210
version probably it won't link with a

00:01:34,170 --> 00:01:37,619
different compiler version or with

00:01:36,210 --> 00:01:39,900
different settings so with a different

00:01:37,619 --> 00:01:41,490
standard library so we have to be

00:01:39,900 --> 00:01:44,280
careful about our our configuration of

00:01:41,490 --> 00:01:46,530
our binaries and also if we are doing

00:01:44,280 --> 00:01:48,509
more than one platform and we're the

00:01:46,530 --> 00:01:51,619
linux and windows are problem it just

00:01:48,509 --> 00:01:54,720
increases in complexity and one of the

00:01:51,619 --> 00:01:58,049
challenging things that we face in in in

00:01:54,720 --> 00:02:00,180
C++ is the issue of Corinne I mean I

00:01:58,049 --> 00:02:03,659
think no other language have has this

00:02:00,180 --> 00:02:05,640
issue is basically this thing if we are

00:02:03,659 --> 00:02:08,399
developing here a very simple static

00:02:05,640 --> 00:02:11,129
library like this one is just adding to

00:02:08,399 --> 00:02:13,560
integral numbers and we build a static

00:02:11,129 --> 00:02:15,810
library we will see that the

00:02:13,560 --> 00:02:18,180
assembler code is it's very simple is

00:02:15,810 --> 00:02:22,590
this Lea operation is just an of the

00:02:18,180 --> 00:02:24,720
massive person of adding two numbers so

00:02:22,590 --> 00:02:28,800
this is my static library okay that's

00:02:24,720 --> 00:02:30,660
fine but now I'm going to to build

00:02:28,800 --> 00:02:33,300
another library another static library

00:02:30,660 --> 00:02:35,880
mass three that is going to use math to

00:02:33,300 --> 00:02:39,300
to add three numbers and it's going to

00:02:35,880 --> 00:02:41,790
call twice the add function to add those

00:02:39,300 --> 00:02:45,390
three numbers okay so if I build this

00:02:41,790 --> 00:02:47,370
this library is a static - then I have

00:02:45,390 --> 00:02:50,819
this assembler code here and what I've

00:02:47,370 --> 00:02:52,980
got I got two calls to the function that

00:02:50,819 --> 00:02:54,840
actually lives in the other library so

00:02:52,980 --> 00:02:57,480
this is the call and this is the return

00:02:54,840 --> 00:03:00,000
two times four for each invocation okay

00:02:57,480 --> 00:03:03,000
but it is actually not there so when I

00:03:00,000 --> 00:03:04,410
build in my finally executable then it

00:03:03,000 --> 00:03:09,209
will link both together both together

00:03:04,410 --> 00:03:13,260
and the linker will go to the nothing so

00:03:09,209 --> 00:03:15,959
if I go now to the math to library and I

00:03:13,260 --> 00:03:17,609
fix the part or I develop something I

00:03:15,959 --> 00:03:21,840
improve something my code in this case

00:03:17,609 --> 00:03:25,440
I'm just adding a 1 there and then I

00:03:21,840 --> 00:03:26,880
rebuild my math 2 library my code for

00:03:25,440 --> 00:03:29,040
the static library math you will be

00:03:26,880 --> 00:03:31,980
different of course thank inter

00:03:29,040 --> 00:03:35,010
countries near new one number and if I

00:03:31,980 --> 00:03:37,230
rebuild my math 3 library the result

00:03:35,010 --> 00:03:39,390
assembler will be exactly the same why

00:03:37,230 --> 00:03:41,760
because it's just linking the the other

00:03:39,390 --> 00:03:45,180
function that is the lives in in math -

00:03:41,760 --> 00:03:47,549
so everything is fine so if I rebuild my

00:03:45,180 --> 00:03:49,709
final application with these two

00:03:47,549 --> 00:03:52,230
libraries it will be fine because if we

00:03:49,709 --> 00:03:56,370
take him the modification I just did -

00:03:52,230 --> 00:04:00,389
math - okay everything good but what

00:03:56,370 --> 00:04:04,590
happens if for example I build a mass 3

00:04:00,389 --> 00:04:07,470
as a biochemist art library then the

00:04:04,590 --> 00:04:09,209
static library math - will be actually

00:04:07,470 --> 00:04:12,269
embedded in the in the final because

00:04:09,209 --> 00:04:16,109
it's a virus it's an an executable code

00:04:12,269 --> 00:04:19,380
so here we can see that a our code for

00:04:16,109 --> 00:04:21,780
the add 3 function you can see the two

00:04:19,380 --> 00:04:23,460
calls the two calls are not calling the

00:04:21,780 --> 00:04:26,340
static library anymore they are calling

00:04:23,460 --> 00:04:27,479
the function that lives inside this they

00:04:26,340 --> 00:04:30,400
start

00:04:27,479 --> 00:04:33,039
and this is a problem because if I go

00:04:30,400 --> 00:04:35,139
and I go to static library I modify it I

00:04:33,039 --> 00:04:37,300
rebuild and I ribbon by the application

00:04:35,139 --> 00:04:39,400
is going to use the code this inside the

00:04:37,300 --> 00:04:43,960
shared library North Dakota that yes I

00:04:39,400 --> 00:04:47,050
rebuild in the static library and the

00:04:43,960 --> 00:04:50,050
thing is that it also happens for help

00:04:47,050 --> 00:04:52,990
and nowadays everybody's using headers

00:04:50,050 --> 00:04:56,289
we very like like in lining things is

00:04:52,990 --> 00:04:59,080
very optimal for performance so in this

00:04:56,289 --> 00:05:02,050
case well I didn't at the online but it

00:04:59,080 --> 00:05:04,270
is actually doing the inlining here so

00:05:02,050 --> 00:05:07,620
here I just moved the math to

00:05:04,270 --> 00:05:13,060
functionality to the header so when I

00:05:07,620 --> 00:05:15,669
build my math 3 library then I can see

00:05:13,060 --> 00:05:17,680
that assembler is not calling at all a

00:05:15,669 --> 00:05:19,840
math to function it has in length

00:05:17,680 --> 00:05:22,569
everything so it is doing the operation

00:05:19,840 --> 00:05:25,449
there so what does this mean if I change

00:05:22,569 --> 00:05:27,330
the header and I've ever used the static

00:05:25,449 --> 00:05:30,009
library it is using the all

00:05:27,330 --> 00:05:32,710
functionality so I should repeal and

00:05:30,009 --> 00:05:35,139
this is a problem I we will see how we

00:05:32,710 --> 00:05:38,979
will win in system with continuous

00:05:35,139 --> 00:05:42,340
integration trying to be like optimal ok

00:05:38,979 --> 00:05:44,860
so if we are doing call this integration

00:05:42,340 --> 00:05:46,780
and we have to manage the batteries I'm

00:05:44,860 --> 00:05:50,110
going to show you first how to create a

00:05:46,780 --> 00:05:53,800
basic a basic package for a server

00:05:50,110 --> 00:05:56,080
library with with : of course so here we

00:05:53,800 --> 00:05:57,819
have a library a library and we have

00:05:56,080 --> 00:05:59,979
function that is going to print some

00:05:57,819 --> 00:06:03,729
some code to the summer output it's very

00:05:59,979 --> 00:06:05,740
simple and also a Simek file that is

00:06:03,729 --> 00:06:07,930
building this application this I'm sorry

00:06:05,740 --> 00:06:10,330
this is static library it's also very

00:06:07,930 --> 00:06:13,060
simple so the code is there I think

00:06:10,330 --> 00:06:14,979
everybody understand it so if I want to

00:06:13,060 --> 00:06:18,130
create a package economist with with

00:06:14,979 --> 00:06:22,210
these libraries all I need is to add a

00:06:18,130 --> 00:06:24,060
column v dot pi file to my to my record

00:06:22,210 --> 00:06:29,530
to the rep over the where my pod sleep

00:06:24,060 --> 00:06:31,810
how is this column file is something

00:06:29,530 --> 00:06:33,639
like this ok so I'm going to briefly

00:06:31,810 --> 00:06:34,650
explain it so we understand what is

00:06:33,639 --> 00:06:37,719
happening here

00:06:34,650 --> 00:06:38,919
the first important important thing here

00:06:37,719 --> 00:06:40,540
is the digression of settings

00:06:38,919 --> 00:06:43,630
this means ok

00:06:40,540 --> 00:06:45,370
if I change my compiler if I change my

00:06:43,630 --> 00:06:47,790
bill type if I change my architect or

00:06:45,370 --> 00:06:50,080
I'm going to have a different binary and

00:06:47,790 --> 00:06:51,070
for every combination of different

00:06:50,080 --> 00:06:55,330
configuration I'm going to have a

00:06:51,070 --> 00:06:58,000
different battery okay this is important

00:06:55,330 --> 00:06:59,830
we will see it later then I have a bill

00:06:58,000 --> 00:07:01,630
the bill belt is very simple it's just

00:06:59,830 --> 00:07:04,120
calling my bill system in this case I'm

00:07:01,630 --> 00:07:06,550
using CA because everybody understand it

00:07:04,120 --> 00:07:09,070
but it can just directly call visual

00:07:06,550 --> 00:07:11,530
studio solution or any bill system you

00:07:09,070 --> 00:07:13,660
you want to wrap you can just wrap it

00:07:11,530 --> 00:07:17,560
and create packages from your build

00:07:13,660 --> 00:07:19,300
system then you will have a package

00:07:17,560 --> 00:07:20,920
method that is just extracting the

00:07:19,300 --> 00:07:23,680
artifacts in this case the header and

00:07:20,920 --> 00:07:26,770
static library all the other code and

00:07:23,680 --> 00:07:27,640
everything is for Windows so I told you

00:07:26,770 --> 00:07:30,130
if this is going to be undefined

00:07:27,640 --> 00:07:33,430
behavior I'm doing DevOps in Windows in

00:07:30,130 --> 00:07:35,740
live step so this is going to be 10 so

00:07:33,430 --> 00:07:37,720
I'm using here leap extensions but you

00:07:35,740 --> 00:07:40,450
can use also a extension if you are

00:07:37,720 --> 00:07:42,130
working in looks so it will work in able

00:07:40,450 --> 00:07:44,200
platform with very little modifications

00:07:42,130 --> 00:07:45,700
so this is the package metal that is

00:07:44,200 --> 00:07:47,770
extracting the artifacts have a

00:07:45,700 --> 00:07:50,560
libraries and put them in the final

00:07:47,770 --> 00:07:52,150
package and finally we have the packet

00:07:50,560 --> 00:07:55,120
information this is the information for

00:07:52,150 --> 00:07:58,090
our consumers so when consumers they are

00:07:55,120 --> 00:08:00,550
using this package they they know that

00:07:58,090 --> 00:08:03,730
they they have to link with the hello

00:08:00,550 --> 00:08:05,740
library for example any purposes for the

00:08:03,730 --> 00:08:07,930
Phoenicians we want to have include

00:08:05,740 --> 00:08:10,360
directories library directors library

00:08:07,930 --> 00:08:12,790
names compiler flags that we want our

00:08:10,360 --> 00:08:15,070
consumers to use we will put them there

00:08:12,790 --> 00:08:19,240
it would be equivalent to PC files more

00:08:15,070 --> 00:08:21,790
or less in Linux okay so with this file

00:08:19,240 --> 00:08:24,160
I can just create my packages I'm going

00:08:21,790 --> 00:08:29,190
to show you first in the in the command

00:08:24,160 --> 00:08:29,190
line so I asked our repo here

00:08:35,279 --> 00:08:42,479
okay with a with a current file so I can

00:08:38,950 --> 00:08:45,610
show you the Riley can create user

00:08:42,479 --> 00:08:50,710
testing and it's going to build my

00:08:45,610 --> 00:08:51,390
package okay so now it's calling see

00:08:50,710 --> 00:08:53,920
mate

00:08:51,390 --> 00:08:57,040
it takes a while with a lot of Bissell

00:08:53,920 --> 00:09:00,400
stories kind of slow and finally I have

00:08:57,040 --> 00:09:02,560
I have my package so I can inspect well

00:09:00,400 --> 00:09:05,140
actually I can repeat this process for

00:09:02,560 --> 00:09:07,330
any configuration I want so in this case

00:09:05,140 --> 00:09:11,529
I just used my default that is Visual

00:09:07,330 --> 00:09:12,820
Studio 2017 64 bits release whatever but

00:09:11,529 --> 00:09:15,250
if I want to build for other

00:09:12,820 --> 00:09:16,510
configuration I just I just tell tell

00:09:15,250 --> 00:09:18,940
the scene okay I want to create a

00:09:16,510 --> 00:09:22,570
package but in this case I want to

00:09:18,940 --> 00:09:24,520
create a package for 32 bits so I would

00:09:22,570 --> 00:09:27,790
just pass the architecture as an

00:09:24,520 --> 00:09:35,530
argument and then I will I will create a

00:09:27,790 --> 00:09:38,589
package for 32 it's if I expect my

00:09:35,530 --> 00:09:41,320
mykola a micron local cache I will see

00:09:38,589 --> 00:09:47,050
the way I've a library here a la package

00:09:41,320 --> 00:09:49,480
here and if I inspect this package I

00:09:47,050 --> 00:09:52,930
will see that I have two binaries I have

00:09:49,480 --> 00:09:57,339
one binary here for 32 bits and I have

00:09:52,930 --> 00:09:59,530
another banner here for for 64 bits so

00:09:57,339 --> 00:10:01,150
right now I could just okay

00:09:59,530 --> 00:10:04,270
those miners are cool I want to share

00:10:01,150 --> 00:10:08,110
them with my team and so I could just do

00:10:04,270 --> 00:10:11,020
current upload okay and upload it to a

00:10:08,110 --> 00:10:14,230
server but I am going to to do it with

00:10:11,020 --> 00:10:17,740
continuous integration so what I just

00:10:14,230 --> 00:10:19,060
did is I developed I created locally in

00:10:17,740 --> 00:10:21,310
my machine

00:10:19,060 --> 00:10:23,200
those two battles so I have a package

00:10:21,310 --> 00:10:25,089
recipe that is the column file and I

00:10:23,200 --> 00:10:30,310
have two binaries for two different

00:10:25,089 --> 00:10:34,209
configurations so those binaries they

00:10:30,310 --> 00:10:36,310
have an identifier so the identifier for

00:10:34,209 --> 00:10:38,170
each package binary it's just the hash

00:10:36,310 --> 00:10:40,690
of the all the settings and of

00:10:38,170 --> 00:10:43,150
everything that can affect my battery we

00:10:40,690 --> 00:10:44,140
will cancel a sha-1 signature and that

00:10:43,150 --> 00:10:45,850
will be there

00:10:44,140 --> 00:10:49,780
five packages will be similar to what

00:10:45,850 --> 00:10:51,670
boost does with a sort of for example so

00:10:49,780 --> 00:10:53,320
in this case if you change the compiler

00:10:51,670 --> 00:10:55,330
there are better version the standard

00:10:53,320 --> 00:10:57,550
library for example or you are between a

00:10:55,330 --> 00:11:00,600
static or dynamic it will change and you

00:10:57,550 --> 00:11:03,610
will get a different package setting

00:11:00,600 --> 00:11:05,680
okay so when you have your batteries

00:11:03,610 --> 00:11:09,130
local and then the next step is to

00:11:05,680 --> 00:11:11,470
upload them to a server the server we

00:11:09,130 --> 00:11:13,600
had : also have a : server that is also

00:11:11,470 --> 00:11:16,270
open source with MIT license this is

00:11:13,600 --> 00:11:18,340
fine for for for a small and medium 16

00:11:16,270 --> 00:11:20,860
teens but it'll also work without the

00:11:18,340 --> 00:11:21,850
factory that's integration in this case

00:11:20,860 --> 00:11:23,470
in this talk I'm going to use

00:11:21,850 --> 00:11:25,810
artifactory because artifactory has a

00:11:23,470 --> 00:11:28,750
web UI so we can see the packets there

00:11:25,810 --> 00:11:31,150
in the now cool web interface okay but

00:11:28,750 --> 00:11:32,950
it but you can use both so then this

00:11:31,150 --> 00:11:35,860
upload is what I'm going to automate

00:11:32,950 --> 00:11:37,420
with with Jenkins okay so I'm going to

00:11:35,860 --> 00:11:41,410
create by my package with Jenkins

00:11:37,420 --> 00:11:42,970
so if I want to this package to be

00:11:41,410 --> 00:11:45,310
automatically created in continuous

00:11:42,970 --> 00:11:47,920
integration so the easiest thing is to

00:11:45,310 --> 00:11:50,800
add a Jenkins file to my rep or two so I

00:11:47,920 --> 00:11:52,690
will add a Jenkins file and in this case

00:11:50,800 --> 00:11:57,160
I'm going to use the the new pipeline

00:11:52,690 --> 00:12:00,010
syntax so do you know Jenkins used to to

00:11:57,160 --> 00:12:02,110
use a loader but now they are promoting

00:12:00,010 --> 00:12:03,850
very heavily to use pipelines that

00:12:02,110 --> 00:12:08,590
actually they are actually groovy

00:12:03,850 --> 00:12:10,450
scripts okay so a pipeline in Jenkins is

00:12:08,590 --> 00:12:13,990
something like this it has some stages

00:12:10,450 --> 00:12:17,740
the first one is very easy just check

00:12:13,990 --> 00:12:20,170
out the source code I'm defining that

00:12:17,740 --> 00:12:22,540
second stage for continuous integration

00:12:20,170 --> 00:12:25,990
is create the package so just the like

00:12:22,540 --> 00:12:28,540
that that I I rolled in in the common

00:12:25,990 --> 00:12:30,430
line it's going to be executed by by

00:12:28,540 --> 00:12:34,240
Jenkins here okay

00:12:30,430 --> 00:12:37,060
you can see that I'm running here

00:12:34,240 --> 00:12:41,830
client run and the clients out run

00:12:37,060 --> 00:12:44,620
client is a current client so I'm using

00:12:41,830 --> 00:12:46,060
here a plug-in so artifactory and

00:12:44,620 --> 00:12:48,070
jenkees they have a the Genki

00:12:46,060 --> 00:12:51,940
satifactory plugin that will implement

00:12:48,070 --> 00:12:53,530
this this helper this DSL for us but if

00:12:51,940 --> 00:12:55,720
you are using any other build system

00:12:53,530 --> 00:12:56,709
just in your scripts for your for your

00:12:55,720 --> 00:12:59,050
condition integration

00:12:56,709 --> 00:13:02,290
just call collab create and the packets

00:12:59,050 --> 00:13:05,860
will be created and finally in the last

00:13:02,290 --> 00:13:09,490
stage of the of the pipeline Jenkins

00:13:05,860 --> 00:13:15,459
will upload what it just built to the to

00:13:09,490 --> 00:13:18,670
the remote to their server okay finally

00:13:15,459 --> 00:13:23,439
if I want to for example to build

00:13:18,670 --> 00:13:25,929
different configuration at once or at

00:13:23,439 --> 00:13:27,550
once parallel for example I could use

00:13:25,929 --> 00:13:29,649
the parallel features of the of the

00:13:27,550 --> 00:13:30,850
pipeline in this case I want to build

00:13:29,649 --> 00:13:34,209
both 32 bits

00:13:30,850 --> 00:13:37,660
city for bits architectures in Jenkins

00:13:34,209 --> 00:13:40,720
so what I can do is ok so I can just

00:13:37,660 --> 00:13:44,649
launch two nodes that will be identical

00:13:40,720 --> 00:13:50,170
to the two this here two times but the

00:13:44,649 --> 00:13:52,809
first one we'll use the x86 architecture

00:13:50,170 --> 00:13:55,660
and the other one will be using their

00:13:52,809 --> 00:13:58,949
64-bit circulator so those are basically

00:13:55,660 --> 00:14:03,699
same they are launched in parallel and

00:13:58,949 --> 00:14:07,990
they will create both packages so we are

00:14:03,699 --> 00:14:11,889
going to try here we can see our gem

00:14:07,990 --> 00:14:15,819
consistence this is the leap a pipeline

00:14:11,889 --> 00:14:18,699
everything is empty now so what I'm

00:14:15,819 --> 00:14:20,079
going to do is okay half I have my

00:14:18,699 --> 00:14:41,939
library here and just going to introduce

00:14:20,079 --> 00:14:41,939
a fake commit so sorry wrong over here

00:14:43,559 --> 00:14:52,149
okay so I just committed some some

00:14:46,569 --> 00:14:54,369
commit into my repo and now a Jenkins

00:14:52,149 --> 00:14:58,119
will detect this it takes a while it

00:14:54,369 --> 00:14:59,679
takes elaborate half a minute to detect

00:14:58,119 --> 00:15:03,480
there that the changes have been

00:14:59,679 --> 00:15:05,980
introduced because it is using cron jobs

00:15:03,480 --> 00:15:08,379
no it's not necessary because the asylum

00:15:05,980 --> 00:15:10,390
I'm running everything locally yeah so I

00:15:08,379 --> 00:15:13,870
will go I will configure

00:15:10,390 --> 00:15:15,640
a pipeline for the next library yeah so

00:15:13,870 --> 00:15:18,640
it detects the baby has a new commit and

00:15:15,640 --> 00:15:20,710
it will it will eventually launch yeah

00:15:18,640 --> 00:15:22,690
the bad thing is that the the pipeline's

00:15:20,710 --> 00:15:25,090
they have a they are run with a crawler

00:15:22,690 --> 00:15:27,040
script with crunch in tax and with

00:15:25,090 --> 00:15:29,200
Crohn's you can go down up to a minute

00:15:27,040 --> 00:16:00,130
so on average you have to wait 30

00:15:29,200 --> 00:16:06,610
seconds or something like that no

00:16:00,130 --> 00:16:09,760
especially in Windows it worked like two

00:16:06,610 --> 00:16:16,780
minutes ago I'm just going to build to

00:16:09,760 --> 00:16:20,050
lunch to be manually now it lunch demo

00:16:16,780 --> 00:16:26,680
effect so it's going to build twice both

00:16:20,050 --> 00:16:29,620
configurations so now it is a building

00:16:26,680 --> 00:16:32,710
in parallel both architectures 32 and 64

00:16:29,620 --> 00:16:35,890
bits two times so I only do in every row

00:16:32,710 --> 00:16:38,020
you you you are building the both

00:16:35,890 --> 00:16:42,400
architectures okay so the only things

00:16:38,020 --> 00:16:48,700
that is within twice okay everything

00:16:42,400 --> 00:16:55,240
looks good oh I don't know why why this

00:16:48,700 --> 00:17:00,280
is fair in any case I'm going to check

00:16:55,240 --> 00:17:03,490
in artifact terrine and here it looks

00:17:00,280 --> 00:17:06,880
good I have here my package my battery

00:17:03,490 --> 00:17:07,630
for 32 bits and here I have my packs for

00:17:06,880 --> 00:17:13,959
64 bits

00:17:07,630 --> 00:17:16,839
ok so now I have set up my mic holders

00:17:13,959 --> 00:17:20,110
they can just to get pushes and Jenkins

00:17:16,839 --> 00:17:22,180
we will fire a job or a number of jobs

00:17:20,110 --> 00:17:23,079
and it will create packages for all the

00:17:22,180 --> 00:17:25,299
architectures and all the

00:17:23,079 --> 00:17:29,110
settings I I want to configure in my in

00:17:25,299 --> 00:17:31,809
my containers integration ok so this is

00:17:29,110 --> 00:17:34,840
what I did just some changes in the code

00:17:31,809 --> 00:17:36,970
go to keep the world to keep Jenkins and

00:17:34,840 --> 00:17:39,820
is finally will upload to artifactory my

00:17:36,970 --> 00:17:41,169
final packages so other users or the

00:17:39,820 --> 00:17:44,950
developers or my continuous integration

00:17:41,169 --> 00:17:47,740
system can use them okay but what

00:17:44,950 --> 00:17:50,950
happens to packages that have

00:17:47,740 --> 00:17:54,279
dependencies okay let's go for for a new

00:17:50,950 --> 00:17:57,100
one a library be that depends on the

00:17:54,279 --> 00:18:01,659
library a that we just created so the B

00:17:57,100 --> 00:18:06,970
will be including a and it will be

00:18:01,659 --> 00:18:09,549
calling a okay very simple so regarding

00:18:06,970 --> 00:18:12,309
the column file or I have to do is to

00:18:09,549 --> 00:18:14,230
define the requirements so here I

00:18:12,309 --> 00:18:17,909
maintain okay so I'm repairing will

00:18:14,230 --> 00:18:22,899
abate and I recorded leap a version 100

00:18:17,909 --> 00:18:24,399
good then also I need a some connection

00:18:22,899 --> 00:18:26,470
to the build system in this case I'm

00:18:24,399 --> 00:18:28,600
telling current a I'm going to build

00:18:26,470 --> 00:18:31,720
with CMake please generate a see make

00:18:28,600 --> 00:18:37,600
fight for me so my C make scripts they

00:18:31,720 --> 00:18:39,730
know where my dependencies are so the

00:18:37,600 --> 00:18:41,799
the C make list will do something like

00:18:39,730 --> 00:18:43,990
this it will include the file that color

00:18:41,799 --> 00:18:46,600
is is generating that is typically full

00:18:43,990 --> 00:18:48,940
of the all the include paths library

00:18:46,600 --> 00:18:51,279
path library names variables so it can

00:18:48,940 --> 00:18:53,710
be used into my into my build in this

00:18:51,279 --> 00:18:57,039
case column will be defining target with

00:18:53,710 --> 00:18:59,769
a modern Simek syntax so my B library

00:18:57,039 --> 00:19:03,970
can just link with with a target define

00:18:59,769 --> 00:19:06,760
for living okay

00:19:03,970 --> 00:19:14,399
the Jenkins file is exactly the same so

00:19:06,760 --> 00:19:14,399
nothing nothing new here so let's try to

00:19:17,399 --> 00:19:20,399
Libby

00:19:31,049 --> 00:19:38,950
okay and then I'm going to commit but

00:19:37,299 --> 00:19:41,859
the thing is that I didn't define it the

00:19:38,950 --> 00:19:45,279
the pipeline yet so I wanted to show you

00:19:41,859 --> 00:19:48,460
that actually the pipeline's in Jenkins

00:19:45,279 --> 00:19:50,259
they are very easy to set up because all

00:19:48,460 --> 00:19:52,929
I have to do is to define okay I'm going

00:19:50,259 --> 00:19:56,619
to define a new line item this is going

00:19:52,929 --> 00:20:02,080
to be called leap B and I'm going to do

00:19:56,619 --> 00:20:06,279
a multi bright multi branch pipe and so

00:20:02,080 --> 00:20:08,559
the defaults are a all are good or

00:20:06,279 --> 00:20:11,979
almost good so I'm just going to add by

00:20:08,559 --> 00:20:16,269
my source repo so that's why it worked

00:20:11,979 --> 00:20:23,259
in in before because I'm just doing here

00:20:16,269 --> 00:20:25,119
my local repo and in this case it will

00:20:23,259 --> 00:20:28,289
fire automatically beside I just created

00:20:25,119 --> 00:20:32,169
the the pipeline so what it works and

00:20:28,289 --> 00:20:35,440
Billy B what is happening here okay so

00:20:32,169 --> 00:20:38,889
Jenkins has decided that it want to

00:20:35,440 --> 00:20:41,139
build Libby and if it has the source

00:20:38,889 --> 00:20:43,299
code it has the build system so the

00:20:41,139 --> 00:20:46,029
first thing it will do it will be to

00:20:43,299 --> 00:20:49,210
retreat the dependencies okay as B

00:20:46,029 --> 00:20:51,369
requires a to build the first thing is

00:20:49,210 --> 00:20:53,830
okay artifactory then or the server

00:20:51,369 --> 00:20:55,960
I need Lib a so it will retrieve a

00:20:53,830 --> 00:20:57,999
binary for lib a so when you are

00:20:55,960 --> 00:21:00,190
building leap be in CODIS integration

00:20:57,999 --> 00:21:01,779
you don't need to build leap a again

00:21:00,190 --> 00:21:04,509
from sources you are using the batteries

00:21:01,779 --> 00:21:06,700
from from artifactory if we retrieve all

00:21:04,509 --> 00:21:08,679
the dependencies if there are transitive

00:21:06,700 --> 00:21:11,649
dependencies it will give all of them it

00:21:08,679 --> 00:21:14,139
will be the dependency graph and it will

00:21:11,649 --> 00:21:16,479
order things and output this column

00:21:14,139 --> 00:21:17,799
building followed see make file this

00:21:16,479 --> 00:21:19,599
column billing followed Simic file is

00:21:17,799 --> 00:21:20,649
the one that is loaded by the by the

00:21:19,599 --> 00:21:24,099
Simic

00:21:20,649 --> 00:21:28,210
file of the of the Lib Lib be project

00:21:24,099 --> 00:21:32,169
and it will be used to build the be

00:21:28,210 --> 00:21:35,499
binary and once we have the Debbie

00:21:32,169 --> 00:21:37,960
binary then we are uploading it to

00:21:35,499 --> 00:21:39,489
artifactory why because we are in start

00:21:37,960 --> 00:21:42,609
factory as our truth

00:21:39,489 --> 00:21:44,830
so all the artifacts are always a store

00:21:42,609 --> 00:21:47,200
in our Factory I I know we could use

00:21:44,830 --> 00:21:49,779
like another mechanism like C cash for

00:21:47,200 --> 00:21:51,549
example and I will be locally but this

00:21:49,779 --> 00:21:54,190
approach work works for every platform

00:21:51,549 --> 00:21:56,830
in Windows you can just your satifactory

00:21:54,190 --> 00:21:58,719
as your source of truth of miners all

00:21:56,830 --> 00:22:06,609
the time and downloading and uploading

00:21:58,719 --> 00:22:11,710
is very fast yeah so the the thing was

00:22:06,609 --> 00:22:13,749
so that when this is working and it is

00:22:11,710 --> 00:22:16,029
retrieving dependencies of course it

00:22:13,749 --> 00:22:18,399
only retrieves the dependencies the

00:22:16,029 --> 00:22:22,089
batteries that it needs so if in this

00:22:18,399 --> 00:22:26,649
case it's building lib be for 64 bits it

00:22:22,089 --> 00:22:27,039
will already be treif divided for 64

00:22:26,649 --> 00:22:30,369
bits

00:22:27,039 --> 00:22:32,739
okay this matters because sometimes you

00:22:30,369 --> 00:22:35,409
you have up to hundreds of binaries

00:22:32,739 --> 00:22:36,700
depending on on the what you are doing

00:22:35,409 --> 00:22:38,229
there are currently users that we have

00:22:36,700 --> 00:22:39,849
hundreds of binary for the same library

00:22:38,229 --> 00:22:42,879
so if you are doing question you don't

00:22:39,849 --> 00:22:47,889
want to download 100 batteries just to

00:22:42,879 --> 00:22:51,460
link with one of them okay so let's see

00:22:47,889 --> 00:22:54,609
I hope this division has finished and

00:22:51,460 --> 00:22:55,210
now I should have two packages here

00:22:54,609 --> 00:23:00,989
lately

00:22:55,210 --> 00:23:06,119
a al-libi for Libby I will also get the

00:23:00,989 --> 00:23:06,119
8086 and 64 bits

00:23:08,969 --> 00:23:21,519
okay so let me launch why we will I

00:23:13,359 --> 00:23:23,759
speak I'm going to boost drop some more

00:23:21,519 --> 00:23:23,759
libraries

00:23:27,650 --> 00:23:34,200
okay looks good so now suppose that we

00:23:32,520 --> 00:23:36,600
have a more complex application

00:23:34,200 --> 00:23:39,090
something like this okay so I have a

00:23:36,600 --> 00:23:41,640
full dependency graph I have these

00:23:39,090 --> 00:23:43,020
typical diamond structures that they are

00:23:41,640 --> 00:23:46,740
important because they can lead to

00:23:43,020 --> 00:23:49,710
conflicts so if I if I go to a certain

00:23:46,740 --> 00:23:51,600
version or one branch of the diamond and

00:23:49,710 --> 00:23:54,390
I get one different one that I have a

00:23:51,600 --> 00:23:55,770
conflict and I have to solve it okay so

00:23:54,390 --> 00:23:58,650
this would be an example of an

00:23:55,770 --> 00:24:01,020
application project I want to build the

00:23:58,650 --> 00:24:03,420
app code will be very simple in this

00:24:01,020 --> 00:24:07,320
case it will be calling just C and D if

00:24:03,420 --> 00:24:10,410
you check here we have C and D libraries

00:24:07,320 --> 00:24:14,400
the depend on D okay so my application

00:24:10,410 --> 00:24:16,500
will be just calling CMD you can see

00:24:14,400 --> 00:24:21,870
here the main function is calling C and

00:24:16,500 --> 00:24:24,720
D and my simic file will just in this

00:24:21,870 --> 00:24:27,150
case link with two targets the targets

00:24:24,720 --> 00:24:28,920
for Lib C and the target for lip D the

00:24:27,150 --> 00:24:34,530
rest is actually exactly the same as a

00:24:28,920 --> 00:24:37,890
slippies very simple so to to build this

00:24:34,530 --> 00:24:40,620
application i need also a column file so

00:24:37,890 --> 00:24:43,320
in this column file it's also very

00:24:40,620 --> 00:24:45,450
similar i only have to do add in this

00:24:43,320 --> 00:24:49,050
case i i want to depend on two libraries

00:24:45,450 --> 00:24:52,260
lip cl- so i differ both of them okay

00:24:49,050 --> 00:24:54,420
I'm adding a also a line here in the

00:24:52,260 --> 00:24:56,070
build method to run the binary that I

00:24:54,420 --> 00:24:58,260
just built it's just for convenience so

00:24:56,070 --> 00:25:01,200
I'm going to build things and I want the

00:24:58,260 --> 00:25:03,870
output of the of the rallyin application

00:25:01,200 --> 00:25:06,390
and also the packaging but this is not

00:25:03,870 --> 00:25:10,980
important so let's check if this has

00:25:06,390 --> 00:25:13,440
finished looks good and everything has

00:25:10,980 --> 00:25:22,020
been uploaded to our tea factory okay so

00:25:13,440 --> 00:25:25,190
I'm going to show you I'm moving to a

00:25:22,020 --> 00:25:27,780
clean folder to be my my project

00:25:25,190 --> 00:25:29,400
okay so what I'm doing here I'm not

00:25:27,780 --> 00:25:31,890
going to create a package I want us to

00:25:29,400 --> 00:25:34,650
develop so I'm going to use this column

00:25:31,890 --> 00:25:36,390
file and just as our as a recipe to

00:25:34,650 --> 00:25:37,260
retrieve my dependencies but I will be

00:25:36,390 --> 00:25:39,060
working locally

00:25:37,260 --> 00:25:41,130
I'm not created a package anymore so I

00:25:39,060 --> 00:25:45,090
will be just : installing

00:25:41,130 --> 00:25:48,900
dependencies okay I got my dependencies

00:25:45,090 --> 00:25:51,210
am I going to execute : bill this is

00:25:48,900 --> 00:25:53,580
just a local build off of my application

00:25:51,210 --> 00:25:55,350
it would be the same if you run she make

00:25:53,580 --> 00:25:59,060
manually it will be exactly the same

00:25:55,350 --> 00:26:02,310
okay so here I can see the output

00:25:59,060 --> 00:26:05,430
yeah of a leap aid is being calling

00:26:02,310 --> 00:26:08,580
twice because I have any an inside of

00:26:05,430 --> 00:26:11,010
the of the diamond okay so everything is

00:26:08,580 --> 00:26:18,260
working here so I could repeat the same

00:26:11,010 --> 00:26:30,720
thing I could just wipe this : install

00:26:18,260 --> 00:26:32,880
for 32 bits : bill and what I'm doing is

00:26:30,720 --> 00:26:36,390
I'm just retrieving my dependencies for

00:26:32,880 --> 00:26:38,520
64 bits for 32 bits and I'm calling one

00:26:36,390 --> 00:26:40,680
or the other okay so for me this is

00:26:38,520 --> 00:26:42,420
amazing because actually I'm I'm I can

00:26:40,680 --> 00:26:44,100
have a different dependency graph

00:26:42,420 --> 00:26:45,840
depending on my architecture or

00:26:44,100 --> 00:26:52,310
depending on my operating system or

00:26:45,840 --> 00:26:52,310
whatever so I can check here for example

00:26:54,650 --> 00:27:04,730
my dependency graph sorry to the TSA's

00:27:07,040 --> 00:27:12,900
so here you can see my project here

00:27:10,350 --> 00:27:15,090
depending on C and B which in turn

00:27:12,900 --> 00:27:17,340
depend on B so the graph that I I saw

00:27:15,090 --> 00:27:19,200
you in the sides it's just what the tool

00:27:17,340 --> 00:27:30,290
is giving is giving me so you can tailor

00:27:19,200 --> 00:27:33,570
this this is real okay so so far so good

00:27:30,290 --> 00:27:36,260
the challenge the real challenge is when

00:27:33,570 --> 00:27:40,080
we start to evolve our dependencies so

00:27:36,260 --> 00:27:44,510
what happened if I now go and I I do an

00:27:40,080 --> 00:27:48,270
amazing improvement to my code and I

00:27:44,510 --> 00:27:50,040
generated this also message okay cool

00:27:48,270 --> 00:27:54,610
functionality I'm going to release a new

00:27:50,040 --> 00:27:58,090
version I'm going to release version 101

00:27:54,610 --> 00:28:20,280
eBay so I go to buy qualified and I bump

00:27:58,090 --> 00:28:30,880
the version and I create the package I

00:28:20,280 --> 00:28:33,070
got this then I do my commit I'm just

00:28:30,880 --> 00:28:37,540
going to fire it manually so so we don't

00:28:33,070 --> 00:28:40,240
have to wait and now it is building my

00:28:37,540 --> 00:28:41,830
new version is within 101 for for a

00:28:40,240 --> 00:28:51,400
debate that includes the new

00:28:41,830 --> 00:28:55,570
functionality so now in a while we

00:28:51,400 --> 00:28:59,140
should see that for eBay now we have two

00:28:55,570 --> 00:29:01,630
packages we have version point 0 and

00:28:59,140 --> 00:29:04,360
version point 1 okay and for each one I

00:29:01,630 --> 00:29:10,870
have two banners for the two bits and

00:29:04,360 --> 00:29:13,330
another two bits are collector okay so

00:29:10,870 --> 00:29:15,970
what I have right now is this I have

00:29:13,330 --> 00:29:16,840
created two packages sorry - yeah two

00:29:15,970 --> 00:29:19,059
different packages for two different

00:29:16,840 --> 00:29:20,679
version of leeway but if I go to my

00:29:19,059 --> 00:29:22,600
application and I've been like a

00:29:20,679 --> 00:29:24,190
petition it is still going to show the

00:29:22,600 --> 00:29:26,770
the previous code because my dependency

00:29:24,190 --> 00:29:30,370
graph is that okay so what could I do

00:29:26,770 --> 00:29:38,200
the typical thing and the thing that

00:29:30,370 --> 00:29:40,360
most users are doing is this so it will

00:29:38,200 --> 00:29:43,960
be the manual update of the dependencies

00:29:40,360 --> 00:29:47,200
okay so let's say that now I want to use

00:29:43,960 --> 00:29:52,059
the new functionality from a ok so I

00:29:47,200 --> 00:29:55,150
will go to B and I will bump here my

00:29:52,059 --> 00:29:56,770
requirement tool to leave it okay and

00:29:55,150 --> 00:30:00,480
then I will bump my depend my own

00:29:56,770 --> 00:30:03,370
dependency of Libby okay actually

00:30:00,480 --> 00:30:06,700
typically you will also do some source

00:30:03,370 --> 00:30:07,940
code changes but not always so so you

00:30:06,700 --> 00:30:12,950
can just

00:30:07,940 --> 00:30:16,310
bump your your version and unfired your

00:30:12,950 --> 00:30:20,030
bill and you will have this here okay so

00:30:16,310 --> 00:30:23,240
we are going down the hierarchy here one

00:30:20,030 --> 00:30:25,820
by one it is good it is an order way to

00:30:23,240 --> 00:30:29,660
do it we will be testing everything but

00:30:25,820 --> 00:30:33,340
we will be a slow okay is it possible to

00:30:29,660 --> 00:30:36,200
do something so we can go faster

00:30:33,340 --> 00:30:38,060
so here the challenge is how to update

00:30:36,200 --> 00:30:39,830
dependencies when the source code

00:30:38,060 --> 00:30:42,380
doesn't change actually in this example

00:30:39,830 --> 00:30:46,460
I haven't changed the source code for B

00:30:42,380 --> 00:30:49,280
at all the circle is exactly the same so

00:30:46,460 --> 00:30:50,750
what what can I do there are different

00:30:49,280 --> 00:30:52,760
ways to update your dependencies

00:30:50,750 --> 00:30:54,920
upstream the first one is to be explicit

00:30:52,760 --> 00:30:58,640
and just bump the versions manually one

00:30:54,920 --> 00:31:01,100
by one and keep running there are other

00:30:58,640 --> 00:31:03,500
ways for example there is one that would

00:31:01,100 --> 00:31:05,660
be like server based or let's say

00:31:03,500 --> 00:31:08,330
defined by the package creator you can

00:31:05,660 --> 00:31:09,470
you can have an alias it's basically

00:31:08,330 --> 00:31:12,740
like a symlink

00:31:09,470 --> 00:31:15,650
or so they package creator the files

00:31:12,740 --> 00:31:18,530
okay I have this this for example

00:31:15,650 --> 00:31:20,780
virtual one all and this is a simile

00:31:18,530 --> 00:31:22,850
this is my radius for the lattice what

00:31:20,780 --> 00:31:27,490
for latest version of the package sector

00:31:22,850 --> 00:31:30,860
so every time it he created the package

00:31:27,490 --> 00:31:32,780
he can update the alias on updating the

00:31:30,860 --> 00:31:35,210
alias the alias it will make the

00:31:32,780 --> 00:31:36,530
consumers of that alias to retrieve the

00:31:35,210 --> 00:31:39,710
latest live expression of the package

00:31:36,530 --> 00:31:41,960
okay so this is something to retrieve

00:31:39,710 --> 00:31:44,710
the latest version of a certain packet

00:31:41,960 --> 00:31:48,110
but they find it by the package creator

00:31:44,710 --> 00:31:50,960
then we also have virtual ranges version

00:31:48,110 --> 00:31:54,800
this is the typical expression you can

00:31:50,960 --> 00:31:57,460
use the approximate approach of a node

00:31:54,800 --> 00:31:59,390
chamber for example you can use an or

00:31:57,460 --> 00:32:01,850
different different condition there

00:31:59,390 --> 00:32:05,060
between the brackets the personal

00:32:01,850 --> 00:32:07,250
ratings work nice but typically this

00:32:05,060 --> 00:32:09,710
slope for example because it has to

00:32:07,250 --> 00:32:12,140
change to check the server to check all

00:32:09,710 --> 00:32:15,260
the verses that they can match and then

00:32:12,140 --> 00:32:17,060
a valid expression okay so in this in

00:32:15,260 --> 00:32:19,480
this talk I'm going to use version of

00:32:17,060 --> 00:32:19,480
arriving

00:32:19,820 --> 00:32:25,890
version of a ramen is something like

00:32:22,290 --> 00:32:27,990
this so when I'm developing my app okay

00:32:25,890 --> 00:32:31,050
so this is the column file for my app is

00:32:27,990 --> 00:32:33,540
the downstream final package of the of

00:32:31,050 --> 00:32:36,960
the dependency graph okay so I'm going

00:32:33,540 --> 00:32:40,050
to introduce another requirement to live

00:32:36,960 --> 00:32:43,110
a and I'm going to force that lee Bailey

00:32:40,050 --> 00:32:45,360
I want to depend on lib a vessel one all

00:32:43,110 --> 00:32:47,250
what that is the one that I want to test

00:32:45,360 --> 00:32:50,430
for my provide final application and

00:32:47,250 --> 00:32:55,590
then I'm in here an extra ward is all

00:32:50,430 --> 00:32:58,950
right why this this word here because if

00:32:55,590 --> 00:33:01,950
I don't add this override my dependency

00:32:58,950 --> 00:33:05,550
graph will change I will I will add an

00:33:01,950 --> 00:33:06,090
edge between my app node and my lip lip

00:33:05,550 --> 00:33:10,680
a node

00:33:06,090 --> 00:33:13,170
okay so so it can come out for example

00:33:10,680 --> 00:33:14,550
it can affect the order of by libraries

00:33:13,170 --> 00:33:16,230
you know when you link your your

00:33:14,550 --> 00:33:18,150
libraries have to be in order to

00:33:16,230 --> 00:33:19,740
properly link so if you are doing this

00:33:18,150 --> 00:33:21,840
kind of things you are changing your

00:33:19,740 --> 00:33:24,360
actually dependency graph and if you are

00:33:21,840 --> 00:33:26,250
doing some analysis to say why my app is

00:33:24,360 --> 00:33:28,380
it's actually depending on on a it is

00:33:26,250 --> 00:33:30,990
not depend on a it is dependent on C and

00:33:28,380 --> 00:33:33,240
D so I don't want this H in my

00:33:30,990 --> 00:33:35,100
information here it will it won't help

00:33:33,240 --> 00:33:38,070
me to refactor it will help me to to

00:33:35,100 --> 00:33:40,740
move so that's the reason we can specify

00:33:38,070 --> 00:33:43,980
overwrite and if I fell over right it

00:33:40,740 --> 00:33:46,110
will only change upstream okay this can

00:33:43,980 --> 00:33:48,480
also matter because coroner also saw

00:33:46,110 --> 00:33:50,220
conditional dependencies it would have

00:33:48,480 --> 00:33:52,260
dependencies that can change from

00:33:50,220 --> 00:33:54,660
operating system from operating system

00:33:52,260 --> 00:33:57,090
typical case electric files in Linux

00:33:54,660 --> 00:33:59,370
I didn't have it in Windows so you have

00:33:57,090 --> 00:34:01,920
packages that will depend on electric

00:33:59,370 --> 00:34:03,330
fence on Linux and nothing in Windows so

00:34:01,920 --> 00:34:05,700
that your dependency graph actually

00:34:03,330 --> 00:34:07,950
changes from configuration to

00:34:05,700 --> 00:34:10,700
configuration and in that case you

00:34:07,950 --> 00:34:14,790
definitely don't want to introduce a

00:34:10,700 --> 00:34:16,290
force requirement upstream because you

00:34:14,790 --> 00:34:18,240
are just trying to update on dependency

00:34:16,290 --> 00:34:20,250
so the override is okay if you are

00:34:18,240 --> 00:34:26,060
streaming you find dependencies to leave

00:34:20,250 --> 00:34:26,060
a use this one you sleep a 101

00:34:27,470 --> 00:34:43,159
so the override here yeah they were

00:34:41,159 --> 00:34:48,000
right works like this

00:34:43,159 --> 00:34:58,349
yes I sold you so I'm going to get my

00:34:48,000 --> 00:35:00,480
app and this is Conan install you can

00:34:58,349 --> 00:35:27,390
see here that now I am depending on

00:35:00,480 --> 00:35:29,460
lately very 100 won so now we can see

00:35:27,390 --> 00:35:32,880
that we are using the new message from

00:35:29,460 --> 00:35:36,030
Lee Bay so my whole dependency graph is

00:35:32,880 --> 00:35:38,160
working with this newly pay and I didn't

00:35:36,030 --> 00:35:39,960
I didn't have to rebuild any of the

00:35:38,160 --> 00:35:43,079
nodes I didn't have to rebuild be I

00:35:39,960 --> 00:35:45,180
didn't had to rebuild C or D okay so

00:35:43,079 --> 00:35:51,030
everything linked and everything will

00:35:45,180 --> 00:35:55,559
work but this might not be the case

00:35:51,030 --> 00:35:58,109
always for example something that we we

00:35:55,559 --> 00:36:02,460
do a lot let's do something more amazing

00:35:58,109 --> 00:36:04,770
and let's do optimization so I'm going

00:36:02,460 --> 00:36:09,650
for a new person and I'm going to in

00:36:04,770 --> 00:36:13,380
line the de message okay this is a

00:36:09,650 --> 00:36:21,650
biggest bigger change I'm going to bump

00:36:13,380 --> 00:36:26,339
my person to 1 2 to 0 let's do it

00:36:21,650 --> 00:36:31,220
first I'm going to create the package

00:36:26,339 --> 00:36:31,220
for 1 to 0

00:36:53,559 --> 00:37:03,049
okay let's check it the talus here

00:36:59,230 --> 00:37:06,079
good I have the three versions here so

00:37:03,049 --> 00:37:09,289
now I can I can go to my project I can

00:37:06,079 --> 00:37:13,940
override and I want to say okay I want

00:37:09,289 --> 00:37:33,529
to build with one toe to zero let's try

00:37:13,940 --> 00:37:37,789
it so something failed what is happening

00:37:33,529 --> 00:37:41,269
here so why did I I get this this link

00:37:37,789 --> 00:37:44,839
error and I actually I was very lucky

00:37:41,269 --> 00:37:46,549
that I got this error yeah you know you

00:37:44,839 --> 00:37:48,410
know it you know it otherwise the

00:37:46,549 --> 00:37:48,640
debugging the opposite that it happens a

00:37:48,410 --> 00:37:51,859
lot

00:37:48,640 --> 00:37:56,059
it's an idler so what is happening here

00:37:51,859 --> 00:37:59,150
I have three versions of lib a first two

00:37:56,059 --> 00:38:01,849
they have in the native code of the

00:37:59,150 --> 00:38:03,559
static library I have implementation for

00:38:01,849 --> 00:38:06,410
a different but there are three

00:38:03,559 --> 00:38:09,769
implantation for a okay if I go to the

00:38:06,410 --> 00:38:12,380
third version 1.2 I don't have an

00:38:09,769 --> 00:38:16,910
implementation for a because invitation

00:38:12,380 --> 00:38:20,119
for AC is in the header okay and then

00:38:16,910 --> 00:38:24,109
for my library be static library that I

00:38:20,119 --> 00:38:29,029
built it had a jump call to static

00:38:24,109 --> 00:38:32,809
library a so when I linked the my final

00:38:29,029 --> 00:38:35,089
application with a leap a 100 it links

00:38:32,809 --> 00:38:37,009
with it and it will call the my

00:38:35,089 --> 00:38:42,259
application will call the code from a

00:38:37,009 --> 00:38:45,950
leap a 100 and if I link with 101 it

00:38:42,259 --> 00:38:48,460
will call the the customer or one and

00:38:45,950 --> 00:38:50,210
everything works but if I try to link

00:38:48,460 --> 00:38:54,920
with the

00:38:50,210 --> 00:38:58,910
third person it will find the a code

00:38:54,920 --> 00:39:02,330
analytical file good so and why I say

00:38:58,910 --> 00:39:06,080
that we we are lucky because if we just

00:39:02,330 --> 00:39:09,859
did change in the code in the inline

00:39:06,080 --> 00:39:12,170
that header my code will link but it

00:39:09,859 --> 00:39:14,750
will run the old version of the code and

00:39:12,170 --> 00:39:19,250
then I will have to be back and know

00:39:14,750 --> 00:39:21,470
what having at runtime good luck so what

00:39:19,250 --> 00:39:24,830
do I need what do i I don't need this is

00:39:21,470 --> 00:39:28,730
this if I I want to to keep my e-library

00:39:24,830 --> 00:39:30,650
B and I don't want to bunt the version

00:39:28,730 --> 00:39:33,080
because I haven't changed the code for

00:39:30,650 --> 00:39:36,349
be the source code I need two batteries

00:39:33,080 --> 00:39:38,630
okay so I need a binary okay that will

00:39:36,349 --> 00:39:41,720
be able to link with the first two

00:39:38,630 --> 00:39:45,859
verses and it will it will contain a

00:39:41,720 --> 00:39:48,380
jump to the static library of a and then

00:39:45,859 --> 00:39:52,580
I need a different binary for library be

00:39:48,380 --> 00:39:56,630
that has the code in line it of the of

00:39:52,580 --> 00:40:02,810
the library a in line version so this

00:39:56,630 --> 00:40:06,310
okay how can i I managed to do this okay

00:40:02,810 --> 00:40:09,950
when I presented the the back tidy I

00:40:06,310 --> 00:40:14,150
immediately the the lot of thing so one

00:40:09,950 --> 00:40:16,280
thing that changes our binaries are our

00:40:14,150 --> 00:40:18,099
requirements is something that doesn't

00:40:16,280 --> 00:40:27,290
happen in any other programming language

00:40:18,099 --> 00:40:31,400
okay yeah so how do our dependencies

00:40:27,290 --> 00:40:33,859
affect our binaries we don't know so

00:40:31,400 --> 00:40:37,430
what we did in : what is doing is okay

00:40:33,859 --> 00:40:39,800
it's this win assembler by default okay

00:40:37,430 --> 00:40:43,040
so if you are bumping the major version

00:40:39,800 --> 00:40:46,540
you will need a new binary but it

00:40:43,040 --> 00:40:51,859
happens that it might not be good always

00:40:46,540 --> 00:40:54,020
so for that : allows to configure your

00:40:51,859 --> 00:40:56,780
your binaries the banners do you need

00:40:54,020 --> 00:40:59,570
the in this case for example I will spin

00:40:56,780 --> 00:41:03,140
with the settings we have here the

00:40:59,570 --> 00:41:04,170
default packet IV for settings and they

00:41:03,140 --> 00:41:07,290
both default behave

00:41:04,170 --> 00:41:09,900
is okay for every compiler version you

00:41:07,290 --> 00:41:12,570
will get a different binary okay so for

00:41:09,900 --> 00:41:14,850
GCC for eight you will get a binary for

00:41:12,570 --> 00:41:18,780
GCC for nine you will get a binary for

00:41:14,850 --> 00:41:21,270
cc to be you get a little minor okay and

00:41:18,780 --> 00:41:23,310
that's true the compilers even if they

00:41:21,270 --> 00:41:24,660
are compatible sometimes do get a

00:41:23,310 --> 00:41:26,070
different binary because probably they

00:41:24,660 --> 00:41:28,590
implement the some of TV's ASIS or

00:41:26,070 --> 00:41:31,620
whatever so the final value you get is

00:41:28,590 --> 00:41:34,890
different but what happens if I mean

00:41:31,620 --> 00:41:36,330
it's a real it's a real use case some

00:41:34,890 --> 00:41:41,100
people they are packed in a C library

00:41:36,330 --> 00:41:43,680
okay I say my my ABI would break I am

00:41:41,100 --> 00:41:45,960
fine I want to build my library with GCC

00:41:43,680 --> 00:41:48,870
for eight for example and I want to

00:41:45,960 --> 00:41:51,120
reuse that the binary for all my

00:41:48,870 --> 00:41:53,610
compiled versions and I want to do it I

00:41:51,120 --> 00:41:54,590
don't want ten 10 different miners I

00:41:53,610 --> 00:41:57,750
want one

00:41:54,590 --> 00:41:59,820
so in that case with a package ID you

00:41:57,750 --> 00:42:02,760
can do it you just overwrite the default

00:41:59,820 --> 00:42:04,440
behavior and you say okay so my the

00:42:02,760 --> 00:42:07,290
information that is going to affect my

00:42:04,440 --> 00:42:09,600
hat my package ID will be instead of

00:42:07,290 --> 00:42:13,290
using the version use this string use

00:42:09,600 --> 00:42:15,480
any so the what you will get here you

00:42:13,290 --> 00:42:18,210
will get okay so with this package AV

00:42:15,480 --> 00:42:19,440
you will get just one binary of course

00:42:18,210 --> 00:42:20,940
what my net for deciding if you're going

00:42:19,440 --> 00:42:23,580
to Windows Visual Studio you will get

00:42:20,940 --> 00:42:27,360
atom by atom binary but for this setup

00:42:23,580 --> 00:42:31,140
you will get just just one so the same

00:42:27,360 --> 00:42:33,900
can be applied for requirements the

00:42:31,140 --> 00:42:36,810
default behavior for violence is a

00:42:33,900 --> 00:42:40,400
cember so every time you change the

00:42:36,810 --> 00:42:44,190
module version you will get a new binary

00:42:40,400 --> 00:42:47,010
what happens that I came in super

00:42:44,190 --> 00:42:49,410
stressed we don't follow semantic

00:42:47,010 --> 00:42:53,240
versioning at all why because if we did

00:42:49,410 --> 00:42:56,070
we will have version number 3000 hundred

00:42:53,240 --> 00:42:58,350
then that would be the module and every

00:42:56,070 --> 00:43:01,980
time we break the the API I think level

00:42:58,350 --> 00:43:05,400
so we typically tend to bump our the

00:43:01,980 --> 00:43:08,070
module is typically our meaner in in C++

00:43:05,400 --> 00:43:11,040
so if we went okay so I want this

00:43:08,070 --> 00:43:13,350
behavior I want anytime my dependencies

00:43:11,040 --> 00:43:15,990
bomb the minor version I want a new

00:43:13,350 --> 00:43:17,910
binary it's just what we will so you can

00:43:15,990 --> 00:43:21,880
specify in your current

00:43:17,910 --> 00:43:24,940
display that with this syntax here this

00:43:21,880 --> 00:43:27,400
is just a helper you can you can define

00:43:24,940 --> 00:43:30,930
your own logic here if you want but what

00:43:27,400 --> 00:43:34,900
it means is this okay

00:43:30,930 --> 00:43:40,620
when it is evaluated if it is depending

00:43:34,900 --> 00:43:44,140
on leap a 100 or is depend on live a 101

00:43:40,620 --> 00:43:46,840
then the patch is this car so you get

00:43:44,140 --> 00:43:50,230
the same result you get lip a1 all set

00:43:46,840 --> 00:43:53,380
and these always passes to the same

00:43:50,230 --> 00:43:56,110
package a B so for both cases for those

00:43:53,380 --> 00:43:58,570
both minor versions you will get the

00:43:56,110 --> 00:44:01,240
same package ID that will be the package

00:43:58,570 --> 00:44:03,010
ID of the binary containing the jump

00:44:01,240 --> 00:44:06,430
that is able to link with a static

00:44:03,010 --> 00:44:10,780
library and in the other path here if

00:44:06,430 --> 00:44:14,800
you are requiring library a 1.2 it will

00:44:10,780 --> 00:44:19,210
be changed to Larry a 1.2 set and it

00:44:14,800 --> 00:44:21,820
will cache to a different package ID and

00:44:19,210 --> 00:44:24,520
this will be the package the package ID

00:44:21,820 --> 00:44:33,330
that has the implementation in line from

00:44:24,520 --> 00:44:33,330
the head ok so now let's try to to do it

00:44:38,100 --> 00:44:49,500
B I'm going to Libby I'm going to modify

00:44:46,120 --> 00:44:49,500
the my column file

00:44:58,420 --> 00:45:11,519
need commit and I'm going to fire Libby

00:45:21,400 --> 00:45:40,809
it is the comment of the recommit it

00:45:25,990 --> 00:45:44,230
will work so let me just so what I am

00:45:40,809 --> 00:45:48,099
doing here I'm just right now I am over

00:45:44,230 --> 00:45:50,410
writing I I introduced it a change I I

00:45:48,099 --> 00:45:51,990
submitted without bumping the version so

00:45:50,410 --> 00:45:57,390
I am rewriting my your whole batteries

00:45:51,990 --> 00:46:04,779
also can be done so now it is it is

00:45:57,390 --> 00:46:06,220
rebuilding my lip my lip B and I'm going

00:46:04,779 --> 00:46:19,630
to try to use it from from my

00:46:06,220 --> 00:46:24,190
application leave here yeah sorry I

00:46:19,630 --> 00:46:28,119
forgot to - oh no no is the override is

00:46:24,190 --> 00:46:33,519
already to one talk to zero so I'm going

00:46:28,119 --> 00:46:34,029
to install and now I got a different

00:46:33,519 --> 00:46:37,059
message

00:46:34,029 --> 00:46:39,190
okay is it still an error but but this I

00:46:37,059 --> 00:46:42,549
would enroll because now is telling me

00:46:39,190 --> 00:46:45,490
that you don't have a binary for Libby

00:46:42,549 --> 00:46:48,220
hey I just created a binary with the

00:46:45,490 --> 00:46:51,160
continuous integration why why I don't

00:46:48,220 --> 00:46:54,009
have a binary because now I'm trying to

00:46:51,160 --> 00:46:57,130
use a binary of B that will link with

00:46:54,009 --> 00:47:00,940
leap a one to zero so I need that binary

00:46:57,130 --> 00:47:03,460
no nobody built up that binary so what I

00:47:00,940 --> 00:47:06,390
can do here is I can do myself

00:47:03,460 --> 00:47:10,299
ok yes

00:47:06,390 --> 00:47:25,930
with the Dutton missing library buildup

00:47:10,299 --> 00:47:28,599
missing package okay and now it's

00:47:25,930 --> 00:47:31,089
working and the important thing here is

00:47:28,599 --> 00:47:35,589
that I haven't I haven't mess up with my

00:47:31,089 --> 00:47:47,619
batteries if I want to revert to my old

00:47:35,589 --> 00:47:49,930
101 I just do the override and it will

00:47:47,619 --> 00:47:52,930
work without revealing anything at all

00:47:49,930 --> 00:47:58,299
it will manage all the batteries and we

00:47:52,930 --> 00:48:05,709
can check in our cache that for library

00:47:58,299 --> 00:48:08,650
B we have this we have two batteries and

00:48:05,709 --> 00:48:13,449
you can check here we have a battery

00:48:08,650 --> 00:48:16,089
here that is requiring leap a 100 and I

00:48:13,449 --> 00:48:28,660
have a different battery for Lipe that

00:48:16,089 --> 00:48:31,869
is requiring library a one to zero so

00:48:28,660 --> 00:48:36,400
now I'm going this is the interesting

00:48:31,869 --> 00:48:40,420
part of regarding C and C++ it's almost

00:48:36,400 --> 00:48:43,329
on so here I wanted to just do two to do

00:48:40,420 --> 00:48:46,479
some proof that what can be done but

00:48:43,329 --> 00:48:48,579
this is mostly just a Jenkins okay so

00:48:46,479 --> 00:48:50,650
I'm going to do it quickly so I prefer

00:48:48,579 --> 00:48:54,160
to keep some some time for for questions

00:48:50,650 --> 00:48:56,410
okay so actually if we want to scale

00:48:54,160 --> 00:48:59,709
this to prints that instead of having

00:48:56,410 --> 00:49:02,619
five we have 50 or 100 dependencies I

00:48:59,709 --> 00:49:04,829
would like something like this okay I

00:49:02,619 --> 00:49:09,039
want to test my whole application

00:49:04,829 --> 00:49:12,400
rebuilding with library a12 okay but I

00:49:09,039 --> 00:49:13,869
don't want nodes like leap a leap for

00:49:12,400 --> 00:49:14,979
example that is not effect at all I

00:49:13,869 --> 00:49:17,709
don't want it to be launched I don't

00:49:14,979 --> 00:49:20,110
want to be computed okay I want to

00:49:17,709 --> 00:49:22,180
launch every single node in a

00:49:20,110 --> 00:49:24,670
Jenkins job so I can visualize all the

00:49:22,180 --> 00:49:29,590
other hierarchy going okay and I want to

00:49:24,670 --> 00:49:32,500
launch them in parallel okay so what can

00:49:29,590 --> 00:49:34,300
be done here Conan has a comment that is

00:49:32,500 --> 00:49:36,250
the current information call an info

00:49:34,300 --> 00:49:38,380
will get information for for the

00:49:36,250 --> 00:49:42,070
dependency graph in this case you can

00:49:38,380 --> 00:49:44,380
ask : what would be the build order you

00:49:42,070 --> 00:49:46,060
need to build such dependency graph so

00:49:44,380 --> 00:49:50,800
it will tell okay you have to start with

00:49:46,060 --> 00:49:54,850
a then you have to go to be their return

00:49:50,800 --> 00:49:56,950
actually is a list of lists why because

00:49:54,850 --> 00:49:59,380
at the Pennsy graph a Chris have

00:49:56,950 --> 00:50:02,740
directed graph so you can order it and

00:49:59,380 --> 00:50:04,720
you can order it by by levels all the

00:50:02,740 --> 00:50:07,300
nodes that are in the same level they

00:50:04,720 --> 00:50:08,950
can build they can be built in parallel

00:50:07,300 --> 00:50:12,130
because they are independent between

00:50:08,950 --> 00:50:13,960
each other okay so in this case the

00:50:12,130 --> 00:50:16,330
algorithm detects that C and D are not

00:50:13,960 --> 00:50:20,620
dependent in each other so they can be

00:50:16,330 --> 00:50:22,900
built in parallel so with this just

00:50:20,620 --> 00:50:24,970
build a continuous integration system is

00:50:22,900 --> 00:50:28,420
very simple it will just use a recipe

00:50:24,970 --> 00:50:30,580
with some some tricky mechanism to

00:50:28,420 --> 00:50:31,930
define the overrides I want and to

00:50:30,580 --> 00:50:34,900
propagate them to the to the whole

00:50:31,930 --> 00:50:39,430
system but basically is what you do so

00:50:34,900 --> 00:50:42,340
and we will be using a Jenkins job that

00:50:39,430 --> 00:50:45,280
would be firing all the other children

00:50:42,340 --> 00:50:50,290
or the children for every node of the of

00:50:45,280 --> 00:50:52,600
the of the graph so the script is like

00:50:50,290 --> 00:50:55,000
this don't think that is 200 lines or

00:50:52,600 --> 00:50:57,940
something like this but if you check is

00:50:55,000 --> 00:50:59,800
most of it is it's groovy comes from

00:50:57,940 --> 00:51:03,730
Java and thisis

00:50:59,800 --> 00:51:05,560
I mean it's verbose so but here what you

00:51:03,730 --> 00:51:08,560
have is you're just calling color in

00:51:05,560 --> 00:51:11,650
food to get the the bill order okay it

00:51:08,560 --> 00:51:13,600
is being saved to a JSON file the iPhone

00:51:11,650 --> 00:51:15,040
5 is being load is being parsed and you

00:51:13,600 --> 00:51:18,910
get a build order a survey as a variable

00:51:15,040 --> 00:51:21,910
and then it is just launching the child

00:51:18,910 --> 00:51:23,920
the children in parallel so you doing

00:51:21,910 --> 00:51:26,710
nothing but just launching things and

00:51:23,920 --> 00:51:28,840
the children is all about the same as we

00:51:26,710 --> 00:51:32,170
as we saw for a single package which is

00:51:28,840 --> 00:51:32,890
the initial step is a it's a bit more

00:51:32,170 --> 00:51:33,430
complicated

00:51:32,890 --> 00:51:35,559
just to

00:51:33,430 --> 00:51:37,630
find out an intermediate column file but

00:51:35,559 --> 00:51:43,119
they stole and the upload is basically

00:51:37,630 --> 00:51:45,579
say okay so I this talk in actually in

00:51:43,119 --> 00:51:47,589
the in the abstract I want to talk about

00:51:45,579 --> 00:51:49,839
other things for example I want to talk

00:51:47,589 --> 00:51:52,089
about beers requirements because another

00:51:49,839 --> 00:51:54,790
way to speed and to ease in our

00:51:52,089 --> 00:51:56,859
continuous integration is to to define

00:51:54,790 --> 00:51:58,990
for example our tools we could do things

00:51:56,859 --> 00:52:01,510
like this we can depend for example on

00:51:58,990 --> 00:52:04,059
catch testing framework and we can do it

00:52:01,510 --> 00:52:05,890
as a visa requirement that means that it

00:52:04,059 --> 00:52:08,319
will only be retrieved and it will be

00:52:05,890 --> 00:52:11,200
only be used if you are building a

00:52:08,319 --> 00:52:14,290
package from sources so if you already

00:52:11,200 --> 00:52:16,660
have the binary for this certain package

00:52:14,290 --> 00:52:19,960
catch will not be true trick at all and

00:52:16,660 --> 00:52:21,579
it will not be use this is interesting

00:52:19,960 --> 00:52:23,829
because it can be used not only for

00:52:21,579 --> 00:52:25,270
testing frameworks but also for tools so

00:52:23,829 --> 00:52:27,250
this is something that typically our

00:52:25,270 --> 00:52:30,460
users are doing imagine do you want to

00:52:27,250 --> 00:52:33,190
use lettuce to make 3:9 you have to

00:52:30,460 --> 00:52:35,140
object you can ask your IT to salsa

00:52:33,190 --> 00:52:38,440
making the servers then wait for two

00:52:35,140 --> 00:52:41,890
months or three you know what I'm

00:52:38,440 --> 00:52:44,670
talking about or you can just take Civic

00:52:41,890 --> 00:52:47,950
3:9 build a condom package with it

00:52:44,670 --> 00:52:50,410
upload see make three nine two your your

00:52:47,950 --> 00:52:53,230
remote server and then you can inject

00:52:50,410 --> 00:52:56,380
this video primer in your profile for

00:52:53,230 --> 00:52:58,150
example or in your recipes so then when

00:52:56,380 --> 00:53:00,880
you need to be from sources the package

00:52:58,150 --> 00:53:02,740
Simic three nine will be retrieved the

00:53:00,880 --> 00:53:05,260
path to see make will be injected in

00:53:02,740 --> 00:53:07,329
your in your recipe while it's building

00:53:05,260 --> 00:53:09,849
so it will use to make three nine from

00:53:07,329 --> 00:53:11,049
the column package sorry so the result

00:53:09,849 --> 00:53:12,730
is that you actually you can in a

00:53:11,049 --> 00:53:14,410
dependency graph you can actually build

00:53:12,730 --> 00:53:16,630
different notes with different civic if

00:53:14,410 --> 00:53:19,000
you want and this can be of course

00:53:16,630 --> 00:53:22,180
generalized for for compiler there are

00:53:19,000 --> 00:53:23,680
some example with mingw that's also in

00:53:22,180 --> 00:53:26,619
very interesting so if you want just to

00:53:23,680 --> 00:53:28,359
to build with GCC in Windows you'll have

00:53:26,619 --> 00:53:30,940
to stall it just create a column package

00:53:28,359 --> 00:53:33,700
for it and it will be it will be used so

00:53:30,940 --> 00:53:35,680
of course very useful for developers if

00:53:33,700 --> 00:53:38,319
you don't want to be stall things and

00:53:35,680 --> 00:53:40,750
you want to run against different GCC

00:53:38,319 --> 00:53:46,710
versions in Windows for example you can

00:53:40,750 --> 00:53:49,260
do that okay so a microcrystals here

00:53:46,710 --> 00:53:52,560
the first pass part is automating the

00:53:49,260 --> 00:53:54,600
cradle of packages is very simple just

00:53:52,560 --> 00:53:56,520
with 20 lines of a column file that is

00:53:54,600 --> 00:53:58,380
practically always the same and 20 lines

00:53:56,520 --> 00:54:01,080
of the Jenkins file that is always the

00:53:58,380 --> 00:54:04,700
same you can create packages when when

00:54:01,080 --> 00:54:07,530
users do get past mitigate push to your

00:54:04,700 --> 00:54:10,110
to your to your reps and it will work

00:54:07,530 --> 00:54:12,890
for multi-platform the packages will end

00:54:10,110 --> 00:54:16,470
in the server so this is kind of easy

00:54:12,890 --> 00:54:19,080
for the challenging task there are ways

00:54:16,470 --> 00:54:21,450
to do it so if we manatee if we defined

00:54:19,080 --> 00:54:24,180
correctly our vessel in approach if we

00:54:21,450 --> 00:54:27,000
define correctly our package ID and we

00:54:24,180 --> 00:54:29,880
define some ability in mechanism for for

00:54:27,000 --> 00:54:33,120
example dependency overwrite or virtual

00:54:29,880 --> 00:54:34,920
renews whatever we can make it work that

00:54:33,120 --> 00:54:37,140
it will be optimal in the sense that

00:54:34,920 --> 00:54:40,170
only those packages that really need to

00:54:37,140 --> 00:54:42,360
be the rebuild will be revealed the rest

00:54:40,170 --> 00:54:44,190
you can have a hierarchy of 50 packages

00:54:42,360 --> 00:54:46,710
only those that really need to be

00:54:44,190 --> 00:54:48,750
rebuilt for for compatibility and for

00:54:46,710 --> 00:54:50,250
using the right code that has to be used

00:54:48,750 --> 00:54:53,100
will be will be rebuilt

00:54:50,250 --> 00:54:54,960
okay and of course Genki suffers a

00:54:53,100 --> 00:54:56,640
polarization over the nodes that are

00:54:54,960 --> 00:55:00,600
independent of everything so this can be

00:54:56,640 --> 00:55:03,060
actually political fast and the only

00:55:00,600 --> 00:55:04,680
thing here is quite functionally this is

00:55:03,060 --> 00:55:09,720
a proof of concept which is quite quite

00:55:04,680 --> 00:55:11,670
future is some usability so I had to use

00:55:09,720 --> 00:55:13,050
a couple of tricks to actually propagate

00:55:11,670 --> 00:55:16,350
inferences about the overrides for

00:55:13,050 --> 00:55:19,500
example and so here I would love

00:55:16,350 --> 00:55:22,110
feedback so if anybody that is in column

00:55:19,500 --> 00:55:24,450
is a modernist integration please please

00:55:22,110 --> 00:55:26,280
submit issues we really something that

00:55:24,450 --> 00:55:28,320
we are working on and the more feedback

00:55:26,280 --> 00:55:32,100
we have the best for the for the expert

00:55:28,320 --> 00:55:34,910
source and finally I didn't want to

00:55:32,100 --> 00:55:39,150
finish without saying that we are hired

00:55:34,910 --> 00:55:42,330
so please send your CDs come to talk

00:55:39,150 --> 00:55:44,460
with us at our booth by the way we also

00:55:42,330 --> 00:55:46,290
have t-shirts we have these t-shirts in

00:55:44,460 --> 00:55:47,850
our booth so if you want one please

00:55:46,290 --> 00:55:53,430
please come to our booth and we will

00:55:47,850 --> 00:55:55,610
love to give you one yeah time time for

00:55:53,430 --> 00:56:04,360
questions

00:55:55,610 --> 00:56:09,470
[Applause]

00:56:04,360 --> 00:56:11,870
any question trust me to pick the seat

00:56:09,470 --> 00:56:13,160
furthest away from the microphone um so

00:56:11,870 --> 00:56:16,490
I have a quick question about the the

00:56:13,160 --> 00:56:18,080
semantic versioning aspect you mentioned

00:56:16,490 --> 00:56:20,270
that the default was to use semantic

00:56:18,080 --> 00:56:22,460
versioning yeah that seems extremely

00:56:20,270 --> 00:56:25,310
dangerous given how almost impossible it

00:56:22,460 --> 00:56:27,020
is in C++ to get it right

00:56:25,310 --> 00:56:28,400
given everything's you know that the

00:56:27,020 --> 00:56:31,250
propensity towards putting things in

00:56:28,400 --> 00:56:32,300
headers and the fact as you demonstrated

00:56:31,250 --> 00:56:33,470
that's the thing exactly the kind of

00:56:32,300 --> 00:56:35,420
thing you can get wrong so what was the

00:56:33,470 --> 00:56:36,530
motivation between picking semantic

00:56:35,420 --> 00:56:39,380
versioning as the default rather than

00:56:36,530 --> 00:56:44,120
making it the override yeah it was

00:56:39,380 --> 00:56:46,640
basically like being purist I mean

00:56:44,120 --> 00:56:49,610
semantic versioning says that we should

00:56:46,640 --> 00:56:52,040
do that and then we introduced it and

00:56:49,610 --> 00:56:53,870
when we realized that probably we should

00:56:52,040 --> 00:56:56,270
have gone for a more restrictive

00:56:53,870 --> 00:56:58,700
approach then there were thousands of

00:56:56,270 --> 00:57:01,910
packages up there with the binaries and

00:56:58,700 --> 00:57:03,860
if we the thing with that if we change

00:57:01,910 --> 00:57:05,270
the default that we are using for

00:57:03,860 --> 00:57:07,310
hashing and and computed in packets

00:57:05,270 --> 00:57:10,400
binaries then all the wineries that are

00:57:07,310 --> 00:57:13,340
uploaded to to the central server they

00:57:10,400 --> 00:57:15,050
will be they will be broke I mean you

00:57:13,340 --> 00:57:18,230
won't be able to find them because the

00:57:15,050 --> 00:57:20,840
package ID will change we are thinking

00:57:18,230 --> 00:57:24,140
probably for vessel ones here that we

00:57:20,840 --> 00:57:27,250
might be able to break more things we

00:57:24,140 --> 00:57:30,650
might consider doing a more restrictive

00:57:27,250 --> 00:57:32,090
virtual approach collapse strongly

00:57:30,650 --> 00:57:33,740
suggest doing that as cause nothing but

00:57:32,090 --> 00:57:36,680
the debugging of that problem is nearly

00:57:33,740 --> 00:57:38,120
impossible a second thing if while I

00:57:36,680 --> 00:57:39,110
would sorry to myself people behind me

00:57:38,120 --> 00:57:40,850
if you don't mind I'm gonna sleep one

00:57:39,110 --> 00:57:43,400
more in um a loot like that the

00:57:40,850 --> 00:57:46,550
depending package was - was the thing

00:57:43,400 --> 00:57:47,630
that determined what the version was you

00:57:46,550 --> 00:57:48,950
know what with whether it was using

00:57:47,630 --> 00:57:51,050
semantic versioning or not whereas it

00:57:48,950 --> 00:57:52,820
should be that the package itself that

00:57:51,050 --> 00:57:54,340
defines whether or people who depend on

00:57:52,820 --> 00:57:56,690
it should pick up on semantic versioning

00:57:54,340 --> 00:57:58,730
not really because the thing is for

00:57:56,690 --> 00:58:01,340
example if you're the fact that is

00:57:58,730 --> 00:58:03,260
depending okay it can say okay I'm going

00:58:01,340 --> 00:58:07,760
to build now I'm going to build us a

00:58:03,260 --> 00:58:09,770
solid library then I have to every

00:58:07,760 --> 00:58:11,680
single change in the version of my apps

00:58:09,770 --> 00:58:14,810
independencies is going to affect me or

00:58:11,680 --> 00:58:18,500
I can I can build a static library and

00:58:14,810 --> 00:58:21,380
now the mineral patches they won't

00:58:18,500 --> 00:58:22,580
affect me so exactly that only if you

00:58:21,380 --> 00:58:24,230
know how the blood library was

00:58:22,580 --> 00:58:25,520
implemented yourself because the library

00:58:24,230 --> 00:58:27,020
itself could knows whether it has things

00:58:25,520 --> 00:58:28,490
and headers that need to be in there I

00:58:27,020 --> 00:58:31,190
guess we should take this offline really

00:58:28,490 --> 00:58:34,670
I think I could probably talk there are

00:58:31,190 --> 00:58:38,870
two sites first is that the package that

00:58:34,670 --> 00:58:40,550
is we depend on is following some

00:58:38,870 --> 00:58:44,540
versioning approach that you understand

00:58:40,550 --> 00:58:47,210
and then the packet is using that

00:58:44,540 --> 00:58:50,450
package is the one to say okay I'm a

00:58:47,210 --> 00:58:53,120
header only library so by my upstream

00:58:50,450 --> 00:58:55,280
doesn't define how it's affecting me I I

00:58:53,120 --> 00:58:57,830
do it because I can for example boost I

00:58:55,280 --> 00:58:59,810
can just do a header only I will build

00:58:57,830 --> 00:59:02,800
up a packet for a header only boost or I

00:58:59,810 --> 00:59:05,990
will be I will be both for for study or

00:59:02,800 --> 00:59:08,050
dynamic the way I build boost is the way

00:59:05,990 --> 00:59:11,870
that that defines how my upstream

00:59:08,050 --> 00:59:12,980
affects me cool okay I may be both

00:59:11,870 --> 00:59:20,290
packages you be involved in that

00:59:12,980 --> 00:59:23,330
decision so so I have a question about

00:59:20,290 --> 00:59:25,300
your experience with this in terms of

00:59:23,330 --> 00:59:27,290
Hell like having code bases of scale so

00:59:25,300 --> 00:59:29,120
have you guys had any experience using

00:59:27,290 --> 00:59:30,710
this on a code base this like millions

00:59:29,120 --> 00:59:32,180
of lines of codes and like over 100

00:59:30,710 --> 00:59:37,130
packages that are like all highly

00:59:32,180 --> 00:59:40,070
changing all the time we directly note

00:59:37,130 --> 00:59:43,550
but our users yeah we have users that

00:59:40,070 --> 00:59:46,850
have more than hundreds of packages so

00:59:43,550 --> 00:59:48,310
the approaches I would say every

00:59:46,850 --> 00:59:51,740
approach of every company is different

00:59:48,310 --> 00:59:54,260
so some of them they will try approaches

00:59:51,740 --> 00:59:56,810
that will be very like living on the

00:59:54,260 --> 00:59:58,700
edge and all the packages they move all

00:59:56,810 --> 01:00:02,570
together so for example when you update

00:59:58,700 --> 01:00:04,880
a leap a and bam the version they will

01:00:02,570 --> 01:00:06,680
have a script that it will bunt the

01:00:04,880 --> 01:00:07,670
version of all the dependencies out

01:00:06,680 --> 01:00:08,810
stream for example they will move

01:00:07,670 --> 01:00:11,420
everything automatically

01:00:08,810 --> 01:00:13,670
for example orders they are doing it

01:00:11,420 --> 01:00:16,100
manually and they don't care the I mean

01:00:13,670 --> 01:00:18,170
if we are upgrading this it can take one

01:00:16,100 --> 01:00:21,530
month but we want to make sure that the

01:00:18,170 --> 01:00:23,010
Chaney's upstream are tested one by one

01:00:21,530 --> 01:00:25,470
down the hierarchy

01:00:23,010 --> 01:00:27,359
so I I could I know that it's been used

01:00:25,470 --> 01:00:29,820
actually what I said the virtual

01:00:27,359 --> 01:00:33,540
Rainey's approach is occurring this

01:00:29,820 --> 01:00:36,950
because some people are having like one

01:00:33,540 --> 01:00:40,619
of them was having like 70,000 artifacts

01:00:36,950 --> 01:00:43,619
there I say my personal radiance is slow

01:00:40,619 --> 01:00:45,540
yes you have to search the version that

01:00:43,619 --> 01:00:48,630
matches this for for several hundreds of

01:00:45,540 --> 01:00:50,850
packages so so this is a no limitation

01:00:48,630 --> 01:00:55,410
for example and that's why we develop a

01:00:50,850 --> 01:00:57,540
called an alias so so yes I could

01:00:55,410 --> 01:00:59,700
instruct like a general pattern for for

01:00:57,540 --> 01:01:03,020
large-scale projects because every

01:00:59,700 --> 01:01:03,020
everyone is doing something different

01:01:04,190 --> 01:01:11,490
okay one question about like the fact

01:01:08,070 --> 01:01:13,470
you use exactly strict version for your

01:01:11,490 --> 01:01:15,570
diplomacy like when you do require you

01:01:13,470 --> 01:01:17,420
specify exactly the Russian or not

01:01:15,570 --> 01:01:20,040
something like Russian superior to that

01:01:17,420 --> 01:01:21,660
like one problem is that because your

01:01:20,040 --> 01:01:24,000
system is very similar to Python

01:01:21,660 --> 01:01:25,590
packaging mechanism like beep it's

01:01:24,000 --> 01:01:27,690
generally when you start to a very big

01:01:25,590 --> 01:01:30,300
tree of dependency you get at least like

01:01:27,690 --> 01:01:32,010
one library which is used with two or

01:01:30,300 --> 01:01:36,380
three different version like oh do you

01:01:32,010 --> 01:01:39,660
under that so you are talking about

01:01:36,380 --> 01:01:41,369
conflict exactly like it in case of

01:01:39,660 --> 01:01:42,359
static every like you have it's a bit

01:01:41,369 --> 01:01:43,710
obvious because it's not going to

01:01:42,359 --> 01:01:46,609
compile in case you are using share

01:01:43,710 --> 01:01:50,570
memory you get really nasty side effect

01:01:46,609 --> 01:01:53,400
yeah yeah so I think with regarding that

01:01:50,570 --> 01:01:56,100
colin is following let's say quite a

01:01:53,400 --> 01:01:57,030
standard approach so it using it is

01:01:56,100 --> 01:01:59,550
using the typical

01:01:57,030 --> 01:02:01,740
conflict detection resolution actually

01:01:59,550 --> 01:02:02,970
not only version the thing is that you

01:02:01,740 --> 01:02:06,119
can have conflicts

01:02:02,970 --> 01:02:08,790
based on configuration so you can have a

01:02:06,119 --> 01:02:10,710
package that is being used a I want to

01:02:08,790 --> 01:02:13,440
link with this package statically and

01:02:10,710 --> 01:02:17,130
then on the other side of the diamond I

01:02:13,440 --> 01:02:19,170
want to link with this dynamically so

01:02:17,130 --> 01:02:21,740
what so that's a conflict and it has to

01:02:19,170 --> 01:02:24,119
be resolved so what column does is okay

01:02:21,740 --> 01:02:26,670
one previous of course it doesn't try to

01:02:24,119 --> 01:02:29,359
do very a lot of magic so if it detects

01:02:26,670 --> 01:02:32,580
a conflict either of versioning of

01:02:29,359 --> 01:02:35,609
configuration is going to tell the user

01:02:32,580 --> 01:02:37,260
and the user downstream is the one to

01:02:35,609 --> 01:02:39,960
say okay so I have accomplished

01:02:37,260 --> 01:02:41,790
here I want to use person and doing an

01:02:39,960 --> 01:02:44,640
override the override typically is a

01:02:41,790 --> 01:02:46,020
mechanism for resolving conflicts so the

01:02:44,640 --> 01:02:47,910
same of read you can do that there you

01:02:46,020 --> 01:02:50,550
can do for opt-ins also and you can

01:02:47,910 --> 01:02:53,070
force downstream okay do you wanna

01:02:50,550 --> 01:02:54,990
static you want dynamic I tell my

01:02:53,070 --> 01:02:57,600
dependency graph that you are going to

01:02:54,990 --> 01:03:00,060
you are going to use dynamic there is

01:02:57,600 --> 01:03:02,970
also a different kind of dependencies in

01:03:00,060 --> 01:03:05,040
current that are private so you can use

01:03:02,970 --> 01:03:07,020
private dependencies and so you can

01:03:05,040 --> 01:03:09,000
actually depend on different versions in

01:03:07,020 --> 01:03:11,160
the similar fantasy graph but it will be

01:03:09,000 --> 01:03:14,600
different notes you really want to make

01:03:11,160 --> 01:03:17,790
sure that the API want one across

01:03:14,600 --> 01:03:20,700
frontiers here and you want serve

01:03:17,790 --> 01:03:22,800
objects of those libraries is typically

01:03:20,700 --> 01:03:25,290
something you don't want to do but so

01:03:22,800 --> 01:03:26,940
many users they really need to link with

01:03:25,290 --> 01:03:28,560
the same library to different person in

01:03:26,940 --> 01:03:31,230
the same dependency graph so it's

01:03:28,560 --> 01:03:33,450
something that can be done lots of girls

01:03:31,230 --> 01:03:35,250
who could be recommended for the general

01:03:33,450 --> 01:03:41,850
case okay thank you

01:03:35,250 --> 01:03:44,370
thank you so we have a mixture of Sigma

01:03:41,850 --> 01:03:46,820
plus and Java code and our code base we

01:03:44,370 --> 01:03:50,430
use maven for building the Java is there

01:03:46,820 --> 01:03:53,250
integration with but between the sort of

01:03:50,430 --> 01:03:56,280
the maven artifacts and the Coenen artex

01:03:53,250 --> 01:04:00,900
okay so there is no integration with

01:03:56,280 --> 01:04:03,120
with Mabon okay but Colin as you have

01:04:00,900 --> 01:04:05,580
seen their recipes they are just very

01:04:03,120 --> 01:04:08,100
general so we have proof of concept

01:04:05,580 --> 01:04:10,020
working for Python packaging also for

01:04:08,100 --> 01:04:12,930
goal-line packaging there are also

01:04:10,020 --> 01:04:15,420
generator for rust so from Colin

01:04:12,930 --> 01:04:18,660
packages you can just generate all the

01:04:15,420 --> 01:04:22,560
information of certain dependencies that

01:04:18,660 --> 01:04:24,540
will be used from rust to link with with

01:04:22,560 --> 01:04:29,130
the artifacts that we do just creative

01:04:24,540 --> 01:04:30,930
and with Colin so I guess for maven you

01:04:29,130 --> 01:04:32,670
can do that you it's possible to write a

01:04:30,930 --> 01:04:34,890
generator that will output the

01:04:32,670 --> 01:04:36,330
information all the off to the pacific

01:04:34,890 --> 01:04:39,750
graph everything that that maybe needs

01:04:36,330 --> 01:04:41,340
in miriam format it can be within one

01:04:39,750 --> 01:04:44,660
day for example well such a generator

01:04:41,340 --> 01:04:44,660
okay cool thanks

01:04:45,039 --> 01:04:51,220
hey go I noticed that in your first

01:04:49,160 --> 01:04:53,450
example when you override the version

01:04:51,220 --> 01:04:55,309
couldn't just a file instead of

01:04:53,450 --> 01:04:58,309
recompiling doesn't mean that the

01:04:55,309 --> 01:05:00,079
default policy is not to check the

01:04:58,309 --> 01:05:04,640
version and recompile the dependencies

01:05:00,079 --> 01:05:07,160
the graph changes when I did the first

01:05:04,640 --> 01:05:08,809
one but right you mean yeah yeah the

01:05:07,160 --> 01:05:11,749
first override was that was my lower

01:05:08,809 --> 01:05:15,200
back was a patch now and the default is

01:05:11,749 --> 01:05:18,319
to do not recombine right the default is

01:05:15,200 --> 01:05:19,460
cember so cember if you're just mapping

01:05:18,319 --> 01:05:21,559
the patches

01:05:19,460 --> 01:05:24,700
samer will tell you that you don't need

01:05:21,559 --> 01:05:28,160
to reveal yeah yeah yeah groove not ok

01:05:24,700 --> 01:05:30,319
just to add to maybe a bit of response

01:05:28,160 --> 01:05:31,730
to what Matt said just before we

01:05:30,319 --> 01:05:34,910
assemble and the problems of a

01:05:31,730 --> 01:05:37,489
versioning I actually I'm doing a talk

01:05:34,910 --> 01:05:39,499
on Wednesday morning about versioning in

01:05:37,489 --> 01:05:41,269
support plus I will be very glad if you

01:05:39,499 --> 01:05:42,920
come and you can give me your feedback

01:05:41,269 --> 01:05:50,720
if I can't give you answers I would be

01:05:42,920 --> 01:05:52,970
very happy looking at the C make use

01:05:50,720 --> 01:05:54,589
cases that it seems that this juke hang

01:05:52,970 --> 01:05:56,839
a lot of information that would already

01:05:54,589 --> 01:05:59,420
be available through C makes install

01:05:56,839 --> 01:06:00,920
process or the C make modules that get

01:05:59,420 --> 01:06:03,890
generated when you install the library

01:06:00,920 --> 01:06:05,390
is there any way to have Koenen extract

01:06:03,890 --> 01:06:08,119
that information I then repeat it in the

01:06:05,390 --> 01:06:10,130
Konan fold up hi

01:06:08,119 --> 01:06:13,700
things like sorry I should clarify

01:06:10,130 --> 01:06:18,259
things like required compiler flags for

01:06:13,700 --> 01:06:21,019
example no I mean column is very or

01:06:18,259 --> 01:06:24,019
taller to a build system so it's kind of

01:06:21,019 --> 01:06:26,450
transparent so you have to translate all

01:06:24,019 --> 01:06:29,420
the way down to C make and also certain

01:06:26,450 --> 01:06:32,390
for C make of course you can do many

01:06:29,420 --> 01:06:35,269
things for example a typical use case

01:06:32,390 --> 01:06:38,259
would be in C make you have the install

01:06:35,269 --> 01:06:40,999
for example utilities so instead of

01:06:38,259 --> 01:06:43,670
building of defining your your package

01:06:40,999 --> 01:06:45,829
method in the column file recipe you

01:06:43,670 --> 01:06:48,319
just call C make install for example and

01:06:45,829 --> 01:06:51,289
so we we have the parameters like the

01:06:48,319 --> 01:06:53,420
package folder and you will say okay C

01:06:51,289 --> 01:06:56,059
make a C make is told prefix

01:06:53,420 --> 01:06:57,380
package folder so it will it will run

01:06:56,059 --> 01:06:59,210
the install

01:06:57,380 --> 01:07:01,580
to the packet folder and so you can

01:06:59,210 --> 01:07:03,340
reuse the functionality so it basically

01:07:01,580 --> 01:07:06,290
is have to use it's nothing

01:07:03,340 --> 01:07:08,600
transparent or or magic in the way that

01:07:06,290 --> 01:07:11,450
that we are integrated with CMake just

01:07:08,600 --> 01:07:14,630
you go Simic to create packages you can

01:07:11,450 --> 01:07:17,750
pass see make any flag do you want but

01:07:14,630 --> 01:07:21,770
your see make script it has to be

01:07:17,750 --> 01:07:23,150
prepared to use those flags you know so

01:07:21,770 --> 01:07:25,640
I mean the other way around so if you'll

01:07:23,150 --> 01:07:27,980
see my if your library is defining Flags

01:07:25,640 --> 01:07:30,290
you need yeah you know the unstrained

01:07:27,980 --> 01:07:32,390
the typical ones seem I could be install

01:07:30,290 --> 01:07:35,350
generates a module file yeah so

01:07:32,390 --> 01:07:38,720
basically imagine that your teammate is

01:07:35,350 --> 01:07:42,110
required some personal directives or

01:07:38,720 --> 01:07:44,600
something you have right now you have to

01:07:42,110 --> 01:07:47,480
add them manually in your packet

01:07:44,600 --> 01:07:48,920
information so for your consumers : will

01:07:47,480 --> 01:07:51,020
not detect the configuration from

01:07:48,920 --> 01:07:52,700
teammate you have to explicitly define

01:07:51,020 --> 01:07:55,100
for your consumers their configuration

01:07:52,700 --> 01:07:56,780
in the packet info method so in that way

01:07:55,100 --> 01:08:00,650
you will have some repetition but there

01:07:56,780 --> 01:08:01,220
is no way that you can do this like very

01:08:00,650 --> 01:08:02,600
smartly

01:08:01,220 --> 01:08:04,850
I mean extracting information for

01:08:02,600 --> 01:08:07,130
teammate is not something that it can be

01:08:04,850 --> 01:08:09,890
done automatically in any case it takes

01:08:07,130 --> 01:08:12,440
you like two minutes to do it if you

01:08:09,890 --> 01:08:15,100
know your build system within a packet

01:08:12,440 --> 01:08:19,480
recipe it's quite simple

01:08:15,100 --> 01:08:22,350
thank you okay thank you anyone else

01:08:19,480 --> 01:08:29,109
No so thanks very much for coming

01:08:22,350 --> 01:08:29,109

YouTube URL: https://www.youtube.com/watch?v=xA9yRX4Mdz0


