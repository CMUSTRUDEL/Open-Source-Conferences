Title: CppCon 2017: James McNellis “Everything You Ever Wanted to Know about DLLs”
Publication date: 2017-10-12
Playlist: CppCon 2017
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
If you build software for Windows, you use DLLs, and it’s likely that you may build DLLs of your own. DLLs are the primary mechanism for packaging and encapsulating code on the Windows platform. But have you ever stopped to think about how DLLs work? What goes into a DLL when you build it, what happens when you link your program with a DLL, or how do DLLs get located and loaded at runtime? Many of us build and use DLLs without fully understanding them. In this session, we’ll give an in-depth introduction to DLLs and how they work. 

We’ll begin by looking at what’s in a DLL—the kinds of things a DLL can contain and the basic data structures that are used—and the benefits and drawbacks of packaging code in a DLL. We’ll look at how DLLs are loaded, including the details of how the loader locates DLLs and maps them into the process; how dependencies are resolved among DLLs; and DLL lifetime and how DLLs get unloaded. We’ll also look at how DLLs get built, including what makes DLLs “special,” what goes into an import library, and how the linker uses import libraries. Finally, we’ll look at several other miscellaneous topics, including how DLLs interact with threads and thread-local storage, and mechanisms for solving or mitigating the dreaded “DLL hell.” 
— 
James McNellis: Microsoft, Senior Software Engineer

James is a senior engineer on the Windows Debugger team at Microsoft, where he works on the Time Travel Debugging (TTD) reverse debugging toolkit. Prior to joining the Debuggers team in 2016, he was a member of the Visual C++ team, where he was responsible for the Microsoft C Runtime (CRT) and C Standard Library implementation. Passionate about all things related to C++, he is a frequent speaker at C++ conferences around the world and is a former top contributor on StackOverflow. He can be found on Twitter at @JamesMcNellis.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:02,760
so good morning everyone before I

00:00:01,829 --> 00:00:04,230
started I just wanted to make sure

00:00:02,760 --> 00:00:06,720
you're all aware that this is a talk

00:00:04,230 --> 00:00:08,189
about dll's right like there's people

00:00:06,720 --> 00:00:09,780
all over the conference talking about

00:00:08,189 --> 00:00:13,469
very interesting things right now but

00:00:09,780 --> 00:00:15,150
we're going to talk about dll's all

00:00:13,469 --> 00:00:16,859
right just I want to give you the

00:00:15,150 --> 00:00:20,100
opportunity to you know leave if you

00:00:16,859 --> 00:00:21,510
want to so actually the talk is titled

00:00:20,100 --> 00:00:24,539
everything you ever wanted to know about

00:00:21,510 --> 00:00:25,890
dll's but I need to amend that a little

00:00:24,539 --> 00:00:27,510
bit so it's actually going to be a few

00:00:25,890 --> 00:00:30,150
things you probably didn't want to know

00:00:27,510 --> 00:00:31,289
about dll's if I was to cover everything

00:00:30,150 --> 00:00:32,489
there is to know about them it would

00:00:31,289 --> 00:00:35,010
take me a whole conference worth of

00:00:32,489 --> 00:00:36,930
sessions so this is going to be sort of

00:00:35,010 --> 00:00:38,460
an introduction to how dll's work we're

00:00:36,930 --> 00:00:41,180
gonna touch on a lot of things we're not

00:00:38,460 --> 00:00:43,440
going into a ton of detail in the talk

00:00:41,180 --> 00:00:45,270
so my name is James McNellis I'm a

00:00:43,440 --> 00:00:47,640
senior engineer on the windows debuggers

00:00:45,270 --> 00:00:48,899
team so I work on windbg you may have

00:00:47,640 --> 00:00:51,120
been at our talk yesterday we announced

00:00:48,899 --> 00:00:53,370
and released some brand-new time travel

00:00:51,120 --> 00:00:54,660
or reverse debugging tools for Windows

00:00:53,370 --> 00:00:57,180
which are very exciting you should go

00:00:54,660 --> 00:00:58,680
check them out most importantly on this

00:00:57,180 --> 00:01:00,239
slide you can see my twitter handle you

00:00:58,680 --> 00:01:03,090
should all go and follow me that has

00:01:00,239 --> 00:01:04,830
also be great so I've got a lot of

00:01:03,090 --> 00:01:06,390
things that I'd like to talk about here

00:01:04,830 --> 00:01:08,250
some of the things that toward the end

00:01:06,390 --> 00:01:08,729
we may cut depending on time we'll have

00:01:08,250 --> 00:01:10,260
to see

00:01:08,729 --> 00:01:12,659
so we're gonna start by looking at how

00:01:10,260 --> 00:01:15,270
you build a dll how to use a DLL in a

00:01:12,659 --> 00:01:17,130
program look at what's inside of a DLL

00:01:15,270 --> 00:01:19,229
we'll look at explicit and implicit

00:01:17,130 --> 00:01:21,229
linking what happens when you load a DLL

00:01:19,229 --> 00:01:23,729
how to diagnose DLL load failures

00:01:21,229 --> 00:01:25,619
various ways to specify what a DLL

00:01:23,729 --> 00:01:28,020
exports will look at data exports delay

00:01:25,619 --> 00:01:29,520
loading C++ threads and then DLL hell

00:01:28,020 --> 00:01:33,210
and then maybe there will be time for

00:01:29,520 --> 00:01:34,380
questions so what we're not going to

00:01:33,210 --> 00:01:36,150
talk about we're not going to talk about

00:01:34,380 --> 00:01:37,829
dynamic libraries or shared objects on

00:01:36,150 --> 00:01:39,600
other platforms so obviously many other

00:01:37,829 --> 00:01:41,880
platforms have shared libraries of

00:01:39,600 --> 00:01:43,320
various forms I've been programming on

00:01:41,880 --> 00:01:45,149
Windows for a long time now so I don't

00:01:43,320 --> 00:01:47,399
have that familiarity that I need to

00:01:45,149 --> 00:01:49,049
give a talk on that and also I only have

00:01:47,399 --> 00:01:51,030
an hour so I have to constrain what I'm

00:01:49,049 --> 00:01:52,290
going to talk about this is cpp so

00:01:51,030 --> 00:01:53,759
we're not going to talk about dotnet

00:01:52,290 --> 00:01:55,229
we're gonna talk about native you know

00:01:53,759 --> 00:01:57,479
dll's that have native code in them

00:01:55,229 --> 00:01:59,850
we're not gonna focus on any other kinds

00:01:57,479 --> 00:02:03,240
of dll's or uses of dll's like resource

00:01:59,850 --> 00:02:04,560
dll's as well and so we'll mention a lot

00:02:03,240 --> 00:02:05,909
of things that we won't discuss in depth

00:02:04,560 --> 00:02:07,110
but I've tried to put enough information

00:02:05,909 --> 00:02:08,520
on the slides that if you search for

00:02:07,110 --> 00:02:10,770
things you'll be able to find them quite

00:02:08,520 --> 00:02:13,370
easily using Bing or if you prefer

00:02:10,770 --> 00:02:13,370
Google

00:02:13,410 --> 00:02:17,460
so what and why so a dll is a dynamic

00:02:16,200 --> 00:02:19,260
link library that's what those letters

00:02:17,460 --> 00:02:20,880
stand for so it's a library that

00:02:19,260 --> 00:02:23,640
contains code and data just like a

00:02:20,880 --> 00:02:25,410
static library but it can be it can be

00:02:23,640 --> 00:02:26,700
loaded dynamically at runtime so you

00:02:25,410 --> 00:02:28,500
don't actually have to link it into your

00:02:26,700 --> 00:02:30,120
program when you start you know when you

00:02:28,500 --> 00:02:31,670
actually build it you can choose whether

00:02:30,120 --> 00:02:33,930
or not to load it at runtime

00:02:31,670 --> 00:02:36,240
additionally it can be shared or reused

00:02:33,930 --> 00:02:37,560
between multiple programs so a static

00:02:36,240 --> 00:02:39,150
library can also be shared between

00:02:37,560 --> 00:02:41,790
multiple programs because you could link

00:02:39,150 --> 00:02:43,170
it into for example 20 programs but then

00:02:41,790 --> 00:02:45,750
if you distribute those programs well

00:02:43,170 --> 00:02:47,220
you have 20 copies of that code or data

00:02:45,750 --> 00:02:50,100
or whatever you've linked from that on

00:02:47,220 --> 00:02:52,230
disk so dll's you only need to have one

00:02:50,100 --> 00:02:55,590
copy of it you don't need to have

00:02:52,230 --> 00:02:57,120
multiple copies so most normal dll's

00:02:55,590 --> 00:02:58,290
have a dll file extension you don't

00:02:57,120 --> 00:02:59,640
actually have to have a DLL file

00:02:58,290 --> 00:03:01,740
extension it could be a dot txt

00:02:59,640 --> 00:03:05,010
extension it will work just as well well

00:03:01,740 --> 00:03:07,260
some things will work just as well so

00:03:05,010 --> 00:03:08,400
why use dll's so the biggest advantage

00:03:07,260 --> 00:03:10,410
that I already touched on is multiple

00:03:08,400 --> 00:03:12,030
programs can share code and data without

00:03:10,410 --> 00:03:13,560
each programming having its own copy so

00:03:12,030 --> 00:03:15,390
this can reduce disk space usage because

00:03:13,560 --> 00:03:16,920
your X's are smaller you have this code

00:03:15,390 --> 00:03:18,480
that's actually shared you can also

00:03:16,920 --> 00:03:19,770
reduce memory usage because if you have

00:03:18,480 --> 00:03:22,170
dll's that are loaded into many

00:03:19,770 --> 00:03:24,180
different processes all of the read-only

00:03:22,170 --> 00:03:25,860
pages of those dll's can generally be

00:03:24,180 --> 00:03:27,600
shared between the multiple processes

00:03:25,860 --> 00:03:29,370
you can reduce overall memory usage

00:03:27,600 --> 00:03:31,350
across the system even if you're not

00:03:29,370 --> 00:03:32,880
even if you may be increasing slightly

00:03:31,350 --> 00:03:34,920
your own virtual address space usage

00:03:32,880 --> 00:03:36,000
within a process you can defer a

00:03:34,920 --> 00:03:37,650
decision of whether to load

00:03:36,000 --> 00:03:38,910
functionality until runtime so perhaps

00:03:37,650 --> 00:03:40,800
you may not always need some

00:03:38,910 --> 00:03:42,000
functionality like for example if you

00:03:40,800 --> 00:03:43,440
write a print driver you don't want to

00:03:42,000 --> 00:03:45,209
load your print driver and every single

00:03:43,440 --> 00:03:46,920
process regardless of whether you know

00:03:45,209 --> 00:03:48,300
it's printing or not you want to load it

00:03:46,920 --> 00:03:50,490
you know when you actually need to go in

00:03:48,300 --> 00:03:52,250
print or perhaps you know you want to

00:03:50,490 --> 00:03:54,750
support other kinds of open extended

00:03:52,250 --> 00:03:57,150
open-ended extensibility like plugins

00:03:54,750 --> 00:03:59,280
there's also maintainability benefits so

00:03:57,150 --> 00:04:01,200
componentization you know is enabled by

00:03:59,280 --> 00:04:02,820
dll's you know if you only work on one

00:04:01,200 --> 00:04:04,410
little part of your project you can keep

00:04:02,820 --> 00:04:05,550
rebuilding just your one dll you don't

00:04:04,410 --> 00:04:06,959
have to rebuild the entire thing

00:04:05,550 --> 00:04:09,600
necessarily it can improve

00:04:06,959 --> 00:04:10,920
serviceability because you know if let's

00:04:09,600 --> 00:04:13,050
say there's a critical security bug in

00:04:10,920 --> 00:04:14,040
some of your code if it's in a static

00:04:13,050 --> 00:04:15,780
library you actually have to go and

00:04:14,040 --> 00:04:17,520
rebuild every single thing that's linked

00:04:15,780 --> 00:04:19,380
that bug into that into the program

00:04:17,520 --> 00:04:21,180
whereas with a dll you can just rebuild

00:04:19,380 --> 00:04:23,400
the dll redistribute it and everyone

00:04:21,180 --> 00:04:24,419
picks up the fixes and then finally

00:04:23,400 --> 00:04:26,970
there's some improvement a nobility

00:04:24,419 --> 00:04:27,230
basically for the same reason let's also

00:04:26,970 --> 00:04:28,820
do

00:04:27,230 --> 00:04:30,350
advantages so it certainly makes

00:04:28,820 --> 00:04:31,490
software distribution more complicated

00:04:30,350 --> 00:04:32,990
right if you build everything into a

00:04:31,490 --> 00:04:34,600
single XE well you can just give that to

00:04:32,990 --> 00:04:37,100
people and run it and it works happily

00:04:34,600 --> 00:04:38,510
but you know with dll's there's multiple

00:04:37,100 --> 00:04:39,770
files maybe you have to install some of

00:04:38,510 --> 00:04:42,290
them differently so it can be a bit more

00:04:39,770 --> 00:04:43,760
complex has increased potential for

00:04:42,290 --> 00:04:45,680
incompatibilities I'm sure many people

00:04:43,760 --> 00:04:49,130
here have had to deal with DLL hell or

00:04:45,680 --> 00:04:50,630
you know DLL hell like issues and then

00:04:49,130 --> 00:04:52,430
it's you know a small thing it's

00:04:50,630 --> 00:04:54,140
impossible to optimize code across DLL

00:04:52,430 --> 00:04:56,030
boundaries or at least with today's

00:04:54,140 --> 00:04:57,740
tooling so you know if you statically

00:04:56,030 --> 00:04:59,360
link code Ian you can actually do whole

00:04:57,740 --> 00:05:01,550
program optimization link time code

00:04:59,360 --> 00:05:03,740
generation to optimize across different

00:05:01,550 --> 00:05:05,150
source files but with dll's like there's

00:05:03,740 --> 00:05:08,720
actually a hard boundary you know every

00:05:05,150 --> 00:05:10,370
call into a DLL is an indirect call so

00:05:08,720 --> 00:05:11,960
end up talking let's let's build a

00:05:10,370 --> 00:05:16,580
little DLL so I'm gonna build a DLL

00:05:11,960 --> 00:05:18,440
named hello DLL we're just basically all

00:05:16,580 --> 00:05:19,880
of my slides I'm going actually we're

00:05:18,440 --> 00:05:21,250
just gonna use the command line I'm

00:05:19,880 --> 00:05:23,630
going to have all the commands you need

00:05:21,250 --> 00:05:25,550
most of the command output will be shown

00:05:23,630 --> 00:05:27,050
sometimes I've trimmed things down just

00:05:25,550 --> 00:05:28,490
to fit them on the slides to focus on

00:05:27,050 --> 00:05:29,240
you know individual things but you

00:05:28,490 --> 00:05:30,860
should be able to take all these

00:05:29,240 --> 00:05:32,390
commands all the sample code and just

00:05:30,860 --> 00:05:34,400
copy and paste it and do the same thing

00:05:32,390 --> 00:05:36,680
we're going to use the visual C++

00:05:34,400 --> 00:05:38,510
toolset but you could use mingw you can

00:05:36,680 --> 00:05:39,860
use clang on windows they'll do the same

00:05:38,510 --> 00:05:41,990
thing it's just you know a different

00:05:39,860 --> 00:05:43,700
tool set so we'll start by looking at

00:05:41,990 --> 00:05:45,620
this hello dot cpp that we're going to

00:05:43,700 --> 00:05:47,270
use to build a DLL now I know you're

00:05:45,620 --> 00:05:50,270
here at CPP con you're excited for

00:05:47,270 --> 00:05:52,370
awesome advanced C++ this is not going

00:05:50,270 --> 00:05:53,540
to be it this is about as advanced as

00:05:52,370 --> 00:05:55,460
the code that we're going to be showing

00:05:53,540 --> 00:05:58,130
in this talk because we're focusing on

00:05:55,460 --> 00:06:00,110
the DLL mechanism not with C++ code so

00:05:58,130 --> 00:06:02,240
here this is just a very simple function

00:06:00,110 --> 00:06:03,860
called get greeting it returns a string

00:06:02,240 --> 00:06:05,540
a pointer to a string

00:06:03,860 --> 00:06:07,430
the only non-standard thing we've had to

00:06:05,540 --> 00:06:08,720
do here is it has the CD echo calling

00:06:07,430 --> 00:06:10,280
convention and the reason is is that

00:06:08,720 --> 00:06:11,660
when you're talking across the DLL

00:06:10,280 --> 00:06:12,800
boundary you want to make sure that

00:06:11,660 --> 00:06:14,030
everyone agrees on the calling

00:06:12,800 --> 00:06:15,410
convention since there's more than one

00:06:14,030 --> 00:06:17,570
otherwise you'll end up corrupting your

00:06:15,410 --> 00:06:19,430
stack or you know breaking something so

00:06:17,570 --> 00:06:21,410
all of our exports will be explicitly C

00:06:19,430 --> 00:06:22,910
deckle you can pick a calling convention

00:06:21,410 --> 00:06:25,160
just as long as you use the same one on

00:06:22,910 --> 00:06:26,990
both sides so we're going to take this

00:06:25,160 --> 00:06:30,380
we're going to compile it so CL slash C

00:06:26,990 --> 00:06:33,020
compiles it it does not link it and so

00:06:30,380 --> 00:06:34,280
that will produce hello obj most of the

00:06:33,020 --> 00:06:35,750
future slides I'm going to skip the

00:06:34,280 --> 00:06:38,210
compilation step because it's always the

00:06:35,750 --> 00:06:39,470
same as nothing special you know about

00:06:38,210 --> 00:06:40,590
that and we're just going to show the

00:06:39,470 --> 00:06:41,880
linking step so here

00:06:40,590 --> 00:06:45,120
is where we're going to produce the DLL

00:06:41,880 --> 00:06:46,890
so we take the hello obj file we passed

00:06:45,120 --> 00:06:48,420
the DLL option to the linker which tells

00:06:46,890 --> 00:06:51,000
it don't build an XE which is the

00:06:48,420 --> 00:06:52,380
default build a DLL we say no entry the

00:06:51,000 --> 00:06:53,940
only important thing right now is that

00:06:52,380 --> 00:06:55,290
basically reduces the amount of stuff

00:06:53,940 --> 00:06:57,570
that gets put into the DLL which makes

00:06:55,290 --> 00:06:59,730
this example a lot simpler and then we

00:06:57,570 --> 00:07:01,020
use slash export to tell it get greeting

00:06:59,730 --> 00:07:02,820
is part of the public interface of this

00:07:01,020 --> 00:07:05,130
DLL so get greeting is one of the things

00:07:02,820 --> 00:07:07,860
that you can actually use from outside

00:07:05,130 --> 00:07:09,810
of the DLL and so if we run that it'll

00:07:07,860 --> 00:07:11,730
actually well it says it created hello

00:07:09,810 --> 00:07:13,560
dot live we'll talk about that in a bit

00:07:11,730 --> 00:07:16,350
it also created hello DLL though it

00:07:13,560 --> 00:07:18,420
didn't tell us that so now that we have

00:07:16,350 --> 00:07:20,130
our DLL we can just run it note we can't

00:07:18,420 --> 00:07:22,110
just run it sorry that won't work so

00:07:20,130 --> 00:07:24,870
we're gonna have to write a program that

00:07:22,110 --> 00:07:26,400
actually uses this so I've written a

00:07:24,870 --> 00:07:28,620
program called print greeting we have a

00:07:26,400 --> 00:07:29,910
main function in it we're going to do is

00:07:28,620 --> 00:07:32,010
we're going to call this load library

00:07:29,910 --> 00:07:33,900
function that basically goes finds the

00:07:32,010 --> 00:07:36,360
DLL loads it into memory and gives us a

00:07:33,900 --> 00:07:37,830
handle back called an H module that we

00:07:36,360 --> 00:07:40,490
can use to refer to the DLL that's been

00:07:37,830 --> 00:07:42,630
loaded in memory so this will do that

00:07:40,490 --> 00:07:44,250
well then get a function will then

00:07:42,630 --> 00:07:45,720
create a function pointer type that

00:07:44,250 --> 00:07:47,400
matches the type of this function that

00:07:45,720 --> 00:07:49,560
we're exporting now we're going to call

00:07:47,400 --> 00:07:50,940
get proc address for the get greeting

00:07:49,560 --> 00:07:52,980
function so we're going to ask the the

00:07:50,940 --> 00:07:55,140
loader to give us the address of this

00:07:52,980 --> 00:07:56,820
function inside of that DLL Rhian

00:07:55,140 --> 00:07:59,070
reinterpret cast it's the appropriate

00:07:56,820 --> 00:08:00,870
type well then just call puts to print

00:07:59,070 --> 00:08:03,740
the string out and then free library

00:08:00,870 --> 00:08:06,240
because we're done using the DLL and

00:08:03,740 --> 00:08:07,980
then finally we need to headers because

00:08:06,240 --> 00:08:10,410
we are using functionality from Studio

00:08:07,980 --> 00:08:13,200
for puts and windows for the various

00:08:10,410 --> 00:08:14,940
library loading functions so we can

00:08:13,200 --> 00:08:16,980
compile and Link that and then if we run

00:08:14,940 --> 00:08:19,140
the program we see it prints out hello

00:08:16,980 --> 00:08:20,640
C++ programmers for those of you with a

00:08:19,140 --> 00:08:22,710
short attention span that was the same

00:08:20,640 --> 00:08:26,480
string that we had in our DLL so good

00:08:22,710 --> 00:08:29,160
we've got it working this is our example

00:08:26,480 --> 00:08:31,020
alright so let's take a look at what's

00:08:29,160 --> 00:08:33,450
actually inside of that hello dot DLL

00:08:31,020 --> 00:08:35,010
that we built so when I want to look

00:08:33,450 --> 00:08:37,590
inside a file there's a program called

00:08:35,010 --> 00:08:40,590
type very helpful so here's what's

00:08:37,590 --> 00:08:43,080
inside of a file it's not particularly

00:08:40,590 --> 00:08:44,760
useful I asked on Twitter I told people

00:08:43,080 --> 00:08:46,080
like I couldn't figure out like you know

00:08:44,760 --> 00:08:48,150
is there a better tool for this someone

00:08:46,080 --> 00:08:51,510
suggested notepad so that works

00:08:48,150 --> 00:08:54,180
unfortunately just as well we have some

00:08:51,510 --> 00:08:56,670
other tools we'll be looking at here

00:08:54,180 --> 00:08:58,200
so a dll file consists of basically a

00:08:56,670 --> 00:08:59,790
handful of things that are just in

00:08:58,200 --> 00:09:01,410
sequence in the file so it starts off

00:08:59,790 --> 00:09:03,060
every DLL has a DOS

00:09:01,410 --> 00:09:05,040
stub program in it it's completely

00:09:03,060 --> 00:09:07,470
useless now but it's there for legacy

00:09:05,040 --> 00:09:10,410
purposes from back when Windows and dos

00:09:07,470 --> 00:09:11,940
inter operated it then has a PE

00:09:10,410 --> 00:09:14,490
signature which marks the beginning of

00:09:11,940 --> 00:09:16,830
the PE the PE stands for portable

00:09:14,490 --> 00:09:18,690
executable so every DLL and XE is one of

00:09:16,830 --> 00:09:20,130
these PE files there's a big

00:09:18,690 --> 00:09:21,840
specification on the Microsoft

00:09:20,130 --> 00:09:24,300
documentation website that has all of

00:09:21,840 --> 00:09:25,860
the details I'm about to talk about it

00:09:24,300 --> 00:09:27,300
then has a cough file header which has a

00:09:25,860 --> 00:09:28,800
little information about the file it has

00:09:27,300 --> 00:09:31,260
an optional header that's not actually

00:09:28,800 --> 00:09:33,180
optional that has DLL information in it

00:09:31,260 --> 00:09:34,830
it then has a set of section headers

00:09:33,180 --> 00:09:36,330
that tell you how to find information in

00:09:34,830 --> 00:09:38,130
the DLL like what's actually inside of

00:09:36,330 --> 00:09:40,590
it and it just has all of the code and

00:09:38,130 --> 00:09:41,970
data after that so we'll start by

00:09:40,590 --> 00:09:44,940
looking at the DA stub and the PE

00:09:41,970 --> 00:09:46,680
signature so this is I've opened up in a

00:09:44,940 --> 00:09:48,930
hex editor you can see it's a little

00:09:46,680 --> 00:09:50,580
stub program or well it's probably not

00:09:48,930 --> 00:09:52,140
easy to see that but it basically just

00:09:50,580 --> 00:09:53,580
is it's a little DOS program that prints

00:09:52,140 --> 00:09:55,680
out this program cannot be run in DOS

00:09:53,580 --> 00:09:57,150
mode so that you know back when dos and

00:09:55,680 --> 00:09:58,740
windows inter operated if you ran a

00:09:57,150 --> 00:10:00,090
Windows program in Dass it wouldn't you

00:09:58,740 --> 00:10:02,370
know actually run it would just print

00:10:00,090 --> 00:10:04,230
this message so then we also see here

00:10:02,370 --> 00:10:06,110
it's got the PE signature at the end so

00:10:04,230 --> 00:10:10,800
there's the PE and to null terminators

00:10:06,110 --> 00:10:13,140
how do we find that there's basically a

00:10:10,800 --> 00:10:16,320
well-defined way there's at offset 3 C

00:10:13,140 --> 00:10:17,820
in the file there's a there's a value

00:10:16,320 --> 00:10:20,000
and that tells you the offset of the PE

00:10:17,820 --> 00:10:22,320
signature so it's at c8 in this file

00:10:20,000 --> 00:10:23,990
alright that's all just how we get to

00:10:22,320 --> 00:10:25,830
find the information we want to look for

00:10:23,990 --> 00:10:27,810
so next up we're gonna look at the

00:10:25,830 --> 00:10:30,750
coffee header the optional header and

00:10:27,810 --> 00:10:32,040
the section headers so to do that we're

00:10:30,750 --> 00:10:34,350
gonna use a tool called dump bin which

00:10:32,040 --> 00:10:35,730
basically just parses dll or XE files

00:10:34,350 --> 00:10:37,140
and it gives you all sorts of

00:10:35,730 --> 00:10:38,760
information about them so it goes in

00:10:37,140 --> 00:10:40,170
parses all the data structures inside of

00:10:38,760 --> 00:10:43,050
them and presents it in the mostly

00:10:40,170 --> 00:10:45,030
readable text form so here we've run

00:10:43,050 --> 00:10:46,560
dump in slash headers which prints out

00:10:45,030 --> 00:10:48,870
all of the header information and at the

00:10:46,560 --> 00:10:50,940
top of those we'll see that ok it's

00:10:48,870 --> 00:10:53,010
recognized that this is hello dot dll

00:10:50,940 --> 00:10:54,390
it's found the PE signature which means

00:10:53,010 --> 00:10:56,220
it's you know at least starting to find

00:10:54,390 --> 00:10:57,570
that it's a valid file it's discovered

00:10:56,220 --> 00:10:59,250
at the DLL and then it's going to print

00:10:57,570 --> 00:11:01,140
out the actual contents of the COFF

00:10:59,250 --> 00:11:02,550
header so we can see here it tells you

00:11:01,140 --> 00:11:04,170
what machine this is made for so this is

00:11:02,550 --> 00:11:06,930
the kind of process the DLL has to be

00:11:04,170 --> 00:11:07,740
loaded into tells you that this DLL file

00:11:06,930 --> 00:11:08,730
has to sex

00:11:07,740 --> 00:11:10,380
in it which we're going to need later

00:11:08,730 --> 00:11:12,450
when we go to look for the section

00:11:10,380 --> 00:11:14,550
headers tells you the time and date

00:11:12,450 --> 00:11:16,050
stamp that this DLL was built this can

00:11:14,550 --> 00:11:18,090
actually be any value so it's not

00:11:16,050 --> 00:11:20,360
necessarily the time and date stamp it

00:11:18,090 --> 00:11:22,590
is by default but you can customize that

00:11:20,360 --> 00:11:23,790
it tells you the size of the optional

00:11:22,590 --> 00:11:25,560
header and then it has some

00:11:23,790 --> 00:11:27,540
characteristics this file contains

00:11:25,560 --> 00:11:29,130
executable code so executable here does

00:11:27,540 --> 00:11:30,870
not mean that it's an XD it just means

00:11:29,130 --> 00:11:33,360
it has it can be loaded as an executable

00:11:30,870 --> 00:11:35,610
DLL it says it can handle large

00:11:33,360 --> 00:11:37,740
addresses this is a 64 bit binary it has

00:11:35,610 --> 00:11:39,780
to be able to handle large addresses 32

00:11:37,740 --> 00:11:43,260
bit is different and then it's a dll not

00:11:39,780 --> 00:11:44,340
an X E so then what the loader will do

00:11:43,260 --> 00:11:45,540
is it'll look at that size of the

00:11:44,340 --> 00:11:48,420
optional header and that will tell it

00:11:45,540 --> 00:11:50,510
the type to read to interpret the option

00:11:48,420 --> 00:11:52,770
to use to interpret the optional header

00:11:50,510 --> 00:11:55,890
so there's two types of optional headers

00:11:52,770 --> 00:11:58,380
there's PE 32 and PE 32 plus and as you

00:11:55,890 --> 00:12:03,570
would guess PE 32 is for 32-bit binaries

00:11:58,380 --> 00:12:05,520
and PE 32 plus is for 64-bit binaries so

00:12:03,570 --> 00:12:07,140
you can see here that's also a magic

00:12:05,520 --> 00:12:08,640
number that allows the loader or the

00:12:07,140 --> 00:12:10,020
linker or the loader to make sure that

00:12:08,640 --> 00:12:11,970
it you know it's parsing the right kind

00:12:10,020 --> 00:12:13,830
of data we can see here the entry point

00:12:11,970 --> 00:12:15,390
is null we'll talk about entry points

00:12:13,830 --> 00:12:16,920
later but basically we've told it no

00:12:15,390 --> 00:12:19,260
entry so that's what we're expecting to

00:12:16,920 --> 00:12:20,580
see has the preferred base address for

00:12:19,260 --> 00:12:22,890
the image which comes it becomes

00:12:20,580 --> 00:12:24,960
important later it has some alignment

00:12:22,890 --> 00:12:28,560
information tells us the size of the

00:12:24,960 --> 00:12:29,760
image is hex 3000 bytes and it's got

00:12:28,560 --> 00:12:30,990
some characteristic some extra

00:12:29,760 --> 00:12:33,570
information and then finally there's

00:12:30,990 --> 00:12:36,020
some directories which are additional

00:12:33,570 --> 00:12:39,090
metadata about what's inside of the DLL

00:12:36,020 --> 00:12:41,580
so you'll see that in the directories it

00:12:39,090 --> 00:12:44,460
actually says r-va and size so what is

00:12:41,580 --> 00:12:45,900
an RV a and to talk about that we have

00:12:44,460 --> 00:12:47,910
to talk about how we address within a

00:12:45,900 --> 00:12:49,260
DLL so let's say you've got your program

00:12:47,910 --> 00:12:51,060
running so we've got the heap there

00:12:49,260 --> 00:12:53,310
we've got print greeting XE we've got a

00:12:51,060 --> 00:12:55,890
couple thread stacks some other data

00:12:53,310 --> 00:12:59,340
somewhere and we want to go and load our

00:12:55,890 --> 00:13:02,280
hello DLL now our hello DLL wants to

00:12:59,340 --> 00:13:04,680
load at this base address the loader

00:13:02,280 --> 00:13:07,170
will say alright is that space free yes

00:13:04,680 --> 00:13:08,580
great it'll load it there and it'll you

00:13:07,170 --> 00:13:10,740
know everything works fine everything's

00:13:08,580 --> 00:13:11,880
happy but what happens if you know we've

00:13:10,740 --> 00:13:13,230
started a couple other threads and

00:13:11,880 --> 00:13:14,550
they're now occupying that space in

00:13:13,230 --> 00:13:16,650
memory it needs to go and put the DLL

00:13:14,550 --> 00:13:18,240
somewhere else we can't load the DLL

00:13:16,650 --> 00:13:18,930
there that memory is already in use we'd

00:13:18,240 --> 00:13:20,640
go and over

00:13:18,930 --> 00:13:22,170
something we can't move data around in a

00:13:20,640 --> 00:13:24,660
native process because you've got just

00:13:22,170 --> 00:13:26,339
random pointers pointing to things so

00:13:24,660 --> 00:13:29,520
maybe the deal loader will load it you

00:13:26,339 --> 00:13:31,260
know up here instead we'll talk a little

00:13:29,520 --> 00:13:32,910
bit more about this later in the talk

00:13:31,260 --> 00:13:34,110
in general dll's actually don't get

00:13:32,910 --> 00:13:36,540
loaded the preferred base address

00:13:34,110 --> 00:13:37,709
anymore basically the security feature

00:13:36,540 --> 00:13:39,660
the loader will try to load them at a

00:13:37,709 --> 00:13:41,010
random address in each process so it's

00:13:39,660 --> 00:13:43,110
not predictable where the data will be

00:13:41,010 --> 00:13:44,550
but the important thing is is that a dll

00:13:43,110 --> 00:13:46,830
can be loaded at all sorts of different

00:13:44,550 --> 00:13:48,540
places in your address space so we need

00:13:46,830 --> 00:13:50,339
a way to address things within a dll

00:13:48,540 --> 00:13:52,200
without relying on the actual address at

00:13:50,339 --> 00:13:54,029
which it's loaded and so what we use are

00:13:52,200 --> 00:13:56,190
what are called our V A's or relative

00:13:54,029 --> 00:13:58,410
virtual addresses which are just offsets

00:13:56,190 --> 00:13:59,730
from the beginning of the DLL so if you

00:13:58,410 --> 00:14:01,320
want to find the address of something in

00:13:59,730 --> 00:14:02,760
memory and you have its r-va you just

00:14:01,320 --> 00:14:05,310
add it to the base address at which it

00:14:02,760 --> 00:14:06,510
was the DLL was actually loaded or if

00:14:05,310 --> 00:14:08,100
you have the address of something and

00:14:06,510 --> 00:14:10,110
you want its RVA you just subtract the

00:14:08,100 --> 00:14:12,180
base address from it so for example if

00:14:10,110 --> 00:14:15,149
our get greeting function in hello DLL

00:14:12,180 --> 00:14:16,589
has an r VA of 2000 and if hello gets

00:14:15,149 --> 00:14:18,779
loaded at its preferred base address

00:14:16,589 --> 00:14:19,860
there then get greeting will be located

00:14:18,779 --> 00:14:21,510
at this address

00:14:19,860 --> 00:14:25,410
because again you just add the two

00:14:21,510 --> 00:14:27,480
together so that's the optional header

00:14:25,410 --> 00:14:28,950
the optional header then gets followed

00:14:27,480 --> 00:14:30,209
by the section headers so they're just

00:14:28,950 --> 00:14:31,980
one after the other and these tell you

00:14:30,209 --> 00:14:34,260
where to find the actual data inside of

00:14:31,980 --> 00:14:35,670
the DLL so here for example is the first

00:14:34,260 --> 00:14:38,279
section it's the text section which

00:14:35,670 --> 00:14:40,800
contains code we can see that because in

00:14:38,279 --> 00:14:42,270
the flags it has execute and this needs

00:14:40,800 --> 00:14:44,880
to be mapped into a page in memory with

00:14:42,270 --> 00:14:46,650
execute and read privileges we can see

00:14:44,880 --> 00:14:48,209
here the virtual address so this is the

00:14:46,650 --> 00:14:51,300
r-va at where this section will be

00:14:48,209 --> 00:14:52,920
located when the DLL is loaded and then

00:14:51,300 --> 00:14:54,270
we can see the virtual size which is the

00:14:52,920 --> 00:14:55,560
number of bytes that are actually

00:14:54,270 --> 00:14:57,900
contained here there's only eight bytes

00:14:55,560 --> 00:15:00,240
of code in this DLL and then some other

00:14:57,900 --> 00:15:02,760
information about how it how its laid

00:15:00,240 --> 00:15:03,810
out in the file the second section is in

00:15:02,760 --> 00:15:05,550
our data section which contains

00:15:03,810 --> 00:15:06,870
read-only data we can see that in the

00:15:05,550 --> 00:15:08,790
flags here that it will need to be

00:15:06,870 --> 00:15:10,440
mapped into a page that is has read-only

00:15:08,790 --> 00:15:12,720
permissions so not writable not

00:15:10,440 --> 00:15:15,810
executable and it's got slightly more

00:15:12,720 --> 00:15:17,459
data in it from the optional header we

00:15:15,810 --> 00:15:19,680
also saw that there were you know those

00:15:17,459 --> 00:15:20,940
two directory well this DLL had two

00:15:19,680 --> 00:15:23,700
directories there are many more it could

00:15:20,940 --> 00:15:24,959
have had and the r-va is there happen to

00:15:23,700 --> 00:15:26,220
be inside of this section and we can

00:15:24,959 --> 00:15:28,680
tell that because the r-va

00:15:26,220 --> 00:15:31,740
of the export directory for example is

00:15:28,680 --> 00:15:32,889
2040 and this section occupies all of

00:15:31,740 --> 00:15:35,920
the virtual addresses

00:15:32,889 --> 00:15:37,509
from 2000 up until 20 d7 you can see

00:15:35,920 --> 00:15:40,629
that on the third or fourth line of

00:15:37,509 --> 00:15:42,279
output so from hello dll's headers we

00:15:40,629 --> 00:15:43,929
know that the DLL will occupy three

00:15:42,279 --> 00:15:46,389
pages in memory when loaded into the

00:15:43,929 --> 00:15:47,619
process one page will contain the

00:15:46,389 --> 00:15:49,749
headers one page will contain the text

00:15:47,619 --> 00:15:51,339
section one can page will contain that

00:15:49,749 --> 00:15:53,799
our data section and we'll show that in

00:15:51,339 --> 00:15:55,299
a bit more detail in a bit these aren't

00:15:53,799 --> 00:15:56,679
the only possible sections there's other

00:15:55,299 --> 00:15:57,999
kinds of sections we might find in the

00:15:56,679 --> 00:16:00,609
DLL but these are the only ones this

00:15:57,999 --> 00:16:01,959
program needs the DLL has additional

00:16:00,609 --> 00:16:03,850
metadata and a pair of directories

00:16:01,959 --> 00:16:05,259
there's the debug directory that we're

00:16:03,850 --> 00:16:06,850
not going to look at but it basically

00:16:05,259 --> 00:16:09,309
has some very basic debug information

00:16:06,850 --> 00:16:11,739
and there's an export directory that we

00:16:09,309 --> 00:16:13,649
will look at in a little bit and all of

00:16:11,739 --> 00:16:15,699
that data is contained in the our data

00:16:13,649 --> 00:16:17,109
section because it's it's basically just

00:16:15,699 --> 00:16:24,730
read-only data that the loader is going

00:16:17,109 --> 00:16:26,169
to use so then after that basically we

00:16:24,730 --> 00:16:27,970
just have the sections so the section

00:16:26,169 --> 00:16:30,910
headers told us where to find the data

00:16:27,970 --> 00:16:32,379
in the file and so we can now look at

00:16:30,910 --> 00:16:34,869
what's actually inside of the sections

00:16:32,379 --> 00:16:36,160
to do that we can use dump in slash raw

00:16:34,869 --> 00:16:37,929
data which will actually just print out

00:16:36,160 --> 00:16:39,189
the hex of the data that's inside of

00:16:37,929 --> 00:16:41,559
each section so here we'll start with

00:16:39,189 --> 00:16:43,749
the text section and we can see that

00:16:41,559 --> 00:16:46,419
well okay it contains some bytes since

00:16:43,749 --> 00:16:48,459
this is executable code we can also use

00:16:46,419 --> 00:16:50,079
the diss Azzam option of dump in which

00:16:48,459 --> 00:16:52,239
we'll actually disassemble it and so we

00:16:50,079 --> 00:16:54,009
can see it's two instructions all right

00:16:52,239 --> 00:16:55,989
well that's not very exciting but there

00:16:54,009 --> 00:16:57,759
it is I mean then look at the our data

00:16:55,989 --> 00:17:00,850
section and again we can use the raw

00:16:57,759 --> 00:17:02,860
data option and it's got well a bit more

00:17:00,850 --> 00:17:04,089
data most notably it has our string

00:17:02,860 --> 00:17:05,350
there so this is where the string is

00:17:04,089 --> 00:17:07,059
located it's a string literal it's

00:17:05,350 --> 00:17:09,850
read-only data it'll be in the our data

00:17:07,059 --> 00:17:11,409
section additionally those two

00:17:09,850 --> 00:17:14,079
directories that we talked about

00:17:11,409 --> 00:17:16,419
previously are also located in here so I

00:17:14,079 --> 00:17:18,250
can highlight those we're not going to

00:17:16,419 --> 00:17:19,689
talk about the raw bytes there but we

00:17:18,250 --> 00:17:21,100
will look at what's inside of the export

00:17:19,689 --> 00:17:25,179
directory so the export directory

00:17:21,100 --> 00:17:26,860
defines the public surface of the DLL so

00:17:25,179 --> 00:17:28,960
it defines all of the things that you

00:17:26,860 --> 00:17:31,720
know other dll's or xes can use from

00:17:28,960 --> 00:17:33,279
this DLL and so to get information out

00:17:31,720 --> 00:17:35,860
of it there's an option of dumping you

00:17:33,279 --> 00:17:38,590
just call dump in exports on the DLL and

00:17:35,860 --> 00:17:40,149
here it'll print out okay we have one

00:17:38,590 --> 00:17:41,919
function that's exportable so you can if

00:17:40,149 --> 00:17:43,809
you have a handle to this DLL you can

00:17:41,919 --> 00:17:45,399
call get proc address and you can get

00:17:43,809 --> 00:17:47,400
this one function that's the only thing

00:17:45,399 --> 00:17:48,510
that's available here

00:17:47,400 --> 00:17:51,660
so at this point we can put everything

00:17:48,510 --> 00:17:52,440
together so in the export directory we

00:17:51,660 --> 00:17:54,630
see okay

00:17:52,440 --> 00:17:56,760
the get greeting function is located at

00:17:54,630 --> 00:17:58,980
our VA 1000 well I remember from

00:17:56,760 --> 00:18:01,170
previously our VA 1000 is in the text

00:17:58,980 --> 00:18:03,090
section and so we can disassemble the

00:18:01,170 --> 00:18:05,250
text section and we can see okay that's

00:18:03,090 --> 00:18:07,710
the first instruction in there now if

00:18:05,250 --> 00:18:10,230
you're familiar with so that's pointing

00:18:07,710 --> 00:18:12,510
basically to that first instruction now

00:18:10,230 --> 00:18:14,400
if you're familiar with x64 calling

00:18:12,510 --> 00:18:15,420
conventions and assembly basically if

00:18:14,400 --> 00:18:17,010
you have a function that returns a

00:18:15,420 --> 00:18:18,840
pointer like our get greeting function

00:18:17,010 --> 00:18:21,030
you put the pointer into the re X

00:18:18,840 --> 00:18:23,070
register and then you return and so here

00:18:21,030 --> 00:18:24,870
we can see that this is going to load

00:18:23,070 --> 00:18:28,080
the address of whatever is at our VA

00:18:24,870 --> 00:18:31,110
2000 into the re X register and then

00:18:28,080 --> 00:18:33,150
return well what's at our VA 2000 well I

00:18:31,110 --> 00:18:35,130
remember that was inside of our data

00:18:33,150 --> 00:18:36,960
section and so if we look in there

00:18:35,130 --> 00:18:38,880
that's at the very beginning of the our

00:18:36,960 --> 00:18:40,559
data section and it's going to return

00:18:38,880 --> 00:18:43,350
the the address of our string or the

00:18:40,559 --> 00:18:44,790
address of our string literal so that's

00:18:43,350 --> 00:18:46,860
kind of the basics of what's inside of

00:18:44,790 --> 00:18:53,820
the DLL how all the pieces pointed each

00:18:46,860 --> 00:18:55,500
other work together so in this example

00:18:53,820 --> 00:18:58,410
that we had previously of our print

00:18:55,500 --> 00:19:00,270
greeting we we saw how to link

00:18:58,410 --> 00:19:02,179
explicitly to the DLL so where you

00:19:00,270 --> 00:19:04,440
actually call load library to get the

00:19:02,179 --> 00:19:05,850
handle to the DLL you call get proc

00:19:04,440 --> 00:19:07,920
address to get you know the actual

00:19:05,850 --> 00:19:10,020
address of the function but there's a

00:19:07,920 --> 00:19:11,580
little problem here and that is that

00:19:10,020 --> 00:19:13,950
well load library is actually defined in

00:19:11,580 --> 00:19:15,540
a DLL itself and get proc address is

00:19:13,950 --> 00:19:19,860
also defined in a DLL so both of these

00:19:15,540 --> 00:19:21,840
are defined in kernel32.dll so well we

00:19:19,860 --> 00:19:23,640
can't call load library to get you know

00:19:21,840 --> 00:19:26,790
kernel32 so that we can get the address

00:19:23,640 --> 00:19:28,170
of load library that would not work so

00:19:26,790 --> 00:19:31,679
dll's can actually have implicit

00:19:28,170 --> 00:19:33,179
dependencies so what you can do is you

00:19:31,679 --> 00:19:34,380
can run dump independence which will

00:19:33,179 --> 00:19:36,929
tell you all of the dependencies that

00:19:34,380 --> 00:19:40,130
you know and XE or a DLL has our print

00:19:36,929 --> 00:19:42,750
greeting has dependency on kernel32.dll

00:19:40,130 --> 00:19:44,820
and we can run dump in slash imports to

00:19:42,750 --> 00:19:47,490
find out what exactly it's importing

00:19:44,820 --> 00:19:49,140
from that DLL and so here it'll say

00:19:47,490 --> 00:19:51,030
alright it has the following imports and

00:19:49,140 --> 00:19:52,770
we can see free library get proc address

00:19:51,030 --> 00:19:54,030
and load library which are the three

00:19:52,770 --> 00:19:55,710
functions that we called in our main

00:19:54,030 --> 00:19:57,120
function and then it turns out because

00:19:55,710 --> 00:19:59,700
we've statically linked the C runtime

00:19:57,120 --> 00:20:01,200
into this XC so we can call puts there's

00:19:59,700 --> 00:20:05,280
actually a whole bunch more

00:20:01,200 --> 00:20:07,320
imports so I don't want to look at

00:20:05,280 --> 00:20:08,850
kernel32 for this because again there's

00:20:07,320 --> 00:20:11,100
so many functions and it's you know it's

00:20:08,850 --> 00:20:13,050
big and complex so what I want to do is

00:20:11,100 --> 00:20:16,800
I want to convert this print greeting

00:20:13,050 --> 00:20:18,780
program that used explicit linking to

00:20:16,800 --> 00:20:20,820
our DLL and I want to convert it into

00:20:18,780 --> 00:20:22,590
this one so basically we just want to

00:20:20,820 --> 00:20:24,600
declare our get greeting function and

00:20:22,590 --> 00:20:28,800
then call it and then use implicit

00:20:24,600 --> 00:20:30,420
linking to get everything to work so

00:20:28,800 --> 00:20:33,300
what we're going to do is again we're

00:20:30,420 --> 00:20:36,810
going to previously we link to our Hello

00:20:33,300 --> 00:20:39,060
DLL and that printed out creating

00:20:36,810 --> 00:20:43,260
library hello dot libe that library is

00:20:39,060 --> 00:20:44,220
an import library for Hello DLL and so

00:20:43,260 --> 00:20:46,050
what we can actually do we can actually

00:20:44,220 --> 00:20:48,660
also run dump in exports on that libe

00:20:46,050 --> 00:20:51,390
and it'll tell us okay well the get

00:20:48,660 --> 00:20:52,800
greeting function is available so it's

00:20:51,390 --> 00:20:54,990
actually inside of there you have to run

00:20:52,800 --> 00:20:56,610
dump in all to get more detailed

00:20:54,990 --> 00:20:57,630
information and this prints out tons of

00:20:56,610 --> 00:21:00,870
stuff so I'm just going to show the

00:20:57,630 --> 00:21:02,250
important excerpts it has the two

00:21:00,870 --> 00:21:04,440
linkable symbols so it has a get

00:21:02,250 --> 00:21:06,090
greeting symbol that it can be linked to

00:21:04,440 --> 00:21:09,090
and then it has an imp get greeting and

00:21:06,090 --> 00:21:10,950
then there's an R an extra member inside

00:21:09,090 --> 00:21:12,750
of the library that actually says okay

00:21:10,950 --> 00:21:14,610
this get greeting function is a code

00:21:12,750 --> 00:21:19,800
export so it's a function not data and

00:21:14,610 --> 00:21:22,950
it it's located inside of Hello DLL so

00:21:19,800 --> 00:21:24,630
what happens inside the linker is this

00:21:22,950 --> 00:21:25,950
is as if the library had the following

00:21:24,630 --> 00:21:27,930
so it's as if we had a function pointer

00:21:25,950 --> 00:21:29,610
of the correct type and it's got a

00:21:27,930 --> 00:21:31,710
global variable imp underscore get

00:21:29,610 --> 00:21:33,360
greeting that gets initialized to the

00:21:31,710 --> 00:21:34,860
address of the get greeting function

00:21:33,360 --> 00:21:36,210
inside the other DLL and that happens

00:21:34,860 --> 00:21:39,270
through magic and we'll see how that

00:21:36,210 --> 00:21:41,010
magic works in an upcoming section but

00:21:39,270 --> 00:21:42,990
for now just you know assume that this

00:21:41,010 --> 00:21:45,030
ends up being the address of the gate

00:21:42,990 --> 00:21:46,320
greeting function and then get greeting

00:21:45,030 --> 00:21:47,850
is basically just a stub that gets

00:21:46,320 --> 00:21:49,200
statically linked into your program that

00:21:47,850 --> 00:21:50,850
call that calls through that function

00:21:49,200 --> 00:21:52,380
pointer so this way when you you know

00:21:50,850 --> 00:21:53,850
inside of our main function if we call

00:21:52,380 --> 00:21:55,020
get greeting it'll end up calling

00:21:53,850 --> 00:21:59,730
through that function pointer and

00:21:55,020 --> 00:22:01,980
getting the the function from the DLL so

00:21:59,730 --> 00:22:04,740
then if we have our print greeting

00:22:01,980 --> 00:22:07,590
implicit function our program we can

00:22:04,740 --> 00:22:10,020
compile it we can run it and we get our

00:22:07,590 --> 00:22:11,370
message again then if we run dump

00:22:10,020 --> 00:22:12,750
independence on our print implicit

00:22:11,370 --> 00:22:14,940
program you know as compared to our

00:22:12,750 --> 00:22:17,220
print greeting program we can see well

00:22:14,940 --> 00:22:19,770
depends on hello DLL just like the other

00:22:17,220 --> 00:22:21,270
one depended only on kernel32 and if we

00:22:19,770 --> 00:22:22,890
look at the imports we can see okay it

00:22:21,270 --> 00:22:25,230
imports get greeting and we no longer

00:22:22,890 --> 00:22:26,970
import the load library free library and

00:22:25,230 --> 00:22:28,380
get proc address from kernel32 but we

00:22:26,970 --> 00:22:30,780
still do import all the things that

00:22:28,380 --> 00:22:39,720
needed for the sieves the C standard

00:22:30,780 --> 00:22:44,010
library alright so so far we've looked

00:22:39,720 --> 00:22:45,630
at how you can use slash export to tell

00:22:44,010 --> 00:22:47,040
the linker what you want to what you

00:22:45,630 --> 00:22:48,210
want your export surface to be there's a

00:22:47,040 --> 00:22:49,410
few other ways and there's a few

00:22:48,210 --> 00:22:51,360
advanced things that we can do so we'll

00:22:49,410 --> 00:22:53,070
look at that so I'm kind of tired of

00:22:51,360 --> 00:22:55,050
this you know silly example of you know

00:22:53,070 --> 00:22:56,580
our greeting program so I came up with a

00:22:55,050 --> 00:22:59,670
new example I thought it'd be useful to

00:22:56,580 --> 00:23:03,150
have a DLL that has common Matt commonly

00:22:59,670 --> 00:23:05,010
used math constants so to that we're

00:23:03,150 --> 00:23:08,430
gonna have these three functions now get

00:23:05,010 --> 00:23:10,500
one two and three and so from previously

00:23:08,430 --> 00:23:14,910
we know that we can just pass / export

00:23:10,500 --> 00:23:16,920
for each one of those create the DLL and

00:23:14,910 --> 00:23:18,540
then if we dump in the exports we'll see

00:23:16,920 --> 00:23:19,980
okay it exports all three of those so

00:23:18,540 --> 00:23:21,560
that's just the same as we were doing

00:23:19,980 --> 00:23:23,790
before except now we have three of them

00:23:21,560 --> 00:23:26,910
and if we look in the library it also

00:23:23,790 --> 00:23:29,790
has all three of them you can also

00:23:26,910 --> 00:23:31,260
rename exports so for example here if

00:23:29,790 --> 00:23:33,450
instead of calling it get three we

00:23:31,260 --> 00:23:34,950
wanted to call it get one plus two we

00:23:33,450 --> 00:23:36,600
can we don't even need to rename the

00:23:34,950 --> 00:23:38,190
function inside of the code we can leave

00:23:36,600 --> 00:23:39,690
it name get three yeah I don't know why

00:23:38,190 --> 00:23:41,610
we wouldn't want to change that but it's

00:23:39,690 --> 00:23:43,770
possible and then we can export it as

00:23:41,610 --> 00:23:45,180
you know get one plus two and so then

00:23:43,770 --> 00:23:47,340
you see in the exports list and in the

00:23:45,180 --> 00:23:49,410
import library it's just renamed the

00:23:47,340 --> 00:23:52,740
symbol but in our code it stayed the

00:23:49,410 --> 00:23:54,510
same now let's say we want to add get

00:23:52,740 --> 00:23:57,600
three back we can do that and you can

00:23:54,510 --> 00:23:59,430
note in the exports list that we haven't

00:23:57,600 --> 00:24:00,930
added a new function to the DLL we just

00:23:59,430 --> 00:24:02,730
added a new name for it in the export

00:24:00,930 --> 00:24:04,890
list so here you can see you get one

00:24:02,730 --> 00:24:10,110
plus two and get three are both at our

00:24:04,890 --> 00:24:12,840
VA 10 20 you can also have private

00:24:10,110 --> 00:24:14,460
exports so these are exports that you

00:24:12,840 --> 00:24:16,800
can call get proc address to get them

00:24:14,460 --> 00:24:18,180
but they're not in the import library so

00:24:16,800 --> 00:24:20,460
you can't implicitly link to them you

00:24:18,180 --> 00:24:21,750
can only explicitly link to them so this

00:24:20,460 --> 00:24:23,190
is useful for example if you want to

00:24:21,750 --> 00:24:24,540
deprecate some functionality you don't

00:24:23,190 --> 00:24:25,800
want people calling something anymore

00:24:24,540 --> 00:24:27,630
but you can't remove it because you've

00:24:25,800 --> 00:24:29,900
got people depending on the the existing

00:24:27,630 --> 00:24:32,790
api's

00:24:29,900 --> 00:24:34,620
so this slash export can get very

00:24:32,790 --> 00:24:36,360
unwieldy if you've got like a thousand

00:24:34,620 --> 00:24:37,560
exports from your DLL right like you

00:24:36,360 --> 00:24:38,970
don't wanna have to keep updating your

00:24:37,560 --> 00:24:40,290
make files every time you add new

00:24:38,970 --> 00:24:42,690
exports and you don't have to maintain a

00:24:40,290 --> 00:24:44,190
gigantic list of these options I expect

00:24:42,690 --> 00:24:46,440
you to run up against some limit on the

00:24:44,190 --> 00:24:48,180
length of the command line eventually so

00:24:46,440 --> 00:24:50,310
another option is you can use what's

00:24:48,180 --> 00:24:51,810
called a module definition file so our

00:24:50,310 --> 00:24:54,540
numbers program is still the same as it

00:24:51,810 --> 00:24:57,540
was before but now we have a new file

00:24:54,540 --> 00:24:59,610
called numbers def so this file just

00:24:57,540 --> 00:25:02,670
says this is a module definition file

00:24:59,610 --> 00:25:05,280
for numbers DLL that DLL is implicit and

00:25:02,670 --> 00:25:07,080
then it has the list of exports so here

00:25:05,280 --> 00:25:08,880
we export the get one function we're

00:25:07,080 --> 00:25:11,430
gonna export get to as being private and

00:25:08,880 --> 00:25:13,050
then we'll do the rename trick I'm just

00:25:11,430 --> 00:25:15,780
doing this to show you the syntax of the

00:25:13,050 --> 00:25:17,670
different options when we link instead

00:25:15,780 --> 00:25:19,770
of passing slash export we pass slash

00:25:17,670 --> 00:25:22,110
def to tell it what the definite module

00:25:19,770 --> 00:25:24,420
definition file is and then if we run

00:25:22,110 --> 00:25:26,310
dump in everything is just as it was

00:25:24,420 --> 00:25:27,960
with the slash export options so this is

00:25:26,310 --> 00:25:31,650
basically just another way of specifying

00:25:27,960 --> 00:25:32,910
all of the exports for the DLL there's

00:25:31,650 --> 00:25:36,600
another option lets you do it inside of

00:25:32,910 --> 00:25:39,960
your code you can annotate a function

00:25:36,600 --> 00:25:41,330
with deckle spec DLL export and then we

00:25:39,960 --> 00:25:43,110
don't have to tell the linker anything

00:25:41,330 --> 00:25:45,750
basically we just pass it the object

00:25:43,110 --> 00:25:49,380
file and then if we dump in the exports

00:25:45,750 --> 00:25:52,050
we see it's got all the exports magic it

00:25:49,380 --> 00:25:54,210
turns out it's actually not magic what

00:25:52,050 --> 00:25:56,400
happens is the compiler basically just

00:25:54,210 --> 00:25:58,110
injects into the object file some

00:25:56,400 --> 00:25:59,580
strings and it tells the linker pretend

00:25:58,110 --> 00:26:02,610
as if you got these on the command line

00:25:59,580 --> 00:26:04,380
so basically deckle spec dll export just

00:26:02,610 --> 00:26:06,150
gets turned into these linker directives

00:26:04,380 --> 00:26:09,570
and so it's exactly the same thing under

00:26:06,150 --> 00:26:11,700
the hood finally there's a fourth option

00:26:09,570 --> 00:26:14,160
I don't really know why one would use

00:26:11,700 --> 00:26:17,310
this but it's possibility you can

00:26:14,160 --> 00:26:19,260
actually pass those those directives

00:26:17,310 --> 00:26:21,510
using pragma comment so there's this

00:26:19,260 --> 00:26:23,700
visual c++ specific pragma that you can

00:26:21,510 --> 00:26:25,890
use and so this will put inject those

00:26:23,700 --> 00:26:29,010
directives into the object file just

00:26:25,890 --> 00:26:31,560
like the deckle spec dll export did

00:26:29,010 --> 00:26:35,540
automatically so if we do that we can

00:26:31,560 --> 00:26:35,540
see the same exports

00:26:38,059 --> 00:26:43,650
cool so now kind of the meat of the talk

00:26:41,010 --> 00:26:46,440
what happens when we load hello dot DLL

00:26:43,650 --> 00:26:50,280
so the loader has to do a lot of things

00:26:46,440 --> 00:26:51,990
and there's a lot of like there's a lot

00:26:50,280 --> 00:26:53,520
of advanced features that dll's can use

00:26:51,990 --> 00:26:55,200
is a lot of interesting things they can

00:26:53,520 --> 00:26:56,580
do we're not going to touch on most of

00:26:55,200 --> 00:26:58,169
those we're gonna focus on the things

00:26:56,580 --> 00:27:02,520
that are germane to our simple example

00:26:58,169 --> 00:27:04,500
here so we're gonna look at five steps

00:27:02,520 --> 00:27:07,289
basically so first the loader needs to

00:27:04,500 --> 00:27:08,909
find hello DLL it needs to map it into

00:27:07,289 --> 00:27:11,669
memory correctly it needs to load any

00:27:08,909 --> 00:27:13,950
dll's that our hello DLL depends on any

00:27:11,669 --> 00:27:16,049
implicit dependencies that it has it's

00:27:13,950 --> 00:27:17,760
going to bind imports from dll's on

00:27:16,049 --> 00:27:19,400
which hello dot DLL depends so it needs

00:27:17,760 --> 00:27:21,750
to actually go and initialize those

00:27:19,400 --> 00:27:23,549
function pointers like imp underscore

00:27:21,750 --> 00:27:24,870
get greeting that we had and then it

00:27:23,549 --> 00:27:28,460
needs to call the entry point for hello

00:27:24,870 --> 00:27:31,409
dot DLL to let it initialize itself so

00:27:28,460 --> 00:27:33,000
before I get into all that I just wanted

00:27:31,409 --> 00:27:35,340
a note so DLL is our reference counted

00:27:33,000 --> 00:27:37,380
so for example here if we call load

00:27:35,340 --> 00:27:39,240
library twice on hello dot DLL the first

00:27:37,380 --> 00:27:41,340
time it will load the DLL and this ref

00:27:39,240 --> 00:27:43,080
count will be one if you call it again

00:27:41,340 --> 00:27:44,400
the ref count will then just be

00:27:43,080 --> 00:27:46,860
incremented of two it's not going to

00:27:44,400 --> 00:27:48,360
load the DLL a second time both hello

00:27:46,860 --> 00:27:50,730
one and hello two will actually be the

00:27:48,360 --> 00:27:52,830
same they'll be the same value same

00:27:50,730 --> 00:27:54,299
handle and then when we call free

00:27:52,830 --> 00:27:55,350
library on the first of those it'll just

00:27:54,299 --> 00:27:57,990
decrement the ref count it won't

00:27:55,350 --> 00:28:00,000
actually you know free that unload the

00:27:57,990 --> 00:28:02,570
DLL and then when we call free library a

00:28:00,000 --> 00:28:04,590
second time it will then unload the DLL

00:28:02,570 --> 00:28:06,000
all right so the first thing we have to

00:28:04,590 --> 00:28:08,460
do is we have to find the right deal odd

00:28:06,000 --> 00:28:10,500
load if we say load library hello dot

00:28:08,460 --> 00:28:15,600
DLL how does the loader know where to

00:28:10,500 --> 00:28:17,460
find hello dot DLL so the easy case is

00:28:15,600 --> 00:28:19,559
if we were to have passed at a an

00:28:17,460 --> 00:28:21,720
absolute path so here instead of just

00:28:19,559 --> 00:28:23,490
calling load library hello dot DLL we

00:28:21,720 --> 00:28:26,340
call load library a column back slash

00:28:23,490 --> 00:28:27,990
hello dot DLL so if a colon backslash

00:28:26,340 --> 00:28:29,610
hello dot DLL has already been loaded

00:28:27,990 --> 00:28:31,980
the loader will just return its module

00:28:29,610 --> 00:28:33,570
handle so that's easy right again it's

00:28:31,980 --> 00:28:34,830
going to be reference counted otherwise

00:28:33,570 --> 00:28:36,450
the loader is actually just going to

00:28:34,830 --> 00:28:37,950
find that file on disk if it's there

00:28:36,450 --> 00:28:41,909
it'll load it if not it'll fail too

00:28:37,950 --> 00:28:43,350
it'll fail the load additionally this

00:28:41,909 --> 00:28:45,120
you can actually load different dll's

00:28:43,350 --> 00:28:46,710
that have the same name from different

00:28:45,120 --> 00:28:49,230
paths so here if I have one on my a

00:28:46,710 --> 00:28:51,160
drive one of my B Drive I guess I have

00:28:49,230 --> 00:28:53,260
two floppy drives on this laptop

00:28:51,160 --> 00:28:54,430
then it would actually load both of

00:28:53,260 --> 00:28:56,380
those those would be different module

00:28:54,430 --> 00:28:57,550
handles and you'd have two different you

00:28:56,380 --> 00:29:03,790
know you'd have two different hello

00:28:57,550 --> 00:29:06,000
dll's and memory so then after that if

00:29:03,790 --> 00:29:10,270
we haven't passed it a an absolute path

00:29:06,000 --> 00:29:12,430
so here we've first we've called load

00:29:10,270 --> 00:29:14,110
library for the absolute path hello DLL

00:29:12,430 --> 00:29:16,240
it's gotten loaded the second time we

00:29:14,110 --> 00:29:18,130
call load library on hello DLL with no

00:29:16,240 --> 00:29:20,560
path the loader is going to say is there

00:29:18,130 --> 00:29:22,780
already a DLL with that name loaded in

00:29:20,560 --> 00:29:23,980
this case yes and so it's actually just

00:29:22,780 --> 00:29:25,690
going to return it's going to say I

00:29:23,980 --> 00:29:26,920
assume that's the DLL you're looking for

00:29:25,690 --> 00:29:29,140
and I'm going to return the handle to

00:29:26,920 --> 00:29:31,870
that so here hello DLL one and hello DLL

00:29:29,140 --> 00:29:33,490
two are the same and we saw previously

00:29:31,870 --> 00:29:34,900
well you can actually have two dll's

00:29:33,490 --> 00:29:36,730
with the same name that already loaded

00:29:34,900 --> 00:29:38,530
in that case the loader is just going to

00:29:36,730 --> 00:29:40,810
pick whichever DLL was loaded first so

00:29:38,530 --> 00:29:43,600
in this case our hello DLL X that was

00:29:40,810 --> 00:29:45,100
loaded with a with no path is the same

00:29:43,600 --> 00:29:49,210
as a because that was the first of the

00:29:45,100 --> 00:29:51,790
two that we loaded so then okay we say

00:29:49,210 --> 00:29:53,050
there's no DLL with the name we're

00:29:51,790 --> 00:29:55,780
looking for that's already been loaded

00:29:53,050 --> 00:29:57,360
and the DLL needs to or the loader needs

00:29:55,780 --> 00:30:00,310
to find the one we're looking for

00:29:57,360 --> 00:30:02,890
so what's going to ask first is is it a

00:30:00,310 --> 00:30:04,360
known DLL so there's a small set of

00:30:02,890 --> 00:30:05,710
operating-system dll's that are

00:30:04,360 --> 00:30:07,960
considered well known to the operating

00:30:05,710 --> 00:30:09,280
system and if you call load library for

00:30:07,960 --> 00:30:10,960
them or if you have a dependency on them

00:30:09,280 --> 00:30:12,610
it's always going to load the operating

00:30:10,960 --> 00:30:14,710
system version of it it's never going to

00:30:12,610 --> 00:30:16,420
do any of the other searching and it's

00:30:14,710 --> 00:30:18,250
basically to prevent DLL hijacking it's

00:30:16,420 --> 00:30:20,440
to prevent you know someone from putting

00:30:18,250 --> 00:30:22,750
a malicious DLL in and replacing some OS

00:30:20,440 --> 00:30:24,970
functionality with their own so here for

00:30:22,750 --> 00:30:27,670
example if we try and load kernel 32 or

00:30:24,970 --> 00:30:29,350
ntdll or ol a 32 these are all known

00:30:27,670 --> 00:30:33,130
dll's so they get loaded from the system

00:30:29,350 --> 00:30:35,140
directory every time whereas if we call

00:30:33,130 --> 00:30:36,940
load library on our hello dot DLL the OS

00:30:35,140 --> 00:30:38,260
doesn't know what that is and so the DIA

00:30:36,940 --> 00:30:40,270
the loader will continue with the search

00:30:38,260 --> 00:30:42,640
process if you want to know what the set

00:30:40,270 --> 00:30:44,410
of known dll's are you can use they're

00:30:42,640 --> 00:30:46,270
all listed in the registry you can just

00:30:44,410 --> 00:30:51,400
look at this registry key these are from

00:30:46,270 --> 00:30:52,960
my Windows 10 laptop so after that all

00:30:51,400 --> 00:30:54,340
right so it's not already loaded into

00:30:52,960 --> 00:30:57,190
memory we don't have an absolute path

00:30:54,340 --> 00:31:00,550
that it's not a known DLL the loader

00:30:57,190 --> 00:31:02,790
needs to go and search for the DLL so

00:31:00,550 --> 00:31:04,980
this is the standard search path

00:31:02,790 --> 00:31:06,600
basically it's going to start by looking

00:31:04,980 --> 00:31:08,850
same directory that our application is

00:31:06,600 --> 00:31:10,410
located so the a drive for my little

00:31:08,850 --> 00:31:12,179
test program here it'll look in the

00:31:10,410 --> 00:31:14,880
system directory which will be system 32

00:31:12,179 --> 00:31:17,010
for 32 bit about programs it'll be sis

00:31:14,880 --> 00:31:20,240
while 64 for or you know I've got that

00:31:17,010 --> 00:31:22,530
backwards anyway it'll be one of those

00:31:20,240 --> 00:31:23,910
it'll then look in the 16-bit system

00:31:22,530 --> 00:31:27,960
directory which is just named system

00:31:23,910 --> 00:31:29,370
because you know legacy it'll then look

00:31:27,960 --> 00:31:31,470
in the current directory so wherever you

00:31:29,370 --> 00:31:32,910
ran the program from and then it'll look

00:31:31,470 --> 00:31:34,559
it'll go through the directories in your

00:31:32,910 --> 00:31:36,900
path environment variable and basically

00:31:34,559 --> 00:31:38,820
is it'll it searches these in that order

00:31:36,900 --> 00:31:41,970
and as soon as it finds one it'll say

00:31:38,820 --> 00:31:43,350
that's the dll I must be looking for the

00:31:41,970 --> 00:31:45,210
current directory used to be searched

00:31:43,350 --> 00:31:48,480
first that changed in Windows XP so

00:31:45,210 --> 00:31:50,070
that's no longer the case this search

00:31:48,480 --> 00:31:52,020
process it turns out is highly

00:31:50,070 --> 00:31:53,940
customizable so there's dll redirection

00:31:52,020 --> 00:31:55,590
side-by-side components the path

00:31:53,940 --> 00:31:57,720
obviously can be customized it's an

00:31:55,590 --> 00:31:59,010
environment variable there's an ADD dll

00:31:57,720 --> 00:32:00,720
directory function there's a whole bunch

00:31:59,010 --> 00:32:03,870
of flags you can pass to load library

00:32:00,720 --> 00:32:06,150
e^x Windows Store and Windows universal

00:32:03,870 --> 00:32:08,250
applications are totally different in

00:32:06,150 --> 00:32:10,799
how they work I'm not going to talk

00:32:08,250 --> 00:32:11,940
about all of those I list them here so

00:32:10,799 --> 00:32:13,590
that you know if you're curious about

00:32:11,940 --> 00:32:15,240
them like all of those you can search

00:32:13,590 --> 00:32:16,130
for them and find more information about

00:32:15,240 --> 00:32:18,750
them

00:32:16,130 --> 00:32:20,130
alright so the loader has found the dll

00:32:18,750 --> 00:32:21,960
it's looking for in our case it was easy

00:32:20,130 --> 00:32:24,600
it was just right next to the XE we were

00:32:21,960 --> 00:32:27,270
running but it now needs to map that DLL

00:32:24,600 --> 00:32:28,650
into memory so it's gonna open up the

00:32:27,270 --> 00:32:30,179
DLL and it's going to look at the header

00:32:28,650 --> 00:32:34,260
and it's going to say excellent hello

00:32:30,179 --> 00:32:37,260
dot DLL occupies 3000 or well hex 3000

00:32:34,260 --> 00:32:38,790
it's basically 12000 bytes in memory so

00:32:37,260 --> 00:32:42,600
I'm just going to you know copy the

00:32:38,790 --> 00:32:46,650
whole file into memory but hello DLL is

00:32:42,600 --> 00:32:50,030
only 2048 bytes and the reason for this

00:32:46,650 --> 00:32:53,130
is the DLL actually has different

00:32:50,030 --> 00:32:56,070
alignment in the file where it has hex

00:32:53,130 --> 00:32:58,679
200 byte alignment and in memory where

00:32:56,070 --> 00:33:02,460
it has hex 1000 byte alignment so a

00:32:58,679 --> 00:33:03,929
memory it has to has have 4096 by 2

00:33:02,460 --> 00:33:07,320
lineman because that's the size of a

00:33:03,929 --> 00:33:09,210
page and as we saw previously so we in

00:33:07,320 --> 00:33:10,679
our hello DLL we have a text section we

00:33:09,210 --> 00:33:12,059
have an our data section and they have

00:33:10,679 --> 00:33:14,669
to have different protections right the

00:33:12,059 --> 00:33:16,380
text section needs to be have execute

00:33:14,669 --> 00:33:17,370
privileges whereas the our data section

00:33:16,380 --> 00:33:18,510
you don't want to have execute

00:33:17,370 --> 00:33:21,300
privileges so

00:33:18,510 --> 00:33:25,140
each section has to be aligned to a page

00:33:21,300 --> 00:33:27,900
boundary in memory in the file though it

00:33:25,140 --> 00:33:29,850
uses 512 byte alignment and the reason

00:33:27,900 --> 00:33:31,050
is that's the fat sector size so back

00:33:29,850 --> 00:33:32,580
when this was designed that was the

00:33:31,050 --> 00:33:34,470
default you can actually change that

00:33:32,580 --> 00:33:36,210
there's a linker option to change the

00:33:34,470 --> 00:33:38,760
alignment so you could make it smaller

00:33:36,210 --> 00:33:42,180
if you wanted but the default is

00:33:38,760 --> 00:33:43,790
probably fine for most purposes so

00:33:42,180 --> 00:33:45,660
sections have to be page line in memory

00:33:43,790 --> 00:33:47,610
this is what I was saying previously

00:33:45,660 --> 00:33:49,380
that the text section has different

00:33:47,610 --> 00:33:50,640
permissions on it than the our data

00:33:49,380 --> 00:33:52,190
section so they have to be on different

00:33:50,640 --> 00:33:53,850
pages

00:33:52,190 --> 00:33:55,380
additionally we don't actually need to

00:33:53,850 --> 00:33:57,150
store everything in the file so for

00:33:55,380 --> 00:33:59,340
example let's say I have a version of

00:33:57,150 --> 00:34:01,400
our hello DLL called hello buffer and

00:33:59,340 --> 00:34:06,210
I've just thrown an extra 1 megabyte

00:34:01,400 --> 00:34:09,870
global buffer inside of that DLL well

00:34:06,210 --> 00:34:15,180
the the DLL file is still only 2048

00:34:09,870 --> 00:34:17,490
bytes in size if we look in the headers

00:34:15,180 --> 00:34:19,050
we actually end up seeing that ok the

00:34:17,490 --> 00:34:20,370
DLL does have a larger image size so

00:34:19,050 --> 00:34:21,810
when it gets mapped into memory it does

00:34:20,370 --> 00:34:24,090
have that extra megabyte that it's going

00:34:21,810 --> 00:34:25,710
to take up but then if we look in the

00:34:24,090 --> 00:34:27,840
data section we see that the size of the

00:34:25,710 --> 00:34:29,310
raw data is 0 because again this is

00:34:27,840 --> 00:34:31,110
going to be 0 initialized so the default

00:34:29,310 --> 00:34:32,940
0 the initialization that the loader is

00:34:31,110 --> 00:34:34,530
going to do of these pages is sufficient

00:34:32,940 --> 00:34:36,300
we don't actually need to put any data

00:34:34,530 --> 00:34:38,310
in the file for this so there's you know

00:34:36,300 --> 00:34:39,690
some benefit here that anything that 0

00:34:38,310 --> 00:34:43,530
initialize we don't need a whole bunch

00:34:39,690 --> 00:34:44,940
of zeros inside of our file so to map

00:34:43,530 --> 00:34:46,800
the DLL in the memory basically the

00:34:44,940 --> 00:34:48,330
loader needs to open the DLL file and

00:34:46,800 --> 00:34:50,730
figure out what the image size is where

00:34:48,330 --> 00:34:52,770
all of the sections are located it needs

00:34:50,730 --> 00:34:55,440
to allocate a contiguous page aligned

00:34:52,770 --> 00:34:56,970
block of memory of that size so all of

00:34:55,440 --> 00:34:58,590
these pages do have to be allocated

00:34:56,970 --> 00:35:00,530
contiguously otherwise the relative

00:34:58,590 --> 00:35:02,820
virtual addresses don't work correctly

00:35:00,530 --> 00:35:04,350
and it has to copy the contents of each

00:35:02,820 --> 00:35:06,480
section into the appropriate area of

00:35:04,350 --> 00:35:08,430
that block of memory later it will set

00:35:06,480 --> 00:35:11,010
the appropriate page protections on each

00:35:08,430 --> 00:35:12,360
page in the map DLL before it does that

00:35:11,010 --> 00:35:16,620
there's a couple more things it has to

00:35:12,360 --> 00:35:21,090
do so next up it has to do relocation

00:35:16,620 --> 00:35:23,310
potentially so let's say we have another

00:35:21,090 --> 00:35:25,170
little dll we're going to write and in

00:35:23,310 --> 00:35:27,540
it we've got two global variables and

00:35:25,170 --> 00:35:29,340
I've exported them just so that we can

00:35:27,540 --> 00:35:32,410
get their addresses very easily and in

00:35:29,340 --> 00:35:34,600
the next slides so first we've got a

00:35:32,410 --> 00:35:37,060
global variable name - which is just an

00:35:34,600 --> 00:35:38,920
integer but the value - and then we have

00:35:37,060 --> 00:35:44,010
a global pointer variable that just

00:35:38,920 --> 00:35:46,900
holds the address of that and we link it

00:35:44,010 --> 00:35:48,490
so how do these look in the DLL well we

00:35:46,900 --> 00:35:50,230
can look at the exports again this is

00:35:48,490 --> 00:35:52,450
why I exported them and we can see that

00:35:50,230 --> 00:35:55,440
- is it our V a 1000 and the pointer is

00:35:52,450 --> 00:35:59,140
at our VA 1008 and so if we look at the

00:35:55,440 --> 00:36:02,620
at the our data section we can see okay

00:35:59,140 --> 00:36:06,600
- is it our VA 1000 and pointer to - is

00:36:02,620 --> 00:36:09,310
at our VA 1008 and you can see that the

00:36:06,600 --> 00:36:11,380
pointer - actually contains the actual

00:36:09,310 --> 00:36:13,210
pointer we're expecting to find it at so

00:36:11,380 --> 00:36:15,670
it's assuming that the DLL is located in

00:36:13,210 --> 00:36:17,890
its preferred base address so this is

00:36:15,670 --> 00:36:19,300
only going to work if pointer global dll

00:36:17,890 --> 00:36:21,250
gets loaded at that preferred base

00:36:19,300 --> 00:36:24,280
address if it gets loaded at say you

00:36:21,250 --> 00:36:25,690
know ninety million hex then this won't

00:36:24,280 --> 00:36:28,450
work like that pointer will be pointing

00:36:25,690 --> 00:36:31,420
somewhere completely wrong so what we do

00:36:28,450 --> 00:36:33,730
is we use well the DLL file has what are

00:36:31,420 --> 00:36:35,260
called relocations and the relocations

00:36:33,730 --> 00:36:36,730
are basically a table of all of the

00:36:35,260 --> 00:36:38,890
pointers in the dll that need to be

00:36:36,730 --> 00:36:41,590
fixed up if the DLL is loaded somewhere

00:36:38,890 --> 00:36:42,970
other than its preferred base address so

00:36:41,590 --> 00:36:45,490
it's actually just a very simple table

00:36:42,970 --> 00:36:47,920
so if you can run dump in relocations to

00:36:45,490 --> 00:36:49,600
get the list of them and basically we

00:36:47,920 --> 00:36:51,370
have one here and it just says that

00:36:49,600 --> 00:36:53,410
there is a pointer located eight bytes

00:36:51,370 --> 00:36:56,980
from the start of the section beginning

00:36:53,410 --> 00:36:59,650
at our VA 1000 and the reason you get

00:36:56,980 --> 00:37:01,720
this kind of weird output is that the

00:36:59,650 --> 00:37:02,800
table is very compact so they don't

00:37:01,720 --> 00:37:04,720
actually store the r-va

00:37:02,800 --> 00:37:07,720
all of the data all together in one

00:37:04,720 --> 00:37:09,130
place in the dll and what the loader

00:37:07,720 --> 00:37:11,050
will do is will just update each pointer

00:37:09,130 --> 00:37:12,580
listed in the relocation table by

00:37:11,050 --> 00:37:15,130
subtracting the preferred base address

00:37:12,580 --> 00:37:16,630
and adding the actual base address so

00:37:15,130 --> 00:37:17,290
for example here it'll take the original

00:37:16,630 --> 00:37:19,240
pointer

00:37:17,290 --> 00:37:20,980
it'll subtract the prefer base address

00:37:19,240 --> 00:37:22,450
add to the actual base address it was

00:37:20,980 --> 00:37:24,520
loaded we're assuming it's loaded at

00:37:22,450 --> 00:37:26,170
that address and that gives us the new

00:37:24,520 --> 00:37:28,990
pointer value which the loader will just

00:37:26,170 --> 00:37:30,900
write into that location in memory the

00:37:28,990 --> 00:37:33,220
reason that the pointer contains the

00:37:30,900 --> 00:37:34,750
like the address it would have if the

00:37:33,220 --> 00:37:36,550
DLL is loaded at the preferred base

00:37:34,750 --> 00:37:40,420
address like instead of just having say

00:37:36,550 --> 00:37:42,520
the r-va to start off with is because a

00:37:40,420 --> 00:37:44,170
long time ago DLL is would have

00:37:42,520 --> 00:37:46,180
generated the loader would try to load

00:37:44,170 --> 00:37:48,040
dll's at their preferred base address so

00:37:46,180 --> 00:37:49,540
like if that address was available it

00:37:48,040 --> 00:37:51,400
would try to load the deal out there and

00:37:49,540 --> 00:37:52,900
it would only fall back to relocating if

00:37:51,400 --> 00:37:55,960
it absolutely had to so basically it was

00:37:52,900 --> 00:37:58,360
more efficient to do that nowadays

00:37:55,960 --> 00:38:00,820
though there's a feature called asler

00:37:58,360 --> 00:38:02,440
address space layout randomization where

00:38:00,820 --> 00:38:04,420
basically the loader will always try and

00:38:02,440 --> 00:38:06,580
load the DLL at some other locations so

00:38:04,420 --> 00:38:08,350
that attackers can't you know predict

00:38:06,580 --> 00:38:10,510
where the see library is and you know

00:38:08,350 --> 00:38:16,450
use see library functionality to produce

00:38:10,510 --> 00:38:18,250
exploits all right so now that we've

00:38:16,450 --> 00:38:20,320
relocated the DLL all the pointers are

00:38:18,250 --> 00:38:24,340
patched up we now need to load all of

00:38:20,320 --> 00:38:25,690
the dependencies and bind any imports so

00:38:24,340 --> 00:38:28,150
if we look at the imports in our Hello

00:38:25,690 --> 00:38:29,890
DLL we see it doesn't have any so that's

00:38:28,150 --> 00:38:32,470
all right we can't use hello DLL for

00:38:29,890 --> 00:38:34,120
this part so let's add a new function to

00:38:32,470 --> 00:38:36,190
hello dot DLL that will give us a

00:38:34,120 --> 00:38:38,460
dependency so we already had our get

00:38:36,190 --> 00:38:41,410
greeting function that returns a a

00:38:38,460 --> 00:38:42,880
narrow string we can just add I get a

00:38:41,410 --> 00:38:44,650
wide greeting function that takes a

00:38:42,880 --> 00:38:46,810
buffer and it copies that into a wide

00:38:44,650 --> 00:38:48,370
character buffer instead and I've done

00:38:46,810 --> 00:38:49,780
this because then we can call multibyte

00:38:48,370 --> 00:38:53,860
too wide care which we would have to

00:38:49,780 --> 00:38:55,870
import from kernel32 so when we link it

00:38:53,860 --> 00:38:58,150
we now just add the new export to the

00:38:55,870 --> 00:39:00,280
command line we add kernel32 live so it

00:38:58,150 --> 00:39:02,860
links in you know the import for that

00:39:00,280 --> 00:39:04,630
function that we're now calling we look

00:39:02,860 --> 00:39:06,340
at it X at its exports we see yes we've

00:39:04,630 --> 00:39:07,690
got both functions and we look at it

00:39:06,340 --> 00:39:11,020
imports and we see yes now we're

00:39:07,690 --> 00:39:12,400
importing multi-byte to wide care so

00:39:11,020 --> 00:39:13,720
this is for exposition and I just

00:39:12,400 --> 00:39:15,970
thought it was easier to show as you

00:39:13,720 --> 00:39:18,010
know fake pseudocode basically the

00:39:15,970 --> 00:39:21,010
loader is going to loop over all of the

00:39:18,010 --> 00:39:22,720
dll dependencies it's going to load each

00:39:21,010 --> 00:39:24,430
dependency so it's gonna in this case

00:39:22,720 --> 00:39:26,350
we've only got one so it's going to go

00:39:24,430 --> 00:39:28,780
and load kernel32 which will probably

00:39:26,350 --> 00:39:30,430
already be loaded in the process if that

00:39:28,780 --> 00:39:32,110
fails it'll return failure so it'll

00:39:30,430 --> 00:39:34,900
actually fail to load your DLL as well

00:39:32,110 --> 00:39:36,730
and then for each function that gets

00:39:34,900 --> 00:39:38,560
imported it calls get proc address to go

00:39:36,730 --> 00:39:40,000
and get the actual procedure now the

00:39:38,560 --> 00:39:41,560
loader internally doesn't actually call

00:39:40,000 --> 00:39:43,600
load library or get proc address but

00:39:41,560 --> 00:39:45,910
this is conceptually the exactly what

00:39:43,600 --> 00:39:49,000
the loader is going to do so or in

00:39:45,910 --> 00:39:50,710
English basically the the loader is

00:39:49,000 --> 00:39:52,210
going to load each DLL that we are

00:39:50,710 --> 00:39:53,740
dependent on and then get all the

00:39:52,210 --> 00:39:56,050
required exports that it can fill in

00:39:53,740 --> 00:39:59,800
those imp variables those function

00:39:56,050 --> 00:40:02,140
pointers all right at this point

00:39:59,800 --> 00:40:04,990
the DLL is basically loaded almost ready

00:40:02,140 --> 00:40:06,850
for use the loader now gives the DLL the

00:40:04,990 --> 00:40:08,020
opportunity to initialize itself if it

00:40:06,850 --> 00:40:09,310
needs to and it does this through an

00:40:08,020 --> 00:40:11,290
entry point which is conventionally

00:40:09,310 --> 00:40:12,670
called DLL main so DLL main is a

00:40:11,290 --> 00:40:14,470
function that you implement in your

00:40:12,670 --> 00:40:17,410
program and it's like the C main

00:40:14,470 --> 00:40:18,940
function but you know for dll's so it

00:40:17,410 --> 00:40:22,000
takes three parameters the instance is a

00:40:18,940 --> 00:40:23,440
hint is your actual DLL handle so it's

00:40:22,000 --> 00:40:25,030
the same one that will be returned from

00:40:23,440 --> 00:40:26,800
load library with someone floating you

00:40:25,030 --> 00:40:28,690
that way

00:40:26,800 --> 00:40:29,800
the reason indicates why the functions

00:40:28,690 --> 00:40:31,750
being called so there's four different

00:40:29,800 --> 00:40:33,820
times when the loader calls this

00:40:31,750 --> 00:40:35,830
function it calls it on process attached

00:40:33,820 --> 00:40:37,510
which is when the DLL gets loaded it

00:40:35,830 --> 00:40:40,330
calls it on process detach which is when

00:40:37,510 --> 00:40:42,400
the the DLL gets unloaded and that calls

00:40:40,330 --> 00:40:43,900
it on thread attached and thread detach

00:40:42,400 --> 00:40:46,720
which or when a thread starts or stops

00:40:43,900 --> 00:40:47,800
running within the process then the

00:40:46,720 --> 00:40:50,110
reserved parameter just gives a little

00:40:47,800 --> 00:40:52,030
extra information for some of those and

00:40:50,110 --> 00:40:54,190
then you get the opportunity to return

00:40:52,030 --> 00:40:55,960
true on success or false on failure if

00:40:54,190 --> 00:41:00,160
you return false than your DLL fails to

00:40:55,960 --> 00:41:01,990
load finally calls the DLL main are

00:41:00,160 --> 00:41:04,869
synchronized by a global lock called a

00:41:01,990 --> 00:41:07,450
loader lock so basically only one thread

00:41:04,869 --> 00:41:08,580
can be initializing a DLL at any one

00:41:07,450 --> 00:41:12,310
time

00:41:08,580 --> 00:41:14,980
not all dll's have an entry point so for

00:41:12,310 --> 00:41:16,480
example our hello program when we built

00:41:14,980 --> 00:41:19,900
when we linked it we said no entry I

00:41:16,480 --> 00:41:21,160
don't want an entry point and then if we

00:41:19,900 --> 00:41:22,660
look at the headers there we saw there's

00:41:21,160 --> 00:41:24,070
a null pointer for the entry point so

00:41:22,660 --> 00:41:25,090
there's you know there's no entry so the

00:41:24,070 --> 00:41:26,080
basically the loader will see that and

00:41:25,090 --> 00:41:27,310
I'll say all right you don't need to be

00:41:26,080 --> 00:41:31,750
initialized I don't need to do anything

00:41:27,310 --> 00:41:35,500
special so let's build a little DLL with

00:41:31,750 --> 00:41:38,740
an entry point here I have just a simple

00:41:35,500 --> 00:41:40,690
DLL main function that just prints out a

00:41:38,740 --> 00:41:42,700
message when prot when it gets called

00:41:40,690 --> 00:41:45,400
for process attach or process detach and

00:41:42,700 --> 00:41:47,260
then returns true and so when we compile

00:41:45,400 --> 00:41:49,540
that we basically instead of passing no

00:41:47,260 --> 00:41:51,190
entry we pass slash entry with the entry

00:41:49,540 --> 00:41:58,210
point that we want the the loader to

00:41:51,190 --> 00:42:01,540
call so we write a little test program

00:41:58,210 --> 00:42:03,250
to demonstrate it so here basically we

00:42:01,540 --> 00:42:05,590
just print out I'm about to load the DLL

00:42:03,250 --> 00:42:07,300
I load it I then say alright I've loaded

00:42:05,590 --> 00:42:09,100
the DLL I'm about to unload it I call

00:42:07,300 --> 00:42:11,320
free library and then I print out all

00:42:09,100 --> 00:42:13,580
right I've unloaded it we link that and

00:42:11,320 --> 00:42:14,750
then we run it we should see

00:42:13,580 --> 00:42:17,390
all right we're in the main function

00:42:14,750 --> 00:42:19,610
about to load the DLL we're now we've

00:42:17,390 --> 00:42:21,170
now we're now loading the DLL so we're

00:42:19,610 --> 00:42:23,870
in DLL main for the process attached

00:42:21,170 --> 00:42:25,160
which it prints out correctly we're back

00:42:23,870 --> 00:42:27,710
in the main function of the DLL has

00:42:25,160 --> 00:42:29,210
completed loading the DLL main gets

00:42:27,710 --> 00:42:30,590
called again when we call free library

00:42:29,210 --> 00:42:33,230
because it's going to free the DLL and

00:42:30,590 --> 00:42:37,010
and unload it and then we're back in

00:42:33,230 --> 00:42:38,510
main at the end of the program so if you

00:42:37,010 --> 00:42:39,470
right entry points you do have to be

00:42:38,510 --> 00:42:42,020
extremely careful

00:42:39,470 --> 00:42:43,700
so MSDN has an article on dynamic link

00:42:42,020 --> 00:42:45,500
library best practices the short version

00:42:43,700 --> 00:42:46,820
is do as little as possible as you have

00:42:45,500 --> 00:42:48,920
to you know when your deal all gets

00:42:46,820 --> 00:42:50,540
loaded be very careful when calling into

00:42:48,920 --> 00:42:51,920
other dll's from the entry point because

00:42:50,540 --> 00:42:54,740
they may not have been initialized

00:42:51,920 --> 00:42:55,790
themselves and do not synchronize with

00:42:54,740 --> 00:42:58,430
other threads from your entry point

00:42:55,790 --> 00:42:59,930
because again the entry point is called

00:42:58,430 --> 00:43:02,450
but the loader lock held and so you

00:42:59,930 --> 00:43:04,760
often end up with dead locks if you try

00:43:02,450 --> 00:43:06,710
synchronizing with other threads in

00:43:04,760 --> 00:43:08,150
general in c n c++ programs you won't

00:43:06,710 --> 00:43:09,410
specify your own entry point we'll look

00:43:08,150 --> 00:43:13,940
at this in a little bit when we discuss

00:43:09,410 --> 00:43:16,130
c++ specific things but instead you'll

00:43:13,940 --> 00:43:18,140
let the C runtime provide the entry

00:43:16,130 --> 00:43:21,770
point and you can define DLL with DLL

00:43:18,140 --> 00:43:23,780
main which it will call alright

00:43:21,770 --> 00:43:26,150
so that's what it has to do in order to

00:43:23,780 --> 00:43:27,980
load a DLL but what happens if something

00:43:26,150 --> 00:43:29,570
fails something doesn't work correctly

00:43:27,980 --> 00:43:31,610
how do you diagnose what went wrong

00:43:29,570 --> 00:43:33,260
right so load library is just going to

00:43:31,610 --> 00:43:34,760
return a null pointer and an it and a

00:43:33,260 --> 00:43:37,100
status code like how do you get more

00:43:34,760 --> 00:43:38,180
information so I know this talk is early

00:43:37,100 --> 00:43:39,500
in the morning if you've fallen asleep

00:43:38,180 --> 00:43:41,180
now it would be a good time to wake up

00:43:39,500 --> 00:43:43,340
because this is the most important thing

00:43:41,180 --> 00:43:44,870
I'm going to share with you today I know

00:43:43,340 --> 00:43:46,310
a lot of people don't know about this

00:43:44,870 --> 00:43:50,420
but it makes debugging this sort of

00:43:46,310 --> 00:43:52,490
things so easy so what I'm going to do

00:43:50,420 --> 00:43:54,170
is I'm going to delete hello DLL so that

00:43:52,490 --> 00:43:56,180
when we run our print greeting program

00:43:54,170 --> 00:43:58,220
oh well it doesn't print anything out

00:43:56,180 --> 00:44:00,140
and if we look at the error level it's

00:43:58,220 --> 00:44:01,790
that happens to be the code for an

00:44:00,140 --> 00:44:03,590
access violation and the reason for that

00:44:01,790 --> 00:44:04,880
is well it failed to load the DLL and we

00:44:03,590 --> 00:44:07,190
didn't have any error programming in our

00:44:04,880 --> 00:44:09,020
test program so it's just everything's

00:44:07,190 --> 00:44:11,660
failed so how do we find out what went

00:44:09,020 --> 00:44:14,210
wrong what we're going to do is the

00:44:11,660 --> 00:44:16,580
windows debugger package comes with this

00:44:14,210 --> 00:44:18,470
tool called G Flags so we're going to

00:44:16,580 --> 00:44:22,360
run G Flags and we're going to say that

00:44:18,470 --> 00:44:24,710
when our program runs show loader snaps

00:44:22,360 --> 00:44:27,040
so that if we open our program in the

00:44:24,710 --> 00:44:27,040
debugger

00:44:27,210 --> 00:44:31,050
basically the loader is going to print

00:44:29,069 --> 00:44:32,640
out lots of information basically all of

00:44:31,050 --> 00:44:34,319
the things that loader is doing so when

00:44:32,640 --> 00:44:36,030
it starts up its going to say hey I've

00:44:34,319 --> 00:44:37,589
just started you know running this

00:44:36,030 --> 00:44:40,890
process so it's gonna just give you a

00:44:37,589 --> 00:44:42,270
little information so here's what it's

00:44:40,890 --> 00:44:44,609
going to print when it tries to load

00:44:42,270 --> 00:44:46,050
hello DLL which is going to fail so it

00:44:44,609 --> 00:44:48,930
says all right I've started I'm trying

00:44:46,050 --> 00:44:50,730
to load hello DLL I see I'm going to see

00:44:48,930 --> 00:44:52,800
if it's an own DLL it says nope it's not

00:44:50,730 --> 00:44:54,180
a known DLL that's not it so then it

00:44:52,800 --> 00:44:55,500
starts trying to search the search path

00:44:54,180 --> 00:44:56,849
and it actually tells you the set of

00:44:55,500 --> 00:44:59,010
paths that it's going to try and search

00:44:56,849 --> 00:45:00,059
for this DLL you'll notice this matches

00:44:59,010 --> 00:45:01,800
that search order that we were looking

00:45:00,059 --> 00:45:03,720
at earlier it's the DLL you know which

00:45:01,800 --> 00:45:05,550
our program is it's the system 32

00:45:03,720 --> 00:45:07,650
directory the system directory the

00:45:05,550 --> 00:45:10,589
windows directory and so on until it

00:45:07,650 --> 00:45:11,819
gets to my path then it's going to try

00:45:10,589 --> 00:45:13,829
each of those so it's gonna say alright

00:45:11,819 --> 00:45:15,780
can I load a hello dot DLL nope that

00:45:13,829 --> 00:45:18,210
failed can I load system 32 hello dot

00:45:15,780 --> 00:45:19,890
DLL nope that failed and so on until it

00:45:18,210 --> 00:45:22,079
gets to the end see this will actually

00:45:19,890 --> 00:45:23,880
tell you every step that the loader is

00:45:22,079 --> 00:45:25,140
going to try and do to load this DLL for

00:45:23,880 --> 00:45:27,510
you so you can kind of see what went

00:45:25,140 --> 00:45:30,180
wrong right you can see oh the DLL you

00:45:27,510 --> 00:45:31,799
know it wasn't in the right location or

00:45:30,180 --> 00:45:33,930
I've got you know my paths configured

00:45:31,799 --> 00:45:36,119
incorrectly whatever this tells you

00:45:33,930 --> 00:45:37,290
exactly what the loader did did and you

00:45:36,119 --> 00:45:40,200
can compare that against what you were

00:45:37,290 --> 00:45:42,780
expecting it to do and and figure out

00:45:40,200 --> 00:45:44,520
what went wrong similarly if we were to

00:45:42,780 --> 00:45:47,040
relink our hello program and we were to

00:45:44,520 --> 00:45:50,160
remove the export and then call get proc

00:45:47,040 --> 00:45:51,750
address to try and get that export it'll

00:45:50,160 --> 00:45:53,250
print out a little warning that says

00:45:51,750 --> 00:45:54,930
well when you tried to call get proc

00:45:53,250 --> 00:45:57,240
address it wasn't there so this is how

00:45:54,930 --> 00:46:00,270
you can determine if a load fails

00:45:57,240 --> 00:46:02,160
because you were depending on an export

00:46:00,270 --> 00:46:04,130
that doesn't exist for some reason this

00:46:02,160 --> 00:46:06,240
will tell you which exports were missing

00:46:04,130 --> 00:46:09,059
and then when you're done you just need

00:46:06,240 --> 00:46:12,569
to run G flags again with - s LS instead

00:46:09,059 --> 00:46:13,950
of plus SL has to turn it off again now

00:46:12,569 --> 00:46:15,030
you're probably thinking oh cool this is

00:46:13,950 --> 00:46:16,500
a great reason to use the windows

00:46:15,030 --> 00:46:18,119
debuggers and since I work on the

00:46:16,500 --> 00:46:19,589
debuggers team I'd like to say that but

00:46:18,119 --> 00:46:21,359
this actually works with any debugger

00:46:19,589 --> 00:46:22,950
you have to run the G Flags program

00:46:21,359 --> 00:46:24,450
separately but then like in Visual

00:46:22,950 --> 00:46:26,670
Studio the output will show up there as

00:46:24,450 --> 00:46:31,650
well I just basically the loader uses

00:46:26,670 --> 00:46:34,380
output D BOTS debug string alright

00:46:31,650 --> 00:46:37,079
another little feature there is inside

00:46:34,380 --> 00:46:39,030
of a so we've already seen deckle spec

00:46:37,079 --> 00:46:41,100
DLL export which you can use inside of a

00:46:39,030 --> 00:46:43,470
source file so that the link

00:46:41,100 --> 00:46:46,170
I'll just you know implicitly export

00:46:43,470 --> 00:46:48,110
this you know this is so I don't have to

00:46:46,170 --> 00:46:50,340
pass / export or things like that

00:46:48,110 --> 00:46:52,170
there's also a deal out import so you

00:46:50,340 --> 00:46:56,730
use this inside of programs that use a

00:46:52,170 --> 00:46:58,340
DLL so what does this do so first I'll

00:46:56,730 --> 00:47:01,050
look at a program that calls these

00:46:58,340 --> 00:47:03,900
imports without using deco spec DLL

00:47:01,050 --> 00:47:05,700
import so here's just a simple program

00:47:03,900 --> 00:47:09,270
our main function calls get one there's

00:47:05,700 --> 00:47:12,660
no DLL import we link this program with

00:47:09,270 --> 00:47:15,510
the import library if we look at what

00:47:12,660 --> 00:47:17,010
the main function ends up doing it's

00:47:15,510 --> 00:47:18,330
just a call get one because it thinks

00:47:17,010 --> 00:47:20,460
alright this is just a function I need

00:47:18,330 --> 00:47:26,010
to call and then get one just jumps

00:47:20,460 --> 00:47:28,020
through that function pointer so then if

00:47:26,010 --> 00:47:30,690
we use DLL import it does things a

00:47:28,020 --> 00:47:32,850
little differently basically this tells

00:47:30,690 --> 00:47:35,370
the compiler this function is going to

00:47:32,850 --> 00:47:36,540
be imported so the compiler knows when

00:47:35,370 --> 00:47:38,400
it's generating code for the main

00:47:36,540 --> 00:47:39,720
function it can just do they call the

00:47:38,400 --> 00:47:43,470
indirect call directly there it can

00:47:39,720 --> 00:47:45,510
avoid that extra thunk through the the

00:47:43,470 --> 00:47:47,730
get one function stub that it had in

00:47:45,510 --> 00:47:49,260
that binary you might think alright this

00:47:47,730 --> 00:47:52,440
is a great idea like we should totally

00:47:49,260 --> 00:47:53,630
definitely be using DLL import today if

00:47:52,440 --> 00:47:56,520
you're using whole program optimization

00:47:53,630 --> 00:47:57,930
or link time code generation the linker

00:47:56,520 --> 00:47:59,340
can see right through all of this and so

00:47:57,930 --> 00:48:00,900
it will actually do this optimization

00:47:59,340 --> 00:48:03,030
for you even if you don't have the

00:48:00,900 --> 00:48:05,100
deckle spec DLL import so it's not

00:48:03,030 --> 00:48:06,420
entirely necessary today obviously in

00:48:05,100 --> 00:48:08,790
unoptimized builds or if you're not

00:48:06,420 --> 00:48:11,180
using a link time code generation this

00:48:08,790 --> 00:48:13,290
would still be beneficial but it's not

00:48:11,180 --> 00:48:14,760
it's not really necessary if you're

00:48:13,290 --> 00:48:17,340
actually using all the optimizations you

00:48:14,760 --> 00:48:19,890
should be using so we've seen exporting

00:48:17,340 --> 00:48:21,360
functions you can also export data so

00:48:19,890 --> 00:48:24,840
here instead of exporting get one and

00:48:21,360 --> 00:48:26,520
get two we can export variables named

00:48:24,840 --> 00:48:29,850
one and two and to do that you use

00:48:26,520 --> 00:48:31,290
exactly the same methods that we did for

00:48:29,850 --> 00:48:33,330
exporting functions except you should

00:48:31,290 --> 00:48:34,770
add comma data after it or in the DEF

00:48:33,330 --> 00:48:39,090
file I think there's just no comma you

00:48:34,770 --> 00:48:41,190
just say data and then if we dump in

00:48:39,090 --> 00:48:44,760
exports we see great we can see there

00:48:41,190 --> 00:48:46,650
are V A's which point as we'd expect to

00:48:44,760 --> 00:48:51,000
oh well there's a one and there's a two

00:48:46,650 --> 00:48:54,270
inside of our DLL and if we want to

00:48:51,000 --> 00:48:56,070
write a program that uses these so use

00:48:54,270 --> 00:48:59,250
constants we can see we just declare the

00:48:56,070 --> 00:49:01,650
variables we compile it and oh it

00:48:59,250 --> 00:49:04,620
doesn't link hmm that's interesting so

00:49:01,650 --> 00:49:06,720
for for when you import data you

00:49:04,620 --> 00:49:10,260
actually have to use deco spec to yellow

00:49:06,720 --> 00:49:11,700
import and the reason is that the the

00:49:10,260 --> 00:49:13,050
variables aren't exported directly they

00:49:11,700 --> 00:49:15,060
have to be exported by address the

00:49:13,050 --> 00:49:16,680
export table only knows about addresses

00:49:15,060 --> 00:49:19,170
it doesn't know you know what an INT is

00:49:16,680 --> 00:49:21,240
so it actually when you export an int it

00:49:19,170 --> 00:49:23,310
actually the what's in the export table

00:49:21,240 --> 00:49:25,170
is the address of that integer so you

00:49:23,310 --> 00:49:28,050
know if we were actually able to bind

00:49:25,170 --> 00:49:29,160
the name 1 to that address like the

00:49:28,050 --> 00:49:31,910
types wouldn't match you would think

00:49:29,160 --> 00:49:35,310
that that pointer is the integer and

00:49:31,910 --> 00:49:40,200
then we can see we can use it 1 is 1 2

00:49:35,310 --> 00:49:42,870
is 2 you can also get get data exports

00:49:40,200 --> 00:49:44,310
using get proc address but note that

00:49:42,870 --> 00:49:45,870
again this was what I was saying

00:49:44,310 --> 00:49:51,090
previously the export is an encounter

00:49:45,870 --> 00:49:53,880
it's not an int anyway that all works

00:49:51,090 --> 00:49:58,620
just the same you can also delay load

00:49:53,880 --> 00:50:00,210
dll's so here if we have our DLL with

00:49:58,620 --> 00:50:02,400
the entry point again this is again it

00:50:00,210 --> 00:50:06,690
just prints out when it gets called for

00:50:02,400 --> 00:50:08,370
process attach and detach I'm running

00:50:06,690 --> 00:50:10,200
out of time so I'm going to flip through

00:50:08,370 --> 00:50:14,310
this a little quickly actually I'm just

00:50:10,200 --> 00:50:17,130
going to skip this section and get to

00:50:14,310 --> 00:50:18,120
C++ and DLL so the CP pecan I figured I

00:50:17,130 --> 00:50:21,930
should probably talk a little bit about

00:50:18,120 --> 00:50:24,480
C++ in dll's so first off you can have

00:50:21,930 --> 00:50:33,480
global variables global c++ variables in

00:50:24,480 --> 00:50:37,410
dll's but you have to use the default

00:50:33,480 --> 00:50:40,020
entry point so basically you have to the

00:50:37,410 --> 00:50:42,060
CRT provides this entry point named DLL

00:50:40,020 --> 00:50:43,530
main CRT start up if you provide your

00:50:42,060 --> 00:50:45,930
own DLL main it will call that

00:50:43,530 --> 00:50:46,950
automatically but the CRT entry point

00:50:45,930 --> 00:50:48,420
does a bunch of other things that are

00:50:46,950 --> 00:50:52,230
necessary in order to do C and C++

00:50:48,420 --> 00:50:53,940
inside of your DLL so during process

00:50:52,230 --> 00:50:56,220
attach it'll if you've statically linked

00:50:53,940 --> 00:50:57,780
the CRT it'll go and initialize that ID

00:50:56,220 --> 00:50:59,370
initializes the security cookie and

00:50:57,780 --> 00:51:01,380
other runtime check support it runs

00:50:59,370 --> 00:51:02,970
constructors for global variables it

00:51:01,380 --> 00:51:05,100
initializes add eggs that support within

00:51:02,970 --> 00:51:07,620
the DLL and then I'll call your DLL main

00:51:05,100 --> 00:51:08,130
finally during process detach it calls

00:51:07,620 --> 00:51:09,900
add eggs

00:51:08,130 --> 00:51:12,780
registered functions it runs destructors

00:51:09,900 --> 00:51:15,060
for global variables and it'll shut down

00:51:12,780 --> 00:51:17,940
the CRT if necessary and it also calls

00:51:15,060 --> 00:51:20,760
your DLL main therefore process detach I

00:51:17,940 --> 00:51:22,890
do want to note so because all of this

00:51:20,760 --> 00:51:24,750
is done inside of the entry point all of

00:51:22,890 --> 00:51:26,940
the rules that I mentioned for

00:51:24,750 --> 00:51:28,590
implementing your own DLL main also

00:51:26,940 --> 00:51:30,990
apply to any global variables that have

00:51:28,590 --> 00:51:33,210
constructors inside of your DLL so you

00:51:30,990 --> 00:51:34,650
know you can't synchronize from within a

00:51:33,210 --> 00:51:36,390
constructor of a global variable in a

00:51:34,650 --> 00:51:37,620
DLL because you'll end up dead locking

00:51:36,390 --> 00:51:40,560
or you'll probably end up dead locking

00:51:37,620 --> 00:51:43,770
with the loader lock you can also export

00:51:40,560 --> 00:51:45,630
C++ functions so here's a little example

00:51:43,770 --> 00:51:47,700
we can have to add functions one that

00:51:45,630 --> 00:51:49,050
takes insulin takes doubles we can link

00:51:47,700 --> 00:51:50,790
it and we look at the exports and we get

00:51:49,050 --> 00:51:52,650
two of them I don't know how to do

00:51:50,790 --> 00:51:55,620
mangle those in my head so one of them

00:51:52,650 --> 00:51:57,690
is one the other is the other you can

00:51:55,620 --> 00:52:00,420
export C++ classes so here we've got a

00:51:57,690 --> 00:52:02,910
class with a couple member functions we

00:52:00,420 --> 00:52:04,710
can link it and of course classes like

00:52:02,910 --> 00:52:06,300
aren't things that exist you know in the

00:52:04,710 --> 00:52:07,530
DLL all you actually have are all of the

00:52:06,300 --> 00:52:09,270
member functions that operate on the

00:52:07,530 --> 00:52:11,130
class so when you export a class that

00:52:09,270 --> 00:52:12,540
actually exports all of the member

00:52:11,130 --> 00:52:14,010
functions for it so here we've got the

00:52:12,540 --> 00:52:15,840
get value an increment that our class

00:52:14,010 --> 00:52:17,880
has we have the two constructors that

00:52:15,840 --> 00:52:19,350
our class has and the compiler has gone

00:52:17,880 --> 00:52:21,150
ahead for us and actually generated the

00:52:19,350 --> 00:52:23,280
copy and move constructor for us and

00:52:21,150 --> 00:52:26,420
exported those so I have some advice for

00:52:23,280 --> 00:52:29,310
exporting C++ functions in classes don't

00:52:26,420 --> 00:52:31,350
so on Windows there's no standard C++

00:52:29,310 --> 00:52:33,390
ABI so you're very dependent on the

00:52:31,350 --> 00:52:35,070
compiler there's no guarantee that if

00:52:33,390 --> 00:52:36,720
you throw an exception from one DLL and

00:52:35,070 --> 00:52:38,340
you catch it somewhere else that it's

00:52:36,720 --> 00:52:41,030
you know it's guaranteed to work unless

00:52:38,340 --> 00:52:42,930
you're using the same runtime library

00:52:41,030 --> 00:52:44,190
basically when you're exporting things

00:52:42,930 --> 00:52:46,230
from a DLL you really want to make sure

00:52:44,190 --> 00:52:49,500
you're using you know a very stable ABI

00:52:46,230 --> 00:52:50,790
like C or calm or WinRT the three that

00:52:49,500 --> 00:52:54,870
are you know very well defined on

00:52:50,790 --> 00:52:58,470
Windows so dll's can have threads and

00:52:54,870 --> 00:53:02,010
thread local storage I'm not going to

00:52:58,470 --> 00:53:05,250
have time for that and actually I think

00:53:02,010 --> 00:53:08,100
I'm just going to get to the end so that

00:53:05,250 --> 00:53:09,420
we can take a few questions so if you

00:53:08,100 --> 00:53:11,880
want to come to the microphone so I'll

00:53:09,420 --> 00:53:14,300
be happy to answer any questions but no

00:53:11,880 --> 00:53:14,300
heckling

00:53:19,860 --> 00:53:26,260
yes hi um I just like to know is there

00:53:23,080 --> 00:53:29,950
wish to prevent reading string rituals

00:53:26,260 --> 00:53:32,050
when you peek into yellow from pardon

00:53:29,950 --> 00:53:34,900
so string rituals define your code

00:53:32,050 --> 00:53:36,370
pretty much dumped into DL as is and

00:53:34,900 --> 00:53:42,910
it's readable when you peek into them

00:53:36,370 --> 00:53:44,560
can you avoid that so obfuscation is so

00:53:42,910 --> 00:53:48,940
there are tools to obfuscate like

00:53:44,560 --> 00:53:49,660
obfuscated code inside of dll's I like

00:53:48,940 --> 00:53:51,580
this there's a whole bunch of

00:53:49,660 --> 00:53:53,290
third-party tools that can do that that

00:53:51,580 --> 00:53:54,700
will try and hide you know what what is

00:53:53,290 --> 00:53:56,350
actually going on under the cover like

00:53:54,700 --> 00:53:57,790
it'll go and you know move code around

00:53:56,350 --> 00:54:00,340
and make it very difficult you know just

00:53:57,790 --> 00:54:01,600
to disassemble it but I mean at the end

00:54:00,340 --> 00:54:04,390
of the day if the machines going to

00:54:01,600 --> 00:54:08,710
execute it like it's got to be there in

00:54:04,390 --> 00:54:11,080
some form okay so yes hello I have a

00:54:08,710 --> 00:54:12,970
question is there any mechanism that

00:54:11,080 --> 00:54:15,250
different process can share the text

00:54:12,970 --> 00:54:17,050
segment from a DLL or that the data

00:54:15,250 --> 00:54:20,530
segment is shared like copy and write

00:54:17,050 --> 00:54:22,630
like in system 5 yes yeah so the

00:54:20,530 --> 00:54:23,320
question well I guess everyone heard the

00:54:22,630 --> 00:54:26,560
question because we're at the

00:54:23,320 --> 00:54:27,730
microphones um so yes if so what I said

00:54:26,560 --> 00:54:30,460
previously was that the loader will

00:54:27,730 --> 00:54:32,800
attempt to with address space layout

00:54:30,460 --> 00:54:34,870
randomization it will try and load each

00:54:32,800 --> 00:54:37,180
DLL at a different base address and you

00:54:34,870 --> 00:54:38,920
know each time the program's run that's

00:54:37,180 --> 00:54:40,840
actually not entirely true it will try

00:54:38,920 --> 00:54:42,670
and use a random base address but it

00:54:40,840 --> 00:54:44,860
will try to like for any given DLL like

00:54:42,670 --> 00:54:46,600
our hello DLL it will try to load it at

00:54:44,860 --> 00:54:49,060
the same base address in every process

00:54:46,600 --> 00:54:50,890
so that any read-only data and any text

00:54:49,060 --> 00:54:53,910
pages can be shared between the

00:54:50,890 --> 00:54:56,110
processes so you use you end up using a

00:54:53,910 --> 00:54:57,910
you know virtual address space in your

00:54:56,110 --> 00:54:59,470
process but actual system memory like

00:54:57,910 --> 00:55:01,450
that can all be shared and that's very

00:54:59,470 --> 00:55:03,370
critical for things like kernel 32 which

00:55:01,450 --> 00:55:05,140
is going to be loaded into 200 processes

00:55:03,370 --> 00:55:08,740
we don't want 200 copies of that sitting

00:55:05,140 --> 00:55:10,900
in memory additionally any writable

00:55:08,740 --> 00:55:14,140
pages are marked copy-on-write

00:55:10,900 --> 00:55:15,490
so basically DLLs will share them until

00:55:14,140 --> 00:55:17,530
the first time they try to write to it

00:55:15,490 --> 00:55:18,880
at which point the page gets copied and

00:55:17,530 --> 00:55:20,020
all that happens behind the scenes in

00:55:18,880 --> 00:55:21,820
the memory manager so you don't actually

00:55:20,020 --> 00:55:25,540
have to worry about that in your own

00:55:21,820 --> 00:55:27,100
code so it's just it's only possible if

00:55:25,540 --> 00:55:28,520
they're not reloaded to on different

00:55:27,100 --> 00:55:30,470
address they have to be in

00:55:28,520 --> 00:55:32,810
same address right I'm right yeah so the

00:55:30,470 --> 00:55:34,250
loader does try it's best to put it at

00:55:32,810 --> 00:55:36,440
the same address plate it's not puzzled

00:55:34,250 --> 00:55:37,400
in that case he do then it'll it'll load

00:55:36,440 --> 00:55:42,890
it at a different address in that

00:55:37,400 --> 00:55:45,140
process okay thanks hmm okay hi so if

00:55:42,890 --> 00:55:48,380
you were writing a library would you

00:55:45,140 --> 00:55:50,030
recommend using dll export or avoiding

00:55:48,380 --> 00:55:51,380
it yeah

00:55:50,030 --> 00:55:54,020
so if I was writing a library would I

00:55:51,380 --> 00:55:55,850
recommend using dll export I my

00:55:54,020 --> 00:55:57,470
preferred approach is to use the module

00:55:55,850 --> 00:56:00,410
definition file and the reason for that

00:55:57,470 --> 00:56:02,480
is that you actually have like one place

00:56:00,410 --> 00:56:04,820
where your entire public contract of

00:56:02,480 --> 00:56:07,700
your dll is defined right so you have

00:56:04,820 --> 00:56:09,170
one place you know it's very easy to

00:56:07,700 --> 00:56:11,210
make sure that you aren't accidentally

00:56:09,170 --> 00:56:12,560
losing exports so like let's say that

00:56:11,210 --> 00:56:14,420
you have some things that are marked DL

00:56:12,560 --> 00:56:15,770
export and you accidentally stopped

00:56:14,420 --> 00:56:17,270
compiling that far or maybe you've

00:56:15,770 --> 00:56:19,700
purposefully stopped compiling that file

00:56:17,270 --> 00:56:21,260
into your dll you probably just lost all

00:56:19,700 --> 00:56:22,820
of those exports from your dll as well

00:56:21,260 --> 00:56:27,680
so you've made a breaking change to your

00:56:22,820 --> 00:56:28,490
dll so the the def file makes sure that

00:56:27,680 --> 00:56:30,170
that won't happen

00:56:28,490 --> 00:56:31,340
because again if those symbols aren't

00:56:30,170 --> 00:56:34,010
there you'll actually get a link error

00:56:31,340 --> 00:56:35,090
it'll say you've removed this symbol so

00:56:34,010 --> 00:56:37,520
basically if you want to maintain a

00:56:35,090 --> 00:56:39,280
stable contract for your dll using the

00:56:37,520 --> 00:56:42,380
def file is probably the safest approach

00:56:39,280 --> 00:56:46,250
yeah I was I was also thinking static

00:56:42,380 --> 00:56:49,000
linking versus dll linking so if you if

00:56:46,250 --> 00:56:52,670
you don't use dll export you're avoiding

00:56:49,000 --> 00:56:56,540
mismatches yes so specifically for the C

00:56:52,670 --> 00:56:58,670
runtime we it marks functions as DLL

00:56:56,540 --> 00:57:01,280
import in its header if you're using the

00:56:58,670 --> 00:57:03,560
the DLL runtime and so if you have

00:57:01,280 --> 00:57:06,590
shared static libraries that use that

00:57:03,560 --> 00:57:07,970
functionality basically static libraries

00:57:06,590 --> 00:57:09,860
have to be recompiled with different

00:57:07,970 --> 00:57:12,200
flavors of the C runtime in order to

00:57:09,860 --> 00:57:15,950
link correctly which is a big hassle

00:57:12,200 --> 00:57:17,720
yeah hi James

00:57:15,950 --> 00:57:20,000
as you may know I'm a bit concerned

00:57:17,720 --> 00:57:21,170
about portability and my question is do

00:57:20,000 --> 00:57:25,270
you think the standard should be

00:57:21,170 --> 00:57:27,530
something about about loading and

00:57:25,270 --> 00:57:29,540
finding stuff into shell libraries

00:57:27,530 --> 00:57:32,990
because you know when you try to do that

00:57:29,540 --> 00:57:37,340
on UNIX and then on Windows it gets very

00:57:32,990 --> 00:57:38,630
messy very quick yes so my aunt well yes

00:57:37,340 --> 00:57:40,130
I do have an opinion on that and the

00:57:38,630 --> 00:57:41,930
answer is no I don't think the standard

00:57:40,130 --> 00:57:42,180
should standardize that because it's

00:57:41,930 --> 00:57:43,800
come

00:57:42,180 --> 00:57:46,440
lately different on Linux and windows I

00:57:43,800 --> 00:57:48,060
mean like the yes they both have shared

00:57:46,440 --> 00:57:49,710
libraries they both contain code and

00:57:48,060 --> 00:57:51,510
data that you can share but the way that

00:57:49,710 --> 00:57:53,280
they work the way that their their

00:57:51,510 --> 00:57:55,200
contracts are defined for your libraries

00:57:53,280 --> 00:57:56,970
the way that you know lifetime is

00:57:55,200 --> 00:57:58,380
handled the way that at exit and

00:57:56,970 --> 00:57:59,610
Global's are handled like they're all

00:57:58,380 --> 00:58:01,920
completely different and so

00:57:59,610 --> 00:58:03,900
standardizing that I I think it's just

00:58:01,920 --> 00:58:05,790
too late like I mean we can't go and

00:58:03,900 --> 00:58:07,710
change how Windows does it because I

00:58:05,790 --> 00:58:09,360
mean we've got 30 years of software you

00:58:07,710 --> 00:58:11,430
know doing it one way we can't go and

00:58:09,360 --> 00:58:14,100
change how POSIX does it because I mean

00:58:11,430 --> 00:58:15,390
again the same thing so yeah I don't I

00:58:14,100 --> 00:58:17,520
don't really see any benefit of

00:58:15,390 --> 00:58:20,340
standardizing that like I see

00:58:17,520 --> 00:58:21,870
opportunity for libraries to help you

00:58:20,340 --> 00:58:24,240
know paper over the differences you know

00:58:21,870 --> 00:58:29,010
our C++ libraries but I don't think

00:58:24,240 --> 00:58:31,170
that's a good fit for the standard hi

00:58:29,010 --> 00:58:32,850
I'm so I have a question about the one

00:58:31,170 --> 00:58:35,490
part you skipped over and the labeling

00:58:32,850 --> 00:58:37,010
we are using it quite extensively and I

00:58:35,490 --> 00:58:40,440
was wondering what's the rationale

00:58:37,010 --> 00:58:42,120
behind deciding that it's not going to

00:58:40,440 --> 00:58:48,600
be automatic on loaded when you unload

00:58:42,120 --> 00:58:50,040
the deal that the label is something yes

00:58:48,600 --> 00:58:51,240
that I actually don't know the answer to

00:58:50,040 --> 00:58:53,760
that question but if you come chat with

00:58:51,240 --> 00:58:57,240
me afterwards I can help find it okay

00:58:53,760 --> 00:58:58,620
thanks yeah you skipped really fast over

00:58:57,240 --> 00:59:00,480
two parts that I'm interested in but I

00:58:58,620 --> 00:59:01,770
will only ask about one it okay can you

00:59:00,480 --> 00:59:04,770
just repeat what happens if I've got a

00:59:01,770 --> 00:59:07,470
global variable and I initialize it and

00:59:04,770 --> 00:59:09,780
the the constructor or whatever it is is

00:59:07,470 --> 00:59:11,550
calling something from a DLL is that a

00:59:09,780 --> 00:59:14,820
deadlock or what happens is it fix it

00:59:11,550 --> 00:59:17,340
for me it it depends so if some things

00:59:14,820 --> 00:59:19,110
are safe to call so for example a lot of

00:59:17,340 --> 00:59:21,030
the exports from kernel32 to do

00:59:19,110 --> 00:59:22,290
initialization of like synchronization

00:59:21,030 --> 00:59:24,810
primitives things like that are safe

00:59:22,290 --> 00:59:26,790
many of the C runtime api's are safe to

00:59:24,810 --> 00:59:30,450
call you just have to be extremely

00:59:26,790 --> 00:59:32,880
careful because you know if another

00:59:30,450 --> 00:59:34,530
program calls something that holds you

00:59:32,880 --> 00:59:36,780
know this lock that you might depend on

00:59:34,530 --> 00:59:38,700
and then that in turn you know tries to

00:59:36,780 --> 00:59:40,290
load a library and then you know

00:59:38,700 --> 00:59:41,790
basically you can end up with lock order

00:59:40,290 --> 00:59:43,530
and versioning very easily so you just

00:59:41,790 --> 00:59:45,360
have to be very careful with what you

00:59:43,530 --> 00:59:47,310
end up importing like if it's if there

00:59:45,360 --> 00:59:48,810
are things from or what you end up using

00:59:47,310 --> 00:59:50,700
as global variables so if it's things

00:59:48,810 --> 00:59:52,560
from your own code like maybe you know

00:59:50,700 --> 00:59:53,730
that something will be safe but if it's

00:59:52,560 --> 00:59:55,800
not from your own code

00:59:53,730 --> 00:59:58,619
you know you have to use extra care so I

00:59:55,800 --> 01:00:00,300
know for Windows basically there's a

00:59:58,619 --> 01:00:01,950
small set of functions from kernel32

01:00:00,300 --> 01:00:03,690
that are guaranteed to be safe and then

01:00:01,950 --> 01:00:06,420
we try it we say try not to call

01:00:03,690 --> 01:00:08,250
anything else okay so even if I if I'm

01:00:06,420 --> 01:00:10,320
not doing anything weird with with these

01:00:08,250 --> 01:00:13,650
load library X but even if I just stick

01:00:10,320 --> 01:00:17,869
to the standard C++ DLL import I can

01:00:13,650 --> 01:00:21,990
still end up in a deadlock yeah yep

01:00:17,869 --> 01:00:24,390
yes hi could you please elaborate on

01:00:21,990 --> 01:00:27,510
your advice not to export classes from

01:00:24,390 --> 01:00:30,180
details because this is what hundreds

01:00:27,510 --> 01:00:32,580
and hundreds of software projects are

01:00:30,180 --> 01:00:36,930
doing and it's very very surprising to

01:00:32,580 --> 01:00:38,970
learn that it's not advice yeah so it's

01:00:36,930 --> 01:00:41,040
left to be the last question and then I

01:00:38,970 --> 01:00:44,340
can take more questions afterward so the

01:00:41,040 --> 01:00:47,130
so basically the C++ ABI on Windows is

01:00:44,340 --> 01:00:48,780
not it's not well it's not basically

01:00:47,130 --> 01:00:50,850
it's not specified right so the compiler

01:00:48,780 --> 01:00:52,859
does what it does and each major release

01:00:50,850 --> 01:00:54,119
of the compiler they may make breaking

01:00:52,859 --> 01:00:55,740
changes so I know there's been an object

01:00:54,119 --> 01:00:57,600
layout changes in some versions of the

01:00:55,740 --> 01:00:59,640
compiler that's been named may I there

01:00:57,600 --> 01:01:01,109
may have been name mangling changes I

01:00:59,640 --> 01:01:02,160
don't know if there's any developer on

01:01:01,109 --> 01:01:03,600
the compiler here but I don't want to

01:01:02,160 --> 01:01:05,369
say something fall so basically any

01:01:03,600 --> 01:01:09,660
major release they can change that and

01:01:05,369 --> 01:01:11,700
so it's okay to export C++ things from a

01:01:09,660 --> 01:01:13,410
DLL like if it's just your one

01:01:11,700 --> 01:01:15,720
application package that is going to end

01:01:13,410 --> 01:01:17,609
up using it right so like if if you are

01:01:15,720 --> 01:01:19,650
using DLL solely for componentization

01:01:17,609 --> 01:01:22,500
with the in your application it's

01:01:19,650 --> 01:01:23,910
probably fine you know to use c++ across

01:01:22,500 --> 01:01:25,380
the boundary as long as you make sure

01:01:23,910 --> 01:01:26,670
you're always recompiling everything

01:01:25,380 --> 01:01:29,070
with the same toolset with the same

01:01:26,670 --> 01:01:30,630
options you know to pass things across

01:01:29,070 --> 01:01:32,760
if you're trying to build a reusable

01:01:30,630 --> 01:01:34,500
component so something that you know a

01:01:32,760 --> 01:01:37,500
library that someone might use in their

01:01:34,500 --> 01:01:39,810
own application if you use C++ across

01:01:37,500 --> 01:01:41,640
that boundary you basically need to make

01:01:39,810 --> 01:01:43,590
sure that whatever options you use to

01:01:41,640 --> 01:01:45,060
build your DLL they're using also on

01:01:43,590 --> 01:01:46,890
their side so you you might have to

01:01:45,060 --> 01:01:49,380
distribute you know many versions of

01:01:46,890 --> 01:01:51,000
your dll's for different versions of the

01:01:49,380 --> 01:01:54,330
toolset you might have to deliver

01:01:51,000 --> 01:01:56,790
different versions for different compile

01:01:54,330 --> 01:01:58,230
options so the standard library has a

01:01:56,790 --> 01:02:00,210
different layout for different types

01:01:58,230 --> 01:02:01,770
under different under some options so

01:02:00,210 --> 01:02:03,990
debug and release don't have the same

01:02:01,770 --> 01:02:05,700
layout for all types so as long as you

01:02:03,990 --> 01:02:07,559
control like the full set of things that

01:02:05,700 --> 01:02:08,880
are you know exporting the C++

01:02:07,559 --> 01:02:13,619
sports and then importing them on the

01:02:08,880 --> 01:02:15,959
other side it's it's safer but if you if

01:02:13,619 --> 01:02:17,309
you have like reusable components you

01:02:15,959 --> 01:02:21,569
definitely want to use you know some

01:02:17,309 --> 01:02:23,400
kind of stable ABI all right well thank

01:02:21,569 --> 01:02:26,050
you all for coming again I'm happy to

01:02:23,400 --> 01:02:29,069
take questions I'll be here all week

01:02:26,050 --> 01:02:29,069

YouTube URL: https://www.youtube.com/watch?v=JPQWQfDhICA


