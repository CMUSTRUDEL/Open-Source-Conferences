Title: Template Metaprogramming: Type Traits (part 2 of 2) - Jody Hagins - CppCon 2020
Publication date: 2020-09-22
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/template_metaprogramming_type_traits/template_metaprogramming_type_traits__jody_hagins__cppcon_2020.pdf

Watch Part 1: https://youtu.be/tiAVWcjIF6o
---
PART 2/2 - This talk experienced some latency issues, but the slides and audio are mostly unaffected.

Template metaprogramming is a vast subject, but there are a small number of basic fundamental idioms that are used over and over. Mastery of these idioms will help in reading, writing, and using modern C++ code. The type traits that come as part of the standard library are incredibly useful, but at times can be thought of as some form of dark magic.

In this tutorial, we will explore some of the fundamental idioms of template metaprogramming by implementing a good portion of the type traits from the standard library. In so doing, attendees will come away with a solid understanding of how to apply the fundamental template metaprogramming idioms to solve problems including, but not limited to, standard type traits.

---
Jody Hagins first compiled "C++" code in 1984, and wrote a specialized LisP editor using Zortech C++ for senior project in 1988. However, he didn't truly start programming in C++ until 1992, when he read The Greatest C++ Book Ever Written, "Advanced C++ Programming Styles and Idioms" by Jim Coplien. That book, combined with cfront, which generated C code from C++ source, gave him the joyful task of writing SVr4 Streams drivers in C++. Ever since, he has been hooked on writing C++ code for kernel modules, large telephony applications, and, since the late 1990s, applications in what is now known as the high frequency trading industry.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,400 --> 00:00:13,440
all right well welcome back to uh part

00:00:12,320 --> 00:00:15,519
two of uh

00:00:13,440 --> 00:00:17,840
template meta programming with type

00:00:15,519 --> 00:00:19,760
traits uh

00:00:17,840 --> 00:00:21,680
we'll uh resume where we left off last

00:00:19,760 --> 00:00:24,400
time um

00:00:21,680 --> 00:00:24,800
and uh i'm gonna make sure i oops get my

00:00:24,400 --> 00:00:28,000
questions

00:00:24,800 --> 00:00:29,599
i forgot to do that um

00:00:28,000 --> 00:00:31,039
so we'll resume where we left off last

00:00:29,599 --> 00:00:34,160
time with and talk about

00:00:31,039 --> 00:00:36,399
primary type categories um so

00:00:34,160 --> 00:00:37,440
there's 14 primary type categories and

00:00:36,399 --> 00:00:38,719
they're on this screen i'm not going to

00:00:37,440 --> 00:00:41,280
read them all

00:00:38,719 --> 00:00:45,840
but all except null pointer were

00:00:41,280 --> 00:00:49,200
introduced in 2011 no pointer was 2014.

00:00:45,840 --> 00:00:52,000
and these primary type traits

00:00:49,200 --> 00:00:53,280
all have uh to have a base

00:00:52,000 --> 00:00:55,520
characteristic of either

00:00:53,280 --> 00:00:57,280
true type or false type that's fancy

00:00:55,520 --> 00:00:59,520
words just meaning they have to inherit

00:00:57,280 --> 00:01:02,559
from either true type or false type

00:00:59,520 --> 00:01:05,360
um and uh you know all of them

00:01:02,559 --> 00:01:06,080
should yield the same result in light of

00:01:05,360 --> 00:01:07,840
cv

00:01:06,080 --> 00:01:09,200
qualifiers we discussed that at the

00:01:07,840 --> 00:01:11,280
beginning of last session

00:01:09,200 --> 00:01:14,159
but in case you're just coming to this

00:01:11,280 --> 00:01:16,159
one the cv qualifiers are the const

00:01:14,159 --> 00:01:18,560
and volatile qualifiers that attach to a

00:01:16,159 --> 00:01:21,600
type and so whenever you call

00:01:18,560 --> 00:01:23,920
uh is void or is integral with a type if

00:01:21,600 --> 00:01:25,520
you call is integral with int

00:01:23,920 --> 00:01:27,759
that statement is saying that you have

00:01:25,520 --> 00:01:31,040
to have the same result for int

00:01:27,759 --> 00:01:33,680
it const int volatile and const volatile

00:01:31,040 --> 00:01:34,240
that the cv qualifiers should all return

00:01:33,680 --> 00:01:37,520
the same

00:01:34,240 --> 00:01:40,720
the same type for these traits and for

00:01:37,520 --> 00:01:42,320
any given type t exactly one of the

00:01:40,720 --> 00:01:44,159
primary type categories

00:01:42,320 --> 00:01:45,680
shall yield true type now this has

00:01:44,159 --> 00:01:49,200
several implications

00:01:45,680 --> 00:01:51,840
um one it means that if by chance you

00:01:49,200 --> 00:01:53,200
can't implement one of them then you can

00:01:51,840 --> 00:01:55,680
implement it by

00:01:53,200 --> 00:01:57,119
just checking to see if it's not any of

00:01:55,680 --> 00:02:00,479
all the other 13.

00:01:57,119 --> 00:02:02,399
um the other implications are that

00:02:00,479 --> 00:02:04,240
remember i said you should not the

00:02:02,399 --> 00:02:06,320
standard says that you can't

00:02:04,240 --> 00:02:08,000
over um provide your own specializations

00:02:06,320 --> 00:02:10,160
or you're going to understand behavior

00:02:08,000 --> 00:02:12,160
and especially if you like say oh i've

00:02:10,160 --> 00:02:13,920
got my own class and it acts like an

00:02:12,160 --> 00:02:14,640
integral or it acts like a pointer so

00:02:13,920 --> 00:02:16,720
i'm going to

00:02:14,640 --> 00:02:17,920
say that it returns true for its pointer

00:02:16,720 --> 00:02:19,440
well now it's going to return true for

00:02:17,920 --> 00:02:21,520
its class and this pointer

00:02:19,440 --> 00:02:23,200
or true for is class and as integral and

00:02:21,520 --> 00:02:24,640
you can bet that somebody somewhere

00:02:23,200 --> 00:02:26,800
they're counting on the fact that the

00:02:24,640 --> 00:02:28,000
standard says that every type can only

00:02:26,800 --> 00:02:29,920
belong to one of these

00:02:28,000 --> 00:02:31,440
and something is going to break at some

00:02:29,920 --> 00:02:33,120
point in time and it's probably going to

00:02:31,440 --> 00:02:36,160
be when you least expect it

00:02:33,120 --> 00:02:38,319
don't do those kinds of things so

00:02:36,160 --> 00:02:39,440
um let's a reminder we've already seen

00:02:38,319 --> 00:02:41,200
is void in the first

00:02:39,440 --> 00:02:42,480
in the first section and is void is the

00:02:41,200 --> 00:02:45,840
first one on our list

00:02:42,480 --> 00:02:49,519
so let's just take a quick look at it um

00:02:45,840 --> 00:02:53,280
we have a uh explicit specialization

00:02:49,519 --> 00:02:53,280
for each of the four types here

00:02:53,760 --> 00:02:58,560
we have the primary template

00:02:57,519 --> 00:02:59,840
and i'll review this a little bit

00:02:58,560 --> 00:03:01,360
because we went over it a lot last time

00:02:59,840 --> 00:03:03,440
but some people maybe do

00:03:01,360 --> 00:03:04,959
the primary template and then we have an

00:03:03,440 --> 00:03:07,920
explicit specialization

00:03:04,959 --> 00:03:09,519
for void for void cons for void volatile

00:03:07,920 --> 00:03:11,200
and for void const volatile

00:03:09,519 --> 00:03:13,040
so we've got an explicit specialization

00:03:11,200 --> 00:03:15,280
for all of those cb qualifiers

00:03:13,040 --> 00:03:16,560
so now every one of them will return the

00:03:15,280 --> 00:03:18,239
same type

00:03:16,560 --> 00:03:20,400
whether they have to avoid qualifier or

00:03:18,239 --> 00:03:20,400
not

00:03:20,959 --> 00:03:27,120
um so the next one is is null pointer

00:03:24,959 --> 00:03:27,120
now

00:03:28,480 --> 00:03:32,159
okay this doesn't really look much

00:03:31,120 --> 00:03:35,599
different from

00:03:32,159 --> 00:03:37,280
is void why are we looking at this

00:03:35,599 --> 00:03:38,879
well you're kind of right it doesn't

00:03:37,280 --> 00:03:40,879
look much different in fact

00:03:38,879 --> 00:03:42,239
if you look at the red the red box

00:03:40,879 --> 00:03:44,000
around the top

00:03:42,239 --> 00:03:45,120
of is no pointer that's our primary

00:03:44,000 --> 00:03:46,560
template and then we have our

00:03:45,120 --> 00:03:49,120
specializations

00:03:46,560 --> 00:03:49,840
and those specializations look very very

00:03:49,120 --> 00:03:53,360
similar

00:03:49,840 --> 00:03:55,439
um now normally my spidey sense

00:03:53,360 --> 00:03:56,959
would start tingling about now saying we

00:03:55,439 --> 00:04:00,319
need something more

00:03:56,959 --> 00:04:01,519
since we're doing this twice um it's not

00:04:00,319 --> 00:04:02,879
that much code but

00:04:01,519 --> 00:04:04,799
i'm starting to worry about this a

00:04:02,879 --> 00:04:06,319
little bit um

00:04:04,799 --> 00:04:08,959
so let's look at the next one is

00:04:06,319 --> 00:04:13,599
floating point we've got float

00:04:08,959 --> 00:04:17,519
we've got double we've got long double

00:04:13,599 --> 00:04:20,959
and now this requires 12 specializations

00:04:17,519 --> 00:04:22,400
um you know this is starting to be a

00:04:20,959 --> 00:04:26,000
combinatorial explosion

00:04:22,400 --> 00:04:27,600
so hold on to your pants here look

00:04:26,000 --> 00:04:29,199
all right so there's our his floating

00:04:27,600 --> 00:04:31,680
point um

00:04:29,199 --> 00:04:32,240
if that doesn't scream to you that we

00:04:31,680 --> 00:04:35,440
need

00:04:32,240 --> 00:04:39,600
something better then

00:04:35,440 --> 00:04:41,520
yeah okay well maybe just just wait um

00:04:39,600 --> 00:04:43,440
you know if this were regular

00:04:41,520 --> 00:04:45,280
programming doing regular functions we

00:04:43,440 --> 00:04:47,120
probably would have already refactored

00:04:45,280 --> 00:04:49,040
and abstracted things out to make it

00:04:47,120 --> 00:04:50,720
easier um

00:04:49,040 --> 00:04:53,680
but you know this is template meta

00:04:50,720 --> 00:04:55,680
programming it's supposed to be painful

00:04:53,680 --> 00:04:57,360
so we're just gonna endure well that's

00:04:55,680 --> 00:04:58,400
not really true that's that's not how we

00:04:57,360 --> 00:05:01,680
should look at it

00:04:58,400 --> 00:05:03,680
um but i will say that these

00:05:01,680 --> 00:05:05,440
specializations like this are probably

00:05:03,680 --> 00:05:07,600
the fastest way of implementing it

00:05:05,440 --> 00:05:08,639
not typing speed of course but from the

00:05:07,600 --> 00:05:10,240
compiler standpoint

00:05:08,639 --> 00:05:12,160
when the compiler in the compilation

00:05:10,240 --> 00:05:13,280
time you'll notice as you start doing

00:05:12,160 --> 00:05:15,120
more of this programming

00:05:13,280 --> 00:05:17,120
that your compiler takes more and more

00:05:15,120 --> 00:05:18,240
and more time and the compiler speed is

00:05:17,120 --> 00:05:19,680
going to be important

00:05:18,240 --> 00:05:21,360
but if you're doing things like that

00:05:19,680 --> 00:05:23,440
require super high performance you're

00:05:21,360 --> 00:05:26,479
very glad to trade those things off

00:05:23,440 --> 00:05:28,560
but this doesn't look good um

00:05:26,479 --> 00:05:29,600
and uh okay so it's painful it doesn't

00:05:28,560 --> 00:05:31,919
look very good

00:05:29,600 --> 00:05:33,919
what about is integral there's five

00:05:31,919 --> 00:05:38,479
standard signed integer types

00:05:33,919 --> 00:05:40,400
sign char short long long long

00:05:38,479 --> 00:05:42,080
there's implementation defined extended

00:05:40,400 --> 00:05:45,520
signed integer types like

00:05:42,080 --> 00:05:47,280
uh gcc and clang support 64-bit integers

00:05:45,520 --> 00:05:50,240
on some platforms and

00:05:47,280 --> 00:05:51,919
there are corresponding but different

00:05:50,240 --> 00:05:52,960
unsigned integer types for each one of

00:05:51,919 --> 00:05:55,520
those

00:05:52,960 --> 00:05:56,560
and there's all these chart types

00:05:55,520 --> 00:05:59,600
there's char and

00:05:56,560 --> 00:06:02,400
char 8t which is new in 20. chart 16

00:05:59,600 --> 00:06:03,600
chart 32 and wr and then finally there's

00:06:02,400 --> 00:06:06,400
pool

00:06:03,600 --> 00:06:07,199
so this is going to require 16 times

00:06:06,400 --> 00:06:09,440
four

00:06:07,199 --> 00:06:10,639
specializations because there's the

00:06:09,440 --> 00:06:12,800
without cons

00:06:10,639 --> 00:06:14,000
const volatile and con swallow we're

00:06:12,800 --> 00:06:14,960
gonna have to specialize that for every

00:06:14,000 --> 00:06:18,080
one of them

00:06:14,960 --> 00:06:20,160
so thank goodness for vim macros

00:06:18,080 --> 00:06:21,520
so them macros to the rescue and there's

00:06:20,160 --> 00:06:25,919
our code right there

00:06:21,520 --> 00:06:27,600
all nice and neat and let's move on

00:06:25,919 --> 00:06:28,960
you know what that just doesn't i don't

00:06:27,600 --> 00:06:31,039
i don't like this

00:06:28,960 --> 00:06:32,840
this is we're begging for something else

00:06:31,039 --> 00:06:34,319
we're begging for meta function

00:06:32,840 --> 00:06:36,479
abstractions now

00:06:34,319 --> 00:06:38,720
it shouldn't be that hard to understand

00:06:36,479 --> 00:06:40,000
the idea of meta function abstractions

00:06:38,720 --> 00:06:42,160
but because meta functions

00:06:40,000 --> 00:06:43,280
might be new to most of us uh that's

00:06:42,160 --> 00:06:44,960
what this is kind of a beginner

00:06:43,280 --> 00:06:47,440
intermediate class

00:06:44,960 --> 00:06:48,720
then you know maybe you don't really

00:06:47,440 --> 00:06:51,759
understand what that means

00:06:48,720 --> 00:06:54,639
too much and i can know i can relate

00:06:51,759 --> 00:06:55,120
you know you know we've reached for this

00:06:54,639 --> 00:06:57,120
technique

00:06:55,120 --> 00:06:58,240
long long time ago in regular normal

00:06:57,120 --> 00:07:00,319
programming

00:06:58,240 --> 00:07:02,000
my encouragement to you as you do more

00:07:00,319 --> 00:07:04,639
of these meta programming is treat it

00:07:02,000 --> 00:07:06,319
like regular programming because well

00:07:04,639 --> 00:07:08,000
that's really what it is

00:07:06,319 --> 00:07:09,680
it is regular programming especially

00:07:08,000 --> 00:07:10,560
nowadays and all with all the type

00:07:09,680 --> 00:07:13,039
system

00:07:10,560 --> 00:07:13,680
so we're going to look at how to how to

00:07:13,039 --> 00:07:18,000
take

00:07:13,680 --> 00:07:18,000
some meta programming abstractions um

00:07:18,080 --> 00:07:25,120
uh so leading to template templates

00:07:21,680 --> 00:07:29,280
well yeah

00:07:25,120 --> 00:07:31,039
okay so step back to the land of regular

00:07:29,280 --> 00:07:32,560
functions all right so

00:07:31,039 --> 00:07:34,080
we've been talking about regular funk

00:07:32,560 --> 00:07:35,360
doing meta function abstractions we're

00:07:34,080 --> 00:07:37,039
talking about regular functions

00:07:35,360 --> 00:07:38,560
so we're going to step back again and

00:07:37,039 --> 00:07:40,960
reseat ourselves

00:07:38,560 --> 00:07:42,319
pretend that we need to implement these

00:07:40,960 --> 00:07:44,160
same ideas with strings

00:07:42,319 --> 00:07:46,560
instead of types we're going to

00:07:44,160 --> 00:07:49,280
implement this in a very similar way

00:07:46,560 --> 00:07:50,400
there you go there's this void compare

00:07:49,280 --> 00:07:51,360
the string against every one of the

00:07:50,400 --> 00:07:52,960
possibilities

00:07:51,360 --> 00:07:53,919
and there's is no pointer compare the

00:07:52,960 --> 00:07:55,120
string against every one of the

00:07:53,919 --> 00:07:57,039
possibilities

00:07:55,120 --> 00:07:58,080
and there's this floating point compare

00:07:57,039 --> 00:07:59,280
the string against every one of the

00:07:58,080 --> 00:08:01,919
possibilities

00:07:59,280 --> 00:08:02,800
so that's what you did and you know year

00:08:01,919 --> 00:08:04,479
and

00:08:02,800 --> 00:08:06,000
take you wrote it i mean you've got

00:08:04,479 --> 00:08:06,800
tests and you submit this for code

00:08:06,000 --> 00:08:08,319
review

00:08:06,800 --> 00:08:10,319
so you submit this code for your code

00:08:08,319 --> 00:08:13,680
review and your code review

00:08:10,319 --> 00:08:16,240
comments start coming in

00:08:13,680 --> 00:08:18,160
and uh yeah so probably not too many

00:08:16,240 --> 00:08:20,879
people are happy with that code

00:08:18,160 --> 00:08:22,879
um you know and while we remember that

00:08:20,879 --> 00:08:25,280
specialization is going to have our

00:08:22,879 --> 00:08:26,560
best issues that's probably not going to

00:08:25,280 --> 00:08:29,280
be the case in this code

00:08:26,560 --> 00:08:29,680
and if that code would not pass muster

00:08:29,280 --> 00:08:32,479
in

00:08:29,680 --> 00:08:33,839
regular doing regular code then those

00:08:32,479 --> 00:08:34,560
techniques are probably not going to

00:08:33,839 --> 00:08:37,360
pass muster

00:08:34,560 --> 00:08:38,959
in meta programming now we have to use

00:08:37,360 --> 00:08:40,320
different techniques to figure out what

00:08:38,959 --> 00:08:42,640
we're going to do

00:08:40,320 --> 00:08:43,440
but we still should apply the same rules

00:08:42,640 --> 00:08:46,320
of what

00:08:43,440 --> 00:08:48,640
is good and what is not so let's get rid

00:08:46,320 --> 00:08:48,640
of this

00:08:48,720 --> 00:08:51,360
so let's take a step in the right

00:08:50,000 --> 00:08:53,200
direction we're not going to try and

00:08:51,360 --> 00:08:54,399
solve the world's problems or solve the

00:08:53,200 --> 00:08:55,680
get the ultimate solution here but we're

00:08:54,399 --> 00:08:57,600
going to take a step

00:08:55,680 --> 00:08:59,040
so in this case we've got our our

00:08:57,600 --> 00:09:00,399
functions and let's say we had a

00:08:59,040 --> 00:09:02,959
function

00:09:00,399 --> 00:09:04,640
called remove cv that went in our string

00:09:02,959 --> 00:09:05,279
and removed all those const volatile

00:09:04,640 --> 00:09:07,680
things

00:09:05,279 --> 00:09:08,320
so that all we had was just you know the

00:09:07,680 --> 00:09:11,279
void

00:09:08,320 --> 00:09:12,880
then we could easily write is void right

00:09:11,279 --> 00:09:14,080
we could easily write there's our is

00:09:12,880 --> 00:09:16,640
void

00:09:14,080 --> 00:09:18,160
this void is just remove if the remove

00:09:16,640 --> 00:09:20,000
cv is equal to void

00:09:18,160 --> 00:09:21,200
same thing with null pointer remove this

00:09:20,000 --> 00:09:22,640
remove all the cons all

00:09:21,200 --> 00:09:24,399
the stuff out of there and is that what

00:09:22,640 --> 00:09:26,320
i have left yeah then it is

00:09:24,399 --> 00:09:28,399
and the same thing with float remove it

00:09:26,320 --> 00:09:30,959
look and see if it's a float a double or

00:09:28,399 --> 00:09:32,399
if it's a long double

00:09:30,959 --> 00:09:34,160
that that's a step in the right

00:09:32,399 --> 00:09:37,200
direction um

00:09:34,160 --> 00:09:39,200
and even with is integral we can have

00:09:37,200 --> 00:09:40,480
another one that says strip signed that

00:09:39,200 --> 00:09:42,560
will kind of remove the sign

00:09:40,480 --> 00:09:44,240
it knows how to knows how to remove the

00:09:42,560 --> 00:09:45,519
signed or the unsigned and

00:09:44,240 --> 00:09:48,080
try to figure out what the underlying

00:09:45,519 --> 00:09:50,640
thing is and then we could have our

00:09:48,080 --> 00:09:52,160
a function similar to this now this is

00:09:50,640 --> 00:09:53,519
this is better than having all those

00:09:52,160 --> 00:09:55,519
explicit string comparisons

00:09:53,519 --> 00:09:57,040
and so on the same way it's probably

00:09:55,519 --> 00:10:00,160
better that we do something

00:09:57,040 --> 00:10:02,839
similar instead of doing all of those

00:10:00,160 --> 00:10:04,240
explicit template instantiations or

00:10:02,839 --> 00:10:06,320
specializations

00:10:04,240 --> 00:10:08,720
so we talked about remove cv with

00:10:06,320 --> 00:10:12,160
strings let's talk about remove cv

00:10:08,720 --> 00:10:13,839
with a meta function now we already have

00:10:12,160 --> 00:10:16,480
remove const and remove cv

00:10:13,839 --> 00:10:18,399
by the way the the cv or the const

00:10:16,480 --> 00:10:19,360
volatile qualifiers so that's constant

00:10:18,399 --> 00:10:21,680
volatile

00:10:19,360 --> 00:10:22,399
so we already have removed const so what

00:10:21,680 --> 00:10:24,720
we need

00:10:22,399 --> 00:10:27,279
is a remove volatile and then we can

00:10:24,720 --> 00:10:30,079
compose them together to get remove cd

00:10:27,279 --> 00:10:31,279
and composition of meta functions is

00:10:30,079 --> 00:10:33,760
similar in

00:10:31,279 --> 00:10:34,800
in thought to composition of regular

00:10:33,760 --> 00:10:36,240
functions it's

00:10:34,800 --> 00:10:37,600
different in implementation but it's

00:10:36,240 --> 00:10:39,200
similar in the idea of what we're trying

00:10:37,600 --> 00:10:41,519
to accomplish

00:10:39,200 --> 00:10:42,640
so let's look at remove volatile there's

00:10:41,519 --> 00:10:44,959
our formal definition

00:10:42,640 --> 00:10:46,079
basically it says any top level follow

00:10:44,959 --> 00:10:48,720
the qualifier

00:10:46,079 --> 00:10:51,120
get them out of there and there's our

00:10:48,720 --> 00:10:52,560
implementation for remove volatile

00:10:51,120 --> 00:10:54,560
it's eerily similar to our

00:10:52,560 --> 00:10:58,160
implementation of remove const

00:10:54,560 --> 00:11:00,320
in fact just replace cons with volo

00:10:58,160 --> 00:11:01,600
so there's our primary template it does

00:11:00,320 --> 00:11:03,279
nothing so

00:11:01,600 --> 00:11:04,560
if there's no volatile in there it's

00:11:03,279 --> 00:11:05,920
just going to return the type that you

00:11:04,560 --> 00:11:08,959
give it

00:11:05,920 --> 00:11:11,120
here's our partial specialization now

00:11:08,959 --> 00:11:13,279
in our partial specialization if

00:11:11,120 --> 00:11:15,360
volatile is part of the type

00:11:13,279 --> 00:11:16,320
then we're going to pull the volatile

00:11:15,360 --> 00:11:18,640
piece out and

00:11:16,320 --> 00:11:20,000
all the pieces of the type that are left

00:11:18,640 --> 00:11:22,399
we're going to use those

00:11:20,000 --> 00:11:23,519
as the green piece that goes into the t

00:11:22,399 --> 00:11:24,320
and we're going to inherit from type

00:11:23,519 --> 00:11:27,040
identity

00:11:24,320 --> 00:11:28,160
would ex which if you remember exposes a

00:11:27,040 --> 00:11:31,680
public type name

00:11:28,160 --> 00:11:33,680
type which will be t and so

00:11:31,680 --> 00:11:36,640
we will have removed our volatile just

00:11:33,680 --> 00:11:39,200
like we have removed our const

00:11:36,640 --> 00:11:40,720
so remove cv the formal definition says

00:11:39,200 --> 00:11:42,000
that it's going to remove any top-level

00:11:40,720 --> 00:11:42,959
cv qualifier so basically it's going to

00:11:42,000 --> 00:11:46,959
remove

00:11:42,959 --> 00:11:49,279
const and vol and uh

00:11:46,959 --> 00:11:50,320
so in this case what we're going to do

00:11:49,279 --> 00:11:52,480
is remove

00:11:50,320 --> 00:11:53,680
volatile and then const now there was a

00:11:52,480 --> 00:11:57,440
question earlier

00:11:53,680 --> 00:11:59,839
in session one asking if uh

00:11:57,440 --> 00:12:01,040
alias templates could be considered meta

00:11:59,839 --> 00:12:02,240
functions because i said meta functions

00:12:01,040 --> 00:12:04,160
were classes well

00:12:02,240 --> 00:12:05,920
yeah so this is an alias template but

00:12:04,160 --> 00:12:07,680
this is a meta function so let's look at

00:12:05,920 --> 00:12:10,320
it a little more detail

00:12:07,680 --> 00:12:12,320
um you know it doesn't look like a meta

00:12:10,320 --> 00:12:13,920
function this removes cv

00:12:12,320 --> 00:12:16,000
it doesn't look like a meta function

00:12:13,920 --> 00:12:19,200
that we've had before

00:12:16,000 --> 00:12:21,279
because it's not a class um but it's

00:12:19,200 --> 00:12:24,639
basically saying that remove cv

00:12:21,279 --> 00:12:26,240
is going to be the same thing as remove

00:12:24,639 --> 00:12:31,360
const

00:12:26,240 --> 00:12:31,360
and then remove volatile okay so

00:12:31,440 --> 00:12:34,399
this is what we've got

00:12:34,720 --> 00:12:40,560
remove const with

00:12:38,160 --> 00:12:41,279
that right there the remove volatile

00:12:40,560 --> 00:12:44,000
underscore t

00:12:41,279 --> 00:12:45,680
remember that's a convenience for

00:12:44,000 --> 00:12:48,160
calling remove volatile

00:12:45,680 --> 00:12:48,800
it's the same thing as type name remove

00:12:48,160 --> 00:12:51,440
volatile

00:12:48,800 --> 00:12:52,880
uh and asking for the type and so what

00:12:51,440 --> 00:12:56,000
we're going to do

00:12:52,880 --> 00:12:56,720
is we are going to compose this we're

00:12:56,000 --> 00:12:59,600
going to call

00:12:56,720 --> 00:13:00,639
remove volatile to remove the volatile

00:12:59,600 --> 00:13:03,200
piece off the type

00:13:00,639 --> 00:13:05,120
off the off the type and then the result

00:13:03,200 --> 00:13:08,639
of that we're going to feed into

00:13:05,120 --> 00:13:10,320
remove const now there's something

00:13:08,639 --> 00:13:15,200
interesting here

00:13:10,320 --> 00:13:18,079
um remove cv

00:13:15,200 --> 00:13:20,720
takes remove const but it doesn't do

00:13:18,079 --> 00:13:23,040
remove const underscore t

00:13:20,720 --> 00:13:25,120
it does remove volatile underscore t but

00:13:23,040 --> 00:13:28,320
it doesn't remove const underscore t

00:13:25,120 --> 00:13:30,880
because remove cv is going to be a

00:13:28,320 --> 00:13:32,079
meta function we want to be able to call

00:13:30,880 --> 00:13:34,880
it like a function

00:13:32,079 --> 00:13:35,600
if we had said that remove cv equals

00:13:34,880 --> 00:13:39,040
remove

00:13:35,600 --> 00:13:42,639
const underscore t then it would have

00:13:39,040 --> 00:13:44,000
invoked the remove const meta function

00:13:42,639 --> 00:13:46,720
and that's not what we want we're

00:13:44,000 --> 00:13:48,480
defining remove cv as a meta function

00:13:46,720 --> 00:13:49,920
and it's actually going to be the exact

00:13:48,480 --> 00:13:53,600
same as

00:13:49,920 --> 00:13:53,600
the meta function remove const

00:13:55,040 --> 00:13:57,279
okay

00:13:58,639 --> 00:14:05,920
so let's look at an example

00:14:02,399 --> 00:14:08,639
remove cv of ins const volatile

00:14:05,920 --> 00:14:08,639
there's the type

00:14:10,240 --> 00:14:13,519
it's going to be the same thing as

00:14:11,440 --> 00:14:18,880
remove const of remove volatile t

00:14:13,519 --> 00:14:20,560
it's const volatile there's our type

00:14:18,880 --> 00:14:22,959
which is going to be the same as remove

00:14:20,560 --> 00:14:25,600
const of type name remove volatile in

00:14:22,959 --> 00:14:27,440
const volatile type which is then going

00:14:25,600 --> 00:14:29,680
to be the same as remove const of

00:14:27,440 --> 00:14:32,320
remove const of and const so what we've

00:14:29,680 --> 00:14:34,560
done is we've given it insconce volatile

00:14:32,320 --> 00:14:35,360
that has gone into the remove volatile

00:14:34,560 --> 00:14:37,440
meta function

00:14:35,360 --> 00:14:38,720
and it's been invoked because we see the

00:14:37,440 --> 00:14:41,040
underscore t means

00:14:38,720 --> 00:14:42,560
invoke the remove volatile meta function

00:14:41,040 --> 00:14:44,320
get its type and return it

00:14:42,560 --> 00:14:46,880
so it stripped off the volatile part and

00:14:44,320 --> 00:14:48,720
returned ent const

00:14:46,880 --> 00:14:51,440
and then that got pulled back and so now

00:14:48,720 --> 00:14:54,160
we have remove cv is equal to remove

00:14:51,440 --> 00:14:55,839
const it's const

00:14:54,160 --> 00:14:57,360
but why i thought we were going to

00:14:55,839 --> 00:15:00,880
remove the cost why is the const

00:14:57,360 --> 00:15:01,519
still there well remember this is a meta

00:15:00,880 --> 00:15:04,720
function

00:15:01,519 --> 00:15:05,600
so once we call remo once we call colon

00:15:04,720 --> 00:15:07,680
colon type

00:15:05,600 --> 00:15:08,880
on it then we're going to get the int

00:15:07,680 --> 00:15:11,360
part out

00:15:08,880 --> 00:15:12,639
okay so let's look at let's look at

00:15:11,360 --> 00:15:16,079
remove cvt

00:15:12,639 --> 00:15:19,920
this is invoking remove cv

00:15:16,079 --> 00:15:21,199
there's our type our type name with our

00:15:19,920 --> 00:15:22,959
type that comes down

00:15:21,199 --> 00:15:24,959
and we basically we do the type name

00:15:22,959 --> 00:15:25,360
dance it's hidden because it's it's up

00:15:24,959 --> 00:15:28,320
in there

00:15:25,360 --> 00:15:28,320
when we invoke it

00:15:28,560 --> 00:15:32,160
and then now we end up with our int

00:15:30,320 --> 00:15:32,880
because we're going to call colon colon

00:15:32,160 --> 00:15:36,240
type

00:15:32,880 --> 00:15:39,279
on the type that's wrapped so

00:15:36,240 --> 00:15:41,519
when you use an a type alias

00:15:39,279 --> 00:15:42,320
i mean an alias template as a meta

00:15:41,519 --> 00:15:45,920
function

00:15:42,320 --> 00:15:46,480
it is a meta function don't confuse it

00:15:45,920 --> 00:15:48,079
with

00:15:46,480 --> 00:15:49,680
calling a meta function because what

00:15:48,079 --> 00:15:52,720
you're doing is you're creating

00:15:49,680 --> 00:15:54,000
another meta function that is equivalent

00:15:52,720 --> 00:15:57,440
to the amount of function that

00:15:54,000 --> 00:16:00,480
you're making it an alias for okay

00:15:57,440 --> 00:16:01,519
so you know earlier i said

00:16:00,480 --> 00:16:04,800
specialization is like

00:16:01,519 --> 00:16:08,399
comparison for functions of types right

00:16:04,800 --> 00:16:10,639
but it can be votes and it can be

00:16:08,399 --> 00:16:11,600
used in a context that allows explicit

00:16:10,639 --> 00:16:13,600
specializations

00:16:11,600 --> 00:16:15,680
of templates so that's the only place

00:16:13,600 --> 00:16:17,839
you can use the specializations the

00:16:15,680 --> 00:16:20,639
explicit specialization

00:16:17,839 --> 00:16:22,800
and so let's write a comparison for meta

00:16:20,639 --> 00:16:24,639
functions for types

00:16:22,800 --> 00:16:25,680
and we're going to call it is same and

00:16:24,639 --> 00:16:26,800
the reason we're going to call it this

00:16:25,680 --> 00:16:28,079
same is because

00:16:26,800 --> 00:16:30,079
that's what the standard library calls

00:16:28,079 --> 00:16:32,160
it because this is a type trait from the

00:16:30,079 --> 00:16:34,639
standard library

00:16:32,160 --> 00:16:36,320
and so we have our primary template and

00:16:34,639 --> 00:16:39,519
it takes two types

00:16:36,320 --> 00:16:41,600
any types uh now remember um

00:16:39,519 --> 00:16:42,959
i think earlier we had only worked with

00:16:41,600 --> 00:16:45,120
one type on here

00:16:42,959 --> 00:16:46,480
but we've got two types it takes two of

00:16:45,120 --> 00:16:50,560
any types that's why

00:16:46,480 --> 00:16:52,639
we've got type name t1 and type name t2

00:16:50,560 --> 00:16:56,720
they could map to anything they could be

00:16:52,639 --> 00:16:56,720
the same type but they don't have to be

00:17:00,800 --> 00:17:07,439
so since our special case

00:17:04,160 --> 00:17:10,079
is the same right

00:17:07,439 --> 00:17:10,720
we've got you see how with the stuff in

00:17:10,079 --> 00:17:13,679
the green

00:17:10,720 --> 00:17:14,400
box it's the two t's but look above it

00:17:13,679 --> 00:17:17,520
you only see

00:17:14,400 --> 00:17:18,799
one t in the in the angle brackets so

00:17:17,520 --> 00:17:20,000
remember we talked about partial

00:17:18,799 --> 00:17:21,839
specializations

00:17:20,000 --> 00:17:23,439
an explicit specialization means the

00:17:21,839 --> 00:17:26,640
angle brackets are empty

00:17:23,439 --> 00:17:28,640
a partial specialization is that there's

00:17:26,640 --> 00:17:30,400
something in here and we're and we're

00:17:28,640 --> 00:17:32,720
going to specialize it in a way

00:17:30,400 --> 00:17:33,520
now it might be confusing that there's

00:17:32,720 --> 00:17:36,320
only one

00:17:33,520 --> 00:17:38,320
type in this angle bracket up top and

00:17:36,320 --> 00:17:41,280
there's two types here

00:17:38,320 --> 00:17:43,360
but that's okay because you have to

00:17:41,280 --> 00:17:44,480
think of this upper part as almost like

00:17:43,360 --> 00:17:48,400
the parameters

00:17:44,480 --> 00:17:51,600
to a function it's not the same

00:17:48,400 --> 00:17:53,520
and this is a little interesting because

00:17:51,600 --> 00:17:55,280
in this case if you remember i said that

00:17:53,520 --> 00:17:56,960
anything inside of these angle brackets

00:17:55,280 --> 00:17:58,720
if they're empty we've got a full or

00:17:56,960 --> 00:18:00,000
explicit specialization

00:17:58,720 --> 00:18:03,120
we've got something in here so it's

00:18:00,000 --> 00:18:03,919
partial but there's only one of these

00:18:03,120 --> 00:18:07,280
parameters

00:18:03,919 --> 00:18:09,360
but i need two in my specialization

00:18:07,280 --> 00:18:10,880
and that's okay because i don't want you

00:18:09,360 --> 00:18:13,600
to be confused by what's

00:18:10,880 --> 00:18:15,039
in this set or not think of this it's

00:18:13,600 --> 00:18:17,039
not quite right but it's

00:18:15,039 --> 00:18:19,039
close enough think of this almost like

00:18:17,039 --> 00:18:20,240
the parameters you pass into a function

00:18:19,039 --> 00:18:21,760
or something you've got

00:18:20,240 --> 00:18:23,679
a bunch you've got a bunch of them it's

00:18:21,760 --> 00:18:25,919
not that it's it's not

00:18:23,679 --> 00:18:28,240
it's not even really that but you can

00:18:25,919 --> 00:18:29,679
have as many of those as you want

00:18:28,240 --> 00:18:31,360
right you can have when you have a

00:18:29,679 --> 00:18:34,559
specialization you can have as many

00:18:31,360 --> 00:18:37,600
things in here as you want

00:18:34,559 --> 00:18:41,120
this has to match that

00:18:37,600 --> 00:18:44,480
okay so when you specialize it

00:18:41,120 --> 00:18:46,080
this has to match this but it doesn't

00:18:44,480 --> 00:18:47,840
matter what's in this part

00:18:46,080 --> 00:18:49,200
anything you want to put in there is

00:18:47,840 --> 00:18:51,360
fine okay

00:18:49,200 --> 00:18:52,799
and so in this case i've got one type

00:18:51,360 --> 00:18:54,240
because i want to match when they're

00:18:52,799 --> 00:18:57,039
both the same

00:18:54,240 --> 00:18:57,760
okay when both of those types are the

00:18:57,039 --> 00:19:02,000
same

00:18:57,760 --> 00:19:04,480
so um you know this specialization

00:19:02,000 --> 00:19:06,240
think of it as it's like says hey you

00:19:04,480 --> 00:19:09,679
know i gotta type t

00:19:06,240 --> 00:19:11,280
now that t can be anything and when the

00:19:09,679 --> 00:19:16,320
template is instantiated

00:19:11,280 --> 00:19:19,200
in such a way where both types

00:19:16,320 --> 00:19:20,320
are that anything that t then choose

00:19:19,200 --> 00:19:22,720
this specialization

00:19:20,320 --> 00:19:24,720
right so is same can be instantiated

00:19:22,720 --> 00:19:28,320
with any two types at all

00:19:24,720 --> 00:19:30,240
but any time it gets instantiated and it

00:19:28,320 --> 00:19:32,080
and it matches where they're both the

00:19:30,240 --> 00:19:33,679
same then this one's gonna get done

00:19:32,080 --> 00:19:35,120
right so the first one's gonna get

00:19:33,679 --> 00:19:36,480
matched right so let's look at there's

00:19:35,120 --> 00:19:38,160
only two of them here so

00:19:36,480 --> 00:19:39,520
it's not a combinatorial explosion here

00:19:38,160 --> 00:19:42,080
let's look at the first one

00:19:39,520 --> 00:19:43,520
if i pass it in a couple of types it's

00:19:42,080 --> 00:19:46,080
going to get matched

00:19:43,520 --> 00:19:47,760
no matter what two types i have the

00:19:46,080 --> 00:19:48,559
first spec the primary template is going

00:19:47,760 --> 00:19:50,720
to get matched

00:19:48,559 --> 00:19:51,919
that one will get matched every time no

00:19:50,720 --> 00:19:55,200
matter what two types i put

00:19:51,919 --> 00:19:56,080
in but the second one will only get

00:19:55,200 --> 00:19:59,120
matched

00:19:56,080 --> 00:20:00,320
whenever the types that you put in are

00:19:59,120 --> 00:20:03,200
the same

00:20:00,320 --> 00:20:06,240
that's why there's only one type up top

00:20:03,200 --> 00:20:08,080
because if that type can describe

00:20:06,240 --> 00:20:09,280
the types that are inside of the

00:20:08,080 --> 00:20:11,360
specialization

00:20:09,280 --> 00:20:13,039
then that one gets matched as well and

00:20:11,360 --> 00:20:15,120
the rules say

00:20:13,039 --> 00:20:17,679
that even though both of them get

00:20:15,120 --> 00:20:21,280
matched it's going to select the one

00:20:17,679 --> 00:20:22,159
that is the best specialization the best

00:20:21,280 --> 00:20:23,840
match

00:20:22,159 --> 00:20:26,240
and so the best match is going to be

00:20:23,840 --> 00:20:28,080
this one which is going to be true

00:20:26,240 --> 00:20:29,440
whenever the two things are the same so

00:20:28,080 --> 00:20:30,000
let's look at this in a little detail

00:20:29,440 --> 00:20:33,520
here

00:20:30,000 --> 00:20:34,320
um so if we if we assign is if we call

00:20:33,520 --> 00:20:37,440
is same

00:20:34,320 --> 00:20:39,760
int and unsigned then t1

00:20:37,440 --> 00:20:41,440
is going to be int and t2 is going to be

00:20:39,760 --> 00:20:42,400
unsigned so the primary template is

00:20:41,440 --> 00:20:44,320
going to match

00:20:42,400 --> 00:20:46,080
the primary template matches with t1

00:20:44,320 --> 00:20:47,280
matching to end and t2 matching to

00:20:46,080 --> 00:20:49,440
unsign

00:20:47,280 --> 00:20:50,640
but there's no way to make the second

00:20:49,440 --> 00:20:53,039
specialization match

00:20:50,640 --> 00:20:53,840
i mean how can you pass it int and

00:20:53,039 --> 00:20:56,720
unsign

00:20:53,840 --> 00:20:57,600
and make both of them be equal to the t

00:20:56,720 --> 00:20:59,760
i mean you can't

00:20:57,600 --> 00:21:01,120
because they're different they both

00:20:59,760 --> 00:21:03,200
can't be equal to the t

00:21:01,120 --> 00:21:04,799
so that one's not going to match but if

00:21:03,200 --> 00:21:06,720
we look at the second example where we

00:21:04,799 --> 00:21:09,760
send in two ents

00:21:06,720 --> 00:21:11,440
the first uh the gen the primary

00:21:09,760 --> 00:21:11,840
template it's going to match with t1

00:21:11,440 --> 00:21:14,960
equal

00:21:11,840 --> 00:21:16,640
int and t2 and t2 equaling end and then

00:21:14,960 --> 00:21:17,280
the second specialization it's also

00:21:16,640 --> 00:21:20,720
going to match

00:21:17,280 --> 00:21:24,240
because it can create is same int

00:21:20,720 --> 00:21:26,320
with the t equaling int because

00:21:24,240 --> 00:21:27,840
it's it's only there's one it can only

00:21:26,320 --> 00:21:30,240
be one and if they're both the same then

00:21:27,840 --> 00:21:31,600
it's going to match

00:21:30,240 --> 00:21:33,600
okay i hope that's i hope that's a

00:21:31,600 --> 00:21:35,600
little more clear sometimes these

00:21:33,600 --> 00:21:37,280
specializations are a little bit tricky

00:21:35,600 --> 00:21:39,760
we've got a few more because there's

00:21:37,280 --> 00:21:41,440
just subtle examples subtle differences

00:21:39,760 --> 00:21:42,799
so let's let's just assume that we have

00:21:41,440 --> 00:21:45,760
this thing i call is

00:21:42,799 --> 00:21:47,039
same raw now to be sure this is not a

00:21:45,760 --> 00:21:49,520
standard type trait

00:21:47,039 --> 00:21:50,559
um but it's kind of useful and what it

00:21:49,520 --> 00:21:53,600
really does

00:21:50,559 --> 00:21:54,400
is it takes two types removes their cv

00:21:53,600 --> 00:21:56,320
qualifiers

00:21:54,400 --> 00:21:57,600
and then compare and then compares them

00:21:56,320 --> 00:22:00,480
right it just says hey

00:21:57,600 --> 00:22:01,120
remove the cv qualifiers and if they're

00:22:00,480 --> 00:22:03,039
the same

00:22:01,120 --> 00:22:04,480
after removing these cv qualifiers then

00:22:03,039 --> 00:22:07,440
i'm gonna treat them the same

00:22:04,480 --> 00:22:09,360
so um this might be helpful considering

00:22:07,440 --> 00:22:11,440
that all of our type traits

00:22:09,360 --> 00:22:14,080
want us to remove both the const and the

00:22:11,440 --> 00:22:18,080
volatile qualifiers

00:22:14,080 --> 00:22:18,080
so let's go back to its floating point

00:22:18,720 --> 00:22:24,159
so again we use an alias template

00:22:21,919 --> 00:22:25,280
this floating point is an alias template

00:22:24,159 --> 00:22:26,640
it's not a class

00:22:25,280 --> 00:22:29,039
and it's basically going to resolve

00:22:26,640 --> 00:22:32,080
strictly to bull constant

00:22:29,039 --> 00:22:36,000
and we're going to call our is same raw

00:22:32,080 --> 00:22:39,600
if removing the const

00:22:36,000 --> 00:22:42,640
the cv qualifier from both sides yields

00:22:39,600 --> 00:22:44,799
the same thing then we're

00:22:42,640 --> 00:22:46,159
a floating point i hope that makes sense

00:22:44,799 --> 00:22:48,640
that's very close to the

00:22:46,159 --> 00:22:51,200
string example we were looking at from

00:22:48,640 --> 00:22:51,200
regular

00:22:52,840 --> 00:22:55,840
programming

00:22:56,000 --> 00:22:59,440
i see a question i'll get to it in a

00:22:57,120 --> 00:23:01,679
second um

00:22:59,440 --> 00:23:02,720
so we have this bull constant of

00:23:01,679 --> 00:23:05,039
integral const

00:23:02,720 --> 00:23:05,840
and that's really um that's really what

00:23:05,039 --> 00:23:07,679
those things

00:23:05,840 --> 00:23:09,280
those guys resolve to that's what is

00:23:07,679 --> 00:23:10,080
floating point is it's a bull constant

00:23:09,280 --> 00:23:13,120
which is a

00:23:10,080 --> 00:23:16,559
a constant an integral constant

00:23:13,120 --> 00:23:19,760
um so let's look at is integral

00:23:16,559 --> 00:23:20,799
uh is integral is very similar it's just

00:23:19,760 --> 00:23:22,240
a little bit longer

00:23:20,799 --> 00:23:24,080
and i didn't implement the part about

00:23:22,240 --> 00:23:26,320
the unsigned because really uh

00:23:24,080 --> 00:23:28,000
make unsigned and make signed actually

00:23:26,320 --> 00:23:28,640
have a little bit of complexity to them

00:23:28,000 --> 00:23:30,080
because

00:23:28,640 --> 00:23:31,840
depending on what it is you have to find

00:23:30,080 --> 00:23:32,080
that the type that has the right size

00:23:31,840 --> 00:23:33,440
and

00:23:32,080 --> 00:23:36,400
it's probably a little bit more involved

00:23:33,440 --> 00:23:37,360
than an example here um but you get the

00:23:36,400 --> 00:23:39,840
idea this is

00:23:37,360 --> 00:23:41,279
better than the 64 specializations we

00:23:39,840 --> 00:23:43,279
had it's still not great

00:23:41,279 --> 00:23:45,200
and hopefully we'll get it get time to

00:23:43,279 --> 00:23:47,279
see something that is better

00:23:45,200 --> 00:23:48,320
but this still is way way better than

00:23:47,279 --> 00:23:49,919
what we had before

00:23:48,320 --> 00:23:51,279
and you can see the power of doing these

00:23:49,919 --> 00:23:52,720
abstractions and it's really not that

00:23:51,279 --> 00:23:54,640
bad once you get used to it

00:23:52,720 --> 00:23:55,760
you just you create your little function

00:23:54,640 --> 00:23:57,039
your meta functions

00:23:55,760 --> 00:23:58,400
just like you would create little

00:23:57,039 --> 00:23:58,960
functions when you were writing bigger

00:23:58,400 --> 00:24:00,480
code

00:23:58,960 --> 00:24:02,240
you don't put everything in one big

00:24:00,480 --> 00:24:05,520
function at least not anymore

00:24:02,240 --> 00:24:07,039
um and so we we can happily go along and

00:24:05,520 --> 00:24:08,960
write these smaller meta functions to

00:24:07,039 --> 00:24:12,320
help us

00:24:08,960 --> 00:24:15,039
um now we could implement

00:24:12,320 --> 00:24:16,640
if we had a thing called is type in pack

00:24:15,039 --> 00:24:18,080
and we might get time to me showing you

00:24:16,640 --> 00:24:20,480
how to implement that

00:24:18,080 --> 00:24:22,320
but imagine there was a meta function

00:24:20,480 --> 00:24:25,760
called is type impact

00:24:22,320 --> 00:24:28,960
and it took a type and it took

00:24:25,760 --> 00:24:30,400
a list of a bunch of other types and it

00:24:28,960 --> 00:24:33,360
basically returned true

00:24:30,400 --> 00:24:34,799
if that type was anywhere in that list

00:24:33,360 --> 00:24:35,360
then you could imagine that something

00:24:34,799 --> 00:24:37,840
like this

00:24:35,360 --> 00:24:39,840
is integral is type in pack give it the

00:24:37,840 --> 00:24:42,080
type and then give it the list of types

00:24:39,840 --> 00:24:45,039
and it would go off on its happy way and

00:24:42,080 --> 00:24:47,679
check to see if it was any of those

00:24:45,039 --> 00:24:49,200
okay so let's get to this question

00:24:47,679 --> 00:24:51,440
intuitively i understand

00:24:49,200 --> 00:24:53,520
what is the best match when more than

00:24:51,440 --> 00:24:56,480
one template definitions match

00:24:53,520 --> 00:24:58,080
how is it formally defined though um

00:24:56,480 --> 00:25:01,279
that's a great question

00:24:58,080 --> 00:25:02,960
and i'm not big on standard ease so

00:25:01,279 --> 00:25:03,919
to get the actual formal definition

00:25:02,960 --> 00:25:04,799
you're going to have to go to the

00:25:03,919 --> 00:25:08,159
standard

00:25:04,799 --> 00:25:09,679
but basically for template

00:25:08,159 --> 00:25:12,480
specialization

00:25:09,679 --> 00:25:13,760
it it it's just as intuitively as you

00:25:12,480 --> 00:25:17,279
would think it is

00:25:13,760 --> 00:25:18,960
it's the best match think of it like

00:25:17,279 --> 00:25:22,240
this

00:25:18,960 --> 00:25:23,919
you've got if you took all of the

00:25:22,240 --> 00:25:25,279
this isn't exactly how it works but

00:25:23,919 --> 00:25:27,360
think of it this way

00:25:25,279 --> 00:25:28,480
take all the types in the world you've

00:25:27,360 --> 00:25:31,039
got each one

00:25:28,480 --> 00:25:32,320
of the each one of these specializations

00:25:31,039 --> 00:25:36,080
or each one of the matches

00:25:32,320 --> 00:25:38,640
is a bin throw all the types in

00:25:36,080 --> 00:25:40,320
the one that is the most specialized is

00:25:38,640 --> 00:25:42,960
the one that you're gonna pick

00:25:40,320 --> 00:25:44,559
right because i'm matching against the

00:25:42,960 --> 00:25:46,159
general one but there's only

00:25:44,559 --> 00:25:47,679
one over here and it's the one that

00:25:46,159 --> 00:25:50,960
matches me exactly

00:25:47,679 --> 00:25:51,279
it matches most of my stuff i match i

00:25:50,960 --> 00:25:53,520
might

00:25:51,279 --> 00:25:55,120
i might match with i might you know if

00:25:53,520 --> 00:25:56,799
i'm looking for something with

00:25:55,120 --> 00:25:59,120
const in it it might match with

00:25:56,799 --> 00:26:02,480
something with an ant and a const and a

00:25:59,120 --> 00:26:04,320
and a and some other values but

00:26:02,480 --> 00:26:05,760
you're looking for the one that is the

00:26:04,320 --> 00:26:08,159
most refined

00:26:05,760 --> 00:26:09,600
and i don't know what the language is

00:26:08,159 --> 00:26:10,000
from the standard because i just don't

00:26:09,600 --> 00:26:13,200
remember

00:26:10,000 --> 00:26:16,400
it um i read the 98 standard from

00:26:13,200 --> 00:26:17,360
cover to cover and i will never do that

00:26:16,400 --> 00:26:18,559
again

00:26:17,360 --> 00:26:20,559
i probably don't have the stamina to do

00:26:18,559 --> 00:26:21,919
it anymore but i don't remember but it's

00:26:20,559 --> 00:26:22,480
basically what you would think from an

00:26:21,919 --> 00:26:25,840
intuitive

00:26:22,480 --> 00:26:29,440
perspective is that the

00:26:25,840 --> 00:26:31,679
match that is the closest to your

00:26:29,440 --> 00:26:33,360
type is what's going to be matched and

00:26:31,679 --> 00:26:36,320
there is a sophisticated algorithm

00:26:33,360 --> 00:26:37,919
and it's very well described i'm just

00:26:36,320 --> 00:26:39,039
can't really describe it very well aside

00:26:37,919 --> 00:26:41,039
from that

00:26:39,039 --> 00:26:42,240
it is the best match i mean look at all

00:26:41,039 --> 00:26:44,480
the examples and you'll

00:26:42,240 --> 00:26:46,000
you can clearly see the best match uh

00:26:44,480 --> 00:26:48,559
apologize for not not being able to do

00:26:46,000 --> 00:26:48,559
better on that

00:26:48,799 --> 00:26:52,000
so let's look at israel and we look at

00:26:50,640 --> 00:26:54,000
this one because it's still

00:26:52,000 --> 00:26:55,520
partial specialization but it's

00:26:54,000 --> 00:26:58,720
different

00:26:55,520 --> 00:27:00,640
um it uses uh

00:26:58,720 --> 00:27:01,840
hang on i've had more questions popped

00:27:00,640 --> 00:27:03,600
up there let me see if i can do those

00:27:01,840 --> 00:27:05,440
before i get on here

00:27:03,600 --> 00:27:07,279
uh would this match something like a

00:27:05,440 --> 00:27:08,960
size t or a unit or would that need to

00:27:07,279 --> 00:27:12,640
be exposed oh good question

00:27:08,960 --> 00:27:16,000
um good question um no you you will get

00:27:12,640 --> 00:27:18,240
you will get um a size uh size uh

00:27:16,000 --> 00:27:19,279
type promotion for the integers if you

00:27:18,240 --> 00:27:21,600
if you have

00:27:19,279 --> 00:27:22,720
um things so like right here on this one

00:27:21,600 --> 00:27:25,440
it's got a

00:27:22,720 --> 00:27:27,679
type t and a size tn you don't have to

00:27:25,440 --> 00:27:29,440
cast it to a size tn you could throw in

00:27:27,679 --> 00:27:32,240
a 10 or something and it will

00:27:29,440 --> 00:27:33,440
it will promote it um to fill to meet

00:27:32,240 --> 00:27:36,320
that

00:27:33,440 --> 00:27:38,399
if i had a primary template template

00:27:36,320 --> 00:27:41,679
type name one type in two timing three

00:27:38,399 --> 00:27:43,200
struct is same can i write a

00:27:41,679 --> 00:27:46,880
specialization template technique

00:27:43,200 --> 00:27:50,960
x happening y struct is same x y

00:27:46,880 --> 00:27:53,679
um no you couldn't um because

00:27:50,960 --> 00:27:54,000
you've got three because your is same

00:27:53,679 --> 00:27:57,039
there

00:27:54,000 --> 00:27:57,279
takes three template parameters and if

00:27:57,039 --> 00:27:58,559
you

00:27:57,279 --> 00:28:00,399
and if it takes three then the

00:27:58,559 --> 00:28:02,960
specialization has to have three

00:28:00,399 --> 00:28:05,120
so so let me see if i can show you on

00:28:02,960 --> 00:28:08,240
here

00:28:05,120 --> 00:28:09,840
um is array the primary template is

00:28:08,240 --> 00:28:12,000
array has one parameter

00:28:09,840 --> 00:28:12,880
therefore every specialization must have

00:28:12,000 --> 00:28:15,360
one

00:28:12,880 --> 00:28:17,360
if the primary template has two then

00:28:15,360 --> 00:28:18,720
every specialization must have two

00:28:17,360 --> 00:28:21,039
you have to have the you have to have

00:28:18,720 --> 00:28:21,520
the same number in when you specialize

00:28:21,039 --> 00:28:23,840
it

00:28:21,520 --> 00:28:25,200
the number the number in here when

00:28:23,840 --> 00:28:27,039
you're declaring what your

00:28:25,200 --> 00:28:28,399
partial what your variables are for your

00:28:27,039 --> 00:28:30,799
partial specialization

00:28:28,399 --> 00:28:31,440
you can have as many as you want there

00:28:30,799 --> 00:28:34,559
but

00:28:31,440 --> 00:28:38,240
in this it has to match exactly in

00:28:34,559 --> 00:28:40,080
what you have in the primary template

00:28:38,240 --> 00:28:41,520
okay i think i'm caught up on questions

00:28:40,080 --> 00:28:42,640
which is good because i mean it's a

00:28:41,520 --> 00:28:45,279
tutorial so

00:28:42,640 --> 00:28:45,679
um i should be processing questions all

00:28:45,279 --> 00:28:50,000
right

00:28:45,679 --> 00:28:52,000
so on is array um when we look here

00:28:50,000 --> 00:28:53,600
uh it's interesting because we have a

00:28:52,000 --> 00:28:55,279
type and

00:28:53,600 --> 00:28:57,200
a non-type template parameter we have

00:28:55,279 --> 00:29:00,240
both of them and

00:28:57,200 --> 00:29:03,520
this is just in the specialization right

00:29:00,240 --> 00:29:06,559
so i'm trying to match a type

00:29:03,520 --> 00:29:08,000
but arrays there's two kinds of arrays

00:29:06,559 --> 00:29:11,600
there's arrays that are

00:29:08,000 --> 00:29:12,000
bounded with a size and that's what this

00:29:11,600 --> 00:29:13,760
would be

00:29:12,000 --> 00:29:15,200
it would be matching an array think of

00:29:13,760 --> 00:29:18,399
it like int

00:29:15,200 --> 00:29:19,200
angle bracket five right i've got an

00:29:18,399 --> 00:29:21,679
integer of

00:29:19,200 --> 00:29:23,520
five i've got an array of five integers

00:29:21,679 --> 00:29:25,760
and so this is going to match with the

00:29:23,520 --> 00:29:27,520
type of an integer with five elements

00:29:25,760 --> 00:29:29,440
in it it's going to match the end with

00:29:27,520 --> 00:29:31,279
the t and the five with the n

00:29:29,440 --> 00:29:32,720
and yes if you just give it a five which

00:29:31,279 --> 00:29:35,840
is technically an integer

00:29:32,720 --> 00:29:39,279
it will match to the size t

00:29:35,840 --> 00:29:43,600
um the second specialization is

00:29:39,279 --> 00:29:46,480
for an unbounded array and which has no

00:29:43,600 --> 00:29:47,760
um size so its type doesn't have a size

00:29:46,480 --> 00:29:50,080
so this one's just going to match

00:29:47,760 --> 00:29:52,000
any unbounded array so it doesn't matter

00:29:50,080 --> 00:29:54,480
what the type is just any array at all

00:29:52,000 --> 00:29:55,279
and and these arrays can have arrays

00:29:54,480 --> 00:29:57,840
within them

00:29:55,279 --> 00:29:58,640
right t itself could be a list of arrays

00:29:57,840 --> 00:30:01,919
that's okay

00:29:58,640 --> 00:30:04,880
this is just any array um

00:30:01,919 --> 00:30:06,000
so and oh in this case no wonder int 5

00:30:04,880 --> 00:30:06,880
was on my mind because that's what i

00:30:06,000 --> 00:30:10,240
wrote

00:30:06,880 --> 00:30:13,200
um so we've got we've got here that

00:30:10,240 --> 00:30:14,000
int 5 the primary template is going to

00:30:13,200 --> 00:30:16,320
match with t

00:30:14,000 --> 00:30:18,399
because int 5 is is a type any type is

00:30:16,320 --> 00:30:20,240
going to match with the primary template

00:30:18,399 --> 00:30:21,840
the first specialization is going to

00:30:20,240 --> 00:30:22,159
match because it's going to match with

00:30:21,840 --> 00:30:23,760
the

00:30:22,159 --> 00:30:25,679
int and it's going to match with the n

00:30:23,760 --> 00:30:27,760
equals 5.

00:30:25,679 --> 00:30:29,360
and but there's no way to match with the

00:30:27,760 --> 00:30:31,919
second specialization

00:30:29,360 --> 00:30:33,360
so the first specialization will be

00:30:31,919 --> 00:30:36,000
selected because it is

00:30:33,360 --> 00:30:37,279
more specialized now it there is there

00:30:36,000 --> 00:30:38,640
are cases where

00:30:37,279 --> 00:30:40,320
the compiler can't figure out which

00:30:38,640 --> 00:30:42,159
one's more specialized

00:30:40,320 --> 00:30:44,399
and in that case it would be ambiguous

00:30:42,159 --> 00:30:47,360
and you would get a compiler error

00:30:44,399 --> 00:30:47,840
um and so here's our second case where

00:30:47,360 --> 00:30:50,480
we have

00:30:47,840 --> 00:30:52,159
an array that's unbounded of course the

00:30:50,480 --> 00:30:54,240
primary template is going to match

00:30:52,159 --> 00:30:56,399
because it takes any type

00:30:54,240 --> 00:30:57,519
and the second one is not going to match

00:30:56,399 --> 00:31:00,320
because there's no way to

00:30:57,519 --> 00:31:00,960
form there's no way to put t and n

00:31:00,320 --> 00:31:04,480
together

00:31:00,960 --> 00:31:06,080
in order to get a valid uh type

00:31:04,480 --> 00:31:07,679
i mean you just can't there's no way

00:31:06,080 --> 00:31:09,519
there's no way to form that together in

00:31:07,679 --> 00:31:11,519
order to get a valid type because

00:31:09,519 --> 00:31:13,200
square bracket has no n it has no

00:31:11,519 --> 00:31:15,760
integer so there's no way to

00:31:13,200 --> 00:31:16,559
create that one and the second one will

00:31:15,760 --> 00:31:19,840
match with

00:31:16,559 --> 00:31:19,840
t being int

00:31:22,000 --> 00:31:26,320
is it fair to assume that there is the

00:31:24,159 --> 00:31:28,399
possibility of ambiguities which would

00:31:26,320 --> 00:31:31,600
result in compile time error message

00:31:28,399 --> 00:31:33,200
yes most definitely um um when you

00:31:31,600 --> 00:31:34,640
create your specializations

00:31:33,200 --> 00:31:36,399
you need to make sure that you're

00:31:34,640 --> 00:31:39,519
creating them um

00:31:36,399 --> 00:31:41,120
in an unambiguous manner and if you do

00:31:39,519 --> 00:31:42,320
have ambiguous specializations the

00:31:41,120 --> 00:31:43,679
compiler will yell at you

00:31:42,320 --> 00:31:45,440
so it's not like you'll get in a case

00:31:43,679 --> 00:31:47,120
where you've got some some oh

00:31:45,440 --> 00:31:48,559
some bug because the wrong thing no the

00:31:47,120 --> 00:31:49,039
comp the compiler will figure out what

00:31:48,559 --> 00:31:52,240
those

00:31:49,039 --> 00:31:53,679
ambiguities are um uh and uh and it'll

00:31:52,240 --> 00:31:56,960
be pretty clear to you once you look at

00:31:53,679 --> 00:31:56,960
it in in most cases

00:31:57,919 --> 00:32:05,039
okay so this pointer

00:32:01,919 --> 00:32:08,480
it's pretty simple um why are we even

00:32:05,039 --> 00:32:10,399
doing this one right um i mean

00:32:08,480 --> 00:32:12,240
it's just it's a pointer the primary

00:32:10,399 --> 00:32:15,440
template says

00:32:12,240 --> 00:32:17,120
hey false type n

00:32:15,440 --> 00:32:19,679
in general things aren't pointers so the

00:32:17,120 --> 00:32:23,200
primary template is false

00:32:19,679 --> 00:32:25,360
the specialization i take a t

00:32:23,200 --> 00:32:26,480
and this is a partial specialization for

00:32:25,360 --> 00:32:28,399
any pointer

00:32:26,480 --> 00:32:31,760
a pointer to anything i don't care what

00:32:28,399 --> 00:32:31,760
it is and i'm going to return true

00:32:32,960 --> 00:32:38,000
but that's not all there is because we

00:32:35,600 --> 00:32:38,960
have to take into account this little cv

00:32:38,000 --> 00:32:40,799
thing

00:32:38,960 --> 00:32:42,720
and the little cv thing is going to bite

00:32:40,799 --> 00:32:46,559
us in the tush on this

00:32:42,720 --> 00:32:48,480
um so we have to basically take

00:32:46,559 --> 00:32:49,600
our implementation of this pointer and

00:32:48,480 --> 00:32:51,200
put it into a

00:32:49,600 --> 00:32:52,559
detail and put it somewhere we have to

00:32:51,200 --> 00:32:53,519
do some implementation this is not the

00:32:52,559 --> 00:32:55,039
only way to do it

00:32:53,519 --> 00:32:57,440
but we have to account for the seat for

00:32:55,039 --> 00:32:58,799
the the the cv qualifiers

00:32:57,440 --> 00:33:01,039
and so in this case the way we're going

00:32:58,799 --> 00:33:04,000
to account for the cv qualifiers

00:33:01,039 --> 00:33:05,679
is that um we're going to put this

00:33:04,000 --> 00:33:06,480
implementation into this detail name

00:33:05,679 --> 00:33:08,799
space

00:33:06,480 --> 00:33:09,600
and we're going to have this pointer now

00:33:08,799 --> 00:33:12,720
is remember it

00:33:09,600 --> 00:33:15,360
is an alien an alias template

00:33:12,720 --> 00:33:17,039
that resolves to is pointer impul with

00:33:15,360 --> 00:33:19,360
remove cvt

00:33:17,039 --> 00:33:21,840
so i'm calling our remove cv meta

00:33:19,360 --> 00:33:24,159
function to remove all the cons volatile

00:33:21,840 --> 00:33:25,760
qualifiers off of this type and then i'm

00:33:24,159 --> 00:33:28,960
going to pass it into the

00:33:25,760 --> 00:33:32,399
this pointer because it what if you had

00:33:28,960 --> 00:33:33,840
a const pointer to t then you want to

00:33:32,399 --> 00:33:35,120
make sure that those get resolved so

00:33:33,840 --> 00:33:36,960
we're going to we're going to handle

00:33:35,120 --> 00:33:38,320
handle that situation

00:33:36,960 --> 00:33:40,640
but otherwise it's pretty similar to

00:33:38,320 --> 00:33:42,480
what we've been doing before

00:33:40,640 --> 00:33:43,679
okay this is the one we were talking

00:33:42,480 --> 00:33:45,279
about um

00:33:43,679 --> 00:33:46,880
right before the break when somebody had

00:33:45,279 --> 00:33:47,840
asked are there cases where the compiler

00:33:46,880 --> 00:33:50,240
doesn't support them

00:33:47,840 --> 00:33:51,519
uh so so is union this is an example of

00:33:50,240 --> 00:33:53,039
one of the meta functions that it's

00:33:51,519 --> 00:33:53,919
impossible to implement without compiler

00:33:53,039 --> 00:33:56,240
support

00:33:53,919 --> 00:33:58,000
um and the reason i include this is i

00:33:56,240 --> 00:33:59,600
want to explicitly point out that

00:33:58,000 --> 00:34:00,960
some information about types while

00:33:59,600 --> 00:34:01,919
available to compiler they're not

00:34:00,960 --> 00:34:04,720
available

00:34:01,919 --> 00:34:05,440
um with the construct of the language

00:34:04,720 --> 00:34:07,919
itself

00:34:05,440 --> 00:34:09,359
um remember uh meta programming in c

00:34:07,919 --> 00:34:11,200
plus plus is not

00:34:09,359 --> 00:34:12,560
um a first order language feature at

00:34:11,200 --> 00:34:13,839
least not yet um

00:34:12,560 --> 00:34:15,119
and while a lot of that stuff is

00:34:13,839 --> 00:34:16,879
changing there's still a lot of

00:34:15,119 --> 00:34:18,079
idiomatic conventions and

00:34:16,879 --> 00:34:20,320
some things you just can't be done

00:34:18,079 --> 00:34:22,960
without without compiler support

00:34:20,320 --> 00:34:23,839
um and so this is what compiler support

00:34:22,960 --> 00:34:26,639
kind of looks like

00:34:23,839 --> 00:34:27,520
that under under is under union right

00:34:26,639 --> 00:34:30,320
you know how they

00:34:27,520 --> 00:34:32,839
keep talking about those reserved words

00:34:30,320 --> 00:34:35,200
that they're allowed to use

00:34:32,839 --> 00:34:37,359
anyway okay

00:34:35,200 --> 00:34:39,200
so this one is going to be kind of fun

00:34:37,359 --> 00:34:42,159
um and um

00:34:39,200 --> 00:34:42,639
is class um now why am i going to do

00:34:42,159 --> 00:34:45,599
this

00:34:42,639 --> 00:34:48,480
i mean usually it's almost always

00:34:45,599 --> 00:34:50,399
implemented as a compiler intrinsic um

00:34:48,480 --> 00:34:51,919
in fact most of the type traits nowadays

00:34:50,399 --> 00:34:52,480
are implemented as compiler intrinsics

00:34:51,919 --> 00:34:54,639
because

00:34:52,480 --> 00:34:56,079
it's much the compiler is much faster

00:34:54,639 --> 00:34:57,680
dealing with intrinsics than dealing

00:34:56,079 --> 00:35:00,839
with even the simplest um

00:34:57,680 --> 00:35:04,160
the simplest template stuff so

00:35:00,839 --> 00:35:05,839
um and without the compiler assistance

00:35:04,160 --> 00:35:08,960
it's kind of impossible to distinguish

00:35:05,839 --> 00:35:12,400
between union and non-union class types

00:35:08,960 --> 00:35:14,960
um but we already have is union

00:35:12,400 --> 00:35:16,000
i mean we just saw his union we got help

00:35:14,960 --> 00:35:18,320
from the compiler to implement

00:35:16,000 --> 00:35:20,160
that one um and there are some

00:35:18,320 --> 00:35:22,960
interesting things that we can learn

00:35:20,160 --> 00:35:25,280
in implementing um is class remember i'm

00:35:22,960 --> 00:35:27,760
not trying to show you how to replace

00:35:25,280 --> 00:35:29,119
the standard library you should use the

00:35:27,760 --> 00:35:30,560
standard library you should use the type

00:35:29,119 --> 00:35:32,160
traits in the standard library

00:35:30,560 --> 00:35:33,599
what i'm trying to show you is trying to

00:35:32,160 --> 00:35:35,680
help you

00:35:33,599 --> 00:35:37,359
understand what they're doing so you can

00:35:35,680 --> 00:35:38,880
write your own but also so you can more

00:35:37,359 --> 00:35:42,839
confidently use them

00:35:38,880 --> 00:35:47,200
on your own in your programming so

00:35:42,839 --> 00:35:49,200
um if we could tell

00:35:47,200 --> 00:35:50,800
the difference between a union or a

00:35:49,200 --> 00:35:52,240
class or if we could tell

00:35:50,800 --> 00:35:54,320
at least be able to group them into a

00:35:52,240 --> 00:35:56,720
category right there's these 14

00:35:54,320 --> 00:35:58,640
different unique types and if we could

00:35:56,720 --> 00:36:02,160
separate the ones that are

00:35:58,640 --> 00:36:02,880
either union or class i i i i know that

00:36:02,160 --> 00:36:04,160
i know without

00:36:02,880 --> 00:36:06,160
help from the compiler i can't tell that

00:36:04,160 --> 00:36:07,200
there's 20 union or class but maybe i

00:36:06,160 --> 00:36:09,839
can

00:36:07,200 --> 00:36:11,760
at least group those two off from the

00:36:09,839 --> 00:36:15,119
rest of the herd

00:36:11,760 --> 00:36:18,480
and each type must be in exactly one

00:36:15,119 --> 00:36:20,560
of 14 categories right so

00:36:18,480 --> 00:36:22,160
each one of them has to be in exactly

00:36:20,560 --> 00:36:26,000
each type has to be in

00:36:22,160 --> 00:36:30,000
exactly one so um i know that if

00:36:26,000 --> 00:36:33,920
the type is either a union

00:36:30,000 --> 00:36:35,440
or a class then i can say oh

00:36:33,920 --> 00:36:38,480
discount the ones that are union because

00:36:35,440 --> 00:36:40,240
i already have that meta function

00:36:38,480 --> 00:36:41,839
so let's uh let's try and learn some

00:36:40,240 --> 00:36:43,520
things and this is where we get into the

00:36:41,839 --> 00:36:44,880
kind of the deeper end of the pool we've

00:36:43,520 --> 00:36:46,079
kind of been in the shallow end

00:36:44,880 --> 00:36:48,240
we're just gonna cross over we're

00:36:46,079 --> 00:36:50,079
crossing over like the little line

00:36:48,240 --> 00:36:51,599
and you know you might you might step

00:36:50,079 --> 00:36:53,680
over your head a little bit but

00:36:51,599 --> 00:36:55,119
uh but there's the lifeguard on duty

00:36:53,680 --> 00:36:56,320
somewhere and they'll throw you a little

00:36:55,119 --> 00:36:59,359
unicorn ring

00:36:56,320 --> 00:37:00,560
um so you know what do we know about

00:36:59,359 --> 00:37:03,680
unions and classes

00:37:00,560 --> 00:37:06,960
that's unique to just those types

00:37:03,680 --> 00:37:09,280
well they can have members

00:37:06,960 --> 00:37:10,240
nothing else can have members right a

00:37:09,280 --> 00:37:12,400
class well

00:37:10,240 --> 00:37:13,599
a struct but str struct is considered a

00:37:12,400 --> 00:37:15,440
class

00:37:13,599 --> 00:37:16,960
classes and unions they're the only ones

00:37:15,440 --> 00:37:19,200
that can have members so if we can

00:37:16,960 --> 00:37:20,960
devise a way to detect if a type can

00:37:19,200 --> 00:37:24,079
have a member

00:37:20,960 --> 00:37:27,920
then we're golden so how can you tell

00:37:24,079 --> 00:37:29,839
if a class has a member um well

00:37:27,920 --> 00:37:32,240
if it has a member it can have a pointer

00:37:29,839 --> 00:37:33,440
to a member and the syntax for a pointer

00:37:32,240 --> 00:37:35,599
to member

00:37:33,440 --> 00:37:36,560
is valid for any class even without

00:37:35,599 --> 00:37:39,280
members

00:37:36,560 --> 00:37:40,320
so if as long as you just have a struct

00:37:39,280 --> 00:37:42,960
you can construct

00:37:40,320 --> 00:37:46,240
you can create a type that represents a

00:37:42,960 --> 00:37:46,240
pointer to one of its members

00:37:47,200 --> 00:37:51,200
a question does is union consider stood

00:37:49,839 --> 00:37:54,400
variant as a union

00:37:51,200 --> 00:37:56,800
no and the reason is because every

00:37:54,400 --> 00:37:58,400
type belongs to exactly one of the

00:37:56,800 --> 00:38:01,040
primary type categories

00:37:58,400 --> 00:38:01,760
and stood variant is belongs to class

00:38:01,040 --> 00:38:03,440
it's

00:38:01,760 --> 00:38:05,440
not belong to union just like is

00:38:03,440 --> 00:38:07,200
function does not include stood function

00:38:05,440 --> 00:38:08,960
and this pointer does not include smart

00:38:07,200 --> 00:38:10,480
pointers it doesn't include shared

00:38:08,960 --> 00:38:13,599
pointer and all that stuff

00:38:10,480 --> 00:38:15,359
um that's a good question um so if we

00:38:13,599 --> 00:38:16,800
can devise a way then what we want to do

00:38:15,359 --> 00:38:18,560
is figure out

00:38:16,800 --> 00:38:20,880
this pointer to member syntax right if i

00:38:18,560 --> 00:38:23,760
can create a type for it

00:38:20,880 --> 00:38:24,720
so int star is a valid pointer type it

00:38:23,760 --> 00:38:26,800
doesn't have anything

00:38:24,720 --> 00:38:27,920
to point to but it doesn't matter it

00:38:26,800 --> 00:38:28,640
doesn't matter if it's pointing to

00:38:27,920 --> 00:38:30,320
anything or not

00:38:28,640 --> 00:38:31,680
it's a valid type and that's remember

00:38:30,320 --> 00:38:32,880
we're dealing in the type system

00:38:31,680 --> 00:38:34,560
it doesn't matter if it has something to

00:38:32,880 --> 00:38:35,359
point to what matters is can we

00:38:34,560 --> 00:38:36,800
represent

00:38:35,359 --> 00:38:38,480
that it could possibly point to

00:38:36,800 --> 00:38:41,520
something so

00:38:38,480 --> 00:38:44,240
if we have a class foo then int

00:38:41,520 --> 00:38:45,359
foo colon cohen star is a member pointer

00:38:44,240 --> 00:38:48,079
type

00:38:45,359 --> 00:38:49,200
it's pointing to a member of type int it

00:38:48,079 --> 00:38:52,240
doesn't matter if foo

00:38:49,200 --> 00:38:53,839
has an actual member of type internet we

00:38:52,240 --> 00:38:57,440
can still construct

00:38:53,839 --> 00:39:00,480
the type of pointer to it

00:38:57,440 --> 00:39:04,640
so have an empty struct

00:39:00,480 --> 00:39:04,640
it has no members of any kind

00:39:04,960 --> 00:39:08,079
an empty struct bar with no members of

00:39:07,280 --> 00:39:11,599
any kind

00:39:08,079 --> 00:39:14,560
i can still create a pointer

00:39:11,599 --> 00:39:15,920
to it right i can create a type that's a

00:39:14,560 --> 00:39:17,760
pointer to it

00:39:15,920 --> 00:39:19,599
but i can't create this one this one's

00:39:17,760 --> 00:39:21,359
going to generate a hard compiler error

00:39:19,599 --> 00:39:23,839
because you can't create a member

00:39:21,359 --> 00:39:24,720
pointer to a long that doesn't make any

00:39:23,839 --> 00:39:26,560
sense it doesn't

00:39:24,720 --> 00:39:27,920
it can't have members so if we can

00:39:26,560 --> 00:39:28,640
figure out how to do that then we're

00:39:27,920 --> 00:39:30,480
golden

00:39:28,640 --> 00:39:32,000
and what we're going to do is we're

00:39:30,480 --> 00:39:33,359
going to learn about

00:39:32,000 --> 00:39:35,599
about the thing that you've all been

00:39:33,359 --> 00:39:36,800
waiting for um but nobody's nobody's

00:39:35,599 --> 00:39:42,320
really said it

00:39:36,800 --> 00:39:46,400
um i'm going to say it in a minute um

00:39:42,320 --> 00:39:48,160
so before we get to it though i want to

00:39:46,400 --> 00:39:51,359
talk about something called function

00:39:48,160 --> 00:39:53,200
overload resolution

00:39:51,359 --> 00:39:54,960
um and to do that we're going to

00:39:53,200 --> 00:39:56,000
re-implement is null pointer in a

00:39:54,960 --> 00:39:57,839
different way completely different

00:39:56,000 --> 00:39:59,280
way all right we're going to say we're

00:39:57,839 --> 00:40:00,880
going to re-implement

00:39:59,280 --> 00:40:02,480
is no pointer and we're going to say

00:40:00,880 --> 00:40:05,040
that is no pointer

00:40:02,480 --> 00:40:06,880
is the result of calling this function

00:40:05,040 --> 00:40:09,280
so decltype says

00:40:06,880 --> 00:40:11,119
pre compiler pretend that you're

00:40:09,280 --> 00:40:12,560
actually calling this function

00:40:11,119 --> 00:40:14,640
give me the type that you would have

00:40:12,560 --> 00:40:15,040
returned if you call it but don't call

00:40:14,640 --> 00:40:16,640
it

00:40:15,040 --> 00:40:18,160
i mean note that those two functions up

00:40:16,640 --> 00:40:21,680
there aren't even implemented

00:40:18,160 --> 00:40:23,599
so decl type um decl type just says

00:40:21,680 --> 00:40:25,599
compiler pretend you're gonna call these

00:40:23,599 --> 00:40:27,040
functions if you called them what type

00:40:25,599 --> 00:40:30,880
would you return

00:40:27,040 --> 00:40:33,200
and this deco vowel it basically takes t

00:40:30,880 --> 00:40:34,880
and converts it to a reference type now

00:40:33,200 --> 00:40:36,960
it can only be used in unevaluated

00:40:34,880 --> 00:40:39,680
contexts like this one

00:40:36,960 --> 00:40:40,960
and so this alias asked the compiler to

00:40:39,680 --> 00:40:44,240
pretend

00:40:40,960 --> 00:40:46,720
that it was making an instance of a type

00:40:44,240 --> 00:40:48,800
and passing it into those functions and

00:40:46,720 --> 00:40:53,119
it was asking if it was no putter

00:40:48,800 --> 00:40:56,240
and what type would it return now

00:40:53,119 --> 00:40:59,520
um if we look at here

00:40:56,240 --> 00:41:03,200
and we see is no pointer of

00:40:59,520 --> 00:41:05,839
int we should be able to see clearly

00:41:03,200 --> 00:41:06,240
that is no pointer of int it can't call

00:41:05,839 --> 00:41:09,680
is

00:41:06,240 --> 00:41:09,680
it can't call the

00:41:11,040 --> 00:41:14,800
it of int it can't call this one because

00:41:13,760 --> 00:41:16,800
you can't convert an

00:41:14,800 --> 00:41:18,319
int into a null putter you can't do it

00:41:16,800 --> 00:41:19,680
so the only one they can call is the one

00:41:18,319 --> 00:41:22,880
is the purple one

00:41:19,680 --> 00:41:25,440
right and it should be quite clear

00:41:22,880 --> 00:41:26,640
that this one can only call that one i

00:41:25,440 --> 00:41:29,040
mean we'll call that one

00:41:26,640 --> 00:41:31,040
now it can call this one as well it can

00:41:29,040 --> 00:41:34,160
call the one with the ellipsis

00:41:31,040 --> 00:41:36,880
so in this case what happens is that

00:41:34,160 --> 00:41:38,880
both functions are valid remember

00:41:36,880 --> 00:41:42,560
earlier we were we were talking about

00:41:38,880 --> 00:41:44,400
template specializations where two

00:41:42,560 --> 00:41:45,760
two and two specializations were both

00:41:44,400 --> 00:41:46,160
valid and the compiler picked the best

00:41:45,760 --> 00:41:47,760
one

00:41:46,160 --> 00:41:49,599
well this is similar this is this but

00:41:47,760 --> 00:41:52,720
it's overload resolution for functions

00:41:49,599 --> 00:41:55,839
rather than for those template classes

00:41:52,720 --> 00:41:57,599
and so it's you know it basically goes

00:41:55,839 --> 00:41:59,599
in and it says hey which one has the

00:41:57,599 --> 00:42:01,359
which one has the best match

00:41:59,599 --> 00:42:03,280
uh which one of these functions am i

00:42:01,359 --> 00:42:06,480
going to call and it picks it

00:42:03,280 --> 00:42:08,880
and the dot dot dot will match anything

00:42:06,480 --> 00:42:09,680
it'll match any number of any things but

00:42:08,880 --> 00:42:13,200
it's always

00:42:09,680 --> 00:42:13,680
the worst priority it will only ever be

00:42:13,200 --> 00:42:16,000
used

00:42:13,680 --> 00:42:17,200
if nothing else matches it'll only ever

00:42:16,000 --> 00:42:18,160
be used if it's the only one that

00:42:17,200 --> 00:42:20,240
matches

00:42:18,160 --> 00:42:22,160
and in this case both of them match so

00:42:20,240 --> 00:42:23,760
no putter gets called

00:42:22,160 --> 00:42:26,079
the overload resolution is important to

00:42:23,760 --> 00:42:27,920
understand when you start dealing with

00:42:26,079 --> 00:42:29,040
advanced meta program techniques it

00:42:27,920 --> 00:42:30,240
actually is important to understand no

00:42:29,040 --> 00:42:31,839
matter what you're doing in c plus plus

00:42:30,240 --> 00:42:32,400
because it comes up in a lot of things

00:42:31,839 --> 00:42:35,920
not just

00:42:32,400 --> 00:42:38,480
in this um so let's look at one

00:42:35,920 --> 00:42:40,319
that uh another type that we've seen

00:42:38,480 --> 00:42:42,800
before is const

00:42:40,319 --> 00:42:44,480
now this time is const we implement it

00:42:42,800 --> 00:42:45,200
in a little different way and we use a

00:42:44,480 --> 00:42:49,440
technique called

00:42:45,200 --> 00:42:51,280
tag dispatch now tag dispatch is

00:42:49,440 --> 00:42:52,640
is where we're creating a type that's

00:42:51,280 --> 00:42:53,760
just being used as a tag and we're going

00:42:52,640 --> 00:42:55,760
to use type identity

00:42:53,760 --> 00:42:56,800
because type identity is a type you can

00:42:55,760 --> 00:42:58,880
instantiate it

00:42:56,800 --> 00:43:00,400
and you can pass it around and it holds

00:42:58,880 --> 00:43:02,560
no it takes no space

00:43:00,400 --> 00:43:04,240
um it's very efficient to pass pass

00:43:02,560 --> 00:43:06,160
these guys around

00:43:04,240 --> 00:43:07,440
now i don't recommend or encourage this

00:43:06,160 --> 00:43:10,240
version of his const

00:43:07,440 --> 00:43:10,800
i'm showing it to you to demonstrate um

00:43:10,240 --> 00:43:12,880
how

00:43:10,800 --> 00:43:14,000
this technique is used so there's our

00:43:12,880 --> 00:43:15,839
deco val again

00:43:14,000 --> 00:43:17,520
i'm creating an instance of type

00:43:15,839 --> 00:43:21,040
identity t

00:43:17,520 --> 00:43:23,119
okay i'm i'm gonna construct

00:43:21,040 --> 00:43:24,800
pretend that i'm constructing an

00:43:23,119 --> 00:43:26,160
instance of type identity t

00:43:24,800 --> 00:43:28,720
so that's going to return to me a

00:43:26,160 --> 00:43:30,880
reference to type identity t

00:43:28,720 --> 00:43:32,319
and then the decal type is going to mean

00:43:30,880 --> 00:43:35,440
i'm going to pretend to call

00:43:32,319 --> 00:43:37,359
is const with it and one of those two

00:43:35,440 --> 00:43:41,119
functions is going to be called

00:43:37,359 --> 00:43:43,839
now in the first case

00:43:41,119 --> 00:43:45,599
um i get a match it's no putter it

00:43:43,839 --> 00:43:47,760
doesn't have a const anywhere in it

00:43:45,599 --> 00:43:48,880
so that's the that's the only one that

00:43:47,760 --> 00:43:50,480
matches

00:43:48,880 --> 00:43:52,079
and so that's the one that's caused and

00:43:50,480 --> 00:43:54,880
so we get false

00:43:52,079 --> 00:43:55,680
on the second one however both of them

00:43:54,880 --> 00:43:58,000
will match

00:43:55,680 --> 00:43:59,200
but this one will be a better match and

00:43:58,000 --> 00:44:02,400
so that's the one

00:43:59,200 --> 00:44:05,520
that will get called now

00:44:02,400 --> 00:44:08,560
here's the big word the savine word now

00:44:05,520 --> 00:44:11,760
that word that that the word the acronym

00:44:08,560 --> 00:44:14,960
came about in this book

00:44:11,760 --> 00:44:16,720
by david van devord i i know i

00:44:14,960 --> 00:44:18,800
must mastered his name but i bought his

00:44:16,720 --> 00:44:21,440
book and i bought every book that he and

00:44:18,800 --> 00:44:23,040
uh nikolai have written so um forgive me

00:44:21,440 --> 00:44:26,640
for masking your name

00:44:23,040 --> 00:44:29,839
um so this sphene

00:44:26,640 --> 00:44:32,960
stands for substitution failure is

00:44:29,839 --> 00:44:33,359
not an error and what it means is that

00:44:32,960 --> 00:44:36,560
under

00:44:33,359 --> 00:44:39,280
certain contexts when the compiler

00:44:36,560 --> 00:44:40,640
is binding an expression to a template

00:44:39,280 --> 00:44:43,599
parameter

00:44:40,640 --> 00:44:46,000
then an error that normally would have

00:44:43,599 --> 00:44:49,839
generated a compiler error

00:44:46,000 --> 00:44:52,400
doesn't generate the error it just

00:44:49,839 --> 00:44:53,680
forgets about it and moves on right it's

00:44:52,400 --> 00:44:55,040
a jedi trick

00:44:53,680 --> 00:44:58,079
you know this is not the area you're

00:44:55,040 --> 00:44:59,760
looking it's just that that go away

00:44:58,079 --> 00:45:01,680
but it's a specific context it's not

00:44:59,760 --> 00:45:03,119
every context but it's a very specific

00:45:01,680 --> 00:45:06,319
context

00:45:03,119 --> 00:45:08,720
so in our previous examples

00:45:06,319 --> 00:45:11,040
both functions were valid both functions

00:45:08,720 --> 00:45:12,480
compiled and the compiler picked the one

00:45:11,040 --> 00:45:14,480
that best matched

00:45:12,480 --> 00:45:16,160
but what if we want to match something

00:45:14,480 --> 00:45:20,240
that may not be a valid c

00:45:16,160 --> 00:45:22,560
plus plus construct i mean like say

00:45:20,240 --> 00:45:23,839
a pointer to a member since that's what

00:45:22,560 --> 00:45:24,800
we're trying to figure out we're trying

00:45:23,839 --> 00:45:27,200
to deduce

00:45:24,800 --> 00:45:28,319
um you can't just pass anything to a

00:45:27,200 --> 00:45:29,599
pointer to member because you're going

00:45:28,319 --> 00:45:31,520
to get a compiler error

00:45:29,599 --> 00:45:34,000
so let's walk through what happens in a

00:45:31,520 --> 00:45:37,040
couple of examples

00:45:34,000 --> 00:45:40,880
here we're explicitly providing

00:45:37,040 --> 00:45:44,640
a foo into can have pointer to member

00:45:40,880 --> 00:45:46,640
right and when we do that

00:45:44,640 --> 00:45:48,240
we get both of these functions the

00:45:46,640 --> 00:45:48,880
compiler is going to spit out both of

00:45:48,240 --> 00:45:50,800
these

00:45:48,880 --> 00:45:51,920
okay it's going to spit out can't have

00:45:50,800 --> 00:45:54,000
pointer member foo

00:45:51,920 --> 00:45:56,079
ant bar star and it's going to spit out

00:45:54,000 --> 00:45:58,160
can have pointer to member foo

00:45:56,079 --> 00:45:59,680
dot dot both of them are going to be

00:45:58,160 --> 00:46:01,440
valid

00:45:59,680 --> 00:46:02,720
and the compiler will pick the one

00:46:01,440 --> 00:46:05,040
that's the better match which is going

00:46:02,720 --> 00:46:09,280
to be the one with the member pointer

00:46:05,040 --> 00:46:12,319
the pointer to member now

00:46:09,280 --> 00:46:13,200
if we look at it with another one

00:46:12,319 --> 00:46:14,800
instead of pat

00:46:13,200 --> 00:46:16,480
because the last time we passed it foo

00:46:14,800 --> 00:46:18,079
right we foo which was a class

00:46:16,480 --> 00:46:20,720
this time we're going to pass it int

00:46:18,079 --> 00:46:22,640
which is an integer it's not a class

00:46:20,720 --> 00:46:24,319
and so what happens is the compiler is

00:46:22,640 --> 00:46:25,119
still going to try and spit out both of

00:46:24,319 --> 00:46:27,359
these

00:46:25,119 --> 00:46:28,960
right it's going to say hey i'm gonna

00:46:27,359 --> 00:46:32,000
try and instantiate both of those

00:46:28,960 --> 00:46:33,520
uh function templates but the one when i

00:46:32,000 --> 00:46:36,000
try to instantiate it with the

00:46:33,520 --> 00:46:37,520
one that i try to instantiate within it

00:46:36,000 --> 00:46:39,520
that right there

00:46:37,520 --> 00:46:41,599
that ain't c plus plus it's gonna barf

00:46:39,520 --> 00:46:43,280
on that it's not gonna compile that

00:46:41,599 --> 00:46:45,119
and so we're going to get a compiler

00:46:43,280 --> 00:46:47,760
error that's not quite what we want we

00:46:45,119 --> 00:46:51,520
don't want to compile here

00:46:47,760 --> 00:46:54,240
but you remember what i said about

00:46:51,520 --> 00:46:55,200
the reason when substitution failure is

00:46:54,240 --> 00:46:58,400
not an error

00:46:55,200 --> 00:47:01,520
it's when you are substituting for

00:46:58,400 --> 00:47:02,240
a template parameter so let's create an

00:47:01,520 --> 00:47:04,400
error

00:47:02,240 --> 00:47:06,000
an extra level of indirection and create

00:47:04,400 --> 00:47:08,960
our template parameter

00:47:06,000 --> 00:47:11,040
specifically we're going to create this

00:47:08,960 --> 00:47:13,440
one

00:47:11,040 --> 00:47:13,440
right here

00:47:15,920 --> 00:47:19,119
and we're going to call can have pointer

00:47:18,240 --> 00:47:22,839
to member

00:47:19,119 --> 00:47:25,200
with a deduced type with t a dependent

00:47:22,839 --> 00:47:26,400
type now down here we're still going to

00:47:25,200 --> 00:47:27,920
call this within

00:47:26,400 --> 00:47:29,760
right i'm still i haven't changed this

00:47:27,920 --> 00:47:31,599
at all i'm still calling this within

00:47:29,760 --> 00:47:32,960
but instead i'm going to call this

00:47:31,599 --> 00:47:34,800
template alias

00:47:32,960 --> 00:47:36,640
right we can we're doing abstraction

00:47:34,800 --> 00:47:40,240
stuff we can create one of these

00:47:36,640 --> 00:47:44,480
i'm going to call that guy okay

00:47:40,240 --> 00:47:47,920
and by and by calling that guy

00:47:44,480 --> 00:47:49,760
i'm gonna have a deduced context okay

00:47:47,920 --> 00:47:52,079
so i'm gonna have a context where spinae

00:47:49,760 --> 00:47:55,680
can come in okay so

00:47:52,079 --> 00:47:56,559
let me let me try to um uh recount this

00:47:55,680 --> 00:47:59,680
again

00:47:56,559 --> 00:48:02,160
um the

00:47:59,680 --> 00:48:03,280
the template parameter that we've added

00:48:02,160 --> 00:48:07,040
let me go back and

00:48:03,280 --> 00:48:10,319
put this up this template parameter this

00:48:07,040 --> 00:48:13,839
this alias template that we have added

00:48:10,319 --> 00:48:14,960
that this guy calls means that when this

00:48:13,839 --> 00:48:17,520
ent

00:48:14,960 --> 00:48:19,119
when this int gets substituted for that

00:48:17,520 --> 00:48:21,680
t

00:48:19,119 --> 00:48:22,960
now we've got a substitution occurring

00:48:21,680 --> 00:48:26,079
i'm saying

00:48:22,960 --> 00:48:29,839
instantiate this template and

00:48:26,079 --> 00:48:32,559
force it to have an an int into this t

00:48:29,839 --> 00:48:34,000
well in the previous slide this context

00:48:32,559 --> 00:48:35,839
when we recalled it in the previous

00:48:34,000 --> 00:48:37,280
context we tried to call this thing

00:48:35,839 --> 00:48:38,960
directly from here

00:48:37,280 --> 00:48:40,319
it wouldn't let us it gave us an error

00:48:38,960 --> 00:48:42,880
and that's because we were

00:48:40,319 --> 00:48:45,680
we were directly shoving the intent but

00:48:42,880 --> 00:48:45,680
in this case

00:48:46,480 --> 00:48:50,160
right here we're substituting it for a

00:48:48,800 --> 00:48:51,520
template parameter that's why it's

00:48:50,160 --> 00:48:54,400
called substitution

00:48:51,520 --> 00:48:56,880
failure is not an error so the error

00:48:54,400 --> 00:48:59,680
isn't that this doesn't compile

00:48:56,880 --> 00:49:00,079
the error is that when you substitute an

00:48:59,680 --> 00:49:02,960
int

00:49:00,079 --> 00:49:03,680
for t when you try to plug it an int in

00:49:02,960 --> 00:49:06,880
for this t

00:49:03,680 --> 00:49:10,800
this doesn't compile so the substitution

00:49:06,880 --> 00:49:13,200
fails and when the substitution fails

00:49:10,800 --> 00:49:14,160
then it means that that's not going to

00:49:13,200 --> 00:49:17,440
be

00:49:14,160 --> 00:49:20,000
valid so when we try to call this

00:49:17,440 --> 00:49:21,599
when we try to call this with this guy

00:49:20,000 --> 00:49:22,800
and we pass it an int

00:49:21,599 --> 00:49:24,800
we're going to still get the same

00:49:22,800 --> 00:49:27,119
compiler error we got before but the

00:49:24,800 --> 00:49:29,440
compiler is going to swallow it

00:49:27,119 --> 00:49:30,800
because it says hey i got this com i

00:49:29,440 --> 00:49:32,079
this doesn't make any sense to me i

00:49:30,800 --> 00:49:36,240
can't compile this

00:49:32,079 --> 00:49:36,880
but it occurred as a direct result of me

00:49:36,240 --> 00:49:38,880
trying to

00:49:36,880 --> 00:49:41,119
substitute a type for a template

00:49:38,880 --> 00:49:42,960
parameter and because of that

00:49:41,119 --> 00:49:45,839
it's not an error and i'm going to go

00:49:42,960 --> 00:49:45,839
away

00:49:46,160 --> 00:49:52,400
now there we go he says these are not

00:49:50,000 --> 00:49:54,960
the airs you're looking for

00:49:52,400 --> 00:49:54,960
move along

00:49:55,680 --> 00:50:02,319
now with this in hand we can

00:49:59,680 --> 00:50:03,680
try to implement this class it's very

00:50:02,319 --> 00:50:06,319
simple actually but we need to

00:50:03,680 --> 00:50:09,520
understand the ideas behind sphine

00:50:06,319 --> 00:50:11,359
and trying to get to spinae um there's a

00:50:09,520 --> 00:50:12,079
lot of ways of implementing this is

00:50:11,359 --> 00:50:13,440
class

00:50:12,079 --> 00:50:14,960
but one of the reasons i did it like

00:50:13,440 --> 00:50:16,000
this is because i wanted to introduce

00:50:14,960 --> 00:50:18,319
you to

00:50:16,000 --> 00:50:19,760
overload set resolution i wanted to

00:50:18,319 --> 00:50:22,000
introduce you to those concepts in

00:50:19,760 --> 00:50:24,640
sphenae particularly in that context

00:50:22,000 --> 00:50:26,000
because that's where it originated and

00:50:24,640 --> 00:50:27,200
now we can use it in lots and lots of

00:50:26,000 --> 00:50:30,400
different ways but

00:50:27,200 --> 00:50:33,599
um but in this case if we look

00:50:30,400 --> 00:50:35,680
at this is class we can see a number of

00:50:33,599 --> 00:50:38,240
things

00:50:35,680 --> 00:50:39,680
now here we have is class that is

00:50:38,240 --> 00:50:42,480
basically saying all right

00:50:39,680 --> 00:50:44,000
this class is a meta function this don't

00:50:42,480 --> 00:50:45,440
look like any meta function we've been

00:50:44,000 --> 00:50:46,880
looking at right this doesn't look like

00:50:45,440 --> 00:50:49,119
a class but

00:50:46,880 --> 00:50:50,720
it's gonna it's gonna say compiler

00:50:49,119 --> 00:50:53,760
pretend that you call

00:50:50,720 --> 00:50:55,200
is class or union passing it the t with

00:50:53,760 --> 00:50:57,200
the null putter

00:50:55,200 --> 00:50:58,640
which is then going to invoke this is

00:50:57,200 --> 00:51:00,720
class or union

00:50:58,640 --> 00:51:01,839
or this one right depending on which

00:51:00,720 --> 00:51:04,800
depending on the match

00:51:01,839 --> 00:51:06,160
right and it's going to say one of them

00:51:04,800 --> 00:51:08,720
if i pass in a foo

00:51:06,160 --> 00:51:11,200
for this if i pass in a foo both this

00:51:08,720 --> 00:51:12,640
one and this one will be active

00:51:11,200 --> 00:51:14,240
and this one will be selected because

00:51:12,640 --> 00:51:16,160
it's the better match

00:51:14,240 --> 00:51:18,240
and so it will return true that it is a

00:51:16,160 --> 00:51:21,520
class or a union but if i plug an

00:51:18,240 --> 00:51:24,640
int in here if i call it with an int

00:51:21,520 --> 00:51:26,079
then this one will be valid this one

00:51:24,640 --> 00:51:27,119
will not this one will generate a

00:51:26,079 --> 00:51:28,960
compiler error

00:51:27,119 --> 00:51:30,400
but because it generates the compiler

00:51:28,960 --> 00:51:32,640
error as a result

00:51:30,400 --> 00:51:33,680
of directly substituting for this

00:51:32,640 --> 00:51:36,079
template parameter

00:51:33,680 --> 00:51:37,200
that error goes away so this function

00:51:36,079 --> 00:51:39,839
doesn't even exist

00:51:37,200 --> 00:51:40,640
and only this one exists so now we have

00:51:39,839 --> 00:51:45,280
a way

00:51:40,640 --> 00:51:47,760
of turning a compiler error into false

00:51:45,280 --> 00:51:48,800
i think that's kind of cool even now

00:51:47,760 --> 00:51:50,559
after having

00:51:48,800 --> 00:51:51,920
seen this for 20 years i think this is

00:51:50,559 --> 00:51:54,960
kind of cool

00:51:51,920 --> 00:51:56,960
um so we could also so

00:51:54,960 --> 00:51:58,559
we could also implement this class with

00:51:56,960 --> 00:52:00,480
constexpr functions

00:51:58,559 --> 00:52:02,640
right here's the constexpr function that

00:52:00,480 --> 00:52:04,480
returns an actual bull

00:52:02,640 --> 00:52:05,760
they do the same thing they do the same

00:52:04,480 --> 00:52:07,680
sphenae trick

00:52:05,760 --> 00:52:09,359
right they do the exact same phenae trig

00:52:07,680 --> 00:52:11,599
the only difference is this one

00:52:09,359 --> 00:52:13,359
is a bull constant doesn't use decal

00:52:11,599 --> 00:52:16,000
type it's a bull constant

00:52:13,359 --> 00:52:17,520
that calls this constexpr function that

00:52:16,000 --> 00:52:19,440
returns a bull

00:52:17,520 --> 00:52:22,000
and it just fills in the bull in for

00:52:19,440 --> 00:52:24,079
that bull constant

00:52:22,000 --> 00:52:26,319
just an alternative way of handling it

00:52:24,079 --> 00:52:27,520
there's tons and tons and tons of ways

00:52:26,319 --> 00:52:30,880
of doing that

00:52:27,520 --> 00:52:32,000
um so if i had if i have a lot of if i

00:52:30,880 --> 00:52:34,160
have a lot of questions i'll do

00:52:32,000 --> 00:52:35,359
those if not i might try to show you the

00:52:34,160 --> 00:52:38,160
is in pack

00:52:35,359 --> 00:52:39,760
um though i don't want to run over even

00:52:38,160 --> 00:52:42,640
though i lost my

00:52:39,760 --> 00:52:43,359
connection is deco val needed in slide

00:52:42,640 --> 00:52:45,520
00:52:43,359 --> 00:52:46,880
doesn't type identity have a default

00:52:45,520 --> 00:52:51,599
constructor

00:52:46,880 --> 00:52:54,400
um is deco found needed in 79

00:52:51,599 --> 00:52:55,200
is deco valve oh it doesn't need oh you

00:52:54,400 --> 00:52:57,280
know what it

00:52:55,200 --> 00:52:59,200
it it doesn't matter whether it has a

00:52:57,280 --> 00:53:00,400
default constructor or not yes you could

00:52:59,200 --> 00:53:03,040
use it that way

00:53:00,400 --> 00:53:05,040
but uh yes so and so let me go back and

00:53:03,040 --> 00:53:05,680
show what he's what what the question is

00:53:05,040 --> 00:53:09,200
asking

00:53:05,680 --> 00:53:11,440
in slide 79 um

00:53:09,200 --> 00:53:15,839
which uh figure make sure i'm looking at

00:53:11,440 --> 00:53:15,839
the one you're looking at

00:53:16,800 --> 00:53:24,480
okay and 79 um yes so this

00:53:22,000 --> 00:53:25,920
this decal valve yeah technically you

00:53:24,480 --> 00:53:27,200
probably you don't necessarily have to

00:53:25,920 --> 00:53:28,000
have it because you could say type

00:53:27,200 --> 00:53:29,680
identity t

00:53:28,000 --> 00:53:31,440
and then put the little squiggles and it

00:53:29,680 --> 00:53:34,480
has a constructor and it'll do it

00:53:31,440 --> 00:53:35,680
but however the whole con the concept

00:53:34,480 --> 00:53:38,160
with deco val

00:53:35,680 --> 00:53:40,160
is that you it's it's in a totally

00:53:38,160 --> 00:53:43,280
unevaluated context

00:53:40,160 --> 00:53:46,240
and so um my personal

00:53:43,280 --> 00:53:47,520
um after having when duckwell first came

00:53:46,240 --> 00:53:48,960
out and i started playing with it i

00:53:47,520 --> 00:53:50,800
struggled between what my

00:53:48,960 --> 00:53:52,880
what i should do or what i shouldn't

00:53:50,800 --> 00:53:54,800
after having several bugs that cost me a

00:53:52,880 --> 00:53:58,319
lot of time to track down

00:53:54,800 --> 00:54:01,520
my own my own personal uh

00:53:58,319 --> 00:54:03,040
uh convention is that if i'm using

00:54:01,520 --> 00:54:04,480
something in an unvalued context

00:54:03,040 --> 00:54:06,160
i'm gonna use it like that the only

00:54:04,480 --> 00:54:09,520
place i won't use deco val

00:54:06,160 --> 00:54:11,359
isn't is in places like in uh and then

00:54:09,520 --> 00:54:13,359
the auto reduce return type right when

00:54:11,359 --> 00:54:15,440
you specify the return type after it

00:54:13,359 --> 00:54:16,559
and you say decal type there because you

00:54:15,440 --> 00:54:17,200
actually have access to the actual

00:54:16,559 --> 00:54:18,559
variables

00:54:17,200 --> 00:54:20,240
that are the parameters that come in

00:54:18,559 --> 00:54:21,760
through the function but other than that

00:54:20,240 --> 00:54:23,599
i always use deco val

00:54:21,760 --> 00:54:26,480
um even though you can get away without

00:54:23,599 --> 00:54:30,880
it um

00:54:26,480 --> 00:54:30,880
so um

00:54:31,440 --> 00:54:36,640
let me see if i can run through this

00:54:34,559 --> 00:54:40,000
real quick at least put it on

00:54:36,640 --> 00:54:42,079
at least put it on and uh

00:54:40,000 --> 00:54:43,760
um so remember we had this thing called

00:54:42,079 --> 00:54:44,640
uh i don't see any oh wait no maybe i

00:54:43,760 --> 00:54:45,760
should answer these other questions

00:54:44,640 --> 00:54:47,520
that's what i'll do

00:54:45,760 --> 00:54:49,119
is there a way to find out if a class

00:54:47,520 --> 00:54:52,240
has a specific method

00:54:49,119 --> 00:54:54,319
uh yes there is um there's there's the

00:54:52,240 --> 00:54:54,960
old way of querying it and there's kind

00:54:54,319 --> 00:54:57,119
of the

00:54:54,960 --> 00:54:58,400
a new way of doing uh detect there's

00:54:57,119 --> 00:55:00,960
look up um

00:54:58,400 --> 00:55:03,200
uh the is detected mechanism there you

00:55:00,960 --> 00:55:04,640
use you could use uh stood voidt for it

00:55:03,200 --> 00:55:06,160
you could use is detected

00:55:04,640 --> 00:55:07,440
you could depending on the context if

00:55:06,160 --> 00:55:08,000
it's on if you're trying to use it on a

00:55:07,440 --> 00:55:11,040
function

00:55:08,000 --> 00:55:13,680
you could just use the the um

00:55:11,040 --> 00:55:14,799
the decal type the decal type at you put

00:55:13,680 --> 00:55:16,559
an arrow

00:55:14,799 --> 00:55:18,160
right the the trailing return type and

00:55:16,559 --> 00:55:18,720
use decal type and then your context in

00:55:18,160 --> 00:55:20,400
there

00:55:18,720 --> 00:55:21,839
and that that'll give you sphenae

00:55:20,400 --> 00:55:23,040
results as to whether it's actually

00:55:21,839 --> 00:55:26,559
active or not

00:55:23,040 --> 00:55:27,920
um there's lots of ways of doing that

00:55:26,559 --> 00:55:29,680
um can you spend some more time

00:55:27,920 --> 00:55:30,400
explaining the deco valve decal type

00:55:29,680 --> 00:55:35,839
pattern

00:55:30,400 --> 00:55:40,000
um okay so deco decal type

00:55:35,839 --> 00:55:40,000
tells you to pretend that

00:55:40,799 --> 00:55:44,400
um let me go back to one that has both

00:55:42,559 --> 00:55:48,480
decotype and deco val

00:55:44,400 --> 00:55:50,880
which i think was 79 is that one

00:55:48,480 --> 00:55:51,599
i have to get where i'm seeing something

00:55:50,880 --> 00:55:54,960
different

00:55:51,599 --> 00:55:58,799
all right okay there we go 79

00:55:54,960 --> 00:56:00,720
okay so the decal type

00:55:58,799 --> 00:56:01,920
decal type basically see how this

00:56:00,720 --> 00:56:04,079
parenthesis is right there that

00:56:01,920 --> 00:56:06,480
parentheses goes all the way to here

00:56:04,079 --> 00:56:08,559
so everything inside of decal type it

00:56:06,480 --> 00:56:10,079
says all right compiler pretend like

00:56:08,559 --> 00:56:12,559
you're making this call

00:56:10,079 --> 00:56:13,760
evaluate this spread evaluate this

00:56:12,559 --> 00:56:15,359
expression

00:56:13,760 --> 00:56:17,680
doesn't have to be a function call

00:56:15,359 --> 00:56:19,760
evaluate this expression

00:56:17,680 --> 00:56:20,960
and give me the result the type that you

00:56:19,760 --> 00:56:22,319
would get from evaluating that

00:56:20,960 --> 00:56:24,319
expression

00:56:22,319 --> 00:56:26,240
that's all that's what decotype does

00:56:24,319 --> 00:56:26,960
pretend like you called this and give me

00:56:26,240 --> 00:56:28,960
the type

00:56:26,960 --> 00:56:30,240
as if you if you really called this what

00:56:28,960 --> 00:56:32,960
would you give me

00:56:30,240 --> 00:56:34,000
but we're in an unevaluated context we

00:56:32,960 --> 00:56:36,880
can't really make this

00:56:34,000 --> 00:56:38,319
function call and so in an unevaluated

00:56:36,880 --> 00:56:41,119
context

00:56:38,319 --> 00:56:42,640
duckle val is there so that you can grab

00:56:41,119 --> 00:56:44,400
a reference to any type

00:56:42,640 --> 00:56:46,000
and the question earlier about is since

00:56:44,400 --> 00:56:46,960
type identity t didn't have a default

00:56:46,000 --> 00:56:48,640
constructor

00:56:46,960 --> 00:56:50,240
one of the benefits of deco val is it

00:56:48,640 --> 00:56:50,640
doesn't have to have any constructors at

00:56:50,240 --> 00:56:52,000
all

00:56:50,640 --> 00:56:54,079
it just gives you a reference to

00:56:52,000 --> 00:56:55,280
something as if you had created one as

00:56:54,079 --> 00:56:57,520
if you had one

00:56:55,280 --> 00:56:58,480
but duck but this is an unevaluated

00:56:57,520 --> 00:57:00,240
context

00:56:58,480 --> 00:57:02,079
and so deco vowel can be called in an

00:57:00,240 --> 00:57:03,440
unevaluated context it's just a

00:57:02,079 --> 00:57:04,400
declaration it's there's no

00:57:03,440 --> 00:57:06,720
implementation

00:57:04,400 --> 00:57:08,240
um it's illegal to try and implement it

00:57:06,720 --> 00:57:09,599
i mean to try and instantiate it it's

00:57:08,240 --> 00:57:14,160
illegal to try and have one

00:57:09,599 --> 00:57:16,240
so this decal valve says

00:57:14,160 --> 00:57:17,359
the stuff inside of this of these angle

00:57:16,240 --> 00:57:19,359
brackets

00:57:17,359 --> 00:57:20,400
i want you to pretend that you've

00:57:19,359 --> 00:57:22,559
created one of those

00:57:20,400 --> 00:57:24,079
and return a reference that's really all

00:57:22,559 --> 00:57:26,799
it does

00:57:24,079 --> 00:57:29,040
deco valve's implementation is add a

00:57:26,799 --> 00:57:31,440
reference to whatever you get here

00:57:29,040 --> 00:57:32,559
if what you have is a is is a value then

00:57:31,440 --> 00:57:33,440
you're going to have an r value

00:57:32,559 --> 00:57:35,119
reference like here

00:57:33,440 --> 00:57:37,520
this will return an r value reference to

00:57:35,119 --> 00:57:39,680
t right this will basically return

00:57:37,520 --> 00:57:41,040
this std deco vowel right there will

00:57:39,680 --> 00:57:44,960
basically return

00:57:41,040 --> 00:57:46,960
um type identity t ref ref

00:57:44,960 --> 00:57:48,319
okay that's that's all it's doing it's

00:57:46,960 --> 00:57:49,040
returning a reference so that it could

00:57:48,319 --> 00:57:52,720
be used

00:57:49,040 --> 00:57:52,720
and passed to this is const

00:57:52,839 --> 00:57:58,319
um is there a way the slides can be made

00:57:56,720 --> 00:58:02,400
available for reference

00:57:58,319 --> 00:58:04,720
uh that's a good question i imagine that

00:58:02,400 --> 00:58:05,920
i imagine that they have a imagine that

00:58:04,720 --> 00:58:07,359
there's probably put them in the github

00:58:05,920 --> 00:58:08,559
or something and so i'll make them i'll

00:58:07,359 --> 00:58:10,640
make them available

00:58:08,559 --> 00:58:11,920
um i don't know if i don't i don't know

00:58:10,640 --> 00:58:13,520
if i don't know what i can do to try and

00:58:11,920 --> 00:58:15,040
make all the little graphic-y things in

00:58:13,520 --> 00:58:18,079
there but i don't know if they'll

00:58:15,040 --> 00:58:20,240
i don't know about that but um i'm sure

00:58:18,079 --> 00:58:21,440
cppcon will have them available in some

00:58:20,240 --> 00:58:23,520
way um

00:58:21,440 --> 00:58:25,040
i'm i'm out of time i apologize for

00:58:23,520 --> 00:58:26,160
losing my connection earlier i really

00:58:25,040 --> 00:58:28,880
really am sorry

00:58:26,160 --> 00:58:30,160
um i had i i i know i had way much more

00:58:28,880 --> 00:58:31,599
material than i was going to cover

00:58:30,160 --> 00:58:33,839
because i wanted to make sure i answered

00:58:31,599 --> 00:58:36,160
any questions that you had um i will

00:58:33,839 --> 00:58:38,240
i will be around um you know find me if

00:58:36,160 --> 00:58:40,000
you if you have any more questions and

00:58:38,240 --> 00:58:41,839
um if there's enough interest in more

00:58:40,000 --> 00:58:43,839
questions maybe maybe we'll do one of

00:58:41,839 --> 00:58:44,640
these ama things so you can ask specific

00:58:43,839 --> 00:58:46,799
questions

00:58:44,640 --> 00:58:49,599
about this type of stuff i don't know i

00:58:46,799 --> 00:59:05,839
want to get asked about anything but

00:58:49,599 --> 00:59:05,839
okay thank you

00:59:11,680 --> 00:59:13,760

YouTube URL: https://www.youtube.com/watch?v=dLZcocFOb5Q


