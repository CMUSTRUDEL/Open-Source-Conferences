Title: Plenary: The Beauty and Power of "Primitive" C++ - Bjarne Stroustrup - CppCon 2020
Publication date: 2020-09-24
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/the_powr_and_beauty_of_primitive_c/the_powr_and_beauty_of_primitive_c__bjarne_stroustrup__cppcon_2020.pdf
---
Often, we focus on novel, clever, and advanced features of C++. To contrast, here I look at addressing relatively simple problems in relatively simple ways under severe constraints of performance, ease of use, and reliability. My main example is to read and write typed objects from and to a byte buffer. This is of course something we do a lot and in a bewildering variety of ways. Any object that needs to be stored or transmitted to another computer must go through such a process. However, the constrains on such reading and writing varies immensely based on the kind of data to be moved around, the performance and reliability requirements, the hardware available, and history. Many trade-offs are possible, and many different interfaces. That makes this an interesting design exercise.

This is an exploration of a design space close to the hardware and of the use of C++ in that space, rather than a standards proposal or the presentation of a mature tool chain. And, no, by “primitive”, I don’t mean “old-fashioned, C-like” code; some of the general techniques are old, but some of the code requires C++17 and much could be done better given features we are unlikely to get even in C++23.

---
Bjarne Stroustrup
Technical fellow, morgan stanley
C++: history, design, use, standardization, future; performance, reliability; software developer education; distributed systems
Bio: www.stroustrup.com/bio.html

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:14,320
hello

00:00:10,320 --> 00:00:14,320
um so

00:00:15,440 --> 00:00:19,359
i hope you're all there can't see you

00:00:17,920 --> 00:00:22,560
but uh

00:00:19,359 --> 00:00:25,920
i'm going to uh give this talk about

00:00:22,560 --> 00:00:29,679
c plus this this year is

00:00:25,920 --> 00:00:30,400
uh is is different uh very different

00:00:29,679 --> 00:00:34,160
from

00:00:30,400 --> 00:00:34,960
uh previous years and i sort of missed

00:00:34,160 --> 00:00:38,000
the

00:00:34,960 --> 00:00:39,920
coffee and the rock band and being able

00:00:38,000 --> 00:00:42,960
to chat with everybody

00:00:39,920 --> 00:00:45,520
and see people face to face and chat

00:00:42,960 --> 00:00:46,239
but it's not going to happen this year

00:00:45,520 --> 00:00:48,079
and so

00:00:46,239 --> 00:00:49,440
i thought this talk should also be

00:00:48,079 --> 00:00:51,760
something different i'm

00:00:49,440 --> 00:00:54,719
not going to give any grand philosophy

00:00:51,760 --> 00:00:57,360
and not going to talk about the standard

00:00:54,719 --> 00:00:59,120
i'm just going to play this on code

00:00:57,360 --> 00:01:01,520
unfortunately

00:00:59,120 --> 00:01:04,080
that was a good idea and i have two or

00:01:01,520 --> 00:01:07,360
three hours worth of material

00:01:04,080 --> 00:01:07,840
and one hour to deliver it so we'll see

00:01:07,360 --> 00:01:10,720
how this

00:01:07,840 --> 00:01:10,720
all works out

00:01:10,960 --> 00:01:14,560
first i'm going to talk about what the

00:01:12,720 --> 00:01:16,960
problem is

00:01:14,560 --> 00:01:19,040
which is mapping type updates to and

00:01:16,960 --> 00:01:20,960
from bytes in a message

00:01:19,040 --> 00:01:24,799
then i'm going to look at the general

00:01:20,960 --> 00:01:28,000
design some of the implementation

00:01:24,799 --> 00:01:29,920
and then do a bit of um

00:01:28,000 --> 00:01:31,200
sort of general observations of what i

00:01:29,920 --> 00:01:33,680
just did

00:01:31,200 --> 00:01:35,439
uh i was thinking of calling this talk

00:01:33,680 --> 00:01:36,640
fun and frustrations of writing

00:01:35,439 --> 00:01:38,960
low-level code

00:01:36,640 --> 00:01:40,720
but that's not quite right either but

00:01:38,960 --> 00:01:41,759
it's certainly about programming in the

00:01:40,720 --> 00:01:46,560
small

00:01:41,759 --> 00:01:46,560
rather than grand ideas

00:01:48,240 --> 00:01:55,200
so my chosen problem is to

00:01:52,159 --> 00:01:57,520
get some information from a to b this is

00:01:55,200 --> 00:01:59,840
something we all do all the time

00:01:57,520 --> 00:02:00,560
and so it's interesting where it's

00:01:59,840 --> 00:02:04,000
interesting

00:02:00,560 --> 00:02:05,520
is actually in the constraints on the

00:02:04,000 --> 00:02:07,920
problem

00:02:05,520 --> 00:02:09,280
i'm thinking about messages between

00:02:07,920 --> 00:02:12,319
applications that

00:02:09,280 --> 00:02:14,239
may go on to different processes to

00:02:12,319 --> 00:02:16,160
different processes

00:02:14,239 --> 00:02:17,440
to different computers and different

00:02:16,160 --> 00:02:19,440
places

00:02:17,440 --> 00:02:21,440
i'm thinking about something that might

00:02:19,440 --> 00:02:24,560
require low latency that

00:02:21,440 --> 00:02:28,480
might have to be stored for years

00:02:24,560 --> 00:02:31,760
maybe it has to be minimal space and

00:02:28,480 --> 00:02:33,519
we we need to talk between languages the

00:02:31,760 --> 00:02:36,560
languages we have tried is c

00:02:33,519 --> 00:02:37,599
plus plus java and python but in

00:02:36,560 --> 00:02:40,000
principle

00:02:37,599 --> 00:02:42,319
moving things over wire means that

00:02:40,000 --> 00:02:44,480
you're pushing bytes around

00:02:42,319 --> 00:02:46,319
and everybody can do that directly

00:02:44,480 --> 00:02:50,080
indirectly

00:02:46,319 --> 00:02:52,720
also some of the things i think about is

00:02:50,080 --> 00:02:53,840
critical applications both performance

00:02:52,720 --> 00:02:57,280
and

00:02:53,840 --> 00:02:58,879
safety-wise so we have to minimize

00:02:57,280 --> 00:03:02,480
programming area

00:02:58,879 --> 00:03:04,560
errors so that's sort of my constraints

00:03:02,480 --> 00:03:06,480
if you look at this remember that my

00:03:04,560 --> 00:03:07,280
constraints and your constraints may not

00:03:06,480 --> 00:03:10,000
actually be

00:03:07,280 --> 00:03:11,920
the same but it's very important when

00:03:10,000 --> 00:03:12,800
you start off with a project or an

00:03:11,920 --> 00:03:16,800
experiment

00:03:12,800 --> 00:03:16,800
to decide what your constraints are

00:03:16,959 --> 00:03:20,000
everybody everybody's doing this as i

00:03:18,560 --> 00:03:23,360
said um

00:03:20,000 --> 00:03:26,080
and uh every library that talks

00:03:23,360 --> 00:03:27,680
into process intercomputer has some kind

00:03:26,080 --> 00:03:29,760
of way of doing it

00:03:27,680 --> 00:03:31,519
and there's many many ways of doing this

00:03:29,760 --> 00:03:32,000
and this is one of the things that

00:03:31,519 --> 00:03:35,120
bothered

00:03:32,000 --> 00:03:38,879
me because i couldn't do experiments

00:03:35,120 --> 00:03:41,920
using a variety of things and also i

00:03:38,879 --> 00:03:44,959
observed that business applications got

00:03:41,920 --> 00:03:48,319
tied to a particular way of

00:03:44,959 --> 00:03:50,799
exchanging information and so couldn't

00:03:48,319 --> 00:03:52,000
couldn't change it and the users had to

00:03:50,799 --> 00:03:54,080
understand that

00:03:52,000 --> 00:03:55,040
and when you have to communicate between

00:03:54,080 --> 00:03:57,200
different

00:03:55,040 --> 00:04:00,480
applications you have to understand all

00:03:57,200 --> 00:04:02,959
the transport mechanisms communication

00:04:00,480 --> 00:04:07,040
mechanisms anybody's ever used

00:04:02,959 --> 00:04:09,280
in that set of applications

00:04:07,040 --> 00:04:10,480
so i want to separate the reading and

00:04:09,280 --> 00:04:13,840
writing of messages

00:04:10,480 --> 00:04:16,720
from the transport and basically i'm

00:04:13,840 --> 00:04:20,720
describing a library i'm working on

00:04:16,720 --> 00:04:22,880
um experimenting with uh for

00:04:20,720 --> 00:04:25,199
giving an interface between typed

00:04:22,880 --> 00:04:28,080
objects and bytes in a message

00:04:25,199 --> 00:04:28,960
and basically the way i see applications

00:04:28,080 --> 00:04:31,120
is like this

00:04:28,960 --> 00:04:33,280
we have an application you have some

00:04:31,120 --> 00:04:35,600
business logic as they call it

00:04:33,280 --> 00:04:36,560
and it can be written in a variety of

00:04:35,600 --> 00:04:38,639
languages

00:04:36,560 --> 00:04:41,040
and then there's a transport it can be

00:04:38,639 --> 00:04:43,520
done in many many different ways

00:04:41,040 --> 00:04:44,560
but basically it's end up being bites on

00:04:43,520 --> 00:04:47,040
a wire

00:04:44,560 --> 00:04:48,080
and then i want to write the same layer

00:04:47,040 --> 00:04:50,000
i can

00:04:48,080 --> 00:04:51,120
between the business logic and the

00:04:50,000 --> 00:04:54,720
transport

00:04:51,120 --> 00:04:58,720
that is easy to use and safe and

00:04:54,720 --> 00:05:02,160
and efficient um efficiency matters

00:04:58,720 --> 00:05:03,360
uh because sometimes uh that wire is not

00:05:02,160 --> 00:05:05,520
thin

00:05:03,360 --> 00:05:07,759
maybe it's shared memory and it's

00:05:05,520 --> 00:05:11,759
actually more like a fire hose

00:05:07,759 --> 00:05:14,400
and in that case the cost of marshalling

00:05:11,759 --> 00:05:16,960
stuff if that's what you're doing or

00:05:14,400 --> 00:05:18,479
copying stuff can be very expensive so

00:05:16,960 --> 00:05:20,479
you want to minimize

00:05:18,479 --> 00:05:23,120
the cost of passing through that

00:05:20,479 --> 00:05:23,120
interface

00:05:23,360 --> 00:05:26,560
i i have a communication model uh which

00:05:26,160 --> 00:05:29,680
is

00:05:26,560 --> 00:05:33,039
that um i i

00:05:29,680 --> 00:05:36,160
don't need self-describing messages

00:05:33,039 --> 00:05:39,360
um you can set up a

00:05:36,160 --> 00:05:42,560
version control connection control

00:05:39,360 --> 00:05:44,720
at the start of a session and that

00:05:42,560 --> 00:05:47,199
that's that's what i assume here

00:05:44,720 --> 00:05:50,400
furthermore i'm not going to read or

00:05:47,199 --> 00:05:52,240
write half buffers

00:05:50,400 --> 00:05:54,560
you wait until the buffer is full and

00:05:52,240 --> 00:05:57,600
then you can start reading it

00:05:54,560 --> 00:05:58,639
and uh i want zero copying i don't want

00:05:57,600 --> 00:06:02,000
you to build

00:05:58,639 --> 00:06:04,000
a a message in one place and then

00:06:02,000 --> 00:06:05,039
sort of do something to it moving at

00:06:04,000 --> 00:06:07,680
something else

00:06:05,039 --> 00:06:08,479
minimize copying no marshalling in other

00:06:07,680 --> 00:06:10,560
words

00:06:08,479 --> 00:06:12,960
i want to simplify by not trying to

00:06:10,560 --> 00:06:17,280
solve every problem i can imagine

00:06:12,960 --> 00:06:19,520
i want to see what my likely users need

00:06:17,280 --> 00:06:21,360
similarly with the data structures i

00:06:19,520 --> 00:06:25,039
want to simplify things to

00:06:21,360 --> 00:06:27,600
to what basically everybody is sending

00:06:25,039 --> 00:06:29,199
no pointers they don't go well over

00:06:27,600 --> 00:06:31,360
wires

00:06:29,199 --> 00:06:33,759
no mutual references that creates

00:06:31,360 --> 00:06:36,000
complicated things but we have the basic

00:06:33,759 --> 00:06:38,800
types like characters integers

00:06:36,000 --> 00:06:41,520
some materials are floats optional

00:06:38,800 --> 00:06:44,560
variant array vector and strings

00:06:41,520 --> 00:06:47,199
and nesting of all of these

00:06:44,560 --> 00:06:48,240
things again don't try and solve every

00:06:47,199 --> 00:06:50,960
problem uh

00:06:48,240 --> 00:06:52,720
listen to the users and for anything

00:06:50,960 --> 00:06:53,440
that's more complicated than that you

00:06:52,720 --> 00:06:56,639
can use

00:06:53,440 --> 00:06:59,280
a higher level of composition

00:06:56,639 --> 00:07:02,639
and basically break the problem into a

00:06:59,280 --> 00:07:05,120
series of messages that fulfill this

00:07:02,639 --> 00:07:06,800
this requirement i call these simple

00:07:05,120 --> 00:07:08,960
structures flats

00:07:06,800 --> 00:07:11,360
and the library i'm working on is chord

00:07:08,960 --> 00:07:11,360
flats

00:07:11,680 --> 00:07:15,520
so here's a message it has a bunch of

00:07:14,800 --> 00:07:17,199
flats

00:07:15,520 --> 00:07:19,919
that are the structures that are the

00:07:17,199 --> 00:07:22,160
payload and there's an optional header

00:07:19,919 --> 00:07:23,599
if you need versioning in the headers or

00:07:22,160 --> 00:07:26,720
if you need to control

00:07:23,599 --> 00:07:28,880
some memory at the end where we put

00:07:26,720 --> 00:07:30,000
stuff that we don't know the size of

00:07:28,880 --> 00:07:33,039
before we start writing

00:07:30,000 --> 00:07:36,639
the message that's known as the tail so

00:07:33,039 --> 00:07:40,960
basically head main part of the body and

00:07:36,639 --> 00:07:44,080
tail that's it and so

00:07:40,960 --> 00:07:46,319
the messages basically look like this as

00:07:44,080 --> 00:07:47,680
characters look like characters integers

00:07:46,319 --> 00:07:50,720
like integers

00:07:47,680 --> 00:07:53,759
arrays are typed it's an array of 10

00:07:50,720 --> 00:07:54,479
t and there's n of them we know how many

00:07:53,759 --> 00:07:57,199
they are

00:07:54,479 --> 00:07:58,400
if we don't know how many there are

00:07:57,199 --> 00:08:01,440
until

00:07:58,400 --> 00:08:04,560
we create the object create a vector

00:08:01,440 --> 00:08:08,000
then it's called a vector and we store

00:08:04,560 --> 00:08:11,840
the number of elements and where we

00:08:08,000 --> 00:08:13,919
stick the elements that goes to the tail

00:08:11,840 --> 00:08:17,360
optionals are simply

00:08:13,919 --> 00:08:19,759
a thing that is either there or not and

00:08:17,360 --> 00:08:21,360
an optional array that looks like that

00:08:19,759 --> 00:08:24,639
and then you have variants

00:08:21,360 --> 00:08:25,680
which holds one out of n alternatives or

00:08:24,639 --> 00:08:29,919
none of them

00:08:25,680 --> 00:08:30,400
so uh that's as simple as i could make

00:08:29,919 --> 00:08:33,519
it

00:08:30,400 --> 00:08:35,760
the the aim here is not uh for for real

00:08:33,519 --> 00:08:38,479
sophistication it's to be

00:08:35,760 --> 00:08:40,240
very simple quite primitive about how

00:08:38,479 --> 00:08:43,839
you use things

00:08:40,240 --> 00:08:45,120
so we need to be able to map between the

00:08:43,839 --> 00:08:48,000
ordinary world

00:08:45,120 --> 00:08:49,440
of typed objects where you can use the

00:08:48,000 --> 00:08:53,200
full language

00:08:49,440 --> 00:08:55,839
and the sequence of bytes on the wire

00:08:53,200 --> 00:08:56,880
and that thing is called a message

00:08:55,839 --> 00:08:59,920
descriptor

00:08:56,880 --> 00:09:00,959
it's it's something that i that we

00:08:59,920 --> 00:09:04,560
generate

00:09:00,959 --> 00:09:07,600
and it does the mapping from types to

00:09:04,560 --> 00:09:09,360
to bytes which is a key issue here

00:09:07,600 --> 00:09:11,519
and then once you've stopped things in

00:09:09,360 --> 00:09:13,839
the byte you can send them to somewhere

00:09:11,519 --> 00:09:16,000
else or you can receive a message buffer

00:09:13,839 --> 00:09:19,600
and read them

00:09:16,000 --> 00:09:22,080
the key to type mapping is that it's

00:09:19,600 --> 00:09:23,519
it's really messy you have to have high

00:09:22,080 --> 00:09:26,720
level concept that you

00:09:23,519 --> 00:09:29,120
turn into low level representations and

00:09:26,720 --> 00:09:30,959
then back to high level things again

00:09:29,120 --> 00:09:32,560
if you write that code you'll find it's

00:09:30,959 --> 00:09:35,760
fiddly and error prone

00:09:32,560 --> 00:09:39,600
so we don't have humans write it it's

00:09:35,760 --> 00:09:40,240
either generated or it is in a support

00:09:39,600 --> 00:09:42,880
library

00:09:40,240 --> 00:09:45,519
that that's written by people who who

00:09:42,880 --> 00:09:48,320
does that once and for all

00:09:45,519 --> 00:09:50,160
so here the user code can use things

00:09:48,320 --> 00:09:52,880
like standard string

00:09:50,160 --> 00:09:54,080
and it can access using an access type

00:09:52,880 --> 00:09:56,480
which is a span

00:09:54,080 --> 00:09:57,279
a span is like the standard spam the

00:09:56,480 --> 00:09:59,839
span

00:09:57,279 --> 00:10:00,480
it it simply says there are elements

00:09:59,839 --> 00:10:02,720
from here

00:10:00,480 --> 00:10:04,480
to there you can traverse them you can

00:10:02,720 --> 00:10:06,959
subscribe to get to them

00:10:04,480 --> 00:10:09,120
uh the span is is one of the key

00:10:06,959 --> 00:10:12,240
abstractions we're using

00:10:09,120 --> 00:10:14,240
uh the message descriptor can take a

00:10:12,240 --> 00:10:18,800
string and turn it into the

00:10:14,240 --> 00:10:20,480
um the the string representation in the

00:10:18,800 --> 00:10:22,320
buffer which happens to be called a

00:10:20,480 --> 00:10:24,399
string and

00:10:22,320 --> 00:10:26,399
you can get back out again a span that

00:10:24,399 --> 00:10:28,560
describes what you're doing it

00:10:26,399 --> 00:10:30,560
the way it looks in code is you can

00:10:28,560 --> 00:10:33,040
initialize a vector of string

00:10:30,560 --> 00:10:34,640
say by giving it an initialize a list of

00:10:33,040 --> 00:10:37,360
standard strings

00:10:34,640 --> 00:10:38,480
and it's for it the message descriptor

00:10:37,360 --> 00:10:41,519
knows where

00:10:38,480 --> 00:10:44,480
the um the the message buffer is

00:10:41,519 --> 00:10:46,399
so it does a placement new sticking a

00:10:44,480 --> 00:10:49,600
vector of string

00:10:46,399 --> 00:10:52,560
with the allocator and the argument

00:10:49,600 --> 00:10:54,320
disk we got there and it basically takes

00:10:52,560 --> 00:10:57,279
the whole thing and puts it

00:10:54,320 --> 00:10:59,680
on the wire to get it back again it

00:10:57,279 --> 00:11:04,800
simply says return

00:10:59,680 --> 00:11:07,680
this place this is the field called vs

00:11:04,800 --> 00:11:09,920
again the field called vs and basically

00:11:07,680 --> 00:11:10,240
it knows where the characters are so it

00:11:09,920 --> 00:11:13,600
can

00:11:10,240 --> 00:11:16,640
return a span of the elements

00:11:13,600 --> 00:11:17,360
for for people to use and so up here all

00:11:16,640 --> 00:11:20,160
the code

00:11:17,360 --> 00:11:20,959
is is perfectly normal and ordinary and

00:11:20,160 --> 00:11:24,399
down here

00:11:20,959 --> 00:11:26,240
we're fiddling with bytes um

00:11:24,399 --> 00:11:27,800
there's a set of types that we have to

00:11:26,240 --> 00:11:29,360
do things that can be used for

00:11:27,800 --> 00:11:33,279
initialization

00:11:29,360 --> 00:11:35,360
that's basically standard types and user

00:11:33,279 --> 00:11:38,640
defined types things like that

00:11:35,360 --> 00:11:40,720
and in the buffer they have equivalents

00:11:38,640 --> 00:11:43,760
and then we have access types that we

00:11:40,720 --> 00:11:47,120
use to to simplify people's use of it

00:11:43,760 --> 00:11:50,079
um basically that that'll be the types

00:11:47,120 --> 00:11:50,880
that we use already and then there's the

00:11:50,079 --> 00:11:54,800
span

00:11:50,880 --> 00:11:57,519
that is that we use for ranges

00:11:54,800 --> 00:12:00,000
of course it didn't start out like this

00:11:57,519 --> 00:12:02,639
one thing i really missed this year

00:12:00,000 --> 00:12:04,959
is is the whiteboard sessions it's a

00:12:02,639 --> 00:12:07,440
design sessions where you discuss

00:12:04,959 --> 00:12:08,959
what's important in the field and i

00:12:07,440 --> 00:12:12,399
found no real

00:12:08,959 --> 00:12:15,120
online substitutes

00:12:12,399 --> 00:12:16,240
for simply talking to people drawing

00:12:15,120 --> 00:12:19,279
things on the

00:12:16,240 --> 00:12:20,399
map and things like that so i am very

00:12:19,279 --> 00:12:22,399
base

00:12:20,399 --> 00:12:24,160
missing my favorite tool for initial

00:12:22,399 --> 00:12:26,959
design the whiteboard

00:12:24,160 --> 00:12:29,279
or blackboard notice here the buffers

00:12:26,959 --> 00:12:31,440
there's the message descriptors

00:12:29,279 --> 00:12:34,079
here's uh the structures that's being

00:12:31,440 --> 00:12:37,440
passed and things like that

00:12:34,079 --> 00:12:39,680
okay so to talk between languages we

00:12:37,440 --> 00:12:42,240
need an interface definition language

00:12:39,680 --> 00:12:43,839
we could use c plus plus but then we

00:12:42,240 --> 00:12:46,800
would have to translate

00:12:43,839 --> 00:12:47,839
from c plus plus to java and pythons and

00:12:46,800 --> 00:12:51,200
etc

00:12:47,839 --> 00:12:52,160
so instead we need i went and looked for

00:12:51,200 --> 00:12:53,839
the simplest

00:12:52,160 --> 00:12:56,399
interface definition language i could

00:12:53,839 --> 00:12:57,440
find this is an opportunity because it

00:12:56,399 --> 00:13:00,079
can be

00:12:57,440 --> 00:13:01,120
simpler than what's fine found in any

00:13:00,079 --> 00:13:04,399
language

00:13:01,120 --> 00:13:07,920
and we can accommodate specialized needs

00:13:04,399 --> 00:13:10,320
if they arrive but anyway we don't start

00:13:07,920 --> 00:13:12,240
with trying to solve every problem and

00:13:10,320 --> 00:13:14,720
being as general as possible we start

00:13:12,240 --> 00:13:16,880
simple and then you can add features

00:13:14,720 --> 00:13:18,880
the the simpler it is the easier it is

00:13:16,880 --> 00:13:20,240
to add things later because there's

00:13:18,880 --> 00:13:24,160
fewer constraints

00:13:20,240 --> 00:13:26,880
so here a pair is a flat that's our

00:13:24,160 --> 00:13:28,720
data type and it has a name which is a

00:13:26,880 --> 00:13:31,760
string and a value that's in

00:13:28,720 --> 00:13:32,480
32 i mean it can't be much simpler than

00:13:31,760 --> 00:13:34,639
that

00:13:32,480 --> 00:13:37,600
and that is actually actual code we

00:13:34,639 --> 00:13:41,199
don't need anything else there

00:13:37,600 --> 00:13:44,880
and if you look at it uh in

00:13:41,199 --> 00:13:47,360
in a flat we can put a variable

00:13:44,880 --> 00:13:48,560
size sequence of characters that string

00:13:47,360 --> 00:13:52,160
has its

00:13:48,560 --> 00:13:54,959
size determined at runtime we can put

00:13:52,160 --> 00:13:55,839
building types we can put user defined

00:13:54,959 --> 00:13:57,760
types

00:13:55,839 --> 00:13:59,440
provided they are sufficiently simple

00:13:57,760 --> 00:14:02,639
and not loaded with

00:13:59,440 --> 00:14:03,360
pointers and things like that um we can

00:14:02,639 --> 00:14:06,560
have

00:14:03,360 --> 00:14:10,000
arrays of say

00:14:06,560 --> 00:14:10,320
flats or anything else really and we can

00:14:10,000 --> 00:14:12,880
have

00:14:10,320 --> 00:14:14,240
optional things that's that's basically

00:14:12,880 --> 00:14:17,440
the idea

00:14:14,240 --> 00:14:19,440
when i looked at this and i um

00:14:17,440 --> 00:14:20,800
considered the generality and recursion

00:14:19,440 --> 00:14:22,639
issue usually good

00:14:20,800 --> 00:14:24,959
if you can just say we can do everything

00:14:22,639 --> 00:14:26,639
that's fine on the other hand there's an

00:14:24,959 --> 00:14:29,519
overhead of doing that

00:14:26,639 --> 00:14:31,920
um nobody needs all that generality it

00:14:29,519 --> 00:14:34,160
can lead to bloat it can lead to

00:14:31,920 --> 00:14:36,000
confusion when people create things that

00:14:34,160 --> 00:14:36,880
are more complicated than they know they

00:14:36,000 --> 00:14:40,880
do

00:14:36,880 --> 00:14:41,360
and so we we have limits the code design

00:14:40,880 --> 00:14:43,519
again

00:14:41,360 --> 00:14:44,560
i find that if you're general and

00:14:43,519 --> 00:14:47,600
elegant uh

00:14:44,560 --> 00:14:49,760
code is nicer one of the things

00:14:47,600 --> 00:14:51,760
that is my measure of getting close to a

00:14:49,760 --> 00:14:52,560
good piece of code is when it starts

00:14:51,760 --> 00:14:55,120
shrinking

00:14:52,560 --> 00:14:57,120
there's less of it and it runs faster so

00:14:55,120 --> 00:14:58,000
the current state is quite general but

00:14:57,120 --> 00:15:01,440
not completely

00:14:58,000 --> 00:15:03,199
general for for nesting and generality

00:15:01,440 --> 00:15:04,480
and basically i don't want to add

00:15:03,199 --> 00:15:07,600
complexity

00:15:04,480 --> 00:15:11,360
without a use case to drive it but

00:15:07,600 --> 00:15:13,279
given an igl we need a parser a

00:15:11,360 --> 00:15:16,639
generator

00:15:13,279 --> 00:15:19,600
and we can do that so

00:15:16,639 --> 00:15:21,600
once we pass the the the flat

00:15:19,600 --> 00:15:23,920
definitions and the idl

00:15:21,600 --> 00:15:24,800
we can we can do anything we can

00:15:23,920 --> 00:15:27,360
generate c

00:15:24,800 --> 00:15:27,920
plus plus we can generate java we can

00:15:27,360 --> 00:15:30,000
generate

00:15:27,920 --> 00:15:32,160
object maps we can generate things that

00:15:30,000 --> 00:15:35,040
interpret data structures but

00:15:32,160 --> 00:15:35,759
um for now i'll concentrate on c plus

00:15:35,040 --> 00:15:38,000
plus we

00:15:35,759 --> 00:15:40,000
played with java and python 2 and send

00:15:38,000 --> 00:15:42,399
messages around so

00:15:40,000 --> 00:15:43,920
it actually works each interface should

00:15:42,399 --> 00:15:46,079
be culturally appropriate

00:15:43,920 --> 00:15:47,680
as i said before we don't really want

00:15:46,079 --> 00:15:51,279
the java programmers to

00:15:47,680 --> 00:15:55,440
write c plus or vice versa so the

00:15:51,279 --> 00:15:58,320
general framework looks like this

00:15:55,440 --> 00:16:00,240
the application programmer sees the idl

00:15:58,320 --> 00:16:03,279
and writes some code

00:16:00,240 --> 00:16:04,000
using the the stuff that's generated

00:16:03,279 --> 00:16:05,759
from it

00:16:04,000 --> 00:16:07,839
the generator generates message

00:16:05,759 --> 00:16:10,079
descriptors it gives the interface and

00:16:07,839 --> 00:16:13,040
that does the mapping between

00:16:10,079 --> 00:16:13,600
the code the data structures we write

00:16:13,040 --> 00:16:16,639
with

00:16:13,600 --> 00:16:19,519
and what's on the in the buffer

00:16:16,639 --> 00:16:20,880
and there's a little library of flat

00:16:19,519 --> 00:16:25,519
types that helps

00:16:20,880 --> 00:16:27,600
vector spam the span string

00:16:25,519 --> 00:16:29,600
optional and such that's written by

00:16:27,600 --> 00:16:31,120
support programmers so it can be quite

00:16:29,600 --> 00:16:32,880
thoroughly tested

00:16:31,120 --> 00:16:35,279
and there's all kind of other stuff

00:16:32,880 --> 00:16:40,000
which i won't talk about today

00:16:35,279 --> 00:16:43,440
so when it comes to the implementation

00:16:40,000 --> 00:16:46,720
small is good to be fast and correct

00:16:43,440 --> 00:16:49,199
the code has to be small and simple if i

00:16:46,720 --> 00:16:52,399
have a huge

00:16:49,199 --> 00:16:53,040
stack of code it's very hard to see what

00:16:52,399 --> 00:16:56,079
it does

00:16:53,040 --> 00:16:57,680
it's hard to find bugs it's it's hard to

00:16:56,079 --> 00:17:01,279
be thorough on testing

00:16:57,680 --> 00:17:02,240
so um i i have a little pass or

00:17:01,279 --> 00:17:04,720
generator

00:17:02,240 --> 00:17:05,600
from the igl generates things like

00:17:04,720 --> 00:17:08,799
vectors

00:17:05,600 --> 00:17:10,559
anything i want and it's about a

00:17:08,799 --> 00:17:13,280
thousand lines of c plus plus

00:17:10,559 --> 00:17:14,959
that's quite manageable it's just a a

00:17:13,280 --> 00:17:16,880
recursive descent parcel

00:17:14,959 --> 00:17:18,640
creates an internal data structure that

00:17:16,880 --> 00:17:21,199
i can do everything with

00:17:18,640 --> 00:17:23,679
the support library is similar simple it

00:17:21,199 --> 00:17:26,160
has these types

00:17:23,679 --> 00:17:27,360
it has no pointers in the buffer

00:17:26,160 --> 00:17:30,400
representation

00:17:27,360 --> 00:17:32,799
and it's about 500 lines of simple c

00:17:30,400 --> 00:17:34,720
plus plus so we're talking about a total

00:17:32,799 --> 00:17:35,360
system that will probably end up being

00:17:34,720 --> 00:17:38,320
maybe 2

00:17:35,360 --> 00:17:40,160
000 lines uh some types of weird here

00:17:38,320 --> 00:17:43,600
there's a ui

00:17:40,160 --> 00:17:46,080
well i will go there just now so

00:17:43,600 --> 00:17:48,400
anyway the big question then comes why

00:17:46,080 --> 00:17:51,760
write 2 000 lines of c plus plus

00:17:48,400 --> 00:17:54,480
when you can get a half million line

00:17:51,760 --> 00:17:57,760
application framework to do it for you

00:17:54,480 --> 00:18:00,160
and the argument for going with a small

00:17:57,760 --> 00:18:01,600
thing here is it's transparent you can

00:18:00,160 --> 00:18:03,679
see what it's doing there's fewer

00:18:01,600 --> 00:18:05,919
dependencies so your tool chain is

00:18:03,679 --> 00:18:08,400
simpler

00:18:05,919 --> 00:18:09,520
it's a direct solution of our needs

00:18:08,400 --> 00:18:12,480
whatever our needs

00:18:09,520 --> 00:18:14,160
are as opposed to having to work our

00:18:12,480 --> 00:18:17,120
needs into a general

00:18:14,160 --> 00:18:18,240
framework for everything and it's easier

00:18:17,120 --> 00:18:20,880
to tune

00:18:18,240 --> 00:18:22,400
i mean the 2000 lines you can you can

00:18:20,880 --> 00:18:24,320
start tuning things you can see where

00:18:22,400 --> 00:18:27,360
the problems are and fix them

00:18:24,320 --> 00:18:29,840
and the executables are very small

00:18:27,360 --> 00:18:31,440
the counter argument a very serious and

00:18:29,840 --> 00:18:33,440
realistic counter argument that

00:18:31,440 --> 00:18:36,960
sometimes wins

00:18:33,440 --> 00:18:39,360
but the huge framework is familiar

00:18:36,960 --> 00:18:42,160
it's maintained by somebody else who may

00:18:39,360 --> 00:18:45,360
be more responsive than we are

00:18:42,160 --> 00:18:47,760
it made it it's good to have third-party

00:18:45,360 --> 00:18:49,679
tools so you don't have to maintain them

00:18:47,760 --> 00:18:51,919
and you don't have to do any low-level

00:18:49,679 --> 00:18:55,440
fiddling which you have to get

00:18:51,919 --> 00:18:56,160
this kind of stuff running provided the

00:18:55,440 --> 00:18:59,200
framework

00:18:56,160 --> 00:18:59,760
provides exactly what you want and of

00:18:59,200 --> 00:19:01,919
course

00:18:59,760 --> 00:19:03,360
when you write the 2000 lines if you put

00:19:01,919 --> 00:19:05,120
them in production use you have to

00:19:03,360 --> 00:19:07,360
maintain them forever

00:19:05,120 --> 00:19:09,280
also i find that anything new will be

00:19:07,360 --> 00:19:11,840
unfamiliar

00:19:09,280 --> 00:19:13,600
i have had people look at this and say

00:19:11,840 --> 00:19:16,320
well this is too complicated i don't

00:19:13,600 --> 00:19:19,760
understand it i'm more used to xml

00:19:16,320 --> 00:19:20,880
and in that case i say well maybe you

00:19:19,760 --> 00:19:22,799
should think about

00:19:20,880 --> 00:19:24,400
fundamentally symbol as opposed to

00:19:22,799 --> 00:19:27,280
what's familiar

00:19:24,400 --> 00:19:28,960
so i can't explain everything in the

00:19:27,280 --> 00:19:32,000
time available

00:19:28,960 --> 00:19:35,919
the flats library and tools framework

00:19:32,000 --> 00:19:38,960
has a parser it has a generator

00:19:35,919 --> 00:19:41,120
it has runtime support and i'm going to

00:19:38,960 --> 00:19:44,720
talk about the red things here

00:19:41,120 --> 00:19:47,520
the accessors the standard types here

00:19:44,720 --> 00:19:48,880
and the error handling error handling is

00:19:47,520 --> 00:19:51,600
always important

00:19:48,880 --> 00:19:52,000
there's two sets of error handling in

00:19:51,600 --> 00:19:54,480
the

00:19:52,000 --> 00:19:56,480
parser generators it makes sure that you

00:19:54,480 --> 00:19:58,000
don't generate something that can't be

00:19:56,480 --> 00:20:00,000
implemented well

00:19:58,000 --> 00:20:01,200
and the error handling at runtime that

00:20:00,000 --> 00:20:04,080
catches

00:20:01,200 --> 00:20:05,520
errors that cannot be handled at compile

00:20:04,080 --> 00:20:08,720
time

00:20:05,520 --> 00:20:11,919
so the key to all of this

00:20:08,720 --> 00:20:13,919
is good interfaces that's always

00:20:11,919 --> 00:20:16,000
essential the way we write code

00:20:13,919 --> 00:20:17,679
if we have good interfaces the code

00:20:16,000 --> 00:20:20,159
using those interfaces

00:20:17,679 --> 00:20:21,360
are good both from the user side and the

00:20:20,159 --> 00:20:25,039
implementer side

00:20:21,360 --> 00:20:28,080
and if they are not code becomes a mess

00:20:25,039 --> 00:20:30,080
now unfortunately tastes lit differ so

00:20:28,080 --> 00:20:32,799
what i like may not be what you like

00:20:30,080 --> 00:20:34,900
and vice versa but here's an example

00:20:32,799 --> 00:20:36,720
event here is

00:20:34,900 --> 00:20:40,320
[Music]

00:20:36,720 --> 00:20:43,520
is a message descriptor and there is a

00:20:40,320 --> 00:20:46,559
field and a member called vvi

00:20:43,520 --> 00:20:49,919
vector or vector of integers

00:20:46,559 --> 00:20:50,799
for this is a test example and i give it

00:20:49,919 --> 00:20:53,919
a list

00:20:50,799 --> 00:20:56,480
uh basically a list of lists

00:20:53,919 --> 00:20:58,080
of integers that that seems fairly

00:20:56,480 --> 00:20:59,919
natural and simple

00:20:58,080 --> 00:21:01,520
and when i want to write it out again i

00:20:59,919 --> 00:21:05,280
can say

00:21:01,520 --> 00:21:08,559
write it out and what that

00:21:05,280 --> 00:21:12,000
thing does is prints the element

00:21:08,559 --> 00:21:14,559
and since this is a vector of vectors

00:21:12,000 --> 00:21:15,039
it just does a nested range for loop to

00:21:14,559 --> 00:21:17,360
do it

00:21:15,039 --> 00:21:18,559
comes out very naturally that's the kind

00:21:17,360 --> 00:21:21,760
of ideal i'm

00:21:18,559 --> 00:21:25,039
aiming for we can try

00:21:21,760 --> 00:21:27,120
there's a member called a vector of

00:21:25,039 --> 00:21:29,840
integers here vui

00:21:27,120 --> 00:21:30,960
it has integers and it's optional

00:21:29,840 --> 00:21:33,600
integers so

00:21:30,960 --> 00:21:34,799
there can be some that are missing and

00:21:33,600 --> 00:21:38,080
so i can

00:21:34,799 --> 00:21:38,559
uh i can read this thing i can get a

00:21:38,080 --> 00:21:42,000
grab

00:21:38,559 --> 00:21:44,400
the uh the the the thing from the buffer

00:21:42,000 --> 00:21:45,200
this is a reference not a copy and then

00:21:44,400 --> 00:21:48,240
i can ask

00:21:45,200 --> 00:21:50,480
is one element one present and it

00:21:48,240 --> 00:21:51,679
will go and see yes it's present then i

00:21:50,480 --> 00:21:53,440
can write it out

00:21:51,679 --> 00:21:56,080
if i had asked for true the answer would

00:21:53,440 --> 00:21:56,080
have been no

00:21:56,799 --> 00:21:59,840
the idea here is to have a single

00:21:59,039 --> 00:22:03,280
interface

00:21:59,840 --> 00:22:06,559
for many implementations i'll show

00:22:03,280 --> 00:22:07,679
two implementations but uh there there

00:22:06,559 --> 00:22:10,559
are many

00:22:07,679 --> 00:22:11,520
uh we can't just read and write structs

00:22:10,559 --> 00:22:15,039
because

00:22:11,520 --> 00:22:16,640
the standard types have pointers in them

00:22:15,039 --> 00:22:19,520
and they are more general than what we

00:22:16,640 --> 00:22:22,400
need and in general our data structures

00:22:19,520 --> 00:22:22,720
are more complicated than can be fitted

00:22:22,400 --> 00:22:26,159
uh

00:22:22,720 --> 00:22:29,039
conveniently into a and

00:22:26,159 --> 00:22:30,159
conveniently and efficiently into a byte

00:22:29,039 --> 00:22:32,720
buffer

00:22:30,159 --> 00:22:33,280
so we can't read and write struct

00:22:32,720 --> 00:22:36,159
because

00:22:33,280 --> 00:22:37,520
the different interfaces to transport we

00:22:36,159 --> 00:22:40,799
might want

00:22:37,520 --> 00:22:42,880
zero copy in the world i'm

00:22:40,799 --> 00:22:43,840
thinking about we definitely need to

00:22:42,880 --> 00:22:46,880
handle uh

00:22:43,840 --> 00:22:49,200
version uh differences

00:22:46,880 --> 00:22:50,960
we some people want guarantees that the

00:22:49,200 --> 00:22:54,320
fields have always been

00:22:50,960 --> 00:22:57,440
all been written that's not easy

00:22:54,320 --> 00:22:59,600
but we can do it and uh

00:22:57,440 --> 00:23:01,760
some of the necessary types are not

00:22:59,600 --> 00:23:03,600
native in all languages so we have to

00:23:01,760 --> 00:23:04,880
provide user defined types that

00:23:03,600 --> 00:23:07,840
represent

00:23:04,880 --> 00:23:09,919
uh what the the other language needs

00:23:07,840 --> 00:23:13,039
what the transport protocol needs

00:23:09,919 --> 00:23:16,720
my main example is a three byte

00:23:13,039 --> 00:23:19,760
integer that i found in some

00:23:16,720 --> 00:23:22,799
important communication protocols

00:23:19,760 --> 00:23:24,080
and some want static guarantees that

00:23:22,799 --> 00:23:26,000
only a subset of

00:23:24,080 --> 00:23:27,120
fields is accessed so if we send a

00:23:26,000 --> 00:23:29,200
message uh

00:23:27,120 --> 00:23:31,200
over the wire it may have all kinds of

00:23:29,200 --> 00:23:32,559
stuff that from the application is just

00:23:31,200 --> 00:23:35,600
irrelevant gunk

00:23:32,559 --> 00:23:39,760
that could be confusing so we

00:23:35,600 --> 00:23:41,840
the simple plain structs were not coded

00:23:39,760 --> 00:23:43,840
uh we can't use the standard library

00:23:41,840 --> 00:23:44,880
types on the wire because they've got

00:23:43,840 --> 00:23:47,679
pointers

00:23:44,880 --> 00:23:49,679
and i can't just use my favorite

00:23:47,679 --> 00:23:52,000
inventors interface because i don't have

00:23:49,679 --> 00:23:55,120
a single favorite vendor

00:23:52,000 --> 00:23:57,760
it locks into the favorite vendor and

00:23:55,120 --> 00:23:58,960
in a large organization that means you

00:23:57,760 --> 00:24:01,200
get different part

00:23:58,960 --> 00:24:02,640
of your code based logged in to

00:24:01,200 --> 00:24:05,200
different vendors

00:24:02,640 --> 00:24:07,200
and you have trouble communicating and

00:24:05,200 --> 00:24:08,080
anyway i want to experiment and doing

00:24:07,200 --> 00:24:12,000
that at scale

00:24:08,080 --> 00:24:14,080
requires a single interface so from

00:24:12,000 --> 00:24:15,840
so from a good inference phase we can

00:24:14,080 --> 00:24:18,159
map to any

00:24:15,840 --> 00:24:20,000
implementation any transport mechanism

00:24:18,159 --> 00:24:23,200
that you can think of

00:24:20,000 --> 00:24:25,360
so here's an example of

00:24:23,200 --> 00:24:26,960
why we might have a single interface to

00:24:25,360 --> 00:24:31,440
two two things

00:24:26,960 --> 00:24:34,159
here is a flat creatively called if

00:24:31,440 --> 00:24:36,000
that has some members and i want to

00:24:34,159 --> 00:24:39,120
access member d

00:24:36,000 --> 00:24:41,679
and member s um the

00:24:39,120 --> 00:24:42,400
message the message descriptor knows

00:24:41,679 --> 00:24:45,679
that d

00:24:42,400 --> 00:24:47,520
is there and the s is there the offsets

00:24:45,679 --> 00:24:50,159
are known at compile time so

00:24:47,520 --> 00:24:50,880
we can read and write really directly

00:24:50,159 --> 00:24:54,960
into the

00:24:50,880 --> 00:24:58,000
buffer on the other hand a new version

00:24:54,960 --> 00:25:00,320
of f comes along

00:24:58,000 --> 00:25:01,120
and somebody has stalker this vector

00:25:00,320 --> 00:25:03,279
let's see what

00:25:01,120 --> 00:25:05,679
the yeah stalk a vector of strings right

00:25:03,279 --> 00:25:08,880
in the middle there

00:25:05,679 --> 00:25:12,320
things like that happen uh now

00:25:08,880 --> 00:25:14,159
we would still like to to read both this

00:25:12,320 --> 00:25:16,159
and that and the way you do it is you

00:25:14,159 --> 00:25:17,919
define a view that says i'm interested

00:25:16,159 --> 00:25:20,240
in dns

00:25:17,919 --> 00:25:23,760
not in rest and the way this is

00:25:20,240 --> 00:25:27,200
implemented is that now the view

00:25:23,760 --> 00:25:28,159
event d knows what where to find the

00:25:27,200 --> 00:25:30,320
offset of d

00:25:28,159 --> 00:25:31,360
and get to the right place s knows where

00:25:30,320 --> 00:25:34,000
the offset of s

00:25:31,360 --> 00:25:36,240
is and it's in the right place and it's

00:25:34,000 --> 00:25:38,799
not the same as it was up there

00:25:36,240 --> 00:25:40,080
so if we use a view we are independent

00:25:38,799 --> 00:25:43,919
on layout of

00:25:40,080 --> 00:25:46,320
the buffer and we can survive

00:25:43,919 --> 00:25:48,320
version changes that leaves the fields

00:25:46,320 --> 00:25:50,480
we're interested in

00:25:48,320 --> 00:25:52,559
as we want them so that's just one

00:25:50,480 --> 00:25:53,600
example of why we want a single

00:25:52,559 --> 00:25:55,760
interface

00:25:53,600 --> 00:25:56,960
notice that those called the same event

00:25:55,760 --> 00:26:00,000
d

00:25:56,960 --> 00:26:00,960
event d and it's just the initialization

00:26:00,000 --> 00:26:04,240
of event

00:26:00,960 --> 00:26:07,760
has changed um

00:26:04,240 --> 00:26:11,840
so can i afford this it's a big question

00:26:07,760 --> 00:26:15,120
so fairly early on in in the design here

00:26:11,840 --> 00:26:17,520
i was looking at uh how to measure

00:26:15,120 --> 00:26:19,520
things so i did some symbol measures

00:26:17,520 --> 00:26:21,440
they're very simple they i could be

00:26:19,520 --> 00:26:22,400
blindsided but it's better than no

00:26:21,440 --> 00:26:25,600
measures

00:26:22,400 --> 00:26:26,159
so i write a million messages and i have

00:26:25,600 --> 00:26:29,440
00:26:26,159 --> 00:26:31,520
fields 68 bytes very simple messages

00:26:29,440 --> 00:26:33,840
i i borrowed it from some friend of mine

00:26:31,520 --> 00:26:37,600
that sends such messages

00:26:33,840 --> 00:26:40,159
and then i get some symbol brittle

00:26:37,600 --> 00:26:42,720
mexicans to get a first impression

00:26:40,159 --> 00:26:44,240
and i do the usual kind of thing average

00:26:42,720 --> 00:26:47,360
best

00:26:44,240 --> 00:26:50,799
remove outliers

00:26:47,360 --> 00:26:53,600
worry about cache effect and inlining

00:26:50,799 --> 00:26:55,760
i'm looking for ratios comparing

00:26:53,600 --> 00:26:58,400
different ways not absolute figures

00:26:55,760 --> 00:27:00,080
there's really no substitute for using a

00:26:58,400 --> 00:27:03,039
demanding application

00:27:00,080 --> 00:27:05,440
but i have to define my interface first

00:27:03,039 --> 00:27:08,240
before i can do the real implementation

00:27:05,440 --> 00:27:10,240
and so i need some guidance and you

00:27:08,240 --> 00:27:14,000
repeat that a lot

00:27:10,240 --> 00:27:18,799
so i found that writing bytes structs

00:27:14,000 --> 00:27:21,039
and using the message descriptors

00:27:18,799 --> 00:27:23,120
gives about the same thing i i can write

00:27:21,039 --> 00:27:25,279
a message in four nanoseconds

00:27:23,120 --> 00:27:27,440
that's probably too optimistic it has to

00:27:25,279 --> 00:27:31,279
do with with the fact that i'm

00:27:27,440 --> 00:27:33,279
in a tight loop but it gives an idea

00:27:31,279 --> 00:27:35,279
i tried the excesses reading from the

00:27:33,279 --> 00:27:36,640
beginning and from the end and for

00:27:35,279 --> 00:27:40,000
random in the middle

00:27:36,640 --> 00:27:41,120
it it gives some differences but not

00:27:40,000 --> 00:27:42,880
dramatic

00:27:41,120 --> 00:27:44,960
on the other hand i tried sort of

00:27:42,880 --> 00:27:48,080
traditional way

00:27:44,960 --> 00:27:50,640
of interfaces from some areas i have get

00:27:48,080 --> 00:27:53,279
functions and set functions

00:27:50,640 --> 00:27:55,679
and they're roughly twice as expensive

00:27:53,279 --> 00:27:58,720
because the compilers can't eliminate

00:27:55,679 --> 00:28:02,559
the copying of arguments

00:27:58,720 --> 00:28:05,840
and and and results

00:28:02,559 --> 00:28:08,000
uh completely especially not for the uh

00:28:05,840 --> 00:28:09,760
slightly more complicated data

00:28:08,000 --> 00:28:12,880
structures that that

00:28:09,760 --> 00:28:14,159
we're we're reading and writing so uh

00:28:12,880 --> 00:28:17,279
the the accessor

00:28:14,159 --> 00:28:20,240
interface is probably the right one

00:28:17,279 --> 00:28:20,880
apart from that it's much easier to type

00:28:20,240 --> 00:28:24,080
i

00:28:20,880 --> 00:28:28,000
i like it it's cleaner so

00:28:24,080 --> 00:28:30,399
let's look we have we feed the idl

00:28:28,000 --> 00:28:32,799
pair which is this strict and we say i

00:28:30,399 --> 00:28:35,279
want a message with a pair in it

00:28:32,799 --> 00:28:36,720
and it generates a structure which is a

00:28:35,279 --> 00:28:39,039
perfectly ordinary c

00:28:36,720 --> 00:28:40,000
plus plus structure with a default

00:28:39,039 --> 00:28:42,159
constructor

00:28:40,000 --> 00:28:44,480
which i happen to need for a lot of

00:28:42,159 --> 00:28:44,480
things

00:28:44,880 --> 00:28:53,279
now we can use it i put the pair direct

00:28:49,360 --> 00:28:56,720
generated accessor a generated

00:28:53,279 --> 00:28:57,679
message descriptor through a test code

00:28:56,720 --> 00:29:00,480
and it can

00:28:57,679 --> 00:29:01,200
initialize the string initialize the

00:29:00,480 --> 00:29:04,320
value

00:29:01,200 --> 00:29:05,440
and see what we got write out the name

00:29:04,320 --> 00:29:08,399
write out the value

00:29:05,440 --> 00:29:09,919
that's fine and i can go and change

00:29:08,399 --> 00:29:13,760
badger to pair

00:29:09,919 --> 00:29:16,240
and value to two 1 2 3 4. this is fine

00:29:13,760 --> 00:29:18,240
we write it out again it works

00:29:16,240 --> 00:29:19,919
and i can try and change the name to

00:29:18,240 --> 00:29:23,120
elephant

00:29:19,919 --> 00:29:25,039
now we could then

00:29:23,120 --> 00:29:26,240
change everything so that we had a

00:29:25,039 --> 00:29:29,919
different

00:29:26,240 --> 00:29:33,120
size of the string but we don't do that

00:29:29,919 --> 00:29:34,799
the way uh it's it's written is that you

00:29:33,120 --> 00:29:37,120
get a truncation

00:29:34,799 --> 00:29:38,480
and you get an error and i'll get to

00:29:37,120 --> 00:29:41,070
what the errors look like

00:29:38,480 --> 00:29:44,000
but basically once

00:29:41,070 --> 00:29:46,640
[Music]

00:29:44,000 --> 00:29:48,720
once you set the size of a field once

00:29:46,640 --> 00:29:51,760
you set the size of

00:29:48,720 --> 00:29:54,720
a vector uh you you can't

00:29:51,760 --> 00:29:56,559
you can't just go and change it

00:29:54,720 --> 00:29:58,880
invisibly

00:29:56,559 --> 00:30:00,799
okay so this will give an error let's

00:29:58,880 --> 00:30:03,279
see what that looks like but first let's

00:30:00,799 --> 00:30:06,080
see what the pair direct is

00:30:03,279 --> 00:30:07,200
the the message descriptor here knows

00:30:06,080 --> 00:30:10,480
where the buffer is

00:30:07,200 --> 00:30:11,760
and what the type of the buffer is

00:30:10,480 --> 00:30:14,399
supposed to be

00:30:11,760 --> 00:30:15,520
and it knows where the tail is so that

00:30:14,399 --> 00:30:18,799
it can put

00:30:15,520 --> 00:30:21,039
thing vector elements in in the tail

00:30:18,799 --> 00:30:22,000
and so it has function to generate

00:30:21,039 --> 00:30:24,960
functions for

00:30:22,000 --> 00:30:26,320
the pair generates a name thing which

00:30:24,960 --> 00:30:29,679
returns a span

00:30:26,320 --> 00:30:31,679
it generates a value that just returns a

00:30:29,679 --> 00:30:34,320
reference into the buffer

00:30:31,679 --> 00:30:34,799
and you can initialize the string the

00:30:34,320 --> 00:30:37,919
string

00:30:34,799 --> 00:30:38,799
in three ways give it a c style string

00:30:37,919 --> 00:30:41,440
give it a

00:30:38,799 --> 00:30:42,320
c plus plus style string and just select

00:30:41,440 --> 00:30:44,559
how many

00:30:42,320 --> 00:30:45,679
elements you want how many characters

00:30:44,559 --> 00:30:48,960
you want

00:30:45,679 --> 00:30:51,760
and the the value is very simple

00:30:48,960 --> 00:30:52,799
it simply takes the argument and write

00:30:51,760 --> 00:30:56,000
it to it

00:30:52,799 --> 00:31:00,240
notice that it uses a placement new

00:30:56,000 --> 00:31:01,120
to construct the proper objects in the

00:31:00,240 --> 00:31:04,799
memory

00:31:01,120 --> 00:31:07,360
this is the flat string that is flat it

00:31:04,799 --> 00:31:08,159
works in the buffer it maps to bytes and

00:31:07,360 --> 00:31:11,600
it takes

00:31:08,159 --> 00:31:15,120
the traditional types as inputs

00:31:11,600 --> 00:31:16,480
and that this displacement view is

00:31:15,120 --> 00:31:20,720
essential

00:31:16,480 --> 00:31:24,080
so why is do we have this um

00:31:20,720 --> 00:31:26,399
open close parenthesis all over the time

00:31:24,080 --> 00:31:28,399
i needed a way to call the message

00:31:26,399 --> 00:31:30,559
descriptor's exit functions

00:31:28,399 --> 00:31:32,399
it's necessary to call a function in

00:31:30,559 --> 00:31:35,440
many many cases

00:31:32,399 --> 00:31:37,679
and it provides that common interface

00:31:35,440 --> 00:31:39,760
in some cases it's implemented one way

00:31:37,679 --> 00:31:41,600
in some cases implemented in another way

00:31:39,760 --> 00:31:43,600
but there is a function call that looks

00:31:41,600 --> 00:31:48,000
the same so we can change

00:31:43,600 --> 00:31:51,200
by recompiling so for example

00:31:48,000 --> 00:31:52,399
i can write or output the name i'll put

00:31:51,200 --> 00:31:55,840
the value

00:31:52,399 --> 00:31:59,840
and this open close paren annoys me no

00:31:55,840 --> 00:32:01,679
end it's ubiquitous it seems redundant

00:31:59,840 --> 00:32:04,480
and sometimes confusing

00:32:01,679 --> 00:32:06,240
i make mistakes and forget it and i

00:32:04,480 --> 00:32:07,720
really miss operate a dot

00:32:06,240 --> 00:32:09,440
i was not going to talk about

00:32:07,720 --> 00:32:11,519
standardization but

00:32:09,440 --> 00:32:12,960
i really wish i had operator dot so that

00:32:11,519 --> 00:32:16,399
i could write the

00:32:12,960 --> 00:32:18,559
really simple version of this where the

00:32:16,399 --> 00:32:20,080
call to the accessor function is

00:32:18,559 --> 00:32:22,880
implicit

00:32:20,080 --> 00:32:24,399
anyway let's see how we handle variable

00:32:22,880 --> 00:32:28,159
sized object

00:32:24,399 --> 00:32:29,200
an array is unknown is something where

00:32:28,159 --> 00:32:31,519
the elements

00:32:29,200 --> 00:32:32,480
number of elements known as compile time

00:32:31,519 --> 00:32:36,159
a vector

00:32:32,480 --> 00:32:36,880
we find the number of elements when we

00:32:36,159 --> 00:32:40,799
construct

00:32:36,880 --> 00:32:42,960
the object initialization time so

00:32:40,799 --> 00:32:43,840
the message looks like this there's the

00:32:42,960 --> 00:32:46,240
header

00:32:43,840 --> 00:32:47,120
there's the elements that we know the

00:32:46,240 --> 00:32:50,320
size of

00:32:47,120 --> 00:32:54,880
like arrays or building types and then

00:32:50,320 --> 00:32:58,159
here at the tail is where we put

00:32:54,880 --> 00:33:00,000
vector elements and we are not currently

00:32:58,159 --> 00:33:01,120
supporting change of size after

00:33:00,000 --> 00:33:03,120
construction

00:33:01,120 --> 00:33:04,480
because i don't generalize without a use

00:33:03,120 --> 00:33:07,600
case and i haven't seen the

00:33:04,480 --> 00:33:10,480
use case for that yet you can do it but

00:33:07,600 --> 00:33:10,799
that would be complexity so let's look

00:33:10,480 --> 00:33:14,000
at

00:33:10,799 --> 00:33:16,559
strings string is basically a

00:33:14,000 --> 00:33:17,919
vector of of charge so here that's the

00:33:16,559 --> 00:33:20,960
full definition of string

00:33:17,919 --> 00:33:24,399
string is a flat vector char

00:33:20,960 --> 00:33:26,640
okay the fixed size we have a

00:33:24,399 --> 00:33:28,720
we can simply allocate a fixed size an

00:33:26,640 --> 00:33:31,039
unfixed number of characters

00:33:28,720 --> 00:33:32,720
this is perfect if you know the size but

00:33:31,039 --> 00:33:36,320
you always

00:33:32,720 --> 00:33:39,360
always waste space because you have to

00:33:36,320 --> 00:33:39,760
over allocate in most cases i mean if

00:33:39,360 --> 00:33:42,159
you are

00:33:39,760 --> 00:33:43,679
always having the answer is the string

00:33:42,159 --> 00:33:46,240
is always three elements so

00:33:43,679 --> 00:33:48,320
always 20 minutes this is fine but for a

00:33:46,240 --> 00:33:49,840
lot of strings you don't know the size

00:33:48,320 --> 00:33:52,640
so you over allocate

00:33:49,840 --> 00:33:53,519
and then you have to keep track of how

00:33:52,640 --> 00:33:56,640
many

00:33:53,519 --> 00:33:57,519
characters are really worse so if i say

00:33:56,640 --> 00:34:02,720
i have this

00:33:57,519 --> 00:34:02,720
field of of 20 elements

00:34:03,679 --> 00:34:09,599
then use it then by

00:34:06,880 --> 00:34:10,240
not using 14 characters if this has been

00:34:09,599 --> 00:34:13,679
a vector

00:34:10,240 --> 00:34:14,639
we didn't need to say extend if the size

00:34:13,679 --> 00:34:17,520
is unknown

00:34:14,639 --> 00:34:20,399
i allocate only the ones i need which is

00:34:17,520 --> 00:34:23,520
four characters i just saved

00:34:20,399 --> 00:34:24,399
16 characters here but in the end in the

00:34:23,520 --> 00:34:27,200
end i have to

00:34:24,399 --> 00:34:29,280
store the size and position that's a

00:34:27,200 --> 00:34:32,879
word's worth of memory

00:34:29,280 --> 00:34:32,879
and we put them in the tail

00:34:32,960 --> 00:34:37,280
the vector definition looks basically

00:34:36,240 --> 00:34:39,599
like this

00:34:37,280 --> 00:34:40,560
there's a representation has a size and

00:34:39,599 --> 00:34:42,960
an offset

00:34:40,560 --> 00:34:44,320
i use 16 bit integers because i'm

00:34:42,960 --> 00:34:47,200
assuming that

00:34:44,320 --> 00:34:48,800
messages are short if i'm wrong i have

00:34:47,200 --> 00:34:52,879
to recompile

00:34:48,800 --> 00:34:53,919
um and there's default initialization to

00:34:52,879 --> 00:34:57,599
imagine

00:34:53,919 --> 00:35:00,320
which is pretty necessary

00:34:57,599 --> 00:35:02,000
and then there's a variety of ways of

00:35:00,320 --> 00:35:03,920
allocating things we can say

00:35:02,000 --> 00:35:05,599
how many elements there are we can give

00:35:03,920 --> 00:35:09,760
it an initializer list

00:35:05,599 --> 00:35:12,880
we can give it a string and the

00:35:09,760 --> 00:35:15,280
reading and writing to it

00:35:12,880 --> 00:35:16,480
is through a span which basically says

00:35:15,280 --> 00:35:18,720
where are the

00:35:16,480 --> 00:35:20,320
elements from the beginning to the end

00:35:18,720 --> 00:35:24,800
like std string

00:35:20,320 --> 00:35:24,800
astd span and

00:35:25,280 --> 00:35:30,079
the reason we need an allocator is that

00:35:28,320 --> 00:35:31,599
we don't know to run time how many

00:35:30,079 --> 00:35:33,920
elements there are so we have to put

00:35:31,599 --> 00:35:35,599
them in the tail this is done by

00:35:33,920 --> 00:35:37,599
allocating some memory

00:35:35,599 --> 00:35:38,800
fiddling around with bytes for

00:35:37,599 --> 00:35:42,000
addressing

00:35:38,800 --> 00:35:43,440
and this is pretty messy and i got it

00:35:42,000 --> 00:35:45,839
wrong a few times

00:35:43,440 --> 00:35:48,079
fortunately this is not something that's

00:35:45,839 --> 00:35:48,640
in the application interface we can get

00:35:48,079 --> 00:35:52,160
it right

00:35:48,640 --> 00:35:55,440
and test it and it's generated now so

00:35:52,160 --> 00:35:58,640
it's like code generation compiler

00:35:55,440 --> 00:36:01,680
and we have two things where

00:35:58,640 --> 00:36:06,160
we allocate elements in general

00:36:01,680 --> 00:36:08,640
and here we have l allocation of

00:36:06,160 --> 00:36:10,720
characters from a c style string which

00:36:08,640 --> 00:36:12,000
is more complicated because we have to

00:36:10,720 --> 00:36:15,040
scan the string to figure

00:36:12,000 --> 00:36:18,800
out where it is

00:36:15,040 --> 00:36:21,359
so the way we do it for a string here

00:36:18,800 --> 00:36:23,200
we actually asked the allocator to copy

00:36:21,359 --> 00:36:26,400
the string over and tell us

00:36:23,200 --> 00:36:29,760
what the size and position was the

00:36:26,400 --> 00:36:31,280
the pi the offset fiddling here is done

00:36:29,760 --> 00:36:34,079
but the allocation is done

00:36:31,280 --> 00:36:34,960
by the allocator you give it the string

00:36:34,079 --> 00:36:38,480
and tell it to

00:36:34,960 --> 00:36:41,040
to allocate it and

00:36:38,480 --> 00:36:41,839
so for c-style strings that's easily

00:36:41,040 --> 00:36:45,839
done

00:36:41,839 --> 00:36:49,040
we simply ask for the size and then

00:36:45,839 --> 00:36:50,880
we cop then then we know

00:36:49,040 --> 00:36:53,200
where the allocator gave us that much

00:36:50,880 --> 00:36:53,680
space and then we just copy elements

00:36:53,200 --> 00:36:57,040
towards

00:36:53,680 --> 00:36:59,680
it that's that's nice and simple

00:36:57,040 --> 00:37:00,640
and not error problem at all except of

00:36:59,680 --> 00:37:03,920
course if we

00:37:00,640 --> 00:37:05,599
try to cheat the system with a string

00:37:03,920 --> 00:37:08,880
that is far too long

00:37:05,599 --> 00:37:11,359
and that way we we have to check

00:37:08,880 --> 00:37:13,280
and so we check with narrowing to see if

00:37:11,359 --> 00:37:16,160
there's an error there

00:37:13,280 --> 00:37:18,320
for a c-style string we ask the

00:37:16,160 --> 00:37:21,440
allocator to put it in place

00:37:18,320 --> 00:37:24,800
i don't have a good way of using a

00:37:21,440 --> 00:37:25,920
member initialization here because i

00:37:24,800 --> 00:37:29,440
don't know a way

00:37:25,920 --> 00:37:29,440
of taking two

00:37:29,839 --> 00:37:34,320
two values and initialize two variables

00:37:32,480 --> 00:37:36,960
with it

00:37:34,320 --> 00:37:37,760
maybe i'll find one if nothing else it's

00:37:36,960 --> 00:37:40,720
possible

00:37:37,760 --> 00:37:41,359
it can be done so here is that c string

00:37:40,720 --> 00:37:44,160
copy

00:37:41,359 --> 00:37:45,760
which is used by the allocator of

00:37:44,160 --> 00:37:48,880
strings

00:37:45,760 --> 00:37:50,480
or in the implementation here and it

00:37:48,880 --> 00:37:53,839
basically says i want to

00:37:50,480 --> 00:37:56,480
copy some characters from to two

00:37:53,839 --> 00:37:58,640
and i want to check that i don't go

00:37:56,480 --> 00:38:02,839
through the maximum

00:37:58,640 --> 00:38:05,839
if you look back here you you'll see

00:38:02,839 --> 00:38:05,839
that

00:38:06,480 --> 00:38:12,880
somewhere somewhere in the core there

00:38:09,839 --> 00:38:13,359
uh it says that you should only use as

00:38:12,880 --> 00:38:16,960
many

00:38:13,359 --> 00:38:20,160
bites as you've got left in the tail

00:38:16,960 --> 00:38:22,800
and so basically it does the usual to

00:38:20,160 --> 00:38:24,240
and from but it keeps checking whether

00:38:22,800 --> 00:38:27,359
you were floated

00:38:24,240 --> 00:38:31,280
uh there's an error handler here um this

00:38:27,359 --> 00:38:35,599
contain condition is that you will

00:38:31,280 --> 00:38:39,520
never go over the max if you do you call

00:38:35,599 --> 00:38:43,599
you call an error handler with that

00:38:39,520 --> 00:38:46,240
reporting which kind of error you've got

00:38:43,599 --> 00:38:48,480
this might be optimizable character

00:38:46,240 --> 00:38:51,280
copies are usually heavily

00:38:48,480 --> 00:38:52,160
optimized i have not heavily optimized

00:38:51,280 --> 00:38:55,359
this because

00:38:52,160 --> 00:38:58,839
i didn't see the need yet

00:38:55,359 --> 00:39:00,800
but i assume that i can't optimize this

00:38:58,839 --> 00:39:02,720
further

00:39:00,800 --> 00:39:05,119
and this is what my error handler looked

00:39:02,720 --> 00:39:07,119
like basically the strategy has been to

00:39:05,119 --> 00:39:09,119
litter the code with checks wherever

00:39:07,119 --> 00:39:12,480
there could be a runtime error

00:39:09,119 --> 00:39:15,680
i insert and it's a call to inspect

00:39:12,480 --> 00:39:16,480
and we have an error handling check the

00:39:15,680 --> 00:39:19,839
d

00:39:16,480 --> 00:39:23,760
that says that for c strings we we use

00:39:19,839 --> 00:39:26,240
the d4 error handling action um

00:39:23,760 --> 00:39:26,880
here is the expect it tests the

00:39:26,240 --> 00:39:30,560
condition

00:39:26,880 --> 00:39:31,359
gives an error code that tells you what

00:39:30,560 --> 00:39:33,520
it is

00:39:31,359 --> 00:39:35,200
and we can get fine-grained control over

00:39:33,520 --> 00:39:38,000
what happened

00:39:35,200 --> 00:39:39,280
if we want to it is defaulted to the

00:39:38,000 --> 00:39:43,359
default

00:39:39,280 --> 00:39:46,480
and so i test is it logging then

00:39:43,359 --> 00:39:47,280
i test the condition and it logs if it's

00:39:46,480 --> 00:39:50,800
throwing i

00:39:47,280 --> 00:39:54,000
test the condition and throw if it's

00:39:50,800 --> 00:39:55,760
terminating i test the condition and

00:39:54,000 --> 00:39:57,359
terminate these are the only

00:39:55,760 --> 00:39:59,520
alternatives i have

00:39:57,359 --> 00:40:00,480
for the moment but you could have

00:39:59,520 --> 00:40:02,640
anything

00:40:00,480 --> 00:40:03,760
you like here notice the use of

00:40:02,640 --> 00:40:06,240
constructs but

00:40:03,760 --> 00:40:08,560
this stuff is really minimal i can make

00:40:06,240 --> 00:40:11,440
the whole thing disappear completely

00:40:08,560 --> 00:40:12,160
or i certainly don't have the only

00:40:11,440 --> 00:40:14,400
runtime

00:40:12,160 --> 00:40:16,720
check is the condition check which has

00:40:14,400 --> 00:40:19,920
which of course has to be done at

00:40:16,720 --> 00:40:24,560
runtime the rest is optimized away

00:40:19,920 --> 00:40:26,720
by using only what i chose

00:40:24,560 --> 00:40:27,839
you can suppress the tests i don't

00:40:26,720 --> 00:40:30,640
recommend

00:40:27,839 --> 00:40:32,000
suppression and you can define clusters

00:40:30,640 --> 00:40:35,200
of related chests

00:40:32,000 --> 00:40:37,760
default is something or other that's set

00:40:35,200 --> 00:40:40,640
and the individual checks here anything

00:40:37,760 --> 00:40:43,440
to do with c string anything to do

00:40:40,640 --> 00:40:44,160
with truncation i've said some things

00:40:43,440 --> 00:40:47,520
here

00:40:44,160 --> 00:40:48,640
the the thing the the control here is in

00:40:47,520 --> 00:40:51,520
the code

00:40:48,640 --> 00:40:52,400
this is appropriate for the stage of the

00:40:51,520 --> 00:40:55,280
development

00:40:52,400 --> 00:40:56,960
and for experimentation uh it doesn't

00:40:55,280 --> 00:40:59,839
give wide system control

00:40:56,960 --> 00:41:01,599
but i'm not actually a fan of lots of

00:40:59,839 --> 00:41:03,440
different places in the

00:41:01,599 --> 00:41:06,720
code having different error handling

00:41:03,440 --> 00:41:07,760
strategies so um this is this is good

00:41:06,720 --> 00:41:09,920
for now

00:41:07,760 --> 00:41:11,440
and it is it really is simple that is

00:41:09,920 --> 00:41:15,359
the code

00:41:11,440 --> 00:41:17,760
um okay so i had to test some of this uh

00:41:15,359 --> 00:41:19,280
cost again what does it really cost to

00:41:17,760 --> 00:41:21,599
put things in the tail

00:41:19,280 --> 00:41:23,040
what does it cost to copy things into

00:41:21,599 --> 00:41:26,800
the tail

00:41:23,040 --> 00:41:28,000
i initialized some variables with c

00:41:26,800 --> 00:41:31,359
style strings

00:41:28,000 --> 00:41:33,200
that's the overflow then i turned the

00:41:31,359 --> 00:41:37,599
overflow check off

00:41:33,200 --> 00:41:41,839
it was about 10 nanoseconds difference

00:41:37,599 --> 00:41:45,280
for 12 strings and 189 characters

00:41:41,839 --> 00:41:45,680
that's about 7 i decided i could afford

00:41:45,280 --> 00:41:48,560
that

00:41:45,680 --> 00:41:50,640
and i haven't even optimized yet if i

00:41:48,560 --> 00:41:53,440
use c style strings

00:41:50,640 --> 00:41:56,400
it is not a good idea because this build

00:41:53,440 --> 00:41:59,200
a c style string and then copies it

00:41:56,400 --> 00:42:00,880
that gives two copies so don't do that

00:41:59,200 --> 00:42:03,839
however if you get a c

00:42:00,880 --> 00:42:05,359
plus plus style string and it has

00:42:03,839 --> 00:42:06,240
already been filled up by the

00:42:05,359 --> 00:42:09,680
application

00:42:06,240 --> 00:42:10,240
you have close to the optimal strategy

00:42:09,680 --> 00:42:12,880
you just

00:42:10,240 --> 00:42:13,760
just copy a known number of characters

00:42:12,880 --> 00:42:15,520
there

00:42:13,760 --> 00:42:18,160
i don't have to check for length or

00:42:15,520 --> 00:42:21,359
overview

00:42:18,160 --> 00:42:23,200
i could also take allocate the stuff and

00:42:21,359 --> 00:42:26,240
then write to it

00:42:23,200 --> 00:42:27,760
there i have to test for overflow again

00:42:26,240 --> 00:42:30,319
for sizes

00:42:27,760 --> 00:42:31,680
so that's expensive i tried just to see

00:42:30,319 --> 00:42:34,480
what's the allocation

00:42:31,680 --> 00:42:35,760
what does it really cost me to allocate

00:42:34,480 --> 00:42:39,680
12 strings

00:42:35,760 --> 00:42:42,640
in the in in the tail

00:42:39,680 --> 00:42:44,319
and make sure they are things are

00:42:42,640 --> 00:42:47,839
properly initialized

00:42:44,319 --> 00:42:49,280
um that's 55 nanoseconds i'm sure i can

00:42:47,839 --> 00:42:53,040
optimize that further

00:42:49,280 --> 00:42:56,839
but this is at this stage of the design

00:42:53,040 --> 00:42:58,640
i don't need to do the authorizations i

00:42:56,839 --> 00:43:01,760
can

00:42:58,640 --> 00:43:04,880
that's assigning things and not narrow

00:43:01,760 --> 00:43:07,200
checks for against um

00:43:04,880 --> 00:43:09,040
against strings when you have a c style

00:43:07,200 --> 00:43:12,720
string and you just

00:43:09,040 --> 00:43:15,359
don't check for narrowing or

00:43:12,720 --> 00:43:17,599
truncation you get other things here

00:43:15,359 --> 00:43:21,440
this is just a set of experiments

00:43:17,599 --> 00:43:23,440
um the the cheapest thing i found was to

00:43:21,440 --> 00:43:26,720
write to an

00:43:23,440 --> 00:43:30,640
array of characters and don't check for

00:43:26,720 --> 00:43:34,240
truncation for overflow not recommended

00:43:30,640 --> 00:43:35,839
i actually like the these

00:43:34,240 --> 00:43:39,440
figures here but they're talking about

00:43:35,839 --> 00:43:42,640
100 nanosecond plus minus a bit

00:43:39,440 --> 00:43:43,760
so access to ranges comes through spans

00:43:42,640 --> 00:43:45,839
it has the effect

00:43:43,760 --> 00:43:47,520
that you can't actually the code looks

00:43:45,839 --> 00:43:50,560
identical whether thing

00:43:47,520 --> 00:43:53,920
is an array or is

00:43:50,560 --> 00:43:56,800
a vector and this

00:43:53,920 --> 00:43:58,720
includes arrays of characters and

00:43:56,800 --> 00:44:01,440
strings

00:43:58,720 --> 00:44:02,160
and this gives a uniform access to this

00:44:01,440 --> 00:44:05,359
it gives

00:44:02,160 --> 00:44:08,079
uh scop scripting commas the way it's

00:44:05,359 --> 00:44:09,920
done by default ranges are checked and

00:44:08,079 --> 00:44:14,240
you can do range force

00:44:09,920 --> 00:44:17,040
and basically a span looks like this

00:44:14,240 --> 00:44:19,040
you it almost fits on a slide it has a

00:44:17,040 --> 00:44:21,680
pointer to the beginning and the end

00:44:19,040 --> 00:44:22,640
it has begin and end function for normal

00:44:21,680 --> 00:44:26,000
and const

00:44:22,640 --> 00:44:26,640
size and two subscript operators that

00:44:26,000 --> 00:44:29,920
each

00:44:26,640 --> 00:44:33,680
check the range range

00:44:29,920 --> 00:44:36,560
if you have it enabled and you have an

00:44:33,680 --> 00:44:39,359
assignment that checks for

00:44:36,560 --> 00:44:41,040
truncation this is pretty

00:44:39,359 --> 00:44:44,480
straightforward code

00:44:41,040 --> 00:44:45,520
um it is not old-fashioned code in that

00:44:44,480 --> 00:44:47,839
sense this is

00:44:45,520 --> 00:44:48,960
quite modern c plus plus with a range

00:44:47,839 --> 00:44:52,240
for

00:44:48,960 --> 00:44:53,839
lambdas and the work const correctness

00:44:52,240 --> 00:44:57,119
and the rest of the stuff

00:44:53,839 --> 00:45:01,280
but it's basically fiddling with bytes

00:44:57,119 --> 00:45:02,720
and locations i found that this wasn't

00:45:01,280 --> 00:45:06,640
quite enough

00:45:02,720 --> 00:45:09,760
when i access a field that is a span

00:45:06,640 --> 00:45:13,680
then i should get this

00:45:09,760 --> 00:45:16,839
the vector of integers gives me the span

00:45:13,680 --> 00:45:20,160
uh a pair i need

00:45:16,839 --> 00:45:24,160
the message descriptor for

00:45:20,160 --> 00:45:24,960
the pair and we have a vector of pairs i

00:45:24,160 --> 00:45:27,440
should

00:45:24,960 --> 00:45:27,440
return

00:45:28,880 --> 00:45:32,400
basically a span of pairs and so i

00:45:31,200 --> 00:45:35,920
defined

00:45:32,400 --> 00:45:39,390
span ref which is one that when you

00:45:35,920 --> 00:45:41,040
dereference it it gives you a

00:45:39,390 --> 00:45:43,280
[Music]

00:45:41,040 --> 00:45:44,560
a message descriptor rather than the

00:45:43,280 --> 00:45:47,200
object itself

00:45:44,560 --> 00:45:48,400
and then everything works recursively

00:45:47,200 --> 00:45:53,440
down there

00:45:48,400 --> 00:45:57,040
and again this mostly fits on a slide

00:45:53,440 --> 00:46:00,640
a span ref to return

00:45:57,040 --> 00:46:04,720
the pointer plus the allocator so that

00:46:00,640 --> 00:46:09,440
when you de-reference it uh you can

00:46:04,720 --> 00:46:13,040
you you you can get the the interface

00:46:09,440 --> 00:46:15,280
one of the things that concerns me a lot

00:46:13,040 --> 00:46:16,400
here as you probably guessed is

00:46:15,280 --> 00:46:19,119
initialization

00:46:16,400 --> 00:46:21,280
how do we trade off space and time and

00:46:19,119 --> 00:46:24,560
safety

00:46:21,280 --> 00:46:27,520
i tried first to not initialize anything

00:46:24,560 --> 00:46:28,800
and leave it to the user even with the

00:46:27,520 --> 00:46:31,920
user being me

00:46:28,800 --> 00:46:34,880
that is a disaster um you can't

00:46:31,920 --> 00:46:35,680
remember to do everything consistently

00:46:34,880 --> 00:46:38,079
and so

00:46:35,680 --> 00:46:40,079
for vector optional variant you get

00:46:38,079 --> 00:46:41,280
other disasters if you forget to

00:46:40,079 --> 00:46:44,880
initialize

00:46:41,280 --> 00:46:47,920
not just pad values but but bad

00:46:44,880 --> 00:46:49,839
as accessing so they get initialized

00:46:47,920 --> 00:46:52,319
default is empty

00:46:49,839 --> 00:46:53,599
you can do a range for vector that you

00:46:52,319 --> 00:46:57,280
forgot to initialize

00:46:53,599 --> 00:46:58,079
because it's defaulted to empty similar

00:46:57,280 --> 00:47:00,319
optional

00:46:58,079 --> 00:47:02,000
optional is defaulted to not there

00:47:00,319 --> 00:47:05,680
variants to

00:47:02,000 --> 00:47:08,160
not there and

00:47:05,680 --> 00:47:09,760
basically repeated initialization turned

00:47:08,160 --> 00:47:12,240
out to be allowed

00:47:09,760 --> 00:47:13,440
it wastes a little bit of time space in

00:47:12,240 --> 00:47:16,720
the

00:47:13,440 --> 00:47:17,680
tail but you can actually initialize to

00:47:16,720 --> 00:47:19,920
something

00:47:17,680 --> 00:47:21,839
and then change your mind and initialize

00:47:19,920 --> 00:47:24,559
it to something else

00:47:21,839 --> 00:47:25,040
the most common cases you initialize it

00:47:24,559 --> 00:47:27,599
to

00:47:25,040 --> 00:47:30,880
no elements and you then add elements

00:47:27,599 --> 00:47:32,559
there's not even any waste

00:47:30,880 --> 00:47:34,000
should every field be default

00:47:32,559 --> 00:47:36,480
initialized

00:47:34,000 --> 00:47:38,880
no i don't know what the cost is

00:47:36,480 --> 00:47:41,920
actually i measured it it's significant

00:47:38,880 --> 00:47:42,640
and i don't know what value to

00:47:41,920 --> 00:47:46,160
initialize

00:47:42,640 --> 00:47:49,440
to and initializing everything to

00:47:46,160 --> 00:47:51,680
zero might be good but there's a lot of

00:47:49,440 --> 00:47:55,599
field where zero is not a good value

00:47:51,680 --> 00:47:58,559
so i stayed out of this

00:47:55,599 --> 00:47:59,839
default initialization and i have not

00:47:58,559 --> 00:48:01,920
decided

00:47:59,839 --> 00:48:02,880
because i don't have enough use cases to

00:48:01,920 --> 00:48:05,200
decide

00:48:02,880 --> 00:48:07,119
whether programmers should specify

00:48:05,200 --> 00:48:10,240
defaults for fields

00:48:07,119 --> 00:48:13,359
it is quite possible to

00:48:10,240 --> 00:48:16,000
generate an interface that

00:48:13,359 --> 00:48:17,680
so that everything is guaranteed to be

00:48:16,000 --> 00:48:20,960
initialized

00:48:17,680 --> 00:48:25,200
you you simply have one of these

00:48:20,960 --> 00:48:27,920
initialize x initialized y initialize c

00:48:25,200 --> 00:48:30,160
long strings of initializers that can be

00:48:27,920 --> 00:48:30,160
done

00:48:31,440 --> 00:48:39,040
i wondered about allowing the size after

00:48:35,359 --> 00:48:40,319
construction the cases are vector

00:48:39,040 --> 00:48:42,640
invariant

00:48:40,319 --> 00:48:43,440
and in principle it's easy and i've seen

00:48:42,640 --> 00:48:45,440
no use

00:48:43,440 --> 00:48:47,040
so basically you can have default

00:48:45,440 --> 00:48:47,599
nothing and then you can set it to

00:48:47,040 --> 00:48:51,680
something

00:48:47,599 --> 00:48:54,480
and that's that's it um

00:48:51,680 --> 00:48:56,079
i was wondering whether optionals should

00:48:54,480 --> 00:48:59,280
be

00:48:56,079 --> 00:49:01,359
allocated even

00:48:59,280 --> 00:49:02,880
if they were not filled and i decided

00:49:01,359 --> 00:49:07,119
yeah i'll do that an optional

00:49:02,880 --> 00:49:07,920
key has a has a boolean that says

00:49:07,119 --> 00:49:11,040
whether it's

00:49:07,920 --> 00:49:13,440
present or not and the allocation if you

00:49:11,040 --> 00:49:17,839
don't want to allocate

00:49:13,440 --> 00:49:20,079
here so that you um

00:49:17,839 --> 00:49:21,040
so so that you don't waste any space if

00:49:20,079 --> 00:49:24,640
you haven't

00:49:21,040 --> 00:49:26,079
um if it's not present you can instead

00:49:24,640 --> 00:49:28,640
use a vector

00:49:26,079 --> 00:49:30,960
a vector with zero elements is just a

00:49:28,640 --> 00:49:32,000
size and the pos and you can then change

00:49:30,960 --> 00:49:34,480
it to vector

00:49:32,000 --> 00:49:36,559
one and then you get that there's a

00:49:34,480 --> 00:49:39,680
little bit of overhead in space

00:49:36,559 --> 00:49:41,440
and in in axis time but you actually

00:49:39,680 --> 00:49:43,839
have the choice between the plane

00:49:41,440 --> 00:49:45,680
option war and the vector of zero and

00:49:43,839 --> 00:49:49,200
one that that gives you

00:49:45,680 --> 00:49:52,880
that performance trade-off and

00:49:49,200 --> 00:49:55,280
now there's always a lack of time

00:49:52,880 --> 00:49:56,000
even less than two thousand lines of

00:49:55,280 --> 00:49:58,319
code there's

00:49:56,000 --> 00:50:00,800
many many design decisions many many

00:49:58,319 --> 00:50:04,160
examples that could be used

00:50:00,800 --> 00:50:07,200
this will make a rather nice talk for

00:50:04,160 --> 00:50:10,240
sort of three hours for students to

00:50:07,200 --> 00:50:12,559
to to show discern this design decisions

00:50:10,240 --> 00:50:15,760
and alternatives and coding techniques

00:50:12,559 --> 00:50:18,000
but we don't have three hours any day

00:50:15,760 --> 00:50:21,200
now i'll put it all on github

00:50:18,000 --> 00:50:23,839
and that people comment i'd love

00:50:21,200 --> 00:50:26,559
comments about this

00:50:23,839 --> 00:50:28,640
so the general observations on this is

00:50:26,559 --> 00:50:30,640
that actually modern c plus plus is

00:50:28,640 --> 00:50:34,319
great for low level code

00:50:30,640 --> 00:50:37,520
i i've written low level code in well

00:50:34,319 --> 00:50:40,640
machine code and micro code and c and

00:50:37,520 --> 00:50:44,400
order c plus plus we can do

00:50:40,640 --> 00:50:47,119
much much better in modern c plus

00:50:44,400 --> 00:50:49,359
it's very languages the language is very

00:50:47,119 --> 00:50:51,280
flexible and it's tunable

00:50:49,359 --> 00:50:52,640
once you figure out what you want you

00:50:51,280 --> 00:50:55,839
can usually

00:50:52,640 --> 00:50:59,040
do it and you can can measure

00:50:55,839 --> 00:51:00,319
and tune and simple value types are the

00:50:59,040 --> 00:51:02,480
key to a lot of things

00:51:00,319 --> 00:51:04,960
i don't need rather classes i don't need

00:51:02,480 --> 00:51:07,839
the free store the dynamic memory

00:51:04,960 --> 00:51:09,920
i can avoid sporious indirections and

00:51:07,839 --> 00:51:13,440
get things that are compact and

00:51:09,920 --> 00:51:15,599
fast close to zero overhead i find that

00:51:13,440 --> 00:51:17,280
generic programming is essential for

00:51:15,599 --> 00:51:20,400
that

00:51:17,280 --> 00:51:23,280
for composing code you you

00:51:20,400 --> 00:51:23,680
and for having uniform access to things

00:51:23,280 --> 00:51:26,559
uh

00:51:23,680 --> 00:51:29,359
you you need generic programming and

00:51:26,559 --> 00:51:31,839
compiling time evaluation and inlining

00:51:29,359 --> 00:51:32,720
allows me to do this kind of abstraction

00:51:31,839 --> 00:51:34,960
functions don't

00:51:32,720 --> 00:51:36,000
actually cost very much because well

00:51:34,960 --> 00:51:38,400
once you generate

00:51:36,000 --> 00:51:39,520
the code there's no function call it's

00:51:38,400 --> 00:51:42,160
been inlined

00:51:39,520 --> 00:51:43,200
compile time evaluation if those error

00:51:42,160 --> 00:51:45,440
alternatives

00:51:43,200 --> 00:51:47,440
are not chosen they're not there and

00:51:45,440 --> 00:51:49,839
again i miss operator dot to

00:51:47,440 --> 00:51:52,400
simplify my notation but it wouldn't

00:51:49,839 --> 00:51:55,920
actually affect its effect

00:51:52,400 --> 00:51:57,920
runtime of it then

00:51:55,920 --> 00:51:58,960
i was debugging this stuff and there's

00:51:57,920 --> 00:52:02,559
some

00:51:58,960 --> 00:52:04,480
observations there the most fundamental

00:52:02,559 --> 00:52:07,280
observation about debugging is that the

00:52:04,480 --> 00:52:09,760
bug is always where you aren't looking

00:52:07,280 --> 00:52:11,760
because otherwise you would have found

00:52:09,760 --> 00:52:14,559
it by now

00:52:11,760 --> 00:52:15,040
there are some language related sources

00:52:14,559 --> 00:52:18,559
of

00:52:15,040 --> 00:52:20,079
bugs and problems signed and unsigned is

00:52:18,559 --> 00:52:22,480
a mess

00:52:20,079 --> 00:52:24,160
here we have to use size of and we have

00:52:22,480 --> 00:52:26,640
to do offset calculations

00:52:24,160 --> 00:52:28,240
size of this unsigned offset calculation

00:52:26,640 --> 00:52:29,839
goes forward and backwards so they're

00:52:28,240 --> 00:52:32,720
necessarily signed

00:52:29,839 --> 00:52:35,440
that caused me some grief overflow

00:52:32,720 --> 00:52:38,880
protection forces you to choose between

00:52:35,440 --> 00:52:42,880
having rare bugs or verbosity and or

00:52:38,880 --> 00:52:45,599
runtime cost i tend to choose

00:52:42,880 --> 00:52:47,200
the checking and the verbosity now

00:52:45,599 --> 00:52:49,839
explicit checks and

00:52:47,200 --> 00:52:51,760
the cost i can afford it at least for

00:52:49,839 --> 00:52:55,040
the applications i've seen so far

00:52:51,760 --> 00:52:57,680
and remember i'm counting nanoseconds um

00:52:55,040 --> 00:52:58,960
i don't like a rear box not at all if

00:52:57,680 --> 00:53:01,839
it's safety critical

00:52:58,960 --> 00:53:04,240
stuff you don't want to be here so

00:53:01,839 --> 00:53:06,079
systematic error detection is relatively

00:53:04,240 --> 00:53:08,160
cheap error reporting needs to be very

00:53:06,079 --> 00:53:10,079
flexible because if you are a library

00:53:08,160 --> 00:53:12,720
you don't really know what people

00:53:10,079 --> 00:53:14,720
need to do with the with the areas

00:53:12,720 --> 00:53:17,040
errors that's been detected

00:53:14,720 --> 00:53:18,160
um there's endless debates about that in

00:53:17,040 --> 00:53:20,640
the community

00:53:18,160 --> 00:53:21,760
here i need to be able to deal with

00:53:20,640 --> 00:53:24,400
applications that

00:53:21,760 --> 00:53:25,280
may not terminate it's simply not

00:53:24,400 --> 00:53:27,599
acceptable

00:53:25,280 --> 00:53:29,599
so i use exceptions to to get out of

00:53:27,599 --> 00:53:31,680
this into the application that then can

00:53:29,599 --> 00:53:33,760
decide what he wants to do about it

00:53:31,680 --> 00:53:35,520
that was one of the reasons exceptions

00:53:33,760 --> 00:53:36,720
were put into seatbelt plus in the first

00:53:35,520 --> 00:53:39,440
place

00:53:36,720 --> 00:53:41,440
i got bitten by order of argument

00:53:39,440 --> 00:53:44,800
evaluation i really wish

00:53:41,440 --> 00:53:47,520
that the order was defined it's

00:53:44,800 --> 00:53:49,440
such an unlikely thing and when it bites

00:53:47,520 --> 00:53:51,200
it bites hard and we're not used to

00:53:49,440 --> 00:53:54,000
looking for that kind of errors so

00:53:51,200 --> 00:53:54,000
that's nasty

00:53:54,559 --> 00:53:58,800
in this kind of stuff i needed to use

00:53:56,800 --> 00:54:00,559
both pointers and references

00:53:58,800 --> 00:54:01,920
and it's really quite hard to remember

00:54:00,559 --> 00:54:04,400
when you have to put the

00:54:01,920 --> 00:54:06,640
address and the star in the right places

00:54:04,400 --> 00:54:08,800
that cause some bugs

00:54:06,640 --> 00:54:10,880
and it can be really hard to find the

00:54:08,800 --> 00:54:12,160
root cause of compile time errors in

00:54:10,880 --> 00:54:15,440
generic code

00:54:12,160 --> 00:54:17,440
if you write the code and you make it

00:54:15,440 --> 00:54:19,200
generic and you do it at compile time

00:54:17,440 --> 00:54:21,119
rather than runtime

00:54:19,200 --> 00:54:22,240
the debugger isn't going to help you all

00:54:21,119 --> 00:54:25,280
that much

00:54:22,240 --> 00:54:27,200
and get really these horrible errors

00:54:25,280 --> 00:54:29,920
we've seen for years

00:54:27,200 --> 00:54:30,960
i made a big big mistake i failed to use

00:54:29,920 --> 00:54:33,200
concept

00:54:30,960 --> 00:54:34,480
uh you could ask why have all people

00:54:33,200 --> 00:54:36,799
make that mistake

00:54:34,480 --> 00:54:38,559
and the the answer was i thought this

00:54:36,799 --> 00:54:39,760
was a simple problem and i didn't

00:54:38,559 --> 00:54:42,799
actually need the help

00:54:39,760 --> 00:54:44,960
i was wrong concepts are very very

00:54:42,799 --> 00:54:47,040
powerful and very very useful

00:54:44,960 --> 00:54:49,359
and the other reason was that the

00:54:47,040 --> 00:54:50,400
compilers i was using didn't all support

00:54:49,359 --> 00:54:53,440
them then

00:54:50,400 --> 00:54:57,040
next year you don't have that excuse

00:54:53,440 --> 00:54:59,040
um so basically um we can do a type safe

00:54:57,040 --> 00:55:01,359
mapping to and from raw memory

00:54:59,040 --> 00:55:02,960
that that's important it's part of the c

00:55:01,359 --> 00:55:06,000
and c plus plus

00:55:02,960 --> 00:55:09,040
um memory model that that gives you

00:55:06,000 --> 00:55:11,440
this kind of ability to manipulate it

00:55:09,040 --> 00:55:12,640
we can get great time and space

00:55:11,440 --> 00:55:14,640
performance

00:55:12,640 --> 00:55:16,079
there's no spurious memory use no

00:55:14,640 --> 00:55:18,720
spurious indirections

00:55:16,079 --> 00:55:21,440
minimize the number of function calls

00:55:18,720 --> 00:55:23,280
and this is all done without any macros

00:55:21,440 --> 00:55:24,480
there is no macros in this system i

00:55:23,280 --> 00:55:27,760
don't like macros

00:55:24,480 --> 00:55:30,799
and for this i don't need them and uh

00:55:27,760 --> 00:55:32,640
only necessary cost you have to some

00:55:30,799 --> 00:55:33,440
costs are necessary because you have to

00:55:32,640 --> 00:55:37,680
tell

00:55:33,440 --> 00:55:40,079
for instance you have to tell the

00:55:37,680 --> 00:55:41,839
message descriptor where the buffer is

00:55:40,079 --> 00:55:43,920
and things like that

00:55:41,839 --> 00:55:45,040
so fiddling with bytes and addresses is

00:55:43,920 --> 00:55:46,960
necessary

00:55:45,040 --> 00:55:48,079
slow unpleasant and narrow prone so

00:55:46,960 --> 00:55:51,200
leave it to support

00:55:48,079 --> 00:55:54,240
libraries compilers and generators

00:55:51,200 --> 00:55:54,720
and once you've got it a generator you

00:55:54,240 --> 00:55:58,319
can

00:55:54,720 --> 00:56:01,680
you can do just about anything and

00:55:58,319 --> 00:56:05,200
then it ends up being

00:56:01,680 --> 00:56:08,400
a set of trade-offs

00:56:05,200 --> 00:56:11,440
balancing concerns figuring out what you

00:56:08,400 --> 00:56:13,680
want and what you can afford

00:56:11,440 --> 00:56:15,520
and then you can tune and extend later

00:56:13,680 --> 00:56:19,200
if you need to

00:56:15,520 --> 00:56:20,960
and so i was showing this to some people

00:56:19,200 --> 00:56:22,720
and says are you going to propose this

00:56:20,960 --> 00:56:25,599
to the standard

00:56:22,720 --> 00:56:27,200
and the answer at this stage at least is

00:56:25,599 --> 00:56:30,319
no

00:56:27,200 --> 00:56:34,400
if you look at what

00:56:30,319 --> 00:56:36,319
is required of the standards proposal

00:56:34,400 --> 00:56:37,440
what i've just told you and the state of

00:56:36,319 --> 00:56:41,760
my code is not

00:56:37,440 --> 00:56:42,839
up to it you can see what wt21 requires

00:56:41,760 --> 00:56:45,440
it's from

00:56:42,839 --> 00:56:46,319
isocpp.org and you can see my

00:56:45,440 --> 00:56:49,680
explanation

00:56:46,319 --> 00:56:51,599
of what it what i look at in my history

00:56:49,680 --> 00:56:52,720
of programming languages paper from this

00:56:51,599 --> 00:56:54,640
year

00:56:52,720 --> 00:56:57,440
which describes the history of c plus

00:56:54,640 --> 00:56:59,920
plus in the last over 15 years

00:56:57,440 --> 00:57:01,680
so think of this as a design exercise

00:56:59,920 --> 00:57:03,200
think of it something where you can

00:57:01,680 --> 00:57:06,559
think about

00:57:03,200 --> 00:57:09,839
what decisions had to be made

00:57:06,559 --> 00:57:13,440
how were they made were they appropriate

00:57:09,839 --> 00:57:15,680
we need a more better

00:57:13,440 --> 00:57:17,680
there's not an analysis of general

00:57:15,680 --> 00:57:19,119
utility which there should be if it was

00:57:17,680 --> 00:57:20,640
a standard proposal

00:57:19,119 --> 00:57:22,799
there's simply not enough user

00:57:20,640 --> 00:57:23,760
experiment experience this is still an

00:57:22,799 --> 00:57:25,680
experiment

00:57:23,760 --> 00:57:27,440
in particular i would like to know much

00:57:25,680 --> 00:57:27,920
more about what mistakes people will

00:57:27,440 --> 00:57:29,760
make

00:57:27,920 --> 00:57:32,240
so that i can catch them and deal with

00:57:29,760 --> 00:57:33,839
them the implementation is still not

00:57:32,240 --> 00:57:36,480
general enough and that means

00:57:33,839 --> 00:57:36,960
it might hide the signpost i don't think

00:57:36,480 --> 00:57:40,240
so

00:57:36,960 --> 00:57:42,160
but they might and there's not a

00:57:40,240 --> 00:57:43,760
design document which would help

00:57:42,160 --> 00:57:47,359
document and

00:57:43,760 --> 00:57:50,480
systematically show what um

00:57:47,359 --> 00:57:53,280
what was what

00:57:50,480 --> 00:57:55,359
what the decisions were and also i like

00:57:53,280 --> 00:57:56,079
tutorials that's not a good tutorial

00:57:55,359 --> 00:57:58,480
here

00:57:56,079 --> 00:57:59,839
and i would like performance analysis

00:57:58,480 --> 00:58:04,000
done properly

00:57:59,839 --> 00:58:07,200
meaning real applications for real scale

00:58:04,000 --> 00:58:09,760
rather than just micro benchmarks

00:58:07,200 --> 00:58:11,920
so basically the reason i'm talking

00:58:09,760 --> 00:58:14,160
about this is that we talk so much about

00:58:11,920 --> 00:58:18,000
the high level and sophisticated

00:58:14,160 --> 00:58:19,680
and the elegant low-level primitive code

00:58:18,000 --> 00:58:22,480
is an important part of the c

00:58:19,680 --> 00:58:25,359
plus plus world a lot of c plus plus

00:58:22,480 --> 00:58:28,720
deals fairly closely with hardware under

00:58:25,359 --> 00:58:30,720
a variety of constraints so see this

00:58:28,720 --> 00:58:32,000
as an example of discussing such

00:58:30,720 --> 00:58:34,960
problems

00:58:32,000 --> 00:58:36,000
and basically mapping between the high

00:58:34,960 --> 00:58:39,200
level type safe

00:58:36,000 --> 00:58:42,480
code to the machine level so that it's

00:58:39,200 --> 00:58:45,760
done efficiently elegantly and safely

00:58:42,480 --> 00:58:49,680
and this year we cut the

00:58:45,760 --> 00:58:54,240
amount of time for presentations

00:58:49,680 --> 00:58:57,440
because of the virtual nature of this

00:58:54,240 --> 00:58:59,599
so there's no q a just now

00:58:57,440 --> 00:59:00,480
that's sad because usually we can have a

00:58:59,599 --> 00:59:04,160
very nice

00:59:00,480 --> 00:59:06,400
20 minutes half an hour q a

00:59:04,160 --> 00:59:07,359
but if i did that i would cut into other

00:59:06,400 --> 00:59:11,440
people's

00:59:07,359 --> 00:59:13,280
time so instead i'll take questions at

00:59:11,440 --> 00:59:16,960
the ama

00:59:13,280 --> 00:59:20,079
on wednesday morning and whatever you

00:59:16,960 --> 00:59:22,319
you sent during this conference meeting

00:59:20,079 --> 00:59:24,000
will will get to me and i'll take new

00:59:22,319 --> 00:59:27,359
questions on

00:59:24,000 --> 00:59:30,720
wednesday so for this i will

00:59:27,359 --> 00:59:35,359
say thank you and and cut it here

00:59:30,720 --> 00:59:35,359
and see you again on wednesday

00:59:44,839 --> 00:59:47,839
bye

00:59:54,640 --> 00:59:56,720

YouTube URL: https://www.youtube.com/watch?v=ERzENfQ51Ck


