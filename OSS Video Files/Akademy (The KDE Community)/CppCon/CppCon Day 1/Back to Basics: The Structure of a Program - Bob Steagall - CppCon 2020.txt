Title: Back to Basics: The Structure of a Program - Bob Steagall - CppCon 2020
Publication date: 2020-10-08
Playlist: CppCon Day 1
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_the_structure_of_a_program/back_to_basics_the_structure_of_a_program__bob_steagall__cppcon_2020.pdf
---

What's the difference between a declaration and a definition? What is a translation unit, and how is it related to the source code that you write? How would you describe the one-definition rule? What is name-mangling? 

If the answers to these questions are a little hazy for you, or if you would like a refresher on the fundamentals of how source code is converted into executable programs, then this talk is for you.

In this session, we'll cover the process of compiling and linking C++ source code, describing and discussing the key concepts involved in that process along the way. Attendees will leave with a basic understanding of such fundamental concepts as translation units, declarations, definitions, the one-definition rule, name-mangling, ABIs, and how the compiler and linker conspire to convert human-readable source code into binary code that executes on hardware.

---

Bob Steagall
Chief Cook and Bottle Washer, KEWB Computing

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,360 --> 00:00:12,400
hello everyone

00:00:10,400 --> 00:00:14,320
thank you for coming my name is bob

00:00:12,400 --> 00:00:16,640
stegall and this is the second talk at

00:00:14,320 --> 00:00:18,400
this year's back to basics track

00:00:16,640 --> 00:00:20,160
each session in the back to basics track

00:00:18,400 --> 00:00:21,680
is about a single concrete topic

00:00:20,160 --> 00:00:23,760
like this one which is entitled the

00:00:21,680 --> 00:00:25,519
structure of a program

00:00:23,760 --> 00:00:27,039
our goal is to produce content that

00:00:25,519 --> 00:00:28,400
covers important things you need to know

00:00:27,039 --> 00:00:31,439
to be a working programmer

00:00:28,400 --> 00:00:33,440
in today's c plus community that being

00:00:31,439 --> 00:00:35,360
said many thanks to our back-to-basics

00:00:33,440 --> 00:00:37,040
track chair arthur o'dwyer for putting

00:00:35,360 --> 00:00:38,960
together the track program

00:00:37,040 --> 00:00:40,480
and to our conference chair john cowell

00:00:38,960 --> 00:00:43,200
for making c

00:00:40,480 --> 00:00:43,600
making cppcon such a great experience

00:00:43,200 --> 00:00:45,760
and

00:00:43,600 --> 00:00:48,000
for dealing with the difficulties this

00:00:45,760 --> 00:00:48,000
year

00:00:48,160 --> 00:00:55,440
in this talk i plan to cover things

00:00:51,600 --> 00:00:55,440
like the process of building a program

00:00:55,600 --> 00:01:00,559
what a translation unit is and its

00:00:57,680 --> 00:01:02,800
relationship to the code that you write

00:01:00,559 --> 00:01:04,720
the various phases of translation which

00:01:02,800 --> 00:01:06,560
means taking a program from source code

00:01:04,720 --> 00:01:09,360
to executable

00:01:06,560 --> 00:01:11,040
declarations definitions and linkage the

00:01:09,360 --> 00:01:15,680
one definition rule

00:01:11,040 --> 00:01:18,640
storage duration abis and name angling

00:01:15,680 --> 00:01:18,640
linkage and loading

00:01:19,759 --> 00:01:23,600
my goal in this talk my goals are

00:01:21,920 --> 00:01:26,640
threefold

00:01:23,600 --> 00:01:27,680
first i'd like to describe a few very

00:01:26,640 --> 00:01:31,040
important

00:01:27,680 --> 00:01:31,680
global concepts global in the sense that

00:01:31,040 --> 00:01:33,360
these are

00:01:31,680 --> 00:01:35,759
probably fundamental things that every

00:01:33,360 --> 00:01:38,240
serious c plus programmer should know

00:01:35,759 --> 00:01:39,759
but don't necessarily dive too deeply

00:01:38,240 --> 00:01:41,759
into the language

00:01:39,759 --> 00:01:43,759
itself although certainly like

00:01:41,759 --> 00:01:45,280
everything in c plus plus

00:01:43,759 --> 00:01:48,399
there probably is no bottom to the

00:01:45,280 --> 00:01:50,560
rabbit hole for some of these things

00:01:48,399 --> 00:01:51,920
i'd like to clarify terminology that

00:01:50,560 --> 00:01:54,240
gets used a lot

00:01:51,920 --> 00:01:55,520
and that can be confusing especially to

00:01:54,240 --> 00:01:57,439
those of us

00:01:55,520 --> 00:01:58,960
who are perhaps less experienced or just

00:01:57,439 --> 00:02:02,000
starting with c plus

00:01:58,960 --> 00:02:03,520
terminology that can be confusing

00:02:02,000 --> 00:02:05,360
and i'd like to shine a little bit of

00:02:03,520 --> 00:02:08,720
light at least at a very high level

00:02:05,360 --> 00:02:11,360
on how c plus plus compilation works

00:02:08,720 --> 00:02:12,480
it's been my experience in recent

00:02:11,360 --> 00:02:14,319
employment

00:02:12,480 --> 00:02:15,920
that some of our engineers coming out of

00:02:14,319 --> 00:02:17,599
college and those with

00:02:15,920 --> 00:02:19,360
lots of experience in other languages

00:02:17,599 --> 00:02:22,800
and not much experience in c

00:02:19,360 --> 00:02:24,480
plus seem to have some difficulty

00:02:22,800 --> 00:02:26,239
understanding what actually goes on

00:02:24,480 --> 00:02:29,120
under the hood when a c plus

00:02:26,239 --> 00:02:31,360
program is built and this lack of

00:02:29,120 --> 00:02:32,800
understanding i think

00:02:31,360 --> 00:02:35,040
hampered their effectiveness

00:02:32,800 --> 00:02:37,280
effectiveness in some ways

00:02:35,040 --> 00:02:38,879
and so it's my hope that by providing

00:02:37,280 --> 00:02:41,920
this somewhat basic

00:02:38,879 --> 00:02:43,920
tutorial on these important but also

00:02:41,920 --> 00:02:46,879
kind of basic topics

00:02:43,920 --> 00:02:48,560
that i either help fill in the gaps or

00:02:46,879 --> 00:02:49,360
maybe help improve the understanding of

00:02:48,560 --> 00:02:51,040
some of the

00:02:49,360 --> 00:02:53,200
less experienced who may be watching

00:02:51,040 --> 00:02:53,200
this

00:02:53,360 --> 00:02:58,239
so let's talk about building and running

00:02:55,519 --> 00:02:59,760
c plus program

00:02:58,239 --> 00:03:02,959
let's start at a very high level the

00:02:59,760 --> 00:03:05,200
fifty thousand foot view

00:03:02,959 --> 00:03:07,599
we begin with input files our c plus

00:03:05,200 --> 00:03:10,239
source code

00:03:07,599 --> 00:03:11,920
and we take those input files and we

00:03:10,239 --> 00:03:14,560
process them through some development

00:03:11,920 --> 00:03:14,560
tool chain

00:03:14,720 --> 00:03:18,000
if you're like me typically this is a

00:03:16,720 --> 00:03:19,840
loop that you go through from the

00:03:18,000 --> 00:03:22,159
development tools back to the input

00:03:19,840 --> 00:03:25,200
files it's edit compile edit compile

00:03:22,159 --> 00:03:27,280
over and over again until at some point

00:03:25,200 --> 00:03:29,680
you're either smart or lucky and you get

00:03:27,280 --> 00:03:31,200
an executable file

00:03:29,680 --> 00:03:33,599
once you have an executable file you

00:03:31,200 --> 00:03:35,519
want to run the program so the os loader

00:03:33,599 --> 00:03:37,360
takes over

00:03:35,519 --> 00:03:39,120
and you end up with an image running on

00:03:37,360 --> 00:03:42,959
the operating system

00:03:39,120 --> 00:03:44,640
now at some point usually it ends

00:03:42,959 --> 00:03:46,480
and you go back to the development tool

00:03:44,640 --> 00:03:47,440
chain you fix a bug you add a new

00:03:46,480 --> 00:03:50,640
feature

00:03:47,440 --> 00:03:53,200
you modify operation you

00:03:50,640 --> 00:03:55,599
take away functionality but you have to

00:03:53,200 --> 00:03:58,560
change the program

00:03:55,599 --> 00:03:58,560
to create a new version

00:03:58,879 --> 00:04:04,640
so an important part of this talk

00:04:02,159 --> 00:04:05,599
is talking about the input files our c

00:04:04,640 --> 00:04:07,040
source code

00:04:05,599 --> 00:04:08,720
and how they should be structured in

00:04:07,040 --> 00:04:12,640
such a way that

00:04:08,720 --> 00:04:14,799
one can create working programs

00:04:12,640 --> 00:04:16,720
so let's talk about user-defined code

00:04:14,799 --> 00:04:17,840
this is in my mind this is the code that

00:04:16,720 --> 00:04:21,680
you write

00:04:17,840 --> 00:04:25,120
and this consists of header files

00:04:21,680 --> 00:04:28,639
source code files and resource

00:04:25,120 --> 00:04:32,160
files now resource files

00:04:28,639 --> 00:04:32,160
are those things which contain

00:04:32,320 --> 00:04:38,479
things like icons cursors

00:04:35,840 --> 00:04:40,880
internationalization translations things

00:04:38,479 --> 00:04:43,680
which you may want bound into a program

00:04:40,880 --> 00:04:44,080
when you deliver that program but which

00:04:43,680 --> 00:04:45,600
don't

00:04:44,080 --> 00:04:47,280
contribute to the execution of the

00:04:45,600 --> 00:04:49,919
program and are not part of the actual

00:04:47,280 --> 00:04:52,160
source code that you write

00:04:49,919 --> 00:04:53,840
then we have our dependencies and i

00:04:52,160 --> 00:04:57,520
think of dependencies as being

00:04:53,840 --> 00:05:00,080
effectively the libraries that we use

00:04:57,520 --> 00:05:01,600
the libraries that we use will provide

00:05:00,080 --> 00:05:05,280
header files

00:05:01,600 --> 00:05:08,320
like uh stud the standard library vector

00:05:05,280 --> 00:05:11,280
or boost text.hpp if you want to use

00:05:08,320 --> 00:05:13,400
that facility from boost

00:05:11,280 --> 00:05:15,840
libraries oftentimes provide

00:05:13,400 --> 00:05:17,919
pre-compiled files pre

00:05:15,840 --> 00:05:19,759
files that have object or executable

00:05:17,919 --> 00:05:23,120
code pre-compiled

00:05:19,759 --> 00:05:26,000
like the standard libraries from gcc

00:05:23,120 --> 00:05:27,120
clang the microsoft runtime library

00:05:26,000 --> 00:05:31,120
[Music]

00:05:27,120 --> 00:05:31,600
the microsoft winsock library or crt 1.0

00:05:31,120 --> 00:05:35,039
which is

00:05:31,600 --> 00:05:38,960
magic object code used on linux to

00:05:35,039 --> 00:05:41,680
make your program load and run

00:05:38,960 --> 00:05:42,720
and oftentimes libraries will provide

00:05:41,680 --> 00:05:45,600
source code

00:05:42,720 --> 00:05:47,680
for some libraries those that are not

00:05:45,600 --> 00:05:50,639
heterony

00:05:47,680 --> 00:05:51,600
like boost for example to get the

00:05:50,639 --> 00:05:52,960
library to work

00:05:51,600 --> 00:05:54,320
not only do you have to employ the

00:05:52,960 --> 00:05:54,960
headers but you have to download the

00:05:54,320 --> 00:05:56,960
source

00:05:54,960 --> 00:05:58,960
and build a source and building that

00:05:56,960 --> 00:06:01,759
library source becomes part of your

00:05:58,960 --> 00:06:01,759
build process

00:06:02,560 --> 00:06:06,080
and as i mentioned before the idea of

00:06:05,039 --> 00:06:08,160
resources

00:06:06,080 --> 00:06:10,240
libraries can come with resources bound

00:06:08,160 --> 00:06:13,120
into their static archives

00:06:10,240 --> 00:06:15,600
or to their shared objects and these

00:06:13,120 --> 00:06:18,720
resources can be icons or images or

00:06:15,600 --> 00:06:18,720
translations used for

00:06:18,840 --> 00:06:21,680
internationalization

00:06:20,000 --> 00:06:23,120
one thing to keep in mind and perhaps a

00:06:21,680 --> 00:06:24,960
question to ask yourself as we go

00:06:23,120 --> 00:06:27,120
through these slides is

00:06:24,960 --> 00:06:29,759
why is there this division between

00:06:27,120 --> 00:06:31,600
header files and source files

00:06:29,759 --> 00:06:33,520
why do we structure things in the way

00:06:31,600 --> 00:06:35,520
that we do

00:06:33,520 --> 00:06:37,840
and when we talk about declarations and

00:06:35,520 --> 00:06:40,240
definitions in the one definition rule

00:06:37,840 --> 00:06:41,919
hopefully it will become apparent why

00:06:40,240 --> 00:06:44,400
there is this bifurcation in the code

00:06:41,919 --> 00:06:44,400
that we write

00:06:44,800 --> 00:06:49,680
so let's look at the c plus plus

00:06:46,400 --> 00:06:52,319
ecosystem programming ecosystem

00:06:49,680 --> 00:06:53,599
it's actually fairly complex

00:06:52,319 --> 00:06:56,880
surprisingly so

00:06:53,599 --> 00:07:00,560
especially in today's world you have us

00:06:56,880 --> 00:07:00,960
the programmer and a whole wide variety

00:07:00,560 --> 00:07:03,840
of

00:07:00,960 --> 00:07:06,000
of things and flows of information

00:07:03,840 --> 00:07:08,000
between those things that contribute

00:07:06,000 --> 00:07:10,240
to the executable file that we're trying

00:07:08,000 --> 00:07:13,199
to create

00:07:10,240 --> 00:07:14,319
we have tools for managing source code

00:07:13,199 --> 00:07:18,639
and we have

00:07:14,319 --> 00:07:20,000
tools editors and ides that are used to

00:07:18,639 --> 00:07:23,280
compose

00:07:20,000 --> 00:07:24,960
and maintain the source code itself

00:07:23,280 --> 00:07:27,280
there's a whole wide variety of these

00:07:24,960 --> 00:07:29,520
hundreds hundreds of editors

00:07:27,280 --> 00:07:30,560
and probably a few tens if not a hundred

00:07:29,520 --> 00:07:34,639
or more

00:07:30,560 --> 00:07:36,080
ides then we have our version control

00:07:34,639 --> 00:07:38,400
systems like well git

00:07:36,080 --> 00:07:40,240
is the one i think most people use today

00:07:38,400 --> 00:07:42,080
which we use to manage

00:07:40,240 --> 00:07:43,759
the versions of our source code so we

00:07:42,080 --> 00:07:45,199
can keep track of changes that have

00:07:43,759 --> 00:07:47,680
occurred over time

00:07:45,199 --> 00:07:48,800
and again there are a large variety of

00:07:47,680 --> 00:07:50,400
these

00:07:48,800 --> 00:07:51,840
i've just picked a few out at random

00:07:50,400 --> 00:07:52,720
including some that i've used in the

00:07:51,840 --> 00:07:56,560
past

00:07:52,720 --> 00:07:56,560
for this little balloon

00:07:56,960 --> 00:08:00,080
we have tools that help us manage

00:07:58,879 --> 00:08:02,400
dependencies

00:08:00,080 --> 00:08:04,000
uh the big one these days seems to be

00:08:02,400 --> 00:08:06,240
conan but there are certainly others

00:08:04,000 --> 00:08:07,840
there's build two there's buckaroo

00:08:06,240 --> 00:08:10,240
people do dependency management with

00:08:07,840 --> 00:08:11,039
cmake you can do dependency management

00:08:10,240 --> 00:08:14,000
with make

00:08:11,039 --> 00:08:15,199
itself uh visual studio and microsoft

00:08:14,000 --> 00:08:18,240
have nuget

00:08:15,199 --> 00:08:19,280
and vc package and then of course you

00:08:18,240 --> 00:08:21,919
can manage

00:08:19,280 --> 00:08:23,680
packages and dependencies libraries

00:08:21,919 --> 00:08:27,440
yourself manually which is kind of the

00:08:23,680 --> 00:08:29,599
old-school way of doing it

00:08:27,440 --> 00:08:32,479
we have tools that manage the actual

00:08:29,599 --> 00:08:36,240
process of the build itself

00:08:32,479 --> 00:08:39,279
the traditional make and make cmake

00:08:36,240 --> 00:08:42,240
there's ninja an incredible jam

00:08:39,279 --> 00:08:44,480
there's boost build there's ms build

00:08:42,240 --> 00:08:47,120
there's a whole slew of things which

00:08:44,480 --> 00:08:48,080
automatically manage taking groups of

00:08:47,120 --> 00:08:50,560
source code

00:08:48,080 --> 00:08:52,240
files and turning them into programs for

00:08:50,560 --> 00:08:54,720
you

00:08:52,240 --> 00:08:56,000
let's not forget the compiler there are

00:08:54,720 --> 00:08:58,399
all kinds of compilers

00:08:56,000 --> 00:09:00,240
well not all kinds but there's certainly

00:08:58,399 --> 00:09:01,120
a good variety of compilers available

00:09:00,240 --> 00:09:04,800
these days

00:09:01,120 --> 00:09:05,680
from clang to gcc there's microsoft's

00:09:04,800 --> 00:09:07,920
compiler

00:09:05,680 --> 00:09:09,279
we have the intel compiler the portland

00:09:07,920 --> 00:09:11,760
group compiler

00:09:09,279 --> 00:09:12,800
we have the ibm's compiler and there are

00:09:11,760 --> 00:09:14,399
a few more

00:09:12,800 --> 00:09:16,560
although writing a compiler is such a

00:09:14,399 --> 00:09:17,600
big and difficult and expensive task

00:09:16,560 --> 00:09:19,200
these days

00:09:17,600 --> 00:09:21,600
there aren't nearly as many compilers as

00:09:19,200 --> 00:09:23,680
there are editors

00:09:21,600 --> 00:09:25,519
and then finally there's the linker and

00:09:23,680 --> 00:09:27,360
there are well quite a bit fewer of

00:09:25,519 --> 00:09:29,120
these than there are compilers i've just

00:09:27,360 --> 00:09:32,560
listed the names of the ones

00:09:29,120 --> 00:09:35,519
that i've used uh ld

00:09:32,560 --> 00:09:36,000
ldbfd ld gold and lld i've used all of

00:09:35,519 --> 00:09:38,080
those on

00:09:36,000 --> 00:09:39,760
linux i think ld is the name that's

00:09:38,080 --> 00:09:41,760
traditionally used for the linker on

00:09:39,760 --> 00:09:44,000
other platforms and i've worked on

00:09:41,760 --> 00:09:46,160
solaris and linux and freebsd and

00:09:44,000 --> 00:09:47,760
they'll call the linker ld

00:09:46,160 --> 00:09:50,720
and of course with microsoft there's the

00:09:47,760 --> 00:09:51,760
venerable link.exe all of those things

00:09:50,720 --> 00:09:53,600
conspire to help

00:09:51,760 --> 00:09:56,800
build the executable file the program

00:09:53,600 --> 00:09:59,040
you're trying to trying to make

00:09:56,800 --> 00:10:00,880
now we don't always build executables

00:09:59,040 --> 00:10:01,920
sometimes we build dynamically linked

00:10:00,880 --> 00:10:04,160
libraries

00:10:01,920 --> 00:10:06,079
and the process for building that is

00:10:04,160 --> 00:10:08,079
surprisingly similar it's almost

00:10:06,079 --> 00:10:09,360
identical to that of building an

00:10:08,079 --> 00:10:11,040
executable

00:10:09,360 --> 00:10:13,279
the difference between a shared object

00:10:11,040 --> 00:10:15,760
and an executable in most cases

00:10:13,279 --> 00:10:16,880
is that an executable has extra code in

00:10:15,760 --> 00:10:19,680
it that allows the

00:10:16,880 --> 00:10:21,839
operating system loader to load the

00:10:19,680 --> 00:10:24,880
program into memory begin its execution

00:10:21,839 --> 00:10:27,600
and it contains a main function

00:10:24,880 --> 00:10:29,519
dlls shared objects typically typically

00:10:27,600 --> 00:10:31,279
don't have those things

00:10:29,519 --> 00:10:33,200
but dlls and shared objects are not the

00:10:31,279 --> 00:10:36,320
only kind of libraries we want to write

00:10:33,200 --> 00:10:40,720
there are also static archives

00:10:36,320 --> 00:10:42,480
on linux they have the extension.a

00:10:40,720 --> 00:10:44,079
there's a tool called the archiver and

00:10:42,480 --> 00:10:44,800
it builds a thing called a static

00:10:44,079 --> 00:10:46,880
archive

00:10:44,800 --> 00:10:48,240
a library which is basically just a

00:10:46,880 --> 00:10:50,720
concatenation

00:10:48,240 --> 00:10:51,839
of object code from a bunch of compiled

00:10:50,720 --> 00:10:54,560
modules

00:10:51,839 --> 00:10:57,519
windows has its library and it creates

00:10:54,560 --> 00:11:00,000
static archives with a dot lib extension

00:10:57,519 --> 00:11:00,800
it's not quite as extensive as that of

00:11:00,000 --> 00:11:02,560
building a

00:11:00,800 --> 00:11:04,399
shared object or an executable because

00:11:02,560 --> 00:11:07,519
there's no need to worry about

00:11:04,399 --> 00:11:08,160
main or do fix-ups that are required by

00:11:07,519 --> 00:11:10,560
linking

00:11:08,160 --> 00:11:12,079
or relocations so static archives are

00:11:10,560 --> 00:11:16,399
actually quite a bit simpler

00:11:12,079 --> 00:11:16,399
than shared objects or executables

00:11:16,720 --> 00:11:20,079
so our focus in this talk is really

00:11:18,320 --> 00:11:23,360
going to be on the first

00:11:20,079 --> 00:11:25,200
three stages of that initial diagram

00:11:23,360 --> 00:11:28,560
taking input files through a development

00:11:25,200 --> 00:11:30,399
tool chain and creating executable files

00:11:28,560 --> 00:11:32,079
and again i just want to be clear this

00:11:30,399 --> 00:11:34,640
is a very high level view

00:11:32,079 --> 00:11:36,240
intended to help people uh fill in their

00:11:34,640 --> 00:11:36,880
knowledge gaps with regard to these

00:11:36,240 --> 00:11:38,720
things

00:11:36,880 --> 00:11:41,040
if you're coming to c plus from another

00:11:38,720 --> 00:11:42,720
language like java or python and you've

00:11:41,040 --> 00:11:43,680
never worked in a compiled environment

00:11:42,720 --> 00:11:45,440
before

00:11:43,680 --> 00:11:48,320
i think you'll find this helpful at

00:11:45,440 --> 00:11:48,320
least i hope you will

00:11:48,560 --> 00:11:52,800
so how do we represent our c plus plus

00:11:50,720 --> 00:11:54,720
programs i mean our programs the code

00:11:52,800 --> 00:11:56,000
and write they tell the compiler what we

00:11:54,720 --> 00:11:59,200
want the underlying hardware

00:11:56,000 --> 00:12:00,000
to do well we represent our programs by

00:11:59,200 --> 00:12:01,839
source code

00:12:00,000 --> 00:12:03,920
and source code is expressed in human

00:12:01,839 --> 00:12:05,680
readable text files

00:12:03,920 --> 00:12:08,240
we typically have three kinds of source

00:12:05,680 --> 00:12:11,519
code i think i mentioned them before

00:12:08,240 --> 00:12:13,279
we have header files also called headers

00:12:11,519 --> 00:12:15,519
which are generally used more than once

00:12:13,279 --> 00:12:17,839
when building an executable

00:12:15,519 --> 00:12:18,880
we have source files and i'll just call

00:12:17,839 --> 00:12:21,519
them source

00:12:18,880 --> 00:12:23,120
which are generally used only once when

00:12:21,519 --> 00:12:25,839
building an executable

00:12:23,120 --> 00:12:27,600
and we have resource files used to

00:12:25,839 --> 00:12:28,399
represent special non-executable

00:12:27,600 --> 00:12:32,480
information

00:12:28,399 --> 00:12:35,200
again like cursors or icons images or

00:12:32,480 --> 00:12:36,800
internationalization translations so

00:12:35,200 --> 00:12:37,760
from this point forward when i say

00:12:36,800 --> 00:12:40,399
source code

00:12:37,760 --> 00:12:41,279
i mean the totality or the set union of

00:12:40,399 --> 00:12:44,480
header files

00:12:41,279 --> 00:12:48,160
and source files in general likewise

00:12:44,480 --> 00:12:51,440
terms header files header source files

00:12:48,160 --> 00:12:54,079
and source are strict subsets of that

00:12:51,440 --> 00:12:55,600
encompassing term source code i won't

00:12:54,079 --> 00:12:58,560
mention resource files anymore as

00:12:55,600 --> 00:13:01,279
they're not relevant to this discussion

00:12:58,560 --> 00:13:03,279
so at the bottom is a trivial c plus

00:13:01,279 --> 00:13:05,279
program to print hello

00:13:03,279 --> 00:13:07,279
it's slightly more complex than hello

00:13:05,279 --> 00:13:08,000
world and chosen to raise a few

00:13:07,279 --> 00:13:10,320
questions

00:13:08,000 --> 00:13:11,120
or to raise the question why does this

00:13:10,320 --> 00:13:14,320
work

00:13:11,120 --> 00:13:15,600
or how does this program build we have

00:13:14,320 --> 00:13:18,079
the definition

00:13:15,600 --> 00:13:19,040
of the function we want to run print

00:13:18,079 --> 00:13:21,839
hello

00:13:19,040 --> 00:13:23,279
we have an implementation of print hello

00:13:21,839 --> 00:13:25,760
and we have a main function

00:13:23,279 --> 00:13:26,639
that calls print hello and when executed

00:13:25,760 --> 00:13:31,200
we'll actually

00:13:26,639 --> 00:13:31,200
print it to the to the terminal

00:13:32,320 --> 00:13:36,240
so when we build an executable those are

00:13:34,800 --> 00:13:38,720
accomplished through the process of

00:13:36,240 --> 00:13:39,680
compilation and linking why do we do

00:13:38,720 --> 00:13:41,920
this

00:13:39,680 --> 00:13:44,240
well our human readable text files must

00:13:41,920 --> 00:13:45,600
be converted to binary machine language

00:13:44,240 --> 00:13:49,040
and so the picture i'd like you to keep

00:13:45,600 --> 00:13:50,560
in mind is this let's strip out

00:13:49,040 --> 00:13:52,639
things that we don't real that are not

00:13:50,560 --> 00:13:54,639
pertinent to the discussion having to do

00:13:52,639 --> 00:13:55,279
with the tool chains and how tool chains

00:13:54,639 --> 00:13:58,160
interact

00:13:55,279 --> 00:13:58,720
and just look at the basics we have our

00:13:58,160 --> 00:14:01,519
headers

00:13:58,720 --> 00:14:04,000
and our source we have library headers

00:14:01,519 --> 00:14:06,160
and possibly library source codes

00:14:04,000 --> 00:14:07,839
we have the process of compilation which

00:14:06,160 --> 00:14:09,440
gives us object files

00:14:07,839 --> 00:14:11,920
we have the process of linking which

00:14:09,440 --> 00:14:14,480
takes the object files that we create

00:14:11,920 --> 00:14:16,320
and adds to them the object code from

00:14:14,480 --> 00:14:18,560
libraries that we want to use

00:14:16,320 --> 00:14:20,000
and if everything works well and we've

00:14:18,560 --> 00:14:22,720
done our job and maybe even if we're

00:14:20,000 --> 00:14:25,680
lucky we get an executable file

00:14:22,720 --> 00:14:26,639
so what we'll do is we'll dig into this

00:14:25,680 --> 00:14:29,199
a little bit more

00:14:26,639 --> 00:14:29,199
as we go

00:14:29,760 --> 00:14:34,160
let's talk about compilation compilation

00:14:32,880 --> 00:14:35,600
is the process of taking

00:14:34,160 --> 00:14:37,360
our source code and turning it into

00:14:35,600 --> 00:14:40,639
binary code usually called

00:14:37,360 --> 00:14:42,480
object code files from a compiler design

00:14:40,639 --> 00:14:44,399
a high level perspective

00:14:42,480 --> 00:14:45,760
it's usually described as consisting of

00:14:44,399 --> 00:14:49,199
four four parts

00:14:45,760 --> 00:14:52,880
lexical analysis syntax syntax analysis

00:14:49,199 --> 00:14:56,160
semantic analysis and code generation

00:14:52,880 --> 00:14:58,480
now syntax uh

00:14:56,160 --> 00:15:00,320
lexical analysis is usually called

00:14:58,480 --> 00:15:02,399
scanning or tokenization

00:15:00,320 --> 00:15:03,600
it happens before you do syntax analysis

00:15:02,399 --> 00:15:06,240
and it converts

00:15:03,600 --> 00:15:06,959
the code into tokens which are the parts

00:15:06,240 --> 00:15:08,639
of

00:15:06,959 --> 00:15:11,440
of the code that the program actually

00:15:08,639 --> 00:15:14,480
used to construct binaries

00:15:11,440 --> 00:15:17,600
syntax analysis which we also call

00:15:14,480 --> 00:15:20,079
parsing involves reading through

00:15:17,600 --> 00:15:21,360
the token sequence that comes in from

00:15:20,079 --> 00:15:23,839
the lexical analysis

00:15:21,360 --> 00:15:26,000
phase to identify the syntactic

00:15:23,839 --> 00:15:27,360
structure of the program

00:15:26,000 --> 00:15:29,199
in this phase we typically build

00:15:27,360 --> 00:15:31,040
something called a parse tree which

00:15:29,199 --> 00:15:32,480
replaces the linear sequence of tokens

00:15:31,040 --> 00:15:34,160
with a tree structure

00:15:32,480 --> 00:15:35,839
that's built according to the rules of a

00:15:34,160 --> 00:15:37,040
formal grammar that describes the

00:15:35,839 --> 00:15:39,199
language

00:15:37,040 --> 00:15:40,959
and that parse tree is analyzed and

00:15:39,199 --> 00:15:42,560
transformed by later phases in the

00:15:40,959 --> 00:15:44,959
compiler

00:15:42,560 --> 00:15:46,480
semantic analysis adds semantic

00:15:44,959 --> 00:15:47,440
information about the intent of the

00:15:46,480 --> 00:15:49,040
program

00:15:47,440 --> 00:15:50,800
into the parse tree and it builds a

00:15:49,040 --> 00:15:54,240
symbol table

00:15:50,800 --> 00:15:56,320
it does semantic checks for example

00:15:54,240 --> 00:15:58,800
type checking making sure that types

00:15:56,320 --> 00:16:00,399
match correctly and expressions

00:15:58,800 --> 00:16:02,160
it does object binding which means

00:16:00,399 --> 00:16:05,040
associating variable and function

00:16:02,160 --> 00:16:08,000
references with their definitions

00:16:05,040 --> 00:16:08,720
it does assignment it rejects incorrect

00:16:08,000 --> 00:16:11,519
programs

00:16:08,720 --> 00:16:13,279
or issues warnings and finally the last

00:16:11,519 --> 00:16:14,000
step is code generation which is the

00:16:13,279 --> 00:16:16,399
process

00:16:14,000 --> 00:16:18,079
in which compiler's code generator takes

00:16:16,399 --> 00:16:18,639
the intermediate representation that

00:16:18,079 --> 00:16:21,279
comes from

00:16:18,639 --> 00:16:23,839
semantic analysis and it turns it into

00:16:21,279 --> 00:16:23,839
machine code

00:16:23,920 --> 00:16:28,800
in c plus plus we typically generate one

00:16:26,720 --> 00:16:29,360
object code file for each indistinct

00:16:28,800 --> 00:16:32,079
source

00:16:29,360 --> 00:16:34,720
each distinct source file every dot cpp

00:16:32,079 --> 00:16:36,800
or dot cxx or dot cc file

00:16:34,720 --> 00:16:38,480
typically results in one corresponding

00:16:36,800 --> 00:16:40,160
dot o or dot obj

00:16:38,480 --> 00:16:42,639
file depending what platform you're

00:16:40,160 --> 00:16:42,639
working on

00:16:42,880 --> 00:16:46,399
linking is really the process of taking

00:16:44,880 --> 00:16:47,360
the object files that come out of the

00:16:46,399 --> 00:16:49,120
compiler

00:16:47,360 --> 00:16:50,399
combining them with object code in our

00:16:49,120 --> 00:16:52,160
binary libraries

00:16:50,399 --> 00:16:55,600
stitching it all together and making a

00:16:52,160 --> 00:16:55,600
working program that we can run

00:16:55,920 --> 00:17:00,320
now the standard calls the process of

00:16:57,759 --> 00:17:03,360
compilation translation

00:17:00,320 --> 00:17:04,959
and in c plus translation is for

00:17:03,360 --> 00:17:06,400
performed on something called a

00:17:04,959 --> 00:17:09,760
translation unit

00:17:06,400 --> 00:17:13,760
in nine well-defined stages and

00:17:09,760 --> 00:17:15,919
uh those nine stages cover the four

00:17:13,760 --> 00:17:16,959
phases of compilation if you will that i

00:17:15,919 --> 00:17:19,199
just mentioned

00:17:16,959 --> 00:17:21,439
except they lay things out perhaps in

00:17:19,199 --> 00:17:23,600
greater detail

00:17:21,439 --> 00:17:24,559
the committee has very evocatively named

00:17:23,600 --> 00:17:28,160
these phases

00:17:24,559 --> 00:17:30,240
phases one through nine so i mentioned

00:17:28,160 --> 00:17:32,960
translation unit what is that

00:17:30,240 --> 00:17:35,039
well translation unit is defined roughly

00:17:32,960 --> 00:17:37,919
this is not an exact definition

00:17:35,039 --> 00:17:38,320
it's defined roughly as a source file

00:17:37,919 --> 00:17:40,160
plus

00:17:38,320 --> 00:17:42,640
all of the headers and source files that

00:17:40,160 --> 00:17:45,760
are included in it via the include

00:17:42,640 --> 00:17:48,240
pre-processing directive minus any

00:17:45,760 --> 00:17:51,200
source code lines that are skipped by

00:17:48,240 --> 00:17:53,600
conditional directives for example if

00:17:51,200 --> 00:17:56,559
you've if depth in or if duffed out

00:17:53,600 --> 00:17:59,039
a section of code and with all macros

00:17:56,559 --> 00:17:59,039
expanded

00:17:59,360 --> 00:18:03,679
so here's a simple graphical

00:18:01,919 --> 00:18:06,400
representation of the nine phases of

00:18:03,679 --> 00:18:06,400
translation

00:18:06,640 --> 00:18:10,160
and i'm going to briefly touch on each

00:18:08,640 --> 00:18:10,880
one of the nine because i think they're

00:18:10,160 --> 00:18:15,520
important

00:18:10,880 --> 00:18:17,440
to understand so in phase one

00:18:15,520 --> 00:18:19,440
individual bytes of the source file are

00:18:17,440 --> 00:18:21,200
mapped into characters of

00:18:19,440 --> 00:18:22,720
something that's called the basic source

00:18:21,200 --> 00:18:24,400
character set

00:18:22,720 --> 00:18:27,039
and the basic source character set

00:18:24,400 --> 00:18:30,160
consists of 96 characters

00:18:27,039 --> 00:18:31,039
uh the space character uh four

00:18:30,160 --> 00:18:34,160
non-printing

00:18:31,039 --> 00:18:37,120
control characters like tab and new line

00:18:34,160 --> 00:18:38,720
and 91 graphical characters the 91

00:18:37,120 --> 00:18:43,840
characters that you see

00:18:38,720 --> 00:18:43,840
when you type code into a c plus program

00:18:44,240 --> 00:18:50,559
in phase two lines that are escaped

00:18:48,320 --> 00:18:51,520
with a backslash character at the end of

00:18:50,559 --> 00:18:55,280
the line

00:18:51,520 --> 00:18:56,880
are concatenated every instance of a

00:18:55,280 --> 00:18:58,480
backslash character

00:18:56,880 --> 00:19:00,160
that's immediately followed by a new

00:18:58,480 --> 00:19:03,919
line character

00:19:00,160 --> 00:19:05,200
uh is deleted and the physical line the

00:19:03,919 --> 00:19:07,200
physical source code lines

00:19:05,200 --> 00:19:11,840
are spliced together to make a new

00:19:07,200 --> 00:19:11,840
logical source code line

00:19:12,559 --> 00:19:16,559
in phase 3 the source file is decomposed

00:19:15,600 --> 00:19:19,200
into something called

00:19:16,559 --> 00:19:20,799
pre-processing tokens and sequences of

00:19:19,200 --> 00:19:23,919
white space characters

00:19:20,799 --> 00:19:25,679
and comments now a pre-processing token

00:19:23,919 --> 00:19:26,559
is the minimal lexical element of the

00:19:25,679 --> 00:19:28,240
language

00:19:26,559 --> 00:19:31,840
that's necessary for phases three

00:19:28,240 --> 00:19:33,120
through six uh defined by the standard

00:19:31,840 --> 00:19:34,960
there are several categories of

00:19:33,120 --> 00:19:36,720
pre-processing token and the set of

00:19:34,960 --> 00:19:37,520
pre-processing tokens is actually a

00:19:36,720 --> 00:19:39,360
superset

00:19:37,520 --> 00:19:41,919
of the set of tokens that's recognized

00:19:39,360 --> 00:19:43,919
by the compiler itself

00:19:41,919 --> 00:19:45,679
there are header names there are

00:19:43,919 --> 00:19:48,559
placeholder tokens

00:19:45,679 --> 00:19:49,840
used when pre-processing occurs there

00:19:48,559 --> 00:19:52,799
are

00:19:49,840 --> 00:19:55,120
inclusion directives like pound include

00:19:52,799 --> 00:19:57,600
if death

00:19:55,120 --> 00:19:57,600
there are

00:19:58,160 --> 00:20:01,200
there are literals

00:20:01,360 --> 00:20:05,520
that potentially need pre-processing

00:20:03,120 --> 00:20:07,760
there are string literals

00:20:05,520 --> 00:20:08,720
there are pre-processing operators and

00:20:07,760 --> 00:20:11,840
punctuators

00:20:08,720 --> 00:20:13,440
and uh single non-white space characters

00:20:11,840 --> 00:20:16,720
that don't lexically match

00:20:13,440 --> 00:20:18,080
other other categories so

00:20:16,720 --> 00:20:20,320
at the end of the day we've got

00:20:18,080 --> 00:20:22,640
pre-processing tokens each comment is

00:20:20,320 --> 00:20:24,880
replaced by one white space character

00:20:22,640 --> 00:20:28,159
and all the new line characters in the

00:20:24,880 --> 00:20:28,159
in the source are retained

00:20:28,640 --> 00:20:35,679
in stage four pre-processing directives

00:20:32,240 --> 00:20:37,919
the if-defs the pound include

00:20:35,679 --> 00:20:39,039
the things that begin with pound sign

00:20:37,919 --> 00:20:42,080
are executed

00:20:39,039 --> 00:20:44,240
and macro invocations are expanded

00:20:42,080 --> 00:20:45,360
each file that's included by an include

00:20:44,240 --> 00:20:47,919
directive is

00:20:45,360 --> 00:20:49,600
processed by phases one through four

00:20:47,919 --> 00:20:52,159
recursively

00:20:49,600 --> 00:20:53,280
and this is done in order and

00:20:52,159 --> 00:20:55,280
recursively

00:20:53,280 --> 00:20:56,320
until all the pre-processing directives

00:20:55,280 --> 00:20:58,400
are removed

00:20:56,320 --> 00:20:59,919
so for example if you pound and include

00:20:58,400 --> 00:21:02,559
a file foo dot h

00:20:59,919 --> 00:21:03,840
during this phase the contents of the

00:21:02,559 --> 00:21:06,559
file foo.h

00:21:03,840 --> 00:21:07,840
are included in your stream of tokens

00:21:06,559 --> 00:21:11,280
and the directive

00:21:07,840 --> 00:21:13,280
include foo.h is removed because the

00:21:11,280 --> 00:21:14,480
actual text of food.h has been

00:21:13,280 --> 00:21:16,480
substituted

00:21:14,480 --> 00:21:20,320
in the stream of tokens where that

00:21:16,480 --> 00:21:20,320
include directive originally occurred

00:21:20,799 --> 00:21:25,600
in phase 5 the characters that are

00:21:23,760 --> 00:21:27,600
character literals and string literals

00:21:25,600 --> 00:21:29,440
are converted from the source character

00:21:27,600 --> 00:21:30,000
set to something called the execution

00:21:29,440 --> 00:21:32,559
character

00:21:30,000 --> 00:21:33,840
set and the execution character set is

00:21:32,559 --> 00:21:35,600
something that could be a multi-byte

00:21:33,840 --> 00:21:38,080
sequence such as utf-8

00:21:35,600 --> 00:21:40,240
it could be a wide character sequence it

00:21:38,080 --> 00:21:41,039
could be some more generalized character

00:21:40,240 --> 00:21:42,960
set

00:21:41,039 --> 00:21:44,320
however the requirement for the

00:21:42,960 --> 00:21:46,640
execution character set

00:21:44,320 --> 00:21:47,760
is that the 96 characters of the basic

00:21:46,640 --> 00:21:50,000
source character set

00:21:47,760 --> 00:21:52,559
that i mentioned in phase one have to be

00:21:50,000 --> 00:21:52,559
supported

00:21:52,880 --> 00:21:56,720
also escape sequences and universal

00:21:55,440 --> 00:21:59,600
character names

00:21:56,720 --> 00:22:00,799
uh in literals and raw and non-raw

00:21:59,600 --> 00:22:02,640
string literals

00:22:00,799 --> 00:22:05,919
are expanded and converted to the

00:22:02,640 --> 00:22:05,919
execution character cell

00:22:07,360 --> 00:22:12,320
phase six is actually pretty

00:22:09,559 --> 00:22:15,200
straightforward uh

00:22:12,320 --> 00:22:15,760
in phase six any string literals that

00:22:15,200 --> 00:22:17,280
are occur

00:22:15,760 --> 00:22:19,200
adjacent to each other in the text of

00:22:17,280 --> 00:22:20,720
the program are concatenated

00:22:19,200 --> 00:22:22,960
so you can have two string literals you

00:22:20,720 --> 00:22:25,200
could have hello and double quotes

00:22:22,960 --> 00:22:27,520
and if immediately after you have a

00:22:25,200 --> 00:22:29,440
world also in double quotes

00:22:27,520 --> 00:22:31,280
those things will be concatenated and

00:22:29,440 --> 00:22:32,880
the last double quotes of hello and the

00:22:31,280 --> 00:22:33,600
first double quotes of world will be

00:22:32,880 --> 00:22:35,120
removed

00:22:33,600 --> 00:22:37,120
and then you'll have a single string

00:22:35,120 --> 00:22:38,240
with one set of quotes that says hello

00:22:37,120 --> 00:22:40,159
world

00:22:38,240 --> 00:22:42,400
now at the end of phase six we actually

00:22:40,159 --> 00:22:43,760
have constructed the translation unit

00:22:42,400 --> 00:22:45,280
all the inclusion directives have been

00:22:43,760 --> 00:22:46,559
performed all the conditional

00:22:45,280 --> 00:22:47,280
compilation directives have been

00:22:46,559 --> 00:22:51,039
performed

00:22:47,280 --> 00:22:51,039
and all macros have been expanded

00:22:51,840 --> 00:22:55,679
now it should be said at least the

00:22:53,520 --> 00:22:57,360
standard says that source code files and

00:22:55,679 --> 00:22:59,200
translation units

00:22:57,360 --> 00:23:00,799
and the output of translating a

00:22:59,200 --> 00:23:02,080
translating unit doesn't need to be

00:23:00,799 --> 00:23:03,919
stored as files

00:23:02,080 --> 00:23:05,919
there is no requirement that there's a

00:23:03,919 --> 00:23:07,360
one-to-one correspondence between any of

00:23:05,919 --> 00:23:08,080
these entities in any external

00:23:07,360 --> 00:23:10,400
representation

00:23:08,080 --> 00:23:12,000
like a file the description that the

00:23:10,400 --> 00:23:14,000
standard provides here they warn you is

00:23:12,000 --> 00:23:15,360
conceptual only and doesn't specify an

00:23:14,000 --> 00:23:16,880
implementation

00:23:15,360 --> 00:23:19,520
in the real world everybody does this

00:23:16,880 --> 00:23:19,520
with files

00:23:19,679 --> 00:23:24,080
now in phase seven each pre-processing

00:23:22,159 --> 00:23:25,600
token is actually converted into a

00:23:24,080 --> 00:23:28,480
parser token

00:23:25,600 --> 00:23:31,039
and the resulting set of tokens then are

00:23:28,480 --> 00:23:33,600
syntactically and semantically analyzed

00:23:31,039 --> 00:23:34,799
and they're translated as a translation

00:23:33,600 --> 00:23:37,440
unit

00:23:34,799 --> 00:23:39,360
so the output of phase six is the

00:23:37,440 --> 00:23:39,919
translation unit that feeds into phase

00:23:39,360 --> 00:23:43,360
seven

00:23:39,919 --> 00:23:46,640
and phase seven translates that input

00:23:43,360 --> 00:23:46,640
as a translation unit

00:23:48,000 --> 00:23:51,600
in phase eight each translation unit is

00:23:50,799 --> 00:23:53,760
examined

00:23:51,600 --> 00:23:55,120
to produce a list of required template

00:23:53,760 --> 00:23:56,799
instantiations

00:23:55,120 --> 00:23:59,600
including the ones that are requested by

00:23:56,799 --> 00:24:01,279
explicit instantiation directives

00:23:59,600 --> 00:24:03,440
uh the definitions of the templates are

00:24:01,279 --> 00:24:04,000
located and the required instantiations

00:24:03,440 --> 00:24:07,360
are performed

00:24:04,000 --> 00:24:08,400
to perform to create a second form of

00:24:07,360 --> 00:24:11,600
output called

00:24:08,400 --> 00:24:15,200
an instantiation unit

00:24:11,600 --> 00:24:16,559
so at the end of phase eight we have

00:24:15,200 --> 00:24:19,279
something called the translated

00:24:16,559 --> 00:24:22,159
translated translated translation unit

00:24:19,279 --> 00:24:22,799
which is typically an object file and

00:24:22,159 --> 00:24:24,960
the

00:24:22,799 --> 00:24:26,559
translated translation unit the object

00:24:24,960 --> 00:24:29,600
file was formed

00:24:26,559 --> 00:24:31,520
by parsing the translation unit by

00:24:29,600 --> 00:24:33,200
creating an instantiation unit one or

00:24:31,520 --> 00:24:35,679
more instantiation units

00:24:33,200 --> 00:24:36,480
and from all of those things together

00:24:35,679 --> 00:24:40,159
building

00:24:36,480 --> 00:24:42,000
object file output

00:24:40,159 --> 00:24:43,200
phase nine is what we normally think of

00:24:42,000 --> 00:24:45,760
it is linking

00:24:43,200 --> 00:24:46,880
and in this phase the external entity

00:24:45,760 --> 00:24:48,880
references are resolved

00:24:46,880 --> 00:24:50,159
translation units instantiation units

00:24:48,880 --> 00:24:52,240
library components

00:24:50,159 --> 00:24:53,360
that are needed to satisfy all external

00:24:52,240 --> 00:24:55,520
references

00:24:53,360 --> 00:24:57,600
everything is collected into a single

00:24:55,520 --> 00:24:59,440
executable program image

00:24:57,600 --> 00:25:01,279
all the disparate pieces of object code

00:24:59,440 --> 00:25:03,760
that have been created along the way

00:25:01,279 --> 00:25:07,039
are now stitched together by the linker

00:25:03,760 --> 00:25:07,039
to create an executable

00:25:09,360 --> 00:25:13,679
so to summarize in phases one through

00:25:12,720 --> 00:25:17,120
six

00:25:13,679 --> 00:25:19,120
we do lexical analysis

00:25:17,120 --> 00:25:20,799
these are the phases we usually think of

00:25:19,120 --> 00:25:23,120
as pre-processing

00:25:20,799 --> 00:25:26,240
and i as i understand it are typically

00:25:23,120 --> 00:25:27,679
executed by the preprocessor itself

00:25:26,240 --> 00:25:29,600
the output of phase six is the

00:25:27,679 --> 00:25:32,640
translation unit

00:25:29,600 --> 00:25:33,679
phases seven and eight perform syntax

00:25:32,640 --> 00:25:35,840
analysis

00:25:33,679 --> 00:25:37,520
semantic analysis and they do code

00:25:35,840 --> 00:25:40,000
generation

00:25:37,520 --> 00:25:41,679
and taken together these are the things

00:25:40,000 --> 00:25:44,240
that we usually think of as being

00:25:41,679 --> 00:25:46,400
compilation

00:25:44,240 --> 00:25:47,520
the output of phase 8 is a translated

00:25:46,400 --> 00:25:51,360
translation unit

00:25:47,520 --> 00:25:52,799
i.e object code phase 9

00:25:51,360 --> 00:25:54,960
is the thing that does our image

00:25:52,799 --> 00:25:55,600
creation and this is what we think of as

00:25:54,960 --> 00:25:57,440
linking

00:25:55,600 --> 00:25:58,799
and again the output of linking is an

00:25:57,440 --> 00:26:00,559
executable image

00:25:58,799 --> 00:26:03,679
that can run on our destination

00:26:00,559 --> 00:26:03,679
execution environment

00:26:04,080 --> 00:26:08,159
so let's look at our very simple program

00:26:06,400 --> 00:26:10,799
the one that i showed a few slides ago

00:26:08,159 --> 00:26:13,279
again this is only a few lines of code

00:26:10,799 --> 00:26:15,200
and it's very simple

00:26:13,279 --> 00:26:17,279
so we have two source code files here

00:26:15,200 --> 00:26:20,080
hello cpp

00:26:17,279 --> 00:26:21,760
and main.cpp which need to be compiled

00:26:20,080 --> 00:26:23,039
and linked together in order to form a

00:26:21,760 --> 00:26:26,240
program

00:26:23,039 --> 00:26:26,240
so let's have a little bit of fun

00:26:26,480 --> 00:26:32,159
how many lines of code are output

00:26:29,679 --> 00:26:35,120
at the end of phase six into the

00:26:32,159 --> 00:26:35,120
translation unit

00:26:37,279 --> 00:26:41,760
well we can figure this out by

00:26:40,400 --> 00:26:43,279
inspecting the contents of the

00:26:41,760 --> 00:26:44,640
translation unit or something at least

00:26:43,279 --> 00:26:47,520
that's very close to it

00:26:44,640 --> 00:26:48,640
with gcc you can use the minus e flag

00:26:47,520 --> 00:26:52,240
and what you can do

00:26:48,640 --> 00:26:54,400
is generate the the uh

00:26:52,240 --> 00:26:55,840
the contents of the translation unit

00:26:54,400 --> 00:26:56,400
that would have been fed into phase

00:26:55,840 --> 00:26:58,000
seven

00:26:56,400 --> 00:27:00,320
so in this case here are the commands

00:26:58,000 --> 00:27:02,799
that i use to create main.i

00:27:00,320 --> 00:27:03,600
and hello.i which are the translation

00:27:02,799 --> 00:27:04,640
units

00:27:03,600 --> 00:27:06,200
or something representing the

00:27:04,640 --> 00:27:09,120
translation units that correspond to

00:27:06,200 --> 00:27:11,279
hello.cpp and main.cpp

00:27:09,120 --> 00:27:14,080
so again how many lines of code do you

00:27:11,279 --> 00:27:14,080
think were created

00:27:14,480 --> 00:27:22,320
well 41 625

00:27:18,960 --> 00:27:25,919
uh for main.i and one fewer

00:27:22,320 --> 00:27:29,039
for hello.i and this is using gcc 10.2

00:27:25,919 --> 00:27:31,919
on ubuntu 1804.

00:27:29,039 --> 00:27:32,559
so given the way this works and the fact

00:27:31,919 --> 00:27:35,760
that

00:27:32,559 --> 00:27:38,000
before heading into syntactic analysis

00:27:35,760 --> 00:27:40,240
we are lexically including everything

00:27:38,000 --> 00:27:42,480
that needs to be processed in order to

00:27:40,240 --> 00:27:44,960
perform syntactic analysis

00:27:42,480 --> 00:27:46,559
you can sort of see why this model of

00:27:44,960 --> 00:27:48,960
compilation has driven the

00:27:46,559 --> 00:27:50,720
the evolution of our tools our tool

00:27:48,960 --> 00:27:52,880
chains and our ecosystem

00:27:50,720 --> 00:27:54,480
and you can begin to sort of feel why

00:27:52,880 --> 00:27:56,720
there is this

00:27:54,480 --> 00:27:58,799
uh why is this there's this bifurcation

00:27:56,720 --> 00:28:00,240
between header files and source files

00:27:58,799 --> 00:28:01,520
now it's not enough information to

00:28:00,240 --> 00:28:02,000
understand the difference and we'll come

00:28:01,520 --> 00:28:05,760
back to that

00:28:02,000 --> 00:28:06,640
later so now i'd like to talk about

00:28:05,760 --> 00:28:09,360
declarations

00:28:06,640 --> 00:28:09,840
definitions and the one definition rule

00:28:09,360 --> 00:28:11,600
and

00:28:09,840 --> 00:28:12,880
these are probably these three things

00:28:11,600 --> 00:28:15,520
are probably the most important things

00:28:12,880 --> 00:28:17,600
to take away from this talk

00:28:15,520 --> 00:28:18,960
declaration and definition have specific

00:28:17,600 --> 00:28:22,480
meanings although

00:28:18,960 --> 00:28:22,480
they typically get conflated

00:28:22,559 --> 00:28:26,399
so in order to understand definitions

00:28:24,799 --> 00:28:28,640
and declarations we have to understand

00:28:26,399 --> 00:28:30,640
what an entity is

00:28:28,640 --> 00:28:32,240
the standard defines an entity as being

00:28:30,640 --> 00:28:33,520
one of these things

00:28:32,240 --> 00:28:35,840
i'm not going to read the list to you

00:28:33,520 --> 00:28:37,600
but you can see there are quite a few

00:28:35,840 --> 00:28:40,000
and the way i think about this list of

00:28:37,600 --> 00:28:43,360
things is these are things

00:28:40,000 --> 00:28:46,880
that we create these are things that

00:28:43,360 --> 00:28:49,679
in some direct way correspond

00:28:46,880 --> 00:28:50,000
to something in the executable image

00:28:49,679 --> 00:28:54,480
that

00:28:50,000 --> 00:28:57,200
is either data or executes

00:28:54,480 --> 00:28:58,080
uh an object for example that is

00:28:57,200 --> 00:29:00,240
directly

00:28:58,080 --> 00:29:01,840
uh something that exists in the

00:29:00,240 --> 00:29:05,919
executable image we give

00:29:01,840 --> 00:29:10,159
we give objects names right

00:29:05,919 --> 00:29:13,840
so any of these things that exist

00:29:10,159 --> 00:29:13,840
is thought of as being an entity

00:29:14,320 --> 00:29:18,720
so let's talk about names the standard

00:29:17,200 --> 00:29:20,720
says that a name

00:29:18,720 --> 00:29:21,840
is the use of an identifier and that

00:29:20,720 --> 00:29:23,200
goes on to

00:29:21,840 --> 00:29:25,520
list several different forms of

00:29:23,200 --> 00:29:28,399
identifier that denotes

00:29:25,520 --> 00:29:29,679
or refers to an entity or a program

00:29:28,399 --> 00:29:32,480
label in the code and we're not going to

00:29:29,679 --> 00:29:36,080
mention labels anymore

00:29:32,480 --> 00:29:38,480
so every name that denotes an entity

00:29:36,080 --> 00:29:41,840
must be introduced into the translation

00:29:38,480 --> 00:29:41,840
unit by a declaration

00:29:43,120 --> 00:29:49,279
conversely a declaration introduces

00:29:46,159 --> 00:29:50,640
those names into the translation unit a

00:29:49,279 --> 00:29:53,120
declaration can also

00:29:50,640 --> 00:29:54,000
reintroduce a name into a translation

00:29:53,120 --> 00:29:56,480
unit

00:29:54,000 --> 00:29:58,000
and you see this sometimes it's easy to

00:29:56,480 --> 00:30:01,120
do if you've declared a function

00:29:58,000 --> 00:30:03,520
int of f and f takes no parameters

00:30:01,120 --> 00:30:04,720
you can redeclare that function time

00:30:03,520 --> 00:30:06,320
over and over

00:30:04,720 --> 00:30:08,720
and the compiler doesn't complain

00:30:06,320 --> 00:30:12,640
because you are reintroducing that name

00:30:08,720 --> 00:30:15,360
f into the translation unit

00:30:12,640 --> 00:30:16,159
now a definition is a subset of

00:30:15,360 --> 00:30:18,240
declaration

00:30:16,159 --> 00:30:22,240
it's a declaration that fully defines

00:30:18,240 --> 00:30:24,480
the entity that's being introduced

00:30:22,240 --> 00:30:26,399
a variable is an entity that's

00:30:24,480 --> 00:30:28,799
introduced by the declaration of an

00:30:26,399 --> 00:30:30,559
object and there's this other thing or

00:30:28,799 --> 00:30:31,679
of a reference other than a non-static

00:30:30,559 --> 00:30:35,279
data member

00:30:31,679 --> 00:30:38,480
but if you declare an object you are

00:30:35,279 --> 00:30:42,399
you are defining it

00:30:38,480 --> 00:30:45,200
you are instantiating an entity

00:30:42,399 --> 00:30:46,080
so going back to the idea of declaration

00:30:45,200 --> 00:30:48,720
informally

00:30:46,080 --> 00:30:50,960
what you're saying to the compiler is in

00:30:48,720 --> 00:30:54,080
this translation unit

00:30:50,960 --> 00:30:56,080
informally here's a new name

00:30:54,080 --> 00:30:57,600
or here's a name that you've already

00:30:56,080 --> 00:31:00,320
seen i'm just bringing it to your

00:30:57,600 --> 00:31:00,320
attention again

00:31:00,399 --> 00:31:05,039
a definition you can think of informally

00:31:02,720 --> 00:31:07,360
as being a declaration that says

00:31:05,039 --> 00:31:08,960
here's a name and here's everything you

00:31:07,360 --> 00:31:10,880
need to know about that name

00:31:08,960 --> 00:31:14,080
in order to use it to be able to

00:31:10,880 --> 00:31:14,080
generate code for it

00:31:16,000 --> 00:31:21,360
so then the standard goes on to say that

00:31:19,039 --> 00:31:24,480
every declaration is also a definition

00:31:21,360 --> 00:31:26,559
unless it declares several things i'm

00:31:24,480 --> 00:31:30,399
not going to list all of them

00:31:26,559 --> 00:31:32,080
but i think the takeaway here is that

00:31:30,399 --> 00:31:33,440
if you use c plus plus for any length of

00:31:32,080 --> 00:31:35,279
time you'll begin to develop an

00:31:33,440 --> 00:31:37,120
intuition for what a declaration what a

00:31:35,279 --> 00:31:40,159
definition is

00:31:37,120 --> 00:31:42,080
and you'll understand uh when

00:31:40,159 --> 00:31:43,600
to provide definitions and when not to

00:31:42,080 --> 00:31:46,399
provide definitions when to use

00:31:43,600 --> 00:31:48,480
declarations and when to use definitions

00:31:46,399 --> 00:31:49,679
but at the end of the day the way i like

00:31:48,480 --> 00:31:52,880
to think of it is

00:31:49,679 --> 00:31:56,000
the set of definitions is a subset

00:31:52,880 --> 00:31:58,080
of the set of declarations so every

00:31:56,000 --> 00:31:59,919
definition is a declaration

00:31:58,080 --> 00:32:02,320
but not every declaration is a

00:31:59,919 --> 00:32:04,320
definition

00:32:02,320 --> 00:32:05,360
so let's do some venn diagrams like like

00:32:04,320 --> 00:32:07,760
i used to do

00:32:05,360 --> 00:32:10,480
when we were in elementary school so we

00:32:07,760 --> 00:32:13,919
have a big set of declarations

00:32:10,480 --> 00:32:14,880
and we have a subset of definitions so

00:32:13,919 --> 00:32:17,279
on the left

00:32:14,880 --> 00:32:18,159
i have declared an extern int called a

00:32:17,279 --> 00:32:22,320
an extern

00:32:18,159 --> 00:32:26,159
int an extern constant called c

00:32:22,320 --> 00:32:30,240
on the right somewhere in my program

00:32:26,159 --> 00:32:33,760
i have to define the extern

00:32:30,240 --> 00:32:36,799
a and the external count c and i define

00:32:33,760 --> 00:32:40,840
by initializing them in

00:32:36,799 --> 00:32:42,640
some translation unit in the program

00:32:40,840 --> 00:32:44,960
somewhere

00:32:42,640 --> 00:32:45,679
on the left here i have a declaration of

00:32:44,960 --> 00:32:47,360
a function

00:32:45,679 --> 00:32:49,440
a function declaration that has no

00:32:47,360 --> 00:32:50,240
definition and this is very common we

00:32:49,440 --> 00:32:52,480
see it all the time

00:32:50,240 --> 00:32:54,799
in headers right uh if you ever worked

00:32:52,480 --> 00:32:57,519
in c c headers typically consist

00:32:54,799 --> 00:32:58,640
basically of function declarations right

00:32:57,519 --> 00:33:00,240
and that the code

00:32:58,640 --> 00:33:01,760
is defined in source code files

00:33:00,240 --> 00:33:04,240
elsewhere

00:33:01,760 --> 00:33:05,519
on the right we see a definition of that

00:33:04,240 --> 00:33:08,159
same function

00:33:05,519 --> 00:33:11,120
now this definition of f is also a

00:33:08,159 --> 00:33:11,120
declaration of act

00:33:12,000 --> 00:33:16,000
on the left i have a declaration of the

00:33:13,760 --> 00:33:17,679
class foo perhaps i'm using it as a

00:33:16,000 --> 00:33:19,760
forward declaration

00:33:17,679 --> 00:33:22,559
and on the right i have a definition of

00:33:19,760 --> 00:33:22,559
the class foo

00:33:22,840 --> 00:33:27,279
so the definition

00:33:25,039 --> 00:33:28,960
of classvoo provides the compiler with

00:33:27,279 --> 00:33:31,200
all the information it needs to

00:33:28,960 --> 00:33:33,279
understand how the class is laid out

00:33:31,200 --> 00:33:34,799
how it's represented in memory and how

00:33:33,279 --> 00:33:37,679
it can be used

00:33:34,799 --> 00:33:38,080
by its clients the declaration of a

00:33:37,679 --> 00:33:40,240
class

00:33:38,080 --> 00:33:41,440
doesn't provide any of that information

00:33:40,240 --> 00:33:43,039
the one thing you can do with the

00:33:41,440 --> 00:33:44,159
forward declaration of the data type

00:33:43,039 --> 00:33:46,880
that's very useful

00:33:44,159 --> 00:33:48,880
is to use it to form a pointer type if i

00:33:46,880 --> 00:33:50,399
wanted to form a pointer to foo

00:33:48,880 --> 00:33:52,320
i don't need to know what's in foo to

00:33:50,399 --> 00:33:53,200
form a pointer to it i just need to know

00:33:52,320 --> 00:33:55,679
the name

00:33:53,200 --> 00:33:58,240
because pointer defu is a different type

00:33:55,679 --> 00:33:58,240
than foo

00:34:00,720 --> 00:34:04,480
i can also have a using declaration

00:34:02,559 --> 00:34:06,960
which pulls in a name from some

00:34:04,480 --> 00:34:08,960
namespace in this case capital n

00:34:06,960 --> 00:34:10,159
so i can declare it because i'm going to

00:34:08,960 --> 00:34:12,560
use it somewhere

00:34:10,159 --> 00:34:13,280
and on the right i can define it

00:34:12,560 --> 00:34:14,960
somewhere

00:34:13,280 --> 00:34:18,800
and i have to define it so that it can

00:34:14,960 --> 00:34:18,800
eventually be used elsewhere

00:34:19,440 --> 00:34:26,399
here on the left i've created

00:34:22,879 --> 00:34:28,240
i've declared an enum a strong enum

00:34:26,399 --> 00:34:30,720
whose type is color and his

00:34:28,240 --> 00:34:33,520
representation is an it

00:34:30,720 --> 00:34:35,440
i can do this and i can actually use

00:34:33,520 --> 00:34:36,720
these in limited circumstances without

00:34:35,440 --> 00:34:39,440
defining them

00:34:36,720 --> 00:34:41,359
on the right i'm also providing a

00:34:39,440 --> 00:34:43,359
declaration of color but i'm

00:34:41,359 --> 00:34:46,000
in that declaration is also a definition

00:34:43,359 --> 00:34:48,639
and here i'm defining the enumerators

00:34:46,000 --> 00:34:51,760
that are part of that enumeration red

00:34:48,639 --> 00:34:51,760
green and blue in this case

00:34:52,480 --> 00:34:59,119
moving on i can define

00:34:56,000 --> 00:35:03,040
a struct bar

00:34:59,119 --> 00:35:05,839
and bar has a member function compute x

00:35:03,040 --> 00:35:07,200
now what we see on the left is a

00:35:05,839 --> 00:35:09,920
declaration

00:35:07,200 --> 00:35:11,280
i've defined the struct bar and i've

00:35:09,920 --> 00:35:13,920
provided enough

00:35:11,280 --> 00:35:15,520
information here so that it can be used

00:35:13,920 --> 00:35:18,640
but i've only declared

00:35:15,520 --> 00:35:20,079
the member function compute x so

00:35:18,640 --> 00:35:22,240
somewhere in the program i have to

00:35:20,079 --> 00:35:23,920
provide a definition of compute x

00:35:22,240 --> 00:35:25,440
so perhaps in a source code file

00:35:23,920 --> 00:35:27,040
somewhere i would

00:35:25,440 --> 00:35:29,680
i would write the definition that you

00:35:27,040 --> 00:35:32,000
see on the right

00:35:29,680 --> 00:35:34,079
now some declarations do not have

00:35:32,000 --> 00:35:36,480
corresponding definitions

00:35:34,079 --> 00:35:37,680
uh in particular type aliases are a very

00:35:36,480 --> 00:35:39,920
good example of that

00:35:37,680 --> 00:35:41,440
if i create a type alias by using

00:35:39,920 --> 00:35:43,520
through a using directive

00:35:41,440 --> 00:35:44,560
or i create a type alias by using

00:35:43,520 --> 00:35:47,359
typedef

00:35:44,560 --> 00:35:48,720
in either case there is no corresponding

00:35:47,359 --> 00:35:49,680
definition that goes with that

00:35:48,720 --> 00:35:52,880
declaration

00:35:49,680 --> 00:35:55,440
the declaration is sufficient to to use

00:35:52,880 --> 00:35:55,440
by itself

00:35:56,720 --> 00:36:00,240
let's talk about another concept called

00:35:58,480 --> 00:36:03,119
linkage now c

00:36:00,240 --> 00:36:05,119
plus allows some declarations of an

00:36:03,119 --> 00:36:06,160
entity to occur in more than one place

00:36:05,119 --> 00:36:09,200
in the same

00:36:06,160 --> 00:36:11,359
program or translation unit or scope

00:36:09,200 --> 00:36:13,359
now if a name refers to any of these

00:36:11,359 --> 00:36:16,240
things that i've listed here

00:36:13,359 --> 00:36:16,640
that name might have some property

00:36:16,240 --> 00:36:20,800
called

00:36:16,640 --> 00:36:23,200
linkage if a name has linkage

00:36:20,800 --> 00:36:25,040
what that means is that name refers to

00:36:23,200 --> 00:36:27,839
the same entity

00:36:25,040 --> 00:36:30,560
as when that name was introduced by a

00:36:27,839 --> 00:36:34,320
declaration in a different scope

00:36:30,560 --> 00:36:37,440
so if i introduce

00:36:34,320 --> 00:36:39,119
a name x in two different scopes and

00:36:37,440 --> 00:36:40,079
that name x and those two different

00:36:39,119 --> 00:36:43,359
scopes

00:36:40,079 --> 00:36:46,640
refer to the same entity then

00:36:43,359 --> 00:36:48,320
those names have linkage

00:36:46,640 --> 00:36:50,079
a name can have three different kinds of

00:36:48,320 --> 00:36:53,680
linkage external linkage

00:36:50,079 --> 00:36:56,160
internal language linkage and no linkage

00:36:53,680 --> 00:36:56,780
external linkage occurs when an entity

00:36:56,160 --> 00:36:58,320
with a name

00:36:56,780 --> 00:36:59,920
[Music]

00:36:58,320 --> 00:37:01,359
that has external language can be

00:36:59,920 --> 00:37:03,599
referred to by names

00:37:01,359 --> 00:37:05,839
from other scopes in other translation

00:37:03,599 --> 00:37:08,000
units or from other scopes in the same

00:37:05,839 --> 00:37:10,960
translation unit

00:37:08,000 --> 00:37:13,359
internal linkage occurs when an entity

00:37:10,960 --> 00:37:16,560
can be referred to by names from scopes

00:37:13,359 --> 00:37:18,320
only in the same translation unit

00:37:16,560 --> 00:37:20,079
and no linkage is the case where an

00:37:18,320 --> 00:37:22,000
entity that has a name

00:37:20,079 --> 00:37:23,599
can't be referred by can only be

00:37:22,000 --> 00:37:26,320
referred to by names

00:37:23,599 --> 00:37:28,079
in the scope where that entity exists so

00:37:26,320 --> 00:37:30,960
think of it as being

00:37:28,079 --> 00:37:31,599
external linkage means the name can be

00:37:30,960 --> 00:37:33,520
uh

00:37:31,599 --> 00:37:35,440
could be linked a name can have linkage

00:37:33,520 --> 00:37:37,440
at any scope in the program

00:37:35,440 --> 00:37:38,960
internal linkage means that a name can

00:37:37,440 --> 00:37:40,240
have linkage anywhere inside a

00:37:38,960 --> 00:37:42,800
translation unit

00:37:40,240 --> 00:37:44,480
and no linkage means that a name can

00:37:42,800 --> 00:37:48,240
only be referred to

00:37:44,480 --> 00:37:49,760
inside the block where it's declared

00:37:48,240 --> 00:37:51,680
let's look at an example of external

00:37:49,760 --> 00:37:54,480
linkage

00:37:51,680 --> 00:37:58,320
on the left i've got my header.h and on

00:37:54,480 --> 00:37:58,320
the right i've got my source.h

00:37:59,280 --> 00:38:03,200
i'm sorry on the left i've got

00:38:00,560 --> 00:38:04,960
myheader.h of mysource.cpp

00:38:03,200 --> 00:38:06,720
and on the right i've got another source

00:38:04,960 --> 00:38:08,960
file so

00:38:06,720 --> 00:38:09,920
the names that i've highlighted here in

00:38:08,960 --> 00:38:13,680
yellow

00:38:09,920 --> 00:38:16,160
represent they name entities

00:38:13,680 --> 00:38:17,359
so f names a function that's defined

00:38:16,160 --> 00:38:20,400
here

00:38:17,359 --> 00:38:22,000
x names an integer that is declared in

00:38:20,400 --> 00:38:25,520
this spot

00:38:22,000 --> 00:38:27,440
the type alias capital i int

00:38:25,520 --> 00:38:30,160
is an entity that refers to the

00:38:27,440 --> 00:38:33,520
primitive type int

00:38:30,160 --> 00:38:38,000
below it in source dot cpp i define

00:38:33,520 --> 00:38:38,720
f in this code on the right my other

00:38:38,000 --> 00:38:41,760
source

00:38:38,720 --> 00:38:44,480
cpp i've included my header

00:38:41,760 --> 00:38:45,280
which means i have introduced the names

00:38:44,480 --> 00:38:50,400
f

00:38:45,280 --> 00:38:54,079
and x into the scope of my other source

00:38:50,400 --> 00:38:57,520
so those declarations occur here

00:38:54,079 --> 00:39:00,640
and now having declared

00:38:57,520 --> 00:39:03,200
x wants i declare it again and i also

00:39:00,640 --> 00:39:03,200
define it

00:39:04,560 --> 00:39:11,680
next i define a function called g

00:39:07,920 --> 00:39:15,440
which returns f modulo 3.

00:39:11,680 --> 00:39:18,640
so the point here is that the names

00:39:15,440 --> 00:39:22,079
f x and

00:39:18,640 --> 00:39:25,359
int all have external linkage

00:39:22,079 --> 00:39:27,040
because these names can be used across

00:39:25,359 --> 00:39:30,480
translation units they're being used in

00:39:27,040 --> 00:39:30,480
two different translation units

00:39:30,640 --> 00:39:33,920
if we extend the example a little bit

00:39:32,320 --> 00:39:35,880
more let's add

00:39:33,920 --> 00:39:37,599
an unnamed namespace in

00:39:35,880 --> 00:39:41,440
myothersource.cpp

00:39:37,599 --> 00:39:43,440
and let's let's define a variable y

00:39:41,440 --> 00:39:44,880
let's uh define some struct with a

00:39:43,440 --> 00:39:46,800
member function called

00:39:44,880 --> 00:39:48,400
fuzzy and let's define a type called

00:39:46,800 --> 00:39:50,720
foobar

00:39:48,400 --> 00:39:52,400
i'm going to use those names i'm going

00:39:50,720 --> 00:39:52,720
to expand the definition of my function

00:39:52,400 --> 00:39:55,280
g

00:39:52,720 --> 00:39:57,359
and i'm going to use those names in that

00:39:55,280 --> 00:40:00,800
definition

00:39:57,359 --> 00:40:03,200
in this case y and foo

00:40:00,800 --> 00:40:04,720
and fubar have internal linkage they

00:40:03,200 --> 00:40:06,000
have internal linkage because they're

00:40:04,720 --> 00:40:09,079
only visible

00:40:06,000 --> 00:40:11,280
inside this translation unit my

00:40:09,079 --> 00:40:13,680
mysource.cpp on the left

00:40:11,280 --> 00:40:15,280
has never seen these names and so far

00:40:13,680 --> 00:40:18,400
these names have no linkage

00:40:15,280 --> 00:40:20,480
in this translation unit however the

00:40:18,400 --> 00:40:22,880
names waifu and fubar

00:40:20,480 --> 00:40:25,760
do have linkage inside this translation

00:40:22,880 --> 00:40:28,599
unit the translation unit that's created

00:40:25,760 --> 00:40:31,599
when pre-processing is done on my other

00:40:28,599 --> 00:40:31,599
source.cpp

00:40:32,160 --> 00:40:36,079
finally we have the case of no linkage

00:40:34,800 --> 00:40:39,440
inside my function g

00:40:36,079 --> 00:40:41,520
i'm going to create a typedef foobar

00:40:39,440 --> 00:40:42,560
i'm going to instantiate a variable of

00:40:41,520 --> 00:40:44,319
type foo

00:40:42,560 --> 00:40:46,720
called myfu and i'm going to create an

00:40:44,319 --> 00:40:50,240
integer called z

00:40:46,720 --> 00:40:51,119
these things the typedef the type alias

00:40:50,240 --> 00:40:54,800
foobar

00:40:51,119 --> 00:40:57,680
the variable myfu and the variable z

00:40:54,800 --> 00:40:59,200
have no linkage they are only visible

00:40:57,680 --> 00:41:00,319
inside the function where they are

00:40:59,200 --> 00:41:02,000
defined

00:41:00,319 --> 00:41:04,400
and these rules they conform to our

00:41:02,000 --> 00:41:06,400
common sense they make sense

00:41:04,400 --> 00:41:08,800
but they are formally defined in this

00:41:06,400 --> 00:41:10,240
way through the concept of linkage

00:41:08,800 --> 00:41:12,160
the standard actually has quite a bit to

00:41:10,240 --> 00:41:13,200
say about language and i can't go

00:41:12,160 --> 00:41:14,960
through it all but

00:41:13,200 --> 00:41:18,160
i hope this suffices to give you some

00:41:14,960 --> 00:41:22,000
flavor of what it means

00:41:18,160 --> 00:41:22,000
let's move on to the one definition rule

00:41:22,079 --> 00:41:25,119
there are actually several pages in the

00:41:23,520 --> 00:41:26,640
standard to define this i'm going to try

00:41:25,119 --> 00:41:28,240
and keep it short and succinct and

00:41:26,640 --> 00:41:29,760
hopefully provide some guidelines that

00:41:28,240 --> 00:41:32,640
make it meaningful

00:41:29,760 --> 00:41:34,400
so in a given translation unit there can

00:41:32,640 --> 00:41:38,160
be at most one definition

00:41:34,400 --> 00:41:38,160
of any of these things that you see

00:41:38,640 --> 00:41:42,400
there can be multiple declarations in

00:41:40,960 --> 00:41:45,760
that translation unit

00:41:42,400 --> 00:41:48,640
but there can be only one definition

00:41:45,760 --> 00:41:49,760
there cannot for example for a function

00:41:48,640 --> 00:41:51,920
there could be as we saw

00:41:49,760 --> 00:41:55,119
multiple declarations of a function but

00:41:51,920 --> 00:41:55,119
only one definition

00:42:00,000 --> 00:42:04,160
a given program has to contain exactly

00:42:03,200 --> 00:42:06,880
one definition

00:42:04,160 --> 00:42:08,480
of across the program has to contain

00:42:06,880 --> 00:42:11,119
exactly one definition

00:42:08,480 --> 00:42:12,720
of every non-inline variable or function

00:42:11,119 --> 00:42:15,599
that's used in the program

00:42:12,720 --> 00:42:16,000
this conforms to our common sense again

00:42:15,599 --> 00:42:18,000
multiple

00:42:16,000 --> 00:42:20,240
declarations are okay but there can only

00:42:18,000 --> 00:42:22,640
be one definition

00:42:20,240 --> 00:42:24,400
on the other hand for an inline variable

00:42:22,640 --> 00:42:26,560
or an inline function

00:42:24,400 --> 00:42:27,680
a definition is required in every

00:42:26,560 --> 00:42:30,400
translation unit

00:42:27,680 --> 00:42:32,480
that uses that variable or calls that

00:42:30,400 --> 00:42:35,760
function

00:42:32,480 --> 00:42:37,040
now back in the day inline

00:42:35,760 --> 00:42:39,040
when it was first introduced in the

00:42:37,040 --> 00:42:41,040
language was intended to be a suggested

00:42:39,040 --> 00:42:42,160
optimization the programmer made to the

00:42:41,040 --> 00:42:45,280
compiler

00:42:42,160 --> 00:42:46,800
the programmer was saying hey i want you

00:42:45,280 --> 00:42:48,560
to take this bit of code and i don't

00:42:46,800 --> 00:42:49,920
want you to actually create a function

00:42:48,560 --> 00:42:51,760
that gets called with the

00:42:49,920 --> 00:42:53,680
expensive process of pushing arguments

00:42:51,760 --> 00:42:55,520
on the stack and returning a value

00:42:53,680 --> 00:42:56,960
i just want you to expand the code in

00:42:55,520 --> 00:42:58,800
line

00:42:56,960 --> 00:43:00,720
well compilers have gotten very smart

00:42:58,800 --> 00:43:02,800
about doing this these days

00:43:00,720 --> 00:43:04,079
and compilers will inline code in that

00:43:02,800 --> 00:43:05,920
fashion that

00:43:04,079 --> 00:43:08,160
you haven't requested to be inline the

00:43:05,920 --> 00:43:10,319
compiler will do anything it wants

00:43:08,160 --> 00:43:11,599
to make sure that your code runs as fast

00:43:10,319 --> 00:43:13,520
as possible

00:43:11,599 --> 00:43:14,640
so inline no longer has its original

00:43:13,520 --> 00:43:16,640
meaning

00:43:14,640 --> 00:43:17,760
what it really means these days what it

00:43:16,640 --> 00:43:21,040
has evolved to mean

00:43:17,760 --> 00:43:23,359
is please allow or it means

00:43:21,040 --> 00:43:24,160
multiple definitions of this variable of

00:43:23,359 --> 00:43:27,520
this function

00:43:24,160 --> 00:43:29,200
are permitted so i can have an inline

00:43:27,520 --> 00:43:32,000
function i can put it in a header

00:43:29,200 --> 00:43:33,760
it can be included in multiple

00:43:32,000 --> 00:43:35,680
translation units

00:43:33,760 --> 00:43:38,400
it can be used in multiple translation

00:43:35,680 --> 00:43:38,960
units and this inline variable or inline

00:43:38,400 --> 00:43:41,440
function

00:43:38,960 --> 00:43:45,280
is an exception to the rule in that

00:43:41,440 --> 00:43:45,280
multiple definitions are permitted

00:43:46,000 --> 00:43:49,680
along the way exactly one definition of

00:43:48,720 --> 00:43:51,680
a class much

00:43:49,680 --> 00:43:52,720
must occur in any translation unit that

00:43:51,680 --> 00:43:54,560
uses it

00:43:52,720 --> 00:43:55,920
in such a way that the class needs to be

00:43:54,560 --> 00:43:59,359
complete

00:43:55,920 --> 00:44:02,400
so that means by being complete

00:43:59,359 --> 00:44:04,560
that means that the compiler sees

00:44:02,400 --> 00:44:06,480
how to build the class it sees the full

00:44:04,560 --> 00:44:08,319
definition of the class so that it knows

00:44:06,480 --> 00:44:10,480
what member data is in it

00:44:08,319 --> 00:44:12,160
what member functions it contains and

00:44:10,480 --> 00:44:14,319
can decide how to lay it out

00:44:12,160 --> 00:44:15,359
how to represent it how to generate the

00:44:14,319 --> 00:44:18,480
object code

00:44:15,359 --> 00:44:22,319
that go with supporting that class

00:44:18,480 --> 00:44:23,280
and running its member functions and so

00:44:22,319 --> 00:44:25,119
examples here well

00:44:23,280 --> 00:44:26,319
like like a constructor or calling a

00:44:25,119 --> 00:44:28,400
member function

00:44:26,319 --> 00:44:29,920
if you need to use some facility of a

00:44:28,400 --> 00:44:31,680
class by

00:44:29,920 --> 00:44:33,680
if it's a struct and you need to access

00:44:31,680 --> 00:44:36,240
its public data members or it's a class

00:44:33,680 --> 00:44:38,079
and you need to

00:44:36,240 --> 00:44:39,280
invoke a member function or you need to

00:44:38,079 --> 00:44:40,960
construct that class

00:44:39,280 --> 00:44:43,040
the compiler must see the full

00:44:40,960 --> 00:44:46,079
definition of the class

00:44:43,040 --> 00:44:49,280
in order to to to uh

00:44:46,079 --> 00:44:50,960
to do its job so let's look at a

00:44:49,280 --> 00:44:53,040
quick few quick examples of the one

00:44:50,960 --> 00:44:55,280
definition rule

00:44:53,040 --> 00:44:56,720
so on the left we have a translation

00:44:55,280 --> 00:44:58,480
unit one and on the right we have

00:44:56,720 --> 00:45:02,079
translation unit two

00:44:58,480 --> 00:45:04,560
on the left i'm declaring a const int

00:45:02,079 --> 00:45:05,280
externally and on the right i'm defining

00:45:04,560 --> 00:45:08,480
it

00:45:05,280 --> 00:45:12,640
that's fine perfectly allowable

00:45:08,480 --> 00:45:15,359
however if i define the same integer

00:45:12,640 --> 00:45:16,240
in two different translation units this

00:45:15,359 --> 00:45:17,760
is not allowable

00:45:16,240 --> 00:45:21,359
this is a violation of the one

00:45:17,760 --> 00:45:23,280
definition rule so this is invalid code

00:45:21,359 --> 00:45:24,480
again assuming both translation units

00:45:23,280 --> 00:45:28,000
are being

00:45:24,480 --> 00:45:28,000
linked into the same executable

00:45:28,720 --> 00:45:32,720
in translation unit 1 i've got the

00:45:31,839 --> 00:45:34,640
declaration

00:45:32,720 --> 00:45:36,640
of function f and maybe i use it

00:45:34,640 --> 00:45:39,280
somewhere in

00:45:36,640 --> 00:45:40,480
translation unit 1. in translation unit

00:45:39,280 --> 00:45:43,359
00:45:40,480 --> 00:45:45,280
i define f and i can use f in

00:45:43,359 --> 00:45:48,000
translation unit 2 as well

00:45:45,280 --> 00:45:49,440
but the important point here is there is

00:45:48,000 --> 00:45:53,119
only one definition

00:45:49,440 --> 00:45:56,000
of the function f in the executable

00:45:53,119 --> 00:45:57,280
if i do this for example forget to put

00:45:56,000 --> 00:45:59,520
inline on a function

00:45:57,280 --> 00:46:01,520
like this that might go in a header file

00:45:59,520 --> 00:46:03,119
i have multiple defined symbols

00:46:01,520 --> 00:46:06,000
and this is a violation of the one

00:46:03,119 --> 00:46:07,680
definition rule and this is the

00:46:06,000 --> 00:46:11,040
this is the kind of thing that's an

00:46:07,680 --> 00:46:11,040
ill-formed program with no

00:46:11,440 --> 00:46:15,760
no diagnostic required the compiler

00:46:14,400 --> 00:46:18,319
cannot sense

00:46:15,760 --> 00:46:19,839
that this occurs in that this function

00:46:18,319 --> 00:46:20,960
is defined in two different translation

00:46:19,839 --> 00:46:24,079
units

00:46:20,960 --> 00:46:24,960
only the linker can find uh can sense

00:46:24,079 --> 00:46:29,839
this and then

00:46:24,960 --> 00:46:29,839
issue a link error

00:46:30,319 --> 00:46:34,880
i can define the class and provide full

00:46:33,040 --> 00:46:37,200
definitions of a class in two different

00:46:34,880 --> 00:46:39,119
translation units like this

00:46:37,200 --> 00:46:41,280
and the member function or the

00:46:39,119 --> 00:46:44,000
constructor foo i've defined

00:46:41,280 --> 00:46:45,440
in the in the class declaration itself

00:46:44,000 --> 00:46:48,800
or in the class definition

00:46:45,440 --> 00:46:50,480
and so it's implicitly inline so this is

00:46:48,800 --> 00:46:52,560
perfectly valid code

00:46:50,480 --> 00:46:54,240
this full class definition can be used

00:46:52,560 --> 00:46:55,040
in translation units like this and

00:46:54,240 --> 00:46:58,079
there's no

00:46:55,040 --> 00:46:58,079
violation of odr

00:46:58,319 --> 00:47:03,280
i can also do this i can have a member

00:47:01,760 --> 00:47:04,000
function declaration for foos

00:47:03,280 --> 00:47:07,040
constructor

00:47:04,000 --> 00:47:07,920
in translation unit 1 and in translation

00:47:07,040 --> 00:47:10,400
unit 2

00:47:07,920 --> 00:47:12,640
i can have the full struct definition

00:47:10,400 --> 00:47:14,800
and i will define the member function

00:47:12,640 --> 00:47:16,720
this is also perfectly valid code

00:47:14,800 --> 00:47:19,040
because there's only

00:47:16,720 --> 00:47:21,040
i have not requested the ability to have

00:47:19,040 --> 00:47:24,319
multiple definitions of foo

00:47:21,040 --> 00:47:25,440
it's not in line and i've provided only

00:47:24,319 --> 00:47:28,640
one definition

00:47:25,440 --> 00:47:30,160
of this constructor however if i do

00:47:28,640 --> 00:47:32,559
something like this

00:47:30,160 --> 00:47:33,200
where i define the same constructor out

00:47:32,559 --> 00:47:35,040
of line

00:47:33,200 --> 00:47:36,800
in two different translation units

00:47:35,040 --> 00:47:38,400
that's a violation of odr

00:47:36,800 --> 00:47:41,359
and again you'll get multiple defined

00:47:38,400 --> 00:47:41,359
symbol link errors

00:47:42,319 --> 00:47:46,800
so odr is complicated there are lots of

00:47:45,280 --> 00:47:47,760
there are exceptions and low level

00:47:46,800 --> 00:47:49,440
details

00:47:47,760 --> 00:47:51,040
i have a couple of simple guidelines

00:47:49,440 --> 00:47:52,160
that i try to keep in mind when i'm

00:47:51,040 --> 00:47:55,520
working and

00:47:52,160 --> 00:47:58,800
they work for me 99 of the time and so

00:47:55,520 --> 00:48:02,319
i'm gonna share them with you

00:47:58,800 --> 00:48:03,920
first of all for an inline thing

00:48:02,319 --> 00:48:05,359
something that's in line whether it's a

00:48:03,920 --> 00:48:07,599
variable or a function

00:48:05,359 --> 00:48:09,200
and that thing that's declared inline

00:48:07,599 --> 00:48:12,160
gets used

00:48:09,200 --> 00:48:12,559
make sure that that thing is defined at

00:48:12,160 --> 00:48:16,720
least

00:48:12,559 --> 00:48:18,960
once in some translation unit somewhere

00:48:16,720 --> 00:48:20,880
if it's used in a translation unit it

00:48:18,960 --> 00:48:23,680
must be defined in that translation unit

00:48:20,880 --> 00:48:26,079
so make sure that happens

00:48:23,680 --> 00:48:27,280
for everything else that gets used make

00:48:26,079 --> 00:48:32,000
sure it gets defined

00:48:27,280 --> 00:48:32,000
exactly once in one translation unit

00:48:33,680 --> 00:48:37,760
i'll talk briefly about storage duration

00:48:35,920 --> 00:48:40,559
in objects

00:48:37,760 --> 00:48:42,319
every object has a storage duration

00:48:40,559 --> 00:48:43,440
there are four kinds there's automatic

00:48:42,319 --> 00:48:45,520
storage duration

00:48:43,440 --> 00:48:47,359
where object storage is allocated at the

00:48:45,520 --> 00:48:50,240
beginning of an enclosing block

00:48:47,359 --> 00:48:51,839
and deallocated at the end of the block

00:48:50,240 --> 00:48:53,760
this is something that applies to all

00:48:51,839 --> 00:48:55,359
local objects

00:48:53,760 --> 00:48:56,960
objects that are declared inside a

00:48:55,359 --> 00:48:58,480
function or a member function

00:48:56,960 --> 00:49:01,440
except those that are declared thread

00:48:58,480 --> 00:49:03,839
local or static or external

00:49:01,440 --> 00:49:05,200
those have different storage duration

00:49:03,839 --> 00:49:07,680
but if you think about

00:49:05,200 --> 00:49:08,800
writing a function f and inside f you

00:49:07,680 --> 00:49:10,400
you declare

00:49:08,800 --> 00:49:12,160
string s and you do something with

00:49:10,400 --> 00:49:15,119
string string s has

00:49:12,160 --> 00:49:16,960
automatic storage duration there's

00:49:15,119 --> 00:49:18,000
dynamic storage duration and this is

00:49:16,960 --> 00:49:19,839
duration

00:49:18,000 --> 00:49:22,559
of storage that we as programmers

00:49:19,839 --> 00:49:24,640
control explicitly

00:49:22,559 --> 00:49:25,920
the storage for objects is allocated and

00:49:24,640 --> 00:49:27,920
deallocated

00:49:25,920 --> 00:49:29,200
by our code in the program using

00:49:27,920 --> 00:49:32,319
functions to perform

00:49:29,200 --> 00:49:33,359
dynamic memory allocation objects with

00:49:32,319 --> 00:49:35,440
this duration

00:49:33,359 --> 00:49:37,440
with dynamic storage duration are

00:49:35,440 --> 00:49:38,400
created using new expressions and delete

00:49:37,440 --> 00:49:40,240
expressions

00:49:38,400 --> 00:49:41,440
in other words the new operator or

00:49:40,240 --> 00:49:45,839
operator new

00:49:41,440 --> 00:49:45,839
the delete operator or operator delete

00:49:47,040 --> 00:49:50,640
there's static storage duration this is

00:49:50,160 --> 00:49:52,000
object

00:49:50,640 --> 00:49:53,920
this is storage duration that's

00:49:52,000 --> 00:49:55,599
allocated at the beginning of a program

00:49:53,920 --> 00:49:56,400
and deallocated at the end of the

00:49:55,599 --> 00:49:59,599
program

00:49:56,400 --> 00:50:02,400
in other words static storage

00:49:59,599 --> 00:50:02,880
is allocated for the program before the

00:50:02,400 --> 00:50:06,160
program

00:50:02,880 --> 00:50:06,400
execution enters main and it is cleaned

00:50:06,160 --> 00:50:10,000
up

00:50:06,400 --> 00:50:12,240
and deleted after main exits

00:50:10,000 --> 00:50:13,760
now static storage duration applies to

00:50:12,240 --> 00:50:14,880
all objects that are declared at

00:50:13,760 --> 00:50:17,599
namespace scope

00:50:14,880 --> 00:50:19,680
including the global namespace it also

00:50:17,599 --> 00:50:20,480
applies to any objects that you declare

00:50:19,680 --> 00:50:23,680
static or

00:50:20,480 --> 00:50:27,599
extern so anything at namespace scope

00:50:23,680 --> 00:50:30,160
static or extern is going to be

00:50:27,599 --> 00:50:33,119
is going to be constructed in static

00:50:30,160 --> 00:50:33,119
duration storage

00:50:33,359 --> 00:50:40,240
importantly for some object

00:50:37,200 --> 00:50:41,839
that is declared at namespace scope or

00:50:40,240 --> 00:50:44,319
static or extern

00:50:41,839 --> 00:50:46,079
and which has static storage duration

00:50:44,319 --> 00:50:47,680
there can only be one object with a

00:50:46,079 --> 00:50:51,599
given name

00:50:47,680 --> 00:50:53,760
in static storage in the program

00:50:51,599 --> 00:50:55,760
so you can't have two global variables

00:50:53,760 --> 00:50:56,720
in the same name space of the same type

00:50:55,760 --> 00:50:58,640
named x

00:50:56,720 --> 00:51:00,240
or actually even not of the same type

00:50:58,640 --> 00:51:02,640
named x

00:51:00,240 --> 00:51:04,160
thread storage duration is when object

00:51:02,640 --> 00:51:06,880
storage is allocated

00:51:04,160 --> 00:51:08,000
when a thread is created and it's

00:51:06,880 --> 00:51:10,559
deallocated when that

00:51:08,000 --> 00:51:12,079
thread ends this is storage that applies

00:51:10,559 --> 00:51:13,119
to objects that are declared thread

00:51:12,079 --> 00:51:15,040
local

00:51:13,119 --> 00:51:16,160
and in this case every thread has its

00:51:15,040 --> 00:51:22,160
own instance of an

00:51:16,160 --> 00:51:23,520
object with this thread duration the few

00:51:22,160 --> 00:51:25,119
minutes i have left i want to talk

00:51:23,520 --> 00:51:28,880
briefly about what abi

00:51:25,119 --> 00:51:30,800
is abi stands for application binary

00:51:28,880 --> 00:51:32,559
interface and it's a platform specific

00:51:30,800 --> 00:51:33,040
description of how entities which we

00:51:32,559 --> 00:51:35,440
define

00:51:33,040 --> 00:51:37,040
in one translation unit interact with

00:51:35,440 --> 00:51:38,400
entities that are defined in another

00:51:37,040 --> 00:51:40,160
translation unit

00:51:38,400 --> 00:51:42,160
for c plus plus this includes things

00:51:40,160 --> 00:51:44,640
like name mangling for functions

00:51:42,160 --> 00:51:45,839
name mangling for non-template types

00:51:44,640 --> 00:51:47,200
name bangling for template

00:51:45,839 --> 00:51:49,359
instantiations

00:51:47,200 --> 00:51:50,960
the size layout and alignment of objects

00:51:49,359 --> 00:51:52,960
of any given type

00:51:50,960 --> 00:51:55,200
how the bytes in an object's binary

00:51:52,960 --> 00:51:56,480
representation are to be interpreted by

00:51:55,200 --> 00:51:58,240
the program

00:51:56,480 --> 00:51:59,680
the calling conventions for passing

00:51:58,240 --> 00:52:01,440
arguments to functions

00:51:59,680 --> 00:52:02,720
and receiving objects that are returned

00:52:01,440 --> 00:52:04,400
from functions

00:52:02,720 --> 00:52:06,720
and the calling conventions for making

00:52:04,400 --> 00:52:08,640
system calls calls into the operating

00:52:06,720 --> 00:52:10,800
system

00:52:08,640 --> 00:52:13,599
on linux gcc and clang used something

00:52:10,800 --> 00:52:16,640
called the itanium avi

00:52:13,599 --> 00:52:19,760
on x86 x64

00:52:16,640 --> 00:52:22,640
microsoft and visual studio windows uses

00:52:19,760 --> 00:52:24,160
its own abi

00:52:22,640 --> 00:52:25,680
let's talk briefly about what name

00:52:24,160 --> 00:52:27,520
mangling is

00:52:25,680 --> 00:52:29,119
name angling refers to the way in which

00:52:27,520 --> 00:52:31,119
entities in a translation unit

00:52:29,119 --> 00:52:32,319
are transformed into symbol names and

00:52:31,119 --> 00:52:34,559
object code

00:52:32,319 --> 00:52:36,640
now c plus plus historically has

00:52:34,559 --> 00:52:39,359
deliberately maintained binary binary

00:52:36,640 --> 00:52:41,920
compatibility with c

00:52:39,359 --> 00:52:43,599
this means that c plus object files can

00:52:41,920 --> 00:52:46,880
use functions and data

00:52:43,599 --> 00:52:48,160
that are defined in c object files and

00:52:46,880 --> 00:52:51,680
with a little bit of work

00:52:48,160 --> 00:52:53,280
the other way as well now the c language

00:52:51,680 --> 00:52:55,520
does not provide overloading or

00:52:53,280 --> 00:52:57,760
namespaces

00:52:55,520 --> 00:52:58,839
so given a c function with this very

00:52:57,760 --> 00:53:02,160
simple

00:52:58,839 --> 00:53:05,280
declaration this corresponding

00:53:02,160 --> 00:53:06,720
symbol name for that function is un uh

00:53:05,280 --> 00:53:09,040
is basically taking the name of the

00:53:06,720 --> 00:53:12,319
function and prefixing it with an

00:53:09,040 --> 00:53:15,599
underscore it's that simple now this is

00:53:12,319 --> 00:53:18,720
usual for c

00:53:15,599 --> 00:53:19,520
so because there's no overloading or

00:53:18,720 --> 00:53:22,240
namespaces

00:53:19,520 --> 00:53:23,200
there's no need to further refine that

00:53:22,240 --> 00:53:26,800
name

00:53:23,200 --> 00:53:28,000
the function name fubar will be uniquely

00:53:26,800 --> 00:53:30,559
represented by the symbol

00:53:28,000 --> 00:53:31,040
name underscore foobar in the object

00:53:30,559 --> 00:53:32,880
code

00:53:31,040 --> 00:53:34,319
when the program is linked and there

00:53:32,880 --> 00:53:36,240
should only be one

00:53:34,319 --> 00:53:38,480
set of object code referred to by the

00:53:36,240 --> 00:53:40,960
symbol name underscore foobar

00:53:38,480 --> 00:53:43,839
in the entire program across all of the

00:53:40,960 --> 00:53:43,839
set of object files

00:53:44,240 --> 00:53:47,680
so the symbol name here is the same no

00:53:45,920 --> 00:53:48,400
matter how many parameters or what their

00:53:47,680 --> 00:53:50,800
types

00:53:48,400 --> 00:53:51,440
so reusing names in c can be tricky

00:53:50,800 --> 00:53:54,720
right

00:53:51,440 --> 00:53:56,800
it's difficult or it's it's painful

00:53:54,720 --> 00:53:58,160
well c plus does support overloading

00:53:56,800 --> 00:53:59,680
it's one of the most important and

00:53:58,160 --> 00:54:00,720
interesting features and it supports

00:53:59,680 --> 00:54:02,480
name spaces

00:54:00,720 --> 00:54:03,839
and this allows us to use short human

00:54:02,480 --> 00:54:05,520
readable names

00:54:03,839 --> 00:54:07,599
in many different scopes or many

00:54:05,520 --> 00:54:09,520
different contexts

00:54:07,599 --> 00:54:11,440
so what we need to do is we need to be

00:54:09,520 --> 00:54:14,400
able to map the name of a c

00:54:11,440 --> 00:54:15,599
plus entity into a name that can coexist

00:54:14,400 --> 00:54:19,119
with the names of c

00:54:15,599 --> 00:54:22,720
entities so that means that

00:54:19,119 --> 00:54:24,000
every overloaded use of a name has to be

00:54:22,720 --> 00:54:27,200
transformed into a

00:54:24,000 --> 00:54:27,520
unique symbol name and the way we do

00:54:27,200 --> 00:54:30,079
this

00:54:27,520 --> 00:54:30,640
is we encode extra information about the

00:54:30,079 --> 00:54:33,920
entity

00:54:30,640 --> 00:54:35,040
directly into the symbol name so for

00:54:33,920 --> 00:54:37,119
example

00:54:35,040 --> 00:54:38,079
uh here's an example that i cribbed from

00:54:37,119 --> 00:54:41,599
wikipedia

00:54:38,079 --> 00:54:44,079
and expanded a little bit here i've got

00:54:41,599 --> 00:54:45,839
a class called article and it has a

00:54:44,079 --> 00:54:47,359
public member function called format

00:54:45,839 --> 00:54:49,200
that returns a string

00:54:47,359 --> 00:54:51,839
and it exists in this name space called

00:54:49,200 --> 00:54:54,000
wikipedia

00:54:51,839 --> 00:54:54,960
looking through the object files with nm

00:54:54,000 --> 00:54:57,680
you can see

00:54:54,960 --> 00:54:59,200
that this is the name for that entity

00:54:57,680 --> 00:55:01,520
this is the symbol name

00:54:59,200 --> 00:55:03,920
that is associated with the object code

00:55:01,520 --> 00:55:06,240
that goes with this member function

00:55:03,920 --> 00:55:07,839
it's long and ugly and hard to read but

00:55:06,240 --> 00:55:10,720
it's a unique symbol name

00:55:07,839 --> 00:55:11,040
that corresponds to the conventions that

00:55:10,720 --> 00:55:15,119
c

00:55:11,040 --> 00:55:17,280
looks for if i declare

00:55:15,119 --> 00:55:19,680
another function i overload the name

00:55:17,280 --> 00:55:22,000
format and in this case it takes a const

00:55:19,680 --> 00:55:24,000
ref to a string and a 64-bit sign

00:55:22,000 --> 00:55:26,640
integer as arguments and also returns a

00:55:24,000 --> 00:55:29,599
string and it has the same name format

00:55:26,640 --> 00:55:30,799
so i'm re-using the name format it has a

00:55:29,599 --> 00:55:34,880
much longer

00:55:30,799 --> 00:55:36,880
and uglier symbol name

00:55:34,880 --> 00:55:37,920
but again it is sufficient to

00:55:36,880 --> 00:55:41,200
distinguish it from

00:55:37,920 --> 00:55:41,200
other c symbol names

00:55:42,000 --> 00:55:45,680
so linking is the final stage of

00:55:44,079 --> 00:55:46,480
compilation which is performed by the

00:55:45,680 --> 00:55:48,079
linker and

00:55:46,480 --> 00:55:49,760
as i've said a couple times before it

00:55:48,079 --> 00:55:51,359
combines object files

00:55:49,760 --> 00:55:54,079
and libraries to produce the final

00:55:51,359 --> 00:55:55,920
executable it does this by examining all

00:55:54,079 --> 00:55:56,559
the object files to find all the symbols

00:55:55,920 --> 00:55:58,240
that are in them

00:55:56,559 --> 00:56:00,000
it determines the set of all the symbols

00:55:58,240 --> 00:56:02,559
that are used by the program

00:56:00,000 --> 00:56:04,799
it resolves references from internal

00:56:02,559 --> 00:56:06,720
symbols and external symbols

00:56:04,799 --> 00:56:08,400
it assigns final addresses to the

00:56:06,720 --> 00:56:09,760
symbols that represent functions and

00:56:08,400 --> 00:56:12,160
variables

00:56:09,760 --> 00:56:14,400
it revises code and data to reflect

00:56:12,160 --> 00:56:16,480
these addresses object code and data to

00:56:14,400 --> 00:56:18,160
reflect these addresses it emits

00:56:16,480 --> 00:56:20,240
executable code

00:56:18,160 --> 00:56:22,000
an important key here for everything to

00:56:20,240 --> 00:56:23,920
work is that the compiler and the linker

00:56:22,000 --> 00:56:25,599
have to agree on the abi

00:56:23,920 --> 00:56:27,760
which means they both have to understand

00:56:25,599 --> 00:56:30,640
data layouts and calling conventions

00:56:27,760 --> 00:56:31,200
and other things so both have to

00:56:30,640 --> 00:56:34,400
understand

00:56:31,200 --> 00:56:35,280
object code in the same way loading and

00:56:34,400 --> 00:56:37,119
running well

00:56:35,280 --> 00:56:39,200
get ready to run your program the

00:56:37,119 --> 00:56:40,720
operating system loader validates the

00:56:39,200 --> 00:56:42,559
executable file it checks the

00:56:40,720 --> 00:56:44,079
permissions it checks the resource

00:56:42,559 --> 00:56:46,000
requirements like do i have enough

00:56:44,079 --> 00:56:49,200
memory to run this program

00:56:46,000 --> 00:56:50,079
it it verifies that the file is indeed

00:56:49,200 --> 00:56:52,000
executable

00:56:50,079 --> 00:56:53,839
and that the instructions it has are

00:56:52,000 --> 00:56:55,760
valid

00:56:53,839 --> 00:56:58,160
the operating system then loads and runs

00:56:55,760 --> 00:57:00,000
the image it does this by copying the

00:56:58,160 --> 00:57:01,920
executable image into memory

00:57:00,000 --> 00:57:03,839
if there's any dynamically linked

00:57:01,920 --> 00:57:06,960
libraries there have to be the final

00:57:03,839 --> 00:57:10,160
resolution of unresolved symbols

00:57:06,960 --> 00:57:11,920
this is called relocation and fix up

00:57:10,160 --> 00:57:13,680
command line parameters given to the

00:57:11,920 --> 00:57:14,960
program are copied onto the program

00:57:13,680 --> 00:57:16,640
stack

00:57:14,960 --> 00:57:19,280
registers that are going to be used are

00:57:16,640 --> 00:57:20,480
initialized the stack pointer is set to

00:57:19,280 --> 00:57:23,119
the top of the stack

00:57:20,480 --> 00:57:24,960
and other registers are cleared control

00:57:23,119 --> 00:57:27,440
jumps to the start routine

00:57:24,960 --> 00:57:29,200
which performs program initialization

00:57:27,440 --> 00:57:30,640
and calls main with the command line

00:57:29,200 --> 00:57:32,559
parameters

00:57:30,640 --> 00:57:34,400
and at that point you've got a running

00:57:32,559 --> 00:57:36,559
program

00:57:34,400 --> 00:57:38,640
so i'm just about out of time here and

00:57:36,559 --> 00:57:40,960
that's the end of my presentation

00:57:38,640 --> 00:57:42,559
thank you for uh thank you for attending

00:57:40,960 --> 00:57:43,760
and i hope you got something out of this

00:57:42,559 --> 00:57:45,599
talk

00:57:43,760 --> 00:57:47,200
i'll answer questions for a couple of

00:57:45,599 --> 00:57:47,839
minutes i don't want to run over for too

00:57:47,200 --> 00:57:52,559
long

00:57:47,839 --> 00:57:52,559
let me just go to remo here

00:57:53,599 --> 00:57:58,240
okay so uh one question is the first

00:57:57,440 --> 00:58:00,720
question is

00:57:58,240 --> 00:58:01,440
can you expand on why we can define

00:58:00,720 --> 00:58:04,400
classes

00:58:01,440 --> 00:58:07,040
multiple times why doesn't that violate

00:58:04,400 --> 00:58:10,480
the odr

00:58:07,040 --> 00:58:13,760
so remember

00:58:10,480 --> 00:58:13,760
a class definition

00:58:14,319 --> 00:58:20,640
by itself doesn't

00:58:17,520 --> 00:58:22,880
actually if you have a class definition

00:58:20,640 --> 00:58:24,480
that only declares the member functions

00:58:22,880 --> 00:58:27,119
in it or

00:58:24,480 --> 00:58:29,920
the member functions are declared inline

00:58:27,119 --> 00:58:33,119
inside the class declaration

00:58:29,920 --> 00:58:34,960
what you've said to the compiler is here

00:58:33,119 --> 00:58:36,000
is the definition of the class here's

00:58:34,960 --> 00:58:37,599
the name of all the member

00:58:36,000 --> 00:58:39,680
functions here's all the data members

00:58:37,599 --> 00:58:41,200
the class is going to contain

00:58:39,680 --> 00:58:43,440
here are some member functions that may

00:58:41,200 --> 00:58:46,079
be declared inline

00:58:43,440 --> 00:58:47,839
right go ahead and use that information

00:58:46,079 --> 00:58:50,960
in translation unit

00:58:47,839 --> 00:58:52,799
a well in translation unit a

00:58:50,960 --> 00:58:54,079
if i call those class member functions

00:58:52,799 --> 00:58:56,319
that are that are

00:58:54,079 --> 00:58:57,359
defined inside the class they are

00:58:56,319 --> 00:58:59,839
implicitly inline

00:58:57,359 --> 00:59:01,839
they're inline functions and inline

00:58:59,839 --> 00:59:03,680
functions are allowed to be used

00:59:01,839 --> 00:59:06,559
in multiple translation units without

00:59:03,680 --> 00:59:08,240
violating odr

00:59:06,559 --> 00:59:10,559
if you think back to the example that i

00:59:08,240 --> 00:59:10,559
gave

00:59:10,799 --> 00:59:14,319
and let me see if i can find it very

00:59:16,839 --> 00:59:19,839
quickly

00:59:21,200 --> 00:59:24,559
if you think back to this example

00:59:26,079 --> 00:59:30,720
here i've got a class definition but the

00:59:29,280 --> 00:59:32,880
member function itself

00:59:30,720 --> 00:59:33,760
i've declared i've defined it out of

00:59:32,880 --> 00:59:35,520
line

00:59:33,760 --> 00:59:37,359
and so it's this definition of this

00:59:35,520 --> 00:59:39,599
function that's actually violating the

00:59:37,359 --> 00:59:42,480
odr because in this particular instance

00:59:39,599 --> 00:59:42,480
it's out of line

00:59:45,440 --> 00:59:48,160
in this case

00:59:49,200 --> 00:59:52,480
the class is defined and simply the

00:59:50,799 --> 00:59:53,920
definition of class is not enough to

00:59:52,480 --> 00:59:56,720
trigger an odr warning

00:59:53,920 --> 00:59:57,440
my member function is inline so i can

00:59:56,720 --> 00:59:59,280
define it

00:59:57,440 --> 01:00:01,599
and use it in multiple locations because

00:59:59,280 --> 01:00:04,319
that's what inline means

01:00:01,599 --> 01:00:05,359
this is okay because i've only i've

01:00:04,319 --> 01:00:07,440
defined the class

01:00:05,359 --> 01:00:09,119
and declared the member function and in

01:00:07,440 --> 01:00:12,160
another translation unit

01:00:09,119 --> 01:00:14,079
i have redefined the class effectively

01:00:12,160 --> 01:00:15,839
redeclaring everything that's in it and

01:00:14,079 --> 01:00:18,000
i've defined the member function

01:00:15,839 --> 01:00:20,319
and classes are actually called out as

01:00:18,000 --> 01:00:22,400
one of those exceptions in odr that say

01:00:20,319 --> 01:00:23,760
in the standard that says classes are

01:00:22,400 --> 01:00:26,319
allowed to be defined

01:00:23,760 --> 01:00:28,160
in in multiple translation units without

01:00:26,319 --> 01:00:31,440
violating odr

01:00:28,160 --> 01:00:33,839
i hope that answers your question

01:00:31,440 --> 01:00:35,359
uh last question will the slides be

01:00:33,839 --> 01:00:39,119
shared with participants

01:00:35,359 --> 01:00:43,839
well yes they will um

01:00:39,119 --> 01:00:43,839
i will put them up on my github account

01:00:44,160 --> 01:00:49,280
give me a moment i will pull up my last

01:00:48,000 --> 01:00:53,359
slide

01:00:49,280 --> 01:00:53,359
that that has that information

01:00:54,839 --> 01:00:58,799
okay so i will

01:00:57,040 --> 01:01:00,880
take this presentation and the

01:00:58,799 --> 01:01:03,440
presentation i did before this one

01:01:00,880 --> 01:01:04,559
and they will be up on github today uh

01:01:03,440 --> 01:01:05,760
by the end of the day

01:01:04,559 --> 01:01:08,079
i'm not going to do it right now i'm

01:01:05,760 --> 01:01:09,760
going to take a break so thank you for

01:01:08,079 --> 01:01:10,720
coming everyone i really appreciate your

01:01:09,760 --> 01:01:12,319
attending

01:01:10,720 --> 01:01:13,760
i hope you got something useful out of

01:01:12,319 --> 01:01:15,599
this and

01:01:13,760 --> 01:01:25,839
i hope to see you all in the hallway

01:01:15,599 --> 01:01:25,839
take care

01:01:36,240 --> 01:01:38,319

YouTube URL: https://www.youtube.com/watch?v=3KoXeegncrs


