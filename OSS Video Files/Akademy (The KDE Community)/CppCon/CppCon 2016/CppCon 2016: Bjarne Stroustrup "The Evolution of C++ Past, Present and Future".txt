Title: CppCon 2016: Bjarne Stroustrup "The Evolution of C++ Past, Present and Future"
Publication date: 2016-09-22
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
This is a philosophical talk. It deals with ideals, aims, and ways of approximating those. It deals with practical constraints and risks. It gives short examples. It presents a perspective of what drives the evolution of C++. What is C++ and what it must become over the next years for its success to continue? This involves both social and technical points. Towards the end, I discuss the direction of C++ future evolution, give some opinions, point to urgently needed new features, and discuss how to manage until they are part of the standard.
— 
Bjarne Stroustrup
MD, Morgan Stanley
C++: history, design, use, standardization, future; performance, reliability; software developer education; | distributed systems
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,370 --> 00:00:04,728
I was thinking about what I was going to talk about at this

00:00:04,728 --> 00:00:07,436
conference as a key note speaker.

00:00:07,436 --> 00:00:12,469
And I looked at the program, and decided that there

00:00:12,469 --> 00:00:17,159
was an awful lot of nice, good, detail stuff.

00:00:18,290 --> 00:00:23,080
Language things, library stuff and such, so I shouldn't do that.

00:00:24,540 --> 00:00:27,865
So, I am trying to talk about something more general,

00:00:27,865 --> 00:00:33,580
bigger ideas, and so I'm talking about the evolution.

00:00:33,580 --> 00:00:38,548
And I'm trying to look back and see why on earth does this happen?

00:00:38,548 --> 00:00:43,610
I mean C++ has been declared dead at least ten times every year,

00:00:43,610 --> 00:00:45,710
for the last about 35, right?

00:00:46,900 --> 00:00:51,270
So, let's look at it and

00:00:51,270 --> 00:00:54,700
why it didn't die in the crib, or after that.

00:00:54,700 --> 00:00:58,040
And then, I'm going to look a little bit about standardization and

00:00:58,040 --> 00:01:01,900
see what are the opportunities and the dangers now.

00:01:01,900 --> 00:01:03,210
And then, I'm going to try and

00:01:03,210 --> 00:01:05,570
answer the question, where are we going?

00:01:05,570 --> 00:01:06,940
Where should we be going?

00:01:06,940 --> 00:01:12,140
How can we sustain what we have been doing so far and make it better?

00:01:12,140 --> 00:01:16,110
And then, this gets too philosophical, right?

00:01:16,110 --> 00:01:20,152
Then I have some concrete stuff about what we can do today, and

00:01:20,152 --> 00:01:22,193
that's how I'm going to end.

00:01:22,193 --> 00:01:25,380
But first we start with philosophy.

00:01:25,380 --> 00:01:31,120
There's a couple of philosophers, and there's a tension between ideas,

00:01:31,120 --> 00:01:35,480
and principles, and practicalities.

00:01:35,480 --> 00:01:36,890
And this has been going on for

00:01:36,890 --> 00:01:41,160
at least 2,500 years and it hasn't stopped yet.

00:01:41,160 --> 00:01:45,640
But this is one of the tensions that we're going to talk about.

00:01:45,640 --> 00:01:51,009
And I am not going to give you long lists of features, other people will

00:01:51,009 --> 00:01:56,845
be doing this, you don't have to, if that's what you want you'll get it.

00:01:56,845 --> 00:02:01,441
And I can't give you really cool stuff, go to the people at ship

00:02:01,441 --> 00:02:06,170
libraries and such, and talk to some of the compile inventors.

00:02:06,170 --> 00:02:10,410
Cool stuff is shipping, it's just not what I'm talking about.

00:02:10,410 --> 00:02:16,459
And then, again, going back, why did C++ succeed?

00:02:16,459 --> 00:02:18,234
What can we do?

00:02:18,234 --> 00:02:23,470
And I've heard many theories, my least favorite is being lucky.

00:02:23,470 --> 00:02:25,720
How do you stay lucky for 35 years?

00:02:26,860 --> 00:02:28,690
It takes hard work.

00:02:28,690 --> 00:02:32,352
And furthermore, yeah, one thing to point out,

00:02:32,352 --> 00:02:36,860
when I talk about C++, I'm taking a very C++ centric view.

00:02:36,860 --> 00:02:41,574
I could give a totally different talk about the industry, and

00:02:41,574 --> 00:02:45,210
where C++ fit, and all of that kind of stuff.

00:02:45,210 --> 00:02:50,206
That's not what I'm doing, I'm very C++ centric.

00:02:50,206 --> 00:02:53,830
If you want to criticize me for it, fine, but

00:02:53,830 --> 00:02:58,180
remember I know that too, and this is just lack of time.

00:02:59,360 --> 00:03:02,240
Okay, so let's look at philosophers.

00:03:02,240 --> 00:03:05,810
Here's a good, dream no little dreams.

00:03:05,810 --> 00:03:08,680
In other words, what are we really trying to do?

00:03:08,680 --> 00:03:09,948
What's a big picture?

00:03:09,948 --> 00:03:14,770
What is the thing that sustains us, sustains C++ over decades,

00:03:14,770 --> 00:03:18,140
as opposed to days, weeks, months, years?

00:03:19,140 --> 00:03:23,923
Basically, my aim, and I hope many other aims are,

00:03:23,923 --> 00:03:27,780
simply to do things much better.

00:03:27,780 --> 00:03:30,360
And to do things much better in software development you

00:03:30,360 --> 00:03:34,620
have to think differently, you have to construct your code differently.

00:03:34,620 --> 00:03:38,054
Just doing what we've always done, but

00:03:38,054 --> 00:03:42,407
slightly better, it's not going to get us there.

00:03:42,407 --> 00:03:46,984
It's going to get us the next project shipped, it's going to get

00:03:46,984 --> 00:03:51,645
us to the next year, but it's not going to sustain the language and

00:03:51,645 --> 00:03:54,230
the community for decades.

00:03:54,230 --> 00:03:59,720
So, I would like type and resource safe, without any adjectives or

00:03:59,720 --> 00:04:01,580
other worries.

00:04:01,580 --> 00:04:05,610
I want the code, I have to read, to be simpler and

00:04:05,610 --> 00:04:08,060
clearer, easier to understand.

00:04:08,060 --> 00:04:09,225
This is important,

00:04:09,225 --> 00:04:12,388
I mean that's what you spent most of our time doing it.

00:04:12,388 --> 00:04:14,910
You should be looking at code that isn't finished or

00:04:14,910 --> 00:04:19,261
has bugs in it, and clarity, simplicity is really,

00:04:19,261 --> 00:04:22,670
really valid and the language in the libraries can help there.

00:04:22,670 --> 00:04:24,180
That's what we want to do.

00:04:24,180 --> 00:04:29,280
And of course this C++ has to be as fast as faster, than anything else.

00:04:29,280 --> 00:04:33,260
If you want slow code, you can get it,

00:04:33,260 --> 00:04:35,400
there's benefits sometimes to have slow code.

00:04:35,400 --> 00:04:38,260
You can have tools that allow you to write it sooner and such.

00:04:39,350 --> 00:04:42,983
But anyway, as fast and simpler than anything else, and

00:04:42,983 --> 00:04:45,610
it has to be good at modern hardware.

00:04:45,610 --> 00:04:49,540
One of the strengths of C++, as I'll repeat a few times here,

00:04:49,540 --> 00:04:52,890
is it actually has mapped really nicely to hardware.

00:04:52,890 --> 00:04:55,865
Hardware is getting weirder.

00:04:55,865 --> 00:04:59,294
There are more pipelines, there's more forms of concurrency,

00:04:59,294 --> 00:05:02,824
there's more strangeness inside the compilers and optimizers.

00:05:02,824 --> 00:05:06,480
C++ is supposed to be good at that stuff,

00:05:06,480 --> 00:05:08,303
let's keep it being good at that stuff.

00:05:08,303 --> 00:05:14,080
And then, compile times, nobody really like long compile times,

00:05:14,080 --> 00:05:16,400
let's get much faster about this.

00:05:16,400 --> 00:05:19,720
And remember, in these things I'm not talking percent.

00:05:19,720 --> 00:05:22,270
If you give me 10% I'll be very unhappy,

00:05:22,270 --> 00:05:24,370
if you give me ten times, I'll get happy.

00:05:25,450 --> 00:05:26,800
But that's not easy,

00:05:28,150 --> 00:05:32,760
here we have an expert on difficulties, Niccolò Machiavelli,

00:05:32,760 --> 00:05:37,780
the famous historian of the Roman Republic, patriot, and politician.

00:05:37,780 --> 00:05:40,580
There's nothing more difficult to carry out, nor

00:05:40,580 --> 00:05:44,390
more doubtful of success, no more dangerous to handle,

00:05:44,390 --> 00:05:47,130
than to initiate a new order of things.

00:05:47,130 --> 00:05:51,030
In other words, don't rock the boat, it's dangerous for you.

00:05:51,030 --> 00:05:54,360
Don't try and make things that are really new, don't try and

00:05:54,360 --> 00:05:59,460
make things that are significantly different.

00:05:59,460 --> 00:06:04,985
And if you look at this, and of course that

00:06:04,985 --> 00:06:09,000
is what I'm trying to do, it's also what Machiavelli was trying to do.

00:06:09,000 --> 00:06:11,730
He wrote a book trying to convince people to do it, and

00:06:11,730 --> 00:06:16,780
people convinced that he was wrong because he explains things the way

00:06:16,780 --> 00:06:22,070
they were, as opposed to the things that people pretended they were.

00:06:22,070 --> 00:06:24,620
I quoted that in the third edition,

00:06:24,620 --> 00:06:28,670
and here's a continuation, the problem is it's dangerous

00:06:28,670 --> 00:06:31,670
because you make enemies of everybody who loves status quo.

00:06:32,950 --> 00:06:37,940
And people who would like something new tend to be lukewarm,

00:06:37,940 --> 00:06:39,060
because it isn't there yet.

00:06:39,060 --> 00:06:41,330
They can't use it on their next project,

00:06:41,330 --> 00:06:45,420
they can't use it next year, and so there's an imbalance here.

00:06:45,420 --> 00:06:46,830
And so, my conclusion is,

00:06:46,830 --> 00:06:51,080
developers love minor changes that helps with current problems.

00:06:51,080 --> 00:06:53,453
And they don't really,

00:06:53,453 --> 00:06:59,860
people had a vested interest in the status quo stronger, okay.

00:06:59,860 --> 00:07:03,119
Then also remember, the best is the enemy of the good.

00:07:04,230 --> 00:07:06,720
We can't just sit around and wait for perfection.

00:07:08,520 --> 00:07:12,580
No, that doesn't get us to perfection, for starters,

00:07:12,580 --> 00:07:14,100
we don't learn anything.

00:07:14,100 --> 00:07:17,890
There's no feedback loops in trying to perfect,

00:07:17,890 --> 00:07:19,230
you have to move further.

00:07:19,230 --> 00:07:22,950
So, we're going to talk a little bit about what concrete practical steps

00:07:22,950 --> 00:07:26,420
we can take now, that's the last quarter of the talk.

00:07:26,420 --> 00:07:29,620
And then, of course, we can't do it alone, and

00:07:29,620 --> 00:07:33,569
I'll point out that a lot of people have helped.

00:07:34,620 --> 00:07:38,670
There's just a few names there, if I had put everybody who needed

00:07:38,670 --> 00:07:42,540
thanks on this slide, I would have to use an 8 point font, and

00:07:42,540 --> 00:07:45,190
you couldn't have seen a single name.

00:07:45,190 --> 00:07:46,700
There's always these tradeoffs.

00:07:48,660 --> 00:07:53,150
Okay, let's look at C++, here's a graph,

00:07:54,370 --> 00:07:58,500
some of the numbers are real, but it's hard to get numbers.

00:07:59,540 --> 00:08:01,210
In particular, the bottom and

00:08:01,210 --> 00:08:04,440
the top and some of the flex points are real.

00:08:05,660 --> 00:08:09,880
What I had to do is some interpellation, especially around

00:08:09,880 --> 00:08:14,980
the 2002 plus minus column, the rest is pretty good.

00:08:14,980 --> 00:08:19,575
So let's see, I mean, we had a commercial released in 85.

00:08:19,575 --> 00:08:23,410
That's a long time ago, why did we have exponential growth?

00:08:23,410 --> 00:08:27,450
I measured it as doubling every 7.5 months for

00:08:27,450 --> 00:08:32,718
11 years, and then I couldn't count that high anymore.

00:08:32,718 --> 00:08:37,650
Numbers got too big, my sources were not good enough, and

00:08:37,650 --> 00:08:39,380
then obviously, there was a slowdown.

00:08:40,600 --> 00:08:45,152
And we've got a really serious slowdown just

00:08:45,152 --> 00:08:49,116
after 2000, and then it resumed.

00:08:49,116 --> 00:08:52,598
I mean, we have pretty good numbers for the last three, four,

00:08:52,598 --> 00:08:56,440
five years, and there's no doubt we're on an upward curve.

00:08:56,440 --> 00:09:00,790
So, if I can explain this slide, I can actually

00:09:00,790 --> 00:09:06,020
get some guidance about what we should do to sustain it.

00:09:06,020 --> 00:09:10,792
What people would like, what would actually help people, so

00:09:10,792 --> 00:09:13,005
let's go back to the roots.

00:09:13,005 --> 00:09:15,402
Where does C++ come from?

00:09:15,402 --> 00:09:20,033
Some of you may have seen this slide, the past doesn't change

00:09:20,033 --> 00:09:25,160
very often, and so there are two sources of C++'s strength.

00:09:25,160 --> 00:09:28,670
The bottomline there starts with, try and

00:09:28,670 --> 00:09:34,230
squeeze every cycle, every bite out of the hardware.

00:09:34,230 --> 00:09:37,230
It starts with assembler, David Wheeler there

00:09:37,230 --> 00:09:40,030
is one of first people who claimed to have built a compiler.

00:09:40,030 --> 00:09:44,260
He certainly wrote the very first program on a slow program computer.

00:09:44,260 --> 00:09:49,050
And he was my thesis advisor, so he gave me a lot of information.

00:09:50,500 --> 00:09:54,447
BCPL, C we know about that, and.

00:09:56,469 --> 00:09:57,571
The problem is,

00:09:57,571 --> 00:10:01,992
that most of the time we're not actually manipulating hardware.

00:10:01,992 --> 00:10:06,457
Some of us are, and C and C++ is good at it, should be good at it,

00:10:06,457 --> 00:10:08,420
it's designed to be.

00:10:08,420 --> 00:10:12,360
But there's another line of thought here which is abstraction.

00:10:14,338 --> 00:10:15,770
Back us there, and

00:10:15,770 --> 00:10:20,680
his team invented Fortran, which was the most significant improvement in

00:10:22,490 --> 00:10:27,160
programming sofa, they lifted the language from

00:10:28,200 --> 00:10:32,620
the hardware up to something that was more suitable for humans.

00:10:32,620 --> 00:10:36,900
Very particular kinds of humans, engineers and scientists, but

00:10:36,900 --> 00:10:41,790
they had a language that then could be mapped to different computers,

00:10:41,790 --> 00:10:44,170
and you can get portability and all kinds of good things.

00:10:44,170 --> 00:10:47,360
They didn't mean to, they just meant to give a language that would be

00:10:47,360 --> 00:10:50,190
good for scientists and engineers.

00:10:50,190 --> 00:10:51,160
But once scientists and

00:10:51,160 --> 00:10:54,630
engineers have got it, everybody wanted one too.

00:10:54,630 --> 00:10:58,440
So, you've got 200 more languages that specialize for

00:10:58,440 --> 00:11:02,070
different things, Cobol for business people and such.

00:11:02,070 --> 00:11:03,470
And now, he had a filthy mess.

00:11:03,470 --> 00:11:05,680
200 languages, and they couldn't talk together.

00:11:06,720 --> 00:11:08,700
You want to gather some data?

00:11:08,700 --> 00:11:11,710
You put it on a record.

00:11:11,710 --> 00:11:13,390
Cobol's really good at that.

00:11:13,390 --> 00:11:16,180
Then you want to run some statistical analysis on it?

00:11:16,180 --> 00:11:17,770
Fortran is really good at that.

00:11:17,770 --> 00:11:19,346
Fortran doesn't speak to Cobol.

00:11:19,346 --> 00:11:24,940
And there's many particular solutions to that kind of problems.

00:11:24,940 --> 00:11:28,870
But the general solution came with and Simula.

00:11:28,870 --> 00:11:30,270
Object oriented programming.

00:11:32,260 --> 00:11:35,840
Basically, instead of giving people an abstraction that's suitable for

00:11:35,840 --> 00:11:39,280
a particular kind of user, you have a generalization, so

00:11:39,280 --> 00:11:41,210
that you can build your own types.

00:11:41,210 --> 00:11:44,930
Your own class hierarchies, if you have related types.

00:11:44,930 --> 00:11:46,780
And that's a brilliant idea.

00:11:46,780 --> 00:11:54,130
And so, when I had a problem at Bell Labs, I said, why can't I have both?

00:11:54,130 --> 00:11:58,270
I want to use every ounce of the hardware, but

00:11:58,270 --> 00:12:01,839
I want to abstract away from it when I don't have to be bothered with it.

00:12:02,840 --> 00:12:07,840
And that's the true root of C++, and the first feature coming into it

00:12:07,840 --> 00:12:11,220
was classes, with constructors and destructors, and things like that.

00:12:11,220 --> 00:12:13,030
And a lot of things come from there.

00:12:13,030 --> 00:12:16,830
So, there are the two intellectual roots of C++,

00:12:16,830 --> 00:12:20,780
which I suggest it's a good idea to stick to.

00:12:20,780 --> 00:12:22,465
So, C++ in two lines.

00:12:22,465 --> 00:12:26,840
Not 1300 or 1400 pages, but

00:12:26,840 --> 00:12:30,450
if you really want to get the basic of it, that's where it is.

00:12:30,450 --> 00:12:35,890
Direct map to hardware came originally from C, and for future,

00:12:35,890 --> 00:12:40,660
we need facilities for dealing with the hardware that's now coming out.

00:12:40,660 --> 00:12:46,340
We can't just program against a 1990s computers,

00:12:47,360 --> 00:12:51,330
which is what we do when you misuse a current computer, and

00:12:51,330 --> 00:12:53,230
we need zero-overhead abstraction.

00:12:53,230 --> 00:12:56,360
We need to abstract, but I don't want to pay for it.

00:12:56,360 --> 00:12:58,820
Simula showed us the value of abstraction.

00:13:00,720 --> 00:13:03,554
Where I came in is I wanted it at no cost.

00:13:03,554 --> 00:13:07,950
And that's where you get, you get this from classes, you get

00:13:07,950 --> 00:13:12,700
an inheritance, you get a generic programming with templates and such,

00:13:12,700 --> 00:13:16,840
and for the future, I want type and resource safety with concepts,

00:13:16,840 --> 00:13:19,808
modules, and better concurrency support.

00:13:19,808 --> 00:13:25,400
So, that's C++ in two lines, and let's get a little bit concrete.

00:13:25,400 --> 00:13:32,090
You have to choose your level of distraction when you deal with C++.

00:13:32,090 --> 00:13:37,260
Here's a very trivial symbol example.

00:13:37,260 --> 00:13:39,449
I want to read some strings into a lecture.

00:13:40,520 --> 00:13:43,560
I can do it on the top, I can do it at the bottom.

00:13:43,560 --> 00:13:46,197
There wasn't room for the all flow checks, so sorry.

00:13:46,197 --> 00:13:52,758
I'm having two slides on, two examples on one slide.

00:13:52,758 --> 00:13:56,438
To give an example, I would prefer the top, and

00:13:56,438 --> 00:14:00,858
I'll prefer the top to run at least as fast as the bottom.

00:14:00,858 --> 00:14:05,180
For many, many application areas, that is possible.

00:14:05,180 --> 00:14:10,070
So, you can start with what you can do, and then you can improve it.

00:14:10,070 --> 00:14:13,370
And the aim should be that the higher level, the clearer,

00:14:13,370 --> 00:14:17,370
the type safe thing where you don't have to worry too much

00:14:17,370 --> 00:14:19,140
about the overflow and things like that.

00:14:19,140 --> 00:14:22,740
The distinction is fluid, you have a choice, but

00:14:22,740 --> 00:14:26,000
I would like to push people toward a more elegant solution.

00:14:27,400 --> 00:14:30,050
You also have to ask what matters.

00:14:31,590 --> 00:14:32,900
A lot of the things we talk about

00:14:32,900 --> 00:14:35,220
don't actually matter in the big picture.

00:14:35,220 --> 00:14:38,270
For software development, first of all, that's what matters,

00:14:38,270 --> 00:14:41,449
not who can have the cutest little example in an article.

00:14:42,690 --> 00:14:46,860
What actually matters for actually building things?

00:14:46,860 --> 00:14:49,740
Stability, important.

00:14:49,740 --> 00:14:53,930
There's a lot of 20 year old code out there, and

00:14:53,930 --> 00:14:58,210
evolution, there's a lot of new problems coming on, we must do that.

00:14:58,210 --> 00:15:00,650
We have tool chains, we have teaching and learning.

00:15:00,650 --> 00:15:05,520
There's lots of people, I get mail every week from people asking

00:15:05,520 --> 00:15:12,026
questions that relates only to Turbo C++ 4.0.

00:15:12,026 --> 00:15:13,980
This is sad.

00:15:13,980 --> 00:15:15,920
We have to improve teaching and learning.

00:15:15,920 --> 00:15:18,380
I always mention that, and it's really hard, there's so

00:15:18,380 --> 00:15:20,260
much inertia out there.

00:15:20,260 --> 00:15:24,090
There has to be a technical community,

00:15:24,090 --> 00:15:26,840
none of us write a program in isolation.

00:15:26,840 --> 00:15:30,250
We depend on the advice of others, the support of others,

00:15:30,250 --> 00:15:32,830
the tools from others, the ideas from others.

00:15:32,830 --> 00:15:38,090
We have to build that community, this conferences is part of that.

00:15:38,090 --> 00:15:40,140
I want concise expression of ideas.

00:15:40,140 --> 00:15:43,860
I actually want to be able to read your code and vice versa.

00:15:43,860 --> 00:15:47,550
If it's a mess of bits and bytes, often I can't.

00:15:47,550 --> 00:15:49,689
Coherent language, complete language,

00:15:52,860 --> 00:15:55,970
compact data structures that are out of date, lots of libraries.

00:15:55,970 --> 00:15:59,320
These are the things that are important, as opposed to

00:15:59,320 --> 00:16:02,980
language technique, or little details that also has to be right,

00:16:02,980 --> 00:16:04,760
but they have to support this.

00:16:04,760 --> 00:16:07,850
And one of the important thing to make note is that

00:16:07,850 --> 00:16:10,670
there at the bottom, a language must be good enough for

00:16:10,670 --> 00:16:12,770
everything you're doing in your project.

00:16:14,220 --> 00:16:17,660
If it totally fails at one thing, it totally fails.

00:16:19,578 --> 00:16:25,090
So, being the world's best at one or two things is not sufficient.

00:16:25,090 --> 00:16:29,520
You have to be really good at some things, preferably lots of things,

00:16:29,520 --> 00:16:31,580
but you mustn't totally fail anywhere.

00:16:31,580 --> 00:16:34,020
So, that's good.

00:16:34,020 --> 00:16:36,010
And it's really hard to do because you don't know what's

00:16:36,010 --> 00:16:37,010
important to people.

00:16:38,030 --> 00:16:42,983
There's far too many people to know what they want and what they need.

00:16:42,983 --> 00:16:48,065
I mean, we got 4.4, 4.5 million C++ programmers I mean,

00:16:48,065 --> 00:16:53,790
even if I was a mind reader, I couldn't read that many minds.

00:16:53,790 --> 00:16:56,130
So, this is difficult.

00:16:56,130 --> 00:16:58,200
But don't get obsessed with details.

00:16:58,200 --> 00:17:01,290
There are times to be obsessed with details when you finish one little

00:17:01,290 --> 00:17:02,700
corner of a project.

00:17:02,700 --> 00:17:05,170
But sometimes, you have to look at the picture.

00:17:05,170 --> 00:17:09,460
So, a language needs good fundamental features.

00:17:09,460 --> 00:17:10,240
That's important.

00:17:11,260 --> 00:17:15,860
And a good language is not just a set of good features.

00:17:15,860 --> 00:17:17,850
You have to have them fit together,

00:17:17,850 --> 00:17:22,170
and all framework has to be comprehensible and effective.

00:17:22,170 --> 00:17:26,410
You have to be able to use language features in a combination.

00:17:26,410 --> 00:17:28,920
You have to be able to have real compilers,

00:17:28,920 --> 00:17:31,276
generate good code from them, and things like that.

00:17:31,276 --> 00:17:34,490
And 90% of the work

00:17:34,490 --> 00:17:37,000
of getting something new into a language is integration.

00:17:39,020 --> 00:17:44,818
People always come, they sent this email, put this into C++,

00:17:44,818 --> 00:17:47,630
it's cool.

00:17:47,630 --> 00:17:49,600
Even if it is cool, even if I agree.

00:17:50,830 --> 00:17:55,480
Well, the first 10% is to write the proposal.

00:17:55,480 --> 00:17:58,430
And the next 90% is to figure out where it was wrong, and

00:17:58,430 --> 00:18:01,760
why it didn't fit in, and get everything to work together.

00:18:01,760 --> 00:18:04,290
But the discussions tend to be an individual feature,

00:18:05,910 --> 00:18:09,030
especially until they can't be tried out

00:18:09,030 --> 00:18:13,820
until they can be seen in context of the standard, or of a tutorial.

00:18:13,820 --> 00:18:19,530
We need to spend more time looking at individual problems,

00:18:19,530 --> 00:18:23,580
individual features in the context in which they are used.

00:18:23,580 --> 00:18:26,040
I mean, this kind of design issues.

00:18:26,040 --> 00:18:27,240
So, let's look.

00:18:27,240 --> 00:18:32,379
I tried to articulate rules of thumb, I've done that

00:18:32,379 --> 00:18:37,307
several times, in the design evolution of C++.

00:18:37,307 --> 00:18:40,491
But here's a list I found from 2003.

00:18:40,491 --> 00:18:44,402
Stability and compatibility, yep, you want new features, but

00:18:44,402 --> 00:18:46,689
you don't want me to break your code.

00:18:48,370 --> 00:18:51,360
Libraries are good, because we can deploy them today,

00:18:51,360 --> 00:18:54,620
rather than waiting until all of your compilers have been updated.

00:18:54,620 --> 00:18:59,656
There are many project for which you can't get away from,

00:18:59,656 --> 00:19:04,390
say Gcc4.3, and it doesn't matter what the standout committee does to

00:19:04,390 --> 00:19:08,070
improve the language, if you still have to use a ten year old compiler.

00:19:08,070 --> 00:19:10,880
So, we really have to help people getting off those compilers.

00:19:12,030 --> 00:19:14,530
But we have to make sure

00:19:14,530 --> 00:19:17,360
what libraries is one of the things that helps us.

00:19:17,360 --> 00:19:20,070
Generality, the point is we have hardware.

00:19:20,070 --> 00:19:21,370
We have extraction.

00:19:21,370 --> 00:19:22,730
We need over generalities,

00:19:22,730 --> 00:19:26,740
rather than language features to solve these particular problems.

00:19:26,740 --> 00:19:29,590
And support those experts and novices.

00:19:29,590 --> 00:19:33,050
I've been going on like this for a long time.

00:19:33,050 --> 00:19:36,710
I gave a keynote here called make simple things simple.

00:19:36,710 --> 00:19:42,482
And experts tend to want really important, clever,

00:19:42,482 --> 00:19:48,610
highly performing, sometimes specialize things.

00:19:48,610 --> 00:19:50,110
Think about the poor novices,

00:19:50,110 --> 00:19:53,260
think about yourself, who's a novice, doing

00:19:53,260 --> 00:19:57,017
the other 90% of what you're doing when you can't do your speciality.

00:19:58,120 --> 00:20:01,182
Great libraries help, they increase type safety,

00:20:01,182 --> 00:20:05,232
improve performance, and ability to work directly with hardware.

00:20:05,232 --> 00:20:07,249
Fit into the real world.

00:20:07,249 --> 00:20:10,277
[BLANK AUDIO] Academic papers are nice, but

00:20:10,277 --> 00:20:13,778
you really want to help people building real systems.

00:20:13,778 --> 00:20:19,540
And again there, change the way people think.

00:20:19,540 --> 00:20:23,380
That is where the order of magnitude improvements are lurking.

00:20:24,850 --> 00:20:27,370
Okay, and this has been going on forever.

00:20:27,370 --> 00:20:29,560
Let's see, simple things simple.

00:20:30,660 --> 00:20:34,380
In the dark ages we wrote a loop like that.

00:20:34,380 --> 00:20:38,620
Declare a variable, then give a start condition, a maximum and

00:20:38,620 --> 00:20:39,850
then increment.

00:20:39,850 --> 00:20:45,600
That's fine, except sometimes you misuse the loop variable.

00:20:45,600 --> 00:20:47,630
So found a way.

00:20:47,630 --> 00:20:52,334
Just take a loop variable into the loop things, so

00:20:52,334 --> 00:20:54,462
we can see where it is,

00:20:54,462 --> 00:20:59,503
if you don't need the value afterwards, of course.

00:20:59,503 --> 00:21:02,414
And in 2011 made another improvement.

00:21:02,414 --> 00:21:04,840
Why actually mention the loop variable?

00:21:04,840 --> 00:21:09,700
I just want to go through that contain on arrays or something, for

00:21:09,700 --> 00:21:10,730
when I want to do that,

00:21:10,730 --> 00:21:15,220
which is 90% of the time, we can just write the range for loop.

00:21:15,220 --> 00:21:17,470
So basically the assumption here is,

00:21:20,270 --> 00:21:23,680
the 2011 thing does 90% of the cases,

00:21:25,220 --> 00:21:29,280
the 83 thing does 90% of the rest of the cases, and

00:21:29,280 --> 00:21:34,100
then you are back to being able to do absolutely everything,

00:21:34,100 --> 00:21:36,440
including all the bugs you don't like.

00:21:36,440 --> 00:21:41,230
So hence, the last line there, which shows that if you can do anything,

00:21:41,230 --> 00:21:42,199
you probably will.

00:21:43,530 --> 00:21:46,010
Those are real bugs found in real programs.

00:21:47,260 --> 00:21:50,984
So when we go on about the language and

00:21:50,984 --> 00:21:55,308
think about what to do, how to improve it,

00:21:55,308 --> 00:22:00,970
there's a lot of design decisions that should be made.

00:22:00,970 --> 00:22:05,045
They're only a few of the design decisions that are really key,

00:22:05,045 --> 00:22:08,895
I tried to list them, there's still a lot of them there, but

00:22:08,895 --> 00:22:12,216
you start from the beginning, you add things on it,

00:22:12,216 --> 00:22:15,240
based on experience and all of that.

00:22:15,240 --> 00:22:19,440
Let's see, the key things here is what

00:22:19,440 --> 00:22:23,370
kind of programming is being enabled by language features?

00:22:23,370 --> 00:22:26,595
A language feature in isolation is boring,

00:22:26,595 --> 00:22:30,344
could be seen as intellectually interesting, but

00:22:30,344 --> 00:22:35,589
I think it's fundamentally boring and it's fundamentally useless.

00:22:35,589 --> 00:22:40,650
If you only had a loop.

00:22:40,650 --> 00:22:43,180
So we started in the beginning.

00:22:43,180 --> 00:22:51,240
The ropes of C++ is in the building of the user defined data types.

00:22:51,240 --> 00:22:54,520
Constructors, destructors, the weight structures and

00:22:54,520 --> 00:22:56,420
classes are the same.

00:22:56,420 --> 00:22:59,280
I decided on C compatibility for good and bad.

00:22:59,280 --> 00:23:02,920
We've got macros there, that includes trying to get rid of them

00:23:02,920 --> 00:23:08,290
ever since, but it was a decent start.

00:23:08,290 --> 00:23:11,870
It allowed me to support a user after six months.

00:23:11,870 --> 00:23:13,950
It's not a ten year project.

00:23:13,950 --> 00:23:16,900
The language is a mighty 10 year project, but

00:23:16,900 --> 00:23:19,270
getting useful result is not.

00:23:19,270 --> 00:23:20,392
About 84, 85,

00:23:20,392 --> 00:23:24,360
we could support object oriented programming as well as anybody else.

00:23:26,080 --> 00:23:30,193
And sort of modern C++ is about 88,

00:23:30,193 --> 00:23:34,720
89 when start of standardization.

00:23:34,720 --> 00:23:38,130
With the exceptions and templates, we can do RAII,

00:23:38,130 --> 00:23:40,460
we can do a bit of generic programming.

00:23:40,460 --> 00:23:43,610
And we had to figure out what generic programming really was.

00:23:43,610 --> 00:23:45,140
The STL helped.

00:23:45,140 --> 00:23:48,570
Metaprogramming comes along later, it's still too complicated,

00:23:48,570 --> 00:23:50,460
but we'll deal with that.

00:23:50,460 --> 00:23:52,960
And now, what are we doing?

00:23:52,960 --> 00:23:56,080
I'm hoping to see the type and resource safety soon.

00:23:56,080 --> 00:23:59,750
That is, a new collection of language features,

00:23:59,750 --> 00:24:03,600
that in combination deliver this kind of type and

00:24:03,600 --> 00:24:06,180
resource safety, without loss of performance.

00:24:06,180 --> 00:24:09,500
I have not forgotten this hardware, and

00:24:09,500 --> 00:24:12,545
we are getting better support for functional programming.

00:24:12,545 --> 00:24:18,710
We'll see, I put it out at beyond 2020 or thereabouts.

00:24:18,710 --> 00:24:24,360
Notice that the main decisions comes sort of, in clusters.

00:24:24,360 --> 00:24:27,274
There's one in the early 80's.

00:24:27,274 --> 00:24:30,568
And, things are happening up till 88.

00:24:30,568 --> 00:24:32,760
And, then it takes some time to learn.

00:24:32,760 --> 00:24:38,450
Things gelled in 11 again, around generic programming, and such.

00:24:38,450 --> 00:24:43,560
And, we're not there yet, for other things.

00:24:43,560 --> 00:24:45,970
So basically, one of the things I look at here,

00:24:45,970 --> 00:24:48,390
see, major changes comes in bursts.

00:24:49,390 --> 00:24:54,175
You need significant features, and then you need polishing,

00:24:54,175 --> 00:24:59,000
integration and then you can go from an idea to actually

00:24:59,000 --> 00:25:03,313
a deployed new way of writing code, a better way of writing code.

00:25:03,313 --> 00:25:07,910
And they come in bursts and it takes time to get there and

00:25:07,910 --> 00:25:09,260
then it happens.

00:25:09,260 --> 00:25:12,665
And most changes aren't major, I mean minor changes

00:25:12,665 --> 00:25:18,270
can support status quo, but you're still writing code the same old way.

00:25:18,270 --> 00:25:22,630
Minor changes can be useful ,they can be very comforting, and

00:25:22,630 --> 00:25:27,730
some minor changes are of course, necessary to support the major ones.

00:25:27,730 --> 00:25:30,000
But if you want to get to the next level,

00:25:30,000 --> 00:25:31,460
if you want to get to the next stage,

00:25:31,460 --> 00:25:36,626
if you want to make significant improvements, not 10%, not 40%.

00:25:36,626 --> 00:25:39,080
We can argue about two times and

00:25:39,080 --> 00:25:43,130
three times but usually I think, let's get some factors in there.

00:25:43,130 --> 00:25:47,580
10 is a very nice factor and I'll take two.

00:25:47,580 --> 00:25:53,360
But if we want to do that, then we have, then we need major changes.

00:25:53,360 --> 00:25:56,480
And we need major changes because we're not in the middle ages.

00:25:56,480 --> 00:25:58,480
Things are changing all the time.

00:25:58,480 --> 00:26:03,440
Our problems change, we change, and so the language has to keep up.

00:26:03,440 --> 00:26:06,745
And major change is unsettling, that is well-known.

00:26:06,745 --> 00:26:11,410
If somebody comes with a radical new feature, a radical new way of doing

00:26:11,410 --> 00:26:14,987
things, even if it can co-exist with existing code,

00:26:14,987 --> 00:26:18,585
which it always can in C++, it is still unsettling.

00:26:18,585 --> 00:26:20,559
You have to learn new things.

00:26:20,559 --> 00:26:22,390
You just thought you knew everything.

00:26:22,390 --> 00:26:25,780
You may very well have known everything about the world as it was

00:26:25,780 --> 00:26:27,440
five years ago.

00:26:27,440 --> 00:26:32,800
It's not good enough, so we need to make changes and

00:26:32,800 --> 00:26:34,880
we have to make decisions.

00:26:34,880 --> 00:26:40,510
There are close to infinite number of directions you could go in.

00:26:40,510 --> 00:26:42,310
We can't go in all of them.

00:26:42,310 --> 00:26:45,830
We can't focus the language if we don't make decisions about

00:26:45,830 --> 00:26:48,460
going roughly that way as opposed to go roughly that way.

00:26:48,460 --> 00:26:51,690
And, that's hard to do.

00:26:51,690 --> 00:26:53,845
So, here is another view of this.

00:26:53,845 --> 00:27:00,970
I think early C++ finished about 88 or 89.

00:27:00,970 --> 00:27:03,640
And those are commercial release.

00:27:03,640 --> 00:27:08,730
And it took people maybe a decade more to actually figure

00:27:08,730 --> 00:27:13,420
out how to use this, to deploy this, to support this, to get libraries,

00:27:13,420 --> 00:27:17,000
compilers, analysis tools, the works.

00:27:17,000 --> 00:27:23,070
And after that there was a slowing, there was a feature drought.

00:27:23,070 --> 00:27:31,010
We didn't get anything significantly new during this period of time.

00:27:31,010 --> 00:27:33,180
A lot of work stabilized.

00:27:33,180 --> 00:27:37,690
STL sort of saved us from really fossilizing.

00:27:39,810 --> 00:27:41,170
There was a lot of work to be done, and

00:27:41,170 --> 00:27:44,230
the alternative to C++ was improving.

00:27:44,230 --> 00:27:47,185
I think we actually didn't do enough,

00:27:47,185 --> 00:27:51,350
C++ doesn't have a sugar daddy that can give us marketing and

00:27:51,350 --> 00:27:54,120
the research dollars and development dollars.

00:27:54,120 --> 00:27:59,830
The standard's committee was working hard on stabilizing things,

00:27:59,830 --> 00:28:03,120
so we were losing traction and

00:28:03,120 --> 00:28:07,810
C++ is dead was very popular in the press.

00:28:07,810 --> 00:28:11,130
But then it always is, but it worked.

00:28:11,130 --> 00:28:15,690
So I was thinking now, why didn't this send us into a death spiral?

00:28:15,690 --> 00:28:17,510
Because you can see, I'm complaining,

00:28:17,510 --> 00:28:18,950
but the numbers are going up.

00:28:20,162 --> 00:28:25,340
I mean,they're still going up by hundreds of thousands in this area.

00:28:25,340 --> 00:28:27,150
And I'm complaining?

00:28:27,150 --> 00:28:29,770
Most people wouldn't complain if they only got another hundred

00:28:29,770 --> 00:28:31,580
thousand users.

00:28:31,580 --> 00:28:35,170
Anyway, I think there was a drop later, but

00:28:35,170 --> 00:28:39,470
the thing that saved us was the CPUs stopped getting faster.

00:28:39,470 --> 00:28:41,720
You couldn't just ignore performance.

00:28:41,720 --> 00:28:44,340
You couldn't really ignore the CRO head and

00:28:44,340 --> 00:28:46,540
the CRO head abstraction anymore.

00:28:46,540 --> 00:28:50,190
You couldn't ignore the weirdness of the hardware anymore.

00:28:50,190 --> 00:28:55,530
And that is what I think helped C++.

00:28:55,530 --> 00:28:58,760
And then 11 came along, C++ 11,

00:28:58,760 --> 00:29:02,920
which supported features that have been developed and integrated and

00:29:02,920 --> 00:29:07,850
understood in the previous decade, and we are on an upturn again.

00:29:07,850 --> 00:29:12,550
And so I would really love to know what's happening to that curve.

00:29:12,550 --> 00:29:18,060
Are we going into another stabling out,

00:29:18,060 --> 00:29:21,950
leveling out, and downtrend, or are we going to carry on for a while?

00:29:21,950 --> 00:29:24,523
I hope we are going to go carry on for a while,

00:29:24,523 --> 00:29:26,689
but we have to get some things right.

00:29:26,689 --> 00:29:32,194
We're not going to maintain that curve by doing nothing.

00:29:32,194 --> 00:29:35,509
We're not going to maintain that curve by doing nothing, we're not

00:29:35,509 --> 00:29:38,552
going to maintain that curve by doing only tiny things, okay.

00:29:38,552 --> 00:29:39,940
So, an apology.

00:29:39,940 --> 00:29:41,880
We need great libraries!

00:29:41,880 --> 00:29:45,090
The standard is now more than 50% of the standard library.

00:29:46,320 --> 00:29:49,550
I can't talk about it, just like I can't talk about the industry in

00:29:49,550 --> 00:29:51,250
general, because I don't have time.

00:29:51,250 --> 00:29:52,670
I can't talk about libraries.

00:29:52,670 --> 00:29:57,461
So, apologies, go and see the talks about libraries at this conference,

00:29:57,461 --> 00:29:57,999
right?

00:29:57,999 --> 00:29:59,235
Okay, great libraries.

00:29:59,235 --> 00:30:00,731
So, that's it.

00:30:00,731 --> 00:30:02,837
So go back.

00:30:02,837 --> 00:30:06,012
Let's see, what can we do that is significant?

00:30:06,012 --> 00:30:10,916
And how can we avoid it becoming an intellectual exercise that

00:30:10,916 --> 00:30:11,985
never ends?

00:30:11,985 --> 00:30:16,030
That's back to the philosophers, whoops.

00:30:16,030 --> 00:30:19,410
So when you ask people what's a good extension,

00:30:19,410 --> 00:30:22,530
if you talk to people about extensions, what is useful,

00:30:22,530 --> 00:30:26,820
what is needed, what should be done, you get two very distinct answers.

00:30:26,820 --> 00:30:31,120
Here is the semi-caricatured developer's point of view.

00:30:32,980 --> 00:30:36,090
I really want something that helps me with my next project or

00:30:36,090 --> 00:30:37,260
my current project.

00:30:38,510 --> 00:30:41,460
I want a very specific problem solved because this is

00:30:41,460 --> 00:30:44,930
what's bothering me, this is what I'm spending all my time on.

00:30:44,930 --> 00:30:49,160
And really, I don't have time to go and read a book.

00:30:49,160 --> 00:30:51,890
I don't have time to read an article, I'm busy, busy, busy.

00:30:51,890 --> 00:30:54,660
Don't tell me anything I don't already understand,

00:30:54,660 --> 00:30:57,540
just give me a better tool for doing it.

00:30:57,540 --> 00:31:01,036
And make it isolated, so I don't have to rethink and

00:31:01,036 --> 00:31:02,871
recheck everything else.

00:31:02,871 --> 00:31:07,450
And don't break anything, mustn't break anything, this is bad.

00:31:07,450 --> 00:31:11,445
And it should be in my compiler tomorrow, thank you.

00:31:11,445 --> 00:31:14,030
That, I hear that often.

00:31:14,030 --> 00:31:18,733
And there's a picture of sort of a typical developer that's so

00:31:18,733 --> 00:31:23,793
busy looking at his current problem that he can't see the forest for

00:31:23,793 --> 00:31:24,694
the trees.

00:31:24,694 --> 00:31:30,161
This kind of input, this kind of experience,

00:31:30,161 --> 00:31:33,530
it's genuine experience.

00:31:33,530 --> 00:31:35,620
We've all have been there, right?

00:31:35,620 --> 00:31:38,220
It's real, but it's misleading.

00:31:39,410 --> 00:31:44,920
Very often, people who go on about that lax experience with long term

00:31:44,920 --> 00:31:49,310
planning, or at least, they've never seen the results of their planning.

00:31:49,310 --> 00:31:52,880
Aims can very often be set by others.

00:31:52,880 --> 00:31:56,103
That is, people are trying to finish this project that they have

00:31:56,103 --> 00:31:56,648
no say in.

00:31:56,648 --> 00:32:00,752
And they're spending 90% of things that probably nobody should spend

00:32:00,752 --> 00:32:04,270
time on, because some bozo didn't define the problem right.

00:32:05,810 --> 00:32:10,270
And you're gonna have very short term evaluation of consequences.

00:32:10,270 --> 00:32:13,985
That is, did the product ship on time or not?

00:32:15,220 --> 00:32:16,250
That's the proof of the pudding.

00:32:17,960 --> 00:32:20,140
From the view of a programming language and

00:32:20,140 --> 00:32:24,590
the development of programming styles, that is not a good criteria.

00:32:24,590 --> 00:32:28,100
Deliver on time, focus on the details, and don't screw up.

00:32:29,300 --> 00:32:31,220
Very important not to screw up.

00:32:31,220 --> 00:32:33,670
If you have a mortgage, don't screw up.

00:32:33,670 --> 00:32:37,510
Okay, but this is not the way we can design a language.

00:32:37,510 --> 00:32:42,723
There's the other extreme here, there's the typical designer,

00:32:42,723 --> 00:32:46,140
spouting theoretical something or other.

00:32:46,140 --> 00:32:48,480
And basically,

00:32:48,480 --> 00:32:52,730
we need to help the user community over the next decade as such.

00:32:52,730 --> 00:32:55,620
And we have to address fundamental problems because

00:32:55,620 --> 00:32:58,290
that's where the fundamental improvements are.

00:32:58,290 --> 00:33:00,020
Change the way people think.

00:33:00,020 --> 00:33:03,380
I keep going on about that because it's important.

00:33:03,380 --> 00:33:07,290
Make the language more regular, therefore easier to use.

00:33:07,290 --> 00:33:12,080
Be theoretical sound, theory is a lousy guide for

00:33:12,080 --> 00:33:15,420
what to do, but it's an excellent guide for how to do it.

00:33:15,420 --> 00:33:18,810
Once you have decided what you do, you have to be sound.

00:33:18,810 --> 00:33:21,990
And improve the reputation of the language.

00:33:21,990 --> 00:33:24,590
It's not enough that you can do things in a corner, and

00:33:24,590 --> 00:33:26,680
nobody hears about it.

00:33:26,680 --> 00:33:29,720
Again, the theory and the literature can be very misleading.

00:33:29,720 --> 00:33:33,950
Just as misleading as the environment of the developer

00:33:33,950 --> 00:33:36,780
can be the environment of the designer.

00:33:36,780 --> 00:33:39,260
There's a lot of focus on novelty, if it isn't new,

00:33:39,260 --> 00:33:40,160
it can't be published.

00:33:41,860 --> 00:33:46,330
Who said that what can help us most has to be new?

00:33:46,330 --> 00:33:51,030
Most things were invented a long time ago, and we have to revise

00:33:51,030 --> 00:33:56,690
them, we have to engineer them to be useful, that's not often seen there.

00:33:56,690 --> 00:33:59,350
There's a real focus on being clever.

00:33:59,350 --> 00:34:01,310
You have to solve complicated problems.

00:34:02,580 --> 00:34:07,370
If you have a simple problem and you solve it, you don't get much credit,

00:34:07,370 --> 00:34:10,530
even if that simple problem is something that is the right royal

00:34:10,530 --> 00:34:12,270
pain in the neck to a few million people.

00:34:13,720 --> 00:34:17,190
And focus on the amount of features, again, has to be clever.

00:34:17,190 --> 00:34:21,731
And quite often, if you look at the literature, and you look at theory,

00:34:21,731 --> 00:34:24,940
I think it basically disdains every programmers.

00:34:24,940 --> 00:34:27,338
We should do things this complete new way, and

00:34:27,338 --> 00:34:31,212
just rewrite all your own code, and if the programmers are more than 32,

00:34:31,212 --> 00:34:35,049
they should be fired anyway, because they don't understand anything.

00:34:36,520 --> 00:34:39,900
There's some kind of attitude there.

00:34:39,900 --> 00:34:42,850
Obviously, my conclusion is that we need both,

00:34:42,850 --> 00:34:47,420
we need to somehow combine the everyday developer experience

00:34:47,420 --> 00:34:51,840
with a design perspective that spans years and decades.

00:34:51,840 --> 00:34:55,940
And that's a lot of ands there.

00:34:55,940 --> 00:34:59,960
And you have to keep a lot of them in your heads at the same time.

00:34:59,960 --> 00:35:03,042
You have to balance, and this is seriously hard.

00:35:03,042 --> 00:35:07,600
The C++ community is enormous.

00:35:07,600 --> 00:35:09,740
It's so easy to be parochial.

00:35:09,740 --> 00:35:13,930
All of my friends do things this way, it must be good.

00:35:13,930 --> 00:35:19,010
All of my friends have this problem, it must be solved.

00:35:19,010 --> 00:35:24,390
All of my friends like this solution, we must choose it.

00:35:24,390 --> 00:35:26,801
Okay, how many friends we got, 1,000?

00:35:26,801 --> 00:35:28,952
That's not 1%.

00:35:28,952 --> 00:35:32,188
It's about a percent of a percent.

00:35:32,188 --> 00:35:37,760
How many of us talk to 1,000 people regularly about serious things?

00:35:37,760 --> 00:35:40,940
It's really easy to be parochial, to see only

00:35:40,940 --> 00:35:44,320
what's going on just around you, or read the same magazine.

00:35:44,320 --> 00:35:48,650
And get the same kind of stuff that some journalist thought was

00:35:48,650 --> 00:35:50,500
important.

00:35:50,500 --> 00:35:58,790
And we have to work within the current C++ implementation and

00:35:58,790 --> 00:36:02,330
infrastructure because we have to consider transition.

00:36:02,330 --> 00:36:06,905
And then of course again, we have to get it right, but

00:36:06,905 --> 00:36:10,565
then we have to be able to teach it right, so

00:36:10,565 --> 00:36:14,753
that people don't write 1984 style C++.

00:36:14,753 --> 00:36:17,508
Some of us have been there and done that,

00:36:17,508 --> 00:36:22,000
some of us do not want to go back, we can do better now.

00:36:22,000 --> 00:36:26,608
Okay, more examples, I distinguish between major features and

00:36:26,608 --> 00:36:27,872
minor features.

00:36:27,872 --> 00:36:32,200
Major features are ones that have potential for major improvements,

00:36:32,200 --> 00:36:35,659
and minor ones are comforting and can help a little bit.

00:36:36,910 --> 00:36:42,160
So basically, a major is change the way we think about code.

00:36:42,160 --> 00:36:46,180
And you can have combinations that are really,

00:36:46,180 --> 00:36:47,940
really powerful and interesting.

00:36:47,940 --> 00:36:50,230
I'm not saying you don't need any minor features,

00:36:50,230 --> 00:36:51,920
that would be ridiculous.

00:36:51,920 --> 00:36:54,280
But the driver should be the major features.

00:36:54,280 --> 00:36:58,193
So, we have little separators,

00:36:58,193 --> 00:37:04,215
digit separators in C++ 11, it's very nice.

00:37:04,215 --> 00:37:06,876
Okay, we've also got auto.

00:37:08,814 --> 00:37:10,990
It's sort of borderline major minor.

00:37:10,990 --> 00:37:13,560
If you just use it to initialize a variable and so

00:37:13,560 --> 00:37:19,380
they don't have to say double for that x, it's minor.

00:37:19,380 --> 00:37:25,810
If you use it to eliminate OR typing in generic code,

00:37:26,820 --> 00:37:31,110
it's getting close to significant about how you write code.

00:37:31,110 --> 00:37:34,570
And if you get concepts, you can actually make a major,

00:37:34,570 --> 00:37:35,360
major difference.

00:37:35,360 --> 00:37:39,460
People always underestimate concepts when they haven't tried them.

00:37:39,460 --> 00:37:42,370
And so there's this range of things.

00:37:42,370 --> 00:37:47,466
And one of the problems is that people will spend as much time on

00:37:47,466 --> 00:37:53,520
the little separators as they will spend on thinking about concepts.

00:37:53,520 --> 00:37:56,575
As a matter of fact, they might think more about it because it's so

00:37:56,575 --> 00:37:59,099
much easier to think about how do you separate digits.

00:37:59,099 --> 00:38:04,203
Do you use an underscore or a dash, should we use white space?

00:38:04,203 --> 00:38:07,220
So easy, everybody can have an opinion.

00:38:07,220 --> 00:38:09,365
Everybody can have an opinion on concepts, too.

00:38:09,365 --> 00:38:13,010
But it actually takes time to have an educated opinion.

00:38:13,010 --> 00:38:16,861
So it's hard to discuss that.

00:38:16,861 --> 00:38:20,690
There's isolated versus pervasive impact.

00:38:20,690 --> 00:38:26,166
We're getting in C++ 17, inline keyword for variables, and

00:38:26,166 --> 00:38:32,690
this is very nice, from a language technical point of view feature.

00:38:32,690 --> 00:38:33,770
No new keywords,

00:38:33,770 --> 00:38:39,450
new grammar impacts, no type system impacts, no impact, and no code.

00:38:39,450 --> 00:38:42,995
And best of all, it makes it trivial for

00:38:42,995 --> 00:38:47,620
you trying to reduce global variables in headers.

00:38:47,620 --> 00:38:50,515
Some people think that's a good thing, I don't.

00:38:52,115 --> 00:38:54,400
The last thing I need is a new way for

00:38:54,400 --> 00:38:57,555
you to sneak global variables into my concurrent code.

00:38:58,765 --> 00:39:00,625
But you are going to get it.

00:39:00,625 --> 00:39:06,690
And I've read articles that it's really good for you, so be my guest.

00:39:06,690 --> 00:39:12,592
Another feature that I was trying to get into C++ is connects to genetic

00:39:12,592 --> 00:39:17,620
programming and such is I want to be able to call a function with

00:39:17,620 --> 00:39:22,963
a functional syntax or the member syntax, no impact on old code.

00:39:22,963 --> 00:39:27,303
And it eliminates the need for duplicate functions, have you seen

00:39:27,303 --> 00:39:31,520
begin and end or x.begin, which one do you want to use, why?

00:39:31,520 --> 00:39:35,089
Forwarding functions, there is a lot of forwarding functions and

00:39:35,089 --> 00:39:37,012
binders and such, be eliminated.

00:39:37,012 --> 00:39:41,162
Here's forwarding function that I found and

00:39:41,162 --> 00:39:45,640
shrunk to something that fitted on a slide.

00:39:45,640 --> 00:39:49,130
Basically, it calls foo bar with a functional syntax.

00:39:49,130 --> 00:39:54,241
I should have used the other syntax in there, foo.bar.

00:39:54,241 --> 00:39:58,931
But basically, it can simplify the way you write code and

00:39:58,931 --> 00:40:01,480
the way you design libraries.

00:40:01,480 --> 00:40:06,404
This one went down in flames Because it was too different,

00:40:06,404 --> 00:40:09,229
new, and therefore dangerous.

00:40:09,229 --> 00:40:13,367
You might get the wrong function as if you couldn't get the wrong

00:40:13,367 --> 00:40:14,519
function today.

00:40:14,519 --> 00:40:16,172
Okay, let's see,

00:40:16,172 --> 00:40:21,432
one thing we have to remember is every extension does some harm.

00:40:21,432 --> 00:40:24,220
There's people that think that you can just get new things and

00:40:24,220 --> 00:40:25,675
then everything will be happy.

00:40:25,675 --> 00:40:30,120
No, you need implementation, tool, and learning.

00:40:30,120 --> 00:40:32,924
That takes time, effort, resources.

00:40:32,924 --> 00:40:38,013
It outdates learning material, and learning material and compilers

00:40:38,013 --> 00:40:42,941
in libraries tend to last longer than you'd think, like decades.

00:40:42,941 --> 00:40:48,870
Remember that Turbo C++ compiler I get questions about?

00:40:48,870 --> 00:40:49,830
That was 20 years ago.

00:40:51,470 --> 00:40:53,230
It's still bothering people today.

00:40:54,250 --> 00:40:57,470
And you can have a poor benefit cost ratio.

00:40:58,470 --> 00:41:01,670
That is, you can have a feature that helps me.

00:41:01,670 --> 00:41:03,580
It helps all of my friends.

00:41:03,580 --> 00:41:07,130
I can demonstrate it helps 100,000 people.

00:41:07,130 --> 00:41:08,333
How can you say it's not good?

00:41:08,333 --> 00:41:16,706
Let's see, 100,000 divided by 4.5 million.

00:41:16,706 --> 00:41:23,820
This could be that you are imposing a burden on the other 90% or

00:41:23,820 --> 00:41:30,161
more of the users, that doesn't give them any benefit.

00:41:30,161 --> 00:41:39,210
And it may delay new features that are necessary for other people.

00:41:39,210 --> 00:41:43,540
It can distract from good implementation of new features.

00:41:43,540 --> 00:41:48,100
It can distract from the optimization of existing code,

00:41:48,100 --> 00:41:51,260
of porting to other machines, things like that.

00:41:51,260 --> 00:41:52,779
There's no free lunch here.

00:41:53,870 --> 00:41:58,610
And you may actually get features that makes it harder to

00:41:58,610 --> 00:42:01,290
move in a direction you'd like to move to in a future.

00:42:02,300 --> 00:42:05,230
Like I want better concurrency, and

00:42:05,230 --> 00:42:09,630
if you want global variables, they get in the way of each other.

00:42:09,630 --> 00:42:13,936
Okay, now we also have to remember that if we want

00:42:13,936 --> 00:42:18,770
absolutely 100% portability or compatibility,

00:42:18,770 --> 00:42:22,878
back to the dark ages, we have some problems.

00:42:22,878 --> 00:42:29,655
Sometimes, we have to break it, if so, break it loudly.

00:42:29,655 --> 00:42:32,700
This is static_assert, good stuff.

00:42:32,700 --> 00:42:37,410
If you feed that into an old compiler it'll tell you it's not

00:42:37,410 --> 00:42:41,280
compiling that dialect of C++.

00:42:41,280 --> 00:42:43,240
Well, use an up to date compiler.

00:42:44,670 --> 00:42:48,050
Fix the old compiler or use a compatibility switch.

00:42:48,050 --> 00:42:51,010
There will always be a backward compatibility switch

00:42:51,010 --> 00:42:52,370
in the compiler.

00:42:52,370 --> 00:42:56,700
You don't like them, you shouldn't like them, but it's a solution.

00:42:57,870 --> 00:43:03,190
There's a little change there in the meaning of auto coming up in C++ 17,

00:43:03,190 --> 00:43:07,110
unless the committee changes it mind.

00:43:09,320 --> 00:43:13,268
This will break some very rare code that think that y is

00:43:13,268 --> 00:43:16,700
an initializer list, instead of an integer.

00:43:18,360 --> 00:43:22,150
Most of that code, it could be a silent change, but

00:43:22,150 --> 00:43:27,340
how will you use that y without getting an error.

00:43:27,340 --> 00:43:30,090
If you think it's an initializer list, and

00:43:30,090 --> 00:43:34,310
the compiler thinks it's an integer.

00:43:34,310 --> 00:43:36,740
Yeah, there's code, you can construct it.

00:43:36,740 --> 00:43:38,300
I don't think there's very much of it.

00:43:38,300 --> 00:43:42,488
So basically, we have to break code sometimes to get modern

00:43:42,488 --> 00:43:45,351
code looking better, working better.

00:43:45,351 --> 00:43:52,827
Try to break it loudly, and if not hope it breaks often.

00:43:52,827 --> 00:43:55,200
Okay, I think we need a direction.

00:43:55,200 --> 00:43:58,090
That's a major point here.

00:43:58,090 --> 00:44:00,200
We can't just go in all directions.

00:44:00,200 --> 00:44:05,030
We need principles, consistency, coherence, completeness,

00:44:05,030 --> 00:44:08,600
interoperability, zero overhead, good.

00:44:08,600 --> 00:44:11,890
It's hard to do, harder than it sounds.

00:44:11,890 --> 00:44:15,890
And we need a process to help us follow those principles.

00:44:15,890 --> 00:44:19,220
It's really hard with lots of individual decisions.

00:44:20,680 --> 00:44:22,510
A standards committee for

00:44:22,510 --> 00:44:27,050
a new standard has to make thousands of individual decisions, and

00:44:27,050 --> 00:44:30,600
they can't sit around looking at philosophy all the time.

00:44:30,600 --> 00:44:33,500
But it would be nice if there was some guidance, and

00:44:33,500 --> 00:44:34,890
you need concrete examples.

00:44:34,890 --> 00:44:39,780
People are amazingly good at misunderstanding text,

00:44:39,780 --> 00:44:44,190
especially on general principals and such, so we need something.

00:44:44,190 --> 00:44:51,900
So, creating and maintaining a direction is quite difficult.

00:44:53,450 --> 00:44:57,100
Most people want a smaller language with more features.

00:44:58,500 --> 00:45:00,980
This is hard.

00:45:00,980 --> 00:45:04,585
It is actually possible to get the effect through generalization, so

00:45:04,585 --> 00:45:06,853
that there's fewer rules you have to know.

00:45:06,853 --> 00:45:11,150
Because things work more in general, but it's hard.

00:45:11,150 --> 00:45:14,690
People want stability, 100% compatibility and

00:45:14,690 --> 00:45:16,810
with significant improvements.

00:45:16,810 --> 00:45:20,770
Except for the people that just want to break the whole thing and go and

00:45:20,770 --> 00:45:21,560
do a revolution.

00:45:23,250 --> 00:45:25,870
For those, go and do your revolution elsewhere.

00:45:25,870 --> 00:45:27,280
This is an old language.

00:45:27,280 --> 00:45:30,660
It's going to be a much older language in the next 40 years.

00:45:30,660 --> 00:45:34,767
And it's going to be quite good, and we can't break the code.

00:45:34,767 --> 00:45:36,228
It's our code.

00:45:36,228 --> 00:45:39,825
It was written by our colleagues and our friends, and it's still be

00:45:39,825 --> 00:45:43,960
written by our colleagues and friends for the next decade or two.

00:45:43,960 --> 00:45:46,600
Whoa, this is good trick.

00:45:46,600 --> 00:45:53,310
And so we want stability and

00:45:53,310 --> 00:46:00,760
some directions are mutually incompatible.

00:46:00,760 --> 00:46:03,790
We can't both go that way and that way, and keep things small.

00:46:05,880 --> 00:46:09,190
We have to make sure these things combine somehow.

00:46:09,190 --> 00:46:13,840
And the standards committee has no money,

00:46:13,840 --> 00:46:17,180
no resources beyond the volunteers that do all the work, and

00:46:17,180 --> 00:46:19,780
have to pay for the privilege of doing all the work.

00:46:21,800 --> 00:46:24,930
And the more features we add the harder it is to integrate,

00:46:24,930 --> 00:46:27,910
so the amount of work increases.

00:46:27,910 --> 00:46:31,350
And then of course there are people who disagree on fundamental

00:46:31,350 --> 00:46:32,099
philosophies.

00:46:33,310 --> 00:46:36,260
Do you want implicit things in language?

00:46:36,260 --> 00:46:39,801
Do you want a very explicit syntax for everything?

00:46:39,801 --> 00:46:44,429
Do you want it simple so that you may only handle

00:46:44,429 --> 00:46:49,069
90% of the cases like the range-for loop?

00:46:49,069 --> 00:46:52,508
Or do you want everything to be fully comprehensive like

00:46:52,508 --> 00:46:55,010
the original C for loop?

00:46:55,010 --> 00:46:59,250
Then there's aesthetics, people disagree about what looks good.

00:47:00,340 --> 00:47:04,050
And then there's always a discussion about should we do things in

00:47:04,050 --> 00:47:07,170
the library or in the language.

00:47:07,170 --> 00:47:10,280
And I think C++ is a victim of its own success.

00:47:10,280 --> 00:47:12,070
Everybody wants to help.

00:47:12,070 --> 00:47:14,650
The standards committee is bigger than it ever way,

00:47:14,650 --> 00:47:19,490
more active than ever was, and I think the individual technical

00:47:19,490 --> 00:47:23,570
expertise of people in the committee is higher than it ever was.

00:47:23,570 --> 00:47:26,400
But it's really hard to be coherent.

00:47:26,400 --> 00:47:29,730
A lot of people come with totally different background, and

00:47:29,730 --> 00:47:33,130
doesn't appreciate that other people have different backgrounds,

00:47:33,130 --> 00:47:34,850
different concerns.

00:47:34,850 --> 00:47:41,118
And a lot people have not internalized

00:47:41,118 --> 00:47:45,505
the C++ process,

00:47:45,505 --> 00:47:49,720
where the language is going and why.

00:47:49,720 --> 00:47:52,220
And then of course there's people who's been there for

00:47:52,220 --> 00:47:54,680
a long time, spend all the time

00:47:54,680 --> 00:47:57,430
trying to rehash what we should have done ten years ago.

00:47:59,450 --> 00:48:00,650
Well that was ten years ago.

00:48:00,650 --> 00:48:02,750
We can't do much about it today.

00:48:02,750 --> 00:48:09,170
And so we have a long series of separate decisions quite often

00:48:09,170 --> 00:48:14,020
done by people who hasn't been in the room with the other decisions.

00:48:14,020 --> 00:48:16,010
And it's hard to be coherent.

00:48:16,010 --> 00:48:20,230
And sometimes people come in the last minute and says,

00:48:20,230 --> 00:48:22,200
we can't do this, this is horrible.

00:48:23,460 --> 00:48:26,230
And says, we've discussed it for three years.

00:48:26,230 --> 00:48:29,680
Well I wasn't there, why didn't you tell me?

00:48:29,680 --> 00:48:32,610
Well, we did tell you, but it drowned in the details,

00:48:32,610 --> 00:48:34,090
the mass of information.

00:48:34,090 --> 00:48:37,910
There's more than 100 papers coming for every standards meeting.

00:48:37,910 --> 00:48:40,740
Not everybody can eat, read all of those and understand it,

00:48:40,740 --> 00:48:41,940
and contribute.

00:48:41,940 --> 00:48:47,112
This is hard, and but now it's not really designed by a committee,

00:48:47,112 --> 00:48:49,582
it's designed by committees.

00:48:49,582 --> 00:48:50,743
There are subcommittees.

00:48:50,743 --> 00:48:53,451
There's people that never actually spent

00:48:53,451 --> 00:48:56,360
time discussing the features together.

00:48:56,360 --> 00:48:58,139
This is very difficult.

00:48:58,139 --> 00:49:00,061
Anyway, we should thank the committee.

00:49:00,061 --> 00:49:02,260
It's done a good job over the years.

00:49:03,460 --> 00:49:06,650
There is a very tired committee down at the bottom,

00:49:06,650 --> 00:49:09,746
just after voting out C++14.

00:49:09,746 --> 00:49:14,774
I think they might be voting up the top slide there.

00:49:14,774 --> 00:49:19,158
And the final thing is where people do a lot of the real work which is

00:49:19,158 --> 00:49:23,242
in the working groups, and notice all the computers there.

00:49:23,242 --> 00:49:26,444
Everybody is sitting there doing their various things

00:49:26,444 --> 00:49:30,870
in communicating with their friends in other countries and such.

00:49:30,870 --> 00:49:33,740
If you go into a room in the standards committee,

00:49:33,740 --> 00:49:37,139
you see 15 people sitting around the table.

00:49:38,450 --> 00:49:43,325
There's probably 30 people in the room, because they communicate.

00:49:43,325 --> 00:49:48,902
Okay, one of the examples here, why should complex

00:49:48,902 --> 00:49:53,732
be in the library and and not in the language?

00:49:53,732 --> 00:49:58,620
Why should a range-for be mostly in the language and not in the library?

00:49:58,620 --> 00:50:02,480
There's a whole set of decisions there that actually are not that

00:50:02,480 --> 00:50:03,189
hard to do.

00:50:03,189 --> 00:50:07,160
Sorry, not that easy to do.

00:50:07,160 --> 00:50:11,675
This is a discussion that you can have for every single feature.

00:50:11,675 --> 00:50:17,550
C++ is powerful enough that most things can be done in a library and

00:50:17,550 --> 00:50:20,159
especially if you put in a few intrinsics.

00:50:21,300 --> 00:50:25,610
When you do that, you can sometimes deploy it early, which is good.

00:50:25,610 --> 00:50:30,310
And you increase the compile time, this can be very bad, so

00:50:30,310 --> 00:50:32,660
we need to deal with that.

00:50:32,660 --> 00:50:35,810
Here's a simplification thing showing how things work

00:50:35,810 --> 00:50:37,080
over the years.

00:50:37,080 --> 00:50:44,900
So in 98 or thereabouts we started using things like pair.

00:50:44,900 --> 00:50:48,590
And we have to say a pair of what and initialize it.

00:50:48,590 --> 00:50:53,240
With 11, we say make pair, and it'll deduce the right types.

00:50:53,240 --> 00:50:56,190
And we can use auto, so that we don't have to sit and

00:50:56,190 --> 00:50:58,200
repeat ourselves so much.

00:50:58,200 --> 00:51:02,290
And in 17, we will be able to have the template

00:51:02,290 --> 00:51:05,520
documents deduced from the initializer.

00:51:05,520 --> 00:51:09,930
Cool stuff, so, progress happens at the smart more level.

00:51:09,930 --> 00:51:14,110
This is the kind of simplification that where we'll help people.

00:51:14,110 --> 00:51:16,430
It'll also confuse people who read old code and

00:51:16,430 --> 00:51:20,820
can't understand what the new code is doing or get used to the new code

00:51:20,820 --> 00:51:24,320
and get confused about what the old code is doing.

00:51:24,320 --> 00:51:27,900
You can't actually have changed without some cost.

00:51:29,760 --> 00:51:34,220
A direction, I think we should talk more about the future.

00:51:34,220 --> 00:51:39,219
It would be nice if people agreed on a list of things we

00:51:39,219 --> 00:51:42,866
would like to see in five to ten years.

00:51:42,866 --> 00:51:47,458
And it would be nice if people had an agreement about roughly what we

00:51:47,458 --> 00:51:51,150
would like for an extender in the three year horizon.

00:51:53,760 --> 00:51:56,537
We are not having those discussions,

00:51:56,537 --> 00:51:59,780
we are not having those lists that's bad.

00:51:59,780 --> 00:52:04,030
Most people don't articulate their aims, I do but

00:52:04,030 --> 00:52:06,620
often people fall asleep and don't read them.

00:52:06,620 --> 00:52:09,660
And we should be explicit about this,

00:52:09,660 --> 00:52:11,730
we should be articulate about it.

00:52:11,730 --> 00:52:15,520
We can't spend all our time discussing the details.

00:52:15,520 --> 00:52:17,290
And that's what I feel what we do, and

00:52:17,290 --> 00:52:20,290
furthermore, the last one is very controversial.

00:52:20,290 --> 00:52:22,620
I want to integrate things early.

00:52:22,620 --> 00:52:26,340
I want to see it in the standup document together with the other

00:52:26,340 --> 00:52:34,090
things, so that we know that things work together or not.

00:52:34,090 --> 00:52:37,970
Lot of people want to delay things until they're perfect.

00:52:37,970 --> 00:52:38,890
Remember Voltaire?

00:52:40,080 --> 00:52:41,370
Best is the enemy of the good.

00:52:42,500 --> 00:52:43,960
So some philosophy.

00:52:43,960 --> 00:52:48,170
We will make errors, in language design,

00:52:48,170 --> 00:52:50,740
like in program design and such.

00:52:50,740 --> 00:52:52,690
So let's get them made.

00:52:52,690 --> 00:52:57,130
I'm for early integration, I'm for moving ahead.

00:52:57,130 --> 00:53:01,250
We know we are going to make mistakes anyways, so

00:53:01,250 --> 00:53:02,610
let's get used to it.

00:53:02,610 --> 00:53:05,680
And we should maximize our successes,

00:53:05,680 --> 00:53:07,910
we shouldn't just minimize failures.

00:53:07,910 --> 00:53:10,410
Of course we don't want failures, but we are going to make mistakes

00:53:10,410 --> 00:53:12,190
anyway, so let's make them and fix them.

00:53:13,430 --> 00:53:17,880
Any change carries risk, including not doing anything.

00:53:19,140 --> 00:53:22,690
And we have to be confident.

00:53:22,690 --> 00:53:26,590
I think we're getting too nervous that we might make mistakes.

00:53:26,590 --> 00:53:29,720
Forgetting, one, we do make mistakes, and

00:53:29,720 --> 00:53:35,190
two, in the past, most of the time we were able to fix it.

00:53:35,190 --> 00:53:36,460
Before it was shipped, or

00:53:36,460 --> 00:53:42,900
before it was significantly impacting the community.

00:53:42,900 --> 00:53:45,350
Look, if your library writer or compiler writer,

00:53:45,350 --> 00:53:47,340
it hurts them to back up something.

00:53:47,340 --> 00:53:52,770
It hurts when something breaks but that's life, and

00:53:52,770 --> 00:54:01,110
it, if we have to move on, we have to take some chances.

00:54:01,110 --> 00:54:06,990
And one thing people do a lot, is to confuse familiarity with simplicity.

00:54:06,990 --> 00:54:10,060
If it looks the way I'm used to it,

00:54:10,060 --> 00:54:13,170
it's simple, is many people's definition.

00:54:13,170 --> 00:54:15,010
No it's not, it's familiar.

00:54:15,010 --> 00:54:20,360
It may be simple You have to go for

00:54:20,360 --> 00:54:23,240
simplicity especially on major things.

00:54:23,240 --> 00:54:30,880
So, a problem we have is that we can't actually explain what C++ is.

00:54:30,880 --> 00:54:33,760
And if we can't characterize what C++ is,

00:54:33,760 --> 00:54:36,200
how can we explain what it should become.

00:54:38,200 --> 00:54:40,770
We have to have some kind of agreement what it is.

00:54:40,770 --> 00:54:44,100
I have my suggestions, it's a language for defining and

00:54:44,100 --> 00:54:46,260
using light weight abstractions.

00:54:46,260 --> 00:54:49,560
It's aimed primarily at software infrastructure and

00:54:49,560 --> 00:54:51,430
resource constrained applications.

00:54:52,910 --> 00:54:55,670
We have long papers explaining what that means.

00:54:57,390 --> 00:54:58,370
Who is the language for?

00:54:59,650 --> 00:55:06,270
Meaning it is not for people who want to do a quick webpage.

00:55:06,270 --> 00:55:09,960
It's, I use the phrase serious programmers

00:55:09,960 --> 00:55:14,490
in the first edition of the C++ programming language.

00:55:14,490 --> 00:55:18,396
It's actually the first sentence of the first edition.

00:55:18,396 --> 00:55:24,480
I use serious, I edited out professional

00:55:24,480 --> 00:55:29,400
slightly early because I realized some of the amateurs were better.

00:55:29,400 --> 00:55:32,540
But people it takes the act of generating good code,

00:55:32,540 --> 00:55:36,580
or writing good code, or maintaining code that's serious.

00:55:36,580 --> 00:55:38,750
And that's what C++ is for.

00:55:38,750 --> 00:55:42,920
It's less for casual programmers, unfortunately.

00:55:42,920 --> 00:55:47,950
There's a lot of those, they do real good C++ at times, but only

00:55:47,950 --> 00:55:52,631
if the serious ones get there tools and libraries in such in place.

00:55:53,830 --> 00:55:56,440
And what would make the language better?

00:55:57,580 --> 00:56:01,020
We have to specify what it means to be better.

00:56:01,020 --> 00:56:05,060
You've seen some suggestions in this talk and in writings but

00:56:05,060 --> 00:56:09,080
we have to be specific to make forward.

00:56:09,080 --> 00:56:13,550
And so, we can't please everybody we'll maintain the direct map to

00:56:13,550 --> 00:56:16,220
hardware, the zero-overhead abstraction.

00:56:18,240 --> 00:56:21,490
Language is primarily industrial.

00:56:21,490 --> 00:56:26,300
We'll never get it pretty enough for every professor to like it for

00:56:26,300 --> 00:56:27,900
teaching freshman.

00:56:27,900 --> 00:56:31,490
I've taught freshman, to thousands of them, can be done.

00:56:31,490 --> 00:56:33,618
It's not even that hard but you have to do it right.

00:56:33,618 --> 00:56:38,290
What primarily C++ is there because we can build

00:56:38,290 --> 00:56:39,529
good systems for people.

00:56:40,930 --> 00:56:42,910
And then it rewards good programmers.

00:56:44,270 --> 00:56:47,780
If you are a good programmer you shouldn't be stopped from doing

00:56:47,780 --> 00:56:49,070
good stuff.

00:56:49,070 --> 00:56:50,550
We should make it simpler for

00:56:50,550 --> 00:56:55,420
a good programmer to do good stuff in areas we don't know.

00:56:56,830 --> 00:56:58,810
In application areas we don't know.

00:57:00,020 --> 00:57:02,360
In application domains we have never heard of.

00:57:03,700 --> 00:57:04,320
It's good.

00:57:04,320 --> 00:57:07,710
It would be really nice if we had a buzz word for saying this.

00:57:09,030 --> 00:57:10,852
I don't, I'm sorry.

00:57:10,852 --> 00:57:15,530
And everytime I've tried to find out good words I've learned why

00:57:15,530 --> 00:57:18,235
I shouldn't be in marketing.

00:57:18,235 --> 00:57:19,770
>> [LAUGH] >> Now, let's try and

00:57:19,770 --> 00:57:21,593
look ahead a little bit.

00:57:21,593 --> 00:57:28,540
My high-level aims was first C++17 and beyond.

00:57:28,540 --> 00:57:30,150
Now they're just for C++.

00:57:30,150 --> 00:57:33,810
Let's not put a specific time scale on this.

00:57:33,810 --> 00:57:37,298
Improve support for large-scale dependable software.

00:57:37,298 --> 00:57:39,774
Support higher-level concurrency.

00:57:39,774 --> 00:57:44,690
Everything is getting concurrent, so let's support it well.

00:57:44,690 --> 00:57:46,700
Simplify the core language use,

00:57:46,700 --> 00:57:50,585
you can't simplify the core language that can break your code.

00:57:50,585 --> 00:57:55,378
We can simplify it's use, ranges also when things like that can

00:57:55,378 --> 00:58:00,705
simplify range for also things like that can simplify your code and then

00:58:00,705 --> 00:58:06,140
we have to address the major sources of errors that can be through tools.

00:58:06,140 --> 00:58:09,030
It can be through coding guidelines

00:58:09,030 --> 00:58:12,420
It can be through language features and libraries.

00:58:12,420 --> 00:58:14,108
Preserve the fundamental strength.

00:58:14,108 --> 00:58:15,570
C++ has to remain C++.

00:58:15,570 --> 00:58:19,392
If you want something that's fundamentally different from C++,

00:58:19,392 --> 00:58:20,340
go get it.

00:58:20,340 --> 00:58:24,530
C++ is not for everything and for everybody, we know that.

00:58:24,530 --> 00:58:26,090
But don't abandon the past.

00:58:27,260 --> 00:58:30,150
Don't get stuck in the past and

00:58:30,150 --> 00:58:34,430
awards more feature creep because there's so much stuff there.

00:58:34,430 --> 00:58:38,210
So there was my top ten list for

00:58:38,210 --> 00:58:43,340
17 as presented I think in February last year.

00:58:43,340 --> 00:58:45,040
And I was very optimistic.

00:58:45,040 --> 00:58:47,460
I thought we were going to get concepts.

00:58:47,460 --> 00:58:52,820
I thought modules were so far advanced that It would be a stretch.

00:58:52,820 --> 00:58:54,850
Goldberg might be able to get it.

00:58:54,850 --> 00:58:56,680
There was a range library.

00:58:56,680 --> 00:59:00,780
It was marginally, might get it.

00:59:00,780 --> 00:59:04,690
Uniform syntax, code things, the shipping networking,

00:59:04,690 --> 00:59:08,390
it's been shipping, contracts, yeah, stretch goal.

00:59:09,740 --> 00:59:14,660
SIMD vector and parallel algorithms that is going well.

00:59:14,660 --> 00:59:18,120
Library, vocabulary type, optional variance string span span,

00:59:18,120 --> 00:59:22,570
yeah it's going in a magic stack array type because stacks are really

00:59:22,570 --> 00:59:26,630
useful things and it would be nice to have proper arrays on them.

00:59:26,630 --> 00:59:30,780
And, well, I learned the hard way it's hard to make predictions.

00:59:30,780 --> 00:59:31,960
Especially about the future.

00:59:32,980 --> 00:59:36,440
We only got the two things that are pointed to there and only partially.

00:59:37,440 --> 00:59:39,390
And all the rest is postponed.

00:59:40,460 --> 00:59:44,030
That's sad about that.

00:59:44,030 --> 00:59:49,450
Here's what you actually get and here's a list.

00:59:49,450 --> 00:59:55,578
And the problem is that all of that basically is in the minor category.

00:59:55,578 --> 01:00:00,813
A lot of minor improvements can add up to something significant if we,

01:00:00,813 --> 01:00:04,540
well Most of these will help somebody in some way so

01:00:04,540 --> 01:00:08,260
there's something for everyone here.

01:00:08,260 --> 01:00:14,190
I can't imagine any C++ programmer that will not have at least some

01:00:14,190 --> 01:00:20,480
relief from pain in C++17, that will not be able to write

01:00:20,480 --> 01:00:26,010
some piece of their code better in C++17.

01:00:26,010 --> 01:00:30,640
So what I'm concerned about is that we are not moving fast enough and

01:00:30,640 --> 01:00:32,530
we're focusing on too small things.

01:00:33,600 --> 01:00:37,690
And let's see a library features, well,

01:00:37,690 --> 01:00:40,500
it's not a library talk so I'm not going to go into that.

01:00:40,500 --> 01:00:42,535
We're finally getting the file systems and

01:00:42,535 --> 01:00:43,857
parallelism kind of stuff.

01:00:46,399 --> 01:00:51,406
Okay, so what do I think now after the last year or so?

01:00:51,406 --> 01:00:56,277
For C++20, and hopefully available before 20,

01:00:56,277 --> 01:01:03,115
I would like everything C++17, and I would like my C++17 list because

01:01:03,115 --> 01:01:08,755
it still reflects the way I think the language ought to be going.

01:01:08,755 --> 01:01:13,480
And operator dot, I want smart references, finally.

01:01:13,480 --> 01:01:17,830
They were about the first extension proposed at the first meet,

01:01:17,830 --> 01:01:22,610
second meeting of the C++ standards committee back in the dark ages.

01:01:22,610 --> 01:01:24,480
I think we finally know how to do it.

01:01:24,480 --> 01:01:28,240
Before comparisons, it was rejected by the standards group.

01:01:28,240 --> 01:01:30,235
I think they got it wrong.

01:01:30,235 --> 01:01:38,550
And, beyond that, there are things we need to look into.

01:01:38,550 --> 01:01:40,810
We could use a packet manager.

01:01:40,810 --> 01:01:44,806
We could use a standardized representation of C++ source code

01:01:44,806 --> 01:01:47,570
that we could use for tool building.

01:01:47,570 --> 01:01:53,210
IPR is something that Gabriel Dos Reis and I did a few years ago.

01:01:54,580 --> 01:01:58,180
It's a general representation of a language for

01:01:58,180 --> 01:02:03,220
the superset of C++, fully typed, minimal in all possible ways.

01:02:03,220 --> 01:02:06,160
It would be lovely if we would get something like that.

01:02:06,160 --> 01:02:08,022
There's work on static reflection.

01:02:08,022 --> 01:02:10,410
I would like to see that come in.

01:02:10,410 --> 01:02:13,610
I've been experimenting with functional programming style

01:02:13,610 --> 01:02:14,960
pattern matching.

01:02:14,960 --> 01:02:19,500
So we could finally get safe use of unions and such,

01:02:19,500 --> 01:02:23,660
part of this idea of making things simpler and making them safer.

01:02:24,700 --> 01:02:28,290
And high levels of concurrency support, I'm not going to be

01:02:28,290 --> 01:02:32,303
specific there but I don't want to fiddle with new texts and

01:02:32,303 --> 01:02:36,140
worrying about data raisers and such.

01:02:36,140 --> 01:02:37,152
We can do better.

01:02:37,152 --> 01:02:43,060
And then I feel that we are diluting the effort.

01:02:43,060 --> 01:02:45,040
We have 100, 200 people in committee.

01:02:45,040 --> 01:02:48,620
We have 1,000 people in the community that contributes.

01:02:48,620 --> 01:02:49,360
If we don't watch out,

01:02:49,360 --> 01:02:53,910
we'll get nothing because we are all over the place.

01:02:53,910 --> 01:02:56,819
And if you look at this list,

01:02:56,819 --> 01:03:01,792
I did not expect I'd get everything in 17, but

01:03:01,792 --> 01:03:07,390
I expected I'll get something, and this is not much.

01:03:07,390 --> 01:03:12,330
If this has been a project, whether we have a project management and

01:03:12,330 --> 01:03:17,830
such, we would have shipped a couple of the major things and

01:03:17,830 --> 01:03:23,740
you would have been busy learning about it and upgrading your code.

01:03:23,740 --> 01:03:25,760
As it is now, it's harder.

01:03:25,760 --> 01:03:27,590
It's lack of focus that does it.

01:03:27,590 --> 01:03:29,790
So, what do we do now?

01:03:29,790 --> 01:03:30,668
We'd have to get ready.

01:03:30,668 --> 01:03:34,240
Upgrade to C++14 if you haven't already.

01:03:35,340 --> 01:03:37,430
Lots of places have upgraded to 11.

01:03:37,430 --> 01:03:40,350
It's easier to upgrade from 11 to 14.

01:03:40,350 --> 01:03:40,970
This is good.

01:03:40,970 --> 01:03:46,060
If you're still stuck in '98, either mindset or compilers, upgrade.

01:03:46,060 --> 01:03:51,730
It's the best of getting ready for

01:03:51,730 --> 01:03:55,910
the future, is at least get to the present.

01:03:55,910 --> 01:04:00,040
Furthermore, your code will run faster.

01:04:00,040 --> 01:04:03,780
If you compile with a modern compiler, you will be able to

01:04:03,780 --> 01:04:07,380
run faster because you'll target modern architectures,

01:04:07,380 --> 01:04:11,390
instead of using the backward compatibility features of your CPUs.

01:04:13,100 --> 01:04:17,380
Upgrading from an old compiler is a good way of finding bugs and

01:04:17,380 --> 01:04:18,200
to run faster.

01:04:19,260 --> 01:04:23,080
And try out the TSs.

01:04:23,080 --> 01:04:25,300
I mean you can get concepts.

01:04:26,310 --> 01:04:28,442
Ranges are there to download news.

01:04:28,442 --> 01:04:32,313
The networking library has been in production use, in many places, for

01:04:32,313 --> 01:04:33,460
the last five years.

01:04:33,460 --> 01:04:35,050
It's great.

01:04:35,050 --> 01:04:39,910
Coroutines are shipping, mostly by Microsoft but

01:04:39,910 --> 01:04:42,220
I hear there's a Clang implementation also.

01:04:42,220 --> 01:04:46,200
Try them, you can do some really cool pipelining very,

01:04:46,200 --> 01:04:48,520
very fast, and you can do it today.

01:04:49,580 --> 01:04:50,960
Modules, they're coming.

01:04:50,960 --> 01:04:52,660
There's talks about them at this conference.

01:04:52,660 --> 01:04:53,660
This is good.

01:04:53,660 --> 01:04:57,190
And then I'm still working on the core guidelines that we announced

01:04:57,190 --> 01:04:58,010
last year.

01:04:58,010 --> 01:04:58,780
They've improved.

01:04:58,780 --> 01:04:59,440
I'll get to that.

01:04:59,440 --> 01:05:01,160
Improve them and improve tool support.

01:05:01,160 --> 01:05:03,755
So let's go over concepts.

01:05:03,755 --> 01:05:09,343
So technical specification, it's shipping GCC 6.1.

01:05:09,343 --> 01:05:13,616
The most important thing about concept is that you

01:05:13,616 --> 01:05:18,397
can improve your specification of your generic code and

01:05:18,397 --> 01:05:23,685
you can get simpler generic code, like you can do overloading

01:05:23,685 --> 01:05:28,077
based on concepts rather than writing an.

01:05:28,077 --> 01:05:31,974
And you can get better error messages and, by the way,

01:05:31,974 --> 01:05:35,470
compiles faster than the alternatives.

01:05:35,470 --> 01:05:38,180
And so basically I want to see code

01:05:38,180 --> 01:05:40,299
that says I want to sort anything that's sortable.

01:05:41,670 --> 01:05:44,860
And so, if I sort a vector it's sortable.

01:05:44,860 --> 01:05:46,070
What does sortable mean?

01:05:46,070 --> 01:05:48,390
Definition is over there somewhere.

01:05:48,390 --> 01:05:52,540
It is a sequence that is random access

01:05:52,540 --> 01:05:55,070
with elements you can compare with less than.

01:05:56,540 --> 01:05:58,430
Okay, translate that into C++.

01:05:58,430 --> 01:06:01,320
It's four lines and you're done.

01:06:01,320 --> 01:06:04,260
By the way, you cannot sort the list.

01:06:04,260 --> 01:06:06,450
Why not? The standard says so.

01:06:06,450 --> 01:06:10,510
It says that the list is not a random access sequence.

01:06:10,510 --> 01:06:14,250
And so the error messages will tell you that it's not sortable, and

01:06:14,250 --> 01:06:17,900
it will tell you that it is not random accessible and

01:06:17,900 --> 01:06:22,140
it's not random accessible because it doesn't have soft grade plus.

01:06:22,140 --> 01:06:25,790
There's been some discussions about the quality of the error messages.

01:06:25,790 --> 01:06:28,204
Some people want more, some people want less.

01:06:28,204 --> 01:06:32,060
I've forgotten what they're shipping in 6.1.

01:06:32,060 --> 01:06:34,230
It used to be that there was a switch, so

01:06:34,230 --> 01:06:35,690
that you can say how much you wanted.

01:06:35,690 --> 01:06:37,830
I always wanted less, and

01:06:37,830 --> 01:06:42,060
a certain who wrote that compiler always wanted more.

01:06:42,060 --> 01:06:45,911
It seems that people these days out in the community usually wants more.

01:06:45,911 --> 01:06:48,300
They'll get over that.

01:06:48,300 --> 01:06:52,350
Once you learn to use the concepts and know the concepts,

01:06:52,350 --> 01:06:53,300
you'll want less.

01:06:53,300 --> 01:06:55,270
I want that switch back.

01:06:55,270 --> 01:06:58,720
Concept design can be used in the comments.

01:06:58,720 --> 01:07:03,465
You can actually design your code around concepts.

01:07:03,465 --> 01:07:08,670
You could actually design your code and

01:07:08,670 --> 01:07:13,670
test it out on the Microsoft compiler commented out.

01:07:13,670 --> 01:07:18,000
No, sorry, not the Microsoft, the clue compiler, and

01:07:18,000 --> 01:07:20,720
then port it to whichever compiler you're using.

01:07:20,720 --> 01:07:22,510
Just put a comments in place.

01:07:22,510 --> 01:07:26,290
And when the other compilers catch up, take the comments away.

01:07:26,290 --> 01:07:29,005
And you can use the concepts from the ranges, TS.

01:07:29,005 --> 01:07:29,980
There's a good set.

01:07:29,980 --> 01:07:31,470
You don't have to start from scratch.

01:07:34,230 --> 01:07:36,890
Then we are going to get modules.

01:07:36,890 --> 01:07:38,230
Almost certainly.

01:07:38,230 --> 01:07:40,390
And this is the way we write code today.

01:07:41,830 --> 01:07:46,677
We include some files and then we use them.

01:07:46,677 --> 01:07:53,296
And there's some data I got from Gabriel Dos Reis.

01:07:53,296 --> 01:08:00,840
There is 176 bytes of text that you wrote to get this little example.

01:08:00,840 --> 01:08:05,234
It becomes 400 plus kilobyte GCC,

01:08:05,234 --> 01:08:11,940
just over a megabyte with Clang, or Visual C++.

01:08:11,940 --> 01:08:14,960
Now, our compilers are very,

01:08:14,960 --> 01:08:20,300
very clever to actually ever get finished with all of that text.

01:08:20,300 --> 01:08:23,770
And that was only one file.

01:08:25,140 --> 01:08:28,620
You're going to include that stuff 100 times and

01:08:28,620 --> 01:08:30,550
it's going to be bigger.

01:08:30,550 --> 01:08:33,010
We are simply going to radically

01:08:33,010 --> 01:08:37,520
decrease the amount of data processed by the compiler.

01:08:37,520 --> 01:08:40,710
This ought to give significant improvements in compile time.

01:08:42,310 --> 01:08:44,080
I don't have any numbers unfortunately.

01:08:45,100 --> 01:08:49,650
To use it, you need better code hygiene.

01:08:49,650 --> 01:08:54,250
If you have undisciplined macro usage,

01:08:54,250 --> 01:08:58,670
you're not going to get that much advantage, because if you have old

01:08:58,670 --> 01:09:02,860
code, and you demand your compiler does the old way of doing things,

01:09:02,860 --> 01:09:05,220
you're going to get the old performance.

01:09:05,220 --> 01:09:11,310
So some cleanup would be necessary, but once you've worked this in,

01:09:11,310 --> 01:09:14,500
get code hygiene, get fast compilation you just import

01:09:14,500 --> 01:09:19,690
the libraries and

01:09:19,690 --> 01:09:24,530
then you use them to write a module.

01:09:24,530 --> 01:09:28,100
It's not rocket science, you can introduce it gradually.

01:09:28,100 --> 01:09:30,650
Have some stuff that usually includes on the macros,

01:09:30,650 --> 01:09:33,110
have some stuffs that encapsulate it,

01:09:33,110 --> 01:09:35,600
have some stuff that doesn't use it any more.

01:09:35,600 --> 01:09:38,350
And, basically, it's based on two keywords.

01:09:38,350 --> 01:09:42,130
One for getting things in, and one for saying you want to get it out.

01:09:42,130 --> 01:09:44,020
There's lots of details, of course.

01:09:44,020 --> 01:09:47,120
There's at least three talks at this conference that'll

01:09:47,120 --> 01:09:50,290
tell you about the details, so I'm not going to do it here.

01:09:50,290 --> 01:09:52,630
I'm just going to say we have to hope for

01:09:52,630 --> 01:09:55,100
simpler code that compiles faster.

01:09:55,100 --> 01:10:00,596
And if you compile it with things like concepts, it gets even faster,

01:10:00,596 --> 01:10:04,615
it gets better error messages, and cleaner code.

01:10:04,615 --> 01:10:08,922
We're working on a contract, it's simply a proposal now,

01:10:08,922 --> 01:10:14,050
we're working about it, it's sort of assert on steroids.

01:10:14,050 --> 01:10:18,230
And it's selectively enabled at runtime, so you can say

01:10:18,230 --> 01:10:22,020
preconditions, expect latter thing if the queue is not full.

01:10:23,090 --> 01:10:27,390
Post conditions, it make sure that once you have push something

01:10:27,390 --> 01:10:30,250
on to the queue it's no longer empty and

01:10:30,250 --> 01:10:32,050
you can have assertions in your code.

01:10:33,678 --> 01:10:38,260
So, that simply standardizes what a lot of people are doing

01:10:38,260 --> 01:10:41,020
with special code on macros and such.

01:10:41,020 --> 01:10:44,082
And there will be three levels of contracts you

01:10:44,082 --> 01:10:47,625
can argue whether it should be two, three, or four.

01:10:47,625 --> 01:10:49,000
Currently it is three.

01:10:50,520 --> 01:10:55,190
Basically audit, which is big expensive tech checks,

01:10:55,190 --> 01:10:58,070
default, which is relatively cheap check,

01:10:58,070 --> 01:11:03,810
checks relatively to the algorithm that's being done.

01:11:03,810 --> 01:11:08,900
And action, which is basically not checked at compile time.

01:11:08,900 --> 01:11:10,050
You can write things like that.

01:11:11,140 --> 01:11:13,662
And we're going to get something called structured binding.

01:11:13,662 --> 01:11:16,800
This was voted into C++ 17.

01:11:16,800 --> 01:11:20,410
It's coming in compilers right now.

01:11:20,410 --> 01:11:25,295
We'll probably be told this week whether it is shipping in Clang.

01:11:25,295 --> 01:11:29,030
I think it either is or is close.

01:11:29,030 --> 01:11:31,980
Basically it can give local names to struct members, so

01:11:31,980 --> 01:11:36,980
when you call something like a map insert that returns a pair,

01:11:36,980 --> 01:11:38,550
you can break out the pair.

01:11:38,550 --> 01:11:43,220
The one is an iterator and the other one is a success indicator.

01:11:43,220 --> 01:11:47,370
And so you can write code like that.

01:11:47,370 --> 01:11:48,570
One of the things it does,

01:11:48,570 --> 01:11:52,940
is work nicely with the range for loop things.

01:11:52,940 --> 01:11:55,040
So you can go through the map and

01:11:55,040 --> 01:11:58,710
for each element break out the key and the value and do things with it.

01:11:59,730 --> 01:12:02,010
Very nice, very nice stuff.

01:12:02,010 --> 01:12:06,990
And then the kicker here is that

01:12:06,990 --> 01:12:09,440
we design things to work in combination.

01:12:10,810 --> 01:12:15,130
If we didn't do that every feature would bloat by itself.

01:12:15,130 --> 01:12:17,610
And there would be tremendous overlap in the language.

01:12:17,610 --> 01:12:19,200
There's already enough overlap

01:12:19,200 --> 01:12:20,470
between the features in the language.

01:12:20,470 --> 01:12:23,319
But these things can work together, so I want to write that code.

01:12:24,490 --> 01:12:28,140
I import, I O-stream, namespace, I have a map printer, I

01:12:28,140 --> 01:12:33,000
write some code, it has concepts in it, it has structure bindings in it.

01:12:35,280 --> 01:12:36,130
I can't do it.

01:12:37,610 --> 01:12:43,760
Modules are shipping by Microsoft, concepts are shipping by GCC,

01:12:43,760 --> 01:12:46,570
and structured bindings are shipping in Clang.

01:12:46,570 --> 01:12:49,020
I will be really happy

01:12:49,020 --> 01:12:52,740
when I can get all three in all three compilers,

01:12:52,740 --> 01:12:56,800
because I happen to work in a place that uses all three compilers.

01:12:58,310 --> 01:13:01,910
I'm an optimist, people can tell me, will I get it next year?

01:13:03,210 --> 01:13:03,710
I hope so.

01:13:05,720 --> 01:13:08,350
Okay, again, thanks.

01:13:08,350 --> 01:13:10,560
We couldn't do it without a lot of people.

01:13:10,560 --> 01:13:13,570
I shouldn't have said that, I myself am up there, I shouldn't.

01:13:13,570 --> 01:13:16,852
Okay, that guy there, I'm not thanking.

01:13:16,852 --> 01:13:18,489
But the others I'm thanking.

01:13:18,489 --> 01:13:19,830
>> [LAUGH] >> Okay,

01:13:19,830 --> 01:13:23,660
they've all done hard work to get us to where we are today.

01:13:24,870 --> 01:13:29,938
And again, if I put in everybody in the font will be too small for

01:13:29,938 --> 01:13:34,446
you to see it, so I just picked a few that did something.

01:13:34,446 --> 01:13:38,143
Until now, the other thing we can do is we can work on guidelines for

01:13:38,143 --> 01:13:39,695
how to write modern C++.

01:13:39,695 --> 01:13:42,430
How to clean up the old code.

01:13:43,920 --> 01:13:46,820
I gave the keynote last year on that.

01:13:48,450 --> 01:13:51,040
If you haven't seen it you can.

01:13:51,040 --> 01:13:55,850
But basically, we want to guide people towards a better,

01:13:55,850 --> 01:14:00,740
more effective, more efficient, better style of code.

01:14:00,740 --> 01:14:06,030
Develop the style and we're aiming at type and resource safe C++,

01:14:06,030 --> 01:14:09,790
no leaks, no memory corruption, no garbage collector.

01:14:09,790 --> 01:14:14,620
No limit of expressability, no performance degradation, and

01:14:14,620 --> 01:14:18,710
in strict ISO C++, tool enforced.

01:14:18,710 --> 01:14:23,870
I'd hoped to be able to say I could do this at scale, today, I can't.

01:14:23,870 --> 01:14:25,680
It's not at scale yet.

01:14:25,680 --> 01:14:29,360
But, there's a lot there, there's a lot that wasn't there last year.

01:14:29,360 --> 01:14:31,928
So progress is being made.

01:14:31,928 --> 01:14:35,960
There's the links to the guidelines,

01:14:35,960 --> 01:14:39,430
they are links to the support library we're using.

01:14:39,430 --> 01:14:42,310
And we can use all the help we can get.

01:14:43,560 --> 01:14:46,630
And the aesthetic analysis tool support that has started,

01:14:46,630 --> 01:14:49,890
you can actually get something out of a few of them.

01:14:49,890 --> 01:14:51,710
I just wanted more.

01:14:51,710 --> 01:14:55,662
So the status is we've got 423 rules.

01:14:55,662 --> 01:14:59,885
Which is, of course, too many rules because people can't

01:14:59,885 --> 01:15:04,000
remember 423 rules, can't even count that high.

01:15:04,000 --> 01:15:09,060
On the other hand, the idea is that the tools will help you find where

01:15:09,060 --> 01:15:14,730
you made a mistake and dump you to the right place in the rules so

01:15:14,730 --> 01:15:20,310
that you can read what was the rule that you are not supposed to break.

01:15:20,310 --> 01:15:23,260
Why is it a good rule?

01:15:23,260 --> 01:15:26,030
Examples, and what can you do instead?

01:15:26,030 --> 01:15:27,720
And some of that is in place.

01:15:27,720 --> 01:15:29,850
There's beginning industrial use.

01:15:29,850 --> 01:15:33,295
Usually an organization subsets and

01:15:33,295 --> 01:15:37,760
super-sets to fit their specific needs.

01:15:37,760 --> 01:15:39,972
That's good, that's expected.

01:15:39,972 --> 01:15:43,550
It said so in the introduction even last year.

01:15:44,580 --> 01:15:48,260
And there's some starting use in teaching commercially and

01:15:48,260 --> 01:15:49,180
in academia.

01:15:49,180 --> 01:15:52,928
So after a year I guess I shouldn't be,

01:15:52,928 --> 01:15:56,320
I'm impatient, and I wish there was more.

01:15:56,320 --> 01:15:57,440
But maybe I shouldn't be.

01:15:57,440 --> 01:16:01,690
The fact that one year later it's getting into academic curricula

01:16:01,690 --> 01:16:03,810
is pretty good.

01:16:03,810 --> 01:16:06,140
We wanted better tool support.

01:16:06,140 --> 01:16:08,600
I thought it would be better.

01:16:08,600 --> 01:16:10,580
Well, apologies, things happen.

01:16:11,625 --> 01:16:13,170
We're working on it, and

01:16:13,170 --> 01:16:17,850
if any of you are tool builders, I encourage you to think about it,

01:16:17,850 --> 01:16:22,860
look at the guidelines, content, the guideline's editors.

01:16:22,860 --> 01:16:25,500
You can find us on the GitHub and I'm one of them.

01:16:25,500 --> 01:16:27,280
So not too hard to find.

01:16:27,280 --> 01:16:31,120
Herb Sata is the other main name on the paper.

01:16:31,120 --> 01:16:32,630
And expect more.

01:16:32,630 --> 01:16:34,330
And again, thanks.

01:16:34,330 --> 01:16:38,389
We have, I don't know how many contributors.

01:16:38,389 --> 01:16:42,221
Twelve squared.

01:16:42,221 --> 01:16:44,320
And lots of issues.

01:16:44,320 --> 01:16:48,270
I hear about translations into Russian, Portuguese, and Korean.

01:16:48,270 --> 01:16:52,562
I can't read those languages, so I don't know how up to date

01:16:52,562 --> 01:16:56,720
they are or how good they are, but somebody is trying.

01:16:56,720 --> 01:17:01,030
Our general approach to just about anything is sort of the cocktail of

01:17:01,030 --> 01:17:01,800
approaches.

01:17:02,810 --> 01:17:09,060
We use low level stuff, like in the GSL, the guideline support library.

01:17:09,060 --> 01:17:12,050
There's an owner annotation that means nothing.

01:17:12,050 --> 01:17:13,150
It's an alias.

01:17:13,150 --> 01:17:14,970
But it tells you it's an owner.

01:17:14,970 --> 01:17:18,780
So static analysers and humans can understand that you're supposed to

01:17:18,780 --> 01:17:21,430
delete that thing when you're finished with it.

01:17:21,430 --> 01:17:24,570
At the higher level, where things are better,

01:17:24,570 --> 01:17:28,440
you have abstractions that represent ownership.

01:17:28,440 --> 01:17:31,300
Vectors, unique pointers, map, shared pointers, and

01:17:31,300 --> 01:17:32,750
stuff like that.

01:17:32,750 --> 01:17:35,274
And we have support for optional range checking.

01:17:35,274 --> 01:17:36,788
We go one level up.

01:17:36,788 --> 01:17:41,313
Span, string_span, not_null, you can express things directly and

01:17:41,313 --> 01:17:43,700
you can either have the code check it.

01:17:45,720 --> 01:17:49,115
These libraries functions will actually do checking, or

01:17:49,115 --> 01:17:51,965
you could have the equivalent done statically.

01:17:51,965 --> 01:17:53,506
And then we have rule support.

01:17:53,506 --> 01:17:57,803
There are somethings that just don't do it or just do it this way and

01:17:57,803 --> 01:18:00,620
you don't get into trouble.

01:18:00,620 --> 01:18:03,240
That helps and we work.

01:18:03,240 --> 01:18:07,120
The idea is the applications are built on the abstractions and

01:18:07,120 --> 01:18:09,010
then you can verify them.

01:18:09,010 --> 01:18:13,370
As oppose to fiddling around with low level stuff all the time.

01:18:13,370 --> 01:18:16,080
But sometimes you need the low-level stuff.

01:18:16,080 --> 01:18:20,730
Herb will talk a bit about that in the last keynote.

01:18:20,730 --> 01:18:24,840
There's an outline of the guidelines, there's a lot of them.

01:18:24,840 --> 01:18:28,960
The supporting sections, a lot of them are horribly incomplete, but

01:18:28,960 --> 01:18:29,820
not all of them.

01:18:29,820 --> 01:18:31,800
Some of them actually have teeth.

01:18:31,800 --> 01:18:36,760
And some of them actually have checking that supports them.

01:18:36,760 --> 01:18:37,800
Here's an example.

01:18:37,800 --> 01:18:40,140
Do not pass an array as a single pointer.

01:18:41,210 --> 01:18:44,750
This is an example of one of the rules where we have looked into

01:18:44,750 --> 01:18:45,930
seeing where the bugs are.

01:18:47,220 --> 01:18:51,100
And people passing a pointer or peer pointers and

01:18:51,100 --> 01:18:53,790
an integer that's supposed to tell how many limits there are.

01:18:55,100 --> 01:18:56,580
This is a bug source.

01:18:56,580 --> 01:18:58,270
It is a major bug source.

01:18:58,270 --> 01:19:04,940
Furthermore, it's a source of and other kinds of stuff.

01:19:04,940 --> 01:19:08,150
And so the rule is there,

01:19:08,150 --> 01:19:12,210
it's easily checkable, and there's an alternative.

01:19:12,210 --> 01:19:14,790
You can't just say, people, don't do that.

01:19:14,790 --> 01:19:19,670
I mean, what do we think it is, kindergarten?

01:19:19,670 --> 01:19:24,030
You have to give an alternative that is valid,

01:19:24,030 --> 01:19:26,730
applicable, and equally fast.

01:19:26,730 --> 01:19:29,430
And span in the GSL is an example of that.

01:19:31,650 --> 01:19:34,340
There's an example of how to get burned.

01:19:35,550 --> 01:19:39,880
Somebody thought it was a bright idea to have an array of

01:19:43,400 --> 01:19:46,100
elements of a derived class, and

01:19:46,100 --> 01:19:51,030
then pass that to a function that took a base class.

01:19:51,030 --> 01:19:55,523
There's a double implicit conversion going on there.

01:19:55,523 --> 01:19:59,532
First it converts the array to a pointer,

01:19:59,532 --> 01:20:03,999
then it converts the pointer through derive to

01:20:03,999 --> 01:20:09,510
the pointer to Base and boom if you subscript that stuff.

01:20:10,640 --> 01:20:14,070
Again, don't do it.

01:20:14,070 --> 01:20:15,770
The tool will catch it for you.

01:20:15,770 --> 01:20:19,370
I mean you could say I would never do that.

01:20:20,470 --> 01:20:24,210
Well I'll tell you some people do that sometimes.

01:20:24,210 --> 01:20:29,050
Bugs are very often done by people who hasn't been burned yet.

01:20:29,050 --> 01:20:33,170
And it would be really nice to help them, and that's what we can do.

01:20:33,170 --> 01:20:35,940
So that's the sort of structure.

01:20:37,290 --> 01:20:41,189
There's some exceptions if you pass zero terminated strings.

01:20:42,370 --> 01:20:43,680
That's fine.

01:20:43,680 --> 01:20:48,410
An enforcement, I believe this actually is available in

01:20:48,410 --> 01:20:54,180
the implementation by Neil Macintosh in the Microsoft compiler.

01:20:55,520 --> 01:20:59,530
And here's the example I gave earlier.

01:20:59,530 --> 01:21:01,420
You can use concepts today.

01:21:02,650 --> 01:21:05,170
And the recommendation is use concepts for

01:21:05,170 --> 01:21:06,570
all of your classes today.

01:21:07,670 --> 01:21:13,960
And, if you don't use a compiler that understand concepts,

01:21:13,960 --> 01:21:18,420
put comments in front of them.

01:21:20,250 --> 01:21:24,000
I had a comment just this week about this rule, and

01:21:24,000 --> 01:21:26,970
says you didn't mean policy types of something?

01:21:28,020 --> 01:21:29,340
And I said give me an example.

01:21:29,340 --> 01:21:33,250
And the answer came back says, I tried to write it down and

01:21:33,250 --> 01:21:36,960
I realized that I needed these concepts.

01:21:36,960 --> 01:21:38,899
People who hasn't tried this stuff.

01:21:40,090 --> 01:21:44,860
Under estimated, and if you dont want us to start from scratch go to

01:21:44,860 --> 01:21:50,752
the ranges TS and find a good set of starting concepts.

01:21:50,752 --> 01:21:53,475
It'll teach you some good manners and

01:21:53,475 --> 01:21:56,684
it'll help you get started by specifying the code better.

01:21:56,684 --> 01:22:00,615
Always initialize an object.

01:22:00,615 --> 01:22:04,180
I mean, we should do that but there's a lot of clever stuff

01:22:04,180 --> 01:22:07,380
where people say, I don't want to initialize it yet.

01:22:09,220 --> 01:22:10,940
And then they forget.

01:22:10,940 --> 01:22:15,070
Or they write a complicated if something is something initialize it

01:22:15,070 --> 01:22:18,930
this way, initialize it that way or else you divide that way.

01:22:18,930 --> 01:22:21,270
Okay, you get it wrong sometimes.

01:22:21,270 --> 01:22:23,030
It gets too clever.

01:22:23,030 --> 01:22:26,660
If you don't want a thing initialized yet,

01:22:26,660 --> 01:22:28,650
don't declare it yet.

01:22:28,650 --> 01:22:33,230
If you have a complicated initializer,

01:22:33,230 --> 01:22:34,890
there's ways of doing it.

01:22:34,890 --> 01:22:37,320
Like if you ever have initialized a variable,

01:22:37,320 --> 01:22:41,370
a variable with a lambda that did some conditional stuff on it.

01:22:41,370 --> 01:22:42,620
You can do better.

01:22:42,620 --> 01:22:47,060
A rule like that gives you suggestions for how to do better.

01:22:47,060 --> 01:22:51,580
Don't just say don't do it, say why you don't do it, and

01:22:51,580 --> 01:22:52,450
what you can do instead.

01:22:53,570 --> 01:22:57,370
And there's a lot of related talks.

01:22:57,370 --> 01:22:58,820
This is sort of my reason for

01:22:58,820 --> 01:23:02,870
not giving a language feature talk, apart from

01:23:02,870 --> 01:23:05,910
feeling that sometimes you have to talk about bigger pictures.

01:23:05,910 --> 01:23:08,860
There's a lot of talk at this conference.

01:23:08,860 --> 01:23:10,680
You want to know more about modules?

01:23:10,680 --> 01:23:12,080
There's modules talk.

01:23:12,080 --> 01:23:14,950
You want to know more about guidelines?

01:23:14,950 --> 01:23:16,160
There's guideline talks.

01:23:17,280 --> 01:23:18,260
Code teams.

01:23:19,440 --> 01:23:20,370
It's here.

01:23:20,370 --> 01:23:23,650
Parallel algorithms, which I mentioned, they're here.

01:23:23,650 --> 01:23:27,550
And this is, undoubtedly, not all the related talks.

01:23:27,550 --> 01:23:30,370
In some sense every talk at this conference is related,

01:23:30,370 --> 01:23:34,250
but in a stronger sense it's available there.

01:23:35,290 --> 01:23:35,790
And so.

01:23:37,080 --> 01:23:38,558
And here's some kind of summary.

01:23:38,558 --> 01:23:42,870
C++ is successful.

01:23:42,870 --> 01:23:46,180
We have to build on what made it successful.

01:23:47,350 --> 01:23:50,680
To sustain the success and

01:23:50,680 --> 01:23:53,840
to sustain the many applications that we depend on everyday.

01:23:55,210 --> 01:23:59,280
And We have to focus on significant changes.

01:23:59,280 --> 01:24:04,030
We mustn't just spend all of our time on details.

01:24:04,030 --> 01:24:05,610
First you decide where you go.

01:24:05,610 --> 01:24:07,510
First you decide what is major.

01:24:07,510 --> 01:24:13,110
And then you can agonize about the details, not the other way around.

01:24:13,110 --> 01:24:17,890
And we can't wait for the comedian,

01:24:17,890 --> 01:24:19,890
the compiler writers to finish everything.

01:24:20,970 --> 01:24:23,820
We actually have to catch up with what's available now.

01:24:23,820 --> 01:24:26,240
We have to experiment.

01:24:26,240 --> 01:24:29,140
Experimentation shows how we can use new features.

01:24:29,140 --> 01:24:32,400
It may even show you how new features can be improved

01:24:32,400 --> 01:24:36,180
while they're still in the design and decision stage.

01:24:36,180 --> 01:24:41,040
And the TS's, especially in the libraries, can be used.

01:24:41,040 --> 01:24:43,400
Some of them are in production use now.

01:24:43,400 --> 01:24:45,620
I don't recommend all of them, for production use.

01:24:46,840 --> 01:24:49,650
But there's no need to wait.

01:24:50,690 --> 01:24:55,980
There's a lot of stuff that can be done by us this afternoon.

01:24:55,980 --> 01:24:58,550
This is not just future stuff.

01:24:58,550 --> 01:25:01,040
Yes, those philosophers on the first slide,

01:25:01,040 --> 01:25:03,600
but some of it is really concrete.

01:25:03,600 --> 01:25:05,120
And try the guidelines.

01:25:05,120 --> 01:25:11,260
If you tried it after last year, you found it was incomplete.

01:25:11,260 --> 01:25:14,440
You try it now, it's still incomplete but it's better.

01:25:14,440 --> 01:25:16,649
Significantly better than it was last year.

01:25:18,170 --> 01:25:19,420
And, yep.

01:25:22,070 --> 01:25:24,920
By the way, that picture's not of stars,

01:25:24,920 --> 01:25:27,850
it's a program that pretends to generate stars.

01:25:29,140 --> 01:25:32,360
So, in case you wonder.

01:25:32,360 --> 01:25:35,240
And so, I think I have plenty of time for

01:25:35,240 --> 01:25:40,584
questions now Thank you.

01:25:40,584 --> 01:25:48,010
[APPLAUSE] I don't know,

01:25:48,010 --> 01:25:53,470
do we have a system with microphones and such? Yes.

01:25:53,470 --> 01:25:55,190
Please use the microphones if

01:25:55,190 --> 01:25:56,229
you're asking questions.

01:25:57,440 --> 01:26:01,230
>> How much can modules help with template heavy code?

01:26:01,230 --> 01:26:04,686
>> How much can modules do a template heavy code?

01:26:04,686 --> 01:26:08,989
Quite a lot,

01:26:08,989 --> 01:26:14,380
because you can break templates down into

01:26:14,380 --> 01:26:18,790
something like the IPR, I mentioned the internal program representation.

01:26:18,790 --> 01:26:24,650
So you'll basically build a typed, abstract dag.

01:26:24,650 --> 01:26:28,340
Not in the ST but, something more advanced like that.

01:26:28,340 --> 01:26:33,640
And then a lot of the template work has been done once.

01:26:34,780 --> 01:26:40,040
And so, only the final instantiation will be done once

01:26:40,040 --> 01:26:45,728
per set of template arguments as it was meant to be done.

01:26:45,728 --> 01:26:50,368
So go and ask the people that are doing modules,

01:26:50,368 --> 01:26:57,445
especially people that do both modules and concepts like Rays.

01:26:57,445 --> 01:27:00,059
He's down there with a hat.

01:27:03,020 --> 01:27:08,533
He's the right person to ask, but modules plus templates,

01:27:08,533 --> 01:27:13,290
especially modules plus templates with concepts,

01:27:13,290 --> 01:27:15,740
is a very very potent mix.

01:27:15,740 --> 01:27:19,310
Both for compile time, and for correctness.

01:27:19,310 --> 01:27:21,620
I want those faster compiles,

01:27:21,620 --> 01:27:24,510
significantly faster compiles to find more bugs.

01:27:25,540 --> 01:27:29,275
It's easier to compile faster, you just postpone everything's runtime.

01:27:29,275 --> 01:27:32,446
[LAUGH] That's not what I want.

01:27:32,446 --> 01:27:33,718
>> Thank you.

01:27:38,233 --> 01:27:43,350
>> So, you seemed sort of frustrated with the pace of the 17 standard,

01:27:43,350 --> 01:27:47,530
that we didn't get a lot of the features that you wanted.

01:27:47,530 --> 01:27:51,590
And you showed the graph of where it went real fast up and

01:27:51,590 --> 01:27:54,650
then flattened and then went fast up again and your worried, seemingly.

01:27:54,650 --> 01:27:57,120
It feels like you are worried about it flattening again and

01:27:57,120 --> 01:27:59,100
you want to try and forestall that.

01:27:59,100 --> 01:28:03,920
>> But i wonder if you can give some historical context as to, when we

01:28:03,920 --> 01:28:09,620
were in the flat portion back in 2005, 2008, did it feel flat?

01:28:09,620 --> 01:28:11,740
What was the committee doing at that time,

01:28:11,740 --> 01:28:13,820
that was before a lot of our times?

01:28:13,820 --> 01:28:19,030
>> Okay, this is a very complicated question to answer because

01:28:19,030 --> 01:28:23,800
it spans decades and, well, millions of people ,and language features,

01:28:23,800 --> 01:28:25,605
and industrial connections and everything.

01:28:25,605 --> 01:28:32,920
But yes I"m very impatient and yes if I'd been dictator of the world

01:28:32,920 --> 01:28:36,540
you would have had more features today and people in the committee

01:28:36,540 --> 01:28:39,820
that didn't think this was the right thing will tell you I'm wrong.

01:28:39,820 --> 01:28:44,575
And I'll tell them they are wrong and that's how we discuss things.

01:28:44,575 --> 01:28:47,244
>> [LAUGH] >> Hopefully we're still

01:28:47,244 --> 01:28:49,546
friends after that.

01:28:53,448 --> 01:29:00,280
At the time, yeah 2002 +/- 3.

01:29:00,280 --> 01:29:04,520
It did feel as if things

01:29:06,110 --> 01:29:09,760
were not going as well as it should.

01:29:09,760 --> 01:29:14,400
The committee was under the false assumption that you couldn't discuss

01:29:15,780 --> 01:29:18,040
new language features for five years.

01:29:18,040 --> 01:29:22,630
We actually believe there was an ISO rule for that.

01:29:22,630 --> 01:29:26,600
There was some kind of IS rules says you couldn't vote them in and

01:29:26,600 --> 01:29:30,610
change the standard but we were wrong.

01:29:30,610 --> 01:29:34,490
We were also very tired after the effort of delivering 98.

01:29:34,490 --> 01:29:39,234
And I think we screwed up.

01:29:41,794 --> 01:29:46,202
And then fortunately the CPU stopped getting faster and

01:29:46,202 --> 01:29:49,866
a few other things, and we sort of recovered.

01:29:49,866 --> 01:29:54,591
And like Stephanoff did us a real good favor by the SGL which

01:29:54,591 --> 01:29:59,806
created a certain amount of excitement when we needed it badly.

01:29:59,806 --> 01:30:04,031
So Hit on that before the standard, but of course,

01:30:04,031 --> 01:30:08,850
after the standard is when you get it available.

01:30:08,850 --> 01:30:12,510
So, yes, I think we could do better.

01:30:12,510 --> 01:30:14,720
And yes I think we can do things faster.

01:30:16,330 --> 01:30:19,350
I don't think any total disasters have happened.

01:30:20,570 --> 01:30:23,400
And I, just trying to give my

01:30:24,640 --> 01:30:29,710
contribution to what we can do and why we should do it.

01:30:29,710 --> 01:30:35,530
And next year and the year after, we will know more and have high hopes.

01:30:35,530 --> 01:30:40,324
A lot of these things are shipping, that I've been talking about.

01:30:46,432 --> 01:30:50,236
>> So, C++ has this rich history of features following this pipeline

01:30:50,236 --> 01:30:53,517
from third-party libraries into the standard library and

01:30:53,517 --> 01:30:56,141
even into the language itself, for instance,

01:30:56,141 --> 01:30:59,636
move semantics were in boost before they were in the language.

01:30:59,636 --> 01:31:02,971
But the path to language is much rockier because the APIs for

01:31:02,971 --> 01:31:06,910
extending compilers aren't really there, thus you often have these

01:31:06,910 --> 01:31:10,516
really dirty tricks that people do inside of metaprogramming or

01:31:10,516 --> 01:31:13,320
inside of all these other things.

01:31:13,320 --> 01:31:17,490
And it takes a lot longer to get things into the language because

01:31:17,490 --> 01:31:21,530
of that, and that's really cuz the APIs aren't there.

01:31:21,530 --> 01:31:24,130
Is this something that the standards committee should be concerned with,

01:31:24,130 --> 01:31:29,280
or is that something that's on your mind, should those be standardized,

01:31:29,280 --> 01:31:34,700
and why or why not?

01:31:34,700 --> 01:31:38,790
>> Let me just ask a counter question before I Try to answer.

01:31:38,790 --> 01:31:41,570
You said APIs?

01:31:41,570 --> 01:31:43,010
>> Well, standardized APIs.

01:31:43,010 --> 01:31:45,150
I mean I can't write a new compiler extension that will work with

01:31:45,150 --> 01:31:45,940
Microsoft and

01:31:45,940 --> 01:31:47,075
will work with Clang and- >> Okay,

01:31:47,075 --> 01:31:49,270
I was just trying to make sure it's right thing.

01:31:49,270 --> 01:31:50,758
That is a very hard question.

01:31:50,758 --> 01:31:55,507
Traditionally, platform vendors have insisted

01:31:55,507 --> 01:31:59,870
they can do things on their platform.

01:31:59,870 --> 01:32:03,040
And compiler vendors are very keen of not breaking

01:32:03,040 --> 01:32:06,400
their current user basis code.

01:32:06,400 --> 01:32:11,020
Furthermore, there's been a concern that if we standardized an ABI,

01:32:11,020 --> 01:32:15,020
like the Itanium ABI, and said everybody had to use it,

01:32:15,020 --> 01:32:18,890
we would limit experimentation and performance.

01:32:20,240 --> 01:32:24,354
So, this has been close to the third rail in discussions and

01:32:24,354 --> 01:32:26,494
the standards committee, and

01:32:26,494 --> 01:32:31,210
there has been people who simply wouldn't discuss this.

01:32:31,210 --> 01:32:34,810
And I don't have high hopes for this.

01:32:34,810 --> 01:32:38,950
If we could get a group of people

01:32:38,950 --> 01:32:43,820
together to arrange greater interoperability.

01:32:43,820 --> 01:32:48,232
You would have to have for starters Clang, GNU,

01:32:48,232 --> 01:32:53,350
Micrsoft, Intel, and a few others to sit down and agree.

01:32:54,600 --> 01:32:58,420
And I don't think it'll be the standards committee that

01:32:58,420 --> 01:33:00,030
can do that.

01:33:00,030 --> 01:33:03,190
For starters, they wouldn't want 100 people

01:33:03,190 --> 01:33:06,658
involved in the sign of a standard API.

01:33:06,658 --> 01:33:11,650
Furthermore different hardware has different things.

01:33:11,650 --> 01:33:16,830
So you probably could not standardize across architectures.

01:33:16,830 --> 01:33:20,730
And if you can't standardize across architectures, how can you

01:33:20,730 --> 01:33:24,710
standardize across architectures that are still changing?

01:33:24,710 --> 01:33:28,040
So it's a really, really sticky problem,

01:33:28,040 --> 01:33:33,930
and since I've failed to make progress in that area

01:33:33,930 --> 01:33:36,960
repeatedly, I'm not going to make any promises.

01:33:38,160 --> 01:33:40,990
Complain to your compiler vendor, >> [LAUGH]

01:33:40,990 --> 01:33:43,164
>> Encourage them to do something,

01:33:43,164 --> 01:33:47,433
maybe not perfect, maybe there could be a compatibility suite or

01:33:47,433 --> 01:33:50,538
a conversion mechanism in place or something,

01:33:50,538 --> 01:33:54,366
but don't rely on the standards committee to doing that.

01:33:58,617 --> 01:34:02,888
>> I would like to comment a little bit on the list that you have for

01:34:02,888 --> 01:34:06,990
C++ 20 and beyond, and the weirdness of hardware.

01:34:06,990 --> 01:34:11,170
Because I didn't quite make the connection between

01:34:11,170 --> 01:34:13,949
how we're gonna support this weirder hardware, as you mentioned.

01:34:15,460 --> 01:34:20,680
>> The main thing that was missing on that list was specific

01:34:20,680 --> 01:34:23,840
things about improved concurrency control.

01:34:25,080 --> 01:34:29,290
That's, I think, we need higher level concurrency models.

01:34:29,290 --> 01:34:34,474
We may need some work in cache

01:34:34,474 --> 01:34:39,660
awareness, I don't know.

01:34:39,660 --> 01:34:43,190
Somebody may look into that.

01:34:43,190 --> 01:34:48,374
And we may see some work in the standard library,

01:34:48,374 --> 01:34:53,189
for say, flat containers of various sorts.

01:34:55,750 --> 01:34:58,070
For using, cash is better.

01:34:59,410 --> 01:35:01,938
I just didn't want to go into details there.

01:35:01,938 --> 01:35:08,130
And I think a lot of it is a library issue,

01:35:08,130 --> 01:35:10,280
which is the main reason I didn't go deeper into it.

01:35:13,450 --> 01:35:15,071
Libraries with intrinsics.

01:35:17,829 --> 01:35:19,227
>> In your growth chart,

01:35:19,227 --> 01:35:23,577
I think there were maybe two hidden things that you didn't point out.

01:35:23,577 --> 01:35:27,598
That were, maybe there is growth of the communication web and

01:35:27,598 --> 01:35:32,237
being able to get access to a lot of information, and perhaps maybe some

01:35:32,237 --> 01:35:36,415
key individuals who have helped project the language forward,

01:35:36,415 --> 01:35:38,450
over the last couple of years?

01:35:38,450 --> 01:35:40,680
I mean, notable people who are at this conference.

01:35:41,710 --> 01:35:42,564
What are the ways to,

01:35:42,564 --> 01:35:45,127
do you think those are actual factors in the growth of language,

01:35:45,127 --> 01:35:47,659
and if they are, how do you capture that and make it go forward?

01:35:51,196 --> 01:35:53,170
>> I didn't quite understand, could you.

01:35:53,170 --> 01:35:56,060
>> So the idea being if there was sort of a lull in the growth of

01:35:56,060 --> 01:35:59,170
language and then it sort of took up, was that due to,

01:35:59,170 --> 01:36:01,830
maybe there are things on the list that you didn't talk about,

01:36:01,830 --> 01:36:04,410
that I can find information easier.

01:36:04,410 --> 01:36:06,490
I'm able to use learn about how to use a language better than

01:36:06,490 --> 01:36:08,960
maybe 2000 and did that help with the language?

01:36:08,960 --> 01:36:09,680
>> Yeah. >> And also

01:36:09,680 --> 01:36:11,920
now we've got a lot of people helping.

01:36:11,920 --> 01:36:13,780
>> It's a complicated issue.

01:36:13,780 --> 01:36:18,200
The exhaustion of the committee members were

01:36:19,750 --> 01:36:24,280
important, so was the draining of the community

01:36:25,740 --> 01:36:30,180
by organizations like Sun that was taking the best compiler writers and

01:36:30,180 --> 01:36:30,970
putting them on Java.

01:36:33,540 --> 01:36:37,610
And so was the fact that

01:36:37,610 --> 01:36:43,090
we had never managed to create a center for the C++ community.

01:36:43,090 --> 01:36:45,830
We don't have a central website,

01:36:45,830 --> 01:36:50,790
we don't have a central library exchange, and things like that.

01:36:52,040 --> 01:36:53,200
We're trying now.

01:36:54,510 --> 01:37:00,540
The C++ foundation is part of an attempt to deal with this.

01:37:00,540 --> 01:37:05,210
And then finally there was libraries that was missing,

01:37:05,210 --> 01:37:07,170
notably a GUI library.

01:37:07,170 --> 01:37:11,260
There's no standard for it, which we couldn't get, because there

01:37:11,260 --> 01:37:14,540
was at least five organizations that was members of the standards

01:37:14,540 --> 01:37:18,160
committee that was of the opinion that their GUI was the best.

01:37:19,410 --> 01:37:22,670
And we could not move without insulting

01:37:22,670 --> 01:37:26,500
more than half of the committee And that's not the way you move.

01:37:26,500 --> 01:37:30,842
There was all the things, we're finally getting a networking library

01:37:30,842 --> 01:37:34,400
but why don't we have a web access library?

01:37:34,400 --> 01:37:43,030
It's 10 years late and, Well this happened.

01:37:43,030 --> 01:37:44,440
It was ten years ago.

01:37:44,440 --> 01:37:47,130
The question we have to ask is what can we do today.

01:37:48,140 --> 01:37:51,840
And we're moving too slowly for my taste.

01:37:51,840 --> 01:37:57,893
I would have liked the SU library to be shipped with 17.

01:37:57,893 --> 01:38:02,610
As it is, it's production quality and used, so use it anyway.

01:38:05,880 --> 01:38:09,714
>> Hi, actually you answered a part of my question by talking about

01:38:09,714 --> 01:38:11,783
concurrency and cash awareness.

01:38:11,783 --> 01:38:16,144
But my question was more like, you started by saying that C++ has to be

01:38:16,144 --> 01:38:20,578
true to its two code principles of one, staying closer to the hardware,

01:38:20,578 --> 01:38:24,380
and second is, providing minimal obstructions on top of it.

01:38:25,410 --> 01:38:30,730
It's just my opinion that as we are going to C++ 17 and 20,

01:38:30,730 --> 01:38:36,641
I think the focus has more been on providing those extractions better,

01:38:36,641 --> 01:38:41,486
whereas the focus is less on being closer to the hardware.

01:38:41,486 --> 01:38:47,873
And almost to an extent that, there has been a perception that,

01:38:47,873 --> 01:38:54,520
people say that if you are really focused towards speed, you see.

01:38:55,660 --> 01:38:59,320
So what's your opinion on that focus?

01:39:01,090 --> 01:39:02,910
>> There's a lot of impressions out there.

01:39:04,120 --> 01:39:07,131
And very often they are wrong.

01:39:07,131 --> 01:39:13,240
I think there is a part of the community and

01:39:13,240 --> 01:39:18,140
part of the standards community that is very interested in performance.

01:39:18,140 --> 01:39:20,980
In my day job, I sometimes deal with

01:39:22,410 --> 01:39:26,080
both high volume data and ultra low latency data.

01:39:26,080 --> 01:39:32,070
I can count nanoseconds now, I didn't used to be able to.

01:39:32,070 --> 01:39:33,986
And it's certainly not forgotten.

01:39:33,986 --> 01:39:37,076
Whether we popularize and

01:39:37,076 --> 01:39:42,695
spread the word well enough is another matter,

01:39:42,695 --> 01:39:47,891
and also whether the ideas that come forward

01:39:47,891 --> 01:39:53,865
are general enough to work with everybody.

01:39:53,865 --> 01:39:58,489
They'll certainly work with, for instance,

01:39:58,489 --> 01:40:02,889
integrating FTAs and CPUs and GPUs on the same

01:40:06,553 --> 01:40:11,577
On the same chip, and we're aware of that.

01:40:11,577 --> 01:40:16,216
There's at least one cross industry group that

01:40:16,216 --> 01:40:21,675
are looking into issues like that, that we know about.

01:40:21,675 --> 01:40:28,262
But I suspect that we're still waiting for some proposals for

01:40:28,262 --> 01:40:33,593
how to do that, some people are talking about it.

01:40:33,593 --> 01:40:39,017
I think it's more an impression,

01:40:39,017 --> 01:40:45,060
an image issue, than it is real.

01:40:45,060 --> 01:40:47,620
But anything we can do to get

01:40:48,690 --> 01:40:51,716
more known that we're working in those fields is probably good.

01:40:51,716 --> 01:40:57,030
I think there are talks

01:40:57,030 --> 01:41:01,700
at this conference that relates to better use of hardware.

01:41:01,700 --> 01:41:05,643
I suggest you look into it on the schedule.

01:41:08,644 --> 01:41:13,471
>> Could you maybe say a couple words about the role of Boost in

01:41:13,471 --> 01:41:18,690
the past, and then particularly what you envision is a role for

01:41:18,690 --> 01:41:22,040
organizations like that in the future,

01:41:22,040 --> 01:41:25,860
as far as contributing to this effort?

01:41:25,860 --> 01:41:29,364
>> Boost has made an excellent, and

01:41:29,364 --> 01:41:34,998
important contribution to modern C++ in general,

01:41:34,998 --> 01:41:39,175
and to the stand in particular.

01:41:39,175 --> 01:41:41,660
They've tried out a lot of ideas.

01:41:42,910 --> 01:41:46,810
I would say only a few of them have any chance of getting into

01:41:46,810 --> 01:41:50,310
The Standard, which, I think is fine

01:41:50,310 --> 01:41:54,470
because The Standard is what has to be shipped to everybody everywhere.

01:41:54,470 --> 01:41:57,080
And it has to work together.

01:41:57,080 --> 01:42:01,360
Boost is doing a good job, but they shouldn't expect more than say,

01:42:01,360 --> 01:42:02,800
a 10% success rate,

01:42:02,800 --> 01:42:07,260
if entry into the standard is the measure of success.

01:42:07,260 --> 01:42:08,380
I don't think it should be.

01:42:08,380 --> 01:42:11,800
I think usage should be.

01:42:11,800 --> 01:42:14,950
The other thing is that sometimes, I think,

01:42:14,950 --> 01:42:20,380
Boost over designs, and becomes a bit expert friendly.

01:42:20,380 --> 01:42:23,560
And if I would make some suggestions to Boost,

01:42:23,560 --> 01:42:28,090
nothing I haven't done all ready repeatedly, and actually once at

01:42:28,090 --> 01:42:33,590
BoostCon, focus a little bit more on simple use.

01:42:33,590 --> 01:42:35,560
Focus a little bit more on packaging.

01:42:37,550 --> 01:42:43,330
I would like to have sort of a novice's package of Boost stuff for

01:42:43,330 --> 01:42:47,430
the essentials, and then the package, and

01:42:47,430 --> 01:42:49,810
then the experts only package.

01:42:49,810 --> 01:42:54,250
And I would not have to want to know everything that an expert needs to

01:42:54,250 --> 01:42:57,800
know to be a novice user, examples like that.

01:42:57,800 --> 01:43:01,980
But I think Boost is one organization.

01:43:01,980 --> 01:43:07,455
It is not the only organization, I wish there was more and

01:43:07,455 --> 01:43:13,620
I wish there was more code there and I wish people would use it more.

01:43:13,620 --> 01:43:15,760
Without it we would be sunk.

01:43:19,100 --> 01:43:19,710
>> Thank you.

01:43:19,710 --> 01:43:23,289
I might say I think you way underestimate your abilities as

01:43:23,289 --> 01:43:24,098
a marketer.

01:43:24,098 --> 01:43:26,460
>> Sorry, I am over.

01:43:26,460 --> 01:43:28,570
I'm being interrupted here.

01:43:29,650 --> 01:43:35,440
Sorry about it, there is a session for committee tonight.

01:43:35,440 --> 01:43:38,650
So if you've got committee questions, you go to that.

01:43:38,650 --> 01:43:41,680
And otherwise catch me in the corridors.

01:43:41,680 --> 01:43:43,600
That was a hard interrupt.

01:43:43,600 --> 01:43:44,360
Sorry.

01:43:44,360 --> 01:43:50,680

YouTube URL: https://www.youtube.com/watch?v=_wzc7a3McOs


