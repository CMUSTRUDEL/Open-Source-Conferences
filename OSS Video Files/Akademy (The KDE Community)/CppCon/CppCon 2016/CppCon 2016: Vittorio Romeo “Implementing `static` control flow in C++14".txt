Title: CppCon 2016: Vittorio Romeo “Implementing `static` control flow in C++14"
Publication date: 2016-09-30
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
There has always been great interest in imperative compile-time control flow: as an example, consider all the existing `static_if` proposals and the recently accepted `constexpr_if` construct for C++17. 

What if you were told that it is actually possible to implement imperative control flow in C++14? 

In this tutorial, the implementation and design of a compile-time `static_if` branching construct and of a compile-time `static_for` iteration construct will be shown and analyzed. These constructs will then be compared to traditional solutions and upcoming C++17 features, examining advantages and drawbacks.
— 
Vittorio Romeo
Bloomberg LP
Software Engineer
London, UK
Vittorio Romeo is an Italian 21 year old Computer Science student at "Università degli Studi di Messina". He began programming at a very young age and is now a C++ enthusiast. While following the evolution of the C++ standard and embracing the newest features, he worked on several open-source projects, including modern general-purpose libraries and free cross-platform indie games. Vittorio is an active member of the C++ community: he participated as a speaker at CppCon 2014/2015, ++it Florence 2015 and at his local Linux Day 2013/2014 events, as a Student/Volunteer at C++Now 2015, and as part of Meeting C++ 2015's student program. He currently maintains a YouTube channel featuring well-received modern C++11 and C++14 tutorials. When he's not writing code, Vittorio enjoys weightlifting and fitness-related activities, competitive/challenging computer gaming and good scifi movies/TV-series.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,389
thank you very much for coming my name

00:00:01,709 --> 00:00:05,370
is vittorio Rommel I currently work at

00:00:03,389 --> 00:00:07,200
Bloomberg as a software engineer and you

00:00:05,370 --> 00:00:09,929
might know me for my video tutorials

00:00:07,200 --> 00:00:12,059
Emira conference talk today we're going

00:00:09,929 --> 00:00:15,330
to speak about static control for in C++

00:00:12,059 --> 00:00:19,199
14 and this is what we're going to do so

00:00:15,330 --> 00:00:20,609
I have as part that's just light and are

00:00:19,199 --> 00:00:22,920
we going to look at static control flow

00:00:20,609 --> 00:00:24,420
in general then we gonna learn about

00:00:22,920 --> 00:00:26,099
compile time branching and we'll have a

00:00:24,420 --> 00:00:29,039
little history lesson about static if in

00:00:26,099 --> 00:00:31,710
C++ we're gonna take a look at if Const

00:00:29,039 --> 00:00:34,469
expert in C++ 17 and then implement our

00:00:31,710 --> 00:00:35,940
own version in Sobotka's 14 then we're

00:00:34,469 --> 00:00:38,040
gonna switch to coding comments and

00:00:35,940 --> 00:00:40,079
we'll see the mutation details of static

00:00:38,040 --> 00:00:41,640
if and we'll also deal with compile time

00:00:40,079 --> 00:00:43,860
iteration using two different techniques

00:00:41,640 --> 00:00:46,110
for each arguments which you may know if

00:00:43,860 --> 00:00:48,300
you have if you're following shown

00:00:46,110 --> 00:00:50,550
parents on Twitter and Static 4 which is

00:00:48,300 --> 00:00:53,489
a glorified fold with a lot of

00:00:50,550 --> 00:00:55,770
synthetical sugar so what is static

00:00:53,489 --> 00:00:57,870
control foe so static is a specifier

00:00:55,770 --> 00:00:59,640
that has multiple meaning C++ but it's

00:00:57,870 --> 00:01:01,680
also word very commonly used by

00:00:59,640 --> 00:01:04,890
developers to refer to compile time

00:01:01,680 --> 00:01:07,200
control flow languages such as D if you

00:01:04,890 --> 00:01:09,240
have ever used it you should know it as

00:01:07,200 --> 00:01:12,090
a very very powerful meta programming

00:01:09,240 --> 00:01:13,979
facility called static if and there are

00:01:12,090 --> 00:01:16,229
also other languages to do that the

00:01:13,979 --> 00:01:18,450
goals of this talk are understanding the

00:01:16,229 --> 00:01:21,420
benefits of static control flow looking

00:01:18,450 --> 00:01:23,040
at the history static if in C++ and also

00:01:21,420 --> 00:01:25,560
analyzing the constructs we're gonna

00:01:23,040 --> 00:01:27,840
implement this about those 14 assert

00:01:25,560 --> 00:01:30,720
with an example of another language so

00:01:27,840 --> 00:01:32,520
this is static F in D if you look at

00:01:30,720 --> 00:01:34,680
this it's pretty weird because as you

00:01:32,520 --> 00:01:35,880
can see we're kind of having this kind

00:01:34,680 --> 00:01:38,220
of template where we're passing a

00:01:35,880 --> 00:01:40,530
compile time integer and we are

00:01:38,220 --> 00:01:42,899
compiling different analysis depending

00:01:40,530 --> 00:01:44,369
on the integer we passed and we also

00:01:42,899 --> 00:01:46,619
have a static assert over there which

00:01:44,369 --> 00:01:48,810
will only fire if the conditions are not

00:01:46,619 --> 00:01:52,070
met so in this case you can think about

00:01:48,810 --> 00:01:54,240
the decompiler completely ignoring

00:01:52,070 --> 00:01:57,090
branches that are not matched by the

00:01:54,240 --> 00:02:01,939
conditions so how would you implement

00:01:57,090 --> 00:02:01,939
this in C++ anyone

00:02:04,950 --> 00:02:09,280
okay yeah that's probably the easiest

00:02:07,390 --> 00:02:10,869
way of implementing it you just have a

00:02:09,280 --> 00:02:14,050
normal template and you specialize it

00:02:10,869 --> 00:02:17,379
over the integer and you can already see

00:02:14,050 --> 00:02:19,060
the difference so indeed it's very it

00:02:17,379 --> 00:02:21,670
doesn't care about the Scopes well in

00:02:19,060 --> 00:02:24,340
C++ it's easier to understand because

00:02:21,670 --> 00:02:25,720
the compiler has to specialize between

00:02:24,340 --> 00:02:29,560
the two templates and there are no weird

00:02:25,720 --> 00:02:32,650
rules about static if this is an example

00:02:29,560 --> 00:02:35,440
from C++ 11 where we have a periodic

00:02:32,650 --> 00:02:38,110
function called F and this is the

00:02:35,440 --> 00:02:40,599
traditional way of angling with a very

00:02:38,110 --> 00:02:42,819
attic pack of arguments we usually have

00:02:40,599 --> 00:02:45,459
a single step that handles one of the

00:02:42,819 --> 00:02:47,230
arguments and then we have the poetic

00:02:45,459 --> 00:02:49,120
version that calls the single argument

00:02:47,230 --> 00:02:51,879
function and then handles the tail and

00:02:49,120 --> 00:02:54,010
keeps repeating until the tail is empty

00:02:51,879 --> 00:02:56,650
so as you can see we have to repeat that

00:02:54,010 --> 00:02:59,680
function twice if we had some sort of

00:02:56,650 --> 00:03:01,510
construct maybe called if Const exper we

00:02:59,680 --> 00:03:03,190
could avoid defining two functions and

00:03:01,510 --> 00:03:05,739
we could do something like this this is

00:03:03,190 --> 00:03:07,269
very nice because it's localized we have

00:03:05,739 --> 00:03:08,769
the single function call and then we

00:03:07,269 --> 00:03:11,410
handle the tail only if it's not empty

00:03:08,769 --> 00:03:14,340
so it's quite easier to read and to

00:03:11,410 --> 00:03:17,350
maintain as we have a single function

00:03:14,340 --> 00:03:19,660
our example is constructing objects

00:03:17,350 --> 00:03:21,970
let's say we're building our own version

00:03:19,660 --> 00:03:24,519
of make unique and what we want to do is

00:03:21,970 --> 00:03:26,560
switch between braces initialization and

00:03:24,519 --> 00:03:29,560
grandparent initialization that allows

00:03:26,560 --> 00:03:31,599
implicit conversion all the stuff and if

00:03:29,560 --> 00:03:33,010
we want to check that at compile time

00:03:31,599 --> 00:03:35,200
we might use something like this which

00:03:33,010 --> 00:03:37,900
is in a belief or if you're using some

00:03:35,200 --> 00:03:40,060
nice libraries such as fit or Hana you

00:03:37,900 --> 00:03:41,500
would do something clever but as you can

00:03:40,060 --> 00:03:42,940
see we have two fact two versions of the

00:03:41,500 --> 00:03:44,769
same function and it's really noisy

00:03:42,940 --> 00:03:47,560
because we have all that enable live

00:03:44,769 --> 00:03:49,780
stuff if again we add this magical

00:03:47,560 --> 00:03:52,180
construct called if constructs / all of

00:03:49,780 --> 00:03:53,650
that would go away and what we will have

00:03:52,180 --> 00:03:55,120
is just a single function which is

00:03:53,650 --> 00:03:57,069
really really straightforward and easy

00:03:55,120 --> 00:03:59,769
to read and as you can see we're

00:03:57,069 --> 00:04:00,880
switching between a compile conditions a

00:03:59,769 --> 00:04:03,099
compile time condition and just

00:04:00,880 --> 00:04:07,120
returning depending on the result of

00:04:03,099 --> 00:04:08,919
that condition so those examples are

00:04:07,120 --> 00:04:11,139
actually real examples that were taken

00:04:08,919 --> 00:04:13,599
from this proposal over here by Bill

00:04:11,139 --> 00:04:15,879
volcanion and it was called construct

00:04:13,599 --> 00:04:17,950
with and the paper was originally called

00:04:15,879 --> 00:04:19,720
created as a resurrection of Cheever

00:04:17,950 --> 00:04:23,590
controversial silicate proposals by

00:04:19,720 --> 00:04:25,900
Walter Lee Brown and Walter bright herb

00:04:23,590 --> 00:04:28,780
sadder and Alexandra school so these

00:04:25,900 --> 00:04:31,930
proposals were created in 2011-2012 and

00:04:28,780 --> 00:04:35,530
they were considered harmful by we are

00:04:31,930 --> 00:04:37,810
now Gabby and and each other because

00:04:35,530 --> 00:04:41,230
they had very unintuitive scope rules

00:04:37,810 --> 00:04:43,450
they were similar 2d static if and they

00:04:41,230 --> 00:04:46,840
weren't you know consistent with the

00:04:43,450 --> 00:04:50,650
rest of the language in 2015 we had this

00:04:46,840 --> 00:04:52,120
static director proposal that changed

00:04:50,650 --> 00:04:53,350
the name to constructs per if I made it

00:04:52,120 --> 00:04:58,540
more in line with the rest of the

00:04:53,350 --> 00:05:01,420
language so will improve the proposal

00:04:58,540 --> 00:05:03,880
several times and in 2015 we got two

00:05:01,420 --> 00:05:07,930
more proposals that improved the wording

00:05:03,880 --> 00:05:09,160
and that 16 we finally got to the

00:05:07,930 --> 00:05:12,910
version that you seen on the screen with

00:05:09,160 --> 00:05:14,920
the if construct or syntax in Oulu we

00:05:12,910 --> 00:05:16,690
got the final revision we was accepted

00:05:14,920 --> 00:05:18,430
for super for 17 and I'm really happy to

00:05:16,690 --> 00:05:20,620
announce that you will be able to write

00:05:18,430 --> 00:05:24,670
that beautiful code pretty soon

00:05:20,620 --> 00:05:26,770
hopefully so these are is the same

00:05:24,670 --> 00:05:28,300
example seen before and this is valid

00:05:26,770 --> 00:05:30,400
suppose puzzlement in you can write this

00:05:28,300 --> 00:05:32,440
if you have a super 17 compliant

00:05:30,400 --> 00:05:34,570
compiler and I think that clunk SVM

00:05:32,440 --> 00:05:36,940
should be able to handle this quite

00:05:34,570 --> 00:05:39,520
nicely and again this example that we've

00:05:36,940 --> 00:05:41,830
seen before is not hypothetical you can

00:05:39,520 --> 00:05:44,500
write this in suppose pass 17 there are

00:05:41,830 --> 00:05:46,720
some rules so if Const expert is always

00:05:44,500 --> 00:05:49,360
restricted to block scopes is always

00:05:46,720 --> 00:05:51,070
going to establish a new scope and it

00:05:49,360 --> 00:05:52,480
requires that exists value of the

00:05:51,070 --> 00:05:54,490
condition so that either coalition

00:05:52,480 --> 00:05:56,770
branches were fault so the first two

00:05:54,490 --> 00:05:59,350
rules can be summarized as that you know

00:05:56,770 --> 00:06:01,240
if you ever used the normal if statement

00:05:59,350 --> 00:06:03,040
you need you will introduce a new scope

00:06:01,240 --> 00:06:04,240
you cannot do crazy stuff like D so

00:06:03,040 --> 00:06:06,490
everything that you do inside the scope

00:06:04,240 --> 00:06:08,200
is going to be limited to that scope the

00:06:06,490 --> 00:06:10,840
third rule is the most important one and

00:06:08,200 --> 00:06:13,720
it says that practically all the

00:06:10,840 --> 00:06:15,760
branches need to be is possible and they

00:06:13,720 --> 00:06:17,440
will only be instantiated if the

00:06:15,760 --> 00:06:19,030
condition is matching so as long as you

00:06:17,440 --> 00:06:22,630
have it valid support was code in there

00:06:19,030 --> 00:06:24,130
even if it's even if the class maybe

00:06:22,630 --> 00:06:25,600
does not support an operation that

00:06:24,130 --> 00:06:27,280
you're calling inside a branch the

00:06:25,600 --> 00:06:29,920
branch will only be instantiated and

00:06:27,280 --> 00:06:31,780
cause a compile error if the condition

00:06:29,920 --> 00:06:33,610
is matching otherwise

00:06:31,780 --> 00:06:35,170
it just needs to be well-formed doesn't

00:06:33,610 --> 00:06:36,400
matter if we will compile if the

00:06:35,170 --> 00:06:39,460
condition is not true

00:06:36,400 --> 00:06:41,590
so if you remember this no we cannot do

00:06:39,460 --> 00:06:45,250
that instead well plus and I I think

00:06:41,590 --> 00:06:47,470
that's a good thing you can chain

00:06:45,250 --> 00:06:51,310
together if Const exper like this which

00:06:47,470 --> 00:06:53,290
is very nice to see and the question

00:06:51,310 --> 00:06:54,910
that you are asking is do we wait you

00:06:53,290 --> 00:06:57,070
have to wait until she was 17 to do

00:06:54,910 --> 00:06:59,320
something like this and if you're here

00:06:57,070 --> 00:07:01,360
obviously you're interested in a C++

00:06:59,320 --> 00:07:04,360
protein solution which we can implement

00:07:01,360 --> 00:07:06,730
with a slightly less enticing syntax so

00:07:04,360 --> 00:07:08,560
let's get to the spot was 14 construct

00:07:06,730 --> 00:07:10,030
and I want to start with an example

00:07:08,560 --> 00:07:12,220
let's say we have multiple food-related

00:07:10,030 --> 00:07:14,169
classes that have slightly different

00:07:12,220 --> 00:07:16,210
interfaces so we have a banana and

00:07:14,169 --> 00:07:17,830
peanuts that we can eat and then we have

00:07:16,210 --> 00:07:20,380
water in juice that we can drink our

00:07:17,830 --> 00:07:22,360
goal is to create a generic consume

00:07:20,380 --> 00:07:24,190
function that will accept any kind of

00:07:22,360 --> 00:07:26,260
food instance and we'll print something

00:07:24,190 --> 00:07:29,889
to a CD out depending on the type of the

00:07:26,260 --> 00:07:31,479
food one way we could do this is using

00:07:29,889 --> 00:07:33,700
if constructs were or my static if

00:07:31,479 --> 00:07:35,740
implementation and what we need is

00:07:33,700 --> 00:07:38,140
obviously a compile time condition in

00:07:35,740 --> 00:07:40,120
order to branch a compile time so we can

00:07:38,140 --> 00:07:42,760
specialize some suppose 14 very attic

00:07:40,120 --> 00:07:45,160
with variables in order to categorize

00:07:42,760 --> 00:07:48,370
these classes and you can think of this

00:07:45,160 --> 00:07:49,840
as manually having a concept in manually

00:07:48,370 --> 00:07:51,970
specifying what is satisfying the

00:07:49,840 --> 00:07:53,800
concept so in the case of this solid

00:07:51,970 --> 00:07:56,620
concept we're specifying that banana and

00:07:53,800 --> 00:07:58,150
peanuts should satisfy hit and for is

00:07:56,620 --> 00:08:01,150
liquid with doing that for water and

00:07:58,150 --> 00:08:03,610
juice once we have that and our magical

00:08:01,150 --> 00:08:05,950
study cave in suppose for 14 we can

00:08:03,610 --> 00:08:09,970
write something like this so this is

00:08:05,950 --> 00:08:12,160
quite weird it's like a chain of lambdas

00:08:09,970 --> 00:08:14,320
with some synthetical sugar in between

00:08:12,160 --> 00:08:16,270
that allows you to implement something

00:08:14,320 --> 00:08:16,900
that's completely equivalent to support

00:08:16,270 --> 00:08:20,260
or Seventeen's

00:08:16,900 --> 00:08:22,539
if comes sex for construct so as you can

00:08:20,260 --> 00:08:25,330
see we're using this weird bull b which

00:08:22,539 --> 00:08:28,660
is a variable template that allows us to

00:08:25,330 --> 00:08:30,580
wrap the boolean value in a compile time

00:08:28,660 --> 00:08:34,450
wrapper so that the branching can take

00:08:30,580 --> 00:08:37,210
place and yeah that's what Wolvie is for

00:08:34,450 --> 00:08:40,740
and it is implemented like this we have

00:08:37,210 --> 00:08:42,849
an interval constant and a concept

00:08:40,740 --> 00:08:44,680
variable template in order to make it a

00:08:42,849 --> 00:08:45,100
little nicer so we don't have to use the

00:08:44,680 --> 00:08:50,380
braces

00:08:45,100 --> 00:08:52,540
the end afterwards I'd like to say that

00:08:50,380 --> 00:08:54,550
this kind of idea of rapping types

00:08:52,540 --> 00:08:56,440
inside values and vice versa is what

00:08:54,550 --> 00:08:58,750
allows amazing libraries such as putana

00:08:56,440 --> 00:09:00,430
or fit in cheek to create extremely

00:08:58,750 --> 00:09:03,279
powerful and nice to use metaprogramming

00:09:00,430 --> 00:09:05,980
facilities and you can learn more about

00:09:03,279 --> 00:09:07,600
about this pattern in the links here the

00:09:05,980 --> 00:09:09,759
slides are available on github so feel

00:09:07,600 --> 00:09:11,860
free to check them out later and you can

00:09:09,759 --> 00:09:16,089
click on the links and visit the

00:09:11,860 --> 00:09:18,459
articles also you can see that the scope

00:09:16,089 --> 00:09:19,839
rules are what you would expect because

00:09:18,459 --> 00:09:22,209
we have those lambdas that are

00:09:19,839 --> 00:09:26,769
restricting the logic of the branching

00:09:22,209 --> 00:09:29,110
only inside that scopes and the idea of

00:09:26,769 --> 00:09:31,660
thinking about this construct is that

00:09:29,110 --> 00:09:34,600
every branch is like a template function

00:09:31,660 --> 00:09:36,610
that will only be instantiated if the

00:09:34,600 --> 00:09:40,269
condition is matching so it doesn't

00:09:36,610 --> 00:09:43,449
matter if for example Y that it does not

00:09:40,269 --> 00:09:45,910
exist for our current acts in the

00:09:43,449 --> 00:09:47,800
consumed call because we won't get a

00:09:45,910 --> 00:09:49,509
compilation error unless the branch is

00:09:47,800 --> 00:09:51,910
accentuated so that means that the

00:09:49,509 --> 00:09:53,470
conditioner should have matched so yeah

00:09:51,910 --> 00:09:55,769
you can think about this as a bunch of

00:09:53,470 --> 00:09:58,060
template function and which we're like

00:09:55,769 --> 00:10:00,100
linearly searching the one that matches

00:09:58,060 --> 00:10:01,720
and as soon as we find it we take in and

00:10:00,100 --> 00:10:06,310
we instantiate it otherwise it's never

00:10:01,720 --> 00:10:07,959
going to be instantiated so this pattern

00:10:06,310 --> 00:10:11,199
works thanks to see pastas proteins

00:10:07,959 --> 00:10:13,240
generic lambdas this is one of the

00:10:11,199 --> 00:10:14,920
branches and the compiler does some

00:10:13,240 --> 00:10:16,750
magic transformation and it becomes

00:10:14,920 --> 00:10:19,569
something like this so it's an anonymous

00:10:16,750 --> 00:10:21,850
struct with a templated operator call

00:10:19,569 --> 00:10:23,829
that's taking our argument and then

00:10:21,850 --> 00:10:25,389
doing something and this is the

00:10:23,829 --> 00:10:27,819
important part because since the

00:10:25,389 --> 00:10:30,279
operator call is templated it will only

00:10:27,819 --> 00:10:32,050
be instantiated if it's called that's

00:10:30,279 --> 00:10:33,339
the important part if we didn't have

00:10:32,050 --> 00:10:37,810
generic lambdas we wouldn't be able to

00:10:33,339 --> 00:10:40,600
do this cleanly so any questions so far

00:10:37,810 --> 00:10:43,380
and feel free to ask because this is

00:10:40,600 --> 00:10:43,380
very important yes

00:10:59,930 --> 00:11:04,190
okay the question is why would you use

00:11:01,640 --> 00:11:06,500
this very convoluted syntax instead of

00:11:04,190 --> 00:11:07,970
using a base food class and maybe doing

00:11:06,500 --> 00:11:08,840
something more traditional so this is

00:11:07,970 --> 00:11:12,350
just an example

00:11:08,840 --> 00:11:14,840
I mean you I wouldn't obviously write

00:11:12,350 --> 00:11:17,360
anything like this for such a simple

00:11:14,840 --> 00:11:19,100
class hierarchy but when you're dealing

00:11:17,360 --> 00:11:21,350
with meta programming and we did with

00:11:19,100 --> 00:11:23,240
complex code it's really really nice to

00:11:21,350 --> 00:11:25,130
have a localized compiled branch inside

00:11:23,240 --> 00:11:27,740
a single function instead of jumping

00:11:25,130 --> 00:11:30,260
everywhere over the code and maybe this

00:11:27,740 --> 00:11:32,900
is a not an excellent example but it

00:11:30,260 --> 00:11:34,220
gives you an idea how you can use

00:11:32,900 --> 00:11:35,480
different interfaces in the same

00:11:34,220 --> 00:11:36,950
function without having to use

00:11:35,480 --> 00:11:39,080
specialization and stuff like that so

00:11:36,950 --> 00:11:41,180
yeah you wouldn't do this for such a

00:11:39,080 --> 00:11:43,550
simple example but we're seeing more

00:11:41,180 --> 00:11:53,920
examples in the code that might be more

00:11:43,550 --> 00:11:53,920
interesting sure yeah

00:11:56,540 --> 00:12:02,340
well the question is why do you consider

00:12:00,600 --> 00:12:06,450
not being able to do the crazy stuff you

00:12:02,340 --> 00:12:08,400
can do in the in C++ and maybe I didn't

00:12:06,450 --> 00:12:09,300
express myself very well I don't

00:12:08,400 --> 00:12:11,070
consider that to be good

00:12:09,300 --> 00:12:12,240
inside C++ because it's kind of

00:12:11,070 --> 00:12:14,430
inconsistent with the rest of the

00:12:12,240 --> 00:12:15,810
language but if I were using D I really

00:12:14,430 --> 00:12:17,280
love the meta programming stuff you can

00:12:15,810 --> 00:12:30,060
do indeed I just think it doesn't fit

00:12:17,280 --> 00:12:31,350
with the rest of the language sure so

00:12:30,060 --> 00:12:33,390
the question is what if I wanted to

00:12:31,350 --> 00:12:35,340
disable the invalid specialization of

00:12:33,390 --> 00:12:37,230
compile time and instead of printing

00:12:35,340 --> 00:12:41,670
cannot consume just get rid of the else

00:12:37,230 --> 00:12:43,530
that's it so it's an elite and analyze

00:12:41,670 --> 00:12:45,630
this technique step by step the first

00:12:43,530 --> 00:12:46,950
step is obviously calling consume so

00:12:45,630 --> 00:12:52,260
we're passing this value inside a

00:12:46,950 --> 00:12:55,140
function and after that we are going to

00:12:52,260 --> 00:12:57,210
look for a matching branch so we start

00:12:55,140 --> 00:12:58,830
at the top of the if and we test the

00:12:57,210 --> 00:13:02,160
condition if it's false we completely

00:12:58,830 --> 00:13:04,200
ignore the corresponding branch and as

00:13:02,160 --> 00:13:06,960
soon as we find a real valid condition

00:13:04,200 --> 00:13:08,880
then we don't care about anything else

00:13:06,960 --> 00:13:10,020
we found our branch we stopped there and

00:13:08,880 --> 00:13:13,710
this is what we're going to instantiate

00:13:10,020 --> 00:13:16,050
and call so this is a very nice

00:13:13,710 --> 00:13:18,630
animation take a look at static if and

00:13:16,050 --> 00:13:20,370
this what happens everything we don't

00:13:18,630 --> 00:13:22,770
care about that we're just collapsing

00:13:20,370 --> 00:13:25,650
the whole construct into a single lambda

00:13:22,770 --> 00:13:27,600
call so again we found our matching

00:13:25,650 --> 00:13:29,720
condition everything else we don't care

00:13:27,600 --> 00:13:32,130
about it we've got this lambda and this

00:13:29,720 --> 00:13:33,960
function call operator and we were just

00:13:32,130 --> 00:13:38,070
gonna you know stick them together and

00:13:33,960 --> 00:13:39,960
call the lambda so this is what happens

00:13:38,070 --> 00:13:42,420
the argument we pass to consume will be

00:13:39,960 --> 00:13:44,490
passed to the call and say static if and

00:13:42,420 --> 00:13:46,950
the static if call will forward that

00:13:44,490 --> 00:13:49,410
argument to the lambda and then this is

00:13:46,950 --> 00:13:51,930
practically what we get it's just the

00:13:49,410 --> 00:13:55,530
call inside the match branch we don't

00:13:51,930 --> 00:13:55,800
care about anything else oh sorry about

00:13:55,530 --> 00:13:57,810
that

00:13:55,800 --> 00:14:00,750
yeah FWD is just a macro for forward

00:13:57,810 --> 00:14:03,120
that I defined which gets uses the call

00:14:00,750 --> 00:14:06,770
type to get the types of the arguments

00:14:03,120 --> 00:14:06,770
you until specify that again it's just

00:14:06,790 --> 00:14:12,230
so I have another question for you why

00:14:09,619 --> 00:14:14,480
don't we just capture the variable

00:14:12,230 --> 00:14:17,089
instead of you know passing another one

00:14:14,480 --> 00:14:27,529
and calling it again does anybody know

00:14:17,089 --> 00:14:30,230
why sure exactly so we cannot capture

00:14:27,529 --> 00:14:33,019
both variables when using static if

00:14:30,230 --> 00:14:34,999
because we need to the very instant

00:14:33,019 --> 00:14:36,889
ation to a letter step if we had

00:14:34,999 --> 00:14:38,929
captured the variable the compare would

00:14:36,889 --> 00:14:41,689
generate something like this and since

00:14:38,929 --> 00:14:43,610
operator call is not templated this will

00:14:41,689 --> 00:14:45,619
get immediately instantiated and it will

00:14:43,610 --> 00:14:50,929
not compile because obviously we cannot

00:14:45,619 --> 00:14:53,629
eat juice we can only drink it okay so

00:14:50,929 --> 00:14:56,149
this was the slides part we'll get into

00:14:53,629 --> 00:14:58,100
the code and see some more interesting

00:14:56,149 --> 00:15:07,970
examples and then implementation of

00:14:58,100 --> 00:15:11,749
static if and iteration constructs okay

00:15:07,970 --> 00:15:14,179
hopefully you can see that okay so this

00:15:11,749 --> 00:15:16,399
is the example we just seen in the

00:15:14,179 --> 00:15:17,929
slides I just wanted to make it complete

00:15:16,399 --> 00:15:21,439
and as you can see here we have our

00:15:17,929 --> 00:15:24,379
classes here we are defining our fake

00:15:21,439 --> 00:15:26,959
concepts or manual concepts and then

00:15:24,379 --> 00:15:28,879
inside consume we have this static if

00:15:26,959 --> 00:15:31,759
construct and we're calling all the

00:15:28,879 --> 00:15:34,730
different methods if it matches the

00:15:31,759 --> 00:15:36,559
branch and our main looks like this so

00:15:34,730 --> 00:15:38,509
we're just calling consuming instances

00:15:36,559 --> 00:15:42,559
of every kind of food and if we compile

00:15:38,509 --> 00:15:44,480
it you can see that it compiles and it

00:15:42,559 --> 00:15:46,189
prints what we expect so for banana we

00:15:44,480 --> 00:15:48,429
will install it in liquid solid liquid

00:15:46,189 --> 00:15:51,470
and for in turn float we cannot consume

00:15:48,429 --> 00:15:53,269
if we add suppose plus 17 what you would

00:15:51,470 --> 00:15:55,309
write is much nicer but it's

00:15:53,269 --> 00:15:56,629
conceptually the same so this is what

00:15:55,309 --> 00:15:58,670
you would write in service plus 17

00:15:56,629 --> 00:16:00,920
you'll write if Const acts per the

00:15:58,670 --> 00:16:03,170
conditions and you can just have health

00:16:00,920 --> 00:16:05,149
for the default case and as you can see

00:16:03,170 --> 00:16:06,529
we avoid a lot of noise and we don't

00:16:05,149 --> 00:16:08,839
have two variables we just have the X

00:16:06,529 --> 00:16:12,559
and what the compiler does is it takes

00:16:08,839 --> 00:16:17,360
care of deferring the enunciation to a

00:16:12,559 --> 00:16:19,939
later step so let's take a look at

00:16:17,360 --> 00:16:22,399
implementation of static if

00:16:19,939 --> 00:16:24,829
firstly we will define some interesting

00:16:22,399 --> 00:16:26,869
snippets and alysus and stuff that's

00:16:24,829 --> 00:16:28,789
useful so this is this FWD macro that

00:16:26,869 --> 00:16:30,529
was talking about is just a city forward

00:16:28,789 --> 00:16:32,689
with deco type of the arguments of the

00:16:30,529 --> 00:16:35,689
macro and is passing them inside vehicle

00:16:32,689 --> 00:16:37,639
type inside for work oh I like this

00:16:35,689 --> 00:16:41,089
because it prevents you from having to

00:16:37,639 --> 00:16:42,619
repeat the argument types and it's also

00:16:41,089 --> 00:16:43,999
very nice when you use in generic

00:16:42,619 --> 00:16:46,609
lambdas so you don't have to say deco

00:16:43,999 --> 00:16:50,439
type of X and then X again it's just a

00:16:46,609 --> 00:16:54,169
simple macro then we'll define our bull

00:16:50,439 --> 00:16:55,970
compile-time variables so this is a type

00:16:54,169 --> 00:16:58,729
Alice from Super Plus 11 and this is a

00:16:55,970 --> 00:17:01,399
variable template for co-stars 14 if we

00:16:58,729 --> 00:17:04,009
define this we don't have to call to

00:17:01,399 --> 00:17:05,870
instantiate the bull type we can just

00:17:04,009 --> 00:17:08,870
say will be with a value inside the

00:17:05,870 --> 00:17:10,549
angle brackets and that's fine in sales

00:17:08,870 --> 00:17:12,889
plus 17 will have bull constant which

00:17:10,549 --> 00:17:16,669
can be used to replace this alias over

00:17:12,889 --> 00:17:18,500
here so my my static if implementation

00:17:16,669 --> 00:17:20,689
was inspired by this article hover here

00:17:18,500 --> 00:17:22,669
that you can check out later and also by

00:17:20,689 --> 00:17:25,579
the comments on its reddit thread and

00:17:22,669 --> 00:17:26,959
this following typical guidelines issues

00:17:25,579 --> 00:17:28,879
so it's just that mix and match of

00:17:26,959 --> 00:17:30,679
everything that's has been saved there

00:17:28,879 --> 00:17:32,059
and those are really interesting

00:17:30,679 --> 00:17:34,490
discussion so I really advise you to

00:17:32,059 --> 00:17:36,470
check them out if you're interested so

00:17:34,490 --> 00:17:37,850
the implementation is composed of three

00:17:36,470 --> 00:17:40,009
different things we have an interface

00:17:37,850 --> 00:17:41,990
that Akif function that will take a

00:17:40,009 --> 00:17:44,149
predicate and we return another struct

00:17:41,990 --> 00:17:46,519
and then we can call and we'll trigger

00:17:44,149 --> 00:17:48,830
the whole compile time branching stuff

00:17:46,519 --> 00:17:51,500
we will have an outburst rack called

00:17:48,830 --> 00:17:53,960
psych if in pull which will allow you to

00:17:51,500 --> 00:17:57,350
chain then and else and will eventually

00:17:53,960 --> 00:18:01,009
return a result when when a branch is

00:17:57,350 --> 00:18:02,659
fine is found and result struct is

00:18:01,009 --> 00:18:04,700
another implementation details which

00:18:02,659 --> 00:18:08,240
will ignore all the other chaining calls

00:18:04,700 --> 00:18:10,309
and it will give you the operator call

00:18:08,240 --> 00:18:11,929
of the branch that you have matched and

00:18:10,309 --> 00:18:13,879
as soon as you have that operator call

00:18:11,929 --> 00:18:17,629
you can instantly the lambda and call

00:18:13,879 --> 00:18:19,009
the function so the interface function

00:18:17,629 --> 00:18:21,769
will be called static if and it will

00:18:19,009 --> 00:18:23,570
take boolean constant as a parameter as

00:18:21,769 --> 00:18:25,970
you can see here instead of specifying

00:18:23,570 --> 00:18:27,649
the boolean directly in the template I'm

00:18:25,970 --> 00:18:29,929
using the type value encoding paradigm

00:18:27,649 --> 00:18:33,019
so I'm passing it as a value and then I

00:18:29,929 --> 00:18:33,740
can always check what the compile time

00:18:33,019 --> 00:18:35,390
value is

00:18:33,740 --> 00:18:36,710
because it's wrapped inside an interweb

00:18:35,390 --> 00:18:40,250
constant so that's that's a very

00:18:36,710 --> 00:18:42,020
powerful pattern and after that we will

00:18:40,250 --> 00:18:44,300
further declare our implementation

00:18:42,020 --> 00:18:48,350
struct which will take the result of the

00:18:44,300 --> 00:18:49,970
predicate and this will be used to this

00:18:48,350 --> 00:18:53,929
will be specialized depending on the

00:18:49,970 --> 00:18:55,340
result of the predicate afterwards we

00:18:53,929 --> 00:18:57,920
have another struct that's called static

00:18:55,340 --> 00:18:59,809
if result and it will be templated on

00:18:57,920 --> 00:19:02,390
the function to call which is the branch

00:18:59,809 --> 00:19:04,130
that we're passing to static it and we

00:19:02,390 --> 00:19:08,200
will actually use inheritance to expose

00:19:04,130 --> 00:19:10,760
the operator call of the function and

00:19:08,200 --> 00:19:12,440
before we get we get into the details

00:19:10,760 --> 00:19:15,559
let's reiterate to make it absolutely

00:19:12,440 --> 00:19:17,510
clear static its input will be returned

00:19:15,559 --> 00:19:19,130
by interface function and every instance

00:19:17,510 --> 00:19:21,050
of this static a simple represents a

00:19:19,130 --> 00:19:23,030
single branch the type will be

00:19:21,050 --> 00:19:25,670
specialized as you as you may recall

00:19:23,030 --> 00:19:27,850
it's a bull template depending on

00:19:25,670 --> 00:19:30,830
whether or not the predicate is matched

00:19:27,850 --> 00:19:33,080
static if result will ignore all the

00:19:30,830 --> 00:19:35,270
subsequent chaining methods will hinder

00:19:33,080 --> 00:19:38,150
it from the lambda which is our branch

00:19:35,270 --> 00:19:40,250
and it will have exposed the operator

00:19:38,150 --> 00:19:42,320
call in order to allow you to call the

00:19:40,250 --> 00:19:44,000
matching branch it will be returned by

00:19:42,320 --> 00:19:47,420
the true specialization of staticy

00:19:44,000 --> 00:19:49,460
simple if at then branches matches or by

00:19:47,420 --> 00:19:53,780
the fall specialization if announced

00:19:49,460 --> 00:19:55,970
branches matches so I also have this

00:19:53,780 --> 00:19:58,610
make static if resolved function here

00:19:55,970 --> 00:20:00,860
that allows you to do type deduction for

00:19:58,610 --> 00:20:02,540
the lambda which is pretty nice but we

00:20:00,860 --> 00:20:05,920
won't need it in suppose plus 17 thanks

00:20:02,540 --> 00:20:08,990
to the constructor template argument

00:20:05,920 --> 00:20:10,160
deduction how should we and here we have

00:20:08,990 --> 00:20:15,140
the specialization of our implementation

00:20:10,160 --> 00:20:18,380
struct so this will be instantiated when

00:20:15,140 --> 00:20:19,940
we find a matching true predicate if we

00:20:18,380 --> 00:20:21,679
found that we don't care about the else

00:20:19,940 --> 00:20:23,120
predicate so we can just ignore it we

00:20:21,679 --> 00:20:25,160
collapse it if you remember the

00:20:23,120 --> 00:20:28,700
animation it became transparent we don't

00:20:25,160 --> 00:20:30,230
care about it and we return the the same

00:20:28,700 --> 00:20:32,870
structure that we're actually checking

00:20:30,230 --> 00:20:34,490
now and the same for else if so if the

00:20:32,870 --> 00:20:36,110
breadth is the branch is true the

00:20:34,490 --> 00:20:39,110
predicate is true we don't care about

00:20:36,110 --> 00:20:41,600
you know anything that that we

00:20:39,110 --> 00:20:44,809
implemented to catch the false branch

00:20:41,600 --> 00:20:47,000
condition so what we care about is the

00:20:44,809 --> 00:20:49,640
fan which contains the matter

00:20:47,000 --> 00:20:51,410
in branch lambda in this case we we

00:20:49,640 --> 00:20:53,210
found we finally found our condition and

00:20:51,410 --> 00:20:55,250
we can return a result with the lambda

00:20:53,210 --> 00:20:56,840
that we're going to call and then just

00:20:55,250 --> 00:20:58,250
for one digit lambda into the function

00:20:56,840 --> 00:21:00,440
then we'll get something that exposes

00:20:58,250 --> 00:21:02,840
the coal operator for the fall

00:21:00,440 --> 00:21:05,630
specialization we don't care about them

00:21:02,840 --> 00:21:07,970
because the predicate is false we only

00:21:05,630 --> 00:21:10,430
care about else and else if so if we

00:21:07,970 --> 00:21:12,980
find else we will just return a result

00:21:10,430 --> 00:21:15,200
because we don't have any order else if

00:21:12,980 --> 00:21:16,970
that we have to check otherwise if we

00:21:15,200 --> 00:21:18,830
have else if we will just return a new

00:21:16,970 --> 00:21:21,740
static if that will check that predicate

00:21:18,830 --> 00:21:24,380
so it's kind of chaining together

00:21:21,740 --> 00:21:28,430
multiple study caves be behind a very

00:21:24,380 --> 00:21:30,590
nice interface and we also have to

00:21:28,430 --> 00:21:34,130
ignore operator call because as Jackie

00:21:30,590 --> 00:21:35,630
said if we don't have a default case we

00:21:34,130 --> 00:21:39,320
might actually have just a Nathan and

00:21:35,630 --> 00:21:43,400
Dan and we we are returning ourselves if

00:21:39,320 --> 00:21:46,310
we don't have another else so we need to

00:21:43,400 --> 00:21:50,810
ignore any possible call to D to learn a

00:21:46,310 --> 00:21:52,910
mesh branch the static if result is what

00:21:50,810 --> 00:21:54,350
will be returned in indicates that we

00:21:52,910 --> 00:21:57,320
find a matching branch or an else branch

00:21:54,350 --> 00:21:59,720
and it's very simple we're just getting

00:21:57,320 --> 00:22:02,030
our branch which is the lambda we are in

00:21:59,720 --> 00:22:04,390
rating from it so that it exposes the

00:22:02,030 --> 00:22:07,160
coal operator and we're forwarding the

00:22:04,390 --> 00:22:09,800
branch inside ourselves in order to

00:22:07,160 --> 00:22:11,720
initialize the lambda as soon as we find

00:22:09,800 --> 00:22:13,550
a result we ignore everything because

00:22:11,720 --> 00:22:15,530
all we want to do is call that that

00:22:13,550 --> 00:22:20,050
branch without you know caring about the

00:22:15,530 --> 00:22:22,070
rest of the static if construct and

00:22:20,050 --> 00:22:24,080
these are this syntactical sugar

00:22:22,070 --> 00:22:25,670
functions which are very simple this is

00:22:24,080 --> 00:22:28,640
just for type deduction to create the

00:22:25,670 --> 00:22:30,290
results and this is just to get the

00:22:28,640 --> 00:22:32,600
predicate as a value to make a nice

00:22:30,290 --> 00:22:35,150
function like interface and this will

00:22:32,600 --> 00:22:37,280
instance it implementation by expanding

00:22:35,150 --> 00:22:41,540
the compile time integral constant to a

00:22:37,280 --> 00:22:42,110
compile time boolean value everything

00:22:41,540 --> 00:22:48,500
clear so far

00:22:42,110 --> 00:22:49,970
feel free to ask questions okay nice so

00:22:48,500 --> 00:22:53,150
let's see some additional examples in

00:22:49,970 --> 00:22:54,140
the next Mexico segment hopefully there

00:22:53,150 --> 00:22:56,570
will be more interesting than the

00:22:54,140 --> 00:22:59,000
previous one so this something I had to

00:22:56,570 --> 00:23:00,310
incur encounter were calling a generic

00:22:59,000 --> 00:23:02,140
data structure

00:23:00,310 --> 00:23:04,420
to have this grow function and keep

00:23:02,140 --> 00:23:07,720
track of how many copies and moves I was

00:23:04,420 --> 00:23:09,820
doing and I wanted to check if the type

00:23:07,720 --> 00:23:12,130
I was copying to the new buffer was move

00:23:09,820 --> 00:23:14,230
constructible so instead of having two

00:23:12,130 --> 00:23:17,920
separate functions and maybe using an a

00:23:14,230 --> 00:23:19,930
belief or a third-party dependency what

00:23:17,920 --> 00:23:21,400
I did is have a single function I put

00:23:19,930 --> 00:23:23,260
the static if directory inside the

00:23:21,400 --> 00:23:25,180
copying loop I check if it 'smoke

00:23:23,260 --> 00:23:27,640
constructible then I increment my move

00:23:25,180 --> 00:23:29,920
counter and use STD move explicitly

00:23:27,640 --> 00:23:32,440
otherwise I increment my copy counter

00:23:29,920 --> 00:23:33,970
and you know just use a copy so as you

00:23:32,440 --> 00:23:35,650
can see this is very nice when you write

00:23:33,970 --> 00:23:37,540
in generic code where and you don't know

00:23:35,650 --> 00:23:39,130
the types you can just put inside your

00:23:37,540 --> 00:23:41,440
implementation function it just works

00:23:39,130 --> 00:23:45,310
well and doesn't pollute your code with

00:23:41,440 --> 00:23:47,170
in a belief and another stuff I also

00:23:45,310 --> 00:23:49,750
think static is extremely useful when

00:23:47,170 --> 00:23:51,510
writing compile time algorithms another

00:23:49,750 --> 00:23:55,330
thing I was doing for my thesis is

00:23:51,510 --> 00:23:58,420
creating a compile time fold and this is

00:23:55,330 --> 00:24:00,550
a left fold and I wanted to control the

00:23:58,420 --> 00:24:01,990
recursion without having to specify all

00:24:00,550 --> 00:24:03,250
the parameters again and maybe have a

00:24:01,990 --> 00:24:05,620
different lambda or a different

00:24:03,250 --> 00:24:07,720
interface function so what I did is I

00:24:05,620 --> 00:24:10,240
returned this fold function here which

00:24:07,720 --> 00:24:11,890
you don't have to care about the the

00:24:10,240 --> 00:24:13,540
good part is that I'm using static if to

00:24:11,890 --> 00:24:15,970
control the recursion so I'm checking

00:24:13,540 --> 00:24:18,340
through more items we have to fall down

00:24:15,970 --> 00:24:20,170
to and if there are not we can just

00:24:18,340 --> 00:24:21,580
return the base case and this works very

00:24:20,170 --> 00:24:25,470
well at compile time without any an

00:24:21,580 --> 00:24:28,570
extra function that's just avoids the

00:24:25,470 --> 00:24:30,820
the recursive case you can think of this

00:24:28,570 --> 00:24:33,010
like the very Attic part argument

00:24:30,820 --> 00:24:34,540
example that we seen in the slides it's

00:24:33,010 --> 00:24:36,640
slightly more complex and it's a compile

00:24:34,540 --> 00:24:39,790
time but I think this is way cleaner

00:24:36,640 --> 00:24:41,290
than having an explicit specialization

00:24:39,790 --> 00:24:48,940
and having to duplicate the function

00:24:41,290 --> 00:24:50,560
signature two times so yeah two again

00:24:48,940 --> 00:24:53,500
being able to branch in an almost

00:24:50,560 --> 00:24:55,960
imperative way in compile time code it's

00:24:53,500 --> 00:24:57,310
something that might be more familiar to

00:24:55,960 --> 00:25:00,670
programmers who are not experienced with

00:24:57,310 --> 00:25:02,860
functional programming and it's it can

00:25:00,670 --> 00:25:05,970
be subjective but again I really think

00:25:02,860 --> 00:25:07,960
it's cleaner in these contexts

00:25:05,970 --> 00:25:10,360
another common operation we do any

00:25:07,960 --> 00:25:11,920
project code is that for each loop so is

00:25:10,360 --> 00:25:13,900
there a way we could implement that at

00:25:11,920 --> 00:25:14,260
compile time as well and the answer is

00:25:13,900 --> 00:25:17,320
yes

00:25:14,260 --> 00:25:19,570
obviously so I'll start by analyzing

00:25:17,320 --> 00:25:22,150
this amazing for each argument snippet

00:25:19,570 --> 00:25:25,810
that Sean Penn posted on Twitter a few

00:25:22,150 --> 00:25:28,570
years ago and I've analyzed it already

00:25:25,810 --> 00:25:30,730
asleep young 2015 it's a 30-minute stop

00:25:28,570 --> 00:25:33,100
dedicated to that but I'll try to you

00:25:30,730 --> 00:25:34,960
know be short and show you this cool

00:25:33,100 --> 00:25:37,630
snippet there is that we have this

00:25:34,960 --> 00:25:40,090
function called four arcs that takes a

00:25:37,630 --> 00:25:43,240
callable object and a bunch of arguments

00:25:40,090 --> 00:25:46,960
and what we want to do is call F on

00:25:43,240 --> 00:25:49,360
every single argument so what do we do

00:25:46,960 --> 00:25:52,600
we use a steel initializer list event

00:25:49,360 --> 00:25:54,610
casted to void and inside that we call

00:25:52,600 --> 00:25:56,800
the function with the parameter pack by

00:25:54,610 --> 00:25:58,810
forwarding every single argument then we

00:25:56,800 --> 00:26:01,120
have the comma operator as zero and

00:25:58,810 --> 00:26:02,980
we're expanding the things inside the

00:26:01,120 --> 00:26:04,360
initializer list so this seems really

00:26:02,980 --> 00:26:06,370
contrived if you haven't seen the

00:26:04,360 --> 00:26:08,950
sleeper before but it's conceptually

00:26:06,370 --> 00:26:11,440
very simple so the initializer list is

00:26:08,950 --> 00:26:13,840
here because we need a context where we

00:26:11,440 --> 00:26:15,970
can expand the very attic pack in order

00:26:13,840 --> 00:26:20,110
to have the left to right a guaranteed

00:26:15,970 --> 00:26:21,640
execution order we are using we are

00:26:20,110 --> 00:26:23,950
calling the function on every single

00:26:21,640 --> 00:26:26,500
element here by forwarding the element

00:26:23,950 --> 00:26:28,210
as the argument of the function but

00:26:26,500 --> 00:26:31,470
since our initializer list is of type

00:26:28,210 --> 00:26:34,360
int we want this function call to

00:26:31,470 --> 00:26:35,950
evaluate to a valid into expression so

00:26:34,360 --> 00:26:39,910
that's where why we're using the comma

00:26:35,950 --> 00:26:41,680
operator here and after evaluating every

00:26:39,910 --> 00:26:43,390
single call to an int expression we're

00:26:41,680 --> 00:26:44,530
using the ellipsis operator to expand

00:26:43,390 --> 00:26:46,870
everything inside the initializer list

00:26:44,530 --> 00:26:49,090
so in the end the initializer list is

00:26:46,870 --> 00:26:51,670
just for 12 pass expand the function

00:26:49,090 --> 00:26:55,900
calls and it's just an implementation

00:26:51,670 --> 00:26:58,150
detail so if this is not clear this is

00:26:55,900 --> 00:27:00,310
an example for for article which is

00:26:58,150 --> 00:27:02,890
taking a callable object that will just

00:27:00,310 --> 00:27:04,930
forward the argument to see out and here

00:27:02,890 --> 00:27:06,310
were passing hit your genius values we

00:27:04,930 --> 00:27:09,520
have a string and a bunch of ends and

00:27:06,310 --> 00:27:13,390
what we expect is to print hello 1 2 3 2

00:27:09,520 --> 00:27:14,920
st out and this roughly expands to this

00:27:13,390 --> 00:27:17,220
crazy thing over here

00:27:14,920 --> 00:27:20,110
it's analyzer lists casted to void

00:27:17,220 --> 00:27:22,690
containing four elements and every

00:27:20,110 --> 00:27:25,800
element is a call of the color object we

00:27:22,690 --> 00:27:28,060
passed with a comma and 0 in order to

00:27:25,800 --> 00:27:30,040
evaluate to a valid end

00:27:28,060 --> 00:27:32,200
and since instead underneath a large

00:27:30,040 --> 00:27:33,850
list we're guaranteed to be to have a

00:27:32,200 --> 00:27:35,650
left to right evaluation order this will

00:27:33,850 --> 00:27:37,810
do what we want it will print hello one

00:27:35,650 --> 00:27:39,820
two three and the comb operator will

00:27:37,810 --> 00:27:42,340
allow it to be via the compile time

00:27:39,820 --> 00:27:43,990
because it's they're actually int so

00:27:42,340 --> 00:27:46,630
they can be inside the initializer list

00:27:43,990 --> 00:27:49,270
and this is the same as writing a CD out

00:27:46,630 --> 00:27:51,160
hello one two three so this is a zero

00:27:49,270 --> 00:27:53,350
overhead obstruction that you can use to

00:27:51,160 --> 00:27:58,920
call a function over an entire genus set

00:27:53,350 --> 00:28:01,660
of values just to show you a possible

00:27:58,920 --> 00:28:03,130
example there is a call of the frogs

00:28:01,660 --> 00:28:05,220
function with the same arguments as we

00:28:03,130 --> 00:28:11,200
seen before and if I compile that

00:28:05,220 --> 00:28:15,190
hopefully it will print what we expect L

00:28:11,200 --> 00:28:17,350
1 2 3 s in see also 17 again this will

00:28:15,190 --> 00:28:19,630
be much cleaner this is the

00:28:17,350 --> 00:28:21,820
implementation see what 417 is just a

00:28:19,630 --> 00:28:24,580
fold expression over the comma operator

00:28:21,820 --> 00:28:26,530
and fold expressions guarantee left to

00:28:24,580 --> 00:28:28,300
right evaluation order so that's all you

00:28:26,530 --> 00:28:44,820
need to do in order to call a function

00:28:28,300 --> 00:28:47,860
of aerobatic back sure question okay so

00:28:44,820 --> 00:28:49,540
the question is that they have a similar

00:28:47,860 --> 00:28:51,520
implementation of four arcs in their

00:28:49,540 --> 00:28:53,170
company and what did is they returned F

00:28:51,520 --> 00:28:55,210
at the end of the function in order you

00:28:53,170 --> 00:28:56,140
know to be more composable and I agree

00:28:55,210 --> 00:28:58,600
with that that's probably a better

00:28:56,140 --> 00:29:01,120
solution because it's similar to a CD

00:28:58,600 --> 00:29:03,790
for each or CD that allows you you know

00:29:01,120 --> 00:29:06,460
to mutate the functor and then do

00:29:03,790 --> 00:29:08,100
something after yeah so an alternative a

00:29:06,460 --> 00:29:10,120
better alternative will be returning the

00:29:08,100 --> 00:29:13,000
decodable object that you pass to for

00:29:10,120 --> 00:29:14,290
arcs so you want to learn more about for

00:29:13,000 --> 00:29:16,320
the expression just go and see BP

00:29:14,290 --> 00:29:20,170
reference it's a very concise and

00:29:16,320 --> 00:29:22,870
well-written PI page and in an Xcode

00:29:20,170 --> 00:29:27,460
segment will exploit four arcs for

00:29:22,870 --> 00:29:30,370
compile-time iteration so this is how it

00:29:27,460 --> 00:29:31,810
looks like without comments and you can

00:29:30,370 --> 00:29:34,090
see why it fits in a tweet

00:29:31,810 --> 00:29:39,340
it's very short very concise and very

00:29:34,090 --> 00:29:41,020
cryptic so this is an example I came up

00:29:39,340 --> 00:29:41,980
with let's say we have a template called

00:29:41,020 --> 00:29:43,809
buffer the

00:29:41,980 --> 00:29:46,179
it's templated over a number of bytes

00:29:43,809 --> 00:29:49,059
and we can allocate and deallocate the

00:29:46,179 --> 00:29:52,120
buffer this totally valid allocation

00:29:49,059 --> 00:29:53,620
de-allocation code and we will write to

00:29:52,120 --> 00:29:55,539
run some tests with different amounts of

00:29:53,620 --> 00:29:58,000
bytes without having to write a lot of

00:29:55,539 --> 00:30:01,570
repetition and you know just have a nice

00:29:58,000 --> 00:30:02,919
for loop so if we had a runtime buffer

00:30:01,570 --> 00:30:03,639
where we can allocate the number of

00:30:02,919 --> 00:30:05,350
bytes at runtime

00:30:03,639 --> 00:30:10,210
this is what you were right you have a

00:30:05,350 --> 00:30:13,210
range for over a set of numbers you will

00:30:10,210 --> 00:30:14,830
allocate a buffer we will perform a test

00:30:13,210 --> 00:30:16,269
and then the allocate this is very clean

00:30:14,830 --> 00:30:18,159
very straightforward in order to do that

00:30:16,269 --> 00:30:20,649
a compile time we need to generate this

00:30:18,159 --> 00:30:23,230
code somehow so for arts cannot do

00:30:20,649 --> 00:30:25,029
cannot pass doing that if you remember

00:30:23,230 --> 00:30:26,919
our previous static of implementation we

00:30:25,029 --> 00:30:29,409
use something similar to boot constant

00:30:26,919 --> 00:30:31,179
to wrap a boolean value inside a compile

00:30:29,409 --> 00:30:31,720
time wrapper we can do the same with

00:30:31,179 --> 00:30:34,299
numbers

00:30:31,720 --> 00:30:36,309
we can have a size T interval constant

00:30:34,299 --> 00:30:38,940
and its own constructed variable

00:30:36,309 --> 00:30:42,669
template and we can wrap a value inside

00:30:38,940 --> 00:30:45,850
this construct value this way we can

00:30:42,669 --> 00:30:49,000
actually iterate using for arcs over all

00:30:45,850 --> 00:30:50,980
values here and every single szv

00:30:49,000 --> 00:30:54,610
instantiation is a different type that

00:30:50,980 --> 00:30:56,110
will contain the size T value and inside

00:30:54,610 --> 00:30:59,080
our function here we can just call

00:30:56,110 --> 00:31:01,059
buffer angle brackets oops angle

00:30:59,080 --> 00:31:02,620
brackets with n and it will unwrap the

00:31:01,059 --> 00:31:04,299
value for us and essentially it at

00:31:02,620 --> 00:31:06,880
compile time with the correct amount of

00:31:04,299 --> 00:31:09,039
bytes so this is not as clean as the

00:31:06,880 --> 00:31:11,110
runtime test but it's very similar

00:31:09,039 --> 00:31:13,269
conceptually you just have a bunch of

00:31:11,110 --> 00:31:14,649
values you are iterating over and for

00:31:13,269 --> 00:31:16,059
every value you're doing something in

00:31:14,649 --> 00:31:17,909
compile time which is instant serial

00:31:16,059 --> 00:31:19,809
buffer with that amount of bytes and

00:31:17,909 --> 00:31:22,809
allocating the allocating and performing

00:31:19,809 --> 00:31:24,669
your test so it's not as pretty as the

00:31:22,809 --> 00:31:26,380
runtime version but if you want to make

00:31:24,669 --> 00:31:28,919
it prettier you can use some addition of

00:31:26,380 --> 00:31:31,029
instructions and maybe have a for values

00:31:28,919 --> 00:31:33,340
function here that takes a bunch of

00:31:31,029 --> 00:31:35,440
values it will wrap them for you inside

00:31:33,340 --> 00:31:39,159
an integral constant and then do do

00:31:35,440 --> 00:31:40,690
something with a callable object so is

00:31:39,159 --> 00:31:43,830
this pattern clear to everyone about

00:31:40,690 --> 00:31:43,830
yeah sure question

00:31:48,040 --> 00:31:53,750
okay the question is why do you need

00:31:51,140 --> 00:31:56,030
this compiled time as we were up there

00:31:53,750 --> 00:31:59,080
instead of passing the integers directly

00:31:56,030 --> 00:32:01,730
so if you pass the integers directly and

00:31:59,080 --> 00:32:03,680
you lose the compiled time information

00:32:01,730 --> 00:32:05,870
about the value of the integer it's just

00:32:03,680 --> 00:32:08,240
an int you don't have that information

00:32:05,870 --> 00:32:12,050
at compile time what we want to do is

00:32:08,240 --> 00:32:14,090
not pass an int but an 1/8 a 16 and 32

00:32:12,050 --> 00:32:16,010
at compile time in order to do that we

00:32:14,090 --> 00:32:17,930
need to capture that information and

00:32:16,010 --> 00:32:19,730
wrap into something that can hold it at

00:32:17,930 --> 00:32:22,640
compile time and then we can unwrap it

00:32:19,730 --> 00:32:25,100
later so if you pass hate here when you

00:32:22,640 --> 00:32:26,980
get here inside the lambda and you try

00:32:25,100 --> 00:32:29,930
to make sense it buffer it will not work

00:32:26,980 --> 00:32:33,200
because this is like runtime information

00:32:29,930 --> 00:32:36,140
it's not a valid compile time value if

00:32:33,200 --> 00:32:37,880
it's not clear yet think of it in terms

00:32:36,140 --> 00:32:39,380
of types what if you wanted to

00:32:37,880 --> 00:32:41,330
instantiate a buffer with a specific

00:32:39,380 --> 00:32:43,820
type you need like to wrap the type

00:32:41,330 --> 00:32:49,130
inside an order like type constant and

00:32:43,820 --> 00:32:51,260
then pass it to the buffer okay let's

00:32:49,130 --> 00:32:52,960
move forward and we'll see an example of

00:32:51,260 --> 00:32:57,620
using static if and four arcs together

00:32:52,960 --> 00:32:59,300
so let's say that we have as we're just

00:32:57,620 --> 00:33:01,940
saying we want to iterate over different

00:32:59,300 --> 00:33:04,460
types and what we can do is the final

00:33:01,940 --> 00:33:06,920
type wrapper which will be a simple

00:33:04,460 --> 00:33:09,020
template struct over here containing the

00:33:06,920 --> 00:33:11,030
type and we also define a concept

00:33:09,020 --> 00:33:13,160
variable template that will allow us to

00:33:11,030 --> 00:33:14,900
pass it around as a value so what we're

00:33:13,160 --> 00:33:17,000
doing we're wrapping a type inside of a

00:33:14,900 --> 00:33:18,950
value and this is an empty value it's

00:33:17,000 --> 00:33:20,660
really nothing at runtime it's just a

00:33:18,950 --> 00:33:23,600
wrapper for us to play with at a compile

00:33:20,660 --> 00:33:25,700
time and we also have this kind of

00:33:23,600 --> 00:33:28,580
utility mehta function called unwrap

00:33:25,700 --> 00:33:32,450
that will take a rock type and it will

00:33:28,580 --> 00:33:32,930
unwrap it for us and these are you can

00:33:32,450 --> 00:33:35,240
use it

00:33:32,930 --> 00:33:38,270
imagine you have a couple of vectors

00:33:35,240 --> 00:33:39,950
which is a set of buffers and you want

00:33:38,270 --> 00:33:42,110
to do something on every buffer all at

00:33:39,950 --> 00:33:44,030
once maybe if you had suppose for 17 you

00:33:42,110 --> 00:33:45,890
would use a CD apply in order to apply

00:33:44,030 --> 00:33:48,080
the double inside a function do

00:33:45,890 --> 00:33:50,930
something with that but another approach

00:33:48,080 --> 00:33:52,900
is just iterating over types getting the

00:33:50,930 --> 00:33:55,610
corresponding buffer from the topple and

00:33:52,900 --> 00:33:58,330
performing an action over that and we

00:33:55,610 --> 00:34:00,559
can do that before arts so these are

00:33:58,330 --> 00:34:04,039
frogs call here

00:34:00,559 --> 00:34:06,440
where we're passing a very alikum ount

00:34:04,039 --> 00:34:08,690
of rap types because if you remember

00:34:06,440 --> 00:34:10,819
those are actually values or those are

00:34:08,690 --> 00:34:13,629
empty values but they contain compile

00:34:10,819 --> 00:34:16,940
time information important for us and

00:34:13,629 --> 00:34:18,470
every single type is going to get passed

00:34:16,940 --> 00:34:21,200
inside a lambda so it's going to take

00:34:18,470 --> 00:34:23,510
the value of T when we have when we are

00:34:21,200 --> 00:34:26,000
inside the lambda body we can unwrap the

00:34:23,510 --> 00:34:28,970
type and get the real T which in this

00:34:26,000 --> 00:34:30,800
case is int float or double and after

00:34:28,970 --> 00:34:33,139
that we can use a city get to get the

00:34:30,800 --> 00:34:34,129
corresponding vector and maybe resize it

00:34:33,139 --> 00:34:36,500
or do something on it

00:34:34,129 --> 00:34:38,119
so as you can see by wrapping values in

00:34:36,500 --> 00:34:40,210
two types and by wrapping types in two

00:34:38,119 --> 00:34:42,169
values you can iterate over numbers

00:34:40,210 --> 00:34:43,819
types or whatever you want a

00:34:42,169 --> 00:34:46,040
compile-time and I think this is really

00:34:43,819 --> 00:34:49,970
powerful because it doesn't look too far

00:34:46,040 --> 00:34:51,919
off from a runtime loop and again the

00:34:49,970 --> 00:34:54,200
same concept as static it applies it's

00:34:51,919 --> 00:34:58,520
localized easier to reason about and

00:34:54,200 --> 00:35:00,290
easier to read in my opinion if you

00:34:58,520 --> 00:35:01,880
combine this function I we static if you

00:35:00,290 --> 00:35:04,400
can I'm really powerful and simple

00:35:01,880 --> 00:35:06,170
algorithms let's say we have a to

00:35:04,400 --> 00:35:07,670
function want to initialize a small

00:35:06,170 --> 00:35:10,190
object storage and want to initialize a

00:35:07,670 --> 00:35:12,319
big object storage and we want to check

00:35:10,190 --> 00:35:14,300
out compile time whether or not a set of

00:35:12,319 --> 00:35:17,089
types is bigger than a certain threshold

00:35:14,300 --> 00:35:18,609
and switch upon the threshold in order

00:35:17,089 --> 00:35:21,200
to initialize a small or a big storage

00:35:18,609 --> 00:35:23,540
so what we will do is have this four

00:35:21,200 --> 00:35:25,069
arcs here we have a bunch of types over

00:35:23,540 --> 00:35:28,310
here as you can see you have an int

00:35:25,069 --> 00:35:32,060
float double and an array and inside the

00:35:28,310 --> 00:35:34,780
for arts lambda body we can unwrap or

00:35:32,060 --> 00:35:37,750
type check if the unwrap type is

00:35:34,780 --> 00:35:39,920
matching your threshold and in this case

00:35:37,750 --> 00:35:41,990
either initialize the small object

00:35:39,920 --> 00:35:43,579
storage or the big object storage so by

00:35:41,990 --> 00:35:45,099
convening combining these two constructs

00:35:43,579 --> 00:35:47,599
together you can get really clean

00:35:45,099 --> 00:35:49,700
compile time algorithms and codes that

00:35:47,599 --> 00:35:51,349
you know it's pretty easy to read it's

00:35:49,700 --> 00:35:56,900
just like the runtime version but this

00:35:51,349 --> 00:35:58,970
is all happening at compile time so for

00:35:56,900 --> 00:36:00,980
for our this is very very cool but there

00:35:58,970 --> 00:36:02,480
are so many limitations it's not

00:36:00,980 --> 00:36:04,280
possible to get the current iteration

00:36:02,480 --> 00:36:07,460
index easily you need to pass it

00:36:04,280 --> 00:36:09,049
alongside your arguments it's it's also

00:36:07,460 --> 00:36:11,740
not possible to produce a result value

00:36:09,049 --> 00:36:14,190
and there are no break and continue

00:36:11,740 --> 00:36:16,290
equivalents to the compile time

00:36:14,190 --> 00:36:18,240
so what are we going to implement is

00:36:16,290 --> 00:36:20,820
another version of static iteration

00:36:18,240 --> 00:36:22,590
called static 4 which will be internal

00:36:20,820 --> 00:36:25,730
implement expose 14 and will allow you

00:36:22,590 --> 00:36:29,370
to do all of those things

00:36:25,730 --> 00:36:31,020
static 4 compared to 4 arts will indeed

00:36:29,370 --> 00:36:32,910
add the ability to get the current

00:36:31,020 --> 00:36:34,770
iteration index as a compile time number

00:36:32,910 --> 00:36:37,140
it will give you the possibility to

00:36:34,770 --> 00:36:39,870
produce an output value so an

00:36:37,140 --> 00:36:41,970
accumulator and it will allow you to

00:36:39,870 --> 00:36:44,600
break and continue out of the loop quite

00:36:41,970 --> 00:36:46,770
easily so if you are familiar with

00:36:44,600 --> 00:36:49,950
functional programming this is just a

00:36:46,770 --> 00:36:53,130
glorified fault the idea is that we're

00:36:49,950 --> 00:36:54,930
trading off compilation times in order

00:36:53,130 --> 00:36:57,350
to use our recursive implementation so

00:36:54,930 --> 00:37:00,170
that we can have all this nice sugar

00:36:57,350 --> 00:37:02,520
because with for arts we get the

00:37:00,170 --> 00:37:04,770
ellipsis operator so it's expanded by

00:37:02,520 --> 00:37:06,030
the compiler which is very quick but if

00:37:04,770 --> 00:37:08,160
you want to do this stuff we need to

00:37:06,030 --> 00:37:10,050
recurse so it's going to be a little

00:37:08,160 --> 00:37:11,400
more impactful on compile times but it's

00:37:10,050 --> 00:37:12,930
more powerful so those are two

00:37:11,400 --> 00:37:16,320
alternatives depending on what you want

00:37:12,930 --> 00:37:18,810
to do so before diving into the

00:37:16,320 --> 00:37:20,340
implementation let's see a very

00:37:18,810 --> 00:37:21,750
contracts ample that will show you

00:37:20,340 --> 00:37:24,330
everything that you we can do with

00:37:21,750 --> 00:37:26,430
static 4 so we'll write a static 4 that

00:37:24,330 --> 00:37:28,680
will accept any number of compile time

00:37:26,430 --> 00:37:30,480
numerical values it will accumulate the

00:37:28,680 --> 00:37:33,510
numbers and return our results at

00:37:30,480 --> 00:37:36,930
compile time so the sum of all numbers

00:37:33,510 --> 00:37:39,270
in a compile time wrapped value and it

00:37:36,930 --> 00:37:41,220
will print every even number and I

00:37:39,270 --> 00:37:42,960
trashed in index and will it will

00:37:41,220 --> 00:37:45,210
immediately break when we find this

00:37:42,960 --> 00:37:49,200
strange sentinel value which is minus

00:37:45,210 --> 00:37:51,660
999 so the idea is the static work study

00:37:49,200 --> 00:37:53,490
forwards by passing its current state as

00:37:51,660 --> 00:37:55,410
a parameter to the to the loop body

00:37:53,490 --> 00:37:58,050
every iteration and you can query this

00:37:55,410 --> 00:37:59,940
day to get the current iteration the

00:37:58,050 --> 00:38:02,310
next action that we will happen which is

00:37:59,940 --> 00:38:03,600
either continue or break and you can

00:38:02,310 --> 00:38:06,210
also access the accumulator variable

00:38:03,600 --> 00:38:10,080
that you can override with your new

00:38:06,210 --> 00:38:11,730
value inside the for loop body so this

00:38:10,080 --> 00:38:15,330
is how it looks like we have this static

00:38:11,730 --> 00:38:17,400
for function and the body is a lambda

00:38:15,330 --> 00:38:19,320
that will take two parameters the first

00:38:17,400 --> 00:38:21,090
one is the state of the static for and

00:38:19,320 --> 00:38:24,600
the second one is the current argument

00:38:21,090 --> 00:38:26,700
we're iterating upon and since GCC

00:38:24,600 --> 00:38:27,450
doesn't really like when we use state

00:38:26,700 --> 00:38:30,329
and

00:38:27,450 --> 00:38:33,930
inside a construction constant context

00:38:30,329 --> 00:38:35,670
sorry we need to use this kind of weird

00:38:33,930 --> 00:38:37,950
pattern where we take the type of the

00:38:35,670 --> 00:38:41,099
state and immediately instantiate it in

00:38:37,950 --> 00:38:43,500
order to get across x-value clank does

00:38:41,099 --> 00:38:45,540
not force you to do this but it's just a

00:38:43,500 --> 00:38:46,980
workaround in order to take this value

00:38:45,540 --> 00:38:49,290
and convert it to something that I can

00:38:46,980 --> 00:38:51,530
be you can use a compile-time and we are

00:38:49,290 --> 00:38:53,430
not losing any information because

00:38:51,530 --> 00:38:55,260
everything is in the compile time

00:38:53,430 --> 00:38:59,099
wrapper so there is nothing we're losing

00:38:55,260 --> 00:39:01,230
by race and simply type again so we can

00:38:59,099 --> 00:39:04,440
also assign names to our predicate so

00:39:01,230 --> 00:39:06,809
the must break predicate is when our X

00:39:04,440 --> 00:39:09,450
is equal to the weird sentinel value

00:39:06,809 --> 00:39:12,510
that which shows and even predicate is

00:39:09,450 --> 00:39:16,230
obviously when X when the remainder of X

00:39:12,510 --> 00:39:18,000
+ 2 is 0 now we can check if we have to

00:39:16,230 --> 00:39:21,960
break and if we have to break we will

00:39:18,000 --> 00:39:23,940
use return state or break so we need to

00:39:21,960 --> 00:39:25,410
we need a way of telling the for

00:39:23,940 --> 00:39:26,819
iteration that we want to break

00:39:25,410 --> 00:39:29,220
immediately so we're going to return

00:39:26,819 --> 00:39:30,990
this special value that will be caught

00:39:29,220 --> 00:39:34,950
by the implementation I will stop

00:39:30,990 --> 00:39:37,859
iterating otherwise we will have a

00:39:34,950 --> 00:39:39,720
neuropsych if here that we'll check if

00:39:37,859 --> 00:39:41,339
the number is even and if it's even we

00:39:39,720 --> 00:39:44,220
will print something to us to be out and

00:39:41,339 --> 00:39:46,079
that will be the iteration the current

00:39:44,220 --> 00:39:48,290
index of the for which is stored inside

00:39:46,079 --> 00:39:51,990
the state and the number itself

00:39:48,290 --> 00:39:54,329
otherwise we will continue iterating and

00:39:51,990 --> 00:39:56,790
we will increase our accumulator with

00:39:54,329 --> 00:39:58,799
the current value so all of this is a

00:39:56,790 --> 00:40:00,299
lot to take in but I wanted to show you

00:39:58,799 --> 00:40:02,700
an example that uses every possible

00:40:00,299 --> 00:40:04,530
feature of static for and in the end

00:40:02,700 --> 00:40:06,030
this is just a very glorified fault that

00:40:04,530 --> 00:40:09,960
has a lot of syntactical sugar for you

00:40:06,030 --> 00:40:12,390
to use inside the loop body you can see

00:40:09,960 --> 00:40:14,730
that we can also produce runtime side

00:40:12,390 --> 00:40:16,859
effects so this is not a purely compile

00:40:14,730 --> 00:40:18,540
time construct you can get a compile

00:40:16,859 --> 00:40:20,400
time result but while you're iterating

00:40:18,540 --> 00:40:22,260
you can also produce an generate code

00:40:20,400 --> 00:40:24,150
that will be run at runtime so in this

00:40:22,260 --> 00:40:26,490
case we're printing stuff and also

00:40:24,150 --> 00:40:27,930
getting a compile time accumulated value

00:40:26,490 --> 00:40:32,369
that you can use in order compile time

00:40:27,930 --> 00:40:34,920
algorithms the above code is slightly

00:40:32,369 --> 00:40:37,410
equivalent to this run time generator so

00:40:34,920 --> 00:40:40,470
what we're doing is we're catching an

00:40:37,410 --> 00:40:41,070
accumulator and binding it these are

00:40:40,470 --> 00:40:43,350
initial

00:40:41,070 --> 00:40:45,330
value then we returning a very attic

00:40:43,350 --> 00:40:48,390
lambda that takes a bunch of values and

00:40:45,330 --> 00:40:49,920
for every value we are doing the same

00:40:48,390 --> 00:40:52,500
thing we were doing the static for we're

00:40:49,920 --> 00:40:54,750
breaking on our Sentinel value we're

00:40:52,500 --> 00:40:56,910
keeping track of the iteration and we're

00:40:54,750 --> 00:40:59,010
printing if the number is even and we're

00:40:56,910 --> 00:41:01,530
accumulating the value and incremented

00:40:59,010 --> 00:41:03,840
iteration as you can see this is way

00:41:01,530 --> 00:41:05,700
easier to read but conceptually is the

00:41:03,840 --> 00:41:07,500
same control flow so we have the same

00:41:05,700 --> 00:41:09,990
structure for a static four and a

00:41:07,500 --> 00:41:13,920
runtime for the price we have to pay is

00:41:09,990 --> 00:41:15,210
obviously syntactical clarity but if you

00:41:13,920 --> 00:41:17,250
know how to write a compiler

00:41:15,210 --> 00:41:18,750
sorryi runtime for you know how to write

00:41:17,250 --> 00:41:24,390
a compile time four and that's the point

00:41:18,750 --> 00:41:27,090
of this of this talk so we actually are

00:41:24,390 --> 00:41:29,760
using kering here to make it a lot more

00:41:27,090 --> 00:41:31,680
flexible the first call to static four

00:41:29,760 --> 00:41:34,560
will take the body of the lambda and

00:41:31,680 --> 00:41:36,480
simply return a wrapper that wrapped up

00:41:34,560 --> 00:41:38,790
body so we can call it multiple times

00:41:36,480 --> 00:41:42,150
the second call will take an initial

00:41:38,790 --> 00:41:44,190
accumulator and will not yet called will

00:41:42,150 --> 00:41:46,020
not yet start the iteration so this is

00:41:44,190 --> 00:41:48,450
just binding the body and binding the

00:41:46,020 --> 00:41:49,830
accumulator and we can set this aside

00:41:48,450 --> 00:41:51,930
and we can call it multiple times with

00:41:49,830 --> 00:41:55,170
different argument paths finally the

00:41:51,930 --> 00:41:56,730
third call we'll have our own body we'll

00:41:55,170 --> 00:41:58,260
have the initial accumulator and we'll

00:41:56,730 --> 00:42:00,870
have the very attic pack and this is

00:41:58,260 --> 00:42:02,580
where the iteration will start over this

00:42:00,870 --> 00:42:06,450
body with this initial accumulation

00:42:02,580 --> 00:42:08,430
value so we do it this way because it's

00:42:06,450 --> 00:42:10,560
a lot more flexible let's say that you

00:42:08,430 --> 00:42:12,570
want to call the same body with the

00:42:10,560 --> 00:42:14,190
circulation value multiple times with

00:42:12,570 --> 00:42:16,590
different argument paths you can just

00:42:14,190 --> 00:42:18,600
bind those and then call the result of

00:42:16,590 --> 00:42:21,570
that with different arguments so it's

00:42:18,600 --> 00:42:23,160
pretty powerful as an example we are

00:42:21,570 --> 00:42:25,320
taking our print even accumulate

00:42:23,160 --> 00:42:28,680
function that was the example we seen

00:42:25,320 --> 00:42:30,060
before and we're binding the initial 0

00:42:28,680 --> 00:42:31,950
value to the accumulator in this

00:42:30,060 --> 00:42:33,770
variable over here and then we can call

00:42:31,950 --> 00:42:36,120
this variable with a bunch of values

00:42:33,770 --> 00:42:38,610
multiple times and the result of that

00:42:36,120 --> 00:42:41,820
will be a compile-time value that will

00:42:38,610 --> 00:42:43,430
sum all these types together and you

00:42:41,820 --> 00:42:45,540
know it will do the usual logic of

00:42:43,430 --> 00:42:49,080
breaking if we get our sentinel value

00:42:45,540 --> 00:42:51,360
and it will print even numbers so as an

00:42:49,080 --> 00:42:52,740
example i'm calling both the compile

00:42:51,360 --> 00:42:54,930
time version of the loop and a runtime

00:42:52,740 --> 00:42:56,520
version of the loop and just checking if

00:42:54,930 --> 00:42:58,500
values the returned are the same in

00:42:56,520 --> 00:43:00,420
order to make sure that the control flow

00:42:58,500 --> 00:43:04,460
be logically the same we can compile

00:43:00,420 --> 00:43:04,460
that and hopefully it will work

00:43:04,970 --> 00:43:10,349
okay yes as you can see we get the even

00:43:08,549 --> 00:43:11,730
number printed in both versions and we

00:43:10,349 --> 00:43:14,130
get the same compile-time and run-time

00:43:11,730 --> 00:43:15,660
result the important thing is that you

00:43:14,130 --> 00:43:17,130
can use this compiler and result which

00:43:15,660 --> 00:43:18,480
is the accumulation of the value in any

00:43:17,130 --> 00:43:21,240
other compile time algorithm because

00:43:18,480 --> 00:43:23,430
it's wrapped inside integral constant

00:43:21,240 --> 00:43:25,730
well in the runtime value you lose

00:43:23,430 --> 00:43:28,140
obviously the compile time information

00:43:25,730 --> 00:43:29,490
so we will implement static for from

00:43:28,140 --> 00:43:32,039
scratch in the next code segment before

00:43:29,490 --> 00:43:33,750
we do that I want to make sure that it

00:43:32,039 --> 00:43:36,089
is clear what's happening so if you have

00:43:33,750 --> 00:43:47,339
any question or any doubt please feel

00:43:36,089 --> 00:43:51,029
free to ask sure so the question is

00:43:47,339 --> 00:43:52,319
could you use fault expressions okay now

00:43:51,029 --> 00:43:54,029
you couldn't use full the expressions

00:43:52,319 --> 00:43:57,569
because you have no way of breaking out

00:43:54,029 --> 00:44:00,240
of it and also no way of getting the

00:43:57,569 --> 00:44:02,010
iteration index if you think about it

00:44:00,240 --> 00:44:04,230
the previous code snippet the for art

00:44:02,010 --> 00:44:06,630
snippet is actually a fold expression

00:44:04,230 --> 00:44:09,059
instead of a 17 so that's the trade-off

00:44:06,630 --> 00:44:10,319
you have to pay you either use something

00:44:09,059 --> 00:44:12,180
that gets expanded by they compared

00:44:10,319 --> 00:44:14,250
directly and it's very fast at compile

00:44:12,180 --> 00:44:17,119
time or use a recursive solution that

00:44:14,250 --> 00:44:24,089
allows you to do more stuff basically

00:44:17,119 --> 00:44:25,380
sure the question is is there any way

00:44:24,089 --> 00:44:28,349
this could generate a really crappy

00:44:25,380 --> 00:44:31,910
runtime code no I did as I tested

00:44:28,349 --> 00:44:34,289
compiling to assembly and with

00:44:31,910 --> 00:44:36,359
optimization level 1 for GCC and

00:44:34,289 --> 00:44:38,400
optimization level 2 for clang it

00:44:36,359 --> 00:44:44,839
completely goes away it's just like

00:44:38,400 --> 00:44:44,839
generating code it's very nice sure

00:44:49,369 --> 00:44:54,809
so the question is if you are the arrows

00:44:52,950 --> 00:45:02,400
you get with this clear no they are

00:44:54,809 --> 00:45:04,829
horrible all right let's move on to the

00:45:02,400 --> 00:45:06,420
implementation I think it's more

00:45:04,829 --> 00:45:08,569
straightforward and for arts one if

00:45:06,420 --> 00:45:10,890
you're familiar with recursion and

00:45:08,569 --> 00:45:12,990
algorithms so what we're using is a

00:45:10,890 --> 00:45:14,430
state class that keeps track of the

00:45:12,990 --> 00:45:16,410
current iteration the current

00:45:14,430 --> 00:45:18,900
accumulation value and the next action

00:45:16,410 --> 00:45:21,329
we will perform so it's like as which we

00:45:18,900 --> 00:45:22,950
either break or continue and the

00:45:21,329 --> 00:45:24,930
iteration will be tracked using an

00:45:22,950 --> 00:45:27,029
interval constant as you should know

00:45:24,930 --> 00:45:28,730
this is now our pattern every number we

00:45:27,029 --> 00:45:30,930
use a compile-time we have to wrap it

00:45:28,730 --> 00:45:32,940
the accumulator will be provided by the

00:45:30,930 --> 00:45:34,619
user code by the second code so that we

00:45:32,940 --> 00:45:36,750
can bind an initial accumulator and work

00:45:34,619 --> 00:45:38,549
with it and the next section will be

00:45:36,750 --> 00:45:40,380
implemented using two empty text drugs

00:45:38,549 --> 00:45:41,789
so we're going to tag what the loop is

00:45:40,380 --> 00:45:44,759
going to do in the next iteration either

00:45:41,789 --> 00:45:46,380
breaker continue we also need to iterate

00:45:44,759 --> 00:45:47,910
a compile-time and this can be

00:45:46,380 --> 00:45:50,069
implemented using recursion and I'm

00:45:47,910 --> 00:45:52,950
gonna use lambdas to recurse which is

00:45:50,069 --> 00:45:55,140
pretty cool so the action classes are

00:45:52,950 --> 00:45:57,150
over here there are just implementation

00:45:55,140 --> 00:45:59,670
details in a hidden namespace

00:45:57,150 --> 00:46:01,829
there are empty tag classes and we will

00:45:59,670 --> 00:46:03,210
just use a CDS same to check if we want

00:46:01,829 --> 00:46:05,910
to continue or break inside the

00:46:03,210 --> 00:46:08,339
implementation of the for loop the state

00:46:05,910 --> 00:46:10,710
class is a templated class that will

00:46:08,339 --> 00:46:15,029
store our iteration our accumulator and

00:46:10,710 --> 00:46:17,099
our action now we need to know all of

00:46:15,029 --> 00:46:19,349
those values at compile time so it needs

00:46:17,099 --> 00:46:20,700
to be a template but we also want

00:46:19,349 --> 00:46:23,279
syntactical sugar that will allow the

00:46:20,700 --> 00:46:28,470
user to grab them very easily so we

00:46:23,279 --> 00:46:30,119
define context / auto methods that will

00:46:28,470 --> 00:46:32,250
instantiate the template value and

00:46:30,119 --> 00:46:34,769
return it and this is very nice because

00:46:32,250 --> 00:46:37,650
we're using 2014 type deduction so we

00:46:34,769 --> 00:46:40,730
don't have to specify the type ourselves

00:46:37,650 --> 00:46:42,450
and is it the compiler can usually

00:46:40,730 --> 00:46:44,730
automatically convert it to our runtime

00:46:42,450 --> 00:46:46,920
values so like we're using esidisi out

00:46:44,730 --> 00:46:48,569
with the iteration value there's no need

00:46:46,920 --> 00:46:51,289
to unwrap it manually the compiler did

00:46:48,569 --> 00:46:53,789
that for you so it's pretty convenient

00:46:51,289 --> 00:46:57,000
now we also have to define two methods

00:46:53,789 --> 00:46:58,759
one to continue and want to break and as

00:46:57,000 --> 00:47:01,410
you can see here I have two overloads

00:46:58,759 --> 00:47:01,710
because we want to continue with the

00:47:01,410 --> 00:47:03,510
same

00:47:01,710 --> 00:47:06,570
in accumulation value without mutating

00:47:03,510 --> 00:47:08,430
it or we might want to give the static

00:47:06,570 --> 00:47:11,010
for a new accumulation value in order to

00:47:08,430 --> 00:47:12,240
pass it forward to the next iteration so

00:47:11,010 --> 00:47:13,830
depending on what you want to do you

00:47:12,240 --> 00:47:17,220
either want to pass a new accumulator or

00:47:13,830 --> 00:47:19,470
just use the current one and this

00:47:17,220 --> 00:47:21,810
methods here will change the action

00:47:19,470 --> 00:47:23,550
inside the state so that the next

00:47:21,810 --> 00:47:25,230
iteration we will check using static if

00:47:23,550 --> 00:47:28,740
whether or not we need to continue a

00:47:25,230 --> 00:47:30,150
break in order to simplify the

00:47:28,740 --> 00:47:32,490
management of the state

00:47:30,150 --> 00:47:34,920
I created this make state function in

00:47:32,490 --> 00:47:36,240
this advanced state function and the

00:47:34,920 --> 00:47:38,580
make state function will probably not be

00:47:36,240 --> 00:47:42,060
needed in civil 417 but all it does here

00:47:38,580 --> 00:47:43,800
is just take the values by regular

00:47:42,060 --> 00:47:45,240
parameters for the function so that we

00:47:43,800 --> 00:47:47,400
can deduce the types and it will just

00:47:45,240 --> 00:47:50,820
instance it a state the advanced state

00:47:47,400 --> 00:47:52,650
will just take the current state an

00:47:50,820 --> 00:47:54,240
accumulation value and then in the next

00:47:52,650 --> 00:47:56,390
action I will just increment the

00:47:54,240 --> 00:47:58,920
iteration for you very easily

00:47:56,390 --> 00:48:00,900
so one thing you that might be

00:47:58,920 --> 00:48:03,540
interesting here is that when you want

00:48:00,900 --> 00:48:05,609
to increment a compile-time value you

00:48:03,540 --> 00:48:07,530
need to wrap it again because when we're

00:48:05,609 --> 00:48:09,780
doing this +1 over here we're going back

00:48:07,530 --> 00:48:11,490
to the runtime realm so we want to wrap

00:48:09,780 --> 00:48:14,160
all that into the compound 10 room again

00:48:11,490 --> 00:48:15,780
so we use a CSV if you had your own

00:48:14,160 --> 00:48:18,420
interval constant implementation which

00:48:15,780 --> 00:48:20,910
is what boost Ana does you can overload

00:48:18,420 --> 00:48:22,710
the plus operator for to interval

00:48:20,910 --> 00:48:24,300
constants and you will do the wrapping

00:48:22,710 --> 00:48:26,700
and unwrapping inside implementation of

00:48:24,300 --> 00:48:27,720
the over operator overload so it's a lot

00:48:26,700 --> 00:48:29,220
cleaner but you need a lot of

00:48:27,720 --> 00:48:33,000
boilerplate that didn't fit on the

00:48:29,220 --> 00:48:36,510
slides on the code writer

00:48:33,000 --> 00:48:38,580
ok let's implement the state methods so

00:48:36,510 --> 00:48:40,650
for continue what we want to do is just

00:48:38,580 --> 00:48:43,920
advance the state with our current state

00:48:40,650 --> 00:48:45,480
and either give you a new accumulator

00:48:43,920 --> 00:48:48,210
that was provided by the user or the

00:48:45,480 --> 00:48:51,420
current accumulator and we're going to

00:48:48,210 --> 00:48:53,480
signal the for recursion loop that we

00:48:51,420 --> 00:48:56,490
want to continue and not actually break

00:48:53,480 --> 00:48:59,070
the break function is pretty much the

00:48:56,490 --> 00:49:02,220
same if we don't want to have a new

00:48:59,070 --> 00:49:04,560
accumulator we just passed our current

00:49:02,220 --> 00:49:06,150
one and we want to signal the for body

00:49:04,560 --> 00:49:10,260
that we want to break instead of

00:49:06,150 --> 00:49:11,730
continuing the next piece of the

00:49:10,260 --> 00:49:14,190
implementation which is the most complex

00:49:11,730 --> 00:49:16,589
one is the recursive lambda that is used

00:49:14,190 --> 00:49:19,530
to actual

00:49:16,589 --> 00:49:21,569
execute the loop and as you can see this

00:49:19,530 --> 00:49:23,640
is wrapped inside aesthetic for function

00:49:21,569 --> 00:49:26,040
that will bind our body so this is the

00:49:23,640 --> 00:49:28,859
first scale of the function and here

00:49:26,040 --> 00:49:30,839
we're binding our body by forwarding the

00:49:28,859 --> 00:49:34,460
body inside lambda so we're capturing it

00:49:30,839 --> 00:49:37,109
and this lambda call step will be called

00:49:34,460 --> 00:49:39,960
multiple times with every argument at

00:49:37,109 --> 00:49:41,849
compile time and in order to rehearse

00:49:39,960 --> 00:49:43,380
with lambdas we need to use this weird

00:49:41,849 --> 00:49:45,359
pattern where we passed the lambda to

00:49:43,380 --> 00:49:48,660
itself because we don't have information

00:49:45,359 --> 00:49:49,710
about the lambda until we call it so if

00:49:48,660 --> 00:49:51,119
you were doing this around time you

00:49:49,710 --> 00:49:53,010
might use STD function because a state

00:49:51,119 --> 00:49:54,780
function erases the type and allows you

00:49:53,010 --> 00:49:56,220
to recurse inside the lambda but since

00:49:54,780 --> 00:49:58,170
we can have used at a compile time we

00:49:56,220 --> 00:49:59,910
need to pass the lambda to itself you

00:49:58,170 --> 00:50:02,280
know in order to recurse this is kind of

00:49:59,910 --> 00:50:04,710
weird but it does make sense if you

00:50:02,280 --> 00:50:06,960
think about it then we need to pass the

00:50:04,710 --> 00:50:09,000
current state to the lambda the current

00:50:06,960 --> 00:50:12,750
argument that we are iterating over and

00:50:09,000 --> 00:50:14,369
rest of the arguments inside the step

00:50:12,750 --> 00:50:15,599
body what we're going to do is we're

00:50:14,369 --> 00:50:18,030
going to compute the next state

00:50:15,599 --> 00:50:19,800
immediately and how do we compute the

00:50:18,030 --> 00:50:22,410
next state we call the body function

00:50:19,800 --> 00:50:23,819
that we captured earlier with the

00:50:22,410 --> 00:50:25,980
current state and the current ex

00:50:23,819 --> 00:50:28,950
argument so the next state will tell us

00:50:25,980 --> 00:50:31,200
whether or not we had to break what the

00:50:28,950 --> 00:50:34,890
new accumulation value is and it might

00:50:31,200 --> 00:50:36,810
generate code we also need to check if

00:50:34,890 --> 00:50:39,450
this is the last iteration we're doing

00:50:36,810 --> 00:50:41,550
by checking if we have any remaining

00:50:39,450 --> 00:50:43,650
argument in the argument pack that's

00:50:41,550 --> 00:50:45,240
very easy to do we just check the sides

00:50:43,650 --> 00:50:47,430
of the argument pack with the size of

00:50:45,240 --> 00:50:49,520
ellipsis operator and wrap that into a

00:50:47,430 --> 00:50:52,589
compile time value that's very important

00:50:49,520 --> 00:50:55,230
now we need to make sure that if the

00:50:52,589 --> 00:50:57,660
user is going to call break in the next

00:50:55,230 --> 00:50:59,069
state we want to immediately break so we

00:50:57,660 --> 00:51:01,260
don't have we don't want to generate an

00:50:59,069 --> 00:51:03,180
extra step of code or modify the

00:51:01,260 --> 00:51:05,910
accumulator value for an extra step so

00:51:03,180 --> 00:51:08,730
what we are going to do is checking if

00:51:05,910 --> 00:51:10,950
we must break by using STD the same with

00:51:08,730 --> 00:51:13,560
the type of the next action in the next

00:51:10,950 --> 00:51:16,410
state and comparing that to the break

00:51:13,560 --> 00:51:18,540
action so if in the next state the user

00:51:16,410 --> 00:51:20,819
is going to call break we want to

00:51:18,540 --> 00:51:23,670
recognize that a compile time by using

00:51:20,819 --> 00:51:25,380
deckle type on the next state we check

00:51:23,670 --> 00:51:28,440
what the type of this action will be and

00:51:25,380 --> 00:51:29,460
if it will break we set this value here

00:51:28,440 --> 00:51:31,890
to a compile time

00:51:29,460 --> 00:51:34,550
boolean true value in order to avoid

00:51:31,890 --> 00:51:36,990
going an extra step in our static for

00:51:34,550 --> 00:51:39,180
now it's time to deal with recursion if

00:51:36,990 --> 00:51:41,580
you remember the previous example of you

00:51:39,180 --> 00:51:42,990
code segments ago I use static if to

00:51:41,580 --> 00:51:44,520
recurse instead of lambda for our fold

00:51:42,990 --> 00:51:47,369
and this is basically the same thing

00:51:44,520 --> 00:51:50,790
what we're implementing is a syntactical

00:51:47,369 --> 00:51:52,440
sugar for left fold so what we want to

00:51:50,790 --> 00:51:54,930
do is static if to control the recursion

00:51:52,440 --> 00:51:57,240
if we have to break because the user

00:51:54,930 --> 00:52:00,330
wanted us to immediately break or if we

00:51:57,240 --> 00:52:02,310
are the last iteration this is our final

00:52:00,330 --> 00:52:04,190
step or base case we are going to return

00:52:02,310 --> 00:52:07,890
the current accumulator and that's it

00:52:04,190 --> 00:52:10,980
otherwise what we want to do is recurse

00:52:07,890 --> 00:52:12,810
and this is the very cool thing about

00:52:10,980 --> 00:52:15,030
lambdas you can pass the lambda to

00:52:12,810 --> 00:52:17,040
itself in order to allow recursion

00:52:15,030 --> 00:52:20,400
without knowledge of the type of the

00:52:17,040 --> 00:52:22,560
lambda at compile time and we can also

00:52:20,400 --> 00:52:24,810
pass the next state and the rest of the

00:52:22,560 --> 00:52:26,849
arguments ignoring the current argument

00:52:24,810 --> 00:52:30,540
so this is a lot to take in

00:52:26,849 --> 00:52:32,790
but I hope it's kind of clear what we're

00:52:30,540 --> 00:52:34,589
doing if the user wants to break or if

00:52:32,790 --> 00:52:36,960
we have no more argument just return the

00:52:34,589 --> 00:52:39,869
accumulation value otherwise we call

00:52:36,960 --> 00:52:42,660
ourselves this itself will be basically

00:52:39,869 --> 00:52:46,410
the step function with the new state and

00:52:42,660 --> 00:52:48,570
the rest of the arguments so that was

00:52:46,410 --> 00:52:50,430
the step function now we want to return

00:52:48,570 --> 00:52:52,080
something that allows the user to bind

00:52:50,430 --> 00:52:54,510
an accumulator to the state function and

00:52:52,080 --> 00:52:56,190
to do that we move the step function

00:52:54,510 --> 00:52:58,260
inside an extra lambda that will be

00:52:56,190 --> 00:53:00,330
returned and this lambda will just take

00:52:58,260 --> 00:53:02,790
the initial accumulation value bind it

00:53:00,330 --> 00:53:04,560
and we'll provide the user with another

00:53:02,790 --> 00:53:06,660
function that will take a bunch of

00:53:04,560 --> 00:53:09,150
arguments and I trait over those

00:53:06,660 --> 00:53:11,430
arguments using the bound accumulation

00:53:09,150 --> 00:53:14,490
value and a bound loop that's going to

00:53:11,430 --> 00:53:16,320
be used for the static four and what we

00:53:14,490 --> 00:53:18,420
need to do here is we need to explicitly

00:53:16,320 --> 00:53:21,660
check if the user is passing an empty

00:53:18,420 --> 00:53:23,700
parameter pack because otherwise we will

00:53:21,660 --> 00:53:26,010
get a compile time error during the

00:53:23,700 --> 00:53:28,589
sensation of the step lambda and so if

00:53:26,010 --> 00:53:30,200
the user is passing no arguments

00:53:28,589 --> 00:53:33,960
we'll just emit a return the accumulator

00:53:30,200 --> 00:53:37,170
otherwise we start our iteration with an

00:53:33,960 --> 00:53:39,990
initial state that begins from the zero

00:53:37,170 --> 00:53:42,150
iteration index from the bound user

00:53:39,990 --> 00:53:43,470
provider accumulator and with the

00:53:42,150 --> 00:53:45,720
continued action by the

00:53:43,470 --> 00:53:48,260
once we have all of that we can finally

00:53:45,720 --> 00:53:53,609
call step with the initial state and

00:53:48,260 --> 00:53:55,859
forwarded where the argument back and we

00:53:53,609 --> 00:53:58,829
can actually invoke static if with our

00:53:55,859 --> 00:54:00,960
step and our argument back so throughout

00:53:58,829 --> 00:54:05,430
this talk what I've been doing is just

00:54:00,960 --> 00:54:07,859
defining x and y's the the reason I do

00:54:05,430 --> 00:54:09,839
this is to allow the firing of the

00:54:07,859 --> 00:54:10,079
static if branch matching at compile

00:54:09,839 --> 00:54:13,380
time

00:54:10,079 --> 00:54:15,329
so if you see XS here and YS here is

00:54:13,380 --> 00:54:16,980
just because I'm calling static if and

00:54:15,329 --> 00:54:20,339
passing it back to the static if in

00:54:16,980 --> 00:54:23,390
order to allow template enunciation to

00:54:20,339 --> 00:54:26,970
take place only if the branches match it

00:54:23,390 --> 00:54:29,490
so we can test our implementation this

00:54:26,970 --> 00:54:33,450
is an example code we're using static

00:54:29,490 --> 00:54:35,190
for with our body hover here and this

00:54:33,450 --> 00:54:37,650
will just bind the body after binding

00:54:35,190 --> 00:54:40,230
the body with bind an initial

00:54:37,650 --> 00:54:42,089
accumulation value so this is second

00:54:40,230 --> 00:54:45,810
function call and the final function

00:54:42,089 --> 00:54:49,740
call will execute the loop and give us

00:54:45,810 --> 00:54:51,119
our accumulator result so if we analyze

00:54:49,740 --> 00:54:53,579
the body what we're doing is we're

00:54:51,119 --> 00:54:56,130
printing everything at the beginning of

00:54:53,579 --> 00:55:00,079
the loop then we are computing our new

00:54:56,130 --> 00:55:04,500
accumulation value by taking the old one

00:55:00,079 --> 00:55:06,089
over here and incrementing it with with

00:55:04,500 --> 00:55:07,710
the value that we're iterating over and

00:55:06,089 --> 00:55:09,780
wrapping all of that inside a

00:55:07,710 --> 00:55:11,790
compile-time constant again this the

00:55:09,780 --> 00:55:14,339
cool types that it's required because of

00:55:11,790 --> 00:55:17,280
GCC for some reason so if u s-- clang is

00:55:14,339 --> 00:55:21,089
way nicer and after that we will return

00:55:17,280 --> 00:55:23,339
the continue action from our state with

00:55:21,089 --> 00:55:25,980
the new accumulation value so this is

00:55:23,339 --> 00:55:28,200
just a sum over the elements of the

00:55:25,980 --> 00:55:30,630
static four with an initial zero value

00:55:28,200 --> 00:55:39,990
if we compile that we should get the sum

00:55:30,630 --> 00:55:42,440
of 10 20 30 and 40 oops ok as you can

00:55:39,990 --> 00:55:44,940
see we get every iteration value and

00:55:42,440 --> 00:55:46,619
sorry iteration index and current value

00:55:44,940 --> 00:55:48,660
printed and the current value of the

00:55:46,619 --> 00:55:52,200
accumulator so we can track where the

00:55:48,660 --> 00:55:54,210
four is doing and again the point of

00:55:52,200 --> 00:55:56,520
this construct it's a that it's

00:55:54,210 --> 00:55:57,150
conceptually the same as a runtime for

00:55:56,520 --> 00:55:59,069
in terms of

00:55:57,150 --> 00:56:01,500
control flow and how you will think

00:55:59,069 --> 00:56:03,869
about it the difference is the horrible

00:56:01,500 --> 00:56:06,020
syntax but that's just what we have to

00:56:03,869 --> 00:56:35,760
do for now

00:56:06,020 --> 00:56:38,670
sure exactly

00:56:35,760 --> 00:56:41,520
so the question or comment was what's

00:56:38,670 --> 00:56:44,039
inside the for-loop is code that will be

00:56:41,520 --> 00:56:45,510
generated at runtime which is directly

00:56:44,039 --> 00:56:47,579
in the body and this will be the color

00:56:45,510 --> 00:56:49,339
we're generating in order to compute

00:56:47,579 --> 00:56:52,410
stuff at compile time we're exploiting

00:56:49,339 --> 00:56:55,440
argument passing to the recursive lambda

00:56:52,410 --> 00:56:58,200
and returning values that have special

00:56:55,440 --> 00:56:59,460
like compile time sentinels that will

00:56:58,200 --> 00:57:01,529
tell us whether or not we have to

00:56:59,460 --> 00:57:04,430
accumulate and to continuum break is

00:57:01,529 --> 00:57:12,299
that right okay perfect

00:57:04,430 --> 00:57:13,619
so yeah sure exactly is no overhead at

00:57:12,299 --> 00:57:16,250
runtime just for C outs

00:57:13,619 --> 00:57:16,250
sure

00:57:20,150 --> 00:57:22,810
yeah

00:57:47,910 --> 00:57:52,480
okay so the question is you're using

00:57:50,650 --> 00:57:54,220
recursion to break out of the loop

00:57:52,480 --> 00:57:56,860
what if you capture the state as a

00:57:54,220 --> 00:57:58,990
mutable lambda value and you directly

00:57:56,860 --> 00:58:00,880
like a sign break to it during the body

00:57:58,990 --> 00:58:02,320
is that what you're asking you're

00:58:00,880 --> 00:58:04,480
thinking the in the runtime realm

00:58:02,320 --> 00:58:06,820
because you can do that at runtime but

00:58:04,480 --> 00:58:08,560
if you are signing it inside the body we

00:58:06,820 --> 00:58:09,280
are not really changing any anything at

00:58:08,560 --> 00:58:16,390
a compile time

00:58:09,280 --> 00:58:22,170
we need a way but the lambda is not

00:58:16,390 --> 00:58:22,170
constructs true it might work in space

00:58:23,250 --> 00:58:27,520
okay I see what you what you get into

00:58:25,930 --> 00:58:29,650
maybe it's a 4:17 where we have

00:58:27,520 --> 00:58:31,900
constructs two lambdas we could do this

00:58:29,650 --> 00:58:33,160
in a cleaner way but he supposes 14

00:58:31,900 --> 00:58:35,830
since we don't have contacts from

00:58:33,160 --> 00:58:37,720
lambdas I don't think you can use

00:58:35,830 --> 00:58:40,420
runtime like syntax to control the

00:58:37,720 --> 00:58:51,010
iteration we we might transfer facility

00:58:40,420 --> 00:58:53,250
that's an interesting point sure yeah

00:58:51,010 --> 00:58:53,250
okay

00:59:01,270 --> 00:59:05,950
the point was so yeah the question is

00:59:03,340 --> 00:59:08,500
how did you get away without specifying

00:59:05,950 --> 00:59:11,500
the explicit return type of the lambda

00:59:08,500 --> 00:59:13,870
using recursion I just use auto because

00:59:11,500 --> 00:59:16,300
as you said I'm passing the lambda into

00:59:13,870 --> 00:59:17,560
itself so I don't need to know what the

00:59:16,300 --> 00:59:19,300
lambda is going to do or it's going to

00:59:17,560 --> 00:59:22,360
return or D or the type of the lambda

00:59:19,300 --> 00:59:26,730
itself during the development of the

00:59:22,360 --> 00:59:30,040
outer for loop since I can explore the

00:59:26,730 --> 00:59:32,140
type deduction here as you can see when

00:59:30,040 --> 00:59:35,490
I'm rehearsing I'm just using return

00:59:32,140 --> 00:59:38,890
itself calling self again over and over

00:59:35,490 --> 00:59:42,220
but the return type is known in the base

00:59:38,890 --> 00:59:45,730
case of the recursion so in the end the

00:59:42,220 --> 00:59:47,460
author that you see here is the type of

00:59:45,730 --> 00:59:49,630
the lambda which we do not care about

00:59:47,460 --> 00:59:51,670
the thing we care about is the return

00:59:49,630 --> 00:59:54,310
like the base case of the recursion and

00:59:51,670 --> 00:59:56,950
we are aware of that type in

00:59:54,310 --> 01:00:01,090
staticky fear which is the base step so

00:59:56,950 --> 01:00:03,040
I understand your question but you don't

01:00:01,090 --> 01:00:04,330
need to know the like the recursive type

01:00:03,040 --> 01:00:06,190
of the lamb that you implement on the

01:00:04,330 --> 01:00:08,680
recursion if you use this pattern what

01:00:06,190 --> 01:00:09,760
you need to know is just what the type

01:00:08,680 --> 01:00:11,440
of the value you're going to return is

01:00:09,760 --> 01:00:12,610
and you can deduce that from the

01:00:11,440 --> 01:00:13,950
accumulator in this case or anything

01:00:12,610 --> 01:00:26,350
else I hope that answer your question

01:00:13,950 --> 01:00:28,180
sure okay okay yeah exactly yeah yeah so

01:00:26,350 --> 01:00:29,470
the comment was it's not actually a real

01:00:28,180 --> 01:00:30,850
recursive function you're coming a

01:00:29,470 --> 01:00:33,610
different function average duration and

01:00:30,850 --> 01:00:35,200
that's completely correct I just like to

01:00:33,610 --> 01:00:37,450
think it in terms of recursion because

01:00:35,200 --> 01:00:39,340
you know it's it's practically what are

01:00:37,450 --> 01:00:40,660
we doing but yeah it's not the same

01:00:39,340 --> 01:00:44,290
function we're just generating any one

01:00:40,660 --> 01:00:47,110
and calling it's every time any more

01:00:44,290 --> 01:00:49,420
comments okay I think we're at a time

01:00:47,110 --> 01:00:51,430
let me check what the order okay let's

01:00:49,420 --> 01:00:54,040
go very clearly through this this is my

01:00:51,430 --> 01:00:56,230
conclusion and in the github repository

01:00:54,040 --> 01:00:57,460
where I that I show you the link at the

01:00:56,230 --> 01:01:00,130
beginning of the talk I have the

01:00:57,460 --> 01:01:03,040
assembly generated for just both paths

01:01:00,130 --> 01:01:04,810
5.3 6.1 and chronic plus plus three

01:01:03,040 --> 01:01:07,030
point seven three point eight and they

01:01:04,810 --> 01:01:09,670
produce identical assembly for unwritten

01:01:07,030 --> 01:01:12,730
code and Static for four arcs of static

01:01:09,670 --> 01:01:15,160
if starting from this optimization level

01:01:12,730 --> 01:01:17,200
onwards so this is effectively raucous

01:01:15,160 --> 01:01:20,170
obstruction you might pay in terms of

01:01:17,200 --> 01:01:22,360
compile time a compilation time impact

01:01:20,170 --> 01:01:24,580
depending on whether or not you know

01:01:22,360 --> 01:01:27,480
you're using a very big static for that

01:01:24,580 --> 01:01:30,190
user recursion or a lot of static gifts

01:01:27,480 --> 01:01:31,990
if you want a production-ready solution

01:01:30,190 --> 01:01:33,520
you can check out boost Ana I cannot

01:01:31,990 --> 01:01:35,290
stress this enough this is a beautiful

01:01:33,520 --> 01:01:38,950
library that makes meta programming

01:01:35,290 --> 01:01:40,900
amazing and it provides some evil if

01:01:38,950 --> 01:01:42,430
construct here which you can use to

01:01:40,900 --> 01:01:45,990
implement the same pattern as you can

01:01:42,430 --> 01:01:48,580
see here you just have a compile time

01:01:45,990 --> 01:01:50,830
condition here and a bunch of lambdas

01:01:48,580 --> 01:01:52,180
that represent the various instance

01:01:50,830 --> 01:01:54,090
yishun depending on whether or not

01:01:52,180 --> 01:01:56,920
you're matching the compile time branch

01:01:54,090 --> 01:01:58,510
also it provides that for each here that

01:01:56,920 --> 01:02:00,670
takes a topple instead of a very Adak

01:01:58,510 --> 01:02:01,900
amount of arguments and it will applied

01:02:00,670 --> 01:02:03,880
it about the topple inside the pass

01:02:01,900 --> 01:02:05,740
function so you can achieve the same

01:02:03,880 --> 01:02:07,940
thing as four arcs of static for without

01:02:05,740 --> 01:02:10,310
the iteration index and all out

01:02:07,940 --> 01:02:12,590
the syntactical sugar another cool

01:02:10,310 --> 01:02:15,290
library is both false fits which is a

01:02:12,590 --> 01:02:17,480
modern functional library and you have

01:02:15,290 --> 01:02:20,210
something similar to study gift which is

01:02:17,480 --> 01:02:22,910
called evil and conditional by composing

01:02:20,210 --> 01:02:25,400
evil and conditional together and using

01:02:22,910 --> 01:02:27,440
that special if object you can implement

01:02:25,400 --> 01:02:29,000
the same thing as static if and this is

01:02:27,440 --> 01:02:30,710
a production reading solution it's a

01:02:29,000 --> 01:02:34,580
different syntax different approach but

01:02:30,710 --> 01:02:36,560
it does the same thing basically also

01:02:34,580 --> 01:02:39,890
you can use fit compress and fit apply

01:02:36,560 --> 01:02:43,160
to create a callable object that will

01:02:39,890 --> 01:02:45,620
call a specific function over a set of

01:02:43,160 --> 01:02:47,930
arguments and instead of passing them as

01:02:45,620 --> 01:02:50,330
a very attic set you just call it

01:02:47,930 --> 01:02:52,010
multiple times and you can use

01:02:50,330 --> 01:02:55,730
metaprogramming facilities to make this

01:02:52,010 --> 01:02:57,650
nicer and equivalent to static for so I

01:02:55,730 --> 01:03:00,010
hope you enjoyed the talk thank you very

01:02:57,650 --> 01:03:00,010

YouTube URL: https://www.youtube.com/watch?v=aXSsUqVSe2k


