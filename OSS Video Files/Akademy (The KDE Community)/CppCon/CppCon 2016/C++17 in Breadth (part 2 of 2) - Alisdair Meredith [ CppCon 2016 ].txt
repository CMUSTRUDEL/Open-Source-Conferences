Title: C++17 in Breadth (part 2 of 2) - Alisdair Meredith [ CppCon 2016 ]
Publication date: 2016-09-29
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
This talk will cover every feature addition, removal, and change in the next version of the C++ standard, provisionally going by the name C++17. Covering both the language and the library, the coverage of any given feature must necessarily brief. The goal is to come away with an understanding of what each feature is, and why you might want to use it, with an overall impression of how the new language might fit together. It is not intended to be an detailed tutorial on any individual feature, but rather, a jumping off point for further sessions on the topics that seem most interesting.
— 
Alisdair Meredith
Bloomberg LP
Alisdair Meredith is a software developer at BloombergLP in New York, and the C++ Standard Committee Library Working Group chair.

He has been an active member of the C++ committee for just over a decade, and by a lucky co-incidence his first meeting was the kick-off meeting for the project that would become C++11, and also fixed the contents of the original library TR.

He is currently working on the BDE project, BloombergLP's open source libraries that offer a foundation for C++ development, including a standard library implementation supporting the polymorphic allocator model proposed for standardization.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,030 --> 00:00:07,410
so I'm already 90 seconds late so I'm

00:00:01,770 --> 00:00:08,820
going to have to really get going so we

00:00:07,410 --> 00:00:12,719
finished with the template instantiation

00:00:08,820 --> 00:00:14,670
guides nice example of how we might use

00:00:12,719 --> 00:00:16,410
them with vector interesting point that

00:00:14,670 --> 00:00:18,060
we didn't actually get this early enough

00:00:16,410 --> 00:00:20,130
so the standard library added this to

00:00:18,060 --> 00:00:21,720
vector so this is what we're saying

00:00:20,130 --> 00:00:23,519
we're out in the ballot comment period

00:00:21,720 --> 00:00:25,740
time I filed ballot comments suggesting

00:00:23,519 --> 00:00:29,869
hey this thing saying this is the

00:00:25,740 --> 00:00:32,790
motivation for doing this let's do this

00:00:29,869 --> 00:00:34,380
stricted bindings is a another light

00:00:32,790 --> 00:00:36,899
breaking feature that I expected to be

00:00:34,380 --> 00:00:38,160
really popular the idea is so I've got a

00:00:36,899 --> 00:00:40,950
function that returns multiple values

00:00:38,160 --> 00:00:43,129
and I want to declare a bunch of

00:00:40,950 --> 00:00:46,050
variables that are the result of

00:00:43,129 --> 00:00:48,980
breaking down those multiple values into

00:00:46,050 --> 00:00:51,300
separate variables so the syntax is

00:00:48,980 --> 00:00:54,629
we're using all of our wonderful tokens

00:00:51,300 --> 00:00:57,690
Auto square bracket X comma Y introduces

00:00:54,629 --> 00:01:00,449
two new variables x and y that will bind

00:00:57,690 --> 00:01:03,239
to the result of dereferencing in this

00:01:00,449 --> 00:01:07,320
case map fine so it's first and second

00:01:03,239 --> 00:01:09,659
of that pair what does the stricter

00:01:07,320 --> 00:01:12,960
binding syntax work with functions can

00:01:09,659 --> 00:01:14,909
return any aggregate so I've got a C

00:01:12,960 --> 00:01:16,619
style struct I don't need to anything

00:01:14,909 --> 00:01:18,600
extra that will already just bind

00:01:16,619 --> 00:01:20,520
correctly as long as I provide the right

00:01:18,600 --> 00:01:23,189
number of identifiers for the new

00:01:20,520 --> 00:01:24,840
variables I'm declaring and I can return

00:01:23,189 --> 00:01:27,180
an array by reference and it will wear

00:01:24,840 --> 00:01:29,640
for initialize the same number of

00:01:27,180 --> 00:01:31,680
variables of that type or something that

00:01:29,640 --> 00:01:33,900
supports the tuple protocol where the

00:01:31,680 --> 00:01:35,909
tuple protocol has not yet been nailed

00:01:33,900 --> 00:01:37,799
down properly in the library but the

00:01:35,909 --> 00:01:39,810
intent is this will all be smoothed over

00:01:37,799 --> 00:01:43,079
and cleaned up by the time 17 goes to

00:01:39,810 --> 00:01:46,079
print so the idea is you're providing

00:01:43,079 --> 00:01:48,810
specializations for tuple size and tuple

00:01:46,079 --> 00:01:50,549
element and the get function in order to

00:01:48,810 --> 00:01:53,430
retrieve the element out of the tuple

00:01:50,549 --> 00:01:55,530
using those values but it does mean that

00:01:53,430 --> 00:01:57,930
array parent topple out the box already

00:01:55,530 --> 00:01:59,610
support those types we've just not given

00:01:57,930 --> 00:02:02,310
you the user the rules for how you can

00:01:59,610 --> 00:02:05,820
customize your own types to specialize

00:02:02,310 --> 00:02:08,429
those traits and it also works anywhere

00:02:05,820 --> 00:02:09,899
initialization may be performed so this

00:02:08,429 --> 00:02:11,849
was a fun one that had figuring out to

00:02:09,899 --> 00:02:13,830
draw the slides you can you know got a

00:02:11,849 --> 00:02:15,930
map using a for loop and can

00:02:13,830 --> 00:02:18,150
Auto reference give me first and second

00:02:15,930 --> 00:02:19,860
from the map I've got first and second

00:02:18,150 --> 00:02:21,690
variables directly usable within the map

00:02:19,860 --> 00:02:23,520
you'll notice I've used an auto

00:02:21,690 --> 00:02:25,530
reference to make sure I get references

00:02:23,520 --> 00:02:27,780
out and it means that I've got a Const

00:02:25,530 --> 00:02:33,570
reference to first and a regular

00:02:27,780 --> 00:02:34,620
reference to second as include is a

00:02:33,570 --> 00:02:37,560
little tool putting into the

00:02:34,620 --> 00:02:39,510
preprocessor that it's an extension in

00:02:37,560 --> 00:02:40,830
several popular can powers today and

00:02:39,510 --> 00:02:43,500
people wanted it in the standard for a

00:02:40,830 --> 00:02:45,000
while so here's my husky example of them

00:02:43,500 --> 00:02:47,250
trying to use the file system header

00:02:45,000 --> 00:02:48,990
I'll see if I can include the file

00:02:47,250 --> 00:02:51,690
system header and if so great namespace

00:02:48,990 --> 00:02:53,220
FS is standard file system otherwise

00:02:51,690 --> 00:02:54,720
I'll see if I can find the experimental

00:02:53,220 --> 00:02:56,850
file system header and if so great

00:02:54,720 --> 00:02:59,580
namespace FS is the experimental file

00:02:56,850 --> 00:03:01,050
system header otherwise last-gasp I'll

00:02:59,580 --> 00:03:03,870
see if I can find the boost file system

00:03:01,050 --> 00:03:05,780
library and I'm missing the HPP on boost

00:03:03,870 --> 00:03:08,610
file system so that's a bug on the slide

00:03:05,780 --> 00:03:10,500
if I can include that great I've now got

00:03:08,610 --> 00:03:12,900
the boost file system is my namespace FS

00:03:10,500 --> 00:03:14,250
otherwise yeah I'll give the user an

00:03:12,900 --> 00:03:15,600
error I couldn't find the file system

00:03:14,250 --> 00:03:17,720
library this codes probably not going to

00:03:15,600 --> 00:03:17,720
work

00:03:18,110 --> 00:03:23,850
language tweaks going on one that was

00:03:21,810 --> 00:03:25,920
requested going back at least as far as

00:03:23,850 --> 00:03:28,950
C++ C 11 we finally get is the ability

00:03:25,920 --> 00:03:32,519
to open an STD namespace so a namespace

00:03:28,950 --> 00:03:34,860
STD colon colon file system I don't need

00:03:32,519 --> 00:03:37,500
to know independently open both

00:03:34,860 --> 00:03:39,660
namespaces really is nice because it

00:03:37,500 --> 00:03:41,160
means I can close it with a single curly

00:03:39,660 --> 00:03:43,800
which is fairly handy when you're trying

00:03:41,160 --> 00:03:46,739
to write these things in macros not that

00:03:43,800 --> 00:03:49,650
we like writing mini macros and you can

00:03:46,739 --> 00:03:51,660
wise reckon if clauses I thought this

00:03:49,650 --> 00:03:53,160
was a particularly dubious feature until

00:03:51,660 --> 00:03:55,760
someone gave me the classic motivating

00:03:53,160 --> 00:03:58,620
example and now I love it too bit

00:03:55,760 --> 00:04:00,930
basically the idea is it's avoiding a

00:03:58,620 --> 00:04:02,489
pair of curly brackets you're not

00:04:00,930 --> 00:04:04,530
writing anything you that you couldn't

00:04:02,489 --> 00:04:06,900
write before but it is just so much

00:04:04,530 --> 00:04:08,280
neater on the page similar to the idiom

00:04:06,900 --> 00:04:10,410
of where you would initialize a point

00:04:08,280 --> 00:04:12,989
with a dynamic cast inside the earth in

00:04:10,410 --> 00:04:17,250
this case I'm going to take a lock over

00:04:12,989 --> 00:04:21,000
the Konkan call so if lock garden mutex

00:04:17,250 --> 00:04:22,560
elk it okay I get my lock but the test

00:04:21,000 --> 00:04:25,229
that I'm going to do once I've acquired

00:04:22,560 --> 00:04:26,610
the lock is V door empty and if the

00:04:25,229 --> 00:04:27,440
things empty I'm going to do my push

00:04:26,610 --> 00:04:32,520
back

00:04:27,440 --> 00:04:34,949
so I acquire the lock before doing the

00:04:32,520 --> 00:04:38,490
test but I've got a scope of mine if if

00:04:34,949 --> 00:04:40,699
block and the else for that for that

00:04:38,490 --> 00:04:40,699
lock

00:04:40,729 --> 00:04:47,940
another simple small cleanup for static

00:04:44,400 --> 00:04:50,940
assert often if we're using good class

00:04:47,940 --> 00:04:53,240
names with good identifiers the thing

00:04:50,940 --> 00:04:56,220
that we're testing is clear enough that

00:04:53,240 --> 00:04:57,990
coming up with a separate string literal

00:04:56,220 --> 00:04:59,280
to describe the error it's frustrating

00:04:57,990 --> 00:05:00,990
it's annoying especially if you're

00:04:59,280 --> 00:05:03,270
writing a lot of these especially

00:05:00,990 --> 00:05:06,419
writing test drivers so just having the

00:05:03,270 --> 00:05:08,550
static assert string guys that text like

00:05:06,419 --> 00:05:10,440
it would with a regular assert is a

00:05:08,550 --> 00:05:12,630
popular little feature so we can now

00:05:10,440 --> 00:05:17,610
omit the string literal nor just string

00:05:12,630 --> 00:05:19,139
eyes the text of the code and obscure

00:05:17,610 --> 00:05:21,030
little corner at the end that this is

00:05:19,139 --> 00:05:23,490
significant if you've been following

00:05:21,030 --> 00:05:25,650
what's happening with the ranges TS and

00:05:23,490 --> 00:05:27,599
if you've not you'll find out again

00:05:25,650 --> 00:05:30,360
another three to five years but the idea

00:05:27,599 --> 00:05:33,060
is a range doesn't need to have now the

00:05:30,360 --> 00:05:35,580
begin in the end iterator be the same

00:05:33,060 --> 00:05:37,080
type I can have some kind of query that

00:05:35,580 --> 00:05:40,229
when I'm querying it against the end as

00:05:37,080 --> 00:05:42,539
long as I ever I'm testing with tests

00:05:40,229 --> 00:05:44,610
with the first iterator type I can have

00:05:42,539 --> 00:05:46,229
it a simplest sentinel type at the end

00:05:44,610 --> 00:05:48,990
that is very useful in some kinds of

00:05:46,229 --> 00:05:51,000
ranges especially input ranges so this

00:05:48,990 --> 00:05:52,919
is an idiom that were propagating all

00:05:51,000 --> 00:05:55,349
the way through the ranges TS which is

00:05:52,919 --> 00:05:57,419
coming for the library in the medium

00:05:55,349 --> 00:05:59,699
future in the meanwhile we put that

00:05:57,419 --> 00:06:02,130
support straight into the new range base

00:05:59,699 --> 00:06:04,259
for loop so if people have loops a

00:06:02,130 --> 00:06:07,580
returnee functions at returning ranges

00:06:04,259 --> 00:06:07,580
they can drop them into the loop a

00:06:08,509 --> 00:06:13,050
obscure corn they were clarifying

00:06:10,710 --> 00:06:14,190
explicit default constructors as I said

00:06:13,050 --> 00:06:18,210
I'm going to show you everything we've

00:06:14,190 --> 00:06:22,310
done in a standard look the final

00:06:18,210 --> 00:06:26,069
bracket Zed C is equal to empty braces

00:06:22,310 --> 00:06:29,580
is this supposed to work is it not a

00:06:26,069 --> 00:06:31,349
standard was ambiguous on this and it

00:06:29,580 --> 00:06:33,599
turned there having gone round the

00:06:31,349 --> 00:06:35,310
various alternatives that making that

00:06:33,599 --> 00:06:36,990
ill-formed is the one that seems most

00:06:35,310 --> 00:06:38,339
consistent with the way explicit

00:06:36,990 --> 00:06:40,560
constructors work elsewhere in the

00:06:38,339 --> 00:06:41,220
language these days so that was cleaned

00:06:40,560 --> 00:06:43,620
up and that

00:06:41,220 --> 00:06:45,420
actually simplifies an awful lot of

00:06:43,620 --> 00:06:50,280
library issues that were hanging on this

00:06:45,420 --> 00:06:51,630
specific core feature one of the more

00:06:50,280 --> 00:06:55,380
contentious things we were dealing with

00:06:51,630 --> 00:06:58,890
at the end was nailing down an order of

00:06:55,380 --> 00:07:01,380
evaluation of expressions this has long

00:06:58,890 --> 00:07:03,840
been a corner case for bugs in C++ you

00:07:01,380 --> 00:07:08,310
know I plus plus plus i plus plus is not

00:07:03,840 --> 00:07:10,260
well-defined optimizer folks love to

00:07:08,310 --> 00:07:11,880
claim this is a really important corner

00:07:10,260 --> 00:07:14,520
where they can get the most out of

00:07:11,880 --> 00:07:16,160
language and folks learning language

00:07:14,520 --> 00:07:18,450
especially coming from other languages

00:07:16,160 --> 00:07:20,310
have undefined behavior in the programs

00:07:18,450 --> 00:07:24,000
that they're not seeing and this is we

00:07:20,310 --> 00:07:26,910
don't like that confusion so we came to

00:07:24,000 --> 00:07:28,890
some kind of a middle ground where the

00:07:26,910 --> 00:07:30,930
operators of the web the standard

00:07:28,890 --> 00:07:33,270
operators are plus minus and so forth

00:07:30,930 --> 00:07:36,740
are all going to have a clear well

00:07:33,270 --> 00:07:39,690
specified order of evaluation now

00:07:36,740 --> 00:07:41,280
function call operators so the order and

00:07:39,690 --> 00:07:43,919
evaluate the expressions within a

00:07:41,280 --> 00:07:47,490
function call so a B you know I'm

00:07:43,919 --> 00:07:50,400
calling F with ABCDE evaluation of ABCDE

00:07:47,490 --> 00:07:54,540
are now all indeterminately sequenced

00:07:50,400 --> 00:07:55,919
that is progress since C++ 14 where they

00:07:54,540 --> 00:07:57,690
were actually uncie quince and therefore

00:07:55,919 --> 00:07:59,220
I could have date arbitrary data races

00:07:57,690 --> 00:08:01,740
or interleaving of instructions between

00:07:59,220 --> 00:08:04,169
any of those evaluations now there is

00:08:01,740 --> 00:08:06,240
going to be a sequencing but whether

00:08:04,169 --> 00:08:08,669
it's left-to-right right-to-left or any

00:08:06,240 --> 00:08:10,890
random permutation you don't know that's

00:08:08,669 --> 00:08:12,450
known only to the compiler vendor there

00:08:10,890 --> 00:08:14,040
was a desire to make that left-to-right

00:08:12,450 --> 00:08:16,530
you might read about people saying it

00:08:14,040 --> 00:08:18,270
should be left to right we had some

00:08:16,530 --> 00:08:20,790
feedback from some optimizer folks who

00:08:18,270 --> 00:08:22,650
implemented that and said yeah we were

00:08:20,790 --> 00:08:25,050
doing right-to-left before and when we

00:08:22,650 --> 00:08:26,370
switch to left-to-right we're getting

00:08:25,050 --> 00:08:28,680
this much of a performance penalty and

00:08:26,370 --> 00:08:30,540
we don't want to pay it so certainly as

00:08:28,680 --> 00:08:33,229
far as 17 is concerned we're not nailing

00:08:30,540 --> 00:08:35,580
down the order any more than

00:08:33,229 --> 00:08:37,169
indeterminate with sequence but there is

00:08:35,580 --> 00:08:40,320
now at least a sequencing there to

00:08:37,169 --> 00:08:44,280
eliminate further kinds of awkward

00:08:40,320 --> 00:08:47,970
corner case bugs it also means that when

00:08:44,280 --> 00:08:49,140
you overload an operator the overloaded

00:08:47,970 --> 00:08:52,290
operator when it's called

00:08:49,140 --> 00:08:54,089
will have a sequencing between the

00:08:52,290 --> 00:08:55,529
evaluation of the two arguments that

00:08:54,089 --> 00:08:57,930
would be quick consistent with the

00:08:55,529 --> 00:08:59,759
underlying operator which finally means

00:08:57,930 --> 00:09:04,769
you can overload operator comma to do

00:08:59,759 --> 00:09:08,430
what the built-in operator comma does so

00:09:04,769 --> 00:09:11,040
quick example X equals y plus plus plus

00:09:08,430 --> 00:09:12,629
y plus plus is now well-defined it means

00:09:11,040 --> 00:09:14,550
I'm going to increment Y and then add

00:09:12,629 --> 00:09:17,579
that to incrementing Y in exactly the

00:09:14,550 --> 00:09:19,769
order you see whereas if I call a

00:09:17,579 --> 00:09:22,499
function f with y plus plus comma y plus

00:09:19,769 --> 00:09:24,540
plus it's no longer undefined behavior

00:09:22,499 --> 00:09:27,089
it's going to do something and that

00:09:24,540 --> 00:09:29,550
something will be well defined at the

00:09:27,089 --> 00:09:32,160
language level but you don't know which

00:09:29,550 --> 00:09:34,110
values of the third those two arguments

00:09:32,160 --> 00:09:37,879
will be because the order of evaluation

00:09:34,110 --> 00:09:37,879
the 2y plus plus is you don't know

00:09:39,139 --> 00:09:45,300
ongoing language tweaks I think this is

00:09:41,699 --> 00:09:47,069
the end of the language now we've got

00:09:45,300 --> 00:09:49,769
this funky function coming into the

00:09:47,069 --> 00:09:52,529
standard library which is effectively a

00:09:49,769 --> 00:09:55,290
function that does nothing so it should

00:09:52,529 --> 00:09:57,629
be an operation but it gives information

00:09:55,290 --> 00:10:01,350
to the compiler regarding a lifetime of

00:09:57,629 --> 00:10:03,120
object the in particular obscure corner

00:10:01,350 --> 00:10:05,160
cases when you're building some of our

00:10:03,120 --> 00:10:07,410
more advanced data structures you get

00:10:05,160 --> 00:10:09,120
into corner cases about type safety of

00:10:07,410 --> 00:10:10,800
the language that's okay I'm going to

00:10:09,120 --> 00:10:14,370
destroy this thing in place and recreate

00:10:10,800 --> 00:10:15,660
another thing on top of it and how that

00:10:14,370 --> 00:10:16,829
interacts with a lifetime rules of the

00:10:15,660 --> 00:10:18,779
language you just need to give the

00:10:16,829 --> 00:10:20,550
compiler a hint so it doesn't say how

00:10:18,779 --> 00:10:22,110
you've got into undefined behavior the

00:10:20,550 --> 00:10:24,209
way you're abusing the type system here

00:10:22,110 --> 00:10:26,129
standard launder says we're about to do

00:10:24,209 --> 00:10:27,120
something funny mister compiler you're

00:10:26,129 --> 00:10:28,290
not allowed to optimize on the

00:10:27,120 --> 00:10:32,879
assumption that we weren't allowed to do

00:10:28,290 --> 00:10:35,339
that if you never hit one of those

00:10:32,879 --> 00:10:38,189
corner cases are thank you you're in the

00:10:35,339 --> 00:10:39,779
99.5% of C++ developers you never need

00:10:38,189 --> 00:10:41,370
to know about this but when you're

00:10:39,779 --> 00:10:43,410
trying to build some debt some data

00:10:41,370 --> 00:10:47,220
structures classic example be a flat map

00:10:43,410 --> 00:10:48,629
where I'm trying to resource ort my

00:10:47,220 --> 00:10:50,730
elements in my vector but I've got a

00:10:48,629 --> 00:10:52,860
comp a pair with a Const key so I need

00:10:50,730 --> 00:10:54,660
to somehow swap things with consti I

00:10:52,860 --> 00:10:56,639
need to play funny games with the type

00:10:54,660 --> 00:10:58,620
system and those games will probably

00:10:56,639 --> 00:11:00,509
involve calling standard launder to keep

00:10:58,620 --> 00:11:04,620
it all well-defined Const cast isn't

00:11:00,509 --> 00:11:06,929
enough final corner the memory

00:11:04,620 --> 00:11:08,640
allocation of over aligned data so when

00:11:06,929 --> 00:11:12,180
we call operating you

00:11:08,640 --> 00:11:14,610
do new with it yes what this is the

00:11:12,180 --> 00:11:16,800
arguments for the new operator prior to

00:11:14,610 --> 00:11:18,269
passing the arguments of constructor so

00:11:16,800 --> 00:11:21,959
it's like to be an in place new I can do

00:11:18,269 --> 00:11:26,790
a new with a size and an alignment using

00:11:21,959 --> 00:11:28,500
the new align val t enum class and those

00:11:26,790 --> 00:11:31,410
the full set of the core language

00:11:28,500 --> 00:11:35,910
changes so just in time to start on the

00:11:31,410 --> 00:11:38,070
library gsa is significantly larger in

00:11:35,910 --> 00:11:39,990
terms of page count hopefully will go

00:11:38,070 --> 00:11:43,290
fairly quickly because libraries are

00:11:39,990 --> 00:11:44,640
much easier to summarize because as soon

00:11:43,290 --> 00:11:46,740
as you go into depth you've suddenly got

00:11:44,640 --> 00:11:50,310
this much to talk about so i kept trying

00:11:46,740 --> 00:11:52,769
to talk about this match starting with

00:11:50,310 --> 00:11:54,300
the multi core support we've got these

00:11:52,769 --> 00:11:56,100
two terms we've been throwing around or

00:11:54,300 --> 00:11:58,050
just make sure that you're on the same

00:11:56,100 --> 00:12:00,209
page that the standard committee up and

00:11:58,050 --> 00:12:03,029
we talked about these terms parallelism

00:12:00,209 --> 00:12:05,880
is the idea of using multiple executing

00:12:03,029 --> 00:12:07,620
unit to perform the same computation as

00:12:05,880 --> 00:12:08,250
quickly a single computation as quickly

00:12:07,620 --> 00:12:09,779
as possible

00:12:08,250 --> 00:12:11,910
farming out lots of tiny parts or the

00:12:09,779 --> 00:12:13,470
same computation and collecting them all

00:12:11,910 --> 00:12:17,490
again at the end okay yep I've got my

00:12:13,470 --> 00:12:20,130
result concurrency is multiple threads

00:12:17,490 --> 00:12:22,500
of execution doing different things at

00:12:20,130 --> 00:12:23,760
the same time so that you know we get to

00:12:22,500 --> 00:12:25,380
the end when the last of those results

00:12:23,760 --> 00:12:27,449
is already oh it's a good way of

00:12:25,380 --> 00:12:29,100
reducing latency it's very useful when

00:12:27,449 --> 00:12:31,050
you're doing lots of them asynchronous

00:12:29,100 --> 00:12:32,970
processing but it's you know different

00:12:31,050 --> 00:12:35,459
kind of set of idioms and be usually

00:12:32,970 --> 00:12:37,620
different goals than parallelism just

00:12:35,459 --> 00:12:42,839
trying to accelerate some one specific

00:12:37,620 --> 00:12:46,230
thing as much as possible so we now have

00:12:42,839 --> 00:12:47,790
context per is always lock tree for your

00:12:46,230 --> 00:12:50,640
atomic types in the standard library you

00:12:47,790 --> 00:12:53,519
can query if they're lock free or not

00:12:50,640 --> 00:12:55,620
but prior to see per for seventeen that

00:12:53,519 --> 00:12:57,390
function itself wasn't Const expert so

00:12:55,620 --> 00:12:59,850
it was a runtime dispatch of your code

00:12:57,390 --> 00:13:01,410
now with it with context per the

00:12:59,850 --> 00:13:03,660
compiler could optimize that away and

00:13:01,410 --> 00:13:05,100
with if Const X but you can actually go

00:13:03,660 --> 00:13:07,290
down different branches of logic

00:13:05,100 --> 00:13:10,110
entirely so making that context was

00:13:07,290 --> 00:13:12,570
actually fairly handy we also have two

00:13:10,110 --> 00:13:16,019
new values that are context burb

00:13:12,570 --> 00:13:17,670
integers or size t types that aren't

00:13:16,019 --> 00:13:19,380
terribly meaningful to me cuz I do not

00:13:17,670 --> 00:13:20,880
work at this very low level but this is

00:13:19,380 --> 00:13:22,320
coming straight out of the folks who are

00:13:20,880 --> 00:13:24,029
working directly with

00:13:22,320 --> 00:13:25,800
hardware so your writing came for the

00:13:24,029 --> 00:13:28,050
PlayStation you've got a very good idea

00:13:25,800 --> 00:13:30,560
of your target the idea is these are

00:13:28,050 --> 00:13:33,630
describing the cache lines of your CPU

00:13:30,560 --> 00:13:35,550
so the compiler itself at compile time

00:13:33,630 --> 00:13:37,889
needs to know the cache lines of the

00:13:35,550 --> 00:13:39,569
target that you're optimizing for but if

00:13:37,889 --> 00:13:40,920
you can do that you're going to get

00:13:39,569 --> 00:13:42,720
values here that are going to be very

00:13:40,920 --> 00:13:45,600
useful otherwise it's going to give you

00:13:42,720 --> 00:13:47,850
its best guess values and your logical

00:13:45,600 --> 00:13:51,029
using those will be as good as the

00:13:47,850 --> 00:13:52,620
guesses but the really high throughput

00:13:51,029 --> 00:13:54,779
applications that are really sensitive

00:13:52,620 --> 00:13:57,180
to cache lines and specific hardware

00:13:54,779 --> 00:13:59,190
that can know the hardware they're going

00:13:57,180 --> 00:14:03,569
to be running on these can actually be

00:13:59,190 --> 00:14:05,819
incredibly useful so also on the

00:14:03,569 --> 00:14:09,209
concurrency side of the library C++ 14

00:14:05,819 --> 00:14:11,519
we added shared locks C++ 17 we're

00:14:09,209 --> 00:14:13,410
adding here mutex and they're very

00:14:11,519 --> 00:14:14,790
aliquot guard so the idea in the very

00:14:13,410 --> 00:14:16,709
early what guard is I'll say here's

00:14:14,790 --> 00:14:18,990
three four five different mutex is I

00:14:16,709 --> 00:14:21,449
want you to walk make sure that you

00:14:18,990 --> 00:14:26,610
acquire them in the same sequence every

00:14:21,449 --> 00:14:29,639
time which should resolve a potential

00:14:26,610 --> 00:14:35,370
risk of deadlock sit with some kinds of

00:14:29,639 --> 00:14:37,769
code on the big change it big progresses

00:14:35,370 --> 00:14:40,980
is we're adopting the parallelism TS

00:14:37,769 --> 00:14:43,019
which is adding parallel overloads for

00:14:40,980 --> 00:14:46,230
many but not quite all of the standard

00:14:43,019 --> 00:14:49,019
algorithms so what happens is all of the

00:14:46,230 --> 00:14:52,410
algorithms in basically the numeric and

00:14:49,019 --> 00:14:54,269
the algorithm header where we can we're

00:14:52,410 --> 00:14:56,459
adding an additional overload where the

00:14:54,269 --> 00:14:59,220
first temp first parameter to be used

00:14:56,459 --> 00:15:01,829
will be an execution policy that

00:14:59,220 --> 00:15:04,079
describes or give permission to the

00:15:01,829 --> 00:15:06,750
algorithm to make further assumptions

00:15:04,079 --> 00:15:09,470
that allow it to optimize its algorithm

00:15:06,750 --> 00:15:11,250
and dispatch using multiple threads or

00:15:09,470 --> 00:15:14,519
vectorization instructions other

00:15:11,250 --> 00:15:15,540
executing units we're not providing

00:15:14,519 --> 00:15:18,000
parallel support

00:15:15,540 --> 00:15:21,329
oddly enough algorithms involving random

00:15:18,000 --> 00:15:23,970
numbers because parallel random numbers

00:15:21,329 --> 00:15:25,920
are still a very interesting research

00:15:23,970 --> 00:15:27,480
area I mean I can provide parallel

00:15:25,920 --> 00:15:28,500
guarantees on a single thread but as

00:15:27,480 --> 00:15:30,569
soon as I go across multiple threads

00:15:28,500 --> 00:15:33,060
does each of those threads see the same

00:15:30,569 --> 00:15:34,319
quality of random numbers is your broad

00:15:33,060 --> 00:15:35,760
distribution across the threads also

00:15:34,319 --> 00:15:38,670
going to be good and random

00:15:35,760 --> 00:15:40,440
it's a tough topic to go into so we're

00:15:38,670 --> 00:15:42,690
just not going there

00:15:40,440 --> 00:15:45,660
keep operations other than querying it

00:15:42,690 --> 00:15:48,089
is heap or is heap until I'm not going

00:15:45,660 --> 00:15:49,680
to have the parallel overloads anything

00:15:48,089 --> 00:15:51,510
involving permutations as going from

00:15:49,680 --> 00:15:55,500
permutation to permutation tends to be a

00:15:51,510 --> 00:15:57,630
fairly serial algorithm and again these

00:15:55,500 --> 00:16:00,839
other algorithms I've got in Orange do

00:15:57,630 --> 00:16:04,160
not get parallel support we do add to

00:16:00,839 --> 00:16:07,079
the numeric header for new algorithms

00:16:04,160 --> 00:16:09,930
exclusive scan inclusive scan transform

00:16:07,079 --> 00:16:11,970
reduce and reduce that some of these I

00:16:09,930 --> 00:16:13,850
feel a bit if you're familiar with the

00:16:11,970 --> 00:16:16,980
term MapReduce will be making sense

00:16:13,850 --> 00:16:18,360
inclusive scan and exclusive scan I'm

00:16:16,980 --> 00:16:20,639
not particularly clear what they do but

00:16:18,360 --> 00:16:22,529
these terms are the terms of art used by

00:16:20,639 --> 00:16:24,899
the high-performance computing parallel

00:16:22,529 --> 00:16:26,279
community so if those terms resonate

00:16:24,899 --> 00:16:28,949
with you that probably what you think

00:16:26,279 --> 00:16:30,209
they mean when I look at the word scan

00:16:28,949 --> 00:16:32,910
this wasn't doing what I was expecting

00:16:30,209 --> 00:16:37,800
so read the spec if you want to know

00:16:32,910 --> 00:16:39,510
what they do changes since the TS was

00:16:37,800 --> 00:16:42,120
first published which is basically the

00:16:39,510 --> 00:16:43,889
last year now we have forward progress

00:16:42,120 --> 00:16:45,269
guarantees that I spoke about in the

00:16:43,889 --> 00:16:47,459
memory model back at the start of this

00:16:45,269 --> 00:16:49,560
talk we're applying those to describe

00:16:47,459 --> 00:16:52,769
the progress guarantees on the parallel

00:16:49,560 --> 00:16:54,569
algorithms themselves the execution

00:16:52,769 --> 00:16:57,690
policies were renamed to be something a

00:16:54,569 --> 00:17:02,550
little bit simpler is going to be using

00:16:57,690 --> 00:17:05,819
these frequently enough the behavior

00:17:02,550 --> 00:17:08,610
when an operation that the user supplies

00:17:05,819 --> 00:17:11,610
throws an exception has been changed to

00:17:08,610 --> 00:17:13,049
trap in the TS we tried to have a note

00:17:11,610 --> 00:17:14,880
in it when exception list we could

00:17:13,049 --> 00:17:16,709
accumulate a variety of exceptions and

00:17:14,880 --> 00:17:18,240
then throw an exception list object you

00:17:16,709 --> 00:17:20,730
could somehow retrieve the acceptance

00:17:18,240 --> 00:17:22,110
from without ever documenting how you

00:17:20,730 --> 00:17:24,660
would populate that exception list

00:17:22,110 --> 00:17:26,459
yourself now as we're promoting these up

00:17:24,660 --> 00:17:28,439
to the main standard it becomes

00:17:26,459 --> 00:17:30,960
important that the users writing their

00:17:28,439 --> 00:17:32,429
own parallel algorithms can interoperate

00:17:30,960 --> 00:17:33,840
with the standard algorithms in the same

00:17:32,429 --> 00:17:35,610
way people know the framework and if we

00:17:33,840 --> 00:17:38,280
can't populate around accepting lists

00:17:35,610 --> 00:17:40,290
that's going to be a problem but further

00:17:38,280 --> 00:17:42,510
even as we try to nail down what this

00:17:40,290 --> 00:17:43,610
meant we were seeing lots of problems

00:17:42,510 --> 00:17:45,570
with the formulation the next

00:17:43,610 --> 00:17:48,240
expectation of an accepting list in the

00:17:45,570 --> 00:17:49,690
standard so the policy has changed this

00:17:48,240 --> 00:17:51,580
if anything

00:17:49,690 --> 00:17:53,679
user-supplied operation so anything from

00:17:51,580 --> 00:17:57,549
one of your factors or the increment

00:17:53,679 --> 00:17:59,080
operator on your onion iterators or

00:17:57,549 --> 00:18:01,480
trying to dereference in the iterator if

00:17:59,080 --> 00:18:02,799
any of these operations throws the whole

00:18:01,480 --> 00:18:05,190
parallel algorithm would just call

00:18:02,799 --> 00:18:07,929
terminate and bring the process down and

00:18:05,190 --> 00:18:11,110
that includes when you're calling with

00:18:07,929 --> 00:18:12,460
the sequential execution policy so an

00:18:11,110 --> 00:18:15,580
algorithm with the sequential execution

00:18:12,460 --> 00:18:17,559
policy is not the same as calling the

00:18:15,580 --> 00:18:20,110
equivalent algorithm without a policy

00:18:17,559 --> 00:18:22,659
and this is not an accidental oversight

00:18:20,110 --> 00:18:25,350
it's deliberately by design because the

00:18:22,659 --> 00:18:28,059
idea is trying to debug parallel code is

00:18:25,350 --> 00:18:30,279
difficult enough switching to a

00:18:28,059 --> 00:18:32,470
sequential execution model of the same

00:18:30,279 --> 00:18:34,990
code having you sent with the same idiom

00:18:32,470 --> 00:18:37,419
in semantics is very helpful in tracking

00:18:34,990 --> 00:18:39,279
down the debugging if this is suddenly

00:18:37,419 --> 00:18:40,779
propagating exceptions rather than

00:18:39,279 --> 00:18:43,269
terminating it's not having the same

00:18:40,779 --> 00:18:45,629
behavior so the main reason that the

00:18:43,269 --> 00:18:48,100
sequential policy here is debugging aid

00:18:45,629 --> 00:18:54,669
to serve its purpose it has to terminate

00:18:48,100 --> 00:18:57,309
in the same way on the math side we

00:18:54,669 --> 00:19:01,059
incorporating the separate is that we

00:18:57,309 --> 00:19:02,769
created roundabout 2012 based upon the

00:19:01,059 --> 00:19:05,940
vibraphone the original library

00:19:02,769 --> 00:19:07,870
technical report we had 20 or so

00:19:05,940 --> 00:19:09,940
mathematical special functions in there

00:19:07,870 --> 00:19:12,190
so Bessel functions beta functions the

00:19:09,940 --> 00:19:14,019
Reimann zeta function if these terms

00:19:12,190 --> 00:19:15,759
resonate with you you know all the

00:19:14,019 --> 00:19:17,649
goodies you're getting if they don't

00:19:15,759 --> 00:19:19,090
resonate with you going to research

00:19:17,649 --> 00:19:21,639
these things it's probably not going to

00:19:19,090 --> 00:19:23,470
help you this is fairly obscure

00:19:21,639 --> 00:19:28,210
mathematics unless you're up at graduate

00:19:23,470 --> 00:19:31,299
level math there was a desire to

00:19:28,210 --> 00:19:33,639
incorporate those in C++ 14 that or even

00:19:31,299 --> 00:19:35,470
C++ 11 but there were concerns about the

00:19:33,639 --> 00:19:36,909
cost of implementing these and bigger

00:19:35,470 --> 00:19:38,379
concerns about the cost of supporting

00:19:36,909 --> 00:19:41,169
these you don't want to have somebody on

00:19:38,379 --> 00:19:42,940
the hotline who's got to answer I've got

00:19:41,169 --> 00:19:44,740
a bug report on your Bessel function is

00:19:42,940 --> 00:19:47,860
your gamma technical support phone

00:19:44,740 --> 00:19:49,450
capable of dealing with that but there's

00:19:47,860 --> 00:19:50,740
been sufficient demand for these now

00:19:49,450 --> 00:19:52,840
coming from certain scientific

00:19:50,740 --> 00:19:55,629
communities that the idea of maintaining

00:19:52,840 --> 00:19:58,419
two standards and the free availability

00:19:55,629 --> 00:19:59,799
of reason could weasel to good-quality

00:19:58,419 --> 00:20:01,269
implementations of these functions we've

00:19:59,799 --> 00:20:03,460
finally folded them into the main

00:20:01,269 --> 00:20:06,040
standard itself

00:20:03,460 --> 00:20:08,140
we're also grabbing on the smaller scale

00:20:06,040 --> 00:20:11,320
of things a three argument version of

00:20:08,140 --> 00:20:12,370
the hypotenuse function yay so we can do

00:20:11,320 --> 00:20:14,680
three-dimensional as well as

00:20:12,370 --> 00:20:16,150
two-dimensional triangles greatest

00:20:14,680 --> 00:20:19,060
common divisor and lowest coming at

00:20:16,150 --> 00:20:24,100
least common multiplier and we're adding

00:20:19,060 --> 00:20:25,690
a sample function so we will go over the

00:20:24,100 --> 00:20:28,060
rank begin end we will write through the

00:20:25,690 --> 00:20:30,790
output iterator a a number of samples

00:20:28,060 --> 00:20:36,160
using a specific random sequence and

00:20:30,790 --> 00:20:38,980
ingenuity in the realm of vocabulary

00:20:36,160 --> 00:20:40,420
types vocabulary types are the kind of

00:20:38,980 --> 00:20:42,880
thing that you want to use in your

00:20:40,420 --> 00:20:44,800
interfaces so vocabulary types work

00:20:42,880 --> 00:20:46,360
really well when there's very few of

00:20:44,800 --> 00:20:48,700
them if you've got seven ways to

00:20:46,360 --> 00:20:51,610
describe the same thing you're going to

00:20:48,700 --> 00:20:53,530
need an exponential combination of api's

00:20:51,610 --> 00:20:56,250
when things start interoperating with

00:20:53,530 --> 00:20:59,110
these ideas so the more we can get

00:20:56,250 --> 00:21:00,610
common vocabulary into the standard the

00:20:59,110 --> 00:21:03,910
more interoperable libraries will be

00:21:00,610 --> 00:21:05,530
that use the standard vocabulary so

00:21:03,910 --> 00:21:07,780
we've had pair for a while this is

00:21:05,530 --> 00:21:09,190
really you know a simplified version of

00:21:07,780 --> 00:21:11,200
tuples so we've already got a bit

00:21:09,190 --> 00:21:13,930
occasion about vocabulary there and

00:21:11,200 --> 00:21:16,080
we've got standard array so we've got a

00:21:13,930 --> 00:21:18,850
pairs you know contained with two types

00:21:16,080 --> 00:21:21,790
tuple is a heterogenous campaign

00:21:18,850 --> 00:21:24,730
container event values and array is a

00:21:21,790 --> 00:21:26,560
homogeneous container event values we

00:21:24,730 --> 00:21:29,880
now have the idea of optional which is

00:21:26,560 --> 00:21:34,090
i've got a value or it--don't which is

00:21:29,880 --> 00:21:35,620
clear you know it it's the type it's

00:21:34,090 --> 00:21:37,330
been wanted quite a while with people in

00:21:35,620 --> 00:21:39,520
getting around this by perhaps using

00:21:37,330 --> 00:21:42,040
pointers but then who owns a thing that

00:21:39,520 --> 00:21:43,330
the point is pointing to and you end up

00:21:42,040 --> 00:21:44,890
with lots of awkward code trying to

00:21:43,330 --> 00:21:47,080
manage the lifetime of these things so

00:21:44,890 --> 00:21:49,450
standard optional is the primal

00:21:47,080 --> 00:21:52,080
vocabulary for expressing a result that

00:21:49,450 --> 00:21:55,090
either produces something or doesn't

00:21:52,080 --> 00:21:56,890
standard any is the vocabulary type it's

00:21:55,090 --> 00:21:58,630
a container for one of anything as long

00:21:56,890 --> 00:22:00,850
as that thing is copy constructible and

00:21:58,630 --> 00:22:02,770
you can hold it you'll notice it's not a

00:22:00,850 --> 00:22:04,950
template it's just a regular type that

00:22:02,770 --> 00:22:07,150
holds anything let's copy constructible

00:22:04,950 --> 00:22:08,560
the fun comes when you want to take the

00:22:07,150 --> 00:22:14,170
value back out but we'll get to that

00:22:08,560 --> 00:22:15,550
later variant is kind of like optional

00:22:14,170 --> 00:22:16,750
it's a container of one thing but in

00:22:15,550 --> 00:22:18,880
this case it's one of us

00:22:16,750 --> 00:22:20,620
sequence of types so I've got a bunch of

00:22:18,880 --> 00:22:22,020
types it can hold one of them and you

00:22:20,620 --> 00:22:24,700
can tell me which one it's holding

00:22:22,020 --> 00:22:26,410
unlike any which can hold anything which

00:22:24,700 --> 00:22:28,840
is a much larger set of types but I

00:22:26,410 --> 00:22:30,520
don't know which one it's holding and

00:22:28,840 --> 00:22:33,460
the other vocabulary type that's been

00:22:30,520 --> 00:22:35,680
coming through is string view which is a

00:22:33,460 --> 00:22:37,600
reference into a string that doesn't

00:22:35,680 --> 00:22:39,070
actually own the string is much more

00:22:37,600 --> 00:22:42,330
like to wait for passing around as a

00:22:39,070 --> 00:22:46,240
vocabulary type in a lot of interfaces

00:22:42,330 --> 00:22:47,920
so pet and tuple every standards we have

00:22:46,240 --> 00:22:51,520
a new way to clean up and break pair

00:22:47,920 --> 00:22:54,730
interval so C++ 14 we added the ability

00:22:51,520 --> 00:22:56,920
to retrieve an item out of your parrot

00:22:54,730 --> 00:22:59,170
apple with a get of the type rather than

00:22:56,920 --> 00:23:02,590
get of the index so we've got a couple

00:22:59,170 --> 00:23:05,290
of in this case an int a standard string

00:23:02,590 --> 00:23:07,450
and a double if I call get the int it

00:23:05,290 --> 00:23:10,060
knows I wanted to get the one out of

00:23:07,450 --> 00:23:12,310
there if on the other hand I had to intz

00:23:10,060 --> 00:23:17,830
it would be ambiguous and the call would

00:23:12,310 --> 00:23:20,020
fail to compile in C++ 17 all the

00:23:17,830 --> 00:23:23,520
Constructors for parent supple and now

00:23:20,020 --> 00:23:25,300
we're going conditionally explicit now

00:23:23,520 --> 00:23:27,550
explicit constructors were an

00:23:25,300 --> 00:23:29,530
interesting thing in C++ 98 but only

00:23:27,550 --> 00:23:31,960
meant something useful when you had a

00:23:29,530 --> 00:23:34,000
single argument when we expanded the

00:23:31,960 --> 00:23:37,150
rules for brace initialization for C++

00:23:34,000 --> 00:23:39,060
11 explicit constructors with multiple

00:23:37,150 --> 00:23:42,460
arguments suddenly acquired a meaning

00:23:39,060 --> 00:23:44,230
and that was unfortunate for tip all

00:23:42,460 --> 00:23:46,180
that had made its multiple argument form

00:23:44,230 --> 00:23:47,740
explicit on the grounds that that might

00:23:46,180 --> 00:23:51,700
be a single argument and we didn't want

00:23:47,740 --> 00:23:55,510
the implicit conversions they're trying

00:23:51,700 --> 00:23:57,880
to resolve that issue ran through a

00:23:55,510 --> 00:24:00,130
variety of design choices but the one

00:23:57,880 --> 00:24:04,600
we've come down to is if my

00:24:00,130 --> 00:24:07,240
initialization of that tuple with that

00:24:04,600 --> 00:24:10,630
set of arguments with hit an explicit

00:24:07,240 --> 00:24:12,970
constructor then that same constructor

00:24:10,630 --> 00:24:15,580
of tuple should be explicit

00:24:12,970 --> 00:24:19,000
so we inherit the explicitness kind of

00:24:15,580 --> 00:24:21,400
in it inherits up from the elements of

00:24:19,000 --> 00:24:23,320
the tuple itself but it's specific to

00:24:21,400 --> 00:24:26,380
that form of initialization so we've got

00:24:23,320 --> 00:24:28,120
a converting constructor with many

00:24:26,380 --> 00:24:30,100
parameters it checks each of those

00:24:28,120 --> 00:24:32,919
individual constructions and says if

00:24:30,100 --> 00:24:35,020
fat's annexed was a constructor then

00:24:32,919 --> 00:24:37,660
that constructor will be marked explicit

00:24:35,020 --> 00:24:39,370
otherwise there's no explicit there this

00:24:37,660 --> 00:24:42,820
is a joy to implement as you can only

00:24:39,370 --> 00:24:44,950
imagine no we have no language support

00:24:42,820 --> 00:24:47,080
and no the core folks have no interest

00:24:44,950 --> 00:24:50,460
whatsoever in jumping down this rathole

00:24:47,080 --> 00:24:53,200
to give us language support but once you

00:24:50,460 --> 00:24:55,750
can it got the tricks it's it's fun a

00:24:53,200 --> 00:24:58,870
fun problem to solve and a painful want

00:24:55,750 --> 00:25:01,840
to keep implementing one of the other

00:24:58,870 --> 00:25:03,429
things we can do now is we can for a

00:25:01,840 --> 00:25:04,960
long time be able to pack function

00:25:03,429 --> 00:25:07,179
arguments for example with make to put

00:25:04,960 --> 00:25:09,549
into a tuple we've not been able to go

00:25:07,179 --> 00:25:11,169
the other way and unpack the arguments

00:25:09,549 --> 00:25:13,570
into a function call or a functor call

00:25:11,169 --> 00:25:16,120
so now we have the apply function to say

00:25:13,570 --> 00:25:18,070
here's a function here's some arguments

00:25:16,120 --> 00:25:19,510
practing the tupple unpack them and call

00:25:18,070 --> 00:25:22,179
the function with the unpacked arguments

00:25:19,510 --> 00:25:24,730
for me i believe it was actually sitting

00:25:22,179 --> 00:25:27,549
around as an example in the c++ 14

00:25:24,730 --> 00:25:31,870
standard and that exact example is now

00:25:27,549 --> 00:25:33,640
just the definition of the library and

00:25:31,870 --> 00:25:35,799
finally similar to the apply function

00:25:33,640 --> 00:25:38,590
going the other way we can construct an

00:25:35,799 --> 00:25:41,049
object by unpacking a tuple so this is

00:25:38,590 --> 00:25:44,650
equivalent of apply for a constructor so

00:25:41,049 --> 00:25:46,360
kind of like make pyramid but make sure

00:25:44,650 --> 00:25:49,480
that make unique you you specify the

00:25:46,360 --> 00:25:52,960
type of thing you want to construct so

00:25:49,480 --> 00:25:55,419
I've got a tuple using me then you funny

00:25:52,960 --> 00:25:57,159
constructed deduced type syntax auto

00:25:55,419 --> 00:25:59,860
tuple one one two three

00:25:57,159 --> 00:26:01,630
I can then why I can make from tuple and

00:25:59,860 --> 00:26:03,070
say I'm going to make a my type I've got

00:26:01,630 --> 00:26:04,750
to specify the type in the angle

00:26:03,070 --> 00:26:06,669
brackets but it will then unpack the

00:26:04,750 --> 00:26:12,940
trouble to the appropriate constructor

00:26:06,669 --> 00:26:14,650
of my type OP film so this is the idea

00:26:12,940 --> 00:26:18,850
of a type that's going to substitute for

00:26:14,650 --> 00:26:22,480
T and behave exactly like a T if T has a

00:26:18,850 --> 00:26:23,860
value the default constructor is going

00:26:22,480 --> 00:26:26,650
to go into the empty state though so I

00:26:23,860 --> 00:26:28,990
don't have a value the reason say

00:26:26,650 --> 00:26:32,130
behaves exactly like T is when you get

00:26:28,990 --> 00:26:34,870
to the overloaded relational operators

00:26:32,130 --> 00:26:39,940
classic example I've got an optional

00:26:34,870 --> 00:26:41,980
double and the double holds an an the

00:26:39,940 --> 00:26:44,080
standard way that the library has so far

00:26:41,980 --> 00:26:47,500
approach is defining the six where

00:26:44,080 --> 00:26:49,570
operators is you define equal equals and

00:26:47,500 --> 00:26:53,080
then not equals is the negation of equal

00:26:49,570 --> 00:26:55,540
equals so if I do equal equal on an

00:26:53,080 --> 00:26:57,550
optional double holding an am it will

00:26:55,540 --> 00:26:59,710
say yes false then and doesn't equal

00:26:57,550 --> 00:27:01,960
itself okay does it not equal itself

00:26:59,710 --> 00:27:03,220
under the old rules it would not equal

00:27:01,960 --> 00:27:05,440
itself because it's the negation of

00:27:03,220 --> 00:27:07,300
equal equals but if I'm holding an am

00:27:05,440 --> 00:27:09,940
and passed directly down to the nan

00:27:07,300 --> 00:27:11,770
operator not equals also returns no I

00:27:09,940 --> 00:27:13,630
don't equal myself and now the equal

00:27:11,770 --> 00:27:18,250
myself nor do not equal myself I'm a

00:27:13,630 --> 00:27:20,500
bizarre thing Emma nan so optional t4

00:27:18,250 --> 00:27:23,230
words or six relational operators down

00:27:20,500 --> 00:27:24,700
to the underlying T rather than

00:27:23,230 --> 00:27:27,460
synthesizing them the way we've always

00:27:24,700 --> 00:27:30,730
done in the library in the past this is

00:27:27,460 --> 00:27:32,500
a really contentious design call but the

00:27:30,730 --> 00:27:34,870
fundamental idea is no optional T is

00:27:32,500 --> 00:27:37,120
really intended to stand in for the

00:27:34,870 --> 00:27:38,980
original T so it's important to have

00:27:37,120 --> 00:27:41,130
these semantics rather than we invented

00:27:38,980 --> 00:27:43,330
something else to go along with them

00:27:41,130 --> 00:27:45,220
from that we need to say well where does

00:27:43,330 --> 00:27:47,880
the empty state order and yeah it's less

00:27:45,220 --> 00:27:47,880
than all the others

00:27:48,030 --> 00:27:53,560
and yeah you access the element by

00:27:51,820 --> 00:27:56,140
dereferencing it as if it or a smart

00:27:53,560 --> 00:27:59,320
pointer that makes it relatively easy to

00:27:56,140 --> 00:28:01,150
do in existing code that has been using

00:27:59,320 --> 00:28:03,070
pointers to represent this kind of idiom

00:28:01,150 --> 00:28:07,300
in the past especially going through our

00:28:03,070 --> 00:28:10,540
functional interfaces next one about

00:28:07,300 --> 00:28:13,150
vocabulary types we have variant this is

00:28:10,540 --> 00:28:15,730
an interesting type in that this didn't

00:28:13,150 --> 00:28:19,480
go through any of the TS processes it

00:28:15,730 --> 00:28:21,220
came in it was just missed getting into

00:28:19,480 --> 00:28:23,620
the fundamentals to TS it was a

00:28:21,220 --> 00:28:25,120
slam-dunk my fundamentals three but

00:28:23,620 --> 00:28:26,980
given by having all about other

00:28:25,120 --> 00:28:29,380
vocabulary types shipping in this

00:28:26,980 --> 00:28:31,780
standard and the huge amount of time was

00:28:29,380 --> 00:28:34,180
burnt getting this design right there

00:28:31,780 --> 00:28:36,190
was a real desire to ship this in the

00:28:34,180 --> 00:28:37,600
same vehicle so bearing has come all the

00:28:36,190 --> 00:28:40,750
way up the process and the shipping in

00:28:37,600 --> 00:28:42,340
C++ 17 in particular there was a strong

00:28:40,750 --> 00:28:45,010
concern that shipping any without

00:28:42,340 --> 00:28:47,500
variant would lead to people over using

00:28:45,010 --> 00:28:50,800
any interfaces where variant was the

00:28:47,500 --> 00:28:53,200
right answer so the idea of variant is

00:28:50,800 --> 00:28:55,180
it always holds a value this was one of

00:28:53,200 --> 00:28:57,430
those again an important awkward design

00:28:55,180 --> 00:28:59,379
question that can variant have an empty

00:28:57,430 --> 00:29:01,600
state

00:28:59,379 --> 00:29:04,090
code is a lot simpler if I never need to

00:29:01,600 --> 00:29:06,879
worry about the variant being any I can

00:29:04,090 --> 00:29:09,970
just you know visit it query it and it

00:29:06,879 --> 00:29:11,740
will always have a good answer but

00:29:09,970 --> 00:29:13,600
there's a cost having a never empty

00:29:11,740 --> 00:29:15,250
guarantee and that cost typically

00:29:13,600 --> 00:29:17,139
consists of double buffering cos if I'm

00:29:15,250 --> 00:29:18,879
reassigning a new value to the variant

00:29:17,139 --> 00:29:21,039
and the reassignment fails by throwing

00:29:18,879 --> 00:29:24,129
an exception how do I get the original

00:29:21,039 --> 00:29:25,570
about the original value back typically

00:29:24,129 --> 00:29:26,950
I would have that in a second but for

00:29:25,570 --> 00:29:29,649
now I would just translate between the

00:29:26,950 --> 00:29:31,450
two but that so that I've always got a

00:29:29,649 --> 00:29:33,429
good state and can just transition one

00:29:31,450 --> 00:29:35,889
way or the other but that now means I'm

00:29:33,429 --> 00:29:37,960
paying twice the space overhead to my

00:29:35,889 --> 00:29:40,000
variant than I would want or I could

00:29:37,960 --> 00:29:42,190
allow for the fact variance can be empty

00:29:40,000 --> 00:29:44,620
and therefore always have to query the

00:29:42,190 --> 00:29:46,090
empty state worrying about my that in

00:29:44,620 --> 00:29:49,779
addition to all the other states in the

00:29:46,090 --> 00:29:52,690
variant so people banged on this really

00:29:49,779 --> 00:29:54,429
hard in terms of design and it was seen

00:29:52,690 --> 00:29:56,169
that the majority of types that users

00:29:54,429 --> 00:29:58,440
want to store in these as long as

00:29:56,169 --> 00:29:59,649
they've got a well-defined no throw move

00:29:58,440 --> 00:30:02,590
constructor

00:29:59,649 --> 00:30:04,360
you can always temporarily move away the

00:30:02,590 --> 00:30:08,320
object and you've got a guaranteed

00:30:04,360 --> 00:30:09,850
ability to move it back so it's common

00:30:08,320 --> 00:30:14,169
for implementations to be able to

00:30:09,850 --> 00:30:16,389
eliminate the empty state the need for

00:30:14,169 --> 00:30:17,580
the empty state and not consume extra

00:30:16,389 --> 00:30:20,409
storage

00:30:17,580 --> 00:30:22,210
but in those rare cases where users do

00:30:20,409 --> 00:30:24,340
give us these awkward things that throw

00:30:22,210 --> 00:30:26,590
we've now introducing this valueless by

00:30:24,340 --> 00:30:29,710
exception state which isn't a state you

00:30:26,590 --> 00:30:31,090
can construct directly this is why it's

00:30:29,710 --> 00:30:32,769
different when actually having an empty

00:30:31,090 --> 00:30:35,159
state in the vector it's not something

00:30:32,769 --> 00:30:38,080
in the variance or you can't request it

00:30:35,159 --> 00:30:40,120
but you need to be aware that yes

00:30:38,080 --> 00:30:42,340
variants can enter this strange

00:30:40,120 --> 00:30:43,960
valueless state if an exception is

00:30:42,340 --> 00:30:46,059
thrown it's a particularly awkward time

00:30:43,960 --> 00:30:47,919
if you want the program against the

00:30:46,059 --> 00:30:49,629
never empty guarantee and assume it

00:30:47,919 --> 00:30:51,659
doesn't happen most of the time you'll

00:30:49,629 --> 00:30:53,830
be correct and I liken this to

00:30:51,659 --> 00:30:55,929
programming with doubles and ignoring

00:30:53,830 --> 00:30:58,059
the idea that Nan's might be in my data

00:30:55,929 --> 00:30:59,350
set the majority of the time I control

00:30:58,059 --> 00:31:01,480
things well enough that this isn't going

00:30:59,350 --> 00:31:03,639
to occur especially from writing

00:31:01,480 --> 00:31:05,740
non-generic code so I know all the types

00:31:03,639 --> 00:31:08,320
that are in my variant but in generic

00:31:05,740 --> 00:31:09,909
code every so often I might have to

00:31:08,320 --> 00:31:11,250
worry about this and then I've got the

00:31:09,909 --> 00:31:13,169
empty state and those

00:31:11,250 --> 00:31:14,549
algorithms will just be a little bit

00:31:13,169 --> 00:31:18,630
more complicated to implement and I

00:31:14,549 --> 00:31:22,169
might have intended so other obvious

00:31:18,630 --> 00:31:24,510
things so I can access by type because

00:31:22,169 --> 00:31:26,700
variant holds things by type but we're

00:31:24,510 --> 00:31:28,559
also allowed duplicate types in that set

00:31:26,700 --> 00:31:31,070
of types and therefore I can access by

00:31:28,559 --> 00:31:35,730
index so and whatever the third type was

00:31:31,070 --> 00:31:37,080
and we have a variant size and variant

00:31:35,730 --> 00:31:38,730
element I think they're the reforms of

00:31:37,080 --> 00:31:40,620
tuple size and tuple elements so I can

00:31:38,730 --> 00:31:45,179
introspectively query what types of

00:31:40,620 --> 00:31:47,370
variant can hold similar to a C++ Union

00:31:45,179 --> 00:31:49,830
the default constructor is going to

00:31:47,370 --> 00:31:51,510
value initialize the first of the

00:31:49,830 --> 00:31:54,620
alternatives in that type list as if

00:31:51,510 --> 00:31:58,049
that were the first element of a union

00:31:54,620 --> 00:32:00,480
and again in a manner similar to the

00:31:58,049 --> 00:32:03,630
optional library it's overloading all

00:32:00,480 --> 00:32:05,640
six operators as if trying to forward

00:32:03,630 --> 00:32:07,530
them to the underlying operation between

00:32:05,640 --> 00:32:10,320
the two the elements held in the two

00:32:07,530 --> 00:32:12,240
variants but first of all we check if

00:32:10,320 --> 00:32:14,280
they've got the same index and we'll

00:32:12,240 --> 00:32:15,539
order by index before we order by okay I

00:32:14,280 --> 00:32:17,520
mean I've got two things I know that the

00:32:15,539 --> 00:32:19,559
same type so I can now just do the query

00:32:17,520 --> 00:32:21,690
on the operation for those same types on

00:32:19,559 --> 00:32:25,220
the assumption that operator exists if

00:32:21,690 --> 00:32:27,120
the operator doesn't exist the whole

00:32:25,220 --> 00:32:28,710
comparison for that variants going to

00:32:27,120 --> 00:32:29,970
fail regardless of what type it's

00:32:28,710 --> 00:32:34,280
holding because that's a compile time

00:32:29,970 --> 00:32:37,020
constraint standard any as I said before

00:32:34,280 --> 00:32:38,789
can hold any copy constructible thing

00:32:37,020 --> 00:32:40,440
because it's going to dynamically

00:32:38,789 --> 00:32:43,530
allocate a copy of that thing

00:32:40,440 --> 00:32:45,210
essentially on the heap we might have

00:32:43,530 --> 00:32:47,100
some small object optimizations if you

00:32:45,210 --> 00:32:49,409
strike start passing integers and so

00:32:47,100 --> 00:32:51,059
forth but mostly if you're storing

00:32:49,409 --> 00:32:53,100
something in any object you've got a

00:32:51,059 --> 00:32:55,080
dynamic allocation and it's copied onto

00:32:53,100 --> 00:32:57,210
the heap if I make a copy of the any

00:32:55,080 --> 00:33:00,270
object it makes a copy of that thing on

00:32:57,210 --> 00:33:02,880
the heap so both any objects have their

00:33:00,270 --> 00:33:05,370
own copy if I want to get something out

00:33:02,880 --> 00:33:08,039
of the any object I've got to know what

00:33:05,370 --> 00:33:09,600
type that is and then we go we query it

00:33:08,039 --> 00:33:11,909
with the anycast

00:33:09,600 --> 00:33:14,520
function which is kind of the funny

00:33:11,909 --> 00:33:17,130
dynamic cast we have on smart pointers

00:33:14,520 --> 00:33:19,860
we've now got any cast is a way to try

00:33:17,130 --> 00:33:22,169
to retrieve the item out of in any I can

00:33:19,860 --> 00:33:22,800
retrieve it by reference any caster to

00:33:22,169 --> 00:33:24,960
an end

00:33:22,800 --> 00:33:27,210
and if my any holds an int I have an

00:33:24,960 --> 00:33:31,110
improv if it doesn't it's going to throw

00:33:27,210 --> 00:33:34,010
a bad any exit bad any cast except and I

00:33:31,110 --> 00:33:35,910
think it throws an exception and

00:33:34,010 --> 00:33:38,520
conversely I could try and retrieve it

00:33:35,910 --> 00:33:40,080
by pointer and that case I'll have a no

00:33:38,520 --> 00:33:42,320
accept guarantee but it will just give

00:33:40,080 --> 00:33:46,320
me a null pointer if the cast fails I

00:33:42,320 --> 00:33:47,880
can also query the type ID of the object

00:33:46,320 --> 00:33:50,460
that's held but there's not a whole lot

00:33:47,880 --> 00:33:52,260
you can do with a C++ type ID that might

00:33:50,460 --> 00:33:54,450
give you a clue as to how the API is

00:33:52,260 --> 00:33:56,250
implemented though in particular it will

00:33:54,450 --> 00:33:58,140
not do based derived conversions for

00:33:56,250 --> 00:34:03,510
compatibility and pointers for you it's

00:33:58,140 --> 00:34:06,270
got to be an exact match in the world of

00:34:03,510 --> 00:34:08,460
text handling we've now got basic string

00:34:06,270 --> 00:34:11,130
view which is the analog of basic string

00:34:08,460 --> 00:34:14,490
it's kind of like an AK on string

00:34:11,130 --> 00:34:16,679
reference given that everyone seems to

00:34:14,490 --> 00:34:19,830
agree that it's a real shame that basic

00:34:16,679 --> 00:34:20,940
string has way too many functions we

00:34:19,830 --> 00:34:22,740
want to use this as a drop-in

00:34:20,940 --> 00:34:25,140
replacement for basic stringing menu

00:34:22,740 --> 00:34:27,390
function so it has the same way to many

00:34:25,140 --> 00:34:29,910
member functions it's basically got

00:34:27,390 --> 00:34:32,910
every Const qualified member function of

00:34:29,910 --> 00:34:35,580
basic string and it's got a couple more

00:34:32,910 --> 00:34:37,860
that allow you to shrink and grow the

00:34:35,580 --> 00:34:40,140
range that you're viewing over on the

00:34:37,860 --> 00:34:41,730
underlying string being idea being it's

00:34:40,140 --> 00:34:43,919
your job to make sure you don't go over

00:34:41,730 --> 00:34:46,169
the band so shrinking is easy but if

00:34:43,919 --> 00:34:48,030
you're trying to grow the range of your

00:34:46,169 --> 00:34:51,929
viewing it's your job to make sure you

00:34:48,030 --> 00:34:53,870
don't go out of bounds we also have a

00:34:51,929 --> 00:34:55,919
faster string searching network

00:34:53,870 --> 00:34:58,860
framework in the book using the by or

00:34:55,919 --> 00:35:02,460
more algorithms the idea here is I'm

00:34:58,860 --> 00:35:05,010
going to have a large I'm trying to

00:35:02,460 --> 00:35:07,590
search for a common string across lots

00:35:05,010 --> 00:35:09,090
of different bodies of texts so I can

00:35:07,590 --> 00:35:11,010
effectively construct a small finite

00:35:09,090 --> 00:35:13,230
state machine to describe how I would

00:35:11,010 --> 00:35:14,880
search for that string to say ok once

00:35:13,230 --> 00:35:17,040
I've searched I'm actually first seven

00:35:14,880 --> 00:35:19,260
characters but not the last the eighth

00:35:17,040 --> 00:35:20,490
one failed I know I can usually jump

00:35:19,260 --> 00:35:22,710
seven characters in the underlying

00:35:20,490 --> 00:35:24,720
sequence unless there's some common

00:35:22,710 --> 00:35:28,410
subsequences which might mean I jumper a

00:35:24,720 --> 00:35:30,870
smaller amount so it's a handy way of

00:35:28,410 --> 00:35:34,259
people researching for the same string

00:35:30,870 --> 00:35:36,579
in many different bodies of text

00:35:34,259 --> 00:35:39,579
minor fix for basic string we've got a

00:35:36,579 --> 00:35:41,259
data member function that only had a

00:35:39,579 --> 00:35:43,119
Const are valid so we now allow the non

00:35:41,259 --> 00:35:46,150
constable owed so I can pass the content

00:35:43,119 --> 00:35:48,220
of a string to a an underlying C API on

00:35:46,150 --> 00:35:49,900
the group with the understanding that

00:35:48,220 --> 00:35:51,789
I'm not going to try and change the

00:35:49,900 --> 00:35:52,839
length of that string in particular I'm

00:35:51,789 --> 00:35:54,970
not allowed to overwrite the null

00:35:52,839 --> 00:35:57,039
terminating now I can introduce other

00:35:54,970 --> 00:35:59,200
null bytes because strings are allowed

00:35:57,039 --> 00:36:03,339
to have null values but the terminating

00:35:59,200 --> 00:36:05,349
though should not be over in and final

00:36:03,339 --> 00:36:07,630
thing in the purple we've got a high

00:36:05,349 --> 00:36:11,109
performance number string passing

00:36:07,630 --> 00:36:13,240
library coming in this is in pink

00:36:11,109 --> 00:36:16,210
because when we came to apply those

00:36:13,240 --> 00:36:17,890
edits to the final standard it didn't

00:36:16,210 --> 00:36:19,690
apply clean there were a couple of minor

00:36:17,890 --> 00:36:22,859
issues that were picked up in the

00:36:19,690 --> 00:36:25,599
interface there so we're sending it back

00:36:22,859 --> 00:36:27,249
well well my file encompasses say it was

00:36:25,599 --> 00:36:29,200
meant to land but the editors weren't in

00:36:27,249 --> 00:36:30,759
a position they could merge it cleanly

00:36:29,200 --> 00:36:33,249
we expect that to be cleaned up and that

00:36:30,759 --> 00:36:35,200
is still expected to be a part of C++ 17

00:36:33,249 --> 00:36:39,880
when the actual standard is published

00:36:35,200 --> 00:36:43,589
next year far system library is our last

00:36:39,880 --> 00:36:46,630
large TS that's being landed into C++ 17

00:36:43,589 --> 00:36:48,489
so basically were adopting the TS as was

00:36:46,630 --> 00:36:51,910
published around about the same time as

00:36:48,489 --> 00:36:53,230
C++ 14 and resolving a bunch of defect

00:36:51,910 --> 00:36:55,779
reports are coming in over the

00:36:53,230 --> 00:36:57,849
intervening three years the

00:36:55,779 --> 00:37:00,400
specification is based on the POSIX

00:36:57,849 --> 00:37:02,200
standard to define the noting of a file

00:37:00,400 --> 00:37:03,579
system what it means to navigate a file

00:37:02,200 --> 00:37:05,710
system and all the operations on the

00:37:03,579 --> 00:37:10,150
file system it doesn't mean you have to

00:37:05,710 --> 00:37:12,309
have a POSIX file system underneath but

00:37:10,150 --> 00:37:13,869
it does mean that you've got your the

00:37:12,309 --> 00:37:15,999
fastest um that you're using should

00:37:13,869 --> 00:37:18,579
hopefully have a fairly clean mapping to

00:37:15,999 --> 00:37:22,059
the POSIX semantics so that this library

00:37:18,579 --> 00:37:23,710
can be layered on top one of the big

00:37:22,059 --> 00:37:25,390
concerns that was reported against this

00:37:23,710 --> 00:37:26,890
and did give us some pause about whether

00:37:25,390 --> 00:37:28,660
we were correct to adopt this at this

00:37:26,890 --> 00:37:32,200
point is that we have no protection

00:37:28,660 --> 00:37:36,759
against data races at the file system

00:37:32,200 --> 00:37:38,589
level so make a file that you know make

00:37:36,759 --> 00:37:40,329
a temporary file name now open the file

00:37:38,589 --> 00:37:43,329
name somebody can afford things in the

00:37:40,329 --> 00:37:45,369
middle is an opportunity for an attacker

00:37:43,329 --> 00:37:47,579
to do a man-in-the-middle kind of attack

00:37:45,369 --> 00:37:49,589
on your code so this is not in

00:37:47,579 --> 00:37:52,289
tended for that kind of application

00:37:49,589 --> 00:37:53,910
we're securities our real concern if I'm

00:37:52,289 --> 00:37:58,619
writing small applications to know to

00:37:53,910 --> 00:38:01,650
mind my own opera own machine or many

00:37:58,619 --> 00:38:03,209
common uses where security is I'm within

00:38:01,650 --> 00:38:03,809
a constraint where I don't have to worry

00:38:03,209 --> 00:38:06,569
about that

00:38:03,809 --> 00:38:09,959
it's more than good enough but please be

00:38:06,569 --> 00:38:12,359
aware do not use this up this library

00:38:09,959 --> 00:38:14,339
thinking you're going to not be

00:38:12,359 --> 00:38:15,749
introducing any see using this fiber is

00:38:14,339 --> 00:38:18,630
going to injuries potential security

00:38:15,749 --> 00:38:23,729
holes in your code be aware of that

00:38:18,630 --> 00:38:26,309
concern it uses the system error

00:38:23,729 --> 00:38:28,859
reporting the system error exception

00:38:26,309 --> 00:38:32,489
handling exception categorization that

00:38:28,859 --> 00:38:33,959
we introduced in C++ 11 and all the new

00:38:32,489 --> 00:38:36,690
facilities that come from the file

00:38:33,959 --> 00:38:37,559
system TS are added in the STD file

00:38:36,690 --> 00:38:39,959
system namespace

00:38:37,559 --> 00:38:41,640
I'm not going to exhaustively enumerate

00:38:39,959 --> 00:38:44,339
them all because as I said this is a

00:38:41,640 --> 00:38:46,589
quick catch-up and of things we have so

00:38:44,339 --> 00:38:49,890
a quick categorization and a few things

00:38:46,589 --> 00:38:52,380
that changed into the ETS the basic

00:38:49,890 --> 00:38:54,509
class is file path that you will notice

00:38:52,380 --> 00:38:57,299
is a regular class it's not a class

00:38:54,509 --> 00:38:59,759
template like basic string it's a class

00:38:57,299 --> 00:39:01,829
that can traffic is constructors will

00:38:59,759 --> 00:39:04,049
take a regular string and a wide string

00:39:01,829 --> 00:39:07,680
and now that we have them but also a

00:39:04,049 --> 00:39:10,099
string view in a wide string view on top

00:39:07,680 --> 00:39:12,839
of that we've added a lexical API for

00:39:10,099 --> 00:39:14,609
decoding relative paths so I say it's a

00:39:12,839 --> 00:39:16,619
lexical API because we're doing

00:39:14,609 --> 00:39:19,229
operations purely on the string names

00:39:16,619 --> 00:39:21,719
themselves and we're not querying the

00:39:19,229 --> 00:39:24,869
operating system to say how do i best

00:39:21,719 --> 00:39:26,519
map from this path to this other path

00:39:24,869 --> 00:39:29,219
which might have to deal with things

00:39:26,519 --> 00:39:30,329
like symlinks and so forth resolving

00:39:29,219 --> 00:39:33,959
through those paths might be able to

00:39:30,329 --> 00:39:38,519
find shorter resolutions will not find

00:39:33,959 --> 00:39:39,539
the canonical resolutions so the key

00:39:38,519 --> 00:39:42,390
things that we get from the filesystem

00:39:39,539 --> 00:39:44,309
API are functions and iterators that

00:39:42,390 --> 00:39:46,229
allow us to navigate a filesystem and

00:39:44,309 --> 00:39:49,380
then the corresponding operations that

00:39:46,229 --> 00:39:52,849
is create delete files and directories

00:39:49,380 --> 00:39:52,849
and symlinks and so forth

00:39:52,890 --> 00:39:56,819
tap traits library type traits is a

00:39:55,199 --> 00:39:58,709
popular library if ever you're doing

00:39:56,819 --> 00:40:01,999
anything with templates because the idea

00:39:58,709 --> 00:40:06,509
to introspect and guide your template

00:40:01,999 --> 00:40:11,519
algorithms accordingly is a you too too

00:40:06,509 --> 00:40:14,519
much to pass so in sequence or 17 or C++

00:40:11,519 --> 00:40:16,890
14 we added a bunch of alias templates

00:40:14,519 --> 00:40:19,019
for all the type traits that computed in

00:40:16,890 --> 00:40:20,640
return two types with an underscore T

00:40:19,019 --> 00:40:22,709
suffix that were often substantially

00:40:20,640 --> 00:40:24,180
easier to use because you didn't need to

00:40:22,709 --> 00:40:27,089
have the type name when you used them

00:40:24,180 --> 00:40:29,579
and it was just a nicer interface so for

00:40:27,089 --> 00:40:32,880
C++ 17 we're adding something similar

00:40:29,579 --> 00:40:34,709
for type traits that return the value

00:40:32,880 --> 00:40:37,279
where we're using a variable template

00:40:34,709 --> 00:40:39,839
with corresponding underscore V name

00:40:37,279 --> 00:40:41,849
it's not clear that these are is useful

00:40:39,839 --> 00:40:45,449
but when I implemented my own version

00:40:41,849 --> 00:40:47,279
but tab traits library I found that code

00:40:45,449 --> 00:40:48,449
working with the V's especially as I

00:40:47,279 --> 00:40:52,109
made the visa actually my primary

00:40:48,449 --> 00:40:54,569
definition and the separate an alias to

00:40:52,109 --> 00:40:56,190
almost to the trait just turned out to

00:40:54,569 --> 00:40:58,650
be much cleaner in use because I'm not

00:40:56,190 --> 00:41:01,079
jumping between type based

00:40:58,650 --> 00:41:03,119
representations of values and actual

00:41:01,079 --> 00:41:06,630
values in the language so code just

00:41:03,119 --> 00:41:08,579
somehow read more cleanly but it's not

00:41:06,630 --> 00:41:10,920
so clear it's as big again but it is a

00:41:08,579 --> 00:41:13,769
nice consistency to have throughout the

00:41:10,920 --> 00:41:17,660
system alright wise bull constant is our

00:41:13,769 --> 00:41:20,130
new alias for integer constant of bull

00:41:17,660 --> 00:41:22,199
again I was not very excited when this

00:41:20,130 --> 00:41:23,759
came in I started writing code using it

00:41:22,199 --> 00:41:26,039
and it just looked so much neater and

00:41:23,759 --> 00:41:28,739
cleaner and this is a lot of what we're

00:41:26,039 --> 00:41:31,170
getting from 17 code written

00:41:28,739 --> 00:41:34,049
idiomatically I just feel simpler and

00:41:31,170 --> 00:41:36,029
cleaner when I was talking about the

00:41:34,049 --> 00:41:38,640
fold expressions earlier remember I said

00:41:36,029 --> 00:41:40,709
that even though we got short-circuit

00:41:38,640 --> 00:41:43,199
evaluation on the expressions you've got

00:41:40,709 --> 00:41:44,699
to instantiate the whole fold before you

00:41:43,199 --> 00:41:46,829
can do that evaluation and that might

00:41:44,699 --> 00:41:48,749
fail to compile we've got the

00:41:46,829 --> 00:41:51,509
conjunction disjunction and negation

00:41:48,749 --> 00:41:52,979
type traits that are effectively doing a

00:41:51,509 --> 00:41:56,099
similar kind of thing of you know

00:41:52,979 --> 00:41:58,440
conjunctions and disjunctions or wars

00:41:56,099 --> 00:42:01,289
and the gating is just probably negation

00:41:58,440 --> 00:42:03,410
as a very attic pack expansion but these

00:42:01,289 --> 00:42:06,140
are written in such a way that we have a

00:42:03,410 --> 00:42:09,509
lazy evaluation of the template

00:42:06,140 --> 00:42:11,190
expansion so if if I can compute the

00:42:09,509 --> 00:42:13,229
result and determine this what we know

00:42:11,190 --> 00:42:14,550
within the and or an or after expanding

00:42:13,229 --> 00:42:16,680
the first two or three

00:42:14,550 --> 00:42:19,200
that I've got the result I no longer

00:42:16,680 --> 00:42:21,480
need to expand the whole parameter pack

00:42:19,200 --> 00:42:24,660
in case any of those expressions might

00:42:21,480 --> 00:42:27,540
in turn fail to instantiate so this is a

00:42:24,660 --> 00:42:31,200
safer way in generic code potentially of

00:42:27,540 --> 00:42:33,000
working with the same kind of ideas but

00:42:31,200 --> 00:42:34,530
it's also going down your template

00:42:33,000 --> 00:42:36,750
recursion depth and the way a fold

00:42:34,530 --> 00:42:40,920
expression might not so different

00:42:36,750 --> 00:42:44,190
trade-offs one of the embarrassing

00:42:40,920 --> 00:42:45,900
things in the C++ 14 library is we've

00:42:44,190 --> 00:42:47,450
got all these type traits that all these

00:42:45,900 --> 00:42:50,640
sorry functions in the standard library

00:42:47,450 --> 00:42:52,980
that have no except operators that would

00:42:50,640 --> 00:42:56,340
be importantly querying is your swap

00:42:52,980 --> 00:42:57,780
operations no except this was not at all

00:42:56,340 --> 00:42:59,640
a problem for the standard library to

00:42:57,780 --> 00:43:01,710
implement any men that we wanted your

00:42:59,640 --> 00:43:02,880
swap Robbery you and your swap functions

00:43:01,710 --> 00:43:04,470
to be able to decorate your swap

00:43:02,880 --> 00:43:06,690
functions and accordingly

00:43:04,470 --> 00:43:09,750
but the kids were relying on your doing

00:43:06,690 --> 00:43:12,690
in the ADL look upon your swap you can't

00:43:09,750 --> 00:43:14,190
do any IDL look up in a no accept

00:43:12,690 --> 00:43:16,650
operation because there's no name

00:43:14,190 --> 00:43:18,930
looking there's no way to get the using

00:43:16,650 --> 00:43:21,420
STD namespace STD in there in the first

00:43:18,930 --> 00:43:23,280
place now the standard libraries written

00:43:21,420 --> 00:43:26,280
in namespace STD it never saw the

00:43:23,280 --> 00:43:27,690
problem so it turns out it's actually

00:43:26,280 --> 00:43:29,790
really important to be able to have a

00:43:27,690 --> 00:43:32,100
query not so much Lee is swappable trait

00:43:29,790 --> 00:43:34,290
which is handy but it is no throw

00:43:32,100 --> 00:43:36,630
swappable is something that users could

00:43:34,290 --> 00:43:38,670
not write to put in there except there

00:43:36,630 --> 00:43:40,650
no except specifications on their

00:43:38,670 --> 00:43:43,710
functions so we finally added those to

00:43:40,650 --> 00:43:46,830
the standard library and it's callable

00:43:43,710 --> 00:43:48,810
is our missing invoke related trait

00:43:46,830 --> 00:43:51,120
invoke is this funky language we have in

00:43:48,810 --> 00:43:54,300
the standard when we're trying to invoke

00:43:51,120 --> 00:43:56,610
or call an arbitrary function like thing

00:43:54,300 --> 00:43:58,410
so it could be a function it could be a

00:43:56,610 --> 00:44:00,330
functor it could be appointed to member

00:43:58,410 --> 00:44:01,770
function it could be a reference to one

00:44:00,330 --> 00:44:04,760
of these things there's a whole variety

00:44:01,770 --> 00:44:07,380
of these things but if I can pass a

00:44:04,760 --> 00:44:08,940
comma-separated list of things between

00:44:07,380 --> 00:44:11,160
the pair of parens and it's going to go

00:44:08,940 --> 00:44:13,100
off and invoke and call some code this

00:44:11,160 --> 00:44:17,010
is the set of rules to follow

00:44:13,100 --> 00:44:18,690
so we're exposing that says a function

00:44:17,010 --> 00:44:20,130
that follows that set of rules that they

00:44:18,690 --> 00:44:22,800
say it's more general than just calling

00:44:20,130 --> 00:44:24,330
the function operator because it handles

00:44:22,800 --> 00:44:27,150
pointer to member functions and so forth

00:44:24,330 --> 00:44:28,349
for you as he is callable function it

00:44:27,150 --> 00:44:31,319
has unique

00:44:28,349 --> 00:44:34,470
yet representations I missed the s for a

00:44:31,319 --> 00:44:37,170
long time simply says that all the bits

00:44:34,470 --> 00:44:39,410
used in this object representation are

00:44:37,170 --> 00:44:41,700
part of the value there's no padding bit

00:44:39,410 --> 00:44:45,210
which means if I have something that has

00:44:41,700 --> 00:44:47,970
this trait I can therefore use things

00:44:45,210 --> 00:44:49,650
like mem camp in order to test if two

00:44:47,970 --> 00:44:51,239
things have the same value so when

00:44:49,650 --> 00:44:53,519
dealing with a large range of these

00:44:51,239 --> 00:44:57,049
things I can transform to usually much

00:44:53,519 --> 00:44:58,890
more optimized low level algorithms and

00:44:57,049 --> 00:45:02,970
finally we've got a new transformation

00:44:58,890 --> 00:45:08,549
trait alias called void T this is a very

00:45:02,970 --> 00:45:10,079
handy trick built around this for doing

00:45:08,549 --> 00:45:12,269
compile time introspection to say you

00:45:10,079 --> 00:45:13,920
know do you have this particular member

00:45:12,269 --> 00:45:16,049
and therefore create this thing I

00:45:13,920 --> 00:45:17,670
constraint around that so if what I'm

00:45:16,049 --> 00:45:19,680
saying there make sense to you go off

00:45:17,670 --> 00:45:21,299
and look this up it's fantastic and if

00:45:19,680 --> 00:45:24,329
what I'm saying makes no sense then you

00:45:21,299 --> 00:45:26,789
do not need this it's a good corner that

00:45:24,329 --> 00:45:29,519
solves a really awkward syntax problem

00:45:26,789 --> 00:45:32,369
in the library or in libraries in

00:45:29,519 --> 00:45:34,469
general I'm assuming everyone in the

00:45:32,369 --> 00:45:36,420
room knows what I mean when I say spin I

00:45:34,469 --> 00:45:37,499
if you don't I'm sorry these like last

00:45:36,420 --> 00:45:41,729
few slides probably not going to make a

00:45:37,499 --> 00:45:44,579
lot of sense but we had a problem in C++

00:45:41,729 --> 00:45:46,950
14 that's vinay or people use the result

00:45:44,579 --> 00:45:48,329
of type trait it would drag them

00:45:46,950 --> 00:45:49,920
dropping into a context where we would

00:45:48,329 --> 00:45:51,359
really need it to say well if I don't

00:45:49,920 --> 00:45:53,180
have that overloaded I want to go and

00:45:51,359 --> 00:45:56,009
pick another one it had to drop out of

00:45:53,180 --> 00:45:57,779
resolution correspondingly but there was

00:45:56,009 --> 00:46:00,089
no primary definition of the result of

00:45:57,779 --> 00:46:02,759
type trades so code would fail to

00:46:00,089 --> 00:46:03,210
compile as a heart failure in the wrong

00:46:02,759 --> 00:46:05,489
places

00:46:03,210 --> 00:46:09,450
so we require the result of trait to be

00:46:05,489 --> 00:46:11,119
an empty class if it's a if it's not

00:46:09,450 --> 00:46:13,319
going to be defined appropriately a

00:46:11,119 --> 00:46:15,390
primary we basically give a primary

00:46:13,319 --> 00:46:16,289
definition to the primary template and

00:46:15,390 --> 00:46:18,630
we've done the same thing now for

00:46:16,289 --> 00:46:22,589
iterative traits in common type so these

00:46:18,630 --> 00:46:23,969
can also be used safely in code that

00:46:22,589 --> 00:46:29,609
would be wanting to query these things

00:46:23,969 --> 00:46:31,170
in swing I like context smart pointers

00:46:29,609 --> 00:46:35,039
because we all love to keep working on

00:46:31,170 --> 00:46:37,229
our smart pointers there were some holes

00:46:35,039 --> 00:46:39,539
found in the kind of conversions that

00:46:37,229 --> 00:46:41,349
you would do with a unique pointer to an

00:46:39,539 --> 00:46:42,910
array

00:46:41,349 --> 00:46:44,380
that might end up being you know losing

00:46:42,910 --> 00:46:46,059
the fact it was a unique pointer to an

00:46:44,380 --> 00:46:47,680
array and calling the wrong the weeks

00:46:46,059 --> 00:46:49,660
and so forth

00:46:47,680 --> 00:46:51,579
you had to jump through some hoops to

00:46:49,660 --> 00:46:54,759
get into those holes but we found those

00:46:51,579 --> 00:46:58,210
holes and we closed them shared pointer

00:46:54,759 --> 00:47:02,619
of array of unknown band was supposed to

00:46:58,210 --> 00:47:05,319
be added to the CD along with which is a

00:47:02,619 --> 00:47:08,950
shared pointer analog of the unique

00:47:05,319 --> 00:47:11,079
pointer functionality this was imported

00:47:08,950 --> 00:47:12,700
from the library fundamentals TS and by

00:47:11,079 --> 00:47:14,229
the time we were doing that it turns out

00:47:12,700 --> 00:47:16,720
we'd also rate already made quite a

00:47:14,229 --> 00:47:18,940
bunch of changes to shared pointer so

00:47:16,720 --> 00:47:20,829
the project editor didn't have an easy

00:47:18,940 --> 00:47:22,569
way to do the merge and then we've

00:47:20,829 --> 00:47:25,239
accidentally forgot about that

00:47:22,569 --> 00:47:28,720
so that is intended to be landed in the

00:47:25,239 --> 00:47:30,279
c++ 17 that we publish next year but

00:47:28,720 --> 00:47:33,339
it's not in the current document that

00:47:30,279 --> 00:47:37,119
went out of a ballot standard own or

00:47:33,339 --> 00:47:39,249
less with a funky diamond c++ 14 we have

00:47:37,119 --> 00:47:42,609
all these diamonds functors that's a

00:47:39,249 --> 00:47:46,200
cute way of having the function call

00:47:42,609 --> 00:47:48,489
operator of that class template be a

00:47:46,200 --> 00:47:50,170
deducing thing more like a polymorphic

00:47:48,489 --> 00:47:51,609
lambda where all the DC arguments of

00:47:50,170 --> 00:47:55,029
both types and then apply the operator

00:47:51,609 --> 00:47:56,890
accordingly so we found another standard

00:47:55,029 --> 00:47:59,410
library functor that didn't have this

00:47:56,890 --> 00:48:00,989
particular tweak will be added in c++ 14

00:47:59,410 --> 00:48:03,190
we've done it there

00:48:00,989 --> 00:48:04,690
Rhian abling heared from this is

00:48:03,190 --> 00:48:07,329
something i would really not like to

00:48:04,690 --> 00:48:09,460
talk about because this is just evil and

00:48:07,329 --> 00:48:11,140
should never happen anyway but if you're

00:48:09,460 --> 00:48:12,969
in that crazy round where you want to

00:48:11,140 --> 00:48:15,219
have multiple shared pointer owner

00:48:12,969 --> 00:48:17,410
groups so I've got a shared pointer over

00:48:15,219 --> 00:48:19,960
here that thinks it owns pointer X and a

00:48:17,410 --> 00:48:22,749
shared pointer Y over here that thinks

00:48:19,960 --> 00:48:24,279
it owns pointer X but they have

00:48:22,749 --> 00:48:25,719
different control blocks because they've

00:48:24,279 --> 00:48:27,849
got different de litres that are going

00:48:25,719 --> 00:48:29,499
to do different things typically one of

00:48:27,849 --> 00:48:30,700
them is going to delete and destroy X

00:48:29,499 --> 00:48:32,079
whereas one might just be calling a

00:48:30,700 --> 00:48:35,259
function with it that's going to assume

00:48:32,079 --> 00:48:38,650
it lives beyond that so a don't be doing

00:48:35,259 --> 00:48:40,630
this but if you did that and the x you

00:48:38,650 --> 00:48:42,999
were using use the shared from this

00:48:40,630 --> 00:48:45,160
mechanism you quickly fell into

00:48:42,999 --> 00:48:47,140
undefined behavior so we've defined how

00:48:45,160 --> 00:48:49,479
these shared from this is rebind when

00:48:47,140 --> 00:48:50,859
you construct these objects and found

00:48:49,479 --> 00:48:52,690
the corners of undefined behavior and

00:48:50,859 --> 00:48:54,190
ruled it out so this crazy thing you

00:48:52,690 --> 00:48:55,870
shouldn't be doing

00:48:54,190 --> 00:48:57,550
is mildly less scary because we've

00:48:55,870 --> 00:49:01,480
defined what it does and I'm not sure

00:48:57,550 --> 00:49:03,010
that was a good thing but yeah it when

00:49:01,480 --> 00:49:04,570
you start going in poking in dark

00:49:03,010 --> 00:49:06,010
corners of the standard library is

00:49:04,570 --> 00:49:07,480
surprising somebody's already been there

00:49:06,010 --> 00:49:09,910
and cleaned them out for you in advance

00:49:07,480 --> 00:49:12,040
and finally shared point a weak type

00:49:09,910 --> 00:49:13,930
just so we can get the the weak pointer

00:49:12,040 --> 00:49:15,310
analog of the current shared pointer I'm

00:49:13,930 --> 00:49:17,470
looking at if I don't actually have

00:49:15,310 --> 00:49:21,400
immediate access to the the type

00:49:17,470 --> 00:49:23,820
parameters allocators in C++ seventeen

00:49:21,400 --> 00:49:26,680
that's subject near and dear to my heart

00:49:23,820 --> 00:49:30,040
we've got a new trait to simplify our

00:49:26,680 --> 00:49:32,200
use of we can specify a lot of the

00:49:30,040 --> 00:49:35,410
accepted specifications dealing with

00:49:32,200 --> 00:49:38,380
alligators so standard alligator it's a

00:49:35,410 --> 00:49:40,420
stateless alligator so any two

00:49:38,380 --> 00:49:41,920
alligators of this type are always going

00:49:40,420 --> 00:49:44,230
to compare equal they can always enter

00:49:41,920 --> 00:49:46,030
interchange memory but there's a lot of

00:49:44,230 --> 00:49:49,390
code that is required to query that at

00:49:46,030 --> 00:49:53,290
runtime in order to figure out if I can

00:49:49,390 --> 00:49:55,750
swap or so forth which meant that lots

00:49:53,290 --> 00:49:57,460
of code that should have good clear

00:49:55,750 --> 00:50:00,310
exception specifications that say I know

00:49:57,460 --> 00:50:01,660
this thing can't throw couldn't do so

00:50:00,310 --> 00:50:04,570
because it couldn't heck which is a

00:50:01,660 --> 00:50:06,520
compile-time property so we now have the

00:50:04,570 --> 00:50:08,650
is always equal trait that defaults to

00:50:06,520 --> 00:50:11,110
I've got an empty type it's a state a

00:50:08,650 --> 00:50:12,700
stateless alligator probably is always

00:50:11,110 --> 00:50:14,770
going to compare equal to it to other

00:50:12,700 --> 00:50:17,470
alkyds of that same type and that lets

00:50:14,770 --> 00:50:18,970
us give much better exception safety

00:50:17,470 --> 00:50:20,470
guarantees and especially exception

00:50:18,970 --> 00:50:24,550
specifications throughout the standard

00:50:20,470 --> 00:50:26,410
library the other thing we've done is

00:50:24,550 --> 00:50:28,960
we've incorporated the polymorphic

00:50:26,410 --> 00:50:34,090
memory resources from the library

00:50:28,960 --> 00:50:35,560
fundamentals TS room which i've got even

00:50:34,090 --> 00:50:36,400
more detail on the next slide so I'm

00:50:35,560 --> 00:50:39,490
probably just going to jump straight

00:50:36,400 --> 00:50:42,760
through behind there is standard PMR

00:50:39,490 --> 00:50:44,500
memory resource is an abstract class

00:50:42,760 --> 00:50:46,900
it's not fast template it's a straight

00:50:44,500 --> 00:50:48,880
class that won't get when you implement

00:50:46,900 --> 00:50:51,850
the derived classes they just give you

00:50:48,880 --> 00:50:53,800
memory of appropriate sizes so we're

00:50:51,850 --> 00:50:56,110
taking the type out of the allocation

00:50:53,800 --> 00:50:57,730
framework and by making it a base class

00:50:56,110 --> 00:50:59,860
that does the allocation through virtual

00:50:57,730 --> 00:51:01,780
functions you can now pick your

00:50:59,860 --> 00:51:05,440
allocation strategy essentially at

00:51:01,780 --> 00:51:07,599
runtime so we provide a few standard

00:51:05,440 --> 00:51:09,309
resources so there's a diff

00:51:07,599 --> 00:51:10,630
memory resource because the memory

00:51:09,309 --> 00:51:13,690
resource you will use unless you request

00:51:10,630 --> 00:51:15,339
a specific ones through this API the new

00:51:13,690 --> 00:51:16,390
delete resource which just delegates

00:51:15,339 --> 00:51:18,249
everything down to operate a new

00:51:16,390 --> 00:51:20,079
operator delete which is the default

00:51:18,249 --> 00:51:22,390
behavior for the default resource and

00:51:20,079 --> 00:51:24,279
the handy the ever handy null memory

00:51:22,390 --> 00:51:26,910
resource that always throws whenever you

00:51:24,279 --> 00:51:29,140
try to allocate it could never allocate

00:51:26,910 --> 00:51:31,049
which is a hand you want to have the end

00:51:29,140 --> 00:51:33,819
of a chain of our resource adapters

00:51:31,049 --> 00:51:36,279
adapting different strategies and again

00:51:33,819 --> 00:51:39,160
we put three actual useful strategies in

00:51:36,279 --> 00:51:41,200
there the monotonic mapper resource is a

00:51:39,160 --> 00:51:42,940
resource that basically you give it a

00:51:41,200 --> 00:51:44,979
buffer and it will just allocate memory

00:51:42,940 --> 00:51:47,259
from it as it goes it never reclaims the

00:51:44,979 --> 00:51:49,479
memory the the delete function just says

00:51:47,259 --> 00:51:51,430
yeah thanks thanks for sharing and then

00:51:49,479 --> 00:51:53,559
if you exhaust that buffer it will

00:51:51,430 --> 00:51:56,410
dynamically allocate through an app as

00:51:53,559 --> 00:51:58,450
additional allocating allocate resource

00:51:56,410 --> 00:52:01,299
you supply when you construct it or the

00:51:58,450 --> 00:52:02,799
default if you don't a buffer twice the

00:52:01,299 --> 00:52:05,650
length and then continue allocating

00:52:02,799 --> 00:52:06,999
through there simple strategy very handy

00:52:05,650 --> 00:52:09,460
for try to say I want a small buffer on

00:52:06,999 --> 00:52:10,989
the stack so I'll create a small stack

00:52:09,460 --> 00:52:12,369
object there allocate out of that and

00:52:10,989 --> 00:52:15,190
hopefully never need to go out to the

00:52:12,369 --> 00:52:17,829
heap for memory the synchronizing

00:52:15,190 --> 00:52:19,269
unsynchronized pool resources are more

00:52:17,829 --> 00:52:21,700
familiar strategy where we're going to

00:52:19,269 --> 00:52:23,710
bucket things based upon the size of the

00:52:21,700 --> 00:52:25,839
allocation when I have the allocation

00:52:23,710 --> 00:52:27,160
back I'm going to keep that in my bucket

00:52:25,839 --> 00:52:29,769
and therefore I've got a free list of

00:52:27,160 --> 00:52:32,369
allocations of the appropriate size but

00:52:29,769 --> 00:52:35,109
this does mean because I've got separate

00:52:32,369 --> 00:52:36,969
pools now with different resources I can

00:52:35,109 --> 00:52:40,089
have more localized pools for different

00:52:36,969 --> 00:52:43,089
memory subsystems within my overall

00:52:40,089 --> 00:52:46,650
system and that has a surprisingly good

00:52:43,089 --> 00:52:46,650
effect on cache locality of these days

00:52:46,710 --> 00:52:50,529
then we have the resource of web memory

00:52:49,390 --> 00:52:52,869
resource working aware of those

00:52:50,529 --> 00:52:55,869
containers so p.m. are polymorphic

00:52:52,869 --> 00:52:57,549
allocator of T is the allocator that

00:52:55,869 --> 00:53:01,930
works with allocated traits that wraps

00:52:57,549 --> 00:53:05,019
all those memory resources then within

00:53:01,930 --> 00:53:07,450
each container header we have a new

00:53:05,019 --> 00:53:09,069
container alias that it simply now is

00:53:07,450 --> 00:53:10,749
for the existing container using the

00:53:09,069 --> 00:53:15,839
polymorphic allocator rather than

00:53:10,749 --> 00:53:18,460
standard allocator so SDM our containers

00:53:15,839 --> 00:53:20,739
allows the versions that can use these

00:53:18,460 --> 00:53:21,450
type of racing alligators quite quite

00:53:20,739 --> 00:53:25,530
efficiently

00:53:21,450 --> 00:53:26,220
throughout the system other changes for

00:53:25,530 --> 00:53:28,950
containers

00:53:26,220 --> 00:53:31,440
we've got non data member sorry non

00:53:28,950 --> 00:53:33,089
never functions versions of data empty

00:53:31,440 --> 00:53:34,800
and size that they're coming across a

00:53:33,089 --> 00:53:36,960
few of the containers where are my on

00:53:34,800 --> 00:53:38,070
slides I have five minutes to do seven

00:53:36,960 --> 00:53:40,230
slides I'm going to have to really

00:53:38,070 --> 00:53:42,329
accelerate that so game

00:53:40,230 --> 00:53:45,359
we have minimal incomplete type support

00:53:42,329 --> 00:53:46,800
for for word list list and vector which

00:53:45,359 --> 00:53:49,170
basically means up with a recursive data

00:53:46,800 --> 00:53:51,570
structure like a struct X it's got a

00:53:49,170 --> 00:53:55,920
data member that's a list of X while I'm

00:53:51,570 --> 00:53:57,720
passing X X is an incomplete type so if

00:53:55,920 --> 00:53:59,460
I've got a list of X I've got a list of

00:53:57,720 --> 00:54:02,130
an incomplete type but as long as those

00:53:59,460 --> 00:54:03,660
operations when I call them or

00:54:02,130 --> 00:54:07,380
instantiate them see a complete type

00:54:03,660 --> 00:54:08,730
we're going to be good and it turns out

00:54:07,380 --> 00:54:10,020
all the existing implementations of

00:54:08,730 --> 00:54:12,140
standard libraries could support this

00:54:10,020 --> 00:54:14,040
guarantee for those three containers

00:54:12,140 --> 00:54:15,690
when you start getting into the more

00:54:14,040 --> 00:54:17,339
node based containers not all of them

00:54:15,690 --> 00:54:18,720
could give that guarantee today so we

00:54:17,339 --> 00:54:22,800
didn't want to go further than we knew

00:54:18,720 --> 00:54:24,329
we could guarantee another minor change

00:54:22,800 --> 00:54:26,420
the sequence containers have in place

00:54:24,329 --> 00:54:28,290
front init and place back containers

00:54:26,420 --> 00:54:31,260
functions they're great I've just

00:54:28,290 --> 00:54:33,599
constructed something where'd it go so

00:54:31,260 --> 00:54:36,839
they return rather than void like they

00:54:33,599 --> 00:54:38,700
used to return in C++ 14 and C++ 17 they

00:54:36,839 --> 00:54:39,990
will directly return a reference to the

00:54:38,700 --> 00:54:41,280
thing they've just constructed because

00:54:39,990 --> 00:54:43,280
they have that reference handing out

00:54:41,280 --> 00:54:46,800
standing around anyway

00:54:43,280 --> 00:54:47,940
for associative containers ah ignore the

00:54:46,800 --> 00:54:52,880
last bullet because it's on the next

00:54:47,940 --> 00:54:56,910
slide so we've now got the default order

00:54:52,880 --> 00:54:59,099
quite lookup type trait the epitome says

00:54:56,910 --> 00:55:02,640
this is the way I want you to order my

00:54:59,099 --> 00:55:04,500
type by default and we can drop that in

00:55:02,640 --> 00:55:06,359
where the default is call standard less

00:55:04,500 --> 00:55:08,880
which we'll call the operator less than

00:55:06,359 --> 00:55:11,250
so by dropping this in we've got a

00:55:08,880 --> 00:55:12,960
customization point so that if I want to

00:55:11,250 --> 00:55:14,760
customize my type say I've got a complex

00:55:12,960 --> 00:55:17,130
number type I do not want to define the

00:55:14,760 --> 00:55:19,339
less than operator for this type nor do

00:55:17,130 --> 00:55:21,630
I want to abuse the standard less

00:55:19,339 --> 00:55:23,099
functor that is supposed to be the

00:55:21,630 --> 00:55:25,290
function like an analogue of calling

00:55:23,099 --> 00:55:28,260
operator less but I do want to be able

00:55:25,290 --> 00:55:29,730
to store my type in sets and skeezer

00:55:28,260 --> 00:55:31,530
maps because I can define an arbitrary

00:55:29,730 --> 00:55:34,079
ordering that's good for my type it's

00:55:31,530 --> 00:55:36,179
not the mathematical ordering

00:55:34,079 --> 00:55:38,579
default order gives us a customisation

00:55:36,179 --> 00:55:40,949
that will do that while being 100% a bi

00:55:38,579 --> 00:55:42,839
compatible with existing code because

00:55:40,949 --> 00:55:45,119
it's a lookup through a typed rate for a

00:55:42,839 --> 00:55:46,589
default template parameter it produces

00:55:45,119 --> 00:55:50,789
exactly the same tack for all the

00:55:46,589 --> 00:55:52,949
existing code when it comes to trying to

00:55:50,789 --> 00:55:55,049
insert things into unique key maps or

00:55:52,949 --> 00:55:56,969
unordered Maps we've got the problem

00:55:55,049 --> 00:55:59,069
that if the things already there the

00:55:56,969 --> 00:56:00,029
inserts going to fail and how do we deal

00:55:59,069 --> 00:56:02,819
with that there's different

00:56:00,029 --> 00:56:04,649
optimizations you can do container side

00:56:02,819 --> 00:56:07,289
to make these current you know try and

00:56:04,649 --> 00:56:09,719
try them place this or insert or if it's

00:56:07,289 --> 00:56:10,979
already there assigned to it much more

00:56:09,719 --> 00:56:12,599
efficient than trying to live in purely

00:56:10,979 --> 00:56:16,679
outside the container so we've added

00:56:12,599 --> 00:56:19,469
those methods funky thing about splicing

00:56:16,679 --> 00:56:21,689
is extracting a node from a container so

00:56:19,469 --> 00:56:23,699
the other is I'm going to I've got a

00:56:21,689 --> 00:56:25,409
node that's been allocated by my

00:56:23,699 --> 00:56:27,029
container that holds whatever element I

00:56:25,409 --> 00:56:29,489
can extract that node out of the

00:56:27,029 --> 00:56:30,839
container then either splice it into a

00:56:29,489 --> 00:56:32,279
different container because it will just

00:56:30,839 --> 00:56:34,319
sort correctly without having to do

00:56:32,279 --> 00:56:36,839
another allocation or I can perhaps

00:56:34,319 --> 00:56:38,519
fiddle with the key which is where I was

00:56:36,839 --> 00:56:39,989
talking about standard launder earlier

00:56:38,519 --> 00:56:41,459
you occasionally hit these strange

00:56:39,989 --> 00:56:43,139
corners where you want to do funky

00:56:41,459 --> 00:56:45,029
things just outside the strict rules of

00:56:43,139 --> 00:56:46,739
the type system case your family on the

00:56:45,029 --> 00:56:48,869
key and then try and insert it back into

00:56:46,739 --> 00:56:50,579
the same container okay I don't want to

00:56:48,869 --> 00:56:53,669
allocating it will now go just to the

00:56:50,579 --> 00:56:56,249
right place one of the problems it does

00:56:53,669 --> 00:57:00,179
solve is that with a set of unique

00:56:56,249 --> 00:57:01,169
pointers in C++ 11 and onwards we've

00:57:00,179 --> 00:57:04,380
never been able to actually take

00:57:01,169 --> 00:57:05,969
elements back out of the set I mean I

00:57:04,380 --> 00:57:09,539
can erase the element that's in the set

00:57:05,969 --> 00:57:11,189
but I've not be able to move the unique

00:57:09,539 --> 00:57:13,319
pointer out because I only ever had

00:57:11,189 --> 00:57:15,419
access to a constitute or effectively or

00:57:13,319 --> 00:57:17,459
alliterated with constant access so

00:57:15,419 --> 00:57:22,079
that's another thing that this extract

00:57:17,459 --> 00:57:25,499
interface will letters do finally we've

00:57:22,079 --> 00:57:26,729
got these funky a bit too small to read

00:57:25,499 --> 00:57:29,669
on the slide hopefully you'll be able to

00:57:26,729 --> 00:57:31,679
see them more clearly when the slides

00:57:29,669 --> 00:57:34,380
are published a bunch of algorithms for

00:57:31,679 --> 00:57:36,689
working over an initialized memory to do

00:57:34,380 --> 00:57:40,109
a construct in place or destroy in place

00:57:36,689 --> 00:57:42,239
or a move in place when we have a small

00:57:40,109 --> 00:57:44,929
subset of uninitialized algorithms that

00:57:42,239 --> 00:57:47,099
have been sitting there since C++ 98

00:57:44,929 --> 00:57:49,170
there was a real desire from the

00:57:47,099 --> 00:57:51,869
on the gaming community and other high

00:57:49,170 --> 00:57:54,479
performance low-level winery managers

00:57:51,869 --> 00:57:56,339
that want them really to enrich its

00:57:54,479 --> 00:57:59,460
facility to encompass all the behavior

00:57:56,339 --> 00:58:04,829
so we that has finally been broadened in

00:57:59,460 --> 00:58:07,789
C++ 17 small library editions invoke a

00:58:04,829 --> 00:58:11,099
callable thing with a bunch of argument

00:58:07,789 --> 00:58:12,390
as const is just a simple it'll give me

00:58:11,099 --> 00:58:14,430
a const reference to the thing

00:58:12,390 --> 00:58:15,779
so all those widely functions like c

00:58:14,430 --> 00:58:17,729
begin CN that we've done all these

00:58:15,779 --> 00:58:20,609
different overloads i could just call as

00:58:17,729 --> 00:58:22,079
const and then begin it's just a more

00:58:20,609 --> 00:58:24,089
general thing rather than having to

00:58:22,079 --> 00:58:26,279
create lots of separate named functions

00:58:24,089 --> 00:58:27,720
all over the place one that just gets us

00:58:26,279 --> 00:58:29,729
to the right place

00:58:27,720 --> 00:58:31,589
clamp is the classic i've got a minimum

00:58:29,729 --> 00:58:35,400
in the maximum and I want my value to be

00:58:31,589 --> 00:58:37,920
bound within that range the generalize

00:58:35,400 --> 00:58:42,539
negator not fun I mentioned earlier I'm

00:58:37,920 --> 00:58:44,130
already 15 seconds over con sexpert is

00:58:42,539 --> 00:58:46,200
more broadly spread throughout the whole

00:58:44,130 --> 00:58:50,660
standard library in the list of places

00:58:46,200 --> 00:58:53,039
there and final library cleanups

00:58:50,660 --> 00:58:54,539
reference wrapper is now guaranteed to

00:58:53,039 --> 00:58:55,950
have a trivial copy constructor and copy

00:58:54,539 --> 00:58:59,309
assignment it doesn't have an assignment

00:58:55,950 --> 00:59:01,880
operator for the chrono types we now

00:58:59,309 --> 00:59:04,559
support abs sealed floor and round and

00:59:01,880 --> 00:59:07,829
finally we're reserving for the future

00:59:04,559 --> 00:59:09,690
all namespaces that start STD followed

00:59:07,829 --> 00:59:12,150
by a sequence of digits we are looking

00:59:09,690 --> 00:59:14,369
probably not for C++ 20 but hopefully

00:59:12,150 --> 00:59:16,049
not much beyond that to have a new

00:59:14,369 --> 00:59:18,440
standard library namespace that we're

00:59:16,049 --> 00:59:20,940
going to want to start populating with a

00:59:18,440 --> 00:59:22,440
more consistent standard library built

00:59:20,940 --> 00:59:24,660
up from the kind of features we've been

00:59:22,440 --> 00:59:26,339
talking about today so you're on notice

00:59:24,660 --> 00:59:30,950
we're reserving those all of those

00:59:26,339 --> 00:59:30,950
namespaces for future use thank you

00:59:33,460 --> 00:59:35,520

YouTube URL: https://www.youtube.com/watch?v=-rIixnNJM4k


