Title: CppCon 2016: Bob Steagall “Lightweight Object Persistence With Relocatable Heaps in Modern C++"
Publication date: 2016-10-01
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Modern C++ brings many exciting and powerful advances to both the core language and the standard C++ library. Among these are changes to the standard allocator requirements that now permit allocators to allocate and deallocate blocks of memory that are addressable by generalized (i.e., non-native) pointers, as well as requirements for allocator-aware containers to employ such pointers. 

This talk will describe a slightly different way of thinking about memory allocation, decomposing the idea into four distinct structural concepts – addressing model, storage model, pointer interface, and allocation strategy. To illustrate this new mental framework, we'll examine the design of a standard-conformant allocator that uses shared memory as its storage model, and show how it can be used to construct data structures based on standard C++ containers directly in shared memory. We'll then explore how this particular allocator's address-independent storage model supports a form of lightweight object persistence (with some constraints). Along the way we'll compare and contrast the old C++03 allocator requirements with those of C++14, and we'll also see at least one way to implement a generalized pointer. Finally, if time permits, we'll touch on other storage models and possible applications. 
— 

Bob Steagall
I've been working in C++ for the last 24 years. The majority of my career has been spent in medical imaging, where I led teams building applications for functional MRI and CT-based cardiac visualization. After a brief journey through the world of DNS, I'm now trying my hand at analytics.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,359
good morning everyone and thank you for

00:00:03,030 --> 00:00:07,710
coming to my talk my name is Bob Stegall

00:00:06,359 --> 00:00:10,590
and they tell me I'm a software

00:00:07,710 --> 00:00:13,679
architect with Finch computing I began

00:00:10,590 --> 00:00:15,509
using C++ in 1992 when I was a young

00:00:13,679 --> 00:00:17,640
research assistant working for the

00:00:15,509 --> 00:00:20,189
department's of physics and radiology at

00:00:17,640 --> 00:00:21,449
university hospitals in Cleveland and I

00:00:20,189 --> 00:00:24,060
can tell you from personal experience

00:00:21,449 --> 00:00:27,269
that the evolution of the language in

00:00:24,060 --> 00:00:29,460
its libraries since then especially over

00:00:27,269 --> 00:00:32,820
the last seven or eight years is truly

00:00:29,460 --> 00:00:35,850
astounding with the rapid uptake of C++

00:00:32,820 --> 00:00:37,739
11 and now 14 it's hard to imagine that

00:00:35,850 --> 00:00:39,960
there ever was a time before our value

00:00:37,739 --> 00:00:42,180
references and lambdas and very attic

00:00:39,960 --> 00:00:45,030
templates and soon concepts and things

00:00:42,180 --> 00:00:47,039
like this as you can see this talk was

00:00:45,030 --> 00:00:50,370
initially entitled lightweight object

00:00:47,039 --> 00:00:52,949
persistence with modern C++ however as

00:00:50,370 --> 00:00:55,230
always happens when I complete something

00:00:52,949 --> 00:00:57,059
for a deadline after the deadline passes

00:00:55,230 --> 00:00:59,219
i begin to obsess over the many ways

00:00:57,059 --> 00:01:01,440
that could have been made better so in

00:00:59,219 --> 00:01:03,270
the interest of improved precision for

00:01:01,440 --> 00:01:05,339
today I've amended the title to be

00:01:03,270 --> 00:01:08,549
lightweight object persistence with

00:01:05,339 --> 00:01:09,630
relocatable heaps in modern C++ I'm not

00:01:08,549 --> 00:01:11,250
sure that it's much of an improvement

00:01:09,630 --> 00:01:14,159
but at least my good intentions are

00:01:11,250 --> 00:01:15,780
captured in the video record now before

00:01:14,159 --> 00:01:18,090
we dig into the content I have a request

00:01:15,780 --> 00:01:19,799
in a couple of notes first there's a

00:01:18,090 --> 00:01:21,600
fair bit of material to get through and

00:01:19,799 --> 00:01:24,030
so I ask that you please hold your

00:01:21,600 --> 00:01:25,320
questions until the end each slide is

00:01:24,030 --> 00:01:28,140
numbered in the lower right hand corner

00:01:25,320 --> 00:01:29,759
so if you have a question please take

00:01:28,140 --> 00:01:33,030
note of that slides number and we'll go

00:01:29,759 --> 00:01:35,159
back to it next like our esteemed 43rd

00:01:33,030 --> 00:01:37,920
president I may make up some words along

00:01:35,159 --> 00:01:41,040
the way hopefully their meaning will be

00:01:37,920 --> 00:01:42,720
clear from the context also i'm going to

00:01:41,040 --> 00:01:45,420
use the word concepts throughout this

00:01:42,720 --> 00:01:47,640
talk and when I do I mean concepts with

00:01:45,420 --> 00:01:51,930
the lowercase C not the new language

00:01:47,640 --> 00:01:54,149
facility I'd like to begin describing

00:01:51,930 --> 00:01:55,710
what this talk is about I submitted the

00:01:54,149 --> 00:01:57,630
abstract for the talk because I wanted

00:01:55,710 --> 00:01:59,040
to share some results of some work that

00:01:57,630 --> 00:02:02,369
I've been doing off and on for the last

00:01:59,040 --> 00:02:04,469
few years so first I'd like to describe

00:02:02,369 --> 00:02:06,240
a way of thinking about allocator design

00:02:04,469 --> 00:02:09,060
that may be helpful when you design your

00:02:06,240 --> 00:02:11,280
allocators I decompose the problem into

00:02:09,060 --> 00:02:13,500
a small number of concepts which could

00:02:11,280 --> 00:02:14,820
be implemented as policy types

00:02:13,500 --> 00:02:16,890
make designing high-performance

00:02:14,820 --> 00:02:19,590
allocators a little easier or at least

00:02:16,890 --> 00:02:22,020
they did for me and for my money this

00:02:19,590 --> 00:02:23,910
decomposition or mental framework if you

00:02:22,020 --> 00:02:27,690
will is the most important thing to take

00:02:23,910 --> 00:02:29,640
away from the talk secondly I'd like to

00:02:27,690 --> 00:02:32,040
outline one solution to the problem of

00:02:29,640 --> 00:02:34,440
object persistence a solution that may

00:02:32,040 --> 00:02:36,240
be useful in certain cases now there's

00:02:34,440 --> 00:02:38,850
no sexy metaprogramming or slick

00:02:36,240 --> 00:02:40,830
concurrency techniques instead just a

00:02:38,850 --> 00:02:43,770
straightforward way of implementing one

00:02:40,830 --> 00:02:45,510
small form of object persistence for

00:02:43,770 --> 00:02:48,540
another solution along the same lines as

00:02:45,510 --> 00:02:50,580
mine and one that is very mature I

00:02:48,540 --> 00:02:54,180
recommend that you look at boost inner

00:02:50,580 --> 00:02:55,500
process now although we're going to

00:02:54,180 --> 00:02:57,750
construct a standard conforming

00:02:55,500 --> 00:02:59,760
allocator along the way this talk is not

00:02:57,750 --> 00:03:01,470
a tutorial on allocators there are

00:02:59,760 --> 00:03:03,330
plenty of books and articles and online

00:03:01,470 --> 00:03:05,670
references that describe the details of

00:03:03,330 --> 00:03:07,590
allocators and how to build them this is

00:03:05,670 --> 00:03:09,900
also not a proposal for how to improve

00:03:07,590 --> 00:03:11,790
the standard allocator facilities there

00:03:09,900 --> 00:03:13,700
have been countless electrons sacrificed

00:03:11,790 --> 00:03:16,590
on this altar over the last few years

00:03:13,700 --> 00:03:18,390
Andre Alexander SQ has been very vocal

00:03:16,590 --> 00:03:20,190
in this area and gave a great talk on

00:03:18,390 --> 00:03:22,049
the topic last year at this very

00:03:20,190 --> 00:03:24,510
conference and I recommend you check it

00:03:22,049 --> 00:03:26,880
out on youtube he's given similar talks

00:03:24,510 --> 00:03:28,410
in the past and parenthetically the only

00:03:26,880 --> 00:03:30,330
quibble I have with Andres point of view

00:03:28,410 --> 00:03:32,610
is that I think he doesn't go quite far

00:03:30,330 --> 00:03:35,670
enough I hope to move that ball a little

00:03:32,610 --> 00:03:37,260
bit further down the field today finally

00:03:35,670 --> 00:03:39,120
this talk will not provide a complete

00:03:37,260 --> 00:03:41,700
off-the-shelf framework for object

00:03:39,120 --> 00:03:43,350
persistence writing allocators and

00:03:41,700 --> 00:03:45,570
implementing object persistence is

00:03:43,350 --> 00:03:47,910
difficult and challenging work and I do

00:03:45,570 --> 00:03:49,709
not have the one true library that will

00:03:47,910 --> 00:03:51,299
solve all of your persistence problems

00:03:49,709 --> 00:03:55,380
you're going to need to figure out the

00:03:51,299 --> 00:03:56,459
best way to do that for yourself so the

00:03:55,380 --> 00:03:58,980
first half of the talk will be a

00:03:56,459 --> 00:04:00,750
discussion of some concepts then I'll

00:03:58,980 --> 00:04:03,090
show some code and finally I'll

00:04:00,750 --> 00:04:06,420
hopefully provide a demo that may or may

00:04:03,090 --> 00:04:08,100
not work so let's provide or let's begin

00:04:06,420 --> 00:04:11,489
in the context of a particular problem

00:04:08,100 --> 00:04:13,680
in my case at my current and previous

00:04:11,489 --> 00:04:15,660
employers critical business operations

00:04:13,680 --> 00:04:17,669
depend on proprietary in-memory

00:04:15,660 --> 00:04:19,799
databases that are written in C++

00:04:17,669 --> 00:04:22,530
although these databases are very

00:04:19,799 --> 00:04:25,349
different in the design and the content

00:04:22,530 --> 00:04:27,210
they hold both databases shared store

00:04:25,349 --> 00:04:29,729
lots of complex data

00:04:27,210 --> 00:04:33,270
with non-trivial relationships among the

00:04:29,729 --> 00:04:36,569
data so if I step back and generalize

00:04:33,270 --> 00:04:39,000
the problem I have a set of types these

00:04:36,569 --> 00:04:40,590
types have container data members the

00:04:39,000 --> 00:04:43,259
elements of those containers may

00:04:40,590 --> 00:04:45,389
themselves also have container container

00:04:43,259 --> 00:04:47,729
data members so I could have a nested

00:04:45,389 --> 00:04:49,910
hierarchy of containment I have a large

00:04:47,729 --> 00:04:52,919
number of these objects in memory

00:04:49,910 --> 00:04:54,660
usually more than 10 gigabytes and quite

00:04:52,919 --> 00:04:57,949
often substantially more than 10

00:04:54,660 --> 00:05:00,060
gigabytes the objects of these types

00:04:57,949 --> 00:05:02,430
typically have time consuming

00:05:00,060 --> 00:05:06,990
construction or copy or traversal

00:05:02,430 --> 00:05:08,759
operations and so naturally I want to be

00:05:06,990 --> 00:05:11,220
able to take this data and save it to

00:05:08,759 --> 00:05:13,349
persistent storage so i can recall it

00:05:11,220 --> 00:05:16,620
later and use it or transmitted across

00:05:13,349 --> 00:05:18,090
the wire so somebody else can use it of

00:05:16,620 --> 00:05:21,030
course the question is how to accomplish

00:05:18,090 --> 00:05:22,880
these feats well it goes without saying

00:05:21,030 --> 00:05:25,650
that we can turn to serialization

00:05:22,880 --> 00:05:27,599
wikipedia has a nice definition the

00:05:25,650 --> 00:05:29,940
process of translating data structures

00:05:27,599 --> 00:05:32,039
or objects stayed into a format that can

00:05:29,940 --> 00:05:34,020
be stored in a file or temporary buffer

00:05:32,039 --> 00:05:36,330
or transmitted across a network

00:05:34,020 --> 00:05:39,229
connection and reconstructed later in

00:05:36,330 --> 00:05:41,669
the same or other computer environment

00:05:39,229 --> 00:05:46,050
in many cases this is a two-step process

00:05:41,669 --> 00:05:48,719
as we all know step one we iterate over

00:05:46,050 --> 00:05:51,300
and serialize the source objects into

00:05:48,719 --> 00:05:53,340
some intermediate format for example

00:05:51,300 --> 00:05:57,960
JSON which all the kids love these days

00:05:53,340 --> 00:06:01,199
or yamo or XML or protocol buffers or a

00:05:57,960 --> 00:06:03,090
proprietary format etc etc now this

00:06:01,199 --> 00:06:04,830
iteration could be recursive it could be

00:06:03,090 --> 00:06:07,440
level order it could be something else

00:06:04,830 --> 00:06:10,620
but whatever it is it has to be

00:06:07,440 --> 00:06:12,539
pre-arranged with or discoverable by the

00:06:10,620 --> 00:06:14,759
entity on the destination side that's

00:06:12,539 --> 00:06:17,340
doing the D serialization now of course

00:06:14,759 --> 00:06:21,990
the obvious purpose of serialization is

00:06:17,340 --> 00:06:24,479
to save important objects state step two

00:06:21,990 --> 00:06:27,360
is to deserialize the intermediate

00:06:24,479 --> 00:06:29,190
format into destination objects and here

00:06:27,360 --> 00:06:32,280
the obvious purpose is to recover

00:06:29,190 --> 00:06:35,190
important objects state if we've done

00:06:32,280 --> 00:06:37,770
this properly the result will be that on

00:06:35,190 --> 00:06:40,950
the destination side each destination

00:06:37,770 --> 00:06:43,260
object will be semantically identical

00:06:40,950 --> 00:06:44,790
to its corresponding source object I'm

00:06:43,260 --> 00:06:46,590
not going to define semantically

00:06:44,790 --> 00:06:50,040
identical but i think we all pretty have

00:06:46,590 --> 00:06:51,810
a pretty good idea what that means now

00:06:50,040 --> 00:06:54,300
when we talk about serialization in this

00:06:51,810 --> 00:06:57,300
context this is what I think of as

00:06:54,300 --> 00:06:59,970
traversal based serialization traversal

00:06:57,300 --> 00:07:02,520
because sequences of objects and object

00:06:59,970 --> 00:07:04,200
contain containment hierarchies must be

00:07:02,520 --> 00:07:08,700
traversed in order to perform the

00:07:04,200 --> 00:07:11,280
serialization of each object so let's

00:07:08,700 --> 00:07:12,990
talk briefly in very general terms about

00:07:11,280 --> 00:07:16,860
the intermediate format because I think

00:07:12,990 --> 00:07:19,620
there are some useful ideas here first

00:07:16,860 --> 00:07:21,540
whether implicitly or explicitly the

00:07:19,620 --> 00:07:24,180
intermediate format describes a schema

00:07:21,540 --> 00:07:25,710
and here I'm using the word schema in a

00:07:24,180 --> 00:07:27,810
very loose sense to mean the

00:07:25,710 --> 00:07:30,600
relationship between an object and other

00:07:27,810 --> 00:07:32,030
objects for purposes of serialization I

00:07:30,600 --> 00:07:35,160
think of two kinds of relationships

00:07:32,030 --> 00:07:36,660
containment and reference and usually

00:07:35,160 --> 00:07:38,820
it's the representation of a reference

00:07:36,660 --> 00:07:42,600
relationship that poses the tough

00:07:38,820 --> 00:07:45,360
problems secondly the intermediate

00:07:42,600 --> 00:07:47,450
format provides or can provide several

00:07:45,360 --> 00:07:50,250
forms of Independence of three varieties

00:07:47,450 --> 00:07:53,190
the first is architectural independence

00:07:50,250 --> 00:07:54,930
in here I think of independence from

00:07:53,190 --> 00:07:57,300
issues of things like byte ordering

00:07:54,930 --> 00:08:00,360
class member layout or address space

00:07:57,300 --> 00:08:02,390
layout and here think of serializing

00:08:00,360 --> 00:08:04,980
objects that exist on an intel-based

00:08:02,390 --> 00:08:07,670
architecture and deserializing them on a

00:08:04,980 --> 00:08:10,080
Power Architecture or SPARC architecture

00:08:07,670 --> 00:08:11,910
the second form of Independence that I

00:08:10,080 --> 00:08:15,000
think of is what I call representational

00:08:11,910 --> 00:08:17,400
independence for example I might have a

00:08:15,000 --> 00:08:19,980
list of vector of char on the source

00:08:17,400 --> 00:08:21,690
side which when deserialized on the

00:08:19,980 --> 00:08:23,610
destination side becomes a list of

00:08:21,690 --> 00:08:25,530
string one could argue that those

00:08:23,610 --> 00:08:28,080
objects are similar enough that that

00:08:25,530 --> 00:08:30,030
we've done the persistence correctly

00:08:28,080 --> 00:08:32,150
this is an example of something I think

00:08:30,030 --> 00:08:34,650
of as being intra language

00:08:32,150 --> 00:08:37,830
representational independence and on the

00:08:34,650 --> 00:08:39,930
other side of that corn coin I might

00:08:37,830 --> 00:08:41,580
have a list of string in Java which

00:08:39,930 --> 00:08:44,550
after wandering through the desert of

00:08:41,580 --> 00:08:46,380
JSON becomes a list of string and C++

00:08:44,550 --> 00:08:48,600
and here I think of this as being

00:08:46,380 --> 00:08:51,300
interlanguage representational

00:08:48,600 --> 00:08:53,080
independence the final concept is that

00:08:51,300 --> 00:08:57,400
of positional independence

00:08:53,080 --> 00:08:59,530
and what I mean by this is that the

00:08:57,400 --> 00:09:01,720
intermediate format can provide

00:08:59,530 --> 00:09:04,870
independence such that when a

00:09:01,720 --> 00:09:07,870
destination object is D serialized in a

00:09:04,870 --> 00:09:09,730
destination process it's important state

00:09:07,870 --> 00:09:12,790
is preserved even if the destination

00:09:09,730 --> 00:09:15,640
object exists at a different address in

00:09:12,790 --> 00:09:17,710
the destination process and this is

00:09:15,640 --> 00:09:22,360
actually sort of the key concept here

00:09:17,710 --> 00:09:24,010
behind the rest of the talk we all know

00:09:22,360 --> 00:09:27,460
from experience that there are costs and

00:09:24,010 --> 00:09:29,260
risks associated with this approach we

00:09:27,460 --> 00:09:31,270
don't yet have standardized mechanisms

00:09:29,260 --> 00:09:34,720
for compile time or runtime reflection

00:09:31,270 --> 00:09:37,680
in C++ so at the end of the day code has

00:09:34,720 --> 00:09:40,180
to be written or generated or both and

00:09:37,680 --> 00:09:42,160
the code has to traverse the source

00:09:40,180 --> 00:09:43,780
objects on the source side and render

00:09:42,160 --> 00:09:46,540
them into some intermediate format and

00:09:43,780 --> 00:09:48,010
on the destination side the code has to

00:09:46,540 --> 00:09:50,260
parse the intermediate format and

00:09:48,010 --> 00:09:52,870
reconstruct the destination objects I

00:09:50,260 --> 00:09:55,120
think most of us know that code like

00:09:52,870 --> 00:09:57,670
this can rapidly become complex and

00:09:55,120 --> 00:09:59,770
fragile there's an engineering costs

00:09:57,670 --> 00:10:02,670
associated with these activities and it

00:09:59,770 --> 00:10:05,260
can be non-trivial in real-world systems

00:10:02,670 --> 00:10:07,720
there's a temporal cost associated with

00:10:05,260 --> 00:10:10,000
traversal based serialization by its

00:10:07,720 --> 00:10:12,100
very definition serialization is linear

00:10:10,000 --> 00:10:14,590
and therefore in general the entire

00:10:12,100 --> 00:10:16,570
stream must be read sequentially which

00:10:14,590 --> 00:10:19,030
typically precludes any sort of parallel

00:10:16,570 --> 00:10:21,490
ISM this can be an expensive proposition

00:10:19,030 --> 00:10:24,630
if your object construction is time

00:10:21,490 --> 00:10:28,060
consuming on the destination side

00:10:24,630 --> 00:10:30,180
likewise there's a spatial cost many

00:10:28,060 --> 00:10:32,920
common intermediate formats are verbose

00:10:30,180 --> 00:10:34,870
XML for example is the poster child of

00:10:32,920 --> 00:10:38,650
excessively verbose data interchange

00:10:34,870 --> 00:10:40,860
formats there are risks associated with

00:10:38,650 --> 00:10:43,360
traversal based serialization our

00:10:40,860 --> 00:10:45,640
intermediate format may allow private

00:10:43,360 --> 00:10:48,040
implement eight implementation details

00:10:45,640 --> 00:10:51,340
to be exposed details that we would like

00:10:48,040 --> 00:10:54,690
to keep private so the risk from this is

00:10:51,340 --> 00:10:57,100
that on the destination side

00:10:54,690 --> 00:10:59,260
encapsulation might be violated when

00:10:57,100 --> 00:11:01,450
destination objects are reconstructed

00:10:59,260 --> 00:11:03,700
and this may in turn break class

00:11:01,450 --> 00:11:06,340
invariance or violate constraints that

00:11:03,700 --> 00:11:06,920
we expect to hold between objects on the

00:11:06,340 --> 00:11:11,089
destination

00:11:06,920 --> 00:11:12,800
side so to sum up everything there is to

00:11:11,089 --> 00:11:15,170
know about traversal based serialization

00:11:12,800 --> 00:11:16,910
in one slide it's as close as we can

00:11:15,170 --> 00:11:18,709
come to a universal technique for

00:11:16,910 --> 00:11:20,839
implementing object persistence if

00:11:18,709 --> 00:11:22,310
you're willing to put in the effort you

00:11:20,839 --> 00:11:24,769
can find a way to make it work for you

00:11:22,310 --> 00:11:26,959
on the other hand it can be expensive to

00:11:24,769 --> 00:11:28,370
implement and maintain and you generally

00:11:26,959 --> 00:11:30,440
have to be very careful to keep your

00:11:28,370 --> 00:11:34,850
code from becoming overly complex or

00:11:30,440 --> 00:11:37,100
stale or fragile so given these

00:11:34,850 --> 00:11:39,139
circumstances is there a way for me to

00:11:37,100 --> 00:11:41,420
avoid all the hard work involved with

00:11:39,139 --> 00:11:43,250
traversal based serialization in other

00:11:41,420 --> 00:11:45,050
words can I pull a Kobayashi Maru and

00:11:43,250 --> 00:11:49,370
change the parameters the problem to

00:11:45,050 --> 00:11:52,070
make my life easier well let's change

00:11:49,370 --> 00:11:53,570
the problem statement suppose that I

00:11:52,070 --> 00:11:56,089
don't need architectural or

00:11:53,570 --> 00:11:58,160
representational independence suppose

00:11:56,089 --> 00:12:00,560
that my source and destination platforms

00:11:58,160 --> 00:12:02,389
are the same or very close suppose that

00:12:00,560 --> 00:12:04,300
I'm positive the class layouts and

00:12:02,389 --> 00:12:06,320
corresponding source and destination

00:12:04,300 --> 00:12:08,750
objects are going to be exactly the same

00:12:06,320 --> 00:12:11,240
and suppose I'm willing to use the same

00:12:08,750 --> 00:12:14,060
object code on either side or code

00:12:11,240 --> 00:12:16,310
that's very close if I make these

00:12:14,060 --> 00:12:17,779
assumptions can I now implement a form

00:12:16,310 --> 00:12:20,930
of object persistence that does not

00:12:17,779 --> 00:12:23,779
require any sort of / type serialization

00:12:20,930 --> 00:12:25,850
or D serialization code that allows me

00:12:23,779 --> 00:12:28,279
to persist standard containers and

00:12:25,850 --> 00:12:30,440
strings and be able to use standard

00:12:28,279 --> 00:12:33,980
algorithms on the on the destination

00:12:30,440 --> 00:12:36,350
objects after D serialization and that

00:12:33,980 --> 00:12:39,019
uses fast binary i/o like write and read

00:12:36,350 --> 00:12:41,329
or send and receive clearly we can do

00:12:39,019 --> 00:12:43,519
some of these things now I can save an

00:12:41,329 --> 00:12:45,410
array of p 0 DS to disk or send it over

00:12:43,519 --> 00:12:46,970
the wire and if I'm careful about what I

00:12:45,410 --> 00:12:48,980
put in it and how I interpret it

00:12:46,970 --> 00:12:50,569
everything will work just fine but I

00:12:48,980 --> 00:12:55,490
want to work at a slightly higher level

00:12:50,569 --> 00:12:57,829
than plain old data structures so here's

00:12:55,490 --> 00:13:00,050
an idea how about a relocatable heap I

00:12:57,829 --> 00:13:02,839
usually think of the heap as being a

00:13:00,050 --> 00:13:04,250
magic black box I ask it for some memory

00:13:02,839 --> 00:13:06,260
and if the planets are aligned and the

00:13:04,250 --> 00:13:07,940
gods are willing a small window into

00:13:06,260 --> 00:13:10,250
that box opens revealing a chunk of

00:13:07,940 --> 00:13:11,779
memory that I can use for a while when

00:13:10,250 --> 00:13:14,600
i'm done with that memory i hand it back

00:13:11,779 --> 00:13:16,100
to the box and the window closes well

00:13:14,600 --> 00:13:18,319
would it be cool if i could pick up that

00:13:16,100 --> 00:13:20,250
black box and save it to disk so i can

00:13:18,319 --> 00:13:22,020
restore it later or

00:13:20,250 --> 00:13:24,450
share it with another process or send it

00:13:22,020 --> 00:13:25,770
across the wire to somebody else in

00:13:24,450 --> 00:13:30,360
other words wouldn't be cool if I could

00:13:25,770 --> 00:13:32,720
relocate the heap so by Fiat I'm going

00:13:30,360 --> 00:13:35,400
to declare that a heap is relocatable if

00:13:32,720 --> 00:13:39,000
it can be serialized and deserialized

00:13:35,400 --> 00:13:41,280
with simple binary i/o and after D

00:13:39,000 --> 00:13:43,500
serialization at a different address in

00:13:41,280 --> 00:13:45,960
the destination process on the

00:13:43,500 --> 00:13:48,930
destination machine the heap itself

00:13:45,960 --> 00:13:50,550
continues to function correctly and the

00:13:48,930 --> 00:13:52,800
heaps contents continue to function

00:13:50,550 --> 00:13:55,470
correctly in other words after

00:13:52,800 --> 00:13:57,330
relocation all class and variants are

00:13:55,470 --> 00:14:00,420
preserved for the heap and all the

00:13:57,330 --> 00:14:02,610
destination objects it contains and all

00:14:00,420 --> 00:14:04,770
the destination objects are semantically

00:14:02,610 --> 00:14:08,430
identical to their corresponding source

00:14:04,770 --> 00:14:10,110
objects as experienced C++ programmers

00:14:08,430 --> 00:14:11,700
we all know intuitively that for a silly

00:14:10,110 --> 00:14:13,860
scheme like this to work there must be

00:14:11,700 --> 00:14:16,890
some restrictions on the types that can

00:14:13,860 --> 00:14:20,340
be used by and stored within such a

00:14:16,890 --> 00:14:22,440
relocatable heap and there are every

00:14:20,340 --> 00:14:25,860
object and a relocatable heat must be of

00:14:22,440 --> 00:14:27,720
a relocatable type and by in the heap I

00:14:25,860 --> 00:14:29,640
mean the objects used to implement the

00:14:27,720 --> 00:14:33,330
heap itself as well as the heaps

00:14:29,640 --> 00:14:35,910
contents so this begs the question of

00:14:33,330 --> 00:14:38,070
what is a relocatable type and again by

00:14:35,910 --> 00:14:40,980
Fiat I will declare that a type is

00:14:38,070 --> 00:14:43,620
relocatable if it can be serialized by

00:14:40,980 --> 00:14:45,780
writing raw bytes for example by being

00:14:43,620 --> 00:14:49,320
the source argument of a right or M copy

00:14:45,780 --> 00:14:51,510
operation and it is d serializable by

00:14:49,320 --> 00:14:54,030
reading raw bytes for example being the

00:14:51,510 --> 00:14:57,780
target arguments in a read or mem copy

00:14:54,030 --> 00:15:00,030
operation and a destination object of

00:14:57,780 --> 00:15:01,440
that type is semantically identical to

00:15:00,030 --> 00:15:04,410
its corresponding source object

00:15:01,440 --> 00:15:09,150
regardless of the destination objects

00:15:04,410 --> 00:15:11,760
address in the destination process so

00:15:09,150 --> 00:15:13,770
what kind of types are relocatable well

00:15:11,760 --> 00:15:16,790
it's pretty straightforward integer

00:15:13,770 --> 00:15:20,089
types and floating-point types also

00:15:16,790 --> 00:15:23,070
p.o.d types which when unwrapped

00:15:20,089 --> 00:15:26,370
ultimately contain only integer and

00:15:23,070 --> 00:15:29,520
floating-point types everything else is

00:15:26,370 --> 00:15:32,400
not relocatable well let's look at a few

00:15:29,520 --> 00:15:33,800
cases ordinary pointers to data are not

00:15:32,400 --> 00:15:36,930
relocatable

00:15:33,800 --> 00:15:38,880
the data to which they refer to that to

00:15:36,930 --> 00:15:41,850
which they refer on the destination in

00:15:38,880 --> 00:15:43,470
the destination process may exist at a

00:15:41,850 --> 00:15:46,080
different address than in the source

00:15:43,470 --> 00:15:47,610
process pointers to member functions

00:15:46,080 --> 00:15:50,190
static member functions and free

00:15:47,610 --> 00:15:52,110
functions are not relocatable because

00:15:50,190 --> 00:15:53,850
the object code to which they refer is

00:15:52,110 --> 00:15:55,380
very likely going to exist at a

00:15:53,850 --> 00:15:58,410
different address in the destination

00:15:55,380 --> 00:16:00,450
process likewise with types that have

00:15:58,410 --> 00:16:02,880
virtual functions this is because

00:16:00,450 --> 00:16:04,350
they're V tables will very likely exist

00:16:02,880 --> 00:16:07,440
at a different address in the

00:16:04,350 --> 00:16:10,140
destination process and finally types or

00:16:07,440 --> 00:16:11,640
values of types that express some sort

00:16:10,140 --> 00:16:13,620
of process dependence are not

00:16:11,640 --> 00:16:15,570
relocatable and here on thinking of

00:16:13,620 --> 00:16:18,990
things like file descriptors or windows

00:16:15,570 --> 00:16:20,880
handles of course by definition process

00:16:18,990 --> 00:16:23,960
to pin dependent handle types are

00:16:20,880 --> 00:16:26,520
meaningless outside their own process

00:16:23,960 --> 00:16:29,220
now these might seem like pretty severe

00:16:26,520 --> 00:16:30,900
restrictions and they are but if you

00:16:29,220 --> 00:16:32,910
think about them they sort of specify

00:16:30,900 --> 00:16:35,700
the kind of data that one might keep in

00:16:32,910 --> 00:16:37,890
a record residing in a table in an

00:16:35,700 --> 00:16:41,970
in-memory database in other words the

00:16:37,890 --> 00:16:45,210
kind of stuff that I do day today so

00:16:41,970 --> 00:16:47,130
let's sketch out a design for this first

00:16:45,210 --> 00:16:49,050
of all a real okay table heap would need

00:16:47,130 --> 00:16:52,350
to provide methods to initialize and

00:16:49,050 --> 00:16:54,180
serialize and deserialize the heap it

00:16:52,350 --> 00:16:56,190
also need to provide methods to store

00:16:54,180 --> 00:16:58,020
and access something I call a master

00:16:56,190 --> 00:17:00,450
object which would reside in the heap

00:16:58,020 --> 00:17:02,520
and here a master object is a special

00:17:00,450 --> 00:17:05,400
object that the heap itself is aware of

00:17:02,520 --> 00:17:07,829
its role is to act as a gateway to the

00:17:05,400 --> 00:17:11,760
actual contents of interest stored in

00:17:07,829 --> 00:17:13,560
the heat on the source side our client

00:17:11,760 --> 00:17:15,300
code would have to ensure that the

00:17:13,560 --> 00:17:17,579
relocatable type requirements are

00:17:15,300 --> 00:17:19,230
observed by all the Heat's contents and

00:17:17,579 --> 00:17:21,030
of course we would need to allocate

00:17:19,230 --> 00:17:23,220
everything that we want to be persistent

00:17:21,030 --> 00:17:25,949
from the heat and at some point we need

00:17:23,220 --> 00:17:28,800
to serialize the heap on the destination

00:17:25,949 --> 00:17:30,060
side our client code would need to do

00:17:28,800 --> 00:17:32,970
the congress it would need to

00:17:30,060 --> 00:17:35,160
deserialize the heap and obtain content

00:17:32,970 --> 00:17:40,230
obtain access to the heaps contents

00:17:35,160 --> 00:17:43,140
through the master object so when I

00:17:40,230 --> 00:17:45,720
think about this problem I see six not

00:17:43,140 --> 00:17:47,100
quite orthogonal concepts that I that I

00:17:45,720 --> 00:17:49,289
grew up into two

00:17:47,100 --> 00:17:51,090
broad categories as i mentioned earlier

00:17:49,289 --> 00:17:52,860
i call them concepts but it's perfectly

00:17:51,090 --> 00:17:56,640
reasonable to think of them as being

00:17:52,860 --> 00:17:59,039
policy types the first broad category i

00:17:56,640 --> 00:18:01,169
call structural management and here the

00:17:59,039 --> 00:18:03,720
four associated concepts are the

00:18:01,169 --> 00:18:05,789
addressing model the storage model the

00:18:03,720 --> 00:18:09,539
pointer interface and the allocation

00:18:05,789 --> 00:18:11,730
strategy the second broad category i

00:18:09,539 --> 00:18:13,740
call concurrency management and the two

00:18:11,730 --> 00:18:16,380
associated concepts are thread safety

00:18:13,740 --> 00:18:18,750
and transaction safety we're going to go

00:18:16,380 --> 00:18:22,620
into a little detail about regarding

00:18:18,750 --> 00:18:24,870
these concepts in the next few slides so

00:18:22,620 --> 00:18:27,270
let's start with the addressing model

00:18:24,870 --> 00:18:28,919
the first structural concept the

00:18:27,270 --> 00:18:30,840
addressing model is a type that

00:18:28,919 --> 00:18:33,419
implements primitive addressing

00:18:30,840 --> 00:18:36,030
operations its purpose is to provide

00:18:33,419 --> 00:18:37,650
access to raw memory segments and I'll

00:18:36,030 --> 00:18:40,140
define what a segment is in a couple of

00:18:37,650 --> 00:18:43,020
minutes in a way it's analogous to avoid

00:18:40,140 --> 00:18:45,299
star it must also be convertible to

00:18:43,020 --> 00:18:46,799
avoid star the conversion is important

00:18:45,299 --> 00:18:49,409
because when we want to cast an

00:18:46,799 --> 00:18:52,620
addressing model object to a non-void

00:18:49,409 --> 00:18:56,419
pointer we first have to usually we

00:18:52,620 --> 00:18:56,419
first have to turn it into a void star

00:18:57,409 --> 00:19:03,659
internally the addressing model defines

00:19:00,330 --> 00:19:06,840
the bits or the pattern of bits that are

00:19:03,659 --> 00:19:08,789
used to represent an address it defines

00:19:06,840 --> 00:19:13,559
how an address is computed from that

00:19:08,789 --> 00:19:15,570
pattern of bits and this implies how the

00:19:13,559 --> 00:19:19,140
addressing model expects memory to be

00:19:15,570 --> 00:19:21,030
arranged now from this description we

00:19:19,140 --> 00:19:25,250
can see that the simplest example of a

00:19:21,030 --> 00:19:25,250
storage model is in fact a void pointer

00:19:26,000 --> 00:19:30,840
there are really sort of two possible

00:19:27,950 --> 00:19:33,809
representations right the first is as an

00:19:30,840 --> 00:19:36,720
ordinary void pointer I also call them

00:19:33,809 --> 00:19:38,429
natural pointers the other is a

00:19:36,720 --> 00:19:41,340
synthetic void pointer or some other

00:19:38,429 --> 00:19:43,500
user-defined type these kinds of

00:19:41,340 --> 00:19:45,600
pointers are also known as fancy

00:19:43,500 --> 00:19:51,059
pointers the standard refers to them as

00:19:45,600 --> 00:19:53,909
pointer like types next up is the

00:19:51,059 --> 00:19:56,070
storage model and this is a policy type

00:19:53,909 --> 00:19:58,320
whose job is to manage segments it

00:19:56,070 --> 00:20:00,809
interacts with an external source of

00:19:58,320 --> 00:20:02,970
memory to borrow segments from the

00:20:00,809 --> 00:20:04,740
operating system and return them to the

00:20:02,970 --> 00:20:07,980
operating system at some point in time

00:20:04,740 --> 00:20:10,110
it provides an interface to segments in

00:20:07,980 --> 00:20:12,570
terms of the addressing model to the

00:20:10,110 --> 00:20:15,480
allocation to the allocation strategy

00:20:12,570 --> 00:20:21,120
and it forms the lowest level allocation

00:20:15,480 --> 00:20:22,799
in the stack so what's a segment I call

00:20:21,120 --> 00:20:24,870
a segment a region of memory that's been

00:20:22,799 --> 00:20:27,149
provided to the storage model by some

00:20:24,870 --> 00:20:29,519
primitive external source and here I've

00:20:27,149 --> 00:20:32,039
listed some of those sources both for

00:20:29,519 --> 00:20:35,369
Windows and for unix-like operating

00:20:32,039 --> 00:20:37,440
systems both sources that provide memory

00:20:35,369 --> 00:20:41,129
to the private address space and sources

00:20:37,440 --> 00:20:43,860
that can provide shared memory now I use

00:20:41,129 --> 00:20:46,049
the term segment because other

00:20:43,860 --> 00:20:48,240
allocators call them blocks or super

00:20:46,049 --> 00:20:49,799
blocks and I prefer to use terms without

00:20:48,240 --> 00:20:54,659
the word block in them just to avoid

00:20:49,799 --> 00:20:56,700
confusion the next structural concept is

00:20:54,659 --> 00:20:58,769
the pointer interface and this is a

00:20:56,700 --> 00:21:01,289
policy type that wraps the addressing

00:20:58,769 --> 00:21:04,710
model so that it can emulate a pointer

00:21:01,289 --> 00:21:07,230
to data it's analogous to a t-star for

00:21:04,710 --> 00:21:09,450
example it provides enough pointer

00:21:07,230 --> 00:21:12,269
syntax to get the job done whatever the

00:21:09,450 --> 00:21:14,369
job maybe it's convertible in the right

00:21:12,269 --> 00:21:15,929
direction to ordinary pointers and it's

00:21:14,369 --> 00:21:18,600
convertible in the right direction to

00:21:15,929 --> 00:21:20,070
other pointer interface types by in the

00:21:18,600 --> 00:21:23,730
right direction I mean things like

00:21:20,070 --> 00:21:26,879
adding CV qualifiers going from casting

00:21:23,730 --> 00:21:32,159
from derive to base or casting from T

00:21:26,879 --> 00:21:34,409
star to void star now there are again

00:21:32,159 --> 00:21:36,179
two possible representations a natural

00:21:34,409 --> 00:21:38,429
or ordinary pointer T star or a

00:21:36,179 --> 00:21:39,419
synthetic pointer and you may be

00:21:38,429 --> 00:21:42,929
wondering well what's the difference

00:21:39,419 --> 00:21:44,279
between a synthetic pointer and a random

00:21:42,929 --> 00:21:46,289
access iterator because they're actually

00:21:44,279 --> 00:21:48,899
very close and the difference is

00:21:46,289 --> 00:21:51,960
conversion operations I want to be able

00:21:48,899 --> 00:21:54,240
to take my pointer interface and apply

00:21:51,960 --> 00:21:56,309
ordinary casting operations to get

00:21:54,240 --> 00:21:58,320
ordinary pointers so that I don't have

00:21:56,309 --> 00:22:01,200
to go through convoluted syntax like I

00:21:58,320 --> 00:22:05,509
would with a random access iterator to

00:22:01,200 --> 00:22:05,509
get an actual address to something and

00:22:06,049 --> 00:22:10,409
just as with the addressing model the

00:22:08,669 --> 00:22:14,869
simplest example of a pointer interface

00:22:10,409 --> 00:22:14,869
to objects of type T is a t-star

00:22:15,669 --> 00:22:20,599
next up is the allocation strategy and

00:22:18,979 --> 00:22:22,700
this is what we normally think of as an

00:22:20,599 --> 00:22:24,709
alligator it's a policy type that

00:22:22,700 --> 00:22:27,589
manages the process of allocating memory

00:22:24,709 --> 00:22:29,599
for segments it requests segment

00:22:27,589 --> 00:22:31,279
allocation and de-allocation from the

00:22:29,599 --> 00:22:32,869
storage model and recall that the

00:22:31,279 --> 00:22:35,209
storage model is a proxy for the

00:22:32,869 --> 00:22:37,549
operating system it interacts with

00:22:35,209 --> 00:22:39,739
segments in terms of the addressing

00:22:37,549 --> 00:22:41,719
model it divides those segments into

00:22:39,739 --> 00:22:43,820
chunks for use by the client and it

00:22:41,719 --> 00:22:49,309
provides those chunks to the client in

00:22:43,820 --> 00:22:51,739
terms of the pointer interface and also

00:22:49,309 --> 00:22:53,419
by the way a chunk is a smaller region

00:22:51,739 --> 00:22:55,369
of memory that's carved out of the

00:22:53,419 --> 00:22:58,969
segment to be used by an alligator's

00:22:55,369 --> 00:23:00,679
client the final two concepts under

00:22:58,969 --> 00:23:02,989
concurrency management are thread safety

00:23:00,679 --> 00:23:04,609
and transaction safety of course thread

00:23:02,989 --> 00:23:06,409
safety means ensuring that your program

00:23:04,609 --> 00:23:08,539
operates correctly in the presence of

00:23:06,409 --> 00:23:10,789
multiple threads or processes in other

00:23:08,539 --> 00:23:12,979
words no data races and I think of

00:23:10,789 --> 00:23:15,200
transaction safety as meaning allocating

00:23:12,979 --> 00:23:17,089
and D allocating chunks in such a way

00:23:15,200 --> 00:23:19,159
that your allocator could be used by

00:23:17,089 --> 00:23:21,409
something that needs acid semantics like

00:23:19,159 --> 00:23:23,989
a database this means providing

00:23:21,409 --> 00:23:26,950
operations like commit and rollback for

00:23:23,989 --> 00:23:29,329
your allocate and deallocate functions

00:23:26,950 --> 00:23:30,859
now when I think about a relocatable

00:23:29,329 --> 00:23:32,749
heats implementation the structural

00:23:30,859 --> 00:23:34,999
concepts sort of build upon each other

00:23:32,749 --> 00:23:37,190
in a linear fashion however the

00:23:34,999 --> 00:23:39,979
concurrency concepts might be involved

00:23:37,190 --> 00:23:43,249
or intermingled with any or all of the

00:23:39,979 --> 00:23:44,989
structural concepts and I'm not going to

00:23:43,249 --> 00:23:47,119
say anything more about thread safety or

00:23:44,989 --> 00:23:49,279
transaction safety other than to mention

00:23:47,119 --> 00:23:50,929
that thinking about them is a very

00:23:49,279 --> 00:23:52,999
important consideration in the design of

00:23:50,929 --> 00:23:56,179
your allocator and you've got your work

00:23:52,999 --> 00:23:58,429
cut out for you so how would we

00:23:56,179 --> 00:23:59,929
characterize stood allocator by this

00:23:58,429 --> 00:24:02,149
mental framework it's pretty

00:23:59,929 --> 00:24:04,429
straightforward the addressing model is

00:24:02,149 --> 00:24:06,229
void star the storage model is

00:24:04,429 --> 00:24:09,469
implemented behind the scenes by global

00:24:06,229 --> 00:24:11,209
operator new using the operating

00:24:09,469 --> 00:24:14,389
system's memory management primitives

00:24:11,209 --> 00:24:16,489
the pointer interface is T star and the

00:24:14,389 --> 00:24:18,259
allocation strategy is also implemented

00:24:16,489 --> 00:24:20,749
behind the scenes by global operator new

00:24:18,259 --> 00:24:24,200
using whatever allocation algorithms the

00:24:20,749 --> 00:24:26,179
library writers have chosen likewise

00:24:24,200 --> 00:24:27,049
thread safety is implemented by global

00:24:26,179 --> 00:24:28,820
operator new

00:24:27,049 --> 00:24:31,549
it is whatever your implementation says

00:24:28,820 --> 00:24:34,759
it is finally as far as transaction

00:24:31,549 --> 00:24:36,499
safety goes there is none and you know

00:24:34,759 --> 00:24:40,159
these are all exactly what you would

00:24:36,499 --> 00:24:42,019
expect it's worth noting that from the

00:24:40,159 --> 00:24:43,999
perspective of this talk the major

00:24:42,019 --> 00:24:45,590
differences among common allocators is

00:24:43,999 --> 00:24:48,169
in the way they implement the storage

00:24:45,590 --> 00:24:49,879
model allocation strategy and thread

00:24:48,169 --> 00:24:52,279
safety concepts in order to improve

00:24:49,879 --> 00:24:55,779
performance or at least in the way that

00:24:52,279 --> 00:24:58,309
they desire to improve performance so

00:24:55,779 --> 00:25:00,230
recall that I want my relocatable heap

00:24:58,309 --> 00:25:02,090
to hold standard container and standard

00:25:00,230 --> 00:25:03,799
string objects and I want to be able to

00:25:02,090 --> 00:25:06,739
operate on those objects with standard

00:25:03,799 --> 00:25:10,369
algorithms the C++ 98 and 03 standards

00:25:06,739 --> 00:25:12,169
did not allow me to do this here's a

00:25:10,369 --> 00:25:14,029
load of verbiage from the 03 standard

00:25:12,169 --> 00:25:16,159
the highlighted text in the first

00:25:14,029 --> 00:25:18,739
section shows how containers were free

00:25:16,159 --> 00:25:21,139
to assume that the pointer and const

00:25:18,739 --> 00:25:25,580
pointer type defs nested in stood

00:25:21,139 --> 00:25:27,470
allocator our t star and consti star as

00:25:25,580 --> 00:25:29,989
far as i know until two or three or four

00:25:27,470 --> 00:25:31,940
years ago all of the implementations did

00:25:29,989 --> 00:25:33,919
this which effectively prevented

00:25:31,940 --> 00:25:36,799
standard containers from being used with

00:25:33,919 --> 00:25:39,739
allocators that allocate memory in terms

00:25:36,799 --> 00:25:41,389
of synthetic pointers the second

00:25:39,739 --> 00:25:43,549
paragraph is an attempt by the committee

00:25:41,389 --> 00:25:45,769
to encourage library implementers to

00:25:43,549 --> 00:25:49,690
support more sophisticated allocators

00:25:45,769 --> 00:25:49,690
but I don't think any of them really did

00:25:49,720 --> 00:25:56,090
here's a little diagram which sort of

00:25:52,220 --> 00:25:58,519
represents the old standards view of a

00:25:56,090 --> 00:26:00,529
container and it's allocator containers

00:25:58,519 --> 00:26:04,009
would obtain their allocation services

00:26:00,529 --> 00:26:06,139
and part of their view of memory from

00:26:04,009 --> 00:26:07,730
the allocator template argument and part

00:26:06,139 --> 00:26:10,190
of that view of memory includes things

00:26:07,730 --> 00:26:13,549
like the reference or const reference

00:26:10,190 --> 00:26:16,730
type deaths as well as the size type and

00:26:13,549 --> 00:26:18,769
difference type type dose but containers

00:26:16,730 --> 00:26:21,139
were totally free to assume and most of

00:26:18,769 --> 00:26:23,799
them did that a pointer was a t-star and

00:26:21,139 --> 00:26:26,840
a constant was a constant e star

00:26:23,799 --> 00:26:32,239
fortunately for us this changed in C++

00:26:26,840 --> 00:26:34,220
11 c++ c plus plus 11 beyond those

00:26:32,239 --> 00:26:36,769
offensive paragraphs from section 20

00:26:34,220 --> 00:26:38,419
were deleted and scattered throughout

00:26:36,769 --> 00:26:39,500
the library portion of the standard many

00:26:38,419 --> 00:26:42,530
new requirements were

00:26:39,500 --> 00:26:45,620
to support the idea of allocator aware

00:26:42,530 --> 00:26:47,780
containers I've listed five of these

00:26:45,620 --> 00:26:50,090
requirements here the five key

00:26:47,780 --> 00:26:52,670
requirements which I believe when taken

00:26:50,090 --> 00:26:54,470
together indicate the containers must

00:26:52,670 --> 00:26:57,410
support allocators that employs

00:26:54,470 --> 00:26:58,820
synthetic pointers I've listed some of

00:26:57,410 --> 00:27:00,380
the section numbers on the right and

00:26:58,820 --> 00:27:02,240
these section numbers are from the 14

00:27:00,380 --> 00:27:03,620
standard some of the numbers are

00:27:02,240 --> 00:27:06,230
slightly different in the 11th standard

00:27:03,620 --> 00:27:10,280
and some of them are different in the 17

00:27:06,230 --> 00:27:13,520
draft standard so here's a picture of

00:27:10,280 --> 00:27:16,310
the new way the new order working from

00:27:13,520 --> 00:27:18,680
the bottom up containers must now obtain

00:27:16,310 --> 00:27:22,010
all information about memory from the

00:27:18,680 --> 00:27:23,930
allocator traits template in turn the

00:27:22,010 --> 00:27:25,730
allocator traits template obtains

00:27:23,930 --> 00:27:28,250
information about memory allocation

00:27:25,730 --> 00:27:30,470
services from the allocator and also

00:27:28,250 --> 00:27:31,850
from the pointer traits template the

00:27:30,470 --> 00:27:34,670
pointer traits template has a very

00:27:31,850 --> 00:27:36,350
specialized job it obtains information

00:27:34,670 --> 00:27:40,040
about the representation of pointers

00:27:36,350 --> 00:27:42,020
from the allocator so given the services

00:27:40,040 --> 00:27:44,300
provided by the allocator and the

00:27:42,020 --> 00:27:47,330
representation of a pointer provided by

00:27:44,300 --> 00:27:49,430
pointer traits allocator traits collates

00:27:47,330 --> 00:27:51,590
this information and provides it to the

00:27:49,430 --> 00:27:53,900
allocator aware container so that the

00:27:51,590 --> 00:27:57,880
allocator aware container can go upon

00:27:53,900 --> 00:27:57,880
its merry way and and do important stuff

00:27:59,560 --> 00:28:05,260
okay so let's look at some example code

00:28:06,100 --> 00:28:12,920
here is one possible memory layout for a

00:28:09,560 --> 00:28:16,010
relocatable heap we have a set of n

00:28:12,920 --> 00:28:18,770
segments all of which are pointed to by

00:28:16,010 --> 00:28:22,010
what i call a backbone a backbone array

00:28:18,770 --> 00:28:23,720
of pointers constructing the address of

00:28:22,010 --> 00:28:25,970
something that lives in one of these

00:28:23,720 --> 00:28:28,100
segments is very much along the lines of

00:28:25,970 --> 00:28:30,110
doing a two dimensional array look up it

00:28:28,100 --> 00:28:32,350
is exactly along the lines of a

00:28:30,110 --> 00:28:35,240
two-dimensional array from the old

00:28:32,350 --> 00:28:38,870
numerical recipes and see if anybody use

00:28:35,240 --> 00:28:41,420
that early in their career and by the

00:28:38,870 --> 00:28:43,970
way the type of the backbone is an array

00:28:41,420 --> 00:28:49,160
of pointers to well unsigned 8-bit

00:28:43,970 --> 00:28:51,050
integers but bytes so one way of

00:28:49,160 --> 00:28:52,650
implementing this arrangement is in the

00:28:51,050 --> 00:28:55,620
processes own ad

00:28:52,650 --> 00:28:58,110
space perhaps by calling global new or

00:28:55,620 --> 00:29:01,200
some other primitive memory allocation

00:28:58,110 --> 00:29:04,140
service service to allocate the backbone

00:29:01,200 --> 00:29:06,090
and the segments and here I've got a

00:29:04,140 --> 00:29:11,250
variable called BP which is the backbone

00:29:06,090 --> 00:29:13,500
pointer that points to the backbone in

00:29:11,250 --> 00:29:15,750
the case of a heap that's based on

00:29:13,500 --> 00:29:17,580
shared memory there could also be an

00:29:15,750 --> 00:29:19,710
administrative segment that contains

00:29:17,580 --> 00:29:23,130
things like the shared memory segment

00:29:19,710 --> 00:29:24,690
IDs in system 5 shared memory or segment

00:29:23,130 --> 00:29:28,320
names if you're using POSIX shared

00:29:24,690 --> 00:29:30,450
memory now here I've tried to make the

00:29:28,320 --> 00:29:32,790
distinction between memory that's shared

00:29:30,450 --> 00:29:34,380
and memory that's private even though

00:29:32,790 --> 00:29:37,320
shared memory gets mapped into the

00:29:34,380 --> 00:29:39,840
processes private address space the

00:29:37,320 --> 00:29:43,140
backbone exists in private address space

00:29:39,840 --> 00:29:45,270
and a call to show Matt or M map Maps

00:29:43,140 --> 00:29:47,850
the shared segments into the processes

00:29:45,270 --> 00:29:49,650
private space the backbone needs to be

00:29:47,850 --> 00:29:51,840
in the process is private address space

00:29:49,650 --> 00:29:53,850
because the mapped addresses for the

00:29:51,840 --> 00:29:55,470
shared segments can be different in

00:29:53,850 --> 00:30:01,440
every process that would want to use

00:29:55,470 --> 00:30:03,870
these segments okay so let's look at

00:30:01,440 --> 00:30:07,200
some code and I'm going to walk through

00:30:03,870 --> 00:30:09,000
some types looking at basically some

00:30:07,200 --> 00:30:11,340
class definitions and one or two

00:30:09,000 --> 00:30:12,930
function definitions and then moving on

00:30:11,340 --> 00:30:16,230
to a short demo which hopefully will

00:30:12,930 --> 00:30:18,120
work so let's look at an example of the

00:30:16,230 --> 00:30:20,730
lowest level the addressing model type

00:30:18,120 --> 00:30:22,350
now i will say before starting that

00:30:20,730 --> 00:30:24,060
there are many ways that one could

00:30:22,350 --> 00:30:26,370
implement these concepts and make the

00:30:24,060 --> 00:30:28,500
system work I've chose to implement the

00:30:26,370 --> 00:30:30,570
for structural concepts as four distinct

00:30:28,500 --> 00:30:32,160
types if you decide to use this

00:30:30,570 --> 00:30:33,770
methodology you could do it differently

00:30:32,160 --> 00:30:36,750
and there's nothing wrong with that in

00:30:33,770 --> 00:30:39,570
this case my addressing model type is a

00:30:36,750 --> 00:30:41,430
class template and it's parameterised on

00:30:39,570 --> 00:30:44,700
the type of the storage manager that

00:30:41,430 --> 00:30:46,860
will use it I could have a private

00:30:44,700 --> 00:30:48,870
address storage manager I could have a

00:30:46,860 --> 00:30:52,470
shared memory storage manager I could

00:30:48,870 --> 00:30:54,150
have a stack-based array storage manager

00:30:52,470 --> 00:30:55,680
and I would like to be able to use the

00:30:54,150 --> 00:30:58,350
same addressing model with all of those

00:30:55,680 --> 00:30:59,700
things so I made it a template now we're

00:30:58,350 --> 00:31:02,070
looking at the prologue part of the

00:30:59,700 --> 00:31:05,580
class with important nested taipei laces

00:31:02,070 --> 00:31:06,630
and the canonical member functions and

00:31:05,580 --> 00:31:08,910
really all we need to know what

00:31:06,630 --> 00:31:11,250
point is sighs type and difference type

00:31:08,910 --> 00:31:13,260
and all of the canonical member

00:31:11,250 --> 00:31:15,060
functions are all defaulted and here

00:31:13,260 --> 00:31:18,480
I've also made them no except to make

00:31:15,060 --> 00:31:20,310
them to optimize performance the only

00:31:18,480 --> 00:31:22,410
ones that are not defaulted are the ones

00:31:20,310 --> 00:31:26,490
which take a parameter of null pointer

00:31:22,410 --> 00:31:30,360
type here's the middle of that class

00:31:26,490 --> 00:31:31,860
I've got some functions address offset

00:31:30,360 --> 00:31:34,200
in segments which provide information

00:31:31,860 --> 00:31:36,180
about memory and here the key function

00:31:34,200 --> 00:31:39,000
the most interesting interesting one I

00:31:36,180 --> 00:31:41,040
call address there are some helper

00:31:39,000 --> 00:31:43,170
functions which are used to perform

00:31:41,040 --> 00:31:45,720
comparison and here there's a helper

00:31:43,170 --> 00:31:48,690
function to test for quality and helper

00:31:45,720 --> 00:31:50,760
functions to test for less than and or

00:31:48,690 --> 00:31:53,220
greater than operations but I've not

00:31:50,760 --> 00:31:56,580
shown them here for brevity there's also

00:31:53,220 --> 00:31:59,400
some operations to allow assignment from

00:31:56,580 --> 00:32:02,130
a void pointer and also to increment or

00:31:59,400 --> 00:32:04,620
decrement what the addressing model

00:32:02,130 --> 00:32:06,930
refers to and this is a little bit of a

00:32:04,620 --> 00:32:09,090
fudge because in this case the increment

00:32:06,930 --> 00:32:10,950
the addressing model is not truly acting

00:32:09,090 --> 00:32:12,630
like a void pointer because I'm allowing

00:32:10,950 --> 00:32:14,280
it to be incremented and decremented

00:32:12,630 --> 00:32:17,010
it's actually acting a little more like

00:32:14,280 --> 00:32:21,840
a char star but this little cheat makes

00:32:17,010 --> 00:32:25,290
things easier to implement downstream at

00:32:21,840 --> 00:32:28,260
the bottom of the type in the private

00:32:25,290 --> 00:32:30,150
section I've decided to make the store

00:32:28,260 --> 00:32:33,270
the storage model a friend and the

00:32:30,150 --> 00:32:35,490
reason will become clear and I also have

00:32:33,270 --> 00:32:36,990
and actually it's because it needs to

00:32:35,490 --> 00:32:38,940
call the constructor that you see on the

00:32:36,990 --> 00:32:40,920
next line which is to construct an

00:32:38,940 --> 00:32:44,700
instance given a segment ID and an

00:32:40,920 --> 00:32:47,760
offset into a segment and the next part

00:32:44,700 --> 00:32:50,090
I've defined a bit mask and I've defined

00:32:47,760 --> 00:32:56,010
a structure I call adder bits which is a

00:32:50,090 --> 00:32:57,720
64-bit structure and I've duplicated it

00:32:56,010 --> 00:33:02,220
here to show the very bottom of the

00:32:57,720 --> 00:33:05,040
class so the actual bits are stored in

00:33:02,220 --> 00:33:07,710
an anonymous union of a 64-bit integer

00:33:05,040 --> 00:33:10,200
and an adder bit structure and the idea

00:33:07,710 --> 00:33:12,390
here is that the upper 16 bits which are

00:33:10,200 --> 00:33:15,810
called em segments will represent the

00:33:12,390 --> 00:33:17,910
segment ID and the lower 48 bits will

00:33:15,810 --> 00:33:19,410
represent the offset into a segment

00:33:17,910 --> 00:33:21,090
which means I'm going to have to do

00:33:19,410 --> 00:33:23,790
a little bit of bit twiddling to compute

00:33:21,090 --> 00:33:27,630
an address and this is good old segment

00:33:23,790 --> 00:33:32,940
offset addressing if any of you are old

00:33:27,630 --> 00:33:34,560
enough to remember this so our example

00:33:32,940 --> 00:33:36,030
storage model is actually a very

00:33:34,560 --> 00:33:39,990
straightforward class there are no

00:33:36,030 --> 00:33:42,360
templates here it provides important

00:33:39,990 --> 00:33:44,970
infra interface information downstream

00:33:42,360 --> 00:33:48,120
to the allocation adage a strategy type

00:33:44,970 --> 00:33:50,460
which I will also call a heap now two

00:33:48,120 --> 00:33:52,890
items of particular interest here are

00:33:50,460 --> 00:33:54,390
the type alias which describes the

00:33:52,890 --> 00:33:58,530
addressing model so there's a little bit

00:33:54,390 --> 00:34:01,170
of CRT p here although not really and a

00:33:58,530 --> 00:34:03,900
static member function that returns an

00:34:01,170 --> 00:34:11,070
addressing model object given a segment

00:34:03,900 --> 00:34:12,929
ID and an offset in the bottom part of

00:34:11,070 --> 00:34:14,160
the storage model well they see in

00:34:12,929 --> 00:34:15,480
public portion there are some other

00:34:14,160 --> 00:34:18,179
helper functions but the interesting

00:34:15,480 --> 00:34:20,340
stuff is in the private section here

00:34:18,179 --> 00:34:22,140
I've also I've implemented a reciprocal

00:34:20,340 --> 00:34:25,740
friendship relationship with the

00:34:22,140 --> 00:34:27,960
addressing model and i've defined some

00:34:25,740 --> 00:34:29,640
arrays of data which are segment the

00:34:27,960 --> 00:34:33,390
first one which is highlighted in black

00:34:29,640 --> 00:34:34,800
is the backbone it's that array of byte

00:34:33,390 --> 00:34:37,580
pointers which will point to the

00:34:34,800 --> 00:34:40,260
segment's the next is an array of

00:34:37,580 --> 00:34:41,910
addressing model types which are the

00:34:40,260 --> 00:34:44,370
actual pointers that will be used

00:34:41,910 --> 00:34:46,110
publicly and there's an array of size

00:34:44,370 --> 00:34:47,940
types which tell me how long each

00:34:46,110 --> 00:34:50,520
segment is and there's this funny thing

00:34:47,940 --> 00:34:52,230
called the shadow backbone and the

00:34:50,520 --> 00:34:53,910
purpose of this I will reveal later and

00:34:52,230 --> 00:34:59,970
hopefully it will work correctly in the

00:34:53,910 --> 00:35:03,120
demo so how are the addressing model and

00:34:59,970 --> 00:35:04,680
the storage model tied together so at

00:35:03,120 --> 00:35:07,290
the top of this the code in blue

00:35:04,680 --> 00:35:09,090
represents some snippets from the

00:35:07,290 --> 00:35:11,700
addressing model and the storage model

00:35:09,090 --> 00:35:13,260
the first part above the ellipsis is

00:35:11,700 --> 00:35:15,060
from the addressing model and below the

00:35:13,260 --> 00:35:17,220
ellipsis is from the storage model and

00:35:15,060 --> 00:35:20,070
I've provided this here so you can

00:35:17,220 --> 00:35:22,650
understand how the addressing model

00:35:20,070 --> 00:35:24,690
computes an address and this is the

00:35:22,650 --> 00:35:27,570
function in black at the bottom and I've

00:35:24,690 --> 00:35:31,490
actually bolted the computation as you

00:35:27,570 --> 00:35:31,490
can see it's a pretty simple operation

00:35:31,710 --> 00:35:37,859
the first thing that occurs well

00:35:35,300 --> 00:35:39,030
assuming I will say it's the first thing

00:35:37,859 --> 00:35:41,550
that occurs but of course it could be

00:35:39,030 --> 00:35:44,849
evaluated in any order we dereference

00:35:41,550 --> 00:35:50,480
the segment backbone using the segment

00:35:44,849 --> 00:35:54,960
ID to get a pointer to a segment we then

00:35:50,480 --> 00:35:57,810
apply the mask to the offset we apply

00:35:54,960 --> 00:36:00,780
the mask to the amader bits to obtain

00:35:57,810 --> 00:36:03,810
the offset and finally we add the two

00:36:00,780 --> 00:36:06,900
together to compute a byte address or

00:36:03,810 --> 00:36:10,589
char star address and that gets returned

00:36:06,900 --> 00:36:15,420
to the caller as a void star pretty

00:36:10,589 --> 00:36:17,339
straightforward ok the third important

00:36:15,420 --> 00:36:19,859
type and probably the most complex type

00:36:17,339 --> 00:36:22,410
at least in terms of interface is the

00:36:19,859 --> 00:36:24,089
pointer interface type and most of that

00:36:22,410 --> 00:36:26,820
complexity in the interface comes from a

00:36:24,089 --> 00:36:28,770
desire to mimic ordinary pointers we

00:36:26,820 --> 00:36:31,109
cannot do a perfect job of that but we

00:36:28,770 --> 00:36:34,050
can get reasonably close close enough to

00:36:31,109 --> 00:36:35,760
implement containers and I've sort of

00:36:34,050 --> 00:36:37,859
provided an outline here of the various

00:36:35,760 --> 00:36:39,570
sections that will touch on canonical

00:36:37,859 --> 00:36:42,030
member functions other constructors

00:36:39,570 --> 00:36:44,010
other assignment operators conversion

00:36:42,030 --> 00:36:46,980
operators dereferencing and pointer

00:36:44,010 --> 00:36:48,900
arithmetic helpers to support library

00:36:46,980 --> 00:36:50,940
requirements helpers to support

00:36:48,900 --> 00:36:55,380
comparison operators and finally our

00:36:50,940 --> 00:36:58,650
data member but in order to get there

00:36:55,380 --> 00:37:01,800
and to help us provide desirable

00:36:58,650 --> 00:37:03,089
conversions in the right direction we're

00:37:01,800 --> 00:37:05,790
going to turn to some custom traits

00:37:03,089 --> 00:37:07,500
types to do svn a and s fina is a

00:37:05,790 --> 00:37:09,540
technique that allows us to remove a

00:37:07,500 --> 00:37:11,490
member function from overload resolution

00:37:09,540 --> 00:37:13,500
so that we can control the set of

00:37:11,490 --> 00:37:16,380
possible overloads that participate in

00:37:13,500 --> 00:37:19,050
that process so the first template here

00:37:16,380 --> 00:37:20,670
is called implicitly convertible and we

00:37:19,050 --> 00:37:22,470
use it to an eight I use it to enable

00:37:20,670 --> 00:37:26,310
member functions when an implicit

00:37:22,470 --> 00:37:27,750
conversion from from star to to star

00:37:26,310 --> 00:37:29,910
makes sense and these are the

00:37:27,750 --> 00:37:32,400
conversions I mentioned earlier adding

00:37:29,910 --> 00:37:35,280
cv qualifiers going from derived to base

00:37:32,400 --> 00:37:38,070
or from anything to void and it just

00:37:35,280 --> 00:37:41,250
relies on stood enable if and stood is

00:37:38,070 --> 00:37:43,680
convertible the second is the logical

00:37:41,250 --> 00:37:44,880
converse of the first and I call it

00:37:43,680 --> 00:37:47,400
explicit conversion with

00:37:44,880 --> 00:37:49,230
choir the name isn't when used in the

00:37:47,400 --> 00:37:51,060
code the name is intended to convey that

00:37:49,230 --> 00:37:54,030
the member function associated with this

00:37:51,060 --> 00:37:56,640
SVA must be used with an explicit

00:37:54,030 --> 00:37:58,950
conversion operator and finally the

00:37:56,640 --> 00:38:03,090
third trait I call implicitly comparable

00:37:58,950 --> 00:38:05,760
and its job is to help with the help and

00:38:03,090 --> 00:38:07,590
performing conversions between synthetic

00:38:05,760 --> 00:38:09,180
pointer types and ordinary pointer types

00:38:07,590 --> 00:38:11,310
we want to make sure that we're

00:38:09,180 --> 00:38:14,730
performing a comparison that makes sense

00:38:11,310 --> 00:38:19,590
like comparing a basestar to a derived

00:38:14,730 --> 00:38:21,600
star or or anything that adds cv

00:38:19,590 --> 00:38:24,750
qualifiers we don't want to do things

00:38:21,600 --> 00:38:29,310
like compare a double star to a char

00:38:24,750 --> 00:38:31,980
star okay at the top of the template is

00:38:29,310 --> 00:38:34,620
the prologue there's a reminder and some

00:38:31,980 --> 00:38:38,670
nested type aliases for consumption by

00:38:34,620 --> 00:38:41,550
standard pointer traits I've also thrown

00:38:38,670 --> 00:38:43,620
in a random access iterator tag so that

00:38:41,550 --> 00:38:45,690
the synthetic pointer can be used as a

00:38:43,620 --> 00:38:49,170
random access iterator with the standard

00:38:45,690 --> 00:38:51,420
algorithms there are no surprises in the

00:38:49,170 --> 00:38:53,460
canonical member functions everything is

00:38:51,420 --> 00:38:54,960
defaulted and I've sort of cheated a

00:38:53,460 --> 00:38:58,520
little bit and made them know except

00:38:54,960 --> 00:39:02,460
even though strictly they shouldn't be

00:38:58,520 --> 00:39:04,980
next are some custom constructors the

00:39:02,460 --> 00:39:07,380
first to a group together they're allow

00:39:04,980 --> 00:39:09,180
implicit conversion from an addressing

00:39:07,380 --> 00:39:13,080
model object and also from a null

00:39:09,180 --> 00:39:16,470
pointer the second to conversion on the

00:39:13,080 --> 00:39:19,500
second to permit implicit conversion

00:39:16,470 --> 00:39:22,700
from compatible ordinary and setting and

00:39:19,500 --> 00:39:25,710
synthetic pointer types so if a you star

00:39:22,700 --> 00:39:27,870
can be implicitly converted to a t-star

00:39:25,710 --> 00:39:29,930
then these two constructors will

00:39:27,870 --> 00:39:32,640
participate in overload resolution

00:39:29,930 --> 00:39:34,410
otherwise as stignes kicks them out and

00:39:32,640 --> 00:39:38,310
it's as if they doesn't they don't exist

00:39:34,410 --> 00:39:40,500
and as an aside I'm was pleased to see

00:39:38,310 --> 00:39:42,750
that this technique which I'm using is

00:39:40,500 --> 00:39:45,210
identical to the technique that Stefan

00:39:42,750 --> 00:39:46,620
lowville Wade described as Spain a

00:39:45,210 --> 00:39:48,540
technique number five in his talk

00:39:46,620 --> 00:39:53,250
Tuesday so I must be doing something

00:39:48,540 --> 00:39:55,410
partially right similarly with

00:39:53,250 --> 00:39:57,600
assignment I want to allow assignment

00:39:55,410 --> 00:39:58,500
from a null pointer and compatible

00:39:57,600 --> 00:40:00,360
assignment from an

00:39:58,500 --> 00:40:02,480
ordinary or synthetic pointer again

00:40:00,360 --> 00:40:05,960
compatible being adding CV qualifiers

00:40:02,480 --> 00:40:08,280
derive to base or anything to avoid as

00:40:05,960 --> 00:40:10,230
with the Constructors on the previous

00:40:08,280 --> 00:40:11,970
slide if a used star can be implicitly

00:40:10,230 --> 00:40:14,730
converted to a t-star than these two

00:40:11,970 --> 00:40:16,500
assignment operators the second to

00:40:14,730 --> 00:40:18,840
assignment operators will participate in

00:40:16,500 --> 00:40:23,190
overload resolution otherwise they're

00:40:18,840 --> 00:40:26,190
right out the conversion operators I

00:40:23,190 --> 00:40:28,230
find to be interesting the first

00:40:26,190 --> 00:40:31,320
provides an explicit conversion to bhool

00:40:28,230 --> 00:40:33,210
which is usually explicit except when it

00:40:31,320 --> 00:40:37,080
exists in a context where so-called

00:40:33,210 --> 00:40:38,970
contextual conversion can occur and the

00:40:37,080 --> 00:40:40,830
way to think about this is the

00:40:38,970 --> 00:40:43,110
conversion to bool will be implicit if

00:40:40,830 --> 00:40:47,850
it occurs inside of an if statement or a

00:40:43,110 --> 00:40:50,040
while statement or a for statement the

00:40:47,850 --> 00:40:51,780
second conversion operator provides for

00:40:50,040 --> 00:40:55,890
an implicit conversion to a compatible

00:40:51,780 --> 00:40:57,990
ordinary pointer type the corresponding

00:40:55,890 --> 00:40:59,700
implicit conversion to a compatible

00:40:57,990 --> 00:41:01,320
synthetic pointer type is handled by the

00:40:59,700 --> 00:41:04,140
conversions constructor that was a

00:41:01,320 --> 00:41:06,210
couple slides back the third and fourth

00:41:04,140 --> 00:41:08,640
conversion operators provide for

00:41:06,210 --> 00:41:11,130
explicit conversion in the other

00:41:08,640 --> 00:41:15,950
direction and here I'm thinking of

00:41:11,130 --> 00:41:18,960
things like removing CV qualifiers or

00:41:15,950 --> 00:41:21,170
casting from baked from base to derived

00:41:18,960 --> 00:41:23,970
or casting from void to something else

00:41:21,170 --> 00:41:25,770
so when taken together the upshot is

00:41:23,970 --> 00:41:28,650
that if a conversion can be done

00:41:25,770 --> 00:41:30,960
implicitly between a you star and a

00:41:28,650 --> 00:41:32,880
t-star then one set of member functions

00:41:30,960 --> 00:41:34,620
will participate in overload resolution

00:41:32,880 --> 00:41:36,510
and allow that to occur implicitly

00:41:34,620 --> 00:41:38,400
otherwise a different set of member

00:41:36,510 --> 00:41:41,180
functions participate in overload

00:41:38,400 --> 00:41:45,630
resolution an explicit conversion

00:41:41,180 --> 00:41:46,890
explicit cast is required of course the

00:41:45,630 --> 00:41:48,720
synthetic pointer needs to support

00:41:46,890 --> 00:41:51,390
dereferencing indexing and pointer

00:41:48,720 --> 00:41:53,520
arithmetic operations and if if this

00:41:51,390 --> 00:41:55,350
looks familiar it should it's identical

00:41:53,520 --> 00:42:00,870
to the interface that a random access

00:41:55,350 --> 00:42:03,120
iterator must provide at the top is the

00:42:00,870 --> 00:42:06,780
pointer to member function which is

00:42:03,120 --> 00:42:10,310
provided to be used by standard pointer

00:42:06,780 --> 00:42:12,660
traits and what this does is it takes an

00:42:10,310 --> 00:42:16,440
efference to some element

00:42:12,660 --> 00:42:18,599
returns a synthetic point now just like

00:42:16,440 --> 00:42:20,160
with the example addressing model we saw

00:42:18,599 --> 00:42:22,799
a few slides back there are some helper

00:42:20,160 --> 00:42:25,319
functions here which I've defined to be

00:42:22,799 --> 00:42:26,609
used by the binary comparison operators

00:42:25,319 --> 00:42:29,490
which I'm not going to show because

00:42:26,609 --> 00:42:31,710
they're fairly straightforward and in

00:42:29,490 --> 00:42:33,630
these helper functions equals less than

00:42:31,710 --> 00:42:36,240
and greater than is where the implicitly

00:42:33,630 --> 00:42:37,770
comparable type trade is is used to

00:42:36,240 --> 00:42:41,789
ensure that we're only going to perform

00:42:37,770 --> 00:42:43,230
comparisons that make sense and finally

00:42:41,789 --> 00:42:45,210
the private section of the class is

00:42:43,230 --> 00:42:47,220
quite simple this is where an interest

00:42:45,210 --> 00:42:49,319
an instance of the addressing model is

00:42:47,220 --> 00:42:51,720
stored now there's a friendship relation

00:42:49,319 --> 00:42:54,329
a friendship declaration to all of its

00:42:51,720 --> 00:42:55,890
cousins it grants friendship to any

00:42:54,329 --> 00:42:57,960
other synthetic pointer template

00:42:55,890 --> 00:42:59,880
although its purpose is to permit the

00:42:57,960 --> 00:43:01,710
conversion to permit one of the

00:42:59,880 --> 00:43:03,900
conversion constructors we saw earlier

00:43:01,710 --> 00:43:06,539
which is converting which means

00:43:03,900 --> 00:43:10,319
converting synthetic pointer of t comma

00:43:06,539 --> 00:43:14,730
am to synthetic pointer of you comma am

00:43:10,319 --> 00:43:17,250
assuming that conversion makes sense so

00:43:14,730 --> 00:43:18,930
here's the allocation strategy another

00:43:17,250 --> 00:43:20,880
very simple class but here it's a class

00:43:18,930 --> 00:43:25,710
template and here i call it segmented

00:43:20,880 --> 00:43:27,240
test heat it provides some type aliases

00:43:25,710 --> 00:43:29,849
which will be consumed by an alligator

00:43:27,240 --> 00:43:34,049
rapper we'll see in the next slide it

00:43:29,849 --> 00:43:36,809
provides pointer rebinding so that given

00:43:34,049 --> 00:43:39,690
any type t it can provide a point of

00:43:36,809 --> 00:43:42,960
synthetic pointer for that type t using

00:43:39,690 --> 00:43:44,579
the addressing model and it has very

00:43:42,960 --> 00:43:48,000
simple service functions much like an

00:43:44,579 --> 00:43:50,849
alligator max size allocate deallocate

00:43:48,000 --> 00:43:53,760
and the mysterious swap buffers member

00:43:50,849 --> 00:43:56,190
function now note that allocate returns

00:43:53,760 --> 00:43:58,799
a void pointer and note just above that

00:43:56,190 --> 00:44:01,109
void pointer here is a synthetic void a

00:43:58,799 --> 00:44:03,950
synthetic pointer representing a void

00:44:01,109 --> 00:44:09,569
pointer but using our addressing model

00:44:03,950 --> 00:44:11,579
template argument and here's an

00:44:09,569 --> 00:44:13,319
allocator wrapper a simple class

00:44:11,579 --> 00:44:15,240
template that's parameterised by an

00:44:13,319 --> 00:44:18,390
element type and by an allocation

00:44:15,240 --> 00:44:20,400
strategy type the thing we just saw its

00:44:18,390 --> 00:44:23,819
interface is compatible with stood

00:44:20,400 --> 00:44:25,840
allocator traits the top is all very

00:44:23,819 --> 00:44:27,640
standard stuff you'll see this in

00:44:25,840 --> 00:44:30,160
just about every standard conforming

00:44:27,640 --> 00:44:34,150
allocator the basic type aliases that

00:44:30,160 --> 00:44:36,250
define what memory is and also there's

00:44:34,150 --> 00:44:39,010
the rebind ER which is then part of

00:44:36,250 --> 00:44:41,320
stood allocator I think since C++ 98 and

00:44:39,010 --> 00:44:43,000
this allows conversion from one

00:44:41,320 --> 00:44:47,740
allocator type to another by simply

00:44:43,000 --> 00:44:49,390
changing the element type the bottom

00:44:47,740 --> 00:44:51,460
half here is also pretty straightforward

00:44:49,390 --> 00:44:53,440
the allocate and deallocate member

00:44:51,460 --> 00:44:54,820
functions simply wrap the corresponding

00:44:53,440 --> 00:44:59,790
member functions in the allocation

00:44:54,820 --> 00:45:04,780
strategy and they return or take

00:44:59,790 --> 00:45:06,910
synthetic pointers to do their work the

00:45:04,780 --> 00:45:08,680
final two member functions construct and

00:45:06,910 --> 00:45:10,570
destroy these are part of the standard

00:45:08,680 --> 00:45:14,340
allocator interface now and what they do

00:45:10,570 --> 00:45:18,010
is they perform in place construction of

00:45:14,340 --> 00:45:20,410
an object given some arguments and given

00:45:18,010 --> 00:45:23,110
a chunk of memory and also perform in

00:45:20,410 --> 00:45:26,380
place destruction given a pointer to an

00:45:23,110 --> 00:45:29,470
object of that type and for purposes of

00:45:26,380 --> 00:45:32,530
exposition I've decided to include an

00:45:29,470 --> 00:45:36,240
instance of my out of my allocation

00:45:32,530 --> 00:45:40,950
strategy type which I'm calling em heap

00:45:36,240 --> 00:45:44,470
all right so let's look at an example

00:45:40,950 --> 00:45:46,510
what would this look like in practice so

00:45:44,470 --> 00:45:49,750
I've tried to put together a fairly

00:45:46,510 --> 00:45:53,830
simple test function hopefully it will

00:45:49,750 --> 00:45:56,620
all make sense I'll begin by including

00:45:53,830 --> 00:45:58,900
some standard headers I'm then going to

00:45:56,620 --> 00:46:01,900
include some headers which define the

00:45:58,900 --> 00:46:04,030
types that you just saw and I'm going to

00:46:01,900 --> 00:46:05,860
slightly break a rule here and I'm going

00:46:04,030 --> 00:46:08,800
to import everything from namespace

00:46:05,860 --> 00:46:11,880
stood and i'm going to start defining

00:46:08,800 --> 00:46:14,080
some type aliases to make things easier

00:46:11,880 --> 00:46:16,660
the first I'm going to do is I'm going

00:46:14,080 --> 00:46:19,480
to make a typedef of our storage model

00:46:16,660 --> 00:46:21,490
because these names can get very long so

00:46:19,480 --> 00:46:26,170
what I'm doing is I'm calling my test

00:46:21,490 --> 00:46:28,900
heap the the instance of our segmented

00:46:26,170 --> 00:46:31,630
test heap template which is parametrized

00:46:28,900 --> 00:46:34,200
in terms of our segmented private

00:46:31,630 --> 00:46:34,200
storage law

00:46:35,040 --> 00:46:40,950
I'm going to define our test I'm going

00:46:37,860 --> 00:46:43,290
to bind the heap argument of our

00:46:40,950 --> 00:46:44,940
allocator type and only allow the

00:46:43,290 --> 00:46:48,480
element type to vary with this

00:46:44,940 --> 00:46:50,430
parameterised alias likewise I'm going

00:46:48,480 --> 00:46:52,890
to define a test string by binding the

00:46:50,430 --> 00:46:55,530
character traits and the allocator type

00:46:52,890 --> 00:46:56,850
but allowing the character to the sorry

00:46:55,530 --> 00:46:59,000
the allocator type but allowing the

00:46:56,850 --> 00:47:01,950
character type of the string to vary I'm

00:46:59,000 --> 00:47:04,380
going to define a test list and I'm

00:47:01,950 --> 00:47:06,930
going to bind the allocator type and but

00:47:04,380 --> 00:47:09,230
allow the element type to vary and

00:47:06,930 --> 00:47:12,450
finally I'm going to define a test map

00:47:09,230 --> 00:47:15,000
this map will associate a string with a

00:47:12,450 --> 00:47:18,030
list of strings and here I'm going to

00:47:15,000 --> 00:47:19,950
bind the comparator and the allocator

00:47:18,030 --> 00:47:26,430
but allow the key and value types too

00:47:19,950 --> 00:47:28,830
very so here's an actual function the

00:47:26,430 --> 00:47:30,840
highlighted code shows the actual type

00:47:28,830 --> 00:47:34,590
that I'm going to allocate and I call it

00:47:30,840 --> 00:47:37,830
demo map so demo map is a test map which

00:47:34,590 --> 00:47:41,570
is instantiated using a test string of

00:47:37,830 --> 00:47:46,550
char as the key type and a test list of

00:47:41,570 --> 00:47:50,700
tests string of char as the value type

00:47:46,550 --> 00:47:52,770
and this is where I'm going to allocate

00:47:50,700 --> 00:47:54,330
it now the allocate function here is a

00:47:52,770 --> 00:47:55,950
simple helper function which is

00:47:54,330 --> 00:47:58,980
off-screen and i'm not going to show it

00:47:55,950 --> 00:48:02,340
here but what it does is it allocates an

00:47:58,980 --> 00:48:07,080
object of type demo map using the test

00:48:02,340 --> 00:48:09,150
heap allocation strategy i'm also going

00:48:07,080 --> 00:48:11,310
to allocate a work buffer for Mikey

00:48:09,150 --> 00:48:12,840
strings here i'm just going to implement

00:48:11,310 --> 00:48:16,770
a test string and i'm going to use that

00:48:12,840 --> 00:48:18,990
as a buffer likewise i'm going to

00:48:16,770 --> 00:48:21,150
allocate a string to be used as a work

00:48:18,990 --> 00:48:26,010
buffer for my value strings that will go

00:48:21,150 --> 00:48:28,500
in the list and the top of the code here

00:48:26,010 --> 00:48:31,230
is a very simple nested loop that will

00:48:28,500 --> 00:48:33,300
populate the map i'm going to create 10

00:48:31,230 --> 00:48:35,310
elements i'm going to with different

00:48:33,300 --> 00:48:38,490
strings for each element and for each

00:48:35,310 --> 00:48:40,590
element there will be a key there will

00:48:38,490 --> 00:48:42,270
be a value that's a list and i'm going

00:48:40,590 --> 00:48:43,710
to put five elements in the list five

00:48:42,270 --> 00:48:45,880
strings each of which will have a

00:48:43,710 --> 00:48:49,220
different value

00:48:45,880 --> 00:48:51,319
and here's the particular line of code

00:48:49,220 --> 00:48:53,480
that does that shouldn't be any

00:48:51,319 --> 00:48:55,279
surprises here the only slight wrinkle

00:48:53,480 --> 00:48:57,380
is instead of using references I'm

00:48:55,279 --> 00:49:01,900
dereferencing these synthetic pointers

00:48:57,380 --> 00:49:03,859
for each of the each of those operations

00:49:01,900 --> 00:49:08,390
next I'm going to have a loop that

00:49:03,859 --> 00:49:10,099
prints the contents of the map then I'm

00:49:08,390 --> 00:49:12,890
going to call this magic function swap

00:49:10,099 --> 00:49:15,559
buffers and what swap buffers does this

00:49:12,890 --> 00:49:17,269
will now be revealed is it's going to

00:49:15,559 --> 00:49:19,309
take the data stored in the primary

00:49:17,269 --> 00:49:21,529
segments in the backbone it's going to M

00:49:19,309 --> 00:49:23,839
copy them into the corresponding shadow

00:49:21,529 --> 00:49:26,509
segment and then it's going to swap the

00:49:23,839 --> 00:49:30,589
segment's in effect I am relocating my

00:49:26,509 --> 00:49:36,410
heap finally I'm going to print the

00:49:30,589 --> 00:49:41,299
contents again so recall this is the

00:49:36,410 --> 00:49:44,450
picture of our memory layout and this

00:49:41,299 --> 00:49:46,910
shows our primary backbone in primary

00:49:44,450 --> 00:49:48,740
segments and our shadow backbone and

00:49:46,910 --> 00:49:50,989
shadow segments and as I said swap

00:49:48,740 --> 00:49:53,599
buffers will M copy data from the

00:49:50,989 --> 00:49:56,390
primary segments to the shadow segments

00:49:53,599 --> 00:49:58,460
it will then swap the pointers in the in

00:49:56,390 --> 00:50:03,380
the backbone arrays and we will

00:49:58,460 --> 00:50:05,029
effectively relocate the data okay and

00:50:03,380 --> 00:50:10,599
so now with your indulgence I'm going to

00:50:05,029 --> 00:50:10,599
try and do a demo here give me a moment

00:50:28,689 --> 00:50:35,809
okay here i am in a sent a 7.2 virtual

00:50:32,900 --> 00:50:37,489
machine and I've actually queued up gdb

00:50:35,809 --> 00:50:44,689
with this program and I've got some

00:50:37,489 --> 00:50:48,709
breakpoint set and I am redirecting

00:50:44,689 --> 00:50:50,150
output to to see out to the terminal

00:50:48,709 --> 00:50:54,079
that you see on the right and hopefully

00:50:50,150 --> 00:50:55,999
this will be readable so I'm going to

00:50:54,079 --> 00:51:03,489
start the program so here I am at the

00:50:55,999 --> 00:51:06,650
top of that function so I'm going to

00:51:03,489 --> 00:51:09,049
allocate the map I'm going to allocate

00:51:06,650 --> 00:51:12,259
the string and I'm going to step into my

00:51:09,049 --> 00:51:15,140
loop that does the population and I'm

00:51:12,259 --> 00:51:20,959
going to do this a few times because

00:51:15,140 --> 00:51:24,769
it's amusing okay so I've just done the

00:51:20,959 --> 00:51:27,920
first element and I'm going to continue

00:51:24,769 --> 00:51:30,229
to the next breakpoint and you can see

00:51:27,920 --> 00:51:34,009
on the right is the output from that

00:51:30,229 --> 00:51:37,489
operation so for example for the tenth

00:51:34,009 --> 00:51:40,339
element the key string was this is test

00:51:37,489 --> 00:51:43,549
key string 9 and the elements put into

00:51:40,339 --> 00:51:47,539
that list were the well the strings 90

00:51:43,549 --> 00:51:50,719
that end with 90 1 90 to 93 9 04 @ 9 05

00:51:47,539 --> 00:51:54,079
right so I've been able to allocate

00:51:50,719 --> 00:51:56,390
memory I've been able to use a standard

00:51:54,079 --> 00:51:59,900
string a standard list in a standard map

00:51:56,390 --> 00:52:05,839
which are which exists inside this

00:51:59,900 --> 00:52:08,059
relocatable data buffer now I'm in the

00:52:05,839 --> 00:52:13,699
swap buffers member function which is

00:52:08,059 --> 00:52:14,509
part of my storage model and I'm just

00:52:13,699 --> 00:52:17,539
going to step through a couple

00:52:14,509 --> 00:52:20,179
iterations but you can see here is where

00:52:17,539 --> 00:52:22,579
I'm taking data from the primary segment

00:52:20,179 --> 00:52:25,400
and I'm copying it binary doing a binary

00:52:22,579 --> 00:52:26,929
copy into the shadow segment and then

00:52:25,400 --> 00:52:29,989
I'm swapping the pointers between the

00:52:26,929 --> 00:52:36,049
two backbones and this will go a few

00:52:29,989 --> 00:52:39,890
times and on the right you can see that

00:52:36,049 --> 00:52:41,110
I've printed out the same data after the

00:52:39,890 --> 00:52:43,120
swapping

00:52:41,110 --> 00:52:45,940
I've printed out exactly the same data

00:52:43,120 --> 00:52:48,430
so what I've done in effect is I've

00:52:45,940 --> 00:52:50,280
taken a heap I've made a binary copy and

00:52:48,430 --> 00:52:53,920
relocated it to a different address

00:52:50,280 --> 00:52:55,630
inside the same process and I've been

00:52:53,920 --> 00:52:58,690
able to preserve the class invariance

00:52:55,630 --> 00:53:02,740
and make things like strings lists and

00:52:58,690 --> 00:53:05,350
maps work so if I can do this I can also

00:53:02,740 --> 00:53:07,090
serialize the heap by copying those

00:53:05,350 --> 00:53:09,090
bites the bytes for each segment to a

00:53:07,090 --> 00:53:11,080
file and at some point in the future

00:53:09,090 --> 00:53:13,510
duplicating the layout of memory with

00:53:11,080 --> 00:53:15,180
the backbone in the segments and loading

00:53:13,510 --> 00:53:19,350
those bites back into the segment's

00:53:15,180 --> 00:53:25,440
effectively providing a relocatable heap

00:53:19,350 --> 00:53:25,440
all right so that's it for the demo

00:53:39,010 --> 00:53:51,580
okay good all right so concluding

00:53:44,860 --> 00:53:53,680
comments possible applications well in

00:53:51,580 --> 00:53:55,210
my case I'm sort of these are the three

00:53:53,680 --> 00:53:57,220
things that I'm interested in of course

00:53:55,210 --> 00:53:58,870
I don't have much imagination so I'm

00:53:57,220 --> 00:54:01,180
sure you can probably think of other

00:53:58,870 --> 00:54:04,030
ways that this could be used I'm

00:54:01,180 --> 00:54:05,740
interested in using this as a heap for

00:54:04,030 --> 00:54:08,410
allocating memory for my shared memory

00:54:05,740 --> 00:54:11,710
databases or actually for my databases

00:54:08,410 --> 00:54:13,810
and having them exist either in private

00:54:11,710 --> 00:54:16,600
address space or in shared memory I

00:54:13,810 --> 00:54:18,820
think these could also be useful if one

00:54:16,600 --> 00:54:21,070
wanted to implement a very highly

00:54:18,820 --> 00:54:23,320
instrumented debug allocator I mean

00:54:21,070 --> 00:54:25,660
think about being able to be capture

00:54:23,320 --> 00:54:29,920
information from the pointer interface

00:54:25,660 --> 00:54:32,350
and capture information for every single

00:54:29,920 --> 00:54:34,660
operation that a pointer does whether

00:54:32,350 --> 00:54:36,610
it's being incremented or dereferenced

00:54:34,660 --> 00:54:38,680
or indexed with the pointer interface

00:54:36,610 --> 00:54:40,840
you can capture that information you

00:54:38,680 --> 00:54:42,580
could capture stack information for

00:54:40,840 --> 00:54:45,400
every operation whether it's the pointer

00:54:42,580 --> 00:54:49,480
interface or in the allocation strategy

00:54:45,400 --> 00:54:53,620
or in the storage model or in the

00:54:49,480 --> 00:54:56,110
addressing model as I said before this

00:54:53,620 --> 00:54:57,670
is simply one possible implementation of

00:54:56,110 --> 00:55:00,670
these concepts and there are many ways

00:54:57,670 --> 00:55:03,460
that this could be done in early work I

00:55:00,670 --> 00:55:06,010
actually made the addressing model be a

00:55:03,460 --> 00:55:08,200
type that is nested within the storage

00:55:06,010 --> 00:55:10,000
model and that sort of made the shared

00:55:08,200 --> 00:55:11,830
the reciprocal friendship a little bit

00:55:10,000 --> 00:55:14,790
easier I'm not sure that's the best way

00:55:11,830 --> 00:55:18,040
to do it but you know it's worth a try

00:55:14,790 --> 00:55:21,040
finally this is a work in progress and i

00:55:18,040 --> 00:55:24,010
will say that i've tested this I've done

00:55:21,040 --> 00:55:27,970
some light testing with clang and visual

00:55:24,010 --> 00:55:31,030
c++ and clang and lib c++ is pretty good

00:55:27,970 --> 00:55:35,920
at its allocator aware containers so far

00:55:31,030 --> 00:55:39,370
all my tests pass with visual c++ 2015

00:55:35,920 --> 00:55:42,100
update 3 all of the tests pass except

00:55:39,370 --> 00:55:46,720
for one and that has to do with stood

00:55:42,100 --> 00:55:51,150
map so other than that I think this is

00:55:46,720 --> 00:55:51,150
the end are there any questions

00:55:59,930 --> 00:56:24,000
sir I actually wanted to do this in such

00:56:20,850 --> 00:56:26,790
a way that I did not need to specialized

00:56:24,000 --> 00:56:29,240
allocator traits I wanted to provide an

00:56:26,790 --> 00:56:31,860
interface to allocator traits which was

00:56:29,240 --> 00:56:33,840
close enough to what stood allocator

00:56:31,860 --> 00:56:38,790
provides so that that was not an issue

00:56:33,840 --> 00:56:40,620
uh but there's I don't see any

00:56:38,790 --> 00:56:43,260
performance benefit one way or the other

00:56:40,620 --> 00:56:57,300
it was a nip and implementation decision

00:56:43,260 --> 00:56:58,500
driven by laziness sir so the question

00:56:57,300 --> 00:57:01,500
is how do I deal with binary

00:56:58,500 --> 00:57:04,620
compatibility well I don't deal with it

00:57:01,500 --> 00:57:06,170
per se other than to say as I said in an

00:57:04,620 --> 00:57:08,700
earlier slide that there are

00:57:06,170 --> 00:57:10,710
requirements for the types that need to

00:57:08,700 --> 00:57:12,390
be relocated and there are assumptions

00:57:10,710 --> 00:57:14,160
that are made when you do the

00:57:12,390 --> 00:57:16,110
serialization between the source and

00:57:14,160 --> 00:57:19,020
destination platforms and those

00:57:16,110 --> 00:57:20,850
assumptions are that the platforms on

00:57:19,020 --> 00:57:23,790
the source and destination site are

00:57:20,850 --> 00:57:26,580
basically the same that the class member

00:57:23,790 --> 00:57:28,230
layouts of objects on the source and

00:57:26,580 --> 00:57:30,570
destination sites are exactly the same

00:57:28,230 --> 00:57:34,220
and then i'm using the same object code

00:57:30,570 --> 00:57:37,800
on each side effectively i'm using clang

00:57:34,220 --> 00:57:39,930
381 on the source side and clanging 381

00:57:37,800 --> 00:57:46,640
on the destination side with the same

00:57:39,930 --> 00:57:46,640
compilation settings sir

00:57:49,160 --> 00:57:55,200
well performance is going to be slower

00:57:52,620 --> 00:57:57,360
and in this particular case instead of

00:57:55,200 --> 00:57:59,700
dereferencing a pointer there is an

00:57:57,360 --> 00:58:01,680
indexing operation there is a bit

00:57:59,700 --> 00:58:04,050
masking operation and there's an

00:58:01,680 --> 00:58:06,300
addition operation and then finally when

00:58:04,050 --> 00:58:12,930
that's done a dereferencing operation

00:58:06,300 --> 00:58:15,090
that must be done right so the speed of

00:58:12,930 --> 00:58:18,300
the dereferencing itself is naturally

00:58:15,090 --> 00:58:21,900
going to be slower my experience

00:58:18,300 --> 00:58:24,320
depending on the application is that in

00:58:21,900 --> 00:58:27,510
a lot of circumstances that performance

00:58:24,320 --> 00:58:30,720
decrease sort of gets buried in all the

00:58:27,510 --> 00:58:34,740
other costs and if one is designing and

00:58:30,720 --> 00:58:36,660
if one were to design a container which

00:58:34,740 --> 00:58:38,280
used this scheme if I were going to

00:58:36,660 --> 00:58:42,030
create a new kind of container that used

00:58:38,280 --> 00:58:44,820
this allocator or this this scheme what

00:58:42,030 --> 00:58:46,980
i would do is once i got a pointer back

00:58:44,820 --> 00:58:49,200
from the allocator and had constructed

00:58:46,980 --> 00:58:51,060
the object from that point forward I

00:58:49,200 --> 00:58:52,980
would actually only use the ordinary

00:58:51,060 --> 00:58:54,720
pointer I would use the synthetic

00:58:52,980 --> 00:58:56,760
pointers basically only to carry

00:58:54,720 --> 00:58:59,490
information for allocation and

00:58:56,760 --> 00:59:01,020
de-allocation operations once I had them

00:58:59,490 --> 00:59:03,630
I would convert them to ordinary

00:59:01,020 --> 00:59:05,400
pointers and use them that way except of

00:59:03,630 --> 00:59:07,980
course where you need to store the

00:59:05,400 --> 00:59:10,050
synthetic pointer think about an element

00:59:07,980 --> 00:59:12,990
in a doubly linked list right for this

00:59:10,050 --> 00:59:15,240
to work each each of the two pointers in

00:59:12,990 --> 00:59:18,090
the node of a doubly linked list needs

00:59:15,240 --> 00:59:20,370
to be a synthetic pointer but if I need

00:59:18,090 --> 00:59:21,720
to do operations on that node I might

00:59:20,370 --> 00:59:24,690
convert one of those pointers to an

00:59:21,720 --> 00:59:26,520
ordinary pointer and do it that way so I

00:59:24,690 --> 00:59:29,870
guess the answer is I don't have a good

00:59:26,520 --> 00:59:29,870
answer for you and it depends

00:59:39,230 --> 00:59:43,860
so have the question is have I tried to

00:59:42,510 --> 00:59:47,160
run this test comparing the performance

00:59:43,860 --> 00:59:48,690
of the same containers the same element

00:59:47,160 --> 00:59:51,870
types with the standard container and

00:59:48,690 --> 00:59:55,050
with this demo and the answer to that is

00:59:51,870 --> 01:00:00,800
not yet I do expect a decrease in

00:59:55,050 --> 01:00:00,800
performance but I've not measured it sir

01:00:05,630 --> 01:00:11,190
yes the question is can I describe my

01:00:09,210 --> 01:00:13,140
deallocation implementation and its

01:00:11,190 --> 01:00:15,170
effect and I will tell you right now

01:00:13,140 --> 01:00:17,070
that the allocation and de-allocation

01:00:15,170 --> 01:00:21,150
strategy that I used for this

01:00:17,070 --> 01:00:23,280
demonstration is very simple I have an

01:00:21,150 --> 01:00:25,590
array of bytes and I allocate from the

01:00:23,280 --> 01:00:28,230
bottom and deallocation is a no op I

01:00:25,590 --> 01:00:29,910
call it the leaky allocator I don't

01:00:28,230 --> 01:00:31,800
really care about allocation correctness

01:00:29,910 --> 01:00:34,620
at this point I'm trying to make the

01:00:31,800 --> 01:00:36,450
allocator aware containers work to make

01:00:34,620 --> 01:00:39,180
sure that compilation and linking can

01:00:36,450 --> 01:00:41,610
occur and everything works correctly now

01:00:39,180 --> 01:00:43,050
the idea behind the allocation strategy

01:00:41,610 --> 01:00:45,090
which i think is what you're really

01:00:43,050 --> 01:00:47,100
getting to is that's the piece of the

01:00:45,090 --> 01:00:49,590
puzzle that would allow you to implement

01:00:47,100 --> 01:00:52,110
allocation and de-allocation algorithms

01:00:49,590 --> 01:00:54,450
to improve performance the way you want

01:00:52,110 --> 01:00:56,220
to do that in that improvement whether

01:00:54,450 --> 01:00:59,580
it has to do with locking and unlocking

01:00:56,220 --> 01:01:02,430
or the way that you divide memory into

01:00:59,580 --> 01:01:04,920
chunks or deallocate them to provide to

01:01:02,430 --> 01:01:06,870
minimize fragmentation that's the role

01:01:04,920 --> 01:01:09,540
of the allocation strategy and it would

01:01:06,870 --> 01:01:11,370
it's up to the implementer of that to

01:01:09,540 --> 01:01:13,410
make that work the way you want to I

01:01:11,370 --> 01:01:18,590
chose something very simple because I

01:01:13,410 --> 01:01:18,590
actually wanted to make this work first

01:01:18,800 --> 01:01:23,970
okay well I'm told that this is the end

01:01:21,630 --> 01:01:25,680
of the hour thank you very much for

01:01:23,970 --> 01:01:27,950
coming i greatly appreciate your time

01:01:25,680 --> 01:01:27,950

YouTube URL: https://www.youtube.com/watch?v=FPUBjPYBsGI


