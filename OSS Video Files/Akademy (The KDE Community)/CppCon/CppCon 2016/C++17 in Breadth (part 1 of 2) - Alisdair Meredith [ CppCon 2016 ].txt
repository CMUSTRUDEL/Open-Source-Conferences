Title: C++17 in Breadth (part 1 of 2) - Alisdair Meredith [ CppCon 2016 ]
Publication date: 2016-09-28
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
This talk will cover every feature addition, removal, and change in the next version of the C++ standard, provisionally going by the name C++17. Covering both the language and the library, the coverage of any given feature must necessarily brief. The goal is to come away with an understanding of what each feature is, and why you might want to use it, with an overall impression of how the new language might fit together. It is not intended to be an detailed tutorial on any individual feature, but rather, a jumping off point for further sessions on the topics that seem most interesting.
— 
Alisdair Meredith
Bloomberg LP
Alisdair Meredith is a software developer at BloombergLP in New York, and the C++ Standard Committee Library Working Group chair.

He has been an active member of the C++ committee for just over a decade, and by a lucky co-incidence his first meeting was the kick-off meeting for the project that would become C++11, and also fixed the contents of the original library TR.

He is currently working on the BDE project, BloombergLP's open source libraries that offer a foundation for C++ development, including a standard library implementation supporting the polymorphic allocator model proposed for standardization.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,030 --> 00:00:04,020
okay so we're just gone two o'clock I've

00:00:02,399 --> 00:00:06,870
got the what to try to cover in the next

00:00:04,020 --> 00:00:08,099
two hours so I'm going to get going any

00:00:06,870 --> 00:00:09,120
wait stragglers there's plenty of room

00:00:08,099 --> 00:00:11,880
for people to come in and sit down

00:00:09,120 --> 00:00:13,590
anyway so just to make you what everyone

00:00:11,880 --> 00:00:16,830
thinks are in the right session the

00:00:13,590 --> 00:00:20,400
session is c++ 17 the next c++ standard

00:00:16,830 --> 00:00:21,960
in breadth and not depth so the idea by

00:00:20,400 --> 00:00:24,180
the end of this session is you will know

00:00:21,960 --> 00:00:27,990
absolutely everything that has gone in

00:00:24,180 --> 00:00:29,429
or change with c++ 17 and maybe not a

00:00:27,990 --> 00:00:31,289
whole lot about any of it but you've got

00:00:29,429 --> 00:00:32,669
a good idea about what you want to go

00:00:31,289 --> 00:00:34,079
and see during the rest of the week if

00:00:32,669 --> 00:00:36,390
anyone's talking about any of these

00:00:34,079 --> 00:00:37,860
topics and hopefully you have a fair

00:00:36,390 --> 00:00:40,110
idea of what to do with these things but

00:00:37,860 --> 00:00:42,780
certainly not an in-depth on any

00:00:40,110 --> 00:00:44,989
particular topic those of you who don't

00:00:42,780 --> 00:00:47,700
know me my name is Alistair Meredith I

00:00:44,989 --> 00:00:49,320
currently work for Bloomberg as one of

00:00:47,700 --> 00:00:51,629
their senior developers on their own

00:00:49,320 --> 00:00:53,969
internal standard library and we publish

00:00:51,629 --> 00:00:59,399
that now through the open source bde

00:00:53,969 --> 00:01:01,140
project during the evolution of c++ 14

00:00:59,399 --> 00:01:02,969
hours a library working group share so I

00:01:01,140 --> 00:01:06,240
know a little bit about what went into

00:01:02,969 --> 00:01:07,950
all that we're about to see so I'm going

00:01:06,240 --> 00:01:10,619
to have a quick slide Christopher who's

00:01:07,950 --> 00:01:14,750
aware of how the C++ standards process

00:01:10,619 --> 00:01:17,070
but works in practice so just a

00:01:14,750 --> 00:01:20,250
professional hands quickly to background

00:01:17,070 --> 00:01:21,960
the one slides worth no more why do we

00:01:20,250 --> 00:01:23,869
have a C++ standard in the first place

00:01:21,960 --> 00:01:27,540
this predates me going back to about

00:01:23,869 --> 00:01:29,880
1990 there was a wide variety of

00:01:27,540 --> 00:01:31,619
dialects of C++ emerging is everyone

00:01:29,880 --> 00:01:34,350
like following up on be Ana's work and

00:01:31,619 --> 00:01:35,490
adding their own different extensions so

00:01:34,350 --> 00:01:36,960
it would be really good to have a

00:01:35,490 --> 00:01:39,780
talking shop where people could come

00:01:36,960 --> 00:01:42,090
together and produce a consistent

00:01:39,780 --> 00:01:45,390
dialect in version of that language but

00:01:42,090 --> 00:01:46,619
that hits anti cartel we're disliking in

00:01:45,390 --> 00:01:48,360
the States that lots of companies

00:01:46,619 --> 00:01:51,000
colluding actually you're a seen as a

00:01:48,360 --> 00:01:53,369
bad thing as if you convene under an ISO

00:01:51,000 --> 00:01:56,280
standards process it's an open process

00:01:53,369 --> 00:01:57,630
everyone can come and participate so

00:01:56,280 --> 00:01:59,790
that was the way to go ahead and we

00:01:57,630 --> 00:02:01,710
actually set about creating a C++

00:01:59,790 --> 00:02:02,729
standard that eventually fooled the

00:02:01,710 --> 00:02:05,549
committee that they actually had to

00:02:02,729 --> 00:02:07,560
publish something that's it has been

00:02:05,549 --> 00:02:09,929
quite quite a good thing for us if you

00:02:07,560 --> 00:02:12,750
want to follow what the standards group

00:02:09,929 --> 00:02:13,370
are working on if you google WD 21

00:02:12,750 --> 00:02:15,019
that's

00:02:13,370 --> 00:02:17,810
name of our standards group under the

00:02:15,019 --> 00:02:20,930
ISO process or the last part of our name

00:02:17,810 --> 00:02:22,370
it's quite a long acronym and the other

00:02:20,930 --> 00:02:24,920
place we can go and follow standards

00:02:22,370 --> 00:02:28,519
work now is the ISO CPP org website

00:02:24,920 --> 00:02:30,860
which is intended to be a new community

00:02:28,519 --> 00:02:32,239
knew it was new a while back hopefully

00:02:30,860 --> 00:02:34,640
everyone here will know about it because

00:02:32,239 --> 00:02:36,739
this is one of the outreaches as a

00:02:34,640 --> 00:02:39,140
consequence of creating this website in

00:02:36,739 --> 00:02:41,540
this organization this is intended to be

00:02:39,140 --> 00:02:43,269
the online home and community for C++ at

00:02:41,540 --> 00:02:46,120
large

00:02:43,269 --> 00:02:49,160
so quick history of the C++ standards

00:02:46,120 --> 00:02:50,510
1998 we had the first standard and that

00:02:49,160 --> 00:02:53,260
will took roughly seven years and

00:02:50,510 --> 00:02:56,799
twenty-one meetings then we have the

00:02:53,260 --> 00:02:59,569
2003 standard which was 5 years later

00:02:56,799 --> 00:03:00,920
your spot we significantly slowed down

00:02:59,569 --> 00:03:02,329
the amount of work we were doing at that

00:03:00,920 --> 00:03:04,010
period and that might have set some

00:03:02,329 --> 00:03:06,010
false expectations about how the

00:03:04,010 --> 00:03:08,090
standards process is supposed to work

00:03:06,010 --> 00:03:09,409
this was because we had a false

00:03:08,090 --> 00:03:11,480
understanding of how the standards

00:03:09,409 --> 00:03:13,099
process is supposed to work we thought

00:03:11,480 --> 00:03:14,720
that once you publish a standard you

00:03:13,099 --> 00:03:16,879
weren't allowed to touch it for 5 years

00:03:14,720 --> 00:03:19,370
so we did five years of defect reports

00:03:16,879 --> 00:03:22,010
fixing things and then found out that no

00:03:19,370 --> 00:03:24,380
after five years you have to say we're

00:03:22,010 --> 00:03:25,819
retaining a standard or do or it retires

00:03:24,380 --> 00:03:29,389
and we should have been doing new work

00:03:25,819 --> 00:03:31,910
all that time so 2003 is roughly also

00:03:29,389 --> 00:03:33,739
when I joined the process and for the

00:03:31,910 --> 00:03:37,790
next eight years we started working on

00:03:33,739 --> 00:03:41,720
C++ oh seven eight nine set it's escaped

00:03:37,790 --> 00:03:42,859
in 2011 roughly as you can see similar

00:03:41,720 --> 00:03:44,959
amount of time that went into the

00:03:42,859 --> 00:03:47,389
original standard and I hope you will

00:03:44,959 --> 00:03:50,870
agree that it was a big step forward in

00:03:47,389 --> 00:03:53,359
what you could do with C++ the idioms

00:03:50,870 --> 00:03:55,220
you could use and have a language would

00:03:53,359 --> 00:03:58,000
interact with the broader software

00:03:55,220 --> 00:04:01,609
community

00:03:58,000 --> 00:04:04,280
falling 2 to 2011 standards we wanted to

00:04:01,609 --> 00:04:06,500
start what clearly on the next standard

00:04:04,280 --> 00:04:10,699
and we did not want to have another big

00:04:06,500 --> 00:04:12,230
bang release taking another 10 years so

00:04:10,699 --> 00:04:15,139
the idea was we're going to have a new

00:04:12,230 --> 00:04:18,320
standard round about 2017 and started

00:04:15,139 --> 00:04:20,090
work on that and round about 2014 we

00:04:18,320 --> 00:04:22,880
already had a lot of bug reports and

00:04:20,090 --> 00:04:25,010
defects we wanted to fix so rather than

00:04:22,880 --> 00:04:26,880
say going through the standards process

00:04:25,010 --> 00:04:29,370
you can't add

00:04:26,880 --> 00:04:31,500
new features in something like a bug fix

00:04:29,370 --> 00:04:33,630
technical core agenda which was a 2003

00:04:31,500 --> 00:04:36,540
standard so just to avoid asking that

00:04:33,630 --> 00:04:38,280
questions we said 2014 will continue

00:04:36,540 --> 00:04:40,770
standard it will simplify our paperwork

00:04:38,280 --> 00:04:42,210
and that last meeting everyone dropped

00:04:40,770 --> 00:04:46,080
in any new feature that happened to be

00:04:42,210 --> 00:04:48,140
ready so 2014 was actually a better

00:04:46,080 --> 00:04:51,210
iteration than we were expecting

00:04:48,140 --> 00:04:53,640
2017 another three years later similar

00:04:51,210 --> 00:04:55,620
amount of time should be where we be

00:04:53,640 --> 00:04:57,690
landing hopefully substantially more

00:04:55,620 --> 00:05:00,510
features so if you're looking at the

00:04:57,690 --> 00:05:03,150
evolution from 2011 to 2014 to set your

00:05:00,510 --> 00:05:05,280
expectation for how much of an increment

00:05:03,150 --> 00:05:10,560
we have now hopefully you're going to be

00:05:05,280 --> 00:05:12,930
pleasantly surprised so where are we in

00:05:10,560 --> 00:05:15,060
the C++ seventeen process final slide on

00:05:12,930 --> 00:05:17,280
process sorry either but it's wanted

00:05:15,060 --> 00:05:20,520
together at the last minute we're

00:05:17,280 --> 00:05:22,500
currently in C++ 17 ballot review that

00:05:20,520 --> 00:05:24,870
means that the start of at the end of

00:05:22,500 --> 00:05:27,300
June started July we sent out what we

00:05:24,870 --> 00:05:29,550
would hope to be the C++ 17 candidate

00:05:27,300 --> 00:05:31,050
document for the new standard that's

00:05:29,550 --> 00:05:32,940
going to ice off a ballot we have

00:05:31,050 --> 00:05:34,710
roughly up until sometime in the middle

00:05:32,940 --> 00:05:37,650
of October to send ballot comments back

00:05:34,710 --> 00:05:39,690
to ISO to address any issues and defects

00:05:37,650 --> 00:05:41,040
we think we spot in that standard but no

00:05:39,690 --> 00:05:45,360
new features should be added at this

00:05:41,040 --> 00:05:46,500
point we expect with our experience of

00:05:45,360 --> 00:05:48,150
previous standards that will be have

00:05:46,500 --> 00:05:50,070
another two standards meetings that will

00:05:48,150 --> 00:05:52,290
process and deal with those defect

00:05:50,070 --> 00:05:54,540
reports which means roughly the end of

00:05:52,290 --> 00:05:55,980
first week of March is our second

00:05:54,540 --> 00:05:58,890
meeting we should be sending that back

00:05:55,980 --> 00:06:01,500
to ISO hopefully as our final approved

00:05:58,890 --> 00:06:02,850
standard they will bow at that for a few

00:06:01,500 --> 00:06:05,280
months say in the middle of summer if

00:06:02,850 --> 00:06:06,510
that all goes going according to plan we

00:06:05,280 --> 00:06:08,820
should have a new standard published

00:06:06,510 --> 00:06:10,890
sometime by the end of the year so

00:06:08,820 --> 00:06:12,750
that's where we are in the process it

00:06:10,890 --> 00:06:14,190
does mean everything I'm about to show

00:06:12,750 --> 00:06:16,230
you is subject to change

00:06:14,190 --> 00:06:22,980
we've got this ballot resolution but

00:06:16,230 --> 00:06:24,330
he's substantially factory correct while

00:06:22,980 --> 00:06:25,920
we've been working on sleepers for 17

00:06:24,330 --> 00:06:28,290
just a quick slug we've been working on

00:06:25,920 --> 00:06:30,090
a whole bunch of other things the ones

00:06:28,290 --> 00:06:31,830
in green we worked on well enough and

00:06:30,090 --> 00:06:33,480
early enough that we've actually landed

00:06:31,830 --> 00:06:36,990
those in the new standard those will be

00:06:33,480 --> 00:06:38,820
part of C++ 17 the yellow TS is our

00:06:36,990 --> 00:06:40,440
additional project we've worked on

00:06:38,820 --> 00:06:42,180
we've published them as

00:06:40,440 --> 00:06:45,240
very mental material and hopefully those

00:06:42,180 --> 00:06:47,100
will all be parts of C++ 20 and the ones

00:06:45,240 --> 00:06:49,290
in white are our ongoing projects that

00:06:47,100 --> 00:06:51,600
we're still working on publishing so

00:06:49,290 --> 00:06:53,460
even though we're publishing C++ 17

00:06:51,600 --> 00:06:55,500
there's still a lot of existing ongoing

00:06:53,460 --> 00:07:00,180
work happening in parallel the committee

00:06:55,500 --> 00:07:02,010
is very busy these days again just

00:07:00,180 --> 00:07:04,140
trying to set expectations as to the

00:07:02,010 --> 00:07:06,120
growth of the standard I just page

00:07:04,140 --> 00:07:08,130
counts not necessarily a good guide but

00:07:06,120 --> 00:07:10,680
it gives you again an indication that if

00:07:08,130 --> 00:07:11,970
you look around about 2011 we had a big

00:07:10,680 --> 00:07:14,880
dump of new things coming into the

00:07:11,970 --> 00:07:16,620
standard a new hundred pages in the

00:07:14,880 --> 00:07:19,590
court and the huge growth in the library

00:07:16,620 --> 00:07:21,690
so C++ 11 people like to talk about the

00:07:19,590 --> 00:07:23,430
changes in the language but you can see

00:07:21,690 --> 00:07:25,650
in terms of the standard it was a huge

00:07:23,430 --> 00:07:27,360
addition to the library and it's a

00:07:25,650 --> 00:07:30,720
similar kind of thing happening again in

00:07:27,360 --> 00:07:32,580
2017 you can see we're adding a number

00:07:30,720 --> 00:07:34,290
of pages to the core languages we clean

00:07:32,580 --> 00:07:36,240
up and have lots of features smaller

00:07:34,290 --> 00:07:39,240
features the libraries taken another

00:07:36,240 --> 00:07:42,690
reasonable size change but also it's not

00:07:39,240 --> 00:07:43,650
on the same scale as C++ 11 and if

00:07:42,690 --> 00:07:46,080
you're wondering well there's a small

00:07:43,650 --> 00:07:48,150
page count reduction in the 2014 cool

00:07:46,080 --> 00:07:49,919
language we didn't take things out we

00:07:48,150 --> 00:07:54,180
just use a slightly smaller font in the

00:07:49,919 --> 00:07:58,470
standard so those 2017 pages are far

00:07:54,180 --> 00:07:59,910
more valuable and again just showing

00:07:58,470 --> 00:08:01,710
again the evolution of the standard

00:07:59,910 --> 00:08:03,750
roundabout to the first standard it was

00:08:01,710 --> 00:08:06,060
a fairly even balance between core and

00:08:03,750 --> 00:08:08,370
library in terms of volume of what went

00:08:06,060 --> 00:08:11,190
into the standard but it's been a real

00:08:08,370 --> 00:08:13,020
desire to expand within the library and

00:08:11,190 --> 00:08:15,030
just provide the core language features

00:08:13,020 --> 00:08:17,790
that will allow us to write richer

00:08:15,030 --> 00:08:19,530
libraries so you can see that for 2017

00:08:17,790 --> 00:08:21,240
this will be the first standard where

00:08:19,530 --> 00:08:26,220
the library is actually more than twice

00:08:21,240 --> 00:08:29,930
the size of the core language so what

00:08:26,220 --> 00:08:33,150
we've done with C++ 1717 at the glance

00:08:29,930 --> 00:08:35,640
it builds on C++ 14 which we published

00:08:33,150 --> 00:08:37,320
two years ago as I say it's a

00:08:35,640 --> 00:08:38,580
significant library update you saw from

00:08:37,320 --> 00:08:41,430
the previous page can we're adding

00:08:38,580 --> 00:08:43,440
almost 200 pages to the library and most

00:08:41,430 --> 00:08:45,060
of that's coming through libraries that

00:08:43,440 --> 00:08:46,530
we've already trialed in existing

00:08:45,060 --> 00:08:49,910
technical specifications so they're

00:08:46,530 --> 00:08:52,500
coming already in good shape well tested

00:08:49,910 --> 00:08:54,270
on the language side it's a modest

00:08:52,500 --> 00:08:56,460
change but in total you can see

00:08:54,270 --> 00:08:59,100
roughly we've got we've accepted close

00:08:56,460 --> 00:09:02,850
to 120 proposals so I've got a lot to

00:08:59,100 --> 00:09:04,950
talk about in 120 minutes some of those

00:09:02,850 --> 00:09:06,600
proposals are reasonably large in scope

00:09:04,950 --> 00:09:08,790
some of them are very small just maybe

00:09:06,600 --> 00:09:10,230
changing a word or two but it all adds

00:09:08,790 --> 00:09:13,800
up to the feature set we're going to

00:09:10,230 --> 00:09:15,480
look at as I said most people landing a

00:09:13,800 --> 00:09:19,080
lot of the existing technical

00:09:15,480 --> 00:09:20,430
specification work an ongoing thing that

00:09:19,080 --> 00:09:22,500
happens every release of the standards

00:09:20,430 --> 00:09:24,690
we get a lot of Queen of clean up of the

00:09:22,500 --> 00:09:27,090
existing wording and presentation so the

00:09:24,690 --> 00:09:29,250
standards a lot more precise about

00:09:27,090 --> 00:09:30,900
issues coming in people start playing

00:09:29,250 --> 00:09:33,510
with corner cases we find where the big

00:09:30,900 --> 00:09:36,390
things are standards of specification

00:09:33,510 --> 00:09:39,690
not a library or compiler specifically

00:09:36,390 --> 00:09:40,890
so fixing the specification is a

00:09:39,690 --> 00:09:43,590
slightly more interesting in their

00:09:40,890 --> 00:09:45,570
attorney involved process but we concede

00:09:43,590 --> 00:09:48,240
to clean up and give a much better

00:09:45,570 --> 00:09:52,380
contract between the customer and the

00:09:48,240 --> 00:09:54,060
developer and on the language side as I

00:09:52,380 --> 00:09:56,430
said I don't think I'm seeing any

00:09:54,060 --> 00:09:58,710
significant new idioms if you look back

00:09:56,430 --> 00:10:00,960
at C++ 11 the big things where we had

00:09:58,710 --> 00:10:02,970
move semantics we had a well-defined

00:10:00,960 --> 00:10:05,220
memory model we have lambdas coming in

00:10:02,970 --> 00:10:06,720
there's quite a series of things that

00:10:05,220 --> 00:10:10,920
would fundamentally change the way you

00:10:06,720 --> 00:10:12,570
might program in C++ 17 we have a lot of

00:10:10,920 --> 00:10:13,890
things that make a lot of those idioms

00:10:12,570 --> 00:10:16,590
that we've been introducing over the

00:10:13,890 --> 00:10:18,300
years much easier to use but don't go

00:10:16,590 --> 00:10:22,560
looking for the big new idiom that more

00:10:18,300 --> 00:10:24,150
like we C++ 20 for those of you who have

00:10:22,560 --> 00:10:26,040
been following the process I'm wondering

00:10:24,150 --> 00:10:27,510
where are these things these some of the

00:10:26,040 --> 00:10:30,060
big-ticket items people were hoping to

00:10:27,510 --> 00:10:33,350
land concepts we've got it at at

00:10:30,060 --> 00:10:35,880
publishes at es but it was just a little

00:10:33,350 --> 00:10:39,690
too late in terms of getting experience

00:10:35,880 --> 00:10:41,910
to be landing it directly into C++ 17 if

00:10:39,690 --> 00:10:43,020
this doesn't land in C++ 20 there's a

00:10:41,910 --> 00:10:44,760
lot of people going to be very

00:10:43,020 --> 00:10:46,800
disappointed if you don't know what

00:10:44,760 --> 00:10:48,240
concepts are come back in three years

00:10:46,800 --> 00:10:50,270
you'll be hearing an awful lot about

00:10:48,240 --> 00:10:53,280
them if you haven't heard already

00:10:50,270 --> 00:10:54,870
Cortines was another one that came in a

00:10:53,280 --> 00:10:56,460
very well defined shape because

00:10:54,870 --> 00:10:57,900
Microsoft had been shipping their

00:10:56,460 --> 00:11:00,270
implementation of this language feature

00:10:57,900 --> 00:11:02,520
and they've given us a specification

00:11:00,270 --> 00:11:05,649
that looked pretty much good enough to

00:11:02,520 --> 00:11:07,209
accept the main reason it didn't land is

00:11:05,649 --> 00:11:08,889
there's another idea of co-routines

00:11:07,209 --> 00:11:11,170
happening out the networking development

00:11:08,889 --> 00:11:14,259
side so we've got competing ideas in the

00:11:11,170 --> 00:11:15,970
space so Microsoft you know happily

00:11:14,259 --> 00:11:17,519
gaber's this this work and said okay

00:11:15,970 --> 00:11:20,110
well public is a technical specification

00:11:17,519 --> 00:11:22,569
so we can carry on honing the standards

00:11:20,110 --> 00:11:26,259
process and this will be again ready to

00:11:22,569 --> 00:11:29,709
land very quickly in C++ 20 depending

00:11:26,259 --> 00:11:32,019
upon how the competing proposal goes so

00:11:29,709 --> 00:11:36,759
active work on co-routines but nothing

00:11:32,019 --> 00:11:38,560
landing in 17 so with that let's get

00:11:36,759 --> 00:11:42,399
talking about what actually is going in

00:11:38,560 --> 00:11:43,569
17 quick color code for trying to decode

00:11:42,399 --> 00:11:46,000
my sliders like go through fairly

00:11:43,569 --> 00:11:48,970
quickly something in green is something

00:11:46,000 --> 00:11:50,500
that why didn't C++ 14 or earlier quick

00:11:48,970 --> 00:11:51,879
show of hands who followed what happened

00:11:50,500 --> 00:11:55,540
we see is aware of the differences

00:11:51,879 --> 00:11:57,279
between super plus 14 and C++ 11 just

00:11:55,540 --> 00:11:58,600
got a sense of the audience okay I've

00:11:57,279 --> 00:12:00,819
got two well informed audience that's

00:11:58,600 --> 00:12:02,680
good most of the green stuff is I was

00:12:00,819 --> 00:12:04,240
adding the super plus 14 as them as a

00:12:02,680 --> 00:12:06,639
gradual migration but you're already

00:12:04,240 --> 00:12:10,199
ahead of me on that anything in yellow

00:12:06,639 --> 00:12:13,810
is part of the C++ 17 candidate CD

00:12:10,199 --> 00:12:15,370
things in this funny purpley color they

00:12:13,810 --> 00:12:16,779
were supposed to have landed in the CD

00:12:15,370 --> 00:12:19,329
but due to a couple of last-minute

00:12:16,779 --> 00:12:21,310
editorial problems didn't actually land

00:12:19,329 --> 00:12:23,589
in so we still expect those to be part

00:12:21,310 --> 00:12:24,910
of the public standard but if you look

00:12:23,589 --> 00:12:27,250
at the one we sent out for ballot you'll

00:12:24,910 --> 00:12:28,810
not see those yet and then I'm using

00:12:27,250 --> 00:12:29,949
this funny orange color to say here's

00:12:28,810 --> 00:12:33,130
something that was deprecated

00:12:29,949 --> 00:12:36,910
discouraged removed so can this is the

00:12:33,130 --> 00:12:38,620
bad thing color so first things we did

00:12:36,910 --> 00:12:39,880
starting with the simplest and working

00:12:38,620 --> 00:12:42,850
our way up the scale towards some the

00:12:39,880 --> 00:12:46,029
more interesting features are binding to

00:12:42,850 --> 00:12:48,370
other standards the C++ standard has to

00:12:46,029 --> 00:12:50,920
refer to other standards for some parts

00:12:48,370 --> 00:12:52,959
of its specification so we have the C Y

00:12:50,920 --> 00:12:55,809
C standard specifically the C standard

00:12:52,959 --> 00:12:59,709
library that we have not updated for a

00:12:55,809 --> 00:13:01,660
while so I think C++ 11 finally bound to

00:12:59,709 --> 00:13:04,209
the c99 standard just as C was

00:13:01,660 --> 00:13:06,279
publishing the C 11 standard so having a

00:13:04,209 --> 00:13:07,839
good update to our library to get back

00:13:06,279 --> 00:13:11,259
in sync again with the C standard

00:13:07,839 --> 00:13:14,980
library we're adding a new binding to

00:13:11,259 --> 00:13:16,689
the ISO 80,000 specification which this

00:13:14,980 --> 00:13:17,949
used to be ISO 31 which is about the

00:13:16,689 --> 00:13:18,880
oldest standard we could find to bind

00:13:17,949 --> 00:13:20,290
against this

00:13:18,880 --> 00:13:22,060
certify some mathematical special

00:13:20,290 --> 00:13:24,400
functions so anyone who was following

00:13:22,060 --> 00:13:25,810
the tr1 process back in the day

00:13:24,400 --> 00:13:28,020
that's your heads up for what might be

00:13:25,810 --> 00:13:32,020
coming in though I'd be this afternoon

00:13:28,020 --> 00:13:34,630
we also have a binding to POSIX and to

00:13:32,020 --> 00:13:35,980
the Unicode standard and to the ECMO

00:13:34,630 --> 00:13:37,300
script standard because that's where we

00:13:35,980 --> 00:13:39,910
specify our regular expressions

00:13:37,300 --> 00:13:41,620
libraries and those are in orange

00:13:39,910 --> 00:13:43,270
because I noticed by me now we're

00:13:41,620 --> 00:13:45,010
following our ballot comments all of

00:13:43,270 --> 00:13:46,690
those are currently binding to older at

00:13:45,010 --> 00:13:48,700
a date standards so hopefully those will

00:13:46,690 --> 00:13:54,160
all be updated in the next two months

00:13:48,700 --> 00:13:55,990
next term to meetings so we're rebasing

00:13:54,160 --> 00:13:58,600
on the c11 library what does that mean

00:13:55,990 --> 00:14:00,730
well we're going to update the reference

00:13:58,600 --> 00:14:03,220
of which why we were bringing in by

00:14:00,730 --> 00:14:04,930
specification and part of the

00:14:03,220 --> 00:14:06,790
presentation as I said we've improved

00:14:04,930 --> 00:14:08,650
the quality of the specification itself

00:14:06,790 --> 00:14:10,030
one of the awkward things with the C

00:14:08,650 --> 00:14:12,520
standard library functions and

00:14:10,030 --> 00:14:14,050
structures was we just said look at that

00:14:12,520 --> 00:14:16,210
other document we didn't show you what

00:14:14,050 --> 00:14:18,790
the headers looked like so it's kind of

00:14:16,210 --> 00:14:21,190
tricky piecing together what was what

00:14:18,790 --> 00:14:23,020
what the C parts are the CEO C++

00:14:21,190 --> 00:14:24,820
standard library look like so we've

00:14:23,020 --> 00:14:26,980
actually expanded all those headers in

00:14:24,820 --> 00:14:29,380
line to say this is how you apply the

00:14:26,980 --> 00:14:32,530
mapping but what the C standard library

00:14:29,380 --> 00:14:34,030
headers looked like in C++ we actually

00:14:32,530 --> 00:14:35,830
make it easy to find in the index as

00:14:34,030 --> 00:14:38,320
well as been a fair bit of work on the

00:14:35,830 --> 00:14:39,460
index if you are a standards geek you

00:14:38,320 --> 00:14:41,560
actually like to read the standard

00:14:39,460 --> 00:14:43,300
itself and that's really fixing up all

00:14:41,560 --> 00:14:44,920
the cross references so you don't have

00:14:43,300 --> 00:14:48,450
out-of-date reference this pointing to

00:14:44,920 --> 00:14:48,450
the wrong words in the other document

00:14:50,310 --> 00:14:55,750
one of the questions we had when looking

00:14:52,630 --> 00:14:57,790
at the c standard library is in c 11

00:14:55,750 --> 00:14:59,950
they introduced the notion of optional

00:14:57,790 --> 00:15:02,110
components of a standard which c++

00:14:59,950 --> 00:15:04,450
doesn't really have and one of the

00:15:02,110 --> 00:15:07,600
larger optional components is an XK

00:15:04,450 --> 00:15:11,260
which is the safe or the checked

00:15:07,600 --> 00:15:13,420
standard library api which was some work

00:15:11,260 --> 00:15:15,430
that said all those places where you

00:15:13,420 --> 00:15:16,870
provide a pointer and then there's no

00:15:15,430 --> 00:15:18,460
real way to check whether or not the

00:15:16,870 --> 00:15:20,320
library was given the right range or not

00:15:18,460 --> 00:15:22,300
so you can have buffer overflows running

00:15:20,320 --> 00:15:26,800
off the end too easily there's now an

00:15:22,300 --> 00:15:28,480
underscore s parallel but a surrogate

00:15:26,800 --> 00:15:30,250
version of that library that will give

00:15:28,480 --> 00:15:31,839
you the ability to check the YB the

00:15:30,250 --> 00:15:32,660
ability to check the parameters as they

00:15:31,839 --> 00:15:34,730
come in

00:15:32,660 --> 00:15:36,110
and that's an optional part of the C

00:15:34,730 --> 00:15:38,150
standard library

00:15:36,110 --> 00:15:40,670
we're not importing that into the sea

00:15:38,150 --> 00:15:42,710
stood version that same lab eNOS in the

00:15:40,670 --> 00:15:44,780
standard namespace it's there for

00:15:42,710 --> 00:15:47,120
implementation defined so if your vendor

00:15:44,780 --> 00:15:50,300
ships that in the global namespace as

00:15:47,120 --> 00:15:51,350
part of C they can do so but they just

00:15:50,300 --> 00:15:54,770
tell you whether or not they've done

00:15:51,350 --> 00:15:58,460
that with deprecating some C++ 14

00:15:54,770 --> 00:16:00,080
headers so those that map to the funny C

00:15:58,460 --> 00:16:02,210
language features of how they deal with

00:16:00,080 --> 00:16:06,380
complex numbers some of their generic

00:16:02,210 --> 00:16:08,090
math functions or macros these don't

00:16:06,380 --> 00:16:10,400
really do anything useful in C++ so

00:16:08,090 --> 00:16:11,690
effectively vacuous headers so we're

00:16:10,400 --> 00:16:13,220
just deprecating them they can't just

00:16:11,690 --> 00:16:15,320
follow the pattern of why we introduced

00:16:13,220 --> 00:16:17,780
them and likewise when it came to

00:16:15,320 --> 00:16:19,580
dealing with the memory model stuff the

00:16:17,780 --> 00:16:22,190
way C hasn't supercilious of slightly

00:16:19,580 --> 00:16:25,040
diverged C is doing this directly in

00:16:22,190 --> 00:16:26,900
terms of some key words we didn't import

00:16:25,040 --> 00:16:29,270
those headers when we imported the rest

00:16:26,900 --> 00:16:32,830
of C 11 so that it's probably some

00:16:29,270 --> 00:16:32,830
fairly useful information to be aware of

00:16:33,520 --> 00:16:38,030
moving on vocabulary is an important

00:16:37,010 --> 00:16:39,980
thing when you're talking about

00:16:38,030 --> 00:16:43,700
standards and things coming out of the

00:16:39,980 --> 00:16:45,590
standard and we're getting a wide some

00:16:43,700 --> 00:16:48,260
computing out of some of these terms and

00:16:45,590 --> 00:16:49,700
lots of competing terms for the same

00:16:48,260 --> 00:16:51,350
thing that people would talk about the

00:16:49,700 --> 00:16:53,300
same thing not realizing they were

00:16:51,350 --> 00:16:55,100
talking about the same thing so we've

00:16:53,300 --> 00:16:57,620
got a few new standard terms in the

00:16:55,100 --> 00:16:59,720
standards itself the first one is

00:16:57,620 --> 00:17:01,940
forwarding references years we had this

00:16:59,720 --> 00:17:03,740
wonderful chap called Scott Myers trying

00:17:01,940 --> 00:17:06,740
to make sense of the r-value reference

00:17:03,740 --> 00:17:08,240
in text in C++ 11 finally did kill you

00:17:06,740 --> 00:17:11,150
of the rules that he decided meant

00:17:08,240 --> 00:17:13,310
universal references and then we have

00:17:11,150 --> 00:17:15,290
the rules for almost universal

00:17:13,310 --> 00:17:17,270
references and why universal references

00:17:15,290 --> 00:17:19,100
aren't quite universal and the main

00:17:17,270 --> 00:17:21,560
issue comes down to when you're in a

00:17:19,100 --> 00:17:24,110
template deduction context if I've got

00:17:21,560 --> 00:17:27,350
the double ampersand I'm going to do

00:17:24,110 --> 00:17:29,420
with the duckling as to what that type T

00:17:27,350 --> 00:17:31,550
is and it's typically alternative use to

00:17:29,420 --> 00:17:34,490
an L value or an R value reference as

00:17:31,550 --> 00:17:35,720
opposed to distinct we type T / 3 B did

00:17:34,490 --> 00:17:37,550
you see see I have an hour value

00:17:35,720 --> 00:17:40,070
reference but if I've got if I'm dead

00:17:37,550 --> 00:17:42,740
using off an L value it wouldn't use T

00:17:40,070 --> 00:17:44,210
is an L value reference so rather than

00:17:42,740 --> 00:17:46,430
getting confused with the talk of our

00:17:44,210 --> 00:17:48,440
values and L values in this syntax

00:17:46,430 --> 00:17:50,990
doing something following those rules

00:17:48,440 --> 00:17:52,460
but with a different effect when you

00:17:50,990 --> 00:17:54,620
step back and think about how you're

00:17:52,460 --> 00:17:57,020
using it we're now consistently calling

00:17:54,620 --> 00:17:58,760
those forwarding references and suggest

00:17:57,020 --> 00:18:01,160
that's the vocabulary that the community

00:17:58,760 --> 00:18:02,540
should use now as well so that's what

00:18:01,160 --> 00:18:04,970
the how the standards going to refer to

00:18:02,540 --> 00:18:08,060
this idiom in the future

00:18:04,970 --> 00:18:09,650
another thing that was running around

00:18:08,060 --> 00:18:12,110
with far too many different names with

00:18:09,650 --> 00:18:13,910
now we can initialize data members in

00:18:12,110 --> 00:18:14,990
directly in a class and therefore if you

00:18:13,910 --> 00:18:17,600
don't initialize it in the constructor

00:18:14,990 --> 00:18:20,180
that's of that's the initialization it's

00:18:17,600 --> 00:18:21,350
going to perform and there are a variety

00:18:20,180 --> 00:18:24,880
of names for this running around

00:18:21,350 --> 00:18:27,080
including the the one for NS DMI acronym

00:18:24,880 --> 00:18:30,020
which I think there's non static data

00:18:27,080 --> 00:18:32,000
member initialization so the name we've

00:18:30,020 --> 00:18:33,620
chosen for this just to simplify how

00:18:32,000 --> 00:18:35,120
everyone talking about the same thing in

00:18:33,620 --> 00:18:37,970
the same way our default member

00:18:35,120 --> 00:18:39,500
initializes and family these funny

00:18:37,970 --> 00:18:41,390
things that show up in templates that

00:18:39,500 --> 00:18:43,070
aren't quite templates but follow a lot

00:18:41,390 --> 00:18:45,500
of the rules of templates but dependent

00:18:43,070 --> 00:18:47,620
values and types and so forth we've got

00:18:45,500 --> 00:18:51,320
a template a member of a class template

00:18:47,620 --> 00:18:53,270
a template member of a non class non

00:18:51,320 --> 00:18:54,860
template class and these things that

00:18:53,270 --> 00:18:57,110
kind of look like template should follow

00:18:54,860 --> 00:18:58,970
the template rules we just call them all

00:18:57,110 --> 00:19:01,040
templated entities rather than spit out

00:18:58,970 --> 00:19:02,990
this big long list of special case rules

00:19:01,040 --> 00:19:05,210
all over the place so hopefully that

00:19:02,990 --> 00:19:08,180
will allow us to talk more precisely and

00:19:05,210 --> 00:19:12,590
more simply about some corners of the

00:19:08,180 --> 00:19:14,240
use of templates in the future on the

00:19:12,590 --> 00:19:16,880
library side we're introducing the term

00:19:14,240 --> 00:19:19,130
of contiguous iterators which are almost

00:19:16,880 --> 00:19:21,020
a new iterator category that a

00:19:19,130 --> 00:19:23,150
refinement of the idea of a random

00:19:21,020 --> 00:19:25,610
access iterator that goes one step

00:19:23,150 --> 00:19:27,770
further and says if I take the address

00:19:25,610 --> 00:19:29,300
of the element I'm referring to and take

00:19:27,770 --> 00:19:32,210
the address of something that's further

00:19:29,300 --> 00:19:33,950
on down the same sequence I can do

00:19:32,210 --> 00:19:37,070
simple pointer arithmetic and it's going

00:19:33,950 --> 00:19:39,680
to work because you could easily have

00:19:37,070 --> 00:19:41,780
some kind of clever iterator that's

00:19:39,680 --> 00:19:43,280
doing some bookkeeping between each

00:19:41,780 --> 00:19:45,680
element so although I can do all the

00:19:43,280 --> 00:19:47,750
random access behavior I still can't do

00:19:45,680 --> 00:19:49,090
the pointer arithmetic and we want to

00:19:47,750 --> 00:19:51,620
guarantee in certain circumstances

00:19:49,090 --> 00:19:53,930
classically array basic string and

00:19:51,620 --> 00:19:55,570
vector that those iterators really do

00:19:53,930 --> 00:19:58,610
have the contiguity

00:19:55,570 --> 00:19:59,900
guarantee so it's not quite a new

00:19:58,610 --> 00:20:00,169
iterator category because it doesn't

00:19:59,900 --> 00:20:02,450
have a

00:20:00,169 --> 00:20:04,029
Tagg yet and we're still looking at that

00:20:02,450 --> 00:20:06,830
in the evolution group to say is this

00:20:04,029 --> 00:20:08,419
distinct enough it should have an extra

00:20:06,830 --> 00:20:11,029
tag you can dispatch in your algorithms

00:20:08,419 --> 00:20:12,830
but for now having the term contiguous

00:20:11,029 --> 00:20:14,960
iterator helps you talk about this idea

00:20:12,830 --> 00:20:17,809
much more cleanly and we use it to

00:20:14,960 --> 00:20:19,039
define contiguous containers to clean up

00:20:17,809 --> 00:20:22,970
the guarantee that these three

00:20:19,039 --> 00:20:24,649
containers really do have a contiguous

00:20:22,970 --> 00:20:28,309
range of elements regardless of the

00:20:24,649 --> 00:20:30,769
allocator that you're using another fun

00:20:28,309 --> 00:20:34,249
piece of vocabulary my way was we have

00:20:30,769 --> 00:20:36,109
these universal generators for sequences

00:20:34,249 --> 00:20:37,669
of bits in the standard that the

00:20:36,109 --> 00:20:39,409
mathematical community that gave them to

00:20:37,669 --> 00:20:41,659
us we will call them Universal random

00:20:39,409 --> 00:20:43,340
number generators no saying no no what

00:20:41,659 --> 00:20:45,320
really matters is that from bits a bit

00:20:43,340 --> 00:20:47,330
to bit you get a random sequence of bits

00:20:45,320 --> 00:20:49,399
the fact they happen to group up in

00:20:47,330 --> 00:20:51,200
packages of bits that are going to be

00:20:49,399 --> 00:20:52,309
used as a number it's misleading if you

00:20:51,200 --> 00:20:54,139
call them that because you're talking

00:20:52,309 --> 00:20:56,840
about the groupings being random rather

00:20:54,139 --> 00:20:59,090
than the sequence of bits so hopefully

00:20:56,840 --> 00:21:00,830
using the right name here will lead to

00:20:59,090 --> 00:21:02,539
less confusion as people start trying to

00:21:00,830 --> 00:21:05,749
talk about these universal random bit

00:21:02,539 --> 00:21:10,070
generators because random sequences are

00:21:05,749 --> 00:21:12,409
confusing enough for me to begin with on

00:21:10,070 --> 00:21:15,080
the memory model side this is what a lot

00:21:12,409 --> 00:21:16,669
of concurrency guarantees there was a

00:21:15,080 --> 00:21:19,159
concern that when I'm trying to describe

00:21:16,669 --> 00:21:21,590
the behavior of an algorithm or some

00:21:19,159 --> 00:21:23,359
other parts of the standard although we

00:21:21,590 --> 00:21:25,190
can have the idea of a lock-free

00:21:23,359 --> 00:21:27,230
algorithm we want to guarantee you the

00:21:25,190 --> 00:21:29,450
algorithm continues to make progress and

00:21:27,230 --> 00:21:32,059
it doesn't you know live lock or

00:21:29,450 --> 00:21:36,279
deadlock and having the ability to talk

00:21:32,059 --> 00:21:38,480
about this the concurrency working group

00:21:36,279 --> 00:21:40,549
study sitting down to nail down their

00:21:38,480 --> 00:21:42,350
vocabulary that I'm not the ideal person

00:21:40,549 --> 00:21:43,759
to talk to about this but as I said I'm

00:21:42,350 --> 00:21:45,799
going to do everything that happened in

00:21:43,759 --> 00:21:47,720
the standard we don't have terms that

00:21:45,799 --> 00:21:51,019
can better describe how you would

00:21:47,720 --> 00:21:52,519
document a parallel algorithm to give

00:21:51,019 --> 00:21:54,799
the guarantees as it continues to make

00:21:52,519 --> 00:21:58,970
forward progress to eventually complete

00:21:54,799 --> 00:22:00,529
the operation so we now have a we define

00:21:58,970 --> 00:22:02,869
the term of an execution step that can

00:22:00,529 --> 00:22:06,980
make progress a thread may provide the

00:22:02,869 --> 00:22:08,690
kink so or you can see the words on the

00:22:06,980 --> 00:22:12,480
screen I'm going to run pass because

00:22:08,690 --> 00:22:14,040
this is not my area of expertise but the

00:22:12,480 --> 00:22:16,020
interesting thing to note is that atomic

00:22:14,040 --> 00:22:16,650
operations are not guaranteed to be

00:22:16,020 --> 00:22:19,410
lock-free

00:22:16,650 --> 00:22:21,120
and therefore if you've got an on lock

00:22:19,410 --> 00:22:23,820
free implementation of the atomic

00:22:21,120 --> 00:22:25,290
trapped in the standard library be aware

00:22:23,820 --> 00:22:27,780
that your algorithms even using the lock

00:22:25,290 --> 00:22:30,660
free types sort of the atomic types can

00:22:27,780 --> 00:22:32,490
still block hopefully all the

00:22:30,660 --> 00:22:34,919
implementations I'm aware of provide the

00:22:32,490 --> 00:22:36,179
lock free guarantee on their atomic but

00:22:34,919 --> 00:22:38,309
if your plot if your hardware doesn't

00:22:36,179 --> 00:22:39,840
provide the necessary primitives you

00:22:38,309 --> 00:22:41,520
might have to implement those using a

00:22:39,840 --> 00:22:44,820
mutex and therefore the ability to book

00:22:41,520 --> 00:22:48,360
a chance at that hardware might block is

00:22:44,820 --> 00:22:49,650
still there moving on what time to

00:22:48,360 --> 00:22:53,480
describe is garbage collecting the

00:22:49,650 --> 00:22:53,480
standard deprecating and deleting things

00:22:53,510 --> 00:22:57,780
first of all we remove these things in

00:22:55,590 --> 00:23:00,059
c++ 11 so if you're using any of these

00:22:57,780 --> 00:23:01,110
things in your code today well as soon

00:23:00,059 --> 00:23:02,010
as you upgrade your compiler to

00:23:01,110 --> 00:23:03,690
something that's more modern and

00:23:02,010 --> 00:23:05,730
conforming it got be aware that you

00:23:03,690 --> 00:23:07,350
might hit problems hopefully none of

00:23:05,730 --> 00:23:09,929
these things room widespread use at the

00:23:07,350 --> 00:23:11,640
time we removed them so auto in the

00:23:09,929 --> 00:23:14,040
non-deduction context just to say this

00:23:11,640 --> 00:23:15,360
is a local variable was removed exported

00:23:14,040 --> 00:23:17,070
templates because there were very very

00:23:15,360 --> 00:23:19,950
few shipping implementations and those

00:23:17,070 --> 00:23:22,590
that shipped didn't get widespread use

00:23:19,950 --> 00:23:24,799
and the use we had didn't show it to be

00:23:22,590 --> 00:23:26,970
use useful of features we had hoped for

00:23:24,799 --> 00:23:28,650
access declarations I can't even

00:23:26,970 --> 00:23:30,660
remember what they were but there were a

00:23:28,650 --> 00:23:32,640
syntax that you could use to I think

00:23:30,660 --> 00:23:34,169
mark things public and private in a

00:23:32,640 --> 00:23:37,950
slightly different way than we did back

00:23:34,169 --> 00:23:39,929
in 98 so that was a pre 98 syntax that

00:23:37,950 --> 00:23:42,750
hopefully nobody remembered and we

00:23:39,929 --> 00:23:45,510
quietly removed well one of the ones

00:23:42,750 --> 00:23:48,299
that did catch people out was you could

00:23:45,510 --> 00:23:51,360
have a non-constant binding to a string

00:23:48,299 --> 00:23:53,190
literal which was really kind of

00:23:51,360 --> 00:23:55,370
dangerous so we that was deprecated in

00:23:53,190 --> 00:23:57,360
98 we finally dropped that in 11 and

00:23:55,370 --> 00:23:59,610
when we add you the new braceland

00:23:57,360 --> 00:24:01,230
civilization narrowing conversions were

00:23:59,610 --> 00:24:02,850
banned and therefore some of these

00:24:01,230 --> 00:24:05,309
arranged realizations might have caught

00:24:02,850 --> 00:24:06,720
people at those caught by the picking

00:24:05,309 --> 00:24:08,960
our test drives but we're really trying

00:24:06,720 --> 00:24:13,110
to test the merit of bound stuff

00:24:08,960 --> 00:24:15,660
we've been going to C++ 14 we removed

00:24:13,110 --> 00:24:17,820
one function so not a whole lot of

00:24:15,660 --> 00:24:20,610
cleanup happened in C++ 14 and this

00:24:17,820 --> 00:24:22,860
wasn't even deprecated in C++ C 11 but

00:24:20,610 --> 00:24:24,750
by the time we got round to it C had not

00:24:22,860 --> 00:24:26,400
only deprecated they removed it so we

00:24:24,750 --> 00:24:27,810
went the whole hog and said this

00:24:26,400 --> 00:24:30,840
this function was just too dangerous it

00:24:27,810 --> 00:24:33,840
went straight away so I'm moving on to

00:24:30,840 --> 00:24:40,050
C++ 17 we finally get to remove

00:24:33,840 --> 00:24:43,650
trigraphs which yes you can applaud I'm

00:24:40,050 --> 00:24:45,240
so happy to see that go the register

00:24:43,650 --> 00:24:47,910
keyword or at least the meaning of the

00:24:45,240 --> 00:24:49,890
register keyword was deprecated in C++

00:24:47,910 --> 00:24:52,260
11 because compilers are doing their own

00:24:49,890 --> 00:24:54,570
judgment about how to do register

00:24:52,260 --> 00:24:56,010
allocation so even if you gave the hint

00:24:54,570 --> 00:24:58,620
with the keyword the compilers were

00:24:56,010 --> 00:25:00,360
largely ignoring it and this is really

00:24:58,620 --> 00:25:02,790
nice keyword to have in our back pocket

00:25:00,360 --> 00:25:05,280
to use felt future language extensions

00:25:02,790 --> 00:25:08,310
so we're deprecating are we removing the

00:25:05,280 --> 00:25:10,290
existing use of the register keyword as

00:25:08,310 --> 00:25:12,030
I said that was deprecated in 11 anyway

00:25:10,290 --> 00:25:14,520
but we're keeping the keyword that's

00:25:12,030 --> 00:25:16,380
still reserved for the language to use

00:25:14,520 --> 00:25:19,440
at some point in the future

00:25:16,380 --> 00:25:22,290
and likewise back in 98 operator plus

00:25:19,440 --> 00:25:24,540
plus on bull types was deprecated and

00:25:22,290 --> 00:25:25,950
it's 2sat round there we've got some

00:25:24,540 --> 00:25:28,440
compilers are finally giving deprecation

00:25:25,950 --> 00:25:30,540
warnings having setting deprecated

00:25:28,440 --> 00:25:32,820
status since 98 it was finally time to

00:25:30,540 --> 00:25:34,170
remove that as well because if we don't

00:25:32,820 --> 00:25:36,090
clean things out the standards just

00:25:34,170 --> 00:25:37,430
going to accumulate corner cases of

00:25:36,090 --> 00:25:39,960
interactions indefinitely

00:25:37,430 --> 00:25:43,230
you'll notice that Bulls never had

00:25:39,960 --> 00:25:45,330
operator - - unless you were using C

00:25:43,230 --> 00:25:49,620
where it does something even more

00:25:45,330 --> 00:25:52,170
interesting so additional things that

00:25:49,620 --> 00:25:53,580
we've cleaned up and tidied that might

00:25:52,170 --> 00:25:57,780
break you in the similar manner to a

00:25:53,580 --> 00:25:59,640
removal one of the ones that caught

00:25:57,780 --> 00:26:01,410
people out by surprise was if I'm using

00:25:59,640 --> 00:26:03,840
the new bracelet realization it works

00:26:01,410 --> 00:26:06,810
very well in a lot of places but when I

00:26:03,840 --> 00:26:09,240
try to use it to make a copy so Auto XY

00:26:06,810 --> 00:26:10,740
make me a copy of why actually the views

00:26:09,240 --> 00:26:13,200
to the initialize of list and surprised

00:26:10,740 --> 00:26:14,730
a lot of people it was very confusing so

00:26:13,200 --> 00:26:16,200
we're fixing the rules those rules are

00:26:14,730 --> 00:26:18,870
saying no that's what you expect that

00:26:16,200 --> 00:26:20,700
gives you a copy but that does mean if

00:26:18,870 --> 00:26:22,320
you were genuinely trying to use the

00:26:20,700 --> 00:26:25,560
auto initialization - hey I want to

00:26:22,320 --> 00:26:27,600
initialize the list event that code will

00:26:25,560 --> 00:26:28,920
now be all formed and in the really

00:26:27,600 --> 00:26:30,810
unlucky case where you were trying to

00:26:28,920 --> 00:26:32,760
deduce an initializer with of a single

00:26:30,810 --> 00:26:34,320
argument yeah where some we're changing

00:26:32,760 --> 00:26:36,420
the type on you hopefully your code will

00:26:34,320 --> 00:26:38,940
catch that comparing somewhere else but

00:26:36,420 --> 00:26:39,779
this is a distinct change that be aware

00:26:38,940 --> 00:26:41,340
of we

00:26:39,779 --> 00:26:45,539
think this is mostly going to be fixing

00:26:41,340 --> 00:26:47,099
rather than breaking code another part

00:26:45,539 --> 00:26:49,259
that I'm not sure with this was as much

00:26:47,099 --> 00:26:50,549
that ease the specification but still

00:26:49,259 --> 00:26:52,349
can give a clearer model of how the

00:26:50,549 --> 00:26:54,570
language worked with accepting

00:26:52,349 --> 00:26:56,219
specifications on functions exception

00:26:54,570 --> 00:26:58,320
specifications are now part of the

00:26:56,219 --> 00:27:00,539
function type as opposed to some

00:26:58,320 --> 00:27:03,679
peculiar annotation that sat outside the

00:27:00,539 --> 00:27:06,419
type system but lived in the grammar and

00:27:03,679 --> 00:27:07,859
they interact the you know they decay

00:27:06,419 --> 00:27:12,690
appropriately the way you would hope so

00:27:07,859 --> 00:27:13,830
that you can call the one the which way

00:27:12,690 --> 00:27:15,330
around as it go I always get this wrong

00:27:13,830 --> 00:27:20,179
when I try and talk about it quickly on

00:27:15,330 --> 00:27:20,179
the stage you can call a function that

00:27:20,869 --> 00:27:25,950
has a wide throwing it says it can throw

00:27:24,089 --> 00:27:27,210
you can pass a function I've got a

00:27:25,950 --> 00:27:29,729
function pointer for a function that

00:27:27,210 --> 00:27:31,349
says it can throw anything naturally I

00:27:29,729 --> 00:27:33,869
can pass a function pointer today that's

00:27:31,349 --> 00:27:35,849
got a no except on it whereas I can't go

00:27:33,869 --> 00:27:37,799
the other way around and pass a function

00:27:35,849 --> 00:27:39,479
that can throw through a function

00:27:37,799 --> 00:27:41,729
pointer that says it can't that's caught

00:27:39,479 --> 00:27:44,789
it as a syntax error now so that's

00:27:41,729 --> 00:27:46,139
helping find errors in your code but the

00:27:44,789 --> 00:27:48,419
compatibility goes the right way so

00:27:46,139 --> 00:27:49,919
mostly nothing could break we've got

00:27:48,419 --> 00:27:51,419
this wonderful little example that's

00:27:49,919 --> 00:27:53,070
actually in it in the compatibility

00:27:51,419 --> 00:27:55,499
annex of the standard that says if I'm

00:27:53,070 --> 00:27:56,969
doing a deduction so I've got a temple

00:27:55,499 --> 00:27:58,919
it's going to try to use T to be the

00:27:56,969 --> 00:27:59,969
same thing in this case where I've got

00:27:58,919 --> 00:28:02,309
the functions have slightly different

00:27:59,969 --> 00:28:06,029
accepted specifications it would work in

00:28:02,309 --> 00:28:07,529
14 and will fail to compile in 17 so

00:28:06,029 --> 00:28:10,679
accepted specifications are in the type

00:28:07,529 --> 00:28:13,289
system the old deprecated dynamic

00:28:10,679 --> 00:28:15,269
exception specifications do not enter

00:28:13,289 --> 00:28:17,779
the type system but we didn't manage

00:28:15,269 --> 00:28:30,210
quite yet to take them out the standard

00:28:17,779 --> 00:28:32,789
ISO I hand going up at the front here ok

00:28:30,210 --> 00:28:34,019
so the question is do you have to does

00:28:32,789 --> 00:28:36,749
the signature include the whole

00:28:34,019 --> 00:28:38,460
expression of the no accept but no

00:28:36,749 --> 00:28:40,679
there's no accept expression has to

00:28:38,460 --> 00:28:43,589
evaluate a compile time to true or false

00:28:40,679 --> 00:28:50,210
and it's simply the true false nature is

00:28:43,589 --> 00:28:53,780
what enters the type system additional

00:28:50,210 --> 00:28:56,300
and breakage inheriting constructors

00:28:53,780 --> 00:28:58,780
were feature we introduced in C++ 11 and

00:28:56,300 --> 00:29:01,550
they continue to turn during a small

00:28:58,780 --> 00:29:03,530
variety of corner cases and bug reports

00:29:01,550 --> 00:29:05,990
one of the classic ones was we couldn't

00:29:03,530 --> 00:29:08,210
actually have a inheriting constructor

00:29:05,990 --> 00:29:09,950
for a constructively user C style

00:29:08,210 --> 00:29:12,530
ellipses that just didn't work in the

00:29:09,950 --> 00:29:15,260
grammar nicely so with changing the

00:29:12,530 --> 00:29:16,670
rules to say this should work widely the

00:29:15,260 --> 00:29:19,460
way it worked before but it will clean

00:29:16,670 --> 00:29:22,190
up some some cons just work better for

00:29:19,460 --> 00:29:24,710
you you use the same syntax as you say

00:29:22,190 --> 00:29:27,260
using a colon colon a here but now what

00:29:24,710 --> 00:29:28,760
happens is if I call a constructor

00:29:27,260 --> 00:29:29,930
that's not found in the derived class it

00:29:28,760 --> 00:29:31,790
now says well I've got also got

00:29:29,930 --> 00:29:33,620
constructors in the base class so I

00:29:31,790 --> 00:29:36,170
could just directly call that base class

00:29:33,620 --> 00:29:38,510
constructor and then any members in the

00:29:36,170 --> 00:29:40,100
further derived class just get whatever

00:29:38,510 --> 00:29:41,780
rules that have had if I called say a

00:29:40,100 --> 00:29:43,490
default constructor and haven't provided

00:29:41,780 --> 00:29:45,590
members so things want default

00:29:43,490 --> 00:29:47,630
initialize value initialize use the

00:29:45,590 --> 00:29:50,060
default member initializer however they

00:29:47,630 --> 00:29:52,000
should initialize which is essentially

00:29:50,060 --> 00:29:54,650
with the same behavior you had before

00:29:52,000 --> 00:29:56,000
written in subtly different terms it

00:29:54,650 --> 00:29:58,540
means we're not declaring you

00:29:56,000 --> 00:30:01,000
constructor functions so that

00:29:58,540 --> 00:30:04,310
initialization has to happen somewhere

00:30:01,000 --> 00:30:06,050
other than in calling the constructor so

00:30:04,310 --> 00:30:08,390
it's a slightly different arrangement of

00:30:06,050 --> 00:30:10,640
the code but it should be a cleaner

00:30:08,390 --> 00:30:12,500
model that will be easier to understand

00:30:10,640 --> 00:30:13,730
and it's generally what people wanted

00:30:12,500 --> 00:30:18,710
when they spoke about inheriting

00:30:13,730 --> 00:30:21,200
constructors also on the move removal

00:30:18,710 --> 00:30:23,180
side moving over to the library now Auto

00:30:21,200 --> 00:30:25,610
pointer has finally gone deprecated in

00:30:23,180 --> 00:30:28,790
C++ 11 now we have unique pointer we

00:30:25,610 --> 00:30:31,250
don't need it by first binding second

00:30:28,790 --> 00:30:33,290
member and unary function all these the

00:30:31,250 --> 00:30:35,030
old adaptable function API that relies

00:30:33,290 --> 00:30:37,550
on having special type deaths in your

00:30:35,030 --> 00:30:39,350
classes we've generally got better ways

00:30:37,550 --> 00:30:42,710
of doing these things now with lambda

00:30:39,350 --> 00:30:44,900
expressions and bind so this limited

00:30:42,710 --> 00:30:46,760
functionality was deprecated in C++ 11

00:30:44,900 --> 00:30:51,530
if you're using those functions and

00:30:46,760 --> 00:30:54,380
types they are gone from C++ 17 random

00:30:51,530 --> 00:30:56,570
shuffle was a shuffling function that

00:30:54,380 --> 00:30:58,220
basically used the rand function from

00:30:56,570 --> 00:30:59,990
the c standard library that was not

00:30:58,220 --> 00:31:02,480
particularly well specified to be a good

00:30:59,990 --> 00:31:04,110
random number generator so that was

00:31:02,480 --> 00:31:07,620
deprecated in c++ 14

00:31:04,110 --> 00:31:08,670
and we're removing it from 17 also on

00:31:07,620 --> 00:31:11,670
the whole garbage collection and

00:31:08,670 --> 00:31:13,860
cleanups I'd back in C++ 98 when we

00:31:11,670 --> 00:31:15,480
standardized i/o streams we put in the

00:31:13,860 --> 00:31:16,920
deprecated annex oh and here's some

00:31:15,480 --> 00:31:18,840
other names people have used in some of

00:31:16,920 --> 00:31:21,360
their implementations to describe the

00:31:18,840 --> 00:31:23,010
same things but use the ones we've put

00:31:21,360 --> 00:31:25,230
in the standard instead so we're finally

00:31:23,010 --> 00:31:27,390
just cleaning up these type def so that

00:31:25,230 --> 00:31:28,799
nobody I I've spoken to knows about

00:31:27,390 --> 00:31:30,630
these things apart from people who read

00:31:28,799 --> 00:31:35,100
the obscure deprecated annex of the

00:31:30,630 --> 00:31:37,530
standard and also going is the support

00:31:35,100 --> 00:31:39,840
for type erased allocator in standard

00:31:37,530 --> 00:31:43,140
function and call this one out because

00:31:39,840 --> 00:31:45,630
it wasn't even deprecated in 14 that we

00:31:43,140 --> 00:31:48,150
had many reports that this was a very

00:31:45,630 --> 00:31:52,530
hard if not impossible function to

00:31:48,150 --> 00:31:53,820
implement the this use of allocators we

00:31:52,530 --> 00:31:55,380
don't have any shipping implementation

00:31:53,820 --> 00:31:57,540
that has successfully figured out how to

00:31:55,380 --> 00:31:59,490
implement it so removing it isn't going

00:31:57,540 --> 00:32:01,530
to break any code because anyone relying

00:31:59,490 --> 00:32:03,090
on it was relying on the broken

00:32:01,530 --> 00:32:05,580
implementation anyway this just could

00:32:03,090 --> 00:32:07,440
not work as written so by removing the

00:32:05,580 --> 00:32:10,200
support now we're hoping that we'll make

00:32:07,440 --> 00:32:12,570
it easy to provide a correct

00:32:10,200 --> 00:32:14,610
implementation the need for this kind of

00:32:12,570 --> 00:32:15,900
support for allocators in function and

00:32:14,610 --> 00:32:22,850
similar types at some point in the

00:32:15,900 --> 00:32:25,980
future further clean-up in the library

00:32:22,850 --> 00:32:28,110
we're tightening down our specification

00:32:25,980 --> 00:32:29,820
for the kind of things you can add pass

00:32:28,110 --> 00:32:31,559
the predicate in the standard library

00:32:29,820 --> 00:32:33,870
the general rule was you could pass any

00:32:31,559 --> 00:32:35,760
functor which meant you didn't have to

00:32:33,870 --> 00:32:37,350
console if I the function call operator

00:32:35,760 --> 00:32:39,660
even though everyone knew that was best

00:32:37,350 --> 00:32:40,950
practice the standard library in theory

00:32:39,660 --> 00:32:43,110
we should have gone out of its way to

00:32:40,950 --> 00:32:45,780
support this turns out not quite all

00:32:43,110 --> 00:32:47,490
standard libraries were doing that we

00:32:45,780 --> 00:32:49,470
think the reason this was never there in

00:32:47,490 --> 00:32:52,260
the first place was back in 98 when this

00:32:49,470 --> 00:32:53,940
idiom was first defined people were

00:32:52,260 --> 00:32:55,710
still not as familiar with the idea of

00:32:53,940 --> 00:32:57,900
overloading a function call operator

00:32:55,710 --> 00:32:59,549
never mind Const qualifying it this

00:32:57,900 --> 00:33:02,429
would just looked a bit strange whereas

00:32:59,549 --> 00:33:04,350
now it's a very familiar idiom so we're

00:33:02,429 --> 00:33:05,970
not requiring libraries to do strange

00:33:04,350 --> 00:33:12,570
things and jump through lots of Hoops to

00:33:05,970 --> 00:33:14,070
support unusual code and my favorite new

00:33:12,570 --> 00:33:16,280
clause in the standard library zombie

00:33:14,070 --> 00:33:16,280
names

00:33:16,430 --> 00:33:19,460
the idea here is but I've just told you

00:33:18,260 --> 00:33:20,570
about all those names that we've taken

00:33:19,460 --> 00:33:23,270
out of the library

00:33:20,570 --> 00:33:25,940
zombie names is a cause it says all

00:33:23,270 --> 00:33:27,550
those names remain reserved by this to

00:33:25,940 --> 00:33:30,020
the standard library for previous

00:33:27,550 --> 00:33:31,790
standardization so standard library

00:33:30,020 --> 00:33:33,710
vendors can still provide those things

00:33:31,790 --> 00:33:35,420
as extensions if they want those names

00:33:33,710 --> 00:33:37,550
are reserved to the standard library

00:33:35,420 --> 00:33:39,170
you're not allowed to define macros with

00:33:37,550 --> 00:33:41,330
these names now we've taken these things

00:33:39,170 --> 00:33:43,310
out so this is our standard clause that

00:33:41,330 --> 00:33:46,430
says yeah we have those names once

00:33:43,310 --> 00:33:48,050
they're still ours and yes we can still

00:33:46,430 --> 00:33:52,610
ship these things and support customers

00:33:48,050 --> 00:33:55,550
who don't want to break straight away so

00:33:52,610 --> 00:33:57,260
features deprecated by C++ 14 the

00:33:55,550 --> 00:33:59,420
previous and the random shuffle that not

00:33:57,260 --> 00:34:02,930
only deprecated it we removed it in 17

00:33:59,420 --> 00:34:07,340
so that's going on on the language side

00:34:02,930 --> 00:34:10,100
of deprecations in 17 static cons data

00:34:07,340 --> 00:34:11,600
member definitions are being deprecated

00:34:10,100 --> 00:34:14,690
because we've now added the notion of

00:34:11,600 --> 00:34:16,820
inline variables so in a non variable

00:34:14,690 --> 00:34:19,669
follows the similar kind of rules as an

00:34:16,820 --> 00:34:23,000
inline function so typically if a

00:34:19,669 --> 00:34:26,230
typical use case is a standard sorry the

00:34:23,000 --> 00:34:30,740
static member a data member of a class

00:34:26,230 --> 00:34:32,929
where if we don't it has to be defined

00:34:30,740 --> 00:34:34,850
and it has to be defined at the moment

00:34:32,929 --> 00:34:36,679
in exactly one translation unit that is

00:34:34,850 --> 00:34:39,590
messy when you're dealing with templates

00:34:36,679 --> 00:34:42,169
and we've already gone through these set

00:34:39,590 --> 00:34:43,790
of rules about how inline functions can

00:34:42,169 --> 00:34:45,110
appear in multiple translation units

00:34:43,790 --> 00:34:46,580
multiple headers you can see the thing

00:34:45,110 --> 00:34:49,820
many times as long as they all have an

00:34:46,580 --> 00:34:52,100
identical definition and the preceding

00:34:49,820 --> 00:34:54,770
inline keyword so without doing the same

00:34:52,100 --> 00:34:56,899
thing with inline variables that just

00:34:54,770 --> 00:34:58,250
solves this whole corner of strangeness

00:34:56,899 --> 00:34:59,810
when people are trying to get their

00:34:58,250 --> 00:35:01,910
static data members initialized

00:34:59,810 --> 00:35:03,890
correctly and therefore we deprecated

00:35:01,910 --> 00:35:05,060
the old way that for the Const data

00:35:03,890 --> 00:35:08,150
members where they could be defined in

00:35:05,060 --> 00:35:10,190
the class still legal but deprecated

00:35:08,150 --> 00:35:13,850
because we've hopefully got a superior

00:35:10,190 --> 00:35:16,120
alternative to move to on the library

00:35:13,850 --> 00:35:18,380
side now that we removed all that old

00:35:16,120 --> 00:35:20,720
adaptable function API we've bound first

00:35:18,380 --> 00:35:23,300
bind second and so forth because that we

00:35:20,720 --> 00:35:25,970
deprecated the type def that we had

00:35:23,300 --> 00:35:27,050
there purely to support that the main

00:35:25,970 --> 00:35:28,829
reason that these things weren't

00:35:27,050 --> 00:35:30,809
deprecated before

00:35:28,829 --> 00:35:32,160
have not one not two unary and by

00:35:30,809 --> 00:35:35,219
knowing the gate functions that we

00:35:32,160 --> 00:35:36,690
didn't have an alternative to so that

00:35:35,219 --> 00:35:38,609
was the tail wagging the dog saying

00:35:36,690 --> 00:35:40,859
these keep all those type deaf surround

00:35:38,609 --> 00:35:42,930
forevermore so we've introduced a new

00:35:40,859 --> 00:35:45,420
library function called not fun but

00:35:42,930 --> 00:35:47,999
similar to mmm fun in naming idiom but

00:35:45,420 --> 00:35:50,069
it solves it generalizes the problem of

00:35:47,999 --> 00:35:52,950
the negate errs and letters remove these

00:35:50,069 --> 00:35:55,109
things so they're deprecated for 17 we

00:35:52,950 --> 00:35:59,029
expect to remove them as soon as C++ 20

00:35:55,109 --> 00:36:01,950
opens uncaught exception is a

00:35:59,029 --> 00:36:03,319
particularly poorly specified library

00:36:01,950 --> 00:36:05,489
function that was trying to let you

00:36:03,319 --> 00:36:07,229
detect if you're in the middle of stack

00:36:05,489 --> 00:36:09,930
unwinding given exceptions already in

00:36:07,229 --> 00:36:11,609
flight we're replacing with a better

00:36:09,930 --> 00:36:13,799
function called uncaught exceptions

00:36:11,609 --> 00:36:15,599
plural that will give you a count of how

00:36:13,799 --> 00:36:16,859
many exceptions are in flight and if you

00:36:15,599 --> 00:36:18,930
thought that answer couldn't be more

00:36:16,859 --> 00:36:20,400
than one I've got news for you and I'm

00:36:18,930 --> 00:36:22,109
not going to tell you how because it's

00:36:20,400 --> 00:36:26,130
so much nice and not to have to deal

00:36:22,109 --> 00:36:27,660
with that but yes you can do strange

00:36:26,130 --> 00:36:29,880
things it can have multiple exceptions

00:36:27,660 --> 00:36:32,430
in flight multiple versions of the same

00:36:29,880 --> 00:36:34,619
except in in-flight uncaught exceptions

00:36:32,430 --> 00:36:37,199
will give you an accurate version of

00:36:34,619 --> 00:36:39,209
that count we also have the is literal

00:36:37,199 --> 00:36:41,299
type trait that was not very useful

00:36:39,209 --> 00:36:43,589
because knowing that a type is literal

00:36:41,299 --> 00:36:45,809
doesn't give you any useful information

00:36:43,589 --> 00:36:48,839
a literal type is a type that it's got a

00:36:45,809 --> 00:36:52,249
few rules about trivial constructors and

00:36:48,839 --> 00:36:54,329
has at least one context per constructor

00:36:52,249 --> 00:36:57,059
but is literal doesn't tell you which

00:36:54,329 --> 00:36:59,190
constructor that is so yes I know that

00:36:57,059 --> 00:37:01,259
mytab can perform Const expert

00:36:59,190 --> 00:37:02,789
initialization but unless I know which

00:37:01,259 --> 00:37:05,640
constructor it is that's not useful

00:37:02,789 --> 00:37:07,229
information so it's debatable whether

00:37:05,640 --> 00:37:09,150
the whole term of a literal type is

00:37:07,229 --> 00:37:11,069
useful as currently formulated and

00:37:09,150 --> 00:37:12,509
certainly the type trait wasn't serving

00:37:11,069 --> 00:37:14,219
much of a useful purpose so that's now

00:37:12,509 --> 00:37:17,130
moving to annex D with the other

00:37:14,219 --> 00:37:19,859
deprecated components what also

00:37:17,130 --> 00:37:22,619
duplicating standard iterator this was

00:37:19,859 --> 00:37:24,359
the template class that just has a bunch

00:37:22,619 --> 00:37:25,499
of type def that with the theory make it

00:37:24,359 --> 00:37:27,959
easier for you to define your own

00:37:25,499 --> 00:37:29,849
iterator types all it provides with five

00:37:27,959 --> 00:37:32,729
type depths that now rather than being

00:37:29,849 --> 00:37:35,430
named you need to know the order you put

00:37:32,729 --> 00:37:37,229
them into the template instantiation to

00:37:35,430 --> 00:37:39,390
know what they map to so if anything it

00:37:37,229 --> 00:37:42,779
felt like a step backwards but the whole

00:37:39,390 --> 00:37:46,679
idea of using base classes to forward

00:37:42,779 --> 00:37:48,299
deft doesn't seem to work as well in C++

00:37:46,679 --> 00:37:49,919
11 we've just got cleaning idioms for

00:37:48,299 --> 00:37:52,289
solving a lot of these problems so a

00:37:49,919 --> 00:37:53,819
deprecating standard iterator the

00:37:52,289 --> 00:37:55,829
library traps that were defined in terms

00:37:53,819 --> 00:37:58,259
of that already were cleaned up their

00:37:55,829 --> 00:37:59,969
specification in C++ 14 and the

00:37:58,259 --> 00:38:03,479
recommendation is just put the top gets

00:37:59,969 --> 00:38:06,029
into your type directly raw storage

00:38:03,479 --> 00:38:07,679
iterator with an iterator for iterating

00:38:06,029 --> 00:38:10,589
over raw memory so the I do is I could

00:38:07,679 --> 00:38:12,599
initialize oh you know through this

00:38:10,589 --> 00:38:15,390
storage iterator construct my elements

00:38:12,599 --> 00:38:17,819
into raw memory as I'm going along the

00:38:15,390 --> 00:38:19,019
iterator was didn't work very well once

00:38:17,819 --> 00:38:20,939
we've got a much better defined

00:38:19,019 --> 00:38:22,559
allocator model there's a whole bunch of

00:38:20,939 --> 00:38:23,939
problems with it we're deprecating and

00:38:22,559 --> 00:38:25,079
we have to talk faster cuz i'm running

00:38:23,939 --> 00:38:27,659
out of time and I'm not going to get to

00:38:25,079 --> 00:38:29,640
the library at this rate get temporary

00:38:27,659 --> 00:38:31,949
buffer and returns empty buffer those

00:38:29,640 --> 00:38:33,209
were a optimization point that we put

00:38:31,949 --> 00:38:36,119
into the standard library to say

00:38:33,209 --> 00:38:37,380
sometimes if I can spot that I can do in

00:38:36,119 --> 00:38:38,999
the efficient allocation off the top of

00:38:37,380 --> 00:38:41,400
the stack with information known to the

00:38:38,999 --> 00:38:44,400
implementation I can maybe do a really

00:38:41,400 --> 00:38:46,259
efficient allocation without even having

00:38:44,400 --> 00:38:48,119
to lock memory and go out to the heap

00:38:46,259 --> 00:38:49,619
and so forth and if I can't a can fail

00:38:48,119 --> 00:38:51,569
and you can go up and do a slightly more

00:38:49,619 --> 00:38:53,459
expensive thing but your library candy

00:38:51,569 --> 00:38:54,959
you take this and say if I can get some

00:38:53,459 --> 00:38:56,059
keep memory sometimes I can do something

00:38:54,959 --> 00:39:01,849
better

00:38:56,059 --> 00:39:04,229
these api's didn't get those optimizer

00:39:01,849 --> 00:39:06,539
implementations we didn't have the RAI

00:39:04,229 --> 00:39:09,119
wrappers that you would need to use them

00:39:06,539 --> 00:39:11,459
safely idiomatically so rather than

00:39:09,119 --> 00:39:13,919
clean them up try and fix them and make

00:39:11,459 --> 00:39:16,679
them an optimization opportunity they've

00:39:13,919 --> 00:39:18,209
not been optimized in 25 years so the

00:39:16,679 --> 00:39:19,259
just sitting here will just deprecated

00:39:18,209 --> 00:39:21,299
them and if we really need an

00:39:19,259 --> 00:39:22,679
optimization there will have a cleaner

00:39:21,299 --> 00:39:26,069
better version at some point in the

00:39:22,679 --> 00:39:28,829
future and finally when we had allocated

00:39:26,069 --> 00:39:29,939
rates as the way you perform allocations

00:39:28,829 --> 00:39:32,400
in all your containers and data

00:39:29,939 --> 00:39:34,289
structures as a whole bunch of things in

00:39:32,400 --> 00:39:36,719
standard allocate that would be deduced

00:39:34,289 --> 00:39:38,759
according to the formula of allocated

00:39:36,719 --> 00:39:40,709
trades and indeed you should always

00:39:38,759 --> 00:39:43,049
access alligator's now through the

00:39:40,709 --> 00:39:44,669
allocated tracks interface so having the

00:39:43,049 --> 00:39:46,890
useful parts of standard allocator

00:39:44,669 --> 00:39:49,829
actually part of the allocator that just

00:39:46,890 --> 00:39:52,349
do the default thing left the temptation

00:39:49,829 --> 00:39:54,749
to go and call them directly now clearly

00:39:52,349 --> 00:39:56,039
if you've got c++ l-3 code that's

00:39:54,749 --> 00:39:56,790
exactly what you're doing it was the

00:39:56,039 --> 00:39:58,440
only way to do that

00:39:56,790 --> 00:40:00,420
so we can't remove these features yet

00:39:58,440 --> 00:40:02,610
but we can deprecated them and say yeah

00:40:00,420 --> 00:40:04,110
the intention is we really want to send

00:40:02,610 --> 00:40:07,740
the message allocator trait so the way

00:40:04,110 --> 00:40:10,680
to access your allocators we also got a

00:40:07,740 --> 00:40:12,390
new term going deprecating white when

00:40:10,680 --> 00:40:15,900
you start doing atomic operations we've

00:40:12,390 --> 00:40:17,490
got this memory order consumed but I'm

00:40:15,900 --> 00:40:19,050
not sure if it's not clearly specified

00:40:17,490 --> 00:40:21,240
it's not clearly doing what people want

00:40:19,050 --> 00:40:22,590
it to do today but there's a real intent

00:40:21,240 --> 00:40:25,290
that we should be able to fix this and

00:40:22,590 --> 00:40:26,640
make it work so we're deprecation

00:40:25,290 --> 00:40:28,410
writing it or putting a note in the

00:40:26,640 --> 00:40:30,300
standard rather than officially

00:40:28,410 --> 00:40:32,490
deprecating it's saying please don't use

00:40:30,300 --> 00:40:33,360
this yet but we will make it more usable

00:40:32,490 --> 00:40:36,630
in the future

00:40:33,360 --> 00:40:38,340
so heads up be very cautious using

00:40:36,630 --> 00:40:43,380
memory order consume until we fix it

00:40:38,340 --> 00:40:44,700
hopefully in C++ 20 so new features we

00:40:43,380 --> 00:40:46,770
introduced a bunch of stuff to do with

00:40:44,700 --> 00:40:47,970
literals in C++ 11 I have a good

00:40:46,770 --> 00:40:52,230
audience so I'm not going to dwell on

00:40:47,970 --> 00:40:54,780
that slide in C++ 14 we introduced digit

00:40:52,230 --> 00:40:57,120
separators binary literals and though I

00:40:54,780 --> 00:40:59,420
provided the user-defined literals that

00:40:57,120 --> 00:41:02,610
would therefore actually use the feature

00:40:59,420 --> 00:41:06,930
so for C++ 17 in the world of literals

00:41:02,610 --> 00:41:08,970
we added utf-8 character literals I'll

00:41:06,930 --> 00:41:10,620
admit I'm not sold on the utility of

00:41:08,970 --> 00:41:12,810
this feature but it really cleans up how

00:41:10,620 --> 00:41:15,480
we specify things in the standard as far

00:41:12,810 --> 00:41:18,300
as I can tell a utf-8 literal must be

00:41:15,480 --> 00:41:23,670
ASCII because anything that's above 127

00:41:18,300 --> 00:41:25,320
doesn't fit within a single char and we

00:41:23,670 --> 00:41:27,240
can't have multi character utf-8

00:41:25,320 --> 00:41:29,670
literals whereas we could with a regular

00:41:27,240 --> 00:41:31,080
key R type that promotes it in because

00:41:29,670 --> 00:41:33,690
it's actually an error in the language

00:41:31,080 --> 00:41:34,950
well diagnose it as an error so as far

00:41:33,690 --> 00:41:36,900
as I can tell the only thing you can

00:41:34,950 --> 00:41:39,900
store in the utf-8 character literal is

00:41:36,900 --> 00:41:41,310
an ASCII character but it really cleans

00:41:39,900 --> 00:41:44,370
up the specification for how you have

00:41:41,310 --> 00:41:45,810
prefixes and so forth with characters

00:41:44,370 --> 00:41:47,610
and strings and it's just nice to have

00:41:45,810 --> 00:41:49,560
the syntax mirror each other so Roland

00:41:47,610 --> 00:41:54,090
in your weird exception it's just not a

00:41:49,560 --> 00:41:57,720
very useful feature we also have from c

00:41:54,090 --> 00:42:00,330
99 hexadecimal floating literals for

00:41:57,720 --> 00:42:02,460
folks who it's a bit of a not obscure

00:42:00,330 --> 00:42:03,660
corner but i write test drivers that

00:42:02,460 --> 00:42:05,430
deal with floating-point numbers an

00:42:03,660 --> 00:42:07,440
awful lot and being able to really

00:42:05,430 --> 00:42:09,270
specify that bit pattern rather than

00:42:07,440 --> 00:42:10,500
rely that the parser is going to move

00:42:09,270 --> 00:42:12,690
the decimal text in my

00:42:10,500 --> 00:42:17,060
code transfer it to the binary of the

00:42:12,690 --> 00:42:19,080
hex values I'm expecting having a way to

00:42:17,060 --> 00:42:22,349
prespecified that precisely is really

00:42:19,080 --> 00:42:24,300
handy the thing to note we have an OE X

00:42:22,349 --> 00:42:26,670
in front of the floating-point number

00:42:24,300 --> 00:42:28,170
let me have the mantissa and then when

00:42:26,670 --> 00:42:31,320
you get to the exponent it's followed by

00:42:28,170 --> 00:42:36,060
a P not an E and that number is decimal

00:42:31,320 --> 00:42:36,900
not hex thank you see but that's the

00:42:36,060 --> 00:42:38,760
that's the form of a hexadecimal

00:42:36,900 --> 00:42:40,440
floating point and as far as I'm aware

00:42:38,760 --> 00:42:41,580
most compilers are already shipping this

00:42:40,440 --> 00:42:46,590
because they got this from their C

00:42:41,580 --> 00:42:50,310
implementation after butte c++ 14 added

00:42:46,590 --> 00:42:52,410
the deprecated attribute c++ 17

00:42:50,310 --> 00:42:54,150
therefore as full true which we got from

00:42:52,410 --> 00:42:56,760
the clang folks as a way of saying

00:42:54,150 --> 00:42:58,410
here's a case statement okay that we

00:42:56,760 --> 00:42:59,609
really do want to deliberately fall

00:42:58,410 --> 00:43:01,410
through to the next one please don't

00:42:59,609 --> 00:43:02,430
give me a warning about it and it's

00:43:01,410 --> 00:43:04,140
certainly a very good clear

00:43:02,430 --> 00:43:06,450
documentation to the readers of the code

00:43:04,140 --> 00:43:07,980
that you didn't accidentally miss the

00:43:06,450 --> 00:43:10,170
break and they don't go and fix your

00:43:07,980 --> 00:43:12,750
code by adding it

00:43:10,170 --> 00:43:14,160
no discard is to say this function is

00:43:12,750 --> 00:43:16,020
going to return your result and you

00:43:14,160 --> 00:43:17,790
really should not just drop it on the

00:43:16,020 --> 00:43:19,650
floor and ignore it so it's an

00:43:17,790 --> 00:43:21,359
opportunity for the compiler to give you

00:43:19,650 --> 00:43:22,830
a warning when you don't actually

00:43:21,359 --> 00:43:25,560
consume the result of calling that

00:43:22,830 --> 00:43:27,990
function good example that we've not

00:43:25,560 --> 00:43:29,640
done in the library but we may who knows

00:43:27,990 --> 00:43:31,670
if we'll have ballot comment suggesting

00:43:29,640 --> 00:43:33,450
this the empty function of any container

00:43:31,670 --> 00:43:34,859
somebody who's coming from another

00:43:33,450 --> 00:43:36,210
language we'll look at this this thinks

00:43:34,859 --> 00:43:37,680
this sounds like a command empty the

00:43:36,210 --> 00:43:40,020
container I'll just call empty we move

00:43:37,680 --> 00:43:42,930
on no empty tells you whether or not

00:43:40,020 --> 00:43:45,390
it's empty so why would I there's no

00:43:42,930 --> 00:43:47,550
need to call it unless I'm going to

00:43:45,390 --> 00:43:49,050
examine that result so that's a good way

00:43:47,550 --> 00:43:50,880
to catch errors in code so hopefully

00:43:49,050 --> 00:43:52,349
that will become a common idiom within

00:43:50,880 --> 00:43:54,359
standard containers that people will

00:43:52,349 --> 00:43:57,030
whether the set of mandates or not put

00:43:54,359 --> 00:43:58,380
no discard on the empty function and I'm

00:43:57,030 --> 00:44:03,300
sure you'll find lots of examples of

00:43:58,380 --> 00:44:04,460
your own may be unused is the attribute

00:44:03,300 --> 00:44:06,420
we're going to use for something that

00:44:04,460 --> 00:44:08,700
potentially is not going to be used in

00:44:06,420 --> 00:44:10,619
the following code compilers love to

00:44:08,700 --> 00:44:12,450
give you warnings about this especially

00:44:10,619 --> 00:44:15,420
on function parameters the usual idiom

00:44:12,450 --> 00:44:16,740
is that you cast that to void so unused

00:44:15,420 --> 00:44:18,330
was a popular name for this attribute

00:44:16,740 --> 00:44:20,280
because it's shorter but we like nice

00:44:18,330 --> 00:44:21,540
long names in the standard especially

00:44:20,280 --> 00:44:23,609
when you've got conditional compilation

00:44:21,540 --> 00:44:24,290
that means if this thing goes through an

00:44:23,609 --> 00:44:26,450
assert it

00:44:24,290 --> 00:44:28,130
might or might not be used if you said

00:44:26,450 --> 00:44:30,110
unused you would therefore expect the

00:44:28,130 --> 00:44:32,090
compiler to diagnose if it actually gets

00:44:30,110 --> 00:44:33,860
used because that would be separate so

00:44:32,090 --> 00:44:35,690
maybe on used was a simple general

00:44:33,860 --> 00:44:37,370
all-purpose attribute that describes all

00:44:35,690 --> 00:44:42,770
these situations with the least

00:44:37,370 --> 00:44:44,360
confusion and most characters also I'm

00:44:42,770 --> 00:44:46,970
moving on to attributes we can now put

00:44:44,360 --> 00:44:48,080
attributes on namespaces because that's

00:44:46,970 --> 00:44:51,290
one of the few things that we couldn't

00:44:48,080 --> 00:44:53,090
actually annotate so yeh after use on

00:44:51,290 --> 00:44:54,650
namespaces I'm showing an example of a

00:44:53,090 --> 00:44:56,660
dick namespace lots of people would love

00:44:54,650 --> 00:45:00,080
to deprecate but we haven't deprecated

00:44:56,660 --> 00:45:02,180
yet sorry another place we can now put

00:45:00,080 --> 00:45:05,870
attributes that we couldn't before was

00:45:02,180 --> 00:45:07,580
in enumerators with enumeration so if

00:45:05,870 --> 00:45:10,370
I've got a series of values maybe I've

00:45:07,580 --> 00:45:11,930
got an old enumeration that represents

00:45:10,370 --> 00:45:13,610
flags I don't want to support anymore

00:45:11,930 --> 00:45:15,230
I've come up with a cleaner name for

00:45:13,610 --> 00:45:17,600
something I'm transitioning you can

00:45:15,230 --> 00:45:19,400
actually actively deprecated a specific

00:45:17,600 --> 00:45:21,110
enumeration or any other attribute that

00:45:19,400 --> 00:45:24,800
you wish to use but deprecation is

00:45:21,110 --> 00:45:26,210
always an easy example to provide the

00:45:24,800 --> 00:45:29,510
normative encouragement to compilers to

00:45:26,210 --> 00:45:31,580
say if I see an attribute in using the

00:45:29,510 --> 00:45:34,310
attribute namespace feature that isn't

00:45:31,580 --> 00:45:36,320
mine at my attribute namespace don't

00:45:34,310 --> 00:45:37,820
give a warning about it we've put this

00:45:36,320 --> 00:45:39,110
feature in so that the feature is

00:45:37,820 --> 00:45:40,520
extensible to other libraries yeah

00:45:39,110 --> 00:45:42,800
there's a feature I don't recognize I'm

00:45:40,520 --> 00:45:44,300
not using it but if I nag you about that

00:45:42,800 --> 00:45:47,300
the feature then turns into lots of

00:45:44,300 --> 00:45:48,980
conditional compilation and defeats the

00:45:47,300 --> 00:45:50,630
whole purpose of introducing the idea of

00:45:48,980 --> 00:45:53,180
attribute namespaces in the first place

00:45:50,630 --> 00:45:54,560
and similarly there was an idea that if

00:45:53,180 --> 00:45:56,210
I'm using a lot of attributes from the

00:45:54,560 --> 00:45:57,830
same attribute namespace it would be

00:45:56,210 --> 00:45:59,810
nice be able to have it using and saying

00:45:57,830 --> 00:46:02,060
using this attribute namespace I'm using

00:45:59,810 --> 00:46:04,280
all these attributes so I don't think

00:46:02,060 --> 00:46:06,890
they'll be widely used features but when

00:46:04,280 --> 00:46:10,390
you deal with some heavily annotated

00:46:06,890 --> 00:46:12,470
code that could actually be very useful

00:46:10,390 --> 00:46:15,050
aggregates get a little tweaked up in

00:46:12,470 --> 00:46:17,330
the new standard aggregates can now have

00:46:15,050 --> 00:46:19,580
empty base classes which means you've

00:46:17,330 --> 00:46:22,640
got a class that was not an aggregate in

00:46:19,580 --> 00:46:25,160
C++ 14 because it had an empty base

00:46:22,640 --> 00:46:28,220
class that class 1 now for the aggregate

00:46:25,160 --> 00:46:29,870
initialization rules rather than calling

00:46:28,220 --> 00:46:33,380
the default constructor in the copy

00:46:29,870 --> 00:46:36,440
constructor accordingly that does show

00:46:33,380 --> 00:46:37,700
up in a few corner cases but the

00:46:36,440 --> 00:46:39,140
difference typically

00:46:37,700 --> 00:46:40,460
I can actually initialize all those

00:46:39,140 --> 00:46:42,230
members but when I'm going through

00:46:40,460 --> 00:46:44,200
containers some of the ways I can

00:46:42,230 --> 00:46:48,410
initialize things get a little bit more

00:46:44,200 --> 00:46:50,060
confusing aggregates now they can have

00:46:48,410 --> 00:46:51,860
base classes are not allowed to have

00:46:50,060 --> 00:46:54,020
inherited there are doing Herot

00:46:51,860 --> 00:46:56,720
constructors or have explicit

00:46:54,020 --> 00:46:58,400
constructors how would I have an

00:46:56,720 --> 00:47:02,540
explicit constructor I would inherit oh

00:46:58,400 --> 00:47:03,740
I guess I actually couldn't have an

00:47:02,540 --> 00:47:05,750
explicit constructor while that's in the

00:47:03,740 --> 00:47:07,970
word some folks in the core wording

00:47:05,750 --> 00:47:09,470
found it cool in the case of how they

00:47:07,970 --> 00:47:11,270
could actually get explicit on the

00:47:09,470 --> 00:47:12,740
constructor into an aggregate I'm not

00:47:11,270 --> 00:47:14,720
sure how that could have happened but if

00:47:12,740 --> 00:47:22,460
you miraculously construct it it's still

00:47:14,720 --> 00:47:24,110
not allowed from a really handy problem

00:47:22,460 --> 00:47:26,840
they finally solved aggregates now to

00:47:24,110 --> 00:47:28,610
put copied list initialization so if

00:47:26,840 --> 00:47:31,850
you're using brace initialization and

00:47:28,610 --> 00:47:33,410
trying to copy your aggregate well the

00:47:31,850 --> 00:47:35,420
rules are bracelet wise actually say I

00:47:33,410 --> 00:47:37,430
initialize the first element with the

00:47:35,420 --> 00:47:39,620
first thing in that list in V I don't

00:47:37,430 --> 00:47:41,270
have my first element is not of my own

00:47:39,620 --> 00:47:43,130
type I'm not a recursive data structure

00:47:41,270 --> 00:47:44,900
so that's not valid so actually that

00:47:43,130 --> 00:47:47,630
will now be a copy constructor call

00:47:44,900 --> 00:47:50,770
rather than trying to initialize the

00:47:47,630 --> 00:47:50,770
first element with a copy of yourself

00:47:51,610 --> 00:47:55,460
I've got way too many slides on lambdas

00:47:53,990 --> 00:47:58,910
because lambdas are always fun to talk

00:47:55,460 --> 00:48:00,230
about but this was C++ 14 and you've

00:47:58,910 --> 00:48:03,080
already all told me you're familiar with

00:48:00,230 --> 00:48:06,050
C++ 14 so I'm not dwell on this classic

00:48:03,080 --> 00:48:07,670
example of it I'm trying to do a reverse

00:48:06,050 --> 00:48:10,850
sort algorithm in this case so I'm just

00:48:07,670 --> 00:48:14,270
going to turn round the two elements of

00:48:10,850 --> 00:48:16,210
the container that I'm calling I've got

00:48:14,270 --> 00:48:19,430
to use this funky horrible type def name

00:48:16,210 --> 00:48:21,430
so it's much easier or a I'm suggesting

00:48:19,430 --> 00:48:24,350
that bind would be the answer for this

00:48:21,430 --> 00:48:26,390
even though people love to use lambdas

00:48:24,350 --> 00:48:28,550
because the bounce in fact is really

00:48:26,390 --> 00:48:29,900
short and it's fairly clear as to what

00:48:28,550 --> 00:48:34,070
it's doing I don't have too much other

00:48:29,900 --> 00:48:36,200
text to read but C++ 14 we can do this

00:48:34,070 --> 00:48:38,810
directly using the polymorphic lambda

00:48:36,200 --> 00:48:41,180
feature where we just drop auto in as a

00:48:38,810 --> 00:48:43,990
type and we now have a function template

00:48:41,180 --> 00:48:46,400
that's abusing both arguments for the

00:48:43,990 --> 00:48:48,110
the implicit functor that's in there and

00:48:46,400 --> 00:48:51,470
then we just call the arguments in the

00:48:48,110 --> 00:48:55,210
reverse order the other thing we

00:48:51,470 --> 00:48:57,530
from C++ 14 is lambda capped yeah so

00:48:55,210 --> 00:48:59,869
where I can use an initialization

00:48:57,530 --> 00:49:02,359
expression to initialize the CAPTCHAs

00:48:59,869 --> 00:49:06,290
classic example usually given here is

00:49:02,359 --> 00:49:08,420
I'm calling a sort algorithm I want to

00:49:06,290 --> 00:49:10,280
have the lock over that whole algorithm

00:49:08,420 --> 00:49:12,320
while I'm calling my function so we're

00:49:10,280 --> 00:49:15,109
going to have a lambda I'm going to move

00:49:12,320 --> 00:49:18,530
the unique walk into the lambda to the

00:49:15,109 --> 00:49:20,240
lambda narrow interlock and when the

00:49:18,530 --> 00:49:24,950
algorithm is done it destroys a lambda

00:49:20,240 --> 00:49:26,720
and the lock goes away the main problem

00:49:24,950 --> 00:49:28,990
with that of course is that standard

00:49:26,720 --> 00:49:31,700
library algorithms can arbitrarily copy

00:49:28,990 --> 00:49:33,230
their functors I noticed this just as I

00:49:31,700 --> 00:49:34,640
was preparing these slides and I've just

00:49:33,230 --> 00:49:37,430
started a discussion on the standard

00:49:34,640 --> 00:49:39,349
reflected today that this is a feature

00:49:37,430 --> 00:49:41,900
sounds great but it's not going to work

00:49:39,349 --> 00:49:43,880
with a standard library because most I

00:49:41,900 --> 00:49:45,859
was given was user reference wrapper

00:49:43,880 --> 00:49:47,599
instead so I'll call stud ref but

00:49:45,859 --> 00:49:48,890
holding a reference to something that's

00:49:47,599 --> 00:49:50,690
supposed to be unique walk sounds

00:49:48,890 --> 00:49:52,760
particularly worrying to me if it is

00:49:50,690 --> 00:49:54,740
going to be copied many times everyone

00:49:52,760 --> 00:49:56,450
thinking they on the lock and it adds

00:49:54,740 --> 00:49:57,800
nothing because all right I've got to

00:49:56,450 --> 00:50:01,400
move the lock outside which I already

00:49:57,800 --> 00:50:03,920
have covering the context anyway so the

00:50:01,400 --> 00:50:05,420
classic example of the movie

00:50:03,920 --> 00:50:07,670
neutralization of lambdas I'm not sure

00:50:05,420 --> 00:50:09,710
how useful a move on the lambda is yet

00:50:07,670 --> 00:50:11,000
but hope they will pick this up in the

00:50:09,710 --> 00:50:12,560
library working group and see if there's

00:50:11,000 --> 00:50:14,780
anything more useful we should be doing

00:50:12,560 --> 00:50:19,670
there and that's a whole other from C++

00:50:14,780 --> 00:50:21,880
14 that's not new stuff what am I doing

00:50:19,670 --> 00:50:21,880
here

00:50:22,030 --> 00:50:26,450
this is just the this is pretty much how

00:50:24,859 --> 00:50:28,400
you would write it today is you actually

00:50:26,450 --> 00:50:30,619
you could lock fine-grained on each

00:50:28,400 --> 00:50:32,210
operation or you could just let us say

00:50:30,619 --> 00:50:33,500
on the previous slide lock oh the

00:50:32,210 --> 00:50:38,720
original slide look over the whole

00:50:33,500 --> 00:50:40,430
algorithm outside it and just to kill

00:50:38,720 --> 00:50:41,780
how do these things get we have an

00:50:40,430 --> 00:50:43,250
example in the standard of just

00:50:41,780 --> 00:50:44,720
combining lots of things together and

00:50:43,250 --> 00:50:46,369
saying here's a really awkward set of

00:50:44,720 --> 00:50:47,950
corner cases to think about please don't

00:50:46,369 --> 00:50:50,690
do this

00:50:47,950 --> 00:50:52,339
so see parcels 14 we have the

00:50:50,690 --> 00:50:54,250
polymorphic lambda expressions I just

00:50:52,339 --> 00:50:56,180
showed and the capture initialization

00:50:54,250 --> 00:51:00,230
show of hands Delia said you already

00:50:56,180 --> 00:51:01,849
know all about these for C+ or 17 lambda

00:51:00,230 --> 00:51:03,260
expressions can now be constants per

00:51:01,849 --> 00:51:04,970
which means that there will be literal

00:51:03,260 --> 00:51:05,190
objects you can con state for a little

00:51:04,970 --> 00:51:07,950
while

00:51:05,190 --> 00:51:09,690
to them the language expression itself

00:51:07,950 --> 00:51:12,030
can be executed as a Kong sex poor

00:51:09,690 --> 00:51:14,339
evaluation given the generalized rules

00:51:12,030 --> 00:51:17,579
for context but when things and C++ 14

00:51:14,339 --> 00:51:20,250
that's really handy and one of the other

00:51:17,579 --> 00:51:22,800
things that was problematic in C++ 17

00:51:20,250 --> 00:51:24,930
was capturing a cut if you capture this

00:51:22,800 --> 00:51:27,270
you capture a pointer value and if I

00:51:24,930 --> 00:51:28,770
wanted to actually make a copy of an

00:51:27,270 --> 00:51:31,800
object or specifically this Copic with

00:51:28,770 --> 00:51:34,260
the star this it the syntax around that

00:51:31,800 --> 00:51:35,609
was possible but very convoluted so

00:51:34,260 --> 00:51:37,410
we've actually got a very simple way of

00:51:35,609 --> 00:51:39,210
just putting a star this and to capture

00:51:37,410 --> 00:51:44,460
a copy of the object rather than a

00:51:39,210 --> 00:51:45,839
reference through the list pointer and

00:51:44,460 --> 00:51:47,430
okay I'm I'll be ahead of where I was

00:51:45,839 --> 00:51:49,530
going to be I've spoken myself too fast

00:51:47,430 --> 00:51:51,960
this was roughly about my breakpoint so

00:51:49,530 --> 00:51:54,540
I'll be a little bit I can slow down a

00:51:51,960 --> 00:51:57,180
little bit for the next second template

00:51:54,540 --> 00:51:59,579
features C++ 14 we added variable

00:51:57,180 --> 00:52:02,460
templates so the idea here is I've got

00:51:59,579 --> 00:52:03,810
PI and if I want to have this is a

00:52:02,460 --> 00:52:05,490
classic example pie I'll have it at

00:52:03,810 --> 00:52:08,310
various accuracies different frequency

00:52:05,490 --> 00:52:10,650
of representation for float double long

00:52:08,310 --> 00:52:12,690
double and use specializations to have

00:52:10,650 --> 00:52:15,089
my preferred representation of Pi in

00:52:12,690 --> 00:52:16,890
that resolution rather than just relying

00:52:15,089 --> 00:52:21,569
on part in the long number and rounding

00:52:16,890 --> 00:52:23,040
accordingly one of the awkward cases for

00:52:21,569 --> 00:52:25,380
seventeen that we finally got round to

00:52:23,040 --> 00:52:27,869
just an irregularity in the C++ grammar

00:52:25,380 --> 00:52:29,579
whereas most places in templates we've

00:52:27,869 --> 00:52:31,619
got the option of using class or type

00:52:29,579 --> 00:52:34,079
name and the seams to your feeling that

00:52:31,619 --> 00:52:35,880
type name is more of a C++ ething line

00:52:34,079 --> 00:52:37,260
class so there's been a general idiom at

00:52:35,880 --> 00:52:39,420
people have moved towards using type

00:52:37,260 --> 00:52:42,119
name but when they have a template

00:52:39,420 --> 00:52:44,750
template parameter so I've got trying to

00:52:42,119 --> 00:52:47,040
have a class template of type X called X

00:52:44,750 --> 00:52:48,930
the ground I didn't support using type

00:52:47,040 --> 00:52:50,130
name there it had to be class so we're

00:52:48,930 --> 00:52:52,170
changing the one part of the grammar

00:52:50,130 --> 00:52:59,660
that required class rather than type

00:52:52,170 --> 00:53:03,180
game yes yeah and going up okay

00:52:59,660 --> 00:53:05,040
another again man your future just doing

00:53:03,180 --> 00:53:07,980
what's a queen up Napa seventeen we've

00:53:05,040 --> 00:53:09,510
got the feature of I'm trying to have a

00:53:07,980 --> 00:53:11,849
template that's going to integral

00:53:09,510 --> 00:53:14,490
constants is the classic example where

00:53:11,849 --> 00:53:16,290
I'm going to have a constant but I've

00:53:14,490 --> 00:53:18,810
also got to name the type of a constant

00:53:16,290 --> 00:53:20,910
I can't I want to give you one thing

00:53:18,810 --> 00:53:22,320
the constant value but end up having a

00:53:20,910 --> 00:53:23,640
template parameter with two because

00:53:22,320 --> 00:53:26,430
they've got to say what the type is as

00:53:23,640 --> 00:53:28,050
well as the value of the constant as I

00:53:26,430 --> 00:53:29,910
can see what type what what the type is

00:53:28,050 --> 00:53:33,030
it's in the constant so we've got this

00:53:29,910 --> 00:53:36,120
new template Auto n syntax that as you

00:53:33,030 --> 00:53:40,080
can see what the use n is both of type

00:53:36,120 --> 00:53:41,370
end and an int with that value so if we

00:53:40,080 --> 00:53:44,810
were to go back in time we might have

00:53:41,370 --> 00:53:48,090
implemented integral constant this way

00:53:44,810 --> 00:53:50,160
neat new feature that's why I have on

00:53:48,090 --> 00:53:52,710
this slide I put it in purple because

00:53:50,160 --> 00:53:54,270
when I went to trying give an example of

00:53:52,710 --> 00:53:56,550
this I went let's go back and look at

00:53:54,270 --> 00:53:58,110
the the paper that was adopted for this

00:53:56,550 --> 00:53:59,220
now actually although I have this down

00:53:58,110 --> 00:54:00,780
on the list of things we've done I

00:53:59,220 --> 00:54:02,580
couldn't find a paper trace that said

00:54:00,780 --> 00:54:04,620
what the feature is is possible it's

00:54:02,580 --> 00:54:06,960
come in through a library defect report

00:54:04,620 --> 00:54:08,700
it's possible that I've just fooled

00:54:06,960 --> 00:54:10,410
myself and this one didn't happen so

00:54:08,700 --> 00:54:12,330
take this one with a big grain of salt

00:54:10,410 --> 00:54:14,790
but there's the idea of it when I've got

00:54:12,330 --> 00:54:16,560
literal types we can expanded the idea

00:54:14,790 --> 00:54:19,350
of what nan type template parameters to

00:54:16,560 --> 00:54:21,930
be to allow beyond just integers and

00:54:19,350 --> 00:54:23,790
pointers here I particularly wanted to

00:54:21,930 --> 00:54:25,080
look at that to see what you know if I'm

00:54:23,790 --> 00:54:27,180
using a floating point there what are

00:54:25,080 --> 00:54:29,280
the rules for matching Nan's and so

00:54:27,180 --> 00:54:31,560
forth but because I couldn't find the

00:54:29,280 --> 00:54:32,760
actual paper trail I'm no longer as

00:54:31,560 --> 00:54:34,830
convinced as I was when they put the

00:54:32,760 --> 00:54:36,480
slides together that made the final cut

00:54:34,830 --> 00:54:42,390
and you'd have to go back and be

00:54:36,480 --> 00:54:44,190
research my notes I'm afraid so one of

00:54:42,390 --> 00:54:47,730
the big features coming to the template

00:54:44,190 --> 00:54:50,730
feature facilities of C++ 17 is if Const

00:54:47,730 --> 00:54:52,710
expert the idea here is the condition I

00:54:50,730 --> 00:54:54,630
passed if Const X but is going to be

00:54:52,710 --> 00:54:56,310
some code that you value eights at

00:54:54,630 --> 00:54:58,500
compile time is a constant expression

00:54:56,310 --> 00:55:00,270
and then which of the two branches of

00:54:58,500 --> 00:55:04,980
code you have got the if-else is

00:55:00,270 --> 00:55:07,350
actually compiled is chosen so if I've

00:55:04,980 --> 00:55:09,870
got an expression that isn't going to

00:55:07,350 --> 00:55:12,300
compile on the elf on the under the if

00:55:09,870 --> 00:55:13,980
branch normally what you'd have to do is

00:55:12,300 --> 00:55:15,660
you have to have partial specializations

00:55:13,980 --> 00:55:17,310
or class templates or overloads of

00:55:15,660 --> 00:55:19,710
function templates you go to a very

00:55:17,310 --> 00:55:21,960
indirect idiom just to jump around the

00:55:19,710 --> 00:55:24,990
fact that I've done the test I know

00:55:21,960 --> 00:55:26,970
whether or not this grammar is good too

00:55:24,990 --> 00:55:28,740
because under here is going to match the

00:55:26,970 --> 00:55:30,690
name will look up rules and be a valid

00:55:28,740 --> 00:55:32,130
expression and I've got something else I

00:55:30,690 --> 00:55:34,350
want to do if it isn't

00:55:32,130 --> 00:55:36,630
I want to write that cleanly in one

00:55:34,350 --> 00:55:38,760
place like the example here rather than

00:55:36,630 --> 00:55:40,350
have an indirection from in directing

00:55:38,760 --> 00:55:41,910
function that goes into an overload set

00:55:40,350 --> 00:55:44,730
that dispatch is accordingly perhaps

00:55:41,910 --> 00:55:46,440
with some enable ifs it was really messy

00:55:44,730 --> 00:55:50,460
so this is going to clean up an awful

00:55:46,440 --> 00:55:55,890
lot of obscure template code that could

00:55:50,460 --> 00:55:58,020
be written much more directly all the

00:55:55,890 --> 00:56:00,810
expressions were popular request for

00:55:58,020 --> 00:56:03,510
very attic templates where I've got its

00:56:00,810 --> 00:56:05,550
parameter pack of things and the

00:56:03,510 --> 00:56:06,900
examples I'm using here I've got the

00:56:05,550 --> 00:56:10,020
street counter folding the standard the

00:56:06,900 --> 00:56:12,750
left fold the right fold and the the

00:56:10,020 --> 00:56:13,710
binary fold these terms are great if

00:56:12,750 --> 00:56:15,390
you're familiar with functional

00:56:13,710 --> 00:56:16,950
programming everything I know about

00:56:15,390 --> 00:56:19,290
functional programming I learned by

00:56:16,950 --> 00:56:21,450
reverse engineering from C++ templates

00:56:19,290 --> 00:56:23,130
so I don't know the vocabulary but if

00:56:21,450 --> 00:56:26,310
you know the vocabulary these are the

00:56:23,130 --> 00:56:28,440
terms you're looking for otherwise read

00:56:26,310 --> 00:56:30,900
the syntax and hopefully become fairly

00:56:28,440 --> 00:56:33,720
clear what's happening we've got a left

00:56:30,900 --> 00:56:36,030
hold on double ampersand I'm going to do

00:56:33,720 --> 00:56:37,680
a conjunction of every expression in the

00:56:36,030 --> 00:56:40,230
pack expand engine and get true or false

00:56:37,680 --> 00:56:41,940
at the end it does follow the

00:56:40,230 --> 00:56:44,880
traditional short-circuiting rules when

00:56:41,940 --> 00:56:48,120
it evaluates all those expressions but

00:56:44,880 --> 00:56:49,800
it also has to instantiate all those

00:56:48,120 --> 00:56:52,140
expressions in the parameter pack before

00:56:49,800 --> 00:56:53,100
it starts evaluating them so if you're

00:56:52,140 --> 00:56:55,020
looking for a short-circuit evaluation

00:56:53,100 --> 00:56:57,150
that says because I know that the third

00:56:55,020 --> 00:56:58,800
one was true I don't need to worry about

00:56:57,150 --> 00:57:00,300
whether or not the fifth or sixth thing

00:56:58,800 --> 00:57:03,120
in the pack is going to compile

00:57:00,300 --> 00:57:04,560
correctly or not because lookup fails no

00:57:03,120 --> 00:57:10,580
you still have to instantiate the whole

00:57:04,560 --> 00:57:10,580
pack but it will combine accordingly

00:57:13,490 --> 00:57:17,880
another popular feature is requesting

00:57:15,810 --> 00:57:19,980
for a long time and we just didn't quite

00:57:17,880 --> 00:57:21,210
know how to specify in standardise we

00:57:19,980 --> 00:57:23,580
think we've got it right now and this

00:57:21,210 --> 00:57:26,130
came in right on the deadline of c++ 17

00:57:23,580 --> 00:57:28,260
is deducing templates from their

00:57:26,130 --> 00:57:30,270
constructors so I've got a class

00:57:28,260 --> 00:57:33,390
template and it's got a template

00:57:30,270 --> 00:57:35,040
constructor in there depending on how I

00:57:33,390 --> 00:57:36,900
call that constructor I could be able to

00:57:35,040 --> 00:57:39,390
do use the actual parameters for the

00:57:36,900 --> 00:57:40,850
class itself so we've got an example I'm

00:57:39,390 --> 00:57:42,690
trying to say I'm going to have a pair

00:57:40,850 --> 00:57:44,550
this would be an alternative actually

00:57:42,690 --> 00:57:45,960
coin a mate pair function I'm going to

00:57:44,550 --> 00:57:49,250
initialize it with 42 you

00:57:45,960 --> 00:57:51,300
you in hello world is a string there for

00:57:49,250 --> 00:57:52,920
just having standard pair and then these

00:57:51,300 --> 00:57:55,349
things in the curly brackets it now

00:57:52,920 --> 00:57:57,060
knows I'm trying to D dousset I prepare

00:57:55,349 --> 00:57:59,310
I find the only constructor that can

00:57:57,060 --> 00:58:01,950
match and from that I can did use that

00:57:59,310 --> 00:58:06,750
for pair T and u T was an unsigned int

00:58:01,950 --> 00:58:08,490
and you had to be a string and for those

00:58:06,750 --> 00:58:11,070
cases where it's not immediately obvious

00:58:08,490 --> 00:58:13,170
from the template itself we can we have

00:58:11,070 --> 00:58:15,599
outside the class a deduction guide that

00:58:13,170 --> 00:58:16,980
can give the direction so in this case

00:58:15,599 --> 00:58:18,510
I'm going to call the container

00:58:16,980 --> 00:58:21,510
constructor that takes a pair of

00:58:18,510 --> 00:58:23,760
iterators but the iterators are not the

00:58:21,510 --> 00:58:25,410
type of a container element they refer

00:58:23,760 --> 00:58:27,420
to the container element so when I call

00:58:25,410 --> 00:58:29,880
that and then I'm doing a deduction I'm

00:58:27,420 --> 00:58:31,500
did using the iterator type and the

00:58:29,880 --> 00:58:34,500
different guide says well I'm a

00:58:31,500 --> 00:58:36,720
container whose element type is the

00:58:34,500 --> 00:58:39,900
value type of the iterator that I can

00:58:36,720 --> 00:58:41,460
find in directed rates and that Paul

00:58:39,900 --> 00:58:43,440
lets me did use that for the container

00:58:41,460 --> 00:58:45,210
I've got container event because I have

00:58:43,440 --> 00:58:48,630
a sequence of n that I'm passing through

00:58:45,210 --> 00:58:50,839
iterators and I think this is probably

00:58:48,630 --> 00:58:54,380
the place I should be calling a pause

00:58:50,839 --> 00:58:54,380

YouTube URL: https://www.youtube.com/watch?v=22jIHfvelZk


