Title: CppCon 2016: David Schwartz “Developing Blockchain Software”
Publication date: 2016-09-26
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
This talk will explain what public blockchain systems like Bitcoin and Ripple are, the unique challenges of developing software for them, and how C++ helps to meet these challenges. 

Security issues are paramount. Blockchain systems are open source, have large attack surfaces, and can cause significant financial damage if they have exploitable defects. Performance and scalability are also major concerns. 

C++ provides a unique balance that helps meet these challenges. The language's design makes it possible to catch bugs at compile time, write modular code that can be tested, develop flexible data structures and manage resources. Yet, where performance is critical, it does not obscure what your code is making the computer actually do. 

The primary purpose of the talk is to explain what blockchains are, increase understanding of the unusual challenges developers of blockchain software experience, and to demonstrate why C++ is a good choice to address them. 
— 
David Schwartz is the Chief Cryptographer of Ripple, a distributed payment network. Also known as "JoelKatz", he is a respected voice in the crypto-currency community. David has also developed secure messaging and cloud storage software for government and military applications.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:04,740
it's a pleasure to be here today thanks

00:00:01,949 --> 00:00:06,569
to Brice and John thank you all for

00:00:04,740 --> 00:00:07,890
coming how many of you know what a

00:00:06,569 --> 00:00:09,780
blockchain is how many you've heard the

00:00:07,890 --> 00:00:11,820
term knows something about it a couple

00:00:09,780 --> 00:00:13,559
of hands anyone consider themselves a

00:00:11,820 --> 00:00:15,599
blockchain expert think they know it

00:00:13,559 --> 00:00:17,660
really well that's great because you're

00:00:15,599 --> 00:00:19,560
all going to be by the end of this talk

00:00:17,660 --> 00:00:21,029
really I'm not kidding I know you guys

00:00:19,560 --> 00:00:22,859
are laughing that's not that's not funny

00:00:21,029 --> 00:00:24,449
I do have one one thing to ask though if

00:00:22,859 --> 00:00:26,490
any of you have looked at my slides

00:00:24,449 --> 00:00:29,119
ahead of time please still laugh at my

00:00:26,490 --> 00:00:31,529
jokes it's important for my self-esteem

00:00:29,119 --> 00:00:33,270
so I'm the chief cryptographer a triple

00:00:31,529 --> 00:00:34,829
and I was one of the original architects

00:00:33,270 --> 00:00:36,780
of the rippled consensus ledger which is

00:00:34,829 --> 00:00:40,590
a blockchain I'm known as joe katz

00:00:36,780 --> 00:00:42,629
inaudible online communities the company

00:00:40,590 --> 00:00:44,190
I work for is ripple the global leader

00:00:42,629 --> 00:00:46,320
and distributed financial technology

00:00:44,190 --> 00:00:47,969
we're working on allowing people to move

00:00:46,320 --> 00:00:52,949
money the way they move information

00:00:47,969 --> 00:00:54,629
today the internet of value in

00:00:52,949 --> 00:00:56,070
distributed financial technology to

00:00:54,629 --> 00:00:58,320
allow banks and financial institutions

00:00:56,070 --> 00:00:59,899
to transact directly rather than going

00:00:58,320 --> 00:01:03,270
through the correspondent banking system

00:00:59,899 --> 00:01:05,640
and we have 135 team members 2/3

00:01:03,270 --> 00:01:07,530
engineers a lot of experience in

00:01:05,640 --> 00:01:09,000
different fields and main offices in San

00:01:07,530 --> 00:01:11,130
Francisco offices New York City London

00:01:09,000 --> 00:01:12,810
Sydney and Luxembourg we're developing

00:01:11,130 --> 00:01:16,470
blockchain software and C plus boss have

00:01:12,810 --> 00:01:18,390
been doing so since 2011 so we got a

00:01:16,470 --> 00:01:20,700
vast array of customers and partners

00:01:18,390 --> 00:01:23,939
working with major banks to move money

00:01:20,700 --> 00:01:27,390
more efficiently so blockchains what are

00:01:23,939 --> 00:01:29,700
they what are they good for block chains

00:01:27,390 --> 00:01:32,579
records state and they record history

00:01:29,700 --> 00:01:35,549
history past state state is modified by

00:01:32,579 --> 00:01:37,350
transactions a transaction to command

00:01:35,549 --> 00:01:38,939
some change in the state and the

00:01:37,350 --> 00:01:41,369
important thing is that transactions are

00:01:38,939 --> 00:01:43,500
eventually agreed on so if you transfer

00:01:41,369 --> 00:01:45,420
a toget token that represents some value

00:01:43,500 --> 00:01:49,140
everybody will eventually agree that

00:01:45,420 --> 00:01:50,640
that value was transferred assets the

00:01:49,140 --> 00:01:52,020
things that block chains manage funds

00:01:50,640 --> 00:01:53,670
whatever they are are controlled by

00:01:52,020 --> 00:01:56,490
identities which are represented by

00:01:53,670 --> 00:01:58,469
public keys they prove their authority

00:01:56,490 --> 00:02:00,180
by digital signatures so a transaction

00:01:58,469 --> 00:02:02,460
is signed with a digital signature that

00:02:00,180 --> 00:02:04,380
connects it to an identity the integrity

00:02:02,460 --> 00:02:06,329
of the blockchain is protected by secure

00:02:04,380 --> 00:02:08,340
hashes and what that means is we can

00:02:06,329 --> 00:02:09,899
communicate a secure hash and then we

00:02:08,340 --> 00:02:11,970
can follow a hash chain to find the

00:02:09,899 --> 00:02:13,740
history of the blockchain

00:02:11,970 --> 00:02:15,240
well boy that sounds an awful lot like

00:02:13,740 --> 00:02:16,740
something you guys probably know a lot

00:02:15,240 --> 00:02:18,390
about right I mean that's a database

00:02:16,740 --> 00:02:20,910
database to store information they have

00:02:18,390 --> 00:02:22,980
transactions that change their state is

00:02:20,910 --> 00:02:24,900
a blockchain just a database well not

00:02:22,980 --> 00:02:26,670
quite because the blockchain does

00:02:24,900 --> 00:02:28,500
something that databases don't do and

00:02:26,670 --> 00:02:30,450
that's managed a double spending problem

00:02:28,500 --> 00:02:31,980
so if you're going to have some kind of

00:02:30,450 --> 00:02:34,170
a payment system some kind of an asset

00:02:31,980 --> 00:02:36,210
tracking system and Alice has an asset

00:02:34,170 --> 00:02:37,500
let's say ten dollars she has to be able

00:02:36,210 --> 00:02:39,780
to send it to Bob but we don't have a

00:02:37,500 --> 00:02:41,190
useful asset transfer system and she has

00:02:39,780 --> 00:02:42,570
to be able to send it to Charlie or

00:02:41,190 --> 00:02:45,360
again we don't have a useful asset

00:02:42,570 --> 00:02:46,980
transfer system but if she can transfer

00:02:45,360 --> 00:02:48,690
the same asset to both Bob and Charlie

00:02:46,980 --> 00:02:51,510
again we don't have a useful asset

00:02:48,690 --> 00:02:53,220
transfer system so somehow if she sends

00:02:51,510 --> 00:02:55,020
their ten dollars to Charlie that has to

00:02:53,220 --> 00:02:58,710
prevent her from sending the same ten

00:02:55,020 --> 00:03:00,420
dollars to Bob pretty basic stuff so how

00:02:58,710 --> 00:03:01,620
do we usually solve this truly we've had

00:03:00,420 --> 00:03:02,880
this problem before and certainly we

00:03:01,620 --> 00:03:04,410
have and we solve it with a central

00:03:02,880 --> 00:03:06,570
authority so if I write a check to

00:03:04,410 --> 00:03:08,610
someone my bank is the central authority

00:03:06,570 --> 00:03:10,440
that says that check is good they

00:03:08,610 --> 00:03:11,820
prevent double spending by reconciling

00:03:10,440 --> 00:03:13,500
against their ledger so they have a

00:03:11,820 --> 00:03:15,420
record somewhere that shows how much

00:03:13,500 --> 00:03:17,100
money everybody has and they say that

00:03:15,420 --> 00:03:18,930
check is good that check is not good you

00:03:17,100 --> 00:03:20,459
can also imagine doing it with secure

00:03:18,930 --> 00:03:22,470
Hardware I could have some sort of box

00:03:20,459 --> 00:03:24,450
that knew how much money I had signed a

00:03:22,470 --> 00:03:26,610
transaction to transfer funds and then

00:03:24,450 --> 00:03:28,709
it knew I had less money but someone has

00:03:26,610 --> 00:03:30,120
to put the keys in that box and you wind

00:03:28,709 --> 00:03:31,860
up needing a central authority it's very

00:03:30,120 --> 00:03:33,660
difficult to design secure hardware that

00:03:31,860 --> 00:03:35,310
we can trust without some central

00:03:33,660 --> 00:03:39,060
authority to put the information in that

00:03:35,310 --> 00:03:40,470
Hardware before a block chains we had a

00:03:39,060 --> 00:03:42,750
lot of effort to produce these

00:03:40,470 --> 00:03:45,209
decentralized asset transfer systems

00:03:42,750 --> 00:03:46,739
Hashcash which came up with the idea

00:03:45,209 --> 00:03:49,350
that you could use proof of work to

00:03:46,739 --> 00:03:51,000
create something scarce computers can

00:03:49,350 --> 00:03:52,380
only do so much work however much work

00:03:51,000 --> 00:03:54,690
they can do they can't do more than that

00:03:52,380 --> 00:03:57,209
so you can create a scarce resource by

00:03:54,690 --> 00:03:58,860
attaching it to computing power B money

00:03:57,209 --> 00:04:00,900
was the next step which came up with the

00:03:58,860 --> 00:04:02,310
idea of essentially having some trust in

00:04:00,900 --> 00:04:04,260
the servers to solve the transfer

00:04:02,310 --> 00:04:06,239
problem so hash cash could regulate the

00:04:04,260 --> 00:04:07,800
control of an asset but not a good way

00:04:06,239 --> 00:04:10,320
to transfer it somehow you had to know

00:04:07,800 --> 00:04:12,330
who held that asset B money had the idea

00:04:10,320 --> 00:04:14,550
of trusting the servers Ryan Fuger

00:04:12,330 --> 00:04:16,350
develop triple classic which had this

00:04:14,550 --> 00:04:17,730
idea of instead of having one central

00:04:16,350 --> 00:04:19,470
authority would have lots and lots of

00:04:17,730 --> 00:04:20,820
authority so every asset could have its

00:04:19,470 --> 00:04:23,330
own Authority and that way no one

00:04:20,820 --> 00:04:25,530
authority ran the system just an asset

00:04:23,330 --> 00:04:27,690
the breakthrough came

00:04:25,530 --> 00:04:29,400
with Bitcoin which was the first

00:04:27,690 --> 00:04:31,260
blockchain and it is literally a chain

00:04:29,400 --> 00:04:33,570
of blocks and by that I mean that each

00:04:31,260 --> 00:04:35,970
block has the secure hash of the chain

00:04:33,570 --> 00:04:37,590
the block before it so you can follow

00:04:35,970 --> 00:04:39,380
that chain from the current block

00:04:37,590 --> 00:04:41,760
through the history of the system

00:04:39,380 --> 00:04:43,440
transactions transfer a native token so

00:04:41,760 --> 00:04:46,020
that is Bitcoin creates some sort of an

00:04:43,440 --> 00:04:47,430
asset a unit a transaction transfers

00:04:46,020 --> 00:04:50,310
that asset from one cryptographically

00:04:47,430 --> 00:04:52,200
proven identity to another it has what

00:04:50,310 --> 00:04:53,280
we call a UT EXO model this gets a

00:04:52,200 --> 00:04:55,440
little technical but it's kind of

00:04:53,280 --> 00:04:57,540
important to understand a UT EXO is an

00:04:55,440 --> 00:05:00,270
unspent transaction output if you have a

00:04:57,540 --> 00:05:01,770
Bitcoin you have a UT EXO a UT EXO is

00:05:00,270 --> 00:05:03,720
essentially some bitcoins that have been

00:05:01,770 --> 00:05:06,419
sent to someone but not yet been spent

00:05:03,720 --> 00:05:08,580
so a payment creates a UT EXO if I send

00:05:06,419 --> 00:05:10,620
you a Bitcoin I create a UT X so that

00:05:08,580 --> 00:05:12,630
you have the private key to claim for

00:05:10,620 --> 00:05:14,370
that Bitcoin and we assume the network

00:05:12,630 --> 00:05:15,930
degrees on the set of UT EXO's we don't

00:05:14,370 --> 00:05:17,760
actually directly check that but if they

00:05:15,930 --> 00:05:19,350
agree on the transactions transactions

00:05:17,760 --> 00:05:22,830
produce UT EXO's they should agree on

00:05:19,350 --> 00:05:24,570
the set of UT EXO's and the amazing

00:05:22,830 --> 00:05:26,130
thing is that bitcoins meet all the

00:05:24,570 --> 00:05:27,660
requirements for currency so they're

00:05:26,130 --> 00:05:29,040
scarce you have to have something scarce

00:05:27,660 --> 00:05:31,470
in order for it to be a currency if we

00:05:29,040 --> 00:05:33,120
can produce an unlimited quantity can

00:05:31,470 --> 00:05:34,650
produce an unlimited quantity but if

00:05:33,120 --> 00:05:36,360
there's something that regulates the

00:05:34,650 --> 00:05:38,490
quantity anyway it's usable as a

00:05:36,360 --> 00:05:40,919
currency so it has to be fungible that

00:05:38,490 --> 00:05:42,270
means that the units look the same so I

00:05:40,919 --> 00:05:43,500
don't particularly care what dollar bill

00:05:42,270 --> 00:05:44,940
you give me it could be an old one it

00:05:43,500 --> 00:05:45,390
can be a shiny one but I treat it as a

00:05:44,940 --> 00:05:47,250
dollar

00:05:45,390 --> 00:05:48,540
we don't use apples as currency because

00:05:47,250 --> 00:05:50,669
there are nice apples there are not so

00:05:48,540 --> 00:05:52,110
nice apples it has to be divisible if

00:05:50,669 --> 00:05:53,490
you imagine we had only hundred dollar

00:05:52,110 --> 00:05:55,110
bills that wouldn't be a very useful

00:05:53,490 --> 00:05:56,540
currency how would you buy cheap things

00:05:55,110 --> 00:05:58,560
with the bitcoins are divisible and

00:05:56,540 --> 00:06:00,060
they're durable so you don't want

00:05:58,560 --> 00:06:01,560
something that spoils it's a terrible

00:06:00,060 --> 00:06:03,030
currency you want something it's durable

00:06:01,560 --> 00:06:05,070
and you want something that's easily

00:06:03,030 --> 00:06:07,020
transferred so we don't use blocks of

00:06:05,070 --> 00:06:08,460
gold as currency typically directly

00:06:07,020 --> 00:06:10,020
because they're difficult to transfer I

00:06:08,460 --> 00:06:11,250
would have to give you the ball of gold

00:06:10,020 --> 00:06:13,410
I would have to carry it around with me

00:06:11,250 --> 00:06:15,360
so instead we virtualized it into an

00:06:13,410 --> 00:06:17,820
asset that is transferable to fix that

00:06:15,360 --> 00:06:20,060
problem so the amazing thing is is that

00:06:17,820 --> 00:06:22,200
this native token on this blockchain

00:06:20,060 --> 00:06:23,700
meets all the requirements to be a

00:06:22,200 --> 00:06:27,510
currency which means that people want to

00:06:23,700 --> 00:06:29,160
use it as a currency they can Bitcoin

00:06:27,510 --> 00:06:31,229
solves the double spend problem with

00:06:29,160 --> 00:06:33,330
mining it also solves the distribution

00:06:31,229 --> 00:06:34,740
problem if you imagine that you created

00:06:33,330 --> 00:06:36,300
a currency that had no central authority

00:06:34,740 --> 00:06:37,979
how would you introduce it in the first

00:06:36,300 --> 00:06:39,400
place there's nobody to give it away to

00:06:37,979 --> 00:06:41,260
people there's nobody to sell

00:06:39,400 --> 00:06:42,940
there's nobody to give it away so

00:06:41,260 --> 00:06:45,790
Bitcoin does it through mining which is

00:06:42,940 --> 00:06:46,960
a computational contest I used to joke

00:06:45,790 --> 00:06:48,280
that it's like giving them a way to

00:06:46,960 --> 00:06:50,110
whoever wastes the most electricity

00:06:48,280 --> 00:06:53,260
that's frightening Lee close to the

00:06:50,110 --> 00:06:54,280
truth the longest chain wins so that is

00:06:53,260 --> 00:06:56,350
the chain that has the most

00:06:54,280 --> 00:06:58,150
computational effort wins and miners are

00:06:56,350 --> 00:06:59,889
incentivized to lengthen the longest

00:06:58,150 --> 00:07:01,630
chain so if you sent me a block a

00:06:59,889 --> 00:07:03,070
Bitcoin on the longest chain that chain

00:07:01,630 --> 00:07:04,630
is going to get longer and longer and

00:07:03,070 --> 00:07:06,010
longer the other chains are not because

00:07:04,630 --> 00:07:08,199
nobody's paying to lengthen them

00:07:06,010 --> 00:07:09,940
we have eventual consistency as soon as

00:07:08,199 --> 00:07:11,500
the BOK chain that has your bitcoins on

00:07:09,940 --> 00:07:13,180
it is sufficiently longer than the

00:07:11,500 --> 00:07:15,340
others you can trust that it's going to

00:07:13,180 --> 00:07:18,550
stay that way and that solves the double

00:07:15,340 --> 00:07:20,020
spend problem in practice it's also

00:07:18,550 --> 00:07:22,360
interesting to note that we have both a

00:07:20,020 --> 00:07:23,889
currency and a payment system so we have

00:07:22,360 --> 00:07:25,960
bitcoins in the sense that I can have a

00:07:23,889 --> 00:07:27,970
Bitcoin and we also have Bitcoin which

00:07:25,960 --> 00:07:30,010
is a blockchain that can transfer that

00:07:27,970 --> 00:07:31,780
asset and you could imagine separating

00:07:30,010 --> 00:07:33,700
those things that you could imagine a

00:07:31,780 --> 00:07:35,500
bank that issued Bitcoin certificates of

00:07:33,700 --> 00:07:37,150
deposit held peoples bitcoins for people

00:07:35,500 --> 00:07:38,800
it can have its own payment system but

00:07:37,150 --> 00:07:40,240
Bitcoin is both a currency and a payment

00:07:38,800 --> 00:07:41,830
system because it's rooted in a

00:07:40,240 --> 00:07:44,020
blockchain that also supports

00:07:41,830 --> 00:07:45,639
transactions and the system regulates

00:07:44,020 --> 00:07:47,650
the introduction of new currency the way

00:07:45,639 --> 00:07:49,389
mining is controlled it creates bitcoins

00:07:47,650 --> 00:07:51,220
at a predictable rate and the supply is

00:07:49,389 --> 00:07:53,440
ultimately fixed so we actually have a

00:07:51,220 --> 00:07:55,060
deflationary carnate currency some

00:07:53,440 --> 00:07:57,030
people love deflationary currency some

00:07:55,060 --> 00:07:59,889
people hate them but that's what we have

00:07:57,030 --> 00:08:01,840
the rules are notionally set in stone by

00:07:59,889 --> 00:08:04,180
which i mean we all have software that

00:08:01,840 --> 00:08:06,220
controls what happens with a Bitcoin and

00:08:04,180 --> 00:08:08,919
we can only change those rules by social

00:08:06,220 --> 00:08:10,720
consensus so for example the Bitcoin

00:08:08,919 --> 00:08:13,539
supply is limited to 21 million bitcoins

00:08:10,720 --> 00:08:15,160
by the software but if everybody decided

00:08:13,539 --> 00:08:17,169
to change the software so it produced

00:08:15,160 --> 00:08:18,340
more bitcoins you don't have to change

00:08:17,169 --> 00:08:19,570
your software but then you wouldn't

00:08:18,340 --> 00:08:21,340
agree with the rest of the world and

00:08:19,570 --> 00:08:23,680
because the world does have to agree it

00:08:21,340 --> 00:08:25,150
requires eventual consistency everybody

00:08:23,680 --> 00:08:27,250
has to agree on the rules and agreeing

00:08:25,150 --> 00:08:29,740
on changing them which has been a bit of

00:08:27,250 --> 00:08:31,720
a governance problem it has UT Excel

00:08:29,740 --> 00:08:35,380
model and it uses mining to secure

00:08:31,720 --> 00:08:37,060
transactions Ripple one of the next

00:08:35,380 --> 00:08:38,650
block chains I have the worst elevator

00:08:37,060 --> 00:08:40,240
pitch ever for ripple it's a platform

00:08:38,650 --> 00:08:42,310
for issuing holding transferring and

00:08:40,240 --> 00:08:46,330
trading arbitrary assets I'll unpack

00:08:42,310 --> 00:08:48,220
that a bit I began in 2011 when Jed

00:08:46,330 --> 00:08:49,839
McCaleb hired me to try to find another

00:08:48,220 --> 00:08:52,270
way to solve the double spend problem

00:08:49,839 --> 00:08:53,170
without a central authority we came up

00:08:52,270 --> 00:08:54,970
with a distribute

00:08:53,170 --> 00:08:56,350
agreement protocol which is kind of like

00:08:54,970 --> 00:08:57,790
a room full of people agreeing on

00:08:56,350 --> 00:08:59,589
something as long as they all agree on

00:08:57,790 --> 00:09:01,570
which transactions to process and we can

00:08:59,589 --> 00:09:03,639
tell what they agreed on that solves a

00:09:01,570 --> 00:09:04,930
double spending problem - we replace

00:09:03,639 --> 00:09:06,579
blocks with Ledger's and we allow to

00:09:04,930 --> 00:09:09,250
arbitrary assets I'll go over that in a

00:09:06,579 --> 00:09:10,839
second so we have Ledger's ledger is the

00:09:09,250 --> 00:09:12,339
current state of the universe it's just

00:09:10,839 --> 00:09:14,199
like the contents of a database so

00:09:12,339 --> 00:09:15,760
instead of having unspent transaction

00:09:14,199 --> 00:09:17,230
outputs that are sort of collected over

00:09:15,760 --> 00:09:19,209
time we have the ledger that has

00:09:17,230 --> 00:09:21,430
everything in it and that forms a secure

00:09:19,209 --> 00:09:23,110
hash chain and ripple transaction sets

00:09:21,430 --> 00:09:24,699
advance the ledger an advantage of that

00:09:23,110 --> 00:09:26,470
is that prior Ledger's can be forgotten

00:09:24,699 --> 00:09:28,300
if anyone's ever tried to run Bitcoin

00:09:26,470 --> 00:09:29,500
you know it takes a long time for you to

00:09:28,300 --> 00:09:30,910
synchronize the blockchain because you

00:09:29,500 --> 00:09:32,680
need the every transaction that's ever

00:09:30,910 --> 00:09:34,300
happened prior transactions can be

00:09:32,680 --> 00:09:36,459
discarded and ripple you only keep them

00:09:34,300 --> 00:09:38,350
if you want history so the ledger also

00:09:36,459 --> 00:09:41,290
contains the transactions themselves and

00:09:38,350 --> 00:09:43,449
what we call metadata so many debt is

00:09:41,290 --> 00:09:45,339
what a transaction did so if I pay you

00:09:43,449 --> 00:09:47,019
ten dollars the transaction presumably

00:09:45,339 --> 00:09:48,850
if it's exceeded paid you 10 dollars for

00:09:47,019 --> 00:09:51,040
simple transactions it's enough to know

00:09:48,850 --> 00:09:52,269
the transaction succeeded if I write a

00:09:51,040 --> 00:09:53,709
check to someone it's enough for

00:09:52,269 --> 00:09:55,360
everyone to know that that cheque went

00:09:53,709 --> 00:09:57,399
through but imagine if you had a more

00:09:55,360 --> 00:09:59,649
complicated transaction say you had a

00:09:57,399 --> 00:10:01,149
transaction that paid someone 10 euros

00:09:59,649 --> 00:10:03,579
at the current rate and you were willing

00:10:01,149 --> 00:10:04,990
to pay up to 12 dollars to do it well

00:10:03,579 --> 00:10:06,519
just knowing that that transaction

00:10:04,990 --> 00:10:07,899
succeeded isn't enough because it

00:10:06,519 --> 00:10:10,149
doesn't tell you how much you paid it

00:10:07,899 --> 00:10:12,100
doesn't tell you who provided the euros

00:10:10,149 --> 00:10:14,079
and who took your dollars so a more

00:10:12,100 --> 00:10:15,880
sophisticated system that tracks what a

00:10:14,079 --> 00:10:18,760
transaction did can support more

00:10:15,880 --> 00:10:20,769
sophisticated transactions it develops

00:10:18,760 --> 00:10:22,570
eventual consistency by an algorithm we

00:10:20,769 --> 00:10:24,579
call consensus which is a distributed

00:10:22,570 --> 00:10:27,430
agreement algorithm and if you know what

00:10:24,579 --> 00:10:29,350
pbft is good you'll find out soon enough

00:10:27,430 --> 00:10:31,029
it doesn't require a hundred percent

00:10:29,350 --> 00:10:33,070
agreement on the participants that was

00:10:31,029 --> 00:10:35,110
what was interesting about Ripple prior

00:10:33,070 --> 00:10:36,730
algorithms required everybody to agree

00:10:35,110 --> 00:10:38,529
on the participants Ripple just require

00:10:36,730 --> 00:10:40,000
a substantial agreement which means that

00:10:38,529 --> 00:10:41,920
you can add and remove people without

00:10:40,000 --> 00:10:44,019
having to agree on who's in and who's

00:10:41,920 --> 00:10:46,209
out so it's ripples method of solving

00:10:44,019 --> 00:10:48,310
the double spend problem transactions

00:10:46,209 --> 00:10:49,810
are applied as a unit in groups it's

00:10:48,310 --> 00:10:51,970
like a room full of people trying to

00:10:49,810 --> 00:10:53,470
agree one of the reasons it's robust is

00:10:51,970 --> 00:10:55,449
that an honest server just cares about

00:10:53,470 --> 00:10:56,940
agreement so if you imagine we were all

00:10:55,449 --> 00:10:59,050
trying to agree what to have for lunch

00:10:56,940 --> 00:11:01,149
we all have different things that we

00:10:59,050 --> 00:11:02,860
want some of us don't like gluten some

00:11:01,149 --> 00:11:04,420
of us are on a low-carb diet some of us

00:11:02,860 --> 00:11:05,860
are vegetarians it's hard for us to

00:11:04,420 --> 00:11:06,910
agree because we all have different

00:11:05,860 --> 00:11:08,740
interests but imagine if

00:11:06,910 --> 00:11:10,600
all we cared about was agreeing all

00:11:08,740 --> 00:11:12,370
everybody cared about is that we pick a

00:11:10,600 --> 00:11:13,630
place to eat so someone says let's go to

00:11:12,370 --> 00:11:14,830
the movie theater and it's like no

00:11:13,630 --> 00:11:16,090
that's not a place to eat and someone

00:11:14,830 --> 00:11:17,770
says let's go to Burger King in every

00:11:16,090 --> 00:11:19,630
but it's like that's a place to eat it's

00:11:17,770 --> 00:11:21,220
a much simpler problem when the

00:11:19,630 --> 00:11:22,690
different participants have aligned

00:11:21,220 --> 00:11:24,700
interests and they don't have unique

00:11:22,690 --> 00:11:26,790
interest so if they all agree on just

00:11:24,700 --> 00:11:28,780
getting the valid transactions in

00:11:26,790 --> 00:11:31,090
agreement is much simpler

00:11:28,780 --> 00:11:32,290
the other interesting thing to notice is

00:11:31,090 --> 00:11:33,850
that you can solve the double spend

00:11:32,290 --> 00:11:34,980
problem just by putting transactions in

00:11:33,850 --> 00:11:37,840
order

00:11:34,980 --> 00:11:39,580
why because whether a transaction is

00:11:37,840 --> 00:11:41,280
valid or not as deterministic if you

00:11:39,580 --> 00:11:43,990
want to spend money you have to have it

00:11:41,280 --> 00:11:45,340
executing a transaction if two transfers

00:11:43,990 --> 00:11:46,600
money you have it succeeds if it

00:11:45,340 --> 00:11:48,160
transfers money you don't have it

00:11:46,600 --> 00:11:50,170
doesn't succeed it's deterministic we

00:11:48,160 --> 00:11:51,640
can all agree on it and transactions

00:11:50,170 --> 00:11:52,930
either conflict or they don't if I try

00:11:51,640 --> 00:11:54,670
to send the same money to two different

00:11:52,930 --> 00:11:56,350
places we'll all agree that the second

00:11:54,670 --> 00:11:59,290
transaction will fail but which is the

00:11:56,350 --> 00:12:00,670
second transaction you might see one

00:11:59,290 --> 00:12:01,840
payment first and then the other one

00:12:00,670 --> 00:12:03,970
someone might see them in the other

00:12:01,840 --> 00:12:05,470
order so transaction ordering is

00:12:03,970 --> 00:12:07,870
sufficient to solve the double spend

00:12:05,470 --> 00:12:10,090
problem and that's what validators do in

00:12:07,870 --> 00:12:12,130
Ripple they propose sets of transactions

00:12:10,090 --> 00:12:13,690
they Avalanche to consensus avalanche if

00:12:12,130 --> 00:12:15,610
you imagine a snowball on the top of

00:12:13,690 --> 00:12:17,260
roof if it starts to tip in one

00:12:15,610 --> 00:12:18,610
direction everybody kind of pushes it in

00:12:17,260 --> 00:12:20,800
that same direction until you reach

00:12:18,610 --> 00:12:23,140
agreement very quickly and then they

00:12:20,800 --> 00:12:25,960
sign the ledger so it turns out that

00:12:23,140 --> 00:12:27,730
this is remarkably robust for us for a

00:12:25,960 --> 00:12:29,140
set of reasons that make it seem a much

00:12:27,730 --> 00:12:31,630
simpler problem than it than it

00:12:29,140 --> 00:12:33,190
originally seen so one is all honest

00:12:31,630 --> 00:12:34,960
participants will vote to include a

00:12:33,190 --> 00:12:36,700
transaction if there's no reason not to

00:12:34,960 --> 00:12:38,140
include it if I say I want to transfer

00:12:36,700 --> 00:12:40,150
ten dollars to Bob and I have ten

00:12:38,140 --> 00:12:41,620
dollars Bob's a valid account on the

00:12:40,150 --> 00:12:43,090
system and everything looks fine every

00:12:41,620 --> 00:12:44,890
honest participant will say yeah that's

00:12:43,090 --> 00:12:46,810
fine that should go in and if a

00:12:44,890 --> 00:12:48,160
transaction has any reason not to be

00:12:46,810 --> 00:12:50,050
included maybe it's part of a double

00:12:48,160 --> 00:12:51,760
spend whatever it's fine if it's not

00:12:50,050 --> 00:12:53,650
included because if it's still valid

00:12:51,760 --> 00:12:56,040
it'll be voted in in the next round and

00:12:53,650 --> 00:12:58,600
the algorithm is biased to exclude

00:12:56,040 --> 00:13:00,340
transactions to reduce overlap so what

00:12:58,600 --> 00:13:01,630
that means is that if we can't agree if

00:13:00,340 --> 00:13:03,490
there's a whole bunch of transactions

00:13:01,630 --> 00:13:05,380
and there's just lots of disagreement we

00:13:03,490 --> 00:13:07,210
can reduce the amount of disagreement by

00:13:05,380 --> 00:13:08,500
eliminating transactions and not adding

00:13:07,210 --> 00:13:12,820
new ones and that way the amount of

00:13:08,500 --> 00:13:15,250
disagreement continuously drops it has

00:13:12,820 --> 00:13:16,900
no rotating dictators so in Bitcoin a

00:13:15,250 --> 00:13:18,730
miner chooses the transactions that go

00:13:16,900 --> 00:13:20,730
in a block consensus doesn't have

00:13:18,730 --> 00:13:23,040
rotating dictators so you can do things

00:13:20,730 --> 00:13:24,269
like financial transactions where one

00:13:23,040 --> 00:13:25,889
person controlled all of the

00:13:24,269 --> 00:13:27,540
transactions they might abuse that to

00:13:25,889 --> 00:13:29,040
their own financial benefit they might

00:13:27,540 --> 00:13:31,050
take the juiciest offers they might

00:13:29,040 --> 00:13:34,910
prevent people from moving funds and so

00:13:31,050 --> 00:13:34,910
on and the past can't be rewritten

00:13:35,209 --> 00:13:40,529
ripple is open source is C licensed

00:13:38,220 --> 00:13:42,540
public ledger public transactions public

00:13:40,529 --> 00:13:45,360
history equal access and it's written in

00:13:42,540 --> 00:13:47,579
C++ by a team of developers who've been

00:13:45,360 --> 00:13:50,579
writing high-quality modern C++ software

00:13:47,579 --> 00:13:52,680
for several years now so how do you move

00:13:50,579 --> 00:13:55,470
assets on a payment system that isn't

00:13:52,680 --> 00:13:57,360
connected to any sort of financial

00:13:55,470 --> 00:13:59,459
institution you might imagine if you

00:13:57,360 --> 00:14:01,440
have a payment system like Visa or eBay

00:13:59,459 --> 00:14:02,910
they have infrastructure that moves real

00:14:01,440 --> 00:14:04,199
money and you might wonder how could you

00:14:02,910 --> 00:14:05,790
have a payment system that wasn't

00:14:04,199 --> 00:14:07,769
directly connected to infrastructure

00:14:05,790 --> 00:14:10,110
that moves me at real money and the way

00:14:07,769 --> 00:14:12,810
you do that is by virtualizing arbitrary

00:14:10,110 --> 00:14:14,820
assets so an asset is identified by an

00:14:12,810 --> 00:14:16,470
issuer and a currency let's say dollars

00:14:14,820 --> 00:14:19,410
issued by Wells Fargo that seems like a

00:14:16,470 --> 00:14:21,779
nice asset and because an asset can be

00:14:19,410 --> 00:14:23,670
issued by anyone ripple only allows you

00:14:21,779 --> 00:14:26,279
to hold an asset that you choose to hold

00:14:23,670 --> 00:14:27,480
so I don't want my cousin Jeff to owe me

00:14:26,279 --> 00:14:29,430
money that's not a very reliable

00:14:27,480 --> 00:14:29,880
currency I'd rather have Wells Fargo owe

00:14:29,430 --> 00:14:32,490
me money

00:14:29,880 --> 00:14:34,139
I can choose assets have a counterparty

00:14:32,490 --> 00:14:35,550
and what's interesting about that is

00:14:34,139 --> 00:14:38,490
that means they can reflect a legal

00:14:35,550 --> 00:14:40,050
obligation so if our CL says that Wells

00:14:38,490 --> 00:14:41,490
Fargo is me $10

00:14:40,050 --> 00:14:43,290
while that's while the ledger is

00:14:41,490 --> 00:14:45,209
reporting that and ripple knows that

00:14:43,290 --> 00:14:47,190
that's true there was a separate legal

00:14:45,209 --> 00:14:49,680
obligation on the part of Wells Fargo to

00:14:47,190 --> 00:14:51,360
owe me those ten dollars and presumably

00:14:49,680 --> 00:14:53,339
even if something terrible happened to

00:14:51,360 --> 00:14:55,139
Ripple that legal obligation would still

00:14:53,339 --> 00:14:56,970
exist and you'll see in a minute what

00:14:55,139 --> 00:14:58,709
that does so you have a bunch of

00:14:56,970 --> 00:15:01,110
accounts their identities in the network

00:14:58,709 --> 00:15:03,540
and they trust each other forming a

00:15:01,110 --> 00:15:05,279
directed graph so this shows that alice

00:15:03,540 --> 00:15:06,990
is willing to allow Carol to owe her

00:15:05,279 --> 00:15:08,490
some money Alice is willing to allow

00:15:06,990 --> 00:15:10,589
Edward to owe her some money of course

00:15:08,490 --> 00:15:11,579
these would probably be financial

00:15:10,589 --> 00:15:14,639
institutions but they could be people

00:15:11,579 --> 00:15:16,529
and so you can have money by sending

00:15:14,639 --> 00:15:18,060
money in the physical world so Alice can

00:15:16,529 --> 00:15:20,519
actually send a hundred dollars to Bob

00:15:18,060 --> 00:15:23,910
and Bob takes that hundred dollars and

00:15:20,519 --> 00:15:26,190
pushes an electronic asset to out to

00:15:23,910 --> 00:15:27,959
Alice now that electronic asset can be

00:15:26,190 --> 00:15:29,579
in any system we want it doesn't matter

00:15:27,959 --> 00:15:31,470
what's important is that bob boze alice

00:15:29,579 --> 00:15:33,660
$100 and that's a real

00:15:31,470 --> 00:15:35,250
the system is recording that fact but it

00:15:33,660 --> 00:15:38,150
isn't that fact that fact is a fact

00:15:35,250 --> 00:15:41,010
Alice sent Bob $100 bob boze Alice $100

00:15:38,150 --> 00:15:43,250
so Alice now has this digital asset that

00:15:41,010 --> 00:15:45,960
says Bob owes me $100

00:15:43,250 --> 00:15:47,910
Alice can transfer that asset in any

00:15:45,960 --> 00:15:50,670
system we want as long as Bob is willing

00:15:47,910 --> 00:15:52,380
to honor it so if if Charlie also trusts

00:15:50,670 --> 00:15:54,300
Bob and Alice sends those hundred

00:15:52,380 --> 00:15:55,770
dollars to Charlie in any system at all

00:15:54,300 --> 00:15:57,570
that Bob is willing to honor it doesn't

00:15:55,770 --> 00:15:59,720
matter who runs it or owns it as long as

00:15:57,570 --> 00:16:02,280
it doesn't mess up now

00:15:59,720 --> 00:16:05,550
Charlie can redeem those hundred dollars

00:16:02,280 --> 00:16:07,020
with Bob the only problem is if you

00:16:05,550 --> 00:16:08,550
imagine what we all have different

00:16:07,020 --> 00:16:10,080
people we trust them you get this sort

00:16:08,550 --> 00:16:12,750
of spaghetti network where there is a

00:16:10,080 --> 00:16:14,610
large number of participants and it's

00:16:12,750 --> 00:16:16,710
not a very usable system so the solution

00:16:14,610 --> 00:16:19,080
is to have a hub a hub would be like a

00:16:16,710 --> 00:16:20,730
bank if there are a lot of people who

00:16:19,080 --> 00:16:23,340
are willing to consider Wells Fargo

00:16:20,730 --> 00:16:24,930
owing them $1 to be worth a dollar then

00:16:23,340 --> 00:16:26,460
you'll consider it worth a dollar

00:16:24,930 --> 00:16:29,160
because you know that other people will

00:16:26,460 --> 00:16:30,570
consider it worth the dollar but now you

00:16:29,160 --> 00:16:32,460
wind up with a whole bunch of islands

00:16:30,570 --> 00:16:34,770
you wind up with Wells Fargo issuing

00:16:32,460 --> 00:16:37,140
dollars you wind up with another company

00:16:34,770 --> 00:16:39,330
issuing Euros or issuing bitcoins or you

00:16:37,140 --> 00:16:41,220
honor all these different currencies so

00:16:39,330 --> 00:16:42,990
how do you make a global payment system

00:16:41,220 --> 00:16:46,020
out of an arbitrary asset system with

00:16:42,990 --> 00:16:47,700
offers those things in the middle that

00:16:46,020 --> 00:16:49,620
look like those double arrows those are

00:16:47,700 --> 00:16:51,240
connectors they have an asset or an

00:16:49,620 --> 00:16:53,040
account in two different systems and

00:16:51,240 --> 00:16:55,350
they're willing to trade one asset for

00:16:53,040 --> 00:16:57,360
another so if I hold dollars at Wells

00:16:55,350 --> 00:17:00,540
Fargo and I'm willing to transfer them

00:16:57,360 --> 00:17:02,670
for euros then someone who wants to make

00:17:00,540 --> 00:17:04,290
a payment can give me the euros I want

00:17:02,670 --> 00:17:06,270
and I transfer the dollars at Wells

00:17:04,290 --> 00:17:08,190
Fargo and you can put together an

00:17:06,270 --> 00:17:10,350
international payment from to domestic

00:17:08,190 --> 00:17:12,630
payments so if I want to pay someone in

00:17:10,350 --> 00:17:14,550
China and there's someone in China who's

00:17:12,630 --> 00:17:16,949
willing to accept my dollars in the US

00:17:14,550 --> 00:17:19,140
and supply the money in China

00:17:16,949 --> 00:17:21,360
those two domestic payments from my

00:17:19,140 --> 00:17:25,170
point of view act like one international

00:17:21,360 --> 00:17:26,760
payment so arbitrary assets how do they

00:17:25,170 --> 00:17:28,290
work money doesn't really move you

00:17:26,760 --> 00:17:30,060
notice we never actually moved any money

00:17:28,290 --> 00:17:32,100
what we did is we changed who owned the

00:17:30,060 --> 00:17:33,810
money and that's just as good Alice

00:17:32,100 --> 00:17:35,640
wants to pay Bob ten dollars what she

00:17:33,810 --> 00:17:37,290
wants is Bob to have title to ten

00:17:35,640 --> 00:17:38,820
dollars so he considers her to have paid

00:17:37,290 --> 00:17:40,080
him so you don't actually have to move

00:17:38,820 --> 00:17:42,660
any money you just have to swap the

00:17:40,080 --> 00:17:44,100
ownership of the assets sender loses

00:17:42,660 --> 00:17:45,070
custody of the asset they sent the

00:17:44,100 --> 00:17:46,750
recipient gains

00:17:45,070 --> 00:17:48,940
today payments ripple through the

00:17:46,750 --> 00:17:50,920
intermediaries they gain and lose assets

00:17:48,940 --> 00:17:54,850
to facilitate the payments they also

00:17:50,920 --> 00:17:56,920
benefit now a crazy idea you can build

00:17:54,850 --> 00:17:58,720
social credit out of that so typically

00:17:56,920 --> 00:18:00,400
if you need money you borrow it from

00:17:58,720 --> 00:18:01,600
someone typically a financial

00:18:00,400 --> 00:18:03,100
institution I don't know how many people

00:18:01,600 --> 00:18:05,070
here borrow money from their friends but

00:18:03,100 --> 00:18:07,480
that's not really socially acceptable

00:18:05,070 --> 00:18:09,430
but what you could do is instead of

00:18:07,480 --> 00:18:11,530
borrowing money if I borrow $10 and

00:18:09,430 --> 00:18:13,060
someone they don't have $10 and they're

00:18:11,530 --> 00:18:14,650
out $10 and they might charge me

00:18:13,060 --> 00:18:16,660
interest which makes sense because they

00:18:14,650 --> 00:18:19,090
say take a disadvantage but suppose

00:18:16,660 --> 00:18:21,790
instead of me borrowing $10 from them we

00:18:19,090 --> 00:18:24,040
exchange IOU so I give them an IOU that

00:18:21,790 --> 00:18:27,160
says I owe you $10 they give me an IOU

00:18:24,040 --> 00:18:29,560
that says I owe them $10 those IOUs have

00:18:27,160 --> 00:18:32,080
value those IOUs are something that

00:18:29,560 --> 00:18:34,570
people will want if I have assets that

00:18:32,080 --> 00:18:39,100
people want and you can build a system

00:18:34,570 --> 00:18:40,570
like this someone has money at a gateway

00:18:39,100 --> 00:18:42,880
they have a whole bunch of people who

00:18:40,570 --> 00:18:44,200
trust them they can push balances to

00:18:42,880 --> 00:18:45,730
those people now here's where things get

00:18:44,200 --> 00:18:48,730
interesting so Alice notionally has a

00:18:45,730 --> 00:18:50,830
$40 balance because the Gateway OS are

00:18:48,730 --> 00:18:52,720
$100 but she owes $20 each of three

00:18:50,830 --> 00:18:54,520
other people but the Gateway doesn't

00:18:52,720 --> 00:18:56,260
know that she has those IOU she still

00:18:54,520 --> 00:18:57,730
has that hundred dollars and you might

00:18:56,260 --> 00:18:59,140
think that she can't spend that money

00:18:57,730 --> 00:19:00,460
that she has to have a positive balance

00:18:59,140 --> 00:19:02,530
that you wouldn't want to go negative

00:19:00,460 --> 00:19:04,720
but if you think about it every asset

00:19:02,530 --> 00:19:06,790
one party has an obligation some other

00:19:04,720 --> 00:19:09,760
party has the system funds have to sum

00:19:06,790 --> 00:19:11,560
to zero if Alice has $100 at the gateway

00:19:09,760 --> 00:19:13,450
it's because the Gateway owes are $100

00:19:11,560 --> 00:19:15,040
and has negative balance so a social

00:19:13,450 --> 00:19:17,110
credit system would allow everybody who

00:19:15,040 --> 00:19:19,810
wanted to to run negative or positive

00:19:17,110 --> 00:19:23,920
balances and create value out of

00:19:19,810 --> 00:19:25,440
borrowing works on Ripple today but it's

00:19:23,920 --> 00:19:27,790
considered a pretty crazy idea

00:19:25,440 --> 00:19:29,080
government money is not about to go away

00:19:27,790 --> 00:19:30,190
there's a lot of people who think that

00:19:29,080 --> 00:19:32,470
these things will take over the world

00:19:30,190 --> 00:19:34,810
there's a multi trillion dollar market

00:19:32,470 --> 00:19:36,640
in these legacy fiat currencies if you

00:19:34,810 --> 00:19:39,400
will they're not going away anytime soon

00:19:36,640 --> 00:19:40,810
so they are important you may have heard

00:19:39,400 --> 00:19:42,400
of private blockchains these are block

00:19:40,810 --> 00:19:44,380
chains that are not accessible to the

00:19:42,400 --> 00:19:46,330
public they're becoming very popular now

00:19:44,380 --> 00:19:49,570
for things like trade sell trade

00:19:46,330 --> 00:19:51,790
financing settling securities and other

00:19:49,570 --> 00:19:53,320
applications they're like public

00:19:51,790 --> 00:19:54,850
blockchains except the participants are

00:19:53,320 --> 00:19:56,800
controlled so you typically have a

00:19:54,850 --> 00:19:57,630
cryptographic identity to use the system

00:19:56,800 --> 00:19:59,280
at all

00:19:57,630 --> 00:20:00,750
transactions can be private and they

00:19:59,280 --> 00:20:01,950
don't need a native token they don't

00:20:00,750 --> 00:20:02,940
have to worry about denial of service

00:20:01,950 --> 00:20:05,760
attacks because you can cut off

00:20:02,940 --> 00:20:06,900
participants you don't like attacks can

00:20:05,760 --> 00:20:08,400
be mitigated because you know the

00:20:06,900 --> 00:20:10,140
identity of the participants they can

00:20:08,400 --> 00:20:11,669
react to a legal process so there's no

00:20:10,140 --> 00:20:13,650
court you can go to to get your bitcoins

00:20:11,669 --> 00:20:15,210
back if they're stolen there's no legal

00:20:13,650 --> 00:20:16,740
process that you can apply to the

00:20:15,210 --> 00:20:18,330
Bitcoin network because it's running on

00:20:16,740 --> 00:20:20,280
thousands of people's computers and

00:20:18,330 --> 00:20:21,390
there's no real management if any of you

00:20:20,280 --> 00:20:23,580
are familiar with the block size

00:20:21,390 --> 00:20:25,169
controversy there's no way to manage a

00:20:23,580 --> 00:20:26,910
public blockchain really except to get

00:20:25,169 --> 00:20:28,440
agreement a private blockchain can have

00:20:26,910 --> 00:20:31,200
a formal management process and it can

00:20:28,440 --> 00:20:32,970
be built into the software so they're

00:20:31,200 --> 00:20:36,179
good for organizations of frenemies now

00:20:32,970 --> 00:20:38,340
if you imagine banks have a cumulative

00:20:36,179 --> 00:20:40,230
interest in making asset transfer

00:20:38,340 --> 00:20:42,450
reliable but know what they don't want

00:20:40,230 --> 00:20:43,950
anyone bank to run it Wells Fargo

00:20:42,450 --> 00:20:45,990
doesn't want to use Chase's payment

00:20:43,950 --> 00:20:47,460
system chase doesn't want to use HSBC's

00:20:45,990 --> 00:20:49,470
payment system because their business

00:20:47,460 --> 00:20:51,570
competitors you can use a private

00:20:49,470 --> 00:20:53,309
blockchain to have a system where the

00:20:51,570 --> 00:20:55,770
rules are enforced by software and

00:20:53,309 --> 00:20:57,539
because the rules are enforced by

00:20:55,770 --> 00:20:59,159
software you have redundancy if one

00:20:57,539 --> 00:21:00,690
system doesn't follow the rules it just

00:20:59,159 --> 00:21:03,000
get it gets ignored by the other and

00:21:00,690 --> 00:21:04,650
they can be self-governing so that's

00:21:03,000 --> 00:21:07,590
that that seems to be a way to save

00:21:04,650 --> 00:21:09,059
money if traditionally if banks wanted

00:21:07,590 --> 00:21:10,470
to set a payment system up between them

00:21:09,059 --> 00:21:12,690
they would create an organization like

00:21:10,470 --> 00:21:14,520
Swift it would have governance it would

00:21:12,690 --> 00:21:16,980
have computers it would have offices it

00:21:14,520 --> 00:21:18,690
would be very expensive they could solve

00:21:16,980 --> 00:21:20,490
those same types of problems using a

00:21:18,690 --> 00:21:23,070
private blockchain where software

00:21:20,490 --> 00:21:24,750
enforces those rules no one person can

00:21:23,070 --> 00:21:26,309
cheat the system or control the system

00:21:24,750 --> 00:21:30,559
because the system works by agreement of

00:21:26,309 --> 00:21:33,419
the remaining system of the participants

00:21:30,559 --> 00:21:34,679
so a lot of Bitcoin enthusiasts seem to

00:21:33,419 --> 00:21:36,360
think that there'll be one ledger to

00:21:34,679 --> 00:21:38,610
rule them all we've beaten down that

00:21:36,360 --> 00:21:40,440
path for a couple of years and the news

00:21:38,610 --> 00:21:41,850
is there is not going to be one ledger

00:21:40,440 --> 00:21:44,100
there is not going to be one payment

00:21:41,850 --> 00:21:46,890
system there is not going to be one

00:21:44,100 --> 00:21:48,480
blockchain there's not going to be just

00:21:46,890 --> 00:21:49,890
like there isn't one web server just

00:21:48,480 --> 00:21:51,750
like there isn't one payment system on

00:21:49,890 --> 00:21:52,620
the internet there's one internet but

00:21:51,750 --> 00:21:55,049
there's a whole bunch of different

00:21:52,620 --> 00:21:56,850
systems on it and the reason for that is

00:21:55,049 --> 00:21:58,590
that people like different things out of

00:21:56,850 --> 00:22:00,600
their Ledger's and we want innovation

00:21:58,590 --> 00:22:02,730
Ledger's are important they track assets

00:22:00,600 --> 00:22:04,830
people want high-frequency trading they

00:22:02,730 --> 00:22:06,690
want Ledger's that respond to government

00:22:04,830 --> 00:22:07,950
subpoenas they want Ledger's that have

00:22:06,690 --> 00:22:09,390
different rules some people want

00:22:07,950 --> 00:22:11,399
Ledger's that are fully public some

00:22:09,390 --> 00:22:13,109
people want Ledger's that are private

00:22:11,399 --> 00:22:15,089
people will refuse to participate in the

00:22:13,109 --> 00:22:16,169
system if North Korea has access to it

00:22:15,089 --> 00:22:18,089
because they have regulatory

00:22:16,169 --> 00:22:21,749
requirements there is not going to be

00:22:18,089 --> 00:22:23,219
one payment system but like we don't

00:22:21,749 --> 00:22:24,929
want Ledger's to be Islands either we

00:22:23,219 --> 00:22:26,759
need a standard we need a way to make

00:22:24,929 --> 00:22:29,369
payments across Ledger's we need a way

00:22:26,759 --> 00:22:31,440
to build the system that consists of a

00:22:29,369 --> 00:22:33,509
number of payment systems forming one

00:22:31,440 --> 00:22:35,070
network just like the internet connected

00:22:33,509 --> 00:22:38,239
a large number of private networks

00:22:35,070 --> 00:22:40,619
together and we need a neutral standard

00:22:38,239 --> 00:22:42,690
ripple has proposed Inter ledger as a

00:22:40,619 --> 00:22:44,279
solution to connect payment systems to

00:22:42,690 --> 00:22:46,080
each other and build a world where money

00:22:44,279 --> 00:22:49,799
can move as easy as information it's

00:22:46,080 --> 00:22:51,539
it's surprisingly simple so you have

00:22:49,799 --> 00:22:53,700
Ledger's the track accounts and balances

00:22:51,539 --> 00:22:55,589
but you have people who are on different

00:22:53,700 --> 00:22:57,299
Ledger's a sender has a senders ledger

00:22:55,589 --> 00:22:58,919
recipient on a different ledger these

00:22:57,299 --> 00:23:01,259
could be financial institutions that

00:22:58,919 --> 00:23:03,539
could be payment systems can be paypal

00:23:01,259 --> 00:23:05,489
can be anything so we have a connector

00:23:03,539 --> 00:23:07,589
that relays money connector has an

00:23:05,489 --> 00:23:09,419
account in both systems and is willing

00:23:07,589 --> 00:23:12,779
to accept the payment on one system and

00:23:09,419 --> 00:23:14,580
make a payment on another so Alice wants

00:23:12,779 --> 00:23:17,549
to pay Bob let's say Alice wants to send

00:23:14,580 --> 00:23:19,339
100 widgets and deliver those widgets to

00:23:17,549 --> 00:23:22,379
Chloe

00:23:19,339 --> 00:23:24,419
whee Chloe receives a payment on Alice's

00:23:22,379 --> 00:23:26,779
ledger Chloe makes a payment on Bob's

00:23:24,419 --> 00:23:29,159
ledger and everything is good

00:23:26,779 --> 00:23:31,049
except someone has to make that payment

00:23:29,159 --> 00:23:32,609
first if Alice makes the payment first

00:23:31,049 --> 00:23:34,379
she has to trust Chloe if Chloe makes

00:23:32,609 --> 00:23:36,899
the payment first yes to trust Alice

00:23:34,379 --> 00:23:38,429
there are tremendous advantages to being

00:23:36,899 --> 00:23:41,429
able to use connectors we don't trust

00:23:38,429 --> 00:23:44,450
because connectors can compete so money

00:23:41,429 --> 00:23:46,919
would be lost if Chloe drops the payment

00:23:44,450 --> 00:23:50,009
we can use escrow to fix that problem

00:23:46,919 --> 00:23:51,330
and the ledgers provide the escrow I'll

00:23:50,009 --> 00:23:51,889
show you why that's important in a

00:23:51,330 --> 00:23:54,539
minute

00:23:51,889 --> 00:23:56,729
so if Alice wants to send some money to

00:23:54,539 --> 00:24:00,599
Bob through Chloe she puts the money

00:23:56,729 --> 00:24:02,369
that she's going to send in escrow then

00:24:00,599 --> 00:24:05,249
Chloe puts the money that she's going to

00:24:02,369 --> 00:24:08,159
send in escrow and then the transfer is

00:24:05,249 --> 00:24:10,129
executed from right to left so the

00:24:08,159 --> 00:24:12,629
recipient gets the payment from Chloe

00:24:10,129 --> 00:24:14,639
Chloe gets the payment from Alice and we

00:24:12,629 --> 00:24:17,429
have an atomic transaction the

00:24:14,639 --> 00:24:21,259
recipients receipt releases the funds to

00:24:17,429 --> 00:24:24,989
the recipient to the recipient but also

00:24:21,259 --> 00:24:25,250
the recipients receipt also releases the

00:24:24,989 --> 00:24:27,890
file

00:24:25,250 --> 00:24:29,050
guns to the market maker to the

00:24:27,890 --> 00:24:31,880
connector to Chloe

00:24:29,050 --> 00:24:34,130
so Chloe receives the funds from Alice

00:24:31,880 --> 00:24:37,250
Bob receives the funds from Chloe and

00:24:34,130 --> 00:24:39,830
the transaction is atomic so transfers

00:24:37,250 --> 00:24:41,840
are executed from left to right their

00:24:39,830 --> 00:24:45,080
escort from left to right executed from

00:24:41,840 --> 00:24:46,520
right to left the ledger only has to

00:24:45,080 --> 00:24:47,960
support two operations you have to be

00:24:46,520 --> 00:24:49,190
able to put the funds in escrow that is

00:24:47,960 --> 00:24:50,150
you have to lock them up so that

00:24:49,190 --> 00:24:51,350
everybody knows they're going to be

00:24:50,150 --> 00:24:53,330
there and you have to be able to release

00:24:51,350 --> 00:24:54,920
them and as it happens just about every

00:24:53,330 --> 00:24:56,780
ledger in the world can already do this

00:24:54,920 --> 00:24:58,220
every banking ledger has a way to hold

00:24:56,780 --> 00:25:00,050
funds while they're in transfer has a

00:24:58,220 --> 00:25:01,970
way to clear the transfer so you can

00:25:00,050 --> 00:25:04,640
make transactions across Ledger's

00:25:01,970 --> 00:25:06,410
facilitated by connectors atomic just by

00:25:04,640 --> 00:25:08,590
adding two operations to each ledger

00:25:06,410 --> 00:25:10,760
operations that they can easily support

00:25:08,590 --> 00:25:12,440
inter ledger has a set of crypto

00:25:10,760 --> 00:25:14,300
conditions which is a standard that

00:25:12,440 --> 00:25:16,040
specifies how to agree on whether or not

00:25:14,300 --> 00:25:18,050
something happens so that we know that

00:25:16,040 --> 00:25:20,840
Bob's receipt will release the funds

00:25:18,050 --> 00:25:22,850
from the sending ledger the key is one

00:25:20,840 --> 00:25:24,980
Ledger's receipt is another Ledger's

00:25:22,850 --> 00:25:27,620
receipt condition so it's the receipt of

00:25:24,980 --> 00:25:30,530
the funds to Bob that triggers the

00:25:27,620 --> 00:25:32,060
release of the funds to Chloe leverages

00:25:30,530 --> 00:25:33,530
the trust that already exists anyone who

00:25:32,060 --> 00:25:35,060
has funds on a ledger trust that ledger

00:25:33,530 --> 00:25:36,470
anyone willing to receive funds on a

00:25:35,060 --> 00:25:38,960
ledger trust that ledger and you don't

00:25:36,470 --> 00:25:40,310
have to trust the connectors so if you

00:25:38,960 --> 00:25:42,710
look at it from Bob's point of view

00:25:40,310 --> 00:25:44,120
let's say Alice Alice is sending Bob

00:25:42,710 --> 00:25:45,980
money which is either going to create a

00:25:44,120 --> 00:25:48,580
legal obligation for Bob maybe Bob's

00:25:45,980 --> 00:25:51,530
going to send her some goods or maybe

00:25:48,580 --> 00:25:52,910
Alice already owes Bob money Bob doesn't

00:25:51,530 --> 00:25:54,410
want to give the receipt and not get the

00:25:52,910 --> 00:25:56,810
money and he doesn't trust Alice or

00:25:54,410 --> 00:25:58,100
Chloe Alice wants to send the money she

00:25:56,810 --> 00:26:00,980
doesn't want to lose the money unless

00:25:58,100 --> 00:26:02,440
bob gets it she has to trust her ledger

00:26:00,980 --> 00:26:04,700
since it has her money

00:26:02,440 --> 00:26:07,190
Chloe the connector doesn't want to pay

00:26:04,700 --> 00:26:08,780
Bob and not get paid by Alice Chloe has

00:26:07,190 --> 00:26:11,000
to connect trust both Ledger's already

00:26:08,780 --> 00:26:12,770
because this Bob's ledger has her money

00:26:11,000 --> 00:26:15,980
and Alice's ledger will have her money

00:26:12,770 --> 00:26:17,150
she doesn't trust Alice or Bob she

00:26:15,980 --> 00:26:19,520
doesn't want to pay Bob unless she gets

00:26:17,150 --> 00:26:21,710
trust it gets paid by Alice and all of

00:26:19,520 --> 00:26:23,180
those requirements are met all those

00:26:21,710 --> 00:26:25,760
requirements are met by this system

00:26:23,180 --> 00:26:27,500
because Alice cannot lose her funds

00:26:25,760 --> 00:26:29,480
without the receipt that Bob get got

00:26:27,500 --> 00:26:31,520
paid and Chloe knows that when she gives

00:26:29,480 --> 00:26:34,310
that receipt to Alice's ledger she'll

00:26:31,520 --> 00:26:38,030
get paid boy it just it seems so simple

00:26:34,310 --> 00:26:39,140
I think I think some of you probably

00:26:38,030 --> 00:26:40,580
know it's really not

00:26:39,140 --> 00:26:42,680
that simple unfortunately so some

00:26:40,580 --> 00:26:43,340
sometimes it is that simple sometimes it

00:26:42,680 --> 00:26:45,710
is that simple

00:26:43,340 --> 00:26:48,470
so why well when the sender puts funds

00:26:45,710 --> 00:26:51,230
into escrow Alice's locks up $400 for

00:26:48,470 --> 00:26:53,030
this payment and the release condition

00:26:51,230 --> 00:26:55,790
Chloe gets that money when Chloe's pays

00:26:53,030 --> 00:26:57,380
Bob seems good the problem is we need a

00:26:55,790 --> 00:26:59,990
failure condition we need some way to

00:26:57,380 --> 00:27:00,860
unwind this if it doesn't work why

00:26:59,990 --> 00:27:02,270
wouldn't it work

00:27:00,860 --> 00:27:04,400
maybe the connector can't meet the

00:27:02,270 --> 00:27:05,810
payment terms maybe the connector loses

00:27:04,400 --> 00:27:07,580
connectivity with the internet a ledger

00:27:05,810 --> 00:27:10,430
break something can go wrong we need

00:27:07,580 --> 00:27:13,730
some way to unwind this transaction if

00:27:10,430 --> 00:27:15,170
something goes wrong now the sender from

00:27:13,730 --> 00:27:16,760
Alice's point of view she doesn't trust

00:27:15,170 --> 00:27:18,740
the connector she doesn't want the

00:27:16,760 --> 00:27:21,380
transaction in limbo for an hour because

00:27:18,740 --> 00:27:23,570
if Chloe doesn't make the payment she's

00:27:21,380 --> 00:27:27,020
lost an hour of time the connectors held

00:27:23,570 --> 00:27:28,490
her money but if the sender has to meet

00:27:27,020 --> 00:27:31,370
a release time that's tight

00:27:28,490 --> 00:27:33,290
but the connector is taking risk the

00:27:31,370 --> 00:27:34,790
risk stems from the inability to get the

00:27:33,290 --> 00:27:36,800
receipt to the ledger so the problem for

00:27:34,790 --> 00:27:39,080
Chloe is what if Chloe pays Bob and then

00:27:36,800 --> 00:27:41,510
something goes wrong Chloe can't get the

00:27:39,080 --> 00:27:42,740
money from Alice the time expires and

00:27:41,510 --> 00:27:45,650
Alice gets her money back in the

00:27:42,740 --> 00:27:47,330
connectors out so for low value payments

00:27:45,650 --> 00:27:49,820
it's not a problem you can use the

00:27:47,330 --> 00:27:51,650
release time say 10 minutes and Chloe

00:27:49,820 --> 00:27:53,840
can price in the risk of failure so if

00:27:51,650 --> 00:27:56,660
there's a 1/10 of 1% chance of failure

00:27:53,840 --> 00:27:59,000
she can charge 2/10 of 1% not a problem

00:27:56,660 --> 00:28:01,340
for small payments not good for high

00:27:59,000 --> 00:28:02,780
value payments for high value payments

00:28:01,340 --> 00:28:04,520
you need to agree on whether a

00:28:02,780 --> 00:28:05,930
transaction succeeded or failed you

00:28:04,520 --> 00:28:07,670
can't have this situation where one

00:28:05,930 --> 00:28:09,290
ledger thinks that transaction succeeded

00:28:07,670 --> 00:28:11,390
and another ledger thinks it's failed

00:28:09,290 --> 00:28:12,860
and you can't have a long lock time if I

00:28:11,390 --> 00:28:14,690
want to make a million dollar payment to

00:28:12,860 --> 00:28:16,550
someone I don't want someone having the

00:28:14,690 --> 00:28:18,080
option to make that payment for an hour

00:28:16,550 --> 00:28:19,520
without being committed to make it

00:28:18,080 --> 00:28:21,350
because maybe they'll wait until the

00:28:19,520 --> 00:28:22,850
financial markets move for their benefit

00:28:21,350 --> 00:28:25,520
and they'll make the payment if and only

00:28:22,850 --> 00:28:27,380
if they get an unusual fee so you need

00:28:25,520 --> 00:28:29,000
proof that something didn't happen if

00:28:27,380 --> 00:28:31,010
the payment doesn't happen you need

00:28:29,000 --> 00:28:33,800
proof and simple schemes cannot provide

00:28:31,010 --> 00:28:35,540
this proof of absence fortunately we do

00:28:33,800 --> 00:28:37,730
have a scheme that can provide proof of

00:28:35,540 --> 00:28:39,950
absence it's a fairly new technology and

00:28:37,730 --> 00:28:40,970
it is definitely being underused it is

00:28:39,950 --> 00:28:42,770
comes from the Byzantine generals

00:28:40,970 --> 00:28:44,300
problem I feel they are familiar with

00:28:42,770 --> 00:28:46,250
the business you generals problem anyone

00:28:44,300 --> 00:28:49,580
know the Byzantine generals plumbing I'd

00:28:46,250 --> 00:28:51,920
say probably ten fifteen percent so the

00:28:49,580 --> 00:28:53,000
basic idea is you have two generals they

00:28:51,920 --> 00:28:54,920
have two armies

00:28:53,000 --> 00:28:56,810
and one of them realizes that if they

00:28:54,920 --> 00:28:57,980
both attack a city the next day they'll

00:28:56,810 --> 00:29:00,080
be able to take it but if they attack

00:28:57,980 --> 00:29:02,870
alone either one of them alone will not

00:29:00,080 --> 00:29:04,400
be able to take the city so the general

00:29:02,870 --> 00:29:06,080
that realizes the plan is going to send

00:29:04,400 --> 00:29:08,330
a messenger to the other general saying

00:29:06,080 --> 00:29:10,220
let's both attack the city tomorrow the

00:29:08,330 --> 00:29:12,110
problem is the messenger might not get

00:29:10,220 --> 00:29:13,670
through but that's okay the receiving

00:29:12,110 --> 00:29:15,050
general can send a messenger back saying

00:29:13,670 --> 00:29:17,030
hey I got your message I'm attacking

00:29:15,050 --> 00:29:19,730
tomorrow but what if that messenger

00:29:17,030 --> 00:29:22,670
doesn't go go through does the sender

00:29:19,730 --> 00:29:24,500
attack or not and the problem is you can

00:29:22,670 --> 00:29:26,690
prove fairly simply that there is no

00:29:24,500 --> 00:29:28,310
solution to this problem as stated even

00:29:26,690 --> 00:29:30,560
with very simple requirements so simple

00:29:28,310 --> 00:29:31,940
requirements would be if no messages go

00:29:30,560 --> 00:29:33,830
through you can't attack because you

00:29:31,940 --> 00:29:35,690
don't have a joint plan if all the

00:29:33,830 --> 00:29:36,950
messages go through then both have to

00:29:35,690 --> 00:29:38,870
attack otherwise you don't have a

00:29:36,950 --> 00:29:40,460
solution even if nothing goes wrong and

00:29:38,870 --> 00:29:42,260
then the other requirement would be the

00:29:40,460 --> 00:29:43,430
number of messages has to be finite if

00:29:42,260 --> 00:29:45,140
you have a message that requires an

00:29:43,430 --> 00:29:46,760
infant a protocol that requires an

00:29:45,140 --> 00:29:48,620
infinite number of messages before it

00:29:46,760 --> 00:29:50,390
reaches a conclusion that's not a useful

00:29:48,620 --> 00:29:52,190
protocol now it seems that those

00:29:50,390 --> 00:29:54,050
requirements are simple and reasonable

00:29:52,190 --> 00:29:55,520
but they're too many there's a very

00:29:54,050 --> 00:29:56,960
simple formal proof that there are too

00:29:55,520 --> 00:29:58,370
many I'll give you the formal proof just

00:29:56,960 --> 00:29:59,900
in case anyone can follow it verbally

00:29:58,370 --> 00:30:01,190
because it's cool and then I'll give you

00:29:59,900 --> 00:30:03,410
an informal proof that's easier to

00:30:01,190 --> 00:30:05,300
follow the formal proof is this if there

00:30:03,410 --> 00:30:06,740
was some algorithm that guaranteed that

00:30:05,300 --> 00:30:09,140
both generals attacked or neither

00:30:06,740 --> 00:30:11,990
general attack it has to have a finite

00:30:09,140 --> 00:30:13,400
number of steps let's call that n so we

00:30:11,990 --> 00:30:15,290
have this algorithm that sends n

00:30:13,400 --> 00:30:18,290
messengers and then if no messengers

00:30:15,290 --> 00:30:21,140
fail they both attack now imagine if the

00:30:18,290 --> 00:30:23,570
last message doesn't go through and no

00:30:21,140 --> 00:30:25,100
messages after that go through well the

00:30:23,570 --> 00:30:26,870
person who sent that message doesn't

00:30:25,100 --> 00:30:29,120
know that message didn't go through so

00:30:26,870 --> 00:30:30,710
they still attack and since the

00:30:29,120 --> 00:30:32,150
algorithm presumably guarantees that

00:30:30,710 --> 00:30:34,430
either neither of them attack or both

00:30:32,150 --> 00:30:35,750
attack that means they both attack well

00:30:34,430 --> 00:30:37,040
if they're both going to attack even if

00:30:35,750 --> 00:30:38,240
the last message doesn't go through

00:30:37,040 --> 00:30:39,830
what's the point in sending the last

00:30:38,240 --> 00:30:41,090
message just don't send the last message

00:30:39,830 --> 00:30:43,040
and the algorithm still works but we

00:30:41,090 --> 00:30:44,930
have a problem we said that this was the

00:30:43,040 --> 00:30:46,130
message with the shortest number this

00:30:44,930 --> 00:30:47,870
was the protocol with the shortest

00:30:46,130 --> 00:30:49,910
number of messages we just found a

00:30:47,870 --> 00:30:51,530
protocol with one fewer message so we

00:30:49,910 --> 00:30:53,000
have a contradiction if we have an

00:30:51,530 --> 00:30:54,020
algorithm that works with n messages we

00:30:53,000 --> 00:30:55,430
have an algorithm that works with n

00:30:54,020 --> 00:30:57,500
minus 1 messages which means we don't

00:30:55,430 --> 00:31:01,040
have any algorithm at all a more

00:30:57,500 --> 00:31:02,180
informal proof is each general is only

00:31:01,040 --> 00:31:05,390
going to commit if the other side

00:31:02,180 --> 00:31:06,710
commits at some point some general has

00:31:05,390 --> 00:31:08,750
to commit a rebek

00:31:06,710 --> 00:31:10,400
some general has to say even if no more

00:31:08,750 --> 00:31:12,980
messages go through I'm attacking if

00:31:10,400 --> 00:31:15,350
nobody ever commits it never finishes

00:31:12,980 --> 00:31:17,210
and someone has to commit irrevocably

00:31:15,350 --> 00:31:19,190
first some general has to be the first

00:31:17,210 --> 00:31:20,960
general to say okay I've gotten enough

00:31:19,190 --> 00:31:23,090
messages I've sent enough messages I'm

00:31:20,960 --> 00:31:24,620
attacking but we can't commit a

00:31:23,090 --> 00:31:26,030
revocable until we know the other side

00:31:24,620 --> 00:31:27,680
has committed arabica beliefs so neither

00:31:26,030 --> 00:31:29,060
side can commit irrevocably first it's a

00:31:27,680 --> 00:31:30,890
little more informal but a little easier

00:31:29,060 --> 00:31:32,840
to follow and it also helps you to

00:31:30,890 --> 00:31:34,340
identify Byzantine generals problems

00:31:32,840 --> 00:31:36,830
when that argument applies you have a

00:31:34,340 --> 00:31:39,080
Byzantine generals problem many of you

00:31:36,830 --> 00:31:41,180
probably know that the TCP protocol does

00:31:39,080 --> 00:31:42,800
not guarantee that either both sides

00:31:41,180 --> 00:31:44,630
will see an error or neither side will

00:31:42,800 --> 00:31:46,460
how many of you know that most you know

00:31:44,630 --> 00:31:48,020
that doesn't provide that guarantee and

00:31:46,460 --> 00:31:50,000
it can't provide that guarantee because

00:31:48,020 --> 00:31:52,250
that's a business in generals problem so

00:31:50,000 --> 00:31:53,810
we have this sort of you send these sort

00:31:52,250 --> 00:31:55,400
of I'm done I'm done I'm done I hope you

00:31:53,810 --> 00:31:56,900
got one of those messages maybe you

00:31:55,400 --> 00:31:59,240
didn't but I'm not going to transmit

00:31:56,900 --> 00:32:00,920
anymore but we do not guarantee that

00:31:59,240 --> 00:32:02,930
either neither side will see an error or

00:32:00,920 --> 00:32:04,280
both sides well and also creates an

00:32:02,930 --> 00:32:06,020
interesting problem like you might think

00:32:04,280 --> 00:32:07,850
it's a simple problem to say I'm sending

00:32:06,020 --> 00:32:09,620
an email from one server to another and

00:32:07,850 --> 00:32:11,180
I want the sender to stop sending the

00:32:09,620 --> 00:32:12,650
email if and only if the receiving

00:32:11,180 --> 00:32:14,630
machine got it again Byzantine generals

00:32:12,650 --> 00:32:16,730
problem we run into the same

00:32:14,630 --> 00:32:18,410
complication but we have an algorithm

00:32:16,730 --> 00:32:19,730
that solves the Byzantine generals from

00:32:18,410 --> 00:32:21,920
I know I just said there was no solution

00:32:19,730 --> 00:32:23,300
it solves the problem by changing the

00:32:21,920 --> 00:32:24,920
constraints a little bit but really it's

00:32:23,300 --> 00:32:28,010
a realistic practical solution in fact

00:32:24,920 --> 00:32:30,830
the pbn pbft stands for prom the stand

00:32:28,010 --> 00:32:32,120
for practical I hope anyone know for

00:32:30,830 --> 00:32:33,800
sure my misremembering I think it stands

00:32:32,120 --> 00:32:36,200
for practical if not it could just as

00:32:33,800 --> 00:32:38,090
well so it's a Byzantine agreement

00:32:36,200 --> 00:32:40,010
protocol and it can tolerate some faulty

00:32:38,090 --> 00:32:42,380
nodes it can tolerate drop messages so

00:32:40,010 --> 00:32:44,810
long as enough of the nodes don't don't

00:32:42,380 --> 00:32:46,760
fail and it combines beautifully with

00:32:44,810 --> 00:32:48,440
crypto so as pbft was originally

00:32:46,760 --> 00:32:51,290
specified it didn't use any cryptography

00:32:48,440 --> 00:32:52,700
at all it combines nicely with crypto so

00:32:51,290 --> 00:32:54,500
what you can do with crypto is since all

00:32:52,700 --> 00:32:56,090
the participants are known you can give

00:32:54,500 --> 00:32:57,410
them a cryptographic identity and so

00:32:56,090 --> 00:32:58,880
they can't impersonate each other they

00:32:57,410 --> 00:33:00,440
can't send one thing to one participant

00:32:58,880 --> 00:33:02,900
another thing to another that makes pbft

00:33:00,440 --> 00:33:04,340
run really nicely another advantage is

00:33:02,900 --> 00:33:06,350
if you know what threshold signatures

00:33:04,340 --> 00:33:08,030
are threshold signatures are cases where

00:33:06,350 --> 00:33:09,560
you get cryptographic signatures from

00:33:08,030 --> 00:33:10,910
say seven out of ten participants or

00:33:09,560 --> 00:33:12,560
eight out of thirteen participants and

00:33:10,910 --> 00:33:14,720
you can combine them into a single

00:33:12,560 --> 00:33:16,430
signature so what you can do is if you

00:33:14,720 --> 00:33:17,870
have a Byzantine Agreement protocol and

00:33:16,430 --> 00:33:19,160
you have the correct quorum agreeing

00:33:17,870 --> 00:33:19,929
let's say eight out of thirteen degree

00:33:19,160 --> 00:33:21,820
you can

00:33:19,929 --> 00:33:23,350
a single digital signature as a proof of

00:33:21,820 --> 00:33:24,119
that agreement which is really really

00:33:23,350 --> 00:33:26,860
nice

00:33:24,119 --> 00:33:28,929
high-value payments and ILP is a BG

00:33:26,860 --> 00:33:31,690
problem so we want the sent the payment

00:33:28,929 --> 00:33:33,249
took Bob to happen if and only if the

00:33:31,690 --> 00:33:34,779
payment Alice happens and what that

00:33:33,249 --> 00:33:36,369
means is that the two Ledger's need to

00:33:34,779 --> 00:33:38,799
either agree that the payment happened

00:33:36,369 --> 00:33:41,139
or agree that it didn't consensus and

00:33:38,799 --> 00:33:42,940
ripple is a BG problem we want the all

00:33:41,139 --> 00:33:44,169
the service to agree on the transaction

00:33:42,940 --> 00:33:45,369
ordering we don't want someone to pick a

00:33:44,169 --> 00:33:47,980
particular ordering unless everybody

00:33:45,369 --> 00:33:49,690
else does the double spend problem the

00:33:47,980 --> 00:33:51,460
distributed ledger the distributed

00:33:49,690 --> 00:33:53,619
database agreement problem these are all

00:33:51,460 --> 00:33:55,119
BG problems in fact lots of problems or

00:33:53,619 --> 00:33:56,799
BG problems and we now have a solution

00:33:55,119 --> 00:33:58,809
to the Byzantine generals problem

00:33:56,799 --> 00:34:01,240
essentially we gather in an army of

00:33:58,809 --> 00:34:03,100
witnesses and we let the witnesses come

00:34:01,240 --> 00:34:04,659
to a consensus on whether we're going to

00:34:03,100 --> 00:34:06,879
do it or not they provide a digital

00:34:04,659 --> 00:34:08,829
signature and then everybody knows from

00:34:06,879 --> 00:34:10,750
that digital signature the thing that we

00:34:08,829 --> 00:34:12,790
give up potentially is liveness if the

00:34:10,750 --> 00:34:14,409
system fails that nobody knows may know

00:34:12,790 --> 00:34:17,040
what happened until the system recovers

00:34:14,409 --> 00:34:18,940
but that only happens if a quorum fails

00:34:17,040 --> 00:34:20,470
when we can minimize the probability

00:34:18,940 --> 00:34:21,790
that if there's not a single point of

00:34:20,470 --> 00:34:24,760
failure we can control the number of

00:34:21,790 --> 00:34:26,740
points of failure so it's easy to solve

00:34:24,760 --> 00:34:29,260
with algorithms like pbft and we only

00:34:26,740 --> 00:34:31,329
need those agreements to be private and

00:34:29,260 --> 00:34:32,889
ephemeral you can also do that with

00:34:31,329 --> 00:34:34,690
private blockchains private blockchains

00:34:32,889 --> 00:34:37,179
use Byzantine Agreement protocols like

00:34:34,690 --> 00:34:38,889
pbft so if you imagine a consortium of

00:34:37,179 --> 00:34:40,210
banks that set up some payment system

00:34:38,889 --> 00:34:42,339
they can set it up so that if eight of

00:34:40,210 --> 00:34:44,290
the 13 banks agree on a transaction the

00:34:42,339 --> 00:34:46,119
transaction goes through they can use

00:34:44,290 --> 00:34:48,569
something like pbft to agree on that

00:34:46,119 --> 00:34:48,569
transaction

00:34:48,869 --> 00:34:53,500
okay now we're all blockchain experts

00:34:51,250 --> 00:34:55,960
there is going to be some development in

00:34:53,500 --> 00:34:57,430
C++ content I promise promise we're

00:34:55,960 --> 00:34:59,170
getting there but had to make you all

00:34:57,430 --> 00:35:01,510
blockchain experts first those are block

00:34:59,170 --> 00:35:04,569
chains that's what they do so why are

00:35:01,510 --> 00:35:06,250
they hard to develop what's so difficult

00:35:04,569 --> 00:35:08,770
what are the unique software challenges

00:35:06,250 --> 00:35:10,690
that we need to solve with C++ first of

00:35:08,770 --> 00:35:11,859
all they have to be fortresses how many

00:35:10,690 --> 00:35:13,329
of you are familiar with any Bitcoin

00:35:11,859 --> 00:35:15,210
thefts there was a 70 million dollar

00:35:13,329 --> 00:35:17,680
theft just recently you probably know

00:35:15,210 --> 00:35:19,510
it's a huge huge huge problem and the

00:35:17,680 --> 00:35:21,309
reason the problem is so big is a couple

00:35:19,510 --> 00:35:23,650
of things but one of them is that we

00:35:21,309 --> 00:35:25,930
don't have a financial system built into

00:35:23,650 --> 00:35:27,609
the ledgers that can track the funds and

00:35:25,930 --> 00:35:28,960
recover them easily once the bitcoins

00:35:27,609 --> 00:35:31,030
are transferred they belong to another

00:35:28,960 --> 00:35:33,040
cryptographic identity they can sit

00:35:31,030 --> 00:35:33,260
silently for months or years and there's

00:35:33,040 --> 00:35:35,090
no

00:35:33,260 --> 00:35:36,980
to recover them there's no legal process

00:35:35,090 --> 00:35:38,150
well I guess you could have a hard fork

00:35:36,980 --> 00:35:39,620
and if you know about the etherium hard

00:35:38,150 --> 00:35:41,240
fork you can sort of everyone have

00:35:39,620 --> 00:35:43,130
everyone agree to wind the ledger back

00:35:41,240 --> 00:35:45,830
but that didn't happen for a 70 million

00:35:43,130 --> 00:35:48,110
dollar theft so and the code is public

00:35:45,830 --> 00:35:49,400
so you can't hide your flaws you can't

00:35:48,110 --> 00:35:52,130
put in a comment you know if anyone

00:35:49,400 --> 00:35:54,260
figured this out we'd be screwed no you

00:35:52,130 --> 00:35:55,220
might not put the comment in but someone

00:35:54,260 --> 00:35:57,290
will figure it out so this is the

00:35:55,220 --> 00:36:00,430
problem you got a multi-billion dollar

00:35:57,290 --> 00:36:02,810
bug bounty so there's a tremendous

00:36:00,430 --> 00:36:05,240
incentive for people to find the bugs

00:36:02,810 --> 00:36:06,560
and because if they find bugs they could

00:36:05,240 --> 00:36:07,820
steal potentially millions of dollars

00:36:06,560 --> 00:36:10,160
and they're very unlikely to get caught

00:36:07,820 --> 00:36:13,970
that stresses people's morals a little

00:36:10,160 --> 00:36:16,010
bit I know if I found a bug in Cisco

00:36:13,970 --> 00:36:17,540
software if I found a bug and you know

00:36:16,010 --> 00:36:18,800
Apache I would probably do the right

00:36:17,540 --> 00:36:20,690
thing and tell the community but if I

00:36:18,800 --> 00:36:22,190
found a bug that I can make seventy

00:36:20,690 --> 00:36:24,740
million dollars on a my probability of

00:36:22,190 --> 00:36:26,450
getting caught is pretty low I like to

00:36:24,740 --> 00:36:29,630
think that you know I would do the right

00:36:26,450 --> 00:36:31,070
thing but I won't ask for a show of

00:36:29,630 --> 00:36:32,510
hands who would do the right thing in

00:36:31,070 --> 00:36:35,390
that circumstance because I don't think

00:36:32,510 --> 00:36:37,250
you'll be honest but you know it's AB

00:36:35,390 --> 00:36:38,900
it's a huge huge problem I can't I can't

00:36:37,250 --> 00:36:40,040
stress how big a problem it is and the

00:36:38,900 --> 00:36:41,720
other problem is even if it doesn't

00:36:40,040 --> 00:36:43,100
allow a theft let's just say it corrupts

00:36:41,720 --> 00:36:45,200
the blockchain let's just say creates an

00:36:43,100 --> 00:36:46,850
invalid state on the blockchain you have

00:36:45,200 --> 00:36:49,610
to get everybody to agree to rewind it

00:36:46,850 --> 00:36:51,290
and that's not an easy thing we've had

00:36:49,610 --> 00:36:53,780
very good luck Bitcoin had a problem

00:36:51,290 --> 00:36:56,300
like that there was a block there was a

00:36:53,780 --> 00:36:57,950
hard fork between two it was an

00:36:56,300 --> 00:36:59,660
inadvertent mistake a small bug in the

00:36:57,950 --> 00:37:00,830
software caused the two versions of the

00:36:59,660 --> 00:37:02,600
software to have different rules for

00:37:00,830 --> 00:37:03,950
what makes a block valid and so they

00:37:02,600 --> 00:37:05,690
didn't agree on what the longest chain

00:37:03,950 --> 00:37:07,130
was and there were double spins there

00:37:05,690 --> 00:37:08,510
were spends on one chain that weren't on

00:37:07,130 --> 00:37:10,790
the other chain and people lost money

00:37:08,510 --> 00:37:12,440
it's impressive that the community was

00:37:10,790 --> 00:37:14,150
able to come together and agree on how

00:37:12,440 --> 00:37:17,030
to fix that but that is very very

00:37:14,150 --> 00:37:18,830
painful very painful this makes

00:37:17,030 --> 00:37:21,170
development slow if you're developing

00:37:18,830 --> 00:37:23,360
software that everybody can see the code

00:37:21,170 --> 00:37:25,100
to development is much slower I guess an

00:37:23,360 --> 00:37:26,510
analogy would be imagine you're building

00:37:25,100 --> 00:37:28,730
an operating system like let's say Linux

00:37:26,510 --> 00:37:31,040
and you want to protect it from network

00:37:28,730 --> 00:37:32,570
attacks that's not too bad now you want

00:37:31,040 --> 00:37:34,160
to protect it from local attacks by

00:37:32,570 --> 00:37:35,930
people who have user accounts that's a

00:37:34,160 --> 00:37:37,700
lot harder because people have a lot

00:37:35,930 --> 00:37:39,170
more access to the system they have a

00:37:37,700 --> 00:37:40,640
lot more knowledge they have a lot more

00:37:39,170 --> 00:37:41,960
control it's much more difficult to

00:37:40,640 --> 00:37:44,630
protect the system against the local

00:37:41,960 --> 00:37:47,060
user than a remote maybe makes

00:37:44,630 --> 00:37:48,770
development as much as ten times slower

00:37:47,060 --> 00:37:51,530
maybe not quite that bad maybe worse

00:37:48,770 --> 00:37:52,850
depending very very paranoid the other

00:37:51,530 --> 00:37:54,530
problem is when you're developing

00:37:52,850 --> 00:37:55,640
mission critical software typically you

00:37:54,530 --> 00:37:57,020
put out a new release and you tell

00:37:55,640 --> 00:37:58,310
people if your software's

00:37:57,020 --> 00:37:59,720
mission-critical don't upgrade to this

00:37:58,310 --> 00:38:01,400
release just wait unless there's

00:37:59,720 --> 00:38:03,500
something you really need just wait test

00:38:01,400 --> 00:38:04,850
it out see how you like it block chains

00:38:03,500 --> 00:38:06,890
have to have agreement by the entire

00:38:04,850 --> 00:38:08,390
world so we can't do that we can't tell

00:38:06,890 --> 00:38:09,590
people that they can run a new version

00:38:08,390 --> 00:38:11,870
of the software unless they run it on a

00:38:09,590 --> 00:38:13,550
separate network and one of the problems

00:38:11,870 --> 00:38:15,230
is if any of you have released beta know

00:38:13,550 --> 00:38:16,490
release betas and you try to get bug

00:38:15,230 --> 00:38:18,260
requests you always get the bug reports

00:38:16,490 --> 00:38:20,000
five minutes after the beta goes gold

00:38:18,260 --> 00:38:21,980
that's always what happens people won't

00:38:20,000 --> 00:38:24,020
test a beta you try to get them

00:38:21,980 --> 00:38:25,400
hopefully big business isn't it means a

00:38:24,020 --> 00:38:26,810
lot of money they will but they won't

00:38:25,400 --> 00:38:29,510
because they have to build duplicates of

00:38:26,810 --> 00:38:30,590
their systems that work on the beta it

00:38:29,510 --> 00:38:31,790
won't replicate the real situation

00:38:30,590 --> 00:38:34,640
because they're not going to build

00:38:31,790 --> 00:38:37,160
everything on the test system so public

00:38:34,640 --> 00:38:39,500
block chains must be fortresses and that

00:38:37,160 --> 00:38:41,690
is one of the reasons that we like C++

00:38:39,500 --> 00:38:43,280
and I'll show you why later we also have

00:38:41,690 --> 00:38:44,960
to manage our resources we have to keep

00:38:43,280 --> 00:38:46,040
up with the network we don't want to

00:38:44,960 --> 00:38:48,200
fall behind people want to know that

00:38:46,040 --> 00:38:49,880
they got their money immediately if

00:38:48,200 --> 00:38:51,590
someone's making a payments us instant

00:38:49,880 --> 00:38:53,090
satisfaction is extremely important one

00:38:51,590 --> 00:38:54,230
of the big advantages in these systems

00:38:53,090 --> 00:38:55,760
is that they're quick so we have to keep

00:38:54,230 --> 00:38:58,490
up with the network we can't just fall

00:38:55,760 --> 00:38:59,840
further and further behind some servers

00:38:58,490 --> 00:39:01,940
have to respond to remote queries so

00:38:59,840 --> 00:39:03,320
remote servers will ask them for

00:39:01,940 --> 00:39:06,170
information they have to manage those

00:39:03,320 --> 00:39:07,880
resources and not fall behind some of

00:39:06,170 --> 00:39:10,190
them have to deal with local quarries so

00:39:07,880 --> 00:39:11,660
the Bitcoin network stays stable because

00:39:10,190 --> 00:39:13,670
people are willing to give information

00:39:11,660 --> 00:39:15,200
to each other if I need history if I

00:39:13,670 --> 00:39:16,790
shut my server up and turn it back on

00:39:15,200 --> 00:39:18,380
other servers generously give me the

00:39:16,790 --> 00:39:20,150
information that I missed they have to

00:39:18,380 --> 00:39:21,740
be able to do that without overloading

00:39:20,150 --> 00:39:23,510
themselves and because it's a public

00:39:21,740 --> 00:39:24,740
network and there are no identities they

00:39:23,510 --> 00:39:25,970
have to protect themselves against

00:39:24,740 --> 00:39:28,340
attacks have to manage the resources

00:39:25,970 --> 00:39:30,680
intelligently they have to cache you

00:39:28,340 --> 00:39:32,150
have no choice you need binary formats

00:39:30,680 --> 00:39:34,250
for data representation because you have

00:39:32,150 --> 00:39:35,870
to sign transactions all kinds of

00:39:34,250 --> 00:39:37,700
objects have to be hashed that requires

00:39:35,870 --> 00:39:39,350
a single binary representation you have

00:39:37,700 --> 00:39:41,060
to have unique binary representations

00:39:39,350 --> 00:39:42,980
but humans don't like binary

00:39:41,060 --> 00:39:44,740
representations very well that's why I'm

00:39:42,980 --> 00:39:46,880
not giving this talk in ones and zeros

00:39:44,740 --> 00:39:48,440
javascript likes them too javascript

00:39:46,880 --> 00:39:50,420
likes json a lot and if you're not

00:39:48,440 --> 00:39:52,460
careful you can wind up with a situation

00:39:50,420 --> 00:39:54,050
where if you push something to jason and

00:39:52,460 --> 00:39:55,970
then back to binary you don't get

00:39:54,050 --> 00:39:57,230
exactly the same binary data back and

00:39:55,970 --> 00:39:59,210
you need that because otherwise the

00:39:57,230 --> 00:40:00,860
signatures and hashes won't check so you

00:39:59,210 --> 00:40:04,070
need good binary form

00:40:00,860 --> 00:40:06,080
and you need performance on everything

00:40:04,070 --> 00:40:07,400
so some tasks are embarrassingly

00:40:06,080 --> 00:40:09,200
parallel a good example is checking

00:40:07,400 --> 00:40:10,610
digital signatures one of the biggest

00:40:09,200 --> 00:40:12,020
things that blockchain software does

00:40:10,610 --> 00:40:13,700
it's a significant fraction of its

00:40:12,020 --> 00:40:15,380
computational effort is it checks the

00:40:13,700 --> 00:40:17,090
digital signatures on transactions

00:40:15,380 --> 00:40:19,460
because these use public/private keys

00:40:17,090 --> 00:40:21,140
they don't use they don't they don't use

00:40:19,460 --> 00:40:22,820
shared keys because no one's going to

00:40:21,140 --> 00:40:24,110
share the key to controls their money

00:40:22,820 --> 00:40:25,910
with anyone else

00:40:24,110 --> 00:40:27,140
that's a lot of work checking those

00:40:25,910 --> 00:40:29,270
those digital signatures but it

00:40:27,140 --> 00:40:31,670
paralyzes beautifully once you have the

00:40:29,270 --> 00:40:33,170
key the transaction and the signature

00:40:31,670 --> 00:40:34,550
you can check whether the signature is

00:40:33,170 --> 00:40:36,080
valid once and for all you don't need

00:40:34,550 --> 00:40:38,270
any other data itself contains that

00:40:36,080 --> 00:40:40,970
paralyzes beautifully but some tasks

00:40:38,270 --> 00:40:42,920
don't paralyze at all so when you're

00:40:40,970 --> 00:40:44,090
executing the transactions for real you

00:40:42,920 --> 00:40:45,500
have to execute them one at a time

00:40:44,090 --> 00:40:47,300
because you can't have two transactions

00:40:45,500 --> 00:40:48,770
that conflict with each other and it is

00:40:47,300 --> 00:40:50,150
all important you need super high

00:40:48,770 --> 00:40:52,130
performance both for the things that

00:40:50,150 --> 00:40:53,660
paralyze and the things that don't some

00:40:52,130 --> 00:40:54,680
languages are really good at one some

00:40:53,660 --> 00:40:56,480
languages are really good at the other

00:40:54,680 --> 00:40:58,310
there aren't that many that give you a

00:40:56,480 --> 00:41:01,220
lot of flexibility to do both and

00:40:58,310 --> 00:41:02,480
blockchains do not scale horizontally we

00:41:01,220 --> 00:41:04,160
can't make Bitcoin handle more

00:41:02,480 --> 00:41:06,260
transactions by adding more servers that

00:41:04,160 --> 00:41:07,970
doesn't work that way every server has

00:41:06,260 --> 00:41:09,470
to see every transaction to know the

00:41:07,970 --> 00:41:11,420
state of the network and so we're

00:41:09,470 --> 00:41:13,370
limited by essentially the slowest

00:41:11,420 --> 00:41:14,840
machine we're willing to support we do

00:41:13,370 --> 00:41:16,370
not have horizontal scaling that

00:41:14,840 --> 00:41:20,300
blocking it so performance is super

00:41:16,370 --> 00:41:21,890
super important naive C++ code compared

00:41:20,300 --> 00:41:23,360
to naive JavaScript code let's say to

00:41:21,890 --> 00:41:25,160
solve the same problems about a factor

00:41:23,360 --> 00:41:27,530
of five and performance so you really

00:41:25,160 --> 00:41:30,830
you really need to be able to control

00:41:27,530 --> 00:41:32,690
what you're making the system do and we

00:41:30,830 --> 00:41:35,000
also need isolation because transactions

00:41:32,690 --> 00:41:36,830
have to be deterministic some designs

00:41:35,000 --> 00:41:38,750
fail catastrophically if you imagine

00:41:36,830 --> 00:41:40,010
that I send out the same transaction to

00:41:38,750 --> 00:41:41,360
two different machines and due to some

00:41:40,010 --> 00:41:43,370
software bug it produces different

00:41:41,360 --> 00:41:44,750
results on those two machines then we

00:41:43,370 --> 00:41:46,490
won't have eventual agreement we'll have

00:41:44,750 --> 00:41:49,160
disagreement and that would be very

00:41:46,490 --> 00:41:51,020
catastrophic it's very easy to get

00:41:49,160 --> 00:41:53,090
non-deterministic behavior by accident

00:41:51,020 --> 00:41:54,650
you'd be surprised how easy it is to

00:41:53,090 --> 00:41:56,060
accidentally write code that behaves in

00:41:54,650 --> 00:41:58,400
some kind of non-deterministic way

00:41:56,060 --> 00:42:00,470
unfortunately it is fairly easy to do

00:41:58,400 --> 00:42:02,060
especially in smart contracts smart

00:42:00,470 --> 00:42:03,950
contracts is essentially code that

00:42:02,060 --> 00:42:06,230
manages intelligently the movement of

00:42:03,950 --> 00:42:07,850
assets it's very easy to accidentally

00:42:06,230 --> 00:42:09,290
make a smart contract that's behavior is

00:42:07,850 --> 00:42:12,260
non-deterministic and if the system

00:42:09,290 --> 00:42:13,920
crashes or fails or something horrible

00:42:12,260 --> 00:42:15,150
happens when you have non-deterministic

00:42:13,920 --> 00:42:17,190
that's a problem the way you solve that

00:42:15,150 --> 00:42:18,240
is isolation you don't give the code

00:42:17,190 --> 00:42:19,950
access to anything that's

00:42:18,240 --> 00:42:23,579
non-deterministic so it cannot behave

00:42:19,950 --> 00:42:25,020
non-deterministically so finally the C++

00:42:23,579 --> 00:42:26,790
content so how do you meet these

00:42:25,020 --> 00:42:28,619
challenges with C++ well that's what

00:42:26,790 --> 00:42:31,349
we've been doing we've been writing

00:42:28,619 --> 00:42:33,000
botching software for many years in C++

00:42:31,349 --> 00:42:35,809
the Bitcoin project's primary

00:42:33,000 --> 00:42:38,369
implementation is in C++ C++ seems to be

00:42:35,809 --> 00:42:42,869
probably the primary language of choice

00:42:38,369 --> 00:42:44,940
here so what does C++ do and a lot of

00:42:42,869 --> 00:42:46,980
this stuff almost everything except one

00:42:44,940 --> 00:42:48,210
thing is specific to C++ it's not in C

00:42:46,980 --> 00:42:50,069
so if some of you guys are trying to

00:42:48,210 --> 00:42:51,420
persuade people to switch from C to C

00:42:50,069 --> 00:42:53,430
plus bus that you know they need to get

00:42:51,420 --> 00:42:54,869
with the times some of these some of

00:42:53,430 --> 00:42:57,119
these points may help because these are

00:42:54,869 --> 00:42:58,410
things that are except for one of these

00:42:57,119 --> 00:43:01,559
are things that are difficult to get in

00:42:58,410 --> 00:43:03,540
C so one of them is move semantics move

00:43:01,559 --> 00:43:05,490
semantics allow types to have value

00:43:03,540 --> 00:43:06,990
semantics so by value semantics I mean a

00:43:05,490 --> 00:43:08,910
type that behaves like an integer you

00:43:06,990 --> 00:43:10,380
can pass it by reference you can pass it

00:43:08,910 --> 00:43:12,480
by Const reference you can pass it by

00:43:10,380 --> 00:43:14,220
value you can stash it in a lambda you

00:43:12,480 --> 00:43:15,390
can store it in a container you do

00:43:14,220 --> 00:43:16,530
whatever you want with it and you don't

00:43:15,390 --> 00:43:18,359
have to worry about some weird

00:43:16,530 --> 00:43:20,579
requirement that's imposed on it where

00:43:18,359 --> 00:43:22,200
it doesn't really behave like a value so

00:43:20,579 --> 00:43:24,540
move semantics mean that you only get

00:43:22,200 --> 00:43:26,250
copies when you need them and one of the

00:43:24,540 --> 00:43:27,660
big problems with value semantics is

00:43:26,250 --> 00:43:28,950
that you get copies everywhere you just

00:43:27,660 --> 00:43:30,390
wind up with code that has lots and lots

00:43:28,950 --> 00:43:32,099
and lots of copies move semantics

00:43:30,390 --> 00:43:33,660
eliminate a significant fraction of

00:43:32,099 --> 00:43:36,690
those copies with minimal effort

00:43:33,660 --> 00:43:40,619
sometimes none usually very very little

00:43:36,690 --> 00:43:42,180
effort a huge huge performance boost C++

00:43:40,619 --> 00:43:43,470
has lambdas which enable visitor

00:43:42,180 --> 00:43:45,380
patterns and allow you to preserve

00:43:43,470 --> 00:43:47,700
layering so what I mean by that is

00:43:45,380 --> 00:43:49,020
imagine you have a container and you

00:43:47,700 --> 00:43:50,700
want to perform some operation on that

00:43:49,020 --> 00:43:52,380
container but it's complicated so you

00:43:50,700 --> 00:43:54,030
need to acquire a lock on the container

00:43:52,380 --> 00:43:55,530
perform the operation and then release

00:43:54,030 --> 00:43:58,049
the lock well you don't want the

00:43:55,530 --> 00:43:59,670
container to export its lock that's a

00:43:58,049 --> 00:44:01,109
layering problem we want the container

00:43:59,670 --> 00:44:03,089
to manage its own locking so with a

00:44:01,109 --> 00:44:04,559
lambda we can package up the logic

00:44:03,089 --> 00:44:06,780
that's going to apply on the container

00:44:04,559 --> 00:44:08,880
and hand the logic to the container the

00:44:06,780 --> 00:44:10,710
container can acquire the lock process

00:44:08,880 --> 00:44:12,510
the logic and release the lock that

00:44:10,710 --> 00:44:15,210
allows the clock to be managed by the

00:44:12,510 --> 00:44:16,740
container lambdas also allow work to be

00:44:15,210 --> 00:44:18,240
deferred in dispatch so we can package

00:44:16,740 --> 00:44:20,190
up some work that has to go into a

00:44:18,240 --> 00:44:21,660
lambda if that work needs to be done

00:44:20,190 --> 00:44:22,920
later we can pick it up when we're ready

00:44:21,660 --> 00:44:24,660
I don't know if many of you are familiar

00:44:22,920 --> 00:44:26,210
with boost Co routines and I understand

00:44:24,660 --> 00:44:28,940
the standard library there's some work

00:44:26,210 --> 00:44:30,859
on ko routines for C++ 17 tremendously

00:44:28,940 --> 00:44:32,630
valuable to be able to do some work and

00:44:30,859 --> 00:44:33,830
then defer it until you have some other

00:44:32,630 --> 00:44:35,869
information that you need and then

00:44:33,830 --> 00:44:37,099
resume the work very very clean and

00:44:35,869 --> 00:44:38,480
elegant you don't wind up having to

00:44:37,099 --> 00:44:40,190
package all the information into an

00:44:38,480 --> 00:44:42,950
object or doing other ugly things with

00:44:40,190 --> 00:44:45,500
your state big one for us is compiled

00:44:42,950 --> 00:44:48,050
time polymorphism this this has been

00:44:45,500 --> 00:44:50,300
massive mostly because polymorphic code

00:44:48,050 --> 00:44:52,460
fully optimizes so if you use runtime

00:44:50,300 --> 00:44:54,200
polymorphism with virtual functions it's

00:44:52,460 --> 00:44:55,430
very difficult the optimizer to optimize

00:44:54,200 --> 00:44:56,510
through because the compile time it has

00:44:55,430 --> 00:44:59,359
no idea what function is going to be

00:44:56,510 --> 00:45:00,950
called compiled time polymorphism even

00:44:59,359 --> 00:45:03,020
in lines and it allows you to respond

00:45:00,950 --> 00:45:04,460
separate responsibilities cleanly so you

00:45:03,020 --> 00:45:06,170
can put some of the code in the

00:45:04,460 --> 00:45:07,369
polymorphic class and you can put some

00:45:06,170 --> 00:45:09,680
of the code in the code that calls it

00:45:07,369 --> 00:45:11,420
the responsibilities separate nicely and

00:45:09,680 --> 00:45:14,660
you still get optimization all the way

00:45:11,420 --> 00:45:16,099
across it tremendously valuable c++ has

00:45:14,660 --> 00:45:18,050
type composition which means you write

00:45:16,099 --> 00:45:19,730
code once and you get a nice API boost

00:45:18,050 --> 00:45:21,920
optional is a good example gonna have

00:45:19,730 --> 00:45:23,180
standard optional will see standard

00:45:21,920 --> 00:45:25,820
shared pointer and weak pointer same

00:45:23,180 --> 00:45:27,290
thing so I can take any class and I can

00:45:25,820 --> 00:45:28,670
wrap it in boost optional or shared

00:45:27,290 --> 00:45:30,140
point or a weak pointer and I know what

00:45:28,670 --> 00:45:31,520
I'm getting I know I'm getting an

00:45:30,140 --> 00:45:32,990
optional class I'm getting a class that

00:45:31,520 --> 00:45:35,240
has strong and weak pointers I get a

00:45:32,990 --> 00:45:36,770
very nice API and I don't have to tweak

00:45:35,240 --> 00:45:40,520
it for the class or do anything fancy

00:45:36,770 --> 00:45:41,930
and it's all optimizes through we have

00:45:40,520 --> 00:45:43,849
code isolation features we have

00:45:41,930 --> 00:45:45,170
namespaces we can import one namespace

00:45:43,849 --> 00:45:46,550
into another which we don't have name

00:45:45,170 --> 00:45:49,070
conflicts helps with large-scale

00:45:46,550 --> 00:45:50,900
development and the other thing that has

00:45:49,070 --> 00:45:52,730
also proven to be very valuable is that

00:45:50,900 --> 00:45:55,040
a class can be a boundary between two

00:45:52,730 --> 00:45:56,839
API so a class can have an API for its

00:45:55,040 --> 00:45:58,280
use so somebody the public functions and

00:45:56,839 --> 00:46:00,109
that can it can have an API for

00:45:58,280 --> 00:46:02,060
derivation those would be its protected

00:46:00,109 --> 00:46:04,460
functions so a class can be an API

00:46:02,060 --> 00:46:05,810
boundary providing to clean API is one

00:46:04,460 --> 00:46:07,040
on each side those can be documented

00:46:05,810 --> 00:46:08,740
maintained have different

00:46:07,040 --> 00:46:11,330
implementations different clients

00:46:08,740 --> 00:46:13,130
extremely useful we have a lot of mature

00:46:11,330 --> 00:46:15,560
tools we have at least three solid

00:46:13,130 --> 00:46:17,510
compilers we have ICC we have GCC we

00:46:15,560 --> 00:46:19,310
have clang we have tools for performance

00:46:17,510 --> 00:46:21,050
analysis we have tools for finding

00:46:19,310 --> 00:46:23,359
concurrency violations you name it we

00:46:21,050 --> 00:46:25,940
have nice graphical ID es we have

00:46:23,359 --> 00:46:28,550
libraries for just about everything it's

00:46:25,940 --> 00:46:32,240
not a new language it's extremely mature

00:46:28,550 --> 00:46:33,619
the tool chain is mature except

00:46:32,240 --> 00:46:34,910
sometimes I think we've all had this

00:46:33,619 --> 00:46:36,349
experience where you have an extra pound

00:46:34,910 --> 00:46:39,970
sign or an extra semicolon and a header

00:46:36,349 --> 00:46:42,040
file this was a 3k 32k error mess

00:46:39,970 --> 00:46:43,720
which none of this code is the code that

00:46:42,040 --> 00:46:45,430
had the error in it this is just a

00:46:43,720 --> 00:46:49,930
randomly selected excerpt as some boost

00:46:45,430 --> 00:46:51,310
code in here I don't know why any of you

00:46:49,930 --> 00:46:53,080
guys can do anything about that that is

00:46:51,310 --> 00:46:54,460
a a minor irritation and source of

00:46:53,080 --> 00:46:55,750
amusement but I guess the source of

00:46:54,460 --> 00:46:58,900
amusement is a good thing we all get

00:46:55,750 --> 00:47:00,400
bored sometimes um this is also a si

00:46:58,900 --> 00:47:01,869
feature this is the one C++ feature

00:47:00,400 --> 00:47:04,869
that's not just C++ we have hand

00:47:01,869 --> 00:47:06,160
optimized primitives so very little code

00:47:04,869 --> 00:47:07,240
is worth hand optimizing you're not

00:47:06,160 --> 00:47:08,619
going to write a major project in

00:47:07,240 --> 00:47:11,470
assembly language you'd have to update

00:47:08,619 --> 00:47:13,720
it for new CPUs and but there is some

00:47:11,470 --> 00:47:15,609
code that benefits tremendously from

00:47:13,720 --> 00:47:17,530
hand optimization digital signatures are

00:47:15,609 --> 00:47:21,460
a good example digital signatures are

00:47:17,530 --> 00:47:23,650
worth hand optimizing and one of the

00:47:21,460 --> 00:47:25,540
amazing things about both C and C++ is

00:47:23,650 --> 00:47:28,119
these calls are really cheap

00:47:25,540 --> 00:47:30,400
they can even inline so you can have a

00:47:28,119 --> 00:47:32,800
piece of hand optimized assembler that

00:47:30,400 --> 00:47:34,869
will inline into your C++ code and the

00:47:32,800 --> 00:47:37,030
optimizer will optimize across the

00:47:34,869 --> 00:47:38,650
inlined assembly code that that's pretty

00:47:37,030 --> 00:47:40,450
amazing that's pretty amazing stuff like

00:47:38,650 --> 00:47:42,250
in other languages typically you have a

00:47:40,450 --> 00:47:43,180
function that can be hand optimized but

00:47:42,250 --> 00:47:44,349
then when you call in to the function

00:47:43,180 --> 00:47:45,609
you might have to push stuff on the

00:47:44,349 --> 00:47:47,380
stack when you return from the function

00:47:45,609 --> 00:47:49,359
you have to pop stuff off the stack and

00:47:47,380 --> 00:47:50,710
it becomes like a hard optimization

00:47:49,359 --> 00:47:52,720
boundary everything in the registers

00:47:50,710 --> 00:47:54,760
gets pushed to memory you don't have

00:47:52,720 --> 00:47:56,530
that in C and C++ and we can leverage

00:47:54,760 --> 00:47:59,140
work across projects so if someone makes

00:47:56,530 --> 00:48:00,730
the digital signature implementation we

00:47:59,140 --> 00:48:03,070
can use it in any number of projects we

00:48:00,730 --> 00:48:04,540
have lots of mature libraries I did have

00:48:03,070 --> 00:48:05,770
to include one bad thing which is the

00:48:04,540 --> 00:48:08,470
slicing problem I think that's probably

00:48:05,770 --> 00:48:10,000
the biggest problem in C++ right now at

00:48:08,470 --> 00:48:12,460
least from the development that I've

00:48:10,000 --> 00:48:14,080
done we like value semantics we like

00:48:12,460 --> 00:48:15,970
classes that behave like integers and

00:48:14,080 --> 00:48:17,800
polymorphism and value semantics mix

00:48:15,970 --> 00:48:19,270
badly so if you have a reference to

00:48:17,800 --> 00:48:20,830
something or if you have a pointer to it

00:48:19,270 --> 00:48:22,390
you can't easily copy it you can't

00:48:20,830 --> 00:48:25,150
necessarily stash it somewhere you can't

00:48:22,390 --> 00:48:26,589
manage its lifetime that's a problem we

00:48:25,150 --> 00:48:27,849
have a lot of solutions that sometimes

00:48:26,589 --> 00:48:29,349
are at the right solution you can take a

00:48:27,849 --> 00:48:31,300
raw pointer and at least then you can

00:48:29,349 --> 00:48:33,040
pass it around you can have a unique

00:48:31,300 --> 00:48:34,390
pointer at least then the lifetime is

00:48:33,040 --> 00:48:35,950
managed for you but what if you need to

00:48:34,390 --> 00:48:37,270
stash it in a collection you can use a

00:48:35,950 --> 00:48:40,660
shared pointer

00:48:37,270 --> 00:48:43,240
protip you can create a standard shared

00:48:40,660 --> 00:48:45,640
pointer to T Const where the Const is

00:48:43,240 --> 00:48:48,430
inside the parameter to the shared

00:48:45,640 --> 00:48:51,369
pointer that way you're giving the

00:48:48,430 --> 00:48:52,810
callers a Const shared but it's not the

00:48:51,369 --> 00:48:53,700
shared point of itself that's constants

00:48:52,810 --> 00:48:54,960
the T that's

00:48:53,700 --> 00:48:56,430
which means they can't change its value

00:48:54,960 --> 00:48:58,140
one of the problems with shared pointers

00:48:56,430 --> 00:48:59,790
is if you pass them all around and

00:48:58,140 --> 00:49:01,320
someone modifies the object at the point

00:48:59,790 --> 00:49:02,700
of points - it modifies every instance

00:49:01,320 --> 00:49:04,560
of the object you want to catch a

00:49:02,700 --> 00:49:07,110
mistake like that at compile time make a

00:49:04,560 --> 00:49:08,940
shared pointer to a T Const can't

00:49:07,110 --> 00:49:11,160
manipulate the object you'll catch those

00:49:08,940 --> 00:49:12,570
errors at compile time so the clone

00:49:11,160 --> 00:49:16,740
idiom you can have a virtual function

00:49:12,570 --> 00:49:18,330
that duplicates a class it's not a great

00:49:16,740 --> 00:49:20,040
solution it doesn't wrap into standard

00:49:18,330 --> 00:49:21,900
containers nicely we have boost pointer

00:49:20,040 --> 00:49:23,550
vector but there are often situations

00:49:21,900 --> 00:49:27,030
where one of these solutions is the

00:49:23,550 --> 00:49:29,190
solution not a big deal if you can use

00:49:27,030 --> 00:49:30,630
it compile time polymorphism is the best

00:49:29,190 --> 00:49:31,770
solution for all the reasons that I

00:49:30,630 --> 00:49:34,020
discussed before compiled time

00:49:31,770 --> 00:49:36,180
polymorphism because of the optimization

00:49:34,020 --> 00:49:38,160
to catch bugs at compile time it's

00:49:36,180 --> 00:49:40,350
really nice a standard variant if it

00:49:38,160 --> 00:49:42,390
gets into c++ 17 I think there were some

00:49:40,350 --> 00:49:44,220
talks about standard variant standard

00:49:42,390 --> 00:49:46,110
variant is a discriminated union so it

00:49:44,220 --> 00:49:47,520
knows what type it is and it can say if

00:49:46,110 --> 00:49:48,900
I'm holding this type we call this

00:49:47,520 --> 00:49:50,610
function if I'm holding this other type

00:49:48,900 --> 00:49:52,260
we call this other function you can get

00:49:50,610 --> 00:49:54,300
compiled you can get polymorphic

00:49:52,260 --> 00:49:55,740
behavior in a type that knows how to

00:49:54,300 --> 00:50:00,150
copy itself without having to use a

00:49:55,740 --> 00:50:02,730
clone idiom so let me give you some very

00:50:00,150 --> 00:50:04,530
specific examples of wait that's lies

00:50:02,730 --> 00:50:04,830
not sorry yeah much better sorry about

00:50:04,530 --> 00:50:06,630
that

00:50:04,830 --> 00:50:09,780
let me give you some specific examples

00:50:06,630 --> 00:50:11,340
of things that we've done in C++ ways

00:50:09,780 --> 00:50:12,900
that we've built up software capital

00:50:11,340 --> 00:50:15,360
ways that we've eliminated technical

00:50:12,900 --> 00:50:16,380
debt ways that we've used modern C++

00:50:15,360 --> 00:50:19,170
idioms to produce high-quality

00:50:16,380 --> 00:50:20,460
blockchain code so one of them is in our

00:50:19,170 --> 00:50:22,290
caching we'll use strong and weak

00:50:20,460 --> 00:50:24,720
pointers the cache holds strong and weak

00:50:22,290 --> 00:50:27,810
pointers and this is how look someone's

00:50:24,720 --> 00:50:29,370
on skype I meant to put it in airplane

00:50:27,810 --> 00:50:31,170
mode and forgotten even know who Pedro

00:50:29,370 --> 00:50:35,550
Moreno Sanchez is he's available of

00:50:31,170 --> 00:50:36,960
anyway anyway so we use strong and weak

00:50:35,550 --> 00:50:38,250
pointers in the cache the cache will

00:50:36,960 --> 00:50:39,540
either hold a strong pointer to an

00:50:38,250 --> 00:50:41,160
object or a weak pointer the strong

00:50:39,540 --> 00:50:44,040
pointer keeps the object alive and the

00:50:41,160 --> 00:50:45,900
weak pointer doesn't when you access an

00:50:44,040 --> 00:50:47,520
object we promote the weak pointer to a

00:50:45,900 --> 00:50:49,530
strong pointer so that the cache keeps

00:50:47,520 --> 00:50:52,170
the object alive over time rather than

00:50:49,530 --> 00:50:53,610
expiring the object from the cache we

00:50:52,170 --> 00:50:55,680
throw away the strong pointer and keep

00:50:53,610 --> 00:50:57,540
the weak pointer and what that means is

00:50:55,680 --> 00:50:59,130
that if an object is in use if someone

00:50:57,540 --> 00:51:01,260
has a strong pointer to it they pin it

00:50:59,130 --> 00:51:03,510
in the cache and this has had tremendous

00:51:01,260 --> 00:51:05,130
benefits like I said in the slide good

00:51:03,510 --> 00:51:07,050
things happen for free so for example

00:51:05,130 --> 00:51:08,430
suppose you have an a ledger or

00:51:07,050 --> 00:51:10,170
some object that you're manipulating a

00:51:08,430 --> 00:51:11,520
lot if you just share a strong pointer

00:51:10,170 --> 00:51:13,380
to it you pinned it in the cache and all

00:51:11,520 --> 00:51:15,030
your other code can find it so if you

00:51:13,380 --> 00:51:16,770
have objects that are valuable that you

00:51:15,030 --> 00:51:18,450
need to have around you have some class

00:51:16,770 --> 00:51:20,190
that has a strong pointer to them you're

00:51:18,450 --> 00:51:21,720
also making those objects available to

00:51:20,190 --> 00:51:23,760
all of your other codes so frequently

00:51:21,720 --> 00:51:26,190
used objects get pinned in the cache by

00:51:23,760 --> 00:51:28,200
use worked out very well for us it also

00:51:26,190 --> 00:51:30,630
resists algorithmic complexity attacks

00:51:28,200 --> 00:51:32,370
an algorithmic complexity attack is when

00:51:30,630 --> 00:51:34,080
an attacker who knows your algorithm

00:51:32,370 --> 00:51:35,250
carefully craps his data to make your

00:51:34,080 --> 00:51:37,500
algorithm give its worst-case

00:51:35,250 --> 00:51:39,420
performance so if you imagine a sorting

00:51:37,500 --> 00:51:40,680
algorithm that maybe it has its worst

00:51:39,420 --> 00:51:42,090
case behavior if the data's already

00:51:40,680 --> 00:51:43,290
sorted an attacker can give you data

00:51:42,090 --> 00:51:44,940
that's already sorted you get the worst

00:51:43,290 --> 00:51:47,550
case behavior you can't keep your code

00:51:44,940 --> 00:51:49,620
secret so you have to protect yourself

00:51:47,550 --> 00:51:51,240
against an attacker who carefully crafts

00:51:49,620 --> 00:51:52,530
his data to make your code behave in its

00:51:51,240 --> 00:51:54,930
worst case and the way we do it is we

00:51:52,530 --> 00:51:56,460
index with salted hashes so a salted

00:51:54,930 --> 00:51:58,140
hash we hash it right we use a random

00:51:56,460 --> 00:51:59,670
salt the attacker doesn't know the salt

00:51:58,140 --> 00:52:04,140
and so he cannot attack the hashing

00:51:59,670 --> 00:52:05,760
algorithm new DB is it - nope all of our

00:52:04,140 --> 00:52:07,410
code is open source all this is widely

00:52:05,760 --> 00:52:09,000
available we've been promoting new DB

00:52:07,410 --> 00:52:11,450
it's something we built to solve a

00:52:09,000 --> 00:52:14,040
problem we have it's a key value store

00:52:11,450 --> 00:52:16,140
stores fixed length keys and variable

00:52:14,040 --> 00:52:18,150
length data and you retrieve only by key

00:52:16,140 --> 00:52:19,830
we typically use it in a block chain

00:52:18,150 --> 00:52:21,420
with the key being the hash of the data

00:52:19,830 --> 00:52:22,110
so that you can follow hash chains very

00:52:21,420 --> 00:52:24,120
efficiently

00:52:22,110 --> 00:52:25,620
we have transactions we have hash trees

00:52:24,120 --> 00:52:28,350
we have legislate entries all kinds of

00:52:25,620 --> 00:52:30,090
things that we need to find by a key so

00:52:28,350 --> 00:52:32,520
you probably know that there's a lot of

00:52:30,090 --> 00:52:34,170
key value stores out there you've

00:52:32,520 --> 00:52:36,390
probably heard of things like leveldb

00:52:34,170 --> 00:52:37,890
and rocks DB and all kinds of other

00:52:36,390 --> 00:52:39,300
things that are key value stores the

00:52:37,890 --> 00:52:41,250
problem with all of them is that the

00:52:39,300 --> 00:52:43,350
memory demand scales with the data size

00:52:41,250 --> 00:52:45,630
or the performance drops as the data

00:52:43,350 --> 00:52:47,070
size increases or both and that's

00:52:45,630 --> 00:52:49,800
because they rely on caching for

00:52:47,070 --> 00:52:52,380
performance so for example rocks DB is a

00:52:49,800 --> 00:52:53,970
phenomenal key value store but you

00:52:52,380 --> 00:52:56,280
either have to use bloom filters or you

00:52:53,970 --> 00:52:57,960
don't if you use bloom filters the size

00:52:56,280 --> 00:52:59,670
of the bloom filters is o of n double

00:52:57,960 --> 00:53:01,350
the data yet twice as many bloom filters

00:52:59,670 --> 00:53:03,420
takes twice as much space in memory if

00:53:01,350 --> 00:53:05,310
you don't use bloom filters then the

00:53:03,420 --> 00:53:06,870
performance is o of log n so as your

00:53:05,310 --> 00:53:09,300
data gets larger at the performance

00:53:06,870 --> 00:53:11,730
drops what we want is we wanted a key

00:53:09,300 --> 00:53:14,280
value store that's memory usage was o of

00:53:11,730 --> 00:53:16,920
1 and whose performance would level off

00:53:14,280 --> 00:53:18,510
so once you exceed a certain data set

00:53:16,920 --> 00:53:20,130
size we're caching doesn't work any more

00:53:18,510 --> 00:53:20,760
rather than the performance continuing

00:53:20,130 --> 00:53:22,800
to drop

00:53:20,760 --> 00:53:24,330
memory usage increasing the performance

00:53:22,800 --> 00:53:27,420
levels off and it levels off at a very

00:53:24,330 --> 00:53:29,250
high level so when we designed it we

00:53:27,420 --> 00:53:30,720
assume that caching was useless we just

00:53:29,250 --> 00:53:32,430
said let's assume that we can't catch

00:53:30,720 --> 00:53:36,450
our data is so large our memory is so

00:53:32,430 --> 00:53:38,370
small that we can't cache at all we want

00:53:36,450 --> 00:53:39,630
our performance to level off as the data

00:53:38,370 --> 00:53:41,550
size increases we don't want it to keep

00:53:39,630 --> 00:53:42,990
dropping unfortunately we can't get it

00:53:41,550 --> 00:53:44,640
to keep increasing that'd be awesome but

00:53:42,990 --> 00:53:45,810
I don't know any way to do that so the

00:53:44,640 --> 00:53:47,550
performance will level off the

00:53:45,810 --> 00:53:49,440
performance will ultimately be o of 1

00:53:47,550 --> 00:53:51,750
and therefore there's no penalty for

00:53:49,440 --> 00:53:53,310
massive databases and the memory use

00:53:51,750 --> 00:53:54,480
only scales with the write rate we have

00:53:53,310 --> 00:53:55,710
to buffer the writes in memory to

00:53:54,480 --> 00:53:57,180
journal them so if you have a very high

00:53:55,710 --> 00:53:58,470
write rate you have you have some memory

00:53:57,180 --> 00:54:01,290
consumption but the memory consumption

00:53:58,470 --> 00:54:02,880
is independent of the data set size so

00:54:01,290 --> 00:54:04,200
we wondered what was the best that you

00:54:02,880 --> 00:54:06,030
could do if we could make the best

00:54:04,200 --> 00:54:08,460
possible key value store that had these

00:54:06,030 --> 00:54:09,960
requirements how good could we get what

00:54:08,460 --> 00:54:11,670
was what did we think was theoretically

00:54:09,960 --> 00:54:13,200
the absolute best we can do and so we

00:54:11,670 --> 00:54:15,390
figured if you're looking for data

00:54:13,200 --> 00:54:17,070
that's not present maybe you could

00:54:15,390 --> 00:54:18,690
magically know we're on disk the

00:54:17,070 --> 00:54:19,950
information that it wasn't present was

00:54:18,690 --> 00:54:21,240
you couldn't have it in memory because

00:54:19,950 --> 00:54:23,760
we're assuming caching is useless you

00:54:21,240 --> 00:54:24,990
have to go to the disk but the best we

00:54:23,760 --> 00:54:25,770
thought what you can do is one i/o you

00:54:24,990 --> 00:54:27,660
know where to look

00:54:25,770 --> 00:54:30,000
you read that chunk and it says up the

00:54:27,660 --> 00:54:31,680
data is not in the database so what

00:54:30,000 --> 00:54:33,210
about data present what did we think is

00:54:31,680 --> 00:54:35,700
the best you can do we thought to iOS

00:54:33,210 --> 00:54:37,110
one i/o to go check to see if the data

00:54:35,700 --> 00:54:38,610
is there and that would tell you where

00:54:37,110 --> 00:54:40,980
the data was and then you'd have to one

00:54:38,610 --> 00:54:43,050
more i/o to get the data so if data is

00:54:40,980 --> 00:54:45,000
not present one i/o if data is present

00:54:43,050 --> 00:54:47,220
to iOS and the performance limit would

00:54:45,000 --> 00:54:49,170
be your SSD I ops so if you have an SSD

00:54:47,220 --> 00:54:51,030
that has a hundred thousand iOS per

00:54:49,170 --> 00:54:53,340
second you could retrieve 50 thousand

00:54:51,030 --> 00:54:54,810
objects per second or you can determine

00:54:53,340 --> 00:54:57,600
that a hundred thousand objects per

00:54:54,810 --> 00:55:00,630
second we're not present new DB is very

00:54:57,600 --> 00:55:03,480
very close to that like within a couple

00:55:00,630 --> 00:55:05,550
of percent new DB is very very close to

00:55:03,480 --> 00:55:08,760
what we thought was the optimum that you

00:55:05,550 --> 00:55:10,800
could possibly do the data is append

00:55:08,760 --> 00:55:12,420
only we have a data file that holds all

00:55:10,800 --> 00:55:14,070
the data it also holds the keys so you

00:55:12,420 --> 00:55:16,470
can recover the index in the data in

00:55:14,070 --> 00:55:18,690
case it gets corrupt it uses either two

00:55:16,470 --> 00:55:20,580
or three files so you have the data file

00:55:18,690 --> 00:55:22,020
and an index file and then during an

00:55:20,580 --> 00:55:24,960
update rights or journaled so you have

00:55:22,020 --> 00:55:27,630
three files only during an update the

00:55:24,960 --> 00:55:29,460
index consists of hash buckets and the

00:55:27,630 --> 00:55:33,510
bucket count is dynamically increased so

00:55:29,460 --> 00:55:34,540
when we have when we have more data and

00:55:33,510 --> 00:55:36,820
our buckets are starting

00:55:34,540 --> 00:55:39,460
get full and we hit a configured limit

00:55:36,820 --> 00:55:40,990
we add another bucket we split a bucket

00:55:39,460 --> 00:55:42,970
in half to add another bucket and we

00:55:40,990 --> 00:55:44,980
keep the average number of objects per

00:55:42,970 --> 00:55:46,660
bucket constant rights don't block reads

00:55:44,980 --> 00:55:48,190
reads don't block reads reason don't

00:55:46,660 --> 00:55:50,110
block writes nothing blocks anything

00:55:48,190 --> 00:55:52,870
else so ultimately it is the SSDI opps

00:55:50,110 --> 00:55:54,780
limit that is your limiting factor so

00:55:52,870 --> 00:55:57,400
what does that have to do with C++

00:55:54,780 --> 00:55:58,840
well it's header only which gives you

00:55:57,400 --> 00:56:02,410
all of the advantages I talked about

00:55:58,840 --> 00:56:04,000
before about optimization it uses a

00:56:02,410 --> 00:56:05,320
templated visitor and compile time of

00:56:04,000 --> 00:56:08,410
sorts with asserts which I'll show you

00:56:05,320 --> 00:56:11,020
so this is a templated visitor it passes

00:56:08,410 --> 00:56:12,580
the visitor function into the visit the

00:56:11,020 --> 00:56:14,710
function that's called on each object

00:56:12,580 --> 00:56:17,230
into the visiting function so that way

00:56:14,710 --> 00:56:19,180
you don't have to export an API that

00:56:17,230 --> 00:56:21,460
keeps track of where in the file you are

00:56:19,180 --> 00:56:23,770
you just push the function that does the

00:56:21,460 --> 00:56:26,110
visiting in it also templates on a codec

00:56:23,770 --> 00:56:27,550
if you have any particular compression

00:56:26,110 --> 00:56:30,070
algorithms if your data has in a use

00:56:27,550 --> 00:56:31,120
case specific compression that's

00:56:30,070 --> 00:56:33,730
possible for example if it has a

00:56:31,120 --> 00:56:36,280
particular header you can optimize that

00:56:33,730 --> 00:56:38,590
header out with a codec we also use the

00:56:36,280 --> 00:56:40,870
static assert something very nice and

00:56:38,590 --> 00:56:42,850
C++ is that you can catch lots of errors

00:56:40,870 --> 00:56:44,860
at compile time if you're clever this

00:56:42,850 --> 00:56:47,050
actually caught on someone went to and

00:56:44,860 --> 00:56:48,970
compile new DB on a platform where the

00:56:47,050 --> 00:56:50,650
size of a size type wasn't big enough to

00:56:48,970 --> 00:56:52,900
hold the size of their hash we assume

00:56:50,650 --> 00:56:55,510
that it is this static assert caught

00:56:52,900 --> 00:56:58,630
that at compile time which is very nice

00:56:55,510 --> 00:57:00,900
saves you a lot of time beast how many

00:56:58,630 --> 00:57:03,400
of you whoops

00:57:00,900 --> 00:57:06,760
so beast how many of you have gotten one

00:57:03,400 --> 00:57:08,080
of these from Vinnie Falco anyone no one

00:57:06,760 --> 00:57:09,520
Vinnie Falcon would like every single

00:57:08,080 --> 00:57:11,560
one of you to have those beasts is a

00:57:09,520 --> 00:57:13,990
library that we developed for HTTP and

00:57:11,560 --> 00:57:15,970
WebSockets Vinnie's been pushing to try

00:57:13,990 --> 00:57:18,250
to get it included in to boost maybe

00:57:15,970 --> 00:57:19,750
we'll see maybe a little optimistic its

00:57:18,250 --> 00:57:21,850
header only and it provides a boost like

00:57:19,750 --> 00:57:23,680
API so it's an extension of boost for

00:57:21,850 --> 00:57:26,830
HTTP and WebSockets that provides both

00:57:23,680 --> 00:57:28,840
asynchronous and synchronous api's you

00:57:26,830 --> 00:57:30,220
probably can't see this code but take my

00:57:28,840 --> 00:57:31,930
word for it it's really clean elegant

00:57:30,220 --> 00:57:34,270
simple code it actually does something

00:57:31,930 --> 00:57:36,970
useful one side with on the left with

00:57:34,270 --> 00:57:40,690
WebSockets on the right with HTTP it's

00:57:36,970 --> 00:57:42,580
very very boost like another example is

00:57:40,690 --> 00:57:44,080
polymorphic currency types and ripple if

00:57:42,580 --> 00:57:46,390
we had it to do over again we probably

00:57:44,080 --> 00:57:48,130
would use standard variants for this we

00:57:46,390 --> 00:57:49,960
didn't at the time

00:57:48,130 --> 00:57:51,880
ripple has both the native currency and

00:57:49,960 --> 00:57:54,130
arbitrary assets some objects can hold

00:57:51,880 --> 00:57:55,750
either type of currency some objects can

00:57:54,130 --> 00:57:57,700
only hold one kind of currency we have a

00:57:55,750 --> 00:57:59,410
mix of code some of which deals with

00:57:57,700 --> 00:58:01,210
multiple assets some of which doesn't

00:57:59,410 --> 00:58:03,280
virtual functions were not a good fit

00:58:01,210 --> 00:58:05,080
slicing is one of the issue optimization

00:58:03,280 --> 00:58:06,790
is another another one is that you have

00:58:05,080 --> 00:58:08,290
all of these annoying runtime checks

00:58:06,790 --> 00:58:10,390
like what if I got an object of the

00:58:08,290 --> 00:58:11,800
wrong type and if you put a check for

00:58:10,390 --> 00:58:13,480
that into your code you have to sort of

00:58:11,800 --> 00:58:14,710
do something if you have an object of

00:58:13,480 --> 00:58:17,830
the wrong type and since it's one of

00:58:14,710 --> 00:58:19,540
those can't happen situations you put in

00:58:17,830 --> 00:58:20,980
an assert but then you can't test it you

00:58:19,540 --> 00:58:23,590
can't unit test code that's never

00:58:20,980 --> 00:58:24,880
supposed to happen it's very ugly until

00:58:23,590 --> 00:58:27,430
inelegant it's a way to build up

00:58:24,880 --> 00:58:29,800
technical debt instead you can use

00:58:27,430 --> 00:58:31,210
runtime polymorphism it knows the type

00:58:29,800 --> 00:58:33,100
don't have that problem

00:58:31,210 --> 00:58:34,450
templates give you concepts I think most

00:58:33,100 --> 00:58:35,710
of you know what I mean by concept but I

00:58:34,450 --> 00:58:37,210
mean essentially a set of rules that a

00:58:35,710 --> 00:58:39,340
class has to follow in order for a

00:58:37,210 --> 00:58:41,530
template to work and they can't slice

00:58:39,340 --> 00:58:43,180
and they keep the common code simple and

00:58:41,530 --> 00:58:45,280
easy to understand so some of the code

00:58:43,180 --> 00:58:46,780
goes in the class that you're templating

00:58:45,280 --> 00:58:48,370
on some of it goes in the template code

00:58:46,780 --> 00:58:50,650
itself and it allows you to avoid having

00:58:48,370 --> 00:58:52,360
to have all of these if it's this type

00:58:50,650 --> 00:58:53,980
of s I do this but if it's this type of

00:58:52,360 --> 00:58:56,170
s I do this other thing which gets to be

00:58:53,980 --> 00:58:59,110
very very ugly and difficult to maintain

00:58:56,170 --> 00:59:00,730
this is an example of one of the

00:58:59,110 --> 00:59:03,520
advantages of using that type of

00:59:00,730 --> 00:59:05,200
templating compile-time polymorphism so

00:59:03,520 --> 00:59:06,850
this is a class that handles an offer of

00:59:05,200 --> 00:59:08,680
someone willing to trade one asset for

00:59:06,850 --> 00:59:10,750
another and you can see it's templated

00:59:08,680 --> 00:59:12,160
on the type of assets and what's nice

00:59:10,750 --> 00:59:14,500
about that is you see that boost

00:59:12,160 --> 00:59:16,270
optional T out at the bottom you get

00:59:14,500 --> 00:59:18,070
value semantics so that has value

00:59:16,270 --> 00:59:20,650
semantics we can create a new object of

00:59:18,070 --> 00:59:22,510
type whatever the output type is we can

00:59:20,650 --> 00:59:24,040
wrap it in a boost optional very

00:59:22,510 --> 00:59:25,510
difficult to do that with virtual

00:59:24,040 --> 00:59:26,950
functions very difficult to do that with

00:59:25,510 --> 00:59:29,460
inheritance but you can do that very

00:59:26,950 --> 00:59:31,600
cleanly with compile time polymorphism

00:59:29,460 --> 00:59:36,060
tremendously simplifies the code makes

00:59:31,600 --> 00:59:37,960
it easier to maintain that's it

00:59:36,060 --> 00:59:40,380
hopefully you all are now blockchain

00:59:37,960 --> 00:59:40,380
experts

00:59:46,710 --> 00:59:50,680
lots of time for questions if you want

00:59:49,089 --> 00:59:56,050
if anyone wants to come to one of the

00:59:50,680 --> 00:59:59,050
two microphones excuse me you said that

00:59:56,050 --> 01:00:02,109
there was attack on worst-case behavior

00:59:59,050 --> 01:00:05,680
but is there any sort of attack that can

01:00:02,109 --> 01:00:07,869
happen on the best case behavior for

01:00:05,680 --> 01:00:11,290
example let's say that your worst case

01:00:07,869 --> 01:00:15,460
of behavior was n log n but your best

01:00:11,290 --> 01:00:17,830
case behavior was limit linear time

01:00:15,460 --> 01:00:19,960
could somebody create an attack on that

01:00:17,830 --> 01:00:24,190
case where they're very giving you the

01:00:19,960 --> 01:00:28,150
best T data that you that go through

01:00:24,190 --> 01:00:30,640
your algorithm and just get the best

01:00:28,150 --> 01:00:32,170
time yes but you would hope that that

01:00:30,640 --> 01:00:34,210
would be an easier problem to solve

01:00:32,170 --> 01:00:36,580
otherwise you pick the wrong algorithm

01:00:34,210 --> 01:00:38,410
so if someone attacks your best case

01:00:36,580 --> 01:00:40,089
behavior all of your normal congestion

01:00:38,410 --> 01:00:41,500
control mechanisms would solve that so

01:00:40,089 --> 01:00:43,630
for example if you have a public

01:00:41,500 --> 01:00:45,790
blockchain like ripple or Bitcoin you

01:00:43,630 --> 01:00:47,410
pay a transaction fee and those fees are

01:00:45,790 --> 01:00:49,570
normally very low but if the network

01:00:47,410 --> 01:00:51,070
gets congested the fee goes up so if you

01:00:49,570 --> 01:00:52,869
want to keep the network congested you

01:00:51,070 --> 01:00:54,670
have to keep sending transactions that

01:00:52,869 --> 01:00:56,440
that saturate the network and you have

01:00:54,670 --> 01:00:58,240
to pay a fee for every transaction

01:00:56,440 --> 01:01:00,520
that's greater than I'm willing to pay

01:00:58,240 --> 01:01:02,230
for my one legitimate transaction so as

01:01:00,520 --> 01:01:04,540
long as you don't have an advantage over

01:01:02,230 --> 01:01:05,950
me then I can compete on a level playing

01:01:04,540 --> 01:01:07,359
field because I only have to get one or

01:01:05,950 --> 01:01:09,160
two transactions free and you have to

01:01:07,359 --> 01:01:10,390
keep the network saturated forever like

01:01:09,160 --> 01:01:11,950
if you want to stop me from performing a

01:01:10,390 --> 01:01:13,599
transaction you have to keep the network

01:01:11,950 --> 01:01:15,700
saturated if you're willing to pay more

01:01:13,599 --> 01:01:17,619
than me for a period of time yes you can

01:01:15,700 --> 01:01:19,119
lock me out but what we really don't

01:01:17,619 --> 01:01:20,890
want what we can't handle with the

01:01:19,119 --> 01:01:22,480
conventional methods is someone who has

01:01:20,890 --> 01:01:24,609
a computational advantage like if you

01:01:22,480 --> 01:01:26,050
could submit one transaction and it cost

01:01:24,609 --> 01:01:28,119
a hundred times as much as my

01:01:26,050 --> 01:01:30,040
transactions now you can jam the network

01:01:28,119 --> 01:01:32,680
at a low cost and I can't out-compete

01:01:30,040 --> 01:01:34,300
you so so we designed the system to

01:01:32,680 --> 01:01:35,830
tolerate the best-case behavior and then

01:01:34,300 --> 01:01:41,920
we design it so that an attacker can't

01:01:35,830 --> 01:01:44,230
force the worst-case behavior good um I

01:01:41,920 --> 01:01:45,849
have a question we probably have seen

01:01:44,230 --> 01:01:47,650
quantum computers are your algorithms

01:01:45,849 --> 01:01:50,500
ready for that in Ripper for what

01:01:47,650 --> 01:01:52,270
computers sorry quantum computers it's a

01:01:50,500 --> 01:01:55,630
good question so we have to keep our eye

01:01:52,270 --> 01:01:57,339
open we do have ways to evolve the

01:01:55,630 --> 01:01:59,080
algorithm so we can swap out the

01:01:57,339 --> 01:02:00,970
algorithms if we get to that point

01:01:59,080 --> 01:02:02,650
we keep a very close eye on that

01:02:00,970 --> 01:02:04,240
technology as everybody who does

01:02:02,650 --> 01:02:06,940
encryption and digital signatures have

01:02:04,240 --> 01:02:08,500
to I hope we still have about eight more

01:02:06,940 --> 01:02:10,030
years before we really have to get

01:02:08,500 --> 01:02:11,619
aggressive about it I could be wrong

01:02:10,030 --> 01:02:13,450
about that but yeah we do we would you

01:02:11,619 --> 01:02:15,940
follow the technology as everybody has

01:02:13,450 --> 01:02:17,619
to everybody in cryptography everybody

01:02:15,940 --> 01:02:19,360
you know who deals with the electronic

01:02:17,619 --> 01:02:21,310
security these systems are dependent on

01:02:19,360 --> 01:02:22,600
cryptography the dependent on secure

01:02:21,310 --> 01:02:23,980
hashes they're dependent on digital

01:02:22,600 --> 01:02:25,619
signatures and we have to make sure that

01:02:23,980 --> 01:02:27,550
the algorithms that they use are

01:02:25,619 --> 01:02:29,230
resistant against attackers who are

01:02:27,550 --> 01:02:31,990
willing to potentially spend millions of

01:02:29,230 --> 01:02:33,760
dollars to break the system so yeah we

01:02:31,990 --> 01:02:36,100
will have to evolve the algorithms

01:02:33,760 --> 01:02:37,660
definitely a lot of people will say well

01:02:36,100 --> 01:02:39,400
why don't you change the algorithms now

01:02:37,660 --> 01:02:41,290
like why don't you like ahead of time

01:02:39,400 --> 01:02:42,730
it's kind of like turning the steering

01:02:41,290 --> 01:02:45,250
wheel on your car when the curves still

01:02:42,730 --> 01:02:46,690
50 miles ahead like you might do the

01:02:45,250 --> 01:02:47,980
wrong thing it's hard to know like what

01:02:46,690 --> 01:02:49,570
a quantum computer is going to look like

01:02:47,980 --> 01:02:51,010
what algorithms are they going to break

01:02:49,570 --> 01:02:52,810
and how badly what are gonna be the best

01:02:51,010 --> 01:02:54,280
algorithms to resist them if we switch

01:02:52,810 --> 01:02:56,619
too early we might find that we just

01:02:54,280 --> 01:02:58,660
have to switch again so there's a matter

01:02:56,619 --> 01:02:59,950
of finding the right the right time and

01:02:58,660 --> 01:03:01,060
I think we still have a couple of years

01:02:59,950 --> 01:03:02,350
but yet we have to be ready we

01:03:01,060 --> 01:03:03,730
absolutely have to ready be ready we

01:03:02,350 --> 01:03:05,290
have to follow the literature and we

01:03:03,730 --> 01:03:07,450
also have to worry because we don't know

01:03:05,290 --> 01:03:09,880
what an attacker might have that is not

01:03:07,450 --> 01:03:12,369
in the literature so I'm sure the NSA is

01:03:09,880 --> 01:03:14,200
a couple of years ahead of the of what

01:03:12,369 --> 01:03:16,510
we know about and I'm sure foreign

01:03:14,200 --> 01:03:18,160
governments might potentially interfere

01:03:16,510 --> 01:03:19,660
with these systems as an amount of money

01:03:18,160 --> 01:03:21,550
they hold goes into the billions of

01:03:19,660 --> 01:03:23,320
dollars so yeah we have a huge bug

01:03:21,550 --> 01:03:24,609
bounty we have a huge security bounty of

01:03:23,320 --> 01:03:26,920
potentially millions of billions of

01:03:24,609 --> 01:03:30,760
dollars so yes very concerned very

01:03:26,920 --> 01:03:32,500
concerned about that on this side so for

01:03:30,760 --> 01:03:35,020
a ledger system with large number of

01:03:32,500 --> 01:03:37,050
participants what is a typical quorum

01:03:35,020 --> 01:03:39,820
number how many you have to get replies

01:03:37,050 --> 01:03:41,410
how many T's to get replies from if we

01:03:39,820 --> 01:03:44,080
decide that it's an agreement and

01:03:41,410 --> 01:03:45,760
consensus and you can move forward so it

01:03:44,080 --> 01:03:47,890
depends on the type of system that

01:03:45,760 --> 01:03:49,810
you're using in in Bitcoin it doesn't

01:03:47,890 --> 01:03:51,190
use a quorum it uses proof of work so

01:03:49,810 --> 01:03:53,380
it's just sufficient essentially

01:03:51,190 --> 01:03:56,260
sufficient hashing power by anyone

01:03:53,380 --> 01:03:58,090
ripple uses 80% of the active

01:03:56,260 --> 01:03:59,350
participants but it identifies active

01:03:58,090 --> 01:04:00,760
participants essentially by known

01:03:59,350 --> 01:04:01,869
identities that someone has to convince

01:04:00,760 --> 01:04:03,280
you to count them because if we just

01:04:01,869 --> 01:04:04,660
counted anyone who is present then

01:04:03,280 --> 01:04:06,520
attacker could produce thousands and

01:04:04,660 --> 01:04:07,240
thousands of identities private

01:04:06,520 --> 01:04:09,130
blockchains

01:04:07,240 --> 01:04:10,210
typically they know all the participants

01:04:09,130 --> 01:04:11,770
because they have some sort of an

01:04:10,210 --> 01:04:12,270
organization that said like these ten

01:04:11,770 --> 01:04:14,130
organs

01:04:12,270 --> 01:04:16,680
patience or the participants and so they

01:04:14,130 --> 01:04:18,600
typically will use a quorum of 3 n plus

01:04:16,680 --> 01:04:20,910
1 where n is the number so if this 3 n

01:04:18,600 --> 01:04:22,110
plus 1 participants n of them can be

01:04:20,910 --> 01:04:23,340
missing and you can make forward

01:04:22,110 --> 01:04:25,290
progress otherwise you don't make

01:04:23,340 --> 01:04:26,730
forward progress some are a little more

01:04:25,290 --> 01:04:28,470
aggressive than that where basically

01:04:26,730 --> 01:04:29,940
they don't count a participant that

01:04:28,470 --> 01:04:31,530
hasn't been active for a certain period

01:04:29,940 --> 01:04:32,430
of time and they decide that that's an

01:04:31,530 --> 01:04:34,470
acceptable risk

01:04:32,430 --> 01:04:36,930
it's very use case specific though and

01:04:34,470 --> 01:04:39,240
there isn't a perfect solution yet we

01:04:36,930 --> 01:04:41,040
definitely do need more more work there

01:04:39,240 --> 01:04:42,810
and in fact if you if anyone here is

01:04:41,040 --> 01:04:45,120
looking for a computer science masters

01:04:42,810 --> 01:04:46,800
with PhD I can give you the rundown of

01:04:45,120 --> 01:04:49,440
what we really need research to figure

01:04:46,800 --> 01:04:51,270
out exactly how we need to do that that

01:04:49,440 --> 01:04:53,010
that would be that would be extremely

01:04:51,270 --> 01:04:55,290
valuable but to some extent we're

01:04:53,010 --> 01:04:57,060
slightly winging it now I mean we run

01:04:55,290 --> 01:04:58,800
simulations and we stay very very

01:04:57,060 --> 01:05:00,240
conservative so that we know we're safe

01:04:58,800 --> 01:05:02,430
but it would be really nice to know

01:05:00,240 --> 01:05:04,200
number one exactly where is the danger

01:05:02,430 --> 01:05:05,760
zone like what where is the thing that

01:05:04,200 --> 01:05:08,190
we have to stay away from and number two

01:05:05,760 --> 01:05:09,420
what happens as we get close to it so

01:05:08,190 --> 01:05:10,770
one of the things is we tested in

01:05:09,420 --> 01:05:12,480
simulation where we took a network that

01:05:10,770 --> 01:05:13,620
was very healthy and we took a network

01:05:12,480 --> 01:05:15,840
that was unhealthy and we gradually

01:05:13,620 --> 01:05:18,060
moved one to the other to say what would

01:05:15,840 --> 01:05:19,620
happen as the network starts to break

01:05:18,060 --> 01:05:21,480
and what's interesting is that it

01:05:19,620 --> 01:05:23,250
doesn't like all of a sudden just blow

01:05:21,480 --> 01:05:24,510
up and there's double spins and all

01:05:23,250 --> 01:05:26,550
these problems what happens is the

01:05:24,510 --> 01:05:29,040
network becomes unstable and slow so you

01:05:26,550 --> 01:05:30,450
get non agreement you get extra rounds

01:05:29,040 --> 01:05:32,040
and you get this sort of soft failure

01:05:30,450 --> 01:05:33,210
that we hope would incentivize people to

01:05:32,040 --> 01:05:35,640
say hey there's something wrong we

01:05:33,210 --> 01:05:37,290
better fix it so that's good but we

01:05:35,640 --> 01:05:39,870
really do want to know like what are the

01:05:37,290 --> 01:05:41,970
exact theoretical constraints to be sure

01:05:39,870 --> 01:05:43,830
that the system is reliable how do we

01:05:41,970 --> 01:05:45,300
know where we are relative to those

01:05:43,830 --> 01:05:48,030
constraints and that's definitely an

01:05:45,300 --> 01:05:49,800
ongoing research area ok so that's why

01:05:48,030 --> 01:05:52,410
you can use gateways right so that you

01:05:49,800 --> 01:05:54,840
can reduce number of active participants

01:05:52,410 --> 01:05:56,910
so that 80% will not be well and the

01:05:54,840 --> 01:05:58,590
other advantage is if you use a system

01:05:56,910 --> 01:06:00,830
like ripple where the system is tracking

01:05:58,590 --> 01:06:03,690
a virtual asset if the system blows up

01:06:00,830 --> 01:06:06,540
notionally you can constrain the problem

01:06:03,690 --> 01:06:08,850
because the the Gateway still owes you

01:06:06,540 --> 01:06:10,350
the money so if you give me $100 and I

01:06:08,850 --> 01:06:12,600
give you an electronic balance on one of

01:06:10,350 --> 01:06:13,920
these systems and the system blows up or

01:06:12,600 --> 01:06:15,450
fails in some way I still owe you that

01:06:13,920 --> 01:06:16,770
money right the system was just

01:06:15,450 --> 01:06:19,230
recording the fact that that obligation

01:06:16,770 --> 01:06:20,760
existed but for Bitcoin you can't do

01:06:19,230 --> 01:06:22,200
that for Bitcoin if you have a Bitcoin

01:06:20,760 --> 01:06:23,520
all you have is a number in the computer

01:06:22,200 --> 01:06:25,960
and if something happens to that number

01:06:23,520 --> 01:06:27,460
you're just out the money so a lot of

01:06:25,960 --> 01:06:28,810
we'll say that like counterparties are

01:06:27,460 --> 01:06:30,310
bad because the counterparty can fail

01:06:28,810 --> 01:06:31,540
but counterparties have the advantage

01:06:30,310 --> 01:06:32,800
that if the system fails in the

01:06:31,540 --> 01:06:36,089
counterparty doesn't you still get your

01:06:32,800 --> 01:06:39,550
money you so it's it's a trade off

01:06:36,089 --> 01:06:41,170
so you mentioned how blockchain software

01:06:39,550 --> 01:06:44,020
it needs to be like a fortress and I'm

01:06:41,170 --> 01:06:45,970
curious do you deploy your software with

01:06:44,020 --> 01:06:49,960
any sanitizers enabled or things like

01:06:45,970 --> 01:06:52,060
that um we typically don't run too much

01:06:49,960 --> 01:06:54,280
of that stuff on live like production

01:06:52,060 --> 01:06:55,990
machines but one of the nice things it

01:06:54,280 --> 01:06:57,760
would you have to you have two sets of

01:06:55,990 --> 01:06:59,500
data flows so you have the data flow

01:06:57,760 --> 01:07:00,910
that's the transactions and the Ledger's

01:06:59,500 --> 01:07:02,530
and everybody has to follow that to

01:07:00,910 --> 01:07:04,300
monitor the network and then you also

01:07:02,530 --> 01:07:05,770
have like local queries people who want

01:07:04,300 --> 01:07:07,570
to know information about what's going

01:07:05,770 --> 01:07:09,070
on on the network so one of the nice

01:07:07,570 --> 01:07:10,540
things is you can completely separate

01:07:09,070 --> 01:07:12,220
those so the servers that are tracking

01:07:10,540 --> 01:07:13,750
the sort of canonical reliable

01:07:12,220 --> 01:07:14,740
information you can keep completely

01:07:13,750 --> 01:07:16,420
private you know to give people access

01:07:14,740 --> 01:07:18,220
to them and then the servers that are

01:07:16,420 --> 01:07:21,880
sort of widely accessible to the world

01:07:18,220 --> 01:07:24,310
and people can query they can't harm the

01:07:21,880 --> 01:07:27,130
network they can only harm themselves we

01:07:24,310 --> 01:07:29,680
do use we use all kinds of sanitizers we

01:07:27,130 --> 01:07:32,619
use Val grind we use what is it called

01:07:29,680 --> 01:07:34,810
tea Sanh address sanitizer we use a

01:07:32,619 --> 01:07:36,940
variety of tools to analyze live data

01:07:34,810 --> 01:07:38,859
the other nice thing is it's really only

01:07:36,940 --> 01:07:40,570
failing on the transactions in the

01:07:38,859 --> 01:07:42,760
ledger manipulation that's a problem and

01:07:40,570 --> 01:07:44,920
we can replay that stuff from historical

01:07:42,760 --> 01:07:46,420
data so we can replay everything that

01:07:44,920 --> 01:07:48,940
happened over the past day on a machine

01:07:46,420 --> 01:07:50,740
and we can watch that happening sort of

01:07:48,940 --> 01:07:53,710
in simulated time rather than real time

01:07:50,740 --> 01:07:57,280
so we don't have to we can test new code

01:07:53,710 --> 01:07:59,109
on old data but it's but the problem is

01:07:57,280 --> 01:08:01,570
still if someone figures out an attack

01:07:59,109 --> 01:08:03,040
vector and they launch it live it won't

01:08:01,570 --> 01:08:04,750
help that we figured out the attacker

01:08:03,040 --> 01:08:05,800
that an address sanitizer has caught it

01:08:04,750 --> 01:08:07,450
or some sort of pretty sick code has

01:08:05,800 --> 01:08:09,250
caught it if it's already applied to the

01:08:07,450 --> 01:08:10,660
ledger and we can't like manually screen

01:08:09,250 --> 01:08:12,790
each transactions before applying it

01:08:10,660 --> 01:08:14,410
because of the response time so that

01:08:12,790 --> 01:08:16,509
does have some value and it's definitely

01:08:14,410 --> 01:08:22,509
good for back testing but it's not as

01:08:16,509 --> 01:08:24,370
useful for protecting live systems hi I

01:08:22,509 --> 01:08:28,089
was wondering how sensitive your code

01:08:24,370 --> 01:08:31,120
base is to compiler vendor optimization

01:08:28,089 --> 01:08:35,049
flags versioning and how you mitigate

01:08:31,120 --> 01:08:37,710
that so we we compile our code regularly

01:08:35,049 --> 01:08:41,310
on GCC clang

01:08:37,710 --> 01:08:43,109
in Visual Studio not too often on ICC we

01:08:41,310 --> 01:08:44,640
get pretty good cogeneration on all of

01:08:43,109 --> 01:08:48,239
them sometimes one will find a bug that

01:08:44,640 --> 01:08:51,330
another one doesn't which is also nice I

01:08:48,239 --> 01:08:53,339
has not been that sensitive to too much

01:08:51,330 --> 01:08:56,190
optimizations do make a huge difference

01:08:53,339 --> 01:08:58,739
any type of memory checking will just

01:08:56,190 --> 01:09:00,299
put the performance in the toilet which

01:08:58,739 --> 01:09:01,679
probably is an indication that our code

01:09:00,299 --> 01:09:04,199
is still doing more copying than it

01:09:01,679 --> 01:09:05,640
needs to but we've got really good

01:09:04,199 --> 01:09:07,770
performance out of all of the major

01:09:05,640 --> 01:09:09,719
compiler vendors and then we and I think

01:09:07,770 --> 01:09:11,279
it's also very advantageous to compile

01:09:09,719 --> 01:09:13,830
your code on multiple platforms and

01:09:11,279 --> 01:09:15,659
multiple compilers because compilers

01:09:13,830 --> 01:09:17,699
sometimes won't report warnings and

01:09:15,659 --> 01:09:19,409
another one will compilers some

01:09:17,699 --> 01:09:20,549
compilers are tolerant of code that you

01:09:19,409 --> 01:09:22,589
really shouldn't be doing whereas

01:09:20,549 --> 01:09:25,049
another one may not be building on a

01:09:22,589 --> 01:09:26,489
variety of compilers is definitely

01:09:25,049 --> 01:09:29,460
definitely helping but we haven't found

01:09:26,489 --> 01:09:31,049
it to be particularly sensitive just yet

01:09:29,460 --> 01:09:32,460
just like compiling a debug mode

01:09:31,049 --> 01:09:33,779
particular with memory debugging is

01:09:32,460 --> 01:09:35,989
horrible but everything else is pretty

01:09:33,779 --> 01:09:35,989
good

01:09:37,020 --> 01:09:43,440
lots of good application stuff lots of

01:09:39,929 --> 01:09:45,390
good high-level programming stuff so you

01:09:43,440 --> 01:09:49,799
must excuse me for asking a fairly

01:09:45,390 --> 01:09:53,400
low-level question I had to back off and

01:09:49,799 --> 01:09:56,030
attempt to ban slicing would you

01:09:53,400 --> 01:10:02,460
encourage me to fight that fight again

01:09:56,030 --> 01:10:04,140
it's painful so so yeah I mean it is it

01:10:02,460 --> 01:10:06,510
it's it I think it is the biggest

01:10:04,140 --> 01:10:08,100
problem with C++ today like in fact if I

01:10:06,510 --> 01:10:09,000
could push my magic button and make one

01:10:08,100 --> 01:10:12,150
problem go away

01:10:09,000 --> 01:10:15,540
it would be slicing I don't know what

01:10:12,150 --> 01:10:18,480
the solution is um I would love to see

01:10:15,540 --> 01:10:19,949
people yourself like coming up with some

01:10:18,480 --> 01:10:22,140
substandard variant I think is going to

01:10:19,949 --> 01:10:23,670
be one one possible tool and we've used

01:10:22,140 --> 01:10:25,770
all different tools on different things

01:10:23,670 --> 01:10:28,199
but yeah we need some we need we would

01:10:25,770 --> 01:10:30,060
benefit a lot I think I tried to press

01:10:28,199 --> 01:10:32,219
that button but there's a lot of old

01:10:30,060 --> 01:10:36,179
code out there my conjecture is that

01:10:32,219 --> 01:10:37,860
essentially all bugs III I would have a

01:10:36,179 --> 01:10:40,320
hard time disagreeing with Tweetie with

01:10:37,860 --> 01:10:41,760
you on that yeah I will agree ACK to

01:10:40,320 --> 01:10:43,409
some extent I'm sounding the alarm I

01:10:41,760 --> 01:10:46,350
think that that's it's very surprising

01:10:43,409 --> 01:10:48,900
behavior for every new C++ programmer

01:10:46,350 --> 01:10:51,100
and it rears its ugly head sometimes

01:10:48,900 --> 01:10:53,410
late and for people who are not you know

01:10:51,100 --> 01:10:54,940
decades of C++ experience sometimes

01:10:53,410 --> 01:10:56,350
you'll almost finish a piece of code

01:10:54,940 --> 01:10:58,240
that you spent a long time on and

01:10:56,350 --> 01:10:59,830
suddenly discover that slicing makes it

01:10:58,240 --> 01:11:01,300
like means you do use the wrong design

01:10:59,830 --> 01:11:02,890
from the very beginning and you're like

01:11:01,300 --> 01:11:04,540
what crap I just spent you know three

01:11:02,890 --> 01:11:07,060
days working on something and it's just

01:11:04,540 --> 01:11:10,240
not going to work because of this C++

01:11:07,060 --> 01:11:11,680
issue and so so yeah I'm not gonna it

01:11:10,240 --> 01:11:12,820
doesn't ruin the language free by any

01:11:11,680 --> 01:11:14,620
stretch of the imagination it is the

01:11:12,820 --> 01:11:21,520
very worst thing though I think but

01:11:14,620 --> 01:11:24,010
thank you that's good you mentioned that

01:11:21,520 --> 01:11:26,290
you're salting your hashes with random

01:11:24,010 --> 01:11:28,630
numbers given that it's open-source

01:11:26,290 --> 01:11:30,280
software do you have to worry about the

01:11:28,630 --> 01:11:32,140
seed that you use on the random number

01:11:30,280 --> 01:11:34,080
generator and how are you getting the

01:11:32,140 --> 01:11:38,350
entropy or whatever that you need there

01:11:34,080 --> 01:11:40,780
I'm so glad you asked that so that's

01:11:38,350 --> 01:11:42,190
actually a fairly well solved problem

01:11:40,780 --> 01:11:44,140
except when every once in a while a

01:11:42,190 --> 01:11:45,340
failure to do it exactly right rears its

01:11:44,140 --> 01:11:47,470
ugly head but we know how to solve that

01:11:45,340 --> 01:11:49,990
so the computers that we use in the real

01:11:47,470 --> 01:11:51,610
world are not Turing machines they have

01:11:49,990 --> 01:11:53,440
connections to the real world and they

01:11:51,610 --> 01:11:57,250
get randomness from many sources and the

01:11:53,440 --> 01:11:58,840
biggest one is on a modern x86 CPU they

01:11:57,250 --> 01:12:00,760
have an instruction cycle counter and

01:11:58,840 --> 01:12:02,560
the clock that generates that

01:12:00,760 --> 01:12:04,330
instruction cycle counter beats against

01:12:02,560 --> 01:12:07,330
the network clock and other clocks in

01:12:04,330 --> 01:12:08,980
the system and it causes randomness in

01:12:07,330 --> 01:12:11,620
the time at which data arrives and we

01:12:08,980 --> 01:12:13,270
can mine that randomness every Linux

01:12:11,620 --> 01:12:14,890
distribution does that already Windows

01:12:13,270 --> 01:12:16,360
has some proprietary solution that we're

01:12:14,890 --> 01:12:19,690
told does that I don't know if we

01:12:16,360 --> 01:12:21,910
believe it but it seems to system save

01:12:19,690 --> 01:12:23,860
randomness on shutdown and they reload

01:12:21,910 --> 01:12:26,050
it on startup to have them to start from

01:12:23,860 --> 01:12:27,730
an unknown condition and one of the cool

01:12:26,050 --> 01:12:29,650
things is as long as you have enough

01:12:27,730 --> 01:12:31,390
randomness at some point you can produce

01:12:29,650 --> 01:12:33,280
an essentially unlimited supply of

01:12:31,390 --> 01:12:34,840
random numbers so if you give me a

01:12:33,280 --> 01:12:36,850
hundred and twenty eight random bits

01:12:34,840 --> 01:12:38,860
unknown to an attacker I can produce a

01:12:36,850 --> 01:12:40,630
gigabyte of unpredictable data or more

01:12:38,860 --> 01:12:42,820
and it's at least computationally

01:12:40,630 --> 01:12:44,800
unpredictable some people say well they

01:12:42,820 --> 01:12:46,360
want true random numbers and they don't

01:12:44,800 --> 01:12:47,320
want pseudo-random numbers I kind of

01:12:46,360 --> 01:12:49,780
think that's like the difference between

01:12:47,320 --> 01:12:51,550
holy water and water you know true

01:12:49,780 --> 01:12:52,750
random numbers are like holy water like

01:12:51,550 --> 01:12:55,180
some people think that it's a great

01:12:52,750 --> 01:12:57,270
thing but you can't there's no test that

01:12:55,180 --> 01:12:59,470
can prove the difference between the two

01:12:57,270 --> 01:13:01,330
so that's kind of we use pseudo-random

01:12:59,470 --> 01:13:02,710
numbers but we mind true randomness from

01:13:01,330 --> 01:13:04,309
the system to make sure those numbers

01:13:02,710 --> 01:13:06,139
are unpredictable now there

01:13:04,309 --> 01:13:07,760
have been some well-known cases where

01:13:06,139 --> 01:13:10,669
people have gotten that wrong there was

01:13:07,760 --> 01:13:11,959
an abundance that had a bug in the end

01:13:10,669 --> 01:13:13,069
right operating system I believe are in

01:13:11,959 --> 01:13:15,289
one of the libraries they were using

01:13:13,069 --> 01:13:18,169
that caused them not to produce random

01:13:15,289 --> 01:13:19,550
keys and and that was a huge problem but

01:13:18,169 --> 01:13:21,949
we know how to do it right we just have

01:13:19,550 --> 01:13:23,269
to keep remembering to do it right one

01:13:21,949 --> 01:13:25,309
of the cool things that makes that

01:13:23,269 --> 01:13:27,019
easier though is if you take randomness

01:13:25,309 --> 01:13:28,669
from a number of different sources and

01:13:27,019 --> 01:13:31,729
you put it into a secure hash function

01:13:28,669 --> 01:13:34,280
your output is secure as the strongest

01:13:31,729 --> 01:13:35,749
input so you can take input from dozens

01:13:34,280 --> 01:13:37,039
of sources even some that you don't

01:13:35,749 --> 01:13:38,719
think are particularly strong like you

01:13:37,039 --> 01:13:40,669
could get some from a server and maybe

01:13:38,719 --> 01:13:42,260
you don't trust that server but but it

01:13:40,669 --> 01:13:44,119
doesn't do you any harm because you're

01:13:42,260 --> 01:13:46,039
as strong as the strong strongest

01:13:44,119 --> 01:13:47,869
strongest source but yes it's very

01:13:46,039 --> 01:13:49,219
important to get that right very

01:13:47,869 --> 01:13:50,989
important to get that right there been

01:13:49,219 --> 01:14:01,669
some spectacular failures all right

01:13:50,989 --> 01:14:03,949
thanks one last question if that's okay

01:14:01,669 --> 01:14:07,129
all right so you mentioned you use the

01:14:03,949 --> 01:14:08,749
Clank Visual Studio in GCC right and you

01:14:07,129 --> 01:14:11,719
mentioned that you have some select use

01:14:08,749 --> 01:14:13,219
cases when you use inline assembly so my

01:14:11,719 --> 01:14:15,829
question is do you have some good advice

01:14:13,219 --> 01:14:17,869
to make it relatively portable by a

01:14:15,829 --> 01:14:22,519
relatively portable I mean I only care

01:14:17,869 --> 01:14:24,679
about x86 and x86 64 but even though I

01:14:22,519 --> 01:14:27,199
only care about this I still have to

01:14:24,679 --> 01:14:29,209
change the syntax say in GCC I have to

01:14:27,199 --> 01:14:32,449
specify the constraints on the registers

01:14:29,209 --> 01:14:35,359
on Visual Studio 32-bit I can use inline

01:14:32,449 --> 01:14:37,459
assembly on Visual Studio 64-bit I have

01:14:35,359 --> 01:14:38,929
to have it in a separate file so I'm

01:14:37,459 --> 01:14:41,209
wondering it did you find some good

01:14:38,929 --> 01:14:44,419
solution to keep it relatively portable

01:14:41,209 --> 01:14:46,579
in your codebase unfortunately no there

01:14:44,419 --> 01:14:48,829
I don't know of any magic solution to

01:14:46,579 --> 01:14:52,609
that we most of that we use the same

01:14:48,829 --> 01:14:53,899
method that OpenSSL uses um there isn't

01:14:52,609 --> 01:14:55,489
really a good way to do it

01:14:53,899 --> 01:14:57,769
unfortunately obviously inline assembly

01:14:55,489 --> 01:14:59,780
is inherently not portable I would love

01:14:57,769 --> 01:15:01,249
to see though some better cooperation

01:14:59,780 --> 01:15:02,510
between the compiler vendors to

01:15:01,249 --> 01:15:04,760
standardize that a little bit

01:15:02,510 --> 01:15:07,039
particularly in 64-bit windows code

01:15:04,760 --> 01:15:08,599
where it's just completely just I don't

01:15:07,039 --> 01:15:09,739
I don't know why everybody seems to

01:15:08,599 --> 01:15:11,119
think they have to do it there I guess

01:15:09,739 --> 01:15:12,949
the good thing about standards is so

01:15:11,119 --> 01:15:14,929
many to choose from as they say but it

01:15:12,949 --> 01:15:16,590
does make code maintenance difficult on

01:15:14,929 --> 01:15:18,210
the bright side you don't have to change

01:15:16,590 --> 01:15:20,310
that code often and it's usually only a

01:15:18,210 --> 01:15:21,750
small percentage of your code but it's

01:15:20,310 --> 01:15:25,050
going it's going it's got to be painful

01:15:21,750 --> 01:15:26,159
yeah it would be nice to have you know

01:15:25,050 --> 01:15:27,840
there might be some people from

01:15:26,159 --> 01:15:29,880
Microsoft in this room I'm thinking this

01:15:27,840 --> 01:15:45,840
probably a couple right maybe some of

01:15:29,880 --> 01:15:47,400
them could take that message back thank

01:15:45,840 --> 01:15:50,119
you thank you so much for coming

01:15:47,400 --> 01:15:50,119

YouTube URL: https://www.youtube.com/watch?v=w4jq4frE5v4


