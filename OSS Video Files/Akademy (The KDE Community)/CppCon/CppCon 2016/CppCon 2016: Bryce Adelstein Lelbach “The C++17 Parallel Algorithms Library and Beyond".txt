Title: CppCon 2016: Bryce Adelstein Lelbach “The C++17 Parallel Algorithms Library and Beyond"
Publication date: 2016-09-30
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
One of the major library features in C++17 is a parallel algorithms library (formerly the Parallelism Technical Specification v1). The parallel algorithms library has both parallel versions of the existing algorithms in the standard library and a handful of new algorithms inspired by common patterns from parallel programming (such as std::reduce() and std::transform_reduce()).

We’ll talk about what’s in the parallel algorithms library, and how to utilize it in your code today. Also, we’ll discuss some exciting future developments relating to the parallel algorithms library which are targeted for the second version of the Parallelism Technical Specification – executors, and asynchronous parallel algorithms.
— 
Bryce Adelstein Lelbach
Lawrence Berkeley National Laboratory
Berkeley, California
Bryce Adelstein Lelbach is a researcher at Lawrence Berkeley National Laboratory (LBNL), a US Department of Energy research facility. Working alongside a team of hardware engineers and scientists, he develops and analyzes new parallel programming models for exascale and post-Moore architectures. Bryce is one of the developers of the HPX C++ runtime system. He spent five years working on HPX while he was at Louisiana State University's Center for Computation and Technology. He also helped start the LLVMLinux initiative, and has occasionally contributed to the Boost C++ libraries. Bryce is an organizer for the C++Now and CppCon conferences as well as the Bay Area C++ user group, and he is passionate about C++ community development. He serves as LBNL's representative to the ISO committee for programming languages and the ISO C++ standard committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,259
all right so welcome to CPP con I'm

00:00:02,399 --> 00:00:07,200
Bryce it'll steam them all back on the

00:00:04,259 --> 00:00:08,970
program chair I work at the computer

00:00:07,200 --> 00:00:11,040
architecture group at Lawrence Berkeley

00:00:08,970 --> 00:00:12,660
National Laboratory which is a US

00:00:11,040 --> 00:00:15,809
Department of Energy Research Facility

00:00:12,660 --> 00:00:18,150
in California and I developed parallel

00:00:15,809 --> 00:00:19,980
programming frameworks and analyze

00:00:18,150 --> 00:00:22,680
software performance and research next

00:00:19,980 --> 00:00:24,240
generation hardware technologies I'm a

00:00:22,680 --> 00:00:26,310
member of the stellar group and one of

00:00:24,240 --> 00:00:28,830
the developers of the HP X parallel

00:00:26,310 --> 00:00:30,390
runtime system some of you are in this

00:00:28,830 --> 00:00:33,210
room the last talk

00:00:30,390 --> 00:00:36,660
that was from Hartnett my colleague who

00:00:33,210 --> 00:00:37,860
was also one HP X developers and so

00:00:36,660 --> 00:00:39,420
today I'm going to talk to you about the

00:00:37,860 --> 00:00:44,219
new parallel algorithms that will

00:00:39,420 --> 00:00:46,289
tentatively be in the C++ 17 standard so

00:00:44,219 --> 00:00:48,390
I'm not really gonna talk about how

00:00:46,289 --> 00:00:51,510
particular compiler vendors might

00:00:48,390 --> 00:00:52,829
implement the parallel algorithms the

00:00:51,510 --> 00:00:54,420
reason that is the parallel rhythm

00:00:52,829 --> 00:00:56,160
library was designed as a way for

00:00:54,420 --> 00:00:58,770
programmers to request parallelization

00:00:56,160 --> 00:01:00,859
and constraints in that parallelization

00:00:58,770 --> 00:01:03,629
and the interface was designed to be

00:01:00,859 --> 00:01:06,060
agnostic to the implementation so in my

00:01:03,629 --> 00:01:09,030
talk today I'm going also be agnostic to

00:01:06,060 --> 00:01:11,549
the implementation I'm going to focus on

00:01:09,030 --> 00:01:12,659
how you use the parallel algorithms

00:01:11,549 --> 00:01:13,770
library and it really focus on the

00:01:12,659 --> 00:01:16,590
interface it's not going to talk too

00:01:13,770 --> 00:01:19,770
much about sort of the details aside

00:01:16,590 --> 00:01:21,150
from what the constraints mean if you're

00:01:19,770 --> 00:01:23,009
interested in looking at particular

00:01:21,150 --> 00:01:25,229
implementation I'd recommend hpx

00:01:23,009 --> 00:01:28,140
I'm a little biased though so something

00:01:25,229 --> 00:01:30,930
like thrust or boost compute or other

00:01:28,140 --> 00:01:32,549
implementations the parallel rhythms

00:01:30,930 --> 00:01:35,729
library has not yet been implemented in

00:01:32,549 --> 00:01:37,650
any of the major C++ standard libraries

00:01:35,729 --> 00:01:39,150
but we'll probably start to see

00:01:37,650 --> 00:01:40,560
implementations in the next year or so

00:01:39,150 --> 00:01:43,890
given that it's right now in the

00:01:40,560 --> 00:01:46,380
committee draft for the 17 standard so

00:01:43,890 --> 00:01:50,909
I'm first gonna talk about why we need

00:01:46,380 --> 00:01:53,939
parallel algorithms in C++ so in 2012

00:01:50,909 --> 00:01:56,490
Sean parent gave a keynote at C++ now

00:01:53,939 --> 00:01:59,070
and during that talk he said without

00:01:56,490 --> 00:02:01,469
addressing vectorization GPU computing

00:01:59,070 --> 00:02:03,180
scalable parallelism standard C++ is

00:02:01,469 --> 00:02:05,000
just a scripting system to get the other

00:02:03,180 --> 00:02:07,320
99% of the machine through other

00:02:05,000 --> 00:02:11,310
languages and libraries and he showed

00:02:07,320 --> 00:02:13,620
this slide and so this this slide is his

00:02:11,310 --> 00:02:14,319
intention was to demonstrate that prior

00:02:13,620 --> 00:02:16,150
to see Faust

00:02:14,319 --> 00:02:18,609
you can only utilize a small percentage

00:02:16,150 --> 00:02:19,749
of your hardware with only standard C++

00:02:18,609 --> 00:02:22,359
and nothing else

00:02:19,749 --> 00:02:25,150
now just adding threading would get you

00:02:22,359 --> 00:02:27,370
a little bit it's maybe a little hard to

00:02:25,150 --> 00:02:28,530
see this pointer here but you can see

00:02:27,370 --> 00:02:30,909
this little pink region right here

00:02:28,530 --> 00:02:34,180
that's what you get from from just

00:02:30,909 --> 00:02:36,819
threading but you lose all of this here

00:02:34,180 --> 00:02:38,590
from not utilizing vectorization from

00:02:36,819 --> 00:02:41,650
not utilizing any accelerators that you

00:02:38,590 --> 00:02:43,540
might have so a lot of you may be

00:02:41,650 --> 00:02:45,969
familiar with herb setters article free

00:02:43,540 --> 00:02:47,769
lunches over from from a few years ago

00:02:45,969 --> 00:02:49,900
which described the end of CPU frequency

00:02:47,769 --> 00:02:52,269
growth and the rise of multi process

00:02:49,900 --> 00:02:54,069
multi-core processors and how we needed

00:02:52,269 --> 00:02:55,480
to adapt we needed to start thinking

00:02:54,069 --> 00:02:57,069
about parallelism and software that

00:02:55,480 --> 00:02:58,599
previously didn't need to have

00:02:57,069 --> 00:02:59,739
parallelism because parallelism was the

00:02:58,599 --> 00:03:02,489
new way that you would get additional

00:02:59,739 --> 00:03:05,079
performance and we have adapted to that

00:03:02,489 --> 00:03:06,669
but now we're reaching the end of CPU

00:03:05,079 --> 00:03:09,609
core growth it's becoming harder and

00:03:06,669 --> 00:03:12,609
harder to add additional course a

00:03:09,609 --> 00:03:15,010
traditional cache coherent heavyweight

00:03:12,609 --> 00:03:18,389
CPU designs so we're starting to move

00:03:15,010 --> 00:03:21,790
towards lightweight cores simply

00:03:18,389 --> 00:03:23,560
processing so GPUs type processing other

00:03:21,790 --> 00:03:27,669
types of accelerators specialized

00:03:23,560 --> 00:03:29,650
accelerators on package FPGAs on package

00:03:27,669 --> 00:03:32,739
high bandwidth memory technologies like

00:03:29,650 --> 00:03:34,870
MC dram and HMC and so what all this

00:03:32,739 --> 00:03:37,030
means is that free lunch is over again

00:03:34,870 --> 00:03:38,500
so now we have to sort of adapt to a

00:03:37,030 --> 00:03:40,509
whole new set of things and this time

00:03:38,500 --> 00:03:42,250
it's worse because the hardware is both

00:03:40,509 --> 00:03:44,259
increasingly parallel and increasingly

00:03:42,250 --> 00:03:46,139
diverse so now we've reached a point

00:03:44,259 --> 00:03:48,250
where we're starting to move towards

00:03:46,139 --> 00:03:49,509
specialization of we're gonna have this

00:03:48,250 --> 00:03:51,729
this hardware that's going to be very

00:03:49,509 --> 00:03:53,519
specialized for this type of task and so

00:03:51,729 --> 00:03:56,859
it's very difficult to sort of write

00:03:53,519 --> 00:03:59,859
portable software that can run on

00:03:56,859 --> 00:04:02,530
multiple modern systems and really fully

00:03:59,859 --> 00:04:04,030
utilize them today so what we really

00:04:02,530 --> 00:04:06,040
need is vendor-neutral parallel

00:04:04,030 --> 00:04:08,949
programming abstractions that can target

00:04:06,040 --> 00:04:11,079
multiple different architectures and

00:04:08,949 --> 00:04:14,229
systems without leaving performance on

00:04:11,079 --> 00:04:15,879
the table so in C++ 11 and 14 we have

00:04:14,229 --> 00:04:17,109
low level concurrency primitives so we

00:04:15,879 --> 00:04:18,519
don't really have any higher level

00:04:17,109 --> 00:04:20,199
generic abstractions for parallel

00:04:18,519 --> 00:04:23,469
programming and that's what the parallel

00:04:20,199 --> 00:04:24,639
algorithm cyber library adds but before

00:04:23,469 --> 00:04:27,070
I get into that I first want to talk

00:04:24,639 --> 00:04:28,210
about what it's based on which is the

00:04:27,070 --> 00:04:30,880
standard algorithms

00:04:28,210 --> 00:04:32,289
library so this is a question that I

00:04:30,880 --> 00:04:33,789
came across is one of the first things I

00:04:32,289 --> 00:04:36,190
was putting any of this slides was well

00:04:33,789 --> 00:04:39,009
what our what our standard algorithms so

00:04:36,190 --> 00:04:41,410
the standard says that the algorithms

00:04:39,009 --> 00:04:43,569
library describes components that C++

00:04:41,410 --> 00:04:45,190
programs may use to perform algorithmic

00:04:43,569 --> 00:04:47,500
operations on containers and other

00:04:45,190 --> 00:04:49,240
sequences so that sort of seems

00:04:47,500 --> 00:04:50,710
fundamental that it's these these

00:04:49,240 --> 00:04:52,449
algorithms that they operate on

00:04:50,710 --> 00:04:54,789
sequences so what are they they're

00:04:52,449 --> 00:04:56,050
generic operations on sequences but

00:04:54,789 --> 00:04:57,639
there's a caveat that there's some

00:04:56,050 --> 00:04:59,289
things that are in the algorithm header

00:04:57,639 --> 00:05:01,330
that don't operate on sequences but

00:04:59,289 --> 00:05:03,130
let's just ignore those for now just

00:05:01,330 --> 00:05:05,139
standard algorithms or these generic

00:05:03,130 --> 00:05:06,970
operations on sequences so there's three

00:05:05,139 --> 00:05:08,470
types of these operations

00:05:06,970 --> 00:05:10,389
so there's non modifying sequence

00:05:08,470 --> 00:05:12,550
operations like for each and find

00:05:10,389 --> 00:05:14,020
there's mutating sequence operations

00:05:12,550 --> 00:05:16,270
like transform and copy

00:05:14,020 --> 00:05:20,080
there's sorting and related operations

00:05:16,270 --> 00:05:22,419
so things like sort and binary search so

00:05:20,080 --> 00:05:24,520
the new parent logarithms library

00:05:22,419 --> 00:05:26,500
provides paralyzed versions of these

00:05:24,520 --> 00:05:28,599
sequence operations and it's going to

00:05:26,500 --> 00:05:29,650
tension heavily be in C++ 17 as I said

00:05:28,599 --> 00:05:32,349
it's right now it's in the committee

00:05:29,650 --> 00:05:34,419
draft which which means that it's it's

00:05:32,349 --> 00:05:38,680
very likely going to be in there there

00:05:34,419 --> 00:05:41,590
may be some bug fixes that go in okay so

00:05:38,680 --> 00:05:42,820
what do I mean by parallel so as I said

00:05:41,590 --> 00:05:44,139
there's a lot of different types of

00:05:42,820 --> 00:05:46,780
parallelism a lot of different types of

00:05:44,139 --> 00:05:48,460
parallel hardware and most platforms

00:05:46,780 --> 00:05:50,169
expose different types of parallelism

00:05:48,460 --> 00:05:52,060
and multiple types of parallelism so

00:05:50,169 --> 00:05:55,030
there's I like to think of five basic

00:05:52,060 --> 00:05:57,550
levels of parallelism so the bit level

00:05:55,030 --> 00:05:59,169
of parallelism is is parallelism exposed

00:05:57,550 --> 00:06:01,389
by the word size that individual

00:05:59,169 --> 00:06:03,729
hardware components operate on this is

00:06:01,389 --> 00:06:05,530
this is implicit you almost never see

00:06:03,729 --> 00:06:07,300
this directly in your software you don't

00:06:05,530 --> 00:06:08,800
have to think about this frequently the

00:06:07,300 --> 00:06:10,659
people who make hardware free think

00:06:08,800 --> 00:06:12,340
about this for you instruction level

00:06:10,659 --> 00:06:13,900
parallelism is that parallelism exposed

00:06:12,340 --> 00:06:16,539
through the simultaneous execution of

00:06:13,900 --> 00:06:17,949
instructions you mostly don't have to

00:06:16,539 --> 00:06:20,380
think about this unless you're somebody

00:06:17,949 --> 00:06:21,789
like me who has to sweat cycles very

00:06:20,380 --> 00:06:24,070
frequently and has to think about how

00:06:21,789 --> 00:06:25,570
does the branch predictor going to

00:06:24,070 --> 00:06:27,969
function in this particular piece of

00:06:25,570 --> 00:06:29,680
software but usually the idea is that

00:06:27,969 --> 00:06:31,960
instruction level parallelism is also

00:06:29,680 --> 00:06:34,599
hidden from you that magical Hardware

00:06:31,960 --> 00:06:37,000
smarts will just sort of make it all

00:06:34,599 --> 00:06:38,229
work under the hood the vector level

00:06:37,000 --> 00:06:40,419
parallelism is parallelism which is

00:06:38,229 --> 00:06:41,689
exposed by instructions and hardware

00:06:40,419 --> 00:06:44,029
units that operate on multiple

00:06:41,689 --> 00:06:46,789
words simultaneously so this is sort of

00:06:44,029 --> 00:06:48,589
the middle ground you get a good amount

00:06:46,789 --> 00:06:51,289
of vector pair of vector parallelism

00:06:48,589 --> 00:06:52,999
from Otto vectorizing compilers but if

00:06:51,289 --> 00:06:54,769
you really want to ensure that you've

00:06:52,999 --> 00:06:56,149
got good vectorization you have to go

00:06:54,769 --> 00:06:57,919
out of your way to address it in some

00:06:56,149 --> 00:06:59,449
way explicitly maybe you just need to

00:06:57,919 --> 00:07:01,159
give your compiler some hints so it's

00:06:59,449 --> 00:07:02,809
not like fully explicit but just like

00:07:01,159 --> 00:07:04,729
hint it like hey here are some

00:07:02,809 --> 00:07:07,039
suggestions that will help you know that

00:07:04,729 --> 00:07:09,259
you can vectorize this code then there's

00:07:07,039 --> 00:07:10,669
task level parallelism which is peral's

00:07:09,259 --> 00:07:13,219
and that you is exposed through the

00:07:10,669 --> 00:07:14,899
simultaneous execution of tasks that are

00:07:13,219 --> 00:07:17,089
communicating in some fashion and that

00:07:14,899 --> 00:07:18,229
share a primary address space and then

00:07:17,089 --> 00:07:20,029
finally there's process level

00:07:18,229 --> 00:07:21,409
parallelism which is paralyzed I'm

00:07:20,029 --> 00:07:23,329
exposed through the simultaneous

00:07:21,409 --> 00:07:25,489
execution of different processes which

00:07:23,329 --> 00:07:28,249
communicate via messages or shared

00:07:25,489 --> 00:07:30,289
memory regions and don't have a shared

00:07:28,249 --> 00:07:32,329
address space and so sort of at the

00:07:30,289 --> 00:07:35,719
bottom here this is very explicit and at

00:07:32,329 --> 00:07:37,189
the top here it's very inclusive so the

00:07:35,719 --> 00:07:38,869
parallel algorithms library today

00:07:37,189 --> 00:07:41,659
provides vector and task level

00:07:38,869 --> 00:07:43,879
parallelism so in the future it might

00:07:41,659 --> 00:07:45,829
provide process level parallelism like

00:07:43,879 --> 00:07:46,879
distributed computing support right now

00:07:45,829 --> 00:07:48,739
we're provided these two levels and

00:07:46,879 --> 00:07:50,239
that's sort of what we need these top

00:07:48,739 --> 00:07:52,099
two levels are not something that you

00:07:50,239 --> 00:07:53,829
really need to explicitly address at all

00:07:52,099 --> 00:07:56,899
in your software

00:07:53,829 --> 00:07:58,249
so there's five main components to the

00:07:56,899 --> 00:08:00,469
parallelograms library first of all

00:07:58,249 --> 00:08:01,999
there's this concept of an execution

00:08:00,469 --> 00:08:05,869
policy that I'm gonna get to in a minute

00:08:01,999 --> 00:08:08,300
then there's three standard types that

00:08:05,869 --> 00:08:10,429
that implement that concept then there

00:08:08,300 --> 00:08:12,739
are the algorithms themselves so they

00:08:10,429 --> 00:08:14,449
come in the ones that are just versions

00:08:12,739 --> 00:08:16,429
of the existing algorithms they come in

00:08:14,449 --> 00:08:18,079
the form of new overloads that take an

00:08:16,429 --> 00:08:20,300
execution policy is their first

00:08:18,079 --> 00:08:22,639
parameter and then there are some new

00:08:20,300 --> 00:08:24,949
unordered algorithms that are based on

00:08:22,639 --> 00:08:26,300
existing ordered algorithms basically

00:08:24,949 --> 00:08:28,909
these algorithms are algorithms where

00:08:26,300 --> 00:08:30,829
the wording of the serial version would

00:08:28,909 --> 00:08:33,740
prohibit us from vectorize it from

00:08:30,829 --> 00:08:35,000
paralyzing it so we've created a new

00:08:33,740 --> 00:08:37,419
version that has slightly different

00:08:35,000 --> 00:08:39,229
wording that relaxes some of the the

00:08:37,419 --> 00:08:40,699
guarantees about the ordering of

00:08:39,229 --> 00:08:42,349
operations and would allow us to

00:08:40,699 --> 00:08:44,660
paralyze them and then we have fused

00:08:42,349 --> 00:08:47,209
algorithms which are combinations of

00:08:44,660 --> 00:08:48,620
other algorithms which wit by combining

00:08:47,209 --> 00:08:50,149
them were able to create a more

00:08:48,620 --> 00:08:52,519
efficient implementation than we would

00:08:50,149 --> 00:08:54,290
otherwise have all right so let's start

00:08:52,519 --> 00:08:55,430
off with execution policies so an

00:08:54,290 --> 00:08:57,350
execution policy does

00:08:55,430 --> 00:08:59,720
scribes how a generic algorithm maybe

00:08:57,350 --> 00:09:02,089
paralyzed they allowed programmers to

00:08:59,720 --> 00:09:03,980
request parallelism and to describe the

00:09:02,089 --> 00:09:05,870
constraints on parallelism so what type

00:09:03,980 --> 00:09:07,250
of parallelism what I like and I don't

00:09:05,870 --> 00:09:08,839
mean that in terms of like saying like I

00:09:07,250 --> 00:09:10,760
would like you to use my GPU what you

00:09:08,839 --> 00:09:12,980
say is like I would like like these this

00:09:10,760 --> 00:09:15,050
sort these sorts of operations are okay

00:09:12,980 --> 00:09:16,580
like this you can do this sort of thing

00:09:15,050 --> 00:09:18,260
to my code and it will be alright and

00:09:16,580 --> 00:09:20,120
then whatever the implementation is

00:09:18,260 --> 00:09:21,860
under the hood will figure out you know

00:09:20,120 --> 00:09:24,020
oh I can use this or I can do this or I

00:09:21,860 --> 00:09:25,339
can do this so there's three standard

00:09:24,020 --> 00:09:27,860
ones that I mentioned

00:09:25,339 --> 00:09:30,200
so there's stood seek stood par and

00:09:27,860 --> 00:09:32,750
stood par on seek so stood seek is

00:09:30,200 --> 00:09:34,760
mainly there for debugging it is a

00:09:32,750 --> 00:09:36,410
policy that specifies that operations

00:09:34,760 --> 00:09:37,850
will be indeterminately sequenced in the

00:09:36,410 --> 00:09:39,950
calling thread so indeterminately

00:09:37,850 --> 00:09:42,050
sequence just means that they will they

00:09:39,950 --> 00:09:43,970
will be sequenced in some order we won't

00:09:42,050 --> 00:09:46,010
tell you what but that that order will

00:09:43,970 --> 00:09:47,270
hold and that it will only be in the

00:09:46,010 --> 00:09:49,190
calling thread there will be no new

00:09:47,270 --> 00:09:51,890
threads created so it's just serial

00:09:49,190 --> 00:09:53,450
basically then there's stood par which

00:09:51,890 --> 00:09:55,279
says operations are intent and

00:09:53,450 --> 00:09:57,649
determinately sequenced with respect to

00:09:55,279 --> 00:09:59,750
each other within the same thread so

00:09:57,649 --> 00:10:02,750
stood par says paralyze but please do

00:09:59,750 --> 00:10:04,370
not vectorize stood par on seek says

00:10:02,750 --> 00:10:06,080
operations are uncie quenched with

00:10:04,370 --> 00:10:08,120
respect to each other and possibly

00:10:06,080 --> 00:10:10,400
interleaved in there's special magical

00:10:08,120 --> 00:10:14,440
language there and that magical language

00:10:10,400 --> 00:10:16,730
is what lets us have a library

00:10:14,440 --> 00:10:17,900
functionality that supports

00:10:16,730 --> 00:10:20,300
vectorization because the special

00:10:17,900 --> 00:10:22,130
language says hey you can do some magic

00:10:20,300 --> 00:10:23,600
and like inner leave these functions in

00:10:22,130 --> 00:10:25,459
ways that normally you wouldn't be

00:10:23,600 --> 00:10:26,839
allowed to do this with like just some

00:10:25,459 --> 00:10:28,520
function object that somebody gave you

00:10:26,839 --> 00:10:30,709
but it's all right here and so that's

00:10:28,520 --> 00:10:32,900
saying I want both parallelism and I

00:10:30,709 --> 00:10:35,360
want vectorization so both both task

00:10:32,900 --> 00:10:38,240
parallelism and vector level parallelism

00:10:35,360 --> 00:10:39,200
so let's look at an example of how these

00:10:38,240 --> 00:10:41,120
two are different

00:10:39,200 --> 00:10:43,279
so how Parsi poorer and poorer and

00:10:41,120 --> 00:10:45,680
seeker different so suppose that we want

00:10:43,279 --> 00:10:47,510
to use the following binary operation

00:10:45,680 --> 00:10:50,050
this multiply here with a stood

00:10:47,510 --> 00:10:52,579
transform so we've got some input here

00:10:50,050 --> 00:10:55,370
and so basically what we want to do is

00:10:52,579 --> 00:10:58,459
we want to do X I equals x I times y for

00:10:55,370 --> 00:11:01,940
each iteration of these two different

00:10:58,459 --> 00:11:03,950
sequences there may be vectors so let's

00:11:01,940 --> 00:11:06,020
sort of compile this to sort of a pseudo

00:11:03,950 --> 00:11:07,790
assembly here so what does this look

00:11:06,020 --> 00:11:08,899
like well we're going to load X ID or

00:11:07,790 --> 00:11:10,670
some scalar register

00:11:08,899 --> 00:11:11,720
then we're gonna load weii to some

00:11:10,670 --> 00:11:13,490
scalar register then we're gonna

00:11:11,720 --> 00:11:15,949
multiply these two together and we're

00:11:13,490 --> 00:11:18,199
gonna store the results in X I so with

00:11:15,949 --> 00:11:19,759
stood par you get something like this

00:11:18,199 --> 00:11:21,290
where you have we've got multiple

00:11:19,759 --> 00:11:25,309
iterations and maybe each one is

00:11:21,290 --> 00:11:28,100
executed on a different thread but they

00:11:25,309 --> 00:11:29,959
will not be interleaved at all that each

00:11:28,100 --> 00:11:32,480
one will will be just it'll be treated

00:11:29,959 --> 00:11:34,179
like a regular function it'll be each

00:11:32,480 --> 00:11:37,579
step it will be executed in sequence

00:11:34,179 --> 00:11:40,189
what stood par what stood par and seeks

00:11:37,579 --> 00:11:41,990
as is you're allowed to both enter leave

00:11:40,189 --> 00:11:44,119
and sherwin these things and multiple

00:11:41,990 --> 00:11:45,410
threads so like one thing we could do is

00:11:44,119 --> 00:11:47,809
we could say hey let's move all the

00:11:45,410 --> 00:11:50,149
loads of X up here to the top and all

00:11:47,809 --> 00:11:52,369
the loads of y up here and all of them

00:11:50,149 --> 00:11:55,189
multiplies here and all the stores down

00:11:52,369 --> 00:11:57,050
here and then with vector instructions

00:11:55,189 --> 00:11:58,910
we could reduce that down to something

00:11:57,050 --> 00:12:00,860
like this where we say halo 2 vectors

00:11:58,910 --> 00:12:04,160
worth of X is load of vectors worth of

00:12:00,860 --> 00:12:06,139
Y's and then multiply those two vectors

00:12:04,160 --> 00:12:09,170
of data together and then store the

00:12:06,139 --> 00:12:10,490
results to this location thing and so

00:12:09,170 --> 00:12:11,809
again this is possible because we've

00:12:10,490 --> 00:12:14,990
allowed this this I'm leaving

00:12:11,809 --> 00:12:17,449
interleaving here and okay the next

00:12:14,990 --> 00:12:21,139
component is all these new overloads so

00:12:17,449 --> 00:12:24,559
these are all of the existing algorithms

00:12:21,139 --> 00:12:27,170
that have overloads the table of ones

00:12:24,559 --> 00:12:29,269
that don't have parallel overloads is

00:12:27,170 --> 00:12:31,069
probably more useful but unfortunately I

00:12:29,269 --> 00:12:33,470
don't have it so most of them have it

00:12:31,069 --> 00:12:35,839
there's a couple exceptions it for

00:12:33,470 --> 00:12:37,730
example the order two algorithms that we

00:12:35,839 --> 00:12:39,499
can't paralyze those don't have

00:12:37,730 --> 00:12:42,110
overloads so like accumulate is missing

00:12:39,499 --> 00:12:43,999
here for example inner product is

00:12:42,110 --> 00:12:45,439
missing here for example and there

00:12:43,999 --> 00:12:46,999
there's there's a couple others so like

00:12:45,439 --> 00:12:50,240
there's obviously there's no parallel

00:12:46,999 --> 00:12:51,379
manner max and I've highlighted sort of

00:12:50,240 --> 00:12:54,049
the most useful ones

00:12:51,379 --> 00:12:57,199
so for each sort and transform our

00:12:54,049 --> 00:12:59,360
particular useful ones in a parallel

00:12:57,199 --> 00:13:00,709
context so one thing to note about for

00:12:59,360 --> 00:13:02,149
each is that it's a little different in

00:13:00,709 --> 00:13:04,519
the parallel version the serial version

00:13:02,149 --> 00:13:06,079
returns the urinary function argument

00:13:04,519 --> 00:13:07,790
that's the input the parallel version

00:13:06,079 --> 00:13:10,970
does not because that's not really to do

00:13:07,790 --> 00:13:13,429
it would work for a parallel for each so

00:13:10,970 --> 00:13:15,589
using these is pretty easy so like this

00:13:13,429 --> 00:13:18,559
is parallel sort you just here's a

00:13:15,589 --> 00:13:20,660
vector can you sort it first argument is

00:13:18,559 --> 00:13:21,889
going to be an execution policy it will

00:13:20,660 --> 00:13:26,389
be sorted in some

00:13:21,889 --> 00:13:28,579
in parallel so for each here what we're

00:13:26,389 --> 00:13:30,019
saying to say par and seek for this and

00:13:28,579 --> 00:13:31,759
what I'm saying here with the with the

00:13:30,019 --> 00:13:33,949
uncie cuz I'm sayin hey I'm giving you

00:13:31,759 --> 00:13:35,869
this function and process and you can go

00:13:33,949 --> 00:13:38,329
and like decompose it and interleave it

00:13:35,869 --> 00:13:39,439
and do crazy stuff under the hood so

00:13:38,329 --> 00:13:42,259
that you can vectorize it and that's

00:13:39,439 --> 00:13:43,879
alright now if for whatever reason that

00:13:42,259 --> 00:13:45,109
was gonna be a problem for me that was

00:13:43,879 --> 00:13:47,149
gonna break my code I could just change

00:13:45,109 --> 00:13:49,399
this to par and then it would be fine so

00:13:47,149 --> 00:13:53,359
this is roughly equivalent to this

00:13:49,399 --> 00:13:55,699
so pragma OMP parallel force md it just

00:13:53,359 --> 00:13:59,149
looks much nicer and it's an actual c++

00:13:55,699 --> 00:14:00,769
construct all right so then there's the

00:13:59,149 --> 00:14:03,649
new unordered algorithms that are based

00:14:00,769 --> 00:14:05,989
on ordered algorithms so should reduce

00:14:03,649 --> 00:14:08,149
which is an unordered accumulate there

00:14:05,989 --> 00:14:09,799
is stood inclusive scan and exclusive

00:14:08,149 --> 00:14:12,230
scan which are unordered partial sums

00:14:09,799 --> 00:14:14,989
and then there's transform reduce which

00:14:12,230 --> 00:14:18,439
is an unordered inner product so these

00:14:14,989 --> 00:14:20,389
are also some of the more useful ones

00:14:18,439 --> 00:14:23,809
that pretty much all of the examples

00:14:20,389 --> 00:14:25,699
will use these algorithms these are the

00:14:23,809 --> 00:14:28,100
components of the pair algorithm is like

00:14:25,699 --> 00:14:30,470
library you're most likely to use with

00:14:28,100 --> 00:14:33,980
the exception of sort also being fairly

00:14:30,470 --> 00:14:35,569
useful in this context alright so first

00:14:33,980 --> 00:14:36,889
let's start with wizard reduce so as I

00:14:35,569 --> 00:14:39,350
said it's it's a nun order to accumulate

00:14:36,889 --> 00:14:41,149
the interface is the same so at first

00:14:39,350 --> 00:14:43,579
you got the execution policy then you've

00:14:41,149 --> 00:14:45,970
got some input sequence then you have

00:14:43,579 --> 00:14:48,019
the initial value for the reduction

00:14:45,970 --> 00:14:49,850
which is applied for the first element

00:14:48,019 --> 00:14:52,759
and then you have this binary up and

00:14:49,850 --> 00:14:53,899
that binary op is a callable that's

00:14:52,759 --> 00:14:55,249
going to be applied to consecutive

00:14:53,899 --> 00:14:57,410
elements and it's also going to be

00:14:55,249 --> 00:14:59,089
applied to other invocations of the OP

00:14:57,410 --> 00:15:01,699
so it's like it'll do like a tree

00:14:59,089 --> 00:15:05,239
structure and by default that's that's

00:15:01,699 --> 00:15:07,069
stood plus and the net value thereby is

00:15:05,239 --> 00:15:10,160
by default just the default constructed

00:15:07,069 --> 00:15:12,019
tea so the difference is between stood

00:15:10,160 --> 00:15:14,089
accumulate instead of reduce is this so

00:15:12,019 --> 00:15:17,869
stoat accumulates says hey first you

00:15:14,089 --> 00:15:20,359
treat some temporary some value at ACC

00:15:17,869 --> 00:15:23,089
of type T and initialize it with that

00:15:20,359 --> 00:15:25,549
initial value then for every iterator in

00:15:23,089 --> 00:15:27,679
this range in order go and apply this

00:15:25,549 --> 00:15:31,489
operation here of applying the binary

00:15:27,679 --> 00:15:33,289
operator to to this here and so you can

00:15:31,489 --> 00:15:34,549
see here this is not you couldn't

00:15:33,289 --> 00:15:35,420
paralyze this because every iteration

00:15:34,549 --> 00:15:38,030
depends on

00:15:35,420 --> 00:15:40,820
previous iteration so what stood reduce

00:15:38,030 --> 00:15:43,700
says is it says this thing it says do

00:15:40,820 --> 00:15:46,940
this G something of this binary up and

00:15:43,700 --> 00:15:50,150
then in it and first so before we get

00:15:46,940 --> 00:15:53,780
into what that is we have to step aside

00:15:50,150 --> 00:15:54,680
and take a quick math review so the

00:15:53,780 --> 00:15:56,270
reason for that is because the

00:15:54,680 --> 00:15:59,510
difference between reduce and accumulate

00:15:56,270 --> 00:16:02,060
is that with reduce you'll get a

00:15:59,510 --> 00:16:04,700
non-deterministic result for a non

00:16:02,060 --> 00:16:06,770
associative or non commutative like

00:16:04,700 --> 00:16:09,470
floating point addition is not a not

00:16:06,770 --> 00:16:11,480
commutative and not associative so that

00:16:09,470 --> 00:16:14,740
you might get a non-deterministic result

00:16:11,480 --> 00:16:20,330
here if you just did stood reduce with

00:16:14,740 --> 00:16:22,460
just floats or doubles so this is the

00:16:20,330 --> 00:16:23,660
quick math math review some utility

00:16:22,460 --> 00:16:25,360
means that changing the order of

00:16:23,660 --> 00:16:27,470
operations does not change the result

00:16:25,360 --> 00:16:30,350
addition multiplication or commutative

00:16:27,470 --> 00:16:32,240
subtraction is not associativity means

00:16:30,350 --> 00:16:35,300
that the grouping of operations does not

00:16:32,240 --> 00:16:37,180
change the result so again addition and

00:16:35,300 --> 00:16:39,770
multiplication for integers is

00:16:37,180 --> 00:16:41,420
associative and subtraction is not for

00:16:39,770 --> 00:16:43,940
floating-point types they're not because

00:16:41,420 --> 00:16:46,160
the order of operations may change may

00:16:43,940 --> 00:16:48,350
determine how many you know bits get cut

00:16:46,160 --> 00:16:50,270
off in certain places all right so let's

00:16:48,350 --> 00:16:52,490
go back to that G something but first

00:16:50,270 --> 00:16:54,830
I've got to define another weird

00:16:52,490 --> 00:16:57,260
ambiguous operation which is this thing

00:16:54,830 --> 00:16:59,810
so this is G n sum which stands for

00:16:57,260 --> 00:17:02,540
generalized non-community of son so

00:16:59,810 --> 00:17:04,700
we've got it takes two arguments really

00:17:02,540 --> 00:17:07,340
it takes an op some operator and then a

00:17:04,700 --> 00:17:09,470
sequence of thing needs and it's a

00:17:07,340 --> 00:17:12,040
piecewise function so if the number of

00:17:09,470 --> 00:17:15,380
things in the sequence is 1 then this

00:17:12,040 --> 00:17:16,460
operation just returns the the thing in

00:17:15,380 --> 00:17:18,650
the sequence that whatever the one

00:17:16,460 --> 00:17:21,590
argument was but otherwise what it does

00:17:18,650 --> 00:17:25,130
is it will go and it'll do two recursive

00:17:21,590 --> 00:17:27,890
calls on some subsequence of the input

00:17:25,130 --> 00:17:30,740
and the the partition point can be

00:17:27,890 --> 00:17:32,600
arbitrary so that it could be just like

00:17:30,740 --> 00:17:34,430
two elements could be like half the

00:17:32,600 --> 00:17:38,030
elements could be whatever and then it

00:17:34,430 --> 00:17:40,490
will call the operator on the result of

00:17:38,030 --> 00:17:41,780
the two recursive calls here and then of

00:17:40,490 --> 00:17:43,730
course those recursive calls could also

00:17:41,780 --> 00:17:45,440
recur stem so they could have some tree

00:17:43,730 --> 00:17:47,270
structure and again as I said that K

00:17:45,440 --> 00:17:48,929
there is arbitrary so this is the

00:17:47,270 --> 00:17:52,769
generalized non-community of

00:17:48,929 --> 00:17:56,009
some so the other thing G some the

00:17:52,769 --> 00:17:58,200
generalized some that is what we how we

00:17:56,009 --> 00:17:59,999
specify reduce is very similar what it

00:17:58,200 --> 00:18:01,320
basically just says is that it's the

00:17:59,999 --> 00:18:04,590
same thing as the generalized non

00:18:01,320 --> 00:18:09,740
commutative sum but it can reconfirm

00:18:04,590 --> 00:18:14,419
mute the elements in the sequence so the

00:18:09,740 --> 00:18:17,610
difference is that this here is

00:18:14,419 --> 00:18:19,139
unspecified for non commutative obso GN

00:18:17,610 --> 00:18:21,860
some is unspecified for non commutative

00:18:19,139 --> 00:18:25,590
ops but it's not it's fine for

00:18:21,860 --> 00:18:28,080
non-associative ops g some here is

00:18:25,590 --> 00:18:31,049
unequal give you some unspecified result

00:18:28,080 --> 00:18:33,869
for both non associate for

00:18:31,049 --> 00:18:35,850
non-associative and non community ops so

00:18:33,869 --> 00:18:37,499
this is why reduce gives you a

00:18:35,850 --> 00:18:38,999
non-deterministic result for non

00:18:37,499 --> 00:18:40,769
community of not associated by ops cuz

00:18:38,999 --> 00:18:42,960
it's it's this is how its weights for

00:18:40,769 --> 00:18:44,730
tit so what does this mean well so if

00:18:42,960 --> 00:18:46,320
you've got this here if I've got some

00:18:44,730 --> 00:18:47,610
vector and I want to accumulate it it's

00:18:46,320 --> 00:18:49,200
very straightforward what actually

00:18:47,610 --> 00:18:51,240
happens if we would just want them to

00:18:49,200 --> 00:18:53,730
like inline this function in our head we

00:18:51,240 --> 00:18:55,200
would just do this right so we got these

00:18:53,730 --> 00:18:58,169
five elements here we're going to

00:18:55,200 --> 00:19:00,840
accumulate them okay well we've got some

00:18:58,169 --> 00:19:02,850
initial value here zero so that's what

00:19:00,840 --> 00:19:04,529
the initial value is here and then for

00:19:02,850 --> 00:19:08,450
each iteration we just sort of add on to

00:19:04,529 --> 00:19:11,190
it straightforward okay so with reduce

00:19:08,450 --> 00:19:12,990
this is one of the possible things that

00:19:11,190 --> 00:19:14,879
could happen but there are many other

00:19:12,990 --> 00:19:16,799
possible things that could happen so you

00:19:14,879 --> 00:19:19,799
could get this but you could also get

00:19:16,799 --> 00:19:22,110
this because it's allowed to permeate

00:19:19,799 --> 00:19:24,179
the the per the order in which the

00:19:22,110 --> 00:19:26,009
elements are are operated on could be

00:19:24,179 --> 00:19:27,210
permuted so that it could go hey let's

00:19:26,009 --> 00:19:29,820
deal with the second one and the first

00:19:27,210 --> 00:19:33,119
one then the third one then the last one

00:19:29,820 --> 00:19:35,879
then the fourth one and also it can do

00:19:33,119 --> 00:19:37,700
this it can sort of split things off

00:19:35,879 --> 00:19:40,769
into trees and do this recursive

00:19:37,700 --> 00:19:43,590
partitioning of the workload so that you

00:19:40,769 --> 00:19:45,269
could say hey go do this in one task

00:19:43,590 --> 00:19:46,919
over here go do this and another task

00:19:45,269 --> 00:19:50,369
over here and then come and combine them

00:19:46,919 --> 00:19:52,950
together later and then also this this

00:19:50,369 --> 00:19:55,679
this could also be so this is like this

00:19:52,950 --> 00:19:56,129
is it ordered I'm looking throwing aside

00:19:55,679 --> 00:19:58,049
okay

00:19:56,129 --> 00:19:59,809
this is like this is ordered and there

00:19:58,049 --> 00:20:02,900
could also be unorder in here as well

00:19:59,809 --> 00:20:06,740
all right pretty straightforward

00:20:02,900 --> 00:20:17,060
ish any questions on reduce okay right

00:20:06,740 --> 00:20:18,650
there so the question was do you

00:20:17,060 --> 00:20:20,540
guarantee that it will be one of the

00:20:18,650 --> 00:20:23,660
possible orders plus one of the possible

00:20:20,540 --> 00:20:27,770
associations I believe the answer to

00:20:23,660 --> 00:20:30,500
that is yes because the result is its

00:20:27,770 --> 00:20:33,110
unspecified but not undefined behavior

00:20:30,500 --> 00:20:35,200
so it's on some unspecified things

00:20:33,110 --> 00:20:37,580
happens but I might be wrong about that

00:20:35,200 --> 00:20:40,880
pretty sure I'm not but it's something I

00:20:37,580 --> 00:20:42,290
don't have to look up later okay all

00:20:40,880 --> 00:20:45,020
right so next let's talk about inclusive

00:20:42,290 --> 00:20:48,410
scan so inclusive scan is an unordered

00:20:45,020 --> 00:20:50,240
partial sum so it has the same interface

00:20:48,410 --> 00:20:53,150
as partial sum so again it's just it's

00:20:50,240 --> 00:20:54,920
got the execution for a policy parameter

00:20:53,150 --> 00:20:56,990
then it's got some input sequence

00:20:54,920 --> 00:20:59,090
specified as a first and last iterator

00:20:56,990 --> 00:21:01,130
then there's another sequence in an

00:20:59,090 --> 00:21:02,780
output sequence and for the output

00:21:01,130 --> 00:21:04,640
sequence we only have we only have one

00:21:02,780 --> 00:21:06,200
iterator that's given and then it's just

00:21:04,640 --> 00:21:08,480
assumed that that it's going to be the

00:21:06,200 --> 00:21:10,790
same size as the input sequence and then

00:21:08,480 --> 00:21:12,440
you've got an OP and that OP is a binary

00:21:10,790 --> 00:21:14,270
callable it's going to be applied to

00:21:12,440 --> 00:21:16,730
consecutive elements in the results of

00:21:14,270 --> 00:21:18,350
other invitations and also possibly the

00:21:16,730 --> 00:21:21,680
initial value and then we have an

00:21:18,350 --> 00:21:24,260
initial value so the difference between

00:21:21,680 --> 00:21:26,630
inclusive scan and partial sum is that

00:21:24,260 --> 00:21:29,330
inclusive scan applies the off with

00:21:26,630 --> 00:21:30,770
unspecified grouping so it gives a

00:21:29,330 --> 00:21:33,410
non-deterministic result for

00:21:30,770 --> 00:21:36,590
non-associative ups but it's fine for

00:21:33,410 --> 00:21:39,830
noncommutative ups so it's it's it's a

00:21:36,590 --> 00:21:42,890
GN sum is used in defining this not

00:21:39,830 --> 00:21:44,720
ji-sung so slightly different from

00:21:42,890 --> 00:21:46,310
reduced there so what this actually

00:21:44,720 --> 00:21:49,010
looks like so this is like what partial

00:21:46,310 --> 00:21:52,340
summer or inclusive scan looks like so

00:21:49,010 --> 00:21:53,660
the first element of the output is just

00:21:52,340 --> 00:21:55,940
equal to the first element of the input

00:21:53,660 --> 00:21:57,980
the second is equal to the the first

00:21:55,940 --> 00:21:59,450
element of the input plus the second

00:21:57,980 --> 00:22:01,370
moment of the input and so on and so

00:21:59,450 --> 00:22:03,770
forth so on so it's a accumulates the

00:22:01,370 --> 00:22:06,500
sum of all the previous iterations

00:22:03,770 --> 00:22:07,940
they're so exclusive scan is something

00:22:06,500 --> 00:22:10,160
that we didn't previously have a

00:22:07,940 --> 00:22:15,440
corresponding unordered version it's

00:22:10,160 --> 00:22:16,220
just like inclusive scan but it excludes

00:22:15,440 --> 00:22:18,980
the ice

00:22:16,220 --> 00:22:21,470
in the ice some so what I mean by that

00:22:18,980 --> 00:22:23,660
is that like the the first output is

00:22:21,470 --> 00:22:25,670
just equal to the initial value here and

00:22:23,660 --> 00:22:27,350
like the second output here is just

00:22:25,670 --> 00:22:29,240
equal to the whatever the initial value

00:22:27,350 --> 00:22:32,300
is plus the first element it does not

00:22:29,240 --> 00:22:34,250
include the corresponding element so the

00:22:32,300 --> 00:22:36,740
second element of the input in the

00:22:34,250 --> 00:22:39,410
someday and it's particularly useful for

00:22:36,740 --> 00:22:40,730
a number of these parallel programming

00:22:39,410 --> 00:22:43,400
problems which is why it's added and

00:22:40,730 --> 00:22:45,590
there's now a corresponding non

00:22:43,400 --> 00:22:48,230
execution policy-based overload of this

00:22:45,590 --> 00:22:50,150
exclusive scan too but it's sort of it's

00:22:48,230 --> 00:22:52,910
very similar to a partial sum or

00:22:50,150 --> 00:22:55,310
inclusive scan all right and so then we

00:22:52,910 --> 00:22:56,630
have the fused algorithms and the last

00:22:55,310 --> 00:22:58,310
of the fused at were the first this

00:22:56,630 --> 00:23:00,260
views algorithms here transform reduce

00:22:58,310 --> 00:23:02,990
is also one of these algorithms that

00:23:00,260 --> 00:23:04,040
maps directly to an unordered algorithm

00:23:02,990 --> 00:23:05,330
which is inner product

00:23:04,040 --> 00:23:06,950
so there's transformer dudas there's

00:23:05,330 --> 00:23:09,350
transform inclusive scan and transform

00:23:06,950 --> 00:23:11,750
exclusive scan so transform reduce is by

00:23:09,350 --> 00:23:13,760
far the most powerful of these in fact

00:23:11,750 --> 00:23:15,170
this talk probably shouldn't be called

00:23:13,760 --> 00:23:17,390
this it should probably just be called

00:23:15,170 --> 00:23:18,830
transform reduce because that's pretty

00:23:17,390 --> 00:23:20,870
much all that I do here is just show you

00:23:18,830 --> 00:23:23,060
how to use transform reduce it's very

00:23:20,870 --> 00:23:25,790
very very useful algorithm so it looks

00:23:23,060 --> 00:23:27,290
like this okay that should not say

00:23:25,790 --> 00:23:29,120
unordered transform reduce it should say

00:23:27,290 --> 00:23:30,080
unordered inner product there my

00:23:29,120 --> 00:23:32,480
apologies for that

00:23:30,080 --> 00:23:34,310
alright so transform reduce it takes as

00:23:32,480 --> 00:23:36,380
execution policy is the first parameter

00:23:34,310 --> 00:23:38,900
here and then it takes some input

00:23:36,380 --> 00:23:41,990
sequence so first last pair then it

00:23:38,900 --> 00:23:44,990
takes a transformation operator a urn

00:23:41,990 --> 00:23:46,490
Airy transformation operator and then it

00:23:44,990 --> 00:23:48,560
takes some initial value and then a

00:23:46,490 --> 00:23:50,480
reduction operator here now it's

00:23:48,560 --> 00:23:52,910
important to note what the types are of

00:23:50,480 --> 00:23:54,830
this transform operator this ternary

00:23:52,910 --> 00:23:57,020
transform operator in this binary

00:23:54,830 --> 00:23:59,120
reduction operator so here's what the

00:23:57,020 --> 00:24:01,790
signatures look like so the transform

00:23:59,120 --> 00:24:03,680
operator looks like this so it takes

00:24:01,790 --> 00:24:05,750
some T the type of the input sequence

00:24:03,680 --> 00:24:07,490
and it returns some type R of whatever

00:24:05,750 --> 00:24:10,580
type it would like and then the

00:24:07,490 --> 00:24:13,340
reduction operator takes two types are

00:24:10,580 --> 00:24:15,680
and combines them into one type R so

00:24:13,340 --> 00:24:17,600
what when Iced we say transform reduce

00:24:15,680 --> 00:24:19,130
it's two if you want to think about what

00:24:17,600 --> 00:24:21,200
it does it's very simple just transform

00:24:19,130 --> 00:24:23,900
then reduce so what it does is it

00:24:21,200 --> 00:24:25,850
applies the bind it applies the ER nary

00:24:23,900 --> 00:24:28,250
transform up to each element in the

00:24:25,850 --> 00:24:29,810
range first last then it reduces the

00:24:28,250 --> 00:24:32,990
result with the reduction operators

00:24:29,810 --> 00:24:34,220
transform then reduce now is of course a

00:24:32,990 --> 00:24:36,550
little confusing because the way that

00:24:34,220 --> 00:24:39,110
you see it encode is you like this

00:24:36,550 --> 00:24:41,510
reduce and then transform if you sort of

00:24:39,110 --> 00:24:42,530
are writing it out in your head but the

00:24:41,510 --> 00:24:44,000
operate the order in which the

00:24:42,530 --> 00:24:45,710
operations happens is the transformation

00:24:44,000 --> 00:24:47,630
is applied to the input and then the

00:24:45,710 --> 00:24:49,160
reduction is applied one important thing

00:24:47,630 --> 00:24:50,690
to note is that usually when you think

00:24:49,160 --> 00:24:53,330
about transform you think about it as a

00:24:50,690 --> 00:24:55,790
mutating sort of thing to transform the

00:24:53,330 --> 00:24:59,060
serial version right it has some output

00:24:55,790 --> 00:25:01,220
sequence that that it writes to there is

00:24:59,060 --> 00:25:03,470
no output sequence for the transform

00:25:01,220 --> 00:25:04,940
here the value there's this transform

00:25:03,470 --> 00:25:06,860
sequence that gets created but it's sort

00:25:04,940 --> 00:25:08,390
of like a pseudo sequence it's sort of

00:25:06,860 --> 00:25:11,150
created on the fly and it's immediately

00:25:08,390 --> 00:25:13,070
consumed by the reduction op and so this

00:25:11,150 --> 00:25:14,390
is where you get the the benefit from

00:25:13,070 --> 00:25:16,010
confront from instead of just doing a

00:25:14,390 --> 00:25:17,720
transform separately and a reduce

00:25:16,010 --> 00:25:20,870
separately that there's no temporary

00:25:17,720 --> 00:25:22,790
sequence created here all right so like

00:25:20,870 --> 00:25:24,170
this is what it looks like so at the

00:25:22,790 --> 00:25:26,300
base level the first thing you've done

00:25:24,170 --> 00:25:28,370
is the transform off gets applied to the

00:25:26,300 --> 00:25:31,040
input sequence and then the reduction

00:25:28,370 --> 00:25:33,170
off gets used to combine multiple

00:25:31,040 --> 00:25:35,450
transform values and then it also gets

00:25:33,170 --> 00:25:37,820
used to combine multiple reduced values

00:25:35,450 --> 00:25:40,970
and so the tree actually would look a

00:25:37,820 --> 00:25:41,530
lot larger than this potentially all

00:25:40,970 --> 00:25:44,270
right

00:25:41,530 --> 00:25:47,900
so there is a again this slide should

00:25:44,270 --> 00:25:49,990
say unordered stood transferred inner

00:25:47,900 --> 00:25:52,250
product here so there's also a binary

00:25:49,990 --> 00:25:54,050
version of transform reduced there's a

00:25:52,250 --> 00:25:56,480
caveat here which is that the spec is

00:25:54,050 --> 00:25:58,100
currently missing the binary version but

00:25:56,480 --> 00:26:00,560
I think I'm going to be able to fix that

00:25:58,100 --> 00:26:02,870
so I'm the rest of these slides assume

00:26:00,560 --> 00:26:04,100
that the binary overload for transform

00:26:02,870 --> 00:26:07,040
reduce is going to make it into the

00:26:04,100 --> 00:26:08,360
standard I'm pretty confident that this

00:26:07,040 --> 00:26:10,310
is something that we'll be able to fix I

00:26:08,360 --> 00:26:12,380
think it's really just a naming issue

00:26:10,310 --> 00:26:14,090
because they're actually it's specified

00:26:12,380 --> 00:26:17,000
in the standard that there is a parallel

00:26:14,090 --> 00:26:18,620
inner product and that doesn't make a

00:26:17,000 --> 00:26:21,590
lot of sense because we can't paralyze

00:26:18,620 --> 00:26:23,180
inner product so really what we really

00:26:21,590 --> 00:26:24,980
just need to do is rename the parallel

00:26:23,180 --> 00:26:27,860
and our product to transform to

00:26:24,980 --> 00:26:30,260
transform reduce so the the I call this

00:26:27,860 --> 00:26:31,640
the binary transform reduce so the

00:26:30,260 --> 00:26:33,730
distinction between the version I just

00:26:31,640 --> 00:26:36,590
showed you is that this takes a binary

00:26:33,730 --> 00:26:39,950
transform operation and it works on two

00:26:36,590 --> 00:26:41,750
input sequences so the binary transform

00:26:39,950 --> 00:26:43,460
operation is applied two consecutive

00:26:41,750 --> 00:26:45,529
pairs from the two and

00:26:43,460 --> 00:26:47,750
sequences the first input sequence is

00:26:45,529 --> 00:26:49,100
the first one last one sequence and then

00:26:47,750 --> 00:26:51,980
the second input sequence is the

00:26:49,100 --> 00:26:54,289
sequence that starts with first - and so

00:26:51,980 --> 00:26:55,460
the transform op will be applied two

00:26:54,289 --> 00:26:57,289
pairs of elements from those two

00:26:55,460 --> 00:27:00,500
sequences and then the reduction

00:26:57,289 --> 00:27:03,140
operation gets applied in the way that

00:27:00,500 --> 00:27:04,730
we just I just showed you so all right

00:27:03,140 --> 00:27:07,370
I'm gonna get some examples now so

00:27:04,730 --> 00:27:09,830
suppose that we have some sequence X and

00:27:07,370 --> 00:27:11,330
we want to compute its vector norm so

00:27:09,830 --> 00:27:14,059
the vector norm is the square root of

00:27:11,330 --> 00:27:17,330
the sum of the square of each element so

00:27:14,059 --> 00:27:19,610
that's a little wordy but basically we

00:27:17,330 --> 00:27:21,140
take each element we square it we sum

00:27:19,610 --> 00:27:22,490
all those elements together and then we

00:27:21,140 --> 00:27:23,870
take the square root of that so you

00:27:22,490 --> 00:27:25,309
should be able to see sort of like how

00:27:23,870 --> 00:27:26,510
this is an inner product because there's

00:27:25,309 --> 00:27:28,610
there's - there's two different

00:27:26,510 --> 00:27:31,399
operations here that we're doing so this

00:27:28,610 --> 00:27:32,450
is we're gonna use an airy transform

00:27:31,399 --> 00:27:35,149
reduce here and the reason for that

00:27:32,450 --> 00:27:36,649
we've just got one input sequence X

00:27:35,149 --> 00:27:38,770
we're going to do some urban area

00:27:36,649 --> 00:27:42,559
transform on it and it's going to be

00:27:38,770 --> 00:27:44,600
this so just a square function so that's

00:27:42,559 --> 00:27:45,919
the middle of there right there sorry my

00:27:44,600 --> 00:27:48,919
laser pointer does not seem to be

00:27:45,919 --> 00:27:52,340
functioning all right so here's our

00:27:48,919 --> 00:27:56,779
array and then the reduction officer is

00:27:52,340 --> 00:27:58,549
going to be addition here so and so just

00:27:56,779 --> 00:28:00,950
the this is going to reduce the left

00:27:58,549 --> 00:28:02,120
value and the right value here and then

00:28:00,950 --> 00:28:03,169
the initial reduction value is just

00:28:02,120 --> 00:28:04,220
going to be zero so this is pretty

00:28:03,169 --> 00:28:05,539
straightforward and then we just take

00:28:04,220 --> 00:28:08,000
the square root of this whole thing so

00:28:05,539 --> 00:28:10,070
this is peril vector norm with the

00:28:08,000 --> 00:28:11,260
parallel algorithms library it's pretty

00:28:10,070 --> 00:28:13,990
easy to read it's pretty straightforward

00:28:11,260 --> 00:28:16,970
kind of like it all right so let's talk

00:28:13,990 --> 00:28:20,000
these signs out of order slightly out of

00:28:16,970 --> 00:28:23,090
order don't worry about that okay all

00:28:20,000 --> 00:28:26,299
right so dot product so this is the sort

00:28:23,090 --> 00:28:28,490
of canonical transform reduce example if

00:28:26,299 --> 00:28:29,600
you are in Hartman stock I haven't

00:28:28,490 --> 00:28:31,250
looked over Heartland slides but I

00:28:29,600 --> 00:28:33,020
suspect there was probably a dot product

00:28:31,250 --> 00:28:34,100
example in there I feel confident in

00:28:33,020 --> 00:28:36,470
saying that there was a dot product

00:28:34,100 --> 00:28:37,909
example in the last talk because that's

00:28:36,470 --> 00:28:40,039
just an example that you use for

00:28:37,909 --> 00:28:41,870
transform reduce so dot product is

00:28:40,039 --> 00:28:43,850
you've got two different vectors and you

00:28:41,870 --> 00:28:45,320
want to go and take for each consecutive

00:28:43,850 --> 00:28:46,640
pair of elements you want to multiply

00:28:45,320 --> 00:28:48,950
them together and then you want to take

00:28:46,640 --> 00:28:53,990
the sum of all of those products so like

00:28:48,950 --> 00:28:55,929
X 0 times y 0 plus X 1 times y 1 so

00:28:53,990 --> 00:28:56,990
here's where we would use the binary

00:28:55,929 --> 00:29:00,950
train

00:28:56,990 --> 00:29:02,390
form reduce so we've got two input

00:29:00,950 --> 00:29:04,790
sequences so we've got this left input

00:29:02,390 --> 00:29:07,340
sequence here the X's and this right

00:29:04,790 --> 00:29:08,840
input sequence here the Y's and then

00:29:07,340 --> 00:29:10,760
this is our transform op so it's going

00:29:08,840 --> 00:29:13,420
to multiply the X isn't the X and the y

00:29:10,760 --> 00:29:17,360
almonds together from the consecutive

00:29:13,420 --> 00:29:19,070
element pairs and then we've got just

00:29:17,360 --> 00:29:20,720
about zero for our initial value for the

00:29:19,070 --> 00:29:22,100
reduction and we have the reduction

00:29:20,720 --> 00:29:24,830
hockey up here which again is just

00:29:22,100 --> 00:29:26,240
addition note that you actually have to

00:29:24,830 --> 00:29:27,830
write the reduction off in the

00:29:26,240 --> 00:29:29,809
initialization here because they do not

00:29:27,830 --> 00:29:32,270
have a default value in the current spec

00:29:29,809 --> 00:29:35,410
I see some hands all right I'm going to

00:29:32,270 --> 00:29:35,410
go here than here

00:30:05,030 --> 00:30:10,020
so sister you're asking whether you can

00:30:07,470 --> 00:30:12,480
whether you can do a binary transform

00:30:10,020 --> 00:30:15,120
reduce on two input sequences of

00:30:12,480 --> 00:30:16,920
different types I believe the answer to

00:30:15,120 --> 00:30:18,660
that is no I would have to check the

00:30:16,920 --> 00:30:21,410
wording but I'm pretty sure that the way

00:30:18,660 --> 00:30:24,150
that reduction operators are normally

00:30:21,410 --> 00:30:25,500
sort of worded it's that they have to

00:30:24,150 --> 00:30:28,140
take they have to take arguments of the

00:30:25,500 --> 00:30:31,650
same type because otherwise you you

00:30:28,140 --> 00:30:33,120
could use it to reduce the elements but

00:30:31,650 --> 00:30:35,280
you couldn't use it to reduce the

00:30:33,120 --> 00:30:36,870
reductions themselves so it has to be

00:30:35,280 --> 00:30:38,990
the same type otherwise you would need a

00:30:36,870 --> 00:30:42,540
separate operation to be able to combine

00:30:38,990 --> 00:30:43,800
the reductions so sort of make that a

00:30:42,540 --> 00:30:46,500
little bit clearer let me go back a

00:30:43,800 --> 00:30:48,570
couple slides so like here like if this

00:30:46,500 --> 00:30:50,850
if pretend that this was some second

00:30:48,570 --> 00:30:52,410
sequence here and that you want it like

00:30:50,850 --> 00:30:54,320
this was complex this is the second

00:30:52,410 --> 00:30:56,610
sequence this was a Y and this was

00:30:54,320 --> 00:30:58,560
complex' and this was double then you

00:30:56,610 --> 00:31:00,390
might want your reduce op here to take a

00:30:58,560 --> 00:31:03,120
double on a complex but then this reduce

00:31:00,390 --> 00:31:05,960
up doesn't work because this one is

00:31:03,120 --> 00:31:08,190
expecting to the results of these two

00:31:05,960 --> 00:31:09,810
computations there so that's why we

00:31:08,190 --> 00:31:12,720
don't have that's why you have to have

00:31:09,810 --> 00:31:13,130
the same input type for the sequence all

00:31:12,720 --> 00:31:15,180
right

00:31:13,130 --> 00:31:37,110
okay so there's another question over

00:31:15,180 --> 00:31:40,230
here I feel I feel like there's probably

00:31:37,110 --> 00:31:42,660
a requires clause that says that the Y

00:31:40,230 --> 00:31:44,790
is to be larger than than the X and that

00:31:42,660 --> 00:31:47,820
it you just get you B if you break that

00:31:44,790 --> 00:31:49,020
requires Clause that that that would be

00:31:47,820 --> 00:31:53,010
my guess off the top of my head but I

00:31:49,020 --> 00:31:54,630
would have to check yeah I'm pretty sure

00:31:53,010 --> 00:31:56,130
that it's just that it's just one of the

00:31:54,630 --> 00:32:03,450
requirements that the one of the

00:31:56,130 --> 00:32:05,130
preconditions of the function yeah if

00:32:03,450 --> 00:32:08,730
it's greater than it will just only

00:32:05,130 --> 00:32:10,710
process up for the for the the range of

00:32:08,730 --> 00:32:13,490
the first yeah yeah

00:32:10,710 --> 00:32:18,799
and this is the same way that the the

00:32:13,490 --> 00:32:18,799
non parallel algorithms do things - yeah

00:32:26,600 --> 00:32:32,549
so the comment was that he leaves as a

00:32:29,490 --> 00:32:35,630
proposal to the committee in flight to

00:32:32,549 --> 00:32:38,880
deprecate versions of algorithms that

00:32:35,630 --> 00:32:41,490
specify some ranges some some sequences

00:32:38,880 --> 00:32:44,549
as to iterators and some is just one and

00:32:41,490 --> 00:32:47,700
make some assumptions yeah I think I've

00:32:44,549 --> 00:32:50,399
seen that that's a good idea it's not

00:32:47,700 --> 00:32:52,679
something that's in flight 417 since the

00:32:50,399 --> 00:32:54,149
the train is shipped for 17 but that

00:32:52,679 --> 00:32:56,940
would almost certainly be applied to

00:32:54,149 --> 00:32:58,260
these parallel rooms anyways another

00:32:56,940 --> 00:33:01,140
thing I should mention some of the

00:32:58,260 --> 00:33:03,390
orders of our parameters for transform

00:33:01,140 --> 00:33:05,100
reduce in particular doesn't really

00:33:03,390 --> 00:33:07,020
match what the order is for inner

00:33:05,100 --> 00:33:09,240
product so there's a chance that some of

00:33:07,020 --> 00:33:10,710
the orders of pram of art of parameters

00:33:09,240 --> 00:33:14,279
and the numbers might change in the

00:33:10,710 --> 00:33:16,140
future for reasons like that as well all

00:33:14,279 --> 00:33:20,640
right any other questions at this point

00:33:16,140 --> 00:33:23,549
in time okay all right so we went

00:33:20,640 --> 00:33:25,649
through this dot product ok so there's

00:33:23,549 --> 00:33:29,760
another way to write dot product which

00:33:25,649 --> 00:33:32,220
is to use this something like a boost

00:33:29,760 --> 00:33:34,140
County underwriter so a boost Kenton

00:33:32,220 --> 00:33:36,149
County innovators iterate over some

00:33:34,140 --> 00:33:39,240
sequence of numbers so saying like boost

00:33:36,149 --> 00:33:41,250
County generator 0 to X dot size says

00:33:39,240 --> 00:33:45,049
like I want to iterate over all of the

00:33:41,250 --> 00:33:47,309
indices in this range here and so the

00:33:45,049 --> 00:33:49,820
idea here is that we want to write

00:33:47,309 --> 00:33:52,230
something where instead of working with

00:33:49,820 --> 00:33:53,880
the elements themselves and our

00:33:52,230 --> 00:33:55,860
transform function we want to get the

00:33:53,880 --> 00:33:57,390
index there's a number of reasons that

00:33:55,860 --> 00:33:59,159
this might be useful it comes up a lot

00:33:57,390 --> 00:34:01,260
in like scientific codes or maybe you

00:33:59,159 --> 00:34:02,490
want to like apply a stencil and so this

00:34:01,260 --> 00:34:03,960
is how you can do it it's a pretty cool

00:34:02,490 --> 00:34:06,500
trick it comes up in a few places and

00:34:03,960 --> 00:34:10,679
this is kind of nifty it lets you write

00:34:06,500 --> 00:34:13,109
this dot product with the urinary

00:34:10,679 --> 00:34:16,560
transform reduce so this is actually

00:34:13,109 --> 00:34:17,760
also the more frequent example of or one

00:34:16,560 --> 00:34:19,139
of the more frequented ways that you'd

00:34:17,760 --> 00:34:20,730
see an example of a transformer is you

00:34:19,139 --> 00:34:23,099
also might see like a zip iterator for

00:34:20,730 --> 00:34:24,540
how you would use an urn Airy transform

00:34:23,099 --> 00:34:27,960
reduce

00:34:24,540 --> 00:34:29,790
with which to do dot product with an

00:34:27,960 --> 00:34:31,200
ordinary transform reduce but the proper

00:34:29,790 --> 00:34:33,540
way to do that is with the binary

00:34:31,200 --> 00:34:35,100
version which it's I'm gonna try very

00:34:33,540 --> 00:34:39,659
hard to make sure it gets into the 17

00:34:35,100 --> 00:34:42,000
standard all right okay so next we're

00:34:39,659 --> 00:34:44,040
gonna so I had sort of two lengthier

00:34:42,000 --> 00:34:45,360
examples here and so if you get lost at

00:34:44,040 --> 00:35:10,920
any point during the lengthy or examples

00:34:45,360 --> 00:35:13,050
just raise your hand and okay the

00:35:10,920 --> 00:35:15,120
question is are there requirements on

00:35:13,050 --> 00:35:16,680
the iterator types there are

00:35:15,120 --> 00:35:19,830
requirements in the iterator types there

00:35:16,680 --> 00:35:21,030
are also lots of requirements on any so

00:35:19,830 --> 00:35:22,320
there's these things called element

00:35:21,030 --> 00:35:24,870
access functions element access

00:35:22,320 --> 00:35:26,100
functions are any iterators basically

00:35:24,870 --> 00:35:27,840
any user code that might be used by an

00:35:26,100 --> 00:35:29,640
algorithm so any iterator operations

00:35:27,840 --> 00:35:32,700
that might be used by an algorithm any

00:35:29,640 --> 00:35:35,280
operations on the elements of the

00:35:32,700 --> 00:35:37,140
sequences that are that are required by

00:35:35,280 --> 00:35:39,090
the algorithm any of the user-defined

00:35:37,140 --> 00:35:40,980
functions so like your reduction on ops

00:35:39,090 --> 00:35:42,990
you transform ops your Optive to 4-h

00:35:40,980 --> 00:35:44,580
those are we call those Allman access

00:35:42,990 --> 00:35:48,570
functions and there are restrictions on

00:35:44,580 --> 00:35:51,030
them basically the restrictions are you

00:35:48,570 --> 00:35:59,820
you you can't do things that would cause

00:35:51,030 --> 00:36:00,240
data races I am I good now all right

00:35:59,820 --> 00:36:02,700
cool

00:36:00,240 --> 00:36:03,960
so basically it's it's you can't do

00:36:02,700 --> 00:36:06,330
things that cause data races I don't

00:36:03,960 --> 00:36:08,850
actually have a slide with the

00:36:06,330 --> 00:36:10,890
particular restrictions handy so I can't

00:36:08,850 --> 00:36:13,110
really tell you what the exact

00:36:10,890 --> 00:36:15,270
requirements are but you can't use

00:36:13,110 --> 00:36:17,550
something like in like an iterator from

00:36:15,270 --> 00:36:19,350
an i/o stream as an input to any of the

00:36:17,550 --> 00:36:21,120
parallel algorithms because that would

00:36:19,350 --> 00:36:22,650
break there's there would be leashed

00:36:21,120 --> 00:36:25,110
loop carry dependence ease between each

00:36:22,650 --> 00:36:27,510
different iteration but yes there are

00:36:25,110 --> 00:36:29,280
there are those restrictions there and

00:36:27,510 --> 00:36:33,000
it's certainly something to look up in

00:36:29,280 --> 00:36:36,030
in the documentation before using any of

00:36:33,000 --> 00:36:38,490
these algorithms any other questions

00:36:36,030 --> 00:36:39,839
before we move on to this this example

00:36:38,490 --> 00:36:42,750
okay so what we're gonna do is we're

00:36:39,839 --> 00:36:44,099
gonna write a parallel word count using

00:36:42,750 --> 00:36:46,020
of course transformer disk because

00:36:44,099 --> 00:36:48,599
that's the only the only thing that you

00:36:46,020 --> 00:36:50,910
would ever need so our goal here is to

00:36:48,599 --> 00:36:54,359
count the number of word beginnings in

00:36:50,910 --> 00:36:55,980
the input sequence alright so first we

00:36:54,359 --> 00:36:58,589
need some way of figuring out what a

00:36:55,980 --> 00:37:00,660
what a word beginning is so we're gonna

00:36:58,589 --> 00:37:02,960
use this function here so what this

00:37:00,660 --> 00:37:05,910
function does is it takes two

00:37:02,960 --> 00:37:08,070
consecutive elements of an some sequence

00:37:05,910 --> 00:37:10,560
and it returns true if the second

00:37:08,070 --> 00:37:12,660
element is the beginning of a word and

00:37:10,560 --> 00:37:14,550
so the test for that is if the left

00:37:12,660 --> 00:37:17,070
character here is a space and the right

00:37:14,550 --> 00:37:19,770
one is not then we've reached a new word

00:37:17,070 --> 00:37:21,119
here all right so we've got this

00:37:19,770 --> 00:37:22,950
function here we're gonna set it aside

00:37:21,119 --> 00:37:25,800
for a moment so we go back here alright

00:37:22,950 --> 00:37:27,869
so trivial case if the input string is

00:37:25,800 --> 00:37:32,400
empty we don't have any words so we just

00:37:27,869 --> 00:37:33,690
return zero and then because of the way

00:37:32,400 --> 00:37:35,220
we wrote this we said that it's going to

00:37:33,690 --> 00:37:37,140
detect the second element at the

00:37:35,220 --> 00:37:38,220
beginning of the word we we have a

00:37:37,140 --> 00:37:39,540
little problem if we're going to use

00:37:38,220 --> 00:37:42,420
this which is that if the first

00:37:39,540 --> 00:37:43,770
character and in the sequence is not a

00:37:42,420 --> 00:37:45,450
space and it's the beginning of a word

00:37:43,770 --> 00:37:47,339
and we're not going to pick up on it

00:37:45,450 --> 00:37:48,990
because our function only tests whether

00:37:47,339 --> 00:37:52,320
the second element the second of two

00:37:48,990 --> 00:37:54,750
consecutive elements is a beginning of a

00:37:52,320 --> 00:37:56,670
word and there's no element that's to

00:37:54,750 --> 00:37:58,670
the left of the first element so we need

00:37:56,670 --> 00:38:01,230
to count the Friedan to check the first

00:37:58,670 --> 00:38:03,599
character separately and so we just see

00:38:01,230 --> 00:38:07,589
is the first character of space if it if

00:38:03,599 --> 00:38:09,660
it is if it's not a space then it's the

00:38:07,589 --> 00:38:11,670
beginning of a word and so we count it

00:38:09,660 --> 00:38:14,250
and if it is a space then we don't count

00:38:11,670 --> 00:38:15,839
it all right so then as I said we're

00:38:14,250 --> 00:38:17,400
going to use transform reduce here we're

00:38:15,839 --> 00:38:20,580
going to use the binary transform reduce

00:38:17,400 --> 00:38:21,330
because we've got this binary function

00:38:20,580 --> 00:38:24,270
that we're going to apply the

00:38:21,330 --> 00:38:26,460
transformation but we've only got one

00:38:24,270 --> 00:38:28,109
input sequence so what we're going to do

00:38:26,460 --> 00:38:32,190
is we're going to construct these two

00:38:28,109 --> 00:38:36,210
sub sequences from the input here so the

00:38:32,190 --> 00:38:39,570
left one is the element all of the

00:38:36,210 --> 00:38:43,230
elements in s except for the last

00:38:39,570 --> 00:38:44,849
element the right sequence is all of the

00:38:43,230 --> 00:38:47,400
elements in askes except for the first

00:38:44,849 --> 00:38:50,940
element and what this is going to give

00:38:47,400 --> 00:38:52,170
us is what we wanted which is keys

00:38:50,940 --> 00:38:54,780
element pairs of caen

00:38:52,170 --> 00:38:57,119
native elements so in particular we're

00:38:54,780 --> 00:38:59,849
gonna get like you can see it here s

00:38:57,119 --> 00:39:01,710
we're gonna get s 0 and s 1 as the first

00:38:59,849 --> 00:39:03,990
element pair and then we're going to get

00:39:01,710 --> 00:39:06,450
s 1 and s 2 is the second element pair

00:39:03,990 --> 00:39:07,410
now this this might look a lot like what

00:39:06,450 --> 00:39:08,609
a reduction looks like because

00:39:07,410 --> 00:39:10,260
reductions are also applied to

00:39:08,609 --> 00:39:12,059
consecutive elements the difference here

00:39:10,260 --> 00:39:13,410
is that there's overlap so this

00:39:12,059 --> 00:39:15,599
operation that we're doing here

00:39:13,410 --> 00:39:18,960
like our reduction would be like s 0 and

00:39:15,599 --> 00:39:20,609
s 1 then s 2 and s 3 whereas this here

00:39:18,960 --> 00:39:23,869
we have the overlap so like we're

00:39:20,609 --> 00:39:27,420
applying a paste a stencil almost here

00:39:23,869 --> 00:39:28,650
alright so we've got this and then is

00:39:27,420 --> 00:39:31,619
word beginning is what we're going to

00:39:28,650 --> 00:39:33,180
use and and so it returns 1 whenever we

00:39:31,619 --> 00:39:33,690
hit a new word and it returns 0

00:39:33,180 --> 00:39:35,910
otherwise

00:39:33,690 --> 00:39:38,040
and then our reduction operator is again

00:39:35,910 --> 00:39:39,809
just going to be addition and the

00:39:38,040 --> 00:39:42,720
initial value is going to be 0 ok so

00:39:39,809 --> 00:39:45,510
what does this actually sort of look

00:39:42,720 --> 00:39:47,309
like in process so we've got some input

00:39:45,510 --> 00:39:48,960
sequence here and then we've got this

00:39:47,309 --> 00:39:50,460
I'm going to call it a pseudo sequence

00:39:48,960 --> 00:39:51,569
because it's not something that's real

00:39:50,460 --> 00:39:53,490
it doesn't actually have storage

00:39:51,569 --> 00:39:55,589
anywhere it's built on the fly but we've

00:39:53,490 --> 00:39:57,510
got this post transform pseudo sequence

00:39:55,589 --> 00:39:59,609
that gets created by applying the

00:39:57,510 --> 00:40:01,589
transformed function to these two sub

00:39:59,609 --> 00:40:03,750
sequences that we've created note that

00:40:01,589 --> 00:40:06,329
the first that this is one shorter than

00:40:03,750 --> 00:40:08,579
the input here the first element we've

00:40:06,329 --> 00:40:10,049
skipped over here ok so what do we have

00:40:08,579 --> 00:40:12,119
in this post transform sequence well we

00:40:10,049 --> 00:40:13,530
have zeros for all the things that are

00:40:12,119 --> 00:40:14,940
not the beginning of words and we have

00:40:13,530 --> 00:40:18,000
ones for all the things that are the

00:40:14,940 --> 00:40:19,950
beginning of words and so then the

00:40:18,000 --> 00:40:22,170
reduction goes and adds up all of these

00:40:19,950 --> 00:40:24,839
ones here and hey we have one of these

00:40:22,170 --> 00:40:26,790
for every word so now we've counted the

00:40:24,839 --> 00:40:28,440
number of words that we have so this is

00:40:26,790 --> 00:40:31,770
what it looks like and also one thing we

00:40:28,440 --> 00:40:34,380
can do we can actually take this right

00:40:31,770 --> 00:40:35,520
here and we can stick it down in the

00:40:34,380 --> 00:40:36,510
initial value there because that's

00:40:35,520 --> 00:40:39,359
really where it belongs

00:40:36,510 --> 00:40:40,890
because it's that's the initial value

00:40:39,359 --> 00:40:42,869
that gets added up to the sum here so

00:40:40,890 --> 00:40:45,390
this is our parallel word count using

00:40:42,869 --> 00:40:52,829
the C++ 17 parallel algorithms library

00:40:45,390 --> 00:40:56,010
any questions on this okay all right how

00:40:52,829 --> 00:40:59,099
are we doing on time I'm having trouble

00:40:56,010 --> 00:41:00,780
reading that 15 minutes all right that's

00:40:59,099 --> 00:41:02,430
good that's just about as much content

00:41:00,780 --> 00:41:05,420
as we have left all right so our next

00:41:02,430 --> 00:41:07,640
example is very similar we're gonna

00:41:05,420 --> 00:41:09,859
create a sparse histogram so a sports

00:41:07,640 --> 00:41:12,799
histogram is a mapping of all of the

00:41:09,859 --> 00:41:15,530
unique elements in a sequence to the

00:41:12,799 --> 00:41:18,049
number of times that the element appears

00:41:15,530 --> 00:41:19,220
in the sequence so this is something

00:41:18,049 --> 00:41:20,390
that's best understood through an

00:41:19,220 --> 00:41:25,069
example so like I've got this input

00:41:20,390 --> 00:41:27,680
sequence here a b c c a a b b b b e so

00:41:25,069 --> 00:41:28,730
how many unique keys do we have our

00:41:27,680 --> 00:41:31,250
unique element so we have well we have

00:41:28,730 --> 00:41:33,260
four and so then what we want is an

00:41:31,250 --> 00:41:35,630
output is we want that the list of

00:41:33,260 --> 00:41:38,299
unique elements and then we want another

00:41:35,630 --> 00:41:40,880
list of what how many times those unique

00:41:38,299 --> 00:41:42,859
elements show up so it's it's called

00:41:40,880 --> 00:41:46,339
sparse here as opposed to against a

00:41:42,859 --> 00:41:48,950
dense histogram would have a D in this

00:41:46,339 --> 00:41:50,569
list here because it's it's day and then

00:41:48,950 --> 00:41:53,720
the count for D would be zero it is

00:41:50,569 --> 00:41:57,049
dense through the entire min max range

00:41:53,720 --> 00:42:00,440
of the keys and the input sequence all

00:41:57,049 --> 00:42:02,329
right so this is one as far as histogram

00:42:00,440 --> 00:42:04,640
function is going to look like it's

00:42:02,329 --> 00:42:06,589
going to return a tuple of two vectors I

00:42:04,640 --> 00:42:09,500
guess it could return a map but I really

00:42:06,589 --> 00:42:12,680
like vectors because I program on

00:42:09,500 --> 00:42:14,990
hardware that really likes struct of

00:42:12,680 --> 00:42:16,430
array layouts as opposed to array of

00:42:14,990 --> 00:42:17,750
structs so I don't and I don't want to

00:42:16,430 --> 00:42:20,690
use a map here so we're going to return

00:42:17,750 --> 00:42:21,650
a tuple of two vectors and those vectors

00:42:20,690 --> 00:42:24,170
are going to be the first one is going

00:42:21,650 --> 00:42:26,510
to be the the keys and the second one's

00:42:24,170 --> 00:42:28,280
going to be the count here all right so

00:42:26,510 --> 00:42:29,720
again first thing is just you know if

00:42:28,280 --> 00:42:31,700
we're empty we're done we'll just return

00:42:29,720 --> 00:42:33,859
these two things here and they will be

00:42:31,700 --> 00:42:36,410
empty they will have nothing in them all

00:42:33,859 --> 00:42:39,410
right so then what we need to do first

00:42:36,410 --> 00:42:40,730
is we need to sort the input sequence so

00:42:39,410 --> 00:42:43,250
that all the equal elements are together

00:42:40,730 --> 00:42:46,040
we'll use the parallel algorithm library

00:42:43,250 --> 00:42:48,380
again for this so just sort power on

00:42:46,040 --> 00:42:49,940
seek pretty straightforward all right

00:42:48,380 --> 00:42:51,770
then the next thing we need to do is

00:42:49,940 --> 00:42:53,869
count the number of unique elements so

00:42:51,770 --> 00:42:56,450
this is basically the same as counting

00:42:53,869 --> 00:42:59,240
the number of words so we're going to

00:42:56,450 --> 00:43:01,780
use transform reduce so this is what

00:42:59,240 --> 00:43:04,280
we've got so again we're using the

00:43:01,780 --> 00:43:05,390
binary version of transformer to use for

00:43:04,280 --> 00:43:07,130
doing the same trick that we did before

00:43:05,390 --> 00:43:08,930
where we're creating these two sub

00:43:07,130 --> 00:43:11,000
sequences from this initial input

00:43:08,930 --> 00:43:13,040
sequence here where one of them's got

00:43:11,000 --> 00:43:14,089
everything but the last one of element

00:43:13,040 --> 00:43:16,250
every one of them's got everything but

00:43:14,089 --> 00:43:18,700
the first element and then we're going

00:43:16,250 --> 00:43:18,700
to apply

00:43:19,519 --> 00:43:24,410
transform up here which is very similar

00:43:21,769 --> 00:43:27,200
to our is word beginning operator where

00:43:24,410 --> 00:43:29,269
it's going to return 1 if the second

00:43:27,200 --> 00:43:30,979
consecutive element is a new unique

00:43:29,269 --> 00:43:33,200
element and because we've sorted it we

00:43:30,979 --> 00:43:34,999
know that if the left is not equal to

00:43:33,200 --> 00:43:38,329
the right and we found the next one

00:43:34,999 --> 00:43:41,359
that's not it's not unique that is

00:43:38,329 --> 00:43:42,849
unique rather sorry and so the reduction

00:43:41,359 --> 00:43:45,349
is a little bit different here because

00:43:42,849 --> 00:43:47,809
we know that we have at least one unique

00:43:45,349 --> 00:43:49,519
key minimum and again just as with with

00:43:47,809 --> 00:43:53,059
the word problem we would have not

00:43:49,519 --> 00:43:55,099
counted that key because this transform

00:43:53,059 --> 00:43:56,690
up here it's going to tell us whether

00:43:55,099 --> 00:43:58,519
the right element is a new unique

00:43:56,690 --> 00:44:00,079
element so it would miss the first one

00:43:58,519 --> 00:44:01,640
because there's nothing to the left of

00:44:00,079 --> 00:44:03,710
the first element so we need to count

00:44:01,640 --> 00:44:05,630
that first one and since we know X isn't

00:44:03,710 --> 00:44:08,269
empty we just assume that it's that it's

00:44:05,630 --> 00:44:11,839
that okay and so then we're gonna

00:44:08,269 --> 00:44:13,430
allocate our storage in our keys and

00:44:11,839 --> 00:44:16,119
counts based on that number of unique

00:44:13,430 --> 00:44:18,559
elements and then now we're now we're

00:44:16,119 --> 00:44:19,729
driving off into the land of things that

00:44:18,559 --> 00:44:21,170
are not in the standard yet but

00:44:19,729 --> 00:44:23,960
hopefully we'll be which is we're gonna

00:44:21,170 --> 00:44:25,309
use this thing called reduce by key now

00:44:23,960 --> 00:44:27,109
I could write this without reduced by

00:44:25,309 --> 00:44:29,779
key but I can't fit it on the slide

00:44:27,109 --> 00:44:36,319
without reduced by key so what reduced

00:44:29,779 --> 00:44:40,849
by key does is it's going to for every

00:44:36,319 --> 00:44:44,779
range of consecutive values that share

00:44:40,849 --> 00:44:47,239
the same key in some two set of key

00:44:44,779 --> 00:44:50,930
value sequences it will do a reduction

00:44:47,239 --> 00:44:52,369
on on that consecutive range so you've

00:44:50,930 --> 00:44:54,079
got is two input sequences a key

00:44:52,369 --> 00:44:55,849
sequence and a value sequence so it'll

00:44:54,079 --> 00:44:58,670
go through and it'll find so all these

00:44:55,849 --> 00:45:00,200
keys here are equal so then for the

00:44:58,670 --> 00:45:01,789
corresponding value elements I'm going

00:45:00,200 --> 00:45:03,619
to go and do the reduction on that and

00:45:01,789 --> 00:45:05,479
then go find for the next keys how many

00:45:03,619 --> 00:45:07,369
of these keys are equal and do the

00:45:05,479 --> 00:45:09,079
reduction on that and so unlike a

00:45:07,369 --> 00:45:11,269
regular reduce which just gives you back

00:45:09,079 --> 00:45:13,400
one value this is going to potentially

00:45:11,269 --> 00:45:15,859
reduce to multiple values because it's

00:45:13,400 --> 00:45:17,690
just reducing on subsequences and so

00:45:15,859 --> 00:45:19,369
instead of having just a return value it

00:45:17,690 --> 00:45:21,650
needs to have an output sequence here

00:45:19,369 --> 00:45:23,749
and the output sequence the output key

00:45:21,650 --> 00:45:26,329
sequence is going to be this histogram

00:45:23,749 --> 00:45:29,299
keys and the output count will be the

00:45:26,329 --> 00:45:32,420
counts and again just lies with the word

00:45:29,299 --> 00:45:35,420
count here we'll we're just

00:45:32,420 --> 00:45:38,210
we're using this constant iterator thing

00:45:35,420 --> 00:45:40,579
here for the input value and that's just

00:45:38,210 --> 00:45:42,430
an iterator that always returns one so

00:45:40,579 --> 00:45:48,410
because we want to count each one of the

00:45:42,430 --> 00:45:49,970
input elements once so then what this

00:45:48,410 --> 00:45:50,809
will give us as the output is exactly

00:45:49,970 --> 00:45:53,089
what we need

00:45:50,809 --> 00:45:54,799
alright any questions on this and this

00:45:53,089 --> 00:45:56,599
is this is something that's in HP x and

00:45:54,799 --> 00:45:57,499
thrust and boost compute if you want to

00:45:56,599 --> 00:46:00,410
play around with this and there's a

00:45:57,499 --> 00:46:03,920
whole bunch of other useful buy key

00:46:00,410 --> 00:46:06,049
algorithms I think these are are some of

00:46:03,920 --> 00:46:08,200
the most likely things to go into like

00:46:06,049 --> 00:46:10,549
the next version of a parallelism TS

00:46:08,200 --> 00:46:12,529
they're particularly useful if you're

00:46:10,549 --> 00:46:16,099
dealing with if you want to if you want

00:46:12,529 --> 00:46:18,079
to work with structs of array or a

00:46:16,099 --> 00:46:19,249
struct of array or so instead of working

00:46:18,079 --> 00:46:27,349
with array of struct was there a

00:46:19,249 --> 00:46:28,789
question back there yeah that's so the

00:46:27,349 --> 00:46:30,200
question was a driver version this

00:46:28,789 --> 00:46:33,680
doesn't have so much false sharing

00:46:30,200 --> 00:46:35,420
problems me talking about false sharing

00:46:33,680 --> 00:46:37,849
would be a whole different talk so we

00:46:35,420 --> 00:46:40,160
should probably take that offline but

00:46:37,849 --> 00:46:41,259
yeah the answer is yes but we should we

00:46:40,160 --> 00:46:47,359
should talk about that later

00:46:41,259 --> 00:46:49,930
all right okay all right so now I get to

00:46:47,359 --> 00:46:52,460
talk about the the part of the current

00:46:49,930 --> 00:46:54,559
parity and stuff that I'm very directly

00:46:52,460 --> 00:46:57,470
responsible for and I don't say that

00:46:54,559 --> 00:46:59,029
necessarily in a good way which is the

00:46:57,470 --> 00:47:02,630
parallel algorithm exception handling

00:46:59,029 --> 00:47:04,220
so me and Jeff Bastion wrote a paper for

00:47:02,630 --> 00:47:07,190
the last committee meeting called hotel

00:47:04,220 --> 00:47:08,720
peril for Nia the the punchline is you

00:47:07,190 --> 00:47:11,359
can throw any time you like but the

00:47:08,720 --> 00:47:14,450
exceptions can never leave the reason

00:47:11,359 --> 00:47:16,460
for this is that if we have exceptions

00:47:14,450 --> 00:47:19,549
boiling out of our element access

00:47:16,460 --> 00:47:22,160
functions it makes it very very very

00:47:19,549 --> 00:47:24,349
difficult to vectorize them efficiently

00:47:22,160 --> 00:47:27,999
because then we have to damask because

00:47:24,349 --> 00:47:33,349
of the possibility of control flow so

00:47:27,999 --> 00:47:35,450
this is very problematic one like on a

00:47:33,349 --> 00:47:36,950
GPU basically the approach would have

00:47:35,450 --> 00:47:38,989
been like you know like check the a

00:47:36,950 --> 00:47:40,730
analyze the element access functions if

00:47:38,989 --> 00:47:42,109
any of them could throw exceptions run

00:47:40,730 --> 00:47:44,509
it on serial would have been the

00:47:42,109 --> 00:47:45,600
implementation if we had gone with any

00:47:44,509 --> 00:47:48,930
error reporting

00:47:45,600 --> 00:47:50,940
that doesn't call terminate here so this

00:47:48,930 --> 00:47:52,500
is I think a good solution for now which

00:47:50,940 --> 00:47:54,530
is that if an if an element access

00:47:52,500 --> 00:47:56,700
function throws an uncaught exception

00:47:54,530 --> 00:48:01,580
terminate gets called you're just done

00:47:56,700 --> 00:48:05,040
now it also could throw bad alec if

00:48:01,580 --> 00:48:08,790
memory is needed for you know like a

00:48:05,040 --> 00:48:11,040
thread pool or if it's temporary memory

00:48:08,790 --> 00:48:13,620
resource I'm unit for the algorithm but

00:48:11,040 --> 00:48:16,170
that's a much less common case all right

00:48:13,620 --> 00:48:18,750
so there's that sorry or thanks

00:48:16,170 --> 00:48:20,160
depending on your viewpoint or you're

00:48:18,750 --> 00:48:22,490
welcome rather all right

00:48:20,160 --> 00:48:24,630
okay so so the stuff in this slides

00:48:22,490 --> 00:48:26,310
almost none of this was code that I

00:48:24,630 --> 00:48:27,660
wrote it was almost all code that I

00:48:26,310 --> 00:48:29,040
stole from other people and these are

00:48:27,660 --> 00:48:32,010
the people and things that I stole it

00:48:29,040 --> 00:48:34,200
from so they should get the credit for

00:48:32,010 --> 00:48:37,470
that so there's a couple things I didn't

00:48:34,200 --> 00:48:40,200
talk about which is future directions so

00:48:37,470 --> 00:48:41,580
there's three big ones I sort of want to

00:48:40,200 --> 00:48:44,700
briefly mention the first is

00:48:41,580 --> 00:48:47,640
asynchronous versions of the parallel

00:48:44,700 --> 00:48:49,380
algorithms so like right now one of the

00:48:47,640 --> 00:48:52,380
issues is that if you're using multiple

00:48:49,380 --> 00:48:56,600
parallel algorithms like I'm doing I'm

00:48:52,380 --> 00:49:00,360
doing sort here I've got a transform

00:48:56,600 --> 00:49:02,130
videos here I've got a reduced by key

00:49:00,360 --> 00:49:04,170
here this is all fork joined parallelism

00:49:02,130 --> 00:49:06,120
going hey you go split all these tasks

00:49:04,170 --> 00:49:07,920
go do stuff then get then communicate

00:49:06,120 --> 00:49:09,840
back together there's no way for us to

00:49:07,920 --> 00:49:11,970
overlap computation with the current

00:49:09,840 --> 00:49:13,410
parallel parallel algorithms it would be

00:49:11,970 --> 00:49:15,570
very nice if we had versions which

00:49:13,410 --> 00:49:16,950
returned which were asynchronous and it

00:49:15,570 --> 00:49:19,020
would return a future that would be

00:49:16,950 --> 00:49:24,570
ready when the algorithm had finished

00:49:19,020 --> 00:49:27,510
executing yes question there you could I

00:49:24,570 --> 00:49:29,960
just think you could but I think

00:49:27,510 --> 00:49:31,770
realistically there's going to be

00:49:29,960 --> 00:49:34,970
performance opportunities that will be

00:49:31,770 --> 00:49:37,770
lost if we don't have the library

00:49:34,970 --> 00:49:39,570
interfaces for this I'd have to talk

00:49:37,770 --> 00:49:40,890
with Hartmut to determine whether or not

00:49:39,570 --> 00:49:43,740
that's correct but I'm pretty sure that

00:49:40,890 --> 00:49:44,750
you actually want the library to provide

00:49:43,740 --> 00:49:48,810
you with the asynchronous version

00:49:44,750 --> 00:49:50,940
instead of you just wrapping it in some

00:49:48,810 --> 00:49:52,260
asynchrony prim primitive it's just like

00:49:50,940 --> 00:49:53,090
with the fused algorithms I think I

00:49:52,260 --> 00:49:58,020
believe there's going to be

00:49:53,090 --> 00:49:59,400
opportunities there to optimize by

00:49:58,020 --> 00:50:00,779
having by knowing that you do

00:49:59,400 --> 00:50:05,869
that you you're joining this

00:50:00,779 --> 00:50:05,869
asynchronously okay question over there

00:50:20,180 --> 00:50:25,380
okay so the question was how does this

00:50:22,079 --> 00:50:26,819
compare to Microsoft's parallel STL so I

00:50:25,380 --> 00:50:28,799
should give the brief history of

00:50:26,819 --> 00:50:31,410
parallel STL's which is that there's

00:50:28,799 --> 00:50:33,630
been about a million of them they've all

00:50:31,410 --> 00:50:35,520
kind of done similar things I haven't

00:50:33,630 --> 00:50:38,910
looked at Microsoft's parallel STL in

00:50:35,520 --> 00:50:41,849
particular but usually they've done very

00:50:38,910 --> 00:50:44,130
similar sorts of things in that they

00:50:41,849 --> 00:50:45,839
tried to paralyze sequence algorithms so

00:50:44,130 --> 00:50:46,799
I I'm not I can't really answer your

00:50:45,839 --> 00:50:47,970
question properly because I haven't

00:50:46,799 --> 00:50:51,529
looked at it but I would guess it's

00:50:47,970 --> 00:50:54,119
pretty close alright so the the other

00:50:51,529 --> 00:50:55,020
two thing I wanted to briefly mention so

00:50:54,119 --> 00:50:56,309
one of the thing that you may have

00:50:55,020 --> 00:50:58,829
noticed is missing is that there's no

00:50:56,309 --> 00:51:01,049
way to ask for vectorization without

00:50:58,829 --> 00:51:02,760
paralyzation uh moms don't worry we have

00:51:01,049 --> 00:51:04,559
top men working on that so there's a

00:51:02,760 --> 00:51:09,630
proposal for this thing called for loop

00:51:04,559 --> 00:51:13,160
and for this whole framework theoretical

00:51:09,630 --> 00:51:15,359
framework for reasoning for in wording

00:51:13,160 --> 00:51:17,010
just factorization for this for loop

00:51:15,359 --> 00:51:20,789
construct it's very powerful it's a

00:51:17,010 --> 00:51:22,109
wavefront model and Pablo is going to be

00:51:20,789 --> 00:51:23,369
giving a talk about this later in the

00:51:22,109 --> 00:51:25,920
week it's I can't remember the name but

00:51:23,369 --> 00:51:28,069
it's something vectorization in C++ you

00:51:25,920 --> 00:51:32,609
guys should go there it's really great

00:51:28,069 --> 00:51:33,839
there's also some it's um so so there's

00:51:32,609 --> 00:51:36,690
some algorithms that are like missing

00:51:33,839 --> 00:51:38,220
like the bikey stuff there's a couple

00:51:36,690 --> 00:51:41,190
others that I think we could really

00:51:38,220 --> 00:51:42,329
benefit from having in the spec here so

00:51:41,190 --> 00:51:44,130
that's sort of the future direction oh

00:51:42,329 --> 00:51:45,480
and I forgot of course there's executor

00:51:44,130 --> 00:51:49,230
z-- which are a whole talk in and of

00:51:45,480 --> 00:51:51,839
themselves basically what I've shown you

00:51:49,230 --> 00:51:53,010
here is a way to request parallelism but

00:51:51,839 --> 00:51:55,319
I haven't shown you any way to sort of

00:51:53,010 --> 00:51:57,750
like control how that parallelism may be

00:51:55,319 --> 00:51:59,789
applied executor z-- will give you that

00:51:57,750 --> 00:52:02,490
so executor z-- as a way of abstracting

00:51:59,789 --> 00:52:07,200
execution resources like thread pools

00:52:02,490 --> 00:52:09,980
for example and orb like a accelerator

00:52:07,200 --> 00:52:12,280
that is attached to your device might be

00:52:09,980 --> 00:52:14,700
abstracted as a

00:52:12,280 --> 00:52:17,200
executor so right now the parallel

00:52:14,700 --> 00:52:20,380
algorithms library basically has sort of

00:52:17,200 --> 00:52:22,510
a default implied executor which is sort

00:52:20,380 --> 00:52:24,430
of this unspecified thing that whatever

00:52:22,510 --> 00:52:27,340
your vendor gives you is going to be so

00:52:24,430 --> 00:52:29,830
like nvidia cuda compiler the default

00:52:27,340 --> 00:52:32,290
executor is going to probably be you

00:52:29,830 --> 00:52:33,670
know whatever GPUs on your system but

00:52:32,290 --> 00:52:35,620
like what if you have two GPUs and you

00:52:33,670 --> 00:52:39,130
want to say run on this GPU or that GPU

00:52:35,620 --> 00:52:40,480
we're like with lib C++ the execution

00:52:39,130 --> 00:52:43,480
the executor is gonna probably be

00:52:40,480 --> 00:52:46,870
something that goes to live the Grand

00:52:43,480 --> 00:52:48,550
Central Dispatch on Linux with Lipstadt

00:52:46,870 --> 00:52:50,590
C++ so it'll probably be some thread

00:52:48,550 --> 00:52:52,300
pool built on top of P threads with

00:52:50,590 --> 00:52:55,270
something like HP X it's it's very

00:52:52,300 --> 00:52:56,710
lightweight tasking and so executor czar

00:52:55,270 --> 00:52:58,180
going to give us a way to add a lot of

00:52:56,710 --> 00:53:01,360
the controls that you might want to

00:52:58,180 --> 00:53:02,770
other parallel algorithms all right so I

00:53:01,360 --> 00:53:06,040
think about a little bit of time for

00:53:02,770 --> 00:53:08,200
questions so I think it would be easiest

00:53:06,040 --> 00:53:09,310
if we maybe do a line on one of these

00:53:08,200 --> 00:53:11,050
microphones here because it's very

00:53:09,310 --> 00:53:31,870
difficult for me to see you as hands up

00:53:11,050 --> 00:53:34,230
with the lights here okay all right deck

00:53:31,870 --> 00:53:37,720
you door default policy can you actually

00:53:34,230 --> 00:53:42,040
suggest that you want to use all all

00:53:37,720 --> 00:53:45,510
sites of Hardware threads or Hardware

00:53:42,040 --> 00:53:47,910
pools such as GPU CPUs FPGAs

00:53:45,510 --> 00:53:50,560
simultaneously to perform on your

00:53:47,910 --> 00:53:52,000
algorithm um so you're the right now

00:53:50,560 --> 00:53:54,040
that the question was whether whether

00:53:52,000 --> 00:53:56,650
you can request to use all hard all a

00:53:54,040 --> 00:53:58,270
possible hardware available with the

00:53:56,650 --> 00:54:02,530
default executor right now you can't

00:53:58,270 --> 00:54:05,860
right now the executor is something that

00:54:02,530 --> 00:54:07,480
the implement is not in the language of

00:54:05,860 --> 00:54:10,990
the spec anywhere and it's just an

00:54:07,480 --> 00:54:13,180
implied concept that it's completely up

00:54:10,990 --> 00:54:15,400
to your implementation how how the

00:54:13,180 --> 00:54:17,470
parallelism is provided so right now no

00:54:15,400 --> 00:54:19,690
there's not a way to add that but we

00:54:17,470 --> 00:54:23,410
have top guys on it and that's coming in

00:54:19,690 --> 00:54:25,509
the future all right so did par unsick

00:54:23,410 --> 00:54:28,689
used to be called par vac you

00:54:25,509 --> 00:54:30,339
yes it did this is like if Const expert

00:54:28,689 --> 00:54:31,989
so you've probably have heard about a

00:54:30,339 --> 00:54:33,399
thing called concepts for if because

00:54:31,989 --> 00:54:36,249
everybody in the committee has gotten

00:54:33,399 --> 00:54:38,169
used to calling it concepts forever yeah

00:54:36,249 --> 00:54:39,939
or static if but concepts brief is a

00:54:38,169 --> 00:54:43,509
particularly bad one because the actual

00:54:39,939 --> 00:54:45,399
thing is spelled in code if Const expert

00:54:43,509 --> 00:54:47,919
and everybody calls it concepts for if

00:54:45,399 --> 00:54:50,679
Yap are back it used to be a rapport and

00:54:47,919 --> 00:54:54,819
CPUC and myself currency used to be

00:54:50,679 --> 00:54:56,859
called par vaq it got renamed to be par

00:54:54,819 --> 00:54:58,929
and seek because those the execution

00:54:56,859 --> 00:55:00,939
policy identifiers are very short they

00:54:58,929 --> 00:55:02,799
got like shedded many many many times

00:55:00,939 --> 00:55:04,749
they were gonna live in a separate

00:55:02,799 --> 00:55:07,119
namespace at one point seek was going to

00:55:04,749 --> 00:55:08,199
be sequence at one point on they were

00:55:07,119 --> 00:55:10,839
going to be longer they were going to be

00:55:08,199 --> 00:55:12,579
shorter this is this is what we ended up

00:55:10,839 --> 00:55:17,489
with but yes that that is how they they

00:55:12,579 --> 00:55:20,079
mapped yeah last question about using

00:55:17,489 --> 00:55:23,859
the beginning end of the destination

00:55:20,079 --> 00:55:28,509
yeah and there's a paper on that but

00:55:23,859 --> 00:55:30,369
since we're adding a transform reduce so

00:55:28,509 --> 00:55:32,709
we have control over that now so why not

00:55:30,369 --> 00:55:34,239
add that safety feature now because we

00:55:32,709 --> 00:55:36,069
don't really have control over it

00:55:34,239 --> 00:55:38,259
because the committee draft is has fixed

00:55:36,069 --> 00:55:41,499
the only possible changes that could be

00:55:38,259 --> 00:55:44,859
made to transform reduce is if their

00:55:41,499 --> 00:55:48,699
committee decides that the current we

00:55:44,859 --> 00:55:51,399
are the current missing transform reduce

00:55:48,699 --> 00:55:53,289
overload should be there and that the

00:55:51,399 --> 00:55:54,729
inner product overload for tradition

00:55:53,289 --> 00:55:56,259
policies that is there shouldn't be

00:55:54,729 --> 00:55:57,519
there then we might have some freedom

00:55:56,259 --> 00:55:58,899
there but it's not something that we

00:55:57,519 --> 00:56:01,239
could really fix in teleconference I'm

00:55:58,899 --> 00:56:03,009
hoping to at least fix the order of

00:56:01,239 --> 00:56:07,749
parameters and transform reduce but

00:56:03,009 --> 00:56:11,049
maybe a little out there if you set up a

00:56:07,749 --> 00:56:13,509
vectorized of execution policy but then

00:56:11,049 --> 00:56:15,759
the operations that you sent to it are

00:56:13,509 --> 00:56:18,759
not capable of being vectorized bad

00:56:15,759 --> 00:56:20,619
stuff so does it cause a compiler error

00:56:18,759 --> 00:56:22,689
or does it cause of runtime it does not

00:56:20,619 --> 00:56:24,369
cause a compiler error okay causes it

00:56:22,689 --> 00:56:28,059
does not cause a runtime error it causes

00:56:24,369 --> 00:56:31,869
undefined babe yes all right any other

00:56:28,059 --> 00:56:33,489
questions all right well I hope you guys

00:56:31,869 --> 00:56:36,189
have a great conference we're really

00:56:33,489 --> 00:56:38,819
glad to have you here and I'll see you

00:56:36,189 --> 00:56:38,819

YouTube URL: https://www.youtube.com/watch?v=Vck6kzWjY88


