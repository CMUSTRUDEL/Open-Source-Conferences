Title: CppCon 2016: Alfred Bratterud “#include ＜os＞: from bootloader to REST API with the new C++"
Publication date: 2016-09-30
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
IncludeOS is a brand new open source library operating system that turns your modern C++ source code into a minimal, self contained virtual machine. No Linux inside, just your service and whatever your service needs from the operating system library. Creating the virtual machine is just as fast as compiling a binary and the resulting virtual machine image can run unchanged on Linux, Windows or Mac. 

Early in the design process we made a hard choice; no C interfaces and no blocking POSIX calls. We’ve done everything from scratch with modern C++ 11/14 - Including device drivers and the complete network stack all the way through ethernet, IP and ARP, up to and including UDP, TCP and recently also an http / REST API framework. To achieve maximum efficiency we decided to do everything event based and async, so there's plenty of opportunities to use lambdas and delegates. 

In this talk you’ll get the first overview of our first feature-complete release and the first application built with IncludeOS. We’ll show you what we’re proud of and what we’d like your help to improve. And of course, we’ll show you how to write an application for IncludeOS, deploy it locally on your PC or in an IaaS cloud such as OpenStack, and then hook it up to the internet.
— 
Alfred Bratterud
IncludeOS
CEO
Oslo Area, Norway
Websiteincludeos.org
MSc. in mathematical logic from the dept. of Informatics, University of Oslo. Employed since 2011 as Assistant professor at Oslo and Akershus University College of Applied science, the largest institution for engineering education in Norway , where I taught an undergrad course in C++ for 5 years. I'm working on a PhD in the area of cloud computing under the working title "Resource efficient Cloud Computing using minimal virtual machines" and IncludeOS is the result of that work. We have recently received a grant from the Norwegian research council to further develop IncludeOS into a commercially viable product and leading this work (as CEO of the startup IncludeOS AS) is currently my main focus.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:10,139
hello everybody I'll let you guys settle

00:00:02,639 --> 00:00:14,700
down my name is Alfred I started this

00:00:10,139 --> 00:00:15,800
project include OS really glad to be

00:00:14,700 --> 00:00:18,119
here

00:00:15,800 --> 00:00:20,699
it's a fun project I want to show you

00:00:18,119 --> 00:00:23,519
but keep in mind you guys are probably

00:00:20,699 --> 00:00:27,750
the language experts I'm just making an

00:00:23,519 --> 00:00:30,060
our operating system so this first line

00:00:27,750 --> 00:00:32,070
it pretty much sums up what we're trying

00:00:30,060 --> 00:00:36,870
to do we're trying to make this

00:00:32,070 --> 00:00:38,579
statement a reality include OS so this

00:00:36,870 --> 00:00:43,559
is the first line you'll write in an

00:00:38,579 --> 00:00:45,960
include OS program so what we want to do

00:00:43,559 --> 00:00:48,510
is to put some operating system inside

00:00:45,960 --> 00:00:51,780
your elf binary and of course the

00:00:48,510 --> 00:00:53,940
important word here is some I don't

00:00:51,780 --> 00:00:58,250
think you want all of Microsoft Windows

00:00:53,940 --> 00:01:00,719
into your elf binary that would be crazy

00:00:58,250 --> 00:01:02,520
so what we're making is called a unit

00:01:00,719 --> 00:01:05,519
kernel so let me just give you a few

00:01:02,520 --> 00:01:08,490
points about what unit kernels are the

00:01:05,519 --> 00:01:10,860
term was coined in 2013 by Neil Madhava

00:01:08,490 --> 00:01:13,049
pedy Richard Moore dear and others from

00:01:10,860 --> 00:01:14,729
Cambridge so they're making something

00:01:13,049 --> 00:01:18,750
similar to what we're doing but they're

00:01:14,729 --> 00:01:20,820
doing it in Oh camel so the most

00:01:18,750 --> 00:01:24,030
important property probably is that it's

00:01:20,820 --> 00:01:26,159
single purpose we're making something

00:01:24,030 --> 00:01:29,939
you can use for a lot of purposes but

00:01:26,159 --> 00:01:32,189
only one purpose at a time and in order

00:01:29,939 --> 00:01:34,829
to achieve that we make it into a

00:01:32,189 --> 00:01:37,350
library operating system so what we're

00:01:34,829 --> 00:01:39,960
doing is a library and your program will

00:01:37,350 --> 00:01:44,310
pull in whatever it needs from the

00:01:39,960 --> 00:01:46,619
operating system from this library so

00:01:44,310 --> 00:01:51,030
essentially this turns your binary into

00:01:46,619 --> 00:01:53,729
a bootable disk image obviously that

00:01:51,030 --> 00:01:55,530
means you can't run you can expect

00:01:53,729 --> 00:01:57,960
include OS to be your next operating

00:01:55,530 --> 00:02:00,200
system for your laptop I mean your

00:01:57,960 --> 00:02:03,000
laptop needs something general purpose

00:02:00,200 --> 00:02:06,979
but for virtual machines especially in

00:02:03,000 --> 00:02:10,860
the cloud or for IOT a lot of the times

00:02:06,979 --> 00:02:13,900
servers are single purpose anyway you

00:02:10,860 --> 00:02:16,540
set up a web server it's usually

00:02:13,900 --> 00:02:18,280
a full-blown operating system in their

00:02:16,540 --> 00:02:22,720
general purpose but it only does this

00:02:18,280 --> 00:02:25,120
one thing so include us it's a minimal

00:02:22,720 --> 00:02:27,730
resource efficient implementation from

00:02:25,120 --> 00:02:30,189
scratch it's a unicorn and is written

00:02:27,730 --> 00:02:32,019
from scratch in modern C++ this

00:02:30,189 --> 00:02:33,879
reference is from a paper that's when we

00:02:32,019 --> 00:02:39,040
released include West for the first time

00:02:33,879 --> 00:02:41,530
I was in December last year and you see

00:02:39,040 --> 00:02:44,739
some interesting results there but a lot

00:02:41,530 --> 00:02:49,239
has happened since then so some

00:02:44,739 --> 00:02:53,680
interesting facts look at the graph

00:02:49,239 --> 00:02:57,099
there the blue dots at the bottom that's

00:02:53,680 --> 00:03:00,760
included with so it's about 300 times

00:02:57,099 --> 00:03:04,000
smaller than our Ubuntu disk image if

00:03:00,760 --> 00:03:06,459
you build a hello world program and

00:03:04,000 --> 00:03:08,230
include just enough operating system to

00:03:06,459 --> 00:03:10,689
boot that hello world program with

00:03:08,230 --> 00:03:15,849
include OS turns into about 1 megabyte

00:03:10,689 --> 00:03:18,160
of disk and for memory I mean we could

00:03:15,849 --> 00:03:21,430
get we could probably manage with about

00:03:18,160 --> 00:03:24,370
1 megabyte but we're running on x86 so

00:03:21,430 --> 00:03:27,579
the first megabyte is reserved for etc

00:03:24,370 --> 00:03:31,379
etc so about 3 megabytes so this is a

00:03:27,579 --> 00:03:33,870
lot of savings in memory and disk size

00:03:31,379 --> 00:03:36,790
so it's single threaded by default

00:03:33,870 --> 00:03:39,459
doesn't mean will be like that forever

00:03:36,790 --> 00:03:43,269
but there's a good reason for that I'll

00:03:39,459 --> 00:03:45,729
come back to that later it's also faster

00:03:43,269 --> 00:03:48,790
and it's more efficient for single core

00:03:45,729 --> 00:03:53,139
VMs so these are some results from the

00:03:48,790 --> 00:03:56,560
paper a little bit of improvement in

00:03:53,139 --> 00:03:59,199
speed and resource efficiency very

00:03:56,560 --> 00:04:01,989
importantly is boot times so for virtual

00:03:59,199 --> 00:04:05,199
machines in the cloud it's really nice

00:04:01,989 --> 00:04:08,949
to scale fast if you have a lot of

00:04:05,199 --> 00:04:10,840
traffic to your website you know you

00:04:08,949 --> 00:04:12,849
need to spawn new virtual machines to

00:04:10,840 --> 00:04:14,799
handle the requests that's one of the

00:04:12,849 --> 00:04:18,430
interesting properties of cloud is the

00:04:14,799 --> 00:04:20,799
elasticity so good time is important 300

00:04:18,430 --> 00:04:24,370
milliseconds of boot time is pretty fast

00:04:20,799 --> 00:04:27,039
so when you start an include OS program

00:04:24,370 --> 00:04:27,970
or you boot up a virtual machine it's

00:04:27,039 --> 00:04:30,820
like this

00:04:27,970 --> 00:04:34,990
and if it feels like starting a program

00:04:30,820 --> 00:04:36,700
on the terminal so we're not trying to

00:04:34,990 --> 00:04:38,400
Pete with Ubuntu it's a fantastic

00:04:36,700 --> 00:04:40,660
operating system we use it all the time

00:04:38,400 --> 00:04:44,050
but it's a general purpose operating

00:04:40,660 --> 00:04:47,260
system and include OS is designed for

00:04:44,050 --> 00:04:50,640
special purpose appliances that you want

00:04:47,260 --> 00:04:52,780
to wrap into a very safe environment so

00:04:50,640 --> 00:04:56,320
you all know what virtual machines are

00:04:52,780 --> 00:04:58,690
right everybody you know what it is and

00:04:56,320 --> 00:05:01,660
you can tell me at the instruction level

00:04:58,690 --> 00:05:05,050
exactly what it is well I'll go through

00:05:01,660 --> 00:05:09,730
it so there are many this is a very

00:05:05,050 --> 00:05:11,500
heavily overloaded term right so I like

00:05:09,730 --> 00:05:15,340
to go back to this definition that was

00:05:11,500 --> 00:05:16,810
provided in a grey paper in 1974 it's by

00:05:15,340 --> 00:05:19,150
pop akin Goldberg

00:05:16,810 --> 00:05:21,160
so they say that our virtual machine is

00:05:19,150 --> 00:05:24,190
an efficient isolated duplicate of the

00:05:21,160 --> 00:05:25,930
real machine so it's supposed to feel

00:05:24,190 --> 00:05:27,520
exactly like it feels to boot on

00:05:25,930 --> 00:05:29,740
hardware to boot inside that virtual

00:05:27,520 --> 00:05:32,620
machine so this is a statement it

00:05:29,740 --> 00:05:35,020
doesn't it's not really precise but in

00:05:32,620 --> 00:05:37,480
the paper they give a mathematical model

00:05:35,020 --> 00:05:41,320
of exactly what it means to be a virtual

00:05:37,480 --> 00:05:43,950
machine essentially boils down to this

00:05:41,320 --> 00:05:47,380
all sensitive instructions have to trap

00:05:43,950 --> 00:05:49,330
so the hypervisor on the side there

00:05:47,380 --> 00:05:51,370
that's the whole host operating system

00:05:49,330 --> 00:05:54,700
it can be Windows the can be Linux it

00:05:51,370 --> 00:05:56,260
can be Mac OS it's the the operating

00:05:54,700 --> 00:05:59,169
system you installed onto the physical

00:05:56,260 --> 00:06:01,270
machine so very important to notice is

00:05:59,169 --> 00:06:03,520
that according to the public goldberg

00:06:01,270 --> 00:06:06,010
requirements for virtualization there

00:06:03,520 --> 00:06:09,340
isn't any software layer between these

00:06:06,010 --> 00:06:10,900
VMs and the hardware they run directly

00:06:09,340 --> 00:06:14,370
on hardware instructions are executed

00:06:10,900 --> 00:06:17,200
directly without some layer in between

00:06:14,370 --> 00:06:18,820
so we start out we boot the physical

00:06:17,200 --> 00:06:20,740
machine and we're in the hypervisor we

00:06:18,820 --> 00:06:22,900
start a virtual machine in our some

00:06:20,740 --> 00:06:26,140
instructions in there these instructions

00:06:22,900 --> 00:06:27,820
are not dangerous it's just addition

00:06:26,140 --> 00:06:30,190
multiplication moving stuff around

00:06:27,820 --> 00:06:32,620
they're not sensitive so they don't trap

00:06:30,190 --> 00:06:35,440
they execute directly on hardware and is

00:06:32,620 --> 00:06:37,780
fast there's no overhead no layer in

00:06:35,440 --> 00:06:39,960
between there's no emulation if it was

00:06:37,780 --> 00:06:41,550
emulation it wouldn't be a

00:06:39,960 --> 00:06:45,330
machine according to the definitions by

00:06:41,550 --> 00:06:47,850
Papa Goldberg now we come to the m2 well

00:06:45,330 --> 00:06:51,240
here's something sensitive at the end

00:06:47,850 --> 00:06:55,319
here I'm saying out and out means send

00:06:51,240 --> 00:06:58,500
some byte over the bus to some device on

00:06:55,319 --> 00:07:00,810
the hardware so this has to trap so what

00:06:58,500 --> 00:07:03,090
happens then we we switch to the

00:07:00,810 --> 00:07:06,240
hypervisor the hypervisor gets notified

00:07:03,090 --> 00:07:10,319
of what you want it to do and it can

00:07:06,240 --> 00:07:11,910
either emulate a physical device or it

00:07:10,319 --> 00:07:14,070
could pass your instruction on to a

00:07:11,910 --> 00:07:17,849
physical device we don't really know and

00:07:14,070 --> 00:07:19,620
we don't have to know so but obviously

00:07:17,849 --> 00:07:22,289
you need the trap you can't just ignore

00:07:19,620 --> 00:07:24,180
these sensitive instructions like like

00:07:22,289 --> 00:07:27,509
what's the case on very early Intel

00:07:24,180 --> 00:07:31,349
processors you need to trap and once you

00:07:27,509 --> 00:07:34,770
do you can provide virtualization same

00:07:31,349 --> 00:07:36,389
goes with virtual memory it's it's the

00:07:34,770 --> 00:07:41,250
same principle of virtual memory that

00:07:36,389 --> 00:07:43,770
you used to for user space but in this

00:07:41,250 --> 00:07:46,770
case you also have to trap and we use

00:07:43,770 --> 00:07:51,389
this mechanism in order to for example

00:07:46,770 --> 00:07:54,930
talk to memory map devices so this was a

00:07:51,389 --> 00:07:57,180
great paper all I always said now was

00:07:54,930 --> 00:08:00,810
from this paper and it takes 30 years

00:07:57,180 --> 00:08:06,110
until Intel says oh that's a good idea

00:08:00,810 --> 00:08:09,719
let's implement that so finally in

00:08:06,110 --> 00:08:12,270
2005/2006 hardware virtualization was

00:08:09,719 --> 00:08:17,219
popularized into Intel CPUs and now all

00:08:12,270 --> 00:08:18,900
your laptops have it so the point is you

00:08:17,219 --> 00:08:21,570
can run direct on hardware there's no

00:08:18,900 --> 00:08:24,560
software layer in between the VM trap is

00:08:21,570 --> 00:08:29,370
pretty much a glorified context switch

00:08:24,560 --> 00:08:31,320
so since we're also 100% self-contained

00:08:29,370 --> 00:08:34,140
we run directly on hardware we don't

00:08:31,320 --> 00:08:36,360
share any code with a hypervisor we

00:08:34,140 --> 00:08:38,820
don't share any executable code with

00:08:36,360 --> 00:08:41,520
other virtual machines that means when

00:08:38,820 --> 00:08:44,390
you build as an elf binary with include

00:08:41,520 --> 00:08:47,790
OS you can run the same binary on

00:08:44,390 --> 00:08:50,760
Windows Linux or Mac so that's also

00:08:47,790 --> 00:08:53,300
pretty cool it's like a java runtime

00:08:50,760 --> 00:08:59,420
environment for c++

00:08:53,300 --> 00:09:00,830
hardware support I also want to stress

00:08:59,420 --> 00:09:04,760
that we look at these virtual machines

00:09:00,830 --> 00:09:06,980
like processes I mean they're not they

00:09:04,760 --> 00:09:08,990
don't have to be huge machines that you

00:09:06,980 --> 00:09:10,850
log into the terminal it's just a

00:09:08,990 --> 00:09:15,590
process and the virtualization layer

00:09:10,850 --> 00:09:20,960
around it it's it's just a glorified

00:09:15,590 --> 00:09:23,260
complex traditions essentially yeah so

00:09:20,960 --> 00:09:25,760
since it's running directly on Hardware

00:09:23,260 --> 00:09:26,960
you know you have to have an operating

00:09:25,760 --> 00:09:28,730
system in order to do something

00:09:26,960 --> 00:09:32,510
interesting you could do a computation

00:09:28,730 --> 00:09:36,050
of digits of pi or something but when

00:09:32,510 --> 00:09:39,500
you want I oh you're going to have some

00:09:36,050 --> 00:09:42,920
operating system in there so this is the

00:09:39,500 --> 00:09:44,540
build system this is essentially what an

00:09:42,920 --> 00:09:47,480
include West virtual machine is and how

00:09:44,540 --> 00:09:50,330
it gets built so there's the OS a that's

00:09:47,480 --> 00:09:52,280
the library where we put all the parts

00:09:50,330 --> 00:09:55,490
of the operating system that you can

00:09:52,280 --> 00:09:57,380
pick and choose from and you pick and

00:09:55,490 --> 00:10:01,130
choose just by mentioning this in code

00:09:57,380 --> 00:10:03,440
if you want to use TCP you mentioned TCP

00:10:01,130 --> 00:10:08,780
and the static linker will pull TCP into

00:10:03,440 --> 00:10:12,800
your code drivers we've separated I'll

00:10:08,780 --> 00:10:15,280
mention those later so what's

00:10:12,800 --> 00:10:17,900
interesting now is that we can increase

00:10:15,280 --> 00:10:19,400
we can keep adding functionality just

00:10:17,900 --> 00:10:21,350
like the standards commit Standards

00:10:19,400 --> 00:10:24,440
Committee does to C++ right you can just

00:10:21,350 --> 00:10:27,500
throw more features in there we can do

00:10:24,440 --> 00:10:29,240
that without having the size of the

00:10:27,500 --> 00:10:32,300
virtual machines to grow because it just

00:10:29,240 --> 00:10:35,290
blows the library and your service still

00:10:32,300 --> 00:10:35,290
just pulls up what it needs

00:10:35,780 --> 00:10:41,600
the last part here it's actually

00:10:37,670 --> 00:10:43,190
optional you can boot without this but

00:10:41,600 --> 00:10:45,170
this this makes it the most

00:10:43,190 --> 00:10:47,210
self-contained if you add a bootloader

00:10:45,170 --> 00:10:50,540
so we have a tiny little program that

00:10:47,210 --> 00:10:52,880
just adds the 512 byte bootloader to the

00:10:50,540 --> 00:11:00,320
front of your elf binary and that makes

00:10:52,880 --> 00:11:02,900
its bootable so why C++ it's completely

00:11:00,320 --> 00:11:04,570
obvious to me and probably to all of you

00:11:02,900 --> 00:11:06,830
guys but since some people are asking

00:11:04,570 --> 00:11:11,540
let me just mention

00:11:06,830 --> 00:11:13,490
some things C++ I mean you can say so

00:11:11,540 --> 00:11:15,610
many things about it but for me it's

00:11:13,490 --> 00:11:18,500
obvious that it's the most evolved

00:11:15,610 --> 00:11:20,209
independent system language and by

00:11:18,500 --> 00:11:23,300
independent systems language I mean

00:11:20,209 --> 00:11:25,970
something that can write arbitrated data

00:11:23,300 --> 00:11:27,410
to arbitrary addresses and that's

00:11:25,970 --> 00:11:30,350
something you have to be able to do to

00:11:27,410 --> 00:11:31,940
write an operating system you also need

00:11:30,350 --> 00:11:36,890
access to the full instruction set I

00:11:31,940 --> 00:11:38,480
mean you have to tell the CPU how to

00:11:36,890 --> 00:11:41,089
handle interrupts you have to talk

00:11:38,480 --> 00:11:43,760
directly to devices you have to have

00:11:41,089 --> 00:11:45,050
access to the whole instruction set in

00:11:43,760 --> 00:11:50,750
order to be an efficient operating

00:11:45,050 --> 00:11:53,089
system so in my mind I can't see how you

00:11:50,750 --> 00:11:58,490
can have a completely type safe language

00:11:53,089 --> 00:12:01,040
and do all this it's a contrast right so

00:11:58,490 --> 00:12:03,290
the Mirage guys the the ones that are

00:12:01,040 --> 00:12:05,870
writing operating systems in all camel

00:12:03,290 --> 00:12:07,910
they will have a C layer you'll see a

00:12:05,870 --> 00:12:10,310
lot of high-level unit kernel projects

00:12:07,910 --> 00:12:12,230
and they will have a C layer what I

00:12:10,310 --> 00:12:13,970
think is great about C++ is that we can

00:12:12,230 --> 00:12:16,520
do everything we can do the high-level

00:12:13,970 --> 00:12:22,510
abstractions we can also do all the

00:12:16,520 --> 00:12:28,160
low-level so this is hello world

00:12:22,510 --> 00:12:32,600
it looks probably unfamiliar because how

00:12:28,160 --> 00:12:35,240
about main so the reason why we didn't

00:12:32,600 --> 00:12:38,329
use main for this starting function of a

00:12:35,240 --> 00:12:41,500
program we could have but we didn't

00:12:38,329 --> 00:12:44,630
because the signature doesn't really

00:12:41,500 --> 00:12:47,930
live up to the expectation the signature

00:12:44,630 --> 00:12:49,370
of main returns an int right so in the

00:12:47,930 --> 00:12:53,839
unit kernel where's that's supposed to

00:12:49,370 --> 00:12:56,270
go so there's no parent process it's

00:12:53,839 --> 00:12:56,570
only your process right so where should

00:12:56,270 --> 00:12:58,790
it go

00:12:56,570 --> 00:13:01,670
should it go back to the hypervisor well

00:12:58,790 --> 00:13:05,570
it could but then if you're running in

00:13:01,670 --> 00:13:07,699
the cloud where does that go right it

00:13:05,570 --> 00:13:09,949
just goes down to some server that's

00:13:07,699 --> 00:13:11,420
running in a data center somewhere so

00:13:09,949 --> 00:13:14,089
it's not obvious

00:13:11,420 --> 00:13:16,579
so for us we thought well let's just

00:13:14,089 --> 00:13:19,190
make a new signature we might do main as

00:13:16,579 --> 00:13:20,510
well but when we do I think it's most

00:13:19,190 --> 00:13:24,880
appropriate to actual

00:13:20,510 --> 00:13:27,080
we do what you expect with mains so

00:13:24,880 --> 00:13:29,450
another interesting question is where

00:13:27,080 --> 00:13:32,840
does standardout go so let's just

00:13:29,450 --> 00:13:34,490
address that right away so by default

00:13:32,840 --> 00:13:36,890
since there is no parent process we

00:13:34,490 --> 00:13:40,250
can't just return standard out data to

00:13:36,890 --> 00:13:41,330
the shell right there is no shell it's

00:13:40,250 --> 00:13:44,330
just the process

00:13:41,330 --> 00:13:46,490
I mean it's running in an hour other

00:13:44,330 --> 00:13:50,600
operating system but not in the context

00:13:46,490 --> 00:13:53,720
of a shell so by default we route this

00:13:50,600 --> 00:13:56,060
to the serial port and that means when

00:13:53,720 --> 00:13:58,010
you're running include OS from a

00:13:56,060 --> 00:14:00,710
terminal it behaves like a normal

00:13:58,010 --> 00:14:03,400
process because usually at least on

00:14:00,710 --> 00:14:06,850
linux with key mu which is the

00:14:03,400 --> 00:14:11,060
virtualization program you use in linux

00:14:06,850 --> 00:14:14,240
then you can get the serial port output

00:14:11,060 --> 00:14:17,420
just redirected out to your terminal so

00:14:14,240 --> 00:14:20,210
when I write programs it feels I start a

00:14:17,420 --> 00:14:22,820
program and the output whatever I do in

00:14:20,210 --> 00:14:25,730
printf for C out it just comes out in

00:14:22,820 --> 00:14:30,170
the journal like you expect but you know

00:14:25,730 --> 00:14:33,920
that's not something you always want so

00:14:30,170 --> 00:14:36,890
we're using delegates everywhere so

00:14:33,920 --> 00:14:38,540
these delegates I mean as you probably

00:14:36,890 --> 00:14:41,120
all know they much more about this than

00:14:38,540 --> 00:14:43,820
I do but essentially a delegate it's a

00:14:41,120 --> 00:14:46,940
pointer to a member function so the

00:14:43,820 --> 00:14:50,120
delegates we're using are compatible

00:14:46,940 --> 00:14:51,650
with standard function so when you have

00:14:50,120 --> 00:14:54,650
an interface that takes a delegate as a

00:14:51,650 --> 00:14:56,540
parameter you can give it a pointer to a

00:14:54,650 --> 00:14:59,150
member function or you can give it a

00:14:56,540 --> 00:15:03,980
free-standing function or a lambda or

00:14:59,150 --> 00:15:08,810
any other standard function so I think

00:15:03,980 --> 00:15:10,880
we owe this user something because we

00:15:08,810 --> 00:15:13,520
found this code just posted on Stack

00:15:10,880 --> 00:15:16,550
Exchange so if anybody knows this user

00:15:13,520 --> 00:15:20,800
or if you're you seeing this please let

00:15:16,550 --> 00:15:24,320
us buy you a beverage of your choice I

00:15:20,800 --> 00:15:25,970
mean the code is really cool it really

00:15:24,320 --> 00:15:29,660
works it's compatible with everything

00:15:25,970 --> 00:15:31,700
and it's written in modern C++ 11 it

00:15:29,660 --> 00:15:33,310
makes my head explode a little when I

00:15:31,700 --> 00:15:37,090
try to read all of it

00:15:33,310 --> 00:15:40,360
but it works so now we can route

00:15:37,090 --> 00:15:42,970
standard out to anywhere so in the first

00:15:40,360 --> 00:15:44,500
case here we're routing it to VGA you

00:15:42,970 --> 00:15:46,480
know that's also a strange concept with

00:15:44,500 --> 00:15:47,200
with virtual machines what's with VGA

00:15:46,480 --> 00:15:50,230
right

00:15:47,200 --> 00:15:52,660
I mean you boot up a virtual machine

00:15:50,230 --> 00:15:55,870
whenever you write to video map memory

00:15:52,660 --> 00:15:58,360
it causes a trap so then it's up to the

00:15:55,870 --> 00:16:01,300
hypervisor to say okay you want to write

00:15:58,360 --> 00:16:04,720
to this memory mapped video device what

00:16:01,300 --> 00:16:06,279
do I do with it right so usually what

00:16:04,720 --> 00:16:07,930
happens if you write if you're on the

00:16:06,279 --> 00:16:09,820
desktop and you start a virtual machine

00:16:07,930 --> 00:16:11,800
you get a little window and this window

00:16:09,820 --> 00:16:14,320
represent the VGA output from that

00:16:11,800 --> 00:16:16,390
virtual machine but there's nothing to

00:16:14,320 --> 00:16:19,270
say that you have to have that and in a

00:16:16,390 --> 00:16:21,010
server in a data center obviously that's

00:16:19,270 --> 00:16:24,190
just useless you don't need that VGA

00:16:21,010 --> 00:16:25,930
output so you can write it there because

00:16:24,190 --> 00:16:28,750
it's nice we have a snake game you can

00:16:25,930 --> 00:16:30,370
play using this kind of graphics but

00:16:28,750 --> 00:16:33,370
it's not really you it's not really

00:16:30,370 --> 00:16:37,300
necessary but it can be nice so in this

00:16:33,370 --> 00:16:39,670
second case we add a custom Handler

00:16:37,300 --> 00:16:41,380
again this just takes a delegate as a

00:16:39,670 --> 00:16:43,810
parameter in this case we're using a

00:16:41,380 --> 00:16:46,390
lambda and we're writing standard out

00:16:43,810 --> 00:16:48,190
two in this case it's from the web

00:16:46,390 --> 00:16:50,020
server we'll show you later and it's

00:16:48,190 --> 00:16:55,150
writing it to a ring buffer in memory

00:16:50,020 --> 00:16:56,530
that can be harvested later so what's

00:16:55,150 --> 00:16:58,690
different about an operating system for

00:16:56,530 --> 00:17:00,310
virtual machines in principle like I've

00:16:58,690 --> 00:17:02,470
said it's almost nothing but I'll just

00:17:00,310 --> 00:17:07,179
give you a brief idea of the hardware we

00:17:02,470 --> 00:17:09,730
have to deal with so this is not

00:17:07,179 --> 00:17:11,650
complete but this is like this is some

00:17:09,730 --> 00:17:14,829
things we have to deal with a lot and

00:17:11,650 --> 00:17:18,220
that's mostly exactly like an operating

00:17:14,829 --> 00:17:19,929
system for physical machines because I

00:17:18,220 --> 00:17:22,540
only interface with these devices

00:17:19,929 --> 00:17:24,550
through physical through the CPU

00:17:22,540 --> 00:17:27,850
directly through the CPU there's no

00:17:24,550 --> 00:17:29,230
shared code right so inside the CPU we

00:17:27,850 --> 00:17:32,080
have timers we have interrupt

00:17:29,230 --> 00:17:33,610
controllers we have registers we need to

00:17:32,080 --> 00:17:37,420
deal with we have access to all of

00:17:33,610 --> 00:17:40,300
memory which is nice and then we have

00:17:37,420 --> 00:17:41,980
serial ports and the PCI bus and on the

00:17:40,300 --> 00:17:44,380
PCI bus that's where I find most my

00:17:41,980 --> 00:17:46,630
devices i probe the pci bus just like

00:17:44,380 --> 00:17:48,340
you would in an

00:17:46,630 --> 00:17:53,170
normal operating system and what I find

00:17:48,340 --> 00:17:54,640
there is something that usually our

00:17:53,170 --> 00:17:57,070
virtual devices that's the most

00:17:54,640 --> 00:18:01,890
efficient when you're running a virtual

00:17:57,070 --> 00:18:07,600
machine we have custom memory mapped

00:18:01,890 --> 00:18:09,100
ways to transfer data in and out but the

00:18:07,600 --> 00:18:12,840
point is that we use a hardware

00:18:09,100 --> 00:18:18,880
interface to establish this kind of

00:18:12,840 --> 00:18:20,770
exchange so the interface that I use to

00:18:18,880 --> 00:18:23,020
talk to these devices it's a physical

00:18:20,770 --> 00:18:26,470
interface are in the sense that there

00:18:23,020 --> 00:18:28,630
are instructions to the CPU and then we

00:18:26,470 --> 00:18:31,480
negotiate direct memory access so that

00:18:28,630 --> 00:18:34,990
the device can deposit packages directly

00:18:31,480 --> 00:18:38,350
into my memory without me having to do

00:18:34,990 --> 00:18:40,300
port I all the time so the point is the

00:18:38,350 --> 00:18:42,190
virtual devices but they could have as

00:18:40,300 --> 00:18:46,810
well have been physical devices

00:18:42,190 --> 00:18:49,440
I don't really know so talking about

00:18:46,810 --> 00:18:53,350
devices is kind of interesting to see

00:18:49,440 --> 00:18:55,720
how we include only the drivers you need

00:18:53,350 --> 00:18:58,330
so I talked about static linking that's

00:18:55,720 --> 00:18:59,860
the way we get most the stuff in and we

00:18:58,330 --> 00:19:02,680
in the beginning we use that also for

00:18:59,860 --> 00:19:04,510
drivers but you know you kind of want to

00:19:02,680 --> 00:19:05,890
be able to replace a device driver

00:19:04,510 --> 00:19:10,570
without having to reroute the

00:19:05,890 --> 00:19:12,940
application code right so I thought it

00:19:10,570 --> 00:19:18,160
was kind of interesting we use global

00:19:12,940 --> 00:19:20,020
constructors now for that so the

00:19:18,160 --> 00:19:21,550
ordering of global constructor is

00:19:20,020 --> 00:19:23,770
undefined so you don't really know

00:19:21,550 --> 00:19:26,140
what's going on when but of course we

00:19:23,770 --> 00:19:27,730
know exactly when to start calling

00:19:26,140 --> 00:19:30,970
global constructors and we know whether

00:19:27,730 --> 00:19:33,640
when they're done so what we're doing is

00:19:30,970 --> 00:19:36,550
that we are we can now link in a driver

00:19:33,640 --> 00:19:39,460
and if it has a global constructor this

00:19:36,550 --> 00:19:43,360
can register with the PCI manager and

00:19:39,460 --> 00:19:47,110
give it a delegate so it just gives the

00:19:43,360 --> 00:19:49,000
PCI manager a delegate that's a pointer

00:19:47,110 --> 00:19:50,500
to a function or a member function in

00:19:49,000 --> 00:19:53,140
this case it's the initialization

00:19:50,500 --> 00:19:55,690
function for the network driver so I'm

00:19:53,140 --> 00:19:57,970
telling the PCI bus that here's the

00:19:55,690 --> 00:19:59,600
driver so whenever you encounter a

00:19:57,970 --> 00:20:02,600
device that has

00:19:59,600 --> 00:20:07,580
this vendor ID or this device ID you can

00:20:02,600 --> 00:20:09,470
initialize me so that's slightly

00:20:07,580 --> 00:20:11,630
different than from the static linking

00:20:09,470 --> 00:20:14,030
approach but it makes it possible for

00:20:11,630 --> 00:20:15,530
you to specify from right outside now I

00:20:14,030 --> 00:20:17,059
want to run on that kind of driver now I

00:20:15,530 --> 00:20:20,000
want to run on that kind of driver and

00:20:17,059 --> 00:20:22,390
the IP interface or the network

00:20:20,000 --> 00:20:25,010
interface is abstracted from the drivers

00:20:22,390 --> 00:20:27,230
so now the deployment tools and SUSE

00:20:25,010 --> 00:20:30,640
admins can apply appropriate drivers and

00:20:27,230 --> 00:20:33,860
you can relink without having to rewrite

00:20:30,640 --> 00:20:35,840
so let's look at the core of the kernel

00:20:33,860 --> 00:20:39,610
like I said it's single threaded by

00:20:35,840 --> 00:20:39,610
default so it's completely event based

00:20:41,470 --> 00:20:46,190
so this is the event loop essentially

00:20:44,840 --> 00:20:49,130
what's going on I mean I do a lot of

00:20:46,190 --> 00:20:50,659
initialization initialize stack heap BSS

00:20:49,130 --> 00:20:52,789
etc called global constructors

00:20:50,659 --> 00:20:54,049
initialize hardware and then I call the

00:20:52,789 --> 00:20:55,880
service start which could have been

00:20:54,049 --> 00:20:58,730
called main if the signature wouldn't

00:20:55,880 --> 00:21:00,890
have been lying and then I go into this

00:20:58,730 --> 00:21:05,809
event loop where what we're all I'm

00:21:00,890 --> 00:21:08,240
doing is to ask the irq manager which

00:21:05,809 --> 00:21:10,010
interrupts have happened which of them

00:21:08,240 --> 00:21:12,320
were subscribed to and if they both

00:21:10,010 --> 00:21:14,890
happen then we're subscribed to then

00:21:12,320 --> 00:21:18,620
call the delegate that they registered

00:21:14,890 --> 00:21:20,390
so obviously this would be spending a

00:21:18,620 --> 00:21:22,600
hundred percent CPU if there wasn't

00:21:20,390 --> 00:21:25,010
something more going on so there is so

00:21:22,600 --> 00:21:27,260
after the I or queue manager has called

00:21:25,010 --> 00:21:29,780
all the delegates that were waiting to

00:21:27,260 --> 00:21:32,720
be called the halt instruction will be

00:21:29,780 --> 00:21:34,789
called so essentially yeah and the halt

00:21:32,720 --> 00:21:36,320
instruction it just means put the CPU to

00:21:34,789 --> 00:21:39,320
sleep until there's a new interrupt

00:21:36,320 --> 00:21:41,390
that's what it means so what's nice

00:21:39,320 --> 00:21:46,159
about that is that there is no

00:21:41,390 --> 00:21:47,510
preemption here it means when this unit

00:21:46,159 --> 00:21:50,030
kernel is sleeping and not doing

00:21:47,510 --> 00:21:53,000
anything it will use exactly zero

00:21:50,030 --> 00:21:55,039
percent CPU it will be just scheduled

00:21:53,000 --> 00:21:57,080
out and will use absolutely no resources

00:21:55,039 --> 00:21:59,120
so you can have a lot of these in memory

00:21:57,080 --> 00:22:04,460
they are sleeping and they are not

00:21:59,120 --> 00:22:06,470
spending any resources so notice that

00:22:04,460 --> 00:22:08,900
when you subscribe to interrupts that

00:22:06,470 --> 00:22:11,809
get handled in this manner without

00:22:08,900 --> 00:22:12,940
preemption there will be then you don't

00:22:11,809 --> 00:22:15,250
have a guarantee

00:22:12,940 --> 00:22:17,139
of exactly how long it took from when

00:22:15,250 --> 00:22:18,880
the interval was called until your

00:22:17,139 --> 00:22:21,210
delegate was called because that might

00:22:18,880 --> 00:22:24,940
depend on other interrupts having been

00:22:21,210 --> 00:22:27,130
handled before you so you can also do it

00:22:24,940 --> 00:22:28,389
the hard way and make pre-emptive

00:22:27,130 --> 00:22:31,389
interrupts we do that for a stack

00:22:28,389 --> 00:22:33,279
sampler I'll show you later but you know

00:22:31,389 --> 00:22:35,769
this takes you a long way

00:22:33,279 --> 00:22:38,320
it actually takes you all the way up to

00:22:35,769 --> 00:22:41,799
making an internet-enabled application

00:22:38,320 --> 00:22:43,179
that can serve a lot of requests on

00:22:41,799 --> 00:22:47,230
different ports and on different

00:22:43,179 --> 00:22:50,799
protocols at the same time so this is

00:22:47,230 --> 00:22:52,690
how you subscribe to interrupts I told

00:22:50,799 --> 00:22:56,830
you these delegates were nice they're

00:22:52,690 --> 00:23:00,759
not pretty to declare but they they work

00:22:56,830 --> 00:23:02,860
very well so I declare a delegate I'm

00:23:00,759 --> 00:23:05,610
giving I'm saying this is a signature

00:23:02,860 --> 00:23:09,399
that returns void takes no parameters

00:23:05,610 --> 00:23:12,580
I'm telling telling it which class this

00:23:09,399 --> 00:23:14,830
delegate points to and then I tell it

00:23:12,580 --> 00:23:16,990
which function with which member

00:23:14,830 --> 00:23:20,740
function of that class we point to and

00:23:16,990 --> 00:23:22,769
then I give it an instance so having

00:23:20,740 --> 00:23:25,600
made the delegate now I can just

00:23:22,769 --> 00:23:29,350
subscribe to an interrupt number and I

00:23:25,600 --> 00:23:31,330
pass along this delegate so what happens

00:23:29,350 --> 00:23:33,250
here is that whenever this interrupts n

00:23:31,330 --> 00:23:35,289
happens of course I didn't hard-code

00:23:33,250 --> 00:23:37,750
this in include OS but I did it for the

00:23:35,289 --> 00:23:39,639
example but now whenever interrupts n

00:23:37,750 --> 00:23:41,860
happens this delegate gets called and

00:23:39,639 --> 00:23:43,870
then the network driver is notified that

00:23:41,860 --> 00:23:48,720
okay I have new packets probably in

00:23:43,870 --> 00:23:50,710
memory so you don't have to worry about

00:23:48,720 --> 00:23:52,659
subscribing to interrupts I'm just

00:23:50,710 --> 00:23:56,590
showing you how this is done we provide

00:23:52,659 --> 00:23:59,889
a lot of objections on top of this so we

00:23:56,590 --> 00:24:02,230
also made our own IP stack and I thought

00:23:59,889 --> 00:24:03,580
that was crazy when we started I thought

00:24:02,230 --> 00:24:06,159
I would never do that I thought it just

00:24:03,580 --> 00:24:07,690
poured something from somewhere else but

00:24:06,159 --> 00:24:09,399
then you know I couldn't help myself so

00:24:07,690 --> 00:24:10,480
I started with Ethernet then that wasn't

00:24:09,399 --> 00:24:12,940
that complicated

00:24:10,480 --> 00:24:16,179
because it really isn't it's a small

00:24:12,940 --> 00:24:18,879
header and it's just just essentially

00:24:16,179 --> 00:24:22,179
you have to switch on packet type okay

00:24:18,879 --> 00:24:24,600
so we started and then I got to our bin

00:24:22,179 --> 00:24:26,620
IP 4 and UDP and it all went kind of

00:24:24,600 --> 00:24:31,270
nicely so

00:24:26,620 --> 00:24:33,909
we thought what the hell so what you see

00:24:31,270 --> 00:24:36,669
in the picture all of these boxes are

00:24:33,909 --> 00:24:41,080
classes class instances and they're also

00:24:36,669 --> 00:24:43,409
representing one protocol all the

00:24:41,080 --> 00:24:48,880
connections between them are delegates

00:24:43,409 --> 00:24:51,730
so that means the ethernet object it

00:24:48,880 --> 00:24:53,260
just knows okay I have a packet and now

00:24:51,730 --> 00:24:55,960
I'm passing this along through this

00:24:53,260 --> 00:24:57,309
delegate all I need to know is that the

00:24:55,960 --> 00:24:59,230
delegate is a function that has a

00:24:57,309 --> 00:25:01,029
signature that allows me to pass a

00:24:59,230 --> 00:25:03,010
packet through it I really don't know

00:25:01,029 --> 00:25:06,580
how I don't have to know anything else

00:25:03,010 --> 00:25:08,320
about that class so Ethernet doesn't

00:25:06,580 --> 00:25:12,299
know about IP it just knows that I have

00:25:08,320 --> 00:25:15,399
a handler for that kind of data and this

00:25:12,299 --> 00:25:17,950
handler can I can send the packet to

00:25:15,399 --> 00:25:22,000
there so we use the delegates both up

00:25:17,950 --> 00:25:24,909
and down so all of this wiring it's

00:25:22,000 --> 00:25:27,399
pretty simple it's like two lines of

00:25:24,909 --> 00:25:31,000
codes for each wire so yes it's a lot of

00:25:27,399 --> 00:25:33,640
wires but it's quite simple and this

00:25:31,000 --> 00:25:35,890
also makes it possible to write custom

00:25:33,640 --> 00:25:38,169
versions of this IP stack I mean I'm

00:25:35,890 --> 00:25:41,020
concerned with minimality so if you just

00:25:38,169 --> 00:25:43,270
want a network stack that only talks UDP

00:25:41,020 --> 00:25:44,980
you know I want you to be able to do

00:25:43,270 --> 00:25:47,260
that so you can reuse these same

00:25:44,980 --> 00:25:50,710
components take out the parts you don't

00:25:47,260 --> 00:25:53,260
want and make another wrapper class that

00:25:50,710 --> 00:25:56,500
has kind of a minimal custom-tailored IP

00:25:53,260 --> 00:26:00,010
stack for your purpose you can also

00:25:56,500 --> 00:26:03,309
rewire during run time it's only a

00:26:00,010 --> 00:26:06,610
matter of shifting these delegates so

00:26:03,309 --> 00:26:10,830
here's an example where I insert an IP

00:26:06,610 --> 00:26:14,289
filter so if you can see here there okay

00:26:10,830 --> 00:26:18,159
animation wasn't so good but an IP

00:26:14,289 --> 00:26:20,020
filter was just put in between ah the

00:26:18,159 --> 00:26:22,539
ethernet object and the IP for object

00:26:20,020 --> 00:26:24,220
just by rewiring the delegates and you

00:26:22,539 --> 00:26:25,840
can see on our website you can see an

00:26:24,220 --> 00:26:31,240
example of how to do that in code in a

00:26:25,840 --> 00:26:33,669
few lines so like I said I'm concerned

00:26:31,240 --> 00:26:36,820
with the minimality so I want the

00:26:33,669 --> 00:26:39,690
defaults to be minimal

00:26:36,820 --> 00:26:42,230
so we're single threaded by default

00:26:39,690 --> 00:26:43,830
this is due to actually our

00:26:42,230 --> 00:26:46,769
interpretation of the null operator

00:26:43,830 --> 00:26:49,019
principle because in virtual machines

00:26:46,769 --> 00:26:50,909
threading is more expensive it's quite

00:26:49,019 --> 00:26:56,009
another involved topic I'm not an expert

00:26:50,909 --> 00:26:58,799
on this but you can quite easily imagine

00:26:56,009 --> 00:27:01,230
that when you have scheduling and thread

00:26:58,799 --> 00:27:03,690
synchronization already going on on the

00:27:01,230 --> 00:27:05,940
hypervisor and then you have another

00:27:03,690 --> 00:27:07,980
layer of scheduling and threads and

00:27:05,940 --> 00:27:09,870
synchronization inside the virtual

00:27:07,980 --> 00:27:12,389
machine then these can interfere with

00:27:09,870 --> 00:27:14,100
each other so this is one reference

00:27:12,389 --> 00:27:15,750
there are several references to research

00:27:14,100 --> 00:27:17,490
showing that threaded applications

00:27:15,750 --> 00:27:20,480
inside of virtual machines are

00:27:17,490 --> 00:27:22,679
significantly significantly slower

00:27:20,480 --> 00:27:24,360
compared to bare metal than single

00:27:22,679 --> 00:27:26,669
threaded applications now I'm not

00:27:24,360 --> 00:27:28,289
against threading at all I just want you

00:27:26,669 --> 00:27:30,570
to notice that when you boot up a

00:27:28,289 --> 00:27:32,279
virtual machine and you say that this

00:27:30,570 --> 00:27:34,409
virtual machine should have five CPUs

00:27:32,279 --> 00:27:36,570
then you already get five threads

00:27:34,409 --> 00:27:39,269
because that's how you make a virtual

00:27:36,570 --> 00:27:41,549
CPU is by making one fed on the host so

00:27:39,269 --> 00:27:44,250
we're kind of looking to make interfaces

00:27:41,549 --> 00:27:46,049
where we can utilize that so that the

00:27:44,250 --> 00:27:49,049
physical machine only has to deal with

00:27:46,049 --> 00:27:53,340
one set of threads one level or layer of

00:27:49,049 --> 00:27:55,590
threads and not two so in order to do

00:27:53,340 --> 00:27:56,539
single threaded very efficiently and

00:27:55,590 --> 00:27:59,970
cheaply

00:27:56,539 --> 00:28:02,490
everything is isync so that means

00:27:59,970 --> 00:28:07,019
currently there are no blocking POSIX

00:28:02,490 --> 00:28:10,559
calls but we know people like to say F

00:28:07,019 --> 00:28:12,149
read and they expect to not have to move

00:28:10,559 --> 00:28:13,769
out of the queue and just stand there

00:28:12,149 --> 00:28:16,169
and say I'll set every you'd and I'm

00:28:13,769 --> 00:28:19,009
standing right here until I get my data

00:28:16,169 --> 00:28:22,320
right it's your constitutional right I

00:28:19,009 --> 00:28:23,820
realize that so of course we will take

00:28:22,320 --> 00:28:25,710
care of your stack and we will set it

00:28:23,820 --> 00:28:28,049
aside and we'll create a new stack and

00:28:25,710 --> 00:28:30,570
and we'll fix that for you but we just

00:28:28,049 --> 00:28:34,830
want to show the full potential of the

00:28:30,570 --> 00:28:38,580
single threaded version of this first so

00:28:34,830 --> 00:28:41,179
this is how we write a tcp server the

00:28:38,580 --> 00:28:44,159
POSIX interface for networking is are

00:28:41,179 --> 00:28:46,980
more involved than this so I think it's

00:28:44,159 --> 00:28:51,029
quite intuitive I'm starting my service

00:28:46,980 --> 00:28:53,040
I'm saying that I want a server and I

00:28:51,029 --> 00:28:57,060
want to and

00:28:53,040 --> 00:28:58,680
in turn I pee for Internet stack so I'm

00:28:57,060 --> 00:29:01,350
asking for the stack and from the stack

00:28:58,680 --> 00:29:03,180
I'm asking for the TCP object and on the

00:29:01,350 --> 00:29:07,140
TCP object I'm saying that I want to

00:29:03,180 --> 00:29:10,620
bind to port 80 so I get a server object

00:29:07,140 --> 00:29:13,820
that's bound to port 80 so now I can

00:29:10,620 --> 00:29:16,800
attach delegates to events on this

00:29:13,820 --> 00:29:18,660
connect on this server so I say

00:29:16,800 --> 00:29:21,060
unconnect and I provide a delegate

00:29:18,660 --> 00:29:23,940
doesn't have to be a lambda it can be

00:29:21,060 --> 00:29:26,160
and it usually probably maybe it

00:29:23,940 --> 00:29:29,100
shouldn't be but you know it could be

00:29:26,160 --> 00:29:32,340
probably a server object that you write

00:29:29,100 --> 00:29:36,720
and you point this on connect function

00:29:32,340 --> 00:29:38,910
to there so now you say on read and you

00:29:36,720 --> 00:29:40,710
say how much you want to read and now we

00:29:38,910 --> 00:29:44,400
get two buffers it's kind of complicated

00:29:40,710 --> 00:29:46,080
this is a shared pointer to a buffer it

00:29:44,400 --> 00:29:47,670
has to be it has to do with a

00:29:46,080 --> 00:29:49,710
synchronicity why we had to do it like

00:29:47,670 --> 00:29:51,660
that I know you don't like the buffer

00:29:49,710 --> 00:29:55,200
and size interfaces and we're really

00:29:51,660 --> 00:29:57,630
trying to outlaw them throughout so this

00:29:55,200 --> 00:30:02,360
is kind of a special case it's a it's

00:29:57,630 --> 00:30:05,490
the buffer is lives in in shared memory

00:30:02,360 --> 00:30:07,260
so anyway every time you connect to this

00:30:05,490 --> 00:30:07,920
server now over telnet you'll get this

00:30:07,260 --> 00:30:11,970
response

00:30:07,920 --> 00:30:14,900
it's a TCP server it works another

00:30:11,970 --> 00:30:18,560
security so how do you break into this I

00:30:14,900 --> 00:30:24,150
mean I have no idea

00:30:18,560 --> 00:30:26,730
right so that makes it secure no of

00:30:24,150 --> 00:30:28,500
course it doesn't but think about this I

00:30:26,730 --> 00:30:30,990
mean if you do get in you're in a

00:30:28,500 --> 00:30:33,750
hardware protected sandbox so at least

00:30:30,990 --> 00:30:36,630
let's talk about that I mean if you were

00:30:33,750 --> 00:30:38,640
able to break in the hardware is

00:30:36,630 --> 00:30:39,600
protecting the physical server

00:30:38,640 --> 00:30:41,700
underneath you

00:30:39,600 --> 00:30:43,440
that's why virtualization was invented

00:30:41,700 --> 00:30:45,810
in the first place it was to isolate

00:30:43,440 --> 00:30:50,910
services from each other and it's been

00:30:45,810 --> 00:30:52,980
working well at that since the 60s so if

00:30:50,910 --> 00:30:54,840
you're worried about damage or infection

00:30:52,980 --> 00:30:57,060
to the rest of the system that's

00:30:54,840 --> 00:30:59,990
contained by hardware which is the main

00:30:57,060 --> 00:31:03,150
reason for wanting to do this at all

00:30:59,990 --> 00:31:06,110
there's also no shell no other ad hoc

00:31:03,150 --> 00:31:07,820
system access you can't get root X

00:31:06,110 --> 00:31:11,990
get to a terminal because there is no

00:31:07,820 --> 00:31:14,480
one no terminal in there right it has

00:31:11,990 --> 00:31:16,940
minimal attack surface because it's

00:31:14,480 --> 00:31:19,760
really really tiny all little parts your

00:31:16,940 --> 00:31:22,429
serve is explicitly needed or that was

00:31:19,760 --> 00:31:25,010
injected as a driver only those parts

00:31:22,429 --> 00:31:26,770
are in there there's nothing else so

00:31:25,010 --> 00:31:28,730
there are no tools left for the thieves

00:31:26,770 --> 00:31:30,820
everything inside can be randomized

00:31:28,730 --> 00:31:33,710
we're already randomizing stack and heap

00:31:30,820 --> 00:31:37,760
locations you can do a lot more with

00:31:33,710 --> 00:31:40,280
that so that once you get to know how

00:31:37,760 --> 00:31:41,900
one unit kernel works that doesn't

00:31:40,280 --> 00:31:47,510
necessarily translate to how the next

00:31:41,900 --> 00:31:49,549
unit works so somebody said leave no

00:31:47,510 --> 00:31:53,840
room for a level low level language

00:31:49,549 --> 00:31:55,669
below C++ except for assembler and you

00:31:53,840 --> 00:31:58,940
made it we didn't need any other

00:31:55,669 --> 00:32:00,679
language except for assembler and we try

00:31:58,940 --> 00:32:05,510
to use it as little little as possible

00:32:00,679 --> 00:32:06,410
but do we need another language above

00:32:05,510 --> 00:32:12,440
C++

00:32:06,410 --> 00:32:16,130
I find that C++ the new C++ is really

00:32:12,440 --> 00:32:17,780
really good at high level as well so

00:32:16,130 --> 00:32:20,240
we're going to show you what we built on

00:32:17,780 --> 00:32:22,190
top of include lists so we're now

00:32:20,240 --> 00:32:26,299
introducing acorn we're open sourcing

00:32:22,190 --> 00:32:28,130
this this week for this occasion it's a

00:32:26,299 --> 00:32:31,549
web server that we built on top of

00:32:28,130 --> 00:32:33,740
include OS but it also has a C++

00:32:31,549 --> 00:32:36,919
framework for building restful api in a

00:32:33,740 --> 00:32:39,590
very modern way it's inspired by nodejs

00:32:36,919 --> 00:32:41,210
and Express so these JavaScript

00:32:39,590 --> 00:32:43,429
developers that are now running

00:32:41,210 --> 00:32:45,590
server-side code they invented some

00:32:43,429 --> 00:32:47,000
pretty nice techniques it's all async

00:32:45,590 --> 00:32:49,309
and single threaded so it kind of

00:32:47,000 --> 00:32:53,540
resembles our scenarios so we thought

00:32:49,309 --> 00:32:56,360
let's try to do that in C++ so if you

00:32:53,540 --> 00:32:58,250
download ACORN it's a include web

00:32:56,360 --> 00:33:00,500
service it requires you to have

00:32:58,250 --> 00:33:02,990
installed including Wes library but

00:33:00,500 --> 00:33:06,700
there you get a couple of fancy or a

00:33:02,990 --> 00:33:08,510
couple of simple web pages let's say so

00:33:06,700 --> 00:33:10,549
the first one here

00:33:08,510 --> 00:33:15,679
you know we serve static content from a

00:33:10,549 --> 00:33:18,080
fat filesystem that's the basic case it

00:33:15,679 --> 00:33:19,760
can be served from a memory disk or that

00:33:18,080 --> 00:33:21,530
lives inside the elf binary or

00:33:19,760 --> 00:33:24,500
it can be served from an external block

00:33:21,530 --> 00:33:25,820
device there's also a demo of something

00:33:24,500 --> 00:33:29,870
more interactive where you can post

00:33:25,820 --> 00:33:34,070
stuff so this is a Ajax application

00:33:29,870 --> 00:33:36,190
using kind of a modern front-end and

00:33:34,070 --> 00:33:38,900
then there's a little repository of

00:33:36,190 --> 00:33:40,940
repository of books so this just shows

00:33:38,900 --> 00:33:43,670
you also that you know we have an

00:33:40,940 --> 00:33:46,460
abstraction that allows you to just list

00:33:43,670 --> 00:33:50,240
the directory contents and show that as

00:33:46,460 --> 00:33:55,220
HTML so that's great it's a web server

00:33:50,240 --> 00:33:56,960
and then somebody said this morning C++

00:33:55,220 --> 00:34:01,390
is not the language for putting up a

00:33:56,960 --> 00:34:07,580
simple web page okay message received so

00:34:01,390 --> 00:34:11,570
how about a fancy web page and we have

00:34:07,580 --> 00:34:14,750
that how about a dashboard with live CPU

00:34:11,570 --> 00:34:17,659
stats and live profiling of the code

00:34:14,750 --> 00:34:21,370
that's running the web page does that

00:34:17,659 --> 00:34:25,399
qualify it's surprisingly easy with C++

00:34:21,370 --> 00:34:26,960
so here's the dashboard now the reason

00:34:25,399 --> 00:34:29,330
why I'm showing you this it's not

00:34:26,960 --> 00:34:31,310
because I think all units should have

00:34:29,330 --> 00:34:36,080
this dashboard but it's a really cool

00:34:31,310 --> 00:34:38,840
useful tool so what you see here that's

00:34:36,080 --> 00:34:41,659
a live interactive CPU graph it will

00:34:38,840 --> 00:34:44,300
update nicely and if you put some load

00:34:41,659 --> 00:34:46,580
on there you'll see the load so this

00:34:44,300 --> 00:34:48,919
particular picture is taken from ten

00:34:46,580 --> 00:34:52,179
thousand HTTP requests you know it

00:34:48,919 --> 00:34:55,310
doesn't break a sweat it's it's fine

00:34:52,179 --> 00:34:59,090
this is a memory map it looks all red

00:34:55,310 --> 00:35:01,160
that's because all of memory or almost

00:34:59,090 --> 00:35:03,590
all of memory goes to your application

00:35:01,160 --> 00:35:05,240
and not to the operating system so this

00:35:03,590 --> 00:35:08,000
is also an interactive memory map

00:35:05,240 --> 00:35:09,470
because somebody at cpp cast asked me if

00:35:08,000 --> 00:35:10,190
we had a memory map and I thought oh my

00:35:09,470 --> 00:35:12,740
goodness

00:35:10,190 --> 00:35:14,930
we should probably have one so this is a

00:35:12,740 --> 00:35:18,800
STL data structure that map's all of

00:35:14,930 --> 00:35:20,690
memory so you can ask the operating

00:35:18,800 --> 00:35:24,140
system what does the memory map look

00:35:20,690 --> 00:35:26,870
like and then it's easy to then

00:35:24,140 --> 00:35:29,300
serialize that and now it's also easy to

00:35:26,870 --> 00:35:29,710
provide a restful api endpoint for that

00:35:29,300 --> 00:35:32,870
data

00:35:29,710 --> 00:35:33,650
this is tcp status connection shows you

00:35:32,870 --> 00:35:36,800
who's trying

00:35:33,650 --> 00:35:38,840
to break into your server if they get in

00:35:36,800 --> 00:35:45,230
you know think of the damage they can do

00:35:38,840 --> 00:35:47,390
with no shell well so this is another

00:35:45,230 --> 00:35:50,390
thing look at the rights the left side

00:35:47,390 --> 00:35:52,660
of the screen here you have stats so

00:35:50,390 --> 00:35:56,120
these are centrally located statistics

00:35:52,660 --> 00:35:58,760
that anyone can or that your service or

00:35:56,120 --> 00:36:01,550
the operating system any lambda anything

00:35:58,760 --> 00:36:04,370
can can say I want to haven't use that

00:36:01,550 --> 00:36:06,770
and you give it a name and in return you

00:36:04,370 --> 00:36:10,070
get a reference to a counter that you

00:36:06,770 --> 00:36:13,010
can decrement or increment and since

00:36:10,070 --> 00:36:15,680
these are centrally located you can also

00:36:13,010 --> 00:36:18,290
easily serialize all of them so if your

00:36:15,680 --> 00:36:20,930
application now says okay I injected

00:36:18,290 --> 00:36:22,910
this little IP filter as a lambda or as

00:36:20,930 --> 00:36:24,710
a delegate that goes between the

00:36:22,910 --> 00:36:25,940
ethernet and arp four layer you know

00:36:24,710 --> 00:36:28,030
that can have its own stats as well

00:36:25,940 --> 00:36:30,740
telling you how many packets it dropped

00:36:28,030 --> 00:36:32,480
of course maybe the most interesting

00:36:30,740 --> 00:36:36,680
thing is live stack sampling that's

00:36:32,480 --> 00:36:38,450
something you get from running in a

00:36:36,680 --> 00:36:41,180
single threaded environment with only

00:36:38,450 --> 00:36:43,880
one stack so what we're doing here is

00:36:41,180 --> 00:36:45,350
that we have an interrupt timer we have

00:36:43,880 --> 00:36:48,200
a timer interrupt going every

00:36:45,350 --> 00:36:49,700
millisecond and the timer interrupt is

00:36:48,200 --> 00:36:52,220
just a function called figured by the

00:36:49,700 --> 00:36:54,140
cpu so it will go on the top of the same

00:36:52,220 --> 00:36:56,690
stack that's already there so all you

00:36:54,140 --> 00:36:58,370
have to do is just look down at the

00:36:56,690 --> 00:37:01,090
bottom of the stack and see what was the

00:36:58,370 --> 00:37:03,590
previous function so we record that

00:37:01,090 --> 00:37:05,030
thousand times per second it's not

00:37:03,590 --> 00:37:08,810
expensive or at least it doesn't show up

00:37:05,030 --> 00:37:10,670
in the in the stack sampling and we

00:37:08,810 --> 00:37:13,370
record that data so all we do is we

00:37:10,670 --> 00:37:15,740
record the function address in a data

00:37:13,370 --> 00:37:18,530
structure and then afterwards when you

00:37:15,740 --> 00:37:19,910
want to extract that data to to look at

00:37:18,530 --> 00:37:21,650
it in a datastore data structure to

00:37:19,910 --> 00:37:25,070
serialize it then you find the name of

00:37:21,650 --> 00:37:27,380
the function so this is live its heat

00:37:25,070 --> 00:37:30,440
mapped in a way so that if you do run a

00:37:27,380 --> 00:37:33,410
lot of load on here you will see which

00:37:30,440 --> 00:37:36,770
function is the bad guy that's found the

00:37:33,410 --> 00:37:39,350
most times we also do the same with logs

00:37:36,770 --> 00:37:41,030
this is where we routed the standard

00:37:39,350 --> 00:37:42,920
output from the from the hello world

00:37:41,030 --> 00:37:45,200
example or right after that I show you

00:37:42,920 --> 00:37:47,210
we could route it anywhere now we're at

00:37:45,200 --> 00:37:50,330
into a in memory

00:37:47,210 --> 00:37:52,970
in buffer and then we have a timer again

00:37:50,330 --> 00:37:57,980
that just harvests this data and puts it

00:37:52,970 --> 00:37:59,630
on a restful endpoint so yeah this just

00:37:57,980 --> 00:38:01,280
shows you that you can also access the

00:37:59,630 --> 00:38:02,690
data directly and obviously the

00:38:01,280 --> 00:38:06,010
dashboard is just a way to demonstrate

00:38:02,690 --> 00:38:10,700
how you can expose parts of this

00:38:06,010 --> 00:38:12,470
machinery easily over the web and we

00:38:10,700 --> 00:38:14,330
composed all of this into a dashboard

00:38:12,470 --> 00:38:16,609
but of course they are all individual

00:38:14,330 --> 00:38:19,220
routes the operating system doesn't

00:38:16,609 --> 00:38:22,940
expose anything this is just something

00:38:19,220 --> 00:38:24,800
the application is doing but we have to

00:38:22,940 --> 00:38:26,410
show you how we did it we have some nice

00:38:24,800 --> 00:38:30,710
abstractions that we took from

00:38:26,410 --> 00:38:33,820
JavaScript and nodejs so this is how you

00:38:30,710 --> 00:38:36,770
make one of these routes so our route

00:38:33,820 --> 00:38:39,650
that's essentially a way to tie in some

00:38:36,770 --> 00:38:42,320
functionality to a certain type of URL

00:38:39,650 --> 00:38:45,440
or actually to a certain path in the URL

00:38:42,320 --> 00:38:47,869
let's so let's just view URLs as an

00:38:45,440 --> 00:38:50,150
abstract tree structure and then you can

00:38:47,869 --> 00:38:54,800
tie functionality into certain parts of

00:38:50,150 --> 00:38:57,740
that tree structure so in this case yeah

00:38:54,800 --> 00:39:00,170
so this is kind of a reg expanding based

00:38:57,740 --> 00:39:03,470
mini language that's very popular for

00:39:00,170 --> 00:39:06,740
web applications to express routes so

00:39:03,470 --> 00:39:09,830
it's essentially this language gets

00:39:06,740 --> 00:39:11,839
parsed by standard reg X and it produces

00:39:09,830 --> 00:39:15,230
a new reg X that you actually use to

00:39:11,839 --> 00:39:16,910
match the incoming requests but the

00:39:15,230 --> 00:39:20,720
convenience of this is that now I'm

00:39:16,910 --> 00:39:22,369
again I can say I want serve this I want

00:39:20,720 --> 00:39:24,849
to run this functionality whenever

00:39:22,369 --> 00:39:27,609
somebody goes to API slash users slash

00:39:24,849 --> 00:39:32,770
colon ID and you can actually get this

00:39:27,609 --> 00:39:38,270
ID part of the URL by value and by name

00:39:32,770 --> 00:39:40,660
so so now we so what's happened is that

00:39:38,270 --> 00:39:43,130
behind the scenes this router it's

00:39:40,660 --> 00:39:45,410
parsed the URL and it found out that

00:39:43,130 --> 00:39:47,480
okay it matches one of the it matches

00:39:45,410 --> 00:39:49,130
this pattern so let's extract the idea

00:39:47,480 --> 00:39:53,780
from there and provide it to you by

00:39:49,130 --> 00:39:56,540
value through the request object this is

00:39:53,780 --> 00:39:58,910
a default route so we use the same kind

00:39:56,540 --> 00:40:00,530
of principle but in this case we say

00:39:58,910 --> 00:40:01,070
okay for just slash it means you go to

00:40:00,530 --> 00:40:05,120
just

00:40:01,070 --> 00:40:06,770
mydomain.com / nothing you know so if

00:40:05,120 --> 00:40:08,780
that's what you're going for then in

00:40:06,770 --> 00:40:11,840
this case we will just look at the file

00:40:08,780 --> 00:40:14,690
system and we will try to find which we

00:40:11,840 --> 00:40:17,510
will actually just serve index.html from

00:40:14,690 --> 00:40:22,900
the slash public / index.html on the

00:40:17,510 --> 00:40:28,610
file system the next thing is middleware

00:40:22,900 --> 00:40:31,220
so middleware is a way to pre-process or

00:40:28,610 --> 00:40:33,980
to kind of get to pre-process the

00:40:31,220 --> 00:40:37,100
requests when they're coming in so it's

00:40:33,980 --> 00:40:40,190
essentially a stack of functions or just

00:40:37,100 --> 00:40:43,190
a list of functions that the request has

00:40:40,190 --> 00:40:47,930
to pass through in order to reach up to

00:40:43,190 --> 00:40:51,230
the routes so one typical example of

00:40:47,930 --> 00:40:55,550
middleware is JSON parsing so say you're

00:40:51,230 --> 00:40:57,740
having a ajax web application the user

00:40:55,550 --> 00:41:00,670
will typically give you data in form in

00:40:57,740 --> 00:41:03,620
the form of JSON now when you want to

00:41:00,670 --> 00:41:05,540
work on this data you just want it to be

00:41:03,620 --> 00:41:07,880
parsed for you you don't want to have to

00:41:05,540 --> 00:41:12,020
deal with that so usually you just apply

00:41:07,880 --> 00:41:13,940
middleware so that you know whenever the

00:41:12,020 --> 00:41:17,060
request is coming in the JSON is already

00:41:13,940 --> 00:41:19,670
parsed so this just checks if the

00:41:17,060 --> 00:41:22,400
content type of the request on HTTP

00:41:19,670 --> 00:41:24,770
level if it's Jason well then you know

00:41:22,400 --> 00:41:27,350
we parse the data and we attach the

00:41:24,770 --> 00:41:29,950
parse JSON data to the request so that

00:41:27,350 --> 00:41:32,540
when it comes up to the very lazy

00:41:29,950 --> 00:41:38,210
application programmer writing the route

00:41:32,540 --> 00:41:42,770
the JSON is already parsed yeah exactly

00:41:38,210 --> 00:41:46,940
what I said and this last part this is a

00:41:42,770 --> 00:41:48,410
async pattern that we have to use so I'm

00:41:46,940 --> 00:41:50,180
calling next here you see that gets

00:41:48,410 --> 00:41:53,600
passed in and this is because of the

00:41:50,180 --> 00:41:56,060
async nature of these of our system

00:41:53,600 --> 00:41:59,900
everything is I sync so you know if you

00:41:56,060 --> 00:42:02,390
inside of this middleware you want to go

00:41:59,900 --> 00:42:04,190
asynchronously to the file system and

00:42:02,390 --> 00:42:06,080
fetch something then you have to wait

00:42:04,190 --> 00:42:07,550
and then you want to call next to call

00:42:06,080 --> 00:42:09,560
the next middleware in the stack you

00:42:07,550 --> 00:42:12,260
know for that reason these this

00:42:09,560 --> 00:42:14,660
middleware has to live in resident

00:42:12,260 --> 00:42:16,760
memory so you get past the

00:42:14,660 --> 00:42:19,070
in this is some let's just say it's some

00:42:16,760 --> 00:42:20,210
basic magic going on you don't have to

00:42:19,070 --> 00:42:22,490
worry about it unless you're

00:42:20,210 --> 00:42:24,590
implementing your own middleware but we

00:42:22,490 --> 00:42:27,560
have some ready-made middleware there

00:42:24,590 --> 00:42:29,600
was a JSON parser we have we also have

00:42:27,560 --> 00:42:31,550
the thing that makes the directory

00:42:29,600 --> 00:42:33,620
listing of the contents of your

00:42:31,550 --> 00:42:35,270
filesystem which is pretty cool so you

00:42:33,620 --> 00:42:37,760
can replace the contents with your own

00:42:35,270 --> 00:42:40,570
favorite content and you can use that as

00:42:37,760 --> 00:42:43,220
a way to list the directory contents and

00:42:40,570 --> 00:42:47,150
so when you apply middleware you just

00:42:43,220 --> 00:42:49,700
say where you want to use it and then

00:42:47,150 --> 00:42:51,590
you give it the middleware there's a

00:42:49,700 --> 00:42:53,480
cookie parser parsing on all the cookies

00:42:51,590 --> 00:42:55,970
that might come on request so that you

00:42:53,480 --> 00:42:59,480
can have a web application using cookies

00:42:55,970 --> 00:43:02,810
etc and I know you will worry about

00:42:59,480 --> 00:43:04,610
performance so let me just remind you

00:43:02,810 --> 00:43:08,360
that virtual machines aren't faster than

00:43:04,610 --> 00:43:10,910
bare metal they're ideally or optimally

00:43:08,360 --> 00:43:14,120
they're the same right so if you just

00:43:10,910 --> 00:43:15,980
run decimal compute as moles of Pi you

00:43:14,120 --> 00:43:19,010
can probably get almost identical

00:43:15,980 --> 00:43:21,290
performance but for i/o you know there's

00:43:19,010 --> 00:43:24,440
it's a little bit more wayward so our

00:43:21,290 --> 00:43:26,960
motivation for this is to make an

00:43:24,440 --> 00:43:30,440
architecture where it's easy to write

00:43:26,960 --> 00:43:34,040
thousands of microservices and that you

00:43:30,440 --> 00:43:37,310
if you want concurrency at a large level

00:43:34,040 --> 00:43:39,740
you can scale up with thousands of these

00:43:37,310 --> 00:43:42,470
little virtual machines now that being

00:43:39,740 --> 00:43:46,460
said of course I'm happy to say that we

00:43:42,470 --> 00:43:49,750
do beat a party as a web server on this

00:43:46,460 --> 00:43:52,370
little acorn that we're introducing so

00:43:49,750 --> 00:43:55,790
we did some benchmarking where we put a

00:43:52,370 --> 00:43:59,540
party web server inside of Ubuntu turns

00:43:55,790 --> 00:44:02,690
out we are 11% faster and that's for a

00:43:59,540 --> 00:44:05,630
proof-of-concept application our HTTP

00:44:02,690 --> 00:44:08,030
parser is using a lot of string copying

00:44:05,630 --> 00:44:11,600
it's pretty straightforward C++ with no

00:44:08,030 --> 00:44:13,190
optimization can be optimized a lot so

00:44:11,600 --> 00:44:16,010
there's a lot of more stuff we can do

00:44:13,190 --> 00:44:18,620
but we're already faster which is just

00:44:16,010 --> 00:44:21,110
due to the simplistic design I think and

00:44:18,620 --> 00:44:23,540
it's also 79 percent faster than node

00:44:21,110 --> 00:44:25,250
you might say well obviously you'd be no

00:44:23,540 --> 00:44:27,390
because that's written in JavaScript

00:44:25,250 --> 00:44:33,420
well most of it is

00:44:27,390 --> 00:44:35,970
e or C++ javascript is used if I mean if

00:44:33,420 --> 00:44:37,260
your application code is very heavy then

00:44:35,970 --> 00:44:40,140
yes there will be a lot of JavaScript

00:44:37,260 --> 00:44:45,390
running but for just serving a static

00:44:40,140 --> 00:44:47,609
file mostly it's C so the HTTP parts are

00:44:45,390 --> 00:44:50,460
in no that's pure C and it's very ugly C

00:44:47,609 --> 00:44:52,559
so we actually ported that one into

00:44:50,460 --> 00:44:54,539
include OS but then we saw a boost up

00:44:52,559 --> 00:44:57,029
down one so you know we probably want to

00:44:54,539 --> 00:44:59,970
do that instead so I'm happy with the

00:44:57,029 --> 00:45:02,309
results so far it's faster to run

00:44:59,970 --> 00:45:06,809
include your application on include OS

00:45:02,309 --> 00:45:08,960
than it is to run it on Ubuntu to deploy

00:45:06,809 --> 00:45:12,420
in the cloud I don't know if that's

00:45:08,960 --> 00:45:14,309
scenario you are that's very useful to

00:45:12,420 --> 00:45:16,349
you but it's incredibly useful for us

00:45:14,309 --> 00:45:19,650
and that's kind of the audience we're

00:45:16,349 --> 00:45:22,200
targeting primarily and secondarily IOT

00:45:19,650 --> 00:45:25,099
so I just want to show you that these

00:45:22,200 --> 00:45:28,829
include OS instances can easily be

00:45:25,099 --> 00:45:32,900
uploaded and booted on OpenStack which

00:45:28,829 --> 00:45:35,970
is the most deployed cloud architecture

00:45:32,900 --> 00:45:38,190
it's the the most common way for

00:45:35,970 --> 00:45:42,299
business to get like their own private

00:45:38,190 --> 00:45:44,400
cloud so what you do is say that you

00:45:42,299 --> 00:45:46,769
want to create the image so you upload

00:45:44,400 --> 00:45:50,279
this image that just the single make

00:45:46,769 --> 00:45:53,039
command from include OS produced and

00:45:50,279 --> 00:45:54,869
then you say boot the image and what

00:45:53,039 --> 00:45:57,390
happens is that you get an IP in return

00:45:54,869 --> 00:46:03,450
because include OS will get an IP from

00:45:57,390 --> 00:46:06,630
DHCP and you know it will just serve web

00:46:03,450 --> 00:46:09,319
content from there we'll be adding

00:46:06,630 --> 00:46:12,150
support for all the big cloud vendors

00:46:09,319 --> 00:46:15,059
gradually OpenStack is just the easiest

00:46:12,150 --> 00:46:17,579
one to work with because it's open so

00:46:15,059 --> 00:46:21,269
but eventually will run on all of them I

00:46:17,579 --> 00:46:25,410
think it's not going to be that long so

00:46:21,269 --> 00:46:27,930
the status is we want to reach 1.0 but

00:46:25,410 --> 00:46:30,599
you know that communicates that we have

00:46:27,930 --> 00:46:32,789
a stable API now I showed you a lot of

00:46:30,599 --> 00:46:34,680
things I showed you include our score

00:46:32,789 --> 00:46:36,900
and then I showed you this web

00:46:34,680 --> 00:46:41,089
application framework very briefly on

00:46:36,900 --> 00:46:43,770
top of that so I think

00:46:41,089 --> 00:46:46,800
we want to I think where we can have a

00:46:43,770 --> 00:46:49,680
production ready include away score by

00:46:46,800 --> 00:46:52,650
the end of the year but then whether or

00:46:49,680 --> 00:46:55,020
not this the API is stable and you know

00:46:52,650 --> 00:46:57,210
decided that really depends on what kind

00:46:55,020 --> 00:46:59,730
of feedback we're getting so if you're

00:46:57,210 --> 00:47:01,560
at all interested in this please let us

00:46:59,730 --> 00:47:03,810
know how things should have been done

00:47:01,560 --> 00:47:06,150
how we did everything wrong how we

00:47:03,810 --> 00:47:08,790
didn't do sufficiently beautiful c++

00:47:06,150 --> 00:47:11,190
here and there you guys are the c++

00:47:08,790 --> 00:47:14,430
experts so we really want to invite you

00:47:11,190 --> 00:47:18,810
to come and just voice your opinions we

00:47:14,430 --> 00:47:22,339
can improve if you help us so acorn is

00:47:18,810 --> 00:47:25,530
open source and alpha today or tomorrow

00:47:22,339 --> 00:47:28,280
what we're missing is TLS I mean

00:47:25,530 --> 00:47:31,619
transport layer security for encrypted

00:47:28,280 --> 00:47:37,220
HTTP connections we're going to add

00:47:31,619 --> 00:47:40,079
POSIX and multi architecture support and

00:47:37,220 --> 00:47:43,020
then we need more tooling but we have

00:47:40,079 --> 00:47:47,160
there's a project by EMC that was

00:47:43,020 --> 00:47:49,440
recently acquired by Dell that actually

00:47:47,160 --> 00:47:52,020
you know it makes it pretty easy to

00:47:49,440 --> 00:47:54,450
deploy lots of different unique animal

00:47:52,020 --> 00:47:58,109
projects on lots of different platforms

00:47:54,450 --> 00:48:01,010
so we integrated with them and this is

00:47:58,109 --> 00:48:03,900
going to be a tool you can use to deploy

00:48:01,010 --> 00:48:08,099
unicorns everywhere we need package

00:48:03,900 --> 00:48:10,970
manager ce mec builds etc so this is

00:48:08,099 --> 00:48:14,790
what you can expect in the near future

00:48:10,970 --> 00:48:19,109
so to recap virtual machines are not

00:48:14,790 --> 00:48:22,319
heavy operating systems are and include

00:48:19,109 --> 00:48:25,130
OS is faster and more efficient and more

00:48:22,319 --> 00:48:28,380
secure for single purpose applications

00:48:25,130 --> 00:48:30,540
C++ has turned out to be fantastic for

00:48:28,380 --> 00:48:34,880
both the low level and the high level

00:48:30,540 --> 00:48:38,160
stuff we've been doing please contribute

00:48:34,880 --> 00:48:39,780
follow us on Twitter we'll notify you of

00:48:38,160 --> 00:48:43,500
what's happening there there will be a

00:48:39,780 --> 00:48:45,930
demo and in an open content session that

00:48:43,500 --> 00:48:48,930
shows you an IRC server running on

00:48:45,930 --> 00:48:52,030
include OS it will show you some code

00:48:48,930 --> 00:48:54,670
and will show you something live so get

00:48:52,030 --> 00:48:58,150
to that if you're interested on Thursday

00:48:54,670 --> 00:49:01,300
but really give me expert advice you

00:48:58,150 --> 00:49:04,050
guys our language experts I'm not so

00:49:01,300 --> 00:49:08,140
please tell me what we could improve and

00:49:04,050 --> 00:49:11,320
we will be much we'll be very happy for

00:49:08,140 --> 00:49:28,020
that also focus on github chat with us

00:49:11,320 --> 00:49:34,750
on jitter thanks any questions yeah ah

00:49:28,020 --> 00:49:38,260
that was yeah that was super hard yeah

00:49:34,750 --> 00:49:40,000
oh yeah sorry he asked how did we make

00:49:38,260 --> 00:49:45,910
the standard library available inside

00:49:40,000 --> 00:49:48,340
the UD kernel so well it's kind of

00:49:45,910 --> 00:49:51,970
involved you have to build well I

00:49:48,340 --> 00:49:55,150
started out having to build a custom GCC

00:49:51,970 --> 00:49:57,730
compiler like a custom designated tool

00:49:55,150 --> 00:50:01,600
chain just for building for this

00:49:57,730 --> 00:50:04,660
particular platform and then I was able

00:50:01,600 --> 00:50:08,140
to get the C library which we're using a

00:50:04,660 --> 00:50:10,090
new Lib in there and the C library new

00:50:08,140 --> 00:50:11,980
Libet just has a few system calls so

00:50:10,090 --> 00:50:14,470
it's that it's an implementation that's

00:50:11,980 --> 00:50:16,450
meant to make it easy for you to you

00:50:14,470 --> 00:50:19,900
know provide the system calls underneath

00:50:16,450 --> 00:50:22,030
so that was that was not so hard I mean

00:50:19,900 --> 00:50:23,980
making the cross compiler thing it's a

00:50:22,030 --> 00:50:26,530
lot of work but you know you have pretty

00:50:23,980 --> 00:50:29,560
decent guides on on sites like always

00:50:26,530 --> 00:50:32,920
they have dual org now to get the c++

00:50:29,560 --> 00:50:35,230
library was much harder so we ended up

00:50:32,920 --> 00:50:37,600
dropping the GCC one because it was so

00:50:35,230 --> 00:50:40,180
hard to just get that library out of the

00:50:37,600 --> 00:50:43,420
whole rest of the things so we ended up

00:50:40,180 --> 00:50:45,250
doing the Lib C++ from LVM turn out when

00:50:43,420 --> 00:50:47,830
we went there it was much easier to just

00:50:45,250 --> 00:50:49,450
get a clean compilation for just 32-bit

00:50:47,830 --> 00:50:53,050
architecture which is what we're

00:50:49,450 --> 00:50:55,750
currently using so yeah so essentially

00:50:53,050 --> 00:50:59,740
when we switch to LLVM it was not that

00:50:55,750 --> 00:51:01,600
hard but still we do provide ready-mades

00:50:59,740 --> 00:51:03,700
for this because takes a long time to

00:51:01,600 --> 00:51:05,980
build all these things so we provide

00:51:03,700 --> 00:51:09,400
binaries

00:51:05,980 --> 00:51:11,800
the C library C++ library and then you

00:51:09,400 --> 00:51:20,100
use those to build the include OS

00:51:11,800 --> 00:51:20,100
libraries on top of that yeah yeah ah

00:51:22,350 --> 00:51:27,420
interesting so the question was Internet

00:51:25,270 --> 00:51:29,440
of Things can I see this going to

00:51:27,420 --> 00:51:34,780
microcontrollers well I can certainly

00:51:29,440 --> 00:51:37,210
see going to arm and raspberry PI's so

00:51:34,780 --> 00:51:39,490
and I mean yes Internet of Things

00:51:37,210 --> 00:51:40,420
usually you'll have a small device with

00:51:39,490 --> 00:51:42,640
a single purpose

00:51:40,420 --> 00:51:44,890
so in principle that fits now

00:51:42,640 --> 00:51:47,530
microcurrent microcontroller is very

00:51:44,890 --> 00:51:49,690
very memory constrained and while we try

00:51:47,530 --> 00:51:51,730
to be very minimal when I started the

00:51:49,690 --> 00:51:53,350
project we looked at a lot of for

00:51:51,730 --> 00:51:57,430
example we looked at IP stacks from

00:51:53,350 --> 00:51:59,410
these minimal IOT operating systems and

00:51:57,430 --> 00:52:02,140
it turned out that they were usually

00:51:59,410 --> 00:52:05,050
designed when you design for that much

00:52:02,140 --> 00:52:07,119
that little memory I turned out to be

00:52:05,050 --> 00:52:09,369
that they have to sacrifice performance

00:52:07,119 --> 00:52:11,380
so I'm guessing that you know if you

00:52:09,369 --> 00:52:14,080
have a reasonable amount of working

00:52:11,380 --> 00:52:19,240
memory you know then you could port

00:52:14,080 --> 00:52:19,540
include OS over there yeah how do we do

00:52:19,240 --> 00:52:22,300
bug

00:52:19,540 --> 00:52:25,300
ah excellent question how do we debug

00:52:22,300 --> 00:52:29,619
it's we use gdb just like you would do

00:52:25,300 --> 00:52:33,970
bug a normal process so that's so

00:52:29,619 --> 00:52:35,350
debugging um so the gdb can and you can

00:52:33,970 --> 00:52:36,580
probably use other debuggers as well I

00:52:35,350 --> 00:52:39,730
just haven't needed it

00:52:36,580 --> 00:52:42,609
so you just chemo which is the process

00:52:39,730 --> 00:52:43,869
that controls the i/o for the virtual

00:52:42,609 --> 00:52:45,160
machine and so essentially when you

00:52:43,869 --> 00:52:46,930
build a virtual machine what you'll see

00:52:45,160 --> 00:52:49,630
in your list of processes that's a key

00:52:46,930 --> 00:52:51,940
mu process and it's it's communicating

00:52:49,630 --> 00:52:55,750
through a kernel module with with the

00:52:51,940 --> 00:52:58,300
guest so it can expose a port so that

00:52:55,750 --> 00:53:01,300
it's it acts as a debugging server so

00:52:58,300 --> 00:53:04,180
that gdb connects to that server it will

00:53:01,300 --> 00:53:05,950
get I guess what it needs is like the

00:53:04,180 --> 00:53:09,250
instruction pointer the location of

00:53:05,950 --> 00:53:11,020
memory etc and then you can just provide

00:53:09,250 --> 00:53:12,910
the binary because there's an elf binary

00:53:11,020 --> 00:53:14,350
right so you provide a binary with or

00:53:12,910 --> 00:53:16,480
just the

00:53:14,350 --> 00:53:18,820
the symbol tables on the other side and

00:53:16,480 --> 00:53:21,040
put student two together so you can get

00:53:18,820 --> 00:53:23,530
step wise you know walk you through

00:53:21,040 --> 00:53:34,360
exactly the code while is running in the

00:53:23,530 --> 00:53:36,340
inside the virtual machine so yeah so if

00:53:34,360 --> 00:53:41,140
the user code does not yield what do I

00:53:36,340 --> 00:53:45,550
do well there is no I mean everything is

00:53:41,140 --> 00:53:47,860
I sync so currently all you do I mean if

00:53:45,550 --> 00:53:50,470
you if you just run a for loop or you

00:53:47,860 --> 00:53:53,860
run a computation of Pi forever well

00:53:50,470 --> 00:53:56,860
then that's what the thread is doing so

00:53:53,860 --> 00:54:00,280
yes then everything will be unless you

00:53:56,860 --> 00:54:02,800
implement preemptive interrupt handlers

00:54:00,280 --> 00:54:04,900
like a stack sampler we have that's a

00:54:02,800 --> 00:54:06,910
pre-emptive interrupt Handler so that

00:54:04,900 --> 00:54:09,610
will do a proper interrupt and it will

00:54:06,910 --> 00:54:11,440
actually do work so I can't but but you

00:54:09,610 --> 00:54:13,930
know then you have to take care of

00:54:11,440 --> 00:54:19,180
saving your context and then you can

00:54:13,930 --> 00:54:21,670
switch back so yes so currently we want

00:54:19,180 --> 00:54:23,440
to just show you how much you can do I

00:54:21,670 --> 00:54:25,720
mean you can have several protocols

00:54:23,440 --> 00:54:27,970
listening on several different different

00:54:25,720 --> 00:54:30,760
ports and the thing is that network

00:54:27,970 --> 00:54:32,980
traffic is kind of naturally scheduled

00:54:30,760 --> 00:54:37,180
because everything is already chunked up

00:54:32,980 --> 00:54:39,010
into packets right so we I felt you know

00:54:37,180 --> 00:54:42,010
I was surprised at how much you could do

00:54:39,010 --> 00:54:44,650
with this model but yes we will add the

00:54:42,010 --> 00:54:46,390
normal context switching threading so

00:54:44,650 --> 00:54:49,240
that we're POSIX compliant and you can

00:54:46,390 --> 00:55:03,400
run whatever and also do blocking calls

00:54:49,240 --> 00:55:06,370
etc yeah other questions yes all right

00:55:03,400 --> 00:55:09,010
so uh and what was the advantages of

00:55:06,370 --> 00:55:11,950
putting all the device drivers and stuff

00:55:09,010 --> 00:55:16,030
like that into the virtual machines as

00:55:11,950 --> 00:55:17,590
opposed to paravirtualization so if I

00:55:16,030 --> 00:55:20,980
understand the question correctly yeah

00:55:17,590 --> 00:55:23,490
so paravirtualization that's kind of

00:55:20,980 --> 00:55:27,550
well not to be rude but it's a band-aid

00:55:23,490 --> 00:55:28,000
for for creating virtual machines before

00:55:27,550 --> 00:55:30,910
the C

00:55:28,000 --> 00:55:35,230
use actually had the ability to do this

00:55:30,910 --> 00:55:37,810
virtualization themselves I mean so well

00:55:35,230 --> 00:55:39,670
so Xen hypervisor is very popular and

00:55:37,810 --> 00:55:42,190
very good they have this pair of virtual

00:55:39,670 --> 00:55:45,340
mode where essentially your code is just

00:55:42,190 --> 00:55:47,680
user space code so in order to run

00:55:45,340 --> 00:55:49,120
Windows or Linux on top of there which

00:55:47,680 --> 00:55:51,300
is what they wanted for example when

00:55:49,120 --> 00:55:53,320
Amazon started out they were very early

00:55:51,300 --> 00:55:56,020
promoters of this virtualization

00:55:53,320 --> 00:55:59,050
technique so then you have to modify the

00:55:56,020 --> 00:56:02,200
guest so you modify the guest so that

00:55:59,050 --> 00:56:03,670
the operating system isn't actually

00:56:02,200 --> 00:56:05,950
dealing with hardware it's dealing with

00:56:03,670 --> 00:56:08,620
a thin software layer so for me that's

00:56:05,950 --> 00:56:12,550
just the security vulnerability that

00:56:08,620 --> 00:56:16,030
just isn't necessary so to be honest I

00:56:12,550 --> 00:56:19,180
just thought you know that I was looking

00:56:16,030 --> 00:56:21,100
for the perfect way to isolate services

00:56:19,180 --> 00:56:23,320
from one another because cloud is kind

00:56:21,100 --> 00:56:25,780
of our context so I want your server

00:56:23,320 --> 00:56:27,910
service to run on my hardware as well as

00:56:25,780 --> 00:56:30,430
your service so so I just thought well

00:56:27,910 --> 00:56:32,320
the most secure in my mind is the

00:56:30,430 --> 00:56:34,960
isolation mechanism that doesn't share a

00:56:32,320 --> 00:56:37,360
single byte of code so that's I guess

00:56:34,960 --> 00:56:40,510
that's the advantage of doing it like

00:56:37,360 --> 00:56:43,870
that and yes as a as a result you have

00:56:40,510 --> 00:56:46,180
to have like PCI interface etc now I

00:56:43,870 --> 00:56:47,980
think later in the week on Thursday

00:56:46,180 --> 00:56:50,170
we'll hear about a new hypervisor

00:56:47,980 --> 00:56:52,300
project where you know you can probably

00:56:50,170 --> 00:56:56,320
find interfaces where you can throw away

00:56:52,300 --> 00:56:57,790
the PCI and all that and make simpler

00:56:56,320 --> 00:57:00,340
interfaces between guest and host

00:56:57,790 --> 00:57:03,700
without having to go through all these

00:57:00,340 --> 00:57:06,940
legacy interfaces but still keeping

00:57:03,700 --> 00:57:09,850
hardware virtualization so what did it

00:57:06,940 --> 00:57:22,090
answer your question ok thanks anything

00:57:09,850 --> 00:57:26,920
else ok yeah sure doing without the host

00:57:22,090 --> 00:57:30,910
so so you mean running ah this directly

00:57:26,920 --> 00:57:35,380
in userspace Oh a bare-metal well I

00:57:30,910 --> 00:57:38,590
haven't but I did oh sorry

00:57:35,380 --> 00:57:39,910
have I tried to run include OS directly

00:57:38,590 --> 00:57:40,559
on physical hardware is that where

00:57:39,910 --> 00:57:42,809
you're asking right

00:57:40,559 --> 00:57:44,519
yeah no I haven't tried to run include

00:57:42,809 --> 00:57:48,119
us directly on physical hardware but I

00:57:44,519 --> 00:57:53,670
had some experiment projects that I did

00:57:48,119 --> 00:57:56,400
before that which kind of was precursor

00:57:53,670 --> 00:57:58,739
to include us that booted up on hardware

00:57:56,400 --> 00:58:02,249
and everything behaved exactly like it

00:57:58,739 --> 00:58:05,579
would in chemo so you know it will boot

00:58:02,249 --> 00:58:08,009
on hardware pretty confident or I am

00:58:05,579 --> 00:58:10,199
confident because the point is that you

00:58:08,009 --> 00:58:11,369
are running directly on Hardware you

00:58:10,199 --> 00:58:14,160
know you're just running in a

00:58:11,369 --> 00:58:16,259
virtualized context so we probably might

00:58:14,160 --> 00:58:18,180
have to do some adjustments to I mean we

00:58:16,259 --> 00:58:19,589
definitely need to add physical device

00:58:18,180 --> 00:58:21,869
drivers in order to get internet

00:58:19,589 --> 00:58:24,239
connectivity etc but booting I'm pretty

00:58:21,869 --> 00:58:27,029
confident we'll just start up and then

00:58:24,239 --> 00:58:31,559
you have to attach a serial plug to get

00:58:27,029 --> 00:58:33,589
the output data etc out but yeah so it's

00:58:31,559 --> 00:58:38,400
a goal of ours

00:58:33,589 --> 00:58:41,180
any other questions okay then I guess

00:58:38,400 --> 00:58:41,180

YouTube URL: https://www.youtube.com/watch?v=t4etEwG2_LY


