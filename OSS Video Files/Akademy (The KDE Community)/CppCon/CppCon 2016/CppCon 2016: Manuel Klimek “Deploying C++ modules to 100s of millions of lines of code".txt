Title: CppCon 2016: Manuel Klimek “Deploying C++ modules to 100s of millions of lines of code"
Publication date: 2016-09-28
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Compile times are a pain point for C++ programmers all over the world. Google is no exception.. We have a single unified codebase with hundreds of millions of lines of C++ code, all of it built from source. As the size of the codebase and the depth of interrelated interfaces exposed through textually included headers grew, the scaling of compiles became a critical issue. 

Years ago we started working to build technology in the Clang compiler that could help scale builds more effectively than textual inclusion. This is the core of C++ Modules: moving away from the model of textual inclusion. We also started preparing our codebase to migrate to this technology en masse, and through a highly automated process. It's been a long time and a tremendous effort, but we'd like to share where we are as well as what comes next. 

In this talk, we will outline the core C++ Modules technology in Clang. This is just raw technology at this stage, not an integrated part of the C++ programming language. That part is being worked on by a large group of people in the ISO C++ standards committee. But we want to share how Google is using this raw technology internally to make today's C++ compiles faster, what it took to get there, and how you too can take advantage of these features. We will cover everything from the details of migrating a codebase of this size to use a novel compilation model to the ramifications for both local and distributed build systems. We hope to give insight into the kinds of benefits that technology like C++ Modules can bring to a large scale C++ development environment. 
— 
Manuel Klimek
Google
Software Engineer
Manuel Klimek is a software engineer at Google since 2008 and a professional code monkey since 2003. After developing embedded Linux terminals for the payment industry and distributed storage technology at Google in C++, he decided that C++ productivity lags significantly behind other programming languages and set out to change this. He led the effort to grow Clang (http://clang.llvm.org) into a world class tooling platform for AST-based C++ tools and spearheaded large scale distributed semantic C++ code transformations both at Google and in the broader industry. Besides being sad that Germany lost against France in the Euro 2016, he is currently modularizing Google's internal C++ codebase and leading the development of the next generation of Clang-based C++ tools that range from editor based code completion to deep API refactorings.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:06,240
hello good morning I hope you all awake

00:00:02,850 --> 00:00:09,059
my name is Manu Klimek and I work for

00:00:06,240 --> 00:00:12,420
Google on C++ tools and generally on

00:00:09,059 --> 00:00:15,360
making C++ easier to develop and today

00:00:12,420 --> 00:00:18,240
I'll talk about how we rolled out C++

00:00:15,360 --> 00:00:21,510
modules to our hundreds of millions of

00:00:18,240 --> 00:00:24,300
lines of code code base overall this

00:00:21,510 --> 00:00:27,900
will be the story of how we went from

00:00:24,300 --> 00:00:30,539
this graph to this graph and how that

00:00:27,900 --> 00:00:34,469
made us both both very happy and very

00:00:30,539 --> 00:00:36,960
sad but before I tell you that story

00:00:34,469 --> 00:00:41,280
you'll need to learn a bit about how we

00:00:36,960 --> 00:00:44,879
develop code at Google and Google we

00:00:41,280 --> 00:00:48,300
have a very large continuously

00:00:44,879 --> 00:00:50,210
integrated code base most of our

00:00:48,300 --> 00:00:53,730
development is done in that code base

00:00:50,210 --> 00:00:55,260
for C++ we have a couple of hundred

00:00:53,730 --> 00:00:57,690
million lines of code in there that's

00:00:55,260 --> 00:01:01,379
handwritten and we have roughly the same

00:00:57,690 --> 00:01:03,239
amount of generated code it's

00:01:01,379 --> 00:01:06,090
continuously integrated that means that

00:01:03,239 --> 00:01:08,040
if you submit a change everybody in the

00:01:06,090 --> 00:01:10,470
whole company will immediately see that

00:01:08,040 --> 00:01:12,240
change and to be able to develop that

00:01:10,470 --> 00:01:13,770
way of course we need to run all the

00:01:12,240 --> 00:01:15,810
builds and all the tests of all the

00:01:13,770 --> 00:01:20,159
transitive rippers dependencies of your

00:01:15,810 --> 00:01:21,930
code and to do that you can obviously

00:01:20,159 --> 00:01:25,170
not do that on your single machine every

00:01:21,930 --> 00:01:27,060
time you submit something so in our data

00:01:25,170 --> 00:01:29,159
centers we have a lot of machines that

00:01:27,060 --> 00:01:33,329
do nothing but compile code and run

00:01:29,159 --> 00:01:35,909
tests they also catch the results so if

00:01:33,329 --> 00:01:38,700
you compile again you basically get the

00:01:35,909 --> 00:01:40,680
cached results back we've published a

00:01:38,700 --> 00:01:42,990
couple of papers on this so if you if

00:01:40,680 --> 00:01:45,360
you search for google build system you

00:01:42,990 --> 00:01:52,829
will find more details on the internets

00:01:45,360 --> 00:01:54,780
and if you look at the amount of

00:01:52,829 --> 00:01:56,820
generated code right we have roughly the

00:01:54,780 --> 00:01:59,729
same amount of generated code as we have

00:01:56,820 --> 00:02:02,880
hand written code that might seem like a

00:01:59,729 --> 00:02:05,460
lot of code but it turns out that this

00:02:02,880 --> 00:02:07,680
is mostly one kind of generated code and

00:02:05,460 --> 00:02:11,580
that's protocol buffers who here has

00:02:07,680 --> 00:02:13,500
heard of protocol buffers okay so

00:02:11,580 --> 00:02:13,860
protocol buffers are how our servers

00:02:13,500 --> 00:02:15,870
come

00:02:13,860 --> 00:02:19,290
with each other and so they're really

00:02:15,870 --> 00:02:22,620
important in general it's just a simple

00:02:19,290 --> 00:02:27,000
data description language right in this

00:02:22,620 --> 00:02:30,570
example you have a message that has one

00:02:27,000 --> 00:02:32,700
field bar and the protocol compiler

00:02:30,570 --> 00:02:36,320
compiles that into a C++ header file

00:02:32,700 --> 00:02:40,200
that gives you getters and setters and

00:02:36,320 --> 00:02:44,459
we use protocol compilers at the

00:02:40,200 --> 00:02:51,300
protocol buffers all over all right they

00:02:44,459 --> 00:02:53,310
are the main dependencies and now let's

00:02:51,300 --> 00:02:56,459
look in a more low-level how we build

00:02:53,310 --> 00:02:59,520
stuff so our build system has evolved

00:02:56,459 --> 00:03:02,220
out of a make fire based system so

00:02:59,520 --> 00:03:04,230
basically originally we had a single Meg

00:03:02,220 --> 00:03:06,660
file at the root of this large

00:03:04,230 --> 00:03:09,510
continuously integrated tree and it

00:03:06,660 --> 00:03:11,640
turns out that doesn't scale right so at

00:03:09,510 --> 00:03:14,489
some point we thought well we'll build

00:03:11,640 --> 00:03:16,530
our own build system that is now open

00:03:14,489 --> 00:03:19,560
source it's called basil you can use it

00:03:16,530 --> 00:03:22,769
and I'll explain a bit about how the

00:03:19,560 --> 00:03:25,440
syntax works how we describe our builds

00:03:22,769 --> 00:03:27,330
so it's very Python II all right you can

00:03:25,440 --> 00:03:28,769
see here and you see an example of a

00:03:27,330 --> 00:03:32,580
couple of libraries right you have a

00:03:28,769 --> 00:03:34,620
proto library named P it has a source P

00:03:32,580 --> 00:03:37,110
dot proto right that what we generate

00:03:34,620 --> 00:03:39,660
the c++ source code from and then we

00:03:37,110 --> 00:03:42,720
have two other libraries a library a we

00:03:39,660 --> 00:03:45,299
see that we specify headers that's kind

00:03:42,720 --> 00:03:47,549
of interesting because many C++ build

00:03:45,299 --> 00:03:50,370
systems don't specify their headers we

00:03:47,549 --> 00:03:52,920
do that because it has turned out that

00:03:50,370 --> 00:03:55,530
letting everybody just include Harris

00:03:52,920 --> 00:03:58,080
from all over the codebase is a bad idea

00:03:55,530 --> 00:04:00,540
right did people then basically use the

00:03:58,080 --> 00:04:02,190
implementation details of other people's

00:04:00,540 --> 00:04:02,549
libraries and they cannot change it

00:04:02,190 --> 00:04:06,540
anymore

00:04:02,549 --> 00:04:08,459
and we of course specify the sources

00:04:06,540 --> 00:04:11,040
that those are the translation units

00:04:08,459 --> 00:04:13,799
that are compiled right and then next we

00:04:11,040 --> 00:04:17,250
specify the dependencies on a high level

00:04:13,799 --> 00:04:19,620
here CCC library P has dependencies on

00:04:17,250 --> 00:04:23,550
the library a and the program of a

00:04:19,620 --> 00:04:25,830
library P and if you look at how this

00:04:23,550 --> 00:04:28,590
then gets compiled let's just take a

00:04:25,830 --> 00:04:31,140
translation unit out of that

00:04:28,590 --> 00:04:33,570
so here we have P dot CCE and let's say

00:04:31,140 --> 00:04:39,480
P dot CC includes a one dot H P dot H

00:04:33,570 --> 00:04:41,520
other dot H and P dot p bh and now when

00:04:39,480 --> 00:04:44,370
we want to compile this we need to ship

00:04:41,520 --> 00:04:46,080
the source code to our distributed

00:04:44,370 --> 00:04:48,210
builder so the question is what source

00:04:46,080 --> 00:04:50,130
close to we need to ship well the first

00:04:48,210 --> 00:04:52,110
idea is we just ship everything that's

00:04:50,130 --> 00:04:54,750
specified in the headers of the

00:04:52,110 --> 00:04:57,480
transitive dependencies and the source

00:04:54,750 --> 00:05:01,169
code itself while in this case we have p

00:04:57,480 --> 00:05:03,480
dot c c metered age a1 dot h a2 dot H

00:05:01,169 --> 00:05:06,360
and P dot P B - now the first thing

00:05:03,480 --> 00:05:09,630
you'll notice is that a - dot H is

00:05:06,360 --> 00:05:11,910
actually not used so that that seems

00:05:09,630 --> 00:05:13,919
wasteful we want to get rid of that and

00:05:11,910 --> 00:05:15,870
so we included a local optimization

00:05:13,919 --> 00:05:19,260
that's called include scale so the build

00:05:15,870 --> 00:05:20,970
system actually follows the includes

00:05:19,260 --> 00:05:24,300
through all the files right it has a

00:05:20,970 --> 00:05:27,240
preprocessor implementation and figures

00:05:24,300 --> 00:05:31,110
out what headers a source file actually

00:05:27,240 --> 00:05:33,780
needs so it figures out a 2 dot H is

00:05:31,110 --> 00:05:35,610
actually not needed so it's not an input

00:05:33,780 --> 00:05:38,910
to this action so we don't need to send

00:05:35,610 --> 00:05:41,070
it to the remote execute additionally

00:05:38,910 --> 00:05:43,620
you see that P dot CC includes other

00:05:41,070 --> 00:05:45,810
knowledge so the interesting part is why

00:05:43,620 --> 00:05:47,970
we would like that all headers and the

00:05:45,810 --> 00:05:49,530
code base are fully specified they're

00:05:47,970 --> 00:05:51,780
currently not we are working on that

00:05:49,530 --> 00:05:54,330
it's a multi-year effort as long as

00:05:51,780 --> 00:05:59,430
that's not done we need to also detect

00:05:54,330 --> 00:06:02,040
additional headers we have to set so

00:05:59,430 --> 00:06:08,400
this is basically the core of how our

00:06:02,040 --> 00:06:11,550
build system works now we want to roll

00:06:08,400 --> 00:06:13,919
out modules so when we say modules here

00:06:11,550 --> 00:06:16,740
what do we mean with that this was

00:06:13,919 --> 00:06:18,810
multiple years ago right what we wanted

00:06:16,740 --> 00:06:22,680
to do was we wanted to take clanks

00:06:18,810 --> 00:06:24,210
module implementation at the time and we

00:06:22,680 --> 00:06:25,979
knew that at some point modules would be

00:06:24,210 --> 00:06:28,860
standardized but we had no idea what

00:06:25,979 --> 00:06:31,110
that would look like so we said we do

00:06:28,860 --> 00:06:34,110
not want to make any changes to syntax

00:06:31,110 --> 00:06:36,030
in our code that means right we want to

00:06:34,110 --> 00:06:39,450
still spell out the hash includes hash

00:06:36,030 --> 00:06:41,400
includes and but we what we would want

00:06:39,450 --> 00:06:44,820
to allow is semantics

00:06:41,400 --> 00:06:47,430
because we had we had people previously

00:06:44,820 --> 00:06:49,470
trying to do precompiled headers and

00:06:47,430 --> 00:06:52,650
most of the time they ran into problems

00:06:49,470 --> 00:06:55,020
when they wanted to keep the semantics

00:06:52,650 --> 00:06:58,919
of C++ with precompiled headers and that

00:06:55,020 --> 00:07:01,320
basically took away all the upsides so

00:06:58,919 --> 00:07:05,220
we allow changes and semantics we do not

00:07:01,320 --> 00:07:07,320
allow changes in syntax and now we have

00:07:05,220 --> 00:07:10,350
a bit of background of how we build code

00:07:07,320 --> 00:07:12,110
how our build system works and what kind

00:07:10,350 --> 00:07:15,900
of modules we actually want to address

00:07:12,110 --> 00:07:20,490
but the question stands why do we did we

00:07:15,900 --> 00:07:22,740
want to do that so why not just wait

00:07:20,490 --> 00:07:25,110
until modules is standardized right and

00:07:22,740 --> 00:07:28,110
then implement it that seems lower risk

00:07:25,110 --> 00:07:30,240
but we know that for a code base of

00:07:28,110 --> 00:07:31,560
multiple 100 million lines of code what

00:07:30,240 --> 00:07:33,450
you actually need to do is you need to

00:07:31,560 --> 00:07:35,760
start early because it takes many many

00:07:33,450 --> 00:07:38,789
years to make a large change to the code

00:07:35,760 --> 00:07:40,860
base so we wanted to start early we also

00:07:38,789 --> 00:07:42,600
wanted to start early because we want to

00:07:40,860 --> 00:07:45,150
gain implementation in size right we

00:07:42,600 --> 00:07:46,710
have people working in our C++ team who

00:07:45,150 --> 00:07:48,720
are also parts of the sentence committee

00:07:46,710 --> 00:07:51,000
and they wanted to be able to contribute

00:07:48,720 --> 00:07:52,620
that inside from our implementation from

00:07:51,000 --> 00:07:55,410
our experiments back to the

00:07:52,620 --> 00:07:58,110
standardization process so we make sure

00:07:55,410 --> 00:08:00,479
that when modules are standardized it's

00:07:58,110 --> 00:08:02,820
not standardized in a way that precludes

00:08:00,479 --> 00:08:12,000
us from getting the benefits that we

00:08:02,820 --> 00:08:14,340
need for a large C++ code base and more

00:08:12,000 --> 00:08:19,830
importantly why we wanted to start was

00:08:14,340 --> 00:08:23,190
that we had a really bad problem and to

00:08:19,830 --> 00:08:24,870
get an look at just how bad it got you

00:08:23,190 --> 00:08:28,800
can look at this graph though this graph

00:08:24,870 --> 00:08:31,440
started back in 2013 when we started to

00:08:28,800 --> 00:08:33,930
look into why our build second a clause

00:08:31,440 --> 00:08:35,099
so we had this this intuition something

00:08:33,930 --> 00:08:38,820
is getting slower what's actually

00:08:35,099 --> 00:08:40,860
happening here and I did some log

00:08:38,820 --> 00:08:43,919
shuffling and a foul that some people

00:08:40,860 --> 00:08:46,050
actually change a test file and then

00:08:43,919 --> 00:08:48,570
they run their compiled and then it

00:08:46,050 --> 00:08:50,280
takes one minute for the compiler to get

00:08:48,570 --> 00:08:53,339
back to them with value forget a

00:08:50,280 --> 00:08:55,240
semicolon here and at that point I was

00:08:53,339 --> 00:08:57,160
like why are they not coming this

00:08:55,240 --> 00:08:59,589
pitchforks is at us that seems like

00:08:57,160 --> 00:09:01,120
really bad for activity and the problem

00:08:59,589 --> 00:09:01,510
is it's a bit of a boiling frog problem

00:09:01,120 --> 00:09:04,029
right

00:09:01,510 --> 00:09:07,330
it just gets slowly worse over time and

00:09:04,029 --> 00:09:09,640
the big problem that we see here is this

00:09:07,330 --> 00:09:12,399
graph goes up to the right that this is

00:09:09,640 --> 00:09:14,709
super Linea we really like those graphs

00:09:12,399 --> 00:09:19,029
when they mean money earned we don't

00:09:14,709 --> 00:09:21,100
like them when it's cost right and if

00:09:19,029 --> 00:09:22,600
you explain to people who provision for

00:09:21,100 --> 00:09:25,540
the machines you need for building

00:09:22,600 --> 00:09:28,750
things that well our our requirements

00:09:25,540 --> 00:09:31,209
for building our code base actually

00:09:28,750 --> 00:09:32,830
super linear increase they're like well

00:09:31,209 --> 00:09:36,430
that's that's not something we can

00:09:32,830 --> 00:09:38,920
continue to do so we wanted to address

00:09:36,430 --> 00:09:40,209
this problem to address this problem we

00:09:38,920 --> 00:09:43,050
first had to understand what's actually

00:09:40,209 --> 00:09:43,050
going on here

00:09:44,880 --> 00:09:51,190
so we looked into why those things

00:09:48,220 --> 00:09:54,220
happened the first idea we had was well

00:09:51,190 --> 00:09:55,450
perhaps optimizations getting slow has

00:09:54,220 --> 00:09:57,490
nothing do with optimization

00:09:55,450 --> 00:09:59,950
perhaps the compiler circuit is law in

00:09:57,490 --> 00:10:02,589
fact no the compilers had been getting

00:09:59,950 --> 00:10:04,630
faster over time per line of code what

00:10:02,589 --> 00:10:06,850
really has happened is that the

00:10:04,630 --> 00:10:09,149
transitive closure of includes

00:10:06,850 --> 00:10:16,000
that we expand into the pre process file

00:10:09,149 --> 00:10:19,180
grew super linearly so we had overall we

00:10:16,000 --> 00:10:21,220
had translation units that turned out to

00:10:19,180 --> 00:10:26,440
be more than 10 million lines of code

00:10:21,220 --> 00:10:30,820
after preprocessor so where does this

00:10:26,440 --> 00:10:33,579
come from right we already knew that we

00:10:30,820 --> 00:10:36,070
have lots of generated code we have all

00:10:33,579 --> 00:10:38,459
these problems and now these protocol

00:10:36,070 --> 00:10:42,040
buffers have some interesting properties

00:10:38,459 --> 00:10:46,540
first the example I showed you

00:10:42,040 --> 00:10:48,670
previously was a simplification right if

00:10:46,540 --> 00:10:51,100
you have a very simple message with a

00:10:48,670 --> 00:10:54,339
single field the protocol buffer

00:10:51,100 --> 00:10:56,290
actually expands into roughly what you

00:10:54,339 --> 00:10:58,329
can see here right

00:10:56,290 --> 00:11:01,959
we have many overloads for the setters

00:10:58,329 --> 00:11:03,940
we have many more like site methods we

00:11:01,959 --> 00:11:06,250
have actually what's missing here's all

00:11:03,940 --> 00:11:08,680
the reflection parts that also get

00:11:06,250 --> 00:11:09,160
generated and basically you see two

00:11:08,680 --> 00:11:10,839
parts of

00:11:09,160 --> 00:11:13,660
the protocol before five five right you

00:11:10,839 --> 00:11:15,550
see the declarations of all the methods

00:11:13,660 --> 00:11:17,259
we need for the fields and then we see

00:11:15,550 --> 00:11:18,850
the inline definitions and we have the

00:11:17,259 --> 00:11:20,440
inline definitions because because we

00:11:18,850 --> 00:11:22,060
needed to be fast right it's what

00:11:20,440 --> 00:11:24,129
connects our servers we need this path

00:11:22,060 --> 00:11:30,220
to be super fast this is actually the

00:11:24,129 --> 00:11:32,290
hot path in our code additionally we

00:11:30,220 --> 00:11:34,329
have the problem that if a protocol

00:11:32,290 --> 00:11:36,910
buffer depends on a different protocol

00:11:34,329 --> 00:11:39,850
buffers type it would just directly hash

00:11:36,910 --> 00:11:43,230
include' that header so this actually

00:11:39,850 --> 00:11:45,459
just transitively expands all

00:11:43,230 --> 00:11:47,160
dependencies of a protocol buffer every

00:11:45,459 --> 00:11:49,779
time you use it

00:11:47,160 --> 00:11:52,839
so the first idea we had was well this

00:11:49,779 --> 00:11:54,819
is easy to solve right we seems like in

00:11:52,839 --> 00:11:56,439
in up mode we need those inline

00:11:54,819 --> 00:11:59,709
functions but in debug mode you probably

00:11:56,439 --> 00:12:01,420
don't need them so we just left them out

00:11:59,709 --> 00:12:02,920
the the preprocessor is actually really

00:12:01,420 --> 00:12:07,509
good at just jumping over stuff you

00:12:02,920 --> 00:12:11,649
don't need and we implement that and our

00:12:07,509 --> 00:12:13,930
graph changed so it gave us some relief

00:12:11,649 --> 00:12:16,120
but that only lasted for a very short

00:12:13,930 --> 00:12:19,240
time because we did not actually address

00:12:16,120 --> 00:12:22,329
the underlying problem right after that

00:12:19,240 --> 00:12:26,470
change again the super linear growth

00:12:22,329 --> 00:12:33,670
just persisted so how do we address the

00:12:26,470 --> 00:12:36,040
root cause here there are two possible

00:12:33,670 --> 00:12:38,019
ways to address the root cause the first

00:12:36,040 --> 00:12:40,540
is well this is a protocol buffer

00:12:38,019 --> 00:12:42,430
problem let's address in the compiler

00:12:40,540 --> 00:12:44,709
right we can hack up the proto compiler

00:12:42,430 --> 00:12:48,880
to work around the fact that it needs

00:12:44,709 --> 00:12:50,410
this those transitive includes the

00:12:48,880 --> 00:12:53,620
problem with that approach is obviously

00:12:50,410 --> 00:12:55,569
that will only help us for protocol for

00:12:53,620 --> 00:12:59,139
the protocol buffers we also have a lot

00:12:55,569 --> 00:13:02,189
of code and a increasing number of lines

00:12:59,139 --> 00:13:05,259
of code for the rest of the code base so

00:13:02,189 --> 00:13:08,050
we thought instead of having the proto

00:13:05,259 --> 00:13:11,319
compiler and actually figuring out how

00:13:08,050 --> 00:13:13,300
to make it not need the types of its

00:13:11,319 --> 00:13:16,709
direct dependencies right you can do

00:13:13,300 --> 00:13:19,569
template magic and stuff what if we just

00:13:16,709 --> 00:13:21,970
change how we compile code on a more

00:13:19,569 --> 00:13:22,990
fundamental level right and they are the

00:13:21,970 --> 00:13:27,070
idea of Moore has come

00:13:22,990 --> 00:13:28,870
or busy it store the ast the idea to

00:13:27,070 --> 00:13:31,089
make that actually scale is met you

00:13:28,870 --> 00:13:34,000
lazily load the symbols from the module

00:13:31,089 --> 00:13:36,010
file if you want more details on all the

00:13:34,000 --> 00:13:38,740
technical parts you will have to go to

00:13:36,010 --> 00:13:42,670
Richard's talk which will also talk more

00:13:38,740 --> 00:13:52,060
about that how this all applies to the

00:13:42,670 --> 00:13:53,980
TF in the afternoon and in this talk I

00:13:52,060 --> 00:13:56,350
will continue to talk about how we

00:13:53,980 --> 00:13:58,060
implement that in the code base so the

00:13:56,350 --> 00:14:00,100
first thing because before we wanted to

00:13:58,060 --> 00:14:01,600
roll that out is we wanted to make sure

00:14:00,100 --> 00:14:03,339
that we actually have an understanding

00:14:01,600 --> 00:14:05,890
of what would happen right we didn't

00:14:03,339 --> 00:14:07,720
want to just go and do it because we

00:14:05,890 --> 00:14:10,450
knew it's a lot of effort so let's

00:14:07,720 --> 00:14:14,410
predict what happens to predict what

00:14:10,450 --> 00:14:16,870
happens we have to look at how we how we

00:14:14,410 --> 00:14:19,600
think modules will change the

00:14:16,870 --> 00:14:22,120
fundamental compilation and let's look

00:14:19,600 --> 00:14:25,270
at an example right you have a couple of

00:14:22,120 --> 00:14:27,880
translation unit t1 to t4 at CC and they

00:14:25,270 --> 00:14:30,610
all have the include the same chain of

00:14:27,880 --> 00:14:35,380
headers right C dot H includes P dotage

00:14:30,610 --> 00:14:37,660
includes edit H now in the current model

00:14:35,380 --> 00:14:41,890
in the old model what happens is that

00:14:37,660 --> 00:14:44,709
you distribute all of them to build

00:14:41,890 --> 00:14:46,630
workers and each of the build workers

00:14:44,709 --> 00:14:49,630
will in parallel just take one of the

00:14:46,630 --> 00:14:53,620
source files parse a dot H parse P dot H

00:14:49,630 --> 00:14:57,910
Bar C dot H and the translation unit and

00:14:53,620 --> 00:14:59,320
compile the output so the nice property

00:14:57,910 --> 00:15:01,390
of this is that you can do all of this

00:14:59,320 --> 00:15:03,070
in parallel and the problem you see is

00:15:01,390 --> 00:15:04,870
that we do lot of work right every green

00:15:03,070 --> 00:15:08,440
box here means that something needs to

00:15:04,870 --> 00:15:11,050
be parsed so we we actually spend a lot

00:15:08,440 --> 00:15:13,720
of time reap arcing the same headers

00:15:11,050 --> 00:15:17,010
over and over and over again with

00:15:13,720 --> 00:15:19,779
modules this will look different right

00:15:17,010 --> 00:15:22,630
with modules we will take a header in

00:15:19,779 --> 00:15:24,399
this example a dot H and we compile what

00:15:22,630 --> 00:15:26,920
we call a header module that's the PCM

00:15:24,399 --> 00:15:30,130
file in clang landfill right so a dot H

00:15:26,920 --> 00:15:32,620
will be compiled into a dot PCM and then

00:15:30,130 --> 00:15:34,930
a dot PCM and B dot H will be the input

00:15:32,620 --> 00:15:36,279
for the compilation of P dot H and

00:15:34,930 --> 00:15:39,759
repeater PCM

00:15:36,279 --> 00:15:41,829
and then we compile Peachy PCM and all

00:15:39,759 --> 00:15:44,170
of these then are the input to the

00:15:41,829 --> 00:15:48,519
compilation of the translation units and

00:15:44,170 --> 00:15:50,199
those again can have min Pro so if you

00:15:48,519 --> 00:15:52,149
know about distributed systems what we

00:15:50,199 --> 00:15:55,149
what we did was basically we introduced

00:15:52,149 --> 00:15:57,100
a larger serial step right in theory

00:15:55,149 --> 00:15:59,800
this shouldn't actually make a

00:15:57,100 --> 00:16:04,600
difference right because we actually do

00:15:59,800 --> 00:16:06,790
the same amount of work in just serially

00:16:04,600 --> 00:16:08,470
before we do the parallel steps but in

00:16:06,790 --> 00:16:10,360
practice in a distributed system you

00:16:08,470 --> 00:16:12,850
always have communication overhead right

00:16:10,360 --> 00:16:15,579
you always have some latency when you

00:16:12,850 --> 00:16:17,559
when for example a dot PCM is compiled

00:16:15,579 --> 00:16:21,129
on a different machine than the t4 dot

00:16:17,559 --> 00:16:23,439
CC so we expect some overhead here but

00:16:21,129 --> 00:16:26,079
we don't expect that overhead to be like

00:16:23,439 --> 00:16:28,149
significant on the other hand for the

00:16:26,079 --> 00:16:31,449
single translation unit recompile case

00:16:28,149 --> 00:16:34,059
so let's take the example where somebody

00:16:31,449 --> 00:16:36,819
just edits a test so for example 200 cc

00:16:34,059 --> 00:16:40,050
and they just make write they just add

00:16:36,819 --> 00:16:42,100
some new lines of code in the old system

00:16:40,050 --> 00:16:45,339
what would happen is let people to

00:16:42,100 --> 00:16:48,490
recompile a B and C reparse a B and C to

00:16:45,339 --> 00:16:52,000
compile tierod CC and with modules now

00:16:48,490 --> 00:16:55,509
all we need to do is we need to reparse

00:16:52,000 --> 00:17:02,949
g1 not CC and take the modules as input

00:16:55,509 --> 00:17:05,949
so here we expect some serious speed so

00:17:02,949 --> 00:17:08,709
to conclude with modules we expect some

00:17:05,949 --> 00:17:10,929
longer critical path we don't exactly

00:17:08,709 --> 00:17:14,159
know how that will turn out we expect it

00:17:10,929 --> 00:17:16,539
to be not too bad we expect a lot of

00:17:14,159 --> 00:17:18,699
speed up for incremental compiles right

00:17:16,539 --> 00:17:22,630
that was what our original problem also

00:17:18,699 --> 00:17:25,260
was and also we expect less CPU use of

00:17:22,630 --> 00:17:28,510
all because if you remember right the

00:17:25,260 --> 00:17:30,340
parallel compilations all the headers

00:17:28,510 --> 00:17:32,620
get recompile all the time in the old

00:17:30,340 --> 00:17:39,159
model so we don't do that we save some

00:17:32,620 --> 00:17:42,100
CPU hopefully so now we want to roll

00:17:39,159 --> 00:17:44,260
that out over all of our code the

00:17:42,100 --> 00:17:46,659
question is how do we start if you want

00:17:44,260 --> 00:17:49,930
to make such a large change you want to

00:17:46,659 --> 00:17:52,210
find something small where you get

00:17:49,930 --> 00:17:54,040
for with very little effort get a lot of

00:17:52,210 --> 00:17:55,660
benefit right because your team needs to

00:17:54,040 --> 00:17:58,720
actually pay for itself over time you

00:17:55,660 --> 00:18:02,050
cannot just for ten years develop

00:17:58,720 --> 00:18:03,370
something that hopefully has impact at

00:18:02,050 --> 00:18:07,780
the end so you need some incremental

00:18:03,370 --> 00:18:09,910
impact so turns out that protocol

00:18:07,780 --> 00:18:12,460
buffers as you probably expected by now

00:18:09,910 --> 00:18:15,420
are the perfect example again right

00:18:12,460 --> 00:18:19,270
it's the largest problem we found and

00:18:15,420 --> 00:18:22,059
it's also a very very small problem

00:18:19,270 --> 00:18:23,559
comparable because if we want to change

00:18:22,059 --> 00:18:25,360
our protocol buffers right if there are

00:18:23,559 --> 00:18:27,610
semantic changes that require us to

00:18:25,360 --> 00:18:29,230
change protocol buffers we just change

00:18:27,610 --> 00:18:31,660
the generator we don't have to actually

00:18:29,230 --> 00:18:33,220
go all over the codebase and change

00:18:31,660 --> 00:18:37,090
called code all over the codebase

00:18:33,220 --> 00:18:38,790
because that's actually a lot harder so

00:18:37,090 --> 00:18:42,520
cool let's start with protocol buffers

00:18:38,790 --> 00:18:45,670
how do we how do we implement that with

00:18:42,520 --> 00:18:50,230
clang so the trick is we don't want to

00:18:45,670 --> 00:18:52,809
make any changes to the syntax clang has

00:18:50,230 --> 00:18:55,600
this idea of a module map that you can

00:18:52,809 --> 00:18:58,929
give it in addition to the source code

00:18:55,600 --> 00:19:03,270
you give it and that basic describes

00:18:58,929 --> 00:19:05,800
what the C++ module will look like if

00:19:03,270 --> 00:19:08,410
you have an example of a proto library

00:19:05,800 --> 00:19:11,410
right with a source P dot proto that

00:19:08,410 --> 00:19:13,210
will generator had a p dot p b dot h the

00:19:11,410 --> 00:19:16,179
module looks roughly like this right you

00:19:13,210 --> 00:19:18,850
have it says header header means clang

00:19:16,179 --> 00:19:22,740
this will be a header that i want in

00:19:18,850 --> 00:19:25,540
that module the dependencies are

00:19:22,740 --> 00:19:27,850
specified by saying use here right we

00:19:25,540 --> 00:19:30,100
use a and everything uses the STL of

00:19:27,850 --> 00:19:33,700
course and then we have the interesting

00:19:30,100 --> 00:19:36,550
part that's the export star so when we

00:19:33,700 --> 00:19:38,860
roll out modules we want to make as few

00:19:36,550 --> 00:19:39,370
changes to the code base as we possibly

00:19:38,860 --> 00:19:41,800
can

00:19:39,370 --> 00:19:45,220
so we tried to have the semantic model

00:19:41,800 --> 00:19:47,710
match as closely to the old like include

00:19:45,220 --> 00:19:49,900
model and if you include something you

00:19:47,710 --> 00:19:52,300
can use everything in it so we do expert

00:19:49,900 --> 00:19:54,610
star which tests clang well everything

00:19:52,300 --> 00:19:59,590
in that header is exported so somebody

00:19:54,610 --> 00:20:03,600
who uses that module can also use all

00:19:59,590 --> 00:20:03,600
symbols that are in that header

00:20:04,170 --> 00:20:13,150
now one interesting part is that the

00:20:10,390 --> 00:20:14,380
protocol buffer headers also include

00:20:13,150 --> 00:20:17,080
other headers right they obviously

00:20:14,380 --> 00:20:19,930
include some stuff from the STL but they

00:20:17,080 --> 00:20:21,880
also include their own utility libraries

00:20:19,930 --> 00:20:25,150
for example every protocol buffer header

00:20:21,880 --> 00:20:27,430
has a every protocol buffer has a base

00:20:25,150 --> 00:20:30,190
class so every protocol buffer header

00:20:27,430 --> 00:20:32,710
includes the header of that base class

00:20:30,190 --> 00:20:34,360
and we thought at first that well people

00:20:32,710 --> 00:20:36,640
don't want to go all over the codebase

00:20:34,360 --> 00:20:39,370
and have to modernize everything so we

00:20:36,640 --> 00:20:42,250
introduced the idea of textual headers

00:20:39,370 --> 00:20:45,370
and we introduced that in the clang

00:20:42,250 --> 00:20:47,980
module map so that you can basically

00:20:45,370 --> 00:20:49,300
declare a module message so that's not

00:20:47,980 --> 00:20:52,660
really a module because it will not

00:20:49,300 --> 00:20:55,330
compile any PCM file out of it because

00:20:52,660 --> 00:20:58,810
the header in it is texture and that

00:20:55,330 --> 00:21:00,790
means if clang C is in a when you

00:20:58,810 --> 00:21:03,820
compile a module it sees an include of

00:21:00,790 --> 00:21:06,250
that header it will just include that

00:21:03,820 --> 00:21:08,820
textually now the interesting part is

00:21:06,250 --> 00:21:11,950
that because of the export star all

00:21:08,820 --> 00:21:21,060
symbols from that header will also need

00:21:11,950 --> 00:21:25,240
to be exported so overall let's look at

00:21:21,060 --> 00:21:28,090
when we made those changes do we have to

00:21:25,240 --> 00:21:31,540
make any changes because we expect the

00:21:28,090 --> 00:21:34,360
semantics to be different so generally

00:21:31,540 --> 00:21:36,670
with modules the core problem is that

00:21:34,360 --> 00:21:39,100
every header must stand on its own right

00:21:36,670 --> 00:21:44,260
it cannot be different depending on

00:21:39,100 --> 00:21:45,820
where it's used from we will also we

00:21:44,260 --> 00:21:50,230
will also detect some more audio

00:21:45,820 --> 00:21:52,240
violations and we thought well over the

00:21:50,230 --> 00:21:55,150
code paste do we have audio violations

00:21:52,240 --> 00:21:57,250
in protocol buffers perhaps a few right

00:21:55,150 --> 00:22:00,310
probably not too many we just fix them

00:21:57,250 --> 00:22:02,380
as we go so it seems like we all set up

00:22:00,310 --> 00:22:05,890
right the protocol buffer headers are a

00:22:02,380 --> 00:22:12,810
very simple world they stand on their

00:22:05,890 --> 00:22:14,980
own so let's roll that out so we started

00:22:12,810 --> 00:22:17,140
implementing that in our build system

00:22:14,980 --> 00:22:19,720
and we started

00:22:17,140 --> 00:22:24,310
building code in our Google cope with

00:22:19,720 --> 00:22:27,550
that as you expect not all things went

00:22:24,310 --> 00:22:30,880
as we expected so the first thing that

00:22:27,550 --> 00:22:34,840
happened was that module compiles for

00:22:30,880 --> 00:22:38,260
twice as low as non molecule PI's that's

00:22:34,840 --> 00:22:41,440
unexpected and it turned out that the

00:22:38,260 --> 00:22:44,650
problem here is that when we developed

00:22:41,440 --> 00:22:46,870
modules we always tried it on small kind

00:22:44,650 --> 00:22:50,980
of examples and then when we went in and

00:22:46,870 --> 00:22:53,800
started to use it at Google scale it

00:22:50,980 --> 00:22:57,370
turns out that we find some algorithmic

00:22:53,800 --> 00:23:00,760
problems that we didn't predict so we

00:22:57,370 --> 00:23:03,160
have many translation units that depend

00:23:00,760 --> 00:23:06,430
transitively on thousands of protocol

00:23:03,160 --> 00:23:09,040
buffer files here we have an example

00:23:06,430 --> 00:23:11,530
right we have a t1 dot C C and that just

00:23:09,040 --> 00:23:18,190
depends on a lot of protocol buffer

00:23:11,530 --> 00:23:20,710
modules and all those program modules or

00:23:18,190 --> 00:23:23,410
the the headers in those modules include

00:23:20,710 --> 00:23:26,650
the base class header right they include

00:23:23,410 --> 00:23:29,020
the message hood age which provides the

00:23:26,650 --> 00:23:32,170
class message so as we said earlier

00:23:29,020 --> 00:23:34,630
because of the export star every one of

00:23:32,170 --> 00:23:38,590
those header modules actually contains

00:23:34,630 --> 00:23:42,700
that class now when we compile t1 and CC

00:23:38,590 --> 00:23:45,100
and we load a protocol buffer we need to

00:23:42,700 --> 00:23:47,920
actually go through all the modules and

00:23:45,100 --> 00:23:52,720
figure out that this exported symbol is

00:23:47,920 --> 00:23:55,510
the same in every header module and this

00:23:52,720 --> 00:23:58,000
is a thousand modules right so you have

00:23:55,510 --> 00:24:02,100
Mexican Oh n in there that you have to

00:23:58,000 --> 00:24:05,290
do for every such symbol that you import

00:24:02,100 --> 00:24:08,140
now we don't only have the message to at

00:24:05,290 --> 00:24:10,780
age right the protocol buffer headers

00:24:08,140 --> 00:24:12,010
also includes the STL for example so in

00:24:10,780 --> 00:24:14,530
the early days where we hadn't

00:24:12,010 --> 00:24:19,000
modernized VHDL what actually happened

00:24:14,530 --> 00:24:21,160
was that we put the STL into every one

00:24:19,000 --> 00:24:24,670
of those modules and when we started

00:24:21,160 --> 00:24:26,590
merging them clang ran over and in 32

00:24:24,670 --> 00:24:30,150
for the number of pre-processed tokens

00:24:26,590 --> 00:24:30,150
that we found and crashed

00:24:30,190 --> 00:24:34,230
well but that seems like an easy problem

00:24:33,100 --> 00:24:37,390
to fix

00:24:34,230 --> 00:24:39,760
we just modernize the dependencies that

00:24:37,390 --> 00:24:43,840
we use from every protocol buffer and

00:24:39,760 --> 00:24:48,490
then we have the symbol in one place and

00:24:43,840 --> 00:24:50,500
everything's fine the problem is with

00:24:48,490 --> 00:24:54,010
this that this also means that we need

00:24:50,500 --> 00:24:56,320
to go now and actually modernize larger

00:24:54,010 --> 00:24:57,970
parts of the copis the protocol buffers

00:24:56,320 --> 00:24:59,830
actually have a few quite a few

00:24:57,970 --> 00:25:02,830
dependencies and those have dependencies

00:24:59,830 --> 00:25:04,420
and overall you basically need the first

00:25:02,830 --> 00:25:07,660
layer that every protocol buffer

00:25:04,420 --> 00:25:12,700
includes to be modular to work against

00:25:07,660 --> 00:25:14,500
that pessimism okay so what we did was

00:25:12,700 --> 00:25:16,210
we went over the code base and we

00:25:14,500 --> 00:25:19,030
started actually trying to compile

00:25:16,210 --> 00:25:22,080
normal code non-programmable code as

00:25:19,030 --> 00:25:24,610
modules and there you run into the

00:25:22,080 --> 00:25:26,920
problems you expect with the semantic

00:25:24,610 --> 00:25:28,870
changes you would get from modules all

00:25:26,920 --> 00:25:32,950
right the simplest example that actually

00:25:28,870 --> 00:25:34,930
happens a lot is somebody has a header

00:25:32,950 --> 00:25:37,390
that had a declare some function

00:25:34,930 --> 00:25:39,850
something else some other header uses

00:25:37,390 --> 00:25:42,970
fat and does not include the first

00:25:39,850 --> 00:25:44,620
header this of course works fine with

00:25:42,970 --> 00:25:46,870
the traditional C++ module where

00:25:44,620 --> 00:25:48,970
everything if you just happen to include

00:25:46,870 --> 00:25:52,330
the files in the right order everything

00:25:48,970 --> 00:25:54,850
works fine right but here P dot H does

00:25:52,330 --> 00:25:57,040
not actually compile on its own so when

00:25:54,850 --> 00:26:00,160
we try to compile it as a module we get

00:25:57,040 --> 00:26:01,720
a compile error so we went and started

00:26:00,160 --> 00:26:05,050
fixing them basically all over the

00:26:01,720 --> 00:26:07,450
codebase what else happens we have we

00:26:05,050 --> 00:26:10,030
have some people who really dislike

00:26:07,450 --> 00:26:13,660
having any implementation details in

00:26:10,030 --> 00:26:16,300
their head so what they came up with was

00:26:13,660 --> 00:26:19,210
the idea that well we also want really

00:26:16,300 --> 00:26:21,550
performant code so we we want our inline

00:26:19,210 --> 00:26:23,830
methods to be in the header but we don't

00:26:21,550 --> 00:26:27,910
want them in the header that a user of

00:26:23,830 --> 00:26:30,880
my library would look at so they define

00:26:27,910 --> 00:26:31,750
a class and then they at the end of the

00:26:30,880 --> 00:26:33,970
header

00:26:31,750 --> 00:26:37,810
they just hash include' an impelled or H

00:26:33,970 --> 00:26:40,570
and that will give you all the or the

00:26:37,810 --> 00:26:43,240
inline methods the problem with that

00:26:40,570 --> 00:26:45,540
approach right again the input

00:26:43,240 --> 00:26:47,920
- does actually not compile on its own

00:26:45,540 --> 00:26:50,110
if you if you happen to follow the

00:26:47,920 --> 00:26:53,590
Google style guide actually a while ago

00:26:50,110 --> 00:26:55,870
we change the style guide to discourage

00:26:53,590 --> 00:26:58,420
at least those implement sets and to say

00:26:55,870 --> 00:27:04,030
that every header should stand on its

00:26:58,420 --> 00:27:07,809
own another thing that's interesting

00:27:04,030 --> 00:27:09,400
that breaks is C code so the problem is

00:27:07,809 --> 00:27:13,420
that we have a lot of third-party code

00:27:09,400 --> 00:27:15,520
and some third-party code is C only code

00:27:13,420 --> 00:27:18,460
where the authors don't really care that

00:27:15,520 --> 00:27:21,670
their code might be used from C++ so

00:27:18,460 --> 00:27:25,230
they don't want to sprinkle if the C++

00:27:21,670 --> 00:27:29,200
extra and C all over the headers right

00:27:25,230 --> 00:27:32,230
so what people do is they put the extern

00:27:29,200 --> 00:27:35,559
see around the hash include' now this is

00:27:32,230 --> 00:27:38,950
a hash include' that is hard to put to

00:27:35,559 --> 00:27:41,590
make into a modular use automatically so

00:27:38,950 --> 00:27:43,690
we have some workarounds but within our

00:27:41,590 --> 00:27:47,530
own build system we don't have a really

00:27:43,690 --> 00:27:51,130
good solution yet mainly because our the

00:27:47,530 --> 00:27:52,809
names for c and c++ headers are

00:27:51,130 --> 00:27:56,200
basically the same right both have the

00:27:52,809 --> 00:27:58,000
dot h any and so as long as our build

00:27:56,200 --> 00:28:00,280
system doesn't allow us to specify but

00:27:58,000 --> 00:28:02,860
this RC harris and these are c++ headers

00:28:00,280 --> 00:28:05,080
we don't actually know which are which

00:28:02,860 --> 00:28:10,750
without like because they are compatible

00:28:05,080 --> 00:28:14,620
most then we come into the more akane

00:28:10,750 --> 00:28:16,720
things that break when you do that so

00:28:14,620 --> 00:28:18,460
clang thought that using under and a

00:28:16,720 --> 00:28:22,510
module under under wild compiles a

00:28:18,460 --> 00:28:25,210
module is a good idea and apparently the

00:28:22,510 --> 00:28:27,370
arm C++ compiler Forks thought they use

00:28:25,210 --> 00:28:28,780
that for something else so we have some

00:28:27,370 --> 00:28:30,640
third-party code in the code base that

00:28:28,780 --> 00:28:33,309
does weird things when it encounters

00:28:30,640 --> 00:28:38,679
that define and that leads to random

00:28:33,309 --> 00:28:41,950
crashes another interesting story what

00:28:38,679 --> 00:28:45,370
happened is that we pass all the module

00:28:41,950 --> 00:28:48,190
maps that describe to clang how we want

00:28:45,370 --> 00:28:52,480
to compile the modules on the command

00:28:48,190 --> 00:28:54,220
line and it turns out that these are so

00:28:52,480 --> 00:28:56,870
many more Maps again this is like just

00:28:54,220 --> 00:28:59,150
the huge scale of the Google codebase

00:28:56,870 --> 00:29:01,730
we actually broke the expectation of our

00:28:59,150 --> 00:29:04,669
build system on what the maximum command

00:29:01,730 --> 00:29:06,650
line length is what we did to work

00:29:04,669 --> 00:29:09,440
around that again is that we then ran

00:29:06,650 --> 00:29:12,860
some graph algorithm on our dependency

00:29:09,440 --> 00:29:15,470
graph to only pass the top modules on

00:29:12,860 --> 00:29:17,270
the command line but running those graph

00:29:15,470 --> 00:29:19,669
algorithm to take an expensive so that

00:29:17,270 --> 00:29:21,080
actually makes your build slower so we

00:29:19,669 --> 00:29:26,659
were basically fighting a bit with the

00:29:21,080 --> 00:29:30,020
build system yet and finally one of the

00:29:26,659 --> 00:29:32,029
core things if you implement modules in

00:29:30,020 --> 00:29:34,580
your codebase is that you have to think

00:29:32,029 --> 00:29:36,230
about your configuration and your

00:29:34,580 --> 00:29:38,480
configuration management what do I mean

00:29:36,230 --> 00:29:40,700
with that everybody basically uses a

00:29:38,480 --> 00:29:42,380
couple of macros to switch between

00:29:40,700 --> 00:29:43,850
different configurations for their

00:29:42,380 --> 00:29:45,620
project write an open source project

00:29:43,850 --> 00:29:51,350
that's often a conflict on edge that

00:29:45,620 --> 00:29:53,419
gets generated and with modules you

00:29:51,350 --> 00:29:55,850
cannot mix these configurations anymore

00:29:53,419 --> 00:29:58,429
right one of the core things is debug

00:29:55,850 --> 00:30:02,000
versus opt and for example the assert

00:29:58,429 --> 00:30:04,940
library behaves differently whether you

00:30:02,000 --> 00:30:08,510
have the an assert and debug macro

00:30:04,940 --> 00:30:12,770
defined or not so code that actually has

00:30:08,510 --> 00:30:16,279
a header that uses this library right

00:30:12,770 --> 00:30:19,880
for example with an assert behaves

00:30:16,279 --> 00:30:21,559
differently when compiled with modules

00:30:19,880 --> 00:30:26,120
or without modules when people try to

00:30:21,559 --> 00:30:27,740
actually manually define that macro so

00:30:26,120 --> 00:30:28,970
this code actually will give you

00:30:27,740 --> 00:30:30,950
currently with clang it will give you

00:30:28,970 --> 00:30:34,580
different results but the a dot H comes

00:30:30,950 --> 00:30:37,220
from a module that was compiled without

00:30:34,580 --> 00:30:42,529
the define or whether it's included

00:30:37,220 --> 00:30:45,820
naturally overall the problem here is

00:30:42,529 --> 00:30:49,130
that if you think about it you need a

00:30:45,820 --> 00:30:51,890
different header module for every

00:30:49,130 --> 00:30:58,159
possible combination of configuration

00:30:51,890 --> 00:31:00,260
flags you have that is mostly not

00:30:58,159 --> 00:31:02,929
actually as much as you would fear it

00:31:00,260 --> 00:31:05,450
might be right most code bases have a

00:31:02,929 --> 00:31:08,030
handful or if they are very large code

00:31:05,450 --> 00:31:10,890
bases they have might tens of different

00:31:08,030 --> 00:31:13,260
configurations so the overhead

00:31:10,890 --> 00:31:17,610
not that bad for now we actually decided

00:31:13,260 --> 00:31:20,100
that when you built you select one main

00:31:17,610 --> 00:31:23,130
configurations and that's what we built

00:31:20,100 --> 00:31:26,610
the header modules for and if any of the

00:31:23,130 --> 00:31:28,800
build files define some different

00:31:26,610 --> 00:31:30,660
combination or configurations we will

00:31:28,800 --> 00:31:33,120
just not build the header modules we

00:31:30,660 --> 00:31:44,930
will just continue to do textual

00:31:33,120 --> 00:31:49,590
inclusion so now we have implemented

00:31:44,930 --> 00:31:53,670
modules for the protocol buffer headers

00:31:49,590 --> 00:31:57,540
and we went over the code base and fixed

00:31:53,670 --> 00:32:00,840
all the problems our distributed build

00:31:57,540 --> 00:32:02,310
system now nicely supports modules we

00:32:00,840 --> 00:32:05,460
know that how we handle all the

00:32:02,310 --> 00:32:08,100
configurations so let's let's flip the

00:32:05,460 --> 00:32:10,230
switch and see what happens first let's

00:32:08,100 --> 00:32:11,720
look back at the graph where we were at

00:32:10,230 --> 00:32:13,890
when we started with this whole thing

00:32:11,720 --> 00:32:15,510
and this is what it looked like the

00:32:13,890 --> 00:32:18,810
problem is that this was now a couple of

00:32:15,510 --> 00:32:19,790
years ago and things had happened in the

00:32:18,810 --> 00:32:22,680
meantime

00:32:19,790 --> 00:32:27,720
specifically the graph now looks like

00:32:22,680 --> 00:32:31,340
this things had improved why did they

00:32:27,720 --> 00:32:34,050
improve well the problem was so bad that

00:32:31,340 --> 00:32:37,170
a different set of people actually went

00:32:34,050 --> 00:32:39,600
and fixed the problem in the protocol

00:32:37,170 --> 00:32:42,620
compiler like what I told you in the

00:32:39,600 --> 00:32:45,930
beginning one possible solution was to

00:32:42,620 --> 00:32:48,660
try to make the protocol compiler

00:32:45,930 --> 00:32:51,840
generated files not need all the

00:32:48,660 --> 00:32:55,080
includes and still have the performance

00:32:51,840 --> 00:32:58,080
of all the inline functions so we used a

00:32:55,080 --> 00:33:00,690
couple of template tricks to actually

00:32:58,080 --> 00:33:03,660
allow this and then migrated the whole

00:33:00,690 --> 00:33:09,060
code base to that model and that got us

00:33:03,660 --> 00:33:11,400
a lot of benefit so now let's see what

00:33:09,060 --> 00:33:13,020
happens is in this situation we switch

00:33:11,400 --> 00:33:15,620
on loads right at this point we were

00:33:13,020 --> 00:33:21,150
like well for we didn't expect that much

00:33:15,620 --> 00:33:24,419
let's see what happens well we were

00:33:21,150 --> 00:33:27,239
pretty much right right boss some

00:33:24,419 --> 00:33:29,369
all increase with a 10% further decrease

00:33:27,239 --> 00:33:32,159
of the average compile times nothing

00:33:29,369 --> 00:33:36,330
major but overall that's actually pretty

00:33:32,159 --> 00:33:38,970
nice because that 10% decrease in

00:33:36,330 --> 00:33:41,340
average compile times comes from a huge

00:33:38,970 --> 00:33:44,190
improvement in the 99th percentile and

00:33:41,340 --> 00:33:46,440
the 99th percentile is what's what was

00:33:44,190 --> 00:33:48,659
really bad right that's the I weighed

00:33:46,440 --> 00:33:56,279
one minute to get back that my semicolon

00:33:48,659 --> 00:33:58,019
is missing so that's pretty cool but one

00:33:56,279 --> 00:34:00,419
of the things we really had hoped for

00:33:58,019 --> 00:34:03,419
was that the load of our distributed

00:34:00,419 --> 00:34:05,519
system would decrease and we actually

00:34:03,419 --> 00:34:08,549
told the maintenance of our distributed

00:34:05,519 --> 00:34:10,379
build system with virtual modules will

00:34:08,549 --> 00:34:18,540
make your life easier and then this

00:34:10,379 --> 00:34:20,970
happened we actually doubled the load so

00:34:18,540 --> 00:34:25,349
what has happened we looked into that

00:34:20,970 --> 00:34:27,450
and turns out that we were just

00:34:25,349 --> 00:34:33,349
compiling more so on average we had a

00:34:27,450 --> 00:34:35,639
10% improvement and that translated to

00:34:33,349 --> 00:34:37,470
more than twice the number of

00:34:35,639 --> 00:34:39,929
translation units that we compile on

00:34:37,470 --> 00:34:43,290
average day so we have twice the amount

00:34:39,929 --> 00:34:45,720
of load where does this come from so to

00:34:43,290 --> 00:34:48,389
understand that we have to look into

00:34:45,720 --> 00:34:51,720
some more detail in like some

00:34:48,389 --> 00:34:54,299
idiosyncrasies of how our bit looks so

00:34:51,720 --> 00:34:55,919
we look at a more complex example here

00:34:54,299 --> 00:34:59,040
I'll explain it quickly right we have

00:34:55,919 --> 00:35:01,559
three libraries the LEP Lipsey Lipsy

00:34:59,040 --> 00:35:01,950
depends on the P the B depends on the

00:35:01,559 --> 00:35:05,339
Bay

00:35:01,950 --> 00:35:09,240
each of them has to had us write a1 a2

00:35:05,339 --> 00:35:11,819
b1 b2 c1 0 and it has very sparse

00:35:09,240 --> 00:35:13,680
dependencies actually right so we have a

00:35:11,819 --> 00:35:16,470
translation unit C dot c c that depends

00:35:13,680 --> 00:35:18,510
on c2 and the header c2 dot h just

00:35:16,470 --> 00:35:22,319
depends on like includes they had a bit

00:35:18,510 --> 00:35:24,809
would be do dot H and not neither b1 or

00:35:22,319 --> 00:35:27,630
b2 dot h include anything from the lip a

00:35:24,809 --> 00:35:30,180
and the delay dependency from the b2 lip

00:35:27,630 --> 00:35:33,030
a exists because there is a translation

00:35:30,180 --> 00:35:36,119
unit in Lippe that actually includes a

00:35:33,030 --> 00:35:37,989
header from Lib a and that's very

00:35:36,119 --> 00:35:40,430
typical of our corpus

00:35:37,989 --> 00:35:43,400
now if you remember in the traditional

00:35:40,430 --> 00:35:46,849
model when we compile this what would

00:35:43,400 --> 00:35:49,400
happen is that you to include scanning

00:35:46,849 --> 00:35:52,249
we would figure out that C dot C C only

00:35:49,400 --> 00:35:54,710
includes 0 C 2 dot H and P 2 dot H we

00:35:52,249 --> 00:35:57,799
would only send those to the to the

00:35:54,710 --> 00:36:00,259
worker only those are the inputs but now

00:35:57,799 --> 00:36:03,140
with our naive modules implementation

00:36:00,259 --> 00:36:06,799
what happens is that the number of

00:36:03,140 --> 00:36:09,410
inputs actually increases a lot so now

00:36:06,799 --> 00:36:12,109
we have all the header modules and the

00:36:09,410 --> 00:36:16,519
header files as input and that means two

00:36:12,109 --> 00:36:19,069
things first the time it takes to stage

00:36:16,519 --> 00:36:22,369
or the inputs to the remote machine

00:36:19,069 --> 00:36:26,739
actually increases a lot so we had this

00:36:22,369 --> 00:36:29,210
10% improvement in average compile time

00:36:26,739 --> 00:36:31,489
we had actually a much higher

00:36:29,210 --> 00:36:34,160
improvement in average compile time but

00:36:31,489 --> 00:36:36,829
that got eaten up basically nearly fully

00:36:34,160 --> 00:36:38,630
by the time it takes to just stage all

00:36:36,829 --> 00:36:43,039
the additional inputs like the the

00:36:38,630 --> 00:36:46,450
header modules to the machines but more

00:36:43,039 --> 00:36:49,640
importantly we now have more inputs and

00:36:46,450 --> 00:36:52,849
if an input changes you need to

00:36:49,640 --> 00:36:55,309
recompile your translation unit so

00:36:52,849 --> 00:36:57,319
previously right only if C 2 or B 2

00:36:55,309 --> 00:37:01,039
change we need to recompile seed or CC

00:36:57,319 --> 00:37:04,130
but now also if a1 dot H changes we need

00:37:01,039 --> 00:37:06,109
to recompile cc and that's really where

00:37:04,130 --> 00:37:07,609
this huge amount in new recompile

00:37:06,109 --> 00:37:10,130
culture right because we have a lot of

00:37:07,609 --> 00:37:12,440
paste libraries that very frequently

00:37:10,130 --> 00:37:16,579
change and now we just recompile the

00:37:12,440 --> 00:37:19,009
world over and over again the solution

00:37:16,579 --> 00:37:22,279
to that is basically translate the idea

00:37:19,009 --> 00:37:23,960
of include scanning 2 modules and the

00:37:22,279 --> 00:37:25,849
ideas that we do include scanning so we

00:37:23,960 --> 00:37:29,180
follow locally follow the set of

00:37:25,849 --> 00:37:32,420
includes that we find and every time we

00:37:29,180 --> 00:37:34,849
find an a header that is part of a

00:37:32,420 --> 00:37:38,539
module we mark that module as an input

00:37:34,849 --> 00:37:41,480
and all other modules are not inputs so

00:37:38,539 --> 00:37:44,329
in this case we can actually see that

00:37:41,480 --> 00:37:45,710
lip a module a dot PCM do not feel use

00:37:44,329 --> 00:37:48,109
we don't need to ship it it's not an

00:37:45,710 --> 00:37:49,640
input this is something we currently are

00:37:48,109 --> 00:37:51,200
in the process of rolling out we haven't

00:37:49,640 --> 00:37:53,810
rolled it out yet but

00:37:51,200 --> 00:37:56,119
results indicator that will actually get

00:37:53,810 --> 00:38:03,050
most of the problem of the increased

00:37:56,119 --> 00:38:06,200
load out of the way now if I if I do a

00:38:03,050 --> 00:38:08,119
very simple modification to this we

00:38:06,200 --> 00:38:09,710
still cannot solve that that they

00:38:08,119 --> 00:38:13,010
include skinny and that is we have an

00:38:09,710 --> 00:38:16,730
additional include from b1 dot H to a

00:38:13,010 --> 00:38:21,349
one dot H now the problem is that due to

00:38:16,730 --> 00:38:23,810
the way modules works the a naive

00:38:21,349 --> 00:38:26,420
include scanning would not find that but

00:38:23,810 --> 00:38:28,910
when we include scan from C dot C C 2 C

00:38:26,420 --> 00:38:30,710
2 dot H 2 balloon of H we now have to

00:38:28,910 --> 00:38:34,160
also include scan or the different

00:38:30,710 --> 00:38:36,050
headers in that module right because the

00:38:34,160 --> 00:38:41,150
compiler actually needs to know about

00:38:36,050 --> 00:38:44,810
these headers so remember in the old

00:38:41,150 --> 00:38:47,990
model we would just send Sidra - and B 2

00:38:44,810 --> 00:38:50,329
to the H but now we would again send

00:38:47,990 --> 00:38:52,089
everything what's the solution yet the

00:38:50,329 --> 00:38:55,250
only solution here we can think of is

00:38:52,089 --> 00:38:59,630
actually to make people split up

00:38:55,250 --> 00:39:02,240
libraries because if you look at it the

00:38:59,630 --> 00:39:05,180
headers in Libby are actually not

00:39:02,240 --> 00:39:07,099
tightly coupled so other headers in

00:39:05,180 --> 00:39:09,650
Lippitt right we have a complete

00:39:07,099 --> 00:39:12,829
different dependency graph so we can

00:39:09,650 --> 00:39:14,569
split up the libraries now we have three

00:39:12,829 --> 00:39:17,450
more libraries each with their own

00:39:14,569 --> 00:39:19,510
header and now we can we compile that as

00:39:17,450 --> 00:39:22,609
module we actually have exactly the same

00:39:19,510 --> 00:39:25,880
order of magnitude as input of inputs as

00:39:22,609 --> 00:39:29,060
in the traditional model now spring of

00:39:25,880 --> 00:39:36,710
libraries can sometimes be hard our goal

00:39:29,060 --> 00:39:40,910
is to give people tools to do that so to

00:39:36,710 --> 00:39:44,660
wrap it up the results we got were right

00:39:40,910 --> 00:39:47,180
we had 50% better compile times up to

00:39:44,660 --> 00:39:49,280
50% in the 99th percentile I think it

00:39:47,180 --> 00:39:52,339
was like 30% on average in the 99th

00:39:49,280 --> 00:39:54,640
visitor we had an average improvement of

00:39:52,339 --> 00:39:54,640
10%

00:39:54,700 --> 00:40:04,040
we had a large increase in the overall

00:39:57,290 --> 00:40:04,960
load of the system but on the upside we

00:40:04,040 --> 00:40:07,030
have unlocked

00:40:04,960 --> 00:40:09,220
a lot of optimization potential why is

00:40:07,030 --> 00:40:11,740
that right we have taken a lot of work

00:40:09,220 --> 00:40:14,170
that the compiler has to do and that it

00:40:11,740 --> 00:40:16,390
has no chance of not doing right it has

00:40:14,170 --> 00:40:18,400
to recompile all the files it sees we

00:40:16,390 --> 00:40:21,520
parse all the files it sees and we put

00:40:18,400 --> 00:40:24,040
that into the build system right and now

00:40:21,520 --> 00:40:25,599
in the build system we actually can pull

00:40:24,040 --> 00:40:27,130
a lot of tricks to make that faster

00:40:25,599 --> 00:40:29,890
that's something we were very good and

00:40:27,130 --> 00:40:34,030
we have a lot of ideas how to like make

00:40:29,890 --> 00:40:36,520
that significantly faster and also we

00:40:34,030 --> 00:40:40,270
gain some insight into how modules

00:40:36,520 --> 00:40:42,369
behaves what the corner cases are how to

00:40:40,270 --> 00:40:44,320
actually migrate a codebase and in the

00:40:42,369 --> 00:40:46,839
process we've actually got our code base

00:40:44,320 --> 00:40:49,450
a lot closer to what we think it will be

00:40:46,839 --> 00:40:53,380
once need to be once modules launches

00:40:49,450 --> 00:40:55,660
once modules is in the standard so that

00:40:53,380 --> 00:40:57,730
we can then migrate our code base to a

00:40:55,660 --> 00:41:02,440
like standardized modules module very

00:40:57,730 --> 00:41:04,780
quickly we have a couple of things that

00:41:02,440 --> 00:41:06,220
we learned that worked very well and we

00:41:04,780 --> 00:41:07,300
have a couple of things that didn't go

00:41:06,220 --> 00:41:10,480
as well let's look at the stuff that

00:41:07,300 --> 00:41:12,160
worked well right one very good thing

00:41:10,480 --> 00:41:13,869
about our code base is that we have a

00:41:12,160 --> 00:41:17,200
very strict style guide and people

00:41:13,869 --> 00:41:21,160
actually mostly adhere to it and that

00:41:17,200 --> 00:41:24,910
means that we had to fix things right

00:41:21,160 --> 00:41:27,160
the semantic problems but the order of

00:41:24,910 --> 00:41:29,619
magnitude of the fixes was tractable

00:41:27,160 --> 00:41:31,660
right it was a couple of ten to ten

00:41:29,619 --> 00:41:33,640
thousand fixes that's actually something

00:41:31,660 --> 00:41:40,060
like that takes a couple of days of work

00:41:33,640 --> 00:41:44,200
we have we have a lot of tools that help

00:41:40,060 --> 00:41:49,599
us migrate our code base at large that

00:41:44,200 --> 00:41:51,910
made it very easy and because of

00:41:49,599 --> 00:41:54,670
completely different reasons our code

00:41:51,910 --> 00:41:57,760
base already specified headers in the

00:41:54,670 --> 00:41:59,500
build files and that's also interesting

00:41:57,760 --> 00:42:01,210
because that helped us because

00:41:59,500 --> 00:42:04,240
specifying all the headers in the build

00:42:01,210 --> 00:42:06,730
files on its own is actually a very

00:42:04,240 --> 00:42:08,410
large project and we had started to do

00:42:06,730 --> 00:42:10,930
that for for different reasons because

00:42:08,410 --> 00:42:14,589
we actually want to control better what

00:42:10,930 --> 00:42:18,040
people can include a couple of years

00:42:14,589 --> 00:42:20,730
before that so that was also very nice

00:42:18,040 --> 00:42:20,730
we got lucky that

00:42:21,350 --> 00:42:24,780
couple of things that didn't go as

00:42:23,310 --> 00:42:27,450
expected right the performance

00:42:24,780 --> 00:42:29,820
improvement our predictions were not

00:42:27,450 --> 00:42:32,370
totally off but a couple of things

00:42:29,820 --> 00:42:35,790
obviously when differently from how we

00:42:32,370 --> 00:42:38,520
expected them turns out some broken code

00:42:35,790 --> 00:42:40,950
was hard to fix and mostly that was not

00:42:38,520 --> 00:42:44,490
the scale but for example when we

00:42:40,950 --> 00:42:45,930
modernized the STL and STL mode an STL

00:42:44,490 --> 00:42:48,930
implementation that's not written with

00:42:45,930 --> 00:42:50,790
modules in mind seems to be quite hard

00:42:48,930 --> 00:42:52,950
to modularize you have to talk with

00:42:50,790 --> 00:42:59,430
Richard or Chandler about that they will

00:42:52,950 --> 00:43:02,520
give you war stories modules makes the

00:42:59,430 --> 00:43:04,740
code harder to distribute so we actually

00:43:02,520 --> 00:43:06,750
had to put a lot of effort into making

00:43:04,740 --> 00:43:08,550
that work with our distributed build

00:43:06,750 --> 00:43:11,490
system right you saw most of the

00:43:08,550 --> 00:43:14,580
problems we had were due to interactions

00:43:11,490 --> 00:43:16,200
with the distributed businesses and also

00:43:14,580 --> 00:43:19,290
we lived on the bleeding edge of clang

00:43:16,200 --> 00:43:21,660
so we naturally ran into quite a bit of

00:43:19,290 --> 00:43:24,840
clang bugs Richard also always nicely

00:43:21,660 --> 00:43:27,900
quickly fix them but the Diagnostics if

00:43:24,840 --> 00:43:30,870
you if you get Diagnostics for bucks in

00:43:27,900 --> 00:43:38,810
your compiler that is often very

00:43:30,870 --> 00:43:38,810
challenging and with that questions

00:43:48,590 --> 00:43:54,330
so I may have missed it but I kept

00:43:51,390 --> 00:43:55,560
waiting for you to show a big picture of

00:43:54,330 --> 00:43:59,490
an elephant and say something about

00:43:55,560 --> 00:44:01,050
templates you will need to come to

00:43:59,490 --> 00:44:03,750
Richard's talk in the afternoon I think

00:44:01,050 --> 00:44:05,940
ok like yes Richard implemented the

00:44:03,750 --> 00:44:10,260
template merging and clang and that is a

00:44:05,940 --> 00:44:17,250
story on its own can you speak a little

00:44:10,260 --> 00:44:21,800
bit about what happened to link x ok can

00:44:17,250 --> 00:44:25,530
I speak about link x so we had some

00:44:21,800 --> 00:44:28,770
initial problems with link x mainly

00:44:25,530 --> 00:44:31,620
because of static initializers that

00:44:28,770 --> 00:44:34,560
showed up now in every module but we

00:44:31,620 --> 00:44:36,300
fixed that and I think link times were

00:44:34,560 --> 00:44:40,440
after that after the fixes link times

00:44:36,300 --> 00:44:42,810
were pretty much unaffected so you

00:44:40,440 --> 00:44:44,700
mentioned that you encourage your

00:44:42,810 --> 00:44:48,410
developers to break up libraries into

00:44:44,700 --> 00:44:51,840
smaller chunks aren't you concerned that

00:44:48,410 --> 00:44:55,200
the number of libraries will explode

00:44:51,840 --> 00:44:59,550
because of this and also that the the

00:44:55,200 --> 00:45:02,910
break lines would become slightly

00:44:59,550 --> 00:45:04,890
arbitrary along dependencies rather than

00:45:02,910 --> 00:45:08,820
a long functionality of course these too

00:45:04,890 --> 00:45:11,480
often align well but not always so the

00:45:08,820 --> 00:45:14,040
question is if I understand it correctly

00:45:11,480 --> 00:45:17,960
the idea to encourage developers to

00:45:14,040 --> 00:45:21,690
split up libraries more might lead to

00:45:17,960 --> 00:45:28,020
too many libraries or libraries that are

00:45:21,690 --> 00:45:30,870
not well cohesive so generally we found

00:45:28,020 --> 00:45:33,750
that developers tend to bundle too much

00:45:30,870 --> 00:45:35,430
into a library and the promise that that

00:45:33,750 --> 00:45:39,030
is also an incentive for you to write

00:45:35,430 --> 00:45:40,890
bad code because within the library we

00:45:39,030 --> 00:45:44,580
allow you to have cyclic dependencies

00:45:40,890 --> 00:45:46,770
and that means you split out less like

00:45:44,580 --> 00:45:49,050
you modernize your code less because you

00:45:46,770 --> 00:45:51,420
just have those include cycles within

00:45:49,050 --> 00:45:52,950
your library so you actually you

00:45:51,420 --> 00:45:54,270
actually start creating larger and

00:45:52,950 --> 00:45:57,030
larger blocks of things that are really

00:45:54,270 --> 00:45:59,290
hard to split apart but often you

00:45:57,030 --> 00:46:01,690
actually have things in in the

00:45:59,290 --> 00:46:03,100
that you would want to split apart that

00:46:01,690 --> 00:46:05,410
have completely different sets of

00:46:03,100 --> 00:46:07,120
dependencies right and that's really

00:46:05,410 --> 00:46:10,810
problematic because the set of

00:46:07,120 --> 00:46:13,090
dependencies means that if you if you

00:46:10,810 --> 00:46:15,370
have to if you have a library that has

00:46:13,090 --> 00:46:18,160
too many dependencies will be recompiled

00:46:15,370 --> 00:46:21,070
way too often and that's the case with

00:46:18,160 --> 00:46:22,930
modules and without modules though so I

00:46:21,070 --> 00:46:24,790
think for incentivizing people I

00:46:22,930 --> 00:46:27,370
actually think smaller libraries make

00:46:24,790 --> 00:46:29,050
for more modular command regarding the

00:46:27,370 --> 00:46:31,540
number of libraries we've not seen that

00:46:29,050 --> 00:46:31,750
our build system has any problems with

00:46:31,540 --> 00:46:33,820
that

00:46:31,750 --> 00:46:36,460
on the contrary because we have more

00:46:33,820 --> 00:46:39,370
precise dependency chains it leads to

00:46:36,460 --> 00:46:41,860
just less recompilation and less work

00:46:39,370 --> 00:46:47,770
you have to do in the build system thank

00:46:41,860 --> 00:46:50,350
you oh you've mentioned that this change

00:46:47,770 --> 00:46:52,870
enables you to have loads of

00:46:50,350 --> 00:46:54,180
optimization potential and what do we

00:46:52,870 --> 00:46:58,600
actually have in mind

00:46:54,180 --> 00:47:00,730
potential what so the question is I said

00:46:58,600 --> 00:47:03,400
we have optimization potential so you

00:47:00,730 --> 00:47:06,970
saw that for the overall load of the of

00:47:03,400 --> 00:47:09,280
our build system it went up but if you

00:47:06,970 --> 00:47:12,400
if you remember the the graph in the

00:47:09,280 --> 00:47:15,610
distributed build system you in the non

00:47:12,400 --> 00:47:17,260
modules case you reparse the the all the

00:47:15,610 --> 00:47:20,920
same headers over and over and over

00:47:17,260 --> 00:47:22,810
again so obviously there's potential to

00:47:20,920 --> 00:47:27,150
get rid of like we've got rid of some of

00:47:22,810 --> 00:47:30,580
that but we put that basically into the

00:47:27,150 --> 00:47:32,350
recompilation of the same translation

00:47:30,580 --> 00:47:34,180
unit to to dependency to to new

00:47:32,350 --> 00:47:36,550
dependencies and if we can get rid of

00:47:34,180 --> 00:47:39,010
those dependencies we reap both the

00:47:36,550 --> 00:47:40,810
benefits of not recompiling the same

00:47:39,010 --> 00:47:44,170
header as part of every translation unit

00:47:40,810 --> 00:47:46,120
as well as then not recompiling the same

00:47:44,170 --> 00:47:48,280
translation unit with modules because of

00:47:46,120 --> 00:47:50,830
increased dependencies so that's where

00:47:48,280 --> 00:47:53,440
we expect the the large decrease in

00:47:50,830 --> 00:47:56,500
overall load and also another decrease

00:47:53,440 --> 00:47:58,030
in compile time to come from also as you

00:47:56,500 --> 00:48:00,490
have seen with this merging example the

00:47:58,030 --> 00:48:06,550
more of your code base is motorized the

00:48:00,490 --> 00:48:09,520
more benefits you get out of it a few

00:48:06,550 --> 00:48:11,740
questions that I've got but maybe I'll

00:48:09,520 --> 00:48:14,680
just stick it to

00:48:11,740 --> 00:48:17,230
USU's unity builds at all or anything

00:48:14,680 --> 00:48:19,270
like that like see files including other

00:48:17,230 --> 00:48:22,030
C files so the question is whether we

00:48:19,270 --> 00:48:24,420
use unity builds the answer is no we

00:48:22,030 --> 00:48:27,369
generally don't believe in young cubits

00:48:24,420 --> 00:48:31,090
the other question then would be do you

00:48:27,369 --> 00:48:32,650
use shared libraries or dll's that might

00:48:31,090 --> 00:48:34,570
make it difficult to split your

00:48:32,650 --> 00:48:35,710
libraries like now the question is

00:48:34,570 --> 00:48:37,510
whether be you shared lobbies we

00:48:35,710 --> 00:48:40,180
actually do use currently few shared

00:48:37,510 --> 00:48:41,800
libraries when we build tests and we

00:48:40,180 --> 00:48:46,300
don't use shared libraries when we build

00:48:41,800 --> 00:48:48,070
stuff to deploy I don't understand so

00:48:46,300 --> 00:48:50,320
you mentioned that you think that that

00:48:48,070 --> 00:48:52,090
might be harder to split up libraries I

00:48:50,320 --> 00:48:54,880
don't understand why that would be so

00:48:52,090 --> 00:48:56,500
the core idea about our build system is

00:48:54,880 --> 00:49:00,340
that we always rebuild everything from

00:48:56,500 --> 00:49:03,910
scratch so we build shared libraries but

00:49:00,340 --> 00:49:06,130
we don't deploy them ever does that make

00:49:03,910 --> 00:49:07,660
sense so splitting it up will just split

00:49:06,130 --> 00:49:09,940
up the library into two shared libraries

00:49:07,660 --> 00:49:11,980
I'm thinking the problems around exports

00:49:09,940 --> 00:49:15,910
and imports and getting them correctly

00:49:11,980 --> 00:49:17,830
around circular dependencies would be my

00:49:15,910 --> 00:49:19,540
thoughts if you break the library at an

00:49:17,830 --> 00:49:22,660
arbitrary point it might be difficult to

00:49:19,540 --> 00:49:24,880
solve those so the problem is if you

00:49:22,660 --> 00:49:27,130
have circular dependencies splitting up

00:49:24,880 --> 00:49:29,530
libraries as how yeah that is true that

00:49:27,130 --> 00:49:31,390
is true in general our build system does

00:49:29,530 --> 00:49:34,960
not allow circular dependencies between

00:49:31,390 --> 00:49:37,630
libraries like and it never did so

00:49:34,960 --> 00:49:39,010
that's where why if you can split it in

00:49:37,630 --> 00:49:42,070
our build system you actually solve that

00:49:39,010 --> 00:49:43,900
problem Linux also allows circular

00:49:42,070 --> 00:49:49,480
dependencies between shared libraries I

00:49:43,900 --> 00:49:52,000
think so but anyway yes um do you have

00:49:49,480 --> 00:49:54,160
any insights into removing inline and

00:49:52,000 --> 00:49:56,500
using link time optimizations to offset

00:49:54,160 --> 00:49:58,420
the performance cost in order to get

00:49:56,500 --> 00:50:02,230
faster compile times so do we want to

00:49:58,420 --> 00:50:04,420
remove in line and use link time

00:50:02,230 --> 00:50:05,920
optimization so I'm not the expert on

00:50:04,420 --> 00:50:08,500
that you have to ask Chandler for the

00:50:05,920 --> 00:50:11,200
details but I think the high level is we

00:50:08,500 --> 00:50:14,170
have no plan to remove in line but we do

00:50:11,200 --> 00:50:19,270
actually develop link time optimizations

00:50:14,170 --> 00:50:21,910
because they have a lot you mentioned

00:50:19,270 --> 00:50:23,740
that there's analysis to understand

00:50:21,910 --> 00:50:25,029
dependencies that are declared but not

00:50:23,740 --> 00:50:29,289
actually used

00:50:25,029 --> 00:50:31,359
feedback into some kind of tooling so

00:50:29,289 --> 00:50:33,189
that you actually restructure your code

00:50:31,359 --> 00:50:36,099
and don't declare you don't actually

00:50:33,189 --> 00:50:37,599
have the include file for the module so

00:50:36,099 --> 00:50:39,909
we have dependencies that are not really

00:50:37,599 --> 00:50:41,619
used and the question is does that feel

00:50:39,909 --> 00:50:44,319
fit in the tooling actually we are

00:50:41,619 --> 00:50:46,150
currently building up tools to get that

00:50:44,319 --> 00:50:48,369
dependency better under control because

00:50:46,150 --> 00:50:52,499
partly because what we learned from the

00:50:48,369 --> 00:50:55,059
modules experiment and we learned that

00:50:52,499 --> 00:50:56,890
we really need to get our dependencies

00:50:55,059 --> 00:50:59,529
in order so we are currently building up

00:50:56,890 --> 00:51:01,419
tools to help you also split up

00:50:59,529 --> 00:51:03,130
libraries and which dependencies you

00:51:01,419 --> 00:51:06,400
want to delete that give you the most

00:51:03,130 --> 00:51:08,589
benefit and things like that so like

00:51:06,400 --> 00:51:12,249
clang include what you use is

00:51:08,589 --> 00:51:13,779
insufficient for this task to acclaim

00:51:12,249 --> 00:51:20,439
include what use is insufficient for

00:51:13,779 --> 00:51:22,449
this task yes hey to expect more build

00:51:20,439 --> 00:51:24,909
time improvements when modules become

00:51:22,449 --> 00:51:28,089
standard or you think you already take

00:51:24,909 --> 00:51:29,890
all the benefits do we expect more build

00:51:28,089 --> 00:51:35,049
time improvements when modules becomes

00:51:29,890 --> 00:51:36,909
standardized I think that's orthogonal I

00:51:35,049 --> 00:51:38,919
expect more build time improvements in

00:51:36,909 --> 00:51:41,650
the future all right

00:51:38,919 --> 00:51:44,019
richard has put some effort into making

00:51:41,650 --> 00:51:47,439
modules faster obviously but I think if

00:51:44,019 --> 00:51:50,349
we prioritize making clanks clanks

00:51:47,439 --> 00:51:52,689
module implementations faster that we

00:51:50,349 --> 00:51:55,359
can get additional time improvements but

00:51:52,689 --> 00:51:57,369
that is like what we know - how its

00:51:55,359 --> 00:51:58,959
standardized I think well depends on

00:51:57,369 --> 00:52:00,880
some of the standardization but that's

00:51:58,959 --> 00:52:06,269
all open so I don't know yet right

00:52:00,880 --> 00:52:09,219
thank you can you comment on other

00:52:06,269 --> 00:52:11,679
potential ideas for build improvements

00:52:09,219 --> 00:52:14,589
that were considered at Google let's say

00:52:11,679 --> 00:52:16,509
you know can we figure out what can be

00:52:14,589 --> 00:52:20,669
for our declared rather than you know

00:52:16,509 --> 00:52:23,559
including a header file or how about

00:52:20,669 --> 00:52:26,559
splitting header files into individual

00:52:23,559 --> 00:52:29,380
concepts so that header file would and

00:52:26,559 --> 00:52:31,449
have more than one class in it so that

00:52:29,380 --> 00:52:35,229
then we can benefit from incremental

00:52:31,449 --> 00:52:36,579
builds a little bit more because if

00:52:35,229 --> 00:52:38,740
there are changes to the hair file it

00:52:36,579 --> 00:52:41,110
would affect fewer CPP files that

00:52:38,740 --> 00:52:44,770
dependence on those things that are in

00:52:41,110 --> 00:52:49,630
the header file things like that

00:52:44,770 --> 00:52:51,400
have you guys done any like big changes

00:52:49,630 --> 00:52:54,280
like that across entire code base to

00:52:51,400 --> 00:53:00,250
simplifies those things so the question

00:52:54,280 --> 00:53:02,890
is how we split up libraries and the

00:53:00,250 --> 00:53:04,780
question is what you described is

00:53:02,890 --> 00:53:06,550
something that isn't applicable to many

00:53:04,780 --> 00:53:09,580
companies because modules it is a

00:53:06,550 --> 00:53:11,740
preparation for modules are there any

00:53:09,580 --> 00:53:14,530
other efforts like the protobuf that you

00:53:11,740 --> 00:53:17,500
described across entire google to speed

00:53:14,530 --> 00:53:20,440
up the build times let's say you know

00:53:17,500 --> 00:53:22,930
using for word declares is one you mean

00:53:20,440 --> 00:53:24,460
but there are efforts that were not like

00:53:22,930 --> 00:53:26,350
now we rolled out modules where the

00:53:24,460 --> 00:53:28,510
efforts before that to speed up build

00:53:26,350 --> 00:53:31,869
times without using modules right or in

00:53:28,510 --> 00:53:34,540
parallel okay well in parallel as you

00:53:31,869 --> 00:53:36,190
saw right we have actually got a lot of

00:53:34,540 --> 00:53:42,450
benefit out of changing the protocol

00:53:36,190 --> 00:53:44,710
compiler and we had some people

00:53:42,450 --> 00:53:46,359
investigating for example forward

00:53:44,710 --> 00:53:49,000
éclairs

00:53:46,359 --> 00:53:51,910
the interesting part was that from the

00:53:49,000 --> 00:53:54,790
start the forward declarations actually

00:53:51,910 --> 00:53:56,770
have different problems of because the

00:53:54,790 --> 00:54:00,390
problem is that they prevent you as a

00:53:56,770 --> 00:54:03,160
library maintainer from changing types

00:54:00,390 --> 00:54:06,250
without changing all the code so we

00:54:03,160 --> 00:54:07,930
actually never went very far into trying

00:54:06,250 --> 00:54:10,450
to force forward declares all over the

00:54:07,930 --> 00:54:12,880
codebase we have them obviously because

00:54:10,450 --> 00:54:15,430
of performance but we hope that we can

00:54:12,880 --> 00:54:19,660
get rid of them more in the modules

00:54:15,430 --> 00:54:22,150
world because they don't help well then

00:54:19,660 --> 00:54:25,000
they do still help some with the D

00:54:22,150 --> 00:54:27,910
coupling but it's also not really a

00:54:25,000 --> 00:54:29,320
decoupling so we hope we can live in a

00:54:27,910 --> 00:54:30,850
world where we don't need for vertically

00:54:29,320 --> 00:54:32,470
eration that's right this is just an

00:54:30,850 --> 00:54:35,980
example how about pimple pattern or

00:54:32,470 --> 00:54:37,810
something like that so the question is

00:54:35,980 --> 00:54:40,359
how about the implementers I'm not a big

00:54:37,810 --> 00:54:42,850
fan of the input pattern but just makes

00:54:40,359 --> 00:54:44,260
code more complex to work around your

00:54:42,850 --> 00:54:46,180
build system I think modules is the

00:54:44,260 --> 00:54:48,310
right solution that we have a

00:54:46,180 --> 00:54:50,230
fundamentally different compilation

00:54:48,310 --> 00:54:52,180
model that enables you to not need

00:54:50,230 --> 00:54:55,000
workarounds in your code and

00:54:52,180 --> 00:54:57,369
your code more complex just so that the

00:54:55,000 --> 00:54:59,500
compile doesn't like isn't completely

00:54:57,369 --> 00:55:04,480
crazy right got it

00:54:59,500 --> 00:55:05,800
Thanks am I correct and understanding

00:55:04,480 --> 00:55:07,869
that you have a one-to-one

00:55:05,800 --> 00:55:10,839
correspondence between libraries and

00:55:07,869 --> 00:55:13,690
modules there's one module per library

00:55:10,839 --> 00:55:14,650
one library promotional the question is

00:55:13,690 --> 00:55:17,260
whether we have a one-to-one

00:55:14,650 --> 00:55:20,349
correspondence between libraries and

00:55:17,260 --> 00:55:24,930
modules where modules are enabled

00:55:20,349 --> 00:55:27,040
currently yes so we also use a an

00:55:24,930 --> 00:55:31,450
implementation detail of clang that's

00:55:27,040 --> 00:55:32,710
that that sub modules but going into

00:55:31,450 --> 00:55:34,359
that would probably go too far but

00:55:32,710 --> 00:55:34,930
generally there's one library one module

00:55:34,359 --> 00:55:38,800
okay

00:55:34,930 --> 00:55:41,770
so within a single library do you get

00:55:38,800 --> 00:55:44,290
any benefit for modules then do we get

00:55:41,770 --> 00:55:52,720
benefits from modules within a single

00:55:44,290 --> 00:55:54,970
library I don't think so okay I come

00:55:52,720 --> 00:55:56,920
from the windows world and so I'm not up

00:55:54,970 --> 00:55:58,690
debated all the clang technologies

00:55:56,920 --> 00:56:00,849
however one of the things I kept

00:55:58,690 --> 00:56:03,069
expecting you to mention or at least

00:56:00,849 --> 00:56:04,599
would have some some talk about because

00:56:03,069 --> 00:56:07,780
I believe it is this is the concept of

00:56:04,599 --> 00:56:09,609
precompiled headers it was is that just

00:56:07,780 --> 00:56:11,799
not allowed in the distributed build

00:56:09,609 --> 00:56:13,780
system or can you talk about that so I I

00:56:11,799 --> 00:56:16,510
didn't mention it very shortly I think

00:56:13,780 --> 00:56:17,950
we have people look into precompiled

00:56:16,510 --> 00:56:20,829
headers and no precompiled headers in

00:56:17,950 --> 00:56:22,299
the windows world but the problem is the

00:56:20,829 --> 00:56:24,700
way you use precompiled headers there i

00:56:22,299 --> 00:56:26,140
think is that you very early on you

00:56:24,700 --> 00:56:28,150
decide you have a precompiled header

00:56:26,140 --> 00:56:29,530
this will be my precompiled header and i

00:56:28,150 --> 00:56:31,240
just put all the others headers into

00:56:29,530 --> 00:56:33,970
that and everybody includes that one

00:56:31,240 --> 00:56:36,430
header in a large to distribute code

00:56:33,970 --> 00:56:38,710
base that is problematic because you get

00:56:36,430 --> 00:56:40,510
this the single point of dependency

00:56:38,710 --> 00:56:44,200
where everything depends on and again

00:56:40,510 --> 00:56:45,790
you get this dependency like the recode

00:56:44,200 --> 00:56:47,680
like if any of the headers needs to be

00:56:45,790 --> 00:56:48,819
recompiled the precompiled header that

00:56:47,680 --> 00:56:49,359
precompiled header needs to be

00:56:48,819 --> 00:56:51,130
recompiled

00:56:49,359 --> 00:56:53,559
and everything that depends on it needs

00:56:51,130 --> 00:56:55,299
to be pre-compiled compiled and that's

00:56:53,559 --> 00:56:57,880
something we want to try to get rid of

00:56:55,299 --> 00:57:00,220
and also in a code base that was not

00:56:57,880 --> 00:57:02,049
written that way you don't naturally

00:57:00,220 --> 00:57:03,670
have those points so what people

00:57:02,049 --> 00:57:05,160
actually do is write you include one

00:57:03,670 --> 00:57:06,630
header from this library one header from

00:57:05,160 --> 00:57:07,770
library and somebody else includes the

00:57:06,630 --> 00:57:09,990
other header from this and the other

00:57:07,770 --> 00:57:11,670
handle from that library and we actually

00:57:09,990 --> 00:57:13,859
had people go in and try to use

00:57:11,670 --> 00:57:15,660
precompiled headers but because they

00:57:13,859 --> 00:57:18,750
needed to keep the code compiling

00:57:15,660 --> 00:57:20,789
because we also didn't have a probe like

00:57:18,750 --> 00:57:22,650
there was no idea that modules would

00:57:20,789 --> 00:57:24,390
come and actually require everybody to

00:57:22,650 --> 00:57:29,180
rethink how they think about semantics

00:57:24,390 --> 00:57:32,309
of C++ anyway that completely failed and

00:57:29,180 --> 00:57:34,079
another unrelated question you would

00:57:32,309 --> 00:57:37,200
mention that you're trying hard to get

00:57:34,079 --> 00:57:40,280
your dependencies together our company

00:57:37,200 --> 00:57:42,960
is doing that as well do you have any

00:57:40,280 --> 00:57:45,510
interesting or useful visualization

00:57:42,960 --> 00:57:47,910
tools to see the dependency graph

00:57:45,510 --> 00:57:49,680
between headers and and libraries and

00:57:47,910 --> 00:57:51,539
whatnot or have you developed those or

00:57:49,680 --> 00:57:53,280
do you find those useful so the question

00:57:51,539 --> 00:57:55,500
is do we have visualization tools for

00:57:53,280 --> 00:57:57,599
our dependencies so we have people who

00:57:55,500 --> 00:57:59,460
have hacked together tools like websites

00:57:57,599 --> 00:58:03,000
where you can watch the dependencies and

00:57:59,460 --> 00:58:06,030
it's not helpful if you want to see

00:58:03,000 --> 00:58:08,789
spaghetti yes you see spaghetti we have

00:58:06,030 --> 00:58:11,160
actually created tools that help you

00:58:08,789 --> 00:58:14,099
guide which dependencies are actually

00:58:11,160 --> 00:58:16,770
important and you need to look at as a

00:58:14,099 --> 00:58:18,539
human it's just so much code and like

00:58:16,770 --> 00:58:20,849
right it's much of a hundred million

00:58:18,539 --> 00:58:23,430
lines of C++ code if you look at that

00:58:20,849 --> 00:58:25,380
depends if you have you seen nothing but

00:58:23,430 --> 00:58:27,630
for a tool it can actually figure out so

00:58:25,380 --> 00:58:30,480
if you if you if you remove these five

00:58:27,630 --> 00:58:32,250
dependencies now suddenly you actually

00:58:30,480 --> 00:58:34,500
have two components that are completely

00:58:32,250 --> 00:58:36,450
split apart and you will say that many

00:58:34,500 --> 00:58:39,029
test runs from running than anything in

00:58:36,450 --> 00:58:40,410
the transitive closure changes and those

00:58:39,029 --> 00:58:41,700
things those things are the things we're

00:58:40,410 --> 00:58:46,349
focusing on and less on visitor

00:58:41,700 --> 00:58:49,559
visualization thank you all right just a

00:58:46,349 --> 00:58:52,020
simple question why did you choose to

00:58:49,559 --> 00:58:55,470
distinguish between modular and non

00:58:52,020 --> 00:58:58,200
modular headers and describe those

00:58:55,470 --> 00:59:00,510
modules explicitly in your build files

00:58:58,200 --> 00:59:03,210
instead of just generating a PCM file

00:59:00,510 --> 00:59:05,809
out of every header you have to speed up

00:59:03,210 --> 00:59:08,279
the build process so why did we not just

00:59:05,809 --> 00:59:10,559
create modules like switch on modules

00:59:08,279 --> 00:59:12,240
everywhere basically it doesn't work

00:59:10,559 --> 00:59:16,529
because most of the code like you have

00:59:12,240 --> 00:59:19,670
to change code in order to in order to

00:59:16,529 --> 00:59:19,670
make it work with Moya's

00:59:20,089 --> 00:59:26,390

YouTube URL: https://www.youtube.com/watch?v=dHFNpBfemDI


