Title: CppCon 2016: Erik Smith “A modern database interface for C++"
Publication date: 2016-10-02
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
C++ has historically had many options for database connectivity but has lacked a standard interface that other languages, such as Java, have had for a long time. This talk will present a standards grade interface along with experience with a reference implementation that includes support for at least 6 databases. A key aspect of the design is to show how modern C++ features can be used to achieve a high degree of both efficiency and ease-of-use. Specific features to be covered will include type conversion, connection pooling, I/O binding for scalars and arrays, row sets, direct/polymorphic interfaces, policy based design, the driver interface, and details on the implementation. Forward looking standards proposals, such as ranges and variants, will also be included in the discussion. 
— 
Erik Smith
Engineering Manager, TranscendInsights
Erik Smith is a member of the clinical analytics team at Transcend Insights in San Diego. Erik is a specialist in building high performance full stack applications. He is a co-founder of AppFluent, a maker of database caching technology and analytic monitoring software. He has a diverse background in the development of C++ applications involving database interfaces and in the implementation of database engines.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,230
thanks for coming to my talk today I'm

00:00:02,399 --> 00:00:10,400
going to talk about modern database

00:00:04,230 --> 00:00:10,400
interface for C++ my name is Eric Smith

00:00:10,580 --> 00:00:17,670
so first of all why do we care I'm going

00:00:15,240 --> 00:00:19,619
to try and boil this down to just two

00:00:17,670 --> 00:00:21,029
data points is there a lot there are a

00:00:19,619 --> 00:00:23,460
lot of reasons why me we might care

00:00:21,029 --> 00:00:26,279
about this they're probably pretty

00:00:23,460 --> 00:00:27,900
obvious but I just I'll just put these

00:00:26,279 --> 00:00:30,900
two data points so if you think of a

00:00:27,900 --> 00:00:33,180
database like sequel light sequel light

00:00:30,900 --> 00:00:35,250
is installed on every smartphone in the

00:00:33,180 --> 00:00:38,430
world I tried to Google what that number

00:00:35,250 --> 00:00:41,430
is but I have to think it's in the

00:00:38,430 --> 00:00:44,250
billions at this point so databases

00:00:41,430 --> 00:00:45,570
literally are everywhere and I'm sure

00:00:44,250 --> 00:00:49,020
probably everybody in this room has

00:00:45,570 --> 00:00:52,110
probably encountered a database if not

00:00:49,020 --> 00:00:55,070
on every project at least on many of

00:00:52,110 --> 00:01:00,120
them so they really are everywhere a

00:00:55,070 --> 00:01:03,260
second data point is has to do with JDBC

00:01:00,120 --> 00:01:06,270
so and this this talk very much is about

00:01:03,260 --> 00:01:10,380
that layer of the stack which I'll get

00:01:06,270 --> 00:01:13,650
into in a moment jdb JDBC was introduced

00:01:10,380 --> 00:01:16,439
in 1998 and I think a large part of the

00:01:13,650 --> 00:01:19,470
success of Java and its domain has to do

00:01:16,439 --> 00:01:24,290
with the fact that you get that

00:01:19,470 --> 00:01:27,450
connectivity very easily and here it is

00:01:24,290 --> 00:01:28,680
2016 and we do not have a standard

00:01:27,450 --> 00:01:31,320
interface it's not that we don't build

00:01:28,680 --> 00:01:33,090
databases with C++ it just isn't

00:01:31,320 --> 00:01:36,900
something we the standard doesn't help

00:01:33,090 --> 00:01:39,420
us at all here so I did not name this

00:01:36,900 --> 00:01:40,740
talk a standard database for C++ because

00:01:39,420 --> 00:01:43,829
I think it's going to take quite a bit

00:01:40,740 --> 00:01:45,390
of time to get a standard push through

00:01:43,829 --> 00:01:48,060
so I'm just gonna call it a modern

00:01:45,390 --> 00:01:49,560
interface I just want to acknowledge

00:01:48,060 --> 00:01:52,530
some previous repose to work in this

00:01:49,560 --> 00:01:55,470
area by these individuals and I have

00:01:52,530 --> 00:01:56,850
read them and there were there are

00:01:55,470 --> 00:02:01,619
points from each of these that I have

00:01:56,850 --> 00:02:03,390
taken so credit to them so just a little

00:02:01,619 --> 00:02:05,399
bit of a primer here for those who may

00:02:03,390 --> 00:02:06,920
not be familiar with this this is just a

00:02:05,399 --> 00:02:09,929
quick picture of the relational model

00:02:06,920 --> 00:02:13,560
this is a type of structured data that

00:02:09,929 --> 00:02:15,150
you get out of a database and it's

00:02:13,560 --> 00:02:18,569
it's really straightforward you just

00:02:15,150 --> 00:02:21,270
have columns that define a datatype per

00:02:18,569 --> 00:02:22,680
column and the rows so this is a type of

00:02:21,270 --> 00:02:25,590
structure information stored in the

00:02:22,680 --> 00:02:27,900
database it's also the same structure

00:02:25,590 --> 00:02:31,050
that you get back from the client api's

00:02:27,900 --> 00:02:33,150
as well so this is this is what you'll

00:02:31,050 --> 00:02:35,340
this is what the type of data that this

00:02:33,150 --> 00:02:38,580
interface is designed to work with that

00:02:35,340 --> 00:02:40,200
the second item on the below that is an

00:02:38,580 --> 00:02:42,330
example of a sequel query which I'm sure

00:02:40,200 --> 00:02:45,510
no doubt probably all of you have worked

00:02:42,330 --> 00:02:47,250
with this is an example of a text query

00:02:45,510 --> 00:02:50,220
that you use to pull data out of a

00:02:47,250 --> 00:02:51,830
database and for the purposes of the

00:02:50,220 --> 00:02:56,220
interface which I'm going to show today

00:02:51,830 --> 00:02:58,799
I'm gonna call this a row set just

00:02:56,220 --> 00:03:00,780
because that's how I've named it so

00:02:58,799 --> 00:03:02,250
let's take a look at the client stack

00:03:00,780 --> 00:03:04,349
for this for a moment that the areas in

00:03:02,250 --> 00:03:07,170
blue are really the areas I'm focused on

00:03:04,349 --> 00:03:09,330
and I talked about what this talk what

00:03:07,170 --> 00:03:13,489
the focus of this project is and what it

00:03:09,330 --> 00:03:15,959
is not so I know that there's a lot of

00:03:13,489 --> 00:03:17,579
existing work one particular project

00:03:15,959 --> 00:03:20,910
there are a couple projects that are

00:03:17,579 --> 00:03:23,430
focusing a higher layer of the stack in

00:03:20,910 --> 00:03:30,030
addition to the layer on focus focus on

00:03:23,430 --> 00:03:33,120
which is like Roland's CCPP project I'm

00:03:30,030 --> 00:03:35,400
focusing on the driver layer itself and

00:03:33,120 --> 00:03:37,109
I think the main reason for this is I

00:03:35,400 --> 00:03:40,019
think this is a really necessary

00:03:37,109 --> 00:03:42,389
foundational layer for other types of

00:03:40,019 --> 00:03:44,910
interesting work to be built on top of

00:03:42,389 --> 00:03:46,350
and there's just a lot of details to get

00:03:44,910 --> 00:03:49,590
right in this layer so it's really a

00:03:46,350 --> 00:03:52,980
project in and of itself just to

00:03:49,590 --> 00:03:55,650
describe a little bit of detail on this

00:03:52,980 --> 00:03:58,040
stack you've got application code which

00:03:55,650 --> 00:04:01,769
can either be built directly on top of

00:03:58,040 --> 00:04:04,290
this interface like it is some in case

00:04:01,769 --> 00:04:06,389
cases with JDBC or you can have an

00:04:04,290 --> 00:04:07,950
ecosystem on top of this layer which is

00:04:06,389 --> 00:04:11,340
where other things can be build things

00:04:07,950 --> 00:04:12,660
just like straight database utility code

00:04:11,340 --> 00:04:15,090
on top of it

00:04:12,660 --> 00:04:18,200
lightweight Clery query builders or

00:04:15,090 --> 00:04:21,000
full-blown or EMM frameworks can exist

00:04:18,200 --> 00:04:25,650
on top of this layer now as far as the

00:04:21,000 --> 00:04:26,909
layer itself I'm going to describe later

00:04:25,650 --> 00:04:27,389
in the talk the design of this layer

00:04:26,909 --> 00:04:30,270
because there

00:04:27,389 --> 00:04:33,449
a front-end layer which is intended for

00:04:30,270 --> 00:04:35,550
people writing user code and then

00:04:33,449 --> 00:04:37,020
there's a driver layer in which you

00:04:35,550 --> 00:04:38,310
would want where you be interesting that

00:04:37,020 --> 00:04:40,830
if you were implementing a particular

00:04:38,310 --> 00:04:43,740
database driver and then on the bottom

00:04:40,830 --> 00:04:46,430
we just have the client interfaces for

00:04:43,740 --> 00:04:49,319
the various database drivers sometimes

00:04:46,430 --> 00:04:51,330
they're written against those interfaces

00:04:49,319 --> 00:04:53,969
sometimes they're written against just

00:04:51,330 --> 00:04:56,580
plain sockets if the protocol for the

00:04:53,969 --> 00:04:59,849
database is known there's other options

00:04:56,580 --> 00:05:03,210
for the future such as fibers and

00:04:59,849 --> 00:05:06,150
co-routines so just to get into it in

00:05:03,210 --> 00:05:11,340
detail here I'm I'm going to show you an

00:05:06,150 --> 00:05:15,000
example of what this is and the code has

00:05:11,340 --> 00:05:16,529
been I this is not just this is code

00:05:15,000 --> 00:05:18,810
that I have that's working so I've given

00:05:16,529 --> 00:05:21,599
the examples I've in this talk some a

00:05:18,810 --> 00:05:23,699
bit of time to ensure that this is

00:05:21,599 --> 00:05:25,469
actually a workable interface although

00:05:23,699 --> 00:05:28,800
there's plenty of work to be done but

00:05:25,469 --> 00:05:32,099
this this needs to be an easy to use

00:05:28,800 --> 00:05:35,279
interface first and foremost so I hope

00:05:32,099 --> 00:05:38,159
that what this conveys is that it's it's

00:05:35,279 --> 00:05:41,270
a pretty easy interface to use I don't

00:05:38,159 --> 00:05:43,800
want to sacrifice any functionality in

00:05:41,270 --> 00:05:45,000
favor of that but we'll get into the

00:05:43,800 --> 00:05:48,860
functionality as we go through the talk

00:05:45,000 --> 00:05:52,169
so a couple things to notice here

00:05:48,860 --> 00:05:54,330
there's no explicit types mentioned here

00:05:52,169 --> 00:05:58,889
so this is this is using that the

00:05:54,330 --> 00:06:01,110
chained call style which I'll talk about

00:05:58,889 --> 00:06:05,069
in a minute but it's I think this lends

00:06:01,110 --> 00:06:06,649
to a very succinct and compact style now

00:06:05,069 --> 00:06:09,960
a few other details for that example

00:06:06,649 --> 00:06:12,060
that I want to throw in here is that you

00:06:09,960 --> 00:06:15,270
would have to have a and include and you

00:06:12,060 --> 00:06:16,919
would want to alias a namespace so when

00:06:15,270 --> 00:06:18,629
I talk about this being a standards

00:06:16,919 --> 00:06:21,659
candidate I don't think we're ever going

00:06:18,629 --> 00:06:24,629
to see actual drivers in the vendor

00:06:21,659 --> 00:06:26,849
implementations that doesn't seem likely

00:06:24,629 --> 00:06:28,860
to me so the idea here is you'd want it

00:06:26,849 --> 00:06:31,110
to be as to seem as uniform as possible

00:06:28,860 --> 00:06:33,349
so the way you can do this is including

00:06:31,110 --> 00:06:36,209
a header for your particular

00:06:33,349 --> 00:06:38,009
implementation which may or may be

00:06:36,209 --> 00:06:41,129
provided by the compiler but I don't

00:06:38,009 --> 00:06:43,860
think so and then just create an alias

00:06:41,129 --> 00:06:45,319
Elya so that you have consistency among

00:06:43,860 --> 00:06:48,119
your interface if you want to switch

00:06:45,319 --> 00:06:49,619
vendors you can do that when I say

00:06:48,119 --> 00:06:51,419
vendors I really mean open source

00:06:49,619 --> 00:06:52,589
efforts and that's what this is this

00:06:51,419 --> 00:06:54,300
particular effort is a reference

00:06:52,589 --> 00:06:55,019
implementation for the interface I'm

00:06:54,300 --> 00:06:57,269
proposing

00:06:55,019 --> 00:07:02,249
so without addition you have a fully

00:06:57,269 --> 00:07:04,889
working example so a little more on this

00:07:02,249 --> 00:07:07,769
style of interface this is a composable

00:07:04,889 --> 00:07:09,929
interface it's using a classic method

00:07:07,769 --> 00:07:16,979
chaining approach which is really been

00:07:09,929 --> 00:07:18,240
around for a long time and this I'm not

00:07:16,979 --> 00:07:23,189
sure if everybody likes this but I think

00:07:18,240 --> 00:07:25,649
it's I think it's it's a it's completely

00:07:23,189 --> 00:07:27,959
appropriate for this particular model

00:07:25,649 --> 00:07:29,580
and I think it has a little recent

00:07:27,959 --> 00:07:32,309
support added to it with some of the

00:07:29,580 --> 00:07:34,649
proposals for uniform function call

00:07:32,309 --> 00:07:36,419
syntax so that would suggest so there

00:07:34,649 --> 00:07:38,789
are people on the committee who like

00:07:36,419 --> 00:07:40,499
this style and and want to promote it

00:07:38,789 --> 00:07:42,110
with this kind of work now this this

00:07:40,499 --> 00:07:45,360
isn't has made in the standard but

00:07:42,110 --> 00:07:47,159
yharnam South has supported that

00:07:45,360 --> 00:07:51,779
proposal so and that's a proposal where

00:07:47,159 --> 00:07:54,119
if a method call fails to resolve it

00:07:51,779 --> 00:07:55,559
will call a non-member function so you

00:07:54,119 --> 00:07:57,240
can retain the chaining call and not

00:07:55,559 --> 00:07:59,099
have to have everything be a member

00:07:57,240 --> 00:08:05,039
function although most of the ones in

00:07:59,099 --> 00:08:07,379
this core interface are one thing I

00:08:05,039 --> 00:08:08,939
should mention here is that all of the

00:08:07,379 --> 00:08:11,339
examples here until later in the talk

00:08:08,939 --> 00:08:13,860
our direct interfaces by that I mean

00:08:11,339 --> 00:08:15,689
that most people when they implement a

00:08:13,860 --> 00:08:17,909
database are just coding against one

00:08:15,689 --> 00:08:20,699
database and if that's all you're doing

00:08:17,909 --> 00:08:22,559
you should be able to do that without

00:08:20,699 --> 00:08:24,149
going through our extra layers of

00:08:22,559 --> 00:08:25,559
indirection and that's supported by this

00:08:24,149 --> 00:08:28,499
driver you can either say I'm only using

00:08:25,559 --> 00:08:29,909
my sukul or only using sequel Lite or we

00:08:28,499 --> 00:08:32,430
as we'll see you later in the talk you

00:08:29,909 --> 00:08:35,159
can you can access a poly interface

00:08:32,430 --> 00:08:36,990
which is the exact same interface but

00:08:35,159 --> 00:08:42,180
allows you to resolve to a particular

00:08:36,990 --> 00:08:43,680
driver at runtime so let's look at the

00:08:42,180 --> 00:08:45,000
various types in this interface and

00:08:43,680 --> 00:08:47,670
these should be pretty familiar to

00:08:45,000 --> 00:08:50,670
anybody's who has used any type of other

00:08:47,670 --> 00:08:54,230
library that's it's they're all fairly

00:08:50,670 --> 00:08:55,940
similar in the end the types I declare

00:08:54,230 --> 00:08:58,760
and database interfaces are all about

00:08:55,940 --> 00:09:01,730
managing resources so each one of these

00:08:58,760 --> 00:09:03,890
is paired with a resource that needs to

00:09:01,730 --> 00:09:05,060
be managed on the client layer so just

00:09:03,890 --> 00:09:06,350
going through these pretty quickly

00:09:05,060 --> 00:09:09,290
you've got the database which is a

00:09:06,350 --> 00:09:11,500
top-level context the connection is

00:09:09,290 --> 00:09:16,570
maintains a connection to the server

00:09:11,500 --> 00:09:20,390
these are all REI I type interfaces

00:09:16,570 --> 00:09:23,450
statement for query execution primarily

00:09:20,390 --> 00:09:24,680
statement not only manages things behind

00:09:23,450 --> 00:09:26,000
the scenes but if you need prepared

00:09:24,680 --> 00:09:28,100
statements that's which that's why

00:09:26,000 --> 00:09:31,370
you'll need a statement column set is

00:09:28,100 --> 00:09:35,260
from for metadata for columns a column

00:09:31,370 --> 00:09:38,060
is of specific metadata for a column or

00:09:35,260 --> 00:09:39,950
metadata for a specific column the row

00:09:38,060 --> 00:09:43,730
set that's the primary data structure in

00:09:39,950 --> 00:09:47,330
this API that is probably most important

00:09:43,730 --> 00:09:50,450
here a row accessor is just a particular

00:09:47,330 --> 00:09:52,100
row within that row set and field now

00:09:50,450 --> 00:09:53,480
these last two do tell us two objects

00:09:52,100 --> 00:09:56,780
are proxies and we're gonna we're gonna

00:09:53,480 --> 00:09:59,120
get into that what that means so just

00:09:56,780 --> 00:10:01,160
just to break this out a little bit more

00:09:59,120 --> 00:10:03,320
so you can see that the types more

00:10:01,160 --> 00:10:05,810
clearly this is the same example but

00:10:03,320 --> 00:10:07,430
just in a more classic form a non

00:10:05,810 --> 00:10:09,350
chained form where you can see each of

00:10:07,430 --> 00:10:11,240
the individual types in action here

00:10:09,350 --> 00:10:14,390
still not having to refer to the types

00:10:11,240 --> 00:10:15,980
but in this case you can see a broken

00:10:14,390 --> 00:10:18,320
out you can see clearly the database

00:10:15,980 --> 00:10:19,550
being connected to or the database being

00:10:18,320 --> 00:10:22,340
created then the connection then the

00:10:19,550 --> 00:10:27,980
query then the rows and then just a more

00:10:22,340 --> 00:10:29,600
C++ 98 style of for loop a little bit

00:10:27,980 --> 00:10:33,110
about the methods here so I think

00:10:29,600 --> 00:10:36,770
there's I've actually have two styles

00:10:33,110 --> 00:10:38,810
here one is what I'll collide by type

00:10:36,770 --> 00:10:41,570
name and this is where the accessors on

00:10:38,810 --> 00:10:43,400
these class refer to are just analogous

00:10:41,570 --> 00:10:45,110
to the types themselves so if you if you

00:10:43,400 --> 00:10:48,620
want to connect if you want a connection

00:10:45,110 --> 00:10:51,440
object the name of that access ER is

00:10:48,620 --> 00:10:53,360
just connection versus a natural style

00:10:51,440 --> 00:10:59,270
which is more like a noun or a verb

00:10:53,360 --> 00:11:01,340
where you say connect query rows I

00:10:59,270 --> 00:11:03,110
prefer the natural style but I can see

00:11:01,340 --> 00:11:04,580
use cases for both so they're both in

00:11:03,110 --> 00:11:05,870
the interface at this point now maybe

00:11:04,580 --> 00:11:08,160
somebody will come along at some point

00:11:05,870 --> 00:11:10,259
you must choose between one or the other

00:11:08,160 --> 00:11:12,540
but nothing here standardized for so for

00:11:10,259 --> 00:11:16,829
every I'm keeping options open here just

00:11:12,540 --> 00:11:20,459
by having both of these available this

00:11:16,829 --> 00:11:23,129
interfaces should be flexible so all of

00:11:20,459 --> 00:11:24,689
these statements are equivalent so one

00:11:23,129 --> 00:11:27,300
of the things I mentioned that this

00:11:24,689 --> 00:11:29,279
design has a front-end layer and a

00:11:27,300 --> 00:11:31,319
driver layer the front-end is common to

00:11:29,279 --> 00:11:33,269
everything and is not is not anything

00:11:31,319 --> 00:11:35,430
anybody needs to extend the driver

00:11:33,269 --> 00:11:39,540
layers where the extension is done so

00:11:35,430 --> 00:11:41,000
because of that design it's easy to

00:11:39,540 --> 00:11:46,680
achieve this what I mean by this is that

00:11:41,000 --> 00:11:48,360
if you want to query something you can

00:11:46,680 --> 00:11:49,860
do it from the database you can do it

00:11:48,360 --> 00:11:52,529
from the statement you can do it from

00:11:49,860 --> 00:11:57,689
the connection all of these are ok so

00:11:52,529 --> 00:11:59,550
this leads to a flexible style in which

00:11:57,689 --> 00:12:01,079
whatever object you happen to have at

00:11:59,550 --> 00:12:03,149
the time if you want to do a particular

00:12:01,079 --> 00:12:12,620
operation that makes sense you can do

00:12:03,149 --> 00:12:14,819
that and it's hard to get wrong ok so

00:12:12,620 --> 00:12:17,850
one thing I should mention here is all

00:12:14,819 --> 00:12:19,410
of these objects are what I call

00:12:17,850 --> 00:12:22,589
reference types and what I mean by that

00:12:19,410 --> 00:12:26,130
is they're all holding standards shared

00:12:22,589 --> 00:12:27,689
pointer to internal data now this if

00:12:26,130 --> 00:12:29,040
you've tried to hand roll your

00:12:27,689 --> 00:12:31,649
interfaces before you may have not have

00:12:29,040 --> 00:12:33,480
seen this detail you don't actually need

00:12:31,649 --> 00:12:34,920
that if all your example such as the

00:12:33,480 --> 00:12:38,730
ones that we've seen on the previous

00:12:34,920 --> 00:12:40,589
lights are all nested within the same

00:12:38,730 --> 00:12:42,990
scope there's no need to have a smart

00:12:40,589 --> 00:12:46,069
pointer in this context but as soon as

00:12:42,990 --> 00:12:49,380
you get to a use case where you have a

00:12:46,069 --> 00:12:51,870
let's say some type of utility function

00:12:49,380 --> 00:12:53,430
where you want to pass in some some user

00:12:51,870 --> 00:12:57,180
data and you want to get a row set out

00:12:53,430 --> 00:13:00,470
of that now it makes total sense why

00:12:57,180 --> 00:13:02,910
they should be reference types that are

00:13:00,470 --> 00:13:04,829
that you share pointer and the reason

00:13:02,910 --> 00:13:08,339
here is that you'll notice inside of

00:13:04,829 --> 00:13:10,980
this utility function I'm creating a

00:13:08,339 --> 00:13:13,649
database context and implicitly getting

00:13:10,980 --> 00:13:16,279
a connection via this query accessor and

00:13:13,649 --> 00:13:18,779
then I get the row set as well and

00:13:16,279 --> 00:13:20,610
unfortunately missing a return statement

00:13:18,779 --> 00:13:21,810
in there but there should be right at

00:13:20,610 --> 00:13:24,750
the DB line

00:13:21,810 --> 00:13:26,220
this is going to return a result there's

00:13:24,750 --> 00:13:28,560
nothing wrong with this it's it's safe

00:13:26,220 --> 00:13:30,330
to do this because the rosette is going

00:13:28,560 --> 00:13:34,380
to hold the state information it needs

00:13:30,330 --> 00:13:35,640
until it goes out of scope so this and

00:13:34,380 --> 00:13:37,200
this would be the kind of thing you

00:13:35,640 --> 00:13:38,760
would do when you reach a certain design

00:13:37,200 --> 00:13:40,740
level in your application you want to

00:13:38,760 --> 00:13:43,650
design for this so therefore they hold

00:13:40,740 --> 00:13:46,650
reference types and don't think that

00:13:43,650 --> 00:13:49,560
impacts the performance at all however

00:13:46,650 --> 00:13:51,029
there's also a policy capability the API

00:13:49,560 --> 00:13:53,460
if you really if you really care about

00:13:51,029 --> 00:13:58,410
that you can specify a policy not to do

00:13:53,460 --> 00:13:59,670
that okay so I'm gonna go through a

00:13:58,410 --> 00:14:01,770
little more detail in each of these

00:13:59,670 --> 00:14:04,290
layers to give you an idea about what

00:14:01,770 --> 00:14:05,730
they're supposed to do and these are

00:14:04,290 --> 00:14:07,650
just certain examples this the database

00:14:05,730 --> 00:14:09,630
is a top-level object and it's a context

00:14:07,650 --> 00:14:11,070
object in some cases that manage your

00:14:09,630 --> 00:14:13,200
resources for the driver in some case

00:14:11,070 --> 00:14:15,690
there are no resources to manage

00:14:13,200 --> 00:14:17,220
depending on the database driver but it

00:14:15,690 --> 00:14:22,350
does things like it's gonna get

00:14:17,220 --> 00:14:25,140
connections you if it if you specify at

00:14:22,350 --> 00:14:26,550
the database layer a URI then when you

00:14:25,140 --> 00:14:28,380
ask for connections you do not have to

00:14:26,550 --> 00:14:30,180
specify it it will has a notion of a

00:14:28,380 --> 00:14:32,730
default URI which just makes it too

00:14:30,180 --> 00:14:34,230
convenient in your code to not have to

00:14:32,730 --> 00:14:37,020
litter your code with a bunch of

00:14:34,230 --> 00:14:40,470
connection strings everywhere it also

00:14:37,020 --> 00:14:42,540
has the if there's a difference between

00:14:40,470 --> 00:14:44,010
connection and create connection most of

00:14:42,540 --> 00:14:46,770
time you just want a connection but

00:14:44,010 --> 00:14:48,720
there are some contexts in the presence

00:14:46,770 --> 00:14:52,350
of connection pooling where you want to

00:14:48,720 --> 00:14:54,839
actually ask for another connection not

00:14:52,350 --> 00:14:56,880
the same one handed to you based on your

00:14:54,839 --> 00:14:58,320
thread ID so that's what's creates

00:14:56,880 --> 00:15:02,160
connection for and we'll see an example

00:14:58,320 --> 00:15:03,780
for that the talk so that's what this

00:15:02,160 --> 00:15:06,120
does but also mentioned before if you

00:15:03,780 --> 00:15:07,440
want if your use case is simple in fact

00:15:06,120 --> 00:15:08,790
if you you're you're executing queries

00:15:07,440 --> 00:15:10,680
that don't return results you should be

00:15:08,790 --> 00:15:12,810
able to just execute that query straight

00:15:10,680 --> 00:15:17,190
from the database object and you can do

00:15:12,810 --> 00:15:20,760
that a little bit on connection strings

00:15:17,190 --> 00:15:22,200
it's just using an URI syntax this is

00:15:20,760 --> 00:15:23,820
something I've seen done in other

00:15:22,200 --> 00:15:26,100
database drivers and it seems very

00:15:23,820 --> 00:15:30,240
reasonable to do this you just have the

00:15:26,100 --> 00:15:34,080
name of the driver at the top like in a

00:15:30,240 --> 00:15:35,340
URI syntax colon slash slash the server

00:15:34,080 --> 00:15:36,960
the Debian and some

00:15:35,340 --> 00:15:38,880
these details will be specific to the

00:15:36,960 --> 00:15:40,110
driver but there is some some overlap

00:15:38,880 --> 00:15:43,740
between all the drivers that would make

00:15:40,110 --> 00:15:45,180
sense you can also specify a name source

00:15:43,740 --> 00:15:47,250
which and this is just an extension

00:15:45,180 --> 00:15:49,050
mechanism in the framework to say hey I

00:15:47,250 --> 00:15:52,320
want to name my sources and I want those

00:15:49,050 --> 00:15:54,750
sources to be looked up in a config file

00:15:52,320 --> 00:15:55,380
and rather than specify exactly what

00:15:54,750 --> 00:15:57,150
that should be

00:15:55,380 --> 00:15:58,980
that's simply a hook you can extend for

00:15:57,150 --> 00:16:01,110
if you want it to look for some you know

00:15:58,980 --> 00:16:02,820
any format in some location within your

00:16:01,110 --> 00:16:04,500
application or in your home directory

00:16:02,820 --> 00:16:06,060
all of that's possible through an

00:16:04,500 --> 00:16:12,410
extension and that's through a custom

00:16:06,060 --> 00:16:14,340
resolver connection connection is where

00:16:12,410 --> 00:16:15,960
there's two things you can do here and

00:16:14,340 --> 00:16:17,640
this is true for the API if at any point

00:16:15,960 --> 00:16:19,200
you have an object and you want to get

00:16:17,640 --> 00:16:21,540
the parent object that's always a

00:16:19,200 --> 00:16:22,890
possibility so if you were handed a

00:16:21,540 --> 00:16:25,830
connection you need to get the database

00:16:22,890 --> 00:16:27,180
just say dot database the other thing

00:16:25,830 --> 00:16:29,700
that the primary responsibility of a

00:16:27,180 --> 00:16:31,530
connection is transactions so there's a

00:16:29,700 --> 00:16:33,090
bunch of transaction calls here that you

00:16:31,530 --> 00:16:35,880
would expect if you're familiar with how

00:16:33,090 --> 00:16:37,680
transactions work in a database ability

00:16:35,880 --> 00:16:40,400
to start a transaction do a set of

00:16:37,680 --> 00:16:44,670
operations and then commit them

00:16:40,400 --> 00:16:49,410
checkpoint them or rule them back this

00:16:44,670 --> 00:16:52,140
is something that you can do if you have

00:16:49,410 --> 00:16:54,420
a feature called scope exit and this is

00:16:52,140 --> 00:16:55,890
not in the language so I only mentioned

00:16:54,420 --> 00:17:00,060
it briefly but there is a proposal to

00:16:55,890 --> 00:17:02,040
add this and this just allows the

00:17:00,060 --> 00:17:07,020
ability to define a scope within your

00:17:02,040 --> 00:17:08,610
function that causes these the

00:17:07,020 --> 00:17:14,520
statements within the scope to be

00:17:08,610 --> 00:17:16,110
executed upon failure so again this is a

00:17:14,520 --> 00:17:17,640
really nice thing I'd like to see added

00:17:16,110 --> 00:17:19,200
the language and you'll see that in a

00:17:17,640 --> 00:17:20,490
couple sites of the talks of things that

00:17:19,200 --> 00:17:23,580
I think need to be there that would be

00:17:20,490 --> 00:17:25,830
great this drastically simplifies

00:17:23,580 --> 00:17:29,520
complex transactions in which you have

00:17:25,830 --> 00:17:34,200
to manage state carefully the statement

00:17:29,520 --> 00:17:36,810
object this is primarily again needed

00:17:34,200 --> 00:17:38,280
for prepared statements and I'll have an

00:17:36,810 --> 00:17:42,020
example of this a little bit later but

00:17:38,280 --> 00:17:44,670
essentially a prepared statement is is

00:17:42,020 --> 00:17:47,010
when you're going to execute the same

00:17:44,670 --> 00:17:48,500
statement repeatedly and you want to

00:17:47,010 --> 00:17:51,080
save the work of

00:17:48,500 --> 00:17:54,190
your driver layer or database to have to

00:17:51,080 --> 00:17:56,840
repeatedly parse the query you want to

00:17:54,190 --> 00:17:59,030
to do this outside of a loop your

00:17:56,840 --> 00:18:01,250
program at a higher level say please

00:17:59,030 --> 00:18:03,560
prepare this query and then you use

00:18:01,250 --> 00:18:04,970
statement execute to pass it parameters

00:18:03,560 --> 00:18:07,940
and these parameters correspond to the

00:18:04,970 --> 00:18:09,320
question marks so so the work of

00:18:07,940 --> 00:18:11,180
preparing the query is down front and

00:18:09,320 --> 00:18:13,400
then you and then you pass parameters

00:18:11,180 --> 00:18:15,410
and that can be a big performance

00:18:13,400 --> 00:18:18,710
improvement so that's a primary role of

00:18:15,410 --> 00:18:23,720
a statement object okay now we get to

00:18:18,710 --> 00:18:25,940
the row set so the minor accessors in

00:18:23,720 --> 00:18:28,580
this row set are things like Rho dot

00:18:25,940 --> 00:18:31,220
width which would just be the number of

00:18:28,580 --> 00:18:34,510
columns if you you know it's a useful

00:18:31,220 --> 00:18:34,510
thing if you're trying to loop over it

00:18:35,650 --> 00:18:40,130
rota columns returns column metadata so

00:18:39,140 --> 00:18:44,480
that you can get the names of the

00:18:40,130 --> 00:18:46,520
columns row dot length is the number of

00:18:44,480 --> 00:18:49,070
rows and your result set and this would

00:18:46,520 --> 00:18:51,410
only be defined if you actually read all

00:18:49,070 --> 00:18:53,780
over the results or if you had some type

00:18:51,410 --> 00:18:55,550
mechanism that was materializing them up

00:18:53,780 --> 00:18:57,200
front but I still have it in here just

00:18:55,550 --> 00:19:00,380
to have a general notion of what a row

00:18:57,200 --> 00:19:04,010
set can do so the big question here is

00:19:00,380 --> 00:19:07,090
what about row traversal and this is a

00:19:04,010 --> 00:19:12,110
really important aspect of the API is

00:19:07,090 --> 00:19:13,760
how are you going to iterate over the

00:19:12,110 --> 00:19:15,530
data and there's a couple approaches

00:19:13,760 --> 00:19:17,180
that have traditionally been done that

00:19:15,530 --> 00:19:20,600
are in existing libraries things like

00:19:17,180 --> 00:19:23,660
next and done where you say give me the

00:19:20,600 --> 00:19:25,850
next row check to see if if there are

00:19:23,660 --> 00:19:28,490
any left so I've got a couple options

00:19:25,850 --> 00:19:32,390
here that the front pop up front and

00:19:28,490 --> 00:19:35,960
empty our notion of ranges that you may

00:19:32,390 --> 00:19:43,460
see in other languages well in C++ we

00:19:35,960 --> 00:19:46,370
have iterators so why not iterators well

00:19:43,460 --> 00:19:49,550
this this is what we use is iterators so

00:19:46,370 --> 00:19:51,440
in this particular case it's input

00:19:49,550 --> 00:19:52,940
iterators this is a weakest kind of

00:19:51,440 --> 00:19:54,470
iterators but I think completely

00:19:52,940 --> 00:19:57,679
appropriate for this type of interface

00:19:54,470 --> 00:19:59,660
because in virtually every interface

00:19:57,679 --> 00:20:01,310
what you're doing is just stepping

00:19:59,660 --> 00:20:03,720
through the results one at

00:20:01,310 --> 00:20:08,940
so you can only go forward and you only

00:20:03,720 --> 00:20:11,430
have access to the current result so the

00:20:08,940 --> 00:20:13,740
big enabler here I think the big win is

00:20:11,430 --> 00:20:16,230
that now you can use this with range

00:20:13,740 --> 00:20:19,100
based for just like that and here's an

00:20:16,230 --> 00:20:22,740
example so I'm creating a database I

00:20:19,100 --> 00:20:26,190
immediately get the rose from this query

00:20:22,740 --> 00:20:29,970
and I go straight into a range based for

00:20:26,190 --> 00:20:33,240
loop and it just works and so this is I

00:20:29,970 --> 00:20:37,140
think matching most closely what you

00:20:33,240 --> 00:20:39,840
would expect from an interface and C++

00:20:37,140 --> 00:20:42,900
in terms of matching features it makes

00:20:39,840 --> 00:20:47,310
it really easy to use in the way that

00:20:42,900 --> 00:20:50,640
you'd expect so in fact it's even better

00:20:47,310 --> 00:20:53,850
than that because I think if you've seen

00:20:50,640 --> 00:20:55,980
some some talks by STL he recommends it

00:20:53,850 --> 00:21:01,170
with range base for that you do auto ref

00:20:55,980 --> 00:21:03,090
ref because in many cases if you don't

00:21:01,170 --> 00:21:06,750
do that you've got an expensive copy

00:21:03,090 --> 00:21:07,770
that you may be able to avoid if what

00:21:06,750 --> 00:21:09,650
you're if the container you're iterating

00:21:07,770 --> 00:21:13,110
over is actually returning references

00:21:09,650 --> 00:21:16,200
this interface uses proxies so what's

00:21:13,110 --> 00:21:18,780
returned from a row set is actually a

00:21:16,200 --> 00:21:21,510
proxy object and that's going to create

00:21:18,780 --> 00:21:23,970
a few issues but for range base for this

00:21:21,510 --> 00:21:26,280
actually is a win so if you do the thing

00:21:23,970 --> 00:21:27,900
which you're probably most likely to do

00:21:26,280 --> 00:21:30,120
which is not our reference just playing

00:21:27,900 --> 00:21:32,100
Auto it's fine it's since it's a proxy

00:21:30,120 --> 00:21:34,560
doesn't matter if it's copied or you can

00:21:32,100 --> 00:21:36,480
just take the advice and use the auto

00:21:34,560 --> 00:21:38,760
ref ref also fine and of course taking

00:21:36,480 --> 00:21:40,410
just a single reference either constant

00:21:38,760 --> 00:21:44,760
nonce constant make sense in this

00:21:40,410 --> 00:21:46,530
context which is totally fine there was

00:21:44,760 --> 00:21:51,900
a proposal by STL to actually eliminate

00:21:46,530 --> 00:21:53,280
the auto altogether and that's that was

00:21:51,900 --> 00:21:55,440
discussed but I think that's going to

00:21:53,280 --> 00:21:59,040
come back at some point in a different

00:21:55,440 --> 00:22:00,570
form and that would also be nice here so

00:21:59,040 --> 00:22:02,460
you may be asking yourself well okay it

00:22:00,570 --> 00:22:04,770
arrays are great but is that going how

00:22:02,460 --> 00:22:10,440
much overhead is that going to add to

00:22:04,770 --> 00:22:13,080
the cost of the interface and because

00:22:10,440 --> 00:22:15,100
these are input iterators it's actually

00:22:13,080 --> 00:22:18,009
not down bad now there this is

00:22:15,100 --> 00:22:22,080
and you know a subject of discussion as

00:22:18,009 --> 00:22:24,850
well see but it's really pretty light

00:22:22,080 --> 00:22:26,380
for input iterators and you can see

00:22:24,850 --> 00:22:27,610
right here there is there's a runtime

00:22:26,380 --> 00:22:28,929
cost of doing this because you don't

00:22:27,610 --> 00:22:30,279
know which iterator you're gonna get in

00:22:28,929 --> 00:22:31,419
which order and all and these checks

00:22:30,279 --> 00:22:34,299
have to be done to run tight but it's

00:22:31,419 --> 00:22:38,139
not as bad as say with Ford iterators so

00:22:34,299 --> 00:22:39,789
this to me is is okay I don't think it

00:22:38,139 --> 00:22:41,679
actually matters that much compared to

00:22:39,789 --> 00:22:44,259
the other costs that you're that you are

00:22:41,679 --> 00:22:49,480
likely to occur overall in a database

00:22:44,259 --> 00:22:52,029
driver so what else can we do with this

00:22:49,480 --> 00:22:54,580
iterator design well you can here's an

00:22:52,029 --> 00:23:00,009
example of a standard library algorithm

00:22:54,580 --> 00:23:02,879
just in this case find if and you'll see

00:23:00,009 --> 00:23:08,789
here there's a typo it should say RNG

00:23:02,879 --> 00:23:14,289
I'm getting a range from the query and

00:23:08,789 --> 00:23:17,500
I'm passing it to find if and it just

00:23:14,289 --> 00:23:22,600
works so this example is looking for a

00:23:17,500 --> 00:23:24,309
key within the result set and returns an

00:23:22,600 --> 00:23:26,379
iterator to that row on the first one it

00:23:24,309 --> 00:23:28,299
finds so this is this works exactly like

00:23:26,379 --> 00:23:33,039
you would expect except now we're doing

00:23:28,299 --> 00:23:34,899
in the context of database code so we're

00:23:33,039 --> 00:23:37,090
able to leverage standard algorithms

00:23:34,899 --> 00:23:39,009
which i think is just great here's

00:23:37,090 --> 00:23:40,360
another example this one with just

00:23:39,009 --> 00:23:44,200
happens to be the cumulated you say you

00:23:40,360 --> 00:23:46,389
want to do you want to accumulate a

00:23:44,200 --> 00:23:47,500
score on the client side you can use

00:23:46,389 --> 00:23:49,330
accumulate now this is probably

00:23:47,500 --> 00:23:51,370
something that databases do really well

00:23:49,330 --> 00:23:53,019
with aggregation but for the purpose of

00:23:51,370 --> 00:23:58,299
showing another algorithm that would

00:23:53,019 --> 00:24:01,000
work here this is it so there still are

00:23:58,299 --> 00:24:03,460
issues with iterators that need to be

00:24:01,000 --> 00:24:05,700
considered and it's not so much with the

00:24:03,460 --> 00:24:10,200
input iterator but there are use cases

00:24:05,700 --> 00:24:13,360
in this design for other types of

00:24:10,200 --> 00:24:15,549
rosettes in particular stronger sets

00:24:13,360 --> 00:24:18,940
like full random access Pro sets so you

00:24:15,549 --> 00:24:21,909
can imagine maybe you you want to read

00:24:18,940 --> 00:24:25,870
in the entire row set instead of just

00:24:21,909 --> 00:24:27,279
having to buffer it for every each time

00:24:25,870 --> 00:24:28,600
and we're going to talk about that

00:24:27,279 --> 00:24:32,290
optimization but there

00:24:28,600 --> 00:24:35,200
this is something if in more complex

00:24:32,290 --> 00:24:39,850
types of iterator models theater issues

00:24:35,200 --> 00:24:44,190
iterator issues really start to show so

00:24:39,850 --> 00:24:46,810
the answer to this is ranges and and I

00:24:44,190 --> 00:24:48,730
assume that you've all probably heard of

00:24:46,810 --> 00:24:52,960
the range proposal by Eric Kneedler but

00:24:48,730 --> 00:24:57,100
this is really a phenomenal piece of

00:24:52,960 --> 00:24:58,780
work I think it's really impactful for

00:24:57,100 --> 00:25:01,150
the way we're going to write code in the

00:24:58,780 --> 00:25:06,100
future even though I think it's quite a

00:25:01,150 --> 00:25:08,200
ways away it's usable now and I just

00:25:06,100 --> 00:25:10,960
think it's going to it really effects I

00:25:08,200 --> 00:25:13,780
think how this interface can work with a

00:25:10,960 --> 00:25:16,300
standard library so I definitely

00:25:13,780 --> 00:25:18,160
recommend checking it out it's going to

00:25:16,300 --> 00:25:19,810
it basically addresses the existing

00:25:18,160 --> 00:25:23,050
issues with iterators particularly with

00:25:19,810 --> 00:25:24,610
composability and brings a whole class

00:25:23,050 --> 00:25:28,090
of functionality and I'll show you an

00:25:24,610 --> 00:25:32,430
example of that so just to give you a

00:25:28,090 --> 00:25:36,750
sense for how this would work with that

00:25:32,430 --> 00:25:40,390
proposal a row set is an input range and

00:25:36,750 --> 00:25:43,990
so a row set there's a couple of

00:25:40,390 --> 00:25:46,960
concepts in that standard which define

00:25:43,990 --> 00:25:48,760
classes of access for whatever you're

00:25:46,960 --> 00:25:51,430
particularly working with and the way it

00:25:48,760 --> 00:25:53,500
maps here is an iterable concept is

00:25:51,430 --> 00:25:56,860
simply anything we're beginning and is

00:25:53,500 --> 00:25:59,020
defined it turns out that I don't

00:25:56,860 --> 00:26:01,480
actually need to expose that in

00:25:59,020 --> 00:26:04,390
isolation because row set is both an

00:26:01,480 --> 00:26:06,940
editable and a range so if you think of

00:26:04,390 --> 00:26:09,970
a range a range object which in this

00:26:06,940 --> 00:26:12,310
case is the row set has a begin and end

00:26:09,970 --> 00:26:15,100
so that works the range based for it's

00:26:12,310 --> 00:26:17,800
also lightweight in that copying is

00:26:15,100 --> 00:26:20,140
cheap it doesn't own the elements and

00:26:17,800 --> 00:26:22,060
it's default constructible caught people

00:26:20,140 --> 00:26:25,000
assignable indestructible so it actually

00:26:22,060 --> 00:26:27,490
serves both of those purposes which also

00:26:25,000 --> 00:26:29,380
further simplifies the use of the API

00:26:27,490 --> 00:26:30,940
and then on top of that if you think of

00:26:29,380 --> 00:26:35,790
these stacking it's also an input range

00:26:30,940 --> 00:26:39,299
so it does map perfectly into that

00:26:35,790 --> 00:26:44,369
proposals notion of concepts and how

00:26:39,299 --> 00:26:45,749
works so based upon that proposal how

00:26:44,369 --> 00:26:47,700
would things change the first thing I

00:26:45,749 --> 00:26:50,519
want to show you is an optimization so

00:26:47,700 --> 00:26:52,230
the first operator compare this is for

00:26:50,519 --> 00:26:55,889
iterators within row set the first one

00:26:52,230 --> 00:26:58,379
is the one we had before and you can see

00:26:55,889 --> 00:27:02,879
it has a certain complexity if you're

00:26:58,379 --> 00:27:04,980
using ranges then it collapses to the

00:27:02,879 --> 00:27:06,389
one below so that's a little bit more

00:27:04,980 --> 00:27:08,639
efficient the reason it's able to do

00:27:06,389 --> 00:27:09,470
that is because it's it knows a

00:27:08,639 --> 00:27:12,359
compile-time

00:27:09,470 --> 00:27:13,470
how to compare the iterators and the key

00:27:12,359 --> 00:27:15,869
thing which I which I didn't mention

00:27:13,470 --> 00:27:19,769
here is the key thing within ranges is

00:27:15,869 --> 00:27:21,749
that a begin and enter it end iterator

00:27:19,769 --> 00:27:24,600
are not required to have the same type

00:27:21,749 --> 00:27:26,700
in fact if they have different types it

00:27:24,600 --> 00:27:28,200
allows a compiler to see in the code

00:27:26,700 --> 00:27:31,429
that you're trying to compare an

00:27:28,200 --> 00:27:33,509
iterator to an in condition and that

00:27:31,429 --> 00:27:37,470
eliminates branches in the code and

00:27:33,509 --> 00:27:39,119
simplifies the comparison so so you get

00:27:37,470 --> 00:27:41,460
some improvement from there but that's I

00:27:39,119 --> 00:27:46,830
think really maybe the minor benefit in

00:27:41,460 --> 00:27:48,419
this case a little bit better benefit is

00:27:46,830 --> 00:27:50,009
that with the composability so

00:27:48,419 --> 00:27:52,350
everywhere where you would pass a

00:27:50,009 --> 00:27:54,779
beginning in you can now pass just a

00:27:52,350 --> 00:27:56,940
single range object which in this case

00:27:54,779 --> 00:27:58,470
is just the row set so what I did in

00:27:56,940 --> 00:28:00,659
this case is I just put it in line you

00:27:58,470 --> 00:28:02,909
don't have to do that but it does allow

00:28:00,659 --> 00:28:05,999
you to do that and makes the code a

00:28:02,909 --> 00:28:09,899
little more succinct and you can compose

00:28:05,999 --> 00:28:11,940
the expression as the argument so so

00:28:09,899 --> 00:28:18,299
that that improves the use of the

00:28:11,940 --> 00:28:21,419
existing algorithms now I think the big

00:28:18,299 --> 00:28:25,080
win for ranges is in what's called range

00:28:21,419 --> 00:28:28,379
adapters and I'm really excited about

00:28:25,080 --> 00:28:32,220
this this is an example of a range

00:28:28,379 --> 00:28:34,230
adapter in the ranges library and what

00:28:32,220 --> 00:28:36,929
it's doing is it's filtering the

00:28:34,230 --> 00:28:38,999
database result but what it's the way

00:28:36,929 --> 00:28:41,700
it's doing it is it's fetching let this

00:28:38,999 --> 00:28:45,029
the results lazily so if you can imagine

00:28:41,700 --> 00:28:47,279
here it's similar to copy of if you have

00:28:45,029 --> 00:28:49,830
used that what you're doing here is

00:28:47,279 --> 00:28:51,629
you're creating a filter and you're

00:28:49,830 --> 00:28:52,770
specifying the input range that you want

00:28:51,629 --> 00:28:55,050
to filter on and then

00:28:52,770 --> 00:28:58,350
a condition in the lambda in this case

00:28:55,050 --> 00:29:01,140
the example I'm giving here is you're

00:28:58,350 --> 00:29:03,330
looking for all results that have a

00:29:01,140 --> 00:29:06,420
minimum score so it's a fairly

00:29:03,330 --> 00:29:08,940
straightforward example this code is

00:29:06,420 --> 00:29:10,350
written hasn't actually isn't actually

00:29:08,940 --> 00:29:13,620
doing anything the only thing that's

00:29:10,350 --> 00:29:15,600
doing is creating a new range which is

00:29:13,620 --> 00:29:17,070
going to perform that result so all

00:29:15,600 --> 00:29:18,570
you're doing here is setting up the

00:29:17,070 --> 00:29:21,030
ability to query and then when you

00:29:18,570 --> 00:29:22,650
actually access the range itself then it

00:29:21,030 --> 00:29:25,380
executes the query and then it fetches

00:29:22,650 --> 00:29:27,810
the elements of one at a time this is

00:29:25,380 --> 00:29:30,030
able to do something that you can't do

00:29:27,810 --> 00:29:32,100
with the exist that it's doing it lazily

00:29:30,030 --> 00:29:34,470
it actually worked so so if you tried to

00:29:32,100 --> 00:29:36,660
do this with copy if what you would find

00:29:34,470 --> 00:29:39,300
is that it would not work and the reason

00:29:36,660 --> 00:29:41,640
is this because copy up is going to

00:29:39,300 --> 00:29:43,320
iterate through the results and input

00:29:41,640 --> 00:29:45,300
ranges can't it's going to exhaust the

00:29:43,320 --> 00:29:47,130
results so if you were to try and access

00:29:45,300 --> 00:29:48,570
those copied results later you'd have a

00:29:47,130 --> 00:29:51,570
bunch of proxy objects which were

00:29:48,570 --> 00:29:53,610
invalid but if you do it lazily it works

00:29:51,570 --> 00:29:55,470
perfectly fine so this is actually doing

00:29:53,610 --> 00:29:57,660
something that it really isn't possible

00:29:55,470 --> 00:30:00,270
with this before and you're getting a

00:29:57,660 --> 00:30:03,180
lot of composability benefits so I think

00:30:00,270 --> 00:30:04,380
this is just a huge addition to the

00:30:03,180 --> 00:30:06,090
standard library and I think it works

00:30:04,380 --> 00:30:09,540
really great with this type of interface

00:30:06,090 --> 00:30:12,150
for databases so just moving along to

00:30:09,540 --> 00:30:17,220
some of the other objects the row object

00:30:12,150 --> 00:30:20,850
is simply a way to to access fields

00:30:17,220 --> 00:30:23,880
within the row so you dereference a row

00:30:20,850 --> 00:30:25,800
set you get a row proxy the row proxy

00:30:23,880 --> 00:30:27,300
then can be dereference to get a field

00:30:25,800 --> 00:30:30,780
object you can it you can do it by

00:30:27,300 --> 00:30:32,400
position you can do it by name or you

00:30:30,780 --> 00:30:33,840
can do it by column which column is

00:30:32,400 --> 00:30:36,330
another object that comes from the

00:30:33,840 --> 00:30:39,210
columns metadata object available at the

00:30:36,330 --> 00:30:41,430
row set and then there's the field

00:30:39,210 --> 00:30:45,810
object the field object is another proxy

00:30:41,430 --> 00:30:48,210
and its primary role is to handle

00:30:45,810 --> 00:30:50,310
conversions so if all you did is you

00:30:48,210 --> 00:30:52,800
just wanted to send it a standard out

00:30:50,310 --> 00:30:54,810
that should be fine if you wanted to do

00:30:52,800 --> 00:30:58,460
a conversion to a particular type you

00:30:54,810 --> 00:31:02,310
can specify it via as template type T

00:30:58,460 --> 00:31:04,020
and all of those conversions are handled

00:31:02,310 --> 00:31:06,720
within Slayer and also it has to handle

00:31:04,020 --> 00:31:10,470
the case where the way it was bound

00:31:06,720 --> 00:31:11,700
by default in the lair may or may not be

00:31:10,470 --> 00:31:14,190
the type that you're asking for so all

00:31:11,700 --> 00:31:15,510
of those have to be accounted for you

00:31:14,190 --> 00:31:17,010
should be able to ask for a variant and

00:31:15,510 --> 00:31:19,230
you should have support or optional note

00:31:17,010 --> 00:31:22,980
this the interesting thing here is that

00:31:19,230 --> 00:31:25,909
the the accessors on their listed above

00:31:22,980 --> 00:31:29,570
have the possibility of throwing and

00:31:25,909 --> 00:31:32,490
that's because of this notion of null so

00:31:29,570 --> 00:31:34,860
the the value that you get back to

00:31:32,490 --> 00:31:36,510
pending upon the database may there's a

00:31:34,860 --> 00:31:38,909
possibility may be null so you cannot

00:31:36,510 --> 00:31:40,860
you cannot marshal into a type that

00:31:38,909 --> 00:31:43,770
doesn't inherently support an illness if

00:31:40,860 --> 00:31:45,240
if the values actually know so if you

00:31:43,770 --> 00:31:47,429
use the access search below such as

00:31:45,240 --> 00:31:49,169
variant and optional those are okay

00:31:47,429 --> 00:31:52,679
those do not throw and it just means

00:31:49,169 --> 00:31:54,299
that if the actual field value is no you

00:31:52,679 --> 00:31:57,360
will get that null reflected in the

00:31:54,299 --> 00:32:00,000
variant and optional so that's a nice

00:31:57,360 --> 00:32:01,650
convenience they have a couple other

00:32:00,000 --> 00:32:04,530
accessors you can test upfront whether

00:32:01,650 --> 00:32:06,659
it is know the the name and the type are

00:32:04,530 --> 00:32:08,610
available at the field level even those

00:32:06,659 --> 00:32:09,900
that's metadata that you would normally

00:32:08,610 --> 00:32:11,789
get from the column it's very convenient

00:32:09,900 --> 00:32:13,020
to have them at the field so that you

00:32:11,789 --> 00:32:14,159
also you don't have to work with

00:32:13,020 --> 00:32:26,000
multiple objects if you really don't

00:32:14,159 --> 00:32:29,700
have a need to so let me talk about

00:32:26,000 --> 00:32:32,179
field annex a little bit more so when

00:32:29,700 --> 00:32:34,260
you ask for a field by name this isn't

00:32:32,179 --> 00:32:35,880
the most efficient approach and that's

00:32:34,260 --> 00:32:38,220
because you're having to take a string

00:32:35,880 --> 00:32:40,080
and compare it to the to the names of

00:32:38,220 --> 00:32:44,429
the column and then return the field if

00:32:40,080 --> 00:32:47,010
you use a numeric index is a little bit

00:32:44,429 --> 00:32:50,309
more efficient so but that's not as

00:32:47,010 --> 00:32:54,539
maintainable so what can you do about

00:32:50,309 --> 00:32:57,809
this well you can you can set up code

00:32:54,539 --> 00:33:01,620
like this which is if you create index

00:32:57,809 --> 00:33:03,390
objects ahead of the loop say idea ID X

00:33:01,620 --> 00:33:04,890
name ID X what you're doing is you're

00:33:03,390 --> 00:33:06,419
looking up the indexes outside of the

00:33:04,890 --> 00:33:09,809
loop and then when you get into the loop

00:33:06,419 --> 00:33:12,090
then you can use these integer variables

00:33:09,809 --> 00:33:14,340
to index the fields out of that and

00:33:12,090 --> 00:33:17,309
that's that is more efficient it's

00:33:14,340 --> 00:33:20,070
harder to maintain whether it actually

00:33:17,309 --> 00:33:22,530
matters may really depend upon just

00:33:20,070 --> 00:33:26,520
how critical performance is for your

00:33:22,530 --> 00:33:29,780
particular setup but there may be a

00:33:26,520 --> 00:33:32,040
better way to do this and this uses

00:33:29,780 --> 00:33:34,020
varied act templates and let me show you

00:33:32,040 --> 00:33:40,640
how this works so here I have I'm

00:33:34,020 --> 00:33:43,890
getting a row set out of a database and

00:33:40,640 --> 00:33:45,240
then what I'm doing is I'm going to go

00:33:43,890 --> 00:33:53,520
back inside because I'm out of order

00:33:45,240 --> 00:33:56,760
here here is an example of what I call

00:33:53,520 --> 00:33:58,740
into so into is a very dag template in

00:33:56,760 --> 00:34:02,990
which you pass in the variables that you

00:33:58,740 --> 00:34:07,020
want bound to based on the query and

00:34:02,990 --> 00:34:09,360
this works when your query is just a

00:34:07,020 --> 00:34:11,040
single row and you just want to get

00:34:09,360 --> 00:34:12,750
these in two variables with the least

00:34:11,040 --> 00:34:16,020
amount of work as possible so you don't

00:34:12,750 --> 00:34:17,820
even necessarily want to index set up

00:34:16,020 --> 00:34:19,320
the indexing even by name if you have a

00:34:17,820 --> 00:34:21,960
query that's this short which is four

00:34:19,320 --> 00:34:23,340
values why not just put them right into

00:34:21,960 --> 00:34:25,440
the variables and that's exactly what

00:34:23,340 --> 00:34:28,740
this does so therefore single row

00:34:25,440 --> 00:34:30,180
queries this is a great way to just

00:34:28,740 --> 00:34:35,550
achieve that without having to worry

00:34:30,180 --> 00:34:37,620
about indexing into the row object it

00:34:35,550 --> 00:34:40,590
turns out this also can be applied of

00:34:37,620 --> 00:34:42,420
the row proxy object as well so if you

00:34:40,590 --> 00:34:44,700
can imagine that you know this this can

00:34:42,420 --> 00:34:46,980
extend beyond just a query that returns

00:34:44,700 --> 00:34:49,290
single rows it can apply to actually

00:34:46,980 --> 00:34:51,360
ones with multiple rows and it simply

00:34:49,290 --> 00:34:55,170
means that within your for loop itself

00:34:51,360 --> 00:34:57,240
you say row into and the names of the

00:34:55,170 --> 00:34:58,980
variables so here I've got an example

00:34:57,240 --> 00:35:00,900
where I have a query that may return

00:34:58,980 --> 00:35:02,910
more than one result I have variables

00:35:00,900 --> 00:35:05,250
that I want to put that data into then I

00:35:02,910 --> 00:35:08,520
go into a for loop and on the row object

00:35:05,250 --> 00:35:10,410
that I got from the row set I can now

00:35:08,520 --> 00:35:12,360
say row into and whatever variables I

00:35:10,410 --> 00:35:14,250
put in there whatever type the very deck

00:35:12,360 --> 00:35:17,280
template will pick those up and do the

00:35:14,250 --> 00:35:22,340
assignment so it's flexible in that

00:35:17,280 --> 00:35:25,800
regard to other possibilities here is

00:35:22,340 --> 00:35:28,410
that you could use a range you could put

00:35:25,800 --> 00:35:29,730
into range so instead of putting them

00:35:28,410 --> 00:35:33,030
into variables they could go into a

00:35:29,730 --> 00:35:33,940
range and an output range or they could

00:35:33,030 --> 00:35:36,190
do that you

00:35:33,940 --> 00:35:39,640
either vertically for the whole result

00:35:36,190 --> 00:35:41,140
set or by horizontally for a particular

00:35:39,640 --> 00:35:42,940
column and there needs to be some work

00:35:41,140 --> 00:35:44,710
in figuring out how to disambiguate and

00:35:42,940 --> 00:35:46,569
what what makes sense at what levels so

00:35:44,710 --> 00:35:48,010
that you're getting what you expect but

00:35:46,569 --> 00:35:50,290
that's also a possibility

00:35:48,010 --> 00:35:54,640
I should mention serialization here's I

00:35:50,290 --> 00:35:59,200
think this is a huge need in the

00:35:54,640 --> 00:36:01,420
standard for to have this this ability

00:35:59,200 --> 00:36:03,339
to be easily implemented so what I mean

00:36:01,420 --> 00:36:04,660
by and I think this is really not this

00:36:03,339 --> 00:36:06,430
isn't something that has to be

00:36:04,660 --> 00:36:08,069
integrated into this framework I think

00:36:06,430 --> 00:36:11,170
it actually sits above this framework

00:36:08,069 --> 00:36:13,839
but the idea here is it if you have a

00:36:11,170 --> 00:36:16,180
row set and you have an object you'd

00:36:13,839 --> 00:36:18,490
like to use some type of reflection

00:36:16,180 --> 00:36:20,740
based mechanism to serialize it into

00:36:18,490 --> 00:36:23,319
your object and there are many ways that

00:36:20,740 --> 00:36:25,480
you could do that with the syntax this

00:36:23,319 --> 00:36:27,910
this is something that other languages

00:36:25,480 --> 00:36:28,480
have and is is considered just a

00:36:27,910 --> 00:36:31,569
commonplace

00:36:28,480 --> 00:36:33,700
to be able to do this so serialization

00:36:31,569 --> 00:36:36,670
just not only just for data it would be

00:36:33,700 --> 00:36:38,619
applied to lots of different contexts

00:36:36,670 --> 00:36:41,050
but particularly here for databases as

00:36:38,619 --> 00:36:42,819
well as things like flat files things

00:36:41,050 --> 00:36:44,650
you get over a network connection so

00:36:42,819 --> 00:36:46,839
this is an area that I think really

00:36:44,650 --> 00:36:53,079
would benefit by reflection in the

00:36:46,839 --> 00:36:55,569
standard just really small feature here

00:36:53,079 --> 00:36:57,819
is in some cases you may want to have

00:36:55,569 --> 00:36:59,819
access to the underlying handle the

00:36:57,819 --> 00:37:03,160
native handle of the driver width in

00:36:59,819 --> 00:37:05,170
that's underlies your particular choice

00:37:03,160 --> 00:37:07,420
of database and that's what this does so

00:37:05,170 --> 00:37:09,690
for example if it does if you say

00:37:07,420 --> 00:37:14,109
connection not handle you will get a

00:37:09,690 --> 00:37:16,810
void pointer to a my sequel handle and

00:37:14,109 --> 00:37:18,520
that maybe maybe that's you for testing

00:37:16,810 --> 00:37:20,530
maybe it's useful because you have

00:37:18,520 --> 00:37:22,990
legacy code when what you actually need

00:37:20,530 --> 00:37:24,460
to get a handle to hook it up to the

00:37:22,990 --> 00:37:25,750
interface does provide that capability

00:37:24,460 --> 00:37:28,079
but you have to be careful with this

00:37:25,750 --> 00:37:31,329
because realizing that this is escaping

00:37:28,079 --> 00:37:33,940
the shared pointer mechanism so in this

00:37:31,329 --> 00:37:36,700
example here I'm I say DB connection not

00:37:33,940 --> 00:37:38,140
handle because it's not returning a

00:37:36,700 --> 00:37:40,180
smart pointer that will go out of scope

00:37:38,140 --> 00:37:42,520
and you'll have a lifetime fail on that

00:37:40,180 --> 00:37:44,980
my sequel pointer so you have to be

00:37:42,520 --> 00:37:47,650
careful with that now I want to talk

00:37:44,980 --> 00:37:50,650
about a particular feature that moe

00:37:47,650 --> 00:37:56,320
strivers offer which is important which

00:37:50,650 --> 00:38:02,800
is called output binding so what this is

00:37:56,320 --> 00:38:04,120
is that the binding mechanism is is set

00:38:02,800 --> 00:38:07,060
up by the driver where you where

00:38:04,120 --> 00:38:09,100
internally you declare in a buffer in

00:38:07,060 --> 00:38:10,630
which database coming information from

00:38:09,100 --> 00:38:12,370
the database goes into this buffer and

00:38:10,630 --> 00:38:13,900
that's all managed by this framework you

00:38:12,370 --> 00:38:17,650
don't have to ever deal with that it's

00:38:13,900 --> 00:38:20,200
never exposed at the user level there's

00:38:17,650 --> 00:38:21,790
something called array output binding

00:38:20,200 --> 00:38:25,720
which is an optimization many drivers

00:38:21,790 --> 00:38:30,850
offer and the way it works is that you

00:38:25,720 --> 00:38:33,580
specify an array the size of the array

00:38:30,850 --> 00:38:36,190
that you want to allocate for the

00:38:33,580 --> 00:38:38,470
results to go into so I'm gonna explain

00:38:36,190 --> 00:38:40,570
how this works so let's say you have a

00:38:38,470 --> 00:38:44,170
thousand or a table if you did not

00:38:40,570 --> 00:38:45,910
specify output array binding what you

00:38:44,170 --> 00:38:51,220
would get as a buffer to hold just one

00:38:45,910 --> 00:38:52,660
row if you do specify it then it what's

00:38:51,220 --> 00:38:55,420
going to happen is it's going to fetch

00:38:52,660 --> 00:38:57,460
however whatever size you declare each

00:38:55,420 --> 00:38:58,600
time it talks to the database so you can

00:38:57,460 --> 00:39:00,610
imagine this is going to have some

00:38:58,600 --> 00:39:02,380
performance benefit depending on your

00:39:00,610 --> 00:39:04,750
use case so for example here's a case

00:39:02,380 --> 00:39:06,070
without any binding here and I've just

00:39:04,750 --> 00:39:10,000
measured this for a particular database

00:39:06,070 --> 00:39:11,650
set 203 milliseconds and I'm reading

00:39:10,000 --> 00:39:13,000
this house enroll table and I'm just

00:39:11,650 --> 00:39:17,050
fetching over the results and adding

00:39:13,000 --> 00:39:19,180
them so now I'm going to specify a row

00:39:17,050 --> 00:39:21,250
array size of a hundred and you can see

00:39:19,180 --> 00:39:23,350
right here that it goes from 2 or 3 to

00:39:21,250 --> 00:39:25,180
32 milliseconds now that's a hundred

00:39:23,350 --> 00:39:27,100
rows for a thousand row table so if

00:39:25,180 --> 00:39:29,860
100's good may be increasing it will be

00:39:27,100 --> 00:39:33,640
better so let's edit 500 now goes down

00:39:29,860 --> 00:39:35,830
to two milliseconds and now let's just

00:39:33,640 --> 00:39:38,320
create just specify at the full size I

00:39:35,830 --> 00:39:41,770
want a thousand rows which covers the

00:39:38,320 --> 00:39:44,020
size of that table now unfortunately

00:39:41,770 --> 00:39:46,590
that number there was not updated but

00:39:44,020 --> 00:39:50,020
it's something like 500 microseconds

00:39:46,590 --> 00:39:54,070
instead of that 2 milliseconds but this

00:39:50,020 --> 00:39:57,550
is essentially 400 times faster than the

00:39:54,070 --> 00:39:59,140
first case without array binding and I

00:39:57,550 --> 00:40:01,600
graph this here of the four data points

00:39:59,140 --> 00:40:03,400
and and just to illustrate that how

00:40:01,600 --> 00:40:05,950
much of a performance increase this is

00:40:03,400 --> 00:40:08,380
that's that's a log scale right there

00:40:05,950 --> 00:40:10,150
it's orders of magnitude faster to do

00:40:08,380 --> 00:40:11,650
this it's even may even may set make

00:40:10,150 --> 00:40:14,500
sense to just create a default in

00:40:11,650 --> 00:40:16,450
certain circumstances and in fact row

00:40:14,500 --> 00:40:17,800
array sites could be set at the database

00:40:16,450 --> 00:40:19,500
level so that you can ensure within your

00:40:17,800 --> 00:40:22,270
application that all of your connections

00:40:19,500 --> 00:40:24,940
may I have some type of defect default

00:40:22,270 --> 00:40:27,130
row set size now maybe this you know

00:40:24,940 --> 00:40:28,840
this does cost memory but you know how

00:40:27,130 --> 00:40:30,160
to there's I think there's a certain

00:40:28,840 --> 00:40:31,810
number in which it makes sense for

00:40:30,160 --> 00:40:35,320
probably every application to have this

00:40:31,810 --> 00:40:37,660
so that is a pretty dramatic improvement

00:40:35,320 --> 00:40:39,730
and all of this you get all of this

00:40:37,660 --> 00:40:43,660
without having to affect user code just

00:40:39,730 --> 00:40:46,210
by specifying the road race ice on top

00:40:43,660 --> 00:40:48,490
of that some drivers also support this

00:40:46,210 --> 00:40:51,400
notion of I'll call continuous array

00:40:48,490 --> 00:40:53,260
binding where you can say normally when

00:40:51,400 --> 00:40:56,200
you specify these column arrays they're

00:40:53,260 --> 00:40:59,710
separately allocated but some database

00:40:56,200 --> 00:41:02,260
drivers allow you to actually overlay

00:40:59,710 --> 00:41:04,840
those those arrays into the same

00:41:02,260 --> 00:41:07,390
contiguous memory and so what you end up

00:41:04,840 --> 00:41:10,630
with is your entire result set in

00:41:07,390 --> 00:41:12,550
contiguous memory and so if what you're

00:41:10,630 --> 00:41:14,050
going to do is fetch data from your

00:41:12,550 --> 00:41:15,670
database and you're going to spend some

00:41:14,050 --> 00:41:17,860
time with it processing it then this

00:41:15,670 --> 00:41:19,600
could be an added improvement because

00:41:17,860 --> 00:41:21,070
you can get the entire result

00:41:19,600 --> 00:41:23,080
along with all the columns in contiguous

00:41:21,070 --> 00:41:25,870
memory so this is another opportunity

00:41:23,080 --> 00:41:30,970
for improving performance detached

00:41:25,870 --> 00:41:33,400
rosettes so the row sets we've talked

00:41:30,970 --> 00:41:36,630
about up to now are just forward only or

00:41:33,400 --> 00:41:38,980
they are input only one row at a time

00:41:36,630 --> 00:41:41,530
but here's a notion where you can ask

00:41:38,980 --> 00:41:45,430
for detached rows and when you do this

00:41:41,530 --> 00:41:47,380
you get a row set that is random access

00:41:45,430 --> 00:41:50,610
so what's happening here is if if you

00:41:47,380 --> 00:41:52,900
have the ability to just get the row set

00:41:50,610 --> 00:41:54,130
all at once and you can see from the

00:41:52,900 --> 00:41:58,690
previous slides that this has a real

00:41:54,130 --> 00:42:00,940
benefit because of the performance then

00:41:58,690 --> 00:42:03,700
you have some added abilities that come

00:42:00,940 --> 00:42:06,130
with this and here again this is why I

00:42:03,700 --> 00:42:07,660
mentioned earlier Y ranges plays into

00:42:06,130 --> 00:42:09,850
this because now you have a row set that

00:42:07,660 --> 00:42:14,260
may benefit quite a bit more from the

00:42:09,850 --> 00:42:15,870
capabilities that ranges provides this

00:42:14,260 --> 00:42:17,940
detachable row set all

00:42:15,870 --> 00:42:19,500
can outlive the other resources so if

00:42:17,940 --> 00:42:21,120
you want to take this detachable rosette

00:42:19,500 --> 00:42:22,920
and just hand back the connection it

00:42:21,120 --> 00:42:24,420
automatically releases a connection all

00:42:22,920 --> 00:42:27,800
the other resources associated with it

00:42:24,420 --> 00:42:32,250
you can keep it within your application

00:42:27,800 --> 00:42:36,870
in a in essentially a long state and

00:42:32,250 --> 00:42:39,000
what this does is it enables caching so

00:42:36,870 --> 00:42:41,850
for example you can imagine that if you

00:42:39,000 --> 00:42:44,280
have a database application and you want

00:42:41,850 --> 00:42:48,320
to start you know small tables locally

00:42:44,280 --> 00:42:48,320
this is something that will help do that

00:42:48,740 --> 00:42:53,880
so just on the same notion I want to

00:42:52,290 --> 00:42:57,240
revisit input binding which was

00:42:53,880 --> 00:42:57,930
mentioned before just as output what

00:42:57,240 --> 00:43:00,510
binding

00:42:57,930 --> 00:43:03,120
really benefits from array the same can

00:43:00,510 --> 00:43:05,820
be done for input binding input binding

00:43:03,120 --> 00:43:07,920
is where you're specifying with execute

00:43:05,820 --> 00:43:10,590
variables that are going to go into a

00:43:07,920 --> 00:43:13,080
statement such as insert with no results

00:43:10,590 --> 00:43:14,700
coming back you can do rate and put

00:43:13,080 --> 00:43:16,880
binding with many drivers and that you

00:43:14,700 --> 00:43:19,850
it's the same pattern where you say how

00:43:16,880 --> 00:43:23,400
how large you want that buffer to be

00:43:19,850 --> 00:43:24,930
this also is a huge performance win so

00:43:23,400 --> 00:43:28,800
you can imagine the only downside of

00:43:24,930 --> 00:43:31,680
this is that as you're inserting

00:43:28,800 --> 00:43:33,480
information none of those are being

00:43:31,680 --> 00:43:35,070
pushed to the database until you reach

00:43:33,480 --> 00:43:36,510
the size of the buffer so if you have an

00:43:35,070 --> 00:43:37,860
application where you're not having to

00:43:36,510 --> 00:43:40,290
transact a row at a time

00:43:37,860 --> 00:43:43,520
you're just trying to stream data its

00:43:40,290 --> 00:43:45,840
data into a database as fast as possible

00:43:43,520 --> 00:43:47,100
then this makes a lot of sense and every

00:43:45,840 --> 00:43:48,750
time you fill the buffer it's gonna

00:43:47,100 --> 00:43:54,510
flush out to the database and then keep

00:43:48,750 --> 00:43:56,880
writing them locally just a note about

00:43:54,510 --> 00:43:58,740
type conversion which I said before the

00:43:56,880 --> 00:44:01,260
field object has to deal with a lot of

00:43:58,740 --> 00:44:03,780
type conversion details in terms of how

00:44:01,260 --> 00:44:05,540
the data was bound internally and what

00:44:03,780 --> 00:44:09,090
it is that's being requested and

00:44:05,540 --> 00:44:10,590
depending on how those match up there

00:44:09,090 --> 00:44:13,110
may not there may or may not be a cost

00:44:10,590 --> 00:44:14,520
associated with that if and there's ways

00:44:13,110 --> 00:44:16,530
to control that if you know that you're

00:44:14,520 --> 00:44:18,930
always pulling things out of strings you

00:44:16,530 --> 00:44:20,490
say you know binding everything natively

00:44:18,930 --> 00:44:24,660
internally as strings so that there's no

00:44:20,490 --> 00:44:28,110
conversion on this end a little bit

00:44:24,660 --> 00:44:29,520
about policies so this this design is a

00:44:28,110 --> 00:44:34,770
template based design

00:44:29,520 --> 00:44:39,600
and that does facilitate the ability to

00:44:34,770 --> 00:44:41,160
control certain parameters about how how

00:44:39,600 --> 00:44:45,240
things can be controlled to compile time

00:44:41,160 --> 00:44:49,790
things like custom allocators connection

00:44:45,240 --> 00:44:52,020
pulling things like resource resolvers

00:44:49,790 --> 00:44:56,010
there are other possibilities that I

00:44:52,020 --> 00:44:58,140
think may be possible as well here such

00:44:56,010 --> 00:45:00,360
as if you really don't want the cost of

00:44:58,140 --> 00:45:05,540
shared pointer you could specify just

00:45:00,360 --> 00:45:09,710
make it scoped that's possible here I

00:45:05,540 --> 00:45:12,180
want to talk a little bit about a

00:45:09,710 --> 00:45:14,820
utility example here by that I mean

00:45:12,180 --> 00:45:20,750
here's something that you can use on top

00:45:14,820 --> 00:45:24,180
of this interface which is an

00:45:20,750 --> 00:45:27,350
interesting use case so here you may

00:45:24,180 --> 00:45:29,369
have experiences this issue before where

00:45:27,350 --> 00:45:31,830
databases aren't actually particularly

00:45:29,369 --> 00:45:33,240
good at returning hierarchical results

00:45:31,830 --> 00:45:35,400
so if you can imagine you have an

00:45:33,240 --> 00:45:37,800
inventory and an orders in a parts table

00:45:35,400 --> 00:45:41,760
you end up in a situation where you

00:45:37,800 --> 00:45:43,500
having to redundantly have column values

00:45:41,760 --> 00:45:45,859
because all of this has to be flattened

00:45:43,500 --> 00:45:49,320
and the result set that comes back and

00:45:45,859 --> 00:45:51,210
part of what this does is address that

00:45:49,320 --> 00:45:52,830
problem and the other thing it does is

00:45:51,210 --> 00:45:56,840
try to achieve it with high performance

00:45:52,830 --> 00:45:59,340
so at this example what it's doing is

00:45:56,840 --> 00:46:01,680
its opening a connection 3 connections

00:45:59,340 --> 00:46:04,230
database and it's streaming simple

00:46:01,680 --> 00:46:06,690
select results on these 3 connections

00:46:04,230 --> 00:46:08,550
back to your client and I'll call it a

00:46:06,690 --> 00:46:10,830
it's like a client-side join you take

00:46:08,550 --> 00:46:13,740
the results coming back from from each

00:46:10,830 --> 00:46:15,270
of these tables and you do the joint on

00:46:13,740 --> 00:46:17,040
the client side and I'll call it a

00:46:15,270 --> 00:46:19,609
natural join because the idea here is

00:46:17,040 --> 00:46:23,609
just for simplicity sake just state just

00:46:19,609 --> 00:46:26,130
infer how to join this from the collet

00:46:23,609 --> 00:46:30,300
keys within there so the ID matches ID

00:46:26,130 --> 00:46:32,310
matches from one table to the other and

00:46:30,300 --> 00:46:36,780
there are a few caveats as approach the

00:46:32,310 --> 00:46:38,310
the overlapping keys have to be ordered

00:46:36,780 --> 00:46:39,420
in the right way so that as these

00:46:38,310 --> 00:46:41,190
straight these streams have to be

00:46:39,420 --> 00:46:43,290
ordered together and what's happening is

00:46:41,190 --> 00:46:43,559
it's it's much like a merge algorithm in

00:46:43,290 --> 00:46:45,359
the stew

00:46:43,559 --> 00:46:47,359
under library is that it's reading the

00:46:45,359 --> 00:46:50,369
values from each of these streams and

00:46:47,359 --> 00:46:55,319
joining them up and the cost is really

00:46:50,369 --> 00:46:57,359
almost nothing and if you do this the

00:46:55,319 --> 00:46:59,670
there's no space taken up by it and it

00:46:57,359 --> 00:47:03,150
scales quite well and it solves the

00:46:59,670 --> 00:47:06,329
problem of having to deal with redundant

00:47:03,150 --> 00:47:08,609
data so this can actually be made to

00:47:06,329 --> 00:47:09,839
scale quite large there's something

00:47:08,609 --> 00:47:11,999
you'll notice that when you get into

00:47:09,839 --> 00:47:14,729
very large databases even trying to pull

00:47:11,999 --> 00:47:16,469
things out by index becomes expensive if

00:47:14,729 --> 00:47:18,059
you have a database that supports index

00:47:16,469 --> 00:47:21,239
organized tables or clustered indexes

00:47:18,059 --> 00:47:23,430
this can scale to many hundreds of

00:47:21,239 --> 00:47:25,349
millions of Records so this is a simple

00:47:23,430 --> 00:47:27,959
utility that can be because the

00:47:25,349 --> 00:47:29,969
interfaces using iterators using a

00:47:27,959 --> 00:47:31,709
container like approach it's relatively

00:47:29,969 --> 00:47:33,839
easy to do these kinds of higher level

00:47:31,709 --> 00:47:37,049
algorithms on on that there are other

00:47:33,839 --> 00:47:40,140
possibilities for joint algorithms more

00:47:37,049 --> 00:47:41,880
general examples including instead of a

00:47:40,140 --> 00:47:43,019
natural join you could say just have an

00:47:41,880 --> 00:47:45,479
order join which takes into account

00:47:43,019 --> 00:47:47,670
maybe column conditions specific to what

00:47:45,479 --> 00:47:49,920
you're trying to join and the other one

00:47:47,670 --> 00:47:52,140
mentioned before which is a much more

00:47:49,920 --> 00:47:55,650
general type of joint if you have a cash

00:47:52,140 --> 00:47:58,380
result set possibly from other databases

00:47:55,650 --> 00:48:01,079
than than the one you're querying on and

00:47:58,380 --> 00:48:03,689
you want the benefit of joining with

00:48:01,079 --> 00:48:08,759
that because it's resident that can be

00:48:03,689 --> 00:48:12,420
built on top of this interface mention

00:48:08,759 --> 00:48:14,009
quickly here that we've been I've been

00:48:12,420 --> 00:48:16,079
showing examples of a direct interface

00:48:14,009 --> 00:48:18,569
which I think most the time is what you

00:48:16,079 --> 00:48:20,459
want but sometimes people want to have a

00:48:18,569 --> 00:48:22,259
polymorphic interface because their

00:48:20,459 --> 00:48:25,109
application has to talk to multiple

00:48:22,259 --> 00:48:28,229
databases and that's what this does you

00:48:25,109 --> 00:48:30,809
can say at runtime I want to have a

00:48:28,229 --> 00:48:33,150
different database on the connection and

00:48:30,809 --> 00:48:35,249
we'll give you that and the way this

00:48:33,150 --> 00:48:36,900
does design is completely transparent to

00:48:35,249 --> 00:48:38,189
the drivers so for instance if you

00:48:36,900 --> 00:48:41,969
implement a driver for a particular

00:48:38,189 --> 00:48:44,119
database it's available in this poly

00:48:41,969 --> 00:48:47,309
interface and this is all done through

00:48:44,119 --> 00:48:49,109
type erasure basically the interface for

00:48:47,309 --> 00:48:52,499
the driver if you specify standard

00:48:49,109 --> 00:48:54,269
database create database you are asking

00:48:52,499 --> 00:48:55,949
for the poly driver and this is

00:48:54,269 --> 00:48:56,950
something that could potentially be in

00:48:55,949 --> 00:48:58,210
the standard

00:48:56,950 --> 00:49:03,160
because it's not specific to any

00:48:58,210 --> 00:49:05,020
database you get it for free if you want

00:49:03,160 --> 00:49:07,180
to look like what it would be like to

00:49:05,020 --> 00:49:10,390
add drivers this is what it would look

00:49:07,180 --> 00:49:13,450
like you just register them based on the

00:49:10,390 --> 00:49:15,970
type so you can say I want to register

00:49:13,450 --> 00:49:18,310
all four databases and by doing that in

00:49:15,970 --> 00:49:24,910
your code you can now ask for

00:49:18,310 --> 00:49:27,130
connections on any of those four I have

00:49:24,910 --> 00:49:29,140
a reference information implementation

00:49:27,130 --> 00:49:32,260
test suite which I won't talk about too

00:49:29,140 --> 00:49:36,130
much doing due to time but needless to

00:49:32,260 --> 00:49:38,710
say this kind of a project needs lots of

00:49:36,130 --> 00:49:40,690
time spent on running through all kinds

00:49:38,710 --> 00:49:42,820
of use cases so I've spent some time

00:49:40,690 --> 00:49:45,400
trying to build out a test suite that's

00:49:42,820 --> 00:49:47,440
going to cover all of these and verify

00:49:45,400 --> 00:49:51,930
that they run for every driver not only

00:49:47,440 --> 00:49:51,930
direct motive but also polymorphic mode

00:49:52,530 --> 00:49:58,090
so just briefly I'll talk a little bit

00:49:56,290 --> 00:50:00,370
about the implementation and a

00:49:58,090 --> 00:50:02,110
implementation detail not all of them

00:50:00,370 --> 00:50:05,160
but as I mentioned before there's a

00:50:02,110 --> 00:50:07,600
front end and there's a driver layer and

00:50:05,160 --> 00:50:08,860
the front end takes care of although the

00:50:07,600 --> 00:50:10,900
reference counting none of that is

00:50:08,860 --> 00:50:12,970
exposed to the user defines all the

00:50:10,900 --> 00:50:14,520
interface functions including redundant

00:50:12,970 --> 00:50:17,290
ones that you'd like for convenience

00:50:14,520 --> 00:50:19,000
manages state manages connection polling

00:50:17,290 --> 00:50:21,970
none of that is done at the driver layer

00:50:19,000 --> 00:50:24,010
so this I see this type of a design as a

00:50:21,970 --> 00:50:25,870
big win otherwise it would have forced

00:50:24,010 --> 00:50:27,310
all kinds of complexity on the driver

00:50:25,870 --> 00:50:29,290
layer that you don't necessarily want

00:50:27,310 --> 00:50:31,060
now that technically you you wouldn't

00:50:29,290 --> 00:50:32,560
have to use this mechanism it is a layer

00:50:31,060 --> 00:50:35,080
on top of that if you wanted to just

00:50:32,560 --> 00:50:37,990
implement a driver to spec you could do

00:50:35,080 --> 00:50:41,170
this but I see this as a big win for

00:50:37,990 --> 00:50:43,360
driver implementation at least for the

00:50:41,170 --> 00:50:45,370
reference implementation driver

00:50:43,360 --> 00:50:47,440
interface the nice thing about that

00:50:45,370 --> 00:50:49,320
drops out of this is that it it really

00:50:47,440 --> 00:50:53,380
it not only is the driver interface

00:50:49,320 --> 00:50:56,230
fairly simple and familiar once you have

00:50:53,380 --> 00:50:58,030
certain template definitions you'll see

00:50:56,230 --> 00:50:59,500
at the bottom here the things which you

00:50:58,030 --> 00:51:02,110
must have implementing this driver to

00:50:59,500 --> 00:51:03,220
work with the front-end is really the

00:51:02,110 --> 00:51:05,320
same layers that you have in the

00:51:03,220 --> 00:51:07,240
front-end database connections statement

00:51:05,320 --> 00:51:09,460
and result and you don't really have to

00:51:07,240 --> 00:51:10,360
manage any resources the resources that

00:51:09,460 --> 00:51:14,410
you need for insta

00:51:10,360 --> 00:51:16,900
it's having to pass parent object to

00:51:14,410 --> 00:51:23,380
child object is all handled by the front

00:51:16,900 --> 00:51:25,600
end as it seen here now I'm going to

00:51:23,380 --> 00:51:27,670
talk a little bit just briefly about a

00:51:25,600 --> 00:51:32,520
challenge although I'm running out of

00:51:27,670 --> 00:51:38,920
time this is an implementation detail

00:51:32,520 --> 00:51:42,280
this this is about polymorphic execution

00:51:38,920 --> 00:51:44,680
and one of the things that is

00:51:42,280 --> 00:51:48,550
challenging about this implementation is

00:51:44,680 --> 00:51:50,940
that you have to pass this is the case

00:51:48,550 --> 00:51:53,760
where you're preparing a statement and

00:51:50,940 --> 00:51:56,110
you're passing arguments repeatedly and

00:51:53,760 --> 00:51:58,810
that must go through a very data comes

00:51:56,110 --> 00:52:02,380
on the front end but what it has to do

00:51:58,810 --> 00:52:04,900
if it's a polymorphic driver is is take

00:52:02,380 --> 00:52:08,650
those and call them with a very Datak

00:52:04,900 --> 00:52:11,050
function in the driver at runtime so I'm

00:52:08,650 --> 00:52:13,600
thinking I you know just because it was

00:52:11,050 --> 00:52:16,630
so motivating to take all of that work

00:52:13,600 --> 00:52:19,000
out of the driver layer maybe I can take

00:52:16,630 --> 00:52:21,160
at runtime that information repackage it

00:52:19,000 --> 00:52:23,500
and call the driver layers very attic

00:52:21,160 --> 00:52:25,330
function without having to put any

00:52:23,500 --> 00:52:27,340
additional complexity and the driver

00:52:25,330 --> 00:52:30,400
layer there are two challenges that

00:52:27,340 --> 00:52:32,350
unpacking variant arguments and second

00:52:30,400 --> 00:52:35,710
needing to transport arguments for one

00:52:32,350 --> 00:52:39,010
variadic template to another and this is

00:52:35,710 --> 00:52:40,600
what it looks like it's I think that

00:52:39,010 --> 00:52:42,100
this is unusual because what you have to

00:52:40,600 --> 00:52:44,260
realize is that you're taking something

00:52:42,100 --> 00:52:46,420
at runtime and you're trying to form a

00:52:44,260 --> 00:52:47,680
very data call that's that's a really

00:52:46,420 --> 00:52:50,470
unusual thing to do you're going

00:52:47,680 --> 00:52:52,750
upstream so you're taking your you're

00:52:50,470 --> 00:52:54,310
taking a vector a very odd a very vector

00:52:52,750 --> 00:52:58,270
of variants and you're saying I want to

00:52:54,310 --> 00:53:00,190
package that into an actual fixed

00:52:58,270 --> 00:53:02,440
argument call and that's what this

00:53:00,190 --> 00:53:03,610
diagram represents and then what I'm

00:53:02,440 --> 00:53:04,990
going to do is I'm going to unpack the

00:53:03,610 --> 00:53:08,080
variants and then I'm gonna call the

00:53:04,990 --> 00:53:09,220
drivers execute and then the driver

00:53:08,080 --> 00:53:16,690
doesn't know whether it came from

00:53:09,220 --> 00:53:19,110
polymorphic driver or not seems okay is

00:53:16,690 --> 00:53:19,110
this a good idea

00:53:19,230 --> 00:53:26,190
so this is what happens when you - this

00:53:22,859 --> 00:53:28,020
is the reason this took two minutes to

00:53:26,190 --> 00:53:33,480
compile and I'm thinking okay why is

00:53:28,020 --> 00:53:35,520
this so what's happening here is I can't

00:53:33,480 --> 00:53:37,920
this this is most definitely a fail but

00:53:35,520 --> 00:53:39,599
it's also kind of awesome to think about

00:53:37,920 --> 00:53:42,300
what it's doing I'm taking if you can

00:53:39,599 --> 00:53:47,130
imagine that you have variable number of

00:53:42,300 --> 00:53:48,930
arguments taken from ten types and you

00:53:47,130 --> 00:53:52,109
have your going to support it up to five

00:53:48,930 --> 00:53:55,320
arguments you are asking the compiler to

00:53:52,109 --> 00:53:56,550
generate over 30,000 functions the fact

00:53:55,320 --> 00:53:59,070
that what this works at all is actually

00:53:56,550 --> 00:54:01,020
kind of interesting now if it hadn't

00:53:59,070 --> 00:54:03,030
taken so long to compile I might have

00:54:01,020 --> 00:54:07,140
thought you know this is great you know

00:54:03,030 --> 00:54:08,760
this look what I did but because it took

00:54:07,140 --> 00:54:10,829
so long that was a tip-off that well

00:54:08,760 --> 00:54:13,440
maybe this is generating far too much

00:54:10,829 --> 00:54:15,210
code but I have to wonder just how much

00:54:13,440 --> 00:54:18,030
code is too much I mean if it really is

00:54:15,210 --> 00:54:21,619
performing work in the modern age maybe

00:54:18,030 --> 00:54:25,380
you know this seems excessive to me but

00:54:21,619 --> 00:54:26,910
the point is is that the impact of this

00:54:25,380 --> 00:54:29,250
is not that great it simply means that

00:54:26,910 --> 00:54:33,030
your driver must support a second call

00:54:29,250 --> 00:54:35,520
with either a vector variance or your to

00:54:33,030 --> 00:54:37,650
your very Dadich argument must support

00:54:35,520 --> 00:54:39,329
variance so it's a little just a tiny

00:54:37,650 --> 00:54:41,730
bit more complexity in the driver and

00:54:39,329 --> 00:54:45,990
that's probably the right call although

00:54:41,730 --> 00:54:48,180
I did learn in STL's talk that the the

00:54:45,990 --> 00:54:50,160
approach of peeling off arguments in a

00:54:48,180 --> 00:54:51,720
very directive template is a horrible

00:54:50,160 --> 00:54:54,180
way to implement it so we'd like to

00:54:51,720 --> 00:54:55,920
least try it for a better approaches in

00:54:54,180 --> 00:54:58,520
parameter packs and see if that may be

00:54:55,920 --> 00:55:00,930
drastically reduces the compile time

00:54:58,520 --> 00:55:02,910
there's a lot of future work here in

00:55:00,930 --> 00:55:05,369
this project and one of the big things

00:55:02,910 --> 00:55:08,420
that should be of interest to everybody

00:55:05,369 --> 00:55:12,480
is to have non-blocking functionality

00:55:08,420 --> 00:55:14,369
this isn't feasible with every driver

00:55:12,480 --> 00:55:16,770
but some drivers do provide this and

00:55:14,369 --> 00:55:19,040
what's needed is for the underlying

00:55:16,770 --> 00:55:21,900
driver to support a non-blocking i/o

00:55:19,040 --> 00:55:23,490
there's one in particular that I have my

00:55:21,900 --> 00:55:29,280
site on which is a project called

00:55:23,490 --> 00:55:31,020
web-scale sequel which is a project out

00:55:29,280 --> 00:55:32,940
of Facebook and a couple other companies

00:55:31,020 --> 00:55:34,920
and it that project

00:55:32,940 --> 00:55:37,109
offers a my sequel compatible driver

00:55:34,920 --> 00:55:39,569
with the additional non-blocking calls

00:55:37,109 --> 00:55:42,630
so if you have a project built upon that

00:55:39,569 --> 00:55:44,190
you can literally use the driver out of

00:55:42,630 --> 00:55:46,050
this project and use it against your

00:55:44,190 --> 00:55:49,290
existing my school database and I'd see

00:55:46,050 --> 00:55:52,349
this is a the first driver with full

00:55:49,290 --> 00:55:54,359
support for this to make this work

00:55:52,349 --> 00:55:56,540
I believe Postgres can also do this as

00:55:54,359 --> 00:55:56,540
well

00:55:56,910 --> 00:56:02,520
reference implementation roadmap there

00:56:00,150 --> 00:56:05,550
is current support here's from my sequel

00:56:02,520 --> 00:56:08,540
and sequel Lite although these phase 2

00:56:05,550 --> 00:56:11,010
databases should appear very quickly I

00:56:08,540 --> 00:56:12,599
do have this project on github although

00:56:11,010 --> 00:56:14,250
there's no code checked in it will be

00:56:12,599 --> 00:56:18,089
checked in soon as soon as I clean it up

00:56:14,250 --> 00:56:20,160
a little bit but this all phase 1 and

00:56:18,089 --> 00:56:21,930
phase 2 do actually work pretty well now

00:56:20,160 --> 00:56:23,700
there's there's a notion between having

00:56:21,930 --> 00:56:25,859
sort of a shallow support for all these

00:56:23,700 --> 00:56:27,990
databases and having deep support for

00:56:25,859 --> 00:56:29,880
instance are you supporting you know

00:56:27,990 --> 00:56:31,890
things like blobs and very you know

00:56:29,880 --> 00:56:33,599
specific types of columns that's going

00:56:31,890 --> 00:56:36,839
to take some time to fill out but in

00:56:33,599 --> 00:56:38,430
terms of being able to run a growing

00:56:36,839 --> 00:56:40,020
test suite that's including you know

00:56:38,430 --> 00:56:43,740
basic things like selecting stuff out I

00:56:40,020 --> 00:56:45,900
think that that's pretty achievable so

00:56:43,740 --> 00:56:47,700
and then phase 3 is to start thinking

00:56:45,900 --> 00:56:56,880
about asynchronous designs and support

00:56:47,700 --> 00:56:59,270
other databases and that's it any

00:56:56,880 --> 00:56:59,270
questions

00:57:40,220 --> 00:57:43,829
so the question was about the fact that

00:57:42,630 --> 00:57:46,339
sequel is different among different

00:57:43,829 --> 00:57:48,359
databases and did you did you say it was

00:57:46,339 --> 00:57:52,170
I'm not sure if you're talking about the

00:57:48,359 --> 00:57:54,060
binding types but I would say that this

00:57:52,170 --> 00:57:55,770
particular layer is is actually not

00:57:54,060 --> 00:57:58,079
concerned with differences in sequel for

00:57:55,770 --> 00:58:00,690
the most part in fact things like that

00:57:58,079 --> 00:58:04,109
the binding syntax is question mark in

00:58:00,690 --> 00:58:06,030
my sequel and is colon filled in another

00:58:04,109 --> 00:58:07,859
database and and this this layer is

00:58:06,030 --> 00:58:12,210
agnostic to that for the most part I may

00:58:07,859 --> 00:58:13,859
be entirely it really matters for a

00:58:12,210 --> 00:58:14,640
higher level code like if you're if

00:58:13,859 --> 00:58:15,690
you're trying to do know where I'm

00:58:14,640 --> 00:58:18,540
framework there's an absolutely

00:58:15,690 --> 00:58:20,790
consideration but because I'm trying to

00:58:18,540 --> 00:58:22,859
focus on the foundation that's that's

00:58:20,790 --> 00:58:25,680
not something I largely see as having to

00:58:22,859 --> 00:58:28,020
handle there are some details there but

00:58:25,680 --> 00:58:30,150
I think was that your example is that I

00:58:28,020 --> 00:58:32,339
think if I recall correctly you are

00:58:30,150 --> 00:58:34,410
looking at higher level constructs for

00:58:32,339 --> 00:58:37,050
how you can know we haven't have to

00:58:34,410 --> 00:58:39,780
write code that will work on any

00:58:37,050 --> 00:58:42,030
supporting database without doing a if

00:58:39,780 --> 00:58:44,819
Oracle something I'll see if my sequel

00:58:42,030 --> 00:58:46,950
something you know yeah that's much more

00:58:44,819 --> 00:58:49,380
ambitious and that's this this is just

00:58:46,950 --> 00:58:52,790
providing the foundational work for you

00:58:49,380 --> 00:58:57,000
to build that kind of an ORM or or

00:58:52,790 --> 00:58:58,020
hibernate like facility I think it's I

00:58:57,000 --> 00:59:00,060
think that's definitely an interesting

00:58:58,020 --> 00:59:06,770
thing to do but that's not necessarily

00:59:00,060 --> 00:59:09,240
what we're trying to do here interesting

00:59:06,770 --> 00:59:11,790
presentation thank you can you go back

00:59:09,240 --> 00:59:15,210
to the slide that shows the papers

00:59:11,790 --> 00:59:17,790
you've read or referenced I just didn't

00:59:15,210 --> 00:59:26,460
I'd like to just get a picture of that

00:59:17,790 --> 00:59:28,560
if I could thank you right so first of

00:59:26,460 --> 00:59:32,150
all I think it's great to see that

00:59:28,560 --> 00:59:34,680
several people are now trying to get

00:59:32,150 --> 00:59:37,200
databases into the standard again that's

00:59:34,680 --> 00:59:39,510
been dead for quite some time so thank

00:59:37,200 --> 00:59:42,089
you for that I'm not sure if string

00:59:39,510 --> 00:59:43,770
based approaches are the thing for the

00:59:42,089 --> 00:59:45,839
standard but that's a different question

00:59:43,770 --> 00:59:48,089
certainly not enough nothing that

00:59:45,839 --> 00:59:51,119
not enough time for it for this year I'm

00:59:48,089 --> 00:59:55,319
interested in in connecting your library

00:59:51,119 --> 00:59:59,130
to SQL plus 11 one feature in SQL plus

00:59:55,319 --> 01:00:02,640
plus 11 is that it can change syntax

00:59:59,130 --> 01:00:06,059
things as as mentioned before depending

01:00:02,640 --> 01:00:09,359
on which data is actually used does your

01:00:06,059 --> 01:00:11,999
database have this information at

01:00:09,359 --> 01:00:14,119
compile time available for a layer like

01:00:11,999 --> 01:00:16,799
SQL plus 11

01:00:14,119 --> 01:00:18,329
I'm sure could I just write probably I

01:00:16,799 --> 01:00:20,910
need to understand the specifics of what

01:00:18,329 --> 01:00:24,900
you need I mean up here so if it well

01:00:20,910 --> 01:00:26,279
the thing is just the just a code note

01:00:24,900 --> 01:00:28,589
or the compiler know at compile time

01:00:26,279 --> 01:00:31,019
that hey this isn't as MySQL database

01:00:28,589 --> 01:00:32,939
for instance so I think it could I mean

01:00:31,019 --> 01:00:35,249
the question is how to implement that I

01:00:32,939 --> 01:00:38,249
mean it's you know I can think of a

01:00:35,249 --> 01:00:41,009
tagged type mechanism but they have to

01:00:38,249 --> 01:00:43,469
be careful about what I specifically put

01:00:41,009 --> 01:00:44,819
in that that in code that might be a

01:00:43,469 --> 01:00:46,469
candidate at some point in the future

01:00:44,819 --> 01:00:47,819
were standard ation because you because

01:00:46,469 --> 01:00:50,039
nothing in the standardization can refer

01:00:47,819 --> 01:00:52,859
to any particular like say enumerations

01:00:50,039 --> 01:00:54,479
or tags yeah it can be I know if it can

01:00:52,859 --> 01:00:57,329
really be a string and the compile time

01:00:54,479 --> 01:00:59,429
but I think I think it's definitely

01:00:57,329 --> 01:01:01,229
doable one way or another so we should

01:00:59,429 --> 01:01:02,910
have a talk afterwards and see and I'd

01:01:01,229 --> 01:01:07,259
like to understand and by the way this

01:01:02,910 --> 01:01:10,289
is you know this is my sort of notion

01:01:07,259 --> 01:01:11,999
after you know years of hand rolling

01:01:10,289 --> 01:01:13,499
database interfaces and looking at

01:01:11,999 --> 01:01:16,189
various projects and just just

01:01:13,499 --> 01:01:19,769
experience about what is sensible to me

01:01:16,189 --> 01:01:21,329
once I I think this is on github and

01:01:19,769 --> 01:01:23,130
people come interested I'm really

01:01:21,329 --> 01:01:26,160
interested to see what the community

01:01:23,130 --> 01:01:27,509
thinks of this interface and I might

01:01:26,160 --> 01:01:30,749
expect it to change quite a bit over

01:01:27,509 --> 01:01:33,119
time based on a larger group of people

01:01:30,749 --> 01:01:35,130
trying it and finding what works and

01:01:33,119 --> 01:01:39,150
what doesn't so I really if you have any

01:01:35,130 --> 01:01:40,739
kind of effort or interest in you know

01:01:39,150 --> 01:01:43,799
working on this project please please

01:01:40,739 --> 01:01:45,390
talk to me so yeah I think that I would

01:01:43,799 --> 01:01:49,529
like to talk to you further about that

01:01:45,390 --> 01:01:52,859
okay hi of simple questions what is the

01:01:49,529 --> 01:01:54,900
licensing licensing level of the of the

01:01:52,859 --> 01:01:56,489
library that's on github whatever is the

01:01:54,900 --> 01:01:59,400
most liberal so I don't know if that's

01:01:56,489 --> 01:02:02,910
MIT it's definitely this is this is

01:01:59,400 --> 01:02:04,440
not there's no attempt to commercialize

01:02:02,910 --> 01:02:07,500
this at all is going to be the most

01:02:04,440 --> 01:02:10,230
liberal license it works for you know

01:02:07,500 --> 01:02:12,960
everybody's use case great my second

01:02:10,230 --> 01:02:14,640
question is the exam the code examples

01:02:12,960 --> 01:02:18,510
that you gave in the slides are they all

01:02:14,640 --> 01:02:24,210
examples of current functionality they

01:02:18,510 --> 01:02:25,380
were not everything but maybe 80% I mean

01:02:24,210 --> 01:02:26,850
there are some things I think there a

01:02:25,380 --> 01:02:28,740
couple slides where I had maybe some

01:02:26,850 --> 01:02:30,390
future capabilities that depend upon

01:02:28,740 --> 01:02:34,380
things appearing in the standard but I

01:02:30,390 --> 01:02:36,270
would say that 89% is in the code once

01:02:34,380 --> 01:02:38,520
it's checked in you will be able to do

01:02:36,270 --> 01:02:40,500
that now there probably some things yeah

01:02:38,520 --> 01:02:42,920
I would say that's reasonable now there

01:02:40,500 --> 01:02:45,540
are certain kinds of like I said before

01:02:42,920 --> 01:02:47,850
rounding out all of the the various

01:02:45,540 --> 01:02:50,520
support for types within the day basis

01:02:47,850 --> 01:02:53,190
is often a lot of work just making sure

01:02:50,520 --> 01:02:55,860
that everything every type is supported

01:02:53,190 --> 01:02:58,740
and can be input bound output bound but

01:02:55,860 --> 01:03:01,050
yes you should see nearly all that

01:02:58,740 --> 01:03:05,460
functionality available and they may

01:03:01,050 --> 01:03:06,690
depend upon of course C++ 11 by minimum

01:03:05,460 --> 01:03:09,210
I'm going to try and work my way

01:03:06,690 --> 01:03:11,100
backwards from 17 because I suspect that

01:03:09,210 --> 01:03:13,830
there will be people interested who and

01:03:11,100 --> 01:03:16,650
want to use framework in 14 or 11 and

01:03:13,830 --> 01:03:20,400
and I can probably just reduce some

01:03:16,650 --> 01:03:22,050
features if they're not supported so yes

01:03:20,400 --> 01:03:24,330
are there sample programs who can

01:03:22,050 --> 01:03:26,520
download there will be I mean I the

01:03:24,330 --> 01:03:29,940
intention is I'll put lots of examples

01:03:26,520 --> 01:03:31,860
on the github page and and you'll be

01:03:29,940 --> 01:03:36,510
able to see a lot by looking at the test

01:03:31,860 --> 01:03:38,100
framework so by the way this is this is

01:03:36,510 --> 01:03:41,010
a header only a library and part of the

01:03:38,100 --> 01:03:43,200
reason for that is it forces me not to

01:03:41,010 --> 01:03:45,960
have to choose one of 20 build tools

01:03:43,200 --> 01:03:47,670
including my own I'd like to write so by

01:03:45,960 --> 01:03:50,010
doing a header only just you should be

01:03:47,670 --> 01:03:51,750
able to just you know check it out and

01:03:50,010 --> 01:03:53,070
actually drop it in as a clued path and

01:03:51,750 --> 01:03:55,410
it should work except for the test suite

01:03:53,070 --> 01:03:57,720
that might require a slight build but it

01:03:55,410 --> 01:03:59,730
should be I do want to be extremely

01:03:57,720 --> 01:04:02,220
convenient to use even to the extent of

01:03:59,730 --> 01:04:04,500
like if I can put it on brew to just

01:04:02,220 --> 01:04:07,380
make it paint there's really just quite

01:04:04,500 --> 01:04:09,650
simple to use I would be happy thank you

01:04:07,380 --> 01:04:09,650
very much

01:04:09,870 --> 01:04:15,160
sometimes results

01:04:11,920 --> 01:04:18,160
from SQL statements are returned in

01:04:15,160 --> 01:04:20,739
chunks to the calling program would

01:04:18,160 --> 01:04:23,170
there be iterators that are smart enough

01:04:20,739 --> 01:04:29,799
to let you go through a whole returned

01:04:23,170 --> 01:04:31,180
data set and so that it would hide the

01:04:29,799 --> 01:04:34,930
fact that it's actually being returned

01:04:31,180 --> 01:04:37,480
in in chunks that's exactly what output

01:04:34,930 --> 01:04:38,739
binding does for you so you know that a

01:04:37,480 --> 01:04:41,140
lot of times when you look at a database

01:04:38,739 --> 01:04:44,049
API it shows you as a user how to

01:04:41,140 --> 01:04:46,390
achieve that and at some point in

01:04:44,049 --> 01:04:48,009
rolling databases I realize that that

01:04:46,390 --> 01:04:51,869
could be hidden from the user so just

01:04:48,009 --> 01:04:54,130
when you specify an array binding size

01:04:51,869 --> 01:04:57,009
internally it's going to allocate a

01:04:54,130 --> 01:04:58,960
buffer for a certain amount of size and

01:04:57,009 --> 01:05:00,430
when you are fetching row by row you're

01:04:58,960 --> 01:05:02,109
not going you're not round tripping in

01:05:00,430 --> 01:05:04,420
the database you're only round tripping

01:05:02,109 --> 01:05:06,039
when that buffer needs to be fresh so is

01:05:04,420 --> 01:05:07,749
it did I did I answer your question yeah

01:05:06,039 --> 01:05:11,349
so hopefully you get all those benefits

01:05:07,749 --> 01:05:13,239
without having to do anything in the

01:05:11,349 --> 01:05:16,680
user code just by specifying an output

01:05:13,239 --> 01:05:16,680
buffer thank you

01:05:17,099 --> 01:05:20,190

YouTube URL: https://www.youtube.com/watch?v=75aUjcYr6vE


