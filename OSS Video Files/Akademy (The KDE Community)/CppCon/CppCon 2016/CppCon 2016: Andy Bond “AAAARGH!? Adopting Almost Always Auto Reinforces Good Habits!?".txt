Title: CppCon 2016: Andy Bond “AAAARGH!? Adopting Almost Always Auto Reinforces Good Habits!?"
Publication date: 2016-09-30
Playlist: CppCon 2016
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016
—
Prominent members of the C++ community are advocating the "almost-always-auto" idiom, but there are understandable concerns from many about its implications. This case study will demonstrate how it may be applied in different situations, suggest ways to avoid performance penalties, introduce algorithms to minimize the "almost" part, and discuss the overall impact.
— 
Andy Bond
Lead Software Engineer, Blizzard Entertainment
I've been programming professionally at Blizzard for over 16 years and am currently a Lead Software Engineer for Heroes of the Storm. While my day-to-day focus is on providing the best gameplay experience for our players, in my spare time I enjoy tinkering with the latest C++ features to discover better ways to implement whatever our designers dream up next.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,940
okay good afternoon everyone my name is

00:00:03,120 --> 00:00:08,940
Annie bond I'm a lead software engineer

00:00:05,940 --> 00:00:12,389
at Blizzard Entertainment I've worked

00:00:08,940 --> 00:00:15,690
there for the last 16 years I've on

00:00:12,389 --> 00:00:19,980
games like Warcraft three more than

00:00:15,690 --> 00:00:23,970
Warcraft Starcraft 2 and most recently

00:00:19,980 --> 00:00:25,500
here is in the storm and I want to thank

00:00:23,970 --> 00:00:27,779
you all for joining me to talk about

00:00:25,500 --> 00:00:31,740
what many would consider to be a

00:00:27,779 --> 00:00:36,149
controversial subject that is the almost

00:00:31,740 --> 00:00:39,420
always auto idiom so before I get too

00:00:36,149 --> 00:00:40,829
in-depth the far marshal has asked me to

00:00:39,420 --> 00:00:43,020
let everyone know that if you have

00:00:40,829 --> 00:00:45,899
torches and pitchforks please take them

00:00:43,020 --> 00:00:47,730
outside it's not safe in here if you

00:00:45,899 --> 00:00:52,800
want to form an unordered mob outside

00:00:47,730 --> 00:00:54,840
that would be the best thing I think so

00:00:52,800 --> 00:00:56,789
to give you a heads up of where we're

00:00:54,840 --> 00:00:59,579
headed today first I'm going to cover

00:00:56,789 --> 00:01:02,070
what the idiom is in case you're not

00:00:59,579 --> 00:01:05,909
familiar with it then I'll walk you

00:01:02,070 --> 00:01:08,189
through a case study that I picked to

00:01:05,909 --> 00:01:12,510
try to understand the implications that

00:01:08,189 --> 00:01:15,630
has on code that I work with and then

00:01:12,510 --> 00:01:18,020
I'll walk through examples for how we

00:01:15,630 --> 00:01:24,000
can apply almost always auto two

00:01:18,020 --> 00:01:27,900
variables two functions lambdas then

00:01:24,000 --> 00:01:30,110
we'll take a look at how we can deal

00:01:27,900 --> 00:01:33,210
with some problems that come up with

00:01:30,110 --> 00:01:38,159
branching and looping and I'll conclude

00:01:33,210 --> 00:01:41,970
with a overall take away kind of my

00:01:38,159 --> 00:01:43,470
observations based on this experience so

00:01:41,970 --> 00:01:46,530
the idiom if you haven't heard of it

00:01:43,470 --> 00:01:52,140
before really what it's all about is

00:01:46,530 --> 00:01:53,579
trying to prefer to reduce types trying

00:01:52,140 --> 00:01:56,729
to deduce types as much as possible

00:01:53,579 --> 00:02:00,240
rather than using explicit types it

00:01:56,729 --> 00:02:04,259
leverages new C++ 11 and 14 keywords

00:02:00,240 --> 00:02:08,310
like Auto and deco type and tackle type

00:02:04,259 --> 00:02:10,770
ah no it's primarily been put forward in

00:02:08,310 --> 00:02:13,750
the community by herb Sutter and Scott

00:02:10,770 --> 00:02:16,570
Myers and I think herbs

00:02:13,750 --> 00:02:18,640
sums it up pretty well here that the

00:02:16,570 --> 00:02:23,020
intent is to write code against

00:02:18,640 --> 00:02:26,560
interfaces not implementations when I

00:02:23,020 --> 00:02:28,150
took a look at trying to see how this

00:02:26,560 --> 00:02:30,910
could be applied in code bases that I

00:02:28,150 --> 00:02:33,970
work with and talking to the rest of my

00:02:30,910 --> 00:02:36,930
team there was a lot of concern quite

00:02:33,970 --> 00:02:39,910
understandably so about the impact that

00:02:36,930 --> 00:02:47,709
using this style would have on code

00:02:39,910 --> 00:02:49,990
readability versus flexibility so since

00:02:47,709 --> 00:02:52,600
I'm from a gaming background I picked a

00:02:49,990 --> 00:02:54,940
very simple game to try to understand

00:02:52,600 --> 00:02:58,270
the implications that it would have on

00:02:54,940 --> 00:03:00,010
code bases that I'm familiar with so we

00:02:58,270 --> 00:03:02,740
have a very simple game loop on the

00:03:00,010 --> 00:03:07,690
right hand side which will form the core

00:03:02,740 --> 00:03:10,510
of our evaluation and the game just

00:03:07,690 --> 00:03:14,530
starts your player at a maximum amount

00:03:10,510 --> 00:03:18,100
of life and then you cast one of two

00:03:14,530 --> 00:03:20,230
random spells each turn each spell will

00:03:18,100 --> 00:03:23,470
either increase or decrease your life

00:03:20,230 --> 00:03:30,160
and then the game ends when you have no

00:03:23,470 --> 00:03:34,209
life remaining so here's the definition

00:03:30,160 --> 00:03:36,570
of the game struck that we saw use them

00:03:34,209 --> 00:03:38,860
a previous line pretty straightforward

00:03:36,570 --> 00:03:41,920
again this is no this doesn't have any

00:03:38,860 --> 00:03:44,769
almost always auto principles assigned

00:03:41,920 --> 00:03:47,049
to it yet this is just a framework for

00:03:44,769 --> 00:03:50,560
us to talk about the effect that that's

00:03:47,049 --> 00:03:53,830
going to have so at the top I have an

00:03:50,560 --> 00:03:57,750
alias named life which is currently an

00:03:53,830 --> 00:04:00,910
unsigned integer below that I have a

00:03:57,750 --> 00:04:03,720
maximum amount of life as a static

00:04:00,910 --> 00:04:06,519
constant property of the class

00:04:03,720 --> 00:04:11,220
underneath that I have the default

00:04:06,519 --> 00:04:13,420
32-bit unsigned 32-bit Mersenne twister

00:04:11,220 --> 00:04:16,690
pseudo-random number generator which

00:04:13,420 --> 00:04:20,739
I'll used to do a variety of random

00:04:16,690 --> 00:04:22,840
choice in the program underneath that I

00:04:20,739 --> 00:04:25,960
have the current value of life which is

00:04:22,840 --> 00:04:28,990
default member initialized to

00:04:25,960 --> 00:04:31,720
the maximum amount of life and then

00:04:28,990 --> 00:04:35,259
finally I have three functions that will

00:04:31,720 --> 00:04:37,599
help to us to understand how almost

00:04:35,259 --> 00:04:41,380
always auto can apply to them to them

00:04:37,599 --> 00:04:45,280
our spell functions heal and hurt they

00:04:41,380 --> 00:04:47,380
both take a life value as an L value

00:04:45,280 --> 00:04:50,860
reference and then return it back out

00:04:47,380 --> 00:04:53,080
and then finally the turn function which

00:04:50,860 --> 00:04:55,360
we saw in the previous slide just simply

00:04:53,080 --> 00:05:01,150
returns a boolean to indicate whether

00:04:55,360 --> 00:05:02,919
the game should continue so here's the

00:05:01,150 --> 00:05:05,470
implementation of the healing hurt

00:05:02,919 --> 00:05:08,380
function nothing very sophisticated here

00:05:05,470 --> 00:05:10,539
I've had to add an extra alias here for

00:05:08,380 --> 00:05:15,009
uniform and distribution just so that

00:05:10,539 --> 00:05:17,860
everything fits on the slide so inside

00:05:15,009 --> 00:05:21,729
each function we define a uniform int

00:05:17,860 --> 00:05:24,699
distribution which either will pick a

00:05:21,729 --> 00:05:28,569
random value between zero and the

00:05:24,699 --> 00:05:31,570
missing amount of life or zero and the

00:05:28,569 --> 00:05:34,030
current amount of life and then it'll

00:05:31,570 --> 00:05:38,740
either add or subtract that value as we

00:05:34,030 --> 00:05:41,020
go forward and use these spells and then

00:05:38,740 --> 00:05:44,340
finally here's the turn function it

00:05:41,020 --> 00:05:47,500
declares an alias at the top to kind of

00:05:44,340 --> 00:05:51,039
hide the nastiness of a pointer to

00:05:47,500 --> 00:05:54,280
member function syntax we define an

00:05:51,039 --> 00:05:57,520
unsigned array with each of the to spell

00:05:54,280 --> 00:05:59,590
member functions inside of it and then

00:05:57,520 --> 00:06:04,050
below that we have another uniform and

00:05:59,590 --> 00:06:06,460
distribution which we're using to try to

00:06:04,050 --> 00:06:09,810
decide which element we're going to pick

00:06:06,460 --> 00:06:13,930
from the unsigned array up above and you

00:06:09,810 --> 00:06:18,840
can see that we're using the uniform

00:06:13,930 --> 00:06:20,530
distribution underneath that and then

00:06:18,840 --> 00:06:22,440
dereferencing the pointer to member

00:06:20,530 --> 00:06:25,389
function and then calling the life

00:06:22,440 --> 00:06:28,360
passing at the life value checking that

00:06:25,389 --> 00:06:34,750
the result is greater than zero to just

00:06:28,360 --> 00:06:37,270
sign if we should continue okay so when

00:06:34,750 --> 00:06:38,750
starting to apply almost always Auto

00:06:37,270 --> 00:06:41,060
principles I

00:06:38,750 --> 00:06:43,760
I kind of followed these general

00:06:41,060 --> 00:06:45,530
guidelines and by the way for any code

00:06:43,760 --> 00:06:47,630
that you see on here it's all on github

00:06:45,530 --> 00:06:50,990
there will be a link at the end and I'll

00:06:47,630 --> 00:06:56,060
send my my slides out to the committee

00:06:50,990 --> 00:06:57,560
so they have those available the the

00:06:56,060 --> 00:07:00,230
guidelines I followed were to use

00:06:57,560 --> 00:07:03,980
forwarding Auto as much as possible

00:07:00,230 --> 00:07:06,350
it's very universally applicable it

00:07:03,980 --> 00:07:09,200
works with both l valuing our value

00:07:06,350 --> 00:07:13,910
references works with non copyable and

00:07:09,200 --> 00:07:18,560
non moveable types any in any instance

00:07:13,910 --> 00:07:21,470
where i had a variable that i wanted to

00:07:18,560 --> 00:07:24,830
make sure that compiler enforced was not

00:07:21,470 --> 00:07:28,130
mutable then I'd add I used Const L

00:07:24,830 --> 00:07:30,740
value reference to auto instead and for

00:07:28,130 --> 00:07:33,860
any circumstance for I definitively want

00:07:30,740 --> 00:07:39,530
to copy or move then I'll just use plain

00:07:33,860 --> 00:07:43,090
auto and I avoided using pointer to auto

00:07:39,530 --> 00:07:47,720
or L value reference to auto because I

00:07:43,090 --> 00:07:49,880
felt like for the forwarding auto that

00:07:47,720 --> 00:07:53,180
kind of encapsulates everything I need I

00:07:49,880 --> 00:07:55,550
don't need to specifically use the L

00:07:53,180 --> 00:07:58,220
value reference daughter and uncle type

00:07:55,550 --> 00:08:04,990
on it was really mostly intended fries

00:07:58,220 --> 00:08:08,120
with forwarding functions anyway so I

00:08:04,990 --> 00:08:11,470
started to apply these principles and I

00:08:08,120 --> 00:08:14,630
immediately ran into trouble because the

00:08:11,470 --> 00:08:16,520
only variables that are members of the

00:08:14,630 --> 00:08:19,700
class that I can convert using almost

00:08:16,520 --> 00:08:24,320
always thought of style is the maximum

00:08:19,700 --> 00:08:28,160
amount of life because the standard

00:08:24,320 --> 00:08:30,440
doesn't allow you to use to define the

00:08:28,160 --> 00:08:34,520
other two variables here the engine and

00:08:30,440 --> 00:08:36,409
life values as auto and I believe the

00:08:34,520 --> 00:08:38,599
reason for that and some someone can

00:08:36,409 --> 00:08:40,880
correct me if I'm wrong is that we're

00:08:38,599 --> 00:08:43,760
concerned about potential ambiguity if

00:08:40,880 --> 00:08:47,690
you have constructors and initializer

00:08:43,760 --> 00:08:49,940
lists so that's a real shame

00:08:47,690 --> 00:08:51,940
the syntax at the bottom I didn't even I

00:08:49,940 --> 00:08:54,130
just included for

00:08:51,940 --> 00:08:55,570
completeness sake this is basically

00:08:54,130 --> 00:08:57,750
mimicking what

00:08:55,570 --> 00:09:03,100
Declan ibotta would do but I would I

00:08:57,750 --> 00:09:05,880
it's not worth it to really do that we

00:09:03,100 --> 00:09:08,380
have a little bit more luck with the

00:09:05,880 --> 00:09:10,690
non-member variables that are inside of

00:09:08,380 --> 00:09:12,519
the spell functions those are very

00:09:10,690 --> 00:09:14,529
straightforward to convert over I just

00:09:12,519 --> 00:09:17,140
picked her as an example here you can

00:09:14,529 --> 00:09:20,920
apply the same transformation to the

00:09:17,140 --> 00:09:24,300
heal function it simply moves the type

00:09:20,920 --> 00:09:33,310
to the right hand side initializer and

00:09:24,300 --> 00:09:35,920
then uses forwarding on it for the array

00:09:33,310 --> 00:09:38,260
of spells that I had inside of the turn

00:09:35,920 --> 00:09:42,459
function this was a little bit more

00:09:38,260 --> 00:09:47,790
difficult to contend with at the top the

00:09:42,459 --> 00:09:50,709
first attempt is stood initializer list

00:09:47,790 --> 00:09:52,570
at least that's what it reduces to which

00:09:50,709 --> 00:09:55,149
isn't really what I want because you

00:09:52,570 --> 00:09:58,060
can't directly use subscript operator

00:09:55,149 --> 00:10:00,579
with the initializer list you can of

00:09:58,060 --> 00:10:02,980
course use stood begin on an

00:10:00,579 --> 00:10:05,440
initializing list they're guaranteed to

00:10:02,980 --> 00:10:07,600
be contiguous so you could use that to

00:10:05,440 --> 00:10:11,290
kind of index into it but that's not

00:10:07,600 --> 00:10:16,209
really very convenient next you might

00:10:11,290 --> 00:10:20,279
try to do to add brackets brackets there

00:10:16,209 --> 00:10:22,240
to specify an unsigned or a sized array

00:10:20,279 --> 00:10:24,910
unfortunately it doesn't work either the

00:10:22,240 --> 00:10:28,630
compiler says that that's arrays of auto

00:10:24,910 --> 00:10:32,050
or not permitted the closest I was able

00:10:28,630 --> 00:10:34,870
to get was to define an alias which has

00:10:32,050 --> 00:10:38,709
the type there so that the braces can be

00:10:34,870 --> 00:10:41,649
treated as a constructor but this still

00:10:38,709 --> 00:10:42,940
isn't that scalable because for each

00:10:41,649 --> 00:10:44,680
different type that you want to create

00:10:42,940 --> 00:10:46,690
an array of you have to declare an alias

00:10:44,680 --> 00:10:54,790
so that's not a really great solution

00:10:46,690 --> 00:10:58,089
either the library fundamentals ts has a

00:10:54,790 --> 00:11:01,420
function that they're proposing called

00:10:58,089 --> 00:11:04,440
make array which actually helps quite a

00:11:01,420 --> 00:11:04,440
bit in this case

00:11:04,960 --> 00:11:09,430
simply provided however many arguments

00:11:07,060 --> 00:11:11,860
you want and based on the number of

00:11:09,430 --> 00:11:14,590
arguments it will create a stood array

00:11:11,860 --> 00:11:17,410
using the common type of all arguments

00:11:14,590 --> 00:11:19,450
that you pass in so I think this is this

00:11:17,410 --> 00:11:22,330
is a pretty useful addition and I hope

00:11:19,450 --> 00:11:25,810
to see it added to a standard officially

00:11:22,330 --> 00:11:27,370
soon it has a nice property as well

00:11:25,810 --> 00:11:31,870
which you can see at the bottom here

00:11:27,370 --> 00:11:34,030
where if you explicitly pass in a type

00:11:31,870 --> 00:11:37,000
here it will override what it would

00:11:34,030 --> 00:11:40,000
normally try to deduce so what would

00:11:37,000 --> 00:11:43,380
normally be a dinner a of three intz

00:11:40,000 --> 00:11:45,430
becomes a stud array of three doubles

00:11:43,380 --> 00:11:47,770
even though many of the Makery

00:11:45,430 --> 00:11:51,220
are sorry many of them make functions

00:11:47,770 --> 00:11:54,190
are likely to go out of style with c++

00:11:51,220 --> 00:11:55,240
17 I think this this function in

00:11:54,190 --> 00:12:02,860
particular is still going to be very

00:11:55,240 --> 00:12:05,200
useful okay so next I took a look at how

00:12:02,860 --> 00:12:08,140
I can apply almost always Auto to the

00:12:05,200 --> 00:12:10,300
functions that I have and the general

00:12:08,140 --> 00:12:14,680
guidelines that I followed were using

00:12:10,300 --> 00:12:18,340
Auto for any circumstance where I wanted

00:12:14,680 --> 00:12:22,360
to return a local variable or an hour

00:12:18,340 --> 00:12:26,350
value and if a function has multiple

00:12:22,360 --> 00:12:29,170
return types then on the auto will be

00:12:26,350 --> 00:12:32,440
deduced as the common type of all return

00:12:29,170 --> 00:12:34,630
statements I didn't really have any

00:12:32,440 --> 00:12:37,570
getters in this example but if I did

00:12:34,630 --> 00:12:40,810
have them then I would use an l-value

00:12:37,570 --> 00:12:43,840
reference to auto for those as the

00:12:40,810 --> 00:12:47,710
return type and then for any functions

00:12:43,840 --> 00:12:50,050
that simply return the value of calling

00:12:47,710 --> 00:12:52,300
another function basically forwarding

00:12:50,050 --> 00:12:53,860
functions I'll use deckle type audio so

00:12:52,300 --> 00:12:57,160
that way if the function that I'm

00:12:53,860 --> 00:12:57,880
calling happens to return by value or by

00:12:57,160 --> 00:13:00,670
reference

00:12:57,880 --> 00:13:04,330
it'll pass that directly through as the

00:13:00,670 --> 00:13:07,780
same type and then finally if I needed

00:13:04,330 --> 00:13:09,250
to fina anything I prefer to use Auto

00:13:07,780 --> 00:13:11,940
even though it doesn't really bias

00:13:09,250 --> 00:13:15,610
anything here just to kind of help to

00:13:11,940 --> 00:13:18,170
corral the spin a statement out of the

00:13:15,610 --> 00:13:20,600
left-hand side and a

00:13:18,170 --> 00:13:23,680
after the parameters that has a nice

00:13:20,600 --> 00:13:26,840
side effect where if you want to use

00:13:23,680 --> 00:13:29,540
expressions VNA using the parameters you

00:13:26,840 --> 00:13:32,450
can you can do that by moving it there I

00:13:29,540 --> 00:13:37,520
think it just looks nicer to have it on

00:13:32,450 --> 00:13:42,680
that side so the first thing I did was

00:13:37,520 --> 00:13:46,760
to try to take an opportunity to look at

00:13:42,680 --> 00:13:49,190
the common patterns that were already in

00:13:46,760 --> 00:13:51,830
the code you may recall there were

00:13:49,190 --> 00:13:54,250
multiple instances where I defined a

00:13:51,830 --> 00:13:57,380
uniform in distribution so I said well

00:13:54,250 --> 00:13:59,960
let me see if I can do more deduction

00:13:57,380 --> 00:14:01,940
here by creating a helper function I've

00:13:59,960 --> 00:14:05,030
called it make UD here just to keep it

00:14:01,940 --> 00:14:09,320
on the slide and what this does is it

00:14:05,030 --> 00:14:11,840
takes two template parameters a and B

00:14:09,320 --> 00:14:14,570
which can be different types it will

00:14:11,840 --> 00:14:18,740
then deduce the common type of those and

00:14:14,570 --> 00:14:20,270
pass that as arguments to the D type

00:14:18,740 --> 00:14:24,080
here which is the uniform in tester

00:14:20,270 --> 00:14:26,570
bution you may also notice that this fee

00:14:24,080 --> 00:14:29,150
name is based on whether or not the

00:14:26,570 --> 00:14:31,400
common type is integral so you can

00:14:29,150 --> 00:14:35,240
imagine defining an overload for this

00:14:31,400 --> 00:14:37,280
which span a is based on whether it's a

00:14:35,240 --> 00:14:40,040
floating point type and then you don't

00:14:37,280 --> 00:14:42,920
have to worry about typing out uniform

00:14:40,040 --> 00:14:48,290
and distribution everywhere so I like

00:14:42,920 --> 00:14:51,560
that approach so here I've updated the

00:14:48,290 --> 00:14:54,800
functions to apply the rules that I just

00:14:51,560 --> 00:14:58,820
mentioned as well as to use the makey d

00:14:54,800 --> 00:15:03,950
helper function that I wrote the logic

00:14:58,820 --> 00:15:05,420
is all the same but it has the most of

00:15:03,950 --> 00:15:08,350
the types removed the only thing that's

00:15:05,420 --> 00:15:11,270
really still visible is the parameter on

00:15:08,350 --> 00:15:14,890
the heel and the Herk function which

00:15:11,270 --> 00:15:14,890
isn't shown here just for space reasons

00:15:17,470 --> 00:15:25,210
I think I can do one better for the

00:15:21,330 --> 00:15:27,460
selection of a random spell I really

00:15:25,210 --> 00:15:29,380
want to pick a random element in the

00:15:27,460 --> 00:15:32,080
range since I have an array to work with

00:15:29,380 --> 00:15:35,620
I'm might as well have a function to do

00:15:32,080 --> 00:15:37,030
that so C++ 17 has another function

00:15:35,620 --> 00:15:41,440
coming in that's going to allow you to

00:15:37,030 --> 00:15:42,880
select n elements from a range but in

00:15:41,440 --> 00:15:46,270
this case I just want something simple I

00:15:42,880 --> 00:15:51,030
just want one so I have the begin and

00:15:46,270 --> 00:15:56,050
end of a range as well as the G is the

00:15:51,030 --> 00:15:59,680
gonna stand in for the uniform stood

00:15:56,050 --> 00:16:03,940
around a number generator and then I I

00:15:59,680 --> 00:16:06,160
simply figure out how much how many

00:16:03,940 --> 00:16:09,790
elements are between the two iterators

00:16:06,160 --> 00:16:14,410
that I passed in and as I did previously

00:16:09,790 --> 00:16:17,710
and then I call stood next to advance

00:16:14,410 --> 00:16:19,270
the first iterator that many times now

00:16:17,710 --> 00:16:21,280
I've specified this is an input iterator

00:16:19,270 --> 00:16:23,260
you could do that it would be better and

00:16:21,280 --> 00:16:25,060
more efficient as a random iterator so

00:16:23,260 --> 00:16:30,490
just keep that in mind if you want to

00:16:25,060 --> 00:16:31,720
use this and you your own code here you

00:16:30,490 --> 00:16:34,210
can see and apply it to the turn

00:16:31,720 --> 00:16:37,480
function it's obviously more code than

00:16:34,210 --> 00:16:40,300
we saw before but we don't have to deal

00:16:37,480 --> 00:16:44,770
with trying to calculate the distance

00:16:40,300 --> 00:16:51,880
between those two and everything else is

00:16:44,770 --> 00:16:55,840
basically the same here so you may

00:16:51,880 --> 00:16:58,500
recall that the functions that we still

00:16:55,840 --> 00:17:03,010
had for the spells they still had a

00:16:58,500 --> 00:17:04,930
parameter with a named type so I want to

00:17:03,010 --> 00:17:07,390
take this a little bit further and try

00:17:04,930 --> 00:17:09,570
to find a way to get rid of that type to

00:17:07,390 --> 00:17:11,710
see what it would look like in that case

00:17:09,570 --> 00:17:14,650
so the guidelines that I followed for

00:17:11,710 --> 00:17:17,710
lambdas I use forwarding Auto

00:17:14,650 --> 00:17:19,470
for any circumstances where I have a

00:17:17,710 --> 00:17:22,990
Landon that I want to give a name to

00:17:19,470 --> 00:17:26,050
I'll use forwarding Auto for input

00:17:22,990 --> 00:17:29,080
parameters and then I'll use an l-value

00:17:26,050 --> 00:17:29,980
reference to auto for any parameters

00:17:29,080 --> 00:17:32,230
that you

00:17:29,980 --> 00:17:34,630
kind of have their lifetime managed

00:17:32,230 --> 00:17:38,920
outside of the lambda like we did with

00:17:34,630 --> 00:17:44,200
the life for any lambdas that need to

00:17:38,920 --> 00:17:46,720
return by reference I've done I've used

00:17:44,200 --> 00:17:48,580
L value reference to Auto as the

00:17:46,720 --> 00:17:52,270
trailing return type here since by

00:17:48,580 --> 00:17:55,630
default lambdas won't return Auto just

00:17:52,270 --> 00:17:58,240
playing Auto and then for any forwarding

00:17:55,630 --> 00:17:59,710
functions or forwarding lambdas that I

00:17:58,240 --> 00:18:02,110
want to use

00:17:59,710 --> 00:18:04,300
I'll use the trailing return type of

00:18:02,110 --> 00:18:06,040
deckle type ATO to get the same

00:18:04,300 --> 00:18:12,160
functionality I had with forwarding

00:18:06,040 --> 00:18:16,240
functions so I can now define the heel

00:18:12,160 --> 00:18:20,110
function within the body of the turn

00:18:16,240 --> 00:18:23,260
function as a lambda and this gets rid

00:18:20,110 --> 00:18:29,170
of any explicit types that we had listed

00:18:23,260 --> 00:18:31,660
in a signature I had to update this to

00:18:29,170 --> 00:18:34,210
pass the engine as an additional

00:18:31,660 --> 00:18:36,700
parameter you'll see why on the next

00:18:34,210 --> 00:18:42,220
slide and I did that instead of just

00:18:36,700 --> 00:18:43,240
capturing this and passing it through so

00:18:42,220 --> 00:18:46,510
beacon

00:18:43,240 --> 00:18:52,960
sorry because we can now do I might go

00:18:46,510 --> 00:18:56,430
up okay sorry because we can now define

00:18:52,960 --> 00:19:00,190
the spells as lambdas we can actually

00:18:56,430 --> 00:19:06,760
declare them as independent parameters

00:19:00,190 --> 00:19:08,290
of make array and this the only

00:19:06,760 --> 00:19:11,050
constraint that we have to use in this

00:19:08,290 --> 00:19:14,050
circumstance is that because these

00:19:11,050 --> 00:19:18,340
spells are all lambdas lambdas all have

00:19:14,050 --> 00:19:20,890
a unique type so I have to cast the

00:19:18,340 --> 00:19:23,260
lambdas to a uniform function pointer

00:19:20,890 --> 00:19:25,390
which I've defined up above the

00:19:23,260 --> 00:19:27,820
signature for that just to make sure

00:19:25,390 --> 00:19:30,940
that if I have multiple lambdas passed

00:19:27,820 --> 00:19:34,990
in to make array they'll be considered

00:19:30,940 --> 00:19:37,180
the same type then this is the rest of

00:19:34,990 --> 00:19:39,810
the turn function wouldn't really need

00:19:37,180 --> 00:19:39,810
to change any further

00:19:41,740 --> 00:19:47,870
so I want to take a stock of where the

00:19:45,200 --> 00:19:49,550
changes that we've done so far so we've

00:19:47,870 --> 00:19:52,370
added a good amount of reusable

00:19:49,550 --> 00:19:56,960
functions that can help to deduce things

00:19:52,370 --> 00:20:00,380
going forward but we have a lot of

00:19:56,960 --> 00:20:04,360
difficulty trying to deal with C style

00:20:00,380 --> 00:20:08,360
arrays if we're really trying to take

00:20:04,360 --> 00:20:10,910
deduction to its extreme I don't want to

00:20:08,360 --> 00:20:14,120
have to get in the habit of defining my

00:20:10,910 --> 00:20:16,100
array sizes so utilities like the

00:20:14,120 --> 00:20:18,290
experimental make array I think are

00:20:16,100 --> 00:20:22,760
going to be pretty useful we can get

00:20:18,290 --> 00:20:24,200
those in the standard as we saw in the

00:20:22,760 --> 00:20:26,180
turn function if you want to just add

00:20:24,200 --> 00:20:28,490
another spell it's as simple as adding

00:20:26,180 --> 00:20:30,410
another parameter to the maker a

00:20:28,490 --> 00:20:32,690
function you don't have to remember to

00:20:30,410 --> 00:20:35,510
update things independently which is a

00:20:32,690 --> 00:20:39,590
nice property it would be very easy to

00:20:35,510 --> 00:20:41,360
go in and add another member function

00:20:39,590 --> 00:20:45,020
that we had earlier and then forget to

00:20:41,360 --> 00:20:46,490
update the array this has the property

00:20:45,020 --> 00:20:51,200
that the spells are no longer visible

00:20:46,490 --> 00:20:54,920
outside of the turn function and they're

00:20:51,200 --> 00:20:57,080
actually even hard to spot individually

00:20:54,920 --> 00:20:59,750
inside the turn function unless you're

00:20:57,080 --> 00:21:08,000
doing something like adding a comment

00:20:59,750 --> 00:21:09,830
before each lambda so as far as the the

00:21:08,000 --> 00:21:13,340
changes that we we saw that we can

00:21:09,830 --> 00:21:17,810
actually measure I counted the total

00:21:13,340 --> 00:21:21,500
number of types that were in the both

00:21:17,810 --> 00:21:23,270
versions before and after we started and

00:21:21,500 --> 00:21:28,640
you can see that the explicit types

00:21:23,270 --> 00:21:30,110
decreased quite a bit the we couldn't

00:21:28,640 --> 00:21:32,960
get rid of all of them because of course

00:21:30,110 --> 00:21:36,380
the member variables that were

00:21:32,960 --> 00:21:42,080
non-static can't use almost always auto

00:21:36,380 --> 00:21:46,850
style and we were able to get most of

00:21:42,080 --> 00:21:49,580
the types different defer to deduce the

00:21:46,850 --> 00:21:53,540
total number of words actually increased

00:21:49,580 --> 00:21:54,890
a fair amount and the total number of

00:21:53,540 --> 00:21:57,800
characters increased

00:21:54,890 --> 00:22:01,130
it's a substantially so after running

00:21:57,800 --> 00:22:03,320
the game for 11 million turns I measured

00:22:01,130 --> 00:22:05,650
that the time actually to do that

00:22:03,320 --> 00:22:08,450
decreased with the almost always auto

00:22:05,650 --> 00:22:12,290
version and that was a little surprising

00:22:08,450 --> 00:22:15,110
but I think that performance improvement

00:22:12,290 --> 00:22:17,870
came largely from the conversion to

00:22:15,110 --> 00:22:20,330
lambdas we no longer had the complexity

00:22:17,870 --> 00:22:25,820
of dealing with the pointer to member

00:22:20,330 --> 00:22:27,140
functions that we had previously so I

00:22:25,820 --> 00:22:31,760
look at something a little bit more

00:22:27,140 --> 00:22:33,350
complicated here so I now have a spell

00:22:31,760 --> 00:22:35,210
that I want to add to the game which is

00:22:33,350 --> 00:22:38,360
going to deal a conditional amount of

00:22:35,210 --> 00:22:42,620
damage based on the current state of the

00:22:38,360 --> 00:22:44,930
player so if you have between 80 and 100

00:22:42,620 --> 00:22:47,120
percent life it's going to deal 25%

00:22:44,930 --> 00:22:51,070
damage going on down to if you're

00:22:47,120 --> 00:22:57,920
between 0 and 20% life we won't actually

00:22:51,070 --> 00:23:01,370
change your life at all and you can see

00:22:57,920 --> 00:23:03,590
here the definition in the non almost

00:23:01,370 --> 00:23:04,820
always out of form pretty much follows

00:23:03,590 --> 00:23:10,190
that pattern that we saw in the previous

00:23:04,820 --> 00:23:13,040
slide and the key here is that I wanted

00:23:10,190 --> 00:23:17,350
to find a way that almost always auto

00:23:13,040 --> 00:23:21,740
could tackle a common practice of say

00:23:17,350 --> 00:23:24,980
defining the value of life conditionally

00:23:21,740 --> 00:23:28,280
I don't want to have to incur the

00:23:24,980 --> 00:23:30,200
overhead of assigning a default value to

00:23:28,280 --> 00:23:32,150
begin with and then changing it later

00:23:30,200 --> 00:23:33,320
now there's other ways that you could

00:23:32,150 --> 00:23:35,990
deal with that

00:23:33,320 --> 00:23:38,090
besides converting to almost always auto

00:23:35,990 --> 00:23:40,970
but if you'll bear with me I just wanted

00:23:38,090 --> 00:23:42,410
to view this as an exercise of how to

00:23:40,970 --> 00:23:44,870
deal with this particular constraint

00:23:42,410 --> 00:23:50,590
there's sometimes reasons why you can't

00:23:44,870 --> 00:23:50,590
simply use a helper function to do that

00:23:50,860 --> 00:23:59,090
so to to kick this off I'm going to use

00:23:55,130 --> 00:24:03,170
a very antic function to evaluate all

00:23:59,090 --> 00:24:06,650
the branches that we had previously the

00:24:03,170 --> 00:24:08,270
very on ik function has three template

00:24:06,650 --> 00:24:11,510
parameters

00:24:08,270 --> 00:24:18,050
if then and else they're all function

00:24:11,510 --> 00:24:23,120
objects else's is a very attic parameter

00:24:18,050 --> 00:24:24,559
pack so I'll evaluate the if if it's if

00:24:23,120 --> 00:24:27,830
the result then it returns is

00:24:24,559 --> 00:24:29,830
convertible to true then I'll return the

00:24:27,830 --> 00:24:34,100
result of calling the then function

00:24:29,830 --> 00:24:40,580
otherwise I'll recursively apply the

00:24:34,100 --> 00:24:43,580
else parameter pack until I run out and

00:24:40,580 --> 00:24:45,230
here's the terminating case and I'm sure

00:24:43,580 --> 00:24:49,150
if STL is in the audience he would

00:24:45,230 --> 00:24:51,530
probably chastise me for using the

00:24:49,150 --> 00:24:53,000
recursive version of this but this was

00:24:51,530 --> 00:24:56,420
on purpose because I want to make sure

00:24:53,000 --> 00:25:00,320
to short-circuit and not evaluate the

00:24:56,420 --> 00:25:02,540
other branches when I don't need to you

00:25:00,320 --> 00:25:07,190
can see an example a trivial one at the

00:25:02,540 --> 00:25:09,500
bottom so if the first lambda

00:25:07,190 --> 00:25:12,080
there's pairs of Lando's there and the

00:25:09,500 --> 00:25:15,610
first one is the condition the second

00:25:12,080 --> 00:25:19,190
one is the result that we'll use if that

00:25:15,610 --> 00:25:21,800
conditional land ever returns true so in

00:25:19,190 --> 00:25:24,320
this example you can see that the

00:25:21,800 --> 00:25:27,110
results because the first conditional

00:25:24,320 --> 00:25:29,210
lambda returns false and the second one

00:25:27,110 --> 00:25:39,370
one returns true is not the result is a

00:25:29,210 --> 00:25:43,460
double of 1.0 and here we've applied

00:25:39,370 --> 00:25:45,770
that same logic to the branches that we

00:25:43,460 --> 00:25:48,380
had previously and this has a nice

00:25:45,770 --> 00:25:50,510
property that even though it doesn't

00:25:48,380 --> 00:25:55,610
look like a traditional series of

00:25:50,510 --> 00:25:57,860
if-then else's change is only ever

00:25:55,610 --> 00:26:06,800
assigned a value once we know which

00:25:57,860 --> 00:26:10,160
branch we're going to take so choose I

00:26:06,800 --> 00:26:15,170
feel like it's kind of like four

00:26:10,160 --> 00:26:19,970
branches what 4-h is for raw loops it

00:26:15,170 --> 00:26:21,760
expects a regular pattern and we'll try

00:26:19,970 --> 00:26:25,090
to help enforce that for

00:26:21,760 --> 00:26:27,730
each branch that you take on the

00:26:25,090 --> 00:26:30,460
downside just like with 4-h the the raw

00:26:27,730 --> 00:26:33,910
behavior is kind of hidden behind the

00:26:30,460 --> 00:26:36,370
template function and you can have

00:26:33,910 --> 00:26:38,380
errors due to mismatch arguments that

00:26:36,370 --> 00:26:40,810
could be hard to diagnose if you don't

00:26:38,380 --> 00:26:43,500
have a good amount of static asserts or

00:26:40,810 --> 00:26:47,200
or potentially concepts to help you

00:26:43,500 --> 00:26:50,740
the initial version that I had was using

00:26:47,200 --> 00:26:54,100
a stood pair of the condition and result

00:26:50,740 --> 00:26:55,690
function objects which is gonna be a

00:26:54,100 --> 00:26:58,630
little bit safer but it was a lot more

00:26:55,690 --> 00:27:00,790
verbose of the call site so I opted in

00:26:58,630 --> 00:27:04,450
for the version that fit on the slide a

00:27:00,790 --> 00:27:06,190
little bit better and then finally as I

00:27:04,450 --> 00:27:07,600
mentioned earlier you could if you don't

00:27:06,190 --> 00:27:10,630
want to use something like chews you

00:27:07,600 --> 00:27:13,120
could use lambda as an immediately

00:27:10,630 --> 00:27:16,150
invoked function expression or just

00:27:13,120 --> 00:27:20,040
another helper function to kind of do

00:27:16,150 --> 00:27:20,040
that branched evaluation as you see fit

00:27:20,550 --> 00:27:29,950
and the the overall impacts on our code

00:27:26,830 --> 00:27:34,360
base was that we now decrease the

00:27:29,950 --> 00:27:35,470
explicit types to zero and the number of

00:27:34,360 --> 00:27:38,010
deduce types actually went up

00:27:35,470 --> 00:27:41,830
substantially a lot more than we had

00:27:38,010 --> 00:27:45,900
explicit types originally and the reason

00:27:41,830 --> 00:27:48,340
for that is that we have a number of

00:27:45,900 --> 00:27:49,810
types that are kind of hidden due to all

00:27:48,340 --> 00:27:52,900
the lambdas that are being used the

00:27:49,810 --> 00:27:56,440
lambda type itself and then the deduced

00:27:52,900 --> 00:27:58,750
return type for the lambda the total

00:27:56,440 --> 00:28:02,470
number of words increased a good amount

00:27:58,750 --> 00:28:04,960
from 81 and 97 a ton of our characters

00:28:02,470 --> 00:28:06,670
increased a good amount to you but the

00:28:04,960 --> 00:28:09,990
really surprising thing to me ms that

00:28:06,670 --> 00:28:13,420
the performance was identical and that

00:28:09,990 --> 00:28:18,100
was because the optimizer did an amazing

00:28:13,420 --> 00:28:19,660
job of taking both of those forms and

00:28:18,100 --> 00:28:26,290
recognizing that they're doing the same

00:28:19,660 --> 00:28:29,020
exact thing okay so most of our games

00:28:26,290 --> 00:28:31,750
have multiplayer so I thought why not

00:28:29,020 --> 00:28:35,410
finish off by adding multiplayer support

00:28:31,750 --> 00:28:40,240
to the game to see the impact that all

00:28:35,410 --> 00:28:41,860
always otto has with loops so we'll

00:28:40,240 --> 00:28:45,880
change the current amount of life that

00:28:41,860 --> 00:28:48,250
we have to an array in each turn we'll

00:28:45,880 --> 00:28:50,860
iterate over the array and we'll skip

00:28:48,250 --> 00:28:54,190
any element if the life is already zero

00:28:50,860 --> 00:28:59,080
if they're dead then we'll end when all

00:28:54,190 --> 00:29:00,910
life values are zero so here's the

00:28:59,080 --> 00:29:03,940
changes that I made to the none almost

00:29:00,910 --> 00:29:06,490
always auto version I had to omit some

00:29:03,940 --> 00:29:09,460
other stuff that didn't change just for

00:29:06,490 --> 00:29:14,200
space here but at the top you can see we

00:29:09,460 --> 00:29:17,830
have a stint array of size three for one

00:29:14,200 --> 00:29:21,100
for each of our players of life and then

00:29:17,830 --> 00:29:25,120
I've had to update and add a constructor

00:29:21,100 --> 00:29:28,540
here that fills in each of the values

00:29:25,120 --> 00:29:30,760
with the maximum amount of life that's

00:29:28,540 --> 00:29:34,960
because the only other alternative is to

00:29:30,760 --> 00:29:36,790
add braced initialize or a default

00:29:34,960 --> 00:29:41,470
member initializer afterwards that has

00:29:36,790 --> 00:29:44,620
one element for each of the three life

00:29:41,470 --> 00:29:46,420
values and that's not really very easy

00:29:44,620 --> 00:29:50,050
to maintain so I kind of prefer using

00:29:46,420 --> 00:29:53,170
fill in this circumstance and then

00:29:50,050 --> 00:29:55,810
finally I updated the body of turn this

00:29:53,170 --> 00:29:59,950
isn't the complete code but I updated it

00:29:55,810 --> 00:30:02,350
to loop over the values in the array and

00:29:59,950 --> 00:30:05,020
apply the logic that we saw earlier and

00:30:02,350 --> 00:30:07,450
the spell here it's not defined but it's

00:30:05,020 --> 00:30:15,000
basically just a shortcut for picking

00:30:07,450 --> 00:30:18,730
the random spell and then calling it so

00:30:15,000 --> 00:30:22,530
now if you followed shown parents C++

00:30:18,730 --> 00:30:27,580
seasoning talk it's amazing talk he

00:30:22,530 --> 00:30:32,880
recommends using stead for each to try

00:30:27,580 --> 00:30:36,160
to avoid raw loops and I've done it here

00:30:32,880 --> 00:30:39,490
but because state for each doesn't

00:30:36,160 --> 00:30:43,480
really allow any output it's really just

00:30:39,490 --> 00:30:47,190
geared towards modifying your your array

00:30:43,480 --> 00:30:49,700
I found to capture I haven't define a

00:30:47,190 --> 00:30:53,880
the any alive

00:30:49,700 --> 00:30:57,180
outside of the 4-h call so that it can

00:30:53,880 --> 00:30:59,490
persist after the call is done and then

00:30:57,180 --> 00:31:03,210
I capture it and update it with the

00:30:59,490 --> 00:31:05,850
Landa so this is pretty good but it does

00:31:03,210 --> 00:31:09,150
have the downside that we've had to do

00:31:05,850 --> 00:31:11,850
that association with explicit

00:31:09,150 --> 00:31:13,800
association with a pool which isn't

00:31:11,850 --> 00:31:16,800
great if we want to update the logic

00:31:13,800 --> 00:31:24,240
that happens inside of the lambda as we

00:31:16,800 --> 00:31:25,710
iterate over each element so I looked at

00:31:24,240 --> 00:31:29,940
the standard algorithms and none of them

00:31:25,710 --> 00:31:32,550
really helped me out here so what I did

00:31:29,940 --> 00:31:35,910
was I kind of smashed the idea of

00:31:32,550 --> 00:31:41,550
student community and transform reduce

00:31:35,910 --> 00:31:43,050
into this kind of monstrosity and I've

00:31:41,550 --> 00:31:46,850
rearranged the order of the parameters a

00:31:43,050 --> 00:31:51,720
little bit simply to try to help

00:31:46,850 --> 00:31:54,770
actually deduce the type of T and that's

00:31:51,720 --> 00:32:01,790
helpful in this case because I have a

00:31:54,770 --> 00:32:06,330
value that I can figure out entirely by

00:32:01,790 --> 00:32:12,720
looking at the signature of the unary

00:32:06,330 --> 00:32:14,580
option and deducing that by providing it

00:32:12,720 --> 00:32:17,520
with the input iterator and

00:32:14,580 --> 00:32:20,940
dereferencing on so it'll produce the T

00:32:17,520 --> 00:32:22,170
type that I'm interested in so even

00:32:20,940 --> 00:32:24,360
though it's a little bit different from

00:32:22,170 --> 00:32:28,430
the order that parameters appear instead

00:32:24,360 --> 00:32:31,170
accumulate ørsted transform reduce I

00:32:28,430 --> 00:32:34,770
like that you can define it in this way

00:32:31,170 --> 00:32:39,390
and have that extra initial parameter

00:32:34,770 --> 00:32:41,730
kind of default initialized so we'll

00:32:39,390 --> 00:32:44,190
take the first and last elements in the

00:32:41,730 --> 00:32:47,460
range the unary operators going to be

00:32:44,190 --> 00:32:49,830
our transform and the binary op is going

00:32:47,460 --> 00:32:52,520
to be our reduction and then just simply

00:32:49,830 --> 00:32:54,840
iterate over the range and apply them

00:32:52,520 --> 00:33:02,100
and then return the result when we're

00:32:54,840 --> 00:33:02,730
done here it is applied to our turn

00:33:02,100 --> 00:33:06,870
function

00:33:02,730 --> 00:33:10,110
it's a lot more code now we have the

00:33:06,870 --> 00:33:13,140
begin and end of the life range as the

00:33:10,110 --> 00:33:15,990
begin and end parameters then we have

00:33:13,140 --> 00:33:19,260
the lambda that's going to be our

00:33:15,990 --> 00:33:22,500
transform function it's responsible just

00:33:19,260 --> 00:33:24,060
for checking to see if the life is the

00:33:22,500 --> 00:33:27,720
current life value that it's iterating

00:33:24,060 --> 00:33:31,260
over happens to be greater than 0 and if

00:33:27,720 --> 00:33:35,940
it is then we'll call the spell function

00:33:31,260 --> 00:33:38,660
and finally return whether or not the

00:33:35,940 --> 00:33:42,020
that particular player is still alive

00:33:38,660 --> 00:33:46,140
and then at the bottom we have our

00:33:42,020 --> 00:33:48,870
transparent lambda which will take the

00:33:46,140 --> 00:33:51,660
value that we've been accumulating over

00:33:48,870 --> 00:33:55,140
time and the latest result that we just

00:33:51,660 --> 00:33:57,330
calculated and reduce them together and

00:33:55,140 --> 00:33:59,490
it knows I didn't have to specify the

00:33:57,330 --> 00:34:02,220
initial value here it can completely

00:33:59,490 --> 00:34:06,660
deduce that because of the type of the

00:34:02,220 --> 00:34:13,950
transform land up above so that would

00:34:06,660 --> 00:34:17,070
start it off at false so overall I felt

00:34:13,950 --> 00:34:19,320
like if you're trying to avoid raw loops

00:34:17,070 --> 00:34:23,370
and you're trying to use almost always

00:34:19,320 --> 00:34:25,050
out of style that's going to require a

00:34:23,370 --> 00:34:27,120
bunch of additional work to try to

00:34:25,050 --> 00:34:31,050
understand how to make that function

00:34:27,120 --> 00:34:34,710
properly most standard algorithms don't

00:34:31,050 --> 00:34:38,940
really want you to try to mutate the

00:34:34,710 --> 00:34:44,610
contents of the range some don't even

00:34:38,940 --> 00:34:46,250
let you invalidate iterators it would

00:34:44,610 --> 00:34:49,710
have been nice to use a function like

00:34:46,250 --> 00:34:51,750
said any of here but unfortunately that

00:34:49,710 --> 00:34:54,060
wouldn't work because it exposed

00:34:51,750 --> 00:34:59,820
explicitly says that the range shouldn't

00:34:54,060 --> 00:35:02,070
be modified so a key mutate unlike state

00:34:59,820 --> 00:35:05,610
transform reduce can figure out the type

00:35:02,070 --> 00:35:08,460
of the T parameter and default it so I

00:35:05,610 --> 00:35:11,490
think this just kind of highlighted that

00:35:08,460 --> 00:35:14,800
if you're developing a generic algorithm

00:35:11,490 --> 00:35:16,150
that the parameter order is important

00:35:14,800 --> 00:35:18,819
and that if you're trying to use

00:35:16,150 --> 00:35:23,589
standard algorithms that you have to be

00:35:18,819 --> 00:35:29,470
very cautious of any potential narrow

00:35:23,589 --> 00:35:30,760
contracts that they might have and it

00:35:29,470 --> 00:35:33,490
finally just kind of taking a look at

00:35:30,760 --> 00:35:36,940
the overall impact that the looping

00:35:33,490 --> 00:35:39,640
changes had we were able to eliminate

00:35:36,940 --> 00:35:42,280
almost all of the explicit types that we

00:35:39,640 --> 00:35:45,540
had the only ones that we couldn't get

00:35:42,280 --> 00:35:49,349
rid of our non-static member variables

00:35:45,540 --> 00:35:52,839
the total number of deduce types is

00:35:49,349 --> 00:35:55,020
actually larger than the total number of

00:35:52,839 --> 00:35:59,200
explicit types that we started out with

00:35:55,020 --> 00:36:03,280
because in the additional land is the

00:35:59,200 --> 00:36:06,550
total amount of words and characters

00:36:03,280 --> 00:36:09,780
both increased substantially due to all

00:36:06,550 --> 00:36:11,859
the extra land is that we had to use and

00:36:09,780 --> 00:36:15,220
this is a little surprising the

00:36:11,859 --> 00:36:19,180
performance is slightly slower with

00:36:15,220 --> 00:36:21,069
almost always auto version the optimized

00:36:19,180 --> 00:36:22,000
assembly is pretty close but not

00:36:21,069 --> 00:36:24,400
identical

00:36:22,000 --> 00:36:27,130
I think the there were probably one too

00:36:24,400 --> 00:36:32,800
many layers of lambdas for it to kind of

00:36:27,130 --> 00:36:38,740
chip all of them away so here is kind of

00:36:32,800 --> 00:36:40,960
my overall takeaway after going through

00:36:38,740 --> 00:36:44,230
all these examples and trying to see the

00:36:40,960 --> 00:36:45,930
impact that they had I'm not going to

00:36:44,230 --> 00:36:49,359
read through all of them but I think

00:36:45,930 --> 00:36:52,839
these kinds of properties are important

00:36:49,359 --> 00:36:55,260
for you guys to consider when figuring

00:36:52,839 --> 00:36:57,970
out if almost always a lot of style is

00:36:55,260 --> 00:37:02,829
it's the right thing or not for your

00:36:57,970 --> 00:37:04,540
code base and since I think we're

00:37:02,829 --> 00:37:09,160
running a little bit early on time I

00:37:04,540 --> 00:37:12,819
have a couple of bonus slides after this

00:37:09,160 --> 00:37:15,880
but I sorry for the formatting mess up

00:37:12,819 --> 00:37:18,339
there but if you want to take one thing

00:37:15,880 --> 00:37:22,000
away from this talk it's that more

00:37:18,339 --> 00:37:24,970
typing for Less typing if you use almost

00:37:22,000 --> 00:37:28,779
always auto that was kind of something

00:37:24,970 --> 00:37:35,119
that my co-workers and I joked about so

00:37:28,779 --> 00:37:37,220
just keep that in mind and forget the

00:37:35,119 --> 00:37:38,779
bonus slides I'm to thank bunch of my

00:37:37,220 --> 00:37:41,390
colleagues for providing some great

00:37:38,779 --> 00:37:44,660
feedback on on this and there's a link

00:37:41,390 --> 00:37:49,220
to the github repo that has all the code

00:37:44,660 --> 00:37:52,460
that I developed I'll take questions

00:37:49,220 --> 00:37:55,509
first thing we have time I can go over

00:37:52,460 --> 00:37:55,509
the bonus slides

00:38:11,950 --> 00:38:21,440
questions how many people use almost

00:38:15,619 --> 00:38:22,970
always auto ok how many of you feel who

00:38:21,440 --> 00:38:27,740
were kind of on the fence feel like

00:38:22,970 --> 00:38:31,670
you're more interested now ok how many

00:38:27,740 --> 00:38:34,700
are less interested all right fair

00:38:31,670 --> 00:38:36,770
enough thanks for your honesty go ahead

00:38:34,700 --> 00:38:39,490
could you expand on your reasons for

00:38:36,770 --> 00:38:43,550
using Auto ref ref for local variables

00:38:39,490 --> 00:38:47,570
just Auto ball yeah the main reason for

00:38:43,550 --> 00:38:52,220
that is to work with types that are not

00:38:47,570 --> 00:38:55,150
movable or not copyable so it works

00:38:52,220 --> 00:38:58,280
nicely with unique put our shared footer

00:38:55,150 --> 00:39:00,860
proxy types as well like if you're if

00:38:58,280 --> 00:39:03,890
you're trying to iterate over a vector

00:39:00,860 --> 00:39:06,470
bulls or a bit set you don't have to

00:39:03,890 --> 00:39:08,990
deal with any problems of not being able

00:39:06,470 --> 00:39:17,119
to do that correctly it just kind of

00:39:08,990 --> 00:39:23,869
works inversely which is nice any other

00:39:17,119 --> 00:39:26,420
questions so this seemed to have a lot

00:39:23,869 --> 00:39:28,640
of boilerplate due to the lambdas and

00:39:26,420 --> 00:39:31,580
trying to put everything into stuff that

00:39:28,640 --> 00:39:34,070
looked like standard functions yeah so

00:39:31,580 --> 00:39:35,390
my question is how much of that

00:39:34,070 --> 00:39:39,109
boilerplate do you think would have gone

00:39:35,390 --> 00:39:42,140
away if you'd been I guess less extreme

00:39:39,109 --> 00:39:44,780
about the always almost auto and used

00:39:42,140 --> 00:39:48,500
auto everywhere that it was say you know

00:39:44,780 --> 00:39:51,020
easy or not writing a bunch of

00:39:48,500 --> 00:39:52,220
boilerplate and how much fun effect

00:39:51,020 --> 00:39:56,150
would that have had on the code base

00:39:52,220 --> 00:39:56,840
over trying to force it as far as

00:39:56,150 --> 00:39:59,030
possible

00:39:56,840 --> 00:40:01,400
right which you know may be why it's

00:39:59,030 --> 00:40:02,000
scaring people off this talking that

00:40:01,400 --> 00:40:03,859
kind of stuff

00:40:02,000 --> 00:40:05,810
yeah I mean my intent and going this far

00:40:03,859 --> 00:40:09,290
was to see what it looked like when you

00:40:05,810 --> 00:40:10,940
do apply it to this extent I don't think

00:40:09,290 --> 00:40:12,290
anybody is necessarily advocating that

00:40:10,940 --> 00:40:16,450
you go that far

00:40:12,290 --> 00:40:20,350
but I wanted to see what it looked like

00:40:16,450 --> 00:40:23,410
and it was interesting that as I

00:40:20,350 --> 00:40:27,440
continued to try to push things I felt

00:40:23,410 --> 00:40:30,440
more and more like leaning towards

00:40:27,440 --> 00:40:33,290
generic algorithms was helpful or trying

00:40:30,440 --> 00:40:36,710
to develop additional ones that was the

00:40:33,290 --> 00:40:38,510
surprising result I wasn't really

00:40:36,710 --> 00:40:41,810
expecting that that I would develop a

00:40:38,510 --> 00:40:44,210
bunch of helper functions outside of the

00:40:41,810 --> 00:40:46,850
scope of the talk necessarily I wasn't

00:40:44,210 --> 00:40:49,100
even trying to do most of those to show

00:40:46,850 --> 00:40:56,540
as examples but they ended up being

00:40:49,100 --> 00:41:00,530
useful so go ahead do you really write

00:40:56,540 --> 00:41:06,380
quote like this in production no this is

00:41:00,530 --> 00:41:10,070
this is admittedly a toy example I think

00:41:06,380 --> 00:41:13,250
we're on my team we're starting to look

00:41:10,070 --> 00:41:15,950
at how to practically apply almost

00:41:13,250 --> 00:41:19,130
always auto whether or not to even do it

00:41:15,950 --> 00:41:21,530
this was an exercise to try to help me

00:41:19,130 --> 00:41:24,080
understand the impact I've shared it

00:41:21,530 --> 00:41:27,320
with folks on my team so I think it they

00:41:24,080 --> 00:41:31,160
can feel more comfortable with the idea

00:41:27,320 --> 00:41:32,090
of even trying to do this before it

00:41:31,160 --> 00:41:33,800
really did

00:41:32,090 --> 00:41:36,320
I went through this exercise I think a

00:41:33,800 --> 00:41:38,690
lot of people were very understandably

00:41:36,320 --> 00:41:42,050
apprehensive about the potential impact

00:41:38,690 --> 00:41:47,720
that it could have on readability versus

00:41:42,050 --> 00:41:50,810
flexibility so I think you know I went

00:41:47,720 --> 00:41:53,570
very far along the scale probably

00:41:50,810 --> 00:41:58,270
farther than herb would want me to go by

00:41:53,570 --> 00:41:58,270
it it was an interesting exercise

00:41:59,530 --> 00:42:04,760
perhaps the last question has made this

00:42:02,570 --> 00:42:08,240
bit moot but how do you overall feel

00:42:04,760 --> 00:42:10,010
that this has affected the readability

00:42:08,240 --> 00:42:13,480
maintainability of your code and the

00:42:10,010 --> 00:42:13,480
productivity of working on it

00:42:13,580 --> 00:42:21,110
I think I've seen cases I mean aside

00:42:18,890 --> 00:42:24,700
from this toy example I've seen cases

00:42:21,110 --> 00:42:30,700
where it actually has helped quite a bit

00:42:24,700 --> 00:42:33,099
as we have a lot of cases where we're

00:42:30,700 --> 00:42:36,190
trying to convert from say our own

00:42:33,099 --> 00:42:39,700
custom containers to something like

00:42:36,190 --> 00:42:42,060
standard library containers and by

00:42:39,700 --> 00:42:46,990
trying to leverage almost always Auto

00:42:42,060 --> 00:42:49,540
more and more we don't have to worry

00:42:46,990 --> 00:42:52,720
about updating so many places at least

00:42:49,540 --> 00:42:55,270
in terms of the the simple st. tactical

00:42:52,720 --> 00:42:57,130
change to convert from one named type to

00:42:55,270 --> 00:42:58,960
another obviously you stopped I'm

00:42:57,130 --> 00:43:02,440
worried that the interface is compatible

00:42:58,960 --> 00:43:04,869
but if you tackle your conversion

00:43:02,440 --> 00:43:10,900
project and good phases I think you can

00:43:04,869 --> 00:43:12,730
do that good well I think the recurring

00:43:10,900 --> 00:43:15,430
theme that I observed in your talk it's

00:43:12,730 --> 00:43:17,770
it's more cold you know every step it's

00:43:15,430 --> 00:43:19,450
more code yeah and I think everyone will

00:43:17,770 --> 00:43:22,750
agree that it's a lot less

00:43:19,450 --> 00:43:29,140
comprehensible then so I would like to

00:43:22,750 --> 00:43:30,310
coin the term almost never Auto doesn't

00:43:29,140 --> 00:43:34,000
doesn't quite roll off the tongue as

00:43:30,310 --> 00:43:36,099
easy as almost always but I I can

00:43:34,000 --> 00:43:38,980
appreciate where you're coming from I

00:43:36,099 --> 00:43:41,440
think the complexity of some of the

00:43:38,980 --> 00:43:43,859
tricks that I've pulled here is probably

00:43:41,440 --> 00:43:45,130
beyond what most people would recommend

00:43:43,859 --> 00:43:51,369
go ahead

00:43:45,130 --> 00:43:52,599
could you go back to slide 27 sure so

00:43:51,369 --> 00:43:54,670
you have a comment that says that the

00:43:52,599 --> 00:43:57,550
return of the lambda is a double but

00:43:54,670 --> 00:43:59,200
could it also be a float and if it could

00:43:57,550 --> 00:44:01,960
and at that point is it possible that

00:43:59,200 --> 00:44:06,099
other types could be incorrectly deduced

00:44:01,960 --> 00:44:07,599
and how would that affect I'm not sure

00:44:06,099 --> 00:44:12,540
how it could be a float in this case

00:44:07,599 --> 00:44:15,099
it's the common type of both the first

00:44:12,540 --> 00:44:18,630
result which is returning an integer and

00:44:15,099 --> 00:44:23,230
the double which is the second result

00:44:18,630 --> 00:44:27,880
maybe I misunderstood your question no I

00:44:23,230 --> 00:44:30,040
think that was it okay I wanted to

00:44:27,880 --> 00:44:33,970
mention a case where you didn't go far

00:44:30,040 --> 00:44:35,410
enough I thought oh this one's good but

00:44:33,970 --> 00:44:38,350
actually 34 I think is maybe a little

00:44:35,410 --> 00:44:42,190
more compelling yeah

00:44:38,350 --> 00:44:44,410
yes so here you actually have explicit

00:44:42,190 --> 00:44:46,480
typing even though it looks like

00:44:44,410 --> 00:44:49,180
everything is deduced and it's hiding in

00:44:46,480 --> 00:44:52,090
the deckle type this I mean previously

00:44:49,180 --> 00:44:54,880
was also hiding in the result of and the

00:44:52,090 --> 00:44:56,380
mistake here in highly generic code

00:44:54,880 --> 00:44:57,610
which I would worry about in the

00:44:56,380 --> 00:44:59,440
standard library although it would

00:44:57,610 --> 00:45:01,600
probably never occur in application

00:44:59,440 --> 00:45:04,740
production is you have asked the

00:45:01,600 --> 00:45:09,790
question what would happen if I invoked

00:45:04,740 --> 00:45:11,860
Yuna or you up on D referencing the

00:45:09,790 --> 00:45:15,430
iterator and the value category matters

00:45:11,860 --> 00:45:18,850
your actual invocation uses you up as an

00:45:15,430 --> 00:45:21,370
l-value always but if you've been given

00:45:18,850 --> 00:45:22,870
an hour value the deckle type is asking

00:45:21,370 --> 00:45:24,700
what if I invoke this thing as an

00:45:22,870 --> 00:45:26,620
r-value and those can now give different

00:45:24,700 --> 00:45:29,590
answers with rough qualifiers yep so a

00:45:26,620 --> 00:45:32,020
sufficiently motivated attacker in some

00:45:29,590 --> 00:45:35,050
sense can force you to deduce the types

00:45:32,020 --> 00:45:37,240
incorrectly because the T asked the

00:45:35,050 --> 00:45:38,620
question not with Auto but with deck

00:45:37,240 --> 00:45:40,120
eval forming it through different paths

00:45:38,620 --> 00:45:41,980
so here you didn't go far enough with

00:45:40,120 --> 00:45:47,890
Auto thank you for pointing that as

00:45:41,980 --> 00:45:55,750
versatile yep any other questions I can

00:45:47,890 --> 00:45:58,540
show you some bonus lines so one thing I

00:45:55,750 --> 00:46:06,240
I ran into while trying to develop this

00:45:58,540 --> 00:46:10,210
talk was difficulty with trying to pass

00:46:06,240 --> 00:46:13,180
templated functions through two standard

00:46:10,210 --> 00:46:15,550
functions like in this case if I want to

00:46:13,180 --> 00:46:18,010
calculate the maximum value in a range

00:46:15,550 --> 00:46:22,120
you could use stood max element to do

00:46:18,010 --> 00:46:24,160
this but I wanted to find a way to deal

00:46:22,120 --> 00:46:27,700
with the fact that if I were to try to

00:46:24,160 --> 00:46:31,480
pass stead max trying to explicitly

00:46:27,700 --> 00:46:33,430
qualify it is ambiguous so I didn't

00:46:31,480 --> 00:46:35,980
really have a way of trying to deal with

00:46:33,430 --> 00:46:41,050
this in a case where I wanted to deduce

00:46:35,980 --> 00:46:45,820
as much as possible so I realized that I

00:46:41,050 --> 00:46:49,540
could use a very annek generic lambda to

00:46:45,820 --> 00:46:50,910
actually capture the function that I'm

00:46:49,540 --> 00:46:54,210
interested in in

00:46:50,910 --> 00:46:56,460
using and use argument to dependent look

00:46:54,210 --> 00:46:59,640
up inside the lambda to actually forward

00:46:56,460 --> 00:47:03,980
it through transparently so this way

00:46:59,640 --> 00:47:06,650
whenever I pass in two stood accumulate

00:47:03,980 --> 00:47:10,430
it will be passed through directly to

00:47:06,650 --> 00:47:13,170
the periodic lambda that I have here and

00:47:10,430 --> 00:47:16,279
I don't have to worry about trying to

00:47:13,170 --> 00:47:19,380
qualify max with an explicit type so I

00:47:16,279 --> 00:47:21,809
found this to be useful it's a lot more

00:47:19,380 --> 00:47:24,569
typing than using stood max element

00:47:21,809 --> 00:47:29,509
obviously in this case but I think it

00:47:24,569 --> 00:47:29,509
might be useful beyond beyond that so

00:47:30,259 --> 00:47:34,650
there's no more questions thank you all

00:47:32,880 --> 00:47:36,660
for your attention and for not rushing

00:47:34,650 --> 00:47:38,809
the stage to attack me with torches and

00:47:36,660 --> 00:47:38,809

YouTube URL: https://www.youtube.com/watch?v=ZCGyvPDM0YY


