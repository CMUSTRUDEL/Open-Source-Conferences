Title: CppCon 2015: Phil Nash “Test Driven C++ with Catch”
Publication date: 2015-10-13
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
C++ has been notorious for being a second class citizen when it comes to test frameworks. There are plenty of them but they tend to be fiddly to set-up and ceremonious to use. Many of them attempt to follow the xUnit template without respect for the language environment they are written for. Catch is an attempt to cut through all of that. It is simple to get and simple to use - being distributed in a single header file - yet is powerful and flexible. Catch includes a number of innovations that make testing in C++ more natural - and fun - than ever before. This presentation introduces you to the unique approach that Catch brings to unit and integration testing - and how to use Catch to drive your design with TDD or BDD.
— 
Phil Nash:  Long time C++ developer but also dabbles with F#, Objective-C, Swift, C#, Python, D, Rust and others. | Open source author and contributor - particularly Catch - a C++ test framework in a single header file. | Interested in all forms of bettering oneself!
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,840
good morning everyone thanks for coming

00:00:01,949 --> 00:00:08,010
along good to see quite a few people

00:00:03,840 --> 00:00:10,380
interested in just driven C++ especially

00:00:08,010 --> 00:00:15,230
with STL giving her another talk in

00:00:10,380 --> 00:00:17,070
another room so thanks for coming so

00:00:15,230 --> 00:00:17,640
quick show of hands before we get

00:00:17,070 --> 00:00:21,720
started

00:00:17,640 --> 00:00:24,689
who's done some form of TDD before in

00:00:21,720 --> 00:00:28,230
any language not just C++ so a fair few

00:00:24,689 --> 00:00:30,750
but quite a few haven't who's sort of

00:00:28,230 --> 00:00:35,010
reasonably familiar with what TDD is at

00:00:30,750 --> 00:00:37,079
least so quite a few people only knew

00:00:35,010 --> 00:00:41,820
two TDD it's not going to be a deep dive

00:00:37,079 --> 00:00:45,989
on CDD I will explain a bit about it so

00:00:41,820 --> 00:00:47,789
to recap what it means and we'll sort of

00:00:45,989 --> 00:00:49,739
bare some other out in the demos so

00:00:47,789 --> 00:00:53,879
hopefully you'll still get plenty out of

00:00:49,739 --> 00:00:56,820
that but also the other part of this is

00:00:53,879 --> 00:01:00,809
it's we have catch so catch is a test

00:00:56,820 --> 00:01:02,520
framework originally written by me many

00:01:00,809 --> 00:01:05,600
contributions now over the years rubbers

00:01:02,520 --> 00:01:07,530
so it's more of a community thing and

00:01:05,600 --> 00:01:10,140
they're going to look at some of the

00:01:07,530 --> 00:01:15,150
ways that catch I feel at least is

00:01:10,140 --> 00:01:16,320
particularly good for doing TDD but what

00:01:15,150 --> 00:01:18,409
we get onto that I want to concentrate

00:01:16,320 --> 00:01:30,329
more on that first part the test-driven

00:01:18,409 --> 00:01:31,799
C++ so so I'll have my um click in some

00:01:30,329 --> 00:01:34,020
somehow I managed to leave it at home I

00:01:31,799 --> 00:01:36,450
completely failed to connect my Apple

00:01:34,020 --> 00:01:38,189
watch to use it as a remote so I'll have

00:01:36,450 --> 00:01:40,700
to have to do it from here so

00:01:38,189 --> 00:01:44,850
test-driven C++ what's he talking about

00:01:40,700 --> 00:01:48,689
TDD she usually expand to test-driven

00:01:44,850 --> 00:01:52,049
development but some people like to

00:01:48,689 --> 00:01:54,630
expand it to test-driven design and

00:01:52,049 --> 00:01:57,540
that's quite nice because it puts the

00:01:54,630 --> 00:01:58,770
emphasis on on their word design and I

00:01:57,540 --> 00:02:00,240
think that's really the sort of one of

00:01:58,770 --> 00:02:03,659
the most valuable parts that comes out

00:02:00,240 --> 00:02:06,210
of TDD a portion utley that's not the

00:02:03,659 --> 00:02:07,619
word that most people focus on most

00:02:06,210 --> 00:02:10,020
people just seem to get stuck on that

00:02:07,619 --> 00:02:12,209
first word test and that's a bit

00:02:10,020 --> 00:02:13,620
unfortunate because there has a lot of

00:02:12,209 --> 00:02:16,379
connotations a lot of baggage

00:02:13,620 --> 00:02:18,269
comes along with that word and people to

00:02:16,379 --> 00:02:22,110
get a reaction when they talk about

00:02:18,269 --> 00:02:25,049
tests that's not really what TDD is all

00:02:22,110 --> 00:02:26,580
about some people will say that the

00:02:25,049 --> 00:02:31,019
tests are not even the most important

00:02:26,580 --> 00:02:33,420
part of TDD you may argue with them but

00:02:31,019 --> 00:02:36,829
I think the most important word here is

00:02:33,420 --> 00:02:39,329
actually the middle one driven

00:02:36,829 --> 00:02:42,510
test-driven development or test-driven

00:02:39,329 --> 00:02:46,590
design what it actually mean to drive

00:02:42,510 --> 00:02:49,859
your design from tests to answer that

00:02:46,590 --> 00:02:52,049
question and we also need to look at

00:02:49,859 --> 00:02:54,120
what we actually mean by tests let's say

00:02:52,049 --> 00:02:55,379
a lot of people have a reaction where

00:02:54,120 --> 00:02:58,290
they hear that word I think it's worth

00:02:55,379 --> 00:03:01,409
clarifying that and to answer that we

00:02:58,290 --> 00:03:03,180
need to ask another question very broad

00:03:01,409 --> 00:03:06,840
question why do we actually write code

00:03:03,180 --> 00:03:09,989
in the first place why do we do it

00:03:06,840 --> 00:03:13,500
there's always a reason here's a few

00:03:09,989 --> 00:03:16,170
possibilities maybe we want to deliver

00:03:13,500 --> 00:03:20,609
stakeholder value because that guess is

00:03:16,170 --> 00:03:24,389
our bed in the morning practice to to

00:03:20,609 --> 00:03:28,139
meet a business need yeah sounds sounds

00:03:24,389 --> 00:03:30,419
important maybe because it's we were

00:03:28,139 --> 00:03:31,680
just told to do it so job we write code

00:03:30,419 --> 00:03:35,370
someone told us to write this code we

00:03:31,680 --> 00:03:38,819
write it I don't really care why all of

00:03:35,370 --> 00:03:41,099
these things may be true but as I said

00:03:38,819 --> 00:03:43,169
they're not particularly motivating it's

00:03:41,099 --> 00:03:47,579
not really what we connect to as

00:03:43,169 --> 00:03:50,690
programmers how about this one we write

00:03:47,579 --> 00:03:52,709
code to solve a particular problem

00:03:50,690 --> 00:03:55,139
now that's something we can connect to

00:03:52,709 --> 00:03:58,079
we're problem solvers that's what we do

00:03:55,139 --> 00:04:00,030
we solve problems now that problem may

00:03:58,079 --> 00:04:01,620
deliver stakeholders early it may meet a

00:04:00,030 --> 00:04:04,919
business need it maybe what we're asked

00:04:01,620 --> 00:04:07,829
to do but we can connect to the problem

00:04:04,919 --> 00:04:11,060
solving pal so we're getting somewhere a

00:04:07,829 --> 00:04:13,349
couple more questions we need to ask how

00:04:11,060 --> 00:04:15,540
to solve a particular problem we need to

00:04:13,349 --> 00:04:19,650
ask what the problem is that we're

00:04:15,540 --> 00:04:22,660
trying to solve another question is how

00:04:19,650 --> 00:04:25,750
do we know when we've solved it

00:04:22,660 --> 00:04:27,280
seem like simple fundamental questions

00:04:25,750 --> 00:04:29,080
so trivial will we miss them we won't

00:04:27,280 --> 00:04:31,120
ask the questions and that's a shame

00:04:29,080 --> 00:04:33,880
because we end up not actually answering

00:04:31,120 --> 00:04:36,660
them either we end up solving the wrong

00:04:33,880 --> 00:04:38,860
problem and that's an incredible waste

00:04:36,660 --> 00:04:41,290
or maybe we start off on the right

00:04:38,860 --> 00:04:44,440
problem but we don't actually solve it

00:04:41,290 --> 00:04:47,200
we think we had how do we know that's

00:04:44,440 --> 00:04:50,080
the question so how do we know when we

00:04:47,200 --> 00:04:52,570
solved the problem let's look at really

00:04:50,080 --> 00:04:56,670
simple requirement so I had two numbers

00:04:52,570 --> 00:04:58,980
together see very vague just run with it

00:04:56,670 --> 00:05:02,950
we might jump straight into some code

00:04:58,980 --> 00:05:05,020
not doing TDD here which write this code

00:05:02,950 --> 00:05:06,550
now we'll set aside for the moment other

00:05:05,020 --> 00:05:08,470
questions we can ask and it did we mean

00:05:06,550 --> 00:05:09,880
integers there's all sorts of other

00:05:08,470 --> 00:05:12,550
questions we can ask about requirements

00:05:09,880 --> 00:05:16,840
but to set that aside integers are fine

00:05:12,550 --> 00:05:17,950
here well writing code like this and now

00:05:16,840 --> 00:05:21,280
we need to know does this actually

00:05:17,950 --> 00:05:22,780
address the mither requirement that we

00:05:21,280 --> 00:05:26,440
were trying to solve what we were trying

00:05:22,780 --> 00:05:29,320
to solve how can we verify that we might

00:05:26,440 --> 00:05:31,300
say the case like this it's so simple we

00:05:29,320 --> 00:05:34,240
could just look at the code we can see

00:05:31,300 --> 00:05:36,820
it's going to do it and that may be true

00:05:34,240 --> 00:05:38,800
we might go out to simplify our code to

00:05:36,820 --> 00:05:40,630
the point can verify just by inspection

00:05:38,800 --> 00:05:43,120
and their whole disciplines that have

00:05:40,630 --> 00:05:46,470
been built up around code inspection and

00:05:43,120 --> 00:05:50,020
they're quite successful that it happens

00:05:46,470 --> 00:05:52,330
generally we want to actually run some

00:05:50,020 --> 00:05:54,520
code through this and see what the

00:05:52,330 --> 00:05:56,470
output is just to make sure this does

00:05:54,520 --> 00:06:00,700
actually do what we want and we'll see

00:05:56,470 --> 00:06:03,490
more complex cases all the more so so

00:06:00,700 --> 00:06:06,160
I'm gonna make a call to our add

00:06:03,490 --> 00:06:08,260
function give it some sample values we

00:06:06,160 --> 00:06:11,110
might do a few of these but let's go

00:06:08,260 --> 00:06:13,120
with one and two at the moment and that

00:06:11,110 --> 00:06:14,320
will exercise the code but still we

00:06:13,120 --> 00:06:17,890
don't know that it's returned the right

00:06:14,320 --> 00:06:21,960
value we need some means to to verify it

00:06:17,890 --> 00:06:26,250
it's a simplest way the Wiccans verify

00:06:21,960 --> 00:06:26,250
but that return the value we expected

00:06:26,310 --> 00:06:36,790
how about just a simple C assert

00:06:31,750 --> 00:06:40,130
so we've got our expression add 1 & 2

00:06:36,790 --> 00:06:41,810
we're saying that's equal to 3 that's

00:06:40,130 --> 00:06:46,880
gonna evaluates a boolean true or false

00:06:41,810 --> 00:06:50,660
and if it's false assert or terminate at

00:06:46,880 --> 00:06:52,310
least in the debug build so simple

00:06:50,660 --> 00:06:57,670
straightforward what happens when it

00:06:52,310 --> 00:07:00,440
does fail Oh before I go on there's a

00:06:57,670 --> 00:07:02,630
bit more to actually we do need to

00:07:00,440 --> 00:07:03,710
include the header for assert and we

00:07:02,630 --> 00:07:07,040
need to put it in some sort of function

00:07:03,710 --> 00:07:10,340
it could be mine but still that's just a

00:07:07,040 --> 00:07:12,350
few plus plus for you so if we introduce

00:07:10,340 --> 00:07:15,440
a deliberate error into this say we

00:07:12,350 --> 00:07:17,720
multiply instead of add what are we

00:07:15,440 --> 00:07:20,270
gonna get out of this something like

00:07:17,720 --> 00:07:24,020
this so I captured this on my Mac

00:07:20,270 --> 00:07:26,150
running Xcode with clang the app I got

00:07:24,020 --> 00:07:28,340
told me what the expression was that I

00:07:26,150 --> 00:07:30,530
wrote it's up with the function that it

00:07:28,340 --> 00:07:34,640
was in when it failed main in this case

00:07:30,530 --> 00:07:36,410
and that's nice you write a number of

00:07:34,640 --> 00:07:38,720
different test functions you want to

00:07:36,410 --> 00:07:40,640
capture that name and of course it tells

00:07:38,720 --> 00:07:42,350
you the file and 9 number but the

00:07:40,640 --> 00:07:45,500
assertion photon they can go straight to

00:07:42,350 --> 00:07:50,900
the cause of the problem that's actually

00:07:45,500 --> 00:07:52,610
really nice I haven't really invested in

00:07:50,900 --> 00:07:55,160
anything else other than just the

00:07:52,610 --> 00:07:57,620
standard library here and yet I'm

00:07:55,160 --> 00:07:59,080
getting some quite good feedback for a

00:07:57,620 --> 00:08:03,500
very simple test

00:07:59,080 --> 00:08:05,090
but there are some shortcomings one is

00:08:03,500 --> 00:08:08,270
that this output is implementation

00:08:05,090 --> 00:08:11,120
dependent so I ran this on Visual Studio

00:08:08,270 --> 00:08:14,120
and windows and I've got quite similar

00:08:11,120 --> 00:08:15,590
output didn't give me the function name

00:08:14,120 --> 00:08:18,950
to the shame

00:08:15,590 --> 00:08:21,260
and gave me most of the rest but none of

00:08:18,950 --> 00:08:23,300
that's actually guaranteed or what's

00:08:21,260 --> 00:08:26,510
guaranteed is that it might actually

00:08:23,300 --> 00:08:28,490
terminate so that's not cigarette

00:08:26,510 --> 00:08:31,160
doesn't scale too well either

00:08:28,490 --> 00:08:32,450
if you've got hundreds or thousands of

00:08:31,160 --> 00:08:34,370
these asserts probably want to group

00:08:32,450 --> 00:08:35,450
them you put them in functions then you

00:08:34,370 --> 00:08:37,550
want to have something that controls

00:08:35,450 --> 00:08:38,780
which ones get called and you get more

00:08:37,550 --> 00:08:40,250
and more of these requirements and

00:08:38,780 --> 00:08:42,890
you're not building your own test

00:08:40,250 --> 00:08:44,839
framework so

00:08:42,890 --> 00:08:48,620
that's when we turn the test frameworks

00:08:44,839 --> 00:08:53,950
and we concede that we might need some

00:08:48,620 --> 00:08:56,120
extra dependency so it talks about catch

00:08:53,950 --> 00:08:59,420
which is a test framework what does this

00:08:56,120 --> 00:09:02,720
look like we write it in catch very

00:08:59,420 --> 00:09:03,410
similar actually we still include a

00:09:02,720 --> 00:09:06,230
header file

00:09:03,410 --> 00:09:07,579
this time it's catch that HPP we still

00:09:06,230 --> 00:09:09,769
have to have some sort of function to

00:09:07,579 --> 00:09:12,649
put it in this case that's provided by

00:09:09,769 --> 00:09:15,350
this test case macro you notice we

00:09:12,649 --> 00:09:17,870
haven't given our test name we don't

00:09:15,350 --> 00:09:20,390
have to we usually would can be useful

00:09:17,870 --> 00:09:22,250
for demos and for exploration just did

00:09:20,390 --> 00:09:25,130
not have to worry about that yeah so or

00:09:22,250 --> 00:09:28,640
name things later and instead of assert

00:09:25,130 --> 00:09:30,980
we said require but the basic flow is is

00:09:28,640 --> 00:09:32,839
still there so we haven't lost too much

00:09:30,980 --> 00:09:39,110
I wouldn't take it on that additional

00:09:32,839 --> 00:09:40,630
dependency so that's quite nice there is

00:09:39,110 --> 00:09:43,550
one other thing we have to do that

00:09:40,630 --> 00:09:46,430
because catch will write its own version

00:09:43,550 --> 00:09:47,839
and main for us if we ask it to just in

00:09:46,430 --> 00:09:50,140
exactly one source file we need to put

00:09:47,839 --> 00:09:52,490
this hash define before we include catch

00:09:50,140 --> 00:09:55,820
catch config main there's another one if

00:09:52,490 --> 00:09:57,769
we want to provide our own main but

00:09:55,820 --> 00:09:59,570
apart from that that's the only

00:09:57,769 --> 00:10:02,480
additional thing over the OBD assert

00:09:59,570 --> 00:10:05,959
example so what sort of feedback does

00:10:02,480 --> 00:10:09,649
this give us now let's see that I think

00:10:05,959 --> 00:10:15,860
we should do a quick demo so I'm going

00:10:09,649 --> 00:10:17,540
to come out here start Xcode so I'm

00:10:15,860 --> 00:10:19,610
running on my Mac so I'm using Xcode

00:10:17,540 --> 00:10:22,790
there's nothing particularly Xcode

00:10:19,610 --> 00:10:26,660
specific about any of this so other than

00:10:22,790 --> 00:10:31,180
just setting up a project if I've got

00:10:26,660 --> 00:10:35,050
enough screen space to do this actually

00:10:31,180 --> 00:10:35,050
see if I can get rid of that dock

00:10:36,910 --> 00:10:48,340
yeah okay we got there in the end sorry

00:10:43,280 --> 00:10:52,670
about that everyone read that okay okay

00:10:48,340 --> 00:10:55,810
so like any good IDE Xcode is written a

00:10:52,670 --> 00:11:04,730
load of code that we don't actually need

00:10:55,810 --> 00:11:06,950
so we want to do is include catch now

00:11:04,730 --> 00:11:08,650
this is the spirit of TDD we're actually

00:11:06,950 --> 00:11:13,330
including a file we don't have yet

00:11:08,650 --> 00:11:16,330
seeing that file so now we need to get

00:11:13,330 --> 00:11:16,330
catch

00:11:36,630 --> 00:11:41,529
to go to my previous version of this

00:11:39,190 --> 00:11:42,819
tool so get that file there I would

00:11:41,529 --> 00:11:45,220
normally download it at the same time

00:11:42,819 --> 00:11:54,120
but already having too many problems

00:11:45,220 --> 00:11:57,910
here then we'll go back to our project

00:11:54,120 --> 00:11:59,850
so I'm just going to drop the single

00:11:57,910 --> 00:12:02,500
header file into that folder

00:11:59,850 --> 00:12:04,240
so hopefully have it interrupted the

00:12:02,500 --> 00:12:06,120
flow of this too much of it so normally

00:12:04,240 --> 00:12:08,139
I would get that file from github

00:12:06,120 --> 00:12:15,519
download it straight there and we're

00:12:08,139 --> 00:12:18,100
done then I go back to Xcode don't our

00:12:15,519 --> 00:12:21,279
compile but doesn't link the reason

00:12:18,100 --> 00:12:26,769
doesn't link is because we don't have

00:12:21,279 --> 00:12:31,569
mine so we need to put that how to

00:12:26,769 --> 00:12:35,230
define in that I mentioned catch Quantic

00:12:31,569 --> 00:12:39,120
main let now compiles in links and we

00:12:35,230 --> 00:12:39,120
have a complete working application

00:13:09,910 --> 00:13:19,820
know what's going on there okay gonna

00:13:16,550 --> 00:13:21,200
abandon this session for now we're going

00:13:19,820 --> 00:13:32,829
to come back in a moment to do another

00:13:21,200 --> 00:13:32,829
demo anyway but first go back to slides

00:13:32,890 --> 00:13:42,170
so wanted to talk a little bit oh there

00:13:38,180 --> 00:13:43,700
we go okay something's working we're

00:13:42,170 --> 00:13:47,180
gonna talk a little about why I wrote

00:13:43,700 --> 00:13:48,260
cash in the first place so let's go back

00:13:47,180 --> 00:13:52,519
to the in with the technical issues in a

00:13:48,260 --> 00:13:55,700
moment because after all there are one

00:13:52,519 --> 00:13:57,589
or two other test frameworks for C++

00:13:55,700 --> 00:13:58,220
already out there this is a page on the

00:13:57,589 --> 00:14:01,399
Wikipedia

00:13:58,220 --> 00:14:03,529
dedicated to just listing or the test

00:14:01,399 --> 00:14:05,990
frameworks for C++ you're taking notes

00:14:03,529 --> 00:14:08,120
you might wanna write quickly there's 56

00:14:05,990 --> 00:14:10,160
of them there at least there was when I

00:14:08,120 --> 00:14:12,199
captured that list about a year or so

00:14:10,160 --> 00:14:16,420
ago and of course that's not exhaustive

00:14:12,199 --> 00:14:20,660
so why do they need to write another one

00:14:16,420 --> 00:14:22,160
that's a good question so I'll see them

00:14:20,660 --> 00:14:23,899
try every single one of those I tried to

00:14:22,160 --> 00:14:27,519
the popular ones and there always seemed

00:14:23,899 --> 00:14:27,519
to be sort of one or two things missing

00:14:27,910 --> 00:14:33,980
probably the main one is just simplicity

00:14:31,329 --> 00:14:35,180
we saw right at the start that you can

00:14:33,980 --> 00:14:37,550
actually get quite far just within a

00:14:35,180 --> 00:14:39,800
search statement and we don't really

00:14:37,550 --> 00:14:42,620
want to give up that simplicity in terms

00:14:39,800 --> 00:14:44,540
of how you write the tests but

00:14:42,620 --> 00:14:46,130
directness using natural expressions and

00:14:44,540 --> 00:14:47,899
so on since with a lot of boilerplate

00:14:46,130 --> 00:14:50,029
and ceremony involved in so many of

00:14:47,899 --> 00:14:53,000
these test frameworks I just didn't get

00:14:50,029 --> 00:14:56,060
the like getting involved in that number

00:14:53,000 --> 00:14:58,399
one is expressiveness so just with a

00:14:56,060 --> 00:15:01,579
small amount of code being out to get

00:14:58,399 --> 00:15:04,220
rich feedback we did quite well with

00:15:01,579 --> 00:15:05,300
assert I've got for my last demo you'll

00:15:04,220 --> 00:15:09,499
is seen that catch gives you a little

00:15:05,300 --> 00:15:12,600
bit more and low overhead

00:15:09,499 --> 00:15:15,059
so you did say it's just a single header

00:15:12,600 --> 00:15:18,959
file you can grab from github you clue

00:15:15,059 --> 00:15:24,059
that and you get started no messing with

00:15:18,959 --> 00:15:25,709
you know static libraries and getting

00:15:24,059 --> 00:15:27,779
other things up and running worrying

00:15:25,709 --> 00:15:31,230
about the different build settings you

00:15:27,779 --> 00:15:32,910
just include and go oh yeah so they're

00:15:31,230 --> 00:15:34,139
the values that I was looking for and I

00:15:32,910 --> 00:15:36,809
didn't really find elsewhere

00:15:34,139 --> 00:15:39,209
at least at the time and I try to build

00:15:36,809 --> 00:15:44,309
these things into catch so hopefully

00:15:39,209 --> 00:15:46,139
your grief you you try it out so go back

00:15:44,309 --> 00:15:49,470
to that example we looked at earlier

00:15:46,139 --> 00:15:54,179
with the add function we saw how that

00:15:49,470 --> 00:15:57,089
works in you catch that we could add a

00:15:54,179 --> 00:15:59,309
name in now this might be surprising if

00:15:57,089 --> 00:16:01,709
you've used other test frameworks both

00:15:59,309 --> 00:16:04,379
test frameworks will force you to write

00:16:01,709 --> 00:16:07,049
your testings as function names usually

00:16:04,379 --> 00:16:08,850
you have to find out a way to couch

00:16:07,049 --> 00:16:11,029
these names and you want to try and be

00:16:08,850 --> 00:16:13,649
descriptive because what we're told

00:16:11,029 --> 00:16:16,470
try and couch them in legal safe house

00:16:13,649 --> 00:16:18,660
plus identifier well attach you think

00:16:16,470 --> 00:16:21,449
you see as a free-form string spaces

00:16:18,660 --> 00:16:24,360
punctuation whatever you like be

00:16:21,449 --> 00:16:27,919
descriptive as you like and more than

00:16:24,360 --> 00:16:30,679
that there's an optional extra argument

00:16:27,919 --> 00:16:33,329
where you can put in square brackets tax

00:16:30,679 --> 00:16:35,519
where as many of these as you like and

00:16:33,329 --> 00:16:37,499
these let you run groups of tests or

00:16:35,519 --> 00:16:38,639
exclude groups of tests and you can

00:16:37,499 --> 00:16:41,730
actually build up some fairly complex

00:16:38,639 --> 00:16:43,949
expressions to be able to sort of cut

00:16:41,730 --> 00:16:45,679
across your test suite and we'll see

00:16:43,949 --> 00:16:52,739
that a little bit more in action later

00:16:45,679 --> 00:16:55,379
so that's quite useful so at the point

00:16:52,739 --> 00:16:59,069
where what should have come to my second

00:16:55,379 --> 00:17:02,519
demo so I'm going to do because I've

00:16:59,069 --> 00:17:04,079
tried to keep a locked-down user for my

00:17:02,519 --> 00:17:08,870
presentation that doesn't seem to be

00:17:04,079 --> 00:17:08,870
working out so I'm going to log in as me

00:17:09,500 --> 00:17:26,919
Choki will give us less problems okay so

00:17:36,400 --> 00:17:41,750
starting Xcode again resolution is maybe

00:17:40,190 --> 00:17:55,340
a bit too high now let's see how it goes

00:17:41,750 --> 00:17:57,440
when we spikes code so for this demo I

00:17:55,340 --> 00:17:59,809
wanted to pick an example I could sort

00:17:57,440 --> 00:18:02,720
of work through and show you a fair bit

00:17:59,809 --> 00:18:05,809
of catch but also demonstrates EDD so a

00:18:02,720 --> 00:18:16,580
bit of a meteor demo so I'm going to do

00:18:05,809 --> 00:18:18,230
a ring buffer you know how those fonts

00:18:16,580 --> 00:18:24,280
looking is that readable for the back

00:18:18,230 --> 00:18:31,340
okay okay so again we get rid of that

00:18:24,280 --> 00:18:40,520
let's try coding catch again we know we

00:18:31,340 --> 00:18:41,419
want to do catch conflict moon now we

00:18:40,520 --> 00:18:43,400
know we're going to need that header

00:18:41,419 --> 00:18:45,460
file it from somewhere different this

00:18:43,400 --> 00:18:45,460
time

00:18:54,970 --> 00:18:58,570
would it be create that

00:19:08,580 --> 00:19:17,289
okay so and Rappard in there I should

00:19:15,999 --> 00:19:23,549
now compile and build this is where we

00:19:17,289 --> 00:19:23,549
got to earlier and we couldn't run it

00:19:37,220 --> 00:19:43,690
okay that's a bit weird I need to do

00:19:59,300 --> 00:20:09,110
well that's never not worked before it's

00:20:04,420 --> 00:20:16,550
definitely bad demo day today should I

00:20:09,110 --> 00:20:18,650
run it from the terminal okay that's

00:20:16,550 --> 00:20:20,480
better

00:20:18,650 --> 00:20:24,350
let's try and bring the fonts up a bit

00:20:20,480 --> 00:20:27,850
on there I prefer running this from the

00:20:24,350 --> 00:20:27,850
terminal anyway so it's no big loss

00:20:44,549 --> 00:20:55,600
okay that terminal readable so no test

00:20:51,490 --> 00:21:04,890
run ran that's what we expect so that's

00:20:55,600 --> 00:21:06,880
fine so let's start our demo

00:21:04,890 --> 00:21:12,419
so we said we're going to do a ring

00:21:06,880 --> 00:21:14,320
buffer I'll call it that for now now

00:21:12,419 --> 00:21:15,340
we're going to want some sort of ring

00:21:14,320 --> 00:21:18,690
buffer class

00:21:15,340 --> 00:21:23,140
so let's declare an instance of that so

00:21:18,690 --> 00:21:26,049
this is the start of TDD we haven't

00:21:23,140 --> 00:21:28,750
created a ring buffer class yet but in

00:21:26,049 --> 00:21:32,020
our test we're asking for one this the

00:21:28,750 --> 00:21:34,179
way TDD works we write the test code

00:21:32,020 --> 00:21:36,640
first and then even when that doesn't

00:21:34,179 --> 00:21:37,720
compile we can that's telling us

00:21:36,640 --> 00:21:43,240
something it's telling us we need to

00:21:37,720 --> 00:21:48,360
create a class called ring buffer so

00:21:43,240 --> 00:21:50,679
let's do that don't have to implement it

00:21:48,360 --> 00:21:55,480
what we're doing is the minimum that we

00:21:50,679 --> 00:21:57,520
need to get this test to pass and even

00:21:55,480 --> 00:22:03,940
though there's no assertions yet just

00:21:57,520 --> 00:22:08,799
compiling is the first stage commonly

00:22:03,940 --> 00:22:14,440
there but we can see that it still runs

00:22:08,799 --> 00:22:17,730
but it's not particularly interesting so

00:22:14,440 --> 00:22:21,040
let's start adding some requirements

00:22:17,730 --> 00:22:25,210
what can we say about an empty ring

00:22:21,040 --> 00:22:28,419
buffer well we could say that its size

00:22:25,210 --> 00:22:31,200
is zero we haven't written a size method

00:22:28,419 --> 00:22:36,460
yet so let's do that

00:22:31,200 --> 00:22:39,429
it's size T and what are we going to

00:22:36,460 --> 00:22:41,890
return well now we just want to make the

00:22:39,429 --> 00:22:44,980
test pass so we're going to hard code a

00:22:41,890 --> 00:22:48,100
zero in there if you've not done CDD

00:22:44,980 --> 00:22:49,630
before this might seem a bit stupid you

00:22:48,100 --> 00:22:51,480
know we know that's not German enough

00:22:49,630 --> 00:22:52,889
but this is the point

00:22:51,480 --> 00:22:54,630
we're not going to write the

00:22:52,889 --> 00:22:57,179
general-purpose code until we have tests

00:22:54,630 --> 00:22:59,340
that cover it so we only ever write what

00:22:57,179 --> 00:23:00,570
we need to make the test pass and then

00:22:59,340 --> 00:23:07,230
we think about what tests we need to

00:23:00,570 --> 00:23:11,490
write so make that file so for now that

00:23:07,230 --> 00:23:18,000
should make the test pass and everything

00:23:11,490 --> 00:23:21,090
is green so that's good now on the side

00:23:18,000 --> 00:23:23,340
it may have noticed that the compilation

00:23:21,090 --> 00:23:26,570
is getting a bit slow here we have very

00:23:23,340 --> 00:23:31,710
much code so what's going on the reason

00:23:26,570 --> 00:23:34,500
is this catch convict name so I said

00:23:31,710 --> 00:23:36,600
that that causes catch to generate a

00:23:34,500 --> 00:23:37,500
version and main for us and it does but

00:23:36,600 --> 00:23:40,230
there have been more to it than that

00:23:37,500 --> 00:23:42,720
though we've packaged catch as a single

00:23:40,230 --> 00:23:45,659
header file but it has a whole framework

00:23:42,720 --> 00:23:47,340
in there and normally you would write

00:23:45,659 --> 00:23:49,980
several header files and implementation

00:23:47,340 --> 00:23:52,169
files and in cash both of those are

00:23:49,980 --> 00:23:54,450
present it's compiling the whole thing

00:23:52,169 --> 00:23:59,580
every time we don't want to pay the cost

00:23:54,450 --> 00:24:06,990
of that so what we'll do let it another

00:23:59,580 --> 00:24:15,590
test file let's call it test dot CPP for

00:24:06,990 --> 00:24:15,590
now let's forget to give another header

00:24:16,010 --> 00:24:23,429
we're copy everything from our main file

00:24:20,250 --> 00:24:27,450
into there except we removed that hash

00:24:23,429 --> 00:24:30,299
define we only need it in one file and

00:24:27,450 --> 00:24:33,000
in our main file that's all we're gonna

00:24:30,299 --> 00:24:35,700
do so

00:24:33,000 --> 00:24:37,169
did something going up asked them quite

00:24:35,700 --> 00:24:39,289
a lot you know why does catch compile so

00:24:37,169 --> 00:24:41,220
slowly that's usually their reason

00:24:39,289 --> 00:24:44,190
you're putting all your tests in the

00:24:41,220 --> 00:24:46,440
same file as the catch config main it's

00:24:44,190 --> 00:24:47,639
great for demos and to get started but

00:24:46,440 --> 00:24:48,990
once you're actually building up a test

00:24:47,639 --> 00:24:50,940
suite it's best to keep this off in its

00:24:48,990 --> 00:24:54,779
own file that's now only going to have

00:24:50,940 --> 00:24:58,799
that long compile once get that out the

00:24:54,779 --> 00:25:01,379
way and now introduce a deliberate

00:24:58,799 --> 00:25:02,760
mistake there compile again you can see

00:25:01,379 --> 00:25:03,890
it's pretty much instant that's what we

00:25:02,760 --> 00:25:06,670
would expect

00:25:03,890 --> 00:25:08,750
could run that we can see the test file

00:25:06,670 --> 00:25:11,480
so we didn't see the test file before

00:25:08,750 --> 00:25:14,600
they didn't do my previous demo now you

00:25:11,480 --> 00:25:16,160
can see what the output looks like we've

00:25:14,600 --> 00:25:18,080
got so plenty of red there to show us

00:25:16,160 --> 00:25:22,190
that everything has gone wrong see that

00:25:18,080 --> 00:25:25,750
the test is filed you can see what we've

00:25:22,190 --> 00:25:27,830
got the the test name up here

00:25:25,750 --> 00:25:30,140
the final a known number of the test

00:25:27,830 --> 00:25:33,010
case file an EIN number the failing

00:25:30,140 --> 00:25:36,860
assertion the assertion as we wrote it

00:25:33,010 --> 00:25:40,540
so so far we're sort of on par with the

00:25:36,860 --> 00:25:43,400
assert statement but now we've also got

00:25:40,540 --> 00:25:45,320
the expansion of the expression the

00:25:43,400 --> 00:25:48,520
left-hand side and right-hand side

00:25:45,320 --> 00:25:50,870
separated out and that's interesting

00:25:48,520 --> 00:25:53,560
because in most test frameworks to get

00:25:50,870 --> 00:25:56,900
that you need to rewrite your expression

00:25:53,560 --> 00:25:59,870
using a macro like a 30 equals in this

00:25:56,900 --> 00:26:01,340
case it's quite common it seemed like a

00:25:59,870 --> 00:26:03,770
minor thing but if these little speed

00:26:01,340 --> 00:26:05,480
ballasts that you have to have a

00:26:03,770 --> 00:26:07,580
slightly different mindset and the way

00:26:05,480 --> 00:26:09,380
you write your test code it's to

00:26:07,580 --> 00:26:11,890
slightly less natural than the code you

00:26:09,380 --> 00:26:13,790
would have written otherwise adds up so

00:26:11,890 --> 00:26:15,560
here we're just using a natural

00:26:13,790 --> 00:26:18,620
expression and it's broken it down for

00:26:15,560 --> 00:26:20,570
us now forget time it's all wasted a bit

00:26:18,620 --> 00:26:21,710
of time and the technical issues we were

00:26:20,570 --> 00:26:24,770
going to how I do that

00:26:21,710 --> 00:26:27,040
a bit later let's go back to our ring

00:26:24,770 --> 00:26:27,040
buffer

00:26:35,100 --> 00:26:48,070
so let me come down because I was a bit

00:26:38,020 --> 00:26:48,340
blocked so I still didn't quite catch

00:26:48,070 --> 00:26:58,000
that

00:26:48,340 --> 00:27:00,700
let's write about this in the other

00:26:58,000 --> 00:27:03,250
source file you mean when I spit from

00:27:00,700 --> 00:27:06,430
Maine and test at CPP so I think the

00:27:03,250 --> 00:27:08,530
question was I moved the test into

00:27:06,430 --> 00:27:13,630
another source file so how did catch

00:27:08,530 --> 00:27:18,580
pick pick them up so the the test case

00:27:13,630 --> 00:27:20,290
macro this one here defines a function

00:27:18,580 --> 00:27:24,790
behind the scenes but also defines a

00:27:20,290 --> 00:27:28,240
little class that has a constructor that

00:27:24,790 --> 00:27:31,330
just registers the test case and another

00:27:28,240 --> 00:27:33,400
like the global instance of that fairly

00:27:31,330 --> 00:27:36,790
common technique for self registering

00:27:33,400 --> 00:27:40,240
test cases because we have we have

00:27:36,790 --> 00:27:43,390
included a catch here we just didn't use

00:27:40,240 --> 00:27:46,030
the define to instantiate a main so it's

00:27:43,390 --> 00:27:47,950
got all of the catch machinery so it

00:27:46,030 --> 00:27:49,450
works exactly the same way there as it

00:27:47,950 --> 00:27:57,940
would have done in the main test file

00:27:49,450 --> 00:27:59,170
sound to your question great okay so we

00:27:57,940 --> 00:28:02,970
said that the size is zero we've

00:27:59,170 --> 00:28:02,970
hard-coded that let's fix that again now

00:28:04,530 --> 00:28:12,070
and now we can see the test passes again

00:28:06,910 --> 00:28:13,900
it's great so what else can we do with a

00:28:12,070 --> 00:28:18,160
ring buffer we probably want to be able

00:28:13,900 --> 00:28:20,610
to add elements so let's use pushback

00:28:18,160 --> 00:28:23,560
and we use push back and pop front

00:28:20,610 --> 00:28:25,960
because we're gonna have a front of the

00:28:23,560 --> 00:28:28,270
buffer in the back of the buffer which

00:28:25,960 --> 00:28:30,850
move independently

00:28:28,270 --> 00:28:32,830
now what are we going to put in it we

00:28:30,850 --> 00:28:36,010
haven't said what types the ring Pathak

00:28:32,830 --> 00:28:43,510
anode so let's go back and make that a

00:28:36,010 --> 00:28:44,980
template to probably what we want and

00:28:43,510 --> 00:28:52,240
well let's den see eight this for in

00:28:44,980 --> 00:28:54,429
spinel we put a one in there and now we

00:28:52,240 --> 00:29:02,710
need to write pushback because it's

00:28:54,429 --> 00:29:05,440
asking us to we don't have to implement

00:29:02,710 --> 00:29:07,210
it because we're not testing anything

00:29:05,440 --> 00:29:10,260
any consequences of that just yet

00:29:07,210 --> 00:29:13,510
we just need that to be able to compile

00:29:10,260 --> 00:29:18,100
okay what can we now say about the ring

00:29:13,510 --> 00:29:21,280
buffer well got our size method we would

00:29:18,100 --> 00:29:23,710
expect that to now return one I'll say

00:29:21,280 --> 00:29:25,090
expect we'd expect this to this test to

00:29:23,710 --> 00:29:28,150
fail because we haven't written any code

00:29:25,090 --> 00:29:31,480
to cope with it yet and of course it

00:29:28,150 --> 00:29:34,800
does size is still zero now is the time

00:29:31,480 --> 00:29:38,290
we can go back and make the size method

00:29:34,800 --> 00:29:40,450
more general so we're going to want

00:29:38,290 --> 00:29:46,890
something to keep a track of the size so

00:29:40,450 --> 00:29:46,890
let's just introduce a variable size

00:29:47,580 --> 00:29:59,200
going to want to initialize that in our

00:29:53,020 --> 00:30:07,080
constructor now we can return it here

00:29:59,200 --> 00:30:07,080
and we could implement it yeah

00:30:07,559 --> 00:30:10,920
see if that works

00:30:12,649 --> 00:30:22,139
and it does so this again it might seem

00:30:19,379 --> 00:30:23,970
a bit of an odd way to to build our ring

00:30:22,139 --> 00:30:25,379
buffer we sort of probably have an idea

00:30:23,970 --> 00:30:27,629
in our head how we wanted to implement

00:30:25,379 --> 00:30:30,480
it but the tests are leading us in a

00:30:27,629 --> 00:30:33,989
slightly different direction but we will

00:30:30,480 --> 00:30:35,730
get there let's carry on with this now

00:30:33,989 --> 00:30:38,210
we've got an item on the ring buffer or

00:30:35,730 --> 00:30:43,259
at least we we seem to have pushed one

00:30:38,210 --> 00:30:49,230
well we want to be able to get a value

00:30:43,259 --> 00:30:56,399
back of course whoever written pop front

00:30:49,230 --> 00:30:59,220
yet so let's do that now and it's a

00:30:56,399 --> 00:31:03,210
minimum we can do to make this pass was

00:30:59,220 --> 00:31:07,289
just to return the default 40 that

00:31:03,210 --> 00:31:10,440
compiles so now what can we say about

00:31:07,289 --> 00:31:13,679
the ring buffer again we can look at the

00:31:10,440 --> 00:31:18,570
size I should now have gone down because

00:31:13,679 --> 00:31:23,149
we've removed an item and do we expect

00:31:18,570 --> 00:31:27,509
that to pass or fail hopefully file C

00:31:23,149 --> 00:31:28,679
and it does again this is safe like a

00:31:27,509 --> 00:31:30,359
stupid step you know we know that's

00:31:28,679 --> 00:31:32,669
going to fail why do we run it of

00:31:30,359 --> 00:31:34,710
sometimes it doesn't and then that tells

00:31:32,669 --> 00:31:36,029
you that you've missed something should

00:31:34,710 --> 00:31:37,859
always know exactly what your code is

00:31:36,029 --> 00:31:42,109
doing so we challenge our assumptions

00:31:37,859 --> 00:31:46,519
all the time even the simplest cases so

00:31:42,109 --> 00:31:49,049
now we can the equipment the size here

00:31:46,519 --> 00:31:51,299
we pop back notice we haven't got any

00:31:49,049 --> 00:31:59,789
storage yet but I'm actually storing any

00:31:51,299 --> 00:32:03,690
of these values that now passes okay but

00:31:59,789 --> 00:32:09,809
now now we're going to want to test the

00:32:03,690 --> 00:32:11,190
value and we want to expect that to be

00:32:09,809 --> 00:32:17,670
the value that we pushed in which is a 1

00:32:11,190 --> 00:32:21,720
I would hope that's going to fail

00:32:17,670 --> 00:32:23,960
it does so now this is a point where

00:32:21,720 --> 00:32:27,600
we're going to want to do some real work

00:32:23,960 --> 00:32:30,060
we won't actually hold on to to the

00:32:27,600 --> 00:32:32,190
values we put on and it forces us to

00:32:30,060 --> 00:32:33,990
take on another question is how big is a

00:32:32,190 --> 00:32:35,990
ring buffer going to be we haven't said

00:32:33,990 --> 00:32:40,380
that anywhere

00:32:35,990 --> 00:32:44,430
so first of all we want the constructor

00:32:40,380 --> 00:32:45,800
to take a capacity there's a few ways we

00:32:44,430 --> 00:32:48,450
could do this we might want to make it a

00:32:45,800 --> 00:32:49,950
fixed size at compile time a template

00:32:48,450 --> 00:32:53,580
argument we're going to do it like this

00:32:49,950 --> 00:32:57,750
for now and with uh some underlying

00:32:53,580 --> 00:32:59,210
storage we use a standard vector gonna

00:32:57,750 --> 00:33:06,180
have lots of choices we could do here

00:32:59,210 --> 00:33:09,650
this keeps it simple so how are we going

00:33:06,180 --> 00:33:09,650
to relate the capacity in the vector

00:33:09,920 --> 00:33:15,000
well vector has a capacity that's not

00:33:12,840 --> 00:33:18,990
quite what we want here where she want

00:33:15,000 --> 00:33:23,100
the buffer to be a fixed size and just

00:33:18,990 --> 00:33:26,640
have her pointers into it so we actually

00:33:23,100 --> 00:33:32,730
going to create a vector already sized

00:33:26,640 --> 00:33:36,270
to capacity initialize it to zeros it

00:33:32,730 --> 00:33:41,460
gives us somewhere to put our values now

00:33:36,270 --> 00:33:44,160
so we couldn't we could push back but

00:33:41,460 --> 00:33:45,750
that would push after our buffer but

00:33:44,160 --> 00:33:53,850
it's not what we want we want actually

00:33:45,750 --> 00:33:56,670
set in to do size we can move that back

00:33:53,850 --> 00:34:00,000
there it's not going to be that helpful

00:33:56,670 --> 00:34:03,870
let's let's go with this and see what

00:34:00,000 --> 00:34:05,670
happens to retrieve the item off well we

00:34:03,870 --> 00:34:07,020
need to go back from the front we don't

00:34:05,670 --> 00:34:10,310
have anything that's telling us what the

00:34:07,020 --> 00:34:16,020
front of the buffer is so uh actually

00:34:10,310 --> 00:34:18,620
we're gonna need some more indices we

00:34:16,020 --> 00:34:18,620
have front and back

00:34:21,330 --> 00:34:33,040
those zeros now we can say push back

00:34:29,880 --> 00:34:36,670
go to the back index which were then

00:34:33,040 --> 00:34:38,020
want to increment obviously there's

00:34:36,670 --> 00:34:39,280
something else we need to do there but

00:34:38,020 --> 00:34:51,160
we can not get into that just yet

00:34:39,280 --> 00:34:54,820
and now I'll pop front similarly take it

00:34:51,160 --> 00:34:56,800
from the front index and now the front

00:34:54,820 --> 00:35:01,230
is going to move on because it's a ring

00:34:56,800 --> 00:35:04,330
buffer so we'll increment that as well

00:35:01,230 --> 00:35:06,460
that should be enough if I've not missed

00:35:04,330 --> 00:35:09,880
anything which I have of course the

00:35:06,460 --> 00:35:14,320
capacity here let's make it four that

00:35:09,880 --> 00:35:17,920
should be enough to pass our tests it

00:35:14,320 --> 00:35:22,540
does it's definitely not finished but it

00:35:17,920 --> 00:35:24,810
passed their test so far so I chose a

00:35:22,540 --> 00:35:28,900
buffer size of four here just to keep it

00:35:24,810 --> 00:35:31,750
maintainable for our tests another thing

00:35:28,900 --> 00:35:33,760
to notice here is we've got our the code

00:35:31,750 --> 00:35:36,570
under tests and the tests in the same

00:35:33,760 --> 00:35:38,740
farm don't have to do that of course I

00:35:36,570 --> 00:35:41,590
usually prefer to do it that way when

00:35:38,740 --> 00:35:44,680
I'm just writing some new class or

00:35:41,590 --> 00:35:46,420
structure or function this in isolation

00:35:44,680 --> 00:35:47,650
health-food to keep it in isolation and

00:35:46,420 --> 00:35:51,790
not worry about the rest of the system

00:35:47,650 --> 00:35:55,300
you can do it in place in another target

00:35:51,790 --> 00:35:56,620
source file if you want I'd sort of move

00:35:55,300 --> 00:36:00,310
it there when it's ready make sure all

00:35:56,620 --> 00:36:03,700
the tests all pass matter of choice but

00:36:00,310 --> 00:36:06,970
something else we're doing wrong here if

00:36:03,700 --> 00:36:09,150
you done any unit testing before you've

00:36:06,970 --> 00:36:12,010
probably heard of this guideline that

00:36:09,150 --> 00:36:15,790
you should only have one assertion per

00:36:12,010 --> 00:36:18,790
test that actually means one logical

00:36:15,790 --> 00:36:20,920
assertion so down here at the bottom

00:36:18,790 --> 00:36:23,710
where we're testing the size and the

00:36:20,920 --> 00:36:26,080
value we got back that's two aspects or

00:36:23,710 --> 00:36:29,310
test of the result of popped rent so

00:36:26,080 --> 00:36:31,420
that's one logical assert that's fine

00:36:29,310 --> 00:36:32,170
problem is we have these ones here as

00:36:31,420 --> 00:36:34,540
well

00:36:32,170 --> 00:36:36,460
with testing some state we take in the

00:36:34,540 --> 00:36:38,800
state testing again mutating testing

00:36:36,460 --> 00:36:41,050
again and that's considered bad form in

00:36:38,800 --> 00:36:45,940
unit testing because you can't isolate

00:36:41,050 --> 00:36:47,320
those different parts usually we would

00:36:45,940 --> 00:36:49,390
have to nail separate this out into

00:36:47,320 --> 00:36:51,040
separate test cases with a lot of

00:36:49,390 --> 00:36:54,910
duplication some of which we could

00:36:51,040 --> 00:37:01,890
factor out into a setup method the catch

00:36:54,910 --> 00:37:06,370
has a a different way we can now create

00:37:01,890 --> 00:37:15,010
different sections that will be executed

00:37:06,370 --> 00:37:18,390
separately so here we're going to add a

00:37:15,010 --> 00:37:22,990
value adding a value increases the size

00:37:18,390 --> 00:37:25,630
give it nice descriptive names again and

00:37:22,990 --> 00:37:27,070
that's that part there this is going to

00:37:25,630 --> 00:37:32,230
continue on so we want that in here as

00:37:27,070 --> 00:37:36,790
well so that's our second legible is

00:37:32,230 --> 00:37:41,560
that off in a section and then the next

00:37:36,790 --> 00:37:47,020
section starts here talking about it

00:37:41,560 --> 00:37:56,140
decreases the size and returns the first

00:37:47,020 --> 00:38:00,280
ready these names aren't brilliant we'll

00:37:56,140 --> 00:38:02,410
come back to that in a while but now

00:38:00,280 --> 00:38:05,860
we've got h logical asserting its own

00:38:02,410 --> 00:38:10,390
section but notice we've been out to

00:38:05,860 --> 00:38:11,920
nest sections here in here because this

00:38:10,390 --> 00:38:16,300
section is still dependent on the first

00:38:11,920 --> 00:38:18,520
section our first logical test is to set

00:38:16,300 --> 00:38:21,130
up for the next illogical test so we

00:38:18,520 --> 00:38:23,050
captured that in other cases we can

00:38:21,130 --> 00:38:24,880
include additional sections here which

00:38:23,050 --> 00:38:27,370
we will do in a moment but are not

00:38:24,880 --> 00:38:31,320
dependent we'll see how that works let's

00:38:27,370 --> 00:38:33,580
just make sure that still runs it does

00:38:31,320 --> 00:38:34,870
now when I seen the output here because

00:38:33,580 --> 00:38:37,660
we haven't seen any failures for a while

00:38:34,870 --> 00:38:41,610
we can see the output even if it

00:38:37,660 --> 00:38:45,020
succeeds with - yes and now we can say

00:38:41,610 --> 00:38:47,810
as well as all no results up here

00:38:45,020 --> 00:38:49,190
got our test case name and the names of

00:38:47,810 --> 00:38:51,470
all the sections that have been executed

00:38:49,190 --> 00:38:54,710
up to that point like a stack if acted

00:38:51,470 --> 00:38:58,850
is a stack these little stack based so

00:38:54,710 --> 00:39:01,190
it's a really natural fit for C++ I hope

00:38:58,850 --> 00:39:04,400
you scroll back a bit we can see it's

00:39:01,190 --> 00:39:09,830
also executed just the first section in

00:39:04,400 --> 00:39:14,090
isolation and that was the really the

00:39:09,830 --> 00:39:17,230
first illogical section so we've got

00:39:14,090 --> 00:39:17,230
quite a lot of bang for the buck there

00:39:18,100 --> 00:39:24,170
and having done that we can carry on so

00:39:21,070 --> 00:39:27,380
we've added one value to our buffer and

00:39:24,170 --> 00:39:29,180
popped it back again but it's gonna get

00:39:27,380 --> 00:39:32,660
more interesting if we add more values

00:39:29,180 --> 00:39:42,560
than there there should be room for so

00:39:32,660 --> 00:39:48,980
let's start a new section for that so

00:39:42,560 --> 00:39:52,910
adding more values and capacity wraps

00:39:48,980 --> 00:39:57,590
the buffer will get a better name for

00:39:52,910 --> 00:39:59,930
that in a while so we're going to want

00:39:57,590 --> 00:40:02,990
to add at least five values now we can

00:39:59,930 --> 00:40:04,250
do five pushbacks in a row but that's

00:40:02,990 --> 00:40:07,670
going to get a bit tedious if we have to

00:40:04,250 --> 00:40:09,560
do that a lot so happen to write this

00:40:07,670 --> 00:40:12,890
test it's putting us in the driving seat

00:40:09,560 --> 00:40:15,470
where this is part of the driving part

00:40:12,890 --> 00:40:17,380
of test-driven development we're seeing

00:40:15,470 --> 00:40:19,850
what it's like as a client of our code

00:40:17,380 --> 00:40:21,530
rather than does the implementer and it

00:40:19,850 --> 00:40:25,010
can often change to you know the way

00:40:21,530 --> 00:40:27,230
that we want to express our API it's

00:40:25,010 --> 00:40:30,770
quite convenient to be able to push many

00:40:27,230 --> 00:40:35,540
items at once and we've so plus plus 11

00:40:30,770 --> 00:40:43,250
we have a nice way to do that we've and

00:40:35,540 --> 00:40:44,540
initialize a list so I'm going to do an

00:40:43,250 --> 00:40:47,080
overload of pushback takes an

00:40:44,540 --> 00:40:47,080
initializer list

00:40:49,650 --> 00:40:56,440
we can quickly look through there and

00:40:53,099 --> 00:40:59,019
for the values onto our single value

00:40:56,440 --> 00:41:04,150
overload that's a few ways we could do

00:40:59,019 --> 00:41:06,279
that we could use a an algorithm notice

00:41:04,150 --> 00:41:07,630
also that that method is implemented

00:41:06,279 --> 00:41:10,900
entirely in terms of the public

00:41:07,630 --> 00:41:12,549
interface our ring buffer we could

00:41:10,900 --> 00:41:13,119
choose to move that out into non-member

00:41:12,549 --> 00:41:15,880
non-friend

00:41:13,119 --> 00:41:18,279
and a certain advantages to that as a

00:41:15,880 --> 00:41:20,880
design choice which we had to make

00:41:18,279 --> 00:41:23,170
separately if you feel that this is

00:41:20,880 --> 00:41:25,599
genuine generally useful

00:41:23,170 --> 00:41:27,640
he might be clearer to leave it there if

00:41:25,599 --> 00:41:30,430
you thought it is just for your tests to

00:41:27,640 --> 00:41:34,749
start with maybe better to leave it as a

00:41:30,430 --> 00:41:38,859
non-member non-friend okay so now we got

00:41:34,749 --> 00:41:44,380
that we can have a bit more fun and add

00:41:38,859 --> 00:41:47,380
multiple values so that should now

00:41:44,380 --> 00:41:50,529
overflow our buffer and wrap around of

00:41:47,380 --> 00:41:54,130
course we know it doesn't yet but what

00:41:50,529 --> 00:41:57,880
can we say about that now again we can

00:41:54,130 --> 00:41:59,470
look at the size that should now be

00:41:57,880 --> 00:42:01,119
stuck at four even though we are did

00:41:59,470 --> 00:42:08,680
five items because that's the point of a

00:42:01,119 --> 00:42:16,200
ring back so expect that to fail and it

00:42:08,680 --> 00:42:16,200
does mmm that looks a bit suspicious

00:42:18,940 --> 00:42:26,520
okay I have to look at that we'll move

00:42:22,329 --> 00:42:29,829
on for now point is it did fail oh

00:42:26,520 --> 00:42:34,299
that's because that's the wrong that was

00:42:29,829 --> 00:42:37,690
the funny one good that's a relief it's

00:42:34,299 --> 00:42:40,599
one less bug report today so we expected

00:42:37,690 --> 00:42:44,740
the five because we're not wrapping

00:42:40,599 --> 00:42:48,030
around so coming up here we can see

00:42:44,740 --> 00:42:52,869
we're unconditionally incrementing sighs

00:42:48,030 --> 00:42:56,859
what we wanted to do is say if size is

00:42:52,869 --> 00:43:07,990
less than the capacity what's the

00:42:56,859 --> 00:43:11,140
capacity it's the size of the vector so

00:43:07,990 --> 00:43:18,539
that's going to stop at four now which

00:43:11,140 --> 00:43:27,510
means our test should pass and it does

00:43:18,539 --> 00:43:34,510
we're far from done now let's pop front

00:43:27,510 --> 00:43:36,309
again see what value we got back so we

00:43:34,510 --> 00:43:38,319
know we should be expecting because we

00:43:36,309 --> 00:43:53,490
only got four items should be expecting

00:43:38,319 --> 00:43:53,490
a - what do we get

00:43:55,340 --> 00:44:06,619
at 1:00 so again that's because

00:44:11,660 --> 00:44:21,049
here we're unconditionally incrementing

00:44:16,099 --> 00:44:25,630
our back index okay so that's sober

00:44:21,049 --> 00:44:29,599
flowing off the end I've been told that

00:44:25,630 --> 00:44:33,980
running a bit shorter time so I'm not

00:44:29,599 --> 00:44:35,869
going to finish this demo as it is most

00:44:33,980 --> 00:44:39,619
of its carrying on much the same I

00:44:35,869 --> 00:44:42,770
wanted to just pivot into different

00:44:39,619 --> 00:44:46,490
aspects of of catch so we've used these

00:44:42,770 --> 00:44:49,150
test cases and sections here you can see

00:44:46,490 --> 00:44:51,559
how that's allowing us to group related

00:44:49,150 --> 00:44:53,869
parts of the test together to keep

00:44:51,559 --> 00:44:58,309
single logical assertions and nicely

00:44:53,869 --> 00:45:01,539
described the flow through but if you've

00:44:58,309 --> 00:45:03,799
done any BDD behavior-driven development

00:45:01,539 --> 00:45:07,490
you might be familiar with another way

00:45:03,799 --> 00:45:11,869
of talking about these tests with the

00:45:07,490 --> 00:45:13,849
given when then approach and catch the

00:45:11,869 --> 00:45:19,750
forces as well we're just a set of

00:45:13,849 --> 00:45:22,960
alternate macros starting with scenario

00:45:19,750 --> 00:45:29,329
it's a corresponds to the test case and

00:45:22,960 --> 00:45:39,099
then we can say given an empty ring

00:45:29,329 --> 00:45:41,960
buffer does involve a bit more nesting

00:45:39,099 --> 00:45:45,650
costume you pay so given an in tearing

00:45:41,960 --> 00:45:51,650
buffer throw that should have included

00:45:45,650 --> 00:45:55,160
that this case has no when we can see

00:45:51,650 --> 00:46:00,200
then signs will be 0

00:45:55,160 --> 00:46:04,539
I don't we can say we'll give it an

00:46:00,200 --> 00:46:04,539
empty ring buffer when

00:46:06,430 --> 00:46:33,339
the value is pushed then the science

00:46:18,970 --> 00:46:46,559
becomes one now we get the nesting and

00:46:33,339 --> 00:47:01,029
when the value is popped then size

00:46:46,559 --> 00:47:02,619
decreases the value is returned I would

00:47:01,029 --> 00:47:07,170
just do this one as well so going back

00:47:02,619 --> 00:47:07,170
to give it an interviewing buffer when

00:47:09,390 --> 00:47:16,020
more believes in the capacity or I did

00:47:17,490 --> 00:47:31,289
then buffer wraps around size stays at

00:47:29,020 --> 00:47:31,289
capacity

00:47:39,270 --> 00:47:46,180
okay so let's look at what we've done

00:47:41,049 --> 00:48:23,829
here it's a same test but we've changed

00:47:46,180 --> 00:48:28,599
the naming a bit sorry had a question so

00:48:23,829 --> 00:48:30,630
they're they're following on so are you

00:48:28,599 --> 00:48:33,880
saying that we could put the end when

00:48:30,630 --> 00:48:36,609
directly under the web yes you could if

00:48:33,880 --> 00:48:38,349
I probably should have done that rushing

00:48:36,609 --> 00:48:41,260
a little bit too much you're quite right

00:48:38,349 --> 00:48:43,299
it will work either way but yes you've

00:48:41,260 --> 00:48:44,829
got seven additional logical assert in

00:48:43,299 --> 00:48:48,390
that chain that you'd probably don't

00:48:44,829 --> 00:48:48,390
need so you're quite right

00:48:54,839 --> 00:49:02,140
so yeah the point was here this bar is

00:49:00,309 --> 00:49:04,529
not really dependent on that then we can

00:49:02,140 --> 00:49:04,529
move it out

00:49:10,269 --> 00:49:19,009
it's okay so we've introduced this

00:49:14,930 --> 00:49:20,749
structure and quite a nice property of

00:49:19,009 --> 00:49:21,920
the naming has emerged as a result of

00:49:20,749 --> 00:49:23,839
this I think it's much clearer than what

00:49:21,920 --> 00:49:25,009
we had a moment ago and we haven't

00:49:23,839 --> 00:49:26,989
really had to think too much about it

00:49:25,009 --> 00:49:29,660
which has been guided by the given when

00:49:26,989 --> 00:49:34,160
they're in structure so best

00:49:29,660 --> 00:49:35,630
demonstrated if we actually run that run

00:49:34,160 --> 00:49:40,900
over - yes and we still got that failing

00:49:35,630 --> 00:49:43,599
test but you look now the test name

00:49:40,900 --> 00:49:46,549
we've got a whole scenario description

00:49:43,599 --> 00:49:48,829
scenario ring buffer given an in tearing

00:49:46,549 --> 00:49:51,079
buffer when more values in the capacity

00:49:48,829 --> 00:49:54,619
I did then the buffer wraps around in

00:49:51,079 --> 00:49:57,380
this capacity side stays at capacity and

00:49:54,619 --> 00:50:01,460
we ever hear these all here all of these

00:49:57,380 --> 00:50:06,049
routes through that scenario they're

00:50:01,460 --> 00:50:09,099
covered and this is human readable we

00:50:06,049 --> 00:50:11,269
can talk to someone maybe not technical

00:50:09,099 --> 00:50:13,789
maybe they'd have to be in this case but

00:50:11,269 --> 00:50:18,440
maybe I don't know C++ they don't have

00:50:13,789 --> 00:50:19,640
to look at the code to see the flow so I

00:50:18,440 --> 00:50:23,269
mean that's a really nice property of

00:50:19,640 --> 00:50:35,630
this but they're gonna have to get back

00:50:23,269 --> 00:50:41,989
to the slides to try wrap up back in a

00:50:35,630 --> 00:50:44,470
different username now okay skip over

00:50:41,989 --> 00:50:44,470
some things

00:50:52,100 --> 00:50:59,940
let's go through this part fairly

00:50:54,060 --> 00:51:03,240
quickly when the test files catch we'll

00:50:59,940 --> 00:51:05,490
try and convert all the types evolved

00:51:03,240 --> 00:51:06,720
into strings and a bit that I just

00:51:05,490 --> 00:51:09,900
skipped over which explained how the

00:51:06,720 --> 00:51:11,760
expression template works you would see

00:51:09,900 --> 00:51:14,490
where it calls catched your string in

00:51:11,760 --> 00:51:17,940
there to do that if it doesn't

00:51:14,490 --> 00:51:21,510
understand a custom type do you may see

00:51:17,940 --> 00:51:22,500
this in your output so it's worth seeing

00:51:21,510 --> 00:51:26,580
how we get around that

00:51:22,500 --> 00:51:28,560
so by default if your type supports the

00:51:26,580 --> 00:51:30,780
insertion operator overload for a string

00:51:28,560 --> 00:51:35,820
it will just work catch we'll find that

00:51:30,780 --> 00:51:38,670
and use it if it doesn't you can write

00:51:35,820 --> 00:51:40,950
an overload for catch to string in the

00:51:38,670 --> 00:51:44,670
catch namespace which just takes your

00:51:40,950 --> 00:51:47,310
type and returns a standard string and

00:51:44,670 --> 00:51:48,900
the new to work there are some

00:51:47,310 --> 00:51:52,760
cases where that's not quite enough

00:51:48,900 --> 00:51:52,760
usually involving specializations

00:51:56,630 --> 00:52:00,540
writing test code if you've got a no

00:51:58,830 --> 00:52:02,250
stream operator overloading in your

00:52:00,540 --> 00:52:06,390
production code we'll pick that up or

00:52:02,250 --> 00:52:08,580
you can write it just for tests yeah so

00:52:06,390 --> 00:52:10,680
some real cases usually involving a

00:52:08,580 --> 00:52:13,280
partial specialization you may have to

00:52:10,680 --> 00:52:15,510
drop to this string maker template class

00:52:13,280 --> 00:52:16,940
it's a bit more complex but works the

00:52:15,510 --> 00:52:20,460
same sit away you've got to convert

00:52:16,940 --> 00:52:24,210
static method there takes your type

00:52:20,460 --> 00:52:27,120
returns assign a string for all the

00:52:24,210 --> 00:52:28,290
primitive types and even standard

00:52:27,120 --> 00:52:31,320
library types like standard vector

00:52:28,290 --> 00:52:33,780
static map you can stand a tuple there's

00:52:31,320 --> 00:52:35,280
already overloads with cachtice string

00:52:33,780 --> 00:52:35,720
in catch you're gonna to worry about

00:52:35,280 --> 00:52:38,850
those

00:52:35,720 --> 00:52:42,180
so mostly just works it's worth keeping

00:52:38,850 --> 00:52:45,720
that in mind and then just to address a

00:52:42,180 --> 00:52:46,950
couple of the elephants in the room most

00:52:45,720 --> 00:52:50,340
common questions I get when I've given

00:52:46,950 --> 00:52:54,870
this talk before firstly what about

00:52:50,340 --> 00:52:57,550
threading cash doesn't have any

00:52:54,870 --> 00:53:00,550
awareness of frets

00:52:57,550 --> 00:53:03,400
the main problem is that it's targeted

00:53:00,550 --> 00:53:05,560
at C++ so free compilers and has no

00:53:03,400 --> 00:53:07,990
external dependencies it's the way I

00:53:05,560 --> 00:53:11,440
want to keep it so it's quite hard but a

00:53:07,990 --> 00:53:15,880
portable threading support in there the

00:53:11,440 --> 00:53:19,770
plan is to conditionally include support

00:53:15,880 --> 00:53:22,480
for C++ 11 compilers using the C++ 11

00:53:19,770 --> 00:53:23,859
reading primitives that's just not being

00:53:22,480 --> 00:53:26,680
done yet

00:53:23,859 --> 00:53:30,730
but that is coming and you ever elephant

00:53:26,680 --> 00:53:33,190
is what about mocks so cash doesn't have

00:53:30,730 --> 00:53:35,530
any built-in support for mocks mostly

00:53:33,190 --> 00:53:39,280
because I tend not to be a ma kissed

00:53:35,530 --> 00:53:40,960
if you don't mock objects are you know

00:53:39,280 --> 00:53:44,020
what a mock it is it's a different

00:53:40,960 --> 00:53:46,900
approach to testing but a lot of people

00:53:44,020 --> 00:53:48,430
find invaluable I get this a hath this a

00:53:46,900 --> 00:53:49,990
lot there's a couple of mocking

00:53:48,430 --> 00:53:52,410
frameworks that do work quite well we

00:53:49,990 --> 00:53:56,350
catch that I'm aware of one of them is

00:53:52,410 --> 00:53:58,450
hippo box there's a link to both of

00:53:56,350 --> 00:53:59,920
these at the end I think you have to do

00:53:58,450 --> 00:54:03,130
a little bit of integration code to get

00:53:59,920 --> 00:54:05,650
that to work the other one a fairly new

00:54:03,130 --> 00:54:07,270
framework called Trump Lee and the

00:54:05,650 --> 00:54:08,740
author of that was already aware of

00:54:07,270 --> 00:54:10,720
catch when he wrote it so you made sure

00:54:08,740 --> 00:54:12,160
it works well with it there was a little

00:54:10,720 --> 00:54:14,440
bit of integration code but he includes

00:54:12,160 --> 00:54:17,800
out on his github page and there's a

00:54:14,440 --> 00:54:20,170
link to that at the end other mocking

00:54:17,800 --> 00:54:33,670
frameworks may or may not work I don't

00:54:20,170 --> 00:54:36,670
know about those sorry so it works for

00:54:33,670 --> 00:54:38,380
C++ 11 and C++ 14 and there's a number

00:54:36,670 --> 00:54:41,290
of things in there already conditionally

00:54:38,380 --> 00:54:43,650
that I've had to do to to make it work

00:54:41,290 --> 00:54:46,210
say for example we've had a null pointer

00:54:43,650 --> 00:54:48,460
has to understand outer as a particular

00:54:46,210 --> 00:54:52,840
type and a certain things like you know

00:54:48,460 --> 00:54:55,090
the deprecation of auto pointer as I've

00:54:52,840 --> 00:54:56,859
had to use unique pointer in some things

00:54:55,090 --> 00:54:58,630
like that I've already had to do just to

00:54:56,859 --> 00:55:01,150
make you work but it turns I've actually

00:54:58,630 --> 00:55:02,859
using C++ 11 features relying on them

00:55:01,150 --> 00:55:06,340
there's nothing in there currently that

00:55:02,859 --> 00:55:08,640
relies in C++ 11 but I think that's

00:55:06,340 --> 00:55:11,130
worth changing for the writing support

00:55:08,640 --> 00:55:13,829
because that's quite a big thing if

00:55:11,130 --> 00:55:15,900
you're using it for pure unit tests that

00:55:13,829 --> 00:55:19,260
shouldn't matter because you shouldn't

00:55:15,900 --> 00:55:20,549
be doing threading in a unit test but

00:55:19,260 --> 00:55:23,400
I've deliberately tried not to call

00:55:20,549 --> 00:55:26,039
catch a unit test framework because you

00:55:23,400 --> 00:55:28,109
can use it for non unit tests particular

00:55:26,039 --> 00:55:29,660
integration tests what you do want to

00:55:28,109 --> 00:55:33,779
work in a multi-threaded environment

00:55:29,660 --> 00:55:37,079
what I currently do when I'm in my day

00:55:33,779 --> 00:55:41,099
job I use catch is I have to sort of

00:55:37,079 --> 00:55:44,519
store up all of my failures maybe in a

00:55:41,099 --> 00:55:46,500
TLS structure and then once I've joined

00:55:44,519 --> 00:55:48,779
my afraid so and then I assert on Ian's

00:55:46,500 --> 00:55:52,250
catch it's a bit of a clutch but it does

00:55:48,779 --> 00:55:57,480
work so I would like to get for support

00:55:52,250 --> 00:55:58,589
into catch if I've got time just to run

00:55:57,480 --> 00:56:01,760
through a couple of the other things

00:55:58,589 --> 00:56:04,829
that are hopefully coming and catch

00:56:01,760 --> 00:56:07,170
generators it's quite a big area it's

00:56:04,829 --> 00:56:09,000
been on my queue for a few years now but

00:56:07,170 --> 00:56:11,460
basically will give you a way of doing

00:56:09,000 --> 00:56:14,660
property based testing testing large

00:56:11,460 --> 00:56:19,589
ranges of values at once

00:56:14,660 --> 00:56:21,900
matches is in our area quite a big part

00:56:19,589 --> 00:56:25,410
I want to try and keep sort of off to

00:56:21,900 --> 00:56:28,410
the side more what do that thing but

00:56:25,410 --> 00:56:31,380
matches are basically a way of composing

00:56:28,410 --> 00:56:32,759
assertions writing customer surgeons for

00:56:31,380 --> 00:56:35,910
particular needs and composing them

00:56:32,759 --> 00:56:37,980
together so you can have the knot of an

00:56:35,910 --> 00:56:41,250
assertion and break them together

00:56:37,980 --> 00:56:43,410
weave ands and ORS it's quite powerful

00:56:41,250 --> 00:56:45,750
quite a powerful technique that needs

00:56:43,410 --> 00:56:48,019
some supporting catch and it's a

00:56:45,750 --> 00:56:52,380
prototypical version already in there

00:56:48,019 --> 00:56:55,980
you're finally possibility of changing

00:56:52,380 --> 00:56:57,900
the name reoccurring complaints over the

00:56:55,980 --> 00:57:00,119
years has been that catch is not a very

00:56:57,900 --> 00:57:04,230
searchable name in the context of

00:57:00,119 --> 00:57:09,750
particularly C++ search Stack Overflow

00:57:04,230 --> 00:57:11,519
per catch you'll see what I mean so I've

00:57:09,750 --> 00:57:13,289
been ignoring this for a few years but

00:57:11,519 --> 00:57:15,299
I've finally thought maybe it's a it's a

00:57:13,289 --> 00:57:17,640
real problem be looking at possibility

00:57:15,299 --> 00:57:19,380
of a new name my current favorite

00:57:17,640 --> 00:57:22,620
proposal is catfish

00:57:19,380 --> 00:57:23,850
so keeps a similar sort of acronym in

00:57:22,620 --> 00:57:26,030
there but let me know what you think

00:57:23,850 --> 00:57:33,600
about that afterwards

00:57:26,030 --> 00:57:36,270
so I think we can finish their top link

00:57:33,600 --> 00:57:40,230
is just redirects to the github page for

00:57:36,270 --> 00:57:42,780
catch my blog level of indirection calm

00:57:40,230 --> 00:57:44,670
you can also get there from extra lever

00:57:42,780 --> 00:57:48,000
don't indirection calm it just redirects

00:57:44,670 --> 00:57:50,270
I often talk about catch there and other

00:57:48,000 --> 00:57:52,620
things and those two mocking frameworks

00:57:50,270 --> 00:57:55,920
that I mentioned just a little while ago

00:57:52,620 --> 00:57:58,110
so sort of that will be the demo issues

00:57:55,920 --> 00:58:01,520
but they got there in the end

00:57:58,110 --> 00:58:01,520

YouTube URL: https://www.youtube.com/watch?v=gdzP3pAC6UI


