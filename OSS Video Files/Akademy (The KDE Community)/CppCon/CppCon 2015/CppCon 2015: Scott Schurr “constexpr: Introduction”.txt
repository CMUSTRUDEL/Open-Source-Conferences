Title: CppCon 2015: Scott Schurr “constexpr: Introduction”
Publication date: 2015-10-09
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
I'm excited about constexpr. It's probably my favorite C++11 feature and it's gotten even better with C++14. This talk will introduce constexpr to the uninitiated. We'll start with C++11 and continue into the improvements introduced with C++14. We'll look into useful ways to think about constexpr code. We'll also cover some tips and tricks with writing constexpr code.
— 
If you ask his children, they will tell you that Scott has been writing software since dinosaurs roamed the earth. In 1996 Scott learned C++ by working through the exercises in Stroustrup's TC++PL 2nd edition and he has never looked back. Scott is currently working at Ripple Labs developing open source crypto-financial software. When he's not writing code Scott plays the Chapman Stick, sings rock and roll, and spends time with his lovely wife.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,810
so my name's Scott sure you can call me

00:00:02,429 --> 00:00:09,389
Scott everybody hi Scott

00:00:05,810 --> 00:00:11,820
alright so we want this to be I I don't

00:00:09,389 --> 00:00:14,070
know about we I want this to be an

00:00:11,820 --> 00:00:15,839
interactive kind of a session we're in

00:00:14,070 --> 00:00:17,970
the middle of the afternoon we've all

00:00:15,839 --> 00:00:21,090
gone you know our brains are kind of

00:00:17,970 --> 00:00:24,689
wrung out if you have a question or an

00:00:21,090 --> 00:00:26,070
assertion get my attention I may not

00:00:24,689 --> 00:00:31,260
notice your right away you can throw

00:00:26,070 --> 00:00:33,030
things at me that's alright so let's

00:00:31,260 --> 00:00:36,059
don't save your questions for the end

00:00:33,030 --> 00:00:37,950
let's let's get them out if we don't get

00:00:36,059 --> 00:00:40,980
through all the slides that's okay the

00:00:37,950 --> 00:00:42,829
most important ones are at the front so

00:00:40,980 --> 00:00:45,180
don't worry about slowing things down

00:00:42,829 --> 00:00:46,559
especially you folks who are hesitant to

00:00:45,180 --> 00:00:48,719
hold up your hands and say I have a

00:00:46,559 --> 00:00:52,350
question I particularly want to hear

00:00:48,719 --> 00:00:56,190
from you and I have a way to reinforce

00:00:52,350 --> 00:00:58,410
that so everyone who asks a question or

00:00:56,190 --> 00:01:00,090
who helps me out I'm from Portland

00:00:58,410 --> 00:01:03,930
Oregon I like things that are

00:01:00,090 --> 00:01:05,580
biodegradable so this is about as

00:01:03,930 --> 00:01:10,200
biodegradable as it gets this is

00:01:05,580 --> 00:01:11,670
chocolate I work for a place called

00:01:10,200 --> 00:01:13,860
ripple labs they're based in San

00:01:11,670 --> 00:01:15,509
Francisco and strangely enough

00:01:13,860 --> 00:01:20,700
Ghirardelli chocolate comes from San

00:01:15,509 --> 00:01:23,960
Francisco so if you if if you help the

00:01:20,700 --> 00:01:26,220
the presentation by asking a question or

00:01:23,960 --> 00:01:29,040
correcting me if I'm wrong I'm not an

00:01:26,220 --> 00:01:32,189
expert I'm way open to to people saying

00:01:29,040 --> 00:01:35,490
hey that's not quite right you you get a

00:01:32,189 --> 00:01:37,710
reward I've got 80 of these I don't

00:01:35,490 --> 00:01:41,600
think I'll run out but it's possible so

00:01:37,710 --> 00:01:41,600
ask ask early and ask often

00:01:44,470 --> 00:01:49,960
so so I want to talk about contacts per

00:01:50,170 --> 00:01:54,110
so with our there are two parts oh

00:01:52,790 --> 00:02:03,649
there's a question you get chocolate

00:01:54,110 --> 00:02:10,069
right away what does Oh what does the

00:02:03,649 --> 00:02:11,330
loan well so I need to to pass this

00:02:10,069 --> 00:02:17,420
chocolate back can you pass that

00:02:11,330 --> 00:02:20,420
chocolate back Thanks so the concrete

00:02:17,420 --> 00:02:22,730
company I there there a number of

00:02:20,420 --> 00:02:26,209
pictures in here and most of them relate

00:02:22,730 --> 00:02:29,150
to concrete or stone or something like

00:02:26,209 --> 00:02:31,850
that and that's because and we'll get

00:02:29,150 --> 00:02:35,269
will get more into this context fur is

00:02:31,850 --> 00:02:37,850
all about finding values or things at

00:02:35,269 --> 00:02:40,430
compile time at least that's my take on

00:02:37,850 --> 00:02:43,519
it that's that's what I find to be

00:02:40,430 --> 00:02:46,160
valuable about context for context per

00:02:43,519 --> 00:02:48,320
is not only a compile time thing and

00:02:46,160 --> 00:02:51,500
we'll again we'll get into those details

00:02:48,320 --> 00:02:53,269
later on but the thing that I think is

00:02:51,500 --> 00:02:56,090
cool about it is what it allows you to

00:02:53,269 --> 00:02:58,130
do a compile time without having to do

00:02:56,090 --> 00:03:01,340
template metaprogramming which I have

00:02:58,130 --> 00:03:06,049
tried and I occasionally succeeded but

00:03:01,340 --> 00:03:08,560
but this is way easier in my opinion so

00:03:06,049 --> 00:03:16,700
let's get started

00:03:08,560 --> 00:03:20,739
more concrete so context for what an odd

00:03:16,700 --> 00:03:23,359
word why would someone use this word I

00:03:20,739 --> 00:03:25,370
think partly it was something that they

00:03:23,359 --> 00:03:28,040
could introduce into the language that

00:03:25,370 --> 00:03:29,450
nobody else had used yet because there's

00:03:28,040 --> 00:03:30,769
this problem with key words that you

00:03:29,450 --> 00:03:33,650
don't want to put in a key word that

00:03:30,769 --> 00:03:35,959
somebody else has already used so yeah

00:03:33,650 --> 00:03:38,510
it's a really odd word but it's kind of

00:03:35,959 --> 00:03:40,280
this oddball contraction of constant

00:03:38,510 --> 00:03:42,230
expression so that's what we're gonna

00:03:40,280 --> 00:03:47,870
end up talking about is constant

00:03:42,230 --> 00:03:49,840
expressions Const exper allows you to

00:03:47,870 --> 00:03:52,099
evaluate expressions at compile time

00:03:49,840 --> 00:03:55,040
it's kind of like template

00:03:52,099 --> 00:03:58,209
metaprogramming but it uses a familiar

00:03:55,040 --> 00:03:58,209
C++ syntax

00:03:58,610 --> 00:04:03,620
so it's easier to maintain you don't

00:04:00,980 --> 00:04:05,780
have to be a freakin expert in order to

00:04:03,620 --> 00:04:08,240
figure this stuff out a lot of it reads

00:04:05,780 --> 00:04:11,480
like well depending on whether you're

00:04:08,240 --> 00:04:15,500
dealing with C++ 11 or C++ 14 it's

00:04:11,480 --> 00:04:19,100
pretty much standard C++ code which is

00:04:15,500 --> 00:04:21,799
something I think is is really nifty it

00:04:19,100 --> 00:04:25,690
only produces constant values so this is

00:04:21,799 --> 00:04:28,910
stuff that you know once it's produced

00:04:25,690 --> 00:04:34,970
it's done it's not moving it's not

00:04:28,910 --> 00:04:39,950
changing so like I said it can't change

00:04:34,970 --> 00:04:43,640
at runtime so why is that interesting

00:04:39,950 --> 00:04:46,340
who cares used but actually one of the

00:04:43,640 --> 00:04:48,830
motivations for this talk was I got

00:04:46,340 --> 00:04:51,170
excited about cost expert and I walk up

00:04:48,830 --> 00:04:55,220
to programmers like I always do in a bus

00:04:51,170 --> 00:04:56,570
station or whatever and say you know let

00:04:55,220 --> 00:04:59,420
me tell you about context per and they

00:04:56,570 --> 00:05:01,580
say well if you're doing all this stuff

00:04:59,420 --> 00:05:03,980
a compile time well what what's the good

00:05:01,580 --> 00:05:07,100
of that what's useful that you can do a

00:05:03,980 --> 00:05:08,480
compile time it turns out in my opinion

00:05:07,100 --> 00:05:10,669
there are a lot of things you can do a

00:05:08,480 --> 00:05:12,350
compile time that are pretty useful some

00:05:10,669 --> 00:05:14,120
of that is because of my background as

00:05:12,350 --> 00:05:15,560
an embedded developer I did about it

00:05:14,120 --> 00:05:17,419
embedded developing for quite a number

00:05:15,560 --> 00:05:20,540
of years and the more stuff you can do

00:05:17,419 --> 00:05:22,190
ahead the less you know the the errors

00:05:20,540 --> 00:05:24,080
are caught early the errors are caught a

00:05:22,190 --> 00:05:28,310
compile time just the very best possible

00:05:24,080 --> 00:05:29,960
time your footprint is smaller and

00:05:28,310 --> 00:05:32,419
probably I'm getting way ahead of my

00:05:29,960 --> 00:05:36,530
yeah all right so no you know run time

00:05:32,419 --> 00:05:38,660
cost there's when that value is already

00:05:36,530 --> 00:05:40,610
present in your image you're not

00:05:38,660 --> 00:05:45,020
computing it at runtime your compiler

00:05:40,610 --> 00:05:46,940
did that work for you you've reduced

00:05:45,020 --> 00:05:48,860
your executable footprint which most

00:05:46,940 --> 00:05:50,720
people don't care about but if you're

00:05:48,860 --> 00:05:53,000
doing embedded development or a

00:05:50,720 --> 00:05:57,470
constrained platform this can make a big

00:05:53,000 --> 00:06:00,470
difference and probably the most

00:05:57,470 --> 00:06:02,150
important part is whenever you can you

00:06:00,470 --> 00:06:04,460
know I'm and I'm not saying Const X

00:06:02,150 --> 00:06:06,860
first solves all problems Const X bar is

00:06:04,460 --> 00:06:09,350
a very specific kind of a thing you

00:06:06,860 --> 00:06:10,340
can't do everything at compile time for

00:06:09,350 --> 00:06:12,500
most problems

00:06:10,340 --> 00:06:13,760
that's fine I understand that but there

00:06:12,500 --> 00:06:17,960
are things that you can do a

00:06:13,760 --> 00:06:21,170
compile-time and if you can my position

00:06:17,960 --> 00:06:23,330
is that you should so the things that

00:06:21,170 --> 00:06:25,220
you can find a compile-time you're way

00:06:23,330 --> 00:06:27,590
ahead if you can find those errors if

00:06:25,220 --> 00:06:29,270
you can find you know whatever the

00:06:27,590 --> 00:06:32,330
problem is if you can find that at

00:06:29,270 --> 00:06:35,210
compile time you just made a big win

00:06:32,330 --> 00:06:36,860
because the compiler you know runtime

00:06:35,210 --> 00:06:39,530
errors you have to actually execute the

00:06:36,860 --> 00:06:41,990
code before the error happens the

00:06:39,530 --> 00:06:45,710
compiler walks all of your code every

00:06:41,990 --> 00:06:48,560
time you compile so even an error in an

00:06:45,710 --> 00:06:51,740
oddball little corner the compiler will

00:06:48,560 --> 00:06:53,990
find that so you've nailed that you

00:06:51,740 --> 00:06:59,540
don't have to rely on your unit tests

00:06:53,990 --> 00:07:02,930
getting into the odd corners you don't

00:06:59,540 --> 00:07:05,870
have synchronization concerns this is

00:07:02,930 --> 00:07:09,920
sort of a set up for my talk tomorrow

00:07:05,870 --> 00:07:13,400
which I hope some of you will attend but

00:07:09,920 --> 00:07:15,530
if you build containers at runtime and

00:07:13,400 --> 00:07:17,450
you happen to know what all of those

00:07:15,530 --> 00:07:20,210
values are going to be then there's

00:07:17,450 --> 00:07:21,860
often a synchronization problem as you

00:07:20,210 --> 00:07:23,860
build that container if it contains a

00:07:21,860 --> 00:07:27,080
vector or whatever if there's a race

00:07:23,860 --> 00:07:29,930
folks getting into that container then

00:07:27,080 --> 00:07:31,670
you have to do all the synchronization

00:07:29,930 --> 00:07:34,490
work you have to do your threads and

00:07:31,670 --> 00:07:37,550
locking and all that business and why

00:07:34,490 --> 00:07:40,190
bother with that if you don't need to so

00:07:37,550 --> 00:07:42,620
if you have a constant container make it

00:07:40,190 --> 00:07:45,170
a constant expert constant container and

00:07:42,620 --> 00:07:48,260
now you don't have any races dealing

00:07:45,170 --> 00:07:50,350
with that container and we'll talk more

00:07:48,260 --> 00:07:53,930
about that tomorrow

00:07:50,350 --> 00:07:59,330
so Const expert is a new keyword it was

00:07:53,930 --> 00:08:03,380
introduced in C++ 11 see if I can stop

00:07:59,330 --> 00:08:08,060
getting ahead of myself so the keyword

00:08:03,380 --> 00:08:11,300
is applied in two different cases one is

00:08:08,060 --> 00:08:16,100
when you're declaring a value or an

00:08:11,300 --> 00:08:20,390
object and in that case you say Const X

00:08:16,100 --> 00:08:24,759
/ int or whatever and that says that

00:08:20,390 --> 00:08:26,929
it's going to be a literal type

00:08:24,759 --> 00:08:29,689
the other thing you can do is you can

00:08:26,929 --> 00:08:34,459
use that constant expert keyword for

00:08:29,689 --> 00:08:36,289
declaring functions and constructors so

00:08:34,459 --> 00:08:37,939
those are the two situations where the

00:08:36,289 --> 00:08:40,939
context per keyword is going to play

00:08:37,939 --> 00:08:42,409
into what you're up to and where you're

00:08:40,939 --> 00:08:47,839
going to want to drop that context for

00:08:42,409 --> 00:08:51,819
keyword in so the place we're going to

00:08:47,839 --> 00:08:55,040
spend most of our attention is on

00:08:51,819 --> 00:08:57,259
context / functions later on but

00:08:55,040 --> 00:09:02,959
probably the more important part is the

00:08:57,259 --> 00:09:06,199
context / values so we can make contexts

00:09:02,959 --> 00:09:11,600
for values it's easier if I look over

00:09:06,199 --> 00:09:13,730
here so here we've declared a number of

00:09:11,600 --> 00:09:17,810
these values now there's an interesting

00:09:13,730 --> 00:09:20,829
aspect to this slide every single one of

00:09:17,810 --> 00:09:23,389
those asserts is a static assert that

00:09:20,829 --> 00:09:25,730
means that every one of those checks is

00:09:23,389 --> 00:09:27,949
happening at compile time and if the

00:09:25,730 --> 00:09:30,980
compiler is not happy with the result it

00:09:27,949 --> 00:09:33,199
will stop you at compile time if there's

00:09:30,980 --> 00:09:35,269
a problem it will not get into

00:09:33,199 --> 00:09:39,670
production you won't even finish

00:09:35,269 --> 00:09:39,670
compiling you won't get an object file

00:09:39,879 --> 00:09:46,399
so even though we're going to be talking

00:09:42,680 --> 00:09:48,829
about context / code a lot it's the

00:09:46,399 --> 00:09:51,319
context for keyword on the value that's

00:09:48,829 --> 00:09:54,430
the most important part that's what's

00:09:51,319 --> 00:09:54,430
going to stop you yes

00:10:04,050 --> 00:10:08,680
yeah so the question is what's the

00:10:06,610 --> 00:10:11,709
difference between the contacts print

00:10:08,680 --> 00:10:13,540
and saying static constant and and at

00:10:11,709 --> 00:10:16,000
this point you know that's it's

00:10:13,540 --> 00:10:17,740
basically interchangeable as we get to

00:10:16,000 --> 00:10:23,889
something that's more complicated in an

00:10:17,740 --> 00:10:26,529
INT and you get some chocolate can you

00:10:23,889 --> 00:10:29,800
pass this back okay dude if I throw it I

00:10:26,529 --> 00:10:31,810
may hit you all right okay it's

00:10:29,800 --> 00:10:36,819
dangerous I hit somebody in the face

00:10:31,810 --> 00:10:39,189
with some skittles ones so yeah we're

00:10:36,819 --> 00:10:42,279
we're dealing with with an INT a static

00:10:39,189 --> 00:10:45,339
constant would work great as the object

00:10:42,279 --> 00:10:46,779
types get more interesting than like as

00:10:45,339 --> 00:10:48,790
a matter of fact if you get to a

00:10:46,779 --> 00:10:51,459
floating point type you can't do that

00:10:48,790 --> 00:11:01,839
and context for an float get along just

00:10:51,459 --> 00:11:04,089
great so yeah well so the reason I did

00:11:01,839 --> 00:11:06,819
double is because as we were talking

00:11:04,089 --> 00:11:09,160
about in earlier you can do static

00:11:06,819 --> 00:11:11,139
constant if you do a static haunts

00:11:09,160 --> 00:11:14,410
double that's not something that you can

00:11:11,139 --> 00:11:16,600
operate on a compile time so these are

00:11:14,410 --> 00:11:19,089
all you know the double in particular

00:11:16,600 --> 00:11:20,560
any of the floating point types the

00:11:19,089 --> 00:11:23,259
compiler will know about those and you

00:11:20,560 --> 00:11:30,310
can do static asserts on cons to expert

00:11:23,259 --> 00:11:37,930
doubles which you could not do it yeah

00:11:30,310 --> 00:11:39,339
just fun chocolate and I'm gonna have to

00:11:37,930 --> 00:11:46,899
develop my throwing arm if I start

00:11:39,339 --> 00:11:51,850
getting questions from the back so those

00:11:46,899 --> 00:11:54,579
are all data types that are at namespace

00:11:51,850 --> 00:12:00,939
scope you can also put stuff inside of a

00:11:54,579 --> 00:12:06,100
function that at PI in the function so

00:12:00,939 --> 00:12:08,250
that's worth thinking about if you have

00:12:06,100 --> 00:12:14,350
how many of you have heard the phrase

00:12:08,250 --> 00:12:19,630
magic statics yeah okay okay so it sits

00:12:14,350 --> 00:12:21,490
around so I'm not gonna spend a whole

00:12:19,630 --> 00:12:23,740
lot of time talking about this but the

00:12:21,490 --> 00:12:27,130
fact that that context per PI now you

00:12:23,740 --> 00:12:29,290
know that's a constant but but if that

00:12:27,130 --> 00:12:33,009
were being computed with a context per

00:12:29,290 --> 00:12:35,679
function when you walk into the function

00:12:33,009 --> 00:12:39,839
see the the compilers job is to make

00:12:35,679 --> 00:12:44,259
sure that that value is initialized

00:12:39,839 --> 00:12:47,079
before the function executes and that

00:12:44,259 --> 00:12:50,860
means it has as long as it gets

00:12:47,079 --> 00:12:52,600
initialized it can it doesn't matter so

00:12:50,860 --> 00:12:57,490
oftentimes there are if you have a

00:12:52,600 --> 00:13:00,089
function that has you know is used in a

00:12:57,490 --> 00:13:03,939
multi-threaded situation there have

00:13:00,089 --> 00:13:05,709
previously before C++ 11 or 14 or

00:13:03,939 --> 00:13:07,509
something like that there were race

00:13:05,709 --> 00:13:09,790
conditions where you could have a

00:13:07,509 --> 00:13:11,709
function where you to enter into the

00:13:09,790 --> 00:13:13,269
function the static variable hadn't been

00:13:11,709 --> 00:13:16,230
initialized yet it would start

00:13:13,269 --> 00:13:18,939
initializing somebody else would race in

00:13:16,230 --> 00:13:20,439
with and and now that's all being

00:13:18,939 --> 00:13:22,120
protected you know if you're using a

00:13:20,439 --> 00:13:24,370
modern compiler the compilers are

00:13:22,120 --> 00:13:25,420
effectively doing locks in order to

00:13:24,370 --> 00:13:28,779
prevent that from happening

00:13:25,420 --> 00:13:31,029
well if you do it with context / nobody

00:13:28,779 --> 00:13:34,000
needs a lock because the values

00:13:31,029 --> 00:13:38,699
determined at compile time it's all set

00:13:34,000 --> 00:13:38,699
to go yes

00:13:48,840 --> 00:13:55,440
yeah yeah so so the question was what's

00:13:53,320 --> 00:13:58,600
the advantage of contacts / versus

00:13:55,440 --> 00:14:01,630
static Const and and in this particular

00:13:58,600 --> 00:14:03,700
case because it's a it's a

00:14:01,630 --> 00:14:06,910
floating-point number we can initialize

00:14:03,700 --> 00:14:10,200
that very easily so it's it's no value

00:14:06,910 --> 00:14:27,970
yet let's wait until we compute a value

00:14:10,200 --> 00:14:33,040
and hey good catch yeah so the so the

00:14:27,970 --> 00:14:49,720
question is is is is there not let's see

00:14:33,040 --> 00:14:51,730
if I can well okay yeah but yeah so

00:14:49,720 --> 00:14:57,610
let's let's not let's not deal with with

00:14:51,730 --> 00:14:59,860
with a macro but I one of one of the

00:14:57,610 --> 00:15:01,630
things that will happen if if this were

00:14:59,860 --> 00:15:03,970
a more complicated expression than just

00:15:01,630 --> 00:15:07,990
dropping a floating-point value in there

00:15:03,970 --> 00:15:11,350
and here's your chocolate is that that

00:15:07,990 --> 00:15:12,820
flag to see whether something needs to

00:15:11,350 --> 00:15:14,830
be initialized a there's that race

00:15:12,820 --> 00:15:18,850
condition when you first enter secondly

00:15:14,830 --> 00:15:20,500
there is a very very small cost to

00:15:18,850 --> 00:15:22,690
entering the function every time you

00:15:20,500 --> 00:15:24,580
enter the function because it has to see

00:15:22,690 --> 00:15:28,180
whether that value was initialized or

00:15:24,580 --> 00:15:30,550
not so in the case of a context / value

00:15:28,180 --> 00:15:34,300
it knows that was initialized it was

00:15:30,550 --> 00:15:37,660
initialized at compile time so that test

00:15:34,300 --> 00:15:41,220
of the flag has now gone away so there's

00:15:37,660 --> 00:15:41,220
yeah so there is value

00:15:51,420 --> 00:15:56,140
yeah I didn't think his his question was

00:15:54,399 --> 00:15:58,720
about macros I thought his was about

00:15:56,140 --> 00:16:02,470
like static answer or whatever so yeah

00:15:58,720 --> 00:16:04,600
anyway so we great questions thank you

00:16:02,470 --> 00:16:05,829
very much appreciate that we need to get

00:16:04,600 --> 00:16:13,110
more in the back so I can develop my

00:16:05,829 --> 00:16:18,880
throwing arm so you can you can also

00:16:13,110 --> 00:16:22,029
declare static data members of literal

00:16:18,880 --> 00:16:24,160
types inside of a struct so those are

00:16:22,029 --> 00:16:30,300
basically or your options of where you

00:16:24,160 --> 00:16:46,480
can where you can use contacts book so

00:16:30,300 --> 00:16:52,029
yes in the struct the let's see will get

00:16:46,480 --> 00:16:56,680
there this is the question so inside of

00:16:52,029 --> 00:17:00,550
the struct that has to be static because

00:16:56,680 --> 00:17:04,720
it's going to be constant so it's true

00:17:00,550 --> 00:17:06,910
for all instances of that struct so you

00:17:04,720 --> 00:17:11,919
can't have a non-static member that's

00:17:06,910 --> 00:17:13,420
also Const expert okay and you get

00:17:11,919 --> 00:17:38,440
chocolate

00:17:13,420 --> 00:17:40,960
Oh iris more chocolate coming let's get

00:17:38,440 --> 00:17:44,800
to some of those questions later on okay

00:17:40,960 --> 00:17:52,090
but I I want to reinforce the questions

00:17:44,800 --> 00:18:01,320
I almost made it I'll make it gonna make

00:17:52,090 --> 00:18:05,770
you change chase that chocolate so so

00:18:01,320 --> 00:18:08,050
values can be any literal type that's

00:18:05,770 --> 00:18:12,610
including floating-point types character

00:18:08,050 --> 00:18:15,340
literals pointer literals objects and

00:18:12,610 --> 00:18:18,130
we'll get to how to declare an object so

00:18:15,340 --> 00:18:22,450
that a pretty much any type so that it

00:18:18,130 --> 00:18:25,000
can be taken as a literal they require

00:18:22,450 --> 00:18:26,620
no storage declaration so a lot of these

00:18:25,000 --> 00:18:28,810
things you have to if you if you had a

00:18:26,620 --> 00:18:31,270
static and the struct for example you

00:18:28,810 --> 00:18:32,740
have to declare the static in the struct

00:18:31,270 --> 00:18:34,690
and then you have to declare storage for

00:18:32,740 --> 00:18:36,940
at some place in the CPP file typically

00:18:34,690 --> 00:18:38,500
you don't have to do that with context

00:18:36,940 --> 00:18:45,730
where the compiler takes care of it for

00:18:38,500 --> 00:18:50,380
you and it's not okay to have context

00:18:45,730 --> 00:18:51,850
for parameters on a function don't ask

00:18:50,380 --> 00:18:53,680
me why I'm not part of the Standards

00:18:51,850 --> 00:18:55,600
Committee I'm sure they had great

00:18:53,680 --> 00:18:58,420
reasons but and if you try to do this

00:18:55,600 --> 00:19:00,430
the compiler will stop you so don't

00:18:58,420 --> 00:19:07,810
worry about it the compiler will let you

00:19:00,430 --> 00:19:10,300
know so how do you use these things you

00:19:07,810 --> 00:19:13,990
can use them anywhere a literals could

00:19:10,300 --> 00:19:16,810
be used so you can use them as template

00:19:13,990 --> 00:19:19,870
parameters non-type template parameters

00:19:16,810 --> 00:19:22,600
you can use them to determine the

00:19:19,870 --> 00:19:24,760
dimensions of an array you can use them

00:19:22,600 --> 00:19:26,190
for enumeration initialization and you

00:19:24,760 --> 00:19:29,820
can use them in standard run

00:19:26,190 --> 00:19:32,669
I'm code so the compiler really knows

00:19:29,820 --> 00:19:34,379
the value you know that's if you think

00:19:32,669 --> 00:19:36,929
about how templates get instantiated

00:19:34,379 --> 00:19:40,470
there's a bunch of thrashing about and

00:19:36,929 --> 00:19:47,639
so you know by the compiler so it knows

00:19:40,470 --> 00:19:49,590
the value they are implicitly Const so

00:19:47,639 --> 00:19:51,600
the values that this is different from

00:19:49,590 --> 00:19:53,279
you know we'll get to the code later on

00:19:51,600 --> 00:19:55,860
and then the code gets a little blurry

00:19:53,279 --> 00:19:59,009
about the constants but here on the

00:19:55,860 --> 00:20:01,620
value they are implicitly Const you

00:19:59,009 --> 00:20:05,340
can't change them if you cast away the

00:20:01,620 --> 00:20:07,740
Const the compiler will let you do this

00:20:05,340 --> 00:20:09,809
Marshalls not in here Marshall has this

00:20:07,740 --> 00:20:12,960
great talk about what happens when you

00:20:09,809 --> 00:20:16,080
get undefined behavior the way I like to

00:20:12,960 --> 00:20:18,330
do it to talk about it is that if if you

00:20:16,080 --> 00:20:20,759
set up a situation for undefined

00:20:18,330 --> 00:20:22,799
behavior you're now allowing your cat

00:20:20,759 --> 00:20:29,120
the compiler to make your cat have

00:20:22,799 --> 00:20:32,340
puppies and you may not even have a cat

00:20:29,120 --> 00:20:45,870
so so undefined behavior is a very

00:20:32,340 --> 00:20:48,000
dangerous place to go yes you'd have to

00:20:45,870 --> 00:20:50,100
so the question was is it ok to cast

00:20:48,000 --> 00:20:53,490
away the cost and then not modify the

00:20:50,100 --> 00:20:55,889
value you'd have to talk to a compiler

00:20:53,490 --> 00:21:00,179
guy I prefer not to tread in those areas

00:20:55,889 --> 00:21:03,769
myself because compiler has this nasty

00:21:00,179 --> 00:21:03,769
way of biting me when I'm not watching

00:21:05,899 --> 00:21:11,779
so yeah so thank you

00:21:11,920 --> 00:21:26,720
so so we've talked about values now oh

00:21:15,620 --> 00:21:30,680
okay I'm just sorry okay so one of the

00:21:26,720 --> 00:21:33,200
experts just said that that the question

00:21:30,680 --> 00:21:36,290
was if you if you cast away the

00:21:33,200 --> 00:21:38,360
countenance of a Const exper value the

00:21:36,290 --> 00:21:40,520
question was it can you constant cast

00:21:38,360 --> 00:21:43,070
away the cost but not modify it and get

00:21:40,520 --> 00:21:45,580
away with it and the expert says it's

00:21:43,070 --> 00:21:49,160
okay as long as you don't touch it

00:21:45,580 --> 00:21:51,350
so but my suggestion would be don't cast

00:21:49,160 --> 00:21:53,180
it away so that the compiler will stop

00:21:51,350 --> 00:21:59,660
you if you do by accident touch it once

00:21:53,180 --> 00:22:00,920
you've cast it away so we're gonna spend

00:21:59,660 --> 00:22:04,490
most of our time talking about the

00:22:00,920 --> 00:22:08,690
computations oh and chocolate yeah I

00:22:04,490 --> 00:22:10,340
can't yeah that but but he brought value

00:22:08,690 --> 00:22:12,130
no I can't throw it that far someone's

00:22:10,340 --> 00:22:23,630
gonna have to pass it back we'll do a

00:22:12,130 --> 00:22:27,860
bucket brigade across so computations so

00:22:23,630 --> 00:22:30,590
you can declare free functions member

00:22:27,860 --> 00:22:36,320
functions and constructors as const

00:22:30,590 --> 00:22:39,410
expert the code that's once you once you

00:22:36,320 --> 00:22:41,960
put that contacts for declaration on

00:22:39,410 --> 00:22:43,580
that function or constructor the code

00:22:41,960 --> 00:22:46,340
that the compiler will allow you to put

00:22:43,580 --> 00:22:50,150
inside there becomes more constrained

00:22:46,340 --> 00:22:53,060
you can't put just any code inside of a

00:22:50,150 --> 00:22:59,330
function or constructor you have to

00:22:53,060 --> 00:23:02,210
follow the rules the the rules in C++ 11

00:22:59,330 --> 00:23:07,150
are pretty highly constrained its but

00:23:02,210 --> 00:23:12,740
it's the cool thing is it's still C++ in

00:23:07,150 --> 00:23:16,190
C++ 14 there were some folks who went to

00:23:12,740 --> 00:23:19,760
some heroic efforts to allow a lot of

00:23:16,190 --> 00:23:24,260
very cool stuff to be inside of the code

00:23:19,760 --> 00:23:24,650
and we'll see some examples of that so

00:23:24,260 --> 00:23:27,110
it's

00:23:24,650 --> 00:23:31,420
the context for constructor that allows

00:23:27,110 --> 00:23:33,710
you to make a user-defined literal type

00:23:31,420 --> 00:23:35,900
that's a little bit counterintuitive

00:23:33,710 --> 00:23:36,980
when you first hear about context

00:23:35,900 --> 00:23:40,430
borough there are people who want to

00:23:36,980 --> 00:23:42,200
declare context per classes so you want

00:23:40,430 --> 00:23:44,390
to put that context per class whatever

00:23:42,200 --> 00:23:46,940
that's not the way you do it the way you

00:23:44,390 --> 00:23:49,160
do it is you take one or more of the

00:23:46,940 --> 00:23:53,420
Constructors for that class so you can

00:23:49,160 --> 00:23:55,940
have a class that has one context per

00:23:53,420 --> 00:23:58,430
constructor and other non cons to expert

00:23:55,940 --> 00:24:00,890
constructors and if you use that context

00:23:58,430 --> 00:24:02,780
for constructor you can get a context

00:24:00,890 --> 00:24:09,200
for literal out of that write a constant

00:24:02,780 --> 00:24:13,250
literal out of that so if you put Const

00:24:09,200 --> 00:24:15,380
x4 on the front then that allows the

00:24:13,250 --> 00:24:18,200
compiler to produce the value from that

00:24:15,380 --> 00:24:21,860
computation at compile time and that's

00:24:18,200 --> 00:24:25,720
the cool part again just to reiterate

00:24:21,860 --> 00:24:27,800
quickly why would you want to do that

00:24:25,720 --> 00:24:30,200
because you can reduce your runtime

00:24:27,800 --> 00:24:32,540
execution time you can reduce the

00:24:30,200 --> 00:24:34,640
program footprint because no longer have

00:24:32,540 --> 00:24:38,540
to include the code that produces the

00:24:34,640 --> 00:24:43,070
value you're catching errors at compiler

00:24:38,540 --> 00:24:46,010
length time and fortunately for me

00:24:43,070 --> 00:24:46,490
neither herb sutter nor andre are in

00:24:46,010 --> 00:24:49,250
here

00:24:46,490 --> 00:24:55,130
but i I think this is probably one of

00:24:49,250 --> 00:24:57,860
their top quotes for me so there was

00:24:55,130 --> 00:25:00,290
this interesting word that I used in a

00:24:57,860 --> 00:25:06,110
previous slide about allowed to be

00:25:00,290 --> 00:25:09,140
computed at compile time so what what

00:25:06,110 --> 00:25:12,560
does that really mean well okay if you

00:25:09,140 --> 00:25:17,180
have a Const exper function that can run

00:25:12,560 --> 00:25:20,000
at compile time it can also run at

00:25:17,180 --> 00:25:23,060
runtime so let's let's look at an

00:25:20,000 --> 00:25:27,080
example of that so here's here's our

00:25:23,060 --> 00:25:29,660
very first constitu expert function what

00:25:27,080 --> 00:25:33,020
it does is it takes in a value divides

00:25:29,660 --> 00:25:35,330
it in two and returns the value it's not

00:25:33,020 --> 00:25:38,190
a very interesting function but you know

00:25:35,330 --> 00:25:43,450
you have to start someplace

00:25:38,190 --> 00:25:46,990
so we can call that function and put the

00:25:43,450 --> 00:25:49,720
result of that call into a context for

00:25:46,990 --> 00:25:51,610
value that we're gonna call half and now

00:25:49,720 --> 00:25:55,720
we can do a static assert on that value

00:25:51,610 --> 00:25:58,900
that same function because it's it's

00:25:55,720 --> 00:26:04,540
just standard C++ nothing funny about

00:25:58,900 --> 00:26:06,580
that code we can call that same function

00:26:04,540 --> 00:26:09,460
at runtime with a value that the

00:26:06,580 --> 00:26:11,590
compiler has no idea what the value is

00:26:09,460 --> 00:26:13,090
going to be okay so we're going to wait

00:26:11,590 --> 00:26:14,860
until runtime we're going to get the

00:26:13,090 --> 00:26:17,500
value in our hand because somebody hit

00:26:14,860 --> 00:26:19,780
that keyboard we're gonna divide it in

00:26:17,500 --> 00:26:21,910
half now we can't do the static assert I

00:26:19,780 --> 00:26:24,190
hope it's clear to everybody why you

00:26:21,910 --> 00:26:26,800
can't do the static assert on a value

00:26:24,190 --> 00:26:29,410
you don't know until runtime but the

00:26:26,800 --> 00:26:32,200
compiler will keep track of that

00:26:29,410 --> 00:26:38,380
difference and part of how it does that

00:26:32,200 --> 00:26:43,360
is by whether the value of run is not

00:26:38,380 --> 00:26:46,000
declared cost expert it's just cost but

00:26:43,360 --> 00:27:01,450
the value of half further up the slide

00:26:46,000 --> 00:27:04,630
that's a Const extra value yes/no auto

00:27:01,450 --> 00:27:08,050
will not so the question the question

00:27:04,630 --> 00:27:09,670
was will auto figure out that the value

00:27:08,050 --> 00:27:12,040
that's being returned his context for

00:27:09,670 --> 00:27:17,020
and the answer is know that even though

00:27:12,040 --> 00:27:20,200
you call a a context per function the

00:27:17,020 --> 00:27:22,390
general inclination of the compiler will

00:27:20,200 --> 00:27:26,620
be to not produce context for values

00:27:22,390 --> 00:27:30,120
unless you demand it so make a point of

00:27:26,620 --> 00:27:30,120
demanding it as often as you can

00:27:31,749 --> 00:27:42,159
that's uh see if I can I will try Oh

00:27:38,559 --> 00:27:42,159
almost got it

00:27:42,909 --> 00:28:02,419
Beeman yeah so Beeman asked is there a

00:27:55,190 --> 00:28:07,220
way to poison well half of and the

00:28:02,419 --> 00:28:07,999
answer is yes mostly and we'll get to

00:28:07,220 --> 00:28:10,490
that later on

00:28:07,999 --> 00:28:13,190
that's something yeah and and thank you

00:28:10,490 --> 00:28:14,629
for that setup yeah we're gonna have to

00:28:13,190 --> 00:28:20,470
bucket-brigade the chocolate back on

00:28:14,629 --> 00:28:30,049
this one here so this is going back

00:28:20,470 --> 00:28:53,529
question could you speak up and try it

00:28:30,049 --> 00:28:56,179
again so I think the question is whether

00:28:53,529 --> 00:29:01,850
any of the stuff that we're seeing here

00:28:56,179 --> 00:29:06,049
is going to prevent the the return value

00:29:01,850 --> 00:29:10,429
optimization from from working and if

00:29:06,049 --> 00:29:12,080
you declare a constant value then

00:29:10,429 --> 00:29:14,990
nothing at runtime

00:29:12,080 --> 00:29:20,629
nothing gets returned it's already there

00:29:14,990 --> 00:29:26,659
so there's so you're better off than you

00:29:20,629 --> 00:29:29,619
would be if if you had the the return

00:29:26,659 --> 00:29:29,619
value optimization

00:29:38,780 --> 00:29:45,570
so the the way the way a function

00:29:43,380 --> 00:29:47,940
supports okay

00:29:45,570 --> 00:29:49,650
so I'm being advised to move on we are

00:29:47,940 --> 00:29:51,750
at that would take us off track I was

00:29:49,650 --> 00:29:58,559
about to go on the on some other stuff

00:29:51,750 --> 00:30:01,950
which I don't need to thank you okay so

00:29:58,559 --> 00:30:06,360
we have con sex for evaluation it may be

00:30:01,950 --> 00:30:09,809
at run time to force that translation

00:30:06,360 --> 00:30:11,640
happen at or that that evaluation that

00:30:09,809 --> 00:30:13,919
happened during translation there are

00:30:11,640 --> 00:30:16,559
two ways within the standard to do that

00:30:13,919 --> 00:30:20,100
one is to declare the value that

00:30:16,559 --> 00:30:23,070
receives and it's going slower than I

00:30:20,100 --> 00:30:25,950
thought the the value that receives it

00:30:23,070 --> 00:30:27,660
as Const expert that's my favorite way

00:30:25,950 --> 00:30:29,190
to do it because if you look at it you

00:30:27,660 --> 00:30:31,610
can see what's going on and you know

00:30:29,190 --> 00:30:34,350
that the compiler is gonna put it there

00:30:31,610 --> 00:30:36,750
the next one is to use it where a

00:30:34,350 --> 00:30:38,340
literal is required by the compiler and

00:30:36,750 --> 00:30:40,260
this means that you have to be a little

00:30:38,340 --> 00:30:43,470
bit more aware of you know when does the

00:30:40,260 --> 00:30:45,120
compiler have to know this for array

00:30:43,470 --> 00:30:46,559
boundaries this is pretty obvious if

00:30:45,120 --> 00:30:48,059
you're using it for a template parameter

00:30:46,559 --> 00:30:49,590
this is pretty obvious there are some

00:30:48,059 --> 00:30:52,559
other places where it's not quite as

00:30:49,590 --> 00:30:54,990
obvious but if the compiler says I have

00:30:52,559 --> 00:31:12,330
to know this value now it will insist on

00:30:54,990 --> 00:31:16,470
it the context for yes yes so the

00:31:12,330 --> 00:31:18,809
question is does the constant context

00:31:16,470 --> 00:31:22,490
for constructor worked the same way and

00:31:18,809 --> 00:31:24,990
the answer is yes that if you have a an

00:31:22,490 --> 00:31:27,750
object with a context for constructor

00:31:24,990 --> 00:31:30,179
and the value that is being constructed

00:31:27,750 --> 00:31:32,040
is declared as context where it will be

00:31:30,179 --> 00:31:33,450
determined at compile time or the

00:31:32,040 --> 00:31:37,410
compiler will tell you it can't

00:31:33,450 --> 00:31:39,270
determine it so you either get a valid

00:31:37,410 --> 00:31:43,020
value out of it or you get a compiler

00:31:39,270 --> 00:31:45,230
error so good question and you get some

00:31:43,020 --> 00:31:45,230
chocolate

00:31:45,480 --> 00:31:59,350
and I can't throw it that far could you

00:31:49,300 --> 00:32:01,150
pass that back thank you so the context

00:31:59,350 --> 00:32:06,310
for keyword is part of the definition

00:32:01,150 --> 00:32:09,880
that won't compile because we're seeing

00:32:06,310 --> 00:32:12,220
two different declarations of Const one

00:32:09,880 --> 00:32:15,130
of which is context and one is not so

00:32:12,220 --> 00:32:17,170
when the compiler sees that it'll say

00:32:15,130 --> 00:32:20,620
and I you can't do that I won't let you

00:32:17,170 --> 00:32:22,570
do that now if it were to happen in two

00:32:20,620 --> 00:32:24,100
different translation units the compiler

00:32:22,570 --> 00:32:47,500
doesn't necessarily get to see that

00:32:24,100 --> 00:32:50,200
nevertheless don't do it yes yeah so so

00:32:47,500 --> 00:32:52,330
the question is I think is the context

00:32:50,200 --> 00:33:05,320
for part of the Declaration of the

00:32:52,330 --> 00:33:08,530
function so the constant expert is not

00:33:05,320 --> 00:33:10,570
part of the return type because either a

00:33:08,530 --> 00:33:18,340
constant value or a non constant value

00:33:10,570 --> 00:33:20,260
can be returned so okay all right so

00:33:18,340 --> 00:33:22,690
they are implicitly in line the compiler

00:33:20,260 --> 00:33:28,260
has to be able to see the definition of

00:33:22,690 --> 00:33:28,260
the function before anybody invokes it

00:33:30,150 --> 00:33:34,060
there are a couple of interesting rules

00:33:32,350 --> 00:33:42,610
regarding contexts for in floating point

00:33:34,060 --> 00:33:45,460
and yeah so so this one's this one's

00:33:42,610 --> 00:33:47,350
really interesting that if you have a

00:33:45,460 --> 00:33:50,560
floating point value or a floating point

00:33:47,350 --> 00:33:53,430
thing that's being computed by your by

00:33:50,560 --> 00:33:56,250
your compiler you can run that

00:33:53,430 --> 00:33:57,730
computation at runtime you can run that

00:33:56,250 --> 00:34:00,880
computation that compile

00:33:57,730 --> 00:34:03,070
the compilers not guaranteed to produce

00:34:00,880 --> 00:34:07,390
the same result from both of those

00:34:03,070 --> 00:34:24,940
computations does does anybody have an

00:34:07,390 --> 00:34:26,620
idea why yes perfect so the quest the

00:34:24,940 --> 00:34:29,470
the issue is that if you're cross

00:34:26,620 --> 00:34:32,710
compiling you know your floating-point

00:34:29,470 --> 00:34:34,780
units may be different so the the

00:34:32,710 --> 00:34:38,250
standards folks gave themselves and

00:34:34,780 --> 00:34:41,440
appropriate out saying you know if this

00:34:38,250 --> 00:34:43,690
we can't guarantee this we encourage

00:34:41,440 --> 00:34:46,120
compiler vendors to to do the right

00:34:43,690 --> 00:34:49,120
thing and produce the same value but

00:34:46,120 --> 00:34:50,440
they can't guarantee it so just to be

00:34:49,120 --> 00:34:52,510
aware if you're doing floating-point

00:34:50,440 --> 00:34:54,700
computations at compile time in

00:34:52,510 --> 00:34:57,160
particular the ones that are done at

00:34:54,700 --> 00:34:59,170
compile time if you have a if your cross

00:34:57,160 --> 00:35:01,300
compiling and you have a heavy duty

00:34:59,170 --> 00:35:05,950
processor and you're running on some

00:35:01,300 --> 00:35:07,780
kind of a wimpy compiler processor the

00:35:05,950 --> 00:35:10,680
wimpy processor may not give you as good

00:35:07,780 --> 00:35:12,790
results you know good in quotes

00:35:10,680 --> 00:35:15,640
depending on which what what you

00:35:12,790 --> 00:35:18,220
consider to be good the results could be

00:35:15,640 --> 00:35:19,600
different because the the wimpier

00:35:18,220 --> 00:35:21,180
compiler is going to struggle a little

00:35:19,600 --> 00:35:32,500
bit more and maybe allow a little bit

00:35:21,180 --> 00:35:34,240
furrier results yes yeah so the question

00:35:32,500 --> 00:35:35,380
is where do you lose your precision and

00:35:34,240 --> 00:35:38,500
the answer is this entirely

00:35:35,380 --> 00:35:39,700
implementation too dependent so this

00:35:38,500 --> 00:35:44,400
year you're in the hands of your

00:35:39,700 --> 00:35:44,400
compiler vendor yes

00:35:56,109 --> 00:36:00,830
yeah

00:35:57,320 --> 00:36:05,119
so the from from one of our GCC experts

00:36:00,830 --> 00:36:07,130
in the back he says that GCC at least

00:36:05,119 --> 00:36:09,890
so I'm heads up I'm going to be sending

00:36:07,130 --> 00:36:11,500
some chocolate back I can't throw it

00:36:09,890 --> 00:36:16,880
that far

00:36:11,500 --> 00:36:19,070
so that send that back the GCC folks

00:36:16,880 --> 00:36:20,869
have been working hard at trying to keep

00:36:19,070 --> 00:36:34,010
those aligned and it looks like there's

00:36:20,869 --> 00:36:36,230
another question back there okay and and

00:36:34,010 --> 00:36:39,940
so Howard gets chocolate for that for

00:36:36,230 --> 00:36:44,750
sure more chocolate going back heads up

00:36:39,940 --> 00:36:48,530
so so the point was that you can change

00:36:44,750 --> 00:36:50,570
the way your floating-point unit works

00:36:48,530 --> 00:36:52,609
you're you're rounding implementation or

00:36:50,570 --> 00:36:55,339
whatever at runtime so you can't

00:36:52,609 --> 00:36:59,510
guarantee under any circumstance even

00:36:55,339 --> 00:37:01,880
even with a marvelous simulation that

00:36:59,510 --> 00:37:07,520
the the floating-point computation is

00:37:01,880 --> 00:37:09,140
going to be exactly the same so the

00:37:07,520 --> 00:37:11,200
other thing that's interesting a lot of

00:37:09,140 --> 00:37:14,599
folks who do floating-point computations

00:37:11,200 --> 00:37:17,030
do that by looking inside of the the raw

00:37:14,599 --> 00:37:18,560
floating-point literal and you know

00:37:17,030 --> 00:37:21,950
crawling around in the bits because

00:37:18,560 --> 00:37:23,780
there's this exponential characteristic

00:37:21,950 --> 00:37:26,500
of most floating-point implementations

00:37:23,780 --> 00:37:29,560
and people take advantage of that and

00:37:26,500 --> 00:37:32,660
Const exper will not let you look inside

00:37:29,560 --> 00:37:34,040
I've tried you know there may be people

00:37:32,660 --> 00:37:36,200
who are more clever than I am but I

00:37:34,040 --> 00:37:38,839
think I think the folks on the standard

00:37:36,200 --> 00:37:41,690
really nailed this one down it's yeah I

00:37:38,839 --> 00:37:43,310
know I somebody can tell me they've

00:37:41,690 --> 00:37:45,170
figured out how to do it but they're

00:37:43,310 --> 00:37:47,359
doing their darndest to discourage you

00:37:45,170 --> 00:37:49,970
from looking at the bits in part that's

00:37:47,359 --> 00:37:52,430
a that's a portability issue because

00:37:49,970 --> 00:37:54,349
there's no guarantee that some

00:37:52,430 --> 00:37:58,250
processors representation is going to be

00:37:54,349 --> 00:38:01,690
I Triple E anything so you know again

00:37:58,250 --> 00:38:01,690
we're dealing with cross compiling

00:38:12,070 --> 00:38:26,839
okay okay so yeah yeah so so Peters

00:38:23,990 --> 00:38:29,829
saying that they're using could you send

00:38:26,839 --> 00:38:31,970
this chocolate I don't yeah thanks so

00:38:29,829 --> 00:38:34,150
that it'll taste the same whether it's

00:38:31,970 --> 00:38:39,650
cracked or not

00:38:34,150 --> 00:38:42,500
so Peter was saying they use a Java to

00:38:39,650 --> 00:38:45,619
run their IDE and so they're computing

00:38:42,500 --> 00:38:49,960
floating point values for C++ and Java

00:38:45,619 --> 00:38:49,960
so who knows what that representation is

00:38:51,550 --> 00:38:57,609
so let's look at context per in C++ 11

00:38:58,660 --> 00:39:04,460
so we're gonna what are the constraints

00:39:01,400 --> 00:39:07,990
on a C++ 11 context per function it

00:39:04,460 --> 00:39:10,579
can't be virtual it has to return a

00:39:07,990 --> 00:39:14,450
literal type or reference to a literal

00:39:10,579 --> 00:39:17,440
type the parameters have to be literal

00:39:14,450 --> 00:39:20,690
types or references to literal types and

00:39:17,440 --> 00:39:26,560
the body of the function is a single

00:39:20,690 --> 00:39:32,589
statement one statement that's it and

00:39:26,560 --> 00:39:36,020
that statement has to be a return okay

00:39:32,589 --> 00:39:41,750
so this is C++ 11 this is this is where

00:39:36,020 --> 00:39:44,150
it all starts this is an important point

00:39:41,750 --> 00:39:49,910
to remember for later unevaluated sub

00:39:44,150 --> 00:39:54,460
expressions are ignored so what are we

00:39:49,910 --> 00:39:54,460
going to do with just a return statement

00:39:56,830 --> 00:40:07,390
okay so we can do compound statements we

00:40:01,900 --> 00:40:08,920
can do function calls oh yeah somebody

00:40:07,390 --> 00:40:19,060
said something about the ternary

00:40:08,920 --> 00:40:22,080
operator what are we gonna use it it's

00:40:19,060 --> 00:40:26,190
getting louder everybody one two three

00:40:22,080 --> 00:40:26,190
we got it okay

00:40:27,570 --> 00:40:35,950
so and we don't we don't hand out

00:40:30,340 --> 00:40:40,720
chocolate to everybody for that one so

00:40:35,950 --> 00:40:44,410
let's look at a function so this is

00:40:40,720 --> 00:40:48,670
we're gonna do the power of a value you

00:40:44,410 --> 00:40:50,620
know exponential value and we're going

00:40:48,670 --> 00:40:51,870
to do this we're going to code this so

00:40:50,620 --> 00:40:57,450
that we can determine at compile time

00:40:51,870 --> 00:40:57,450
this is since for C++ 11 Const expert

00:40:58,020 --> 00:41:04,390
and this function just kind of sets us

00:41:02,410 --> 00:41:06,580
up because we're gonna deal we're gonna

00:41:04,390 --> 00:41:08,920
allow ourselves to do negative values

00:41:06,580 --> 00:41:11,830
and so there's the the funny stuff that

00:41:08,920 --> 00:41:15,130
happens with the power that the negative

00:41:11,830 --> 00:41:18,160
power of a value is multiplying it by

00:41:15,130 --> 00:41:19,510
the inverse of the value itself so

00:41:18,160 --> 00:41:23,410
that's that's really all we're setting

00:41:19,510 --> 00:41:30,430
up here and up here at the top this is

00:41:23,410 --> 00:41:33,430
where the recursion happens and it's not

00:41:30,430 --> 00:41:35,680
very complicated this is all standard

00:41:33,430 --> 00:41:38,710
C++ code as long as you don't mind a

00:41:35,680 --> 00:41:41,110
little bit of recursion we're now

00:41:38,710 --> 00:41:47,170
allowing ourselves to compute the power

00:41:41,110 --> 00:41:49,590
of a value at compile time okay any

00:41:47,170 --> 00:41:49,590
questions

00:41:53,780 --> 00:42:08,130
yes so so the question is the question

00:42:06,960 --> 00:42:12,000
was whether there are too many cost

00:42:08,130 --> 00:42:13,740
experts so the first the the lower

00:42:12,000 --> 00:42:19,290
function the one that says user facing

00:42:13,740 --> 00:42:21,840
interface that's not recursive okay so

00:42:19,290 --> 00:42:24,180
what it does is it it takes in the value

00:42:21,840 --> 00:42:36,180
and it says is the exponent negative or

00:42:24,180 --> 00:42:38,280
positive okay so the the problem is is

00:42:36,180 --> 00:42:40,170
the name starts with a context for

00:42:38,280 --> 00:42:55,890
underscore and you have to pay attention

00:42:40,170 --> 00:42:57,300
that underscore yes okay so so Peters

00:42:55,890 --> 00:43:00,900
telling me I should write my code better

00:42:57,300 --> 00:43:03,360
and I'm sure he is right that that I

00:43:00,900 --> 00:43:05,130
should be using unary minus and ID there

00:43:03,360 --> 00:43:14,580
at least two pieces of chocolate that

00:43:05,130 --> 00:43:17,770
need to head over this direction okay

00:43:14,580 --> 00:43:23,470
so yeah my code needs to improve I don't

00:43:17,770 --> 00:43:25,600
have any doubts about that so one of the

00:43:23,470 --> 00:43:29,710
things that's interesting there's a

00:43:25,600 --> 00:43:32,170
throw in there what are we going to do

00:43:29,710 --> 00:43:34,630
with that why is there a throw in a

00:43:32,170 --> 00:43:35,860
context per function that doesn't seem

00:43:34,630 --> 00:43:40,950
like something that's going to work at

00:43:35,860 --> 00:43:45,550
compile time does it yeah and this this

00:43:40,950 --> 00:43:46,810
compiles but there's a throw what the

00:43:45,550 --> 00:43:57,570
heck is going on there

00:43:46,810 --> 00:44:00,100
yes Peter yes okay

00:43:57,570 --> 00:44:06,369
youyou already got at least two pieces

00:44:00,100 --> 00:44:11,110
of chocolate yeah yeah so so what what

00:44:06,369 --> 00:44:14,350
Peter is saying is that it will it will

00:44:11,110 --> 00:44:15,880
fail to compile because remember earlier

00:44:14,350 --> 00:44:19,080
there was this yellow strife about

00:44:15,880 --> 00:44:23,410
unevaluated sub-expressions are ignored

00:44:19,080 --> 00:44:29,320
the throw as long as it's not evaluated

00:44:23,410 --> 00:44:31,270
can just sit there benignly let me

00:44:29,320 --> 00:44:35,980
advance to the next set of slides so

00:44:31,270 --> 00:44:38,740
that we can walk through the points so

00:44:35,980 --> 00:44:42,940
this is an idiom for context for code

00:44:38,740 --> 00:44:44,380
you'll have once there gets to be a lot

00:44:42,940 --> 00:44:49,510
of context for code in the world

00:44:44,380 --> 00:44:54,030
you'll be seeing throws in it if you

00:44:49,510 --> 00:44:56,290
evaluate the throw during compilation

00:44:54,030 --> 00:44:59,350
then the compiler will stop you dead

00:44:56,290 --> 00:45:01,030
because it says I can't throw as long as

00:44:59,350 --> 00:45:05,050
you don't evaluate it it will just sit

00:45:01,030 --> 00:45:07,840
there and the other part of it is that

00:45:05,050 --> 00:45:10,500
if it's at runtime because the return

00:45:07,840 --> 00:45:13,300
value isn't being used where a constant

00:45:10,500 --> 00:45:15,640
expression is required if you're at

00:45:13,300 --> 00:45:17,230
runtime then it turns into a legitimate

00:45:15,640 --> 00:45:19,570
throw so this is a standard way of

00:45:17,230 --> 00:45:21,690
handling errors with in C++ yes your

00:45:19,570 --> 00:45:21,690
question

00:45:32,340 --> 00:45:37,360
yeah okay so the point is that this

00:45:35,500 --> 00:45:39,880
would be an easy way to find out whether

00:45:37,360 --> 00:45:42,250
we're getting run time or compile time

00:45:39,880 --> 00:45:43,990
evaluation and I'm going to have to move

00:45:42,250 --> 00:45:45,610
faster thank you very much

00:45:43,990 --> 00:45:50,650
yeah so let me send some chocolate back

00:45:45,610 --> 00:45:55,380
to you let's see how far back that goes

00:45:50,650 --> 00:45:58,210
yeah so that that keeps going back so

00:45:55,380 --> 00:46:00,180
we're hopefully we'll get to the slide

00:45:58,210 --> 00:46:15,730
where we leverage this

00:46:00,180 --> 00:46:18,760
yes question the back that's that's a so

00:46:15,730 --> 00:46:20,290
the question is if you if you have a

00:46:18,760 --> 00:46:22,660
compiler where you've turned off

00:46:20,290 --> 00:46:25,630
exceptions what's going to happen here

00:46:22,660 --> 00:46:28,630
and that's a great question I don't have

00:46:25,630 --> 00:46:32,350
any experience with that so I can't give

00:46:28,630 --> 00:46:34,750
you the answer somehow you have to know

00:46:32,350 --> 00:46:42,370
the way that you would deal with error

00:46:34,750 --> 00:46:44,410
conditions and work within that so we

00:46:42,370 --> 00:46:46,630
can use this function that we just wrote

00:46:44,410 --> 00:46:48,010
we can use it at compile time and you

00:46:46,630 --> 00:46:51,250
can tell it as compile time because

00:46:48,010 --> 00:46:56,890
we're using static asserts you can use

00:46:51,250 --> 00:46:58,690
that same function at runtime because

00:46:56,890 --> 00:47:02,460
here we've got a value that we don't

00:46:58,690 --> 00:47:02,460
possibly know what is until a runtime

00:47:11,250 --> 00:47:17,310
yeah it happens to work for my compiler

00:47:21,240 --> 00:47:27,700
so the point was I used equal equal on a

00:47:25,030 --> 00:47:33,640
floating point value and yeah it

00:47:27,700 --> 00:47:36,580
happened to work from my compiler so a

00:47:33,640 --> 00:47:39,580
C++ 11 Const exper constructor the

00:47:36,580 --> 00:47:41,740
parameters have to be literals or

00:47:39,580 --> 00:47:44,620
references to literals you can't have a

00:47:41,740 --> 00:47:47,530
function try block the constructor body

00:47:44,620 --> 00:47:54,100
has to be empty nothing in the

00:47:47,530 --> 00:47:56,050
constructor body in C++ 11 the basically

00:47:54,100 --> 00:48:01,210
everything that's not static has to be

00:47:56,050 --> 00:48:03,730
initialized any constructor that is

00:48:01,210 --> 00:48:07,450
invoked by the object also has to be con

00:48:03,730 --> 00:48:09,850
sexpert and every assignment in the

00:48:07,450 --> 00:48:13,570
initializer list has to be a constant

00:48:09,850 --> 00:48:16,630
expression so when I think about the way

00:48:13,570 --> 00:48:22,870
C++ 11 Const expert works

00:48:16,630 --> 00:48:25,960
I see sort of little compiler little

00:48:22,870 --> 00:48:28,210
C++ interpreters running there's a C++

00:48:25,960 --> 00:48:32,020
interpreter that runs here on function a

00:48:28,210 --> 00:48:33,760
and it and it invokes another copy of

00:48:32,020 --> 00:48:35,590
that interpreter when it figures out or

00:48:33,760 --> 00:48:37,450
when it when it goes to function B and

00:48:35,590 --> 00:48:40,090
then function B returns a value that

00:48:37,450 --> 00:48:43,090
gets consumed or passed along through

00:48:40,090 --> 00:48:47,380
function a to function C so that's

00:48:43,090 --> 00:48:50,880
that's the way I think about it you end

00:48:47,380 --> 00:48:50,880
up thinking like a functional programmer

00:48:52,020 --> 00:49:00,280
so in C++ 11 context were is pretty

00:48:56,170 --> 00:49:02,350
seriously constrained but if you put

00:49:00,280 --> 00:49:06,280
some effort into it you can do some some

00:49:02,350 --> 00:49:14,020
cool stuff so let's get to context per

00:49:06,280 --> 00:49:17,830
in C++ 14 and C++ 11 it gives you the

00:49:14,020 --> 00:49:19,690
rules for what you can do and C++ 14

00:49:17,830 --> 00:49:20,590
they turned this on its head and they

00:49:19,690 --> 00:49:24,130
said what

00:49:20,590 --> 00:49:25,870
the things we can't do and the list is

00:49:24,130 --> 00:49:28,480
long here I don't want you to memorize

00:49:25,870 --> 00:49:30,040
it it's two pages of things but it

00:49:28,480 --> 00:49:31,870
includes things like you can't do new

00:49:30,040 --> 00:49:33,700
you can't do delete you can't do throw

00:49:31,870 --> 00:49:38,050
you can't do reinterpret cast you can't

00:49:33,700 --> 00:49:40,600
do dynamic cast but once you've gotten

00:49:38,050 --> 00:49:42,900
through that list everything else is

00:49:40,600 --> 00:49:42,900
fair game

00:49:45,210 --> 00:49:49,330
the rules are there to protect the

00:49:47,350 --> 00:49:50,950
interpreter the interpreter doesn't want

00:49:49,330 --> 00:49:55,570
to be working on anything that it

00:49:50,950 --> 00:49:59,020
doesn't know what it is so you know in

00:49:55,570 --> 00:50:03,130
the case of of a context per object 10

00:49:59,020 --> 00:50:06,520
minutes boy in the case of a context for

00:50:03,130 --> 00:50:10,150
object it has to get everything

00:50:06,520 --> 00:50:12,820
initialized up front and then we'll get

00:50:10,150 --> 00:50:16,840
to will see in context for functions you

00:50:12,820 --> 00:50:18,250
can actually modify those values in C++

00:50:16,840 --> 00:50:20,740
14 okay

00:50:18,250 --> 00:50:22,870
mostly it's like regular code if you

00:50:20,740 --> 00:50:29,050
were to read it it reads like regular

00:50:22,870 --> 00:50:30,970
C++ so where we were doing we had two

00:50:29,050 --> 00:50:34,630
different functions to perform the

00:50:30,970 --> 00:50:39,760
inversion and we had recursion before we

00:50:34,630 --> 00:50:43,960
now have a single function and it has

00:50:39,760 --> 00:50:46,000
the same kind of of in elegance that

00:50:43,960 --> 00:50:52,060
Peter pointed out earlier I didn't

00:50:46,000 --> 00:50:56,350
change my coding style so in C++ 14 this

00:50:52,060 --> 00:51:00,490
is much easier and you know as in terms

00:50:56,350 --> 00:51:02,530
of maintaining it is it just gets a lot

00:51:00,490 --> 00:51:04,270
more straightforward you don't need to

00:51:02,530 --> 00:51:07,510
read this code it's exactly the same

00:51:04,270 --> 00:51:14,530
code we saw before you know it you use

00:51:07,510 --> 00:51:15,880
it in exactly the same way question yeah

00:51:14,530 --> 00:51:17,650
so the question is does it compile

00:51:15,880 --> 00:51:20,800
faster and the answer is I honestly

00:51:17,650 --> 00:51:23,740
don't know you know my examples were too

00:51:20,800 --> 00:51:27,510
small to make a difference but chocolate

00:51:23,740 --> 00:51:33,920
and then I think yeah

00:51:27,510 --> 00:51:33,920
so watch watch your head Beamen

00:51:48,820 --> 00:51:54,830
yeah so the question is why did I not go

00:51:53,120 --> 00:51:58,310
through and carefully enumerate every

00:51:54,830 --> 00:52:00,200
entry in that list and and be even

00:51:58,310 --> 00:52:02,300
figured out my response to that is the

00:52:00,200 --> 00:52:03,680
reason I don't bother memorizing the

00:52:02,300 --> 00:52:05,000
list is because the compiler is going to

00:52:03,680 --> 00:52:07,910
hit me over the head if I try to do

00:52:05,000 --> 00:52:11,660
something wrong most of the time now if

00:52:07,910 --> 00:52:13,820
it's in an unalloyed sub expression you

00:52:11,660 --> 00:52:16,340
can put it's not just throws it can be

00:52:13,820 --> 00:52:19,280
other stuff in there that doesn't really

00:52:16,340 --> 00:52:21,880
belong and then you won't find out until

00:52:19,280 --> 00:52:26,380
you try to evaluate that at compile time

00:52:21,880 --> 00:52:28,490
so it's not it's not perfect you know

00:52:26,380 --> 00:52:30,620
protection but it's pretty good

00:52:28,490 --> 00:52:32,960
it's pretty good it's it's a long list

00:52:30,620 --> 00:52:35,510
of stuff but it all it's the list makes

00:52:32,960 --> 00:52:37,880
sense to me and be a minute you already

00:52:35,510 --> 00:52:39,500
got some chocolate right okay okay we

00:52:37,880 --> 00:52:46,700
won't hit anybody else with the

00:52:39,500 --> 00:52:50,210
chocolate so in C++ 14 context for

00:52:46,700 --> 00:52:52,670
constructors we can now put a body in

00:52:50,210 --> 00:52:56,230
this makes a huge difference having

00:52:52,670 --> 00:53:00,680
having the body on the constructor and

00:52:56,230 --> 00:53:04,100
then this list B is basically saying

00:53:00,680 --> 00:53:06,320
initialize everything okay so as long as

00:53:04,100 --> 00:53:09,280
you initialize everything you can now

00:53:06,320 --> 00:53:13,220
put stuff in the body of the constructor

00:53:09,280 --> 00:53:17,720
the way I think about the again.i model

00:53:13,220 --> 00:53:21,200
this as a C++ interpreter but that

00:53:17,720 --> 00:53:23,740
context has now grown it's not each

00:53:21,200 --> 00:53:27,500
individual function has its own context

00:53:23,740 --> 00:53:29,270
the context of lower functions know

00:53:27,500 --> 00:53:31,220
something about what's happening above

00:53:29,270 --> 00:53:37,280
that they're all producing a constant

00:53:31,220 --> 00:53:41,600
value so you end up thinking like a C++

00:53:37,280 --> 00:53:43,190
programmer who doesn't have new and I

00:53:41,600 --> 00:53:48,080
can think like that maybe some of you

00:53:43,190 --> 00:53:49,880
can't but it works well for me so we

00:53:48,080 --> 00:53:51,470
have less than 10 minutes and we're

00:53:49,880 --> 00:53:55,720
going to rip through compile time

00:53:51,470 --> 00:53:55,720
parsing as our example

00:53:57,520 --> 00:54:06,660
so let's make a binary literal they

00:54:02,710 --> 00:54:10,750
don't have a binary literal in C++ 11

00:54:06,660 --> 00:54:16,300
can we make one it turns out yes

00:54:10,750 --> 00:54:19,869
it's a single function yeah it uses

00:54:16,300 --> 00:54:21,880
recursion but this particular

00:54:19,869 --> 00:54:29,320
implementation allows you to put commas

00:54:21,880 --> 00:54:31,000
in your binary literal so you don't want

00:54:29,320 --> 00:54:34,660
to spend too much time studying that

00:54:31,000 --> 00:54:37,630
well let's just assume that I have tried

00:54:34,660 --> 00:54:41,440
that it compiles it runs here's some

00:54:37,630 --> 00:54:47,110
some example code that uses that compile

00:54:41,440 --> 00:54:49,090
time binary literal and I spent a bunch

00:54:47,110 --> 00:54:51,330
of time doing embedded development and

00:54:49,090 --> 00:54:55,450
boy wouldn't it wouldn't I have ever

00:54:51,330 --> 00:54:57,070
killed for a binary literal now we've

00:54:55,450 --> 00:54:59,650
got it and we'll get to this but you

00:54:57,070 --> 00:55:06,250
know it happens in C++ 14 but you know I

00:54:59,650 --> 00:55:09,550
really wanted this so oh yeah and it's

00:55:06,250 --> 00:55:13,420
worth pointing out that I can make a

00:55:09,550 --> 00:55:19,330
binary double not that's extraordinarily

00:55:13,420 --> 00:55:22,480
useful thank you so let's do that

00:55:19,330 --> 00:55:25,720
solve that same problem in C++ 14 it's

00:55:22,480 --> 00:55:29,500
easier to code than it is in C++ 11 but

00:55:25,720 --> 00:55:31,600
it's not as useful because in C++ 14 the

00:55:29,500 --> 00:55:34,300
Standards Committee gave us that that

00:55:31,600 --> 00:55:36,730
literal so a round of applause for the

00:55:34,300 --> 00:55:40,119
Standards Committee here thank you very

00:55:36,730 --> 00:55:45,100
much thank you yes my approval of the

00:55:40,119 --> 00:55:46,750
Standards Committee so and that's that's

00:55:45,100 --> 00:55:52,780
the way you would do the binary literal

00:55:46,750 --> 00:55:55,210
in C++ 14 but the code that you know

00:55:52,780 --> 00:56:01,000
where we did it with recursion in C++ 11

00:55:55,210 --> 00:56:04,780
this is very straightforward and I'm

00:56:01,000 --> 00:56:06,850
probably just about out of time the

00:56:04,780 --> 00:56:09,190
example code here is identical to the

00:56:06,850 --> 00:56:11,050
other example code it runs exactly the

00:56:09,190 --> 00:56:13,460
same way

00:56:11,050 --> 00:56:15,260
is there a weakness in that particular

00:56:13,460 --> 00:56:19,520
implementation well I was taking in a

00:56:15,260 --> 00:56:24,190
char star can we get rid of the problems

00:56:19,520 --> 00:56:27,680
of buffer overruns yeah so here's

00:56:24,190 --> 00:56:31,010
actually I stole this from cpp reference

00:56:27,680 --> 00:56:32,960
comm so certainly don't you know go to

00:56:31,010 --> 00:56:35,270
CPP reference comm and look at their

00:56:32,960 --> 00:56:38,270
context per page this example sitting

00:56:35,270 --> 00:56:41,570
right there so what it will do is it

00:56:38,270 --> 00:56:44,600
will take in a char or a literal char

00:56:41,570 --> 00:56:46,820
array determine the length capture that

00:56:44,600 --> 00:56:53,390
at compile time or in your in your

00:56:46,820 --> 00:56:54,950
context per evaluation and and so limit

00:56:53,390 --> 00:56:59,180
yourself so that you can't walk off the

00:56:54,950 --> 00:57:05,180
end of your buffer and this is how you

00:56:59,180 --> 00:57:07,310
would use that so I'm probably just

00:57:05,180 --> 00:57:11,060
about out of time let's see how fast we

00:57:07,310 --> 00:57:14,570
can get through this so limits on

00:57:11,060 --> 00:57:18,170
context per so there's an annex B and

00:57:14,570 --> 00:57:19,640
the standard that has two statements

00:57:18,170 --> 00:57:23,360
regarding context but that are really

00:57:19,640 --> 00:57:27,550
important one is how many what what are

00:57:23,360 --> 00:57:29,780
the minimum suggested number of

00:57:27,550 --> 00:57:36,500
recursive invocations that are allowed

00:57:29,780 --> 00:57:40,460
by context where that's 512 in C++ 14

00:57:36,500 --> 00:57:43,070
how many full expressions would be

00:57:40,460 --> 00:57:45,260
allowed to be evaluated inside of

00:57:43,070 --> 00:57:51,020
producing a single context per value and

00:57:45,260 --> 00:57:52,820
that's over a million and the actual

00:57:51,020 --> 00:57:54,710
limits are up to your compilers so those

00:57:52,820 --> 00:57:56,900
are recommendations for minimum values

00:57:54,710 --> 00:57:59,410
whatever your compiler does is what your

00:57:56,900 --> 00:58:04,070
compiler does

00:57:59,410 --> 00:58:08,360
how do you do bugs this stuff sometimes

00:58:04,070 --> 00:58:10,460
you just pull through what I like doing

00:58:08,360 --> 00:58:11,990
is running the code in the debugger so

00:58:10,460 --> 00:58:14,180
just because you've declared a function

00:58:11,990 --> 00:58:15,610
is context per you can still run it at

00:58:14,180 --> 00:58:18,620
runtime

00:58:15,610 --> 00:58:19,940
so you initialize a non-literal with the

00:58:18,620 --> 00:58:23,030
function and then run that in the

00:58:19,940 --> 00:58:25,450
debugger and compare that to debugging a

00:58:23,030 --> 00:58:25,450
template

00:58:25,750 --> 00:58:34,119
okay so I yeah this it's really it

00:58:30,890 --> 00:58:37,720
really makes a big difference

00:58:34,119 --> 00:58:41,240
adding print statements however is tough

00:58:37,720 --> 00:58:42,589
because you always want to put in a

00:58:41,240 --> 00:58:45,619
print statement in some part that's

00:58:42,589 --> 00:58:49,550
going to execute and prints since they

00:58:45,619 --> 00:58:51,109
do i/o they are never context Burgh so

00:58:49,550 --> 00:58:54,500
you have to make a copy of the function

00:58:51,109 --> 00:58:56,329
or remove the context or qualifier while

00:58:54,500 --> 00:58:59,210
you're debugging it if you like to debug

00:58:56,329 --> 00:59:05,119
with prints but if you've got a good

00:58:59,210 --> 00:59:07,160
debugger you can get a long way so

00:59:05,119 --> 00:59:09,190
what's a user error look like at compile

00:59:07,160 --> 00:59:09,190
time

00:59:09,460 --> 00:59:18,079
this is what it looks like it's not you

00:59:14,000 --> 00:59:20,030
know beautiful but at least it stopped

00:59:18,079 --> 00:59:22,040
you at compile time and it got you into

00:59:20,030 --> 00:59:23,810
the right area so you'll now look at

00:59:22,040 --> 00:59:25,339
this throw and maybe there's a clue

00:59:23,810 --> 00:59:29,329
around the throw about what you did

00:59:25,339 --> 00:59:31,510
wrong but if you leave the context for

00:59:29,329 --> 00:59:31,510
off

00:59:37,190 --> 00:59:41,700
you'll get your throw you won't get that

00:59:39,990 --> 00:59:57,180
error at compile time it will happen at

00:59:41,700 --> 00:59:58,920
runtime Peter right yes yeah so if you

00:59:57,180 --> 01:00:00,660
if you have a static assert then the

00:59:58,920 --> 01:00:05,940
compiler will stop you because it has to

01:00:00,660 --> 01:00:06,930
and I'm done right yeah okay I'm so so

01:00:05,940 --> 01:00:08,250
the time is up

01:00:06,930 --> 01:00:10,019
I'm not going to shut it down I'm gonna

01:00:08,250 --> 01:00:14,220
carry on for just a few more minutes and

01:00:10,019 --> 01:00:15,839
forgive me for that so yeah if you if

01:00:14,220 --> 01:00:19,109
you're to toss in a static assert then

01:00:15,839 --> 01:00:26,279
that would be a way of making it happen

01:00:19,109 --> 01:00:28,589
at compile time oh all right

01:00:26,279 --> 01:00:30,900
so yeah so you can't static oh sorry I

01:00:28,589 --> 01:00:32,369
need to move fast so I'm gonna stop

01:00:30,900 --> 01:00:34,259
handing out chocolate and answering

01:00:32,369 --> 01:00:37,619
questions let me let me just pull

01:00:34,259 --> 01:00:42,119
through here really fast so in my

01:00:37,619 --> 01:00:44,730
opinion runtime execution is really

01:00:42,119 --> 01:00:48,150
handy for debugging in this particular

01:00:44,730 --> 01:00:54,839
case it's not so good for debuggers so

01:00:48,150 --> 01:00:57,390
or r44 excuse me for users so which of

01:00:54,839 --> 01:01:02,279
those two cases generates a runtime

01:00:57,390 --> 01:01:04,259
error yeah yeah that's the one that's

01:01:02,279 --> 01:01:06,750
easier to type because you didn't have

01:01:04,259 --> 01:01:08,880
to type the Const expert so you get you

01:01:06,750 --> 01:01:11,640
get punished by a runtime error if you

01:01:08,880 --> 01:01:13,559
forget the Const expert and that means

01:01:11,640 --> 01:01:18,720
that every invocation of that function

01:01:13,559 --> 01:01:22,140
has the potential for error so very

01:01:18,720 --> 01:01:25,140
quickly getting to Beeman's question

01:01:22,140 --> 01:01:30,480
from a long time ago is there a way to

01:01:25,140 --> 01:01:34,349
poison a function and there isn't within

01:01:30,480 --> 01:01:36,269
the standard but we've got a hack that

01:01:34,349 --> 01:01:38,069
Howard helped me with who's Howard

01:01:36,269 --> 01:01:44,160
Howard Hinnant is sitting right next to

01:01:38,069 --> 01:01:45,660
Beeman so what you can do under most

01:01:44,160 --> 01:01:48,180
circumstances is so you can put an

01:01:45,660 --> 01:01:51,000
unresolved symbol in a throw so the

01:01:48,180 --> 01:01:53,460
throw won't be evaluated

01:01:51,000 --> 01:01:55,470
here we've got an unresolved simple and

01:01:53,460 --> 01:02:01,700
we're dropping it into the throat we're

01:01:55,470 --> 01:02:04,250
using is the text for the throat because

01:02:01,700 --> 01:02:06,420
and what she'll get out of that is a

01:02:04,250 --> 01:02:09,450
rather than a compile-time error you'll

01:02:06,420 --> 01:02:16,680
get a link time error so this is this is

01:02:09,450 --> 01:02:22,290
what you'll see this is yeah well thank

01:02:16,680 --> 01:02:25,170
you yeah and this this was actually it

01:02:22,290 --> 01:02:27,990
took a number of years for her thrashing

01:02:25,170 --> 01:02:29,880
around to figure out that you know the

01:02:27,990 --> 01:02:33,030
the standards guys really knew their

01:02:29,880 --> 01:02:35,940
work they made it very hard to detect to

01:02:33,030 --> 01:02:38,880
to draw a distinction between run time

01:02:35,940 --> 01:02:41,010
versus compile time why does it work the

01:02:38,880 --> 01:02:44,130
throw must not be evaluated at compile

01:02:41,010 --> 01:02:47,490
time the throw must be included in a

01:02:44,130 --> 01:02:49,710
runtime implementation and the run time

01:02:47,490 --> 01:02:53,190
implementation cannot link because

01:02:49,710 --> 01:02:55,020
there's an unresolved external is this

01:02:53,190 --> 01:02:58,830
the best you can do it's the best we've

01:02:55,020 --> 01:03:00,780
found so far the errors ugly doesn't

01:02:58,830 --> 01:03:06,090
identify the line where the error was

01:03:00,780 --> 01:03:11,760
and it may not work Richard Smith who's

01:03:06,090 --> 01:03:15,300
the the brains behind C++ 14 this is a

01:03:11,760 --> 01:03:18,360
quote from him that the compiler is

01:03:15,300 --> 01:03:20,160
allowed to include the throw code even

01:03:18,360 --> 01:03:22,260
though it's not executed if your

01:03:20,160 --> 01:03:24,930
compiler goes ahead and includes that

01:03:22,260 --> 01:03:27,240
throw in the in the executable then

01:03:24,930 --> 01:03:31,560
you're gonna have your link time error

01:03:27,240 --> 01:03:34,020
so any error will be a false positive so

01:03:31,560 --> 01:03:36,060
you'll know you know right now either

01:03:34,020 --> 01:03:41,430
either you screwed up or your compiler

01:03:36,060 --> 01:03:43,710
isn't isn't taking care of you so the

01:03:41,430 --> 01:03:47,210
summary for the technique is a context

01:03:43,710 --> 01:03:49,950
or function has to have a throw in it

01:03:47,210 --> 01:03:53,010
you declare an unresolved external

01:03:49,950 --> 01:03:56,460
constant R star and then you reference

01:03:53,010 --> 01:03:58,230
it and I yeah I kept you guys over time

01:03:56,460 --> 01:03:59,760
the next room's gonna start I got to

01:03:58,230 --> 01:04:00,670
call it quits but thank you very much

01:03:59,760 --> 01:04:02,730
for attending

01:04:00,670 --> 01:04:02,730

YouTube URL: https://www.youtube.com/watch?v=fZjYCQ8dzTc


