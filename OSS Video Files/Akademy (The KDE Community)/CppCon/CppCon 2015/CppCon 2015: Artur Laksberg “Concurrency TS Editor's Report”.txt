Title: CppCon 2015: Artur Laksberg “Concurrency TS Editor's Report”
Publication date: 2015-10-13
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
In this presentation we will talk about the new C++ concurrency features that have been included in the Concurrency Technical Specification. 

The TS should be of interest to anyone writing concurrent code in C++. The proposal includes improved futures for wait-free composition of asynchronous operations (including their relationship with C++ 'await'), new synchronization constructs as well as atomic smart pointers.
— 
Artur Laksberg is a software design engineer at Microsoft. His interests include concurrency, programming language and library design, and modern C++. Artur is a regular participant in the work of the Concurrency Study Group in the ISO C++ Committee, serving as the editor of the Concurrency Technical Specification. He is one of the co-authors of the proposal to improve std::future (currently part of the Concurrency TS) and also a contributor to the Parallelism TS.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:07,020
thank you everybody for coming my name

00:00:04,410 --> 00:00:08,700
is Arthur clarksburg I'm a software

00:00:07,020 --> 00:00:10,670
engineer Microsoft I'm a regular

00:00:08,700 --> 00:00:13,170
participant in the work of that

00:00:10,670 --> 00:00:18,660
concurrency study group inside the iso

00:00:13,170 --> 00:00:21,029
c++ standardization committee i'm i'm

00:00:18,660 --> 00:00:23,100
serving there as the editor of the

00:00:21,029 --> 00:00:26,730
technical specification for c++

00:00:23,100 --> 00:00:29,519
extension for concurrency i am one of

00:00:26,730 --> 00:00:30,720
the contributors to the TS i also

00:00:29,519 --> 00:00:36,149
coordinate the work of other

00:00:30,720 --> 00:00:40,140
contributors so what's a TS concurrency

00:00:36,149 --> 00:00:43,230
TS is one of the papers proposed by the

00:00:40,140 --> 00:00:45,210
sg-1 concurrency study group this is how

00:00:43,230 --> 00:00:47,780
the concurrency study group tries to

00:00:45,210 --> 00:00:51,649
advance the state of the art of

00:00:47,780 --> 00:00:54,239
concurrency in the standard C++ a

00:00:51,649 --> 00:00:57,239
technical specification is not a part of

00:00:54,239 --> 00:00:58,920
the standard however we hope to

00:00:57,239 --> 00:01:01,800
ultimately make it part of the standard

00:00:58,920 --> 00:01:04,710
it is difficult to predict that this

00:01:01,800 --> 00:01:10,799
point which portion of the standard will

00:01:04,710 --> 00:01:13,680
it appear in but regardless we hope that

00:01:10,799 --> 00:01:16,409
this technical specification remains an

00:01:13,680 --> 00:01:18,360
authoritative document that there will

00:01:16,409 --> 00:01:20,450
be implementations widely available when

00:01:18,360 --> 00:01:23,549
many platforms Microsoft is building one

00:01:20,450 --> 00:01:25,280
boost already has one I know there are

00:01:23,549 --> 00:01:29,880
some people in this room who have built

00:01:25,280 --> 00:01:32,759
partial implementations of the TS so you

00:01:29,880 --> 00:01:34,740
should be able to use the tools in the

00:01:32,759 --> 00:01:40,280
concurrency TS in your code if not today

00:01:34,740 --> 00:01:43,740
then sometime very soon so what's in it

00:01:40,280 --> 00:01:46,890
I've IDs has three main components one

00:01:43,740 --> 00:01:50,430
is improvements to STD future which

00:01:46,890 --> 00:01:53,909
allows us to compose multiple futures in

00:01:50,430 --> 00:01:55,890
a way three matter a couple of new

00:01:53,909 --> 00:02:01,229
concurrency primitives latches and

00:01:55,890 --> 00:02:03,329
barriers and also a new concept that is

00:02:01,229 --> 00:02:06,960
very useful for locally programming

00:02:03,329 --> 00:02:09,569
which is the atomic shared pointer so

00:02:06,960 --> 00:02:11,069
you should not think of this TS as a

00:02:09,569 --> 00:02:13,319
single cohesive

00:02:11,069 --> 00:02:15,329
feature rather it's a collection of

00:02:13,319 --> 00:02:18,659
features that the committee could agree

00:02:15,329 --> 00:02:20,370
on it could have been less it could have

00:02:18,659 --> 00:02:23,939
been more I'm happy that you have what

00:02:20,370 --> 00:02:26,430
you have here also this TS is not the

00:02:23,939 --> 00:02:28,200
end of the road of this work this is a

00:02:26,430 --> 00:02:30,569
v1 version of the proposal there is

00:02:28,200 --> 00:02:31,829
going to be a v2 and v3 we know there

00:02:30,569 --> 00:02:35,760
are missing features we're working on

00:02:31,829 --> 00:02:38,010
adding more so let's dive in into the

00:02:35,760 --> 00:02:40,340
first feature the first proposal is

00:02:38,010 --> 00:02:43,980
called the improvements to STD future as

00:02:40,340 --> 00:02:46,290
a quick refresher of what is that what

00:02:43,980 --> 00:02:50,849
is the future you can think of a future

00:02:46,290 --> 00:02:53,250
as a as a proxy for an eventual value

00:02:50,849 --> 00:02:57,449
typically a future is used together with

00:02:53,250 --> 00:03:00,389
a promise and somebody who creates a

00:02:57,449 --> 00:03:02,579
promise can then set the value on it and

00:03:00,389 --> 00:03:04,680
then that value will be stored in the

00:03:02,579 --> 00:03:06,359
associated state which is typically a

00:03:04,680 --> 00:03:08,489
heap allocated although some

00:03:06,359 --> 00:03:11,730
implementations exist where it isn't hip

00:03:08,489 --> 00:03:14,310
located and then the future typically on

00:03:11,730 --> 00:03:16,799
another thread can then retrieve the

00:03:14,310 --> 00:03:19,590
value from the shared state or wait for

00:03:16,799 --> 00:03:22,949
the value to become available a future

00:03:19,590 --> 00:03:27,060
is very useful for representing

00:03:22,949 --> 00:03:29,549
long-running operations or any

00:03:27,060 --> 00:03:31,349
operations where we need to wait for the

00:03:29,549 --> 00:03:34,979
results to become available and it's not

00:03:31,349 --> 00:03:36,180
immediately available so a typical use

00:03:34,979 --> 00:03:39,769
of a future would look like this now

00:03:36,180 --> 00:03:43,650
imagine a case where we are reading a

00:03:39,769 --> 00:03:45,750
string from a file right the first one

00:03:43,650 --> 00:03:51,359
one of the ways to get the value out of

00:03:45,750 --> 00:03:52,979
it is to call the get method and when

00:03:51,359 --> 00:03:56,639
the value is not immediately available

00:03:52,979 --> 00:03:59,099
in the future that call will block the

00:03:56,639 --> 00:04:00,840
current thread until the value becomes

00:03:59,099 --> 00:04:04,229
available and then extract the value out

00:04:00,840 --> 00:04:07,439
of the future right if the calling

00:04:04,229 --> 00:04:10,799
thread is a scarce resource which which

00:04:07,439 --> 00:04:13,229
happens the preferred way to consume

00:04:10,799 --> 00:04:15,180
that future would be by attaching a

00:04:13,229 --> 00:04:17,759
continuation to it and that's that's the

00:04:15,180 --> 00:04:22,169
dot then method this is that is this is

00:04:17,759 --> 00:04:24,320
part of the proposal again the the gate

00:04:22,169 --> 00:04:27,830
part is what we have today a

00:04:24,320 --> 00:04:30,740
that does then method is what we are

00:04:27,830 --> 00:04:32,780
proposing in the in that proposal the

00:04:30,740 --> 00:04:33,860
van method takes a collabo object

00:04:32,780 --> 00:04:36,920
typically this would be a lambda

00:04:33,860 --> 00:04:40,790
expression in which you take the future

00:04:36,920 --> 00:04:44,630
and then call get on it that get is then

00:04:40,790 --> 00:04:47,240
guaranteed to be non blocking and then

00:04:44,630 --> 00:04:49,250
you can use the value right and the

00:04:47,240 --> 00:04:52,520
reason we pass the future in it and not

00:04:49,250 --> 00:04:54,380
at not a string is because we also want

00:04:52,520 --> 00:04:57,800
to take care of exception if exception

00:04:54,380 --> 00:04:59,900
is thrown then a call to get on the

00:04:57,800 --> 00:05:06,410
result will resurface that exception

00:04:59,900 --> 00:05:10,850
right so the interesting part about that

00:05:06,410 --> 00:05:13,820
then is that the function itself returns

00:05:10,850 --> 00:05:16,460
a future and then the type of that

00:05:13,820 --> 00:05:20,960
future is determined by the return type

00:05:16,460 --> 00:05:23,980
of the expression inside that then in

00:05:20,960 --> 00:05:26,330
this case we are returning an integer

00:05:23,980 --> 00:05:32,270
therefore the return type of the then is

00:05:26,330 --> 00:05:35,540
going to be a future of int ok another

00:05:32,270 --> 00:05:38,930
useful property of the then method is

00:05:35,540 --> 00:05:42,440
called the implicit unwrapping very

00:05:38,930 --> 00:05:45,110
often when you work with futures and

00:05:42,440 --> 00:05:47,840
continuations you find yourself invoking

00:05:45,110 --> 00:05:49,850
an asynchronous operation inside of the

00:05:47,840 --> 00:05:52,160
call back of the handler of another

00:05:49,850 --> 00:05:53,540
asynchronous operation in which case if

00:05:52,160 --> 00:05:57,830
you look at this example we are reading

00:05:53,540 --> 00:06:00,620
a string that string represents a URL

00:05:57,830 --> 00:06:04,210
and then in the subsequent operation we

00:06:00,620 --> 00:06:07,850
are downloading HTML from that URL and

00:06:04,210 --> 00:06:10,670
here we are turning a future of a string

00:06:07,850 --> 00:06:13,880
right so had we followed the regular

00:06:10,670 --> 00:06:17,270
rules for the return types the type of

00:06:13,880 --> 00:06:19,160
the the type to torrent of the van

00:06:17,270 --> 00:06:22,040
expression would have been a future of a

00:06:19,160 --> 00:06:25,250
future of a string that type is not very

00:06:22,040 --> 00:06:27,230
useful therefore implicit unwrapping and

00:06:25,250 --> 00:06:30,440
wrapping kicks in and that's why this

00:06:27,230 --> 00:06:34,640
type becomes a future of a string and

00:06:30,440 --> 00:06:37,600
this is what allow us to do what we call

00:06:34,640 --> 00:06:42,010
a chaining continuation change

00:06:37,600 --> 00:06:43,770
often in code that uses a continuation

00:06:42,010 --> 00:06:46,930
center features and continued shins you

00:06:43,770 --> 00:06:48,580
you'll see this as a pattern you read

00:06:46,930 --> 00:06:50,380
something or you perform an operation

00:06:48,580 --> 00:06:52,330
inside the operation you perform another

00:06:50,380 --> 00:06:54,250
operation return that and you can

00:06:52,330 --> 00:06:56,650
immediately attach another continuation

00:06:54,250 --> 00:06:59,040
to it right that's sort of this is how

00:06:56,650 --> 00:07:04,210
you can ask string together multiple

00:06:59,040 --> 00:07:06,730
asynchronous operations in addition to

00:07:04,210 --> 00:07:09,520
the van method the TS also introduces

00:07:06,730 --> 00:07:12,850
two operations that act on multiple

00:07:09,520 --> 00:07:15,940
futures the join in the choice the join

00:07:12,850 --> 00:07:19,060
creates a future that becomes ready when

00:07:15,940 --> 00:07:22,030
all parameters passed into it already

00:07:19,060 --> 00:07:23,590
and choice creates a future that becomes

00:07:22,030 --> 00:07:27,790
ready when at least one of the

00:07:23,590 --> 00:07:29,470
parameters israeli both join and choice

00:07:27,790 --> 00:07:33,300
come in two forms homogeneous and

00:07:29,470 --> 00:07:38,140
heterogeneous this is a homogeneous case

00:07:33,300 --> 00:07:41,160
here the joint is implemented by when

00:07:38,140 --> 00:07:46,840
old operation which takes a range and

00:07:41,160 --> 00:07:49,180
returns a future of a vector of a future

00:07:46,840 --> 00:07:50,530
of an end and it looks a little bit

00:07:49,180 --> 00:07:52,420
intimidating but the good news is that

00:07:50,530 --> 00:07:54,970
most often you don't have to spell out

00:07:52,420 --> 00:07:56,710
the type you just say auto right in this

00:07:54,970 --> 00:07:59,530
case I spelled it out so that I can

00:07:56,710 --> 00:08:01,360
explain it what it is first of all the

00:07:59,530 --> 00:08:03,100
return type is always a future because

00:08:01,360 --> 00:08:07,480
it is an asynchronous operation when all

00:08:03,100 --> 00:08:11,920
doesn't wait right second vector is

00:08:07,480 --> 00:08:14,230
there because we take the futures that

00:08:11,920 --> 00:08:17,110
are passed into the function through the

00:08:14,230 --> 00:08:19,930
range and move them into a new container

00:08:17,110 --> 00:08:22,660
which is the vector and finally it's a

00:08:19,930 --> 00:08:25,240
vector of a future because instead of

00:08:22,660 --> 00:08:26,860
moving the values into the vector we are

00:08:25,240 --> 00:08:29,170
moving actually the original futures

00:08:26,860 --> 00:08:31,210
into the new vector we never unpack a

00:08:29,170 --> 00:08:34,690
value out of the future and move it we

00:08:31,210 --> 00:08:36,130
only move the future themselves and of

00:08:34,690 --> 00:08:38,130
course because it runs the future you

00:08:36,130 --> 00:08:42,340
can attach a continuation to it and

00:08:38,130 --> 00:08:46,450
process that continuation like here when

00:08:42,340 --> 00:08:48,280
you go through the vector it is

00:08:46,450 --> 00:08:49,640
guaranteed by definition that every

00:08:48,280 --> 00:08:55,210
future in that vector is

00:08:49,640 --> 00:09:01,400
ready this is a heterogeneous example

00:08:55,210 --> 00:09:03,680
the return type of when old is a little

00:09:01,400 --> 00:09:05,900
bit more complicated now it becomes a

00:09:03,680 --> 00:09:08,000
future of a tuple of a future event in

00:09:05,900 --> 00:09:09,050
the future of a chart again it's a good

00:09:08,000 --> 00:09:13,790
thing that you don't have to spell it

00:09:09,050 --> 00:09:15,400
out in Jersey order and then extracting

00:09:13,790 --> 00:09:20,260
the value out of that future is very

00:09:15,400 --> 00:09:24,440
similar to the previous example choice

00:09:20,260 --> 00:09:27,410
homogeneous example works like this we

00:09:24,440 --> 00:09:29,720
call when any on the range of futures

00:09:27,410 --> 00:09:32,540
the return expression is going to have a

00:09:29,720 --> 00:09:35,150
type of a future of when any result

00:09:32,540 --> 00:09:37,900
which is just a struct of an index that

00:09:35,150 --> 00:09:41,570
represents the future that is ready and

00:09:37,900 --> 00:09:45,650
the container itself of a vector of a

00:09:41,570 --> 00:09:50,840
future of a net right and when I consume

00:09:45,650 --> 00:09:52,430
that future I can index I can use the

00:09:50,840 --> 00:09:55,070
index which is a member of that when any

00:09:52,430 --> 00:09:57,320
result and the future that I get this

00:09:55,070 --> 00:09:59,180
way is guaranteed to be ready right at

00:09:57,320 --> 00:10:01,490
this moment more than one future can be

00:09:59,180 --> 00:10:06,200
ready but at least one this one is

00:10:01,490 --> 00:10:08,410
guaranteed to be in a ready state and

00:10:06,200 --> 00:10:10,580
finally this heterogeneous example gets

00:10:08,410 --> 00:10:12,500
even more complicated now the return

00:10:10,580 --> 00:10:14,030
type is a future of an any result of

00:10:12,500 --> 00:10:19,090
tuple of a future of inter future of

00:10:14,030 --> 00:10:21,070
chart and consuming this is also

00:10:19,090 --> 00:10:24,260
straightforward with the exception of

00:10:21,070 --> 00:10:26,150
that you cannot use the index which is a

00:10:24,260 --> 00:10:28,070
round time variable to index into the

00:10:26,150 --> 00:10:31,670
two pole right that's why I'm using an

00:10:28,070 --> 00:10:34,690
if statement here if the index is 0 that

00:10:31,670 --> 00:10:38,090
i'm using i'm going to use the get of 0

00:10:34,690 --> 00:10:43,130
free function to extract that value out

00:10:38,090 --> 00:10:44,810
of the two pole so we have seen how

00:10:43,130 --> 00:10:47,630
futures can be used for sequential

00:10:44,810 --> 00:10:50,210
composition as well as join and choice

00:10:47,630 --> 00:10:53,840
right so futures are very good for

00:10:50,210 --> 00:10:56,720
creating graphs or expression tags if

00:10:53,840 --> 00:10:59,960
you were right what if your problem is

00:10:56,720 --> 00:11:01,940
not is not a duck right what if you have

00:10:59,960 --> 00:11:04,670
some cycles in that graph

00:11:01,940 --> 00:11:08,130
let's imagine a case where you're eating

00:11:04,670 --> 00:11:10,020
something from a file and you have a

00:11:08,130 --> 00:11:12,900
trivial or simple file in either class

00:11:10,020 --> 00:11:15,060
that has a constructor wooden function

00:11:12,900 --> 00:11:17,910
is EF that indicates if the reader has

00:11:15,060 --> 00:11:22,380
reached the end of oil and they get next

00:11:17,910 --> 00:11:24,240
string function right so let's try and

00:11:22,380 --> 00:11:26,790
see how we can use futures and

00:11:24,240 --> 00:11:33,720
continuations to work with either like

00:11:26,790 --> 00:11:35,750
this a synchronous way of consuming text

00:11:33,720 --> 00:11:38,040
when that tree there is straightforward

00:11:35,750 --> 00:11:39,690
you're looping until the reader has

00:11:38,040 --> 00:11:43,010
reached has not reached the end of file

00:11:39,690 --> 00:11:46,110
and then within each iteration you call

00:11:43,010 --> 00:11:48,210
result that get that is a blocking call

00:11:46,110 --> 00:11:53,090
of course and then you print out the

00:11:48,210 --> 00:11:56,880
valium let's try to do it asynchronously

00:11:53,090 --> 00:11:59,430
so in this case I'm attaching a

00:11:56,880 --> 00:12:01,800
continuation to the result I'm getting

00:11:59,430 --> 00:12:04,860
the value and then I have to do

00:12:01,800 --> 00:12:07,350
something else here right but this being

00:12:04,860 --> 00:12:09,330
an asynchronous lambda this this is

00:12:07,350 --> 00:12:11,910
where it becomes more difficult I cannot

00:12:09,330 --> 00:12:13,080
jump out of a lambda into the middle of

00:12:11,910 --> 00:12:19,610
the loop right especially an

00:12:13,080 --> 00:12:21,840
asynchronous lambda so what do we do so

00:12:19,610 --> 00:12:23,310
let's write something like this

00:12:21,840 --> 00:12:25,440
obviously this isn't going to be a

00:12:23,310 --> 00:12:28,620
scalable approach but just just humor me

00:12:25,440 --> 00:12:31,980
for a minute sometimes it pays to write

00:12:28,620 --> 00:12:34,350
ugly code before we can see patterns and

00:12:31,980 --> 00:12:37,410
then we refactor that code and turn it

00:12:34,350 --> 00:12:39,540
into something more reasonable what if

00:12:37,410 --> 00:12:41,490
I'm simply I'm just going to repeat what

00:12:39,540 --> 00:12:43,710
i did in the for reading the first line

00:12:41,490 --> 00:12:46,620
and come up with something like this

00:12:43,710 --> 00:12:49,530
right and I I can do even more and I can

00:12:46,620 --> 00:12:51,720
repeat it again right we we all have

00:12:49,530 --> 00:12:55,800
widescreen monitors nowadays and you

00:12:51,720 --> 00:12:57,360
know we can go pretty far but joking

00:12:55,800 --> 00:13:00,150
aside this is the point where we start

00:12:57,360 --> 00:13:01,620
seeing some patterns right there is

00:13:00,150 --> 00:13:03,470
something that we do in each iteration

00:13:01,620 --> 00:13:06,360
that's the first observation so this

00:13:03,470 --> 00:13:07,980
piece of code in there in a brown block

00:13:06,360 --> 00:13:10,970
right we read the value out of the

00:13:07,980 --> 00:13:14,930
future who painted on the screen

00:13:10,970 --> 00:13:18,680
and the second observation is because we

00:13:14,930 --> 00:13:20,420
cannot use iteration the next tool that

00:13:18,680 --> 00:13:23,420
we usually reach for when we cannot use

00:13:20,420 --> 00:13:27,019
iteration is what precaution right so

00:13:23,420 --> 00:13:31,459
let's let's do that now this is a

00:13:27,019 --> 00:13:33,920
function that reads read from the file

00:13:31,459 --> 00:13:36,889
that funk is something is something that

00:13:33,920 --> 00:13:40,490
is passed by the user right and it

00:13:36,889 --> 00:13:41,810
invokes itself recursively i should say

00:13:40,490 --> 00:13:43,279
there's not a recursion it's a pseudo

00:13:41,810 --> 00:13:45,439
recursion because typically we invoke

00:13:43,279 --> 00:13:47,120
the function itself on a different

00:13:45,439 --> 00:13:51,500
thread but but it is still sort of a

00:13:47,120 --> 00:13:54,470
kind of recursion and we're done right

00:13:51,500 --> 00:13:55,910
we can we can stop right there but of

00:13:54,470 --> 00:13:58,279
course where engineers would like to

00:13:55,910 --> 00:14:01,730
build with a usable components so let's

00:13:58,279 --> 00:14:04,009
try to generalize it even further so one

00:14:01,730 --> 00:14:06,379
observation here is that in every

00:14:04,009 --> 00:14:09,110
iteration there are three main things

00:14:06,379 --> 00:14:12,110
right there is a predicate that we

00:14:09,110 --> 00:14:14,060
invoke and that tells us whether we need

00:14:12,110 --> 00:14:16,220
to continue iteration right then we can

00:14:14,060 --> 00:14:18,519
make it again something that the user

00:14:16,220 --> 00:14:21,620
can pass into function it's a parameter

00:14:18,519 --> 00:14:25,240
next we have an iterator we call the

00:14:21,620 --> 00:14:28,100
iterator that yields us the next value

00:14:25,240 --> 00:14:31,220
in each invocation finally there is a

00:14:28,100 --> 00:14:32,509
user-provided funk tour so we can write

00:14:31,220 --> 00:14:35,779
the function it looks like this make

00:14:32,509 --> 00:14:38,089
iterative future you can use it for

00:14:35,779 --> 00:14:42,649
reading profile you can use it for

00:14:38,089 --> 00:14:45,949
pretty much anything right invoking this

00:14:42,649 --> 00:14:48,439
function would look like this again

00:14:45,949 --> 00:14:54,079
quite reasonable right now no not not

00:14:48,439 --> 00:14:57,470
super simple but reasonable so we

00:14:54,079 --> 00:15:01,309
started with this simple innocently

00:14:57,470 --> 00:15:05,059
looking a synchronous code and wound up

00:15:01,309 --> 00:15:07,189
with this right even if you consider

00:15:05,059 --> 00:15:10,100
that this part is going to exist

00:15:07,189 --> 00:15:13,430
somewhere in the library this is still

00:15:10,100 --> 00:15:15,829
hard right this is probably too too

00:15:13,430 --> 00:15:19,870
complex for a regular user and the truth

00:15:15,829 --> 00:15:22,579
is this is the point where we are

00:15:19,870 --> 00:15:24,110
reaching the point of the limit of how

00:15:22,579 --> 00:15:29,269
far you can go with the library

00:15:24,110 --> 00:15:31,279
solution but don't despair a better

00:15:29,269 --> 00:15:34,579
solution is on its way and it's called

00:15:31,279 --> 00:15:38,899
the await two things are happening here

00:15:34,579 --> 00:15:41,690
first is read a sinc function needs to

00:15:38,899 --> 00:15:45,100
return a future maybe future of a void

00:15:41,690 --> 00:15:47,390
or some other type that represents an

00:15:45,100 --> 00:15:49,730
operation and eventual operation right

00:15:47,390 --> 00:15:50,959
it doesn't have to be a future but you

00:15:49,730 --> 00:15:55,339
know if we started with you two let's

00:15:50,959 --> 00:15:57,589
continue to use future second we simply

00:15:55,339 --> 00:16:00,769
rewrite result that get into a weight

00:15:57,589 --> 00:16:04,459
result and at this point we are done

00:16:00,769 --> 00:16:08,540
it's easy to write easy to read it's

00:16:04,459 --> 00:16:10,579
efficient and at this point you might be

00:16:08,540 --> 00:16:13,279
wondering okay so if we have that why

00:16:10,579 --> 00:16:15,410
even bother with concurrency guess why

00:16:13,279 --> 00:16:17,240
even bother with the then function right

00:16:15,410 --> 00:16:18,620
why can't we just wait a little bit

00:16:17,240 --> 00:16:21,920
longer and get this into the language

00:16:18,620 --> 00:16:23,660
and we'll be done and that's a

00:16:21,920 --> 00:16:27,490
reasonable question but of course if you

00:16:23,660 --> 00:16:30,440
are using futures today what futures

00:16:27,490 --> 00:16:34,310
lack what they lack today is the ability

00:16:30,440 --> 00:16:37,339
to store continuations right and the

00:16:34,310 --> 00:16:41,149
then function is what adds that ability

00:16:37,339 --> 00:16:43,910
to the future the difference between C++

00:16:41,149 --> 00:16:46,010
14 what you can do today and what you

00:16:43,910 --> 00:16:48,949
will be able to do when a weight is in

00:16:46,010 --> 00:16:51,529
the language is that today it's you the

00:16:48,949 --> 00:16:54,800
programmer who invokes the then method

00:16:51,529 --> 00:16:57,740
in the future it's mostly going to be

00:16:54,800 --> 00:17:00,440
the compiler that invokes the invokes of

00:16:57,740 --> 00:17:03,170
their method right we human beings have

00:17:00,440 --> 00:17:04,339
difficulties reasoning about asynchrony

00:17:03,170 --> 00:17:07,819
because it means that we have to

00:17:04,339 --> 00:17:10,640
essentially rewrite our code into into

00:17:07,819 --> 00:17:14,540
very functional form compilers have no

00:17:10,640 --> 00:17:16,520
problem dealing with that so I highly

00:17:14,540 --> 00:17:20,660
recommend that you attend Gordon Sean of

00:17:16,520 --> 00:17:21,740
stock tomorrow he is the expert and at

00:17:20,660 --> 00:17:26,329
this point I'm going to move on to the

00:17:21,740 --> 00:17:34,070
next part of the controller cts notches

00:17:26,329 --> 00:17:36,620
and barriers so somebody using condition

00:17:34,070 --> 00:17:41,750
variable for the first time

00:17:36,620 --> 00:17:43,910
might naively do it like this so in this

00:17:41,750 --> 00:17:45,680
case I have two threads one is the

00:17:43,910 --> 00:17:47,720
detecting thread it's a thread that

00:17:45,680 --> 00:17:50,240
detects a condition and then notifies

00:17:47,720 --> 00:17:53,960
the other thread the waiting thread that

00:17:50,240 --> 00:17:55,970
the condition has occurred ok so again

00:17:53,960 --> 00:17:58,550
naively I'm going to use a condition

00:17:55,970 --> 00:18:00,470
variable weight the weight requires a

00:17:58,550 --> 00:18:03,770
unique look I'm going to give it a lock

00:18:00,470 --> 00:18:08,570
the lock requires a mutex I'm going to

00:18:03,770 --> 00:18:11,570
give it a Munich's save compile run it

00:18:08,570 --> 00:18:13,010
will compile and it will run about fifty

00:18:11,570 --> 00:18:16,010
percent of the time depending on the

00:18:13,010 --> 00:18:17,600
time right there are there are many big

00:18:16,010 --> 00:18:21,290
problems with this code right but

00:18:17,600 --> 00:18:23,750
they're the frustrating part is that it

00:18:21,290 --> 00:18:25,970
compiles first of all of course the the

00:18:23,750 --> 00:18:28,580
big red flag that should pop up in your

00:18:25,970 --> 00:18:31,760
head when you see this is what's up with

00:18:28,580 --> 00:18:34,010
this mutex what is the shared state that

00:18:31,760 --> 00:18:36,050
this musics but it is supposed to

00:18:34,010 --> 00:18:38,330
protect right obviously that's

00:18:36,050 --> 00:18:41,090
definitely a bad smell the second is

00:18:38,330 --> 00:18:44,300
more subtle it so happens that if you

00:18:41,090 --> 00:18:47,570
notify the condition variable before it

00:18:44,300 --> 00:18:51,650
enters the weight that notification is

00:18:47,570 --> 00:18:55,370
ignored the other problem here is that

00:18:51,650 --> 00:18:57,980
this simple weight fails to take into

00:18:55,370 --> 00:19:00,050
account spurious wake-ups it just so

00:18:57,980 --> 00:19:01,910
happens that an operating system can

00:19:00,050 --> 00:19:04,160
wake up a condition variable for other

00:19:01,910 --> 00:19:08,150
reasons reasons other than the other

00:19:04,160 --> 00:19:10,970
thread notifying it so it is it is hard

00:19:08,150 --> 00:19:12,740
to get right but this is one way how we

00:19:10,970 --> 00:19:15,080
can get it right so we introducing a new

00:19:12,740 --> 00:19:20,900
state it's going to be a boolean or

00:19:15,080 --> 00:19:22,580
Willian bull flag when we notify the can

00:19:20,900 --> 00:19:27,140
before we notify the condition variable

00:19:22,580 --> 00:19:30,110
we set it under lock and then we call

00:19:27,140 --> 00:19:34,040
notify one in the weighting function

00:19:30,110 --> 00:19:36,050
first we check that flag if the flag if

00:19:34,040 --> 00:19:38,540
the condition is not met then we enter

00:19:36,050 --> 00:19:40,130
the weight and then repeat so first of

00:19:38,540 --> 00:19:44,390
all this solves the problem of premature

00:19:40,130 --> 00:19:47,450
notification in a way in that we set the

00:19:44,390 --> 00:19:49,590
flag and then notify right and then the

00:19:47,450 --> 00:19:51,710
waiting side will first

00:19:49,590 --> 00:19:54,870
check the flag and if the flag is set

00:19:51,710 --> 00:19:56,960
will it will never even go into the

00:19:54,870 --> 00:20:01,470
weight right so that takes care of that

00:19:56,960 --> 00:20:05,400
timing problem now this while loop there

00:20:01,470 --> 00:20:07,169
will take care of spurious wake up if

00:20:05,400 --> 00:20:09,840
the condition variable wakes up for

00:20:07,169 --> 00:20:12,150
another reason we iterate again until

00:20:09,840 --> 00:20:14,549
the condition is true and eventually

00:20:12,150 --> 00:20:18,690
will exit that loop when the condition

00:20:14,549 --> 00:20:22,559
has been satisfied an alternative syntax

00:20:18,690 --> 00:20:25,770
would be to call to put the predicate in

00:20:22,559 --> 00:20:27,390
the weight function directly right I I

00:20:25,770 --> 00:20:29,159
personally like this in text mode

00:20:27,390 --> 00:20:31,590
because it makes it more explicit let we

00:20:29,159 --> 00:20:34,649
recheck the predicate first before we

00:20:31,590 --> 00:20:36,870
enter the weight this syntax does

00:20:34,649 --> 00:20:38,340
exactly the same but if you're not sure

00:20:36,870 --> 00:20:40,289
what's going on here you have to you

00:20:38,340 --> 00:20:43,320
have to look it up the other thing that

00:20:40,289 --> 00:20:45,179
I had to do to make this code more

00:20:43,320 --> 00:20:47,580
efficient this is an efficiency issue

00:20:45,179 --> 00:20:51,570
another correctness issue is adding

00:20:47,580 --> 00:20:53,399
those two currently braces here you

00:20:51,570 --> 00:20:55,460
should know that notifying condition not

00:20:53,399 --> 00:20:58,020
notifying of the condition variable

00:20:55,460 --> 00:21:01,350
doesn't need to happen under look right

00:20:58,020 --> 00:21:02,820
it's okay to do that but for beta

00:21:01,350 --> 00:21:07,740
scalability you don't want to hold the

00:21:02,820 --> 00:21:11,059
book for longer than necessary idiomatic

00:21:07,740 --> 00:21:15,200
code like this shouldn't be that hard

00:21:11,059 --> 00:21:16,919
and this is why scott Meyers in his book

00:21:15,200 --> 00:21:20,010
suggests that a sort of condition

00:21:16,919 --> 00:21:22,500
variable just use a future of void right

00:21:20,010 --> 00:21:26,190
for the reasons that I just stated okay

00:21:22,500 --> 00:21:28,289
and this the advantage of this approach

00:21:26,190 --> 00:21:31,080
is of course this code is correct by

00:21:28,289 --> 00:21:33,450
construction you write it it compiles

00:21:31,080 --> 00:21:35,429
and it will be correct right the

00:21:33,450 --> 00:21:37,730
additional upside here is that you can

00:21:35,429 --> 00:21:42,059
also traffic exceptions for a future

00:21:37,730 --> 00:21:43,350
that p-promise care can accept an

00:21:42,059 --> 00:21:45,289
exception you can you can't going to

00:21:43,350 --> 00:21:47,940
pass the exception throughout state

00:21:45,289 --> 00:21:50,580
there there's a couple of downsides here

00:21:47,940 --> 00:21:54,960
one is that the promise is not reusable

00:21:50,580 --> 00:21:57,960
so every time you try to use it again

00:21:54,960 --> 00:21:59,820
you wind up creating a new shirt state

00:21:57,960 --> 00:22:02,440
and that is as I mentioned previously is

00:21:59,820 --> 00:22:05,559
typically heap allocated

00:22:02,440 --> 00:22:06,940
now if you're writing an app and you

00:22:05,559 --> 00:22:09,820
know that this isn't going to be in the

00:22:06,940 --> 00:22:11,649
hot bath of your app then you can take

00:22:09,820 --> 00:22:14,980
that heat and that's okay right if

00:22:11,649 --> 00:22:17,139
you're writing a library or a low level

00:22:14,980 --> 00:22:18,580
with a usable component that it's much

00:22:17,139 --> 00:22:20,590
more difficult to make that judgment

00:22:18,580 --> 00:22:22,779
call right you always want to err on the

00:22:20,590 --> 00:22:26,129
side of let's be as efficient as

00:22:22,779 --> 00:22:30,610
possible and not take any performances

00:22:26,129 --> 00:22:32,919
enter latches and barriers the TS

00:22:30,610 --> 00:22:34,750
introduces three different types latch

00:22:32,919 --> 00:22:37,029
is a simple thread coordination

00:22:34,750 --> 00:22:39,580
mechanism that allows one or more

00:22:37,029 --> 00:22:42,549
threads to block until the condition in

00:22:39,580 --> 00:22:47,529
operation is completed barrier is

00:22:42,549 --> 00:22:52,539
similar but it can also be reused and if

00:22:47,529 --> 00:22:56,549
flex barrier takes a callback that gets

00:22:52,539 --> 00:22:59,470
notified when the when the latch opens

00:22:56,549 --> 00:23:03,460
this is how I would rewrite my previous

00:22:59,470 --> 00:23:07,029
example using the latch here I'm

00:23:03,460 --> 00:23:09,909
creating a latch of 11 is a counter here

00:23:07,029 --> 00:23:14,529
this is a number of times that detecting

00:23:09,909 --> 00:23:18,879
thread must call countdown okay and the

00:23:14,529 --> 00:23:22,389
waiting thread would call weight and the

00:23:18,879 --> 00:23:26,019
latch opens when account when the count

00:23:22,389 --> 00:23:27,730
reaches zero okay windows programmers

00:23:26,019 --> 00:23:30,070
are familiar with the concept of event

00:23:27,730 --> 00:23:34,450
right event is exactly like that it's a

00:23:30,070 --> 00:23:38,889
it's a larger count one how you can use

00:23:34,450 --> 00:23:41,559
it here is we are waiting for all tasks

00:23:38,889 --> 00:23:44,980
to finish I'm starting a bunch of tasks

00:23:41,559 --> 00:23:48,610
and i'm using a latch of task count

00:23:44,980 --> 00:23:50,649
every task when it finishes decrements

00:23:48,610 --> 00:23:54,220
the counter and then in the calling

00:23:50,649 --> 00:23:59,919
thread i'm waiting for the counter to

00:23:54,220 --> 00:24:01,600
reach zero okay another example I'm

00:23:59,919 --> 00:24:04,809
starting a bunch of tasks and then

00:24:01,600 --> 00:24:09,309
immediately freezing them waiting for

00:24:04,809 --> 00:24:12,129
the latch to open right in the meantime

00:24:09,309 --> 00:24:13,779
I'm preparing data for those tasks once

00:24:12,129 --> 00:24:17,169
the data is prepared

00:24:13,779 --> 00:24:18,549
look at this prepare data I'm unleashing

00:24:17,169 --> 00:24:22,659
all the tasks then they start doing the

00:24:18,549 --> 00:24:25,119
work so that's all what latches and bear

00:24:22,659 --> 00:24:26,409
is all about I'm not going to go a

00:24:25,119 --> 00:24:28,539
deeper into the difference between

00:24:26,409 --> 00:24:32,440
latches and beers but this gives you the

00:24:28,539 --> 00:24:37,960
overall idea and find any part number

00:24:32,440 --> 00:24:41,379
three atomic smart pointers most people

00:24:37,960 --> 00:24:44,320
are familiar with compare exchange this

00:24:41,379 --> 00:24:47,320
is a bread and butter of locally

00:24:44,320 --> 00:24:49,409
programming the idea a typical pattern

00:24:47,320 --> 00:24:52,419
is like this you read the original value

00:24:49,409 --> 00:24:54,999
you compute a new value and then you

00:24:52,419 --> 00:24:58,059
replace the old value with a new value

00:24:54,999 --> 00:24:59,859
that you've just computed if the old

00:24:58,059 --> 00:25:02,049
value hasn't changed and if it has

00:24:59,859 --> 00:25:07,389
changed in you repeat right this is what

00:25:02,049 --> 00:25:11,139
this while loop is doing and often when

00:25:07,389 --> 00:25:13,450
using when writing locally data

00:25:11,139 --> 00:25:16,119
structures you'll find yourself using a

00:25:13,450 --> 00:25:18,399
shared pointer right to to manage the

00:25:16,119 --> 00:25:23,649
lifetime of the notes in this example of

00:25:18,399 --> 00:25:25,629
a shirt hopefully list so there is a

00:25:23,649 --> 00:25:29,589
couple problems in this approach with

00:25:25,629 --> 00:25:31,690
what we doing today first of all it's

00:25:29,589 --> 00:25:37,359
it's Oprah you need to rely on

00:25:31,690 --> 00:25:40,989
developers discipline to always use an

00:25:37,359 --> 00:25:43,200
atomic operation whenever whenever you

00:25:40,989 --> 00:25:46,719
try to access the shared pointer right

00:25:43,200 --> 00:25:49,179
there is no currently there is no way to

00:25:46,719 --> 00:25:51,729
declare an atomic shirt pointer that's

00:25:49,179 --> 00:25:54,429
what this that's what this proposal is

00:25:51,729 --> 00:25:56,019
composing and the other problem is that

00:25:54,429 --> 00:25:59,669
it's it's pretty hard to implement

00:25:56,019 --> 00:26:02,679
atomic compared to change efficiently

00:25:59,669 --> 00:26:04,809
unless you are willing to penalize all

00:26:02,679 --> 00:26:06,759
users of shared pointer because a naive

00:26:04,809 --> 00:26:09,039
approach would be a let's just put an a

00:26:06,759 --> 00:26:11,589
spin lock or a mutex inside a shared

00:26:09,039 --> 00:26:14,859
pointer right but that would impose

00:26:11,589 --> 00:26:17,639
overhead when users who don't care about

00:26:14,859 --> 00:26:19,690
using shared pointers in an atomic way

00:26:17,639 --> 00:26:22,809
so for example a Microsoft

00:26:19,690 --> 00:26:24,759
implementation uses a single a global

00:26:22,809 --> 00:26:26,390
spin lock and you can imagine how

00:26:24,759 --> 00:26:29,000
scalable that is

00:26:26,390 --> 00:26:32,810
labe C++ is a little bit more

00:26:29,000 --> 00:26:36,110
sophisticated there's a hash of mutexes

00:26:32,810 --> 00:26:37,790
there's 16 your exes and then it is more

00:26:36,110 --> 00:26:39,650
scalable but there is more upfront cost

00:26:37,790 --> 00:26:44,510
in accessing the right metrics right so

00:26:39,650 --> 00:26:47,930
it is still a problematic with atomic

00:26:44,510 --> 00:26:51,440
shared pointers this problem is solved

00:26:47,930 --> 00:26:53,630
first of all the access to the object is

00:26:51,440 --> 00:26:57,430
guaranteed to the atomic just through

00:26:53,630 --> 00:27:00,260
the nature of the type and second

00:26:57,430 --> 00:27:02,780
operations like compare exchange now can

00:27:00,260 --> 00:27:05,660
be implemented more efficiently yes you

00:27:02,780 --> 00:27:07,520
can implement it by putting a mutex or

00:27:05,660 --> 00:27:09,710
spin lock inside an atomic shared

00:27:07,520 --> 00:27:11,750
pointer perhaps there are more efficient

00:27:09,710 --> 00:27:14,710
implementations but at least that would

00:27:11,750 --> 00:27:17,680
be better than what we have today and

00:27:14,710 --> 00:27:21,410
this brings me to the end of this talk

00:27:17,680 --> 00:27:23,540
for references I recommend first of all

00:27:21,410 --> 00:27:26,060
reading the latest concurrency th paper

00:27:23,540 --> 00:27:27,680
on this link you can snap pictures or

00:27:26,060 --> 00:27:31,310
the slides will be available so you can

00:27:27,680 --> 00:27:34,850
you can get that I I find it very useful

00:27:31,310 --> 00:27:37,820
to sometimes go back to the original

00:27:34,850 --> 00:27:39,820
papers and read the original papers that

00:27:37,820 --> 00:27:41,720
introduce the concepts because they have

00:27:39,820 --> 00:27:43,310
rationale they also seem a little bit

00:27:41,720 --> 00:27:45,830
naive in retrospect but at least they

00:27:43,310 --> 00:27:47,840
have the rationale that in later

00:27:45,830 --> 00:27:49,820
revisions of those papers tend to get

00:27:47,840 --> 00:27:54,530
lost and just replaced with standard

00:27:49,820 --> 00:27:56,840
ease so those three papers are the

00:27:54,530 --> 00:27:59,540
original papers that proposed the

00:27:56,840 --> 00:28:01,960
components of the GS and I also found

00:27:59,540 --> 00:28:04,790
this load by Anthony villains very

00:28:01,960 --> 00:28:08,120
useful in understanding why do we need

00:28:04,790 --> 00:28:12,770
to have a short winter so I have about

00:28:08,120 --> 00:28:15,880
10 seconds to spare I think and some

00:28:12,770 --> 00:28:15,880
time to answer questions

00:28:25,550 --> 00:28:46,080
the question yeah so the question was

00:28:43,820 --> 00:28:47,730
yeah the question was I told Mike

00:28:46,080 --> 00:28:49,350
SharePoint that sounds like a like a

00:28:47,730 --> 00:28:54,000
good idea but it's probably not going to

00:28:49,350 --> 00:28:55,770
be low free and the answer is you

00:28:54,000 --> 00:28:57,900
probably right it probably will not be

00:28:55,770 --> 00:28:59,460
locally there is a function called is

00:28:57,900 --> 00:29:03,840
locally that you can call and check

00:28:59,460 --> 00:29:05,340
whether it is locally right but what you

00:29:03,840 --> 00:29:06,690
really care about not whether it is not

00:29:05,340 --> 00:29:12,960
free or not but whether it is efficient

00:29:06,690 --> 00:29:14,520
to ski in scalable okay I don't see any

00:29:12,960 --> 00:29:18,860
more questions thank you for your

00:29:14,520 --> 00:29:18,860

YouTube URL: https://www.youtube.com/watch?v=mPxIegd9J3w


