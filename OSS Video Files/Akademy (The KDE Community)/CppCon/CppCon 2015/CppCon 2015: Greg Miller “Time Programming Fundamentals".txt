Title: CppCon 2015: Greg Miller “Time Programming Fundamentals"
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
"Time zones are logical and easy to use." -- No one ever

Time programming is notoriously difficult and error prone. Attempts at handling daylight-saving time, for example, often yield baffling code, which of course is explained by a similarly misguided comment. Programmer confusion can spread virally throughout the codebase when these misconceptions find their way into library interfaces.

The problem is not that dates and times are fundamentally complicated (though they are). The problem is the lack of a simplified mental model with library support. This would give programmers the concepts and vocabulary necessary to reason about and discuss these concepts, and the ability to express this reasoning in simple C++ terms.

In this talk I will show how date and time programming evolved into what it is today. I will present a greatly simplified mental model that applies to all programming languages. I will show clear examples using an open source C++ library that implements these simplified concepts. And I will present practical tips for proper time hygiene that should be used by everyone immediately.
— 
I design and implement C++ core libraries at Google. I work on Google's core strings libraries, as well as a Google's Time and Time Zone libraries.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,959
my name is Greg Miller and I'd like to

00:00:01,589 --> 00:00:05,759
thank you for showing up to this early 9

00:00:03,959 --> 00:00:09,450
a.m. talk about time programming

00:00:05,759 --> 00:00:11,370
fundamentals happily this isn't doesn't

00:00:09,450 --> 00:00:12,780
feel very early for me since I'm from

00:00:11,370 --> 00:00:13,700
the East Coast where it's already about

00:00:12,780 --> 00:00:16,800
lunchtime

00:00:13,700 --> 00:00:18,690
however despite that time difference if

00:00:16,800 --> 00:00:21,150
an East Coaster we're watching this talk

00:00:18,690 --> 00:00:24,720
right now we would still agree that the

00:00:21,150 --> 00:00:26,369
talk is happening now and these are the

00:00:24,720 --> 00:00:28,199
aspects of time and time programming

00:00:26,369 --> 00:00:32,279
that I'm going to be talking about today

00:00:28,199 --> 00:00:33,809
you might call it human scale time very

00:00:32,279 --> 00:00:36,180
briefly I'm not going to be talking

00:00:33,809 --> 00:00:38,340
about clocks or timekeeping or a time

00:00:36,180 --> 00:00:40,079
synchronization and since there's always

00:00:38,340 --> 00:00:41,760
some comedian in the room we're not

00:00:40,079 --> 00:00:46,289
going to be talking about space time or

00:00:41,760 --> 00:00:48,480
relativistic effects either I've worked

00:00:46,289 --> 00:00:50,700
at Google for about 10 years and I've

00:00:48,480 --> 00:00:52,530
watched Google's C++ code base grow to

00:00:50,700 --> 00:00:55,670
well over a hundred million lines of

00:00:52,530 --> 00:00:59,460
code some non-trivial fraction of that

00:00:55,670 --> 00:01:01,170
deals with time now Google's time code

00:00:59,460 --> 00:01:04,650
is no better or worse than anywhere else

00:01:01,170 --> 00:01:06,659
we think it's pretty typical and what we

00:01:04,650 --> 00:01:10,790
see is some of this code is very

00:01:06,659 --> 00:01:14,130
complicated some of it's obviously wrong

00:01:10,790 --> 00:01:16,580
some of it's subtly wrong and every once

00:01:14,130 --> 00:01:19,490
in a while some of it looks good and

00:01:16,580 --> 00:01:23,610
some of the reasons for this are that

00:01:19,490 --> 00:01:26,640
time zones are complicated calendars are

00:01:23,610 --> 00:01:29,280
complicated daylight savings time is

00:01:26,640 --> 00:01:31,079
very complicated it seems almost every

00:01:29,280 --> 00:01:33,659
six months there's some news article

00:01:31,079 --> 00:01:34,860
about some piece of technology that did

00:01:33,659 --> 00:01:37,259
the wrong thing during a daylight

00:01:34,860 --> 00:01:38,640
savings time transition we can probably

00:01:37,259 --> 00:01:41,340
look forward to that again in about a

00:01:38,640 --> 00:01:43,380
month and a half and programmers don't

00:01:41,340 --> 00:01:44,880
have a good workable mental model for

00:01:43,380 --> 00:01:47,460
how to think about and how to reason

00:01:44,880 --> 00:01:49,049
about time in their code and time

00:01:47,460 --> 00:01:52,649
programming libraries historically have

00:01:49,049 --> 00:01:54,570
been lacking in some areas so for the

00:01:52,649 --> 00:01:56,189
past couple years my colleague Bradley

00:01:54,570 --> 00:01:58,530
white and I have been working to fix

00:01:56,189 --> 00:02:00,719
these problems within Google and since

00:01:58,530 --> 00:02:02,909
we don't believe our problems are unique

00:02:00,719 --> 00:02:04,860
to Google we think our solutions might

00:02:02,909 --> 00:02:08,190
be useful to others outside of Google as

00:02:04,860 --> 00:02:10,020
well so before any meaningful

00:02:08,190 --> 00:02:12,270
communication can take place we need to

00:02:10,020 --> 00:02:13,980
agree on the vocabulary we're going to

00:02:12,270 --> 00:02:15,900
be using

00:02:13,980 --> 00:02:17,129
and then I'd like to move on and talk

00:02:15,900 --> 00:02:19,319
about some of the classic time

00:02:17,129 --> 00:02:20,849
programming api's that we've all used

00:02:19,319 --> 00:02:24,260
and have shaped most of the time

00:02:20,849 --> 00:02:27,360
programming code that we see today and

00:02:24,260 --> 00:02:30,269
then I want to give you a simple mental

00:02:27,360 --> 00:02:32,700
model that will help you reason about

00:02:30,269 --> 00:02:35,370
your code and think about time concepts

00:02:32,700 --> 00:02:37,950
and then I'd like to leave you with a

00:02:35,370 --> 00:02:40,410
handful of pro tips that you can start

00:02:37,950 --> 00:02:42,720
using today in your existing code to

00:02:40,410 --> 00:02:46,049
help improve and simplify your time

00:02:42,720 --> 00:02:49,530
programming so let's get started talking

00:02:46,049 --> 00:02:54,840
about a book at the vocabulary I'd like

00:02:49,530 --> 00:03:01,019
to talk about civil time UTC a boot time

00:02:54,840 --> 00:03:03,780
and time zone a civil time you can think

00:03:01,019 --> 00:03:05,010
of as just normal human time it's when

00:03:03,780 --> 00:03:06,150
someone asks you what time it is you

00:03:05,010 --> 00:03:09,269
look at your watch and you tell them

00:03:06,150 --> 00:03:11,549
it's 904 and that's a civil time a civil

00:03:09,269 --> 00:03:13,799
time is fundamentally six individual

00:03:11,549 --> 00:03:17,519
fields that represent the Year month day

00:03:13,799 --> 00:03:21,569
hour minute and second we typically use

00:03:17,519 --> 00:03:23,970
the Gregorian calendar and in programs

00:03:21,569 --> 00:03:26,519
civil times are typically represented by

00:03:23,970 --> 00:03:29,670
you know a type like a struck TM or a

00:03:26,519 --> 00:03:32,069
stood TM here or even a civil time could

00:03:29,670 --> 00:03:34,739
be six separate integers representing

00:03:32,069 --> 00:03:37,049
your month day hour minute second even a

00:03:34,739 --> 00:03:38,910
string like right here this string is

00:03:37,049 --> 00:03:44,840
still a civil time it's year month day

00:03:38,910 --> 00:03:47,730
hour minute second that brings us to UTC

00:03:44,840 --> 00:03:50,030
UTC is the predominant international

00:03:47,730 --> 00:03:53,670
time standard used throughout the world

00:03:50,030 --> 00:03:55,440
UTC is basically the the time the clock

00:03:53,670 --> 00:03:57,510
that we all synchronize our watches to

00:03:55,440 --> 00:03:59,970
and we use this to agree on what time it

00:03:57,510 --> 00:04:03,540
is it's the basis for all the local

00:03:59,970 --> 00:04:05,040
times around the world and UTC there is

00:04:03,540 --> 00:04:07,260
no daylight savings time there are no

00:04:05,040 --> 00:04:11,700
transitions every day has exactly 24

00:04:07,260 --> 00:04:13,889
hours and the UTC clock ticks si seconds

00:04:11,700 --> 00:04:15,989
so a second and UTC every second is

00:04:13,889 --> 00:04:19,169
exactly a fixed length defined by an

00:04:15,989 --> 00:04:21,510
atomic clock and UTC uses leap seconds

00:04:19,169 --> 00:04:23,880
so that the UTC clock kind of stays in

00:04:21,510 --> 00:04:26,419
sync with the solar clock where the Sun

00:04:23,880 --> 00:04:26,419
actually is

00:04:27,570 --> 00:04:32,340
and then I'd like now I'd like to talk

00:04:28,800 --> 00:04:35,730
about absolute time an absolute time

00:04:32,340 --> 00:04:40,140
uniquely and universally represents a

00:04:35,730 --> 00:04:41,640
specific instant in time this instant is

00:04:40,140 --> 00:04:43,800
something that everybody would agree on

00:04:41,640 --> 00:04:45,480
when the particular instant is the fact

00:04:43,800 --> 00:04:46,890
that this talk is happening right now it

00:04:45,480 --> 00:04:50,040
doesn't matter where you are where you

00:04:46,890 --> 00:04:53,100
may be watching this absolute x or x own

00:04:50,040 --> 00:04:56,400
independent absolute times are typically

00:04:53,100 --> 00:04:59,820
represented as account of some unit sent

00:04:56,400 --> 00:05:03,030
some epoch and classic examples that

00:04:59,820 --> 00:05:04,740
we're all familiar with are time T

00:05:03,030 --> 00:05:08,160
there's a great example of an absolute

00:05:04,740 --> 00:05:09,960
time in C++ did Chronos system clock

00:05:08,160 --> 00:05:12,330
time point is there a another good

00:05:09,960 --> 00:05:14,460
example or really you can have any

00:05:12,330 --> 00:05:16,680
integer counting something since some

00:05:14,460 --> 00:05:19,590
when would be a fine example of an

00:05:16,680 --> 00:05:21,150
absolute time and just to show the

00:05:19,590 --> 00:05:23,130
relationship between absolute and civil

00:05:21,150 --> 00:05:25,920
time if you think about when Neil

00:05:23,130 --> 00:05:28,770
Armstrong first took the very first step

00:05:25,920 --> 00:05:30,780
onto the moon that first step happened

00:05:28,770 --> 00:05:32,550
at some specific instant in time

00:05:30,780 --> 00:05:35,460
everybody would agree on when that

00:05:32,550 --> 00:05:37,200
happened but we're you or your parents

00:05:35,460 --> 00:05:38,640
were sitting in your living room and

00:05:37,200 --> 00:05:41,370
looking at the calendar on your wall and

00:05:38,640 --> 00:05:43,890
the clock on your wall this that's the

00:05:41,370 --> 00:05:45,780
civil time of for you when you saw that

00:05:43,890 --> 00:05:47,370
happen the civil times for where you

00:05:45,780 --> 00:05:49,440
work may be different for people all

00:05:47,370 --> 00:05:51,630
around the world but he didn't take this

00:05:49,440 --> 00:05:53,730
his first step again an hour later for

00:05:51,630 --> 00:05:58,710
the people one timezone over that

00:05:53,730 --> 00:06:00,120
happened exactly once and then this

00:05:58,710 --> 00:06:02,580
brings us to time zones

00:06:00,120 --> 00:06:05,610
time zones are how we relate absolute

00:06:02,580 --> 00:06:07,140
times in civil times time zones give us

00:06:05,610 --> 00:06:10,680
the rules for converting between

00:06:07,140 --> 00:06:15,120
absolute and civil times these rules are

00:06:10,680 --> 00:06:18,090
defined as offsets from UTC these rules

00:06:15,120 --> 00:06:21,290
can change over time so this notion of a

00:06:18,090 --> 00:06:23,370
time zone includes a whole history of

00:06:21,290 --> 00:06:26,490
potentially different time zone rules

00:06:23,370 --> 00:06:28,020
for different periods of time these time

00:06:26,490 --> 00:06:29,550
zone rules are established by local

00:06:28,020 --> 00:06:33,900
governments so sometimes they can be

00:06:29,550 --> 00:06:36,000
quite complicated and many time zones

00:06:33,900 --> 00:06:37,710
use daylight savings time rules so they

00:06:36,000 --> 00:06:40,110
staged their offset throughout the year

00:06:37,710 --> 00:06:41,199
and these strings in green down here are

00:06:40,110 --> 00:06:43,300
examples of Val

00:06:41,199 --> 00:06:45,789
good timezone identifier x' they're

00:06:43,300 --> 00:06:47,889
typically represented like a continent

00:06:45,789 --> 00:06:49,779
and a major city in a certain area so

00:06:47,889 --> 00:06:51,460
America New York the timezone we're

00:06:49,779 --> 00:06:54,279
currently in right now is called America

00:06:51,460 --> 00:06:56,740
Los Angeles Australia Sydney is another

00:06:54,279 --> 00:06:58,210
one PST we typically think of this

00:06:56,740 --> 00:07:00,129
Pacific Standard Time that's not a

00:06:58,210 --> 00:07:04,210
timezone identifier it's not a valid

00:07:00,129 --> 00:07:07,990
timezone identifier now some interesting

00:07:04,210 --> 00:07:09,580
time transitions so we'd like to think

00:07:07,990 --> 00:07:11,139
that time transitions happen like

00:07:09,580 --> 00:07:13,569
daylight savings time is like an hour

00:07:11,139 --> 00:07:16,419
you know spring forward fall back that's

00:07:13,569 --> 00:07:17,889
not really not how it's not how it

00:07:16,419 --> 00:07:19,889
always works for instance in the United

00:07:17,889 --> 00:07:22,120
States even you know the Arizona Phoenix

00:07:19,889 --> 00:07:26,110
timezone doesn't use daylight savings

00:07:22,120 --> 00:07:27,969
time Asia Katmandu jumped 15 minutes in

00:07:26,110 --> 00:07:30,310
1986 and that was not because of

00:07:27,969 --> 00:07:32,499
daylight savings time so you can have

00:07:30,310 --> 00:07:35,080
time transitions that are not because of

00:07:32,499 --> 00:07:37,360
daylight savings time and Australia Lord

00:07:35,080 --> 00:07:39,219
Howe uses a 30 minute daylight savings

00:07:37,360 --> 00:07:41,439
time offset so even if you think that

00:07:39,219 --> 00:07:45,539
daylight savings time is in effect it's

00:07:41,439 --> 00:07:48,520
not always 60 minutes and Pacific a Pia

00:07:45,539 --> 00:07:50,110
in 2011 they skipped the whole day of

00:07:48,520 --> 00:07:52,960
December 30th it just doesn't exist

00:07:50,110 --> 00:07:53,860
there and in that particular case they

00:07:52,960 --> 00:07:57,330
were switching sides of the

00:07:53,860 --> 00:08:00,189
International Dateline and Africa Cairo

00:07:57,330 --> 00:08:01,810
used to skip the midnight hour during

00:08:00,189 --> 00:08:03,909
their springtime daylight savings time

00:08:01,810 --> 00:08:05,409
transition as actually as of this year

00:08:03,909 --> 00:08:07,300
they no longer do that they no longer

00:08:05,409 --> 00:08:09,909
observed daylight savings time but

00:08:07,300 --> 00:08:12,639
previously before last year

00:08:09,909 --> 00:08:14,830
they're before this year there was no

00:08:12,639 --> 00:08:17,560
midnight on this day there was no you

00:08:14,830 --> 00:08:19,960
know 0 hours 0 minutes 0 seconds on this

00:08:17,560 --> 00:08:22,089
during this transition and African

00:08:19,960 --> 00:08:24,219
Monrovia used to use an offset of 44

00:08:22,089 --> 00:08:26,439
minutes and 30 seconds so transitions

00:08:24,219 --> 00:08:28,779
aren't always a nice round number

00:08:26,439 --> 00:08:31,779
so the takeaway I'd like you to remember

00:08:28,779 --> 00:08:32,740
here is don't try to special case time

00:08:31,779 --> 00:08:34,630
zone transitions

00:08:32,740 --> 00:08:36,039
don't try to like write code to say ok I

00:08:34,630 --> 00:08:37,719
know there's a transition let me figure

00:08:36,039 --> 00:08:40,630
out what I'm supposed to do there's over

00:08:37,719 --> 00:08:43,060
500 time zones there is updates to time

00:08:40,630 --> 00:08:45,040
zone data maybe about 8 times a year so

00:08:43,060 --> 00:08:49,480
it's way too complicated to try to write

00:08:45,040 --> 00:08:51,069
that special case code yourself and now

00:08:49,480 --> 00:08:53,260
that we have a vocabulary let's look at

00:08:51,069 --> 00:08:54,670
a very common way we represent times in

00:08:53,260 --> 00:08:56,530
computer programs

00:08:54,670 --> 00:08:58,210
as a string and let's just kind of

00:08:56,530 --> 00:09:01,150
figure out what's in this string let's

00:08:58,210 --> 00:09:03,160
diagram it so these first three fields

00:09:01,150 --> 00:09:05,020
here give us a date and here's a time

00:09:03,160 --> 00:09:07,000
and together we know that's a civil time

00:09:05,020 --> 00:09:09,700
it's six fields your month day hour

00:09:07,000 --> 00:09:12,460
minute second and this green number here

00:09:09,700 --> 00:09:15,010
is a minus seven hours here this

00:09:12,460 --> 00:09:17,950
represents an offset from UTC so this

00:09:15,010 --> 00:09:19,960
kind of tape takes the you know place of

00:09:17,950 --> 00:09:21,970
like a time zone and this whole thing

00:09:19,960 --> 00:09:24,040
together a civil time with this offset

00:09:21,970 --> 00:09:25,960
gives me an absolute time so this whole

00:09:24,040 --> 00:09:28,390
string here represents a specific

00:09:25,960 --> 00:09:30,480
instant in time it doesn't matter what

00:09:28,390 --> 00:09:35,980
time zone you're in this string

00:09:30,480 --> 00:09:37,180
represents a specific instant in time so

00:09:35,980 --> 00:09:41,170
now I'd like to talk about some of the

00:09:37,180 --> 00:09:42,910
classic time programming AP is not a

00:09:41,170 --> 00:09:45,160
whole lot here hopefully most of this

00:09:42,910 --> 00:09:46,840
will be review review for people but

00:09:45,160 --> 00:09:48,070
these are the classic time AP eyes

00:09:46,840 --> 00:09:50,770
they're still with us today

00:09:48,070 --> 00:09:53,860
these api's have shaped most of the

00:09:50,770 --> 00:09:55,480
modern time in timezone libraries that

00:09:53,860 --> 00:09:57,520
exist today and lots of the time code

00:09:55,480 --> 00:09:59,230
that exists today and fundamentally

00:09:57,520 --> 00:10:01,990
they're based around this type called

00:09:59,230 --> 00:10:05,380
time T and a time T is a count of

00:10:01,990 --> 00:10:09,040
non-leap seconds since January 1st 1970

00:10:05,380 --> 00:10:11,800
0 hours 0 minutes 0 seconds in UTC so a

00:10:09,040 --> 00:10:14,290
time T value of zero represents this

00:10:11,800 --> 00:10:15,850
date and time right up here that date

00:10:14,290 --> 00:10:19,590
and time we typically refer to as the

00:10:15,850 --> 00:10:24,370
UNIX epoch so you may hear me say that

00:10:19,590 --> 00:10:26,950
and a stood TM or a struck TM this

00:10:24,370 --> 00:10:28,690
represents a broken down year month day

00:10:26,950 --> 00:10:30,610
hour minute second there's a handful of

00:10:28,690 --> 00:10:32,320
other fields in there as well but

00:10:30,610 --> 00:10:35,380
fundamentally a time T is an absolute

00:10:32,320 --> 00:10:38,680
time and a struck TM is a simple time

00:10:35,380 --> 00:10:41,170
and we're also given two time zones with

00:10:38,680 --> 00:10:44,860
which we can work we can work in the UTC

00:10:41,170 --> 00:10:46,720
time zone or the local time zone and the

00:10:44,860 --> 00:10:50,260
functions we have are to go from a time

00:10:46,720 --> 00:10:52,990
T to a TM we have this GM time function

00:10:50,260 --> 00:10:54,580
and in the if we want to do that in the

00:10:52,990 --> 00:10:56,680
local time zone we have a local time

00:10:54,580 --> 00:10:59,230
function that will map from a time T to

00:10:56,680 --> 00:11:01,150
a TM if we want to go the other

00:10:59,230 --> 00:11:03,460
direction in the local time zone we can

00:11:01,150 --> 00:11:05,740
call Mick time to go from a TM to a time

00:11:03,460 --> 00:11:07,900
T and in UTC there's really no

00:11:05,740 --> 00:11:08,170
corresponding function for us but that's

00:11:07,900 --> 00:11:10,540
B

00:11:08,170 --> 00:11:12,370
because in UTC since there's no offset

00:11:10,540 --> 00:11:14,380
transitions you can actually just do

00:11:12,370 --> 00:11:18,160
arithmetic with the fields of the TM in

00:11:14,380 --> 00:11:20,410
order to get the absolute time so I just

00:11:18,160 --> 00:11:22,600
want to look at a quick example of these

00:11:20,410 --> 00:11:25,120
using these classic api's there's

00:11:22,600 --> 00:11:26,709
nothing new or fancy here so there

00:11:25,120 --> 00:11:29,170
shouldn't be anything too surprising I'm

00:11:26,709 --> 00:11:30,910
assuming some format function that just

00:11:29,170 --> 00:11:32,740
takes some format string and a stood

00:11:30,910 --> 00:11:35,970
struck TM you could imagine this is

00:11:32,740 --> 00:11:38,620
implemented with stir f time or put time

00:11:35,970 --> 00:11:43,149
but this example here let's just look

00:11:38,620 --> 00:11:45,010
again we're gonna be creating a time T

00:11:43,149 --> 00:11:47,889
called now that represents the current

00:11:45,010 --> 00:11:50,529
time that the current absolute time in

00:11:47,889 --> 00:11:53,079
this first block here I'm gonna use this

00:11:50,529 --> 00:11:55,870
GM time underscore R function that takes

00:11:53,079 --> 00:11:58,149
the current time and fills in the struck

00:11:55,870 --> 00:12:00,399
TM with the year-month-day fields the

00:11:58,149 --> 00:12:02,290
civil time fields that represent the

00:12:00,399 --> 00:12:04,839
correspond to this current time and I'm

00:12:02,290 --> 00:12:06,579
just gonna format it for this percent F

00:12:04,839 --> 00:12:09,370
is shorthand for a year month day

00:12:06,579 --> 00:12:10,810
separated by hyphens and % T here is

00:12:09,370 --> 00:12:14,980
shorthand for our minute second

00:12:10,810 --> 00:12:16,660
separated by colons down here this last

00:12:14,980 --> 00:12:18,730
block here we just you do the same thing

00:12:16,660 --> 00:12:20,440
but we use the local time function and

00:12:18,730 --> 00:12:23,019
we'll just break down the current time

00:12:20,440 --> 00:12:24,519
in the local time zone and we'll fill in

00:12:23,019 --> 00:12:27,579
this truck TM and we'll just go ahead

00:12:24,519 --> 00:12:30,010
and print that as well and now this is

00:12:27,579 --> 00:12:32,170
all fine it works works perfectly well

00:12:30,010 --> 00:12:34,750
the problem is the fact that there's

00:12:32,170 --> 00:12:37,089
only support for two time zones yet many

00:12:34,750 --> 00:12:39,209
time zones exist and the fact that many

00:12:37,089 --> 00:12:41,649
times does exist has led to many

00:12:39,209 --> 00:12:43,870
potentially complicated workarounds to

00:12:41,649 --> 00:12:46,300
support all these different time zones

00:12:43,870 --> 00:12:48,579
and most of these workarounds boil down

00:12:46,300 --> 00:12:50,589
to a technique that we call epoch

00:12:48,579 --> 00:12:52,959
shifting and we're going to go ahead and

00:12:50,589 --> 00:12:56,670
look at that now so let's see how we can

00:12:52,959 --> 00:12:59,440
add support for arbitrary time zones

00:12:56,670 --> 00:13:01,180
most examples of epoch shifting boiled

00:12:59,440 --> 00:13:03,519
down to a function that looks like this

00:13:01,180 --> 00:13:04,959
one right here I'm calling it get offset

00:13:03,519 --> 00:13:08,920
they're typically named something like

00:13:04,959 --> 00:13:11,290
get offset they take it takes a time in

00:13:08,920 --> 00:13:13,060
absolute time and some indicator of a

00:13:11,290 --> 00:13:15,399
time zone in this case I'll be Pett

00:13:13,060 --> 00:13:17,890
we're passing a string to indicate the

00:13:15,399 --> 00:13:21,100
time zone name and it says in this time

00:13:17,890 --> 00:13:21,889
zone at this time what's the offset so

00:13:21,100 --> 00:13:24,439
that's the fun

00:13:21,889 --> 00:13:26,869
get off set function now let's see what

00:13:24,439 --> 00:13:30,079
we're doing again we get the current

00:13:26,869 --> 00:13:33,259
time now this first block here I want to

00:13:30,079 --> 00:13:36,230
say I could call get off set in America

00:13:33,259 --> 00:13:38,600
New York at now at the current time give

00:13:36,230 --> 00:13:40,369
me the current offset then I'm going to

00:13:38,600 --> 00:13:42,439
take that offset and I'm gonna add it to

00:13:40,369 --> 00:13:46,609
now and I'm gonna store it in another

00:13:42,439 --> 00:13:48,619
variable here I'm calling now NYC and

00:13:46,609 --> 00:13:50,600
then I call this GM time function this

00:13:48,619 --> 00:13:52,369
these three lines here just like they

00:13:50,600 --> 00:13:55,489
were in the previous slide I break down

00:13:52,369 --> 00:13:57,319
at now NYC and I fill in the struck TM

00:13:55,489 --> 00:13:58,939
and I'm gonna go ahead and format the

00:13:57,319 --> 00:14:02,899
time the year month day hour minute

00:13:58,939 --> 00:14:05,839
second in New York City now I want to go

00:14:02,899 --> 00:14:09,679
back the other direction so given my now

00:14:05,839 --> 00:14:12,470
NYC my local time T I say get off set

00:14:09,679 --> 00:14:15,319
for this time now NYC again in America

00:14:12,470 --> 00:14:17,059
New York and since previously I added

00:14:15,319 --> 00:14:18,319
the offset here I'm gonna go ahead and

00:14:17,059 --> 00:14:21,470
subtract the off stick so I'm trying to

00:14:18,319 --> 00:14:24,379
undo this operation and I get now UTC

00:14:21,470 --> 00:14:26,899
and so the question here is are these

00:14:24,379 --> 00:14:28,699
two guaranteed to be equal that's one of

00:14:26,899 --> 00:14:29,600
my questions well let's go ahead and

00:14:28,699 --> 00:14:32,569
take a look at some of the other

00:14:29,600 --> 00:14:33,949
problems that we see with this code I'm

00:14:32,569 --> 00:14:37,489
gonna say the most fundamental problem

00:14:33,949 --> 00:14:41,209
here is that now NYC is not really a

00:14:37,489 --> 00:14:42,649
time T you let me explain there's two

00:14:41,209 --> 00:14:45,290
ways I can think about what I'm doing

00:14:42,649 --> 00:14:49,790
here I'm taking now and I'm adding an

00:14:45,290 --> 00:14:52,009
offset to it so either now NYC doesn't

00:14:49,790 --> 00:14:54,319
represent now it represents some other

00:14:52,009 --> 00:14:56,989
time some other time that's you know

00:14:54,319 --> 00:14:59,569
offset seconds or whatever away from now

00:14:56,989 --> 00:15:01,369
so it doesn't represent now or I could

00:14:59,569 --> 00:15:04,189
say well I'm gonna pretend it actually

00:15:01,369 --> 00:15:07,069
does represent now and I've just shifted

00:15:04,189 --> 00:15:09,829
the epoch instead of the actual instant

00:15:07,069 --> 00:15:12,999
in time and so if we look at how this

00:15:09,829 --> 00:15:16,069
code is being used it's named now NYC

00:15:12,999 --> 00:15:18,529
these clearly the intent of this code is

00:15:16,069 --> 00:15:20,629
that this point represents now just in

00:15:18,529 --> 00:15:22,789
some other time zone so what's happened

00:15:20,629 --> 00:15:25,489
here is I've shifted the epoch but at

00:15:22,789 --> 00:15:28,579
time T is defined to have an epoch from

00:15:25,489 --> 00:15:30,589
a specific a specific epoch so if I

00:15:28,579 --> 00:15:32,959
shift that epoch it's not really a time

00:15:30,589 --> 00:15:35,449
T this should be a different type I

00:15:32,959 --> 00:15:38,720
should call this a my time T or

00:15:35,449 --> 00:15:40,910
NYC time T for example is what perhaps

00:15:38,720 --> 00:15:42,709
is what I should call that but I don't I

00:15:40,910 --> 00:15:44,629
call it time T because this function I'm

00:15:42,709 --> 00:15:47,480
calling right here GM time expects the

00:15:44,629 --> 00:15:51,079
time T so I put it in the time T anyway

00:15:47,480 --> 00:15:54,949
and then what's another problem what is

00:15:51,079 --> 00:15:57,019
this offset so as the person writing

00:15:54,949 --> 00:15:58,759
this code I have to be somewhat of a

00:15:57,019 --> 00:16:00,799
time expert because I have to understand

00:15:58,759 --> 00:16:04,549
what is this offset is this an offset

00:16:00,799 --> 00:16:05,689
from UTC to me or from me to UTC and I

00:16:04,549 --> 00:16:07,189
need to know that because I need to

00:16:05,689 --> 00:16:09,739
figure out whether I add or subtract

00:16:07,189 --> 00:16:11,989
here we've seen lots of code that you

00:16:09,739 --> 00:16:14,989
know it looks right except this sign is

00:16:11,989 --> 00:16:16,279
wrong so it's not immediately clear

00:16:14,989 --> 00:16:19,100
whether you're supposed to add or

00:16:16,279 --> 00:16:22,160
subtract this thing additionally when I

00:16:19,100 --> 00:16:24,319
break down this now NYC using this

00:16:22,160 --> 00:16:26,839
function GM time are some of the fields

00:16:24,319 --> 00:16:29,119
in the struct e/m aren't correct for

00:16:26,839 --> 00:16:31,100
example is DST will always be false

00:16:29,119 --> 00:16:34,730
since UTC doesn't have any daylight

00:16:31,100 --> 00:16:36,739
savings time and another big problem is

00:16:34,730 --> 00:16:40,939
this block down here doesn't actually

00:16:36,739 --> 00:16:42,769
work so what we're doing here is we're

00:16:40,939 --> 00:16:46,669
calling get offset but we and we're

00:16:42,769 --> 00:16:48,769
passing in now NYC we previously just

00:16:46,669 --> 00:16:51,799
said up top here that now and YC isn't

00:16:48,769 --> 00:16:53,929
really a time T we're calling it a time

00:16:51,799 --> 00:16:56,329
T but it's not really a time T but get

00:16:53,929 --> 00:16:58,279
offset expects a time T so if I pass

00:16:56,329 --> 00:16:59,720
something that's not really a time T get

00:16:58,279 --> 00:17:02,829
offset may not return the right value

00:16:59,720 --> 00:17:04,730
and in fact four times that are near

00:17:02,829 --> 00:17:06,889
discontinuity some type of you know

00:17:04,730 --> 00:17:09,829
offset transition it actually will give

00:17:06,889 --> 00:17:11,659
you the wrong answer and so I'll say

00:17:09,829 --> 00:17:13,429
that this the you know answering my

00:17:11,659 --> 00:17:14,600
question before was is is this

00:17:13,429 --> 00:17:16,760
guaranteed to always be equal and the

00:17:14,600 --> 00:17:18,919
answer is no it's not it will sometimes

00:17:16,760 --> 00:17:20,539
and maybe when you're writing the code

00:17:18,919 --> 00:17:22,490
and you're testing the code it's the

00:17:20,539 --> 00:17:26,000
same but then when you deploy and run

00:17:22,490 --> 00:17:27,769
the code whoops it's wrong sometimes so

00:17:26,000 --> 00:17:29,059
the takeaway here is I want you to

00:17:27,769 --> 00:17:31,610
remember that there's really no such

00:17:29,059 --> 00:17:33,950
thing as a local time T there's a time T

00:17:31,610 --> 00:17:38,809
that's a valid actual time T and there's

00:17:33,950 --> 00:17:42,590
really not a local time T so now I'd

00:17:38,809 --> 00:17:45,049
like to give you a simplified mental

00:17:42,590 --> 00:17:47,539
model for that will help you think about

00:17:45,049 --> 00:17:49,070
time concepts and reason about your code

00:17:47,539 --> 00:17:52,040
and I

00:17:49,070 --> 00:17:53,720
hope that when you see this model that

00:17:52,040 --> 00:17:57,410
I'm gonna show you here you look at it

00:17:53,720 --> 00:18:01,520
and say oh that's it well duh that's so

00:17:57,410 --> 00:18:04,640
obvious and hopefully it's unsurprising

00:18:01,520 --> 00:18:06,160
that it only has the same vocabulary

00:18:04,640 --> 00:18:08,390
that we've already been talking about

00:18:06,160 --> 00:18:10,040
and what this is here is this is just

00:18:08,390 --> 00:18:11,810
showing the relationship between these

00:18:10,040 --> 00:18:14,300
things and formalizing the relationship

00:18:11,810 --> 00:18:16,100
between these concepts there's the

00:18:14,300 --> 00:18:18,380
concept of an absolute time which we've

00:18:16,100 --> 00:18:20,540
already been talking about there's the

00:18:18,380 --> 00:18:23,000
concept of a civil time which we've been

00:18:20,540 --> 00:18:25,280
talking about and the time zone is all

00:18:23,000 --> 00:18:27,230
the rules to relate these things you can

00:18:25,280 --> 00:18:29,270
imagine for some function f of an

00:18:27,230 --> 00:18:32,120
absolute time in a time zone you can

00:18:29,270 --> 00:18:34,490
compute a civil time and for some other

00:18:32,120 --> 00:18:36,290
function f of a civil time at a time

00:18:34,490 --> 00:18:39,440
zone you can compute an absolute time

00:18:36,290 --> 00:18:41,990
the domain of all the absolute times our

00:18:39,440 --> 00:18:43,670
time zone independent same with civil

00:18:41,990 --> 00:18:45,020
times the whole domain of all the civil

00:18:43,670 --> 00:18:46,670
times are themselves time zone

00:18:45,020 --> 00:18:47,900
independent time zones are only

00:18:46,670 --> 00:18:51,620
important when you want to map between

00:18:47,900 --> 00:18:53,450
the two and so this model actually

00:18:51,620 --> 00:18:57,070
applies to any programming language in

00:18:53,450 --> 00:18:59,500
any date time library you may be using

00:18:57,070 --> 00:19:01,370
and now since I said this is simple I

00:18:59,500 --> 00:19:03,140
should probably point out what's missing

00:19:01,370 --> 00:19:05,210
it's probably simple because it's

00:19:03,140 --> 00:19:07,160
missing a few things so what it's

00:19:05,210 --> 00:19:09,440
missing are the fact that these time

00:19:07,160 --> 00:19:11,660
zones are opaque you can't take these

00:19:09,440 --> 00:19:14,000
time zones and say give me the offset at

00:19:11,660 --> 00:19:16,250
some point in time because we don't want

00:19:14,000 --> 00:19:17,840
you to do any Epoque shifting you

00:19:16,250 --> 00:19:19,820
shouldn't have to take that offset and

00:19:17,840 --> 00:19:22,430
add it to anything or do any arithmetic

00:19:19,820 --> 00:19:25,070
to it that's what a time zone library is

00:19:22,430 --> 00:19:27,230
supposed to do for you so there's no

00:19:25,070 --> 00:19:29,270
access to offsets no local seconds

00:19:27,230 --> 00:19:32,920
there's no access to the future and past

00:19:29,270 --> 00:19:35,480
transitions and when I think about these

00:19:32,920 --> 00:19:37,160
missing features you know this is Ken

00:19:35,480 --> 00:19:39,110
Thompson one of the principal inventors

00:19:37,160 --> 00:19:42,500
of UNIX that you know he was once asked

00:19:39,110 --> 00:19:43,910
about the UNIX file API and the question

00:19:42,500 --> 00:19:45,140
was about you know well where's this

00:19:43,910 --> 00:19:46,580
feature and how do you do this and

00:19:45,140 --> 00:19:47,900
where's all this you know record support

00:19:46,580 --> 00:19:49,940
and where how come it's missing all

00:19:47,900 --> 00:19:58,150
these things and his response was these

00:19:49,940 --> 00:19:59,740
concepts fill a much needed gap and so

00:19:58,150 --> 00:20:02,289
let's take a look and see how these

00:19:59,740 --> 00:20:03,669
classic api's fit into this model so

00:20:02,289 --> 00:20:05,980
I've written some of the some of the

00:20:03,669 --> 00:20:08,110
types and functions here green I think

00:20:05,980 --> 00:20:10,840
these are pretty good fit a time T is a

00:20:08,110 --> 00:20:12,730
is a fine absolute time then it only has

00:20:10,840 --> 00:20:14,950
you know second granularity but that

00:20:12,730 --> 00:20:16,690
might be fine in some cases stood front

00:20:14,950 --> 00:20:19,960
a system clock time point it's another

00:20:16,690 --> 00:20:22,240
that's great fits very well the things I

00:20:19,960 --> 00:20:25,000
wrote in red here I'll say you know

00:20:22,240 --> 00:20:26,590
there they fit but they could be

00:20:25,000 --> 00:20:28,240
improved so for time zones

00:20:26,590 --> 00:20:29,919
there's only support for UTC and local

00:20:28,240 --> 00:20:33,220
time so we could probably improve that

00:20:29,919 --> 00:20:35,830
and for civil time there's the struck TM

00:20:33,220 --> 00:20:37,570
which works for a civil time it leaves a

00:20:35,830 --> 00:20:39,730
little bit to be desired the years or

00:20:37,570 --> 00:20:41,620
offsets from 1900 the months or zero

00:20:39,730 --> 00:20:44,710
index so it's not the easiest thing to

00:20:41,620 --> 00:20:46,120
work with and for again for going from

00:20:44,710 --> 00:20:48,399
absolute to civil we have this local

00:20:46,120 --> 00:20:50,289
time function and civil to absolute we

00:20:48,399 --> 00:20:52,450
have make time and again those work just

00:20:50,289 --> 00:20:56,799
in the civil or I'm sorry the local time

00:20:52,450 --> 00:21:01,270
zone and so to try to fix these problems

00:20:56,799 --> 00:21:03,039
within Google we tried we built a new

00:21:01,270 --> 00:21:06,520
time zone library that very closely

00:21:03,039 --> 00:21:10,570
matches this model we call it CCTV for

00:21:06,520 --> 00:21:12,159
the C++ time zone library and in blue

00:21:10,570 --> 00:21:15,730
here here's some of the types and how we

00:21:12,159 --> 00:21:18,070
this library maps it into this model for

00:21:15,730 --> 00:21:20,049
absolute times we have the CCT Z time

00:21:18,070 --> 00:21:22,210
point now this is pretty much just a

00:21:20,049 --> 00:21:24,429
system clock time point is defined only

00:21:22,210 --> 00:21:27,730
for the system clock it just has a wider

00:21:24,429 --> 00:21:30,340
range as 128 bits of range to avoid the

00:21:27,730 --> 00:21:34,059
292 Year issue because within Google we

00:21:30,340 --> 00:21:36,549
wanted actually one time type but it

00:21:34,059 --> 00:21:39,340
implicitly converts from a system clock

00:21:36,549 --> 00:21:42,309
time point timezone is represented by

00:21:39,340 --> 00:21:44,380
the CCT z time zone class all these

00:21:42,309 --> 00:21:47,529
things are in this namespace so time

00:21:44,380 --> 00:21:50,230
zone can represent any timezone a civil

00:21:47,529 --> 00:21:52,179
time is represented by a c c TZ break

00:21:50,230 --> 00:21:54,399
down you can think of it just kind of

00:21:52,179 --> 00:21:56,380
like I want to say a better struck TM it

00:21:54,399 --> 00:21:58,809
has the civil time components your month

00:21:56,380 --> 00:22:02,080
day hour minute second and a few other

00:21:58,809 --> 00:22:04,029
fields that we'll see in a moment and to

00:22:02,080 --> 00:22:06,909
go from an absolute time to a civil time

00:22:04,029 --> 00:22:08,350
there is the break time function and to

00:22:06,909 --> 00:22:10,679
go the other direction from civil to

00:22:08,350 --> 00:22:12,070
absolute there's the make time function

00:22:10,679 --> 00:22:13,660
and we're going to

00:22:12,070 --> 00:22:15,790
look and take a look and see how these

00:22:13,660 --> 00:22:18,930
things work in some examples and let's

00:22:15,790 --> 00:22:28,330
starting off with a hello cc TZ example

00:22:18,930 --> 00:22:37,390
yes I'm not assuming daylight savings

00:22:28,330 --> 00:22:39,460
time is on so the question is about

00:22:37,390 --> 00:22:41,620
conversions with daylight savings time

00:22:39,460 --> 00:22:44,080
and I have a slide in about two slides

00:22:41,620 --> 00:22:45,400
we will definitely cover that so just

00:22:44,080 --> 00:22:48,460
hold tight please

00:22:45,400 --> 00:22:50,200
so hello CCT Z's so this I just want to

00:22:48,460 --> 00:22:53,500
show to give you kind of a feel for the

00:22:50,200 --> 00:22:55,270
API you know we did this in Google's

00:22:53,500 --> 00:22:56,830
programming style conventions you may or

00:22:55,270 --> 00:23:00,280
may not like that please don't crucify

00:22:56,830 --> 00:23:01,300
me but that's how it's done here so most

00:23:00,280 --> 00:23:02,260
of this code is going to start off

00:23:01,300 --> 00:23:04,210
looking the same

00:23:02,260 --> 00:23:05,920
we're going to do we want to time zone

00:23:04,210 --> 00:23:08,530
I'm going to declare a time zone for

00:23:05,920 --> 00:23:10,630
Sydney Australia I declare this variable

00:23:08,530 --> 00:23:13,450
I call the function load time zone

00:23:10,630 --> 00:23:15,550
I tell it Australia Sydney I pass in a

00:23:13,450 --> 00:23:17,590
pointer to the time zone object load

00:23:15,550 --> 00:23:20,560
time zone will return bull if it you

00:23:17,590 --> 00:23:22,480
know indicating success or failure it

00:23:20,560 --> 00:23:24,490
will load the file it will load the time

00:23:22,480 --> 00:23:26,440
zone from the time zone data on disk

00:23:24,490 --> 00:23:27,310
usually on Linux that's like user share

00:23:26,440 --> 00:23:29,230
zone info

00:23:27,310 --> 00:23:33,400
it'll also then cache it so subsequent

00:23:29,230 --> 00:23:34,900
calls to this are very fast then here

00:23:33,400 --> 00:23:37,180
we're going to call make time and I'm

00:23:34,900 --> 00:23:39,640
gonna to make time I'm gonna pass six

00:23:37,180 --> 00:23:42,160
fields and we probably know what these

00:23:39,640 --> 00:23:44,610
six fields are they're a simple time so

00:23:42,160 --> 00:23:47,410
I'm gonna say 1969 July 21st

00:23:44,610 --> 00:23:50,350
12:56 in the afternoon zero seconds in

00:23:47,410 --> 00:23:51,760
Sydney Australia and we know that from

00:23:50,350 --> 00:23:53,980
our model when we think back to the

00:23:51,760 --> 00:23:56,080
mental model a civil time and a time

00:23:53,980 --> 00:23:57,580
zone gives me an absolute time and

00:23:56,080 --> 00:23:59,680
that's what make time is doing right

00:23:57,580 --> 00:24:01,780
here so this gives me the absolute time

00:23:59,680 --> 00:24:03,550
for when Neil Armstrong first walked on

00:24:01,780 --> 00:24:05,410
the moon that's the absolute time when

00:24:03,550 --> 00:24:06,550
that happened and then I'm just going to

00:24:05,410 --> 00:24:09,520
come down here and I'm going to call

00:24:06,550 --> 00:24:11,980
CCTV format again this is just this is

00:24:09,520 --> 00:24:14,470
very similar to stir f time except

00:24:11,980 --> 00:24:16,120
there's a few extended format specifiers

00:24:14,470 --> 00:24:19,240
that i won't be talking about but are

00:24:16,120 --> 00:24:21,820
documented and format takes an absolute

00:24:19,240 --> 00:24:24,840
time and a time zone and it's going to

00:24:21,820 --> 00:24:24,840
go ahead and format this a

00:24:25,810 --> 00:24:29,800
timepoint yes which is an absolute time

00:24:27,520 --> 00:24:32,020
yes it takes a time point and a time

00:24:29,800 --> 00:24:33,700
zone and down here I'm gonna go ahead

00:24:32,020 --> 00:24:35,740
and load up another time zone I'm gonna

00:24:33,700 --> 00:24:38,350
load up the time zone for America New

00:24:35,740 --> 00:24:40,090
York now I'm not checking the return

00:24:38,350 --> 00:24:41,950
value here for two reasons one is

00:24:40,090 --> 00:24:43,390
because checking the return value on the

00:24:41,950 --> 00:24:46,810
slides kind of takes a bunch of space

00:24:43,390 --> 00:24:48,610
and also the definition of load time

00:24:46,810 --> 00:24:50,950
zone is defined that if it fails to load

00:24:48,610 --> 00:24:53,290
the time zone it sets the argument here

00:24:50,950 --> 00:24:56,290
to UTC which a lot of people have said

00:24:53,290 --> 00:24:59,380
is the default behavior they want so

00:24:56,290 --> 00:25:01,390
your that's why that's not being done

00:24:59,380 --> 00:25:03,070
here and here we're going to call make

00:25:01,390 --> 00:25:05,080
time again and I'm going to pass in a

00:25:03,070 --> 00:25:08,320
different civil time so here I'm passing

00:25:05,080 --> 00:25:11,110
July 20th at 10:56

00:25:08,320 --> 00:25:14,200
in the evening in New York and that

00:25:11,110 --> 00:25:16,450
gives me another absolute time but these

00:25:14,200 --> 00:25:18,610
two time points are guaranteed to be

00:25:16,450 --> 00:25:21,220
identical these are the you know this

00:25:18,610 --> 00:25:23,920
civil time in New York and this civil

00:25:21,220 --> 00:25:31,570
time in Sidney correspond to the exact

00:25:23,920 --> 00:25:32,980
same absolute time now let me mention a

00:25:31,570 --> 00:25:36,340
couple things briefly about the

00:25:32,980 --> 00:25:38,110
implementation of the CCT z library one

00:25:36,340 --> 00:25:40,480
is it mostly follows POSIX conventions

00:25:38,110 --> 00:25:42,700
in that it ignores leap seconds and it

00:25:40,480 --> 00:25:44,470
uses the proleptic Gregorian calendar

00:25:42,700 --> 00:25:46,690
which is the standard calendar we all

00:25:44,470 --> 00:25:50,860
use today it just extends it forward and

00:25:46,690 --> 00:25:53,320
backward in time it uses the eyes Ayana

00:25:50,860 --> 00:25:55,330
timezone data from the local system for

00:25:53,320 --> 00:25:57,880
example you know in user share zone info

00:25:55,330 --> 00:25:59,230
and fields when you call make time and

00:25:57,880 --> 00:26:01,090
you pass in a year month day hour minute

00:25:59,230 --> 00:26:03,010
second field any fields that are out of

00:26:01,090 --> 00:26:05,500
range will automatically be normalized

00:26:03,010 --> 00:26:07,930
to be in range so if you pass in october

00:26:05,500 --> 00:26:11,500
32nd for example it will normalize that

00:26:07,930 --> 00:26:13,060
to be november 1st and we'll see in an

00:26:11,500 --> 00:26:16,900
example coming up here about how that

00:26:13,060 --> 00:26:19,210
can be very useful it's faster than the

00:26:16,900 --> 00:26:21,280
Lib C equivalents now we have run a

00:26:19,210 --> 00:26:24,010
bunch of benchmarks it's hard to tell

00:26:21,280 --> 00:26:26,350
you know it's hard to say for certain

00:26:24,010 --> 00:26:28,450
that every machine every compiler every

00:26:26,350 --> 00:26:30,850
hardware thing it's you know faster so

00:26:28,450 --> 00:26:33,310
I'm gonna say in every benchmark we have

00:26:30,850 --> 00:26:36,370
it's faster I don't think speed is the

00:26:33,310 --> 00:26:38,320
reason to use this or something like

00:26:36,370 --> 00:26:40,090
this

00:26:38,320 --> 00:26:44,799
but it shouldn't be a reason not to use

00:26:40,090 --> 00:26:46,509
it and the implementation gives us some

00:26:44,799 --> 00:26:48,490
very nice default handling of

00:26:46,509 --> 00:26:49,960
discontinuities for example daylight

00:26:48,490 --> 00:26:51,580
savings time so we're going to go ahead

00:26:49,960 --> 00:26:52,899
and talk about that now we're going to

00:26:51,580 --> 00:26:55,029
talk about the daylight savings time

00:26:52,899 --> 00:26:56,980
transitions and how that how that works

00:26:55,029 --> 00:26:59,080
because these are the real complicated

00:26:56,980 --> 00:27:00,909
things that end up in pages and pages of

00:26:59,080 --> 00:27:05,139
comments followed by like one line of

00:27:00,909 --> 00:27:07,240
code so first of all daylight savings

00:27:05,139 --> 00:27:08,950
time is in quotes here because what

00:27:07,240 --> 00:27:12,399
we're talking about here are skipped and

00:27:08,950 --> 00:27:14,200
repeated civil times and whether that is

00:27:12,399 --> 00:27:16,360
because of daylight savings time or not

00:27:14,200 --> 00:27:17,649
is immaterial so we always think of

00:27:16,360 --> 00:27:18,940
these is because of daylight savings

00:27:17,649 --> 00:27:21,519
time but they're not always because of

00:27:18,940 --> 00:27:22,960
daylight savings time and let's just

00:27:21,519 --> 00:27:27,039
start off here looking just at this

00:27:22,960 --> 00:27:29,860
graph here on the Left this vertical

00:27:27,039 --> 00:27:32,740
axis here is absolute time this

00:27:29,860 --> 00:27:35,350
horizontal axis here is the civil times

00:27:32,740 --> 00:27:38,379
like 1 a.m. 2 a.m. 3 a.m. 4 a.m.

00:27:35,350 --> 00:27:40,509
etc in the case of spring let's in this

00:27:38,379 --> 00:27:42,460
example let's say it's America Los

00:27:40,509 --> 00:27:45,700
Angeles in the case of the spring time

00:27:42,460 --> 00:27:51,419
we skip the 2 o'clock hour so we we go

00:27:45,700 --> 00:27:51,419
from like 159 and we jump over to 3 a.m.

00:27:51,509 --> 00:27:56,470
this diagonal you know the blue line

00:27:54,669 --> 00:27:59,649
here is time it increases that you know

00:27:56,470 --> 00:28:02,799
one second per second so the question is

00:27:59,649 --> 00:28:05,980
what happens if you ask for give me the

00:28:02,799 --> 00:28:10,509
absolute time that corresponds to 2:30

00:28:05,980 --> 00:28:13,629
a.m. on this day so this is the question

00:28:10,509 --> 00:28:15,309
is what happens then well what we could

00:28:13,629 --> 00:28:16,690
do there is first of all we could just

00:28:15,309 --> 00:28:20,169
give an error we could say oh there is

00:28:16,690 --> 00:28:21,429
no 2:30 and you know you're done you

00:28:20,169 --> 00:28:23,200
can't do that pardon

00:28:21,429 --> 00:28:24,580
you could you could throw an exception

00:28:23,200 --> 00:28:26,860
you could return some type of there

00:28:24,580 --> 00:28:27,730
but we'd like to try to do better than

00:28:26,860 --> 00:28:30,610
that

00:28:27,730 --> 00:28:32,740
so what could we do well we could say

00:28:30,610 --> 00:28:34,929
that 2:30 if this line here were

00:28:32,740 --> 00:28:37,059
extended down it would intersect about

00:28:34,929 --> 00:28:38,860
here so we could give you this absolute

00:28:37,059 --> 00:28:41,500
time that kind of corresponds to this

00:28:38,860 --> 00:28:43,659
first intersection or we could maybe say

00:28:41,500 --> 00:28:45,580
well of this line extended up here it

00:28:43,659 --> 00:28:47,830
would intersect here and we could give

00:28:45,580 --> 00:28:50,049
you this absolute time or we could also

00:28:47,830 --> 00:28:52,210
say well the time discontinuity happened

00:28:50,049 --> 00:28:54,880
right here so we could just give you

00:28:52,210 --> 00:28:57,190
that time right there and so the default

00:28:54,880 --> 00:29:00,240
behavior that we picked for CC TZ is

00:28:57,190 --> 00:29:04,120
that it follows the as if rule it says

00:29:00,240 --> 00:29:06,850
that is what time would we give you if

00:29:04,120 --> 00:29:09,100
there was no discontinuity if there

00:29:06,850 --> 00:29:10,570
wasn't no discontinuity there would this

00:29:09,100 --> 00:29:11,680
line would just be extended up and we

00:29:10,570 --> 00:29:14,140
would give you this point right here

00:29:11,680 --> 00:29:16,450
that corresponds over there and in fact

00:29:14,140 --> 00:29:18,730
that's what we do it ends up that we end

00:29:16,450 --> 00:29:20,560
up using the pre transition offset is

00:29:18,730 --> 00:29:22,540
the way that works and we think that

00:29:20,560 --> 00:29:24,970
really matches with people's just

00:29:22,540 --> 00:29:27,790
intuition if you think about waking up

00:29:24,970 --> 00:29:29,920
you know after there was a daylight

00:29:27,790 --> 00:29:31,450
savings time changed that evening and in

00:29:29,920 --> 00:29:32,770
the afternoon someone asks you what time

00:29:31,450 --> 00:29:36,760
is it you look at your watch you say oh

00:29:32,770 --> 00:29:54,400
it's 5 p.m. well it's really 4 p.m. we

00:29:36,760 --> 00:29:57,670
tend to do that for about a day yes the

00:29:54,400 --> 00:29:59,020
question is if that happens where

00:29:57,670 --> 00:30:00,760
someone asked for a time that doesn't

00:29:59,020 --> 00:30:03,850
exist is it usually a programming error

00:30:00,760 --> 00:30:05,730
or a user input error it could be those

00:30:03,850 --> 00:30:09,880
it could just be that you're trying to

00:30:05,730 --> 00:30:12,580
write a write a code to you know bucket

00:30:09,880 --> 00:30:13,930
log data you know in two hours and you

00:30:12,580 --> 00:30:15,400
know presented on the screen and you

00:30:13,930 --> 00:30:17,500
just happen to be presenting data on a

00:30:15,400 --> 00:30:19,090
day where there's you know 23 hours in

00:30:17,500 --> 00:30:21,160
that day so you might be you know

00:30:19,090 --> 00:30:23,620
iterating the hours in that day so

00:30:21,160 --> 00:30:26,770
there's very legitimate cases where you

00:30:23,620 --> 00:30:28,840
might want to ask for say 2 a.m. on this

00:30:26,770 --> 00:30:33,640
day that's not always because of an

00:30:28,840 --> 00:30:37,450
error so it depends on the case now let

00:30:33,640 --> 00:30:39,400
me say the fall case is very similar you

00:30:37,450 --> 00:30:42,400
know in this case the one o'clock hour

00:30:39,400 --> 00:30:44,500
is repeated so there's two points in

00:30:42,400 --> 00:30:48,490
time that court that have the label of

00:30:44,500 --> 00:30:49,870
1:30 a.m. in the fall and so again when

00:30:48,490 --> 00:30:51,130
you ask for 1:30 which one do we give

00:30:49,870 --> 00:30:52,630
you do we give you this one or do we

00:30:51,130 --> 00:30:54,220
give you this one and again we just

00:30:52,630 --> 00:30:56,020
follow the as if rule if there was no

00:30:54,220 --> 00:30:57,250
transition what point what time would

00:30:56,020 --> 00:30:59,340
you get well you would get this one

00:30:57,250 --> 00:31:02,950
right here and that's what we give you

00:30:59,340 --> 00:31:04,720
now we think this is a very good default

00:31:02,950 --> 00:31:05,720
behavior it's what our make time

00:31:04,720 --> 00:31:42,890
function return'

00:31:05,720 --> 00:31:44,750
yes yeah yeah weed yes well if you're

00:31:42,890 --> 00:31:46,250
talking about difference between abs I

00:31:44,750 --> 00:31:48,830
mean if you're doing difference between

00:31:46,250 --> 00:31:52,970
absolute times you know you're in that

00:31:48,830 --> 00:31:54,740
question you're a little bit mixing the

00:31:52,970 --> 00:31:57,970
question is if I tried it if I take the

00:31:54,740 --> 00:32:00,350
difference between 259 and 3:00 a.m.

00:31:57,970 --> 00:32:03,050
don't I couldn't I get something that's

00:32:00,350 --> 00:32:05,090
you know maybe negative or or funny and

00:32:03,050 --> 00:32:06,470
I'd say in that case you'd probably want

00:32:05,090 --> 00:32:08,120
to rethink a little bit about what

00:32:06,470 --> 00:32:09,860
you're doing because you're mixing the

00:32:08,120 --> 00:32:11,840
notions of civil times and absolute

00:32:09,860 --> 00:32:13,940
times you're thinking of civil times but

00:32:11,840 --> 00:32:16,760
taking a difference in absolute times so

00:32:13,940 --> 00:32:19,970
I think if you clear that up a little

00:32:16,760 --> 00:32:20,900
bit I think you're gonna find that you

00:32:19,970 --> 00:32:26,470
don't actually want to do the

00:32:20,900 --> 00:32:28,910
computation exactly as you described so

00:32:26,470 --> 00:32:31,310
like I said this is the default behavior

00:32:28,910 --> 00:32:33,740
we give but and we think this is good in

00:32:31,310 --> 00:32:35,360
most cases however we do understand that

00:32:33,740 --> 00:32:38,000
there may be cases where you need to

00:32:35,360 --> 00:32:39,410
have some special handling for when some

00:32:38,000 --> 00:32:42,920
time doesn't exist or when it's repeated

00:32:39,410 --> 00:32:44,870
and so we have another function and that

00:32:42,920 --> 00:32:47,450
I'm showing here these we have two

00:32:44,870 --> 00:32:49,040
versions of make time we have make time

00:32:47,450 --> 00:32:50,900
down here on the bottom this is the one

00:32:49,040 --> 00:32:53,570
I was just describing this is the one

00:32:50,900 --> 00:32:55,910
that does the as if behavior it uses the

00:32:53,570 --> 00:32:57,800
pre-transition offset and I think that's

00:32:55,910 --> 00:33:00,230
typically the one you would want to use

00:32:57,800 --> 00:33:03,830
the arguments to make time are six

00:33:00,230 --> 00:33:05,540
fields a civil time and a time zone so

00:33:03,830 --> 00:33:08,540
you past year month day hour minute

00:33:05,540 --> 00:33:10,910
second and it's going to give you a time

00:33:08,540 --> 00:33:14,350
point there's no error case here in the

00:33:10,910 --> 00:33:16,750
case of repeated or skipped transition

00:33:14,350 --> 00:33:19,460
transitions it's going to pick something

00:33:16,750 --> 00:33:20,929
sensible now if that does

00:33:19,460 --> 00:33:23,270
work for you there's this other version

00:33:20,929 --> 00:33:24,470
called make time info it takes the exact

00:33:23,270 --> 00:33:26,210
same arguments your month day hour

00:33:24,470 --> 00:33:28,250
minute second in a time zone and it

00:33:26,210 --> 00:33:29,840
returns this time info struct and the

00:33:28,250 --> 00:33:31,669
time info struct tells you everything

00:33:29,840 --> 00:33:34,460
you need to know about that conversion

00:33:31,669 --> 00:33:35,899
it tells you whether that conversion

00:33:34,460 --> 00:33:39,380
whether that simple time you asked for

00:33:35,899 --> 00:33:41,510
was unique and existed or whether it was

00:33:39,380 --> 00:33:43,279
skipped and didn't exist or whether it

00:33:41,510 --> 00:33:46,640
was repeated those are the three

00:33:43,279 --> 00:33:47,720
possibilities it also tells you if we

00:33:46,640 --> 00:33:49,880
think back to the graph those

00:33:47,720 --> 00:33:51,830
intersection points it tells you what

00:33:49,880 --> 00:33:54,500
would the time point have been if we use

00:33:51,830 --> 00:33:57,350
the pre transition offset what was the

00:33:54,500 --> 00:33:59,090
transition point itself and what was the

00:33:57,350 --> 00:34:02,330
time if we had used the post transition

00:33:59,090 --> 00:34:04,760
offset and from these three fields here

00:34:02,330 --> 00:34:06,950
these three values you should be able to

00:34:04,760 --> 00:34:08,960
compute any reasonable time point you

00:34:06,950 --> 00:34:24,159
could possibly want including just give

00:34:08,960 --> 00:34:28,730
an error yes because we needed the

00:34:24,159 --> 00:34:30,950
question is why use in 64 for years and

00:34:28,730 --> 00:34:33,050
the reason is because internal to Google

00:34:30,950 --> 00:34:37,310
we ended up wanting one time point that

00:34:33,050 --> 00:34:40,490
could represent all of the times for for

00:34:37,310 --> 00:34:44,020
every for all the applications and we

00:34:40,490 --> 00:34:46,730
ended up using basically a 128-bit

00:34:44,020 --> 00:34:48,530
representation of nanoseconds and that

00:34:46,730 --> 00:34:51,050
ended up being able to produce more than

00:34:48,530 --> 00:34:56,780
32 bits of years so it does it's not a

00:34:51,050 --> 00:34:58,310
full 64 bits of years you know it and

00:34:56,780 --> 00:35:00,619
also it gives you this boolean

00:34:58,310 --> 00:35:02,720
indicating whether or not it normalized

00:35:00,619 --> 00:35:04,369
any of these fields because again by

00:35:02,720 --> 00:35:06,800
default that always normalizes the

00:35:04,369 --> 00:35:08,839
fields if you ask for October 32nd it

00:35:06,800 --> 00:35:12,490
will give you November 1st but if you

00:35:08,839 --> 00:35:14,660
want to treat that as an error you can

00:35:12,490 --> 00:35:17,540
that people tell you if it had to do

00:35:14,660 --> 00:35:19,099
that so mostly I would say generally

00:35:17,540 --> 00:35:22,760
make time that just returns the time

00:35:19,099 --> 00:35:24,380
point is probably what you want in going

00:35:22,760 --> 00:35:27,520
the other direction break time this is

00:35:24,380 --> 00:35:31,190
going from an absolute time a time point

00:35:27,520 --> 00:35:32,960
to the broken-down civil time so we call

00:35:31,190 --> 00:35:33,260
call it break time you give it a time

00:35:32,960 --> 00:35:34,850
point

00:35:33,260 --> 00:35:37,130
in a time zone and it returns this

00:35:34,850 --> 00:35:41,090
breakdown structure again breakdown is a

00:35:37,130 --> 00:35:42,470
lot like a struck TM it has the year

00:35:41,090 --> 00:35:44,390
month day hour minute second those are

00:35:42,470 --> 00:35:45,830
the main civil time components there's

00:35:44,390 --> 00:35:47,870
additionally a handful of other fields

00:35:45,830 --> 00:35:50,960
in here that you might need like weekday

00:35:47,870 --> 00:35:54,200
and sub-second and year day there's also

00:35:50,960 --> 00:35:55,760
these three down here this offset is DST

00:35:54,200 --> 00:35:58,400
and a burr like the time zone

00:35:55,760 --> 00:36:01,550
abbreviation I think you should probably

00:35:58,400 --> 00:36:03,620
not be using those last three fields you

00:36:01,550 --> 00:36:04,820
should probably ignore them the reason

00:36:03,620 --> 00:36:08,180
they exist is for backward compatibility

00:36:04,820 --> 00:36:09,650
with some old AP is that might need to

00:36:08,180 --> 00:36:11,390
use these things but if you're using a

00:36:09,650 --> 00:36:13,910
time zone library properly you don't

00:36:11,390 --> 00:36:15,410
care what the offset is you don't care

00:36:13,910 --> 00:36:17,210
whether it's daylight savings time or

00:36:15,410 --> 00:36:18,800
not because your code is generic and it

00:36:17,210 --> 00:36:20,960
works for all time zones at any time

00:36:18,800 --> 00:36:22,400
point and so you don't care about these

00:36:20,960 --> 00:36:27,080
so I would say try not to use them

00:36:22,400 --> 00:36:29,620
pretty much ignore them if possible now

00:36:27,080 --> 00:36:32,210
I'd like to look at some examples of

00:36:29,620 --> 00:36:34,820
real programming examples that show that

00:36:32,210 --> 00:36:40,760
are common and what they look like

00:36:34,820 --> 00:36:43,250
using the CCT z library so again this in

00:36:40,760 --> 00:36:44,960
this case translating civil time so

00:36:43,250 --> 00:36:47,000
translating it civil time from one time

00:36:44,960 --> 00:36:49,940
zone to an equivalent civil time in

00:36:47,000 --> 00:36:51,350
another time zone all of our examples

00:36:49,940 --> 00:36:52,610
are going to start off pretty much the

00:36:51,350 --> 00:36:54,560
same we're gonna declare a time zone

00:36:52,610 --> 00:36:56,180
we're gonna load up that time zone so

00:36:54,560 --> 00:36:58,100
here's all the data for America Los

00:36:56,180 --> 00:37:00,110
Angeles now this time zone object is

00:36:58,100 --> 00:37:02,480
actually really really small it's about

00:37:00,110 --> 00:37:04,370
it's about one word and you can pass it

00:37:02,480 --> 00:37:07,100
around by value all the types in here

00:37:04,370 --> 00:37:09,200
are little value types so we're gonna

00:37:07,100 --> 00:37:10,640
just load it load this up then we're

00:37:09,200 --> 00:37:13,390
going to call make time we're going to

00:37:10,640 --> 00:37:16,450
get the absolute time for when this talk

00:37:13,390 --> 00:37:19,700
started I want to say make time 2015

00:37:16,450 --> 00:37:25,160
september 22nd at 9:00 a.m. that's when

00:37:19,700 --> 00:37:26,150
this talk started in this time zone down

00:37:25,160 --> 00:37:31,370
here i'm going to go ahead and load up

00:37:26,150 --> 00:37:32,810
the time zone for America New York and

00:37:31,370 --> 00:37:35,270
then I'm just going to go ahead and use

00:37:32,810 --> 00:37:37,880
CC T Z format and I'm going to format

00:37:35,270 --> 00:37:40,550
this same time the exact same absolute

00:37:37,880 --> 00:37:41,600
time in two different time zones so the

00:37:40,550 --> 00:37:43,610
only thing that's changing there is the

00:37:41,600 --> 00:37:45,800
time zone this percent little Z here

00:37:43,610 --> 00:37:46,760
gives me the numeric offset for the time

00:37:45,800 --> 00:37:49,520
zone at that in

00:37:46,760 --> 00:37:51,500
and this big Z here gives me like the

00:37:49,520 --> 00:37:53,150
string abbreviation I'm including these

00:37:51,500 --> 00:37:55,160
here just so it's kind of easy to see

00:37:53,150 --> 00:37:57,740
read in the output and so the output of

00:37:55,160 --> 00:38:01,160
this program well it the output of this

00:37:57,740 --> 00:38:02,420
program is talk starts at 9:00 a.m. and

00:38:01,160 --> 00:38:05,120
a minus seven

00:38:02,420 --> 00:38:07,580
that's PDT Pacific Daylight Time was

00:38:05,120 --> 00:38:11,180
where we are right now and the talk

00:38:07,580 --> 00:38:14,570
starts at 12 noon in Eastern Daylight

00:38:11,180 --> 00:38:16,040
Time so it's very easy to translate a

00:38:14,570 --> 00:38:18,050
civil time from one time zone to another

00:38:16,040 --> 00:38:20,180
and the things to note here are there's

00:38:18,050 --> 00:38:21,500
no mention of offset I mean other than

00:38:20,180 --> 00:38:23,870
the fact that I'm printing it just so we

00:38:21,500 --> 00:38:24,410
can read here but there's no I don't use

00:38:23,870 --> 00:38:26,930
an offset

00:38:24,410 --> 00:38:28,400
I don't compute with an offset all I'm

00:38:26,930 --> 00:38:30,110
doing here is just calling a couple of

00:38:28,400 --> 00:38:34,400
functions and you know perhaps you know

00:38:30,110 --> 00:38:36,530
converting types so we just saw what

00:38:34,400 --> 00:38:38,380
formatting looks like let's see the

00:38:36,530 --> 00:38:40,670
other side what does parsing look like

00:38:38,380 --> 00:38:43,370
so the string I'm going to parse here

00:38:40,670 --> 00:38:47,590
I've defined up here it's a civil time i

00:38:43,370 --> 00:38:51,080
name it civil string it's 2015 922 at

00:38:47,590 --> 00:38:53,090
9:35 a.m. so that's the string I want to

00:38:51,080 --> 00:38:55,580
parse and then we're going to go ahead

00:38:53,090 --> 00:38:59,900
and load up the America Los Angeles

00:38:55,580 --> 00:39:03,950
timezone I'm gonna this time I'm gonna

00:38:59,900 --> 00:39:05,540
call CC TZ parse and that takes a format

00:39:03,950 --> 00:39:08,000
string the same type it like just like

00:39:05,540 --> 00:39:10,250
aster p time format string so you're

00:39:08,000 --> 00:39:11,690
probably pretty familiar with this I'm

00:39:10,250 --> 00:39:14,840
gonna parse out a year month day hour

00:39:11,690 --> 00:39:16,760
minute second from this data here from

00:39:14,840 --> 00:39:18,980
this time string I'm going to say parse

00:39:16,760 --> 00:39:21,530
that with respect to the LA Times own

00:39:18,980 --> 00:39:23,600
and then this is going to give me the

00:39:21,530 --> 00:39:25,400
absolute time that I parsed out of there

00:39:23,600 --> 00:39:28,850
and it returns bool indicating whether

00:39:25,400 --> 00:39:31,280
it was able to parse or not and then

00:39:28,850 --> 00:39:32,570
down here I'm just this isn't really

00:39:31,280 --> 00:39:34,520
about parsing but I'm just going to call

00:39:32,570 --> 00:39:37,430
stood chrono system clock now to get the

00:39:34,520 --> 00:39:40,370
current time and I'm gonna see if now is

00:39:37,430 --> 00:39:43,310
after this time I parsed then this talk

00:39:40,370 --> 00:39:46,010
is running long otherwise it's on time

00:39:43,310 --> 00:39:48,710
and that when I ran this many days ago I

00:39:46,010 --> 00:39:51,620
was definitely on time I don't know

00:39:48,710 --> 00:39:55,940
where I am now okay so I'm running long

00:39:51,620 --> 00:39:58,400
thank you alright so now let's look at

00:39:55,940 --> 00:40:00,740
an interesting example of adding months

00:39:58,400 --> 00:40:03,710
so this is fundamentally a civil

00:40:00,740 --> 00:40:06,590
time computation you can't add months in

00:40:03,710 --> 00:40:09,710
the absolute time domain there's no you

00:40:06,590 --> 00:40:11,090
know stood chrono months duration that

00:40:09,710 --> 00:40:13,460
doesn't really even make sense it's not

00:40:11,090 --> 00:40:14,840
the right question to ask so if you want

00:40:13,460 --> 00:40:16,100
to think about adding months you really

00:40:14,840 --> 00:40:17,630
need to be doing that in this civil time

00:40:16,100 --> 00:40:20,480
domain and I'm going to show how you can

00:40:17,630 --> 00:40:22,400
do that with CCTV again we're gonna

00:40:20,480 --> 00:40:25,040
start off unsurprisingly load up a time

00:40:22,400 --> 00:40:25,760
zone get the LAX time zone since that's

00:40:25,040 --> 00:40:28,250
where we are today

00:40:25,760 --> 00:40:30,680
I'm going to get stood chrono system

00:40:28,250 --> 00:40:32,510
clock now to get the current time and

00:40:30,680 --> 00:40:33,980
I'm going to call break time I'm going

00:40:32,510 --> 00:40:36,140
to break down the current instant in the

00:40:33,980 --> 00:40:37,940
LA Times own and I'm going to get this

00:40:36,140 --> 00:40:39,890
breakdown structure remember breakdown

00:40:37,940 --> 00:40:43,040
is a Sybil time it has your month day

00:40:39,890 --> 00:40:44,720
hour minute second and then I'm it down

00:40:43,040 --> 00:40:47,900
here I'm going to call make time again

00:40:44,720 --> 00:40:50,780
so I want to go from some civil time to

00:40:47,900 --> 00:40:52,640
an absolute time and I want to say from

00:40:50,780 --> 00:40:57,260
this break down give me break down the

00:40:52,640 --> 00:40:59,210
year the current month plus six and I

00:40:57,260 --> 00:41:00,440
want the first of the month I want six

00:40:59,210 --> 00:41:02,960
months from now the first day of the

00:41:00,440 --> 00:41:06,320
month I'm just picking and 0 hours 0

00:41:02,960 --> 00:41:08,090
minutes 0 seconds in LA then I'll go

00:41:06,320 --> 00:41:10,400
ahead and format this I I saw I'm

00:41:08,090 --> 00:41:11,660
initializing the absolute time then and

00:41:10,400 --> 00:41:14,119
I'm gonna go ahead and format both of

00:41:11,660 --> 00:41:18,740
these now when I ran this the other day

00:41:14,119 --> 00:41:21,350
was 917 at 9:02 a.m. and the output for

00:41:18,740 --> 00:41:23,540
six months from now is well September

00:41:21,350 --> 00:41:27,140
October November December January

00:41:23,540 --> 00:41:30,080
February March so six months three and

00:41:27,140 --> 00:41:32,210
that's what we get here March 1st and so

00:41:30,080 --> 00:41:34,040
the thing to note here is that this

00:41:32,210 --> 00:41:36,770
arithmetic right here is done in the

00:41:34,040 --> 00:41:39,950
civil time domain I'm adding six civil

00:41:36,770 --> 00:41:41,510
months and the fact that this may become

00:41:39,950 --> 00:41:43,790
larger than twelve and need to be

00:41:41,510 --> 00:41:45,350
normalized is fine because make time

00:41:43,790 --> 00:41:47,750
always normalizes it will take that

00:41:45,350 --> 00:41:49,430
month and it will normalize it roll over

00:41:47,750 --> 00:41:51,710
into the year's field or roll under as

00:41:49,430 --> 00:41:58,330
necessary and it does this computation

00:41:51,710 --> 00:41:58,330
completely in the civil time domain yes

00:42:02,410 --> 00:42:09,200
yes yes all it it picked up the fact

00:42:06,800 --> 00:42:14,440
that we went from you know daylight time

00:42:09,200 --> 00:42:14,440
to standard time and went printing yes

00:42:25,220 --> 00:42:30,720
yeah so the question is can there be two

00:42:28,050 --> 00:42:32,430
results and yes this is you know if you

00:42:30,720 --> 00:42:33,780
remember the graphs for spring and you

00:42:32,430 --> 00:42:35,730
know fall daylight savings time

00:42:33,780 --> 00:42:38,339
transitions when you're going from a

00:42:35,730 --> 00:42:41,069
civil time to an absolute time there can

00:42:38,339 --> 00:42:43,230
be cases where times are repeated or

00:42:41,069 --> 00:42:46,079
skipped and that's what I was saying

00:42:43,230 --> 00:42:47,910
about make time picks one we think a

00:42:46,079 --> 00:42:49,560
sensible one but there's a different

00:42:47,910 --> 00:42:52,109
version if you want to know that there

00:42:49,560 --> 00:42:53,880
are two possibilities or multiple past

00:42:52,109 --> 00:42:56,250
possibilities you would call the make

00:42:53,880 --> 00:42:58,800
time info function which would give you

00:42:56,250 --> 00:43:00,930
all those details if you care about them

00:42:58,800 --> 00:43:03,599
in many cases if you're computing you

00:43:00,930 --> 00:43:14,579
know six months from now you probably

00:43:03,599 --> 00:43:17,010
don't care about that yes Jeff okay okay

00:43:14,579 --> 00:43:19,290
so the question is what happens if here

00:43:17,010 --> 00:43:21,720
it's July 31st and you want to add six

00:43:19,290 --> 00:43:23,819
months and you want to keep the day what

00:43:21,720 --> 00:43:27,200
would happen is if you end up you know

00:43:23,819 --> 00:43:30,510
saying all right thank you

00:43:27,200 --> 00:43:32,609
the question is fundamentally we always

00:43:30,510 --> 00:43:35,369
think about this is you know is January

00:43:32,609 --> 00:43:36,780
31st and you add one month and you want

00:43:35,369 --> 00:43:38,819
to keep the same day well you know

00:43:36,780 --> 00:43:40,650
February 31st doesn't exist so what

00:43:38,819 --> 00:43:41,609
would happen it would end up normalizing

00:43:40,650 --> 00:43:44,119
that day as well

00:43:41,609 --> 00:43:47,730
so you would end up getting like March

00:43:44,119 --> 00:43:49,920
3rd or something so it would normalized

00:43:47,730 --> 00:43:53,520
the day as well it doesn't cap the day

00:43:49,920 --> 00:43:54,960
to the end of the remaining month if you

00:43:53,520 --> 00:43:56,849
want that behavior you'd have to

00:43:54,960 --> 00:44:05,220
implement that but all the fields just

00:43:56,849 --> 00:44:07,109
get normalized okay so for the one more

00:44:05,220 --> 00:44:09,000
example here I want to this is a very

00:44:07,109 --> 00:44:11,790
common one this is the case where you

00:44:09,000 --> 00:44:13,829
want to floor to midnight this code

00:44:11,790 --> 00:44:15,599
exists all over the place and I have

00:44:13,829 --> 00:44:18,359
midnight in quotes here because I think

00:44:15,599 --> 00:44:20,490
midnight is a bit of a bad term it's

00:44:18,359 --> 00:44:23,160
somewhat of an ambiguous term when you

00:44:20,490 --> 00:44:25,470
just colloquially speaking when you say

00:44:23,160 --> 00:44:27,330
midnight you tend to mean tomorrow's

00:44:25,470 --> 00:44:28,830
midnight you don't mean really

00:44:27,330 --> 00:44:30,510
today's minute if you say I'm gonna be

00:44:28,830 --> 00:44:32,730
home Friday at midnight you actually

00:44:30,510 --> 00:44:34,770
means Saturday morning at midnight is

00:44:32,730 --> 00:44:38,790
typically what people mean additionally

00:44:34,770 --> 00:44:41,700
midnight can you think about 0 hours 0

00:44:38,790 --> 00:44:43,920
minutes 0 second zero when you say

00:44:41,700 --> 00:44:46,110
midnight you think of those zeros and as

00:44:43,920 --> 00:44:48,600
we saw with Africa Cairo that doesn't

00:44:46,110 --> 00:44:50,910
always exist sometimes midnight doesn't

00:44:48,600 --> 00:44:52,590
exist so instead I would encourage you

00:44:50,910 --> 00:44:54,900
to use terms like in this case I'm

00:44:52,590 --> 00:44:57,450
saying floor today we could say that

00:44:54,900 --> 00:44:59,370
every day has a first moment a first

00:44:57,450 --> 00:45:02,190
instant that instant might not be

00:44:59,370 --> 00:45:04,170
midnight so we'll call it floor day day

00:45:02,190 --> 00:45:06,810
start startup day any of those things

00:45:04,170 --> 00:45:09,150
would be fine so in this case we have a

00:45:06,810 --> 00:45:10,620
function floor day and I'm going to

00:45:09,150 --> 00:45:12,120
actually skip down here to main and just

00:45:10,620 --> 00:45:13,500
look at using this real quick and then

00:45:12,120 --> 00:45:16,050
we'll talk about how we implemented it

00:45:13,500 --> 00:45:18,870
so again we simply load up the America

00:45:16,050 --> 00:45:20,460
Los Angeles time zone I'm going to get

00:45:18,870 --> 00:45:23,340
the current time Stood Corona system

00:45:20,460 --> 00:45:25,590
clock now I'm gonna call floor day so

00:45:23,340 --> 00:45:27,720
I'm gonna floor now in the LA Times own

00:45:25,590 --> 00:45:30,420
and I'm gonna get another absolute time

00:45:27,720 --> 00:45:32,040
I called it day and I'm just going to go

00:45:30,420 --> 00:45:34,200
ahead and format both of those both of

00:45:32,040 --> 00:45:35,970
those in the LA Times zone now and day

00:45:34,200 --> 00:45:38,340
and when I ran this the other day was 9

00:45:35,970 --> 00:45:41,490
12 a.m. and the beginning of the day is

00:45:38,340 --> 00:45:44,940
unsurprisingly 0 0 0 so let's see how we

00:45:41,490 --> 00:45:47,160
implemented floor day so the arguments

00:45:44,940 --> 00:45:49,500
are it's given a time point in a time

00:45:47,160 --> 00:45:51,930
zone and it returns it's supposed to

00:45:49,500 --> 00:45:53,880
return the time zone are I'm sorry the

00:45:51,930 --> 00:45:56,730
time point for the first instant of that

00:45:53,880 --> 00:45:58,860
day so we start off we just say break

00:45:56,730 --> 00:46:00,210
down or break time and we get a break

00:45:58,860 --> 00:46:02,670
down so we get all the civil time

00:46:00,210 --> 00:46:04,140
components of that time and then

00:46:02,670 --> 00:46:06,390
fundamentally what I want to do is I

00:46:04,140 --> 00:46:08,160
want to just take that civil time and I

00:46:06,390 --> 00:46:10,290
want to ask for the midnight hour and

00:46:08,160 --> 00:46:13,500
have it give me turn that midnight hour

00:46:10,290 --> 00:46:15,840
into the real civil real absolute time a

00:46:13,500 --> 00:46:18,000
real time point now since the definition

00:46:15,840 --> 00:46:21,330
of this function is that it must give

00:46:18,000 --> 00:46:24,570
the first instant of the day the default

00:46:21,330 --> 00:46:26,280
behavior that as if rule that make time

00:46:24,570 --> 00:46:29,190
would give us is not really what we want

00:46:26,280 --> 00:46:31,290
because the one special case there is if

00:46:29,190 --> 00:46:33,900
you think about the graph the spring

00:46:31,290 --> 00:46:36,300
time graph where a time might be skipped

00:46:33,900 --> 00:46:38,820
the first instant of that day is the

00:46:36,300 --> 00:46:40,710
transition point if the time was skipped

00:46:38,820 --> 00:46:41,040
the transition point would be the first

00:46:40,710 --> 00:46:42,570
dense

00:46:41,040 --> 00:46:45,000
so what we're doing here is we're just

00:46:42,570 --> 00:46:48,360
using time info so we would say make

00:46:45,000 --> 00:46:51,990
time info of this guy of this times year

00:46:48,360 --> 00:46:55,040
month and day hours 0 minutes 0 seconds

00:46:51,990 --> 00:46:59,010
0 and I get the time info and I say if

00:46:55,040 --> 00:47:00,990
that time was skipped then returned the

00:46:59,010 --> 00:47:02,760
transition point because that would be

00:47:00,990 --> 00:47:05,670
the first instant of the day otherwise

00:47:02,760 --> 00:47:07,680
return pre-pre would always be the first

00:47:05,670 --> 00:47:09,630
time instant then and so that this

00:47:07,680 --> 00:47:11,430
function will work for any timezone

00:47:09,630 --> 00:47:13,380
anywhere in the world given any funny

00:47:11,430 --> 00:47:15,900
daylight savings or other transitions

00:47:13,380 --> 00:47:21,840
forward back skips repeats anything like

00:47:15,900 --> 00:47:25,230
that this should work anywhere yes yes

00:47:21,840 --> 00:47:27,360
yes yes the question was the transition

00:47:25,230 --> 00:47:29,040
point is the was the filled in circle on

00:47:27,360 --> 00:47:35,900
those previous graphs and the answer was

00:47:29,040 --> 00:47:38,130
yes okay now again we built this library

00:47:35,900 --> 00:47:41,820
we built this library to fix real

00:47:38,130 --> 00:47:43,500
problems at Google and so we end up

00:47:41,820 --> 00:47:45,120
doing a lot of refactoring of old code

00:47:43,500 --> 00:47:47,310
so I want to just look at one quick

00:47:45,120 --> 00:47:51,510
example of a refactoring of old code of

00:47:47,310 --> 00:47:53,250
real refactoring that we did and what I

00:47:51,510 --> 00:47:55,800
like to do when looking at these api's

00:47:53,250 --> 00:47:58,080
is old API is and refactoring them is

00:47:55,800 --> 00:47:59,730
just look at this function signature

00:47:58,080 --> 00:48:02,010
and then think about this mental model

00:47:59,730 --> 00:48:03,030
and think does it even make sense what

00:48:02,010 --> 00:48:05,160
they're asking what they're claiming

00:48:03,030 --> 00:48:07,320
they're gonna do a lot of times it

00:48:05,160 --> 00:48:09,960
doesn't in this case where this function

00:48:07,320 --> 00:48:13,440
get local time and it's given a time T

00:48:09,960 --> 00:48:14,940
and a time zone so an absolute time and

00:48:13,440 --> 00:48:16,410
a time zone so I know from the mental

00:48:14,940 --> 00:48:18,480
model given those two things I can

00:48:16,410 --> 00:48:20,190
compute a civil time the corresponding

00:48:18,480 --> 00:48:22,800
civil time and the output I want here is

00:48:20,190 --> 00:48:24,900
our a minute second so okay whew this

00:48:22,800 --> 00:48:28,110
one passes the sanity test it's possible

00:48:24,900 --> 00:48:30,180
so let's see how they did it well just

00:48:28,110 --> 00:48:32,040
with a couple seconds of looking here

00:48:30,180 --> 00:48:34,260
it's going to jump out that again this

00:48:32,040 --> 00:48:37,200
is the epoch shifting solution this is

00:48:34,260 --> 00:48:39,780
very common instead of in my example

00:48:37,200 --> 00:48:41,910
earlier I called it get offset here they

00:48:39,780 --> 00:48:44,040
called it calc offset but it's the same

00:48:41,910 --> 00:48:47,400
thing calculate offset in this zone at

00:48:44,040 --> 00:48:49,230
this time and give me the offset then I

00:48:47,400 --> 00:48:52,430
take that offset I add it to the time

00:48:49,230 --> 00:48:54,660
and I get what's called adjusted time

00:48:52,430 --> 00:48:56,670
and then I break it down with

00:48:54,660 --> 00:48:59,490
gM time just like we saw in the earlier

00:48:56,670 --> 00:49:02,610
example and then I just assigned the

00:48:59,490 --> 00:49:04,590
hour minute and second fields so nothing

00:49:02,610 --> 00:49:06,960
too complicated here nothing too

00:49:04,590 --> 00:49:08,520
surprising here but let's see how we can

00:49:06,960 --> 00:49:10,320
improve this let's say we want to

00:49:08,520 --> 00:49:11,730
refactor this but maybe there is a whole

00:49:10,320 --> 00:49:13,020
bunch of collars to this function we

00:49:11,730 --> 00:49:13,980
don't want to change the signature we

00:49:13,020 --> 00:49:17,580
just want to change the implementation

00:49:13,980 --> 00:49:19,430
to improve the code so using c c TZ

00:49:17,580 --> 00:49:21,930
here's what the code would look like

00:49:19,430 --> 00:49:23,880
since i'm given a timezone string I

00:49:21,930 --> 00:49:25,590
would just declare a timezone and load

00:49:23,880 --> 00:49:28,950
up the timezone that I was given but I

00:49:25,590 --> 00:49:30,870
was that was passed here then I'll take

00:49:28,950 --> 00:49:33,000
this time T I was given and I'll use

00:49:30,870 --> 00:49:34,500
stood chrono system clock from time T

00:49:33,000 --> 00:49:37,230
and I'll make a time point that

00:49:34,500 --> 00:49:38,820
corresponds to that argument then the

00:49:37,230 --> 00:49:40,710
real work comes by just calling this one

00:49:38,820 --> 00:49:43,020
function break time I break down that

00:49:40,710 --> 00:49:45,570
that absolute time in the time zone and

00:49:43,020 --> 00:49:48,600
I get a breakdown then I just assign the

00:49:45,570 --> 00:49:50,010
hour minute second here so the thing I

00:49:48,600 --> 00:49:52,860
want you to notice about the difference

00:49:50,010 --> 00:49:55,200
between this implementation and this new

00:49:52,860 --> 00:49:57,900
implementation is that there's no

00:49:55,200 --> 00:49:59,910
mention of offsets there's no logic

00:49:57,900 --> 00:50:01,200
there's no arithmetic I'm not adding

00:49:59,910 --> 00:50:02,790
something I don't have to think am I

00:50:01,200 --> 00:50:04,680
supposed to add that offset or subtract

00:50:02,790 --> 00:50:07,800
that offset I'm pretty much just

00:50:04,680 --> 00:50:12,090
converting types so this is pretty close

00:50:07,800 --> 00:50:13,950
to if it compiles it works now let's say

00:50:12,090 --> 00:50:15,990
there's actually not too many callers to

00:50:13,950 --> 00:50:18,210
this function so updating the function

00:50:15,990 --> 00:50:19,500
signature is maybe that's okay let's see

00:50:18,210 --> 00:50:21,990
what we could do if we could maybe

00:50:19,500 --> 00:50:23,430
improve this a little bit more what I

00:50:21,990 --> 00:50:25,620
might do is I might say well instead of

00:50:23,430 --> 00:50:28,620
passing a time T I'll just pass in the

00:50:25,620 --> 00:50:30,330
time point it could be a c c TZ time

00:50:28,620 --> 00:50:32,940
point or even a stood chrono system

00:50:30,330 --> 00:50:35,250
clock time point would be just just as

00:50:32,940 --> 00:50:37,410
good and instead of passing in the time

00:50:35,250 --> 00:50:39,690
zone as a string all the colleges pass

00:50:37,410 --> 00:50:41,520
the time zone as the CCT z time zone

00:50:39,690 --> 00:50:43,230
object the benefit here is now the

00:50:41,520 --> 00:50:45,840
caller can load up any time zone they

00:50:43,230 --> 00:50:47,340
want they can also handle any handling

00:50:45,840 --> 00:50:49,200
the errors of loading the time zone if

00:50:47,340 --> 00:50:51,720
they want previously both versions of

00:50:49,200 --> 00:50:53,760
the code just ignored any load failures

00:50:51,720 --> 00:50:55,410
on the time zone so this is an

00:50:53,760 --> 00:50:57,030
improvement and then the body of this

00:50:55,410 --> 00:51:00,270
function basically boils down to one

00:50:57,030 --> 00:51:02,340
call to see ctz break time and then we

00:51:00,270 --> 00:51:03,720
just assign the output so really there's

00:51:02,340 --> 00:51:05,310
really no need to have this function at

00:51:03,720 --> 00:51:06,900
all the real refactoring here is just to

00:51:05,310 --> 00:51:08,530
delete the whole thing and just have the

00:51:06,900 --> 00:51:11,950
caller call cCTC break

00:51:08,530 --> 00:51:15,700
time and we see that happens a lot with

00:51:11,950 --> 00:51:17,880
a lot of time utility code now that we

00:51:15,700 --> 00:51:19,900
have si si TZ a lot of it you know

00:51:17,880 --> 00:51:21,270
hundreds and hundreds of lines of code

00:51:19,900 --> 00:51:33,190
are just kind of saying oh this is

00:51:21,270 --> 00:51:35,230
redundant it's not needed anymore yes do

00:51:33,190 --> 00:51:37,420
we do you ever have to identify the time

00:51:35,230 --> 00:51:39,250
point with the time zone it was with

00:51:37,420 --> 00:51:41,590
with the time zone it was created with

00:51:39,250 --> 00:51:46,330
with the time zone that the time point

00:51:41,590 --> 00:51:48,220
was created with you you can I could say

00:51:46,330 --> 00:51:49,360
there's there's no need to it depends on

00:51:48,220 --> 00:52:01,480
what you're trying to do whether or not

00:51:49,360 --> 00:52:03,340
that's necessary the question was could

00:52:01,480 --> 00:52:06,040
the timezone have been a member of the

00:52:03,340 --> 00:52:07,750
time point class what you mentioned is

00:52:06,040 --> 00:52:10,120
actually very similar to how they do it

00:52:07,750 --> 00:52:13,120
and go so there is some precedent for

00:52:10,120 --> 00:52:15,700
what you're saying there but we didn't

00:52:13,120 --> 00:52:17,710
do that primarily because we want to

00:52:15,700 --> 00:52:19,660
reuse the stood chrono time point

00:52:17,710 --> 00:52:22,720
concept which doesn't really have that

00:52:19,660 --> 00:52:24,220
baked in additionally the notion of an

00:52:22,720 --> 00:52:26,680
absolute time is really time zone

00:52:24,220 --> 00:52:31,480
independent it's a times on independent

00:52:26,680 --> 00:52:36,430
concept so some final thoughts I'd like

00:52:31,480 --> 00:52:37,990
to leave you with here are one remember

00:52:36,430 --> 00:52:41,440
this mental model it's real simple

00:52:37,990 --> 00:52:43,480
absolute time civil time time zone the

00:52:41,440 --> 00:52:46,570
relationship absolute time plus a civil

00:52:43,480 --> 00:52:48,280
time gives you a sorry absolute time and

00:52:46,570 --> 00:52:50,200
at time zone give you a civil time and

00:52:48,280 --> 00:52:52,570
civil time and the time zone give you an

00:52:50,200 --> 00:52:55,420
absolute time when you're talking about

00:52:52,570 --> 00:52:58,150
these concepts in coding with these

00:52:55,420 --> 00:53:00,640
concepts and adding comments use a clear

00:52:58,150 --> 00:53:03,130
vocabulary try to use these terms civil

00:53:00,640 --> 00:53:04,690
time absolute time just saying time is

00:53:03,130 --> 00:53:06,540
kind of ambiguous it's not really clear

00:53:04,690 --> 00:53:09,520
what you mean

00:53:06,540 --> 00:53:11,680
and your format strings prefer to use

00:53:09,520 --> 00:53:13,240
this percent little Z that's the thing

00:53:11,680 --> 00:53:15,040
that puts the numeric offset in your

00:53:13,240 --> 00:53:16,450
format string and what that does that

00:53:15,040 --> 00:53:18,250
ends up letting your format string

00:53:16,450 --> 00:53:20,920
represent an absolute instant in time

00:53:18,250 --> 00:53:23,850
it's that moment is unambiguous and

00:53:20,920 --> 00:53:23,850
anybody could parse it

00:53:24,130 --> 00:53:28,480
never compute with UTC offset s--

00:53:26,140 --> 00:53:29,680
there's no need for you to do that it's

00:53:28,480 --> 00:53:32,290
never necessary

00:53:29,680 --> 00:53:34,060
don't add don't do arithmetic with time

00:53:32,290 --> 00:53:35,590
tease unless you're implementing a time

00:53:34,060 --> 00:53:42,130
zone library I would say that's probably

00:53:35,590 --> 00:53:45,490
the only the only exception for this

00:53:42,130 --> 00:53:47,280
breakdown cCTC breakdown compute it when

00:53:45,490 --> 00:53:51,070
you need it don't really pass it around

00:53:47,280 --> 00:53:53,800
represent points in time as time points

00:53:51,070 --> 00:53:56,710
as absolute time points and if you need

00:53:53,800 --> 00:53:58,720
to pass in this notion of a time in some

00:53:56,710 --> 00:54:00,490
time zone pass in a time in a time zone

00:53:58,720 --> 00:54:03,130
and this thing can be computed as

00:54:00,490 --> 00:54:05,910
necessary and do calendar like

00:54:03,130 --> 00:54:08,170
calculations in the civil time domain

00:54:05,910 --> 00:54:11,619
don't try to do things like adding

00:54:08,170 --> 00:54:13,480
months with stood chrono time points

00:54:11,619 --> 00:54:16,300
directly do those calculations in the

00:54:13,480 --> 00:54:20,140
civil time domain and a brief note on

00:54:16,300 --> 00:54:23,380
terminology use the term UTC instead of

00:54:20,140 --> 00:54:25,960
GMT when you mean UTC say UTC you know

00:54:23,380 --> 00:54:31,530
UTC you know superseded GMT in the early

00:54:25,960 --> 00:54:34,750
60s we can start saying UTC now and also

00:54:31,530 --> 00:54:38,050
this cCTC library is available today on

00:54:34,750 --> 00:54:41,619
github you know feel free to take a look

00:54:38,050 --> 00:54:44,349
at it right now it works on Linux and

00:54:41,619 --> 00:54:48,430
almost works on Mac other than if anyone

00:54:44,349 --> 00:54:50,980
works at Apple come talk to me we have a

00:54:48,430 --> 00:54:52,450
couple of questions but so it is

00:54:50,980 --> 00:55:01,150
available today you can take a look at

00:54:52,450 --> 00:55:02,890
it and any questions yes I use it how

00:55:01,150 --> 00:55:05,349
does this stuff relate to the Olsen

00:55:02,890 --> 00:55:07,599
database it uses all the time zone data

00:55:05,349 --> 00:55:09,400
from the Olsen database that I Anna time

00:55:07,599 --> 00:55:12,660
zone data is all from the Olsen database

00:55:09,400 --> 00:55:15,990
and that's the data this works with yes

00:55:12,660 --> 00:55:15,990
yes right

00:55:26,930 --> 00:55:33,510
yeah yeah so - absolutely time zones do

00:55:31,590 --> 00:55:36,720
change that like I said you know there's

00:55:33,510 --> 00:55:37,890
roughly you know eight to ten the

00:55:36,720 --> 00:55:39,450
question is you know do time zones

00:55:37,890 --> 00:55:42,330
change if you compute six months

00:55:39,450 --> 00:55:43,710
difference in 2030 might that change and

00:55:42,330 --> 00:55:47,100
the answer is absolutely yes that might

00:55:43,710 --> 00:55:48,990
change I would say you know be careful

00:55:47,100 --> 00:55:51,540
if you're computing things that depend

00:55:48,990 --> 00:55:53,460
on time zones that far in the future and

00:55:51,540 --> 00:55:54,480
in general for something that from the

00:55:53,460 --> 00:55:57,090
future I would say if you're storing

00:55:54,480 --> 00:55:59,640
data store you're your first order your

00:55:57,090 --> 00:56:02,160
primary data if the thing you need is to

00:55:59,640 --> 00:56:05,130
come to add six months to some time in

00:56:02,160 --> 00:56:06,990
2030 store the absolute time that you

00:56:05,130 --> 00:56:09,180
know for sure in 2030 and store this

00:56:06,990 --> 00:56:11,280
concept of I need to add six months and

00:56:09,180 --> 00:56:16,230
then compute that as you need it when

00:56:11,280 --> 00:56:16,890
it's close to twenty thirty okay okay

00:56:16,230 --> 00:56:19,440
sorry

00:56:16,890 --> 00:56:22,260
this is Bradley white my colleague here

00:56:19,440 --> 00:56:25,350
he said it won't change during the

00:56:22,260 --> 00:56:37,620
execution of your program so that that

00:56:25,350 --> 00:56:51,000
is true that is true yes mm-hmm free

00:56:37,620 --> 00:56:52,560
functions for adding what oh yes you

00:56:51,000 --> 00:56:54,300
know that was just actually in an

00:56:52,560 --> 00:56:55,980
abstract you know mathematical

00:56:54,300 --> 00:56:59,310
representation it wasn't that wasn't the

00:56:55,980 --> 00:57:01,140
code the question was when we add

00:56:59,310 --> 00:57:03,090
offsets did we consider instead of using

00:57:01,140 --> 00:57:08,820
free functions operator overloading I

00:57:03,090 --> 00:57:11,280
would say we in the CCT Z we don't

00:57:08,820 --> 00:57:13,380
really add offsets anywhere I think the

00:57:11,280 --> 00:57:22,080
the adding of offsets was all in the old

00:57:13,380 --> 00:57:24,540
code that we I I see I see the question

00:57:22,080 --> 00:57:27,720
was could we have made absolute like a

00:57:24,540 --> 00:57:30,060
time point plus a time zone give you a

00:57:27,720 --> 00:57:31,450
breakdown instead of break time and I

00:57:30,060 --> 00:57:32,770
think we probably

00:57:31,450 --> 00:57:34,000
could of it would have been a little bit

00:57:32,770 --> 00:57:36,100
harder because in the make time

00:57:34,000 --> 00:57:38,440
direction we want to versions make time

00:57:36,100 --> 00:57:40,510
and make time info so we just thought it

00:57:38,440 --> 00:57:43,150
was clear to have function names instead

00:57:40,510 --> 00:58:14,800
of operators thank you

00:57:43,150 --> 00:58:19,060
yes yeah okay so two questions first one

00:58:14,800 --> 00:58:20,800
was are am i aware of any work toward

00:58:19,060 --> 00:58:23,470
updating Lib C with something like this

00:58:20,800 --> 00:58:32,980
and no I'm not aware of any work like

00:58:23,470 --> 00:58:35,020
that happening sure right so so you know

00:58:32,980 --> 00:58:37,750
I'm not aware of any existing work on

00:58:35,020 --> 00:58:39,850
that and okay I see a session is over

00:58:37,750 --> 00:58:42,390
but I'd be happy to answer that after

00:58:39,850 --> 00:58:42,390

YouTube URL: https://www.youtube.com/watch?v=2rnIHsqABfM


