Title: completion T : Improving the future T with monads - Travis Gockel [ CppCon 2015 ]
Publication date: 2015-10-12
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
std::future provides us a mechanism for asynchronous communication between a provider and receiver. However, the C++14 standard does not allow for actual asynchronous programming, as the only ways to interact with an std::future are blocking calls. The proposed then helps, but the interface is awkward and can be extremely slow when handling exceptions. Here, I will talk about completion a high-performance, async-only and monadic alternative to std::future and how it is used at SolidFire.
— 
Travis work at SolidFire on a high-performance, fault-tolerant distributed system, where he is responsible for developing tools to make building systems easier and safer. He is a bit of a programming language nerd and is a big fan of where Rust is going (eventually). If you find Travis during the day without coffee or during the night without whiskey, there is a problem.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,000 --> 00:00:07,290
good morning I'm Travis Gokul and I work

00:00:03,270 --> 00:00:09,150
for SolidFire as a C++ pirate that is my

00:00:07,290 --> 00:00:10,650
official job title it actually says that

00:00:09,150 --> 00:00:12,030
in the org chart which is pretty cool

00:00:10,650 --> 00:00:14,309
and today I'm going to talk about

00:00:12,030 --> 00:00:16,920
completions which are our internal

00:00:14,309 --> 00:00:19,680
implementation of futures there an

00:00:16,920 --> 00:00:22,949
alternative to futures and I feel may

00:00:19,680 --> 00:00:25,439
work better I only realized last

00:00:22,949 --> 00:00:27,840
yesterday that I had a half an hour to

00:00:25,439 --> 00:00:29,910
talk instead of an hour so the last half

00:00:27,840 --> 00:00:32,759
of this presentation is in the extra

00:00:29,910 --> 00:00:34,410
i'll be posting the slides somewhere so

00:00:32,759 --> 00:00:37,710
i'm not going to get to on any of the

00:00:34,410 --> 00:00:41,309
extra parts so first things first who is

00:00:37,710 --> 00:00:44,040
SolidFire what we do we re distributed

00:00:41,309 --> 00:00:45,660
all flash block storage vendor and what

00:00:44,040 --> 00:00:47,579
that means is we take a bunch of

00:00:45,660 --> 00:00:50,160
computers we networked them together and

00:00:47,579 --> 00:00:52,680
then we present them to users as a bunch

00:00:50,160 --> 00:00:54,239
of hard drives people connect to us over

00:00:52,680 --> 00:00:56,550
I skazhi and we're kind of a

00:00:54,239 --> 00:00:59,039
high-performance solution because we ran

00:00:56,550 --> 00:01:00,930
all SSD vendor you have to be because

00:00:59,039 --> 00:01:02,760
we're a storage vendor things like data

00:01:00,930 --> 00:01:05,850
loss and unavailability are one hundred

00:01:02,760 --> 00:01:07,830
percent unacceptable for our users our

00:01:05,850 --> 00:01:09,840
users are cloud service providers if

00:01:07,830 --> 00:01:13,500
they have down time that cost them a lot

00:01:09,840 --> 00:01:16,500
of money so even in the cases where say

00:01:13,500 --> 00:01:19,049
a network card fails or a hard drive

00:01:16,500 --> 00:01:21,869
fails or whatever we have to keep

00:01:19,049 --> 00:01:24,150
running no matter what we deploy as an

00:01:21,869 --> 00:01:26,180
appliance and what that means is there's

00:01:24,150 --> 00:01:28,619
no administrator that comes along and

00:01:26,180 --> 00:01:30,780
babies the cluster as it goes through

00:01:28,619 --> 00:01:34,320
time it has to be a self-maintaining

00:01:30,780 --> 00:01:35,729
entity and we deploy in environments we

00:01:34,320 --> 00:01:37,439
don't control so we don't have control

00:01:35,729 --> 00:01:38,759
of the power we don't have control of

00:01:37,439 --> 00:01:40,590
the network we don't actually have

00:01:38,759 --> 00:01:42,270
control of the heat and we have to make

00:01:40,590 --> 00:01:46,470
our software and our hardware respond to

00:01:42,270 --> 00:01:49,259
this in really really good ways I guess

00:01:46,470 --> 00:01:50,549
the best ways that we can but we have a

00:01:49,259 --> 00:01:54,299
pretty small engineering team at least

00:01:50,549 --> 00:01:56,939
in my opinion we have 40 C++ developers

00:01:54,299 --> 00:01:58,469
or slightly less than so that means the

00:01:56,939 --> 00:02:01,590
efficiency of our developers is really

00:01:58,469 --> 00:02:03,479
critical and we're also hiring and what

00:02:01,590 --> 00:02:05,310
that means is when new developers come

00:02:03,479 --> 00:02:06,899
on board we have to make sure that they

00:02:05,310 --> 00:02:09,119
can come up to speed pretty quickly so

00:02:06,899 --> 00:02:13,110
the language we use can't be completely

00:02:09,119 --> 00:02:13,470
foreign to them so here's just kind of

00:02:13,110 --> 00:02:14,790
busy

00:02:13,470 --> 00:02:17,430
Apple of one of the algorithms we've

00:02:14,790 --> 00:02:20,190
looked at this is how we do read so a

00:02:17,430 --> 00:02:23,160
request for a volume and offset and a

00:02:20,190 --> 00:02:24,960
certain amount of data comes in we hit

00:02:23,160 --> 00:02:28,260
the metadata we figure out some internal

00:02:24,960 --> 00:02:29,640
IDs for that sometimes that data is in

00:02:28,260 --> 00:02:32,700
the cache and then we can serve that

00:02:29,640 --> 00:02:34,830
immediately sometimes it isn't and when

00:02:32,700 --> 00:02:37,590
it isn't which is I guess most of the

00:02:34,830 --> 00:02:39,930
time we have to fetch the Associated

00:02:37,590 --> 00:02:41,940
chunks over the network and then in the

00:02:39,930 --> 00:02:44,220
end we take all this data we combine it

00:02:41,940 --> 00:02:45,480
back together respond to the user so

00:02:44,220 --> 00:02:49,200
there's a lot of algorithms in our

00:02:45,480 --> 00:02:54,480
system that are fan out scatter gather

00:02:49,200 --> 00:02:57,270
collect return so in this case for reads

00:02:54,480 --> 00:02:59,520
the user-visible latency is the worst

00:02:57,270 --> 00:03:01,500
case of our responders so what that

00:02:59,520 --> 00:03:03,959
means is we're extremely sensitive to

00:03:01,500 --> 00:03:07,050
latency so whenever I talk about oh

00:03:03,959 --> 00:03:10,830
that's slow i typically mean in the case

00:03:07,050 --> 00:03:13,680
of latency not throughput all right so

00:03:10,830 --> 00:03:16,550
since I'm presenting an alternative to

00:03:13,680 --> 00:03:19,110
future I feel like I have to justify why

00:03:16,550 --> 00:03:22,410
the original future is not good enough

00:03:19,110 --> 00:03:25,410
for us so first things first what is the

00:03:22,410 --> 00:03:28,110
goal of future in reality the future is

00:03:25,410 --> 00:03:31,500
a mechanism for communicating some sort

00:03:28,110 --> 00:03:34,050
of a provider which is a promise to some

00:03:31,500 --> 00:03:37,019
sort of receiver so it's a very low

00:03:34,050 --> 00:03:38,940
level construct that says okay I provide

00:03:37,019 --> 00:03:41,880
you values that you shall receive later

00:03:38,940 --> 00:03:43,080
and I receive them somewhere else and in

00:03:41,880 --> 00:03:45,060
reality this is supposed to make

00:03:43,080 --> 00:03:48,390
concurrent programming easier to deal

00:03:45,060 --> 00:03:51,420
with so here's kind of the important

00:03:48,390 --> 00:03:53,400
functions that are part of future the

00:03:51,420 --> 00:03:56,250
first and most important one is gift and

00:03:53,400 --> 00:03:58,830
what get does is if the future has a

00:03:56,250 --> 00:04:00,840
value it returns you the value or it

00:03:58,830 --> 00:04:04,140
throws an exception if it doesn't have a

00:04:00,840 --> 00:04:06,299
value yet then it blocks until you

00:04:04,140 --> 00:04:07,980
actually get the value there's valid to

00:04:06,299 --> 00:04:10,380
check for validity there's wait to wait

00:04:07,980 --> 00:04:11,760
for it to actually be complete then

00:04:10,380 --> 00:04:13,530
there's a wait for wait until those

00:04:11,760 --> 00:04:15,570
don't really matter the last and most

00:04:13,530 --> 00:04:18,690
interesting one is probably share which

00:04:15,570 --> 00:04:21,060
allows you to do something and then fan

00:04:18,690 --> 00:04:23,340
out so regular future is a one-time use

00:04:21,060 --> 00:04:25,590
thing what a shared future is it allows

00:04:23,340 --> 00:04:27,170
you to have n amount of receivers from a

00:04:25,590 --> 00:04:29,850
particular future

00:04:27,170 --> 00:04:32,520
so how do i use this I'll go through the

00:04:29,850 --> 00:04:34,470
very classic example of I want to read

00:04:32,520 --> 00:04:37,980
multiple things so here I want to read

00:04:34,470 --> 00:04:41,370
location X and location Y so I use async

00:04:37,980 --> 00:04:45,300
to start off a read of X and then I read

00:04:41,370 --> 00:04:48,480
Y on my own thread and then of course

00:04:45,300 --> 00:04:50,430
the end I tell my first future I want to

00:04:48,480 --> 00:04:52,860
get so block until it's done and then

00:04:50,430 --> 00:04:54,690
takes a two and then kind of combine

00:04:52,860 --> 00:04:56,850
them into one thing the problem with

00:04:54,690 --> 00:05:00,900
this is it's really only sort of

00:04:56,850 --> 00:05:04,050
asynchronous so the issue is if you're

00:05:00,900 --> 00:05:08,190
doing say hundreds of thousands of reads

00:05:04,050 --> 00:05:09,900
per second then blocking a thread to

00:05:08,190 --> 00:05:13,290
wait on something as simple and

00:05:09,900 --> 00:05:15,960
fundamental as an i/o is absolutely

00:05:13,290 --> 00:05:18,060
preposterous so futures don't really

00:05:15,960 --> 00:05:20,220
work for this use case and when you're

00:05:18,060 --> 00:05:22,230
talking about a network storage solution

00:05:20,220 --> 00:05:27,360
the majority of your operations turn out

00:05:22,230 --> 00:05:29,550
to be io type things so really what I

00:05:27,360 --> 00:05:31,650
think is wrong with with future is that

00:05:29,550 --> 00:05:35,880
get and weight are actually the only two

00:05:31,650 --> 00:05:37,590
ways currently to interact with them and

00:05:35,880 --> 00:05:40,680
really these two functions should never

00:05:37,590 --> 00:05:46,650
be used by anyone ever except for unit

00:05:40,680 --> 00:05:48,240
tests so then is coming to us at some

00:05:46,650 --> 00:05:51,840
point in the not too distant future

00:05:48,240 --> 00:05:54,419
hopefully and what then does is it

00:05:51,840 --> 00:05:57,180
provides you an ability to chain the

00:05:54,419 --> 00:06:00,360
next step of an operation for a future

00:05:57,180 --> 00:06:02,310
so I take then and I say hey I'm going

00:06:00,360 --> 00:06:04,980
to give you this function so here I'm

00:06:02,310 --> 00:06:06,930
taking X which takes in its going to

00:06:04,980 --> 00:06:09,930
call thing and return me an integer

00:06:06,930 --> 00:06:13,260
later and then i'm going to say x dot

00:06:09,930 --> 00:06:16,200
then take this future and return to you

00:06:13,260 --> 00:06:18,240
the cast it to a double which isn't a

00:06:16,200 --> 00:06:22,800
very interesting operation but it's an

00:06:18,240 --> 00:06:25,910
operation so what happens and inside of

00:06:22,800 --> 00:06:28,680
this lambda expression is this future is

00:06:25,910 --> 00:06:31,169
guaranteed not to block so when I say f

00:06:28,680 --> 00:06:33,150
not get I know because I'm called

00:06:31,169 --> 00:06:36,450
through the context of it then that this

00:06:33,150 --> 00:06:38,950
will never ever block which is kind of

00:06:36,450 --> 00:06:40,960
neat but I thing

00:06:38,950 --> 00:06:42,430
that's pretty awkward and the reason why

00:06:40,960 --> 00:06:45,070
that's awkward is when we talk to talk

00:06:42,430 --> 00:06:48,010
about aggregation so imagine I have a

00:06:45,070 --> 00:06:51,430
vector of future integers called all

00:06:48,010 --> 00:06:53,050
tasks and the proposal that says then

00:06:51,430 --> 00:06:55,300
has this other function which is nice

00:06:53,050 --> 00:06:58,660
called win all and the idea behind when

00:06:55,300 --> 00:07:02,170
all is well I am given a future of the

00:06:58,660 --> 00:07:04,360
things that I give you and i'm going to

00:07:02,170 --> 00:07:06,370
move those things over and by the time

00:07:04,360 --> 00:07:08,410
all of those things are done I'm going

00:07:06,370 --> 00:07:10,840
to be given back a vector of my future

00:07:08,410 --> 00:07:13,120
integers where I can call get on them

00:07:10,840 --> 00:07:16,600
and none of them will block ever which

00:07:13,120 --> 00:07:19,660
is very cool the problem is future is a

00:07:16,600 --> 00:07:22,330
multi-threaded construct and the problem

00:07:19,660 --> 00:07:24,250
is it has to deal with locking so while

00:07:22,330 --> 00:07:28,870
I know and the standards committee knows

00:07:24,250 --> 00:07:31,060
that future get I will not block in the

00:07:28,870 --> 00:07:33,520
context of then the compiler does not

00:07:31,060 --> 00:07:36,160
know that so it means it can't optimize

00:07:33,520 --> 00:07:37,450
it it means it has to take a lock on if

00:07:36,160 --> 00:07:39,280
you really want to check me on this add

00:07:37,450 --> 00:07:42,070
up the values and a vector of integers

00:07:39,280 --> 00:07:44,020
and also compare that to the time it

00:07:42,070 --> 00:07:48,670
takes to add a vector of future integers

00:07:44,020 --> 00:07:51,340
it's just slower another problem i have

00:07:48,670 --> 00:07:54,070
is somewhat philosophical so in theory

00:07:51,340 --> 00:07:56,760
these two pieces of code kind of do the

00:07:54,070 --> 00:07:58,840
same thing so the one on the left side

00:07:56,760 --> 00:08:01,330
kind of looks like an insane person

00:07:58,840 --> 00:08:03,460
wrote it you look through we're trying

00:08:01,330 --> 00:08:05,950
we're catching everything just to wreath

00:08:03,460 --> 00:08:07,330
row it we're not doing anything now if

00:08:05,950 --> 00:08:09,040
you looked at these two pieces of code

00:08:07,330 --> 00:08:11,980
obviously the one on the right is the

00:08:09,040 --> 00:08:13,570
preferred modern C++ approach to these

00:08:11,980 --> 00:08:17,620
sort of things and really it's the good

00:08:13,570 --> 00:08:19,420
C++ approach for forever but I would

00:08:17,620 --> 00:08:21,850
argue that the chaining of vin

00:08:19,420 --> 00:08:24,610
operations is the same as the code on

00:08:21,850 --> 00:08:26,320
the left almost except we're doing it

00:08:24,610 --> 00:08:28,690
through futures so if you look through

00:08:26,320 --> 00:08:31,540
thenns we're repeatedly getting the next

00:08:28,690 --> 00:08:34,330
step of this operation and if my first

00:08:31,540 --> 00:08:36,010
step of this operation through then I'm

00:08:34,330 --> 00:08:38,710
repeatedly re throwing an exception

00:08:36,010 --> 00:08:41,020
throughout my entire chain and if my

00:08:38,710 --> 00:08:43,150
chain is significantly long then I'm

00:08:41,020 --> 00:08:45,070
wasting a lot of time throwing andrey

00:08:43,150 --> 00:08:48,220
throwing the same exception over and

00:08:45,070 --> 00:08:49,570
over and over again when in reality had

00:08:48,220 --> 00:08:53,309
I written that code in a synchronous

00:08:49,570 --> 00:08:56,319
manner it would have been a lot faster

00:08:53,309 --> 00:08:58,480
alright so I would argue that the real

00:08:56,319 --> 00:09:00,459
problem with future is that it's trying

00:08:58,480 --> 00:09:02,499
to combine two ideas there's the

00:09:00,459 --> 00:09:05,379
asynchronous communication aspect and

00:09:02,499 --> 00:09:07,540
then there's the reporting of errors so

00:09:05,379 --> 00:09:09,429
one could argue that an error is also a

00:09:07,540 --> 00:09:13,119
type of value but that way we deal with

00:09:09,429 --> 00:09:15,459
them is quite different so there's this

00:09:13,119 --> 00:09:18,879
convenient mechanism that someone has

00:09:15,459 --> 00:09:22,089
proposed called expected which allows

00:09:18,879 --> 00:09:24,910
you to take an exception and kind of act

00:09:22,089 --> 00:09:26,649
like it's a value so if you've ever

00:09:24,910 --> 00:09:29,589
worked with optional an optional can

00:09:26,649 --> 00:09:31,899
have a value or it can have none and you

00:09:29,589 --> 00:09:34,029
can do stuff with it and expected can

00:09:31,899 --> 00:09:36,790
either have a value or can have an

00:09:34,029 --> 00:09:39,160
exception and very similar to the way

00:09:36,790 --> 00:09:41,499
future works get will either return you

00:09:39,160 --> 00:09:44,439
a value or we'll throw the exception

00:09:41,499 --> 00:09:46,059
there's some debate on exactly what the

00:09:44,439 --> 00:09:47,379
semantics there should be but for now

00:09:46,059 --> 00:09:50,439
I'm going to treat it as if it works

00:09:47,379 --> 00:09:53,319
that way and then there's status which

00:09:50,439 --> 00:09:55,660
returns a boolean true if it has a value

00:09:53,319 --> 00:09:57,040
false if it has an exception and then

00:09:55,660 --> 00:10:00,490
there are these two other functions

00:09:57,040 --> 00:10:02,939
called map and catch error which are

00:10:00,490 --> 00:10:05,290
best demonstrated through example so I

00:10:02,939 --> 00:10:07,360
first call this function foo and it's

00:10:05,290 --> 00:10:10,119
going to return to me an expected

00:10:07,360 --> 00:10:12,819
integer and at this point I don't know

00:10:10,119 --> 00:10:16,869
nor do I care if that was completed in

00:10:12,819 --> 00:10:19,110
exception or completed in value so the

00:10:16,869 --> 00:10:22,509
next step I'm going to say X dot map and

00:10:19,110 --> 00:10:26,319
in this case if X was completed with a

00:10:22,509 --> 00:10:29,049
successful value then I will call the

00:10:26,319 --> 00:10:30,730
lambda expression if X was completed

00:10:29,049 --> 00:10:32,769
with an exception then my expected

00:10:30,730 --> 00:10:35,649
double will just take that exception and

00:10:32,769 --> 00:10:38,319
kind of move it over catch error has the

00:10:35,649 --> 00:10:42,670
exact opposite semantics so catch error

00:10:38,319 --> 00:10:44,459
says hey if you have a value I'm just

00:10:42,670 --> 00:10:47,980
going to return you that same value and

00:10:44,459 --> 00:10:49,660
if you have an exception then I'm going

00:10:47,980 --> 00:10:51,970
to apply some transformation on it and

00:10:49,660 --> 00:10:53,619
you can do all sorts of things in this

00:10:51,970 --> 00:10:55,480
case I'm just saying you know what if

00:10:53,619 --> 00:10:58,059
there's an exception of any kind just

00:10:55,480 --> 00:10:59,769
make that value zero then later I'm

00:10:58,059 --> 00:11:02,559
going to cast them both to a string and

00:10:59,769 --> 00:11:08,259
then get my value and print it out to

00:11:02,559 --> 00:11:10,120
see out all right so now that I've

00:11:08,259 --> 00:11:14,589
covered all the bases I can finally talk

00:11:10,120 --> 00:11:16,209
about what a completion is so completion

00:11:14,589 --> 00:11:19,899
is a class that kind of looks like a

00:11:16,209 --> 00:11:27,100
weird amalgamation of the expected and

00:11:19,899 --> 00:11:29,499
future so probably there aren't a lot of

00:11:27,100 --> 00:11:31,679
interesting functions on here if you

00:11:29,499 --> 00:11:36,399
already kind of assume what map and

00:11:31,679 --> 00:11:38,199
catch error do the only weird one here I

00:11:36,399 --> 00:11:40,509
guess there are a couple weird ones one

00:11:38,199 --> 00:11:42,459
is on complete which doesn't return

00:11:40,509 --> 00:11:45,129
anything so I'll cover what exactly that

00:11:42,459 --> 00:11:49,480
means and the other one is disabled and

00:11:45,129 --> 00:11:50,860
I'll talk about that later so the things

00:11:49,480 --> 00:11:52,839
that you might notice are missing are

00:11:50,860 --> 00:11:54,369
get and wait and of course the reason

00:11:52,839 --> 00:11:57,549
they're not included is done on purpose

00:11:54,369 --> 00:11:58,929
you should never call get and wait but

00:11:57,549 --> 00:12:00,730
we can't include them if we want to be

00:11:58,929 --> 00:12:02,679
compatible with STD future and I'll

00:12:00,730 --> 00:12:05,079
actually show that in a bit another

00:12:02,679 --> 00:12:07,689
thing we lack is overloads for the

00:12:05,079 --> 00:12:09,399
reference type and void so if you look

00:12:07,689 --> 00:12:11,649
at the implementation of future the

00:12:09,399 --> 00:12:13,839
standard says you must overload it for

00:12:11,649 --> 00:12:15,809
reference types and void well it turns

00:12:13,839 --> 00:12:18,970
out if you just let your expected

00:12:15,809 --> 00:12:21,369
implementation deal with that then it's

00:12:18,970 --> 00:12:23,559
not a big deal you don't have to kind of

00:12:21,369 --> 00:12:25,990
do all this weird overloading or

00:12:23,559 --> 00:12:31,019
implement your code twice or do anything

00:12:25,990 --> 00:12:34,540
funny you just get to use the expected

00:12:31,019 --> 00:12:37,480
all right so to jump pretty quickly into

00:12:34,540 --> 00:12:38,980
the implementation um we have this thing

00:12:37,480 --> 00:12:40,660
called the completion data and if you

00:12:38,980 --> 00:12:43,959
know how futures are implemented they're

00:12:40,660 --> 00:12:45,910
done basically via the same way where

00:12:43,959 --> 00:12:48,040
you've got kind of this shared piece of

00:12:45,910 --> 00:12:51,879
data that both you are promised and your

00:12:48,040 --> 00:12:54,160
future have references to in our case

00:12:51,879 --> 00:12:56,949
the probably most interesting part is

00:12:54,160 --> 00:12:59,470
this spin mutex at the top so instead of

00:12:56,949 --> 00:13:01,720
having a regular mutex since our quantum

00:12:59,470 --> 00:13:04,629
of work since we know that get and

00:13:01,720 --> 00:13:07,629
weight are never used our quantum of

00:13:04,629 --> 00:13:10,659
work is very small so it's kind of a get

00:13:07,629 --> 00:13:12,970
in make your changes really fast and get

00:13:10,659 --> 00:13:15,370
out as fast as possible so it turns out

00:13:12,970 --> 00:13:16,180
that a spin mutex is way faster for this

00:13:15,370 --> 00:13:17,560
sort of thing

00:13:16,180 --> 00:13:21,310
cuz you're not doing that many

00:13:17,560 --> 00:13:23,710
operations in here the status is for

00:13:21,310 --> 00:13:25,320
status tracking uh there's an optional

00:13:23,710 --> 00:13:27,700
value because you start off without one

00:13:25,320 --> 00:13:30,160
and then of course there's a callback

00:13:27,700 --> 00:13:32,440
which we'll get to later we only support

00:13:30,160 --> 00:13:34,779
move semantics on callbacks which is the

00:13:32,440 --> 00:13:36,910
nice thing about being a modern shop and

00:13:34,779 --> 00:13:38,770
then there's this last bit called

00:13:36,910 --> 00:13:42,930
reference tracking data which is

00:13:38,770 --> 00:13:45,940
essentially an intrusive shared pointer

00:13:42,930 --> 00:13:47,680
alright so the completion status kind of

00:13:45,940 --> 00:13:50,589
goes through a number of these state

00:13:47,680 --> 00:13:53,260
transitions you start off with no value

00:13:50,589 --> 00:13:54,940
so you start off with no value and if

00:13:53,260 --> 00:13:58,120
you disable it then you go into the

00:13:54,940 --> 00:13:59,860
disabled state as you might expect if a

00:13:58,120 --> 00:14:03,370
promise is destroyed without setting a

00:13:59,860 --> 00:14:05,950
value your completion is broken I'll get

00:14:03,370 --> 00:14:09,220
into what exactly that means in a bit if

00:14:05,950 --> 00:14:11,860
you do a chaining operation like map or

00:14:09,220 --> 00:14:14,170
catch exception or then or on complete

00:14:11,860 --> 00:14:17,680
then you go into the has callback state

00:14:14,170 --> 00:14:19,839
if you set a value before you set a call

00:14:17,680 --> 00:14:21,970
back then you have a value and then

00:14:19,839 --> 00:14:24,100
going from has value to complete or has

00:14:21,970 --> 00:14:26,020
call back to complete is kind of the

00:14:24,100 --> 00:14:28,330
opposite of how you go from no value to

00:14:26,020 --> 00:14:30,820
either has call back row has value so

00:14:28,330 --> 00:14:33,490
there's kind of a simple state diagram

00:14:30,820 --> 00:14:35,500
for the things that we can go through oh

00:14:33,490 --> 00:14:41,709
and you can also go from has call back

00:14:35,500 --> 00:14:43,950
to Broken worry about that later so then

00:14:41,709 --> 00:14:46,209
is kind of the the most important

00:14:43,950 --> 00:14:49,180
function that we kind of think of it

00:14:46,209 --> 00:14:54,070
actually is mostly equivalent to STD

00:14:49,180 --> 00:14:57,279
future then except instead of like STD

00:14:54,070 --> 00:15:00,160
future where you pass in a future we

00:14:57,279 --> 00:15:02,230
give you an expected T the semantics are

00:15:00,160 --> 00:15:05,290
exactly identical except it's

00:15:02,230 --> 00:15:07,209
ridiculously faster and by ridiculously

00:15:05,290 --> 00:15:09,480
faster I mean we don't have to take a

00:15:07,209 --> 00:15:12,850
lock we just forward it directly to you

00:15:09,480 --> 00:15:15,970
because well at this point we can

00:15:12,850 --> 00:15:19,029
guarantee through the type system not

00:15:15,970 --> 00:15:20,860
through some weird semantics that you

00:15:19,029 --> 00:15:25,300
will never have any contention on this

00:15:20,860 --> 00:15:28,720
expected value so if you have a value so

00:15:25,300 --> 00:15:29,059
if you call then and you have a value we

00:15:28,720 --> 00:15:32,059
will call

00:15:29,059 --> 00:15:34,429
funk immediately if there is no value we

00:15:32,059 --> 00:15:36,919
store funk for some later use in all

00:15:34,429 --> 00:15:39,529
other cases there's an error and

00:15:36,919 --> 00:15:41,659
depending on how you've configured it it

00:15:39,529 --> 00:15:46,879
can either be a logic error or it can

00:15:41,659 --> 00:15:48,919
just crash immediately so another kind

00:15:46,879 --> 00:15:51,319
of sibling function to then is on

00:15:48,919 --> 00:15:54,709
complete and uncomplete is actually how

00:15:51,319 --> 00:15:56,569
then is implemented except the key to on

00:15:54,709 --> 00:15:59,569
complete is it does not return a value

00:15:56,569 --> 00:16:01,489
so if you look at the flow of data the

00:15:59,569 --> 00:16:05,059
last step in your process you probably

00:16:01,489 --> 00:16:07,669
don't actually want to take a value back

00:16:05,059 --> 00:16:09,649
so the last step of your process so if

00:16:07,669 --> 00:16:11,929
you think about vins and you're chaining

00:16:09,649 --> 00:16:14,269
a bunch of operations together the last

00:16:11,929 --> 00:16:16,729
one is where you are no longer chaining

00:16:14,269 --> 00:16:18,739
anything so this kind of allows us to do

00:16:16,729 --> 00:16:21,409
fire-and-forget so in a lot of cases

00:16:18,739 --> 00:16:24,499
we're firing and forgetting and we say

00:16:21,409 --> 00:16:26,929
okay when you're done just don't

00:16:24,499 --> 00:16:29,029
allocate another completion data for me

00:16:26,929 --> 00:16:33,919
so this saves us a lot of small block

00:16:29,029 --> 00:16:36,469
allocations which is nice so there's

00:16:33,919 --> 00:16:38,659
also map which is very very similar to

00:16:36,469 --> 00:16:42,859
then except it's only called in the

00:16:38,659 --> 00:16:45,979
cases where there is a failure so this

00:16:42,859 --> 00:16:48,679
actually improves speed a ridiculous

00:16:45,979 --> 00:16:52,429
amount so it's very easy to check this

00:16:48,679 --> 00:16:56,209
by always throwing inside of your then

00:16:52,429 --> 00:16:58,159
so imagine if you have a map function

00:16:56,209 --> 00:17:03,019
that is implemented simply in terms of

00:16:58,159 --> 00:17:05,240
then and you always throw on this speeds

00:17:03,019 --> 00:17:06,949
up the system and unfortunately I can't

00:17:05,240 --> 00:17:09,679
give you good benchmarks because any

00:17:06,949 --> 00:17:11,659
trivial benchmark is basically me

00:17:09,679 --> 00:17:15,499
pulling the wool over your eyes so I'm

00:17:11,659 --> 00:17:18,769
just not going to do that so catch error

00:17:15,499 --> 00:17:24,769
has the exact opposite semantics of them

00:17:18,769 --> 00:17:29,149
or sorry of map so we can also implement

00:17:24,769 --> 00:17:31,460
get and we implement get by saying okay

00:17:29,149 --> 00:17:34,399
we're going to just make a promise of an

00:17:31,460 --> 00:17:36,830
expected T and we're going to set on

00:17:34,399 --> 00:17:38,600
complete to set our value and we're

00:17:36,830 --> 00:17:40,269
going to move our expected into that and

00:17:38,600 --> 00:17:42,650
in the end we're going to return

00:17:40,269 --> 00:17:44,600
promises futures

00:17:42,650 --> 00:17:46,490
get get so this is really awkward

00:17:44,600 --> 00:17:48,320
looking but what that's doing is we're

00:17:46,490 --> 00:17:51,970
grabbing the future we're grabbing it's

00:17:48,320 --> 00:17:55,070
expected t and then we're grabbing the

00:17:51,970 --> 00:17:57,530
expected T's get to give our completion

00:17:55,070 --> 00:17:59,450
get the same semantics as future get and

00:17:57,530 --> 00:18:03,770
i realize that i usually get a lot but

00:17:59,450 --> 00:18:07,730
that's okay the key here is that we only

00:18:03,770 --> 00:18:09,920
incur the slow mutex call for the cases

00:18:07,730 --> 00:18:13,610
that somebody actually asks for this

00:18:09,920 --> 00:18:15,040
slow get call which is very powerful we

00:18:13,610 --> 00:18:16,970
can actually do the same thing with wait

00:18:15,040 --> 00:18:21,170
except we have to do some internal

00:18:16,970 --> 00:18:24,590
tricks because just like a future a

00:18:21,170 --> 00:18:26,030
completion can only be fired once so we

00:18:24,590 --> 00:18:28,520
have to make sure that if you implement

00:18:26,030 --> 00:18:32,330
wait we don't actually destroy your

00:18:28,520 --> 00:18:34,280
future alright so the other side of

00:18:32,330 --> 00:18:36,920
things so how do we actually provide

00:18:34,280 --> 00:18:40,370
values just like with a regular promise

00:18:36,920 --> 00:18:42,020
we use completion promise and what this

00:18:40,370 --> 00:18:44,810
does is it gives you the delivery of

00:18:42,020 --> 00:18:47,180
values to our completion okay great it

00:18:44,810 --> 00:18:51,320
shares the completion data just like a

00:18:47,180 --> 00:18:53,330
standard future implementation so it has

00:18:51,320 --> 00:18:55,520
one function that is different from

00:18:53,330 --> 00:18:57,860
standard future and of course the title

00:18:55,520 --> 00:19:00,920
and off the screen on this function

00:18:57,860 --> 00:19:04,430
called complete where you give it an

00:19:00,920 --> 00:19:06,620
expected value and it simply checks hey

00:19:04,430 --> 00:19:08,720
if you have a call back please call that

00:19:06,620 --> 00:19:10,370
call back immediately if there is no

00:19:08,720 --> 00:19:13,300
value storing the value from later

00:19:10,370 --> 00:19:15,970
retrieval if there's this Abe if the

00:19:13,300 --> 00:19:18,650
completion status says it is disabled

00:19:15,970 --> 00:19:20,840
just do nothing so drop that on the

00:19:18,650 --> 00:19:23,750
floor don't call anything call it a day

00:19:20,840 --> 00:19:28,400
all other cases are an error of some

00:19:23,750 --> 00:19:31,250
sort we can also be compatible with this

00:19:28,400 --> 00:19:33,560
standard promise so by saying set value

00:19:31,250 --> 00:19:36,200
we just call complete with make expected

00:19:33,560 --> 00:19:38,720
and when we set an exception we complete

00:19:36,200 --> 00:19:41,120
with make unexpected so kind of gives

00:19:38,720 --> 00:19:43,580
the same semantics and makes completion

00:19:41,120 --> 00:19:46,880
promise a drop-in replacement for STD

00:19:43,580 --> 00:19:49,250
promise so as a refresher on the

00:19:46,880 --> 00:19:52,160
transitions we're going from no value to

00:19:49,250 --> 00:19:55,400
either disabled you can break if you

00:19:52,160 --> 00:19:56,519
destroy your promise you can set your

00:19:55,400 --> 00:19:59,039
callback on the next chain

00:19:56,519 --> 00:20:03,959
or you can set values and give it a

00:19:59,039 --> 00:20:07,799
value for later retrieval cool all right

00:20:03,959 --> 00:20:11,190
so let's talk about edge cases so first

00:20:07,799 --> 00:20:15,269
things first broken promises these are

00:20:11,190 --> 00:20:16,799
kind of a big deal so when your

00:20:15,269 --> 00:20:19,919
completion promise is destroyed without

00:20:16,799 --> 00:20:23,639
setting a value what should you do there

00:20:19,919 --> 00:20:26,909
are a few options one of course is to do

00:20:23,639 --> 00:20:29,639
absolutely nothing simply continue on

00:20:26,909 --> 00:20:31,200
your merry way and cause a deadlock

00:20:29,639 --> 00:20:35,059
somewhere else because if somebody is

00:20:31,200 --> 00:20:37,979
depending on your future somehow getting

00:20:35,059 --> 00:20:39,929
completed well either we're going to

00:20:37,979 --> 00:20:41,789
cause a deadlock somewhere or we're just

00:20:39,929 --> 00:20:46,049
going to have this task that's kind of

00:20:41,789 --> 00:20:48,179
in the ether of stuff that well may or

00:20:46,049 --> 00:20:49,950
may not ever get completed so somebody

00:20:48,179 --> 00:20:53,299
asked for something we've abandoned that

00:20:49,950 --> 00:20:56,549
task the completion never gets delivered

00:20:53,299 --> 00:20:59,429
maybe that's okay you're probably going

00:20:56,549 --> 00:21:01,769
to memory leak so you generally don't

00:20:59,429 --> 00:21:05,009
want to do this in our case we do not

00:21:01,769 --> 00:21:07,139
allow this state but originally we had

00:21:05,009 --> 00:21:09,479
kind of a configuration option to allow

00:21:07,139 --> 00:21:13,579
you to do absolutely nothing on broken

00:21:09,479 --> 00:21:16,109
promises turned out wasn't a good idea

00:21:13,579 --> 00:21:19,249
another option would be to deliver an

00:21:16,109 --> 00:21:24,839
exception say a broken promise exception

00:21:19,249 --> 00:21:26,940
to that completion when you destroy your

00:21:24,839 --> 00:21:28,979
promise of course the issue with this is

00:21:26,940 --> 00:21:31,469
when we deliver it that starts

00:21:28,979 --> 00:21:32,820
triggering a chain of actions so you go

00:21:31,469 --> 00:21:36,599
to the next step you go to the next step

00:21:32,820 --> 00:21:39,299
the issue is you can end up blocking in

00:21:36,599 --> 00:21:40,709
the disruptor and that's probably a

00:21:39,299 --> 00:21:43,079
problem that's generally frowned upon

00:21:40,709 --> 00:21:47,519
another option is to throw but that's

00:21:43,079 --> 00:21:49,169
even more frowned upon in modern code so

00:21:47,519 --> 00:21:52,469
we went with this last option which is

00:21:49,169 --> 00:21:54,959
just panic if you destroy your

00:21:52,469 --> 00:21:58,469
completion promise without setting a

00:21:54,959 --> 00:22:00,119
value we panic week or the product the

00:21:58,469 --> 00:22:02,669
idea is we want to catch these in house

00:22:00,119 --> 00:22:06,779
as fast as possible it's actually turned

00:22:02,669 --> 00:22:09,779
out to be a great solution so another

00:22:06,779 --> 00:22:10,110
option are so another edge case is this

00:22:09,779 --> 00:22:12,299
this

00:22:10,110 --> 00:22:14,340
able function that I kind of told you

00:22:12,299 --> 00:22:17,400
about earlier so if you think of this

00:22:14,340 --> 00:22:19,650
diagram on the left as a series of steps

00:22:17,400 --> 00:22:21,929
so you're trying to accomplish your your

00:22:19,650 --> 00:22:25,260
program is trying to accomplish tasks a

00:22:21,929 --> 00:22:27,540
through H and it has this dependency

00:22:25,260 --> 00:22:29,670
order so you start off with h and then

00:22:27,540 --> 00:22:33,750
you chain be and then you chain see to

00:22:29,670 --> 00:22:36,299
that and e to depend on both B and C etc

00:22:33,750 --> 00:22:38,580
etc and so on down the chain so the

00:22:36,299 --> 00:22:43,110
question is what should happen if you

00:22:38,580 --> 00:22:46,169
disable F R sorry if you disable H what

00:22:43,110 --> 00:22:47,790
should happen so age is kind of at the

00:22:46,169 --> 00:22:49,710
bottom of the chain and maybe the user

00:22:47,790 --> 00:22:53,429
canceled their request for their data

00:22:49,710 --> 00:22:57,179
reads so we no longer care about it it's

00:22:53,429 --> 00:23:00,179
okay for us to cancel f if and only if f

00:22:57,179 --> 00:23:03,030
has no side effects but it turns out

00:23:00,179 --> 00:23:06,390
it's really hard to know if f has side

00:23:03,030 --> 00:23:08,280
effects c++ lacks the introspection that

00:23:06,390 --> 00:23:10,710
you'd need and really even if it did

00:23:08,280 --> 00:23:15,540
have it you probably wouldn't care about

00:23:10,710 --> 00:23:17,429
if it had side effects or not so we

00:23:15,540 --> 00:23:20,160
allow for an up in solution for this

00:23:17,429 --> 00:23:22,950
problem I'll cover that in the kind of

00:23:20,160 --> 00:23:25,650
next slide so another thing that you

00:23:22,950 --> 00:23:28,470
could do is you could disable see so if

00:23:25,650 --> 00:23:32,760
you disable see what should happen to d

00:23:28,470 --> 00:23:37,110
e and f well our solution that is to

00:23:32,760 --> 00:23:39,960
only allow disabling for Leafs so if you

00:23:37,110 --> 00:23:41,880
say disable see we mark it as yes you no

00:23:39,960 --> 00:23:43,380
longer care about see if it had a side

00:23:41,880 --> 00:23:47,610
effect you don't care about it anymore

00:23:43,380 --> 00:23:50,850
whatever no big deal so maybe if you go

00:23:47,610 --> 00:23:52,500
back and you cancel EDF G&H yeah you'll

00:23:50,850 --> 00:23:56,120
eventually canceled see but frankly

00:23:52,500 --> 00:23:58,860
that's a really really unlikely scenario

00:23:56,120 --> 00:24:03,630
so the real question is is disabling

00:23:58,860 --> 00:24:05,640
even useful I'm not sure maybe maybe

00:24:03,630 --> 00:24:08,429
this low-level construct of completions

00:24:05,640 --> 00:24:12,150
shouldn't really deal with any more than

00:24:08,429 --> 00:24:13,620
a basic disabling construct so maybe if

00:24:12,150 --> 00:24:17,760
we want disabling we should use

00:24:13,620 --> 00:24:21,179
something else like a flow graph but so

00:24:17,760 --> 00:24:23,500
the way we deal with you picking up the

00:24:21,179 --> 00:24:26,020
kind of if your function has

00:24:23,500 --> 00:24:29,860
FX is we have these continuation traits

00:24:26,020 --> 00:24:32,350
which really hack the idea of is pure on

00:24:29,860 --> 00:24:34,330
top of some function and we have this

00:24:32,350 --> 00:24:37,050
little thing where you can say pure funk

00:24:34,330 --> 00:24:40,300
and it wraps it in a structure that thus

00:24:37,050 --> 00:24:42,010
figures out hey this thing has no side

00:24:40,300 --> 00:24:45,210
effects so you're explicitly picking up

00:24:42,010 --> 00:24:47,230
yes this is a thing with no side effects

00:24:45,210 --> 00:24:48,910
maybe in the future we could pick up

00:24:47,230 --> 00:24:50,650
pure function automatically there's

00:24:48,910 --> 00:24:56,290
absolutely no way to do that in GCC

00:24:50,650 --> 00:25:07,750
right now but well that I know of so but

00:24:56,290 --> 00:25:15,370
maybe we could and that is it any

00:25:07,750 --> 00:25:16,960
questions so some of your optimizations

00:25:15,370 --> 00:25:18,100
are really intriguing have you proposed

00:25:16,960 --> 00:25:21,910
you any of this stuff to the standards

00:25:18,100 --> 00:25:26,170
committee no I lack the appropriate

00:25:21,910 --> 00:25:27,700
standard ease to do so I would be really

00:25:26,170 --> 00:25:29,890
helpful at somebody who was like well

00:25:27,700 --> 00:25:31,810
versed and that could maybe help me

00:25:29,890 --> 00:25:33,520
because this is some this is something

00:25:31,810 --> 00:25:35,650
that we've found is like really really

00:25:33,520 --> 00:25:38,650
handy and like really powerful for us

00:25:35,650 --> 00:25:43,440
but I don't know how to push that

00:25:38,650 --> 00:25:46,780
forward so I can help you with that the

00:25:43,440 --> 00:25:51,190
first step is to have a paper that

00:25:46,780 --> 00:25:54,220
describes the the problem that you're

00:25:51,190 --> 00:25:56,950
solving the solution why you think that

00:25:54,220 --> 00:25:59,560
solution is good and it doesn't need to

00:25:56,950 --> 00:26:01,990
have the standard ease in it at all what

00:25:59,560 --> 00:26:04,690
you're the first paper is this is a

00:26:01,990 --> 00:26:07,810
problem we can and should solve and once

00:26:04,690 --> 00:26:09,550
you get some to that people will be

00:26:07,810 --> 00:26:11,830
available to help you do the standard

00:26:09,550 --> 00:26:14,380
ease so you know do the first paper

00:26:11,830 --> 00:26:15,640
that's on your own and then people will

00:26:14,380 --> 00:26:23,230
be available to help you with the rest

00:26:15,640 --> 00:26:26,100
of it actually this looks a look look

00:26:23,230 --> 00:26:28,600
like the completion token from a co

00:26:26,100 --> 00:26:32,830
where it's actually proposed there's

00:26:28,600 --> 00:26:36,400
part of the executors proposal so why do

00:26:32,830 --> 00:26:38,950
you think this one would be useful in

00:26:36,400 --> 00:26:40,360
to the completion tool yeah so I

00:26:38,950 --> 00:26:42,910
actually stole some ideas from

00:26:40,360 --> 00:26:45,790
completion token that's why it kind of

00:26:42,910 --> 00:26:49,180
looks like that yeah the problem that I

00:26:45,790 --> 00:26:52,660
kind of had with the SEO completion

00:26:49,180 --> 00:26:55,750
token is it and maybe this is just a

00:26:52,660 --> 00:26:58,750
lack of understanding on my part is it

00:26:55,750 --> 00:27:03,250
seemed to only work in the context of an

00:26:58,750 --> 00:27:06,580
entire Ezio thing and I couldn't really

00:27:03,250 --> 00:27:08,200
extract it out okay I mean that that was

00:27:06,580 --> 00:27:10,300
kind of my I couldn't figure out how to

00:27:08,200 --> 00:27:13,840
rip it out and just have it work on its

00:27:10,300 --> 00:27:16,630
own sort of i think that might be true

00:27:13,840 --> 00:27:18,790
for boost azo but not for the execute

00:27:16,630 --> 00:27:22,270
the proposal ah yeah because I wonder if

00:27:18,790 --> 00:27:24,670
ya so in boost SEO the problem is so all

00:27:22,270 --> 00:27:27,790
of this I'd say completions were kind of

00:27:24,670 --> 00:27:31,270
made we started them in like twenty ten

00:27:27,790 --> 00:27:32,800
so there was no extra thing it was just

00:27:31,270 --> 00:27:36,640
kind of like a thing we threw together

00:27:32,800 --> 00:27:40,810
and we're like this helps a lot and the

00:27:36,640 --> 00:27:43,810
second thing is while you said never use

00:27:40,810 --> 00:27:46,210
get over it well of course I disagree

00:27:43,810 --> 00:27:49,590
with that one and if you don't want to

00:27:46,210 --> 00:27:53,140
use get away just don't use future yeah

00:27:49,590 --> 00:27:54,670
sure well I mean we cannot I don't win

00:27:53,140 --> 00:27:56,710
around that but yeah I guess it should

00:27:54,670 --> 00:27:59,220
have said never use these with little

00:27:56,710 --> 00:28:03,700
asterisk it can be helpful sometimes

00:27:59,220 --> 00:28:07,150
well the point is future is not really

00:28:03,700 --> 00:28:09,280
for this asynchronous i/o ting and I

00:28:07,150 --> 00:28:10,960
completely agree that futures not made

00:28:09,280 --> 00:28:13,300
for that and it doesn't work very well

00:28:10,960 --> 00:28:14,860
as over it but far the things it's

00:28:13,300 --> 00:28:17,770
pretty useful and then it's actually

00:28:14,860 --> 00:28:21,160
useful to have the gate that is blocking

00:28:17,770 --> 00:28:25,210
and you just using it and the search far

00:28:21,160 --> 00:28:30,100
as the question I have is in one of your

00:28:25,210 --> 00:28:34,630
slides I actually saw stood function yes

00:28:30,100 --> 00:28:37,090
it's why they use that because that uses

00:28:34,630 --> 00:28:39,910
memory allocation and it's pretty

00:28:37,090 --> 00:28:42,520
expensive probably more expensive than

00:28:39,910 --> 00:28:44,950
any mutex or something like that so

00:28:42,520 --> 00:28:48,400
while you're using that one yeah so the

00:28:44,950 --> 00:28:52,720
reason why that is used

00:28:48,400 --> 00:29:00,760
is because I I wanted to shorten it for

00:28:52,720 --> 00:29:02,530
this slide that yeah yeah you'll see it

00:29:00,760 --> 00:29:06,100
around but yeah I wanted to shorten it

00:29:02,530 --> 00:29:08,170
for for the slides in reality the clever

00:29:06,100 --> 00:29:09,520
implementer will do something way better

00:29:08,170 --> 00:29:11,500
than this you know there's there's all

00:29:09,520 --> 00:29:13,360
sorts of stuff that are just like you

00:29:11,500 --> 00:29:15,160
would never like a value in a callback

00:29:13,360 --> 00:29:17,410
can never exist at the same time so why

00:29:15,160 --> 00:29:30,040
should they have separate space you know

00:29:17,410 --> 00:29:33,400
just stuff like that you were talking

00:29:30,040 --> 00:29:36,880
about the uncomplete which is kind of

00:29:33,400 --> 00:29:40,030
like a throwaway value you start some

00:29:36,880 --> 00:29:44,560
threats which does some things and then

00:29:40,030 --> 00:29:48,760
it just goes into thin air though where

00:29:44,560 --> 00:29:54,520
do you store this completion object

00:29:48,760 --> 00:29:57,160
which contains all the data yeah so G

00:29:54,520 --> 00:30:00,670
and H are kind of in this case where you

00:29:57,160 --> 00:30:01,840
would use on complete so you know

00:30:00,670 --> 00:30:04,150
they're the last step in the chain

00:30:01,840 --> 00:30:06,640
there's nobody who it will depend on

00:30:04,150 --> 00:30:08,620
these values and when I'm say composing

00:30:06,640 --> 00:30:10,180
something I happen to know that I no

00:30:08,620 --> 00:30:13,750
longer care about any of these values

00:30:10,180 --> 00:30:16,330
anymore so GNA it basically those are

00:30:13,750 --> 00:30:19,630
the use cases for them so to answer your

00:30:16,330 --> 00:30:22,770
to actually answer your question they

00:30:19,630 --> 00:30:27,100
are stored as part of the callbacks to

00:30:22,770 --> 00:30:30,280
basically ed and n so since you've said

00:30:27,100 --> 00:30:32,980
this is my next step on complete knows

00:30:30,280 --> 00:30:36,550
so well it's easier to point it f as an

00:30:32,980 --> 00:30:39,540
example here when I say f on complete

00:30:36,550 --> 00:30:43,240
part of binding that on complete is

00:30:39,540 --> 00:30:45,850
creating this callback to kind of finish

00:30:43,240 --> 00:30:48,400
kind of the next passing of data so it's

00:30:45,850 --> 00:30:53,140
basically just shared pointers so to use

00:30:48,400 --> 00:30:56,680
this we have to store either a bc e d or

00:30:53,140 --> 00:30:58,610
f somewhere and just keep it you know

00:30:56,680 --> 00:31:01,040
program forever

00:30:58,610 --> 00:31:03,410
no typically by the time they're

00:31:01,040 --> 00:31:05,990
executed so imagine you're along the

00:31:03,410 --> 00:31:11,570
chain and you're executing be right now

00:31:05,990 --> 00:31:14,000
well B because b is being executed right

00:31:11,570 --> 00:31:16,790
now it's kind of pinned in memory so it

00:31:14,000 --> 00:31:18,020
has eventually references for everything

00:31:16,790 --> 00:31:20,990
down the chains you don't actually have

00:31:18,020 --> 00:31:22,580
to deal with any good yeah you don't

00:31:20,990 --> 00:31:31,850
have to deal with any like explicit

00:31:22,580 --> 00:31:33,860
storing it'll just kind of work so do

00:31:31,850 --> 00:31:36,520
you mention that this looks like boost

00:31:33,860 --> 00:31:39,020
ezio completion tokens which I've never

00:31:36,520 --> 00:31:41,780
experienced or heard of so I was

00:31:39,020 --> 00:31:43,540
wondering are there other precedents or

00:31:41,780 --> 00:31:45,620
similar things out they do you think or

00:31:43,540 --> 00:31:49,190
similar this other than obviously like

00:31:45,620 --> 00:31:51,350
future in the concurrency ds's stuff are

00:31:49,190 --> 00:31:55,010
there other influences that we should

00:31:51,350 --> 00:31:57,710
look at to understand this better uh I

00:31:55,010 --> 00:31:59,840
mean I'd say look at that it's a lot of

00:31:57,710 --> 00:32:03,650
the ideas for this are in other concern

00:31:59,840 --> 00:32:05,870
cts proposals yeah SEOs it's basically a

00:32:03,650 --> 00:32:08,720
blend of has your own future the as you

00:32:05,870 --> 00:32:12,590
go token and that yeah and then some

00:32:08,720 --> 00:32:18,309
things I stole from early as well all

00:32:12,590 --> 00:32:18,309

YouTube URL: https://www.youtube.com/watch?v=yOtb508xQuM


