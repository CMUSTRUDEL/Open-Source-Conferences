Title: CppCon 2015: Zach Laine "Writing Great Libraries: 89 Easy Steps"
Publication date: 2015-10-13
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Writing code that does what you want it to do, correctly and efficiently, is hard. Doing so when you don't even know yet what you want the code to do yet is quite a bit harder. Yet this is the job of a library writer -- the users of a library may have a very different use case from that of the original author.

How do library writers develop correct and efficient APIs that are also:

- easy to use correctly - hard to use incorrectly - highly reusable - gracefully interoperable with other code

This talk gives lots of practical advice and techniques for accomplishing those goals and more.
— 
Zach Laine has been using C++ in industry for 12 years, focusing on data visualization, numeric computing, games, generic programming, and good library design. He finds the process of writing bio blurbs to be a little uncomfortable.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,410
this talk has the slightly snarky

00:00:02,280 --> 00:00:05,940
subtitle 89 easy steps and I've had some

00:00:04,410 --> 00:00:07,319
people actually ask me how many real

00:00:05,940 --> 00:00:08,929
steps there are there's not a particular

00:00:07,319 --> 00:00:11,370
number of steps the point is that

00:00:08,929 --> 00:00:14,070
writing libraries is hard and there's a

00:00:11,370 --> 00:00:16,139
lot to cover these are at least talks

00:00:14,070 --> 00:00:17,970
with one hour so I Jam kinda lot of

00:00:16,139 --> 00:00:20,189
stuff into this one hour so if you have

00:00:17,970 --> 00:00:21,570
a question that you think really clarify

00:00:20,189 --> 00:00:23,519
something feel free to jump in at any

00:00:21,570 --> 00:00:24,779
time but if you can't kind of minimize

00:00:23,519 --> 00:00:26,039
your questions because there's there's a

00:00:24,779 --> 00:00:29,640
lot to go through especially in the

00:00:26,039 --> 00:00:31,700
second office okay so things are going

00:00:29,640 --> 00:00:34,469
to cover first of all why we write

00:00:31,700 --> 00:00:37,440
libraries at all what's what's the point

00:00:34,469 --> 00:00:39,300
efficiency concerns usability concerns

00:00:37,440 --> 00:00:41,550
and then last I've got sort of a grab

00:00:39,300 --> 00:00:46,070
bag of useful implementation tips for

00:00:41,550 --> 00:00:48,450
writing libraries so first motivation

00:00:46,070 --> 00:00:49,890
what is the principle that governs what

00:00:48,450 --> 00:00:52,770
we need to think about know relating

00:00:49,890 --> 00:00:55,170
writing library the reason we write

00:00:52,770 --> 00:00:58,079
libraries is at coast court Toby

00:00:55,170 --> 00:01:00,390
October use write so there is no other

00:00:58,079 --> 00:01:02,340
reason right you've got Cody right every

00:01:00,390 --> 00:01:03,840
day some of it is meant to be reused and

00:01:02,340 --> 00:01:06,299
hopefully that's library code and some

00:01:03,840 --> 00:01:08,159
of it is one-time use or very custom and

00:01:06,299 --> 00:01:10,920
it's not suitable for use and that's

00:01:08,159 --> 00:01:12,510
your application to so this is gonna

00:01:10,920 --> 00:01:14,520
underpin everything that I tell you in

00:01:12,510 --> 00:01:18,330
this talk we're trying to achieve this

00:01:14,520 --> 00:01:21,090
good reuse okay so what is the main

00:01:18,330 --> 00:01:23,009
difference between the two we've got a

00:01:21,090 --> 00:01:25,080
library code and application code and we

00:01:23,009 --> 00:01:26,549
don't know the requirements for our

00:01:25,080 --> 00:01:28,530
library code rewrite it we don't know

00:01:26,549 --> 00:01:30,119
what the user is going to be needing

00:01:28,530 --> 00:01:33,509
this library for because we haven't met

00:01:30,119 --> 00:01:34,680
them yet okay and sometimes you don't

00:01:33,509 --> 00:01:36,060
have a very good grasp on what you need

00:01:34,680 --> 00:01:37,409
for your application requirements here

00:01:36,060 --> 00:01:39,000
but to the extent that you know them you

00:01:37,409 --> 00:01:42,689
know them less for library well usually

00:01:39,000 --> 00:01:44,250
a lot less so as an example let's say

00:01:42,689 --> 00:01:47,700
I've done my application I've got this

00:01:44,250 --> 00:01:49,380
button type and for the button I have a

00:01:47,700 --> 00:01:50,939
click handler okay so whenever you click

00:01:49,380 --> 00:01:53,460
the button right I get this function as

00:01:50,939 --> 00:01:55,799
a callback and how much time do I have

00:01:53,460 --> 00:01:59,390
to do something in this function does

00:01:55,799 --> 00:02:01,530
anybody have a guest and you shout out a

00:01:59,390 --> 00:02:03,180
hundred milliseconds good answer 100

00:02:01,530 --> 00:02:05,100
milliseconds what I said too because

00:02:03,180 --> 00:02:06,780
usually like if you have around 100

00:02:05,100 --> 00:02:09,420
millisecond response time for that No

00:02:06,780 --> 00:02:13,590
you notice right the user cannot detect

00:02:09,420 --> 00:02:15,150
that lag in feedback what if I have an

00:02:13,590 --> 00:02:18,930
arbitrary function called foo in my

00:02:15,150 --> 00:02:22,020
library how much time do I there I don't

00:02:18,930 --> 00:02:23,489
know right and nobody knows so the point

00:02:22,020 --> 00:02:24,720
is that I don't know if someone who

00:02:23,489 --> 00:02:26,190
calls this is going to call it inside of

00:02:24,720 --> 00:02:28,830
a hot loop where they have like you know

00:02:26,190 --> 00:02:30,060
a few nanoseconds is the overhead that

00:02:28,830 --> 00:02:31,500
they're allowed I don't know if they've

00:02:30,060 --> 00:02:34,970
got a hundred milliseconds or somewhere

00:02:31,500 --> 00:02:37,470
in between or something else no idea so

00:02:34,970 --> 00:02:39,450
we need to make our library as usable as

00:02:37,470 --> 00:02:41,850
possible for anyone that might want to

00:02:39,450 --> 00:02:43,500
use it and the end no more part is

00:02:41,850 --> 00:02:44,850
important okay it's easy to get carried

00:02:43,500 --> 00:02:47,489
away with this I'll get into that a

00:02:44,850 --> 00:02:49,320
little bit but this implies that we need

00:02:47,489 --> 00:02:50,970
to care about efficiency because this is

00:02:49,320 --> 00:02:52,860
C++ people care about efficiency but

00:02:50,970 --> 00:02:54,480
moreover we need to make it maximally

00:02:52,860 --> 00:02:56,430
efficient because we don't know the use

00:02:54,480 --> 00:02:57,720
case we don't know when that person's

00:02:56,430 --> 00:02:59,040
can be calling that function how it's

00:02:57,720 --> 00:03:01,560
gonna be used what the time budget is

00:02:59,040 --> 00:03:02,910
and for the same reason we needed to be

00:03:01,560 --> 00:03:04,380
maximally reusable we need to be

00:03:02,910 --> 00:03:08,420
composable with other things we're doing

00:03:04,380 --> 00:03:11,820
and reusable just in a functional sense

00:03:08,420 --> 00:03:13,290
okay any time you write code there's two

00:03:11,820 --> 00:03:15,000
audiences you have to care about there's

00:03:13,290 --> 00:03:16,350
the compiler so the compiler can reason

00:03:15,000 --> 00:03:18,540
about and compile your code is correct

00:03:16,350 --> 00:03:21,930
and you also care about the the reader

00:03:18,540 --> 00:03:23,010
of that code so when you're writing an

00:03:21,930 --> 00:03:24,480
application especially that's playing

00:03:23,010 --> 00:03:25,799
demo where some kind of throw where you

00:03:24,480 --> 00:03:27,420
think you just write at once and you

00:03:25,799 --> 00:03:28,950
throw the way you don't care about the

00:03:27,420 --> 00:03:31,019
user being able reason about the code

00:03:28,950 --> 00:03:33,720
when you write library code you really

00:03:31,019 --> 00:03:35,549
care a lot about that end user right and

00:03:33,720 --> 00:03:36,690
it might be you in six months or someone

00:03:35,549 --> 00:03:40,769
on your team or it might be a complete

00:03:36,690 --> 00:03:42,150
stranger okay so as far as motivation

00:03:40,769 --> 00:03:44,250
does one of we wouldn't be covered here

00:03:42,150 --> 00:03:46,410
we care about libraries for cookies and

00:03:44,250 --> 00:03:48,480
these are two corollaries we care about

00:03:46,410 --> 00:03:51,420
maximum efficiency and maximum

00:03:48,480 --> 00:03:55,250
disability because of the primary

00:03:51,420 --> 00:03:57,959
principle principle zero okay so

00:03:55,250 --> 00:04:00,420
efficiency everybody in this room is a

00:03:57,959 --> 00:04:03,660
C++ programmer or something like that

00:04:00,420 --> 00:04:05,549
and we all know lots of guidelines we

00:04:03,660 --> 00:04:07,200
can see possible sufficient right so you

00:04:05,549 --> 00:04:09,930
make it moves know except you minimize

00:04:07,200 --> 00:04:12,209
copies you minimize resource allocations

00:04:09,930 --> 00:04:14,070
there's lots of things like this but

00:04:12,209 --> 00:04:16,019
these are all implementation guidelines

00:04:14,070 --> 00:04:17,680
and what we need to do is lift those

00:04:16,019 --> 00:04:20,979
implementation guidelines into guide

00:04:17,680 --> 00:04:23,530
for how to make interfaces I wish I had

00:04:20,979 --> 00:04:25,270
some really concrete silver bullet type

00:04:23,530 --> 00:04:28,060
guidelines for this part I don't so

00:04:25,270 --> 00:04:29,440
we're gonna look at an example since we

00:04:28,060 --> 00:04:31,900
don't know the usage context this is

00:04:29,440 --> 00:04:33,880
gonna be very ad hoc process right it

00:04:31,900 --> 00:04:37,479
depends on the specifics of your library

00:04:33,880 --> 00:04:38,889
and its interfaces okay so a way to get

00:04:37,479 --> 00:04:41,530
a sequence of things to have an API this

00:04:38,889 --> 00:04:44,050
is a bad implementation or bad interface

00:04:41,530 --> 00:04:45,910
rather I've got a struck Dex I've got a

00:04:44,050 --> 00:04:47,830
function dum X's that tells me how many

00:04:45,910 --> 00:04:50,020
I have available from that interface and

00:04:47,830 --> 00:04:52,780
then I have a function that gets one X

00:04:50,020 --> 00:04:54,639
at a time by the index okay and if you

00:04:52,780 --> 00:04:57,389
give me an out of bounds index I'm going

00:04:54,639 --> 00:04:59,500
to give you a null for that pointer tax

00:04:57,389 --> 00:05:01,000
so this is how I use it I just get the

00:04:59,500 --> 00:05:03,490
number of X's on the stack I loop over

00:05:01,000 --> 00:05:05,199
them because I've chosen to write this

00:05:03,490 --> 00:05:06,880
into this loop where I'm consuming only

00:05:05,199 --> 00:05:08,410
the number of X's that I know I already

00:05:06,880 --> 00:05:09,910
have then I don't have to check that

00:05:08,410 --> 00:05:14,380
it's an all when I get it back and I

00:05:09,910 --> 00:05:17,139
just use each one as I can okay so the

00:05:14,380 --> 00:05:21,520
implications of this are that inside the

00:05:17,139 --> 00:05:23,500
library code you have to check that the

00:05:21,520 --> 00:05:24,699
I that you're given to get X is in

00:05:23,500 --> 00:05:27,220
balance right you might have to check on

00:05:24,699 --> 00:05:28,810
both sides or just one side of the range

00:05:27,220 --> 00:05:30,460
depending on how you write it but you're

00:05:28,810 --> 00:05:33,250
gonna have order in branches they're not

00:05:30,460 --> 00:05:34,900
strictly necessary in the receiving code

00:05:33,250 --> 00:05:36,820
and the client code you have to check

00:05:34,900 --> 00:05:38,110
that the X you get back is not null if

00:05:36,820 --> 00:05:39,580
you don't use it as something like that

00:05:38,110 --> 00:05:40,930
loop in the general case if we're given

00:05:39,580 --> 00:05:43,150
it in index I you don't know if it's

00:05:40,930 --> 00:05:44,380
gonna return at all or not at one place

00:05:43,150 --> 00:05:45,550
in the code or it's very hard to reason

00:05:44,380 --> 00:05:46,599
about that so you have to do the checks

00:05:45,550 --> 00:05:48,580
there too

00:05:46,599 --> 00:05:50,830
you've also got order n function calls

00:05:48,580 --> 00:05:53,770
which is a lot more than I would like

00:05:50,830 --> 00:05:56,289
so we want to take the same thing we

00:05:53,770 --> 00:05:57,720
want to minimize the number branches and

00:05:56,289 --> 00:06:00,669
minimizes BER function calls

00:05:57,720 --> 00:06:02,110
so a/c way of doing this would be that

00:06:00,669 --> 00:06:05,050
you get the number of X's and then you

00:06:02,110 --> 00:06:06,610
give it an array that has that many roof

00:06:05,050 --> 00:06:08,590
that many pointers in it and then it

00:06:06,610 --> 00:06:11,919
fills in the array with pointers to all

00:06:08,590 --> 00:06:13,630
the XS that it has here's how you use it

00:06:11,919 --> 00:06:15,400
you just take the number of X's and then

00:06:13,630 --> 00:06:16,960
because of C++ you type with that the

00:06:15,400 --> 00:06:19,180
vector and you resize the vector B that

00:06:16,960 --> 00:06:21,130
size then you call get X as one time and

00:06:19,180 --> 00:06:23,440
then you loop over all the X's and use

00:06:21,130 --> 00:06:25,719
each one so this is better because we

00:06:23,440 --> 00:06:27,669
only need to call to function to API

00:06:25,719 --> 00:06:28,460
functions right so that's a lot less and

00:06:27,669 --> 00:06:31,280
lower inflation

00:06:28,460 --> 00:06:32,870
before and there's no more per element

00:06:31,280 --> 00:06:35,870
branches inside the implementation so

00:06:32,870 --> 00:06:37,310
that's definitely an improvement but we

00:06:35,870 --> 00:06:38,990
still need to allocate memory to use

00:06:37,310 --> 00:06:40,250
this and if we just wanted to look at

00:06:38,990 --> 00:06:42,020
the elements that's really not

00:06:40,250 --> 00:06:43,700
appropriate right we don't force someone

00:06:42,020 --> 00:06:45,410
to do memory allocations just to get a

00:06:43,700 --> 00:06:49,280
look at what's in the what's behind the

00:06:45,410 --> 00:06:50,540
API okay and in this case we happen to

00:06:49,280 --> 00:06:52,100
have a function that tells us the number

00:06:50,540 --> 00:06:53,630
of exits but what if the way we're

00:06:52,100 --> 00:06:54,770
getting these X's is that they're coming

00:06:53,630 --> 00:06:56,150
over a wire or they're coming from a

00:06:54,770 --> 00:06:58,610
terminal we don't know the exact number

00:06:56,150 --> 00:07:02,300
of them so again it's it's a limited by

00:06:58,610 --> 00:07:03,710
that so a better way to do this would be

00:07:02,300 --> 00:07:05,330
to construct a lazy range

00:07:03,710 --> 00:07:06,770
okay I've called this one X range as you

00:07:05,330 --> 00:07:08,750
can see it's just got a type def for the

00:07:06,770 --> 00:07:12,050
iterator of the underlying storage that

00:07:08,750 --> 00:07:13,790
it that it's you know that it delimits a

00:07:12,050 --> 00:07:16,280
range of and then it's got a first and

00:07:13,790 --> 00:07:20,020
last member and that's it I just defined

00:07:16,280 --> 00:07:22,610
a public member of sorry public function

00:07:20,020 --> 00:07:24,890
free function rather begin and end for

00:07:22,610 --> 00:07:26,600
getting the first and last numbers and

00:07:24,890 --> 00:07:28,460
then get X just returns from these X

00:07:26,600 --> 00:07:31,340
rapist and then here's how I use it I

00:07:28,460 --> 00:07:32,420
just say give me the range and now I'm

00:07:31,340 --> 00:07:35,030
going to loop over the range and the

00:07:32,420 --> 00:07:36,410
range miss Portland right very simple if

00:07:35,030 --> 00:07:37,790
I decide that I do want to copy the

00:07:36,410 --> 00:07:40,580
elements out I can still do that too

00:07:37,790 --> 00:07:41,990
just by copying the sequence like you

00:07:40,580 --> 00:07:44,240
see down here at the bottom okay so

00:07:41,990 --> 00:07:47,450
that's a very straightforward way to do

00:07:44,240 --> 00:07:49,100
it and has the nice property that it

00:07:47,450 --> 00:07:50,660
handles on bounded sequence as long as

00:07:49,100 --> 00:07:52,370
you change that interrater category

00:07:50,660 --> 00:07:53,990
right where that was a random access

00:07:52,370 --> 00:07:55,040
iterator but if I change those two input

00:07:53,990 --> 00:07:56,600
iterators then I could have some

00:07:55,040 --> 00:07:58,490
something coming into a file or

00:07:56,600 --> 00:08:04,060
something coming in started a stream or

00:07:58,490 --> 00:08:06,470
something coming in from wire okay so

00:08:04,060 --> 00:08:08,210
you need your guide to be efficient

00:08:06,470 --> 00:08:10,370
they're all reasonably foreseeable usage

00:08:08,210 --> 00:08:12,680
scenarios and I mean reasonable okay

00:08:10,370 --> 00:08:13,640
don't don't go crazy this is something

00:08:12,680 --> 00:08:15,050
you're gonna hear me say over and over

00:08:13,640 --> 00:08:16,790
again you want your interfaces to be

00:08:15,050 --> 00:08:18,800
maximally reusable and maximally

00:08:16,790 --> 00:08:20,360
efficient as I keep saying but there is

00:08:18,800 --> 00:08:22,400
an easy way to go off the rails with

00:08:20,360 --> 00:08:24,710
this stuff so you have to use some

00:08:22,400 --> 00:08:27,080
judicious you know amount of inclusion

00:08:24,710 --> 00:08:29,390
exclusion of what goes in your guys so

00:08:27,080 --> 00:08:31,190
to get to that point as far as

00:08:29,390 --> 00:08:32,820
efficiency goes keep saying like what if

00:08:31,190 --> 00:08:34,979
I call the API like this what

00:08:32,820 --> 00:08:36,690
call it like that okay and there's gonna

00:08:34,979 --> 00:08:38,580
be some point at which you say well what

00:08:36,690 --> 00:08:41,400
if someone you know someone could do it

00:08:38,580 --> 00:08:43,289
this way but think about like in terms

00:08:41,400 --> 00:08:45,180
of use cases like realistically someone

00:08:43,289 --> 00:08:47,280
gonna want to use it that way and if not

00:08:45,180 --> 00:08:49,080
then that's not a real use case and

00:08:47,280 --> 00:08:50,880
don't worry about it don't don't say

00:08:49,080 --> 00:08:53,940
that like I need the day to be

00:08:50,880 --> 00:08:55,530
accessible in every possible permutation

00:08:53,940 --> 00:08:57,330
of access because it's just not

00:08:55,530 --> 00:08:58,890
realistic come up with a concrete use

00:08:57,330 --> 00:09:00,420
cases for what works and then make sure

00:08:58,890 --> 00:09:03,870
every one of those is max lifted

00:09:00,420 --> 00:09:06,630
maximally envisioned okay so in other

00:09:03,870 --> 00:09:08,970
words don't get crazy with that okay so

00:09:06,630 --> 00:09:10,020
usability I'm not going to dwell too

00:09:08,970 --> 00:09:11,370
much on efficiency because I feel like

00:09:10,020 --> 00:09:13,500
as a community we have a really good

00:09:11,370 --> 00:09:14,760
handle on efficiency and I feel like we

00:09:13,500 --> 00:09:16,170
don't have a very good handle on

00:09:14,760 --> 00:09:19,440
usability so that's what most of the

00:09:16,170 --> 00:09:21,360
talk is going to be span now so this is

00:09:19,440 --> 00:09:24,390
a hopefully a non-controversial thing to

00:09:21,360 --> 00:09:27,090
say that names are important but I want

00:09:24,390 --> 00:09:28,530
people to think that you know what

00:09:27,090 --> 00:09:29,970
usually hears don't don't use

00:09:28,530 --> 00:09:31,350
unintuitive names but I want to take it

00:09:29,970 --> 00:09:36,840
a step further and say I want your names

00:09:31,350 --> 00:09:38,190
to be obvious so getting things from the

00:09:36,840 --> 00:09:39,720
sequence or selecting things from a-z

00:09:38,190 --> 00:09:42,510
because you've gotten in this case I've

00:09:39,720 --> 00:09:44,400
got a struct X with a value member if

00:09:42,510 --> 00:09:46,920
I've got a bunch of X's on the stack and

00:09:44,400 --> 00:09:50,060
I've got another vector of X's I'm gonna

00:09:46,920 --> 00:09:52,470
select from the other range of X's

00:09:50,060 --> 00:09:54,630
called this filter function okay filter

00:09:52,470 --> 00:09:57,330
is not do anything crazy it does kind of

00:09:54,630 --> 00:09:59,490
what you expect you take a beginning in

00:09:57,330 --> 00:10:01,380
iterator and it just stuff stuff into

00:09:59,490 --> 00:10:03,000
the selected X's via the back of the

00:10:01,380 --> 00:10:04,680
server and has a predicate to tell you

00:10:03,000 --> 00:10:06,870
when you do something but my question

00:10:04,680 --> 00:10:08,570
for you is what is this something does

00:10:06,870 --> 00:10:10,800
it filter and reduce and filter out if

00:10:08,570 --> 00:10:12,960
you come through the functional world

00:10:10,800 --> 00:10:15,240
you expect this to you're looking at me

00:10:12,960 --> 00:10:16,500
I see because you expect it to filter in

00:10:15,240 --> 00:10:18,090
and everybody that comes to the

00:10:16,500 --> 00:10:20,430
functional world expects that filter in

00:10:18,090 --> 00:10:21,720
the problem is that I've worked at a

00:10:20,430 --> 00:10:22,950
place where we had multiple filter

00:10:21,720 --> 00:10:24,270
functions some of which filtered and

00:10:22,950 --> 00:10:26,970
some of which filter that you said to

00:10:24,270 --> 00:10:28,140
know which ones which and if someone

00:10:26,970 --> 00:10:29,400
doesn't come with a functional world

00:10:28,140 --> 00:10:31,200
they might think well a filter like

00:10:29,400 --> 00:10:33,180
filters out grip out of your water line

00:10:31,200 --> 00:10:36,300
so this is probably filtering out right

00:10:33,180 --> 00:10:37,710
so the impedance mismatch you get from

00:10:36,300 --> 00:10:41,300
people with different backgrounds means

00:10:37,710 --> 00:10:41,300
that this is not an obvious enough name

00:10:41,700 --> 00:10:46,269
instead what if I call the copy of which

00:10:44,830 --> 00:10:49,990
is what the standard algorithm is called

00:10:46,269 --> 00:10:52,120
that does this now it copies if the

00:10:49,990 --> 00:10:54,220
predicate is true there's no way for me

00:10:52,120 --> 00:10:57,430
to misunderstand this right

00:10:54,220 --> 00:10:59,350
besides being tragically under you know

00:10:57,430 --> 00:11:00,790
behind on my sleep right screen like

00:10:59,350 --> 00:11:01,930
unless you have a complete brain fart

00:11:00,790 --> 00:11:04,660
you know you're gonna understand what

00:11:01,930 --> 00:11:08,140
this does everyone here is comfortable

00:11:04,660 --> 00:11:09,760
this name okay so again don't just try

00:11:08,140 --> 00:11:11,769
to go for intuitive names whatever that

00:11:09,760 --> 00:11:13,089
means I want the names to be obvious I

00:11:11,769 --> 00:11:14,410
want to be like there's no way I can

00:11:13,089 --> 00:11:16,240
misunderstand what this thing does the

00:11:14,410 --> 00:11:18,279
name describes what it does completely

00:11:16,240 --> 00:11:19,810
and when I make a guess of what I think

00:11:18,279 --> 00:11:20,860
the implementation is my guess is gonna

00:11:19,810 --> 00:11:24,670
be right because the mean goes well

00:11:20,860 --> 00:11:26,769
shows up okay the principle Lee surprise

00:11:24,670 --> 00:11:28,720
is another ones question later people so

00:11:26,769 --> 00:11:31,180
don't make your interfaces do crazy

00:11:28,720 --> 00:11:32,980
things that no one's gonna guess so for

00:11:31,180 --> 00:11:35,430
example if I've got this register

00:11:32,980 --> 00:11:38,740
function right it takes a pointer to X

00:11:35,430 --> 00:11:42,010
if I knew an X on the stack and then I

00:11:38,740 --> 00:11:43,779
call register X I feel like I'm using

00:11:42,010 --> 00:11:44,920
the API right maybe it doesn't have API

00:11:43,779 --> 00:11:46,360
document me to see the name of this

00:11:44,920 --> 00:11:48,160
function and I see that I need to

00:11:46,360 --> 00:11:49,899
register stuff and would proceed to use

00:11:48,160 --> 00:11:51,070
X after this but then when I get a crash

00:11:49,899 --> 00:11:52,690
I look at the implementation of that

00:11:51,070 --> 00:11:53,829
register and I realized that this is

00:11:52,690 --> 00:11:55,720
actually you should have been called

00:11:53,829 --> 00:11:57,940
consume or something but someone named

00:11:55,720 --> 00:12:00,070
it register instead right how was I

00:11:57,940 --> 00:12:02,079
supposed to know that like I'm not

00:12:00,070 --> 00:12:05,110
psychic right and the name is very

00:12:02,079 --> 00:12:09,100
misleading names are important and

00:12:05,110 --> 00:12:10,899
really I think that in many cases the

00:12:09,100 --> 00:12:14,430
principally surprise is just a

00:12:10,899 --> 00:12:17,170
permutation of names are important so

00:12:14,430 --> 00:12:19,000
make your interfaces impossible to use

00:12:17,170 --> 00:12:21,550
incorrectly whenever that's possible and

00:12:19,000 --> 00:12:23,020
if you can't make them impossible use

00:12:21,550 --> 00:12:24,820
correctly make them very difficult to

00:12:23,020 --> 00:12:27,880
use it correctly impossible to use

00:12:24,820 --> 00:12:29,050
incorrectly shows that okay so what

00:12:27,880 --> 00:12:30,339
happens when we try to restrict the

00:12:29,050 --> 00:12:32,079
number of X's in that example before

00:12:30,339 --> 00:12:35,140
like the bad interface for getting

00:12:32,079 --> 00:12:36,310
access right we get the number of X's we

00:12:35,140 --> 00:12:37,800
have some code that new tastes that

00:12:36,310 --> 00:12:41,279
number and then we loop over

00:12:37,800 --> 00:12:43,499
the exes that we want to look at well if

00:12:41,279 --> 00:12:46,800
I write that code that mutates the num

00:12:43,499 --> 00:12:48,239
variable such that num exceeds the

00:12:46,800 --> 00:12:50,220
number of X's then I get undefined

00:12:48,239 --> 00:12:51,839
behavior hopefully I get a crash but

00:12:50,220 --> 00:12:53,189
maybe I just get an undetected bug from

00:12:51,839 --> 00:12:57,480
ones that have to do with down the road

00:12:53,189 --> 00:12:58,860
okay so if we use that range based

00:12:57,480 --> 00:13:00,629
approach this talking about before not

00:12:58,860 --> 00:13:03,959
only is it I'm arguably more efficient

00:13:00,629 --> 00:13:06,209
but also is is disallowing direct

00:13:03,959 --> 00:13:07,769
indexing into that range in most cases

00:13:06,209 --> 00:13:09,059
so in the example I showed you those

00:13:07,769 --> 00:13:10,350
were public data members you'd make them

00:13:09,059 --> 00:13:12,319
private data members that you don't have

00:13:10,350 --> 00:13:14,549
people indexing into that okay

00:13:12,319 --> 00:13:15,989
alternatively if those were input

00:13:14,549 --> 00:13:17,549
iterators it wouldn't matter that they

00:13:15,989 --> 00:13:20,639
were public because again you can index

00:13:17,549 --> 00:13:23,069
with an imitator either so you give up

00:13:20,639 --> 00:13:25,079
some you give them some flexibility

00:13:23,069 --> 00:13:26,879
because you can't do something like give

00:13:25,079 --> 00:13:29,129
me from the third to the eighth element

00:13:26,879 --> 00:13:31,529
of this range right that flexibility has

00:13:29,129 --> 00:13:34,110
gone if he can index into it but many of

00:13:31,529 --> 00:13:35,399
the sequence operations that you're

00:13:34,110 --> 00:13:36,929
going to do are going to operate on the

00:13:35,399 --> 00:13:39,629
whole sequence that's just the nature of

00:13:36,929 --> 00:13:41,549
many use cases for sequences if that is

00:13:39,629 --> 00:13:43,170
the case make it impossible to index

00:13:41,549 --> 00:13:44,610
into the sequence because you obviate a

00:13:43,170 --> 00:13:47,699
whole class of errors that you can

00:13:44,610 --> 00:13:50,519
otherwise be horrible to all right said

00:13:47,699 --> 00:13:52,799
that okay another one is avoid aliasing

00:13:50,519 --> 00:13:54,720
so that means don't use pointers and

00:13:52,799 --> 00:13:58,619
references in your API is because that

00:13:54,720 --> 00:14:01,860
allows you to alias values and those

00:13:58,619 --> 00:14:03,029
interfaces so that confuses you when

00:14:01,860 --> 00:14:05,790
you're implementing the confusion of

00:14:03,029 --> 00:14:07,170
users who are using the API and it

00:14:05,790 --> 00:14:09,839
confuses the compiler to the compiler

00:14:07,170 --> 00:14:10,920
generates worse code when you do that so

00:14:09,839 --> 00:14:12,959
here's an example is a pretty classic

00:14:10,920 --> 00:14:14,879
example of a wrong implementation of an

00:14:12,959 --> 00:14:18,509
XOR swap does anyone know why this is

00:14:14,879 --> 00:14:21,029
wrong anyone if a and B are the same the

00:14:18,509 --> 00:14:23,669
first statement zeros a map okay pour it

00:14:21,029 --> 00:14:25,649
out it's the same thing so if I pass in

00:14:23,669 --> 00:14:26,910
a and B but they're the same object

00:14:25,649 --> 00:14:28,410
instead of swapping with itself and

00:14:26,910 --> 00:14:30,929
becoming a no objects a zero is that

00:14:28,410 --> 00:14:32,339
thing out so as I told someone before if

00:14:30,929 --> 00:14:34,350
you really don't care about precision

00:14:32,339 --> 00:14:37,139
zero is pretty close to everything at

00:14:34,350 --> 00:14:38,819
the Max and range right so that's that's

00:14:37,139 --> 00:14:41,579
the only condition under which this is

00:14:38,819 --> 00:14:42,230
correct so this is a possible

00:14:41,579 --> 00:14:45,320
implementation

00:14:42,230 --> 00:14:48,740
fix right so if I know that these are

00:14:45,320 --> 00:14:50,090
different objects then I can just only

00:14:48,740 --> 00:14:53,270
do the operations when I know that

00:14:50,090 --> 00:14:55,160
they're different objects so this is bad

00:14:53,270 --> 00:14:56,300
because we've got an extra branch and

00:14:55,160 --> 00:14:58,280
what should be a very simple

00:14:56,300 --> 00:15:00,110
straight-line highly efficient a little

00:14:58,280 --> 00:15:01,820
bit of code and I don't want to have to

00:15:00,110 --> 00:15:03,530
think about identity this is it's almost

00:15:01,820 --> 00:15:05,420
more important to me right I don't care

00:15:03,530 --> 00:15:06,860
that these guys point to the same place

00:15:05,420 --> 00:15:08,450
in memory I care that they're the same

00:15:06,860 --> 00:15:10,100
value that's that's the thing I want to

00:15:08,450 --> 00:15:12,410
reason about in the code having to

00:15:10,100 --> 00:15:13,910
reason about lifetime and who's who is

00:15:12,410 --> 00:15:15,500
taking away from what the program

00:15:13,910 --> 00:15:16,640
actually does is make you think about

00:15:15,500 --> 00:15:19,850
stuff you don't need to think about

00:15:16,640 --> 00:15:21,920
complicating your life so how about this

00:15:19,850 --> 00:15:24,050
implication now we copy out the

00:15:21,920 --> 00:15:26,120
references we're given onto the stack we

00:15:24,050 --> 00:15:29,750
do our operations and then we copy them

00:15:26,120 --> 00:15:34,970
back out okay so this is better it is

00:15:29,750 --> 00:15:37,130
correct but this is also good too and if

00:15:34,970 --> 00:15:39,310
I just copy them in by value in the copy

00:15:37,130 --> 00:15:41,930
amount by value it's a pure function

00:15:39,310 --> 00:15:43,610
it's still simple straight-line code and

00:15:41,930 --> 00:15:47,150
it turns out well believe it or not I

00:15:43,610 --> 00:15:48,620
used clang three something to generate

00:15:47,150 --> 00:15:51,830
code for all these and this actually

00:15:48,620 --> 00:15:54,290
generates the tightest code don't use

00:15:51,830 --> 00:15:55,580
tener for this if you want to generate a

00:15:54,290 --> 00:15:57,500
code that's not gonna happen

00:15:55,580 --> 00:15:58,850
the step air version of it generate

00:15:57,500 --> 00:16:01,610
almost twice as much code as any other

00:15:58,850 --> 00:16:03,140
implementation so you know the bottom

00:16:01,610 --> 00:16:05,210
line here is that you should avoid

00:16:03,140 --> 00:16:06,440
references and pointers in your

00:16:05,210 --> 00:16:07,400
interfaces because they make it harder

00:16:06,440 --> 00:16:08,840
for you to write a correct

00:16:07,400 --> 00:16:11,090
implementation and they makes it harder

00:16:08,840 --> 00:16:14,300
for your users to understand the right

00:16:11,090 --> 00:16:15,680
way to use your interface sometimes

00:16:14,300 --> 00:16:17,240
references around Loyola I'm not saying

00:16:15,680 --> 00:16:19,250
anybody should ask them a large object

00:16:17,240 --> 00:16:21,920
by value and not ask you to make ostrov

00:16:19,250 --> 00:16:23,510
that's that's not on the table but if

00:16:21,920 --> 00:16:24,920
you're doing small values like I just

00:16:23,510 --> 00:16:26,570
showed you the convenience of right of a

00:16:24,920 --> 00:16:29,000
swap where it does references might

00:16:26,570 --> 00:16:30,560
actually be a customization and you need

00:16:29,000 --> 00:16:32,660
to look at the code that your compiler

00:16:30,560 --> 00:16:34,610
generates to determine if the references

00:16:32,660 --> 00:16:36,100
are a win or a loss like when I first

00:16:34,610 --> 00:16:37,870
did this I did it with in terms of

00:16:36,100 --> 00:16:39,339
two pair and I thought okay well that's

00:16:37,870 --> 00:16:40,389
easy right and then I looked at the code

00:16:39,339 --> 00:16:43,360
that it generated I was like this is

00:16:40,389 --> 00:16:45,490
terrible so you got to look okay

00:16:43,360 --> 00:16:47,230
another example if you have a base class

00:16:45,490 --> 00:16:49,720
and has struck test drive from base

00:16:47,230 --> 00:16:51,430
let's say you have some index a notion

00:16:49,720 --> 00:16:53,680
of index for base and not every base has

00:16:51,430 --> 00:16:55,000
an index so the the API author decided

00:16:53,680 --> 00:16:57,250
that they were going to return this

00:16:55,000 --> 00:16:58,630
index unsigned debt as a pointer because

00:16:57,250 --> 00:17:00,069
it's knowable you could say like well if

00:16:58,630 --> 00:17:02,050
there's no such index that I returned

00:17:00,069 --> 00:17:03,850
off and then there's a convenience

00:17:02,050 --> 00:17:06,459
function new S with index that

00:17:03,850 --> 00:17:07,959
dynamically allocates an S calls get

00:17:06,459 --> 00:17:12,760
index and returns both of those things

00:17:07,959 --> 00:17:14,319
to you okay if I'm gonna use new s with

00:17:12,760 --> 00:17:17,020
index and this is all I know I just see

00:17:14,319 --> 00:17:20,079
this stuff then I immediately have some

00:17:17,020 --> 00:17:21,850
questions about what it's doing and when

00:17:20,079 --> 00:17:24,400
it's safe to use and how best to use it

00:17:21,850 --> 00:17:25,659
so if I just think of a simplest

00:17:24,400 --> 00:17:27,909
implementation this is what comes to

00:17:25,659 --> 00:17:29,860
mind right I just knew an S and then I

00:17:27,909 --> 00:17:34,090
called get index with that within us

00:17:29,860 --> 00:17:36,460
okay doesn't get indexed throw I mean it

00:17:34,090 --> 00:17:38,679
returns a pointer and so it's gonna

00:17:36,460 --> 00:17:40,690
return a null in cases where there's no

00:17:38,679 --> 00:17:42,039
such index but in the general case I

00:17:40,690 --> 00:17:44,080
can't just say like well I can't depend

00:17:42,039 --> 00:17:45,250
on the fact that doesn't throw the C++

00:17:44,080 --> 00:17:47,650
does any line of code you have to

00:17:45,250 --> 00:17:50,080
suspect him I throw it some way okay so

00:17:47,650 --> 00:17:53,110
given that if the answer to that is yes

00:17:50,080 --> 00:17:55,570
then does that mean that the whole thing

00:17:53,110 --> 00:17:58,260
throws does numb s with index throw okay

00:17:55,570 --> 00:18:00,549
if it does it's gonna leak that s right

00:17:58,260 --> 00:18:03,490
there's no there's no cleanup for that s

00:18:00,549 --> 00:18:05,500
it just gets leaked so if it doesn't do

00:18:03,490 --> 00:18:07,120
that if it swallows or capture some

00:18:05,500 --> 00:18:08,470
exceptions is a swallowing mixed up just

00:18:07,120 --> 00:18:11,830
the past throw through I need to know

00:18:08,470 --> 00:18:13,270
these kinds of things right so here's an

00:18:11,830 --> 00:18:14,799
alternative limitation I didn't change

00:18:13,270 --> 00:18:17,409
the pointer from get index but I did

00:18:14,799 --> 00:18:19,330
change the new s with index to return an

00:18:17,409 --> 00:18:21,010
S by value it could also return one by

00:18:19,330 --> 00:18:22,419
unique right those are kind of

00:18:21,010 --> 00:18:24,250
equivalent as far as I'm concerned in

00:18:22,419 --> 00:18:25,659
this case because what I get is

00:18:24,250 --> 00:18:28,299
something that I no longer after we have

00:18:25,659 --> 00:18:29,980
to think about and understand how it

00:18:28,299 --> 00:18:32,799
works I know the semantics of it by

00:18:29,980 --> 00:18:34,510
looking at the interface so the question

00:18:32,799 --> 00:18:36,490
of the first one is I don't care because

00:18:34,510 --> 00:18:38,380
if get index throws everything gets

00:18:36,490 --> 00:18:38,800
cleaned up and then whatever get index

00:18:38,380 --> 00:18:40,960
throw

00:18:38,800 --> 00:18:43,390
you as s with index can pasture the same

00:18:40,960 --> 00:18:45,010
thing like someone could have made it

00:18:43,390 --> 00:18:47,320
swallow exceptions or do something crazy

00:18:45,010 --> 00:18:49,930
but it's unreasonable to expect that

00:18:47,320 --> 00:18:51,310
right the way I'm expecting the code to

00:18:49,930 --> 00:18:52,690
work is the most natural way for that

00:18:51,310 --> 00:18:55,630
author to have written it it's very

00:18:52,690 --> 00:18:57,010
obvious from the implementation so you

00:18:55,630 --> 00:19:01,270
know I don't care about these three

00:18:57,010 --> 00:19:04,360
questions anymore and as for the pointer

00:19:01,270 --> 00:19:07,900
forget index don't use pointers to

00:19:04,360 --> 00:19:09,970
express null ability youth there's boost

00:19:07,900 --> 00:19:12,090
optional you could pick a sentinel value

00:19:09,970 --> 00:19:14,080
if it's something like it you entered it

00:19:12,090 --> 00:19:16,090
you could have changed that you went to

00:19:14,080 --> 00:19:17,830
an int and a negative value is you know

00:19:16,090 --> 00:19:19,120
the range of central values something

00:19:17,830 --> 00:19:22,450
like that because when I have the

00:19:19,120 --> 00:19:24,100
pointer and I have you know I get the

00:19:22,450 --> 00:19:25,360
pointer which tells me the index and

00:19:24,100 --> 00:19:27,130
then I have a bunch of operations and I

00:19:25,360 --> 00:19:28,960
want to I want to use that index again

00:19:27,130 --> 00:19:30,220
if I didn't do reference that pointer up

00:19:28,960 --> 00:19:31,300
here before I've made those to be

00:19:30,220 --> 00:19:32,590
function calls now I have to think like

00:19:31,300 --> 00:19:33,730
did that change out from under me

00:19:32,590 --> 00:19:35,710
because of one of those function calls

00:19:33,730 --> 00:19:36,940
or did it not I'm thinking about life

00:19:35,710 --> 00:19:38,290
time and think about identity and

00:19:36,940 --> 00:19:39,460
thinking about address is a memory when

00:19:38,290 --> 00:19:41,350
I should be thinking about what the

00:19:39,460 --> 00:19:43,180
program does which is always in terms of

00:19:41,350 --> 00:19:47,500
value not in terms of pointers and

00:19:43,180 --> 00:19:49,000
pointer tasty okay okay so as another

00:19:47,500 --> 00:19:50,620
guideline just keep raw and cherry

00:19:49,000 --> 00:19:52,270
pointers out of your interfaces whenever

00:19:50,620 --> 00:19:55,600
you can help it they make your code

00:19:52,270 --> 00:19:57,400
harder to reason about when you have Ron

00:19:55,600 --> 00:19:58,660
shared pointers they are a form of

00:19:57,400 --> 00:20:00,250
shared state this is the world

00:19:58,660 --> 00:20:03,670
equivalent of using global data in your

00:20:00,250 --> 00:20:06,340
program okay so if I have a global data

00:20:03,670 --> 00:20:07,870
member or sort of global variable if

00:20:06,340 --> 00:20:08,980
I've got three or four references to it

00:20:07,870 --> 00:20:10,780
you know you've got the problem that

00:20:08,980 --> 00:20:12,880
references to it grow over time and that

00:20:10,780 --> 00:20:14,350
becomes a problem and it's just harder

00:20:12,880 --> 00:20:15,790
the reason about even in among those

00:20:14,350 --> 00:20:18,550
three or four references right so I've

00:20:15,790 --> 00:20:19,960
got the the the consideration that one

00:20:18,550 --> 00:20:21,310
of those other three or four references

00:20:19,960 --> 00:20:24,460
might have changed the value out from

00:20:21,310 --> 00:20:26,830
under me at some point during my one of

00:20:24,460 --> 00:20:28,090
those one of those scopes okay so again

00:20:26,830 --> 00:20:29,830
don't we don't want to think about

00:20:28,090 --> 00:20:31,450
lifetimes of objects we want to think

00:20:29,830 --> 00:20:34,960
about what they do because that's what

00:20:31,450 --> 00:20:36,160
the program does okay so we covered

00:20:34,960 --> 00:20:37,600
these four things that names are

00:20:36,160 --> 00:20:38,800
important that there's this principal

00:20:37,600 --> 00:20:40,480
least surprise we don't want to violate

00:20:38,800 --> 00:20:42,460
though we should make our interfaces

00:20:40,480 --> 00:20:44,980
impossible or if necessary

00:20:42,460 --> 00:20:48,390
difficult to use and avoid alias but

00:20:44,980 --> 00:20:50,860
there's a common element of always and

00:20:48,390 --> 00:20:53,020
in fact I would say that they're all

00:20:50,860 --> 00:20:55,690
saying the same thing which is that your

00:20:53,020 --> 00:20:57,640
code must be easy to reason about I

00:20:55,690 --> 00:20:59,140
don't actually consider these four

00:20:57,640 --> 00:21:01,420
different pieces of advice it's sort of

00:20:59,140 --> 00:21:03,430
different ways of saying a small part of

00:21:01,420 --> 00:21:04,930
the major piece of advice just one piece

00:21:03,430 --> 00:21:06,490
of advice your code needs to be easy to

00:21:04,930 --> 00:21:07,780
reason about these are four different

00:21:06,490 --> 00:21:09,340
ways in which you can make your code

00:21:07,780 --> 00:21:15,130
easier or harder to reason about but

00:21:09,340 --> 00:21:16,510
it's the same piece of advice all right

00:21:15,130 --> 00:21:17,500
so composability I put in its own

00:21:16,510 --> 00:21:19,360
section because I think it's very

00:21:17,500 --> 00:21:21,760
important but it's just an aspect of

00:21:19,360 --> 00:21:24,820
usability okay so this is this is kind

00:21:21,760 --> 00:21:26,770
of more of the same issues so I'm gonna

00:21:24,820 --> 00:21:28,900
put some blanket assertions up here and

00:21:26,770 --> 00:21:30,130
hopefully I will justify some or all of

00:21:28,900 --> 00:21:32,050
them and hopefully some of them will

00:21:30,130 --> 00:21:34,600
just be obvious once you have stayed in

00:21:32,050 --> 00:21:36,370
the way I'm going to so first I think

00:21:34,600 --> 00:21:37,840
type should be regular regular means

00:21:36,370 --> 00:21:39,520
that something is default constructible

00:21:37,840 --> 00:21:41,260
it's copyable it's assignable it's

00:21:39,520 --> 00:21:44,020
movable it's destructible and it's

00:21:41,260 --> 00:21:45,460
equality comparable if I don't have a

00:21:44,020 --> 00:21:47,890
quality comparable this is something

00:21:45,460 --> 00:21:51,940
called semi-regular which you'll see in

00:21:47,890 --> 00:21:53,290
a second it's also very useful copy an

00:21:51,940 --> 00:21:55,570
assignment though must not create

00:21:53,290 --> 00:21:58,150
aliases so shared footer has all of this

00:21:55,570 --> 00:22:00,580
it is not regular because when you copy

00:21:58,150 --> 00:22:01,870
a schertler you now have two references

00:22:00,580 --> 00:22:03,820
to the same data they do not have

00:22:01,870 --> 00:22:06,100
independent state even across copies

00:22:03,820 --> 00:22:08,440
okay like I said some here we go is

00:22:06,100 --> 00:22:10,000
often very useful too if you have all

00:22:08,440 --> 00:22:12,580
the rest of these you can't compare them

00:22:10,000 --> 00:22:14,980
for equality that gets me most of what

00:22:12,580 --> 00:22:16,600
makes regular useful okay and here is

00:22:14,980 --> 00:22:18,580
what makes regular useful think of

00:22:16,600 --> 00:22:20,470
regular is like a number right numbers

00:22:18,580 --> 00:22:22,960
are easier to reason about the C++ API

00:22:20,470 --> 00:22:24,190
is okay they just are or you want to

00:22:22,960 --> 00:22:26,080
think about the world in terms of

00:22:24,190 --> 00:22:27,730
mathematical formulae when you can and

00:22:26,080 --> 00:22:30,670
when you can't deal with deal with

00:22:27,730 --> 00:22:33,310
classes and so forth okay moreover think

00:22:30,670 --> 00:22:35,620
about regular is like a banana okay with

00:22:33,310 --> 00:22:37,300
the exception of copy it's you can all

00:22:35,620 --> 00:22:40,510
these properties apply to bananas okay

00:22:37,300 --> 00:22:41,830
so I heard someone say something very

00:22:40,510 --> 00:22:44,290
insightful during a talk one time he

00:22:41,830 --> 00:22:46,090
said you know people people worry about

00:22:44,290 --> 00:22:48,340
the move from state of an object this is

00:22:46,090 --> 00:22:50,880
this is a big topic and C++ in Lebanon

00:22:48,340 --> 00:22:53,450
later if I move this remote over here

00:22:50,880 --> 00:22:56,389
what happens to that well there is

00:22:53,450 --> 00:22:57,859
this is the remote like I'm not looking

00:22:56,389 --> 00:22:59,479
for the banana or if this is the same

00:22:57,859 --> 00:23:01,070
banana the banana it's just a banana

00:22:59,479 --> 00:23:03,589
there's not more than one reference to

00:23:01,070 --> 00:23:05,629
it it's a banana ok so if you can think

00:23:03,589 --> 00:23:07,969
about the world in this very simple way

00:23:05,629 --> 00:23:09,109
of like actual objects that live in your

00:23:07,969 --> 00:23:10,940
code I'm not talking about object

00:23:09,109 --> 00:23:12,919
orientation talking about the entities

00:23:10,940 --> 00:23:14,690
in your code are real things in the real

00:23:12,919 --> 00:23:17,179
world if you can get the lifetime

00:23:14,690 --> 00:23:20,719
semantics out of your thinking you will

00:23:17,179 --> 00:23:23,509
make more code that is more extensible

00:23:20,719 --> 00:23:24,769
more maintainable faster ok and of

00:23:23,509 --> 00:23:25,909
course bananas are these are is about

00:23:24,769 --> 00:23:28,399
even the numbers ok

00:23:25,909 --> 00:23:30,049
so functions should be pure that means

00:23:28,399 --> 00:23:31,639
that they depend only on their inputs

00:23:30,049 --> 00:23:32,809
they do not mutate their inputs and they

00:23:31,639 --> 00:23:34,579
have no other side effects

00:23:32,809 --> 00:23:37,190
ok retain their butts obviously a kind

00:23:34,579 --> 00:23:38,809
of side effect so remember XOR swap

00:23:37,190 --> 00:23:40,700
right we have a lot of trouble getting

00:23:38,809 --> 00:23:43,339
to a good implementation of it when we

00:23:40,700 --> 00:23:44,929
started from the point of view that we

00:23:43,339 --> 00:23:48,829
were gonna make a function of mutate

00:23:44,929 --> 00:23:51,559
since it's our chance so when you see

00:23:48,829 --> 00:23:53,799
this function call what is an issue that

00:23:51,559 --> 00:23:56,059
comes up you get shattered out anybody

00:23:53,799 --> 00:23:57,409
order an evaluation right so we've got

00:23:56,059 --> 00:23:59,809
two function calls in the same

00:23:57,409 --> 00:24:02,389
expression which one happens first is an

00:23:59,809 --> 00:24:03,700
issue unless they're pure then I don't

00:24:02,389 --> 00:24:06,709
care

00:24:03,700 --> 00:24:07,820
again we're not thinking about addresses

00:24:06,709 --> 00:24:09,759
anymore we're thinking about what the

00:24:07,820 --> 00:24:12,079
program does when we write it like this

00:24:09,759 --> 00:24:13,999
we don't have to think about like maybe

00:24:12,079 --> 00:24:16,039
who does some crazy increment and then a

00:24:13,999 --> 00:24:17,599
test and so I don't know if the two

00:24:16,039 --> 00:24:19,399
increments happen in which order they

00:24:17,599 --> 00:24:21,739
happen in especially in case of inlining

00:24:19,399 --> 00:24:24,669
and stuff so just get rid of all these

00:24:21,739 --> 00:24:28,609
things just make these functions pure ok

00:24:24,669 --> 00:24:30,950
type should define a basis so a basis is

00:24:28,609 --> 00:24:34,070
a set of member functions which is the

00:24:30,950 --> 00:24:36,320
minimal set of member functions that you

00:24:34,070 --> 00:24:41,269
need to maintain the invariance of your

00:24:36,320 --> 00:24:43,309
type ok so that means you don't include

00:24:41,269 --> 00:24:45,259
anything else that is a function of the

00:24:43,309 --> 00:24:48,679
basis or that it's outside of the basis

00:24:45,259 --> 00:24:52,369
ok as an example this why don't we have

00:24:48,679 --> 00:24:55,700
vector sort why isn't anything right

00:24:52,369 --> 00:24:56,719
it's Dom is walking right we wait

00:24:55,700 --> 00:24:59,119
hopefully we don't do a lot of dumb

00:24:56,719 --> 00:25:01,320
things as a standard library convention

00:24:59,119 --> 00:25:03,809
so we have stood sort which

00:25:01,320 --> 00:25:04,980
in terms of vector or spit array and it

00:25:03,809 --> 00:25:06,899
makes no difference which one you use

00:25:04,980 --> 00:25:08,070
right that's because we have standard

00:25:06,899 --> 00:25:09,360
algorithms here at da in terms of the

00:25:08,070 --> 00:25:11,039
five iterative categories you have at

00:25:09,360 --> 00:25:12,929
most five implementations of any

00:25:11,039 --> 00:25:14,850
standard algorithm and you can have an

00:25:12,929 --> 00:25:16,799
infinite number or simply unbounded

00:25:14,850 --> 00:25:18,210
number of container types and they all

00:25:16,799 --> 00:25:20,789
have some iterative categories to

00:25:18,210 --> 00:25:23,399
develop in the standard algorithms okay

00:25:20,789 --> 00:25:26,009
so we don't want to have a different

00:25:23,399 --> 00:25:28,049
sort for each container and so that

00:25:26,009 --> 00:25:29,730
indicates to us that we shouldn't be

00:25:28,049 --> 00:25:31,860
adding things like sort that are

00:25:29,730 --> 00:25:35,340
extraneous to the basis of the type

00:25:31,860 --> 00:25:37,679
itself okay we define stood sort in

00:25:35,340 --> 00:25:39,779
terms of subsets of the basis which is

00:25:37,679 --> 00:25:44,940
just begin and end on the containers we

00:25:39,779 --> 00:25:46,409
want to sort so again you should not add

00:25:44,940 --> 00:25:48,899
things that are there extraneous to the

00:25:46,409 --> 00:25:53,129
basis and when you when you employ that

00:25:48,899 --> 00:25:55,139
discipline you're able to pull things

00:25:53,129 --> 00:25:56,460
out and generalize in a way that you

00:25:55,139 --> 00:25:59,220
wouldn't that wouldn't occur to you

00:25:56,460 --> 00:26:03,360
before so if instead of having stood

00:25:59,220 --> 00:26:05,399
sort I had stood array sort and state

00:26:03,360 --> 00:26:07,529
vector sort I would implement each one

00:26:05,399 --> 00:26:09,720
in terms of the guts of that type and

00:26:07,529 --> 00:26:12,870
then that code would not be reusable

00:26:09,720 --> 00:26:15,179
across those two if I say I'm only going

00:26:12,870 --> 00:26:16,919
to do stood sort in terms of those other

00:26:15,179 --> 00:26:18,090
two API sometimes the beginning end of

00:26:16,919 --> 00:26:20,580
those things now I have to suddenly

00:26:18,090 --> 00:26:22,620
write code that is truly general-purpose

00:26:20,580 --> 00:26:24,419
it could be used for both cases and that

00:26:22,620 --> 00:26:25,740
doesn't apply this just containers and

00:26:24,419 --> 00:26:27,600
sorting this compliant this applies to

00:26:25,740 --> 00:26:29,340
any two types that you've got that you

00:26:27,600 --> 00:26:31,409
want to do a common operation on right

00:26:29,340 --> 00:26:32,549
you will find a ways of generalizing and

00:26:31,409 --> 00:26:34,289
writing generic code and being more

00:26:32,549 --> 00:26:37,049
productive if you if you enforce this

00:26:34,289 --> 00:26:38,220
discipline okay so if you want to see a

00:26:37,049 --> 00:26:39,330
counter example that you can look at

00:26:38,220 --> 00:26:40,950
stood a string which doesn't famously

00:26:39,330 --> 00:26:42,649
fat interface which does the you know

00:26:40,950 --> 00:26:46,679
the kitchen sink is in this thing right

00:26:42,649 --> 00:26:49,080
recently stood array view was proposed I

00:26:46,679 --> 00:26:52,860
think it's in the library fundamentals

00:26:49,080 --> 00:26:56,399
TS and you know what the idea is you can

00:26:52,860 --> 00:26:57,870
pass in a constant R star to this or a

00:26:56,399 --> 00:26:59,490
stood string and then it has the

00:26:57,870 --> 00:27:01,440
interface of strings so you don't have

00:26:59,490 --> 00:27:03,840
to actually copy anything or have double

00:27:01,440 --> 00:27:06,790
overloads for you know efficiency and

00:27:03,840 --> 00:27:08,830
using a constant R star

00:27:06,790 --> 00:27:10,210
those cases where you've got one the

00:27:08,830 --> 00:27:12,430
problem with it is that it has to

00:27:10,210 --> 00:27:15,850
reproduce the entire API it's to string

00:27:12,430 --> 00:27:19,090
this giant fatty API right if we have

00:27:15,850 --> 00:27:21,100
algorithms on to the string or a

00:27:19,090 --> 00:27:22,300
constructs star that operated on strings

00:27:21,100 --> 00:27:24,070
of characters we wouldn't need to

00:27:22,300 --> 00:27:25,480
reproduce all this API and anyone that

00:27:24,070 --> 00:27:27,760
wanted to work a live stream wouldn't

00:27:25,480 --> 00:27:28,240
have to do it okay this is an important

00:27:27,760 --> 00:27:30,760
one

00:27:28,240 --> 00:27:33,070
all right so also container types need

00:27:30,760 --> 00:27:34,870
to be operable interoperable with STL

00:27:33,070 --> 00:27:36,280
algorithms so that means they need a

00:27:34,870 --> 00:27:38,470
beginning and they needed their own the

00:27:36,280 --> 00:27:40,300
iterator types so if you need to make a

00:27:38,470 --> 00:27:42,640
custom iterator to make this happen for

00:27:40,300 --> 00:27:45,160
your type get to know the loose ten

00:27:42,640 --> 00:27:47,800
Reiter library because it makes what is

00:27:45,160 --> 00:27:49,480
for any proposition making an iterator

00:27:47,800 --> 00:27:52,600
type but custom entertain for your

00:27:49,480 --> 00:27:54,310
container nearly trivial so here's an

00:27:52,600 --> 00:27:55,900
example of the amount of code you need

00:27:54,310 --> 00:27:57,820
then this is more or less kind of pasted

00:27:55,900 --> 00:27:59,680
over their documentation here's the

00:27:57,820 --> 00:28:01,270
amount of code you need to make a fort

00:27:59,680 --> 00:28:04,120
traversal iterator okay

00:28:01,270 --> 00:28:06,490
so the top part where we're inheriting

00:28:04,120 --> 00:28:10,360
from a type that type is just you know

00:28:06,490 --> 00:28:12,520
CR TP based iterator facade is what they

00:28:10,360 --> 00:28:15,430
call it so you give it the the type of

00:28:12,520 --> 00:28:17,680
the the classroom making here you give

00:28:15,430 --> 00:28:20,080
it the the type of the underlying node

00:28:17,680 --> 00:28:22,180
that you've got and then you tell it

00:28:20,080 --> 00:28:24,640
with this for traversal tak tak that

00:28:22,180 --> 00:28:26,950
it's a forward iterator and then the

00:28:24,640 --> 00:28:28,510
rest of it is kind of boilerplate if you

00:28:26,950 --> 00:28:30,820
look near the body we've got increment

00:28:28,510 --> 00:28:31,930
equal and dereference those three

00:28:30,820 --> 00:28:33,460
functions where all the magic happens

00:28:31,930 --> 00:28:35,350
right that's where your actual until

00:28:33,460 --> 00:28:37,270
matei she goes so once you know that

00:28:35,350 --> 00:28:39,010
this is all the boilerplate you need

00:28:37,270 --> 00:28:40,900
then you just do those three implement

00:28:39,010 --> 00:28:42,340
those three everyone those three

00:28:40,900 --> 00:28:44,320
functions that do what you actually care

00:28:42,340 --> 00:28:45,850
about and all the boilerplate goes away

00:28:44,320 --> 00:28:49,270
a lot of the boilerplate you have to do

00:28:45,850 --> 00:28:51,550
for a standard iterator is hard to get

00:28:49,270 --> 00:28:52,840
right there's some subtleties that you

00:28:51,550 --> 00:28:54,460
take it takes some experience to do this

00:28:52,840 --> 00:28:58,389
this takes all that idea

00:28:54,460 --> 00:29:00,970
pants okay so you also need to make your

00:28:58,389 --> 00:29:04,509
types usable range based for loops okay

00:29:00,970 --> 00:29:06,100
this is really important okay so let me

00:29:04,509 --> 00:29:08,470
back up so the reason I'm saying this is

00:29:06,100 --> 00:29:10,720
that I recently had a container that one

00:29:08,470 --> 00:29:12,820
of my co-workers wrote that did not do

00:29:10,720 --> 00:29:15,039
this and we had to iterate across the

00:29:12,820 --> 00:29:18,039
elements based on index

00:29:15,039 --> 00:29:19,929
I caught an error in his code that he'd

00:29:18,039 --> 00:29:22,629
already written where he was hit a fence

00:29:19,929 --> 00:29:24,549
post issue with the iteration that was

00:29:22,629 --> 00:29:26,980
causing a bug and then I wrote another

00:29:24,549 --> 00:29:29,340
loop that had a similar problem on the

00:29:26,980 --> 00:29:32,919
other end the other fence post okay so

00:29:29,340 --> 00:29:34,720
making forward arrangements for loops

00:29:32,919 --> 00:29:36,159
usable by your code and gets rid of

00:29:34,720 --> 00:29:37,899
those kinds of fence post issues again

00:29:36,159 --> 00:29:39,639
it's obviating a whole class of errors

00:29:37,899 --> 00:29:41,200
that are possible okay okay

00:29:39,639 --> 00:29:42,789
and this takes very little effort so

00:29:41,200 --> 00:29:45,460
let's say I've got this customer a type

00:29:42,789 --> 00:29:47,499
and it's got some story say array or

00:29:45,460 --> 00:29:49,570
ever a vector or something so all I have

00:29:47,499 --> 00:29:51,519
to do is make these two free functions

00:29:49,570 --> 00:29:53,440
that take you know a cost ref to this

00:29:51,519 --> 00:29:56,619
array and then return the begin and end

00:29:53,440 --> 00:29:58,240
of its storage and that's it now I can

00:29:56,619 --> 00:30:00,369
use it down the bottom this real code

00:29:58,240 --> 00:30:02,019
that compiles and this custom array I'm

00:30:00,369 --> 00:30:04,179
just iterating over it I can teach each

00:30:02,019 --> 00:30:07,149
other one at a time

00:30:04,179 --> 00:30:09,220
I wrote the arrow deckle type that just

00:30:07,149 --> 00:30:12,730
so I didn't even have to know that the

00:30:09,220 --> 00:30:14,980
name of the pointed to value underneath

00:30:12,730 --> 00:30:16,450
there is our upside that the name of the

00:30:14,980 --> 00:30:18,100
the iterator is iterator versus

00:30:16,450 --> 00:30:20,080
concentrator I don't care I just want to

00:30:18,100 --> 00:30:21,820
write whatever it produces that's what

00:30:20,080 --> 00:30:23,710
goes there and the nice thing is see

00:30:21,820 --> 00:30:25,840
bustles 14 everything past the arrows

00:30:23,710 --> 00:30:27,820
can go away you just remove the arrow

00:30:25,840 --> 00:30:29,679
whatever and you just use automatic

00:30:27,820 --> 00:30:31,600
return type deduction so this is getting

00:30:29,679 --> 00:30:33,700
easier and easier and it's already easy

00:30:31,600 --> 00:30:36,970
right now you should do this

00:30:33,700 --> 00:30:38,950
alright so library types also need to be

00:30:36,970 --> 00:30:40,779
using a container subject if I've got my

00:30:38,950 --> 00:30:42,490
type and I want to use your type in it I

00:30:40,779 --> 00:30:45,490
better be able to have it as a member

00:30:42,490 --> 00:30:48,309
that better be easy to do if I have to

00:30:45,490 --> 00:30:50,140
make your thing hanging off the end of a

00:30:48,309 --> 00:30:52,090
pointer inside my class even if it's a

00:30:50,140 --> 00:30:55,360
unique footer that makes it harder for

00:30:52,090 --> 00:30:58,210
me to get my work done if I can't use

00:30:55,360 --> 00:31:00,190
your type in a stood vector we got

00:30:58,210 --> 00:31:01,660
problems right that's a fundamental data

00:31:00,190 --> 00:31:01,870
structure that we use every day all the

00:31:01,660 --> 00:31:05,559
time

00:31:01,870 --> 00:31:07,809
and so the most controversial part of

00:31:05,559 --> 00:31:11,530
the regular concept that I talked about

00:31:07,809 --> 00:31:13,120
before is that regular has default

00:31:11,530 --> 00:31:15,850
constructible a lot of people grouse

00:31:13,120 --> 00:31:17,110
about this being a weakening of

00:31:15,850 --> 00:31:19,030
invariance for your types if you've got

00:31:17,110 --> 00:31:20,500
a type it can only construct certain

00:31:19,030 --> 00:31:21,850
ways and you don't want it to be

00:31:20,500 --> 00:31:23,710
billable you don't want to have an empty

00:31:21,850 --> 00:31:26,620
state you don't want the default page

00:31:23,710 --> 00:31:28,600
character I argue that I care for myself

00:31:26,620 --> 00:31:29,770
more about being able to put one in the

00:31:28,600 --> 00:31:31,540
stood vector and being able to call

00:31:29,770 --> 00:31:33,370
resize with only one element which

00:31:31,540 --> 00:31:35,200
requires a default a default constructor

00:31:33,370 --> 00:31:36,730
so that's just the way I work and I

00:31:35,200 --> 00:31:37,960
really care about that some people

00:31:36,730 --> 00:31:39,670
really care about strengthening the

00:31:37,960 --> 00:31:42,640
invariance that either one of these is

00:31:39,670 --> 00:31:45,640
fine but think about this and consider

00:31:42,640 --> 00:31:47,260
that this is an important case for you

00:31:45,640 --> 00:31:50,230
know making your types of reusable even

00:31:47,260 --> 00:31:51,700
if it weakens be variants okay so

00:31:50,230 --> 00:31:52,450
regular a general helps with

00:31:51,700 --> 00:31:54,220
composability

00:31:52,450 --> 00:31:57,040
a whole lot right if you're able to

00:31:54,220 --> 00:31:58,420
treat something as a banana you throw

00:31:57,040 --> 00:32:00,100
the banana in the basket you lined up

00:31:58,420 --> 00:32:01,740
bananas on the table whatever they just

00:32:00,100 --> 00:32:04,210
go over everything you know to go okay

00:32:01,740 --> 00:32:05,920
so library types need to be

00:32:04,210 --> 00:32:07,470
constructible anywhere that someone

00:32:05,920 --> 00:32:09,370
wants to construct on whenever possible

00:32:07,470 --> 00:32:12,220
everybody knows about constructs and

00:32:09,370 --> 00:32:14,320
stuff on the heap and the stack a lot

00:32:12,220 --> 00:32:16,870
people don't really think about making

00:32:14,320 --> 00:32:18,460
something with a context or constructor

00:32:16,870 --> 00:32:20,860
and they also don't really think about

00:32:18,460 --> 00:32:23,679
making something Rama Bowl by making it

00:32:20,860 --> 00:32:27,100
you know like brace initializer belen

00:32:23,679 --> 00:32:29,559
static static scope right so if it's

00:32:27,100 --> 00:32:30,940
static in it but it calls new then

00:32:29,559 --> 00:32:32,080
you're not going to be able to stick

00:32:30,940 --> 00:32:34,720
that and wrong but if it's something

00:32:32,080 --> 00:32:36,370
that just has like you know literal data

00:32:34,720 --> 00:32:38,800
types and sits in there that can be

00:32:36,370 --> 00:32:40,990
caustics or just wobble and non-cost

00:32:38,800 --> 00:32:43,450
you don't one of those things is is very

00:32:40,990 --> 00:32:44,980
nice okay if you've got to type the

00:32:43,450 --> 00:32:46,929
download stuff from the internet and

00:32:44,980 --> 00:32:49,360
it's constructor then this doesn't work

00:32:46,929 --> 00:32:50,770
but wherever it's possible to get those

00:32:49,360 --> 00:32:51,520
other two use cases you should strive

00:32:50,770 --> 00:32:53,380
for that because

00:32:51,520 --> 00:32:55,600
again you don't know who's using this

00:32:53,380 --> 00:32:56,790
type and what their conditions for users

00:32:55,600 --> 00:33:00,670
are going

00:32:56,790 --> 00:33:02,020
so error messages are important but one

00:33:00,670 --> 00:33:03,160
thing that a lot of people miss when

00:33:02,020 --> 00:33:04,630
they're doing anything or involves any

00:33:03,160 --> 00:33:05,980
kind of template metaprogramming is that

00:33:04,630 --> 00:33:08,170
they're like well you know the compiler

00:33:05,980 --> 00:33:11,470
produces the spew of template errors and

00:33:08,170 --> 00:33:13,000
what am I going to do right well if that

00:33:11,470 --> 00:33:14,620
is the case in your library is going to

00:33:13,000 --> 00:33:17,110
be unusable to a certain class of

00:33:14,620 --> 00:33:19,210
programmer if you look at boost graph or

00:33:17,110 --> 00:33:21,070
lose spirit in both our great libraries

00:33:19,210 --> 00:33:22,660
that do what they do very well and if

00:33:21,070 --> 00:33:24,550
you make the slightest mistake they

00:33:22,660 --> 00:33:26,620
punish and viciously flutter with error

00:33:24,550 --> 00:33:28,059
messages okay and so there's lots of

00:33:26,620 --> 00:33:29,710
people that I know that are you know

00:33:28,059 --> 00:33:31,330
hardcore spirit developers that are like

00:33:29,710 --> 00:33:32,410
I make one line change my compiler make

00:33:31,330 --> 00:33:33,790
a one line change and I could probably

00:33:32,410 --> 00:33:34,630
go on line change my third line because

00:33:33,790 --> 00:33:39,610
there's no way I can getting work done

00:33:34,630 --> 00:33:41,770
so if something like this is the library

00:33:39,610 --> 00:33:44,710
you're gonna be writing you need to come

00:33:41,770 --> 00:33:46,540
up with some kind of you know a

00:33:44,710 --> 00:33:48,580
convention that communicates errors to

00:33:46,540 --> 00:33:51,960
the user in a reasonable way so I wrote

00:33:48,580 --> 00:33:55,030
a linear algebra library that had

00:33:51,960 --> 00:33:56,980
matrices with static sizes and a bunch

00:33:55,030 --> 00:34:00,250
of different types in there and they're

00:33:56,980 --> 00:34:05,200
inside the matrices and I couldn't

00:34:00,250 --> 00:34:06,460
really find a way to stop you know let's

00:34:05,200 --> 00:34:08,320
say you're doing a matrix multiply like

00:34:06,460 --> 00:34:10,659
somewhere down in this you know three

00:34:08,320 --> 00:34:12,340
deep nested for loop you're going to

00:34:10,659 --> 00:34:14,440
have two types and we try to use them

00:34:12,340 --> 00:34:15,820
together if that blows up there's no way

00:34:14,440 --> 00:34:17,619
for me to sort of catch that from the

00:34:15,820 --> 00:34:19,090
outside that that's gonna happen so I

00:34:17,619 --> 00:34:21,100
just have to live with this template

00:34:19,090 --> 00:34:22,480
ever spewed but what I also did was I

00:34:21,100 --> 00:34:24,250
said that I'm going to use a

00:34:22,480 --> 00:34:27,280
substitution failure it's not an error

00:34:24,250 --> 00:34:28,750
in let's say operator x so that if these

00:34:27,280 --> 00:34:30,190
two matrices don't have the same

00:34:28,750 --> 00:34:32,409
dimensions that I'm going to say like

00:34:30,190 --> 00:34:34,629
that function gets removed from the

00:34:32,409 --> 00:34:37,270
overload set and so if you say a times B

00:34:34,629 --> 00:34:40,119
and the compiler says there is no any

00:34:37,270 --> 00:34:41,980
times B then you know oh well that means

00:34:40,119 --> 00:34:44,020
that they're the wrong dimensions of

00:34:41,980 --> 00:34:46,899
matrix right if you get this huge mess

00:34:44,020 --> 00:34:48,940
then you know oh I made a mistake in the

00:34:46,899 --> 00:34:51,450
dimensions of the the units I put inside

00:34:48,940 --> 00:34:51,450
okay

00:34:51,820 --> 00:34:55,720
that's the next thing I was gonna say so

00:34:53,440 --> 00:34:57,070
I also made static concerns at certain

00:34:55,720 --> 00:34:59,020
places to catch certain conditions that

00:34:57,070 --> 00:35:01,240
I knew were common and then when you go

00:34:59,020 --> 00:35:03,100
to that static assert a big fat note

00:35:01,240 --> 00:35:04,750
saying like this is why you hit the

00:35:03,100 --> 00:35:06,040
static assert right and I feel like

00:35:04,750 --> 00:35:07,420
that's a pretty good convention and if

00:35:06,040 --> 00:35:08,530
you do any kind of better program you

00:35:07,420 --> 00:35:09,940
need to come up with something like this

00:35:08,530 --> 00:35:14,550
to communicate problems back to the

00:35:09,940 --> 00:35:17,560
users okay I've been saying a lot

00:35:14,550 --> 00:35:19,420
so what I want you to take away from all

00:35:17,560 --> 00:35:22,060
these shoulds is that you should strive

00:35:19,420 --> 00:35:23,920
for it is impossible to use wrong it is

00:35:22,060 --> 00:35:26,410
maximally efficient is maximally

00:35:23,920 --> 00:35:28,660
composable with other code and then only

00:35:26,410 --> 00:35:30,870
compromise on that when you have to and

00:35:28,660 --> 00:35:33,100
sometimes you simply have to write so

00:35:30,870 --> 00:35:35,290
I'm not saying you should get carried

00:35:33,100 --> 00:35:36,580
away and make something like for

00:35:35,290 --> 00:35:38,560
instance the example I gave before about

00:35:36,580 --> 00:35:40,150
making input iterators rearranges like

00:35:38,560 --> 00:35:42,010
if you decide that actually do care

00:35:40,150 --> 00:35:44,380
about the indexing into that range don't

00:35:42,010 --> 00:35:46,180
make this type with input iterators and

00:35:44,380 --> 00:35:47,350
say no one can index into it because I

00:35:46,180 --> 00:35:49,540
don't want that kind of error when it

00:35:47,350 --> 00:35:50,830
just gets rid of a whole bit of

00:35:49,540 --> 00:35:52,840
functional you actually need your live

00:35:50,830 --> 00:35:55,020
way for some reason okay so that's it's

00:35:52,840 --> 00:35:57,700
another case so don't get carried away

00:35:55,020 --> 00:35:58,810
it's not wrong to use non regular types

00:35:57,700 --> 00:36:00,580
and if your functions and stuff

00:35:58,810 --> 00:36:02,170
sometimes you need to for performance

00:36:00,580 --> 00:36:03,790
reasons as I said before they've got a

00:36:02,170 --> 00:36:07,030
large object you want to pass it by cost

00:36:03,790 --> 00:36:08,260
graph that's not you know there's some

00:36:07,030 --> 00:36:10,620
cases at which that means the function

00:36:08,260 --> 00:36:13,510
is not pure and and that's probably okay

00:36:10,620 --> 00:36:15,580
but again get as close to that as you

00:36:13,510 --> 00:36:17,440
can have that ideal thing in your mind

00:36:15,580 --> 00:36:20,310
and keep trying to hit back to that and

00:36:17,440 --> 00:36:23,050
then only only compromise me you have to

00:36:20,310 --> 00:36:26,020
okay so here's the grab bag of library

00:36:23,050 --> 00:36:27,100
of annotation tips so one another claim

00:36:26,020 --> 00:36:29,110
I'm gonna make is that implementation

00:36:27,100 --> 00:36:31,210
design these are synonymous for for

00:36:29,110 --> 00:36:32,620
writing programs right you have some way

00:36:31,210 --> 00:36:34,000
you think you're going to implement code

00:36:32,620 --> 00:36:36,250
and you go to actually implement the

00:36:34,000 --> 00:36:37,950
code and it turns out that you've got

00:36:36,250 --> 00:36:41,170
this complete impedance mismatch between

00:36:37,950 --> 00:36:42,850
unit a unit B they just don't cooperate

00:36:41,170 --> 00:36:44,350
with without this other bit of

00:36:42,850 --> 00:36:45,280
functionality you didn't didn't realize

00:36:44,350 --> 00:36:48,850
you needed until you started

00:36:45,280 --> 00:36:50,980
implementing this means that as you go

00:36:48,850 --> 00:36:53,200
you need to be using your own code and

00:36:50,980 --> 00:36:54,430
refining where there are problems like

00:36:53,200 --> 00:36:57,740
this needs to be a constant thing

00:36:54,430 --> 00:36:59,030
especially the early stages of

00:36:57,740 --> 00:37:00,710
this is iterative you're not gonna get

00:36:59,030 --> 00:37:03,850
right in the first pass you're probably

00:37:00,710 --> 00:37:06,200
right on the third pass either okay and

00:37:03,850 --> 00:37:07,130
writing test as you go really really

00:37:06,200 --> 00:37:08,600
helps with this hopefully we're all

00:37:07,130 --> 00:37:10,160
testing our code but realistically it

00:37:08,600 --> 00:37:12,650
doesn't happen sometimes in some places

00:37:10,160 --> 00:37:14,180
the more tests you write the better your

00:37:12,650 --> 00:37:17,630
interfaces will get not just the more

00:37:14,180 --> 00:37:19,910
correct okay and start with just writing

00:37:17,630 --> 00:37:21,140
you know fairly extensive snippets of

00:37:19,910 --> 00:37:22,580
what you want the client code to look

00:37:21,140 --> 00:37:23,750
like before anything compiles before

00:37:22,580 --> 00:37:25,730
you've written a single line of your own

00:37:23,750 --> 00:37:27,950
library code and keep referring back to

00:37:25,730 --> 00:37:29,690
that and if you can't get the

00:37:27,950 --> 00:37:31,880
implementation to match the ease-of-use

00:37:29,690 --> 00:37:33,920
that you wrote when you said if I had my

00:37:31,880 --> 00:37:35,810
druthers this is what I would write then

00:37:33,920 --> 00:37:39,050
again go back and sand off those rough

00:37:35,810 --> 00:37:40,670
corners so and you know this is a

00:37:39,050 --> 00:37:44,270
process of discovering the right

00:37:40,670 --> 00:37:46,430
solution you know I mean you're not

00:37:44,270 --> 00:37:48,190
inventing anything new right get very

00:37:46,430 --> 00:37:51,140
familiar with lots of other libraries

00:37:48,190 --> 00:37:52,310
there are any number of library

00:37:51,140 --> 00:37:54,290
development problems and they've all

00:37:52,310 --> 00:37:56,750
been solved by somebody somewhere so so

00:37:54,290 --> 00:37:58,040
read a lot of the code and if you try

00:37:56,750 --> 00:38:00,770
something and it doesn't work if you

00:37:58,040 --> 00:38:02,270
refer back to that that example code

00:38:00,770 --> 00:38:04,040
you're writing as you go and you find

00:38:02,270 --> 00:38:06,050
that something doesn't work the way you

00:38:04,040 --> 00:38:08,420
want it to then you need to keep looking

00:38:06,050 --> 00:38:11,510
right the reason I say these things this

00:38:08,420 --> 00:38:12,650
way is that I find that a lot of people

00:38:11,510 --> 00:38:14,870
I work with are like well this works

00:38:12,650 --> 00:38:16,820
pretty well and I'm like we need to find

00:38:14,870 --> 00:38:17,900
a way to make it perfect and only when

00:38:16,820 --> 00:38:19,730
we prove for ourselves that's not

00:38:17,900 --> 00:38:21,920
perfect do we settle and if you don't

00:38:19,730 --> 00:38:23,450
keep that mindset it's easy to to slip

00:38:21,920 --> 00:38:27,710
into something that's that's highly

00:38:23,450 --> 00:38:29,060
imperfect so an important metric to this

00:38:27,710 --> 00:38:30,560
process is something hopefully everyone

00:38:29,060 --> 00:38:33,320
else has heard too that you make simple

00:38:30,560 --> 00:38:36,260
things simple and not simple things

00:38:33,320 --> 00:38:38,540
straightforward to do okay so the common

00:38:36,260 --> 00:38:40,910
case of use you need to be able to write

00:38:38,540 --> 00:38:42,690
very succinctly and easily in your

00:38:40,910 --> 00:38:44,550
sample that you're there working

00:38:42,690 --> 00:38:47,100
that is the target code you want clients

00:38:44,550 --> 00:38:48,840
to write and if you find you're drifting

00:38:47,100 --> 00:38:53,670
away from that you may be a redesign

00:38:48,840 --> 00:38:56,460
okay so it has an example oh there

00:38:53,670 --> 00:38:59,220
should be daxpy okay well that says a

00:38:56,460 --> 00:39:01,490
lot about bad names so Saxby is actually

00:38:59,220 --> 00:39:04,620
a float for the a and not a double but

00:39:01,490 --> 00:39:07,080
these are actual functions from like a

00:39:04,620 --> 00:39:10,770
blast implementation so light from the

00:39:07,080 --> 00:39:13,020
Fortran days there's a standard Blas API

00:39:10,770 --> 00:39:17,820
for doing linear algebra and in this

00:39:13,020 --> 00:39:20,190
case Saxby means single precision x same

00:39:17,820 --> 00:39:23,640
precision a times X plus y that's what

00:39:20,190 --> 00:39:27,060
this thing returns okay now Dax B means

00:39:23,640 --> 00:39:28,770
double precision a times X plus y okay

00:39:27,060 --> 00:39:33,210
so there's a lot of them they're insane

00:39:28,770 --> 00:39:36,030
names right so if instead I did operator

00:39:33,210 --> 00:39:40,110
star and operator plus and I was able to

00:39:36,030 --> 00:39:41,670
write a times X plus y everyone's gonna

00:39:40,110 --> 00:39:43,470
know what I'm doing right this is

00:39:41,670 --> 00:39:46,760
obvious code everyone gets it you don't

00:39:43,470 --> 00:39:51,660
think know what sacs mean Dax baby okay

00:39:46,760 --> 00:39:53,760
in order to get back to actually calling

00:39:51,660 --> 00:39:55,140
code that looks like sacs beard ax B you

00:39:53,760 --> 00:39:56,910
need to use something called expression

00:39:55,140 --> 00:39:58,800
templates if you don't know what that is

00:39:56,910 --> 00:40:01,070
don't write a linear algebra library but

00:39:58,800 --> 00:40:01,070
it's

00:40:01,360 --> 00:40:06,700
that's a very that's a very heavy topic

00:40:05,110 --> 00:40:09,540
and there was a three-hour talk on it

00:40:06,700 --> 00:40:13,750
yesterday the case in my David's ago so

00:40:09,540 --> 00:40:14,890
in order to transform this into Saxby

00:40:13,750 --> 00:40:17,350
and the reason you want to do that is

00:40:14,890 --> 00:40:19,930
because Saxby exists because that is way

00:40:17,350 --> 00:40:21,520
more efficient than doing the a times X

00:40:19,930 --> 00:40:23,080
by itself and then adding the why doing

00:40:21,520 --> 00:40:25,210
it all in one step is way more efficient

00:40:23,080 --> 00:40:28,210
so again you want people to write code

00:40:25,210 --> 00:40:29,920
like a times x plus y but at the same

00:40:28,210 --> 00:40:31,780
time you don't want to give up the

00:40:29,920 --> 00:40:33,190
efficiency so there's an important point

00:40:31,780 --> 00:40:35,080
here which is that again you want to

00:40:33,190 --> 00:40:36,940
refer back to like what do I want my

00:40:35,080 --> 00:40:38,530
user code to look like and if I have to

00:40:36,940 --> 00:40:39,850
jump through some insane hoops and do a

00:40:38,530 --> 00:40:41,500
bunch of gymnastics to make that

00:40:39,850 --> 00:40:43,180
efficient then that's just what I have

00:40:41,500 --> 00:40:45,250
to buy it off as a library writer right

00:40:43,180 --> 00:40:46,600
and compromising and saying no

00:40:45,250 --> 00:40:50,230
everything's gonna be called sacks being

00:40:46,600 --> 00:40:51,670
back speed is not sufficient okay so

00:40:50,230 --> 00:40:53,830
documentation is important to users some

00:40:51,670 --> 00:40:55,210
very large libraries have great

00:40:53,830 --> 00:40:56,770
documentation and without it they would

00:40:55,210 --> 00:40:59,050
be largely useless though if anybody

00:40:56,770 --> 00:41:00,700
here is whose spirit but it's this huge

00:40:59,050 --> 00:41:02,560
parsing library that does all kinds of

00:41:00,700 --> 00:41:04,450
stuff and it's got very extensive

00:41:02,560 --> 00:41:06,370
documentation without that documentation

00:41:04,450 --> 00:41:08,050
you have no clue what this library does

00:41:06,370 --> 00:41:11,590
right there's lots of stuff in there

00:41:08,050 --> 00:41:13,720
but aside from that Doc's are very very

00:41:11,590 --> 00:41:16,960
important to the implementation and

00:41:13,720 --> 00:41:19,180
design process I have found myself so

00:41:16,960 --> 00:41:21,400
many times writing documentation that

00:41:19,180 --> 00:41:23,860
says the library does this and then

00:41:21,400 --> 00:41:26,590
realizing the library doesn't do that

00:41:23,860 --> 00:41:27,910
right I have thought that this is what I

00:41:26,590 --> 00:41:29,620
want the library to do and when I

00:41:27,910 --> 00:41:31,390
actually implement it didn't do that and

00:41:29,620 --> 00:41:33,100
then writing the documentation let me

00:41:31,390 --> 00:41:34,960
step outside myself and kind of realize

00:41:33,100 --> 00:41:36,670
that it's the same phenomenon as Adam if

00:41:34,960 --> 00:41:38,830
like people heard of you know explaining

00:41:36,670 --> 00:41:40,330
a bug to a teddy bear or whatever you

00:41:38,830 --> 00:41:42,160
know it's like you don't need another

00:41:40,330 --> 00:41:43,600
person to help you debug it sometimes

00:41:42,160 --> 00:41:44,890
you just need to step outside your

00:41:43,600 --> 00:41:45,970
normal frame of reference and then you

00:41:44,890 --> 00:41:47,800
see things from a different angle

00:41:45,970 --> 00:41:51,850
writing documentation does the same

00:41:47,800 --> 00:41:53,200
effect it's very very handy okay so you

00:41:51,850 --> 00:41:55,540
need to really anticipate future needs

00:41:53,200 --> 00:41:58,270
at the beginning of your library design

00:41:55,540 --> 00:42:00,210
process when it's things like thread

00:41:58,270 --> 00:42:02,290
safety that's very hard to bolt on later

00:42:00,210 --> 00:42:04,150
things like versioning are also very

00:42:02,290 --> 00:42:05,680
hard to believe there's there's a small

00:42:04,150 --> 00:42:06,970
set of things that are in this category

00:42:05,680 --> 00:42:09,640
of if we didn't think of it at the

00:42:06,970 --> 00:42:12,620
beginning we're kind of stuck but

00:42:09,640 --> 00:42:15,410
there's another important aspect is Amit

00:42:12,620 --> 00:42:17,660
teachers right so I used to work in a

00:42:15,410 --> 00:42:19,880
place where we we did visualization of

00:42:17,660 --> 00:42:21,560
sonar data and there was this one little

00:42:19,880 --> 00:42:23,060
widget that had like a bunch of bars of

00:42:21,560 --> 00:42:24,860
data and then went down the screen it

00:42:23,060 --> 00:42:27,290
was like an ear range too far age and

00:42:24,860 --> 00:42:30,380
then like direction around the circle

00:42:27,290 --> 00:42:34,190
and from you know right to left so in

00:42:30,380 --> 00:42:35,750
this view you know we're only rendering

00:42:34,190 --> 00:42:38,330
data in that way I describe this is near

00:42:35,750 --> 00:42:40,010
that's far it goes right to left the guy

00:42:38,330 --> 00:42:41,660
that rode it was like why there's no

00:42:40,010 --> 00:42:43,400
reason why it has to be right to left

00:42:41,660 --> 00:42:45,500
there's no reason why it has to be near

00:42:43,400 --> 00:42:47,390
and far on the bottom of top so he just

00:42:45,500 --> 00:42:49,400
rode all four ways and there were like

00:42:47,390 --> 00:42:50,930
six levels of inheritance and you know

00:42:49,400 --> 00:42:53,510
it was just a big mess and it got to be

00:42:50,930 --> 00:42:55,160
such complicated code that is something

00:42:53,510 --> 00:42:57,530
relatively simple that he himself could

00:42:55,160 --> 00:42:58,550
not fix bugs in it that we found and we

00:42:57,530 --> 00:43:00,410
couldn't extend and we end up throwing

00:42:58,550 --> 00:43:02,270
it away and we're doing it right and so

00:43:00,410 --> 00:43:04,190
there is such a thing as too much

00:43:02,270 --> 00:43:05,780
generality there is such a thing as too

00:43:04,190 --> 00:43:08,600
much generosity if the direct share

00:43:05,780 --> 00:43:10,250
going in is making it generic in a way

00:43:08,600 --> 00:43:12,050
that says I want more more features

00:43:10,250 --> 00:43:13,550
you're probably on the wrong track if

00:43:12,050 --> 00:43:15,530
it's generic in a way that says like

00:43:13,550 --> 00:43:16,730
this is the fundamental thing that it

00:43:15,530 --> 00:43:17,780
does and I want to make sure that

00:43:16,730 --> 00:43:19,340
everyone that does it was slightly

00:43:17,780 --> 00:43:22,030
different variation of that can do it

00:43:19,340 --> 00:43:24,890
then you're probably on the right track

00:43:22,030 --> 00:43:27,410
okay so header only verses compiled this

00:43:24,890 --> 00:43:28,940
comes up with some especially open

00:43:27,410 --> 00:43:30,590
source projects a lot of people say like

00:43:28,940 --> 00:43:31,730
it was not header only I'm never going

00:43:30,590 --> 00:43:33,080
to use it because there's too much

00:43:31,730 --> 00:43:34,580
trouble to figure out your weird build

00:43:33,080 --> 00:43:36,350
system and link to your library and what

00:43:34,580 --> 00:43:37,760
life's too short okay and then some

00:43:36,350 --> 00:43:39,440
people say I'm never gonna use your

00:43:37,760 --> 00:43:41,150
library if it's header only because I'm

00:43:39,440 --> 00:43:42,620
not gonna like we compile that every

00:43:41,150 --> 00:43:45,500
time because I've got this very tight

00:43:42,620 --> 00:43:48,170
loop I compile and debug and I and I in

00:43:45,500 --> 00:43:50,150
a code right so you can have both worlds

00:43:48,170 --> 00:43:51,470
if you use this this pattern that you'll

00:43:50,150 --> 00:43:52,730
just see this a lot of routes libraries

00:43:51,470 --> 00:43:55,700
if you want another example but

00:43:52,730 --> 00:43:57,290
essentially you've got your header it's

00:43:55,700 --> 00:43:59,300
got your interfaces in it and at the end

00:43:57,290 --> 00:44:00,680
of your header you say like if I've got

00:43:59,300 --> 00:44:03,230
this macro to find this as its header

00:44:00,680 --> 00:44:04,940
only then I'm going to include this IPP

00:44:03,230 --> 00:44:07,040
file okay that basically has all your

00:44:04,940 --> 00:44:08,570
implementation set and then you've got

00:44:07,040 --> 00:44:10,190
your food on CPP file which

00:44:08,570 --> 00:44:11,900
unfortunately I should have written like

00:44:10,190 --> 00:44:13,850
include food on H at the top of this

00:44:11,900 --> 00:44:15,590
that makes this make more sense but if

00:44:13,850 --> 00:44:17,630
it's not header only if you don't have

00:44:15,590 --> 00:44:19,450
that macro defined then you include the

00:44:17,630 --> 00:44:21,910
IPP file here and then you add

00:44:19,450 --> 00:44:23,470
the CPP file to your build okay and then

00:44:21,910 --> 00:44:25,089
the IPP file has the stuff you normally

00:44:23,470 --> 00:44:27,010
have a listing can be file except maybe

00:44:25,089 --> 00:44:29,799
the pound include of the food on th now

00:44:27,010 --> 00:44:31,599
you can do this with food CPP by itself

00:44:29,799 --> 00:44:33,849
you don't need the IPP file necessarily

00:44:31,599 --> 00:44:34,990
so you can include that at the bottom of

00:44:33,849 --> 00:44:36,640
your header file if you want but

00:44:34,990 --> 00:44:38,079
something like this is very easy to

00:44:36,640 --> 00:44:40,450
accomplish if you just start with it

00:44:38,079 --> 00:44:41,589
from the beginning it's no extra work we

00:44:40,450 --> 00:44:44,770
tried it later it can be difficult

00:44:41,589 --> 00:44:46,390
online things understand how inline

00:44:44,770 --> 00:44:47,619
namespaces work so inline namespaces

00:44:46,390 --> 00:44:49,869
there's lots of great tutorials online

00:44:47,619 --> 00:44:52,030
and I didn't really have the time to go

00:44:49,869 --> 00:44:53,650
over this in this talk but suffice it to

00:44:52,030 --> 00:44:55,359
say that in my name is basically to take

00:44:53,650 --> 00:44:58,180
like I can see that namespace foo and

00:44:55,359 --> 00:45:01,119
you've got v1 v2 v3 all these different

00:44:58,180 --> 00:45:03,309
versions of your of your library and so

00:45:01,119 --> 00:45:05,859
you just say like this one is the latest

00:45:03,309 --> 00:45:08,290
one and then everyone just says using

00:45:05,859 --> 00:45:09,700
you know everyone says food colon colon

00:45:08,290 --> 00:45:13,180
whatever and they get the latest version

00:45:09,700 --> 00:45:16,000
of that API entry point but then you can

00:45:13,180 --> 00:45:17,500
also have the older versions side by

00:45:16,000 --> 00:45:19,210
side with the newer versions in a very

00:45:17,500 --> 00:45:21,010
nice way they don't conflict because

00:45:19,210 --> 00:45:22,869
they're in different namespaces but as

00:45:21,010 --> 00:45:24,819
you migrate different versions you

00:45:22,869 --> 00:45:26,260
always have one version that is

00:45:24,819 --> 00:45:29,710
considered to be the latest one that

00:45:26,260 --> 00:45:31,180
just uses food : all right so like I

00:45:29,710 --> 00:45:32,799
said I'm not gonna get into too much

00:45:31,180 --> 00:45:34,270
there's lots of great stuff online how

00:45:32,799 --> 00:45:36,670
to use it it makes it very easy to

00:45:34,270 --> 00:45:38,829
version your library and migrate once

00:45:36,670 --> 00:45:39,790
you change versions or for client click

00:45:38,829 --> 00:45:45,160
my grades version

00:45:39,790 --> 00:45:48,790
ok so generic code all templates have an

00:45:45,160 --> 00:45:51,339
implicit concept requirement even if

00:45:48,790 --> 00:45:52,450
it's implicit so let's take a look at

00:45:51,339 --> 00:45:54,579
this let's say you look in the

00:45:52,450 --> 00:45:56,890
documentation you just see like the name

00:45:54,579 --> 00:45:58,599
of this function and it doesn't have any

00:45:56,890 --> 00:46:01,930
comments it's just this function and

00:45:58,599 --> 00:46:06,160
some oxygen comments or something so it

00:46:01,930 --> 00:46:09,339
takes an A and a B by value that bolides

00:46:06,160 --> 00:46:12,490
the fact that a + b is used inside of it

00:46:09,339 --> 00:46:13,690
ok and so I can't pass just any little

00:46:12,490 --> 00:46:18,430
thing in there I need two things that I

00:46:13,690 --> 00:46:20,820
can add ok so there is a requirement on

00:46:18,430 --> 00:46:24,060
virtually any template you write but the

00:46:20,820 --> 00:46:26,280
template argument T or whatever argument

00:46:24,060 --> 00:46:29,480
has requirements on it for what types or

00:46:26,280 --> 00:46:32,520
will fit in that and that that template

00:46:29,480 --> 00:46:34,860
parameter if you don't document them

00:46:32,520 --> 00:46:37,560
then you're making your code like

00:46:34,860 --> 00:46:38,700
impossible to use in some cases and very

00:46:37,560 --> 00:46:40,890
hard to unwind these kinds of things

00:46:38,700 --> 00:46:42,270
sometimes if you have the concepts

00:46:40,890 --> 00:46:44,850
feature to use it all over the place

00:46:42,270 --> 00:46:46,620
right in this case this is probably

00:46:44,850 --> 00:46:48,450
going to be a concept that comes with a

00:46:46,620 --> 00:46:50,430
standard library a library arithmetic

00:46:48,450 --> 00:46:52,560
and if you just put arithmetic T on your

00:46:50,430 --> 00:46:54,090
sum function then you know all as well

00:46:52,560 --> 00:46:55,260
people are gonna know what that is in a

00:46:54,090 --> 00:46:58,080
few years but this is a common feature

00:46:55,260 --> 00:47:00,960
until then document these things right

00:46:58,080 --> 00:47:03,390
if you have a public function in your

00:47:00,960 --> 00:47:04,530
library API that people were expecting

00:47:03,390 --> 00:47:06,360
to use they need to know what the

00:47:04,530 --> 00:47:10,340
requirements are for T of U and all the

00:47:06,360 --> 00:47:14,610
other types of grammars you alright so

00:47:10,340 --> 00:47:16,890
to boil this down we're writing

00:47:14,610 --> 00:47:18,120
libraries for code reuse that's it

00:47:16,890 --> 00:47:20,460
that's the beginning in the end of why

00:47:18,120 --> 00:47:22,620
we do this ok and because of that we

00:47:20,460 --> 00:47:26,550
need them to be maximally efficient and

00:47:22,620 --> 00:47:28,320
we need to be maximally reusable in

00:47:26,550 --> 00:47:29,550
practice what this means these are the

00:47:28,320 --> 00:47:31,230
guidelines that went over the second

00:47:29,550 --> 00:47:32,640
half of the talk that means you need to

00:47:31,230 --> 00:47:34,680
make your library if you got a easy to

00:47:32,640 --> 00:47:37,380
reason about to get the usability part

00:47:34,680 --> 00:47:38,940
and that means that you need to name

00:47:37,380 --> 00:47:41,910
things in a way that is obvious what the

00:47:38,940 --> 00:47:44,820
names do you need to make sure that the

00:47:41,910 --> 00:47:46,560
the the functions don't do anything

00:47:44,820 --> 00:47:47,790
extremely surprising in addition to

00:47:46,560 --> 00:47:50,160
doing what the names say they do they

00:47:47,790 --> 00:47:51,750
don't have any crazy side effects you

00:47:50,160 --> 00:47:53,250
need to make the interfaces impossible

00:47:51,750 --> 00:47:54,900
to use incorrectly wherever that's

00:47:53,250 --> 00:47:56,280
possible it's not always possible but at

00:47:54,900 --> 00:47:59,550
least make the part using correctly

00:47:56,280 --> 00:48:01,500
avoid aliasing type should be regular

00:47:59,550 --> 00:48:03,540
function should be pure and type should

00:48:01,500 --> 00:48:05,150
define a basis and nothing else all

00:48:03,540 --> 00:48:08,010
other things should be free functions

00:48:05,150 --> 00:48:09,960
all right also container types should be

00:48:08,010 --> 00:48:14,610
interoperable in this dialog rhythms and

00:48:09,960 --> 00:48:16,170
use one for range for loops and types we

00:48:14,610 --> 00:48:18,480
should be usable and a container of sub

00:48:16,170 --> 00:48:19,890
object that someone else writes your

00:48:18,480 --> 00:48:21,450
type should be constructible anywhere

00:48:19,890 --> 00:48:23,460
don't forget about making things Rama

00:48:21,450 --> 00:48:26,100
beware possible or concepts for possible

00:48:23,460 --> 00:48:27,360
and error messages can't impede the

00:48:26,100 --> 00:48:29,730
easier library you've got a library

00:48:27,360 --> 00:48:30,320
nobody can use and finally don't stick

00:48:29,730 --> 00:48:32,780
to everyone

00:48:30,320 --> 00:48:34,670
these guidelines all the time right like

00:48:32,780 --> 00:48:36,020
so the thing I keep saying is that you

00:48:34,670 --> 00:48:37,670
want to strive for every one of these

00:48:36,020 --> 00:48:39,530
bullet points every time you're making a

00:48:37,670 --> 00:48:41,150
decision you're like am i compromising

00:48:39,530 --> 00:48:43,040
on any one of these and if the answer is

00:48:41,150 --> 00:48:45,230
yes why am i doing that if that's not a

00:48:43,040 --> 00:48:46,130
compelling reason don't do it okay

00:48:45,230 --> 00:48:48,130
that doesn't mean there aren't

00:48:46,130 --> 00:49:01,100
compelling reasons do it in those cases

00:48:48,130 --> 00:49:03,710
all right questions so do you have any

00:49:01,100 --> 00:49:05,900
suggestion on how to design the folder

00:49:03,710 --> 00:49:07,870
structure for an optional a header only

00:49:05,900 --> 00:49:09,950
library because when I actually

00:49:07,870 --> 00:49:12,680
implement this on libraries that were

00:49:09,950 --> 00:49:15,110
optionally eternally it was pretty

00:49:12,680 --> 00:49:17,270
annoying to have the global including

00:49:15,110 --> 00:49:19,850
source folders as you had to use

00:49:17,270 --> 00:49:21,800
absolute include paths to include the

00:49:19,850 --> 00:49:23,960
CBP file in the header file whatever

00:49:21,800 --> 00:49:27,170
know she had the header only macro and

00:49:23,960 --> 00:49:29,510
the something I used was actually at

00:49:27,170 --> 00:49:32,180
having like a folder for every module of

00:49:29,510 --> 00:49:34,100
the library and that local includin

00:49:32,180 --> 00:49:36,440
source folder inside the module folder

00:49:34,100 --> 00:49:38,930
if that makes sense so we have any

00:49:36,440 --> 00:49:41,150
recommendation how now to design a nice

00:49:38,930 --> 00:49:42,890
folder structure I really don't I mean a

00:49:41,150 --> 00:49:45,530
lot of people really swear by having a

00:49:42,890 --> 00:49:47,810
source breakdown where the occlude has

00:49:45,530 --> 00:49:49,220
like the whole tree a lot of people

00:49:47,810 --> 00:49:50,990
swear by like you said a module

00:49:49,220 --> 00:49:52,450
breakdown we've got a clinton source to

00:49:50,990 --> 00:49:55,370
me is six of one half a dozen of another

00:49:52,450 --> 00:49:58,100
as long as it builds i really do care

00:49:55,370 --> 00:50:00,110
about the layout that lunch whatever the

00:49:58,100 --> 00:50:01,280
whatever the layout is all get used to

00:50:00,110 --> 00:50:19,940
it i think most people are like that too

00:50:01,280 --> 00:50:21,680
so yeah I mean concrete so the question

00:50:19,940 --> 00:50:25,070
was how do you migrate to new standards

00:50:21,680 --> 00:50:29,090
in C++ essentially when you've got how

00:50:25,070 --> 00:50:32,150
long how long do you wait that's that's

00:50:29,090 --> 00:50:34,270
a big question I mean essentially you

00:50:32,150 --> 00:50:37,220
know where most places work you've got

00:50:34,270 --> 00:50:39,020
GCC playing and and Visual Studio if you

00:50:37,220 --> 00:50:40,010
do really lots of clock crossbow flower

00:50:39,020 --> 00:50:42,140
stuff and you need to make sure they're

00:50:40,010 --> 00:50:43,339
all three using whatever future

00:50:42,140 --> 00:50:44,569
you want to pick and of course

00:50:43,339 --> 00:50:46,460
downstream clients have to be able do

00:50:44,569 --> 00:50:48,950
that too so I don't think there's ever a

00:50:46,460 --> 00:50:50,869
particularly good or bad time to migrate

00:50:48,950 --> 00:50:52,309
as long you're dashing clients or able

00:50:50,869 --> 00:50:54,410
to comply all use that code then that's

00:50:52,309 --> 00:50:57,220
the time to do it as for using specific

00:50:54,410 --> 00:50:59,420
language features I think that you know

00:50:57,220 --> 00:51:00,589
the nice thing about simplest is eleven

00:50:59,420 --> 00:51:02,809
is the vast majority of language

00:51:00,589 --> 00:51:04,220
features that are new are also things

00:51:02,809 --> 00:51:05,510
that are you know they're just pure

00:51:04,220 --> 00:51:07,069
extensions so if you want to start using

00:51:05,510 --> 00:51:08,930
them in some places to model others

00:51:07,069 --> 00:51:35,059
that's totally fine then you can just

00:51:08,930 --> 00:51:36,619
you know stuff as you go right so the

00:51:35,059 --> 00:51:38,960
question was instead of documenting

00:51:36,619 --> 00:51:40,940
requirements for template parameters

00:51:38,960 --> 00:51:44,299
that constraints on them instead user

00:51:40,940 --> 00:51:45,799
named Olaf and so that this sorta

00:51:44,299 --> 00:51:47,930
schools have thought of this like one is

00:51:45,799 --> 00:51:49,640
using able live and that's great because

00:51:47,930 --> 00:51:51,019
it pulls things out of the overload said

00:51:49,640 --> 00:51:53,769
and that's one way the muse you can

00:51:51,019 --> 00:51:56,059
detect it they've chosen the wrong

00:51:53,769 --> 00:51:57,650
instantiation of this template the

00:51:56,059 --> 00:51:58,880
downside of that is it's completely

00:51:57,650 --> 00:52:02,119
removed that something else might get

00:51:58,880 --> 00:52:03,559
picked up if you've got a static assert

00:52:02,119 --> 00:52:05,029
that's the other way of doing it which

00:52:03,559 --> 00:52:06,200
is that we're gonna let them try to use

00:52:05,029 --> 00:52:09,440
that well we could tell you why it's

00:52:06,200 --> 00:52:11,119
wrong with a static assert it completely

00:52:09,440 --> 00:52:12,680
depends on like like I said you know I

00:52:11,119 --> 00:52:13,849
had this convention before where I had

00:52:12,680 --> 00:52:15,109
certain things that would catch with a

00:52:13,849 --> 00:52:17,269
static assert certain things I would

00:52:15,109 --> 00:52:20,480
catch with scene a certain things I

00:52:17,269 --> 00:52:21,680
wouldn't and it just depends on on how

00:52:20,480 --> 00:52:22,730
you're breaking things down the

00:52:21,680 --> 00:52:25,009
important part is you come up with a

00:52:22,730 --> 00:52:26,960
good convention that is consistent and

00:52:25,009 --> 00:52:28,250
it generates this kind of error for this

00:52:26,960 --> 00:52:29,930
kind of thing and that kind of error for

00:52:28,250 --> 00:52:32,539
that kind of thing and when a user sees

00:52:29,930 --> 00:52:33,950
an error they know immediately where to

00:52:32,539 --> 00:52:37,789
start looking for what kind of error it

00:52:33,950 --> 00:52:39,829
is so that is a great thing to do but

00:52:37,789 --> 00:52:42,160
it's not it's not necessarily the the

00:52:39,829 --> 00:52:42,160
only right answer

00:52:44,119 --> 00:52:48,430
do you have competitive reasons why I

00:52:46,880 --> 00:52:53,210
should

00:52:48,430 --> 00:52:56,660
but struck many I agree to behead oh no

00:52:53,210 --> 00:52:58,130
no I don't but there are I've seen

00:52:56,660 --> 00:53:00,619
people over and over and over

00:52:58,130 --> 00:53:02,630
say on line when talking about a

00:53:00,619 --> 00:53:04,009
particular boost library or another

00:53:02,630 --> 00:53:05,569
library that they're going to use and

00:53:04,009 --> 00:53:07,309
I'm going to use I'm never going to use

00:53:05,569 --> 00:53:10,039
that cuz its header only I will only use

00:53:07,309 --> 00:53:12,259
that up this header only it's just user

00:53:10,039 --> 00:53:14,329
taste so if you have lots of users that

00:53:12,259 --> 00:53:17,509
care about this make it possible for

00:53:14,329 --> 00:53:19,009
those users that care about that care

00:53:17,509 --> 00:53:20,539
about header all need to get header only

00:53:19,009 --> 00:53:23,180
those you should care about compile only

00:53:20,539 --> 00:53:24,259
to get compile that's my site I don't

00:53:23,180 --> 00:53:26,180
have a particularly compelling reason

00:53:24,259 --> 00:53:27,739
for either one I I personally don't care

00:53:26,180 --> 00:53:37,069
but lots of pillars are very strong

00:53:27,739 --> 00:53:38,720
about what me to do taking the library

00:53:37,069 --> 00:53:40,369
then maybe is not in a good state

00:53:38,720 --> 00:53:44,450
currently and getting it into a good

00:53:40,369 --> 00:53:47,299
state if you have a lot of colors a lot

00:53:44,450 --> 00:53:51,440
of or consuming it beretti

00:53:47,299 --> 00:53:53,390
oh no you're kind of stuck that's that's

00:53:51,440 --> 00:53:55,999
that's the that's sort of a big problem

00:53:53,390 --> 00:53:57,319
so another one of the things when I said

00:53:55,999 --> 00:53:59,630
before you note that thing about thread

00:53:57,319 --> 00:54:01,009
safe do you think about versioning the

00:53:59,630 --> 00:54:03,019
big part about versioning is thinking

00:54:01,009 --> 00:54:04,640
about like okay we've got this API entry

00:54:03,019 --> 00:54:06,680
point once we publish this and

00:54:04,640 --> 00:54:08,239
downstream users are using it we are

00:54:06,680 --> 00:54:09,739
very much locked into that we can give

00:54:08,239 --> 00:54:10,940
them an alternate API but a lot of it we

00:54:09,739 --> 00:54:12,739
can say like we're not going to rewrite

00:54:10,940 --> 00:54:15,339
our all our code for this like an

00:54:12,739 --> 00:54:20,779
incremental gain that's rather small so

00:54:15,339 --> 00:54:22,759
my advice for you is make make api's

00:54:20,779 --> 00:54:24,589
that were ever possible or completely

00:54:22,759 --> 00:54:26,210
extensible so if that means you do

00:54:24,589 --> 00:54:28,779
something that's pessimal like you pass

00:54:26,210 --> 00:54:31,369
and destruct that you can add numbers to

00:54:28,779 --> 00:54:32,900
or you pass on a handle to something

00:54:31,369 --> 00:54:35,690
that has the configuration if there's

00:54:32,900 --> 00:54:38,059
some fundamental entry point in your in

00:54:35,690 --> 00:54:40,369
your api that that cannot change once

00:54:38,059 --> 00:54:41,749
you publish it and then anyone and any

00:54:40,369 --> 00:54:43,519
further features that need to happen

00:54:41,749 --> 00:54:44,749
need to go fit within that you might

00:54:43,519 --> 00:54:46,519
have to do something like that like i

00:54:44,749 --> 00:54:48,200
said passing in a handle to a

00:54:46,519 --> 00:54:49,819
configuration object to passing this

00:54:48,200 --> 00:54:51,589
drug these are pessimists like there's a

00:54:49,819 --> 00:54:53,630
well-known things not to do to make

00:54:51,589 --> 00:54:55,999
optimal code but for purposes of making

00:54:53,630 --> 00:54:58,299
things general purpose and making them

00:54:55,999 --> 00:54:58,299
extents

00:54:59,740 --> 00:55:06,109
yes to the question of why header only

00:55:03,529 --> 00:55:08,809
at least in our case our build

00:55:06,109 --> 00:55:12,079
environment is such a the way we use

00:55:08,809 --> 00:55:15,380
link time optimization and whole program

00:55:12,079 --> 00:55:17,569
optimizations relies on us being

00:55:15,380 --> 00:55:20,029
completely header only now there's other

00:55:17,569 --> 00:55:21,920
ways of setting up the builds and so

00:55:20,029 --> 00:55:33,440
forth to get different optimizations but

00:55:21,920 --> 00:55:37,940
that's our reason where some good

00:55:33,440 --> 00:55:39,829
libraries to look at um so one of my

00:55:37,940 --> 00:55:41,720
favorite libraries in terms of linear

00:55:39,829 --> 00:55:43,990
algebra is eigen because it does lots of

00:55:41,720 --> 00:55:46,099
very nice stuff so it essentially takes

00:55:43,990 --> 00:55:50,359
stuff like how I'm showing you before

00:55:46,099 --> 00:55:51,619
like you know the x times a times X plus

00:55:50,359 --> 00:55:53,569
y it takes something like that

00:55:51,619 --> 00:55:55,220
transforms into something like Saxby and

00:55:53,569 --> 00:55:57,950
then it also takes the extra step of

00:55:55,220 --> 00:55:59,660
saying if I know that I can that I can

00:55:57,950 --> 00:56:01,880
generate vector code for this something

00:55:59,660 --> 00:56:05,990
to that instead so it takes stuff from a

00:56:01,880 --> 00:56:07,789
very simple to use interface that looks

00:56:05,990 --> 00:56:09,410
very easy and doesn't much of insane

00:56:07,789 --> 00:56:13,039
gymnastics and produces the right stuff

00:56:09,410 --> 00:56:15,259
right and other libraries like if you

00:56:13,039 --> 00:56:16,579
look at most of the boost libraries or

00:56:15,259 --> 00:56:18,470
very very high quality

00:56:16,579 --> 00:56:21,200
some of them do really interesting

00:56:18,470 --> 00:56:24,980
things with meta program and they're

00:56:21,200 --> 00:56:26,119
just fun to look at but like I don't

00:56:24,980 --> 00:56:27,680
know that you're necessarily going to

00:56:26,119 --> 00:56:29,599
try to do the same thing in your own

00:56:27,680 --> 00:56:31,579
code especially if you're using symbols

00:56:29,599 --> 00:56:33,410
or 11 or 14 you don't have to do a lot

00:56:31,579 --> 00:56:34,490
of those things anymore especially a 14

00:56:33,410 --> 00:56:35,630
you basically don't have to do meta

00:56:34,490 --> 00:56:38,630
programming and I understand the case

00:56:35,630 --> 00:56:39,740
we're used to but yeah looking at the

00:56:38,630 --> 00:56:42,109
boost libraries I mean the first time I

00:56:39,740 --> 00:56:43,579
read Boustany I was like why it doesn't

00:56:42,109 --> 00:56:45,019
everybody do this why didn't I think of

00:56:43,579 --> 00:56:46,579
this myself it seems like impossible

00:56:45,019 --> 00:56:47,839
that any should exist and then the

00:56:46,579 --> 00:56:50,259
implementation is very simple that's

00:56:47,839 --> 00:56:54,799
that's a great sort of aha moment so

00:56:50,259 --> 00:56:57,279
anyone else all right I think it's it

00:56:54,799 --> 00:56:57,279

YouTube URL: https://www.youtube.com/watch?v=hcHUZE6buzE


