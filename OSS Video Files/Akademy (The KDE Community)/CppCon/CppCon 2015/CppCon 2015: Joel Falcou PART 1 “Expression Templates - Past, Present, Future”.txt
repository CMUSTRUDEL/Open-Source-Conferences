Title: CppCon 2015: Joel Falcou PART 1 “Expression Templates - Past, Present, Future”
Publication date: 2015-10-07
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Expression Templates is one of this C++ idiom people learn to either love or hate. The main issues with ET is that everubody has its own conception about what they are, when they should be used, what benefits they give and what are their trade off. For a long time, Expression Tempaltes has been seen has a way to improve temporary heavy code. If the seminal implementation of ET by Todd Veldhuizen was actually about this, the landscape has changed since C++11 and C++14.

This workshop will go over : - what are exactly Expression Templates and what kind of use case they can solve elegantly and efficiently - what are the benefits that one may reap by using expression tempalte in its library - what are the real cost of expressont empaltes both at runtime and compile-time - which tools to use to not reinvent the tempalte wheel everytime including an introduction to Boost.PROTO an Boost.HANA.

The main objective is to clarify why, even in C++1*, this idiom has a meaningful set of applications and how to navigate around its pitfalls.
— 
Joel Falcou is an assistant professor at the University Paris-Sud and researcher at the Laboratoire de Recherche d’Informatique in Orsay, France. His research focuses on studying generative programming idioms and techniques to design tools for parallel software development. The two main parts of those works are: exploration of Embedded Domain Specific Language design for parallel computing on various architectures and the definition of a formal framework for reasoning about meta-programs and prove their compile-time correctness. Applications range from real-time image processing on embedded architectures to High Performance Computing on multi-core clusters. He is a NumScale SAS scientific advisor. NumScale mission is to assist businesses in the exploration and subsequently the mastery of high-performance computing systems.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,170 --> 00:00:07,740
okay so thanks to all of you let me

00:00:05,130 --> 00:00:10,380
introduce myself so I'm I'm Topher ku

00:00:07,740 --> 00:00:16,199
I'm a NASA set professor from University

00:00:10,380 --> 00:00:17,400
of Paris and also CTO of Nam scale which

00:00:16,199 --> 00:00:19,920
is a company that deal with

00:00:17,400 --> 00:00:23,039
high-performance computing and I will

00:00:19,920 --> 00:00:26,820
speak for quite a long time about a

00:00:23,039 --> 00:00:29,330
subject that is probably the most most

00:00:26,820 --> 00:00:32,430
most obscure and most you know

00:00:29,330 --> 00:00:34,649
intriguing concepts in in C++ which is

00:00:32,430 --> 00:00:37,770
expression templates so the original

00:00:34,649 --> 00:00:40,770
talk title was extraction template who

00:00:37,770 --> 00:00:43,350
when what where how but I decided that

00:00:40,770 --> 00:00:46,770
speaking for five hours was too long so

00:00:43,350 --> 00:00:48,600
I just shorted it to three so it's more

00:00:46,770 --> 00:00:51,390
like past present future is more for

00:00:48,600 --> 00:00:53,879
some definition of past and present so

00:00:51,390 --> 00:00:58,020
what will we be doing in this ongoing

00:00:53,879 --> 00:00:59,460
sessions is try to actually grasp what

00:00:58,020 --> 00:01:02,129
our expression templates both

00:00:59,460 --> 00:01:05,489
technically how it should be written and

00:01:02,129 --> 00:01:07,680
all it works and why you should care or

00:01:05,489 --> 00:01:11,400
not because sometimes you just don't

00:01:07,680 --> 00:01:13,170
need them okay and as all tools is also

00:01:11,400 --> 00:01:18,360
important to know when you you should

00:01:13,170 --> 00:01:20,400
not using it okay so the presentation

00:01:18,360 --> 00:01:22,560
workshop tutorial is basically split

00:01:20,400 --> 00:01:25,920
into three sessions the first session

00:01:22,560 --> 00:01:28,229
will be very introductive starting from

00:01:25,920 --> 00:01:30,420
from the ground up writing everything by

00:01:28,229 --> 00:01:33,630
hand see where the problem are what's

00:01:30,420 --> 00:01:36,509
the main concepts and where the worst

00:01:33,630 --> 00:01:38,430
difficulty starts to pop up and then on

00:01:36,509 --> 00:01:40,920
the second session we speak about some

00:01:38,430 --> 00:01:43,079
tools which already there for

00:01:40,920 --> 00:01:46,530
simplifying that mostly Bruce Prado

00:01:43,079 --> 00:01:49,890
I try to get as much as I can of out of

00:01:46,530 --> 00:01:51,869
boost proto introduction in one hour if

00:01:49,890 --> 00:01:52,590
you really really want to dig into more

00:01:51,869 --> 00:01:54,869
details

00:01:52,590 --> 00:01:57,540
I have another presentation on exactly

00:01:54,869 --> 00:02:02,070
this for a bit longer times it which

00:01:57,540 --> 00:02:04,290
available on on the CPP now web video

00:02:02,070 --> 00:02:08,489
websites and the third part will be

00:02:04,290 --> 00:02:11,790
about how can the new way of actually

00:02:08,489 --> 00:02:15,150
programming using C++ 14 and beyond

00:02:11,790 --> 00:02:17,969
actually simplifies a simplified version

00:02:15,150 --> 00:02:21,810
of exception templates and how we can

00:02:17,969 --> 00:02:24,120
use a new cardigan of sequences 14 to

00:02:21,810 --> 00:02:27,780
actually solve the remaining issues that

00:02:24,120 --> 00:02:29,970
we will go over so it was advertised as

00:02:27,780 --> 00:02:33,150
a workshop but as a setup is not really

00:02:29,970 --> 00:02:35,280
very cool for typing code for a long

00:02:33,150 --> 00:02:36,959
time so what we do is we will have a

00:02:35,280 --> 00:02:39,870
bunch of slides when I try to explain

00:02:36,959 --> 00:02:42,000
stuff and more interactive session where

00:02:39,870 --> 00:02:44,340
I would be probably writing code live

00:02:42,000 --> 00:02:46,980
and asking you questions and see how all

00:02:44,340 --> 00:02:50,069
we should be doing things everything is

00:02:46,980 --> 00:02:52,919
available on on github ok and you know

00:02:50,069 --> 00:02:56,430
if it's zoom enough okay so you got the

00:02:52,919 --> 00:03:03,750
slides and all the example codes that

00:02:56,430 --> 00:03:05,879
you will be seeing now it may be change

00:03:03,750 --> 00:03:08,819
a bit afterwards but also matter yours

00:03:05,879 --> 00:03:11,010
there so you can just prune the clones a

00:03:08,819 --> 00:03:15,180
bleep or get downloads of files and

00:03:11,010 --> 00:03:17,190
everything is inside I will also use my

00:03:15,180 --> 00:03:18,959
taxes during the online compiler so we

00:03:17,190 --> 00:03:21,299
can actually get the example running ok

00:03:18,959 --> 00:03:23,069
so first things first let's make a small

00:03:21,299 --> 00:03:26,069
poll all we need people out there

00:03:23,069 --> 00:03:31,500
actually know what expression template

00:03:26,069 --> 00:03:35,239
is about okay not bad and if you know

00:03:31,500 --> 00:03:35,239
what is about how many of you survived

00:03:35,900 --> 00:03:41,970
okay well well that's that's that's a

00:03:40,470 --> 00:03:43,919
classical joke we get about exception

00:03:41,970 --> 00:03:45,510
templates it's it's so complicated you

00:03:43,919 --> 00:03:48,810
basically brain your brain your brain

00:03:45,510 --> 00:03:51,239
out but we try to demystify that so what

00:03:48,810 --> 00:03:54,030
is expression template what was ago so

00:03:51,239 --> 00:03:56,040
for a long time designing libraries in

00:03:54,030 --> 00:03:58,979
C++ was all about getting a correct

00:03:56,040 --> 00:04:01,109
model probably a correct object oriented

00:03:58,979 --> 00:04:03,959
model if you were into this and try to

00:04:01,109 --> 00:04:08,069
make the library API fit this model and

00:04:03,959 --> 00:04:11,579
fit into the actual let's say historical

00:04:08,069 --> 00:04:13,439
C++ language syntax and after why what

00:04:11,579 --> 00:04:16,680
we found out is that it's quite limiting

00:04:13,439 --> 00:04:19,349
and we borrowed the page to other

00:04:16,680 --> 00:04:22,380
languages and we go over that and now

00:04:19,349 --> 00:04:24,960
one of the training stuff is writing

00:04:22,380 --> 00:04:25,710
library as if it was providing your

00:04:24,960 --> 00:04:28,650
service

00:04:25,710 --> 00:04:31,260
as another language and by designing a

00:04:28,650 --> 00:04:33,330
library as a language with all it means

00:04:31,260 --> 00:04:36,870
when we see that we can actually extract

00:04:33,330 --> 00:04:38,880
more optimization opportunities and the

00:04:36,870 --> 00:04:42,180
your code will become more clear for the

00:04:38,880 --> 00:04:44,190
end users because we just have to write

00:04:42,180 --> 00:04:46,410
whatever they want to be doing instead

00:04:44,190 --> 00:04:48,690
of writing what they should be doing to

00:04:46,410 --> 00:04:51,960
get the effects I want so we end up with

00:04:48,690 --> 00:04:57,060
code like this okay so that's something

00:04:51,960 --> 00:04:59,610
I picked up from chaos here Gita which

00:04:57,060 --> 00:05:02,640
is a representation of LLVM carried no

00:04:59,610 --> 00:05:04,290
scope using boo spirit so boo spirit is

00:05:02,640 --> 00:05:07,110
a library which is in boost that

00:05:04,290 --> 00:05:10,590
provides a way to define passers and

00:05:07,110 --> 00:05:11,970
context generators and the main asset of

00:05:10,590 --> 00:05:14,670
this library is that you can actually

00:05:11,970 --> 00:05:17,610
write something that just happened to

00:05:14,670 --> 00:05:20,210
look like you just copy-paste it a piece

00:05:17,610 --> 00:05:23,640
of grammar okay over there

00:05:20,210 --> 00:05:25,830
directly into your CPS postcode okay so

00:05:23,640 --> 00:05:27,180
you just write what you want to be doing

00:05:25,830 --> 00:05:29,970
you want you write what you want to

00:05:27,180 --> 00:05:32,190
achieve and the library itself we turn

00:05:29,970 --> 00:05:36,900
in your description of the problem into

00:05:32,190 --> 00:05:39,090
the actual optimize and strictly minimal

00:05:36,900 --> 00:05:42,419
code to do this so it looks like

00:05:39,090 --> 00:05:44,430
everything but C++ okay is only stuff

00:05:42,419 --> 00:05:47,280
that look like C++ it's basic easy

00:05:44,430 --> 00:05:48,360
operators and how the code is set up but

00:05:47,280 --> 00:05:52,350
if you look at this part between

00:05:48,360 --> 00:05:54,930
identifiers and program well it doesn't

00:05:52,350 --> 00:05:57,780
look like we do C++ and so the deal is

00:05:54,930 --> 00:06:01,590
by having a way to share the language

00:05:57,780 --> 00:06:05,460
the way we want this wave for spirit how

00:06:01,590 --> 00:06:07,620
many of you have heard of eigen yeah so

00:06:05,460 --> 00:06:10,230
I can use the same techniques okay

00:06:07,620 --> 00:06:12,900
we have a parent program in every called

00:06:10,230 --> 00:06:15,300
busine D which is the same stuff you

00:06:12,900 --> 00:06:18,930
have boost MSM that use same kind of

00:06:15,300 --> 00:06:20,340
mechanics to help you write a state

00:06:18,930 --> 00:06:23,010
machine directly he has you will be

00:06:20,340 --> 00:06:23,550
writing in the UNR document and so on

00:06:23,010 --> 00:06:27,080
and so on

00:06:23,550 --> 00:06:30,210
so you we push into those libraries

00:06:27,080 --> 00:06:32,310
don't specific information and the

00:06:30,210 --> 00:06:35,460
library use this to get whatever they

00:06:32,310 --> 00:06:37,560
need to choose what kind of course it

00:06:35,460 --> 00:06:39,030
should be generating and so the question

00:06:37,560 --> 00:06:42,270
is up does it works

00:06:39,030 --> 00:06:47,070
so the main issues is to look at this on

00:06:42,270 --> 00:06:48,690
a different angle so actually if you

00:06:47,070 --> 00:06:50,640
look at what was going on expression

00:06:48,690 --> 00:06:52,950
templates is actually pretty old main

00:06:50,640 --> 00:06:55,170
idea is to say I want to write code that

00:06:52,950 --> 00:06:57,570
looked at something else captures the

00:06:55,170 --> 00:07:00,150
meaning of what is being writen doesn't

00:06:57,570 --> 00:07:02,610
do any computation and ship some kind of

00:07:00,150 --> 00:07:04,410
complex temporary object somewhere else

00:07:02,610 --> 00:07:07,320
and the summarize we take care about

00:07:04,410 --> 00:07:11,280
looking at your pictures and decide what

00:07:07,320 --> 00:07:15,060
to do and the problem is up to recently

00:07:11,280 --> 00:07:17,430
and still now the language itself was

00:07:15,060 --> 00:07:19,650
not very keen to help us writing this in

00:07:17,430 --> 00:07:21,240
a comprehensible manner so efficient

00:07:19,650 --> 00:07:24,480
templates as a techniques as an

00:07:21,240 --> 00:07:26,669
implementation techniques as being not

00:07:24,480 --> 00:07:29,120
very something that people accept as no

00:07:26,669 --> 00:07:31,710
more okay it's support is very flaky

00:07:29,120 --> 00:07:33,600
some people actually are about the fact

00:07:31,710 --> 00:07:35,160
that that we should not be doing this

00:07:33,600 --> 00:07:38,280
and that's the job of the compilers or

00:07:35,160 --> 00:07:41,010
so no thought and now with the advent of

00:07:38,280 --> 00:07:45,540
MOOC semantics and our value references

00:07:41,010 --> 00:07:47,160
copier regions so many issues but we

00:07:45,540 --> 00:07:49,669
should be using expression templates to

00:07:47,160 --> 00:07:53,070
do those meaningful expression

00:07:49,669 --> 00:07:56,070
construction for performance wisdom is

00:07:53,070 --> 00:07:58,590
actually put in question because if you

00:07:56,070 --> 00:07:59,400
have all this core language support why

00:07:58,590 --> 00:08:02,400
do we need this

00:07:59,400 --> 00:08:04,950
so the idea of this is to actually see

00:08:02,400 --> 00:08:10,080
what we can do with that and try to find

00:08:04,950 --> 00:08:11,729
a way to make it work properly so why

00:08:10,080 --> 00:08:14,360
using a vision template so you have

00:08:11,729 --> 00:08:18,120
different reason to do that

00:08:14,360 --> 00:08:20,220
answer a performances okay one of the

00:08:18,120 --> 00:08:22,260
selling point of expression template we

00:08:20,220 --> 00:08:25,260
will see that just after that I develop

00:08:22,260 --> 00:08:27,780
solve old emails from the 90s was to

00:08:25,260 --> 00:08:29,940
prevent creation of temporary array

00:08:27,780 --> 00:08:32,940
object on the stack while composing

00:08:29,940 --> 00:08:35,039
large algebraic flag expressions so by

00:08:32,940 --> 00:08:37,890
removing the need of temporaries we were

00:08:35,039 --> 00:08:40,979
making less memory allocation and the

00:08:37,890 --> 00:08:43,169
code was more tight so answer B for code

00:08:40,979 --> 00:08:44,490
clarity because writing what you want to

00:08:43,169 --> 00:08:47,940
do instead of what you should be doing

00:08:44,490 --> 00:08:49,570
is easier for the writer first and for

00:08:47,940 --> 00:08:51,940
the reader afterwards

00:08:49,570 --> 00:08:54,760
and see just for bragging rights because

00:08:51,940 --> 00:08:56,800
man that's one fine piece of C++ : just

00:08:54,760 --> 00:08:59,920
wrote and I'm pretty proud of it and of

00:08:56,800 --> 00:09:01,960
course answer the orbs evil okay so we

00:08:59,920 --> 00:09:05,440
will go over all of this probably not

00:09:01,960 --> 00:09:08,530
see but many a and B okay a bit of see a

00:09:05,440 --> 00:09:13,270
tree and we try to see how everything

00:09:08,530 --> 00:09:15,940
fits okay so yeah as I say when we

00:09:13,270 --> 00:09:18,640
explain all everything works we actually

00:09:15,940 --> 00:09:21,160
show that it's not that complicated it's

00:09:18,640 --> 00:09:23,260
not complicated it's a bit complex every

00:09:21,160 --> 00:09:26,260
sub pieces we will be using to build our

00:09:23,260 --> 00:09:28,780
small and written expression template

00:09:26,260 --> 00:09:30,490
and shine is in itself a very simple

00:09:28,780 --> 00:09:32,950
audience that you will probably use

00:09:30,490 --> 00:09:35,410
elsewhere already the complexity comes

00:09:32,950 --> 00:09:38,830
from the stacking of all of this in a

00:09:35,410 --> 00:09:40,510
very tight space next part as the same

00:09:38,830 --> 00:09:42,460
we see oh we can actually generate that

00:09:40,510 --> 00:09:44,740
Windu's prado and see all the new sea

00:09:42,460 --> 00:09:46,750
prospers can actually be useful and when

00:09:44,740 --> 00:09:48,370
we discuss some new stuff and all we can

00:09:46,750 --> 00:09:49,780
actually make all those techniques some

00:09:48,370 --> 00:09:52,360
things that the language can provide us

00:09:49,780 --> 00:09:55,900
that's more or less what we will be

00:09:52,360 --> 00:09:58,270
doing so first part is okay basic

00:09:55,900 --> 00:10:04,210
principle oh everything is supposed to

00:09:58,270 --> 00:10:05,860
walk okay so first is okay where does it

00:10:04,210 --> 00:10:08,950
come from it's actually a very very very

00:10:05,860 --> 00:10:11,440
old technique 20 years older than say so

00:10:08,950 --> 00:10:13,420
it's actually a joint discovery by on

00:10:11,440 --> 00:10:17,170
one side taught version and on the other

00:10:13,420 --> 00:10:19,630
side there is one would around 1994 1995

00:10:17,170 --> 00:10:21,790
so taught was an intern at rogue wave

00:10:19,630 --> 00:10:26,200
Oregon working on the image processing

00:10:21,790 --> 00:10:28,810
libraries dealing with image algebra you

00:10:26,200 --> 00:10:31,210
know like some of images and scaling of

00:10:28,810 --> 00:10:33,940
the pixels or and so on and so on and he

00:10:31,210 --> 00:10:35,830
discovered what we become the expression

00:10:33,940 --> 00:10:37,810
template techniques by trying exactly to

00:10:35,830 --> 00:10:41,860
do what I said earlier is trying to

00:10:37,810 --> 00:10:43,300
optimize all those temporary objects Rob

00:10:41,860 --> 00:10:46,480
where we show the technical report on

00:10:43,300 --> 00:10:49,420
this I think it was 94 and there is a

00:10:46,480 --> 00:10:51,190
whole bunch of C++ report articles that

00:10:49,420 --> 00:10:53,500
you can find on the internet about

00:10:51,190 --> 00:10:56,310
explaining all the intricacies of what

00:10:53,500 --> 00:10:59,370
Todd found so

00:10:56,310 --> 00:11:02,010
and at the same time everybody would was

00:10:59,370 --> 00:11:05,640
walking on some very rare implementation

00:11:02,010 --> 00:11:09,029
and just end up doing the same exact

00:11:05,640 --> 00:11:11,400
kind of things and it was actually

00:11:09,029 --> 00:11:13,650
proposed on somewhere and the funny

00:11:11,400 --> 00:11:17,040
thing is that the actual first users of

00:11:13,650 --> 00:11:19,290
this that pushed the the technique into

00:11:17,040 --> 00:11:21,120
the public was a physicist that actually

00:11:19,290 --> 00:11:22,650
published a paper in and roll called

00:11:21,120 --> 00:11:24,630
computers in physics that say hey look

00:11:22,650 --> 00:11:27,120
at that we can actually no write C++

00:11:24,630 --> 00:11:29,550
code and it's as fast as our old good

00:11:27,120 --> 00:11:33,120
old Fortran which act at the time was

00:11:29,550 --> 00:11:35,010
big so I dig up Zeus okay so that's the

00:11:33,120 --> 00:11:37,430
first email actually speaking about the

00:11:35,010 --> 00:11:40,380
problem one of the first email I guess I

00:11:37,430 --> 00:11:41,940
couldn't go I mean earlier than that so

00:11:40,380 --> 00:11:44,100
it's made by someone that made the

00:11:41,940 --> 00:11:46,080
matrices for complex number and the

00:11:44,100 --> 00:11:47,850
question is I have a temporaries that

00:11:46,080 --> 00:11:50,610
should not be there oh can I actually

00:11:47,850 --> 00:11:53,370
get rid of that - which David the other

00:11:50,610 --> 00:11:57,410
one say okay oh you can it's a bit

00:11:53,370 --> 00:11:59,970
complicated and start with the most

00:11:57,410 --> 00:12:02,610
biggest and the statement of the century

00:11:59,970 --> 00:12:05,010
it make any use of class and function

00:12:02,610 --> 00:12:06,870
templates okay to avoid the generation

00:12:05,010 --> 00:12:09,240
of temporary so that problem is the

00:12:06,870 --> 00:12:13,170
first race that is coming from CPP comp

00:12:09,240 --> 00:12:15,000
come CPP something on Usenet okay so

00:12:13,170 --> 00:12:17,580
that's the first stuff I found out about

00:12:15,000 --> 00:12:23,850
this so we had a V use of function

00:12:17,580 --> 00:12:26,940
templates that's a small to say so it's

00:12:23,850 --> 00:12:30,330
all doesn't mean it's not useful yet so

00:12:26,940 --> 00:12:31,710
how does it was so make issue when you

00:12:30,330 --> 00:12:33,630
want to understand what extras and

00:12:31,710 --> 00:12:35,670
templates is actually doing it so

00:12:33,630 --> 00:12:38,250
actually to look at what the compiler is

00:12:35,670 --> 00:12:41,190
doing so let's say you have this kind of

00:12:38,250 --> 00:12:43,530
arithmetic expression going on okay with

00:12:41,190 --> 00:12:47,040
parents and operators identifiers

00:12:43,530 --> 00:12:49,680
constant so when you pass it with your

00:12:47,040 --> 00:12:53,330
brain is clear what's going on but for a

00:12:49,680 --> 00:12:55,470
machine it's a bit more complicated so

00:12:53,330 --> 00:12:57,480
as you can bind on what you want to know

00:12:55,470 --> 00:12:59,550
is you might want to do is understand

00:12:57,480 --> 00:13:02,430
what this expression means and what all

00:12:59,550 --> 00:13:04,860
is components so you can take decision

00:13:02,430 --> 00:13:07,800
about what to do with each of them so

00:13:04,860 --> 00:13:09,680
one classical way to do that but with

00:13:07,800 --> 00:13:12,200
the only sane way to do that

00:13:09,680 --> 00:13:15,230
is to being what we call a derivation

00:13:12,200 --> 00:13:17,480
tree or syntax tree which is a tree

00:13:15,230 --> 00:13:19,580
representing the structure of the

00:13:17,480 --> 00:13:22,520
expression in a way that we can

00:13:19,580 --> 00:13:25,910
construct it by traversing the tree so

00:13:22,520 --> 00:13:28,760
it goes like this so that's a full-blown

00:13:25,910 --> 00:13:33,130
syntax tree where everything is set up

00:13:28,760 --> 00:13:36,020
okay so this EPA so problem by French is

00:13:33,130 --> 00:13:38,990
expression commercially pure algebra an

00:13:36,020 --> 00:13:42,140
algebraic expression is made of

00:13:38,990 --> 00:13:44,779
something on the left and operator and

00:13:42,140 --> 00:13:46,550
something on the right as and is

00:13:44,779 --> 00:13:49,940
something on the left or on the right

00:13:46,550 --> 00:13:52,279
can be either another expression of

00:13:49,940 --> 00:13:55,850
arithmetic components okay

00:13:52,279 --> 00:14:00,100
or if we look down down down the tree an

00:13:55,850 --> 00:14:03,410
identifier X Y Z or a constant 3 & 4 and

00:14:00,100 --> 00:14:05,990
by combining this you can buy you can

00:14:03,410 --> 00:14:10,430
build arbitrarily large expression with

00:14:05,990 --> 00:14:13,550
plus x constants in antivirus so if we

00:14:10,430 --> 00:14:16,400
if we wanted to store the structure of

00:14:13,550 --> 00:14:19,779
this tree somewhere we will probably end

00:14:16,400 --> 00:14:22,880
up having some kind of tree structure

00:14:19,779 --> 00:14:24,890
continuing to left start to right char

00:14:22,880 --> 00:14:29,120
and whatever happens when you traverse

00:14:24,890 --> 00:14:32,750
the tree okay so you can actually write

00:14:29,120 --> 00:14:35,420
regular runtime based built or function

00:14:32,750 --> 00:14:37,850
code based implementation of these three

00:14:35,420 --> 00:14:40,220
classes you probably end up with a tree

00:14:37,850 --> 00:14:42,130
base class with that alt interface you

00:14:40,220 --> 00:14:45,709
need and you will probably have

00:14:42,130 --> 00:14:47,990
subclasses like constant link fire and

00:14:45,709 --> 00:14:50,360
so on and so on binary expression that

00:14:47,990 --> 00:14:53,900
we just do whatever the name implies and

00:14:50,360 --> 00:14:57,020
you can put into a vector or another

00:14:53,900 --> 00:14:59,270
construct of base expression pointers or

00:14:57,020 --> 00:15:02,120
reference so you can actually write this

00:14:59,270 --> 00:15:04,550
and an ABI to run at one time probably

00:15:02,120 --> 00:15:08,300
using some kind of factory but if you

00:15:04,550 --> 00:15:10,459
look at them at the problem is you have

00:15:08,300 --> 00:15:14,300
to stuff going on you have something

00:15:10,459 --> 00:15:18,410
which is intrinsically dynamic or no

00:15:14,300 --> 00:15:20,750
none runtime the value of XYZ it doesn't

00:15:18,410 --> 00:15:22,459
know them yet you know it's the value

00:15:20,750 --> 00:15:23,030
behind this identifier but doesn't know

00:15:22,459 --> 00:15:25,670
what

00:15:23,030 --> 00:15:28,970
and there is another part which is

00:15:25,670 --> 00:15:29,420
completely know at static at compile

00:15:28,970 --> 00:15:32,540
time

00:15:29,420 --> 00:15:35,330
it's the static structure of which piece

00:15:32,540 --> 00:15:37,130
of tree goes where the fact that you

00:15:35,330 --> 00:15:39,560
have a tree with the minus operator is

00:15:37,130 --> 00:15:42,140
containing two sub trees one wizard time

00:15:39,560 --> 00:15:44,300
Submariner and one DiNozzo - with a

00:15:42,140 --> 00:15:46,820
constant of the right and plus on the

00:15:44,300 --> 00:15:50,570
left is completely known as compile time

00:15:46,820 --> 00:15:53,330
it doesn't need to store this

00:15:50,570 --> 00:15:55,160
information at runtime okay so the trick

00:15:53,330 --> 00:15:58,100
is to find a way to say okay what I have

00:15:55,160 --> 00:16:01,760
want to have is a representation of a

00:15:58,100 --> 00:16:04,820
tree with some amount of children that

00:16:01,760 --> 00:16:07,330
can embed these structures in a

00:16:04,820 --> 00:16:08,540
competent way which means in the type

00:16:07,330 --> 00:16:11,360
okay

00:16:08,540 --> 00:16:13,910
so the idea is to say okay that's pretty

00:16:11,360 --> 00:16:19,640
trivial I just could just have a first

00:16:13,910 --> 00:16:21,800
type oh I'm going with myself so that's

00:16:19,640 --> 00:16:23,720
a full syntax tree and so what would we

00:16:21,800 --> 00:16:26,750
be doing to do is once we have those

00:16:23,720 --> 00:16:29,480
types okay we can do something like this

00:16:26,750 --> 00:16:34,100
we start from an arbitrary statement

00:16:29,480 --> 00:16:36,950
using our library on the left yes

00:16:34,100 --> 00:16:40,130
and on the right we see another kind of

00:16:36,950 --> 00:16:42,410
tree okay these blue and red stuff okay

00:16:40,130 --> 00:16:45,620
and if you look at these three it's far

00:16:42,410 --> 00:16:48,470
more simpler than this one okay because

00:16:45,620 --> 00:16:50,210
we stripping it of all these syntactic

00:16:48,470 --> 00:16:52,790
informations that didn't bring anything

00:16:50,210 --> 00:16:55,190
on the table we just have a simple tree

00:16:52,790 --> 00:16:58,100
which is a succession of operation node

00:16:55,190 --> 00:16:59,840
and sub trees and sub trees can be a

00:16:58,100 --> 00:17:03,620
constant or something else but

00:16:59,840 --> 00:17:06,100
everything about the actual syntax the

00:17:03,620 --> 00:17:08,870
actual parents or whatever is stripped

00:17:06,100 --> 00:17:12,530
that's what we call an abstract syntax

00:17:08,870 --> 00:17:14,870
tree okay so that's just boiled down

00:17:12,530 --> 00:17:17,270
version of what the compiler is supposed

00:17:14,870 --> 00:17:20,300
to generate and what we do if you look

00:17:17,270 --> 00:17:22,940
closely at the color code is we we embed

00:17:20,300 --> 00:17:26,000
in red so structure of the tree into

00:17:22,940 --> 00:17:28,339
this expression type in the big box on

00:17:26,000 --> 00:17:30,740
the net and if you go down this very

00:17:28,339 --> 00:17:33,440
complex type of expert of the sign

00:17:30,740 --> 00:17:36,260
expert of matrix X pair of plus of

00:17:33,440 --> 00:17:38,720
course of multiplies if you go down this

00:17:36,260 --> 00:17:40,460
in one way or another you are able to

00:17:38,720 --> 00:17:42,380
reconstruct the tree because you have

00:17:40,460 --> 00:17:44,120
all the information I'm making in that

00:17:42,380 --> 00:17:47,360
segment between something which is a

00:17:44,120 --> 00:17:49,130
matrix on the left with something which

00:17:47,360 --> 00:17:52,130
is an exposition doing some plus

00:17:49,130 --> 00:17:53,990
operation with left hand side in the

00:17:52,130 --> 00:17:55,640
right hand side which is each of them

00:17:53,990 --> 00:17:58,630
being something else which can

00:17:55,640 --> 00:18:01,669
recursively be another expression and

00:17:58,630 --> 00:18:04,880
this information will be sold into a

00:18:01,669 --> 00:18:07,460
type and the objects you build actually

00:18:04,880 --> 00:18:11,059
store value copies actually are

00:18:07,460 --> 00:18:13,549
reference to the runtime information

00:18:11,059 --> 00:18:16,390
into the the leaf of the tree the blue

00:18:13,549 --> 00:18:19,130
blocks okay which we call terminals and

00:18:16,390 --> 00:18:21,830
what would we be doing is also we did

00:18:19,130 --> 00:18:24,260
this capture somehow you can actually

00:18:21,830 --> 00:18:28,700
taste the type of this massive tree and

00:18:24,260 --> 00:18:30,470
you can torture it as much as you want

00:18:28,700 --> 00:18:32,059
using template metaprogramming because

00:18:30,470 --> 00:18:34,070
that's a type so I can transform it the

00:18:32,059 --> 00:18:36,380
way I want until you end up with

00:18:34,070 --> 00:18:38,390
something which is exactly what we need

00:18:36,380 --> 00:18:40,910
to take decision about what kind of code

00:18:38,390 --> 00:18:42,500
do I want to generate and throw in this

00:18:40,910 --> 00:18:45,020
example what we do say okay we are

00:18:42,500 --> 00:18:46,790
dealing with matrixes I have my trees

00:18:45,020 --> 00:18:49,130
that give me whatever operation I should

00:18:46,790 --> 00:18:52,520
be doing on every element of my matrixes

00:18:49,130 --> 00:18:55,220
so I will just put out a loop nest and

00:18:52,520 --> 00:18:57,620
because I feel it I will just put it up

00:18:55,220 --> 00:19:01,340
on openmp prioritization from around it

00:18:57,620 --> 00:19:04,160
and I will just we play my tree Maya

00:19:01,340 --> 00:19:06,799
cinnamon between X and costs of a plus B

00:19:04,160 --> 00:19:09,790
times a for every element of the matrix

00:19:06,799 --> 00:19:13,309
is inside this box

00:19:09,790 --> 00:19:15,020
okay so I've wrote that and the compiler

00:19:13,309 --> 00:19:18,169
did this for me okay

00:19:15,020 --> 00:19:21,200
and the trick happens there we transform

00:19:18,169 --> 00:19:24,350
this iced tea as much as we want until

00:19:21,200 --> 00:19:25,640
we know what we will be doing okay so

00:19:24,350 --> 00:19:27,710
that's the first stuff we will be

00:19:25,640 --> 00:19:29,570
needing to do we need to store the

00:19:27,710 --> 00:19:32,059
matrix term we need to store the

00:19:29,570 --> 00:19:34,549
expression as we beat them first

00:19:32,059 --> 00:19:36,919
challenge second challenge we need to

00:19:34,549 --> 00:19:39,710
find a way so that construction is easy

00:19:36,919 --> 00:19:41,960
and Eden behind operators and function

00:19:39,710 --> 00:19:44,059
overloading and third we need to have a

00:19:41,960 --> 00:19:47,240
way to traverse this tree to transform

00:19:44,059 --> 00:19:49,159
it or to evaluate some value out of it

00:19:47,240 --> 00:19:50,040
and when we know how to do those three

00:19:49,159 --> 00:19:51,450
pieces

00:19:50,040 --> 00:19:55,640
we can actually generate whatever we

00:19:51,450 --> 00:19:58,590
want okay so we take an expression and

00:19:55,640 --> 00:20:00,570
we do something which is very kind to

00:19:58,590 --> 00:20:03,090
what a compiler is doing we extract this

00:20:00,570 --> 00:20:03,510
tree away and try to reason about this

00:20:03,090 --> 00:20:05,549
tree

00:20:03,510 --> 00:20:06,960
the cool thing with tree is that we can

00:20:05,549 --> 00:20:09,900
actually do a lot of stuff with them

00:20:06,960 --> 00:20:11,640
okay because natural process of tree is

00:20:09,900 --> 00:20:13,559
based on recursions we will probably

00:20:11,640 --> 00:20:15,690
have fattened matching on what kind of

00:20:13,559 --> 00:20:19,470
node I am traversing at the moment and

00:20:15,690 --> 00:20:21,600
we can just write regular I mean typical

00:20:19,470 --> 00:20:25,460
that we just visit this tree and take

00:20:21,600 --> 00:20:27,870
decisions about okay is it clear

00:20:25,460 --> 00:20:30,210
that's the main idea of what we'll be

00:20:27,870 --> 00:20:33,030
doing just build the tree and go down it

00:20:30,210 --> 00:20:35,429
or whatever we need to do and when we

00:20:33,030 --> 00:20:35,910
traverse it we just decide what we do

00:20:35,429 --> 00:20:41,340
with it

00:20:35,910 --> 00:20:43,740
okay so well what do we need we need to

00:20:41,340 --> 00:20:45,929
start the expression as I say actually

00:20:43,740 --> 00:20:48,200
we need to stuff storing the operation I

00:20:45,929 --> 00:20:50,669
will be doing at crossing the node or

00:20:48,200 --> 00:20:53,400
not the operation but actually a

00:20:50,669 --> 00:20:55,950
representation of what's going on okay

00:20:53,400 --> 00:20:58,049
we need to start the sub expressions and

00:20:55,950 --> 00:20:59,910
the first question will be should we be

00:20:58,049 --> 00:21:02,070
storing them by value or by reference

00:20:59,910 --> 00:21:04,980
when we see that this is actually a real

00:21:02,070 --> 00:21:07,440
problem and in a way to travel them to

00:21:04,980 --> 00:21:09,480
do something at the same and then how do

00:21:07,440 --> 00:21:11,309
we capture the expression will be just

00:21:09,480 --> 00:21:13,620
be using operators and function

00:21:11,309 --> 00:21:17,130
overloads and use a great tradition of

00:21:13,620 --> 00:21:19,290
writing efficient C++ code with just Y

00:21:17,130 --> 00:21:21,419
functions that do nothing except

00:21:19,290 --> 00:21:23,429
returning a representation of the small

00:21:21,419 --> 00:21:24,990
trees that are currently building so

00:21:23,429 --> 00:21:27,480
basically your plus function won't do

00:21:24,990 --> 00:21:30,750
anything you just return an empty shell

00:21:27,480 --> 00:21:33,059
and say yeah I just crossed a plus

00:21:30,750 --> 00:21:34,700
operation between this and that this is

00:21:33,059 --> 00:21:36,950
the information I found about them

00:21:34,700 --> 00:21:43,650
continue with the rest of the expression

00:21:36,950 --> 00:21:45,419
okay so let's have a look I start with

00:21:43,650 --> 00:21:47,419
something very simple okay we have an

00:21:45,419 --> 00:21:50,160
NRI expression which is an expression

00:21:47,419 --> 00:21:55,290
numerator or functions that take exactly

00:21:50,160 --> 00:21:58,230
one argument so could be like only

00:21:55,290 --> 00:22:00,809
reminders negation absolute value

00:21:58,230 --> 00:22:02,730
whatever and the whatever operation that

00:22:00,809 --> 00:22:03,870
being done when you traverse the tree is

00:22:02,730 --> 00:22:07,410
tall in the

00:22:03,870 --> 00:22:09,270
code tag over there this will give me

00:22:07,410 --> 00:22:12,750
whatever happens when I'm encountering

00:22:09,270 --> 00:22:15,030
this expression and I say I have only

00:22:12,750 --> 00:22:18,059
one argument so I we have only one shot

00:22:15,030 --> 00:22:21,450
which is another subtree and of course

00:22:18,059 --> 00:22:22,559
this tree could be of any type so as I

00:22:21,450 --> 00:22:25,080
don't know what it will be I will just

00:22:22,559 --> 00:22:28,350
again store it as as a template

00:22:25,080 --> 00:22:30,540
pragmatism and you can actually be the

00:22:28,350 --> 00:22:33,960
next new nari expression by taking some

00:22:30,540 --> 00:22:37,110
child and put it inside it and for for

00:22:33,960 --> 00:22:40,350
the example what we do is we give this

00:22:37,110 --> 00:22:42,929
expression a function call operator I

00:22:40,350 --> 00:22:45,270
would just evaluate its value stored

00:22:42,929 --> 00:22:47,820
into the expression okay and what do we

00:22:45,270 --> 00:22:50,520
do well the tag actually is a type which

00:22:47,820 --> 00:22:53,250
is itself a colorable object and so what

00:22:50,520 --> 00:22:56,640
we do is I evaluate my cheat my child

00:22:53,250 --> 00:23:00,480
okay see parents and whatever this gives

00:22:56,640 --> 00:23:02,280
me I pass it to my operation okay and I

00:23:00,480 --> 00:23:04,770
will turn whatever this operation does

00:23:02,280 --> 00:23:08,429
so if you build a linear expression of

00:23:04,770 --> 00:23:10,980
unary minus something we have an into

00:23:08,429 --> 00:23:16,470
something and return - is something okay

00:23:10,980 --> 00:23:17,700
and obviously just I just did the simple

00:23:16,470 --> 00:23:19,830
version so it fits on the slide

00:23:17,700 --> 00:23:21,690
obviously you can actually know except

00:23:19,830 --> 00:23:23,070
and context per whatever you want in

00:23:21,690 --> 00:23:26,940
this doesn't change anything

00:23:23,070 --> 00:23:29,250
okay so that's a unary expression and in

00:23:26,940 --> 00:23:31,140
a very very very complex way this is a

00:23:29,250 --> 00:23:32,880
binary expression which is basically the

00:23:31,140 --> 00:23:37,559
same except they have two children

00:23:32,880 --> 00:23:41,340
okay pío pío p0 p1 get stored store the

00:23:37,559 --> 00:23:44,370
operation and then when you evaluate a

00:23:41,340 --> 00:23:46,800
tree you just call the operation

00:23:44,370 --> 00:23:48,800
function on whatever the result of the

00:23:46,800 --> 00:23:51,090
information of the both children is I

00:23:48,800 --> 00:23:53,940
could have written the ternary

00:23:51,090 --> 00:23:56,010
expression or whatever same things if

00:23:53,940 --> 00:23:57,570
you cross your brain a bit you can

00:23:56,010 --> 00:24:01,559
actually write just an expression that

00:23:57,570 --> 00:24:03,000
takes a class dot dot chives we treat

00:24:01,559 --> 00:24:05,490
you answering with an arbitrary number

00:24:03,000 --> 00:24:08,730
of children it's a bit more complex but

00:24:05,490 --> 00:24:10,500
you can actually do this so okay I store

00:24:08,730 --> 00:24:12,660
unary expression in something like this

00:24:10,500 --> 00:24:15,030
okay I still binary expression in

00:24:12,660 --> 00:24:17,100
something like that right okay

00:24:15,030 --> 00:24:18,960
and of course if you buy the binary

00:24:17,100 --> 00:24:21,780
expression of binary expression and so

00:24:18,960 --> 00:24:24,660
on and so on we just store them in one

00:24:21,780 --> 00:24:26,910
to the others okay so type give you the

00:24:24,660 --> 00:24:29,070
three structures and the value give you

00:24:26,910 --> 00:24:34,710
every value around the tree when you go

00:24:29,070 --> 00:24:36,600
down well we have a special cases that

00:24:34,710 --> 00:24:38,100
we call terminal which is the leaf of

00:24:36,600 --> 00:24:41,160
the tree that contains a value or

00:24:38,100 --> 00:24:43,020
something that we contain the value it's

00:24:41,160 --> 00:24:45,600
usually simpler because you just need to

00:24:43,020 --> 00:24:48,630
know as a value you store inside it okay

00:24:45,600 --> 00:24:50,820
that's a very simple terminal we see

00:24:48,630 --> 00:24:53,040
later that it's actually a bit limited

00:24:50,820 --> 00:24:55,230
but for for the example it's perfect so

00:24:53,040 --> 00:24:57,720
I'm just constructing a terminal with a

00:24:55,230 --> 00:24:59,700
value supposed to contains and whenever

00:24:57,720 --> 00:25:01,830
you ask me to evaluate myself I would

00:24:59,700 --> 00:25:04,770
just return the value to you so a

00:25:01,830 --> 00:25:06,060
terminal or float continuing 3.5 when

00:25:04,770 --> 00:25:09,150
you were very to just return use a

00:25:06,060 --> 00:25:10,050
floating point three point five and if

00:25:09,150 --> 00:25:12,000
you are the generic expression

00:25:10,050 --> 00:25:13,890
containing a terminal when you will

00:25:12,000 --> 00:25:15,600
evaluate the expression you will grab

00:25:13,890 --> 00:25:17,280
the terminal value pass it to the

00:25:15,600 --> 00:25:20,160
operation returns the value of this

00:25:17,280 --> 00:25:22,710
operation and everything is just done

00:25:20,160 --> 00:25:24,800
recursively by this chain of operator

00:25:22,710 --> 00:25:27,390
function calls one into the others

00:25:24,800 --> 00:25:29,970
driven by the number of parameters of

00:25:27,390 --> 00:25:33,030
each expressions and whatever happens

00:25:29,970 --> 00:25:37,950
when you call the operation function

00:25:33,030 --> 00:25:39,870
call okay so basically we if I wanted to

00:25:37,950 --> 00:25:40,670
make a bad choice we are done thanks for

00:25:39,870 --> 00:25:44,760
coming okay

00:25:40,670 --> 00:25:48,030
it's a bit more complacent absently but

00:25:44,760 --> 00:25:50,010
you see you see the magic is there we

00:25:48,030 --> 00:25:50,760
have this recursive call of evaluate

00:25:50,010 --> 00:25:52,980
myself please

00:25:50,760 --> 00:25:55,650
does that go down to three go down three

00:25:52,980 --> 00:25:57,600
and of course depending on what you want

00:25:55,650 --> 00:26:00,060
to do this is a simple direct evaluation

00:25:57,600 --> 00:26:01,680
that you could actually have all the

00:26:00,060 --> 00:26:04,440
option of three traversals

00:26:01,680 --> 00:26:06,060
and fix prefix for speak whatever you

00:26:04,440 --> 00:26:08,370
could actually also have an operation

00:26:06,060 --> 00:26:11,220
that just say my result well it's not a

00:26:08,370 --> 00:26:14,160
new tree but I built from whatever I was

00:26:11,220 --> 00:26:15,930
I got inside okay so this is this is

00:26:14,160 --> 00:26:18,930
what the Magic Flight these recursive

00:26:15,930 --> 00:26:21,570
calls and the fact that you know in each

00:26:18,930 --> 00:26:23,040
operator what you are doing because you

00:26:21,570 --> 00:26:26,100
know that you have a tag and so much

00:26:23,040 --> 00:26:27,790
right and determine all just returns the

00:26:26,100 --> 00:26:31,720
value okay

00:26:27,790 --> 00:26:33,550
well but okay now what I want to do is

00:26:31,720 --> 00:26:35,770
actually I don't want to construct this

00:26:33,550 --> 00:26:37,810
expression by myself because it's

00:26:35,770 --> 00:26:40,030
completely not expressive what I need to

00:26:37,810 --> 00:26:42,990
do is find a way to add operators nice

00:26:40,030 --> 00:26:45,700
operator plus of something something and

00:26:42,990 --> 00:26:47,290
you get you end up with a binary

00:26:45,700 --> 00:26:49,810
expression of plus something something

00:26:47,290 --> 00:26:51,400
so you can just call plus and you get

00:26:49,810 --> 00:26:51,850
your expression built okay that's what

00:26:51,400 --> 00:26:54,370
we want

00:26:51,850 --> 00:26:57,340
except we basically have three different

00:26:54,370 --> 00:26:59,680
types here okay and all of these three

00:26:57,340 --> 00:27:01,630
types can actually be used on the left

00:26:59,680 --> 00:27:04,300
or the right inside of our plus barrier

00:27:01,630 --> 00:27:06,700
okay so the question is called all can I

00:27:04,300 --> 00:27:10,270
write this operator so it does not end

00:27:06,700 --> 00:27:13,270
up as template a template be operative

00:27:10,270 --> 00:27:16,090
press of a B which is far far far too

00:27:13,270 --> 00:27:18,370
much unconstrained so the idea is to

00:27:16,090 --> 00:27:21,160
find a way to say I will take everything

00:27:18,370 --> 00:27:23,200
there and put it into a common box and I

00:27:21,160 --> 00:27:27,100
will try to apply my operators on this

00:27:23,200 --> 00:27:28,630
common box okay so that's basically what

00:27:27,100 --> 00:27:30,940
we will be doing if you are writing a

00:27:28,630 --> 00:27:33,340
runtime based polymorphism versions but

00:27:30,940 --> 00:27:35,260
we don't want to do this so what we'll

00:27:33,340 --> 00:27:37,390
be doing is using your very very

00:27:35,260 --> 00:27:40,090
well-known items which is a cursory

00:27:37,390 --> 00:27:43,510
recursive template pattern okay that's

00:27:40,090 --> 00:27:45,490
quite a mouthful so apparently it's a

00:27:43,510 --> 00:27:47,530
pattern which is based on some kind of

00:27:45,490 --> 00:27:50,710
recursive template which act in a Coon's

00:27:47,530 --> 00:27:53,680
way okay so let's have a look so the

00:27:50,710 --> 00:27:56,560
idea is oh can i simulate runtime

00:27:53,680 --> 00:28:00,450
polymorphisms at compile time well you

00:27:56,560 --> 00:28:02,560
write some things that look like this

00:28:00,450 --> 00:28:04,780
just have a look at that how many people

00:28:02,560 --> 00:28:08,680
know about the CRT P just another poll

00:28:04,780 --> 00:28:10,690
yes cool so I want forward one spend too

00:28:08,680 --> 00:28:12,520
much time in that for the others here's

00:28:10,690 --> 00:28:14,800
what what goes you have a base class

00:28:12,520 --> 00:28:17,610
which is probably trying on the template

00:28:14,800 --> 00:28:21,880
types and you're providing interface

00:28:17,610 --> 00:28:26,500
okay and you have a derived class okay

00:28:21,880 --> 00:28:28,720
is that here it's from base using its

00:28:26,500 --> 00:28:31,410
own type I'll subtract the template

00:28:28,720 --> 00:28:34,930
parameters of the base class so derived

00:28:31,410 --> 00:28:37,960
iterates from base derive and as strange

00:28:34,930 --> 00:28:40,480
as it looks it just walks and what

00:28:37,960 --> 00:28:41,470
happens in Bayesian in the interface

00:28:40,480 --> 00:28:44,620
function

00:28:41,470 --> 00:28:47,110
you can actually take this cast it to

00:28:44,620 --> 00:28:49,780
whatever is template parameter is and

00:28:47,110 --> 00:28:53,830
call whatever function on that and why

00:28:49,780 --> 00:28:57,760
does it works why does it work

00:28:53,830 --> 00:29:00,700
it works because whatever base of T you

00:28:57,760 --> 00:29:04,990
have by definition it cannot be anything

00:29:00,700 --> 00:29:08,620
else but a T okay that's a bit kruky

00:29:04,990 --> 00:29:10,419
okay and actually I think the smoke

00:29:08,620 --> 00:29:11,799
through feeds on to your other projects

00:29:10,419 --> 00:29:14,440
different template system but whatever

00:29:11,799 --> 00:29:17,530
it's really with it was if you're a base

00:29:14,440 --> 00:29:20,530
of T you cannot be anything else but a T

00:29:17,530 --> 00:29:23,590
by construction so casting yourself into

00:29:20,530 --> 00:29:25,450
a T reference whoops okay and it could

00:29:23,590 --> 00:29:26,980
be a static cast you don't even have to

00:29:25,450 --> 00:29:29,860
do dynamic cast because you know you are

00:29:26,980 --> 00:29:32,039
T so we just go down it's basically I

00:29:29,860 --> 00:29:34,870
think I think we can say some kind of

00:29:32,039 --> 00:29:37,059
programmatically done slicing of object

00:29:34,870 --> 00:29:39,390
I think that's based image we can have

00:29:37,059 --> 00:29:41,470
of that we just sliced base up to the T

00:29:39,390 --> 00:29:43,179
market it's not slicing the other way

00:29:41,470 --> 00:29:45,250
around we actually pull up your base

00:29:43,179 --> 00:29:48,100
into a T a fool T and you do whatever

00:29:45,250 --> 00:29:51,100
you need so what you what do we win with

00:29:48,100 --> 00:29:53,350
that the interface function is inherited

00:29:51,100 --> 00:29:56,080
by every types in everything from base

00:29:53,350 --> 00:29:57,909
of something so we have a place where we

00:29:56,080 --> 00:30:00,130
have a common interface and we know what

00:29:57,909 --> 00:30:02,309
to do with it and the actual

00:30:00,130 --> 00:30:04,539
implementation is store into the

00:30:02,309 --> 00:30:06,850
subclasses like with regular

00:30:04,539 --> 00:30:09,490
polymorphism so we can either type

00:30:06,850 --> 00:30:12,130
specific implementation into the base

00:30:09,490 --> 00:30:15,039
herbs or into the subclasses and we can

00:30:12,130 --> 00:30:16,809
take a base of something and call

00:30:15,039 --> 00:30:22,330
whatever we want on it and it would be

00:30:16,809 --> 00:30:24,880
dispatched to the current version so if

00:30:22,330 --> 00:30:26,919
we take that and put it on our own area

00:30:24,880 --> 00:30:29,320
and binary expression in terminal we end

00:30:26,919 --> 00:30:32,110
up with this which is not very readable

00:30:29,320 --> 00:30:35,679
from afar okay so let's have a look at

00:30:32,110 --> 00:30:38,590
how it looks a bit bigger okay probably

00:30:35,679 --> 00:30:40,539
better if I show you it there okay is it

00:30:38,590 --> 00:30:42,580
is it okay for the size for everybody or

00:30:40,539 --> 00:30:47,070
kind of should i zoom a bit more it's

00:30:42,580 --> 00:30:49,240
okay okay so we have this base expert

00:30:47,070 --> 00:30:53,620
classes which is basically our base

00:30:49,240 --> 00:30:54,570
route for our CRT P system we just I

00:30:53,620 --> 00:30:57,000
just static

00:30:54,570 --> 00:30:59,520
inside the self function that's

00:30:57,000 --> 00:31:02,010
something which is very classic and what

00:30:59,520 --> 00:31:03,840
is in the face of our expression

00:31:02,010 --> 00:31:06,090
whatever is the type of expression and

00:31:03,840 --> 00:31:07,980
unary binary terminal operation we want

00:31:06,090 --> 00:31:10,440
to have these function collaborators so

00:31:07,980 --> 00:31:12,870
we ship it into the into the base class

00:31:10,440 --> 00:31:16,110
and what does it do it take itself and

00:31:12,870 --> 00:31:20,340
apply is corporator I could actually

00:31:16,110 --> 00:31:23,340
call this another function and put it

00:31:20,340 --> 00:31:26,190
into privates into a private section but

00:31:23,340 --> 00:31:29,250
in that details so what happened for

00:31:26,190 --> 00:31:34,110
unary expert you know me explore any of

00:31:29,250 --> 00:31:36,720
it from base base X of itself okay cell

00:31:34,110 --> 00:31:37,860
constructor and the end the actual

00:31:36,720 --> 00:31:40,350
implementation of the function

00:31:37,860 --> 00:31:45,080
collaborator just as before we just

00:31:40,350 --> 00:31:45,080
enter it from base expert okay

00:31:45,890 --> 00:31:53,880
binary expert same stuff we inherit from

00:31:49,500 --> 00:31:58,500
the basics for something same for

00:31:53,880 --> 00:32:00,840
terminal okay and now we go to the

00:31:58,500 --> 00:32:06,960
actual meat of the systems I want to

00:32:00,840 --> 00:32:12,420
define my over enterprise okay I can do

00:32:06,960 --> 00:32:14,520
this so basic spur it has is self memory

00:32:12,420 --> 00:32:17,040
functions that just do I mean just

00:32:14,520 --> 00:32:19,050
writes a static stuff okay and then you

00:32:17,040 --> 00:32:29,190
call it inside the whatever interface

00:32:19,050 --> 00:32:30,690
you want yes please yeah I just it just

00:32:29,190 --> 00:32:33,720
occurs to me right now

00:32:30,690 --> 00:32:35,670
it just i should have been calling it

00:32:33,720 --> 00:32:38,010
something else into the base classes

00:32:35,670 --> 00:32:41,130
yeah yeah yeah but we never actually an

00:32:38,010 --> 00:32:43,320
end those there's an on-base expert I

00:32:41,130 --> 00:32:44,700
would go to that afterwards okay

00:32:43,320 --> 00:32:46,350
but yeah you should have been better

00:32:44,700 --> 00:32:47,820
style I will I will correct it on the on

00:32:46,350 --> 00:32:50,370
the Gita usually better start to up

00:32:47,820 --> 00:32:52,140
different thing because in this case we

00:32:50,370 --> 00:32:54,810
are not very sure you don't mask

00:32:52,140 --> 00:32:56,490
anything well the fact is that in this

00:32:54,810 --> 00:32:58,200
system so that means that if you end up

00:32:56,490 --> 00:33:00,360
actually dealing directly with an energy

00:32:58,200 --> 00:33:03,030
expert and you call the whatever we

00:33:00,360 --> 00:33:04,680
directly go to the whatever you don't go

00:33:03,030 --> 00:33:07,020
through the base one and do the cast and

00:33:04,680 --> 00:33:08,790
when you go through the base you go

00:33:07,020 --> 00:33:10,610
through all the loops and go back to sit

00:33:08,790 --> 00:33:14,310
down to the to the correct one okay so

00:33:10,610 --> 00:33:17,220
we have this self stuff that used to

00:33:14,310 --> 00:33:19,920
cast yourself into one of your sub

00:33:17,220 --> 00:33:23,810
classes and you ask your sub classes to

00:33:19,920 --> 00:33:27,080
take care of the actual processing okay

00:33:23,810 --> 00:33:27,080
here's a question

00:33:29,750 --> 00:33:36,050
so it's from there we just borrow plates

00:33:32,730 --> 00:33:39,060
we do this for every kind of expression

00:33:36,050 --> 00:33:39,720
very repetitive work the only one to do

00:33:39,060 --> 00:33:44,250
that at home

00:33:39,720 --> 00:33:48,420
ready same for binary same time you know

00:33:44,250 --> 00:33:50,610
and let's look at operator plus we will

00:33:48,420 --> 00:33:50,970
go on the other stuff afterwards look at

00:33:50,610 --> 00:33:56,220
that

00:33:50,970 --> 00:33:59,130
this part lines 56 to 60 this block so

00:33:56,220 --> 00:34:02,700
what we say that when we call operator

00:33:59,130 --> 00:34:07,740
plus on two different ways expert of

00:34:02,700 --> 00:34:12,240
whatever what I do is I build the new

00:34:07,740 --> 00:34:14,940
binary expert the operation being plus

00:34:12,240 --> 00:34:18,150
okay that's this plus and the score is

00:34:14,940 --> 00:34:19,550
telling us what do we store whatever is

00:34:18,150 --> 00:34:22,560
inside

00:34:19,550 --> 00:34:25,200
Tobias expert okay

00:34:22,560 --> 00:34:31,650
and we just be the object storage the

00:34:25,200 --> 00:34:34,020
things okay and follow the repetitions

00:34:31,650 --> 00:34:37,500
we do the same for operator times okay

00:34:34,020 --> 00:34:39,360
same things different tag same system

00:34:37,500 --> 00:34:41,400
extracts the self from the base

00:34:39,360 --> 00:34:45,390
expression stow it into a new block

00:34:41,400 --> 00:34:47,790
ship the block so we didn't do any

00:34:45,390 --> 00:34:50,910
computation there we just build a very

00:34:47,790 --> 00:34:53,280
lightweight representation of I just

00:34:50,910 --> 00:34:55,350
came across a plus into this expression

00:34:53,280 --> 00:34:57,840
so I would just want to inform you that

00:34:55,350 --> 00:35:01,200
I just did this and you will take care

00:34:57,840 --> 00:35:04,230
of that later and what do we doing plus

00:35:01,200 --> 00:35:07,500
so plus can be an empty type just a tag

00:35:04,230 --> 00:35:12,870
but what we want to do is actually use

00:35:07,500 --> 00:35:15,990
it as kind of an object so what we do is

00:35:12,870 --> 00:35:18,600
we just give him a polymorphic template

00:35:15,990 --> 00:35:21,840
operators function call that a Katia you

00:35:18,600 --> 00:35:25,080
and just return T plus U and what was

00:35:21,840 --> 00:35:29,010
the type of this is and same for x we

00:35:25,080 --> 00:35:30,990
just do T times u so that give us if

00:35:29,010 --> 00:35:34,490
operation called syntax for the

00:35:30,990 --> 00:35:38,820
operation inside the expression okay

00:35:34,490 --> 00:35:40,980
doctor classical way to do it so what

00:35:38,820 --> 00:35:42,810
happens now when I when I call my up my

00:35:40,980 --> 00:35:45,000
parents will be later on on the binary

00:35:42,810 --> 00:35:51,240
expression that goes there these

00:35:45,000 --> 00:35:53,730
functions air which sit inside tag okay

00:35:51,240 --> 00:35:57,570
this operation is actually this piece of

00:35:53,730 --> 00:35:59,850
code and when you go down inside the tag

00:35:57,570 --> 00:36:01,530
operation you don't care about the fact

00:35:59,850 --> 00:36:04,470
that you've got a binary expression and

00:36:01,530 --> 00:36:06,720
something in something you just get raw

00:36:04,470 --> 00:36:11,580
values as an input and you do whatever

00:36:06,720 --> 00:36:13,650
you want with them okay because we ever

00:36:11,580 --> 00:36:15,690
made it through whatever before and what

00:36:13,650 --> 00:36:20,160
we have is recursive a variation of all

00:36:15,690 --> 00:36:24,150
of this okay so I have a way to build

00:36:20,160 --> 00:36:26,340
those operators right okay and I can

00:36:24,150 --> 00:36:28,890
write self exists look into the main I

00:36:26,340 --> 00:36:32,670
just be determinant of end containing

00:36:28,890 --> 00:36:35,340
for and I build an expression which is D

00:36:32,670 --> 00:36:37,650
plus D I've taught that into E and I

00:36:35,340 --> 00:36:43,140
just asked for the value of e by calling

00:36:37,650 --> 00:36:45,420
is evaluation operation okay well still

00:36:43,140 --> 00:36:48,870
not very fancy but let's see if it

00:36:45,420 --> 00:36:51,210
actually works in two parts I'm a bit

00:36:48,870 --> 00:36:53,789
I'm a bit lazy so just as this guy to do

00:36:51,210 --> 00:36:57,279
all the work for me

00:36:53,789 --> 00:37:00,130
so that's experiment expert I'm your

00:36:57,279 --> 00:37:01,329
binary expression plus times so I don't

00:37:00,130 --> 00:37:03,279
remember what I use

00:37:01,329 --> 00:37:06,549
so four plus four probably give us our

00:37:03,279 --> 00:37:09,069
eight G's problem is the most convoluted

00:37:06,549 --> 00:37:12,519
version of printing eight on the screen

00:37:09,069 --> 00:37:14,470
you can actually find well I can do more

00:37:12,519 --> 00:37:17,200
than that but as that's currently for

00:37:14,470 --> 00:37:18,670
still too much well judge joking so what

00:37:17,200 --> 00:37:23,470
happens if I just want to do this

00:37:18,670 --> 00:37:26,499
instead I could just write it okay pick

00:37:23,470 --> 00:37:31,329
compiled link run think 20 is it right

00:37:26,499 --> 00:37:35,140
yes four times four is four but oh crap

00:37:31,329 --> 00:37:45,730
because I guess it's too okay so adopt

00:37:35,140 --> 00:37:47,950
solution is it better it's actually

00:37:45,730 --> 00:37:52,450
simpler than me trying to fix my ratio

00:37:47,950 --> 00:37:54,579
on on the screen so so it was that so

00:37:52,450 --> 00:37:57,279
okay so if you look at the combination

00:37:54,579 --> 00:37:59,049
line I'm using she prefers 14 majority

00:37:57,279 --> 00:38:01,690
cause I'm a lazy guy and I put auto

00:37:59,049 --> 00:38:05,079
everywhere okay of course it's not

00:38:01,690 --> 00:38:06,789
needed of course it's not needed but you

00:38:05,079 --> 00:38:10,839
can work if you want even try to write

00:38:06,789 --> 00:38:12,519
this not using auto and I will probably

00:38:10,839 --> 00:38:15,880
get an appointment with you next month

00:38:12,519 --> 00:38:18,849
okay because as you can see already this

00:38:15,880 --> 00:38:21,579
autos there to be replaced it's not that

00:38:18,849 --> 00:38:23,349
funky okay I have a tendon you and I

00:38:21,579 --> 00:38:25,630
want the type of arbitrary t plus I'll

00:38:23,349 --> 00:38:26,950
be telling you in tsipras first 98 so

00:38:25,630 --> 00:38:35,769
that's not that quite easy

00:38:26,950 --> 00:38:37,869
yes questions yes what I we do just now

00:38:35,769 --> 00:38:44,289
is I would try to print the actual types

00:38:37,869 --> 00:38:47,220
of e okay so beware oh yeah well maybe

00:38:44,289 --> 00:38:47,220
say yeah what I need

00:38:49,760 --> 00:39:00,990
let's pray yes theory so okay so let's

00:38:59,190 --> 00:39:05,220
have a look at the tip of everybody

00:39:00,990 --> 00:39:06,360
there D and E okay so what is the oldest

00:39:05,220 --> 00:39:12,870
what's already yes

00:39:06,360 --> 00:39:14,520
boost Domingo probably this so let's

00:39:12,870 --> 00:39:17,250
take the type idea of the whole thing

00:39:14,520 --> 00:39:23,550
and ask boost the mango to print it into

00:39:17,250 --> 00:39:27,030
a readable formats okay so what happens

00:39:23,550 --> 00:39:28,830
what is okay what is the type of D we

00:39:27,030 --> 00:39:31,860
expect it to be something like struck

00:39:28,830 --> 00:39:34,260
terminal event if not something is is

00:39:31,860 --> 00:39:35,700
rotten into the Kingdom of Denmark okay

00:39:34,260 --> 00:39:37,400
it's not a member of boost what the crap

00:39:35,700 --> 00:39:42,840
is that

00:39:37,400 --> 00:39:46,230
who's in charge okay let actually snot

00:39:42,840 --> 00:39:53,930
me so just five seconds I don't remember

00:39:46,230 --> 00:39:57,320
what was the damn thing is you know

00:39:53,930 --> 00:40:00,720
readings of dog this was a week you know

00:39:57,320 --> 00:40:05,000
core manga where is it actually sitting

00:40:00,720 --> 00:40:10,770
in a boost go of course I'm stupid

00:40:05,000 --> 00:40:14,040
should have known okay it's stemming

00:40:10,770 --> 00:40:18,360
elephant right so now let's have a look

00:40:14,040 --> 00:40:21,120
at what happens if we do this so what we

00:40:18,360 --> 00:40:23,570
expect is something close to unity

00:40:21,120 --> 00:40:26,810
expert plus terminal in terminal okay

00:40:23,570 --> 00:40:26,810
let's have a look

00:40:29,840 --> 00:40:37,220
binary x four plus terminal in terminal

00:40:32,750 --> 00:40:40,980
okay so question why don't we just store

00:40:37,220 --> 00:40:41,850
binary expert of plus base expert a

00:40:40,980 --> 00:40:43,770
Marine base

00:40:41,850 --> 00:40:47,940
expert a minute why don't we just do

00:40:43,770 --> 00:40:50,610
that why am I supposed to extract the

00:40:47,940 --> 00:40:52,850
self from the base expert before storing

00:40:50,610 --> 00:40:52,850
them

00:41:00,020 --> 00:41:09,690
what yep yes yeah exactly you you may

00:41:07,710 --> 00:41:12,420
want to carry on more data than just the

00:41:09,690 --> 00:41:15,270
base expert allow you to okay you may

00:41:12,420 --> 00:41:18,930
have special members or special data set

00:41:15,270 --> 00:41:20,790
into your actual derived class that you

00:41:18,930 --> 00:41:23,730
really really want to add when you when

00:41:20,790 --> 00:41:27,210
you store them okay so that's D plus D

00:41:23,730 --> 00:41:31,560
so let's let's go to the next level D

00:41:27,210 --> 00:41:35,400
plus D times D and we will touch the

00:41:31,560 --> 00:41:39,119
first issues okay well that's exactly

00:41:35,400 --> 00:41:50,460
what we think it should be okay one more

00:41:39,119 --> 00:41:51,090
time starts to be big okay okay so first

00:41:50,460 --> 00:41:54,619
problem

00:41:51,090 --> 00:41:57,450
look at these frigging symbols sighs

00:41:54,619 --> 00:41:59,550
okay first one is okay second one is

00:41:57,450 --> 00:42:02,340
okay the sell one start to be you know

00:41:59,550 --> 00:42:08,880
whirring and the last one is completely

00:42:02,340 --> 00:42:10,650
out of control so um well just so and of

00:42:08,880 --> 00:42:15,240
course you don't really want to go into

00:42:10,650 --> 00:42:16,980
this kind of territories which actually

00:42:15,240 --> 00:42:23,820
happened how many freaking parents do I

00:42:16,980 --> 00:42:24,930
have there okay it's at school yeah so I

00:42:23,820 --> 00:42:26,550
was about to make a joke about the

00:42:24,930 --> 00:42:28,530
compile time and then I remember that

00:42:26,550 --> 00:42:30,530
the latency there is probably more than

00:42:28,530 --> 00:42:36,570
yet wolves on the actual computation so

00:42:30,530 --> 00:42:38,840
yeah and sincere whirring let's bring

00:42:36,570 --> 00:42:45,060
the Wi-Fi

00:42:38,840 --> 00:42:47,609
come on okay one it combines so yeah

00:42:45,060 --> 00:42:51,240
first issues is this very very very very

00:42:47,609 --> 00:42:53,820
very long symbol name doesn't sound like

00:42:51,240 --> 00:42:56,280
much I mean just simple name but at some

00:42:53,820 --> 00:42:58,290
point the compilers asked to build it to

00:42:56,280 --> 00:43:02,460
store it somewhere in more or less some

00:42:58,290 --> 00:43:04,770
kind of stiffen binding come on okay you

00:43:02,460 --> 00:43:07,080
asked to stores a similar name into

00:43:04,770 --> 00:43:08,970
something which is probably as a string

00:43:07,080 --> 00:43:10,590
like structure which probably means as a

00:43:08,970 --> 00:43:14,700
compiler is allocating memory to store

00:43:10,590 --> 00:43:18,780
it okay and it's still inviting okay

00:43:14,700 --> 00:43:22,619
well meanwhile so several names that's

00:43:18,780 --> 00:43:25,980
the first issue we met that's 99 okay

00:43:22,619 --> 00:43:29,460
that's maybe 75% of why expression

00:43:25,980 --> 00:43:32,670
templates are safe to be slow to compile

00:43:29,460 --> 00:43:35,190
but that's what Rachel's they're okay

00:43:32,670 --> 00:43:38,460
symbol names symbol names mean strings

00:43:35,190 --> 00:43:40,230
longer strings means more complex signal

00:43:38,460 --> 00:43:42,420
more complex but we call more memory and

00:43:40,230 --> 00:43:44,640
more memory means maybe more swapping or

00:43:42,420 --> 00:43:46,440
whatever and your memory consumption of

00:43:44,640 --> 00:43:48,869
your compiler we just go up and at some

00:43:46,440 --> 00:43:53,810
point that will be the main issues about

00:43:48,869 --> 00:43:58,560
that that's really worrying actually ok

00:43:53,810 --> 00:44:02,400
ok let's play ok I think it's from yeah

00:43:58,560 --> 00:44:10,560
ok battery F expert of + between what

00:44:02,400 --> 00:44:15,840
between x + + + + x + x + + + + + x

00:44:10,560 --> 00:44:19,170
again and x again and end on that's

00:44:15,840 --> 00:44:20,910
quite a mouthful so that first first

00:44:19,170 --> 00:44:24,119
mutation and of course if you're if you

00:44:20,910 --> 00:44:28,290
feel about it if you think about it I

00:44:24,119 --> 00:44:31,710
mean it's just as much as you 3 is deep

00:44:28,290 --> 00:44:34,020
it will go worse animals but it's

00:44:31,710 --> 00:44:36,330
exactly what we think it should be ok no

00:44:34,020 --> 00:44:38,760
surprise there and of course the

00:44:36,330 --> 00:44:41,430
important thing is ok but I would just

00:44:38,760 --> 00:44:42,840
cut on that because I don't really want

00:44:41,430 --> 00:44:45,930
to spend one more we're waiting for the

00:44:42,840 --> 00:44:48,440
completion of course the important thing

00:44:45,930 --> 00:44:53,810
is when you do this

00:44:48,440 --> 00:44:58,670
okay you end up with the end you ask it

00:44:53,810 --> 00:45:02,420
for so this this place where you you go

00:44:58,670 --> 00:45:05,480
from the tree form to the actual

00:45:02,420 --> 00:45:07,040
evaluation of the tree and somehow

00:45:05,480 --> 00:45:09,500
sometimes called what we call a

00:45:07,040 --> 00:45:11,359
compression point it's a point into the

00:45:09,500 --> 00:45:15,130
expression temperate system where you

00:45:11,359 --> 00:45:18,319
stop being lazy and you do some work and

00:45:15,130 --> 00:45:20,000
there we put it there just just on this

00:45:18,319 --> 00:45:23,270
apparent father parents but we can

00:45:20,000 --> 00:45:25,400
actually put it wherever we want okay so

00:45:23,270 --> 00:45:28,609
let's have a look at something else a

00:45:25,400 --> 00:45:33,500
different version of this okay this is

00:45:28,609 --> 00:45:37,760
one yeah this one

00:45:33,500 --> 00:45:41,630
same idea okay same basic code I just

00:45:37,760 --> 00:45:46,849
change a small stuff it's not look at

00:45:41,630 --> 00:45:51,109
line eighty-five I can write u equals D

00:45:46,849 --> 00:45:54,020
times D plus D times D okay I don't even

00:45:51,109 --> 00:45:56,510
call parents anymore I just use the

00:45:54,020 --> 00:46:00,290
assignment operators of course what

00:45:56,510 --> 00:46:04,400
happens let's look at terminal because

00:46:00,290 --> 00:46:07,599
what you is it's a terminal float so

00:46:04,400 --> 00:46:11,930
what this is assignment operators of

00:46:07,599 --> 00:46:14,930
seminar does it is we take a basic spur

00:46:11,930 --> 00:46:15,680
of whatever and we say cool we have a

00:46:14,930 --> 00:46:17,569
bath expert

00:46:15,680 --> 00:46:19,700
I know it's someone who behind it if I

00:46:17,569 --> 00:46:23,480
ever read it so we just ever read it and

00:46:19,700 --> 00:46:27,619
store it into my value so we move the a

00:46:23,480 --> 00:46:29,540
variation from let's just evaluate it to

00:46:27,619 --> 00:46:31,819
an or let's say semantics driven

00:46:29,540 --> 00:46:35,150
evaluation point which is whenever I

00:46:31,819 --> 00:46:35,930
assign another random expression to a

00:46:35,150 --> 00:46:38,690
terminal

00:46:35,930 --> 00:46:41,420
I want the expression to be you know

00:46:38,690 --> 00:46:44,390
condensed evaluated into the value and I

00:46:41,420 --> 00:46:46,700
store it into my terminal that's a

00:46:44,390 --> 00:46:49,010
classic things assignment operators do

00:46:46,700 --> 00:46:51,829
the compression point that what all

00:46:49,010 --> 00:46:54,619
linear algebra expression template base

00:46:51,829 --> 00:46:56,270
library does when you write my matrix it

00:46:54,619 --> 00:46:58,880
calls this huge amount of math

00:46:56,270 --> 00:47:02,180
expression so our same in the bird of

00:46:58,880 --> 00:47:04,310
your matrix class we just do some loops

00:47:02,180 --> 00:47:06,260
and for every point into my matrixes I

00:47:04,310 --> 00:47:08,600
will store the information of your

00:47:06,260 --> 00:47:11,360
expression on the right for every point

00:47:08,600 --> 00:47:13,400
I'm currently computing so you can put

00:47:11,360 --> 00:47:16,910
your compression point wherever you want

00:47:13,400 --> 00:47:20,050
and by wherever you want it actually

00:47:16,910 --> 00:47:23,360
means wherever it makes sense

00:47:20,050 --> 00:47:26,390
semantically into your small languages

00:47:23,360 --> 00:47:27,590
when should I go from the lazy form to

00:47:26,390 --> 00:47:30,260
the compressed forms that give me a

00:47:27,590 --> 00:47:36,230
value and you could actually have

00:47:30,260 --> 00:47:42,680
multiple such compression points okay so

00:47:36,230 --> 00:47:45,860
we have one there okay oh yeah and I did

00:47:42,680 --> 00:47:47,630
this every stuff oh yeah so anyway you

00:47:45,860 --> 00:47:50,570
could actually have this one so what do

00:47:47,630 --> 00:47:55,730
i do there I'm turning my terminal float

00:47:50,570 --> 00:47:59,020
into a natural float so somewhere I need

00:47:55,730 --> 00:48:01,970
to add an operator that say okay I'm

00:47:59,020 --> 00:48:06,320
taking an expression and I'm converting

00:48:01,970 --> 00:48:08,420
it to some value okay so and that's what

00:48:06,320 --> 00:48:10,520
I actually did there it's a bit

00:48:08,420 --> 00:48:16,070
different I put it into the bass expert

00:48:10,520 --> 00:48:18,290
and I gave the bass expert an operator

00:48:16,070 --> 00:48:20,990
of conversion to some types which is

00:48:18,290 --> 00:48:23,330
value type okay when we see how we

00:48:20,990 --> 00:48:24,830
compute value type afterwards and what

00:48:23,330 --> 00:48:27,980
does it do it computes the value of the

00:48:24,830 --> 00:48:30,370
expression so I would just call function

00:48:27,980 --> 00:48:34,190
call operator on my current expression

00:48:30,370 --> 00:48:35,870
yes that's ID yet sorry for that but the

00:48:34,190 --> 00:48:37,580
value type come on

00:48:35,870 --> 00:48:39,800
it depends it depends on what odd

00:48:37,580 --> 00:48:42,140
whatever is stored into the base

00:48:39,800 --> 00:48:43,790
expression private terminal of end I

00:48:42,140 --> 00:48:45,410
should return an end we have a floor

00:48:43,790 --> 00:48:47,000
that should become a table to float and

00:48:45,410 --> 00:48:48,530
if I have an operation that take

00:48:47,000 --> 00:48:50,210
whatever and whatever and return the

00:48:48,530 --> 00:48:52,460
complex of double I should be returning

00:48:50,210 --> 00:48:54,560
this but as the base expert class

00:48:52,460 --> 00:48:58,690
doesn't have any way to know which one

00:48:54,560 --> 00:49:02,660
is it except by asking is derived plus

00:48:58,690 --> 00:49:05,750
so we use this quite early line 9 I'm

00:49:02,660 --> 00:49:09,320
not sure there is something more elegant

00:49:05,750 --> 00:49:13,300
I'm taking opinion afterwards what I do

00:49:09,320 --> 00:49:15,740
is okay let's build let's try to build a

00:49:13,300 --> 00:49:17,510
fake derived and call it

00:49:15,740 --> 00:49:22,220
to parents on it and give me the type of

00:49:17,510 --> 00:49:25,390
that okay and that's probably the type

00:49:22,220 --> 00:49:28,670
of what it should be returning anyway

00:49:25,390 --> 00:49:30,980
okay because by going down all the

00:49:28,670 --> 00:49:33,350
operators function cold calls if we

00:49:30,980 --> 00:49:36,860
finally end up into a place where okay

00:49:33,350 --> 00:49:38,750
that's a float okay I try to write

00:49:36,860 --> 00:49:40,730
something like okay Rachel they called I

00:49:38,750 --> 00:49:42,800
blah blah blah doesn't bode well so

00:49:40,730 --> 00:49:46,460
that's the simplest thing I found about

00:49:42,800 --> 00:49:48,560
I think that better elegant way should

00:49:46,460 --> 00:49:51,350
to should be to add a value type meter

00:49:48,560 --> 00:49:53,420
function externally stored out of Paul's

00:49:51,350 --> 00:49:55,970
expression types and just call it

00:49:53,420 --> 00:49:59,690
whenever I need okay just to doesn't

00:49:55,970 --> 00:50:01,670
have all these kooky stuff but yeah we

00:49:59,690 --> 00:50:03,650
can actually say okay commercial

00:50:01,670 --> 00:50:05,660
operator is also also a compression

00:50:03,650 --> 00:50:09,560
points that's another great classic okay

00:50:05,660 --> 00:50:11,420
and of course I just call that terminal

00:50:09,560 --> 00:50:14,570
you could actually call it viable value

00:50:11,420 --> 00:50:18,640
matrixes whatever okay but that just

00:50:14,570 --> 00:50:23,359
walk okay and now let's compile actually

00:50:18,640 --> 00:50:25,250
should be oh come on no I wanna know

00:50:23,359 --> 00:50:25,760
this one the self combine okay true true

00:50:25,250 --> 00:50:29,690
true

00:50:25,760 --> 00:50:35,840
doesn't work why it doesn't work focus

00:50:29,690 --> 00:50:38,230
that doesn't work why why it's not

00:50:35,840 --> 00:50:38,230
working

00:50:39,070 --> 00:50:47,210
do I have all my information about

00:50:41,990 --> 00:50:50,869
derived when I compile based expert of

00:50:47,210 --> 00:50:52,780
derived if I add this using inside no

00:50:50,869 --> 00:50:54,950
because I'm if I'm building a base

00:50:52,780 --> 00:50:57,680
expert of derived that means I'm

00:50:54,950 --> 00:50:59,630
building a derived and I cannot ask

00:50:57,680 --> 00:51:02,150
what's the freaking type of operators

00:50:59,630 --> 00:51:04,450
parents on derive a is because I still

00:51:02,150 --> 00:51:07,940
doesn't know my type is not complete yet

00:51:04,450 --> 00:51:09,530
okay this works because it doesn't need

00:51:07,940 --> 00:51:12,800
arrived to be complete when you try to

00:51:09,530 --> 00:51:15,920
take a reference to it so that doesn't

00:51:12,800 --> 00:51:18,500
work okay if you want to make this work

00:51:15,920 --> 00:51:21,050
actually I forgot about this can you get

00:51:18,500 --> 00:51:23,359
my cursor back since you probably want

00:51:21,050 --> 00:51:24,930
to have something like like this I'm not

00:51:23,359 --> 00:51:27,140
even sure if we walk

00:51:24,930 --> 00:51:34,290
so you probably want something like

00:51:27,140 --> 00:51:37,620
template blah blah blah and you want

00:51:34,290 --> 00:51:43,050
this you probably want something like

00:51:37,620 --> 00:51:45,240
this okay and what you want to be okay

00:51:43,050 --> 00:51:48,960
and what you probably want to do is

00:51:45,240 --> 00:51:50,880
something like that but do do we really

00:51:48,960 --> 00:51:56,060
think it will be walking we can actually

00:51:50,880 --> 00:51:56,060
pass this I guess that won't work either

00:51:58,310 --> 00:52:05,220
yeah yeah yeah you will start we were

00:52:03,450 --> 00:52:09,900
still trying to instantiate something we

00:52:05,220 --> 00:52:12,780
should not be doing and the one way to

00:52:09,900 --> 00:52:14,070
make it work I think everything to the

00:52:12,780 --> 00:52:17,610
other solution but it's a bit more

00:52:14,070 --> 00:52:19,560
complex you you have to ditch Auto and

00:52:17,610 --> 00:52:21,300
while we're only things the only way to

00:52:19,560 --> 00:52:23,340
make it work is to delays the

00:52:21,300 --> 00:52:26,010
information of these types by using the

00:52:23,340 --> 00:52:27,690
old-school result of protocol that needs

00:52:26,010 --> 00:52:30,660
to be called whenever it does all the

00:52:27,690 --> 00:52:32,850
information okay so well beware of this

00:52:30,660 --> 00:52:34,890
that's one of the limitation of the C

00:52:32,850 --> 00:52:37,470
RTP you cannot do anything into base

00:52:34,890 --> 00:52:39,750
class that requires information about

00:52:37,470 --> 00:52:43,950
the compact type of the device class so

00:52:39,750 --> 00:52:46,530
okay forgot about that just take this

00:52:43,950 --> 00:52:49,140
somewhere else and let's just put it

00:52:46,530 --> 00:52:52,050
into what should I be putting it yeah

00:52:49,140 --> 00:52:54,660
tell me no but putting it in terminal is

00:52:52,050 --> 00:53:01,200
not very useful okay because we know its

00:52:54,660 --> 00:53:06,990
value okay just that dot but what should

00:53:01,200 --> 00:53:09,390
be cool is to be able to call part and

00:53:06,990 --> 00:53:14,100
call these commercial operators on let's

00:53:09,390 --> 00:53:15,900
say float of a plus B okay and like they

00:53:14,100 --> 00:53:18,300
say when you end up with something

00:53:15,900 --> 00:53:22,470
complicated this is left as an exercise

00:53:18,300 --> 00:53:24,420
for the reader okay so try to do this at

00:53:22,470 --> 00:53:25,530
home in which it's not that kruky but

00:53:24,420 --> 00:53:28,760
you have to think about it to be

00:53:25,530 --> 00:53:31,860
differently those that should be working

00:53:28,760 --> 00:53:34,140
yep and of course when you have that you

00:53:31,860 --> 00:53:36,930
can actually well can I actually put it

00:53:34,140 --> 00:53:38,190
somewhere there yeah actually

00:53:36,930 --> 00:53:39,150
well I can

00:53:38,190 --> 00:53:41,550
because I doesn't know the type of

00:53:39,150 --> 00:53:43,020
written type same problem okay so we

00:53:41,550 --> 00:53:47,000
wish we could actually do something like

00:53:43,020 --> 00:53:50,040
this but it's not possible okay so

00:53:47,000 --> 00:53:52,050
that's once one of the limitation of the

00:53:50,040 --> 00:53:54,240
systems okay you are bound to just ask

00:53:52,050 --> 00:53:56,760
for information about the non complete

00:53:54,240 --> 00:53:59,340
type of your derived class but you can

00:53:56,760 --> 00:54:01,470
actually live with this so this notion

00:53:59,340 --> 00:54:03,660
of compression points is very important

00:54:01,470 --> 00:54:06,030
because that's where the magic happens

00:54:03,660 --> 00:54:08,180
okay you want your user to not know

00:54:06,030 --> 00:54:11,460
about your evaluation strategies just

00:54:08,180 --> 00:54:13,290
write something and somewhere I would

00:54:11,460 --> 00:54:15,000
just go from the lazy representation of

00:54:13,290 --> 00:54:31,830
the tree to something that make sense

00:54:15,000 --> 00:54:33,150
sort of okay so that's where we go so as

00:54:31,830 --> 00:54:35,670
we saw that the operational definition

00:54:33,150 --> 00:54:38,010
we just put some tag with an operator

00:54:35,670 --> 00:54:40,100
which has returned whatever it is a

00:54:38,010 --> 00:54:43,620
binary expression with plus and whether

00:54:40,100 --> 00:54:48,150
so what is missing from this what if I

00:54:43,620 --> 00:54:51,680
want to write something like some

00:54:48,150 --> 00:54:54,120
terminal plus some literal like u plus 3

00:54:51,680 --> 00:54:58,350
tree is clearly not something which is a

00:54:54,120 --> 00:55:01,560
base expert well don't have much choice

00:54:58,350 --> 00:55:05,520
you will have to write the two others

00:55:01,560 --> 00:55:08,130
overload of plus one taking random types

00:55:05,520 --> 00:55:10,170
and base expert on the left or basic

00:55:08,130 --> 00:55:13,020
spur and random type on the right okay

00:55:10,170 --> 00:55:15,870
so that's three operator for binary

00:55:13,020 --> 00:55:17,430
operation which means that if you had

00:55:15,870 --> 00:55:20,400
ten every operation that's probably

00:55:17,430 --> 00:55:22,170
seven yes seven and so on and so on to

00:55:20,400 --> 00:55:25,680
power of number of arguments minus one

00:55:22,170 --> 00:55:31,020
okay well should I do something special

00:55:25,680 --> 00:55:32,550
for unary expression no why because the

00:55:31,020 --> 00:55:35,580
only stuff that interests me in unary

00:55:32,550 --> 00:55:39,270
expression is my usual function or

00:55:35,580 --> 00:55:40,800
operators called on one base expert so

00:55:39,270 --> 00:55:43,380
just have one to write for unary

00:55:40,800 --> 00:55:45,630
explanation so we wrote operators you

00:55:43,380 --> 00:55:48,030
can actually wrote a function not seen

00:55:45,630 --> 00:55:50,820
as continuous arctangent copy whatever

00:55:48,030 --> 00:55:51,750
you want and the system is still the

00:55:50,820 --> 00:55:53,670
same you what

00:55:51,750 --> 00:55:55,820
function take some arguments putting

00:55:53,670 --> 00:55:58,860
into the correct box and suppose

00:55:55,820 --> 00:56:00,750
okay and you should have somewhere into

00:55:58,860 --> 00:56:04,890
the box description what should happen

00:56:00,750 --> 00:56:11,850
when I'm coming down this special tree

00:56:04,890 --> 00:56:13,650
Oh perfect timing so just finish on that

00:56:11,850 --> 00:56:18,030
before some question on this part and

00:56:13,650 --> 00:56:21,240
and and then a small break yep

00:56:18,030 --> 00:56:24,330
also limitation is currently if we do

00:56:21,240 --> 00:56:27,360
that what if I want to take the exact

00:56:24,330 --> 00:56:29,190
same code and write something that just

00:56:27,360 --> 00:56:32,370
say hey by the way what I want to do is

00:56:29,190 --> 00:56:33,840
when I call to string I get the string

00:56:32,370 --> 00:56:35,220
containing the exact string

00:56:33,840 --> 00:56:38,310
representation of the tree you just

00:56:35,220 --> 00:56:39,960
wrote well you would take your your

00:56:38,310 --> 00:56:42,930
stuff you know and you're working choose

00:56:39,960 --> 00:56:44,640
and go down every damn based expression

00:56:42,930 --> 00:56:46,800
stuff and add the two string operations

00:56:44,640 --> 00:56:49,680
that do whatever you need and so on and

00:56:46,800 --> 00:56:51,840
so on and then Bob from the other

00:56:49,680 --> 00:56:53,220
departments come and say you all but now

00:56:51,840 --> 00:56:55,230
what I need to do is actually something

00:56:53,220 --> 00:56:58,170
that's saying I'm taking this expression

00:56:55,230 --> 00:56:59,760
of operation on Bibles and I want you to

00:56:58,170 --> 00:57:02,340
compute the derivative of this function

00:56:59,760 --> 00:57:03,870
and then again you write to stuff you

00:57:02,340 --> 00:57:05,970
write everything back into the best

00:57:03,870 --> 00:57:08,340
expert problem is if you just do it this

00:57:05,970 --> 00:57:10,680
way it's fine as long as you have one

00:57:08,340 --> 00:57:13,050
stuff to move around as soon as you have

00:57:10,680 --> 00:57:15,930
multiple evaluation scheme for the same

00:57:13,050 --> 00:57:18,330
tree these systems is actually a bit

00:57:15,930 --> 00:57:21,540
brittle and at least not solid with big

00:57:18,330 --> 00:57:23,520
s means that you don't really want to

00:57:21,540 --> 00:57:25,770
touch the code of the expression

00:57:23,520 --> 00:57:27,600
structure whenever you feel the need to

00:57:25,770 --> 00:57:30,330
write another tree traversal that's

00:57:27,600 --> 00:57:31,920
basic 101 I mean that's what the ester

00:57:30,330 --> 00:57:33,930
does that what you should be doing all

00:57:31,920 --> 00:57:35,640
the time we need to find a way to

00:57:33,930 --> 00:57:38,340
separate the data structures are

00:57:35,640 --> 00:57:42,030
tripping on the tree from the tree

00:57:38,340 --> 00:57:43,980
traversal okay so well we know how to do

00:57:42,030 --> 00:57:45,660
this we can actually have visit or next

00:57:43,980 --> 00:57:47,250
set methods into somewhere and you can

00:57:45,660 --> 00:57:49,520
just implement some kind of visitor

00:57:47,250 --> 00:57:52,440
patterns and probably solve everything

00:57:49,520 --> 00:57:54,120
okay take that same time it this very

00:57:52,440 --> 00:57:56,790
simple example is cool because we only

00:57:54,120 --> 00:57:58,410
do something okay one thing as soon as

00:57:56,790 --> 00:58:00,660
you grow up and you need to do more

00:57:58,410 --> 00:58:01,980
thing with the same tree it starts to be

00:58:00,660 --> 00:58:04,110
a bit cumbersome and you need to have

00:58:01,980 --> 00:58:04,950
something which is more let's say

00:58:04,110 --> 00:58:06,810
flexible

00:58:04,950 --> 00:58:08,460
oh you want to do this and that's what

00:58:06,810 --> 00:58:09,810
would we be seeing and so that's all

00:58:08,460 --> 00:58:12,510
actually Bruce produce some of the

00:58:09,810 --> 00:58:14,190
issues by separating those two now okay

00:58:12,510 --> 00:58:16,589
is there any question on this first part

00:58:14,190 --> 00:58:18,000
is everything clear now on what the

00:58:16,589 --> 00:58:20,130
expression template is supposed to do

00:58:18,000 --> 00:58:24,570
and how it works when you actually build

00:58:20,130 --> 00:58:25,980
it from the ground up any questions so

00:58:24,570 --> 00:58:27,900
is there like kids every every one of

00:58:25,980 --> 00:58:31,670
you or you all understood everything I

00:58:27,900 --> 00:58:45,930
said I hope it's option two any question

00:58:31,670 --> 00:58:49,320
yes oh okay so the question is all do

00:58:45,930 --> 00:58:51,720
ideas or runtime value correctly so what

00:58:49,320 --> 00:58:56,119
happens there so let's take the simplest

00:58:51,720 --> 00:58:56,119
example more than this one this one

00:58:56,599 --> 00:59:04,619
let's put put it it back so what happens

00:59:00,359 --> 00:59:07,349
when I call a parent I'm jumping into

00:59:04,619 --> 00:59:10,349
the a parents of whatever I got from

00:59:07,349 --> 00:59:12,270
this which is probably the parents from

00:59:10,349 --> 00:59:15,660
binary expressions there yep

00:59:12,270 --> 00:59:17,970
and what does value expression operate

00:59:15,660 --> 00:59:20,130
functional brain code does it say okay

00:59:17,970 --> 00:59:23,550
guys I would just call the semi burritos

00:59:20,130 --> 00:59:25,260
on my left and inside okay and whenever

00:59:23,550 --> 00:59:27,770
I got this erection done I would just

00:59:25,260 --> 00:59:31,079
forward it to the function call from up

00:59:27,770 --> 00:59:32,849
so I need to ever act ca parents and CB

00:59:31,079 --> 00:59:36,060
parents to know what's going on so what

00:59:32,849 --> 00:59:38,240
is ca in CB now in cases that's D which

00:59:36,060 --> 00:59:40,770
is a terminal so I jump into the

00:59:38,240 --> 00:59:43,680
operator parent from terminals that just

00:59:40,770 --> 00:59:46,319
gives the value back so CI give me for

00:59:43,680 --> 00:59:49,170
CB give me four and I will just called

00:59:46,319 --> 00:59:52,560
operators function call for four on up

00:59:49,170 --> 00:59:54,480
which happened to be a plus which is I

00:59:52,560 --> 00:59:57,300
don't remember where there and just do a

00:59:54,480 --> 00:59:59,130
plus so it works just because we

00:59:57,300 --> 01:00:00,839
generate this chain of function calls

00:59:59,130 --> 01:00:03,030
and yes when you comply with our

01:00:00,839 --> 01:00:04,440
optimization you get in line actually

01:00:03,030 --> 01:00:07,109
and you count on that for the

01:00:04,440 --> 01:00:08,849
performance of course but yeah it just

01:00:07,109 --> 01:00:11,579
has this repressive code we do whatever

01:00:08,849 --> 01:00:14,680
you want go down the tree up so you get

01:00:11,579 --> 01:00:17,200
terminals and you get back to value okay

01:00:14,680 --> 01:00:20,499
and speaking of inlining this is a very

01:00:17,200 --> 01:00:25,509
important point in this very simple

01:00:20,499 --> 01:00:27,640
example if you look at this I've been

01:00:25,509 --> 01:00:31,359
lazy by just throwing every chilled

01:00:27,640 --> 01:00:33,670
children by value because okay not not

01:00:31,359 --> 01:00:35,380
complexity anything now

01:00:33,670 --> 01:00:37,960
imagine that your Torino is not a single

01:00:35,380 --> 01:00:40,059
int but it's vector containing jag bytes

01:00:37,960 --> 01:00:41,739
of data okay you don't really really

01:00:40,059 --> 01:00:45,190
want to copy it every time you build the

01:00:41,739 --> 01:00:46,660
new nodes into your tree so one thing

01:00:45,190 --> 01:00:48,460
that people usually do when you do that

01:00:46,660 --> 01:00:51,279
they store the sub expression as close

01:00:48,460 --> 01:00:54,640
reference also at reference to concert a

01:00:51,279 --> 01:00:58,299
subtree that's cool but it implies

01:00:54,640 --> 01:01:00,249
something which is very very I'd say I

01:00:58,299 --> 01:01:02,769
mean when you say it is it's obvious but

01:01:00,249 --> 01:01:05,559
people already miss it if you store your

01:01:02,769 --> 01:01:07,539
sub expression by reference that means

01:01:05,559 --> 01:01:11,079
that the lifetime of your big

01:01:07,539 --> 01:01:13,450
expressions is basically limited by the

01:01:11,079 --> 01:01:15,219
statement is built on you doesn't want

01:01:13,450 --> 01:01:18,130
to store it into a not available because

01:01:15,219 --> 01:01:20,469
all she's gone all you have is dealing

01:01:18,130 --> 01:01:22,390
references to temporaries you can cheat

01:01:20,469 --> 01:01:25,569
a bit by storing everything by reference

01:01:22,390 --> 01:01:28,269
to Const and praise gods are the

01:01:25,569 --> 01:01:31,119
lifetime extension kitchens okay but

01:01:28,269 --> 01:01:32,859
it's not safe and it will bite you later

01:01:31,119 --> 01:01:34,239
because you will end up with a burg that

01:01:32,859 --> 01:01:36,640
something's blow up and you doesn't know

01:01:34,239 --> 01:01:38,769
where and the debugging when you build

01:01:36,640 --> 01:01:40,539
into debug just works because the

01:01:38,769 --> 01:01:43,839
Belcher's do all the stuff one by one

01:01:40,539 --> 01:01:46,059
but in release mode it just grew up so

01:01:43,839 --> 01:01:47,799
it's a very complicated issues but we

01:01:46,059 --> 01:01:49,359
see that in problem we start afterwards

01:01:47,799 --> 01:01:51,789
you really really want to store

01:01:49,359 --> 01:01:53,619
everything by value so it's safe but

01:01:51,789 --> 01:01:56,349
sometimes it's not efficient so we need

01:01:53,619 --> 01:01:58,420
to find a way to know how to take this

01:01:56,349 --> 01:02:02,609
decision okay that's for the afterwards

01:01:58,420 --> 01:02:02,609
any other questions yes

01:02:08,980 --> 01:02:19,220
sorry

01:02:10,250 --> 01:02:20,660
Oh actually we did this example is

01:02:19,220 --> 01:02:23,450
actually very simple we just store a

01:02:20,660 --> 01:02:26,060
single you know in a single integer okay

01:02:23,450 --> 01:02:29,960
now let's let's let's imagine what we

01:02:26,060 --> 01:02:31,970
store is vectors okay what will happen

01:02:29,960 --> 01:02:34,340
if you write your operator plus and over

01:02:31,970 --> 01:02:37,040
at times directly using vectors you will

01:02:34,340 --> 01:02:38,810
end up with a code that say let's build

01:02:37,040 --> 01:02:41,270
the temporary vector in which how we

01:02:38,810 --> 01:02:43,130
store the result write the loop fills a

01:02:41,270 --> 01:02:45,230
resort ship back to the resulting

01:02:43,130 --> 01:02:47,240
vectors and when you write D plus D plus

01:02:45,230 --> 01:02:49,400
D perceive as differently here we go

01:02:47,240 --> 01:02:51,710
there and we got one terminal for one

01:02:49,400 --> 01:02:54,950
temporary sorry for every call to the

01:02:51,710 --> 01:02:57,320
prosper aider compilers may see that

01:02:54,950 --> 01:03:00,560
something's cookie remove some but not

01:02:57,320 --> 01:03:02,780
all and you we probably not get out of

01:03:00,560 --> 01:03:04,850
having all those memory allocation them

01:03:02,780 --> 01:03:07,250
what's happens there if I put a vector

01:03:04,850 --> 01:03:09,440
of whatever inside there I won't do

01:03:07,250 --> 01:03:12,650
anything to the plus I just build this

01:03:09,440 --> 01:03:15,170
empty box taking things containing

01:03:12,650 --> 01:03:18,470
reference to something else okay and

01:03:15,170 --> 01:03:22,340
then when I evaluated your expression I

01:03:18,470 --> 01:03:24,560
will build a single temporary vector if

01:03:22,340 --> 01:03:27,320
needed or we probably just resize my

01:03:24,560 --> 01:03:30,080
destination vector and fill the blank

01:03:27,320 --> 01:03:31,490
with the evaluation okay so what we did

01:03:30,080 --> 01:03:34,040
the fact that it doesn't do any

01:03:31,490 --> 01:03:36,320
temporary is that when you look at plus

01:03:34,040 --> 01:03:38,720
times and other function operators they

01:03:36,320 --> 01:03:41,030
don't do the computation it just builds

01:03:38,720 --> 01:03:43,310
this dandling tree of stuff that you get

01:03:41,030 --> 01:03:46,310
average later and when you average it

01:03:43,310 --> 01:03:48,620
later you can say okay there is probably

01:03:46,310 --> 01:03:50,510
multiple array into these things but I

01:03:48,620 --> 01:03:53,270
don't care I know that I would just

01:03:50,510 --> 01:03:57,650
beside myself and asked all of them all

01:03:53,270 --> 01:03:58,940
they are all of this all their value one

01:03:57,650 --> 01:04:00,710
by one and you doesn't have any

01:03:58,940 --> 01:04:02,000
temporary vectors or whatever that's

01:04:00,710 --> 01:04:03,470
that's what happens I should have put

01:04:02,000 --> 01:04:06,560
that into the example actually I would

01:04:03,470 --> 01:04:08,360
do see that a bit later but yeah so you

01:04:06,560 --> 01:04:11,060
say this temporary because who doesn't

01:04:08,360 --> 01:04:13,340
do any computation on the fly you do a

01:04:11,060 --> 01:04:15,650
lazy evaluation of the tree and you give

01:04:13,340 --> 01:04:16,970
first evaluation later when you know

01:04:15,650 --> 01:04:19,730
that you have all you information

01:04:16,970 --> 01:04:21,380
you can kick you can take conscious

01:04:19,730 --> 01:04:23,900
decisions about how many memory you need

01:04:21,380 --> 01:04:27,650
to allocate okay that's that's what's

01:04:23,900 --> 01:04:30,680
going on okay and we make the assumption

01:04:27,650 --> 01:04:33,590
that the temporary expression object are

01:04:30,680 --> 01:04:58,010
usually small and you know non costly to

01:04:33,590 --> 01:05:00,080
copy yes like sorry yep okay so the

01:04:58,010 --> 01:05:01,940
question is can we can we end up with a

01:05:00,080 --> 01:05:05,630
way to actually manipulate the three so

01:05:01,940 --> 01:05:07,670
we can decide what part to average first

01:05:05,630 --> 01:05:10,970
that does it is this okay or also

01:05:07,670 --> 01:05:12,650
decision based on the three when we see

01:05:10,970 --> 01:05:14,300
that in with loose Prado it's actually

01:05:12,650 --> 01:05:15,770
very complicated to write with this kind

01:05:14,300 --> 01:05:17,990
of system because it doesn't have any

01:05:15,770 --> 01:05:19,820
built-in introspection on the structure

01:05:17,990 --> 01:05:21,470
of the tree Yury probably you have to

01:05:19,820 --> 01:05:23,599
write function and make a function that

01:05:21,470 --> 01:05:26,240
we enumerate all the cases you may want

01:05:23,599 --> 01:05:28,130
and decide by calling the correct

01:05:26,240 --> 01:05:29,900
function when we see with Prado is that

01:05:28,130 --> 01:05:31,520
basically you can say okay this is a

01:05:29,900 --> 01:05:34,099
kind of pattern that interests me and

01:05:31,520 --> 01:05:37,130
whenever you meet that do this okay and

01:05:34,099 --> 01:05:38,420
we spraying with this and something some

01:05:37,130 --> 01:05:40,880
of the things that we speak about later

01:05:38,420 --> 01:05:44,119
you can actually all order or offspring

01:05:40,880 --> 01:05:45,800
the way you want to makes of a relation

01:05:44,119 --> 01:05:47,780
that but you need something more

01:05:45,800 --> 01:05:50,960
powerful than just a bunch of CRT P with

01:05:47,780 --> 01:05:52,480
simple simple classes but yes that's at

01:05:50,960 --> 01:05:56,599
one of the motivation of booze problem

01:05:52,480 --> 01:05:58,910
okay so let's have a break and if you

01:05:56,599 --> 01:06:03,070
still want to hear about me so came back

01:05:58,910 --> 01:06:03,070

YouTube URL: https://www.youtube.com/watch?v=IiVl5oSU5B8


