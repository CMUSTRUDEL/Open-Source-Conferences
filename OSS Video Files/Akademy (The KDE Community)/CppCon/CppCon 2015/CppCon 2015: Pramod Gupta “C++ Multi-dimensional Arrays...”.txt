Title: CppCon 2015: Pramod Gupta “C++ Multi-dimensional Arrays...”
Publication date: 2015-10-08
Playlist: CppCon 2015
Description: 
	“C++ Multi-dimensional Arrays for Computational Physics and Applied Mathematics”

http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
The language feature of passing a multi-dimensional array to a function without specifying all its dimensions at compile time is crucial for computational physics and applied mathematics. For example a matrix is a two dimensional array and a matrix inversion function which needs to know the size of the matrix at compile time would be of limited use. Major general purpose languages such as C, Java and C# support this feature. Of course, scientific programming languages like Fortran, Matlab and R also support this feature.

C++ is perhaps the only major programming language which does not allow passing a multi-dimensional array to a function unless the size of all the dimensions except the first one is known at compile time. Due to this limitation of C++, various libraries have been developed for using multi-dimensional arrays in C++. Some of these libraries are Blitz++, Armadillo, Eigen and boost.multi_array. These libraries are very large and complex. While they do provide a wide variety of features, they have a learning curve which may be difficult to justify for something as basic as passing multi-dimensional arrays to functions. Also the computational physics or applied mathematics code becomes dependent on a large non-standard library. Hence its usage will be limited to only those scientists who are willing to install these non-standard libraries.

The reference feature of C++ allows us to develop a multi-dimensional array class. The class has a small number of lines of code and hence the code can be included with the scientific application code. We use this class to write programs for various areas of computational physics and show that the class is easy to use and it leads to readable programs.
— 
Pramod Gupta is a research scientist at the Department of Astronomy at
the University of Washington. He works on computational astrophysics using C++ and other languages. He is interested in parallel computing and he has used both the established techniques such as MPI and OpenMP and the newer techniques such as Hadoop and CUDA/GPU. He has taught a graduate course on astrophysics. He holds several United States patents. He has presented papers at APS(American Physical Society), AAS(American Astronomical Society), ACM and IEEE conferences. He obtained his Ph.D. in computational physics from the University of Rochester in New York.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:03,360
I'm a research scientist at the

00:00:01,319 --> 00:00:06,420
University of Washington and in the

00:00:03,360 --> 00:00:08,760
Department of astronomy and what I want

00:00:06,420 --> 00:00:13,799
to do here is quickly just show you the

00:00:08,760 --> 00:00:18,529
kind of things we do with C++ so this is

00:00:13,799 --> 00:00:21,300
from a C++ program it's a simulation of

00:00:18,529 --> 00:00:25,289
a protoplanetary disk so right in the

00:00:21,300 --> 00:00:27,390
center there's a star and there's this

00:00:25,289 --> 00:00:29,849
gas spinning around it and we kind of

00:00:27,390 --> 00:00:32,460
try to see how planets form so something

00:00:29,849 --> 00:00:34,350
like this happened few billion years ago

00:00:32,460 --> 00:00:36,329
with the with the solar system and the

00:00:34,350 --> 00:00:38,100
bright spots are where there is more

00:00:36,329 --> 00:00:39,180
matter so you can kind of see finally

00:00:38,100 --> 00:00:41,700
you know it starts off sort of

00:00:39,180 --> 00:00:46,320
homogeneous and it becomes sort of you

00:00:41,700 --> 00:00:48,450
know sort of planets are being formed as

00:00:46,320 --> 00:00:53,329
time goes on so these are kind of some

00:00:48,450 --> 00:00:53,329
of the things that we do with C++ and

00:00:54,020 --> 00:00:59,460
what I would like to talk today is about

00:00:57,230 --> 00:01:07,350
multi-dimensional arrays which are kind

00:00:59,460 --> 00:01:11,400
of critical to that type of simulation

00:01:07,350 --> 00:01:16,110
that we do and one of the things so so

00:01:11,400 --> 00:01:20,880
we use C++ because it's easy to learn

00:01:16,110 --> 00:01:22,979
and easy to use but actually it's

00:01:20,880 --> 00:01:25,140
because it's resource constrained yeah

00:01:22,979 --> 00:01:28,110
so that's one of the use cases for C++

00:01:25,140 --> 00:01:31,110
if you are resource constrained and you

00:01:28,110 --> 00:01:33,810
know you are concerned about time and

00:01:31,110 --> 00:01:36,960
memory and so on so then the language to

00:01:33,810 --> 00:01:39,780
use is essentially if you know Fortran C

00:01:36,960 --> 00:01:41,369
or C++ as I tell my students the more

00:01:39,780 --> 00:01:43,320
expensive the computer that you're

00:01:41,369 --> 00:01:46,320
running your code on the older is the

00:01:43,320 --> 00:01:48,689
language which they use on it so the

00:01:46,320 --> 00:01:53,820
most expensive computers you know tend

00:01:48,689 --> 00:01:56,759
to run C C++ or Fortran and this is sort

00:01:53,820 --> 00:01:59,189
of a generic thing because time is

00:01:56,759 --> 00:02:00,570
critical and memory is critical and so

00:01:59,189 --> 00:02:02,869
on and so usually I'm climbing the

00:02:00,570 --> 00:02:05,219
mountain on the on the left hand side

00:02:02,869 --> 00:02:08,069
but sometimes I do climb the mountain on

00:02:05,219 --> 00:02:09,860
the right hand side and you know I don't

00:02:08,069 --> 00:02:12,380
know if the book authors choose these

00:02:09,860 --> 00:02:14,840
front covers or the

00:02:12,380 --> 00:02:16,280
or the or the you know the publish

00:02:14,840 --> 00:02:21,380
excuse its but they are appropriate to

00:02:16,280 --> 00:02:23,570
the topic that these books contain okay

00:02:21,380 --> 00:02:27,530
so multi-dimensional arrays in C++ so

00:02:23,570 --> 00:02:29,210
what's the big deal now in lot of

00:02:27,530 --> 00:02:30,680
systems programming you don't really see

00:02:29,210 --> 00:02:34,420
multi-dimensional array is like you know

00:02:30,680 --> 00:02:37,430
like one dimension is big enough and so

00:02:34,420 --> 00:02:42,620
C and C++ have tended to kind of focus

00:02:37,430 --> 00:02:43,790
on on that and in physics and applied

00:02:42,620 --> 00:02:45,200
math and many of the scientific

00:02:43,790 --> 00:02:47,090
computing field it's very common to a

00:02:45,200 --> 00:02:49,100
multi dimensional arrays three four

00:02:47,090 --> 00:02:51,170
three two and three are very common and

00:02:49,100 --> 00:02:52,730
you even have higher ones you know we

00:02:51,170 --> 00:02:55,790
are in three space dimensions and one

00:02:52,730 --> 00:02:57,170
time dimension so so things like this

00:02:55,790 --> 00:02:59,240
like you know like the temperature field

00:02:57,170 --> 00:03:00,560
at a point you have a grid of point and

00:02:59,240 --> 00:03:06,530
then you have the temperature at each a

00:03:00,560 --> 00:03:08,120
point spin model on on 3d lattice in

00:03:06,530 --> 00:03:09,950
fluid dynamics three components of the

00:03:08,120 --> 00:03:12,860
velocity at a point in a fluid so these

00:03:09,950 --> 00:03:14,660
are very common and so passing

00:03:12,860 --> 00:03:17,540
multi-dimensional arrays to functions is

00:03:14,660 --> 00:03:20,210
very critical for computational physics

00:03:17,540 --> 00:03:23,480
applied math and scientific computing in

00:03:20,210 --> 00:03:26,360
general and you know in linear algebra a

00:03:23,480 --> 00:03:28,040
matrix is a two-dimensional array and a

00:03:26,360 --> 00:03:30,920
matrix inversion function which needs to

00:03:28,040 --> 00:03:32,750
notice each of the size of of the

00:03:30,920 --> 00:03:35,830
dimension would be like you know at

00:03:32,750 --> 00:03:38,450
compile time would be of limited use

00:03:35,830 --> 00:03:40,490
now other languages have supported this

00:03:38,450 --> 00:03:43,720
feature for decades so it's not exactly

00:03:40,490 --> 00:03:47,690
you know some kind of brand new

00:03:43,720 --> 00:03:48,830
cutting-edge feature so see 99 Java C

00:03:47,690 --> 00:03:51,890
sharp so even the general-purpose

00:03:48,830 --> 00:03:53,900
languages support this for you know over

00:03:51,890 --> 00:03:56,890
15 years and scientific programming

00:03:53,900 --> 00:03:59,150
languages like Fortran MATLAB and are

00:03:56,890 --> 00:04:00,440
they have supported this obviously for

00:03:59,150 --> 00:04:02,810
decades like you know like Fortran I

00:04:00,440 --> 00:04:06,620
supported this for like 50 years so

00:04:02,810 --> 00:04:09,740
there's no real you know unknown aspects

00:04:06,620 --> 00:04:11,390
of this feature but C++ is the only

00:04:09,740 --> 00:04:13,850
major programming language which does

00:04:11,390 --> 00:04:17,720
not support this feature and the absence

00:04:13,850 --> 00:04:20,359
of this feature increases the barrier to

00:04:17,720 --> 00:04:22,610
moving from C X they try to C++ and for

00:04:20,359 --> 00:04:25,820
small teams and grad students it limits

00:04:22,610 --> 00:04:27,160
their usage of C++ because

00:04:25,820 --> 00:04:31,340
you know when they're just beginning to

00:04:27,160 --> 00:04:33,020
program they would like this basic

00:04:31,340 --> 00:04:36,080
feature if they're doing scientific

00:04:33,020 --> 00:04:38,420
computing now this does not mean that

00:04:36,080 --> 00:04:41,230
C++ is not used in scientific computing

00:04:38,420 --> 00:04:44,540
in fact it's used in a lot of places

00:04:41,230 --> 00:04:46,430
usually it's the very big organizations

00:04:44,540 --> 00:04:49,910
like Sir

00:04:46,430 --> 00:04:52,310
Jet Propulsion lab LSST large-scale

00:04:49,910 --> 00:04:54,920
synoptic telescope they were big a group

00:04:52,310 --> 00:04:56,420
here at the unity of Washington LMB the

00:04:54,920 --> 00:04:58,040
lab for molecular biology in Cambridge

00:04:56,420 --> 00:05:00,230
which is I don't know if you know about

00:04:58,040 --> 00:05:01,520
it but it's sort of called like the

00:05:00,230 --> 00:05:04,370
Nobel Prize Factory they were like

00:05:01,520 --> 00:05:08,180
dozens of them and so these very large

00:05:04,370 --> 00:05:10,130
organizations tend to use C++ and if C++

00:05:08,180 --> 00:05:12,050
is used for scientific computing one of

00:05:10,130 --> 00:05:15,110
the first tasks is to make a class for

00:05:12,050 --> 00:05:15,980
multi-dimensional arrays and and so if

00:05:15,110 --> 00:05:18,500
you have one of these really big

00:05:15,980 --> 00:05:20,920
organizations like if you're really big

00:05:18,500 --> 00:05:24,200
like some of JPL you can actually get

00:05:20,920 --> 00:05:26,930
dr. Strauss trip himself to help you out

00:05:24,200 --> 00:05:28,220
with your C++ and you know he's actively

00:05:26,930 --> 00:05:29,810
involved with these really big

00:05:28,220 --> 00:05:31,310
organizations and if you're doing

00:05:29,810 --> 00:05:34,280
something which is really small scale

00:05:31,310 --> 00:05:35,270
then maybe you don't need you know you

00:05:34,280 --> 00:05:37,670
don't have the kind of resource

00:05:35,270 --> 00:05:38,900
constraints of C++ but if you have

00:05:37,670 --> 00:05:41,390
something in the middle kind of like you

00:05:38,900 --> 00:05:44,210
know as the it's often said like the

00:05:41,390 --> 00:05:46,340
middle class you know so if you are in

00:05:44,210 --> 00:05:48,860
that regime then you kind of like you

00:05:46,340 --> 00:05:50,270
know would like certain more it'd be

00:05:48,860 --> 00:05:51,590
preferable to have certain features sort

00:05:50,270 --> 00:05:55,700
of feature already inbuilt in the

00:05:51,590 --> 00:05:57,140
language so that you can not have to

00:05:55,700 --> 00:06:02,030
create your own multi-dimensional array

00:05:57,140 --> 00:06:04,220
class so all these organization like

00:06:02,030 --> 00:06:06,290
LSST code for astronomical I encode for

00:06:04,220 --> 00:06:08,090
cryo-electron microscopy they make their

00:06:06,290 --> 00:06:09,680
own multi-dimensional array classes and

00:06:08,090 --> 00:06:12,170
it's sort of reinventing the wheel over

00:06:09,680 --> 00:06:14,480
and over again so since I'm from the

00:06:12,170 --> 00:06:17,120
Astronomy Department here the picture of

00:06:14,480 --> 00:06:21,310
telescope under construction in Chile

00:06:17,120 --> 00:06:23,450
and you know you can get the size of the

00:06:21,310 --> 00:06:24,650
whole building and the telescope from

00:06:23,450 --> 00:06:26,990
the size of the pickup truck

00:06:24,650 --> 00:06:29,330
so you that gives you a scale of what

00:06:26,990 --> 00:06:30,710
it's all about and if we talk about the

00:06:29,330 --> 00:06:33,020
very big we should talk about the very

00:06:30,710 --> 00:06:35,810
little and this is something from

00:06:33,020 --> 00:06:38,530
cryo-electron microscopy where they use

00:06:35,810 --> 00:06:40,040
two-dimensional images of

00:06:38,530 --> 00:06:41,930
two-dimensional electron

00:06:40,040 --> 00:06:43,160
images from different directions to

00:06:41,930 --> 00:06:45,620
reconstruct the structure of the

00:06:43,160 --> 00:06:48,440
molecule or the virus and so the output

00:06:45,620 --> 00:06:51,260
of all these projects is a huge amount

00:06:48,440 --> 00:06:54,430
of data which is then processed with C++

00:06:51,260 --> 00:06:58,880
so so it's being used in a lot of field

00:06:54,430 --> 00:07:03,790
fields so what exactly is our concern

00:06:58,880 --> 00:07:07,550
here the point is that this code is

00:07:03,790 --> 00:07:11,060
valid c99 but it's not valid C++ so

00:07:07,550 --> 00:07:15,470
essentially if you have this array in

00:07:11,060 --> 00:07:17,720
red being passed to a function in C++

00:07:15,470 --> 00:07:20,720
you need to know N and M at compile time

00:07:17,720 --> 00:07:22,370
and in C you don't need to do that and

00:07:20,720 --> 00:07:27,530
certainly in the other languages you

00:07:22,370 --> 00:07:29,000
don't need to do that so this is sort of

00:07:27,530 --> 00:07:31,220
the you know limitation which

00:07:29,000 --> 00:07:32,960
essentially ensures that the first time

00:07:31,220 --> 00:07:34,790
you start using C++ for scientific

00:07:32,960 --> 00:07:36,260
computing you need to make your own

00:07:34,790 --> 00:07:38,540
multi-dimensional array class or you

00:07:36,260 --> 00:07:41,950
need to like you know get some standard

00:07:38,540 --> 00:07:47,030
some non-standard library from somewhere

00:07:41,950 --> 00:07:48,530
now this is valid C 99 and C++ so if so

00:07:47,030 --> 00:07:52,520
you can leave the first dimension of the

00:07:48,530 --> 00:07:54,410
array B unknown at compile time but the

00:07:52,520 --> 00:07:56,660
second and all the later dimensions have

00:07:54,410 --> 00:08:00,740
to be known at compile time and that

00:07:56,660 --> 00:08:02,540
sort of is you know a bit problematic if

00:08:00,740 --> 00:08:04,810
you are constrained all the time so that

00:08:02,540 --> 00:08:08,060
code is correct only if M is equal to 3

00:08:04,810 --> 00:08:11,780
so you need like you know different code

00:08:08,060 --> 00:08:13,160
each time you have a different M now C

00:08:11,780 --> 00:08:17,420
is this feature called variable-length

00:08:13,160 --> 00:08:20,060
arrays and C variable-length arrays this

00:08:17,420 --> 00:08:22,880
is from C 99 so C variable-length arrays

00:08:20,060 --> 00:08:25,160
are not allowed by a compiler for c++

00:08:22,880 --> 00:08:27,050
even though the same compiler supports

00:08:25,160 --> 00:08:29,060
them for C which is kind of you know so

00:08:27,050 --> 00:08:31,130
they're actively the compiler says no if

00:08:29,060 --> 00:08:32,570
you have a dot CPP file I'm not going to

00:08:31,130 --> 00:08:34,610
allow you to do this even though I know

00:08:32,570 --> 00:08:39,770
how to do this but if your file is dot

00:08:34,610 --> 00:08:43,070
CPP you know no can do and you know GCC

00:08:39,770 --> 00:08:44,270
clang ICC so these are all the compilers

00:08:43,070 --> 00:08:45,500
you know I mean so it's it's basically

00:08:44,270 --> 00:08:47,870
really enforced here they are being

00:08:45,500 --> 00:08:49,880
really strict about it they can give you

00:08:47,870 --> 00:08:51,010
different types of extensions but you

00:08:49,880 --> 00:08:54,020
know they're not going to allow you to

00:08:51,010 --> 00:08:56,380
use VLA even though they

00:08:54,020 --> 00:08:59,030
have the ability to allow you to do that

00:08:56,380 --> 00:09:01,490
now see variable-length arrays are more

00:08:59,030 --> 00:09:03,680
general than needed for just merely

00:09:01,490 --> 00:09:08,050
passing multi-dimensional arrays to

00:09:03,680 --> 00:09:12,050
functions like this is valid c99 but not

00:09:08,050 --> 00:09:14,990
valid C++ and you know what you're doing

00:09:12,050 --> 00:09:16,790
is essentially you're doing a you know

00:09:14,990 --> 00:09:18,560
you can call it a malloc or a new within

00:09:16,790 --> 00:09:21,020
that function so you just got N and M

00:09:18,560 --> 00:09:22,640
from the as function parameters but

00:09:21,020 --> 00:09:25,340
inside it you're allocating space and

00:09:22,640 --> 00:09:27,920
this actually is you know the argument

00:09:25,340 --> 00:09:31,160
against VLA that if N and M are large

00:09:27,920 --> 00:09:33,320
enough then you can you know that code

00:09:31,160 --> 00:09:36,260
can crash without throwing exception or

00:09:33,320 --> 00:09:39,410
returning error code etc and at this one

00:09:36,260 --> 00:09:41,870
of the main arguments but you know that

00:09:39,410 --> 00:09:45,620
argument does not hold just for passing

00:09:41,870 --> 00:09:48,740
arrays to functions because that memory

00:09:45,620 --> 00:09:51,530
has been allocated somewhere else

00:09:48,740 --> 00:09:53,990
so the aside if a future C++ standard

00:09:51,530 --> 00:09:56,080
allowed the above subset of VLA it would

00:09:53,990 --> 00:10:01,190
really reduce the barrier in moving from

00:09:56,080 --> 00:10:03,410
other languages like C to C++ so how

00:10:01,190 --> 00:10:06,170
about the C++ standard library now this

00:10:03,410 --> 00:10:09,200
is a direct quote from the boost multi

00:10:06,170 --> 00:10:10,760
array manual and so they say there's you

00:10:09,200 --> 00:10:12,410
know lots of generic containers in the

00:10:10,760 --> 00:10:14,990
standard library but no

00:10:12,410 --> 00:10:16,480
multi-dimensional array type and then

00:10:14,990 --> 00:10:19,640
they say you can use standard vector

00:10:16,480 --> 00:10:20,900
standard vector double etcetera but they

00:10:19,640 --> 00:10:23,240
themselves say that the resulting

00:10:20,900 --> 00:10:30,560
interface is unwieldy and the memory

00:10:23,240 --> 00:10:32,390
overhead is quite high so you know lots

00:10:30,560 --> 00:10:35,900
of non-standard libraries have been made

00:10:32,390 --> 00:10:37,160
to tackle this issue certainly all these

00:10:35,900 --> 00:10:38,330
various projects I talk to you about

00:10:37,160 --> 00:10:39,770
they have their own you know

00:10:38,330 --> 00:10:44,290
multi-dimensional array classes which

00:10:39,770 --> 00:10:46,790
are tightly knit with their own code and

00:10:44,290 --> 00:10:50,690
these are some of the public lis

00:10:46,790 --> 00:10:53,930
available standard libraries which is

00:10:50,690 --> 00:10:55,910
Armadillo eigen bits plus plus boost dot

00:10:53,930 --> 00:10:58,400
multi array so they have lots of feature

00:10:55,910 --> 00:11:00,440
very large very complex they are good

00:10:58,400 --> 00:11:02,750
for linear algebra you know matrix

00:11:00,440 --> 00:11:04,220
algebra two-dimensional things in many

00:11:02,750 --> 00:11:07,310
cases they're really good they're

00:11:04,220 --> 00:11:07,880
optimized for that so this library is

00:11:07,310 --> 00:11:10,850
from Austria

00:11:07,880 --> 00:11:15,400
and it has its focuses only on 2d arrays

00:11:10,850 --> 00:11:18,200
and 3d arrays which is kind of limiting

00:11:15,400 --> 00:11:20,780
many times and this one focuses only on

00:11:18,200 --> 00:11:22,760
2d arrays this from France and it's also

00:11:20,780 --> 00:11:24,050
basically focused on linear algebra so

00:11:22,760 --> 00:11:26,180
this is you know very strongly focused

00:11:24,050 --> 00:11:29,780
on linear algebra eigenvalue finding and

00:11:26,180 --> 00:11:33,770
things like that this one is interesting

00:11:29,780 --> 00:11:35,570
it splits plus plus and it has very

00:11:33,770 --> 00:11:40,540
large and very complex in fact it was

00:11:35,570 --> 00:11:43,100
100 page manual and up to 11 dimensions

00:11:40,540 --> 00:11:46,430
are supported which is fine for most

00:11:43,100 --> 00:11:48,740
physics and applied math and scientific

00:11:46,430 --> 00:11:49,940
computing applications but it's really

00:11:48,740 --> 00:11:52,520
large you know it I mean it allows you

00:11:49,940 --> 00:11:55,670
to like we'll come to it later but

00:11:52,520 --> 00:11:57,290
there's a grow major and you know a

00:11:55,670 --> 00:12:00,230
column major way of addressing these

00:11:57,290 --> 00:12:01,970
arrays and this one allows you to do all

00:12:00,230 --> 00:12:04,100
the n factorial different ways you can

00:12:01,970 --> 00:12:08,120
access it so it has a huge amount of

00:12:04,100 --> 00:12:11,170
generality but you know if you just want

00:12:08,120 --> 00:12:15,920
the basic multi-dimensional array class

00:12:11,170 --> 00:12:18,320
it's a bit too large and then there's

00:12:15,920 --> 00:12:20,990
Boost dot Multi array which is actually

00:12:18,320 --> 00:12:24,200
inspired by Blitz plus plus so it also

00:12:20,990 --> 00:12:26,230
has lots of features and and it has a

00:12:24,200 --> 00:12:29,630
relatively so it has all the you know

00:12:26,230 --> 00:12:32,590
aspects of Blitz plus plus but it has a

00:12:29,630 --> 00:12:35,120
very it also has a complicated syntax so

00:12:32,590 --> 00:12:36,470
well at least from you know scientific

00:12:35,120 --> 00:12:40,340
computing point of view compared to

00:12:36,470 --> 00:12:42,320
other languages so if you look at this

00:12:40,340 --> 00:12:44,840
code here they're already three classes

00:12:42,320 --> 00:12:48,110
three types of objects that you need you

00:12:44,840 --> 00:12:52,400
you need the array itself the first type

00:12:48,110 --> 00:12:55,580
def then you need index and then you

00:12:52,400 --> 00:12:58,220
know you need extends and so even though

00:12:55,580 --> 00:13:01,100
the code the triple loop there looks

00:12:58,220 --> 00:13:05,270
kind of familiar it's i JK are not you

00:13:01,100 --> 00:13:09,080
know the traditional integers but they

00:13:05,270 --> 00:13:14,570
really index objects of the index class

00:13:09,080 --> 00:13:17,960
and so the drawbacks of the existing

00:13:14,570 --> 00:13:19,730
library is for a lot of code in

00:13:17,960 --> 00:13:22,100
scientific computing is that they're

00:13:19,730 --> 00:13:24,200
very large and complex so

00:13:22,100 --> 00:13:25,670
you know you need to your core become

00:13:24,200 --> 00:13:29,060
dependent on a large non-standard

00:13:25,670 --> 00:13:31,430
library and you know with hundred page

00:13:29,060 --> 00:13:33,290
manuals and so on and so the usage of

00:13:31,430 --> 00:13:36,140
the library is limited to those who are

00:13:33,290 --> 00:13:38,120
willing to install it and learn from it

00:13:36,140 --> 00:13:40,370
and in some cases the libraries may not

00:13:38,120 --> 00:13:43,130
be actively maintained but they are so

00:13:40,370 --> 00:13:44,360
complicated that you'd have to spend a

00:13:43,130 --> 00:13:47,660
lot of time if you really wanted to

00:13:44,360 --> 00:13:50,600
maintain them yourself so I wrote a

00:13:47,660 --> 00:13:52,370
library based on what is available in

00:13:50,600 --> 00:13:54,290
you know commonly available in lots of

00:13:52,370 --> 00:13:56,150
these other languages like C and Fortran

00:13:54,290 --> 00:14:01,070
and so on and the idea was to have a

00:13:56,150 --> 00:14:02,180
minimal minimalistic library so you know

00:14:01,070 --> 00:14:03,440
it should have at least the features

00:14:02,180 --> 00:14:05,540
what native arrays have in other

00:14:03,440 --> 00:14:07,760
languages and it should fill the gap

00:14:05,540 --> 00:14:10,730
between C++ arrays which are very very

00:14:07,760 --> 00:14:13,400
limited and you know these huge large

00:14:10,730 --> 00:14:15,590
libraries and it should be convenient to

00:14:13,400 --> 00:14:18,830
include with applications the code

00:14:15,590 --> 00:14:20,780
should be you know readable code so the

00:14:18,830 --> 00:14:21,800
user can convince himself that it's

00:14:20,780 --> 00:14:24,560
correct like the previous speaker

00:14:21,800 --> 00:14:26,420
pointed out he looked at some header

00:14:24,560 --> 00:14:28,040
files and you know it works very

00:14:26,420 --> 00:14:30,200
complicated even if they're doing

00:14:28,040 --> 00:14:34,870
ordinary things and so if you are going

00:14:30,200 --> 00:14:36,890
to use that type of code it's bit

00:14:34,870 --> 00:14:40,250
problematic if you have to actually

00:14:36,890 --> 00:14:43,880
debug anything and the efficiency should

00:14:40,250 --> 00:14:45,890
be similar to native arrays in C++ and

00:14:43,880 --> 00:14:48,170
it should be easy to debug array index

00:14:45,890 --> 00:14:52,790
out of bounds because that is a very

00:14:48,170 --> 00:14:58,670
common problem one you know we know from

00:14:52,790 --> 00:15:00,020
experience so the choices are that it

00:14:58,670 --> 00:15:01,190
should be easy to declare and use the

00:15:00,020 --> 00:15:02,810
array you should not have to look at a

00:15:01,190 --> 00:15:06,020
manual I mean you don't need to look at

00:15:02,810 --> 00:15:07,400
a manual in these other languages and it

00:15:06,020 --> 00:15:09,470
should be convenient to include so

00:15:07,400 --> 00:15:11,960
single header or file should be enough

00:15:09,470 --> 00:15:13,370
it should be efficient because you know

00:15:11,960 --> 00:15:15,160
if it's not efficient it's not going to

00:15:13,370 --> 00:15:17,690
be able to compete on those you know

00:15:15,160 --> 00:15:19,820
enormous machines 10,000 core machines

00:15:17,690 --> 00:15:22,430
it's as I said like you know all these

00:15:19,820 --> 00:15:24,260
machines use huge amount of power and so

00:15:22,430 --> 00:15:26,630
we are going to do a computation which

00:15:24,260 --> 00:15:29,210
is going to use a lot of power you want

00:15:26,630 --> 00:15:32,000
it to be efficient so it's not just a

00:15:29,210 --> 00:15:33,770
time issue it's a power issue you'd like

00:15:32,000 --> 00:15:35,059
compile time option to turn on array

00:15:33,770 --> 00:15:37,099
bounds checking

00:15:35,059 --> 00:15:41,689
and a compiled up option for C order or

00:15:37,099 --> 00:15:45,139
Fortran order so these are the design

00:15:41,689 --> 00:15:46,459
choices that I made so I would like to

00:15:45,139 --> 00:15:48,829
prohibit the copy constructor and

00:15:46,459 --> 00:15:51,559
assignment operator so the semantics are

00:15:48,829 --> 00:15:54,469
similar to C++ native arrays and this

00:15:51,559 --> 00:15:56,569
you know removes the problem of people

00:15:54,469 --> 00:15:57,739
passing arrays you know like a thousand

00:15:56,569 --> 00:16:00,309
by thousand or a million by million

00:15:57,739 --> 00:16:02,659
array and you know complaining it's slow

00:16:00,309 --> 00:16:05,329
so you must pass multi-dimensional

00:16:02,659 --> 00:16:07,339
arrays by reference there's a member

00:16:05,329 --> 00:16:09,589
function at for subscripting instead of

00:16:07,339 --> 00:16:12,469
overloading operator the subscripting

00:16:09,589 --> 00:16:14,599
operator if array bounds checking is on

00:16:12,469 --> 00:16:16,389
you have a segmentation fault on error

00:16:14,599 --> 00:16:19,939
and then you can find that you know

00:16:16,389 --> 00:16:22,369
problematic line in your debugger so it

00:16:19,939 --> 00:16:23,659
makes it easy to debug and there's no

00:16:22,369 --> 00:16:25,459
default constructor since

00:16:23,659 --> 00:16:27,109
multi-dimensional array without size

00:16:25,459 --> 00:16:28,369
specified for each dimension has no

00:16:27,109 --> 00:16:29,779
meaning so if you really need an array

00:16:28,369 --> 00:16:31,549
of arrays you should use a higher

00:16:29,779 --> 00:16:33,829
dimensional array and not you know

00:16:31,549 --> 00:16:35,959
complicate things and then there's no

00:16:33,829 --> 00:16:38,539
virtual member functions cos is not

00:16:35,959 --> 00:16:40,369
designed for inheritance you know it's

00:16:38,539 --> 00:16:43,129
supposed to be like used as is you can

00:16:40,369 --> 00:16:44,359
use in you can use composition if you

00:16:43,129 --> 00:16:48,199
want to use the array and do some you

00:16:44,359 --> 00:16:52,279
know other fancy tricks put that in your

00:16:48,199 --> 00:16:54,019
class and then do what you want the

00:16:52,279 --> 00:16:58,129
maximum number of dimension is 7

00:16:54,019 --> 00:16:59,839
essentially because higher dimension

00:16:58,129 --> 00:17:02,389
arrays are extremely rare the memory

00:16:59,839 --> 00:17:05,209
usage increases very rapidly so a lot of

00:17:02,389 --> 00:17:06,319
these other array classes with well some

00:17:05,209 --> 00:17:08,449
of them where they allow you to have

00:17:06,319 --> 00:17:09,889
arbitrary number of dimensions it's

00:17:08,449 --> 00:17:12,049
really only of theoretical importance

00:17:09,889 --> 00:17:15,019
because beyond a few dimensions your

00:17:12,049 --> 00:17:17,299
memory usage increases rapidly but it's

00:17:15,019 --> 00:17:19,419
easy to modify the code if you want to

00:17:17,299 --> 00:17:23,269
like have like you know array 8d etc

00:17:19,419 --> 00:17:24,919
this is the user manual really it could

00:17:23,269 --> 00:17:28,389
be put on one page but I'm using a big

00:17:24,919 --> 00:17:32,090
font and you know you declare array

00:17:28,389 --> 00:17:35,600
array to d-double you know the sizes you

00:17:32,090 --> 00:17:39,220
use it by B dot at 3 comma 4 is 3.14 and

00:17:35,600 --> 00:17:40,970
you can send it into a function just by

00:17:39,220 --> 00:17:42,950
reference and and you know it's

00:17:40,970 --> 00:17:44,899
prohibited there's no copy constructor

00:17:42,950 --> 00:17:46,369
so you're not going to make you know the

00:17:44,899 --> 00:17:48,350
users even if they are new they are not

00:17:46,369 --> 00:17:50,720
going to make a mistake of

00:17:48,350 --> 00:17:53,600
you know using the copy constructor here

00:17:50,720 --> 00:17:55,789
so and you have two options at

00:17:53,600 --> 00:17:56,840
compile-time a bounced check which you

00:17:55,789 --> 00:17:58,730
can you know so when you're debugging

00:17:56,840 --> 00:18:01,100
and testing your program it'll help you

00:17:58,730 --> 00:18:04,850
to find your bugs and you can use the

00:18:01,100 --> 00:18:06,350
Fortran order or the or the C order so I

00:18:04,850 --> 00:18:08,980
like to call them Fortran order which is

00:18:06,350 --> 00:18:12,070
first index moves changes fastest and

00:18:08,980 --> 00:18:15,410
the C order where the last index changes

00:18:12,070 --> 00:18:19,549
most rapidly you know the official names

00:18:15,410 --> 00:18:24,770
are column major and row major and so

00:18:19,549 --> 00:18:29,150
here is the same code using this the orc

00:18:24,770 --> 00:18:31,429
are a library and you can see it's very

00:18:29,150 --> 00:18:33,230
simple so even if you don't have a

00:18:31,429 --> 00:18:34,429
manual handy you know you can go home

00:18:33,230 --> 00:18:36,230
and write it right away you don't need

00:18:34,429 --> 00:18:39,620
to like think what does this mean and

00:18:36,230 --> 00:18:41,360
did I get all my classes right etc it's

00:18:39,620 --> 00:18:45,919
exactly the same way you would write in

00:18:41,360 --> 00:18:48,289
a traditional array and answer

00:18:45,919 --> 00:18:49,909
performance so the correct answer to

00:18:48,289 --> 00:18:52,429
every performance question is it depends

00:18:49,909 --> 00:18:55,820
and it depends on a lot of things CPU

00:18:52,429 --> 00:18:58,130
cache size memory this compiler etcetera

00:18:55,820 --> 00:19:00,350
you know and so a lot of the big old

00:18:58,130 --> 00:19:02,150
stuff that you read you should you know

00:19:00,350 --> 00:19:04,549
check it out on your code because the

00:19:02,150 --> 00:19:07,549
big old stuff is asymptotic and you may

00:19:04,549 --> 00:19:09,320
not be in the asymptotic regime so

00:19:07,549 --> 00:19:10,940
actually running the code many times is

00:19:09,320 --> 00:19:14,409
the only reliable way of estimating

00:19:10,940 --> 00:19:17,000
performance and what I found is that

00:19:14,409 --> 00:19:20,330
it's been in few percent of the native

00:19:17,000 --> 00:19:22,070
array performance there's a caveat that

00:19:20,330 --> 00:19:24,559
the you know number of elements must be

00:19:22,070 --> 00:19:26,480
large enough and you know you must be

00:19:24,559 --> 00:19:27,860
doing enough computation so if you if

00:19:26,480 --> 00:19:29,840
you have very small array then you don't

00:19:27,860 --> 00:19:31,549
do any computations at all then the

00:19:29,840 --> 00:19:33,559
native arrays have advantage because you

00:19:31,549 --> 00:19:35,179
know the compiler understands all about

00:19:33,559 --> 00:19:40,340
native arrays and you're not doing

00:19:35,179 --> 00:19:41,990
dynamic memory allocation and so on so

00:19:40,340 --> 00:19:43,760
this is the things which I told you you

00:19:41,990 --> 00:19:46,220
know you prohibit the copy constructor

00:19:43,760 --> 00:19:50,419
assignment operator you check that the

00:19:46,220 --> 00:19:53,419
sizes are not negative a few basic

00:19:50,419 --> 00:19:56,059
functions to give you the sizes you do

00:19:53,419 --> 00:20:00,080
array bounds check you have a Fortran

00:19:56,059 --> 00:20:01,400
order or a C order and this is just to

00:20:00,080 --> 00:20:02,269
point out so if you have like seven

00:20:01,400 --> 00:20:06,409
dimensions or

00:20:02,269 --> 00:20:07,969
you know essentially you access the

00:20:06,409 --> 00:20:11,629
array by a function like this it's

00:20:07,969 --> 00:20:13,849
basically a function from multi you know

00:20:11,629 --> 00:20:17,389
from X 1 X 2 so on till X 7 and you need

00:20:13,849 --> 00:20:19,309
to map it to one value and these F's or

00:20:17,389 --> 00:20:22,159
the C's the big uppercase C and the

00:20:19,309 --> 00:20:23,209
uppercase F are constructed at the time

00:20:22,159 --> 00:20:25,609
when you are constructing the array

00:20:23,209 --> 00:20:31,669
there are functions of the size of the

00:20:25,609 --> 00:20:33,229
array so to conclude the orc are a

00:20:31,669 --> 00:20:35,989
library for multi-dimensional arrays

00:20:33,229 --> 00:20:38,359
it's convenient to use and to include

00:20:35,989 --> 00:20:39,529
the user manual is a few lines only so

00:20:38,359 --> 00:20:41,749
you don't need to spend a lot of time

00:20:39,529 --> 00:20:44,479
you can you know look at the code

00:20:41,749 --> 00:20:45,109
yourself and convince yourself it's ok

00:20:44,479 --> 00:20:48,979
for your needs

00:20:45,109 --> 00:20:52,940
it has compile time options for array

00:20:48,979 --> 00:20:55,009
bounds checking and for C order or

00:20:52,940 --> 00:20:58,940
Fortran order and it has good

00:20:55,009 --> 00:21:03,200
performance so it's available on github

00:20:58,940 --> 00:21:05,059
and to conclude I'd like to say

00:21:03,200 --> 00:21:07,070
questions and this is my picture of my

00:21:05,059 --> 00:21:09,469
favorite over carrots it's a

00:21:07,070 --> 00:21:10,879
two-dimensional or curry so it's

00:21:09,469 --> 00:21:15,829
probably not going to perform that well

00:21:10,879 --> 00:21:24,499
but it's still kind of neat so questions

00:21:15,829 --> 00:21:26,149
yeah so I've thought a bit about it and

00:21:24,499 --> 00:21:28,489
like you know I they seem to be so many

00:21:26,149 --> 00:21:30,079
options I would think it would be like I

00:21:28,489 --> 00:21:32,149
have to still go and put it up there

00:21:30,079 --> 00:21:33,889
like you know but I would go with my

00:21:32,149 --> 00:21:35,899
friends tell me like BST is good

00:21:33,889 --> 00:21:37,669
essentially because you know so yeah so

00:21:35,899 --> 00:21:39,979
if you want to use it either in your you

00:21:37,669 --> 00:21:42,079
know proprietary code or in your you

00:21:39,979 --> 00:21:43,869
know open source code it's all fine with

00:21:42,079 --> 00:21:46,789
me kind of you know I mean the main main

00:21:43,869 --> 00:21:47,899
my main reason to do this so you know

00:21:46,789 --> 00:21:49,309
I've been waiting for lots of these

00:21:47,899 --> 00:21:51,190
standards to come and go and I've been

00:21:49,309 --> 00:21:53,179
hoping one day we would have a standard

00:21:51,190 --> 00:21:54,589
multi-dimensional array but doesn't look

00:21:53,179 --> 00:21:56,570
like it's happening anytime soon

00:21:54,589 --> 00:21:59,419
and so I thought I had to do something

00:21:56,570 --> 00:22:01,269
about it myself so you know so I'm more

00:21:59,419 --> 00:22:04,339
than happy anybody uses it for

00:22:01,269 --> 00:22:07,059
proprietary code or for in open source

00:22:04,339 --> 00:22:07,059
code etc

00:22:08,419 --> 00:22:17,269
I look at the array view and you know

00:22:15,470 --> 00:22:19,399
that doesn't seem to own its own memory

00:22:17,269 --> 00:22:21,559
it seems to me like a rapping on top of

00:22:19,399 --> 00:22:22,789
so if you have erased somewhere and the

00:22:21,559 --> 00:22:24,830
point of somewhere you can wrap it

00:22:22,789 --> 00:22:27,159
within that but they don't seem to be

00:22:24,830 --> 00:22:28,909
you know doing like a real

00:22:27,159 --> 00:22:30,919
multi-dimensional array which owns its

00:22:28,909 --> 00:22:32,239
own storage and where you don't need to

00:22:30,919 --> 00:22:34,279
muck around with pointers yeah so it's

00:22:32,239 --> 00:22:43,039
kind of like here you don't need to use

00:22:34,279 --> 00:22:44,690
any pointers at all that's right yeah no

00:22:43,039 --> 00:22:46,850
because array me who does not own its

00:22:44,690 --> 00:22:47,960
memory yeah like the array view is kind

00:22:46,850 --> 00:22:49,399
of like you know you you you have a

00:22:47,960 --> 00:22:52,639
pointer from somewhere which has its

00:22:49,399 --> 00:22:54,200
memory and then you you know construct

00:22:52,639 --> 00:22:56,739
the array view giving it that pointer

00:22:54,200 --> 00:23:00,169
and some you know space how much

00:22:56,739 --> 00:23:02,809
elements you have say here it's totally

00:23:00,169 --> 00:23:05,899
standalone yeah so and I'm passing it by

00:23:02,809 --> 00:23:07,429
reference so you know the compiler may

00:23:05,899 --> 00:23:11,119
be using pointers and so on but if you

00:23:07,429 --> 00:23:14,239
look at the code it's the code itself is

00:23:11,119 --> 00:23:16,340
very simple yeah and there is yes I

00:23:14,239 --> 00:23:18,409
think the point is that from the user

00:23:16,340 --> 00:23:20,629
point of view and that's one of my

00:23:18,409 --> 00:23:24,409
target audience like users who are new

00:23:20,629 --> 00:23:25,970
to C++ and they can use this without

00:23:24,409 --> 00:23:28,159
having too much knowledge and it's

00:23:25,970 --> 00:23:30,950
difficult to misuse it so you can't like

00:23:28,159 --> 00:23:35,139
you know end up passing a whole array

00:23:30,950 --> 00:23:35,139
but and having copy semantics kind of

00:23:36,039 --> 00:23:40,220
well I did talk to dr. Strauss cope

00:23:38,779 --> 00:23:41,629
himself in fact you know I mean you know

00:23:40,220 --> 00:23:43,009
I call him dr. Strauss too because

00:23:41,629 --> 00:23:44,119
people here seem to call him beyond me

00:23:43,009 --> 00:23:48,820
but that seems like calling my

00:23:44,119 --> 00:23:48,820
schoolteacher you know my first name but

00:23:52,539 --> 00:23:57,889
okay so maybe I should look into that

00:23:54,529 --> 00:23:59,539
you know so I tried to look into the

00:23:57,889 --> 00:24:01,340
process for that and he told me to look

00:23:59,539 --> 00:24:03,529
at the you know array view thing and I

00:24:01,340 --> 00:24:05,929
did look at what's on the web and Neil

00:24:03,529 --> 00:24:07,999
Mackintosh talk but it didn't seem to me

00:24:05,929 --> 00:24:10,359
like you know addressing this

00:24:07,999 --> 00:24:10,359
particularly

00:24:12,380 --> 00:24:33,890
oh yeah so and I think one of the things

00:24:32,390 --> 00:24:37,040
is as I pointed out that for example

00:24:33,890 --> 00:24:38,570
this you know limit on say 7 or 15 or

00:24:37,040 --> 00:24:39,950
whatever you know so I find a lot of

00:24:38,570 --> 00:24:42,650
template code wants to be the most

00:24:39,950 --> 00:24:44,300
general everyone but in practice you

00:24:42,650 --> 00:24:47,630
know you need to say that if you know

00:24:44,300 --> 00:24:49,970
there are limitations on machines in

00:24:47,630 --> 00:24:52,760
today and in the next 30 years yeah and

00:24:49,970 --> 00:24:55,430
you know if you if your memories if

00:24:52,760 --> 00:24:57,470
something n is somewhere you know

00:24:55,430 --> 00:24:58,880
occurring an exponential function you

00:24:57,470 --> 00:25:00,020
don't need to go to very large n you

00:24:58,880 --> 00:25:01,580
know it's like the whole thing with

00:25:00,020 --> 00:25:02,930
Fibonacci sequence people do like an e

00:25:01,580 --> 00:25:04,340
you know you don't really need to

00:25:02,930 --> 00:25:06,200
calculate it you calculate it once and

00:25:04,340 --> 00:25:08,210
you're done because you know the amount

00:25:06,200 --> 00:25:10,610
of number that you can calculate it so

00:25:08,210 --> 00:25:27,890
small so that type of practical thing

00:25:10,610 --> 00:25:29,870
yeah fun no that is not a use case in my

00:25:27,890 --> 00:25:32,540
situation and but you know these type of

00:25:29,870 --> 00:25:34,730
things could be used in MPI programs and

00:25:32,540 --> 00:25:42,230
so on where you just you know you're

00:25:34,730 --> 00:25:44,270
separate so yeah I share nothing you you

00:25:42,230 --> 00:25:45,620
could use it I have not used it but what

00:25:44,270 --> 00:25:47,450
I'm saying is it's shared nothing so

00:25:45,620 --> 00:25:48,590
it's not a thread concurrent type of

00:25:47,450 --> 00:25:50,780
thing you know there's no locking here

00:25:48,590 --> 00:25:52,850
there's no tracking of you know and and

00:25:50,780 --> 00:25:54,230
it's it's all a private memories private

00:25:52,850 --> 00:25:58,540
yeah so you would have to really do some

00:25:54,230 --> 00:25:58,540
trickery to you know exercise yeah

00:26:13,700 --> 00:26:20,250
okay okay yes I think I suggested and

00:26:18,900 --> 00:26:22,020
maybe I'll talk with you afterwards you

00:26:20,250 --> 00:26:23,400
find out more about this process like

00:26:22,020 --> 00:26:24,570
you know so I'm from the astronomic

00:26:23,400 --> 00:26:28,940
department here so it's like I'm not

00:26:24,570 --> 00:26:28,940
familiar with a lot of these processes I

00:26:33,290 --> 00:27:26,880
also wished the same thing actually not

00:27:25,170 --> 00:27:30,270
with boost you know the performance

00:27:26,880 --> 00:27:32,970
comparisons I did with were with you

00:27:30,270 --> 00:27:34,590
know the native array but so you're

00:27:32,970 --> 00:27:42,180
talking about runtime performance or

00:27:34,590 --> 00:27:44,580
compilation yeah so so I think that's

00:27:42,180 --> 00:27:46,170
one of my concerns yeah like so you know

00:27:44,580 --> 00:27:47,490
like so they're two things so one is the

00:27:46,170 --> 00:27:48,870
compile time performance you know if

00:27:47,490 --> 00:27:51,180
this thing is going to take more compile

00:27:48,870 --> 00:27:52,800
time then the scientists own code you

00:27:51,180 --> 00:27:54,480
know you're not gonna use it but I think

00:27:52,800 --> 00:27:55,800
the other is the runtime performance so

00:27:54,480 --> 00:27:58,560
I think I compared it with the native

00:27:55,800 --> 00:28:00,120
arrays and it it's doing fine there so

00:27:58,560 --> 00:28:02,160
if the boost is similar performance to

00:28:00,120 --> 00:28:05,750
native arrays then it would be similar

00:28:02,160 --> 00:28:09,180
performance in practice and I think that

00:28:05,750 --> 00:28:11,550
yeah regarding the comparison it's true

00:28:09,180 --> 00:28:13,310
that you know boost and multi array and

00:28:11,550 --> 00:28:17,670
blitz plus plus do a million things more

00:28:13,310 --> 00:28:19,620
but a lot of scientific code like so if

00:28:17,670 --> 00:28:21,480
the core needs all those functionality

00:28:19,620 --> 00:28:22,590
it's great but a lot of code does not

00:28:21,480 --> 00:28:23,910
necessarily need all that functionality

00:28:22,590 --> 00:28:26,340
you know there's a lot of code being

00:28:23,910 --> 00:28:27,149
written in C and Fortran and so on and

00:28:26,340 --> 00:28:28,919
they're doing

00:28:27,149 --> 00:28:30,659
fine without a lot of that extra

00:28:28,919 --> 00:28:33,929
functionality so that's really the you

00:28:30,659 --> 00:28:35,429
know focus of this thing so so yeah that

00:28:33,929 --> 00:28:39,739
was what decided my you know design

00:28:35,429 --> 00:28:39,739
decisions and sort of overall philosophy

00:28:41,899 --> 00:28:46,469
yeah I've done a bit of it so the

00:28:44,700 --> 00:28:49,559
question is have I done any work on

00:28:46,469 --> 00:28:52,889
sparse matrices so I have done a bit of

00:28:49,559 --> 00:28:55,009
it for my own use but I went you know

00:28:52,889 --> 00:28:59,190
reached a stage where I could sort of

00:28:55,009 --> 00:29:00,299
you know make it public yet but I have

00:28:59,190 --> 00:29:02,190
looked into that because that's other

00:29:00,299 --> 00:29:03,570
thing we have and that occurs in things

00:29:02,190 --> 00:29:05,129
like machine learning and so on

00:29:03,570 --> 00:29:06,899
we applied machine learning to one of

00:29:05,129 --> 00:29:08,309
our astronomic problems and there you

00:29:06,899 --> 00:29:10,320
can have a lot of sparse matrices you

00:29:08,309 --> 00:29:13,799
know so very high dimensions but really

00:29:10,320 --> 00:29:16,259
most of them are you know empty most of

00:29:13,799 --> 00:29:18,330
the elements are empty really and so

00:29:16,259 --> 00:29:29,729
I've done a bit there but it's not ready

00:29:18,330 --> 00:29:31,469
yet it's not a microts they all

00:29:29,729 --> 00:29:38,099
functions but they're in line because

00:29:31,469 --> 00:29:40,619
they're in a very small I know let's go

00:29:38,099 --> 00:29:44,389
to the yeah if death is between you

00:29:40,619 --> 00:29:44,389
either you go for an order or see yeah

00:29:45,950 --> 00:29:50,179
that's right yeah I won't make it

00:29:54,349 --> 00:30:00,570
because I mean this is very scientific

00:29:57,509 --> 00:30:03,109
word usually up like like n times N or

00:30:00,570 --> 00:30:05,369
something but for instance an audio you

00:30:03,109 --> 00:30:07,859
always looking for something similar

00:30:05,369 --> 00:30:09,179
there is something like interdictor is

00:30:07,859 --> 00:30:11,190
not as ready so you have like a two

00:30:09,179 --> 00:30:12,419
stereo channel which is sacred in same

00:30:11,190 --> 00:30:14,789
thing and either you have two two

00:30:12,419 --> 00:30:16,229
channels behind each other or they're in

00:30:14,789 --> 00:30:17,969
turn if this is the same problem like

00:30:16,229 --> 00:30:20,909
robots cut a major but okay you have

00:30:17,969 --> 00:30:22,409
like interfaces some of these take if

00:30:20,909 --> 00:30:24,299
others are not interleave and then I

00:30:22,409 --> 00:30:27,690
have to copy from one to the other and

00:30:24,299 --> 00:30:28,799
then I need both versions in the same

00:30:27,690 --> 00:30:31,049
code oh I see

00:30:28,799 --> 00:30:32,729
okay don't want to switch that that one

00:30:31,049 --> 00:30:34,969
parameter once and then it's like

00:30:32,729 --> 00:30:37,779
hard-coded okay I'll look into that

00:30:34,969 --> 00:30:39,099
policy

00:30:37,779 --> 00:30:40,779
the edge so he called it edge so this

00:30:39,099 --> 00:30:43,599
little confusing maybe if you know the

00:30:40,779 --> 00:30:48,159
vector because the vector it does always

00:30:43,599 --> 00:30:52,229
bounce shorts even is so even it hmm oh

00:30:48,159 --> 00:30:52,229
yeah yeah towards the common things I

00:30:57,149 --> 00:31:01,419
just feel like this you know cord is

00:30:59,710 --> 00:31:05,289
simpler like you know if whether you use

00:31:01,419 --> 00:31:06,700
the you know the you know these type

00:31:05,289 --> 00:31:08,379
brackets or the square brackets you know

00:31:06,700 --> 00:31:09,700
I think this just seems simpler but I

00:31:08,379 --> 00:31:21,580
see your point that people may assume

00:31:09,700 --> 00:31:22,479
dudes check yeah he's talking about

00:31:21,580 --> 00:31:24,759
other one like you know with the

00:31:22,479 --> 00:31:43,839
function type thing yeah yeah I can look

00:31:24,759 --> 00:31:47,940
a bit into that because from a tree yeah

00:31:43,839 --> 00:31:47,940
you would need to have like a starting

00:31:55,320 --> 00:31:59,789
yeah then you return a proxy and then

00:32:12,539 --> 00:32:18,729
yeah I think I should probably make it

00:32:16,960 --> 00:32:20,109
more you know in the in the two-page

00:32:18,729 --> 00:32:22,809
manual it should be written probably

00:32:20,109 --> 00:32:26,859
that you know the default is basically

00:32:22,809 --> 00:32:30,460
to not check and basically since it's

00:32:26,859 --> 00:32:32,559
you know the header is readable it's

00:32:30,460 --> 00:32:33,909
right at the top the choice between you

00:32:32,559 --> 00:32:36,369
know checking and not checking in

00:32:33,909 --> 00:32:38,679
Fortran or not so I'm hoping if people

00:32:36,369 --> 00:32:40,299
use it anywhere they would at least open

00:32:38,679 --> 00:32:43,169
it up and look at the first few lines

00:32:40,299 --> 00:32:43,169
and it could be right

00:33:02,540 --> 00:33:07,400
yeah it's mostly because it's easier

00:33:05,190 --> 00:33:10,559
than remembering row-major and you know

00:33:07,400 --> 00:33:11,910
column-major you know il is it's always

00:33:10,559 --> 00:33:14,040
tricky to remember what it really mean

00:33:11,910 --> 00:33:15,480
but I think for time is Fortran it's

00:33:14,040 --> 00:33:18,630
sort of easy to remember then you know

00:33:15,480 --> 00:33:20,670
mnemonic for it is like you know Fortran

00:33:18,630 --> 00:33:24,600
is first here so like you know first

00:33:20,670 --> 00:33:26,190
index varies fastest and in C you know

00:33:24,600 --> 00:33:27,540
it's like odometer so the last index

00:33:26,190 --> 00:33:30,360
varies faster so that's kind of like

00:33:27,540 --> 00:33:32,460
just to make it easy to remember but you

00:33:30,360 --> 00:33:35,880
write that some other target audience it

00:33:32,460 --> 00:33:37,740
might be new to them but I should

00:33:35,880 --> 00:33:39,330
probably again make a note of that that

00:33:37,740 --> 00:33:41,640
so it's sometimes people are porting

00:33:39,330 --> 00:33:44,610
code from Fortran or C and they need to

00:33:41,640 --> 00:33:48,020
probably know the the ordering you know

00:33:44,610 --> 00:33:48,020
if they're putting some code for example

00:33:58,490 --> 00:34:04,170
right but if it's 2d it's fine but if

00:34:01,559 --> 00:34:05,429
you have like you know 70s then you know

00:34:04,170 --> 00:34:09,450
because what it's saying is the last

00:34:05,429 --> 00:34:11,760
index or the first and the first one

00:34:09,450 --> 00:34:13,320
maybe agree is the row but do we agree

00:34:11,760 --> 00:34:15,270
the last one is the column or the second

00:34:13,320 --> 00:34:19,200
one is the column if you have a seven

00:34:15,270 --> 00:34:21,200
dimensional array yeah so I think that

00:34:19,200 --> 00:34:23,639
was part of it like you know so the real

00:34:21,200 --> 00:34:39,139
interesting case here is three four five

00:34:23,639 --> 00:34:39,139
dimensions yeah

00:34:45,810 --> 00:34:52,000
yeah it's just a it's just a formula

00:34:49,360 --> 00:34:55,570
being used here for the calculation is

00:34:52,000 --> 00:34:57,360
is different you know so and basically

00:34:55,570 --> 00:35:00,040
based on what approach you are using

00:34:57,360 --> 00:35:02,670
it's just a matter of the way you are

00:35:00,040 --> 00:35:04,660
doing the multiplication than addition

00:35:02,670 --> 00:35:05,890
and you know it gets slightly more

00:35:04,660 --> 00:35:09,490
complicated if you have say seven

00:35:05,890 --> 00:35:11,680
dimensions so all these FBF and big seas

00:35:09,490 --> 00:35:13,000
are defined that when you're

00:35:11,680 --> 00:35:14,950
constructing this array so the array

00:35:13,000 --> 00:35:17,800
uses memory equal to the memory are

00:35:14,950 --> 00:35:20,020
using and a little bit of more to you

00:35:17,800 --> 00:35:24,910
know save these things calculate and

00:35:20,020 --> 00:35:26,740
save them once but but usually the aim

00:35:24,910 --> 00:35:28,780
here is for larger arrays yeah like you

00:35:26,740 --> 00:35:29,920
know which is not common which is common

00:35:28,780 --> 00:35:31,300
inside the computing like you know

00:35:29,920 --> 00:36:19,420
hundred by hundred or thousand by twelve

00:35:31,300 --> 00:36:20,320
I know million by million okay yeah I

00:36:19,420 --> 00:36:22,510
agree with that

00:36:20,320 --> 00:36:24,640
it's the idea here is to make it easy to

00:36:22,510 --> 00:36:28,630
use so that in lot of use cases so I

00:36:24,640 --> 00:36:30,310
think if the use case is doing something

00:36:28,630 --> 00:36:31,360
which it needs all the features then

00:36:30,310 --> 00:36:34,270
boost multi array I think that's

00:36:31,360 --> 00:36:36,160
probably you know appropriate but a lot

00:36:34,270 --> 00:36:39,670
of new cases don't need all that you

00:36:36,160 --> 00:36:42,550
know extra stuff and so for that this

00:36:39,670 --> 00:36:44,970
works out fine I guess one last question

00:36:42,550 --> 00:36:44,970
and

00:36:53,880 --> 00:36:57,510
well the way it works is generally

00:36:55,710 --> 00:36:58,620
inside computing at the beginning when

00:36:57,510 --> 00:37:01,290
they're writing maybe they don't care

00:36:58,620 --> 00:37:03,690
you know that much but gradually when

00:37:01,290 --> 00:37:05,880
they go to the supercomputer and run it

00:37:03,690 --> 00:37:07,050
over there then they start caring when

00:37:05,880 --> 00:37:10,620
they need like you know thousands of

00:37:07,050 --> 00:37:12,150
cores so so my opinion always has been

00:37:10,620 --> 00:37:14,250
and I try to convince them that you know

00:37:12,150 --> 00:37:16,890
if you go with these statically compiled

00:37:14,250 --> 00:37:20,340
languages you know you don't need to

00:37:16,890 --> 00:37:21,870
change your code six months later in any

00:37:20,340 --> 00:37:25,860
dramatic way maybe you need to fiddle a

00:37:21,870 --> 00:37:28,140
little bit but because some of them you

00:37:25,860 --> 00:37:30,120
know lacks a features like a convenient

00:37:28,140 --> 00:37:32,570
multi-dimensional array sometimes they

00:37:30,120 --> 00:37:35,340
you know start using some other

00:37:32,570 --> 00:37:38,550
languages and then six months later when

00:37:35,340 --> 00:37:39,990
they find that it's not enough you know

00:37:38,550 --> 00:37:41,520
they can't it's not running fast enough

00:37:39,990 --> 00:38:01,620
then they need to kind of you know think

00:37:41,520 --> 00:38:06,530
what to do yeah that depends because I

00:38:01,620 --> 00:38:08,820
think anything many cases it the kind of

00:38:06,530 --> 00:38:10,230
index manipulation in scientific code is

00:38:08,820 --> 00:38:11,490
not necessarily just you know AI is

00:38:10,230 --> 00:38:15,660
equal to BI type of thing yeah they'll

00:38:11,490 --> 00:38:18,540
be like you know AI is equal to the

00:38:15,660 --> 00:38:21,120
average of all the different you know bi

00:38:18,540 --> 00:38:22,530
is around and so on yeah so it gets

00:38:21,120 --> 00:38:25,470
complicated so I'm not so concerned

00:38:22,530 --> 00:38:27,270
about you know like its it seems

00:38:25,470 --> 00:38:31,100
unlikely the compiler can anticipate all

00:38:27,270 --> 00:38:31,100
the possible you know things people do

00:38:32,540 --> 00:38:37,520
okay I guess the session is over thanks

00:38:35,340 --> 00:38:37,520

YouTube URL: https://www.youtube.com/watch?v=CPPX4kwqh80


