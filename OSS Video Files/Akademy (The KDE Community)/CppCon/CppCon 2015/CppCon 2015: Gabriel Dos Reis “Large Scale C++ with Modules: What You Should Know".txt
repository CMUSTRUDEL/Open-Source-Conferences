Title: CppCon 2015: Gabriel Dos Reis “Large Scale C++ with Modules: What You Should Know"
Publication date: 2015-10-12
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
“Modules” are a frequently requested and long-awaited feature by C++ programmers.  In a nutshell, the idea is to have a direct language support for (a) expressing the boundaries and dependencies of a program component; (b) isolating source codes from macro vagaries; (c) scaling compile time, especially for large projects, given the ubiquity of “headers-only” template libraries; (d) spur innovation and deployment of semantics-aware developer tools.

This presentation will focus on three major points: (1) the design of the module proposal currently being considered by the C++ standards committee (design goals, properties, constraints); (2) implementations currently under way; and (3) early user experience and migration.

Modules directly address a problem (scalability) listed as one of the three major areas where C++17 is expected to significantly improve daily experience of the working C++ programmer.  Naturally, this feature is  also on the top ten list of C++17 functionalities Bjarne Stroustrup put forward in his “Thought on C++17.” 
— 
Gabriel Dos Reis is a Principal Software Development Engineer at Microsoft. He is also a researcher and a longtime member of the C++ community.  His research interests include programming tools for dependable software. Prior to joining Microsoft, he was Assistant Professor at Texas A&M University.  Dr. Dos Reis was a recipient of the 2012 National Science Foundation CAREER award for his research in compilers for dependable computational mathematics and educational activities.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,550
okay good afternoon everybody

00:00:04,589 --> 00:00:11,759
I wanted to give you a brief update

00:00:08,429 --> 00:00:14,009
about the module efforts that's going on

00:00:11,759 --> 00:00:16,230
I know I'm hearing a lot about the

00:00:14,009 --> 00:00:21,390
modules for at least the last 15 years

00:00:16,230 --> 00:00:27,119
or so what are you trying to do is make

00:00:21,390 --> 00:00:30,560
you free all this time so where we are

00:00:27,119 --> 00:00:35,160
today today here taking an example from

00:00:30,560 --> 00:00:38,610
the Anna's book Cintas class usually 80

00:00:35,160 --> 00:00:40,440
is this data type called dates which is

00:00:38,610 --> 00:00:43,170
quite interesting because if you really

00:00:40,440 --> 00:00:46,289
want to represent dates in C++ you get

00:00:43,170 --> 00:00:47,940
quite interesting design problems to

00:00:46,289 --> 00:00:51,510
solve in terms of data structure

00:00:47,940 --> 00:00:54,210
abstracted attack design and server on

00:00:51,510 --> 00:00:57,059
the left hand side know the screen I

00:00:54,210 --> 00:00:59,430
have very small program which is what

00:00:57,059 --> 00:01:02,940
I'll call a consumer of the data type

00:00:59,430 --> 00:01:08,040
date okay so all I have to do is to

00:01:02,940 --> 00:01:09,960
include calendar date of H I include is

00:01:08,040 --> 00:01:12,390
3 because I'm going to do something I

00:01:09,960 --> 00:01:14,689
owe and then the rest is quite

00:01:12,390 --> 00:01:18,360
straightforward right

00:01:14,689 --> 00:01:20,430
on the right-hand side is basically what

00:01:18,360 --> 00:01:22,259
we call a header file the interface

00:01:20,430 --> 00:01:24,810
header file that gives you this abstract

00:01:22,259 --> 00:01:26,970
the time your notice it's silly bit more

00:01:24,810 --> 00:01:28,439
involved and you'll tell me well it's

00:01:26,970 --> 00:01:30,689
supposed to be this library so it's

00:01:28,439 --> 00:01:32,640
supposed to be more involved the very

00:01:30,689 --> 00:01:36,000
last we have this thing we all deal with

00:01:32,640 --> 00:01:40,110
it so if they have this then do other

00:01:36,000 --> 00:01:43,229
stuff just to guard against multiple

00:01:40,110 --> 00:01:47,310
inclusion just first week and I know you

00:01:43,229 --> 00:01:51,750
learn when you learn C or C++ I would

00:01:47,310 --> 00:01:54,030
like us to be at a better place which is

00:01:51,750 --> 00:01:56,670
if you look at the slides the only thing

00:01:54,030 --> 00:02:00,600
I change was just to remove the hash

00:01:56,670 --> 00:02:03,869
includes and we replace that v of fancy

00:02:00,600 --> 00:02:07,520
word calling imports okay and if you

00:02:03,869 --> 00:02:09,490
have been using Python or any of those

00:02:07,520 --> 00:02:11,980
contemporary languages

00:02:09,490 --> 00:02:15,070
familiar with this the left-hand side

00:02:11,980 --> 00:02:19,810
doesn't change much the left-hand side

00:02:15,070 --> 00:02:22,510
change little bits you don't have the if

00:02:19,810 --> 00:02:27,250
death kind of things now I have fancy

00:02:22,510 --> 00:02:31,960
key words you know imports module and

00:02:27,250 --> 00:02:34,270
experts and so you ask me why what is

00:02:31,960 --> 00:02:37,990
the big deal why do you why would I want

00:02:34,270 --> 00:02:40,120
you to be there well the first thing

00:02:37,990 --> 00:02:44,500
ability is that if you take the client

00:02:40,120 --> 00:02:46,690
code it's only about 176 bytes if I can

00:02:44,500 --> 00:02:50,320
trust the only tool that gives me that

00:02:46,690 --> 00:02:52,320
number then you run back through the

00:02:50,320 --> 00:02:53,500
compiler so this is what the user sees

00:02:52,320 --> 00:02:55,600
okay

00:02:53,500 --> 00:02:57,820
the interesting thing is that today that

00:02:55,600 --> 00:03:00,820
is not what your compiler sees this is

00:02:57,820 --> 00:03:03,580
what your compiler sees okay this you

00:03:00,820 --> 00:03:08,700
see hopefully expands the old program no

00:03:03,580 --> 00:03:11,620
pre-processing into about half gigabytes

00:03:08,700 --> 00:03:15,130
time we'll see well I'll give you full

00:03:11,620 --> 00:03:19,710
bigger bites and and and VC plus twice

00:03:15,130 --> 00:03:22,140
is just behind okay and you know it's

00:03:19,710 --> 00:03:25,770
cats I don't know what I would call it

00:03:22,140 --> 00:03:29,770
compression or expansion or inflation

00:03:25,770 --> 00:03:31,690
just know look here I turned those

00:03:29,770 --> 00:03:33,550
numbers into some graphics you just

00:03:31,690 --> 00:03:36,880
getting an understanding so the baseline

00:03:33,550 --> 00:03:38,770
is the program so it would be just one

00:03:36,880 --> 00:03:43,330
bite and everything else is percentage

00:03:38,770 --> 00:03:47,680
of the fact that we have this

00:03:43,330 --> 00:03:54,190
compression of 5 more than 500,000 is

00:03:47,680 --> 00:03:58,660
impressive right now why is it a big

00:03:54,190 --> 00:04:00,670
deal now the problem here is that every

00:03:58,660 --> 00:04:02,920
if you have a large team or company

00:04:00,670 --> 00:04:05,590
people writing program using consuming

00:04:02,920 --> 00:04:07,810
this at a time what they're going to do

00:04:05,590 --> 00:04:10,209
is most of the time include the iostream

00:04:07,810 --> 00:04:12,640
because that's what did you see out a

00:04:10,209 --> 00:04:18,669
bunch of other stuff and then it will

00:04:12,640 --> 00:04:21,190
encourage the dates had a file so every

00:04:18,669 --> 00:04:23,170
hit a fire so every source fire in your

00:04:21,190 --> 00:04:25,690
program or everybody think

00:04:23,170 --> 00:04:28,540
to this comparable to it's going to to

00:04:25,690 --> 00:04:29,890
do that right and what happens is that

00:04:28,540 --> 00:04:31,990
well

00:04:29,890 --> 00:04:34,660
the preprocessor once they hash include'

00:04:31,990 --> 00:04:37,330
what actually does is they hey good a

00:04:34,660 --> 00:04:40,210
look at that head of that file and give

00:04:37,330 --> 00:04:42,600
me the content it's copy and paste we

00:04:40,210 --> 00:04:46,480
are rail against copy/paste programming

00:04:42,600 --> 00:04:50,560
we did orator at least we've had from

00:04:46,480 --> 00:04:52,270
the air compile okay and look at it very

00:04:50,560 --> 00:04:55,870
carefully this is one of those places

00:04:52,270 --> 00:04:59,560
where we fail or the language fails us

00:04:55,870 --> 00:05:02,140
in this you know motor which is you

00:04:59,560 --> 00:05:04,570
don't pay for what you don't use when

00:05:02,140 --> 00:05:06,730
the compiler goes and copy the contents

00:05:04,570 --> 00:05:10,630
of that file it doesn't just copy what

00:05:06,730 --> 00:05:12,430
you need the cop is everything right so

00:05:10,630 --> 00:05:15,190
the compiler goes on and in process

00:05:12,430 --> 00:05:16,960
listing legs parsing you know it cannot

00:05:15,190 --> 00:05:19,780
really precede us what you're doing

00:05:16,960 --> 00:05:23,730
template instance issues of resolution

00:05:19,780 --> 00:05:26,950
all those things so this time

00:05:23,730 --> 00:05:29,890
ninety-four support of symbols and then

00:05:26,950 --> 00:05:31,780
linked here comes in saying okay I can't

00:05:29,890 --> 00:05:36,880
have to throw everybody out let me

00:05:31,780 --> 00:05:41,230
except one so forget about that now we

00:05:36,880 --> 00:05:43,420
have powerful computers this at least

00:05:41,230 --> 00:05:50,020
you have to care about the planet this

00:05:43,420 --> 00:05:54,640
is not dream programming okay so where I

00:05:50,020 --> 00:05:56,860
want us to be is place where we don't

00:05:54,640 --> 00:05:59,800
have to worry about copies because this

00:05:56,860 --> 00:06:01,930
is copy it is quite possible that you'll

00:05:59,800 --> 00:06:04,630
get slightly different version of what I

00:06:01,930 --> 00:06:06,310
have we got knowing of that asking for

00:06:04,630 --> 00:06:08,860
it and even ask for you should get this

00:06:06,310 --> 00:06:10,660
slightly different copy right and this

00:06:08,860 --> 00:06:13,360
happens either because someone defines a

00:06:10,660 --> 00:06:16,090
macro that's not expand rename something

00:06:13,360 --> 00:06:19,080
you didn't ask for oh you get a genius

00:06:16,090 --> 00:06:22,150
on the team who comes and you wanted to

00:06:19,080 --> 00:06:24,580
modify slightly you do

00:06:22,150 --> 00:06:27,940
litter obstruction dicks and you say no

00:06:24,580 --> 00:06:31,330
guess what he did when a copy we have a

00:06:27,940 --> 00:06:33,490
file in a new directory slightly modify

00:06:31,330 --> 00:06:36,250
and then splash the include directory

00:06:33,490 --> 00:06:38,560
right in front of yours now whenever you

00:06:36,250 --> 00:06:41,020
fix bugs in your own hand of fire you

00:06:38,560 --> 00:06:41,620
don't get it because something is got a

00:06:41,020 --> 00:06:44,860
better idea

00:06:41,620 --> 00:06:48,460
okay and there it is it's very difficult

00:06:44,860 --> 00:06:49,930
to get tools to enforce things so this

00:06:48,460 --> 00:06:51,850
sounds like a joke but I'm just

00:06:49,930 --> 00:06:55,270
abstracting from reality this is things

00:06:51,850 --> 00:06:56,700
that no people faced there today and I

00:06:55,270 --> 00:07:02,320
talked to Dave that's what it taught me

00:06:56,700 --> 00:07:07,660
okay the other thing is new mechanism is

00:07:02,320 --> 00:07:09,160
based on C preprocessor it makes parsing

00:07:07,660 --> 00:07:10,920
or analyzing super stress

00:07:09,160 --> 00:07:14,850
extremely difficult if not impossible

00:07:10,920 --> 00:07:18,130
the reason is if you want to correctly

00:07:14,850 --> 00:07:21,220
personalize in a fire you need to know

00:07:18,130 --> 00:07:23,380
is set in the full set of macros that

00:07:21,220 --> 00:07:26,500
you need to do this food bill you can't

00:07:23,380 --> 00:07:33,760
just say oh this won't affect you know

00:07:26,500 --> 00:07:36,010
I'm going to get different codes so I

00:07:33,760 --> 00:07:38,140
guess what I want to say is that we do

00:07:36,010 --> 00:07:40,540
have pressing needs in front of us and

00:07:38,140 --> 00:07:46,680
this is a charge set of challenges for

00:07:40,540 --> 00:07:50,200
for C++ these days you hear a lot about

00:07:46,680 --> 00:07:52,270
cloud computing and cloud build that

00:07:50,200 --> 00:07:53,590
kind of stuff well if first thing is if

00:07:52,270 --> 00:07:55,540
you want to take advantage of the cloud

00:07:53,590 --> 00:07:57,280
you must be very disciplined this is

00:07:55,540 --> 00:07:58,360
where you really want to component and

00:07:57,280 --> 00:08:04,720
just for school you want to have

00:07:58,360 --> 00:08:07,390
dependencies because you know what you

00:08:04,720 --> 00:08:10,750
look at your first fire and if you can't

00:08:07,390 --> 00:08:13,090
tell them how things I use semantically

00:08:10,750 --> 00:08:14,800
not just the timestamp of the fire but

00:08:13,090 --> 00:08:17,500
how things like what is used what is not

00:08:14,800 --> 00:08:18,670
used and if you just slight modification

00:08:17,500 --> 00:08:20,830
maybe you don't actually need to

00:08:18,670 --> 00:08:23,620
recompile entire world you just need to

00:08:20,830 --> 00:08:26,110
compile that's tiny part that dependent

00:08:23,620 --> 00:08:28,750
something you change okay to get there

00:08:26,110 --> 00:08:30,760
we need exclusive dependencies in the

00:08:28,750 --> 00:08:36,220
source program we need computerization

00:08:30,760 --> 00:08:38,650
and we really need to move the language

00:08:36,220 --> 00:08:41,620
place where we can have better developer

00:08:38,650 --> 00:08:44,170
tools okay I cannot emphasize this

00:08:41,620 --> 00:08:46,840
enough and again is the room so you'll

00:08:44,170 --> 00:08:48,880
back me up I'm pretty sure so that the

00:08:46,840 --> 00:08:51,340
fact that we have macros have stiffle

00:08:48,880 --> 00:08:54,910
development for the developer tools no

00:08:51,340 --> 00:09:00,910
it made it very very difficult to build

00:08:54,910 --> 00:09:04,990
tools thanks and the interesting part is

00:09:00,910 --> 00:09:07,180
that in most cases we don't need these

00:09:04,990 --> 00:09:08,830
macros and it wasn't a well behaved

00:09:07,180 --> 00:09:10,480
looks like they could go to show the

00:09:08,830 --> 00:09:16,150
earlier was for the first slide and

00:09:10,480 --> 00:09:18,670
there's no configuration and if we can

00:09:16,150 --> 00:09:21,730
only have those will be in fantastic

00:09:18,670 --> 00:09:24,010
place and that's where I want us to be

00:09:21,730 --> 00:09:33,160
that's where I want you to believe you

00:09:24,010 --> 00:09:39,820
can be in the year not more okay so the

00:09:33,160 --> 00:09:42,730
end of this module efforts is to bring a

00:09:39,820 --> 00:09:44,770
module system that allows you know I

00:09:42,730 --> 00:09:46,750
can't repeat this enough okay this is

00:09:44,770 --> 00:09:51,100
not just about build improvement it's

00:09:46,750 --> 00:09:53,560
very important but you need to benefit

00:09:51,100 --> 00:09:55,930
from the build improvement you first

00:09:53,560 --> 00:09:58,360
need to get your house in order

00:09:55,930 --> 00:10:00,220
you need controller transition you need

00:09:58,360 --> 00:10:02,380
isolation from bathrooms this is very

00:10:00,220 --> 00:10:04,510
important for the tools they built

00:10:02,380 --> 00:10:06,520
instruction gives you in the best it can

00:10:04,510 --> 00:10:08,920
it must be able to analyze your source

00:10:06,520 --> 00:10:12,430
code right if you depends on macros

00:10:08,920 --> 00:10:14,230
forget about it and of course once get

00:10:12,430 --> 00:10:16,240
back you can now now take advantage of

00:10:14,230 --> 00:10:19,990
the cloud build this we did build and we

00:10:16,240 --> 00:10:23,130
get much more much better built recruits

00:10:19,990 --> 00:10:26,170
and and of course all these depends on

00:10:23,130 --> 00:10:29,380
developer tools you know that no takes

00:10:26,170 --> 00:10:33,880
into account semantics to earlier this

00:10:29,380 --> 00:10:37,440
morning you saw I guess it's herbs talk

00:10:33,880 --> 00:10:39,360
and most of it was based on analysis

00:10:37,440 --> 00:10:41,339
and trying to give you this safety

00:10:39,360 --> 00:10:43,769
without changing the language if your

00:10:41,339 --> 00:10:47,579
library at all for that to work

00:10:43,769 --> 00:10:52,860
yeah we need to do program in a way that

00:10:47,579 --> 00:10:54,720
is easily analyzed oh okay the same

00:10:52,860 --> 00:10:55,620
types of seekers West does not define

00:10:54,720 --> 00:10:57,959
super spies

00:10:55,620 --> 00:11:00,839
it is the semantics it is quite possible

00:10:57,959 --> 00:11:04,759
to have very nice syntax I guess what I

00:11:00,839 --> 00:11:08,879
want to say is have a very nice you know

00:11:04,759 --> 00:11:11,579
program expression of 30 years in C++ we

00:11:08,879 --> 00:11:13,379
got using all the other parts that make

00:11:11,579 --> 00:11:16,259
it very very difficult and modules

00:11:13,379 --> 00:11:19,079
actually help you do that and I'm going

00:11:16,259 --> 00:11:22,319
to illustrate that she moved oh yeah

00:11:19,079 --> 00:11:24,959
one last thing I am not proposing and

00:11:22,319 --> 00:11:27,899
I'm not suggesting that we try to remove

00:11:24,959 --> 00:11:30,180
or replace or included preprocessor it

00:11:27,899 --> 00:11:33,689
has me there for more than 40 years and

00:11:30,180 --> 00:11:37,620
people have found creative ways of

00:11:33,689 --> 00:11:41,189
abusing it and we cannot get rid of that

00:11:37,620 --> 00:11:44,459
in the next 12 months and let's not try

00:11:41,189 --> 00:11:47,250
that okay so I guess one thing I want to

00:11:44,459 --> 00:11:48,420
say is if at the end of this effort we

00:11:47,250 --> 00:11:51,769
end up improving a preprocessor

00:11:48,420 --> 00:11:51,769
somewhere we have failed

00:11:52,880 --> 00:12:02,490
okay so first question is it it's all

00:11:57,630 --> 00:12:05,279
sounds nice and you know works but when

00:12:02,490 --> 00:12:08,399
can I use it we're gonna have some

00:12:05,279 --> 00:12:11,540
traditions in trying and of that but now

00:12:08,399 --> 00:12:14,389
today this happen I can announce that

00:12:11,540 --> 00:12:18,750
you get an experimental implementation

00:12:14,389 --> 00:12:21,920
from a Microsoft compiler and update

00:12:18,750 --> 00:12:26,449
their 14 update one timeframe

00:12:21,920 --> 00:12:30,029
I'm not imposition of 10 exactly the

00:12:26,449 --> 00:12:31,970
exact date because but I can tell you it

00:12:30,029 --> 00:12:35,189
is in that timeframe you'll be able to

00:12:31,970 --> 00:12:38,790
test what I'm going to to show shortly

00:12:35,189 --> 00:12:41,699
and of course I want feedback from you

00:12:38,790 --> 00:12:43,220
guys because this is the only way we can

00:12:41,699 --> 00:12:47,579
ensure that we get it right

00:12:43,220 --> 00:12:49,290
ok at least close enough know when get

00:12:47,579 --> 00:12:49,840
out I want you to try it

00:12:49,290 --> 00:12:53,370
and send

00:12:49,840 --> 00:12:57,040
spin back have fear lives you say oh

00:12:53,370 --> 00:12:59,890
this is so complicated we shouldn't do

00:12:57,040 --> 00:13:07,270
it in some insane no we can and we

00:12:59,890 --> 00:13:09,340
should we shouldn't wait so what is the

00:13:07,270 --> 00:13:15,160
problem that we're trying really to

00:13:09,340 --> 00:13:17,920
solve so the program organization that

00:13:15,160 --> 00:13:20,230
we inherited from seed is this idea that

00:13:17,920 --> 00:13:22,410
you compile source files but what a

00:13:20,230 --> 00:13:25,870
compiler sees is in society the code

00:13:22,410 --> 00:13:28,060
translation video so essentially it

00:13:25,870 --> 00:13:31,090
takes a source file looks at all the

00:13:28,060 --> 00:13:32,740
includes and expands them by doing copy

00:13:31,090 --> 00:13:34,270
and paste and sometimes they have

00:13:32,740 --> 00:13:36,820
conditional inclusion so we have

00:13:34,270 --> 00:13:40,750
conditional expression basically have a

00:13:36,820 --> 00:13:43,360
huge pile of things now what are those

00:13:40,750 --> 00:13:46,350
things most of the fire will see

00:13:43,360 --> 00:13:48,460
definitions and then declaration

00:13:46,350 --> 00:13:50,170
especially why don't you have your

00:13:48,460 --> 00:13:52,330
programs you have several translation

00:13:50,170 --> 00:13:54,250
units and you have to communicate

00:13:52,330 --> 00:13:56,560
between themselves so that became know

00:13:54,250 --> 00:13:58,300
do something useful the way the

00:13:56,560 --> 00:14:01,840
currently between themselves is to say

00:13:58,300 --> 00:14:06,610
oh I think I know about the function foo

00:14:01,840 --> 00:14:08,710
it takes an it and returns eight the it

00:14:06,610 --> 00:14:10,990
is not a provider of that function foo

00:14:08,710 --> 00:14:13,270
like to say that it is the user so

00:14:10,990 --> 00:14:15,130
someone is just claiming and there is no

00:14:13,270 --> 00:14:19,480
here the compiler is very fine I know

00:14:15,130 --> 00:14:20,260
what it is please make the call if he is

00:14:19,480 --> 00:14:23,530
a guess right

00:14:20,260 --> 00:14:27,430
it's okay it's strong getting disaster

00:14:23,530 --> 00:14:31,480
and we all know this okay

00:14:27,430 --> 00:14:34,510
the the other thing is the linker when

00:14:31,480 --> 00:14:37,540
compiled as its magic and and put a

00:14:34,510 --> 00:14:40,480
bunch of simple definitions link it

00:14:37,540 --> 00:14:46,240
always sees is shrinking bites our 4x4

00:14:40,480 --> 00:14:49,330
by good go ahead right that's not good

00:14:46,240 --> 00:14:52,480
this will be getting other problems as

00:14:49,330 --> 00:14:54,940
an illustration here you have the basic

00:14:52,480 --> 00:14:58,900
linking model I have three source files

00:14:54,940 --> 00:15:00,250
on this slide the first so let's look at

00:14:58,900 --> 00:15:03,709
the middle

00:15:00,250 --> 00:15:05,630
you know in red you see these

00:15:03,709 --> 00:15:07,820
declarations with that translation unit

00:15:05,630 --> 00:15:10,640
is the one brandishing this declaration

00:15:07,820 --> 00:15:13,070
hey another body function quad it takes

00:15:10,640 --> 00:15:16,570
two in some returns an eight and I'm

00:15:13,070 --> 00:15:18,440
going to call it and compulsive okay

00:15:16,570 --> 00:15:21,860
then it will remit

00:15:18,440 --> 00:15:25,310
no please satisfy this simple definition

00:15:21,860 --> 00:15:27,769
a link time so if you bring in a source

00:15:25,310 --> 00:15:30,529
file it's a soft by one dot C see the

00:15:27,769 --> 00:15:33,560
thing I like here quant is just the sum

00:15:30,529 --> 00:15:37,610
of the squares of the argument you link

00:15:33,560 --> 00:15:40,880
them good get a program another that can

00:15:37,610 --> 00:15:42,730
come in say hey I have the quad it only

00:15:40,880 --> 00:15:46,220
adds the absolute values of the argument

00:15:42,730 --> 00:15:48,560
you can see from hostage get another

00:15:46,220 --> 00:15:53,120
program the only thing you cannot do is

00:15:48,560 --> 00:15:54,680
to put all three together something

00:15:53,120 --> 00:15:59,630
that's quite interesting here is that

00:15:54,680 --> 00:16:02,750
the the consumer of quad is one claiming

00:15:59,630 --> 00:16:05,270
that it knows something about quad right

00:16:02,750 --> 00:16:08,000
and this little things that accompany

00:16:05,270 --> 00:16:10,089
linker can actually do to verify all it

00:16:08,000 --> 00:16:15,020
verifies oh we have only one definition

00:16:10,089 --> 00:16:17,810
so if for example in in Sourcefire one

00:16:15,020 --> 00:16:21,980
to CC the return value was double guess

00:16:17,810 --> 00:16:25,520
what happens most of the time get

00:16:21,980 --> 00:16:27,350
garbage we have no way of verifying that

00:16:25,520 --> 00:16:30,140
and there is no fundamental reason we

00:16:27,350 --> 00:16:30,770
can't do better we can't with modules we

00:16:30,140 --> 00:16:33,529
can do better

00:16:30,770 --> 00:16:36,440
a person who is what to consume

00:16:33,529 --> 00:16:39,260
something has to request who is the

00:16:36,440 --> 00:16:42,920
provider in providing say here are set

00:16:39,260 --> 00:16:45,829
of things that you can use dot that way

00:16:42,920 --> 00:16:47,779
the linker get to see you know the

00:16:45,829 --> 00:16:49,640
entirety of what's going on and can

00:16:47,779 --> 00:16:52,160
translate no transfer information from

00:16:49,640 --> 00:16:58,670
one transition into the next and and

00:16:52,160 --> 00:17:00,589
into verification okay root cause is the

00:16:58,670 --> 00:17:03,769
one definition rule something that we

00:17:00,589 --> 00:17:06,520
hold very dear and I'm told that this

00:17:03,769 --> 00:17:09,140
was actually meant to be true also for C

00:17:06,520 --> 00:17:11,500
but in synthesis is even more

00:17:09,140 --> 00:17:16,449
fundamental so we're told mehe

00:17:11,500 --> 00:17:18,819
ask Dennis Ritchie in 79 I think I was

00:17:16,449 --> 00:17:22,420
probably somewhere in primary school or

00:17:18,819 --> 00:17:26,370
something of that and I didn't say well

00:17:22,420 --> 00:17:29,080
the idea was that you have exactly one

00:17:26,370 --> 00:17:31,930
section of so sticks that define

00:17:29,080 --> 00:17:36,280
something okay today years of what you

00:17:31,930 --> 00:17:38,230
want official you're supposed to copy

00:17:36,280 --> 00:17:41,560
things wrong and in fact that we have to

00:17:38,230 --> 00:17:43,120
include these at the time just a quick

00:17:41,560 --> 00:17:48,330
hack to get something up and running

00:17:43,120 --> 00:17:52,120
okay now when you take that very simple

00:17:48,330 --> 00:17:55,990
no design principle and you're looking

00:17:52,120 --> 00:18:01,290
for it in the standards document God you

00:17:55,990 --> 00:18:04,120
you you get pages of obscure text

00:18:01,290 --> 00:18:07,120
telling you how this one diffuse you're

00:18:04,120 --> 00:18:09,730
supposed to work sometimes compiles

00:18:07,120 --> 00:18:11,410
actually get it wrong wonderful finds me

00:18:09,730 --> 00:18:13,270
wrong for her oh haha but to get a lot

00:18:11,410 --> 00:18:15,010
of bugs and compilers based on one

00:18:13,270 --> 00:18:20,290
definition rules sometimes they are too

00:18:15,010 --> 00:18:23,320
eager sometimes naughty enough and part

00:18:20,290 --> 00:18:25,030
of nice obscurity of the text is the

00:18:23,320 --> 00:18:30,310
fact that we don't actually have a

00:18:25,030 --> 00:18:32,680
module system okay and the fact that the

00:18:30,310 --> 00:18:36,100
Texas obscure is just the reflection of

00:18:32,680 --> 00:18:39,430
this work around the lack of module so

00:18:36,100 --> 00:18:42,460
let's get modules okay so what is the

00:18:39,430 --> 00:18:47,140
module I don't have time so I'm just

00:18:42,460 --> 00:18:49,330
going to give you this you know 33,000

00:18:47,140 --> 00:18:53,500
feet view and I hope that is sufficient

00:18:49,330 --> 00:18:58,000
for you to get going or really using

00:18:53,500 --> 00:19:03,430
this stuff so essentially let's look at

00:18:58,000 --> 00:19:05,800
the example I started with the from a

00:19:03,430 --> 00:19:08,770
consumption point of view you just

00:19:05,800 --> 00:19:10,750
replace your hash includes with imports

00:19:08,770 --> 00:19:13,090
if let's say I'm taking dependency on

00:19:10,750 --> 00:19:16,900
you know module studio

00:19:13,090 --> 00:19:19,419
I'm dependency on module kill under the

00:19:16,900 --> 00:19:23,619
things and then you do the consumption

00:19:19,419 --> 00:19:27,239
now what really is going on is that a

00:19:23,619 --> 00:19:30,009
module is just a collection of let's say

00:19:27,239 --> 00:19:33,489
object files you have compiled of source

00:19:30,009 --> 00:19:37,089
code and then you have declared sets of

00:19:33,489 --> 00:19:40,659
entities to be the only entry point into

00:19:37,089 --> 00:19:43,599
this castle okay within that module you

00:19:40,659 --> 00:19:46,570
can have as many source files OBJ's as

00:19:43,599 --> 00:19:49,029
you want right it is not the motor is

00:19:46,570 --> 00:19:52,329
not necessarily just one file you can

00:19:49,029 --> 00:19:54,759
have many file just like we do today but

00:19:52,329 --> 00:19:57,249
what you get is you get one single place

00:19:54,759 --> 00:20:00,399
where you declare the entry point into

00:19:57,249 --> 00:20:04,239
that module anybody will want to consume

00:20:00,399 --> 00:20:07,959
module will have to depend only on those

00:20:04,239 --> 00:20:09,690
k-tec we can't get a a function name

00:20:07,959 --> 00:20:12,489
because you look at the header file

00:20:09,690 --> 00:20:15,749
right you can use only the things that

00:20:12,489 --> 00:20:19,450
modules would you provide it gives you

00:20:15,749 --> 00:20:21,249
so as a symbolic name here I propose

00:20:19,450 --> 00:20:25,089
that you use if you are about naming I

00:20:21,249 --> 00:20:28,479
call it my module and on from the slide

00:20:25,089 --> 00:20:31,419
you get to the two dot IO Canada update

00:20:28,479 --> 00:20:34,749
it's kind of naming module names are not

00:20:31,419 --> 00:20:36,489
in the same namespace as classes or

00:20:34,749 --> 00:20:39,209
class names or namespace names they're

00:20:36,489 --> 00:20:44,169
completely separate names if you don't

00:20:39,209 --> 00:20:46,209
risk having clash of names between type

00:20:44,169 --> 00:20:50,769
names and and module names I think

00:20:46,209 --> 00:20:53,019
that's essential so only on

00:20:50,769 --> 00:20:56,950
implementation side here's what you can

00:20:53,019 --> 00:21:00,489
do right you go to use today or to

00:20:56,950 --> 00:21:03,009
implement no formatting so say I'm going

00:21:00,489 --> 00:21:05,379
to take dependency on studio I'm also

00:21:03,009 --> 00:21:06,809
going to take dependency of I'm still

00:21:05,379 --> 00:21:09,039
string because I'm going to give

00:21:06,809 --> 00:21:12,820
representation string representation of

00:21:09,039 --> 00:21:15,849
the date and then you declare module

00:21:12,820 --> 00:21:20,649
Sony the first line there module

00:21:15,849 --> 00:21:23,499
calendar the date is the line that says

00:21:20,649 --> 00:21:26,339
this source file is part of the module

00:21:23,499 --> 00:21:26,339
calendar

00:21:26,680 --> 00:21:33,830
and anything that comes after that line

00:21:30,950 --> 00:21:36,680
is part of the module

00:21:33,830 --> 00:21:40,070
anything that is before is not part of

00:21:36,680 --> 00:21:41,780
your model okay so before you have the

00:21:40,070 --> 00:21:44,890
module declaration you can't have

00:21:41,780 --> 00:21:56,420
include files it worked too

00:21:44,890 --> 00:21:59,150
so here on on this slide then it gets a

00:21:56,420 --> 00:22:02,030
namespace all namespaces are always

00:21:59,150 --> 00:22:07,940
exporting because today what we have is

00:22:02,030 --> 00:22:11,600
that a namespace you know expands across

00:22:07,940 --> 00:22:13,880
several source files right so the only

00:22:11,600 --> 00:22:16,370
way you get your local namespace is

00:22:13,880 --> 00:22:18,230
either you have a animals namespace or

00:22:16,370 --> 00:22:20,060
you put the namespaces seven on English

00:22:18,230 --> 00:22:21,950
names that's how you make names they

00:22:20,060 --> 00:22:25,550
still owe it all to two module we don't

00:22:21,950 --> 00:22:27,350
change that and then they'll put your

00:22:25,550 --> 00:22:29,630
declarations the only thing that is new

00:22:27,350 --> 00:22:31,310
is you stick the keyword exports in

00:22:29,630 --> 00:22:34,220
front of the definition or Declaration

00:22:31,310 --> 00:22:37,100
dot okay export is an existing keyword

00:22:34,220 --> 00:22:39,950
that doesn't have any meaning in

00:22:37,100 --> 00:22:46,670
super-stressed 14 i'm just repurposing

00:22:39,950 --> 00:22:48,200
it for for forego jewel coach if you

00:22:46,670 --> 00:22:51,260
feel like you're tired you don't want to

00:22:48,200 --> 00:22:53,360
put expert on every definition you can

00:22:51,260 --> 00:22:55,370
you can just put the experts on the

00:22:53,360 --> 00:22:58,610
namespace and everything that's between

00:22:55,370 --> 00:23:02,330
the opening brace and closed breaks get

00:22:58,610 --> 00:23:05,210
exported it's just a shorthand and of

00:23:02,330 --> 00:23:10,190
course you can also use in code files

00:23:05,210 --> 00:23:12,230
and so I say you can include any header

00:23:10,190 --> 00:23:14,300
file that we have today as soon as you

00:23:12,230 --> 00:23:16,220
do that before the module declarations

00:23:14,300 --> 00:23:19,370
then they are not owned by a multi

00:23:16,220 --> 00:23:21,710
declaration so my recommendations is

00:23:19,370 --> 00:23:22,910
money have modules you write in your

00:23:21,710 --> 00:23:25,910
source file whether it's you're

00:23:22,910 --> 00:23:29,210
consuming on producing first if you have

00:23:25,910 --> 00:23:34,040
to use it could include file first put

00:23:29,210 --> 00:23:35,660
the includes always second puts the

00:23:34,040 --> 00:23:37,670
import statement if you're taking

00:23:35,660 --> 00:23:40,590
symbolic dependency

00:23:37,670 --> 00:23:43,860
thirds right promoted occurs in module

00:23:40,590 --> 00:23:48,600
name then exports whatever you need to

00:23:43,860 --> 00:23:51,660
explore okay if you do that systemically

00:23:48,600 --> 00:23:54,299
you will not get any surprise okay

00:23:51,660 --> 00:23:55,920
surprise you I mean we know today that

00:23:54,299 --> 00:23:58,350
you have to be very careful about the

00:23:55,920 --> 00:24:04,350
order of inclusion otherwise you get big

00:23:58,350 --> 00:24:07,970
surprises it's hard to debug so that is

00:24:04,350 --> 00:24:16,799
basically all you need to know okay so

00:24:07,970 --> 00:24:21,600
we're done quite summary what um now

00:24:16,799 --> 00:24:24,510
this design is promising is that you get

00:24:21,600 --> 00:24:26,850
complete isolation from macros when you

00:24:24,510 --> 00:24:31,440
import a module so let's say bought

00:24:26,850 --> 00:24:34,049
module studio the way the compiler bring

00:24:31,440 --> 00:24:36,600
it to you is as if that module has

00:24:34,049 --> 00:24:39,419
already been compiled so in the standard

00:24:36,600 --> 00:24:42,150
jargon we say has been processed through

00:24:39,419 --> 00:24:44,190
from translation phase one through seven

00:24:42,150 --> 00:24:46,950
don't worry about it just meant it has

00:24:44,190 --> 00:24:49,820
already been compiled in some form if

00:24:46,950 --> 00:24:52,950
you if someone defines a macro in that

00:24:49,820 --> 00:24:57,660
module in that interface you don't get

00:24:52,950 --> 00:24:59,400
it if you define a macro in your source

00:24:57,660 --> 00:25:02,010
file before you dream import because you

00:24:59,400 --> 00:25:04,890
have some good file that play that in

00:25:02,010 --> 00:25:06,720
you don't disturb the the model was

00:25:04,890 --> 00:25:09,120
given to you because that module was

00:25:06,720 --> 00:25:10,980
already processed before you get to

00:25:09,120 --> 00:25:13,890
consume it so you get complete isolation

00:25:10,980 --> 00:25:14,340
from microbes this is not science

00:25:13,890 --> 00:25:16,530
fiction

00:25:14,340 --> 00:25:20,880
it's what you're going to get from the

00:25:16,530 --> 00:25:24,240
visual C++ implementation the other

00:25:20,880 --> 00:25:29,760
thing is that now we actually have the

00:25:24,240 --> 00:25:34,290
OTR in this sense that every entity that

00:25:29,760 --> 00:25:37,380
is defined in exported in module as a

00:25:34,290 --> 00:25:39,179
unique place you go and look okay you

00:25:37,380 --> 00:25:40,950
don't get these header files that you

00:25:39,179 --> 00:25:43,530
have to include that gets copied in

00:25:40,950 --> 00:25:46,650
several places no you have defined your

00:25:43,530 --> 00:25:47,520
entity only one place as dentistry to

00:25:46,650 --> 00:25:49,380
say it

00:25:47,520 --> 00:25:51,179
and then when you when you compile in

00:25:49,380 --> 00:25:55,500
both your interface the compiler

00:25:51,179 --> 00:25:57,150
generates some metadata to remember how

00:25:55,500 --> 00:25:58,980
the corrosion looks like what is the

00:25:57,150 --> 00:26:01,050
type of the argument or it's a class but

00:25:58,980 --> 00:26:03,510
I remember is that kind of stuff but you

00:26:01,050 --> 00:26:05,070
don't get to process that thing's as if

00:26:03,510 --> 00:26:09,890
you're parsing lexing over and over

00:26:05,070 --> 00:26:13,830
again it's really really no already done

00:26:09,890 --> 00:26:16,920
the other thing is whatever we do I

00:26:13,830 --> 00:26:21,059
really hope we don't come up with a new

00:26:16,920 --> 00:26:22,860
name lookup row I don't know how many

00:26:21,059 --> 00:26:24,840
name lookup rules we have but I think

00:26:22,860 --> 00:26:27,450
you have too many and we don't need

00:26:24,840 --> 00:26:29,400
another set I haven't seen any

00:26:27,450 --> 00:26:31,160
improvement to simpler stuff Denver cop

00:26:29,400 --> 00:26:37,530
rules that didn't backfire

00:26:31,160 --> 00:26:42,570
so we'll try very hard to stay there and

00:26:37,530 --> 00:26:48,000
not bring you the other thing that you

00:26:42,570 --> 00:26:51,720
need to remember is that I want you to

00:26:48,000 --> 00:26:53,790
prefer modules over header files however

00:26:51,720 --> 00:26:57,120
we are not going to get rid of Paper

00:26:53,790 --> 00:26:59,400
Scissors there are situations where the

00:26:57,120 --> 00:27:01,910
best thing we can have today when it

00:26:59,400 --> 00:27:05,700
gets modules is still include five

00:27:01,910 --> 00:27:07,710
circles if you get to generate just text

00:27:05,700 --> 00:27:10,170
you know sometimes you have these little

00:27:07,710 --> 00:27:13,230
things that you want to generate just no

00:27:10,170 --> 00:27:16,350
state you include the file several time

00:27:13,230 --> 00:27:19,200
right that's not modular a you just want

00:27:16,350 --> 00:27:21,300
to generate it you continue using those

00:27:19,200 --> 00:27:23,370
include files and if you define macro

00:27:21,300 --> 00:27:26,000
they will not escape from the module it

00:27:23,370 --> 00:27:28,740
will be completely encapsulated and

00:27:26,000 --> 00:27:33,900
real-time will be faster

00:27:28,740 --> 00:27:35,640
now many people modules how do you get

00:27:33,900 --> 00:27:39,780
interact with this whatever you know the

00:27:35,640 --> 00:27:42,809
rules of engagement anything you have to

00:27:39,780 --> 00:27:45,420
expect and really want to emphasize this

00:27:42,809 --> 00:27:47,490
is that you get Odia

00:27:45,420 --> 00:27:51,270
to the best that we can approximate

00:27:47,490 --> 00:27:54,929
because we still have to use no good

00:27:51,270 --> 00:27:57,240
files for certain things but entities in

00:27:54,929 --> 00:27:59,580
general are defined all in one place

00:27:57,240 --> 00:28:05,250
so you get to be able to develop tools

00:27:59,580 --> 00:28:07,380
that would be less painful to write

00:28:05,250 --> 00:28:10,409
right today when you're looking for a

00:28:07,380 --> 00:28:12,690
class you have two classes to first five

00:28:10,409 --> 00:28:15,029
distant source fires even you're

00:28:12,690 --> 00:28:16,679
supposed to just say oh it's the finally

00:28:15,029 --> 00:28:18,450
ones you still have to go and compare

00:28:16,679 --> 00:28:20,730
the fish and eventually say oh they are

00:28:18,450 --> 00:28:23,159
the same as how you get these abysmal

00:28:20,730 --> 00:28:25,080
performance for things like our ttio

00:28:23,159 --> 00:28:27,690
dynamic cast where some implementations

00:28:25,080 --> 00:28:30,149
will just go and compare strings instead

00:28:27,690 --> 00:28:32,100
of comparing pointers right because you

00:28:30,149 --> 00:28:32,779
know you have these talking things going

00:28:32,100 --> 00:28:37,200
on

00:28:32,779 --> 00:28:38,370
the other thing good news is that if hey

00:28:37,200 --> 00:28:42,419
so sorry

00:28:38,370 --> 00:28:44,880
remember I said when you're consuming or

00:28:42,419 --> 00:28:47,460
producing modules you put your input

00:28:44,880 --> 00:28:49,590
files import statement both of

00:28:47,460 --> 00:28:51,480
declarations and your definitions right

00:28:49,590 --> 00:28:52,679
so imagine for a second that you don't

00:28:51,480 --> 00:28:56,159
care about header files now you have

00:28:52,679 --> 00:28:58,740
import statement the order of importance

00:28:56,159 --> 00:29:01,710
meant will not matter anymore

00:28:58,740 --> 00:29:03,659
I became permeate you don't have to know

00:29:01,710 --> 00:29:06,690
to worry about Oh which one have to

00:29:03,659 --> 00:29:10,169
import first no it's irrelevant

00:29:06,690 --> 00:29:14,520
okay again modules are easily from

00:29:10,169 --> 00:29:17,789
macros and the other thing that are

00:29:14,520 --> 00:29:22,080
pulling out earlier is that with the

00:29:17,789 --> 00:29:25,799
include file we pay for things with on

00:29:22,080 --> 00:29:31,080
you with modules we pay only for things

00:29:25,799 --> 00:29:33,149
we use if we repair all right so you

00:29:31,080 --> 00:29:35,880
have this kind of you say import what

00:29:33,149 --> 00:29:39,720
the compiler does is it's Liz Lee brings

00:29:35,880 --> 00:29:41,220
into life the entities in fact doesn't

00:29:39,720 --> 00:29:44,279
matter as anything it just brings any

00:29:41,220 --> 00:29:47,279
name when you happen to reference stood

00:29:44,279 --> 00:29:49,559
vector Oh someone is asking for stood

00:29:47,279 --> 00:29:52,200
what is too documentary is good what is

00:29:49,559 --> 00:29:55,950
vector or given vector anything else

00:29:52,200 --> 00:29:57,580
that was in their source file is not if

00:29:55,950 --> 00:30:00,820
it is not used

00:29:57,580 --> 00:30:05,140
life so really pay for only four things

00:30:00,820 --> 00:30:09,190
to use and and this is places where we

00:30:05,140 --> 00:30:14,560
getting the improvement spinning profit

00:30:09,190 --> 00:30:16,960
the compiler will generate metadata use

00:30:14,560 --> 00:30:18,760
you can use these to transfer

00:30:16,960 --> 00:30:23,050
information from one source five the

00:30:18,760 --> 00:30:25,960
next and and the other thing is

00:30:23,050 --> 00:30:29,920
ownership so what I call ownership is go

00:30:25,960 --> 00:30:33,490
back to the OD are the when you have a

00:30:29,920 --> 00:30:37,210
an entity class function a variable

00:30:33,490 --> 00:30:41,770
global constant that is exported from a

00:30:37,210 --> 00:30:44,350
module B that entity has an entity right

00:30:41,770 --> 00:30:46,840
and the module where it is defined is

00:30:44,350 --> 00:30:49,960
part of it okay

00:30:46,840 --> 00:30:52,450
this is specially true for things that

00:30:49,960 --> 00:30:54,130
I'm not exported but for tailor exported

00:30:52,450 --> 00:30:56,560
this is what I propose I know that we

00:30:54,130 --> 00:30:58,270
still have some work to do in a turret

00:30:56,560 --> 00:31:02,860
have agreements among the implementers

00:30:58,270 --> 00:31:04,570
but the idea is that the modules have

00:31:02,860 --> 00:31:06,940
strong ownership of the entities that

00:31:04,570 --> 00:31:08,440
will allow you to have better

00:31:06,940 --> 00:31:10,780
performance in terms of you know a

00:31:08,440 --> 00:31:13,420
dynamic past four classes that it occurs

00:31:10,780 --> 00:31:14,950
several modules you don't know you don't

00:31:13,420 --> 00:31:17,400
have to worry about what area it is same

00:31:14,950 --> 00:31:20,260
when it happened to be in distant

00:31:17,400 --> 00:31:23,200
modules they are different they

00:31:20,260 --> 00:31:30,970
understand it cannot possibly it same so

00:31:23,200 --> 00:31:33,040
we get some transport there just a quick

00:31:30,970 --> 00:31:38,170
submarine it based basically under some

00:31:33,040 --> 00:31:41,620
terminology we we need modules to work

00:31:38,170 --> 00:31:43,450
with things we have today things we have

00:31:41,620 --> 00:31:46,000
today is that you include hello fire to

00:31:43,450 --> 00:31:48,310
define you know entity using server

00:31:46,000 --> 00:31:51,880
concepts you need so you have to match

00:31:48,310 --> 00:31:54,970
them together but when we have modules

00:31:51,880 --> 00:31:56,650
modules own stuff the own stuff that are

00:31:54,970 --> 00:31:59,230
in their purview so what I call it

00:31:56,650 --> 00:32:01,979
purview of a module is every declaration

00:31:59,230 --> 00:32:07,269
that appears after mode

00:32:01,979 --> 00:32:11,139
so the new class month here isn't a

00:32:07,269 --> 00:32:13,839
purview of module calendar that month so

00:32:11,139 --> 00:32:15,609
it is owned by that mode and that comes

00:32:13,839 --> 00:32:17,379
before if I had some profile that

00:32:15,609 --> 00:32:21,700
defined some software they are not owned

00:32:17,379 --> 00:32:24,039
by however if you don't follow the

00:32:21,700 --> 00:32:26,799
guideline si which is you put the

00:32:24,039 --> 00:32:29,080
include fire after the module

00:32:26,799 --> 00:32:31,929
declaration remember what hashing to

00:32:29,080 --> 00:32:34,539
this it goes and copy and paste the

00:32:31,929 --> 00:32:36,789
content so you accidentally bring

00:32:34,539 --> 00:32:38,769
something that is owned by an alum but

00:32:36,789 --> 00:32:40,779
you get into trouble so please don't do

00:32:38,769 --> 00:32:42,879
that that's why you put all your include

00:32:40,779 --> 00:32:45,339
first the ending in course any module

00:32:42,879 --> 00:32:48,789
declaration so this basically probably

00:32:45,339 --> 00:32:52,450
only really to pay attention to really

00:32:48,789 --> 00:32:54,879
happy you poor declaration I've said

00:32:52,450 --> 00:32:58,179
earlier that I don't want a new set of

00:32:54,879 --> 00:33:01,629
numerical rules yet we have namespaces

00:32:58,179 --> 00:33:03,940
that span several modules and Sourcefire

00:33:01,629 --> 00:33:06,969
so how does that work the way it works

00:33:03,940 --> 00:33:10,149
is we have to go back and look at what

00:33:06,969 --> 00:33:12,940
it really is we're doing today and say

00:33:10,149 --> 00:33:15,429
well when you complain your source file

00:33:12,940 --> 00:33:19,119
the only thing that the compiler really

00:33:15,429 --> 00:33:22,320
sees is the portion of that namespace in

00:33:19,119 --> 00:33:24,759
your source file right namespace STD

00:33:22,320 --> 00:33:27,009
spans several from special units right

00:33:24,759 --> 00:33:30,429
but when you compile source file it's

00:33:27,009 --> 00:33:32,019
only that portion of namespace that the

00:33:30,429 --> 00:33:35,320
compiler sees it doesn't know whether

00:33:32,019 --> 00:33:37,299
list exists unless you bring list in yet

00:33:35,320 --> 00:33:40,359
you'll be different on special units you

00:33:37,299 --> 00:33:43,149
get lists to make the nimac approach

00:33:40,359 --> 00:33:44,889
work properly just the winner today we

00:33:43,149 --> 00:33:47,769
get to define you know introduce this

00:33:44,889 --> 00:33:49,570
notion of namespace partition we just

00:33:47,769 --> 00:33:50,080
formalize this notion that well a

00:33:49,570 --> 00:33:53,169
namespace

00:33:50,080 --> 00:33:55,029
a namespace partition is the portion of

00:33:53,169 --> 00:33:59,139
a namespace that is defined in the

00:33:55,029 --> 00:34:00,940
purview of the module so it all rules

00:33:59,139 --> 00:34:02,529
you know about namespace today if you

00:34:00,940 --> 00:34:04,239
replace names days with news these

00:34:02,529 --> 00:34:05,739
partitions they work exactly the same

00:34:04,239 --> 00:34:07,359
and you're done that's the only thing

00:34:05,739 --> 00:34:17,740
you need not

00:34:07,359 --> 00:34:20,750
okay so ownership I said earlier that

00:34:17,740 --> 00:34:24,500
every entity that is defined in the

00:34:20,750 --> 00:34:30,379
program is owned by some module and I

00:34:24,500 --> 00:34:33,230
know this is a point design point that

00:34:30,379 --> 00:34:37,550
we see working on inside I actually pass

00:34:33,230 --> 00:34:41,389
first committee but it comes from you

00:34:37,550 --> 00:34:43,460
know needs today we talk what are you

00:34:41,389 --> 00:34:45,770
talking about these ownership thing we

00:34:43,460 --> 00:34:49,280
you know the only vocabulary that the

00:34:45,770 --> 00:34:51,829
language give us is linkage you see

00:34:49,280 --> 00:34:54,260
external linkage symbol that's visible

00:34:51,829 --> 00:34:57,260
by everybody else internal linkage

00:34:54,260 --> 00:34:59,030
there's only one translation units and

00:34:57,260 --> 00:35:02,800
then no linkage so if you define local

00:34:59,030 --> 00:35:06,319
clash that little class has no leakage

00:35:02,800 --> 00:35:09,260
but when you're in module you get to

00:35:06,319 --> 00:35:12,140
define some symbols like you know it's

00:35:09,260 --> 00:35:14,540
used by source files in that module but

00:35:12,140 --> 00:35:18,500
you don't intend for them to be used of

00:35:14,540 --> 00:35:21,260
to be visible by folks outside that

00:35:18,500 --> 00:35:25,160
module right so you get a formation of

00:35:21,260 --> 00:35:28,040
linkage and you can go on I I don't like

00:35:25,160 --> 00:35:30,920
the notion of linkage I think it is a

00:35:28,040 --> 00:35:32,930
very low level abstraction something

00:35:30,920 --> 00:35:37,510
that's very implementation orientated

00:35:32,930 --> 00:35:41,089
and the proposal as it stands so far as

00:35:37,510 --> 00:35:45,339
try very hard to stay away from module

00:35:41,089 --> 00:35:45,339
also from not so much

00:35:45,950 --> 00:35:55,609
from linkage so what we have to do is

00:35:51,480 --> 00:35:57,780
just you know biting strings and and and

00:35:55,609 --> 00:36:00,540
interning cage externally kids

00:35:57,780 --> 00:36:04,500
the reality is that a component we have

00:36:00,540 --> 00:36:05,220
I already aware that these three linkage

00:36:04,500 --> 00:36:08,220
certs

00:36:05,220 --> 00:36:11,670
don't don't work they had this notion of

00:36:08,220 --> 00:36:13,680
you know visibility you know this is

00:36:11,670 --> 00:36:16,070
theologian clung allows you to put

00:36:13,680 --> 00:36:18,000
attributes on declaration say Oh

00:36:16,070 --> 00:36:20,040
invisibility of this symbol so

00:36:18,000 --> 00:36:21,960
visibility here is a little incredible

00:36:20,040 --> 00:36:25,890
is the default which means whatever

00:36:21,960 --> 00:36:28,380
language says I say oh it is hidden so

00:36:25,890 --> 00:36:31,830
it's actually it means that this symbol

00:36:28,380 --> 00:36:34,820
is defined in this module and you cannot

00:36:31,830 --> 00:36:37,260
lexically use it in a different module

00:36:34,820 --> 00:36:39,030
but you might be able to take the

00:36:37,260 --> 00:36:42,180
address of that entity and pass it along

00:36:39,030 --> 00:36:44,070
to another module internal really safe

00:36:42,180 --> 00:36:47,369
it cannot even take the address of this

00:36:44,070 --> 00:36:50,910
entity and give it to another module so

00:36:47,369 --> 00:36:53,760
this allows you faster link and you can

00:36:50,910 --> 00:36:55,770
import things like you know Artie is an

00:36:53,760 --> 00:36:57,330
Democrats that are kind of no very

00:36:55,770 --> 00:36:58,890
efficiently because now you know the

00:36:57,330 --> 00:37:00,180
boundaries of your entities you don't

00:36:58,890 --> 00:37:03,930
need to do these three compare you know

00:37:00,180 --> 00:37:06,720
where you are so and of course if you

00:37:03,930 --> 00:37:09,450
C++ has its own set of visibility rules

00:37:06,720 --> 00:37:11,250
we've really important experts I was

00:37:09,450 --> 00:37:13,260
looking to guarantee is that when you

00:37:11,250 --> 00:37:15,600
get receivers plastic rotation for of

00:37:13,260 --> 00:37:18,780
modules the only thing you have to care

00:37:15,600 --> 00:37:22,140
about for now is DLL export because the

00:37:18,780 --> 00:37:25,590
11-part is automatically handled by the

00:37:22,140 --> 00:37:29,960
compiler it's something that I know is

00:37:25,590 --> 00:37:34,290
folks so you get them very confused so

00:37:29,960 --> 00:37:37,080
to support I talked about know the

00:37:34,290 --> 00:37:38,840
general view aspect things you can

00:37:37,080 --> 00:37:41,430
expect and how does it work

00:37:38,840 --> 00:37:42,810
I'm not going to do live them all

00:37:41,430 --> 00:37:44,640
there's a lot of time I don't have

00:37:42,810 --> 00:37:46,640
everything set up but I'm going to give

00:37:44,640 --> 00:37:51,180
you an overview is that kind of dot

00:37:46,640 --> 00:37:55,260
which what's going to happen so when you

00:37:51,180 --> 00:37:57,460
have your first file and use modules the

00:37:55,260 --> 00:38:01,000
way you compile these

00:37:57,460 --> 00:38:04,510
invoke your CL as usual the - see for

00:38:01,000 --> 00:38:06,910
example and to enable the module

00:38:04,510 --> 00:38:11,680
cymatics you have to supply the switch

00:38:06,910 --> 00:38:14,950
module right / module all - module what

00:38:11,680 --> 00:38:17,680
happens when you do that is as usual the

00:38:14,950 --> 00:38:21,850
component is going to produce the obj

00:38:17,680 --> 00:38:24,850
file however because you have modules

00:38:21,850 --> 00:38:27,910
now we can actually generate metadata it

00:38:24,850 --> 00:38:30,430
is essentially the you know a semantics

00:38:27,910 --> 00:38:32,950
drive of the all the entities that you

00:38:30,430 --> 00:38:34,780
have exported from that module right you

00:38:32,950 --> 00:38:37,570
have this distinguish suffice module

00:38:34,780 --> 00:38:40,300
interface and compile it it generates

00:38:37,570 --> 00:38:42,940
that me to do that all I have c5 and

00:38:40,300 --> 00:38:45,790
that's the only thing that you need to

00:38:42,940 --> 00:38:48,040
consume that module so imagine using

00:38:45,790 --> 00:38:50,680
compression you compile the source file

00:38:48,040 --> 00:38:54,090
contains the interface file it generates

00:38:50,680 --> 00:38:57,130
an IFC file then you can continue in

00:38:54,090 --> 00:38:58,000
parallel compiling the source file in

00:38:57,130 --> 00:39:01,300
these modules

00:38:58,000 --> 00:39:04,330
sorry net module but you can also start

00:39:01,300 --> 00:39:05,920
compiling all the consumers after that

00:39:04,330 --> 00:39:09,130
module because all they have to care

00:39:05,920 --> 00:39:12,310
about is the set of expert it is there

00:39:09,130 --> 00:39:24,190
so you get this kind of built in little

00:39:12,310 --> 00:39:26,320
person so now we have a source file you

00:39:24,190 --> 00:39:29,070
really want to see this source file is

00:39:26,320 --> 00:39:32,890
the one that contains the the interface

00:39:29,070 --> 00:39:35,980
explicitly supply the street slash

00:39:32,890 --> 00:39:38,890
module interface and only construction

00:39:35,980 --> 00:39:41,830
site all you have to do if you combine a

00:39:38,890 --> 00:39:46,860
source file that imports a module you

00:39:41,830 --> 00:39:49,660
have to supply your first enable the

00:39:46,860 --> 00:39:52,840
module semantics but you also to supply

00:39:49,660 --> 00:39:55,150
a switch that says oh I'm referencing a

00:39:52,840 --> 00:39:59,530
module in that file okay

00:39:55,150 --> 00:40:01,300
in fact we can have any file okay today

00:39:59,530 --> 00:40:05,310
when it's all we think about source

00:40:01,300 --> 00:40:07,109
pinna fires visually helps you say

00:40:05,310 --> 00:40:12,089
include Canada

00:40:07,109 --> 00:40:15,769
dates / div dot H we expect somehow to

00:40:12,089 --> 00:40:20,489
have a file or if fascism somewhere name

00:40:15,769 --> 00:40:22,619
dates of H in the folder calendar that's

00:40:20,489 --> 00:40:25,349
under something let's search somehow

00:40:22,619 --> 00:40:29,160
right with modules there is no

00:40:25,349 --> 00:40:32,309
requirement of a kind of one one-to-one

00:40:29,160 --> 00:40:34,529
mapping between the module name and the

00:40:32,309 --> 00:40:37,559
binary file that contains the module

00:40:34,529 --> 00:40:40,529
interface diffusion it's purely

00:40:37,559 --> 00:40:46,380
content-based and we find this very

00:40:40,529 --> 00:40:49,079
important the circle options you have

00:40:46,380 --> 00:40:52,200
essentially have no / module that turns

00:40:49,079 --> 00:40:56,219
on mono semantics you have module

00:40:52,200 --> 00:40:59,549
interface that that's the the fly that

00:40:56,219 --> 00:41:02,579
you use to compile the designated source

00:40:59,549 --> 00:41:04,469
file that contains all the expert any

00:41:02,579 --> 00:41:06,089
given module can only have one source

00:41:04,469 --> 00:41:08,640
file that has the exports all the others

00:41:06,089 --> 00:41:12,180
are just incrementation units one that's

00:41:08,640 --> 00:41:16,380
interface and once you compile it into

00:41:12,180 --> 00:41:18,569
some binary format if you use module and

00:41:16,380 --> 00:41:21,180
that module interface is in some binary

00:41:18,569 --> 00:41:23,999
format you will reference that in a

00:41:21,180 --> 00:41:26,640
command line is slash module so even

00:41:23,999 --> 00:41:29,729
slash module reference that fine name

00:41:26,640 --> 00:41:32,099
any compiler will use it you know and

00:41:29,729 --> 00:41:35,839
try to find module interface definition

00:41:32,099 --> 00:41:41,670
if you can find it will tell you and

00:41:35,839 --> 00:41:44,640
then you'll see in fourth option which

00:41:41,670 --> 00:41:47,729
is there essentially to help folks who

00:41:44,640 --> 00:41:50,279
do build on one machine and deploying a

00:41:47,729 --> 00:41:53,309
different machine where you can actually

00:41:50,279 --> 00:41:55,709
reference the binary files by absolute

00:41:53,309 --> 00:41:59,819
path because when it deploy it's going

00:41:55,709 --> 00:42:02,400
to be in a different file system so you

00:41:59,819 --> 00:42:03,869
can tell the compiler here is the set of

00:42:02,400 --> 00:42:06,269
directories that you can search for

00:42:03,869 --> 00:42:09,839
these files that I'm referencing on the

00:42:06,269 --> 00:42:12,839
command line okay and you know one thing

00:42:09,839 --> 00:42:15,180
that comes bonus is if you happen to

00:42:12,839 --> 00:42:18,569
have the same reference files in

00:42:15,180 --> 00:42:19,510
different directories then the compiler

00:42:18,569 --> 00:42:21,700
will tell you some

00:42:19,510 --> 00:42:30,010
we don't do today with a good fire which

00:42:21,700 --> 00:42:31,420
allows geniuses to create havoc so we

00:42:30,010 --> 00:42:34,450
have an affianced today

00:42:31,420 --> 00:42:37,030
some of them like system header files

00:42:34,450 --> 00:42:39,760
they are not mojo at all what I mean by

00:42:37,030 --> 00:42:43,470
modular is there a lot of macros you

00:42:39,760 --> 00:42:47,530
know if they have it's it's insane okay

00:42:43,470 --> 00:42:50,400
take Windows dot H it's nightmare

00:42:47,530 --> 00:42:55,210
now I'm not picking on my employer take

00:42:50,400 --> 00:42:58,720
uni STD dot H same nightmare okay so it

00:42:55,210 --> 00:43:02,160
is just system header file but if you

00:42:58,720 --> 00:43:02,160
happen to have something like infected

00:43:03,090 --> 00:43:12,850
like Canada dot H which is the you have

00:43:09,460 --> 00:43:15,040
a compulsory that allow you to consume

00:43:12,850 --> 00:43:16,840
it as if it was a module they will you

00:43:15,040 --> 00:43:20,020
do it is just included in the source

00:43:16,840 --> 00:43:22,270
file and compile any compiler please

00:43:20,020 --> 00:43:24,280
export this source file as if it was a

00:43:22,270 --> 00:43:25,960
module and the only command line you

00:43:24,280 --> 00:43:28,990
give a command you know the name of your

00:43:25,960 --> 00:43:31,720
module and what the compiler will do is

00:43:28,990 --> 00:43:34,150
well I'll pretend that every top-level

00:43:31,720 --> 00:43:37,570
declaration top level meaning namespace

00:43:34,150 --> 00:43:39,640
scope no next to them as if they were

00:43:37,570 --> 00:43:42,210
exploited if something is declared

00:43:39,640 --> 00:43:44,470
static it's ignored if something is in

00:43:42,210 --> 00:43:47,620
unnamed names which it is ignore but

00:43:44,470 --> 00:43:51,220
anything else that top level is is

00:43:47,620 --> 00:43:55,870
compiled as if it was prefixed with the

00:43:51,220 --> 00:43:58,510
keyword export this is to a folks moving

00:43:55,870 --> 00:44:01,360
from header file based architecture to

00:43:58,510 --> 00:44:10,720
module architecture and has been used

00:44:01,360 --> 00:44:14,500
internally at Microsoft so I made a huge

00:44:10,720 --> 00:44:17,470
first about matters yet here we have a a

00:44:14,500 --> 00:44:19,890
compulsory say that's a Oh X for this

00:44:17,470 --> 00:44:19,890
Metro

00:44:20,160 --> 00:44:25,590
in the ideal world I don't want to hear

00:44:22,800 --> 00:44:28,970
about macros but only in the idea words

00:44:25,590 --> 00:44:32,130
I have to you know do with what I get

00:44:28,970 --> 00:44:34,080
when you get some system verifier you

00:44:32,130 --> 00:44:38,340
get macros that cannot do with that

00:44:34,080 --> 00:44:41,610
right so let let take two IO dot H from

00:44:38,340 --> 00:44:43,800
see this Easterners say is that you can

00:44:41,610 --> 00:44:47,820
either have they're defined as an object

00:44:43,800 --> 00:44:49,860
o as a macro so the first experiment I

00:44:47,820 --> 00:44:52,260
did with the Microsoft compiler say hey

00:44:49,860 --> 00:44:53,550
let's turn to the IO dot H into

00:44:52,260 --> 00:44:59,130
something you can consume as a module

00:44:53,550 --> 00:45:01,470
great works now imports today oh no F

00:44:59,130 --> 00:45:03,960
printf stood out oops

00:45:01,470 --> 00:45:05,100
I know what stood out is what do you

00:45:03,960 --> 00:45:06,690
mean you don't know what stood out is

00:45:05,100 --> 00:45:11,160
never getting in a fire

00:45:06,690 --> 00:45:13,530
oh it is defined as a macro so for

00:45:11,160 --> 00:45:16,620
transitional you know when we want to

00:45:13,530 --> 00:45:19,920
turn things and a header files based on

00:45:16,620 --> 00:45:22,050
macros into you know something that you

00:45:19,920 --> 00:45:24,840
can consume it is not automatic

00:45:22,050 --> 00:45:27,510
modularization it is you just compile it

00:45:24,840 --> 00:45:31,620
can consume as a module sometimes it is

00:45:27,510 --> 00:45:34,860
necessary to have these selected macros

00:45:31,620 --> 00:45:37,980
as okay you know I you know all the

00:45:34,860 --> 00:45:40,320
other macros except these no these few

00:45:37,980 --> 00:45:42,360
and and export them now I have to be

00:45:40,320 --> 00:45:44,220
very careful there is no depe dependence

00:45:42,360 --> 00:45:46,890
analysis but whether you explain the

00:45:44,220 --> 00:45:51,540
right thing or so forth so it is there

00:45:46,890 --> 00:45:53,790
just to eight you for you know in

00:45:51,540 --> 00:45:56,280
transition transitioning from source

00:45:53,790 --> 00:46:02,490
file based architecture to module thank

00:45:56,280 --> 00:46:06,660
you okay so this metadata and I recall

00:46:02,490 --> 00:46:09,090
in IFC so essentially now when you

00:46:06,660 --> 00:46:12,770
compile a module interface source file

00:46:09,090 --> 00:46:18,750
which generates what I call the abstract

00:46:12,770 --> 00:46:23,010
semantics graph of the x4e declaration

00:46:18,750 --> 00:46:24,330
it is a different representation I can

00:46:23,010 --> 00:46:27,320
think of it as a different presentation

00:46:24,330 --> 00:46:31,550
of of signals class right with these

00:46:27,320 --> 00:46:34,580
metadata file utility needs a C++

00:46:31,550 --> 00:46:37,010
anymore it is just a binary simple

00:46:34,580 --> 00:46:39,980
binary format and even with you know the

00:46:37,010 --> 00:46:43,790
community that you can write a parser

00:46:39,980 --> 00:46:45,890
for in any language you want and if it

00:46:43,790 --> 00:46:49,430
is all complete probably get about two

00:46:45,890 --> 00:46:51,380
or three hours of homework done you

00:46:49,430 --> 00:46:53,140
can't write the C++ structure pastoring

00:46:51,380 --> 00:46:56,090
in two hours okay

00:46:53,140 --> 00:46:59,410
so these go lots of something and say it

00:46:56,090 --> 00:47:02,180
is that you have to take super spice and

00:46:59,410 --> 00:47:05,570
its semantics is very different from the

00:47:02,180 --> 00:47:08,180
surface syntax the user interface we

00:47:05,570 --> 00:47:11,060
have to be right the I have scenes gives

00:47:08,180 --> 00:47:13,430
you a super space in a different

00:47:11,060 --> 00:47:15,350
notation okay and this is actually the

00:47:13,430 --> 00:47:17,600
ideas for doing this is pay something

00:47:15,350 --> 00:47:21,260
that I did with biani back when we were

00:47:17,600 --> 00:47:23,030
in Texas but ten years ago called the

00:47:21,260 --> 00:47:26,270
IQR you say something that we only

00:47:23,030 --> 00:47:28,510
studied before I try and and you know it

00:47:26,270 --> 00:47:33,020
gives you a complete representation of

00:47:28,510 --> 00:47:35,090
C++ programs and in it was a small

00:47:33,020 --> 00:47:37,250
library but was generally enough and

00:47:35,090 --> 00:47:40,580
efficient enough that you know you can

00:47:37,250 --> 00:47:46,190
represent our Terrace across bus isn't

00:47:40,580 --> 00:47:48,890
very just using a few numbers no because

00:47:46,190 --> 00:47:51,290
now you have super stress related in

00:47:48,890 --> 00:47:54,470
slightly different way it's that's

00:47:51,290 --> 00:47:58,400
easier to manipulate I hope that we'll

00:47:54,470 --> 00:48:00,530
see more more developers ruling the

00:47:58,400 --> 00:48:04,040
implementation that will come with VC

00:48:00,530 --> 00:48:06,710
will come with manipulate manipulation

00:48:04,040 --> 00:48:10,460
tools for Phi FC is gorgeous I have C

00:48:06,710 --> 00:48:13,310
dot XZ it allows you to embed to take an

00:48:10,460 --> 00:48:16,060
IFC module into compiled interface embed

00:48:13,310 --> 00:48:19,490
it into a static clip or a DLL and

00:48:16,060 --> 00:48:22,010
that's what you give your consumer so

00:48:19,490 --> 00:48:25,100
that now we have just one single thing

00:48:22,010 --> 00:48:28,730
and it is self descriptive it is both

00:48:25,100 --> 00:48:31,460
the executor code and also a set of

00:48:28,730 --> 00:48:36,860
declarations that you need to consume it

00:48:31,460 --> 00:48:38,120
and so this is how DLL yeah I have see

00:48:36,860 --> 00:48:43,520
they have seen

00:48:38,120 --> 00:48:47,540
FC - - embed that in bed your FC into

00:48:43,520 --> 00:48:49,250
study clip or DLL you know the battery

00:48:47,540 --> 00:48:51,650
formerly I have the binary former you

00:48:49,250 --> 00:48:59,060
can embed it in just about any binary

00:48:51,650 --> 00:49:01,670
form we can consider its its so this

00:48:59,060 --> 00:49:05,630
basically what you can expect from a VCS

00:49:01,670 --> 00:49:07,820
implementation no the two side so we

00:49:05,630 --> 00:49:11,050
give this to internal developers food

00:49:07,820 --> 00:49:16,250
really really wanting we know ya means

00:49:11,050 --> 00:49:19,130
Dan means of module ready very well it

00:49:16,250 --> 00:49:20,840
today and the feedback so what do I get

00:49:19,130 --> 00:49:29,150
this feedback the first thing is of

00:49:20,840 --> 00:49:32,480
course syntax they the impart ways to

00:49:29,150 --> 00:49:38,050
make sure that it doesn't turn into

00:49:32,480 --> 00:49:42,980
something you don't recognize I will try

00:49:38,050 --> 00:49:45,050
so the of course they get to use it

00:49:42,980 --> 00:49:47,270
they'll find it they like they find it

00:49:45,050 --> 00:49:50,210
very useful they like it and they

00:49:47,270 --> 00:49:55,340
worrying about being locked in yet

00:49:50,210 --> 00:49:58,490
another Microsoft extension and so the

00:49:55,340 --> 00:50:02,570
worried about standardization and they

00:49:58,490 --> 00:50:04,610
really really wants the devs have been

00:50:02,570 --> 00:50:09,110
talking to they really want module

00:50:04,610 --> 00:50:16,160
yesterday so you're asking is it going

00:50:09,110 --> 00:50:18,530
to be in 17 we are trying I don't want

00:50:16,160 --> 00:50:24,160
you to be scared not just because it is

00:50:18,530 --> 00:50:24,160
new means it is so impossible to do know

00:50:24,220 --> 00:50:30,530
this is something that we implemented in

00:50:27,020 --> 00:50:34,280
a visa compile okay those of you who you

00:50:30,530 --> 00:50:36,500
see know all details about what we see

00:50:34,280 --> 00:50:39,650
right doesn't have HD that kind of stuff

00:50:36,500 --> 00:50:44,260
but what you have in the AFC is an

00:50:39,650 --> 00:50:44,260
abstract semantics graph right I

00:50:44,800 --> 00:50:49,260
suspected

00:50:45,990 --> 00:50:52,770
in May the other compilers and we can't

00:50:49,260 --> 00:50:57,990
do it before 17 comes out so we can get

00:50:52,770 --> 00:51:01,530
it miss Tanner they they worry also

00:50:57,990 --> 00:51:04,740
about the IFC format they they want to

00:51:01,530 --> 00:51:12,210
know whether clang or GCC will have the

00:51:04,740 --> 00:51:14,670
same binary format I don't know I don't

00:51:12,210 --> 00:51:18,930
think it is ready yet for iesous style

00:51:14,670 --> 00:51:21,240
but I think it is ready to consider as a

00:51:18,930 --> 00:51:24,420
technical specification you know a place

00:51:21,240 --> 00:51:26,610
where we we experiment more with the

00:51:24,420 --> 00:51:27,869
binary follow we know what the semantics

00:51:26,610 --> 00:51:31,470
should be they know the semantics of

00:51:27,869 --> 00:51:34,020
module that there is no very low things

00:51:31,470 --> 00:51:36,060
together that we just have to find

00:51:34,020 --> 00:51:39,090
agreement on what I call secondary

00:51:36,060 --> 00:51:41,220
points and write these numbers but we

00:51:39,090 --> 00:51:43,200
leave banner if formerly file the binary

00:51:41,220 --> 00:51:47,720
file that is produced as part of

00:51:43,200 --> 00:51:50,640
metadata that will need more work than

00:51:47,720 --> 00:51:52,890
to do today so I'm not touching that

00:51:50,640 --> 00:51:55,950
binary format as soon as it was part of

00:51:52,890 --> 00:51:58,050
sequence or 17 however very very much

00:51:55,950 --> 00:52:00,619
want us to have modules first and then

00:51:58,050 --> 00:52:04,590
work on the on the binary formats

00:52:00,619 --> 00:52:11,090
technical specification that follows

00:52:04,590 --> 00:52:15,390
almost immediately and so what I say no

00:52:11,090 --> 00:52:19,470
not right now maybe the reaction I get

00:52:15,390 --> 00:52:22,500
is incredible that really giving me any

00:52:19,470 --> 00:52:25,170
telling that you guys can't agree on

00:52:22,500 --> 00:52:28,859
having a a common format for

00:52:25,170 --> 00:52:31,710
representing the compiled binary you

00:52:28,859 --> 00:52:34,020
know modules look you're not guys have

00:52:31,710 --> 00:52:37,980
it know Java has something sous chef has

00:52:34,020 --> 00:52:43,200
something you guys can tell it so maybe

00:52:37,980 --> 00:52:46,350
this is a place where not as bold as I

00:52:43,200 --> 00:52:48,060
should be maybe because I'm so focused

00:52:46,350 --> 00:52:51,420
on getting the semantics

00:52:48,060 --> 00:52:57,460
you know the modules to the programmer

00:52:51,420 --> 00:53:05,349
so please help me and so last word

00:52:57,460 --> 00:53:11,380
about visibility people usually ask hey

00:53:05,349 --> 00:53:13,869
if I experts in class that has private

00:53:11,380 --> 00:53:17,559
data members protected a member in

00:53:13,869 --> 00:53:21,550
accessibility are they also export it my

00:53:17,559 --> 00:53:24,970
answer was kind of they color what does

00:53:21,550 --> 00:53:26,890
that mean kind of well I try to turn a

00:53:24,970 --> 00:53:30,190
community that it'll be really useful if

00:53:26,890 --> 00:53:32,410
we don't export also the our private

00:53:30,190 --> 00:53:35,890
data members and I was unable to

00:53:32,410 --> 00:53:36,700
convince the committee like come on be

00:53:35,890 --> 00:53:42,160
serious

00:53:36,700 --> 00:53:43,839
so again help me help me make the case

00:53:42,160 --> 00:53:46,480
to the committee that this is something

00:53:43,839 --> 00:53:49,390
that is important it enables things that

00:53:46,480 --> 00:53:54,550
you know will be really useful to have

00:53:49,390 --> 00:53:58,180
you know if give you an example take

00:53:54,550 --> 00:54:02,890
card build for you it is possible for

00:53:58,180 --> 00:54:05,859
this guy to give us amazing speed up if

00:54:02,890 --> 00:54:09,130
only you can guarantee that certain

00:54:05,859 --> 00:54:13,000
things are not used or they do not have

00:54:09,130 --> 00:54:18,549
any semantics impact so if all you do is

00:54:13,000 --> 00:54:22,109
to change a a private function parameter

00:54:18,549 --> 00:54:25,750
time that doesn't have any semantics

00:54:22,109 --> 00:54:27,670
effects outside the module why do you

00:54:25,750 --> 00:54:30,940
need to recompile everybody who is

00:54:27,670 --> 00:54:31,809
consuming that module it doesn't have

00:54:30,940 --> 00:54:36,309
any impact

00:54:31,809 --> 00:54:40,839
okay so and if you can give him that

00:54:36,309 --> 00:54:43,240
they will give you huge speedo right

00:54:40,839 --> 00:54:45,460
because they do you know did the

00:54:43,240 --> 00:54:49,059
finale's is on things that I use they're

00:54:45,460 --> 00:54:52,270
not used outside the motor it is this

00:54:49,059 --> 00:54:57,369
policy that we need to worry about

00:54:52,270 --> 00:55:01,140
so as finance fine I want you to know

00:54:57,369 --> 00:55:05,400
I'll encourage you have to go to Steve

00:55:01,140 --> 00:55:08,950
Steve Carrell and evens talk on Thursday

00:55:05,400 --> 00:55:10,339
that no gives you more perspective on

00:55:08,950 --> 00:55:13,329
what

00:55:10,339 --> 00:55:16,279
what's coming in what's new in C C++

00:55:13,329 --> 00:55:18,920
2015 and the future directions of these

00:55:16,279 --> 00:55:23,630
you know C plus were to set coming from

00:55:18,920 --> 00:55:27,279
a pure steel that will be my last slide

00:55:23,630 --> 00:55:27,279
and immediately questions

00:55:50,890 --> 00:56:00,769
so yeah so the question is where have

00:55:57,049 --> 00:56:04,039
consider ability to consume the you know

00:56:00,769 --> 00:56:07,039
the module fc5 the binary format it with

00:56:04,039 --> 00:56:09,939
the data from source files there at this

00:56:07,039 --> 00:56:13,819
transmission unit we do hope to give you

00:56:09,939 --> 00:56:18,079
API that allows you to just open a file

00:56:13,819 --> 00:56:19,519
and just read the declarations or

00:56:18,079 --> 00:56:23,890
definitions yes

00:56:19,519 --> 00:56:26,199
at this point there is no language in a

00:56:23,890 --> 00:56:30,650
Collingwood supporter says oh just

00:56:26,199 --> 00:56:32,689
magically make this metadata data type

00:56:30,650 --> 00:56:34,179
or sorry did this structure in some

00:56:32,689 --> 00:56:38,839
special unique which will give you some

00:56:34,179 --> 00:56:42,279
compile time reflection at this point

00:56:38,839 --> 00:56:42,279
there is nothing that but you have to

00:57:02,979 --> 00:57:08,449
know I'll just say about what happens if

00:57:06,499 --> 00:57:11,059
I try to compile a consumer before

00:57:08,449 --> 00:57:13,069
compiling the module so the question is

00:57:11,059 --> 00:57:17,630
what happens if I try to consume a

00:57:13,069 --> 00:57:19,849
module before I combine so the answer is

00:57:17,630 --> 00:57:22,119
in the correct model

00:57:19,849 --> 00:57:25,279
you're supposed to compile the

00:57:22,119 --> 00:57:28,880
multi-surface first okay there is this

00:57:25,279 --> 00:57:32,839
notion of that when you have wanting to

00:57:28,880 --> 00:57:35,799
deform a dag directly speak right so at

00:57:32,839 --> 00:57:38,289
each of this level you cannot have a

00:57:35,799 --> 00:57:42,069
sizable but the implementation level

00:57:38,289 --> 00:57:42,069
know in prodigy

00:57:44,160 --> 00:57:49,270
implementation vinick's

00:57:45,550 --> 00:57:53,970
can have cycles but you still have to

00:57:49,270 --> 00:57:53,970
compile the module interface first then

00:57:55,680 --> 00:58:02,550
what about cycles between modules so we

00:57:59,380 --> 00:58:05,410
don't have cycles at the interface level

00:58:02,550 --> 00:58:06,520
but you have you can't have cycle type

00:58:05,410 --> 00:58:13,480
implementation level

00:58:06,520 --> 00:58:17,050
now the in general I what way you will

00:58:13,480 --> 00:58:19,750
have these architectures were you you

00:58:17,050 --> 00:58:22,860
feel the need to have two module

00:58:19,750 --> 00:58:26,620
interpreters back reference each other I

00:58:22,860 --> 00:58:29,950
feel like there is probably a design

00:58:26,620 --> 00:58:34,120
error that you have tried too hard to

00:58:29,950 --> 00:58:37,360
have to find drain modules that's my

00:58:34,120 --> 00:58:39,250
general position but I also know that if

00:58:37,360 --> 00:58:41,710
you take is on a library for example the

00:58:39,250 --> 00:58:43,780
reason one we have is forward and I will

00:58:41,710 --> 00:58:46,450
stream is that you have this dependency

00:58:43,780 --> 00:58:48,280
between our streams and strings right so

00:58:46,450 --> 00:58:52,210
you need to have this forward apportion

00:58:48,280 --> 00:58:58,780
but again I will argue that that makes

00:58:52,210 --> 00:59:02,590
my point that we probably decompose

00:58:58,780 --> 00:59:05,140
header files in to find gray if we had

00:59:02,590 --> 00:59:08,590
become that did impose these cost of

00:59:05,140 --> 00:59:11,530
copying everything it is not clear to me

00:59:08,590 --> 00:59:13,510
that we will have this composition of is

00:59:11,530 --> 00:59:16,360
forward I've streams and string we just

00:59:13,510 --> 00:59:18,760
have one thing really

00:59:16,360 --> 00:59:23,200
one cannot function without the earth so

00:59:18,760 --> 00:59:26,320
really now beyond incident one sister

00:59:23,200 --> 00:59:28,840
but I also know that there is needs when

00:59:26,320 --> 00:59:31,720
you bringing existing system because

00:59:28,840 --> 00:59:32,860
today you have 40 version of 1 plus here

00:59:31,720 --> 00:59:35,320
and then you find there and then you

00:59:32,860 --> 00:59:38,740
have lots of sigh closely I also know

00:59:35,320 --> 00:59:42,880
that there is need to find something to

00:59:38,740 --> 00:59:46,440
handle that so you'll be able to say

00:59:42,880 --> 00:59:49,390
that hey I'm going to use this

00:59:46,440 --> 00:59:51,460
functional class it doesn't belong to

00:59:49,390 --> 00:59:52,040
this module it belongs to read separate

00:59:51,460 --> 00:59:56,620
module you

00:59:52,040 --> 01:00:01,940
mechanism to say that but you won't have

00:59:56,620 --> 01:00:03,830
second appearances okay okay one more

01:00:01,940 --> 01:00:43,910
question I'm sorry

01:00:03,830 --> 01:00:45,740
whooping I consider that a good

01:00:43,910 --> 01:00:48,730
suggestion and I'll put you on the list

01:00:45,740 --> 01:00:48,730

YouTube URL: https://www.youtube.com/watch?v=RwdQA0pGWa4


