Title: CppCon 2015: Louis Dionne “C++ Metaprogramming: A Paradigm Shift"
Publication date: 2015-10-08
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Most people think metaprogramming is hard. It isn't; we just didn't have the right tools for it. This talk will present a new way of metaprogramming using the same syntax as that of normal C++. It will show how the runtime and the compile-time boundaries can be crossed almost seamlessly. It will show how compilation times can be reduced without sacrificing expressiveness. It will introduce Hana [1], a newly accepted Boost library using cutting edge features of the language in a creative way to solve the problem of metaprogramming for good.
— 
Louis is a computer programming enthusiast and math student with interest in C++ (meta)programming, functional programming, category theory and related subjects. In the past years, he's been working on various ways to solve the problem of metaprogramming in C++, and he thinks he has finally found a satisfactory solution.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,100
my name is Louie teon I'm a math student

00:00:02,460 --> 00:00:10,080
and a computer programing enthusiast

00:00:05,100 --> 00:00:14,009
I also freelance from time to time but

00:00:10,080 --> 00:00:15,150
mostly I do open source libraries and

00:00:14,009 --> 00:00:18,060
today we'll be talking about meta

00:00:15,150 --> 00:00:20,160
programming actually I will introduce

00:00:18,060 --> 00:00:22,109
what I claim to be a new paradigm for

00:00:20,160 --> 00:00:26,250
metaprogramming a new paradigm that

00:00:22,109 --> 00:00:32,250
makes everything much easier and much

00:00:26,250 --> 00:00:34,680
more expressive due to C++ 14 so first

00:00:32,250 --> 00:00:36,540
up I would like to introduce the

00:00:34,680 --> 00:00:39,570
different types of computations that we

00:00:36,540 --> 00:00:44,040
can do in C++ just to set you know like

00:00:39,570 --> 00:00:47,430
that just so you can see basically we're

00:00:44,040 --> 00:00:50,370
where we are going to deliver this brand

00:00:47,430 --> 00:00:54,270
this presentation like in which part of

00:00:50,370 --> 00:00:56,399
C++ we're gonna dive so first there are

00:00:54,270 --> 00:00:59,340
n time computations the ones that you

00:00:56,399 --> 00:01:01,350
usually use at work ones that we all

00:00:59,340 --> 00:01:04,080
know the first ones that we that we

00:01:01,350 --> 00:01:06,060
learn about so in that world we have run

00:01:04,080 --> 00:01:08,240
time sequences right likes to the

00:01:06,060 --> 00:01:12,119
vectors to the lists to do whatever

00:01:08,240 --> 00:01:13,979
these sequences the they are homogeneous

00:01:12,119 --> 00:01:15,869
in the sense that they can only old

00:01:13,979 --> 00:01:17,040
objects that all have the same type so

00:01:15,869 --> 00:01:18,780
you can have a still vector containing

00:01:17,040 --> 00:01:20,880
ends we can have is the vector

00:01:18,780 --> 00:01:22,350
containing strings but you cannot have a

00:01:20,880 --> 00:01:26,520
vector it's the directory that contains

00:01:22,350 --> 00:01:30,030
both ends and strings right unlike in

00:01:26,520 --> 00:01:31,590
some dynamically typed languages then we

00:01:30,030 --> 00:01:33,869
have ran time functions which are just

00:01:31,590 --> 00:01:36,030
normal C++ functions the operator at

00:01:33,869 --> 00:01:38,720
runtime and then we have runtime

00:01:36,030 --> 00:01:42,540
algorithms to manipulate these these

00:01:38,720 --> 00:01:43,920
sequences and and some of these

00:01:42,540 --> 00:01:46,140
algorithms can also take current time

00:01:43,920 --> 00:01:49,680
functions like higher-order algorithm

00:01:46,140 --> 00:01:52,340
static functions to modify sequences and

00:01:49,680 --> 00:01:56,490
stuff like that so so far nothing new

00:01:52,340 --> 00:01:58,380
then since C++ Alvin and well suppose

00:01:56,490 --> 00:02:00,780
plus 14 mainly because of a generalized

00:01:58,380 --> 00:02:03,750
context where we also have constructs

00:02:00,780 --> 00:02:05,579
for computations right so this world is

00:02:03,750 --> 00:02:07,380
pretty much like the runtime world in

00:02:05,579 --> 00:02:10,259
the sense that everything is emoji news

00:02:07,380 --> 00:02:11,940
except if you are nice enough with the

00:02:10,259 --> 00:02:12,940
compiler if you do not do anything nasty

00:02:11,940 --> 00:02:15,090
inside the computation

00:02:12,940 --> 00:02:17,860
and by nasty I mean like throwing

00:02:15,090 --> 00:02:19,210
allocating memory or stuff like that so

00:02:17,860 --> 00:02:22,270
as long as you are nice enough with the

00:02:19,210 --> 00:02:24,570
compiler you can ask the compiler to

00:02:22,270 --> 00:02:27,190
evaluate data at compile time all right

00:02:24,570 --> 00:02:30,910
that is context but basically so in that

00:02:27,190 --> 00:02:34,500
world we have concepts for sequences we

00:02:30,910 --> 00:02:37,480
have context for functions and we have

00:02:34,500 --> 00:02:39,370
concepts for algorithms or we could have

00:02:37,480 --> 00:02:41,320
sex for algorithms there are not in the

00:02:39,370 --> 00:02:42,580
standard yet but most of the algorithms

00:02:41,320 --> 00:02:44,920
in the center that just manually

00:02:42,580 --> 00:02:46,420
iterators there's no reason why we

00:02:44,920 --> 00:02:48,250
couldn't stick Const exper in front of

00:02:46,420 --> 00:02:51,310
them and it will work just as is but so

00:02:48,250 --> 00:02:53,140
yeah so just so in theory we also have

00:02:51,310 --> 00:02:58,500
concepts per algorithms it's just like

00:02:53,140 --> 00:03:02,200
not implemented in style yet and now

00:02:58,500 --> 00:03:03,720
third quadrant now we're getting kind of

00:03:02,200 --> 00:03:06,040
funky right

00:03:03,720 --> 00:03:08,200
heterogeneous computation so what does

00:03:06,040 --> 00:03:09,870
that even mean so in that world we have

00:03:08,200 --> 00:03:11,890
a thorough genius sequences

00:03:09,870 --> 00:03:13,480
heterogeneous sequence is simply a

00:03:11,890 --> 00:03:15,970
sequence that can all objects with

00:03:13,480 --> 00:03:20,350
different types say suitable is an

00:03:15,970 --> 00:03:22,810
iteration sequence and then we have a

00:03:20,350 --> 00:03:25,450
genus functions which is really just a

00:03:22,810 --> 00:03:27,010
fancy way to say it's just a fancy name

00:03:25,450 --> 00:03:28,330
for template functions really it's

00:03:27,010 --> 00:03:29,590
nothing more than that because the

00:03:28,330 --> 00:03:31,959
template function when you think of it

00:03:29,590 --> 00:03:33,750
it can take objects that have different

00:03:31,959 --> 00:03:37,360
types and depending on you know which

00:03:33,750 --> 00:03:39,430
the type of the arguments it's going to

00:03:37,360 --> 00:03:41,470
maybe return an object of a different

00:03:39,430 --> 00:03:43,780
type unit so the return type type can

00:03:41,470 --> 00:03:48,100
vary depending on the on the type of

00:03:43,780 --> 00:03:50,590
their arguments and then we have a

00:03:48,100 --> 00:03:53,230
thorough genus algorithms or yeah well

00:03:50,590 --> 00:03:55,750
we we trying to do so we don't have them

00:03:53,230 --> 00:03:57,190
in the standard right but it would make

00:03:55,750 --> 00:04:00,430
sense that we have them just like

00:03:57,190 --> 00:04:02,470
concepts for algorithms why not but

00:04:00,430 --> 00:04:04,590
there is like a library that does that

00:04:02,470 --> 00:04:07,420
but we don't have them in the standard

00:04:04,590 --> 00:04:11,170
and of course yeah it's not that easy

00:04:07,420 --> 00:04:14,230
unfortunately so that brings me to my

00:04:11,170 --> 00:04:17,709
first claim which is that we actually

00:04:14,230 --> 00:04:20,320
need algorithms to manipulate that or is

00:04:17,709 --> 00:04:20,650
it original sequences I think we need

00:04:20,320 --> 00:04:23,950
them

00:04:20,650 --> 00:04:25,990
because it simplifies a lot of meta

00:04:23,950 --> 00:04:26,770
programming tasks it make them it makes

00:04:25,990 --> 00:04:29,370
them

00:04:26,770 --> 00:04:34,389
you know almost as easy as writing

00:04:29,370 --> 00:04:37,199
normal regular C++ I mean this this

00:04:34,389 --> 00:04:39,190
transform on a two-pole is really not

00:04:37,199 --> 00:04:41,020
surprising to anybody here right

00:04:39,190 --> 00:04:43,030
anybody who has written Python or Ruby

00:04:41,020 --> 00:04:44,919
like understands that out of the box

00:04:43,030 --> 00:04:47,650
it's very very clear that we were going

00:04:44,919 --> 00:04:50,199
to call the function object to string on

00:04:47,650 --> 00:04:51,520
each element of the tuple it's not not

00:04:50,199 --> 00:04:54,970
surprising that elements have different

00:04:51,520 --> 00:04:59,949
types it just makes sense and then we

00:04:54,970 --> 00:05:02,770
get back a tuple of strings so I think

00:04:59,949 --> 00:05:05,319
we need them in the standard or we need

00:05:02,770 --> 00:05:07,630
the good tool to to to algorithms and on

00:05:05,319 --> 00:05:11,050
sequences and heterogeneous sequences

00:05:07,630 --> 00:05:15,729
and then we have type level computations

00:05:11,050 --> 00:05:18,759
that is the the fourth quadrant type

00:05:15,729 --> 00:05:21,610
level computations well so in that world

00:05:18,759 --> 00:05:23,440
we have I'm sorry type level sequences

00:05:21,610 --> 00:05:25,270
which are basically sequences that can

00:05:23,440 --> 00:05:26,830
hold types they can open up more than

00:05:25,270 --> 00:05:28,900
types so there is no like value

00:05:26,830 --> 00:05:34,270
associated to each types due to each

00:05:28,900 --> 00:05:37,000
type in the sequence and we have type

00:05:34,270 --> 00:05:38,770
level functions which are basically meta

00:05:37,000 --> 00:05:41,620
functions that's all we call them right

00:05:38,770 --> 00:05:43,569
you probably know about type threads

00:05:41,620 --> 00:05:47,620
well pipe threads are just an example of

00:05:43,569 --> 00:05:49,930
a type level functions and then we have

00:05:47,620 --> 00:05:52,330
typable algorithms to manipulate these

00:05:49,930 --> 00:05:55,779
type level sequences with type level

00:05:52,330 --> 00:06:03,310
functions or meta functions it's a bit

00:05:55,779 --> 00:06:05,620
clunky but it works and now let me make

00:06:03,310 --> 00:06:10,210
this other claim which is that MPL is

00:06:05,620 --> 00:06:11,949
actually redundant why my claim that I

00:06:10,210 --> 00:06:15,219
will try to demonstrate during this talk

00:06:11,949 --> 00:06:16,810
is that pure type level computations are

00:06:15,219 --> 00:06:20,560
actually nothing but heterogeneous

00:06:16,810 --> 00:06:22,930
computations so computations on tuples

00:06:20,560 --> 00:06:25,029
are strictly more general strictly more

00:06:22,930 --> 00:06:27,849
powerful than type level computations

00:06:25,029 --> 00:06:30,400
and if we add a very good library to

00:06:27,849 --> 00:06:33,340
manipulate origina sequences we could

00:06:30,400 --> 00:06:35,880
also do type level computations with

00:06:33,340 --> 00:06:35,880
this library

00:06:36,700 --> 00:06:47,740
Oh God okay yeah how do you saw

00:06:42,580 --> 00:06:50,440
everything so but the most important

00:06:47,740 --> 00:06:53,170
point and I guess that is my third claim

00:06:50,440 --> 00:06:54,880
is that C++ 14 is just like a huge game

00:06:53,170 --> 00:06:57,550
changer it just changes everything when

00:06:54,880 --> 00:06:59,710
it comes to metaphor dreaming mostly

00:06:57,550 --> 00:07:02,440
because a to deduce return type generic

00:06:59,710 --> 00:07:03,850
lambdas and generalize context pair is

00:07:02,440 --> 00:07:07,090
also nice but only in the implementation

00:07:03,850 --> 00:07:08,230
of the library it's not really useful as

00:07:07,090 --> 00:07:11,710
part of the interface though

00:07:08,230 --> 00:07:13,680
but yeah so of course this is just me

00:07:11,710 --> 00:07:16,780
claiming stuff and I'm biased because

00:07:13,680 --> 00:07:19,360
some of you might know I offered up made

00:07:16,780 --> 00:07:21,220
a programming library recently so yeah

00:07:19,360 --> 00:07:23,200
I'm competing against these other

00:07:21,220 --> 00:07:25,780
libraries that that I'm claiming they're

00:07:23,200 --> 00:07:28,330
less powerful so so just see for

00:07:25,780 --> 00:07:31,590
yourself so this is all we used to check

00:07:28,330 --> 00:07:36,070
for a member this is like the classical

00:07:31,590 --> 00:07:39,640
female based trick or a diem or I would

00:07:36,070 --> 00:07:42,190
say hack which allows us to check

00:07:39,640 --> 00:07:43,420
whether a map is a type as a nested

00:07:42,190 --> 00:07:46,570
member called exit tax

00:07:43,420 --> 00:07:48,370
I won't even explain it because you know

00:07:46,570 --> 00:07:50,650
either you know it or you don't

00:07:48,370 --> 00:07:53,130
but basically this is yeah this is just

00:07:50,650 --> 00:07:56,800
a trick of the language you're able to

00:07:53,130 --> 00:07:59,680
to know whether a type has some member

00:07:56,800 --> 00:08:00,700
but it's a bit convoluted like when you

00:07:59,680 --> 00:08:06,040
see this for the first time you're like

00:08:00,700 --> 00:08:09,700
okay now soon in C++ 17 there would be

00:08:06,040 --> 00:08:11,380
this detection idiom using stud boy T

00:08:09,700 --> 00:08:14,040
and we're going to be able to make it

00:08:11,380 --> 00:08:17,980
much nicer right I think it's much nicer

00:08:14,040 --> 00:08:20,440
involuted and and yeah it it's easier to

00:08:17,980 --> 00:08:23,830
explain through your co-workers and it's

00:08:20,440 --> 00:08:26,740
better but what I would really like to

00:08:23,830 --> 00:08:28,750
see is something like this I want a

00:08:26,740 --> 00:08:30,730
one-liner for checking whether type as a

00:08:28,750 --> 00:08:34,510
nested member and I want it to look

00:08:30,730 --> 00:08:37,240
natural and I won't you know the the

00:08:34,510 --> 00:08:39,220
idiom to be such that anybody would

00:08:37,240 --> 00:08:40,960
who's new to C++ can say oh well I

00:08:39,220 --> 00:08:44,890
really kind of understand what this does

00:08:40,960 --> 00:08:46,660
right and this actually works I mean

00:08:44,890 --> 00:08:48,350
this is completely possible with suppose

00:08:46,660 --> 00:08:50,990
plus 40

00:08:48,350 --> 00:08:54,140
so now we're talking about you know a

00:08:50,990 --> 00:09:00,080
one-liner for checking whether a type is

00:08:54,140 --> 00:09:02,990
a nested member and it's as you it's

00:09:00,080 --> 00:09:05,030
also important to see that it's it's

00:09:02,990 --> 00:09:06,590
variable so it's it's a lambda which

00:09:05,030 --> 00:09:08,720
makes it possible to declare it like in

00:09:06,590 --> 00:09:11,210
a in another function you don't have to

00:09:08,720 --> 00:09:13,000
be at a global scope or and namespace

00:09:11,210 --> 00:09:18,370
scoped to a to declare such such

00:09:13,000 --> 00:09:18,370
detectors so it's much more flexible

00:09:18,760 --> 00:09:23,990
okay introspection so most of you

00:09:21,710 --> 00:09:25,790
probably already wish you could iterate

00:09:23,990 --> 00:09:28,160
over the members of us trucks right a

00:09:25,790 --> 00:09:30,140
user defined type and that's always easy

00:09:28,160 --> 00:09:33,670
to do it we can use the boost fusion

00:09:30,140 --> 00:09:35,900
library to to like adapt a struct into

00:09:33,670 --> 00:09:39,140
into something that looks either like a

00:09:35,900 --> 00:09:41,180
tuple or a map a compile-time map where

00:09:39,140 --> 00:09:43,750
the keys are types the types that

00:09:41,180 --> 00:09:46,520
already find at the top of the slide

00:09:43,750 --> 00:09:50,900
there they're basically types really and

00:09:46,520 --> 00:09:55,520
then we can access these we can access

00:09:50,900 --> 00:09:57,410
these these members the members of the

00:09:55,520 --> 00:10:01,640
struct using the the types that are

00:09:57,410 --> 00:10:05,120
associated to them okay now with C++ 14

00:10:01,640 --> 00:10:06,890
we can do better we can we can use

00:10:05,120 --> 00:10:09,200
instead of using like types that you

00:10:06,890 --> 00:10:11,840
have to declare beforehand we can use

00:10:09,200 --> 00:10:13,580
compile time strengths for the keys so

00:10:11,840 --> 00:10:15,860
this is an ugly macro but basically what

00:10:13,580 --> 00:10:18,320
this does is create a a compile time

00:10:15,860 --> 00:10:21,470
string and so you do not have to declare

00:10:18,320 --> 00:10:23,210
the members beforehand I mean the the

00:10:21,470 --> 00:10:27,200
keys beforehand which is very handy when

00:10:23,210 --> 00:10:30,170
you have 100 of them and this is the

00:10:27,200 --> 00:10:32,750
future where we have a user-defined

00:10:30,170 --> 00:10:34,640
literal that creates a compile time

00:10:32,750 --> 00:10:37,220
strain you don't need to use a macro

00:10:34,640 --> 00:10:39,620
it's super fast compile time I mean and

00:10:37,220 --> 00:10:43,490
and it's supernatural

00:10:39,620 --> 00:10:45,500
and this is a new extension it works it

00:10:43,490 --> 00:10:47,510
could be in c++ 17 it the standard

00:10:45,500 --> 00:10:50,840
comedy try decides that you know it's

00:10:47,510 --> 00:10:53,120
worth it and it's like trivial to

00:10:50,840 --> 00:10:57,370
implement but for now it is just a good

00:10:53,120 --> 00:10:57,370
new extension yeah

00:10:58,010 --> 00:11:03,230
well this remote is getting crazy I just

00:11:01,340 --> 00:11:15,200
pressed once and then it gets all crazy

00:11:03,230 --> 00:11:19,790
just a minute sorry about that okay

00:11:15,200 --> 00:11:22,670
I am right there okay now how many of

00:11:19,790 --> 00:11:24,740
you have already tried to you know

00:11:22,670 --> 00:11:26,180
generate Jason for serializing or

00:11:24,740 --> 00:11:29,600
something like that most of you probably

00:11:26,180 --> 00:11:31,160
yeah okay so of course I'm not gonna

00:11:29,600 --> 00:11:34,460
show how we used to do it because it

00:11:31,160 --> 00:11:37,990
might have been nesting but now it's

00:11:34,460 --> 00:11:40,430
pretty easy actually so basically you

00:11:37,990 --> 00:11:48,770
I'm really gonna try to put this back on

00:11:40,430 --> 00:11:51,230
I guess it's annoying yeah okay so now

00:11:48,770 --> 00:11:53,360
you just define the user defined type

00:11:51,230 --> 00:11:56,330
using you know this macro here that

00:11:53,360 --> 00:12:00,290
provides some introspection capabilities

00:11:56,330 --> 00:12:05,650
and then what we want is to be able to

00:12:00,290 --> 00:12:08,210
very simply to very simply say to Jason

00:12:05,650 --> 00:12:12,620
print that and it should give us that

00:12:08,210 --> 00:12:14,960
outward good okay so first off we are

00:12:12,620 --> 00:12:18,290
going to end all base types so whatever

00:12:14,960 --> 00:12:19,940
can be to strength we just do it we want

00:12:18,290 --> 00:12:27,280
to quote characters we want to quote

00:12:19,940 --> 00:12:30,230
strings nothing new then if I receive a

00:12:27,280 --> 00:12:32,180
heterogeneous sequence then I want to

00:12:30,230 --> 00:12:34,460
transform that sequence just likes to

00:12:32,180 --> 00:12:36,590
transform right no no no no more

00:12:34,460 --> 00:12:38,330
complicated okay so just I transform

00:12:36,590 --> 00:12:39,890
that sequence and then I call to Jason

00:12:38,330 --> 00:12:41,240
so I gather JSON representation of each

00:12:39,890 --> 00:12:46,490
of the members and then I joined that

00:12:41,240 --> 00:12:48,590
with a comma and then for user-defined

00:12:46,490 --> 00:12:52,220
types like the one I just defined using

00:12:48,590 --> 00:12:55,670
the macro in like two slides ago I again

00:12:52,220 --> 00:12:57,020
I transform the keys of that that user

00:12:55,670 --> 00:13:01,790
defined type which are basically the

00:12:57,020 --> 00:13:05,240
names of the members of the stroke and I

00:13:01,790 --> 00:13:09,680
fetch the value of the member associated

00:13:05,240 --> 00:13:11,139
to that key I and then I just yeah I

00:13:09,680 --> 00:13:13,920
represent the JSON representation

00:13:11,139 --> 00:13:15,609
that member and do the obvious thing and

00:13:13,920 --> 00:13:17,889
it that's it

00:13:15,609 --> 00:13:25,449
there's nothing more and it works and it

00:13:17,889 --> 00:13:27,879
compiles okay now maybe maybe I found

00:13:25,449 --> 00:13:29,980
some cute examples that you know we're

00:13:27,879 --> 00:13:31,809
like wow nice nice everything works and

00:13:29,980 --> 00:13:35,410
and actually it doesn't work so well so

00:13:31,809 --> 00:13:40,989
I'm gonna give you a bit or so there

00:13:35,410 --> 00:13:43,739
were messages yeah there were messages

00:13:40,989 --> 00:13:49,929
they used to be very very very nasty

00:13:43,739 --> 00:13:52,029
basically you you would you know just

00:13:49,929 --> 00:13:56,790
make a little mistake and then you get a

00:13:52,029 --> 00:13:59,769
big spew of very implementation-specific

00:13:56,790 --> 00:14:01,329
stuff so for example here I'm calling MP

00:13:59,769 --> 00:14:02,439
I'll reverse on the integer of course

00:14:01,329 --> 00:14:04,600
it's not going to work because it

00:14:02,439 --> 00:14:06,069
expects the MPL sequence and I get

00:14:04,600 --> 00:14:07,689
something like you know clear Impala

00:14:06,069 --> 00:14:09,309
missing blah blah blah it's very clear

00:14:07,689 --> 00:14:11,379
to me because I know the MPL quite well

00:14:09,309 --> 00:14:12,970
and I know that like your Impala is just

00:14:11,379 --> 00:14:14,919
part of their type dispatching logic and

00:14:12,970 --> 00:14:18,009
blah blah blah so I know exactly what it

00:14:14,919 --> 00:14:20,769
is but most of you guys don't and that's

00:14:18,009 --> 00:14:22,749
a problem whereas with static assert and

00:14:20,769 --> 00:14:26,439
ordered you know tricks it's possible

00:14:22,749 --> 00:14:28,029
that so if I do the same mistake I can

00:14:26,439 --> 00:14:29,649
give you like a very good error message

00:14:28,029 --> 00:14:30,939
and just say like wait well you know one

00:14:29,649 --> 00:14:32,319
is not a sequence and you try to call

00:14:30,939 --> 00:14:35,259
reverse on something that was not a

00:14:32,319 --> 00:14:39,249
sequence so now it's pretty obvious so I

00:14:35,259 --> 00:14:40,989
think that is out pull compile times

00:14:39,249 --> 00:14:44,769
another thing that is quite problematic

00:14:40,989 --> 00:14:47,410
when we do metaprogramming so this

00:14:44,769 --> 00:14:49,569
benchmark shows the time required just

00:14:47,410 --> 00:14:51,819
to include different meta programming

00:14:49,569 --> 00:14:56,429
libraries I'm not doing anything it's

00:14:51,819 --> 00:14:59,049
just like empty CPP file including these

00:14:56,429 --> 00:15:02,589
libraries and of course you can see that

00:14:59,049 --> 00:15:04,239
we are able to to have much lower

00:15:02,589 --> 00:15:06,249
include times and the reason why is just

00:15:04,239 --> 00:15:07,959
because the implementation inside of

00:15:06,249 --> 00:15:11,709
like the implementation details of the

00:15:07,959 --> 00:15:13,419
library are so much simpler with c++ 14

00:15:11,709 --> 00:15:15,669
then you know the library is just

00:15:13,419 --> 00:15:18,100
smaller we don't need to have like big

00:15:15,669 --> 00:15:21,069
preprocessor hacks so this saves on the

00:15:18,100 --> 00:15:23,139
pre-processing time and it's also easier

00:15:21,069 --> 00:15:24,459
to go with fewer dependencies so we

00:15:23,139 --> 00:15:27,050
don't have to pull in

00:15:24,459 --> 00:15:29,870
many you know external dependencies to

00:15:27,050 --> 00:15:34,190
do what we have to do so it's yeah it's

00:15:29,870 --> 00:15:36,339
possible to reducing two times now this

00:15:34,190 --> 00:15:40,120
is the compiled line performance of

00:15:36,339 --> 00:15:43,519
calling the transform algorithm on a

00:15:40,120 --> 00:15:44,990
tooth pulp from the hana library a MPL

00:15:43,519 --> 00:15:47,839
vector and a fusion vector and as you

00:15:44,990 --> 00:15:50,300
can see the Hana tuple is is slightly

00:15:47,839 --> 00:15:53,000
better it's actually ok it's much better

00:15:50,300 --> 00:15:54,860
than than fusion and it's slightly

00:15:53,000 --> 00:15:57,350
better than MPL it's still most

00:15:54,860 --> 00:16:00,949
satisfactory to me but we're working at

00:15:57,350 --> 00:16:04,370
that and the reason why a fusion vector

00:16:00,949 --> 00:16:05,810
stops at 50 is because you cannot create

00:16:04,370 --> 00:16:08,060
a fusion vector with more than 50

00:16:05,810 --> 00:16:14,750
elements it just blows up because of C++

00:16:08,060 --> 00:16:19,190
whole treat limits okay so I think that

00:16:14,750 --> 00:16:20,899
we must rethink meta programming I think

00:16:19,190 --> 00:16:23,540
that c++ working is such a game changer

00:16:20,899 --> 00:16:25,459
that it requires us to like it we just

00:16:23,540 --> 00:16:29,060
had to rethink it from the base we'd

00:16:25,459 --> 00:16:31,310
it's not sufficient to just you know put

00:16:29,060 --> 00:16:33,320
it like type name dot dot somewhere and

00:16:31,310 --> 00:16:35,540
then very early templates and then alias

00:16:33,320 --> 00:16:37,459
templates and then casts exper here and

00:16:35,540 --> 00:16:39,560
six four there it's not enough we need

00:16:37,459 --> 00:16:43,010
to like rethink the way we do it from

00:16:39,560 --> 00:16:44,449
the front of bottom of course now the

00:16:43,010 --> 00:16:48,560
question is like how we're gonna do it

00:16:44,449 --> 00:16:52,339
and well of course I'm here to talk so

00:16:48,560 --> 00:16:54,440
here's my thing so most of you have

00:16:52,339 --> 00:16:55,519
probably heard of integral constant I

00:16:54,440 --> 00:17:00,500
hope so

00:16:55,519 --> 00:17:02,449
basically it's it's a a wrapper for an

00:17:00,500 --> 00:17:04,490
integral value that's known whose value

00:17:02,449 --> 00:17:06,260
is known at compile time and we wrap it

00:17:04,490 --> 00:17:09,410
into a type because it's it makes it

00:17:06,260 --> 00:17:13,610
possible to manipulate it more with more

00:17:09,410 --> 00:17:15,260
flexibility so the way we usually do

00:17:13,610 --> 00:17:19,760
compile time arithmetic is by defining

00:17:15,260 --> 00:17:21,020
meta functions so this plus meta

00:17:19,760 --> 00:17:24,169
function here it takes to integral

00:17:21,020 --> 00:17:25,610
content x x and y and it just you know

00:17:24,169 --> 00:17:28,040
compute the integral constant whose

00:17:25,610 --> 00:17:30,830
value is x plus is the value of x plus

00:17:28,040 --> 00:17:34,010
the value of y simple simple not pretty

00:17:30,830 --> 00:17:35,660
but simple in it works and then as you

00:17:34,010 --> 00:17:37,460
can see i can just test

00:17:35,660 --> 00:17:44,770
that indeed the integral consent in 1

00:17:37,460 --> 00:17:46,550
plus in plus 4 is just it's okay but I

00:17:44,770 --> 00:17:49,220
not super awesome

00:17:46,550 --> 00:17:50,600
either because of all these type name

00:17:49,220 --> 00:17:51,920
and common common type and stuff like

00:17:50,600 --> 00:17:53,360
that there's a lot of syntactic noise

00:17:51,920 --> 00:17:55,370
and it secures what we're actually

00:17:53,360 --> 00:17:58,610
trying to do so let us just try

00:17:55,370 --> 00:18:00,920
something for fun and that thing is well

00:17:58,610 --> 00:18:02,930
all about defining these this plus

00:18:00,920 --> 00:18:05,870
operator instead of defining defining it

00:18:02,930 --> 00:18:08,750
as a medicine we could also define it as

00:18:05,870 --> 00:18:13,580
a you know template function which

00:18:08,750 --> 00:18:15,470
returns an integer constant okay and the

00:18:13,580 --> 00:18:17,810
decor like a very important point here

00:18:15,470 --> 00:18:22,310
is that like we're returning an integral

00:18:17,810 --> 00:18:25,340
constant not an integer not like a that

00:18:22,310 --> 00:18:27,020
the result of V Plus u really the result

00:18:25,340 --> 00:18:28,640
of like an interior constant which

00:18:27,020 --> 00:18:32,480
contains the result of people assume

00:18:28,640 --> 00:18:34,430
that is really really important and then

00:18:32,480 --> 00:18:37,580
if we did that we could eventually

00:18:34,430 --> 00:18:39,440
create integral constant objects instead

00:18:37,580 --> 00:18:42,380
of creating of instead of using the type

00:18:39,440 --> 00:18:44,960
sizes just create the objects and then

00:18:42,380 --> 00:18:48,050
and then use the operators that we all

00:18:44,960 --> 00:18:50,000
know and love right and then since this

00:18:48,050 --> 00:18:52,130
plus operator returns an integral

00:18:50,000 --> 00:18:53,630
constant in something and then this

00:18:52,130 --> 00:18:56,360
equal operator returns an integral

00:18:53,630 --> 00:18:57,800
constant and bool something right

00:18:56,360 --> 00:19:00,410
because it compares two integrals and

00:18:57,800 --> 00:19:02,390
said then you can take the deckle pipe

00:19:00,410 --> 00:19:04,730
of that it's an integral it's like the

00:19:02,390 --> 00:19:06,770
type integral constant will true or

00:19:04,730 --> 00:19:11,480
false and then you can fetch the nested

00:19:06,770 --> 00:19:13,640
value in there so yeah this is an

00:19:11,480 --> 00:19:16,100
alternate way of doing compile-time a

00:19:13,640 --> 00:19:19,100
relay is everybody following me at this

00:19:16,100 --> 00:19:21,820
point no questions everything is clear

00:19:19,100 --> 00:19:21,820
as water yes

00:19:22,419 --> 00:19:35,379
oh yes okay so the comment is that like

00:19:33,489 --> 00:19:38,649
if you wanted to add just let me know if

00:19:35,379 --> 00:19:40,989
I get it correctly ah the the comment is

00:19:38,649 --> 00:19:42,909
that if you want to add like one plus

00:19:40,989 --> 00:19:44,019
word you could just do one plus four and

00:19:42,909 --> 00:19:45,309
then it's going to be a constant

00:19:44,019 --> 00:19:46,779
expression the compiler would say well

00:19:45,309 --> 00:19:49,359
I'm happy to compare one plus four

00:19:46,779 --> 00:19:50,950
equals five at compile time yes that's

00:19:49,359 --> 00:19:53,109
it that's a comment okay yes that's

00:19:50,950 --> 00:19:55,330
totally correct and this is like a toy

00:19:53,109 --> 00:19:58,179
example really because in some other in

00:19:55,330 --> 00:20:00,159
some other context you might get these

00:19:58,179 --> 00:20:02,279
integral constant into one if your are

00:20:00,159 --> 00:20:04,119
constant in four they might be the

00:20:02,279 --> 00:20:05,619
arguments to a function and then you

00:20:04,119 --> 00:20:08,259
don't know whether they are really like

00:20:05,619 --> 00:20:09,159
integers or or compile-time you don't

00:20:08,259 --> 00:20:10,659
know whether they are they are

00:20:09,159 --> 00:20:15,999
compelling or not and the only way

00:20:10,659 --> 00:20:17,769
really to to and then the only way to do

00:20:15,999 --> 00:20:21,489
arithmetic in that context would be to

00:20:17,769 --> 00:20:23,049
use to use like the the plus meta

00:20:21,489 --> 00:20:24,850
function that I showed earlier or this

00:20:23,049 --> 00:20:28,029
or this technique like you wouldn't have

00:20:24,850 --> 00:20:30,039
the the value of this integral constant

00:20:28,029 --> 00:20:31,840
until you fetch the current column value

00:20:30,039 --> 00:20:32,919
of the nested thing because that's what

00:20:31,840 --> 00:20:37,119
you receive as an argument

00:20:32,919 --> 00:20:38,259
am I being clear so I'm so basically

00:20:37,119 --> 00:20:40,359
what I'm saying is that in this toy

00:20:38,259 --> 00:20:42,999
example yes of course its equivalent in

00:20:40,359 --> 00:20:44,649
other in order you know situations it's

00:20:42,999 --> 00:20:53,350
just you just can't do it

00:20:44,649 --> 00:20:55,929
yes yes so the comment is that won't

00:20:53,350 --> 00:20:58,210
like the the key idea is that there is a

00:20:55,929 --> 00:20:59,919
type associated with the value right so

00:20:58,210 --> 00:21:02,019
you can do a bunch of things also like

00:20:59,919 --> 00:21:03,669
overloading and the value of these

00:21:02,019 --> 00:21:08,489
expressions whereas you cannot do it if

00:21:03,669 --> 00:21:08,489
you have just one plus four okay

00:21:08,859 --> 00:21:13,450
of course since the integral constants

00:21:11,049 --> 00:21:16,029
also provide a context for implicit

00:21:13,450 --> 00:21:18,820
boolean constructs for implicit

00:21:16,029 --> 00:21:20,590
conversion to you know the nested to the

00:21:18,820 --> 00:21:23,769
inner value that they provide then you

00:21:20,590 --> 00:21:26,799
can just drop the the whole pickle type

00:21:23,769 --> 00:21:29,019
column count value thing and this is so

00:21:26,799 --> 00:21:30,960
basically again this whole expression is

00:21:29,019 --> 00:21:33,340
an integral constant rule something

00:21:30,960 --> 00:21:35,690
right it's an object of that type but

00:21:33,340 --> 00:21:41,379
that can be converted to a boolean

00:21:35,690 --> 00:21:44,000
sex / so so we can just do that and then

00:21:41,379 --> 00:21:46,340
we can use context for variable

00:21:44,000 --> 00:21:47,720
templates to make it a bit shorter so

00:21:46,340 --> 00:21:50,570
we're which is going to define say an

00:21:47,720 --> 00:21:52,639
integer an integer int underscore C is

00:21:50,570 --> 00:21:54,769
going to be an integral constant and

00:21:52,639 --> 00:21:57,830
with that value and then we can just use

00:21:54,769 --> 00:22:00,710
drop you know de the lengths thing so

00:21:57,830 --> 00:22:03,620
we're there so now we've simplified in a

00:22:00,710 --> 00:22:06,350
weird simplify the syntax quite a bit

00:22:03,620 --> 00:22:08,539
and then the next step is to actually

00:22:06,350 --> 00:22:11,330
use usually define the it rolls right

00:22:08,539 --> 00:22:13,700
and then so I define a user-defined

00:22:11,330 --> 00:22:14,779
literal and then I parse the content of

00:22:13,700 --> 00:22:17,090
that user-defined literal which

00:22:14,779 --> 00:22:19,639
represents you know a number and I

00:22:17,090 --> 00:22:22,129
create the appropriate integral constant

00:22:19,639 --> 00:22:24,590
and what I can do is just 1 under square

00:22:22,129 --> 00:22:26,899
c plus 4 under square C equals 500 or C

00:22:24,590 --> 00:22:29,570
now if you go back to like a couple of

00:22:26,899 --> 00:22:33,860
slides ago and compare this with what we

00:22:29,570 --> 00:22:39,580
had we have a ug n of X / - BT really I

00:22:33,860 --> 00:22:39,580
mean this is compile time arithmetic yes

00:22:47,679 --> 00:22:52,940
okay so the question is why are you

00:22:49,940 --> 00:22:54,889
using the chart at about a version of

00:22:52,940 --> 00:22:56,870
the user different define literal

00:22:54,889 --> 00:23:00,440
instead of say the unsigned long or

00:22:56,870 --> 00:23:02,330
something like that the reason is that I

00:23:00,440 --> 00:23:04,879
want to create an integral constant type

00:23:02,330 --> 00:23:07,940
I need to so inside the function I need

00:23:04,879 --> 00:23:08,629
to parse the value of the literal at

00:23:07,940 --> 00:23:12,139
compile time

00:23:08,629 --> 00:23:15,019
right so that but at compile time I mean

00:23:12,139 --> 00:23:18,529
like you know I need the type that is

00:23:15,019 --> 00:23:20,929
going to be returned by by this operator

00:23:18,529 --> 00:23:23,600
this user-defined literal here is going

00:23:20,929 --> 00:23:25,429
to depend on the values of the C's here

00:23:23,600 --> 00:23:27,710
right because it's an integral constant

00:23:25,429 --> 00:23:30,950
which whose value represents what was

00:23:27,710 --> 00:23:34,039
you know the number in the indo-pak if I

00:23:30,950 --> 00:23:36,169
receive the value of that number in as

00:23:34,039 --> 00:23:37,669
an argument I do not know because we do

00:23:36,169 --> 00:23:39,500
not have context per arguments I do not

00:23:37,669 --> 00:23:41,269
know that this argument was context per

00:23:39,500 --> 00:23:42,830
and the type the return type cannot

00:23:41,269 --> 00:23:46,070
depend on that this is clear for

00:23:42,830 --> 00:23:47,960
everyone so basically I need the value

00:23:46,070 --> 00:23:49,760
of my literal to be encoded in the type

00:23:47,960 --> 00:23:51,050
of my in

00:23:49,760 --> 00:23:52,070
yeah in the type of my function so I

00:23:51,050 --> 00:23:54,020
need to receive it as a template

00:23:52,070 --> 00:23:55,280
parameter because the return type of

00:23:54,020 --> 00:23:59,230
that function is going to depend on a

00:23:55,280 --> 00:24:02,240
value of that number okay

00:23:59,230 --> 00:24:03,980
now let's see a real world example so

00:24:02,240 --> 00:24:06,910
we're going to compute the Euclidean

00:24:03,980 --> 00:24:08,870
distance in a 2d plane this is a formula

00:24:06,910 --> 00:24:11,720
this is what it looks like

00:24:08,870 --> 00:24:14,660
normally I would have to define minus a

00:24:11,720 --> 00:24:16,670
square root brace yourself

00:24:14,660 --> 00:24:18,980
plus multiplies and stuff like that

00:24:16,670 --> 00:24:20,720
equal to and then I just compute my

00:24:18,980 --> 00:24:24,470
distance and it's a bit verbose but it

00:24:20,720 --> 00:24:26,990
works very well now this is the way this

00:24:24,470 --> 00:24:28,970
is how we can do it now we just have to

00:24:26,990 --> 00:24:32,120
use normal operators because well we

00:24:28,970 --> 00:24:33,320
defined you know arithmetic operators on

00:24:32,120 --> 00:24:35,660
integral constant so everything just

00:24:33,320 --> 00:24:38,090
works square root has to be implemented

00:24:35,660 --> 00:24:41,840
using you know just normal operators to

00:24:38,090 --> 00:24:44,840
which is much easier and the key thing

00:24:41,840 --> 00:24:47,390
here is that I'm using auto and that

00:24:44,840 --> 00:24:50,330
these guys are template parameters thing

00:24:47,390 --> 00:24:52,370
is that I'm using auto here because I

00:24:50,330 --> 00:24:54,110
cannot because like them this is going

00:24:52,370 --> 00:24:56,060
to be an integral constant you know

00:24:54,110 --> 00:24:58,310
something it's not going to be like an

00:24:56,060 --> 00:24:59,870
int or float or whatever it's going to

00:24:58,310 --> 00:25:03,100
be an integral constant so I need to use

00:24:59,870 --> 00:25:05,330
auto and the type of this YS here is

00:25:03,100 --> 00:25:08,200
also going to be an integral constant

00:25:05,330 --> 00:25:10,310
and my square root has to be written

00:25:08,200 --> 00:25:12,110
such that it can work with entry port

00:25:10,310 --> 00:25:15,590
constants but it it's not like overly

00:25:12,110 --> 00:25:17,870
difficult and and then I just return so

00:25:15,590 --> 00:25:20,420
the return type of square root is going

00:25:17,870 --> 00:25:23,960
to depend on you know the type which is

00:25:20,420 --> 00:25:25,400
the type of this expression here and I'm

00:25:23,960 --> 00:25:31,310
going to return an integral constant

00:25:25,400 --> 00:25:36,320
with the proper value inside it but the

00:25:31,310 --> 00:25:38,870
real killer thing here is that since we

00:25:36,320 --> 00:25:41,000
only used normal arithmetic operators

00:25:38,870 --> 00:25:43,580
this function also works with runtime

00:25:41,000 --> 00:25:45,500
values right whereas the template that

00:25:43,580 --> 00:25:48,080
we wrote earlier it doesn't work with

00:25:45,500 --> 00:25:50,000
runtime values it's a template it takes

00:25:48,080 --> 00:25:53,210
the interval constants as a template

00:25:50,000 --> 00:25:55,370
parameters so it doesn't work with

00:25:53,210 --> 00:25:57,620
runtime values whereas this one works

00:25:55,370 --> 00:25:59,570
with runtime values and this is super

00:25:57,620 --> 00:26:03,309
cool so the thing is with this new way

00:25:59,570 --> 00:26:05,470
of seeing of doing computations

00:26:03,309 --> 00:26:08,529
compile-time using a normal value level

00:26:05,470 --> 00:26:09,970
C++ no you know normal C++ syntax thing

00:26:08,529 --> 00:26:12,999
is that you might have called right now

00:26:09,970 --> 00:26:15,159
that is read written for doing meta

00:26:12,999 --> 00:26:16,450
computations and for normal computations

00:26:15,159 --> 00:26:18,909
and this is the same code and you could

00:26:16,450 --> 00:26:21,669
reuse it right but you don't know it

00:26:18,909 --> 00:26:23,710
because because just of the way you

00:26:21,669 --> 00:26:29,139
decided to encode your type level

00:26:23,710 --> 00:26:30,870
computation and this is not all once you

00:26:29,139 --> 00:26:33,429
start looking at into your constants as

00:26:30,870 --> 00:26:36,399
objects you just you realize that you

00:26:33,429 --> 00:26:39,610
might want to you know improve their

00:26:36,399 --> 00:26:41,950
interface to do some funky things for

00:26:39,610 --> 00:26:44,110
example here I define a times member

00:26:41,950 --> 00:26:45,700
function which is going to call it takes

00:26:44,110 --> 00:26:48,070
a function and it's just gonna call the

00:26:45,700 --> 00:26:51,039
function n times so this allows me to do

00:26:48,070 --> 00:26:54,669
loop unrolling so for those of you I've

00:26:51,039 --> 00:26:57,639
already done Ruby this is pretty neat so

00:26:54,669 --> 00:27:01,210
I just say 5 times F and it just does 5

00:26:57,639 --> 00:27:02,980
times 5 times F at compile time

00:27:01,210 --> 00:27:05,110
so do I mean like the loop is enrolled

00:27:02,980 --> 00:27:06,909
at compile time which which can be nd

00:27:05,110 --> 00:27:08,230
but this is not really like I'm

00:27:06,909 --> 00:27:09,309
necessarily a standard internal

00:27:08,230 --> 00:27:11,289
constants should add that I'm just

00:27:09,309 --> 00:27:12,789
saying like this is the kind of things

00:27:11,289 --> 00:27:15,330
that we can achieve when we think out of

00:27:12,789 --> 00:27:17,559
the box for you know metaprogramming

00:27:15,330 --> 00:27:22,179
doesn't have to be ugly it can be just

00:27:17,559 --> 00:27:26,440
very useful and every time saving tuple

00:27:22,179 --> 00:27:29,710
access so right now we use to get to get

00:27:26,440 --> 00:27:31,690
the nth element of the tuple instead we

00:27:29,710 --> 00:27:33,700
could define a operator bracket that

00:27:31,690 --> 00:27:35,080
takes an integral constant and just

00:27:33,700 --> 00:27:36,309
those you know stud get with the

00:27:35,080 --> 00:27:40,330
integral the value of the integral

00:27:36,309 --> 00:27:43,210
concept and so that way we could use the

00:27:40,330 --> 00:27:46,149
bracket operator to access the members

00:27:43,210 --> 00:27:48,879
of a tuple and which is like the nice

00:27:46,149 --> 00:27:51,669
thing with this is that say you add a

00:27:48,879 --> 00:27:54,429
vector but you only accessed it using

00:27:51,669 --> 00:27:55,720
and this is our Nolan compile time well

00:27:54,429 --> 00:27:57,309
you could swap with a tuple in it would

00:27:55,720 --> 00:27:59,159
still work because we both defined this

00:27:57,309 --> 00:28:01,360
time the same operator bracket operator

00:27:59,159 --> 00:28:03,009
so as long as your indices are known at

00:28:01,360 --> 00:28:04,840
compile time there is no reason why you

00:28:03,009 --> 00:28:08,129
shouldn't be able to access a vector in

00:28:04,840 --> 00:28:08,129
the tuple differently

00:28:09,390 --> 00:28:19,570
and of course why should we stop there

00:28:15,180 --> 00:28:21,820
still the ratio defined is a quite

00:28:19,570 --> 00:28:24,490
ridiculous interface it if you ask me

00:28:21,820 --> 00:28:27,520
for doing computations on compile time

00:28:24,490 --> 00:28:29,470
ratios like stood equal a ratio equals

00:28:27,520 --> 00:28:31,210
the ratio plus the ratio multiplies the

00:28:29,470 --> 00:28:33,340
ratio divided stood ratio blah blah blah

00:28:31,210 --> 00:28:35,140
I mean it would be much simpler if they

00:28:33,340 --> 00:28:38,290
just defined the operators and it would

00:28:35,140 --> 00:28:40,630
be more natural so this is actually

00:28:38,290 --> 00:28:42,430
something that we could maybe study and

00:28:40,630 --> 00:28:45,580
proposed our standardization because it

00:28:42,430 --> 00:28:48,730
would just improve the interface price

00:28:45,580 --> 00:28:50,440
you know such a such a lot that and it's

00:28:48,730 --> 00:28:53,170
actually so trivial to implement to do

00:28:50,440 --> 00:28:55,480
that it's it's really worth it into

00:28:53,170 --> 00:28:57,010
integer sequence just the same we could

00:28:55,480 --> 00:28:59,260
maybe add like a bracket operator to

00:28:57,010 --> 00:29:03,520
check that and element of the integral

00:28:59,260 --> 00:29:05,260
of the integer sequence okay now on to

00:29:03,520 --> 00:29:06,640
type threads because I claimed that we

00:29:05,260 --> 00:29:11,260
could also do type level transformations

00:29:06,640 --> 00:29:14,440
and and well I need to show how to do

00:29:11,260 --> 00:29:17,080
that right so type threads we add

00:29:14,440 --> 00:29:19,240
functions that take types and and return

00:29:17,080 --> 00:29:21,040
types so for example I could define a

00:29:19,240 --> 00:29:23,290
add pointer made a function that just

00:29:21,040 --> 00:29:27,510
adds a pointer this is equivalent to the

00:29:23,290 --> 00:29:27,510
stood at burner in well in this channel

00:29:27,960 --> 00:29:33,430
but now let's try to replicate basically

00:29:31,870 --> 00:29:36,790
what we did would enter your constants

00:29:33,430 --> 00:29:38,950
where we lifted you know the types to

00:29:36,790 --> 00:29:40,630
values so instead of using you know

00:29:38,950 --> 00:29:43,000
enter your constants as types we use

00:29:40,630 --> 00:29:44,890
them as values and instead of having

00:29:43,000 --> 00:29:47,020
meta functions to manipulate them we now

00:29:44,890 --> 00:29:49,360
have functions the way we do it is quite

00:29:47,020 --> 00:29:52,060
simple we just define the type threads

00:29:49,360 --> 00:29:53,260
so we defined a dummy wrapper to all the

00:29:52,060 --> 00:29:55,300
types okay

00:29:53,260 --> 00:29:58,900
just like integral constant was a demi

00:29:55,300 --> 00:30:01,270
wrapper to old an integral constant well

00:29:58,900 --> 00:30:02,530
you know it like an integer value that's

00:30:01,270 --> 00:30:04,030
known at compile time it was just a

00:30:02,530 --> 00:30:05,770
wrapper to hold that and to pass this

00:30:04,030 --> 00:30:06,910
around now we're gonna do exactly the

00:30:05,770 --> 00:30:11,470
same with a different compile time

00:30:06,910 --> 00:30:13,510
entity types and so I think I define a

00:30:11,470 --> 00:30:16,540
function that takes the type returns the

00:30:13,510 --> 00:30:17,860
type and I take a function I define a

00:30:16,540 --> 00:30:20,970
function that takes the type and returns

00:30:17,860 --> 00:30:26,010
like an integral constant I can do this

00:30:20,970 --> 00:30:28,050
and then you can create an object that

00:30:26,010 --> 00:30:29,940
represents a type just call your

00:30:28,050 --> 00:30:34,080
function which does the type trait on it

00:30:29,940 --> 00:30:36,630
and that's it so you have value level

00:30:34,080 --> 00:30:37,950
syntax normal su + % x4 doing type made

00:30:36,630 --> 00:30:40,050
of metal computations type level

00:30:37,950 --> 00:30:42,600
computations now you can go one step

00:30:40,050 --> 00:30:46,620
further and just define like a context

00:30:42,600 --> 00:30:48,150
per variable template you don't actually

00:30:46,620 --> 00:30:53,460
save any typing it's just for

00:30:48,150 --> 00:30:55,490
consistency in this dog okay now why

00:30:53,460 --> 00:31:00,720
should we really want to do this

00:30:55,490 --> 00:31:03,000
well since since types are represented

00:31:00,720 --> 00:31:04,920
as objects they are first-class citizens

00:31:03,000 --> 00:31:06,810
which means that we can put them into

00:31:04,920 --> 00:31:09,000
two poles okay

00:31:06,810 --> 00:31:11,010
we can also put like create a vector

00:31:09,000 --> 00:31:12,420
with types in it but they would need to

00:31:11,010 --> 00:31:13,920
all represent the same type right

00:31:12,420 --> 00:31:16,620
because you would say like stood vector

00:31:13,920 --> 00:31:17,790
type int for example and then you would

00:31:16,620 --> 00:31:19,350
just add like default constructed

00:31:17,790 --> 00:31:21,150
objects in that vector so it's not

00:31:19,350 --> 00:31:23,910
really useful you could but it's really

00:31:21,150 --> 00:31:26,040
not useful but where this is really

00:31:23,910 --> 00:31:27,870
useful is if you if you use it to pull

00:31:26,040 --> 00:31:32,790
because now you can have different types

00:31:27,870 --> 00:31:34,890
inside you tuple and yeah so then you

00:31:32,790 --> 00:31:39,060
can just manipulate types as if they

00:31:34,890 --> 00:31:42,600
were normal objects now the following

00:31:39,060 --> 00:31:47,130
which can be used so before say you

00:31:42,600 --> 00:31:49,080
wanted to to filter to filter the

00:31:47,130 --> 00:31:52,740
elements of a type of sequence you will

00:31:49,080 --> 00:31:56,550
need to use the tender nasty MPL lambda

00:31:52,740 --> 00:32:01,530
expression domain-specific language to

00:31:56,550 --> 00:32:03,570
define your predicate and now since we

00:32:01,530 --> 00:32:05,190
are just manipulating normal C++ objects

00:32:03,570 --> 00:32:06,660
there is absolutely no reason why we

00:32:05,190 --> 00:32:09,480
couldn't just write a normal generic

00:32:06,660 --> 00:32:12,480
lambda to do it so instead of writing or

00:32:09,480 --> 00:32:15,900
predicate as a type level you know meta

00:32:12,480 --> 00:32:18,810
function or something like a NPL lambda

00:32:15,900 --> 00:32:21,930
expression which basically is a hidden

00:32:18,810 --> 00:32:26,340
meta function we can just write it very

00:32:21,930 --> 00:32:28,260
naturally using the normal C++ syntax so

00:32:26,340 --> 00:32:30,840
what I'm doing here this example is

00:32:28,260 --> 00:32:33,930
really like I take it I create a

00:32:30,840 --> 00:32:35,220
sequence which contains types and then I

00:32:33,930 --> 00:32:37,620
just feel

00:32:35,220 --> 00:32:40,590
and I just keep the ones that are either

00:32:37,620 --> 00:32:43,710
a pointer or a reference so this is a

00:32:40,590 --> 00:32:52,500
new temple which contains type types

00:32:43,710 --> 00:32:55,440
each are and types avoid butter now

00:32:52,500 --> 00:32:57,120
again since we are using the same syntax

00:32:55,440 --> 00:33:00,110
for type of and valuable metaprogramming

00:32:57,120 --> 00:33:04,050
we just need a single library to do it

00:33:00,110 --> 00:33:08,790
so whereas we needed MPL and fusion to

00:33:04,050 --> 00:33:11,010
achieve this in well before I suppose 14

00:33:08,790 --> 00:33:15,690
now we can we can achieve exactly the

00:33:11,010 --> 00:33:19,140
same thing using a single library and as

00:33:15,690 --> 00:33:20,460
you will probably observe the syntax is

00:33:19,140 --> 00:33:22,770
pretty much the same all the time so

00:33:20,460 --> 00:33:26,130
it's easier to learn too soon easier to

00:33:22,770 --> 00:33:28,230
teach fewer dependencies and it just

00:33:26,130 --> 00:33:35,490
interoperates like perfectly because

00:33:28,230 --> 00:33:37,170
it's actually just a single library now

00:33:35,490 --> 00:33:41,760
the fact that we have a unified syntax

00:33:37,170 --> 00:33:43,830
means we can reuse more stuff like I

00:33:41,760 --> 00:33:47,370
said earlier with the compile time

00:33:43,830 --> 00:33:50,730
arithmetic example it's possible that

00:33:47,370 --> 00:33:54,180
some functions or some code that you

00:33:50,730 --> 00:33:57,540
wrote for normal for normal you know C++

00:33:54,180 --> 00:33:59,970
runtime C++ actually works with compiled

00:33:57,540 --> 00:34:02,520
by entities to and you're just not aware

00:33:59,970 --> 00:34:05,610
of it so what I did is I took boost

00:34:02,520 --> 00:34:07,770
proto which is very nice but also very

00:34:05,610 --> 00:34:09,510
complicated like boost library for doing

00:34:07,770 --> 00:34:10,500
expression templates so of course the

00:34:09,510 --> 00:34:11,870
library is complicated because the

00:34:10,500 --> 00:34:18,090
application is also quite complicated

00:34:11,870 --> 00:34:21,149
and so I went into the tutorial and

00:34:18,090 --> 00:34:23,190
found called a an example there which

00:34:21,149 --> 00:34:25,110
basically creates a domain-specific

00:34:23,190 --> 00:34:28,770
language a very simple domain-specific

00:34:25,110 --> 00:34:31,070
language for creating arithmetic

00:34:28,770 --> 00:34:33,419
expressions so this is something that

00:34:31,070 --> 00:34:34,800
basically represents you know well the

00:34:33,419 --> 00:34:38,159
first argument - the second argument

00:34:34,800 --> 00:34:39,870
over the the second argument and the

00:34:38,159 --> 00:34:42,000
nice thing is that when I evaluate this

00:34:39,870 --> 00:34:44,820
expression and I pass it to compile time

00:34:42,000 --> 00:34:48,169
entities it works it returns an integral

00:34:44,820 --> 00:34:50,359
constant and I can also so it was a risk

00:34:48,169 --> 00:34:52,429
written for our runtime computations of

00:34:50,359 --> 00:34:54,409
course but it turns out that with like

00:34:52,429 --> 00:34:56,929
very very little modification you can

00:34:54,409 --> 00:34:58,819
work it can also work with compile time

00:34:56,929 --> 00:35:02,059
entities and what I can tell you for

00:34:58,819 --> 00:35:04,809
sure is that when Eric nibbler wrote

00:35:02,059 --> 00:35:07,280
this library he had no idea that I would

00:35:04,809 --> 00:35:08,900
sometime you know come and and just like

00:35:07,280 --> 00:35:11,000
put integral constants in there and it

00:35:08,900 --> 00:35:14,540
would work like he couldn't know it

00:35:11,000 --> 00:35:16,190
right it wasn't it wasn't planned but it

00:35:14,540 --> 00:35:18,609
just works because we're reusing the

00:35:16,190 --> 00:35:21,200
same syntax this is really really nice I

00:35:18,609 --> 00:35:24,410
was actually very surprised at this that

00:35:21,200 --> 00:35:25,670
it I was like wow I mean didn't I didn't

00:35:24,410 --> 00:35:33,819
think it was gonna work but I know oh

00:35:25,670 --> 00:35:36,559
okay I think we got something else again

00:35:33,819 --> 00:35:39,829
since we have a single syntax for type

00:35:36,559 --> 00:35:42,890
level and value level computations we

00:35:39,829 --> 00:35:44,240
can have more consistent code so this is

00:35:42,890 --> 00:35:46,280
an example of creating a compile time

00:35:44,240 --> 00:35:48,950
map with boost fusion a hit originals

00:35:46,280 --> 00:35:51,859
maps are so basically you defined the

00:35:48,950 --> 00:35:53,480
keys of the map here and the values of

00:35:51,859 --> 00:35:55,010
the map here and it's not exactly

00:35:53,480 --> 00:35:59,900
obvious to someone who has never seen

00:35:55,010 --> 00:36:01,970
this code what it does it stirs but not

00:35:59,900 --> 00:36:03,829
exactly intuitive and then you access

00:36:01,970 --> 00:36:05,780
the elements of the map using you know

00:36:03,829 --> 00:36:08,720
the type to which they are associated

00:36:05,780 --> 00:36:10,730
the syntax is slightly clunky it works

00:36:08,720 --> 00:36:11,599
very well but it's likely clunky and you

00:36:10,730 --> 00:36:14,750
have to know what you're doing

00:36:11,599 --> 00:36:18,200
whereas I think this is while this is

00:36:14,750 --> 00:36:20,270
more verbose it's also more obvious you

00:36:18,200 --> 00:36:23,030
would expect to create a map using you

00:36:20,270 --> 00:36:25,040
know sequence of pairs just like we do

00:36:23,030 --> 00:36:26,780
in the center library and then you

00:36:25,040 --> 00:36:27,950
associate types to you know the value

00:36:26,780 --> 00:36:31,700
you want and then you just use your

00:36:27,950 --> 00:36:33,849
bracket operator to to get the value you

00:36:31,700 --> 00:36:33,849
want

00:36:35,700 --> 00:36:43,060
okay

00:36:36,880 --> 00:36:46,690
I went quite fast so now let us let us

00:36:43,060 --> 00:36:49,920
look at a case study so this is a switch

00:36:46,690 --> 00:36:56,980
for a boost and the goal here is the

00:36:49,920 --> 00:36:59,590
goal is to is to create a switch which

00:36:56,980 --> 00:37:01,570
takes a boost ne and then depending on

00:36:59,590 --> 00:37:03,640
the basically it's going to look at the

00:37:01,570 --> 00:37:05,550
dynamic type of the boost ne and it's

00:37:03,640 --> 00:37:08,260
going to dispatch the proper function

00:37:05,550 --> 00:37:09,760
right inside the cases that I gave and

00:37:08,260 --> 00:37:11,440
so if the boost I need turns out to be

00:37:09,760 --> 00:37:15,070
empty I want to get to the empty class

00:37:11,440 --> 00:37:24,760
and if any nothing matches I want to get

00:37:15,070 --> 00:37:26,200
to the default class so first we want to

00:37:24,760 --> 00:37:28,960
make it really simple so we're just

00:37:26,200 --> 00:37:33,160
gonna use so we're defining we're gonna

00:37:28,960 --> 00:37:35,140
define a case in in this here we're

00:37:33,160 --> 00:37:41,010
defining a case to be like a pair which

00:37:35,140 --> 00:37:44,950
associates type to a function okay and

00:37:41,010 --> 00:37:48,670
then we define this we define this

00:37:44,950 --> 00:37:50,140
default case here to be just to be we

00:37:48,670 --> 00:37:53,110
just defined a dummy type which

00:37:50,140 --> 00:37:56,440
represents the default choice and so

00:37:53,110 --> 00:37:57,670
case case angle bracket default II is

00:37:56,440 --> 00:38:00,400
just going to be you know like this

00:37:57,670 --> 00:38:02,200
function here which associate default

00:38:00,400 --> 00:38:05,560
underscore t to whatever function you're

00:38:02,200 --> 00:38:11,650
going to pass to the lender and

00:38:05,560 --> 00:38:13,840
similarly to for empty now here's what

00:38:11,650 --> 00:38:21,730
the switch looks like so since I want to

00:38:13,840 --> 00:38:23,080
have this cute little syntax here I want

00:38:21,730 --> 00:38:25,480
to have this cute little syntax area of

00:38:23,080 --> 00:38:27,940
calling a and then parens parens and

00:38:25,480 --> 00:38:29,470
then BOOM my cases I'm going to have to

00:38:27,940 --> 00:38:33,640
return a function from the switch here

00:38:29,470 --> 00:38:34,270
this is what I'm doing here switch

00:38:33,640 --> 00:38:38,950
returns

00:38:34,270 --> 00:38:44,930
Olinda which takes the cases good

00:38:38,950 --> 00:38:47,750
then first I so this lambda here takes

00:38:44,930 --> 00:38:49,940
the cases now a pearler pack is very

00:38:47,750 --> 00:38:52,280
nasty to manipulate if you want to do

00:38:49,940 --> 00:38:54,530
anything non-trivial so I just put this

00:38:52,280 --> 00:38:56,600
in a tuple and then we have all like

00:38:54,530 --> 00:39:00,350
fancy algorithms to manipulate tuples

00:38:56,600 --> 00:39:02,810
just as we do with studio so I'm going

00:39:00,350 --> 00:39:05,060
to find the default case because the

00:39:02,810 --> 00:39:06,890
default case could be anywhere so I'm

00:39:05,060 --> 00:39:10,490
just gonna find the default case by

00:39:06,890 --> 00:39:12,410
saying a so each see here is a is a pair

00:39:10,490 --> 00:39:14,180
right which associates a type to a

00:39:12,410 --> 00:39:16,280
function so I'm gonna find the first one

00:39:14,180 --> 00:39:17,840
which type is the default type which

00:39:16,280 --> 00:39:21,830
dummy type that I said would represent

00:39:17,840 --> 00:39:24,230
the default case and then so I find if I

00:39:21,830 --> 00:39:26,330
find yet the first one the default case

00:39:24,230 --> 00:39:28,190
basically now finally if he returns a

00:39:26,330 --> 00:39:30,500
compile-time optional it's like a stood

00:39:28,190 --> 00:39:32,810
option or boost optional except that

00:39:30,500 --> 00:39:36,230
whether it is empty or not is known at

00:39:32,810 --> 00:39:37,910
compile time so then I static assert

00:39:36,230 --> 00:39:40,670
that you know I found the default case

00:39:37,910 --> 00:39:41,930
because otherwise you messed up right so

00:39:40,670 --> 00:39:44,450
compile time it's gonna tell you I

00:39:41,930 --> 00:39:48,980
you're missing something I need like you

00:39:44,450 --> 00:39:51,020
know to be exhaustive and then I get the

00:39:48,980 --> 00:39:52,730
other cases I just get the rest of the

00:39:51,020 --> 00:39:55,030
cases by filtering by just keeping all

00:39:52,730 --> 00:39:58,610
the ones that are not the default case

00:39:55,030 --> 00:40:00,320
okay filter here is like copy F it's the

00:39:58,610 --> 00:40:04,430
same except I really don't like Kabir

00:40:00,320 --> 00:40:07,070
the name so and then I unpack the rest

00:40:04,430 --> 00:40:09,110
of these cases and to this generic

00:40:07,070 --> 00:40:10,580
lambda here and I call in poll which I'm

00:40:09,110 --> 00:40:13,520
going to show you in a second what

00:40:10,580 --> 00:40:15,800
unpack does is is the same thing as to

00:40:13,520 --> 00:40:17,410
the ply which is proposed like for the I

00:40:15,800 --> 00:40:19,790
think it's the library fundamentals TS

00:40:17,410 --> 00:40:23,270
but basically what it does is take a

00:40:19,790 --> 00:40:26,120
tuple and cause a function with the

00:40:23,270 --> 00:40:27,620
elements of the tuple and the reason why

00:40:26,120 --> 00:40:30,800
I am doing this is because I'm going to

00:40:27,620 --> 00:40:32,720
want to process the the cases

00:40:30,800 --> 00:40:35,270
recursively using parameter packs

00:40:32,720 --> 00:40:37,610
because in this case is the simplest way

00:40:35,270 --> 00:40:39,530
to do it so I'm not advocating that you

00:40:37,610 --> 00:40:41,360
should use like two poles and algorithms

00:40:39,530 --> 00:40:42,770
and then all the time sometimes wrap our

00:40:41,360 --> 00:40:45,950
owner back Sarge is a simplest way to go

00:40:42,770 --> 00:40:48,080
not all the time all the time so yeah so

00:40:45,950 --> 00:40:50,540
here I use algorithms algorithms and no

00:40:48,080 --> 00:40:52,930
more algorithms in there so now let's

00:40:50,540 --> 00:40:55,210
dive into our result oh yeah and so

00:40:52,930 --> 00:40:56,290
default arrow segond here is because

00:40:55,210 --> 00:40:58,750
default is a compile-time

00:40:56,290 --> 00:41:00,670
optional right so I'm just fetching the

00:40:58,750 --> 00:41:03,580
second member of the pair which is

00:41:00,670 --> 00:41:05,320
inside the optional and I have the right

00:41:03,580 --> 00:41:07,450
to do it because I already static

00:41:05,320 --> 00:41:10,780
asserted that it was it contained

00:41:07,450 --> 00:41:13,240
something and a type area is just like

00:41:10,780 --> 00:41:15,250
the runtime type information of the

00:41:13,240 --> 00:41:18,430
Boustany like the element inside the

00:41:15,250 --> 00:41:25,270
blue stain so now I'm gonna process

00:41:18,430 --> 00:41:30,070
cases so so there are two branches in

00:41:25,270 --> 00:41:32,800
the if let's ignore this branch here so

00:41:30,070 --> 00:41:34,540
like like if the type ID you know of the

00:41:32,800 --> 00:41:37,330
the case that I'm processing right now

00:41:34,540 --> 00:41:39,340
is the type ID of the you know it

00:41:37,330 --> 00:41:41,350
matches the runtime type of the Boustany

00:41:39,340 --> 00:41:43,330
then I just I just do this which I'm

00:41:41,350 --> 00:41:45,120
going to explain next and then otherwise

00:41:43,330 --> 00:41:47,350
I just you know presses the rest

00:41:45,120 --> 00:41:48,430
recursively very simple I'm going to

00:41:47,350 --> 00:41:49,180
show you the base case and then we'll

00:41:48,430 --> 00:41:51,520
come back

00:41:49,180 --> 00:41:54,070
so the base case is when I'm empty I

00:41:51,520 --> 00:41:59,340
just called the default case with no

00:41:54,070 --> 00:42:04,570
arguments okay now we're going back here

00:41:59,340 --> 00:42:11,500
okay okay good fifteen minutes so I'm

00:42:04,570 --> 00:42:14,920
really okay so basically here I fetch

00:42:11,500 --> 00:42:16,330
the pipe represented by the type

00:42:14,920 --> 00:42:18,250
underscore C okay

00:42:16,330 --> 00:42:19,510
I actually didn't show you that because

00:42:18,250 --> 00:42:23,140
I thought we would be running out of

00:42:19,510 --> 00:42:25,060
time but normally these these like type

00:42:23,140 --> 00:42:28,660
objects type angry bracket objects

00:42:25,060 --> 00:42:30,310
haven't nested Colin Colin pipe okay

00:42:28,660 --> 00:42:33,070
which represents that pipe that's in

00:42:30,310 --> 00:42:35,950
there that the t you know so a type t as

00:42:33,070 --> 00:42:41,020
a nested Colin Colin type alias which

00:42:35,950 --> 00:42:43,570
represents T so when I get when I get a

00:42:41,020 --> 00:42:46,510
case which is a pair which associates

00:42:43,570 --> 00:42:48,340
you know a type and liberated T to a

00:42:46,510 --> 00:42:50,970
function object I can take the first

00:42:48,340 --> 00:42:53,320
pair member of the pair which is a type

00:42:50,970 --> 00:42:55,360
angry bracket T okay

00:42:53,320 --> 00:42:57,940
and Jen then they call type this object

00:42:55,360 --> 00:43:01,330
which gives me the the actual you know

00:42:57,940 --> 00:43:03,760
type angle bracket T and then I fetch a

00:43:01,330 --> 00:43:05,190
nested column column type and that gives

00:43:03,760 --> 00:43:10,269
me the T in there

00:43:05,190 --> 00:43:15,490
is everybody following so that's what I

00:43:10,269 --> 00:43:18,940
do here and then so if the run time type

00:43:15,490 --> 00:43:20,829
of the boost any matches the T inside

00:43:18,940 --> 00:43:25,660
you know the K well basically the the

00:43:20,829 --> 00:43:28,150
type of that case I ran this and

00:43:25,660 --> 00:43:29,140
otherwise like I said I just do it

00:43:28,150 --> 00:43:33,329
recursively now

00:43:29,140 --> 00:43:38,289
now if the type here is void

00:43:33,329 --> 00:43:41,589
it means that I got an empty any so I'm

00:43:38,289 --> 00:43:43,869
going to return from the if not from the

00:43:41,589 --> 00:43:46,509
function from the if I'm going to return

00:43:43,869 --> 00:43:48,099
this lambda here and otherwise I'm going

00:43:46,509 --> 00:43:51,369
to return this lender here and I'm going

00:43:48,099 --> 00:43:55,150
to call whatever lambda I returned with

00:43:51,369 --> 00:43:57,099
the case and the any the reason why I'm

00:43:55,150 --> 00:44:02,440
doing this instead of using a normal run

00:43:57,099 --> 00:44:04,599
time if is because if if the type T here

00:44:02,440 --> 00:44:06,779
so if my Amy is not empty if I'm not

00:44:04,599 --> 00:44:09,819
currently processing the empty case I

00:44:06,779 --> 00:44:11,890
cannot call the function with no

00:44:09,819 --> 00:44:20,440
arguments so it's going to be a compile

00:44:11,890 --> 00:44:22,539
time error so I need to to to like to

00:44:20,440 --> 00:44:24,400
make you know this this call here

00:44:22,539 --> 00:44:26,680
dependent on something so that the

00:44:24,400 --> 00:44:28,599
compiler only does you know syntactic

00:44:26,680 --> 00:44:31,960
analysis but no like it doesn't actually

00:44:28,599 --> 00:44:35,109
try to to call the the function until it

00:44:31,960 --> 00:44:40,079
really needs to so the thing is that

00:44:35,109 --> 00:44:43,569
this if ear is a takes a compile time

00:44:40,079 --> 00:44:46,269
integral constant boolean integral are

00:44:43,569 --> 00:44:49,509
constant and it's going to return this

00:44:46,269 --> 00:44:52,599
one or this one and since the C inside

00:44:49,509 --> 00:44:55,239
this function is auto the compiler

00:44:52,599 --> 00:44:57,009
doesn't know what is the type until I

00:44:55,239 --> 00:45:01,450
call it but I'm never going to call it

00:44:57,009 --> 00:45:07,210
if it's not the empty dmt in is

00:45:01,450 --> 00:45:08,859
everybody following me yes so the

00:45:07,210 --> 00:45:10,930
comment is that it's pretty much a

00:45:08,859 --> 00:45:14,220
static if and it is exactly a static it

00:45:10,930 --> 00:45:14,220
actually I think I will change the name

00:45:15,760 --> 00:45:21,400
so it's a static really but the way to

00:45:19,150 --> 00:45:24,130
emulate you know etiquette which could

00:45:21,400 --> 00:45:25,750
be a language feature but now to there

00:45:24,130 --> 00:45:28,150
will be a way to emulate it with the

00:45:25,750 --> 00:45:30,550
library is to make both branches you

00:45:28,150 --> 00:45:32,230
know lazy by just making them lambdas

00:45:30,550 --> 00:45:36,130
and then you return the branch and you

00:45:32,230 --> 00:45:39,970
do whatever you want with it and then so

00:45:36,130 --> 00:45:42,670
if it's not the default case no the

00:45:39,970 --> 00:45:46,200
empty case then I just call and just

00:45:42,670 --> 00:45:48,940
test the you know the boost any to the T

00:45:46,200 --> 00:45:52,150
to you know that the type that I'm I'm

00:45:48,940 --> 00:45:54,550
currently processing and then I I just

00:45:52,150 --> 00:45:59,560
call my function with that type here and

00:45:54,550 --> 00:46:13,090
that's it is everybody following awesome

00:45:59,560 --> 00:46:16,750
yes okay so the question is or the

00:46:13,090 --> 00:46:19,570
comment is that so this function here is

00:46:16,750 --> 00:46:22,210
not context burst so intent is that this

00:46:19,570 --> 00:46:23,950
can only work with runtime objects and

00:46:22,210 --> 00:46:27,940
yes indeed it doesn't always make sense

00:46:23,950 --> 00:46:30,520
to you know to have all computations at

00:46:27,940 --> 00:46:32,260
that working it both at compile time and

00:46:30,520 --> 00:46:34,690
you know can sexpert and uncle sexpert

00:46:32,260 --> 00:46:37,720
because for example well boost any does

00:46:34,690 --> 00:46:39,070
allocations that you know the RTT i did

00:46:37,720 --> 00:46:43,270
they stood they type index we do not

00:46:39,070 --> 00:46:45,400
have this compile time so yeah it only

00:46:43,270 --> 00:46:47,890
works with with runtime objects it

00:46:45,400 --> 00:46:50,970
wouldn't it wouldn't make any sense to

00:46:47,890 --> 00:46:50,970
have this con cipher yep

00:46:53,820 --> 00:47:02,310
okay so the base case we already saw so

00:46:57,600 --> 00:47:03,720
this is about like 70 lines of code and

00:47:02,310 --> 00:47:10,100
your co-workers could understand it

00:47:03,720 --> 00:47:12,660
mostly and so this was actually based by

00:47:10,100 --> 00:47:16,620
unlike a presentation that was done and

00:47:12,660 --> 00:47:18,030
C++ now by Sebastian riddle he's a very

00:47:16,620 --> 00:47:20,010
very very smart guy

00:47:18,030 --> 00:47:23,610
but he didn't use a meta programming

00:47:20,010 --> 00:47:26,340
library and his solution was it add more

00:47:23,610 --> 00:47:28,200
features but it was still much more you

00:47:26,340 --> 00:47:30,780
know much longer and more complicated so

00:47:28,200 --> 00:47:32,670
it really helps to have a meta

00:47:30,780 --> 00:47:34,970
programming library to to help you with

00:47:32,670 --> 00:47:37,350
non trivial tasks and then when you are

00:47:34,970 --> 00:47:39,030
you know actually doing something that

00:47:37,350 --> 00:47:40,500
that's quite simple like processing

00:47:39,030 --> 00:47:42,030
cases recursively just drop them into

00:47:40,500 --> 00:47:43,890
programming it's going to be a real

00:47:42,030 --> 00:47:46,290
pinion you know and about to try to use

00:47:43,890 --> 00:47:47,670
it so just just do it recursively but

00:47:46,290 --> 00:47:49,740
for the filtering for finding something

00:47:47,670 --> 00:47:51,810
in you know in the in the types in a

00:47:49,740 --> 00:47:53,780
sequence for doing that kind of stuff

00:47:51,810 --> 00:47:59,880
it's very handy to have you know nice

00:47:53,780 --> 00:48:01,830
standard algorithm looking tools okay so

00:47:59,880 --> 00:48:04,200
now my proposal and hopefully your

00:48:01,830 --> 00:48:06,420
deliverance from art to do meta

00:48:04,200 --> 00:48:09,650
programming is Hannah

00:48:06,420 --> 00:48:12,120
actually now boost Hannah which is a a

00:48:09,650 --> 00:48:15,810
library for entertainers and type of

00:48:12,120 --> 00:48:18,270
computations so it does everything that

00:48:15,810 --> 00:48:19,710
the MPL does which is type little

00:48:18,270 --> 00:48:24,480
computations it also does everything

00:48:19,710 --> 00:48:24,900
that fusion does except except it's not

00:48:24,480 --> 00:48:26,880
lazy

00:48:24,900 --> 00:48:29,130
it's eager so it's just for you know

00:48:26,880 --> 00:48:32,250
people who know choosing very well

00:48:29,130 --> 00:48:38,060
everything in infusion I mean in Hana is

00:48:32,250 --> 00:48:38,060
is eager instead of being lazy yes I

00:48:45,410 --> 00:48:49,620
have no idea

00:48:47,640 --> 00:48:51,180
well I mean I could look at it but oh

00:48:49,620 --> 00:48:53,310
yes so the question is what is the

00:48:51,180 --> 00:48:57,690
approximate time compile time for for

00:48:53,310 --> 00:49:00,120
this for this switch any sample ah maybe

00:48:57,690 --> 00:49:02,070
one second but there are like many test

00:49:00,120 --> 00:49:04,350
cases in my in my big because like all

00:49:02,070 --> 00:49:05,820
of this code compiles actually um the

00:49:04,350 --> 00:49:07,230
samples are taken automatically and put

00:49:05,820 --> 00:49:10,140
into my slides so

00:49:07,230 --> 00:49:11,940
but there are many unit tests so maybe

00:49:10,140 --> 00:49:13,350
the file takes something like 1 second

00:49:11,940 --> 00:49:15,060
or so there are a couple of unit tests

00:49:13,350 --> 00:49:16,950
so yeah it's it's really not that bad

00:49:15,060 --> 00:49:18,690
it's much better than if you use another

00:49:16,950 --> 00:49:20,369
metaprogramming library and it's much

00:49:18,690 --> 00:49:23,970
less complicated than if you rolled your

00:49:20,369 --> 00:49:26,220
own if you rolled your own is depending

00:49:23,970 --> 00:49:27,330
on the complex so depending on the

00:49:26,220 --> 00:49:30,270
complexity of the problem that you're

00:49:27,330 --> 00:49:32,100
trying to solve it might be faster you

00:49:30,270 --> 00:49:34,560
can might compile faster than if you use

00:49:32,100 --> 00:49:35,700
say an ax depending on the complexity of

00:49:34,560 --> 00:49:37,410
what you're trying to do if you're

00:49:35,700 --> 00:49:40,260
trying to do something come slightly

00:49:37,410 --> 00:49:42,150
complex be assured that we are more

00:49:40,260 --> 00:49:45,000
clever than you in Hana and that we make

00:49:42,150 --> 00:49:47,700
it like we are the algorithm that that

00:49:45,000 --> 00:49:50,340
we use are more optimized but for very

00:49:47,700 --> 00:49:51,300
simple things you might be able to you

00:49:50,340 --> 00:49:54,210
know to have something that can pass

00:49:51,300 --> 00:49:55,590
faster because you have no you don't

00:49:54,210 --> 00:49:57,510
even have the overhead of just including

00:49:55,590 --> 00:50:02,100
the library which is like 0.3 seconds or

00:49:57,510 --> 00:50:07,500
something so yeah so it's quite fast at

00:50:02,100 --> 00:50:08,970
compile time and I wasn't really clever

00:50:07,500 --> 00:50:11,190
actually in this implementation because

00:50:08,970 --> 00:50:17,100
as you see as you might have seen I'm

00:50:11,190 --> 00:50:18,960
I'm I find it and then I filter and then

00:50:17,100 --> 00:50:20,940
I unpack there's like duplicate work

00:50:18,960 --> 00:50:22,800
here I'm looking I'm like going through

00:50:20,940 --> 00:50:25,290
the sequence finding this case and then

00:50:22,800 --> 00:50:26,640
I go again through the filter this all

00:50:25,290 --> 00:50:28,680
sequence filtering I could have like

00:50:26,640 --> 00:50:30,600
partitioned instead partition the

00:50:28,680 --> 00:50:32,910
sequence into two different things like

00:50:30,600 --> 00:50:35,580
a sequence that contains only you know

00:50:32,910 --> 00:50:37,140
the default case and a sequence which

00:50:35,580 --> 00:50:39,540
contains all the rest it would be

00:50:37,140 --> 00:50:46,410
probably more efficient so yeah but it

00:50:39,540 --> 00:50:48,869
was mostly for education here so yeah

00:50:46,410 --> 00:50:50,940
the genes-- anti-public computations

00:50:48,869 --> 00:50:52,890
although the the Trojans computations

00:50:50,940 --> 00:50:54,390
for now our only eager I'm planning on

00:50:52,890 --> 00:50:56,040
maybe adding views because there seems

00:50:54,390 --> 00:50:58,590
to be a need for it but for now it's not

00:50:56,040 --> 00:51:00,570
there there are more than 80 algorithms

00:50:58,590 --> 00:51:02,609
most of which are highly optimized both

00:51:00,570 --> 00:51:04,230
for a runtime and compile time we are

00:51:02,609 --> 00:51:07,380
using pretty clever techniques which I

00:51:04,230 --> 00:51:09,600
will have the time to show go a bit

00:51:07,380 --> 00:51:11,310
faster and then there are about eight

00:51:09,600 --> 00:51:14,040
versions containers like a compile time

00:51:11,310 --> 00:51:16,619
map the compile time set a two-pole

00:51:14,040 --> 00:51:18,240
which is actually much more compelling

00:51:16,619 --> 00:51:20,230
efficient than its dead tuple so you

00:51:18,240 --> 00:51:23,680
might want to change

00:51:20,230 --> 00:51:25,390
and and there is like also a

00:51:23,680 --> 00:51:26,980
compile-time optional there's a

00:51:25,390 --> 00:51:29,950
compile-time strain class there is a

00:51:26,980 --> 00:51:32,380
compile-time compile time range stuff

00:51:29,950 --> 00:51:33,910
like that and so yeah the compile times

00:51:32,380 --> 00:51:36,850
are much better the run time the

00:51:33,910 --> 00:51:39,040
execution times are quite good also they

00:51:36,850 --> 00:51:41,830
should be matching with those boost

00:51:39,040 --> 00:51:44,740
fusion which is pretty much you know

00:51:41,830 --> 00:51:47,890
what you would write with what you would

00:51:44,740 --> 00:51:49,690
achieve with and written code it's

00:51:47,890 --> 00:51:52,780
working on C++ 14 compilers which means

00:51:49,690 --> 00:51:55,960
only client because even though GCC is

00:51:52,780 --> 00:51:58,360
supposedly C++ we can comply it it's

00:51:55,960 --> 00:52:01,630
full of bugs so so it's not quite

00:51:58,360 --> 00:52:02,920
working and I mean yeah so um it's it's

00:52:01,630 --> 00:52:04,360
almost there there are a couple of bugs

00:52:02,920 --> 00:52:06,400
that still need to be fixed

00:52:04,360 --> 00:52:08,950
I'm I'm really looking forward for the

00:52:06,400 --> 00:52:10,630
GCC team to take my bug reports slightly

00:52:08,950 --> 00:52:13,360
more seriously and to be slightly more

00:52:10,630 --> 00:52:14,950
responsive but apart from that like

00:52:13,360 --> 00:52:17,230
we're really close to maybe two or three

00:52:14,950 --> 00:52:19,150
bug reports left to fix and and we

00:52:17,230 --> 00:52:20,710
should be good for maybe five point JCC

00:52:19,150 --> 00:52:22,660
five point three or something and other

00:52:20,710 --> 00:52:26,109
than that well it works on Apple crying

00:52:22,660 --> 00:52:26,800
and and client yeah you know then very

00:52:26,109 --> 00:52:31,390
very funny

00:52:26,800 --> 00:52:33,010
and miss PC well I'm sorry guys and yet

00:52:31,390 --> 00:52:34,630
so the good news is that it was accepted

00:52:33,010 --> 00:52:38,170
in boost I'm working very hard to make

00:52:34,630 --> 00:52:40,420
it part of the next you know release now

00:52:38,170 --> 00:52:42,130
this is my own work towards you so my

00:52:40,420 --> 00:52:44,710
own work towards you is to continue

00:52:42,130 --> 00:52:47,590
improving the library to fix bugs when

00:52:44,710 --> 00:52:48,940
there are some to work very hard so that

00:52:47,590 --> 00:52:50,650
it can be part of the next books release

00:52:48,940 --> 00:52:52,060
you know to make this available and

00:52:50,650 --> 00:52:56,670
production really as soon as possible

00:52:52,060 --> 00:53:01,090
for you guys your homework is to try it

00:52:56,670 --> 00:53:05,530
it's just to use it to you know file bug

00:53:01,090 --> 00:53:08,200
reports submit suggestions so we can

00:53:05,530 --> 00:53:09,670
improve and you know there's no library

00:53:08,200 --> 00:53:12,010
that that's really good without having

00:53:09,670 --> 00:53:13,660
large user base which can really like

00:53:12,010 --> 00:53:15,220
say hey I need this I need that that I

00:53:13,660 --> 00:53:18,760
don't need so we're gonna you know work

00:53:15,220 --> 00:53:20,859
together and and build ourselves a very

00:53:18,760 --> 00:53:22,660
great programming library which can be

00:53:20,859 --> 00:53:25,630
used to do some very interesting and

00:53:22,660 --> 00:53:29,859
very and things that would be very hard

00:53:25,630 --> 00:53:32,069
to do otherwise so to finish up I would

00:53:29,859 --> 00:53:33,660
like to invite you to embrace the future

00:53:32,069 --> 00:53:35,479
you know the new suppose was fourteen

00:53:33,660 --> 00:53:38,809
standard and and suppose for seventeen

00:53:35,479 --> 00:53:41,190
to try to keep your compilers up-to-date

00:53:38,809 --> 00:53:43,170
to try to think out of the box because

00:53:41,190 --> 00:53:45,420
as I hope I was able to demonstrate it

00:53:43,170 --> 00:53:47,430
is possible to do some crazy interesting

00:53:45,420 --> 00:53:49,699
things if you just think out of the box

00:53:47,430 --> 00:53:51,779
for a bit it's been like ten years that

00:53:49,699 --> 00:53:53,519
we've been like metaprogramming with

00:53:51,779 --> 00:53:55,619
angry brackets a little bit of place for

00:53:53,519 --> 00:53:59,219
like ten years and now I think it's

00:53:55,619 --> 00:54:02,400
possible to like this you know part of

00:53:59,219 --> 00:54:04,140
the past and also obviously since I

00:54:02,400 --> 00:54:07,859
wrote it I would like to invite you to

00:54:04,140 --> 00:54:09,719
embrace Anna because well I think this

00:54:07,859 --> 00:54:12,390
is really a library for the future of

00:54:09,719 --> 00:54:15,569
meta programming and actually I would

00:54:12,390 --> 00:54:18,599
even like for some examples I mean for

00:54:15,569 --> 00:54:20,190
some ideas from Anna to be reported to

00:54:18,599 --> 00:54:23,039
the standard because I think some of

00:54:20,190 --> 00:54:25,109
these ideas are just no brainers okay

00:54:23,039 --> 00:54:27,089
I'm not saying like it's pretty

00:54:25,109 --> 00:54:28,729
functional library I mean like

00:54:27,089 --> 00:54:30,930
programming functional library the

00:54:28,729 --> 00:54:32,519
concepts come from personal programming

00:54:30,930 --> 00:54:34,229
I don't want this in this time madness

00:54:32,519 --> 00:54:34,829
oil yeah I'm not trying to force it like

00:54:34,229 --> 00:54:37,920
a button

00:54:34,829 --> 00:54:39,569
anyone but some like just having a

00:54:37,920 --> 00:54:43,739
forage that works on tuple just makes

00:54:39,569 --> 00:54:46,009
sense for everybody okay so thank you

00:54:43,739 --> 00:54:46,009
very much

00:54:53,859 --> 00:54:59,839
so I had the time to take some questions

00:54:56,690 --> 00:55:01,279
but I would also like to show so I would

00:54:59,839 --> 00:55:02,839
like to show some implementation

00:55:01,279 --> 00:55:05,000
techniques for those that want to see

00:55:02,839 --> 00:55:11,650
how this is actually done like okay can

00:55:05,000 --> 00:55:11,650
you filter a tuple so any questions okay

00:55:16,660 --> 00:55:21,650
the question if you had to pick one or

00:55:19,549 --> 00:55:23,119
two language features that will make my

00:55:21,650 --> 00:55:26,480
life easier in this paradigm what would

00:55:23,119 --> 00:55:29,690
you pick I want to be able to have a

00:55:26,480 --> 00:55:30,980
lambda appear in a unevaluated contacts

00:55:29,690 --> 00:55:32,930
which means that I want to be able to

00:55:30,980 --> 00:55:34,400
say they call type some algorithm and

00:55:32,930 --> 00:55:36,380
then pass a lambda to this algorithm and

00:55:34,400 --> 00:55:38,329
it still works right now it doesn't I'm

00:55:36,380 --> 00:55:40,069
going to open a core defect for that

00:55:38,329 --> 00:55:43,549
which I submit they told me that it was

00:55:40,069 --> 00:55:45,799
that this restriction was now not

00:55:43,549 --> 00:55:47,839
required anymore so this should work the

00:55:45,799 --> 00:55:50,299
other thing that I want is a compile

00:55:47,839 --> 00:55:50,720
time I mean I mean compiler generated

00:55:50,299 --> 00:55:52,609
closure

00:55:50,720 --> 00:55:54,289
I won't - tuple to be part of the

00:55:52,609 --> 00:55:57,349
language I wanted to be part of the core

00:55:54,289 --> 00:55:59,299
language this way we can have very very

00:55:57,349 --> 00:56:03,020
compile time efficient optimally runtime

00:55:59,299 --> 00:56:05,809
efficient heterogeneous closure and this

00:56:03,020 --> 00:56:08,690
is like the this would be like the best

00:56:05,809 --> 00:56:11,420
feature ever this no seriously this

00:56:08,690 --> 00:56:12,829
would just make like compile long

00:56:11,420 --> 00:56:14,720
compile times mostly part of the best

00:56:12,829 --> 00:56:16,309
especially if they give you like a way

00:56:14,720 --> 00:56:19,039
to access the nth element so random

00:56:16,309 --> 00:56:20,960
access into your sequence as part you

00:56:19,039 --> 00:56:22,700
know what the core language then it

00:56:20,960 --> 00:56:25,520
would be just like super fast probably

00:56:22,700 --> 00:56:28,369
and yeah so that would make a big

00:56:25,520 --> 00:56:37,339
difference and apart from that I think

00:56:28,369 --> 00:56:38,420
that's it yeah so yes so the comment is

00:56:37,339 --> 00:56:40,400
that there are parent packs

00:56:38,420 --> 00:56:42,349
random access things that are being

00:56:40,400 --> 00:56:43,430
proposed I do not like burner packs

00:56:42,349 --> 00:56:47,089
because they don't have compose very

00:56:43,430 --> 00:56:48,410
well I think it is much cleaner to to

00:56:47,089 --> 00:56:49,819
just stick your barriner back into a

00:56:48,410 --> 00:56:52,250
sequence and then to manipulated without

00:56:49,819 --> 00:56:54,650
rhythms because say you want to filter

00:56:52,250 --> 00:56:56,329
like a peridot peridot back with a

00:56:54,650 --> 00:56:57,559
predicate how do you do that you you put

00:56:56,329 --> 00:56:59,270
the predicate first first and then you

00:56:57,559 --> 00:57:01,240
expand the parameter I can into like the

00:56:59,270 --> 00:57:03,670
parent into the list of the

00:57:01,240 --> 00:57:05,260
it's just really key just like you

00:57:03,670 --> 00:57:06,940
wouldn't want to represent your state

00:57:05,260 --> 00:57:10,119
vector as some kind of magic syntax

00:57:06,940 --> 00:57:11,800
using that it's just easier to put it in

00:57:10,119 --> 00:57:13,600
a container and then capacity function

00:57:11,800 --> 00:57:15,670
just yeah how would you return the

00:57:13,600 --> 00:57:17,020
periodo back you can't you can return to

00:57:15,670 --> 00:57:18,340
both so I know I'm really not really

00:57:17,020 --> 00:57:21,550
fond of peridot packs I would rather

00:57:18,340 --> 00:57:39,970
these kind of features not not going to

00:57:21,550 --> 00:57:42,220
the language yes okay so the question is

00:57:39,970 --> 00:57:44,470
I I say that the compile time is better

00:57:42,220 --> 00:57:46,390
with this approach then with say uh

00:57:44,470 --> 00:57:49,360
explicit angular bracket stuff and blah

00:57:46,390 --> 00:57:52,810
blah blah so what do i attribute this

00:57:49,360 --> 00:57:55,060
speed up to actually it's not faster the

00:57:52,810 --> 00:57:57,730
reason why it's faster is because we can

00:57:55,060 --> 00:57:59,470
use other so the fastest way to do pure

00:57:57,730 --> 00:58:01,750
type level computations is to go the

00:57:59,470 --> 00:58:03,700
dirty way and to do it like with the my

00:58:01,750 --> 00:58:06,280
rotor packs and the old MPL way it's

00:58:03,700 --> 00:58:09,040
faster but it's also it also makes you

00:58:06,280 --> 00:58:11,080
want to die when you write it so the

00:58:09,040 --> 00:58:12,340
speed up is actually due to just other

00:58:11,080 --> 00:58:15,540
implementation techniques that we're

00:58:12,340 --> 00:58:18,040
using that are part of C++ 14 and this I

00:58:15,540 --> 00:58:20,020
could like I got some bonuses I I'm

00:58:18,040 --> 00:58:22,090
going to show it but yeah so actually

00:58:20,020 --> 00:58:24,160
the fastest way to the pure type of a

00:58:22,090 --> 00:58:26,980
computation is not with this paradigm

00:58:24,160 --> 00:58:35,440
that I've shown you but the most sane

00:58:26,980 --> 00:58:38,830
way to do it is definitely yep a bar

00:58:35,440 --> 00:58:40,330
with I've I tried to write a switch for

00:58:38,830 --> 00:58:41,710
booze variant which does exhaustively

00:58:40,330 --> 00:58:45,640
checking with Hana

00:58:41,710 --> 00:58:47,680
I haven't tried it no I think it

00:58:45,640 --> 00:58:49,660
wouldn't be much harder probably than

00:58:47,680 --> 00:58:51,550
writing to boost any switch right

00:58:49,660 --> 00:58:54,550
because boost any is just booze variant

00:58:51,550 --> 00:58:59,460
with unbounded types like with unbounded

00:58:54,550 --> 00:58:59,460
possibility of types yep

00:59:11,550 --> 00:59:30,369
yeah yeah I was in your talk and and and

00:59:15,280 --> 00:59:38,800
I was thinking this thing you mean the

00:59:30,369 --> 00:59:40,980
the the the any switch or it could be

00:59:38,800 --> 00:59:44,560
I'd like to see it I'd like to see it

00:59:40,980 --> 00:59:46,270
okay but I'm not sure it's more trivial

00:59:44,560 --> 00:59:47,650
than with it anyway right because you're

00:59:46,270 --> 00:59:50,140
still saving a lot of fuss you still

00:59:47,650 --> 00:59:53,470
have like algorithms to abstract some

00:59:50,140 --> 00:59:55,540
operations anyway yeah but in the case

00:59:53,470 --> 00:59:58,510
of a boost variance which it might not

00:59:55,540 --> 01:00:00,640
really be a such a huge game okay so the

00:59:58,510 --> 01:00:02,710
session is over if you still want to

01:00:00,640 --> 01:00:05,320
stay I so like I think we're gonna cut

01:00:02,710 --> 01:00:06,880
the video but i but but but don't do it

01:00:05,320 --> 01:00:08,920
if you don't if you don't want because

01:00:06,880 --> 01:00:10,869
everybody's uh might be interesting

01:00:08,920 --> 01:00:11,980
interested in seeing the implementation

01:00:10,869 --> 01:00:16,320
techniques so you can leave if you want

01:00:11,980 --> 01:00:21,220
but I'm going to show how to implement

01:00:16,320 --> 01:00:25,960
algorithms now so basically what we do

01:00:21,220 --> 01:00:29,440
is the goal is to always do the index

01:00:25,960 --> 01:00:31,420
computations with you know Const expert

01:00:29,440 --> 01:00:34,859
if possible or to use to the next

01:00:31,420 --> 01:00:37,089
sequence to to expand the parity backs

01:00:34,859 --> 01:00:40,630
so say you want to implement transform

01:00:37,089 --> 01:00:42,820
what you can do is you take your tuple I

01:00:40,630 --> 01:00:44,280
mean here you take it to pole and then

01:00:42,820 --> 01:00:47,320
you take your function and then you just

01:00:44,280 --> 01:00:48,460
compute the size you just trade an index

01:00:47,320 --> 01:00:50,770
sequence which contains you know a

01:00:48,460 --> 01:00:53,890
parameter pack of the size of the number

01:00:50,770 --> 01:00:56,109
element in the in the tuple and then you

01:00:53,890 --> 01:00:58,359
call a helper function which as here

01:00:56,109 --> 01:01:01,089
these indices and since this is a parity

01:00:58,359 --> 01:01:02,770
pack going from 0 to n minus 1 where n

01:01:01,089 --> 01:01:05,349
is the number of elements in your tuple

01:01:02,770 --> 01:01:07,180
you can just expand it and call F on

01:01:05,349 --> 01:01:09,400
each of this you know elements of the to

01:01:07,180 --> 01:01:13,150
call that way ok

01:01:09,400 --> 01:01:14,110
this is transform now then somebody

01:01:13,150 --> 01:01:19,600
close the door please

01:01:14,110 --> 01:01:22,600
now okay this is easy you can implement

01:01:19,600 --> 01:01:24,610
other things with like say for each or

01:01:22,600 --> 01:01:26,770
stuff like that using the similar

01:01:24,610 --> 01:01:27,700
techniques although some body else is

01:01:26,770 --> 01:01:29,230
going to talk about that in a different

01:01:27,700 --> 01:01:32,860
session so I'm not gonna show it

01:01:29,230 --> 01:01:33,550
actually but so now this is easy brace

01:01:32,860 --> 01:01:37,540
yourselves

01:01:33,550 --> 01:01:41,890
here comes filter so filter is a nasty

01:01:37,540 --> 01:01:43,150
beast basically okay we're gonna we're

01:01:41,890 --> 01:01:44,920
gonna do it step by step because this

01:01:43,150 --> 01:01:47,650
this one is actually very difficult to

01:01:44,920 --> 01:01:49,240
up to to implement so we get a two pole

01:01:47,650 --> 01:01:50,590
we get a predicate which contains an

01:01:49,240 --> 01:01:54,760
integral which returns an integral

01:01:50,590 --> 01:01:56,470
constant we just create a an index

01:01:54,760 --> 01:01:58,990
sequence with the size of you know the

01:01:56,470 --> 01:02:03,220
tuple and then what we're going to do

01:01:58,990 --> 01:02:06,040
here is we're going to to use an helper

01:02:03,220 --> 01:02:08,310
to create an index sequence okay and

01:02:06,040 --> 01:02:11,470
this index sequence is going to contain

01:02:08,310 --> 01:02:13,620
the indices of the objects for which the

01:02:11,470 --> 01:02:18,220
predicate returns true and only that

01:02:13,620 --> 01:02:20,380
okay and so this indices here again is

01:02:18,220 --> 01:02:23,440
an index sequence still index sequence

01:02:20,380 --> 01:02:25,570
that contains only the indices where the

01:02:23,440 --> 01:02:27,100
predicate returns true and then if we

01:02:25,570 --> 01:02:29,170
have such an index sequence which I'm

01:02:27,100 --> 01:02:30,820
going to show you out how its

01:02:29,170 --> 01:02:33,640
implemented after okay but this is

01:02:30,820 --> 01:02:36,310
slightly nasty but I'm so once you have

01:02:33,640 --> 01:02:37,900
this you can just slice you to pole

01:02:36,310 --> 01:02:39,970
using those indices and slicing your

01:02:37,900 --> 01:02:43,930
tuple is just as easy as just you know

01:02:39,970 --> 01:02:46,900
get the get the proper elements get the

01:02:43,930 --> 01:02:49,740
elements at the proper indices okay so

01:02:46,900 --> 01:02:53,890
if we can actually get an index sequence

01:02:49,740 --> 01:02:56,040
here with the proper indices we're good

01:02:53,890 --> 01:02:56,040
to go

01:02:57,010 --> 01:03:00,670
you're just so it's clear to everyone

01:02:58,780 --> 01:03:02,230
I'm just like I said predicate is

01:03:00,670 --> 01:03:03,730
returning an integral constant to buoy

01:03:02,230 --> 01:03:05,410
an integral constant so I can nickel

01:03:03,730 --> 01:03:07,690
type that fetch the count count value do

01:03:05,410 --> 01:03:11,830
this for all the elements in the in the

01:03:07,690 --> 01:03:15,040
tuple and right so this is like a this

01:03:11,830 --> 01:03:16,210
is an boolean true false true false

01:03:15,040 --> 01:03:20,980
depending on the value of the predicate

01:03:16,210 --> 01:03:23,770
okay let's go here so filter indices is

01:03:20,980 --> 01:03:25,030
just this helper here the real trick is

01:03:23,770 --> 01:03:27,520
going to happen in the filter in this is

01:03:25,030 --> 01:03:34,180
alper here okay

01:03:27,520 --> 01:03:36,900
so what happens is we create an array of

01:03:34,180 --> 01:03:42,670
the results it can stacks per array okay

01:03:36,900 --> 01:03:44,230
then we use stud count except like a

01:03:42,670 --> 01:03:45,520
context perversion of stud count but

01:03:44,230 --> 01:03:47,170
it's exactly the same it just stick

01:03:45,520 --> 01:03:49,900
context where in front of stud counting

01:03:47,170 --> 01:03:51,970
it works so we use stud count to count

01:03:49,900 --> 01:03:54,910
the number of elements that are true now

01:03:51,970 --> 01:03:56,980
since this is context / we're happy the

01:03:54,910 --> 01:03:59,280
result you know we know what it will be

01:03:56,980 --> 01:04:02,470
the size of our resulting tupple and

01:03:59,280 --> 01:04:04,420
then we compute the indices so we are

01:04:02,470 --> 01:04:06,580
going to create an array which contains

01:04:04,420 --> 01:04:08,560
the indices of those elements that are

01:04:06,580 --> 01:04:11,200
true this is pretty trivial this is just

01:04:08,560 --> 01:04:13,660
normal C++ really there's no like type

01:04:11,200 --> 01:04:15,430
level thing here or anything so we just

01:04:13,660 --> 01:04:17,830
you know start the index at zero and

01:04:15,430 --> 01:04:20,110
then whenever we find a result in the

01:04:17,830 --> 01:04:22,780
array that is true we just you know say

01:04:20,110 --> 01:04:25,030
a so the index of this true element is

01:04:22,780 --> 01:04:29,290
is that and we put it into that array

01:04:25,030 --> 01:04:31,750
and now we create an array you can sex

01:04:29,290 --> 01:04:34,510
for array with the computed and this is

01:04:31,750 --> 01:04:36,040
here so here this is a historic context

01:04:34,510 --> 01:04:38,710
breasted array which contains the

01:04:36,040 --> 01:04:42,070
indices of the elements that satisfy the

01:04:38,710 --> 01:04:44,500
predicate and only that what do we still

01:04:42,070 --> 01:04:46,540
need to do is so the only thing that we

01:04:44,500 --> 01:04:59,010
still need to do is to put this into an

01:04:46,540 --> 01:04:59,010
index sequential yes what

01:05:00,970 --> 01:05:04,900
and this is as a result yet

01:05:06,010 --> 01:05:16,250
is a current no it's not yeah no n is

01:05:13,940 --> 01:05:18,560
the number of elements in the in the

01:05:16,250 --> 01:05:23,420
resulting sequence so I just feel my

01:05:18,560 --> 01:05:26,990
array you know using the I just fill my

01:05:23,420 --> 01:05:28,550
array using wait a minute oh crap I

01:05:26,990 --> 01:05:31,090
think that's right it's really crazy

01:05:28,550 --> 01:05:33,560
because this actually jump out and work

01:05:31,090 --> 01:05:36,140
okay so there might be there might be a

01:05:33,560 --> 01:05:37,460
subtle bug here but so yeah I think you

01:05:36,140 --> 01:05:40,430
get it that we're just basically filling

01:05:37,460 --> 01:05:41,930
the array it didn't test enough right

01:05:40,430 --> 01:05:43,010
this is not the implementation in Hana I

01:05:41,930 --> 01:05:44,510
just could be pasted it and then

01:05:43,010 --> 01:05:47,390
simplified it and I made a mistake doing

01:05:44,510 --> 01:05:49,160
it so yeah but basically what we're

01:05:47,390 --> 01:05:52,130
doing is just filling the array with the

01:05:49,160 --> 01:05:53,660
parentheses and now so assuming that I

01:05:52,130 --> 01:05:56,390
wrote my code correctly

01:05:53,660 --> 01:05:57,800
I should this should be like a solar

01:05:56,390 --> 01:05:59,870
array which contains the indices of the

01:05:57,800 --> 01:06:01,940
elements that I want to keep in the

01:05:59,870 --> 01:06:04,100
resulting sequence now the only thing

01:06:01,940 --> 01:06:06,380
that's left to do is to put this into a

01:06:04,100 --> 01:06:13,550
stirred integer sequence and the way

01:06:06,380 --> 01:06:17,300
we're gonna do it is like this so we we

01:06:13,550 --> 01:06:20,330
yeah so this is just a nice trick to you

01:06:17,300 --> 01:06:22,580
know evaporate back from from 0 to 2 n

01:06:20,330 --> 01:06:25,340
here and what I'm gonna do is just

01:06:22,580 --> 01:06:27,260
create an index sequence using the

01:06:25,340 --> 01:06:29,540
computed indices which is a context for

01:06:27,260 --> 01:06:31,610
array containing the indices so what I'm

01:06:29,540 --> 01:06:33,740
doing basically is I'm saying like I'm

01:06:31,610 --> 01:06:36,770
creating an integer sequence that

01:06:33,740 --> 01:06:38,480
contains you know the first the fear the

01:06:36,770 --> 01:06:40,970
first computed index and the second

01:06:38,480 --> 01:06:42,920
computed index and and so on and since

01:06:40,970 --> 01:06:47,410
this interest from stood index sequence

01:06:42,920 --> 01:06:51,880
I can use it in my slice here like this

01:06:47,410 --> 01:06:51,880
so this is the way we do it yes

01:07:10,760 --> 01:07:16,920
okay so the question is that wouldn't it

01:07:14,790 --> 01:07:18,569
be simpler or more or less efficient to

01:07:16,920 --> 01:07:20,040
instead use like a normal approach

01:07:18,569 --> 01:07:21,480
recursive approach to filter all the

01:07:20,040 --> 01:07:24,420
indices that do not satisfy - pretty

01:07:21,480 --> 01:07:27,560
good the thing is no because okay and

01:07:24,420 --> 01:07:30,480
actually yeah so the interest in this

01:07:27,560 --> 01:07:33,030
technique here is that there is no there

01:07:30,480 --> 01:07:35,010
are no in sensations it's just constant

01:07:33,030 --> 01:07:36,390
for a modernist code the compiler

01:07:35,010 --> 01:07:37,829
doesn't do any instantiation

01:07:36,390 --> 01:07:39,750
right there are no templates there are

01:07:37,829 --> 01:07:42,180
no different types if you recruit simply

01:07:39,750 --> 01:07:43,980
you know look at the type list you are

01:07:42,180 --> 01:07:45,930
doing you are like instantiating all

01:07:43,980 --> 01:07:48,150
those different types so this is

01:07:45,930 --> 01:07:49,410
supposed to be much faster and from the

01:07:48,150 --> 01:07:52,980
benchmarks I've learned so far it is

01:07:49,410 --> 01:07:54,359
also so so so yeah the interests here

01:07:52,980 --> 01:07:56,760
that we are doing all the heavy

01:07:54,359 --> 01:07:59,280
computation the index computation we are

01:07:56,760 --> 01:08:03,270
doing it constructs per homogeneous

01:07:59,280 --> 01:08:08,150
which is quite fast okay so that was it

01:08:03,270 --> 01:08:08,150

YouTube URL: https://www.youtube.com/watch?v=cg1wOINjV9U


