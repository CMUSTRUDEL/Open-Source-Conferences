Title: CppCon 2015: Michael Caisse “Using Spirit X3 to Write Parsers”
Publication date: 2015-10-11
Playlist: CppCon 2015
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Parsing is a common problem in many domains. The complexity of using a library often pushes developers to ad-hoc solutions utilizing std::string manipulations, regular expressions, or nested if/switch statements. Most “quick hack” implementations are unmaintainable.

Spirit provides a Domain Specific Embedded Language (DSEL) that allows grammars to be described in a natural and declarative manner just like writing PEG or EBNF directly in your C++ code. X3 is the third major release of the Spirit library and improves both compile and run times while simplifying the much of the library.

In this tutorial session you will be introduced to Spirit X3, attribute parsing, and variety of tips to writing efficient and maintainable parsers. We will build a JSON parser during the session to illustrate techniques and usage of the library. This session is applicable toward anyone needing to parse data.
— 
Michael Caisse has been crafting code in C++ for nearly 25-years. He is a regular speaker at various conferences and is passionate about teaching and training. Michael is the owner of Ciere Consulting which provides software consulting and contracting services, C++ training, and Project Recovery for failing multidisciplinary engineering projects. 

When he isn't fighting with compilers or robots, he enjoys fencing with a sabre. :: ciere.com
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,609
welcome see some filling room familiar

00:00:02,429 --> 00:00:08,849
faces I guess two days wasn't enough and

00:00:05,609 --> 00:00:11,940
you get me for a third alright right now

00:00:08,849 --> 00:00:13,320
we're gonna talk about spirit and in

00:00:11,940 --> 00:00:15,660
particular we're gonna talk about spirit

00:00:13,320 --> 00:00:18,210
x3 it's the next generation of spirit

00:00:15,660 --> 00:00:21,000
spirit is a parsing and generation

00:00:18,210 --> 00:00:25,289
library in general the v2 version of the

00:00:21,000 --> 00:00:27,599
library has both parsing and generation

00:00:25,289 --> 00:00:29,039
where you can parse into an ast and then

00:00:27,599 --> 00:00:32,759
you can later take a data structure

00:00:29,039 --> 00:00:35,010
describe a grammar and then output that

00:00:32,759 --> 00:00:38,309
ast data structure into a stream of some

00:00:35,010 --> 00:00:43,620
sort supports both text and binary type

00:00:38,309 --> 00:00:46,100
things this discussion will be primarily

00:00:43,620 --> 00:00:50,090
about x3 which only has a parser and the

00:00:46,100 --> 00:00:52,710
parser only not the generation inside

00:00:50,090 --> 00:00:54,690
the library is a boost library it's

00:00:52,710 --> 00:00:58,109
written by Joelle de Guzman Joelle works

00:00:54,690 --> 00:00:59,850
with Kiera Consulting and we obviously

00:00:58,109 --> 00:01:03,870
then spent some time supporting this

00:00:59,850 --> 00:01:06,720
thing let's talk about why we have an X

00:01:03,870 --> 00:01:10,369
3 so X 3 is the next generation of

00:01:06,720 --> 00:01:12,570
spirit it's using modern C++ 14

00:01:10,369 --> 00:01:15,600
constructs internally that's given us

00:01:12,570 --> 00:01:17,250
some things one thing is hackable simple

00:01:15,600 --> 00:01:20,509
or internal design we're worried about

00:01:17,250 --> 00:01:26,310
trying to keep things easy inside and

00:01:20,509 --> 00:01:28,170
and v2 has become kind of a monster it's

00:01:26,310 --> 00:01:32,759
a minimal code base very few

00:01:28,170 --> 00:01:35,600
dependencies compiles faster like a lot

00:01:32,759 --> 00:01:39,600
faster if you've ever used spirit v2

00:01:35,600 --> 00:01:42,810
expression templates can really cause a

00:01:39,600 --> 00:01:44,399
lot of compilation headaches and the

00:01:42,810 --> 00:01:46,500
instantiations of all of these things

00:01:44,399 --> 00:01:47,880
will will eventually slow your

00:01:46,500 --> 00:01:50,040
compilation down we use some different

00:01:47,880 --> 00:01:52,890
tricks where you're using a DL tricks

00:01:50,040 --> 00:01:56,159
this time and we'll see that in a little

00:01:52,890 --> 00:01:58,290
bit better error handling a lot better

00:01:56,159 --> 00:02:01,409
error handling for plugging in your own

00:01:58,290 --> 00:02:03,600
error handlers and we have an optimized

00:02:01,409 --> 00:02:05,390
attribute processing so before attribute

00:02:03,600 --> 00:02:08,069
processing was pretty good I'm actually

00:02:05,390 --> 00:02:10,760
really good and now it's even better so

00:02:08,069 --> 00:02:12,610
let's look at some concepts

00:02:10,760 --> 00:02:14,350
it is a domains

00:02:12,610 --> 00:02:18,400
cific embedded language that is what it

00:02:14,350 --> 00:02:21,010
is the domain is parsing the embedded

00:02:18,400 --> 00:02:25,150
part is within C++ via expression

00:02:21,010 --> 00:02:27,640
templates and the language is peg which

00:02:25,150 --> 00:02:30,940
is parsing expression grammar so it

00:02:27,640 --> 00:02:32,680
implements peg if you don't know what

00:02:30,940 --> 00:02:35,020
peg is that's fine if you've seen an e

00:02:32,680 --> 00:02:36,670
BN F type grammar before really only any

00:02:35,020 --> 00:02:38,110
grammar definition if you kind of squint

00:02:36,670 --> 00:02:42,250
your eyes they almost all look the same

00:02:38,110 --> 00:02:46,630
right and so this is this is gonna be

00:02:42,250 --> 00:02:48,760
for pig this you just give you give you

00:02:46,630 --> 00:02:50,080
some ad hoc parsing things how many

00:02:48,760 --> 00:02:52,330
people have code that might look like

00:02:50,080 --> 00:02:55,709
this somewhere in your codebase yeah

00:02:52,330 --> 00:02:58,480
everybody it's always everybody so yeah

00:02:55,709 --> 00:03:01,690
this is this is pretty normal right and

00:02:58,480 --> 00:03:04,060
and it starts off innocent typically but

00:03:01,690 --> 00:03:08,290
at some point it just falls apart and

00:03:04,060 --> 00:03:10,390
you're trying to you're trying to track

00:03:08,290 --> 00:03:13,209
down all kinds of state without a state

00:03:10,390 --> 00:03:15,130
machine using things that just really

00:03:13,209 --> 00:03:16,870
really aren't the best way to to take

00:03:15,130 --> 00:03:19,239
care of this type of a problem so

00:03:16,870 --> 00:03:21,670
sometimes what you do is you say oh this

00:03:19,239 --> 00:03:23,980
might be better I'm going to use a reg X

00:03:21,670 --> 00:03:25,930
reg X is like the most innocent thing

00:03:23,980 --> 00:03:28,810
when it starts because it's this long

00:03:25,930 --> 00:03:30,519
and you can read it until you realize it

00:03:28,810 --> 00:03:32,500
doesn't cover the things you want and by

00:03:30,519 --> 00:03:34,180
the end of like the first week you're

00:03:32,500 --> 00:03:35,830
the only one who can read it and next

00:03:34,180 --> 00:03:40,540
month you can't read it anymore

00:03:35,830 --> 00:03:41,739
so reg X is bad for journalized parsing

00:03:40,540 --> 00:03:46,030
right it's got its place it does its

00:03:41,739 --> 00:03:47,500
thing but it's not a partial so we would

00:03:46,030 --> 00:03:51,130
like to do something else so here's a

00:03:47,500 --> 00:03:52,660
peg grammar for email it's not really a

00:03:51,130 --> 00:03:56,080
peg grammar for email but it's gonna be

00:03:52,660 --> 00:04:00,280
for us we're gonna deal with it as what

00:03:56,080 --> 00:04:04,900
email is so a name letters A through Z

00:04:00,280 --> 00:04:08,560
there's one or more of those and then

00:04:04,900 --> 00:04:11,260
there's a dot with more letters A

00:04:08,560 --> 00:04:13,480
through Z one or more of them and there

00:04:11,260 --> 00:04:16,419
are zero or more of these things that's

00:04:13,480 --> 00:04:19,180
going to be the name part what is a host

00:04:16,419 --> 00:04:21,340
same type of pattern dot and followed by

00:04:19,180 --> 00:04:23,800
in our case it will be either a comm or

00:04:21,340 --> 00:04:26,590
an org or net and what is an email then

00:04:23,800 --> 00:04:28,630
an email is a name at a hoe

00:04:26,590 --> 00:04:30,670
this is easy to reason about easy to

00:04:28,630 --> 00:04:31,930
understand and it would be nice if we

00:04:30,670 --> 00:04:35,620
can write our code the same way

00:04:31,930 --> 00:04:38,530
underneath we have now the spirit x3

00:04:35,620 --> 00:04:40,690
version of this we're not able to put

00:04:38,530 --> 00:04:43,150
the operator plus at the end we have to

00:04:40,690 --> 00:04:45,400
put in the front and so in order to take

00:04:43,150 --> 00:04:47,440
care of some of the rules within C++ we

00:04:45,400 --> 00:04:50,770
move some things around so we have

00:04:47,440 --> 00:04:55,420
characters a through z one or more of

00:04:50,770 --> 00:04:56,800
those followed by zero or more dot

00:04:55,420 --> 00:04:59,290
that's followed by one or more

00:04:56,800 --> 00:05:03,760
characters this is a name looks a lot

00:04:59,290 --> 00:05:08,710
like this what is a host well same type

00:05:03,760 --> 00:05:11,770
of thing we use a bar and sub slash comm

00:05:08,710 --> 00:05:14,680
org net and then what is an email an

00:05:11,770 --> 00:05:18,040
email is a name followed by an @ sign

00:05:14,680 --> 00:05:21,190
followed by a host this is readable I

00:05:18,040 --> 00:05:23,590
know what it does and the idea of

00:05:21,190 --> 00:05:25,210
writing you know having a good parser

00:05:23,590 --> 00:05:27,460
and specifically if you're going to

00:05:25,210 --> 00:05:29,470
write a DSL domain-specific embedded

00:05:27,460 --> 00:05:32,290
language is to write one where you can

00:05:29,470 --> 00:05:34,630
be declarative right and so now we have

00:05:32,290 --> 00:05:37,630
a declarative statement of what an email

00:05:34,630 --> 00:05:40,510
is it's this thing this now has created

00:05:37,630 --> 00:05:42,610
a parser for emails this is what we want

00:05:40,510 --> 00:05:44,760
to get to so let's talk a little bit

00:05:42,610 --> 00:05:48,130
about what parsers are parsers for us

00:05:44,760 --> 00:05:50,320
take some stream of values in in this

00:05:48,130 --> 00:05:55,660
case we have a float parser it will

00:05:50,320 --> 00:05:57,910
parse this if I give it it foo it will

00:05:55,660 --> 00:06:04,020
not parse that because the float parser

00:05:57,910 --> 00:06:07,290
doesn't like foo I can compose these

00:06:04,020 --> 00:06:11,770
using what we would call a rule so

00:06:07,290 --> 00:06:14,520
literal sized parser followed by a float

00:06:11,770 --> 00:06:18,970
parser would be able to parse size space

00:06:14,520 --> 00:06:22,570
42.5 so these compose together we refer

00:06:18,970 --> 00:06:24,520
to these as rules rules in this case we

00:06:22,570 --> 00:06:30,190
have size followed by big the float

00:06:24,520 --> 00:06:33,490
parser portion of it fails rules can be

00:06:30,190 --> 00:06:36,400
composed with more parsers and more

00:06:33,490 --> 00:06:39,700
rules to create other rules the idea is

00:06:36,400 --> 00:06:42,070
that we want to create rules and

00:06:39,700 --> 00:06:43,300
and they composed those and continued to

00:06:42,070 --> 00:06:46,270
compose them into larger and larger

00:06:43,300 --> 00:06:48,760
things so now we have the original one

00:06:46,270 --> 00:06:51,700
that we had which was a literal size and

00:06:48,760 --> 00:06:55,240
afloat parser followed now by a comma

00:06:51,700 --> 00:06:58,050
followed by color and a string it would

00:06:55,240 --> 00:06:58,050
be able to parse this

00:07:01,950 --> 00:07:07,450
alright so parsing things is interesting

00:07:05,100 --> 00:07:10,480
but typically when we're parsing

00:07:07,450 --> 00:07:12,340
something we want data back out we would

00:07:10,480 --> 00:07:14,290
like to do something with with the data

00:07:12,340 --> 00:07:17,260
that came in and put it into a data

00:07:14,290 --> 00:07:19,960
structure that we can deal with so 42.5

00:07:17,260 --> 00:07:24,730
we parse this we would like to get a

00:07:19,960 --> 00:07:26,380
double that is 42.5 this thing on the

00:07:24,730 --> 00:07:29,710
way out is called the synthesized

00:07:26,380 --> 00:07:34,630
attribute this parser has synthesized

00:07:29,710 --> 00:07:42,130
this double for us feel free to ask

00:07:34,630 --> 00:07:44,380
questions any time ok this rule that we

00:07:42,130 --> 00:07:47,140
had before it's parsing the literal size

00:07:44,380 --> 00:07:48,970
followed by this float parser we would

00:07:47,140 --> 00:07:53,110
like this rule to also sent the

00:07:48,970 --> 00:07:56,230
synthesize a 42.5 and so we want to be

00:07:53,110 --> 00:07:58,060
able to explain to our rules what it is

00:07:56,230 --> 00:08:01,170
that they're going to synthesize what it

00:07:58,060 --> 00:08:01,170
is that they're not going to synthesize

00:08:01,650 --> 00:08:10,120
all right if you've used the two before

00:08:07,170 --> 00:08:12,280
we don't have grammars anymore we just

00:08:10,120 --> 00:08:14,290
have composition of rules grammars were

00:08:12,280 --> 00:08:16,450
kind of a wart that was added in order

00:08:14,290 --> 00:08:19,150
to take care of lifetime issues with

00:08:16,450 --> 00:08:23,500
composing rules and and keeping some

00:08:19,150 --> 00:08:25,360
things around due to the way that the

00:08:23,500 --> 00:08:27,010
internals were formed previously we

00:08:25,360 --> 00:08:28,090
don't have this anymore and so grammars

00:08:27,010 --> 00:08:29,770
you can just not think about if you

00:08:28,090 --> 00:08:32,110
worried if you've worked with b2 before

00:08:29,770 --> 00:08:34,000
you can just compose rules compose rules

00:08:32,110 --> 00:08:40,210
compose rules it's a lot nicer to deal

00:08:34,000 --> 00:08:42,220
with alright let's take a look at some

00:08:40,210 --> 00:08:45,280
parsers so the idea here is we're gonna

00:08:42,220 --> 00:08:50,080
take a data stream we're going to bring

00:08:45,280 --> 00:08:53,740
that in and parse that into an abstract

00:08:50,080 --> 00:08:55,990
syntax tree but that's the goal we want

00:08:53,740 --> 00:08:58,300
bring stuff in and have a data structure

00:08:55,990 --> 00:09:03,339
back out that we can deal with and work

00:08:58,300 --> 00:09:05,320
on inside of our code so inside the vex

00:09:03,339 --> 00:09:08,620
3 what 2 parsers look like well this is

00:09:05,320 --> 00:09:10,480
a parser that will parse in it this is

00:09:08,620 --> 00:09:20,290
one that parses a double here's one that

00:09:10,480 --> 00:09:25,720
parses a literal foo we can use parsers

00:09:20,290 --> 00:09:31,750
with the x3 parse API so I have an input

00:09:25,720 --> 00:09:35,410
of 1 2 3 4 and I can say parse passing

00:09:31,750 --> 00:09:37,089
it a begin and in iterator and then I

00:09:35,410 --> 00:09:40,660
can pass it the actual parser that I

00:09:37,089 --> 00:09:47,529
wanted to use and so this will parse the

00:09:40,660 --> 00:09:54,459
the 1 2 3 4 or any int if I wanted to

00:09:47,529 --> 00:09:56,200
parse doubles then this is a double so

00:09:54,459 --> 00:09:58,870
what kind of parses exists there are a

00:09:56,200 --> 00:10:00,970
lot of canned parsers these are some of

00:09:58,870 --> 00:10:04,600
them we have ones that can parse things

00:10:00,970 --> 00:10:10,060
like n2 and double full the different

00:10:04,600 --> 00:10:12,610
types of binary things of word types we

00:10:10,060 --> 00:10:16,060
have literal parsers this will parse a

00:10:12,610 --> 00:10:21,310
negative 42 or an unsigned 82 this will

00:10:16,060 --> 00:10:25,870
parse true or face or dead beef the the

00:10:21,310 --> 00:10:27,160
literal parsers all form the same type

00:10:25,870 --> 00:10:29,529
of thing where you have the parser that

00:10:27,160 --> 00:10:30,820
will parse anything and then you pass it

00:10:29,529 --> 00:10:32,709
actually the value they don't want to

00:10:30,820 --> 00:10:35,730
parse and now you have a literal parser

00:10:32,709 --> 00:10:35,730
instead they follow the same pattern

00:10:36,540 --> 00:10:42,610
here's some of the character partials we

00:10:38,709 --> 00:10:47,970
have so charm score will parse any

00:10:42,610 --> 00:10:55,000
character here are the literal versions

00:10:47,970 --> 00:10:59,230
or just bar will parse the bar so parse

00:10:55,000 --> 00:11:01,180
a through Z this will parse a through Z

00:10:59,230 --> 00:11:03,390
the number 8 and then capital A through

00:11:01,180 --> 00:11:03,390
Z

00:11:04,270 --> 00:11:09,700
parsers have a special knot so this will

00:11:06,880 --> 00:11:11,800
parse everything that is not a and it is

00:11:09,700 --> 00:11:13,330
more efficient to use this than some of

00:11:11,800 --> 00:11:15,600
the other constructs that you might want

00:11:13,330 --> 00:11:15,600
to use

00:11:16,710 --> 00:11:21,490
so let's look how we combine parsers

00:11:19,210 --> 00:11:24,940
because parsing and ant is not very

00:11:21,490 --> 00:11:29,080
interesting so if I want to combine some

00:11:24,940 --> 00:11:31,330
parsers here I have a t6 and a space and

00:11:29,080 --> 00:11:36,600
then one two three four point five six

00:11:31,330 --> 00:11:41,770
I can parse the int here's the space

00:11:36,600 --> 00:11:44,590
here's my double and we use the right

00:11:41,770 --> 00:11:47,140
shift operator and when you see that you

00:11:44,590 --> 00:11:50,260
read inside of inside of the language

00:11:47,140 --> 00:11:52,510
you you read it as followed by and so we

00:11:50,260 --> 00:11:57,000
read this as I'm gonna parse an INT

00:11:52,510 --> 00:11:57,000
followed by a space followed by a double

00:11:59,520 --> 00:12:09,760
yes so the question is does a space here

00:12:07,180 --> 00:12:12,160
match literally a white space or the

00:12:09,760 --> 00:12:15,540
space and it does in this case where

00:12:12,160 --> 00:12:17,890
we're parsing and matching just a space

00:12:15,540 --> 00:12:21,070
in a moment we'll talk about skippers

00:12:17,890 --> 00:12:27,490
and how we can skip and to find skipping

00:12:21,070 --> 00:12:28,600
of for example white space alright so

00:12:27,490 --> 00:12:30,900
there are a variety different type of

00:12:28,600 --> 00:12:34,330
operators that we can use in order to

00:12:30,900 --> 00:12:36,820
compose parsers together and these are

00:12:34,330 --> 00:12:38,590
the operators the first is sequence so

00:12:36,820 --> 00:12:40,990
sequence we read as followed by a

00:12:38,590 --> 00:12:44,620
followed by B it looks like this inside

00:12:40,990 --> 00:12:46,450
a peg and the a followed by the B in

00:12:44,620 --> 00:12:48,370
this case int followed by space followed

00:12:46,450 --> 00:12:51,450
by double which we saw before I would be

00:12:48,370 --> 00:12:53,950
able to parse this or char followed by

00:12:51,450 --> 00:12:58,780
the colon followed by ant would be able

00:12:53,950 --> 00:13:02,680
to parse this we have alternative either

00:12:58,780 --> 00:13:04,510
a or b are allowed and they're evaluated

00:13:02,680 --> 00:13:05,980
in list order this is this is one of the

00:13:04,510 --> 00:13:08,860
things about peg versus some of the

00:13:05,980 --> 00:13:10,660
other types of definitions of grammars

00:13:08,860 --> 00:13:14,290
that exist so it gives us a

00:13:10,660 --> 00:13:16,390
deterministic behavior in peg so we're

00:13:14,290 --> 00:13:17,980
gonna parse alpha followed by digit

00:13:16,390 --> 00:13:18,329
followed by punked any of these things

00:13:17,980 --> 00:13:20,910
will

00:13:18,329 --> 00:13:24,470
work this is going to fail the parts

00:13:20,910 --> 00:13:24,470
because it doesn't meet any of these

00:13:26,989 --> 00:13:30,989
zero or more the clean start

00:13:29,249 --> 00:13:33,149
instead of putting it after what you're

00:13:30,989 --> 00:13:37,139
used to seeing it goes in front because

00:13:33,149 --> 00:13:39,449
of operators for us so zero or more

00:13:37,139 --> 00:13:43,529
alphas followed by an int would look all

00:13:39,449 --> 00:13:44,970
of these reparse fine one or more alphas

00:13:43,529 --> 00:13:46,589
followed by an int this is obviously

00:13:44,970 --> 00:13:52,439
going to fail I don't have any alphas in

00:13:46,589 --> 00:13:58,170
front this is optional so an optional

00:13:52,439 --> 00:13:59,999
alpha followed by an int and so this is

00:13:58,170 --> 00:14:03,119
going to fail because this is not an

00:13:59,999 --> 00:14:13,290
optional alpha this is a whole bunch of

00:14:03,119 --> 00:14:14,999
alphas that were followed by an int so

00:14:13,290 --> 00:14:19,470
the question is would you do plus minus

00:14:14,999 --> 00:14:21,089
alpha for optional one or more and

00:14:19,470 --> 00:14:23,819
optional one or more is basically saying

00:14:21,089 --> 00:14:29,369
zero or more so you just leave it use a

00:14:23,819 --> 00:14:35,389
clean star trying to trick me

00:14:29,369 --> 00:14:37,939
it's okay I cut up and sleep last night

00:14:35,389 --> 00:14:41,069
all right

00:14:37,939 --> 00:14:43,739
the and predicate basically provides

00:14:41,069 --> 00:14:46,410
look ahead we can look ahead into the

00:14:43,739 --> 00:14:49,439
stream without consuming it very

00:14:46,410 --> 00:14:53,790
convenient thing to be able to do and so

00:14:49,439 --> 00:14:57,569
if a matches without consuming any then

00:14:53,790 --> 00:15:00,119
the parse is is good and it can continue

00:14:57,569 --> 00:15:01,049
on to the next step and in case it

00:15:00,119 --> 00:15:04,610
wasn't clear yet

00:15:01,049 --> 00:15:06,720
a and B's up here are parsers or

00:15:04,610 --> 00:15:10,079
combinations of parsers or composed

00:15:06,720 --> 00:15:15,059
parsers right there there the thing and

00:15:10,079 --> 00:15:18,689
so here an int followed by and then this

00:15:15,059 --> 00:15:21,059
is the and predicate a semicolon this is

00:15:18,689 --> 00:15:23,129
going to actually be okay but this is

00:15:21,059 --> 00:15:27,290
going to fail to parse because it wasn't

00:15:23,129 --> 00:15:27,290
followed by the semicolon

00:15:29,350 --> 00:15:37,480
not protocol is just the opposite so for

00:15:34,780 --> 00:15:42,100
followed by not an alphanumeric or an

00:15:37,480 --> 00:15:48,730
underscore this will pass fine 40 will

00:15:42,100 --> 00:15:50,740
not alright we have a few additional

00:15:48,730 --> 00:15:53,890
things that come up a lot when we're

00:15:50,740 --> 00:15:55,770
writing grammars and I'm we leave the

00:15:53,890 --> 00:15:58,540
realm of PEG and there's no peg

00:15:55,770 --> 00:16:01,510
equivalent for this but on there handy

00:15:58,540 --> 00:16:04,690
so we've added a min one is the first

00:16:01,510 --> 00:16:06,340
one is a difference and so the idea is I

00:16:04,690 --> 00:16:10,480
want to match a but I don't want to

00:16:06,340 --> 00:16:14,790
match B I'm trying to parse comments

00:16:10,480 --> 00:16:18,010
these style comments so this followed by

00:16:14,790 --> 00:16:20,290
zero or more characters that are not the

00:16:18,010 --> 00:16:22,390
ending thing and then followed by the

00:16:20,290 --> 00:16:23,710
ending thing that's a pretty common

00:16:22,390 --> 00:16:26,680
pattern where you need you to do this

00:16:23,710 --> 00:16:29,980
and so here's a nice and easy way so

00:16:26,680 --> 00:16:30,610
this would always fail literal ob

00:16:29,980 --> 00:16:35,100
Watanabe

00:16:30,610 --> 00:16:38,860
followed by our less the ob wah well

00:16:35,100 --> 00:16:40,360
there's no way to do this and so I'm

00:16:38,860 --> 00:16:42,370
just kind of be careful as you're

00:16:40,360 --> 00:16:44,140
writing your your difference that you've

00:16:42,370 --> 00:16:47,620
made something that makes sense

00:16:44,140 --> 00:16:50,740
well actually parts okay expectation is

00:16:47,620 --> 00:16:52,810
is also something that is very different

00:16:50,740 --> 00:16:57,730
the idea of an expectation is that

00:16:52,810 --> 00:17:01,480
you're saying a is followed by B and it

00:16:57,730 --> 00:17:02,890
has to be followed by B always there

00:17:01,480 --> 00:17:05,170
will be no backtracking to find

00:17:02,890 --> 00:17:07,560
something else if you have an a there

00:17:05,170 --> 00:17:10,780
has to be a B right afterwards

00:17:07,560 --> 00:17:13,180
internally an expectation point gives us

00:17:10,780 --> 00:17:14,500
a lot of a lot of advantages with inside

00:17:13,180 --> 00:17:16,420
of the parcel we know that that's

00:17:14,500 --> 00:17:19,480
basically a point in which we can flush

00:17:16,420 --> 00:17:21,340
any backtracking we can remove memory

00:17:19,480 --> 00:17:22,900
that we've been scrolling along and keep

00:17:21,340 --> 00:17:25,300
being there's a lot of things that we

00:17:22,900 --> 00:17:28,060
can do internally as soon as we see one

00:17:25,300 --> 00:17:32,650
of these they also are ways for you to

00:17:28,060 --> 00:17:34,480
say that every time I see a particular

00:17:32,650 --> 00:17:36,190
thing it's got to be followed by the

00:17:34,480 --> 00:17:38,410
other and if it's not it's an error and

00:17:36,190 --> 00:17:40,960
I would like you to say that there's an

00:17:38,410 --> 00:17:42,310
error and let me know parser and and

00:17:40,960 --> 00:17:44,770
provide some information

00:17:42,310 --> 00:17:46,360
like you can get out where you are if

00:17:44,770 --> 00:17:47,740
it's a if it's a file you might want to

00:17:46,360 --> 00:17:49,150
know what line you're on or what

00:17:47,740 --> 00:17:52,810
character you're in things of that sort

00:17:49,150 --> 00:17:54,310
so expectation are there really great

00:17:52,810 --> 00:17:57,070
things so in the case they here Oh

00:17:54,310 --> 00:18:00,250
followed by K time we've got to have an

00:17:57,070 --> 00:18:01,900
okay we can't have an ox and when it

00:18:00,250 --> 00:18:03,640
says throw an exception internally

00:18:01,900 --> 00:18:04,930
throwing an exception we'll look at some

00:18:03,640 --> 00:18:10,930
of the error handling mechanisms how you

00:18:04,930 --> 00:18:13,420
get those back out so the difference

00:18:10,930 --> 00:18:17,140
between sequence and expectation is that

00:18:13,420 --> 00:18:19,030
a sequence is a followed by B and if you

00:18:17,140 --> 00:18:21,040
don't have a B you're going to backtrack

00:18:19,030 --> 00:18:22,510
and see if there's an alternative that

00:18:21,040 --> 00:18:25,510
might match it you might have an a

00:18:22,510 --> 00:18:28,000
followed by a C and so that would be

00:18:25,510 --> 00:18:30,670
fine right but with an expectation if

00:18:28,000 --> 00:18:36,040
you say a must be followed by B it has

00:18:30,670 --> 00:18:38,170
to be followed by B all right here's

00:18:36,040 --> 00:18:40,180
another one list it's it's super common

00:18:38,170 --> 00:18:43,180
to have lists of things that you are

00:18:40,180 --> 00:18:47,470
parsing and so it's really just a

00:18:43,180 --> 00:18:51,250
shortcut for a followed by zero or more

00:18:47,470 --> 00:18:54,520
B's followed by A's so here would be an

00:18:51,250 --> 00:18:58,300
example of an int and there's a list of

00:18:54,520 --> 00:19:01,660
ents that are comma separated and so

00:18:58,300 --> 00:19:04,870
this right here would parse nice and

00:19:01,660 --> 00:19:08,140
easily and so lists of things are a very

00:19:04,870 --> 00:19:10,450
common construct and so we have the

00:19:08,140 --> 00:19:12,910
percent that we use for that again a and

00:19:10,450 --> 00:19:19,450
B are any parsers or compose parsers to

00:19:12,910 --> 00:19:22,120
do that all right so far good great so

00:19:19,450 --> 00:19:23,950
let's take a look at at some information

00:19:22,120 --> 00:19:28,750
here and how to how to put these things

00:19:23,950 --> 00:19:34,320
together we've got some input string

00:19:28,750 --> 00:19:37,180
here in which we've got some values

00:19:34,320 --> 00:19:39,760
characters followed by a colon followed

00:19:37,180 --> 00:19:41,800
by some more characters and their comma

00:19:39,760 --> 00:19:44,890
separated so it kind of looks like we

00:19:41,800 --> 00:19:49,950
have pairs of things the right-hand side

00:19:44,890 --> 00:19:52,540
we might have quotes it quoted thank

00:19:49,950 --> 00:19:54,820
Joel felt cool by the way is the crazy

00:19:52,540 --> 00:19:55,830
Frenchman and he's just proving it by

00:19:54,820 --> 00:19:59,240
the way because he's doing three

00:19:55,830 --> 00:19:59,240
hours of lecture right now I don't know

00:19:59,990 --> 00:20:06,059
so here is our input string what would

00:20:03,899 --> 00:20:09,450
it look like to parse this well we want

00:20:06,059 --> 00:20:11,940
to parse a name a name followed by a

00:20:09,450 --> 00:20:14,010
semicolon sorry a colon I want to call

00:20:11,940 --> 00:20:19,830
him a name followed by a colon followed

00:20:14,010 --> 00:20:24,450
by either a quote or a name and this

00:20:19,830 --> 00:20:28,620
thing well it's a list of these so I

00:20:24,450 --> 00:20:30,419
have a list of these things now I've

00:20:28,620 --> 00:20:32,899
swapped some things out for you instead

00:20:30,419 --> 00:20:35,220
of parse we're using phrase parse and

00:20:32,899 --> 00:20:38,519
down here I've added this thing called

00:20:35,220 --> 00:20:40,649
space what I'm telling it is that now

00:20:38,519 --> 00:20:43,470
I'm doing phrase parsing and I have a

00:20:40,649 --> 00:20:45,960
skipper and the skipper is a white space

00:20:43,470 --> 00:20:48,809
skipper it'll automatically skip white

00:20:45,960 --> 00:20:50,159
space until one of these other until it

00:20:48,809 --> 00:20:51,840
can't skip white space basically until

00:20:50,159 --> 00:20:54,570
the skipper fails and at that point when

00:20:51,840 --> 00:20:57,860
the skipper fails then the grammar that

00:20:54,570 --> 00:20:59,970
I provided to it kicks in skippers or

00:20:57,860 --> 00:21:01,950
interesting things they're just grammars

00:20:59,970 --> 00:21:03,269
you can supply your skipper to be

00:21:01,950 --> 00:21:14,909
anything you want just by supplying a

00:21:03,269 --> 00:21:17,549
grammar another rule yes Wow I'll give

00:21:14,909 --> 00:21:19,139
you a buck later so the question is how

00:21:17,549 --> 00:21:21,690
do we define the name and the quote

00:21:19,139 --> 00:21:26,580
space things like that we're gonna find

00:21:21,690 --> 00:21:29,669
out right now so uh so let's look at

00:21:26,580 --> 00:21:31,470
some rules rules allow us to be able to

00:21:29,669 --> 00:21:33,389
do some things in particular they allow

00:21:31,470 --> 00:21:35,820
us to name parsers so we can like reason

00:21:33,389 --> 00:21:39,059
about them as named or quote things like

00:21:35,820 --> 00:21:41,700
that lets us read our our grammar in a

00:21:39,059 --> 00:21:43,889
reasonable way they allow us to specify

00:21:41,700 --> 00:21:45,299
an attribute we would eventually like to

00:21:43,889 --> 00:21:47,460
synthesize probably something out of

00:21:45,299 --> 00:21:50,299
this and attach it to the rule it allows

00:21:47,460 --> 00:21:52,039
for recursion you know it's pretty

00:21:50,299 --> 00:21:54,840
pretty

00:21:52,039 --> 00:21:57,350
in my world lease it's very uncommon to

00:21:54,840 --> 00:21:59,639
have a grammar that doesn't recurse so

00:21:57,350 --> 00:22:02,519
we want to be able to refer to the rules

00:21:59,639 --> 00:22:04,860
again allows us to provide error

00:22:02,519 --> 00:22:06,750
handling on error what is it going to do

00:22:04,860 --> 00:22:09,419
an error would be for example an

00:22:06,750 --> 00:22:11,969
expectation point a followed by B

00:22:09,419 --> 00:22:15,389
and I didn't get a B what is it going to

00:22:11,969 --> 00:22:20,669
do we can attach custom handlers when a

00:22:15,389 --> 00:22:24,479
match is found so here we go

00:22:20,669 --> 00:22:29,489
name is alpha followed by zero or more

00:22:24,479 --> 00:22:32,489
alpha numerics alpha and l num are built

00:22:29,489 --> 00:22:33,869
in spirit parsers so we're just using

00:22:32,489 --> 00:22:39,419
two spirit part series that's what a

00:22:33,869 --> 00:22:41,159
name is a quote a quote is well the

00:22:39,419 --> 00:22:47,339
beginning quote character followed by

00:22:41,159 --> 00:22:51,269
zero or more characters that mmm

00:22:47,339 --> 00:22:55,440
that should say tilde and latex of

00:22:51,269 --> 00:22:59,429
course ate my tilde and it made it a

00:22:55,440 --> 00:23:03,479
space there's a tilde there followed by

00:22:59,429 --> 00:23:05,609
a quote so we're going to basically grab

00:23:03,479 --> 00:23:14,039
all characters that aren't quote and

00:23:05,609 --> 00:23:16,079
then quote we only use auto for non

00:23:14,039 --> 00:23:18,269
recursive rules we'll see a little bit

00:23:16,079 --> 00:23:19,709
later this is like a shortcut to write

00:23:18,269 --> 00:23:28,859
all this and just get up and going right

00:23:19,709 --> 00:23:30,719
away yeah so in order to make the slide

00:23:28,859 --> 00:23:32,549
nice and easy to read there are some

00:23:30,719 --> 00:23:36,329
explicit usings in here in this case

00:23:32,549 --> 00:23:39,859
this is inside of the X the boost spirit

00:23:36,329 --> 00:23:39,859
x3 namespace

00:23:55,690 --> 00:24:02,800
yeah so the shift operator eventually

00:23:58,490 --> 00:24:06,770
this is going to get tainted by a parser

00:24:02,800 --> 00:24:10,330
by a type that is inside of of the

00:24:06,770 --> 00:24:12,500
spirit namespace and and then all

00:24:10,330 --> 00:24:18,410
expression templates from that point on

00:24:12,500 --> 00:24:22,390
work nicely for us so let's take a look

00:24:18,410 --> 00:24:25,640
at what we do with rules here so here

00:24:22,390 --> 00:24:29,660
I've got alpha followed by alphanumeric

00:24:25,640 --> 00:24:33,620
oh good I got my tilde back and here's

00:24:29,660 --> 00:24:35,480
our quote version and I'm going to add

00:24:33,620 --> 00:24:41,720
this little thing in here

00:24:35,480 --> 00:24:44,270
this rule is x3 rule and class name what

00:24:41,720 --> 00:24:45,710
this is doing is creating a tag for us

00:24:44,270 --> 00:24:49,790
that we'll never see again but we need a

00:24:45,710 --> 00:24:51,830
tag that's unique and the tags are as

00:24:49,790 --> 00:24:53,450
we'll see in a little bit later the tags

00:24:51,830 --> 00:24:56,300
are the things that are going to allow

00:24:53,450 --> 00:24:58,370
us to use ADL in such a way to pull a

00:24:56,300 --> 00:25:02,210
bunch of things together and relate them

00:24:58,370 --> 00:25:04,700
so we can have some lightweight objects

00:25:02,210 --> 00:25:06,680
to talk about recursion with and things

00:25:04,700 --> 00:25:08,390
like that that are not the definition of

00:25:06,680 --> 00:25:09,650
our parser they allow us to look up the

00:25:08,390 --> 00:25:12,110
definition of our parser later on

00:25:09,650 --> 00:25:13,850
internally we really don't have to worry

00:25:12,110 --> 00:25:15,470
too much about it as a general rule what

00:25:13,850 --> 00:25:16,910
you do is you just like create a tag

00:25:15,470 --> 00:25:21,770
name that's probably the same as your

00:25:16,910 --> 00:25:28,700
your name here okay so this is how I'm

00:25:21,770 --> 00:25:31,940
going to write my x3 rules yeah the tag

00:25:28,700 --> 00:25:33,890
name I just talked about so let's take a

00:25:31,940 --> 00:25:47,360
little closer look now at what we're

00:25:33,890 --> 00:25:49,400
going to do yeah so the question is

00:25:47,360 --> 00:25:50,720
the tagname need to be unique in what

00:25:49,400 --> 00:25:53,780
namespace the technique needs to be

00:25:50,720 --> 00:25:56,630
unique within the namespace that the tag

00:25:53,780 --> 00:26:00,500
is defined and and that's what's going

00:25:56,630 --> 00:26:04,130
to get us the ADL lookup yeah all right

00:26:00,500 --> 00:26:06,500
so here we have getting a little closer

00:26:04,130 --> 00:26:10,250
to what we want our name is followed by

00:26:06,500 --> 00:26:11,960
our alpha followed by zero or more alpha

00:26:10,250 --> 00:26:15,770
numerics our quote is getting a little

00:26:11,960 --> 00:26:17,450
more complex now this lexeme we as soon

00:26:15,770 --> 00:26:19,820
as we have the quotes what we really

00:26:17,450 --> 00:26:23,960
want to do once we get quotes is we want

00:26:19,820 --> 00:26:25,850
to shut off the skipper because we don't

00:26:23,960 --> 00:26:27,380
want to skip whitespace anymore that's

00:26:25,850 --> 00:26:29,450
what what it meant and that's what

00:26:27,380 --> 00:26:30,970
lexing does it turns this off everything

00:26:29,450 --> 00:26:34,880
inside of here it's a directive

00:26:30,970 --> 00:26:38,360
everything within this directive then be

00:26:34,880 --> 00:26:40,040
these skippers turned off and then as we

00:26:38,360 --> 00:26:44,929
leave that then the skippers turn back

00:26:40,040 --> 00:26:47,240
on and so now this will parse this thing

00:26:44,929 --> 00:26:49,070
for us we've now got our rules in here

00:26:47,240 --> 00:26:53,470
we know actually what name and quote our

00:26:49,070 --> 00:26:57,020
name followed by and so bam look at that

00:26:53,470 --> 00:26:58,669
so this is a lot more readable I hope

00:26:57,020 --> 00:26:59,450
you think this is also a lot more

00:26:58,669 --> 00:27:01,940
readable

00:26:59,450 --> 00:27:04,309
it's declarative then that first

00:27:01,940 --> 00:27:06,020
craziness that we saw of trying to grab

00:27:04,309 --> 00:27:09,220
single characters out of a string and

00:27:06,020 --> 00:27:09,220
figure out what to do with it right

00:27:10,900 --> 00:27:17,150
alright so we've combined some parsers

00:27:14,450 --> 00:27:23,090
we parsed a little something here let's

00:27:17,150 --> 00:27:25,760
take a look at attributes so eventually

00:27:23,090 --> 00:27:28,010
you know getting yeah it was good or no

00:27:25,760 --> 00:27:30,440
it wasn't isn't interesting for most

00:27:28,010 --> 00:27:32,360
people they don't want to just know that

00:27:30,440 --> 00:27:35,660
the parse was successful they want

00:27:32,360 --> 00:27:39,770
actually the data out of it so how do we

00:27:35,660 --> 00:27:44,590
get the result of this parse into a map

00:27:39,770 --> 00:27:47,390
of string string wouldn't that be nice

00:27:44,590 --> 00:27:50,480
I'd be really nice so we have this key

00:27:47,390 --> 00:27:53,030
value map and now we do something clever

00:27:50,480 --> 00:27:54,410
and bam are key value map is filled in

00:27:53,030 --> 00:27:57,400
it so let's figure out what the clever

00:27:54,410 --> 00:27:57,400
thing is that we need to do

00:27:58,870 --> 00:28:04,390
so we've been talking about parsers

00:28:01,950 --> 00:28:06,640
parsers have associated with them an

00:28:04,390 --> 00:28:11,350
attribute type the thing that they're

00:28:06,640 --> 00:28:15,550
going to synthesize naturally literals

00:28:11,350 --> 00:28:16,870
will not actually synthesize anything

00:28:15,550 --> 00:28:20,530
they have no attribute that they'll

00:28:16,870 --> 00:28:23,170
synthesize primitives will synthesize

00:28:20,530 --> 00:28:25,660
the thing that makes sense when you look

00:28:23,170 --> 00:28:29,410
at it it's pretty obvious that lols will

00:28:25,660 --> 00:28:32,670
synthesize a double and so forth non

00:28:29,410 --> 00:28:35,470
terminals like rules will synthesize

00:28:32,670 --> 00:28:38,830
whatever you tell it it's going to be

00:28:35,470 --> 00:28:40,900
synthesizing so this non-terminal is

00:28:38,830 --> 00:28:42,760
going to synthesize an A how about these

00:28:40,900 --> 00:28:46,570
operators what are they going to do for

00:28:42,760 --> 00:28:52,030
us or to us so an a followed by a B is a

00:28:46,570 --> 00:28:54,820
tuple of a and B an alternative they

00:28:52,030 --> 00:29:01,360
boost variant it's either this thing or

00:28:54,820 --> 00:29:03,670
that thing how about these so zero or

00:29:01,360 --> 00:29:06,040
more one or more or a list of things is

00:29:03,670 --> 00:29:09,310
a vector of the type of that thing

00:29:06,040 --> 00:29:18,870
whatever a is synthesizing it's a vector

00:29:09,310 --> 00:29:21,340
of that will get a boost optional and

00:29:18,870 --> 00:29:24,960
predicates obviously have no attribute

00:29:21,340 --> 00:29:24,960
that they're going to synthesize all

00:29:26,490 --> 00:29:34,810
right so how do we now get that value

00:29:31,840 --> 00:29:37,680
well it's actually pretty easy so here I

00:29:34,810 --> 00:29:40,210
am I have a parser that's an int and

00:29:37,680 --> 00:29:44,680
I've got an int I'm going to feed it and

00:29:40,210 --> 00:29:48,400
I simply provide a reference to the

00:29:44,680 --> 00:29:52,050
thing to stick it in so this will parse

00:29:48,400 --> 00:29:52,050
the int into result

00:29:56,610 --> 00:30:05,800
okay I'd like to parse pizza into an STD

00:30:01,300 --> 00:30:08,080
string and I can do that and the reason

00:30:05,800 --> 00:30:11,890
that this works is we talked about

00:30:08,080 --> 00:30:15,580
compatibility and while we say that the

00:30:11,890 --> 00:30:18,550
the clean star or the one more the list

00:30:15,580 --> 00:30:20,980
all going to an STD vector the reality

00:30:18,550 --> 00:30:24,340
is is that they go into the concept of a

00:30:20,980 --> 00:30:26,890
container as described by the x3

00:30:24,340 --> 00:30:28,960
specification of what that means and

00:30:26,890 --> 00:30:31,990
anything that is compatible with that

00:30:28,960 --> 00:30:35,260
concept then therefore will work and so

00:30:31,990 --> 00:30:38,350
a string is compatible with the STD

00:30:35,260 --> 00:30:40,090
vector of char so therefore a string is

00:30:38,350 --> 00:30:42,280
just as valid as anything else right

00:30:40,090 --> 00:30:44,370
here that could look like one of these

00:30:42,280 --> 00:30:50,740
container types

00:30:44,370 --> 00:30:54,070
how about cosmic space pizza well I

00:30:50,740 --> 00:31:02,250
could do this I could have result 1 be

00:30:54,070 --> 00:31:04,270
cosmic and result 2 will be pizza but

00:31:02,250 --> 00:31:08,980
that's going to become pretty

00:31:04,270 --> 00:31:12,460
unmanageable pretty fast so it ends up

00:31:08,980 --> 00:31:14,620
that that looked like a tuple right and

00:31:12,460 --> 00:31:19,480
that's the same thing as a pair that

00:31:14,620 --> 00:31:21,820
works for me and so result here of a

00:31:19,480 --> 00:31:23,140
pair of strings and I can put it here as

00:31:21,820 --> 00:31:27,040
the reference that I'm going to parse

00:31:23,140 --> 00:31:29,500
into and now cosmic will go into the

00:31:27,040 --> 00:31:50,920
first of the pair and pizza will go into

00:31:29,500 --> 00:31:53,140
the second yes questions yeah

00:31:50,920 --> 00:31:55,330
so basically the question is is what

00:31:53,140 --> 00:31:57,700
happens when you have more stuff

00:31:55,330 --> 00:31:59,830
continuing on and what happens is the

00:31:57,700 --> 00:32:02,860
parse is fine there's no error in in

00:31:59,830 --> 00:32:05,080
completing the grammar however if we

00:32:02,860 --> 00:32:07,120
looked at it err and inner end they're

00:32:05,080 --> 00:32:09,340
not equal right we didn't consume all of

00:32:07,120 --> 00:32:10,419
the input and so that's different than a

00:32:09,340 --> 00:32:14,129
failed parsed

00:32:10,419 --> 00:32:14,129
we might receive back out of the parser

00:32:33,779 --> 00:32:37,600
yeah so the question basically is what

00:32:35,799 --> 00:32:38,919
would you do if you want a vector of STD

00:32:37,600 --> 00:32:41,019
strings if you just had a bunch of these

00:32:38,919 --> 00:32:44,470
and they kept going on then that would

00:32:41,019 --> 00:32:46,779
look like a clean star of this thing

00:32:44,470 --> 00:32:49,450
right and this thing would no longer be

00:32:46,779 --> 00:32:50,590
a result here but we're gonna see in a

00:32:49,450 --> 00:32:53,049
moment maybe something else that we

00:32:50,590 --> 00:32:59,200
might want to do don't ruin my next set

00:32:53,049 --> 00:33:01,539
of slides visual all right so attribute

00:32:59,200 --> 00:33:05,109
parsing is where the magic lives in

00:33:01,539 --> 00:33:07,749
spirit and that's enabled through the

00:33:05,109 --> 00:33:09,399
fusion library so at some point if you

00:33:07,749 --> 00:33:11,259
decide that wow that's really pretty

00:33:09,399 --> 00:33:15,129
amazing you want to go look probably at

00:33:11,259 --> 00:33:16,779
fusion which is pretty darn amazing so

00:33:15,129 --> 00:33:21,549
let's take a look at some of these

00:33:16,779 --> 00:33:23,429
things here I have a string that's going

00:33:21,549 --> 00:33:27,639
to be what my name is going to

00:33:23,429 --> 00:33:29,470
synthesize so my rule for the name is

00:33:27,639 --> 00:33:31,960
going to synthesize a string and my rule

00:33:29,470 --> 00:33:38,259
for the quote is going to synthesize a

00:33:31,960 --> 00:33:41,409
string and my item now I'm going to

00:33:38,259 --> 00:33:43,629
actually parse this as an item well that

00:33:41,409 --> 00:33:48,220
is basically two strings I know how to

00:33:43,629 --> 00:33:50,200
do that that's a pair of strings right

00:33:48,220 --> 00:33:57,989
name followed by either a quote or a

00:33:50,200 --> 00:34:03,700
name so let's take a look at these in

00:33:57,989 --> 00:34:06,460
detail alpha is going to is going to

00:34:03,700 --> 00:34:08,679
synthesize a character and the b-side

00:34:06,460 --> 00:34:10,419
which is one or more sorry zero or more

00:34:08,679 --> 00:34:12,849
alpha numerics that's going to be a

00:34:10,419 --> 00:34:16,629
vector of character and how this works

00:34:12,849 --> 00:34:20,049
out right is this is a followed by B in

00:34:16,629 --> 00:34:23,079
which these are compatibility rules this

00:34:20,049 --> 00:34:23,740
is an alpha character this is a standard

00:34:23,079 --> 00:34:25,510
vector of care

00:34:23,740 --> 00:34:27,280
and therefore that could be quite

00:34:25,510 --> 00:34:29,710
compatible with just a standard vector

00:34:27,280 --> 00:34:32,830
of characters it can cook it can

00:34:29,710 --> 00:34:36,369
collapse if the attribute provided to it

00:34:32,830 --> 00:34:36,730
would allow it to collapse how about

00:34:36,369 --> 00:34:39,159
here

00:34:36,730 --> 00:34:41,649
well literals are unused so here's an

00:34:39,159 --> 00:34:44,260
unused and here's the unused for here

00:34:41,649 --> 00:34:45,879
and the center this is easy enough this

00:34:44,260 --> 00:34:48,010
is a vector of characters and a vector

00:34:45,879 --> 00:34:53,169
of characters is definitely compatible

00:34:48,010 --> 00:34:55,119
with the string so in essence a tuple of

00:34:53,169 --> 00:34:56,859
an unused followed by this something and

00:34:55,119 --> 00:35:05,849
followed by an unused is just the thing

00:34:56,859 --> 00:35:10,750
in the middle right quote is a string or

00:35:05,849 --> 00:35:12,910
name is a string so a string or a string

00:35:10,750 --> 00:35:14,200
would be a pretty useless variant at the

00:35:12,910 --> 00:35:17,609
moment we're not going to talk about

00:35:14,200 --> 00:35:20,410
variants of the same type okay and

00:35:17,609 --> 00:35:26,830
therefore this could look like just a

00:35:20,410 --> 00:35:28,750
string that now brings us down to we've

00:35:26,830 --> 00:35:31,690
got this as a string and this is now a

00:35:28,750 --> 00:35:33,640
name followed by what works out to be a

00:35:31,690 --> 00:35:35,170
z' a string and unused in a string and

00:35:33,640 --> 00:35:40,240
that just looks like a tuple of a string

00:35:35,170 --> 00:35:43,000
in a string because this was unused so

00:35:40,240 --> 00:35:51,700
this looks like a pair of a string

00:35:43,000 --> 00:35:55,780
string great because I would like my

00:35:51,700 --> 00:35:59,980
items to be a comma separated list and a

00:35:55,780 --> 00:36:03,070
standard pair a list of standard pairs

00:35:59,980 --> 00:36:05,440
looks like a vector of standard pairs

00:36:03,070 --> 00:36:07,720
which is basically a container of

00:36:05,440 --> 00:36:12,580
standard pairs which really is just a

00:36:07,720 --> 00:36:16,000
map and therefore this thing is just a

00:36:12,580 --> 00:36:19,030
map and so the magic is nothing the

00:36:16,000 --> 00:36:22,650
magic of what do we do that's special in

00:36:19,030 --> 00:36:24,820
that spot is we just give it a map a

00:36:22,650 --> 00:36:27,490
reference to a map because of reference

00:36:24,820 --> 00:36:35,460
to a map is compatible with the grammar

00:36:27,490 --> 00:36:35,460
we had already written not quite

00:36:42,540 --> 00:36:49,210
well in this case a map holding pairs

00:36:46,510 --> 00:36:51,550
it's a compatibility thing right and so

00:36:49,210 --> 00:36:53,950
the pair is of string and string and

00:36:51,550 --> 00:36:58,780
therefore a map is just a container of

00:36:53,950 --> 00:37:01,360
two strings all right it really is a

00:36:58,780 --> 00:37:03,640
multi map is the question let's let's

00:37:01,360 --> 00:37:04,930
continue on and we've got a bunch of

00:37:03,640 --> 00:37:09,869
slides to get through and run with kind

00:37:04,930 --> 00:37:13,810
of low on time and I'm here all week so

00:37:09,869 --> 00:37:15,430
the rules attribute type is optional if

00:37:13,810 --> 00:37:17,260
it's not going to synthesize something

00:37:15,430 --> 00:37:20,980
you don't need to put it and then you

00:37:17,260 --> 00:37:26,560
wouldn't have a rule attribute so let's

00:37:20,980 --> 00:37:28,660
look at at an example here before we get

00:37:26,560 --> 00:37:33,010
to the example just a couple little

00:37:28,660 --> 00:37:34,750
guidelines how many people here have

00:37:33,010 --> 00:37:37,300
used spirit maybe we'll start with that

00:37:34,750 --> 00:37:39,369
okay how many people here have used any

00:37:37,300 --> 00:37:43,590
library that uses expression templates

00:37:39,369 --> 00:37:46,300
or other boost meta programming

00:37:43,590 --> 00:37:48,790
libraries of any sort so okay good there

00:37:46,300 --> 00:37:50,950
that's the whole room at that point so

00:37:48,790 --> 00:37:52,359
you will you will already be accustomed

00:37:50,950 --> 00:37:55,390
to the fact that the compiler is going

00:37:52,359 --> 00:37:57,850
to spit out copious amounts of cred that

00:37:55,390 --> 00:37:59,500
you don't understand and eventually you

00:37:57,850 --> 00:38:00,910
will hunt through it and you will find

00:37:59,500 --> 00:38:03,030
something that's useful but you probably

00:38:00,910 --> 00:38:07,510
won't do that you probably give up so

00:38:03,030 --> 00:38:10,570
spirit uses static asserts all over the

00:38:07,510 --> 00:38:12,730
place when things are bad and it tries

00:38:10,570 --> 00:38:14,530
super super hard to tell you what's

00:38:12,730 --> 00:38:17,200
going on but unfortunately you have to

00:38:14,530 --> 00:38:19,119
find it in the compiler spew and how you

00:38:17,200 --> 00:38:21,270
find it as you search for for asterisks

00:38:19,119 --> 00:38:23,410
in a row and it will have a line number

00:38:21,270 --> 00:38:26,140
along with the static assert and the

00:38:23,410 --> 00:38:30,369
file and you go there if you're in an

00:38:26,140 --> 00:38:33,430
IDE or Emacs or something like that you

00:38:30,369 --> 00:38:36,310
can pull up the file and there will be a

00:38:33,430 --> 00:38:38,590
narrative that tells you exactly why the

00:38:36,310 --> 00:38:40,060
compiler was static asserting at that

00:38:38,590 --> 00:38:42,369
point and what you probably need to

00:38:40,060 --> 00:38:44,050
change in your grammar so as opposed to

00:38:42,369 --> 00:38:46,119
just throwing up your arms and saying I

00:38:44,050 --> 00:38:47,099
have no idea why did I ever start this

00:38:46,119 --> 00:38:53,109
project

00:38:47,099 --> 00:38:55,210
all right so things are hard concepts

00:38:53,109 --> 00:39:01,869
will make it better there we go that's

00:38:55,210 --> 00:39:04,270
my so start small alternatives in your

00:39:01,869 --> 00:39:06,460
grammar are a natural place to break

00:39:04,270 --> 00:39:07,869
things up just start with like one of

00:39:06,460 --> 00:39:09,700
those and work on it and then add

00:39:07,869 --> 00:39:12,640
another one and then animal or just work

00:39:09,700 --> 00:39:14,140
on each alternative at a time to make

00:39:12,640 --> 00:39:16,660
sure that they work start small and

00:39:14,140 --> 00:39:19,960
build up until you get experience using

00:39:16,660 --> 00:39:22,030
spirit so you're gonna start from the

00:39:19,960 --> 00:39:24,700
leaves and work your way up compose and

00:39:22,030 --> 00:39:28,089
test compose something test it compose

00:39:24,700 --> 00:39:30,010
something test it do a lot of that don't

00:39:28,089 --> 00:39:32,050
write your whole grammar that's pages

00:39:30,010 --> 00:39:33,790
and pages long and then like wonder why

00:39:32,050 --> 00:39:39,910
it doesn't work that's just you're gonna

00:39:33,790 --> 00:39:42,369
be sad test early and often nobody ever

00:39:39,910 --> 00:39:45,000
listens to this fungus aid anyhow deal

00:39:42,369 --> 00:39:49,680
with parsing first and then deal with

00:39:45,000 --> 00:39:54,130
attribute synthesis a synthase ssin hmm

00:39:49,680 --> 00:39:56,109
synthesis ii alright so you want to

00:39:54,130 --> 00:39:58,299
worry about the parser first and then

00:39:56,109 --> 00:40:00,040
worry about the attributes next don't

00:39:58,299 --> 00:40:02,799
try to do both at the same time until

00:40:00,040 --> 00:40:05,680
you get you know some experience with

00:40:02,799 --> 00:40:10,510
this stuff allow the natural ast to fall

00:40:05,680 --> 00:40:14,470
out your grammar has an AST don't don't

00:40:10,510 --> 00:40:18,339
fight it it wants to generate some data

00:40:14,470 --> 00:40:20,049
structure for you let it do that let it

00:40:18,339 --> 00:40:21,430
make the data structure you can already

00:40:20,049 --> 00:40:23,799
see that we're we're gonna be able to

00:40:21,430 --> 00:40:26,349
manipulate the container types all we

00:40:23,799 --> 00:40:29,049
want within certain bounds but don't

00:40:26,349 --> 00:40:31,359
fight it beyond that instead what you do

00:40:29,049 --> 00:40:33,609
is you have an ast that comes out and

00:40:31,359 --> 00:40:35,799
you transform that to something else

00:40:33,609 --> 00:40:38,079
that is so much easier and more

00:40:35,799 --> 00:40:40,390
efficient than putting in semantic

00:40:38,079 --> 00:40:45,609
actions everywhere when the parse is

00:40:40,390 --> 00:40:48,549
true do something action why's that now

00:40:45,609 --> 00:40:50,710
no longer is a nice declarative grammar

00:40:48,549 --> 00:40:53,160
that's like procedural stuff crammed

00:40:50,710 --> 00:40:55,540
into a declarative grammar it's nasty

00:40:53,160 --> 00:40:58,500
and then refine your grammar in you're a

00:40:55,540 --> 00:41:00,250
st so let's look at a JSON very quickly

00:40:58,500 --> 00:41:03,310
parser there

00:41:00,250 --> 00:41:05,320
there are nice and easy so if you're not

00:41:03,310 --> 00:41:07,240
familiar with JSON I would be surprised

00:41:05,320 --> 00:41:12,670
well tells me that everybody and their

00:41:07,240 --> 00:41:15,340
dog is so and JSON has objects there

00:41:12,670 --> 00:41:17,920
within curly brackets they the object

00:41:15,340 --> 00:41:20,680
has basically pairs in which the first

00:41:17,920 --> 00:41:23,860
is a string and the second is a JSON

00:41:20,680 --> 00:41:25,750
value thing JSON values can be strings

00:41:23,860 --> 00:41:28,540
or they can be objects so they can be

00:41:25,750 --> 00:41:31,900
boolean's or they can be numeric or they

00:41:28,540 --> 00:41:36,250
can be with the brackets and then lists

00:41:31,900 --> 00:41:37,960
of things that we know so the idea is

00:41:36,250 --> 00:41:40,300
you can see very quickly of course a

00:41:37,960 --> 00:41:43,360
list would be a list of or JSON value

00:41:40,300 --> 00:41:45,400
types this is a recursive data structure

00:41:43,360 --> 00:41:47,350
not a complicated one but one that we

00:41:45,400 --> 00:41:50,140
can actually create some amount of

00:41:47,350 --> 00:41:51,030
detail with a bit of type information

00:41:50,140 --> 00:41:53,560
along the way

00:41:51,030 --> 00:41:55,780
what would an ast look like well is that

00:41:53,560 --> 00:41:57,340
one potential or possible ast for this

00:41:55,780 --> 00:42:00,940
we're just going to say that a string is

00:41:57,340 --> 00:42:02,260
an STD string and a double is a double

00:42:00,940 --> 00:42:03,550
and a float because we're going to

00:42:02,260 --> 00:42:06,820
somehow deal with those differently has

00:42:03,550 --> 00:42:08,710
a double that when we're dealing with

00:42:06,820 --> 00:42:12,100
integers with inside of our JSON thing

00:42:08,710 --> 00:42:17,110
it's an n64 boolean types of bool null

00:42:12,100 --> 00:42:19,840
is just just an empty strike I'm going

00:42:17,110 --> 00:42:22,270
to pre define what a our preacher of a

00:42:19,840 --> 00:42:27,640
value and then I'm gonna say an object

00:42:22,270 --> 00:42:29,560
is a map of string to value and an

00:42:27,640 --> 00:42:32,260
object member therefore is the value

00:42:29,560 --> 00:42:36,820
type the thing that's inside here and an

00:42:32,260 --> 00:42:39,250
array is I'm going to use a boost stable

00:42:36,820 --> 00:42:44,020
vector for a reason that doesn't matter

00:42:39,250 --> 00:42:45,910
for this talk of values this could just

00:42:44,020 --> 00:42:51,010
be an STD vector by the way for what

00:42:45,910 --> 00:42:52,360
we're doing right now all right so you

00:42:51,010 --> 00:42:57,580
can see the recursion is starting to

00:42:52,360 --> 00:43:01,030
begin right now so what is value value

00:42:57,580 --> 00:43:02,680
is an x3 variant and x3 variant you can

00:43:01,030 --> 00:43:05,040
think of it I like a boost variant

00:43:02,680 --> 00:43:07,120
except a boost variant is a is not a

00:43:05,040 --> 00:43:09,970
it's not an object we don't have an

00:43:07,120 --> 00:43:13,750
object we have a type def which is super

00:43:09,970 --> 00:43:18,520
annoying because I I can't actually

00:43:13,750 --> 00:43:21,849
say this with the type def and then use

00:43:18,520 --> 00:43:25,180
it but here I can and so how this works

00:43:21,849 --> 00:43:27,430
out is now I can inherit from x3 variant

00:43:25,180 --> 00:43:29,770
and now value is going to be able to

00:43:27,430 --> 00:43:31,720
contain either a null or a bull type or

00:43:29,770 --> 00:43:33,760
a string type or an int type or a double

00:43:31,720 --> 00:43:35,740
type or an object type or an array type

00:43:33,760 --> 00:43:40,690
okay it's one of those things that's

00:43:35,740 --> 00:43:44,310
what this value holds I'm gonna pull in

00:43:40,690 --> 00:43:46,300
some I'm gonna pull in the the

00:43:44,310 --> 00:43:47,950
Constructors and assignment operators

00:43:46,300 --> 00:43:51,460
from the base so that I can just assign

00:43:47,950 --> 00:43:54,490
one of these and make it work if I it's

00:43:51,460 --> 00:43:56,890
default constructed it'll be null a

00:43:54,490 --> 00:43:59,109
little bit of trick in order to make

00:43:56,890 --> 00:44:03,070
this work for doubles for any floating

00:43:59,109 --> 00:44:04,869
point type and then a little more trick

00:44:03,070 --> 00:44:07,869
in order to make this so that if I have

00:44:04,869 --> 00:44:09,790
any integral type or an enum it will

00:44:07,869 --> 00:44:11,500
work out to be an int type when I create

00:44:09,790 --> 00:44:15,760
one of these it's kind of is all kind of

00:44:11,500 --> 00:44:25,720
unimportant stuff in order to to

00:44:15,760 --> 00:44:28,450
construct them yeah some he was he was

00:44:25,720 --> 00:44:30,520
listening really well yes so the the

00:44:28,450 --> 00:44:32,080
question oh the the comment is didn't

00:44:30,520 --> 00:44:35,710
you just say that you should like focus

00:44:32,080 --> 00:44:37,750
on the parser first yes I did but we

00:44:35,710 --> 00:44:38,920
don't have time to focus on the parser

00:44:37,750 --> 00:44:41,140
first and then the attributes we're

00:44:38,920 --> 00:44:42,640
going to do it all at once and this is

00:44:41,140 --> 00:44:47,430
what falls out naturally by the way of

00:44:42,640 --> 00:44:50,890
the parser so good catch

00:44:47,430 --> 00:44:55,570
so at the top level of value is going to

00:44:50,890 --> 00:44:57,940
be a variant of one of these I want to

00:44:55,570 --> 00:44:59,710
deal with grammars because grammars are

00:44:57,940 --> 00:45:03,070
just like nice packages they make me

00:44:59,710 --> 00:45:04,930
feel good but really at the end of the

00:45:03,070 --> 00:45:08,290
day a grammar is nothing more than a

00:45:04,930 --> 00:45:10,030
bunch of rules composed together to make

00:45:08,290 --> 00:45:14,800
some higher-level rule that I can think

00:45:10,030 --> 00:45:18,520
about and so this is what I'm going to

00:45:14,800 --> 00:45:21,849
do in the code here is that tag that I'm

00:45:18,520 --> 00:45:24,520
going to use it's a JSON class so in my

00:45:21,849 --> 00:45:28,170
rule JSON class and it's going to

00:45:24,520 --> 00:45:28,170
synthesize a JSON value

00:45:28,850 --> 00:45:32,780
that's this thing it's gonna synthesize

00:45:30,890 --> 00:45:35,050
one of these a variant of any of these

00:45:32,780 --> 00:45:35,050
things

00:45:36,580 --> 00:45:46,820
booth spirit declare so how x3 works and

00:45:43,520 --> 00:45:47,510
in order to speed up compile time just

00:45:46,820 --> 00:45:50,330
greatly

00:45:47,510 --> 00:45:53,510
it uses a DL for lookup for things that

00:45:50,330 --> 00:45:56,240
it used to use for making instantiations

00:45:53,510 --> 00:45:59,870
of stuff all over the place and and as a

00:45:56,240 --> 00:46:01,130
result we have to tie a bunch of things

00:45:59,870 --> 00:46:02,630
together and what holds the stuff

00:46:01,130 --> 00:46:03,920
together this is probably detail that

00:46:02,630 --> 00:46:06,170
you don't care about for using it what

00:46:03,920 --> 00:46:08,660
holds the stuff together is this tag so

00:46:06,170 --> 00:46:11,300
JSON class is the tag that's gonna hold

00:46:08,660 --> 00:46:12,920
all the things together here it is here

00:46:11,300 --> 00:46:15,470
it's gonna show up in some more places

00:46:12,920 --> 00:46:17,690
and if you say boo spirit declare JSON

00:46:15,470 --> 00:46:19,460
type this expands out to be about like

00:46:17,690 --> 00:46:21,230
three or four lines to care of some

00:46:19,460 --> 00:46:22,880
stuff for you you can look right those

00:46:21,230 --> 00:46:25,550
three or four lines so you can just type

00:46:22,880 --> 00:46:27,200
that in the declare so here are the

00:46:25,550 --> 00:46:30,290
naming conventions if you want to just

00:46:27,200 --> 00:46:32,930
use the nice macro your identify ur your

00:46:30,290 --> 00:46:34,910
your ID is going to be identify your

00:46:32,930 --> 00:46:36,710
underscore class your rule is going to

00:46:34,910 --> 00:46:38,240
be identifiers who are tight the

00:46:36,710 --> 00:46:40,400
definition of your rule is going to be

00:46:38,240 --> 00:46:42,200
identifier in Urfa sky underscore def

00:46:40,400 --> 00:46:45,560
and then you're going to just refer to

00:46:42,200 --> 00:46:48,440
the rule in general as identifier so

00:46:45,560 --> 00:46:54,500
that's what we had right here so here's

00:46:48,440 --> 00:46:59,390
our JSON type this is the rule type all

00:46:54,500 --> 00:47:00,950
right so we're also gonna have a value

00:46:59,390 --> 00:47:02,030
class an object class and a member pair

00:47:00,950 --> 00:47:04,610
these are the things that we saw a

00:47:02,030 --> 00:47:07,640
little while ago and now what are they

00:47:04,610 --> 00:47:09,890
here are the rules well the value type

00:47:07,640 --> 00:47:11,120
rule is gonna create a value for us an

00:47:09,890 --> 00:47:13,760
object type rule is going to synthesize

00:47:11,120 --> 00:47:15,170
an object the member pair an object

00:47:13,760 --> 00:47:18,740
member pair and array is gonna

00:47:15,170 --> 00:47:22,550
synthesize an array I can now create my

00:47:18,740 --> 00:47:27,080
my rules which is of the type of the of

00:47:22,550 --> 00:47:29,240
whatever the value type value the object

00:47:27,080 --> 00:47:31,970
type object and so forth and I'm giving

00:47:29,240 --> 00:47:34,310
them this string and the string is just

00:47:31,970 --> 00:47:36,920
I'm in debug mode you can actually have

00:47:34,310 --> 00:47:38,390
as its parsing spit stuff out of what

00:47:36,920 --> 00:47:39,350
it's doing where it's backtracking stuff

00:47:38,390 --> 00:47:41,360
and now you know where it

00:47:39,350 --> 00:47:43,610
these are going to be the lightweight

00:47:41,360 --> 00:47:44,690
things that are used in the system this

00:47:43,610 --> 00:47:46,280
is what we're going to use in order to

00:47:44,690 --> 00:47:48,470
refer to these rules from this point on

00:47:46,280 --> 00:47:52,310
and here we see the first one the

00:47:48,470 --> 00:47:55,730
definition of a value is it is a null

00:47:52,310 --> 00:47:59,890
value or a bool value or it's a Unicode

00:47:55,730 --> 00:48:03,290
string or it is this is an integer

00:47:59,890 --> 00:48:07,970
because it is not followed by one of

00:48:03,290 --> 00:48:13,730
these or it's a double or it's an object

00:48:07,970 --> 00:48:16,580
or it's an array so what is a null value

00:48:13,730 --> 00:48:20,900
well a null value in JSON is literal

00:48:16,580 --> 00:48:23,210
null so and when we see the literal null

00:48:20,900 --> 00:48:25,100
we would which as you know literals do

00:48:23,210 --> 00:48:26,750
not synthesize an attribute we would

00:48:25,100 --> 00:48:32,960
like it actually to create an attribute

00:48:26,750 --> 00:48:35,480
for us 18 X 3 attr when this will parse

00:48:32,960 --> 00:48:37,850
or consume nothing out of the stream but

00:48:35,480 --> 00:48:40,190
it will generate the attribute and so

00:48:37,850 --> 00:48:46,430
this is going to generate a null type

00:48:40,190 --> 00:48:49,880
out we saw an int what is an int it's

00:48:46,430 --> 00:48:53,900
gonna be an n64 parser and bool is just

00:48:49,880 --> 00:48:55,520
going to be the bull-type parser what is

00:48:53,900 --> 00:48:59,180
an object definition well an object

00:48:55,520 --> 00:49:03,380
definition is a curly bracket followed

00:48:59,180 --> 00:49:06,140
by an optional list of member pairs that

00:49:03,380 --> 00:49:09,230
are comma separated and then ending with

00:49:06,140 --> 00:49:11,510
a curly well what does a member pair a

00:49:09,230 --> 00:49:21,350
member pair is a Unicode string followed

00:49:11,510 --> 00:49:22,970
by a colon followed by a value right so

00:49:21,350 --> 00:49:26,480
we see our first bit of recursion right

00:49:22,970 --> 00:49:29,930
here what is an array well an array is

00:49:26,480 --> 00:49:32,900
simply a left bracket followed by an

00:49:29,930 --> 00:49:38,290
optional mm comma separated set of

00:49:32,900 --> 00:49:38,290
values right followed by a right bracket

00:49:38,350 --> 00:49:47,300
all right we just defined null the int

00:49:43,520 --> 00:49:50,060
type the floating point type we dealt

00:49:47,300 --> 00:49:52,310
with the bull-type we've dealt with an

00:49:50,060 --> 00:49:54,770
object

00:49:52,310 --> 00:49:57,800
arrey the only thing we haven't dealt

00:49:54,770 --> 00:50:00,080
with is the stream so if we weren't

00:49:57,800 --> 00:50:02,510
being fancy in trying to deal with

00:50:00,080 --> 00:50:04,100
unicode strings we would just do what

00:50:02,510 --> 00:50:07,730
we've been doing for Strings which is

00:50:04,100 --> 00:50:09,830
zero or more chars right and we would

00:50:07,730 --> 00:50:11,840
call it good and we would have a grammar

00:50:09,830 --> 00:50:13,970
that everybody could read and would be

00:50:11,840 --> 00:50:17,780
done with and it'll just work for JSON

00:50:13,970 --> 00:50:19,790
with you know some caveat of we don't

00:50:17,780 --> 00:50:23,030
like Unicode I mean you know they did

00:50:19,790 --> 00:50:27,470
put spaceships up on the moon without

00:50:23,030 --> 00:50:30,020
Unicode it happens alright so when you

00:50:27,470 --> 00:50:32,990
get to this point here you can say boost

00:50:30,020 --> 00:50:35,810
spirit define and list your rules within

00:50:32,990 --> 00:50:37,760
the namespace and this does that pulling

00:50:35,810 --> 00:50:38,810
things together with the tag for you

00:50:37,760 --> 00:50:40,820
because we're gonna use the naming

00:50:38,810 --> 00:50:43,010
convention right and it does a little

00:50:40,820 --> 00:50:46,490
bit more work for you and and call it

00:50:43,010 --> 00:50:48,890
good alright let's look at what the

00:50:46,490 --> 00:50:53,540
unicode string looks like the same type

00:50:48,890 --> 00:50:58,010
of stuff and a spelling error

00:50:53,540 --> 00:51:09,170
interesting so here is the unicode

00:50:58,010 --> 00:51:11,240
string kind of weird and it is let's

00:51:09,170 --> 00:51:12,800
start with this double quoted what is

00:51:11,240 --> 00:51:14,750
the double quoted thing it is shut off

00:51:12,800 --> 00:51:17,510
the let's shut off the parser I've seen

00:51:14,750 --> 00:51:21,170
it shut off the skipper it is a quote

00:51:17,510 --> 00:51:22,670
followed by zero and it's notice we are

00:51:21,170 --> 00:51:26,090
using expectation point at this point

00:51:22,670 --> 00:51:29,000
followed by zero or more escaped

00:51:26,090 --> 00:51:31,820
characters or it's one of these and ooh

00:51:29,000 --> 00:51:34,670
what is this weird thing here well if

00:51:31,820 --> 00:51:36,650
you see something in brackets out at the

00:51:34,670 --> 00:51:37,790
end this is a semantic action it's the

00:51:36,650 --> 00:51:39,230
things we want to stay away from

00:51:37,790 --> 00:51:41,030
generally when we're writing grammars

00:51:39,230 --> 00:51:43,280
until like it's last resort we don't

00:51:41,030 --> 00:51:45,290
know another way to do it at this point

00:51:43,280 --> 00:51:50,960
what we're saying is when this parse is

00:51:45,290 --> 00:51:53,030
successful execute something what is the

00:51:50,960 --> 00:51:56,480
something well that's this lambda and

00:51:53,030 --> 00:51:58,790
the lambda is receiving the context of

00:51:56,480 --> 00:52:00,650
the parse at this point in time and

00:51:58,790 --> 00:52:03,770
within the context of the parse there's

00:52:00,650 --> 00:52:05,600
this thing called Val Val happens to be

00:52:03,770 --> 00:52:08,690
the current at

00:52:05,600 --> 00:52:11,300
tribute that you're in the middle of

00:52:08,690 --> 00:52:15,290
parse of the parse and we're just going

00:52:11,300 --> 00:52:20,630
to stick on the end of it the attribute

00:52:15,290 --> 00:52:22,910
of the context so this is the value of

00:52:20,630 --> 00:52:25,100
the context it's the things coming out

00:52:22,910 --> 00:52:28,220
of here and the attribute is the one

00:52:25,100 --> 00:52:31,790
that it just succeeded on what is escape

00:52:28,220 --> 00:52:34,070
escape our carts chart scape is the

00:52:31,790 --> 00:52:35,840
escape followed by whatever this escape

00:52:34,070 --> 00:52:39,920
thing and the escape thing is going to

00:52:35,840 --> 00:52:41,810
be a you followed by a hex for well what

00:52:39,920 --> 00:52:43,910
does a hex for we're gonna define a hex

00:52:41,810 --> 00:52:46,670
for as being an unsigned int parser that

00:52:43,910 --> 00:52:52,280
is unsigned characters 16 of them 4 4

00:52:46,670 --> 00:52:55,700
and we here we also have decided to

00:52:52,280 --> 00:52:58,790
stick on to more cemented actions to

00:52:55,700 --> 00:53:00,950
take care of this the first one is this

00:52:58,790 --> 00:53:03,710
push escape which is going to take and

00:53:00,950 --> 00:53:06,710
look what is it that we've got and push

00:53:03,710 --> 00:53:10,540
back the appropriate thing into the

00:53:06,710 --> 00:53:14,590
utf-8 thing that we're building up and

00:53:10,540 --> 00:53:17,660
then push utf-8 is going to take care of

00:53:14,590 --> 00:53:19,730
sticking it sitting in the rest of the

00:53:17,660 --> 00:53:21,770
way so occasionally you will end up

00:53:19,730 --> 00:53:24,100
possibly with semantic actions but it's

00:53:21,770 --> 00:53:26,690
only in really really weird odd cases

00:53:24,100 --> 00:53:31,940
most of the time you will end up parsing

00:53:26,690 --> 00:53:33,800
without any weird odd cases at the end

00:53:31,940 --> 00:53:36,590
how do we parse this thing out well we

00:53:33,800 --> 00:53:40,040
call phrase parse we give it the begin

00:53:36,590 --> 00:53:47,320
in the end we give it our grammar that

00:53:40,040 --> 00:53:50,960
came out of here and this is space type

00:53:47,320 --> 00:53:56,060
and where we want it where we would like

00:53:50,960 --> 00:53:58,640
to parse it into we can catch any

00:53:56,060 --> 00:54:00,950
exceptions at this point for failures

00:53:58,640 --> 00:54:04,940
and then handle them appropriately so we

00:54:00,950 --> 00:54:08,480
wrote a JSON parser with really very few

00:54:04,940 --> 00:54:13,990
set of lines and it is probably pretty

00:54:08,480 --> 00:54:13,990
understandable yeah what's the question

00:54:26,440 --> 00:54:37,660
this one this one that would be that one

00:54:43,780 --> 00:54:48,050
yep so you would check parse except to

00:54:46,700 --> 00:54:52,250
see whether or not your parse was

00:54:48,050 --> 00:54:53,660
successful and you can then check the

00:54:52,250 --> 00:54:55,970
iterators and compare them to see

00:54:53,660 --> 00:54:58,760
whether you consume the whole thing now

00:54:55,970 --> 00:55:01,670
the time that you throw is when there is

00:54:58,760 --> 00:55:03,920
an expectation point that you didn't

00:55:01,670 --> 00:55:06,140
meet and then at that point bad things

00:55:03,920 --> 00:55:08,060
occur right and you can deal with them

00:55:06,140 --> 00:55:09,470
whether there's a non error there's a

00:55:08,060 --> 00:55:11,210
non error handler you might want to

00:55:09,470 --> 00:55:13,390
print out the line number or such or

00:55:11,210 --> 00:55:16,040
store that somewhere

00:55:13,390 --> 00:55:20,089
we've got just five minutes and and I'd

00:55:16,040 --> 00:55:23,180
like to just do one thing here this

00:55:20,089 --> 00:55:24,830
question comes up a lot and and might as

00:55:23,180 --> 00:55:27,020
well deal with it a little bit this is

00:55:24,830 --> 00:55:29,450
just a quick overview of a bit of stuff

00:55:27,020 --> 00:55:30,650
about spirit right but a lot of times

00:55:29,450 --> 00:55:32,810
what we're trying to do is parse inside

00:55:30,650 --> 00:55:33,770
of your own data structure you know I've

00:55:32,810 --> 00:55:35,030
got my own data structure that I'd

00:55:33,770 --> 00:55:38,180
really like to parse this information

00:55:35,030 --> 00:55:40,750
into how do you do that well if you have

00:55:38,180 --> 00:55:44,030
your own Struck's

00:55:40,750 --> 00:55:46,010
remember spirit wants to be able to

00:55:44,030 --> 00:55:48,500
parse things like this followed by that

00:55:46,010 --> 00:55:50,030
into a tuple of something and if you

00:55:48,500 --> 00:55:52,880
could figure out how to make your struck

00:55:50,030 --> 00:55:54,859
look like a tuple life would be great

00:55:52,880 --> 00:55:56,510
and it ends up that fusion does that for

00:55:54,859 --> 00:56:00,170
you in all kinds of different ways and

00:55:56,510 --> 00:56:02,150
you can say boost Fusion adapt struct

00:56:00,170 --> 00:56:05,089
the struct I would like to adapt and

00:56:02,150 --> 00:56:08,510
which of the elements within the struct

00:56:05,089 --> 00:56:10,280
you're adapting or the members so sign

00:56:08,510 --> 00:56:12,200
is got this signed

00:56:10,280 --> 00:56:15,589
it's a char type and an operand which is

00:56:12,200 --> 00:56:16,220
an operand and so I can say fusion adapt

00:56:15,589 --> 00:56:19,520
struct

00:56:16,220 --> 00:56:22,010
the thing I'm adapting and and each of

00:56:19,520 --> 00:56:24,349
the members I want to adapt you don't

00:56:22,010 --> 00:56:26,750
have to adapt all of them and which

00:56:24,349 --> 00:56:28,730
order you would like to adapt them

00:56:26,750 --> 00:56:30,710
you can even adapt them multiple times

00:56:28,730 --> 00:56:33,170
if you wanted to or leave some out or

00:56:30,710 --> 00:56:35,330
put some extras in and the really what

00:56:33,170 --> 00:56:38,090
it's doing down underneath is it's

00:56:35,330 --> 00:56:41,920
creating a tuple of references to that

00:56:38,090 --> 00:56:45,230
type of whatever the member type is and

00:56:41,920 --> 00:56:47,600
that tuple that it's creating of those

00:56:45,230 --> 00:56:50,810
references is getting tagged in such a

00:56:47,600 --> 00:56:53,000
way that at compile time it can find it

00:56:50,810 --> 00:56:54,680
when it sees one of those types it finds

00:56:53,000 --> 00:56:57,380
the definition of what it is and it

00:56:54,680 --> 00:56:59,510
plugs that in so what do you do you

00:56:57,380 --> 00:57:02,390
adapt it and you just give it a

00:56:59,510 --> 00:57:04,790
reference to your datatype and bam it

00:57:02,390 --> 00:57:06,410
fills it in and so we've only dealt with

00:57:04,790 --> 00:57:10,190
so far when our in our little bit of

00:57:06,410 --> 00:57:12,080
JSON parsing a variant or containers

00:57:10,190 --> 00:57:14,240
things that it already understands but

00:57:12,080 --> 00:57:15,800
for your own types you can adapt them if

00:57:14,240 --> 00:57:18,770
you have an own type your own type that

00:57:15,800 --> 00:57:19,970
just has methods to get to private data

00:57:18,770 --> 00:57:24,290
not a problem

00:57:19,970 --> 00:57:28,100
again fusion can adapt getters and

00:57:24,290 --> 00:57:30,940
setters for members so that when it sees

00:57:28,100 --> 00:57:33,800
those it will actually do that too

00:57:30,940 --> 00:57:37,250
clearly not as efficient as being able

00:57:33,800 --> 00:57:39,650
to directly access and parse into your

00:57:37,250 --> 00:57:41,170
data structure but it's still pretty

00:57:39,650 --> 00:57:46,160
good

00:57:41,170 --> 00:57:50,390
all right um we're basically on a time

00:57:46,160 --> 00:57:52,040
oh I have two minutes oh my goodness

00:57:50,390 --> 00:57:56,590
what am I gonna do with two minutes okay

00:57:52,040 --> 00:57:56,590
I'll take I'll take a few questions and

00:58:01,090 --> 00:58:06,320
so that's a great question how does this

00:58:03,080 --> 00:58:08,540
JSON parser perform in regard to other

00:58:06,320 --> 00:58:12,890
parsers there are a bunch of parser

00:58:08,540 --> 00:58:15,050
frameworks out there are a bunch of JSON

00:58:12,890 --> 00:58:19,190
parsers out there and there are a bunch

00:58:15,050 --> 00:58:21,380
of benchmarks and if you go to the thing

00:58:19,190 --> 00:58:24,590
that fell off the end that it's horrible

00:58:21,380 --> 00:58:27,230
Kirra labs if you go to kara labs and

00:58:24,590 --> 00:58:29,540
github the json parser is on there along

00:58:27,230 --> 00:58:31,580
with some benchmarks and you can take a

00:58:29,540 --> 00:58:33,260
look at those the generally speaking we

00:58:31,580 --> 00:58:36,110
actually haven't ran it against x3 the

00:58:33,260 --> 00:58:39,170
v2 stuff not so much it didn't perform

00:58:36,110 --> 00:58:40,970
really great and the reason it doesn't

00:58:39,170 --> 00:58:45,500
perform super well how

00:58:40,970 --> 00:58:47,570
to do with the internals of how variant

00:58:45,500 --> 00:58:50,540
works and recursive variants in

00:58:47,570 --> 00:58:53,690
particular and the way move works with

00:58:50,540 --> 00:58:56,869
recursive variant things which is why

00:58:53,690 --> 00:58:57,980
there's an x3 variant now because we

00:58:56,869 --> 00:59:00,470
have a different idea of what it means

00:58:57,980 --> 00:59:01,250
to do a move and it's made for

00:59:00,470 --> 00:59:03,770
performance

00:59:01,250 --> 00:59:07,849
so we'll rerun those we'll have an idea

00:59:03,770 --> 00:59:09,740
the JSON but J something that is there

00:59:07,849 --> 00:59:11,300
is really interested in trying to figure

00:59:09,740 --> 00:59:12,800
out how to make JSON objects look like

00:59:11,300 --> 00:59:14,930
they would in Python or JavaScript

00:59:12,800 --> 00:59:17,210
within c++ and so you just deal with

00:59:14,930 --> 00:59:23,599
them which that's a harder problem than

00:59:17,210 --> 00:59:25,250
parsing so the question is is the whole

00:59:23,599 --> 00:59:27,230
parser generator at compile time it is

00:59:25,250 --> 00:59:29,660
so the whole parser is generated at

00:59:27,230 --> 00:59:31,430
compile time what you're writing our

00:59:29,660 --> 00:59:34,099
expression templates and so at compile

00:59:31,430 --> 00:59:36,140
time it is taking those types and it is

00:59:34,099 --> 00:59:37,550
generating things and combining things

00:59:36,140 --> 00:59:40,130
and generating things and combining

00:59:37,550 --> 00:59:50,240
things until at the very end BAM you

00:59:40,130 --> 00:59:54,349
have your parser generated great

00:59:50,240 --> 00:59:57,680
question so it is x3 is being shipped

00:59:54,349 --> 01:00:01,460
with boost since one five six it has

00:59:57,680 --> 01:00:03,530
been in as a separate line and you can

01:00:01,460 --> 01:00:05,990
look at the spirit documentation to see

01:00:03,530 --> 01:00:08,210
how to enable it and to use that so by

01:00:05,990 --> 01:00:13,940
default you'll get be too if you want x3

01:00:08,210 --> 01:00:16,520
you can enable x3 wise are not a Unicode

01:00:13,940 --> 01:00:20,390
parser there may be a unicode parser at

01:00:16,520 --> 01:00:23,030
some point the the reason that there

01:00:20,390 --> 01:00:24,410
isn't a unicode parser is there's

01:00:23,030 --> 01:00:27,500
currently a belief to try to keep

01:00:24,410 --> 01:00:29,930
everything as thin and slim as possible

01:00:27,500 --> 01:00:32,930
and be to kind of got out of hand and we

01:00:29,930 --> 01:00:34,550
would write like x3 not 2 but Unicode is

01:00:32,930 --> 01:00:36,140
one of those that were thinking that we

01:00:34,550 --> 01:00:39,230
probably should just write one and have

01:00:36,140 --> 01:00:41,510
one so we're out of time for the session

01:00:39,230 --> 01:00:44,089
I'm happy to take questions feel free to

01:00:41,510 --> 01:00:44,690
come on up but I've got to start

01:00:44,089 --> 01:00:47,740
shutting things down

01:00:44,690 --> 01:00:47,740

YouTube URL: https://www.youtube.com/watch?v=xSBWklPLRvw


