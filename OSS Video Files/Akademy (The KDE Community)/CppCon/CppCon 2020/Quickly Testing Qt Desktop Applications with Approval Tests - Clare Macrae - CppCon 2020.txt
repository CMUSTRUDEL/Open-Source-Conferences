Title: Quickly Testing Qt Desktop Applications with Approval Tests - Clare Macrae - CppCon 2020
Publication date: 2020-09-30
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/quickly_testing_qt_desktop_applications_with_approval_tests/quickly_testing_qt_desktop_applications_with_approval_tests__clare_macrae__cppcon_2020.pdf
---
You've inherited some Qt GUI code: it's valuable, but it doesn't have tests, and it wasn't designed to be testable, so you need to start refactoring. But you can't refactor safely until the code has tests, and you can't add tests without refactoring! How can you ever break out of this loop?

The talk will review the challenges and potential sources of error that are specific to code that uses the Qt cross-platform graphical user interface library, and then describe how to guard against them.

There are many options for unit-testing Qt code, including Qt Test, Google Test and Catch. As well as covering those, and general principles for applying them, I will present a small but surprisingly effective C++11 library for applying "Approval Tests" to cross-platform Qt code.

Finally, the talk will briefly cover some other tools that can aid with inspecting and maintaining Qt code, which can in turn improve testability.

Attendees will discover some quick, practical techniques to help write unit tests and integration tests for Qt code.

---
Clare has worked in software development for over 30 years, and in C++ for 20 years.

Since 2017, she has used her spare time to work remotely with Llewellyn Falco on [ApprovalTests.cpp](https://github.com/approvals/ApprovalTests.cpp), to radically simplify testing of legacy code. She has enjoyed this so much that she recently went independent, to focus even more on helper others work more easily with legacy code.

Clare was until recently a Principal Scientific Software Engineer at Cambridge Crystallographic Data Centre, which releases data and powerful software for scientific education, research, and streamlining the design and manufacture of new medicines.

From 2016 to 2018, she lead the team that replaced their 30 year old database format and Fortran code. She then returned to C++ and Qt, working on the popular 3D crystal structure visualisation program [Mercury](https://www.ccdc.cam.ac.uk/mercury/), which she was the original author of.

When not thinking about supporting teams to streamline development, testing and releases, she spends time with family and friends, and enjoys the Raspberry Pi, folk music and cinema.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,480 --> 00:00:12,320
hello i'm claire mcrae and welcome to my

00:00:10,639 --> 00:00:13,120
talk where i give you some tips and

00:00:12,320 --> 00:00:15,679
tricks

00:00:13,120 --> 00:00:18,640
to quickly and effectively test qt

00:00:15,679 --> 00:00:20,560
desktop applications

00:00:18,640 --> 00:00:23,359
my main audience for this is going to be

00:00:20,560 --> 00:00:25,359
developers who are working with qt code

00:00:23,359 --> 00:00:27,119
there are some slides throughout here

00:00:25,359 --> 00:00:27,840
that will be useful about testing in

00:00:27,119 --> 00:00:29,679
general

00:00:27,840 --> 00:00:31,519
and testing gui's in general but the

00:00:29,679 --> 00:00:33,440
main focus is qt

00:00:31,519 --> 00:00:34,640
if you'd like to know more about the

00:00:33,440 --> 00:00:37,600
approval tests

00:00:34,640 --> 00:00:39,440
mechanism and library for testing then

00:00:37,600 --> 00:00:41,120
the link at the bottom of the screen

00:00:39,440 --> 00:00:43,120
will point you to previous talks that

00:00:41,120 --> 00:00:46,879
i've given but this is

00:00:43,120 --> 00:00:48,480
the first recording of a new talk

00:00:46,879 --> 00:00:50,399
uh so a little bit about me i've been

00:00:48,480 --> 00:00:53,120
programming in c plus plus and q

00:00:50,399 --> 00:00:54,559
for more than 20 years now but my real

00:00:53,120 --> 00:00:57,120
focus my real passion

00:00:54,559 --> 00:00:58,559
is learning and sharing information

00:00:57,120 --> 00:01:02,640
about testing

00:00:58,559 --> 00:01:04,720
legacy code making it easy and effective

00:01:02,640 --> 00:01:05,760
to work with code that many people think

00:01:04,720 --> 00:01:08,159
is too hard

00:01:05,760 --> 00:01:10,240
to test and i'm the co-author of the

00:01:08,159 --> 00:01:12,960
approval test for c plus plus library

00:01:10,240 --> 00:01:14,560
along with laurel and falco

00:01:12,960 --> 00:01:17,040
last summer i set up a consulting

00:01:14,560 --> 00:01:18,560
company to help me go further in sharing

00:01:17,040 --> 00:01:20,560
this knowledge

00:01:18,560 --> 00:01:23,119
contact details are on the last slide as

00:01:20,560 --> 00:01:24,320
well there are many links and references

00:01:23,119 --> 00:01:26,479
in this talk

00:01:24,320 --> 00:01:27,439
and you can get to those online via the

00:01:26,479 --> 00:01:30,079
bitly

00:01:27,439 --> 00:01:32,400
link or the qr code and again that's at

00:01:30,079 --> 00:01:35,280
the end if you want to grab that

00:01:32,400 --> 00:01:36,560
a little bit now about this talk the

00:01:35,280 --> 00:01:39,040
first thing to say

00:01:36,560 --> 00:01:40,079
is cambridge is getting uh fibre

00:01:39,040 --> 00:01:42,399
broadband

00:01:40,079 --> 00:01:43,439
uh the bad news is my street is being

00:01:42,399 --> 00:01:45,040
done this week

00:01:43,439 --> 00:01:46,640
and there's a couple of building sites

00:01:45,040 --> 00:01:48,479
nearby so

00:01:46,640 --> 00:01:52,000
at the moment it's quiet but if there's

00:01:48,479 --> 00:01:55,200
any odd rumbling going on i apologize

00:01:52,000 --> 00:01:57,759
it's out of my control

00:01:55,200 --> 00:01:58,960
throughout the talk occasionally a slide

00:01:57,759 --> 00:02:02,240
like this will pop up

00:01:58,960 --> 00:02:04,079
any questions and i will then uh

00:02:02,240 --> 00:02:05,439
have a look at the questions that people

00:02:04,079 --> 00:02:09,360
have been asking

00:02:05,439 --> 00:02:11,280
in the q a section on remo

00:02:09,360 --> 00:02:12,959
i'll try and focus on questions that are

00:02:11,280 --> 00:02:14,239
relevant to the section that i've just

00:02:12,959 --> 00:02:16,400
talked about

00:02:14,239 --> 00:02:19,120
uh if i don't manage to answer all the

00:02:16,400 --> 00:02:21,360
questions today if you want to talk more

00:02:19,120 --> 00:02:23,280
i'll hang around in the fuzzy track in

00:02:21,360 --> 00:02:26,000
remo afterwards

00:02:23,280 --> 00:02:27,760
and i hope to say hello to you then so

00:02:26,000 --> 00:02:28,560
here's the scenario that we're working

00:02:27,760 --> 00:02:31,920
with

00:02:28,560 --> 00:02:34,000
you have inherited some legacy qt code

00:02:31,920 --> 00:02:36,080
and it's valuable you need to make some

00:02:34,000 --> 00:02:37,840
changes but it doesn't have tests and it

00:02:36,080 --> 00:02:40,000
wasn't designed for testing

00:02:37,840 --> 00:02:41,760
so you get into this vicious circle that

00:02:40,000 --> 00:02:44,640
you can't add tests because you can't

00:02:41,760 --> 00:02:47,760
safely refactor

00:02:44,640 --> 00:02:48,800
and the majority of this talk is helping

00:02:47,760 --> 00:02:51,599
you break that

00:02:48,800 --> 00:02:52,239
side of the circle but specifically for

00:02:51,599 --> 00:02:54,239
qt

00:02:52,239 --> 00:02:56,000
desktop applications you don't have any

00:02:54,239 --> 00:02:58,400
tests and the code wasn't designed for

00:02:56,000 --> 00:02:58,400
testing

00:03:00,400 --> 00:03:03,680
i'm sure many of you know that qt or

00:03:03,120 --> 00:03:07,599
cute

00:03:03,680 --> 00:03:08,879
as it is or so called uh is a massive

00:03:07,599 --> 00:03:11,519
framework

00:03:08,879 --> 00:03:13,120
for cross-platform framework for writing

00:03:11,519 --> 00:03:14,959
rich and beautiful graphical user

00:03:13,120 --> 00:03:16,480
interface applications on many different

00:03:14,959 --> 00:03:19,840
platforms

00:03:16,480 --> 00:03:20,239
i firmly believe that cute scurry powers

00:03:19,840 --> 00:03:23,120
make

00:03:20,239 --> 00:03:24,400
automated testing harder than testing

00:03:23,120 --> 00:03:26,480
non-gui code

00:03:24,400 --> 00:03:28,400
there's so much more to deal with in the

00:03:26,480 --> 00:03:30,879
way of interactions and platform

00:03:28,400 --> 00:03:32,959
differences and things like that

00:03:30,879 --> 00:03:34,560
but my goal for this talk is to give you

00:03:32,959 --> 00:03:37,360
the confidence to start

00:03:34,560 --> 00:03:40,720
testing your own qt application and

00:03:37,360 --> 00:03:40,720
doing so effectively

00:03:41,360 --> 00:03:48,159
and to that end how do you even start

00:03:44,319 --> 00:03:50,400
adding tests to an existing application

00:03:48,159 --> 00:03:51,280
well the answer is that you don't modify

00:03:50,400 --> 00:03:54,319
the main

00:03:51,280 --> 00:03:57,599
of your existing application so

00:03:54,319 --> 00:04:00,319
here's the strategy to adopt

00:03:57,599 --> 00:04:02,000
so imagine you have got your executable

00:04:00,319 --> 00:04:05,120
your program that you're testing

00:04:02,000 --> 00:04:08,560
be it a gui one or otherwise

00:04:05,120 --> 00:04:11,200
and that has a main and it has

00:04:08,560 --> 00:04:14,000
the headers and the cpp files and if

00:04:11,200 --> 00:04:16,079
it's a qc gui application created with

00:04:14,000 --> 00:04:17,680
qt designer it'll have a bunch of ui

00:04:16,079 --> 00:04:20,320
files as well

00:04:17,680 --> 00:04:24,240
and what you need to do is change your

00:04:20,320 --> 00:04:28,000
build system to divide that into two

00:04:24,240 --> 00:04:31,360
so that your gui program

00:04:28,000 --> 00:04:33,840
links the main and links

00:04:31,360 --> 00:04:35,360
in the static library which here i've

00:04:33,840 --> 00:04:37,360
called ui.lib

00:04:35,360 --> 00:04:38,960
which contains all of the other cpp

00:04:37,360 --> 00:04:42,000
files and the ui

00:04:38,960 --> 00:04:44,160
files as well and once you've created

00:04:42,000 --> 00:04:46,000
that static library you can then write a

00:04:44,160 --> 00:04:49,120
new test

00:04:46,000 --> 00:04:52,080
executable which called ui tests for

00:04:49,120 --> 00:04:53,040
lack of imagination and it will contain

00:04:52,080 --> 00:04:57,680
its own main

00:04:53,040 --> 00:05:00,160
and its own test cpp files

00:04:57,680 --> 00:05:02,639
so the ui code the majority of the code

00:05:00,160 --> 00:05:04,000
the implementation is compiled once into

00:05:02,639 --> 00:05:06,160
a static library

00:05:04,000 --> 00:05:07,440
and then two or more executables link

00:05:06,160 --> 00:05:09,039
that library

00:05:07,440 --> 00:05:11,360
if it's too hard to move everything in

00:05:09,039 --> 00:05:13,680
one go you could always just

00:05:11,360 --> 00:05:15,120
move incrementally the code that you're

00:05:13,680 --> 00:05:17,440
writing tests for

00:05:15,120 --> 00:05:18,160
and the first rule of adding test legacy

00:05:17,440 --> 00:05:20,000
code

00:05:18,160 --> 00:05:21,360
is only look at adding tests for the

00:05:20,000 --> 00:05:23,759
code that you need to change

00:05:21,360 --> 00:05:25,440
don't set out to test everything in one

00:05:23,759 --> 00:05:26,960
go you'll never get anything released if

00:05:25,440 --> 00:05:28,800
you do that

00:05:26,960 --> 00:05:30,479
i'm sometimes asked why does it have to

00:05:28,800 --> 00:05:33,520
be a static library

00:05:30,479 --> 00:05:34,400
well if it's a dynamic library on

00:05:33,520 --> 00:05:35,840
windows

00:05:34,400 --> 00:05:37,520
you'll get lots of linker errors and

00:05:35,840 --> 00:05:40,080
then you have to

00:05:37,520 --> 00:05:41,039
add lines like deck or space dll import

00:05:40,080 --> 00:05:42,880
and so on

00:05:41,039 --> 00:05:44,639
that's faff if you haven't done it

00:05:42,880 --> 00:05:46,639
before it's tedious

00:05:44,639 --> 00:05:48,560
whereas if it's a static library you

00:05:46,639 --> 00:05:49,919
don't have to change your source code on

00:05:48,560 --> 00:05:52,720
any platform

00:05:49,919 --> 00:05:53,440
you can just change your build system

00:05:52,720 --> 00:05:55,919
and then

00:05:53,440 --> 00:05:57,919
if it's an application that you release

00:05:55,919 --> 00:05:59,600
if you use dynamic libraries

00:05:57,919 --> 00:06:02,000
you'll have to change your release and

00:05:59,600 --> 00:06:04,840
distribution system to include

00:06:02,000 --> 00:06:06,400
those dynamic libraries alongside your

00:06:04,840 --> 00:06:08,639
executable

00:06:06,400 --> 00:06:10,240
whereas if you set up a static library

00:06:08,639 --> 00:06:13,039
the code still gets pulled into the

00:06:10,240 --> 00:06:16,720
executable and you don't need to change

00:06:13,039 --> 00:06:19,440
your your release

00:06:16,720 --> 00:06:20,800
process so basically static libraries

00:06:19,440 --> 00:06:21,600
are a smaller change i'm not saying

00:06:20,800 --> 00:06:23,440
don't use

00:06:21,600 --> 00:06:25,520
dynamic libraries i'm saying if you're

00:06:23,440 --> 00:06:27,759
starting from no libraries at all

00:06:25,520 --> 00:06:29,840
static libraries are the smallest

00:06:27,759 --> 00:06:31,759
incremental step

00:06:29,840 --> 00:06:33,680
and if you want to know more about that

00:06:31,759 --> 00:06:36,479
and you're using cmake

00:06:33,680 --> 00:06:39,039
then arnie metz back in 2018 wrote a

00:06:36,479 --> 00:06:42,319
lovely set of four

00:06:39,039 --> 00:06:44,479
posts explaining that transition so i

00:06:42,319 --> 00:06:46,400
recommend that

00:06:44,479 --> 00:06:48,160
i'll pause at this point and see if

00:06:46,400 --> 00:06:52,880
there are any questions

00:06:48,160 --> 00:06:57,199
and there aren't so i will move on

00:06:52,880 --> 00:07:01,039
a bit more context throughout this talk

00:06:57,199 --> 00:07:03,120
i'm talking about automated testing

00:07:01,039 --> 00:07:04,479
being done by developers so developers

00:07:03,120 --> 00:07:07,120
are writing code

00:07:04,479 --> 00:07:07,759
to test other code so you might think of

00:07:07,120 --> 00:07:11,199
it as

00:07:07,759 --> 00:07:12,960
glass box or transparent box testing

00:07:11,199 --> 00:07:14,720
so developers have access to the code

00:07:12,960 --> 00:07:16,479
and they can potentially change the code

00:07:14,720 --> 00:07:18,160
to make it easier to test and then of

00:07:16,479 --> 00:07:21,919
course add new features

00:07:18,160 --> 00:07:21,919
and add tests for the new features

00:07:22,160 --> 00:07:25,759
so how do you create your test

00:07:24,479 --> 00:07:29,039
executable

00:07:25,759 --> 00:07:31,120
you need to have a runner use

00:07:29,039 --> 00:07:32,479
a test framework that allows you to

00:07:31,120 --> 00:07:34,639
express

00:07:32,479 --> 00:07:35,919
the test that you're writing and

00:07:34,639 --> 00:07:39,039
provides the

00:07:35,919 --> 00:07:41,919
the code to to drive those tests

00:07:39,039 --> 00:07:43,280
and there are many to choose from in c

00:07:41,919 --> 00:07:45,440
plus here are

00:07:43,280 --> 00:07:47,039
four reasonably well known ones google

00:07:45,440 --> 00:07:51,440
catch two dot tests

00:07:47,039 --> 00:07:54,240
and qs itself has its own test library

00:07:51,440 --> 00:07:55,039
for this talk it's mainly going to be

00:07:54,240 --> 00:07:58,479
attached to

00:07:55,039 --> 00:08:00,639
code with a little bit of cute test code

00:07:58,479 --> 00:08:01,599
but a lot of what i'm talking about

00:08:00,639 --> 00:08:03,280
applies

00:08:01,599 --> 00:08:04,639
regardless of the test framework that

00:08:03,280 --> 00:08:06,400
you're using so

00:08:04,639 --> 00:08:08,879
don't worry if you're not using catch

00:08:06,400 --> 00:08:13,840
there will still be

00:08:08,879 --> 00:08:13,840
plenty to take advantage of in the talk

00:08:14,160 --> 00:08:18,240
so let's start by writing a main so the

00:08:17,280 --> 00:08:22,639
catch 2

00:08:18,240 --> 00:08:25,759
can drive our testing of qt acute code

00:08:22,639 --> 00:08:27,759
we need to use hash define

00:08:25,759 --> 00:08:29,120
catch config runner you may be used to

00:08:27,759 --> 00:08:30,560
catch config main

00:08:29,120 --> 00:08:33,120
this is different because we're

00:08:30,560 --> 00:08:34,800
providing our own main function

00:08:33,120 --> 00:08:36,959
we need to tell catch that we're going

00:08:34,800 --> 00:08:38,080
to do that so we say we define catch

00:08:36,959 --> 00:08:39,919
config runner

00:08:38,080 --> 00:08:41,680
and then of course we include the catch

00:08:39,919 --> 00:08:44,880
header

00:08:41,680 --> 00:08:48,880
now we also need to

00:08:44,880 --> 00:08:52,800
have an app a cue application object

00:08:48,880 --> 00:08:53,519
um you uh if you don't know the reason

00:08:52,800 --> 00:08:55,600
for this

00:08:53,519 --> 00:08:56,720
is if you try and create cute widgets

00:08:55,600 --> 00:08:58,959
and there isn't

00:08:56,720 --> 00:09:00,560
a q application object in existence the

00:08:58,959 --> 00:09:01,680
code will just crash it won't run you'll

00:09:00,560 --> 00:09:03,839
get it

00:09:01,680 --> 00:09:06,480
so rather than making each individual

00:09:03,839 --> 00:09:08,560
test case create its own application

00:09:06,480 --> 00:09:09,920
we create an application once in the

00:09:08,560 --> 00:09:12,399
main

00:09:09,920 --> 00:09:14,480
and we pass in the command line

00:09:12,399 --> 00:09:15,040
arguments to it so we can pass in things

00:09:14,480 --> 00:09:18,480
like

00:09:15,040 --> 00:09:20,880
minus platform off screen um so we can

00:09:18,480 --> 00:09:22,399
queue application qt has lots of

00:09:20,880 --> 00:09:24,480
standard supported command line

00:09:22,399 --> 00:09:27,519
arguments and we can use those

00:09:24,480 --> 00:09:28,640
and then we create the catch session and

00:09:27,519 --> 00:09:30,399
we tell it to run

00:09:28,640 --> 00:09:32,480
and again we pass in the command line

00:09:30,399 --> 00:09:34,720
arguments that program was given

00:09:32,480 --> 00:09:36,800
so we can use for example minus minus

00:09:34,720 --> 00:09:38,320
break to stop in the debugger if we get

00:09:36,800 --> 00:09:40,720
a test suite failure

00:09:38,320 --> 00:09:41,440
then the session runs and we return the

00:09:40,720 --> 00:09:44,320
result

00:09:41,440 --> 00:09:46,880
so it's a bunch of slightly one hard one

00:09:44,320 --> 00:09:49,279
boilerplate code but it works

00:09:46,880 --> 00:09:51,040
and from that point we can write catch

00:09:49,279 --> 00:09:54,399
tests

00:09:51,040 --> 00:09:56,160
and call cube code and so in order to

00:09:54,399 --> 00:09:58,160
have some examples

00:09:56,160 --> 00:09:59,360
um i reached out online and the

00:09:58,160 --> 00:10:01,760
wonderfully

00:09:59,360 --> 00:10:02,720
kind and friendly super super collider

00:10:01,760 --> 00:10:05,040
community

00:10:02,720 --> 00:10:07,120
got back in touch with me super collider

00:10:05,040 --> 00:10:10,560
is a platform for

00:10:07,120 --> 00:10:14,640
um programmatically

00:10:10,560 --> 00:10:18,160
synthesizing sounds and composing music

00:10:14,640 --> 00:10:21,279
with albums it's a lovely program it's

00:10:18,160 --> 00:10:23,360
part of how sonic pi on the raspberry pi

00:10:21,279 --> 00:10:24,800
is implemented if you've seen that

00:10:23,360 --> 00:10:26,640
and it has its own integrated

00:10:24,800 --> 00:10:29,519
development environment ide

00:10:26,640 --> 00:10:30,399
and that's what it looks like so i'm

00:10:29,519 --> 00:10:33,760
going to start

00:10:30,399 --> 00:10:35,279
testing a tiny tiny component of the

00:10:33,760 --> 00:10:38,000
super collider code

00:10:35,279 --> 00:10:39,279
that's this little red square so we

00:10:38,000 --> 00:10:41,440
always want to start with something

00:10:39,279 --> 00:10:44,560
small to start testing

00:10:41,440 --> 00:10:45,760
and that's called a color widget it's a

00:10:44,560 --> 00:10:47,760
color picker

00:10:45,760 --> 00:10:49,279
in the super collider source code and

00:10:47,760 --> 00:10:51,519
the user clicks on

00:10:49,279 --> 00:10:52,399
a little square like that a color dialog

00:10:51,519 --> 00:10:54,240
pops up

00:10:52,399 --> 00:10:55,680
the user chooses new color and then

00:10:54,240 --> 00:10:59,120
clicks okay

00:10:55,680 --> 00:10:59,120
and then eventually

00:10:59,519 --> 00:11:04,320
the red square will change to green to

00:11:02,320 --> 00:11:05,760
indicate the new color very quickly that

00:11:04,320 --> 00:11:09,120
change will happen

00:11:05,760 --> 00:11:10,000
um so that's what we're going to test

00:11:09,120 --> 00:11:13,600
that little

00:11:10,000 --> 00:11:15,920
square it's really important to say that

00:11:13,600 --> 00:11:17,040
you want to be focusing on testing the

00:11:15,920 --> 00:11:19,839
code that you

00:11:17,040 --> 00:11:21,600
control you maintain so on the left is

00:11:19,839 --> 00:11:24,160
widgets in the application like

00:11:21,600 --> 00:11:24,880
the the application we're testing on the

00:11:24,160 --> 00:11:29,839
right

00:11:24,880 --> 00:11:31,760
is qt code and perhaps the odd

00:11:29,839 --> 00:11:34,160
dialogue provided by the operating

00:11:31,760 --> 00:11:35,920
system it'd be a waste of our time to

00:11:34,160 --> 00:11:37,600
test that and we wouldn't be able to fix

00:11:35,920 --> 00:11:39,760
any problems that we found

00:11:37,600 --> 00:11:41,279
so we're going to focus on testing code

00:11:39,760 --> 00:11:43,120
on the left

00:11:41,279 --> 00:11:44,959
so here's our first test so we have a

00:11:43,120 --> 00:11:47,120
catch to test case

00:11:44,959 --> 00:11:48,959
we give it a name we create a color

00:11:47,120 --> 00:11:51,600
widget object

00:11:48,959 --> 00:11:53,040
and what i'm doing in this test is just

00:11:51,600 --> 00:11:55,839
exploring

00:11:53,040 --> 00:11:57,760
can i create an object can i see what

00:11:55,839 --> 00:11:59,920
its default state is

00:11:57,760 --> 00:12:01,200
and it turns out that its default state

00:11:59,920 --> 00:12:04,959
is black

00:12:01,200 --> 00:12:09,120
and opaque so that 255 means opaque

00:12:04,959 --> 00:12:12,000
and so you see at the top corner this

00:12:09,120 --> 00:12:12,880
black square indicating that i'm testing

00:12:12,000 --> 00:12:14,639
a black

00:12:12,880 --> 00:12:16,560
widget at the moment so throughout these

00:12:14,639 --> 00:12:18,560
slides i try and give some kind of

00:12:16,560 --> 00:12:18,800
reminder some kind of position of where

00:12:18,560 --> 00:12:20,720
i

00:12:18,800 --> 00:12:22,399
am with pictures at the top right hand

00:12:20,720 --> 00:12:25,279
corner

00:12:22,399 --> 00:12:27,360
and then we use catch's check to check

00:12:25,279 --> 00:12:30,399
that the color of the widget

00:12:27,360 --> 00:12:33,680
is the black expected color that we that

00:12:30,399 --> 00:12:34,720
um expected now at this point i have to

00:12:33,680 --> 00:12:36,480
confess that

00:12:34,720 --> 00:12:38,639
it took me a while to get that test to

00:12:36,480 --> 00:12:41,360
pass because i first wrote

00:12:38,639 --> 00:12:43,440
expected color is zero zero zero zero

00:12:41,360 --> 00:12:46,000
which turns out to be opaque

00:12:43,440 --> 00:12:48,000
and you might know that catch writes out

00:12:46,000 --> 00:12:48,639
really helpful information when a test

00:12:48,000 --> 00:12:50,399
fails

00:12:48,639 --> 00:12:52,959
but it didn't know how to write out a

00:12:50,399 --> 00:12:56,079
cue color so it wrote out question mark

00:12:52,959 --> 00:12:57,760
is not equal to question mark it took me

00:12:56,079 --> 00:13:00,800
a while to work out that

00:12:57,760 --> 00:13:03,600
it was the opacity that was wrong

00:13:00,800 --> 00:13:04,639
so then i wrote a little bit of code to

00:13:03,600 --> 00:13:07,440
teach

00:13:04,639 --> 00:13:08,880
catch how to write a string

00:13:07,440 --> 00:13:12,000
representation

00:13:08,880 --> 00:13:14,560
of a cue color object so catch

00:13:12,000 --> 00:13:16,880
string maker it's well documented you

00:13:14,560 --> 00:13:19,440
can add

00:13:16,880 --> 00:13:21,440
versions of it for your particular types

00:13:19,440 --> 00:13:23,839
of object in your test

00:13:21,440 --> 00:13:24,480
and then i wrote check that the colour

00:13:23,839 --> 00:13:26,079
is

00:13:24,480 --> 00:13:28,880
and that's more expressive than the

00:13:26,079 --> 00:13:31,120
magic numbers in the previous test

00:13:28,880 --> 00:13:32,399
and in fact when i first wrote that i

00:13:31,120 --> 00:13:34,720
wrote

00:13:32,399 --> 00:13:35,920
a test which i knew was going to fail

00:13:34,720 --> 00:13:38,079
check that the

00:13:35,920 --> 00:13:40,240
string representation of the color is an

00:13:38,079 --> 00:13:42,240
empty string

00:13:40,240 --> 00:13:44,800
and laurel and falco and emily bates

00:13:42,240 --> 00:13:46,720
call this approval testing

00:13:44,800 --> 00:13:48,000
the idea that you start when you're

00:13:46,720 --> 00:13:50,160
exploring functionality

00:13:48,000 --> 00:13:52,160
and trying to work out what's going on

00:13:50,160 --> 00:13:55,279
get familiar with the code base

00:13:52,160 --> 00:13:55,760
you you write a test uh sort of poke the

00:13:55,279 --> 00:13:58,480
code

00:13:55,760 --> 00:14:00,160
write a test see what answer you get and

00:13:58,480 --> 00:14:02,560
then if you like it you paste it into

00:14:00,160 --> 00:14:04,240
the source code

00:14:02,560 --> 00:14:07,680
so now let's look at actually changing

00:14:04,240 --> 00:14:07,680
the state of the widget

00:14:07,920 --> 00:14:14,240
so i am now going to simulate

00:14:11,680 --> 00:14:15,519
the user clicking and changing the color

00:14:14,240 --> 00:14:17,120
to red

00:14:15,519 --> 00:14:19,120
but i'm going to do it by calling the

00:14:17,120 --> 00:14:19,920
set color method rather than going

00:14:19,120 --> 00:14:23,519
through

00:14:19,920 --> 00:14:24,959
the dialog color dialog

00:14:23,519 --> 00:14:26,880
and that's because i'm wanting to write

00:14:24,959 --> 00:14:28,720
localized code and i've looked at the

00:14:26,880 --> 00:14:31,040
interface of color widget

00:14:28,720 --> 00:14:33,600
and it has a set color method so it's

00:14:31,040 --> 00:14:36,160
reasonable to expect that that's how

00:14:33,600 --> 00:14:38,320
the um the user's request for a

00:14:36,160 --> 00:14:41,120
different color would be implemented

00:14:38,320 --> 00:14:41,839
so i've done the arrange i've set up the

00:14:41,120 --> 00:14:44,320
widgets

00:14:41,839 --> 00:14:46,800
now i'm acting then i'm going to assert

00:14:44,320 --> 00:14:49,600
that the color has changed to red

00:14:46,800 --> 00:14:50,560
it's a tiny tiny test but it's part of

00:14:49,600 --> 00:14:54,480
it's getting

00:14:50,560 --> 00:14:56,720
to know the library and exploring it and

00:14:54,480 --> 00:14:59,120
where tests are useful saving them along

00:14:56,720 --> 00:15:00,160
the way now you would be forgiven for

00:14:59,120 --> 00:15:03,199
thinking

00:15:00,160 --> 00:15:05,680
quickly testing that hasn't been quick

00:15:03,199 --> 00:15:07,440
we had to write the main and then

00:15:05,680 --> 00:15:08,000
explore and write some first tests and

00:15:07,440 --> 00:15:11,519
that's

00:15:08,000 --> 00:15:14,720
normal writing the first test

00:15:11,519 --> 00:15:15,839
is always the hardest part and then

00:15:14,720 --> 00:15:17,760
you'll find once you've got the first

00:15:15,839 --> 00:15:19,839
test it becomes easier and easier to add

00:15:17,760 --> 00:15:22,079
a second and third and so on

00:15:19,839 --> 00:15:24,000
so what that means is if you're writing

00:15:22,079 --> 00:15:26,560
your first ever test

00:15:24,000 --> 00:15:28,399
in a particular environment or framework

00:15:26,560 --> 00:15:30,399
it's really important

00:15:28,399 --> 00:15:32,240
that you make the first test as easy as

00:15:30,399 --> 00:15:33,279
possible because it is going to be hard

00:15:32,240 --> 00:15:35,680
anyway

00:15:33,279 --> 00:15:36,959
and then if it was hard write a few more

00:15:35,680 --> 00:15:38,720
tests before

00:15:36,959 --> 00:15:40,880
deciding whether it's a good idea to

00:15:38,720 --> 00:15:43,279
carry on so i'm going to pause

00:15:40,880 --> 00:15:44,079
again and see if there's any questions

00:15:43,279 --> 00:15:47,759
and there aren't

00:15:44,079 --> 00:15:49,680
so i will move on again so this is my

00:15:47,759 --> 00:15:51,279
second super collider example

00:15:49,680 --> 00:15:53,040
and we're moving on to something a bit

00:15:51,279 --> 00:15:56,639
more complicated now

00:15:53,040 --> 00:15:58,880
and then the super collider ide

00:15:56,639 --> 00:16:00,720
you see some super collider language

00:15:58,880 --> 00:16:03,199
code and then at the bottom there's what

00:16:00,720 --> 00:16:06,480
it calls the go to line panel

00:16:03,199 --> 00:16:08,800
and you can type a number

00:16:06,480 --> 00:16:10,399
into the box there or click on the up

00:16:08,800 --> 00:16:11,920
down arrows in the spin i think in

00:16:10,399 --> 00:16:12,800
practice people would always type a

00:16:11,920 --> 00:16:15,839
number in

00:16:12,800 --> 00:16:17,440
and then click on the go button and the

00:16:15,839 --> 00:16:20,079
your cursor should move to a different

00:16:17,440 --> 00:16:20,399
location and so the go to line panel was

00:16:20,079 --> 00:16:22,000
a

00:16:20,399 --> 00:16:25,680
another small chunk of code that i could

00:16:22,000 --> 00:16:28,560
look at to start experimenting with

00:16:25,680 --> 00:16:29,440
so i'm going to demo some basic code to

00:16:28,560 --> 00:16:30,800
test this

00:16:29,440 --> 00:16:32,560
i'm going to show you three different

00:16:30,800 --> 00:16:34,560
versions and

00:16:32,560 --> 00:16:36,639
especially in the first version there's

00:16:34,560 --> 00:16:38,160
a lot of detail because i want to show

00:16:36,639 --> 00:16:39,759
you the sort of thing is needed

00:16:38,160 --> 00:16:42,320
and then later on i'll show you how to

00:16:39,759 --> 00:16:43,279
avoid it but in each case i'll go

00:16:42,320 --> 00:16:45,839
through the arrange

00:16:43,279 --> 00:16:47,519
act and assert steps and you'll see in

00:16:45,839 --> 00:16:49,680
the first version what a huge amount of

00:16:47,519 --> 00:16:53,759
arranged code is required

00:16:49,680 --> 00:16:56,320
to get tested so

00:16:53,759 --> 00:16:57,600
we start with our first arrange slide

00:16:56,320 --> 00:17:00,480
and what we're testing

00:16:57,600 --> 00:17:02,839
is that the go to line tool emits a

00:17:00,480 --> 00:17:06,079
particular signal when the go button is

00:17:02,839 --> 00:17:06,079
clicked and

00:17:07,120 --> 00:17:11,679
so we start by creating a go to line

00:17:10,400 --> 00:17:14,160
tool widget

00:17:11,679 --> 00:17:14,959
and then we have to call raise and show

00:17:14,160 --> 00:17:17,600
to make the

00:17:14,959 --> 00:17:18,000
widget visible and then for this test

00:17:17,600 --> 00:17:20,160
we're going

00:17:18,000 --> 00:17:23,439
to say pretend we're editing a document

00:17:20,160 --> 00:17:26,079
which has got 27 lines in it

00:17:23,439 --> 00:17:26,799
now in the main application the document

00:17:26,079 --> 00:17:27,919
model

00:17:26,799 --> 00:17:30,400
something like that would take care of

00:17:27,919 --> 00:17:32,400
this but we don't want to set up

00:17:30,400 --> 00:17:34,080
all of that associated code we want to

00:17:32,400 --> 00:17:35,600
be doing whatever we need to

00:17:34,080 --> 00:17:37,760
to be able to test this widget in

00:17:35,600 --> 00:17:39,919
isolation

00:17:37,760 --> 00:17:41,120
some of these things the raise and the

00:17:39,919 --> 00:17:43,679
show

00:17:41,120 --> 00:17:45,200
the cute test framework takes care of

00:17:43,679 --> 00:17:47,039
but because we're driving this with

00:17:45,200 --> 00:17:48,240
catch which is a rather more expressive

00:17:47,039 --> 00:17:50,080
test framework

00:17:48,240 --> 00:17:52,000
trade-off is we get to have to do some

00:17:50,080 --> 00:17:55,840
more homework ourselves

00:17:52,000 --> 00:17:59,520
and then we set the focus so that any

00:17:55,840 --> 00:18:03,120
actions we trigger definitely go to this

00:17:59,520 --> 00:18:06,559
widget rather than whatever else is

00:18:03,120 --> 00:18:11,600
visible on the screen at the time and

00:18:06,559 --> 00:18:13,919
so our tests in our tests we want to

00:18:11,600 --> 00:18:15,520
do things to the spin box and then we

00:18:13,919 --> 00:18:18,240
want to click on the go

00:18:15,520 --> 00:18:19,919
button and those widgets are private in

00:18:18,240 --> 00:18:21,919
the source code

00:18:19,919 --> 00:18:24,320
and in this first test i'm going to not

00:18:21,919 --> 00:18:26,160
change the library that we're testing

00:18:24,320 --> 00:18:28,640
and that means we need another way to

00:18:26,160 --> 00:18:32,559
get hold of these widgets to test

00:18:28,640 --> 00:18:34,799
and qt has cutie widgets have

00:18:32,559 --> 00:18:36,799
find child to say with insight within

00:18:34,799 --> 00:18:37,760
this dialogue or custom widget or

00:18:36,799 --> 00:18:40,720
whatever

00:18:37,760 --> 00:18:42,000
find me the first object of this type so

00:18:40,720 --> 00:18:45,440
we're saying get a spin

00:18:42,000 --> 00:18:47,039
box find the first spin box in our go to

00:18:45,440 --> 00:18:49,200
line tool widget

00:18:47,039 --> 00:18:51,039
and then because this is a fragile thing

00:18:49,200 --> 00:18:52,799
to do

00:18:51,039 --> 00:18:55,039
because the code may change in future

00:18:52,799 --> 00:18:57,600
and no longer have a spin box

00:18:55,039 --> 00:18:58,080
we require that the value we get back is

00:18:57,600 --> 00:19:01,360
not

00:18:58,080 --> 00:19:04,799
null um a catch will halt

00:19:01,360 --> 00:19:07,200
this test whenever we require fails

00:19:04,799 --> 00:19:09,520
so yeah huge collapsing should be going

00:19:07,200 --> 00:19:11,360
off fine child is really it's a fragile

00:19:09,520 --> 00:19:13,440
thing to do you're peeking inside the

00:19:11,360 --> 00:19:15,120
implementation of a class

00:19:13,440 --> 00:19:17,360
especially don't do it in production

00:19:15,120 --> 00:19:18,880
code but it's what we have available to

00:19:17,360 --> 00:19:20,960
us for now

00:19:18,880 --> 00:19:23,919
and it's more important to write a test

00:19:20,960 --> 00:19:24,320
and worry about the code being perfect

00:19:23,919 --> 00:19:26,320
so

00:19:24,320 --> 00:19:28,559
what we're going to test is we're going

00:19:26,320 --> 00:19:29,760
to simulate the user typing a one and

00:19:28,559 --> 00:19:32,799
then a seven

00:19:29,760 --> 00:19:36,160
into the spinner text box

00:19:32,799 --> 00:19:36,960
and then clicking on go and then what

00:19:36,160 --> 00:19:40,000
should happen

00:19:36,960 --> 00:19:43,200
is that that custom widgets should emit

00:19:40,000 --> 00:19:46,160
the signal activated and say that

00:19:43,200 --> 00:19:47,600
um it's it's requesting a change for

00:19:46,160 --> 00:19:50,799
anyone else who's listening

00:19:47,600 --> 00:19:53,280
and the value is 17.

00:19:50,799 --> 00:19:55,120
i there isn't time to go into signals

00:19:53,280 --> 00:19:57,039
and slots in any details but

00:19:55,120 --> 00:19:59,600
a very simple explanation you can think

00:19:57,039 --> 00:20:02,240
of um

00:19:59,600 --> 00:20:03,120
i have got those completely the wrong

00:20:02,240 --> 00:20:05,440
way around

00:20:03,120 --> 00:20:07,120
acute signal is the special method for

00:20:05,440 --> 00:20:09,520
announcing changes

00:20:07,120 --> 00:20:11,360
and acute slot is a special method for

00:20:09,520 --> 00:20:14,000
responding to changes

00:20:11,360 --> 00:20:16,000
and you connect those together and

00:20:14,000 --> 00:20:19,039
that's a really important part

00:20:16,000 --> 00:20:20,000
of how cute allows separability and

00:20:19,039 --> 00:20:23,360
reusability

00:20:20,000 --> 00:20:27,520
of code so in the

00:20:23,360 --> 00:20:30,080
ide what would happen when the signal

00:20:27,520 --> 00:20:31,760
was emitted is that the cursor would

00:20:30,080 --> 00:20:34,080
jump to line 17.

00:20:31,760 --> 00:20:35,679
in our test we don't want to have to set

00:20:34,080 --> 00:20:39,120
up all of that code

00:20:35,679 --> 00:20:42,320
so instead we're going to use qt testing

00:20:39,120 --> 00:20:42,880
capability called q signal spy to listen

00:20:42,320 --> 00:20:46,320
out

00:20:42,880 --> 00:20:47,280
for signals so we have more arranging

00:20:46,320 --> 00:20:50,400
code

00:20:47,280 --> 00:20:52,240
we're creating a q signal spy

00:20:50,400 --> 00:20:54,240
we're calling activated spy because

00:20:52,240 --> 00:20:55,440
that's the signal that it's listening

00:20:54,240 --> 00:20:57,520
out for

00:20:55,440 --> 00:20:59,600
um we're passing in the widget and the

00:20:57,520 --> 00:21:01,600
pointer to the member function

00:20:59,600 --> 00:21:02,960
that is the signal that we want to

00:21:01,600 --> 00:21:06,240
listen out for

00:21:02,960 --> 00:21:08,640
if you're using and and we have to here

00:21:06,240 --> 00:21:11,679
it's strongly documented

00:21:08,640 --> 00:21:14,000
uh that you should after creating a spy

00:21:11,679 --> 00:21:16,960
you should check that it's valid

00:21:14,000 --> 00:21:18,320
um so that you don't get tests silently

00:21:16,960 --> 00:21:20,480
passing

00:21:18,320 --> 00:21:22,240
um through the code not being set up

00:21:20,480 --> 00:21:25,760
correctly in the test

00:21:22,240 --> 00:21:27,840
if you're using q4 you

00:21:25,760 --> 00:21:29,679
might be familiar with the old style

00:21:27,840 --> 00:21:32,400
macro based connections and that's what

00:21:29,679 --> 00:21:32,400
that would look like

00:21:33,280 --> 00:21:36,720
so this would now so we've now got onto

00:21:35,919 --> 00:21:40,080
the act

00:21:36,720 --> 00:21:41,679
stage so um q test

00:21:40,080 --> 00:21:43,440
has some helpful functions for

00:21:41,679 --> 00:21:45,600
generating

00:21:43,440 --> 00:21:46,720
events during testing so the user is

00:21:45,600 --> 00:21:49,360
going to click one

00:21:46,720 --> 00:21:51,120
in spinner and then seven or our

00:21:49,360 --> 00:21:53,840
simulated user

00:21:51,120 --> 00:21:56,799
and then click on the go button and

00:21:53,840 --> 00:22:00,480
finally we get to our assert

00:21:56,799 --> 00:22:03,440
so we're going to require that the

00:22:00,480 --> 00:22:05,200
activated signal was emitted once and

00:22:03,440 --> 00:22:08,480
once only

00:22:05,200 --> 00:22:10,640
so a common cause of errors is in acute

00:22:08,480 --> 00:22:13,360
code is signals being

00:22:10,640 --> 00:22:15,840
not emitted or emitted too many times so

00:22:13,360 --> 00:22:17,840
we're checking it's only emitted once

00:22:15,840 --> 00:22:19,280
so this is this would be a valuable test

00:22:17,840 --> 00:22:22,320
to keep

00:22:19,280 --> 00:22:23,360
and then we want to test that the value

00:22:22,320 --> 00:22:26,480
in the signal

00:22:23,360 --> 00:22:28,880
was 17 i'm not going to go through that

00:22:26,480 --> 00:22:32,000
boilerplate code in practice you would

00:22:28,880 --> 00:22:35,360
hide it behind a helper function

00:22:32,000 --> 00:22:37,039
so as a quick reminder of version one

00:22:35,360 --> 00:22:38,720
the class that we're testing is go to

00:22:37,039 --> 00:22:42,320
line tool it's got

00:22:38,720 --> 00:22:43,360
private widgets inside and we're writing

00:22:42,320 --> 00:22:46,720
a test catch to

00:22:43,360 --> 00:22:51,120
test case that has to peek inside called

00:22:46,720 --> 00:22:51,120
find child to test those widgets

00:22:52,400 --> 00:22:55,840
this is painful you want your tests to

00:22:55,360 --> 00:22:59,280
be

00:22:55,840 --> 00:23:01,120
super easy to write you don't want um

00:22:59,280 --> 00:23:04,080
you don't want tests to be hard to write

00:23:01,120 --> 00:23:05,600
and it's important that they are it's

00:23:04,080 --> 00:23:06,720
obvious to anyone reading them what's

00:23:05,600 --> 00:23:10,240
going on and find

00:23:06,720 --> 00:23:11,039
child is fragile it's prone to future

00:23:10,240 --> 00:23:12,720
breakage

00:23:11,039 --> 00:23:14,720
and if you get it wrong you don't get a

00:23:12,720 --> 00:23:18,000
compiled time failure

00:23:14,720 --> 00:23:22,080
a small improvement though is

00:23:18,000 --> 00:23:24,080
um to use find child and supply it an

00:23:22,080 --> 00:23:25,360
interface type rather than a concrete

00:23:24,080 --> 00:23:28,400
button type so

00:23:25,360 --> 00:23:30,720
if i'd searched for q abstract button

00:23:28,400 --> 00:23:32,400
then in future somebody changed from

00:23:30,720 --> 00:23:34,720
using cue tool button

00:23:32,400 --> 00:23:35,440
to one of the other button classes in

00:23:34,720 --> 00:23:37,600
cube

00:23:35,440 --> 00:23:39,919
queue abstract button would would still

00:23:37,600 --> 00:23:41,279
find the widget we wanted so you can

00:23:39,919 --> 00:23:44,480
make the code a bit safer

00:23:41,279 --> 00:23:46,240
but try not to use find child so what

00:23:44,480 --> 00:23:47,919
could we do so the first row

00:23:46,240 --> 00:23:50,080
in this table represents what you've

00:23:47,919 --> 00:23:52,880
just seen and the next row

00:23:50,080 --> 00:23:54,000
is an alternative we could add a public

00:23:52,880 --> 00:23:57,679
accessor

00:23:54,000 --> 00:23:59,440
to our go to line tool class

00:23:57,679 --> 00:24:02,159
for each of the widgets that we want to

00:23:59,440 --> 00:24:05,200
test and that's a bit smelly it's

00:24:02,159 --> 00:24:08,000
exposing internals within the code and

00:24:05,200 --> 00:24:11,200
it perhaps encourages misuse

00:24:08,000 --> 00:24:11,200
by other developers

00:24:11,679 --> 00:24:15,840
but yeah it's a possibility so here we

00:24:15,360 --> 00:24:19,279
have

00:24:15,840 --> 00:24:21,039
added public methods to go to line tool

00:24:19,279 --> 00:24:22,320
to access the widgets we need for

00:24:21,039 --> 00:24:24,640
testing

00:24:22,320 --> 00:24:27,039
you could change all the functions

00:24:24,640 --> 00:24:28,880
spinbox only used for testing and that

00:24:27,039 --> 00:24:31,039
might make it a bit less likely it would

00:24:28,880 --> 00:24:33,600
get reused

00:24:31,039 --> 00:24:36,000
and now it's our test code is a bit

00:24:33,600 --> 00:24:36,000
cleaner

00:24:36,400 --> 00:24:41,279
but it would be really nice if we could

00:24:38,480 --> 00:24:46,159
hide the implementation details

00:24:41,279 --> 00:24:47,600
in even better um and make our tests uh

00:24:46,159 --> 00:24:50,640
more general

00:24:47,600 --> 00:24:53,440
more readable and try to guard against

00:24:50,640 --> 00:24:55,919
changes in the implementation of the

00:24:53,440 --> 00:24:58,720
code that we're testing

00:24:55,919 --> 00:25:00,720
and for this i'm introducing an

00:24:58,720 --> 00:25:03,600
intermediate class

00:25:00,720 --> 00:25:04,960
commonly known as a fixture so i've

00:25:03,600 --> 00:25:07,039
called it go to line tool

00:25:04,960 --> 00:25:09,840
fixture maybe test fixture if i got more

00:25:07,039 --> 00:25:13,039
space might be a better name

00:25:09,840 --> 00:25:16,080
and it contains a private

00:25:13,039 --> 00:25:18,240
instance of the thing that we're testing

00:25:16,080 --> 00:25:19,600
and then it has public methods that are

00:25:18,240 --> 00:25:23,200
expressed

00:25:19,600 --> 00:25:25,200
in the vocabulary that

00:25:23,200 --> 00:25:26,640
expresses what we're trying to do in

00:25:25,200 --> 00:25:28,640
testing so we're

00:25:26,640 --> 00:25:31,120
simulating typing a character or

00:25:28,640 --> 00:25:35,039
clicking a button that kind of thing

00:25:31,120 --> 00:25:37,520
so only the test fixture knows about

00:25:35,039 --> 00:25:38,400
the details of the class being tested

00:25:37,520 --> 00:25:40,240
and then

00:25:38,400 --> 00:25:41,600
you can have lots and lots of different

00:25:40,240 --> 00:25:44,880
tests

00:25:41,600 --> 00:25:47,360
written using that fixture and

00:25:44,880 --> 00:25:48,080
catch use in catch you say test case

00:25:47,360 --> 00:25:50,400
method

00:25:48,080 --> 00:25:52,559
and give a class name to use that class

00:25:50,400 --> 00:25:55,760
as the test fixture

00:25:52,559 --> 00:25:56,480
and then you write your tests in terms

00:25:55,760 --> 00:25:58,880
of

00:25:56,480 --> 00:26:00,640
that expressive vocabulary the

00:25:58,880 --> 00:26:01,679
expressive methods you've provided in

00:26:00,640 --> 00:26:05,279
the test fixture

00:26:01,679 --> 00:26:07,360
and that's really lovely so inside the

00:26:05,279 --> 00:26:10,960
fixture we can hide away

00:26:07,360 --> 00:26:14,000
a lot of the details so we've got a

00:26:10,960 --> 00:26:16,799
private widget that we're testing

00:26:14,000 --> 00:26:18,480
managing the lifetime of the spy is a

00:26:16,799 --> 00:26:19,039
little bit harder because it can't be

00:26:18,480 --> 00:26:20,799
created

00:26:19,039 --> 00:26:22,400
until the widget has been created but

00:26:20,799 --> 00:26:24,400
that's all in the way

00:26:22,400 --> 00:26:26,559
and then you can also hide away some of

00:26:24,400 --> 00:26:27,600
the annoyances like raise and show and

00:26:26,559 --> 00:26:31,360
things

00:26:27,600 --> 00:26:33,200
take care of those inside the fixture

00:26:31,360 --> 00:26:35,200
those are private that's really

00:26:33,200 --> 00:26:36,880
important to hide the details

00:26:35,200 --> 00:26:38,559
when i first wrote this they were public

00:26:36,880 --> 00:26:40,720
to start with and then i worked towards

00:26:38,559 --> 00:26:41,840
making them private so i could introduce

00:26:40,720 --> 00:26:46,559
the fixture

00:26:41,840 --> 00:26:48,960
gradually catch uses inheritance

00:26:46,559 --> 00:26:50,480
to with fixtures so when you write test

00:26:48,960 --> 00:26:52,799
case method

00:26:50,480 --> 00:26:54,240
and give it a fixture name that

00:26:52,799 --> 00:26:57,120
generates

00:26:54,240 --> 00:26:58,159
a class so test case method generates

00:26:57,120 --> 00:27:01,279
some

00:26:58,159 --> 00:27:02,880
um long task name you never need to

00:27:01,279 --> 00:27:06,000
worry that inherits

00:27:02,880 --> 00:27:08,159
from the fixture um

00:27:06,000 --> 00:27:09,679
code so all the public and protected

00:27:08,159 --> 00:27:12,960
methods in the fixture

00:27:09,679 --> 00:27:16,080
you just call uh within your test code

00:27:12,960 --> 00:27:18,159
and so this is what that test code the

00:27:16,080 --> 00:27:20,799
many screen for so many slides that i

00:27:18,159 --> 00:27:21,840
showed you previously this is version

00:27:20,799 --> 00:27:23,760
three this

00:27:21,840 --> 00:27:26,320
this is what we've ended up with so

00:27:23,760 --> 00:27:28,399
we've got we're using a fixture

00:27:26,320 --> 00:27:30,559
we've given it a sensible name the test

00:27:28,399 --> 00:27:32,320
go to line tool emit signal when the go

00:27:30,559 --> 00:27:35,440
button is clicked

00:27:32,320 --> 00:27:37,039
we only have to set the maximum line

00:27:35,440 --> 00:27:39,200
count

00:27:37,039 --> 00:27:41,360
type a character one type of character

00:27:39,200 --> 00:27:43,440
seven click the go button

00:27:41,360 --> 00:27:47,360
check that the signal was emitted once

00:27:43,440 --> 00:27:50,720
and that it contains the value 17

00:27:47,360 --> 00:27:52,080
and i think that shows how it's possible

00:27:50,720 --> 00:27:55,520
to write

00:27:52,080 --> 00:27:57,360
expressive maintainable tests and

00:27:55,520 --> 00:27:58,559
maybe you want to add another test which

00:27:57,360 --> 00:28:01,840
says what happens

00:27:58,559 --> 00:28:03,360
if somebody types a number that's larger

00:28:01,840 --> 00:28:04,880
than the maximum line count you can

00:28:03,360 --> 00:28:07,919
start to explore

00:28:04,880 --> 00:28:10,159
the behavior so that's the sort of thing

00:28:07,919 --> 00:28:12,640
that i try to aspire to

00:28:10,159 --> 00:28:15,279
uh when writing tests and fixtures make

00:28:12,640 --> 00:28:18,159
that really easy

00:28:15,279 --> 00:28:18,640
i'm going to gloss over the detail of

00:28:18,159 --> 00:28:20,960
how

00:28:18,640 --> 00:28:22,799
the fixture because the fixture still

00:28:20,960 --> 00:28:25,840
needs to access

00:28:22,799 --> 00:28:27,039
the widgets inside the class that we're

00:28:25,840 --> 00:28:29,360
testing

00:28:27,039 --> 00:28:31,520
we could keep the public accessor we

00:28:29,360 --> 00:28:32,960
could make a protected accessor and use

00:28:31,520 --> 00:28:35,360
inheritance

00:28:32,960 --> 00:28:36,399
where the fixture inherits the thing

00:28:35,360 --> 00:28:39,520
we're testing

00:28:36,399 --> 00:28:42,559
or we could add private accessors

00:28:39,520 --> 00:28:45,919
or even access the private data

00:28:42,559 --> 00:28:47,919
and make the test fixture a friend of

00:28:45,919 --> 00:28:50,000
the class that you're testing none of

00:28:47,919 --> 00:28:51,679
those is perfect you have to hold your

00:28:50,000 --> 00:28:54,640
nose and decide

00:28:51,679 --> 00:28:55,039
what uh which approach you think is best

00:28:54,640 --> 00:28:57,520
i

00:28:55,039 --> 00:28:59,279
i like the last one because it it gives

00:28:57,520 --> 00:29:01,520
better encapsulation but it's a personal

00:28:59,279 --> 00:29:04,960
decision

00:29:01,520 --> 00:29:08,399
um bonus points on this i showed you

00:29:04,960 --> 00:29:11,520
originally how we'd separate our guri

00:29:08,399 --> 00:29:15,120
executable out into a library and

00:29:11,520 --> 00:29:18,240
some separate tests better still

00:29:15,120 --> 00:29:22,080
would be to separate out the

00:29:18,240 --> 00:29:22,080
data storage and

00:29:22,320 --> 00:29:26,000
logic business logic algorithms that

00:29:24,880 --> 00:29:29,520
sort of thing

00:29:26,000 --> 00:29:31,600
from the ui library so behind this

00:29:29,520 --> 00:29:33,039
is often when people first write gui

00:29:31,600 --> 00:29:36,159
code they tend to mix

00:29:33,039 --> 00:29:38,000
in the code that implements the

00:29:36,159 --> 00:29:38,799
requested changes from the user

00:29:38,000 --> 00:29:41,120
interface

00:29:38,799 --> 00:29:43,520
with the gui code and so what we're

00:29:41,120 --> 00:29:45,760
saying here is separate out

00:29:43,520 --> 00:29:47,440
domain model type code into a lower

00:29:45,760 --> 00:29:50,240
level library

00:29:47,440 --> 00:29:50,799
and have your ui library depend on the

00:29:50,240 --> 00:29:53,520
model

00:29:50,799 --> 00:29:55,200
code but not the other way around and

00:29:53,520 --> 00:29:58,080
then of course you can write

00:29:55,200 --> 00:29:58,799
separate simpler tests that test your

00:29:58,080 --> 00:30:00,799
model

00:29:58,799 --> 00:30:02,080
you would expect to have many more tests

00:30:00,799 --> 00:30:05,039
of the model

00:30:02,080 --> 00:30:05,600
than tests of the user interface so over

00:30:05,039 --> 00:30:07,360
time

00:30:05,600 --> 00:30:08,799
yet separate the code and make it more

00:30:07,360 --> 00:30:12,240
maintainable and that

00:30:08,799 --> 00:30:15,360
pays benefits in terms of productivity

00:30:12,240 --> 00:30:17,279
robustness and so

00:30:15,360 --> 00:30:20,080
so i'm now going to pause for questions

00:30:17,279 --> 00:30:22,880
and we do have some

00:30:20,080 --> 00:30:24,960
so question is this testing methodology

00:30:22,880 --> 00:30:27,520
a valid alternative to something like

00:30:24,960 --> 00:30:29,600
squish or are they completely different

00:30:27,520 --> 00:30:31,679
um i have a slide on squish at the end

00:30:29,600 --> 00:30:33,919
so i'll defer that one till then but

00:30:31,679 --> 00:30:35,919
it's very good question i know you said

00:30:33,919 --> 00:30:37,760
fine child is fragile but what happens

00:30:35,919 --> 00:30:39,840
if you have multiple children of the

00:30:37,760 --> 00:30:42,320
same type you need to test

00:30:39,840 --> 00:30:44,640
then there is a find children method

00:30:42,320 --> 00:30:47,600
that will return multiple values

00:30:44,640 --> 00:30:48,799
and you would need to have a way to

00:30:47,600 --> 00:30:50,080
distinguish

00:30:48,799 --> 00:30:53,520
between them and know which one you

00:30:50,080 --> 00:30:55,840
wanted so perhaps name the widgets

00:30:53,520 --> 00:30:58,640
can these same methods be used to test q

00:30:55,840 --> 00:31:01,679
quick qml applications

00:30:58,640 --> 00:31:05,039
um my experience is in

00:31:01,679 --> 00:31:06,720
working with desktop qt applications and

00:31:05,039 --> 00:31:09,840
i'm looking forward at some point to

00:31:06,720 --> 00:31:14,240
working with cute quick and qml but

00:31:09,840 --> 00:31:16,159
for now i don't have any experience on

00:31:14,240 --> 00:31:18,399
that style of cute development and

00:31:16,159 --> 00:31:21,760
that's why i focused on

00:31:18,399 --> 00:31:24,240
uh on desktop applications so um

00:31:21,760 --> 00:31:26,000
i am going to have to pass on that one

00:31:24,240 --> 00:31:26,799
if anyone's watching and does have

00:31:26,000 --> 00:31:30,640
experience

00:31:26,799 --> 00:31:32,080
this kind of testing of qml applications

00:31:30,640 --> 00:31:34,000
i would love to talk

00:31:32,080 --> 00:31:37,679
see what i can learn and share in future

00:31:34,000 --> 00:31:37,679
talks so thank you for the questions

00:31:38,240 --> 00:31:42,159
there's a few things i wanted to flag up

00:31:40,559 --> 00:31:43,919
as things which

00:31:42,159 --> 00:31:46,320
are error-prone and things to

00:31:43,919 --> 00:31:49,279
specifically look out for and test

00:31:46,320 --> 00:31:50,640
so i touched on this previously if you

00:31:49,279 --> 00:31:54,000
are using q4

00:31:50,640 --> 00:31:54,960
or you're working in q5 on code that was

00:31:54,000 --> 00:31:58,000
written

00:31:54,960 --> 00:32:00,320
in q4 earlier your signal slots

00:31:58,000 --> 00:32:01,840
connections will look like this they use

00:32:00,320 --> 00:32:04,480
a signal macro

00:32:01,840 --> 00:32:06,559
and then a slot macro and the code

00:32:04,480 --> 00:32:08,799
behind the scenes is string based and

00:32:06,559 --> 00:32:11,440
only checked at runtime

00:32:08,799 --> 00:32:14,640
if you get that wrong for example if

00:32:11,440 --> 00:32:17,440
there is no slot method called quit

00:32:14,640 --> 00:32:19,519
then at runtime in the console if you're

00:32:17,440 --> 00:32:20,480
lucky enough that your application has a

00:32:19,519 --> 00:32:22,799
console

00:32:20,480 --> 00:32:24,159
someone will see error output like this

00:32:22,799 --> 00:32:26,240
if you don't have a console

00:32:24,159 --> 00:32:27,600
a user will complain that the button was

00:32:26,240 --> 00:32:31,039
broken

00:32:27,600 --> 00:32:34,559
much safer is to use the cute five style

00:32:31,039 --> 00:32:35,840
pointer to member function because

00:32:34,559 --> 00:32:38,799
if you get this wrong you know at

00:32:35,840 --> 00:32:42,480
compile time i mentioned briefly

00:32:38,799 --> 00:32:45,279
later a tool that will port code from q4

00:32:42,480 --> 00:32:47,279
to q5 connections

00:32:45,279 --> 00:32:50,640
another thing to be aware of is event

00:32:47,279 --> 00:32:52,559
processing when you're writing tests so

00:32:50,640 --> 00:32:54,799
you'll know that in a acute application

00:32:52,559 --> 00:32:56,159
behind the scenes qcor application

00:32:54,799 --> 00:32:59,519
process events is

00:32:56,159 --> 00:33:02,880
trundling away listening for user events

00:32:59,519 --> 00:33:05,919
timer events things like that and

00:33:02,880 --> 00:33:09,200
when you're writing your own

00:33:05,919 --> 00:33:11,039
tests you can't rely on that and there

00:33:09,200 --> 00:33:12,480
are some options available i just wanted

00:33:11,039 --> 00:33:14,720
to flag them up so that

00:33:12,480 --> 00:33:16,960
um you could uh search for the

00:33:14,720 --> 00:33:19,200
documentation and use them so

00:33:16,960 --> 00:33:20,799
q test it's really worth reading up on

00:33:19,200 --> 00:33:23,919
the um the qtest

00:33:20,799 --> 00:33:26,640
qt test library it does make it a lot

00:33:23,919 --> 00:33:29,600
easier to write

00:33:26,640 --> 00:33:32,399
developer-driven automated tests and q

00:33:29,600 --> 00:33:34,960
signal spy has weight as well

00:33:32,399 --> 00:33:36,720
um obviously it's not a great idea to

00:33:34,960 --> 00:33:38,799
put in hard-coded weight for three

00:33:36,720 --> 00:33:41,039
seconds until an action happens

00:33:38,799 --> 00:33:42,960
however many seconds sooner or later

00:33:41,039 --> 00:33:45,600
your code is going to be running on a

00:33:42,960 --> 00:33:47,679
perhaps a build virtual machine that is

00:33:45,600 --> 00:33:48,399
starved of cpu time for a while and

00:33:47,679 --> 00:33:50,559
you'll get

00:33:48,399 --> 00:33:53,279
flickering failing tests so try really

00:33:50,559 --> 00:33:56,159
hard not to put hard-coded time values

00:33:53,279 --> 00:33:59,120
in any test that you write

00:33:56,159 --> 00:33:59,600
if your test runner is q-test so your

00:33:59,120 --> 00:34:02,399
main

00:33:59,600 --> 00:34:04,320
is created by acute test then you can

00:34:02,399 --> 00:34:07,600
use these macros qtri

00:34:04,320 --> 00:34:07,919
compare and friends but beware if you

00:34:07,600 --> 00:34:10,000
have

00:34:07,919 --> 00:34:12,079
several assertions in one test that if

00:34:10,000 --> 00:34:16,480
any of those fail

00:34:12,079 --> 00:34:18,240
um the uh the qt test framework returns

00:34:16,480 --> 00:34:21,119
from your test case and so your later

00:34:18,240 --> 00:34:24,560
assertions won't be executed

00:34:21,119 --> 00:34:25,359
uh big klaxon if you've written your own

00:34:24,560 --> 00:34:28,000
test main

00:34:25,359 --> 00:34:30,000
and attach whatever don't use any of

00:34:28,000 --> 00:34:32,639
these methods

00:34:30,000 --> 00:34:34,000
unless your test framework your tests

00:34:32,639 --> 00:34:36,879
being run by the q

00:34:34,000 --> 00:34:38,079
test framework itself i'll explain a bit

00:34:36,879 --> 00:34:41,839
more later on

00:34:38,079 --> 00:34:44,240
why if you're once you've written

00:34:41,839 --> 00:34:45,440
your tests any tests that you write you

00:34:44,240 --> 00:34:47,839
want them to be run

00:34:45,440 --> 00:34:49,520
automatically in a build system in a

00:34:47,839 --> 00:34:51,200
continuous integration system because

00:34:49,520 --> 00:34:53,599
they pay for themselves

00:34:51,200 --> 00:34:54,639
over their lifetime when future

00:34:53,599 --> 00:34:56,639
developers

00:34:54,639 --> 00:34:59,280
make a change that they don't understand

00:34:56,639 --> 00:35:02,160
has broken some prior commitment

00:34:59,280 --> 00:35:04,000
on windows you'll find that doing acute

00:35:02,160 --> 00:35:07,280
gui tests just work

00:35:04,000 --> 00:35:10,880
in a ci system and then actually need to

00:35:07,280 --> 00:35:12,960
set up a virtual display

00:35:10,880 --> 00:35:15,200
typically ci machines don't have

00:35:12,960 --> 00:35:18,880
monitors attached

00:35:15,200 --> 00:35:21,839
xvf is one that is commonly used and

00:35:18,880 --> 00:35:23,920
easily searchable for

00:35:21,839 --> 00:35:26,000
both the developers and ci builds it's

00:35:23,920 --> 00:35:28,800
worth being aware of cube's command line

00:35:26,000 --> 00:35:30,800
argument minus platform off screen

00:35:28,800 --> 00:35:32,720
so developer running test doesn't have

00:35:30,800 --> 00:35:33,760
to have all of the widgets flickering up

00:35:32,720 --> 00:35:37,040
and disappearing

00:35:33,760 --> 00:35:39,119
can use an off-screen display as far as

00:35:37,040 --> 00:35:39,680
i know on mac you need to keep a user

00:35:39,119 --> 00:35:43,839
logged in

00:35:39,680 --> 00:35:47,119
in order for gui tests to run

00:35:43,839 --> 00:35:49,280
if you find you've got a test executable

00:35:47,119 --> 00:35:50,880
that's got some tests that require a

00:35:49,280 --> 00:35:53,920
display environment

00:35:50,880 --> 00:35:55,520
and some that don't then a nice trick is

00:35:53,920 --> 00:35:58,400
to create a macro

00:35:55,520 --> 00:35:59,359
or some one liner that says if there's

00:35:58,400 --> 00:36:01,280
no gui

00:35:59,359 --> 00:36:02,880
print a message saying i'm skipping this

00:36:01,280 --> 00:36:04,960
test and return

00:36:02,880 --> 00:36:06,960
put that at the top of each test that

00:36:04,960 --> 00:36:09,119
depends on the gui

00:36:06,960 --> 00:36:10,160
and then all of your other tests can run

00:36:09,119 --> 00:36:13,839
gracefully

00:36:10,160 --> 00:36:13,839
when no display is found

00:36:16,880 --> 00:36:22,000
there's a question about dealing with

00:36:19,839 --> 00:36:23,359
flaky tests and how do you deal with

00:36:22,000 --> 00:36:25,920
those

00:36:23,359 --> 00:36:28,240
i'll answer that at the end uh if

00:36:25,920 --> 00:36:31,520
there's time or let's talk about it

00:36:28,240 --> 00:36:33,119
uh in remo afterwards um

00:36:31,520 --> 00:36:34,880
it's not a short answer and i want to

00:36:33,119 --> 00:36:36,880
try and focus my answers

00:36:34,880 --> 00:36:38,640
on um things that i'm covering in the

00:36:36,880 --> 00:36:40,640
talk don't you know don't worry

00:36:38,640 --> 00:36:42,240
don't don't hold off please keep answer

00:36:40,640 --> 00:36:44,560
asking them but i'll

00:36:42,240 --> 00:36:46,960
for now pick out the ones that um relate

00:36:44,560 --> 00:36:49,200
to stuff i've covered so far

00:36:46,960 --> 00:36:51,920
so everything i've shown you so far is

00:36:49,200 --> 00:36:53,520
vanilla catch-2 and cute testing

00:36:51,920 --> 00:36:55,920
now i'm going to go on and talk about

00:36:53,520 --> 00:36:58,800
approval tests

00:36:55,920 --> 00:36:59,760
and i'm introducing a tiny tiny testing

00:36:58,800 --> 00:37:01,920
library

00:36:59,760 --> 00:37:03,760
which is built on top of approval tests

00:37:01,920 --> 00:37:07,440
for c-plus plus

00:37:03,760 --> 00:37:10,000
approval tests for testing cute

00:37:07,440 --> 00:37:11,839
and then the naming convention might

00:37:10,000 --> 00:37:15,520
seem curious to you but it fits

00:37:11,839 --> 00:37:19,200
with the many other repositories

00:37:15,520 --> 00:37:22,960
in the approvals github user

00:37:19,200 --> 00:37:25,920
so this is a library that so far

00:37:22,960 --> 00:37:27,760
is built upon approval tests for c plus

00:37:25,920 --> 00:37:29,839
plus and catch two

00:37:27,760 --> 00:37:31,680
i expect that if there's any demand i'll

00:37:29,839 --> 00:37:33,440
add support for more test frameworks in

00:37:31,680 --> 00:37:35,440
future

00:37:33,440 --> 00:37:36,560
and you need to provide your own build

00:37:35,440 --> 00:37:40,320
of q5

00:37:36,560 --> 00:37:42,880
test and q5 widgets

00:37:40,320 --> 00:37:43,520
and the goals that i have for that

00:37:42,880 --> 00:37:45,839
library

00:37:43,520 --> 00:37:47,280
are to enable you to rapidly start

00:37:45,839 --> 00:37:48,960
testing cute code so

00:37:47,280 --> 00:37:50,800
a lot of the boilerplate main that i

00:37:48,960 --> 00:37:53,280
showed you earlier

00:37:50,800 --> 00:37:54,960
i provide a way to use that without

00:37:53,280 --> 00:37:56,560
having to replicate it yourself so

00:37:54,960 --> 00:37:58,320
that little bit will be useful even if

00:37:56,560 --> 00:37:59,680
you don't use the approval tests

00:37:58,320 --> 00:38:02,000
functionality

00:37:59,680 --> 00:38:04,880
and then to start making it easy to add

00:38:02,000 --> 00:38:08,480
approval test support for a few

00:38:04,880 --> 00:38:09,280
cute types so easy saving of the state

00:38:08,480 --> 00:38:12,480
of widgets

00:38:09,280 --> 00:38:14,320
in golden output files i'll demo that

00:38:12,480 --> 00:38:17,280
shortly

00:38:14,320 --> 00:38:18,079
so we're at a tentatively very very

00:38:17,280 --> 00:38:20,079
early version

00:38:18,079 --> 00:38:21,359
to represent the early state that the

00:38:20,079 --> 00:38:24,000
code is in

00:38:21,359 --> 00:38:25,359
one of the big purposes of this talk is

00:38:24,000 --> 00:38:28,160
for me to explore

00:38:25,359 --> 00:38:30,880
whether there's any interest in doing

00:38:28,160 --> 00:38:34,160
more work on the library

00:38:30,880 --> 00:38:35,839
so it really is very prototype early

00:38:34,160 --> 00:38:37,680
version we do have a starter project

00:38:35,839 --> 00:38:43,920
though that you can download

00:38:37,680 --> 00:38:47,119
and build an nec make uh supporting ide

00:38:43,920 --> 00:38:49,520
so your main if you use this library

00:38:47,119 --> 00:38:52,160
you could write hash define approvals

00:38:49,520 --> 00:38:54,960
underscore catch underscore qt

00:38:52,160 --> 00:38:56,400
and then hash include the approval test

00:38:54,960 --> 00:38:58,400
security header

00:38:56,400 --> 00:39:00,000
and that is the equivalent of all of

00:38:58,400 --> 00:39:03,839
this code that we wrote

00:39:00,000 --> 00:39:06,400
by hand earlier so that's the kind of

00:39:03,839 --> 00:39:08,880
help it can give you in getting started

00:39:06,400 --> 00:39:11,280
now imagine that you are trying to write

00:39:08,880 --> 00:39:12,640
a test for some table widget

00:39:11,280 --> 00:39:14,800
and i talked earlier about

00:39:12,640 --> 00:39:15,839
implementation code being mixed into

00:39:14,800 --> 00:39:17,680
widget code

00:39:15,839 --> 00:39:20,880
imagine that the code to populate this

00:39:17,680 --> 00:39:22,720
table was mixed into the code

00:39:20,880 --> 00:39:24,240
that the code that calculated the values

00:39:22,720 --> 00:39:26,240
was mixed in with

00:39:24,240 --> 00:39:28,320
the code that displayed the values and

00:39:26,240 --> 00:39:30,400
you wanted to reuse the calculation code

00:39:28,320 --> 00:39:31,119
somewhere else so you wanted to separate

00:39:30,400 --> 00:39:33,280
it

00:39:31,119 --> 00:39:34,240
so because of that we want to test the

00:39:33,280 --> 00:39:37,920
text

00:39:34,240 --> 00:39:41,119
values in the table cells let's look at

00:39:37,920 --> 00:39:41,119
how we would do that

00:39:41,359 --> 00:39:46,640
so i've got a

00:39:44,560 --> 00:39:48,240
catch header and the approval tests

00:39:46,640 --> 00:39:51,599
header and i've got

00:39:48,240 --> 00:39:52,720
some function that for the purposes of

00:39:51,599 --> 00:39:56,640
testing

00:39:52,720 --> 00:39:57,440
creates a populates the cells in a table

00:39:56,640 --> 00:40:00,560
widget

00:39:57,440 --> 00:40:02,240
so here we have created the table widget

00:40:00,560 --> 00:40:04,480
we're calling our populate table

00:40:02,240 --> 00:40:08,000
function and then we're going to call

00:40:04,480 --> 00:40:11,040
approval tests cute verify cue table

00:40:08,000 --> 00:40:13,119
view now people who've seen

00:40:11,040 --> 00:40:14,960
approval tests before will recognize

00:40:13,119 --> 00:40:19,280
this pattern of having

00:40:14,960 --> 00:40:22,880
a verify method and passing something in

00:40:19,280 --> 00:40:26,160
um and then the state of that object

00:40:22,880 --> 00:40:28,400
being preserved as a kind of regression

00:40:26,160 --> 00:40:31,280
test a very convenient regression test

00:40:28,400 --> 00:40:33,520
so that once you've once you've told

00:40:31,280 --> 00:40:36,079
approval test what the right answer is

00:40:33,520 --> 00:40:37,119
in future runs it will report if there

00:40:36,079 --> 00:40:40,720
are any changes

00:40:37,119 --> 00:40:42,720
so let's try that out let's run it

00:40:40,720 --> 00:40:44,720
and it said test failed and the error

00:40:42,720 --> 00:40:46,400
message was that the approved test was

00:40:44,720 --> 00:40:49,920
not found

00:40:46,400 --> 00:40:52,000
and so on the left hand side we have the

00:40:49,920 --> 00:40:54,480
output from this test run

00:40:52,000 --> 00:40:55,680
and on the right hand side we have the

00:40:54,480 --> 00:40:57,200
right answer

00:40:55,680 --> 00:40:58,720
and of course approvals doesn't know the

00:40:57,200 --> 00:41:01,119
right answer because this is the first

00:40:58,720 --> 00:41:03,119
time we've run this test

00:41:01,119 --> 00:41:04,880
and as is often the case with legacy

00:41:03,119 --> 00:41:07,359
code what it writes out

00:41:04,880 --> 00:41:10,319
for the time being is the right answer

00:41:07,359 --> 00:41:12,800
so i clicked on the little arrow to copy

00:41:10,319 --> 00:41:14,079
the output the received output to the

00:41:12,800 --> 00:41:17,920
approved file

00:41:14,079 --> 00:41:20,640
and i'm going to save and quit that

00:41:17,920 --> 00:41:22,000
and now when i look in the tests you'll

00:41:20,640 --> 00:41:26,960
see in the approval test

00:41:22,000 --> 00:41:30,079
subdirectory we've got an approved file

00:41:26,960 --> 00:41:31,920
with that's populated and

00:41:30,079 --> 00:41:34,000
we would test check in to version

00:41:31,920 --> 00:41:36,720
control that file

00:41:34,000 --> 00:41:37,040
alongside the test source code that file

00:41:36,720 --> 00:41:39,440
is

00:41:37,040 --> 00:41:41,119
that is the right answer that's that's

00:41:39,440 --> 00:41:44,560
the expected output

00:41:41,119 --> 00:41:46,160
and when i rerun the test approval test

00:41:44,560 --> 00:41:47,760
only shows a differencing tool if

00:41:46,160 --> 00:41:48,400
there's a change or a test failure to

00:41:47,760 --> 00:41:51,359
show

00:41:48,400 --> 00:41:51,839
so now it's a silent silently passing

00:41:51,359 --> 00:41:54,560
test

00:41:51,839 --> 00:41:54,560
which is great

00:41:56,880 --> 00:42:00,079
the other capability that this new

00:41:59,359 --> 00:42:03,040
library has

00:42:00,079 --> 00:42:04,960
is the ability to capture screenshots as

00:42:03,040 --> 00:42:07,200
images

00:42:04,960 --> 00:42:09,440
and in general i want to reassure you

00:42:07,200 --> 00:42:10,240
that i do understand that this is not a

00:42:09,440 --> 00:42:12,319
good way

00:42:10,240 --> 00:42:13,680
to write tests of gui code you want to

00:42:12,319 --> 00:42:17,119
focus on testing

00:42:13,680 --> 00:42:20,319
behavior not appearance

00:42:17,119 --> 00:42:22,079
those tests are fragile they can be

00:42:20,319 --> 00:42:24,000
changes they can start failing when

00:42:22,079 --> 00:42:24,640
there's a minor update to an operating

00:42:24,000 --> 00:42:25,920
system

00:42:24,640 --> 00:42:27,839
they'll behave differently give

00:42:25,920 --> 00:42:29,440
different slightly different pictures on

00:42:27,839 --> 00:42:31,839
different platforms

00:42:29,440 --> 00:42:33,119
so this is not the way to test the

00:42:31,839 --> 00:42:34,800
appearances

00:42:33,119 --> 00:42:37,359
are unchanged you really want to test

00:42:34,800 --> 00:42:40,720
behavior

00:42:37,359 --> 00:42:43,359
however just occasionally it may be

00:42:40,720 --> 00:42:46,800
valuable to test

00:42:43,359 --> 00:42:50,000
save screenshots so let me switch

00:42:46,800 --> 00:42:50,000
to the other

00:42:52,079 --> 00:42:58,079
example here now

00:42:55,680 --> 00:43:00,319
i'm going to have to ask you to use your

00:42:58,079 --> 00:43:01,440
imagination here imagine that behind the

00:43:00,319 --> 00:43:04,240
scenes

00:43:01,440 --> 00:43:05,920
is some beautiful code for creating some

00:43:04,240 --> 00:43:08,560
beautiful image

00:43:05,920 --> 00:43:09,599
and we're calling create our example

00:43:08,560 --> 00:43:11,200
image

00:43:09,599 --> 00:43:12,960
and then we're passing that into

00:43:11,200 --> 00:43:15,920
approval tests qt

00:43:12,960 --> 00:43:15,920
verify image

00:43:16,560 --> 00:43:24,000
so the test fails and what appears

00:43:20,160 --> 00:43:26,560
is the actual answer

00:43:24,000 --> 00:43:28,560
this is arrax's merge which supports

00:43:26,560 --> 00:43:30,880
dipping of images but it doesn't give us

00:43:28,560 --> 00:43:33,920
that much useful information

00:43:30,880 --> 00:43:35,440
and so what i'm going to do is and

00:43:33,920 --> 00:43:37,359
there's multiple different ways to do

00:43:35,440 --> 00:43:40,640
this but i'm going to tell

00:43:37,359 --> 00:43:42,640
approval tests to use the

00:43:40,640 --> 00:43:44,079
beyond compare report because that does

00:43:42,640 --> 00:43:47,440
a much nicer job

00:43:44,079 --> 00:43:47,440
of comparing images

00:43:47,599 --> 00:43:52,079
and so that's

00:43:52,560 --> 00:43:56,000
the there's lots of extra information

00:43:54,880 --> 00:43:58,640
displayed

00:43:56,000 --> 00:43:59,760
like the file modification time the file

00:43:58,640 --> 00:44:01,599
size

00:43:59,760 --> 00:44:03,280
um the bit depth all sorts of things

00:44:01,599 --> 00:44:06,319
like that um

00:44:03,280 --> 00:44:08,560
this shows a weakness of the library so

00:44:06,319 --> 00:44:10,640
far which is that

00:44:08,560 --> 00:44:13,280
it doesn't know how to create empty png

00:44:10,640 --> 00:44:17,119
files um

00:44:13,280 --> 00:44:17,440
so this probably isn't the best approach

00:44:17,119 --> 00:44:19,839
for

00:44:17,440 --> 00:44:20,800
testing and there is i'll include a link

00:44:19,839 --> 00:44:22,560
in the

00:44:20,800 --> 00:44:25,520
notes from the talk but somebody has

00:44:22,560 --> 00:44:27,839
written an approval tests

00:44:25,520 --> 00:44:29,200
uh for images library that is much more

00:44:27,839 --> 00:44:32,240
sophisticated

00:44:29,200 --> 00:44:34,880
at um working with images so uh

00:44:32,240 --> 00:44:36,000
as i very much recommend using that but

00:44:34,880 --> 00:44:39,280
this capability

00:44:36,000 --> 00:44:42,560
is is here um

00:44:39,280 --> 00:44:44,319
so i did use this sort of approach

00:44:42,560 --> 00:44:46,400
when i was working on some crystal

00:44:44,319 --> 00:44:48,079
structure visualization software

00:44:46,400 --> 00:44:49,440
and this is the sort of thing that the

00:44:48,079 --> 00:44:52,480
code was generating

00:44:49,440 --> 00:44:55,359
and as i i was adding a new capability

00:44:52,480 --> 00:44:57,440
and i was implementing iteratively and

00:44:55,359 --> 00:45:00,800
finding lots of corner cases

00:44:57,440 --> 00:45:04,640
and in my talk at c plus plus on c

00:45:00,800 --> 00:45:08,560
in 2019 i talked through in more detail

00:45:04,640 --> 00:45:12,000
how i was able to use

00:45:08,560 --> 00:45:15,359
approval tests with cute code

00:45:12,000 --> 00:45:19,119
and uh it was really really helpful and

00:45:15,359 --> 00:45:21,040
sped up development significantly

00:45:19,119 --> 00:45:23,920
quick note of caution a bit more about

00:45:21,040 --> 00:45:27,200
the avoid cue compare and so on

00:45:23,920 --> 00:45:31,440
if your test framework is

00:45:27,200 --> 00:45:33,760
um anything other than

00:45:31,440 --> 00:45:35,599
due to tests any failures and those will

00:45:33,760 --> 00:45:37,359
be silently swallowed and your tests

00:45:35,599 --> 00:45:40,400
will spuriously pass

00:45:37,359 --> 00:45:42,079
that's why you need to avoid it what's

00:45:40,400 --> 00:45:45,040
next for this library

00:45:42,079 --> 00:45:46,240
um i do want to fix qt test macros

00:45:45,040 --> 00:45:48,640
problem and uh

00:45:46,240 --> 00:45:50,400
fabian from qt has given me some really

00:45:48,640 --> 00:45:53,520
helpful information on that

00:45:50,400 --> 00:45:55,839
um and uh you

00:45:53,520 --> 00:45:57,520
uh then i think i'd like feedback

00:45:55,839 --> 00:45:58,960
there's lots of things i could do

00:45:57,520 --> 00:46:01,200
but first of all i need to know if

00:45:58,960 --> 00:46:06,079
there's actually anyone interested in

00:46:01,200 --> 00:46:08,960
working on it and testing it out so um

00:46:06,079 --> 00:46:10,480
so yeah let me know if you use it if you

00:46:08,960 --> 00:46:11,040
want to use it what you think would be

00:46:10,480 --> 00:46:13,440
helpful

00:46:11,040 --> 00:46:14,079
i'd be really happy to do more work so

00:46:13,440 --> 00:46:17,680
let's look

00:46:14,079 --> 00:46:21,040
and see what questions we've got

00:46:17,680 --> 00:46:24,240
um okay so no new questions so

00:46:21,040 --> 00:46:26,880
i will continue

00:46:24,240 --> 00:46:28,319
just briefly three tools that i wanted

00:46:26,880 --> 00:46:32,160
to mention

00:46:28,319 --> 00:46:33,119
kdabs gammaray is a fantastic inspection

00:46:32,160 --> 00:46:36,880
tool

00:46:33,119 --> 00:46:39,839
to allow you to

00:46:36,880 --> 00:46:40,640
navigate through the widget hierarchy in

00:46:39,839 --> 00:46:43,920
a running

00:46:40,640 --> 00:46:45,440
qt application so if you were being

00:46:43,920 --> 00:46:48,400
asked to work on a particular

00:46:45,440 --> 00:46:50,160
area of an application and you wanted to

00:46:48,400 --> 00:46:53,359
find out where that

00:46:50,160 --> 00:46:54,480
source code was i worked on a four to

00:46:53,359 --> 00:46:57,520
five million

00:46:54,480 --> 00:46:59,200
line of codes lines of code base and

00:46:57,520 --> 00:47:01,520
i mean we worked in a new area it was

00:46:59,200 --> 00:47:03,280
quite hard to find the code of interest

00:47:01,520 --> 00:47:05,119
and this would have really helped with

00:47:03,280 --> 00:47:08,880
that

00:47:05,119 --> 00:47:10,240
claesi is a static analysis tool that

00:47:08,880 --> 00:47:14,480
speaks cutie

00:47:10,240 --> 00:47:17,920
or cute it's got lots of useful warnings

00:47:14,480 --> 00:47:21,040
to point out errors likely errors and

00:47:17,920 --> 00:47:21,920
efficiency and efficiency problems in

00:47:21,040 --> 00:47:24,400
code

00:47:21,920 --> 00:47:25,839
qt code and it has a fix-it for old

00:47:24,400 --> 00:47:29,280
style connect so

00:47:25,839 --> 00:47:32,000
that's how you can if you want ports

00:47:29,280 --> 00:47:33,440
update your cute four style connections

00:47:32,000 --> 00:47:36,000
to q5

00:47:33,440 --> 00:47:36,960
and then finally squish which somebody

00:47:36,000 --> 00:47:40,800
asked about

00:47:36,960 --> 00:47:43,119
earlier so everything else so far

00:47:40,800 --> 00:47:45,280
up until this point has been about

00:47:43,119 --> 00:47:49,599
developers editing source code

00:47:45,280 --> 00:47:53,200
and writing tests squish is different

00:47:49,599 --> 00:47:55,599
squish is

00:47:53,200 --> 00:47:56,680
squish runs your whole application and

00:47:55,599 --> 00:48:00,240
it's kind of

00:47:56,680 --> 00:48:04,000
semi-opaque box testing so

00:48:00,240 --> 00:48:05,760
you record actions in your application

00:48:04,000 --> 00:48:07,920
you've picked a language that your tests

00:48:05,760 --> 00:48:11,920
the recordings will be saved in

00:48:07,920 --> 00:48:14,720
python was the one that i used um

00:48:11,920 --> 00:48:17,359
and then you refactor your code into

00:48:14,720 --> 00:48:20,880
reusable tests

00:48:17,359 --> 00:48:24,640
there was a lovely talk at um

00:48:20,880 --> 00:48:25,760
cutie desktop conference in the last

00:48:24,640 --> 00:48:27,680
week or two

00:48:25,760 --> 00:48:29,680
showing actually how to use squish and

00:48:27,680 --> 00:48:31,520
like bdd style tests

00:48:29,680 --> 00:48:32,800
and it kind of does the refactoring for

00:48:31,520 --> 00:48:34,559
you automatically so

00:48:32,800 --> 00:48:37,040
when the video of that is published i'll

00:48:34,559 --> 00:48:39,119
add it to the notes from this tool

00:48:37,040 --> 00:48:40,559
in my opinion it's not a replacement for

00:48:39,119 --> 00:48:42,880
unit tests

00:48:40,559 --> 00:48:45,200
um by virtue of it running your entire

00:48:42,880 --> 00:48:46,559
application for each test it runs it's

00:48:45,200 --> 00:48:48,240
going to be much slower if it's a

00:48:46,559 --> 00:48:49,839
sizeable application

00:48:48,240 --> 00:48:51,359
and it does require commitment to

00:48:49,839 --> 00:48:53,359
training and maintenance

00:48:51,359 --> 00:48:54,960
but if you can use it well and if you

00:48:53,359 --> 00:48:57,200
can make sure that you're running its

00:48:54,960 --> 00:48:59,680
tests automatically regularly so that

00:48:57,200 --> 00:49:01,839
any test failures are picked up quickly

00:48:59,680 --> 00:49:04,160
it can replace huge amounts of manual

00:49:01,839 --> 00:49:08,000
testing before releases

00:49:04,160 --> 00:49:08,000
so i think it's a really powerful tool

00:49:09,359 --> 00:49:13,760
so in summary it's never too late to

00:49:12,559 --> 00:49:16,480
start testing i would like that to be

00:49:13,760 --> 00:49:18,480
the main message of my talk don't be put

00:49:16,480 --> 00:49:19,280
off if you've got no tests it's never

00:49:18,480 --> 00:49:20,720
too late

00:49:19,280 --> 00:49:23,280
once you've written the first test it

00:49:20,720 --> 00:49:25,200
will get easier and

00:49:23,280 --> 00:49:27,359
it's a skill to learn but it will pay

00:49:25,200 --> 00:49:29,920
for itself very quickly

00:49:27,359 --> 00:49:31,920
try to test smaller units of code such

00:49:29,920 --> 00:49:34,319
as individual widgets so write your

00:49:31,920 --> 00:49:36,720
tests in layers

00:49:34,319 --> 00:49:37,760
test behaviors not appearance as much as

00:49:36,720 --> 00:49:40,160
possible

00:49:37,760 --> 00:49:42,720
and keep your application logic separate

00:49:40,160 --> 00:49:44,960
from the gui code

00:49:42,720 --> 00:49:46,880
make tests easy to write if that means

00:49:44,960 --> 00:49:49,920
writing helper functions

00:49:46,880 --> 00:49:51,599
whatever it takes and hide the details

00:49:49,920 --> 00:49:55,599
of the custom widgets

00:49:51,599 --> 00:49:57,680
behind as i said behind helper functions

00:49:55,599 --> 00:49:59,760
fixtures can able can enable you to

00:49:57,680 --> 00:50:02,640
write really expressive

00:49:59,760 --> 00:50:05,280
and readable tests and i don't think

00:50:02,640 --> 00:50:07,119
this just applies to gui code

00:50:05,280 --> 00:50:08,880
i wish i'd understood the benefits of

00:50:07,119 --> 00:50:12,240
fixtures early on in my

00:50:08,880 --> 00:50:12,960
development testing career finally any

00:50:12,240 --> 00:50:15,359
feedback

00:50:12,960 --> 00:50:17,359
on approval tests for cute would be

00:50:15,359 --> 00:50:19,599
really welcome

00:50:17,359 --> 00:50:21,920
and that is how you quickly test cute

00:50:19,599 --> 00:50:26,640
desktop applications with approval tests

00:50:21,920 --> 00:50:29,520
thank you very much

00:50:26,640 --> 00:50:31,359
okay so a little bit more information um

00:50:29,520 --> 00:50:33,839
a reminder that you can get via this

00:50:31,359 --> 00:50:36,800
bitly link or that qr code

00:50:33,839 --> 00:50:38,559
to a page of links that i've mentioned

00:50:36,800 --> 00:50:42,000
and some extra information

00:50:38,559 --> 00:50:45,920
tips on refactoring and things like that

00:50:42,000 --> 00:50:47,839
and i'll as i get asked questions i will

00:50:45,920 --> 00:50:50,480
if anything else crops up i'll extend

00:50:47,839 --> 00:50:50,480
that file

00:50:51,520 --> 00:50:56,400
as i said my focus is on about all about

00:50:53,920 --> 00:50:59,119
sustainable and efficient testing

00:50:56,400 --> 00:51:00,960
and refactoring of legacy code i really

00:50:59,119 --> 00:51:02,720
hope that what i've told you

00:51:00,960 --> 00:51:04,480
will enable you to get started with

00:51:02,720 --> 00:51:07,760
testing on your own

00:51:04,480 --> 00:51:09,440
but if you do need help feel free to

00:51:07,760 --> 00:51:11,839
reach out really happy to answer

00:51:09,440 --> 00:51:15,599
questions and for more substantial work

00:51:11,839 --> 00:51:18,000
i can work with you remotely for

00:51:15,599 --> 00:51:19,760
half a day day a few days whatever it

00:51:18,000 --> 00:51:20,559
helps to get you unblocked and start

00:51:19,760 --> 00:51:23,520
testing

00:51:20,559 --> 00:51:25,599
that's how to contact me and that's it

00:51:23,520 --> 00:51:29,280
so there are a few minutes left

00:51:25,599 --> 00:51:32,640
um so

00:51:29,280 --> 00:51:33,200
yeah so the one extra question is do i

00:51:32,640 --> 00:51:35,920
have

00:51:33,200 --> 00:51:37,599
any suggestions on how to get catch 2 to

00:51:35,920 --> 00:51:40,640
compile faster

00:51:37,599 --> 00:51:44,400
so particularly for its main catch 2

00:51:40,640 --> 00:51:47,599
has a lot of code to compile and

00:51:44,400 --> 00:51:48,640
when you're using catch 2 version 2 they

00:51:47,599 --> 00:51:50,800
have

00:51:48,640 --> 00:51:52,079
a helpful page of some extra options

00:51:50,800 --> 00:51:56,480
that you can set

00:51:52,079 --> 00:51:59,440
to speed up builds i'm assuming that

00:51:56,480 --> 00:52:01,280
you would have a main file and then your

00:51:59,440 --> 00:52:03,040
tests and separate files

00:52:01,280 --> 00:52:05,119
definitely don't put tests in the same

00:52:03,040 --> 00:52:08,079
place as the main

00:52:05,119 --> 00:52:08,800
if you can i would recommend seeing if

00:52:08,079 --> 00:52:12,079
you can build

00:52:08,800 --> 00:52:14,400
against catch 2 version 3 which is

00:52:12,079 --> 00:52:16,960
on a branch but i know that people are

00:52:14,400 --> 00:52:19,440
already using it on production code

00:52:16,960 --> 00:52:21,280
and it's moved for away from the single

00:52:19,440 --> 00:52:24,480
header approach

00:52:21,280 --> 00:52:26,480
to having a static library

00:52:24,480 --> 00:52:28,400
so that like code gets built once and

00:52:26,480 --> 00:52:28,880
then when your code is compiled it only

00:52:28,400 --> 00:52:30,400
needs

00:52:28,880 --> 00:52:32,559
the compiler only needs to see the

00:52:30,400 --> 00:52:35,520
header and not the implementations and

00:52:32,559 --> 00:52:38,319
that will speed up your builds a lot

00:52:35,520 --> 00:52:39,839
um a leftover question have you dealt

00:52:38,319 --> 00:52:42,000
with flaky tests

00:52:39,839 --> 00:52:43,680
how do or did you deal with those thank

00:52:42,000 --> 00:52:48,079
you for the reminder kevin

00:52:43,680 --> 00:52:51,839
um so yes flaky tests are a real

00:52:48,079 --> 00:52:54,880
real problem because they

00:52:51,839 --> 00:52:56,640
mean that people stop trusting the tests

00:52:54,880 --> 00:52:57,040
and it also means they stop dealing with

00:52:56,640 --> 00:52:59,839
test

00:52:57,040 --> 00:53:01,280
failures which is a real disadvantage so

00:52:59,839 --> 00:53:03,040
the kind of thing i've seen

00:53:01,280 --> 00:53:04,720
is a particular library the test from a

00:53:03,040 --> 00:53:07,839
particular library

00:53:04,720 --> 00:53:09,359
started failing a week ago and for

00:53:07,839 --> 00:53:10,640
whatever reason they hadn't been fixed

00:53:09,359 --> 00:53:13,440
in between

00:53:10,640 --> 00:53:16,160
and then some time later a new test

00:53:13,440 --> 00:53:17,839
starts failing in the same library

00:53:16,160 --> 00:53:20,160
and people don't pay any attention the

00:53:17,839 --> 00:53:21,680
ci system says that's like that library

00:53:20,160 --> 00:53:22,880
is read the build it's read the test

00:53:21,680 --> 00:53:24,480
rail and someone says oh don't worry

00:53:22,880 --> 00:53:25,839
it's been like that for a while we'll

00:53:24,480 --> 00:53:27,520
franco and social look at it when they

00:53:25,839 --> 00:53:29,119
get back from holiday so

00:53:27,520 --> 00:53:32,720
don't the number one thing is don't

00:53:29,119 --> 00:53:32,720
tolerate flaky tests

00:53:32,800 --> 00:53:39,200
i've dealt with flaky tests that

00:53:35,920 --> 00:53:39,200
turned out to be

00:53:39,280 --> 00:53:43,280
perhaps a circumstance of timing i

00:53:41,440 --> 00:53:45,680
mentioned earlier that

00:53:43,280 --> 00:53:47,599
don't ever write a test that says for

00:53:45,680 --> 00:53:50,480
example test this function is

00:53:47,599 --> 00:53:52,160
at least three times as fast as this

00:53:50,480 --> 00:53:54,640
other function don't write

00:53:52,160 --> 00:53:58,480
things that depend on timing because

00:53:54,640 --> 00:54:01,599
sooner or later your tests will run on a

00:53:58,480 --> 00:54:03,119
ci system that's staffed of resources

00:54:01,599 --> 00:54:05,119
so that's that's my number one thing is

00:54:03,119 --> 00:54:05,839
just don't write tests that depend on

00:54:05,119 --> 00:54:07,440
timing

00:54:05,839 --> 00:54:09,680
if you need to do performance tests have

00:54:07,440 --> 00:54:10,880
a separate environment for that with

00:54:09,680 --> 00:54:14,400
stable

00:54:10,880 --> 00:54:17,839
hardware that gives stable performance

00:54:14,400 --> 00:54:18,400
um i tend to find the other thing is

00:54:17,839 --> 00:54:22,400
don't ever

00:54:18,400 --> 00:54:24,079
ignore a flaky test in most flaky tests

00:54:22,400 --> 00:54:25,839
that i've seen when we finally

00:54:24,079 --> 00:54:27,680
investigated them they've been telling

00:54:25,839 --> 00:54:31,200
us real things

00:54:27,680 --> 00:54:33,920
so in um if you're writing tests in q

00:54:31,200 --> 00:54:34,720
code testing how an application manages

00:54:33,920 --> 00:54:37,440
its settings

00:54:34,720 --> 00:54:39,359
to settings object those by default are

00:54:37,440 --> 00:54:43,280
saved in the home directory

00:54:39,359 --> 00:54:46,520
and if your ci system

00:54:43,280 --> 00:54:49,280
runs in several different tests

00:54:46,520 --> 00:54:50,559
simultaneously on the same user on the

00:54:49,280 --> 00:54:53,760
same machine

00:54:50,559 --> 00:54:55,920
you might get flickering tests where two

00:54:53,760 --> 00:54:59,119
applications are trying to save

00:54:55,920 --> 00:54:59,680
change the setting to different sets of

00:54:59,119 --> 00:55:02,160
code

00:54:59,680 --> 00:55:03,760
are trying to save to the same settings

00:55:02,160 --> 00:55:06,400
file at the same time

00:55:03,760 --> 00:55:07,280
and that will only fail occasionally and

00:55:06,400 --> 00:55:09,599
you can change

00:55:07,280 --> 00:55:11,280
cue settings to tell it to give it a

00:55:09,599 --> 00:55:13,839
location to store the file

00:55:11,280 --> 00:55:17,839
so that was a real flickering test that

00:55:13,839 --> 00:55:19,599
we were able to improve our tests for

00:55:17,839 --> 00:55:21,359
most of the time so you'll find there

00:55:19,599 --> 00:55:25,040
are patterns and it's worth documenting

00:55:21,359 --> 00:55:27,040
those and sharing them with colleagues

00:55:25,040 --> 00:55:29,280
so usually in my experience the

00:55:27,040 --> 00:55:30,880
flickering test is telling us something

00:55:29,280 --> 00:55:32,960
something real something you need to

00:55:30,880 --> 00:55:35,200
look at

00:55:32,960 --> 00:55:36,079
if you can't fix the flickering test at

00:55:35,200 --> 00:55:39,359
that point

00:55:36,079 --> 00:55:42,400
then i would say disable it

00:55:39,359 --> 00:55:44,640
well if it has no value delete it

00:55:42,400 --> 00:55:47,200
if you think you need to come back to it

00:55:44,640 --> 00:55:49,760
then disable it with a comment that says

00:55:47,200 --> 00:55:51,440
disabled or better write it make it

00:55:49,760 --> 00:55:53,760
write out a message so use

00:55:51,440 --> 00:55:54,799
your test frameworks way of disabling it

00:55:53,760 --> 00:55:58,640
and say

00:55:54,799 --> 00:56:00,079
um disabled until we can fix github

00:55:58,640 --> 00:56:02,319
issue one two three four

00:56:00,079 --> 00:56:04,000
five log an issue for it and make sure

00:56:02,319 --> 00:56:05,760
it gets prioritized

00:56:04,000 --> 00:56:07,280
don't just leave it in there and

00:56:05,760 --> 00:56:08,960
definitely don't just leave it in there

00:56:07,280 --> 00:56:11,040
flickering occasionally

00:56:08,960 --> 00:56:12,000
so it will devalue the rest of your

00:56:11,040 --> 00:56:13,920
tests

00:56:12,000 --> 00:56:16,960
uh so um i said it wasn't the short

00:56:13,920 --> 00:56:16,960
answer but i hope that was

00:56:19,520 --> 00:56:24,559
so we have got about

00:56:22,640 --> 00:56:25,839
four minutes left but there don't seem

00:56:24,559 --> 00:56:29,280
to be any more

00:56:25,839 --> 00:56:31,520
questions so

00:56:29,280 --> 00:56:32,799
thank you very much i think i will i

00:56:31,520 --> 00:56:37,119
will leave it there

00:56:32,799 --> 00:56:38,880
um uh claire mcrae.co.uk if you would

00:56:37,119 --> 00:56:42,160
like to get back in touch with me

00:56:38,880 --> 00:56:44,400
and otherwise uh see you in remo

00:56:42,160 --> 00:56:59,839
shortly thanks ever so much and goodbye

00:56:44,400 --> 00:56:59,839
for now

00:57:04,720 --> 00:57:06,799

YouTube URL: https://www.youtube.com/watch?v=J27HoZM_PTI


