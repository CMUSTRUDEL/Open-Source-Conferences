Title: The Hidden Secrets of Move Semantics - Nicolai Josuttis - CppCon 2020
Publication date: 2020-09-23
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---

Move semantics, introduced with C++11, has become a hallmark of modern C++ programming. However, it also complicates the language in many ways. Even after several years of support, experienced programmers struggle with all the details of move semantics. And style guides still recommend different consequences for programming even of trivial classes. And in the C++ community we still discuss semantic details.

While I took the time to write up all the facts and details in my new book "C++ Move Semantics - The Complete Guide (cppmove.com), I learned a lot I wasn't aware of. Note that the final book will have 200 pages.

This talk is about the most surpising facts, even experts sometimes don't know.

Some hidden secrets so that you understand C++ a bit better.

---
Nicolai Josuttis (http://www.josuttis.com) is well known in the programming community because he not only speaks and writes with authority (being the (co-)author of the world-wide best sellers The C++ Standard Library (www.cppstdlib.com), C++ Templates (www.tmplbook.com), C++17 - The Complete Guide (www.cppstd17.com), C++ Move Semantics - The Complete Guide (www.cppmove.com), and SOA in Practice), but is also an innovative presenter, having talked at various conferences and events.

He has been an active member of the C++ standards committee for more than 20 years.
---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:17,920
hi there

00:00:21,199 --> 00:00:25,199
yeah this is nico josetes and i'm live

00:00:23,680 --> 00:00:31,840
from germany here

00:00:25,199 --> 00:00:31,840
and we have to talk about museum

00:00:32,239 --> 00:00:36,000
i want to tell you about the hidden

00:00:34,800 --> 00:00:39,200
secrets

00:00:36,000 --> 00:00:42,840
i found and

00:00:39,200 --> 00:00:46,160
in the next one hour i will talk about

00:00:42,840 --> 00:00:46,960
uh just how we can move better and see

00:00:46,160 --> 00:00:49,039
bus bus

00:00:46,960 --> 00:00:50,640
move semantic was interviews in c bus

00:00:49,039 --> 00:00:53,920
pass 11

00:00:50,640 --> 00:00:54,640
and it's time to talk about a little bit

00:00:53,920 --> 00:00:57,440
about

00:00:54,640 --> 00:00:58,239
the hidden features of move semantics so

00:00:57,440 --> 00:01:01,520
let's start

00:00:58,239 --> 00:01:05,280
the whole session will be just

00:01:01,520 --> 00:01:05,280
that we program a little bit

00:01:05,600 --> 00:01:09,920
so this is my class i want to program

00:01:07,520 --> 00:01:11,119
with you this is a class cont for

00:01:09,920 --> 00:01:16,000
container

00:01:11,119 --> 00:01:16,000
internally using a vector string and

00:01:16,320 --> 00:01:19,600
yeah with a default constructor so we

00:01:18,400 --> 00:01:21,920
can create

00:01:19,600 --> 00:01:24,720
the container and of course we can

00:01:21,920 --> 00:01:27,280
insert some elements

00:01:24,720 --> 00:01:27,759
maybe we create a string print out a

00:01:27,280 --> 00:01:30,400
string

00:01:27,759 --> 00:01:31,920
before we insert it and then we print it

00:01:30,400 --> 00:01:34,560
out

00:01:31,920 --> 00:01:36,240
and then let's uh print the whole

00:01:34,560 --> 00:01:39,680
content of the container

00:01:36,240 --> 00:01:42,240
which in this case is only hello

00:01:39,680 --> 00:01:43,520
so let's start with a few basics before

00:01:42,240 --> 00:01:46,960
we go into detail

00:01:43,520 --> 00:01:49,040
of move semantics so first of all

00:01:46,960 --> 00:01:51,680
and for the rest of this talk i will

00:01:49,040 --> 00:01:53,840
skip the qualification of scd

00:01:51,680 --> 00:01:54,799
and except for moving forward to make

00:01:53,840 --> 00:01:57,200
clear because

00:01:54,799 --> 00:01:58,320
that we use here key elements of move

00:01:57,200 --> 00:02:01,280
semantics

00:01:58,320 --> 00:02:03,759
and then i will use pretty short strings

00:02:01,280 --> 00:02:06,320
which usually don't benefit from move

00:02:03,759 --> 00:02:08,479
so let me uh please tell you that we

00:02:06,320 --> 00:02:09,759
assume we have no small string

00:02:08,479 --> 00:02:11,680
optimization

00:02:09,759 --> 00:02:13,120
or that these strings are have

00:02:11,680 --> 00:02:16,239
significant size

00:02:13,120 --> 00:02:17,120
so when we um move to somewhere the

00:02:16,239 --> 00:02:20,400
whole string

00:02:17,120 --> 00:02:22,400
is um the memory is moved

00:02:20,400 --> 00:02:24,000
or copied depending on whether we have a

00:02:22,400 --> 00:02:26,080
move or copy

00:02:24,000 --> 00:02:27,200
and then i have a helper function where

00:02:26,080 --> 00:02:30,160
i can print out

00:02:27,200 --> 00:02:31,599
the memory this string internally uses

00:02:30,160 --> 00:02:34,879
so you see it here

00:02:31,599 --> 00:02:38,239
we print out where this string scr was

00:02:34,879 --> 00:02:39,519
allocated the internal the internal

00:02:38,239 --> 00:02:42,959
memory of the screen

00:02:39,519 --> 00:02:43,519
so the string data so and what we can

00:02:42,959 --> 00:02:45,760
see here

00:02:43,519 --> 00:02:47,760
at the beginning is um now when we

00:02:45,760 --> 00:02:49,680
insert a string as it is without

00:02:47,760 --> 00:02:52,000
qualifying it with move

00:02:49,680 --> 00:02:53,440
we see that the string gets copied we

00:02:52,000 --> 00:02:56,480
have a different address

00:02:53,440 --> 00:03:01,200
when the string is inside the

00:02:56,480 --> 00:03:04,159
container and yeah so we copy

00:03:01,200 --> 00:03:06,560
good and the whole idea of move semantic

00:03:04,159 --> 00:03:08,159
is that we avoid these copies because

00:03:06,560 --> 00:03:11,200
copying is expensive

00:03:08,159 --> 00:03:12,720
so we avoid these copies when we can

00:03:11,200 --> 00:03:14,480
and when we should and when we would

00:03:12,720 --> 00:03:18,560
like to do that

00:03:14,480 --> 00:03:22,000
so let's um now come up with a

00:03:18,560 --> 00:03:25,360
new function returning a string by value

00:03:22,000 --> 00:03:28,560
and use it and as you see

00:03:25,360 --> 00:03:29,519
if you directly use this string to

00:03:28,560 --> 00:03:33,120
insert it

00:03:29,519 --> 00:03:36,319
into the container um

00:03:33,120 --> 00:03:38,239
it gets copied again while that

00:03:36,319 --> 00:03:39,440
because in our class we have no support

00:03:38,239 --> 00:03:44,080
for move semantics

00:03:39,440 --> 00:03:46,239
yet and uh yeah so we have a copy

00:03:44,080 --> 00:03:47,440
so how can we improve that well the

00:03:46,239 --> 00:03:50,560
usual way as

00:03:47,440 --> 00:03:52,480
a vector class for example does it um we

00:03:50,560 --> 00:03:54,319
overload the inserters

00:03:52,480 --> 00:03:55,680
for to have some support for move

00:03:54,319 --> 00:03:57,840
semantics

00:03:55,680 --> 00:04:01,360
and that means we have a new function

00:03:57,840 --> 00:04:04,319
insert taking an r value reference

00:04:01,360 --> 00:04:06,159
we take the value here the the temporary

00:04:04,319 --> 00:04:08,959
value that comes here

00:04:06,159 --> 00:04:09,280
we get the compiler automatically calls

00:04:08,959 --> 00:04:11,360
this

00:04:09,280 --> 00:04:12,480
insert function because the compiler

00:04:11,360 --> 00:04:14,959
knows that this

00:04:12,480 --> 00:04:16,959
object is about to die it's a so-called

00:04:14,959 --> 00:04:20,000
pr value

00:04:16,959 --> 00:04:23,360
and this value is moved then

00:04:20,000 --> 00:04:26,000
internally inside the container

00:04:23,360 --> 00:04:27,040
now you might wonder why the hell if

00:04:26,000 --> 00:04:29,280
this object

00:04:27,040 --> 00:04:32,000
has move semantics as a temporary object

00:04:29,280 --> 00:04:35,600
why do i have to qualify the move here

00:04:32,000 --> 00:04:38,560
and the question the the answer is if

00:04:35,600 --> 00:04:39,360
if the caller of the function says i no

00:04:38,560 --> 00:04:42,960
longer need

00:04:39,360 --> 00:04:46,479
this value the receiver of this value

00:04:42,960 --> 00:04:48,560
still has to say when uh this code no

00:04:46,479 --> 00:04:49,840
longer needs the value you might use it

00:04:48,560 --> 00:04:52,479
multiple times

00:04:49,840 --> 00:04:54,400
and so in this case on the last time we

00:04:52,479 --> 00:04:55,040
use it we need it which is the only time

00:04:54,400 --> 00:04:58,080
here

00:04:55,040 --> 00:04:58,800
we here move then this value into the

00:04:58,080 --> 00:05:02,400
container

00:04:58,800 --> 00:05:04,960
and as you see now now the address of

00:05:02,400 --> 00:05:05,680
the memory internal memory of the string

00:05:04,960 --> 00:05:08,400
is moved

00:05:05,680 --> 00:05:09,199
into the container so we have move

00:05:08,400 --> 00:05:12,160
semantics

00:05:09,199 --> 00:05:12,560
implemented here so far so good if

00:05:12,160 --> 00:05:14,800
you're

00:05:12,560 --> 00:05:15,600
familiar a little bit with move somatics

00:05:14,800 --> 00:05:18,639
that might be

00:05:15,600 --> 00:05:21,759
nothing new for you so

00:05:18,639 --> 00:05:23,919
the only benefit from this is assume we

00:05:21,759 --> 00:05:25,520
have here the beginning where we copy

00:05:23,919 --> 00:05:27,280
the string

00:05:25,520 --> 00:05:28,720
we have a name for the string and we

00:05:27,280 --> 00:05:33,039
insert it

00:05:28,720 --> 00:05:35,520
and here we directly use a return value

00:05:33,039 --> 00:05:36,720
it's a good idea if you use move

00:05:35,520 --> 00:05:40,000
semantics to avoid

00:05:36,720 --> 00:05:43,039
objects with names

00:05:40,000 --> 00:05:45,680
okay a few things here first of all

00:05:43,039 --> 00:05:46,240
um look at the top of this function this

00:05:45,680 --> 00:05:50,560
function

00:05:46,240 --> 00:05:54,160
returns a string so an scd string here

00:05:50,560 --> 00:05:57,840
if we come up to return a con

00:05:54,160 --> 00:05:59,520
string then move semantics will be

00:05:57,840 --> 00:06:02,160
broken

00:05:59,520 --> 00:06:04,319
um you see that here we have here

00:06:02,160 --> 00:06:07,759
copying now and you see that in the

00:06:04,319 --> 00:06:10,479
internal data the address we had

00:06:07,759 --> 00:06:11,759
for this string when we got it returned

00:06:10,479 --> 00:06:14,400
from get string

00:06:11,759 --> 00:06:16,080
is now internally we have a different

00:06:14,400 --> 00:06:18,960
memory and and it's clear

00:06:16,080 --> 00:06:20,400
because we pass a constant string to

00:06:18,960 --> 00:06:22,960
move semantics

00:06:20,400 --> 00:06:23,919
and this constant string here in insert

00:06:22,960 --> 00:06:26,319
um

00:06:23,919 --> 00:06:28,400
is not allowed to be modified the usual

00:06:26,319 --> 00:06:29,840
way to implement move semantics is to

00:06:28,400 --> 00:06:32,960
steal some value

00:06:29,840 --> 00:06:34,080
but that is only possible for an other

00:06:32,960 --> 00:06:37,280
eu reference

00:06:34,080 --> 00:06:37,840
for string that is not cons so in this

00:06:37,280 --> 00:06:41,919
case

00:06:37,840 --> 00:06:42,720
um here not this implementation will be

00:06:41,919 --> 00:06:46,080
called

00:06:42,720 --> 00:06:46,479
this insert will call the normal insert

00:06:46,080 --> 00:06:48,960
for

00:06:46,479 --> 00:06:50,880
const strings where we still need the

00:06:48,960 --> 00:06:53,680
value

00:06:50,880 --> 00:06:54,160
so move semantic is disabled with cons

00:06:53,680 --> 00:06:56,639
and

00:06:54,160 --> 00:06:58,479
by the way that means if you have

00:06:56,639 --> 00:06:59,280
functions and if you have learned for

00:06:58,479 --> 00:07:02,319
some reason

00:06:59,280 --> 00:07:02,800
in the past that when you return by

00:07:02,319 --> 00:07:05,199
value

00:07:02,800 --> 00:07:07,120
you might better qualify this by cons

00:07:05,199 --> 00:07:11,039
please don't do that anymore

00:07:07,120 --> 00:07:13,599
because you are as you see a hindering

00:07:11,039 --> 00:07:14,319
move semantics yeah that means your

00:07:13,599 --> 00:07:17,759
program

00:07:14,319 --> 00:07:21,120
runs unnecessary long so don't do that

00:07:17,759 --> 00:07:24,160
anymore okay

00:07:21,120 --> 00:07:25,199
so um you might see okay here in my

00:07:24,160 --> 00:07:27,440
implementation

00:07:25,199 --> 00:07:30,240
i take a string and i move it then in

00:07:27,440 --> 00:07:34,000
the internal vector here of this class

00:07:30,240 --> 00:07:36,479
so let's see how we um

00:07:34,000 --> 00:07:39,039
does it mean that we also programmer

00:07:36,479 --> 00:07:42,080
also sometimes need move

00:07:39,039 --> 00:07:46,319
because you don't see a move here

00:07:42,080 --> 00:07:49,039
however you can't avoid using move and

00:07:46,319 --> 00:07:50,560
from time to time i hear people saying

00:07:49,039 --> 00:07:53,599
that

00:07:50,560 --> 00:07:55,280
try to avoid move but it's easier said

00:07:53,599 --> 00:07:58,960
than done

00:07:55,280 --> 00:08:01,280
so let's uh see uh

00:07:58,960 --> 00:08:03,599
for some some examples where we need a

00:08:01,280 --> 00:08:07,039
move for example here

00:08:03,599 --> 00:08:08,879
um if your object has a name so if it's

00:08:07,039 --> 00:08:12,080
a parameter for example

00:08:08,879 --> 00:08:15,199
you need move to move it to somewhere

00:08:12,080 --> 00:08:16,240
but this is not the only case um if you

00:08:15,199 --> 00:08:19,199
need it twice

00:08:16,240 --> 00:08:20,639
like here let's uh do something let's

00:08:19,199 --> 00:08:23,039
print the value out with

00:08:20,639 --> 00:08:25,120
its memory and then let's move it in if

00:08:23,039 --> 00:08:27,280
you need an object twice

00:08:25,120 --> 00:08:29,840
you need a name for it whether the name

00:08:27,280 --> 00:08:32,719
is the value or reference doesn't matter

00:08:29,840 --> 00:08:33,839
but if you need the same object twice um

00:08:32,719 --> 00:08:36,880
you can't

00:08:33,839 --> 00:08:40,560
do that um without or

00:08:36,880 --> 00:08:43,839
yeah normally without any big effort

00:08:40,560 --> 00:08:47,760
and so

00:08:43,839 --> 00:08:51,120
in this case that means now we qualify

00:08:47,760 --> 00:08:55,040
sdr here with move to say um we no

00:08:51,120 --> 00:08:58,160
longer need this value

00:08:55,040 --> 00:08:59,920
and so we have a couple of reasons as a

00:08:58,160 --> 00:09:02,480
programmer to use

00:08:59,920 --> 00:09:05,120
move even as an application programmer

00:09:02,480 --> 00:09:06,640
so um you need it for parameters so if

00:09:05,120 --> 00:09:09,600
you have a parameter you

00:09:06,640 --> 00:09:11,600
no longer need the value move but you

00:09:09,600 --> 00:09:13,360
need it also for arguments on the other

00:09:11,600 --> 00:09:16,640
side the calling side

00:09:13,360 --> 00:09:16,959
um of a function so a famous example is

00:09:16,640 --> 00:09:19,560
get

00:09:16,959 --> 00:09:20,720
line let's read from a stream a new

00:09:19,560 --> 00:09:23,600
string

00:09:20,720 --> 00:09:25,040
into sdr here and that's an out

00:09:23,600 --> 00:09:29,040
parameter

00:09:25,040 --> 00:09:32,160
which of course also has a name and

00:09:29,040 --> 00:09:35,279
if you return values or just values use

00:09:32,160 --> 00:09:37,440
multiple times as you see here and

00:09:35,279 --> 00:09:39,760
last not least sometimes it's more

00:09:37,440 --> 00:09:42,720
readable to have names for objects

00:09:39,760 --> 00:09:44,160
and the most important thing still is

00:09:42,720 --> 00:09:47,279
that we have readable

00:09:44,160 --> 00:09:50,560
and maintainable code

00:09:47,279 --> 00:09:52,399
so let's um so there are a couple of

00:09:50,560 --> 00:09:53,839
of reasons to use move so move is

00:09:52,399 --> 00:09:55,120
something you should know you should

00:09:53,839 --> 00:09:58,640
understand

00:09:55,120 --> 00:10:02,399
and please note that after this move

00:09:58,640 --> 00:10:05,839
the string you are still able to use

00:10:02,399 --> 00:10:09,279
um move means i no longer

00:10:05,839 --> 00:10:10,720
need this value here um almost every

00:10:09,279 --> 00:10:14,240
word counts here

00:10:10,720 --> 00:10:17,839
i no longer need the value of str here

00:10:14,240 --> 00:10:18,720
you do not partially destroy as they are

00:10:17,839 --> 00:10:21,600
um

00:10:18,720 --> 00:10:22,000
the sdr will still be there it will just

00:10:21,600 --> 00:10:25,040
have

00:10:22,000 --> 00:10:28,800
some valid some value it will be valid

00:10:25,040 --> 00:10:32,079
and will just have some value

00:10:28,800 --> 00:10:35,680
okay and again note that cons

00:10:32,079 --> 00:10:38,480
will um will have the effect

00:10:35,680 --> 00:10:38,959
that you no longer move so uh here you

00:10:38,480 --> 00:10:41,040
see

00:10:38,959 --> 00:10:42,000
the whole program if the return value

00:10:41,040 --> 00:10:44,640
from getzer

00:10:42,000 --> 00:10:45,360
is assigned to a con string and we call

00:10:44,640 --> 00:10:49,120
move

00:10:45,360 --> 00:10:51,920
then we will have a different

00:10:49,120 --> 00:10:52,560
value in the container because the

00:10:51,920 --> 00:10:55,600
copying

00:10:52,560 --> 00:10:58,720
insert function is used um

00:10:55,600 --> 00:11:00,580
you might wonder why we don't think

00:10:58,720 --> 00:11:02,160
this is an error um

00:11:00,580 --> 00:11:06,079
[Music]

00:11:02,160 --> 00:11:09,120
if i have a cons so move has no effect

00:11:06,079 --> 00:11:09,760
um why why shouldn't i have an error

00:11:09,120 --> 00:11:12,720
here

00:11:09,760 --> 00:11:13,760
well think about generic code where we

00:11:12,720 --> 00:11:17,600
have templates

00:11:13,760 --> 00:11:19,920
you might get this str of a type t

00:11:17,600 --> 00:11:20,800
so this type t might or might not be

00:11:19,920 --> 00:11:22,720
const

00:11:20,800 --> 00:11:24,000
and your generic code should work in

00:11:22,720 --> 00:11:27,839
both cases

00:11:24,000 --> 00:11:30,560
so in that case um if it's not cons

00:11:27,839 --> 00:11:31,440
the move would have an effect and if it

00:11:30,560 --> 00:11:34,160
is cons

00:11:31,440 --> 00:11:36,079
the sdr the move will just be ignored

00:11:34,160 --> 00:11:38,240
and the fallback mechanism of move

00:11:36,079 --> 00:11:41,440
semantics will be used and that means

00:11:38,240 --> 00:11:41,680
we fall back to um copy semantics which

00:11:41,440 --> 00:11:44,959
is

00:11:41,680 --> 00:11:45,839
implemented here however there's

00:11:44,959 --> 00:11:49,120
something

00:11:45,839 --> 00:11:52,480
which not everybody knows in c plus

00:11:49,120 --> 00:11:55,040
um it's uh it's possible to get to

00:11:52,480 --> 00:11:58,240
overload for cons

00:11:55,040 --> 00:11:59,040
moved values or cons values that are

00:11:58,240 --> 00:12:03,040
marked with

00:11:59,040 --> 00:12:07,200
move i should say so here it is

00:12:03,040 --> 00:12:10,560
um this is a insert insert takes a const

00:12:07,200 --> 00:12:13,920
string r value reference this is

00:12:10,560 --> 00:12:16,079
technically possible in c plus plus

00:12:13,920 --> 00:12:18,000
and the only problem is we have no real

00:12:16,079 --> 00:12:20,639
semantic meaning for that

00:12:18,000 --> 00:12:22,240
because usually the contract of move

00:12:20,639 --> 00:12:24,880
semantics means

00:12:22,240 --> 00:12:25,760
for the caller i no longer need the

00:12:24,880 --> 00:12:28,160
value

00:12:25,760 --> 00:12:30,000
and for those who implement against that

00:12:28,160 --> 00:12:33,040
okay i can see the value

00:12:30,000 --> 00:12:33,440
but um i have to ensure that there is

00:12:33,040 --> 00:12:36,320
still

00:12:33,440 --> 00:12:38,160
at the end a valid string here so that

00:12:36,320 --> 00:12:40,320
the caller can still use a string

00:12:38,160 --> 00:12:43,440
without knowing its value

00:12:40,320 --> 00:12:45,680
so if you say i no longer need the value

00:12:43,440 --> 00:12:46,959
but you are not allowed to modify the

00:12:45,680 --> 00:12:50,079
string that's a

00:12:46,959 --> 00:12:52,399
semantic contradiction so it makes no

00:12:50,079 --> 00:12:55,760
real sense it's possible to do that

00:12:52,399 --> 00:12:58,160
and i bet we will have a usage for that

00:12:55,760 --> 00:13:00,079
it's a useful usage for that and c plus

00:12:58,160 --> 00:13:02,880
plus s with everything

00:13:00,079 --> 00:13:04,000
um but in general it makes no sense to

00:13:02,880 --> 00:13:06,880
implement

00:13:04,000 --> 00:13:07,600
functions like this i think we have

00:13:06,880 --> 00:13:10,480
almost

00:13:07,600 --> 00:13:11,120
no place in c plus plus whatever you

00:13:10,480 --> 00:13:13,519
said

00:13:11,120 --> 00:13:14,399
just in some wrapper types where we wrap

00:13:13,519 --> 00:13:17,120
behavior

00:13:14,399 --> 00:13:18,240
and just in case somebody has special

00:13:17,120 --> 00:13:20,880
behavior for that

00:13:18,240 --> 00:13:22,320
we don't want to change the behavior and

00:13:20,880 --> 00:13:25,120
we have overloaders or

00:13:22,320 --> 00:13:25,760
overloads for cons our value references

00:13:25,120 --> 00:13:27,839
look at

00:13:25,760 --> 00:13:29,360
class optional for example it has

00:13:27,839 --> 00:13:32,639
overloads for cons

00:13:29,360 --> 00:13:32,639
are value references

00:13:32,880 --> 00:13:40,079
okay so far so good um

00:13:36,160 --> 00:13:43,440
that's uh that's it that's the uh

00:13:40,079 --> 00:13:44,959
the basics of this class and um

00:13:43,440 --> 00:13:48,320
of course we should finally make it

00:13:44,959 --> 00:13:50,240
generic and that means i would take the

00:13:48,320 --> 00:13:53,920
class and say okay this class is

00:13:50,240 --> 00:13:56,320
parameterized for template parameter t

00:13:53,920 --> 00:13:58,000
so we have internally a vector of ts and

00:13:56,320 --> 00:14:01,040
we are inserting a const

00:13:58,000 --> 00:14:02,880
reference or a t other

00:14:01,040 --> 00:14:04,320
reference so this is an l value

00:14:02,880 --> 00:14:06,160
reference so

00:14:04,320 --> 00:14:08,720
this is the insert when we still need

00:14:06,160 --> 00:14:09,199
the value um the caller still needs a

00:14:08,720 --> 00:14:11,199
value

00:14:09,199 --> 00:14:12,399
this is a function is called when the

00:14:11,199 --> 00:14:15,519
caller no

00:14:12,399 --> 00:14:19,199
longer needs the value

00:14:15,519 --> 00:14:19,760
so um that um here's a question by the

00:14:19,199 --> 00:14:21,920
way

00:14:19,760 --> 00:14:24,079
in the in the in the talk the question

00:14:21,920 --> 00:14:26,959
is why i'm using pushback and not

00:14:24,079 --> 00:14:28,639
and faceback well uh can we use and

00:14:26,959 --> 00:14:30,399
place back yes of course you can use

00:14:28,639 --> 00:14:33,440
employees back here

00:14:30,399 --> 00:14:34,399
it's also possible and it works and

00:14:33,440 --> 00:14:39,199
placeback has

00:14:34,399 --> 00:14:41,440
all support for move semantics and

00:14:39,199 --> 00:14:44,000
please note that usually the

00:14:41,440 --> 00:14:47,519
implementations of pushback just call

00:14:44,000 --> 00:14:49,600
in place back for this whole argument so

00:14:47,519 --> 00:14:50,800
therefore it's it's always possible we

00:14:49,600 --> 00:14:53,440
still recommend

00:14:50,800 --> 00:14:56,000
to use pushback if you have already an

00:14:53,440 --> 00:14:58,880
object of the right type

00:14:56,000 --> 00:14:59,279
or expect an object of the right type

00:14:58,880 --> 00:15:01,040
while

00:14:59,279 --> 00:15:03,120
i'm using and place back if you have

00:15:01,040 --> 00:15:05,519
something that is used to create the

00:15:03,120 --> 00:15:07,760
object on the fly or in the vector

00:15:05,519 --> 00:15:10,079
so but yes you can use them place back

00:15:07,760 --> 00:15:10,079
here

00:15:10,399 --> 00:15:16,959
okay so and as we have a container now

00:15:14,079 --> 00:15:18,560
um let's use a container of bool and

00:15:16,959 --> 00:15:21,279
that's also possible

00:15:18,560 --> 00:15:23,519
uh so we have here a type bool which has

00:15:21,279 --> 00:15:26,399
no special support for move semantics

00:15:23,519 --> 00:15:27,519
it's just a fundamental data type but it

00:15:26,399 --> 00:15:30,560
works

00:15:27,519 --> 00:15:32,399
move for bool does not have any effect

00:15:30,560 --> 00:15:34,240
we can insert false we can insert

00:15:32,399 --> 00:15:38,959
through we can print that out

00:15:34,240 --> 00:15:38,959
and you see that the output works here

00:15:39,600 --> 00:15:44,639
okay so to some extent

00:15:42,639 --> 00:15:46,160
that's the basics and that was what is

00:15:44,639 --> 00:15:49,360
usually um

00:15:46,160 --> 00:15:51,759
taught in trainings that talk about c

00:15:49,360 --> 00:15:54,639
plus or move semantics or modern c plus

00:15:51,759 --> 00:15:56,720
plus or whatsoever

00:15:54,639 --> 00:15:58,720
so now let's let's look at some more

00:15:56,720 --> 00:16:02,000
interesting stuff

00:15:58,720 --> 00:16:05,440
so first of all here look at this

00:16:02,000 --> 00:16:08,399
side we have an overload for two

00:16:05,440 --> 00:16:09,519
insert functions so one for const l

00:16:08,399 --> 00:16:12,560
value reference

00:16:09,519 --> 00:16:15,120
one for non-const r value reference

00:16:12,560 --> 00:16:15,839
in principle you can have two others you

00:16:15,120 --> 00:16:18,320
can have

00:16:15,839 --> 00:16:20,000
one for non-const l value reference

00:16:18,320 --> 00:16:22,320
semantic meaning would be

00:16:20,000 --> 00:16:23,279
um i have an output parameter on in out

00:16:22,320 --> 00:16:25,440
parameter

00:16:23,279 --> 00:16:27,040
here the semantic meaning is i have an

00:16:25,440 --> 00:16:28,959
in parameter and here the

00:16:27,040 --> 00:16:30,240
thematic meaning is i have something you

00:16:28,959 --> 00:16:34,000
can steal so

00:16:30,240 --> 00:16:36,079
to adopt uh from from me as a caller

00:16:34,000 --> 00:16:38,399
and we have seen they have this a little

00:16:36,079 --> 00:16:41,600
bit esoteric case

00:16:38,399 --> 00:16:44,720
of a cons t double refer

00:16:41,600 --> 00:16:48,480
double ampersand so um r value reference

00:16:44,720 --> 00:16:51,920
uh for a const t so that's

00:16:48,480 --> 00:16:54,800
between two and four overloads and um

00:16:51,920 --> 00:16:55,839
if you put past multiple arguments and

00:16:54,800 --> 00:16:59,199
you want to support

00:16:55,839 --> 00:17:01,120
our cases perfectly um then you need all

00:16:59,199 --> 00:17:02,320
combinations of these overload so

00:17:01,120 --> 00:17:05,439
between four

00:17:02,320 --> 00:17:07,280
and 16 overloads you need then and for

00:17:05,439 --> 00:17:10,559
three arguments you would then need

00:17:07,280 --> 00:17:13,679
um eight or um

00:17:10,559 --> 00:17:16,959
three nine 20

00:17:13,679 --> 00:17:20,799
27 overloads something like that

00:17:16,959 --> 00:17:24,079
and that's of course something we

00:17:20,799 --> 00:17:26,799
don't want to do at the end so

00:17:24,079 --> 00:17:29,120
can we somehow combine this insert

00:17:26,799 --> 00:17:33,600
function into one function

00:17:29,120 --> 00:17:37,120
and there are two answers um

00:17:33,600 --> 00:17:40,720
the first answer is yes you can simply

00:17:37,120 --> 00:17:41,679
insert the value by taking it by value

00:17:40,720 --> 00:17:45,280
and move

00:17:41,679 --> 00:17:49,039
and surprisingly for types that

00:17:45,280 --> 00:17:51,919
have not where moving is not expensive

00:17:49,039 --> 00:17:53,039
this is not worse um i've done some

00:17:51,919 --> 00:17:56,480
measurements with

00:17:53,039 --> 00:18:00,000
the strings and you only

00:17:56,480 --> 00:18:03,440
add some more moves which are cheap for

00:18:00,000 --> 00:18:04,720
strings um but it as it works the

00:18:03,440 --> 00:18:07,760
following way

00:18:04,720 --> 00:18:09,600
whenever we push back a new value into

00:18:07,760 --> 00:18:13,520
the vector

00:18:09,600 --> 00:18:16,480
um we anyway have to create a new object

00:18:13,520 --> 00:18:17,200
a new element in this case of the vector

00:18:16,480 --> 00:18:20,559
so

00:18:17,200 --> 00:18:23,679
all we do is we create it earlier here

00:18:20,559 --> 00:18:24,240
whatever we get we get it by value and

00:18:23,679 --> 00:18:27,120
as an

00:18:24,240 --> 00:18:29,120
only exception if somebody is giving me

00:18:27,120 --> 00:18:29,840
a temporary object or an object mark

00:18:29,120 --> 00:18:32,720
with move

00:18:29,840 --> 00:18:33,679
if we pass by value this is move

00:18:32,720 --> 00:18:35,520
initialize

00:18:33,679 --> 00:18:37,039
or this v is moved to initialize with

00:18:35,520 --> 00:18:39,760
that value so

00:18:37,039 --> 00:18:40,640
whatever we get we either create here an

00:18:39,760 --> 00:18:43,039
object or

00:18:40,640 --> 00:18:44,400
if we got a movable object we create

00:18:43,039 --> 00:18:47,440
here our v

00:18:44,400 --> 00:18:50,320
and then we move it into the vector

00:18:47,440 --> 00:18:51,919
so the number of memory allocations for

00:18:50,320 --> 00:18:55,039
strings are the same

00:18:51,919 --> 00:18:58,080
the number of moves grew up and

00:18:55,039 --> 00:19:00,559
you can always do that if you have to um

00:18:58,080 --> 00:19:01,120
yeah if you really in all cases have to

00:19:00,559 --> 00:19:05,200
adopt

00:19:01,120 --> 00:19:08,559
things and adopt values so you anyway

00:19:05,200 --> 00:19:10,480
have to create your own copy or store

00:19:08,559 --> 00:19:13,520
your own copy of the value

00:19:10,480 --> 00:19:16,480
a typical example are constructors

00:19:13,520 --> 00:19:18,000
and your constructor can take an

00:19:16,480 --> 00:19:20,799
argument by value

00:19:18,000 --> 00:19:24,080
and move it into the into the member if

00:19:20,799 --> 00:19:27,440
you have a string member also

00:19:24,080 --> 00:19:30,320
um however be careful with that

00:19:27,440 --> 00:19:32,400
um it's not always a good strategy it

00:19:30,320 --> 00:19:35,919
works sometimes so

00:19:32,400 --> 00:19:38,880
move semantics makes a call by value and

00:19:35,919 --> 00:19:42,000
return by value cheap as long

00:19:38,880 --> 00:19:44,080
as what you return or what you pass is

00:19:42,000 --> 00:19:46,080
an r value which means which is an

00:19:44,080 --> 00:19:46,960
object you no longer need a temporary

00:19:46,080 --> 00:19:51,679
object

00:19:46,960 --> 00:19:55,039
or an object marked with moves

00:19:51,679 --> 00:19:56,960
so yes you can take by value and move

00:19:55,039 --> 00:19:58,559
and you can use that for example to

00:19:56,960 --> 00:20:00,320
initialize string members in a

00:19:58,559 --> 00:20:04,080
constructor

00:20:00,320 --> 00:20:07,120
um however let's look at another example

00:20:04,080 --> 00:20:08,320
um don't do that all the time don't do

00:20:07,120 --> 00:20:11,440
that for example

00:20:08,320 --> 00:20:14,960
when move is then moves are expensive

00:20:11,440 --> 00:20:17,360
or in this case here insert if

00:20:14,960 --> 00:20:19,120
if i take a value and i don't know

00:20:17,360 --> 00:20:22,159
whether i need this value

00:20:19,120 --> 00:20:24,640
so i have here an if condition and uh to

00:20:22,159 --> 00:20:28,000
some extent i will push back well yeah

00:20:24,640 --> 00:20:30,960
between the dot or dots there's a v

00:20:28,000 --> 00:20:31,520
dot our dots i use here because we might

00:20:30,960 --> 00:20:34,559
need

00:20:31,520 --> 00:20:35,520
a move or not here so whatever we want

00:20:34,559 --> 00:20:37,760
to do here

00:20:35,520 --> 00:20:39,200
um if it's conditional whether we need

00:20:37,760 --> 00:20:42,159
the object or not

00:20:39,200 --> 00:20:44,480
um then this is not a good strategy for

00:20:42,159 --> 00:20:46,880
temporary objects it's still okay

00:20:44,480 --> 00:20:48,320
because anyway we move the temporary

00:20:46,880 --> 00:20:51,600
object here as

00:20:48,320 --> 00:20:53,840
2v and then we might or might not use it

00:20:51,600 --> 00:20:57,200
and move it into the vector

00:20:53,840 --> 00:21:00,480
but if you have a non an object that is

00:20:57,200 --> 00:21:02,080
not movable so like an l value so an

00:21:00,480 --> 00:21:04,720
object with a name

00:21:02,080 --> 00:21:05,679
then it could be expensive we would copy

00:21:04,720 --> 00:21:08,480
the object

00:21:05,679 --> 00:21:10,720
although we might not move it into the

00:21:08,480 --> 00:21:14,080
vector

00:21:10,720 --> 00:21:16,080
so what could we do instead well

00:21:14,080 --> 00:21:17,120
we could um well first of all i should

00:21:16,080 --> 00:21:19,600
say

00:21:17,120 --> 00:21:21,120
don't take by value and move if you set

00:21:19,600 --> 00:21:24,480
an existing value

00:21:21,120 --> 00:21:27,919
you have already memory for this value

00:21:24,480 --> 00:21:30,400
so setters should not use this technique

00:21:27,919 --> 00:21:31,039
inserters could but conditional

00:21:30,400 --> 00:21:34,640
inserters

00:21:31,039 --> 00:21:36,480
should not um you might not

00:21:34,640 --> 00:21:38,880
like here you might not adopt the value

00:21:36,480 --> 00:21:42,320
and if move is expensive

00:21:38,880 --> 00:21:45,600
so if your object has one 1000

00:21:42,320 --> 00:21:46,320
an std area of 1000 doubles that could

00:21:45,600 --> 00:21:50,159
be

00:21:46,320 --> 00:21:50,159
um and a problem

00:21:50,720 --> 00:21:54,240
at least from performance point of view

00:21:53,600 --> 00:21:57,120
so

00:21:54,240 --> 00:21:58,000
what can you do then instead and the

00:21:57,120 --> 00:22:00,159
usual way

00:21:58,000 --> 00:22:01,840
you use that is use some perfect

00:22:00,159 --> 00:22:04,159
forwarding

00:22:01,840 --> 00:22:05,600
so perfect forwarding um most of you

00:22:04,159 --> 00:22:09,120
probably have heard that

00:22:05,600 --> 00:22:12,559
the audience and cppcon is usually um

00:22:09,120 --> 00:22:13,280
some expert has some level but um let me

00:22:12,559 --> 00:22:16,640
just

00:22:13,280 --> 00:22:18,880
bring up the usual three rules of three

00:22:16,640 --> 00:22:21,760
things you need to have a

00:22:18,880 --> 00:22:22,640
universal reference um a universal

00:22:21,760 --> 00:22:25,600
reference is

00:22:22,640 --> 00:22:27,200
something where you say let's take the

00:22:25,600 --> 00:22:31,440
parameter and as it is

00:22:27,200 --> 00:22:33,039
forward it somewhere else and um

00:22:31,440 --> 00:22:34,640
so there are three things you need you

00:22:33,039 --> 00:22:37,760
need a template parameter

00:22:34,640 --> 00:22:38,559
and r value reference argument and s3

00:22:37,760 --> 00:22:41,280
forward

00:22:38,559 --> 00:22:41,679
so here's a way to do that this looks

00:22:41,280 --> 00:22:44,320
like

00:22:41,679 --> 00:22:46,720
we are hitting the point so that's a

00:22:44,320 --> 00:22:50,400
template parameter to ampersand

00:22:46,720 --> 00:22:53,280
here and then we use

00:22:50,400 --> 00:22:54,240
pushback and as you might have learned

00:22:53,280 --> 00:22:57,360
already

00:22:54,240 --> 00:22:58,000
this pushback should be a conditional

00:22:57,360 --> 00:23:00,960
move

00:22:58,000 --> 00:23:01,760
so it should only move and if we have

00:23:00,960 --> 00:23:05,919
here

00:23:01,760 --> 00:23:07,919
um in what we pass is movable

00:23:05,919 --> 00:23:09,840
and the interesting thing is to this r

00:23:07,919 --> 00:23:11,760
value reference you can't pass

00:23:09,840 --> 00:23:13,600
everything you want oh there's a bug in

00:23:11,760 --> 00:23:17,360
this slide this

00:23:13,600 --> 00:23:20,720
you should be a t of course

00:23:17,360 --> 00:23:22,880
and uh okay um

00:23:20,720 --> 00:23:25,360
so first of all a couple of things to

00:23:22,880 --> 00:23:28,559
qualify to clarify here

00:23:25,360 --> 00:23:29,600
um first of all i use the term universal

00:23:28,559 --> 00:23:32,000
reference

00:23:29,600 --> 00:23:33,120
you might think what the hell is he

00:23:32,000 --> 00:23:35,360
talking about

00:23:33,120 --> 00:23:36,400
because there are two terms for what we

00:23:35,360 --> 00:23:37,919
talk about here

00:23:36,400 --> 00:23:39,520
there's another term it's called

00:23:37,919 --> 00:23:42,000
forwarding reference

00:23:39,520 --> 00:23:44,559
it's a it's a nightmare and a mess we

00:23:42,000 --> 00:23:47,279
have in the seatbelt bus community here

00:23:44,559 --> 00:23:48,640
um we have introduced the terminal scott

00:23:47,279 --> 00:23:52,720
myers introduced this

00:23:48,640 --> 00:23:54,559
in 2012 right after c 11 was published

00:23:52,720 --> 00:23:57,120
and he used universal reference and you

00:23:54,559 --> 00:23:58,000
can still use this term in a couple of

00:23:57,120 --> 00:24:00,480
books

00:23:58,000 --> 00:24:01,520
and still find it in a couple of chats

00:24:00,480 --> 00:24:05,200
and and some people

00:24:01,520 --> 00:24:07,120
like me are using it still and uh then

00:24:05,200 --> 00:24:10,240
the c plus one standards committee

00:24:07,120 --> 00:24:13,520
decided in 2014 after c

00:24:10,240 --> 00:24:14,799
plus 14 was out um that they want to

00:24:13,520 --> 00:24:16,400
change this name

00:24:14,799 --> 00:24:18,080
to forwarding reference actually they

00:24:16,400 --> 00:24:20,159
didn't have any name at all

00:24:18,080 --> 00:24:21,120
universal reference what not was not

00:24:20,159 --> 00:24:23,200
part of the c

00:24:21,120 --> 00:24:24,960
plus standard so they introduced the

00:24:23,200 --> 00:24:27,919
term forwarding reference

00:24:24,960 --> 00:24:28,240
which is sent formally uh the term for

00:24:27,919 --> 00:24:32,080
this

00:24:28,240 --> 00:24:34,240
in c plus plus 17. um this is um

00:24:32,080 --> 00:24:35,919
well we have we have enough problems

00:24:34,240 --> 00:24:39,520
with c plus plus with

00:24:35,919 --> 00:24:42,400
with all the rules now um

00:24:39,520 --> 00:24:43,520
intentionally uh introducing two

00:24:42,400 --> 00:24:46,480
different tabs

00:24:43,520 --> 00:24:47,600
uh just to confuse the audience and the

00:24:46,480 --> 00:24:49,760
people in the

00:24:47,600 --> 00:24:51,360
community even more i think is a

00:24:49,760 --> 00:24:54,159
nightmare in itself

00:24:51,360 --> 00:24:56,400
but um as we can see we still have the

00:24:54,159 --> 00:24:58,400
books of scott myers and we still saw

00:24:56,400 --> 00:25:00,320
books about universal reference and

00:24:58,400 --> 00:25:03,440
forwarding is used

00:25:00,320 --> 00:25:05,120
even worse um universal reference is

00:25:03,440 --> 00:25:08,720
probably the better term

00:25:05,120 --> 00:25:12,400
i will tell you about that in a moment

00:25:08,720 --> 00:25:14,080
so um so we have a it seems we have a

00:25:12,400 --> 00:25:16,159
universe reference a forwarding

00:25:14,080 --> 00:25:18,159
reference template parameter

00:25:16,159 --> 00:25:20,320
argument with the ampersand forward with

00:25:18,159 --> 00:25:20,880
sdu forward so we should perfectly

00:25:20,320 --> 00:25:23,120
forward

00:25:20,880 --> 00:25:24,559
the argument if it has move semantics

00:25:23,120 --> 00:25:28,559
otherwise we should

00:25:24,559 --> 00:25:31,279
not so

00:25:28,559 --> 00:25:32,000
this is what we have here um it works

00:25:31,279 --> 00:25:34,880
fine for

00:25:32,000 --> 00:25:36,159
temporary object so if we pass here a

00:25:34,880 --> 00:25:39,360
temporary object

00:25:36,159 --> 00:25:41,919
it works fine but if we try to

00:25:39,360 --> 00:25:44,080
insert an object that's not marked with

00:25:41,919 --> 00:25:45,760
move for an object with names what we

00:25:44,080 --> 00:25:49,279
call an l value

00:25:45,760 --> 00:25:52,960
this will not compile

00:25:49,279 --> 00:25:53,760
what is the problem well the rule of

00:25:52,960 --> 00:25:58,000
thumb

00:25:53,760 --> 00:26:00,559
i just showed you was not precise enough

00:25:58,000 --> 00:26:03,520
this is not a universal reference or

00:26:00,559 --> 00:26:06,480
this is not a forwarding reference

00:26:03,520 --> 00:26:08,000
there are additional constraints and you

00:26:06,480 --> 00:26:10,080
have to be very careful

00:26:08,000 --> 00:26:12,080
to find out what is the universal

00:26:10,080 --> 00:26:15,120
reference and what is not

00:26:12,080 --> 00:26:20,000
so here's um one condition

00:26:15,120 --> 00:26:22,799
um if t t it's not enough that t is a

00:26:20,000 --> 00:26:24,240
template parameter this t must be a

00:26:22,799 --> 00:26:27,440
template parameter of

00:26:24,240 --> 00:26:28,559
this function so here we have a template

00:26:27,440 --> 00:26:32,720
parameter

00:26:28,559 --> 00:26:35,440
here on top which belongs to the class

00:26:32,720 --> 00:26:36,400
so that does not make this a universal

00:26:35,440 --> 00:26:40,000
reference

00:26:36,400 --> 00:26:42,320
um this is this function does not

00:26:40,000 --> 00:26:43,440
fall under the roots of function

00:26:42,320 --> 00:26:46,240
templates

00:26:43,440 --> 00:26:48,960
it's what we call the temploid so it's

00:26:46,240 --> 00:26:52,000
it's some templified or generic code

00:26:48,960 --> 00:26:55,200
but it's in the moment we know type t

00:26:52,000 --> 00:26:57,360
for the class we have here find if

00:26:55,200 --> 00:26:58,640
as a normal member functions following

00:26:57,360 --> 00:27:02,000
the rules

00:26:58,640 --> 00:27:03,760
of ordinary member functions so this is

00:27:02,000 --> 00:27:07,039
not a universal reference

00:27:03,760 --> 00:27:09,279
once we know t we just accept only t

00:27:07,039 --> 00:27:10,080
with two ampersand and two p with two

00:27:09,279 --> 00:27:13,120
ampersand

00:27:10,080 --> 00:27:14,000
only accepts r values for only accepts

00:27:13,120 --> 00:27:16,320
objects

00:27:14,000 --> 00:27:17,840
that are marked with move or temporary

00:27:16,320 --> 00:27:19,919
objects

00:27:17,840 --> 00:27:21,200
there are a couple of other things that

00:27:19,919 --> 00:27:24,399
are not allowed or

00:27:21,200 --> 00:27:27,279
make this a not a universal reference

00:27:24,399 --> 00:27:27,919
so for example if this argument v is in

00:27:27,279 --> 00:27:30,399
addition

00:27:27,919 --> 00:27:32,240
qualified with const or volatile it's

00:27:30,399 --> 00:27:34,960
not a universal reference

00:27:32,240 --> 00:27:35,919
and if this t is not a pure t it's or

00:27:34,960 --> 00:27:38,320
not that just

00:27:35,919 --> 00:27:39,679
the type the template parameter type if

00:27:38,320 --> 00:27:42,080
you for example use t

00:27:39,679 --> 00:27:44,320
colon colon value type then it's also

00:27:42,080 --> 00:27:46,799
not a universal reference

00:27:44,320 --> 00:27:47,679
and so you have to look very very

00:27:46,799 --> 00:27:49,360
carefully

00:27:47,679 --> 00:27:51,840
when you see two ampersands in a

00:27:49,360 --> 00:27:55,360
declaration to understand what it is

00:27:51,840 --> 00:27:57,279
and what it is not and it's probably the

00:27:55,360 --> 00:27:59,760
biggest mistake we made

00:27:57,279 --> 00:28:00,320
with move semantics that we had no

00:27:59,760 --> 00:28:02,880
special

00:28:00,320 --> 00:28:03,840
syntax for universal or forwarding

00:28:02,880 --> 00:28:05,520
references

00:28:03,840 --> 00:28:07,760
if we would have another syntax some

00:28:05,520 --> 00:28:10,880
people sometimes say three ampersand

00:28:07,760 --> 00:28:12,559
which make everybody laugh but

00:28:10,880 --> 00:28:14,480
it would help we would understand the

00:28:12,559 --> 00:28:17,600
rules and there are different rules

00:28:14,480 --> 00:28:18,880
in addition we have problems that we how

00:28:17,600 --> 00:28:21,120
we qualify

00:28:18,880 --> 00:28:23,600
a string as a universal reference a

00:28:21,120 --> 00:28:25,120
concrete type we need a requires clause

00:28:23,600 --> 00:28:27,600
on enable if

00:28:25,120 --> 00:28:28,880
so we have a couple of problems a huge

00:28:27,600 --> 00:28:31,120
amount of problems

00:28:28,880 --> 00:28:33,279
with the fact that these two ampersands

00:28:31,120 --> 00:28:36,000
are used for two different things

00:28:33,279 --> 00:28:39,120
are the ordinary r value references and

00:28:36,000 --> 00:28:41,679
universal or forwarding references

00:28:39,120 --> 00:28:42,480
but that's the way it is now and the way

00:28:41,679 --> 00:28:45,520
to solve that

00:28:42,480 --> 00:28:45,840
is pretty easy now you see why here's a

00:28:45,520 --> 00:28:49,039
u

00:28:45,840 --> 00:28:51,200
that was a copy paste error um we have

00:28:49,039 --> 00:28:52,799
to say that this is really a function

00:28:51,200 --> 00:28:55,200
template parameter

00:28:52,799 --> 00:28:56,000
so let's declare here another template

00:28:55,200 --> 00:28:59,200
parameter

00:28:56,000 --> 00:29:01,600
u and this parameter u

00:28:59,200 --> 00:29:03,200
we now then forward this into the

00:29:01,600 --> 00:29:04,000
function and now it's a universal

00:29:03,200 --> 00:29:07,039
reference

00:29:04,000 --> 00:29:08,399
now it works for l values for objects

00:29:07,039 --> 00:29:11,440
that have a name

00:29:08,399 --> 00:29:12,880
and for r values for temporary objects

00:29:11,440 --> 00:29:16,159
or for

00:29:12,880 --> 00:29:19,360
objects that are marked with move

00:29:16,159 --> 00:29:23,039
and now on the other hand we now take

00:29:19,360 --> 00:29:25,440
um all types all parameter types

00:29:23,039 --> 00:29:26,480
it's it's not though so easy now to

00:29:25,440 --> 00:29:30,000
restrict that

00:29:26,480 --> 00:29:31,919
to this to type t and uh we might use a

00:29:30,000 --> 00:29:34,640
requires clause or some

00:29:31,919 --> 00:29:35,919
enable if stuff to say but this function

00:29:34,640 --> 00:29:39,679
should only be there

00:29:35,919 --> 00:29:43,200
if if if this u is the same as type t

00:29:39,679 --> 00:29:46,320
and that's also a problem that we have

00:29:43,200 --> 00:29:46,320
the same syntax

00:29:47,120 --> 00:29:53,120
um yeah there was a question here about

00:29:51,200 --> 00:29:54,240
any other syntax for forwarding

00:29:53,120 --> 00:29:56,960
references yeah

00:29:54,240 --> 00:29:58,320
yeah a lot of questions proposals might

00:29:56,960 --> 00:30:01,440
come now so using

00:29:58,320 --> 00:30:02,880
a dollar sign or so um that would be a

00:30:01,440 --> 00:30:05,120
different discussion once

00:30:02,880 --> 00:30:06,000
once we think about how to use things in

00:30:05,120 --> 00:30:08,399
general

00:30:06,000 --> 00:30:09,039
we we are very careful to introduce new

00:30:08,399 --> 00:30:12,000
tokens

00:30:09,039 --> 00:30:13,200
uh the uh even new characters for tokens

00:30:12,000 --> 00:30:15,279
like the dollar sign

00:30:13,200 --> 00:30:16,960
but of course that would be possible and

00:30:15,279 --> 00:30:19,039
that's a different discussion

00:30:16,960 --> 00:30:20,399
we are backward compatible we have now

00:30:19,039 --> 00:30:24,320
this behavior

00:30:20,399 --> 00:30:24,320
and uh that's the problem we have

00:30:25,120 --> 00:30:30,240
so where am i okay so

00:30:28,480 --> 00:30:32,240
let's clarify a little bit more what you

00:30:30,240 --> 00:30:33,200
need you need a function template

00:30:32,240 --> 00:30:35,600
parameter

00:30:33,200 --> 00:30:37,120
you need an argument with t or whatever

00:30:35,600 --> 00:30:39,600
the parameter name is

00:30:37,120 --> 00:30:40,480
and two ampersands please no cons no

00:30:39,600 --> 00:30:42,799
volatile

00:30:40,480 --> 00:30:46,480
and then you can forward and then you

00:30:42,799 --> 00:30:46,480
have perfect forwarding

00:30:46,799 --> 00:30:50,320
please note that we have a feature

00:30:48,640 --> 00:30:52,159
called

00:30:50,320 --> 00:30:54,159
full specialization of function

00:30:52,159 --> 00:30:55,039
templates this is now a function

00:30:54,159 --> 00:30:58,640
template

00:30:55,039 --> 00:30:59,200
inside a class template and it's allowed

00:30:58,640 --> 00:31:02,240
to

00:30:59,200 --> 00:31:04,799
fully qualify this and here is a

00:31:02,240 --> 00:31:06,559
qualification for type string

00:31:04,799 --> 00:31:08,640
now the interesting question is this is

00:31:06,559 --> 00:31:10,880
a universal reference or not

00:31:08,640 --> 00:31:13,919
so you might say oh a type that's a real

00:31:10,880 --> 00:31:16,559
type name scd string ampersand ampersand

00:31:13,919 --> 00:31:17,600
that must be an r value reference that

00:31:16,559 --> 00:31:20,559
can't be a

00:31:17,600 --> 00:31:21,679
universal or forwarding reference that's

00:31:20,559 --> 00:31:24,960
not true

00:31:21,679 --> 00:31:27,919
if your template if your function

00:31:24,960 --> 00:31:28,720
is a full specialization of an existing

00:31:27,919 --> 00:31:31,120
function

00:31:28,720 --> 00:31:32,000
that takes a universal reference then

00:31:31,120 --> 00:31:35,120
this is also

00:31:32,000 --> 00:31:37,760
universal reference so even if you see

00:31:35,120 --> 00:31:39,519
std spring ampersand ampersand you have

00:31:37,760 --> 00:31:42,559
to look a little bit around

00:31:39,519 --> 00:31:43,519
to see whether this is maybe a universal

00:31:42,559 --> 00:31:46,480
reference

00:31:43,519 --> 00:31:47,279
so yeah again we have the same syntax

00:31:46,480 --> 00:31:50,320
for both

00:31:47,279 --> 00:31:54,720
and that's um yeah that's where that's

00:31:50,320 --> 00:31:58,559
a problem okay

00:31:54,720 --> 00:32:01,360
so um we can use this feature

00:31:58,559 --> 00:32:03,279
um like universal references for

00:32:01,360 --> 00:32:06,480
something like insert if

00:32:03,279 --> 00:32:08,720
where we say now let's pass multiple

00:32:06,480 --> 00:32:11,679
arguments so instead of

00:32:08,720 --> 00:32:13,120
passing one argument let's pass multiple

00:32:11,679 --> 00:32:16,000
arguments

00:32:13,120 --> 00:32:17,200
and that will be that we use variatic

00:32:16,000 --> 00:32:20,960
templates

00:32:17,200 --> 00:32:22,559
so variatic templates and are used and

00:32:20,960 --> 00:32:24,320
in a way that you say i have an

00:32:22,559 --> 00:32:27,919
arbitrary number of

00:32:24,320 --> 00:32:29,760
type names and then i take an arbitrary

00:32:27,919 --> 00:32:33,760
number of arguments of these

00:32:29,760 --> 00:32:36,000
type names and to have these arguments

00:32:33,760 --> 00:32:38,159
for these arguments perfect support for

00:32:36,000 --> 00:32:40,480
move semantics or

00:32:38,159 --> 00:32:42,240
also not for move semantics so they take

00:32:40,480 --> 00:32:44,000
everything and they pass everything

00:32:42,240 --> 00:32:46,960
perfectly forward

00:32:44,000 --> 00:32:47,679
um we declare this with two amperes and

00:32:46,960 --> 00:32:50,640
asuna

00:32:47,679 --> 00:32:51,840
for a template parameter and then we

00:32:50,640 --> 00:32:54,640
forward it

00:32:51,840 --> 00:32:56,559
and here's a way to forward it i want

00:32:54,640 --> 00:32:59,360
for each and every

00:32:56,559 --> 00:33:00,480
element i pass here um push them into

00:32:59,360 --> 00:33:03,440
the vector

00:33:00,480 --> 00:33:05,760
so um i use a helper function push which

00:33:03,440 --> 00:33:08,640
i call for each and every argument

00:33:05,760 --> 00:33:10,000
and this is a feature of c plus plus 17

00:33:08,640 --> 00:33:12,720
fold expressions

00:33:10,000 --> 00:33:15,840
this is a comma separated list so that

00:33:12,720 --> 00:33:19,519
before each argument we call push

00:33:15,840 --> 00:33:23,360
the forwarded argument and

00:33:19,519 --> 00:33:26,799
here's another exam error oh my goodness

00:33:23,360 --> 00:33:28,960
too many copy and paste uh so this

00:33:26,799 --> 00:33:30,399
should be you of course here and this

00:33:28,960 --> 00:33:33,679
should be v

00:33:30,399 --> 00:33:36,840
um so because that us the name of the

00:33:33,679 --> 00:33:39,840
type and that's the name of the

00:33:36,840 --> 00:33:42,799
argument last minute changes even after

00:33:39,840 --> 00:33:46,159
i compiled things i shouldn't do that

00:33:42,799 --> 00:33:50,080
good so um

00:33:46,159 --> 00:33:52,799
where where do we find push let's call

00:33:50,080 --> 00:33:53,919
for whatever we got the function that

00:33:52,799 --> 00:33:56,399
inserts this

00:33:53,919 --> 00:33:57,440
into the vector well let's use the

00:33:56,399 --> 00:33:59,440
lambda

00:33:57,440 --> 00:34:01,919
uh lambdas can also have universal

00:33:59,440 --> 00:34:05,120
references then the parameter is

00:34:01,919 --> 00:34:08,399
auto f autoref is another way

00:34:05,120 --> 00:34:09,280
to define a universal reference taking

00:34:08,399 --> 00:34:11,919
everything

00:34:09,280 --> 00:34:14,320
and then we can use perfect forwarding

00:34:11,919 --> 00:34:18,480
how do we use perfect forwarding here

00:34:14,320 --> 00:34:20,480
well we take again forward for this x

00:34:18,480 --> 00:34:21,760
but we need the type of the x the

00:34:20,480 --> 00:34:24,159
decotype of x

00:34:21,760 --> 00:34:24,879
and then we pass the x and we push it

00:34:24,159 --> 00:34:27,919
into

00:34:24,879 --> 00:34:31,040
the vector so yeah that's a

00:34:27,919 --> 00:34:33,280
already a little bit tricky this code

00:34:31,040 --> 00:34:34,800
and a lot of features and modern c bus

00:34:33,280 --> 00:34:37,280
features are used here

00:34:34,800 --> 00:34:40,159
um but you see here that at the end we

00:34:37,280 --> 00:34:43,919
have an arbitrary number of arguments

00:34:40,159 --> 00:34:47,280
we take uh we forward perfectly

00:34:43,919 --> 00:34:48,079
for each argument with push to hear this

00:34:47,280 --> 00:34:51,200
push function

00:34:48,079 --> 00:34:54,879
and this if the condition is um

00:34:51,200 --> 00:34:58,160
correct we push it then back perfectly

00:34:54,879 --> 00:34:58,960
in the vector so that that's the way you

00:34:58,160 --> 00:35:03,119
can

00:34:58,960 --> 00:35:06,480
implement that

00:35:03,119 --> 00:35:10,079
so universal reference

00:35:06,480 --> 00:35:12,560
now let's go to one one level

00:35:10,079 --> 00:35:14,160
further because we have a few other

00:35:12,560 --> 00:35:17,680
problems we can

00:35:14,160 --> 00:35:20,800
use or we might be surprised about

00:35:17,680 --> 00:35:22,640
so one thing is alto ampersand ampersand

00:35:20,800 --> 00:35:25,760
that's a universal reference

00:35:22,640 --> 00:35:28,000
inside the code and it's um

00:35:25,760 --> 00:35:30,160
that we can use that in a lambda but you

00:35:28,000 --> 00:35:30,480
can even have a universal reference like

00:35:30,160 --> 00:35:34,560
that

00:35:30,480 --> 00:35:38,400
as a reference in your code and

00:35:34,560 --> 00:35:41,520
in fact this lambda is a shortcut

00:35:38,400 --> 00:35:44,320
for a class that is

00:35:41,520 --> 00:35:45,599
defined for you where the up function

00:35:44,320 --> 00:35:47,760
call operator

00:35:45,599 --> 00:35:50,000
takes a universal reference as a

00:35:47,760 --> 00:35:52,960
parameter

00:35:50,000 --> 00:35:53,839
but we can also and we might also need

00:35:52,960 --> 00:35:56,160
auto

00:35:53,839 --> 00:35:57,680
ampersand ampersand for other stuff and

00:35:56,160 --> 00:36:01,359
here's maybe

00:35:57,680 --> 00:36:05,200
pretty surprising example

00:36:01,359 --> 00:36:05,839
so um let's let's assume we just want to

00:36:05,200 --> 00:36:08,480
set

00:36:05,839 --> 00:36:09,520
all the values in this container to a

00:36:08,480 --> 00:36:12,880
certain

00:36:09,520 --> 00:36:14,560
value all the of certain value so here

00:36:12,880 --> 00:36:15,440
for example we have a container of

00:36:14,560 --> 00:36:20,880
strings

00:36:15,440 --> 00:36:20,880
so assign to all of them the value reset

00:36:22,560 --> 00:36:26,560
um here you see how this works um we

00:36:26,079 --> 00:36:29,119
just

00:36:26,560 --> 00:36:30,000
um that's this is a value we only have

00:36:29,119 --> 00:36:32,800
to read

00:36:30,000 --> 00:36:33,920
so set all takes this as a const

00:36:32,800 --> 00:36:37,119
reference and then

00:36:33,920 --> 00:36:40,400
l value reference cons let's iterate

00:36:37,119 --> 00:36:43,440
over this and um

00:36:40,400 --> 00:36:45,920
yeah um and assign this and

00:36:43,440 --> 00:36:47,280
we iterate over all the values in this

00:36:45,920 --> 00:36:50,560
vector

00:36:47,280 --> 00:36:51,040
we modify them so we have to iterate by

00:36:50,560 --> 00:36:53,920
value

00:36:51,040 --> 00:36:56,000
by a reference and we can't declare this

00:36:53,920 --> 00:36:59,200
cons because we modify each

00:36:56,000 --> 00:37:02,720
each value in this vector gets this

00:36:59,200 --> 00:37:05,520
argument everything

00:37:02,720 --> 00:37:05,520
looks good

00:37:06,839 --> 00:37:14,720
but let's

00:37:09,359 --> 00:37:14,720
use our container for boolean values

00:37:15,599 --> 00:37:20,800
and now let's um set all the values in

00:37:18,640 --> 00:37:24,560
this container to true

00:37:20,800 --> 00:37:24,560
and we got a compile time error

00:37:26,320 --> 00:37:30,480
think about my goodness what is that

00:37:31,760 --> 00:37:37,680
maybe i've seen that problem maybe not

00:37:35,200 --> 00:37:39,040
but many people work i work with a

00:37:37,680 --> 00:37:45,280
vector bull

00:37:39,040 --> 00:37:45,280
but um yeah it does not compile

00:37:45,680 --> 00:37:49,440
what the hell is going on here

00:37:49,599 --> 00:37:55,040
well let's look what's the

00:37:52,880 --> 00:37:56,960
range space for loop which we use here

00:37:55,040 --> 00:37:58,720
does

00:37:56,960 --> 00:38:00,000
the range base follow while the code we

00:37:58,720 --> 00:38:04,079
have here is roughly

00:38:00,000 --> 00:38:05,680
equivalent to this so we have we

00:38:04,079 --> 00:38:08,400
initialize

00:38:05,680 --> 00:38:09,520
an iterator with the begin of this

00:38:08,400 --> 00:38:11,200
vector

00:38:09,520 --> 00:38:13,599
and while we are not at the end we

00:38:11,200 --> 00:38:15,920
iterate over all the elements

00:38:13,599 --> 00:38:16,800
and then we deal with each and every

00:38:15,920 --> 00:38:19,920
element this

00:38:16,800 --> 00:38:22,240
iterator points to so star pos so

00:38:19,920 --> 00:38:24,000
to where the iterator points and now on

00:38:22,240 --> 00:38:25,359
the left hand side we have this

00:38:24,000 --> 00:38:28,480
expression

00:38:25,359 --> 00:38:32,160
so we say we take the current value

00:38:28,480 --> 00:38:35,440
in our vector and then we assign this

00:38:32,160 --> 00:38:40,000
to an l value reference which is not

00:38:35,440 --> 00:38:41,920
const because we modify it

00:38:40,000 --> 00:38:43,280
however there's a problem with vector

00:38:41,920 --> 00:38:45,760
bool so

00:38:43,280 --> 00:38:46,720
if our container uses boolean values

00:38:45,760 --> 00:38:50,160
vector bool

00:38:46,720 --> 00:38:53,440
has internally

00:38:50,160 --> 00:38:55,760
has a wrapper around

00:38:53,440 --> 00:38:56,960
the bits around the boolean values in

00:38:55,760 --> 00:38:59,440
vectors

00:38:56,960 --> 00:39:00,560
vector of bools the elements are just

00:38:59,440 --> 00:39:04,079
bits

00:39:00,560 --> 00:39:07,359
so the objects are just objects that

00:39:04,079 --> 00:39:08,800
wrap a bit in a byte or in multiple

00:39:07,359 --> 00:39:11,760
bytes

00:39:08,800 --> 00:39:12,880
they are objects and that means what you

00:39:11,760 --> 00:39:16,320
get back here

00:39:12,880 --> 00:39:19,440
with star poss is a temporary object

00:39:16,320 --> 00:39:20,320
it's a proxy object and this temporary

00:39:19,440 --> 00:39:24,640
object

00:39:20,320 --> 00:39:25,760
is then assigned to a non-const l value

00:39:24,640 --> 00:39:28,800
reference and that's

00:39:25,760 --> 00:39:31,040
simply not allowed you can't assign

00:39:28,800 --> 00:39:34,320
temporary objects to non-cons

00:39:31,040 --> 00:39:36,160
l value references and if we try to use

00:39:34,320 --> 00:39:39,119
const here

00:39:36,160 --> 00:39:40,240
then we have here the problem that we

00:39:39,119 --> 00:39:43,280
would

00:39:40,240 --> 00:39:44,000
make everything cons if we skip this

00:39:43,280 --> 00:39:47,280
ampersand

00:39:44,000 --> 00:39:50,320
we could not modify the values so

00:39:47,280 --> 00:39:54,839
what is the solution

00:39:50,320 --> 00:39:56,720
the solution is again use a universal

00:39:54,839 --> 00:40:01,440
reference

00:39:56,720 --> 00:40:04,880
the thing with two ampersand and no cons

00:40:01,440 --> 00:40:05,599
and for arbitrary types so whether it's

00:40:04,880 --> 00:40:07,520
a

00:40:05,599 --> 00:40:09,520
template parameter or whether auto is

00:40:07,520 --> 00:40:12,560
used doesn't matter

00:40:09,520 --> 00:40:16,640
we have the same rules there so now

00:40:12,560 --> 00:40:19,359
we have here an auto available

00:40:16,640 --> 00:40:20,960
and that's okay because a universal

00:40:19,359 --> 00:40:22,960
reference

00:40:20,960 --> 00:40:24,000
that's where the name comes from

00:40:22,960 --> 00:40:27,200
universally

00:40:24,000 --> 00:40:30,480
binds to everything to all objects

00:40:27,200 --> 00:40:33,760
of all value categories to

00:40:30,480 --> 00:40:34,319
even to temporary objects and that's the

00:40:33,760 --> 00:40:37,440
only

00:40:34,319 --> 00:40:39,839
type where we can bind to

00:40:37,440 --> 00:40:41,920
any object without losing the

00:40:39,839 --> 00:40:44,319
information whether an object is not

00:40:41,920 --> 00:40:45,440
const it's the only type that that can

00:40:44,319 --> 00:40:48,880
do that

00:40:45,440 --> 00:40:51,119
kind of type and therefore you sometimes

00:40:48,880 --> 00:40:52,800
need universal references not

00:40:51,119 --> 00:40:54,480
far about something we don't fall about

00:40:52,800 --> 00:40:57,200
yet anything at all

00:40:54,480 --> 00:40:57,760
do you see any forwarding no we just

00:40:57,200 --> 00:41:00,480
need

00:40:57,760 --> 00:41:02,319
a reference and a reference that can

00:41:00,480 --> 00:41:05,680
refer to everything

00:41:02,319 --> 00:41:08,800
and so this works and

00:41:05,680 --> 00:41:10,640
that's why i i'm not happy that

00:41:08,800 --> 00:41:13,040
we decided to give the name the

00:41:10,640 --> 00:41:13,520
forwarding a forwarding reference as a

00:41:13,040 --> 00:41:16,319
name

00:41:13,520 --> 00:41:17,680
this is a universal reference and if you

00:41:16,319 --> 00:41:20,319
apply forward to it

00:41:17,680 --> 00:41:20,800
you make it a forwarding reference but

00:41:20,319 --> 00:41:24,079
here

00:41:20,800 --> 00:41:26,800
we just use it for a different purpose

00:41:24,079 --> 00:41:27,280
and one good purpose of this reference

00:41:26,800 --> 00:41:30,400
is

00:41:27,280 --> 00:41:32,720
it can refer to everything and

00:41:30,400 --> 00:41:34,000
can keep the information whether

00:41:32,720 --> 00:41:37,200
something is const or

00:41:34,000 --> 00:41:41,280
not we have no other way to do that in c

00:41:37,200 --> 00:41:46,839
plus class okay

00:41:41,280 --> 00:41:50,480
um there is um

00:41:46,839 --> 00:41:53,200
yeah um

00:41:50,480 --> 00:41:55,599
talking about uh set as i come to the

00:41:53,200 --> 00:41:57,520
other questions at the end please excuse

00:41:55,599 --> 00:42:01,280
if that's okay

00:41:57,520 --> 00:42:04,560
so um there's another

00:42:01,280 --> 00:42:04,960
another topic was talking about setters

00:42:04,560 --> 00:42:07,520
or

00:42:04,960 --> 00:42:09,119
some kind of setters let's talk about

00:42:07,520 --> 00:42:12,800
getters

00:42:09,119 --> 00:42:14,880
and there's a there's a there's a flaw

00:42:12,800 --> 00:42:17,440
or there's a sometimes even a war

00:42:14,880 --> 00:42:21,119
between programmers about the question

00:42:17,440 --> 00:42:21,839
should get us return by value or by

00:42:21,119 --> 00:42:25,200
reference

00:42:21,839 --> 00:42:28,000
const reference ideally so here's a

00:42:25,200 --> 00:42:31,520
good example in our class we have a

00:42:28,000 --> 00:42:32,319
vector of t and the getter here returns

00:42:31,520 --> 00:42:36,960
by value

00:42:32,319 --> 00:42:40,800
all the vector of t and that's safe

00:42:36,960 --> 00:42:41,920
and but slow so if we do something like

00:42:40,800 --> 00:42:44,480
this so

00:42:41,920 --> 00:42:45,359
i want to just know how many elements i

00:42:44,480 --> 00:42:48,079
have

00:42:45,359 --> 00:42:49,520
so um if this container doesn't have a

00:42:48,079 --> 00:42:53,200
size function which

00:42:49,520 --> 00:42:55,040
might have but um if you don't have that

00:42:53,200 --> 00:42:58,640
or need something else

00:42:55,040 --> 00:43:00,800
um then you would have okay get values

00:42:58,640 --> 00:43:02,880
gives you back this by value but

00:43:00,800 --> 00:43:06,079
returning this by value means

00:43:02,880 --> 00:43:08,800
that we create a copy of the whole

00:43:06,079 --> 00:43:11,280
vector of all its elements so if it's a

00:43:08,800 --> 00:43:13,520
vector of one million strings

00:43:11,280 --> 00:43:15,440
one million strings will be copied

00:43:13,520 --> 00:43:17,920
including memory allocation

00:43:15,440 --> 00:43:19,359
and the vector also has needs what's one

00:43:17,920 --> 00:43:23,040
memory allocation

00:43:19,359 --> 00:43:24,560
for its internal memory that's very

00:43:23,040 --> 00:43:28,400
expensive just

00:43:24,560 --> 00:43:31,040
to get the size so

00:43:28,400 --> 00:43:31,920
the answer of that which is often done

00:43:31,040 --> 00:43:34,400
in practice

00:43:31,920 --> 00:43:36,400
is although then let's a getter can

00:43:34,400 --> 00:43:37,359
return by reference because i call this

00:43:36,400 --> 00:43:40,160
for an object

00:43:37,359 --> 00:43:41,920
it should still be there when i use this

00:43:40,160 --> 00:43:45,200
reference

00:43:41,920 --> 00:43:48,079
well pass by reference is usually safe

00:43:45,200 --> 00:43:48,640
because what you what you pass and does

00:43:48,079 --> 00:43:50,160
exist

00:43:48,640 --> 00:43:51,680
until you leave the function but

00:43:50,160 --> 00:43:55,280
returning by reference

00:43:51,680 --> 00:43:56,480
there's some danger and returning by

00:43:55,280 --> 00:44:01,040
const reference here

00:43:56,480 --> 00:44:03,200
can go wrong there's my favorite example

00:44:01,040 --> 00:44:04,240
is an example where you don't see or

00:44:03,200 --> 00:44:06,400
even feel

00:44:04,240 --> 00:44:08,319
that there could be something going

00:44:06,400 --> 00:44:11,520
wrong

00:44:08,319 --> 00:44:13,040
it's the range base for loop

00:44:11,520 --> 00:44:15,119
the range base for loop has a

00:44:13,040 --> 00:44:16,560
significant problem i would consider

00:44:15,119 --> 00:44:18,640
this as a bug

00:44:16,560 --> 00:44:19,680
and i hope this will be fixed pretty

00:44:18,640 --> 00:44:22,720
soon

00:44:19,680 --> 00:44:25,040
say for c plus 23.

00:44:22,720 --> 00:44:26,960
if we have a function returning a

00:44:25,040 --> 00:44:29,839
container of strings

00:44:26,960 --> 00:44:32,160
so something like this with elements

00:44:29,839 --> 00:44:37,359
being strings

00:44:32,160 --> 00:44:40,400
and if we then call this and directly

00:44:37,359 --> 00:44:41,680
ask for the values inside and iterate

00:44:40,400 --> 00:44:44,079
over these values

00:44:41,680 --> 00:44:45,680
so let's iterate over all values

00:44:44,079 --> 00:44:48,839
returned by a function

00:44:45,680 --> 00:44:50,160
that gives us back a container of

00:44:48,839 --> 00:44:52,960
strings

00:44:50,160 --> 00:44:54,160
the best you get here is a quarter

00:44:52,960 --> 00:44:56,960
because then you see

00:44:54,160 --> 00:44:59,040
that you have a problem there and

00:44:56,960 --> 00:45:01,520
because the range base for loop the way

00:44:59,040 --> 00:45:04,160
it is specified right now has a

00:45:01,520 --> 00:45:06,000
significant problem with references to

00:45:04,160 --> 00:45:06,880
temporaries and then if you have on the

00:45:06,000 --> 00:45:08,960
right side

00:45:06,880 --> 00:45:10,720
references to temporaries and get values

00:45:08,960 --> 00:45:13,040
returns by reference

00:45:10,720 --> 00:45:15,200
and the problem is that with the

00:45:13,040 --> 00:45:18,640
implement specification used

00:45:15,200 --> 00:45:21,440
inside the temporary object

00:45:18,640 --> 00:45:22,000
is destroyed before we start with the

00:45:21,440 --> 00:45:25,599
loop

00:45:22,000 --> 00:45:27,440
internally as i said i'm i still have

00:45:25,599 --> 00:45:29,920
the task and want to fix that

00:45:27,440 --> 00:45:32,079
i think this is a major flaw because it

00:45:29,920 --> 00:45:34,640
is the most important loop we have

00:45:32,079 --> 00:45:37,200
but we have to warn even beginners about

00:45:34,640 --> 00:45:39,359
using this loop for each and every case

00:45:37,200 --> 00:45:41,040
and that should be fixed i hope this

00:45:39,359 --> 00:45:44,079
will be fixed very soon

00:45:41,040 --> 00:45:47,200
but we have we have to discuss that

00:45:44,079 --> 00:45:49,280
because the problem is to fix that we

00:45:47,200 --> 00:45:50,560
have to extend the lifetime of this

00:45:49,280 --> 00:45:52,560
return value

00:45:50,560 --> 00:45:54,240
and extending the lifetime of a return

00:45:52,560 --> 00:45:57,200
value might temporarily

00:45:54,240 --> 00:45:57,920
create more footprint in a program so

00:45:57,200 --> 00:45:59,920
that's

00:45:57,920 --> 00:46:01,680
something we have to consider and that's

00:45:59,920 --> 00:46:03,520
good that we have to consider that and

00:46:01,680 --> 00:46:06,240
that we do that

00:46:03,520 --> 00:46:07,680
so that is the problem and this problem

00:46:06,240 --> 00:46:11,760
will not occur

00:46:07,680 --> 00:46:16,720
if we return by value so it seems

00:46:11,760 --> 00:46:19,839
we have to decide between cheap or safe

00:46:16,720 --> 00:46:22,160
and there's a new way to do that now and

00:46:19,839 --> 00:46:26,319
the new way is this you can overload

00:46:22,160 --> 00:46:29,680
the getter for r-value references

00:46:26,319 --> 00:46:33,520
so this is a way to qualify this getter

00:46:29,680 --> 00:46:34,240
that this will be called if the object i

00:46:33,520 --> 00:46:38,079
call this

00:46:34,240 --> 00:46:41,119
for is as useful to ampersand

00:46:38,079 --> 00:46:44,160
and r value so that means it is

00:46:41,119 --> 00:46:48,640
either a temporary object or an object

00:46:44,160 --> 00:46:51,599
qualified with move or marked with move

00:46:48,640 --> 00:46:53,440
and the const l value our friends that

00:46:51,599 --> 00:46:55,599
works for everything but that's

00:46:53,440 --> 00:46:57,040
that's the second best option if this

00:46:55,599 --> 00:46:59,520
fits that's better

00:46:57,040 --> 00:47:01,440
so for all objects it's like having a

00:46:59,520 --> 00:47:02,160
function taking a const l value

00:47:01,440 --> 00:47:04,720
reference

00:47:02,160 --> 00:47:05,920
for all other objects we return by const

00:47:04,720 --> 00:47:08,800
reference

00:47:05,920 --> 00:47:10,160
so that's good now because now we have

00:47:08,800 --> 00:47:12,319
no problem here

00:47:10,160 --> 00:47:15,200
we have a temporary object and this

00:47:12,319 --> 00:47:18,240
scatter returns by value

00:47:15,200 --> 00:47:19,680
and here we are cheap because we have an

00:47:18,240 --> 00:47:23,119
object with name

00:47:19,680 --> 00:47:25,119
and we are can here return by reference

00:47:23,119 --> 00:47:27,440
and ask for the size

00:47:25,119 --> 00:47:28,480
please also note that we have a move

00:47:27,440 --> 00:47:31,119
here

00:47:28,480 --> 00:47:33,119
so when we have a temporary object and

00:47:31,119 --> 00:47:36,319
we ask for the values

00:47:33,119 --> 00:47:37,200
we make the copying sheet because by

00:47:36,319 --> 00:47:39,920
definition

00:47:37,200 --> 00:47:42,160
of move or of a temporary object we no

00:47:39,920 --> 00:47:43,599
longer need the value of this object so

00:47:42,160 --> 00:47:45,440
we can move out

00:47:43,599 --> 00:47:47,040
the whole vector of strings to the

00:47:45,440 --> 00:47:49,760
caller and that makes

00:47:47,040 --> 00:47:52,400
this cheat this cheap again so this is

00:47:49,760 --> 00:47:54,960
not only okay this is also cheap

00:47:52,400 --> 00:47:55,680
if move semantic is supported for a data

00:47:54,960 --> 00:47:58,800
type

00:47:55,680 --> 00:48:01,920
and that's a good thing so i i don't

00:47:58,800 --> 00:48:04,640
want to see any more that you return

00:48:01,920 --> 00:48:05,280
by reference get in getters don't do

00:48:04,640 --> 00:48:08,960
that

00:48:05,280 --> 00:48:12,000
if you think that's useful well then

00:48:08,960 --> 00:48:15,200
do it in certain cases so say um

00:48:12,000 --> 00:48:15,920
in general um maybe i i return by

00:48:15,200 --> 00:48:18,800
reference but

00:48:15,920 --> 00:48:20,160
for when it can there when there can be

00:48:18,800 --> 00:48:22,960
lifetime problems

00:48:20,160 --> 00:48:25,200
i return a temporary object for a

00:48:22,960 --> 00:48:28,400
temporary object i return by value

00:48:25,200 --> 00:48:31,119
and by the way we discuss right now

00:48:28,400 --> 00:48:32,960
that we even should qualify assignment

00:48:31,119 --> 00:48:36,640
operators and other operators

00:48:32,960 --> 00:48:39,920
that way to fix some flaws we could have

00:48:36,640 --> 00:48:43,440
when we use assignment operators in a

00:48:39,920 --> 00:48:43,440
in some interesting ways

00:48:43,760 --> 00:48:48,400
so and let me finally show you that if

00:48:46,800 --> 00:48:52,000
you have this support

00:48:48,400 --> 00:48:54,640
then it's a good idea to mark

00:48:52,000 --> 00:48:56,640
your object with move if you call get

00:48:54,640 --> 00:48:57,440
values and you no longer need this

00:48:56,640 --> 00:49:00,319
object

00:48:57,440 --> 00:49:00,880
that makes this call cheap so you move

00:49:00,319 --> 00:49:03,440
out

00:49:00,880 --> 00:49:04,720
the object where you need no longer the

00:49:03,440 --> 00:49:07,280
vector of string

00:49:04,720 --> 00:49:08,559
you move out these values as vector of

00:49:07,280 --> 00:49:12,640
strings to here

00:49:08,559 --> 00:49:15,599
if you would not mark this with move

00:49:12,640 --> 00:49:16,400
you have the problem that because this

00:49:15,599 --> 00:49:19,760
returns

00:49:16,400 --> 00:49:23,040
a const reference that here

00:49:19,760 --> 00:49:26,880
we would um copy things um unless maybe

00:49:23,040 --> 00:49:29,520
optimizers compilers can optimize that

00:49:26,880 --> 00:49:30,720
so if you have never seen that it can

00:49:29,520 --> 00:49:33,040
make sense

00:49:30,720 --> 00:49:34,000
for member function calls to mark

00:49:33,040 --> 00:49:37,599
objects with

00:49:34,000 --> 00:49:38,960
move and by the way i had recently an

00:49:37,599 --> 00:49:41,839
interesting discussion

00:49:38,960 --> 00:49:42,240
whether then this move should apply to

00:49:41,839 --> 00:49:45,359
this

00:49:42,240 --> 00:49:47,839
or to the whole thing but

00:49:45,359 --> 00:49:48,800
if it's not a member function but just a

00:49:47,839 --> 00:49:50,640
data member

00:49:48,800 --> 00:49:52,559
so i i haven't said everything about

00:49:50,640 --> 00:49:56,839
that if it's a data member then

00:49:52,559 --> 00:49:58,559
a lot of additional complicated rules

00:49:56,839 --> 00:50:02,400
apply

00:49:58,559 --> 00:50:06,160
that's it i mean we have um the hour

00:50:02,400 --> 00:50:07,280
is almost gone so um to have some time

00:50:06,160 --> 00:50:10,319
for some question

00:50:07,280 --> 00:50:12,559
let's see where we are so

00:50:10,319 --> 00:50:13,440
i i did definitely not show all the

00:50:12,559 --> 00:50:16,079
problems

00:50:13,440 --> 00:50:16,880
um we could um i could have for more

00:50:16,079 --> 00:50:19,920
time we could

00:50:16,880 --> 00:50:23,760
do some other stuff with this class

00:50:19,920 --> 00:50:27,280
and fall into a couple of other traps

00:50:23,760 --> 00:50:30,240
um but what we have seen here is um

00:50:27,280 --> 00:50:31,359
cons disables move semantics so don't

00:50:30,240 --> 00:50:34,400
use it

00:50:31,359 --> 00:50:37,040
when you um see see something

00:50:34,400 --> 00:50:39,359
as used again and that especially means

00:50:37,040 --> 00:50:42,160
don't return by const value don't do

00:50:39,359 --> 00:50:45,119
that if that's your style

00:50:42,160 --> 00:50:45,599
const are value references are possible

00:50:45,119 --> 00:50:49,200
but

00:50:45,599 --> 00:50:51,760
it's a semantic contradiction

00:50:49,200 --> 00:50:53,520
you to always always adopt values you

00:50:51,760 --> 00:50:57,440
can take by value and move

00:50:53,520 --> 00:51:01,280
if move is cheap etc

00:50:57,440 --> 00:51:03,440
and if you have two ampersand for um

00:51:01,280 --> 00:51:05,359
function template parameter or with alto

00:51:03,440 --> 00:51:08,720
you have a universal or

00:51:05,359 --> 00:51:11,440
forwarding references and unless

00:51:08,720 --> 00:51:13,760
the t is not a local function template

00:51:11,440 --> 00:51:16,400
parameter or the argument is cons or t

00:51:13,760 --> 00:51:18,800
is an expression like this

00:51:16,400 --> 00:51:21,200
and as you have seen std string with two

00:51:18,800 --> 00:51:23,119
ampersand can be a universal reference

00:51:21,200 --> 00:51:24,400
although it doesn't look like that in

00:51:23,119 --> 00:51:27,440
full function

00:51:24,400 --> 00:51:29,680
template specializations universal

00:51:27,440 --> 00:51:32,000
references do not always forward

00:51:29,680 --> 00:51:33,280
that's why i prefer the term universal

00:51:32,000 --> 00:51:35,599
reference

00:51:33,280 --> 00:51:36,400
because it's a little bit confusing that

00:51:35,599 --> 00:51:39,119
we name it

00:51:36,400 --> 00:51:40,000
forwarding reference it's also confusing

00:51:39,119 --> 00:51:42,800
because

00:51:40,000 --> 00:51:43,520
l value reference and r value reference

00:51:42,800 --> 00:51:46,960
the name

00:51:43,520 --> 00:51:48,880
this term comes from the fact where can

00:51:46,960 --> 00:51:50,720
they refer to

00:51:48,880 --> 00:51:52,160
and now it makes sense universal

00:51:50,720 --> 00:51:55,200
references can refer

00:51:52,160 --> 00:51:58,559
universally to all um class but

00:51:55,200 --> 00:52:01,440
forwarding is suddenly what can we

00:51:58,559 --> 00:52:02,480
typically do with that but not always we

00:52:01,440 --> 00:52:04,880
have to do that

00:52:02,480 --> 00:52:06,559
and i think that creates a big confusion

00:52:04,880 --> 00:52:08,880
and i'm really not happy

00:52:06,559 --> 00:52:11,040
that we made this and introduced this

00:52:08,880 --> 00:52:12,079
term besides the fact that we had an

00:52:11,040 --> 00:52:16,000
established term

00:52:12,079 --> 00:52:19,440
that was really working well um

00:52:16,000 --> 00:52:22,000
then um yeah maybe here um because

00:52:19,440 --> 00:52:23,119
i'm pretty sure we will discuss that and

00:52:22,000 --> 00:52:25,359
twitter or

00:52:23,119 --> 00:52:26,400
somewhere else here's another example

00:52:25,359 --> 00:52:28,480
for um

00:52:26,400 --> 00:52:30,160
a universal reference that does not

00:52:28,480 --> 00:52:35,280
forward

00:52:30,160 --> 00:52:38,400
let's take some arbitrary container type

00:52:35,280 --> 00:52:40,800
arbitrary um value type

00:52:38,400 --> 00:52:41,599
arbitrary type and arbitrary value

00:52:40,800 --> 00:52:44,000
category

00:52:41,599 --> 00:52:44,640
and let's iterate over the elements by

00:52:44,000 --> 00:52:48,079
calling

00:52:44,640 --> 00:52:50,880
c began and see where will

00:52:48,079 --> 00:52:52,000
do you want to place forward here and

00:52:50,880 --> 00:52:54,480
you are not really

00:52:52,000 --> 00:52:55,760
following we are calling for this c

00:52:54,480 --> 00:52:59,200
begin and then

00:52:55,760 --> 00:53:01,520
and depending on the container here

00:52:59,200 --> 00:53:03,359
we might if it's cons get a const

00:53:01,520 --> 00:53:05,359
iterator if it's not cons we get an

00:53:03,359 --> 00:53:08,000
iterator that might be important

00:53:05,359 --> 00:53:08,880
because you have overloaded iterate for

00:53:08,000 --> 00:53:11,440
taking cons

00:53:08,880 --> 00:53:12,960
iterators and non-considerators so

00:53:11,440 --> 00:53:15,760
that's another example for

00:53:12,960 --> 00:53:17,920
universal reference that does not always

00:53:15,760 --> 00:53:20,319
forward

00:53:17,920 --> 00:53:23,520
getters should return by value or should

00:53:20,319 --> 00:53:26,960
be overloaded on reference qualifiers

00:53:23,520 --> 00:53:29,040
and use auto refresh so

00:53:26,960 --> 00:53:30,319
a universal reference in a generic

00:53:29,040 --> 00:53:34,079
range-based follow

00:53:30,319 --> 00:53:37,200
to to support even containers

00:53:34,079 --> 00:53:40,400
where the iterator is a temporary object

00:53:37,200 --> 00:53:42,079
refers to a temporary object

00:53:40,400 --> 00:53:44,400
the range-based for loop is broken

00:53:42,079 --> 00:53:45,599
currently when iterating over references

00:53:44,400 --> 00:53:48,319
to temporaries

00:53:45,599 --> 00:53:48,880
and it makes or can make sense to use

00:53:48,319 --> 00:53:52,160
move

00:53:48,880 --> 00:53:52,160
for member functions

00:53:52,559 --> 00:54:02,000
that's it so

00:53:57,760 --> 00:54:04,319
time for some questions maybe and

00:54:02,000 --> 00:54:06,160
maybe before i take the questions let me

00:54:04,319 --> 00:54:08,400
say something

00:54:06,160 --> 00:54:09,520
i learned a lot over the past half year

00:54:08,400 --> 00:54:12,880
because since

00:54:09,520 --> 00:54:14,880
the winter of this year um i wrote just

00:54:12,880 --> 00:54:18,000
a book about move semantics

00:54:14,880 --> 00:54:19,599
so there i i learned a lot i didn't know

00:54:18,000 --> 00:54:22,000
before even i'm i'm

00:54:19,599 --> 00:54:23,920
standardizing c bus bus for 20 years but

00:54:22,000 --> 00:54:25,920
i'm i'm not the smartest guy i only took

00:54:23,920 --> 00:54:29,040
him and what we standardize

00:54:25,920 --> 00:54:31,920
and uh this this is done now it's this

00:54:29,040 --> 00:54:32,480
is done it's out it's out as an e-book

00:54:31,920 --> 00:54:36,480
and

00:54:32,480 --> 00:54:37,440
as a paperback at amazon um it has 250

00:54:36,480 --> 00:54:40,319
pages

00:54:37,440 --> 00:54:41,760
so well you might see these slides but a

00:54:40,319 --> 00:54:44,079
few slides are missing

00:54:41,760 --> 00:54:46,480
i'll read the book and here's a website

00:54:44,079 --> 00:54:49,680
where you can find the more information

00:54:46,480 --> 00:54:52,799
i hope you enjoy please give me feedback

00:54:49,680 --> 00:54:56,000
and then um i'm

00:54:52,799 --> 00:54:57,200
i'm i'm fine to take questions so let's

00:54:56,000 --> 00:55:00,160
see

00:54:57,200 --> 00:55:00,160
what i have here

00:55:03,920 --> 00:55:06,960
when specializing a function template to

00:55:06,319 --> 00:55:10,319
take

00:55:06,960 --> 00:55:12,960
a string double ampersand um

00:55:10,319 --> 00:55:14,559
i told you um i said that it's a

00:55:12,960 --> 00:55:17,119
universal reference

00:55:14,559 --> 00:55:19,280
is there any way to specialize it or to

00:55:17,119 --> 00:55:22,400
take only an r value reference yes

00:55:19,280 --> 00:55:25,680
there is what you usually can do

00:55:22,400 --> 00:55:27,359
since c plus plus 20 um you use a

00:55:25,680 --> 00:55:30,720
requires clause

00:55:27,359 --> 00:55:33,760
what you simply say you can ask for the

00:55:30,720 --> 00:55:36,559
template parameter t

00:55:33,760 --> 00:55:38,559
whether it's an r value reference or and

00:55:36,559 --> 00:55:41,280
whether it's an l value reference well

00:55:38,559 --> 00:55:41,760
in fact if it's an l value reference

00:55:41,280 --> 00:55:44,319
then

00:55:41,760 --> 00:55:46,319
it was an l value passed and otherwise

00:55:44,319 --> 00:55:48,880
it's it's not a reference at all

00:55:46,319 --> 00:55:51,040
sorry i was not quite correct here so

00:55:48,880 --> 00:55:51,760
but you can check that there's a special

00:55:51,040 --> 00:55:54,960
rule

00:55:51,760 --> 00:55:55,280
for if you use universal references then

00:55:54,960 --> 00:55:58,720
the

00:55:55,280 --> 00:56:01,839
object and the the parameter type t

00:55:58,720 --> 00:56:03,680
is when an l value is passed it's an l

00:56:01,839 --> 00:56:04,640
value reference otherwise it's just a

00:56:03,680 --> 00:56:07,440
plain type t

00:56:04,640 --> 00:56:08,559
so plane type string by by testing this

00:56:07,440 --> 00:56:11,839
and requires or

00:56:08,559 --> 00:56:14,240
enable if um it's uh it's it's

00:56:11,839 --> 00:56:16,079
it's it's possible to do that and it's

00:56:14,240 --> 00:56:21,680
described in the book haha

00:56:16,079 --> 00:56:21,680
good question um next question

00:56:25,040 --> 00:56:31,839
not sure i can read the next question ah

00:56:28,839 --> 00:56:31,839
scd4.1

00:56:37,040 --> 00:56:40,880
um that was crap for a specific slide i

00:56:40,240 --> 00:56:42,960
think

00:56:40,880 --> 00:56:44,240
if you sent me again with slide your

00:56:42,960 --> 00:56:47,760
meme i'm

00:56:44,240 --> 00:56:51,599
happy to answer that question in general

00:56:47,760 --> 00:56:54,720
forward is a conditional static cast

00:56:51,599 --> 00:56:58,000
so um our conditional move

00:56:54,720 --> 00:57:00,480
by having a special steady cast um

00:56:58,000 --> 00:57:02,799
i can't answer this question now

00:57:00,480 --> 00:57:08,000
immediately without seeing the slide

00:57:02,799 --> 00:57:10,960
you mean and yes it might be that i had

00:57:08,000 --> 00:57:13,839
no i have to no no i can't answer that

00:57:10,960 --> 00:57:13,839
now

00:57:13,920 --> 00:57:17,760
sorry next question

00:57:18,319 --> 00:57:24,400
are there possibilities to statically

00:57:21,760 --> 00:57:26,720
there's always a name in front of that

00:57:24,400 --> 00:57:29,359
shown click to view more

00:57:26,720 --> 00:57:30,960
um yeah can you can you remove the top

00:57:29,359 --> 00:57:33,280
question so that i can see the next

00:57:30,960 --> 00:57:35,359
question

00:57:33,280 --> 00:57:37,119
thank you are there possibilities to

00:57:35,359 --> 00:57:38,880
statically assert if the type is

00:57:37,119 --> 00:57:42,319
forwarding reference to implement

00:57:38,880 --> 00:57:45,920
things like it yes as i said um

00:57:42,319 --> 00:57:48,960
you can do that ah statically as uh

00:57:45,920 --> 00:57:51,920
is it statically a search

00:57:48,960 --> 00:57:53,520
yes you can do that it's it's known at

00:57:51,920 --> 00:57:57,280
compile time so

00:57:53,520 --> 00:58:00,000
as i told you when an l value is passed

00:57:57,280 --> 00:58:01,599
um what you get as a parameter type t is

00:58:00,000 --> 00:58:04,240
an l value reference

00:58:01,599 --> 00:58:07,119
you can check this with uh enable if you

00:58:04,240 --> 00:58:09,440
can also static cast that

00:58:07,119 --> 00:58:10,319
and you can also use if cons x but

00:58:09,440 --> 00:58:12,880
sometimes you need

00:58:10,319 --> 00:58:15,040
if contacts so to decide on whether an l

00:58:12,880 --> 00:58:15,839
value was passed or whether an r value

00:58:15,040 --> 00:58:19,119
was passed

00:58:15,839 --> 00:58:19,119
you can also do that

00:58:20,559 --> 00:58:24,000
what is the difference between saying

00:58:22,559 --> 00:58:28,240
that a member function

00:58:24,000 --> 00:58:31,839
is cons ref and cons well i i assume

00:58:28,240 --> 00:58:35,200
we mean um the return value

00:58:31,839 --> 00:58:38,240
um the return type if it's well const

00:58:35,200 --> 00:58:38,880
string you return by value but for the

00:58:38,240 --> 00:58:41,119
caller

00:58:38,880 --> 00:58:42,640
you say it's it's not allowed to modify

00:58:41,119 --> 00:58:46,000
it if you return

00:58:42,640 --> 00:58:47,359
cons lva your reference you you don't

00:58:46,000 --> 00:58:49,680
create a copy

00:58:47,359 --> 00:58:51,040
you you have really to make sure that

00:58:49,680 --> 00:58:53,040
what you return

00:58:51,040 --> 00:58:54,880
is something that is still living so

00:58:53,040 --> 00:58:55,520
like a member with some flaws we have

00:58:54,880 --> 00:58:59,200
seen that

00:58:55,520 --> 00:59:01,280
or maybe a static object also so

00:58:59,200 --> 00:59:02,799
that um there is a difference there is a

00:59:01,280 --> 00:59:06,000
huge difference and

00:59:02,799 --> 00:59:08,559
pretty often if you return by reference

00:59:06,000 --> 00:59:10,240
be very careful normally return values

00:59:08,559 --> 00:59:12,960
should only be by value

00:59:10,240 --> 00:59:14,000
and maybe with some exceptions if you

00:59:12,960 --> 00:59:16,640
exactly know

00:59:14,000 --> 00:59:16,640
what you do

00:59:17,440 --> 00:59:22,720
could you use auto um r value reference

00:59:20,240 --> 00:59:26,160
instead of having to add template onto a

00:59:22,720 --> 00:59:29,440
member function could you use alto

00:59:26,160 --> 00:59:30,319
and that was slide 17 thanks for the

00:59:29,440 --> 00:59:33,839
slide

00:59:30,319 --> 00:59:33,839
that helps me

00:59:35,920 --> 00:59:39,280
so could you use alt instead of having

00:59:38,480 --> 00:59:41,760
to add

00:59:39,280 --> 00:59:43,280
template onto metal uh yes you can send

00:59:41,760 --> 00:59:46,480
c plus plus 20. yeah

00:59:43,280 --> 00:59:49,760
and c bus plus 20 we have the feature

00:59:46,480 --> 00:59:52,000
that we can here specify auto um

00:59:49,760 --> 00:59:54,880
auto our value references were allowed

00:59:52,000 --> 00:59:58,000
before c plus was 20 only for lambdas

00:59:54,880 --> 01:00:00,240
and now it can is there every

00:59:58,000 --> 01:00:02,079
also everywhere allowed and and it's a

01:00:00,240 --> 01:00:02,960
shortcut for just being a template

01:00:02,079 --> 01:00:05,520
parameter

01:00:02,960 --> 01:00:06,400
but then you need here decal type of v

01:00:05,520 --> 01:00:09,280
instead of

01:00:06,400 --> 01:00:09,280
ooh of course

01:00:09,520 --> 01:00:16,799
okay maybe two or three other questions

01:00:12,839 --> 01:00:18,640
um are there any differences between

01:00:16,799 --> 01:00:21,760
decker type auto foo

01:00:18,640 --> 01:00:25,520
equals f how to reference

01:00:21,760 --> 01:00:27,680
foo equals f oh yes oh my goodness i

01:00:25,520 --> 01:00:29,520
didn't talk about decal time auto docker

01:00:27,680 --> 01:00:32,559
time ultra is a nightmare

01:00:29,520 --> 01:00:35,520
um decker type auto is

01:00:32,559 --> 01:00:36,400
using a very interesting rules of decal

01:00:35,520 --> 01:00:40,079
type

01:00:36,400 --> 01:00:42,480
and to decide how we should return

01:00:40,079 --> 01:00:44,720
a value but with which type and there's

01:00:42,480 --> 01:00:48,000
a special rule with decal type

01:00:44,720 --> 01:00:48,799
if you pass a name it gives you back the

01:00:48,000 --> 01:00:51,760
type

01:00:48,799 --> 01:00:52,960
if you pass an expression decal type

01:00:51,760 --> 01:00:56,640
gives you back

01:00:52,960 --> 01:00:59,760
um the value category so um

01:00:56,640 --> 01:01:02,319
decker type auto is um

01:00:59,760 --> 01:01:04,240
is something that in many cases works

01:01:02,319 --> 01:01:07,200
well but for example you can

01:01:04,240 --> 01:01:08,000
get it in big trouble if you then in

01:01:07,200 --> 01:01:11,040
your return

01:01:08,000 --> 01:01:13,760
statement return a name and have

01:01:11,040 --> 01:01:14,799
parentheses around it don't do that

01:01:13,760 --> 01:01:17,680
because then you

01:01:14,799 --> 01:01:19,839
return the object with an l value

01:01:17,680 --> 01:01:20,799
reference because with the parenthesis

01:01:19,839 --> 01:01:23,119
decl type

01:01:20,799 --> 01:01:24,160
asks for what is the value category of

01:01:23,119 --> 01:01:27,200
the object

01:01:24,160 --> 01:01:28,240
and might give you a different result in

01:01:27,200 --> 01:01:31,280
general

01:01:28,240 --> 01:01:33,680
the difference between decotype auto and

01:01:31,280 --> 01:01:34,559
auto with to ampersand is auto width to

01:01:33,680 --> 01:01:37,680
ampersand is

01:01:34,559 --> 01:01:40,240
always a reference decal type auto

01:01:37,680 --> 01:01:41,119
is sometimes a value and sometimes a

01:01:40,240 --> 01:01:43,680
reference

01:01:41,119 --> 01:01:44,160
and we need that in return type so

01:01:43,680 --> 01:01:46,960
inject

01:01:44,160 --> 01:01:47,920
if we want to perfectly return something

01:01:46,960 --> 01:01:50,559
in the function

01:01:47,920 --> 01:01:52,160
you need deco type auto which you then

01:01:50,559 --> 01:01:54,400
might even have to qualify

01:01:52,160 --> 01:01:55,200
as return type in the lambda because by

01:01:54,400 --> 01:01:57,440
default

01:01:55,200 --> 01:01:59,520
there the return type is auto all

01:01:57,440 --> 01:02:00,720
explained in the book haha it works good

01:01:59,520 --> 01:02:04,160
as an advertisement

01:02:00,720 --> 01:02:06,480
again um

01:02:04,160 --> 01:02:08,799
can't understand it repair the back to

01:02:06,480 --> 01:02:10,640
extend the lifetime yes we can

01:02:08,799 --> 01:02:12,480
well it's not the standard that repairs

01:02:10,640 --> 01:02:15,039
it it's the people who decide what it's

01:02:12,480 --> 01:02:18,160
what is in the standard so the committee

01:02:15,039 --> 01:02:18,720
um i'm still upset that we have this

01:02:18,160 --> 01:02:21,760
back

01:02:18,720 --> 01:02:25,200
and i'm still hope we can fix that

01:02:21,760 --> 01:02:29,839
um as i said it's not that easy

01:02:25,200 --> 01:02:33,599
because we might create in some

01:02:29,839 --> 01:02:37,039
places more temporarily more

01:02:33,599 --> 01:02:38,000
memory footprint and that can sometimes

01:02:37,039 --> 01:02:39,920
be a problem i

01:02:38,000 --> 01:02:42,160
i don't see why this is a problem here

01:02:39,920 --> 01:02:43,039
in this case so i would not fix it in

01:02:42,160 --> 01:02:45,920
general

01:02:43,039 --> 01:02:46,799
for references to extend lifetimes for

01:02:45,920 --> 01:02:48,640
everything

01:02:46,799 --> 01:02:50,240
but in the range space for loop i would

01:02:48,640 --> 01:02:52,720
definitely like to hide

01:02:50,240 --> 01:02:55,680
the problems because nobody sees that

01:02:52,720 --> 01:02:58,559
internally references are used which uh

01:02:55,680 --> 01:02:59,839
which even in in separate statements so

01:02:58,559 --> 01:03:02,559
that lifetimes

01:02:59,839 --> 01:03:03,200
end in the middle of the range base for

01:03:02,559 --> 01:03:05,920
loop that's

01:03:03,200 --> 01:03:07,520
that's a nightmare how many things are

01:03:05,920 --> 01:03:09,920
nightmares everything in c

01:03:07,520 --> 01:03:11,359
plus is a nightmare of course that's

01:03:09,920 --> 01:03:14,480
easy

01:03:11,359 --> 01:03:16,880
um well

01:03:14,480 --> 01:03:17,839
it's a very successful nightmare don't

01:03:16,880 --> 01:03:19,599
get me wrong

01:03:17,839 --> 01:03:21,200
we have a problem with the complexity of

01:03:19,599 --> 01:03:21,839
this language and there's a good reason

01:03:21,200 --> 01:03:24,079
for that

01:03:21,839 --> 01:03:26,480
and there's a history for that we have

01:03:24,079 --> 01:03:29,920
50 years of backward compatibility

01:03:26,480 --> 01:03:32,000
because 50 years ago c was invented and

01:03:29,920 --> 01:03:34,559
we struggled with a couple of things

01:03:32,000 --> 01:03:35,760
we definitely would do now better and of

01:03:34,559 --> 01:03:37,920
course we learn and

01:03:35,760 --> 01:03:39,839
of course we make mistakes it's like

01:03:37,920 --> 01:03:42,400
every other software project

01:03:39,839 --> 01:03:43,520
the problem is we have to be backward

01:03:42,400 --> 01:03:46,799
compatible

01:03:43,520 --> 01:03:48,960
so if you don't like things and

01:03:46,799 --> 01:03:50,880
want us to make it better join the

01:03:48,960 --> 01:03:54,720
community we need people

01:03:50,880 --> 01:03:58,000
who help us to do things right

01:03:54,720 --> 01:04:01,480
thank you okay last

01:03:58,000 --> 01:04:03,440
question would you suggest to use void

01:04:01,480 --> 01:04:06,559
[Music]

01:04:03,440 --> 01:04:08,039
f con string are they reference equals

01:04:06,559 --> 01:04:13,760
delete to avoid

01:04:08,039 --> 01:04:16,720
unintentional copy

01:04:13,760 --> 01:04:17,680
oh equals delete is definitely something

01:04:16,720 --> 01:04:21,440
to avoid

01:04:17,680 --> 01:04:24,799
unintentional copies um i think i need

01:04:21,440 --> 01:04:24,799
for this answer a little bit more

01:04:24,839 --> 01:04:30,000
context that's it

01:04:26,799 --> 01:04:30,799
i hope um i hope i could answer a few

01:04:30,000 --> 01:04:35,039
questions

01:04:30,799 --> 01:04:39,039
feel free to um send me um emails or

01:04:35,039 --> 01:04:43,039
uh whatsoever or um you can feedback

01:04:39,039 --> 01:04:45,520
and um and and if you like um

01:04:43,039 --> 01:04:46,079
tweet about this talk um i learned a lot

01:04:45,520 --> 01:04:48,640
i might

01:04:46,079 --> 01:04:49,359
still learn and i do still learn i know

01:04:48,640 --> 01:04:52,000
that

01:04:49,359 --> 01:04:53,280
and um let's all help to make this

01:04:52,000 --> 01:04:56,960
language better

01:04:53,280 --> 01:04:57,839
and so to to that it's especially easy

01:04:56,960 --> 01:05:00,160
to use

01:04:57,839 --> 01:05:01,920
in the general case for the ordinary

01:05:00,160 --> 01:05:05,599
programmer

01:05:01,920 --> 01:05:08,400
thank you very much have a good day and

01:05:05,599 --> 01:05:09,359
vote don't forget to vote it's important

01:05:08,400 --> 01:05:23,839
this year

01:05:09,359 --> 01:05:23,839
thank you

01:05:29,680 --> 01:05:31,760

YouTube URL: https://www.youtube.com/watch?v=TFMKjL38xAI


